{
    "name": "341_B. Bubble Sort Graph",
    "source": "CODEFORCES",
    "description": "Iahub recently has learned Bubble Sort, an algorithm that is used to sort a permutation with n elements a1, a2, ..., an in ascending order. He is bored of this so simple algorithm, so he invents his own graph. The graph (let's call it G) initially has n vertices and 0 edges. During Bubble Sort execution, edges appear as described in the following algorithm (pseudocode). \n    \n    \n      \n    procedure bubbleSortGraph()  \n        build a graph G with n vertices and 0 edges  \n        repeat  \n            swapped = false  \n            for i = 1 to n - 1 inclusive do:  \n                if a[i] > a[i + 1] then  \n                    add an undirected edge in G between a[i] and a[i + 1]  \n                    swap( a[i], a[i + 1] )  \n                    swapped = true  \n                end if  \n            end for  \n        until not swapped   \n        /* repeat the algorithm as long as swapped value is true. */   \n    end procedure  \n    \n\nFor a graph, an independent set is a set of vertices in a graph, no two of which are adjacent (so there are no edges between vertices of an independent set). A maximum independent set is an independent set which has maximum cardinality. Given the permutation, find the size of the maximum independent set of graph G, if we use such permutation as the premutation a in procedure bubbleSortGraph.\n\nInput\n\nThe first line of the input contains an integer n (2 \u2264 n \u2264 105). The next line contains n distinct integers a1, a2, ..., an (1 \u2264 ai \u2264 n).\n\nOutput\n\nOutput a single integer \u2014 the answer to the problem. \n\nExamples\n\nInput\n\n3\n3 1 2\n\n\nOutput\n\n2\n\nNote\n\nConsider the first example. Bubble sort swaps elements 3 and 1. We add edge (1, 3). Permutation is now [1, 3, 2]. Then bubble sort swaps elements 3 and 2. We add edge (2, 3). Permutation is now sorted. We have a graph with 3 vertices and 2 edges (1, 3) and (2, 3). Its maximal independent set is [1, 2].",
    "difficulty": "B",
    "tags": [
        "binary search",
        "data structures",
        "dp"
    ],
    "rating": 1500,
    "public_test": [
        {
            "input": "3\n3 1 2\n",
            "output": "2\n"
        }
    ],
    "generated_test": [
        {
            "input": "3\n3 2 1\n",
            "output": "1\n"
        },
        {
            "input": "5\n3 2 1 4 5\n",
            "output": "3\n"
        },
        {
            "input": "5\n4 1 2 3 5\n",
            "output": "4\n"
        },
        {
            "input": "3\n2 1 3\n",
            "output": "2\n"
        },
        {
            "input": "3\n1 2 3\n",
            "output": "3\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int max_n = 1e5 + 100;\nint t[4 * max_n];\nint n;\nint max_on_seg(int v, int tl, int tr, int l, int r) {\n  if (tl == l && tr == r) return t[v];\n  int m = (tl + tr) >> 1;\n  if (r <= m) return max_on_seg(2 * v, tl, m, l, r);\n  if (l > m) return max_on_seg(2 * v + 1, m + 1, tr, l, r);\n  return max(max_on_seg(2 * v, tl, m, l, m),\n             max_on_seg(2 * v + 1, m + 1, tr, m + 1, r));\n}\nvoid update(int v, int tl, int tr, int x, int d) {\n  if (tl == tr) {\n    t[v] = d;\n  } else {\n    int m = (tl + tr) >> 1;\n    if (x <= m)\n      update(2 * v, tl, m, x, d);\n    else\n      update(2 * v + 1, m + 1, tr, x, d);\n    t[v] = max(t[2 * v], t[2 * v + 1]);\n  }\n}\nint main() {\n  cin >> n;\n  int ans = 0;\n  for (int i = 0; i < n; ++i) {\n    int a;\n    cin >> a;\n    int d = max_on_seg(1, 1, n, 1, a) + 1;\n    ans = max(ans, d);\n    update(1, 1, n, a, d);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nbool umin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\nbool umax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\nint arr[100009], s[100009 << 2], dp[100009];\nvoid upd(int p, int v, int nd, int x, int y) {\n  if (x == y) {\n    s[nd] = v;\n    return;\n  }\n  int mid = (x + y) >> 1;\n  if (p <= mid)\n    upd(p, v, nd << 1, x, mid);\n  else\n    upd(p, v, nd << 1 | 1, mid + 1, y);\n  s[nd] = max(s[nd << 1], s[nd << 1 | 1]);\n}\nint tap(int l, int r, int nd, int x, int y) {\n  if (l > y or x > r) return 0;\n  if (l <= x and y <= r) return s[nd];\n  int mid = (x + y) >> 1;\n  int i1 = tap(l, r, nd << 1, x, mid);\n  int i2 = tap(l, r, nd << 1 | 1, mid + 1, y);\n  return max(i1, i2);\n}\nint main() {\n  int a;\n  scanf(\"%d\", &a);\n  for (int i = 0; i < a; i++) scanf(\"%d\", arr + i);\n  for (int i = a - 1; i >= 0; i--) {\n    dp[i] = tap(arr[i] + 1, a, 1, 1, a) + 1;\n    upd(arr[i], dp[i], 1, 1, a);\n  }\n  int mx = *max_element(dp, dp + a);\n  printf(\"%d\\n\", mx);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma comment(linker, \"/STACK:64000000\")\nconst long long MAXLL = 0x0FFFFFFFFFFFFFFFll;\nconst int MAXINT = 0x0FFFFFFF;\nconst int MAXN = 100005;\nint n;\nint a[MAXN];\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  set<int> st;\n  set<int>::iterator it;\n  st.clear();\n  for (int i = 0; i < n; i++) {\n    st.insert(a[i]);\n    it = st.find(a[i]);\n    it++;\n    if (it != st.end()) st.erase(it);\n  }\n  cout << st.size() << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint l[500010], r[500010], s[500010], a[500010], f[500010];\nint n, i, z, ans;\nint max(int a, int b) {\n  if (a > b) return a;\n  return b;\n}\nvoid build(int x, int a, int b) {\n  int m;\n  l[x] = a;\n  r[x] = b;\n  if (b - a > 1) {\n    m = (a + b) >> 1;\n    build(2 * x, a, m);\n    build(2 * x + 1, m, b);\n  }\n}\nvoid change(int x, int a, int b, int c) {\n  int m;\n  if (r[x] - l[x] == 1) {\n    s[x] = c;\n    return;\n  } else {\n    m = (l[x] + r[x]) >> 1;\n    if (a < m) change(2 * x, a, b, c);\n    if (m < b) change(2 * x + 1, a, b, c);\n    s[x] = max(s[2 * x], s[2 * x + 1]);\n  }\n}\nint query(int x, int a, int b) {\n  int m, ans;\n  if ((a <= l[x]) && (r[x] <= b)) return s[x];\n  m = (l[x] + r[x]) >> 1;\n  ans = 0;\n  if (a < m) ans = max(ans, query(2 * x, a, b));\n  if (m < b) ans = max(ans, query(2 * x + 1, a, b));\n  return ans;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  build(1, 0, n);\n  for (i = 1; i <= n; i++) {\n    if (a[i] - 1)\n      z = query(1, 0, a[i] - 1);\n    else\n      z = 0;\n    f[i] = z + 1;\n    change(1, a[i] - 1, a[i], f[i]);\n  }\n  for (i = 1; i <= n; i++) ans = max(ans, f[i]);\n  printf(\"%d\", ans);\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.lang.reflect.AnnotatedArrayType;\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\n\npublic class Main {\n\n    long b = 31;\n    String fileName = \"\";\n\n\n    //////////////////////    SOLUTION   SOLUTION  SOLUTION    //////////////////////////////\n    long INF = Long.MAX_VALUE / 10000;\n    long MODULO = 1000*1000*1000+7;\n\n    ArrayList<DoubleEdge>[] graph;\n    int[] distFromRoot;\n    int[] distToRoot;\n    int[][] up;\n    int[] tin;\n    int[] tout;\n    int l;\n    int timer;\n    boolean[] primes = new boolean[2000000+100];\n    void solve() throws IOException {\n        int n = readInt();\n        int[] arr = readIntArray(n);\n        long ans = 0;\n        Fenwik fen = new Fenwik(new int[n+1]);\n        for (int i=0; i<n; ++i){\n            long prefMax = fen.getMax(arr[i]);\n            fen.inc(arr[i], (int)prefMax + 1);\n            ans = Math.max(ans, prefMax + 1);\n        }\n        out.println(ans);\n    }\n\n\n    class Vertex implements Comparable<Vertex>{\n        int dist, from;\n        Vertex(int b, int c){\n            this.dist = c;\n            this.from = b;\n        }\n\n        @Override\n        public int compareTo(Vertex o) {\n            return this.dist-o.dist;\n        }\n    }\n    ///////////////////////////////////////////////////////////////////////////////////////////\n    class DoubleEdge{\n        int from, to, dist1, dist2;\n        DoubleEdge(int from, int to, int dist1, int dist2){\n            this.from = from;\n            this.to = to;\n            this.dist1 = dist1;\n            this.dist2 = dist2;\n        }\n    }\n\n    class Edge{\n        int from, to, dist;\n        Edge(int from, int to, int dist){\n            this.from = from;\n            this.to = to;\n            this.dist = dist;\n        }\n    }\n\n    void readUndirectedGraph (int n, int m, int[][] graph) throws IOException{\n        Edge[] edges = new Edge[n-1];\n        int[] countEdges = new int[n];\n        graph = new int[n][];\n        for (int i=0; i<n-1; ++i){\n            int from = readInt() - 1;\n            int to = readInt() - 1;\n            countEdges[from]++;\n            countEdges[to]++;\n            edges[i] = new Edge(from, to, 0);\n        }\n        for (int i=0; i<n; ++i) graph[i] = new int[countEdges[i]];\n        for (int i=0; i<n-1; ++i){\n            graph[edges[i].to][--countEdges[edges[i].to]] = edges[i].dist;\n            graph[edges[i].dist][-- countEdges[edges[i].dist]] = edges[i].to;\n        }\n    }\n    class SparseTable{\n        int[][] rmq;\n        int[] logTable;\n        int n;\n        SparseTable(int[] a){\n            n = a.length;\n            logTable = new int[n+1];\n            for(int i = 2; i <= n; ++i){\n                logTable[i] = logTable[i >> 1] + 1;\n            }\n            rmq = new int[logTable[n] + 1][n];\n            for(int i=0; i<n; ++i){\n                rmq[0][i] = a[i];\n            }\n\n            for(int k=1; (1 << k) < n; ++k){\n                for(int i=0; i + (1 << k) <= n; ++i){\n                    int max1 = rmq[k - 1][i];\n                    int max2 = rmq[k-1][i + (1 << (k-1))];\n                    rmq[k][i] = Math.max(max1, max2);\n                }\n            }\n        }\n\n        int max(int l, int r){\n            int k = logTable[r - l];\n            int max1 = rmq[k][l];\n            int max2 = rmq[k][r - (1 << k) + 1];\n            return Math.max(max1, max2);\n        }\n    }\n    long checkBit(long mask, int bit){\n        return (mask >> bit) & 1;\n    }\n    class Dsu{\n        int[] parent;\n        int countSets;\n        Dsu(int n){\n            countSets = n;\n            parent = new int[n];\n            for(int i=0; i<n; ++i){\n                parent[i] = i;\n            }\n        }\n        int findSet(int a){\n            if(parent[a] == a) return a;\n            parent[a] = findSet(parent[a]);\n            return parent[a];\n        }\n        void unionSets(int a, int b){\n            a = findSet(a);\n            b = findSet(b);\n            if(a!=b){\n                countSets--;\n                parent[a] = b;\n            }\n        }\n    }\n    static int checkBit(int mask, int bit) {\n        return (mask >> bit) & 1;\n    }\n    boolean isLower(char c){\n        return c >= 'a' && c <= 'z';\n    }\n\n    ////////////////////////////////////////////////////////////\n\n    class SegmentTree{\n        int[] t;\n        int n;\n        SegmentTree(int n){\n            t = new int[4*n];\n            build(new int[n+1], 1, 1, n);\n        }\n        void build (int a[], int v, int tl, int tr) {\n            if (tl == tr)\n                t[v] = a[tl];\n            else {\n                int tm = (tl + tr) / 2;\n                build (a, v*2, tl, tm);\n                build (a, v*2+1, tm+1, tr);\n            }\n        }\n\n        void update (int v, int tl, int tr, int l, int r, int add) {\n            if (l > r)\n                return;\n            if (l == tl && tr == r)\n                t[v] += add;\n            else {\n                int tm = (tl + tr) / 2;\n                update (v*2, tl, tm, l, Math.min(r,tm), add);\n                update (v*2+1, tm+1, tr, Math.max(l,tm+1), r, add);\n            }\n        }\n\n        int get (int v, int tl, int tr, int pos) {\n            if (tl == tr)\n                return t[v];\n            int tm = (tl + tr) / 2;\n            if (pos <= tm)\n                return t[v] + get (v*2, tl, tm, pos);\n            else\n                return t[v] + get (v*2+1, tm+1, tr, pos);\n        }\n    }\n    class Fenwik {\n        long[] t;\n        int length;\n\n        Fenwik(int[] a) {\n            length = a.length + 100;\n            t = new long[length];\n\n            for (int i = 0; i < a.length; ++i) {\n                inc(i, a[i]);\n            }\n        }\n\n        void inc(int ind, int delta) {\n            for (; ind < length; ind = ind | (ind + 1)) {\n                t[ind] = Math.max(delta, t[ind]);\n            }\n        }\n\n        long getMax(int r) {\n            long sum = 0;\n            for (; r >= 0; r = (r & (r + 1)) - 1) {\n                sum = Math.max(sum, t[r]);\n            }\n            return sum;\n        }\n    }\n    int gcd(int a, int b){\n        return b == 0 ? a : gcd(b, a%b);\n    }\n    long gcd(long a, long b){\n        return b == 0 ? a : gcd(b, a%b);\n    }\n    long binPow(long a, long b, long m) {\n        if (b == 0) {\n            return 1;\n        }\n        if (b % 2 == 1) {\n            return ((a % m) * (binPow(a, b - 1, m) % m)) % m;\n        } else {\n            long c = binPow(a, b / 2, m);\n            return (c * c) % m;\n        }\n\n    }\n    int minInt(int... values) {\n        int min = Integer.MAX_VALUE;\n        for (int value : values) min = Math.min(min, value);\n        return min;\n    }\n\n    int maxInt(int... values) {\n        int max = Integer.MIN_VALUE;\n        for (int value : values) max = Math.max(max, value);\n        return max;\n    }\n    public static void main(String[] args) throws NumberFormatException, IOException {\n        // TODO Auto-generated method stub\n        new Main().run();\n    }\n\n    void run() throws NumberFormatException, IOException {\n        solve();\n        out.close();\n    };\n\n    BufferedReader in;\n    PrintWriter out;\n\n    StringTokenizer tok;\n    String delim = \" \";\n    Random rnd = new Random();\n\n    Main() throws FileNotFoundException {\n        try {\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new PrintWriter(\"output.txt\");\n        } catch (Exception e) {\n            if (fileName.isEmpty()) {\n                in = new BufferedReader(new InputStreamReader(System.in));\n                out = new PrintWriter(System.out);\n            } else {\n                in = new BufferedReader(new FileReader(fileName + \".in\"));\n                out = new PrintWriter(fileName + \".out\");\n            }\n\n        }\n        tok = new StringTokenizer(\"\");\n    }\n\n    String readLine() throws IOException {\n        return in.readLine();\n    }\n\n    String readString() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            String nextLine = readLine();\n            if (null == nextLine) {\n                return null;\n            }\n\n            tok = new StringTokenizer(nextLine);\n        }\n        return tok.nextToken();\n    }\n\n    int readInt() throws NumberFormatException, IOException {\n        return Integer.parseInt(readString());\n    }\n    byte readByte() throws NumberFormatException, IOException {\n        return Byte.parseByte(readString());\n    }\n    int[] readIntArray (int n) throws NumberFormatException, IOException {\n        int[] a = new int[n];\n        for(int i=0; i<n; ++i){\n            a[i] = readInt();\n        }\n        return a;\n    }\n\n    Integer[] readIntegerArray (int n) throws NumberFormatException, IOException {\n        Integer[] a = new Integer[n];\n        for(int i=0; i<n; ++i){\n            a[i] = readInt();\n        }\n        return a;\n    }\n\n    long readLong() throws NumberFormatException, IOException {\n        return Long.parseLong(readString());\n    }\n\n    double readDouble() throws NumberFormatException, IOException {\n        return Double.parseDouble(readString());\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, k, l, idx;\nvector<int> a(2, -1);\nint main() {\n  cin >> n;\n  a.back() = 1000000010;\n  for (int i = 0; i < n; i++) {\n    cin >> m;\n    int left = 0, right = a.size() - 1, l;\n    while (true) {\n      l = (left + right) / 2;\n      if (a[l] <= m && m < a[l + 1]) {\n        a[l + 1] = m;\n        if (l + 2 == a.size()) a.push_back(1000000010);\n        break;\n      }\n      if (a[l] > m)\n        right = l;\n      else\n        left = l + 1;\n    }\n  }\n  cout << a.size() - 2;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100010] = {0};\nint b[100010] = {0};\nint getpos(int lst[], int start, int end, int val) {\n  int mid = 0;\n  while (start < end - 1) {\n    mid = (start + end) >> 1;\n    if (lst[mid] >= val) {\n      end = mid - 1;\n    } else {\n      start = mid;\n    }\n  }\n  mid = (start + end) >> 1;\n  while (mid <= end && lst[mid] < val) {\n    mid++;\n  }\n  while (mid > end || lst[mid] >= val) {\n    mid--;\n  }\n  return mid + 1;\n}\nint main() {\n  int n = 0, k = 0;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  for (int i = 0; i < n; i++) {\n    if (a[i] > b[k]) {\n      k++;\n      b[k] = a[i];\n    } else {\n      int pos = getpos(b, 1, k, a[i]);\n      b[pos] = a[i];\n    }\n  }\n  cout << k << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class BubbleSortGraph {\n    public static void main(String[] args) {\n        int n, a[];\n        try(Scanner in = new Scanner(System.in)) {\n            n = in.nextInt();\n            a = new int [n];\n            for(int i = 0; i < n; i++)\n                a[i] = in.nextInt();\n        }\n        \n        BinTreeSeg tree = new BinTreeSeg(n + 1);\n        for(int i = 0; i < n; i++)\n            tree.set(a[i], tree.get_max(a[i]) + 1);\n        \n        System.out.print(tree.get_max(n + 1));\n    }\n}\n\nclass BinTreeSeg {\n    private int t[];\n    private int size;\n    \n    public BinTreeSeg(int sz) {\n        size = sz;\n        t = new int [size * 4];\n        for(int i = 0; i < t.length; i++)\n            t[i] = 0;\n    }\n    \n    private int _get_max(int v, int tl, int tr, int l, int r) {\n        if(l > r)\n            return 0;\n        if(l == tl & r == tr)\n            return t[v];\n        int tm = (tl + tr) / 2;\n        return Math.max(_get_max(v * 2, tl, tm, l, Math.min(r, tm)),\n                _get_max(v * 2 + 1, tm + 1, tr, Math.max(l, tm + 1), r));\n    }\n    \n    public int get_max(int x) {\n        return _get_max(1, 0, size - 1, 0, x - 1);\n    }\n    \n    private void _set(int v, int tl, int tr, int i, int val) {\n        if(tl == tr)\n            t[v] = val;\n        else {\n            int tm = (tl + tr) / 2;\n            if(i <= tm)\n                _set(v * 2, tl, tm, i, val);\n            else\n                _set(v * 2 + 1, tm + 1, tr, i, val);\n            t[v] = Math.max(t[v * 2], t[v * 2 + 1]);\n        }\n    }\n    \n    public void set(int i, int val) {\n        _set(1, 0, size - 1, i, val);\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint a[100010];\nint b[100010];\nint main() {\n  while (~scanf(\"%d\", &n)) {\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n    for (int i = 1; i <= n; i++) b[i] = 10000000;\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n      int l = 0, r = i - 1;\n      while (l < r) {\n        int mid = (l + r) / 2 + 1;\n        if (b[mid] < a[i])\n          l = mid;\n        else\n          r = mid - 1;\n      }\n      b[l + 1] = min(b[l + 1], a[i]);\n      ans = max(ans, l + 1);\n    }\n    printf(\"%d\\n\", ans);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long a[100005], t[100005], n;\nlong long query(long long i) {\n  long long ans = 0;\n  while (i) {\n    ans = max(ans, t[i]);\n    i -= (i & -i);\n  }\n  return ans;\n}\nvoid update(long long i) {\n  long long val = query(i - 1) + 1;\n  while (i <= n) {\n    t[i] = max(t[i], val);\n    i += (i & -i);\n  }\n}\nint32_t main() {\n  long long i;\n  cin >> n;\n  for (i = 1; i <= n; i++) cin >> a[i];\n  for (i = 1; i <= n; i++) update(a[i]);\n  cout << query(n) << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1) {\n  cerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args) {\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \" : \" << arg1 << \" | \";\n  __f(comma + 1, args...);\n}\nlong long int prod(long long int a, long long int b) {\n  long long int x, d;\n  if (b == 0)\n    return 1;\n  else {\n    d = prod(a, b / 2);\n    x = (d * d) % 1000000007;\n    if (b % 2 == 0)\n      return x;\n    else\n      return (x * (a % 1000000007)) % 1000000007;\n  }\n}\nlong long int CeilIndex(std::vector<long long int>& v, long long int l,\n                        long long int r, long long int key) {\n  while (r - l > 1) {\n    long long int m = l + (r - l) / 2;\n    if (v[m] >= key)\n      r = m;\n    else\n      l = m;\n  }\n  return r;\n}\nlong long int LongestIncreasingSubsequenceLength(\n    std::vector<long long int>& v) {\n  if (v.size() == 0) return 0;\n  std::vector<long long int> tail(v.size(), 0);\n  long long int length = 1;\n  tail[0] = v[0];\n  for (size_t i = 1; i < v.size(); i++) {\n    if (v[i] < tail[0])\n      tail[0] = v[i];\n    else if (v[i] > tail[length - 1])\n      tail[length++] = v[i];\n    else\n      tail[CeilIndex(tail, -1, length - 1, v[i])] = v[i];\n  }\n  return length;\n}\nint main() {\n  long long int i, n, a;\n  vector<long long int> v;\n  scanf(\"%lld\", &n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%lld\", &a);\n    v.push_back(a);\n  }\n  cout << LongestIncreasingSubsequenceLength(v) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct dt {\n  int a, b, c;\n};\ndt dat[100005];\nint bit[100005];\nint ans, tmp;\nint n;\nbool cmp1(dt x, dt y) { return (x.a < y.a); }\nbool cmp2(dt x, dt y) { return (x.b < y.b); }\ninline int bitquery(int x) {\n  int res = 0;\n  for (; x > 0; x -= (x & (-x))) res = ((res) > (bit[x]) ? (res) : (bit[x]));\n  return res;\n}\ninline void bitupdate(int x, int y) {\n  for (; x < 100005; x += x & (-x)) bit[x] = ((y) > (bit[x]) ? (y) : (bit[x]));\n}\nint main() {\n  cin.sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n;\n  for (int i = 0; i < n; ++i) {\n    cin >> dat[i].c;\n    dat[i].a = dat[i].c;\n    dat[i].b = i;\n  }\n  sort(dat, dat + n, cmp1);\n  for (int i = 0; i < n; ++i) {\n    if (i > 0 && dat[i - 1].c == dat[i].c)\n      dat[i].a = dat[i - 1].a;\n    else\n      dat[i].a = i + 2;\n  }\n  sort(dat, dat + n, cmp2);\n  ans = 0;\n  for (int i = 0; i < n; ++i) {\n    tmp = bitquery(dat[i].a - 1) + 1;\n    ans = ((ans) > (tmp) ? (ans) : (tmp));\n    bitupdate(dat[i].a, tmp);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 7;\nlong long n, m, k, x, y, l, r, ans, a[N], L[N];\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n;\n  for (int i = 0; i < (int)(n); ++i) cin >> a[i];\n  for (int i = 0; i < (int)(n); ++i) {\n    l = 1, r = ans;\n    while (l <= r) {\n      m = ceil((l + r) / 2);\n      if (a[L[m]] < a[i])\n        l = m + 1;\n      else\n        r = m - 1;\n    }\n    k = l;\n    L[k] = i;\n    if (k > ans) ans = k;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 3e5 + 9;\nvoid nen_so(vector<int> &a) {\n  set<int> s(a.begin(), a.end());\n  vector<int> b(s.begin(), s.end());\n  for (int &x : a) x = lower_bound(b.begin(), b.end(), x) - b.begin() + 1;\n}\nint bit[N], n;\nvoid update(int pos, int x) {\n  for (; pos <= n; pos += (pos & (-pos))) bit[pos] = max(bit[pos], x);\n}\nint get(int pos) {\n  int cnt = 0;\n  for (; pos > 0; pos -= (pos & (-pos))) cnt = max(cnt, bit[pos]);\n  return cnt;\n}\nint main() {\n  cin >> n;\n  vector<int> a(n);\n  for (int &x : a) cin >> x;\n  for (int x : a) update(x, get(x - 1) + 1);\n  cout << get(n);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100005], b[100005], n;\nint fin(int len, int p) {\n  int l, r, mid;\n  l = 1, r = len, mid = (l + r) >> 1;\n  while (l <= r) {\n    if (p > b[mid])\n      l = mid + 1;\n    else if (p < b[mid])\n      r = mid - 1;\n    else\n      return mid;\n    mid = (l + r) >> 1;\n  }\n  return l;\n}\nint LIS() {\n  int i, j, len = 1;\n  b[1] = a[0];\n  for (i = 1; i < n; i++) {\n    j = fin(len, a[i]);\n    b[j] = a[i];\n    if (j >= len) len = j;\n  }\n  return len;\n}\nint main() {\n  int i;\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) scanf(\"%d\", a + i);\n  printf(\"%d\", LIS());\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100010;\nint n, BIT[N];\nvoid update(int idx, int val) {\n  while (idx <= n) {\n    BIT[idx] = max(val, BIT[idx]);\n    idx += idx & -idx;\n  }\n}\nint get(int idx) {\n  int ret = 0;\n  while (idx > 0) {\n    ret = max(BIT[idx], ret);\n    idx -= idx & -idx;\n  }\n  return ret;\n}\nint main() {\n  scanf(\"%d\", &n);\n  int ans = 0;\n  for (int i = 0, x; i < n; ++i) {\n    scanf(\"%d\", &x);\n    update(x, get(x) + 1);\n  }\n  printf(\"%d\\n\", get(n));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int a[200020], dp[200020], n, maxx = 0, m;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  for (int i = 0; i < n; i++) {\n    dp[i] = 0;\n  }\n  for (int i = 0; i < n; i++) {\n    if (a[i] > dp[maxx]) {\n      maxx++;\n      dp[maxx] = a[i];\n    } else {\n      m = 1;\n      while (a[i] > dp[m]) {\n        m++;\n      }\n      if (dp[m] > a[i]) {\n        dp[m] = a[i];\n      }\n    }\n  }\n  cout << maxx;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n\tvoid solve() {\n\t\tint n = sc.nextInt();\n\t\tint[] a = sc.nextIntArray(n);\n\n\t\tint inf = 1001001001;\n\t\tint[] dp = new int[n+1];\n\t\tArrays.fill(dp, inf);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint index = lower_bound(dp, a[i]);\n\t\t\tdp[index] = a[i];\n\t\t}\n\n\t\tint ans = lower_bound(dp, inf);\n\t\tout.println(ans);\n\n\t}\n\n\tint lower_bound(int[] a, int val) {\n\t\tint lo = -1;\n\t\tint hi = a.length;\n\t\twhile (hi - lo > 1) {\n\t\t\tint mid = (hi + lo) >> 1;\n\t\t\tif (a[mid] < val) lo = mid; else hi = mid;\n\t\t}\n\t\treturn hi;\n\t}\n\n\n\tvoid print(int[] a) {\n\t\tout.print(a[0]);\n\t\tfor (int i = 1; i < a.length; i++) out.print(\" \" + a[i]);\n\t\tout.println();\n\t}\n\n\tstatic void tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\tstatic void fill(int[][] a, int val) {\n\t\tfor(int i = 0; i < a.length; i++) Arrays.fill(a[i], val);\n\t}\n\tstatic void fill(int[][][] a, int val) {\n\t\tfor(int i = 0; i < a.length; i++) fill(a[i], val);\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tMyScanner sc = null;\n\tPrintWriter out = null;\n\tpublic void run() throws Exception {\n\t\tsc = new MyScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tfor (;sc.hasNext();) {\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t}\n\t\tout.close();\n\t}\n\n\tclass MyScanner {\n\t\tString line;\n\t\tBufferedReader reader;\n\t\tStringTokenizer tokenizer;\n\n\t\tpublic MyScanner(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream));\n\t\t\ttokenizer = null;\n\t\t}\n\t\tpublic void eat() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tline = reader.readLine();\n\t\t\t\t\tif (line == null) {\n\t\t\t\t\t\ttokenizer = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttokenizer = new StringTokenizer(line);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic String next() {\n\t\t\teat();\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\tpublic boolean hasNext() {\n\t\t\teat();\n\t\t\treturn (tokenizer != null && tokenizer.hasMoreElements());\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint getCeil(int *arr, int s, int e, int x) {\n  while (s <= e) {\n    if (s == e) return s;\n    if (s + 1 == e) {\n      if (arr[s] > x)\n        return s;\n      else\n        return e;\n    }\n    int mid = (s + e) / 2;\n    if (arr[mid] > x && arr[mid - 1] <= x)\n      return mid;\n    else if (arr[mid] > x && arr[mid - 1] > x)\n      e = mid - 1;\n    else if (arr[mid] < x)\n      s = mid + 1;\n  }\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  int arr[n];\n  for (int i = 0; i < n; i++) scanf(\"%d\", &arr[i]);\n  int seq[n];\n  seq[0] = arr[0];\n  int curLen = 1;\n  for (int i = 1; i < n; i++) {\n    if (arr[i] < seq[0])\n      seq[0] = arr[i];\n    else if (arr[i] >= seq[curLen - 1])\n      seq[curLen++] = arr[i];\n    else\n      seq[getCeil(seq, 0, curLen - 1, arr[i])] = arr[i];\n  }\n  printf(\"%d\\n\", curLen);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int oo = 0x3f3f3f3f;\nconst double eps = 1e-9;\nconst int maxN = 100 * 1024;\nint N, K;\nint a[maxN];\nint lis[maxN];\nint main() {\n  cin >> N;\n  for (int i = (1); i < (N + 1); i++) cin >> a[i];\n  for (int i = (1); i < (N + 2); i++) lis[i] = oo;\n  for (int i = (1); i < (N + 1); i++) {\n    int len = upper_bound(lis + 1, lis + N + 1, a[i]) - lis;\n    lis[len] = min(lis[len], a[i]);\n  }\n  int best = lower_bound(lis + 1, lis + N + 2, oo) - lis - 1;\n  cout << best << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int i, j, k;\n  map<int, int> M;\n  int n, ans = 0;\n  scanf(\"%d\", &n);\n  M[0] = 0;\n  for (i = 1; i <= n; ++i) {\n    scanf(\"%d\", &j);\n    map<int, int>::iterator it = M.lower_bound(j);\n    k = (--it)->second + 1;\n    for (++it; it != M.end();) {\n      if (it->second <= k)\n        M.erase(it++);\n      else\n        break;\n    }\n    M[j] = k;\n    ans = max(ans, k);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, i, x, b[110000];\nvoid modify(int x, int y) {\n  for (; x <= n; x += x & -x) b[x] = ((b[x]) > (y) ? (b[x]) : (y));\n}\nint get(int x) {\n  int ans = 0;\n  for (; x; x -= x & -x) ans = ((ans) > (b[x]) ? (ans) : (b[x]));\n  return ans;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; i++) {\n    scanf(\"%d\", &x);\n    modify(x, get(x) + 1);\n  }\n  printf(\"%d\\n\", get(n));\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:512000000\")\nusing namespace std;\ntemplate <class T>\ninline T sqr(T x) {\n  return x * x;\n}\ntemplate <class T>\ninline string tostr(const T &x) {\n  stringstream ss;\n  ss << x;\n  return ss.str();\n}\nconst double EPS = 1e-6;\nconst int INF = 1000 * 1000 * 1000;\nconst char CINF = 102;\nconst long long LINF = INF * 1ll * INF;\nconst long double PI = 3.1415926535897932384626433832795;\nlong long gcd(long long a, long long b) { return a ? gcd(b % a, a) : b; }\nunsigned int gcd(unsigned int a, unsigned int b) {\n  return a ? gcd(b % a, a) : b;\n}\nint P[110000];\nint D[110000];\nint n;\nint main(int argc, char **argv) {\n  cin >> n;\n  for (int i = 0; i < (n); ++i) {\n    cin >> P[i];\n    D[i + 1] = INF;\n  }\n  D[n + 1] = INF;\n  D[0] = -INF;\n  for (int i = 0; i < (n); ++i) {\n    *lower_bound(D, D + n, P[i]) = P[i];\n  }\n  int r = 0;\n  while (D[r] != INF) ++r;\n  --r;\n  cout << r;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nint increasingSubsequece2(int a[], int n) {\n  vector<int> temp;\n  vector<int>::iterator v;\n  temp.push_back(a[0]);\n  for (int i = 1; i < n; ++i) {\n    if (a[i] > temp.back())\n      temp.push_back(a[i]);\n    else {\n      v = upper_bound(temp.begin(), temp.end(), a[i]);\n      *v = a[i];\n    }\n  }\n  return temp.size();\n}\nint bit[1000005] = {0};\nvoid update(int i, int val) {\n  while (i < 1000005) {\n    bit[i] = max(bit[i], val);\n    i += (i & (-i));\n  }\n}\nint query(int i) {\n  int ans = 0;\n  while (i > 0) {\n    ans = max(ans, bit[i]);\n    i -= (i & -i);\n  }\n  return ans;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(0);\n  int n;\n  cin >> n;\n  int a[n];\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  cout << increasingSubsequece2(a, n) << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "/*\nKeep solving problems. \n*/\nimport java.text.SimpleDateFormat;\nimport java.util.*;\nimport java.io.*;\n\npublic class CFA {\n\n    BufferedReader br;\n    PrintWriter out;\n    StringTokenizer st;\n    boolean eof;\n    final long MOD = 1000L * 1000L * 1000L + 7;\n\n    class BIT {\n        private int[] fen;\n        private int n;\n        void initPara(int[] arr) {\n            n = arr.length;\n            fen = new int[1 + n];\n            //Arrays.fill(fen, Integer.MAX_VALUE);\n        }\n        void update(int p, int val){ //add val to tree node at p and all its parent, p is 0-based\n            p++;\n            for(int i = p; i <= n; i += i & -i)\n                fen[i] = Math.max(fen[i], val);\n        }\n        int sum(int p){ //get sum between [0, p], p is 0-based\n            int res = Integer.MIN_VALUE;\n            p++;\n            for(int i = p; i > 0; i -= i & -i)\n                res = Math.max(res, fen[i]);\n            return res;\n        }\n    }\n\n    class Node implements Comparable<Node> {\n        int value;\n        int idx;\n        public Node(int value, int idx) {\n            this.value = value;\n            this.idx = idx;\n        }\n\n        @Override\n        public int compareTo(Node o) {\n            return this.value - o.value;\n        }\n\n        @Override\n        public String toString() {\n            return \"value: \" + value + \"; idx: \" + idx;\n        }\n    }\n    void solve() throws IOException {\n        int n = nextInt();\n        int[] arr = nextIntArr(n);\n        Node[] nds = new Node[n];\n        for (int i = 0; i < n; i++) {\n            nds[i] = new Node(arr[i], i);\n        }\n        Arrays.sort(nds);\n        BIT ins = new BIT();\n        ins.initPara(arr);\n\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            int tmp = ins.sum(nds[i].idx);\n\n            res = Math.max(res, tmp + 1);\n            ins.update(nds[i].idx, tmp + 1);\n        }\n\n        out(res);\n    }\n\n    void shuffle(int[] a) {\n        int n = a.length;\n        for(int i = 0; i < n; i++) {\n            int r = i + (int) (Math.random() * (n - i));\n            int tmp = a[i];\n            a[i] = a[r];\n            a[r] = tmp;\n        }\n    }\n    private void outln(Object o) {\n        out.println(o);\n    }\n    private void out(Object o) {\n        out.print(o);\n    }\n    public CFA() throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n    public static void main(String[] args) throws IOException {\n        new CFA();\n    }\n\n    public long[] nextLongArr(int n) throws IOException{\n        long[] res = new long[n];\n        for(int i = 0; i < n; i++)\n            res[i] = nextLong();\n        return res;\n    }\n    public int[] nextIntArr(int n) throws IOException {\n        int[] res = new int[n];\n        for(int i = 0; i < n; i++)\n            res[i] = nextInt();\n        return res;\n    }\n    public String nextToken() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                eof = true;\n                return null;\n            }\n        }\n        return st.nextToken();\n    }\n    public String nextString() {\n        try {\n            return br.readLine();\n        } catch (IOException e) {\n            eof = true;\n            return null;\n        }\n    }\n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n    public long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n    public double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\n/**\n *\n * @author Trung Pham\n */\npublic class D {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner();\n        PrintWriter out = new PrintWriter(System.out);\n        int n = in.nextInt();\n        int[] data = new int[n];\n        for (int i = 0; i < n; i++) {\n            data[i] = in.nextInt();\n        }\n        int[] dp = new int[n];\n        dp[0] = data[0];\n\n        int j = 0;\n        for (int i = 1; i < n; i++) {\n            if (data[i] > dp[j]) {\n                j++;\n                dp[j] = data[i];\n            } else  {\n                int hi = j;\n                int low = 0;\n                while (hi > low ) {\n                    int mid = (hi + low) / 2;\n                    if (dp[mid] > data[i]) {\n                        hi = mid - 1;\n                    }else{\n                        low = mid + 1;\n                    }\n                }\n                if(dp[low] < data[i]){\n                    low++;\n                }\n                dp[low] = Math.min(dp[low], data[i]);\n            }\n        }\n//        for(int i : dp){\n//            System.out.println(i);\n//        }\n        out.print(j + 1);\n        out.close();\n\n\n    }\n\n    static class Scanner {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public Scanner() {\n            //System.setOut(new PrintStream(new BufferedOutputStream(System.out), true));\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public String next() {\n\n\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (Exception e) {\n                    throw new RuntimeException();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            st = null;\n            try {\n                return br.readLine();\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n\n        public boolean endLine() {\n            try {\n                String next = br.readLine();\n                while (next != null && next.trim().isEmpty()) {\n                    next = br.readLine();\n                }\n                if (next == null) {\n                    return true;\n                }\n                st = new StringTokenizer(next);\n                return st.hasMoreTokens();\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n    }\n}\n"
        },
        {
            "language": 1,
            "solution": "from bisect import bisect\nn, oo = input(), 1 << 20\na = [oo] * n\nfor x in map(int, raw_input().split()):\n  a[bisect(a, x)] = x\nprint bisect(a, oo - 1)\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint n, w[100001], i, a, B, E, M, SZ;\nint main() {\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", &a);\n    if (!i) {\n      w[++SZ] = a;\n      continue;\n    }\n    if (w[SZ] < a) {\n      w[++SZ] = a;\n      continue;\n    }\n    B = 1, E = SZ;\n    while (B <= E) {\n      M = (B + E + 1) >> 1;\n      if (w[M] > a && a > w[M - 1]) {\n        break;\n      }\n      if (w[M] < a)\n        B = M + 1;\n      else\n        E = M - 1;\n    }\n    w[M] = a;\n  }\n  printf(\"%d\\n\", SZ);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint vt[100005], it[100005];\nint n;\nvoid update(int pos, int val) {\n  int u = pos;\n  while (u <= n) {\n    if (it[u] < val) it[u] = val;\n    u = u + (u & (-u));\n  }\n}\nint query(int pos) {\n  int u = pos;\n  int res = 0;\n  while (u >= 1) {\n    if (it[u] > res) res = it[u];\n    u = u - (u & (-u));\n  }\n  return res;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    int tmp;\n    scanf(\"%d\", &tmp);\n    vt[tmp] = i;\n  }\n  for (int i = 1; i <= n; i++) it[i] = 0;\n  for (int i = 1; i <= n; i++) {\n    int tmp = query(vt[i]);\n    update(vt[i], tmp + 1);\n  }\n  printf(\"%d\", query(n));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 131334;\nint d[MAXN + 1];\nconst int INF = 1e9;\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vector<int> a(n);\n  for (int i = 0; i < n; ++i) scanf(\"%d\", &a[i]);\n  d[0] = -INF;\n  for (int i = 1; i <= n; ++i) d[i] = INF;\n  for (int i = 0; i < n; i++) {\n    int j = int(upper_bound(d, d + n, a[i]) - d);\n    if (d[j - 1] < a[i] && a[i] < d[j]) d[j] = a[i];\n  }\n  int ans = 0;\n  for (int i = 0; i < n + 1; ++i)\n    if (d[i] != INF) ans = i;\n  cout << ans;\n  puts(\"\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, a[100001], f[100001];\nint calc(int now) {\n  int will = 0;\n  for (; now; now -= now & (-now)) will = max(will, f[now]);\n  return (will);\n}\ninline void insert(int x, int y) {\n  for (int now = x; now <= n; now += now & (-now)) f[now] = max(f[now], y);\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  int ans = 0;\n  memset(f, 0, sizeof(f));\n  for (int i = 1; i <= n; i++) {\n    int now = calc(a[i] - 1) + 1;\n    ans = max(now, ans);\n    insert(a[i], now);\n  }\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, arr[500000], fen[500000];\nvoid update(int index, int val) {\n  while (index <= n) {\n    fen[index] = max(fen[index], val);\n    index += index & -index;\n  }\n}\nint query(int index) {\n  int sum = 0;\n  while (index > 0) {\n    sum = max(fen[index], sum);\n    index -= index & -index;\n  }\n  return sum;\n}\nint main() {\n  int i, ans = 0;\n  cin >> n;\n  for (i = 0; i < n; i++) cin >> arr[i];\n  for (i = 0; i < n; i++) {\n    update(arr[i], query(arr[i]) + 1);\n  }\n  cout << query(n);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MAXN = 100000;\nint a[MAXN + 1];\nint que[MAXN + 1], len;\nint main() {\n  int n;\n  int i;\n  int high, low, median;\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n  len = 1;\n  for (i = 1; i <= n; ++i) {\n    high = len;\n    low = 0;\n    while (high - low > 1) {\n      median = (high + low) >> 1;\n      if (que[median] > a[i])\n        high = median;\n      else\n        low = median;\n    }\n    if (low + 1 == len)\n      que[len++] = a[i];\n    else if (que[low + 1] > a[i])\n      que[low + 1] = a[i];\n  }\n  printf(\"%d\", len - 1);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint inp[100003], m[100003];\nint main() {\n  int n, i, l, lo, hi, mid;\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) scanf(\"%d\", &inp[i]);\n  l = 0;\n  for (i = 0; i < n; i++) {\n    lo = 0;\n    hi = l;\n    while (lo < hi) {\n      mid = (lo + hi + 1) / 2;\n      if (m[mid] < inp[i])\n        lo = mid;\n      else\n        hi = mid - 1;\n    }\n    if (lo == l) {\n      l = lo + 1;\n      m[l] = inp[i];\n    } else if (inp[i] < m[lo + 1])\n      m[lo + 1] = inp[i];\n  }\n  printf(\"%d\\n\", l);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline void sfr(int *a) {\n  char c = 0;\n  while (c < 33) c = fgetc(stdin);\n  *a = 0;\n  while (c > 33) {\n    *a = *a * 10 + c - '0';\n    c = fgetc(stdin);\n  }\n}\ninline void sfp(int a) {\n  char c[1000];\n  sprintf(c, \"%d\", a);\n  puts(c);\n}\nint A[100010];\nint L[100010];\nint main() {\n  int n;\n  cin >> n;\n  ;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &A[i]);\n  }\n  int m = 0;\n  for (int i = 0; i < n; i++) {\n    int j = lower_bound(L, L + m, A[i]) - L;\n    L[j] = A[i];\n    if (j == m) m += 1;\n  }\n  sfp(m);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int i, j, n, top, temp;\n  int stack[100001];\n  cin >> n;\n  top = 0;\n  stack[0] = -1;\n  for (i = 0; i < n; i++) {\n    cin >> temp;\n    if (temp > stack[top]) {\n      stack[++top] = temp;\n    } else {\n      int low = 1, high = top;\n      int mid;\n      while (low <= high) {\n        mid = (low + high) / 2;\n        if (temp > stack[mid]) {\n          low = mid + 1;\n        } else {\n          high = mid - 1;\n        }\n      }\n      stack[low] = temp;\n    }\n  }\n  cout << top << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class Main {\n    //data-->\n    static final int INF_R = 300000;\n    static int[] T;\n    static int n;\n    //<--\n\n    static void input(){\n        try{\n            Scanner sc = new Scanner(System.in);\n            n = sc.nextInt();\n            T = new int[4*n+10];\n            for(int i = 1; i <= 4*n; i++)T[i]=0;\n            sc.close();\n        }catch(Exception e){\n            System.exit(0);\n        }\n    }\n    static int get(int v, int tl, int tr, int l, int r){\n        if(r < tl || tr < l)return 0;\n        if(r >= tr && l <= tl)return T[v];\n        int tm = (tl+tr)/2;\n        int result_l = get(2*v, tl, tm, l, r);\n        int result_r = get(2*v+1, tm+1, tr, l, r);\n        return(Math.max(result_l,result_r));\n    }\n    static void update(int v, int tl, int tr, int pos, int x){\n        if(pos < tl || tr < pos)return;\n        if(pos >= tr && pos <= tl)T[v] = x; else{\n            int tm = (tl + tr) / 2;\n            update(2 * v, tl, tm, pos, x);\n            update(2 * v+1, tm + 1, tr, pos, x);\n            T[v] = Math.max(T[2 * v], T[2 * v + 1]);\n        }\n    }\n\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        int ans = 0;\n        T = new int[4*n+10];\n        for(int i = 0; i <= 4*n; i++)T[i]=0;\n        for(int i = 1; i <= n; i++){\n            int a;\n            a = sc.nextInt();\n            int mx = get(1,0,n, 0, a-1);\n            ans = Math.max(ans, mx+1);\n            update(1,0,n,a,mx+1);\n        }\n        System.out.print(ans);\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod7 = 1000000007;\nconst long long mod9 = 1000000009;\nconst int linf = 2000000000;\nconst long long llinf = 1000000000000000000ll;\nifstream in(\"series.in\");\nofstream out(\"series.out\");\nint tr[400004];\nint arr[100001];\nint ans[100001];\nint x, key;\nvoid Set(int v, int L, int R) {\n  if (L == R)\n    tr[v] = key;\n  else {\n    int m = (L + R) / 2;\n    if (m >= x)\n      Set(v * 2, L, m);\n    else\n      Set(v * 2 + 1, m + 1, R);\n    tr[v] = max(tr[v * 2], tr[v * 2 + 1]);\n  }\n}\nint get(int v, int l, int r, int L, int R) {\n  if (l > r) return 0;\n  if (L == l && R == r) return tr[v];\n  int m = (L + R) >> 1;\n  return max(get(v * 2, l, min(m, r), L, m),\n             get(v * 2 + 1, max(l, m + 1), r, m + 1, R));\n}\nint main() {\n  int n, answer = 1;\n  cin >> n;\n  for (int i = 1; i <= n; ++i) cin >> arr[i];\n  for (int i = 1; i <= n; ++i) {\n    x = arr[i];\n    ans[i] = get(1, 1, x - 1, 1, n) + 1;\n    key = ans[i];\n    Set(1, 1, n);\n    answer = max(ans[i], answer);\n  }\n  cout << answer;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\n\nimport javax.tools.DocumentationTool.Location;\n\nimport java.math.*;\nimport java.net.StandardSocketOptions;\n\npublic class Main {\n\n\tstatic long sx = 0, sy = 0, mod = (long) (998244353);\n\n\tstatic ArrayList<Integer>[] a;\n\tstatic ArrayList<Long> p;\n\tstatic HashMap<ArrayList<Integer>, Long> hm = new HashMap<>();\n\tstatic Double[][] dp;\n\tstatic boolean[][] vis;\n\tstatic long[] far;\n\tpublic static PrintWriter out = new PrintWriter(System.out);\n\tstatic ArrayList<pair> pa = new ArrayList<>();\n\tstatic long[] fact = new long[(int) 1e6];\n\tstatic StringBuilder sb = new StringBuilder();\n\tstatic boolean cycle = false;\n\tstatic long mo = (long) (1e9 + 7);\n\tstatic int[] c, col;\n\tstatic int n = 0, m, x, k;\n\tstatic int ans = Integer.MAX_VALUE;\n\tstatic boolean b = false;\n\tstatic boolean[] reach = new boolean[6000];\n\tstatic int[][] par;\n\tstatic int[] depth;\n\tstatic int[] size;\n\tstatic long[] pow;\n\tstatic int time = 0;\n\tstatic int[] disc;\n\tstatic int[] low;\n\tstatic char[][] ch;\n\tstatic int cnt = 0;\n\tstatic int[][] dirs = { { -1, 0 }, { 0, 1 }, { 1, 0 }, { 0, -1 }, };\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// Scanner scn = new Scanner(new BufferedReader(new\n\t\t// InputStreamReader(System.in)));\n\n\t\tReader scn = new Reader();\n\n\t\tint n = scn.nextInt();\n\t\tint[] a = scn.nextIntArray(n);\n\n\t\tTreeMap<Integer, Integer> hm = new TreeMap<>();\n\t\tint ans = 0;\n\n\t\tfor (int i = 0; i < n; i++) {\n\n\t\t\thm.put(a[i], 1);\n\t\t\tif (hm.lowerKey(a[i]) != null)\n\t\t\t\thm.put(a[i], hm.get(hm.lowerKey(a[i])) + 1);\n\n\t\t\twhile (hm.higherKey(a[i]) != null && hm.get(hm.higherKey(a[i])) < hm.get(a[i]))\n\t\t\t\thm.remove(hm.higherKey(a[i]));\n\n\t\t\tans = Math.max(ans, hm.get(a[i]));\n\t\t}\n\n\t\tSystem.out.println(ans);\n\t}\n\n\t// _________________________TEMPLATE_____________________________________________________________\n\n\t// public static long lcm(long x, long y) {\n\t//\n\t// return (x * y) / gcd(x, y);\n\t// }\n\t//\n\t// private static long gcd(long x, long y) {\n\t// if (x == 0)\n\t// return y;\n\t//\n\t// return gcd(y % x, x);\n\t// }\n\n\t//\n\t// static class comp implements Comparator<Integer> {\n\t//\n\t// @Override\n\t// public int compare(Integer p1, Integer p2) {\n\t//\n\t// return p2 - p1;\n\t//\n\t// }\n\t// }\n\t//\n\t// }\n\t//\n\t// public static long pow(long a, long b, long mod) {\n\t//\n\t// if (b < 0)\n\t// return 0;\n\t// if (b == 0 || b == 1)\n\t// return (long) Math.pow(a, b);\n\t//\n\t// if (b % 2 == 0) {\n\t//\n\t// long ret = pow(a, b / 2, mod);\n\t// ret = (ret % mod * ret % mod) % mod;\n\t// return ret;\n\t// }\n\t//\n\t// else {\n\t// return ((pow(a, b - 1, mod) % mod) * a % mod) % mod;\n\t// }\n\t// }\n\n\tprivate static class pair implements Comparable<pair> {\n\n\t\tint u, v;\n\t\tlong x, y, c, k, cost;\n\n\t\tpair(int a, int b, long o) {\n\t\t\tthis.u = a;\n\t\t\tthis.v = b;\n\t\t\tthis.cost = o;\n\t\t}\n\n\t\tpair() {\n\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(pair o) {\n\n\t\t\tif (this.cost < o.cost)\n\t\t\t\treturn -1;\n\t\t\telse if (this.cost > o.cost)\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn 0;\n\n\t\t}\n\n\t\t// @Override\n\t\t//\n\t\t// public int hashCode() {\n\t\t// return i;\n\t\t// }\n\t\t//\n\t\t// @Override\n\t\t//\n\t\t// public boolean equals(Object o) {\n\t\t//\n\t\t// pair p = (pair) o;\n\t\t// return this.i == p.i;\n\t\t// }\n\n\t}\n\n\tprivate static class pair1 {\n\n\t\tint a, b;\n\n\t\tpair1(int a, int b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\t}\n\n\tprivate static String reverse(String s) {\n\n\t\treturn new StringBuilder(s).reverse().toString();\n\t}\n\n\tpublic static class Reader {\n\t\tfinal private int BUFFER_SIZE = 1 << 16;\n\t\tprivate DataInputStream din;\n\t\tprivate byte[] buffer;\n\t\tprivate int bufferPointer, bytesRead;\n\n\t\tpublic Reader() {\n\t\t\tdin = new DataInputStream(System.in);\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic Reader(String file_name) throws IOException {\n\t\t\tdin = new DataInputStream(new FileInputStream(file_name));\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic String readLine() throws IOException {\n\t\t\tbyte[] buf = new byte[1000000 + 1]; // line length\n\t\t\tint cnt = 0, c;\n\t\t\twhile ((c = read()) != -1) {\n\t\t\t\tif (c == '\\n')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[cnt++] = (byte) c;\n\t\t\t}\n\t\t\treturn new String(buf, 0, cnt);\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\tint ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\tlong ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tdouble ret = 0, div = 1;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (c == '.') {\n\t\t\t\twhile ((c = read()) >= '0' && c <= '9') {\n\t\t\t\t\tret += (c - '0') / (div *= 10);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tprivate void fillBuffer() throws IOException {\n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\t\t\tif (bytesRead == -1)\n\t\t\t\tbuffer[0] = -1;\n\t\t}\n\n\t\tprivate byte read() throws IOException {\n\t\t\tif (bufferPointer == bytesRead)\n\t\t\t\tfillBuffer();\n\t\t\treturn buffer[bufferPointer++];\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tif (din == null)\n\t\t\t\treturn;\n\t\t\tdin.close();\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tint[] arr = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextInt();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tlong[] arr = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextLong();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic int[][] nextInt2DArray(int m, int n) throws IOException {\n\t\t\tint[][] arr = new int[m][n];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tarr[i][j] = nextInt();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic long[][] nextInt2DArrayL(int m, int n) throws IOException {\n\t\t\tlong[][] arr = new long[m][n];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tarr[i][j] = nextInt();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\t\t// kickstart - Solution\n\t\t// atcoder - Main\n\t}\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\npublic class D340 {\n      static class dat implements Comparable<dat>{\n\tpublic int x;\n\tpublic int y;\n\tpublic dat(int x,int y){\n\t    this.x=x;\n\t    this.y=y;\n\t}\n\t @Override\n\t public int compareTo(dat other){\n\t     return this.x-((dat)other).x;\n\t }\n     }\n    public static int[] res= new int[100010];\n    public static int n;\n    public static int get(int x){\n\tint temp=0;\n\twhile (x>0){\n\t    temp=Math.max(temp,res[x]);\n\t    x-=x&-x;\n\t}\n\treturn temp;\n    }\n    public static void update(int x,int y){\n\twhile (x<=n){\n\t    res[x]=Math.max(res[x],y);\n\t    x+=x&-x;\n\t}\n    }\n    public static void main(String[] agrs) {\n\tScanner f = new Scanner(System.in);\n\tn=f.nextInt();\n\tArrayList<dat> a = new ArrayList<dat>();\n\tfor(int i=0;i<n;i++){\n\t    int u=f.nextInt();\n\t    a.add(new dat(u,i+1));\n\t}\n\tCollections.sort(a);\n\tint ans=0;\n\tfor(int i=0;i<n;i++){\n\t    int temp=get(a.get(i).y)+1;\n\t    ans=Math.max(ans,temp);\n\t    update(a.get(i).y,temp);\n\t}\n\tSystem.out.println(ans);\n}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint a[100514], top;\nvoid truli() {\n  scanf(\"%d\", &n);\n  int x;\n  top = 0;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &x);\n    if (a[top - 1] < x) {\n      a[top++] = x;\n      continue;\n    }\n    int t = -1;\n    for (int bt = 20; bt >= 0; bt--) {\n      if (t + (1 << bt) < top && a[t + (1 << bt)] < x) t += (1 << bt);\n    }\n    a[t + 1] = x;\n  }\n  printf(\"%d\\n\", top);\n}\nint main() {\n  truli();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid online_judge() {}\nlong long a[2000001];\nvoid go() {\n  long long n;\n  cin >> n;\n  long long a[n];\n  for (int i = 0; i < n; ++i) cin >> a[i];\n  vector<long long> v;\n  for (int i = 0; i < n; ++i) {\n    long long lb = lower_bound(v.begin(), v.end(), a[i]) - v.begin();\n    if (lb == v.size()) {\n      v.push_back(a[i]);\n    } else {\n      v[lb] = a[i];\n    }\n  }\n  cout << v.size();\n}\nint main() {\n  cin.tie(0), ios_base ::sync_with_stdio(0);\n  online_judge();\n  go();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\n \n \n \n \nimport java.util.*;\n/*\n \n*/\n \n \n \n \n \npublic class A {\n\tstatic FastReader sc=null;\n\t\n\tpublic static void main(String[] args) {\n\t\tsc=new FastReader();\n\t\tint n=sc.nextInt();\n\t\tint a[]=sc.readArray(n);\n\t\tint ans[]=new int[n];\n\t\tArrays.fill(ans, Integer.MAX_VALUE);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint id=bs(ans,a[i]);\n\t\t\tans[id]=a[i];\n\t\t}\n\t\tint i=0;\n\t\tfor(i=0;i<n;i++)if(ans[i]==Integer.MAX_VALUE)break;\n\t\tSystem.out.println(i);\n\t\n\t\t\n\t}\n\tstatic int bs(int a[],int k) {\n\t\tint l=-1,r=a.length;\n\t\twhile(l+1<r) {\n\t\t\tint mid=(l+r)/2;\n\t\t\tif(a[mid]<k)l=mid;\n\t\t\telse r=mid;\n\t\t}\n\t\treturn r;\n\t}\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n \n\t\n\tstatic int[] reverse(int a[]) {\n\t\tArrayList<Integer> al=new ArrayList<>();\n\t\tfor(int i:a)al.add(i);\n\t\tCollections.sort(al,Collections.reverseOrder());\n\t\tfor(int i=0;i<a.length;i++)a[i]=al.get(i);\n\t\treturn a;\n\t}\n\tstatic int gcd(int a,int b) {\n\t\tif(b==0)return a;\n\t\telse return gcd(b,a%b);\n\t}\n\tstatic int[] ruffleSort(int a[]) {\n\t\tArrayList<Integer> al=new ArrayList<>();\n\t\tfor(int i:a)al.add(i);\n\t\tCollections.sort(al);\n\t\tfor(int i=0;i<a.length;i++)a[i]=al.get(i);\n\t\treturn a;\n\t}\n\t\n\t\n\t\n\tstatic void print(int a[]) {\n\t\tfor(int e:a) {\n\t\t\tSystem.out.print(e+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\tstatic void print(long a[]) {\n\t\tfor(long e:a) {\n\t\t\tSystem.out.print(e+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\t\n\tstatic class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n        int[] readArray(int n) {\n    \t\tint a[]=new int [n];\n    \t\tfor(int i=0;i<n;i++) {\n    \t\t\ta[i]=sc.nextInt();\n    \t\t}\n    \t\treturn a;\n    \t}\n    } \n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint vt[111111];\nint a[111111];\nint maxlen;\nint main() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n  }\n  vt[0] = 0;\n  maxlen = 0;\n  for (int i = 1; i <= n; i++) {\n    if (vt[maxlen] < a[i]) {\n      maxlen++;\n      vt[maxlen] = a[i];\n      continue;\n    }\n    int l, r, mid;\n    l = 0;\n    r = maxlen;\n    while (l < r) {\n      mid = (l + r) / 2;\n      if (vt[mid] < a[i])\n        l = mid + 1;\n      else\n        r = mid;\n    }\n    if (vt[l] > a[i]) vt[l] = a[i];\n  }\n  cout << maxlen;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n\n\npublic class LIS_nLOGn {\n\tstatic int[] t;\n\tstatic int[] r;\n\tstatic int[] input;\n\tpublic static void main(String[] args) throws IOException {\n\t\tMyScanner sc = new MyScanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tinput = new int[n];\n\t\tt = new int[n];\n\t\tr = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tinput[i] = sc.nextInt();\n\t\t}\n\t\tArrays.fill(r, -1);\n\t\tSystem.out.println(lis());\n\t}\n\t\n\tprivate static int lis() {\n\t\tt[0] = 0;\n\t\tint length = 0;\n\t\tfor (int i = 1; i < input.length; i++) {\n\t\t\tif(input[t[0]] > input[i])\n\t\t\t\tt[0] = i;\n\t\t\telse if(input[t[length]] < input[i]){\n\t\t\t\tlength++;\n\t\t\t\tt[length] = i;\n\t\t\t\tr[t[length]] = t[length-1];\n\t\t\t}else{\n\t\t\t\tint idx = ceilIndex(length, input[i]);\n\t\t\t\tt[idx] = i;\n\t\t\t\tr[t[idx]] = t[idx-1];\n\t\t\t}\n\t\t}\n//\t\tprinting the solution\n//\t\tint idx = t[length];\n//\t\twhile(t[idx] != -1){\n//\t\t\tSystem.out.println(input[idx] + \" \");\n//\t\t\tidx = r[idx];\n//\t\t}\n\t\t\n\t\t\n\t\treturn length+1;\n\t}\n\n\tprivate static int ceilIndex(int length, int s) {\n\t\tint start = 0;\n\t\tint mid;\n\t\tint end = length;\n\t\twhile(start <= end){\n\t\t\tmid = (start + end)/2;\n\t\t\tif(mid < length && input[t[mid]] < s && s <= input[t[mid+1]])\n\t\t\t\treturn mid+1;\n\t\t\telse if(input[t[mid]] < s)\n\t\t\t\tstart = mid+1;\n\t\t\telse\n\t\t\t\tend = mid-1;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic class MyScanner \n\t{\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic MyScanner(InputStream s){\tbr = new BufferedReader(new InputStreamReader(s));}\n\n\t\tpublic MyScanner(String s) throws FileNotFoundException{br = new BufferedReader(new FileReader(new File(s)));}\n\n\t\tpublic String next() throws IOException \n\t\t{\n\t\t\twhile (st == null || !st.hasMoreTokens()) \n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n\n\t\tpublic long nextLong() throws IOException {return Long.parseLong(next());}\n\n\t\tpublic String nextLine() throws IOException {return br.readLine();}\n\n\t\tpublic double nextDouble() throws IOException\n\t\t{\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif(x.charAt(0) == '-')\n\t\t\t{\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor(int i = start; i < x.length(); i++)\n\t\t\t\tif(x.charAt(i) == '.')\n\t\t\t\t{\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif(dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg?-1:1);\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {return br.ready();}\n\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline T bigmod(T b, T p, T M) {\n  long long int ret = 1;\n  for (; p > 0; p >>= 1) {\n    if (p & 1) ret = (ret * b) % M;\n    b = (b * b) % M;\n  }\n  return (T)ret;\n}\ntemplate <class T>\ninline T modinverse(T a, T M) {\n  return bigmod(a, M - 2, M);\n}\ntemplate <class T>\ninline T gcd(T a, T b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\ntemplate <class T>\ninline T lcm(T a, T b) {\n  return a * b / gcd<T>(a, b);\n}\ntemplate <class T>\ninline T power(T b, T p) {\n  long long int x = 1;\n  while (p--) x *= b;\n  return x;\n}\nconst long long int mod = 1e9 + 7;\nconst int siz = 202;\nconst long long int lim = 1e16;\nint arr[100010];\nint longestIncreasingSubsequence(int len) {\n  vector<int> V;\n  for (int i = 1; i <= len; i++) {\n    int pos = upper_bound(V.begin(), V.end(), arr[i]) - V.begin();\n    if (pos < V.size())\n      V[pos] = arr[i];\n    else\n      V.push_back(arr[i]);\n  }\n  return V.size();\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  ;\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> arr[i];\n  cout << longestIncreasingSubsequence(n) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\nimport java.io.OutputStreamWriter;\nimport java.math.BigInteger;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.io.IOException;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Nguyen Trung Hieu - vuondenthanhcong11@gmail.com\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskLIS solver = new TaskLIS();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass TaskLIS {\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n        int count = in.readInt();\n        IntervalTree tree = new LongIntervalTree(100001) {\n            protected long joinValue(long left, long right) {\n                return Math.max(left, right);\n            }\n\n            protected long joinDelta(long was, long delta) {\n                return was + delta;\n            }\n\n            protected long accumulate(long value, long delta, int length) {\n                return Math.max(value, delta);\n            }\n\n            protected long neutralValue() {\n                return - Integer.MAX_VALUE / 2;\n            }\n\n            protected long neutralDelta() {\n                return 0;\n            }\n\n            protected long initValue(int index) {\n                return 0;\n            }\n        };\n\n        long answer = 0;\n        for (int i = 1; i <= count; i++) {\n            int val = in.readInt();\n            tree.update(val, val, (int)(tree.query(0, val) + 1));\n            answer = Math.max(answer, tree.query(0, val));\n        }\n\n        out.printLine(answer);\n    }\n}\n\nclass InputReader {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private SpaceCharFilter filter;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public int read() {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int readInt() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public boolean isSpaceChar(int c) {\n        if (filter != null)\n            return filter.isSpaceChar(c);\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public interface SpaceCharFilter {\n        public boolean isSpaceChar(int ch);\n    }\n\n}\n\nclass OutputWriter {\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public void print(Object...objects) {\n        for (int i = 0; i < objects.length; i++) {\n            if (i != 0)\n                writer.print(' ');\n            writer.print(objects[i]);\n        }\n    }\n\n    public void printLine(Object...objects) {\n        print(objects);\n        writer.println();\n    }\n\n    public void close() {\n        writer.close();\n    }\n\n}\n\nabstract class IntervalTree {\n    protected int size;\n\n    public IntervalTree(int size, boolean shouldInit) {\n        this.size = size;\n        int nodeCount = Math.max(1, Integer.highestOneBit(size) << 2);\n        initData(size, nodeCount);\n        if (shouldInit)\n            init();\n    }\n\n    protected abstract void initData(int size, int nodeCount);\n    protected abstract void initAfter(int root, int left, int right, int middle);\n    protected abstract void initBefore(int root, int left, int right, int middle);\n    protected abstract void initLeaf(int root, int index);\n    protected abstract void updatePostProcess(int root, int left, int right, int from, int to, long delta, int middle);\n    protected abstract void updatePreProcess(int root, int left, int right, int from, int to, long delta, int middle);\n    protected abstract void updateFull(int root, int left, int right, int from, int to, long delta);\n    protected abstract long queryPostProcess(int root, int left, int right, int from, int to, int middle, long leftResult, long rightResult);\n    protected abstract void queryPreProcess(int root, int left, int right, int from, int to, int middle);\n    protected abstract long queryFull(int root, int left, int right, int from, int to);\n    protected abstract long emptySegmentResult();\n\n    public void init() {\n        init(0, 0, size - 1);\n    }\n\n    private void init(int root, int left, int right) {\n        if (left == right) {\n            initLeaf(root, left);\n        } else {\n            int middle = (left + right) >> 1;\n            initBefore(root, left, right, middle);\n            init(2 * root + 1, left, middle);\n            init(2 * root + 2, middle + 1, right);\n            initAfter(root, left, right, middle);\n        }\n    }\n\n    public void update(int from, int to, long delta) {\n        update(0, 0, size - 1, from, to, delta);\n    }\n\n    protected void update(int root, int left, int right, int from, int to, long delta) {\n        if (left > to || right < from)\n            return;\n        if (left >= from && right <= to) {\n            updateFull(root, left, right, from, to, delta);\n            return;\n        }\n        int middle = (left + right) >> 1;\n        updatePreProcess(root, left, right, from, to, delta, middle);\n        update(2 * root + 1, left, middle, from, to, delta);\n        update(2 * root + 2, middle + 1, right, from, to, delta);\n        updatePostProcess(root, left, right, from, to, delta, middle);\n    }\n\n    public long query(int from, int to) {\n        return query(0, 0, size - 1, from, to);\n    }\n\n    protected long query(int root, int left, int right, int from, int to) {\n        if (left > to || right < from)\n            return emptySegmentResult();\n        if (left >= from && right <= to)\n            return queryFull(root, left, right, from, to);\n        int middle = (left + right) >> 1;\n        queryPreProcess(root, left, right, from, to, middle);\n        long leftResult = query(2 * root + 1, left, middle, from, to);\n        long rightResult = query(2 * root + 2, middle + 1, right, from, to);\n        return queryPostProcess(root, left, right, from, to, middle, leftResult, rightResult);\n    }\n}\n\nabstract class LongIntervalTree extends IntervalTree {\n    protected long[] value;\n    protected long[] delta;\n\n    protected LongIntervalTree(int size) {\n        this(size, true);\n    }\n\n    public LongIntervalTree(int size, boolean shouldInit) {\n        super(size, shouldInit);\n    }\n\n    protected void initData(int size, int nodeCount) {\n        value = new long[nodeCount];\n        delta = new long[nodeCount];\n    }\n\n    protected abstract long joinValue(long left, long right);\n    protected abstract long joinDelta(long was, long delta);\n    protected abstract long accumulate(long value, long delta, int length);\n    protected abstract long neutralValue();\n    protected abstract long neutralDelta();\n\n    protected long initValue(int index) {\n        return neutralValue();\n    }\n\n    protected void initAfter(int root, int left, int right, int middle) {\n        value[root] = joinValue(value[2 * root + 1], value[2 * root + 2]);\n        delta[root] = neutralDelta();\n    }\n\n    protected void initBefore(int root, int left, int right, int middle) {\n    }\n\n    protected void initLeaf(int root, int index) {\n        value[root] = initValue(index);\n        delta[root] = neutralDelta();\n    }\n\n    protected void updatePostProcess(int root, int left, int right, int from, int to, long delta, int middle) {\n        value[root] = joinValue(value[2 * root + 1], value[2 * root + 2]);\n    }\n\n    protected void updatePreProcess(int root, int left, int right, int from, int to, long delta, int middle) {\n        pushDown(root, left, middle, right);\n    }\n\n    protected void pushDown(int root, int left, int middle, int right) {\n        value[2 * root + 1] = accumulate(value[2 * root + 1], delta[root], middle - left + 1);\n        value[2 * root + 2] = accumulate(value[2 * root + 2], delta[root], right - middle);\n        delta[2 * root + 1] = joinDelta(delta[2 * root + 1], delta[root]);\n        delta[2 * root + 2] = joinDelta(delta[2 * root + 2], delta[root]);\n        delta[root] = neutralDelta();\n    }\n\n    protected void updateFull(int root, int left, int right, int from, int to, long delta) {\n        value[root] = accumulate(value[root], delta, right - left + 1);\n        this.delta[root] = joinDelta(this.delta[root], delta);\n    }\n\n    protected long queryPostProcess(int root, int left, int right, int from, int to, int middle, long leftResult, long rightResult) {\n        return joinValue(leftResult, rightResult);\n    }\n\n    protected void queryPreProcess(int root, int left, int right, int from, int to, int middle) {\n        pushDown(root, left, middle, right);\n    }\n\n    protected long queryFull(int root, int left, int right, int from, int to) {\n        return value[root];\n    }\n\n    protected long emptySegmentResult() {\n        return neutralValue();\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Main2 {\n    static StreamTokenizer in = new StreamTokenizer(System.in);\n    static int ni() throws Exception {\n        in.nextToken();\n        return (int)in.nval;\n    }\n    public static void main(String[] args) throws Exception {\n        int n1 = ni();\n        int[] l1 = new int[n1];\n        for (int i =0; i < n1; i++){\n            l1[i] = ni() - 1;\n        }\n        int best = 1;\n        RMQ t1 = new RMQ(n1);\n//      px(t1.size);\n        for (int e: l1){\n            int cur = 0;\n            if (e > 0){\n//              px(\"cur\",e,cur);\n                cur = t1.root.find(0, e - 1);\n                best = Math.max(best, cur + 1);\n            }\n            t1.solo[e].val = cur + 1;\n            t1.solo[e].refresh();\n//          px(t1);\n//          px(t1.a);\n        }\n        System.out.println(best);\n    }\n    public static class RMQ {\n        N[] solo = null;\n        public class N {\n            N parent = null;\n            N q1 = null, q2 = null;\n            int left = 0;\n            int right = 0;\n            int val = 0;\n            void generate(){\n                if (left == right){\n                    solo[left] = this;\n                    return;\n                }\n                int len = right - left + 1;\n                int half = len / 2;\n                q1 = new N();\n                q1.left = left;\n                q1.right = left + half - 1;\n                q1.parent = this;\n                q2 = new N();\n                q2.left = left + half;\n                q2.right = right;\n                q2.parent = this;\n                q1.generate();\n                q2.generate();\n            }\n            void refresh(){\n                if (q1 != null) val = Math.max(val, q1.val);\n                if (q2 != null) val = Math.max(val, q2.val);\n                if (parent != null) parent.refresh();\n            }\n            \n            public int find(int fleft, int fright){\n//              px(\"find\",left,right,fleft,fright);\n                if (fleft <= left && fright >= right) return val;\n                int res = Integer.MIN_VALUE;\n                if (q1 != null) if (fleft <= q1.right) res = Math.max(res, q1.find(fleft, fright));\n                if (q2 != null) if (fright >= q2.left) res = Math.max(res, q2.find(fleft, fright));\n                return res;\n            }\n        }\n        N root = null;\n        int size = 0;\n        public RMQ(int n1){\n            size = n1;\n            root = new N();\n            root.left = 0;\n            root.right = size - 1;\n            solo = new N[size];\n            root.generate();\n        }\n        \n        \n    }\n    static void px(Object ...objects){\n        System.out.println(Arrays.deepToString(objects));\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nclass xdt {\n public:\n  int T[100005];\n  int lowbit(int i) { return i & -i; }\n  void update(int p, int v) {\n    for (; p < 100005; p += lowbit(p))\n      if (T[p] >= v)\n        return;\n      else\n        T[p] = v;\n  }\n  int max(int R) {\n    int ans = 0;\n    for (; R > 0; R -= lowbit(R))\n      if (ans < T[R]) ans = T[R];\n    return ans;\n  }\n} T;\nint main() {\n  ios::sync_with_stdio(0);\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    int a;\n    cin >> a;\n    T.update(a, T.max(a) + 1);\n  }\n  cout << T.max(100004) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from bisect import bisect_left, bisect_right, insort\nR = lambda: map(int, input().split())\nn, arr = int(input()), list(R())\ndp = []\nfor i in range(n):\n    idx = bisect_left(dp, arr[i])\n    if idx >= len(dp):\n        dp.append(arr[i])\n    else:\n        dp[idx] = arr[i]\nprint(len(dp))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint func(int *a, int n) {\n  vector<int> temp(n + 1, 1000000000);\n  for (int i = 0; i < n; i++)\n    *lower_bound(temp.begin(), temp.end(), a[i]) = a[i];\n  for (int i = 0; i <= n; i++)\n    if (temp[i] == 1000000000) return i;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  int a[n];\n  for (int i = 0; i < n; i++) cin >> a[i];\n  cout << func(a, n) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\n\npublic class Round198D {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] list = new int[n];\n        for (int i=0; i<n; i++) {\n            list[i] = sc.nextInt();\n        }\n        \n        System.out.println(lis(list));\n        \n    }\n    \n    public static int lis(int[] seq) {\n        List<Integer> lis = new ArrayList<Integer>();\n        int seqSize = seq.length;\n        int lo, hi, mid;\n        \n        if(seqSize <= 0) return 0;\n        \n        lis.add(seq[0]);\n        for (int k = 1; k < seqSize; k++) {\n            if (lis.get(lis.size()-1) < seq[k]) {\n                lis.add(seq[k]);\n                continue;\n            }\n            \n            lo = 0;\n            hi = lis.size();\n            while (lo < hi) {\n                mid = (lo + hi)/2;\n                if (lis.get(mid) < seq[k]) {\n                    lo = mid + 1;\n                } else {\n                    hi = mid;\n                }\n            }\n            \n            if (lo < lis.size()) {\n                lis.set(lo, seq[k]);\n            } else {\n                lis.add(seq[k]);\n            }\n        }\n        \n        return lis.size();      \n    }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint i, j, k, l, m, n, a[1000000];\nint main() {\n  int top;\n  scanf(\"%d\", &n);\n  a[0] = -1;\n  top = 0;\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", &m);\n    if (m > a[top])\n      a[++top] = m;\n    else {\n      int high = top, low = 1, mid;\n      while (low <= high) {\n        mid = (high + low) / 2;\n        if (m > a[mid]) {\n          low = mid + 1;\n        } else {\n          high = mid - 1;\n        }\n      }\n      a[low] = m;\n    }\n  }\n  printf(\"%d\\n\", top);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dx[] = {0, 0, 1, -1, 1, -1, 1, -1};\nint dy[] = {1, -1, 0, 0, -1, 1, 1, -1};\nlong long gcd(long long a, long long b) { return !b ? a : gcd(b, a % b); }\nlong long lcm(long long a, long long b) { return (a / gcd(a, b)) * b; }\nvoid PLAY() {\n  cout << fixed << setprecision(10);\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n}\nint n;\nint arr[100005];\nint idx(vector<int> &a, int l, int r, int val) {\n  while (r - l > 1) {\n    int mid = l + (r - l) / 2;\n    if (a[mid] >= val)\n      r = mid;\n    else\n      l = mid;\n  }\n  return r;\n}\nint LIS() {\n  vector<int> v(n, 0);\n  int ret = 1;\n  v[0] = arr[0];\n  for (int i = 1; i < n; i++) {\n    if (arr[i] < v[0])\n      v[0] = arr[i];\n    else if (arr[i] > v[ret - 1])\n      v[ret++] = arr[i];\n    else\n      v[idx(v, -1, ret - 1, arr[i])] = arr[i];\n  }\n  return ret;\n}\nint main() {\n  PLAY();\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> arr[i];\n  cout << LIS() << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint ft[100005];\nint N;\ninline int II() {\n  int n;\n  scanf(\"%d\", &n);\n  return n;\n}\nvoid update(int k, int delta) {\n  for (++k; k <= N; k += (k & (-k))) ft[k] = max(ft[k], delta);\n}\nint sum(int k) {\n  int ans = 0;\n  for (++k; k != 0; k -= (k & (-k))) ans = max(ans, ft[k]);\n  return ans;\n}\nint sum(int a, int b) { return sum(b) - sum(a - 1); }\nint main() {\n  N = II();\n  int ans = 0;\n  for (int i = 0; i < N; i++) {\n    int u = II();\n    int val = 0;\n    for (int b = u; b; b -= (b & (-b))) val = max(val, ft[b]);\n    val++;\n    ans = max(ans, val);\n    for (int b = u; b <= N; b += (b & (-b))) ft[b] = max(ft[b], val);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> v;\nint n, arr[200005], dp[200005];\nint b_search(int h, int l, int b) {\n  int mid;\n  while (l < h) {\n    mid = (l + h) / 2;\n    if (b > dp[mid]) {\n      l = mid + 1;\n    } else\n      h = mid;\n  }\n  return h;\n}\nint LIS(int x) {\n  int len = 1;\n  dp[0] = arr[0];\n  for (int i = 1; i < n; i++) {\n    if (arr[i] < dp[0]) {\n      dp[0] = arr[i];\n    } else if (arr[i] > dp[len - 1]) {\n      dp[len++] = arr[i];\n    } else {\n      int p = b_search(len - 1, 0, arr[i]);\n      dp[p] = arr[i];\n    }\n  }\n  return len;\n}\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> arr[i];\n  int ans = LIS(n);\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nstruct segTree {\n  int n;\n  vector<int> t;\n  segTree(int n) : n(n), t(2 * n, 0) {}\n  void upd(int v, int x) {\n    t[v += n] = x;\n    for (v >>= 1; v; v >>= 1) t[v] = max(t[v * 2], t[v * 2 + 1]);\n  }\n  int get(int l, int r) {\n    int ret = 0;\n    for (l += n, r += n; l <= r; l = (l + 1) >> 1, r = (r - 1) >> 1) {\n      if (l & 1) ret = max(ret, t[l]);\n      if (!(r & 1)) ret = max(ret, t[r]);\n    }\n    return ret;\n  }\n};\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) cin >> a[i], a[i]--;\n  segTree t(n);\n  vector<int> dp(n);\n  for (int i = 0; i < n; i++) {\n    dp[i] = 1 + t.get(0, a[i]);\n    t.upd(a[i], dp[i]);\n  }\n  int ans = 0;\n  for (int i = 0; i < n; i++) ans = max(ans, dp[i]);\n  cout << ans;\n}\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.io.InputStream;\nimport java.util.ArrayList;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        D solver = new D();\n        int testCount = 1;\n        for (int i = 1; i <= testCount; i++) {\n            solver.solve(i, in, out);\n        }\n        out.close();\n    }\n}\n\nclass D {\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n           \n        int n = in.readInt();\n        \n        int[] arr = new int[n];\n        for( int i = 0; i < n; i++){\n           arr[i] = in.readInt();\n        }\n        \n        out.printLine(LIS(arr,n)); \n        \n    }\n    \n    public int LIS( int[] arr , int n){\n        \n         \n        int len = 1;\n        \n        int[] ends = new int[n+1];\n        \n        ends[1] = arr[0];\n        \n        for( int i = 2; i <= n; i++){\n            if( arr[i-1] < ends[1]){\n                 ends[1] = arr[i-1];\n            }\n            else if( arr[i-1] > ends[len]){\n                len = len + 1;\n                ends[len] = arr[i-1];\n            }\n            else{\n                \n                int p = binary_search(ends, 1, len, arr[i - 1]); \n                ends[p] = arr[i - 1];\n            }\n        }\n        \n        return len;\n    }\n    \n     public int binary_search( int[] arr, int l , int r, int v){\n    \n        int m;\n        \n        while( l <= r){\n            m = l + ( r - l)/2;\n            if( arr[m] < v)\n                l = m + 1;\n            else if( arr[m] > v)\n                r = m - 1;\n            else\n                return m;\n        }\n         \n        return r + 1;\n        \n    }\n}\n\nclass InputReader {\n\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private SpaceCharFilter filter;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public int read() {\n        if (numChars == -1) {\n            throw new InputMismatchException();\n        }\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0) {\n                return -1;\n            }\n        }\n        return buf[curChar++];\n    }\n\n    public int readInt() {\n        int c = read();\n        while (isSpaceChar(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9') {\n                throw new InputMismatchException();\n            }\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public String readString() {\n        int c = read();\n        while (isSpaceChar(c)) {\n            c = read();\n        }\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n        return res.toString();\n    }\n\n    public boolean isSpaceChar(int c) {\n        if (filter != null) {\n            return filter.isSpaceChar(c);\n        }\n        return isWhitespace(c);\n    }\n\n    public static boolean isWhitespace(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public String next() {\n        return readString();\n    }\n\n    public interface SpaceCharFilter {\n\n        public boolean isSpaceChar(int ch);\n    }\n}\n\nclass OutputWriter {\n\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n        this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n        for (int i = 0; i < objects.length; i++) {\n            if (i != 0) {\n                writer.print(' ');\n            }\n            writer.print(objects[i]);\n        }\n    }\n\n    public void printLine(Object... objects) {\n        print(objects);\n        writer.println();\n    }\n\n    public void close() {\n        writer.close();\n    }\n}\n\nclass IOUtils {\n\n    public static int[] readIntArray(InputReader in, int size) {\n        int[] array = new int[size];\n        for (int i = 0; i < size; i++) {\n            array[i] = in.readInt();\n        }\n        return array;\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Warstwa {\n  Warstwa() {}\n  Warstwa(int a) : v(1, a) {}\n  vector<int> v;\n  bool operator<(const Warstwa& dane) const {\n    return v[int((v).size()) - 1] < dane.v[int((dane.v).size()) - 1];\n  }\n};\nvoid zrob_test() {\n  vector<Warstwa> t;\n  int n;\n  cin >> n;\n  while (n--) {\n    int a;\n    cin >> a;\n    __typeof(t.begin()) w = (t.begin());\n    w = upper_bound(t.begin(), t.end(), Warstwa(a - 1));\n    if (w == t.end())\n      t.push_back(Warstwa(a));\n    else\n      w->v.push_back(a);\n  }\n  cout << int((t).size()) << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  zrob_test();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100010], b[100010];\nint binary(int i, int k) {\n  if (a[i] < b[1]) return 1;\n  int h, j;\n  for (h = 1, j = k; h != j - 1;) {\n    if (b[k = (h + j) / 2] < a[i])\n      h = k;\n    else\n      j = k;\n  }\n  return j;\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  b[1] = a[1];\n  int cnt = 1;\n  for (int i = 2; i <= n; i++) {\n    if (a[i] > b[cnt])\n      b[++cnt] = a[i];\n    else\n      b[binary(i, cnt)] = a[i];\n  }\n  printf(\"%d\\n\", cnt);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1 << 29;\nconst double dinf = 1e30;\nconst long long linf = 1LL << 55;\nconst int N = 111111;\nint rec[N];\nint a[N], n;\nint bs(int pos, int x) {\n  int l = 0, r = pos;\n  int res;\n  while (l <= r) {\n    int mid = (l + r) >> 1;\n    if (a[rec[mid]] < x)\n      res = mid, l = mid + 1;\n    else\n      r = mid - 1;\n  }\n  return res;\n}\nint main() {\n  while (cin >> n) {\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    rec[0] = 0;\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n      int res = bs(ans, a[i]);\n      if (res == ans) ans++;\n      rec[res + 1] = i;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\nimport java.io.StreamTokenizer;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author KNIGHT0X300\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputStreamReader in = new InputStreamReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\ttt solver = new tt();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass tt {\n    StreamTokenizer in;\n    PrintWriter out;\n    BufferedReader re;\n    Scanner sc;\n    public void solve (int testNumber, InputStreamReader in, PrintWriter out)  {\n\n        this.in = new StreamTokenizer(new BufferedReader(in));\n        this.re =  new BufferedReader(in);\n        this.sc = new Scanner(in);\n        this.out = out;\n        try {\n            this.solve();\n        } catch (IOException e) {\n            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n        }\n        out.flush();\n\n    }\n\n    /////////////////////////////////////////////////////////////\n    int nextInt() throws IOException\n    {\n        in.nextToken();\n        return (int)in.nval;\n    }\n\n    void solve() throws IOException\n    {\n        int n=nextInt();\n        int[] X= new int[n];\n        int[] M= new int[n+1];\n        for (int i=0;i<n;i++){\n            X[i]=nextInt();\n\n        }\n        int L=0;\n        for (int i=0;i<n;i++){\n            int upj=L+1,loj=0;\n            while(Math.abs(upj-loj)>1){\n                int c=(upj+loj)/2;\n                if(X[M[c]]<X[i])loj=c;\n                else upj=c;\n            }\n            int sj=loj;\n            if(sj==L || X[i]<X[M[(sj+1)]]) {\n                M[sj+1]=i;\n                L = Math.max(L,sj+1);\n\n            }\n        }\n        out.println(L);\n        // do the sum\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Template implements Runnable {\n\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer tok = new StringTokenizer(\"\");\n\n    void init() throws FileNotFoundException {\n        try {\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new PrintWriter(\"output.txt\");\n        } catch (Exception e) {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        }\n    }\n\n    class GraphBuilder {\n        int n, m;\n        int[] x, y;\n        int index;\n        int[] size;\n\n\n        GraphBuilder(int n, int m) {\n            this.n = n;\n            this.m = m;\n            x = new int[m];\n            y = new int[m];\n            size = new int[n];\n        }\n\n        void add(int u, int v) {\n            x[index] = u;\n            y[index] = v;\n            size[u]++;\n            size[v]++;\n            index++;\n        }\n\n        int[][] build() {\n            int[][] graph = new int[n][];\n            for (int i = 0; i < n; i++) {\n                graph[i] = new int[size[i]];\n            }\n            for (int i = index - 1; i >= 0; i--) {\n                int u = x[i];\n                int v = y[i];\n                graph[u][--size[u]] = v;\n                graph[v][--size[v]] = u;\n            }\n            return graph;\n        }\n    }\n\n    String readString() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            try {\n                tok = new StringTokenizer(in.readLine());\n            } catch (Exception e) {\n                return null;\n            }\n        }\n        return tok.nextToken();\n    }\n\n    int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n\n    int[] readIntArray(int size) throws IOException {\n        int[] res = new int[size];\n        for (int i = 0; i < size; i++) {\n            res[i] = readInt();\n        }\n        return res;\n    }\n\n    long[] readLongArray(int size) throws IOException {\n        long[] res = new long[size];\n        for (int i = 0; i < size; i++) {\n            res[i] = readLong();\n        }\n        return res;\n    }\n\n    long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n\n    double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n\n    <T> List<T>[] createGraphList(int size) {\n        List<T>[] list = new List[size];\n        for (int i = 0; i < size; i++) {\n            list[i] = new ArrayList<>();\n        }\n        return list;\n    }\n\n    public static void main(String[] args) {\n        new Template().run();\n        // new Thread(null, new Template(), \"\", 1l * 200 * 1024 * 1024).start();\n    }\n\n    long timeBegin, timeEnd;\n\n    void time() {\n        timeEnd = System.currentTimeMillis();\n        System.err.println(\"Time = \" + (timeEnd - timeBegin));\n    }\n\n    long memoryTotal, memoryFree;\n\n    void memory() {\n        memoryFree = Runtime.getRuntime().freeMemory();\n        System.err.println(\"Memory = \" + ((memoryTotal - memoryFree) >> 10)\n                + \" KB\");\n    }\n\n    public void run() {\n        try {\n            timeBegin = System.currentTimeMillis();\n            memoryTotal = Runtime.getRuntime().freeMemory();\n            init();\n            solve();\n            out.close();\n            if (System.getProperty(\"ONLINE_JUDGE\") == null) {\n                time();\n                memory();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }\n\n    void solve() throws IOException {\n        int n = readInt();\n        int[] a = readIntArray(n);\n\n        int[] minLast = new int[n + 1];\n        Arrays.fill(minLast, Integer.MAX_VALUE);\n        minLast[0] = 0;\n        for (int x : a) {\n            int l = 0;\n            int r = minLast.length - 1;\n            int ans = 0;\n            while (l <= r) {\n                int mid = (l + r) >> 1;\n                if (minLast[mid] <= x) {\n                    ans = mid;\n                    l = mid + 1;\n                } else {\n                    r = mid - 1;\n                }\n            }\n            minLast[ans + 1] = x;\n        }\n        int last = 0;\n        for (int i=1;i<minLast.length;i++) {\n            if (minLast[i] != Integer.MAX_VALUE) {\n                last = i;\n            }\n        }\n        out.println(last);\n    }\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn = 1000 * 100 + 10;\nint n;\nint d[Maxn];\nint num[Maxn];\nint L = 1;\nvoid input() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> num[i];\n}\nint find_ind(int begin, int end, int j) {\n  if (end == begin + 1) {\n    return begin;\n  }\n  int mid = (begin + end) / 2;\n  if (num[d[mid]] < num[j]) {\n    return find_ind(mid, end, j);\n  } else\n    return find_ind(begin, mid, j);\n}\nint main() {\n  input();\n  d[1] = 1;\n  int x;\n  for (int i = 2; i <= n; i++) {\n    x = find_ind(0, L + 1, i);\n    if (d[x + 1] != 0 && num[d[x + 1]] > num[i]) d[x + 1] = i;\n    if (x == L) {\n      L++;\n      d[L] = i;\n    }\n  }\n  cout << L << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, x;\nvector<int> v;\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", &x);\n    int a = lower_bound(v.begin(), v.end(), x) - v.begin();\n    if (a == v.size())\n      v.push_back(x);\n    else\n      v[a] = x;\n  }\n  printf(\"%d\\n\", v.size());\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1000 * 100 + 10, mod = 100000007;\nint a[N];\nint n;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  ;\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  vector<int> ans;\n  for (int i = 0; i < n; i++) {\n    int val = a[i];\n    int pos = lower_bound(ans.begin(), ans.end(), val) - ans.begin();\n    if (pos < int(ans.size()))\n      ans[pos] = val;\n    else\n      ans.push_back(val);\n  }\n  cout << int(ans.size()) << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100005, INF = 1e9;\nint dp[MAXN], a[MAXN];\nvoid solve() {\n  int n, i;\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  for (i = 0; i <= n; i++) {\n    dp[i] = INF;\n  }\n  dp[0] = 0;\n  for (i = 0; i < n; i++) {\n    int offset = upper_bound(dp, dp + n, a[i]) - dp;\n    dp[offset] = a[i];\n  }\n  int ans = 0;\n  for (i = 1; i <= n; i++) {\n    if (dp[i] < INF) {\n      ans = i;\n    }\n  }\n  printf(\"%d\", ans);\n}\nint main() {\n  int t;\n  t = 1;\n  while (t) {\n    t--;\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[110000];\nint sol[110000], pos;\nint solve(int n) {\n  int bs = 0, i;\n  pos = 0;\n  sol[0] = -1;\n  for (i = 0; i < n; i++) {\n    if (a[i] > sol[pos]) {\n      pos++;\n      sol[pos] = a[i];\n      if (pos > bs) bs = pos;\n      continue;\n    }\n    int npos = lower_bound(sol, sol + pos, a[i]) - sol;\n    sol[npos] = a[i];\n  }\n  return bs;\n}\nint main() {\n  int n, i;\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n  printf(\"%d\\n\", solve(n));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mod = 1000000007;\nlong long inf = LLONG_MAX;\nlong double pi = 3.1415926536;\nint ans(std::vector<int>& v) {\n  if (v.size() == 0) return 0;\n  std::vector<int> tail(v.size(), 0);\n  int length = 1;\n  tail[0] = v[0];\n  for (int i = 1; i < v.size(); i++) {\n    auto b = tail.begin(), e = tail.begin() + length;\n    auto it = lower_bound(b, e, v[i]);\n    if (it == tail.begin() + length)\n      tail[length++] = v[i];\n    else\n      *it = v[i];\n  }\n  return length;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  int tt = 1;\n  while (tt--) {\n    long long n, x = 0, m = 0, y = 0, k = inf;\n    cin >> n;\n    vector<int> v(n, 0);\n    for (long long i = 0; i < n; i++) {\n      cin >> x;\n      v[i] = x;\n    }\n    cout << ans(v) << '\\n';\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.Vector;\n\npublic class Maximal_ketmaketlik {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n + 1], d = new int[n + 1], last = new int[n + 1];\n\t\tint inf = (int) 1e7;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\td[i] = inf;\n\t\t}\n\t\td[0] = -inf;\n\t\tlast[0] = 0;\n\t\t// for (int i = 1; i <= n; i++) {\n\t\t// for (int j = 1; j <= n; j++) {\n\t\t// if (a[i] < d[j] && a[i] > d[j - 1]) {\n\t\t// d[j] = a[i];\n\t\t// }\n\t\t// }\n\t\t// }\n\t\tVector<Integer> v = new Vector<Integer>();\n\n\t\tint[] p = new int[n + 1];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t// int j = UpperBound(d, 1, n, a[i]) + 1;\n\t\t\tint j = Math.abs(Arrays.binarySearch(d, a[i])) - 1;\n\t\t\tif (a[i] < d[j] && a[i] > d[j - 1]) {\n\t\t\t\td[j] = a[i];\n\t\t\t\tlast[j] = i;\n\t\t\t\tp[i] = last[j - 1];\n\t\t\t}\n\t\t}\n\t\tfor (int i = n; i >= 1; i--) {\n\t\t\tif (d[i] != inf) {\n\t\t\t\tSystem.out.println(i);\n//\t\t\t\tint cur = last[i];\n//\t\t\t\twhile (cur > 0) {\n//\t\t\t\t\tv.add(cur);\n//\t\t\t\t\tcur = p[cur];\n//\t\t\t\t}\n//\t\t\t\tfor (int j = v.size() - 1; j >= 0; j--) {\n//\t\t\t\t\tSystem.out.print(a[v.get(j)] + \" \");\n//\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t//System.out.println(inf);\n\t}\n\n\tprivate static int LowerBound(int[] a, int l, int r, int x) {\n\t\tif (x < a[1] || a[r] < x)\n\t\t\treturn -1;\n\t\tint m = 0;\n\t\twhile (l <= r) {\n\t\t\tm = (l + r) / 2;\n\t\t\t// System.out.println(\"Low\" + l + \" \" + r + \" \" + a[m]);\n\t\t\tif (a[m - 1] < x && a[m] == x)\n\t\t\t\treturn m;\n\t\t\tif (x > a[m])\n\t\t\t\tl = m + 1;\n\t\t\telse if (x <= a[m])\n\t\t\t\tr = m - 1;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tprivate static int UpperBound(int[] a, int l, int r, int x) {\n\t\tif (x < a[1] || a[r] < x)\n\t\t\treturn -1;\n\t\tint m = 0;\n\t\twhile (l <= r) {\n\t\t\tm = (l + r) / 2;\n\t\t\t// System.out.println(\"Upp\" + l + \" \" + r + \" \" + m);\n\t\t\tif (a[m] == x && a[m + 1] > x)\n\t\t\t\treturn m;\n\t\t\tif (x >= a[m])\n\t\t\t\tl = m + 1;\n\t\t\telse if (x < a[m])\n\t\t\t\tr = m - 1;\n\t\t}\n\t\treturn -1;\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[] = {-1, 0, 1, 0, -1, -1, 1, 1};\nconst int dy[] = {0, -1, 0, 1, -1, 1, 1, -1};\ntemplate <class T>\ninline bool get(T& n) {\n  char c, mul = 1;\n  n = 0;\n  while (!isdigit(c = getchar_unlocked()) && (c != EOF) && (c != '-'))\n    ;\n  if (c == EOF) return false;\n  if (c == '-') {\n    c = getchar_unlocked();\n    mul = -1;\n  }\n  for (; isdigit(c); c = getchar_unlocked()) n = n * 10 + c - '0';\n  n *= mul;\n  return true;\n}\ninline void get(char& c) {\n  while (isspace(c = getchar_unlocked()))\n    ;\n}\nint main() {\n  int n, x;\n  get(n);\n  set<int> s;\n  for (int(i) = 0, _ = (n); (i) < _; ++i) {\n    get(x);\n    pair<set<int>::iterator, bool> it = s.insert(x);\n    if (it.second) {\n      ++it.first;\n      if (it.first != s.end()) s.erase(it.first);\n    }\n  }\n  printf(\"%d\\n\", s.size());\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid FastInputOutput() {\n  ios_base ::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n}\nbool isPrime(long long n) {\n  for (long long i = 2; i * i <= n; ++i)\n    if (n % i == 0) return false;\n  return n > 1;\n}\nint lucky[] = {4, 7, 44, 47, 74, 77, 444, 447, 474, 477, 744, 747, 774, 777};\nbool luckNumner(int n) {\n  for (int i = 0; i < 12; ++i) {\n    if (n % lucky[i] == 0) return true;\n  }\n  return false;\n}\nvector<pair<int, pair<int, int> > > pls;\nint cov(int h, int m, int s) { return (h * 60 + m) * 60 + s; }\nint cm[86399 + 4];\nvoid gen() {\n  for (int i = 0; i < 24; ++i)\n    for (int j = 0; j < 60; ++j)\n      for (int k = 0; k < 60; ++k)\n        if (i / 10 == k % 10 && i % 10 == k / 10 && j % 10 == j / 10)\n          cm[cov(i, j, k)] = 1;\n  for (int i = 0; i < 86399 + 4; ++i) cm[i] += cm[i - 1];\n}\nconst int N = 1e5 + 5;\nint a[N];\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; ++i) cin >> a[i];\n  vector<int> ls;\n  for (int i = 0; i < n; ++i) {\n    int idx = lower_bound(ls.begin(), ls.end(), a[i]) - ls.begin();\n    if (idx == ls.size())\n      ls.push_back(a[i]);\n    else\n      ls[idx] = min(ls[idx], a[i]);\n  }\n  cout << ls.size() << \"\\n\";\n}\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.io.*;\nimport java.util.*;\n\npublic class D198{      \n        \n        private BufferedReader in;  \n        private StringTokenizer st;\n        private PrintWriter out;\n        \n        \n        \n        \n        void solve() throws IOException{\n            \n        \n            TreeSet<Integer> t = new TreeSet<Integer>();\n            int n = nextInt();\n            for (int i = 0; i < n; i++) {\n                int a = nextInt();\n                if(t.ceiling(a) == null){\n                    t.add(a);\n                }\n                else{\n                    t.remove(t.ceiling(a));\n                    t.add(a);\n                }\n            }\n            out.println(t.size());\n        \n                    \n        }\n            \n\n        D198() throws IOException {\n            in = new BufferedReader(new InputStreamReader(System.in));  \n            out = new PrintWriter(System.out);\n            eat(\"\");\n            solve();    \n            out.close();\n        }\n\n        private void eat(String str) {\n            st = new StringTokenizer(str);\n        }\n\n        String next() throws IOException {\n            while (!st.hasMoreTokens()) {\n                String line = in.readLine();                \n                if (line == null) {                 \n                    return null;\n                }\n                eat(line);\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public static void main(String[] args) throws IOException {\n            new D198();\n        }\n\n        int gcd(int a,int b){\n            if(b>a) return gcd(b,a);\n            if(b==0) return a;\n            return gcd(b,a%b);\n        }\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\npublic class D340 {\n      static class dat {\n\tpublic int x;\n\tpublic int y;\n\tpublic dat(int x,int y){\n\t    this.x=x;\n\t    this.y=y;\n\t}\n\t \n     }\n    public static int[] res= new int[100010];\n    public static int n;\n    public static int get(int x){\n\tint temp=0;\n\twhile (x>0){\n\t    temp=Math.max(temp,res[x]);\n\t    x-=x&-x;\n\t}\n\treturn temp;\n    }\n    public static void update(int x,int y){\n\twhile (x<=n){\n\t    res[x]=Math.max(res[x],y);\n\t    x+=x&-x;\n\t}\n    }\n    public static void main(String[] agrs) {\n\tScanner f = new Scanner(System.in);\n\tn=f.nextInt();\n\tArrayList<dat> a = new ArrayList<dat>();\n\tfor(int i=0;i<n;i++){\n\t    int u=f.nextInt();\n\t    a.add(new dat(u,i+1));\n\t}\n\tCollections.sort(a, new Comparator<dat>(){\n\t\tpublic int compare(dat a, dat b){\n\t\treturn a.x-b.x;\n\t}\n\t});\n\tint ans=0;\n\tfor(int i=0;i<n;i++){\n\t    int temp=get(a.get(i).y)+1;\n\t    ans=Math.max(ans,temp);\n\t    update(a.get(i).y,temp);\n\t}\n\tSystem.out.println(ans);\n}\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\nI = lambda : list(map(int,input().split()))\n\ndef CeilIndex(A, l, r, key): \n    while (r - l > 1): \n      \n        m = l + (r - l)//2\n        if (A[m] >= key): \n            r = m \n        else: \n            l = m \n    return r \n   \ndef lis(A, size): \n    tailTable = [0 for i in range(size + 1)] \n    len = 0 # always points empty slot \n   \n    tailTable[0] = A[0] \n    len = 1\n    for i in range(1, size): \n      \n        if (A[i] < tailTable[0]): \n            tailTable[0] = A[i] \n   \n        elif (A[i] > tailTable[len-1]): \n            tailTable[len] = A[i] \n            len+= 1\n   \n        else: \n            tailTable[CeilIndex(tailTable, -1, len-1, A[i])] = A[i] \n    return len\n\n\nn,=I()\np=I()\nan=1\nprint(lis(p,n))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint Set(int N, int pos) { return N = N | (1 << pos); }\nint reSet(int N, int pos) { return N = N & ~(1 << pos); }\nbool check(int N, int pos) { return (bool)(N & (1 << pos)); }\nusing namespace std;\nint n, k;\nvector<int> A;\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &k);\n    int id = lower_bound(A.begin(), A.end(), k) - A.begin();\n    if (id == A.size())\n      A.push_back(k);\n    else\n      A[id] = k;\n  }\n  printf(\"%d\\n\", A.size());\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Abc {\n    static int inf=Integer.MAX_VALUE;\n    public static void main(String[] args) {\n        FastReader sc = new FastReader();\n        int n=sc.nextInt();\n        int arr[]=new int[n];\n        for (int i=0;i<n;i++)arr[i]=sc.nextInt();\n        int dp[]=new int[n+1];\n        Arrays.fill(dp,inf);\n        dp[0]=-inf;\n        for (int i=0;i<n;i++){\n            int j=pos(dp,arr[i]);\n            if (dp[j-1]<arr[i]) {\n                dp[j] = arr[i];\n            }\n        }\n        int i=n;\n        while (dp[i]==inf){\n            i--;\n        }\n        System.out.println(i);\n    }\n    static int pos(int arr[],int ele){\n        int l=0,r=arr.length-1;\n        while (l<=r){\n            int mid=l+(r-l)/2;\n            if (arr[mid]<=ele){\n                l=mid+1;\n            }else r=mid-1;\n        }\n        return l;\n    }\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid solve();\nint main() {\n  ios_base::sync_with_stdio(false);\n  int t = 1;\n  while (t--) solve();\n  return 0;\n}\nint INF = 1000000000;\nint d[101010];\nint a[101010];\nvoid solve() {\n  int n;\n  cin >> n;\n  if (n == 1) {\n    cout << 1 << endl;\n    return;\n  }\n  for (int i = 0; i < n; ++i) cin >> a[i];\n  d[0] = -INF;\n  for (int i = 1; i <= n + 5; ++i) d[i] = INF;\n  for (int i = 0; i < n; i++) {\n    int j = int(upper_bound(d, d + n, a[i]) - d);\n    if (d[j - 1] < a[i] && a[i] < d[j]) d[j] = a[i];\n  }\n  int x = 0;\n  for (int i = 0;; ++i) {\n    if (d[i] == INF) {\n      cout << i - 1 << endl;\n      return;\n    }\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\n\npublic class shablon {\n\n\tstatic StringTokenizer st;\n\tstatic BufferedReader br;\n\tstatic PrintWriter pw;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tLocale.setDefault(Locale.US);\n\t\tScanner sc = new Scanner(System.in);\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tpw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(\n\t\t\t\tSystem.out)));\n\t\t// ffile();\n\t\tint n=nextInt();\n\t\tint a[]=new int [n+1];\n\t\tint d[]=new int [n+1];\n\t\tint INF = (int)(1e9+1);\n\t\tfor (int i = 1; i <=n; i++) {\n\t\t\ta[i]=nextInt();\n\t\t\t\n\t\t}\n\t\tArrays.fill(d,INF);\n\t\td[0]=-INF;\n\t\tfor (int i = 1; i <=n; i++) {\n\t\t\tint j=Arrays.binarySearch(d,a[i]);\n\t\t\tj=Math.abs(j)-1;\n\t\t\tif (a[i] < d[j] && a[i] > d[j-1]) {\n\t\t\t\td[j] = a[i];\n\t\t\t}\n\t\t}\n\t\tfor (int i = n; i >= 1; i--) {\n\t\t\tif (d[i] != INF) {\n\t\t\tpw.print(i);\n\t\t\tpw.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static long gcd(long x, long y) {\n\t\treturn y == 0 ? x : gcd(y, x % y);\n\t}\n\n\tprivate static void ffile() throws IOException {\n\t\tbr = new BufferedReader(new FileReader(new File(\"input.txt\")));\n\t\tpw = new PrintWriter(new BufferedWriter(new FileWriter(new File(\n\t\t\t\t\"output.txt\"))));\n\t}\n\n\tprivate static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tprivate static long nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tprivate static double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tprivate static String next() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\treturn st.nextToken();\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxN = 100020;\nint m, n;\nint a[maxN], s[maxN];\nint find(int v) {\n  int inf = 1;\n  int sup = m;\n  int res = 1;\n  while (inf <= sup) {\n    int mid = (inf + sup) >> 1;\n    if (v >= s[mid]) {\n      res = mid;\n      inf = mid + 1;\n    } else\n      sup = mid - 1;\n  }\n  return res;\n}\nint main() {\n  ios ::sync_with_stdio(false);\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  int j;\n  m = 1;\n  s[1] = a[1];\n  for (int i = 2; i <= n; i++) {\n    if (a[i] <= s[1])\n      s[1] = a[i];\n    else if (a[i] >= s[m]) {\n      s[++m] = a[i];\n    } else {\n      j = find(a[i]) + 1;\n      s[j] = a[i];\n    }\n  }\n  cout << m << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint n = 0;\nint plc[100008];\nint bit[100008];\nvoid add(int x, int vl) {\n  int k = 1;\n  while (x <= n) {\n    if (x & k) {\n      if (bit[x] < vl) bit[x] = vl;\n      x += k;\n    }\n    k += k;\n  }\n}\nint calc(int x) {\n  int ret = 0;\n  int k = 1;\n  while (x) {\n    if (x & k) {\n      if (bit[x] > ret) ret = bit[x];\n      x -= k;\n    }\n    k += k;\n  }\n  return ret;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    int as;\n    scanf(\"%d\", &as);\n    plc[as] = i;\n  }\n  int sol = 0;\n  for (int i = 1; i <= n; i++) {\n    int ksol = calc(plc[i] - 1) + 1;\n    if (sol < ksol) sol = ksol;\n    add(plc[i], ksol);\n  }\n  printf(\"%d\\n\", sol);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100004], L[100004], I[100004];\nint LIS(int a[], int n) {\n  I[0] = -2000000000;\n  for (int i = 1; i <= n; i++) I[i] = 2000000000;\n  int len = 0;\n  for (int i = 0; i < n; i++) {\n    int low, high, mid;\n    low = 0, high = len;\n    while (low <= high) {\n      mid = (low + high) / 2;\n      if (I[mid] < a[i])\n        low = mid + 1;\n      else\n        high = mid - 1;\n    }\n    I[low] = a[i];\n    if (len < low) len = low;\n  }\n  return len;\n}\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  cout << LIS(a, n) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, i, len, arr[100001], table[100001];\n  int hi, lo, mid, ans;\n  cin >> n;\n  for (i = 1; i <= n; i++) cin >> arr[i];\n  len = 1;\n  table[1] = arr[1];\n  for (i = 2; i <= n; i++) {\n    if (arr[i] < table[1])\n      table[1] = arr[i];\n    else if (arr[i] > table[len]) {\n      len++;\n      table[len] = arr[i];\n    } else {\n      lo = 1;\n      hi = len;\n      ans = -1;\n      while (lo <= hi) {\n        mid = (lo + hi) / 2;\n        if (table[mid] < arr[i]) {\n          if (ans == -1 || ans < mid) ans = mid;\n          lo = mid + 1;\n        } else\n          hi = mid - 1;\n      }\n      if (ans != -1) table[ans + 1] = arr[i];\n    }\n  }\n  cout << len << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> a;\nint main() {\n  int n, m, i, as = 0;\n  scanf(\"%d\", &n);\n  while (n--) {\n    scanf(\"%d\", &i);\n    m = lower_bound(a.begin(), a.end(), i) - a.begin();\n    if (m == a.size())\n      a.push_back(i);\n    else\n      a[m] = i;\n  }\n  printf(\"%d\\n\", a.size());\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastReader in = new FastReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\n\t\tint n = in.nextInt();\n\t\tint[] a = in.nextIntArray(n);\n\t\tout.println(lis(a, n));;\n\t\t\n\t\tout.close();\n\t}\n\tpublic static int lis(int[] a, int n) {\n\t\tint[] tail = new int[n];\n\t\tint len = 0;\n\n\t\tfor(int i = 0;i < n; ++i) {\n\t\t\tint pos = lowerBound(a, tail, len, a[i]);\n\t\t\tlen = Math.max(len, pos + 1);\n\t\t\ttail[pos] = i;\n\t\t}\n\t\treturn len;\n\t}\n\tpublic static int lowerBound(int[] a, int[] tail, int len, int key) {\n\t\tint high = len;\n\t\tint low = -1;\n\t\twhile (high - low > 1)  {\n\t\t\tint mid = (high + low) >>> 1;\n\t\t\tif(a[tail[mid]] < key) {\n\t\t\t\tlow = mid;\n\t\t\t} else {\n\t\t\t\thigh = mid;\n\t\t\t}\n\t\t}\n\t\treturn high;\n\t}\n\n\tstatic boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tpublic static void tr(Object... objects) {\n\t\tif (objects.length > 0 && !oj) {\n\t\t\tSystem.out.println(Arrays.deepToString(objects));\n\t\t}\n\t}\n\tstatic class FastReader {\n\t    private InputStream stream;\n\t    private final byte[] buf = new byte[8192];\n\t    private int curChar;\n\t    private int pnumChars;\n\n\t    public FastReader(InputStream stream) {\n\t        this.stream = stream;\n\t    }\n\n\t    private int pread() {\n\t        if (pnumChars == -1) {\n\t            throw new InputMismatchException();\n\t        }\n\t        if (curChar >= pnumChars) {\n\t            curChar = 0;\n\t            try {\n\t                pnumChars = stream.read(buf);\n\t            } catch (IOException e) {\n\t                throw new InputMismatchException();\n\t            }\n\t            if (pnumChars <= 0) {\n\t                return -1;\n\t            }\n\t        }\n\t        return buf[curChar++];\n\t    }\n\n\t    private int peek() {\n\t        if (pnumChars == -1) {\n\t            return -1;\n\t        }\n\t        if (curChar >= pnumChars) {\n\t            curChar = 0;\n\t            try {\n\t                pnumChars = stream.read(buf);\n\t            } catch (IOException e) {\n\t                return -1;\n\t            }\n\t            if (pnumChars <= 0) {\n\t                return -1;\n\t            }\n\t        }\n\t        return buf[curChar];\n\t    }\n\n\t    public int nextInt() {\n\t        int c = pread();\n\t        while (isSpaceChar(c))\n\t            c = pread();\n\t        int sgn = 1;\n\t        if (c == '-') {\n\t            sgn = -1;\n\t            c = pread();\n\t        }\n\t        int res = 0;\n\t        do {\n\t            if (c == ',') {\n\t                c = pread();\n\t            }\n\t            if (c < '0' || c > '9') {\n\t                throw new InputMismatchException();\n\t            }\n\t            res *= 10;\n\t            res += c - '0';\n\t            c = pread();\n\t        } while (!isSpaceChar(c));\n\t        return res * sgn;\n\t    }\n\n\t    public int[] nextIntArray(int n) {\n\t        int[] array = new int[n];\n\t        for (int i = 0; i < n; i++) {\n\t            array[i] = nextInt();\n\t        }\n\t        return array;\n\t    }\n\n\t    public long nextLong() {\n\t        int c = pread();\n\t        while (isSpaceChar(c))\n\t            c = pread();\n\t        int sgn = 1;\n\t        if (c == '-') {\n\t            sgn = -1;\n\t            c = pread();\n\t        }\n\t        long res = 0;\n\t        do {\n\t            if (c < '0' || c > '9') {\n\t                throw new InputMismatchException();\n\t            }\n\t            res *= 10;\n\t            res += c - '0';\n\t            c = pread();\n\t        } while (!isSpaceChar(c));\n\t        return res * sgn;\n\t    }\n\n\t    public long[] nextLongArray(int n) {\n\t        long[] array = new long[n];\n\t        for (int i = 0; i < n; i++) {\n\t            array[i] = nextLong();\n\t        }\n\t        return array;\n\t    }\n\n\t    public String nextString() {\n\t        int c = pread();\n\t        while (isSpaceChar(c))\n\t            c = pread();\n\t        StringBuilder res = new StringBuilder();\n\t        do {\n\t            res.appendCodePoint(c);\n\t            c = pread();\n\t        } while (!isSpaceChar(c));\n\t        return res.toString();\n\t    }\n\n\t    private boolean isSpaceChar(int c) {\n\t        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t    }\n\n\t    private boolean isEndOfLine(int c) {\n\t        return c == '\\n' || c == '\\r' || c == -1;\n\t    }\n\n\t    public String nextLine() {\n\t        int c = pread();\n\t        while (isSpaceChar(c))\n\t            c = pread();\n\t        StringBuilder res = new StringBuilder();\n\t        do {\n\t            res.appendCodePoint(c);\n\t            c = pread();\n\t        } while (!isEndOfLine(c));\n\t        return res.toString();\n\t    }\n\n\t    public BigInteger nextBigInteger() {\n\t        try {\n\t            return new BigInteger(nextString());\n\t        } catch (NumberFormatException e) {\n\t            throw new InputMismatchException();\n\t        }\n\t    }\n\n\t    public char nextCharacter() {\n\t        int c = pread();\n\t        while (isSpaceChar(c))\n\t            c = pread();\n\t        return (char) c;\n\t    }\n\n\t    public char[] nextCharacterArray(int n) {\n\t        char[] chars = new char[n];\n\t        for (int i = 0; i < n; i++) {\n\t            chars[i] = nextCharacter();\n\t        }\n\t        return chars;\n\t    }\n\n\t    public char[][] nextCharacterMap(int n, int m) {\n\t        char[][] map = new char[n][];\n\t        for (int i = 0; i < n; i++) {\n\t            map[i] = nextCharacterArray(m);\n\t        }\n\t        return map;\n\t    }\n\n\t    public double nextDouble() {\n\t        int c = pread();\n\t        while (isSpaceChar(c))\n\t            c = pread();\n\t        int sgn = 1;\n\t        if (c == '-') {\n\t            sgn = -1;\n\t            c = pread();\n\t        }\n\t        double res = 0;\n\t        while (!isSpaceChar(c) && c != '.') {\n\t            if (c == 'e' || c == 'E') {\n\t                return res * Math.pow(10, nextInt());\n\t            }\n\t            if (c < '0' || c > '9') {\n\t                throw new InputMismatchException();\n\t            }\n\t            res *= 10;\n\t            res += c - '0';\n\t            c = pread();\n\t        }\n\t        if (c == '.') {\n\t            c = pread();\n\t            double m = 1;\n\t            while (!isSpaceChar(c)) {\n\t                if (c == 'e' || c == 'E') {\n\t                    return res * Math.pow(10, nextInt());\n\t                }\n\t                if (c < '0' || c > '9') {\n\t                    throw new InputMismatchException();\n\t                }\n\t                m /= 10;\n\t                res += (c - '0') * m;\n\t                c = pread();\n\t            }\n\t        }\n\t        return res * sgn;\n\t    }\n\n\t    public boolean isExhausted() {\n\t        int value;\n\t        while (isSpaceChar(value = peek()) && value != -1)\n\t            pread();\n\t        return value == -1;\n\t    }\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.TreeSet;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author BSRK Aditya\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tScanner in = new Scanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskB solver = new TaskB();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskB {\n    public void solve(int testNumber, Scanner in, PrintWriter out) {\n        int n = in.nextInt();\n        int [] X = new int[n];\n        for(int i = 0; i < n; ++i) X[i] = in.nextInt();\n\n        TreeSet<Integer> st = new TreeSet<Integer>();\n\n        for(int i = 0; i < n; ++i) {\n            st.add(X[i]);\n            Integer it = st.higher(X[i]);\n            if(it != null) st.remove(it);\n\n        }\n\n        out.println(st.size());\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class CFR198Div2D {\n\n    public static void main(String[] args) {\n        CFR198Div2D solver = new CFR198Div2D();\n        solver.solve();\n    }\n\n    private void solve() {\n        Scanner sc = new Scanner(System.in);\n//        sc = new Scanner(\n//                \"3\\n\" +\n//                \"3 1 2\\n\");\n\n        int n = sc.nextInt();\n\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n        }\n\n        int[] e = new int[n + 1];\n        e[0] = Integer.MIN_VALUE;\n        for (int i = 1; i < n + 1; i++) {\n            e[i] = Integer.MAX_VALUE;\n        }\n\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            int l = 1;\n            int r = res + 1;\n            while (l < r) {\n                int k = (l + r) / 2;\n                if (e[k] < a[i]) l = k + 1;\n                if (e[k + 1] > a[i]) r = k;\n            }\n\n            e[l] = a[i];\n            res = Math.max(res, l);\n        }\n\n        System.out.println(res);\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class D {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint a[] = new int[n+1];\n\t\tint d[] = new int[n +1];\n\t\tArrays.fill(d, 1000000);\n\t\td[0] = -100000;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\tint k = Arrays.binarySearch(d, a[i]);\n\t\t\tif (k < 0) {\n\t\t\t\td[-1*k-1] = a[i];\n\t\t\t}\n\t\t}\n\t\tint ans = -1;\n\t\tfor (int i = 0; i < d.length; i++) {\n\t\t\tif (d[i] < 1000000){\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int inf = 1000000000;\nint n, m = 1, i, x, l, r, h, a[100100];\nint main() {\n  a[1] = inf;\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", &x);\n    l = 0;\n    r = m;\n    while (l < r) {\n      h = (l + r) / 2;\n      if (a[h] > x)\n        r = h;\n      else\n        l = h + 1;\n    }\n    a[r] = x;\n    if (r == m) a[++m] = inf;\n  }\n  printf(\"%d\\n\", m - 1);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "# Python program to find \n# length of longest \n# increasing subsequence \n# in O(n Log n) time \n\n# Binary search (note \n# boundaries in the caller) \n# A[] is ceilIndex \n# in the caller \ndef CeilIndex(A, l, r, key): \n\n\twhile (r - l > 1): \n\t\n\t\tm = l + (r - l)//2\n\t\tif (A[m] >= key): \n\t\t\tr = m \n\t\telse: \n\t\t\tl = m \n\treturn r \n\ndef Lis(A, size): \n\n\t# Add boundary case, \n\t# when array size is one \n\n\ttailTable = [0 for i in range(size + 1)] \n\tlen = 0 # always points empty slot \n\n\ttailTable[0] = A[0] \n\tlen = 1\n\tfor i in range(1, size): \n\t\n\t\tif (A[i] < tailTable[0]): \n\n\t\t\t# new smallest value \n\t\t\ttailTable[0] = A[i] \n\n\t\telif (A[i] > tailTable[len-1]): \n\n\t\t\t# A[i] wants to extend \n\t\t\t# largest subsequence \n\t\t\ttailTable[len] = A[i] \n\t\t\tlen+= 1\n\n\t\telse: \n\t\t\t# A[i] wants to be current \n\t\t\t# end candidate of an existing \n\t\t\t# subsequence. It will replace \n\t\t\t# ceil value in tailTable \n\t\t\ttailTable[CeilIndex(tailTable, -1, len-1, A[i])] = A[i] \n\t\t\n\n\treturn len\n\n\n# Driver program to \n# test above function \n\na=int(input())\nz=list(map(int,input().split()))\nprint(Lis(z,a))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxN = 1e5 + 10;\nint n, a[maxN], best[maxN], len;\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  for (int i = 0; i < n; i++) {\n    int x = lower_bound(best, best + len, a[i]) - best;\n    best[x] = a[i];\n    if (x == len) len++;\n  }\n  cout << len;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1000000007;\nconst long long UNDEF = -1;\nconst long long INF = 1e18;\ntemplate <typename T>\ninline bool chkmax(T& aa, T bb) {\n  return aa < bb ? aa = bb, true : false;\n}\ntemplate <typename T>\ninline bool chkmin(T& aa, T bb) {\n  return aa > bb ? aa = bb, true : false;\n}\nstatic char stdinBuffer[1024];\nstatic char* stdinDataEnd = stdinBuffer + sizeof(stdinBuffer);\nstatic const char* stdinPos = stdinDataEnd;\nvoid readAhead(size_t amount) {\n  size_t remaining = stdinDataEnd - stdinPos;\n  if (remaining < amount) {\n    memmove(stdinBuffer, stdinPos, remaining);\n    size_t sz = fread(stdinBuffer + remaining, 1,\n                      sizeof(stdinBuffer) - remaining, stdin);\n    stdinPos = stdinBuffer;\n    stdinDataEnd = stdinBuffer + remaining + sz;\n    if (stdinDataEnd != stdinBuffer + sizeof(stdinBuffer)) *stdinDataEnd = 0;\n  }\n}\nint rint() {\n  readAhead(16);\n  int x = 0;\n  bool neg = false;\n  while (*stdinPos == ' ' || *stdinPos == '\\n') ++stdinPos;\n  if (*stdinPos == '-') {\n    ++stdinPos;\n    neg = true;\n  }\n  while (*stdinPos >= '0' && *stdinPos <= '9') {\n    x *= 10;\n    x += *stdinPos - '0';\n    ++stdinPos;\n  }\n  return neg ? -x : x;\n}\nchar rch() {\n  readAhead(16);\n  while (*stdinPos == ' ' || *stdinPos == '\\n') ++stdinPos;\n  char ans = *stdinPos;\n  ++stdinPos;\n  return ans;\n}\nlong long rlong() {\n  readAhead(32);\n  long long x = 0;\n  bool neg = false;\n  while (*stdinPos == ' ' || *stdinPos == '\\n') ++stdinPos;\n  if (*stdinPos == '-') {\n    ++stdinPos;\n    neg = true;\n  }\n  while (*stdinPos >= '0' && *stdinPos <= '9') {\n    x *= 10;\n    x += *stdinPos - '0';\n    ++stdinPos;\n  }\n  return neg ? -x : x;\n}\nconst int mn = 1e5 + 4;\nint x[mn], p[mn], m[mn];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n = rint();\n  for (int i = 0; i < n; i++) x[i] = rint();\n  int l = 0;\n  for (int i = 0; i <= n - 1; i++) {\n    int lo = 1;\n    int hi = l;\n    while (lo <= hi) {\n      int mid = (lo + hi + 1) >> 1;\n      if (x[m[mid]] < x[i])\n        lo = mid + 1;\n      else\n        hi = mid - 1;\n    }\n    int newl = lo;\n    p[i] = m[newl - 1];\n    m[newl] = i;\n    if (newl > l) l = newl;\n  }\n  printf(\"%d\\n\", l);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100010;\nint n;\nint st[N], top;\nint main() {\n  scanf(\"%d\", &n);\n  st[top = 0] = 0;\n  for (int i = 0, x; i < n; ++i) {\n    scanf(\"%d\", &x);\n    int l = 0, r = top, mid;\n    while (r > l) {\n      mid = l + r + 1 >> 1;\n      if (st[mid] < x)\n        l = mid;\n      else\n        r = mid - 1;\n    }\n    if (r == top) top++;\n    st[r + 1] = x;\n  }\n  printf(\"%d\\n\", top);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1 << 17;\nconst int INF = (1 << 30);\nconst double PI = acos(-1.0);\nconst double EPS = (1e-6);\nint n, a[MAXN], ans, d[MAXN];\nint main() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  d[0] = -INF;\n  for (int i = 1; i <= n; ++i) d[i] = INF;\n  for (int i = 1; i <= n; i++) {\n    int j = int(upper_bound(d, d + n + 1, a[i]) - d);\n    if (d[j - 1] < a[i] && a[i] < d[j]) d[j] = a[i];\n  }\n  int ans = 1;\n  for (int i = 1; i <= n; i++)\n    if (d[i] != INF) ans = i;\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.PrintStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass TaskB {\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n        int n = in.nextInt();\n        int h = 1;\n        while (h < n + 10) h *= 2;\n        SegmentTreeFastAddMax tree = new SegmentTreeFastAddMax(h);\n        for (int i = 0; i < n; ++i) {\n            int x = in.nextInt();\n            int val = 0;\n            if (x > 1) {\n                val = tree.max(1, x - 1);\n            }\n            tree.set(x, Math.max(tree.get(x), val + 1));\n        }\n        out.printLine(tree.max(1, n + 5));\n    }\n}\n\nclass InputReader {\n    private InputStream stream;\n    private byte[] buffer = new byte[10000];\n    private int cur;\n    private int count;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public static boolean isSpace(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public int read() {\n        if (count == -1) {\n            throw new InputMismatchException();\n        }\n        try {\n            if (cur >= count) {\n                cur = 0;\n                count = stream.read(buffer);\n                if (count <= 0)\n                    return -1;\n            }\n        } catch (IOException e) {\n            throw new InputMismatchException();\n        }\n        return buffer[cur++];\n    }\n\n    public int readSkipSpace() {\n        int c;\n        do {\n            c = read();\n        } while (isSpace(c));\n        return c;\n    }\n\n    public int nextInt() {\n        int sgn = 1;\n        int c = readSkipSpace();\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9') {\n                throw new InputMismatchException();\n            }\n            res = res * 10 + c - '0';\n            c = read();\n        } while (!isSpace(c));\n        res *= sgn;\n        return res;\n    }\n\n    }\n\nclass OutputWriter {\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n        this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n        for (int i = 0; i < objects.length; i++) {\n            if (i != 0) {\n                writer.print(' ');\n            }\n            writer.print(objects[i]);\n        }\n    }\n\n    public void printLine(Object... objects) {\n        print(objects);\n        writer.println();\n    }\n\n    public void close() {\n        writer.close();\n    }\n\n    }\n\nclass SegmentTreeFastAddMax {\n    final int n;\n    final int[] t;\n\n    public SegmentTreeFastAddMax(int n) {\n        int h = 1;\n        while (h <= n) h *= 2;\n        n = h;\n        this.n = n;\n        t = new int[n + n];\n    }\n\n    public int get(int i) {\n        return t[i + n];\n    }\n\n    public void set(int i, int value) {\n        add(i, value - t[i + n]);\n    }\n\n    public void add(int i, int value) {\n        i += n;\n        t[i] += value;\n        for (; i > 1; i >>= 1)\n            t[i >> 1] = Math.max(t[i], t[i ^ 1]);\n    }\n\n    // max[a, b]\n    public int max(int a, int b) {\n        int res = Integer.MIN_VALUE;\n        for (a += n, b += n; a <= b; a = (a + 1) >> 1, b = (b - 1) >> 1) {\n            res = Math.max(res, t[a]);\n            res = Math.max(res, t[b]);\n        }\n        return res;\n    }\n\n    }\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        Task340D solver = new Task340D();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class Task340D {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            int arr[] = in.nextIntArray(n);\n            int max[] = new int[n];\n            int ans[] = new int[n];\n            Arrays.fill(max, Integer.MAX_VALUE - 5);\n            int i, fans = 1;\n\n\n            for (i = 0; i < n; i++) {\n                int index = find(arr[i], max, i);\n                ans[i] = index + 1;\n                max[index] = arr[i];\n                fans = Math.max(ans[i], fans);\n                //out.println(max);\n            }\n\n            //out.println(ans);\n            out.println(fans);\n        }\n\n        int find(int x, int max[], int i) {\n            int low = 0, high = i;\n            while (high - low > 1) {\n                int mid = (low + high) / 2;\n                if (max[mid] >= x)\n                    high = mid;\n                else\n                    low = mid;\n            }\n\n            if (max[low] >= x)\n                return low;\n            return high;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] array = new int[n];\n            for (int i = 0; i < n; ++i) array[i] = nextInt();\n            return array;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MAXN = 100000;\nint P[MAXN + 1];\nint tree[MAXN + 1] = {0};\nint max(int x) {\n  int ret = 0, i;\n  for (i = x; i; i -= (i & -i))\n    if (ret < tree[i]) ret = tree[i];\n  return ret;\n}\nvoid relax(int x, int val) {\n  int i;\n  for (i = x; i <= MAXN; i += (i & -i))\n    if (tree[i] < val) tree[i] = val;\n}\nint main() {\n  int n, i;\n  int val, ans;\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; ++i) scanf(\"%d\", P + i);\n  ans = 0;\n  for (i = 1; i <= n; ++i) {\n    val = 1 + max(P[i] - 1);\n    if (ans < val) ans = val;\n    relax(P[i], val);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\nint n, a[N], c[N];\ninline void C(int w, int x) {\n  for (; w <= n; w += w & -w)\n    if (x > c[w]) c[w] = x;\n}\ninline int Q(int w) {\n  int ans = 0;\n  for (; w; w -= w & -w)\n    if (c[w] > ans) ans = c[w];\n  return ans;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n  for (int i = 1; i <= n; ++i) {\n    C(a[i], Q(a[i]) + 1);\n  }\n  printf(\"%d\\n\", Q(n));\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class taskB {\n\n\tstatic final int POSITIVE_INFINITY = Integer.MAX_VALUE / 2;\n\n\tvoid solve() throws IOException {\n\t\tint n = nextInt();\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\n\t\tint[] d = new int[n + 1];\n\t\tArrays.fill(d, POSITIVE_INFINITY);\n\t\td[0] = 0;\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint l = 0;\n\t\t\tint r = n;\n\t\t\twhile (l < r - 1) {\n\t\t\t\tint c = (l + r) / 2;\n\t\t\t\tif (d[c] < a[i])\n\t\t\t\t\tl = c;\n\t\t\t\telse\n\t\t\t\t\tr = c;\n\t\t\t}\n\t\t\td[l + 1] = a[i];\n\t\t\tans = Math.max(ans, l + 1);\n\t\t}\n\t\tout.println(ans);\n\t}\n\n\tBufferedReader br;\n\tStringTokenizer st;\n\tPrintWriter out;\n\n\tvoid run() {\n\t\ttry {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\n\t\t\t// br = new BufferedReader(new FileReader(new File(\"taskB.in\")));\n\t\t\t// out = new PrintWriter(\"taskB.out\");\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew taskB().run();\n\t}\n\n\tString nextToken() throws IOException {\n\t\twhile ((st == null) || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt() throws NumberFormatException, IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tdouble nextDouble() throws NumberFormatException, IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tlong nextLong() throws NumberFormatException, IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename F, typename S>\nostream &operator<<(ostream &os, const pair<F, S> &p) {\n  return os << \"(\" << p.first << \", \" << p.second << \")\";\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  os << \"{\";\n  for (auto it = v.begin(); it != v.end(); ++it) {\n    if (it != v.begin()) os << \", \";\n    os << *it;\n  }\n  return os << \"}\";\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, const set<T> &v) {\n  os << \"[\";\n  for (auto it = v.begin(); it != v.end(); ++it) {\n    if (it != v.begin()) os << \", \";\n    os << *it;\n  }\n  return os << \"]\";\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, const multiset<T> &v) {\n  os << \"[\";\n  for (auto it = v.begin(); it != v.end(); ++it) {\n    if (it != v.begin()) os << \", \";\n    os << *it;\n  }\n  return os << \"]\";\n}\ntemplate <typename F, typename S>\nostream &operator<<(ostream &os, const map<F, S> &v) {\n  os << \"[\";\n  for (auto it = v.begin(); it != v.end(); ++it) {\n    if (it != v.begin()) os << \", \";\n    os << it->first << \" = \" << it->second;\n  }\n  return os << \"]\";\n}\nvoid faltu() { cerr << endl; }\ntemplate <typename T>\nvoid faltu(T a[], int n) {\n  for (int i = 0; i < n; ++i) cerr << a[i] << ' ';\n  cerr << endl;\n}\ntemplate <typename T, typename... hello>\nvoid faltu(T arg, const hello &...rest) {\n  cerr << arg << ' ';\n  faltu(rest...);\n}\nconst int fx[] = {+1, -1, +0, +0};\nconst int fy[] = {+0, +0, +1, -1};\nlong long Set(long long &N, long long pos) { return N = N | (1ll << pos); }\nlong long Reset(long long &N, long long pos) { return N = N & ~(1ll << pos); }\nbool check(long long N, long long pos) { return (bool)(N & (1ll << pos)); }\nvoid INITIALIZE() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n}\ninline long long add(long long a, long long b) {\n  return (a + b >= 1000000007) ? (a + b - 1000000007) : (a + b);\n}\ninline long long sub(long long a, long long b) {\n  return (a - b < 0) ? (a - b + 1000000007) : (a - b);\n}\ninline long long mul(long long a, long long b) {\n  return (a * 1ll * b) % 1000000007;\n}\nvoid Binary(long long x) {\n  for (int i = 31; i >= 0; i--) {\n    if ((1 << i) & x)\n      cerr << \"1\";\n    else\n      cerr << \"0\";\n  }\n  cerr << \"\\n\";\n}\nlong long ncr(long long n, long long r) {\n  long long ans = 1;\n  if (r > n - r) r = n - r;\n  for (long long i = 1; i <= r; i++) {\n    ans *= (n - i + 1), ans /= i;\n  }\n  return ans;\n}\nlong long pow(long long a, long long b) {\n  long long res = 1;\n  while (b > 0) {\n    if (b & 1) res = (res * a) % 1000000007;\n    b >>= 1;\n    a = (a * a) % 1000000007;\n  }\n  return res;\n}\nconst long long mxn = 1e5 + 5;\nvector<long long> bit(mxn);\nlong long n;\nvoid update(long long pos, long long val) {\n  for (; pos <= n; pos += pos & -pos) bit[pos] = max(bit[pos], val);\n}\nlong long query(long long pos) {\n  long long ans = 0;\n  for (; pos; pos -= pos & -pos) ans = max(ans, bit[pos]);\n  return ans;\n}\nvoid solve() {\n  cin >> n;\n  long long mx = 0;\n  for (int i = 0; i < n; i++) {\n    long long x;\n    cin >> x;\n    long long koita = query(x);\n    mx = max(mx, koita + 1);\n    update(x, koita + 1);\n  }\n  cout << mx << endl;\n}\nint main() {\n  INITIALIZE();\n  int t;\n  t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint f[101000], dp[101000], a[101000];\nint n;\nint tot;\nint find(int x) {\n  int l = 0, r = tot;\n  int ans = 0;\n  while (l <= r) {\n    int mid = (l + r) >> 1;\n    if (f[mid] <= x) {\n      ans = max(mid, ans);\n      l = mid + 1;\n    } else\n      r = mid - 1;\n  }\n  return ans;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int(i) = 0; (i) < (n); (i)++) scanf(\"%d\", &a[i]);\n  memset(dp, 0, sizeof(dp));\n  tot = 0;\n  for (int i = 0; i < n; i++) {\n    int j = find(a[i]);\n    dp[i] = j + 1;\n    if (j + 1 > tot) {\n      tot++;\n      f[j + 1] = a[i];\n    } else\n      f[j + 1] = min(f[j + 1], a[i]);\n  }\n  int ans = 0;\n  for (int(i) = 0; (i) < (n); (i)++) ans = max(ans, dp[i]);\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 2000000000;\nint n;\nint Sequence[100010];\nint L[100010];\nint I[100010];\nvoid takeInput() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) scanf(\"%d\", &Sequence[i]);\n}\nint LisNlogK() {\n  int i;\n  I[0] = -inf;\n  for (i = 1; i <= n; i++) I[i] = inf;\n  int LisLength = 0;\n  for (i = 0; i < n; i++) {\n    int low, high, mid;\n    low = 0;\n    high = LisLength;\n    while (low <= high) {\n      mid = (low + high) / 2;\n      if (I[mid] < Sequence[i])\n        low = mid + 1;\n      else\n        high = mid - 1;\n    }\n    I[low] = Sequence[i];\n    if (LisLength < low) LisLength = low;\n  }\n  return LisLength;\n}\nint main() {\n  takeInput();\n  int result = LisNlogK();\n  cout << result << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class cf341b {\n  public static void main(String[] args) {\n    FastIO in = new FastIO(), out = in;\n    int n = in.nextInt();\n    int[] v = new int[n];\n    for(int i=0; i<n; i++) v[i] = in.nextInt();\n    int[] lis = new int[n+5];\n    Arrays.fill(lis, n+10);\n    lis[0] = 0;\n    int best = 0;\n    for(int i=0; i<n; i++) {\n      int lo = 0, hi = best;\n      while(hi - lo > 2) {\n        int m = (hi+lo)/2;\n        if(lis[m] < v[i]) lo = m;\n        else hi = m;\n      }\n      while(lis[lo] < v[i]) lo++;\n      lis[lo] = Math.min(lis[lo],v[i]);\n      best = Math.max(best,lo);\n    }\n    out.println(best);\n    out.close();\n  }\n\n  static class FastIO extends PrintWriter {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastIO() {\n      this(System.in, System.out);\n    }\n\n    public FastIO(InputStream in, OutputStream out) {\n      super(new BufferedWriter(new OutputStreamWriter(out)));\n      br = new BufferedReader(new InputStreamReader(in));\n      scanLine();\n    }\n\n    public void scanLine() {\n      try {\n        st = new StringTokenizer(br.readLine().trim());\n      } catch (Exception e) {\n        throw new RuntimeException(e.getMessage());\n      }\n    }\n\n    public int numTokens() {\n      if (!st.hasMoreTokens()) {\n        scanLine();\n        return numTokens();\n      }\n      return st.countTokens();\n    }\n\n    public String next() {\n      if (!st.hasMoreTokens()) {\n        scanLine();\n        return next();\n      }\n      return st.nextToken();\n    }\n\n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, a[100010], lis[100010], m;\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < (n); i++) scanf(\"%d\", a + i);\n  lis[m++] = 0;\n  for (int i = 0; i < (n); i++) {\n    if (a[i] > lis[m - 1])\n      lis[m++] = a[i];\n    else\n      *lower_bound(lis, lis + m, a[i]) = a[i];\n  }\n  printf(\"%d\\n\", m - 1);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100010;\nint n, a[N], t[N], sol;\nvoid upd(int i, int v) {\n  for (; i <= n; i += i & -i) t[i] = max(t[i], v);\n}\nint get(int i) {\n  int s = 0;\n  for (; i; i -= i & -i) s = max(s, t[i]);\n  return s;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  for (int i = 1; i <= n; i++) {\n    int x = get(a[i] - 1) + 1;\n    sol = max(sol, x);\n    upd(a[i], x);\n  }\n  printf(\"%d\\n\", sol);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.util.TreeSet;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            BBubbleSortGraph solver = new BBubbleSortGraph();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class BBubbleSortGraph {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.ri();\n            int[] a = in.ri(n);\n            TreeSet<Integer> set = new TreeSet<>();\n            for (int x : a) {\n                Integer ceil = set.ceiling(x);\n                if (ceil != null) {\n                    set.remove(ceil);\n                }\n                set.add(x);\n            }\n            out.println(set.size());\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        public void populate(int[] data) {\n            for (int i = 0; i < data.length; i++) {\n                data[i] = readInt();\n            }\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int ri() {\n            return readInt();\n        }\n\n        public int[] ri(int n) {\n            int[] ans = new int[n];\n            populate(ans);\n            return ans;\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private static final int THRESHOLD = 32 << 10;\n        private final Writer os;\n        private StringBuilder cache = new StringBuilder(THRESHOLD * 2);\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        private void afterWrite() {\n            if (cache.length() < THRESHOLD) {\n                return;\n            }\n            flush();\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            return append('\\n');\n        }\n\n        public FastOutput flush() {\n            try {\n//            boolean success = false;\n//            if (stringBuilderValueField != null) {\n//                try {\n//                    char[] value = (char[]) stringBuilderValueField.get(cache);\n//                    os.write(value, 0, cache.length());\n//                    success = true;\n//                } catch (Exception e) {\n//                }\n//            }\n//            if (!success) {\n                os.append(cache);\n//            }\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int INF = 1LL << 60;\nlong long int n, m, k, x, y, z;\nint mod = 1e9 + 7;\nlong long int add(long long int a, long long int b) {\n  if (a + b >= mod) return a + b - mod;\n  return a + b;\n}\nlong long int sub(long long int a, long long int b) {\n  if (a < b) return a - b + mod;\n  return a - b;\n}\nlong long int mul(long long int a, long long int b) {\n  return 1LL * a * b % mod;\n}\nint power(int a, int b) {\n  if (b < 0) return 0;\n  int re = 1;\n  while (b) {\n    if (b & 1) {\n      re = mul(re, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return re;\n}\nbool sortbysec(const pair<long long int, long long int> &a,\n               const pair<long long int, long long int> &b) {\n  return (a.second < b.second);\n}\nbool sortbyfi(\n    const pair<long long int, pair<long long int, long long int>> &a,\n    const pair<long long int, pair<long long int, long long int>> &b) {\n  return (a.first > b.first);\n}\npriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>\n    pq;\nlong long int bs(vector<long long int> v, long long int x) {\n  long long int hi = v.size() - 1, lo = 0;\n  while (hi >= lo) {\n    long long int mid = lo + (hi - lo) / 2;\n    if (v[mid] == x)\n      return 1;\n    else if (v[mid] < x)\n      lo = mid + 1;\n    else\n      hi = mid - 1;\n  }\n  return 0;\n}\nbool paired(char a, char b) {\n  if (a == '[' and b == ']') return true;\n  if (a == '{' and b == '}') return true;\n  if (a == '(' and b == ')') return true;\n  if (a == '<' and b == '>') return true;\n  return false;\n}\nbool cmp(pair<long long int, vector<long long int>> a,\n         pair<long long int, vector<long long int>> b) {\n  return a.first > b.first;\n}\nlong long int dp[200005] = {0};\nvoid update1(long long int idx, long long int val) {\n  while (idx <= 100000) {\n    dp[idx] = max(dp[idx], val);\n    idx += idx & -idx;\n  }\n}\nlong long int pref1(long long int idx) {\n  long long int ans = 0;\n  while (idx > 0) {\n    ans = max(dp[idx], ans);\n    idx -= idx & -idx;\n  }\n  return ans;\n}\nlong long int bit[200005] = {0};\nvoid update(long long int idx, long long int val) {\n  while (idx <= 100000) {\n    bit[idx] += val;\n    idx += idx & -idx;\n  }\n}\nlong long int pref(long long int idx) {\n  long long int ans = 0;\n  while (idx > 0) {\n    ans += bit[idx];\n    idx -= idx & -idx;\n  }\n  return ans;\n}\nlong long int rsum(long long int l, long long int r) {\n  return pref(r) - pref(l - 1);\n}\nlong long int nextPowerOf2(long long int n) {\n  long long int count = 0;\n  if (n && !(n & (n - 1))) return n;\n  while (n != 0) {\n    n >>= 1;\n    count += 1;\n  }\n  return 1 << count;\n}\nvoid Birdperson() {\n  cin >> n;\n  long long int a[n];\n  for (int i = 0; i < (n); ++i) cin >> a[i];\n  memset(dp, 0, sizeof(dp));\n  long long int ans = 0;\n  for (int i = 0; i < (n); ++i) {\n    long long int j = pref1(a[i]) + 1;\n    ans = max(ans, j);\n    update1(a[i], j);\n  }\n  cout << ans << \"\\n\";\n}\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long int t = 1;\n  long long int cnt = 1;\n  while (cnt <= t) {\n    Birdperson();\n    cnt++;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100005];\nstruct Fenwick {\n  int a[200000];\n  Fenwick() {\n    for (int i = 0; i < 200000; ++i) a[i] = 0;\n  }\n  void update(int i, int c) {\n    for (; i < 200000; i |= i + 1) {\n      a[i] = max(c, a[i]);\n    }\n  }\n  int query(int i) {\n    int ret = 0;\n    for (; i >= 0; i = (i & (i + 1)) - 1) ret = max(ret, a[i]);\n    return ret;\n  }\n} fenwick;\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", a + i);\n    fenwick.update(a[i], fenwick.query(a[i]) + 1);\n  }\n  printf(\"%d\", fenwick.query(n));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 1e9 + 7;\nint INF = 1e6;\nlong long int n, m;\nlong long int CeilIndex(std::vector<long long int>& vector, long long int l,\n                        long long int r, long long int key) {\n  while (r - l > 1) {\n    long long int m = l + (r - l) / 2;\n    if (vector[m] >= key)\n      r = m;\n    else\n      l = m;\n  }\n  return r;\n}\nlong long int LongestIncreasingSubsequenceLength(\n    std::vector<long long int>& vector) {\n  if (vector.size() == 0) return 0;\n  std::vector<long long int> tail(vector.size(), 0);\n  long long int length = 1;\n  tail[0] = vector[0];\n  for (size_t i = 1; i < vector.size(); i++) {\n    if (vector[i] < tail[0])\n      tail[0] = vector[i];\n    else if (vector[i] > tail[length - 1])\n      tail[length++] = vector[i];\n    else\n      tail[CeilIndex(tail, -1, length - 1, vector[i])] = vector[i];\n  }\n  return length;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  long long int i, j, k, x, y, z, N;\n  cin >> n;\n  vector<long long int> a(n);\n  for (i = 0; i < n; i++) cin >> a[i];\n  cout << LongestIncreasingSubsequenceLength(a);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\n\n// atharva washimkar\n// May 07, 2018\n\npublic class CODEFORCES_340_D {\n\n\tpublic static int ceil (int[] arr, int l, int r, int x) {\n\t\twhile (r > l + 1) {\n\t\t\tint mid = (l + r) / 2;\n\n\t\t\tif (arr[mid] >= x)\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\n\t\treturn r;\n\t}\n\n\tpublic static void main (String[] t) throws IOException {\n\t\tINPUT in = new INPUT (System.in);\n\t\tPrintWriter out = new PrintWriter (System.out);\n\n\t\tint N = in.iscan ();\n\t\tint[] arr = new int[N];\n\n\t\tfor (int n = 0; n < N; ++n)\n\t\t\tarr[n] = in.iscan ();\n\n\t\t// find LIS (as increasing elements aren't directly connected by edge)\n\t\t// dp[n] = smallest end to LIS of length (n - 1)\n\t\tint[] dp = new int[N];\n\n\t\tdp[0] = arr[0];\n\t\tint len = 1;\n\n\t\tfor (int n = 1; n < N; ++n) {\n\t\t\tif (dp[0] > arr[n])\n\t\t\t\t// replace smallest element\n\t\t\t\tdp[0] = arr[n];\n\n\t\t\telse if (dp[len - 1] < arr[n])\n\t\t\t\t// extend lis by one element\n\t\t\t\tdp[len++] = arr[n];\n\n\t\t\telse\n\t\t\t\t// use (ceil) binary search to find which element to replace\n\t\t\t\tdp[ceil (dp, 0, len - 1, arr[n])] = arr[n];\n\t\t}\n\n\t\tout.print (len);\n\t\tout.close ();\n\t}\n\n\tprivate static class INPUT {\n\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar, numChars;\n\n\t\tpublic INPUT (InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic INPUT (String file) throws IOException {\n\t\t\tthis.stream = new FileInputStream (file);\n\t\t}\n\n\t\tpublic int cscan () throws IOException {\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\tnumChars = stream.read (buf);\n\t\t\t}\n\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int iscan () throws IOException {\n\t\t\tint c = cscan (), sgn = 1;\n\t\t\twhile (space (c)) c = cscan ();\n\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = cscan ();\n\t\t\t}\n\n\t\t\tint res = 0;\n\n\t\t\tdo {\n\t\t\t\tres = (res << 1) + (res << 3);\n\t\t\t\tres += c - '0';\n\t\t\t\tc = cscan ();\n\t\t\t}\n\t\t\twhile (!space (c));\n\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic String sscan () throws IOException {\n\t\t\tint c = cscan ();\n\t\t\twhile (space (c)) c = cscan ();\n\n\t\t\tStringBuilder res = new StringBuilder ();\n\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint (c);\n\t\t\t\tc = cscan ();\n\t\t\t}\n\t\t\twhile (!space (c));\n\n\t\t\treturn res.toString ();\n\t\t}\n\n\t\tpublic double dscan () throws IOException {\n\t\t\tint c = cscan (), sgn = 1;\n\t\t\twhile (space (c)) c = cscan ();\n\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = cscan ();\n\t\t\t}\n\n\t\t\tdouble res = 0;\n\n\t\t\twhile (!space (c) && c != '.') {\n\t\t\t\tif (c == 'e' || c == 'E') return res * UTILITIES.fast_pow (10, iscan ());\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = cscan ();\n\t\t\t}\n\n\t\t\tif (c == '.') {\n\t\t\t\tc = cscan ();\n\t\t\t\tdouble m = 1;\n\n\t\t\t\twhile (!space (c)) {\n\t\t\t\t\tif (c == 'e' || c == 'E') return res * UTILITIES.fast_pow (10, iscan ());\n\n\t\t\t\t\tm /= 10;\n\t\t\t\t\tres += (c - '0') * m;\n\t\t\t\t\tc = cscan ();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic long lscan () throws IOException {\n\t\t\tint c = cscan (), sgn = 1;\n\t\t\twhile (space (c)) c = cscan ();\n\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = cscan ();\n\t\t\t}\n\n\t\t\tlong res = 0;\n\n\t\t\tdo {\n\t\t\t\tres = (res << 1) + (res << 3);\n\t\t\t\tres += c - '0';\n\t\t\t\tc = cscan ();\n\n\t\t\t}\n\t\t\twhile (!space (c));\n\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic boolean space (int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\t}\n\n\tpublic static class UTILITIES {\n\n\t\tstatic final double EPS = 10e-6;\n\n\t\tpublic static int lower_bound (int[] arr, int x) {\n\t\t\tint low = 0, high = arr.length, mid = -1;\n\n\t\t\twhile (low < high) {\n\t\t\t\tmid = (low + high) / 2;\n\n\t\t\t\tif (arr[mid] >= x)\n\t\t\t\t\thigh = mid;\n\t\t\t\telse\n\t\t\t\t\tlow = mid + 1;\n\t\t\t}\n\n\t\t\treturn low;\n\t\t}\n\n\t\tpublic static int upper_bound (int[] arr, int x) {\n\t\t\tint low = 0, high = arr.length, mid = -1;\n\n\t\t\twhile (low < high) {\n\t\t\t\tmid = (low + high) / 2;\n\n\t\t\t\tif (arr[mid] > x)\n\t\t\t\t\thigh = mid;\n\t\t\t\telse\n\t\t\t\t\tlow = mid + 1;\n\t\t\t}\n\n\t\t\treturn low;\n\t\t}\n\n\t\tpublic static int gcd (int a, int b) {\n\t\t\treturn b == 0 ? a : gcd (b, a % b);\n\t\t}\n\n\t\tpublic static int lcm (int a, int b) {\n\t\t\treturn a * b / gcd (a, b);\n\t\t}\n\n\t\tpublic static int fast_pow_mod (int b, int x, int mod) {\n\t\t\tif (x == 0) return 1;\n\t\t\tif (x == 1) return b;\n\t\t\tif (x % 2 == 0) return fast_pow_mod (b * b % mod, x / 2, mod) % mod;\n\n\t\t\treturn b * fast_pow_mod (b * b % mod, x / 2, mod) % mod;\n\t\t}\n\n\t\tpublic static int fast_pow (int b, int x) {\n\t\t\tif (x == 0) return 1;\n\t\t\tif (x == 1) return b;\n\t\t\tif (x % 2 == 0) return fast_pow (b * b, x / 2);\n\n\t\t\treturn b * fast_pow (b * b, x / 2);\n\t\t}\n\n\t\tpublic static long choose (long n, long k) {\n\t\t\tk = Math.min (k, n - k);\n\t\t\tlong val = 1;\n\n\t\t\tfor (int i = 0; i < k; ++i)\n\t\t\t\tval = val * (n - i) / (i + 1);\n\n\t\t\treturn val;\n\t\t}\n\n\t\tpublic static long permute (int n, int k) {\n\t\t\tif (n < k) return 0;\n\t\t\tlong val = 1;\n\n\t\t\tfor (int i = 0; i < k; ++i)\n\t\t\t\tval = (val * (n - i));\n\n\t\t\treturn val;\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1000000007;\nconst long long linf = 1LL << 62;\nconst unsigned long long ulinf = 1ULL << 63;\nconst double eps = 0.000001;\nconst double pi = 3.14159265358979323846;\ntemplate <class T>\nT abs(T a) {\n  return a >= 0 ? a : -a;\n}\ntemplate <class T>\nT sqr(T a) {\n  return a * a;\n}\ntemplate <class T>\nT gcd(T a, T b) {\n  return b ? gcd(b, a % b) : a;\n}\ntemplate <class T>\nT mod(T a, T b) {\n  return (a % b + b) % b;\n}\nlong long powmod(long long a, long long b, long long c) {\n  if (b == 0) return 1;\n  long long ret = powmod(a, b >> 1, c);\n  ret = ret * ret % c;\n  if (b & 1) ret = ret * a % c;\n  return ret;\n}\ntemplate <class T>\nvoid maxe(T &a, T b) {\n  if (a < b) a = b;\n}\ntemplate <class T>\nvoid mine(T &a, T b) {\n  if (a > b) a = b;\n}\nint iszero(double a) { return abs(a) <= eps; }\ntemplate <class T>\nvoid geti(T &a) {\n  a = 0;\n  T b = 1;\n  char c = getchar();\n  if (c == '-')\n    b = -1;\n  else\n    a = c - 48;\n  while ((c = getchar()) != ' ' && c != '\\n') a = a * 10 + c - 48;\n  a *= b;\n}\nvoid fileio_in_out() {\n  freopen(\".in\", \"r\", stdin);\n  freopen(\".out\", \"w\", stdout);\n}\nvoid fileio_txt() {\n  freopen(\"input.txt\", \"r\", stdin);\n  freopen(\"output.txt\", \"w\", stdout);\n}\nconst int N = 111111;\nconst int M = 18;\nint test;\nint n, m, k, ans;\nint a[N], b[N];\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    b[i] = inf;\n  }\n  b[0] = -inf;\n  for (int i = 1; i <= n; i++) {\n    int l = 0, r = i, mid;\n    while (l < r) {\n      mid = (l + r + 1) >> 1;\n      if (a[i] > b[mid])\n        l = mid;\n      else\n        r = mid - 1;\n    }\n    if (a[i] < b[l + 1]) {\n      b[l + 1] = a[i];\n      maxe(ans, l + 1);\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int i, j, k, m, n;\n  cin >> n;\n  vector<int> d(n);\n  vector<int> g(n);\n  for (i = 0; i < n; ++i) {\n    cin >> d[i];\n  }\n  g[0] = d[0];\n  int l, r, len = 1;\n  for (i = 1; i < n; ++i) {\n    l = 0;\n    r = len;\n    while (l < r) {\n      int m = l + (r - l) / 2;\n      if (d[i] < g[m])\n        r = m;\n      else if (d[i] == g[m])\n        l = m;\n      else\n        l = m + 1;\n    }\n    if (l == len) len++;\n    g[l] = d[i];\n  }\n  cout << len << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int nm = 100002;\nint n, m;\nint a[nm];\nint b[nm], startof[nm];\nvoid nhap() {\n  scanf(\"%d\", &n);\n  int i;\n  for (i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n}\nint find(int i) {\n  int l, r, mid, kq;\n  l = 0;\n  r = m;\n  do {\n    mid = (l + r) / 2;\n    if (a[startof[mid]] > a[i]) {\n      kq = mid;\n      l = mid + 1;\n    } else\n      r = mid - 1;\n  } while (l <= r);\n  return (startof[kq]);\n}\nvoid xuli() {\n  b[0] = 0;\n  b[n] = 1;\n  startof[1] = n;\n  startof[0] = n + 1;\n  a[n + 1] = n + 1;\n  m = 1;\n  int i, j;\n  for (i = n - 1; i >= 1; --i) {\n    j = find(i);\n    b[i] = b[j] + 1;\n    if (b[i] > m) {\n      m = b[i];\n      startof[m] = i;\n    } else {\n      if (a[i] > a[startof[b[i]]]) startof[b[i]] = i;\n    }\n  }\n  printf(\"%d\", m);\n}\nint main() {\n  nhap();\n  xuli();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100001], bit[100001];\nint n, Max = 0, now;\nvoid updateBIT(int x, int k) {\n  while (x <= n) {\n    if (bit[x] < k)\n      bit[x] = k;\n    else\n      break;\n    x += x & (-x);\n  }\n}\nvoid AskBIT(int x) {\n  while (x > 0) {\n    if (bit[x] > now) now = bit[x];\n    x -= x & (-x);\n  }\n}\nint main() {\n  int i, j;\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    bit[i] = 0;\n  }\n  for (i = 1; i <= n; i++) {\n    now = 0;\n    AskBIT(a[i] - 1);\n    if (now + 1 > Max) Max = now + 1;\n    updateBIT(a[i], now + 1);\n  }\n  cout << Max;\n}\n"
        },
        {
            "language": 4,
            "solution": "/*\n ID: govind.3, GhpS, govindpatel\n LANG: JAVA\n TASK: Main \n */\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    int[] next;\n\n    private int next(int i) {\n        if (next[i] == i) {\n            return i;\n        }\n        return next[i] = next(next[i]);\n    }\n\n    private void set(int[] t, int ind, int val) {\n        ind += (t.length / 2);\n        t[ind] = val;\n        int curr = 0;\n        while (ind > 1) {\n            ind >>= 1;\n            if (curr == 0) {\n                t[ind] = t[ind * 2] | t[ind * 2 + 1];\n            } else {\n                t[ind] = t[ind * 2] ^ t[2 * ind + 1];\n            }\n            curr ^= 1;\n        }\n    }\n\n    private void solve() throws IOException {\n        StringBuilder sb = new StringBuilder(\"\");\n        int N = nextInt();\n        ArrayList<Integer> al = new ArrayList<Integer>();\n        for (int i = 0; i < N; i++) {\n            int in = nextInt();\n            int index = -Collections.binarySearch(al, in) - 1;\n            //System.err.println(index + \" \"+Collections.binarySearch(al,in));\n            if (index >= al.size()) {\n                al.add(in);\n            } else {\n                al.set(index, in);\n            }\n        }\n\n        out.println(al.size());\n    }\n\n    private void shuffle(int[] a, int N) {\n        for (int i = 0; i < N; i++) {\n            int r = i + (int) ((N - i) * Math.random());\n            int t = a[i];\n            a[i] = a[r];\n            a[r] = t;\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    public void run() {\n        try {\n            in = new BufferedReader(new FileReader(\"D-large.in\"));\n            out = new PrintWriter(new BufferedWriter(new FileWriter(\"Main.out\")));\n            tok = null;\n            solve();\n            in.close();\n            out.close();\n            System.exit(0);\n        } catch (IOException e) {//(FileNotFoundException e) {\n            try {\n                in = new BufferedReader(new InputStreamReader(System.in));\n                out = new PrintWriter(new OutputStreamWriter(System.out));\n                tok = null;\n                solve();\n                in.close();\n                out.close();\n                System.exit(0);\n            } catch (IOException ex) {\n                System.out.println(ex.getMessage());\n                System.exit(0);\n            }\n        }\n    }\n\n    private String nextToken() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n\n    private int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    private long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    private double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n    BufferedReader in;\n    StringTokenizer tok;\n    PrintWriter out;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, m;\nlong d[100005];\nlong a[100005];\nbool f = true;\nunsigned long long z = 0;\nint main() {\n  cin >> n;\n  for (long long i = 1; i <= n; i++) {\n    cin >> a[i];\n  }\n  for (long i = 1; i <= n + 1; i++) {\n    d[i] = 110000000;\n  }\n  d[1] = a[1];\n  for (long i = 2; i <= n; i++) {\n    long l = 1, r = i;\n    if (d[1] > a[i]) {\n      d[1] = a[i];\n      continue;\n    }\n    while (l < r) {\n      long m = l + (r - l) / 2;\n      if (d[m] >= a[i])\n        r = m;\n      else\n        l = m + 1;\n    }\n    d[r] = a[i];\n  }\n  for (long i = 1; i <= n + 1; i++) {\n    z = i - 1;\n    if (d[i] == 110000000) break;\n  }\n  cout << z;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, t, ans, c[500000], table[500000], maxx;\nvector<pair<int, int> > a;\nvoid Array_Compression() {\n  sort(a.begin(), a.end());\n  int dem = 1;\n  t = n;\n  c[a[0].second] = 1;\n  for (int i = 1; i <= a.size() - 1; i++) {\n    if (a[i].first > a[i - 1].first) dem++;\n    c[a[i].second] = dem;\n  }\n  maxx = dem;\n}\nint Get(int k) {\n  int res = 0;\n  while (k > 0) {\n    res = max(res, table[k]);\n    k -= (k & (-k));\n  }\n  return (res);\n}\nvoid Update(int x, int y) {\n  while (x <= n) {\n    table[x] = max(table[x], y);\n    x += (x & (-x));\n  }\n}\nvoid Process() {\n  for (int i = 1; i <= maxx; i++) {\n    int f = Get(c[i] - 1) + 1;\n    Update(c[i], f);\n  }\n  for (int i = 1; i <= maxx; i++) ans = max(table[i], ans);\n  printf(\"%d\", ans);\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    int k;\n    scanf(\"%d\", &k);\n    a.push_back(make_pair(k, i));\n  }\n  Array_Compression();\n  Process();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:200000000\")\nusing namespace std;\ntemplate <typename T>\ninline T Abs(T x) {\n  return (x >= 0) ? x : -x;\n}\ntemplate <typename T>\ninline T sqr(T x) {\n  return x * x;\n}\ntemplate <typename T>\ninline string toStr(T x) {\n  stringstream st;\n  st << x;\n  string s;\n  st >> s;\n  return s;\n}\ntemplate <typename T>\ninline int bit(T mask, int b) {\n  return (b >= 0 && (mask & (T(1) << b)) != 0) ? 1 : 0;\n}\ninline int nextInt() {\n  int x;\n  if (scanf(\"%d\", &x) != 1) throw;\n  return x;\n}\ninline long long nextInt64() {\n  long long x;\n  if (scanf(\"%lld\", &x) != 1) throw;\n  return x;\n}\ninline double nextDouble() {\n  double x;\n  if (scanf(\"%lf\", &x) != 1) throw;\n  return x;\n}\nconst int INF = (int)1E9;\nconst long long INF64 = (long long)1E18;\nconst long double EPS = 1E-9;\nconst long double PI = 3.1415926535897932384626433832795;\nconst int MAXN = 100100;\nint tree[MAXN], n;\nint getMax(int x) {\n  int ans = 0;\n  for (; x >= 0; x = (x & (x + 1)) - 1) ans = max(ans, tree[x]);\n  return ans;\n}\nvoid update(int x, int value) {\n  for (; x < n; x = (x | (x + 1))) tree[x] = max(value, tree[x]);\n}\nint main() {\n  n = nextInt();\n  int ans = 0;\n  for (int i = 0; i < (int)(n); i++) {\n    int x = nextInt();\n    int value = getMax(x - 1) + 1;\n    ans = max(ans, value);\n    update(x, value);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inv = 1000000000;\nconst int minv = -1000000000;\n;\nconst int max_n = 100010;\nint n;\nint a[max_n + 1];\nint M[max_n + 1];\nint lis;\nint binsrc(int l, int r, int ref) {\n  if (l + 1 == r)\n    return r;\n  else {\n    int mid = (l + r) / 2;\n    if (M[mid] >= ref)\n      return binsrc(l, mid, ref);\n    else\n      return binsrc(mid, r, ref);\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) scanf(\"%d\", &a[i]);\n  fill(M, M + n + 1, inv);\n  M[0] = minv;\n  lis = 0;\n  for (int i = 0; i < n; ++i) {\n    int x = binsrc(0, n, a[i]);\n    M[x] = a[i];\n    lis = max(lis, x);\n  }\n  printf(\"%d\\n\", lis);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1) {\n  cerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args) {\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \" : \" << arg1 << \" | \";\n  __f(comma + 1, args...);\n}\nconst long long c = 2e5 + 5;\nlong long arr[c], tail[c], n;\nlong long bs(long long l, long long r, long long key) {\n  long long mid;\n  while (r - l > 1) {\n    mid = l + (r - l) / 2;\n    if (tail[mid] >= key)\n      r = mid;\n    else\n      l = mid;\n  }\n  return r;\n}\nlong long lis() {\n  long long length = 1;\n  tail[0] = arr[0];\n  for (int i = 1; i < n; i++) {\n    if (arr[i] < tail[0])\n      tail[0] = arr[i];\n    else if (arr[i] > tail[length - 1]) {\n      tail[length] = arr[i];\n      length++;\n    } else\n      tail[bs(0, length - 1, arr[i])] = arr[i];\n  }\n  return length;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL), cout.tie(NULL);\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> arr[i];\n  cout << lis() << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, tot = 0, a[100005], d[100005];\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  for (int i = 0; i < n; i++) {\n    if (a[i] > d[tot]) {\n      d[++tot] = a[i];\n      continue;\n    }\n    int l = 0;\n    int r = tot;\n    while (l <= r) {\n      int mid = (l + r) / 2;\n      if (d[mid] > a[i]) {\n        r = mid - 1;\n      } else {\n        l = mid + 1;\n      }\n    }\n    d[l] = a[i];\n  }\n  printf(\"%d\\n\", tot);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint tree[10000100];\nint arr[10100];\nint query(int i) {\n  int res = 0;\n  while (i > 0) {\n    res = max(tree[i], res);\n    i -= i & (-i);\n  }\n  return res;\n}\nvoid update(int i, int n, int val) {\n  while (i <= n) {\n    tree[i] = max(tree[i], val);\n    i += i & (-i);\n  }\n}\nvoid init(int n) {\n  for (int i = 1; i <= n; i++) {\n    tree[i] = 0;\n  }\n  for (int i = 0; i < n; i++) {\n    update(i, n, arr[i]);\n  }\n}\nint main() {\n  int n;\n  int u, v, w, x;\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    cin >> u;\n    update(u, n, query(u) + 1);\n  }\n  cout << query(n);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.lang.*;\n\npublic class D1 {\n\tpublic static void main(String[] args) {\n\t\tFastReader in = new FastReader();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n = in.nextInt();\n\t\tint a[] = new int[n + 1];\n\t\tint d[] = new int[n + 1];\n\t\tint inf = Integer.MAX_VALUE;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\ta[i] = in.nextInt();\n\t\t}\n\t\tArrays.fill(d, inf);\n\t\td[0] = -inf;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint j = Arrays.binarySearch(d, 1, n + 1, a[i]);\n//\t\t\tout.println(Arrays.toString(a));\n//\t\t\tout.println(Arrays.toString(d));\n//\t\t\tout.println(j);\n\t\t\tj = Math.abs(j) - 1;\n\t\t\tif (a[i] < d[j] && a[i] > d[j - 1])\n\t\t\t\td[j] = a[i];\n\t\t}\n\t\tfor (int i = n; i >= 1; i--) {\n\t\t\tif (d[i] != inf) {\n\t\t\t\tout.print(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tout.close();\n\t}\n\n\tstatic final Random random=new Random();\n\t//\tstatic void ruffleSort(Pair[] a) {\n\t//\t\tint n=a.length;//shuffle, then sort \n\t//\t\tfor (int i=0; i<n; i++) {\n\t//\t\t\tint oi=random.nextInt(n);\n\t//\t\t\tPair temp=a[oi];\n\t//\t\t\ta[oi]=a[i]; a[i]=temp;\n\t//\t\t}\n\t//\t\tArrays.sort(a);\n\t//\t}\n\tstatic void ruffleSort(int[] a) {\n\t\tint n=a.length;//shuffle, then sort \n\t\tfor (int i=0; i<n; i++) {\n\t\t\tint oi=random.nextInt(n), temp=a[oi];\n\t\t\ta[oi]=a[i]; a[i]=temp;\n\t\t}\n\t\tArrays.sort(a);\n\t}\n\tstatic void ruffleSort(char[] a) {\n\t\tint n=a.length;//shuffle, then sort \n\t\tfor (int i=0; i<n; i++) {\n\t\t\tint oi=random.nextInt(n);\n\t\t\tchar temp=a[oi];\n\t\t\ta[oi]=a[i]; a[i]=temp;\n\t\t}\n\t\tArrays.sort(a);\n\t}\n\tstatic class FastReader \n\t{ \n\t\tBufferedReader br; \n\t\tStringTokenizer st; \n\n\t\tpublic FastReader() \n\t\t{ \n\t\t\tbr = new BufferedReader(new\n\t\t\t\t\tInputStreamReader(System.in)); \n\t\t} \n\n\t\tString next() \n\t\t{ \n\t\t\twhile (st == null || !st.hasMoreElements()) \n\t\t\t{ \n\t\t\t\ttry\n\t\t\t\t{ \n\t\t\t\t\tst = new StringTokenizer(br.readLine()); \n\t\t\t\t} \n\t\t\t\tcatch (IOException  e) \n\t\t\t\t{ \n\t\t\t\t\te.printStackTrace(); \n\t\t\t\t} \n\t\t\t} \n\t\t\treturn st.nextToken(); \n\t\t} \n\n\t\tint nextInt() \n\t\t{ \n\t\t\treturn Integer.parseInt(next()); \n\t\t} \n\n\t\tlong nextLong() \n\t\t{ \n\t\t\treturn Long.parseLong(next()); \n\t\t} \n\n\t\tdouble nextDouble() \n\t\t{ \n\t\t\treturn Double.parseDouble(next()); \n\t\t} \n\n\t\tString nextLine() \n\t\t{ \n\t\t\tString str = \"\"; \n\t\t\ttry\n\t\t\t{ \n\t\t\t\tstr = br.readLine(); \n\t\t\t} \n\t\t\tcatch (IOException e) \n\t\t\t{ \n\t\t\t\te.printStackTrace(); \n\t\t\t} \n\t\t\treturn str; \n\t\t} \n\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n}\n\n//class Pair implements Comparable<Pair>{\n//    int a;\n//    int b;\n//    public Pair(int a, int b) {\n//        this.a = a;\n//        this.b = b;\n//    }\n//    public int compareTo(Pair o) {\n//        if(this.a==o.a)\n//            return this.b - o.b;\n//        return this.a - o.a;\n//    }   \n//}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint lis_nlogn(vector<int>& v) {\n  vector<int> len(v.size() + 1, 1e9);\n  len[0] = -1e9;\n  int mx = 0;\n  for (int i = 0; i < (int)v.size(); i++) {\n    int l = lower_bound(len.begin(), len.end(), v[i]) - len.begin();\n    mx = max(mx, l);\n    len[l] = v[i];\n  }\n  return mx;\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vector<int> v(n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &v[i]);\n  }\n  printf(\"%d\", lis_nlogn(v));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 2e5 + 3;\nusing namespace std;\nint CeilIndex(std::vector<int>& v, int l, int r, int key) {\n  while (r - l > 1) {\n    int m = l + (r - l) / 2;\n    if (v[m] >= key)\n      r = m;\n    else\n      l = m;\n  }\n  return r;\n}\nint LongestIncreasingSubsequenceLength(std::vector<int>& v) {\n  if (v.size() == 0) return 0;\n  std::vector<int> tail(v.size(), 0);\n  int length = 1;\n  tail[0] = v[0];\n  for (size_t i = 1; i < v.size(); i++) {\n    if (v[i] < tail[0])\n      tail[0] = v[i];\n    else if (v[i] > tail[length - 1])\n      tail[length++] = v[i];\n    else\n      tail[CeilIndex(tail, -1, length - 1, v[i])] = v[i];\n  }\n  return length;\n}\nvector<int> v;\nint main() {\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i <= n - 1; i++) cin >> a[i];\n  int ans = LongestIncreasingSubsequenceLength(a);\n  cout << ans;\n}\n"
        },
        {
            "language": 3,
            "solution": "from bisect import *\ns, n = [0], input()\nfor i in map(int, input().split()):\n    if i > s[-1]: s.append(i)\n    else: s[bisect_right(s, i)] = i\n    \nprint(len(s) - 1)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100005;\nint lft[3 * maxn], rht[3 * maxn], M[3 * maxn];\nvoid build(int n, int l, int r) {\n  lft[n] = l, rht[n] = r;\n  if (l == r) return;\n  int mid = (l + r) >> 1;\n  build(n << 1, l, mid);\n  build(n << 1 | 1, mid + 1, r);\n}\nvoid upd(int n, int k, int x) {\n  int mid = (lft[n] + rht[n]) >> 1;\n  if (lft[n] == rht[n]) {\n    M[n] = max(M[n], x);\n    return;\n  }\n  if (k <= mid)\n    upd(n << 1, k, x);\n  else\n    upd(n << 1 | 1, k, x);\n  M[n] = max(M[n << 1], M[n << 1 | 1]);\n}\nint get(int n, int l, int r) {\n  int mid = (lft[n] + rht[n]) >> 1;\n  if (lft[n] == l && rht[n] == r) {\n    return M[n];\n  }\n  if (r <= mid)\n    return get(n << 1, l, r);\n  else if (l > mid)\n    return get(n << 1 | 1, l, r);\n  else\n    return max(get(n << 1, l, mid), get(n << 1 | 1, mid + 1, r));\n}\nint main() {\n  int n, i, ans = 0;\n  scanf(\"%d\", &n);\n  build(1, 1, n);\n  while (n--) {\n    int x, t = 1;\n    scanf(\"%d\", &x);\n    if (x > 1) t = max(t, get(1, 1, x - 1) + 1);\n    ans = max(ans, t);\n    upd(1, x, t);\n  }\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  vector<int> v;\n  v.reserve(n);\n  for (int i = 0; i < n; ++i) {\n    int x;\n    cin >> x;\n    auto it = lower_bound(v.begin(), v.end(), x);\n    if (it == v.end())\n      v.push_back(x);\n    else\n      *it = x;\n  }\n  cout << v.size() << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\nimport java.io.*;\nimport java.math.*;\nimport java.awt.geom.*;\n\nimport static java.lang.Math.*;\n\npublic class Solution implements Runnable {\n\n\tlong mod1 = (long) 1e9 + 7;\n\tint mod2 = 998244353;\n\n\tpublic void solve() throws Exception {\n\t\tint n=sc.nextInt();\n\t\tint arr[]=sc.readArray(n);\n\t\tout.println(LongestIncreasingSubsequenceLength(arr, n));\n\n\t}\n\t\n\tstatic int CeilIndex(int A[], int l, int r, int key) \n    { \n        while (r - l > 1) { \n            int m = l + (r - l) / 2; \n            if (A[m] >= key) \n                r = m; \n            else\n                l = m; \n        } \n  \n        return r; \n    } \n  \n    static int LongestIncreasingSubsequenceLength(int A[], int size) \n    { \n        // Add boundary case, when array size is one \n  \n        int[] tailTable = new int[size]; \n        int len; // always points empty slot \n  \n        tailTable[0] = A[0]; \n        len = 1; \n        for (int i = 1; i < size; i++) { \n            if (A[i] < tailTable[0]) \n                // new smallest value \n                tailTable[0] = A[i]; \n  \n            else if (A[i] > tailTable[len - 1]) \n                // A[i] wants to extend largest subsequence \n                tailTable[len++] = A[i]; \n  \n            else\n                // A[i] wants to be current end candidate of an existing \n                // subsequence. It will replace ceil value in tailTable \n                tailTable[CeilIndex(tailTable, -1, len - 1, A[i])] = A[i]; \n        } \n  \n        return len; \n    } \n\n\tstatic void sort(int[] a) {\n\t\tArrayList<Integer> l = new ArrayList<>();\n\t\tfor (int i : a)\n\t\t\tl.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < a.length; i++)\n\t\t\ta[i] = l.get(i);\n\t}\n\n\tstatic long gcd(long a, long b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\t\treturn gcd(b % a, a);\n\t}\n\n\tstatic long ncr(int n, int r, long p) {\n\t\tif (r > n)\n\t\t\treturn 0l;\n\t\tif (r > n - r)\n\t\t\tr = n - r;\n\n\t\tlong C[] = new long[r + 1];\n\n\t\tC[0] = 1;\n\n\t\tfor (int i = 1; i <= n; i++) {\n\n\t\t\tfor (int j = Math.min(i, r); j > 0; j--)\n\t\t\t\tC[j] = (C[j] + C[j - 1]) % p;\n\t\t}\n\t\treturn C[r] % p;\n\t}\n\n\tpublic long power(long x, long y, long p) {\n\t\tlong res = 1;\n\t\t// out.println(x+\" \"+y);\n\t\tx = x % p;\n\t\tif (x == 0)\n\t\t\treturn 0;\n\n\t\twhile (y > 0) {\n\t\t\tif ((y & 1) == 1)\n\t\t\t\tres = (res * x) % p;\n\t\t\ty = y >> 1;\n\t\t\tx = (x * x) % p;\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic Throwable uncaught;\n\n\tBufferedReader in;\n\tFastScanner sc;\n\tPrintWriter out;\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsc = new FastScanner(in);\n\t\t\tsolve();\n\t\t} catch (Throwable uncaught) {\n\t\t\tSolution.uncaught = uncaught;\n\t\t} finally {\n\t\t\tout.close();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Throwable {\n\t\tThread thread = new Thread(null, new Solution(), \"\", (1 << 26));\n\t\tthread.start();\n\t\tthread.join();\n\t\tif (Solution.uncaught != null) {\n\t\t\tthrow Solution.uncaught;\n\t\t}\n\t}\n\n}\n\nclass FastScanner {\n\n\tBufferedReader in;\n\tStringTokenizer st;\n\n\tpublic FastScanner(BufferedReader in) {\n\t\tthis.in = in;\n\t}\n\n\tpublic String nextToken() throws Exception {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic int nextInt() throws Exception {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tpublic int[] readArray(int n) throws Exception {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic long nextLong() throws Exception {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tpublic double nextDouble() throws Exception {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n  int a[n];\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  set<int> s;\n  for (int i = 0; i < n; i++) {\n    if (s.lower_bound(a[i]) != s.end()) {\n      s.erase(s.lower_bound(a[i]));\n    }\n    s.insert(a[i]);\n  }\n  cout << s.size();\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\nimport java.io.OutputStreamWriter;\nimport java.math.BigInteger;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.io.IOException;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Nguyen Trung Hieu - vuondenthanhcong11@gmail.com\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskLIS solver = new TaskLIS();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass TaskLIS {\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n        int count = in.readInt();\n        BinaryIndexTree tree = new BinaryIndexTree(100001) {\n            protected long joinValue(long was, long delta) {\n                return Math.max(was, delta);\n            }\n        };\n        long answer = 0;\n        for (int i = 1; i <= count; i++) {\n            int val = in.readInt();\n            long p = tree.get(val) + 1;\n            tree.update(val, (int)p);\n            answer = Math.max(answer, p);\n        }\n\n        out.printLine(answer);\n    }\n}\n\nclass InputReader {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private SpaceCharFilter filter;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public int read() {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int readInt() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public boolean isSpaceChar(int c) {\n        if (filter != null)\n            return filter.isSpaceChar(c);\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public interface SpaceCharFilter {\n        public boolean isSpaceChar(int ch);\n    }\n\n}\n\nclass OutputWriter {\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public void print(Object...objects) {\n        for (int i = 0; i < objects.length; i++) {\n            if (i != 0)\n                writer.print(' ');\n            writer.print(objects[i]);\n        }\n    }\n\n    public void printLine(Object...objects) {\n        print(objects);\n        writer.println();\n    }\n\n    public void close() {\n        writer.close();\n    }\n\n}\n\nabstract class BinaryIndexTree {\n    protected int size;\n    protected long[] bit;\n\n    public BinaryIndexTree(int size) {\n        this.size = size;\n        this.bit = new long[this.size];\n    }\n\n    public long get(int x) {\n        long res = 0;\n        for (; x > 0; x -= x & -x)\n            res = joinValue(res, bit[x]);\n        return res;\n    }\n\n    public void update(int x, int v) {\n        for (; x < bit.length; x += x & -x)\n            bit[x] = joinValue(bit[x], v);\n    }\n\n    protected abstract long joinValue(long was, long delta);\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\n/**\n *\n * @author Trung Pham\n */\npublic class D {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner();\n        PrintWriter out = new PrintWriter(System.out);\n        int n = in.nextInt();\n        int[] data = new int[n];\n        for (int i = 0; i < n; i++) {\n            data[i] = in.nextInt();\n        }\n        int[] dp = new int[n];\n        dp[0] = data[0];\n\n        int j = 0;\n        for (int i = 1; i < n; i++) {\n            if (data[i] > dp[j]) {\n                j++;\n                dp[j] = data[i];\n            } else  {\n                int hi = j;\n                int low = 0;\n                while (hi > low + 1) {\n                    int mid = (hi + low) / 2;\n                    if (dp[mid] > data[i]) {\n                        hi = mid;\n                    }else{\n                        low = mid;\n                    }\n                }\n                if(dp[low] < data[i]){\n                    low++;\n                }\n                dp[low] = Math.min(dp[low], data[i]);\n            }\n        }\n//        for(int i : dp){\n//            System.out.println(i);\n//        }\n        out.print(j + 1);\n        out.close();\n\n\n    }\n\n    static class Scanner {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public Scanner() {\n            //System.setOut(new PrintStream(new BufferedOutputStream(System.out), true));\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public String next() {\n\n\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (Exception e) {\n                    throw new RuntimeException();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            st = null;\n            try {\n                return br.readLine();\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n\n        public boolean endLine() {\n            try {\n                String next = br.readLine();\n                while (next != null && next.trim().isEmpty()) {\n                    next = br.readLine();\n                }\n                if (next == null) {\n                    return true;\n                }\n                st = new StringTokenizer(next);\n                return st.hasMoreTokens();\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint a[131072];\nint s[131072];\nint ts = 0;\nint binsearch(int k) {\n  int l = 0, r = ts, mid, ans = 0;\n  while (l <= r) {\n    mid = (l + r) / 2;\n    if (s[mid] < k) {\n      ans = mid;\n      l = mid + 1;\n    } else\n      r = mid - 1;\n  }\n  return ans;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", a + i);\n  for (int i = 1; i <= n; i++) {\n    int t = binsearch(a[i]);\n    s[t + 1] = a[i];\n    if (t == ts) ts++;\n  }\n  printf(\"%d\\n\", ts);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint r[110000];\nint main() {\n  int n, len = 0;\n  scanf(\"%d\", &n);\n  for (int i = 0, j; i < n; ++i) {\n    scanf(\"%d\", &j);\n    int pos = lower_bound(r, r + len, j) - r;\n    r[pos] = j;\n    if (len == pos) len++;\n  }\n  cout << len << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\n\npublic class B {\n\tpublic static void main(String[] args) throws Exception {\n\t\tInputReader in = new InputReader(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint n = in.nextInt();\n\t\tint[] arr = new int[n];\n\t\tfor(int i = 0 ;i < n; i++){\n\t\t\tarr[i] = in.nextInt();\n\t\t}\n\t\t\n\t\tout.println(getLongestIncreasingSubsequence(arr));\n\t\tout.close();\n\t}\n\t\n\tstatic int getLongestIncreasingSubsequence(int[] arr){\n\t\tif(arr.length <= 1) return arr.length;\n\t\t\n\t\tint[] dp = new int[arr.length];\n\t\tint mSize = 2;\n\t\tint[] m = new int[arr.length+1];\n\t\t\n\t\tdp[0] = 1;\n\t\tm[1] = 0;\n\t\tint maxLength = -1;\n\t\tfor(int i = 1; i < dp.length; i++){\n\t\t\tint j = binSearch(arr, arr[i], mSize-1, m);\n\t\t\tdp[i] = 1 + j;\n\t\t\t\n\t\t\tif(dp[i] >= mSize){\n\t\t\t\tm[dp[i]] = i;\n\t\t\t\tmSize++;\n\t\t\t}else{\n\t\t\t\tif(arr[m[dp[i]]] > arr[i]){\n\t\t\t\t\tm[dp[i]] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaxLength = Math.max(dp[i], maxLength);\n\t\t}\n\t\t\n\t\treturn maxLength;\n\t}\n\t\n\t//get largest index in arr > s, given arr is descending\n\tpublic static int binSearch(int[] arr, int s, int hi, int[] m){\n\t\tint lo=1;\n\t\t\n\t\tif(arr[m[1]] > s){\n\t\t\treturn 0;\n\t\t}else{\n\t\t\twhile(lo < hi){\n\t\t\t\tint mid = lo + (hi-lo+1)/2;\n\t\t\t\tif(arr[m[mid]] > s){\n\t\t\t\t\thi = mid-1;\n\t\t\t\t}else{\n\t\t\t\t\tlo = mid;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn lo;\n\t}\n\t\n\t\n\tstatic class InputReader {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\t\tprivate SpaceCharFilter filter;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\t\t\n\t\t\n\t\tpublic int read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\n\t\tpublic String nextToken() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn isWhitespace(c);\n\t\t}\n\n\t\tpublic static boolean isWhitespace(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tpublic interface SpaceCharFilter {\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:100000000\")\nusing namespace std;\nconst double pi = acos(-1.0);\nconst int rms = (1 << 18) - 1;\nconst int hrms = rms / 2;\nconst int size = 200 * 1000;\nint rmq[rms + 1];\nint n;\nint a[size];\nint ans[size];\nvoid change(int ps, int val) {\n  ps += hrms;\n  rmq[ps] = val;\n  while (ps > 1) {\n    ps /= 2;\n    rmq[ps] = max(rmq[ps * 2], rmq[ps * 2 + 1]);\n  }\n}\nint rss(int v, int i, int j, int lb, int rb) {\n  if (rb < i || lb > j) return 0;\n  if (lb >= i && rb <= j) return rmq[v];\n  return max(rss(v * 2, i, j, lb, (lb + rb) / 2),\n             rss(v * 2 + 1, i, j, (lb + rb) / 2 + 1, rb));\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n    ans[i] = rss(1, 1, a[i], 1, hrms + 1) + 1;\n    change(a[i], ans[i]);\n  }\n  cout << rss(1, 1, n, 1, hrms + 1) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing pill = pair<int, ll>;\nusing vvi = vector<vi>;\nll gcd(ll a, ll b) {\n  ll t;\n  while ((t = a % b) != 0) {\n    a = b;\n    b = t;\n  }\n  return b;\n}\nll fast_exp(ll base, ll n, ll m) {\n  if (n == 0) return 1;\n  ll t = fast_exp(base, n / 2, m);\n  if (n % 2 == 0)\n    return (t * t) % m;\n  else\n    return (((t * t) % m) * base) % m;\n}\nbool is_set(int i, ll mask) { return (mask >> i) & 1; }\nint count_bits(ll mask) {\n  int ans = 0;\n  for (int i = 0; i < 64; ++i)\n    if (is_set(i, mask)) ++ans;\n  return ans;\n}\nint first_bit(ll mask) {\n  int i = 0;\n  while (i < 64)\n    if (is_set(i++, mask)) return i - 1;\n  return -1;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  int a[n];\n  for (int i = 0; i < n; ++i) cin >> a[i];\n  vi v;\n  v.push_back(a[0]);\n  for (int i = 1; i < n; ++i) {\n    if (a[i] < v[0])\n      v[0] = a[i];\n    else if (a[i] > v.back())\n      v.push_back(a[i]);\n    else\n      *upper_bound(v.begin(), v.end(), a[i]) = a[i];\n  }\n  cout << v.size() << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int oo = 1e6 + 5;\nint n, bit[oo], res;\nvoid maxi(int &x, int y) {\n  if (x < y) x = y;\n}\nvoid adj(int x, int val) {\n  for (; x < oo; x += x & -x) maxi(bit[x], val);\n}\nint get(int x) {\n  int ans = 0;\n  for (; x > 0; x -= x & -x) maxi(ans, bit[x]);\n  return ans;\n}\nint main() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    int x;\n    cin >> x;\n    adj(x, get(x - 1) + 1);\n  }\n  cout << get(n);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100005;\nint a[maxn];\nint g[maxn];\nint d[maxn];\nint n;\nstruct SegTree {\n  int maxv[maxn * 3];\n  int ql, qr;\n  int query(int o, int L, int R) {\n    if (ql > qr) return 0;\n    int M = L + (R - L) / 2, ans = 0;\n    if (ql <= L && R <= qr) return maxv[o];\n    if (ql <= M) ans = max(ans, query(o * 2, L, M));\n    if (M < qr) ans = max(ans, query(o * 2 + 1, M + 1, R));\n    return ans;\n  }\n  int p, v;\n  void update(int o, int L, int R) {\n    int M = L + (R - L) / 2;\n    if (L == R)\n      maxv[o] = v;\n    else {\n      if (p <= M)\n        update(o * 2, L, M);\n      else\n        update(o * 2 + 1, M + 1, R);\n      maxv[o] = max(maxv[o * 2], maxv[o * 2 + 1]);\n    }\n  }\n} tree;\nstruct FT {\n  int C[maxn];\n  inline int lowbit(int x) { return x & -x; }\n  int mmax(int x) {\n    int ret = 0;\n    while (x > 0) {\n      ret = max(ret, C[x]);\n      x -= lowbit(x);\n    }\n    return ret;\n  }\n  void add(int x, int d) {\n    while (x <= n) {\n      C[x] = max(C[x], d);\n      x += lowbit(x);\n    }\n  }\n  void init() { memset(C, 0, sizeof(C)); }\n} ft;\nint main(int argc, char *argv[]) {\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  ft.init();\n  for (int i = 1; i <= n; i++) {\n    d[i] = ft.mmax(a[i] - 1) + 1;\n    ft.add(a[i], d[i]);\n  }\n  int ans = 1;\n  for (int i = 1; i <= n; i++) ans = max(ans, d[i]);\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100100];\nint d[100100];\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  for (int i = 0; i <= n; i++) {\n    d[i] = 100100;\n  }\n  d[0] = 0;\n  for (int i = 0; i < n; i++) {\n    int l = 0;\n    int r = n - 1;\n    while (l < r) {\n      int m = (l + r + 1) / 2;\n      if (d[m] > a[i]) {\n        r = m - 1;\n      } else {\n        l = m;\n      }\n    }\n    d[r + 1] = a[i];\n  }\n  int ans = 0;\n  for (int i = 0; i <= n; i++) {\n    if (d[i] < 100100) {\n      ans = i;\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint A[100001];\nvector<int> L;\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) scanf(\"%d\", &A[i]);\n  L.push_back(A[0]);\n  vector<int>::iterator pos;\n  for (int i = 1; i < n; i++) {\n    pos = upper_bound(L.begin(), L.end(), A[i]);\n    if (pos == L.end()) {\n      L.push_back(A[i]);\n    } else {\n      int idx = pos - L.begin();\n      L[idx] = A[i];\n    }\n  }\n  printf(\"%d\", L.size());\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nT sqr(T x) {\n  return x * x;\n}\ntemplate <typename T>\nT abs(T x) {\n  return x < 0 ? -x : x;\n}\ntemplate <typename T>\nT gcd(T a, T b) {\n  return b ? gcd(b, a % b) : a;\n}\nint find(int x, int *a, int n) {\n  int res = 0;\n  for (int i = x; 0 < i; i -= i & -i) res = max(res, a[i]);\n  return res;\n}\nvoid modify(int x, int v, int *a, int n) {\n  for (int i = x; i <= n; i += i & -i) a[i] = max(a[i], v);\n}\nint main(int argc, char **argv) {\n  ios_base::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  int a[n + 1];\n  memset(a, 0, sizeof(a));\n  for (int i = 1; i <= n; i++) {\n    int x;\n    cin >> x;\n    modify(x, find(x - 1, a, n) + 1, a, n);\n  }\n  cout << find(n, a, n) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100009;\nint maxup[MAXN];\nint main() {\n  int n, tmp, maxl = 0;\n  int *ptr;\n  cin >> n;\n  for (int i = 0; i < n; ++i) {\n    cin >> tmp;\n    ptr = upper_bound(maxup, maxup + maxl, tmp);\n    *ptr = tmp;\n    if (ptr == maxup + maxl) maxl++;\n  }\n  cout << maxl << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, A[222222], tree[222222], f[222222];\nvoid ins(int x, int val) {\n  for (int z = x; z <= 200000; z += z & -z) tree[z] = max(tree[z], val);\n}\nint ask(int r) {\n  int res = 0;\n  for (int z = r; z; z -= z & -z) res = max(res, tree[z]);\n  return res;\n}\nint main() {\n  cin >> n;\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", &A[i]);\n  int ans = 0;\n  for (int i = 1; i <= n; ++i) {\n    f[i] = ask(A[i] - 1) + 1;\n    ins(A[i], f[i]);\n    ans = max(ans, f[i]);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\nI = lambda : list(map(int,input().split()))\n\ndef CeilIndex(A, l, r, key): \n    while (r - l > 1): \n      \n        m = l + (r - l)//2\n        if (A[m] >= key): \n            r = m \n        else: \n            l = m \n    return r \n   \ndef lis(A, size): \n    tailTable = [0 for i in range(size + 1)] \n    len = 0 \n    tailTable[0] = A[0] \n    len = 1\n    for i in range(1, size): \n      \n        if (A[i] < tailTable[0]): \n            tailTable[0] = A[i] \n   \n        elif (A[i] > tailTable[len-1]): \n            tailTable[len] = A[i] \n            len+= 1\n   \n        else: \n            tailTable[CeilIndex(tailTable, -1, len-1, A[i])] = A[i] \n    return len\nn,=I()\np=I()\nan=1\nprint(lis(p,n))\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author kanak893\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader fi, PrintWriter out) {\n            int i, j, k, n;\n            n = fi.nextInt();\n            int a[] = new int[n];\n            for (i = 0; i < n; i++) {\n                a[i] = fi.nextInt();\n            }\n            int dp[] = new int[n];\n            int len = 0;\n            for (i = 0; i < n; i++) {\n                int next = a[i];\n                int index = bs(dp, 0, len - 1, next);\n                dp[index] = next;\n                if (index == len) len++;\n\n            }\n            out.println(len);\n        }\n\n        static int bs(int a[], int start, int end, int key) {\n            int ans = start;\n            int mid = 0;\n            while (start <= end) {\n                mid = (start + end) / 2;\n                if (a[mid] == key) {\n                    ans = mid;\n                } else if (a[mid] < key) {\n                    start = mid + 1;\n                    ans = start;\n                } else {\n                    end = mid - 1;\n                }\n            }\n            ans = Math.max(ans, 0);\n            return ans;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int snumChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int snext() {\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) {\n                curChar = 0;\n                try {\n                    snumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = snext();\n            while (isSpaceChar(c))\n                c = snext();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = snext();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:66777216\")\nusing namespace std;\nint a, b, c, d, n, m, k;\nint mas[100003];\nint fen[100003];\ninline void upd(int first, int val) {\n  for (; first <= n; first |= first + 1) fen[first] = max(fen[first], val);\n}\ninline int fnd(int first) {\n  int ans = 0;\n  for (; first >= 0; first = (first & (first + 1)) - 1)\n    ans = max(ans, fen[first]);\n  return ans;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int _n((n)-1), i(0); i <= _n; i++) {\n    scanf(\"%d\", &mas[i]);\n    --mas[i];\n  }\n  int ans = 0;\n  for (int _n((n)-1), i(0); i <= _n; i++) {\n    int cur = fnd(mas[i]) + 1;\n    ans = max(ans, cur);\n    upd(mas[i], cur);\n  }\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100000;\nint cnt[MAXN + 10], MX;\nvoid add(int a, int v) {\n  while (a <= MX) {\n    cnt[a] = max(cnt[a], v);\n    a += (a & (-a));\n  }\n}\nint get(int a) {\n  int res = 0;\n  while (a > 0) {\n    res = max(res, cnt[a]);\n    a -= (a & (-a));\n  }\n  return res;\n}\nint main(void) {\n  int n;\n  scanf(\"%d\", &n);\n  vector<int> p(n);\n  for (int i = 0; i < (n); ++i) {\n    scanf(\"%d\", &p[i]);\n  }\n  MX = n + 1;\n  int res = 0;\n  for (int i = 0; i < (n); ++i) {\n    int b = get(p[i] - 1);\n    res = max(res, b + 1);\n    add(p[i], b + 1);\n  }\n  printf(\"%d\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint it[200041], n, io;\nint down(int x) {\n  int s = 0, rs = x;\n  while (x <= n * 2) {\n    s = max(it[x], s);\n    x += x & (-x);\n  }\n  return s;\n}\nvoid up(int x, int u) {\n  while (x > 0) {\n    it[x] = max(it[x], u);\n    x -= x & (-x);\n  }\n}\nint main() {\n  int i, a[100005], o = 0, co;\n  cin >> n;\n  for (i = 0; i < n; i++) cin >> a[i];\n  for (i = n - 1; i >= 0; i--) {\n    co = down(a[i]);\n    up(a[i], co + 1);\n    o = max(co + 1, o);\n  }\n  cout << o << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Ada {\n    static int inf = Integer.MAX_VALUE;\n\n    public static void main(String[] args) {\n        FastReader sc = new FastReader();\n        int n = sc.nextInt();\n        int arr[] = new int[n];\n        for (int i = 0; i < n; i++) arr[i] = sc.nextInt();\n        int dp[] = new int[n + 1];\n        Arrays.fill(dp, inf);\n        dp[0] = -inf;\n        for (int i = 0; i < n; i++) {\n            int j = pos(dp, arr[i]);\n            dp[j] = arr[i];\n            \n        }\n        int i = n;\n        while (dp[i] == inf) {\n            i--;\n        }\n        System.out.println(i);\n    }\n\n    static int pos(int arr[], int ele) {\n        int l = 0, r = arr.length - 1;\n        while (l <= r) {\n            int mid = l + (r - l) / 2;\n            if (arr[mid] <= ele) {\n                l = mid + 1;\n            } else r = mid - 1;\n        }\n        return l;\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\n/**\n *\n * @author Saurabh <saurabh.mtcs15@iitp.ac.in>\n */\npublic class BubbleSortGraph\n{\n    public static void main(String[] args)throws Exception\n    {\n        Reader sc=new Reader();\n        int n=sc.nextInt();\n        int i=1,max=0;\n        FenwickTree ft=new FenwickTree(n);\n        while(i++<=n)\n        {\n            int x=sc.nextInt();\n            int seq=ft.get(x-1);\n            ft.update(x, seq+1);\n            max=Integer.max(max,seq+1);\n        }\n        System.out.println(max);\n    }\n    static class Reader\n    {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n        public Reader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n        public int nextInt() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do\n            {\n                ret = ret * 10 + c - '0';\n            }  while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n}\nclass FenwickTree\n{\n    int size=100005,tree[],n;\n   public FenwickTree(int n)\n   {\n       this.n=n;\n       tree=new int[size];\n   }\n   public void update(int index,int val)\n   {\n       while(index<=n)\n       {\n           if(tree[index]<val)\n               tree[index]=val;\n           index+=(index&(~index + 1 ));\n       }\n   }\n   \n   public int get(int index)\n   {\n       int max=0;\n       while(index>0)\n       {\n           if(tree[index]>max)\n               max=tree[index];\n           index-=(index&(-index));\n       }\n       return max;\n   }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100005], d[100005];\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) scanf(\"%d\", &a[i]);\n  d[0] = -1000000000;\n  for (int i = 1; i <= n + 2; ++i) d[i] = 1000000000;\n  for (int i = 0; i < n; i++) {\n    int j = int(upper_bound(d, d + n + 1, a[i]) - d);\n    if (d[j - 1] < a[i] && a[i] < d[j]) d[j] = a[i];\n  }\n  for (int i = n; i >= 0; --i)\n    if (d[i] != 1000000000) {\n      printf(\"%d\\n\", i);\n      break;\n    }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\npublic class B {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tsc = new StringTokenizer(br.readLine());\n\t\tint[] a = nxtIntArr(nxtInt());\n\t\tArrayList<Integer> b = new ArrayList<Integer>();\n\t\tb.add(0);\n\t\tfor (int i = 1; i < a.length; i++) {\n\t\t\tif (a[b.get(b.size() - 1)] < a[i]) {\n\t\t\t\tb.add(i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint lo = 0;\n\t\t\tint hi = b.size() - 1;\n\t\t\twhile (lo < hi) {\n\t\t\t\tint mid = (lo + hi) / 2;\n\t\t\t\tif (a[b.get(mid)] < a[i])\n\t\t\t\t\tlo = mid + 1;\n\t\t\t\telse\n\t\t\t\t\thi = mid;\n\t\t\t}\n\t\t\tif (a[i] < a[b.get(lo)])\n\t\t\t\tb.set(lo, i);\n\t\t}\n\t\tout.println(b.size());\n\t\tbr.close();\n\t\tout.close();\n\t}\n\n\tstatic BufferedReader br;\n\tstatic StringTokenizer sc;\n\n\tstatic String nxtTok() throws IOException {\n\t\twhile (!sc.hasMoreTokens()) {\n\t\t\tString s = br.readLine();\n\t\t\tif (s == null)\n\t\t\t\treturn null;\n\t\t\tsc = new StringTokenizer(s.trim());\n\t\t}\n\t\treturn sc.nextToken();\n\t}\n\n\tstatic int nxtInt() throws IOException {\n\t\treturn Integer.parseInt(nxtTok());\n\t}\n\n\tstatic long nxtLng() throws IOException {\n\t\treturn Long.parseLong(nxtTok());\n\t}\n\n\tstatic double nxtDbl() throws IOException {\n\t\treturn Double.parseDouble(nxtTok());\n\t}\n\n\tstatic int[] nxtIntArr(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nxtInt();\n\t\treturn a;\n\t}\n\n\tstatic long[] nxtLngArr(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nxtLng();\n\t\treturn a;\n\t}\n\n\tstatic char[] nxtCharArr() throws IOException {\n\t\treturn nxtTok().toCharArray();\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.io.PrintWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Zyflair Griffane\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass TaskD {\n\n    public void solve(int testNumber, Scanner in, PrintWriter out) {\n        int n = Integer.parseInt(in.nextLine().trim());\n\n        String[] nums = in.nextLine().trim().split(\" \");\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = Integer.parseInt(nums[i]);\n        }\n\n        out.println(LIS.length(arr));\n    }\n\n}\n\nclass LIS {\n    public static int length(int[] arr) {\n        int n = arr.length, res = 0, currVal, currIdx = 0;\n        BIT b = new BIT(n);\n        Node nn[] = new Node[n];\n        for (int i = 0; i < n; i++)\n            nn[i] = new Node(i, arr[i]);\n        Arrays.sort(nn);\n        int idx[] = new int[n];\n        currVal = nn[0].val;\n        for (int i = 0; i < n; i++) {\n            if (nn[i].val != currVal) {\n                currIdx++;\n                currVal = nn[i].val;\n            }\n            idx[nn[i].id] = currIdx;\n        }\n        for (int i = 0; i < n; i++) {\n            int a = b.query(idx[i]) + 1;\n            res = Math.max(res,  a);\n            b.update(idx[i] + 1, a);\n        }\n        return res;\n    }\n    public static class Node implements Comparable<Node>{\n        int id, val;\n        public Node(int i, int v) {\n            id = i;\n            val = v;\n        }\n        public int compareTo(Node o) {\n            return val - o.val;\n        }\n    }\n    public static class BIT {\n        int n, tree[];\n        public BIT(int max) {\n            n = max;\n            tree = new int[n + 1];\n        }\n        void update(int idx, int val) {\n            while (idx <= n) {\n                tree[idx] = Math.max(tree[idx], val);\n                idx += (idx & -idx);\n            }\n        }\n        int query(int idx) {\n            int res = 0;\n            while (idx != 0) {\n                res = Math.max(res, tree[idx]);\n                idx -= (idx & -idx);\n            }\n            return res;\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100500];\nint v[100500];\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  v[0] = -1;\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    int l = 0, r = ans + 1;\n    while (r - l > 1) {\n      int j = (l + r) / 2;\n      if (v[j] < a[i])\n        l = j;\n      else\n        r = j;\n    }\n    v[l + 1] = a[i];\n    if (l + 1 > ans) ans = l + 1;\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "from sys import stdin\nfrom bisect import *\n\n\nclass segmenttree:\n    def __init__(self, arr, n):\n        self.tree, self.n = [0] * (2 * n), n\n        # build tree\n        if arr:\n            for i in range(2 * n - 1, 0, -1):\n                if i >= n:\n                    self.tree[i] = arr[i - n]\n                else:\n                    self.tree[i] = max(self.tree[i << 1], self.tree[(i << 1) + 1])\n\n    # get interval[l,r)\n    def query(self, l, r):\n        res = 0\n        l += self.n\n        r += self.n\n        while l < r:\n            if l & 1:\n                res = max(self.tree[l], res)\n                l += 1\n\n            if r & 1:\n                r -= 1\n                res = max(self.tree[r], res)\n\n            l >>= 1\n            r >>= 1\n\n        return res\n\n    def update(self, ix, val):\n        ix += self.n\n\n        # set new value\n        self.tree[ix] = val\n\n        # move up\n        while ix > 1:\n            self.tree[ix >> 1] = max(self.tree[ix], self.tree[ix ^ 1])\n            ix >>= 1\n\n\nrints = lambda: [int(x) for x in stdin.readline().split()]\nn, a, tree = int(input()), rints(), segmenttree([], 10 ** 5 + 1)\n\nfor i in range(n):\n    val = tree.query(0, a[i])\n    tree.update(a[i], val + 1)\n\nprint(tree.query(0, n + 1))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 110000;\nint n, h[MAXN], a[MAXN];\nint lowbit(int x) { return x & -x; }\nint ask(int pos) {\n  int res = 0;\n  for (int i = pos; i; i -= lowbit(i)) {\n    res = max(res, h[i]);\n  }\n  return res;\n}\nvoid ins(int pos, int val) {\n  for (int i = pos; i <= n; i += lowbit(i)) {\n    h[i] = max(h[i], val);\n  }\n}\nint f[MAXN], ans;\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  int ans = 0;\n  for (int i = 1; i <= n; i++) {\n    f[i] = ask(a[i] - 1) + 1;\n    ans = max(ans, f[i]);\n    ins(a[i], f[i]);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n \npublic class Main\n{\n \n    static class LIS { \n        // Binary search (note boundaries in the caller) \n        // A[] is ceilIndex in the caller \n        static int CeilIndex(int A[], int l, int r, int key) \n        { \n            while (r - l > 1) { \n                int m = l + (r - l) / 2; \n                if (A[m] >= key) \n                    r = m; \n                else\n                    l = m; \n            } \n\n            return r; \n        } \n\n        static int LongestInc(int A[], int size) \n        { \n            // Add boundary case, when array size is one \n\n            int[] tailTable = new int[size]; \n            int len; // always points empty slot \n\n            tailTable[0] = A[0]; \n            len = 1; \n            for (int i = 1; i < size; i++) { \n                if (A[i] < tailTable[0]) \n                    // new smallest value \n                    tailTable[0] = A[i]; \n\n                else if (A[i] > tailTable[len - 1]) \n                    // A[i] wants to extend largest subsequence \n                    tailTable[len++] = A[i]; \n\n                else\n                    // A[i] wants to be current end candidate of an existing \n                    // subsequence. It will replace ceil value in tailTable \n                    tailTable[CeilIndex(tailTable, -1, len - 1, A[i])] = A[i]; \n            } \n\n            return len; \n        } \n\n    } \n/* This code is contributed by Devesh Agrawal*/\n\n    public static void process(int test_number)throws IOException\n    {\n        LIS ob = new LIS();\n        int n = ni(), arr[] = new int[n];\n        for(int i = 0; i < n; i++)\n            arr[i] = ni();\n        pn(ob.LongestInc(arr, n));    \n    }\n \n    static final long mod = (long)1e9+7l;\n    \n    static FastReader sc;\n    static PrintWriter out;\n    public static void main(String[]args)throws IOException\n    {\n        out = new PrintWriter(System.out);\n        sc = new FastReader();\n \n        long s = System.currentTimeMillis();\n        int t = 1;\n        //t = ni();\n        for(int i = 1; i <= t; i++)\n            process(i);\n \n        out.flush();\n        System.err.println(System.currentTimeMillis()-s+\"ms\");\n    }\n\n    static void trace(Object... o){ System.err.println(Arrays.deepToString(o)); };\n    static void pn(Object o){ out.println(o); }\n    static void p(Object o){ out.print(o); }\n    static int ni()throws IOException{ return Integer.parseInt(sc.next()); }\n    static long nl()throws IOException{ return Long.parseLong(sc.next()); }\n    static double nd()throws IOException{ return Double.parseDouble(sc.next()); }\n    static String nln()throws IOException{ return sc.nextLine(); }\n    static long gcd(long a, long b)throws IOException{ return (b==0)?a:gcd(b,a%b);}\n    static int gcd(int a, int b)throws IOException{ return (b==0)?a:gcd(b,a%b); }\n    static int bit(long n)throws IOException{ return (n==0)?0:(1+bit(n&(n-1))); }\n    \n    static class FastReader{ \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader(){ \n            br = new BufferedReader(new InputStreamReader(System.in)); \n        } \n  \n        String next(){ \n            while (st == null || !st.hasMoreElements()){ \n                try{ st = new StringTokenizer(br.readLine()); } catch (IOException  e){ e.printStackTrace(); } \n            } \n            return st.nextToken(); \n        } \n  \n        String nextLine(){ \n            String str = \"\"; \n            try{ str = br.readLine(); } catch (IOException e) { e.printStackTrace(); } \n            return str; \n        } \n    } \n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint toInt(string s) {\n  int v;\n  istringstream sin(s);\n  sin >> v;\n  return v;\n}\ntemplate <class T>\nstring toString(T x) {\n  ostringstream sout;\n  sout << x;\n  return sout.str();\n}\nvector<string> form(string a, char s) {\n  a += s;\n  vector<string> v;\n  string b;\n  for (int i = (0); i < (int)(a.size()); ++i) {\n    if (a[i] == s) {\n      v.push_back(b);\n      b = \"\";\n    } else\n      b += a[i];\n  }\n  return v;\n}\nvector<int> formint(string a, char s) {\n  vector<int> v;\n  vector<string> w = form(a, s);\n  for (int i = (0); i < (int)(w.size()); ++i) v.push_back(toInt(w[i]));\n  return v;\n}\nconst int inf = 99999999;\nint lis_fast(const vector<int>& a) {\n  const int n = a.size();\n  vector<int> A(n, inf);\n  vector<int> id(n);\n  for (int i = 0; i < n; ++i) {\n    id[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n    A[id[i]] = a[i];\n  }\n  int m = *max_element(id.begin(), id.end());\n  return m + 1;\n}\nint main(void) {\n  int n;\n  scanf(\"%d\", &n);\n  vector<int> v(n);\n  for (int i = (0); i < (int)(n); ++i) cin >> v[i];\n  int res = lis_fast(v);\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000009;\nconst int N = 100010;\nint a[N], dp[N];\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  for (int i = 1; i <= n; i++) dp[i] = INF;\n  dp[0] = 0;\n  for (int i = 1; i <= n; i++) {\n    int l = 0, r = i - 1;\n    while (l < r) {\n      int mid = (l + r + 1) / 2;\n      if (dp[mid] <= a[i])\n        l = mid;\n      else\n        r = mid - 1;\n    }\n    dp[l + 1] = a[i];\n  }\n  int ans = 0;\n  for (int i = n; i >= 1; i--)\n    if (dp[i] < INF) {\n      ans = i;\n      break;\n    }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "\"\"\"\nhttp://codeforces.com/problemset/problem/341/B\n\"\"\"\n\nfrom typing import List\nfrom bisect import bisect_right\n\n\nclass Solution:\n    def patienceSort(self, a: List[int]) -> int:\n        # patience sort can find longest increasing subsequence in O(NlogN)\n        # https://en.wikipedia.org/wiki/Patience_sorting\n        n = len(a)\n        piles = [n + 1 for i in range(n)]  # To find length of LIS, we're only interested in the top card of each pile\n        nextPileIdx = 0\n        for i in a:\n            idx = bisect_right(piles, i, 0, nextPileIdx)\n            piles[idx] = i\n            if idx >= nextPileIdx:\n                nextPileIdx += 1\n\n        return nextPileIdx\n\n    def maxIndependentSetSize(self, a: List[int]) -> int:\n        return self.patienceSort(a)\n\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    a = list(map(int, input().strip().split()))\n    s = Solution()\n    print(s.maxIndependentSetSize(a))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100002], dp[100001];\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  fill(dp, dp + n, 1);\n  int t = 1;\n  for (int i = 1; i < n; i++) {\n    int lo = 0, up = t - 1;\n    int x = 1;\n    while (up >= lo) {\n      int d = (up + lo) / 2;\n      if (a[d] <= a[i]) {\n        if (dp[d] > x - 1) {\n          x = dp[d] + 1;\n        }\n        lo = d + 1;\n      } else\n        up = d - 1;\n    }\n    lo = 0;\n    up = t - 1;\n    bool flag = false;\n    while (up >= lo) {\n      int d = (up + lo) / 2;\n      if (x == dp[d]) {\n        a[d] = min(a[i], a[d]);\n        flag = true;\n        break;\n      }\n      if (x > dp[d])\n        lo = d + 1;\n      else\n        up = d - 1;\n    }\n    if (!flag) {\n      dp[t] = x;\n      a[t++] = a[i];\n    }\n  }\n  int maxIn = 0;\n  for (int i = 0; i < n; i++)\n    if (dp[i] > dp[maxIn]) maxIn = i;\n  cout << dp[maxIn] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.awt.*;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class Main {\n    static int mod = (int) 1e9 + 7;\n    static boolean[] vis;\n    public static void main(String[] args) throws Exception {\n        FastReader sc = new FastReader();\n        int n=sc.nextInt();\n        int[] arr=new int[n];\n        for(int i=0;i<n;i++)arr[i]=sc.nextInt();\n        int[] dp=new int[n+1];\n        Arrays.fill(dp,Integer.MAX_VALUE);\n        dp[0]=Integer.MIN_VALUE;\n        for(int i=0;i<n;i++){\n            int l=0,r=dp.length-1;\n            while(l<=r){\n                int mid=l+(r-l)/2;\n                if(dp[mid]<=arr[i]){\n                    l=mid+1;\n                }\n                else r=mid-1;\n            }\n            dp[l]=arr[i];\n        }\n        int count=1;\n        while(count<=n && dp[count]!=Integer.MAX_VALUE)count++;\n        System.out.println(count-1);\n    }\n}\nclass FastReader {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastReader() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    String next() {\n        while (st == null || !st.hasMoreElements()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    String nextLine() {\n        String str = \"\";\n        try {\n            str = br.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return str;\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class File {\n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\t\t\n\t\t\n\t\t\n\t\n\t\t\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\t\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\t\n\t\n\t\tint[] lis = new int[n+1];\n\t\tArrays.fill(lis, 100001);\n\t\tlis[0] = 0;\n\t\tint length = 0;\n\t\t\n\t\tfor (int val : a) {\n\t\t\tint index = search(lis, length, val);\n\t\t\t\n\t\t\tif (lis[index+1] == 100001) {\n\t\t\t\tlis[index+1] = val;\n\t\t\t\tindex++;\n\t\t\t\tlength = Math.max(length, index);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlis[index+1] = Math.min(lis[index+1], val);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tout.println(length);\n\t\t\n\t\n\t\t\n\t\t\n\t\t\n        out.close();\n    }\n\t\n\tpublic static int search(int[] a, int hi, int val) {\n\t\tint res = 0;\n\t\t\n\t\tint lo = 0;\n\t\t\n\t\twhile (lo <= hi) {\n\t\t\tint mid = lo + (hi - lo) / 2;\n\t\t\t\n\t\t\tif (a[mid] < val) {\n\t\t\t\tres = Math.max(res, mid);\n\t\t\t\tlo = mid + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\thi = mid - 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = int(1e5 + 5);\nint a[N], dp[N], t[4 * N], sz;\nint max(int l, int r, int L, int R, int v) {\n  if (r <= L || R <= l) return 0;\n  if (l <= L && R <= r) return t[v];\n  int mid = (L + R) / 2;\n  return max(max(l, r, L, mid, v * 2), max(l, r, mid, R, v * 2 + 1));\n}\nvoid upd(int v, int val) {\n  v += sz - 1;\n  while (v) {\n    t[v] = max(val, t[v]);\n    v /= 2;\n  }\n}\nint main() {\n  int n, res = 0;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    dp[i] = 1;\n  }\n  sz = 1;\n  while (sz < n) sz <<= 1;\n  for (int i = 0; i < n; i++) {\n    dp[i] = max(1, a[i], 1, sz + 1, 1) + 1;\n    res = max(res, dp[i]);\n    upd(a[i], dp[i]);\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class D {\n    \n    static StringTokenizer st;\n    static BufferedReader in;\n    static PrintWriter pw;\n    \n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        int n = nextInt();\n        int[]a = new int[n+1];\n        for (int i = 1; i <= n; i++) {\n            a[i] = nextInt();\n        }\n        int[]d = new int[n+1];\n        int INF = (int) 1e9;\n        Arrays.fill(d, INF);\n        d[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            int ind = Arrays.binarySearch(d, a[i]);\n            if (ind < 0) {\n                ind = Math.abs(ind)-1;\n                if (a[i] > d[ind-1] && a[i] < d[ind])\n                    d[ind] = a[i];\n            }\n        }\n        for (int i = n; i >= 1; i--) {\n            if (d[i] != INF) {\n                System.out.println(i);\n                return;\n            }\n        }\n        pw.close();\n    }\n    private static int nextInt() throws IOException{\n        return Integer.parseInt(next());\n    }\n    \n    private static long nextLong() throws IOException{\n        return Long.parseLong(next());\n    }\n    \n    private static double nextDouble() throws IOException{\n        return Double.parseDouble(next());\n    }\n    \n    private static String next() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma comment(linker, \"/STACK:64000000\")\nconst int maxn = 1 << 17;\nconst int inf = 1000000007;\nconst int mod = 1000000007;\nint n;\nint a[maxn], d[maxn];\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  memset(d, 127, sizeof(d));\n  d[0] = -1;\n  for (int i = 0; i < n; i++) {\n    int j = lower_bound(d, d + n + 1, a[i]) - d;\n    d[j] = a[i];\n  }\n  for (int i = n; i >= 0; i--) {\n    if (d[i] < 1e9) {\n      cout << i << endl;\n      break;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int INF = 1LL << 60;\nlong long int n, m, k, x, y, z;\nint mod = 1e9 + 7;\nlong long int add(long long int a, long long int b) {\n  if (a + b >= mod) return a + b - mod;\n  return a + b;\n}\nlong long int sub(long long int a, long long int b) {\n  if (a < b) return a - b + mod;\n  return a - b;\n}\nlong long int mul(long long int a, long long int b) {\n  return 1LL * a * b % mod;\n}\nint power(int a, int b) {\n  if (b < 0) return 0;\n  int re = 1;\n  while (b) {\n    if (b & 1) {\n      re = mul(re, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return re;\n}\nbool sortbysec(const pair<long long int, long long int> &a,\n               const pair<long long int, long long int> &b) {\n  return (a.second < b.second);\n}\nbool sortbyfi(\n    const pair<long long int, pair<long long int, long long int>> &a,\n    const pair<long long int, pair<long long int, long long int>> &b) {\n  return (a.first > b.first);\n}\npriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>\n    pq;\nlong long int bs(vector<long long int> v, long long int x) {\n  long long int hi = v.size() - 1, lo = 0;\n  while (hi >= lo) {\n    long long int mid = lo + (hi - lo) / 2;\n    if (v[mid] == x)\n      return 1;\n    else if (v[mid] < x)\n      lo = mid + 1;\n    else\n      hi = mid - 1;\n  }\n  return 0;\n}\nbool paired(char a, char b) {\n  if (a == '[' and b == ']') return true;\n  if (a == '{' and b == '}') return true;\n  if (a == '(' and b == ')') return true;\n  if (a == '<' and b == '>') return true;\n  return false;\n}\nbool cmp(pair<long long int, vector<long long int>> a,\n         pair<long long int, vector<long long int>> b) {\n  return a.first > b.first;\n}\nlong long int dp[200005][2] = {0};\nvoid update1(long long int idx, long long int val, long long int pos) {\n  while (idx <= 100000) {\n    dp[idx][pos] += val;\n    dp[idx][pos] %= 1000000007;\n    idx += idx & -idx;\n  }\n}\nlong long int pref1(long long int idx, long long int pos) {\n  long long int ans = 0;\n  while (idx > 0) {\n    ans += dp[idx][pos];\n    ans %= 1000000007;\n    idx -= idx & -idx;\n  }\n  return ans;\n}\nlong long int bit[200005] = {0};\nvoid update(long long int idx, long long int val) {\n  while (idx <= 100000) {\n    bit[idx] += val;\n    idx += idx & -idx;\n  }\n}\nlong long int pref(long long int idx) {\n  long long int ans = 0;\n  while (idx > 0) {\n    ans += bit[idx];\n    idx -= idx & -idx;\n  }\n  return ans;\n}\nlong long int rsum(long long int l, long long int r) {\n  return pref(r) - pref(l - 1);\n}\nvoid Birdperson() {\n  cin >> n;\n  set<long long int> s;\n  for (int i = 0; i < (n); ++i) {\n    cin >> x;\n    s.insert(x);\n    auto it = s.upper_bound(x);\n    if (it != s.end()) s.erase(it);\n  }\n  cout << (int)s.size() << \"\\n\";\n}\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long int t = 1;\n  long long int cnt = 1;\n  while (cnt <= t) {\n    Birdperson();\n    cnt++;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author IncubatorMan\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DBubbleSortGraph solver = new DBubbleSortGraph();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DBubbleSortGraph {\n        public static int upperBound(int[] array, int length, int value) {\n            int low = 0;\n            int high = length;\n            while (low < high) {\n                final int mid = (low + high) / 2;\n                if (value >= array[mid]) {\n                    low = mid + 1;\n                } else {\n                    high = mid;\n                }\n            }\n            return low;\n        }\n\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int n;\n            n = in.nextInt();\n            int[] data = new int[n];\n            int[] lis = new int[n + 5];\n\n\n            int INF = (int) 1e9;\n            Arrays.fill(lis, INF);\n            lis[0] = -INF;\n            for (int i = 0; i < n; i++) {\n                int x = in.nextInt();\n                int j = upperBound(lis, n, x);\n                if (lis[j - 1] < x && lis[j] > x) {\n                    lis[j] = x;\n                }\n            }\n            int ans = 0;\n            for (int i = 0; i <= n; i++) {\n                if (lis[i] < INF) ans = i;\n                else break;\n            }\n\n            out.println(ans);\n\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100050;\nint dp[N], n, mx[N << 2], a[N];\nvoid update(int p, int add, int l, int r, int rt) {\n  if (l == r) {\n    mx[rt] = add;\n    return;\n  }\n  int m = (l + r) >> 1;\n  if (p <= m)\n    update(p, add, l, m, rt << 1);\n  else\n    update(p, add, m + 1, r, rt << 1 | 1);\n  mx[rt] = max(mx[rt << 1], mx[rt << 1 | 1]);\n}\nint query(int L, int R, int l, int r, int rt) {\n  if (L <= l && r <= R) return mx[rt];\n  int m = (l + r) >> 1;\n  int ret = 0;\n  if (L <= m) ret = max(ret, query(L, R, l, m, rt << 1));\n  if (R > m) ret = max(ret, query(L, R, m + 1, r, rt << 1 | 1));\n  return ret;\n}\nint main() {\n  scanf(\"%d\", &n);\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    int a;\n    scanf(\"%d\", &a);\n    int ret = query(1, a, 1, n, 1);\n    dp[a] = ret + 1;\n    ans = max(ans, dp[a]);\n    update(a, dp[a], 1, n, 1);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 2000000000;\nconst long double eps = 1e-07;\nint n;\nint a[200000];\nint d[200000];\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) scanf(\"%d\", &a[i]);\n  d[0] = -inf;\n  for (int i = 1; i <= n; ++i) d[i] = inf;\n  for (int i = 0; i < n; i++) {\n    int l = 0;\n    int r = n;\n    while (r - l > 2) {\n      int m = (l + r) / 2;\n      if (d[m] < a[i]) {\n        l = m;\n      } else\n        r = m;\n    }\n    for (int j = r; j >= l; --j)\n      if (d[j] < a[i]) {\n        d[j + 1] = a[i];\n        break;\n      }\n  }\n  int ans = -inf;\n  for (int i = 1; i <= n; ++i)\n    if (d[i] != inf) ans = max(ans, i);\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  int n;\n  while (cin >> n) {\n    int a[100000];\n    vector<int> v;\n    for (int i = 0; i != n; ++i) cin >> a[i];\n    int MaxV[100005];\n    MaxV[1] = a[0];\n    int nmaxv = 1;\n    for (int i = 1; i != n; ++i) {\n      int u = 1, v = nmaxv;\n      while (u <= v) {\n        int mid = (u + v) >> 1;\n        if (MaxV[mid] < a[i])\n          u = mid + 1;\n        else\n          v = mid - 1;\n      }\n      nmaxv = max(nmaxv, v + 1);\n      MaxV[v + 1] = a[i];\n    }\n    cout << nmaxv << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint fena[100005], fenn;\nvoid initfen() { memset(fena, 0, sizeof(fena)); }\nint fengetmax(int inx) {\n  int ret = 0;\n  for (int i = inx; i > 0; i -= (i & (-i))) ret = max(ret, fena[i]);\n  return ret;\n}\nvoid fenset(int inx, int val) {\n  for (int i = inx; i <= fenn; i += (i & (-i))) fena[i] = max(fena[i], val);\n}\nvoid doit() {\n  int tn, ret = 0, cmax = 0;\n  cin >> fenn;\n  initfen();\n  for (int i = 0; i < fenn; i++) {\n    cin >> tn;\n    cmax = fengetmax(tn);\n    fenset(tn, cmax + 1);\n    ret = max(ret, cmax + 1);\n  }\n  cout << ret << endl;\n  return;\n}\nint main() {\n  doit();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000 * 1000 * 1000 + 5;\nconst int MOD = 1000 * 1000 * 1000 + 7;\nconst long double EPS = 1e-8;\nint n;\nvector<int> a;\nvector<int> f;\nint ans;\nvoid change(int x, int d) {\n  for (int i = x; i < n; i = i | (i + 1)) f[i] = max(f[i], d);\n}\nint get(int x) {\n  int res = 0;\n  for (int i = x; i >= 0; i = (i & (i + 1)) - 1) res = max(res, f[i]);\n  return res;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin >> n;\n  a.resize(n);\n  for (int i = 0; i < n; ++i) cin >> a[i], --a[i];\n  f.resize(n);\n  for (int i = 0; i < n; ++i) {\n    int x = get(a[i]) + 1;\n    change(a[i], x);\n    ans = max(ans, x);\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nunsigned long long gcd(unsigned long long a, unsigned long long b) {\n  return (b == 0 ? a : gcd(b, a % b));\n}\nlong long x, y, z, n, m, r, l, k, a, h, d;\nchar c;\nvector<int> v;\nvector<int> tail;\nint bs(int l, int r, int key) {\n  while (r - l > 1) {\n    int m = l + (r - l) / 2;\n    if (tail[m] >= key)\n      r = m;\n    else\n      l = m;\n  }\n  return r;\n}\nint dfs() {\n  if (v.size() == 0) return 0;\n  tail.clear();\n  tail.resize(v.size());\n  int length = 1;\n  tail[0] = v[0];\n  for (size_t i = 1; i < v.size(); i++) {\n    if (v[i] < tail[0])\n      tail[0] = v[i];\n    else if (v[i] > tail[length - 1])\n      tail[length++] = v[i];\n    else\n      tail[bs(-1, length - 1, v[i])] = v[i];\n  }\n  return length;\n}\nvoid solve() {\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> x, v.push_back(x);\n  cout << dfs();\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cout.tie(0);\n  cin.tie(0);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class CO_527D {\n\tstatic int imax = Integer.MAX_VALUE, imin = Integer.MIN_VALUE;\n\tstatic long lmax = Long.MAX_VALUE, lmin = Long.MIN_VALUE;\n\tstatic long mod = (long) 1e9 + 7;\n\n\tpublic static void main(String[] args) throws java.lang.Exception {\n\t\tInputReader in = new InputReader(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t// int test=in.ni();\n\t\tint test = 1;\n\t\twhile (test-- > 0) {\n\t\t\tint n = in.ni();\n\t\t\tint arr[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarr[i] = in.ni();\n\t\t\tint tmp[] = new int[n];\n\t\t\tint len = 0;\n\t\t\ttmp[0] = 0;\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tif (arr[i] < arr[tmp[0]]) {\n\t\t\t\t\ttmp[0] = i;\n\t\t\t\t} else if (arr[i] > arr[tmp[len]]) {\n\t\t\t\t\tlen++;\n\t\t\t\t\ttmp[len] = i;\n\t\t\t\t} else {\n\t\t\t\t\tint idx = binarySearch(arr, tmp, arr[i], len);\n\t\t\t\t\ttmp[idx] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println((len + 1));\n\t\t}\n\t\tout.close();\n\t}\n\n\tstatic int binarySearch(int arr[], int tmp[], int q, int len) {\n\t\tint l = 1, r = len;\n\t\twhile (l < r) {\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tif (arr[tmp[mid]] < q) {\n\t\t\t\tl = mid + 1;\n\t\t\t} else {\n\t\t\t\tr = mid;\n\t\t\t}\n\t\t}\n\t\treturn l;\n\t}\n\n\tstatic class Pair {\n\t\tint x, y;\n\n\t\tPair(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn x + \" \" + y;\n\t\t}\n\n\t}\n\n\tstatic void print(int arr[], int len) {\n\t\tfor (int i = 0; i < len; i++)\n\t\t\tSystem.out.print(arr[i] + \" \");\n\t\tSystem.out.println();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int ni() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c & 15;\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic long nl() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c & 15;\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic String ns() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic char[] ncs() {\n\t\t\treturn ns().toCharArray();\n\t\t}\n\n\t\tpublic String nLine() {\n\t\t\tint c = read();\n\t\t\t// while (c != '\\n' && c != '\\r' && c != '\\t' && c != -1)\n\t\t\t// c = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (c != '\\n' && c != '\\r' && c != '\\t' && c != -1);\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic static boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t}\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class CF {\n\n\tMyScanner in;\n\tPrintWriter out;\n\n\tclass SegmentTree {\n\t\tint n;\n\t\tint[] max;\n\n\t\tpublic SegmentTree(int n) {\n\t\t\tthis.n = n;\n\t\t\tmax = new int[4 * n];\n\t\t}\n\n\t\tvoid upd(int v, int l, int r, int need, int val) {\n\t\t\tif (l == r) {\n\t\t\t\tmax[v] = val;\n\t\t\t} else {\n\t\t\t\tint m = (l + r) / 2;\n\t\t\t\tif (need <= m) {\n\t\t\t\t\tupd(v * 2 + 1, l, m, need, val);\n\t\t\t\t} else {\n\t\t\t\t\tupd(v * 2 + 2, m + 1, r, need, val);\n\t\t\t\t}\n\t\t\t\tmax[v] = Math.max(max[v * 2 + 1], max[v * 2 + 2]);\n\t\t\t}\n\t\t}\n\n\t\tint get(int v, int l, int r, int needL, int needR) {\n\t\t\tif (needR < needL)\n\t\t\t\treturn 0;\n\t\t\tif (needL == l && needR == r)\n\t\t\t\treturn max[v];\n\t\t\tint m = (l + r) / 2;\n\t\t\treturn Math.max(get(v * 2 + 1, l, m, needL, Math.min(needR, m)), get(v * 2 + 2, m + 1, r, Math.max(m + 1, needL), needR));\n\t\t}\n\t}\n\n\tvoid solve() {\n\t\tint n = in.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = in.nextInt();\n\t\t}\n\t\tSegmentTree st = new SegmentTree(n + 1);\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint max = st.get(0, 0, n, 0, a[i] - 1);\n\t\t\tst.upd(0, 0, n, a[i], max + 1);\n\t\t\tres = Math.max(res, max + 1);\n\t\t}\n\t\tout.println(res);\n\t}\n\n\tvoid run() {\n\t\ttry {\n\t\t\tin = new MyScanner();\n\t\t\tout = new PrintWriter(System.out);\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tBufferedReader in;\n\t\tStringTokenizer st;\n\n\t\tpublic MyScanner() {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\n\t\t}\n\n\t\tString nextToken() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(in.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew CF().run();\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "//package round198;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\n\npublic class B {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni();\n\t\tint[] a = na(n);\n\t\tout.println(lis2(a));\n\t}\n\t\n\tpublic static int lis2(int[] in)\n\t{\n\t\tint n = in.length;\n\t\tint ret = 0;\n\t\tint[] h = new int[n + 1];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint ind = Arrays.binarySearch(h, 0, ret + 1, in[i]);\n\t\t\tif(ind < 0){\n\t\t\t\tind = -ind-2;\n\t\t\t\th[ind+1] = in[i];\n\t\t\t\tif(ind >= ret)ret++;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new B().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tprivate int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int n, BIT[100001], arr[100001];\nvoid insert(long long int x, long long int val) {\n  for (; x <= n; x += (x & (-x))) BIT[x] = max(BIT[x], val);\n}\nlong long int query(long long int x) {\n  long long int sum = 0;\n  for (; x > 0; x -= (x & (-x))) sum = max(sum, BIT[x]);\n  return sum;\n}\nint main() {\n  long long int i, j, k;\n  cin >> n;\n  for (i = 0; i < n; ++i) cin >> arr[i];\n  k = 0;\n  for (i = 0; i < n; ++i) {\n    j = query(arr[i]) + 1;\n    k = max(k, j);\n    insert(arr[i], j);\n  }\n  cout << k << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, a[100005], lis[100005];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n;\n  for (long long i = 0; i < n; i++) cin >> a[i];\n  long long len = 0;\n  for (long long i = 0; i < n; i++) {\n    long long pos = lower_bound(lis, lis + len, a[i]) - lis;\n    lis[pos] = a[i];\n    if (pos + 1 > len) len = pos + 1;\n  }\n  cout << len << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, a[100005];\nint s[100005], top;\nvoid work() {\n  int i, j;\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n  for (i = 1; i <= n; ++i) {\n    if (a[i] > s[top])\n      s[++top] = a[i];\n    else {\n      j = upper_bound(s + 1, s + top + 1, a[i]) - s;\n      s[j] = a[i];\n    }\n  }\n  cout << top << endl;\n}\nint main() {\n  work();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1000000;\nint g[maxn];\nint n;\nint a[maxn];\nint lowbit(int x) { return x & (-x); }\nvoid update(int x, int f) {\n  while (x <= n) {\n    g[x] = max(g[x], f);\n    x += lowbit(x);\n  }\n}\nint getmax(int x) {\n  int ans = 0;\n  while (x > 0) {\n    ans = max(ans, g[x]);\n    x -= lowbit(x);\n  }\n  return ans;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n  memset(g, 0, sizeof(g));\n  int ans = 0;\n  for (int i = 1; i <= n; ++i) {\n    int f = getmax(a[i]) + 1;\n    ans = max(ans, f);\n    update(a[i], f);\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N, L;\nint vals[100001];\nint m[100000];\nint main() {\n  scanf(\"%d\", &N);\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d\", &vals[i]);\n    m[i] = 100000;\n  }\n  vals[100000] = 1 << 30;\n  L = 0;\n  for (int i = 0; i < N; i++) {\n    int lb = 0, ub = L;\n    while (ub - lb > 1) {\n      int mid = (ub + lb) / 2;\n      if (vals[m[mid]] < vals[i])\n        lb = mid;\n      else\n        ub = mid - 1;\n    }\n    int j = 0;\n    for (int t = lb; t <= ub; t++)\n      if (vals[m[t]] < vals[i]) j = t;\n    if (j == L || vals[i] < vals[m[j + 1]]) {\n      m[j + 1] = i;\n      L = max(L, j + 1);\n    }\n  }\n  printf(\"%d\\n\", L);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[1000009];\nint LIS(vector<int> a) {\n  int maxi = 1;\n  int sz = a.size();\n  vector<int> d(sz + 1, 100000000);\n  for (int i = int(0); i <= int(sz - 1); i++) {\n    vector<int>::iterator it = lower_bound(d.begin(), d.end(), a[i]);\n    *it = a[i];\n    dp[i] = (it - d.begin()) + 1;\n    maxi = max(maxi, dp[i]);\n  }\n  return maxi;\n}\nint main() {\n  memset(dp, 0, sizeof(dp));\n  int n;\n  scanf(\"%d\", &n);\n  vector<int> a(n);\n  for (int i = int(0); i <= int(n - 1); i++) scanf(\"%d\", &a[i]);\n  int ans = LIS(a);\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class B\n{\n\tpublic static void main(String [] args) throws IOException\n\t{\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tStringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n\n\t\tint n = Integer.parseInt(tokenizer.nextToken());\n\t\tint [] array = new int[n];\n\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\tfor(int i = 0 ; i < n ; i++)\n\t\t\tarray[i] = Integer.parseInt(tokenizer.nextToken());\n\n\t\tint res = 0;\n\t\tint [] sort = new int[n+1];\n\t\tfor(int i = 0 ; i < n ; i++)\n\t\t{\n\t\t\tint ind = Arrays.binarySearch(sort, 0, res+1, array[i]);\n\t\t\tif(ind < 0)\n\t\t\t{\n\t\t\t\tind = -ind-2;\n\t\t\t\tsort[ind+1] = array[i];\n\t\t\t\tif(ind == res)\n\t\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(res);\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T, typename U>\ninline void smin(T &a, U b) {\n  if (a > b) a = b;\n}\ntemplate <typename T, typename U>\ninline void smax(T &a, U b) {\n  if (a < b) a = b;\n}\ntemplate <class T>\ninline void gn(T &first) {\n  char c, sg = 0;\n  while (c = getchar(), (c > '9' || c < '0') && c != '-')\n    ;\n  for ((c == '-' ? sg = 1, c = getchar() : 0), first = 0; c >= '0' && c <= '9';\n       c = getchar())\n    first = (first << 1) + (first << 3) + c - '0';\n  if (sg) first = -first;\n}\ntemplate <class T>\ninline void print(T first) {\n  if (first < 0) {\n    putchar('-');\n    return print(-first);\n  }\n  if (first < 10) {\n    putchar('0' + first);\n    return;\n  }\n  print(first / 10);\n  putchar(first % 10 + '0');\n}\ntemplate <class T, class T1>\ninline void gn(T &first, T1 &second) {\n  gn(first);\n  gn(second);\n}\ntemplate <class T, class T1, class T2>\ninline void gn(T &first, T1 &second, T2 &z) {\n  gn(first);\n  gn(second);\n  gn(z);\n}\ntemplate <class T>\ninline void println(T first) {\n  print(first);\n  putchar('\\n');\n}\ntemplate <class T>\ninline void printsp(T first) {\n  print(first);\n  putchar(' ');\n}\ntemplate <class T1, class T2>\ninline void print(T1 x1, T2 x2) {\n  printsp(x1), println(x2);\n}\ntemplate <class T1, class T2, class T3>\ninline void print(T1 x1, T2 x2, T3 x3) {\n  printsp(x1), printsp(x2), println(x3);\n}\ntemplate <class T1, class T2, class T3, class T4>\ninline void print(T1 x1, T2 x2, T3 x3, T4 x4) {\n  printsp(x1), printsp(x2), printsp(x3), println(x4);\n}\nint power(int a, int b, int m, int ans = 1) {\n  for (; b; b >>= 1, a = 1LL * a * a % m)\n    if (b & 1) ans = 1LL * ans * a % m;\n  return ans;\n}\nint a[100011];\nint b[100011];\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; i++) gn(a[i]);\n  for (int i = 0; i < 100011; i++) b[i] = 0x3f3f3f3f;\n  for (int i = 1; i <= n; i++) {\n    int pos = upper_bound(b, b + 100011, a[i]) - b;\n    b[pos] = a[i];\n  }\n  for (int i = 0; i < 100011; i++)\n    if (b[i] == 0x3f3f3f3f) return cout << i << endl, 0;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint oo = (1 << 31) - 1;\nint arr[100010];\nint main() {\n  int N, lis, v, p;\n  scanf(\"%d\", &N);\n  arr[0] = oo;\n  lis = 1;\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d\", &v);\n    p = lower_bound(arr, arr + lis, v) - arr;\n    arr[p] = v;\n    if (p == lis) lis++;\n  }\n  printf(\"%d\\n\", lis);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint r[100100], n;\nint sum(int x) {\n  int ans = 0;\n  for (; x >= 0; x = ((x & (x + 1)) - 1)) ans = max(r[x], ans);\n  return ans;\n}\nvoid modify(int x, int y) {\n  for (; x <= n; x = (x | (x + 1))) r[x] = max(r[x], y);\n}\nint res, mas[100100];\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &mas[i]);\n    int d = sum(mas[i] - 1);\n    modify(mas[i], d + 1);\n    res = max(res, d + 1);\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class a {\n    static long mod = 1000000009;\n    public static void main(String[] args) throws IOException {\n        // Scanner input = new Scanner(new File(\"input.txt\"));\n        // PrintWriter out = new PrintWriter(new File(\"output.txt\"));\n        input.init(System.in);\n        PrintWriter out = new PrintWriter((System.out));\n        int n = input.nextInt();\n        int[] data = new int[n];\n        for(int i = 0; i<n; i++) data[i] = input.nextInt();\n        int[] dp = new int[n+1];\n        Arrays.fill(dp, 987654321);\n        dp[0] = data[0];\n        for(int i = 1; i<n; i++)\n        {\n            int lo = 0, hi = n;\n            while(hi > lo+1)\n            {\n                int mid = (hi+lo)/2;\n                if(dp[mid] > data[i]) hi = mid;\n                else lo = mid;\n            }\n            if(dp[lo] < data[i]) lo++;\n            if(lo <= n) dp[lo] = Math.min(data[i], dp[lo]);\n        }\n        int res = 1;\n        //for(int x: dp) out.println(x);\n        for(int i = 1; i<=n; i++) if(dp[i] != 987654321) res++;\n        out.println(res);\n        \n        \n        out.close();\n    }\n    static long pow(long x, long p) {\n        if (p == 0)\n            return 1;\n        if ((p & 1) > 0) {\n            return (x * pow(x, p - 1)) % mod;\n        }\n        long sqrt = pow(x, p / 2);\n        return (sqrt * sqrt) % mod;\n    }\n\n    static long gcd(long a, long b) {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n\n    static class input {\n        static BufferedReader reader;\n        static StringTokenizer tokenizer;\n\n        /** call this method to initialize reader for InputStream */\n        static void init(InputStream input) {\n            reader = new BufferedReader(new InputStreamReader(input));\n            tokenizer = new StringTokenizer(\"\");\n        }\n\n        /** get next word */\n        static String next() throws IOException {\n            while (!tokenizer.hasMoreTokens()) {\n                // TODO add check for eof if necessary\n                tokenizer = new StringTokenizer(reader.readLine());\n            }\n            return tokenizer.nextToken();\n        }\n\n        static int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        static double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        static long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        static String nextLine() throws IOException {\n            return reader.readLine();\n        }\n    }\n}\n\n"
        },
        {
            "language": 1,
            "solution": "l=lambda:map(int,raw_input().split())  \nfrom bisect import bisect_right\n\ndef longest_increasing_subsequence(A,n):\n    s=[A[0]]\n    for i in xrange(1,n):\n        if A[i]>s[-1]:\n            s.append(A[i])\n        else:\n            s[bisect_right(s, A[i])] = A[i]\n    return len(s)\n\nn=input()\nA=l()\nprint longest_increasing_subsequence(A,n)"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic class Main {\n    public static void main(String[]args) {\n        Scanner in = new Scanner(System.in);\n        int size = in.nextInt();\n        int[] nums = new int[size];\n        for(int i = 0 ; i < size; i++){\n            nums[i] = in.nextInt();\n        }\n        \n        int[] store = new int[size*2];\n        store[0] = Integer.MAX_VALUE;\n        store[1] = nums[0];\n        for(int i = 1; i < size; i++) {\n            //binary search store for i;\n            int min = 0;\n            int max = size;\n            while(min != max) {\n                int mid = (min + max +1)/2;\n                if(store[mid] == 0 || store[mid] > nums[i]) {\n                    max = mid-1;\n                } else {\n                    min = mid;\n                }\n            }\n            if(store[min+1] > nums[i] || store[min+1] == 0) {\n                store[min+1] = nums[i];\n            }\n        }\n        int best = 1;\n        for(int i = 1; i <= size; i++) {\n            if(store[i] != 0){\n                best = i;\n            }\n        }\n        System.out.println(best);\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, h[200005], f[200005], stk[200005], top, ans;\nvoid init() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &h[i]);\n}\nvoid work() {\n  for (int i = 1; i <= n; i++) {\n    int res = 0;\n    for (int x = h[i]; x; x -= (x & -x)) res = max(res, f[x]);\n    for (int x = h[i]; x <= n; x += (x & -x)) f[x] = max(f[x], res + 1);\n  }\n  int res = 0;\n  for (int x = n; x; x -= (x & -x)) res = max(res, f[x]);\n  printf(\"%d\\n\", res);\n}\nint main() {\n  init();\n  work();\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.TreeSet;\nimport java.io.Writer;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Parser in = new Parser(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass TaskB {\n    public void solve(int testNumber, Parser in, OutputWriter out) {\n        int n = in.nextInt();\n        int[] a = in.readIntArray(n);\n\n        TreeSet<Integer> ts = new TreeSet<Integer>();\n        for (Integer i: a) {\n            if (ts.isEmpty()) {\n                ts.add(i);\n            }\n            else {\n                Integer next = ts.ceiling(i+1);    \n                if (next != null) ts.remove(next);\n                ts.add(i);\n            }    \n        }\n            \n        out.println(ts.size());\n    }\n}\n\nclass Parser\n{\n    private BufferedReader din;\n    private StringTokenizer tokenizer;\n\n    public Parser(InputStream in)\n    {\n        din = new BufferedReader(new InputStreamReader(in));\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(din.readLine());\n            } catch (Exception e) {\n                throw new UnknownError();\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt()\n    {\n        return Integer.parseInt(next());\n    }\n\n    public int[] readIntArray(int n)\n    {\n        int[] ret = new int[n];\n        for (int i = 0; i < n; i++) ret[i] = nextInt();\n        return ret;\n    }\n\n    }\n\nclass OutputWriter extends PrintWriter {\n    public OutputWriter(Writer out) {\n        super(out);\n    }\n\n    public OutputWriter(OutputStream out) {\n        super(out);\n    }\n\n    }\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, N;\nint bit[100009], ar[1000009];\nvoid update(int idx, int val) {\n  while (idx <= n) {\n    bit[idx] = max(bit[idx], val);\n    idx += (idx & -idx);\n  }\n}\nint query(int index) {\n  int ans = 0;\n  while (index > 0) {\n    ans = max(ans, bit[index]);\n    index -= index & (-index);\n  }\n  return ans;\n}\nint main() {\n  cin >> n;\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    int a;\n    cin >> a;\n    int temp = query(a);\n    temp++;\n    ans = max(ans, temp);\n    update(a, temp);\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N;\nint A[100002], D[100002];\nint result;\nint AIB[100002];\nvoid update(int pos, int val) {\n  for (; pos <= 100000; pos += pos & -pos) AIB[pos] = max(AIB[pos], val);\n}\nint query(int pos) {\n  int resnow = 0;\n  for (; pos >= 1; pos -= pos & -pos) resnow = max(resnow, AIB[pos]);\n  return resnow;\n}\nint main() {\n  cin >> N;\n  for (int i = 1; i <= N; ++i) cin >> A[i];\n  for (int i = 1; i <= N; ++i) {\n    D[i] = query(A[i] - 1) + 1;\n    update(A[i], D[i]);\n    result = max(result, D[i]);\n  }\n  cout << result << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct _ {\n  ios_base::Init i;\n  _() {\n    cin.sync_with_stdio(0);\n    cin.tie(0);\n  }\n} _;\nset<int> s;\nint main() {\n  int n, a;\n  cin >> n;\n  for (int i = (0); i < ((n)); i++) {\n    cin >> a;\n    pair<typeof(s.begin()), bool> r = s.insert(a);\n    if (r.second) {\n      if (++(r.first) != s.end()) {\n        s.erase(r.first);\n      }\n    }\n  }\n  cout << s.size() << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys,math as mt\nimport heapq as hp\nimport collections as cc\nimport math as mt\nimport itertools as it\ninput=sys.stdin.readline\nI=lambda:list(map(int,input().split()))\ndef CeilIndex(A, l, r, key): \n    while (r - l > 1): \n      \n        m = l + (r - l)//2\n        if (A[m] >= key): \n            r = m \n        else: \n            l = m \n    return r \n   \ndef lis(A, size): \n    tailTable = [0 for i in range(size + 1)] \n    len = 0 \n    tailTable[0] = A[0] \n    len = 1\n    for i in range(1, size): \n      \n        if (A[i] < tailTable[0]): \n            tailTable[0] = A[i] \n   \n        elif (A[i] > tailTable[len-1]): \n            tailTable[len] = A[i] \n            len+= 1\n   \n        else: \n            tailTable[CeilIndex(tailTable, -1, len-1, A[i])] = A[i] \n    return len\nn,=I()\nl=I()\nprint(lis(l,n))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> Q;\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    int a;\n    cin >> a;\n    int pos = upper_bound(Q.begin(), Q.end(), a) - Q.begin();\n    if (pos == Q.size())\n      Q.push_back(a);\n    else\n      Q[pos] = a;\n  }\n  printf(\"%d\\n\", (int)Q.size());\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author vadimmm\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskD solver = new TaskD();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskD {\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int n = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++)\n            a[i] = in.nextInt();\n        int[] d = new int[n + 1];\n        d[0] = Integer.MIN_VALUE;\n        for (int i = 1; i <= n; i++)\n            d[i] = Integer.MAX_VALUE;\n        for (int i = 0; i < n; i++) {\n            int j = -1 - Arrays.binarySearch(d, a[i]);\n            if (d[j - 1] < a[i] && a[i] < d[j])\n                d[j] = a[i];\n        }\n        for (int i = n; i >= 0; i--)\n            if (d[i] != Integer.MAX_VALUE) {\n                out.println(i);\n                return;\n            }\n    }\n}\n\nclass InputReader {\n\n    private static BufferedReader bufferedReader;\n    private static StringTokenizer stringTokenizer;\n\n    public InputReader(InputStream inputStream) {\n        bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n        stringTokenizer = null;\n    }\n\n    public String next() {\n        while(stringTokenizer == null || !stringTokenizer.hasMoreTokens()) {\n            try {\n                stringTokenizer = new StringTokenizer(bufferedReader.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return stringTokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    }\n\n"
        },
        {
            "language": 1,
            "solution": "import sys\n\ndef fd(elem,res):\n    bg=0\n    ed=res+1\n    while bg<ed:\n        md=(bg+ed)/2\n        if elem>d[md]:\n            bg=md+1\n        else:\n            ed=md\n    if elem<d[bg]:\n        d[bg]=elem\n    if bg>=res:\n        res=bg\n    return res\n\nf=sys.stdin\nn=int(f.readline())\ns=map(int,f.readline().split())\nd=[11**5]*10**5\nres=0\nfor elem in s:\n    res=fd(elem,res)\nprint res+1\n\n\n    \n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint d[100005];\nint find(int l, int r, int x) {\n  if (l == r) return l;\n  int mid = (l + r) >> 1;\n  if (d[mid] > x)\n    return find(l, mid, x);\n  else\n    return find(mid + 1, r, x);\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  d[0] = -1;\n  int temp = 0;\n  for (int i = 1; i <= n; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    if (x >= d[temp])\n      d[++temp] = x;\n    else\n      d[find(1, temp, x)] = x;\n  }\n  printf(\"%d\\n\", temp);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst int mod = 1e9 + 7;\nconst int N = 1e6 + 10;\nint n, m;\nint a[N], b[N];\nint LIS() {\n  int len = 1;\n  b[1] = a[1];\n  for (int i = 2; i <= n; ++i) {\n    if (a[i] > b[len])\n      b[++len] = a[i];\n    else {\n      int j = lower_bound(b + 1, b + 1 + len, a[i]) - b;\n      b[j] = a[i];\n    }\n  }\n  return len;\n}\nint main(void) {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n;\n  for (int i = 1; i <= n; ++i) cin >> a[i];\n  cout << LIS() << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> d, a;\nint n, t;\nint main() {\n  cin >> n;\n  while (n--) cin >> t, a.push_back(t);\n  for (auto i : a)\n    if (lower_bound(d.begin(), d.end(), i) == d.end())\n      d.push_back(i);\n    else\n      *lower_bound(d.begin(), d.end(), i) = i;\n  cout << d.size();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint arr[100100], N;\nint solve() {\n  vector<int> v;\n  for (int i = 0; i < N; i++) {\n    vector<int>::iterator it = upper_bound(v.begin(), v.end(), arr[i]);\n    if (it == v.end())\n      v.push_back(arr[i]);\n    else\n      *it = arr[i];\n  }\n  return v.size();\n}\nint main() {\n  cin >> N;\n  for (int i = 0; i < N; i++) cin >> arr[i];\n  cout << solve() << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, p;\nint arr[100010];\nint lis[100010];\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i];\n    lis[i] = n + 1;\n  }\n  for (int i = 0; i < n; i++) {\n    int idx = lower_bound(lis, lis + p + 1, arr[i]) - lis;\n    lis[idx] = arr[i];\n    if (idx == p) p++;\n  }\n  cout << p << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class B {\n\n    final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer tok = new StringTokenizer(\"\");\n\n\tfinal static int INF = 1000*1000*1000;\n\n    void solve() throws IOException {\n\t\tint n = readInt();\n\t\tInteger[] a = new Integer[n];\n\t\tint[] index = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\ta[i] = readInt()-1;\n\t\t}\n\t\tint[] d = new int[n+1];\n\t\td[0] = -INF;\n\t\tfor(int i = 1; i < n+1; i++) {\n\t\t\td[i] = INF;\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint cur = a[i];\n\t\t\tint j = Arrays.binarySearch(d, a[i]+1);\n\t\t\tif(j < 0) {\n\t\t\t\tj = -j-1;\n\t\t\t}\n\t\t\tif (d[j-1] < a[i] && a[i] < d[j])\n\t\t\t\td[j] = a[i];\n\t\t}\n\t\tint res = 0;\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\tif(d[i] < n) {\n\t\t\t\tres = i;\n\t\t\t}\n\t\t}\n\t\tout.println(res);\n\t}\n\n    void init() throws FileNotFoundException {\n        if (ONLINE_JUDGE) {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        } else {\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new PrintWriter(\"output.txt\");\n        }\n    }\n\n    String readString() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n\n    int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n\n    long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n\n    double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n\n    int[] readArr(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = readInt();\n        }\n        return res;\n    }\n\n    long[] readArrL(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = readLong();\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        new B().run();\n    }\n\n    public void run() {\n        try {\n            long t1 = System.currentTimeMillis();\n            init();\n            solve();\n            out.close();\n            long t2 = System.currentTimeMillis();\n            System.err.println(\"Time = \" + (t2 - t1));\n        } catch (Exception e) {\n            e.printStackTrace(System.err);\n            System.exit(-1);\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100009], g[100009], d[100009];\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n  for (int i = 1; i <= n; i++) g[i] = 0x7fffffff;\n  for (int i = 0; i < n; i++) {\n    int k = lower_bound(g + 1, g + n + 1, a[i]) - g;\n    d[i] = k;\n    g[k] = a[i];\n  }\n  int ans = 0;\n  for (int i = 0; i < n; i++) ans = max(ans, d[i]);\n  printf(\"%d\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst long long INFLL = 0x3f3f3f3f3f3f3f3fLL;\ninline long long read() {\n  long long x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return x * f;\n}\nconst int maxn = 1e5 + 10;\nint n, dp[maxn], a[maxn];\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  int ans = 0;\n  memset(dp, INF, sizeof(dp));\n  for (int i = 0; i < n; i++) {\n    int pos = lower_bound(dp, dp + n, a[i]) - dp;\n    dp[pos] = a[i];\n    ans = max(ans, pos + 1);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wall\"\n#pragma GCC diagnostic ignored \"-Wextra\"\n#pragma GCC diagnostic ignored \"-Wconversion\"\nusing namespace std;\nconst int N = 1005, OO = 0x3f3f3f3f;\nint arr[100001], n, idx;\nvector<int> lis;\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) scanf(\"%d\", arr + i);\n  lis.push_back(arr[0]);\n  for (int i = 1; i < n; i++) {\n    idx = lower_bound(lis.begin(), lis.end(), arr[i]) - lis.begin();\n    if (idx == lis.size())\n      lis.push_back(arr[i]);\n    else\n      lis[idx] = arr[i];\n  }\n  printf(\"%d\", lis.size());\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint inp[100002];\nint res[100002];\nint dp[100002];\nint dpn;\nint min(int a, int b) { return (a < b) ? a : b; }\nint max(int a, int b) { return (a > b) ? a : b; }\nint main() {\n  int n, i, s, e, m, r = 0;\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", inp + i);\n  }\n  res[0] = 1;\n  dp[0] = inp[0];\n  dpn = 0;\n  for (i = 1; i < n; i++) {\n    if (inp[i] < dp[0]) {\n      dp[0] = inp[i];\n      res[i] = 1;\n    } else if (inp[i] > dp[dpn]) {\n      dpn++;\n      dp[dpn] = inp[i];\n      res[i] = dpn + 1;\n    } else {\n      s = 0;\n      e = dpn + 1;\n      while (e - s > 1) {\n        m = (s + e) / 2;\n        (dp[m] < inp[i]) ? s = m : e = m;\n      }\n      res[i] = s + 2;\n      dp[s + 1] = min(dp[s + 1], inp[i]);\n    }\n  }\n  for (i = 0; i < n; i++) {\n    r = max(r, res[i]);\n  }\n  printf(\"%d\", r);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tSolver solver = new Solver();\n\t\tsolver.solve(in, out);\n\t\tout.close();\n\t}\n}\n\nclass Solver {\n\tpublic void solve(InputReader in, PrintWriter out) {\n\t\tint n = in.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = in.nextInt();\n\t\t}\n\t\tint[] m = new int[n + 1];\n\t\tArrays.fill(m, n + 1);\n\t\tm[0] = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint l = 0;\n\t\t\tint r = n + 1;\n\t\t\twhile (l < r - 1) {\n\t\t\t\tint mid = (l + r) / 2;\n\t\t\t\tif (m[mid] < a[i]) {\n\t\t\t\t\tl = mid;\n\t\t\t\t} else {\n\t\t\t\t\tr = mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tm[l + 1] = Math.min(m[l + 1], a[i]);\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n + 1; i++) {\n\t\t\tif (m[i] < n + 1)\n\t\t\t\tans = i;\n\t\t}\n\t\tout.println(ans);\n\t}\n}\n\nclass InputReader {\n\tprivate BufferedReader reader;\n\tprivate StringTokenizer tokenizer;\n\n\tpublic InputReader(InputStream stream) {\n\t\treader = new BufferedReader(new InputStreamReader(stream));\n\t\ttokenizer = null;\n\t}\n\n\tpublic String next() {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "def CeilIndex(A, l, r, key): \n  \n    while (r - l > 1): \n      \n        m = l + (r - l)//2\n        if (A[m] >= key): \n            r = m \n        else: \n            l = m \n    return r \n   \ndef LongestIncreasingSubsequenceLength(A, size): \n  \n    # Add boundary case, \n    # when array size is one \n   \n    tailTable = [0 for i in range(size + 1)] \n    len = 0 # always points empty slot \n   \n    tailTable[0] = A[0] \n    len = 1\n    for i in range(1, size): \n      \n        if (A[i] < tailTable[0]): \n  \n            # new smallest value \n            tailTable[0] = A[i] \n   \n        elif (A[i] > tailTable[len-1]): \n  \n            # A[i] wants to extend \n            # largest subsequence \n            tailTable[len] = A[i] \n            len+= 1\n   \n        else: \n            # A[i] wants to be current \n            # end candidate of an existing \n            # subsequence. It will replace \n            # ceil value in tailTable \n            tailTable[CeilIndex(tailTable, -1, len-1, A[i])] = A[i] \n          \n   \n    return len\nN = int(input())\nList = [int(x) for x in input().split()]\n\nprint(LongestIncreasingSubsequenceLength(List,N))\n"
        },
        {
            "language": 3,
            "solution": "\"\"\" Python 3 compatibility tools. \"\"\"\nfrom __future__ import division, print_function\nimport itertools\nimport sys\nimport os\nfrom io import BytesIO, IOBase\n\n\nif sys.version_info[0] < 3:\n  input = raw_input\n  range = xrange\n\n  filter = itertools.ifilter\n  map = itertools.imap\n  zip = itertools.izip\n\n\ndef is_it_local():\n  script_dir = str(os.getcwd()).split('/')\n  username = \"dipta007\"\n  return username in script_dir\n\n\ndef READ(fileName):\n  if is_it_local():\n    sys.stdin = open(f'./{fileName}', 'r')\n\n# region fastio\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n  newlines = 0\n\n  def __init__(self, file):\n    self._fd = file.fileno()\n    self.buffer = BytesIO()\n    self.writable = \"x\" in file.mode or \"r\" not in file.mode\n    self.write = self.buffer.write if self.writable else None\n\n  def read(self):\n    while True:\n      b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n      if not b:\n          break\n      ptr = self.buffer.tell()\n      self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n    self.newlines = 0\n    return self.buffer.read()\n\n  def readline(self):\n    while self.newlines == 0:\n      b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n      self.newlines = b.count(b\"\\n\") + (not b)\n      ptr = self.buffer.tell()\n      self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n    self.newlines -= 1\n    return self.buffer.readline()\n\n  def flush(self):\n    if self.writable:\n      os.write(self._fd, self.buffer.getvalue())\n      self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n  def __init__(self, file):\n    self.buffer = FastIO(file)\n    self.flush = self.buffer.flush\n    self.writable = self.buffer.writable\n    self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n    self.read = lambda: self.buffer.read().decode(\"ascii\")\n    self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nif not is_it_local():\n  sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n  input = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\n\ndef input1(type=int):\n  return type(input())\n\n\ndef input2(type=int):\n  [a, b] = list(map(type, input().split()))\n  return a, b\n\n\ndef input3(type=int):\n  [a, b, c] = list(map(type, input().split()))\n  return a, b, c\n\n\ndef input_array(type=int):\n  return list(map(type, input().split()))\n\n\ndef input_string():\n  s = input()\n  return list(s)\n\n##############################################################\n\n#Given a list of numbers of length n, this routine extracts a\n#longest increasing subsequence.\n#\n#Running time: O(n log n)\n#\n#  INPUT: a vector of integers\n#  OUTPUT: a vector containing the longest increasing subsequence\n\ndef lower_bound(nums, target):\n    l, r = 0, len(nums) - 1\n    res = len(nums)\n    while l <= r:\n        mid = int(l + (r - l) / 2)\n        if nums[mid] >= target:\n            res = mid\n            r = mid - 1\n        else:\n            l = mid + 1\n    return res\n    \n    \ndef upper_bound(nums, target):\n    l, r = 0, len(nums) - 1\n    res = len(nums)\n    while l <= r:\n        mid = int(l + (r - l) / 2)\n        if nums[mid] > target:\n            r = mid - 1\n            res = mid\n        else:\n            l = mid + 1\n    return res\n\ndef LIS(v, STRICTLY_INCREASING = False):\n  best = []\n  dad = [-1 for _ in range(len(v))]\n\n  for i in range(len(v)):\n    if STRICTLY_INCREASING:\n      item = (v[i], 0)\n      pos = lower_bound(best, item)\n      item.second = i\n    else:\n      item = (v[i], i)\n      pos = upper_bound(best, item)\n\n    if pos == len(best):\n      dad[i] = -1 if len(best) == 0 else best[-1][1]\n      best.append(item)\n    else:\n      dad[i] = -1 if pos == 0 else best[pos-1][1]\n      best[pos] = item\n    # print(pos, best)\n\n  # ret = []\n  i = best[-1][1]\n  cnt = 0\n  while i >= 0:\n    # ret.append(v[i])\n    cnt += 1\n    i = dad[i]\n\n  # ret.reverse()\n  return cnt\n\ndef main():\n  n = input1()\n  v = input_array()\n  print(LIS(v))\n  pass\n\nif __name__ == '__main__':\n  READ('in.txt')\n  main()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1 << 30;\nconst long long INF = (long long)1 << 62;\nconst int mod = 1e9 + 7;\nconst int maxn = 1e6 + 5;\nint n, a[maxn];\nvector<int> v;\nint main() {\n  ios_base::sync_with_stdio(0), cin.tie(0);\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  v.push_back(a[0]);\n  for (int i = 1; i < n; i++) {\n    auto t = lower_bound(v.begin(), v.end(), a[i]);\n    int it = t - v.begin();\n    if (it == ((int)(v).size()))\n      v.push_back(a[i]);\n    else if (a[i] < v[it])\n      v[it] = a[i];\n  }\n  cout << ((int)(v).size()) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100010;\nconst int maxm = 310;\nconst int N = 20010;\nconst int INF = 0x3f3f3f3f;\nconst int mod = 1000000007;\nint n, m;\nint a[maxn];\nint dp[maxn];\nint d[maxn];\nint sc(int x, int right) {\n  int left = 1;\n  int mid;\n  int ret = 0;\n  while (left <= right) {\n    mid = (left + right) >> 1;\n    if (x > d[mid]) {\n      ret = mid;\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n  return ret;\n}\nint main() {\n  int i, j;\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  d[1] = a[1];\n  int len = 1;\n  for (i = 2; i <= n; i++) {\n    int x;\n    if (d[len] < a[i]) {\n      x = ++len;\n    } else {\n      x = sc(a[i], len) + 1;\n    }\n    d[x] = a[i];\n  }\n  printf(\"%d\\n\", len);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = (int)1e6;\nint a[maxn], T[maxn * 2], dp[maxn];\nint n;\nint findMax(int l, int r) {\n  l += n - 1;\n  r += n - 1;\n  int res = 0;\n  while (l <= r) {\n    if (l & 1) res = max(res, T[l]);\n    if (!(r & 1)) res = max(res, T[r]);\n    l = (l + 1) >> 1;\n    r = (r - 1) >> 1;\n  }\n  return res;\n}\nvoid update(int v, int x) {\n  v += n - 1;\n  T[v] = max(T[v], x);\n  while (v > 1) {\n    v >>= 1;\n    T[v] = max(T[v + v], T[v + v + 1]);\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) scanf(\"%d\", &a[i]);\n  int ans = 0;\n  for (int i = 0; i < n; ++i) {\n    dp[i] = findMax(1, a[i] - 1) + 1;\n    update(a[i], dp[i]);\n    ans = max(ans, dp[i]);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int in() {\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\nconst int N = 1e5 + 10;\nconst int MOD = 1e9 + 7;\nconst long double eps = 1e-12;\nint n, d[N], a[N], mp[N], dp[N], fen[N], ans;\nvoid upd(int ind, int val) {\n  while (ind < N) fen[ind] = max(fen[ind], val), ind += ind & -ind;\n}\nint get(int ind) {\n  int ret = 0;\n  while (ind > 0) ret = max(ret, fen[ind]), ind -= ind & -ind;\n  return ret;\n}\nint main() {\n  n = in();\n  for (int i = 0; i < n; i++) a[i] = in(), mp[i] = a[i];\n  sort(mp, mp + n);\n  for (int i = 0; i < n; i++) a[i] = lower_bound(mp, mp + n, a[i]) - mp + 1;\n  dp[0] = 1;\n  d[a[0]] = 1;\n  upd(a[0], 1);\n  for (int i = 1; i < n; i++) {\n    int x = a[i];\n    dp[i] = get(x) + 1;\n    upd(x, dp[i]);\n    ans = max(ans, dp[i]);\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint BIT[10000001];\nint A[10000001], maxVal = 10000001;\nint query(int x) {\n  int ans = 0;\n  while (x > 0) {\n    ans = max(ans, BIT[x]);\n    x -= (x & -x);\n  }\n  return ans;\n}\nvoid update(int x, int value) {\n  while (x <= maxVal) {\n    BIT[x] = max(BIT[x], value);\n    x += (x & -x);\n  }\n}\nint main() {\n  int N;\n  cin >> N;\n  for (int i = 0; i < N; ++i) {\n    cin >> A[i];\n  }\n  int ans = 0;\n  for (int i = 0; i < N; i++) {\n    int temp = query(A[i]);\n    ans = max(ans, temp + 1);\n    update(A[i], temp + 1);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "/**\n * DA-IICT\n * Author : PARTH PATEL\n */\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.fill;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.sort;\nimport static java.util.Collections.sort;\n\n\npublic class D340 \n{\n\n\tpublic static int mod = 1000000007;\n\tstatic FasterScanner in = new FasterScanner();\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic int n;\n\tstatic int[] arr;\n\tstatic int[] tree;\n\tstatic int[] d;\n\tpublic static void update(int node,int start,int end,int index,int val)\n\t{\n\t\tif(start==end)\n\t\t{\n\t\t\ttree[node]=val;\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\tint mid=(start+end)/2;\n\t\tif(index>=start && index<=mid)\n\t\t{\n\t\t\tupdate(2*node, start, mid, index, val);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tupdate(2*node+1, mid+1, end, index, val);\n\t\t}\n\t\ttree[node]=max(tree[2*node], tree[2*node+1]);\n\t\t}\n\t}\n\tpublic static int query(int node,int start,int end,int l,int r)\n\t{\n\t\tif(r<start || end<l )\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tif(start>=l && r>=end)\n\t\t{\n\t\t\treturn tree[node];\n\t\t}\n\t\tint mid=(start+end)/2;\n\t\tint p1=query(2*node, start, mid, l, r);\n\t\tint p2=query(2*node+1, mid+1, end, l, r);\n\t\treturn max(p1, p2);\n\t\t\n\t}\n\tpublic static void main(String[] args) \n\t{\n\n\t\tn=in.nextInt();\n\t\tarr=new int[n];\n\t\ttree=new int[4*n+1];\n\t\td=new int[n+1];\n\t\tint answer=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tarr[i]=in.nextInt();\n\t\t\td[arr[i]]=query(1, 0, n-1, 1, arr[i]-1)+1;\n\t\t\tupdate(1, 0, n-1, arr[i], d[arr[i]]);\n\t\t\tanswer=max(answer, d[arr[i]]);\n\t\t}\n\t\tout.println(answer);\n\t\t\n\t\tout.close();\n\n\t}\n\t\n\n\t\n\t\n\tpublic static long pow(long x, long n, long mod) \n\t{\n\t\tlong res = 1;\n\t\tfor (long p = x; n > 0; n >>= 1, p = (p * p) % mod) \n\t\t{\n\t\t\tif ((n & 1) != 0) \n\t\t\t{\n\t\t\t\tres = (res * p % mod);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static long gcd(long n1, long n2) \n\t{\n\t\tlong r;\n\t\twhile (n2 != 0) \n\t\t{\n\t\t\tr = n1 % n2;\n\t\t\tn1 = n2;\n\t\t\tn2 = r;\n\t\t}\n\t\treturn n1;\n\t}\n\n\tpublic static long lcm(long n1, long n2) \n\t{\n\t\tlong answer = (n1 * n2) / (gcd(n1, n2));\n\t\treturn answer;\n\t}\n\n\tstatic class FasterScanner \n\t{\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int snumChars;\n\n\t\tpublic int read() \n\t\t{\n\t\t\tif (snumChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= snumChars) \n\t\t\t{\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry \n\t\t\t\t{\n\t\t\t\t\tsnumChars = System.in.read(buf);\n\t\t\t\t} catch (IOException e) \n\t\t\t\t{\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic String nextLine() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo \n\t\t\t{\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextString() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo \n\t\t\t{\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic long nextLong() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') \n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo \n\t\t\t{\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} \n\t\t\twhile (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic int nextInt() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') \n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo \n\t\t\t{\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} \n\t\t\twhile (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) \n\t\t{\n\t\t\tint[] arr = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) \n\t\t\t{\n\t\t\t\tarr[i] = nextInt();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) \n\t\t{\n\t\t\tlong[] arr = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tarr[i] = nextLong();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) \n\t\t{\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tprivate boolean isEndOfLine(int c) \n\t\t{\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint A[100005];\nset<int> st;\nint main() {\n  int i, ans, n;\n  while (scanf(\"%d\", &n) != EOF) {\n    st.clear();\n    set<int>::iterator it;\n    for (i = 1; i <= n; i++) {\n      scanf(\"%d\", &A[i]);\n      if (st.size()) {\n        it = st.lower_bound(A[i]);\n        if (it != st.end()) {\n          st.erase(it);\n        }\n      }\n      st.insert(A[i]);\n    }\n    printf(\"%d\\n\", st.size());\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\npublic class D340 {\n      static class dat implements Comparable<dat>{\n\tpublic int x;\n\tpublic int y;\n\t @Override\n\t public int compareTo(dat other){\n\t     return this.x-other.x;\n\t }\n     }\n    public static int[] res= new int[100010];\n    public static int n;\n    public static int get(int x){\n\tint temp=0;\n\twhile (x>0){\n\t    temp=Math.max(temp,res[x]);\n\t    x-=x&-x;\n\t}\n\treturn temp;\n    }\n    public static void update(int x,int y){\n\twhile (x<=n){\n\t    res[x]=Math.max(res[x],y);\n\t    x+=x&-x;\n\t}\n    }\n    public static void main(String[] agrs) {\n\tScanner f = new Scanner(System.in);\n\tn=f.nextInt();\n\tdat[] a = new dat[n];\n\tfor(int i=0;i<n;i++){\n\t    int u=f.nextInt();\n\t    a[i]=new dat();\n\t    a[i].x=u;\n\t    a[i].y=i+1;\n\n\t}\n\tArrays.sort(a);\n\tint ans=0;\n\tfor(int i=0;i<n;i++){\n\t    int temp=get(a[i].y)+1;\n\t    ans=Math.max(ans,temp);\n\t    update(a[i].y,temp);\n\t}\n\tSystem.out.println(ans);\n}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 200000 + 10;\nint n, a[maxn], dp[maxn];\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  dp[0] = 0;\n  for (int i = 1; i <= n; i++) dp[i] = 2 * n;\n  for (int i = 1; i <= n; i++) {\n    int p = upper_bound(dp, dp + 1 + n, a[i]) - dp;\n    dp[p] = a[i];\n  }\n  int len = 0;\n  for (int i = 1; i <= n; i++)\n    if (dp[i] <= n)\n      len++;\n    else\n      break;\n  printf(\"%d\\n\", len);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nconst long long inf = LLONG_MAX;\nconst long long N = 1e5 + 10;\nlong long CeilIndex(std::vector<long long> &v, long long l, long long r,\n                    long long key);\nlong long LongestIncreasingSubsequenceLength(std::vector<long long> &v);\nint main() {\n  ios_base ::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long n;\n  cin >> n;\n  vector<long long> a(n);\n  for (long long i = 0; i < n; cin >> a[i++])\n    ;\n  cout << LongestIncreasingSubsequenceLength(a) << endl;\n  return 0;\n}\nlong long CeilIndex(std::vector<long long> &v, long long l, long long r,\n                    long long key) {\n  while (r - l > 1) {\n    long long m = l + (r - l) / 2;\n    if (v[m] >= key)\n      r = m;\n    else\n      l = m;\n  }\n  return r;\n}\nlong long LongestIncreasingSubsequenceLength(std::vector<long long> &v) {\n  if (v.size() == 0) return 0;\n  std::vector<long long> tail(v.size(), 0);\n  long long length = 1;\n  tail[0] = v[0];\n  for (long long i = 1; i < v.size(); i++) {\n    if (v[i] < tail[0])\n      tail[0] = v[i];\n    else if (v[i] > tail[length - 1])\n      tail[length++] = v[i];\n    else\n      tail[CeilIndex(tail, -1, length - 1, v[i])] = v[i];\n  }\n  return length;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10;\nconst int inf = 1e9 + 10;\nint a[N], dp[N];\nbool isVal(int x, int y) { return (y < dp[x]); }\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> a[n - i];\n  fill(dp, dp + N, -inf);\n  dp[0] = 0;\n  dp[1] = a[1];\n  for (int i = 2; i <= n; i++) {\n    int l = 0, r = n + 1;\n    while (r - l > 1) {\n      int mid = (l + r) / 2;\n      if (isVal(mid, a[i]))\n        l = mid;\n      else\n        r = mid;\n    }\n    dp[l + 1] = a[i];\n  }\n  int ans = 1;\n  for (int i = 1; i <= n; i++)\n    if (dp[i] != -inf) ans = i;\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint a[100001];\nint A[100001];\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = int(0); i < int(n); i++) scanf(\"%d\", a + i);\n  vector<int> A(n, 12345678);\n  vector<int> id(n);\n  for (int i = int(0); i < int(n); i++) {\n    id[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n    A[id[i]] = a[i];\n  }\n  cout << *max_element(id.begin(), id.end()) + 1 << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid find_lis(vector<int> &a, vector<int> &b) {\n  vector<int> p(a.size());\n  int u, v;\n  if (a.empty()) return;\n  b.push_back(0);\n  for (size_t i = 1; i < a.size(); i++) {\n    if (a[b.back()] < a[i]) {\n      p[i] = b.back();\n      b.push_back(i);\n      continue;\n    }\n    for (u = 0, v = b.size() - 1; u < v;) {\n      int c = (u + v) / 2;\n      if (a[b[c]] < a[i])\n        u = c + 1;\n      else\n        v = c;\n    }\n    if (a[i] < a[b[u]]) {\n      if (u > 0) p[i] = b[u - 1];\n      b[u] = i;\n    }\n  }\n  for (u = b.size(), v = b.back(); u--; v = p[v]) b[u] = v;\n}\nint a[100010];\nint main() {\n  ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0), cerr << \"\";\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  vector<int> seq(a, a + sizeof(a) / sizeof(a[0]));\n  vector<int> lis;\n  find_lis(seq, lis);\n  cout << lis.size();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100010, INF = ~0U >> 2;\nint n, A[MAXN], D[MAXN], res;\nvoid init() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) scanf(\"%d\", &A[i]);\n}\nvoid solve() {\n  D[0] = -INF;\n  int l, r, mid, x;\n  res = 0;\n  for (int i = 0; i < n; i++) {\n    x = A[i];\n    if (x > D[res])\n      D[++res] = x;\n    else {\n      l = 0;\n      r = res;\n      while (l < r) {\n        mid = l + r + 1 >> 1;\n        if (x > D[mid])\n          l = mid;\n        else\n          r = mid - 1;\n      }\n      D[l + 1] = x;\n    }\n  }\n}\nvoid pri() { printf(\"%d\\n\", res); }\nint main() {\n  init();\n  solve();\n  pri();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100005;\nint tree[4 * MAXN];\nvoid build_tree(int v, int tl, int tr) {\n  if (tl == tr) {\n    tree[v] = 0;\n    return;\n  }\n  int mid = (tl + tr) / 2;\n  build_tree(2 * v, tl, mid);\n  build_tree(2 * v + 1, mid + 1, tr);\n  tree[v] = 0;\n}\nint get_max_tree(int v, int tl, int tr, int l, int r) {\n  if (tl > r || tr < l) return 0;\n  l = max(tl, l);\n  r = min(tr, r);\n  if (tl == l && tr == r) return tree[v];\n  int mid = (tl + tr) / 2;\n  return max(get_max_tree(2 * v, tl, mid, l, r),\n             get_max_tree(2 * v + 1, mid + 1, tr, l, r));\n}\nvoid modify(int v, int tl, int tr, int pos, int val) {\n  if (tl == tr) {\n    tree[v] = val;\n    return;\n  }\n  int mid = (tl + tr) / 2;\n  if (pos <= mid)\n    modify(2 * v, tl, mid, pos, val);\n  else\n    modify(2 * v + 1, mid + 1, tr, pos, val);\n  tree[v] = max(tree[2 * v], tree[2 * v + 1]);\n}\nint main(void) {\n  int N, a;\n  cin >> N;\n  build_tree(1, 1, N);\n  for (int i = 1; i <= N; i++) {\n    cin >> a;\n    int best = max(1, get_max_tree(1, 1, N, 1, a) + 1);\n    modify(1, 1, N, a, best);\n  }\n  cout << get_max_tree(1, 1, N, 1, N) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:134217728\")\nusing namespace std;\nint n, a[110000];\nvector<int> d;\nint main() {\n  cin >> n;\n  d.push_back(-1000000007);\n  for (int i = (1); i < (n + 2); ++i) d.push_back(1000000007);\n  for (int i = (0); i < (n); ++i) scanf(\"%d\", &a[i]);\n  int j;\n  for (int i = (0); i < (n); ++i) {\n    j = (upper_bound(d.begin(), d.end(), a[i]) - d.begin());\n    if (d[j - 1] < a[i] && a[i] < d[j]) d[j] = a[i];\n  }\n  j = 0;\n  while (d[j + 1] != 1000000007) j++;\n  cout << j << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MX = 300000;\nint n, arr[MX], bit[MX], ans = 0, lis;\nvoid update(int x, int V) {\n  while (x <= n) {\n    bit[x] = max(bit[x], V);\n    x += x & -x;\n  }\n}\nint get(int x) {\n  int ret = 0;\n  while (x > 0) {\n    ret = max(ret, bit[x]);\n    x -= x & -x;\n  }\n  return ret;\n}\nint main() {\n  scanf(\"%d\", &n);\n  memset(bit, 0, sizeof(bit));\n  for (int j = 1; j <= n; j++) {\n    scanf(\"%d\", &arr[j]);\n    lis = get(arr[j]) + 1;\n    update(arr[j] + 1, lis);\n    ans = max(ans, lis);\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\n\n\npublic class LongestIncreasingSub {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader r=new BufferedReader(new InputStreamReader(System.in));\n        int n=Integer.parseInt(r.readLine());\n        StringTokenizer  in =new StringTokenizer(r.readLine());\n        int a[]=new int[n];\n        for(int i=0;i<n;i++){\n            a[i]=Integer.parseInt(in.nextToken());\n        }\n        \n        \n        int t[]=new int[n];\n        int len=0;\n        for(int i=1;i<n;i++){\n            if(a[i]>a[t[len]]){\n                len++;\n                t[len]=i;\n            }else if(a[i]<a[t[0]]){\n                t[0]=i;\n            }else{\n                t[binary(t,a,len,a[i])]=i;\n            }\n        }\n        System.out.println(len+1);\n        \n    }\n    public static int binary(int t[],int a[],int l,int k){\n        int f=0;\n        int med;\n        int ans=-1;\n        while(f<=l){\n            med=(f+l)/2;\n            if(a[t[med]]>k){\n                ans=med;\n                l=med-1;\n            }else{\n                f=med+1;\n            }\n        }\n        return ans;\n    }\n    \n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nvector<int> a;\nint ft[1000000];\nint get_max(int pos) {\n  if (pos == 0) return 0;\n  return max(ft[pos], get_max(pos - (pos & (-pos))));\n}\nvoid upt_max(int pos, int val) {\n  if (pos >= 1000000) return;\n  ft[pos] = max(ft[pos], val);\n  upt_max(pos + (pos & (-pos)), val);\n}\nint ans;\nint main() {\n  cin >> n;\n  a.resize(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n  }\n  for (int i = 0; i < a.size(); ++i) {\n    int t = get_max(a[i] - 1) + 1;\n    ans = max(ans, t);\n    upt_max(a[i], t);\n  }\n  cout << ans << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, A[123457], T[4 * 123457];\nint res;\nint sum(int x) {\n  int ans = 0;\n  while (x > 0) {\n    ans = ans > T[x] ? ans : T[x];\n    x -= (x & -x);\n  }\n  return ans;\n}\nvoid up(int x, int val) {\n  while (x <= n) {\n    T[x] = max(T[x], val);\n    x += (x & -x);\n  }\n}\nint main() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    cin >> A[i];\n  }\n  up(A[1], 1);\n  for (int i = 2; i <= n; i++) {\n    int a = sum(A[i]);\n    up(A[i], a + 1);\n    res = res > a + 1 ? res : a + 1;\n  }\n  cout << res;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000007;\nint n, a[100005], h[100005];\nint main() {\n  int ans = 0;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", a + i);\n    h[i + 1] = INF;\n    int lo = 0, hi = i;\n    while (lo < hi) {\n      int m = (lo + hi + 1) / 2;\n      if (a[i] > h[m])\n        lo = m;\n      else\n        hi = m - 1;\n    }\n    ans = max(ans, ++lo);\n    h[lo] = a[i];\n  }\n  printf(\"%d\\n\", ans);\n  if (0) {\n    int b[10];\n    for (int i = 0; i < n; i++) a[i] = i;\n    do {\n      set<int> e[200];\n      for (int i = 0; i < n; i++) b[i] = a[i];\n      bool ok = true;\n      while (ok) {\n        ok = false;\n        for (int i = 1; i < n; i++) {\n          if (b[i - 1] > b[i]) {\n            ok = true;\n            e[b[i - 1]].insert(b[i]);\n            e[b[i]].insert(b[i - 1]);\n            swap(b[i - 1], b[i]);\n          }\n        }\n      }\n      int mask = (1 << n) - 1, ans = 0, tag = 0;\n      for (int s = 0; s <= mask; s++) {\n        ok = true;\n        int cnt = __builtin_popcount(s);\n        if (cnt <= ans) continue;\n        for (int i = 0; i < n; i++)\n          if (s & 1 << i)\n            for (int j = 0; j < i; j++)\n              if (s & 1 << j)\n                if (e[i].count(j) || e[j].count(i)) i = j = n, ok = false;\n        if (ok) {\n          ans = cnt;\n          tag = s;\n        }\n      }\n      printf(\"result = %d for list\", ans);\n      for (int i = 0; i < n; i++) printf(\" %d\", a[i]);\n      printf(\", set =\");\n      for (int i = 0; i < n; i++)\n        if (tag & 1 << i) printf(\" %d\", i);\n      puts(\"\");\n    } while (next_permutation(a, a + n));\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint INP, AM, REACHEOF;\nconst int BUFSIZE = (1 << 12) + 17;\nchar BUF[BUFSIZE + 1], *inp = BUF;\nconst int MN = 100111;\nint n, a[MN], f[MN], bit[MN];\nint get(int u) {\n  int res = 0;\n  for (int x = u; x > 0; x -= ((x) & (-(x)))) res = max(res, bit[x]);\n  return res;\n}\nvoid update(int u, int k) {\n  for (int x = u; x <= n; x += ((x) & (-(x)))) bit[x] = max(bit[x], k);\n}\nint main() {\n  ios ::sync_with_stdio(false);\n  while (cin >> n) {\n    for (int i = (1), _b = (n); i <= _b; i++) cin >> a[i];\n    memset(bit, 0, sizeof bit);\n    int res = 0;\n    for (int i = (1), _b = (n); i <= _b; i++) {\n      f[i] = get(a[i]) + 1;\n      update(a[i], f[i]);\n      res = max(res, f[i]);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nconst double eps = 1e-9;\nconst double PI = atan(1.0);\nconst int N = 100001;\nint n;\nint tree[N * 4];\nint query(int node, int l, int r, int ll, int rr) {\n  if (l > rr || r < ll || r < l || rr < ll) return 0;\n  if (l >= ll && r <= rr) return tree[node];\n  int mid = (l + r) >> 1;\n  int n1 = query(node << 1, l, mid, ll, rr);\n  int n2 = query(node << 1 | 1, mid + 1, r, ll, rr);\n  return max(n1, n2);\n}\nvoid insert(int node, int l, int r, int idx) {\n  if (l == r) {\n    tree[node] = query(1, 1, n, 1, idx - 1) + 1;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  if (idx <= mid)\n    insert(node << 1, l, mid, idx);\n  else\n    insert(node << 1 | 1, mid + 1, r, idx);\n  tree[node] = max(tree[node << 1], tree[node << 1 | 1]);\n}\nint main() {\n  ios::sync_with_stdio(0);\n  ;\n  cin >> n;\n  memset(tree, 0, sizeof(tree));\n  for (int i = 1; i <= n; i++) {\n    int num;\n    cin >> num;\n    insert(1, 1, n, num);\n  }\n  cout << tree[1];\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) cin >> a[i];\n  vector<int> d(n + 1, 1e9);\n  d[0] = 0;\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    int l = 0, r = n;\n    while (l < r - 1) {\n      int c = (l + r) / 2;\n      if (d[c] < a[i])\n        l = c;\n      else\n        r = c;\n    }\n    d[l + 1] = a[i];\n    ans = max(ans, l + 1);\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class CO_340D\n{\n\tstatic int imax=Integer.MAX_VALUE,imin=Integer.MIN_VALUE;\n\tstatic long lmax=Long.MAX_VALUE,lmin=Long.MIN_VALUE;\n\tstatic long mod=(long)1e9+7;\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\n\t//\tScanner scan=new Scanner(System.in);\n\t\tInputReader in =new InputReader(System.in);\n\t\tPrintWriter out=new PrintWriter(System.out);\n//\t\tint t=in.nextInt();\n \t\tint t=1;\n\t\twhile(t-->0){\n\t\t\tint i=0,j=0;\t\n\t\t\tint n=in.nextInt();\n\t\t\tint arr[]=new int[n];\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tarr[i]=in.nextInt();\n\t\t\t}\n\t\t\tint dp[]=new int[n];\n\t\t\tint len=1;\n\t\t\tdp[0]=0;\n\t\t\tfor(i=1;i<n;i++){\n\t\t\t\tif(arr[i]>arr[dp[len-1]]){\n\t\t\t\t\tdp[len]=i;\n\t\t\t\t\tlen++;\n\t\t\t\t}else if(arr[i]<arr[dp[0]]){\n\t\t\t\t\tdp[0]=i;\n\t\t\t\t}else{\n\t\t\t\t\tdp[bi_search(arr,dp,arr[i],0,len-1)]=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(len);\n\t\t}\n\tout.close();\n\t}\n\tstatic int bi_search(int arr[],int dp[],int x,int l,int r){\n\t\t\n\t\twhile(l<r){\n\t\t\tint mid=(l+r)/2;\n\t\t\tif(arr[dp[mid]]>x){\n\t\t\t\tr=mid;\n\t\t\t}else{\n\t\t\t\tl=mid+1;\n\t\t\t}\n\t\t}\n\t\treturn l;\n\t}\n\tstatic void print(int arr[],int len){\n\t\tfor(int i=0;i<len;i++)\n\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\tstatic class InputReader\n\t{\n\t \n\t    private InputStream stream;\n\t    private byte[] buf = new byte[1024];\n\t    private int curChar;\n\t    private int numChars;\n\t \n\t    public InputReader(InputStream stream) {\n\t        this.stream = stream;\n\t    }\n\t \n\t    public int read() {\n\t        if (numChars == -1)\n\t            throw new InputMismatchException();\n\t        if (curChar >= numChars) {\n\t            curChar = 0;\n\t            try {\n\t                numChars = stream.read(buf);\n\t            } catch (IOException e) {\n\t                throw new InputMismatchException();\n\t            }\n\t            if (numChars <= 0)\n\t                return -1;\n\t        }\n\t        return buf[curChar++];\n\t    }\n\t \n\t    public int nextInt() {\n\t        int c = read();\n\t        while (isSpaceChar(c))\n\t            c = read();\n\t        int sgn = 1;\n\t        if (c == '-') {\n\t            sgn = -1;\n\t            c = read();\n\t        }\n\t        int res = 0;\n\t        do {\n\t            if (c < '0' || c > '9')\n\t                throw new InputMismatchException();\n\t            res *= 10;\n\t            res += c & 15;\n\t            c = read();\n\t        } while (!isSpaceChar(c));\n\t        return res * sgn;\n\t    }\n\t \n\t    public long nextLong() {\n\t        int c = read();\n\t        while (isSpaceChar(c))\n\t            c = read();\n\t        int sgn = 1;\n\t        if (c == '-') {\n\t            sgn = -1;\n\t            c = read();\n\t        }\n\t        long res = 0;\n\t        do {\n\t            if (c < '0' || c > '9')\n\t                throw new InputMismatchException();\n\t            res *= 10;\n\t            res += c & 15;\n\t            c = read();\n\t        } while (!isSpaceChar(c));\n\t        return res * sgn;\n\t    }\n\t \n\t    public String next() {\n\t        int c = read();\n\t        while (isSpaceChar(c))\n\t            c = read();\n\t        StringBuilder res = new StringBuilder();\n\t        do {\n\t            res.appendCodePoint(c);\n\t            c = read();\n\t        } while (!isSpaceChar(c));\n\t        return res.toString();\n\t    }\n\t \n\t    public String nextLine() {\n\t        int c = read();\n\t        //while (c != '\\n' && c != '\\r' && c != '\\t' && c != -1)\n\t        //c = read();\n\t        StringBuilder res = new StringBuilder();\n\t        do {\n\t            res.appendCodePoint(c);\n\t            c = read();\n\t        } while (c != '\\n' && c != '\\r' && c != '\\t' && c != -1);\n\t        return res.toString();\n\t    }\n\t \n\t    public static boolean isSpaceChar(int c) {\n\t        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t    }\n\t \n\t}   \n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint ceilElement(int a[], int start, int end, int key) {\n  while (end - start > 1) {\n    int mid = start + (end - start) / 2;\n    if (a[mid] >= key) {\n      end = mid;\n    } else {\n      start = mid;\n    }\n  }\n  return end;\n}\nint longestIncreasingSubsequence(int input[], int size) {\n  if (!size) return 0;\n  int a[size];\n  int length = 1;\n  a[0] = input[0];\n  for (int i = 1; i < size; i++) {\n    if (input[i] < a[0]) {\n      a[0] = input[i];\n    } else if (input[i] > a[length - 1]) {\n      a[length++] = input[i];\n    } else\n      a[ceilElement(a, -1, length - 1, input[i])] = input[i];\n  }\n  return length;\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  int a[n];\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  int size = sizeof(a) / sizeof(a[0]);\n  printf(\"%d\", longestIncreasingSubsequence(a, size));\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class BubbleSortGraph {\n\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int count = scanner.nextInt();\n\n        TreeSet<Node> orderedNodeSet = new TreeSet<>(Comparator.comparingInt((Node n) -> n.value).thenComparingInt((Node n) -> n.index));\n        for (int i = 0; i < count; i++) {\n            int value = scanner.nextInt();\n            Node nextNode = new Node(i, value);\n            Node smallerThanNode = orderedNodeSet.floor(nextNode);\n            if (smallerThanNode != null) {\n                nextNode.count = smallerThanNode.count + 1;\n\n                SortedSet<Node> tailSubSet = orderedNodeSet.tailSet(nextNode);\n                Iterator<Node> tailIterator = tailSubSet.iterator();\n                while (tailIterator.hasNext()) {\n                    if (tailIterator.next().count <= nextNode.count) {\n                        tailIterator.remove();\n                    } else {\n                        break;\n                    }\n                }\n            }\n            orderedNodeSet.add(nextNode);\n        }\n        System.out.println(orderedNodeSet.last().count + 1);\n    }\n\n\n    static class Node {\n\n        int index;\n        int value;\n        int count = 0;\n\n        Node(int index, int value) {\n            this.index = index;\n            this.value = value;\n        }\n\n    }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long i, j, n, m, k, x, y, l, r;\nlong long res, ans, cur;\nstring s, q, s1, s2;\nchar ch1, ch2, ch3;\nlong long a[500000], b[500000];\nbool f11[500000], f12[500000];\nbool fix[500000];\nvector<long long> g[500000], c[500000];\nlong long X(long long A, long long B, long long P) {\n  if (!B) return 1;\n  if (B == 1) return (A % P);\n  long long C = X(A, B / 2, P);\n  C *= C;\n  C %= P;\n  if (B % 2) C *= A;\n  return C % P;\n}\nlong long UG(long long A, long long B) {\n  if (A > B) return UG(B, A);\n  if (A == 0) return B;\n  if (A == 1) return 1;\n  return UG(B % A, A);\n}\nlong long UJ(long long A, long long B) {\n  long long C = UG(A, B);\n  A /= C;\n  A *= B;\n  return A;\n}\nlong long d[5000000];\nint main() {\n  cin >> n;\n  for (i = 1; i <= n; i++) cin >> a[i];\n  d[0] = -10;\n  d[1] = a[1];\n  for (i = 2; i <= n; i++) d[i] = 1000000000;\n  for (i = 2; i <= n; i++) {\n    l = 0;\n    r = (i - 1);\n    while (l + 1 < r) {\n      m = (l + r) / 2;\n      if (d[m] < a[i])\n        l = m;\n      else\n        r = m - 1;\n    }\n    if (d[r] < a[i])\n      d[r + 1] = min(d[r + 1], a[i]);\n    else if (d[l] < a[i])\n      d[l + 1] = min(d[l + 1], a[i]);\n  }\n  for (i = n; i >= 1; i--)\n    if (d[i] != 1000000000) break;\n  cout << i << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1000 * 1000;\nlong long a[maxn];\nlong long b[maxn];\nint bs(int from, int to, int m);\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  int last = 1;\n  b[1] = a[1];\n  for (int i = 2; i <= n; i++) {\n    int x = bs(1, last, a[i]);\n    if (x > last) last = x;\n    b[x] = a[i];\n  }\n  cout << last << endl;\n  return 0;\n}\nint bs(int from, int to, int m) {\n  while (to - from + 1 > 4) {\n    if (m > b[(to - from) / 2 + from]) {\n      from = ((to - from) / 2) + 1 + from;\n    } else {\n      to = (to - from) / 2 + from;\n    }\n  }\n  for (int i = from; i <= to; i++) {\n    if (m < b[i]) return i;\n  }\n  return to + 1;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1e16;\nlong long lis(vector<long long> const& a) {\n  long long n = a.size();\n  vector<long long> d(n + 1, INF);\n  d[0] = -INF;\n  for (long long i = 0; i < n; i++) {\n    long long j = upper_bound(d.begin(), d.end(), a[i]) - d.begin();\n    if (d[j - 1] < a[i] && a[i] < d[j]) d[j] = a[i];\n  }\n  long long ans = 0;\n  for (long long i = 0; i <= n; i++)\n    if (d[i] < INF) ans = i;\n  return ans;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long n;\n  cin >> n;\n  vector<long long> vec(n);\n  for (long long i = 0; i < n; i++) cin >> vec[i];\n  cout << lis(vec) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\n\npublic class First {\n\n\tpublic static void main(String[] args) {\n\t\tScanner myScanner = new Scanner(System.in);\n\t\tint n = myScanner.nextInt();\n\t\tint val, pos = -1;\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tval = myScanner.nextInt();\n\t\t\tif(pos == -1 || a[pos] < val){\n\t\t\t\ta[++pos] = val;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint lo = 0, hi = pos;\n\t\t\twhile(lo != hi){\n\t\t\t\tint mid = (lo + hi) / 2;\n\t\t\t\tif(a[mid] < val)\n\t\t\t\t\tlo = mid + 1;\n\t\t\t\telse\n\t\t\t\t\thi = mid;\n\t\t\t}\n\t\t\ta[lo] = val;\n\t\t}\n\t\tSystem.out.println(pos + 1);\n\t\t\t\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n  int ss[100010] = {0}, top = 0;\n  for (int i = 0; i < n; i++) {\n    int in;\n    cin >> in;\n    if (in > ss[top]) {\n      ss[++top] = in;\n    } else {\n      int pos = lower_bound(ss, ss + top + 1, in) - ss;\n      ss[pos] = in;\n    }\n  }\n  cout << top << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 1e5 + 20;\nint a[M], lis[M], sz;\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  for (int i = 0; i < n; i++) {\n    int ind = lower_bound(lis, lis + sz, a[i]) - lis;\n    lis[ind] = a[i];\n    if (ind == sz) sz++;\n  }\n  cout << sz << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst long long infLL = 0x3f3f3f3f3f3f3f3fLL;\nconst int hash_mod = 1000037;\nconst int maxn = 100000 + 5;\nint n;\nint a[maxn], g[maxn];\nint main() {\n  int res = 0;\n  scanf(\"%d\", &n);\n  memset(g, 0x3f, sizeof(g));\n  for (int i = 0; i < n; ++i) {\n    int x;\n    scanf(\"%d\", &x);\n    int k = lower_bound(g + 1, g + n + 1, x) - g;\n    res = max(res, k);\n    g[k] = x;\n  }\n  printf(\"%d\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  int a[n];\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  set<int> s;\n  for (int i = 0; i < n; i++) {\n    set<int>::iterator it;\n    if (s.insert(a[i]).second) {\n      it = s.find(a[i]);\n      it++;\n      if (it != s.end()) {\n        s.erase(*it);\n      }\n    }\n  }\n  cout << s.size() << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid _fill_int(int* p, int val, int rep) {\n  int i;\n  for (i = 0; i < rep; i++) p[i] = val;\n}\nint GETi() {\n  int i;\n  scanf(\"%d\", &i);\n  return i;\n}\ntemplate <class T>\nT sqr(T val) {\n  return val * val;\n}\nint N;\nvector<int> A;\nvoid solve() {\n  int f, r, i, j, k, l, x, y, y2;\n  cin >> N;\n  for (i = 0; i < N; i++) A.push_back(GETi() - 1);\n  vector<int> AA(N, N + 1);\n  vector<int> ID(N);\n  for (i = 0; i < N; i++) {\n    vector<int>::iterator it = lower_bound(AA.begin(), AA.end(), A[i]);\n    ID[i] = distance(AA.begin(), it);\n    AA[ID[i]] = A[i];\n  }\n  printf(\"%d\\n\", 1 + *max_element(ID.begin(), ID.end()));\n  return;\n}\nint main(int argc, char** argv) {\n  if (argc > 1) freopen(argv[1], \"r\", stdin);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 10;\nint a[MAXN];\nvector<int> v;\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  for (int i = 0; i < n; i++) {\n    int l = lower_bound(v.begin(), v.end(), a[i]) - v.begin();\n    if (l == v.size())\n      v.push_back(a[i]);\n    else\n      v[l] = a[i];\n  }\n  cout << v.size() << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nT min(const T& a, const T& b, const T& c) {\n  return min(min(a, b), min(a, c));\n}\ntemplate <class T>\nT max(const T& a, const T& b, const T& c) {\n  return max(max(a, b), max(a, c));\n}\nvoid debug() {}\nint getch() {\n  int ch;\n  while ((ch = getchar()) != EOF) {\n    if (ch != ' ' && ch != ' ') return ch;\n  }\n  return EOF;\n}\nint dp[100100];\nint main() {\n  int n;\n  while (scanf(\"%d\", &n) != EOF) {\n    int maxx = 0;\n    for (int i = 1; i <= n; i++) {\n      int v;\n      scanf(\"%d\", &v);\n      int pos = lower_bound(dp, dp + maxx, v) - dp;\n      if (pos == maxx) {\n        dp[maxx++] = v;\n      } else\n        dp[pos] = v;\n    }\n    printf(\"%d\\n\", maxx);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nclass fenwick_tree {\n private:\n  int N;\n  int* bit;\n\n public:\n  fenwick_tree(int n) {\n    N = n;\n    bit = new int[N + 1];\n    for (int i = 0, _n = (int)N + 1; i < _n; i++) bit[i] = 0;\n  }\n  void update(int x, int v) {\n    for (int i = x; i <= N; i += i & -i) bit[i] = max(bit[i], v);\n  }\n  int query(int x) {\n    int res = 0;\n    for (int i = x; i; i -= i & -i) res = max(res, bit[i]);\n    return res;\n  }\n};\nint N;\nint pos[100005];\nint main() {\n  cin >> N;\n  fenwick_tree ft(N);\n  for (int i = 0, _n = (int)N; i < _n; i++) {\n    int x;\n    cin >> x;\n    pos[x - 1] = i + 1;\n  }\n  int res = 0;\n  for (int i = 0, _n = (int)N; i < _n; i++) {\n    int cur = 1 + ft.query(pos[i]);\n    res = max(res, cur);\n    ft.update(pos[i], cur);\n  }\n  cout << res << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint LIS(const vector<int>& a) {\n  vector<int> v;\n  v.push_back(-1);\n  for (int i = 0; i < a.size(); i++)\n    if (a[i] > v.back())\n      v.push_back(a[i]);\n    else\n      *lower_bound(v.begin(), v.end(), a[i]) = a[i];\n  return (int)v.size() - 1;\n}\nint main() {\n  int a, n;\n  vector<int> v;\n  ios::sync_with_stdio(0);\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> a;\n    v.push_back(a);\n  }\n  cout << LIS(v) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, a[100005], d[100005];\nint f(int s, int q) {\n  int l, r, m, ans;\n  l = 1;\n  r = s;\n  while (l <= r) {\n    m = (l + r) >> 1;\n    if (d[m] > q) {\n      ans = m;\n      r = m - 1;\n    } else {\n      l = m + 1;\n    }\n  }\n  return ans;\n}\nint lis(void) {\n  int ans, i, x;\n  ans = 1;\n  d[1] = a[1];\n  for (i = 2; i <= n; i++) {\n    if (a[i] < d[1])\n      d[1] = a[i];\n    else if (a[i] > d[ans])\n      d[++ans] = a[i];\n    else {\n      x = f(ans, a[i]);\n      d[x] = a[i];\n    }\n  }\n  return ans;\n}\nint main() {\n  int i;\n  cin >> n;\n  for (i = 1; i <= n; i++) cin >> a[i];\n  cout << lis() << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def lis(a):\n\n    b = []\n\n    for c in a:\n\n        # if len(b) == 0 or c > b[-1]\n\n        if len(b) == 0 or c > b[-1]:\n\n            b.append(c)\n\n        else:\n\n            l = 0\n\n            r = len(b)\n\n            while l < r-1:\n\n                m = l+r>>1\n\n                # if b[m] <= c: l = m\n\n                if b[m] < c: l = m\n\n                else: r = m\n\n            # if b[l] <= c: l += 1\n\n            if b[l] < c: l += 1\n\n            b[l] = c\n\n        \n\n    return len(b)\n\n                    \n\n\n\nn = int(input())\n\n\n\na = list(map(int, input().split()))\n\n\n\nprint(lis(a))\n\n\n\n\n\n# Made By Mostafa_Khaled"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nconst int MAXN = 100005;\nint ar[MAXN];\nint bs[MAXN];\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", ar + i);\n  }\n  int best = 1;\n  bs[1] = ar[0];\n  for (int i = 1; i < n; i++) {\n    if (ar[i] > bs[best]) {\n      bs[++best] = ar[i];\n    } else if (ar[i] < bs[1]) {\n      bs[1] = ar[i];\n    } else {\n      int l = 1;\n      int r = best;\n      while (l < r) {\n        int m = (l + r + 1) / 2;\n        if (ar[i] > bs[m])\n          l = m;\n        else\n          r = m - 1;\n      }\n      bs[l + 1] = ar[i];\n    }\n  }\n  printf(\"%d\\n\", best);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Stack;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Random;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.security.SecureRandom;\n\npublic class Main {\n\n    /**\n *\n * @author Toghrul\n */\npublic static class SegmentTreeSum {\n    public int height, maxsize, n;\n    public long T[];\n    public SegmentTreeSum(int[] a) {\n        n = a.length;\n        height = (int)Math.ceil((Math.log(a.length) / Math.log(2)));\n        maxsize = (int)(2 * Math.pow(2, height) - 1);\n        T = new long[maxsize + 1];\n        init(1, a, 0, a.length - 1);\n    }\n    public void init(int x, int[] a, int l, int r) {\n        if(l == r) {\n            T[x] = a[l];\n        }else {\n            int m = (l + r) >> 1;\n            init(x << 1, a, l, m);\n            init(x << 1 | 1, a, m + 1, r);\n            T[x] = T[x << 1] + T[x << 1 | 1];\n        }\n    }\n    public long getSum(int x, int l, int r, int ll, int rr) {\n        if(ll <= l && r <= rr) return T[x];\n        if(r < ll || rr < l) return 0;\n        int m = (l + r) >> 1;\n        return getSum(x << 1, l, m, ll, rr) + getSum(x << 1 | 1, m + 1, r, ll, rr);\n    }\n    public void update(int x, int l, int r, int i, int v) {\n        if(l == r && l == i) {\n            T[x] = v;\n            return;\n        }\n        int m = (l + r) >> 1;\n        if(l <= i && i <= m) update(x << 1, l, m, i, v);\n        else if(m + 1 <= i && i <= r)update(x << 1 | 1, m + 1, r, i, v);\n        T[x] = T[x << 1] + T[x << 1 | 1];\n    }\n    public void update(int i, int v) {\n        update(1, 0, n - 1, i, v);\n    }\n    public long getSum(int l, int r) {\n        return getSum(1, 0, n - 1, l, r);\n    }\n}\npublic static class SegmentTreeMax {\n    public int height, maxsize, n;\n    public long T[];\n    public int[] a;\n    public SegmentTreeMax(int[] a) {\n        this.a=a;\n        n = a.length;\n        height = (int)Math.ceil((Math.log(a.length) / Math.log(2)));\n        maxsize = (int)(2 * Math.pow(2, height) - 1);\n        T = new long[maxsize + 1];\n        init(1, a, 0, a.length - 1);\n    }\n    public void init(int x, int[] a, int l, int r) {\n        if(l == r) {\n            T[x] = l;\n        }else {\n            int m = (l + r) >> 1;\n            init(x << 1, a, l, m);\n            init(x << 1 | 1, a, m + 1, r);\n            long tl=T[x << 1];\n            long tr=T[x<<1|1];\n            if(tl==-1)T[x]= tr;\n            else if(tr==-1)T[x]=tl;\n            else if(a[(int)tl]>a[(int)tr])T[x]=tl;\n            else T[x]=tr;\n            //T[x] = Math.max(T[x << 1], T[x << 1 | 1]);\n        }\n    }\n    public long getMax(int x, int l, int r, int ll, int rr) {\n        if(ll <= l && r <= rr) return T[x];\n        if(r < ll || rr < l) return -1;\n        int m = (l + r) >> 1;\n        long tl=T[x << 1];\n            long tr=T[x<<1|1];\n            if(tl==-1)return tr;\n            else if(tr==-1)return tl;\n            else if(a[(int)tl]>a[(int)tr])return tl;\n            else return tr;\n        //return Math.max(getMax(x << 1, l, m, ll, rr), getMax(x << 1 | 1, m + 1, r, ll, rr));\n    }\n    public void update(int x, int l, int r, int i, int v) {\n        if(l == r && l == i) {\n            T[x] = v;\n            return;\n        }\n        int m = (l + r) >> 1;\n        if(l <= i && i <= m) update(x << 1, l, m, i, v);\n        else if(m + 1 <= i && i <= r)update(x << 1 | 1, m + 1, r, i, v);\n        long tl=T[x << 1];\n            long tr=T[x<<1|1];\n            if(tl==-1)T[x]= tr;\n            else if(tr==-1)T[x]=tl;\n            else if(a[(int)tl]>a[(int)tr])T[x]=tl;\n            else T[x]=tr;\n        //T[x] = Math.max(T[x << 1], T[x << 1 | 1]);\n    }\n    public void update(int i, int v) {\n        update(1, 0, n - 1, i, v);\n    }\n    public long getMax(int l, int r) {\n        return getMax(1, 0, n - 1, l, r);\n    }\n}\n\n    public static void main(String[] args) throws IOException {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        PrintWriter out = new PrintWriter(outputStream);\n        InputReader in = new InputReader(inputStream);\n        \n        int n=in.nextInt();\n        int[] a=in.nextArray(n);\n        \n        int[] T = new int[n+1];\n        int len=1;\n        T[0]=a[0];\n        for(int i=1;i<n;i++){\n            if(a[i]<T[0]) T[0]=a[i];\n            else if(T[len-1]<a[i]) T[len++]=a[i];\n            else {\n                int l=0,r=len-1,m=0,ans=-1;\n                while(l<=r){\n                    m=l+r>>1;\n                    if(T[m]>a[i]){\n                        ans=m; r=m-1;\n                    }else l=m+1;\n                }\n                T[ans]=a[i];\n            }\n        }\n        out.println(len);\n        out.close();\n    }\n\n    static class InputReader {\n\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream inputStream) {\n            reader = new BufferedReader(new InputStreamReader(inputStream), 32624);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException ex) {\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        private long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        private double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public int[] nextArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        public double[] nextArrayd(int n) {\n            double[] a = new double[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextDouble();\n            }\n            return a;\n        }\n\n        private BigInteger nextBigInteger() {\n            return new BigInteger(next());\n        }\n\n        public void printAr(int[] a) {\n            System.out.print(\"[\");\n            for (long x : a) {\n                System.out.print(x + \",\");\n            }\n            System.out.print(\"]\");\n        }\n    }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint ar[1000000 + 100];\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) scanf(\"%d\", &ar[i]);\n  vector<int> v;\n  v.push_back(ar[0]);\n  for (int i = 1; i < n; i++) {\n    auto x = lower_bound(v.begin(), v.end(), ar[i]);\n    if (x == v.end())\n      v.push_back(ar[i]);\n    else\n      *x = ar[i];\n  }\n  cout << v.size();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint idx;\nconst int N = 1e5;\nstack<int> sk[N];\nint a[N];\nint n;\nint FindIndx(int x) {\n  int l = 0, r = idx, m, ans = -1;\n  while (l <= r) {\n    m = (l + r) >> 1;\n    if (sk[m].top() > x) {\n      ans = m;\n      r = m - 1;\n    } else\n      l = m + 1;\n  }\n  return ans;\n}\nvoid FindLIS() {\n  idx = 0;\n  sk[idx].push(a[0]);\n  for (int i = 1; i < n; i++) {\n    int curidx = FindIndx(a[i]);\n    if (curidx == -1) {\n      idx++;\n      sk[idx].push(a[i]);\n    } else {\n      sk[curidx].push(a[i]);\n    }\n  }\n  cout << idx + 1 << \"\\n\";\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  FindLIS();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nconst long long inf = 922337203685477;\nconst long long mininf = -922337203685477;\nconst long long nax = 1e5 + 5;\nlong long n, a[nax], bit[nax];\nlong long sum(long long x) {\n  long long ret = 0;\n  for (long long i = x; i > 0; i -= i & -i) {\n    ret = max(ret, bit[i]);\n  }\n  return ret;\n}\nlong long upd(long long x, long long y) {\n  for (long long i = x; i <= n; i += i & -i) {\n    bit[i] = max(bit[i], y);\n  }\n  return 0;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cin >> n;\n  for (long long i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  long long ans = 0, cnt = 0;\n  for (long long i = 0; i < n; i++) {\n    cnt = sum(a[i] - 1);\n    ans = max(ans, cnt + 1);\n    upd(a[i], cnt + 1);\n  }\n  cout << ans << '\\n';\n}\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class B {\n    private static BufferedReader in;\n    private static StringTokenizer st;\n    private static PrintWriter out;\n    public static void main(String[] args) throws NumberFormatException, IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        st = new StringTokenizer(\"\");\n        out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\t\tint n = nextInt();\n\t\tint a[] = new int[n+1];\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\ta[i] = nextInt();\n\t\tint INF = 1000000000;\n\t\tint d[] = new int[1000000 + 2];\n\t\tArrays.fill(d, INF);\n\t\td[0] = -INF;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint j = Arrays.binarySearch(d, a[i]);\n\t\t\tif(j<0){\n\t\t\tj = Math.abs(j) - 1;\n\t\t\td[j] = a[i];\n\t\t\t}\n\t\t}\n\t\tfor (int i = n; i >= 1; i--) {\n\t\t\tif(d[i]!=INF){\n\t\t\t\tSystem.out.println(i);\n\t\t\t\treturn;\n\t\t\t\t}\n\t\t}\n    }\n    static String next() throws IOException{\n        while(!st.hasMoreTokens()){\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n    static int nextInt() throws NumberFormatException, IOException{\n        return Integer.parseInt(next());\n    }\n    static long nextLong() throws NumberFormatException, IOException{\n        return Long.parseLong(next());\n    }\n    \n    static double nextDouble() throws NumberFormatException, IOException{\n        return Double.parseDouble(next());\n    }\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int maxn = 100010;\nint a[maxn + 1];\nint f[maxn + 1];\nint result;\nint n;\nvoid ins(int x, int v) {\n  while (x <= n) {\n    if (v > f[x]) f[x] = v;\n    x += (x & (x ^ (x - 1)));\n  }\n}\nint ask(int x) {\n  int v = 0;\n  while (x) {\n    if (f[x] > v) v = f[x];\n    x -= (x & (x ^ (x - 1)));\n  }\n  return v;\n}\nvoid init() {\n  int i;\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n}\nvoid work() {\n  int i, j;\n  result = 0;\n  for (i = 1; i <= n; ++i) {\n    j = 1 + ask(a[i] - 1);\n    if (j > result) result = j;\n    ins(a[i], j);\n  }\n}\nvoid output() { printf(\"%d\\n\", result); }\nint main() {\n  init();\n  work();\n  output();\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def lis(a):\n    b = []\n    for c in a:\n        # if len(b) == 0 or c > b[-1]\n        if len(b) == 0 or c > b[-1]:\n            b.append(c)\n        else:\n            l = 0\n            r = len(b)\n            while l < r-1:\n                m = l+r>>1\n                # if b[m] <= c: l = m\n                if b[m] < c: l = m\n                else: r = m\n            # if b[l] <= c: l += 1\n            if b[l] < c: l += 1\n            b[l] = c\n        \n    return len(b)\n                    \n\nn = int(input())\n\na = list(map(int, input().split()))\n\nprint(lis(a))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint in[100005];\nset<pair<int, int> > S;\nset<pair<int, int> >::iterator it;\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) scanf(\"%d\", in + i);\n  S.insert(make_pair(0, 0));\n  for (int i = 0; i < n; ++i) {\n    S.insert(make_pair(in[i], 0));\n    it = S.find(make_pair(in[i], 0));\n    --it;\n    int a = (*it).second;\n    ++a;\n    ++it;\n    S.erase(it);\n    S.insert(make_pair(in[i], a));\n    it = S.find(make_pair(in[i], a));\n    ++it;\n    while (it != S.end()) {\n      if ((*it).second <= a) {\n        S.erase(it);\n        it = S.find(make_pair(in[i], a));\n        ++it;\n        continue;\n      }\n      break;\n    }\n  }\n  int rez = 0;\n  for (it = S.begin(); it != S.end(); ++it) {\n    rez = max(rez, (*it).second);\n  }\n  printf(\"%d\\n\", rez);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nFILE *in;\nFILE *out;\nconst int MAX = 131072;\nconst int TREE = 262144;\nint n;\nint a[MAX];\nint tree[TREE];\nvoid update(int idx, int val) {\n  idx += (TREE >> 1);\n  while (idx) {\n    tree[idx] = max(tree[idx], val);\n    idx >>= 1;\n  }\n}\nint query(int idx) {\n  idx += (TREE >> 1);\n  int ret = tree[idx];\n  bool flag = !(idx & 1);\n  idx >>= 1;\n  while (idx) {\n    if (flag) ret = max(ret, tree[(idx << 1) + 1]);\n    flag = !(idx & 1);\n    idx >>= 1;\n  }\n  return ret;\n}\nint lis() {\n  int ans = 0;\n  for (int i = n - 1; i >= 0; i--) {\n    int cur = query(a[i] + 1) + 1;\n    ans = max(ans, cur);\n    update(a[i], cur);\n  }\n  return ans;\n}\nint main(void) {\n  in = stdin;\n  out = stdout;\n  fscanf(in, \"%d\", &n);\n  for (int i = 0; i < n; i++) fscanf(in, \"%d\", &a[i]);\n  fprintf(out, \"%d\\n\", lis());\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100009];\nint dp[100009];\nint n;\nint binary_sch(int l, int h, int val) {\n  int md;\n  while (l < h) {\n    md = (l + h) / 2;\n    if (dp[md] < val) {\n      l = md + 1;\n    } else\n      h = md;\n  }\n  return h;\n}\nint LIS() {\n  dp[0] = a[0];\n  int len = 1;\n  for (int i = 1; i < n; i++) {\n    if (a[i] < dp[0]) {\n      dp[0] = a[i];\n    } else if (a[i] > dp[len - 1]) {\n      dp[len++] = a[i];\n    } else {\n      int p = binary_sch(0, len - 1, a[i]);\n      dp[p] = a[i];\n    }\n  }\n  return len;\n}\nint main() {\n  cin >> n;\n  for (int i = 0; i <= n - 1; i++) {\n    cin >> a[i];\n  }\n  printf(\"%d\\n\", LIS());\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = in.nextInt();\n            }\n            out.println(longestIncreasingSubsequence(a));\n        }\n\n        int longestIncreasingSubsequence(int[] ary) {\n            int max = 0;\n            int[] m = new int[ary.length + 1];\n            for (int i = 0; i < ary.length; i++) {\n                int lo = 1;\n                int hi = max;\n                while (lo <= hi) {\n                    if (ary[m[(lo + hi) / 2]] < ary[i]) lo = (lo + hi) / 2 + 1;\n                    else hi = (lo + hi) / 2 - 1;\n                }\n                if (lo > max) {\n                    m[lo] = i;\n                    max = lo;\n                } else if (ary[m[lo]] > ary[i])\n                    m[lo] = i;\n            }\n            return max;\n        }\n\n    }\n\n    static class InputReader {\n        private StringTokenizer tokenizer;\n        private BufferedReader reader;\n\n        public InputReader(InputStream inputStream) {\n            reader = new BufferedReader(new InputStreamReader(inputStream));\n        }\n\n        private void fillTokenizer() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n\n        public String next() {\n            fillTokenizer();\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n\npublic class Main\n{\n    public static void main(String args[])throws Exception\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st;\n        int n=Integer.parseInt(br.readLine());\n        st=new StringTokenizer(br.readLine());\n        int arr[]=new int[n];\n        int ans=0;\n        arr[0]=Integer.parseInt(st.nextToken());\n        for(int i=1;i<n;i++)\n        {\n            int temp=Integer.parseInt(st.nextToken());\n            if(temp>arr[ans])\n                arr[++ans]=temp;\n            else arr[-Arrays.binarySearch(arr,0,ans,temp)-1]=temp;\n        }\n        System.out.print(ans+1);\n        br.close();\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Main\n{\n    static class Reader \n    { \n        private InputStream mIs;private byte[] buf = new byte[1024];private int curChar,numChars;public Reader() { this(System.in); }public Reader(InputStream is) { mIs = is;} \n        public int read() {if (numChars == -1) throw new InputMismatchException();if (curChar >= numChars) {curChar = 0;try { numChars = mIs.read(buf);} catch (IOException e) { throw new InputMismatchException();}if (numChars <= 0) return -1; }return buf[curChar++];} \n        public String nextLine(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isEndOfLine(c));return res.toString() ;} \n        public String s(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isSpaceChar(c));return res.toString();} \n        public long l(){int c = read();while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }long res = 0; do{ if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read();}while(!isSpaceChar(c));return res * sgn;} \n        public int i(){int c = read() ;while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }int res = 0;do{if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read() ;}while(!isSpaceChar(c));return res * sgn;} \n        public double d() throws IOException {return Double.parseDouble(s()) ;}\n        public boolean isSpaceChar(int c) { return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1; } \n        public boolean isEndOfLine(int c) { return c == '\\n' || c == '\\r' || c == -1; } \n        public int[] arr(int n){int[] ret = new int[n];for (int i = 0; i < n; i++) {ret[i] = i();}return ret;}\n    }\n    \n    \n \n           //       |----|       /\\      |    |   -----   |\n           //       |   /       /  \\     |    |     |     |\n           //       |--/       /----\\    |----|     |     |\n           //       |   \\     /      \\   |    |     |     |\n           //       |    \\   /        \\  |    |   -----   -------\n\n    static int n;\n    static int tree[] = new int[10000008];\n    static int max(int i)\n    {\n        int max = 0; \n        while(i>0)\n        {\n            max = Math.max(max,tree[i]);\n            i-= i&(-i);\n        }\n        return max;\n    }\n \n    public static void update(int n, int i, int val)\n    {\n        while(i<=n)\n        {\n           tree[i] =Math.max(tree[i],val);\n           i+= i&(-i);\n        }\n    }\n    public static void main(String[] args)throws IOException\n    {\n        PrintWriter out= new PrintWriter(System.out);\n        Reader sc=new Reader();\n        n=sc.i();\n        int arr[]=sc.arr(n);\n        int max=0;\n        for(int i=0;i<n;i++)\n        {\n            int val=arr[i];\n            int get=max(val-1);\n            update(10000008,val,get+1);\n            max=Math.max(max,get+1);\n        }\n        out.println(max);\n        out.flush();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e18;\nconst string nl = \"\\n\";\nint32_t main() {\n  ios::sync_with_stdio(0);\n  cin.tie(nullptr);\n  long long n;\n  cin >> n;\n  vector<long long> a(n);\n  for (auto& i : a) {\n    cin >> i;\n  }\n  vector<long long> dp;\n  for (long long i = 0; i < n; ++i) {\n    auto it = lower_bound(dp.begin(), dp.end(), a[i]);\n    if (it == dp.end()) {\n      dp.push_back(a[i]);\n    } else {\n      *it = a[i];\n    }\n  }\n  cout << ((long long)(dp).size()) << nl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nT min(T a, T b, T c) {\n  return min(a, min(b, c));\n}\ntemplate <typename T>\nT max(T a, T b, T c) {\n  return max(a, max(b, c));\n}\ntemplate <typename T>\nT max(T a, T b, T c, T d) {\n  return max(a, max(b, max(c, d)));\n}\ntemplate <typename T>\nvoid read(vector<T> &arr, long long N) {\n  arr.clear();\n  arr.resize(N);\n  for (long long i = 0; i < N; i++) cin >> arr[i];\n}\ntemplate <typename T>\nvoid read(vector<pair<T, T>> &arr, long long N) {\n  arr.clear();\n  arr.resize(N);\n  for (long long i = 0; i < (long long)arr.size(); i++)\n    cin >> arr[i].first >> arr[i].second;\n}\ntemplate <typename T>\nvoid read(vector<vector<T>> &arr, long long N, long long M) {\n  arr.clear();\n  arr.resize(N, vector<T>(M));\n  for (long long i = 0; i < N; i++) {\n    for (long long j = 0; j < M; j++) cin >> arr[i][j];\n  }\n}\ntemplate <typename T, size_t N>\nlong long SIZE(const T (&t)[N]) {\n  return N;\n}\ntemplate <typename T>\nlong long SIZE(const T &t) {\n  return t.size();\n}\nstring to_string(const string s, long long x1 = 0, long long x2 = 1e9) {\n  return '\"' + ((x1 < s.size()) ? s.substr(x1, x2 - x1 + 1) : \"\") + '\"';\n}\nstring to_string(const char *s) { return to_string((string)s); }\nstring to_string(const bool b) { return (b ? \"true\" : \"false\"); }\nstring to_string(const char c) { return string({c}); }\ntemplate <size_t N>\nstring to_string(const bitset<N> &b, long long x1 = 0, long long x2 = 1e9) {\n  string t = \"\";\n  for (long long __iii__ = min(x1, SIZE(b)), __jjj__ = min(x2, SIZE(b) - 1);\n       __iii__ <= __jjj__; ++__iii__) {\n    t += b[__iii__] + '0';\n  }\n  return '\"' + t + '\"';\n}\ntemplate <typename A, typename... C>\nstring to_string(const A(&v), long long x1 = 0, long long x2 = 1e9,\n                 C... coords);\nlong long l_v_l_v_l = 0, t_a_b_s = 0;\ntemplate <typename A, typename B>\nstring to_string(const pair<A, B> &p) {\n  l_v_l_v_l++;\n  string res = \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n  l_v_l_v_l--;\n  return res;\n}\ntemplate <typename A, typename... C>\nstring to_string(const A(&v), long long x1, long long x2, C... coords) {\n  long long rnk = rank<A>::value;\n  string tab(t_a_b_s, ' ');\n  string res = \"\";\n  bool first = true;\n  if (l_v_l_v_l == 0) res += '\\n';\n  res += tab + \"[\";\n  x1 = min(x1, SIZE(v)), x2 = min(x2, SIZE(v));\n  auto l = begin(v);\n  advance(l, x1);\n  auto r = l;\n  advance(r, (x2 - x1) + (x2 < SIZE(v)));\n  for (auto e = l; e != r; e = next(e)) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    l_v_l_v_l++;\n    if (e != l) {\n      if (rnk > 1) {\n        res += '\\n';\n        t_a_b_s = l_v_l_v_l;\n      };\n    } else {\n      t_a_b_s = 0;\n    }\n    res += to_string(*e, coords...);\n    l_v_l_v_l--;\n  }\n  res += \"]\";\n  if (l_v_l_v_l == 0) res += '\\n';\n  return res;\n}\nvoid printm() { ; }\ntemplate <typename Heads, typename... Tails>\nvoid printm(Heads H, Tails... T) {\n  cout << to_string(H) << \" | \";\n  printm(T...);\n}\nbool lexi(string &s1, string &s2) {\n  long long I = s1.size(), J = s2.size(), i = 0, j = 0;\n  while (i < I and j < J) {\n    if (s1[i] > s2[j]) return true;\n    if (s1[i] < s2[j]) return false;\n    i++;\n    j++;\n  }\n  if (I >= J) return true;\n  return false;\n}\nstruct uf {\n  vector<long long> par, size;\n  void init(long long N) {\n    par.resize(N, -1);\n    size.resize(N, 1);\n  }\n  long long root(long long a) {\n    if (par[a] == -1) return a;\n    return par[a] = root(par[a]);\n  }\n  void unite(long long a, long long b) {\n    a = root(a);\n    b = root(b);\n    if (a == b) return;\n    if (size[a] < size[b]) {\n      par[a] = b;\n      size[b] += size[a];\n    } else {\n      par[b] = a;\n      size[a] += size[b];\n    }\n  }\n  bool same(long long a, long long b) {\n    if (root(a) == root(b)) return true;\n    return false;\n  }\n};\nstruct seg_tree {\n  vector<long long> make;\n  long long siz;\n  vector<long long> arr;\n  void init(vector<long long> &a, bool max, bool range) {\n    arr.clear();\n    make.clear();\n    arr = a;\n    siz = arr.size();\n    make.resize(4 * siz);\n    if (max)\n      build_max(0, 0, siz - 1);\n    else if (range)\n      build_range(0, 0, siz - 1);\n  }\n  long long get_max(long long L, long long R) {\n    return Get_max(0, 0, siz - 1, L, R);\n  }\n  void update_max(long long index, long long val) {\n    Update_max(0, 0, siz - 1, index, val);\n    return;\n  }\n  long long get_sum(long long L, long long R) {\n    return Get_sum(0, 0, siz - 1, L, R);\n  }\n  void update_range(long long index, long long add) {\n    Update_range(0, 0, siz - 1, index, add);\n    return;\n  }\n  long long build_range(long long ind, long long L, long long R) {\n    if (L == R) {\n      make[ind] = arr[L];\n      return make[ind];\n    } else {\n      long long mid = (L + R) / 2;\n      long long a = build_range(2 * ind + 1, L, mid);\n      long long b = build_range(2 * ind + 2, mid + 1, R);\n      make[ind] = a + b;\n      return make[ind];\n    }\n  }\n  long long Get_sum(long long ind, long long L, long long R, long long Left,\n                    long long Right) {\n    if (L > Right or R < Left) return 0;\n    if (Left <= L and R <= Right) return make[ind];\n    long long mid = (L + R) / 2;\n    long long a = Get_sum(2 * ind + 1, L, mid, Left, Right);\n    long long b = Get_sum(2 * ind + 2, mid + 1, R, Left, Right);\n    return a + b;\n  }\n  void Update_range(long long ind, long long L, long long R, long long index,\n                    long long add) {\n    if (L == R) {\n      make[ind] = add;\n      arr[index] = add;\n    } else {\n      long long mid = (L + R) / 2;\n      if (L <= index and index <= R) {\n        Update_range(2 * ind + 1, L, mid, index, add);\n      } else {\n        Update_range(2 * ind + 2, mid + 1, R, index, add);\n      }\n      make[ind] = make[2 * ind + 1] + make[2 * ind + 2];\n    }\n  }\n  long long build_max(long long ind, long long L, long long R) {\n    if (L == R) {\n      make[ind] = arr[L];\n      return make[ind];\n    } else {\n      long long mid = (L + R) / 2;\n      return make[ind] = max(build_max(2 * ind + 1, L, mid),\n                             build_max(2 * ind + 2, mid + 1, R));\n    }\n  }\n  long long Get_max(long long ind, long long L, long long R, long long Left,\n                    long long Right) {\n    if (R < Left or L > Right) return -1e15;\n    if (Left <= L and R <= Right) return make[ind];\n    long long mid = (L + R) / 2;\n    return max(Get_max(2 * ind + 1, L, mid, Left, Right),\n               Get_max(2 * ind + 2, mid + 1, R, Left, Right));\n  }\n  long long Update_max(long long ind, long long L, long long R, long long index,\n                       long long val) {\n    if (L == R) {\n      arr[index] = val;\n      make[ind] = val;\n      return val;\n    } else {\n      long long mid = (L + R) / 2;\n      if (L <= index and index <= mid) {\n        make[ind] = Update_max(2 * ind + 1, L, mid, index, val);\n      } else {\n        make[ind] = Update_max(2 * ind + 2, mid + 1, R, index, val);\n      }\n      make[ind] = max(make[2 * ind + 1], make[2 * ind + 2]);\n      return make[ind];\n    }\n  }\n};\nstatic bool comp(pair<long long, long long> &a, pair<long long, long long> &b) {\n  if (a.first < b.first) return true;\n  if (a.first == b.first) {\n    if (a.second < b.second) return true;\n  }\n  return false;\n}\nstatic bool comp1(vector<long long> &a, vector<long long> &b) {\n  if (a[0] < b[0]) return true;\n  if (a[0] == b[0] and a[1] > b[1]) return true;\n  return false;\n}\nlong long Max = 1e17, Min = -1e15;\nlong long N, M, K, D;\nlong long mod = 1e9;\nlong long P = 93;\nvoid solve() {\n  cin >> N;\n  vector<long long> arr(N);\n  for (long long i = 0; i < N; i++) {\n    cin >> arr[i];\n    --arr[i];\n  }\n  vector<long long> cnt(N);\n  seg_tree var;\n  var.init(cnt, true, false);\n  for (long long i = 0; i < N; i++) {\n    long long val = var.get_max(0, arr[i]) + 1;\n    var.update_max(arr[i], val);\n  }\n  long long ans = 0;\n  for (auto it : var.arr) {\n    ans = max(ans, it);\n  }\n  cout << ans << '\\n';\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  auto start_time = chrono::high_resolution_clock::now();\n  bool test = 0;\n  if (!test)\n    solve();\n  else {\n    long long tt;\n    cin >> tt;\n    while (tt--) solve();\n  }\n  auto end_time = chrono::high_resolution_clock::now();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int ri() {\n  register char c;\n  while (1) {\n    c = getchar();\n    if (c >= '0' && c <= '9') break;\n  }\n  register int x = 0;\n  while (1) {\n    x = x * 10 + c - 48;\n    c = getchar();\n    if (c < '0' || c > '9') return x;\n  }\n}\nint n, x[100010];\nvector<vector<int>> s;\nvector<int> cur;\nint main() {\n  n = ri();\n  for (int i = 0; i < n; i++) x[i] = ri();\n  for (int i = 0; i < n; i++) {\n    auto j = lower_bound(cur.begin(), cur.end(), x[i]) - cur.begin();\n    if (j == cur.size()) {\n      s.push_back({});\n      cur.push_back({});\n    } else if (cur[j] == x[i])\n      continue;\n    s[j].push_back(x[i]);\n    cur[j] = x[i];\n  }\n  cout << s.size() << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "n=input()\ns=map(int,raw_input().split())\nd=[9**9]*(n+1)\nd[0]=-d[0]\nfrom bisect import * \nfor a in s:\n    j=bisect(d,a)\n    if a > d[j-1] and a < d[j]:\n        d[j]=a\nprint bisect(d,n)-1"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint N, l, r, now;\nint a[100010];\nint main() {\n  scanf(\"%d\", &N);\n  a[0] = 10000000;\n  now = 0;\n  for (int i = 0, c; i < N; i++) {\n    scanf(\"%d\", &c);\n    l = 0;\n    r = now;\n    while (l < r) {\n      int mid = (l + r) >> 1;\n      if (c >= a[mid])\n        l = mid + 1;\n      else\n        r = mid;\n    }\n    if (a[l] <= c) l++;\n    a[l] = c;\n    if (l > now) now = l;\n  }\n  printf(\"%d\\n\", now + 1);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint seq[100010];\nint main() {\n  int n;\n  while (scanf(\"%d\", &n) > 0) {\n    int L = 0;\n    for (int i = 1; i <= n; i++) {\n      int a;\n      scanf(\"%d\", &a);\n      if (L == 0 or seq[L - 1] < a) {\n        seq[L++] = a;\n        continue;\n      }\n      int lo = 0, up = L - 1, j;\n      while (lo <= up) {\n        int mid = (lo + up) >> 1;\n        if (seq[mid] < a) {\n          lo = mid + 1;\n        } else {\n          up = mid - 1;\n          j = mid;\n        }\n      }\n      seq[j] = a;\n    }\n    printf(\"%d\\n\", L);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100005;\nint a[maxn];\nint g[maxn];\nint d[maxn];\nint main(int argc, char *argv[]) {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  for (int i = 1; i <= n; ++i) g[i] = 1000000000;\n  for (int i = 0; i < n; ++i) {\n    int k = lower_bound(g + 1, g + n + 1, a[i]) - g;\n    d[i] = k;\n    g[k] = a[i];\n  }\n  int ans = 1;\n  for (int i = 0; i < n; i++) ans = max(ans, d[i]);\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.lang.*;\n\npublic class Main {\n\n\t\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t\n\t\tint n = sc.nextInt();\n\t\t\n\t\tint arr[] = new int[n+1];\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tarr[i] = sc.nextInt();\n\t\t}\n\t\t\n\t\tboolean swaped = true;\n\t\tint count = 0;\n//\t\twhile(swaped != false){\n//\t\t\tswaped = false;\n//\t\t\tfor(int i = 0; i < n - 1; i++){\n//\t\t\t\tif(arr[i] > arr[i + 1]){\n//\t\t\t\t\tint temp = arr[i];\n//\t\t\t\t\tarr[i] = arr[i + 1];\n//\t\t\t\t\tarr[i + 1] = temp;\n//\t\t\t\t\tswaped = true;\n//\t\t\t\t\tcount++;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n\t\t\n\t\tint dp[] = new int[n + 4];\n\t\tint m = 0;\n\t\tdp[0] = -1000;\n\t\t\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tint x = arr[i];\n\t\t\tif(x > dp[m]){\n\t\t\t\tdp[++m]=x;\n\t\t\t}else{\n\t\t\t\tint l = 1;\n\t\t\t\tint r = m;\n\t\t\t\t// binary search\n\t\t\t\twhile(l < r){\n\t\t\t\t\tint k = (l + r) / 2;\n\t\t\t\t\tif(dp[k] <= x)\n\t\t\t\t\t\tl = k + 1;\n\t\t\t\t\telse\n\t\t\t\t\t\tr = k;\n\t\t\t\t}\n\t\t\t\tdp[l] = x;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(m);\n\t\tsc.close();\n\n\t}\n\n\t\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint CeilIndex(std::vector<int> &v, int l, int r, int key) {\n  while (r - l > 1) {\n    int m = l + (r - l) / 2;\n    if (v[m] >= key)\n      r = m;\n    else\n      l = m;\n  }\n  return r;\n}\nint LongestIncreasingSubsequenceLength(std::vector<int> &v) {\n  if (v.size() == 0) return 0;\n  std::vector<int> tail(v.size(), 0);\n  int length = 1;\n  tail[0] = v[0];\n  for (size_t i = 1; i < v.size(); i++) {\n    if (v[i] < tail[0])\n      tail[0] = v[i];\n    else if (v[i] > tail[length - 1])\n      tail[length++] = v[i];\n    else\n      tail[CeilIndex(tail, -1, length - 1, v[i])] = v[i];\n  }\n  return length;\n}\nint main() {\n  std::vector<int> v;\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; ++i) {\n    int x;\n    cin >> x;\n    v.push_back(x);\n  }\n  std::cout << LongestIncreasingSubsequenceLength(v) << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = int(1e9 + 7);\nconst double PI = acos(-1.0);\nint n, i, j, d[100010], a[100010];\nint main() {\n  cin >> n;\n  for (i = 0; i < n; i++) cin >> a[i];\n  d[0] = -1000000000;\n  for (i = 1; i <= n; i++) d[i] = 1000000000;\n  for (i = 0; i < n; i++) {\n    j = (int)(upper_bound(d, d + n, a[i]) - d);\n    if (d[j - 1] < a[i] && d[j] > a[i]) d[j] = a[i];\n  }\n  for (i = 1; i <= n; i++)\n    if (d[i] == 1000000000) break;\n  cout << i - 1;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1e9;\nint a[1000000];\nint n;\nint dp[1000000];\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  for (int i = 0; i <= n; i++) {\n    dp[i] = inf;\n  }\n  for (int i = 0; i < n; i++) {\n    int k = upper_bound(dp, dp + n + 1, a[i]) - dp;\n    dp[k] = a[i];\n  }\n  int ans = 0;\n  for (int i = 0; i <= n; i++) {\n    if (dp[i] != inf) {\n      ans = i + 1;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int max_n = 100 * 1000 + 10;\nint a[max_n];\nvector<int> lis;\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  for (int i = 0; i < n; i++) {\n    int pos = lower_bound(lis.begin(), lis.end(), a[i]) - lis.begin();\n    if (pos == lis.size())\n      lis.push_back(a[i]);\n    else\n      lis[pos] = a[i];\n  }\n  cout << lis.size() << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, ans = 1, now = 1, INF = (int)1e9;\n  cin >> n;\n  vector<int> A(n), D((int)1e7, INF);\n  for (int i = 0; i < n; i++) cin >> A[i];\n  D[0] = -INF;\n  for (int i = 0; i < n; i++) {\n    int j = int(upper_bound(D.begin(), D.end(), A[i]) - D.begin());\n    if (D[j - 1] < A[i] && A[i] < D[j]) D[j] = A[i];\n  }\n  for (int i = 1; i < (int)1e7; ans = (D[i] != INF ? i : ans), i++)\n    ;\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class B {\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\tboolean eof;\n\n\tstatic int get(int[] fen, int x) {\n\t\tint ret = 0;\n\t\twhile (x >= 0) {\n\t\t\tret += fen[x];\n\t\t\tx = (x & (x + 1)) - 1;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic void add(int[] fen, int pos) {\n\t\tfor (int i = pos; i < fen.length; i |= i + 1) {\n\t\t\tfen[i]++;\n\t\t}\n\t}\n\n\tvoid solve() throws IOException {\n\t\tint n = nextInt();\n\t\tint ans = 0;\n\t\tint[] d = new int[n + 1];\n\t\tArrays.fill(d, INF);\n\t\td[0] = -INF;\n\n\t\tfor (int i = 0; i < n; i++) {\n\n\t\t\t//System.err.println(Arrays.toString(d));\n\n\t\t\tint x = nextInt();\n\t\t\tint low = 0;\n\t\t\tint high = ans + 1;\n\t\t\twhile (low + 1 < high) {\n\t\t\t\tint mid = (low + high) >> 1;\n\t\t\t\tif (d[mid] < x) {\n\t\t\t\t\tlow = mid;\n\t\t\t\t} else {\n\t\t\t\t\thigh = mid;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\td[high] = x;\n\n\t\t\tif (high > ans)\n\t\t\t\tans = high;\n\n\t\t}\n\n\t\tout.println(ans);\n\t}\n\n\tstatic int INF = Integer.MAX_VALUE / 2;\n\n\tB() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew B();\n\t}\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e) {\n\t\t\t\teof = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\teof = true;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class D_BubbleSortGraph {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader inp = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n        solver.solve(inp, out);\n        out.close();\n    }\n\n    private static class Solver {\n        private static int LIS(int[] x, int n) {\n            int L = 0;\n            int[] m = new int[n+1];\n            for (int i = 0; i < n; i++) {\n                int l = 1, h = L;\n                while (l <= h) {\n                    int mid = l + ((h - l) >> 1);\n                    mid += (l ^ h) & 1;\n                    if (x[m[mid]] < x[i]) l = mid + 1;\n                    else h = mid - 1;\n                }\n                int newL = l;\n                m[newL] = i;\n                if (newL > L) L = newL;\n            }\n            return L;\n        }\n\n        private void solve(InputReader inp, PrintWriter out) {\n            int n = inp.nextInt();\n            int[] w = new int[n];\n            for (int i = 0; i < n; i++) w[i] = inp.nextInt();\n            out.println(LIS(w, w.length));\n        }\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}\n"
        },
        {
            "language": 1,
            "solution": "def lis(a, n):\n\tf = [0] * (n + 1);\n\tl = 0;\n\tfor i in range(n):\n\t\tlow = 1;\n\t\thigh = l;\n\t\twhile (low <= high):\n\t\t\tmid = (low + high) / 2;\n\t\t\tif (a[i] > f[mid]): low = mid + 1;\n\t\t\telse: high = mid - 1;\n\t\tf[low] = a[i];\n\t\tif (low > l): l = low;\n\treturn l;\n\t\nn = input();\na = map(int, raw_input().split());\nprint lis(a, n);\n\t\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 9;\nint a[N], n, q[N], s, t;\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    int v;\n    cin >> v;\n    int l = s, r = t;\n    while (l <= r) {\n      int mid = (l + r) >> 1;\n      if (q[mid] < v)\n        l = mid + 1;\n      else\n        r = mid - 1;\n    }\n    if (r == t)\n      q[++t] = v;\n    else\n      q[r + 1] = min(q[r + 1], v);\n  }\n  cout << t << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> s;\nvector<int>::iterator it;\nint v[100001];\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) scanf(\"%d\", v + i);\n  s.reserve(100000);\n  for (int i = 0; i < n; ++i) {\n    it = lower_bound(s.begin(), s.end(), v[i]);\n    if (it == s.end())\n      s.push_back(v[i]);\n    else\n      *it = v[i];\n  }\n  if (s.size() == 1) s.clear();\n  printf(\"%d\", s.size());\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport static java.lang.Math.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class H {\n\tBufferedReader in; \n\tPrintWriter out;\n\tStringTokenizer st; \n\t\n\tString next() {\n\t\twhile(st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(in.readLine()); \n\t\t\t} catch(Exception e) {\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\t\n\tint nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\t\n\t\n\tlong nextLong() {\n\t\treturn Long.parseLong(next()); \n\t} \n\n\t\n\n\tpublic void run() throws Exception {\n\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\t\tint n = nextInt(); \n\t\t\tlong[] a = new long[n+n];\n\t\t\tArrays.fill(a, 100000000); \n\t\t\ta[0] = -1000000000; \n\t\t\tint top = 0;\n\t\t\tfor (int i=0; i<n; i++) {\n\t\t\t\tint x = nextInt(); \n\t\t\t\tint l = 0, r=top;\n\t\t\t\tint d=-1;\n\t\t\t\twhile (l<=r) {\n\t\t\t\t\tint m = (l+r) / 2;\n\t\t\t\t\tif (a[m] > x) r = m-1; else {\n\t\t\t\t\t\td = m; \n\t\t\t\t\t\tl = m+1; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (a[d+1] > x) a[d+1] = x;\n\t\t\t\tif (top < d+1) top = d+1; \n\t\t\t}\n\t\t\tSystem.err.println(Arrays.toString(a)); \n\t\t\tout.println(top); \n\t\tout.close();\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew H().run();  \n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5;\nint n, ft[N + 5];\npair<int, int> arr[N + 5];\nvoid update(int l, int k) {\n  for (; l <= N; l += (l) & (-l)) ft[l] = max(ft[l], k);\n  return;\n}\nint get(int l) {\n  int ret = 0;\n  for (; l >= 1; l -= (l) & (-l)) ret = max(ret, ft[l]);\n  return ret;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    int a;\n    cin >> a;\n    arr[i] = make_pair(a, i);\n  }\n  sort(arr + 1, arr + n + 1);\n  int ans = 0;\n  for (int i = 1; i <= n; i++) {\n    int temp = get(arr[i].second - 1) + 1;\n    update(arr[i].second, temp);\n    ans = max(ans, get(arr[i].second - 1) + 1);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double PI = 2.0 * acos(0.0);\nconst double EPS = 1e-6;\nint dp[100005];\nstatic int topp;\nvoid LIS(int x) {\n  if (topp == 0)\n    dp[topp++] = x;\n  else if (x > dp[topp - 1])\n    dp[topp++] = x;\n  else {\n    int left = 0, right = topp;\n    while (left < right) {\n      int mid = (left + right) >> 1;\n      if (dp[mid] > x)\n        right = mid;\n      else\n        left = mid + 1;\n    }\n    while (left < topp - 1 && dp[left] == dp[left + 1]) left++;\n    dp[left] = x;\n  }\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  ::topp = 0;\n  for (int i = 0; i < n; i++) {\n    int a;\n    scanf(\"%d\", &a);\n    LIS(a);\n  }\n  printf(\"%d\\n\", topp);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxN = 100005;\nint tree[maxN * 4];\nint query(int t, int l, int r, int x, int y) {\n  if (x > r || y < l) return -1;\n  if (l >= x && r <= y) return tree[t];\n  int m = (l + r) / 2;\n  return max(query(t * 2 + 1, l, m, x, y), query(t * 2 + 2, m + 1, r, x, y));\n}\nvoid update(int t, int l, int r, int index, int value) {\n  if (l == r) {\n    tree[t] = value;\n    return;\n  }\n  int m = (l + r) / 2;\n  if (index <= m)\n    update(t * 2 + 1, l, m, index, value);\n  else\n    update(t * 2 + 2, m + 1, r, index, value);\n  tree[t] = max(tree[t * 2 + 1], tree[t * 2 + 2]);\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vector<int> a(n), d(n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    d[i] = query(0, 0, n - 1, 0, a[i] - 1) + 1;\n    update(0, 0, n - 1, a[i] - 1, d[i]);\n    if (d[i] > ans) ans = d[i];\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool debug = false;\nint n, m, k;\nint dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\nlong long ln, lk, lm;\nint a[100005], d[100005];\nvoid cal() {\n  d[1] = a[1];\n  int len = 1;\n  for (int i = 2; i <= n; i++) {\n    if (a[i] >= d[len])\n      d[++len] = a[i];\n    else {\n      int j = upper_bound(d + 1, d + len + 1, a[i]) - d;\n      d[j] = a[i];\n    }\n  }\n  cout << len << endl;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int(i) = 1; (i) <= (int)(n); (i)++) {\n    scanf(\"%d\", a + i);\n  }\n  cal();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100010], c[100010], len;\nint find(int L, int R, int x) {\n  if (L == R) return L;\n  int mid = (L + R) >> 1;\n  if (c[mid] < x)\n    return find(mid + 1, len, x);\n  else\n    return find(L, mid, x);\n}\nint main() {\n  int i, n, t, m, T, b, k, ans, j, max;\n  while (scanf(\"%d\", &n) != EOF) {\n    for (i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    len = 0;\n    c[0] = -100000000;\n    for (i = 0; i < n; i++) {\n      if (a[i] > c[len])\n        j = ++len;\n      else\n        j = find(1, len, a[i]);\n      c[j] = a[i];\n    }\n    printf(\"%d\\n\", len);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class BubbleSortGraph {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader rd = new BufferedReader(new InputStreamReader(System.in));\n\t\tn = Integer.parseInt(rd.readLine());\n\t\ta = new int[n];\n\t\tStringTokenizer st = new StringTokenizer(rd.readLine());\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = Integer.parseInt(st.nextToken()) - 1;\n\t\tint[] dp = new int[n];\n\t\tdp[n-1] = 1;\n\t\ttreeUpdate(a[n-1], 1);\n\t\tint max = 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tint value = a[i], maxRight = treeGetMax(value);\n\t\t\tdp[i] = 1 + maxRight;\n\t\t\ttreeUpdate(value, dp[i]);\n\t\t\tmax = Math.max(max, dp[i]);\n\t\t}\n\t\tSystem.out.println(max);\n\t}\n\n\tstatic void treeUpdate(int index, int value) {\n\t\tupdate(1, 0, n-1, index, value);\n\t}\n\n\tstatic int treeGetMax(int index) {\n\t\treturn getMax(1, 0, n-1, index, n-1);\n\t}\n\t\n\tstatic int getMax(int v, int L, int R, int a, int b){\n\t\tif(a==L && b==R) return t[v];\n\t\tint M = (L+R)>>1;\n\t\tif(b<=M) return getMax(2*v, L, M, a, b);\n\t\tif(a>M) return getMax(2*v+1, M+1, R, a, b);\n\t\treturn Math.max(getMax(2*v, L, M, a, M), getMax(2*v+1, M+1, R, M+1, b));\n\t}\n\n\tstatic void update(int v, int L, int R, int index, int value) {\n\t\tif (R == L) {\n\t\t\tt[v] = value;\n\t\t\treturn;\n\t\t}\n\t\tint M = (R + L) >> 1;\n\t\tif (index <= M)\n\t\t\tupdate(2 * v, L, M, index, value);\n\t\telse\n\t\t\tupdate(2 * v + 1, M + 1, R, index, value);\n\t\tt[v] = Math.max(t[2 * v], t[2 * v + 1]);\n\t}\n\n\tstatic int[] t = new int[400001];\n\n\tstatic int[] a;\n\n\tstatic int n;\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\nint main() {\n  int n, i, elem;\n  cin >> n;\n  vector<int> A(n);\n  vector<int> B(n + 1, INF);\n  for (i = 0; i < n; ++i) {\n    cin >> elem;\n    *upper_bound(B.begin(), B.end(), elem) = elem;\n  }\n  int ans = 0;\n  for (i = 0; i < n; ++i)\n    if (B[i] < INF) ans++;\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[333333];\nint f[333333];\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  long long sum = 0;\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  int t = 0;\n  for (int i = 1; i <= n; i++) {\n    if (a[i] >= f[t])\n      f[++t] = a[i];\n    else {\n      int idx = lower_bound(f + 1, f + t + 1, a[i]) - f;\n      f[idx] = a[i];\n    }\n  }\n  cout << t;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nset<int> myset;\nint main(int argc, char** argv) {\n  int n, x;\n  cin >> n;\n  auto it = myset.begin();\n  for (int i = 0; i < n; i++) {\n    cin >> x;\n    myset.insert(x);\n    it = myset.find(x);\n    it++;\n    if (it != myset.end()) myset.erase(it);\n  }\n  cout << ((int)(myset).size()) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n\n\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        StringBuilder sb = new StringBuilder();\n        PrintWriter out = new PrintWriter(System.out);\n        int n = sc.nextInt();\n        int arr [] = new int[n] ;\n        for (int i = 0 ; i < n ; ++ i) arr[i] = sc.nextInt();\n        ArrayList<Integer> L = new ArrayList<>();\n        int lis = 0 ;\n        for (int i = 0 ; i < n ; ++ i) {\n            int pos = Collections.binarySearch(L , arr[i]);\n            if (pos < 0) pos = -pos - 1 ;\n            if (pos >= L.size()) L.add(arr[i]);\n            else L.set(pos , arr[i]);\n            if (pos + 1 > lis) lis = pos + 1;\n        }\n        out.println(lis);\n        out.close();\n\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            String x = next();\n            StringBuilder sb = new StringBuilder(\"0\");\n            double res = 0, f = 1;\n            boolean dec = false, neg = false;\n            int start = 0;\n            if (x.charAt(0) == '-') {\n                neg = true;\n                start++;\n            }\n            for (int i = start; i < x.length(); i++)\n                if (x.charAt(i) == '.') {\n                    res = Long.parseLong(sb.toString());\n                    sb = new StringBuilder(\"0\");\n                    dec = true;\n                } else {\n                    sb.append(x.charAt(i));\n                    if (dec)\n                        f *= 10;\n                }\n            res += Long.parseLong(sb.toString()) / f;\n            return res * (neg ? -1 : 1);\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6, inf = 1e9;\nint a[N + 10], dp[N + 10];\nint main() {\n  int n, l;\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  for (int i = 0; i < n; i++) {\n    int j = upper_bound(dp, dp + l, a[i]) - dp;\n    if (l == j) l++;\n    dp[j] = a[i];\n  }\n  cout << l;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double pi = 3.14159265358979323846264338327950288419716939937511;\nconst double eps = 1e-9;\nchar ch_ch_ch[1 << 20];\ninline string gs() {\n  scanf(\"%s\", ch_ch_ch);\n  return string(ch_ch_ch);\n}\ninline string gl() {\n  gets(ch_ch_ch);\n  return string(ch_ch_ch);\n}\ninline int gi() {\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\nconst int inf = 1000000000;\ntemplate <typename T>\nclass FenwickSummator {\n private:\n  T* fenv;\n  int n;\n\n public:\n  FenwickSummator(int N) {\n    n = N;\n    fenv = new T[N + 1];\n    memset(fenv, 0, (N + 1) * sizeof(T));\n  }\n  void add(int p, T val) {\n    if (p < 0 || p >= n) return;\n    for (++p; p <= n; p += p & -p) fenv[p] = max(fenv[p], val);\n  }\n  T maxi(int p) {\n    if (p < 0) return 0;\n    if (p >= n) p = n - 1;\n    T res = 0;\n    for (++p; p > 0; p -= p & -p) res = max(res, fenv[p]);\n    return res;\n  }\n  ~FenwickSummator() { delete[] fenv; }\n};\nint a[100100];\nFenwickSummator<int> fenv(100100);\nint n;\nvoid solution() {\n  n = gi();\n  for (int i = 0; i < (n); ++i) a[i] = gi();\n  int res = 0;\n  for (int i = 0; i < (n); ++i) {\n    int cur = fenv.maxi(a[i] - 1);\n    fenv.add(a[i], cur + 1);\n    res = max(res, cur + 1);\n  }\n  cout << res << endl;\n}\nint main(int argc, char** argv) {\n  solution();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1000000000;\nconst int maxn = 100000 + 9;\nint n;\nint num[maxn], d[maxn], Left, Right, mid, l;\nint main() {\n  while (scanf(\"%d\", &n) == 1) {\n    for (int i = 1; i <= n; ++i) scanf(\"%d\", &num[i]);\n    memset(d, 0, sizeof(d));\n    d[0] = -inf;\n    d[1] = inf;\n    l = 0;\n    for (int i = 1; i <= n; ++i) {\n      Left = 0;\n      Right = l + 1;\n      while (Left < Right) {\n        if (Left + 1 == Right) {\n          if (d[Right] < num[i]) Left = Right;\n          break;\n        }\n        mid = (Left + Right + 1) >> 1;\n        if (d[mid] < num[i])\n          Left = mid;\n        else\n          Right = mid - 1;\n      }\n      if (Left == l) {\n        d[++l + 1] = inf;\n      }\n      d[Left + 1] = num[i];\n    }\n    printf(\"%d\\n\", l);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static long time = 0;\n\n    public static void main(String[] args) throws Exception {\n        time = System.currentTimeMillis();\n        solve();\n        out.flush();\n    }\n\n    public static void solve() throws Exception {\n        int n1 = ni();\n        int[] l1 = nil(n1);\n        pn(LongestIncreasingSubsequence.lis(l1).length);\n    }\n\n    public static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    public static StringTokenizer st = null;\n\n    public static String nx() throws Exception {\n        for (; st == null || !st.hasMoreTokens();) {\n            String k1 = in.readLine();\n            if (k1 == null) return null;\n            st = new StringTokenizer(k1);\n        }\n        return st.nextToken();\n    }\n\n    public static int ni() throws Exception {\n        return Integer.parseInt(nx());\n    }\n\n    public static long nl() throws Exception {\n        return Long.parseLong(nx());\n    }\n\n    public static double nd() throws Exception {\n        return Double.parseDouble(nx());\n    }\n\n    private static int[] nil(int n1) throws Exception {\n        int[] l1 = new int[n1];\n        for (int i = 0; i < n1; i++) {\n            l1[i] = ni();\n        }\n        return l1;\n    }\n\n    public static void px(Object... l1) {\n        System.out.println(Arrays.deepToString(l1));\n    }\n\n    public static boolean FLUSH = false;\n    public static PrintWriter out = new PrintWriter(System.out, FLUSH);\n\n    public static void p(Object... l1) {\n        for (int i = 0; i < l1.length; i++) {\n            if (i != 0) out.print(' ');\n            out.print(l1[i].toString());\n        }\n    }\n\n    public static void pn(Object... l1) {\n        for (int i = 0; i < l1.length; i++) {\n            if (i != 0) out.print(' ');\n            out.print(l1[i].toString());\n        }\n        out.println();\n    }\n\n    public static void pn(Collection l1) {\n        boolean first = true;\n        for (Object e : l1) {\n            if (first) first = false;\n            else out.print(' ');\n            out.print(e.toString());\n        }\n        out.println();\n    }\n\n    private static class LongestIncreasingSubsequence {\n        static int lower_bound(int[] a, int len, int key) {\n            int lo = -1;\n            int hi = len;\n            while (hi - lo > 1) {\n                int mid = (lo + hi) / 2;\n                int midVal = a[mid];\n                if (midVal < key) {\n                    lo = mid;\n                }\n                else {\n                    hi = mid;\n                }\n            }\n            return hi;\n        }\n\n        public static int[] lis(int[] a) {\n            int n = a.length;\n            int[] b = new int[n];\n            int[] len = new int[n];\n            int cnt = 0;\n            for (int i = 0; i < n; i++) {\n                int j = lower_bound(b, cnt, a[i]);\n                if (j == cnt) ++cnt;\n                b[j] = a[i];\n                len[i] = j + 1;\n            }\n            int[] res = new int[cnt];\n            for (int i = n - 1; i >= 0; i--)\n                if (len[i] == cnt && (cnt == res.length || a[i] < res[cnt])) res[--cnt] = a[i];\n            return res;\n        }\n    }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:256000000\")\nusing namespace std;\nconst double infd = 2e+9;\nconst int infi = INT_MAX;\ntemplate <class T>\ninline T sqr(T x) {\n  return x * x;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  vector<int> a, d;\n  int n;\n  cin >> n;\n  a.resize(n);\n  d.resize(n, infi);\n  for (int i = 0; i < n; i++) cin >> a[i];\n  for (int i = 0; i < n; i++) {\n    int x = upper_bound(d.begin(), d.end(), a[i]) - d.begin();\n    d[x] = a[i];\n  }\n  cout << (lower_bound(d.begin(), d.end(), infi) - d.begin());\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.lang.Math;\nimport java.util.*;\n\npublic class D {\n    public static void main(String[] args) {\n      int n=in.nextInt();\n      int a[]=in.nextInts(n);\n      int amax=100_000;\n      int d[]=new int[n];\n      int t[]=new int[amax+1];\n      int tree[]=new int[4*(amax+1)];\n//      out.println(a,false);\n      for(int i=0;i<n;++i){\n        d[i]=Math.max(1,get(tree,1,0,a[i]-1,0,n-1)+1);\n        update(tree,1,a[i],d[i],0,n-1);\n        t[a[i]]=d[i];\n//        out.println(d,false);\n//        out.println(t,false, 20);\n//        out.println(tree,false, 20);\n      }\n      int res=Integer.MIN_VALUE;\n      for(int i=0;i<n;++i){\n        if(d[i]>=res){\n          res=d[i];\n        }\n      }\n      out.println(res);\n    }\n\n    static int get(int[]t,int ti,int ai,int aj,int al, int ar){\n      if((ai<al&&aj<al)||(ar<ai&&ar<aj)){\n        return Integer.MIN_VALUE;\n      }\n      if(ai<=al&&ar<=aj){\n        return t[ti];\n      }\n      int am=(al+ar)/2;\n      return Math.max(get(t,2*ti,ai,aj,al,am), get(t,2*ti+1,ai,aj,am+1,ar));\n    }\n\n    static void update(int[]t,int ti,int ai,int v,int al,int ar) {\n      if(al==ar){\n        t[ti]=v;\n        return;\n      }\n      int am=(al+ar)/2;\n      if(ai<=am){\n        update(t,2*ti,ai,v,al,am);\n      }else{\n        update(t,2*ti+1,ai,v,am+1,ar);\n      }\n      t[ti]=Math.max(t[2*ti], t[2*ti+1]);\n    }\n\n    static MyScanner in = new MyScanner();\n    static MyPrintWriter out = new MyPrintWriter();\n\n    static class MyPrintWriter {\n      BufferedOutputStream bos;\n      PrintWriter pw;\n\n      MyPrintWriter() {\n        this.bos = new BufferedOutputStream(System.out);\n        this.pw = new PrintWriter(bos, true);\n      }\n\n      void print(String t) {\n        pw.print(t);\n      }\n\n      void println() {\n        pw.println(\"\");\n      }\n\n      void println(String s) {\n        pw.println(s);\n      }\n\n      void println(int t) {\n        pw.println(t);\n      }\n\n      void println(long t) {\n        pw.println(t);\n      }\n\n      void println(double t) {\n        pw.println(t);\n      }\n\n      <T> void println(T t) {\n        pw.println(t.toString());\n      }\n\n      void println(boolean[] ts) {\n        println(ts, true);\n      }\n\n      void println(char[] ts) {\n        println(ts, true);\n      }\n\n      void println(int[] ts) {\n        println(ts, true);\n      }\n\n      void println(long[] ts) {\n        println(ts, true);\n      }\n\n      void println(double[] ts) {\n        println(ts, true);\n      }\n\n      <T> void println(T[] ts) {\n        println(ts, true);\n      }\n\n      <T> void println(Collection<T> ts) {\n        println(ts, true);\n      }\n\n      void println(boolean[] ts, boolean newline) {\n        StringBuilder sb = new StringBuilder();\n        for (boolean t: ts) {\n          sb.append(t);\n          sb.append((newline ? \"\\n\" : \" \"));\n        }\n        if (sb.length() > 0) {\n          sb.deleteCharAt(sb.length()-1);\n        }\n        pw.println(sb.toString());\n      }\n\n      void println(char[] ts, boolean newline) {\n        StringBuilder sb = new StringBuilder();\n        for (char t: ts) {\n          sb.append(t);\n          sb.append((newline ? \"\\n\" : \" \"));\n        }\n        if (sb.length() > 0) {\n          sb.deleteCharAt(sb.length()-1);\n        }\n        pw.println(sb.toString());\n      }\n\n      void println(int[] ts, boolean newline) {\n        println(ts, newline, 0, ts.length-1);\n      }\n\n      void println(int[] ts, boolean newline, int imax) {\n        println(ts, newline, 0, imax);\n      }\n\n      void println(int[] ts, boolean newline, int imin, int imax) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = imin; i <= imax; ++i) {\n          sb.append(ts[i]);\n          sb.append((newline ? \"\\n\" : \" \"));\n        }\n        if (sb.length() > 0) {\n          sb.deleteCharAt(sb.length()-1);\n        }\n        pw.println(sb.toString());\n      }\n\n      void println(long[] ts, boolean newline) {\n        StringBuilder sb = new StringBuilder();\n        for (long t: ts) {\n          sb.append(t);\n          sb.append((newline ? \"\\n\" : \" \"));\n        }\n        if (sb.length() > 0) {\n          sb.deleteCharAt(sb.length()-1);\n        }\n        pw.println(sb.toString());\n      }\n\n      void println(double[] ts, boolean newline) {\n        StringBuilder sb = new StringBuilder();\n        for (double t: ts) {\n          sb.append(t);\n          sb.append((newline ? \"\\n\" : \" \"));\n        }\n        if (sb.length() > 0) {\n          sb.deleteCharAt(sb.length()-1);\n        }\n        pw.println(sb.toString());\n      }\n\n      <T> void println(T[] ts, boolean newline) {\n        println(Arrays.asList(ts), newline);\n      }\n\n      <T> void println(Collection<T> ts, boolean newline) {\n        StringBuilder sb = new StringBuilder();\n        for (T t: ts) {\n          sb.append(t.toString());\n          sb.append((newline ? \"\\n\" : \" \"));\n        }\n        if (sb.length() > 0) {\n          sb.deleteCharAt(sb.length()-1);\n        }\n        pw.println(sb.toString());\n      }\n\n      void println(int[][] tss) {\n        StringBuilder sb = new StringBuilder();\n        for (int[] ts: tss) {\n          for (int t: ts) {\n            sb.append(t).append(\" \");\n          }\n          if (ts.length > 0) {\n            sb.setCharAt(sb.length()-1, '\\n');\n          } else {\n            sb.append('\\n');\n          }\n        }\n        pw.print(sb.toString());\n        pw.flush();\n      }\n\n      void println(long[][] tss) {\n        StringBuilder sb = new StringBuilder();\n        for (long[] ts: tss) {\n          for (long t: ts) {\n            sb.append(t).append(\" \");\n          }\n          if (ts.length > 0) {\n            sb.setCharAt(sb.length()-1, '\\n');\n          } else {\n            sb.append('\\n');\n          }\n        }\n        pw.print(sb.toString());\n        pw.flush();\n      }\n\n      void println(double[][] tss) {\n        StringBuilder sb = new StringBuilder();\n        for (double[] ts: tss) {\n          for (double t: ts) {\n            sb.append(t).append(\" \");\n          }\n          if (ts.length > 0) {\n            sb.setCharAt(sb.length()-1, '\\n');\n          } else {\n            sb.append('\\n');\n          }\n        }\n        pw.print(sb.toString());\n        pw.flush();\n      }\n    }\n\n    static class MyScanner {\n      InputStreamReader is;\n      BufferedReader br;\n      StringTokenizer st;\n\n      MyScanner() {\n        this.is = new InputStreamReader(System.in);\n        this.br = new BufferedReader(is);\n      }\n\n      void findToken() {\n        while (st == null || !st.hasMoreTokens()) {\n          try {\n            st = new StringTokenizer(br.readLine());\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n\n      String next() {\n        findToken();\n        return st.nextToken();\n      }\n\n      String nextLine(){\n        String str = \"\";\n        try {\n            str = br.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return str;\n      }\n\n      int nextInt() {\n        return Integer.parseInt(next());\n      }\n\n      int[] nextInts(int n) {\n        return nextInts(n, false);\n      }\n\n      int[] nextInts(int n, boolean oneBased) {\n        return nextInts(n, oneBased ? 1 : 0);\n      }\n\n      int[] nextInts(int n, int iStart) {\n        int[] ints = new int[n+iStart];\n        for (int i=iStart; i<ints.length; ++i) {\n          ints[i] = nextInt();\n        }\n        return ints;\n      }\n\n      long nextLong() {\n        return Long.parseLong(next());\n      }\n\n      long[] nextLongs(int n) {\n        return nextLongs(n, false);\n      }\n\n      long[] nextLongs(int n, int iStart) {\n        long[] longs = new long[n+iStart];\n        for (int i=iStart; i<longs.length; ++i) {\n          longs[i] = nextLong();\n        }\n        return longs;\n      }\n\n      long[] nextLongs(int n, boolean oneBased) {\n        return nextLongs(n, oneBased ? 1 : 0);\n      }\n\n      double nextDouble() {\n        return Double.parseDouble(next());\n      }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mx = 1e5 + 10;\nint d[mx];\nint ft[mx];\nvoid upd(int i, int v) {\n  i = mx - i - 2;\n  for (; i < mx; i += (i & -i)) ft[i] = max(ft[i], v);\n}\nint qry(int i) {\n  int a = 0;\n  i = mx - i - 2;\n  for (; i > 0; i -= (i & -i)) a = max(a, ft[i]);\n  return a;\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", d + i);\n  }\n  int ans = 1;\n  for (int i = n - 1; i >= 0; i--) {\n    int fi = 1 + qry(d[i]);\n    ans = max(ans, fi);\n    upd(d[i], fi);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 200005;\nint main() {\n  int i, j, n, top, tmp;\n  int stack[maxn];\n  cin >> n;\n  top = 0;\n  stack[0] = 0;\n  for (i = 0; i < n; i++) {\n    cin >> tmp;\n    if (tmp > stack[top]) {\n      stack[++top] = tmp;\n    } else {\n      int low = 1, high = top;\n      int mid;\n      while (low <= high) {\n        mid = (low + high) / 2;\n        if (tmp > stack[mid]) {\n          low = mid + 1;\n        } else {\n          high = mid - 1;\n        }\n      }\n      stack[low] = tmp;\n    }\n  }\n  cout << top << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100005], b[100005];\nint n;\nint main() {\n  scanf(\"%d\\n\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  b[0] = -1000000;\n  for (int i = 1; i <= n; i++) {\n    b[i] = 1000000;\n  }\n  for (int i = 0; i < n; i++) {\n    int j = upper_bound(b, b + n, a[i]) - b;\n    if (b[j - 1] < a[i] && b[j] > a[i]) {\n      b[j] = a[i];\n    }\n  }\n  for (int i = n; i >= 1; i--) {\n    if (b[i] < 1000000) {\n      printf(\"%d\\n\", i);\n      return 0;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.util.LinkedList;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class tmp {\n    public static void main(String [] args) throws Exception{\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(in.readLine());\n        StringBuilder sb = new StringBuilder();\n        \n        int n = Integer.parseInt(st.nextToken());\n\t\tint [] array = new int[n];\n\t\tst = new StringTokenizer(in.readLine());\n\t\tfor(int i = 0 ; i < n ; i++)\n\t\t\tarray[i] = Integer.parseInt(st.nextToken());\n\n\t\tint res = 0;\n\t\tint [] sort = new int[n+1];\n\t\tfor(int i = 0 ; i < n ; i++)\n\t\t{\n\t\t\tint ind = Arrays.binarySearch(sort, 0, res+1, array[i]);\n\t\t\tif(ind < 0)\n\t\t\t{\n\t\t\t\tind = -ind-2;\n\t\t\t\tsort[ind+1] = array[i];\n\t\t\t\tif(ind == res)\n\t\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(res);\n        \n        \n        \n        \n     \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n    }\n    \n    \n\n    \n    \n    \n    \n    \n\n\n    \n    \n    \n    \n}\n\n    \nclass P implements Comparable<P>{\n    int val, idx;\n    public P(int val, int idx){\n        this.val = val;\n        this.idx = idx;\n    }\n\n    public int compareTo(P other){\n        if (this.val != other.val) return -this.val + other.val;\n        return this.idx - other.idx;\n    }\n}"
        },
        {
            "language": 1,
            "solution": "def go():\n n=input()\n M=[1e6]*-~n\n s=1\n for i in raw_input().split():\n  x=int(i);l=0;r=s\n  while l+1<r:\n   m=l+r>>1\n   if M[m]<x:l=m\n   else:r=m\n  s+=r==s\n  M[r]=min(M[r],x)\n print s-1\ngo()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint scanst(char *a) {\n  int i = 0;\n  char c = 0;\n  while (c < 33) c = getchar();\n  while (c > 33) {\n    a[i++] = c;\n    c = getchar();\n  }\n  a[i] = 0;\n  return i;\n}\ntemplate <typename T>\nbool scan(T &n) {\n  n = 0;\n  bool got = false;\n  bool negative = false;\n  char c = getchar();\n  if (c == EOF) return false;\n  while (c<'0' | c> '9') {\n    if (c == '-') negative = true;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    got = true;\n    n = n * 10 + c - 48;\n    c = getchar();\n  }\n  if (negative) n = ~(n - 1);\n  return got;\n}\ntemplate <typename T>\ninline T GCD(T a, T b) {\n  a = abs(a);\n  b = abs(b);\n  while (b) {\n    a = a % b;\n    swap(a, b);\n  }\n  return a;\n}\ntemplate <typename T>\ninline T LCM(T x, T y) {\n  T tp = GCD(x, y);\n  if ((x / tp) * 1. * y > 9e18) return 9e18;\n  return (x / tp) * y;\n}\ntemplate <typename T>\ninline T BigMod(T A, T B, T M) {\n  T ret = 1;\n  while (B) {\n    if (B & 1) ret = (ret * A) % M;\n    A = (A * A) % M;\n    B = B >> 1;\n  }\n  return ret;\n}\ntemplate <typename T>\ninline T InvMod(T A, T M) {\n  return BigMod(A, M - 2, M);\n}\nint gcdr(int a, int b) {\n  if (a == 0) return b;\n  return gcdr(b % a, a);\n}\nvoid FastIO() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.precision(20);\n}\nint main() {\n  FastIO();\n  int n, m, p, q, i, j;\n  while (cin >> n) {\n    int arr[100005] = {0};\n    for (i = 0; i <= n - 1; i++) cin >> arr[i];\n    vector<int> ans;\n    for (i = 0; i <= n - 1; i++) {\n      if (ans.size() == 0) {\n        ans.push_back(arr[i]);\n      } else {\n        auto index = lower_bound(ans.begin(), ans.end(), arr[i]) - ans.begin();\n        auto index2 = lower_bound(ans.begin(), ans.end(), arr[i]);\n        if (index2 == ans.end())\n          ans.push_back(arr[i]);\n        else {\n          ans[index] = arr[i];\n        }\n      }\n    }\n    cout << ans.size() << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint c[100010], n, a[100010];\nint lowbit(int x) { return x & (-x); }\nvoid update(int x, int val) {\n  for (int i = x; i; i -= lowbit(i)) c[i] = max(c[i], val);\n}\nint qmax(int x) {\n  int ret = 0;\n  for (int i = x; i <= n; i += lowbit(i)) ret = max(ret, c[i]);\n  return ret;\n}\nint main() {\n  int k, ans;\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  memset(c, 0, sizeof(c));\n  ans = 0;\n  for (int i = n; i >= 1; i--) {\n    k = qmax(a[i]);\n    ans = max(ans, k + 1);\n    update(a[i], k + 1);\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> v(100010, INT_MAX);\nint main() {\n  ios_base::sync_with_stdio(0);\n  int n, a;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> a;\n    *lower_bound(v.begin(), v.end(), a) = a;\n  }\n  for (int i = 0; i <= n; i++)\n    if (v[i] == INT_MAX) {\n      cout << i << \"\\n\";\n      return 0;\n    }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 101110;\nint n;\nint a[N], s[N], f[N];\nvoid update(int x, int v) {\n  for (; x <= n; x += x & -x) s[x] = max(s[x], v);\n}\nint cal(int x) {\n  int r = 0;\n  for (; x > 0; x -= x & -x) r = max(r, s[x]);\n  return r;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  int r = 0;\n  for (int i = 1; i <= n; i++) {\n    f[i] = cal(a[i] - 1) + 1;\n    update(a[i], f[i]);\n    r = max(r, f[i]);\n  }\n  cout << r << endl;\n}\n"
        },
        {
            "language": 1,
            "solution": "from bisect import *\n\ndef longest_increasing_subsequence(A):\n  top_cards = [A[0]]\n  \n  for i in xrange(1, len(A)):\n    if A[i] > top_cards[-1]:\n      top_cards.append(A[i])\n    else:\n      top_cards[bisect_right(top_cards, A[i])] = A[i]\n\n  return len(top_cards)\n\nn = int(raw_input())\nA = map(int, raw_input().split())\nprint longest_increasing_subsequence(A)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint len;\nint s[100005];\nint dpi[100005];\nint dp[100005];\nint last[100005];\nint ans[100005];\nint main() {\n  scanf(\"%d\", &len);\n  for (int i = 0; i < len; i++) scanf(\"%d\", &s[i]);\n  int max = 0;\n  memset(dp, 0, sizeof(dp));\n  for (int i = 0; i < len; i++) {\n    int k = lower_bound(dp, dp + max, s[i]) - dp;\n    if (k == max) {\n      dp[max] = s[i];\n      dpi[max] = i;\n      last[i] = dpi[max - 1];\n      max++;\n    } else {\n      dp[k] = s[i];\n      dpi[k] = i;\n      last[i] = dpi[k - 1];\n    }\n  }\n  printf(\"%d\\n\", max);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n \npublic class code\n{\n    static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n\n     static class FastWriter\n    {\n        OutputStream os;\n\n        public FastWriter()\n        {\n            os = new BufferedOutputStream(System.out);\n        }\n\n        void println(String content)throws IOException\n        {\n            print(content);\n            print(\"\\n\");\n        }\n\n        void print(String content)throws IOException\n        {\n            os.write(content.getBytes());\n        }\n\n        void flush()throws IOException\n        {\n            os.flush();\n        }\n    }\n    \n    static long P = 1000000007L;\n    public static void main(String args[])throws IOException\n    {\n        FastReader scn = new FastReader();\n\n        int n = scn.nextInt();\n        int[] list = new int[n];\n\n        for(int i = 0; i < n; i++)\n            list[i] = scn.nextInt();\n\n        ArrayList<Integer> ans = new ArrayList<>();\n        ans.add(list[0]);\n        int size = 1;\n\n        for(int i = 1; i < n; i++)\n        {\n            if(list[i] > ans.get(size-1))\n            {\n                ans.add(list[i]);\n                size++;\n            }\n            else if(list[i] == ans.get(size - 1))\n            {\n\n            }\n            else\n            {\n                int index = getMoreThanIndex(ans, list[i], 0, size - 1);\n                ans.set(index, list[i]);\n            }\n        }\n\n        System.out.println(ans.size());\n    }\n\n    public static int getMoreThanIndex(ArrayList<Integer> list, int value, int l, int r)\n    {\n        while( l <= r)\n        {\n            int middle = (l+r)/2;\n \n            if(list.get(middle) == value)\n                return middle;\n            else if(list.get(middle)< value)\n                l = middle + 1;\n            else\n                r = middle - 1;\n        } \n        return l;\n    }\n\n    // public static long dfs(Node current, int l, int r, Node[] nodes)\n    // {\n    //     current.visited = true;\n        \n    //     long ans = 1;\n    //     for(Node next: current.neighbors)\n    //     {\n    //         if(!next.visited && next.sorted_index <= r && next.sorted_index >= l)\n    //         {\n    //             long p = dfs(next, l, r, nodes);\n    //             ans = (ans * ( p + 1))%P;\n    //         }\n    //     }\n\n    //     current.visited = false;\n    //     return ans;\n    // }\n}\n\nclass Pair\n{\n    int a, b;\n    public Pair(int a, int b)\n    {\n        this.a = a;\n        this.b = b;\n    }\n}\n\n// class Node implements Comparable<Node>\n// {\n//     int weight;\n//     int sorted_index;\n//     ArrayList<Node> neighbors;\n//     boolean visited;\n//     public Node()\n//     {\n//         neighbors = new ArrayList<>();\n//     }\n\n//     public int compareTo(Node n)\n//     {\n//         return this.weight - n.weight;\n//     }\n \n// }\n \n// class MutableInt\n// {\n//     int count;\n//     ArrayList<Integer> list;\n//     public MutableInt()\n//     {\n//         list = new ArrayList<>();\n//     }\n// }\n\n// class TrieNode\n// {\n//     HashMap<Character, TrieNode> map;\n//     boolean visited;\n//     int cost;\n\n//     public TrieNode()\n//     {\n//         map = new HashMap<>();\n//     }\n\n//     public TrieNode add(char c, boolean isGood, MutableInt result, int k)\n//     {\n//         if(map.containsKey(c))\n//         {\n//             TrieNode n = map.get(c);\n//             return n;\n//         }\n//         else\n//         {\n//             TrieNode n = new TrieNode();\n//             if(!isGood)\n//                 n.cost = this.cost + 1;\n//             else\n//                 n.cost = this.cost;\n\n//             if(n.cost <= k)\n//                 result.count = result.count + 1;\n\n//             map.put(c, n);\n//             return n;\n//         }\n//     }\n// }"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputStreamReader in = new InputStreamReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskB solver = new TaskB();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskB {\n    int MAX = (int) 1e6;\n    int MIN = (int) -1e6;\n\n    public void solve(int testNumber, InputStreamReader inSt, PrintWriter out) {\n        InputReader in = new InputReader(inSt);\n        int n = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextInt();\n        }\n\n        int d[] = new int[n + 1];\n        Arrays.fill(d, MAX);\n        d[0] = MIN;\n        for (int i = 0; i < n; i++) {\n            int j = -(Arrays.binarySearch(d, a[i]) + 1);\n            if (d[j - 1] < a[i] && a[i] < d[j]) {\n                d[j] = a[i];\n            }\n        }\n\n        for (int i = n; i >= 0; i--) {\n            if (d[i] < MAX) {\n                out.println(i);\n                return;\n            }\n        }\n    }\n\n    class InputReader {\n        public BufferedReader reader;\n        private String[] currentArray;\n        int curPointer;\n\n        public InputReader(InputStreamReader inputStreamReader) {\n            reader = new BufferedReader(inputStreamReader);\n        }\n\n        public String next() {\n            try {\n                currentArray = null;\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public void nextChars(char[] t) {\n            try {\n                currentArray = null;\n                reader.read(t);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public char nextChar() {\n            try {\n                currentArray = null;\n                return (char) reader.read();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public int nextInt() {\n            if ((currentArray == null) || (curPointer >= currentArray.length)) {\n                try {\n                    currentArray = reader.readLine().split(\" \");\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                curPointer = 0;\n            }\n            return Integer.parseInt(currentArray[curPointer++]);\n        }\n\n        public long nextLong() {\n            if ((currentArray == null) || (curPointer >= currentArray.length)) {\n                try {\n                    currentArray = reader.readLine().split(\" \");\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                curPointer = 0;\n            }\n            return Long.parseLong(currentArray[curPointer++]);\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\npublic class D340 {\n     static class dat{\n\tpublic int x;\n\tpublic int y;\n     }\n    public static int[] res= new int[100010];\n    public static int n;\n    public static int get(int x){\n\tint temp=0;\n\twhile (x>0){\n\t    temp=Math.max(temp,res[x]);\n\t    x-=x&-x;\n\t}\n\treturn temp;\n    }\n    public static void update(int x,int y){\n\twhile (x<=n){\n\t    res[x]=Math.max(res[x],y);\n\t    x+=x&-x;\n\t}\n    }\n    public static void main(String[] agrs) {\n\tScanner f = new Scanner(System.in);\n\tn=f.nextInt();\n\tdat[] a = new dat[n];\n\tfor(int i=0;i<n;i++){\n\t    int u=f.nextInt();\n\t    a[i]=new dat();\n\t    a[i].x=u;\n\t    a[i].y=i+1;\n\n\t}\n\tArrays.sort(a,new Comparator<dat>(){\n\t    @Override\n\t\tpublic int compare(dat a, dat b){\n\t\treturn a.x-b.x;\n\t    }\n\t    });\n\tint ans=0;\n\tfor(int i=0;i<n;i++){\n\t    int temp=get(a[i].y)+1;\n\t    ans=Math.max(ans,temp);\n\t    update(a[i].y,temp);\n\t}\n\tSystem.out.println(ans);\n}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int max_n = 2e5 + 10;\nint n, temp;\nvector<int> ans;\nint main() {\n  ios_base::sync_with_stdio(false), cin.tie(0);\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> temp;\n    int pos = lower_bound(ans.begin(), ans.end(), temp) - ans.begin();\n    if (pos == ans.size())\n      ans.push_back(temp);\n    else\n      ans[pos] = temp;\n  }\n  cout << ans.size() << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 200000;\nconst int INF = 1000000000;\nint n, a;\nint d[MAXN];\nint main() {\n  d[0] = -INF;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) d[i] = INF;\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", &a);\n    int pos = (upper_bound(d, d + n, a) - d);\n    if (d[pos - 1] < a && a < d[pos]) {\n      d[pos] = a;\n    }\n  }\n  int res = 1;\n  for (int i = 1; i <= n; ++i)\n    if (d[i] <= n) res = i;\n  cout << res << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 20;\nint a[N];\nvector<int> dp;\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n    int indx = lower_bound(dp.begin(), dp.end(), a[i]) - dp.begin();\n    if (indx < dp.size())\n      dp[indx] = a[i];\n    else\n      dp.push_back(a[i]);\n  }\n  cout << dp.size();\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.Locale;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class Solution implements Runnable {\n\t\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer st;\n\t\n\tString nextToken() throws Exception {\n\t\tif (st == null || !st.hasMoreTokens()) st = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\t\n\tint nextInt() throws Exception {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\t\n\tlong nextLong() throws Exception {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\t\n\tvoid solve() throws Exception {\n\t\tint n = nextInt();\n\t\tint[] a = new int[n];\n\t\tint[] b = new int[n + 1];\n\t\tArrays.fill(b, 2 * n);\n\t\tb[0] = 0;\n\t\tfor (int i = 0; i < n; i++) a[i] = nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint q = -Arrays.binarySearch(b, a[i]) - 1;\n\t\t\tb[q] = a[i];\n\t\t}\n\t\tint ans = n;\n\t\twhile (b[ans] == 2 * n) ans--;\n\t\tout.println(ans);\n\t}\n\t\n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n//\t\t\tString s = \"number\";\n//\t\t\tin = new BufferedReader(new FileReader(s + \".in\"));\n//\t\t\tout = new PrintWriter(s + \".out\");\n\t\t\tLocale.setDefault(Locale.US);\n//\t\t\tfor (int tt = nextInt(); tt > 0; tt--)\n\t\t\t\tsolve();\n\t\t} catch(Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t} finally {\n\t\t\tout.close();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t(new Thread(null, new Solution(), \"1\", 1 << 26)).start();\n\t}\n\t\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class round277_C {\n\t\n\tstatic int LIS (int [] A)\n\t{\n\t\tint [] T = new int[A.length];\n\t\tT[0] = A[0];\n\t\tint len = 1;\n\t\tfor(int i = 1; i < A.length; i++)\n\t\t{\n\t\t\tif(A[i] < T[0])\n\t\t\t\tT[0] = A[i];\n\t\t\telse\n\t\t\t\tif(A[i] > T[len - 1])\n\t\t\t\t\tT[len++] = A[i];\n\t\t\t\telse\n\t\t\t\t\tT[lower_bound(T, -1, len - 1, A[i])] = A[i];\n\t\t}\n\t\treturn len;\n\t}\n\t\n\tstatic int lower_bound(int A[], int l, int r, int key)\n    {\n        while (r - l > 1)\n        {\n            int m = l + (r - l)/2;\n            if (A[m]>=key)\n                r = m;\n            else\n                l = m;\n        }\n \n        return r;\n    }\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint [] a = new int[n];\n\t\tfor(int i = 0; i < n; i++)\n\t\t\ta[i] = sc.nextInt();\n\t\tSystem.out.println(LIS(a));\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\n\npublic class R198_D {\n\t\n\tprivate static int lis(int[] seq) {\n\t\tint n = seq.length;\n\t\tint[] counter = new int[n];\n\t\tArrays.fill(counter, 1);\n\t\t\n\t\tint globalMax = 1;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint max = 1;\n\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\tif (seq[i] > seq[j] && counter[j] + 1 > max) {\n\t\t\t\t\tmax = counter[j] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tcounter[i] = max;\n\t\t\tSystem.out.println(Arrays.toString(counter));\n\t\t\tglobalMax = Math.max(globalMax, max);\n\t\t}\n\t\t\n\t\treturn globalMax;\n\t}\n\t\n    public static int calcLIS(int[] arr)\n    {\n    \t\tint n = arr.length;\n    \t\tint[] prefix = new int[n+1];\n    \t\tint[] indexer = new int[n+1];\n            int len = 1;\n            \n            int[] record = new int[arr.length + 1];\n            record[1] = arr[0];\n\n            int start = 1, mid, end = len;\n            for (int i = 1; i < arr.length; i++)\n            {\n                    start = 1;\n                    end = len;\n\n                    while (start <= end)\n                    {\n                            mid = (start + end) >> 1;\n                            if (record[mid] <= arr[i])\n                                    start = mid + 1;\n                            else\n                                    end = mid - 1;\n                    }\n                    if (start > len)\n                            len = start;\n                    record[start] = arr[i];\n                    indexer[start] = i;\n                    prefix[i] = indexer[start - 1];\n            }\n            return len;\n    }\n\t\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.valueOf(reader.readLine());\n\t\t\n\t\tString[] split = reader.readLine().split(\" \");\n\t\tint[] seq = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tseq[i] = Integer.valueOf(split[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(calcLIS(seq));\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N = 1e6 + 2;\nint a[100010];\nvector<int> bit(1e6 + 2);\nvoid update(int i, int val) {\n  while (i < N) {\n    bit[i] = max(bit[i], val);\n    i = i + (i & (-i));\n  }\n}\nint query(int i) {\n  int ret = 0;\n  while (i) {\n    ret = max(ret, bit[i]);\n    i = i - (i & (-i));\n  }\n  return ret;\n}\nint main() {\n  int i, n, lis = 0;\n  cin >> n;\n  for (i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  for (i = 0; i < n; ++i) {\n    int val = query(a[i] - 1);\n    lis = max(lis, val + 1);\n    update(a[i], val + 1);\n  }\n  cout << lis << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint LIS(vector<int> X) {\n  int n = X.size(), L = 0, M[n + 1], P[n];\n  int lo, hi, mi;\n  L = 0;\n  M[0] = 0;\n  for (int i = 0, j; i < n; i++) {\n    lo = 0;\n    hi = L;\n    while (lo != hi) {\n      mi = (lo + hi + 1) / 2;\n      if (X[M[mi]] < X[i])\n        lo = mi;\n      else\n        hi = mi - 1;\n    }\n    j = lo;\n    P[i] = M[j];\n    if (j == L || X[i] < X[M[j + 1]]) {\n      M[j + 1] = i;\n      L = max(L, j + 1);\n    }\n  }\n  return L;\n}\nvector<int> X;\nint main() {\n  ios::sync_with_stdio(0);\n  int n;\n  cin >> n;\n  for (int i = 0, a; i < n; ++i) {\n    cin >> a;\n    X.push_back(a);\n  }\n  cout << LIS(X) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint LIS(vector<int>& s) {\n  if (s.size() == 0) return 0;\n  vector<int> v;\n  v.push_back(s[0]);\n  for (int i = 1; i < s.size(); ++i) {\n    int n = s[i];\n    if (n > v.back())\n      v.push_back(n);\n    else\n      *lower_bound(v.begin(), v.end(), n) = n;\n  }\n  return v.size();\n}\nint main(void) {\n  vector<int> input;\n  int n;\n  scanf(\"%d\", &n);\n  while (n--) {\n    int buff;\n    scanf(\"%d\", &buff);\n    input.push_back(buff);\n  }\n  printf(\"%d\\n\", LIS(input));\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\nimport java.io.OutputStreamWriter;\nimport java.math.BigInteger;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.io.IOException;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Nguyen Trung Hieu - vuondenthanhcong11@gmail.com\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskLIS solver = new TaskLIS();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass TaskLIS {\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n        int count = in.readInt();\n        IntervalTree tree = new LongIntervalTree(100001) {\n            protected long joinValue(long left, long right) {\n                return Math.max(left, right);\n            }\n\n            protected long joinDelta(long was, long delta) {\n                return was + delta;\n            }\n\n            protected long accumulate(long value, long delta, int length) {\n                return Math.max(value, delta);\n            }\n\n            protected long neutralValue() {\n                return - Integer.MAX_VALUE / 2;\n            }\n\n            protected long neutralDelta() {\n                return 0;\n            }\n\n            protected long initValue(int index) {\n                return 0;\n            }\n        };\n\n        long answer = 0;\n        for (int i = 1; i <= count; i++) {\n            int val = in.readInt();\n            long p = tree.query(0, val) + 1;\n            tree.update(val, val, (int)p);\n            answer = Math.max(answer, p);\n        }\n\n        out.printLine(answer);\n    }\n}\n\nclass InputReader {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private SpaceCharFilter filter;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public int read() {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int readInt() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public boolean isSpaceChar(int c) {\n        if (filter != null)\n            return filter.isSpaceChar(c);\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public interface SpaceCharFilter {\n        public boolean isSpaceChar(int ch);\n    }\n\n}\n\nclass OutputWriter {\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public void print(Object...objects) {\n        for (int i = 0; i < objects.length; i++) {\n            if (i != 0)\n                writer.print(' ');\n            writer.print(objects[i]);\n        }\n    }\n\n    public void printLine(Object...objects) {\n        print(objects);\n        writer.println();\n    }\n\n    public void close() {\n        writer.close();\n    }\n\n}\n\nabstract class IntervalTree {\n    protected int size;\n\n    public IntervalTree(int size, boolean shouldInit) {\n        this.size = size;\n        int nodeCount = Math.max(1, Integer.highestOneBit(size) << 2);\n        initData(size, nodeCount);\n        if (shouldInit)\n            init();\n    }\n\n    protected abstract void initData(int size, int nodeCount);\n    protected abstract void initAfter(int root, int left, int right, int middle);\n    protected abstract void initBefore(int root, int left, int right, int middle);\n    protected abstract void initLeaf(int root, int index);\n    protected abstract void updatePostProcess(int root, int left, int right, int from, int to, long delta, int middle);\n    protected abstract void updatePreProcess(int root, int left, int right, int from, int to, long delta, int middle);\n    protected abstract void updateFull(int root, int left, int right, int from, int to, long delta);\n    protected abstract long queryPostProcess(int root, int left, int right, int from, int to, int middle, long leftResult, long rightResult);\n    protected abstract void queryPreProcess(int root, int left, int right, int from, int to, int middle);\n    protected abstract long queryFull(int root, int left, int right, int from, int to);\n    protected abstract long emptySegmentResult();\n\n    public void init() {\n        init(0, 0, size - 1);\n    }\n\n    private void init(int root, int left, int right) {\n        if (left == right) {\n            initLeaf(root, left);\n        } else {\n            int middle = (left + right) >> 1;\n            initBefore(root, left, right, middle);\n            init(2 * root + 1, left, middle);\n            init(2 * root + 2, middle + 1, right);\n            initAfter(root, left, right, middle);\n        }\n    }\n\n    public void update(int from, int to, long delta) {\n        update(0, 0, size - 1, from, to, delta);\n    }\n\n    protected void update(int root, int left, int right, int from, int to, long delta) {\n        if (left > to || right < from)\n            return;\n        if (left >= from && right <= to) {\n            updateFull(root, left, right, from, to, delta);\n            return;\n        }\n        int middle = (left + right) >> 1;\n        updatePreProcess(root, left, right, from, to, delta, middle);\n        update(2 * root + 1, left, middle, from, to, delta);\n        update(2 * root + 2, middle + 1, right, from, to, delta);\n        updatePostProcess(root, left, right, from, to, delta, middle);\n    }\n\n    public long query(int from, int to) {\n        return query(0, 0, size - 1, from, to);\n    }\n\n    protected long query(int root, int left, int right, int from, int to) {\n        if (left > to || right < from)\n            return emptySegmentResult();\n        if (left >= from && right <= to)\n            return queryFull(root, left, right, from, to);\n        int middle = (left + right) >> 1;\n        queryPreProcess(root, left, right, from, to, middle);\n        long leftResult = query(2 * root + 1, left, middle, from, to);\n        long rightResult = query(2 * root + 2, middle + 1, right, from, to);\n        return queryPostProcess(root, left, right, from, to, middle, leftResult, rightResult);\n    }\n}\n\nabstract class LongIntervalTree extends IntervalTree {\n    protected long[] value;\n    protected long[] delta;\n\n    protected LongIntervalTree(int size) {\n        this(size, true);\n    }\n\n    public LongIntervalTree(int size, boolean shouldInit) {\n        super(size, shouldInit);\n    }\n\n    protected void initData(int size, int nodeCount) {\n        value = new long[nodeCount];\n        delta = new long[nodeCount];\n    }\n\n    protected abstract long joinValue(long left, long right);\n    protected abstract long joinDelta(long was, long delta);\n    protected abstract long accumulate(long value, long delta, int length);\n    protected abstract long neutralValue();\n    protected abstract long neutralDelta();\n\n    protected long initValue(int index) {\n        return neutralValue();\n    }\n\n    protected void initAfter(int root, int left, int right, int middle) {\n        value[root] = joinValue(value[2 * root + 1], value[2 * root + 2]);\n        delta[root] = neutralDelta();\n    }\n\n    protected void initBefore(int root, int left, int right, int middle) {\n    }\n\n    protected void initLeaf(int root, int index) {\n        value[root] = initValue(index);\n        delta[root] = neutralDelta();\n    }\n\n    protected void updatePostProcess(int root, int left, int right, int from, int to, long delta, int middle) {\n        value[root] = joinValue(value[2 * root + 1], value[2 * root + 2]);\n    }\n\n    protected void updatePreProcess(int root, int left, int right, int from, int to, long delta, int middle) {\n        pushDown(root, left, middle, right);\n    }\n\n    protected void pushDown(int root, int left, int middle, int right) {\n        value[2 * root + 1] = accumulate(value[2 * root + 1], delta[root], middle - left + 1);\n        value[2 * root + 2] = accumulate(value[2 * root + 2], delta[root], right - middle);\n        delta[2 * root + 1] = joinDelta(delta[2 * root + 1], delta[root]);\n        delta[2 * root + 2] = joinDelta(delta[2 * root + 2], delta[root]);\n        delta[root] = neutralDelta();\n    }\n\n    protected void updateFull(int root, int left, int right, int from, int to, long delta) {\n        value[root] = accumulate(value[root], delta, right - left + 1);\n        this.delta[root] = joinDelta(this.delta[root], delta);\n    }\n\n    protected long queryPostProcess(int root, int left, int right, int from, int to, int middle, long leftResult, long rightResult) {\n        return joinValue(leftResult, rightResult);\n    }\n\n    protected void queryPreProcess(int root, int left, int right, int from, int to, int middle) {\n        pushDown(root, left, middle, right);\n    }\n\n    protected long queryFull(int root, int left, int right, int from, int to) {\n        return value[root];\n    }\n\n    protected long emptySegmentResult() {\n        return neutralValue();\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n/**\n * Date: 23.06.13 at 15:29\n *\n * @author Nickolay Polyarniy aka PolarNick\n */\npublic class ProblemB {\n\n    public void solve() throws Exception {\n        int n = nextInt();\n        int[] a = readIntArray(n);\n        int[] d = new int[n + 1];\n        Arrays.fill(d, Integer.MAX_VALUE / 2);\n        d[0] = 0;\n\n        for (int i = 0; i < n; i++) {\n            int l = 0;\n            int r = n+1;\n            while (l < r - 1) {\n                int m = (l + r) / 2;\n                if (d[m] < a[i]) {\n                    l = m;\n                } else {\n                    r = m;\n                }\n            }\n            d[l + 1] = a[i];\n        }\n        int res = 1;\n        for (int i = 1; i <= n; i++) {\n            if (d[i] < Integer.MAX_VALUE / 2) {\n                res = i;\n            }\n        }\n        out.println(res);\n    }\n\n    public static void main(String[] args) throws Exception {\n        ProblemB problem = new ProblemB();\n        problem.solve();\n        problem.close();\n    }\n\n    BufferedReader in;\n    PrintWriter out;\n    String curLine;\n    StringTokenizer tok;\n    final String delimeter = \" \";\n    final String endOfFile = \"\";\n\n    public ProblemB(BufferedReader in, PrintWriter out) throws Exception {\n        this.in = in;\n        this.out = out;\n        curLine = in.readLine();\n        if (curLine == null || curLine == endOfFile) {\n            tok = null;\n        } else {\n            tok = new StringTokenizer(curLine, delimeter);\n        }\n    }\n\n    public ProblemB() throws Exception {\n        this(new BufferedReader(new InputStreamReader(System.in)),\n                new PrintWriter(System.out));\n    }\n\n    public ProblemB(String filename) throws Exception {\n        this(new BufferedReader(new FileReader(filename + \".in\")),\n                new PrintWriter(filename + \".out\"));\n    }\n\n    public boolean hasMore() throws Exception {\n        if (tok == null || curLine == null) {\n            return false;\n        } else {\n            while (!tok.hasMoreTokens()) {\n                curLine = in.readLine();\n                if (curLine == null || curLine.equalsIgnoreCase(endOfFile)) {\n                    tok = null;\n                    return false;\n                } else {\n                    tok = new StringTokenizer(curLine);\n                }\n            }\n            return true;\n        }\n    }\n\n    public String nextWord() throws Exception {\n        if (!hasMore()) {\n            return null;\n        } else {\n            return tok.nextToken();\n        }\n    }\n\n    public int nextInt() throws Exception {\n        return Integer.parseInt(nextWord());\n    }\n\n    public long nextLong() throws Exception {\n        return Long.parseLong(nextWord());\n    }\n\n    public int[] readIntArray(int n) throws Exception {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nextInt();\n        }\n        return res;\n    }\n\n    public void close() throws Exception {\n        in.close();\n        out.close();\n    }\n\n}\n"
        },
        {
            "language": 4,
            "solution": "/**\n * ******* Created  on 13/12/19 8:04 AM*******\n */\n\nimport java.io.*;\nimport java.util.*;\n\npublic class D340 implements Runnable {\n\n    private static final int MAX = (int) (1E5 + 5);\n    private static final int MOD = (int) (1E9 + 7);\n    private static final long Inf = (long) (1E14 + 10);\n\n    private void solve() throws IOException {\n        int n = reader.nextInt();\n        int[] a = new int[n];\n        for(int i=0;i<n;i++)\n            a[i] = reader.nextInt();\n        List<Integer> L = new ArrayList<>();\n        int ans = 0;\n        for(int i =0;i<n;i++){\n            int pos = Collections.binarySearch(L, a[i]);\n            if(pos < 0 ) pos = -pos-1;\n            if(pos >= L.size())\n                L.add(a[i]);\n            else{\n                L.set(pos,a[i]);\n            }\n            if(pos+1 >ans)\n                ans = pos+1;\n        }\n        writer.print(ans);\n    }\n\n    public static void main(String[] args) throws IOException {\n        try (Input reader = new StandardInput(); PrintWriter writer = new PrintWriter(System.out)) {\n            new D340().run();\n        }\n    }\n\n    StandardInput reader;\n    PrintWriter writer;\n\n    @Override\n    public void run() {\n        try {\n            reader = new StandardInput();\n            writer = new PrintWriter(System.out);\n            solve();\n            reader.close();\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    interface Input extends Closeable {\n        String next() throws IOException;\n\n        default int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        default long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        default double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        default int[] readIntArray() throws IOException {\n            return readIntArray(nextInt());\n        }\n\n        default int[] readIntArray(int size) throws IOException {\n            int[] array = new int[size];\n            for (int i = 0; i < array.length; i++) {\n                array[i] = nextInt();\n            }\n            return array;\n        }\n\n        default long[] readLongArray(int size) throws IOException {\n            long[] array = new long[size];\n            for (int i = 0; i < array.length; i++) {\n                array[i] = nextLong();\n            }\n            return array;\n        }\n    }\n\n    private static class StandardInput implements Input {\n        private final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n        private StringTokenizer stringTokenizer;\n\n        @Override\n        public void close() throws IOException {\n            reader.close();\n        }\n\n        @Override\n        public String next() throws IOException {\n            if (stringTokenizer == null || !stringTokenizer.hasMoreTokens()) {\n                stringTokenizer = new StringTokenizer(reader.readLine());\n            }\n            return stringTokenizer.nextToken();\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100005;\nstruct node {\n  long long val;\n  int pos;\n} temp[MAXN][20];\nint dp[MAXN], n, ans;\nlong long a[MAXN];\nvoid merge_sort(int l, int r, int deep) {\n  if (l == r) {\n    temp[l][deep].val = a[l];\n    temp[l][deep].pos = l;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  merge_sort(l, mid, deep + 1);\n  merge_sort(mid + 1, r, deep + 1);\n  int p1 = l, p2 = mid + 1, p = l;\n  while (p1 <= mid && p2 <= r) {\n    if (temp[p1][deep + 1].val < temp[p2][deep + 1].val) {\n      temp[p++][deep] = temp[p1++][deep + 1];\n    } else {\n      temp[p++][deep] = temp[p2++][deep + 1];\n    }\n  }\n  while (p1 <= mid) {\n    temp[p++][deep] = temp[p1++][deep + 1];\n  }\n  while (p2 <= r) {\n    temp[p++][deep] = temp[p2++][deep + 1];\n  }\n  return;\n}\nvoid CDQ_divalgorithm(int l, int r, int deep) {\n  if (l == r) {\n    dp[l] = max(dp[l], 1);\n    ans = max(ans, dp[l]);\n    return;\n  }\n  int mid = (l + r) >> 1;\n  CDQ_divalgorithm(l, mid, deep + 1);\n  int p1 = l, p2 = mid + 1, nowmaxdp = 0;\n  while (p1 <= mid && p2 <= r) {\n    if (temp[p1][deep + 1].val < temp[p2][deep + 1].val) {\n      nowmaxdp = max(nowmaxdp, dp[temp[p1++][deep + 1].pos]);\n    } else {\n      dp[temp[p2][deep + 1].pos] =\n          max(nowmaxdp + 1, dp[temp[p2][deep + 1].pos]);\n      p2++;\n    }\n  }\n  while (p2 <= r) {\n    dp[temp[p2][deep + 1].pos] = max(nowmaxdp + 1, dp[temp[p2][deep + 1].pos]);\n    p2++;\n  }\n  CDQ_divalgorithm(mid + 1, r, deep + 1);\n  return;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%lld\", &a[i]);\n  }\n  merge_sort(1, n, 0);\n  CDQ_divalgorithm(1, n, 0);\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint arr[100001];\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; ++i) cin >> arr[i];\n  set<int> s;\n  set<int>::iterator it;\n  for (int i = 0; i < n; i++) {\n    s.insert(arr[i]);\n    it = s.find(arr[i]);\n    it++;\n    if (it != s.end()) s.erase(it);\n  }\n  cout << s.size() << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\n\npublic class BubbleGraph {\n\n\t\nstatic Stack<Integer> stack;\t//contains the last solution in increasing order\n\t\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint a[] = new int[n];\n\t\tfor(int i=0; i<n; i++)\n\t\t\ta[i] = sc.nextInt();\n\t\t\n\t\t\n\t\tSystem.out.println(LIS(a,n));\n\t\t\n\t}\n\tstatic int LIS(int[] A, int n)\n\t{\n\t\tArrayList<Integer> L = new ArrayList<Integer>();\n\t\tint[] P = new int[n];\n\t\tint[] L_id = new int[n];\n\t\t\n\t\tint lis = 0, lis_end = -1;\n\t\tfor (int i = 0; i < n; ++i) \n\t\t{\n\t\t\tint pos = Collections.binarySearch(L, A[i]);\n\t\t\tif (pos < 0) pos = -(pos + 1);\n\t\t\t//\t\t\t else\tpos++;\t\tnon-decreasing\n\n\t\t\tif (pos >= L.size()) L.add(A[i]);\n\t\t\telse                 L.set(pos, A[i]);\n\n\t\t\tif (pos + 1 > lis)\n\t\t\t{\n\t\t\t\tlis = pos + 1;\n\t\t\t\tlis_end = -1;\n\t\t\t}\n\t\t\t\n\t\t\t//lis_end and the following part for printing the solution\n\t\t\tL_id[pos] = i;\n\t\t\tP[i] = pos > 0?L_id[pos-1]:-1;\n\t\t}\n\t\t\n\t\tstack = new Stack<Integer>();\n\t\twhile(lis_end != -1)\n\t\t{\n\t\t\tstack.push(A[lis_end]);\n\t\t\tlis_end = P[lis_end];\n\t\t}\n\t\treturn lis;\n\t}\n\t\n\t\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tScanner(FileReader f) {\n\t\t\tbr = new BufferedReader(f);\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tScanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tString next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tString nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tint nextInt() throws NumberFormatException, IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws NumberFormatException, IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, ar[100005];\nvector<int> A;\ntemplate <typename T>\ninline void SI(T &n) {\n  char c = getchar();\n  n = 0;\n  for (; (c > 47 && c < 58); c = getchar()) n = 10 * n + c - 48;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  SI(n);\n  for (int i = 0; i < n; i++) {\n    SI(ar[i]);\n    if (!i || ar[i] > A.back())\n      A.push_back(ar[i]);\n    else if (ar[i] < A[0])\n      A[0] = ar[i];\n    else\n      A[lower_bound(A.begin(), A.end(), ar[i]) - A.begin()] = ar[i];\n  }\n  cout << A.size();\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from bisect import bisect_right\ndef answer(n,A):\n    ans=[A[0]]\n    for i in range(1,n):\n        if ans[-1]<A[i]:\n            ans.append(A[i])\n        else:\n            index=bisect_right(ans,A[i])\n            ans[index]=A[i]\n            \n    return len(ans)\n\n\nn=int(input())\narr=list(map(int,input().split()))\nprint(answer(n,arr))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid deba(int* a, int n) {\n  cerr << \"| \";\n  for (int i = 0; i < (n); i++) cerr << a[i] << \" \";\n  cerr << \"|\" << endl;\n}\ninline bool EQ(double a, double b) { return fabs(a - b) < 1e-9; }\nconst int INF = 1 << 30;\nint a[123456];\nint dp[123456];\nint* p;\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  ;\n  for (int i = 0; i < (n); i++) scanf(\"%d\", &a[i]);\n  ;\n  for (int i = 0; i < (n + 2); i++) dp[i] = INF;\n  dp[0] = -INF;\n  dp[1] = a[0];\n  for (int i = (1); i <= (n - 1); i++) {\n    p = lower_bound(dp, dp + n, a[i]);\n    *p = a[i];\n  }\n  p = lower_bound(dp, dp + n + 1, INF - 1);\n  cout << p - dp - 1 << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Solver{\n\n  BufferedReader in;\n  StringTokenizer str = null;\n  PrintWriter out;\n\n  private String next() throws Exception{\n    while(str == null || !str.hasMoreElements())\n      str = new StringTokenizer(in.readLine());\n    return str.nextToken();\n  }\n\n  private int nextInt() throws Exception{\n    return Integer.parseInt(next());\n  }\n\n  final static int oo = Integer.MAX_VALUE/2;\n\n  public void run() throws Exception{\n    in = new BufferedReader(new InputStreamReader(System.in)); \n    out = new PrintWriter(System.out);\n    \n    int n = nextInt();\n    int []a = new int[n];\n    for(int i=0;i<n;i++) a[i] = nextInt();\n\n    int []e = new int[n+1];\n    Arrays.fill(e, oo);\n    e[0] = -oo;\n\n    for(int i=0;i<n;i++){\n      int x = a[i];\n      int l = -1, r = n+2;\n      while(r - l > 1){\n        int m = l + (r - l)/2;\n        if (e[m] <= x){\n          l = m;\n        }else{\n          r = m;\n        }\n      }\n      e[r] = Math.min(e[r], x);\n    }\n    //System.out.println(Arrays.toString(e));\n    int ret = 1;\n    for(int i=1;i<=n;i++){\n      if(e[i] != oo){\n        ret = Math.max(ret, i);  \n      }\n    }\n    out.println(ret);\n    out.close();\n  }\n\n  public static void main(String args[]) throws Exception{\n    new Solver().run();  \n  }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing std::max;\nint N;\nint A[100000 + 7];\nint F[100000 + 7];\nint G[100000 + 7];\nint Fa[100000 + 7];\nint Max1[100000 + 7];\nint Max2[100000 + 7];\nint Used[100000 + 7];\nint Find(int X) { return X == Fa[X] ? X : Fa[X] = Find(Fa[X]); }\nvoid Init() {\n  scanf(\"%d\", &N);\n  for (int i = 1; i <= N; i++) scanf(\"%d\", A + i);\n}\nvoid Cover(int L, int R) {\n  if (L > R) return;\n  for (int i = L; i <= R; i++) {\n    if (Find(i) == i) {\n      Used[i] = 1, Fa[i] = i + 1;\n    } else\n      i = Find(i) - 1;\n  }\n}\nvoid Work1() {\n  int Ans = 0;\n  F[1] = 1;\n  Max1[1] = 1;\n  for (int i = 2; i <= N; i++) {\n    F[i] = 1;\n    for (int j = 1; j < i; j++)\n      if (A[j] < A[i] && F[j] + 1 > F[i]) F[i] = F[j] + 1;\n    if (F[i] > Ans) Ans = F[i];\n    Max1[i] = (Max1[i - 1] > F[i] ? Max1[i - 1] : F[i]);\n  }\n  G[N] = 1;\n  Max2[N] = 1;\n  for (int i = N - 1; i >= 1; i--) {\n    G[i] = 1;\n    for (int j = N; j > i; j--)\n      if (A[j] > A[i] && G[j] + 1 > G[i]) G[i] = G[j] + 1;\n    Max2[i] = (Max2[i + 1] > G[i] ? Max2[i + 1] : G[i]);\n  }\n  printf(\"%d\\n\", Ans);\n  for (int i = 2; i <= N; i++)\n    if (Max1[i - 1] == Ans) Cover(i, i);\n  for (int i = 1; i < N; i++)\n    if (Max2[i + 1] == Ans) Cover(i, i);\n  for (int i = 1; i <= N; i++) {\n    for (int j = i + 1; j <= N; j++) {\n      if (F[i] + G[j] == Ans && A[i] < A[j]) Cover(i + 1, j - 1);\n    }\n  }\n  for (int i = 1; i <= N; i++)\n    if (!Used[i]) printf(\"%d \", i);\n}\nstruct Part {\n  int key, val, id;\n} Partion[100000 + 7];\nint St[100000 + 7];\nint Ed[100000 + 7];\nint Maxr[100000 + 7];\nbool ComparePart(const Part& A, const Part& B) {\n  return A.key < B.key || A.key == B.key && A.val < B.val;\n}\nint Len;\nint D[100000 + 7];\nvoid Work2() {\n  int Ans, Answer = 0;\n  Max1[1] = F[Len = 1] = 1;\n  D[Len] = A[1];\n  for (int i = 2; i <= N; i++) {\n    if (D[Len] < A[i])\n      D[++Len] = A[i], F[i] = Len;\n    else {\n      int L = 1, R = Len, Mid;\n      for (; L < R;) {\n        Mid = L + R >> 1;\n        if (D[Mid] > A[i])\n          R = Mid;\n        else\n          L = Mid + 1;\n      }\n      F[i] = L;\n      D[L] = A[i];\n    }\n    Max1[i] = max(Max1[i - 1], F[i]);\n  }\n  printf(\"%d\\n\", Ans = Answer = Len);\n}\nint main() {\n  Init();\n  for (int i = 1; i <= N + 1; i++) Fa[i] = i;\n  Work2();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, a, k;\nvector<long long> v;\nint main() {\n  cin >> n;\n  cin >> a;\n  v.push_back(a);\n  for (int i = 1; i < n; i++) {\n    cin >> a;\n    if (a > v[v.size() - 1])\n      v.push_back(a);\n    else {\n      k = lower_bound(v.begin(), v.end(), a) - v.begin();\n      v[k] = a;\n    }\n  }\n  cout << v.size() << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace Debug {\nvoid dout() { cerr << \"\\n\"; }\ntemplate <typename Head, typename... Tail>\nvoid dout(Head H, Tail... T) {\n  cerr << \" \" << H;\n  dout(T...);\n}\ntemplate <typename T>\nvoid dout(const T *a, int n) {\n  cerr << \"\\n[\";\n  for (int i = 0; i < n; i++) {\n    cerr << \" \" << a[i];\n  }\n  cerr << \" ]\\n\";\n}\ntemplate <typename T>\nvoid dout(T **b, int r, int c) {\n  for (int i = 0; i < r; i++) {\n    cerr << \"[\";\n    for (int j = 0; j < c; j++) {\n      cerr << \" \" << b[i][j];\n    }\n    cerr << \" ]\\n\";\n  }\n}\ntemplate <typename T>\nvoid dout(const vector<T> v) {\n  cerr << \"\\n[\";\n  for (T i : v) {\n    cerr << \" \" << i;\n  }\n  cerr << \" ]\\n\";\n}\ntemplate <typename T>\nvoid dout(const vector<vector<T>> v) {\n  cerr << \"\\n\";\n  for (vector<T> u : v) {\n    cerr << \"[\";\n    for (T i : u) {\n      cerr << \" \" << i;\n    }\n    cerr << \" ]\\n\";\n  }\n}\ntemplate <typename F, typename S>\nvoid dout(const vector<pair<F, S>> u) {\n  cerr << \"\\n\";\n  for (pair<F, S> v : u) {\n    cerr << \"[ \" << v.first << \" \" << v.second << \" ]\\n\";\n  }\n}\n}  // namespace Debug\nusing namespace Debug;\nconst int N = 1e5 + 69;\nint n, a[N], BIT[N];\nvoid update(int x, int val) {\n  for (; x <= n; x += x & -x) {\n    (BIT[x]) = max((BIT[x]), (val));\n    ;\n  }\n}\nint query(int x) {\n  int res = 0;\n  for (; x > 0; x -= x & -x) {\n    (res) = max((res), (BIT[x]));\n    ;\n  }\n  return res;\n}\nint main() {\n  cin >> n;\n  memset((BIT), 0, sizeof(BIT));\n  vector<pair<int, int>> vpi(n + 1);\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n    vpi[i] = make_pair(a[i], i);\n  }\n  sort(vpi.begin() + 1, vpi.end());\n  for (int i = 1; i <= n; i++) {\n    update(vpi[i].second, query(vpi[i].second) + 1);\n  }\n  cout << query(n) << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 20123;\nconst int maxn = 211001;\nconst int INF = 0x7f7f7f7f;\nint n;\nint a[maxn], b[maxn], sz;\nunsigned long long sum[maxn];\ntemplate <typename T>\nT gcd(T a, T b) {\n  return b ? gcd(b, a % b) : a;\n}\nint binary(int l, int r, int k) {\n  int m, ans = -1;\n  while (l <= r) {\n    m = (l + r) >> 1;\n    if (b[m] >= k) {\n      ans = m;\n      r = m - 1;\n    } else {\n      l = m + 1;\n    }\n  }\n  return ans;\n}\nint cnt = 0;\nint main() {\n  ios::sync_with_stdio(false);\n  int i;\n  cin >> n;\n  for (i = 1; i <= n; ++i) cin >> a[i];\n  cnt = 1;\n  b[0] = a[1];\n  for (i = 2; i <= n; ++i) {\n    int t = binary(0, cnt - 1, a[i]);\n    if (t < 0)\n      b[cnt++] = a[i];\n    else\n      b[t] = a[i];\n  }\n  printf(\"%d\\n\", cnt);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:256000000\")\nusing namespace std;\nconst int maxN = 210000;\nconst int inf = 1000000000;\nint n, a[maxN], d[maxN];\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", &a[i]);\n  }\n  d[0] = -inf;\n  for (int i = 1; i <= n; ++i) {\n    d[i] = inf;\n  }\n  for (int i = 0; i < n; i++) {\n    int j = upper_bound(d, d + n + 1, a[i]) - d;\n    if (d[j - 1] < a[i] && a[i] < d[j]) {\n      d[j] = a[i];\n    }\n  }\n  for (int i = n; i >= 1; --i) {\n    if (d[i] < inf) {\n      printf(\"%d\\n\", i);\n      return 0;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "from bisect import bisect_right\ns, n = [0], input()\nfor i in map(int, raw_input().split()):\n    if i > s[-1]: s.append(i)\n    else: s[bisect_right(s, i)] = i\nprint len(s) - 1"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\n  public static void main(String[] args) {\n    ScanReader scanner = new ScanReader(System.in);\n//    Scanner scanner = new Scanner(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n    solve(scanner, out);\n    out.close();\n  }\n\n  final static int MAXN = 50005;\n  final static int MAXK = 505;\n  static int N = 0;\n  static int M = 0;\n  static int K = 0;\n  static int W = 0;\n  static int H = 0;\n  static int[] A;\n  static long[][] dp;\n  static int[][] pre;\n  static int[][] g;\n  static int curAns = Integer.MAX_VALUE;\n\n  static int[] bit;\n\n  static void add(int index, int val) {\n    while (index < N) {\n      bit[index] = Math.max(bit[index], val);\n      index |= index + 1;\n    }\n  }\n\n  static int query(int index) {\n    index = Math.min(index, N);\n    int s = 0;\n    while (index >= 0) {\n      s = Math.max(s, bit[index]);\n      index = (index & (index + 1)) - 1;\n    }\n\n    return s;\n  }\n\n  static void solve(ScanReader scanner, PrintWriter out) {\n    N = scanner.nextInt();\n    Pair[] B = new Pair[N];\n    bit = new int[N];\n    for (int i = 0; i < N; i++) {\n      int v = scanner.nextInt();\n      B[i] = new Pair(v, i);\n    }\n    Arrays.sort(B);\n\n    int ans = 0;\n    for (int i = 0; i < N; i++) {\n      Pair p = B[i];\n      add(p.y, query(p.y-1) + 1);\n      ans = Math.max(ans, query(p.y));\n    }\n    out.println(ans);\n  }\n\n\n  static class ScanReader {\n    private byte[] buf = new byte[4 * 1024];\n    private int index;\n    private BufferedInputStream in;\n    private int total;\n\n    public ScanReader(InputStream inputStream) {\n      in = new BufferedInputStream(inputStream);\n    }\n\n    private int scan() {\n      if (index >= total) {\n        index = 0;\n        try {\n          total = in.read(buf);\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n        if (total <= 0) return -1;\n      }\n      return buf[index++];\n    }\n\n    public int nextInt() {\n      int integer = 0;\n      int n = scan();\n      while (isWhiteSpace(n)) n = scan();\n      int neg = 1;\n      if (n == '-') {\n        neg = -1;\n        n = scan();\n      }\n      while (!isWhiteSpace(n)) {\n        if (n >= '0' && n <= '9') {\n          integer *= 10;\n          integer += n - '0';\n          n = scan();\n        }\n      }\n      return neg * integer;\n    }\n\n    private boolean isWhiteSpace(int n) {\n      if (n == ' ' || n == '\\n' || n == '\\r' || n == '\\t' || n == -1) return true;\n      else return false;\n    }\n\n  }\n}\n\nclass UnioinSet {\n  private Map<Long, Long> parents = new HashMap<>();\n\n  public Long find(Long u) {\n    if (parents.getOrDefault(u, u).equals(u)) {\n      return u;\n    }\n\n    return find(parents.get(u));\n  }\n\n  public void union(Long u, Long v) {\n    Long pu = find(u);\n    Long pv = find(v);\n\n    parents.put(pu, pv);\n  }\n}\n\nclass Pair implements Comparable<Pair> {\n  public int x;\n  public int y;\n\n  public Pair(int x, int y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  public int toIndex(int base) {\n    return this.x * base + this.y;\n  }\n\n  public List<Pair> neighbors() {\n    List<Pair> ans = new ArrayList<>();\n    ans.add(new Pair(this.x + 1, this.y));\n    ans.add(new Pair(this.x - 1, this.y));\n    ans.add(new Pair(this.x, this.y + 1));\n    ans.add(new Pair(this.x, this.y - 1));\n\n    return ans;\n  }\n\n  @Override\n  public int compareTo(Pair o) {\n    if (o.x != this.x) {\n      return this.x - o.x;\n    } else {\n      return this.y - o.y;\n    }\n  }\n\n  @Override\n  public int hashCode() {\n    int v = this.x * 100000 + this.y;\n    return Integer.hashCode(v);\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return true;\n    }\n    if (obj instanceof Pair) {\n      Pair op = (Pair) obj;\n      return op.x == this.x && op.y == this.y;\n    }\n\n    return false;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD9 = 1e9 + 7;\nconst long long MAX = 1e5 + 10;\nconst double eps = 0.99;\nint tree[4 * MAX];\nint a[MAX];\nint value = 0, idx = 0;\nvoid update(int node, int start, int end) {\n  if (start == end) {\n    a[idx] = value;\n    tree[node] = value;\n    return;\n  }\n  int mid = (start + end) / 2;\n  if (start <= idx && idx <= mid)\n    update(node * 2, start, mid);\n  else\n    update(node * 2 + 1, mid + 1, end);\n  tree[node] = max(tree[node * 2], tree[node * 2 + 1]);\n}\nint query(int node, int start, int end, int l, int r) {\n  if (start >= l && end <= r) {\n    return tree[node];\n  }\n  if (end < l || start > r) return 0;\n  int mid = (start + end) / 2;\n  int q = query(node * 2, start, mid, l, r);\n  q = max(q, query(node * 2 + 1, mid + 1, end, l, r));\n  return q;\n}\nbool ff[100];\nint main() {\n  ios_base::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  memset(tree, 0, sizeof(tree));\n  vector<int> vec;\n  int ma = INT_MIN;\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    vec.push_back(x);\n    ma = max(x, ma);\n  }\n  for (int i = 0; i < n; i++) {\n    value = query(1, 1, ma, 1, vec[i] - 1) + 1;\n    idx = vec[i];\n    update(1, 1, ma);\n  }\n  cout << tree[1] << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <class T>\nvoid checkmin(T &t, T x) {\n  if (x < t) t = x;\n}\ntemplate <class T>\nvoid checkmax(T &t, T x) {\n  if (x > t) t = x;\n}\nusing namespace std;\nconst int INF = 0x3fffffff;\nconst double PI = acos(-1.0);\nconst double EPS = 1e-9;\nconst int maxN = 100010;\nint a[maxN], c[maxN], len;\nint find(int L, int R, int x) {\n  if (L == R) return L;\n  int mid = (L + R) >> 1;\n  if (c[mid] < x)\n    return find(mid + 1, len, x);\n  else\n    return find(L, mid, x);\n}\nint main() {\n  int i, n, t, m, T, b, k, ans, j, max;\n  while (scanf(\"%d\", &n) != EOF) {\n    for (i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    len = 0;\n    c[0] = -INF;\n    for (i = 0; i < n; i++) {\n      if (a[i] > c[len])\n        j = ++len;\n      else\n        j = find(1, len, a[i]);\n      c[j] = a[i];\n    }\n    printf(\"%d\\n\", len);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\n\npublic class B {\t\n\tBufferedReader reader;\n    StringTokenizer tokenizer;\n    PrintWriter out;\n    \n\tpublic void solve() throws IOException {\t\t\t\t\n\t\tint N = nextInt();\t\t\n\t\tint[] m = new int[N+1];\n\t\tArrays.fill(m, Integer.MAX_VALUE);\n\t\tm[0] = 0;\n\t\tint ans = 0;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint A = nextInt();\n\t\t\tint l = 0;\n\t\t\tint r = ans;\n\t\t\twhile( l < r){\n\t\t\t\tint mid = (l+r+1)/2;\n\t\t\t\tif( m[mid] < A)\n\t\t\t\t\tl = mid;\n\t\t\t\telse\n\t\t\t\t\tr = mid-1;\n\t\t\t}\n\t\t\t\n\t\t\tm[l+1] = Math.min(m[l+1], A);\n\t\t\tans = Math.max(ans, l+1);\n\t\t\t\n//\t\t\tout.println( m[0] + \", \" + m[1] + \", \" + m[2]);\n\t\t}\n\t\tout.println( ans );\n\t}\n\t\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\tnew B().run();\n\t}\n\t\n\tpublic void run() {\n        try {\n            reader = new BufferedReader(new InputStreamReader(System.in));\n            tokenizer = null;\n            out = new PrintWriter(System.out);\n            solve();\n            reader.close();\n            out.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    String nextToken() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n}\n"
        },
        {
            "language": 3,
            "solution": "from bisect import bisect_right\ns, n = [0], input()\nfor i in map(int, input().split()):\n    if i > s[-1]: s.append(i)\n    else: s[bisect_right(s, i)] = i\nprint(len(s) - 1)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:16777216\")\nusing namespace std;\nint n, T[100011];\nint get(int i) {\n  int res = 0;\n  while (i) {\n    res = max(res, T[i]);\n    i -= i & (-i);\n  }\n  return res;\n}\nvoid update(int i, int d) {\n  while (i <= n) {\n    T[i] = max(T[i], d);\n    i += i & (-i);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin >> n;\n  for (int i = (1), _b = (n); i <= _b; i++) {\n    int x;\n    cin >> x;\n    int k = get(x - 1);\n    update(x, k + 1);\n  }\n  cout << get(n) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint arr[100001], i, n, d[100001], p[100001], ans[100001], q, t, aa[100001];\nint main() {\n  cin >> n;\n  for (i = 0; i < n; i++) cin >> arr[i];\n  d[0] = -INT_MAX;\n  for (i = 1; i <= n; i++) d[i] = INT_MAX;\n  for (i = 0; i < n; i++) {\n    int j = int(upper_bound(d, d + n, arr[i]) - d);\n    if ((d[j - 1] < arr[i]) && (d[j] > arr[i])) {\n      d[j] = arr[i];\n      p[j] = i;\n      ans[i] = p[j - 1];\n    }\n  }\n  for (i = 1; i <= n; i++) {\n    if (d[i] != INT_MAX) t = i;\n  }\n  cout << t << endl;\n  aa[0] = p[t] + 1;\n  int o = t;\n  t = p[t];\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint a[100010], ans[100010];\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) {\n    ans[i] = 1000000;\n    scanf(\"%d\", &a[i]);\n  }\n  ans[n] = 1000000;\n  ans[0] = -1;\n  for (int i = 0; i < n; ++i) {\n    int l = 0;\n    int r = i + 1;\n    while (l + 1 < r) {\n      int mid = (l + r) / 2;\n      if (ans[mid] < a[i])\n        l = mid;\n      else\n        r = mid;\n    }\n    ans[l + 1] = min(ans[l + 1], a[i]);\n  }\n  for (int i = n; i > 0; --i)\n    if (ans[i] < 1000000) {\n      printf(\"%d\\n\", i);\n      return 0;\n    }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst long long LINF = 0x3f3f3f3f3f3f3f3fll;\nconst int MAXN = 1e5 + 10;\nint v[MAXN];\nint lis[MAXN];\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int a = 0; a < n; ++a) scanf(\"%d\", &v[a]);\n  memset(lis, INF, sizeof(lis));\n  for (int a = 0; a < n; ++a) {\n    int i = lower_bound(lis, lis + n, v[a]) - lis;\n    lis[i] = v[a];\n  }\n  int hi = 0;\n  for (int a = 0; a < n; ++a)\n    if (lis[a] != INF) hi = a;\n  printf(\"%d\\n\", hi + 1);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int N;\n  cin >> N;\n  int a[100010] = {0}, dp[100010] = {0};\n  for (int i = 0; i < N; i++) scanf(\"%d\", &a[i]);\n  int lis = 1;\n  dp[1] = a[0];\n  for (int i = 1; i < N; i++) {\n    int pos = upper_bound(dp + 1, dp + lis + 1, a[i]) - dp;\n    dp[pos] = a[i];\n    lis = max(lis, pos);\n  }\n  cout << lis;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n  int N;\n  scanf(\"%d\", &N);\n  static int data[100500];\n  for (int i = 0; i < N; i++) scanf(\"%d\", data + i);\n  vector<int> min_of_len;\n  for (int i = 0; i < N; i++) {\n    int idx = upper_bound(min_of_len.begin(), min_of_len.end(), data[i]) -\n              min_of_len.begin();\n    if (idx == min_of_len.size())\n      min_of_len.push_back(data[i]);\n    else\n      min_of_len[idx] = data[i];\n  }\n  cout << min_of_len.size() << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Main implements Runnable {\n\t\t\n\tpublic void solve() throws IOException {\n\t\t//Longest increasing subsequence\n            int N = nextInt();\n            int[] a = new int[N];\n            for(int i = 0; i < N; i++) a[i] = nextInt();\n            \n            int INF = 100000000;\n            int[] d = new int[N+10];\n            Arrays.fill(d, INF);\n            \n            d[0] = 0;\n            for(int i = 0; i < N; i++){\n                int left = 0, right = i+1;\n                while(left < right){\n                    int mid = (left + right) >> 1;\n                    if(d[mid] <= a[i])\n                        left = mid + 1;\n                    else\n                        right = mid;\n                }\n              \n                d[left] = Math.min(d[left], a[i]);\n            }\n            \n            //print1Int(d);\n            int lis = 0;\n            while(d[lis+1] != INF) lis++;\n            \n            out.println(lis);\n\t}\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t//-----------------------------------------------------------\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n        public void print1Int(int[] a){\n                for(int i = 0; i < a.length; i++)\n                        System.out.print(a[i] + \" \");\n                System.out.println();\n        }\n        \n        public void print2Int(int[][] a){\n                for(int i = 0; i < a.length; i++){\n                        for(int j = 0; j < a[0].length; j++){\n                                System.out.print(a[i][j] + \" \");\n                        }\n                        System.out.println();\n                }\n        }\n        \n\tpublic void run() {\n\t\ttry {\n                        out = new PrintWriter(System.out);\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\ttok = null;\n\t\t\tsolve();\n\t\t\tin.close();\n                        out.close();\n\t\t} catch (IOException e) {\n\t\t\tSystem.exit(0);\n\t\t}\n\t}\n\n\tpublic String nextToken() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tpublic long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tpublic double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n        PrintWriter out;\n\tBufferedReader in;\n\tStringTokenizer tok;\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, a[100005], x, ans;\nconst int inf = 99999999;\nint main(int argc, char **argv) {\n  while (~scanf(\"%d\", &n)) {\n    for (int i = 0; i <= n; ++i) a[i] = inf;\n    ans = 0;\n    for (int i = 0; i < n; ++i) {\n      scanf(\"%d\", &x);\n      int p = lower_bound(a, a + n, x) - a;\n      a[p] = x;\n      ans = max(ans, p);\n    }\n    printf(\"%d\\n\", ans + 1);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint arr[100000];\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) scanf(\"%d\", &arr[i]);\n  set<int> st;\n  typeof(st.begin()) it;\n  for (int i = 0; i < n; i++) {\n    st.insert(arr[i]);\n    it = st.find(arr[i]);\n    it++;\n    if (it != st.end()) st.erase(it);\n  }\n  cout << st.size() << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline T MAX(T a, T b) {\n  if (a > b) return a;\n  return b;\n}\ntemplate <class T>\ninline T MIN(T a, T b) {\n  if (a < b) return a;\n  return b;\n}\ntemplate <class T>\ninline T ABS(T x) {\n  if (x < 0) return -x;\n  return x;\n}\ninline void OPEN(const string &s) {\n  freopen((s + \".in\").c_str(), \"r\", stdin);\n  freopen((s + \".out\").c_str(), \"w\", stdout);\n}\nconst static int inf = 1000000000;\nint n, arr[100005];\nint LIS[100005];\nint main() {\n  scanf(\"%d\", &n);\n  for (int(i) = (0); (i) < (n); ++(i)) {\n    scanf(\"%d\", &arr[i]);\n    LIS[i + 1] = inf;\n  }\n  int res = 0;\n  for (int(i) = (0); (i) < (n); ++(i)) {\n    int l = 1, h = res;\n    while (l <= h) {\n      int m = (l + h) / 2;\n      if (LIS[m] < arr[i])\n        l = m + 1;\n      else\n        h = m - 1;\n    }\n    if (LIS[l] > arr[i]) LIS[l] = arr[i];\n    res = max(res, l);\n  }\n  printf(\"%d\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxN = 1e5 + 10;\nint n, a[maxN], len, t[maxN];\nint main() {\n  cin >> n;\n  t[0] = maxN;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  for (int i = 0; i < n; i++) {\n    int x = lower_bound(t, t + len, a[i]) - t;\n    t[x] = a[i];\n    if (x == len) t[++len] = maxN;\n  }\n  cout << len;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint uppbound(int *len, int k, int N) {\n  int a = 0;\n  int b = N;\n  int c = (a + b) / 2;\n  while (a != b) {\n    if (len[c] >= k) {\n      b = c;\n    } else {\n      a = c + 1;\n    }\n    c = (a + b) / 2;\n  }\n  return b;\n}\nvoid NVP(int *len, int k, int N) {\n  int a = uppbound(len, k, N);\n  len[a] = k;\n}\nint main() {\n  int N;\n  scanf(\"%d\", &N);\n  int *mas = new int[N];\n  for (int i = 0; i < N; i++) scanf(\"%d\", &mas[i]);\n  int *len = new int[N + 1];\n  for (int i = 0; i <= N; i++) {\n    len[i] = 1000001;\n  }\n  len[0] = -1000001;\n  for (int i = 0; i < N; i++) {\n    NVP(len, mas[i], N);\n  }\n  int i = 0;\n  while ((len[i] != 1000001) && (i <= N)) {\n    i++;\n  }\n  cout << i - 1;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint LIS(vector<int> A) {\n  int N = A.size(), i;\n  set<int> s;\n  set<int>::iterator k;\n  for (i = 0; i < N; i++) {\n    if (s.insert(A[i]).second) {\n      k = s.find(A[i]);\n      k++;\n      if (k != s.end()) s.erase(k);\n    }\n  }\n  return s.size();\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  int n;\n  cin >> n;\n  vector<int> v(n);\n  for (int i = 0; i < n; i++) {\n    cin >> v[i];\n  }\n  cout << LIS(v) << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint a[100010];\nint f[100010];\nint main() {\n  while (cin >> n) {\n    for (int i = 1; i <= n; ++i) scanf(\"%d\", a + i);\n    int ans = 1;\n    f[1] = a[1];\n    for (int i = 2; i <= n; ++i) {\n      int pos = lower_bound(f, f + ans, a[i]) - f;\n      if (a[i] >= f[pos])\n        f[++ans] = a[i];\n      else\n        f[pos] = a[i];\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.awt.Point;\n\npublic class CodeForces {\n    static boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n    private final long MOD = 1000000009;\n\n\n    void runCase(int caseNum) throws IOException {\n        int n = nextInt();\n        int[] nums = new int[n];\n        for (int i = 0; i < n; ++i)\n            nums[i] = nextInt();\n        int[] d = new int[n];\n        int p = 0;\n        for (int i = 0; i < n; ++i) {\n            int left = 0;\n            int right = p;\n            while (left < right) {\n                int mid = (left + right) / 2;\n                if (d[mid] < nums[i])\n                    left = mid + 1;\n                else if (d[mid] > nums[i])\n                    right = mid;\n            }\n            if (right == p)\n                ++p;\n            d[right] = nums[i];\n        }\n        System.out.println(p);\n    }\n\n\n    public static void main(String[] args) throws IOException {\n        if (ONLINE_JUDGE){\n            System.out.println();\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        }else{\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new PrintWriter(System.out);\n            //out = new PrintWriter(\"output.txt\");\n        }\n        new CodeForces().runIt();\n        out.flush();\n        out.close();\n        return;\n    }\n\n    static BufferedReader in;\n    private StringTokenizer st;\n    static PrintWriter out;\n\n    static int pos;\n    static String curInput = \"\";\n\n    String next() throws IOException {\n        while (!st.hasMoreTokens()) {\n            String line = in.readLine();\n            if (line == null) {\n                return null;\n            }\n            st = new StringTokenizer(line);\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n\n    void runIt() throws IOException {\n        st = new StringTokenizer(\"\");\n\n//        int N = nextInt();\n//        for (int i = 0; i < N; i++) {\n//            runCase(i + 1);\n//        }\n        runCase(0);\n        out.flush();\n    }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid openfile() {}\nconst int N = 1e5 + 22;\nint dp[N], c[N], a[N];\nint main() {\n  openfile();\n  int i, j, n;\n  while (cin >> n) {\n    for (i = 1; i <= n; ++i) cin >> a[i];\n    c[1] = a[1];\n    dp[1] = 1;\n    int mx = 1;\n    for (i = 2; i <= n; ++i) {\n      if (c[mx] < a[i]) {\n        c[++mx] = a[i];\n        dp[i] = mx;\n      } else {\n        int tmp = lower_bound(c + 1, c + mx + 1, a[i]) - c;\n        c[tmp] = a[i];\n        dp[i] = tmp;\n      }\n    }\n    cout << mx << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, x, a[100005], cnt;\nint main() {\n  int i, j, k;\n  while (scanf(\"%d\", &n) == 1) {\n    cnt = 0;\n    for (i = 0; i < n; i++) {\n      scanf(\"%d\", &x);\n      if (cnt == 0 || x > a[cnt - 1])\n        a[cnt++] = x;\n      else {\n        k = lower_bound(a, a + cnt, x) - a;\n        a[k] = x;\n      }\n    }\n    printf(\"%d\\n\", cnt);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ndouble PI = 4.00 * (atan(1));\nlong long int ceilfind(long long int endlen[], long long int start,\n                       long long int end, long long int key) {\n  long long int mid;\n  while ((end - start) > 1) {\n    mid = (end + start) / 2;\n    if (endlen[mid] >= key) {\n      end = mid;\n    } else {\n      start = mid;\n    }\n  }\n  return end;\n}\nlong long int LIS(long long int arr1[], long long int n) {\n  long long int endpos[n];\n  for (long long int i = 1; i < n; i++) {\n    endpos[i] = -1;\n  }\n  endpos[0] = arr1[0];\n  long long int currend = 0;\n  for (long long int i = 1; i < n; i++) {\n    if (arr1[i] < endpos[0]) {\n      endpos[0] = arr1[i];\n      continue;\n    }\n    if (arr1[i] > endpos[currend]) {\n      currend++;\n      endpos[currend] = arr1[i];\n      continue;\n    }\n    long long int val1 = ceilfind(endpos, -1, currend, arr1[i]);\n    endpos[val1] = arr1[i];\n  }\n  return currend + 1;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long int n;\n  cin >> n;\n  long long int arr1[n];\n  for (long long int i = 0; i < n; i++) {\n    cin >> arr1[i];\n  }\n  long long int ans = LIS(arr1, n);\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.io.PrintWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass TaskD {\n    public void solve(int testNumber, Scanner in, PrintWriter out) {\n        int n = in.nextInt();\n        int[] arr = new int[n];\n        for (int i = 0; i < n; ++i) arr[i] = in.nextInt();\n        int[] minTail = new int[n + 1];\n        Arrays.fill(minTail, Integer.MAX_VALUE);\n        for (int i = 0; i < n; ++i) {\n            int l, r;\n            for (l = 1, r = n + 1; l < r;) {\n                int mid = l + (r - l) / 2;\n                if (arr[i] >= minTail[mid]) l = mid + 1;\n                else r = mid;\n            }\n            minTail[l] = arr[i];\n        }\n        int ret = 0;\n        for (int i = 1; i <= n; ++i) if (minTail[i] < Integer.MAX_VALUE)\n            ret = Math.max(i, ret);\n        out.println(ret);\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> v(n), dp(n + 1);\n  fill(dp.begin(), dp.end(), 1000000000);\n  dp[0] = 0;\n  for (auto &x : v) cin >> x;\n  for (int i = 0; i < n; i++) {\n    int x = v[i];\n    int lo = 0, hi = n;\n    while (lo < hi) {\n      int mi = (lo + hi + 1) / 2;\n      if (dp[mi] < x)\n        lo = mi;\n      else\n        hi = mi - 1;\n    }\n    dp[lo + 1] = min(dp[lo + 1], x);\n  }\n  for (int i = n; i >= 0; i--) {\n    if (dp[i] <= n) {\n      cout << i << endl;\n      return 0;\n    }\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class _Bubble_sort_graph {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scn = new Scanner(System.in);\n\t\tint n = scn.nextInt();\n\t\tint[] arr = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarr[i] = scn.nextInt();\n\t\t}\n\t\tint[] temp = new int[n];\n\t\tint len = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (arr[i] > arr[temp[len]]) {\n\t\t\t\ttemp[len + 1] = i;\n\t\t\t\tlen++;\n\t\t\t} else if (arr[i] < arr[temp[0]]) {\n\t\t\t\ttemp[0] = i;\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tint v=CeilIndex(temp, 0, len, arr[i],arr);\n\t\t\t\t\n\t\t\t\ttemp[v]=i;\n\t\t\t\t\t\t\t}\n\t\t}\n\t\tSystem.out.println(len+1);\n\t}\n\t static int CeilIndex(int A[], int l, int r, int key,int []arr) \n\t    { \n\t        while (r - l > 1) { \n\t            int m = l + (r - l) / 2; \n\t            if (arr[A[m]] >= key) \n\t                r = m; \n\t            else\n\t                l = m; \n\t        } \n\t  \n\t        return r; \n\t    } \n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 29;\nconst int N = 100007;\nint n, a[N], dp[N];\nint main() {\n  int res = 0;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", &a[i]);\n    dp[i + 1] = INF;\n  }\n  dp[0] = -INF;\n  for (int i = 0; i < n; ++i) {\n    int j = upper_bound(dp, dp + n, a[i]) - dp;\n    if (dp[j] > a[i] && dp[j - 1] < a[i]) dp[j] = a[i];\n  }\n  for (int i = 1; i <= n; ++i)\n    if (dp[i] != INF) res = i;\n  printf(\"%d\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong binarySearch(long x, long s, long L, vector<long> &X, vector<long> &M) {\n  if (s == L - 1) {\n    if (X[M[s]] < x)\n      return s;\n    else\n      return -1;\n  }\n  if (X[M[(L + s) / 2]] <= x)\n    return binarySearch(x, (L + s) / 2, L, X, M);\n  else\n    return binarySearch(x, s, (L + s) / 2, X, M);\n  return -1;\n}\nint main() {\n  long n;\n  cin >> n;\n  vector<long> X(n), P(n, -1), M(n, -1);\n  long L = 0;\n  for (int i = 0; i < n; i++) {\n    cin >> X[i];\n    long j = L - 1;\n    if (L) j = binarySearch(X[i], 0, L, X, M);\n    if (j == L - 1) {\n      L++;\n      M[L - 1] = i;\n    } else if (X[i] < X[M[j + 1]])\n      M[j + 1] = i;\n  }\n  cout << L << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint tab[100005], z, n, a, i, j;\nint* it;\nint main() {\n  scanf(\"%d\", &n);\n  for (j = 0; j <= n; ++j) tab[j] = 2000000001;\n  for (j = 0; j < n; ++j) {\n    scanf(\"%d\", &a);\n    it = lower_bound(tab, tab + n, a);\n    *it = a;\n  }\n  for (j = 0; j <= n; ++j)\n    if (tab[j] == 2000000001) break;\n  printf(\"%d\\n\", j);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100010;\nint n, a[maxn], par[maxn];\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  vector<int> lis;\n  lis.push_back(a[0]);\n  for (int i = 1; i < n; i++) {\n    if (a[i] > lis[lis.size() - 1]) {\n      lis.push_back(a[i]);\n      par[a[i]] = lis[lis.size() - 2];\n      continue;\n    }\n    int low = lower_bound(lis.begin(), lis.end(), a[i]) - lis.begin();\n    lis[low] = a[i];\n    if (low == 0)\n      par[a[i]] = -1;\n    else\n      par[a[i]] = lis[low - 1];\n  }\n  cout << lis.size() << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000009;\nconst int MOD = 1000000007;\nint T[5000009];\nstruct fenwick {\n  int sum(int i) {\n    int s = 0;\n    for (; i > 0; i -= (i & -i)) {\n      s = max(T[i], s);\n    }\n    return s;\n  }\n  void update(int i, int v) {\n    for (; i < 1000009; i += (i & -i)) {\n      T[i] = max(T[i], v);\n    }\n  }\n};\nint N;\nvector<int> V;\nmap<int, int> MP;\nmap<int, int> RE;\nint main() {\n  int N;\n  cin >> N;\n  for (int i = 0; i < N; i++) {\n    int num;\n    cin >> num;\n    V.push_back(num);\n  }\n  vector<int> aux = V;\n  fenwick F;\n  sort(aux.begin(), aux.end());\n  int k = 1;\n  for (int i = 0; i < N; i++) {\n    if (!MP.count(aux[i])) {\n      MP[aux[i]] = k;\n      RE[k] = aux[i];\n      k++;\n    }\n  }\n  int mm = 0;\n  set<pair<int, int> > S;\n  for (int i = 0; i < N; i++) {\n    int num = MP[V[i]];\n    int v = F.sum(num - 1);\n    F.update(num, v + 1);\n    mm = max(v + 1, mm);\n  }\n  cout << mm << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, vet[100001], aux[100001];\nint solve() {\n  int r = 0;\n  for (int i = 1; i <= n; ++i) {\n    int v = vet[i];\n    int p = lower_bound(aux, aux + n + 1, v) - aux;\n    aux[p] = v;\n    r = max(r, p);\n  }\n  return r;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", vet + i), aux[i] = n + 1;\n  printf(\"%d\\n\", solve());\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint ceilIndex(vector<int> v, int l, int r, int x) {\n  while (r - l > 1) {\n    int mid = l + (r - l) / 2;\n    if (v[mid] >= x)\n      r = mid;\n    else\n      l = mid;\n  }\n  return r;\n}\nint main() {\n  int n, i;\n  scanf(\"%d\", &n);\n  int ar[n + 5];\n  vector<int> tail;\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", &ar[i]);\n    tail.push_back(0);\n  }\n  tail[0] = ar[0];\n  int len = 1;\n  for (i = 1; i < n; i++) {\n    auto b = tail.begin(), e = tail.begin() + len;\n    auto it = lower_bound(b, e, ar[i]);\n    if (it == tail.begin() + len)\n      tail[len++] = ar[i];\n    else\n      *it = ar[i];\n  }\n  printf(\"%d\\n\", len);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> dp;\n  for (int i = 0; i < n; i++) {\n    int a;\n    cin >> a;\n    auto p = lower_bound(dp.begin(), dp.end(), a);\n    if (p == dp.end()) {\n      dp.emplace_back(a);\n    } else if (*p > a) {\n      *p = a;\n    }\n  }\n  cout << (int)dp.size();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\n\n/**\n *\n * @author Assassin\n */\nimport java.io.*;\nimport java.util.*;\n\npublic class D {\n\n    private static BufferedReader reader;\n    private static PrintWriter out;\n    private static StringTokenizer tokenizer;\n    //private final static String filename = \"filename\";\n\n    private static void init(InputStream input, OutputStream output) throws IOException {\n        reader = new BufferedReader(new InputStreamReader(input));\n        out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(output)));\n        //reader = new BufferedReader(new FileReader(filename + \".in\"));\n        //out = new PrintWriter(new BufferedWriter(new FileWriter(filename + \".out\")));\n        tokenizer = new StringTokenizer(\"\");\n    }\n\n    private static String nextLine() throws IOException {\n        return reader.readLine();\n    }\n\n    private static String next() throws IOException {\n        while (!tokenizer.hasMoreTokens())\n            tokenizer = new StringTokenizer(nextLine());\n        return tokenizer.nextToken();\n    }\n\n    private static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    private static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    private static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) throws IOException {\n        init(System.in, System.out);\n        //long startTime = System.currentTimeMillis();\n        int n = nextInt();\n        int[] a = new int[n + 100];\n        int m = 1;\n        int temp;\n        int l, r, h;\n        a[1] = Integer.MAX_VALUE;\n        for (int i = 0; i < n; i++) {\n            temp = nextInt();\n            l = 0;\n            r = m;\n            while (l < r) {\n                h = (l + r) / 2;\n                if (a[h] > temp)\n                    r = h;\n                else\n                    l = h + 1;\n            }\n            a[r] = temp;\n            if (r == m)\n                a[++m] = Integer.MAX_VALUE;\n        }\n        out.println(m - 1);\n        //long runTime = System.currentTimeMillis() - startTime;\n        //out.write(runTime + \"\\n\");\n        out.close();\n        reader.close();\n        System.exit(0);\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int lis(long long int *a, long long int n) {\n  set<long long int> s;\n  long long int i;\n  for (i = 0; i < n; i++) {\n    auto it = s.upper_bound(a[i]);\n    if (it == s.end()) {\n      s.insert(a[i]);\n    } else {\n      s.erase(it);\n      s.insert(a[i]);\n    }\n  }\n  return s.size();\n}\nint main() {\n  long long int i, n, a[100010];\n  cin >> n;\n  for (i = 0; i < n; i++) cin >> a[i];\n  cout << lis(a, n) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic class LIS\n{\n    static int n, a[], end[];\n    public static void main(String[] args)\n    {\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt(); a = new int[n]; end = new int[n+2];\n        for(int i = 0; i < n; i++) a[i] = in.nextInt();\n        for(int i = 1; i < end.length; i++)\n            end[i] = (1 << 25) + i;\n        for(int i = 0; i < a.length; i++)\n        {\n            int j = Arrays.binarySearch(end,a[i]);\n            if(j < 0) j = ~j;\n            end[j] = a[i];\n        }\n        for(int i = 0; i < end.length; i++)\n            if(end[i] >= (1<<25)) {\n                System.out.println(i-1); break;\n            }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "n = int(input())\na= list(map(int,input().split()))\nbit = [0]*(n+1)\ndef update(idx,val):\n    while idx<=n:\n        bit[idx] = max(bit[idx],val)\n        idx+=idx&(-idx)\ndef query(idx):\n    res =0\n    while idx>0:\n        res = max(res,bit[idx])\n        idx-=idx&(-idx)\n    return res\nb = []\nfor i in range(n):\n    b.append([a[i],-(i+1)])\nb.sort()\nfor i in range(n):\n    qe = query(-b[i][1])\n    update(-b[i][1],qe+1)\nprint(query(n))"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.*;\nimport java.io.*;\n\n/**\n *\n * @author usquare\n * \n */\n\npublic class ProblemA {\n\n    public static int mod = (int) (1e9+7);\n    public static InputReader in;\n    public static PrintWriter out;\n    public static int[] bit;\n    \n    public static void update(int i,int d){\n\n        for(;i<bit.length;i+=(i&-i))\n            bit[i]=max(d,bit[i]);\n\n    }\n    \n    public static int query(int i){\n        int ans=0;\n        \n        for(;i>0;i-=(i&-i))\n            ans=max(ans,bit[i]);\n        \n        return ans;\n    }\n\n    public static void main(String[] args) throws FileNotFoundException {\n\n        in = new InputReader(System.in);\n        out = new PrintWriter(System.out);\n        \n        int n=in.nextInt();\n        int[] arr=new int[n+1];\n        \n        for(int i=1;i<=n;i++) arr[i]=in.nextInt();\n        bit=new int[n+1];\n        \n        for(int i=1;i<=n;i++){\n            int x=query(arr[i]-1);\n            update(arr[i], x+1);\n        }\n        \n        out.println(query(n));\n        \n        out.close();\n    }\n    \n    static class Pair implements Comparable<Pair>{\n\n        int x,y;\n        \n//\tPair (int x,int y,int i){\n//\t\tthis.x=x;\n//\t\tthis.y=y;\n//\t\tthis.i=i;\n//\t}\n\n\tPair (int x,int y){\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t}\n        \n\tpublic int compareTo(Pair o) {\n                    return Integer.compare(this.x,o.x);\n\t\t//return 0;\n\t}\n\n            public boolean equals(Object o) {\n            if (o instanceof Pair) {\n                Pair p = (Pair)o;\n                return p.x == x && p.y == y ;\n            }\n            return false;\n        }\n        public int hashCode() {\n            return new Integer(x).hashCode() * 31 + new Integer(y).hashCode();\n        }\n    \n    } \n    \n    static long[] shuffle(long[] a, Random gen){ \n        for(int i = 0, n = a.length;i < n;i++){ \n            int ind = gen.nextInt(n-i)+i; \n            long d = a[i]; \n            a[i] = a[ind]; \n            a[ind] = d; \n        } \n        return a; \n    }\n\n        \n    public static long add(long a,long b){\n        long x=(a+b);\n        while(x>=mod) x-=mod;\n        return x;\n    }\n\n    public static long sub(long a,long b){\n        long x=(a-b);\n        while(x<0) x+=mod;\n        return x;\n    }\n    \n    public static long mul(long a,long b){\n        a%=mod;\n        b%=mod;\n        long x=(a*b);\n        return x%mod;\n    }\n    \n    static boolean isPal(String s){\n        for(int i=0, j=s.length()-1;i<=j;i++,j--){\n                if(s.charAt(i)!=s.charAt(j)) return false;\n        }\n        return true;\n    }\n    static String rev(String s){\n            StringBuilder sb=new StringBuilder(s);\n            sb.reverse();\n            return sb.toString();\n    }\n\n    static long gcd(long x,long y){\n        if(y==0) return x;\n    if(x%y==0)\n            return y;\n    else\n            return gcd(y,x%y);\n    }\n\n    static int gcd(int x,int y){\n        if(y==0) return x;\n    if(x%y==0)\n            return y;\n    else \n            return gcd(y,x%y);\n    }\n\n    static long gcdExtended(long a,long b,long[] x){\n\n        if(a==0){\n            x[0]=0;\n            x[1]=1;\n            return b;\n        }\n        long[] y=new long[2];\n        long gcd=gcdExtended(b%a, a, y);\n\n        x[0]=y[1]-(b/a)*y[0];\n        x[1]=y[0];\n\n        return gcd;\n    }\n\n    static int abs(int a,int b){\n    return (int)Math.abs(a-b);\n    }\n\n    static long abs(long a,long b){\n    return (long)Math.abs(a-b);\n    }\n\n    static int max(int a,int b){\n    if(a>b)\n            return a;\n    else\n            return b;\n    }\n\n    static int min(int a,int b){\n    if(a>b)\n            return b;\n    else \n            return a;\n    }\n\n    static long max(long a,long b){\n    if(a>b)\n            return a;\n    else\n            return b;\n    }\n\n    static long min(long a,long b){\n    if(a>b)\n            return b;\n    else \n            return a;\n    }\n\n\n    public static long pow(long n,long p,long m){\n\t long  result = 1;\n\t  if(p==0)\n\t    return 1;\n          \n\twhile(p!=0)\n\t{\n\t    if(p%2==1)\n\t        result *= n;\n\t    if(result>=m)\n\t    result%=m;\n\t    p >>=1;\n\t    n*=n;\n\t    if(n>=m)\n\t    n%=m;\n\t}\n\treturn result;\n    }\n    \n    public static long pow(long n,long p){\n\tlong  result = 1;\n\t  if(p==0)\n\t    return 1;\n          \n\twhile(p!=0)\n\t{\n\t    if(p%2==1)\n\t        result *= n;\t    \n\t    p >>=1;\n\t    n*=n;\t    \n\t}\n\treturn result;\n    }\n    \n     static void debug(Object... o) {\n            System.out.println(Arrays.deepToString(o));\n    }\n\n    static class InputReader {\n\n            private final InputStream stream;\n            private final byte[] buf = new byte[8192];\n            private int curChar, snumChars;\n            private SpaceCharFilter filter;\n\n            InputReader(InputStream stream) {\n                    this.stream = stream;\n            }\n\n            int snext() {\n                    if (snumChars == -1)\n                            throw new InputMismatchException();\n                    if (curChar >= snumChars) {\n                            curChar = 0;\n                            try {\n                                    snumChars = stream.read(buf);\n                            } catch (IOException e) {\n                                    throw new InputMismatchException();\n                            }\n                            if (snumChars <= 0)\n                                    return -1;\n                    }\n                    return buf[curChar++];\n            }\n\n            int nextInt() {\n                    int c = snext();\n                    while (isSpaceChar(c)) {\n                            c = snext();\n                    }\n                    int sgn = 1;\n                    if (c == '-') {\n                            sgn = -1;\n                            c = snext();\n                    }\n                    int res = 0;\n                    do {\n                            if (c < '0' || c > '9')\n                                    throw new InputMismatchException();\n                            res *= 10;\n                            res += c - '0';\n                            c = snext();\n                    } while (!isSpaceChar(c));\n                    return res * sgn;\n            }\n\n            long nextLong() {\n                    int c = snext();\n                    while (isSpaceChar(c)) {\n                            c = snext();\n                    }\n                    int sgn = 1;\n                    if (c == '-') {\n                            sgn = -1;\n                            c = snext();\n                    }\n                    long res = 0;\n                    do {\n                            if (c < '0' || c > '9')\n                                    throw new InputMismatchException();\n                            res *= 10;\n                            res += c - '0';\n                            c = snext();\n                    } while (!isSpaceChar(c));\n                    return res * sgn;\n            }\n\n            int[] nextIntArray(int n) {\n                    int a[] = new int[n];\n                    for (int i = 0; i < n; i++) {\n                            a[i] = nextInt();\n                    }\n                    return a;\n            }\n\n            long[] nextLongArray(int n) {\n                    long a[] = new long[n];\n                    for (int i = 0; i < n; i++) {\n                            a[i] = nextInt();\n                    }\n                    return a;\n            }\n\n            String readString() {\n                    int c = snext();\n                    while (isSpaceChar(c)) {\n                            c = snext();\n                    }\n                    StringBuilder res = new StringBuilder();\n                    do {\n                            res.appendCodePoint(c);\n                            c = snext();\n                    } while (!isSpaceChar(c));\n                    return res.toString();\n            }\n\n            String nextLine() {\n                    int c = snext();\n                    while (isSpaceChar(c))\n                            c = snext();\n                    StringBuilder res = new StringBuilder();\n                    do {\n                            res.appendCodePoint(c);\n                            c = snext();\n                    } while (!isEndOfLine(c));\n                    return res.toString();\n            }\n\n            boolean isSpaceChar(int c) {\n                    if (filter != null)\n                            return filter.isSpaceChar(c);\n                    return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n            }\n\n            private boolean isEndOfLine(int c) {\n                    return c == '\\n' || c == '\\r' || c == -1;\n            }\n\n            interface SpaceCharFilter {\n                    boolean isSpaceChar(int ch);\n            }\n    }\n}    \n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int bit[100009] = {0}, m = -1, n;\nvoid update(long long int i, long long int val) {\n  while (i <= n) {\n    bit[i] = max(val, bit[i]);\n    i += (i & (-i));\n  }\n}\nlong long int query(long long int i) {\n  long long int sum = 0;\n  while (i > 0) {\n    sum = max(sum, bit[i]);\n    i -= (i & (-i));\n  }\n  return sum;\n}\nint main() {\n  cin.tie(0);\n  cout.tie(0);\n  ios::sync_with_stdio(false);\n  long long int i, x;\n  cin >> n;\n  for (i = 0; i < n; i++) {\n    cin >> x;\n    m = max(m, x);\n    update(x, query(x - 1) + 1);\n  }\n  cout << query(n) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) cin >> a[i];\n  set<int> st;\n  set<int>::iterator it;\n  for (int i = 0; i < n; i++) {\n    st.insert(a[i]);\n    it = st.find(a[i]);\n    it++;\n    if (it != st.end()) st.erase(it);\n  }\n  cout << st.size() << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T, typename U>\ninline void smin(T &a, U b) {\n  if (a > b) a = b;\n}\ntemplate <typename T, typename U>\ninline void smax(T &a, U b) {\n  if (a < b) a = b;\n}\nint a[100100];\nint arr[100100];\nint main() {\n  int n;\n  cin >> n;\n  memset(arr, 0x3f, sizeof(arr));\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", a + i);\n  }\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    int j = lower_bound(arr, arr + n, a[i]) - arr;\n    arr[j] = a[i];\n    smax(ans, j + 1);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nset<int> s;\nint num[100009];\nint n;\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> num[i];\n  int mx = 0;\n  set<int>::iterator iter;\n  for (int i = 0; i < n; i++) {\n    s.insert(num[i]);\n    iter = s.find(num[i]);\n    iter++;\n    if (iter != s.end()) s.erase(iter);\n  }\n  cout << s.size() << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nistream &operator>>(istream &in, vector<T> &vec) {\n  for (int i = 0; i < vec.size(); ++i) in >> vec[i];\n  return in;\n}\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &vec) {\n  for (int i = 0; i < vec.size(); ++i) out << vec[i] << \" \";\n  return out;\n}\nvoid ans(int v = -1e9) {\n  if (v == -1e9)\n    cout << \"YES\" << endl;\n  else\n    cout << v << endl;\n  exit(0);\n}\nvoid err(bool check = 1) {\n  if (check)\n    cout << \"NO\" << endl;\n  else\n    cout << -1 << endl;\n  exit(0);\n}\nconst int INF = 1e5 + 1;\nint tree[INF];\nlong long a, b;\nvoid seter(int i, int dx) {\n  for (; i <= a; i |= i + 1) {\n    tree[i] = max(tree[i], dx);\n  }\n}\nint geter(int i) {\n  int res = 0;\n  for (; i > 0; i = (i & (i + 1)) - 1) {\n    res = max(res, tree[i]);\n  }\n  return res;\n}\nvoid solve() {\n  cin >> a;\n  vector<int> x(a);\n  cin >> x;\n  vector<int> pref(a);\n  pref[0] = 1;\n  seter(x[0], 1);\n  for (int i = 1; i < a; ++i) {\n    int f = geter(x[i]);\n    seter(x[i], f + 1);\n  }\n  int res = 0;\n  for (int i = 1; i <= a; ++i) {\n    res = max(res, geter(i));\n  }\n  cout << res << endl;\n}\nint main(int argv, char *argc[]) {\n  ios::sync_with_stdio(false);\n  cout.setf(ios::fixed);\n  cout.precision(12);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, ans;\nint ar[100003];\nint tree[4 * 100003];\nint Query(int cx, int cy, int qx, int qy, int pos) {\n  if (cy < qx || qy < cx) return 0;\n  if (qx <= cx && cy <= qy) return tree[pos];\n  int mid = (cx + cy) >> 1;\n  return max(Query(cx, mid, qx, qy, pos * 2),\n             Query(mid + 1, cy, qx, qy, pos * 2 + 1));\n}\nvoid Update(int cx, int cy, int q, int val, int pos) {\n  if (cy < q || q < cx) return;\n  tree[pos] = max(tree[pos], val);\n  if (cx == cy) return;\n  int mid = (cx + cy) >> 1;\n  Update(cx, mid, q, val, pos * 2);\n  Update(mid + 1, cy, q, val, pos * 2 + 1);\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &ar[i]);\n  for (int i = 1; i <= n; i++) {\n    int tmp = Query(1, n, 1, ar[i], 1) + 1;\n    Update(1, n, ar[i], tmp, 1);\n    ans = max(ans, tmp);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, a[100009];\n  cin >> n;\n  int M[100009];\n  for (int i = 0; i < n; i++) cin >> a[i];\n  int L = 0;\n  for (int i = 0; i < n; i++) {\n    int lo = 1, hi = L;\n    while (lo <= hi) {\n      int mid = lo + hi;\n      mid = mid / 2 + mid % 2;\n      if (a[M[mid]] < a[i])\n        lo = mid + 1;\n      else\n        hi = mid - 1;\n    }\n    int newL = lo;\n    M[newL] = i;\n    L = max(newL, L);\n  }\n  cout << L << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class B {\n    private static final int mod = (int)1e9+7;\n\n    final IOFast io = new IOFast();\n    \n    \n    public void run() throws IOException {\n        final int n = io.nextInt();\n        \n        int[] a = new int[n];\n        long ans = 0;\n        long cur = 0;\n        int max = 0;\n        \n        for(int i = 0; i < n; i++) {\n            a[i] = io.nextInt();\n        }\n        \n        io.out.println(LIS(a));\n    }\n    \n    private static int LIS(int[] ys) {\n        final int n = ys.length;\n        final int[] res = new int[n];\n        Arrays.fill(res, Integer.MAX_VALUE);\n        for (int i = 0; i < n; i++) {\n            res[lowerBound(res, ys[i])] = ys[i];\n        }\n        return lowerBound(res, Integer.MAX_VALUE);\n    }\n    \n    private static int lowerBound(final int[] xs, final int x)\n    {\n        int low = 0, high = xs.length;\n        while (low < high) {\n            final int mid = (low + high) / 2;\n            final int cmp = xs[mid] < x ? -1 : xs[mid] == x ? 0 : 1;\n            if (cmp >= 0) high = mid;\n            else low = mid + 1;\n        }\n        return low;\n    }\n    \n    void main() throws IOException {\n        //      IOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n        try {\n            run();\n        }\n        catch (EndOfFileRuntimeException e) { }\n        io.out.flush();\n    }\n\n    public static void main(String[] args) throws IOException {\n        new B().main();\n    }\n    \n    static class EndOfFileRuntimeException extends RuntimeException {\n        private static final long serialVersionUID = -8565341110209207657L; }\n\n    static\n    public class IOFast {\n        private BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        private PrintWriter out = new PrintWriter(System.out);\n\n        void setFileIO(String ins, String outs) throws IOException {\n            in = new BufferedReader(new FileReader(ins));\n            out = new PrintWriter(new FileWriter(outs));\n        }\n\n        //      private static final int BUFFER_SIZE = 50 * 200000;\n        private static int pos, readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static final char[] str = new char[500000*8*2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public int read() throws IOException {\n            if(pos >= readLen) {\n                pos = 0;\n                readLen = in.read(buffer);\n                if(readLen <= 0) { throw new EndOfFileRuntimeException(); }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(nextString());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(nextString());\n        }\n\n        public char nextChar() throws IOException {\n            while(true) {\n                final int c = read();\n                if(!isSpace[c]) { return (char)c; }\n            }\n        }\n        \n        int reads(char[] cs, int len, boolean[] accept) throws IOException {\n            try {\n                while(true) {\n                    final int c = read();\n                    if(accept[c]) { break; }\n                    str[len++] = (char)c;\n                }\n            }\n            catch(EndOfFileRuntimeException e) { ; }\n            \n            return len;\n        }\n\n        public char[] nextLine() throws IOException {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(str, len, isLineSep);\n            \n            try {\n                if(str[len-1] == '\\r') { len--; read(); }\n            }\n            catch(EndOfFileRuntimeException e) { ; }\n            \n            return Arrays.copyOf(str, len);\n        }\n\n        public String nextString() throws IOException {\n            return new String(next());\n        }\n\n        public char[] next() throws IOException {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(str, len, isSpace);\n            return Arrays.copyOf(str, len);\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(nextString());\n        }\n\n    }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint a[100005];\nconst int ninf = -1000000;\nconst int inf = 1000000;\nint dp[100005];\nint binSearch(int value) {\n  int L = 0, R = n, M;\n  while (R - L > 1) {\n    M = (L + R) / 2;\n    if (dp[M] > value)\n      R = M;\n    else\n      L = M;\n  }\n  if (dp[L] > value)\n    return L;\n  else\n    return R;\n}\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  dp[0] = ninf;\n  for (int i = 1; i <= n; i++) dp[i] = inf;\n  for (int i = 0; i < n; i++) {\n    dp[binSearch(a[i])] = a[i];\n  }\n  int result;\n  for (int i = n; i >= 0; i--) {\n    if (dp[i] != inf) {\n      result = i;\n      break;\n    }\n  }\n  cout << result;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\n \nimport java.util.*;\n/*\n\n \n */\n \n \n \npublic class P1 {\n\tstatic FastReader sc=null;\n \n\tpublic static void main(String[] args) {\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t\tsc=new FastReader();\n\t\tint n=sc.nextInt();\n\t\tint a[]=sc.readArray(n);\n\t\tfor(int i=0;i<n;i++)a[i]--;\n\t\tint counts[]=new int[n];\n\t\tSegTree s=new SegTree(0,n-1,counts);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint val=s.rangeMax(0, a[i]);\n\t\t\ts.set(a[i], val+1);\n\t\t}\n\t\tout.println(s.rangeMax(0, n-1));\n\t\t\n\t\tout.close();\n\t\t\n\t}\n\t\n\t\n\t\n\tstatic class SegTree{\n\t\tSegTree left,right;\n\t\tint l,r;\n\t\tint max=0,min=0;\n\t\tSegTree(int l,int r,int a[]){\n\t\t\tthis.l=l;\n\t\t\tthis.r=r;\n\t\t\tif(l==r) {\n\t\t\t\tmax=min=a[l];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint mid=(l+r)/2;\n\t\t\t\tleft=new SegTree(l,mid,a);\n\t\t\t\tright=new SegTree(mid+1,r,a);\n\t\t\t}\n\t\t\trecalc();\n\t\t}\n\t\tpublic void set(int i,int val) {\n\t\t\tif(l==r) {\n\t\t\t\tthis.max=val;\n\t\t\t\tthis.min=val;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(left.r>=i)left.set(i, val);\n\t\t\telse right.set(i, val);\n\t\t\trecalc();\n\t\t}\n\t\tpublic void recalc() {\n\t\t\tif(l==r)return;\n\t\t\tthis.max=Math.max(left.max,right.max);\n\t\t\tthis.min=Math.min(left.min, right.min);\n\t\t}\n\t\tpublic int rangeMax(int l,int r) {\n\t\t\tif(l>this.r || r<this.l) return Integer.MIN_VALUE;\n\t\t\telse if(l<=this.l && r>=this.r) {\n\t\t\t\treturn this.max;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn Math.max(left.rangeMax(l,r),right.rangeMax(l, r));\n\t\t\t}\t\n\t\t}\n\t\tpublic long rangeMin(int l,int r) {\n\t\t\tif(l>this.r || r<this.l) return Long.MAX_VALUE;\n\t\t\telse if(l<=this.l && r>=this.r) {\n\t\t\t\treturn this.min;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn Math.min(left.rangeMin(l,r),right.rangeMin(l, r));\n\t\t\t}\t\n\t\t}\n\t\t\n\t\t\n\t\t\n\t}\n\n\t\n\t\n \n\tstatic int[] ruffleSort(int a[]) {\n\t\tArrayList<Integer> al=new ArrayList<>();\n\t\tfor(int i:a)al.add(i);\n\t\tCollections.sort(al);\n\t\tfor(int i=0;i<a.length;i++)a[i]=al.get(i);\n\t\treturn a;\n\t}\n\t\n\t\n\t\n\tstatic void print(ArrayList<Integer> al) {\n\t\tfor(int e:al) {\n\t\t\tSystem.out.print(e+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tstatic void print(int a[]) {\n\t\tfor(int e:a) {\n\t\t\tSystem.out.print(e+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tstatic void print(char a[]) {\n\t\tfor(char e:a) {\n\t\t\tSystem.out.print(e);\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tstatic void print(long a[]) {\n\t\tfor(long e:a) {\n\t\t\tSystem.out.print(e+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tstatic long gcd(long a,long b) {\n\t\tif(b==0)return a;\n\t\telse return gcd(b,a%b);\n\t}\n\t\n\tstatic class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n        int[] readArray(int n) {\n    \t\tint a[]=new int [n];\n    \t\tfor(int i=0;i<n;i++) {\n    \t\t\ta[i]=sc.nextInt();\n    \t\t}\n    \t\treturn a;\n    \t}\n    } \n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) cin >> a[i];\n  vector<int> d(n + 1, 1000000);\n  for (int i = 0; i < n; i++) *lower_bound(d.begin(), d.end(), a[i]) = a[i];\n  for (int i = 0; i <= n; i++) {\n    if (d[i] == 1000000) {\n      cout << i;\n      return 0;\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ninline int RI() {\n  int ret = 0, flag = 1, ip = getchar();\n  for (; ip < 48 || ip > 57; ip = getchar()) {\n    if (ip == 45) {\n      flag = -1;\n      ip = getchar();\n      break;\n    }\n  }\n  for (; ip > 47 && ip < 58; ip = getchar()) ret = ret * 10 + ip - 48;\n  return flag * ret;\n}\nconst int mx = 1e5 + 10;\nint n;\nint tree[mx * 3], ar[mx];\nvoid update(int node, int b, int e, int i, int val) {\n  if (i > e || i < b) {\n    return;\n  }\n  if (i >= e && i <= b) {\n    tree[node] = max(tree[node], val);\n    return;\n  }\n  int left = node << 1;\n  int right = left | 1;\n  int mid = (b + e) >> 1;\n  update(left, b, mid, i, val);\n  update(right, mid + 1, e, i, val);\n  tree[node] = max(tree[left], tree[right]);\n}\nint query(int node, int b, int e, int i, int j) {\n  if (i > e || j < b) {\n    return 0;\n  }\n  if (b >= i && e <= j) {\n    return tree[node];\n  }\n  int left = node << 1;\n  int right = left | 1;\n  int mid = (b + e) >> 1;\n  int part1 = query(left, b, mid, i, j);\n  int part2 = query(right, mid + 1, e, i, j);\n  return max(part1, part2);\n}\nint main() {\n  int h, ans, x;\n  while (cin >> n) {\n    ans = 0;\n    memset(tree, 0, sizeof tree);\n    for (int i = 0; i < n; i++) {\n      cin >> x;\n      h = query(1, 0, n, 0, x - 1) + 1;\n      update(1, 0, n, x, h);\n      ans = max(ans, h);\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "n = input()\na = [n+1] * (n+1)\n\ndef find(a, r, v):\n    l = m = 0\n    while l < r:\n        m = (l+r) >> 1\n        if a[m] < v:\n            l = m + 1\n        else:\n            r = m\n    return l\n\nfor i, x in enumerate(map(int, raw_input().split())):\n    t = find(a, i, x)\n    a[t] = x\n\nprint find(a, n, n+1)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint lis[100010];\nint main() {\n  int n;\n  while (scanf(\"%d\", &n) != EOF) {\n    int top = 0;\n    int tmp;\n    scanf(\"%d\", &tmp);\n    lis[++top] = tmp;\n    for (int i = 1; i < n; i++) {\n      scanf(\"%d\", &tmp);\n      if (tmp > lis[top])\n        lis[++top] = tmp;\n      else {\n        int l = 1, r = top, mid;\n        while (l != r) {\n          mid = (l + r) >> 1;\n          if (lis[mid] >= tmp)\n            r = mid;\n          else\n            l = mid + 1;\n        }\n        lis[r] = tmp;\n      }\n    }\n    printf(\"%d\\n\", top);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\nimport javax.swing.text.html.HTMLDocument.Iterator;\n\n\n\npublic class hck2 {\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tInputReader in = new InputReader(System.in);\n\t\tPrintStream out =  System.out;\n\t\tList<Integer>L = new ArrayList<Integer>();\n\t\tint n = in.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = in.nextInt();\n\t\t\tif(L.isEmpty() || L.get(L.size()-1) < x){\n\t\t\t\tL.add(x);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint k = -Collections.binarySearch(L, x) - 1;\n\t\t\tif(k >= 0){\n\t\t\t\tL.set(k, x);\n\t\t\t}\n\t\t}\n\t\tout.println(L.size());\n\t}\n\t\n}\n\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*; \nimport java.util.*; \nimport java.lang.Math; \n\npublic class Main { \n    static int CeilIndex(int A[], int l, int r, int key) \n    { \n        while (r - l > 1) { \n            int m = l + (r - l) / 2; \n            if (A[m] >= key) \n                r = m; \n            else\n                l = m; \n        } \n\n        return r; \n    } \n    static int LongestIncreasingSubsequenceLength(int A[], int size) \n    { \n        int[] tailTable = new int[size]; \n        int len;\n        tailTable[0] = A[0]; \n        len = 1; \n        for (int i = 1; i < size; i++) { \n            if (A[i] < tailTable[0]) \n                tailTable[0] = A[i]; \n            else if (A[i] > tailTable[len - 1]) \n                tailTable[len++] = A[i]; \n            else\n                tailTable[CeilIndex(tailTable, -1, len - 1, A[i])] = A[i]; \n        } \n        return len; \n    } \n    public static void main(String[] args) \n    { \n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int[]A=new int[n]; \n        for(int i=0;i<n;i++)\n            A[i]=sc.nextInt();\n        System.out.println(LongestIncreasingSubsequenceLength(A, n)); \n    } \n} \n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline void fi(int *a) {\n  register char c = 0;\n  while (c < 33) c = getchar();\n  *a = 0;\n  while (c > 33) {\n    *a = *a * 10 + c - '0';\n    c = getchar();\n  }\n}\nint main() {\n  int n;\n  cin >> n;\n  int arr1[n + 2];\n  int i, j;\n  for (i = 0; i < n; i++) cin >> arr1[i];\n  int LIS[n];\n  LIS[0] = arr1[0];\n  int count = 1;\n  for (i = 1; i < n; i++) {\n    if (arr1[i] < LIS[0])\n      LIS[0] = arr1[i];\n    else if (arr1[i] > LIS[count - 1])\n      LIS[count++] = arr1[i];\n    else {\n      int l = 0, r = count - 1, m;\n      int idx = r;\n      while (r - l > 0) {\n        m = (l + r) / 2;\n        if (LIS[m] > arr1[i]) {\n          r = m;\n          idx = r;\n        } else if (LIS[m] == arr1[i]) {\n          idx = m;\n          break;\n        } else\n          l = m + 1;\n        if (m == l) break;\n      }\n      LIS[idx] = arr1[i];\n    }\n  }\n  printf(\"%d\\n\", count);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid _fill_int(int* p, int val, int rep) {\n  int i;\n  for (i = 0; i < rep; i++) p[i] = val;\n}\nint GETi() {\n  int i;\n  scanf(\"%d\", &i);\n  return i;\n}\ntemplate <class T>\nT sqr(T val) {\n  return val * val;\n}\nint N;\nvector<int> A;\nvector<int> LIS(vector<int>& v) {\n  int i;\n  vector<int> dp(N, 1 << 30), id(N);\n  for (i = 0; i < v.size(); i++) {\n    id[i] = lower_bound(dp.begin(), dp.end(), v[i]) - dp.begin();\n    dp[id[i]] = v[i];\n  }\n  int nl = *max_element(id.begin(), id.end());\n  vector<int> ret(nl + 1);\n  for (i = 0; i < N; i++)\n    if (id[N - 1 - i] == nl) ret[nl--] = v[N - 1 - i];\n  return ret;\n}\nvoid solve() {\n  int f, r, i, j, k, l, x, y, y2;\n  cin >> N;\n  for (i = 0; i < N; i++) A.push_back(GETi() - 1);\n  printf(\"%d\\n\", LIS(A).size());\n  return;\n}\nint main(int argc, char** argv) {\n  if (argc > 1) freopen(argv[1], \"r\", stdin);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.Stack;\n\n/**\n * Created by KC on 4/16/14.\n * the essence of the problem is to find the longest increasing sequence\n */\npublic class BubbleSortGraph {\n    static BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter printWriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n    static int[] longest = new int[100000];\n\n    public static void main(String[] args) throws IOException{\n\n       int n = Integer.parseInt(bufferedReader.readLine());\n\n        String[] p = bufferedReader.readLine().split(\" \");\n\n        int fir = Integer.parseInt(p[0]);\n        int index = 0;\n        longest[index] = fir;\n\n        for(int i = 1; i < n; i++){\n            int tmp = Integer.parseInt(p[i]);\n            if(tmp > longest[index]){\n                longest[++index] = tmp;\n            }\n            else {\n                    update(tmp,index);\n            }\n\n        }\n\n\n        printWriter.println(index+1);\n        printWriter.flush();\n        printWriter.close();\n\n\n\n    }\n\n    public static void update(int tmp, int index){  // in the array, find the smallest value which is bigger than this one\n        int start = 0;\n        int end = index;\n        int mid = (start+ end) >> 1;\n\n        while (start < end ){ // as all nodes are distinct\n            mid = (start + end) >> 1;\n            if(longest[mid] > tmp){\n                end = mid;\n            }\n            else { // longest[mid] < tmp\n                start = mid + 1;\n            }\n\n        }\n\n         // start is the index of the number which is the smallest larger number than tmp\n     //   System.out.print(longest[start]);\n        longest[start] = tmp;\n\n\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100005;\nint a[maxn];\nint g[maxn];\nint d[maxn];\nint n;\nstruct SegTree {\n  int maxv[maxn * 3];\n  int ql, qr;\n  int query(int o, int L, int R) {\n    if (ql > qr) return 0;\n    int M = L + (R - L) / 2, ans = 0;\n    if (ql <= L && R <= qr) return maxv[o];\n    if (ql <= M) ans = max(ans, query(o * 2, L, M));\n    if (M < qr) ans = max(ans, query(o * 2 + 1, M + 1, R));\n    return ans;\n  }\n  int p, v;\n  void update(int o, int L, int R) {\n    int M = L + (R - L) / 2;\n    if (L == R)\n      maxv[o] = v;\n    else {\n      if (p <= M)\n        update(o * 2, L, M);\n      else\n        update(o * 2 + 1, M + 1, R);\n      maxv[o] = max(maxv[o * 2], maxv[o * 2 + 1]);\n    }\n  }\n} tree;\nint main(int argc, char *argv[]) {\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  memset(tree.maxv, 0, sizeof(tree.maxv));\n  for (int i = 1; i <= n; i++) {\n    tree.ql = 1;\n    tree.qr = a[i] - 1;\n    d[i] = 1 + tree.query(1, 1, n);\n    tree.p = a[i];\n    tree.v = d[i];\n    tree.update(1, 1, n);\n  }\n  int ans = 1;\n  for (int i = 1; i <= n; i++) ans = max(ans, d[i]);\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\nconst int INF = 1000000000;\nint n, a, d[100005];\nvoid update(int x, int a);\nint get(int x);\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    cin >> a;\n    update(a, get(a - 1) + 1);\n  }\n  cout << get(n) << \"\\n\";\n  return 0;\n}\nvoid update(int x, int a) {\n  for (; x <= n; x |= x + 1) d[x] = max(d[x], a);\n}\nint get(int x) {\n  int result = 0;\n  for (; x > 0; x = (x & (x + 1)) - 1) result = max(result, d[x]);\n  return result;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long longest(std::vector<long long> v) {\n  vector<long long> tail;\n  long long i, n = v.size();\n  tail.push_back(v[0]);\n  for (i = 1; i < n; i++) {\n    if (v[i] < tail[0])\n      tail[0] = v[i];\n    else if (v[i] > tail[tail.size() - 1])\n      tail.push_back(v[i]);\n    long long x = lower_bound(tail.begin(), tail.end(), v[i]) - tail.begin();\n    if (x == tail.size()) continue;\n    tail[x] = v[i];\n  }\n  return tail.size();\n}\nsigned main() {\n  ios_base::sync_with_stdio(false), cin.tie(NULL);\n  long long n, i;\n  cin >> n;\n  vector<long long> v(n);\n  for (i = 0; i < n; i++) cin >> v[i];\n  cout << longest(v);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100005;\nint st[4 * MAXN];\nint getMax(int v, int tl, int tr, int l, int r) {\n  if (l == tl && r == tr) return st[v];\n  int tm = (tl + tr) / 2;\n  int m1 = 0, m2 = 0;\n  if (l < tm) m1 = getMax(2 * v, tl, tm, l, min(r, tm));\n  if (r > tm) m2 = getMax(2 * v + 1, tm, tr, max(l, tm), r);\n  return max(m1, m2);\n}\nvoid change(int v, int tl, int tr, int i, int x) {\n  if (tl == tr - 1) {\n    st[v] = x;\n    return;\n  }\n  int tm = (tl + tr) / 2;\n  if (i < tm)\n    change(2 * v, tl, tm, i, x);\n  else\n    change(2 * v + 1, tm, tr, i, x);\n  st[v] = max(st[2 * v], st[2 * v + 1]);\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) cin >> a[i];\n  for (int i = 0; i < n; i++) {\n    int k = a[i] > 1 ? getMax(1, 1, n + 1, 1, a[i]) : 0;\n    change(1, 1, n + 1, a[i], k + 1);\n  }\n  cout << st[1] << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int modulo = 222222;\nconst int maxN = 888888;\nint a[maxN], rsq[maxN];\nvoid replace(int i, int x) {\n  i += modulo - 1;\n  rsq[i] = max(rsq[i], x);\n  i /= 2;\n  while (i > 0) {\n    rsq[i] = max(rsq[i + i], rsq[i + i + 1]);\n    i /= 2;\n  }\n}\nint getMax(int l, int r) {\n  int i = l + modulo - 1, j = r + modulo - 1, ans = 0;\n  while (i <= j) {\n    if (i % 2) ans = max(ans, rsq[i]);\n    if ((j + 1) % 2) ans = max(ans, rsq[j]);\n    i = (i + 1) / 2;\n    j = (j - 1) / 2;\n  }\n  return ans;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; ++i) cin >> a[i];\n  for (int i = 1; i <= n; ++i) {\n    replace(i, 0);\n  }\n  for (int i = 1; i <= n; ++i) {\n    int x = a[i], y = getMax(1, x - 1);\n    replace(x, y + 1);\n  }\n  cout << getMax(1, n) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class LISwithSegmentTrees {\n\n\tstatic class SegmentTree {\n\n\t\tint N;\n\n\t\tlong[] array, sTree;\n\n\t\tSegmentTree(int n) {\n\t\t\tN = 1;\n\t\t\twhile (N < n)\n\t\t\t\tN <<= 1;\n\t\t\tarray = new long[N + 1];\n\t\t\tsTree = new long[N << 1];\n\n\t\t\tbuild(1, 1, N);\n\t\t}\n\n\t\tvoid build(int node, int b, int e) {\n\t\t\tif (b == e)\n\t\t\t\tsTree[node] = array[b];\n\t\t\telse {\n\t\t\t\tbuild(node << 1, b, (b + e) >> 1);\n\t\t\t\tbuild((node << 1) + 1, ((b + e) >> 1) + 1, e);\n\t\t\t\tsTree[node] = Math.max(sTree[node << 1], sTree[(node << 1) + 1]);\n\t\t\t}\n\t\t}\n\n\t\tvoid update_point(int index, long val) {\n\t\t\tindex += N - 1;\n\t\t\tsTree[index] = val;\n\t\t\twhile (index > 1) {\n\t\t\t\tindex >>= 1;\n\t\t\t\tsTree[index] = Math.max(sTree[index << 1], sTree[(index << 1) + 1]);\n\t\t\t}\n\t\t}\n\n\t\tlong query(int i, int j) {\n\t\t\tif (i > j)\n\t\t\t\treturn 0;\n\t\t\treturn query(1, 1, N, i, j);\n\t\t}\n\n\t\tlong query(int node, int b, int e, int i, int j) {\n\t\t\tif (i > e || j < b)\n\t\t\t\treturn 0;\n\t\t\tif (b >= i && e <= j)\n\t\t\t\treturn sTree[node];\n\t\t\treturn Math.max(query(node << 1, b, (b + e) >> 1, i, j),\n\t\t\t\t\tquery((node << 1) + 1, ((b + e) >> 1) + 1, e, i, j));\n\n\t\t}\n\t}\n\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint value, idx;\n\n\t\tPair(int v, int i) {\n\t\t\tvalue = v;\n\t\t\tidx = i;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn value - o.value;\n\t\t}\n\n\t}\n\n\tstatic int LIS(int[] a) {\n\t\tint N = a.length;\n\n\t\t// sort the array but keep the original index of each element\n\t\tPair arr[] = new Pair[N];\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tarr[i] = new Pair(a[i], i + 1);\n\t\tArrays.sort(arr);\n\n\t\t// initialize segment tree with zeros.\n\t\tSegmentTree st = new SegmentTree(N);\n\t\t// loop on the sorted array :\n\t\t// in each iteration find the value corresponding to (0, index) : this\n\t\t// value is the LIS from 0 to that index in the original array\n\t\t// update this value by one because the LIS is extended (since the array\n\t\t// is sorted)\n\t\tint max = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tPair cur = arr[i];\n\t\t\tint curIdx = cur.idx;\n\t\t\tint lis = (int) (st.query(1, curIdx - 1) + 1);\n\t\t\tmax = Math.max(max, lis);\n\t\t\tst.update_point(curIdx, lis);\n\t\t}\n\t\treturn max;\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tint[] a = new int[N];\n\t\tfor (int i = 0; i < N; i++)\n\t\t\ta[i] = sc.nextInt();\n\t\tSystem.out.println(LIS(a));\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.concurrent.ArrayBlockingQueue;\n\npublic class ProblemB {\n\t\n\tstatic final int INF = 100000000;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint n = Integer.valueOf(in.readLine());\n\t\tint[] a = new int[n];\n\t\tString[] ai = in.readLine().split(\" \");\n\t\tfor (int i = 0 ; i < n ; i++) {\n\t\t\ta[i] = Integer.valueOf(ai[i]);\n\t\t}\n\t\t\n\t\tint[] dp = new int[n];\n\t\tArrays.fill(dp, INF);\n\t\tfor (int i = 0 ; i < n ; i++) {\n\t\t\tint ip = -Arrays.binarySearch(dp, a[i])-1;\n\t\t\tdp[ip] = a[i];\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\tfor (int i = 0 ; i < n ; i++) {\n\t\t\tif (dp[i] != INF) {\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tout.println(cnt);\n\t\tout.flush();\n\t}\n\n\tpublic static void debug(Object... o) {\n\t\tSystem.err.println(Arrays.deepToString(o));\n\t}\n}\n\n"
        },
        {
            "language": 1,
            "solution": "n=input()\nlst=map(int,raw_input().split())\nfrom bisect import *\ntemp=[0]*(n+2)\nt=[lst[0]]\nl=len(t)\nfor i in range(1,n):\n    if lst[i]<t[0]:\n        t[0]=lst[i]\n    elif lst[i]>=t[l-1]:\n        t.append(lst[i])\n        l=l+1\n    else:\n        v=bisect(t,lst[i])\n        t[v]=lst[i]\n    #print t\nprint len(t)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD(1000000009);\nconst int INF((1 << 30) - 1);\nconst int MAXN(100005);\nint a[MAXN], na = 0;\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    int low = 0, high = na - 1, mid, pos = na;\n    while (low <= high) {\n      mid = (low + high) / 2;\n      if (a[mid] > x)\n        pos = mid, high = mid - 1;\n      else\n        low = mid + 1;\n    }\n    a[pos] = x;\n    if (pos == na) na++;\n  }\n  printf(\"%d\", na);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100005];\nint b[100005];\nint n;\nint findd(int len, int p) {\n  int l, r, mid;\n  l = 1, r = len, mid = (l + r) >> 1;\n  while (l <= r) {\n    if (p > b[mid])\n      l = mid + 1;\n    else if (p < b[mid])\n      r = mid - 1;\n    else\n      return mid;\n    mid = (l + r) >> 1;\n  }\n  return l;\n}\nint LIS() {\n  int i, j, len = 1;\n  b[1] = a[0];\n  for (i = 1; i < n; i++) {\n    j = findd(len, a[i]);\n    b[j] = a[i];\n    if (j > len) len = j;\n  }\n  return len;\n}\nint main() {\n  int i;\n  while (~scanf(\"%d\", &n)) {\n    for (i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    printf(\"%d\\n\", LIS());\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int arr[100005];\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> arr[i];\n  set<int> st;\n  set<int>::iterator it;\n  st.clear();\n  for (int i = 0; i < n; i++) {\n    st.insert(arr[i]);\n    it = st.find(arr[i]);\n    it++;\n    if (it != st.end()) st.erase(it);\n  }\n  cout << st.size() << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport static java.lang.Math.*;\nimport static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.Double.parseDouble;\nimport static java.lang.String.*;\n\npublic class Main {\n    \n    static int n;\n    static int [] BIT;\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder out = new StringBuilder();\n        StringTokenizer tk;\n        \n        n = parseInt(in.readLine());\n        int [] a = new int[n];\n        BIT = new int[n+1];\n        tk = new StringTokenizer(in.readLine());\n        \n        int [] dp = new int[n+1];\n        int lis = 0;\n        \n        for(int i=0; i<n; i++) {\n            a[i] = parseInt(tk.nextToken());\n            dp[a[i]] = get(a[i]-1)+1;\n            lis = max(lis, dp[a[i]]);\n            update(a[i],dp[a[i]]);\n        }\n        \n        System.out.println(lis);\n    }\n    \n    static int get(int i) {\n        int mx = 0;\n        while(i > 0) {\n            mx = max(mx, BIT[i]);\n            i -= (i & -i);\n        }\n        return mx;\n    }\n    \n    static void update(int i,int v) {\n        while(i <= n) {\n            BIT[i] = max(BIT[i],v);\n            i += (i & -i);\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100 * 1000 + 10, maxm = (1 << 17), mod = (int)1e9 + 7,\n          hash = 7000001, inf = (1 << 29);\nconst double pi = 3.14159265359, ee = 2.71828;\nint a[maxn];\nvector<int> q;\nint main() {\n  ios::sync_with_stdio(0);\n  int n, c;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    c = upper_bound(q.begin(), q.end(), a[i]) - q.begin();\n    if (c == q.size())\n      q.push_back(a[i]);\n    else\n      q[c] = a[i];\n  }\n  cout << q.size() << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class B {\n\n\tint[] fenv;\n\n\tint get(int x) {\n\t\tint res = 0;\n\t\twhile (x > 0) {\n\t\t\tres = Math.max(res, fenv[x]);\n\t\t\tx = x & (x - 1);\n\t\t}\n\t\treturn res;\n\t}\n\n\tvoid update(int x, int val) {\n\t\twhile (x <= n) {\n\t\t\tfenv[x] = Math.max(fenv[x], val);\n\t\t\tx = 2 * x - (x & (x - 1));\n\t\t}\n\t}\n\n\tint n;\n\n\tvoid solve() throws IOException {\n\t\tn = nextInt();\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\tfenv = new int[n + 1];\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = get(a[i]) + 1;\n\t\t\tres = Math.max(res, val);\n\t\t\tupdate(a[i], val);\n\t\t}\n\t\tout.println(res);\n\n\t}\n\n\tvoid run() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew B().run();\n\t}\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer str;\n\n\tString next() throws IOException {\n\t\twhile (str == null || !str.hasMoreTokens()) {\n\t\t\tstr = new StringTokenizer(br.readLine());\n\t\t}\n\t\treturn str.nextToken();\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 100010;\nint n, a[MAX], f[MAX], d[MAX];\nlong long result;\nvoid update(int x, int val) {\n  int u = x;\n  while (u <= n) {\n    f[u] = max(f[u], val);\n    u += (u & -u);\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  result = 0;\n  int u;\n  memset(d, 0, sizeof(d));\n  memset(f, 0, sizeof(f));\n  d[1] = 1;\n  update(a[1], 1);\n  int result;\n  for (int i = 2; i <= n; i++) {\n    u = a[i] - 1;\n    result = 0;\n    while (u > 0) {\n      result = max(result, f[u]);\n      u -= (u & -u);\n    }\n    d[i] = result + 1;\n    update(a[i], d[i]);\n  }\n  result = 0;\n  for (int i = 1; i <= n; i++) result = max(result, d[i]);\n  cout << result << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "//package com.himanshu.practice.july11;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * Created by himanshubhardwaj on 11/07/18.\n */\npublic class BubbleSortGraph {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        String[] str = br.readLine().split(\" \");\n        int arr[] = new int[str.length];\n\n        for (int i = 0; i < str.length; i++) {\n            arr[i] = Integer.parseInt(str[i]);\n        }\n\n        System.out.print(LISnLogN(arr));\n\n    }\n\n    public static int LISnLogN(int arr[]) {\n        int LIS[] = new int[arr.length];\n        int pos = 0;\n        LIS[pos] = arr[0];\n\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] < LIS[0]) {\n                LIS[0] = arr[i];\n            } else if (arr[i] >= LIS[pos]) {\n                LIS[++pos] = arr[i];\n            } else {\n                LIS[getCeilIndex(0, pos, LIS, arr[i])] = arr[i];\n            }\n        }\n\n        return pos + 1;\n    }\n\n    //arr[start]<=value<end\n    public static int getCeilIndex(int start, int end, int arr[], int value) {\n        if (start == end) {\n            return end;\n        }\n        if (start == end - 1) {\n            if (arr[start] > value) {\n                return start;\n            } else {\n                return end;\n            }\n        }\n\n        if (arr[start] > value) {\n            return start;\n        }\n\n        int mid = start + (end - start) / 2;\n\n        if (arr[mid] <= value) {\n            return getCeilIndex(mid + 1, end, arr, value);\n        } else {\n            return getCeilIndex(start, mid, arr, value);\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint v[100005], h[100005], n;\nvector<int> q;\nvoid insert(int i) {\n  int val = v[i];\n  int lo, mid, hi;\n  lo = -1;\n  hi = q.size();\n  while (hi - lo > 1) {\n    mid = lo + (hi - lo) / 2;\n    if (val > q[mid])\n      lo = mid;\n    else\n      hi = mid;\n  }\n  if (hi == q.size()) {\n    q.push_back(val);\n    h[i] = q.size();\n  } else {\n    q[hi] = val;\n    h[i] = hi + 1;\n  }\n}\nint main() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    cin >> v[i];\n    insert(i);\n  }\n  int dim = q.size();\n  cout << dim << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nint n;\nint a[100009];\nint b[100009], p;\nint main() {\n  while (scanf(\"%d\", &n) != EOF) {\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n    p = 1;\n    b[0] = a[1];\n    for (int i = 2; i <= n; i++) {\n      int k = lower_bound(b, b + p, a[i]) - b;\n      if (k == p) p++;\n      b[k] = a[i];\n    }\n    printf(\"%d\\n\", p);\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author mthai\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CF_340D solver = new CF_340D();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CF_340D {\n        int inf = Integer.MAX_VALUE;\n\n        long max(long... v) {\n            long m = Long.MIN_VALUE;\n            for (long i : v) if (i > m) m = i;\n            return m;\n        }\n\n        public void solve(int testNumber, Scanner input, PrintWriter out) {\n            ShortScanner in = new ShortScanner(input);\n            int n = in.i();\n            int[] a = in.arr(n);\n\n            int[] lis = new int[n + 1];\n            Arrays.fill(lis, inf);\n            int len = 0;\n            for (int i = 0; i < n; ++i) {\n                int p = firstBigger(lis, a[i]);\n                lis[p] = a[i];\n                len = (int) max(len, p);\n            }\n\n            out.println(len);\n        }\n\n        int firstBigger(int[] a, int key) {\n            int low = 1, hi = a.length - 1, rs = low;\n            while (low <= hi) {\n                int m = low + (hi - low) / 2;\n                if (a[m] >= key) {\n                    rs = m;\n                    hi = m - 1;\n                }\n                else\n                    low = m + 1;\n            }\n            return rs;\n        }\n\n        class ShortScanner {\n            Scanner in;\n\n            ShortScanner(Scanner in) {\n                this.in = in;\n            }\n\n            int i() {\n                return in.nextInt();\n            }\n\n            int[] arr(int n) {\n                int[] a = new int[n];\n                for (int i = 0; i < n; ++i) a[i] = in.nextInt();\n                return a;\n            }\n\n        }\n\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> lis;\nint32_t main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    long long pos = (lower_bound(lis.begin(), lis.end(), x) - lis.begin());\n    if (pos == lis.size()) lis.push_back(x);\n    lis[pos] = x;\n  }\n  cout << lis.size();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 10;\nint a[maxn];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; ++i) cin >> a[i];\n  vector<int> lis = {a[1]};\n  for (int i = 2; i <= n; ++i) {\n    if (a[i] > lis.back())\n      lis.push_back(a[i]);\n    else\n      *lower_bound(lis.begin(), lis.end(), a[i]) = a[i];\n  }\n  cout << lis.size() << endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "n=int(input())\na=list(map(lambda x: int(x), input().split()))\n\n\ndef CeilIndex(A, l, r, key):\n    while (r - l > 1):\n\n        m = l + (r - l) // 2\n        if (A[m] >= key):\n            r = m\n        else:\n            l = m\n    return r\n\n\ndef LongestIncreasingSubsequenceLength(A, size):\n    # Add boundary case,\n    # when array size is one\n\n    tailTable = [0 for i in range(size + 1)]\n    len = 0  # always points empty slot\n\n    tailTable[0] = A[0]\n    len = 1\n    for i in range(1, size):\n\n        if (A[i] < tailTable[0]):\n\n            # new smallest value\n            tailTable[0] = A[i]\n\n        elif (A[i] > tailTable[len - 1]):\n\n            # A[i] wants to extend\n            # largest subsequence\n            tailTable[len] = A[i]\n            len += 1\n\n        else:\n            # A[i] wants to be current\n            # end candidate of an existing\n            # subsequence. It will replace\n            # ceil value in tailTable\n            tailTable[CeilIndex(tailTable, -1, len - 1, A[i])] = A[i]\n\n    return len\nprint(LongestIncreasingSubsequenceLength(a,len(a)))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N, tree[1000090], ar[1000090];\nint read(int pos) {\n  int ret = 0;\n  while (pos > 0) {\n    ret = max(ret, tree[pos]);\n    pos -= (pos & -pos);\n  }\n  return ret;\n}\nvoid add(int pos, int val) {\n  while (pos <= N) {\n    tree[pos] = max(tree[pos], val);\n    pos += (pos & -pos);\n  }\n}\nint main() {\n  while (cin >> N) {\n    memset(tree, 0, sizeof(tree));\n    int ret = 0;\n    for (int i = 0, _n = N; i < _n; i++) {\n      scanf(\"%d\", &ar[i]);\n      int L = read(ar[i]) + 1;\n      ret = max(L, ret);\n      add(ar[i], L);\n    }\n    cout << ret << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 111111;\nint a[N], p[N];\nint cnt;\nint n;\nvoid work() {\n  p[cnt = 1] = a[0];\n  for (int i = 1; i < n; i++) {\n    if (a[i] >= p[cnt])\n      p[++cnt] = a[i];\n    else {\n      int w = upper_bound(p, p + cnt + 1, a[i]) - p;\n      if (w > cnt)\n        p[++cnt] = a[i];\n      else\n        p[w] = a[i];\n    }\n  }\n}\nint main() {\n  while (scanf(\"%d\", &n) != EOF) {\n    for (int i = 0; i < n; i++) {\n      scanf(\"%d\", &a[i]);\n    }\n    work();\n    printf(\"%d\\n\", cnt);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmap<int, int> m;\nint pre[100005];\nmap<int, int>::iterator l, k;\nvector<int> LIS_nlogn(vector<int> V) {\n  int i, j;\n  for (i = 0; i < V.size(); i++) {\n    m.insert(make_pair(V[i], i));\n    l = k = m.find(V[i]);\n    k++;\n    if (l == m.begin()) {\n      pre[i] = -1;\n    } else {\n      l--;\n      pre[i] = l->second;\n    }\n    if (k != m.end()) {\n      m.erase(k);\n    }\n  }\n  vector<int> res;\n  k = m.end();\n  res.clear();\n  k--;\n  j = k->second;\n  while (j != -1) {\n    res.push_back(j);\n    j = pre[j];\n  }\n  return res;\n}\nint main() {\n  int N, i, x;\n  vector<int> V;\n  cin >> N;\n  for (i = 1; i <= N; i++) {\n    cin >> x;\n    V.push_back(x);\n  }\n  vector<int> res = LIS_nlogn(V);\n  cout << res.size() << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        D340 solver = new D340();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class D340 {\n        int[] tree;\n        int[] l;\n        int[] r;\n\n        void build(int node, int left, int right) {\n            l[node] = left;\n            r[node] = right;\n            if (left == right) return;\n            int mid = left + right >> 1;\n            build(node * 2, left, mid);\n            build(node * 2 + 1, mid + 1, right);\n        }\n\n        int max(int node, int left, int right) {\n            if (right < l[node] || left > r[node]) return -1;\n            if (left <= l[node] && r[node] <= right) return tree[node];\n            return Math.max(max(node * 2, left, right), max(node * 2 + 1, left, right));\n        }\n\n        void add(int node, int ind, int value) {\n            if (ind < l[node] || ind > r[node]) return;\n            if (l[node] == r[node] && l[node] == ind) {\n                tree[node] = value;\n                return;\n            }\n            add(node * 2, ind, value);\n            add(node * 2 + 1, ind, value);\n            tree[node] = Math.max(tree[node * 2], tree[node * 2 + 1]);\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            tree = new int[4 * n];\n            l = new int[4 * n];\n            r = new int[4 * n];\n            build(1, 1, n);\n            for (int i = 0; i < n; ++i) {\n                int x = in.nextInt();\n                int cur = max(1, 1, x) + 1;\n                add(1, x, cur);\n            }\n            out.println(tree[1]);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nbool mins(T &a, T b) {\n  return a > b ? (a = b, true) : false;\n}\ntemplate <class T>\nbool maxs(T &a, T b) {\n  return a < b ? (a = b, true) : false;\n}\nconst int inf = 1e9 + 5;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (auto &x : a) cin >> x;\n  vector<int> dp(n + 1, inf);\n  dp[0] = -inf;\n  for (int i = 0; i < n; i++) {\n    int v = lower_bound(dp.begin(), dp.end(), a[i]) - dp.begin();\n    dp[v] = a[i];\n  }\n  int i = 0;\n  for (i = n; i >= 0; i--) {\n    if (dp[i] != inf) break;\n  }\n  cout << i << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T, typename U>\ninline void smin(T &a, U b) {\n  if (a > b) a = b;\n}\ntemplate <typename T, typename U>\ninline void smax(T &a, U b) {\n  if (a < b) a = b;\n}\nint power(int a, int b, int m, int ans = 1) {\n  for (; b; b >>= 1, a = 1LL * a * a % m)\n    if (b & 1) ans = 1LL * ans * a % m;\n  return ans;\n}\nint a[100010];\nint first[100010];\nint dp[100010];\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  for (int i = 1; i <= n; i++) first[i] = 0x3f3f3f3f;\n  dp[1] = 1;\n  first[0] = a[1];\n  for (int i = 2; i <= n; i++) {\n    int nn = lower_bound(first, first + n, a[i]) - first;\n    first[nn] = a[i];\n    dp[i] = nn + 1;\n  }\n  int mn = 0;\n  for (int i = 1; i <= n; i++) smax(mn, dp[i]);\n  cout << mn << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint _;\nconst int MAXN = 111 * 1000;\nint n;\nint a[MAXN];\nvector<int> v;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin >> n;\n  for (int i = 0; i < n; ++i) cin >> a[i];\n  for (int i = 0; i < n; ++i) {\n    int x = lower_bound(v.begin(), v.end(), a[i]) - v.begin();\n    if (x == ((int)(v).size()))\n      v.push_back(a[i]);\n    else\n      v[x] = a[i];\n  }\n  cout << ((int)(v).size()) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "import bisect\n\nn = input()\narray = list(map(int, raw_input().split()))\n#n = 3\n#array = [3,1,2]\n\nallThem = []\nfor i in range(n):\n    pos = bisect.bisect(allThem, array[i])\n    if pos >= len(allThem):\n        allThem.append(array[i])\n    else:\n        allThem[pos] = array[i]\nprint(len(allThem))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid reup() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n}\nint n;\nint a[200005];\nint b[200005];\nvoid enter() {\n  reup();\n  cin >> n;\n  for (int i = 1; i <= n; ++i) cin >> a[i];\n}\nvoid solve() {\n  for (int i = 1; i <= n; ++i) b[i] = 1000000000;\n  int ans = 0;\n  for (int i = 1; i <= n; ++i) {\n    int ta = lower_bound(b + 1, b + 1 + n, a[i]) - b;\n    b[ta] = a[i];\n    ans = max(ans, ta);\n  }\n  cout << ans;\n}\nint main() {\n  enter();\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10;\nint tree[4 * N];\nint a[N];\nvoid update(int node, int s, int e, int p, int val) {\n  if (s > p or e < p) return;\n  if (s >= p and e <= p) {\n    tree[node] = val;\n    return;\n  }\n  int mid = (s + e) / 2;\n  update(2 * node, s, mid, p, val);\n  update(2 * node + 1, mid + 1, e, p, val);\n  tree[node] = max(tree[2 * node], tree[2 * node + 1]);\n}\nint get(int node, int s, int e, int l, int r) {\n  if (l > e or r < s) return 0;\n  if (s >= l and e <= r) {\n    return tree[node];\n  }\n  int mid = (s + e) / 2;\n  int left = get(2 * node, s, mid, l, r);\n  int right = get(2 * node + 1, mid + 1, e, l, r);\n  return max(left, right);\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; i++) {\n    int cur = get(1, 1, n, 1, a[i] - 1) + 1;\n    ans = max(ans, cur);\n    update(1, 1, n, a[i], cur);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class BubbleSortGraph {\n\tpublic static void main(String args[]) throws IOException{\n\t\tBufferedReader f= new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n = Integer.parseInt(f.readLine());\n\t\tStringTokenizer st = new StringTokenizer(f.readLine());\n\t\tint a[] = new int[n];\n\t\tfor(int i=0; i<n; i++)\n\t\t\ta[i]=Integer.parseInt(st.nextToken());\n\t\tint c[] = new int[n+1];\n\t\tint dp[] = new int[n+1];\n\t\tint size = 1;\n\t\tc[1]=a[0];\n\t\tdp[0]=1;\n\t\tfor(int i=1; i < n; i++){\n\t\t\tif (a[i]<c[1]){\n\t\t\t\tc[1]=a[i];\n\t\t\t\tdp[i]=1;\n\t\t\t}\n\t\t\t\n\t\t\telse if (a[i]>c[size]){\n\t\t\t\tc[size+1] = a[i];\n\t\t\t\tdp[i] = size+1;\n\t\t\t\tsize++;\n\t\t\t}\n\t\t\t\n\t\t\telse{\n\t\t\t\tint k = Arrays.binarySearch(c, 0, size, a[i]);\n\t\t\t\tk = -1*(k+1);\n\t\t\t\tc[k] = a[i];\n\t\t\t\tdp[i] = k;\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(size);\n\t\tout.close();\n\t\tSystem.exit(0);\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing namespace std;\nconst long double PI = acos(-1.0);\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(NULL);\n  ;\n  int N, i, x;\n  cin >> N;\n  set<int> ans;\n  for (i = 0; i < N; ++i) {\n    cin >> x;\n    ans.insert(x);\n    auto it = ans.find(x);\n    ++it;\n    if (it != ans.end()) ans.erase(it);\n  }\n  cout << ans.size();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 111111;\nint g[N], a[N], n;\nint Find(int x) {\n  int l = 0, r = n, ret = 0;\n  while (l <= r) {\n    int mid = l + r >> 1;\n    if (g[mid] < x) {\n      ret = mid;\n      l = mid + 1;\n    } else\n      r = mid - 1;\n  }\n  return ret;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  memset(g, 0x7f, sizeof(g));\n  g[0] = 0;\n  for (int i = 1; i <= n; i++) {\n    int j = Find(a[i]);\n    g[j + 1] = min(g[j + 1], a[i]);\n  }\n  for (int i = n; i >= 1; i--)\n    if (g[i] < 1e9) {\n      printf(\"%d\\n\", i);\n      break;\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int n = 200006;\nint bit[n];\nint query(int i) {\n  int maxx = 0;\n  while (i > 0) {\n    maxx = max(maxx, bit[i]);\n    i -= (i & -i);\n  }\n  return maxx;\n}\nvoid update(int i, int v) {\n  while (i < n) {\n    bit[i] = max(bit[i], v);\n    i += (i & (-i));\n  }\n}\nint LIS(vector<int> a) {\n  int nn = a.size();\n  for (int i = 0; i < nn; i++) {\n    int value = query(a[i] - 1);\n    update(a[i], value + 1);\n  }\n  return query(n - 1);\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  memset(bit, 0, sizeof(bit));\n  int xxxx;\n  cin >> xxxx;\n  vector<int> v(xxxx);\n  for (int i = 0; i < xxxx; i++) {\n    cin >> v[i];\n  }\n  cout << LIS(v);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int seg[4 * 100005];\nvoid upd(long long int node, long long int s, long long int e,\n         long long int idx, long long int val) {\n  if (s > e or idx < s or idx > e) return;\n  if (s == e) {\n    seg[node] = val;\n    return;\n  }\n  long long int mid = (s + e) / 2;\n  upd(2 * node, s, mid, idx, val);\n  upd(2 * node + 1, mid + 1, e, idx, val);\n  seg[node] = max(seg[2 * node], seg[2 * node + 1]);\n}\nlong long int query(long long int node, long long int s, long long int e,\n                    long long int l, long long int r) {\n  if (s > e or r < s or l > e) return 0;\n  if (s >= l and e <= r) return seg[node];\n  long long int mid = (s + e) / 2;\n  return max(query(2 * node, s, mid, l, r),\n             query(2 * node + 1, mid + 1, e, l, r));\n}\nint main() {\n  long long int n, i, j, k;\n  cin >> n;\n  vector<long long int> a(n);\n  for (i = 0; i < n; i++) cin >> a[i];\n  upd(1, 1, n, a[0], 1);\n  for (i = 1; i < n; i++) {\n    long long int p = query(1, 1, n, 1, a[i]);\n    upd(1, 1, n, a[i], p + 1);\n  }\n  cout << seg[1] << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint BIT[500000];\nint ar[500000];\nvoid update(int idx, int val) {\n  int mx = val;\n  int i;\n  for (i = idx; i <= 499999; i = i + (i & -i)) {\n    mx = max(mx, BIT[i]);\n    BIT[i] = mx;\n  }\n}\nint query(int idx) {\n  int ans = 0;\n  ;\n  while (idx > 0) {\n    ans = max(ans, BIT[idx]);\n    idx = idx - (idx & -idx);\n  }\n  return ans;\n}\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    cin >> ar[i];\n    update(ar[i], query(ar[i] - 1) + 1);\n  }\n  int t = 0;\n  for (int i = 1; i <= n; i++) t = max(t, BIT[i]);\n  cout << t << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] input = new int[n];\n        for (int i = 0; i < n; i++) {\n            input[i] = sc.nextInt();\n        }\n        int[] bit = new int[n+1];\n        for (int i = 0; i < input.length; i++) {\n            update(bit, input[i]);\n        }\n        System.out.println(query(bit, n));\n    }\n    private static void update(int[] bit, int indx)\n    {\n        int prev = query(bit, indx-1);\n        prev++;\n        for (; indx < bit.length; indx+=(indx&-indx)) {\n            bit[indx] = Math.max(bit[indx], prev);\n        }\n    }\n    private static int query(int[] bit, int indx)\n    {\n        int ans = 0;\n        for (; indx > 0; indx-=(indx&-indx)) {\n            ans = Math.max(ans, bit[indx]);\n        }\n        return ans;\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n *\n * @author MaxHeap\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    BubbleSortGraph solver = new BubbleSortGraph();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class BubbleSortGraph {\n\n    int[] pos;\n    int[] arr;\n    int[] memo;\n    int n;\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n      n = in.nextInt();\n      pos = new int[n + 1];\n      arr = new int[n];\n      memo = new int[n];\n      Arrays.fill(memo, -1);\n      for (int i = 0; i < n; i++) {\n        arr[i] = in.nextInt();\n        pos[arr[i]] = i;\n      }\n      int[] tail = new int[n];\n      int[] inc = new int[n];\n      int countInc = 0;\n      for (int i = 0; i < n; i++) {\n        int pos = ArrayUtils.upperBound(tail, 0, countInc, arr[i]);\n        tail[pos] = arr[i];\n        if (pos == countInc) {\n          ++countInc;\n        }\n        inc[i] = countInc;\n      }\n      out.println(countInc);\n    }\n\n  }\n\n  static class InputReader {\n\n    private InputStream stream;\n    private byte[] buf = new byte[1 << 13];\n    private int curChar;\n    private int numChars;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public int read() {\n      if (this.numChars == -1) {\n        throw new UnknownError();\n      } else {\n        if (this.curChar >= this.numChars) {\n          this.curChar = 0;\n\n          try {\n            this.numChars = this.stream.read(this.buf);\n          } catch (IOException ex) {\n            throw new InputMismatchException();\n          }\n\n          if (this.numChars <= 0) {\n            return -1;\n          }\n        }\n\n        return this.buf[this.curChar++];\n      }\n    }\n\n    public int nextInt() {\n      int c;\n      for (c = this.read(); isSpaceChar(c); c = this.read()) {\n      }\n\n      byte sgn = 1;\n      if (c == 45) {\n        sgn = -1;\n        c = this.read();\n      }\n\n      int res = 0;\n\n      while (c >= 48 && c <= 57) {\n        res *= 10;\n        res += c - 48;\n        c = this.read();\n        if (isSpaceChar(c)) {\n          return res * sgn;\n        }\n      }\n\n      throw new InputMismatchException();\n    }\n\n    public static boolean isSpaceChar(int c) {\n      return c == 32 || c == 10 || c == 13 || c == 9 || c == -1;\n    }\n\n  }\n\n  static class ArrayUtils {\n\n    public static int upperBound(int[] arr, int from, int to, int key) {\n      int n = arr.length;\n      int lo = from, hi = to;\n      int ret = to;\n      while (lo <= hi) {\n        int mid = (lo + hi) >> 1;\n        if (arr[mid] >= key) {\n          ret = mid;\n          hi = mid - 1;\n        } else {\n          lo = mid + 1;\n        }\n      }\n      return ret;\n    }\n\n  }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 102010;\nint d[MAXN];\nint dp[MAXN];\nint tree[MAXN];\nint N;\nvoid update(int k, int v) {\n  while (k <= N) {\n    tree[k] = max(tree[k], v);\n    k += k & -k;\n  }\n}\nint read(int k) {\n  int ret = 0;\n  while (k) {\n    ret = max(ret, tree[k]);\n    k -= k & -k;\n  }\n  return ret;\n}\nint main() {\n  while (cin >> N) {\n    memset(dp, 0, sizeof(dp));\n    memset(tree, 0, sizeof(tree));\n    int ans = 0;\n    for (int i = 1; i <= N; ++i) {\n      scanf(\"%d\", d + i);\n      dp[i] = read(d[i]) + 1;\n      update(d[i], dp[i]);\n      ans = max(ans, dp[i]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint CeilIndex(int A[], int l, int r, int key) {\n  int m;\n  while (r - l > 1) {\n    m = l + (r - l) / 2;\n    (A[m] <= key ? l : r) = m;\n  }\n  return r;\n}\nint LongestIncreasingSubsequenceLength(int A[], int size) {\n  int *tailTable = new int[size];\n  int len;\n  memset(tailTable, 0, sizeof(tailTable[0]) * size);\n  tailTable[0] = A[0];\n  len = 1;\n  for (int i = 1; i < size; i++) {\n    if (A[i] < tailTable[0])\n      tailTable[0] = A[i];\n    else if (A[i] >= tailTable[len - 1])\n      tailTable[len++] = A[i];\n    else\n      tailTable[CeilIndex(tailTable, -1, len - 1, A[i])] = A[i];\n  }\n  delete[] tailTable;\n  return len;\n}\nint main() {\n  int n, a[100009], c[100009];\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n    c[i] = 0;\n  }\n  int ans = 0;\n  ans = LongestIncreasingSubsequenceLength(a, n);\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint mini[100005], sz;\nint main() {\n  int n;\n  cin >> n;\n  memset(mini, 127, sizeof(mini));\n  mini[0] = 0;\n  for (int i = 1; i <= n; ++i) {\n    int x, j = sz;\n    cin >> x;\n    for (; mini[j] > x; --j)\n      ;\n    mini[j + 1] = min(mini[j + 1], x);\n    sz = max(sz, j + 1);\n  }\n  cout << sz;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys; sys.setrecursionlimit(1000000)\n\ndef solve():\n    # 3 1 2 4\n    # 1 2 3 4\n\n    # 2 1 3 5 4\n    # 1 2 3 4 5\n\n    n, = rv()\n    a, = rl(1)\n\n\n\n    # 3 1 2 7 4 6 5\n    # [ , 1 ,  , , , ]\n    # [ , 1 , 2 , , , ]\n    # [ , 1 , 2 , 4, 5, ]\n\n    mem = [10000000] * (n + 1)\n    mem[0] = a[0]\n    for i in range(1, n):\n        left, right = 0, n - 1\n        while left < right:\n            mid = (left + right) // 2\n            if a[i] < mem[mid]: right = mid\n            else: left = mid + 1\n        mem[left] = a[i]\n        # for j in range(n):\n        #     if a[i] < mem[j]:\n        #         mem[j] = a[i]\n        #         break\n    res = 0\n    # print(mem)\n    for i in range(1, n):\n        if mem[i] != 10000000: res = i\n    print(res + 1)\n\n\n\n\ndef rv(): return map(int, input().split())\ndef rl(n): return [list(map(int, input().split())) for _ in range(n)]\nif sys.hexversion == 50594544 : sys.stdin = open(\"test.txt\")\nsolve()\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint max_length = 0;\nvoid add(vector<int> &T, int x) {\n  auto y = lower_bound(T.begin(), T.end(), x);\n  if (y == T.end()) {\n    T.push_back(x);\n    ++max_length;\n  } else {\n    *y = x;\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  vector<int> T;\n  int n;\n  cin >> n;\n  int x;\n  for (int i = 0; i < n; ++i) {\n    cin >> x;\n    add(T, x);\n  }\n  cout << max_length << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 200010;\nconst int INF = 1000000000;\nint n, a[MAXN], f[MAXN], c[MAXN], ans;\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  f[0] = 0, c[0] = 0;\n  for (int i = 1; i <= n; i++) c[i] = INF;\n  for (int i = 1; i <= n; i++) {\n    f[i] = lower_bound(c, c + n + 1, a[i]) - c;\n    c[f[i]] = min(c[f[i]], a[i]);\n  }\n  for (int i = 1; i <= n; i++) ans = max(ans, f[i]);\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint f[100100], n;\nint get(int x) {\n  int res = 0;\n  for (int i = x; i; i -= i & -i) res = max(res, f[i]);\n  return res;\n}\nvoid update(int x, int val) {\n  for (int i = x; i <= n; i += i & -i) f[i] = max(f[i], val);\n}\nint main() {\n  int x, ans = 0;\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    cin >> x;\n    int F = get(x) + 1;\n    ans = max(ans, F);\n    update(x, F);\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "/**\n * Created by Alex on 8/4/2014.\n */\n\nimport java.util.*;\nimport java.io.*;\n\npublic class Solution {\n\n    public void solve() throws IOException {\n        int n = in.nextInt();\n        int[] bit = new int[n + 1];\n\n        for (int i = 0; i < n; i++) {\n            int a = in.nextInt();\n\n            update(bit, a, get(bit, a) + 1);\n        }\n\n        out.println(get(bit, n));\n\n    }\n\n    int get(int[] bit, int x) {\n        int ret = 0;\n        for (; x > 0; x -= (x & -x))\n            ret = Math.max(ret, bit[x]);\n\n        return ret;\n    }\n\n    void update(int[] bit, int x, int y) {\n        for (; x < bit.length; x += (x & -x))\n            bit[x] = Math.max(bit[x], y);\n    }\n\n    private FastScanner in;\n    private PrintWriter out;\n\n    public void run() {\n        try {\n//            in = new FastScanner(new File(\".in\"));\n//            out = new PrintWriter(new File(\".out\"));\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            in = new FastScanner(inputStream);\n            out = new PrintWriter(outputStream);\n            solve();\n\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    class FastScanner extends BufferedReader {\n        StringTokenizer st = null;\n\n        FastScanner(File f) throws FileNotFoundException {\n            super(new FileReader(f));\n        }\n\n        FastScanner(InputStream is) {\n            super(new InputStreamReader(is));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(super.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n\n    public static void main(String[] arg) {\n        new Solution().run();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int max_n = 2e5 + 10;\nint n, temp;\nvector<int> ans;\nint main() {\n  ios_base::sync_with_stdio(false), cin.tie(0);\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> temp;\n    int pos = lower_bound(ans.begin(), ans.end(), temp) - ans.begin();\n    if (pos == ans.size())\n      ans.push_back(temp);\n    else\n      ans[pos] = temp;\n  }\n  cout << ans.size() << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint LIS(vector<int> A) {\n  int N = A.size(), i;\n  set<int> s;\n  set<int>::iterator k;\n  for (i = 0; i < N; i++) {\n    if (s.insert(A[i]).second) {\n      k = s.find(A[i]);\n      k++;\n      if (k != s.end()) s.erase(k);\n    }\n  }\n  return s.size();\n}\nint n, aux;\nvector<int> a;\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &aux);\n    a.push_back(aux);\n  }\n  printf(\"%d\\n\", LIS(a));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, sz, d[300001], i, x;\nvoid update(int p) {\n  p /= 2;\n  while (p) {\n    d[p] = max(d[p * 2], d[p * 2 + 1]);\n    p /= 2;\n  }\n}\nint tree(int l, int r) {\n  int ans = -2147483647;\n  while (l <= r) {\n    if (l % 2 == 1 && ans < d[l]) ans = d[l];\n    if (r % 2 == 0 && ans < d[r]) ans = d[r];\n    l = (l + 1) / 2;\n    r = (r - 1) / 2;\n  }\n  return ans;\n}\nint main() {\n  sz = 1;\n  while (sz < 100000) {\n    sz *= 2;\n  }\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; i++) {\n    scanf(\"%d\", &x);\n    if (x == 1)\n      d[x + sz - 1] = 1;\n    else\n      d[x + sz - 1] = 1 + tree(sz, x + sz - 2);\n    update(x + sz - 1);\n  }\n  printf(\"%d\", d[1]);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = in.nextInt();\n            }\n            out.println(longestIncreasingSubsequence(a));\n        }\n\n        int longestIncreasingSubsequence(int[] ary) {\n            int[] m = new int[ary.length + 1];\n            int max = 0;\n            for (int i = 0; i < ary.length; i++) {\n                int lo = 1;\n                int hi = max;\n\n                while (lo <= hi) {\n                    int mid = (lo + hi) / 2;\n                    if (ary[m[mid]] < ary[i])\n                        lo = mid + 1;\n                    else\n                        hi = mid - 1;\n                }\n                if (lo > max) {\n                    m[lo] = i;\n                    max = lo;\n                } else if (ary[i] < ary[m[lo]])\n                    m[lo] = i;\n            }\n\n            return max;\n        }\n\n    }\n\n    static class InputReader {\n        private StringTokenizer tokenizer;\n        private BufferedReader reader;\n\n        public InputReader(InputStream inputStream) {\n            reader = new BufferedReader(new InputStreamReader(inputStream));\n        }\n\n        private void fillTokenizer() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n\n        public String next() {\n            fillTokenizer();\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.BigDecimal;\nimport java.sql.Time;\nimport java.util.*;\n\nimport java.math.BigInteger;\n\nimport static java.lang.Math.*;\nimport static java.math.BigInteger.*;\nimport static java.util.Arrays.*;\n\n\npublic class Main{\n\n    void run(){\n        Locale.setDefault(Locale.US);\n        boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n//        boolean oj = true;\n        try{\n            if( oj ){\n                sc  = new FastScanner( new InputStreamReader(System.in  ) );\n                out = new PrintWriter(   new OutputStreamWriter(System.out) );\n            } else{\n                sc  = new FastScanner(new FileReader(\"in.txt\") );\n//                sc  = new FastScanner(new FileReader(\"D:\\\\JavaOlymp\\\\FatalError\\\\output.txt\") );\n                out = new PrintWriter(   new FileWriter(\"out.txt\") );\n            }\n        } catch (Exception e) {\n            System.exit(-1);\n        }\n        long tB = System.currentTimeMillis();\n        solve();\n        if( !oj ) System.err.println( \"Time: \" + (System.currentTimeMillis()-tB)/1e3 );\n        out.flush();\n    }\n\n\n    class FastScanner{\n        BufferedReader br;\n        StringTokenizer st = new StringTokenizer(\"\");\n        FastScanner( InputStreamReader a ){\n            br = new BufferedReader(a);\n        }\n        FastScanner( FileReader a ){\n            br = new BufferedReader(a);\n        }\n        String next(){\n            while( !st.hasMoreTokens() )\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    return null;\n                }\n            return st.nextToken();\n        }\n        String readLine(){\n            try {\n                return br.readLine();\n            } catch (Exception e) {\n                return null;\n            }\n        }\n        int nextInt(){ return Integer.parseInt(next()); }\n        long nextLong(){ return Long.parseLong(next()); }\n    }\n\n    FastScanner sc;\n    PrintWriter out;\n\n\n\n    public static void main(String[] args){\n        new Main().run();\n//        new Thread( null, new Runnable() {\n//            @Override\n//            public void run() {\n//                new Main().run();\n//            }\n//            }, \"LOL\", 256L * 1024 * 1024 / 2 ).run();\n//        }, \"LOL\", 2000 * 1024 * 1024 ).run();\n    }\n\n\n\n    void TLE(){ for(;;); }\n\n    void MLE(){\n        int[][] adj = new int[1024*1024][];\n        for( int i = 0; i < adj.length; ++i )\n            adj[i] = new int[1024*1024];\n    }\n\n    void exit( int val ){\n        out.flush();\n        System.exit(val);\n    }\n    //////////////////////////////////////////////////////////////////////////////////////////\n\n\n    int n;\n    int[] tree;\n\n    void set( int val, int pos ){\n        for( int i = pos; i < tree.length; i = i|(i+1) )\n            tree[i] = max( tree[i], val );\n    }\n\n    int get( int r ){\n        int ans = 0;\n        for( int i = r; 0 <= i ; i = (i&(i+1))-1 )\n            ans = max( ans, tree[i] );\n        return ans;\n    }\n\n    void solve(){\n        n = sc.nextInt();\n        int ans = 0;\n        tree = new int[n+1];\n        for( int i = 0; i < n; ++i ){\n            int ai = sc.nextInt();\n            int cur = 1 + get(ai-1);\n            set( cur, ai );\n            ans = max( ans, cur );\n        }\n        out.println(ans);\n    }\n\n\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import static java.lang.System.in;\nimport static java.lang.System.out;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class D340bubble {\n\tstatic final double EPS = 1e-10;\n\tstatic final double INF = 1 << 31;\n\tstatic final double PI = Math.PI;\n\n\tpublic static Scanner sc = new Scanner(in);\n\tStringBuilder sb = new StringBuilder();\n\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\n\tprivate static class Pile<E extends Comparable<? super E>> \n\textends Stack<E> implements Comparable<Pile<E>>{\n\t\tpublic int compareTo(Pile<E> y) { return peek().compareTo(y.peek()); }\n\t}\n\n\tpublic static <E extends Comparable<? super E>> void lis (E[] n){\n\t    List<Pile<E>> piles = new ArrayList<Pile<E>>();\n\t    // sort into piles\n\t    for (E x : n){\n\t        Pile<E> newPile = new Pile<E>();\n\t        newPile.push(x);\n\t        int i = Collections.binarySearch(piles, newPile);\n\t        if (i < 0) i = ~i;\n\t        if (i != piles.size())\n\t            piles.get(i).push(x);\n\t        else\n\t            piles.add(newPile);\n\t    }\n\t    System.out.println(piles.size()); \n\t}\n\n\tpublic void run() throws IOException {\n\t\tString input;\n\t\tString[] inputArray;\n\t\tinput = br.readLine();\n\t\tinputArray = input.split(\" \");\n\t\tint n = Integer.valueOf(inputArray[0]);\n\t\tinput = br.readLine();\n\t\tinputArray = input.split(\" \");\n\t\tInteger A[] = new Integer[n];\n\t\tfor (int i=0; i<n; i++)\n\t\t\tA[i] = Integer.valueOf(inputArray[i]);\n\t\tlis(A);\n\t} \n\tpublic static void main(String[] args) throws IOException {\n\t\tnew D340bubble().run();\n\t}\n\tpublic static void ln(Object obj) {\n\t\tout.println(obj);\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Main{\n\n  BufferedReader in;\n  StringTokenizer str = null;\n  PrintWriter out;\n\n  private String next() throws Exception{\n    while(str == null || !str.hasMoreElements())\n      str = new StringTokenizer(in.readLine());\n    return str.nextToken();\n  }\n\n  private int nextInt() throws Exception{\n    return Integer.parseInt(next());\n  }\n\n  public void run() throws Exception{\n    in = new BufferedReader(new InputStreamReader(System.in)); \n    out = new PrintWriter(System.out);\n    int n = nextInt();\n    int a[] = new int[n];\n    for(int i=0;i<n;i++) a[i] = nextInt();\n\n    SegmentTree tree = new SegmentTree(n+1);\n    int ret = 0;\n    for(int i=0;i<n;i++){\n      int max = tree.max(1, 0, n, 0, a[i]) + 1;\n      //System.out.println(a[i] + \" \" + max);\n      tree.update(1, 0, n, a[i], max);\n      ret = Math.max(ret, max);\n    }\n    out.println(ret);\n    out.close();\n  }\n\n  static class SegmentTree{\n    int []tree;\n    public SegmentTree(int n){\n      tree = new int[4*n];\n    }\n\n    public int max(int v, int tl, int tr, int l, int r){\n      if (l > r) return Integer.MIN_VALUE;\n      if (tl == l && tr == r){\n        return tree[v];\n      }\n\n      int tm = (tl + tr) >> 1;\n      int left = max(2*v, tl, tm, l, Math.min(tm, r));\n      int right = max(2*v+1, tm+1, tr, Math.max(l, tm + 1), r);\n\n      return Math.max(left, right);\n    }\n\n    public void update(int v, int tl, int tr, int pos, int d){\n      if (tl == tr){\n        tree[v] = d;\n        return;\n      }\n\n      int tm = (tl + tr) >> 1;\n      if (pos <= tm) update(2*v, tl, tm, pos, d);\n      else update(2*v+1, tm+1, tr, pos, d);\n\n      tree[v] = Math.max(tree[2*v], tree[2*v+1]);\n    }\n  }\n\n  public static void main(String args[]) throws Exception{\n    new Main().run();  \n  }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100000;\nconst int INF = 1000000;\nlong long a[MAXN];\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  vector<int> d;\n  d.resize(n + 1);\n  d[0] = -INF;\n  for (int i = 1; i <= n; ++i) d[i] = INF;\n  for (int i = 0; i < n; i++) {\n    int j = int(upper_bound(d.begin(), d.end(), a[i]) - d.begin());\n    if (d[j - 1] < a[i] && a[i] < d[j]) d[j] = a[i];\n  }\n  int ans;\n  for (int i = 1; i <= n; i++)\n    if (d[i] != INF) ans = i;\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, sz, i, ans, j, a[200001], t[531172], op;\nvoid upd(int x) {\n  for (j = x / 2; j >= 1; j /= 2) t[j] = max(t[j * 2], t[j * 2 + 1]);\n}\nlong long finds(int l, int r) {\n  long long sum = -1;\n  while (l <= r) {\n    if (l % 2 == 1) sum = max(sum, t[l]);\n    if (r % 2 == 0) sum = max(sum, t[r]);\n    l++, r--, l /= 2, r /= 2;\n  }\n  return sum;\n}\nint main() {\n  cin >> n;\n  sz = 1;\n  while (sz < n) sz *= 2;\n  for (i = 1; i <= n; i++) cin >> a[i];\n  for (i = 1; i <= n; i++) {\n    t[a[i] + sz - 1] = finds(sz, a[i] + sz - 1) + 1;\n    upd(a[i] + sz - 1);\n  }\n  cout << max(t[1], 1ll);\n}\n"
        },
        {
            "language": 3,
            "solution": "MXusl = int\nMXuso = input\nMXusL = map\nMXusr = min\nMXusI = print\nn = MXusl(MXuso())\na = [1e6] * (n + 1)\ns = 1\nfor x in MXusL(MXusl, MXuso().split()):\n    l = 0\n    r = s\n    while r-l > 1:\n        m = (l + r) >> 1\n        if a[m] < x:\n            l = m\n        else:\n            r = m\n    s += r == s\n    a[r] = MXusr(a[r], x)\nMXusI(s - 1)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N, i, ANS;\nint A[100010];\nint AIB[4 * 100010];\nvoid update(int p, int v) {\n  for (; p <= N; p += (p & (-p))) AIB[p] = max(AIB[p], v);\n}\nint query(int p) {\n  int v = 0;\n  for (; p >= 1; p -= (p & (-p))) v = max(v, AIB[p]);\n  return v;\n}\nint main() {\n  cin >> N;\n  for (i = 1; i <= N; i++) {\n    cin >> A[i];\n    int l = query(A[i]);\n    l++;\n    ANS = max(ANS, l);\n    update(A[i], l);\n  }\n  cout << ANS << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nT mabs(const T &a) {\n  return a < 0 ? -a : a;\n}\nconst int MaxLength = 100500;\nint dyn[MaxLength];\nint arr[MaxLength];\nvoid run() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = (0), ei = (n); i < ei; i++) {\n    scanf(\"%d\", &arr[i]);\n  }\n  vector<int> d(n + 1);\n  d[0] = -100500;\n  for (int i = 1; i <= n; ++i) d[i] = 100500;\n  for (int i = 0; i < n; i++) {\n    int j = upper_bound(d.begin(), d.end(), arr[i]) - d.begin();\n    if (d[j - 1] < arr[i] && arr[i] < d[j]) d[j] = arr[i];\n  }\n  int ans = 0;\n  for (int i = (0), ei = (n + 1); i < ei; i++) {\n    if (d[i] != 100500) ans = i;\n  }\n  cout << ans << endl;\n}\nint main() {\n  run();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nvector<int> arr(1e5 + 5);\nvector<int> lel(1e5 + 5);\nstruct cmp {\n  bool operator()(int i, int j) const { return arr[i] < arr[j]; }\n};\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> arr[i];\n  arr[n] = 1e9;\n  arr[n + 1] = -1e9;\n  fill(lel.begin(), lel.end(), n);\n  lel[0] = n + 1;\n  int res = 0;\n  for (int i = 0; i < n; i++) {\n    int len = lower_bound(lel.begin(), lel.end(), i, cmp()) - lel.begin();\n    lel[len] = i;\n    res = max(res, len);\n  }\n  cout << res;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.Locale;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\npublic class B {\n\t\n\tprivate void solve() throws IOException {\n\t\tint n = nextInt();\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt() * 2;\n\t\t}\n\t\t\n\t\tint[] d = new int[n + 1];\n\t\tArrays.fill(d, Integer.MAX_VALUE);\n\t\td[0] = Integer.MIN_VALUE;\n\t\t\n\t\tint res = 1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = -Arrays.binarySearch(d, a[i] + 1) - 1;\n\t\t\tif (d[j - 1] < a[i] && a[i] < d[j]) {\n\t\t\t\td[j] = a[i];\n\t\t\t\tres = Math.max(res, j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintln(res);\n\t}\n\t\n\n\tprivate String nextToken() throws IOException {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tprivate int nextInt() throws NumberFormatException, IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tprivate double nextDouble() throws NumberFormatException, IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tprivate long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tprivate void print(Object o) {\n\t\twriter.print(o);\n\t}\n\n\tprivate void println(Object o) {\n\t\twriter.println(o);\n\t}\n\n\tprivate void printf(String format, Object... o) {\n\t\twriter.printf(format, o);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tlong time = System.currentTimeMillis();\n\t\tLocale.setDefault(Locale.US);\n\t\tnew B().run();\n\t\tSystem.err.printf(\"%.3f\\n\", 1e-3 * (System.currentTimeMillis() - time));\n\t}\n\n\tBufferedReader reader;\n\tStringTokenizer tokenizer;\n\tPrintWriter writer;\n\n\tprivate void run() {\n\t\ttry {\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\twriter = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\treader.close();\n\t\t\twriter.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(13);\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint p[100100], f[100100];\nint main() {\n  int res, N, t;\n  res = 1;\n  scanf(\"%d\", &N);\n  for (int i = 0; i < N; i++) scanf(\"%d\", p + i);\n  memset(f, 0x3f3f3f3f, sizeof(f));\n  for (int i = 0; i < N; i++) {\n    t = lower_bound(f, f + N, p[i]) - f;\n    res = max(res, t + 1);\n    f[t] = p[i];\n  }\n  printf(\"%d\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 5;\nconst int inf = 1e9 - 1;\nint dp[maxn], a[maxn], n, m = 0;\nint main() {\n  cin >> n;\n  for (int i = 1; i <= maxn; i++) dp[i] = inf;\n  dp[0] = 0;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n    int j = lower_bound(dp, dp + n, a[i]) - dp - 1;\n    dp[j + 1] = min(dp[j + 1], a[i]);\n    m = max(j + 1, m);\n  }\n  cout << m;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstatic const double EPS = 1e-8;\nstatic const double PI = 4.0 * atan(1.0);\nstatic const double PI2 = 8.0 * atan(1.0);\ntemplate <class T>\nT MIN(const T& a, const T& b) {\n  return a < b ? a : b;\n}\ntemplate <class T>\nT MAX(const T& a, const T& b) {\n  return a > b ? a : b;\n}\ntemplate <class T>\nvoid MIN_UPDATE(T& a, const T& b) {\n  if (a > b) a = b;\n}\ntemplate <class T>\nvoid MAX_UPDATE(T& a, const T& b) {\n  if (a < b) a = b;\n}\nconst int inf = 99999999;\nvector<int> lis_fast(const vector<int>& a) {\n  const int n = a.size();\n  vector<int> A(n, inf);\n  vector<int> id(n);\n  for (int i = 0; i < n; ++i) {\n    id[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n    A[id[i]] = a[i];\n  }\n  int m = *max_element(id.begin(), id.end());\n  vector<int> b(m + 1);\n  for (int i = n - 1; i >= 0; --i)\n    if (id[i] == m) b[m--] = a[i];\n  return b;\n}\nint main() {\n  std::ios::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  vector<int> a;\n  for (int i = 0; i < (int)n; ++i) {\n    int value;\n    cin >> value;\n    a.push_back(value);\n  }\n  cout << lis_fast(a).size() << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> a, b;\nint LIS() {\n  int u, v;\n  b.push_back(0);\n  for (int i = 1; i < a.size(); i++) {\n    if (a[b.back()] < a[i]) {\n      b.push_back(i);\n      continue;\n    }\n    for (u = 0, v = b.size() - 1; u < v;) {\n      int c = (u + v) / 2;\n      if (a[b[c]] < a[i])\n        u = c + 1;\n      else\n        v = c;\n    }\n    if (a[i] < a[b[u]]) b[u] = i;\n  }\n  return b.size();\n}\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; ++i) {\n    int t;\n    cin >> t;\n    a.push_back(t);\n  }\n  cout << LIS() << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int maxn = 100005;\nint arr[maxn];\nusing namespace std;\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  int top = 1;\n  int ans;\n  for (int i = 0; i < n; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    int idx = 1;\n    int lo = 1;\n    int hi = top - 1;\n    int mi;\n    if (top == 1) {\n      arr[1] = x;\n      ans = 1;\n      top++;\n    } else if (x < arr[1]) {\n      arr[1] = x;\n    } else if (x > arr[top - 1]) {\n      arr[top++] = x;\n      ans = max(ans, top - 1);\n    } else {\n      while (lo <= hi) {\n        mi = (lo + hi) / 2;\n        if (arr[mi] < x && (mi == top || arr[mi + 1] > x)) break;\n        if (arr[mi] < x)\n          lo = mi + 1;\n        else\n          hi = mi - 1;\n      }\n      arr[mi + 1] = x;\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint bit[(int)1e5 + 100];\nvoid add(int pos, int val) {\n  for (int i = pos; i > 0; i -= (i & -i)) bit[i] = max(bit[i], val);\n}\nint get(int pos) {\n  int soma = 0;\n  for (int i = pos; i < (int)1e5 + 100; i += (i & -i)) soma = max(soma, bit[i]);\n  return soma;\n}\nint main() {\n  int n;\n  int bs = 0;\n  scanf(\"%d\", &n);\n  vector<int> val;\n  for (int i = 0; i < n; i++) {\n    int va;\n    scanf(\"%d\", &va);\n    val.push_back(va);\n  }\n  for (int j = n - 1; j >= 0; j--) {\n    int now = get(val[j]) + 1;\n    bs = max(bs, now);\n    add(val[j], now);\n  }\n  printf(\"%d\\n\", bs);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\n\npublic class D \n{\n\t\n\tpublic static void main(String[] args) throws Exception \n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint n = sc.nextInt();\n\t\t\n\t\tint [] a = new int [n];\n\t\t\n\t\tfor(int i = 0 ; i < n ;i++) a[i] = sc.nextInt();\n\t\t\n\t\tout.println(lis(a, n));\n\t\t\n\t\tout.flush();\n\t\tout.close();\n\n\t}\n\tstatic int lis(int [] a , int n)\n\t{\n\t\tArrayList<Integer> list = new ArrayList<>();\n\t\t\t\t\n\t\tfor(int x : a)\n\t\t{\n\t\t\tint start = 0 , end = list.size() - 1 , idx = list.size();\n\t\t\n\t\t\twhile(start <= end)\n\t\t\t{\n\t\t\t\tint mid = (start + end) / 2 ;\n\t\t\t\t\n\t\t\t\tif(list.get(mid) > x)\n\t\t\t\t{\n\t\t\t\t\tidx = mid ;\n\t\t\t\t\tend = mid - 1 ; \n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstart = mid + 1 ; \n\t\t\t}\n\t\t\tif(idx == list.size())\n\t\t\t\tlist.add(x);\n\t\t\telse\n\t\t\t\tlist.set(idx, x);\n\t\t\t\t\n\t\t\t\t\n\t\t}\n\t\t\n\t\treturn list.size();\n\t}\n\t\n\tstatic class Scanner \n\t{\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic Scanner(String path) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(path));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t}\n\n\tstatic void shuffle(int[] a) {\n\t\tint n = a.length;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint r = i + (int) (Math.random() * (n - i));\n\t\t\tint tmp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = tmp;\n\t\t}\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  ;\n  int n;\n  cin >> n;\n  int a[100005];\n  for (int i = 0; i < n; i++) cin >> a[i];\n  int ans[100004];\n  int j = 0;\n  ans[0] = a[0];\n  for (int i = 1; i < n; i++) {\n    if (a[i] > ans[j]) {\n      ans[++j] = a[i];\n    } else {\n      int lo = 0, hi = j, res = 0;\n      while (hi >= lo) {\n        int mid = (hi + lo) / 2;\n        if (ans[mid] >= a[i]) {\n          res = mid;\n          hi = mid - 1;\n        } else\n          lo = mid + 1;\n      }\n      ans[res] = a[i];\n    }\n  }\n  cout << j + 1 << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.lang.System;\npublic class Solution{\n\tstatic PrintStream out=System.out;\n\tstatic BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n    static StringTokenizer st;\n\tstatic Scanner sc=new Scanner(System.in);\n\t\n\n\n\tstatic int n;\n\tstatic int arr[];\n\tstatic TreeSet<Integer> ts = new TreeSet<Integer>();\n\tstatic void Task(){\n\t\tn=ni(); arr=nia(n);\n\t\tts.add(arr[0]);\n\t\tfor(int i=1;i<n;i++){\n\t\t\tif(arr[i]>ts.last())ts.add(arr[i]);\n\t\t\telse{\n\t\t\t\tint x=ts.ceiling(arr[i]);\n\t\t\t\tts.remove(x);\n\t\t\t\tts.add(arr[i]);\n\t\t\t}\n\t\t}\n\t\tout.println(ts.size());\n\t}\n\n\n\n\n\n\n\n\n\tpublic static void main(String args[]){\n\t\tTask();\n\t}\n\tstatic int ni(){\n\t\treturn Integer.parseInt(ns());\n\t}\n\tstatic long nl(){\n\t\t return Long.parseLong(ns());\n\t}\n\tstatic double nd(){\n\t\treturn Double.parseDouble(ns());\n\t}\n\tstatic String ns(){\n\t\twhile (st == null || !st.hasMoreElements()){\n\t\t\ttry{\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t}catch (IOException  e){\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\tstatic int[] nia(int n){\n\t\tint[] arr=new int[n];\n\t\tfor(int i=0;i<n;i++)arr[i]=ni();\n\t\treturn arr;\n\t}\n\tstatic long[] nla(int n){\n\t\tlong[] arr=new long[n];\n\t\tfor(int i=0;i<n;i++)arr[i]=nl();\n\t\treturn arr;\n\t}\n\tstatic String nline(){\n\t\tString str = \"\";\n        try{\n            str = br.readLine();\n        }catch (IOException e){\n            e.printStackTrace();\n        }\n        return str;\n\t}\n\tstatic ArrayList<Integer>[] nAdjList(int n,int k){\n\t\tArrayList<Integer>[] al=new ArrayList[n];\n\t\tfor(int i=0;i<n;i++)al[i]=new ArrayList<Integer>();\n\t\tfor(int i=0;i<k;i++){\n\t\t\tint x=ni(),y=ni();\n\t\t\tal[x].add(y);\n\t\t\tal[y].add(x);\n\t\t}\n\t\treturn al;\n\t}\n\tstatic int i(long l){\n\t\treturn (int)Math.round(l);\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1000000009, maxn = 400000;\nconst long long INF = 1000000000ll * 1000000000ll;\nint rmq[maxn << 2];\nint n;\nvoid insert(int i, int w) {\n  int id = 1, l = 0, r = n, m;\n  while (l < r) {\n    m = (l + r) / 2;\n    id *= 2;\n    if (i <= m)\n      r = m;\n    else\n      l = m + 1, ++id;\n  }\n  rmq[id] = w;\n  id /= 2;\n  while (id >= 1) {\n    rmq[id] = max(rmq[id * 2], rmq[id * 2 + 1]);\n    id /= 2;\n  }\n}\nint maxf(int i, int l, int r, int nl, int nr) {\n  if (r < nl || nr < l || l > r) return 0;\n  if (nl <= l && r <= nr) return rmq[i];\n  int m = (l + r) / 2;\n  return max(maxf(i * 2, l, m, nl, nr), maxf(i * 2 + 1, m + 1, r, nl, nr));\n}\nint L, d, af;\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", &af);\n    int tmp = maxf(1, 0, n, 0, af - 1) + 1;\n    insert(af, tmp);\n  }\n  cout << rmq[1] << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100 * 1000;\nint v[maxn + 10];\nint dp[maxn + 10];\nint main() {\n  int n, ans = 1;\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    cin >> v[i];\n  }\n  for (int i = 1; i <= n; i++) {\n    int tmp = (upper_bound(dp, dp + ans, v[i]) - dp);\n    if (tmp >= ans) {\n      ans++;\n    }\n    dp[tmp] = v[i];\n  }\n  cout << endl << ans - 1;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> dp;\nvoid ok(int curr, int val) {\n  curr /= 2;\n  while (curr > 0) {\n    dp[curr] = max(dp[2 * curr], dp[2 * curr + 1]);\n    curr /= 2;\n  }\n}\nint query(int a, int b, int curr, int l, int r) {\n  if (a > r || b < l) {\n    return 0;\n  }\n  if (a <= l && b >= r) {\n    return dp[curr];\n  }\n  int h = (l + r) / 2;\n  return max(query(a, b, 2 * curr, l, h), query(a, b, 2 * curr + 1, h + 1, r));\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n, a;\n  cin >> n;\n  int t = pow(2, ceil(double(log2(n))));\n  dp.resize(2 * t, 0);\n  for (int i = 0; i < n; i += 1) {\n    cin >> a;\n    if (a > 1) {\n      dp[t + a - 1] = 1 + query(t, t + a - 2, 1, t, 2 * t - 1);\n      ok(t + a - 1, dp[t + a - 1]);\n    } else {\n      dp[t + a - 1] = 1;\n    }\n  }\n  cout << dp[1];\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.lang.reflect.Array;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.TreeMap;\n\n\n\n\npublic class Main {\n    static Pair[] seg;\n\n    private static void update(int v, int x, int y, int pos, Pair pair) {\n        if(x == y){\n            seg[v] = pair;\n        }\n        else{\n            \n            int mid = x+y>>1;\n            \n            if(pos <= mid){\n                update(2*v+1, x, mid, pos, pair);\n            }else{\n                update(2*v+2, mid+1, y, pos, pair);\n            }\n            \n            if(seg[2*v+2].freq > seg[2*v+1].freq) {\n                seg[v] = new Pair(seg[2*v+2].val, seg[2*v+2].freq);\n            }else{\n                seg[v] = new Pair(seg[2*v+1].val, seg[2*v+1].freq);\n            }\n        }\n        \n    }\n\n    private static Pair getMax(int v, int x, int y, int L, int R) {\n        if(L > R){\n            return new Pair(-100, 0);\n        }\n        if(L == x && R == y){\n            \n            return new Pair(seg[v].val, seg[v].freq);\n        }\n        \n        int mid = x+y>>1;\n        \n        Pair first = getMax(2*v+1, x, mid, L, Math.min(R, mid));\n        Pair second = getMax(2*v+2,mid+1, y, Math.max(L, mid+1), R);\n        \n        if(first.freq > second.freq){\n            return first;\n        }\n        return second;\n    }\n    \n    static class Pair{\n        int val;\n        int freq;\n        public Pair(int val, int freq){\n            this.val=val;\n            this.freq = freq;\n        }\n\n        \n    }\n    static class Con {\n        int x;\n        int id;\n        public Con(int x, int id){\n            this.x=x;\n            this.id=id;\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new PrintWriter(System.out));\n        \n       \n        int n = Integer.parseInt(br.readLine());\n        \n        String[] in = br.readLine().split(\" \");\n        \n        Con[] S = new Con[n];\n        \n        for(int i=0;i<n;i++){\n            int x = Integer.parseInt(in[i]);\n            S[i] = new Con(x, i);\n        }\n        \n        Arrays.sort(S, new Comparator<Con>(){\n            @Override\n            public int compare(Con x, Con y) {\n                return x.x-y.x;\n            }\n        });\n        \n        //build tree\n        seg = new Pair[4*n];\n        \n        Arrays.fill(seg, new Pair(0,0));\n        \n        //update the first element of sorted array in tree\n        update(0, 0, n-1, S[0].id, new Pair(S[0].x, 1));\n        \n        //System.out.println(seg[S[0].id].val);\n        int max = 1;\n        for(int i=1;i<n;i++){\n            \n            int nId = S[i].id;\n            \n            //System.out.println(\"query index \"+(nId-1));\n            Pair dMax = nId > 0 ? getMax(0, 0, n-1, 0, nId-1) : new Pair(0, 0);\n            \n            //System.out.println(S[i].x+\" \"+dMax.val+\" \"+dMax.freq);\n            \n            max = Math.max(max, dMax.freq+1);\n            \n            update(0, 0 , n-1, nId, new Pair(S[i].x, dMax.freq+1));\n        }\n        \n        bw.append(max+\"\\n\");\n        bw.close();\n    }\n\n   //tmp = String.format(\"%.6f %.6f\", mm, 0.0);\n\n    \n    \n    \n}"
        },
        {
            "language": 4,
            "solution": "import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author vadimmm\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskD solver = new TaskD();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskD {\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int n = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++)\n            a[i] = in.nextInt();\n        int[] d = new int[n + 1];\n        d[0] = Integer.MIN_VALUE;\n        for (int i = 1; i <= n; i++)\n            d[i] = Integer.MAX_VALUE;\n        for (int i = 0; i < n; i++) {\n            int j = binnarySearch(d, a[i]);\n            if (d[j - 1] < a[i] && a[i] < d[j])\n                d[j] = a[i];\n        }\n        for (int i = n; i >= 0; i--)\n            if (d[i] != Integer.MAX_VALUE) {\n                out.println(i);\n                return;\n            }\n    }\n\n    private int binnarySearch(int[] a, int b) {\n        int left = -1;\n        int right = a.length;\n        while (right - left > 1) {\n            int mid = (left + right) >> 1;\n            if (a[mid] < b)\n                left = mid;\n            else\n                right = mid;\n        }\n        return right;\n    }\n\n}\n\nclass InputReader {\n\n    private static BufferedReader bufferedReader;\n    private static StringTokenizer stringTokenizer;\n\n    public InputReader(InputStream inputStream) {\n        bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n        stringTokenizer = null;\n    }\n\n    public String next() {\n        while(stringTokenizer == null || !stringTokenizer.hasMoreTokens()) {\n            try {\n                stringTokenizer = new StringTokenizer(bufferedReader.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return stringTokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    }\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\nimport static java.lang.Math.max;\n\n/**\n * Created by Katushka on 11.03.2020.\n */\npublic class BubbleSortGraph {\n    static int[] readArray(int size, InputReader in) {\n        int[] a = new int[size];\n        for (int i = 0; i < size; i++) {\n            a[i] = in.nextInt();\n        }\n        return a;\n    }\n\n    static long[] readLongArray(int size, InputReader in) {\n        long[] a = new long[size];\n        for (int i = 0; i < size; i++) {\n            a[i] = in.nextLong();\n        }\n        return a;\n    }\n\n    static long[] longestIncreasingSubsequence(long[] a) {\n        int n = a.length;\n        long[] d = new long[n + 1];\n        int[] pos = new int[n + 1];\n        int[] prev = new int[n];\n        int length = 0;\n\n        pos[0] = -1;\n        d[0] = Long.MIN_VALUE;\n        for (int i = 1; i <= n; i++) {\n            d[i] = Long.MAX_VALUE;\n        }\n        for (int i = 0; i <= n - 1; i++) {\n            int j = Arrays.binarySearch(d, a[i]);\n            if (j < 0) {\n                j = -j - 1;\n            }\n            if (d[j - 1] < a[i] && a[i] < d[j]) {\n                d[j] = a[i];\n                pos[j] = i;\n                prev[i] = pos[j - 1];\n                length = max(length, j);\n            }\n        }\n        List<Long> answer = new ArrayList<>();\n        int p = pos[length];\n        while (p != -1) {\n            answer.add(a[p]);\n            p = prev[p];\n        }\n        long[] ansArray = new long[answer.size()];\n        for (int i = answer.size() - 1; i >= 0; i--) {\n            ansArray[answer.size() - i - 1] = answer.get(i);\n\n        }\n        return ansArray;\n    }\n\n    public static void main(String[] args) throws FileNotFoundException {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\n        int n = in.nextInt();\n        long[] a = readLongArray(n, in);\n        \n        out.println(longestIncreasingSubsequence(a).length);\n\n        out.close();\n    }\n\n\n    private static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public String nextString() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public char nextChar() {\n            return next().charAt(0);\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, a[200000], f[200000], ans;\nint c[200000];\nvoid modify(int x, int y) {\n  for (; x <= n; x += x & -x) c[x] = max(c[x], y);\n}\nint query(int x) {\n  int ret(0);\n  for (; x; x -= x & -x) ret = max(ret, c[x]);\n  return ret;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= (n); ++i) scanf(\"%d\", &a[i]);\n  for (int i = 1; i <= (n); ++i) {\n    f[i] = query(a[i]) + 1;\n    modify(a[i], f[i]);\n    ans = max(ans, f[i]);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long n, m, i, j, a, b, z, q, k, len = 0;\n  cin >> n;\n  long A[n];\n  vector<long> tail(n + 1, 0);\n  for (i = 0; i < n; i++) cin >> A[i];\n  tail[len++] = A[0];\n  for (i = 1; i < n; i++) {\n    if (A[i] >= tail[len - 1])\n      tail[len++] = A[i];\n    else {\n      k = upper_bound(tail.begin(), tail.begin() + len, A[i]) - tail.begin();\n      tail[k] = A[i];\n    }\n  }\n  cout << len;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nvoid chmax(T& a, const T& b) {\n  a = max(a, b);\n}\ntemplate <class T>\nvoid chmin(T& a, const T& b) {\n  a = min(a, b);\n}\ntemplate <class T>\nvoid uniq(T& c) {\n  sort(c.begin(), c.end());\n  c.erase(unique(c.begin(), c.end()), c.end());\n}\ntemplate <class T>\nstring to_s(const T& a) {\n  ostringstream os;\n  os << a;\n  return os.str();\n}\ntemplate <class T>\nT to_T(const string& s) {\n  istringstream is(s);\n  T res;\n  is >> res;\n  return res;\n}\ntemplate <typename T>\nvoid print_container(ostream& os, const T& c) {\n  const char* _s = \" \";\n  if (!c.empty()) {\n    __typeof__(c.begin()) last = --c.end();\n    for (__typeof__((c).begin()) it = (c).begin(); it != (c).end(); ++it) {\n      os << *it;\n      if (it != last) cout << _s;\n    }\n  }\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& c) {\n  print_container(os, c);\n  return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, const set<T>& c) {\n  print_container(os, c);\n  return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, const multiset<T>& c) {\n  print_container(os, c);\n  return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, const deque<T>& c) {\n  print_container(os, c);\n  return os;\n}\ntemplate <typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& c) {\n  print_container(os, c);\n  return os;\n}\ntemplate <typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n  os << \"(\" << p.first << \", \" << p.second << \")\";\n  return os;\n}\ntemplate <class T>\nvoid print(T a, int n, const string& deli = \" \", int br = 1) {\n  for (int i = 0; i < n; ++i) {\n    cout << a[i];\n    if (i + 1 != n) cout << deli;\n  }\n  while (br--) cout << endl;\n}\ntemplate <class T>\nvoid print2d(T a, int w, int h, int width = -1, int br = 1) {\n  for (int i = 0; i < h; ++i) {\n    for (int j = 0; j < w; ++j) {\n      if (width != -1) cout.width(width);\n      cout << a[i][j] << ' ';\n    }\n    cout << endl;\n  }\n  while (br--) cout << endl;\n}\ntemplate <class T>\nvoid input(T& a, int n) {\n  for (int i = 0; i < n; ++i) cin >> a[i];\n}\ntemplate <class T>\nvoid input(T* a, int n) {\n  for (int i = 0; i < n; ++i) cin >> a[i];\n}\nvoid fix_pre(int n) {\n  cout.setf(ios::fixed, ios::floatfield);\n  cout.precision(10);\n}\nvoid fast_io() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\nbool in_rect(int x, int y, int w, int h) {\n  return 0 <= x && x < w && 0 <= y && y < h;\n}\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst double PI = acos(-1.0);\nint main() {\n  fast_io();\n  int n;\n  static int a[((long long)(1e5))];\n  cin >> n;\n  input(a, n);\n  const int inf = ((long long)(1e9));\n  static int dp[((long long)(1e5)) + 100];\n  fill_n(dp, n + 30, inf);\n  for (int i = 0; i < (int)(n); ++i) {\n    int k = upper_bound(dp, dp + n, a[i]) - dp;\n    dp[k] = a[i];\n  }\n  int res = 0;\n  while (dp[res] < inf) ++res;\n  cout << res << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "/* Codeforces Template */\n\nimport java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.fill;\nimport static java.util.Arrays.binarySearch;\nimport static java.util.Arrays.sort;\n\npublic class Main {\n\t\n\tstatic long initTime;\n\tstatic final Random rnd = new Random(7777L);\n\tstatic boolean writeLog = false;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tinitTime = System.currentTimeMillis();\n\t\ttry {\n\t\t\twriteLog = \"true\".equals(System.getProperty(\"LOCAL_RUN_7777\"));\n\t\t} catch (SecurityException e) {}\n\t\tnew Thread(null, new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (new File(\"input.txt\").exists())\n\t\t\t\t\t\t\tSystem.setIn(new FileInputStream(\"input.txt\"));\n\t\t\t\t\t} catch (SecurityException e) {}\n\t\t\t\t\tlong prevTime = System.currentTimeMillis();\n\t\t\t\t\tnew Main().run();\n\t\t\t\t\tlog(\"Total time: \" + (System.currentTimeMillis() - prevTime) + \" ms\");\n\t\t\t\t\tlog(\"Memory status: \" + memoryStatus());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}, \"1\", 1L << 24).start(); \n\t}\n\n\tvoid run() throws IOException {\n\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t\tin.close();\n\t}\n\t\n\t/*************************************************************** \n\t * Solution\n\t **************************************************************/\n\n\tvoid solve() throws IOException  {\n\t\t\n\t\tint n = nextInt();\n\t\tint[] a = nextIntArray(n);\n\t\tRMQ rmq = new RMQ(n);\n\t\t\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = a[i] - 1;\n\t\t\tint len = 1 + rmq.getMax(0, x - 1);\n\t\t\trmq.set(x, len);\n\t\t\tans = max(ans, len);\n\t\t}\n\t\tout.println(ans);\n\t}\n\t\n\tclass RMQ {\n\t\tint n;\n\t\tint[] vals;\n\n\t\tRMQ(int n) {\n\t\t\tthis.n = n;\n\t\t\tthis.vals = new int [2 * n];\n\t\t}\n\t\t\n\t\tvoid set(int i, int x) {\n\t\t\tvals[n + i] = x;\n\t\t\tfor (int v = (n + i) >> 1; v > 0; v >>= 1)\n\t\t\t\tvals[v] = max(vals[(v << 1)], vals[(v << 1) + 1]);\n\t\t}\n\t\t\n\t\tint getMax(int l, int r) {\n\t\t\tl += n;\n\t\t\tr += n;\n\t\t\tint ret = 0;\n\t\t\twhile (l <= r) {\n\t\t\t\tif ((l & 1) == 1) ret = max(ret, vals[l]);\n\t\t\t\tif ((r & 1) == 0) ret = max(ret, vals[r]);\n\t\t\t\tl = (l + 1) >> 1;\n\t\t\t\tr = (r - 1) >> 1;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\t\n\t/*************************************************************** \n\t * Input \n\t **************************************************************/\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer st = new StringTokenizer(\"\");\n\t\n\tString nextToken() throws IOException {\n\t\twhile (!st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\t\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\t\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\t\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\t\n\tint[] nextIntArray(int size) throws IOException {\n\t\tint[] ret = new int [size];\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tret[i] = nextInt();\n\t\treturn ret;\n\t}\n\t\n\tlong[] nextLongArray(int size) throws IOException {\n\t\tlong[] ret = new long [size];\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tret[i] = nextLong();\n\t\treturn ret;\n\t}\n\t\n\tdouble[] nextDoubleArray(int size) throws IOException {\n\t\tdouble[] ret = new double [size];\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tret[i] = nextDouble();\n\t\treturn ret;\n\t}\n\t\n\tString nextLine() throws IOException {\n\t\tst = new StringTokenizer(\"\");\n\t\treturn in.readLine();\n\t}\n\t\n\tboolean EOF() throws IOException {\n\t\twhile (!st.hasMoreTokens()) {\n\t\t\tString s = in.readLine();\n\t\t\tif (s == null)\n\t\t\t\treturn true;\n\t\t\tst = new StringTokenizer(s);\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/*************************************************************** \n\t * Output \n\t **************************************************************/\n\tvoid printRepeat(String s, int count) {\n\t\tfor (int i = 0; i < count; i++)\n\t\t\tout.print(s);\n\t}\n\t\n\tvoid printArray(int[] array) {\n\t\tif (array == null || array.length == 0)\n\t\t\treturn;\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tif (i > 0) out.print(' ');\n\t\t\tout.print(array[i]);\n\t\t}\n\t\tout.println();\n\t}\n\t\n\tvoid printArray(long[] array) {\n\t\tif (array == null || array.length == 0)\n\t\t\treturn;\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tif (i > 0) out.print(' ');\n\t\t\tout.print(array[i]);\n\t\t}\n\t\tout.println();\n\t}\n\t\n\tvoid printArray(double[] array) {\n\t\tif (array == null || array.length == 0)\n\t\t\treturn;\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tif (i > 0) out.print(' ');\n\t\t\tout.print(array[i]);\n\t\t}\n\t\tout.println();\n\t}\n\t\n\tvoid printArray(double[] array, String spec) {\n\t\tif (array == null || array.length == 0)\n\t\t\treturn;\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tif (i > 0) out.print(' ');\n\t\t\tout.printf(Locale.US, spec, array[i]);\n\t\t}\n\t\tout.println();\n\t}\n\t\n\tvoid printArray(Object[] array) {\n\t\tif (array == null || array.length == 0)\n\t\t\treturn;\n\t\tboolean blank = false;\n\t\tfor (Object x : array) {\n\t\t\tif (blank) out.print(' '); else blank = true;\n\t\t\tout.print(x);\n\t\t}\n\t\tout.println();\n\t}\n\t\n\t@SuppressWarnings(\"rawtypes\")\n\tvoid printCollection(Collection collection) {\n\t\tif (collection == null || collection.isEmpty())\n\t\t\treturn;\n\t\tboolean blank = false;\n\t\tfor (Object x : collection) {\n\t\t\tif (blank) out.print(' '); else blank = true;\n\t\t\tout.print(x);\n\t\t}\n\t\tout.println();\n\t}\n\t\n\t/*************************************************************** \n\t * Utility\n\t **************************************************************/\n\tstatic String memoryStatus() {\n\t\treturn (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory() >> 20) + \"/\" + (Runtime.getRuntime().totalMemory() >> 20) + \" MB\";\n\t}\n\t\n\tstatic void checkMemory() {\n\t\tSystem.err.println(memoryStatus());\n\t}\n\t\n\tstatic long prevTimeStamp = Long.MIN_VALUE;\n\t\n\tstatic void updateTimer() {\n\t\tprevTimeStamp = System.currentTimeMillis();\n\t}\n\t\n\tstatic long elapsedTime() {\n\t\treturn (System.currentTimeMillis() - prevTimeStamp);\n\t}\n\t\n\tstatic void checkTimer() {\n\t\tSystem.err.println(elapsedTime() + \" ms\");\n\t}\n\t\n\tstatic void chk(boolean f) {\n\t\tif (!f) throw new RuntimeException(\"Assert failed\");\n\t}\n\t\n\tstatic void chk(boolean f, String format, Object ... args) {\n\t\tif (!f) throw new RuntimeException(String.format(format, args));\n\t}\n\t\n\tstatic void log(String format, Object ... args) {\n\t\tif (writeLog) System.err.println(String.format(Locale.US, format, args));\n\t}\n\t\n\tstatic void swap(int[] a, int i, int j) {\n\t\tint tmp = a[i];\n\t\ta[i] = a[j];\n\t\ta[j] = tmp;\n\t}\n\t\n\tstatic void swap(long[] a, int i, int j) {\n\t\tlong tmp = a[i];\n\t\ta[i] = a[j];\n\t\ta[j] = tmp;\n\t}\n\t\n\tstatic void swap(double[] a, int i, int j) {\n\t\tdouble tmp = a[i];\n\t\ta[i] = a[j];\n\t\ta[j] = tmp;\n\t}\n\t\n\tstatic void shuffle(int[] a, int from, int to) {\n\t\tfor (int i = from; i < to; i++)\n\t\t\tswap(a, i, rnd.nextInt(a.length));\n\t}\n\t\n\tstatic void shuffle(long[] a, int from, int to) {\n\t\tfor (int i = from; i < to; i++)\n\t\t\tswap(a, i, rnd.nextInt(a.length));\n\t}\n\t\n\tstatic void shuffle(double[] a, int from, int to) {\n\t\tfor (int i = from; i < to; i++)\n\t\t\tswap(a, i, rnd.nextInt(a.length));\n\t}\n\t\n\tstatic void shuffle(int[] a) {\n\t\tif (a == null) return;\n\t\tshuffle(a, 0, a.length);\n\t}\n\t\n\tstatic void shuffle(long[] a) {\n\t\tif (a == null) return;\n\t\tshuffle(a, 0, a.length);\n\t}\n\t\n\tstatic void shuffle(double[] a) {\n\t\tif (a == null) return;\n\t\tshuffle(a, 0, a.length);\n\t}\n\t\n\tstatic long[] getPartialSums(int[] a) {\n\t\tfinal long[] sums = new long [a.length + 1];\n\t\tfor (int i = 0; i < a.length; i++)\n\t\t\tsums[i + 1] = sums[i] + a[i];\n\t\treturn sums;\n\t}\n\t\n\tstatic long[] getPartialSums(long[] a) {\n\t\tfinal long[] sums = new long [a.length + 1];\n\t\tfor (int i = 0; i < a.length; i++)\n\t\t\tsums[i + 1] = sums[i] + a[i];\n\t\treturn sums;\n\t}\n\t\n\tstatic int[] getOrderedSet(int[] a) {\n\t\tfinal int[] set = Arrays.copyOf(a, a.length);\n\t\tif (a.length == 0) return set;\n\t\tshuffle(set);\n\t\tsort(set);\n\t\tint k = 1;\n\t\tint prev = set[0];\n\t\tfor (int i = 1; i < a.length; i++) {\n\t\t\tif (prev != set[i]) {\n\t\t\t\tset[k++] = prev = set[i];\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(set, k);\n\t}\n\t\n\tstatic long[] getOrderedSet(long[] a) {\n\t\tfinal long[] set = Arrays.copyOf(a, a.length);\n\t\tif (a.length == 0) return set;\n\t\tshuffle(set);\n\t\tsort(set);\n\t\tint k = 1;\n\t\tlong prev = set[0];\n\t\tfor (int i = 1; i < a.length; i++) {\n\t\t\tif (prev != set[i]) {\n\t\t\t\tset[k++] = prev = set[i];\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(set, k);\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint mod = 1e9 + 7;\nlong long powmod(long long a, long long b) {\n  long long res = 1;\n  if (a >= mod) a %= mod;\n  for (; b; b >>= 1) {\n    if (b & 1) res = res * a;\n    if (res >= mod) res %= mod;\n    a = a * a;\n    if (a >= mod) a %= mod;\n  }\n  return res;\n}\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nlong long arr[100010], tree[1000100], n;\nlong long query(long long node, long long a, long long b, long long i,\n                long long j) {\n  if (a > b || i > b || j < a) return 0;\n  if (a >= i && b <= j) return tree[node];\n  return max(query(node * 2, a, (a + b) / 2, i, j),\n             query(node * 2 + 1, (a + b) / 2 + 1, b, i, j));\n}\nvoid update(long long node, long long a, long long b, long long i,\n            long long val) {\n  if (a > b || i < a || i > b) return;\n  if (a == b && a == i) {\n    tree[node] = val;\n    return;\n  }\n  long long mid = (a + b) / 2;\n  update(node * 2, a, mid, i, val);\n  update(node * 2 + 1, mid + 1, b, i, val);\n  tree[node] = max(tree[node * 2], tree[node * 2 + 1]);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  long long i, maxi, ans = 0;\n  cin >> n;\n  for (i = 0; i < n; i++) cin >> arr[i];\n  for (i = 0; i < n; i++) {\n    maxi = query(1, 0, n - 1, 1, arr[i] - 1);\n    ans = max(ans, maxi);\n    update(1, 0, n - 1, arr[i], maxi + 1);\n  }\n  cout << ans + 1;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n;\n  cin >> n;\n  vector<int> g(1);\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    if (x > g.back())\n      g.push_back(x);\n    else {\n      int p = lower_bound(g.begin(), g.end(), x) - g.begin();\n      g[p] = x;\n    }\n  }\n  cout << g.size() - 1 << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, ans, q[200000], fen[200000];\nint a[200000];\nvoid up(int v, int val) {\n  while (v <= n) {\n    fen[v] = max(fen[v], val);\n    v = (v | (v + 1));\n  }\n}\nint get(int v) {\n  int ans = 0;\n  while (v > 0) {\n    ans = max(ans, fen[v]);\n    v = (v & (v + 1)) - 1;\n  }\n  return ans;\n}\nint main() {\n  cin >> n;\n  ans = 0;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n    q[i] = get(a[i]) + 1;\n    up(a[i], q[i]);\n    ans = max(ans, q[i]);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint seg[1000000];\nint dp[100001];\nvector<int> num;\nint update(int node, int s, int e, int in, int val) {\n  if (s == e) return seg[node] = val;\n  int mid = (s + e) >> 1;\n  if (in <= mid)\n    return seg[node] = max(seg[node], update(2 * node, s, mid, in, val));\n  return seg[node] = max(seg[node], update(2 * node + 1, mid + 1, e, in, val));\n}\nint query(int node, int s, int e, int f, int t) {\n  if (s == e) return seg[node];\n  if (f <= s && t >= e) return seg[node];\n  int mid = (s + e) >> 1;\n  if (t <= mid) return query(2 * node, s, mid, f, t);\n  if (f > mid) return query(2 * node + 1, mid + 1, e, f, t);\n  return max(query(2 * node, s, mid, f, t),\n             query(2 * node + 1, mid + 1, e, f, t));\n}\nint main() {\n  int n;\n  cin >> n;\n  num.resize(n + 1);\n  for (int i = 1; i <= n; ++i) cin >> num[i];\n  for (int i = 1; i <= n; ++i) {\n    int res = query(1, 1, n, 1, num[i] - 1);\n    dp[i] = res + 1;\n    update(1, 1, n, num[i], dp[i]);\n  }\n  cout << query(1, 1, n, 1, n) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MX = 1e6 + 5;\nconst long long INF = 1e18 + 7;\nconst long long MOD = 1e9 + 7;\nint n, res, pre[MX], lay[MX];\nlong long t[MX];\nint BS(int pocz, int konc, long long x) {\n  if (konc - pocz <= 5) {\n    for (int i = konc; i >= pocz; --i)\n      if (t[lay[i]] >= x) return i;\n  }\n  int sr = (pocz + konc) / 2;\n  if (t[lay[sr]] >= x)\n    return BS(sr, konc, x);\n  else\n    return BS(pocz, sr - 1, x);\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = (1); i <= (n); ++i) {\n    cin >> t[i];\n    t[i] = (long long)1e18 - t[i];\n  }\n  lay[0] = 0;\n  t[0] = INF;\n  pre[0] = -1;\n  for (int i = (1); i <= (n); ++i) {\n    int pos = BS(0, res, t[i]);\n    pre[i] = lay[pos];\n    lay[pos + 1] = i;\n    res = max(res, pos + 1);\n  }\n  printf(\"%d\\n\", res);\n  vector<int> r;\n  int akt = lay[res];\n  while (akt != 0) {\n    r.push_back(akt);\n    akt = pre[akt];\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100005];\nint b[100005];\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  int i;\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n    b[i] = 999999999;\n  }\n  int tot = 0;\n  for (i = 0; i < n; i++) {\n    int now = lower_bound(b, b + tot, a[i]) - b;\n    if (now == tot) tot++;\n    b[now] = min(b[now], a[i]);\n  }\n  cout << tot << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int NMAX = 100000;\nvector<int> T;\nint main() {\n  int N;\n  scanf(\"%d\", &N);\n  T.push_back(0);\n  for (int i = 1; i <= N; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    if (x > T.back()) {\n      T.push_back(x);\n      continue;\n    }\n    *lower_bound(T.begin(), T.end(), x) = x;\n  }\n  printf(\"%d\\n\", (int)T.size() - 1);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, a[100010], b[100010], ans = 0;\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n  for (int i = 1; i <= n; ++i) {\n    int L = 1, R = ans, M;\n    while (L <= R) {\n      M = (L + R) >> 1;\n      if (a[i] < b[M])\n        R = M - 1;\n      else\n        L = M + 1;\n    }\n    b[L] = a[i];\n    if (L > ans) ans = L;\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long N;\n  cin >> N;\n  vector<long long> v;\n  for (int i = 1; i <= N; i++) {\n    long long tmp;\n    cin >> tmp;\n    int idx = lower_bound(v.begin(), v.end(), tmp) - v.begin();\n    if (idx == v.size()) {\n      v.push_back(tmp);\n    } else {\n      v[idx] = tmp;\n    }\n  }\n  cout << v.size() << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N;\nint f[100010];\nint a[100010];\nint main() {\n  scanf(\"%d\", &N);\n  for (int i = 1; i <= N; ++i) scanf(\"%d\", &a[i]);\n  for (int i = 0; i <= N; ++i) f[i] = (1 << 30);\n  f[0] = 0;\n  int Ans = 0;\n  for (int i = 1; i <= N; ++i) {\n    int p = upper_bound(f, f + 1 + N, a[i]) - f;\n    if (p > Ans) Ans = p;\n    if (f[p] > a[i]) f[p] = a[i];\n  }\n  cout << Ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1E6;\nconst int MAXN = 1E5;\nint a[MAXN + 2];\nint d[MAXN + 2];\nint bs(int x) {\n  int l = 1;\n  int r = MAXN + 1;\n  while (l < r) {\n    int c = (l + r) / 2;\n    if (d[c] > x) {\n      r = c;\n    } else\n      l = c + 1;\n  }\n  return l;\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  for (int i = 1; i <= MAXN; i++) {\n    d[i] = INF;\n  }\n  int max_l = 0;\n  for (int i = 0; i < n; i++) {\n    int j = bs(a[i]);\n    d[j] = min(d[j], a[i]);\n    max_l = max(max_l, j);\n  }\n  printf(\"%d\\n\", max_l);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int oo = 0x3f3f3f3f;\nconst double eps = 1e-9;\nconst int maxN = 100 * 1024;\nint N, K;\nint a[maxN];\nint lis[maxN];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin >> N;\n  for (int i = (1); i < (N + 1); i++) cin >> a[i];\n  for (int i = (1); i < (N + 2); i++) lis[i] = oo;\n  for (int i = (1); i < (N + 1); i++) {\n    int len = upper_bound(lis + 1, lis + N + 1, a[i]) - lis;\n    lis[len] = min(lis[len], a[i]);\n  }\n  int best = lower_bound(lis + 1, lis + N + 2, oo) - lis - 1;\n  cout << best << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N(100010);\nint n, t;\nint s[N];\nint find(int l, int r, int a) {\n  if (l == r) return l;\n  int mid = (l + r) / 2;\n  if (a <= s[mid]) return find(l, mid, a);\n  return find(mid + 1, r, a);\n}\nint main() {\n  cin >> n;\n  int ans = 0;\n  for (int i = int(1); i < int(n + 1); ++i) {\n    int a;\n    cin >> a;\n    int x = find(0, t, a);\n    if (x == t)\n      s[t++] = a;\n    else\n      s[x] = a;\n    ans = max(ans, t);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n  public static void main (String[] args) {\n    \n    Scanner scanner = new Scanner(System.in);\n    \n    int n = scanner.nextInt();\n    \n    int[] nums = new int[n];\n    \n    for (int i = 0; i < n; i++) {\n      nums[i] = scanner.nextInt();\n    }\n    \n    System.out.println(lis(nums));\n  }\n  \n  public static int lis(int[] nums) {\n    List<Integer> arr = new ArrayList<>();\n    \n    for (int num : nums) {\n      \n      int index = Collections.binarySearch(arr, num);\n      \n      \n      if (index < 0) {\n        index = -index - 1;\n      }\n      \n      if (index >= arr.size()) {\n        arr.add(num);\n      } else {\n        arr.set(index, num);\n      }\n      \n    }\n    \n    return arr.size();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Infinity = 1000000001;\nlong int Max, kq;\nint n, A[200000], f[200000];\nvoid Sort(int Left, int Right) {\n  int i = Left;\n  int j = Right;\n  int Mid = f[(Left + Right) / 2];\n  while (i <= j) {\n    while (f[i] < Mid) i++;\n    while (f[j] > Mid) j--;\n    if (i <= j) {\n      int tmp = f[i];\n      f[i] = f[j];\n      f[j] = tmp;\n      i++;\n      j--;\n    }\n  }\n  if (Left < j) Sort(Left, j);\n  if (i < Right) Sort(i, Right);\n}\nint main() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> A[i];\n  for (int i = 1; i <= n; i++) f[i] = Infinity;\n  f[0] = -Infinity;\n  for (int i = 1; i <= n; i++) {\n    int Mid;\n    int Left = 1;\n    int Right = n;\n    while (Right > Left + 1) {\n      Mid = (Left + Right) / 2;\n      if (f[Mid - 1] >= A[i])\n        Right = Mid;\n      else\n        Left = Mid;\n    }\n    if (f[Right - 1] <= A[i])\n      if (f[Right] > A[i]) Max = Right;\n    if (f[Left - 1] <= A[i])\n      if (f[Left] > A[i]) Max = Left;\n    f[Max] = A[i];\n    if (Max > kq) kq = Max;\n  }\n  cout << kq;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class utkarsh {\n\n    InputStream is;\n    PrintWriter out;\n    \n    long maxl = 1234567890987654321L, mod = 1000000007L;\n    int p[], maxi = 1234567890, sz, np = 20000000;\n    boolean b[];    // = isPrime();\n    \n    void solve(){\n        //Enter code here utkarsh\n        //sz=sieve(); //sz=1270607;\n        //out.println(sz);\n        int i, j, k, m, n, z;\n        n = ni();\n        int a[] = na(n);\n        int d[] = new int[n];\n        d[0] = a[0];\n        z = 1;\n        for(i = 1; i < n; i++){\n            if(a[i] < d[0]){\n                d[0] = a[i];\n            }else if(a[i] > d[z - 1]){\n                d[z++] = a[i];\n            }\n            else{\n                j = -1;\n                k = z-1;\n                while(k - j > 1){\n                    m = j + (k - j) / 2;\n                    if(d[m] >= a[i]){\n                        k = m;\n                    }else{\n                        j = m;\n                    }\n                }\n                d[k] = a[i];\n            }\n        }\n        out.println(z);\n    }\n    \n    int sieve(){ int i, j, n = np; b = new boolean[n]; for(i = 3; i < n; i += 2){ b[i] = true; } b[2] = true; for(i = 3; i * i <= n; i += 2){ if(b[i]){ for(j = 2 * i; j < n; j += i){ b[j] = false; } } } p = new int[n]; p[0] = 2; j = 1; for(i = 3; i < n; i += 2){ if(b[i]){ p[j++] = i; } } p=Arrays.copyOf(p,j); return j;\n    }\n    long modpow(long base, long exp, long modulus) { base %= modulus; long result = 1L; while (exp > 0) { if ((exp & 1)==1) result = (result * base) % modulus; base = (base * base) % modulus; exp >>= 1; } return result;\n    }\n    \n    public static void main(String[] args) { new utkarsh().run();\n    }\n    void run(){ is = System.in; out = new PrintWriter(System.out); solve(); out.flush();\n    }\n    \n    byte input[] = new byte[1024];\n    int len = 0, ptr = 0;\n    \n    int readByte(){ if(ptr >= len){ ptr = 0; try{ len = is.read(input); }catch(IOException e){ throw new InputMismatchException(); } if(len <= 0){ return -1; } } return input[ptr++];\n    }\n    boolean isSpaceChar(int c){ return !( c >= 33 && c <= 126 ); \n    }\n    int skip(){ int b = readByte(); while(b != -1 && isSpaceChar(b)){ b = readByte(); } return b;\n    }\n    \n    char nc(){ return (char)skip();\n    }\n    String ns(){ int b = skip(); StringBuilder sb = new StringBuilder(); while(!isSpaceChar(b)){ sb.appendCodePoint(b); b=readByte(); } return sb.toString();\n    }\n    int ni(){ int n = 0,b = readByte(); boolean minus = false; while(b != -1 && !( (b >= '0' && b <= '9') || b == '-')){ b = readByte(); } if(b == '-'){ minus = true; b = readByte(); } if(b == -1){ return -1; } while(b >= '0' && b <= '9'){ n = n * 10 + (b - '0'); b = readByte(); } return minus ? -n : n;\n    }\n    long nl(){ long n = 0L; int b = readByte(); boolean minus = false; while(b != -1 && !( (b >= '0' && b <= '9') || b == '-')){ b = readByte(); } if(b == '-'){ minus = true; b = readByte(); } while(b >= '0' && b <= '9'){ n = n * 10 + (b - '0'); b = readByte(); } return minus ? -n : n;\n    }\n    double nd(){ return Double.parseDouble(ns());\n    }\n    float nf(){ return Float.parseFloat(ns());\n    }\n    int[] na(int n){ int a[] = new int[n]; for(int i = 0; i < n; i++){ a[i] = ni(); } return a;\n    }\n    char[] ns(int n){ char c[] = new char[n]; int i,b = skip(); for(i = 0; i < n; i++){ if(isSpaceChar(b)){ break; } c[i] = (char)b; b = readByte(); } return i == n ? c : Arrays.copyOf(c,i);\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint T[400020];\nint arr[100005];\nint query(int at, int L, int R, int l, int r) {\n  if (r < L || R < l) return 0;\n  if (l <= L && R <= r) return T[at];\n  int mid = (L + R) / 2;\n  int x = query(at * 2, L, mid, l, r);\n  int y = query(at * 2 + 1, mid + 1, R, l, r);\n  return max(x, y);\n}\nvoid update(int at, int L, int R, int pos, int u) {\n  if (L == R) {\n    T[at] = u;\n    return;\n  }\n  int mid = (L + R) / 2;\n  if (pos <= mid) {\n    update(at * 2, L, mid, pos, u);\n  } else {\n    update(at * 2 + 1, mid + 1, R, pos, u);\n  }\n  T[at] = max(T[at * 2], T[at * 2 + 1]);\n}\nvoid build(int at, int L, int R) {\n  T[at] = 0;\n  if (L == R) {\n    T[at] = 0;\n    return;\n  }\n  int mid = (L + R) / 2;\n  build(at * 2, L, mid);\n  build(at * 2 + 1, mid + 1, R);\n  T[at] = max(T[at * 2], T[at * 2 + 1]);\n}\nbool comp(const pair<int, int> &a, const pair<int, int> &b) {\n  if (a.first == b.first) {\n    return a.second > b.second;\n  }\n  return a.first < b.first;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int n;\n  cin >> n;\n  long long a[n + 1];\n  map<long long, int> mp;\n  vector<pair<int, int> > vec;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n    mp[a[i]] = i;\n    vec.push_back({a[i], i});\n  }\n  sort(vec.begin(), vec.end(), comp);\n  build(1, 1, n);\n  for (int i = 0; i < n; i++) {\n    int u = query(1, 1, n, 1, vec[i].second) + 1;\n    update(1, 1, n, vec[i].second, u);\n  }\n  int mx = 1;\n  for (int i = 1; i <= n; i++) {\n    mx = max(mx, T[i]);\n  }\n  cout << mx;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 100005;\nint subseq(int n, const int *a) {\n  static int b[N + 1];\n  int i, l, r, m, ret = 0;\n  for (i = 0; i < n; b[l] = i++, ret += (l > ret)) {\n    for (m = ((l = 1) + (r = ret)) >> 1; l <= r; m = (l + r) >> 1) {\n      if (((a[b[m]]) < (a[i]))) {\n        l = m + 1;\n      } else {\n        r = m - 1;\n      }\n    }\n  }\n  return ret;\n}\nint n, a[N];\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", a + i);\n  }\n  printf(\"%d\\n\", subseq(n, a));\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint p[100100], buf[100100];\nint main() {\n  int ans = 1, n;\n  memset(buf, 0x3f3f, sizeof(buf));\n  cin >> n;\n  for (int i = 0; i < n; i++) scanf(\"%d\", p + i);\n  for (int i = 0; i < n; i++) {\n    int j = lower_bound(buf, buf + n, p[i]) - buf;\n    buf[j] = p[i];\n    ans = max(ans, j + 1);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint ans, a[100010], c[100010], n, t;\nvoid add(int pos, int x) {\n  while (pos <= n) c[pos] = max(c[pos], x), pos += pos & -pos;\n}\nint ask(int pos, int res = 0) {\n  while (pos) res = max(res, c[pos]), pos -= pos & -pos;\n  return res;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i)\n    scanf(\"%d\", &a[i]), t = ask(a[i] - 1) + 1, ans = max(ans, t), add(a[i], t);\n  printf(\"%d\", ans);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class icpc\n{\n    public static void main(String[] args) throws IOException\n    {\n        Reader in = new Reader();\n        //BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        int n = in.nextInt();\n        int[] A = new int[n];\n        for (int i=0;i<n;i++)   A[i] = in.nextInt();\n        System.out.println(LIS(A));\n    }\n    public static int LIS(int[] X)\n    {\n        int[] parent = new int[X.length];\n        int[] increasingSub = new int[X.length + 1];\n        int length = 0;\n\n        for (int i=0;i<X.length;i++)\n        {\n            int low = 1;\n            int high = length;\n            while (low <= high)\n            {\n                int mid = (int)Math.ceil((low + high) / 2);\n\n                if (X[increasingSub[mid]] < X[i])\n                {\n                    low = mid + 1;\n                }\n                else\n                    high = mid - 1;\n            }\n\n            int pos = low;\n            parent[i] = increasingSub[pos - 1];\n            increasingSub[pos] = i;\n            if (pos > length)\n                length = pos;\n        }\n        return length;\n    }\n}\nclass DSU\n{\n    int[] parent;\n    int[] size;\n    //Pass number of total nodes as parameter to the constructor\n    DSU(int n)\n    {\n        this.parent = new int[n];\n        this.size = new int[n];\n        Arrays.fill(parent, -1);\n    }\n\n    public void makeSet(int v)\n    {\n        parent[v] = v;\n        size[v] = 1;\n    }\n\n    public int findSet(int v)\n    {\n        if (v == parent[v]) return v;\n        return parent[v] = findSet(parent[v]);\n    }\n\n    public void unionSets(int a, int b)\n    {\n        a = findSet(a);\n        b = findSet(b);\n        if (a != b)\n        {\n            if (size[a] < size[b])\n            {\n                int temp = a;\n                a = b;\n                b = temp;\n            }\n            parent[b] = a;\n            size[a] += size[b];\n        }\n    }\n}\nclass FastFourierTransform\n{\n    private void fft(double[] a, double[] b, boolean invert)\n    {\n        int count = a.length;\n        for (int i = 1, j = 0; i < count; i++)\n        {\n            int bit = count >> 1;\n            for (; j >= bit; bit >>= 1)\n                j -= bit;\n            j += bit;\n            if (i < j)\n            {\n                double temp = a[i];\n                a[i] = a[j];\n                a[j] = temp;\n                temp = b[i];\n                b[i] = b[j];\n                b[j] = temp;\n            }\n        }\n        for (int len = 2; len <= count; len <<= 1)\n        {\n            int halfLen = len >> 1;\n            double angle = 2 * Math.PI / len;\n            if (invert)\n                angle = -angle;\n            double wLenA = Math.cos(angle);\n            double wLenB = Math.sin(angle);\n            for (int i = 0; i < count; i += len)\n            {\n                double wA = 1;\n                double wB = 0;\n                for (int j = 0; j < halfLen; j++)\n                {\n                    double uA = a[i + j];\n                    double uB = b[i + j];\n                    double vA = a[i + j + halfLen] * wA - b[i + j + halfLen] * wB;\n                    double vB = a[i + j + halfLen] * wB + b[i + j + halfLen] * wA;\n                    a[i + j] = uA + vA;\n                    b[i + j] = uB + vB;\n                    a[i + j + halfLen] = uA - vA;\n                    b[i + j + halfLen] = uB - vB;\n                    double nextWA = wA * wLenA - wB * wLenB;\n                    wB = wA * wLenB + wB * wLenA;\n                    wA = nextWA;\n                }\n            }\n        }\n        if (invert)\n        {\n            for (int i = 0; i < count; i++)\n            {\n                a[i] /= count;\n                b[i] /= count;\n            }\n        }\n    }\n\n    public long[] multiply(long[] a, long[] b)\n    {\n        int resultSize = Integer.highestOneBit(Math.max(a.length, b.length) - 1) << 2;\n        resultSize = Math.max(resultSize, 1);\n        double[] aReal = new double[resultSize];\n        double[] aImaginary = new double[resultSize];\n        double[] bReal = new double[resultSize];\n        double[] bImaginary = new double[resultSize];\n        for (int i = 0; i < a.length; i++)\n            aReal[i] = a[i];\n        for (int i = 0; i < b.length; i++)\n            bReal[i] = b[i];\n        fft(aReal, aImaginary, false);\n        fft(bReal, bImaginary, false);\n        for (int i = 0; i < resultSize; i++)\n        {\n            double real = aReal[i] * bReal[i] - aImaginary[i] * bImaginary[i];\n            aImaginary[i] = aImaginary[i] * bReal[i] + bImaginary[i] * aReal[i];\n            aReal[i] = real;\n        }\n        fft(aReal, aImaginary, true);\n        long[] result = new long[resultSize];\n        for (int i = 0; i < resultSize; i++)\n            result[i] = Math.round(aReal[i]);\n        return result;\n    }\n}\nclass NumberTheory\n{\n    public boolean isPrime(long n)\n    {\n        if(n < 2)\n            return false;\n        for(long x = 2;x * x <= n;x++)\n        {\n            if(n % x == 0)\n                return false;\n        }\n        return true;\n    }\n    public ArrayList<Long> primeFactorisation(long n)\n    {\n        ArrayList<Long> f = new ArrayList<>();\n        for(long x=2;x * x <= n;x++)\n        {\n            while(n % x == 0)\n            {\n                f.add(x);\n                n /= x;\n            }\n        }\n        if(n > 1)\n            f.add(n);\n        return f;\n    }\n    public int[] sieveOfEratosthenes(int n)\n    {\n        //Returns an array with the smallest prime factor for each number and primes marked as 0\n        int[] sieve = new int[n + 1];\n        for(int x=2;x * x <= n;x++)\n        {\n            if(sieve[x] != 0)\n                continue;\n            for(int u=x*x;u<=n;u+=x)\n            {\n                if(sieve[u] == 0)\n                {\n                    sieve[u] = x;\n                }\n            }\n        }\n        return sieve;\n    }\n    public long gcd(long a, long b)\n    {\n        if(b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n    public long phi(long n)\n    {\n        double result = n;\n\n        for(long p=2;p*p<=n;p++)\n        {\n            if(n % p == 0)\n            {\n                while (n % p == 0)\n                    n /= p;\n                result *= (1.0 - (1.0 / (double)p));\n            }\n        }\n        if(n > 1)\n            result *= (1.0 - (1.0 / (double)n));\n        return (long)result;\n    }\n    public Name extendedEuclid(long a, long b)\n    {\n        if(b == 0)\n            return new Name(a, 1, 0);\n        Name n1 = extendedEuclid(b, a % b);\n        Name n2 = new Name(n1.d, n1.y, n1.x - (long)Math.floor((double)a / b) * n1.y);\n        return n2;\n    }\n    public long modularExponentiation(long a, long b, long n)\n    {\n        long d = 1L;\n        String bString = Long.toBinaryString(b);\n        for(int i=0;i<bString.length();i++)\n        {\n            d = (d * d) % n;\n            if(bString.charAt(i) == '1')\n                d = (d * a) % n;\n        }\n        return d;\n    }\n}\nclass Name\n{\n    long d;\n    long x;\n    long y;\n\n    public Name(long d, long x, long y)\n    {\n        this.d = d;\n        this.x = x;\n        this.y = y;\n    }\n}\nclass SuffixArray\n{\n    int ALPHABET_SZ = 256, N;\n    int[] T, lcp, sa, sa2, rank, tmp, c;\n\n    public SuffixArray(String str)\n    {\n        this(toIntArray(str));\n    }\n\n    private static int[] toIntArray(String s)\n    {\n        int[] text = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) text[i] = s.charAt(i);\n        return text;\n    }\n\n    public SuffixArray(int[] text)\n    {\n        T = text;\n        N = text.length;\n        sa = new int[N];\n        sa2 = new int[N];\n        rank = new int[N];\n        c = new int[Math.max(ALPHABET_SZ, N)];\n        construct();\n        kasai();\n    }\n\n    private void construct()\n    {\n        int i, p, r;\n        for (i = 0; i < N; ++i) c[rank[i] = T[i]]++;\n        for (i = 1; i < ALPHABET_SZ; ++i) c[i] += c[i - 1];\n        for (i = N - 1; i >= 0; --i) sa[--c[T[i]]] = i;\n        for (p = 1; p < N; p <<= 1)\n        {\n            for (r = 0, i = N - p; i < N; ++i) sa2[r++] = i;\n            for (i = 0; i < N; ++i) if (sa[i] >= p) sa2[r++] = sa[i] - p;\n            Arrays.fill(c, 0, ALPHABET_SZ, 0);\n            for (i = 0; i < N; ++i) c[rank[i]]++;\n            for (i = 1; i < ALPHABET_SZ; ++i) c[i] += c[i - 1];\n            for (i = N - 1; i >= 0; --i) sa[--c[rank[sa2[i]]]] = sa2[i];\n            for (sa2[sa[0]] = r = 0, i = 1; i < N; ++i)\n            {\n                if (!(rank[sa[i - 1]] == rank[sa[i]]\n                        && sa[i - 1] + p < N\n                        && sa[i] + p < N\n                        && rank[sa[i - 1] + p] == rank[sa[i] + p])) r++;\n                sa2[sa[i]] = r;\n            }\n            tmp = rank;\n            rank = sa2;\n            sa2 = tmp;\n            if (r == N - 1) break;\n            ALPHABET_SZ = r + 1;\n        }\n    }\n\n    private void kasai()\n    {\n        lcp = new int[N];\n        int[] inv = new int[N];\n        for (int i = 0; i < N; i++) inv[sa[i]] = i;\n        for (int i = 0, len = 0; i < N; i++)\n        {\n            if (inv[i] > 0)\n            {\n                int k = sa[inv[i] - 1];\n                while ((i + len < N) && (k + len < N) && T[i + len] == T[k + len]) len++;\n                lcp[inv[i] - 1] = len;\n                if (len > 0) len--;\n            }\n        }\n    }\n}\nclass ZAlgorithm\n{\n    public int[] calculateZ(char input[])\n    {\n        int Z[] = new int[input.length];\n        int left = 0;\n        int right = 0;\n        for(int k = 1; k < input.length; k++) {\n            if(k > right) {\n                left = right = k;\n                while(right < input.length && input[right] == input[right - left]) {\n                    right++;\n                }\n                Z[k] = right - left;\n                right--;\n            } else {\n                //we are operating inside box\n                int k1 = k - left;\n                //if value does not stretches till right bound then just copy it.\n                if(Z[k1] < right - k + 1) {\n                    Z[k] = Z[k1];\n                } else { //otherwise try to see if there are more matches.\n                    left = k;\n                    while(right < input.length && input[right] == input[right - left]) {\n                        right++;\n                    }\n                    Z[k] = right - left;\n                    right--;\n                }\n            }\n        }\n        return Z;\n    }\n    public ArrayList<Integer> matchPattern(char text[], char pattern[])\n    {\n        char newString[] = new char[text.length + pattern.length + 1];\n        int i = 0;\n        for(char ch : pattern) {\n            newString[i] = ch;\n            i++;\n        }\n        newString[i] = '$';\n        i++;\n        for(char ch : text) {\n            newString[i] = ch;\n            i++;\n        }\n        ArrayList<Integer> result = new ArrayList<>();\n        int Z[] = calculateZ(newString);\n\n        for(i = 0; i < Z.length ; i++) {\n            if(Z[i] == pattern.length) {\n                result.add(i - pattern.length - 1);\n            }\n        }\n        return result;\n    }\n}\nclass KMPAlgorithm\n{\n    public int[] computeTemporalArray(char[] pattern)\n    {\n        int[] lps = new int[pattern.length];\n\n        int index = 0;\n        for(int i=1;i<pattern.length;)\n        {\n            if(pattern[i] == pattern[index])\n            {\n                lps[i] = index + 1;\n                index++;\n                i++;\n            }\n            else\n            {\n                if(index != 0)\n                {\n                    index = lps[index - 1];\n                }\n                else\n                {\n                    lps[i] = 0;\n                    i++;\n                }\n            }\n        }\n        return lps;\n    }\n\n    public ArrayList<Integer> KMPMatcher(char[] text, char[] pattern)\n    {\n        int[] lps = computeTemporalArray(pattern);\n\n        int j = 0;\n        int i = 0;\n        int n = text.length;\n        int m = pattern.length;\n        ArrayList<Integer> indices = new ArrayList<>();\n        while(i < n)\n        {\n            if(pattern[j] == text[i])\n            {\n                i++;\n                j++;\n            }\n            if(j == m)\n            {\n                indices.add(i - j);\n                j = lps[j - 1];\n            }\n            else if(i < n && pattern[j] != text[i])\n            {\n                if(j != 0)\n                    j = lps[j - 1];\n                else\n                    i = i + 1;\n            }\n        }\n        return indices;\n    }\n}\nclass Hashing\n{\n    public long[] computePowers(long p, int n, long m)\n    {\n        long[] powers = new long[n];\n        powers[0] = 1;\n        for(int i=1;i<n;i++)\n        {\n            powers[i] = (powers[i - 1] * p) % m;\n        }\n        return powers;\n    }\n    public long computeHash(String s)\n    {\n        long p = 31;\n        long m = 1_000_000_009;\n        long hashValue = 0L;\n        long[] powers = computePowers(p, s.length(), m);\n        for(int i=0;i<s.length();i++)\n        {\n            char ch = s.charAt(i);\n            hashValue = (hashValue + (ch - 'a' + 1) * powers[i]) % m;\n        }\n        return hashValue;\n    }\n}\nclass BasicFunctions\n{\n    public long min(long[] A)\n    {\n        long min = Long.MAX_VALUE;\n        for(int i=0;i<A.length;i++)\n        {\n            min = Math.min(min, A[i]);\n        }\n        return min;\n    }\n    public long max(long[] A)\n    {\n        long max = Long.MAX_VALUE;\n        for(int i=0;i<A.length;i++)\n        {\n            max = Math.max(max, A[i]);\n        }\n        return max;\n    }\n}\nclass MergeSortInt\n{\n    // Merges two subarrays of arr[].\n    // First subarray is arr[l..m]\n    // Second subarray is arr[m+1..r]\n    void merge(int arr[], int l, int m, int r) {\n        // Find sizes of two subarrays to be merged\n        int n1 = m - l + 1;\n        int n2 = r - m;\n\n        /* Create temp arrays */\n        int L[] = new int[n1];\n        int R[] = new int[n2];\n\n        /*Copy data to temp arrays*/\n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n\n\n        /* Merge the temp arrays */\n\n        // Initial indexes of first and second subarrays\n        int i = 0, j = 0;\n\n        // Initial index of merged subarry array\n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            } else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n\n        /* Copy remaining elements of L[] if any */\n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n\n        /* Copy remaining elements of R[] if any */\n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n\n    // Main function that sorts arr[l..r] using\n    // merge()\n    void sort(int arr[], int l, int r) {\n        if (l < r) {\n            // Find the middle point\n            int m = (l + r) / 2;\n\n            // Sort first and second halves\n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n\n            // Merge the sorted halves\n            merge(arr, l, m, r);\n        }\n    }\n\n}\nclass MergeSortLong\n{\n    // Merges two subarrays of arr[].\n    // First subarray is arr[l..m]\n    // Second subarray is arr[m+1..r]\n    void merge(long arr[], int l, int m, int r) {\n        // Find sizes of two subarrays to be merged\n        int n1 = m - l + 1;\n        int n2 = r - m;\n\n        /* Create temp arrays */\n        long L[] = new long[n1];\n        long R[] = new long[n2];\n\n        /*Copy data to temp arrays*/\n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n\n\n        /* Merge the temp arrays */\n\n        // Initial indexes of first and second subarrays\n        int i = 0, j = 0;\n\n        // Initial index of merged subarry array\n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            } else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n\n        /* Copy remaining elements of L[] if any */\n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n\n        /* Copy remaining elements of R[] if any */\n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n\n    // Main function that sorts arr[l..r] using\n    // merge()\n    void sort(long arr[], int l, int r) {\n        if (l < r) {\n            // Find the middle point\n            int m = (l + r) / 2;\n\n            // Sort first and second halves\n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n\n            // Merge the sorted halves\n            merge(arr, l, m, r);\n        }\n    }\n}\nclass Node\n{\n\n    int x;\n    int y;\n\n    public Node(int x, int y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n\n    @Override\n    public boolean equals(Object ob)\n    {\n        if(ob == null)\n            return false;\n        if(!(ob instanceof Node))\n            return false;\n        if(ob == this)\n            return true;\n        Node obj = (Node)ob;\n        if(this.x == obj.x && this.y == obj.y)\n            return true;\n        return false;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return (int)this.x;\n    }\n}\nclass Reader\n{\n    final private int BUFFER_SIZE = 1 << 16;\n    private DataInputStream din;\n    private byte[] buffer;\n    private int bufferPointer, bytesRead;\n\n    public Reader()\n    {\n        din = new DataInputStream(System.in);\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public Reader(String file_name) throws IOException\n    {\n        din = new DataInputStream(new FileInputStream(file_name));\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public String readLine() throws IOException\n    {\n        byte[] buf = new byte[64]; // line length\n        int cnt = 0, c;\n        while ((c = read()) != -1)\n        {\n            if (c == '\\n')\n                break;\n            buf[cnt++] = (byte) c;\n        }\n        return new String(buf, 0, cnt);\n    }\n\n    public int nextInt() throws IOException\n    {\n        int ret = 0;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n        do\n        {\n            ret = ret * 10 + c - '0';\n        }  while ((c = read()) >= '0' && c <= '9');\n\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    public long nextLong() throws IOException\n    {\n        long ret = 0;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n        do {\n            ret = ret * 10 + c - '0';\n        }\n        while ((c = read()) >= '0' && c <= '9');\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    public double nextDouble() throws IOException\n    {\n        double ret = 0, div = 1;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n\n        do {\n            ret = ret * 10 + c - '0';\n        }\n        while ((c = read()) >= '0' && c <= '9');\n\n        if (c == '.')\n        {\n            while ((c = read()) >= '0' && c <= '9')\n            {\n                ret += (c - '0') / (div *= 10);\n            }\n        }\n\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    private void fillBuffer() throws IOException\n    {\n        bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n        if (bytesRead == -1)\n            buffer[0] = -1;\n    }\n\n    private byte read() throws IOException\n    {\n        if (bufferPointer == bytesRead)\n            fillBuffer();\n        return buffer[bufferPointer++];\n    }\n\n    public void close() throws IOException\n    {\n        if (din == null)\n            return;\n        din.close();\n    }\n}\nclass FenwickTree\n{\n    public void update(long[] fenwickTree,long delta,int index)\n    {\n        index += 1;\n        while(index < fenwickTree.length)\n        {\n            fenwickTree[index] += delta;\n            index = index + (index & (-index));\n        }\n    }\n    public long prefixSum(long[] fenwickTree,int index)\n    {\n        long sum = 0L;\n        index += 1;\n        while(index > 0)\n        {\n            sum += fenwickTree[index];\n            index -= (index & (-index));\n        }\n        return sum;\n    }\n}\nclass SegmentTree\n{\n    public int nextPowerOfTwo(int num)\n    {\n        if(num == 0)\n            return 1;\n        if(num > 0 && (num & (num - 1)) == 0)\n            return num;\n        while((num &(num - 1)) > 0)\n        {\n            num = num & (num - 1);\n        }\n        return num << 1;\n    }\n    public int[] createSegmentTree(int[] input)\n    {\n        int np2 = nextPowerOfTwo(input.length);\n        int[] segmentTree = new int[np2 * 2 - 1];\n\n        for(int i=0;i<segmentTree.length;i++)\n            segmentTree[i] = Integer.MIN_VALUE;\n\n        constructSegmentTree(segmentTree,input,0,input.length-1,0);\n        return segmentTree;\n\n    }\n    private void constructSegmentTree(int[] segmentTree,int[] input,int low,int high,int pos)\n    {\n        if(low == high)\n        {\n            segmentTree[pos] = input[low];\n            return;\n        }\n        int mid = (low + high)/ 2;\n        constructSegmentTree(segmentTree,input,low,mid,2*pos + 1);\n        constructSegmentTree(segmentTree,input,mid+1,high,2*pos + 2);\n        segmentTree[pos] = Math.max(segmentTree[2*pos + 1],segmentTree[2*pos + 2]);\n    }\n    public int rangeMinimumQuery(int []segmentTree,int qlow,int qhigh,int len)\n    {\n        return rangeMinimumQuery(segmentTree,0,len-1,qlow,qhigh,0);\n    }\n    private int rangeMinimumQuery(int segmentTree[],int low,int high,int qlow,int qhigh,int pos)\n    {\n        if(qlow <= low && qhigh >= high){\n            return segmentTree[pos];\n        }\n        if(qlow > high || qhigh < low){\n            return Integer.MIN_VALUE;\n        }\n        int mid = (low+high)/2;\n        return Math.max(rangeMinimumQuery(segmentTree, low, mid, qlow, qhigh, 2 * pos + 1),\n                rangeMinimumQuery(segmentTree, mid + 1, high, qlow, qhigh, 2 * pos + 2));\n    }\n}\nclass Trie\n{\n\n    private class TrieNode\n    {\n        Map<Character, TrieNode> children;\n        boolean endOfWord;\n        public TrieNode()\n        {\n            children = new HashMap<>();\n            endOfWord = false;\n        }\n    }\n\n    private final TrieNode root;\n    public Trie()\n    {\n        root = new TrieNode();\n    }\n\n    public void insert(String word)\n    {\n        TrieNode current = root;\n        for (int i = 0; i < word.length(); i++)\n        {\n            char ch = word.charAt(i);\n            TrieNode node = current.children.get(ch);\n            if (node == null)\n            {\n                node = new TrieNode();\n                current.children.put(ch, node);\n            }\n            current = node;\n        }\n        current.endOfWord = true;\n    }\n\n    public boolean search(String word)\n    {\n        TrieNode current = root;\n        for (int i = 0; i < word.length(); i++)\n        {\n            char ch = word.charAt(i);\n            TrieNode node = current.children.get(ch);\n            if (node == null)\n            {\n                return false;\n            }\n            current = node;\n        }\n        return current.endOfWord;\n    }\n\n    public void delete(String word)\n    {\n        delete(root, word, 0);\n    }\n\n    private boolean delete(TrieNode current, String word, int index)\n    {\n        if (index == word.length())\n        {\n            if (!current.endOfWord)\n            {\n                return false;\n            }\n            current.endOfWord = false;\n            return current.children.size() == 0;\n        }\n        char ch = word.charAt(index);\n        TrieNode node = current.children.get(ch);\n        if (node == null)\n        {\n            return false;\n        }\n        boolean shouldDeleteCurrentNode = delete(node, word, index + 1);\n\n        if (shouldDeleteCurrentNode)\n        {\n            current.children.remove(ch);\n            return current.children.size() == 0;\n        }\n        return false;\n    }\n}\nclass SegmentTreeLazy\n{\n    public int nextPowerOfTwo(int num)\n    {\n        if(num == 0)\n            return 1;\n        if(num > 0 && (num & (num - 1)) == 0)\n            return num;\n        while((num &(num - 1)) > 0)\n        {\n            num = num & (num - 1);\n        }\n        return num << 1;\n    }\n\n    public int[] createSegmentTree(int input[])\n    {\n        int nextPowOfTwo = nextPowerOfTwo(input.length);\n        int segmentTree[] = new int[nextPowOfTwo*2 -1];\n\n        for(int i=0; i < segmentTree.length; i++){\n            segmentTree[i] = Integer.MAX_VALUE;\n        }\n        constructMinSegmentTree(segmentTree, input, 0, input.length - 1, 0);\n        return segmentTree;\n    }\n\n    private void constructMinSegmentTree(int segmentTree[], int input[], int low, int high,int pos)\n    {\n        if(low == high)\n        {\n            segmentTree[pos] = input[low];\n            return;\n        }\n        int mid = (low + high)/2;\n        constructMinSegmentTree(segmentTree, input, low, mid, 2 * pos + 1);\n        constructMinSegmentTree(segmentTree, input, mid + 1, high, 2 * pos + 2);\n        segmentTree[pos] = Math.min(segmentTree[2*pos+1], segmentTree[2*pos+2]);\n    }\n\n    public void updateSegmentTreeRangeLazy(int input[], int segmentTree[], int lazy[], int startRange, int endRange, int delta)\n    {\n        updateSegmentTreeRangeLazy(segmentTree, lazy, startRange, endRange, delta, 0, input.length - 1, 0);\n    }\n\n    private void updateSegmentTreeRangeLazy(int segmentTree[], int lazy[], int startRange, int endRange, int delta, int low, int high, int pos)\n    {\n        if(low > high)\n        {\n            return;\n        }\n        if (lazy[pos] != 0)\n        {\n            segmentTree[pos] += lazy[pos];\n            if (low != high)\n            {\n                lazy[2 * pos + 1] += lazy[pos];\n                lazy[2 * pos + 2] += lazy[pos];\n            }\n            lazy[pos] = 0;\n        }\n\n        if(startRange > high || endRange < low)\n        {\n            return;\n        }\n\n        if(startRange <= low && endRange >= high)\n        {\n            segmentTree[pos] += delta;\n            if(low != high) {\n                lazy[2*pos + 1] += delta;\n                lazy[2*pos + 2] += delta;\n            }\n            return;\n        }\n\n        int mid = (low + high)/2;\n        updateSegmentTreeRangeLazy(segmentTree, lazy, startRange, endRange, delta, low, mid, 2*pos+1);\n        updateSegmentTreeRangeLazy(segmentTree, lazy, startRange, endRange, delta, mid+1, high, 2*pos+2);\n        segmentTree[pos] = Math.min(segmentTree[2*pos + 1], segmentTree[2*pos + 2]);\n    }\n\n    public int rangeMinimumQueryLazy(int segmentTree[], int lazy[], int qlow, int qhigh, int len)\n    {\n        return rangeMinimumQueryLazy(segmentTree, lazy, qlow, qhigh, 0, len - 1, 0);\n    }\n\n    private int rangeMinimumQueryLazy(int segmentTree[], int lazy[], int qlow, int qhigh, int low, int high, int pos)\n    {\n        if(low > high)\n        {\n            return Integer.MAX_VALUE;\n        }\n        if (lazy[pos] != 0)\n        {\n            segmentTree[pos] += lazy[pos];\n            if (low != high)\n            {\n                lazy[2 * pos + 1] += lazy[pos];\n                lazy[2 * pos + 2] += lazy[pos];\n            }\n            lazy[pos] = 0;\n        }\n\n        if(qlow > high || qhigh < low)\n        {\n            return Integer.MAX_VALUE;\n        }\n\n        if(qlow <= low && qhigh >= high)\n        {\n            return segmentTree[pos];\n        }\n\n        int mid = (low+high)/2;\n        return Math.min(rangeMinimumQueryLazy(segmentTree, lazy, qlow, qhigh, low, mid, 2 * pos + 1), rangeMinimumQueryLazy(segmentTree, lazy,  qlow, qhigh, mid + 1, high, 2 * pos + 2));\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint CeilIndex(std::vector<int> &v, int l, int r, int key) {\n  while (r - l > 1) {\n    int m = l + (r - l) / 2;\n    if (v[m] >= key)\n      r = m;\n    else\n      l = m;\n  }\n  return r;\n}\nint LIS(std::vector<int> &v) {\n  if (v.size() == 0) return 0;\n  vector<int> tail(v.size(), 0);\n  int length = 1;\n  tail[0] = v[0];\n  for (size_t i = 1; i < v.size(); i++) {\n    if (v[i] < tail[0])\n      tail[0] = v[i];\n    else if (v[i] > tail[length - 1])\n      tail[length++] = v[i];\n    else\n      tail[CeilIndex(tail, -1, length - 1, v[i])] = v[i];\n  }\n  return length;\n}\nint main() {\n  int n;\n  cin >> n;\n  vector<int> v(n);\n  for (int i = 0; i < n; i++) cin >> v[i];\n  cout << LIS(v);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 111111;\nint n;\nint top;\nint a[N];\nint main() {\n  scanf(\"%d\", &n);\n  top = 0;\n  for (int i = 0; i != n + 1; i++) a[i] = N;\n  for (int i = 0; i != n; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    int w = upper_bound(a + 1, a + n, x) - a;\n    top = max(top, w);\n    a[w] = x;\n  }\n  printf(\"%d\\n\", top);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.DataInputStream;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.TreeSet;\n\n\npublic class ProblemC { \n\n    \n    \n    public static void main(String[] args) throws Exception {\n        \n        Parserdoubt7777121211 s = new Parserdoubt7777121211(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        \n        int n = s.nextInt();\n        int a[] = new int[n];\n        for (int i = 0; i < a.length; i++) {\n            a[i] = s.nextInt();\n        }\n        \n        int res = find_list(a).size();\n        out.println(res);\n        \n        out.close();\n    }\n    \n    private static ArrayList<Integer> find_list(int a[]) {\n\n        ArrayList<Integer> result = new ArrayList<Integer>();\n\n        int p[] = new int[a.length];\n\n        int u, v;\n        if (a.length == 0)\n            return result;\n\n        result.add(0);\n\n        for (int i = 1; i < a.length; i++) {\n            if (a[result.get(result.size() - 1)] < a[i]) {\n                p[i] = result.get(result.size() - 1);\n                result.add(i);\n                continue;\n            }\n\n            for (u = 0, v = result.size() - 1; u < v;) {\n                int c = (u + v) / 2;\n                if (a[result.get(c)] < a[i])\n                    u = c + 1;\n                else\n                    v = c;\n            }\n            if (a[i] < a[result.get(u)]) {\n                if (u > 0)\n                    p[i] = result.get(u - 1);\n                result.set(u, i);\n            }\n\n            int seq[] = new int[result.size()];\n            for (int j = 0; j < seq.length; j++) {\n                seq[j] = a[result.get(j)];\n            }\n        }\n\n        u = result.size();\n        v = result.get(result.size() - 1);\n        for (; u-- > 0; v = p[v])\n            result.set(u, v);\n\n        return result;\n    }\n}\n\n\nclass Parserdoubt7777121211\n{\n   final private int BUFFER_SIZE = 1 << 17;\n \n   private DataInputStream din;\n   private byte[] buffer;\n   private int bufferPointer, bytesRead;\n \n   public Parserdoubt7777121211(InputStream in)\n   {\n      din = new DataInputStream(in);\n      buffer = new byte[BUFFER_SIZE];\n      bufferPointer = bytesRead = 0;\n   }\n   public String nextString() throws Exception\n   {\n       StringBuffer sb=new StringBuffer(\"\");\n       byte c = read();\n       while (c <= ' ') c = read();\n       do\n       {\n           sb.append((char)c);\n           c=read();\n       }while(c>' ');\n       return sb.toString();\n   }\n   public char nextChar() throws Exception\n   {\n       byte c=read();\n       while(c<=' ') c= read();\n       return (char)c;\n   }\n   public int nextInt() throws Exception\n   {\n      int ret = 0;\n      byte c = read();\n      while (c <= ' ') c = read();\n      boolean neg = c == '-';\n      if (neg) c = read();\n      do\n      {\n          ret = ret * 10 + c - '0';\n         c = read();\n      } while (c > ' ');\n      if (neg) return -ret;\n      return ret;\n   }\n   public long nextLong() throws Exception\n   {\n      long ret = 0;\n      byte c = read();\n      while (c <= ' ') c = read();\n      boolean neg = c == '-';\n      if (neg) c = read();\n      do\n      {\n          ret = ret * 10 + c - '0';\n         c = read();\n      } while (c > ' ');\n      if (neg) return -ret;\n      return ret;\n   }\n   private void fillBuffer() throws Exception\n   {\n      bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n      if (bytesRead == -1) buffer[0] = -1;\n   }\n \n   private byte read() throws Exception\n   {\n      if (bufferPointer == bytesRead) fillBuffer();\n      return buffer[bufferPointer++];\n   }\n} "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200005;\nint a[N], aib[N];\nint n;\nvoid update(int i, int val) {\n  for (; i < N; i += ((i) & (-i))) aib[i] = max(aib[i], val);\n}\nint query(int i) {\n  int ret = 0;\n  for (; i > 0; i -= ((i) & (-i))) ret = max(ret, aib[i]);\n  return ret;\n}\nint main() {\n  int i, sol = 0, s;\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  for (i = 1; i <= n; i++) {\n    s = query(a[i] - 1);\n    update(a[i], s + 1);\n    sol = max(sol, s);\n  }\n  printf(\"%d\", sol + 1);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T1>\nvoid debug(T1 e) {\n  cout << e << endl;\n}\ntemplate <class T1, class T2>\nvoid debug(T1 e1, T2 e2) {\n  cout << e1 << \"\\t\" << e2 << endl;\n}\ntemplate <class T1, class T2, class T3>\nvoid debug(T1 e1, T2 e2, T3 e3) {\n  cout << e1 << \"\\t\" << e2 << \"\\t\" << e3 << endl;\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid debug(T1 e1, T2 e2, T3 e3, T4 e4) {\n  cout << e1 << \"\\t\" << e2 << \"\\t\" << e3 << \"\\t\" << e4 << endl;\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid debug(T1 e1, T2 e2, T3 e3, T4 e4, T5 e5) {\n  cout << e1 << \"\\t\" << e2 << \"\\t\" << e3 << \"\\t\" << e4 << \"\\t\" << e5 << endl;\n}\ntemplate <class T1, class T2, class T3, class T4, class T5, class T6>\nvoid debug(T1 e1, T2 e2, T3 e3, T4 e4, T5 e5, T6 e6) {\n  cout << e1 << \"\\t\" << e2 << \"\\t\" << e3 << \"\\t\" << e4 << \"\\t\" << e5 << \"\\t\"\n       << e6 << endl;\n}\ntemplate <class T>\nvoid debug(vector<vector<T> > e, int row, int col) {\n  int i, j;\n  for (i = 0; i < row; i++) {\n    for (j = 0; j < col; j++) cout << e[i][j] << \" \";\n    cout << endl;\n  }\n  cout << endl;\n}\ntemplate <class T>\nvoid debug(vector<basic_string<T> > e, int row, int col) {\n  int i, j;\n  for (i = 0; i < row; i++) {\n    for (j = 0; j < col; j++) cout << e[i][j];\n    cout << endl;\n  }\n  cout << endl;\n}\ntemplate <class T>\nvoid debug(T e[110][110], int row, int col) {\n  int i, j;\n  for (i = 0; i < row; i++) {\n    for (j = 0; j < col; j++) cout << e[i][j] << \" \";\n    cout << endl;\n  }\n}\ntemplate <class T>\nstring toString(T n) {\n  ostringstream oss;\n  oss << n;\n  oss.flush();\n  return oss.str();\n}\nint toInt(string s) {\n  int r = 0;\n  istringstream sin(s);\n  sin >> r;\n  return r;\n}\nbool isVowel(char ch) {\n  ch = tolower(ch);\n  if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u')\n    return true;\n  return false;\n}\nbool isUpper(char c) { return c >= 'A' && c <= 'Z'; }\nbool isLower(char c) { return c >= 'a' && c <= 'z'; }\nint heap[4 * 100010];\nvoid update(int in, int st, int end, int x, int val) {\n  if (st > x || end < x) return;\n  if (st == end) {\n    heap[in] = val;\n    return;\n  }\n  int mid = (st + end) / 2;\n  update(2 * in, st, mid, x, val);\n  update(2 * in + 1, mid + 1, end, x, val);\n  heap[in] = max(heap[2 * in], heap[2 * in + 1]);\n  return;\n}\nint query(int in, int st, int end, int x, int y) {\n  if (st > end) return 0;\n  if (st > y || end < x) return 0;\n  if (st >= x && end <= y) return heap[in];\n  int mid = (st + end) / 2;\n  int ret = query(2 * in, st, mid, x, y);\n  ret = max(ret, query(2 * in + 1, mid + 1, end, x, y));\n  return ret;\n}\nint main() {\n  int n;\n  while (cin >> n) {\n    memset(heap, 0, sizeof(heap));\n    int tem;\n    int i;\n    for (i = 1; i <= n; i++) {\n      cin >> tem;\n      update(1, 1, n, tem, query(1, 1, n, 1, tem - 1) + 1);\n    }\n    cout << heap[1] << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n  int c[n + 5];\n  int a[n];\n  int k, m = 1;\n  cin >> a[0];\n  k = a[0];\n  c[0] = 0;\n  c[1] = k;\n  for (int i = 1; i < n; i++) {\n    cin >> a[i];\n    k = lower_bound(c, c + m + 1, a[i]) - c;\n    m = max(k, m);\n    c[k] = a[i];\n  }\n  cout << m;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n = int(input())\nnum_list = list(map(int, input().split()))\n# def lower_bound(min_lis, x): \n#     #goal return the position of the first element >= x\n#     left = 0 \n#     right = len(min_lis) - 1\n#     res = -1\n#     while left <= right:\n#         mid = (left + right) // 2 \n#         if min_lis[mid] < x: \n#             left = mid + 1\n#         else:\n#             res = mid\n#             right = mid - 1\n#     return res\nimport bisect\n\ndef LongestIncreasingSubsequence(a, n):\n    min_lis = []\n    #lis = [0 for i in range(n)]\n    for i in range(n): \n        pos = bisect.bisect_left(min_lis, a[i])\n        if pos == len(min_lis):\n            #lis[i] = len(min_lis) + 1\n            min_lis.append(a[i])\n        else:\n            #lis[i] = pos + 1\n            min_lis[pos] = a[i]\n        #print(*min_lis)\n    return (len(min_lis))\n\nprint(LongestIncreasingSubsequence(num_list, n))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 100000 + 20;\nint fen[MAX_N];\nint n, ans;\nint get(int x) {\n  int res = 0;\n  for (; x > 0; x -= (x) & (-x)) res = max(res, fen[x]);\n  return res;\n}\nvoid upd(int x, int val) {\n  for (; x < n; x += (x) & (-x)) fen[x] = max(fen[x], val);\n}\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    int len = get(x - 1) + 1;\n    ans = max(ans, len);\n    upd(x, len);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class C {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tint[] array = new int[N];\n\t\tfor(int a=0;a<N;a++)\n\t\t\tarray[a]=sc.nextInt();\n\t\tSystem.out.println(longestIncreasingSubsequence(array));\n\t}\n\n\tstatic int longestIncreasingSubsequence(int[] x) {\n\t\tint[] z = new int[x.length];\n\t\tArrays.fill(z, Integer.MAX_VALUE);\n\t\tz[0] = x[0];\n\t\tfor (int i = 1; i < x.length; i++)\n\t\t\tz[binSearch(z, x[i])] = x[i];\n\t\treturn binSearch(z, Integer.MAX_VALUE / 2);\n\t}\n\n\tstatic int binSearch(int[] x, int val) {\n\t\tint l = 0, r = x.length - 1, ret = x.length;\n\t\twhile (l <= r) {\n\t\t\tint m = (l + r) / 2;\n\t\t\tif (x[m] > val)\n\t\t\t\tr = (ret = m) - 1;\n\t\t\telse\n\t\t\t\tl = m + 1;\n\t\t}\n\t\treturn ret;\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int(n);\n  scanf(\"%d\", &(n));\n  int((a)[(n)]);\n  for (int i = 0; i < (n); i++) scanf(\"%d\", &((a)[i]));\n  vector<int> lop;\n  int ci;\n  for (int(i) = 0; (i) < (n); (i)++) {\n    ci = upper_bound(lop.begin(), lop.end(), a[i]) - lop.begin();\n    if (ci >= int((lop).size()))\n      lop.push_back(a[i]);\n    else\n      lop[ci] = a[i];\n  }\n  cout << int((lop).size());\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint a[1000007];\nvector<int> v;\nvoid f(int x) {\n  int l = 0;\n  int r = v.size() - 1;\n  if (v.size() == 0) {\n    v.push_back(x);\n    return;\n  }\n  if (x > v[r]) {\n    v.push_back(x);\n    return;\n  }\n  int mid;\n  while (r - l > 1) {\n    mid = (r + l) / 2;\n    if (v[mid] < x)\n      l = mid;\n    else\n      r = mid;\n  }\n  if (v[l] < x) l++;\n  v[l] = x;\n}\nvoid input();\nvoid solve();\nint main() {\n  input();\n  solve();\n  return 0;\n}\nvoid input() {\n  v.clear();\n  scanf(\"%d\", &n);\n  int i;\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n    f(a[i]);\n  }\n}\nvoid solve() { printf(\"%d\\n\", v.size()); }\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double eps = 1e-8;\nconst double pi = acos(-1.0);\nconst int N = 1e5 + 10;\nint a[N], q[N];\nint main() {\n  int n, i;\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n  int r = 0;\n  q[r++] = a[1];\n  for (i = 2; i <= n; ++i) {\n    int whe = lower_bound(q, q + r, a[i]) - q;\n    if (whe == r)\n      q[r++] = a[i];\n    else\n      q[whe] = a[i];\n  }\n  printf(\"%d\\n\", r);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 100000 + 10;\nint n;\nint a[MAX];\nint sum[MAX];\nvoid add(int a, int b) {\n  for (; a < MAX; a += a & (-a)) sum[a] = max(sum[a], b);\n}\nint ask(int a) {\n  int ans = 0;\n  for (; a; a -= a & (-a)) ans = max(ans, sum[a]);\n  return ans;\n}\nint main() {\n  int i;\n  scanf(\"%d\", &n);\n  int ans = 0;\n  for ((i) = (1); (i) <= (n); ++(i)) {\n    scanf(\"%d\", &a[i]);\n    int f = ask(a[i]) + 1;\n    ans = max(ans, f);\n    add(a[i], f);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class _Bubble_sort_graph {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scn = new Scanner(System.in);\n\t\tint n = scn.nextInt();\n\t\tint[] arr = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarr[i] = scn.nextInt();\n\t\t}\n\t\tint[] temp = new int[n];\n\t\tint len = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (arr[i] > arr[temp[len]]) {\n\t\t\t\ttemp[len + 1] = i;\n\t\t\t\tlen++;\n\t\t\t} else if (arr[i] < arr[temp[0]]) {\n\t\t\t\ttemp[0] = i;\n\t\t\t} else {\n\t\t\t\tint left = 0;\n\t\t\t\tint right = len;\n\t\t\t\twhile (left <= right) {\n\t\t\t\t\tint mid = left + (right - left) / 2;\n\t\t\t\t\tif (arr[temp[mid]] >=arr[i] && (mid-1<0||arr[temp[mid - 1]] <arr[i])) {\n\t\t\t\t\t\ttemp[mid] = i;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (arr[temp[mid]] > arr[i]) {\n\t\t\t\t\t\tright = mid - 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tleft = mid + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(len+1);\n\t}\n\t static int CeilIndex(int A[], int l, int r, int key) \n\t    { \n\t        while (r - l > 1) { \n\t            int m = l + (r - l) / 2; \n\t            if (A[m] >= key) \n\t                r = m; \n\t            else\n\t                l = m; \n\t        } \n\t  \n\t        return r; \n\t    } \n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1000000000;\nconst int N = 100005;\nint f[N], n;\nint low(int i) { return i & (-i); }\nvoid up(int i, int j) {\n  while (i <= n) {\n    f[i] = max(f[i], j);\n    i += low(i);\n  }\n}\nint ask(int i) {\n  int ret = 0;\n  while (i > 0) {\n    ret = max(ret, f[i]);\n    i -= low(i);\n  }\n  return ret;\n}\nint main() {\n  scanf(\"%d\", &n);\n  int ans = 0;\n  for (int i = 0; i < n; ++i) {\n    int x;\n    scanf(\"%d\", &x);\n    int t = ask(x - 1) + 1;\n    ans = max(ans, t);\n    up(x, t);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint ar[100005];\nvector<int> A;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> ar[i];\n  for (int i = 0; i < n; i++) {\n    if (i == 0)\n      A.push_back(ar[i]);\n    else if (ar[i] < A[0])\n      A[0] = ar[i];\n    else if (ar[i] > A.back())\n      A.push_back(ar[i]);\n    else\n      A[lower_bound(A.begin(), A.end(), ar[i]) - A.begin()] = ar[i];\n  }\n  cout << A.size() << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint lis(vector<int> const& a) {\n  int n = a.size();\n  const int INF = 1e9;\n  vector<int> d;\n  d.push_back(a[0]);\n  for (int i = 1; i < n; i++) {\n    if (a[i] > d[d.size() - 1])\n      d.push_back(a[i]);\n    else {\n      int idx = lower_bound(d.begin(), d.end(), a[i]) - d.begin();\n      if (idx == n) continue;\n      d[idx] = a[i];\n    }\n  }\n  return d.size();\n}\nint n, no;\nvector<int> vi;\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &no);\n    vi.push_back(no);\n  }\n  printf(\"%d\\n\", lis(vi));\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\nimport sys\nfrom bisect import bisect_right, bisect_left, insort_right\nfrom collections import Counter, defaultdict\nfrom heapq import heappop, heappush\nfrom itertools import accumulate, permutations, combinations\nfrom sys import stdout\n\nR = lambda: map(int, input().split())\nn = int(input())\narr = list(R())\ntps = [(0, 0)]\nfor x in arr:\n    i = bisect_left(tps, (x, -1)) - 1\n    tps.insert(i + 1, (x, tps[i][1] + 1))\n    if i + 2 < len(tps) and tps[i + 1][1] >= tps[i + 2][1]:\n        del tps[i + 2]\nprint(max(x[1] for x in tps))"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class B {\n    public void run() {\n        try {\n            int n = reader.nextInt();\n            int[] a = new int[n];\n            for (int i = 0; i < n; ++ i) {\n                a[i] = reader.nextInt() - 1;\n            }\n            int[] count = new int[n];\n            int[] maximum = new int[n];\n            int answer = 0;\n            for (int i = 0; i < n; ++ i) {\n                for (int k = a[i]; k >= 0; k -= ~k & k + 1) {\n                    maximum[i] = Math.max(maximum[i], count[k]);\n                }\n                maximum[i] ++;\n                for (int k = a[i]; k < n; k += ~k & k + 1) {\n                    count[k] = Math.max(count[k], maximum[i]);\n                }\n                answer = Math.max(answer, maximum[i]);\n            }\n            writer.println(answer);\n        } catch (IOException ex) {\n        }\n        writer.close();\n    }\n\n    InputReader reader;\n    PrintWriter writer;\n\n    B() {\n        reader = new InputReader();\n        writer = new PrintWriter(System.out);\n    }\n\n    public static void main(String[] args) {\n        new B().run();\n    }\n\n    void debug(Object...os) {\n        System.err.println(Arrays.deepToString(os));\n    }\n}\n\nclass InputReader {\n    BufferedReader reader;\n    StringTokenizer tokenizer;\n\n    InputReader() {\n        reader = new BufferedReader(new InputStreamReader(System.in));\n        tokenizer = new StringTokenizer(\"\");\n    }\n\n    String next() throws IOException {\n        while (!tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n    Integer nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 2034567891;\nconst long long int INF64 = 1234567890123456789ll;\nint dx[] = {1, -1, 0, 0, 1, -1, -1, 1};\nint dy[] = {0, 0, 1, -1, -1, -1, 1, 1};\nlong long int power(long long int x, long long int y) {\n  long long int ans = 1;\n  while (y > 0) {\n    if (y & 1) ans = (ans * x) % 1000000007;\n    x = (x * x) % 1000000007;\n    y /= 2;\n  }\n  return ans;\n}\nint small[100005], arr[100005], parent[100005], n;\nint binary_search(int sz, int value) {\n  int low = 0;\n  int high = sz - 1;\n  int mid;\n  while (low < high) {\n    mid = low + ((high - low) / 2);\n    if (arr[small[mid]] > value)\n      high = mid;\n    else if (arr[small[mid]] < value)\n      low = mid + 1;\n    else\n      return mid;\n  }\n  return low;\n}\nvoid LIS() {\n  int size = 0;\n  for (int i = 0; i < n; i++) {\n    if (i == 0) {\n      small[size] = i;\n      parent[i] = -1;\n    } else if (arr[i] <= arr[small[size]]) {\n      int pos = binary_search(size + 1, arr[i]);\n      small[pos] = i;\n      if (pos != 0) {\n        parent[i] = small[pos - 1];\n      }\n    } else {\n      size = size + 1;\n      small[size] = i;\n      parent[i] = small[size - 1];\n    }\n  }\n  cout << size + 1 << endl;\n  int pos = small[size];\n  vector<int> v;\n  while (size >= 0) {\n    v.push_back(arr[pos]);\n    pos = parent[pos];\n    size--;\n  }\n}\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> arr[i];\n  LIS();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxN = 1e5 + 100;\nint n, last, a[maxN], BIS[maxN];\nvoid input() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n}\nint find(int l, int r, int key) {\n  int now = (r + l) / 2;\n  if ((r - l == 1 && BIS[r] > key && BIS[r - 1] <= key))\n    return r;\n  else if (r - l == 1 && BIS[l] > key && BIS[l - 1] <= key)\n    return l;\n  else if (r == l && BIS[r] > key && BIS[r - 1] <= key)\n    return r;\n  else if (r - l == 1)\n    return 0;\n  else if (r == l)\n    return 0;\n  if (BIS[now] > key && BIS[now - 1] <= key)\n    return now;\n  else if (BIS[now] < key)\n    return find(now + 1, r, key);\n  else\n    return find(l, now - 1, key);\n  return 0;\n}\nint main() {\n  input();\n  last = 1;\n  BIS[1] = a[1];\n  for (int i = 2; i <= n; i++) {\n    BIS[0] = 0;\n    if (a[i] > BIS[last]) {\n      last++;\n      BIS[last] = a[i];\n    }\n    BIS[find(1, last, a[i])] = a[i];\n  }\n  cout << last << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint f[1000001] = {0}, n;\nint get(int i) {\n  int mx = 0;\n  while (i > 0) {\n    mx = (f[i] > mx) ? f[i] : mx;\n    i -= i & -i;\n  }\n  return mx;\n}\nvoid update(int i, int t) {\n  while (i <= 1000000) {\n    f[i] = (t > f[i]) ? t : f[i];\n    i += i & -i;\n  }\n}\nint main() {\n  int i, x, t, ans = 0;\n  scanf(\"%d\", &n);\n  while (n--) {\n    scanf(\"%d\", &x);\n    t = get(x - 1) + 1;\n    update(x, t);\n    ans = (t > ans) ? t : ans;\n  }\n  printf(\"%d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool cmp(const pair<int, int>& p1, const pair<int, int>& p2) {\n  return p1.first < p2.first;\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vector<int> v;\n  for (int i = 0; i < n; i++) {\n    int a;\n    scanf(\"%d\", &a);\n    v.push_back(a);\n  }\n  vector<int> v1;\n  int res = n;\n  for (int i = 0; i < n; i++) {\n    int idx = upper_bound(v1.begin(), v1.end(), v[i]) - v1.begin();\n    if (idx != v1.size()) {\n      v1[idx] = v[i];\n      res--;\n    } else\n      v1.push_back(v[i]);\n  }\n  printf(\"%d\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, a[100000 + 5];\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  int lmax = 0, l;\n  vector<int> v;\n  for (int i = 0; i < n; i++) {\n    vector<int>::iterator it;\n    it = lower_bound(v.begin(), v.end(), a[i]);\n    l = (it - v.begin() + 1);\n    lmax = max(lmax, l);\n    if (it == v.end()) {\n      v.push_back(a[i]);\n    } else {\n      *it = a[i];\n    }\n  }\n  cout << lmax << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\ninline T sqr(T t) {\n  return t * t;\n}\nint a[100100], d[100100];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n  }\n  for (int i = 1; i <= n; i++) d[i] = 1e9;\n  d[0] = -1e9;\n  for (int i = 1; i <= n; i++) {\n    int l = 0, r = n;\n    while (r - l > 1) {\n      int mid = (l + r) >> 1;\n      if (d[mid] <= a[i])\n        l = mid;\n      else\n        r = mid;\n    }\n    int pos;\n    if (d[l] > a[i])\n      pos = l;\n    else\n      pos = r;\n    if (d[pos - 1] < a[i] && a[i] < d[pos]) {\n      d[pos] = a[i];\n    }\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; i++)\n    if (d[i] == 1e9)\n      break;\n    else\n      ans++;\n  cout << ans;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.math.*;\nimport java.util.regex.*;\n\npublic class BubbleSortGraph {\n\tpublic static void main(String[]args)throws IOException{\n\t\tint[] array;\n\t\tBufferedReader f = new BufferedReader(new InputStreamReader(System.in));             \n\t    StringTokenizer st = new StringTokenizer(f.readLine());\n\t    int n = Integer.parseInt(st.nextToken());\n\t    array = new int[n];\n\t    st = new StringTokenizer(f.readLine());\n\t    for(int i = 0; i < n ; i++){\n\t    \tarray[i] = Integer.parseInt(st.nextToken());\n\t    }\n\t    System.out.println(findLIS(array).length);\n\t}\n\tpublic static int search(int[] M, int[] A, int i, int L ) {\n        int j = 0;\n        int k = L-1;\n        while( j <= k ) {\n                int m = ( j + k ) / 2;\n                if( A[M[m]] <= A[i] ) j = m + 1;\n                else k = m - 1;\n        }\n       \n        return k;\n}\n \npublic static int[] findLIS(int[] A) {\n        int n = A.length;\n        int[] M = new int[n];\n        int[] P = new int[n];\n        M[0] = 0;\n        P[0] = -1;\n        int L = 1;\n       \n        for(int i=1; i<n; ++i) {\n                int j = search( M, A, i, L );\n                if( j == -1 ) P[i] = -1;\n                else P[i] = M[j];\n               \n                if( j == L-1 || A[i] < A[M[j+1]] ) {\n                        M[j+1] = i;\n                        if( j+2 > L ) L = j+2;\n                }\n        }\n       \n        int[] LIS = new int[L];\n        n = L-1;\n        int p = M[n];\n        while( n >= 0 ) {\n                LIS[n] = A[p];\n                p = P[p];\n                n--;\n        }\n       \n        return LIS;\n}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Solver{\n\n  BufferedReader in;\n  StringTokenizer str = null;\n  PrintWriter out;\n\n  private String next() throws Exception{\n    while(str == null || !str.hasMoreElements())\n      str = new StringTokenizer(in.readLine());\n    return str.nextToken();\n  }\n\n  private int nextInt() throws Exception{\n    return Integer.parseInt(next());\n  }\n\n  final static int oo = Integer.MAX_VALUE/2;\n\n  public void run() throws Exception{\n    in = new BufferedReader(new InputStreamReader(System.in)); \n    out = new PrintWriter(System.out);\n    \n    int n = nextInt();\n    int []a = new int[n];\n    for(int i=0;i<n;i++) a[i] = nextInt();\n\n    int []e = new int[n+1];\n    Arrays.fill(e, oo);\n    e[0] = -oo;\n\n    for(int i=0;i<n;i++){\n      int x = a[i];\n      int l = -1, r = n+2;\n      while(r - l > 1){\n        int m = l + (r - l)/2;\n        if (e[m] <= x){\n          l = m;\n        }else{\n          r = m;\n        }\n      }\n      e[r] = x;\n      //System.out.println(Arrays.toString(e));\n    }\n    \n    int ret = 1;\n    for(int i=1;i<=n;i++){\n      if(e[i] != oo){\n        ret = i;  \n      }\n    }\n    out.println(ret);\n    out.close();\n  }\n\n  public static void main(String args[]) throws Exception{\n    new Solver().run();  \n  }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/stack:64000000,64000000\")\nusing namespace std;\nint n;\nint a[100002];\nvoid start();\nint main() {\n  start();\n  return 0;\n}\nvoid start() {\n  for (int i = 1; i < 100002; ++i) {\n    a[i] = 1000000;\n  }\n  int max_ind = 1;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) {\n    int z;\n    scanf(\"%d\", &z);\n    int ind = lower_bound(a + 1, a + 100002, z) - a;\n    a[ind] = z;\n    max_ind = max(ind, max_ind);\n  }\n  printf(\"%d\", max_ind);\n  return;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100001], m[100002], p[100002];\nint main() {\n  int n, i, j, k, l = 0, lo, hi, mid, f;\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; ++i) scanf(\"%d\", a + i);\n  for (i = 0; i < n; ++i) {\n    lo = 1;\n    hi = l;\n    while (lo <= hi) {\n      mid = ceil((lo + hi) / 2);\n      if (a[m[mid]] < a[i])\n        lo = mid + 1;\n      else\n        hi = mid - 1;\n    }\n    f = lo;\n    p[i] = m[f - 1];\n    m[f] = i;\n    if (f > l) l = f;\n  }\n  printf(\"%d\", l);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    \n    \n    static InputReader in;\n    static PrintWriter out;\n        \n    public static void main(String[] args) throws IOException{\n        //InputStream ins = new FileInputStream(\"E:\\\\rush.txt\");\n        InputStream ins = System.in;\n        in = new InputReader(ins);\n        out = new PrintWriter(System.out);\n        //code start from here\n        new Task().solve(in, out);\n        out.close();\n    }\n    \n    static int N = (int)1e5;\n    static class Task{\n\n    \tint n;\n    \tint a[];\n    \tint mi[],R;\n        \n        public void solve(InputReader in,PrintWriter out) {\n        \tn = in.nextInt();\n        \ta = new int[N+10];\n        \tmi = new int[N+10];\n        \t\n        \tfor (int i = 1;i <= n;i++) a[i] = in.nextInt();\n        \tR = 0;\n        \tfor (int i = 1;i <= n;i++) {\n        \t\tint l = 1,r = R,temp = 0;\n        \t\twhile (l<=r) {\n        \t\t\tint mid = (l+r)>>1;\n        \t\t\tif (mi[mid]<=a[i]) {\n        \t\t\t\ttemp = mid;\n        \t\t\t\tl = mid + 1;\n        \t\t\t}else {\n        \t\t\t\tr = mid - 1;\n        \t\t\t}\n        \t\t}\n        \t\tif (mi[temp+1]==0) {\n        \t\t\tR = temp+1;\n        \t\t\tmi[temp+1] = a[i];\n        \t\t}else {\n        \t\t\tmi[temp+1] = Math.min(mi[temp+1], a[i]);\n        \t\t}\n        \t}\n        \tout.println(R);\n        }\n    }\n\n    \n\n    static class InputReader{\n        public BufferedReader br;\n        public StringTokenizer tokenizer;\n        \n        public InputReader(InputStream ins) {\n            br = new BufferedReader(new InputStreamReader(ins));\n            tokenizer = null;\n        }\n        \n        public String next(){\n            while (tokenizer==null || !tokenizer.hasMoreTokens()) {\n                try {\n                tokenizer = new StringTokenizer(br.readLine());\n                }catch(IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100005], f[100005], p[100005];\nint main() {\n  int n, pos = 0, ans = 0;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  for (int i = 1; i <= n; i++) {\n    f[i] = 1;\n    for (int j = pos; j > 0; j--) {\n      if (a[i] >= a[p[j]]) {\n        f[i] = f[p[j]] + 1;\n        break;\n      }\n    }\n    pos = max(pos, f[i]);\n    p[f[i]] = i;\n    ans = max(ans, f[i]);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def CeilIndex(A, l, r, key): \n  \n    while (r - l > 1): \n      \n        m = l + (r - l)//2\n        if (A[m] >= key): \n            r = m \n        else: \n            l = m \n    return r \n   \ndef LongestIncreasingSubsequenceLength(A, size): \n  \n    # Add boundary case, \n    # when array size is one \n   \n    tailTable = [0 for i in range(size + 1)] \n    len = 0 # always points empty slot \n   \n    tailTable[0] = A[0] \n    len = 1\n    for i in range(1, size): \n      \n        if (A[i] < tailTable[0]): \n  \n            # new smallest value \n            tailTable[0] = A[i] \n   \n        elif (A[i] > tailTable[len-1]): \n  \n            # A[i] wants to extend \n            # largest subsequence \n            tailTable[len] = A[i] \n            len+= 1\n   \n        else: \n            # A[i] wants to be current \n            # end candidate of an existing \n            # subsequence. It will replace \n            # ceil value in tailTable \n            tailTable[CeilIndex(tailTable, -1, len-1, A[i])] = A[i] \n          \n   \n    return len\nn=int(input())\nl=list(map(int,input().split()))\nprint(LongestIncreasingSubsequenceLength(l, n))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint f[120000], v, ans, x, i, n, j;\nint main() {\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; ++i) {\n    scanf(\"%d\", &x);\n    v = 0;\n    for (j = x; j; j -= j & (-j)) v = max(v, f[j]);\n    v++;\n    ans = max(ans, v);\n    for (j = x; j <= n; j += j & (-j)) f[j] = max(f[j], v);\n  }\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 1,
            "solution": "# DON'T USE PYTHON FOR RECURSION\n# TRY PYPY\nimport math\nimport operator\nimport sys\nimport threading\nfrom bisect import bisect_left, bisect\nfrom collections import Counter, defaultdict\nfrom math import ceil, floor, pi, sin, sqrt\nfrom sys import exit, stdin, stdout\n\n\ndef main():\n    # stdin = open('.in')\n    n = int(stdin.readline())\n    a = map(int, stdin.readline().strip().split(' '))\n    dp = []\n    for e in a:\n        if not dp or dp[-1] < e:\n            dp.append(e)\n        else:\n            dp[bisect(dp, e)] = e\n    print len(dp)\n\n\nif __name__ == '__main__':\n    sys.setrecursionlimit(10**6)\n    threading.stack_size(10240000)\n    thread = threading.Thread(target=main)\n    thread.start()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 1e5 + 5;\nint a[M];\nint32_t main() {\n  int n;\n  cin >> n;\n  memset(a, 31, sizeof a);\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    a[lower_bound(a, a + M, x) - a] = x;\n  }\n  return cout << int(lower_bound(a, a + M, M) - a) << endl, 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\n\n \npublic class Main {\n\n    int n;\n    int[] aa;\n    int[] bb;\n    int[] seg;\n    HashMap<Integer, Integer> pos = new HashMap<>();\n\n    public void update(int idx, int val){\n        idx += n;\n        seg[idx] = val;\n        idx /= 2;\n\n        while(idx > 1){\n            seg[idx] = Math.max(seg[idx * 2], seg[idx * 2 + 1]);\n            idx /= 2; \n        }\n    }\n\n    public int query(int l, int r){\n\n        l += n;\n        r += n;\n        int res = 0;\n\n        while(l < r){\n            if(l % 2 == 1){\n                res = Math.max(res, seg[l]);\n                l++;\n            }\n            if(r % 2 == 1){\n                r--;\n                res = Math.max(res, seg[r]);\n            }\n            l /= 2;\n            r /= 2;\n        }\n\n        return res;\n\n    }\n\n\n    public void solve() throws IOException{\n\n        n = in.nextInt();\n        aa = new int[n];\n        bb = new int[n];\n        seg = new int[2 * n];\n        for(int i = 0; i < n; i++){\n            aa[i] = in.nextInt();\n            bb[i] = aa[i];\n        }\n\n        Arrays.sort(aa);\n        for(int i = 0; i < n; i++){\n            pos.put(aa[i], i);\n        }\n\n        int res = 0;\n        for(int i = 0; i < n; i++){\n\n            int num = bb[i];\n            int max = query(0, pos.get(num));\n            res = Math.max(res, max + 1);\n            update(pos.get(num), max + 1);\n\n        }\n\n\n        out.println(res);\n\n        return;\n    }\n\n\n\n\n\n    public BigInteger gcdBigInt(BigInteger a, BigInteger b){\n\n        if(a.compareTo(BigInteger.valueOf(0L)) == 0){\n            return b;\n        }else{\n            return gcdBigInt(b.mod(a), a);\n        }\n\n    }\n\n \n    FastScanner in;\n    PrintWriter out;\n \n    static class FastScanner {\n \n        BufferedReader br;\n        StringTokenizer st;\n \n        FastScanner(InputStream in) {\n            br = new BufferedReader(new InputStreamReader(in));\n            st = null;\n        }\n \n        String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n \n        String nextLine() throws IOException {\n            if (st == null || !st.hasMoreTokens())\n                return br.readLine();\n            StringBuilder result = new StringBuilder(st.nextToken());\n            while (st.hasMoreTokens()) {\n                result.append(\" \");\n                result.append(st.nextToken());\n            }\n            return result.toString();\n        }\n \n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n \n        long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n \n        double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n \n    }\n \n    void run() throws IOException {\n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out, false);\n        solve();\n        out.close();\n    }\n \n    public static void main(String[] args) throws IOException{\n        new Main().run();\n    }\n \n    public void printArr(int[] arr){\n        for(int i = 0; i < arr.length; i++){\n            out.print(arr[i] + \" \");\n        }\n        out.println();\n    }\n \n    public long gcd(long a, long b){\n        if(a == 0) return b;\n        return gcd(b % a, a);\n    }\n\n    public boolean isPrime(long num){\n\n        if(num == 0 || num == 1){\n            return false;\n        }\n\n        for(int i = 2; i * i <= num; i++){\n            if(num % i == 0){\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public class Pair<A, B>{\n        public A x; \n        public B y;\n\n        Pair(A x, B y){\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Pair<?, ?> pair = (Pair<?, ?>) o;\n            if (!x.equals(pair.x)) return false;\n            return y.equals(pair.y);\n        }\n\n        @Override\n        public int hashCode() {\n            int result = x.hashCode();\n            result = 31 * result + y.hashCode();\n            return result;\n        }\n\n    }\n\n    class Tuple{\n        int x; int y; int z;\n        Tuple(int ix, int iy, int iz){\n            x = ix;\n            y = iy;\n            z = iz;\n        }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\npublic class sortgraph \n{\n    static int CeilIndex(int A[], int l, int r, int key)\n    {\n        while (r - l > 1)\n        {\n            int m = l + (r - l)/2;\n            if (A[m]>=key)\n                r = m;\n            else\n                l = m;\n        }\n \n        return r;\n    }\n \n    static int subs(int A[], int size)\n    {\n        // Add boundary case, when array size is one\n \n        int[] tailTable   = new int[size];\n        int len; // always points empty slot\n \n        tailTable[0] = A[0];\n        len = 1;\n        for (int i = 1; i < size; i++)\n        {\n            if (A[i] < tailTable[0])\n                // new smallest value\n                tailTable[0] = A[i];\n \n            else if (A[i] > tailTable[len-1])\n                // A[i] wants to extend largest subsequence\n                tailTable[len++] = A[i];\n \n            else\n                // A[i] wants to be current end candidate of an existing\n                // subsequence. It will replace ceil value in tailTable\n                tailTable[CeilIndex(tailTable, -1, len-1, A[i])] = A[i];\n        }\n \n        return len;\n    }\n    public static void main(String args[])throws IOException\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        int n=Integer.parseInt(br.readLine());\n        String s[]=br.readLine().trim().split(\" \");\n        int arr[]=new int[n];\n        Map<Integer,ArrayList<Integer>> adj=new HashMap<>();\n        for(int i=0;i<n;i++)\n        {\n            arr[i]=Integer.parseInt(s[i]);\n            adj.put(i,new ArrayList<>());\n        }/*\n        boolean swap=false;\n        do\n        {\n            swap=false;\n            for(int i=0;i<n-1;i++)\n            {\n                if(arr[i]>arr[i+1])\n                {\n                    adj.get(arr[i]).add(arr[i+1]);\n                    adj.get(arr[i+1]).add(arr[i]);\n                    int t=arr[i];\n                    arr[i]=arr[i+1];\n                    arr[i+1]=t;\n                    swap=true;\n                }\n            }\n        }while(swap==true);\n        for(int i=1;i<=n;i++)\n        {\n            Collections.sort(adj.get(i));\n        }*/\n       int res=subs(arr,n);\n       System.out.println(res);\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint a[101000];\nint ans;\nint b[101000];\nint f[101000];\nvoid update(int x, int y) {\n  for (int i = x; i <= n; i += i & -i) b[i] = max(b[i], y);\n}\nint query(int x) {\n  int res = 0;\n  for (int i = x; i; i -= i & -i) res = max(res, b[i]);\n  return res;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  for (int i = 1; i <= n; i++) {\n    f[i] = query(a[i]) + 1;\n    update(a[i], f[i]);\n    ans = max(ans, f[i]);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[111111], b[111111], len;\nint main() {\n  int n, i;\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n  len = 1;\n  b[0] = a[0];\n  int tmp;\n  for (i = 1; i < n; i++) {\n    if (a[i] > b[len - 1])\n      b[len++] = a[i];\n    else {\n      tmp = lower_bound(b, b + len, a[i]) - b;\n      b[tmp] = a[i];\n    }\n  }\n  printf(\"%d\\n\", len);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nint n, base, f[N];\nint main() {\n  scanf(\"%d\", &n);\n  for (base = 1; base < n; base <<= 1)\n    ;\n  for (int i = 1; i <= n; i++) f[i] = n + 1;\n  for (int i = 1; i <= n; i++) {\n    int a;\n    scanf(\"%d\", &a);\n    int j = lower_bound(f, f + n + 1, a) - f;\n    if (a < f[j]) f[j] = a;\n  }\n  int ans = n;\n  while (f[ans] == n + 1) ans--;\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Niyaz Nigmatullin\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tFastPrinter out = new FastPrinter(outputStream);\n\t\tTaskB solver = new TaskB();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskB {\n    public void solve(int testNumber, FastScanner in, FastPrinter out) {\n        int n = in.nextInt();\n        int[] a = in.readIntArray(n);\n        int[] dp = new int[n + 1];\n        Arrays.fill(dp, Integer.MIN_VALUE);\n        int cur = 0;\n        for (int i : a) {\n            int l = 0;\n            int r = cur + 1;\n            while (l < r - 1) {\n                int mid = l + r >> 1;\n                if (i < dp[mid]) {\n                    r = mid;\n                } else {\n                    l = mid;\n                }\n            }\n            dp[l + 1] = i;\n            if (l == cur) {\n                ++cur;\n            }\n        }\n        out.println(cur);\n    }\n}\n\nclass FastScanner extends BufferedReader {\n\n    public FastScanner(InputStream is) {\n        super(new InputStreamReader(is));\n    }\n\n    public int read() {\n        try {\n            int ret = super.read();\n//            if (isEOF && ret < 0) {\n//                throw new InputMismatchException();\n//            }\n//            isEOF = ret == -1;\n            return ret;\n        } catch (IOException e) {\n            throw new InputMismatchException();\n        }\n    }\n\n    static boolean isWhiteSpace(int c) {\n        return c >= 0 && c <= 32;\n    }\n\n    public int nextInt() {\n        int c = read();\n        while (isWhiteSpace(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int ret = 0;\n        while (c >= 0 && !isWhiteSpace(c)) {\n            if (c < '0' || c > '9') {\n                throw new NumberFormatException(\"digit expected \" + (char) c\n                        + \" found\");\n            }\n            ret = ret * 10 + c - '0';\n            c = read();\n        }\n        return ret * sgn;\n    }\n\n    public String readLine() {\n        try {\n            return super.readLine();\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    public int[] readIntArray(int n) {\n        int[] ret = new int[n];\n        for (int i = 0; i < n; i++) {\n            ret[i] = nextInt();\n        }\n        return ret;\n    }\n\n    }\n\nclass FastPrinter extends PrintWriter {\n\n    public FastPrinter(OutputStream out) {\n        super(out);\n    }\n\n    public FastPrinter(Writer out) {\n        super(out);\n    }\n\n\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint in[100005];\nint dp[100005];\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  fill(dp, dp + 100005, 1000000000);\n  dp[0] = 0;\n  int ret = 0;\n  for (int i = 0; i < n; i++) {\n    int a;\n    scanf(\"%d\", &a);\n    int s = 0, e = 100005;\n    while (e - s > 1) {\n      int med = (s + e) / 2;\n      if (dp[med] < a)\n        s = med;\n      else\n        e = med;\n    }\n    dp[s + 1] = a;\n    ret = max(ret, s + 1);\n  }\n  printf(\"%d\\n\", ret);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:256000000\")\nusing namespace std;\nconst double PI = acos(-1.0);\nconst int INF = 1000000000;\nconst int MOD = 1000000007;\nint main() {\n  int _start = clock();\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n  }\n  vector<int> d(n + 10, +INF);\n  d[0] = -INF;\n  for (int i = 0; i < n; ++i) {\n    int j = upper_bound(d.begin(), d.end(), a[i]) - d.begin();\n    if (d[j - 1] < a[i] && a[i] < d[j]) {\n      d[j] = a[i];\n    }\n  }\n  int r = 0;\n  for (int i = 0; i < d.size(); ++i) {\n    if (d[i] != INF) {\n      r = i;\n    }\n  }\n  cout << r << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastReader in = new FastReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\n\t\tint n = in.nextInt();\n\t\tint[] a = in.nextIntArray(n);\n\n\t\tout.println(lis(a).length);\n\t\t\n\t\tout.close();\n\t}\n\tpublic static int[] lis(int[] a) {\n\t\tint n = a.length;\n\t\tint[] tail = new int[n];\n\t\tint[] prev = new int[n];\n\n\t\tint len = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint pos = lower_bound(a, tail, len, a[i]);\n\t\t\tlen = Math.max(len, pos + 1);\n\t\t\tprev[i] = pos > 0 ? tail[pos - 1] : -1;\n\t\t\ttail[pos] = i;\n\t\t}\n\n\t\tint[] res = new int[len];\n\t\tfor (int i = tail[len - 1]; i >= 0; i = prev[i]) {\n\t\t\tres[--len] = a[i];\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic int lower_bound(int[] a, int[] tail, int len, int key) {\n\t\tint lo = -1;\n\t\tint hi = len;\n\t\twhile (hi - lo > 1) {\n\t\t\tint mid = (lo + hi) >>> 1;\n\t\t\tif (a[tail[mid]] < key) {\n\t\t\t\tlo = mid;\n\t\t\t} else {\n\t\t\t\thi = mid;\n\t\t\t}\n\t\t}\n\t\treturn hi;\n\t}\n\tstatic class FastReader {\n\t    private InputStream stream;\n\t    private final byte[] buf = new byte[8192];\n\t    private int curChar;\n\t    private int pnumChars;\n\n\t    public FastReader(InputStream stream) {\n\t        this.stream = stream;\n\t    }\n\n\t    private int pread() {\n\t        if (pnumChars == -1) {\n\t            throw new InputMismatchException();\n\t        }\n\t        if (curChar >= pnumChars) {\n\t            curChar = 0;\n\t            try {\n\t                pnumChars = stream.read(buf);\n\t            } catch (IOException e) {\n\t                throw new InputMismatchException();\n\t            }\n\t            if (pnumChars <= 0) {\n\t                return -1;\n\t            }\n\t        }\n\t        return buf[curChar++];\n\t    }\n\n\t    private int peek() {\n\t        if (pnumChars == -1) {\n\t            return -1;\n\t        }\n\t        if (curChar >= pnumChars) {\n\t            curChar = 0;\n\t            try {\n\t                pnumChars = stream.read(buf);\n\t            } catch (IOException e) {\n\t                return -1;\n\t            }\n\t            if (pnumChars <= 0) {\n\t                return -1;\n\t            }\n\t        }\n\t        return buf[curChar];\n\t    }\n\n\t    public int nextInt() {\n\t        int c = pread();\n\t        while (isSpaceChar(c))\n\t            c = pread();\n\t        int sgn = 1;\n\t        if (c == '-') {\n\t            sgn = -1;\n\t            c = pread();\n\t        }\n\t        int res = 0;\n\t        do {\n\t            if (c == ',') {\n\t                c = pread();\n\t            }\n\t            if (c < '0' || c > '9') {\n\t                throw new InputMismatchException();\n\t            }\n\t            res *= 10;\n\t            res += c - '0';\n\t            c = pread();\n\t        } while (!isSpaceChar(c));\n\t        return res * sgn;\n\t    }\n\n\t    public int[] nextIntArray(int n) {\n\t        int[] array = new int[n];\n\t        for (int i = 0; i < n; i++) {\n\t            array[i] = nextInt();\n\t        }\n\t        return array;\n\t    }\n\n\t    public long nextLong() {\n\t        int c = pread();\n\t        while (isSpaceChar(c))\n\t            c = pread();\n\t        int sgn = 1;\n\t        if (c == '-') {\n\t            sgn = -1;\n\t            c = pread();\n\t        }\n\t        long res = 0;\n\t        do {\n\t            if (c < '0' || c > '9') {\n\t                throw new InputMismatchException();\n\t            }\n\t            res *= 10;\n\t            res += c - '0';\n\t            c = pread();\n\t        } while (!isSpaceChar(c));\n\t        return res * sgn;\n\t    }\n\n\t    public long[] nextLongArray(int n) {\n\t        long[] array = new long[n];\n\t        for (int i = 0; i < n; i++) {\n\t            array[i] = nextLong();\n\t        }\n\t        return array;\n\t    }\n\n\t    public String nextString() {\n\t        int c = pread();\n\t        while (isSpaceChar(c))\n\t            c = pread();\n\t        StringBuilder res = new StringBuilder();\n\t        do {\n\t            res.appendCodePoint(c);\n\t            c = pread();\n\t        } while (!isSpaceChar(c));\n\t        return res.toString();\n\t    }\n\n\t    private boolean isSpaceChar(int c) {\n\t        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t    }\n\n\t    private boolean isEndOfLine(int c) {\n\t        return c == '\\n' || c == '\\r' || c == -1;\n\t    }\n\n\t    public String nextLine() {\n\t        int c = pread();\n\t        while (isSpaceChar(c))\n\t            c = pread();\n\t        StringBuilder res = new StringBuilder();\n\t        do {\n\t            res.appendCodePoint(c);\n\t            c = pread();\n\t        } while (!isEndOfLine(c));\n\t        return res.toString();\n\t    }\n\n\t    public BigInteger nextBigInteger() {\n\t        try {\n\t            return new BigInteger(nextString());\n\t        } catch (NumberFormatException e) {\n\t            throw new InputMismatchException();\n\t        }\n\t    }\n\n\t    public char nextCharacter() {\n\t        int c = pread();\n\t        while (isSpaceChar(c))\n\t            c = pread();\n\t        return (char) c;\n\t    }\n\n\t    public char[] nextCharacterArray(int n) {\n\t        char[] chars = new char[n];\n\t        for (int i = 0; i < n; i++) {\n\t            chars[i] = nextCharacter();\n\t        }\n\t        return chars;\n\t    }\n\n\t    public char[][] nextCharacterMap(int n, int m) {\n\t        char[][] map = new char[n][];\n\t        for (int i = 0; i < n; i++) {\n\t            map[i] = nextCharacterArray(m);\n\t        }\n\t        return map;\n\t    }\n\n\t    public double nextDouble() {\n\t        int c = pread();\n\t        while (isSpaceChar(c))\n\t            c = pread();\n\t        int sgn = 1;\n\t        if (c == '-') {\n\t            sgn = -1;\n\t            c = pread();\n\t        }\n\t        double res = 0;\n\t        while (!isSpaceChar(c) && c != '.') {\n\t            if (c == 'e' || c == 'E') {\n\t                return res * Math.pow(10, nextInt());\n\t            }\n\t            if (c < '0' || c > '9') {\n\t                throw new InputMismatchException();\n\t            }\n\t            res *= 10;\n\t            res += c - '0';\n\t            c = pread();\n\t        }\n\t        if (c == '.') {\n\t            c = pread();\n\t            double m = 1;\n\t            while (!isSpaceChar(c)) {\n\t                if (c == 'e' || c == 'E') {\n\t                    return res * Math.pow(10, nextInt());\n\t                }\n\t                if (c < '0' || c > '9') {\n\t                    throw new InputMismatchException();\n\t                }\n\t                m /= 10;\n\t                res += (c - '0') * m;\n\t                c = pread();\n\t            }\n\t        }\n\t        return res * sgn;\n\t    }\n\n\t    public boolean isExhausted() {\n\t        int value;\n\t        while (isSpaceChar(value = peek()) && value != -1)\n\t            pread();\n\t        return value == -1;\n\t    }\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n\n        int N = in.readInt();\n        int A[] = new int[N];\n        for (int I = 0; I < N; I++) {\n            A[I] = in.readInt();\n        }\n        int size = 1;\n        int C[] = new int[N + 1];\n        int dp[] = new int[N + 1];\n        C[1] = A[0];\n        dp[0] = 1;\n        for (int I = 1; I < N; I++) {\n            if (A[I] < C[1]) {\n                C[1] = A[I];\n                dp[I] = 1;\n            } else if (A[I] > C[size]) {\n                C[size + 1] = A[I];\n                dp[I] = size + 1;\n                size++;\n            } else {\n                int k = Arrays.binarySearch(C, 0, size + 1, A[I]);\n                if (k > 0) {\n                } else {\n                    k = -(k) - 1;\n                }\n                C[k] = A[I];\n                dp[I] = k;\n            }\n        }\n        out.printLine(size);\n        out.close();\n    }\n}\n\nclass InputReader {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public int read() {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int readInt() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public long readLong() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public String readString() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        StringBuffer res = new StringBuffer();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n        return res.toString();\n    }\n\n    public static boolean isSpaceChar(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public String next() {\n        return readString();\n    }\n}\n\nclass OutputWriter {\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n        writer = new PrintWriter(outputStream);\n    }\n\n    public OutputWriter(Writer writer) {\n        this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n        for (int i = 0; i < objects.length; i++) {\n            if (i != 0)\n                writer.print(' ');\n            writer.print(objects[i]);\n        }\n    }\n\n    public void printLine(Object... objects) {\n        print(objects);\n        writer.println();\n    }\n\n    public void close() {\n        writer.close();\n    }\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int NMAX = 100002;\nint N;\nvector<int> ans, a;\nvector<int> getLis(const vector<int> &a) {\n  vector<int> b;\n  vector<int> p(a.size());\n  if (a.empty()) return b;\n  b.push_back(0);\n  int u, v, mid;\n  for (size_t i = 1; i < a.size(); ++i) {\n    if (a[i] > a[b.back()]) {\n      p[i] = b.back();\n      b.push_back(i);\n      continue;\n    }\n    for (u = 0, v = b.size() - 1; u < v;) {\n      mid = u + ((v - u) >> 1);\n      if (a[b[mid]] < a[i])\n        u = mid + 1;\n      else\n        v = mid;\n    }\n    if (a[i] < a[b[u]]) {\n      b[u] = i;\n      if (u > 0) p[i] = b[u - 1];\n    }\n  }\n  for (u = b.size(), v = b.back(); u--; v = p[v]) b[u] = a[v];\n  return b;\n}\nint main() {\n  cin >> N;\n  a.resize(N);\n  for (int i = 0; i < N; i++) {\n    cin >> a[i];\n  }\n  ans = getLis(a);\n  cout << ans.size();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, i, a[100101], ans[100101], out;\nint T[400001];\nint query(int v, int tl, int tr, int l, int r) {\n  if (l > r) return 0;\n  if (tl == l && tr == r) {\n    return T[v];\n  };\n  int tm = (tl + tr) / 2;\n  return max(query(2 * v, tl, tm, l, min(tm, r)),\n             query(2 * v + 1, tm + 1, tr, max(tm + 1, l), r));\n};\nvoid update(int v, int tl, int tr, int pos, int val) {\n  if (tl == tr) {\n    T[v] = val;\n    return;\n  };\n  int tm = (tl + tr) / 2;\n  if (tm >= pos)\n    update(2 * v, tl, tm, pos, val);\n  else\n    update(2 * v + 1, tm + 1, tr, pos, val);\n  T[v] = max(T[2 * v], T[2 * v + 1]);\n};\nint main() {\n  cin >> n;\n  for (i = 1; i <= n; i++) cin >> a[i];\n  for (i = 1; i <= n; i++) {\n    ans[a[i]] = query(1, 1, n, 1, a[i] - 1) + 1;\n    update(1, 1, n, a[i], ans[a[i]]);\n    out = max(out, ans[a[i]]);\n  };\n  cout << out;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mxn = 2e5;\nint n;\nvector<int> v;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    int a;\n    cin >> a;\n    auto it = lower_bound(v.begin(), v.end(), a);\n    if (it != v.end())\n      *it = a;\n    else\n      v.push_back(a);\n  }\n  cout << v.size();\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\n\npublic class Main {\n\n    static ArrayList<Integer> list;\n    static int[] a;\n    static int n;\n\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        n = sc.nextInt();\n        a = sc.nextIntArray(n);\n        list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            int idx = BS(a[i]);\n            if (idx == list.size()) list.add(a[i]);\n            else\n                list.set(idx, a[i]);\n        }\n        out.println(list.size());\n        out.flush();\n        out.close();\n    }\n\n    static int BS(int val) {\n        int lo = 0;\n        int hi = list.size() - 1;\n        int ans = hi + 1;\n        while (lo <= hi) {\n            int mid = (lo + hi) >> 1;\n            if (list.get(mid) > val) {\n                hi = mid - 1;\n                ans = mid;\n            } else lo = mid + 1;\n        }\n        return ans;\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream system) {\n            br = new BufferedReader(new InputStreamReader(system));\n        }\n\n        public Scanner(String file) throws Exception {\n            br = new BufferedReader(new FileReader(file));\n        }\n\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public char nextChar() throws IOException {\n            return next().charAt(0);\n        }\n\n        public Long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n\n\n        public int[] nextIntArray(int n) throws IOException {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        public long[] nextLongArray(int n) throws IOException {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n\n\n        public Integer[] nextIntegerArray(int n) throws IOException {\n            Integer[] a = new Integer[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        public double[] nextDoubleArray(int n) throws IOException {\n            double[] ans = new double[n];\n            for (int i = 0; i < n; i++)\n                ans[i] = nextDouble();\n            return ans;\n        }\n\n        public short nextShort() throws IOException {\n            return Short.parseShort(next());\n        }\n\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Safronov Alexey (safronov.aa@gmail.com)\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskB solver = new TaskB();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskB {\n    public void solve(int testNumber, FastScanner in, PrintWriter out) {\n        int count = in.nextInt();\n        int[] bounds = new int[count + 1];\n        Arrays.fill(bounds, Integer.MAX_VALUE);\n        bounds[0] = 0;\n        for (int i = 0; i < count; i++) {\n            int value = in.nextInt();\n            int index = lowerBound(bounds, value);\n            if (bounds[index] < value)\n                ++index;\n            bounds[index] = Math.min(bounds[index], value);\n        }\n        int result = 0;\n        while (result <= count && bounds[result] != Integer.MAX_VALUE)\n            ++result;\n        out.println(result - 1);\n    }\n\n    private int lowerBound(int[] arr, int value) {\n        int l = -1, r = arr.length;\n        while (r - l > 1) {\n            int m = (l + r) / 2;\n            if (arr[m] <= value) {\n                l = m;\n            } else {\n                r = m;\n            }\n        }\n        return l;\n    }\n}\n\nclass FastScanner extends BufferedReader {\n    private StringTokenizer stringTokenizer;\n\n    public FastScanner(InputStream stream) {\n        super(new InputStreamReader(stream));\n    }\n\n    public String next() {\n        while (stringTokenizer == null || !stringTokenizer.hasMoreTokens()) {\n            String line;\n            try {\n\n                line = readLine();\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (line == null)\n                return null;\n            stringTokenizer = new StringTokenizer(line);\n        }\n        return stringTokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    }\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> LIS(vector<int> A) {\n  int N = A.size(), i, j = -1, t;\n  vector<int> pre(N, -1), res;\n  map<int, int> m;\n  map<int, int>::iterator k, l;\n  for (i = 0; i < N; i++) {\n    if (m.insert(pair<int, int>(A[i], i)).second) {\n      k = m.find(A[i]);\n      l = k;\n      k++;\n      if (l == m.begin())\n        pre[i] = -1;\n      else {\n        l--;\n        pre[i] = l->second;\n      }\n      if (k != m.end()) m.erase(k);\n    }\n  }\n  k = m.end();\n  k--;\n  j = k->second;\n  while (j != -1) {\n    res.push_back(A[j]);\n    j = pre[j];\n  }\n  reverse(res.begin(), res.end());\n  return res;\n}\nint n, aux;\nvector<int> a;\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &aux);\n    a.push_back(aux);\n  }\n  printf(\"%d\\n\", (LIS(a)).size());\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.File;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class p046 {\n\tpublic static void main(String args[]) throws Exception {\n// \t\tStringTokenizer stok = new StringTokenizer(new Scanner(new File(\"C:/Users/Arunkumar/Downloads/input.txt\")).useDelimiter(\"\\\\A\").next());\n\t\tStringTokenizer stok = new StringTokenizer(new Scanner(System.in).useDelimiter(\"\\\\A\").next());\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint n = Integer.parseInt(stok.nextToken());\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = Integer.parseInt(stok.nextToken());\n\t\t}\n\t\tSystem.out.println(getLongestIncreasingSubsequence(a).size());\n\t}\n\t\n\tprivate static ArrayList<Integer> getLongestIncreasingSubsequence(int[] a) {\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tfor(int i=0;i<a.length;i++) {\n\t\t\tint pos = Collections.binarySearch(list, a[i]);\n\t\t\tif(pos<0) {\n\t\t\t\tpos=-pos-1;\n\t\t\t\tif(pos==list.size()) list.add(a[i]);\n\t\t\t\telse list.set(pos, a[i]);\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double pi = acos(-1.0);\nconst double eps = 1e-8;\nconst int dx[8] = {1, 0, -1, 0, -1, -1, 1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, -1, 1, -1};\nconst int days[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\nconst int leap[13] = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\nint a[111111], n;\nvector<int>::iterator it;\nint lis() {\n  vector<int> v;\n  v.push_back(-1);\n  for (int i = 0; i < n; ++i)\n    if (a[i] >= v[v.size() - 1])\n      v.push_back(a[i]);\n    else {\n      it = upper_bound(v.begin(), v.end(), a[i]);\n      *it = a[i];\n    }\n  return v.size() - 1;\n}\nint main() {\n  while (scanf(\"%d\", &n) == 1) {\n    for (int i = 0; i < n; ++i) scanf(\"%d\", &a[i]);\n    cout << lis() << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.awt.*;\nimport java.awt.event.*;\nimport java.awt.geom.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*; \nimport java.util.*;\n\n/*\nbr = new BufferedReader(new FileReader(\"input.txt\"));\npw = new PrintWriter(new BufferedWriter(new FileWriter(\"output.txt\")));\nbr = new BufferedReader(new InputStreamReader(System.in));\npw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n */\n\npublic class Main {\n  private static BufferedReader br;\n  private static StringTokenizer st;\n  private static PrintWriter pw;\n\n  public static void main(String[] args) throws IOException {\n    br = new BufferedReader(new InputStreamReader(System.in));\n    pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n    //int qq = 1;\n    int qq = Integer.MAX_VALUE;\n    //int qq = readInt();\n    for(int casenum = 1; casenum <= qq; casenum++)  {\n      int n = readInt();\n      SegmentTree tree = new SegmentTree(new int[n]);\n      for(int i = 0; i < n; i++) {\n        int curr = readInt()-1;\n        tree.update(curr, 1 + tree.query(0, curr));\n      }\n      pw.println(tree.query(0, n-1));\n    }\n    pw.close();\n  }\n\n  static class SegmentTree {\n    public int[] leaf;\n    public int origSize;\n    public SegmentTree(int[] list)  {\n      origSize = list.length;\n      leaf = new int[4*list.length];\n      build(1,0,list.length-1,list);\n    }\n    public void build(int curr, int begin, int end, int[] list) {\n      if(begin == end)  {\n        leaf[curr] = list[begin];\n      }\n      else  {\n        int mid = (begin+end)/2;\n        build(2 * curr, begin, mid, list);\n        build(2 * curr + 1, mid+1, end, list);\n        leaf[curr] = Math.max(leaf[2*curr], leaf[2*curr+1]);\n      }\n    }\n    public void update(int index, int val)  {\n      update(1,0,origSize-1,index,val);\n    }\n    public void update(int curr, int begin, int end, int index, int val)  {\n      if(begin == end)  {\n        leaf[curr] = val;\n      }\n      else  {\n        int mid = (begin+end)/2;\n        if(index <= mid)\n          update(2 * curr, begin, mid, index, val);\n        else\n          update(2 * curr + 1, mid+1, end, index, val);\n        leaf[curr] = Math.max(leaf[2*curr], leaf[2*curr+1]);\n      }\n    }\n    public int query(int begin, int end)  {\n      return query(1,0,origSize-1,begin,end);\n    }\n    public int query(int curr, int tBegin, int tEnd, int begin, int end)  {\n      if(tBegin >= begin && tEnd <= end)  {\n        return leaf[curr];\n      }\n      else  {\n        int mid = (tBegin+tEnd)/2;\n        int ret = 0;\n        if(mid >= begin && tBegin <= end)\n          ret = Math.max(ret, query(2*curr, tBegin, mid, begin, end));\n        if(tEnd >= begin && mid+1 <= end)\n          ret = Math.max(ret, query(2*curr+1, mid+1, tEnd, begin, end));\n        return ret;\n      }\n    }\n  }\n\n  \n  private static void exitImmediately() {\n    pw.close();\n    System.exit(0);\n  }\n\n  private static long readLong() throws IOException {\n    return Long.parseLong(nextToken());\n  }\n\n  private static double readDouble() throws IOException {\n    return Double.parseDouble(nextToken());\n  }\n\n  private static int readInt() throws IOException {\n    return Integer.parseInt(nextToken());\n  }\n\n  private static String nextToken() throws IOException  {\n    while(st == null || !st.hasMoreTokens())  {\n      if(!br.ready()) {\n        exitImmediately();\n      }\n      st = new StringTokenizer(br.readLine().trim());\n    }\n    return st.nextToken();\n  }\n}\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Thread(null, new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tlong prevTime = System.currentTimeMillis();\n\t\t\t\t\tnew Main().run();\n\t\t\t\t\tSystem.err.println(\"Total time: \"\n\t\t\t\t\t\t\t+ (System.currentTimeMillis() - prevTime) + \" ms\");\n\t\t\t\t\tSystem.err.println(\"Memory status: \" + memoryStatus());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}, \"1\", 1L << 24).start();\n\t}\n\n\tvoid run() throws IOException {\n\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tObject o = solve();\n\t\tif (o != null)\n\t\t\tout.println(o);\n\t\tout.close();\n\t\tin.close();\n\t}\n\n\tprivate Object solve() throws IOException {\n\t\tint n = ni();\n\t\tint[] arr = nia(n);\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\tfor(int a : arr){\n\t\t\tint index = -Collections.binarySearch(list, a)-1;\n\t\t\tif(index>=list.size()){\t\t\t\t\n\t\t\t\tlist.add(a);\n\t\t\t}else{\n\t\t\t\tlist.set(index, a);\n\t\t\t}\n\t\t}\n\t\treturn list.size();\n\t}\n\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer st = new StringTokenizer(\"\");\n\n\tString nextToken() throws IOException {\n\t\twhile (!st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tint ni() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nl() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nd() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tint[] nia(int size) throws IOException {\n\t\tint[] ret = new int[size];\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tret[i] = ni();\n\t\treturn ret;\n\t}\n\n\tlong[] nla(int size) throws IOException {\n\t\tlong[] ret = new long[size];\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tret[i] = nl();\n\t\treturn ret;\n\t}\n\n\tdouble[] nda(int size) throws IOException {\n\t\tdouble[] ret = new double[size];\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tret[i] = nd();\n\t\treturn ret;\n\t}\n\n\tString nextLine() throws IOException {\n\t\tst = new StringTokenizer(\"\");\n\t\treturn in.readLine();\n\t}\n\n\tboolean EOF() throws IOException {\n\t\twhile (!st.hasMoreTokens()) {\n\t\t\tString s = in.readLine();\n\t\t\tif (s == null)\n\t\t\t\treturn true;\n\t\t\tst = new StringTokenizer(s);\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid printRepeat(String s, int count) {\n\t\tfor (int i = 0; i < count; i++)\n\t\t\tout.print(s);\n\t}\n\n\tvoid printArray(int[] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tif (i > 0)\n\t\t\t\tout.print(' ');\n\t\t\tout.print(array[i]);\n\t\t}\n\t\tout.println();\n\t}\n\n\tvoid printArray(long[] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tif (i > 0)\n\t\t\t\tout.print(' ');\n\t\t\tout.print(array[i]);\n\t\t}\n\t\tout.println();\n\t}\n\n\tvoid printArray(double[] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tif (i > 0)\n\t\t\t\tout.print(' ');\n\t\t\tout.print(array[i]);\n\t\t}\n\t\tout.println();\n\t}\n\n\tvoid printArray(double[] array, String spec) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tif (i > 0)\n\t\t\t\tout.print(' ');\n\t\t\tout.printf(Locale.US, spec, array[i]);\n\t\t}\n\t\tout.println();\n\t}\n\n\tvoid printArray(Object[] array) {\n\t\tboolean blank = false;\n\t\tfor (Object x : array) {\n\t\t\tif (blank)\n\t\t\t\tout.print(' ');\n\t\t\telse\n\t\t\t\tblank = true;\n\t\t\tout.print(x);\n\t\t}\n\t\tout.println();\n\t}\n\n\t@SuppressWarnings(\"rawtypes\")\n\tvoid printCollection(Collection collection) {\n\t\tboolean blank = false;\n\t\tfor (Object x : collection) {\n\t\t\tif (blank)\n\t\t\t\tout.print(' ');\n\t\t\telse\n\t\t\t\tblank = true;\n\t\t\tout.print(x);\n\t\t}\n\t\tout.println();\n\t}\n\n\tstatic String memoryStatus() {\n\t\treturn (Runtime.getRuntime().totalMemory()\n\t\t\t\t- Runtime.getRuntime().freeMemory() >> 20)\n\t\t\t\t+ \"/\" + (Runtime.getRuntime().totalMemory() >> 20) + \" MB\";\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100010];\nmultiset<int> s;\nmultiset<int>::iterator sit;\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  s.insert(a[1]);\n  for (int i = 2; i <= n; i++) {\n    sit = s.upper_bound(a[i]);\n    if (sit != s.end()) {\n      s.erase(sit);\n    }\n    s.insert(a[i]);\n  }\n  printf(\"%d\\n\", s.size());\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long inf = 1LL << 62;\nstatic long parseans(long j, long l) {\n  string k = \"\";\n  long ps = 0;\n  for (long long i = (long long)j; i <= l; ++i) {\n    ps *= 10;\n    ps += k[i] - '0';\n  }\n  return ps;\n}\nint cur = 1;\nint cnt = 0;\nstatic long gcd(long a, long b) {\n  if (b == 0) {\n    return a;\n  } else {\n    return gcd(b, a % b);\n  }\n}\nstatic bool pri(long long k) {\n  if (k == 1LL) return false;\n  for (long long i = 2; i * i <= k; i++) {\n    if (k % i == 0) return false;\n  }\n  return true;\n}\nint n, k;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n;\n  int a[1000005];\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  vector<int> dp(n);\n  dp[0] = -1000005;\n  for (int i = 1; i <= n; i++) {\n    dp[i] = 1000005;\n  }\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    int j = int(upper_bound(dp.begin(), dp.end(), a[i]) - dp.begin());\n    if (dp[j - 1] < a[i] && a[i] < dp[j]) {\n      dp[j] = a[i];\n    }\n  }\n  for (int i = 0; i <= n; i++) {\n    if (abs(dp[i]) != 1000005) ans++;\n  }\n  cout << ans << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100001];\nint dp[100001];\nint main() {\n  long long int n;\n  cin >> n;\n  for (long long int i = 0; i < ((long long int)(n)); i++) {\n    cin >> a[i];\n  }\n  for (long long int i = 0; i < ((long long int)(n)); i++) dp[i] = 1e+9;\n  for (long long int i = 0; i < ((long long int)(n)); i++)\n    *upper_bound(dp, dp + n, a[i]) = a[i];\n  cout << find(dp, dp + n, 1e+9) - dp << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nstruct bit {\n  int v[200000];\n  bit() { memset(v, 0, sizeof v); }\n  int query(int p) {\n    int resp = 0;\n    for (int i = p; i > 0; i -= (i & (-i))) resp = max(resp, v[i]);\n    return resp;\n  }\n  void set(int p, int val) {\n    for (int i = p; i < 200000; i += (i & (-i))) v[i] = max(val, v[i]);\n  }\n};\nint main() {\n  scanf(\"%d\", &n);\n  bit bt;\n  int resp = 0;\n  for (int i = 0; i < n; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    bt.set(x, bt.query(x - 1) + 1);\n  }\n  printf(\"%d\\n\", bt.query(150000));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int bit[100009] = {0}, m = -1, n;\nvoid update(long long int i, long long int val) {\n  while (i <= n) {\n    bit[i] = max(val, bit[i]);\n    i += (i & (-i));\n  }\n}\nlong long int query(long long int i) {\n  long long int sum = 0;\n  while (i > 0) {\n    sum = max(sum, bit[i]);\n    i -= (i & (-i));\n  }\n  return sum;\n}\nint main() {\n  cin.tie(0);\n  cout.tie(0);\n  ios::sync_with_stdio(false);\n  long long int i, x;\n  cin >> n;\n  for (i = 0; i < n; i++) {\n    cin >> x;\n    m = max(m, x);\n    update(x, query(x) + 1);\n  }\n  cout << query(n) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, a[100010] = {}, dp[100010] = {}, ii, mx = 0;\n  cin >> n;\n  fill(dp, dp + n + 10, 1000000);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    ii = upper_bound(dp, dp + n, a[i]) - dp;\n    dp[ii] = a[i];\n    mx = max(mx, ii);\n  }\n  cout << mx + 1;\n}\n"
        },
        {
            "language": 1,
            "solution": "def go():\n\tn = input()\n\ta = [1e6] * (n + 1)\n\ts = 1\n\tfor i in raw_input().split():\n\t\tx = int(i)\n\t\tl = 0\n\t\tr = s\n\t\twhile r - l > 1:\n\t\t\tm = (l + r) >> 1\n\t\t\tif a[m] < x : l = m\n\t\t\telse : r = m\n\t\ts += r == s\n\t\ta[r] = min(a[r], x)\n\tprint s - 1\ngo()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 1e5 + 4;\nstruct Node {\n  int best = 0;\n} st[4 * MAX_N];\nint get(int p, int l, int r, int x, int y) {\n  if (l > y || r < x) return 0;\n  if (l >= x && r <= y) return st[p].best;\n  int mid = (l + r) >> 1;\n  int f = get(2 * p + 1, l, mid, x, y);\n  int s = get(2 * p + 2, mid + 1, r, x, y);\n  return max(f, s);\n}\nvoid update(int p, int l, int r, int x, int val) {\n  if (l > x || r < x) return;\n  if (l == r) {\n    st[p].best = val;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  update(2 * p + 1, l, mid, x, val);\n  update(2 * p + 2, mid + 1, r, x, val);\n  st[p].best = max(st[2 * p + 1].best, st[2 * p + 2].best);\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  int res = 0;\n  for (int i = 0; i < n; i++) {\n    int v;\n    scanf(\"%d\", &v);\n    int gt = get(0, 0, n - 1, 1, v - 1) + 1;\n    res = max(res, gt);\n    update(0, 0, n - 1, v, gt);\n  }\n  cout << res << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class lis\n{\n\tstatic int lower_bound(int a[], int first, int last,int n)\n\t{\n\t\tint mid = (first+last)/2;\n\t\twhile(a[mid]!=n && last>first)\n\t\t{\n\t\t\t\n\t\t\tmid = (first+last)/2;\n\t\t\tif(a[mid]==n)\n\t\t\t{\n\t\t\t\treturn mid;\n\t\t\t}\n\t\t\tif(a[mid]<n)\n\t\t\t{\n\t\t\t\tfirst = mid+1;\n\t\t\t}\n\t\t\telse last=mid;\n\t\t}\n\t\tif(a[mid]==n)return mid;\n\t\treturn last;\n\t}\n\tpublic static void main(String arr[])\n\t{\n\t\tint n,k,m;\n\t\tScanner sc= new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor(int i =0;i<n;i++)\n\t\t{\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tint len = 1;\n\t\tint tail[] = new int[n];\n\t\ttail[0]=a[0];\n\t\tfor(int i =1;i<n;i++)\n\t\t{\n\t\t\tif(a[i]<tail[0])\n\t\t\t{\n\t\t\t\ttail[0]=a[i];\n\t\t\t}\n\t\t\telse if(a[i]>tail[len-1])\n\t\t\t{\n\t\t\t\ttail[len]=a[i];\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttail[lower_bound(tail,0,len-1,a[i])] = a[i];\t\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(len);\t\t\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  set<int> st;\n  int n, x;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", &x);\n    st.insert(x);\n    auto it = st.upper_bound(x);\n    if (it != st.end()) st.erase(it);\n  }\n  printf(\"%d\\n\", int(st.size()));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, arr[100005];\nvector<int> v;\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> arr[i];\n  for (int i = 0; i < n; i++) {\n    int pos = upper_bound(v.begin(), v.end(), arr[i]) - v.begin();\n    if (pos == v.size())\n      v.push_back(arr[i]);\n    else\n      v[pos] = arr[i];\n  }\n  cout << v.size() << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200005;\nint a[N], C[N], f[N];\nint bsearch(const int *C, int size, const int &a) {\n  int l = 0, r = size - 1;\n  while (l <= r) {\n    int mid = (l + r) / 2;\n    if (a > C[mid - 1] && a <= C[mid])\n      return mid;\n    else if (a < C[mid])\n      r = mid - 1;\n    else\n      l = mid + 1;\n  }\n}\nint LIS(const int *a, const int &n) {\n  int i, j, size = 1;\n  C[0] = a[0];\n  f[0] = 1;\n  for (i = 1; i < n; ++i) {\n    if (a[i] <= C[0])\n      j = 0;\n    else if (a[i] > C[size - 1])\n      j = size++;\n    else\n      j = bsearch(C, size, a[i]);\n    C[j] = a[i];\n    f[i] = j + 1;\n  }\n  return size;\n}\nint main() {\n  int testcase;\n  int n;\n  int i, j;\n  scanf(\"%d\", &n);\n  for (j = 0; j < n; j++) scanf(\"%d\", &a[j]);\n  printf(\"%d\\n\", LIS(a, n));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1e9 + 7;\nconst double eps = 1e-8;\nconst long long linf = 1e18;\nint a[111111], c[111111], dp[111111];\nlong long gcd(long long a, long long b) {\n  if (a < b) swap(a, b);\n  if (b == 0)\n    return a;\n  else\n    return gcd(b, a % b);\n}\nint bsearch(int c[], int n, int a) {\n  int l = 1, r = n;\n  while (l <= r) {\n    int mid = (l + r) / 2;\n    if (a > c[mid] && a <= c[mid + 1])\n      return mid + 1;\n    else if (a < c[mid])\n      r = mid - 1;\n    else\n      l = mid + 1;\n  }\n}\nint LIS(int a[], int n) {\n  int i, j, size = 1;\n  c[1] = a[1];\n  dp[1] = 1;\n  for (i = 2; i <= n; ++i) {\n    if (a[i] <= c[1])\n      j = 1;\n    else if (a[i] > c[size])\n      j = ++size;\n    else\n      j = bsearch(c, size, a[i]);\n    c[j] = a[i];\n    dp[i] = j;\n  }\n  return size;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  cout << LIS(a, n) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class CF198B {\n\t\n\tpublic void solve() {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint inf = n+100;\n\t\tint[] ar = new int[n+1];\n\t\tar[0] = 0;\n\t\tfor (int i = 1; i < ar.length; i++)\n\t\t\tar[i] = inf;\n\t\t\n\t\tint res = 0;\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = in.nextInt();\n\t\t\t\n\t\t\tint a = 0;\n\t\t\tint b = ar.length;\n\t\t\twhile (a+1 != b) {\n\t\t\t\tint c = (a+b)/2;\n\t\t\t\tif (ar[c] < x) a = c;\n\t\t\t\telse b = c;\n\t\t\t}\n\t\t\tar[b] = Math.min(ar[b], x);\n\t\t\tres = Math.max(res, b);\n\t\t}\n\t\t\n\t\tSystem.out.println(res);\n\t}\n\t\n\tpublic static void main (String[] a) {\n\t\tnew CF198B().solve();\n\t}\t\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint rands() {\n  static int x = 1364684679;\n  x += (x << 2) + 1;\n  return x;\n}\nstruct point {\n  double x, y;\n  int init() { return scanf(\"%lf%lf\", &x, &y); }\n  point operator+(point a) {\n    point ret;\n    ret.x = x + a.x;\n    ret.y = y + a.y;\n    return ret;\n  }\n  point operator-(point a) {\n    point ret;\n    ret.x = x - a.x;\n    ret.y = y - a.y;\n    return ret;\n  }\n  double operator*(point a) { return x * a.y - y * a.x; }\n  double operator^(point a) { return x * a.x + y * a.y; }\n};\nstruct circle {\n  point o;\n  double r;\n};\nstruct point3 {\n  double x, y, z;\n  int init() { return scanf(\"%lf%lf%lf\", &x, &y, &z); }\n  point3 operator+(point3 a) {\n    point3 ret;\n    ret.x = x + a.x;\n    ret.y = y + a.y;\n    ret.z = z + a.z;\n    return ret;\n  }\n  point3 operator-(point3 a) {\n    point3 ret;\n    ret.x = x - a.x;\n    ret.y = y - a.y;\n    ret.z = z - a.z;\n    return ret;\n  }\n  point3 operator*(point3 a) {\n    point3 ret;\n    ret.x = y * a.z - z * a.y;\n    ret.y = z * a.x - x * a.z;\n    ret.z = x * a.y - y * a.x;\n    return ret;\n  }\n  double operator^(point3 a) { return x * a.x + y * a.y + z * a.z; }\n};\ndouble xmult(point p0, point p1, point p2) {\n  return (p1.x - p0.x) * (p2.y - p0.y) - (p1.y - p0.y) * (p2.x - p0.x);\n}\npoint3 xmult3(point3 p0, point3 p1, point3 p2) {\n  point3 ret;\n  ret.x = (p1.y - p0.y) * (p2.z - p0.z) - (p1.z - p0.z) * (p2.y - p0.y);\n  ret.y = (p1.z - p0.z) * (p2.x - p0.x) - (p1.x - p0.x) * (p2.z - p0.z);\n  ret.z = (p1.x - p0.x) * (p2.y - p0.y) - (p1.y - p0.y) * (p2.x - p0.x);\n  return ret;\n}\ndouble dot(point a, point b) { return a.x * b.x + a.y * b.y; }\ndouble dot3(point3 a, point3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\ndouble dist(point a, point b) {\n  return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\ndouble dist3(point3 a, point3 b) {\n  return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y) +\n              (a.z - b.z) * (a.z - b.z));\n}\nstruct matrix {\n  int n;\n  int a[40][40];\n  void clear() { memset(a, 0, sizeof(a)); }\n  void init() {\n    clear();\n    for (int i = 1; i <= n; i++) a[i][i] = 1;\n  }\n  matrix operator*(matrix b) {\n    matrix c;\n    c.n = n;\n    for (int i = 1; i <= n; i++)\n      for (int j = 1; j <= n; j++) {\n        c.a[i][j] = 0;\n        for (int k = 1; k <= n; k++) c.a[i][j] += a[i][k] * b.a[k][j];\n      }\n    return c;\n  }\n  matrix operator+(matrix b) {\n    matrix c;\n    c.n = n;\n    for (int i = 1; i <= n; i++)\n      for (int j = 1; j <= n; j++) c.a[i][j] = a[i][j] + b.a[i][j];\n    return c;\n  }\n  void printmatrix() {\n    for (int i = 1; i <= n; i++) {\n      for (int j = 1; j <= n; j++) printf(\"%d \", a[i][j]);\n      printf(\"\\n\");\n    }\n  }\n};\nstruct bignumber {\n  int n;\n  int a[10010];\n  void clear() {\n    n = 0;\n    memset(a, 0, sizeof(a));\n  }\n  void init(char *s) {\n    clear();\n    n = strlen(s);\n    for (int i = 0; s[i]; i++) a[n - i] = s[i] - '0';\n    while (a[n] == 0 && n > 1) n--;\n  }\n  void init(int s) {\n    clear();\n    if (s == 0) {\n      n = 1;\n      a[1] = 0;\n      return;\n    }\n    while (s) {\n      a[++n] = s % 10;\n      s /= 10;\n    }\n  }\n  void output() {\n    for (int i = n; i > 0; i--) printf(\"%d\", a[i]);\n    printf(\"\\n\");\n  }\n  int operator<(bignumber b) {\n    if (n < b.n) return 1;\n    if (n > b.n) return 0;\n    for (int i = n; i > 0; i--) {\n      if (a[i] < b.a[i]) return 1;\n      if (a[i] > b.a[i]) return 0;\n    }\n    return 0;\n  }\n  int operator==(bignumber b) {\n    if (n != b.n) return 0;\n    for (int i = n; i > 0; i--)\n      if (a[i] != b.a[i]) return 0;\n    return 1;\n  }\n};\nbignumber operator+(bignumber a, bignumber b) {\n  a.n = max(a.n, b.n);\n  for (int i = 1; i <= a.n; i++) {\n    a.a[i] += b.a[i];\n    a.a[i + 1] += a.a[i] / 10;\n    a.a[i] %= 10;\n  }\n  if (a.a[a.n + 1] > 0) a.n++;\n  return a;\n}\nbignumber operator-(bignumber a, bignumber b) {\n  for (int i = 1; i <= a.n; i++) {\n    a.a[i] -= b.a[i];\n    if (a.a[i] < 0) {\n      a.a[i + 1]--;\n      a.a[i] += 10;\n    }\n  }\n  while (a.a[a.n] == 0 && a.n > 1) a.n--;\n  return a;\n}\nbignumber operator*(bignumber a, int b) {\n  for (int i = 1; i <= a.n; i++) {\n    a.a[i] = a.a[i] * b + a.a[i - 1] / 10;\n    a.a[i - 1] %= 10;\n  }\n  while (a.a[a.n] >= 10) {\n    a.n++;\n    a.a[a.n] = a.a[a.n - 1] / 10;\n    a.a[a.n - 1] %= 10;\n  }\n  return a;\n}\nbignumber operator/(bignumber a, int b) {\n  int tmp = 0;\n  for (int i = a.n; i > 0; i--) {\n    tmp = tmp * 10 + a.a[i];\n    a.a[i] = tmp / b;\n    tmp %= b;\n  }\n  while (a.a[a.n] == 0 && a.n > 1) a.n--;\n  return a;\n}\nbignumber gcd(bignumber a, bignumber b) {\n  int ans = 0;\n  bignumber c;\n  while (1) {\n    if (a.n == 1 && a.a[1] == 0) {\n      c = b;\n      break;\n    }\n    if (b.n == 1 && b.a[1] == 0) {\n      c = a;\n      break;\n    }\n    int flag = 0;\n    if (a.a[1] % 2 == 0) a = a / 2, flag++;\n    if (b.a[1] % 2 == 0) b = b / 2, flag++;\n    if (flag == 2) ans++;\n    if (!flag)\n      if (a < b)\n        b = b - a;\n      else\n        a = a - b;\n  }\n  while (ans--) c = c * 2;\n  return c;\n}\nint fastget() {\n  char c;\n  int ans = 0;\n  c = getchar();\n  int sign = 1;\n  while (!(c >= '0' && c <= '9' || c == '-')) c = getchar();\n  if (c == '-') sign = -1, c = getchar();\n  while (c >= '0' && c <= '9') {\n    ans = (ans << 3) + (ans << 1) + c - '0';\n    c = getchar();\n  }\n  return ans * sign;\n}\nvoid fastput(int x) {\n  char s[12];\n  int a = 0;\n  if (x == 0)\n    puts(\"0\");\n  else {\n    if (x < 0) putchar('-'), x = -x;\n    while (x) {\n      s[a++] = x % 10 + '0';\n      x /= 10;\n    }\n    for (a--; a >= 0; a--) putchar(s[a]);\n    putchar('\\n');\n  }\n}\nint n, a;\nint tree[100010 << 2];\nint query(int L, int R, int l, int r, int rt) {\n  if (L <= l && R >= r) return tree[rt];\n  int mid = l + r >> 1, ret = 0;\n  if (L <= mid) ret = max(ret, query(L, R, l, mid, rt << 1));\n  if (R > mid) ret = max(ret, query(L, R, mid + 1, r, rt << 1 | 1));\n  return ret;\n}\nvoid update(int i, int x, int l, int r, int rt) {\n  if (l == r) {\n    tree[rt] = x;\n    return;\n  }\n  int mid = l + r >> 1;\n  if (i <= mid)\n    update(i, x, l, mid, rt << 1);\n  else\n    update(i, x, mid + 1, r, rt << 1 | 1);\n  tree[rt] = max(tree[rt << 1], tree[rt << 1 | 1]);\n}\nint main() {\n  n = fastget();\n  memset(tree, 0, sizeof(tree));\n  int ans = 0;\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d\", &a);\n    int lcs = query(1, a, 1, n, 1);\n    ans = max(ans, lcs + 1);\n    update(a, lcs + 1, 1, n, 1);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100005;\nint a[MAXN];\nint dp[MAXN];\nint q[MAXN];\nint n;\nvoid cc() {\n  int top = 0;\n  for (int i = 1; i <= n; i++) {\n    if (top == 0 || dp[top] < a[i]) {\n      dp[++top] = a[i];\n      continue;\n    }\n    int l = 1, r = top;\n    int ans = 1;\n    while (l <= r) {\n      int mid = (l + r) >> 1;\n      if (dp[mid] < a[i])\n        l = mid + 1;\n      else {\n        ans = mid;\n        r = mid - 1;\n      }\n    }\n    dp[ans] = a[i];\n  }\n  cout << top << endl;\n}\nint main() {\n  while (cin >> n) {\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n    cc();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100005], n;\nvoid update(int i, int v) {\n  for (; i < n; i = i | (i + 1)) a[i] = max(a[i], v);\n}\nint get(int i) {\n  int len = 0;\n  for (; i >= 0; i = (i & (i + 1)) - 1) len = max(len, a[i]);\n  return len;\n}\nint main() {\n  int mx, x, i, ans = 0;\n  cin >> n;\n  for (i = 0; i < n; i++) {\n    cin >> x;\n    mx = get(x - 1);\n    update(x, mx + 1);\n    ans = max(ans, mx + 1);\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def CeilIndex(A, l, r, key): \n  \n    while (r - l > 1): \n      \n        m = l + (r - l)//2\n        if (A[m] >= key): \n            r = m \n        else: \n            l = m \n    return r \n   \ndef LIS(A, size): \n    tailTable = [0 for i in range(size + 1)] \n    len = 0 \n   \n    tailTable[0] = A[0] \n    len = 1\n    for i in range(1, size): \n      \n        if (A[i] < tailTable[0]): \n            tailTable[0] = A[i] \n   \n        elif (A[i] > tailTable[len-1]): \n            tailTable[len] = A[i] \n            len+= 1\n   \n        else: \n            tailTable[CeilIndex(tailTable, -1, len-1, A[i])] = A[i] \n          \n   \n    return len\n\ndef main():\n    n = int(input())\n    arr = list(map(int,input().split()))\n\n    print(LIS(arr,n))\n    \n\nmain()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000 * 1000 * 1000;\nconst int XD = 100100;\nint a[XD];\nint dp[XD];\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", a + i);\n  }\n  dp[0] = -1;\n  for (int i = 1; i <= n; ++i) {\n    dp[i] = INF;\n  }\n  int lim = 1;\n  for (int i = 0; i < n; ++i) {\n    int lf = 0, rg = lim;\n    while (lf < rg) {\n      int mid = (lf + rg) >> 1;\n      if (a[i] > dp[mid]) {\n        lf = mid + 1;\n      } else {\n        rg = mid;\n      }\n    }\n    dp[lf] = a[i];\n    lim = max(lim, lf + 1);\n  }\n  printf(\"%d\\n\", lim - 1);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\ninline void inp(T &any) {\n  cin >> any;\n}\ntemplate <typename T, typename... U>\ninline void inp(T &a, U &...b) {\n  cin >> a;\n  inp(b...);\n}\ntemplate <typename T>\ninline istream &operator>>(istream &in, vector<T> &a) {\n  for (auto &x : a) in >> x;\n  return in;\n}\ntemplate <typename T, typename U>\ninline istream &operator>>(istream &in, pair<T, U> &a) {\n  in >> a.first >> a.second;\n  return in;\n}\nlong long int LIS(vector<long long int> &a) {\n  set<long long int> ms;\n  for (auto x : a) {\n    ms.emplace(x);\n    auto it = ms.upper_bound(x);\n    if (it != ms.end()) {\n      ms.erase(it);\n    }\n  }\n  return ms.size();\n}\nvoid solve(long long int &T) {\n  long long int n;\n  cin >> n;\n  vector<long long int> a(n);\n  cin >> a;\n  cout << LIS(a) << '\\n';\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int t = 1;\n  for (long long int Case = (1); Case < (t + 1); Case++) {\n    if (0) cerr << \"Case #\" << Case << \"\\n\";\n    solve(Case);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.BufferedReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author AlexFetisov\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] a = Utils.readIntArray(in, n);\n            for (int i = 0; i < n; ++i) --a[i];\n\n            TaskB.SegmentTreeMax st = new TaskB.SegmentTreeMax(n);\n            st.update(a[0], 1);\n            for (int i = 1; i < n; ++i) {\n                int cur = st.getMax(0, a[i]);\n                st.update(a[i], cur + 1);\n            }\n            out.println(st.getMax(0, n));\n        }\n\n        class SegmentTreeMax {\n            int[] max;\n            int size;\n            int n;\n\n            public SegmentTreeMax(int n) {\n                size = n;\n                this.n = n;\n                max = new int[size * 4];\n            }\n\n            void update(int pos, int value) {\n                int left = 0, right = n, v = 1;\n                while (left + 1 < right) {\n                    int middle = (left + right) / 2;\n                    v *= 2;\n                    if (pos < middle) {\n                        right = middle;\n                    } else {\n                        ++v;\n                        left = middle;\n                    }\n                }\n                max[v] = value;\n                v /= 2;\n                while (v > 0) {\n                    max[v] = Math.max(max[v * 2], max[v * 2 + 1]);\n                    v /= 2;\n                }\n            }\n\n            int getMax(int left, int right) {\n                return get(1, left, right, 0, n);\n            }\n\n            private int get(int v, int left, int right, int rangeLeft, int rangeRight) {\n                if (left >= rangeRight || right <= rangeLeft) return 0;\n                if (rangeLeft >= left && rangeRight <= right) {\n                    return max[v];\n                }\n                int middle = (rangeLeft + rangeRight) / 2;\n                int res = Math.max(\n                        get(v * 2, left, right, rangeLeft, middle),\n                        get(v * 2 + 1, left, right, middle, rangeRight)\n                );\n                return res;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer stt;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n\n        public String nextString() {\n            while (stt == null || !stt.hasMoreTokens()) {\n                stt = new StringTokenizer(nextLine());\n            }\n            return stt.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(nextString());\n        }\n\n    }\n\n    static class Utils {\n        public static int[] readIntArray(InputReader in, int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; ++i) {\n                a[i] = in.nextInt();\n            }\n            return a;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class CF198 {\n\n    public static void main(String[] args) throws IOException {\n        new CF198().run();\n    }\n\n    final int MAXN = (int)1e5 + 100;\n\n    int lower_bound(int[] a, int l, int r, int val) {\n        while(l + 1 < r) {\n            int m = l + ((r - l) >> 1);\n            if(a[m] < val)\n                l = m;\n            else\n                r = m;\n        }\n\n        if(!(val < a[r]) && (a[l] < val))\n            l = r;\n\n        return l;\n    }\n\n    void solve() throws IOException {\n        int n = nextInt();\n        int[] a = new int[n];\n        for(int i = 0; i < n; ++i)\n            a[i] = nextInt();\n\n        int[] d = new int[n + 1];\n        d[0] = Integer.MIN_VALUE;\n        for(int i = 1; i < d.length; ++i)\n            d[i] = Integer.MAX_VALUE;\n\n\n        for(int i = 0; i < n; ++i) {\n            int pos = lower_bound(d, 0, n + 1, a[i]);\n            d[pos + 1] = a[i];\n        }\n\n        for(int i = n; i >= 1; --i)\n            if(d[i] < Integer.MAX_VALUE) {\n                out.println(i);\n                return;\n            }\n    }\n\n    BufferedReader br;\n    StringTokenizer st;\n    PrintWriter out;\n\n    public String nextToken() throws IOException {\n        while(st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n\n        return st.nextToken();\n    }\n\n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    public long nextLong() throws  IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    public double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    void run() throws IOException {\n        boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n        br = new BufferedReader( new InputStreamReader( oj ? System.in : new FileInputStream(\"input.txt\")));\n        out = new PrintWriter( oj ? System.out : new FileOutputStream(\"output.txt\"));\n\n        solve();\n\n        out.close();\n    }\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class lis {\n\tprivate static class Solver {\n\n\t\tint longestIncreasingSubsequence(int[] ary) {\n\t\t\tint[] m = new int[ary.length + 1];\n\t\t\tint max = 0;\n\t\t\tfor (int i = 0; i < ary.length; i++) {\n\t\t\t\tint lo = 1;\n\t\t\t\tint hi = max;\n\n\t\t\t\twhile (lo <= hi) {\n\t\t\t\t\tint mid = (lo + hi) / 2;\n\t\t\t\t\tif (ary[m[mid]] < ary[i])\n\t\t\t\t\t\tlo = mid + 1;\n\t\t\t\t\telse\n\t\t\t\t\t\thi = mid - 1;\n\t\t\t\t}\n\t\t\t\tif (lo > max) {\n\t\t\t\t\tm[lo] = i;\n\t\t\t\t\tmax = lo;\n\t\t\t\t} else if (ary[i] < ary[m[lo]])\n\t\t\t\t\tm[lo] = i;\n\t\t\t}\n\n\t\t\treturn max;\n\t\t}\n\n\t\tvoid solve(int testNumber, Scanner s, PrintWriter out) {\n\t\t\tint N = s.nextInt();\n\t\t\tint[] nums = new int[N];\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tnums[i] = s.nextInt();\n\t\t\tout.println(longestIncreasingSubsequence(nums));\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tSolver solver = new Solver();\n\t\tsolver.solve(1, s, out);\n\t\ts.close();\n\t\tout.close();\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint m[100500];\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  memset(m, 63, sizeof m);\n  m[0] = -1;\n  int ans = 1;\n  for (int i = 0; i < (int)(n); ++i) {\n    int a;\n    scanf(\"%d\", &a);\n    int l = 0, r = n;\n    while (r - l > 1) {\n      int mid = (l + r) / 2;\n      if (m[mid] <= a)\n        l = mid;\n      else\n        r = mid;\n    }\n    m[r] = a;\n    if (ans < r) ans = r;\n  }\n  printf(\"%d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint f(vector<int>& v) {\n  vector<int> tail(v.size(), 0);\n  int length = 1;\n  tail[0] = v[0];\n  for (int i = 1; i < v.size(); i++) {\n    auto b = tail.begin(), e = tail.begin() + length;\n    auto it = lower_bound(b, e, v[i]);\n    if (it == tail.begin() + length)\n      tail[length++] = v[i];\n    else\n      *it = v[i];\n  }\n  return length;\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long n;\n  cin >> n;\n  vector<int> ar(n);\n  long long mx = 0;\n  for (long long i = 0; i < (long long)n; ++i) {\n    cin >> ar[i];\n  }\n  cout << f(ar) << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint STree[100000 * 4 + 5];\nvoid update(int node, int l, int r, int a, int b) {\n  if (l == r) {\n    STree[node] = b;\n  } else {\n    int m = (l + r) >> 1;\n    if (a <= m) {\n      update(2 * node + 1, l, m, a, b);\n    } else {\n      update(2 * node + 2, m + 1, r, a, b);\n    }\n    STree[node] = max(STree[2 * node + 1], STree[2 * node + 2]);\n  }\n}\nint query(int node, int l, int r, int a, int b) {\n  if (r < a || l > b) return 0;\n  if (a <= l && r <= b) return STree[node];\n  int m = (l + r) >> 1;\n  int ans = 0;\n  if (a <= m) ans = max(ans, query(2 * node + 1, l, m, a, b));\n  if (b > m) ans = max(ans, query(2 * node + 2, m + 1, r, a, b));\n  return ans;\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  int num[n + 5];\n  for (int i = 0; i < n; i++) scanf(\"%d\", &num[i]);\n  int ans = 0;\n  for (int i = n - 1; i >= 0; i--) {\n    num[i]--;\n    int tmp = query(0, 0, n - 1, num[i], n - 1) + 1;\n    update(0, 0, n - 1, num[i], tmp);\n    ans = max(ans, tmp);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int i, j, n, top, temp;\n  int stack[101101];\n  cin >> n;\n  top = 0;\n  stack[0] = -1;\n  for (i = 0; i < n; i++) {\n    cin >> temp;\n    if (temp > stack[top]) {\n      stack[++top] = temp;\n    } else {\n      int low = 1, high = top;\n      int mid;\n      while (low <= high) {\n        mid = (low + high) / 2;\n        if (temp > stack[mid]) {\n          low = mid + 1;\n        } else {\n          high = mid - 1;\n        }\n      }\n      stack[low] = temp;\n    }\n  }\n  cout << top << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint a[100005];\nint dp[100005], INF;\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", a + i);\n  memset(dp, 63, sizeof(dp)), INF = dp[0];\n  dp[0] = 0;\n  for (int i = 1; i <= n; ++i) {\n    int idx = lower_bound(dp, dp + 1 + n, a[i]) - dp;\n    dp[idx] = min(dp[idx], a[i]);\n  }\n  for (int i = n; i >= 1; --i)\n    if (dp[i] != INF) {\n      printf(\"%d\", i);\n      break;\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\nconst int INF = 0x3f3f3f3f;\nint a[200000], b[200000], n, m, sum = 0, ans, maxx, pos, len, seq[200000];\nint f[200000] = {0};\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> n;\n  for (int i = 0; i <= n - 1; i++) {\n    cin >> a[i];\n  }\n  m = n;\n  ans = 0;\n  for (auto i : a) {\n    pos = lower_bound(seq, seq + len, i) - seq;\n    seq[pos] = i;\n    len = max(len, pos + 1);\n    f[i] = len;\n  }\n  cout << len;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import bisect\nn=int(input())\na=list(map(int,input().split()))\nINF=10**18\ndp=[INF]*n\nfor i in range(n):\n  dp[bisect.bisect_left(dp,a[i])]=a[i]\nprint(bisect.bisect_left(dp,INF))"
        }
    ]
}