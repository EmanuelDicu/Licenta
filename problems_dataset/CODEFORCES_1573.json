{
    "name": "1573_C. Book",
    "source": "CODEFORCES",
    "description": "You are given a book with n chapters.\n\nEach chapter has a specified list of other chapters that need to be understood in order to understand this chapter. To understand a chapter, you must read it after you understand every chapter on its required list.\n\nCurrently you don't understand any of the chapters. You are going to read the book from the beginning till the end repeatedly until you understand the whole book. Note that if you read a chapter at a moment when you don't understand some of the required chapters, you don't understand this chapter.\n\nDetermine how many times you will read the book to understand every chapter, or determine that you will never understand every chapter no matter how many times you read the book.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 2\u22c510^4).\n\nThe first line of each test case contains a single integer n (1 \u2264 n \u2264 2\u22c510^5) \u2014 number of chapters.\n\nThen n lines follow. The i-th line begins with an integer k_i (0 \u2264 k_i \u2264 n-1) \u2014 number of chapters required to understand the i-th chapter. Then k_i integers a_{i,1}, a_{i,2}, ..., a_{i, k_i} (1 \u2264 a_{i, j} \u2264 n, a_{i, j} \u2260 i, a_{i, j} \u2260 a_{i, l} for j \u2260 l) follow \u2014 the chapters required to understand the i-th chapter.\n\nIt is guaranteed that the sum of n and sum of k_i over all testcases do not exceed 2\u22c510^5.\n\nOutput\n\nFor each test case, if the entire book can be understood, print how many times you will read it, otherwise print -1.\n\nExample\n\nInput\n\n\n5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 2\n1 3\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 5\n0\n\n\nOutput\n\n\n2\n-1\n1\n2\n5\n\nNote\n\nIn the first example, we will understand chapters \\{2, 4\\} in the first reading and chapters \\{1, 3\\} in the second reading of the book.\n\nIn the second example, every chapter requires the understanding of some other chapter, so it is impossible to understand the book.\n\nIn the third example, every chapter requires only chapters that appear earlier in the book, so we can understand everything in one go.\n\nIn the fourth example, we will understand chapters \\{2, 3, 4\\} in the first reading and chapter 1 in the second reading of the book.\n\nIn the fifth example, we will understand one chapter in every reading from 5 to 1.",
    "difficulty": "C",
    "tags": [
        "data structures",
        "dp",
        "graphs",
        "implementation"
    ],
    "rating": 1800,
    "public_test": [
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 2\n1 3\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 5\n0\n",
            "output": "2\n-1\n1\n2\n5\n"
        }
    ],
    "generated_test": [
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 1\n1 3\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 5\n0\n",
            "output": "2\n-1\n1\n2\n5\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 1\n1 3\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 2\n1 3\n1 4\n5\n0\n0\n2 1 4\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 5\n0\n",
            "output": "2\n-1\n2\n2\n5\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 3\n5\n1 5\n1 1\n1 2\n1 3\n1 4\n5\n0\n0\n2 1 4\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 5\n0\n",
            "output": "-1\n-1\n2\n2\n5\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 3\n5\n1 5\n1 1\n1 2\n1 3\n1 4\n5\n0\n0\n2 1 4\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 4\n1 3\n1 4\n1 5\n0\n",
            "output": "-1\n-1\n2\n2\n4\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 3\n5\n1 5\n1 1\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "-1\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 1\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n-1\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 4\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 1\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n2\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 2 4\n1 1\n5\n1 2\n1 1\n1 1\n1 3\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "3\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n1 1\n1 3\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 1 2\n5\n1 3\n1 3\n1 4\n1 5\n0\n",
            "output": "2\n-1\n1\n2\n4\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 3\n5\n1 5\n1 1\n1 2\n1 3\n1 4\n5\n0\n0\n2 1 4\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 2\n1 5\n0\n",
            "output": "-1\n-1\n2\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 1\n5\n1 2\n1 5\n1 2\n1 3\n0\n",
            "output": "2\n-1\n1\n-1\n3\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n1 1\n1 3\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 4 3\n0\n0\n2 1 2\n5\n1 2\n1 3\n1 4\n1 5\n0\n",
            "output": "2\n-1\n1\n-1\n5\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 4\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 1 1\n5\n1 2\n1 4\n1 4\n1 3\n0\n",
            "output": "2\n-1\n2\n-1\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 2 4\n1 2\n5\n1 2\n1 1\n1 1\n1 3\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 4\n1 3\n1 5\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n3\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 1\n5\n1 3\n0 2\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 4\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "3\n-1\n2\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 1\n1 3\n1 4\n5\n0\n0\n2 1 2\n1 3\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 2\n1 1\n1 1\n1 3\n1 4\n5\n0\n0\n2 1 2\n1 3\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 1\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 3\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 1\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 1\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 1\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 1\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 1\n1 1\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n1 1\n1 3\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 5\n0\n",
            "output": "2\n-1\n1\n2\n5\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 1\n1 2\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 3\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 4\n1 2\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 1\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n0 1\n1 2\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 3\n1 3\n1 4\n1 2\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 2\n1 3\n1 2\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 5\n0\n",
            "output": "2\n-1\n1\n2\n5\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 1 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 3\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "-1\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 2\n1 1\n1 1\n1 3\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 3\n5\n1 5\n1 1\n1 1\n1 2\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "-1\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 4\n1 2\n1 1\n1 1\n1 3\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 1\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n0 1\n1 2\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 3\n5\n1 5\n1 1\n1 1\n1 2\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 4\n1 3\n1 4\n1 3\n0\n",
            "output": "-1\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n0 1\n1 2\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 1\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n1 2\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 2 4\n1 2\n5\n1 5\n1 1\n1 1\n1 2\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 3\n0\n2 1 4\n1 4\n5\n1 5\n1 1\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "-1\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 1\n5\n1 2\n1 4\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n-1\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 1 2\n5\n1 2\n1 3\n1 4\n1 2\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 2 4\n1 2\n5\n1 2\n1 1\n1 1\n1 3\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n0 1\n1 2\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 1\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 4\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n1 2\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 1\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 1\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 2\n1 2\n5\n1 5\n1 1\n1 1\n1 2\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 4\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n0 1\n1 2\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 2\n1 2\n5\n1 5\n1 1\n0 1\n1 2\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 1\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 1\n2 2 1\n4\n2 2 3\n0\n0\n2 3 1\n5\n1 1\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n1 1\n1 3\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 1 2\n5\n1 2\n1 3\n1 4\n1 5\n0\n",
            "output": "2\n-1\n1\n2\n5\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 4 1\n4\n2 2 3\n0\n0\n2 1 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 1\n5\n1 2\n1 3\n1 2\n1 3\n0\n",
            "output": "2\n-1\n1\n-1\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 3\n5\n1 5\n1 1\n1 1\n1 2\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 1\n1 3\n1 4\n1 3\n0\n",
            "output": "-1\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 4\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n0 1\n1 2\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 1\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 1\n1 1\n1 1\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 1 2\n5\n1 2\n1 3\n1 4\n1 2\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 2\n1 2\n5\n1 5\n1 1\n1 1\n1 2\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 1\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 4\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 1\n1 1\n1 1\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 1 2\n5\n1 2\n1 3\n1 4\n1 2\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 4 3\n0\n0\n2 3 2\n5\n1 1\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 2\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 1 2\n5\n1 2\n1 3\n1 4\n1 2\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 1\n1 2\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 4 1\n4\n2 2 3\n0\n0\n2 1 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 2\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 3\n2 2 1\n4\n2 2 3\n0\n0\n2 1 2\n5\n1 2\n1 3\n1 4\n1 2\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 2 4\n1 1\n5\n1 4\n1 1\n1 1\n1 3\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "3\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 1\n1 2\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 4 1\n4\n2 2 3\n0\n0\n2 1 2\n4\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 1\n1 3\n1 4\n5\n0\n0\n2 1 2\n1 5\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n2\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 2\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 3\n5\n1 5\n1 1\n1 2\n1 3\n1 4\n5\n0\n0\n2 2 4\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 5\n0\n",
            "output": "-1\n-1\n2\n2\n5\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 4\n1 2\n1 2\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 1\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n1 2\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 3\n1 3\n1 4\n1 2\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 2\n1 1\n1 2\n1 3\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n1 2\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 1\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 3\n0\n2 1 4\n1 4\n5\n1 5\n1 1\n1 1\n1 1\n1 2\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "-1\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n1 2\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 1\n2 2 1\n4\n2 4 3\n0\n0\n2 3 2\n5\n1 1\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 4\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n0 1\n1 2\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 3 1\n4\n2 2 4\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 4\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 1\n1 1\n1 1\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 1 2\n5\n1 4\n1 3\n1 4\n1 2\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 2 4\n1 1\n5\n1 4\n1 1\n1 1\n1 3\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 1\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "3\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 4\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 1\n1 1\n1 1\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 4 3\n0\n0\n2 1 2\n5\n1 4\n1 3\n1 4\n1 2\n0\n",
            "output": "2\n-1\n1\n-1\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 2 4\n1 2\n5\n1 4\n1 1\n1 1\n1 3\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 1\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 3\n5\n1 5\n1 2\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "-1\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n4\n1 1\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 1\n5\n1 5\n1 1\n1 1\n1 2\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "3\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n1 1\n1 1\n1 4\n5\n0\n0\n1 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 3\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 2 4\n1 2\n5\n1 5\n1 1\n1 1\n1 2\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 5\n0\n",
            "output": "2\n-1\n1\n2\n5\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 1 1\n5\n1 2\n1 4\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n-1\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 4 1\n4\n2 2 3\n0\n0\n2 1 2\n5\n1 1\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 2\n1 2\n5\n1 5\n1 1\n1 1\n1 2\n1 4\n5\n0\n0\n2 1 2\n1 1\n2 2 1\n4\n2 2 4\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 1\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 2 4\n1 1\n5\n1 2\n1 1\n1 1\n1 3\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 4\n1 3\n1 4\n1 3\n0\n",
            "output": "3\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 1\n5\n1 4\n1 2\n1 2\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 1\n1 3\n1 4\n1 3\n0\n",
            "output": "3\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 2 1\n1 2\n5\n1 5\n1 1\n1 1\n1 2\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 5\n0\n",
            "output": "2\n-1\n1\n2\n5\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 2 4\n1 2\n5\n1 2\n1 1\n1 1\n1 3\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 4\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 3\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "-1\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 4\n0\n2 1 4\n1 3\n5\n1 5\n1 1\n1 2\n1 3\n1 4\n5\n0\n0\n2 1 4\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 5\n0\n",
            "output": "-1\n-1\n2\n2\n5\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 3\n5\n1 5\n1 1\n1 1\n1 1\n1 1\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "-1\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 4\n1 1\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 1\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 2\n1 1\n1 1\n1 3\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 5\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n0 1\n1 2\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 4 1\n4\n2 2 4\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n0 1\n1 2\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 2\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 2 4\n1 2\n5\n1 2\n1 1\n1 1\n1 3\n1 1\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 2\n1 2\n5\n1 5\n1 1\n0 1\n1 2\n1 4\n5\n0\n0\n2 1 4\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 1\n1 3\n0\n",
            "output": "2\n-1\n2\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n0 2\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 4 3\n0\n0\n2 3 2\n5\n1 1\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 2\n1 1\n1 2\n1 3\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 4\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 4\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 1\n1 1\n1 1\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 1 2\n5\n1 4\n1 3\n1 1\n1 2\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 1\n5\n1 2\n1 1\n1 1\n1 3\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 5\n1 4\n1 3\n0\n",
            "output": "3\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 2 4\n1 2\n5\n1 2\n1 1\n1 1\n1 3\n1 1\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 1\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 2 4\n1 2\n5\n1 5\n0 2\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 4 3\n0\n0\n2 3 2\n5\n1 1\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 3\n0\n2 2 4\n1 2\n5\n1 2\n1 1\n1 1\n1 3\n1 1\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 1\n1 3\n1 4\n1 3\n0\n",
            "output": "3\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 2 4\n1 2\n5\n1 5\n1 1\n1 1\n1 3\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 2\n1 1\n1 1\n1 3\n1 4\n5\n0\n0\n2 1 2\n1 3\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 5\n0\n",
            "output": "2\n-1\n1\n2\n5\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 3\n1 1\n1 1\n1 2\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n1 2\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 2\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 2 4\n1 2\n5\n1 5\n1 1\n1 1\n1 3\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 4\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 1\n1 1\n1 2\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 4 3\n0\n0\n2 1 2\n5\n1 4\n1 3\n1 4\n1 2\n0\n",
            "output": "2\n-1\n1\n-1\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 2 4\n1 2\n5\n1 4\n1 1\n1 1\n1 3\n1 5\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 1\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n1 2\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n4\n1 1\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 1\n5\n1 5\n1 1\n1 1\n1 2\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 1\n0\n",
            "output": "3\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 1\n5\n1 2\n1 5\n1 2\n1 1\n0\n",
            "output": "2\n-1\n1\n-1\n3\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 2 4\n1 1\n5\n1 2\n1 1\n1 1\n1 3\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 3 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 4\n1 3\n1 4\n1 3\n0\n",
            "output": "3\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 4\n0\n2 2 1\n1 2\n5\n1 5\n1 1\n1 1\n1 2\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 5\n0\n",
            "output": "2\n-1\n1\n2\n5\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n0 1\n1 2\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 2\n4\n1 2\n1 3\n1 2\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n0 2\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 4 3\n0\n0\n2 3 2\n5\n1 1\n1 5\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 3\n1 2\n1 1\n1 2\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 2 4\n1 2\n5\n1 5\n1 2\n1 2\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 2\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 1\n1 3\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 3\n1 2\n1 1\n1 2\n1 4\n5\n0\n0\n2 1 4\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n2\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 3\n0 2\n1 1\n1 2\n1 4\n5\n0\n0\n2 1 4\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n2\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 3\n0 2\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 4\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n2\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 4\n1 1\n1 1\n1 3\n1 4\n5\n0\n0\n2 1 2\n1 3\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 1\n2 4 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 1\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 4\n1 3\n1 1\n1 1\n1 3\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 1\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n0 1\n1 2\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 1\n5\n1 2\n1 3\n1 1\n1 3\n0\n",
            "output": "2\n-1\n1\n-1\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n1 2\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 3\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 3\n0\n2 1 4\n1 4\n5\n1 5\n1 1\n1 1\n1 1\n1 4\n5\n0\n0\n1 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "-1\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 4\n0\n2 1 4\n1 2\n5\n1 3\n1 1\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 4\n0\n2 1 4\n1 3\n5\n1 5\n1 2\n0 1\n1 2\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 4\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "-1\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 4\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n0 1\n1 2\n1 4\n5\n0\n0\n2 1 2\n1 3\n2 2 1\n4\n2 2 4\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 1\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 1\n2 2 1\n4\n2 4 3\n0\n0\n2 3 2\n5\n1 1\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 2 4\n1 2\n5\n1 4\n1 1\n1 1\n1 3\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n1 2\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 4\n1 3\n1 4\n1 2\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 3\n5\n1 5\n1 1\n1 4\n1 3\n1 4\n5\n0\n0\n2 1 4\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 2\n1 5\n0\n",
            "output": "-1\n-1\n2\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 1\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 4 1\n4\n2 2 3\n0\n0\n2 1 2\n5\n1 1\n1 5\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 2 4\n1 1\n5\n1 2\n1 1\n1 1\n1 5\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 4\n1 3\n1 4\n1 3\n0\n",
            "output": "3\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 4\n0\n2 1 4\n1 3\n5\n1 5\n1 1\n1 4\n1 3\n1 4\n5\n0\n0\n2 1 4\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 5\n0\n",
            "output": "-1\n-1\n2\n2\n5\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 3\n5\n1 5\n1 1\n1 1\n1 2\n1 1\n5\n0\n0\n2 1 2\n1 2\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 3\n1 4\n1 3\n0\n",
            "output": "-1\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n0 2\n1 1\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 2\n2 3 1\n4\n2 4 3\n0\n0\n2 3 2\n5\n1 1\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 2 4\n1 2\n5\n1 2\n1 1\n1 1\n1 3\n1 1\n5\n0\n0\n2 1 2\n1 3\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 1\n1 3\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        },
        {
            "input": "5\n4\n1 2\n0\n2 1 4\n1 2\n5\n1 5\n1 2\n1 2\n1 1\n1 4\n5\n0\n0\n2 1 2\n1 3\n2 2 1\n4\n2 2 3\n0\n0\n2 3 2\n5\n1 2\n1 2\n1 4\n1 3\n0\n",
            "output": "2\n-1\n1\n2\n-1\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstring yes[2] = {\"NO\\n\", \"YES\\n\"};\nconst long long mod = long long(1e9) + 7;\nconst long long inf = long long(1e16) + 1;\nbool testc = 1;\nconst int N = 2e5 + 5;\nint n, i, to[N], x, j, dp[N], o;\nvector<int> adj[N];\nvoid dfs(int x) {\n  int j, y;\n  for (j = 0; j < adj[x].size(); ++j) {\n    y = adj[x][j];\n    --to[y];\n    if (x > y)\n      dp[y] = max(dp[x] + 1, dp[y]);\n    else\n      dp[y] = max(dp[x], dp[y]);\n    if (!to[y]) {\n      to[y] = -1;\n      dfs(y);\n    }\n  }\n}\nvoid solve() {\n  cin >> n;\n  for (i = 1; i <= n; ++i) {\n    adj[i].clear();\n    dp[i] = 1;\n    to[i] = 0;\n  }\n  for (i = 1; i <= n; ++i) {\n    cin >> to[i];\n    for (j = 1; j <= to[i]; ++j) {\n      cin >> x;\n      adj[x].push_back(i);\n    }\n  }\n  for (i = 1; i <= n; ++i)\n    if (!to[i]) {\n      to[i] = -1;\n      dfs(i);\n    }\n  for (i = 1; i <= n; ++i)\n    if (to[i] != -1) {\n      cout << \"-1\\n\";\n      return;\n    }\n  o = 0;\n  for (i = 1; i <= n; ++i) o = max(o, dp[i]);\n  cout << o << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int testcase = 1;\n  if (testc) cin >> testcase;\n  while (testcase-- > 0) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\n\npublic class C {\n\tpublic static void main(String[] args)\n    {\n        FastReader s=new FastReader();\n        int t = s.nextInt();         // Number of test cases\n        \n        \n        for (int i = 0; i<t; i++) {\n        \tint n = s.nextInt();\n        \tint[] indegree = new int[n+1];\n        \tList<List<Integer>> list = new ArrayList<>();\n        \t\n        \tfor (int j = 0; j<=n; j++) {                // n+1 elements in graph, 1 to n are important for us.\n        \t\tlist.add(new ArrayList<>());\n        \t}\n        \t\n        \tQueue<Integer> q = new ArrayDeque<>();\n        \tList<Integer> order = new ArrayList<>();\n        \tint[] day = new int[n+1];\n        \tArrays.fill(day, -1);\n        \tfor (int j = 1; j<=n; j++) {\n        \t\tindegree[j] = s.nextInt();\n        \t\tfor (int k = 0; k<indegree[j]; k++) {\n        \t\t\tint parent = s.nextInt();\n            \t\tlist.get(parent).add(j);\n        \t\t}\t\n        \t\tif (indegree[j] == 0) {\n        \t\t\tq.add(j);\n        \t\t\tday[j] = 1;\n        \t\t}\n        \t}\n        \tint index = 0;\n//        \tprintArray(day);\n//        \tSystem.out.print(\"indgree = \");\n//        \tprintArray(indegree);\n//        \tSystem.out.println(list);\n//        \tSystem.out.println(q.size());\n        \t\n        \t\n        \twhile (q.size() > 0) {\n        \t\tint rem = q.remove();\n        \t\torder.add(rem);\n        \t\tindex++;\n        \t\t\n        \t\tfor (int child : list.get(rem)) {\n        \t\t\tif (rem < child) {\n    \t\t\t\t\tday[child] = Math.max(day[rem], day[child]);\n    \t\t\t\t}else {\n    \t\t\t\t\tday[child] = Math.max(day[rem]+1, day[child]);\n    \t\t\t\t}\n        \t\t\t\n        \t\t\t\n        \t\t\tindegree[child] -= 1;\n        \t\t\tif (indegree[child] == 0) {\n        \t\t\t\tq.add(child);\n        \t\t\t\t\n        \t\t\t\t\n        \t\t\t}\n        \t\t}\n        \t}\n        \tif (index != n) {\n        \t\tSystem.out.println(-1);\n        \t}else {\n        \t\tint maxDay = Integer.MIN_VALUE;\n        \t\tfor (int j = 1; j<day.length; j++) {\n            \t\t\n            \t\tmaxDay = Math.max(maxDay, day[j]);\n            \t}\n        \t\tSystem.out.println(maxDay);\n        \t}\n\n        }\n\n        \n\n        \n        \n    }\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    static void printArray(int[] arr) {\n    \tfor (int i = 0; i<arr.length; i++) {\n    \t\tSystem.out.print(arr[i] + \" \");\n    \t}\n    \tSystem.out.println();\n    }\n    \n    static void sort(int[] a) {\n    \tArrayList<Integer> l = new ArrayList<>();\n    \tfor (int i : a) l.add(i);\n    \tCollections.sort(l);\n    \tfor (int i = 0; i<a.length; i++) {\n    \t\ta[i]=l.get(i);\n    \t}\n    }\n    \n    \n    \n    \n    \n\tstatic class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastReader()\n        {\n            br = new BufferedReader(new\n                     InputStreamReader(System.in));\n        }\n \n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n \n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n \n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n \n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int t = 1;\n  cin >> t;\n  long long n, k;\n  long long ip;\n  while (t--) {\n    cin >> n;\n    vector<int> graph[n + 1];\n    vector<int> indegree(n + 1);\n    for (int i = 0; i < n; i++) {\n      cin >> k;\n      indegree[i + 1] = k;\n      for (int j = 0; j < k; j++) {\n        cin >> ip;\n        graph[ip].push_back(i + 1);\n      }\n    }\n    set<int> q1;\n    set<int> q2;\n    for (int i = 1; i <= n; i++) {\n      if (indegree[i] == 0) {\n        q1.insert(i);\n      }\n    }\n    long long x;\n    long long yay = 0;\n    long long cnt = 0;\n    while (!q1.empty() || !q2.empty()) {\n      if (!q1.empty()) cnt++;\n      while (!q1.empty()) {\n        yay++;\n        x = *(q1.begin());\n        q1.erase(q1.begin());\n        for (auto y : graph[x]) {\n          --indegree[y];\n          if (indegree[y] == 0) {\n            if (y > x)\n              q1.insert(y);\n            else {\n              q2.insert(y);\n            }\n          }\n        }\n      }\n      if (!q2.empty()) cnt++;\n      while (!q2.empty()) {\n        yay++;\n        x = *(q2.begin());\n        q2.erase(q2.begin());\n        for (auto y : graph[x]) {\n          --indegree[y];\n          if (indegree[y] == 0) {\n            if (y > x)\n              q2.insert(y);\n            else {\n              q1.insert(y);\n            }\n          }\n        }\n      }\n    }\n    if (yay != n) {\n      cout << -1 << endl;\n    } else {\n      cout << cnt << endl;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class C {\n\n\tstatic HashMap<Integer, ArrayList<Integer>> map;\n\tstatic ArrayList<Integer> ord;\n\tstatic int[] color, parent, dist;\n\tstatic boolean[] visited;\n\tstatic int[] dp;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n\t\tint t = Integer.parseInt(br.readLine());\n\t\t\n\t\twhile(t --> 0) {\n\t\t\t\n\t\t\tint n = Integer.parseInt(br.readLine());\t\t\t\n\t\t\tmap = new HashMap<Integer, ArrayList<Integer>>();\n\t\t\tcolor = new int[n+1];\n\t\t\tparent = new int[n+1];\n\t\t\tdist = new int[n+1];\n\t\t\tvisited = new boolean[n+1];\n\t\t\tdp = new int[n+1];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\t\n\t\t\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\t\t\t\n\t\t\t\tint k = Integer.parseInt(st.nextToken());\n\t\t\t\t\t\t\t\t\n\t\t\t\tfor(int j = 0; j < k; j++) {\n\t\t\t\t\t\n\t\t\t\t\tint u = Integer.parseInt(st.nextToken());\n\t\t\t\t\t\n\t\t\t\t\tif(!map.containsKey(u))\n\t\t\t\t\t\tmap.put(u, new ArrayList<Integer>());\n\t\t\t\t\t\n\t\t\t\t\tmap.get(u).add(i+1);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tboolean hasCyc = false;\n\t\t\t\n\t\t\tfor(int i = 1; i <= n; i++) {\n\t\t\t\t\n\t\t\t\tif(color[i] == 0 && cyc_check(i)) {\n\t\t\t\t\t\n\t\t\t\t\thasCyc = true;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(hasCyc) {\n\t\t\t\t\n\t\t\t\tpw.println(-1);\n\t\t\t\t\n\t\t\t}else {\n\t\t\t\t\t\n\t\t\t\tint maxmin = 0;\n\t\t\t\t\n\t\t\t\tArrays.fill(visited, false);\n\t\t\t\t\n\t\t\t\tfor(int i = 1; i <= n; i++)\n\t\t\t\t\tif(!visited[i])\n\t\t\t\t\t\tdfs(i);\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i <= n; i++)\n\t\t\t\t\tmaxmin = Math.max(maxmin, dp[i]);\n\t\t\t\t\n\t\t\t\tpw.println(maxmin+1);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tpw.flush();\n\t\t\t\n\t\t}\n\t\t\n\t\tpw.close();\n\n\t}\n\t\n\tstatic void dfs(int v) {\n\t\t\n\t\tvisited[v] = true;\n\t\t\n\t\tif(map.containsKey(v)) {\n\t\t\t\n\t\t\tfor(Integer u : map.get(v)) {\n\t\t\t\t\n\t\t\t\tif(!visited[u]) {\n\t\t\t\t\t\n\t\t\t\t\tdfs(u);\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdp[v] = Math.max(dp[v], ((v > u) ? 1 + dp[u] : dp[u]));\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tstatic boolean cyc_check(int v) {\n\t\t\n\t    color[v] = 1;\n\t    \n\t    if(map.containsKey(v)) {\n\t    \t\n\t\t    for (Integer u : map.get(v)) {\n\t\t    \t\n\t\t        if (color[u] == 0) {\n\t\t        \t\n\t\t            parent[u] = v;\n\t\t            \n\t\t            if (cyc_check(u))\n\t\t                return true;\n\t\t            \n\t\t        } else if (color[u] == 1) {\n\t\n\t\t            return true;\n\t\t            \n\t\t        }\n\t\t        \n\t\t    }\n\t\t    \n\t    }\n\t    \n\t    color[v] = 2;\n\t    \n\t    return false;\n\t    \n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2 * 100 * 1000 + 7;\nint od[N], il[N];\nvector<int> ed[N];\nset<int> kol;\nvoid Answer(int n) {\n  int p, v, w;\n  p = n + 1;\n  w = 0;\n  while (kol.size() > 0) {\n    if (kol.upper_bound(p) != kol.end())\n      v = (*kol.upper_bound(p));\n    else\n      v = (*kol.begin());\n    kol.erase(v);\n    od[v] = 1;\n    if (v < p) ++w;\n    for (int i = 0; i < (int)ed[v].size(); ++i) {\n      --il[ed[v][i]];\n      if (il[ed[v][i]] == 0) kol.insert(ed[v][i]);\n    }\n    p = v;\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (od[i] == 0) {\n      cout << -1 << \"\\n\";\n      return;\n    }\n  }\n  cout << w << \"\\n\";\n}\nvoid Solve() {\n  int n, m, v;\n  cin >> n;\n  for (int i = 1; i <= n; ++i) ed[i].clear();\n  for (int i = 1; i <= n; ++i) {\n    od[i] = 0;\n    cin >> m;\n    il[i] = m;\n    if (m == 0) kol.insert(i);\n    for (int j = 1; j <= m; ++j) {\n      cin >> v;\n      ed[v].push_back(i);\n    }\n  }\n  Answer(n);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int t;\n  cin >> t;\n  while (t--) Solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Coder {\n\n  static StringBuffer str=new StringBuffer();\n  static List<List<Integer>> l, rl;\n  static int n;\n  static int ind[];\n  static List<Integer> topo;\n\n  static void topSort(){\n    Queue<Integer> q=new LinkedList<>();\n    boolean vis[]=new boolean[n+1];\n    for(int i=1;i<=n;i++) if(ind[i]==0) q.add(i);\n    topo=new ArrayList<>();\n    while(!q.isEmpty()){\n      int u=q.remove();\n      vis[u]=true;\n      topo.add(u);\n      for(int v:l.get(u)){\n        if(--ind[v]==0){\n          q.add(v);\n        }\n      }\n    }\n  }\n  static void solve(){\n    topSort();\n    if(topo.size()!=n){\n      str.append(\"-1\\n\");\n      return;\n    }\n    int dp[]=new int[n+1];\n    Arrays.fill(dp, 1);\n    int ans=1;\n    for(int i:topo){\n      for(int v:rl.get(i)){\n        if(v<i) dp[i]=Math.max(dp[i], dp[v]);\n        else dp[i]=Math.max(dp[i], dp[v]+1);\n      }\n      ans=Math.max(dp[i], ans);\n    }\n    str.append(ans).append(\"\\n\");\n  }\n  \n  public static void main(String[] args) throws java.lang.Exception {\n    BufferedReader bf;\n    PrintWriter pw;\n    boolean lenv=false;\n    if(lenv){\n      bf = new BufferedReader(\n                          new FileReader(\"input.txt\"));\n      pw=new PrintWriter(new\n            BufferedWriter(new FileWriter(\"output.txt\")));\n    }else{\n      bf = new BufferedReader(new InputStreamReader(System.in));\n      pw = new PrintWriter(new OutputStreamWriter(System.out));\n    }\n\n    int q = Integer.parseInt(bf.readLine().trim());\n    while (q-- > 0) {\n       n=Integer.parseInt(bf.readLine().trim());\n       l=new ArrayList<>();\n       rl=new ArrayList<>();\n       ind=new int[n+1];\n       for(int i=0;i<=n;i++){l.add(new ArrayList<>()); rl.add(new ArrayList<>());}\n       for(int i=1;i<=n;i++){\n        String s[]=bf.readLine().trim().split(\"\\\\s+\");\n        int k=Integer.parseInt(s[0]);\n        for(int j=1;j<=k;j++){\n          int u=Integer.parseInt(s[j]);\n          l.get(u).add(i);\n          ind[i]++;\n          rl.get(i).add(u);\n        }\n       }\n       solve();\n    }\n    pw.print(str);\n    pw.flush();\n    // System.out.print(str);\n  }\n}"
        },
        {
            "language": 4,
            "solution": "//import java.io.IOException;\nimport java.util.*;\nimport java.io.*;\n\npublic class Book {\n    static InputReader inputReader=new InputReader(System.in);\n    static void solve()\n    {\n        int n=inputReader.nextInt();\n        HashMap<Integer,HashSet<Integer>>graph=new HashMap<>();\n        for (int i=0;i<=n;i++)\n        {\n            graph.put(i,new HashSet<>());\n        }\n        int indegree[]=new int[n+1];\n        for (int i=1;i<=n;i++)\n        {\n            int k=inputReader.nextInt();\n            for (int j=0;j<k;j++)\n            {\n                int u=inputReader.nextInt();\n                graph.get(u).add(i);\n                indegree[i]++;\n            }\n        }\n        int dp[]=new int[n+1];\n        Arrays.fill(dp,1);\n        Queue<Integer>queue=new LinkedList<>();\n        for (int i=1;i<=n;i++)\n        {\n            if (indegree[i]==0)\n            {\n                queue.add(i);\n            }\n        }\n        int count=0;\n        while (!queue.isEmpty())\n        {\n            int ele=queue.poll();\n            for (int next:graph.get(ele))\n            {\n                indegree[next]--;\n                if (ele<next)\n                {\n                    dp[next]=Math.max(dp[next],dp[ele]);\n                }\n                else\n                {\n                    dp[next]=Math.max(dp[next],dp[ele]+1);\n                }\n                if (indegree[next]==0)\n                {\n                    queue.add(next);\n                }\n            }\n            count++;\n        }\n        if (count!=n)\n        {\n            out.println(-1);\n        }\n        else\n        {\n            int max=1;\n            for (int ele:dp)\n            {\n                max=Math.max(max,ele);\n            }\n            out.println(max);\n        }\n\n    }\n\n    static PrintWriter out=new PrintWriter((System.out));\n    public static void main(String args[])throws IOException\n    {\n        int t=inputReader.nextInt();\n        while(t-->0)\n        {\n            solve();\n        }\n        out.close();\n    }\n    static class InputReader {\n\n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar, snumChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int snext() {\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) {\n                curChar = 0;\n                try {\n                    snumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = snext();\n            while (isSpaceChar(c))\n                c = snext();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = snext();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = snext();\n            while (isSpaceChar(c))\n                c = snext();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = snext();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public int[] nextIntArray(int n) {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        public String readString() {\n            int c = snext();\n            while (isSpaceChar(c))\n                c = snext();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "\ndef naiveSolve():\n    \n    \n    \n    return\n\n\n\ndef solve():\n    \n    \n    \n    return\n\nfrom types import GeneratorType\ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef main():\n    \n    t=int(input())\n    allans=[]\n    for _ in range(t):\n        n=int(input())\n        req=[None for __ in range(n)]\n        for i in range(n):\n            temp=readIntArr()\n            temp.pop(0)\n            for j in range(len(temp)):\n                temp[j]-=1\n            req[i]=temp\n        \n        # check for cycles in a path (like topological sort)\n        hasCycle=[False]\n        visited=[False]*n\n        path=[False]*n\n        \n        @bootstrap\n        def dfs(book):\n            for nex in req[book]:\n                if hasCycle[0]:\n                    yield None\n                if path[nex]:\n                    hasCycle[0]=True\n                    yield None\n                if visited[nex]==False:\n                    visited[nex]=True\n                    path[nex]=True\n                    yield dfs(nex)\n                    path[nex]=False\n            yield None\n        for i in range(n): # check if a book visits itself\n            if not visited[i]:\n                path[i]=True\n                visited[i]=True\n                dfs(i)\n                path[i]=False\n            \n        if hasCycle[0]:\n            allans.append(-1)\n            continue\n        \n        memo=[-1]*n\n        @bootstrap\n        def dp(book):\n            if memo[book]==-1:\n                ans=1\n                for prev in req[book]:\n                    if prev<book:\n                        ans=max(ans,(yield dp(prev)))\n                    else:\n                        ans=max(ans,1+(yield dp(prev)))\n                memo[book]=ans\n            yield memo[book]\n        ans=0\n        for book in range(n):\n            ans=max(ans,dp(book))\n        allans.append(ans)\n        \n    multiLineArrayPrint(allans)\n    \n    return\n\n\n\n\nimport sys\ninput=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\n# input=lambda: sys.stdin.readline().rstrip(\"\\r\\n\") #FOR READING STRING/TEXT INPUTS.\n\ndef oneLineArrayPrint(arr):\n    print(' '.join([str(x) for x in arr]))\ndef multiLineArrayPrint(arr):\n    print('\\n'.join([str(x) for x in arr]))\ndef multiLineArrayOfArraysPrint(arr):\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\n \ndef readIntArr():\n    return [int(x) for x in input().split()]\n# def readFloatArr():\n#     return [float(x) for x in input().split()]\n \ndef makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])\n    dv=defaultValFactory;da=dimensionArr\n    if len(da)==1:return [dv() for _ in range(da[0])]\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\n \ndef queryInteractive(x):\n    print('{}'.format(x))\n    sys.stdout.flush()\n    return int(input())\n \ndef answerInteractive(ans):\n    print('! {}'.format(ans))\n    sys.stdout.flush()\n \ninf=float('inf')\n# MOD=10**9+7\n# MOD=998244353\n\nfrom math import gcd,floor,ceil\n# from math import floor,ceil # for Python2\n \nfor _abc in range(1):\n    main()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool checked[200005];\nbool dfs(vector<long long int> graph[], long long int node, bool visited[]) {\n  if (visited[node] == true) return false;\n  if (checked[node] == true) return true;\n  visited[node] = true;\n  for (auto i : graph[node]) {\n    if (dfs(graph, i, visited) == false) return false;\n  }\n  checked[node] = true;\n  visited[node] = false;\n  return true;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long int x24e;\n  cin >> x24e;\n  while (x24e--) {\n    long long int n;\n    cin >> n;\n    vector<long long int> graph[n];\n    for (long long int i = 0; i < n; i++) {\n      long long int size;\n      cin >> size;\n      while (size--) {\n        long long int x;\n        cin >> x;\n        x--;\n        graph[x].push_back(i);\n      }\n    }\n    bool visited[n];\n    memset(visited, false, sizeof visited);\n    memset(checked, false, sizeof checked);\n    bool dag = true;\n    for (long long int i = 0; i < n; i++) {\n      if (checked[i] == true) continue;\n      if (dfs(graph, i, visited) == false) {\n        dag = false;\n      }\n    }\n    if (dag == false) {\n      cout << \"-1\\n\";\n      continue;\n    }\n    long long int indeg[n];\n    memset(indeg, 0, sizeof indeg);\n    for (long long int i = 0; i < n; i++) {\n      for (auto j : graph[i]) indeg[j]++;\n    }\n    queue<pair<long long int, long long int>> q;\n    for (long long int i = 0; i < n; i++) {\n      if (indeg[i] == 0) {\n        q.push({i, 1});\n      }\n    }\n    vector<long long int> order(n, 1);\n    long long int maxi = 1;\n    while (!q.empty()) {\n      auto top = q.front();\n      q.pop();\n      maxi = max(maxi, top.second);\n      for (auto i : graph[top.first]) {\n        indeg[i]--;\n        if (i > top.first)\n          order[i] = max(order[i], top.second);\n        else\n          order[i] = max(order[i], top.second + 1);\n        if (indeg[i] == 0) {\n          q.push({i, order[i]});\n        }\n      }\n    }\n    cout << *max_element(order.begin(), order.end()) << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\n \n \npublic class Codeforces {\n\t\n\tstatic int mod=1000000007 ;\n\tstatic List<Integer> adj[];\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t// TODO Auto-generated method stub\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t    FastScanner fs=new FastScanner();\n\t    int t=fs.nextInt();\n\t    for(int time=1;time<=t;time++) {\n\t    \tint n=fs.nextInt();\n\t    \tadj=new ArrayList[n+1];\n\t    \tfor(int i=0;i<=n;i++) adj[i]=new ArrayList<>();\n\t    \tint dp[]=new int[n+1];\n\t    \tint in[]=new int[n+1];\n\t    \tArrays.fill(dp, 1);\n\t    \tint ans=1;\n\t    \tfor(int i=1;i<=n;i++) {\n\t    \t\tint k=fs.nextInt();\n\t    \t\twhile(k-->0) {\n\t    \t\t\tint v=fs.nextInt();\n\t    \t\t\tadj[v].add(i);\n\t    \t\t\tin[i]++;\n\t    \t\t}\n\t    \t}\n\t    \tint cnt=0;\n\t    \tQueue<Integer> q=new ArrayDeque<>();\n\t    \tfor(int i=1;i<=n;i++) {\n\t    \t\tif(in[i]==0) {\n\t    \t\t\tcnt++;\n\t    \t\t\tq.add(i);\n\t    \t\t}\n\t    \t}\n\t    \twhile(!q.isEmpty()) {\n\t    \t\tint cur=q.poll();\n\t    \t\tans=Math.max(ans,dp[cur]);\n\t    \t\tfor(int c:adj[cur]) {\n\t    \t\t\tin[c]--;\n\t    \t\t\tif(c>cur) {\n\t    \t\t\t\tdp[c]=Math.max(dp[c],dp[cur]);\t\n\t    \t\t\t}\n\t    \t\t\telse dp[c]=Math.max(dp[c],dp[cur]+1);\t\n\t    \t\t\tif(in[c]==0) {\n\t    \t\t\t\tq.add(c);\n\t    \t\t\t\tcnt++;\n\t    \t\t\t}\n\t    \t\t}\n\t    \t}\n\t    \tif(cnt!=n) out.println(-1);\n\t    \telse out.println(ans);\n\t    }\n\t    \n\t    \n\t    out.close();\n\t}\n\t\n\tstatic long pow(long a,long b) {\n\t\tif(b<0) return 1;\n\t\tlong res=1;\n\t\twhile(b!=0) {\n\t\t\tif((b&1)!=0) {\n\t\t\t\tres*=a;\n\t\t\t\tres%=mod;\n\t\t\t}\n\t\t\ta*=a;\n\t\t\ta%=mod;\n\t\t\tb=b>>1;\n\t\t}\n\t\treturn res;\n\t}\n\tstatic long gcd(long  a,long  b) {\n\t\tif(b==0) return a;\n\t\treturn gcd(b,a%b);\n\t}\n\tstatic long nck(int n,int k) {\n\t\tif(k>n) return 0;\n\t\tlong res=1;\n\t\tres*=fact(n);\n\t\tres%=mod;\n\t\tres*=modInv(fact(k));\n\t\tres%=mod;\n\t\tres*=modInv(fact(n-k)); \n\t\tres%=mod;\n\t\treturn res;\n\t}\n\tstatic long fact(long n) {\n\t\tlong res=1;\n\t\tfor(int i=2;i<=n;i++) {\n\t\t\tres*=i;\n\t\t\tres%=mod;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tstatic long modInv(long n) {\n\t\treturn pow(n,mod-2);\n\t}\n\t\n\tstatic void sort(int[] a) {\n\t\t//suffle\n\t\tint n=a.length;\n\t\tRandom r=new Random();\n\t\tfor (int i=0; i<a.length; i++) {\n\t\t\tint oi=r.nextInt(n);\n\t\t\tint temp=a[i];\n\t\t\ta[i]=a[oi];\n\t\t\ta[oi]=temp;\n\t\t}\n\t\t\n\t\t//then sort\n\t\tArrays.sort(a);\n\t}\n\t\n\t// Use this to input code since it is faster than a Scanner\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tlong[] lreadArray(int n) {\n\t\t\tlong a[]=new long[n];\n\t\t\tfor(int i=0;i<n;i++) a[i]=nextLong();\n\t\t\treturn a;\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n \n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long oo = 1e18;\nconst long long N = 2e5 + 5;\nlong long a[N], b[N], k[N], n, h[N], ans;\nvector<long long> d[N];\nset<int> g[N];\nvoid bfs(long long first) {\n  queue<int> q;\n  q.push(first);\n  h[first] = 1;\n  while (q.size()) {\n    long long u = q.front();\n    q.pop();\n    ans = max(ans, h[u]);\n    for (int v : d[u]) {\n      g[v].erase(u);\n      h[v] = max(h[v], h[u] + (v < u));\n      if (g[v].size() == 0) q.push(v);\n    }\n  }\n}\nvoid solve() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) d[i].clear(), h[i] = 0, g[i].clear();\n  for (int i = 1; i <= n; i++) {\n    cin >> k[i];\n    for (int j = 1, u; j <= k[i]; j++) {\n      cin >> u;\n      d[u].push_back(i);\n      g[i].insert(u);\n    }\n  }\n  ans = -1;\n  for (int i = 1; i <= n; i++)\n    if (k[i] == 0) bfs(i);\n  for (int i = 1; i <= n; i++)\n    if (g[i].size() > 0) ans = -1;\n  cout << ans << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long t;\n  cin >> t;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n \npublic class Main extends PrintWriter {\n    \n    void solve()  {\n        int t = sc.nextInt();\n        for(int i = 0; i < t; i++) {\n            test_case();\n        }\n    }\n    \n    void test_case() {\n        int n = sc.nextInt();\n        ArrayDeque<Integer>[] adj = new ArrayDeque[n];\n        for(int i = 0; i < n; i++) adj[i] = new ArrayDeque<>();\n        int[] indegree = new int[n];\n        TreeSet<Integer> set = new TreeSet<>();\n        for(int i = 0; i < n; i++) {\n            indegree[i] = sc.nextInt();\n            for(int j = 0; j < indegree[i]; j++) {\n                adj[sc.nextInt()-1].add(i);\n            }\n            if(indegree[i] == 0) set.add(i);\n        }\n        int ans = 0;\n        int total = 0;\n        while(!set.isEmpty()) {\n            ans++;\n            Integer u = -1;\n            while(true) {\n                u = set.higher(u);\n                if(u == null) break;\n                set.remove(u);\n                total++;\n                for(int v : adj[u]) {\n                    indegree[v]--;\n                    if(indegree[v] == 0) {\n                        set.add(v);\n                    }\n                }\n            }\n        }\n        \n        if(total == n) println(ans);\n        else println(-1);\n    }\n    \n//  Main() throws FileNotFoundException { super(new File(\"output.txt\")); }\n//  InputReader sc = new InputReader(new FileInputStream(\"test_input.txt\"));\n  Main() { super(System.out); }\n  InputReader sc = new InputReader(System.in);\n  static class InputReader {\n      InputReader(InputStream in) { this.in = in; } InputStream in;\n      \n      private byte[] buf = new byte[16384];\n      private int    curChar;\n      private int    numChars;\n      \n \n      public int read() {\n          if (numChars == -1)\n              throw new InputMismatchException();\n          if (curChar >= numChars) {\n              curChar = 0;\n              try {\n                  numChars = in.read(buf);\n              } catch (IOException e) {\n                  throw new InputMismatchException();\n              }\n              if (numChars <= 0)\n                  return -1;\n          }\n          return buf[curChar++];\n      }\n /*\n      private String nextLine() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          StringBuilder res = new StringBuilder();\n          do {\n              res.appendCodePoint(c);\n              c = read();\n          } while (!isEndOfLine(c));\n          return res.toString();\n      }*/\n \n      public String nextString() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          StringBuilder res = new StringBuilder();\n          do {\n              res.appendCodePoint(c);\n              c = read();\n          } while (!isSpaceChar(c));\n          return res.toString();\n      }\n \n      public long nextLong() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          int sgn = 1;\n          if (c == '-') {\n              sgn = -1;\n              c = read();\n          }\n          long res = 0;\n          do {\n              if (c < '0' || c > '9')\n                  throw new InputMismatchException();\n              res *= 10;\n              res += c - '0';\n              c = read();\n          } while (!isSpaceChar(c));\n          return res * sgn;\n      }\n \n      public int nextInt() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          int sgn = 1;\n          if (c == '-') {\n              sgn = -1;\n              c = read();\n          }\n          int res = 0;\n          do {\n              if (c < '0' || c > '9')\n                  throw new InputMismatchException();\n              res *= 10;\n              res += c - '0';\n              c = read();\n          } while (!isSpaceChar(c));\n          return res * sgn;\n      }\n \n      private boolean isSpaceChar(int c) {\n          return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n      }\n \n      private boolean isEndOfLine(int c) {\n          return c == '\\n' || c == '\\r' || c == -1;\n      }\n  }\n \n    public static void main(String[] $) {\n        new Thread(null, new Runnable() {\n            public void run() {\n                long start = System.nanoTime();\n                try {Main solution = new Main(); solution.solve(); solution.flush();} \n                catch (Exception e) {e.printStackTrace(); System.exit(1);}\n                System.err.println((System.nanoTime()-start)/1E9);\n            }\n        }, \"1\", 1 << 27).start();\n \n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename A, typename B, typename C>\nstruct triple {\n  A X;\n  B Y;\n  C Z;\n  triple(A a = 0, B b = 0, C c = 0) : X(a), Y(b), Z(c) {}\n};\ntemplate <typename A, typename B, typename C>\ntriple<A, B, C> make_triple(A a = 0, B b = 0, C c = 0) {\n  return triple<A, B, C>(a, b, c);\n}\ntemplate <typename A, typename B, typename C>\nbool operator<(const triple<A, B, C>& a, const triple<A, B, C>& b) {\n  if (a.X != b.X) return a.X < b.X;\n  if (a.Y != b.Y) return a.Y < b.Y;\n  return a.Z < b.Z;\n}\ntemplate <typename T, typename SS>\nostream& operator<<(ostream& ofs, const pair<T, SS>& p) {\n  ofs << \"( \" << p.first << \" , \" << p.second << \" )\";\n  return ofs;\n}\ntemplate <typename T>\nvoid print(T a) {\n  for (auto i : a) cout << i << ' ';\n  cout << '\\n';\n}\ntemplate <typename T>\nT max(T a, T b, T c) {\n  return max(a, max(b, c));\n}\ntemplate <typename T>\nT min(T a, T b, T c) {\n  return min(a, min(b, c));\n}\ntemplate <typename T, typename D>\nD min(T a) {\n  return *min_element(a.begin(), a.end());\n}\ntemplate <typename T, typename D>\nD max(T a) {\n  return *max_element(a.begin(), a.end());\n}\nstruct custom_hash {\n  static uint64_t splitmix64(uint64_t x) {\n    x += 0x9e3779b97f4a7c15;\n    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n    return x ^ (x >> 31);\n  }\n  size_t operator()(uint64_t x) const {\n    static const uint64_t FIXED_RANDOM =\n        chrono::steady_clock::now().time_since_epoch().count();\n    return splitmix64(x + FIXED_RANDOM);\n  }\n};\nvoid solve() {\n  long long n;\n  cin >> n;\n  vector<vector<long long> > g(n);\n  vector<long long> in(n);\n  for (long long i = 0; i < (n); i++) {\n    long long k;\n    cin >> k;\n    for (long long _ = 0; _ < (k); _++) {\n      long long x;\n      cin >> x;\n      x--;\n      g[x].push_back(i);\n      in[i]++;\n    }\n  }\n  vector<long long> usd(n);\n  function<long long(long long)> dfs = [&](long long v) {\n    usd[v] = 1;\n    for (auto to : g[v])\n      if (usd[to] == 1)\n        return 1;\n      else if (!usd[to] && dfs(to))\n        return 1;\n    usd[v] = 2;\n    return 0;\n  };\n  for (long long i = 0; i < (n); i++)\n    if (!usd[i])\n      if (dfs(i)) return void(cout << \"-1\\n\");\n  vector<long long> d(n);\n  queue<long long> q;\n  for (long long i = 0; i < (n); i++)\n    if (!in[i]) q.push(i);\n  while ((long long)(q.size())) {\n    long long v = q.front();\n    q.pop();\n    for (auto to : g[v]) {\n      d[to] = max(d[to], d[v] + (to < v));\n      in[to]--;\n      if (!in[to]) q.push(to);\n    }\n  }\n  cout << 1 + *max_element(d.begin(), d.end()) << '\\n';\n};\nsigned main() {\n  if (0) {\n    freopen(\n        \"\"\n        \".in\",\n        \"r\", stdin);\n    freopen(\n        \"\"\n        \".out\",\n        \"w\", stdout);\n  }\n  srand(time(NULL));\n  cin.tie(0);\n  cout.tie(0);\n  ios_base::sync_with_stdio(false);\n  long long t = 1;\n  cin >> t;\n  for (long long _ = 0; _ < (t); _++) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int t;\n  cin >> t;\n  while (t-- > 0) {\n    int n;\n    cin >> n;\n    vector<int> k(n);\n    vector<vector<int>> g(n);\n    priority_queue<int> q;\n    for (int i = 0; i < n; ++i) {\n      cin >> k[i];\n      for (int u = 0; u < k[i]; ++u) {\n        int j;\n        cin >> j;\n        g[j - 1].push_back(i);\n      }\n      if (k[i] == 0) q.push(-i);\n    }\n    int cnt = 0;\n    vector<int> c;\n    while (!q.empty()) {\n      while (!q.empty()) {\n        int i = -q.top();\n        q.pop();\n        for (int j : g[i])\n          if (--k[j] == 0) {\n            if (j > i)\n              q.push(-j);\n            else\n              c.push_back(j);\n          }\n      }\n      for (int i : c) q.push(-i);\n      c.clear();\n      ++cnt;\n    }\n    for (int v : k)\n      if (v > 0) cnt = -1;\n    cout << cnt << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 2e5 + 5;\nvector<long long> graph[MAX];\nlong long a[MAX];\nlong long in[MAX]{};\nlong long n;\nlong long bfs(queue<long long> q) {\n  bool visited[MAX]{};\n  vector<long long> r;\n  while (q.size()) {\n    long long u = q.front();\n    q.pop();\n    visited[u] = true;\n    r.push_back(u);\n  }\n  for (long long i = 0; i < r.size(); i++) {\n    q.push(r[i]);\n  }\n  while (q.size()) {\n    long long u = q.front();\n    q.pop();\n    for (long long v : graph[u]) {\n      if (in[v]) {\n        in[v]--;\n        if (in[v] == 0) q.push(v);\n      }\n      if (in[v] == 0 && visited[v] == false) {\n        visited[v] = true;\n        r.push_back(v);\n      }\n    }\n  }\n  if (r.size() < n) return -1;\n  vector<long long> dp(n + 1);\n  for (long long i : r) {\n    for (long long v : graph[i]) {\n      if (i > v)\n        dp[v] = max(dp[v], dp[i] + 1);\n      else\n        dp[v] = max(dp[v], dp[i]);\n    }\n  }\n  long long mr = 0;\n  for (long long i : dp) {\n    mr = max(mr, i);\n  }\n  return mr + 1;\n}\nvoid solveB() {\n  cin >> n;\n  for (long long i = 1; i <= n; i++) {\n    graph[i].clear();\n  }\n  for (long long i = 1; i <= n; i++) {\n    long long k;\n    cin >> k;\n    for (long long j = 0, v; j < k; j++) {\n      cin >> v;\n      graph[v].push_back(i);\n    }\n    in[i] = k;\n  }\n  queue<long long> q;\n  for (long long i = 1; i <= n; i++) {\n    if (in[i] == 0) {\n      q.push(i);\n    }\n  }\n  if (q.size() == 0)\n    cout << \"-1\\n\";\n  else\n    cout << bfs(q) << '\\n';\n}\nint32_t main() {\n  long long t = 1;\n  cin >> t;\n  while (t--) {\n    solveB();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\ninline void read(T &res) {\n  T x = 0, f = 1;\n  char ch = getchar();\n  while (ch != EOF && (ch < '0' || ch > '9')) {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch != EOF && ch >= '0' && ch <= '9') {\n    x = (x << 1) + (x << 3) + (ch ^ 48);\n    ch = getchar();\n  }\n  res = x * f;\n}\ntemplate <typename T, typename... Args>\ninline void read(T &t, Args &...a) {\n  read(t), read(a...);\n}\nconst int inf_int = 0x3f3f3f3f;\nconst long long inf_ll = 0x3f3f3f3f3f3f3f, inf_2 = 4e13 + 11;\nconst long long maxn = 2e5 + 11, maxe = 1e7 + 3, mod = 1e9 + 7;\nconst long double eps = 1e-10;\nint n, mx[maxn], ans, vis[maxn], du[maxn];\nvector<vector<pair<int, int>>> e;\ninline int OK() {\n  for (int i = 1; i <= n; i++)\n    if (!vis[i]) return false;\n  return true;\n}\ninline void solve() {\n  read(n), memset((vis), (0), sizeof(vis));\n  e.assign(n + 1, vector<pair<int, int>>());\n  queue<int> q;\n  for (int i = 1, k, x; i <= n; i++) {\n    read(k), mx[i] = 0, du[i] = k;\n    if (!k) q.push(i);\n    while (k--) read(x), e[x].push_back(make_pair(i, (i < x)));\n  }\n  while (q.size()) {\n    int x = q.front();\n    q.pop();\n    vis[x] = 1;\n    for (auto [v, w] : e[x]) {\n      du[v]--, mx[v] = max(mx[v], mx[x] + w);\n      if (!du[v]) q.push(v);\n    }\n  }\n  if (!OK()) {\n    puts(\"-1\");\n  } else {\n    printf(\"%d\\n\", *max_element(mx + 1, mx + 1 + n) + 1);\n  }\n}\nint main() {\n  int TEST = 1;\n  read(TEST);\n  while (TEST--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int t = 1;\n  cin >> t;\n  long long n, k;\n  long long ip;\n  while (t--) {\n    cin >> n;\n    vector<int> graph[n + 1];\n    vector<int> indegree(n + 1);\n    for (int i = 0; i < n; i++) {\n      cin >> k;\n      indegree[i + 1] = k;\n      for (int j = 0; j < k; j++) {\n        cin >> ip;\n        graph[ip].push_back(i + 1);\n      }\n    }\n    set<int> q1;\n    set<int> q2;\n    for (int i = 1; i <= n; i++) {\n      if (indegree[i] == 0) {\n        q1.insert(i);\n      }\n    }\n    long long x;\n    long long yay = 0;\n    long long cnt = 1;\n    while (!q1.empty()) {\n      yay++;\n      x = *(q1.begin());\n      q1.erase(q1.begin());\n      for (auto y : graph[x]) {\n        --indegree[y];\n        if (indegree[y] == 0) {\n          if (y > x)\n            q1.insert(y);\n          else {\n            q2.insert(y);\n          }\n        }\n      }\n      if (q1.empty()) {\n        q1 = q2;\n        q2.clear();\n        if (!q1.empty()) cnt++;\n      }\n    }\n    if (yay != n) {\n      cout << -1 << endl;\n    } else {\n      cout << cnt << endl;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e6;\nvector<int> v[maxn];\nint ind[maxn];\nint f[maxn];\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n      v[i].clear();\n      ind[i] = f[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n      int k;\n      cin >> k;\n      for (int j = 1; j <= k; j++) {\n        int x;\n        cin >> x;\n        ind[i]++;\n        v[x].push_back(i);\n      }\n    }\n    queue<int> q;\n    for (int i = 1; i <= n; i++) {\n      if (!ind[i]) {\n        q.push(i);\n        f[i] = 1;\n      }\n    }\n    while (!q.empty()) {\n      int x = q.front();\n      q.pop();\n      for (int i = 0; i < v[x].size(); i++) {\n        int y = v[x][i];\n        ind[y]--;\n        if (y < x) {\n          f[y] = max(f[y], f[x] + 1);\n        } else {\n          f[y] = max(f[y], f[x]);\n        }\n        if (!ind[y]) {\n          q.push(y);\n        }\n      }\n    }\n    int ma = 0, fl = 0;\n    for (int i = 1; i <= n; i++) {\n      if (ind[i]) {\n        fl = 1;\n      }\n      ma = max(ma, f[i]);\n    }\n    if (fl) {\n      cout << -1 << \"\\n\";\n    } else {\n      cout << ma << \"\\n\";\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1000000000;\nlong long mod = 1000000007LL;\nlong long mod2 = 998244353LL;\nint t, n;\nvector<int> edges[200005];\nint deg[200005];\nint dp[200005];\nint main() {\n  cin >> t;\n  for (int cas = 1; cas <= t; ++cas) {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; ++i) {\n      deg[i] = 0;\n      edges[i].clear();\n      dp[i] = 1;\n    }\n    for (int i = 1; i <= n; ++i) {\n      int k;\n      scanf(\"%d\", &k);\n      for (int j = 1; j <= k; ++j) {\n        int u;\n        scanf(\"%d\", &u);\n        edges[u].push_back(i);\n        deg[i]++;\n      }\n    }\n    queue<int> q;\n    for (int i = 1; i <= n; ++i) {\n      if (deg[i] == 0) {\n        q.push(i);\n        dp[i] = 1;\n      }\n    }\n    int cnt = 0;\n    while (!q.empty()) {\n      auto cur = q.front();\n      q.pop();\n      cnt++;\n      for (int i = 0; i < edges[cur].size(); ++i) {\n        int v = edges[cur][i];\n        if (cur > v) {\n          dp[v] = max(dp[v], dp[cur] + 1);\n        } else {\n          dp[v] = max(dp[v], dp[cur]);\n        }\n        deg[v]--;\n        if (deg[v] == 0) {\n          q.push(v);\n        }\n      }\n    }\n    if (cnt < n) {\n      puts(\"-1\");\n    } else {\n      int ans = 1;\n      for (int i = 1; i <= n; ++i) {\n        ans = max(ans, dp[i]);\n      }\n      printf(\"%d\\n\", ans);\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N1 = 1e9 + 7, N2 = 998244353;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0), cout.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n, ans, cnt = 0;\n    cin >> n;\n    int k[n + 1];\n    vector<vector<int>> a(n + 1);\n    for (int i = 1; i <= n; i++) {\n      cin >> k[i];\n      for (int j = 0; j < k[i]; j++) {\n        int v;\n        cin >> v;\n        a[v].push_back(i);\n      }\n    }\n    priority_queue<pair<int, int>, vector<pair<int, int>>,\n                   greater<pair<int, int>>>\n        pq;\n    for (int i = 1; i <= n; i++) {\n      if (k[i] == 0) pq.push({1, i});\n    }\n    while (!pq.empty()) {\n      cnt++;\n      pair<int, int> now = pq.top();\n      pq.pop();\n      for (int j = 0; j < a[now.second].size(); j++) {\n        k[a[now.second][j]]--;\n        if (k[a[now.second][j]] == 0)\n          pq.push(\n              {(now.second > a[now.second][j]) + now.first, a[now.second][j]});\n      }\n      ans = now.first;\n    }\n    cout << (cnt == n ? ans : -1) << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict as dd, deque\ndef check_cycle(g, indegree, n):\n    c = 0\n    d = deque([])\n    ans = dd(lambda :1)\n    for i in range(n):\n        if indegree[i + 1] == 0:\n            d.append(i + 1)\n    #print(d)\n    while d:\n        u = d.popleft()\n        c += 1\n        for v in g[u]:\n            indegree[v] -= 1\n            if v < u:\n                ans[v] = max(ans[v], ans[u] + 1)\n            else:\n                ans[v] = max(ans[v], ans[u])\n            if indegree[v] == 0:\n                d.append(v)\n    if c != n:\n        return False\n    if ans:\n        return max(ans.values())\n    return 1\n\n\nfor _ in range(int(input())):\n    n = int(input())\n    g = dd(set)\n    indegree = dd(int)\n    for i in range(n):\n        a = list(map(int, input().split()))\n        for j in range(1, a[0] + 1):indegree[i + 1] += 1;g[a[j]].add(i + 1)\n    res = check_cycle(g, indegree, n);print(-1) if not res else print(res)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n  vector<long long> xg, xy;\n  long long sz, bh;\n} s[200005], p[200005];\nbool cmp(node x, node y) {\n  if (x.sz != y.sz)\n    return x.sz < y.sz;\n  else\n    return x.bh < y.bh;\n}\nbool cmp2(long long x, long long y) { return s[x].bh < s[y].bh; }\npriority_queue<long long, vector<long long>, greater<long long> > cc, xg, dqdq;\nint main() {\n  long long t, n, i, j, k, zc, sy, sg, zczc, slsl;\n  scanf(\"%lld\", &t);\n  while (t--) {\n    scanf(\"%lld\", &n), sy = n;\n    for (i = 1; i <= n; i++) {\n      s[i].xg.clear();\n      s[i].bh = i, s[i].sz = 0;\n    }\n    for (i = 1; i <= n; i++) {\n      scanf(\"%lld\", &k);\n      for (j = 1; j <= k; j++) {\n        scanf(\"%lld\", &zc);\n        s[zc].xg.push_back(i);\n        s[i].sz++;\n      }\n    }\n    for (i = 1; i <= n; i++) {\n      p[i].xg = s[i].xg;\n      p[i].sz = s[i].sz;\n      p[i].bh = i;\n    }\n    while (cc.size() > 0) cc.pop();\n    while (xg.size() > 0) xg.pop();\n    sort(p + 1, p + 1 + n, cmp);\n    for (i = 1; i <= n; i++) {\n      if (p[i].sz == 0)\n        cc.push(p[i].bh);\n      else\n        break;\n    }\n    slsl = 0;\n    while (cc.size() > 0) {\n      zczc = cc.top();\n      cc.pop();\n      sy--;\n      if (s[zczc].xg.size() > 0) {\n        for (i = 0; i <= s[zczc].xg.size() - 1; i++) {\n          s[s[zczc].xg[i]].sz--;\n          if (s[s[zczc].xg[i]].sz == 0) {\n            if (s[zczc].xg[i] > zczc)\n              cc.push(s[zczc].xg[i]);\n            else\n              xg.push(s[zczc].xg[i]);\n          }\n        }\n      }\n      if (cc.size() == 0) {\n        slsl++;\n        while (xg.size() > 0) {\n          zczc = xg.top();\n          xg.pop();\n          cc.push(zczc);\n        }\n      }\n    }\n    if (sy == 0)\n      printf(\"%lld\\n\", slsl);\n    else\n      printf(\"-1\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict, deque, Counter\nfrom heapq import heapify, heappop, heappush\nimport math\nfrom copy import deepcopy\nfrom itertools import combinations, permutations, product, combinations_with_replacement\nfrom bisect import bisect_left, bisect_right\n\nimport sys\ndef input():\n    return sys.stdin.readline().rstrip()\ndef getN():\n    return int(input())\ndef getNM():\n    return map(int, input().split())\ndef getList():\n    return list(map(int, input().split()))\ndef getListGraph():\n    return list(map(lambda x:int(x) - 1, input().split()))\ndef getArray(intn):\n    return [int(input()) for i in range(intn)]\n\nmod = 10 ** 9 + 7\nMOD = 998244353\n# sys.setrecursionlimit(1000000)\ninf = float('inf')\neps = 10 ** (-10)\ndy = [0, 1, 0, -1]\ndx = [1, 0, -1, 0]\n\n#############\n# Main Code #\n#############\n\nT = getN()\nfor _ in range(T):\n    N = getN()\n    E = [[] for i in range(N)]\n    cnt = [0] * N\n\n    for v in range(N):\n        k = getList()\n        cnt[v] = k[0]\n        for u in k[1:]:\n            E[u - 1].append(v)\n\n    prev = [i for i in range(N) if cnt[i] == 0]\n    heapify(prev)\n\n    ans, ignore = 0, 0\n    while prev:\n        next = []\n        ans += 1\n        while prev:\n            u = heappop(prev)\n            ignore += 1\n            for v in E[u]:\n                cnt[v] -= 1\n                if cnt[v] == 0:\n                    # \u63a2\u7d22\u3057\u305f\u306e\u3088\u308a\u524d\u306b\u3042\u308c\u3070\u6b21\u56de\n                    if v < u:\n                        heappush(next, v)\n                    else:\n                        heappush(prev, v)\n\n        prev = next\n\n    if ignore == N:\n        print(ans)\n    else:\n        print(-1)"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\n\npublic final class Main {\n\n    static PrintWriter out = new PrintWriter(System.out);\n    static FastReader in = new FastReader();\n    static Pair[] moves = new Pair[]{new Pair(-1, 0), new Pair(1, 0), new Pair(0, -1), new Pair(0, 1)};\n    static int mod = (int) (1e9 + 7);\n\n    public static void main(String[] args) {\n        int tt = i();\n        while (tt-- > 0) {\n            solve();\n        }\n        out.flush();\n    }\n\n    public static void solve() {\n        int n = i();\n\n        int[] deg = new int[n];\n        List<Integer>[] edges = new List[n];\n        for (int i = 0; i < n; i++) {\n            edges[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < n; i++) {\n            int m = i();\n            for (int j = 0; j < m; j++) {\n                int u = i() - 1;\n                edges[u].add(i);\n                deg[i]++;\n            }\n        }\n\n        PriorityQueue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>() {\n            @Override\n            public int compare(int[] o1, int[] o2) {\n                return o1[0] - o2[0];\n            }\n        }.thenComparing(new Comparator<int[]>() {\n            @Override\n            public int compare(int[] o1, int[] o2) {\n                return o1[1] - o2[1];\n            }\n        }));\n        for (int i = 0; i < n; i++) {\n            if (deg[i] == 0) {\n                pq.offer(new int[]{1, i});\n            }\n        }\n\n        int cnt = 0;\n        int max = 1;\n        while (pq.size() > 0) {\n            int[] cur = pq.poll();\n            cnt++;\n            max = Math.max(max, cur[0]);\n\n            for (int v : edges[cur[1]]) {\n                deg[v]--;\n                if (deg[v] == 0) {\n                    if (v > cur[1]) {\n                        pq.offer(new int[]{cur[0], v});\n                    } else {\n                        pq.offer(new int[]{cur[0] + 1, v});\n                    }\n                }\n            }\n        }\n\n        if (cnt < n) {\n            out.println(-1);\n        } else {\n            out.println(max);\n        }\n\n    }\n\n    static long[] pre(int[] a) {\n        long[] pre = new long[a.length + 1];\n        pre[0] = 0;\n        for (int i = 0; i < a.length; i++) {\n            pre[i + 1] = pre[i] + a[i];\n        }\n        return pre;\n    }\n\n    static void print(char A[]) {\n        for (char c : A) {\n            out.print(c);\n        }\n        out.println();\n    }\n\n    static void print(boolean A[]) {\n        for (boolean c : A) {\n            out.print(c + \" \");\n        }\n        out.println();\n    }\n\n    static void print(int A[]) {\n        for (int c : A) {\n            out.print(c + \" \");\n        }\n        out.println();\n    }\n\n    static void print(long A[]) {\n        for (long i : A) {\n            out.print(i + \" \");\n        }\n        out.println();\n    }\n\n    static void print(List<Integer> A) {\n        for (int a : A) {\n            out.print(a + \" \");\n        }\n    }\n\n    static int i() {\n        return in.nextInt();\n    }\n\n    static long l() {\n        return in.nextLong();\n    }\n\n    static String s() {\n        return in.nextLine();\n    }\n\n    static int[][] inputWithIdx(int N) {\n        int A[][] = new int[N][2];\n        for (int i = 0; i < N; i++) {\n            A[i] = new int[]{i, in.nextInt()};\n        }\n        return A;\n    }\n\n    static int[] input(int N) {\n        int A[] = new int[N];\n        for (int i = 0; i < N; i++) {\n            A[i] = in.nextInt();\n        }\n        return A;\n    }\n\n    static long[] inputLong(int N) {\n        long A[] = new long[N];\n        for (int i = 0; i < A.length; i++) {\n            A[i] = in.nextLong();\n        }\n        return A;\n    }\n\n    static int GCD(int a, int b) {\n        if (b == 0) {\n            return a;\n        } else {\n            return GCD(b, a % b);\n        }\n    }\n\n    static long GCD(long a, long b) {\n        if (b == 0) {\n            return a;\n        } else {\n            return GCD(b, a % b);\n        }\n    }\n\n    static long LCM(int a, int b) {\n        return (long) a / GCD(a, b) * b;\n    }\n\n    static long LCM(long a, long b) {\n        return a / GCD(a, b) * b;\n    }\n\n    static void shuffleAndSort(int[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            int rand = (int) (Math.random() * arr.length);\n            int temp = arr[rand];\n            arr[rand] = arr[i];\n            arr[i] = temp;\n        }\n        Arrays.sort(arr);\n    }\n\n    static void shuffleAndSort(int[][] arr, Comparator<? super int[]> comparator) {\n        for (int i = 0; i < arr.length; i++) {\n            int rand = (int) (Math.random() * arr.length);\n            int[] temp = arr[rand];\n            arr[rand] = arr[i];\n            arr[i] = temp;\n        }\n        Arrays.sort(arr, comparator);\n    }\n\n    static void shuffleAndSort(long[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            int rand = (int) (Math.random() * arr.length);\n            long temp = arr[rand];\n            arr[rand] = arr[i];\n            arr[i] = temp;\n        }\n        Arrays.sort(arr);\n    }\n\n    static boolean isPerfectSquare(double number) {\n        double sqrt = Math.sqrt(number);\n        return ((sqrt - Math.floor(sqrt)) == 0);\n    }\n\n    static void swap(int A[], int a, int b) {\n        int t = A[a];\n        A[a] = A[b];\n        A[b] = t;\n    }\n\n    static long pow(long a, long b, int mod) {\n        long pow = 1;\n        long x = a;\n        while (b != 0) {\n            if ((b & 1) != 0) {\n                pow = (pow * x) % mod;\n            }\n            x = (x * x) % mod;\n            b /= 2;\n        }\n        return pow;\n    }\n\n    static long pow(long a, long b) {\n        long pow = 1;\n        long x = a;\n        while (b != 0) {\n            if ((b & 1) != 0) {\n                pow *= x;\n            }\n            x = x * x;\n            b /= 2;\n        }\n        return pow;\n    }\n\n    static long modInverse(long x, int mod) {\n        return pow(x, mod - 2, mod);\n    }\n\n    static boolean isPrime(long N) {\n        if (N <= 1) {\n            return false;\n        }\n        if (N <= 3) {\n            return true;\n        }\n        if (N % 2 == 0 || N % 3 == 0) {\n            return false;\n        }\n        for (int i = 5; i * i <= N; i = i + 6) {\n            if (N % i == 0 || N % (i + 2) == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static String reverse(String str) {\n        if (str == null) {\n            return null;\n        }\n        return new StringBuilder(str).reverse().toString();\n    }\n\n    public static String repeat(char ch, int repeat) {\n        if (repeat <= 0) {\n            return \"\";\n        }\n        final char[] buf = new char[repeat];\n        for (int i = repeat - 1; i >= 0; i--) {\n            buf[i] = ch;\n        }\n        return new String(buf);\n    }\n\n    public static int[] manacher(String s) {\n        char[] chars = s.toCharArray();\n        int n = s.length();\n        int[] d1 = new int[n];\n        for (int i = 0, l = 0, r = -1; i < n; i++) {\n            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);\n            while (0 <= i - k && i + k < n && chars[i - k] == chars[i + k]) {\n                k++;\n            }\n            d1[i] = k--;\n            if (i + k > r) {\n                l = i - k;\n                r = i + k;\n            }\n        }\n        return d1;\n    }\n\n    public static int[] kmp(String s) {\n        int n = s.length();\n        int[] res = new int[n];\n        for (int i = 1; i < n; ++i) {\n            int j = res[i - 1];\n            while (j > 0 && s.charAt(i) != s.charAt(j)) {\n                j = res[j - 1];\n            }\n            if (s.charAt(i) == s.charAt(j)) {\n                ++j;\n            }\n            res[i] = j;\n        }\n        return res;\n    }\n}\n\nclass Pair {\n\n    int i, j;\n\n    Pair(int i, int j) {\n        this.i = i;\n        this.j = j;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        Pair pair = (Pair) o;\n        return i == pair.i && j == pair.j;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(i, j);\n    }\n}\n\nclass FastReader {\n\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastReader() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    String next() {\n        while (st == null || !st.hasMoreElements()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    String nextLine() {\n        String str = \"\";\n        try {\n            str = br.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return str;\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid dfs(vector<vector<int>> &g, vector<int> &vis, stack<int> &st, int u,\n         int &flag) {\n  vis[u] = 1;\n  for (auto v : g[u]) {\n    if (vis[v] == 0) {\n      dfs(g, vis, st, v, flag);\n    } else if (vis[v] == 1) {\n      flag = 1;\n    }\n  }\n  st.push(u);\n  vis[u] = 2;\n}\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int flag = 0;\n    int n;\n    cin >> n;\n    vector<vector<int>> g(n);\n    vector<vector<int>> list(n);\n    for (int i = 0; i < n; i++) {\n      int k;\n      cin >> k;\n      for (int j = 0; j < k; j++) {\n        int temp;\n        cin >> temp;\n        list[i].push_back(temp - 1);\n        g[temp - 1].push_back(i);\n      }\n    }\n    vector<int> vis(n, 0);\n    stack<int> st;\n    for (int i = 0; i < n; i++) {\n      if (vis[i] == 0) dfs(g, vis, st, i, flag);\n    }\n    if (flag == 1) {\n      cout << -1 << endl;\n      continue;\n    }\n    vector<int> dp(n, 0);\n    while (!st.empty()) {\n      int top = st.top();\n      st.pop();\n      dp[top] = 1;\n      for (auto node : list[top]) {\n        if (node > top)\n          dp[top] = max(dp[top], dp[node] + 1);\n        else\n          dp[top] = max(dp[top], dp[node]);\n      }\n    }\n    cout << *max_element(dp.begin(), dp.end()) << endl;\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nimport math\nimport heapq\nimport bisect\nfrom collections import Counter\nfrom collections import defaultdict\nfrom io import BytesIO, IOBase\nfrom itertools import permutations\nimport string\nfrom types import GeneratorType\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        import os\n        self.os = os\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n        self.BUFSIZE = 8192\n\n    def read(self):\n        while True:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, self.BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, self.BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            self.os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\ndef get_int():\n    return int(input())\n\n\ndef get_ints():\n    return list(map(int, input().split(' ')))\n\n\ndef get_int_grid(n):\n    return [get_ints() for _ in range(n)]\n\n\ndef get_str():\n    return input().strip()\n\n\ndef get_strs():\n    return get_str().split(' ')\n\n\ndef flat_list(arr):\n    return [item for subarr in arr for item in subarr]\n\n\ndef yes_no(b):\n    if b:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n\ndef binary_search(good, left, right, delta=1, right_true=False):\n    \"\"\"\n    Performs binary search\n    ----------\n    Parameters\n    ----------\n    :param good: Function used to perform the binary search\n    :param left: Starting value of left limit\n    :param right: Starting value of the right limit\n    :param delta: Margin of error, defaults value of 1 for integer binary search\n    :param right_true: Boolean, for whether the right limit is the true invariant\n    :return: Returns the most extremal value interval [left, right] which is good function evaluates to True,\n            alternatively returns False if no such value found\n    \"\"\"\n\n    limits = [left, right]\n    while limits[1] - limits[0] > delta:\n        if delta == 1:\n            mid = sum(limits) // 2\n        else:\n            mid = sum(limits) / 2\n        if good(mid):\n            limits[int(right_true)] = mid\n        else:\n            limits[int(~right_true)] = mid\n    if good(limits[int(right_true)]):\n        return limits[int(right_true)]\n    else:\n        return False\n\n\ndef prefix_sums(a):\n    p = [0]\n    for x in a:\n        p.append(p[-1] + x)\n    return p\n\n\ndef solve_a():\n    n = get_int()\n    s = get_str()\n    cnt = 0\n    for i, x in enumerate(s):\n\n        if int(s[i]) > 0:\n            cnt += int(i < n - 1) + int(s[i])\n    return cnt\n\n\ndef solve_b():\n    n = get_int()\n    a = get_ints()\n    b = get_ints()\n\n    pma = [a[0]]\n    pmb = [b[0]]\n    for i in range(1, n):\n        pma.append(min(pma[-1], a[i]))\n        pmb.append(min(pmb[-1], b[i]))\n\n    l = -1\n    r = 2 * n\n\n    while r - l > 1:\n        m = (l + r) // 2\n\n        f = False\n        for i in range(m + 1):\n            if pma[i] < pmb[m - i]:\n                r = m\n                f = True\n                break\n        if not f:\n            l = m\n\n    return r\n\n\n\ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\n\ndef solve_c():\n    n = get_int()\n    out = defaultdict(list)\n    ins = defaultdict(list)\n    for i in range(n):\n        k, *a = get_ints()\n        for x in a:\n            out[x - 1].append(i)\n            ins[i].append(x - 1)\n\n    vis = [0] * n\n    topsort = []\n    topo = [0] * n\n    cycle = [False]\n    @bootstrap\n    def dfs(v):\n        vis[v] = True\n        for u in out[v]:\n            if not vis[u]:\n                yield dfs(u)\n            elif not topo[u]:\n                cycle[0] = True\n        topsort.append(v)\n        topo[v] = 1\n        yield\n\n    for i in range(n):\n        if not vis[i]:\n            dfs(i)\n\n    if cycle[0]:\n        return -1\n\n    dist = [1] * n\n    topsort = topsort[::-1]\n    for v in topsort:\n        for u in out[v]:\n            dist[u] = max(dist[u], dist[v] + int(u < v))\n\n\n    return max(dist)\n\n\n\n\n\n\n    topsort = topsort[::-1]\n    print(topsort)\n\n\n\n\n\n\nt = get_int()\nfor _ in range(t):\n    print(solve_c())\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\nlong long max(long long a, long long b) {\n  if (a > b)\n    return a;\n  else\n    return b;\n}\nlong long min(long long a, long long b) {\n  if (a > b)\n    return b;\n  else\n    return a;\n}\nlong long gcd(long long a, long long b) { return (b == 0) ? a : gcd(b, a % b); }\ninline long long lcm(long long a, long long b) { return a / gcd(a, b) * b; }\ninline long long normalize(long long x, long long mod) {\n  x %= mod;\n  if (x < 0) x += mod;\n  return x;\n}\nlong long dx[4] = {0, 1, 0, -1};\nlong long dy[4] = {1, 0, -1, 0};\nstring abc = \"abcdefghijklmnopqrstuvwxyz\";\nconst double PI = acosl(-1);\nconst long long mod = 1000 * 1000 * 1000 + 7;\nconst long long inf = 1e18 + 5;\ninline long long add(long long a, long long b, long long p = mod) {\n  long long c = a + b;\n  if (c >= p) c -= p;\n  return c;\n}\ninline long long sub(long long a, long long b, long long p = mod) {\n  long long c = a - b;\n  if (c < 0) c += p;\n  return c;\n}\ninline long long mul(long long a, long long b, long long p = mod) {\n  return (a * 1LL * b) % p;\n}\nlong long floor1(long long n, long long k) {\n  if (n % k == 0 || n >= 0) return n / k;\n  return (n / k) - 1;\n}\nlong long ceil1(long long n, long long k) { return floor1(n + k - 1, k); }\nlong long powm(long long a, long long b) {\n  long long res = 1;\n  while (b) {\n    if (b & 1) res = (res * a) % mod;\n    a = (a * a) % mod;\n    b >>= 1;\n  }\n  return res;\n}\nconst long long N = 2e5 + 5;\nlong long n, m;\nvector<long long> g[N];\nvector<long long> topo;\nlong long ans = 0;\nbool toposort(long long n) {\n  topo.clear();\n  queue<pair<long long, long long>> q;\n  vector<long long> indeg(n + 1, 0);\n  vector<long long> dp(n + 1, 0);\n  for (long long i = 1; i <= n; i++)\n    for (auto &it : g[i]) indeg[it]++;\n  for (long long i = 1; i <= n; i++) {\n    if (!indeg[i]) q.push({i, 1});\n  }\n  while (!q.empty()) {\n    pair<long long, long long> x = q.front();\n    long long u = x.first;\n    long long lvl = x.second;\n    ans = max(ans, lvl);\n    q.pop();\n    topo.push_back(u);\n    for (auto &v : g[u]) {\n      if (v > u) {\n        dp[v] = max(dp[v], lvl);\n      } else {\n        dp[v] = max(dp[v], lvl + 1);\n      }\n      indeg[v]--;\n      if (!indeg[v]) q.push({v, dp[v]});\n    }\n  }\n  return (topo.size() == n);\n}\nvoid solve() {\n  cin >> n;\n  for (long long i = (1); i < (n + 1); ++i) g[i].clear();\n  for (long long i = (1); i < (n + 1); ++i) {\n    long long k;\n    cin >> k;\n    for (long long j = (0); j < (k); ++j) {\n      long long u;\n      cin >> u;\n      g[u].push_back(i);\n    }\n  }\n  ans = 0;\n  if (toposort(n)) {\n    cout << ans << \"\\n\";\n  } else\n    cout << -1 << \"\\n\";\n}\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cout << fixed << setprecision(10);\n  long long t = 1;\n  cin >> t;\n  for (long long i = (1); i < (t + 1); ++i) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class C {\n    public static void main(String[] args) {\n        int t = IO.scanner.nextInt();\n        for (int i = 0; i < t; i++) {\n            try {\n                new SolC().solve();\n            } catch (Exception e) {\n                IO.writer.println(-1);\n            }\n        }\n        IO.writer.close();\n    }\n}\n\nclass InputC extends IO {\n    int n;\n    List<int[]> e;\n\n    public InputC() {\n        n = scanner.nextInt();\n        e = new ArrayList<>();\n\n        for (int i = 0; i < n; i++) {\n            int k = scanner.nextInt();\n            int edge[] = new int[k];\n            \n            for (int j = 0; j < k; j++)\n                edge[j] = scanner.nextInt()-1;\n            e.add(edge);\n        }\n    }\n}\n\nclass SolC extends InputC {\n    boolean visited[];\n    boolean computed[];\n    Integer passes[];\n\n    public SolC() {\n        super();\n        passes = new Integer[n];\n        visited = new boolean[n];\n        computed = new boolean[n];\n    }\n\n    void solve() {\n        for (int i = 0; i < n; i++)\n            dfs(i);\n        writer.println(Collections.max(Arrays.asList(passes)));\n    }\n\n    void dfs(int u) {\n        if (visited[u]) {\n            if (!computed[u])\n                throw new RuntimeException();\n            return;\n        }\n        visited[u] = true;\n\n        int[] ed = e.get(u);\n        passes[u] = 1;\n        \n        for (int i = 0; i < ed.length; i++) {\n            int v = ed[i];\n            dfs(v);\n            \n            if (v > u)\n                passes[u] = Integer.max(passes[u], passes[v]+1);\n            else\n                passes[u] = Integer.max(passes[u], passes[v]);\n        }\n        computed[u] = true;\n    }\n}\n\nclass IO {\n    public static final Scanner scanner = new Scanner(System.in);\n    public static final PrintWriter writer = new PrintWriter(System.out);\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader; \nimport java.io.IOException; \nimport java.io.InputStreamReader; \nimport java.util.Scanner; \nimport java.util.StringTokenizer;\nimport java.util.*;\npublic class codeforcesA{\n   static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n         \n   } \n}\n  public static void main(String args[]){\n     FastReader sc=new FastReader();\n     int t=sc.nextInt();\n     StringBuilder sb=new StringBuilder();\n     while(t-->0){\n       int n=sc.nextInt();\n       List<Set<Integer>> list_set=new ArrayList<>();\n       Set<Integer> set=new HashSet<>();\n       List<List<Integer>> list=new ArrayList<>();\n       for(int i=0;i<n;i++){list.add(new ArrayList<>());list_set.add(new HashSet<>());}\n       PriorityQueue<Integer> pq=new PriorityQueue<>();\n       for(int i=0;i<n;i++){\n         int k=sc.nextInt();\n         if(k==0){pq.add(i);set.add(i);}\n         for(int j=0;j<k;j++){\n             int a=sc.nextInt()-1;\n             list_set.get(i).add(a);\n             list.get(a).add(i);\n            }\n        }\n        int ans=0;\n       while(!pq.isEmpty()){\n           ans++;\n           PriorityQueue<Integer> pq_=new PriorityQueue<>();\n        while(!pq.isEmpty()){\n           int a=pq.poll();\n           for(int w:list.get(a)){\n              list_set.get(w).remove(a);\n              if(list_set.get(w).isEmpty()){\n                  if(w<a){set.add(w);pq_.add(w);}else{set.add(w);pq.add(w);}\n                }\n            }\n        }\n        pq=pq_;\n      }\n      \n      if(set.size()!=n){System.out.println(\"-1\");}\n      else{System.out.println(ans);}\n     } \n     System.out.println(sb.toString());\n    }\n}"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.PriorityQueue;\n\nimport java.io.DataInputStream;\nimport java.io.FileInputStream;\n\nimport java.io.IOException;\n\npublic class cfContest1573 {\n\n    public static void main(String args[]) throws IOException {\n        Reader scan = new Reader();\n\n        int t = scan.nextInt();\n        k:\n        while (t-- > 0) {\n            int n = scan.nextInt();\n            Graph g = new Graph(n - 1);\n            for (int i = 0; i < n; i++) {\n                int m = scan.nextInt();\n                for (int j = 0; j < m; j++) {\n                    g.addEdge(scan.nextInt() - 1, i);\n                }\n\n            }\n            HashSet<Integer> a = new HashSet<Integer>();\n            for (int i = 0; i < n; i++) {\n                a.add(i);\n            }\n            int res = 0;\n            g.make();\n            while (a.size() != 0) {\n                int p = a.size();\n                ++res;\n\n                g.TopologicalSort(a);\n                if (p == a.size()) {\n                    System.out.println(\"-1\");\n                    continue k;\n                }\n            }\n            System.out.println(res);\n\n        }\n    }\n\n}\n\nclass Graph {\n\n    ArrayList<Integer>[] node;\n    int size;\n    int[] totalIn;\n\n    Graph(int n) {\n        size = n + 1;\n        totalIn = new int[size];\n        node = new ArrayList[size];\n        for (int i = 0; i < size; i++) {\n            node[i] = new ArrayList<Integer>();\n        }\n    }\n\n    void addEdge(int v, int u) {\n        node[v].add(u);\n        totalIn[u]++;\n    }\n    static PriorityQueue<Integer> q = new PriorityQueue<Integer>();\n\n    void make() {\n        for (int i = 0; i < size; i++) {\n            if (totalIn[i] == 0) {\n                q.add(i);\n            }\n        }\n    }\n\n    void TopologicalSort(HashSet<Integer> h) {\n        PriorityQueue<Integer> q2 = new PriorityQueue<Integer>();\n        while (!q.isEmpty()) {\n            int p = q.poll();\n            h.remove(p);\n            for (int child : node[p]) {\n                --totalIn[child];\n                if (totalIn[child] == 0) {\n                    if (child > p) {\n                        q.add(child);\n                    } else {\n                        q2.add(child);\n                    }\n                }\n            }\n        }\n\n        q = q2;\n    }\n\n}\n\nclass Reader {\n\n    final private int BUFFER_SIZE = 1 << 16;\n    private DataInputStream din;\n    private byte[] buffer;\n    private int bufferPointer, bytesRead;\n\n    public Reader() {\n        din = new DataInputStream(System.in);\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public Reader(String file_name) throws IOException {\n        din = new DataInputStream(new FileInputStream(file_name));\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public String readLine() throws IOException {\n        byte[] buf = new byte[64]; // line length \n        int cnt = 0, c;\n        while ((c = read()) != -1) {\n            if (c == '\\n') {\n                break;\n            }\n            buf[cnt++] = (byte) c;\n        }\n        return new String(buf, 0, cnt);\n    }\n\n    public int nextInt() throws IOException {\n        int ret = 0;\n        byte c = read();\n        while (c <= ' ') {\n            c = read();\n        }\n        boolean neg = (c == '-');\n        if (neg) {\n            c = read();\n        }\n        do {\n            ret = ret * 10 + c - '0';\n        } while ((c = read()) >= '0' && c <= '9');\n\n        if (neg) {\n            return -ret;\n        }\n        return ret;\n    }\n\n    public long nextLong() throws IOException {\n        long ret = 0;\n        byte c = read();\n        while (c <= ' ') {\n            c = read();\n        }\n        boolean neg = (c == '-');\n        if (neg) {\n            c = read();\n        }\n        do {\n            ret = ret * 10 + c - '0';\n        } while ((c = read()) >= '0' && c <= '9');\n        if (neg) {\n            return -ret;\n        }\n        return ret;\n    }\n\n    public double nextDouble() throws IOException {\n        double ret = 0, div = 1;\n        byte c = read();\n        while (c <= ' ') {\n            c = read();\n        }\n        boolean neg = (c == '-');\n        if (neg) {\n            c = read();\n        }\n\n        do {\n            ret = ret * 10 + c - '0';\n        } while ((c = read()) >= '0' && c <= '9');\n\n        if (c == '.') {\n            while ((c = read()) >= '0' && c <= '9') {\n                ret += (c - '0') / (div *= 10);\n            }\n        }\n\n        if (neg) {\n            return -ret;\n        }\n        return ret;\n    }\n\n    private void fillBuffer() throws IOException {\n        bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n        if (bytesRead == -1) {\n            buffer[0] = -1;\n        }\n    }\n\n    private byte read() throws IOException {\n        if (bufferPointer == bytesRead) {\n            fillBuffer();\n        }\n        return buffer[bufferPointer++];\n    }\n\n    public void close() throws IOException {\n        if (din == null) {\n            return;\n        }\n        din.close();\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\ntemplate <typename T>\nT min_(T a, T b) {\n  return a > b ? b : a;\n}\ntemplate <typename T, typename... Ts>\nT min_(T first, Ts... last) {\n  return min_(first, min_(last...));\n}\ntemplate <typename T, typename T1>\nT amax(T& a, T1 b) {\n  if (b > a) a = b;\n  return a;\n}\ntemplate <typename T, typename T1>\nT amin(T& a, T1 b) {\n  if (b < a) a = b;\n  return a;\n}\ntemplate <class T, class S>\nstd::ostream& operator<<(std::ostream& os, const std::pair<T, S>& t) {\n  os << \"(\" << t.first << \", \" << t.second << \")\";\n  return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n  out << \"[\";\n  size_t last = v.size() - 1;\n  for (size_t i = 0; i < v.size(); ++i) {\n    out << v[i];\n    if (i != last) out << \", \";\n  }\n  out << \"]\";\n  return out;\n}\nvector<int> g[200008];\nbool vis[200008];\nbool vis1[200008];\nint in[200008];\nvector<int> dist(200008);\nbool dfs(int v, int par) {\n  vis1[v] = true;\n  for (int u : g[v]) {\n    if (u == par) continue;\n    if (vis1[u]) {\n      return true;\n    }\n    if (dfs(u, v)) return true;\n  }\n  return false;\n}\nvoid solve() {\n  int n;\n  cin >> n;\n  for (auto i = 0; i < n + 1; i++)\n    g[i].clear(), vis[i] = false, vis1[i] = false, in[i] = 0, dist[i] = -1;\n  int k;\n  int e;\n  for (auto i = 0; i < n; i++) {\n    cin >> k;\n    for (auto j = 0; j < k; j++) {\n      cin >> e;\n      e--;\n      g[i].push_back(e);\n      in[e]++;\n    }\n  }\n  queue<int> q;\n  for (int i = 0; i < n; i++)\n    if (in[i] == 0) q.push(i);\n  int cnt = 0;\n  vector<int> top_order;\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n    top_order.push_back(u);\n    for (auto ele : g[u]) {\n      if (--in[ele] == 0) q.push(ele);\n    }\n    cnt++;\n  }\n  if (cnt != n) {\n    cout << -1 << '\\n';\n    return;\n  }\n  reverse((top_order).begin(), (top_order).end());\n  int ans = 0;\n  for (auto ele : top_order) {\n    if (g[ele].size() == 0)\n      dist[ele] = 0;\n    else {\n      int mx = 0;\n      for (auto nd : g[ele]) {\n        if (nd < ele)\n          mx = max(mx, dist[nd]);\n        else\n          mx = max(mx, dist[nd] + 1);\n      }\n      dist[ele] = mx;\n    }\n  }\n  ans = 0;\n  for (auto i = 0; i < n; i++) ans = max(ans, dist[i]);\n  cout << ans + 1 << '\\n';\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int T = 1;\n  cin >> T;\n  while (T--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "from enum import Enum\nimport sys\n\n\nclass VertexState(Enum):\n    NotVisited = 0\n    Processing = 1\n    Done = 2\n\n\ndef dfs_cycle(graph, state, vertex):\n    is_cycle = False\n    state[vertex] = VertexState.Processing\n\n    for n in graph[vertex]:\n        if state[n] == VertexState.NotVisited:\n            is_cycle = is_cycle or dfs_cycle(graph, state, n)\n        elif state[n] == VertexState.Processing:\n            is_cycle = True\n\n    state[vertex] = VertexState.Done\n\n    return is_cycle\n\n\ndef check_cycle(graph):\n    state = len(graph) * [VertexState.NotVisited]\n    is_cycle = False\n\n    for v in range(1, len(graph)):\n        if state[v] == VertexState.NotVisited:\n            is_cycle = is_cycle or dfs_cycle(graph, state, v)\n\n    return is_cycle\n\n\ndef dfs_topo(graph, visited, vertex, rev_topo_order):\n    visited[vertex] = True\n\n    for v in graph[vertex]:\n        if not visited[v]:\n            dfs_topo(graph, visited, v, rev_topo_order)\n\n    rev_topo_order.append(vertex)\n\n\ndef topoSort(graph):\n    visited = len(graph) * [False]\n    rev_topo_order = []\n\n    for v in range(1, len(graph)):\n        if not visited[v]:\n            dfs_topo(graph, visited, v, rev_topo_order)\n\n    return reversed(rev_topo_order)\n\n\ndef solution():\n    t = int(input())\n\n    for _ in range(t):\n        n = int(input())\n\n        graph = [[] for _ in range(n + 1)]\n\n        for i in range(1, n + 1):\n            chapters_required = list(map(int, input().split()))[1:]\n            for v in chapters_required:\n                graph[v].append(i)\n\n        if check_cycle(graph):\n            print(-1)\n        else:\n            topo_order = topoSort(graph)\n            dp = [1 for _ in range(n + 1)]\n\n            for i in topo_order:\n                for v in graph[i]:\n                    if i > v:\n                        dp[v] = max(dp[v], dp[i] + 1)\n                    else:\n                        dp[v] = max(dp[v], dp[i])\n\n            print(max(dp))\n\n\nif __name__ == '__main__':\n    sys.setrecursionlimit(200005)\n    solution()\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        try (FastScanner scanner = System.getProperty(\"ONLINE_JUDGE\", \"\").isEmpty() ? new FastScanner(new File(\"test.txt\")) : new FastScanner(System.in)) {\n            int T = scanner.nextInt();\n            for (int t = 0; t < T; t++) {\n                int N = scanner.nextInt();\n                ArrayList<int[]> deps = new ArrayList<>(N);\n                for (int n = 0; n < N; n++) {\n                    int C = scanner.nextInt();\n                    deps.add(scanner.nextIntArray(C));\n                }\n                try {\n                    System.out.println(new Main(deps).solve());\n                }\n                catch (Exception e) {\n                    System.out.println(\"-1\");\n                }\n            }\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    final ArrayList<int[]> deps;\n    final int[]            reads;\n\n    public Main(ArrayList<int[]> deps) {\n        this.deps = deps;\n        reads     = new int[deps.size()];\n    }\n\n    int solve() throws Exception {\n        int max = 0;\n        for (int c = 0; c < deps.size(); c++) {\n            max = Math.max(max, readChapter(c));\n        }\n        return max;\n    }\n\n    int readChapter(int n) throws Exception {\n        if (reads[n] == -1) {\n            throw new Exception(\"Cycle detected\");\n        }\n        if (reads[n] > 0) {\n            return reads[n];\n        }\n        int max = 1;\n        reads[n] = -1;\n        for (int c: deps.get(n)) {\n            int m = readChapter(c - 1);\n            if (c > n) { ++m; }\n            max = Math.max(max, m);\n        }\n        reads[n] = max;\n        return max;\n    }\n\n    static class FastScanner implements AutoCloseable {\n        final BufferedReader bufferedReader;\n        StringTokenizer stringTokenizer;\n\n        private FastScanner(File file) throws FileNotFoundException {\n            bufferedReader = new BufferedReader(new FileReader(file));\n        }\n\n        private FastScanner(InputStream in) {\n            bufferedReader = new BufferedReader(new InputStreamReader(in));\n        }\n\n        @Override\n        public void close() throws Exception {\n            bufferedReader.close();\n        }\n\n        public String nextString() throws IOException {\n            return nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(nextToken(), 10);\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(nextToken());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(nextToken(), 10);\n        }\n\n        public int[] nextIntArray(int n) throws IOException {\n            int[] res = new int[n];\n            for (int i = 0; i < n; ++i) {\n                res[i] = nextInt();\n            }\n            return res;\n        }\n\n        public long[] nextLongArray(int n) throws IOException {\n            long[] res = new long[n];\n            for (int i = 0; i < n; ++i) {\n                res[i] = nextLong();\n            }\n            return res;\n        }\n\n        public String[] nextStringArray(int n) throws IOException {\n            String[] res = new String[n];\n            for (int i = 0; i < n; ++i) {\n                res[i] = nextString();\n            }\n            return res;\n        }\n\n        private String nextToken() throws IOException {\n            while (stringTokenizer == null || !stringTokenizer.hasMoreTokens()) {\n                stringTokenizer = new StringTokenizer(bufferedReader.readLine());\n            }\n            return stringTokenizer.nextToken();\n        }\n\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mod1 = 1000000007, mod2 = 998244353;\nlong long mn = LLONG_MAX;\nlong long mx = LLONG_MIN;\nlong long mod;\nvector<int> adj[200007];\nint siz[200007], vis[200007], ord[200007], dro[200007], dp[200007], flg, ttl;\nstack<int> stc;\nvoid dfs(int src) {\n  vis[src] = 1;\n  int sz = siz[src];\n  for (int lp = 0; lp < sz; lp++) {\n    int u = adj[src][lp];\n    if (vis[u] == 1) {\n      flg = 0;\n    }\n    if (vis[u] == 0) {\n      dfs(u);\n    }\n  }\n  vis[src] = 2;\n  stc.push(src);\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int tc, o;\n  cin >> tc;\n  for (o = 1; o <= tc; o++) {\n    int n, m, a, b, c, i, j, k, x = 0;\n    flg = 1;\n    vector<int> v;\n    cin >> n;\n    for (i = 1; i <= n; i++) {\n      cin >> k;\n      if (k == 0) {\n        v.push_back(i);\n        x++;\n      } else {\n        for (j = 1; j <= k; j++) {\n          cin >> a;\n          adj[a].push_back(i);\n          siz[a]++;\n        }\n      }\n    }\n    for (i = 1; i <= n; i++) {\n      if (vis[i] == 0) dfs(i);\n    }\n    if (flg == 0)\n      cout << \"-1\" << endl;\n    else {\n      int mx = -9, cnt = 0, e, f, g, h, z, idx;\n      while (!stc.empty()) {\n        a = stc.top();\n        cnt++;\n        ord[a] = cnt;\n        dro[cnt] = a;\n        stc.pop();\n      }\n      for (idx = n; idx >= 1; idx--) {\n        dp[idx] = 1;\n        e = dro[idx];\n        f = siz[e];\n        for (j = 0; j < f; j++) {\n          g = adj[e][j];\n          z = 0;\n          if (g < e) {\n            z = 1;\n          }\n          h = ord[g];\n          dp[idx] = max(dp[idx], z + dp[h]);\n        }\n        mx = max(mx, dp[idx]);\n      }\n      cout << mx << endl;\n    }\n    while (!stc.empty()) stc.pop();\n    for (i = 1; i <= n; i++) {\n      adj[i].clear();\n      siz[i] = 0;\n      vis[i] = 0;\n      ord[i] = 0;\n      dro[i] = 0;\n      dp[i] = 0;\n    }\n    v.clear();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.Stack;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Vector;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n *\n * @author keyurjain\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    OutputWriter out = new OutputWriter(outputStream);\n    CBook solver = new CBook();\n    int testCount = Integer.parseInt(in.next());\n    for (int i = 1; i <= testCount; i++) {\n      solver.solve(i, in, out);\n    }\n    out.close();\n  }\n\n  static class CBook {\n\n    boolean hasCycle;\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n      hasCycle = false;\n      int n = in.readInt();\n      IntList[] graph = new IntList[n];\n      for (int i = 0; i < n; i++) {\n        graph[i] = new IntList();\n      }\n      for (int i = 0; i < n; i++) {\n        int k = in.readInt();\n        for (int j = 0; j < k; j++) {\n          int parent = in.readInt() - 1;\n          graph[parent].add(i);\n        }\n      }\n\n      List<Integer> topoSort = getTopoSort(graph);\n      if (hasCycle) {\n        out.printLine(-1);\n      } else {\n        int[] ans = new int[n];\n        int maxAns = 0;\n        for (int i = n - 1; i >= 0; i--) {\n          int node = topoSort.get(i);\n          ans[node] = 1;\n          for (int next : graph[node]) {\n            int _ans = (next > node) ? ans[next] : ans[next] + 1;\n            ans[node] = Math.max(ans[node], _ans);\n          }\n          maxAns = Math.max(ans[node], maxAns);\n        }\n        out.printLine(maxAns);\n      }\n    }\n\n    public List<Integer> getTopoSort(IntList[] graph) {\n      boolean[] visited = new boolean[graph.length];\n      boolean[] currentPath = new boolean[graph.length];\n      Stack<Integer> stack = new Stack<>();\n      for (int i = 0; i < graph.length; i++) {\n        if (!visited[i]) {\n          topoUtil(i, graph, visited, currentPath, stack);\n        }\n      }\n      List<Integer> topoSort = new ArrayList<>();\n      while (!stack.isEmpty()) {\n        topoSort.add(stack.pop());\n      }\n      return topoSort;\n    }\n\n    public void topoUtil(int node, IntList[] graph, boolean[] visited, boolean[] currentPath,\n        Stack<Integer> stack) {\n      visited[node] = true;\n      currentPath[node] = true;\n      for (int next : graph[node]) {\n        if (!visited[next]) {\n          topoUtil(next, graph, visited, currentPath, stack);\n        } else if (currentPath[next]) {\n          hasCycle = true;\n        }\n      }\n      stack.push(node);\n      currentPath[node] = false;\n    }\n\n  }\n\n  static class OutputWriter {\n\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n      this.writer = new PrintWriter(writer);\n    }\n\n    public void close() {\n      writer.close();\n    }\n\n    public void printLine(int i) {\n      writer.println(i);\n    }\n\n  }\n\n  static class IntList extends ArrayList<Integer> {\n\n  }\n\n  static class InputReader {\n\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private InputReader.SpaceCharFilter filter;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public int read() {\n      if (numChars == -1) {\n        throw new InputMismatchException();\n      }\n      if (curChar >= numChars) {\n        curChar = 0;\n        try {\n          numChars = stream.read(buf);\n        } catch (IOException e) {\n          throw new InputMismatchException();\n        }\n        if (numChars <= 0) {\n          return -1;\n        }\n      }\n      return buf[curChar++];\n    }\n\n    public int readInt() {\n      int c = read();\n      while (isSpaceChar(c)) {\n        c = read();\n      }\n      int sgn = 1;\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      int res = 0;\n      do {\n        if (c < '0' || c > '9') {\n          throw new InputMismatchException();\n        }\n        res *= 10;\n        res += c - '0';\n        c = read();\n      } while (!isSpaceChar(c));\n      return res * sgn;\n    }\n\n    public String readString() {\n      int c = read();\n      while (isSpaceChar(c)) {\n        c = read();\n      }\n      StringBuilder res = new StringBuilder();\n      do {\n        if (Character.isValidCodePoint(c)) {\n          res.appendCodePoint(c);\n        }\n        c = read();\n      } while (!isSpaceChar(c));\n      return res.toString();\n    }\n\n    public boolean isSpaceChar(int c) {\n      if (filter != null) {\n        return filter.isSpaceChar(c);\n      }\n      return isWhitespace(c);\n    }\n\n    public static boolean isWhitespace(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public String next() {\n      return readString();\n    }\n\n    public interface SpaceCharFilter {\n\n      public boolean isSpaceChar(int ch);\n\n    }\n\n  }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class C {\n\t \n\tstatic Set<Integer> g[];\n\tstatic int[] indegree;\n\tstatic List<Integer> order;\n\tpublic static void main(String[] args) {\n\t\t\n\t\tFastReader f = new FastReader();\n\t\tStringBuffer sb=new StringBuffer();\n\t\t\n\t\tint test=f.nextInt();\n\t\twhile(test-->0)\n\t\t{\n\t\t\tint n=f.nextInt();\n\t\t\t\n\t\t\tindegree=new int[n+1];\n\t\t\tg=new HashSet[n+1];\n\t\t\t\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tg[i]=new HashSet<>();\n\t\t\t\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t{\n\t\t\t\tint c=f.nextInt();\n\t\t\t\tfor(int j=0;j<c;j++)\n\t\t\t\t{\n\t\t\t\t\tint y=f.nextInt();\n\t\t\t\t\tg[y].add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\torder=new ArrayList<>();\n\t\t\tif(!topologicalSort())\n\t\t\t{\n\t\t\t\tsb.append(\"-1\\n\");\n\t\t\t\tcontinue ;\n\t\t\t}\n\t\t\tint ans=1;\n\t\t\tfor(int i=1;i<order.size();i++)\n\t\t\t{\n\t\t\t\tif(order.get(i-1)>order.get(i)) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tsb.append(ans+\"\\n\");\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\t\n\t static public boolean topologicalSort()\n\t {\n\t  \n\t\t for(Set<Integer> list:g)\n\t\t {\n\t\t\t for(int i:list)\n\t\t\t\t indegree[i]++;\n\t\t }\n\t \n\t        \n\t        PriorityQueue<Integer> q\n\t            = new PriorityQueue<Integer>();\n\t        for (int i = 1; i <g.length; i++) {\n\t            if (indegree[i] == 0)\n\t                q.add(i);\n\t        }\n\t        PriorityQueue<Integer> currQ\n            = new PriorityQueue<Integer>();\n\t        \n\t        for(int i:q)\n\t        \tcurrQ.add(i);\n\t        \n\t        int cnt = 0;\n\t \n\t        List<Integer> topOrder = new ArrayList<Integer>();\n\t        \n\t        while(!q.isEmpty())\n\t        {\n\t        \tcurrQ=new PriorityQueue<Integer>();\n\t        \tfor(int i:q)\n\t        \t\tcurrQ.add(i);\n\t        \tq=new PriorityQueue<Integer>();\n\t        \twhile(!currQ.isEmpty())\n\t        \t{\n\t        \t\tint u = currQ.poll();\n\t        \t\ttopOrder.add(u);\n\t \n\t           \n\t        \t\tfor (int node : g[u]) {\n\t               \n\t        \t\t\tif (--indegree[node] == 0)\n\t                    {\n\t        \t\t\t\tif(node<u)\n\t        \t\t\t\t\tq.add(node);\n\t        \t\t\t\telse\n\t        \t\t\t\t\tcurrQ.add(node);\n\t                    }\n\t        \t\t}\n\t        \t\tcnt++;\n\t        \t}\n\t        }\n\t \n\t        if (cnt != g.length-1) {\n\t            return false;\n\t        }\n\t        for(int i:topOrder)\n\t        \torder.add(i);\n\t        return true;\n\t       \n\t    }\n\t\n\tstatic class FastReader \n\t{ \n\t    BufferedReader br; \n\t    StringTokenizer st; \n \n\t    public FastReader() {\n\t    \tbr = new BufferedReader(new\n\t                 InputStreamReader(System.in)); \n\t    }\n\t    String next() { \n\t        while (st == null || !st.hasMoreElements()) { \n\t            try{ \n\t                st = new StringTokenizer(br.readLine()); \n\t            } \n\t            catch (IOException  e) { \n\t                e.printStackTrace(); \n\t            } \n\t        } \n\t        return st.nextToken(); \n\t    } \n\t    int nextInt() { \n\t        return Integer.parseInt(next()); \n\t    } \n\t    long nextLong() { \n\t        return Long.parseLong(next()); \n\t    } \n\t    double nextDouble() { \n\t        return Double.parseDouble(next()); \n\t    } \n\t    String nextLine() { \n\t        String str = \"\"; \n\t        try{ \n\t            str = br.readLine(); \n\t        } \n\t        catch (IOException e) { \n\t            e.printStackTrace(); \n\t        } \n\t        return str; \n\t    } \n\t} \n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main\n{\n\tPrintWriter out = new PrintWriter(System.out);\n\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer tok = new StringTokenizer(\"\");\n    String next() throws IOException {\n        if (!tok.hasMoreTokens()) { tok = new StringTokenizer(in.readLine()); }\n        return tok.nextToken();\n    }\n    int ni() throws IOException { return Integer.parseInt(next()); }\n    long nl() throws IOException { return Long.parseLong(next()); }\n    \n    long mod=1000000007;\n    \n    void solve() throws IOException {\n        for (int tc=ni();tc>0;tc--) {\n            int n=ni();\n            HashSet<Integer>[]H=new HashSet[n+1];\n            HashSet<Integer>[]G=new HashSet[n+1];\n            TreeSet<Integer>T=new TreeSet();\n            for (int i=1;i<=n;i++) { H[i]=new HashSet(); G[i]=new HashSet(); }\n            for (int i=1;i<=n;i++) {\n                int j=ni();\n                if (j==0) T.add(i);\n                while (j>0) {\n                    j--;\n                    int u=ni();\n                    H[i].add(u);\n                    G[u].add(i);\n                }\n            }\n            \n            \n            int ans=1;\n            int last=0;\n            int ct=0;\n            while (T.size()>0) {\n                Integer u=T.higher(last);\n                if (u==null) { u=T.higher(0); ans++; }\n                T.remove(u);\n                for (int v:G[u]) {\n                    H[v].remove(u);\n                    if (H[v].size()==0) T.add(v);\n                }\n                ct++;\n                last=u;\n            }\n            \n            if (ct<n) out.println(-1);\n            else out.println(ans);\n        }\n        out.flush();\n    }\n    \n    int gcd(int a,int b) { return(b==0?a:gcd(b,a%b)); }\n    long gcd(long a,long b) { return(b==0?a:gcd(b,a%b)); }\n    long mp(long a,long p) { long r=1; while(p>0) { if ((p&1)==1) r=(r*a)%mod; p>>=1; a=(a*a)%mod; } return r; }\n    \n    public static void main(String[] args) throws IOException {\n        new Main().solve();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint T, n, tot, ans, num;\nconst int maxn = 1e6 + 10;\nint d[maxn], head[maxn], v[maxn], Next[maxn], dp[maxn];\nqueue<int> q;\nvoid init() {\n  num = n;\n  tot = 0;\n  ans = 1;\n  for (int i = 1; i <= n; i++) head[i] = d[i] = 0, dp[i] = 1;\n}\nvoid add(int x, int y) {\n  v[++tot] = y;\n  Next[tot] = head[x];\n  head[x] = tot;\n}\nvoid bfs() {\n  while (q.size()) {\n    int x = q.front();\n    q.pop();\n    num--;\n    ans = max(ans, dp[x]);\n    for (int i = head[x]; i; i = Next[i]) {\n      int y = v[i];\n      d[y]--;\n      if (y < x)\n        dp[y] = max(dp[y], dp[x] + 1);\n      else\n        dp[y] = max(dp[y], dp[x]);\n      if (!d[y]) {\n        q.push(y);\n      }\n    }\n  }\n}\nint main() {\n  scanf(\"%d\", &T);\n  while (T--) {\n    scanf(\"%d\", &n);\n    init();\n    for (int i = 1; i <= n; i++) {\n      int len;\n      scanf(\"%d\", &len);\n      for (int j = 1; j <= len; j++) {\n        int t;\n        scanf(\"%d\", &t);\n        add(t, i);\n        d[i]++;\n      }\n    }\n    for (int i = 1; i <= n; i++) {\n      if (!d[i]) q.push(i);\n    }\n    bfs();\n    if (num)\n      printf(\"-1\\n\");\n    else\n      printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict as dd, deque\ndef check_cycle(g, indegree, n):\n    c = 0;d = deque([]);ans = dd(lambda :1);d += [(i + 1) for i in range(n) if indegree[i + 1] == 0]\n    while d:\n        u = d.popleft();c += 1\n        for v in g[u]:\n            indegree[v] -= 1;ans[v] = (max(ans[v], ans[u] + 1) if v < u else max(ans[v], ans[u]))\n            if indegree[v] == 0:d.append(v)\n    if c != n:return False\n    if ans:return max(ans.values())\n    return 1\nfor _ in range(int(input())):\n    n = int(input());g = dd(set);indegree = dd(int)\n    for i in range(n):\n        a = list(map(int, input().split()))\n        for j in range(1, a[0] + 1):indegree[i + 1] += 1;g[a[j]].add(i + 1)\n    res = check_cycle(g, indegree, n);print(-1) if not res else print(res)"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.SortedSet;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n/**\n * #\n *\n * @author pttrung\n */\npublic class C_Round_743_Div2 {\n    public static long MOD = 998244353;\n\n    static int[] dp;\n\n\n    public static void main(String[] args) throws FileNotFoundException {\n        // PrintWriter out = new PrintWriter(new FileOutputStream(new File(\n        // \"output.txt\")));\n        PrintWriter out = new PrintWriter(System.out);\n        Scanner in = new Scanner();\n        int T = in.nextInt();\n        for (int Z = 0; Z < T; Z++) {\n            int n = in.nextInt();\n            int[][] data = new int[n][];\n            for (int i = 0; i < n; i++) {\n                int k = in.nextInt();\n                data[i] = new int[k];\n                for (int j = 0; j < k; j++) {\n                    data[i][j] = in.nextInt() - 1;\n                }\n            }\n            dp = new int[n];\n            Arrays.fill(dp, -2);\n            int result = 0;\n            boolean[] s = new boolean[n];\n            for (int i = 0; i < n; i++) {\n                int v = cal(i, s, data);\n                if (v == -1) {\n                    result = -1;\n                    break;\n                }\n                result = Integer.max(result, v);\n            }\n            out.println(result);\n        }\n        out.close();\n    }\n\n    static int cal(int index, boolean[] s, int[][] data) {\n        if (dp[index] != -2) {\n            return dp[index];\n        }\n        if (s[index]) {\n            return -1;\n        }\n        s[index] = true;\n        int result = 1;\n        for (int i : data[index]) {\n            int v = cal(i, s, data);\n            if (v == -1) {\n                result = -1;\n                break;\n            }\n            if (i > index) {\n                v++;\n            }\n            result = Integer.max(result, v);\n        }\n        s[index] = false;\n        return dp[index] = result;\n    }\n\n\n    static int dist(int from, int to, int n) {\n        return Integer.min((from - to + n) % n, (to - from + n) % n);\n    }\n\n\n    static int find(int index, int[] u) {\n        if (u[index] != index) {\n            return u[index] = find(u[index], u);\n        }\n        return index;\n    }\n\n    static int abs(int a) {\n        return a < 0 ? -a : a;\n    }\n\n\n    public static int[] KMP(String val) {\n        int i = 0;\n        int j = -1;\n        int[] result = new int[val.length() + 1];\n        result[0] = -1;\n        while (i < val.length()) {\n            while (j >= 0 && val.charAt(j) != val.charAt(i)) {\n                j = result[j];\n            }\n            j++;\n            i++;\n            result[i] = j;\n        }\n        return result;\n\n    }\n\n    public static boolean nextPer(int[] data) {\n        int i = data.length - 1;\n        while (i > 0 && data[i] < data[i - 1]) {\n            i--;\n        }\n        if (i == 0) {\n            return false;\n        }\n        int j = data.length - 1;\n        while (data[j] < data[i - 1]) {\n            j--;\n        }\n        int temp = data[i - 1];\n        data[i - 1] = data[j];\n        data[j] = temp;\n        Arrays.sort(data, i, data.length);\n        return true;\n    }\n\n    public static int digit(long n) {\n        int result = 0;\n        while (n > 0) {\n            n /= 10;\n            result++;\n        }\n        return result;\n    }\n\n    public static double dist(long a, long b, long x, long y) {\n        double val = (b - a) * (b - a) + (x - y) * (x - y);\n        val = Math.sqrt(val);\n        double other = x * x + a * a;\n        other = Math.sqrt(other);\n        return val + other;\n\n    }\n\n    public static class Point {\n\n        int x;\n        int y;\n\n        public Point(int start, int end) {\n            this.x = start;\n            this.y = end;\n        }\n\n        public String toString() {\n            return x + \" \" + y;\n        }\n\n    }\n\n    public static class FT {\n\n        long[] data;\n\n        FT(int n) {\n            data = new long[n];\n        }\n\n        public void update(int index, long value) {\n            while (index < data.length) {\n                data[index] += value;\n                index += (index & (-index));\n            }\n        }\n\n        public long get(int index) {\n\n            long result = 0;\n            while (index > 0) {\n                result += data[index];\n                index -= (index & (-index));\n            }\n            return result;\n\n        }\n    }\n\n    public static long gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    public static long pow(long a, int b) {\n        if (b == 0) {\n            return 1;\n        }\n        if (b == 1) {\n            return a;\n        }\n\n        long val = pow(a, b / 2);\n        if (b % 2 == 0) {\n            return (val * val) % MOD;\n        } else {\n            return (val * ((val * a) % MOD)) % MOD;\n\n        }\n    }\n\n    static class Scanner {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public Scanner() throws FileNotFoundException {\n            // System.setOut(new PrintStream(new BufferedOutputStream(System.out), true));\n            br = new BufferedReader(new InputStreamReader(System.in));\n            //br = new BufferedReader(new InputStreamReader(new FileInputStream(new File(\"input.txt\"))));\n        }\n\n        public String next() {\n\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (Exception e) {\n                    throw new RuntimeException();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            st = null;\n            try {\n                return br.readLine();\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n\n        public boolean endLine() {\n            try {\n                String next = br.readLine();\n                while (next != null && next.trim().isEmpty()) {\n                    next = br.readLine();\n                }\n                if (next == null) {\n                    return true;\n                }\n                st = new StringTokenizer(next);\n                return st.hasMoreTokens();\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> g;\nvector<int> c, dp;\nint n, k, i, f, t, v;\nbool dfs(int u) {\n  c[u] = 2;\n  for (auto s : g[u]) {\n    if (c[s] == 2 || (!c[s] && dfs(s))) return 1;\n    dp[u] = max(dp[u], dp[s] + (u < s));\n  }\n  return !(c[u] = 1);\n}\nint main() {\n  cin >> t;\n  while (t--) {\n    cin >> n, f = 1;\n    g.assign(n, {});\n    c.assign(n, 0);\n    dp.assign(n, 1);\n    for (i = 0; i < n; i++) {\n      cin >> k;\n      while (k--) cin >> v, g[i].push_back(--v);\n    }\n    for (i = 0; i < n; i++) f &= !(!c[i] && dfs(i));\n    cout << (f ? *max_element(begin(dp), end(dp)) : -1) << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, pair<T, U> p) {\n  os << \"(\" << p.first << \",\" << p.second << \")\";\n  return os;\n}\ntemplate <typename T, typename U>\nistream &operator>>(istream &is, pair<T, U> &p) {\n  is >> p.first >> p.second;\n  return is;\n}\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &v) {\n  for (int i = 0; i < int(v.size()); ++i) is >> v[i];\n  return is;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, vector<T> v) {\n  for (T x : v) os << x << \" \";\n  return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, set<T> s) {\n  for (T x : s) os << x << \" \";\n  return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, multiset<T> s) {\n  for (T x : s) os << x << \" \";\n  return os;\n}\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, map<T, U> m) {\n  for (auto x : m) os << x << \" \";\n  return os;\n}\ntemplate <typename T>\nT sum(vector<T> v) {\n  T summ = 0;\n  for (int i = 0; i < int(int(v.size())); ++i) summ += v[i];\n  return summ;\n}\nlong long mod_pow(long long a, long long b) {\n  long long sol = 1;\n  while (b) {\n    if (b & 1) {\n      sol = (sol * a) % mod;\n      b--;\n    } else {\n      a = (a * a) % mod;\n      b /= 2;\n    }\n  }\n  return sol;\n}\nlong long rem(long long a, long long b) {\n  long long res = a % b;\n  return res < 0 ? res + b : res;\n}\nvoid test_case() {\n  int n;\n  cin >> n;\n  vector<vector<int> > g(n + 1);\n  vector<int> indeg(n + 1);\n  for (int i = 1; i < int(n + 1); ++i) {\n    int k;\n    cin >> k;\n    indeg[i] = k;\n    for (int j = 0; j < int(k); ++j) {\n      int req;\n      cin >> req;\n      g[req].push_back(i);\n    }\n  }\n  priority_queue<int> pq, pending;\n  vector<bool> ok(n + 1);\n  for (int i = 1; i < int(n + 1); ++i)\n    if (indeg[i] == 0) pq.push(-i);\n  int reads = 1;\n  while (!pq.empty()) {\n    int v = -pq.top();\n    pq.pop();\n    ok[v] = true;\n    for (int to : g[v]) {\n      indeg[to]--;\n      if (indeg[to] == 0) v > to ? pending.push(-to) : pq.push(-to);\n    }\n    if (pq.empty() && !pending.empty()) {\n      reads++;\n      while (!pending.empty()) {\n        pq.push(pending.top());\n        pending.pop();\n      }\n    }\n  }\n  bool is_sol = true;\n  for (int i = 1; i < int(n + 1); ++i) is_sol &= ok[i];\n  cout << (is_sol ? reads : -1) << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int t;\n  cin >> t;\n  for (int i = 0; i < int(t); ++i) test_case();\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import os, sys\nfrom io import BytesIO, IOBase\nfrom math import log2, ceil, sqrt, gcd\nfrom _collections import deque\nimport heapq as hp\nfrom bisect import bisect_left, bisect_right\nfrom math import cos, sin\nfrom itertools import permutations\nfrom operator import itemgetter\n\n# sys.setrecursionlimit(2*10**5+10000)\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfor _ in range(int(input())):\n    n=int(input())\n    a=[[] for _ in range(n+1)]\n    ct=[0]*(n+1)\n    for i in range(1,n+1):\n        ck=list(map(int,input().split()))[::-1]\n        ck.pop()\n        for j in ck:\n            ct[i]+=1\n            a[j].append(i)\n    ans=0\n    d=[]\n    v=0\n    for i in range(1,n+1):\n        if ct[i]==0:\n            hp.heappush(d,i)\n    # print(a,d,ct)\n    while d:\n        ans+=1\n        dr = []\n        while d:\n            # print(d,dr)\n            x=hp.heappop(d)\n            v+=1\n            for i in a[x]:\n                ct[i]-=1\n                if ct[i]==0:\n                    if i>x:\n                        hp.heappush(d,i)\n                    else:\n                        hp.heappush(dr,i)\n        d=dr\n    if v==n:\n        print(ans)\n    else:\n        print(-1)\n\n"
        },
        {
            "language": 4,
            "solution": "// package com.codeforces.contest.div2.round743.c;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        FastScanner fs = new FastScanner();\n        int t = fs.nextInt();\n        while (t-- > 0) {\n            int n = fs.nextInt();\n            Map<Integer, List<Integer>> adjList = new HashMap<>(), reverseAdjList = new HashMap<>();\n            for (int i = 1; i <=n; ++i) {\n                adjList.put(i, new ArrayList<>());\n                reverseAdjList.put(i, new ArrayList<>());\n            }\n            int[] in = new int[n + 1];\n\n            // 1. Populate adjacency list.\n            for (int i = 1; i <=n; ++i) {\n                int size = fs.nextInt();\n                in[i] = size;\n                while (size-- > 0) {\n                    int adj = fs.nextInt();\n                    adjList.get(adj).add(i);\n                    reverseAdjList.get(i).add(adj);\n                }\n            }\n\n            Queue<Integer> q = new ArrayDeque<>();\n            boolean[] vis = new boolean[n + 1];\n            List<Integer> topologicalOrder = new ArrayList<>();\n\n            // 2. Populate queue with vertex having zero in-degree.\n            for (int i = 1; i <= n; ++i) {\n                if (in[i] == 0) {\n                    q.offer(i);\n                }\n            }\n\n            // 3. Compute topological order.\n            while (!q.isEmpty()) {\n                int cur = q.poll();\n                vis[cur] = true;\n                topologicalOrder.add(cur);\n                for (int adj : adjList.get(cur)) {\n                    if (vis[adj]) continue;\n                    in[adj]--;\n                    if (in[adj] == 0) {\n                        q.offer(adj);\n                    }\n                }\n            }\n\n            boolean possible = true;\n            for (int i = 1; i <=n; ++i) {\n                if (!vis[i]) {\n                    possible = false;\n                    break;\n                }\n            }\n\n            if (!possible) {\n                System.out.println(-1);\n                continue;\n            }\n\n            // 4. Compute total operations to read the book completely.\n            // dp[u] : operations required to read chapter u.\n            // Let's assume to read chapter u we have to first read the following chapters\n            //      v_1, v_2, v_3, v_4, ... , v_k  -> u\n            // then the dp[u] will be:\n            //      dp[u] = Math.max(dp[v_1], dp[v_2], ... , dp[v_k])\n            // Now if v_i > u: Then u can only be read in the next iteration after v_i is read i.e\n            //      dp[u] = Math.max(dp[u], dp[v_i] + 1)\n            // Otherwise if v_i < u: Then u can be read in the same iteration itself.\n            //      dp[u] = Math.max(dp[u], dp[v_i])\n\n            int[] dp = new int[n + 1];\n            // Filling this with 1 since a graph can be, 1 -> 2 -> 3 -> ... -> n\n            Arrays.fill(dp, 1);\n            int ans = 0;\n            for (int u : topologicalOrder) {\n                for (int v : reverseAdjList.get(u)) {\n                    if (v > u) {\n                        dp[u] = Math.max(dp[u], dp[v] + 1);\n                    } else {\n                        dp[u] = Math.max(dp[u], dp[v]);\n                    }\n                }\n                ans = Math.max(ans, dp[u]);\n            }\n            System.out.println(ans);\n        }\n    }\n\n    static class FastScanner {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] readArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class B{\n\tstatic int n;\n\tstatic List<Integer>[] adj;\n\tstatic int[] seen;\n\t\n\tstatic boolean dfs(int node) {\n\t\tseen[node] = 1;\n\t\tboolean ret = false;\n\t\tfor(int i:adj[node]) {\n\t\t\tif(seen[i] == 1)return true;\n\t\t\tif(seen[i] == 0)ret |= dfs(i);\n\t\t}\n\t\tseen[node] = 2;\n\t\treturn ret;\n \t}\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\tFastScanner fs = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint t = fs.nextInt();\n\t\tme:for(int tt=0;tt<t;tt++) {\n\t\t\tn = fs.nextInt();\n\t\t\tadj = new ArrayList[n+1];\n\t\t\tfor(int i=1;i<=n;i++)adj[i] = new ArrayList();\n\t\t\t\n\t\t\tint[] in = new int[n+1];\n\t\t\tfor(int i=1;i<=n;i++)in[i] = 0;\n\t\t\t\n\t\t\tfor(int i=1;i<=n;i++) {\n\t\t\t\tint k = fs.nextInt();\n\t\t\t\tfor(int j=1;j<=k;j++) {\n\t\t\t\t\tint from = fs.nextInt();\n\t\t\t\t\tadj[from].add(i);\n\t\t\t\t\tin[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tQueue<Integer> q = new LinkedList();\n\t\t\tfor(int i=1;i<=n;i++) {\n\t\t\t\tif(in[i] == 0)q.add(i);\n\t\t\t}\n\t\t\tseen = new int[n+1];\n\t\t\tfor(int i=1;i<=n;i++)seen[i] = 0;\n\t\t\t\n\t\t\tboolean isCycle = false;\n\t\t\t\n\t\t\tfor(int i=1;i<=n;i++) {\n\t\t\t\tif(seen[i] == 0) {\n\t\t\t\t\tisCycle |= dfs(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(isCycle == true) {\n\t\t\t\tout.println(\"-1\");\n\t\t\t\tcontinue me;\n\t\t\t}\n\t\t\tint[] ans = new int[n+1];\n\t\t\tfor(int i=1;i<=n;i++)ans[i] = 1;\n\t\t\twhile(!q.isEmpty()) {\n\t\t\t\tint node = q.poll();\n\t\t\t\tfor(int ele:adj[node]) {\n\t\t\t\t\tif(ele<node) {\n\t\t\t\t\t\tans[ele] = Math.max(ans[ele],ans[node]+1);\n\t\t\t\t\t}\n\t\t\t\t\telse ans[ele] = Math.max(ans[ele],ans[node]);\n\t\t\t\t\tin[ele]--;\n\t\t\t\t\tif(in[ele] == 0)q.add(ele);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = Integer.MIN_VALUE;\n\t\t\tfor(int i=1;i<=n;i++)max = Math.max(ans[i],max);\n\t\t\tout.println(max);\n\t\t}\n\t\tout.close();\t\t\n\t}\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n\tpublic static int[] sort(int[] arr)\n\t{\n\t\tList<Integer> temp = new ArrayList();\n\t\tfor(int i:arr)temp.add(i);\n\t\tCollections.sort(temp);\n\t\tint start = 0;\n\t\tfor(int i:temp)arr[start++]=i;\n\t\treturn arr;\n\t}\n\tpublic static String rev(String str)\n\t{\n\t\tchar[] arr = str.toCharArray();\n\t\tchar[] ret = new char[arr.length];\n\t\tint start = arr.length-1;\n\t\tfor(char i:arr)ret[start--] = i;\n\t\tString ret1 = \"\";\n\t\tfor(char ch:ret)ret1+=ch;\n\t\treturn ret1;\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "import traceback\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin = IOWrapper(sys.stdin)\n# sys.stdout = IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n#####################################################################\n\nimport math\nfrom collections import defaultdict as dfd, defaultdict, Counter, deque\nfrom functools import lru_cache\nfrom itertools import accumulate\nfrom heapq import *\nfrom bisect import *\n# from sortedcontainers import SortedList\n\ndef geti():\n    return int(input())\n\ndef gets():\n    return input()\n\ndef getil():\n    return list(map(int, input().split()))\n\ndef getsl():\n    return input().split()\n\ndef getinps(s):\n    inps = s.split()\n    m = {'i': geti, 's': gets, 'il': getil, 'sl': getsl}\n    if len(inps) == 1: return m[s]()\n    return [m[k]() for k in inps]\n\ndef get2d(nrows, ncols, n=0):\n    return [[n] * ncols for r in range(nrows)]\n\ndef get_acc(a):\n    return list(accumulate(a))\n\ndef get_ncr(n, r, mod=10**9+7):\n    num = den = 1\n    r = min(r, n-r)\n    for i in range(r):\n        num = (num * (n - i)) % mod\n        den = (den * (i + 1)) % mod\n    return num * pow(den, mod - 2, mod) % mod\n\ndef get_nc2(n):\n    return n * (n-1) // 2\n    \ndef get_npr(n, r):\n    if n < r: return 0\n    return math.factorial(n) // math.factorial(r) \n\ndef put(a):\n    return ' '.join(map(str, a))\n\n# sys.stdin = open('input.txt', 'r')\n# sys.stdout = open('output.txt', 'w')\n\n# while y:\n#     x, y = y, x % y\n\n# graph = dfd(list)\n# for _ in range(N):\n#     u, v = getil()\n#     graph[u].append(v)\n#     graph[v].append(u)\n\nALPHABETS = 'abcdefghijklmnopqrstuvwxyz'\nVOWELS = 'aeiou'\nCONSONANTS = 'bcdfghjklmnpqrstvwxyz'\n\ninf = float('inf')\nmod = 10 ** 9 + 7\n\n\nclass Solution():\n    def main(self):\n        (N, ) = getil()    \n        graph = dfd(list)\n        deg = Counter()\n        for i in range(N):\n            a = getil()[1:]\n            a.sort()\n            for j in a:\n                graph[j-1].append(i)\n                deg[i] += 1\n        cur = [i for i in range(N) if deg[i] == 0]\n        ans = 0\n        while cur:\n            r = -1\n            nxt = []\n            heapify(cur)\n            while cur:\n                if cur[0] < r:\n                    nxt.append(heappop(cur))\n                    continue\n                r = heappop(cur)\n                for nei in graph[r]:\n                    deg[nei] -= 1\n                    if deg[nei] == 0:\n                        heappush(cur, nei)\n            cur = nxt\n            ans += 1\n        if all([deg[i] == 0 for i in range(N)]):\n            return ans\n        else:\n            return -1\n                \n\n\n\ntry:\n    Sol = Solution()\n    Test = geti()\n    for _ in range(Test):\n        ans = Sol.main()  \n        print(ans)      \nexcept Exception as e:\n    print(e)\n    traceback.print_exc()"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\n/** Built using CHelper plug-in Actual solution is at the top */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solution solver = new Solution();\n        boolean multipleTC = true;\n        int testCount = multipleTC ? Integer.parseInt(in.next()) : 1;\n        for (int i = 1; i <= testCount; i++) solver.solve(in, out, i);\n        out.close();\n    }\n\n    static class Solution {\n        PrintWriter out;\n        InputReader in;\n\n        ArrayList<Integer>[] adj;\n        boolean[] vis;\n        int[] color;\n        boolean dfs(int v) {\n            color[v] = 1;\n            for (int u : adj[v]) {\n                if (color[u] == 0) {\n                    if (dfs(u))\n                        return true;\n                } else if (color[u] == 1) {\n                    return true;\n                }\n            }\n            color[v] = 2;\n            return false;\n        }\n        public void solve(InputReader in, PrintWriter out, int test) {\n            this.out = out;\n            this.in = in;\n\n            int n = ni();\n            int[] inDeg = new int[n];\n            adj = new ArrayList[n];\n            for(int i = 0; i < n; i++)\n                adj[i] = new ArrayList<>();\n            color = new int[n];\n            vis = new boolean[n];\n            for(int i = 0; i < n; i++) {\n                int k = ni();\n                for(int j = 0; j < k; j++) {\n                    int x = ni() - 1;\n                    adj[x].add(i);\n                }\n                inDeg[i] = k;\n            }\n\n            boolean ok = false;\n            for(int i = 0; i < n; i++) {\n                if(color[i] == 0)\n                    ok |= dfs(i);\n            }\n            if(ok) {\n                pn(-1);\n                return;\n            }\n\n            TreeSet<Integer> set = new TreeSet<>();\n            for(int i = 0; i < n; i++) {\n                if(inDeg[i] == 0)\n                    set.add(i);\n            }\n\n            int iter = 0;\n            while(set.size() > 0) {\n                int curr = set.first();\n                while(set.ceiling(curr) != null) {\n                    int val = set.ceiling(curr);\n                    for(int x: adj[val]) {\n                        inDeg[x]--;\n                        if(inDeg[x] == 0) {\n                            set.add(x);\n                        }\n                    }\n                    set.remove(val);\n                    curr = val + 1;\n                }\n                iter++;\n            }\n\n            pn(iter);\n        }\n\n        static final Comparator<Pair> com = new Comparator<Pair>() {\n            @Override\n            public int compare(Pair o1, Pair o2) {\n                if(o1.x != o2.x)\n                    return Integer.compare(o1.x, o2.x);\n                return Integer.compare(o1.y, o2.y);\n            }\n        };\n\n        String n() {\n            return in.next();\n        }\n\n        int ni() {\n            return in.nextInt();\n        }\n\n        long nl() {\n            return in.nextLong();\n        }\n\n        void pn(long zx) {\n            out.println(zx);\n        }\n\n        void pn(String sz) {\n            out.println(sz);\n        }\n\n        void pn(double dx) {\n            out.println(dx);\n        }\n\n        class Pair {\n            int x, y;\n            Pair(int u, int v) {\n                this.x = u;\n                this.y = v;\n            }\n        }\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new UnknownError();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new UnknownError();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public String next() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuffer res = new StringBuffer();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.File;\nimport java.io.IOException;\nimport java.util.*;\n\npublic class Solution {\n   private static final List<Integer>[] graph = new List[2_000_01];\n   private static final int[] colors = new int[2_000_01];\n   private static final int[] ans = new int[2_000_01];\n   static {\n       for (int i = 0 ; i < 2_00_001 ; ++i) graph[i] = new ArrayList<>();\n   }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int t = scanner.nextInt();\n        StringBuilder stringBuilder = new StringBuilder();\n        for (int z = 0; z < t; ++z) {\n            solve(scanner, stringBuilder);\n        }\n        System.out.println(stringBuilder);\n    }\n\n    private static void solve(Scanner scanner, StringBuilder stringBuilder) {\n       int n = scanner.nextInt();\n       for (int i = 0 ; i < n ; ++i) {\n           graph[i].clear();\n           colors[i] = 0;\n           ans[i] = Integer.MAX_VALUE;\n       }\n       for (int i = 0 ; i < n ; ++i) {\n           int k = scanner.nextInt();\n           for (int j = 0 ; j < k ; ++j) {\n               int to = scanner.nextInt() - 1;\n               graph[i].add(to);\n           }\n       }\n       List<Integer> topological = new ArrayList<>();\n       for (int i = 0 ; i < n ; ++i) {\n           if (colors[i] == 0) {\n               if (isCycled(i, topological)) {\n                   stringBuilder.append(\"-1\\n\");\n                   return;\n               }\n           }\n       }\n       for (int i = n - 1 ; i >= 0 ; --i) {\n           dfs(topological.get(i));\n       }\n       int ans = 1;\n       for (int i = 0 ; i < n ; ++i) ans = Math.max(ans, Solution.ans[i]);\n       stringBuilder.append(ans).append('\\n');\n    }\n\n    private static boolean isCycled(int vert, List<Integer> topologicalSort) {\n       colors[vert] = 1;\n       for (int to : graph[vert]) {\n           if (colors[to] == 1) return true;\n           if (colors[to] == 0) {\n               if (isCycled(to, topologicalSort)) return true;\n           }\n       }\n       colors[vert] = 2;\n       topologicalSort.add(vert);\n       return false;\n    }\n\n    private static void dfs(int vert) {\n       if (ans[vert] != Integer.MAX_VALUE) return;\n       if (graph[vert].isEmpty()) {\n           ans[vert] = 1;\n           return;\n       }\n       int current = 1;\n       for (int to : graph[vert]) {\n           if (ans[to] == Integer.MAX_VALUE) {\n               dfs(to);\n           }\n           int t = ans[to];\n           if (to > vert) t++;\n           current = Math.max(current, t);\n       }\n       ans[vert] = current;\n    }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mxn = 2e5;\nint n, t, dp[mxn], ct;\nvector<int> adj[mxn], ans;\nbool vis[mxn], act[mxn], cycle;\nvoid dfs(int u) {\n  vis[u] = 1;\n  act[u] = 1;\n  dp[u] = 1;\n  for (int a : adj[u]) {\n    if (act[a]) {\n      cycle = true;\n    } else {\n      if (!vis[a] && !cycle) {\n        dfs(a);\n      }\n    }\n    if (a > u) {\n      dp[u] = max(dp[u], dp[a] + 1);\n    } else {\n      dp[u] = max(dp[u], dp[a]);\n    }\n  }\n  ct = max(ct, dp[u]);\n  act[u] = 0;\n  ans.push_back(u);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> t;\n  while (t--) {\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n      int k;\n      cin >> k;\n      for (int j = 0; j < k; j++) {\n        int c;\n        cin >> c;\n        c--;\n        adj[i].push_back(c);\n      }\n    }\n    for (int i = 0; i < n; i++) {\n      if (!vis[i]) {\n        dfs(i);\n      }\n    }\n    if (!cycle) {\n      cout << ct << \"\\n\";\n    } else {\n      cout << \"-1\\n\";\n    }\n    for (int i = 0; i < n; i++) {\n      adj[i].clear();\n    }\n    ct = 0;\n    ans.clear();\n    fill(vis, vis + n, false);\n    cycle = false;\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main\n{\n    //static Scanner input= new Scanner();\n    //static FastReader input=new FastReader();\n    static UltraFastReader input = new UltraFastReader();\n    static BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));\n    // Output format => out.append(\"Your Data\")+\"\\n\");\n    \n    \n    \n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\t// your code goes here\n\t\t// Output format => out.append(\"Your Data\")+\"\\n\");\n\n\t\tint t = input.nextInt();\n\t\twhile(t-->0){\n\t\t   int n = input.nextInt();\n\t\t   \n\t\t   int [] in = new int[n+1];\n\t\t   int [] out = new int[n+1];\n\t\t   \n\t\t   ArrayList<Integer>[] graph = new ArrayList[n+1];\n\t\t   for(int i=0;i<=n;i++){\n\t\t       graph[i] = new ArrayList<Integer>();\n\t\t   }\n\t\t   \n\t\t   for(int i=1;i<=n;i++){\n\t\t       int k = input.nextInt();\n\t\t       for(int j=1;j<=k;j++){\n\t\t           int adj = input.nextInt();\n\t\t           out[i]++;\n\t\t           in[adj]++;\n\t\t           graph[adj].add(i);\n\t\t       }\n\t\t   }\n\t\t   \n\t\t   PriorityQueue<Integer> queue = new PriorityQueue<>();\n\t\t    PriorityQueue<Integer> queue2 = new PriorityQueue<>();\n\t\t   HashSet<Integer> set = new HashSet<>();\n\t\t   for(int i=1;i<=n;i++){\n\t\t       set.add(i);\n\t\t   }\n\t\t   \n\t\t   int count = 0;\n\t\t   boolean flag = true;\n\t\t   \n\t\t    for(int i:set){\n\t\t           if(out[i]==0){\n    \t\t           queue.add(i);\n    \t\t       }\n\t\t       }\n\t\t   \n\t\t   while(!set.isEmpty()){\n\t\t       count++;\n\t\t      \n\t\t       \n\t\t       if(queue.isEmpty()){\n\t\t           flag = false;\n\t\t           break;\n\t\t       }\n\t\t       \n\t\t       while(!queue.isEmpty()){\n    \t\t       int curr = queue.remove();\n    \t\t       for(int j:graph[curr]){\n    \t\t           out[j]--;\n    \t\t           \n    \t\t           if(out[j]==0){\n    \t\t               \n    \t\t               if(j<curr){\n    \t\t                   queue2.add(j);\n    \t\t               }\n    \t\t               else{\n    \t\t                   queue.add(j);\n    \t\t               }\n    \t\t               \n    \t\t           }\n    \t\t       }\n    \t\t       \n    \t\t       set.remove(curr);\n    \t\t       \n    \t\t       \n    \t\t   }\n    \t\t   \n    \t\t   queue = queue2;\n    \t\t   queue2 = new PriorityQueue<>();\n\t\t       \n\t\t   }\n\t\t   \n\t\t   if(flag==false){\n\t\t      System.out.println(\"-1\");\n\t\t   }\n\t\t   else{\n\t\t       System.out.println(count);\n\t\t   }\n\t\t   \n\t\t   \n\t\t   \n\t\t  \n\t\t   \n\t\t    \n\t\t}\n\t\t\n\t\tout.flush();\n\t\tout.close();\n\t}\n\t\n\tpublic static ArrayList<LinkedList<Integer>> createUndirectedGraph(int n, int m) throws IOException{\n        //This function will create graph with n nodes and m edges.\n        // It can also create a undirected tree if you pass value m as n-1\n        ArrayList<LinkedList<Integer>> graph = new ArrayList<>();\n        for(int i=0;i<=n;i++){\n            graph.add(new LinkedList<>());\n        }\n        \n        for(int i=1;i<=m;i++){\n            int u = input.nextInt();\n            int v= input.nextInt();\n                graph.get(u).add(v);\n                graph.get(v).add(u);\n        }\n        \n        return graph;\n    }\n\t\n\t\n\tstatic void merge(int arr[], int l, int m, int r)\n    {\n        // Find sizes of two subarrays to be merged\n        int n1 = m - l + 1;\n        int n2 = r - m;\n \n        /* Create temp arrays */\n        int L[] = new int[n1];\n        int R[] = new int[n2];\n \n        /*Copy data to temp arrays*/\n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n \n        /* Merge the temp arrays */\n \n        // Initial indexes of first and second subarrays\n        int i = 0, j = 0;\n \n        // Initial index of merged subarry array\n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            }\n            else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n \n        /* Copy remaining elements of L[] if any */\n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n \n        /* Copy remaining elements of R[] if any */\n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n \n    // Main function that sorts arr[l..r] using\n    // merge()\n    static void mergeSort(int arr[], int l, int r)\n    {\n        if (l < r) {\n            // Find the middle point\n            int m =l+ (r-l)/2;\n \n            // Sort first and second halves\n            mergeSort(arr, l, m);\n            mergeSort(arr, m + 1, r);\n \n            // Merge the sorted halves\n            merge(arr, l, m, r);\n        }\n    }\n\t\n\tpublic static int modPower(int x, int y, int p)\n  {\n    int res = 1; // Initialize result\n \n    x = x % p; // Update x if it is more than or\n    // equal to p\n \n    if (x == 0)\n      return 0; // In case x is divisible by p;\n \n    while (y > 0)\n    {\n \n      // If y is odd, multiply x with result\n      if ((y & 1) != 0)\n        res = (res * x) % p;\n \n      // y must be even now\n      y = y >> 1; // y = y/2\n      x = (x * x) % p;\n    }\n    return res;\n  }\n\t\n\t public static LinkedList<Integer> getDivisors(int n){\n        LinkedList <Integer> res = new LinkedList<>();\n        for(int i=1;i*i<=n;i++){\n            if(n%i==0){\n                res.add(i);\n                if(i*i!=n){\n                    res.add(n/i);\n                }\n            }\n        }\n        return res;\n    }\n    \n    \n    public static void printLL(LinkedList<Integer> ll) throws IOException{\n        out.append(\"{\");\n        for(int i:ll){\n            out.append(i+\" \");\n        }\n        out.append(\"}\\n\");\n    }\n    \n    public static boolean isPrime(int n) throws IOException{\n        for(int i=2;i*i<=n;i++){\n            if(n%i==0){\n                return false;\n            }\n        }\n        return true;\n    }\n\t\n\t\n\t//// Fast Reader Start\n\tstatic class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader()\n        {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        public String [] nextStrings(int n) throws IOException{\n            String [] res = new String[n];\n            for(int i=0;i<n;i++){\n                res[i] = next();\n            }\n            return res;\n        }\n        \n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n        \n        public int [] nextInts(int n) throws IOException{\n            int [] res = new int[n];\n            for(int i=0;i<n;i++){\n                res[i] = input.nextInt();\n            }\n            return res;\n        }\n        \n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n        \n        public long [] nextLongs(int n) throws IOException{\n            long [] res = new long[n];\n            for(int i=0;i<n;i++){\n                res[i] = input.nextLong();\n            }\n            return res;\n        }\n        \n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n        \n        public double [] nextDoubles(int n) throws IOException{\n            double [] res = new double[n];\n            for(int i=0;i<n;i++){\n                res[i] = input.nextDouble();\n            }\n            return res;\n        }\n        \n        String nextLine()\n        {\n            String str=\"\";\n            try\n            {\n                str=br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    \n    //// Fast Reader End\n    \n    \n    //// Ultra Fast Reader Start\n    \n    static class UltraFastReader {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n \n        public UltraFastReader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n \n        public UltraFastReader(String file_name) throws IOException\n        {\n            din = new DataInputStream(\n                new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n \n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') {\n                    if (cnt != 0) {\n                        break;\n                    }\n                    else {\n                        continue;\n                    }\n                }\n                buf[cnt++] = (byte)c;\n            }\n            return new String(buf, 0, cnt);\n        }\n \n        public int nextInt() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') {\n                c = read();\n            }\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n \n            if (neg)\n                return -ret;\n            return ret;\n        }\n        \n        public int [] nextInts(int n) throws IOException{\n            int [] res = new int[n];\n            for(int i=0;i<n;i++){\n                res[i] = input.nextInt();\n            }\n            return res;\n        }\n \n        public long nextLong() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n        \n         public long [] nextLongs(int n) throws IOException{\n            long [] res = new long[n];\n            for(int i=0;i<n;i++){\n                res[i] = input.nextLong();\n            }\n            return res;\n        }\n \n        public double nextDouble() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n \n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n \n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n \n            if (neg)\n                return -ret;\n            return ret;\n        }\n        \n         public double [] nextDoubles(int n) throws IOException{\n            double [] res = new double[n];\n            for(int i=0;i<n;i++){\n                res[i] = input.nextDouble();\n            }\n            return res;\n        }\n \n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0,\n                                 BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n \n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n \n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n    //// Ultra  Fast Reader End\n    \n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 7;\nint indeg[maxn];\nvector<int> g[maxn];\npriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>\n    q;\nint main() {\n  int T;\n  cin >> T;\n  while (T--) {\n    int n;\n    cin >> n;\n    while (!q.empty()) q.pop();\n    for (int i = 1; i <= n; i++) g[i].clear();\n    for (int i = 1; i <= n; i++) {\n      cin >> indeg[i];\n      if (!indeg[i]) q.push(make_pair(1, i));\n      for (int j = 1; j <= indeg[i]; j++) {\n        int k;\n        cin >> k;\n        g[k].push_back(i);\n      }\n    }\n    int cnt = 0, ans = -1;\n    while (!q.empty()) {\n      auto tp = q.top();\n      ans = tp.first;\n      q.pop();\n      cnt++;\n      for (int i : g[tp.second]) {\n        indeg[i]--;\n        if (!indeg[i]) {\n          if (i > tp.second)\n            q.push(make_pair(ans, i));\n          else\n            q.push(make_pair(ans + 1, i));\n        }\n      }\n    }\n    if (cnt != n) ans = -1;\n    cout << ans << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main4 {\n    public static void main(String[] args) {\n        FastReader in = new FastReader(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int t = in.nextInt();\n\n        while(t-- > 0) {\n            int n = in.nextInt();\n\n            int[] ans = new int[n];\n            int[] depsNumber = new int[n];\n            Map<Integer, Set<Integer>> graph = new HashMap<>();\n            Queue<Integer> tops = new LinkedList<>();\n\n            for(int i = 0; i < n; i++) {\n                ans[i] = 1;\n                int depNumber = in.nextInt();\n                depsNumber[i] = depNumber;\n\n                if(depNumber == 0) {\n                    tops.add(i);\n                }\n\n                graph.putIfAbsent(i, new HashSet<>());\n                for(int j = 0; j < depNumber; j++) {\n                    int top = in.nextInt() - 1;\n                    graph.putIfAbsent(top, new HashSet<>());\n                    graph.get(top).add(i);\n                }\n            }\n\n            int visited = 0;\n            while(!tops.isEmpty()) {\n                visited++;\n                int top = tops.poll();\n                for(int dependentTop : graph.get(top)) {\n                    if(dependentTop > top) {\n                        ans[dependentTop] = Math.max(ans[dependentTop], ans[top]);\n                    } else {\n                        ans[dependentTop] = Math.max(ans[dependentTop], ans[top] + 1);\n                    }\n\n                    depsNumber[dependentTop]--;\n\n                    if(depsNumber[dependentTop] == 0) {\n                        tops.add(dependentTop);\n                    }\n                }\n            }\n\n            if(visited != n) {\n                pw.println(-1);\n                continue;\n            }\n\n            int answer = Arrays.stream(ans).max().orElse(-1);\n\n            pw.println(answer);\n        }\n\n        pw.close();\n    }\n\n    static class FastReader {\n        private final int BS = 1 << 16;\n        private final char NC = (char) 0;\n        private final byte[] buf = new byte[BS];\n        private final BufferedInputStream in;\n        private int bId = 0;\n        private int size = 0;\n        private char c = NC;\n        private double cnt = 1;\n\n        public FastReader(InputStream is) {\n            in = new BufferedInputStream(is, BS);\n        }\n\n        private char getChar() {\n            while(bId == size) {\n                try {\n                    size = in.read(buf);\n                } catch(Exception e) {\n                    return NC;\n                }\n\n                if(size == -1) {\n                    return NC;\n                }\n                bId = 0;\n            }\n\n            return (char) buf[bId++];\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            cnt = 1;\n            boolean neg = false;\n            if(c == NC) c = getChar();\n            for(; (c < '0' || c > '9'); c = getChar()) {\n                if(c == '-') neg = true;\n            }\n            long res = 0;\n            for(; c >= '0' && c <= '9'; c = getChar()) {\n                res = (res << 3) + (res << 1) + c - '0';\n                cnt *= 10;\n            }\n            return neg ? -res : res;\n        }\n\n        public double nextDouble() {\n            double cur = nextLong();\n            return c != '.' ? cur : cur + nextLong() / cnt;\n        }\n\n        public String next() {\n            StringBuilder res = new StringBuilder();\n            while(c <= 32) c = getChar();\n            while(c > 32) {\n                res.append(c);\n                c = getChar();\n            }\n            return res.toString();\n        }\n\n        public String nextLine() {\n            StringBuilder res = new StringBuilder();\n            while(c <= 32) {\n                c = getChar();\n            }\n\n            while(c != '\\n') {\n                res.append(c);\n                c = getChar();\n            }\n\n            return res.toString();\n        }\n\n        public boolean hasNext() {\n            if(c > 32) {\n                return true;\n            }\n\n            while(true) {\n                c = getChar();\n                if(c == NC) {\n                    return false;\n                } else if(c > 32) {\n                    return true;\n                }\n            }\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long> adj[200001], radj[200001];\nlong long in[200001];\nlong long dp[200001];\nvoid play() {\n  long long n, cnt = 0;\n  cin >> n;\n  for (long long i = 1; i <= n; i++) {\n    adj[i].clear();\n    radj[i].clear();\n    in[i] = 0;\n    dp[i] = 1;\n  }\n  for (long long i = 1; i <= n; i++) {\n    long long k;\n    cin >> k;\n    for (long long j = 0; j < k; j++) {\n      long long a;\n      cin >> a;\n      adj[a].push_back(i);\n      radj[i].push_back(a);\n      in[i]++;\n    }\n  }\n  vector<long long> topo;\n  queue<long long> q;\n  for (long long i = 1; i <= n; i++)\n    if (in[i] == 0) q.push(i);\n  while (!q.empty()) {\n    long long node = q.front();\n    q.pop();\n    cnt++;\n    topo.push_back(node);\n    for (auto x : adj[node]) {\n      --in[x];\n      if (in[x] == 0) q.push(x);\n    }\n  }\n  if (cnt != n) {\n    cout << -1 << \"\\n\";\n    return;\n  }\n  long long ans = 1;\n  for (auto v : topo) {\n    for (auto u : radj[v]) {\n      if (u < v)\n        dp[v] = max(dp[v], dp[u]);\n      else\n        dp[v] = max(dp[v], dp[u] + 1);\n    }\n    ans = max(ans, dp[v]);\n  }\n  cout << ans << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long t;\n  t = 1;\n  cin >> t;\n  for (long long i = 1; i < t + 1; i++) {\n    play();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class C {\n\n\tstatic HashMap<Integer, ArrayList<Integer>> map;\n\tstatic ArrayList<Integer> ord;\n\tstatic int[] color, parent, dist;\n\tstatic boolean[] visited;\n\tstatic int[] dp;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n\t\tint t = Integer.parseInt(br.readLine());\n\t\t\n\t\twhile(t --> 0) {\n\t\t\t\n\t\t\tint n = Integer.parseInt(br.readLine());\t\t\t\n\t\t\tmap = new HashMap<Integer, ArrayList<Integer>>();\n\t\t\tcolor = new int[n+1];\n\t\t\tparent = new int[n+1];\n\t\t\tdist = new int[n+1];\n\t\t\tvisited = new boolean[n+1];\n\t\t\tdp = new int[n+1];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\t\n\t\t\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\t\t\t\n\t\t\t\tint k = Integer.parseInt(st.nextToken());\n\t\t\t\t\t\t\t\t\n\t\t\t\tfor(int j = 0; j < k; j++) {\n\t\t\t\t\t\n\t\t\t\t\tint u = Integer.parseInt(st.nextToken());\n\t\t\t\t\t\n\t\t\t\t\tif(!map.containsKey(u))\n\t\t\t\t\t\tmap.put(u, new ArrayList<Integer>());\n\t\t\t\t\t\n\t\t\t\t\tmap.get(u).add(i+1);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tboolean hasCyc = false;\n\t\t\t\n\t\t\tfor(int i = 1; i <= n; i++) {\n\t\t\t\t\n\t\t\t\tif(color[i] == 0 && cyc_check(i)) {\n\t\t\t\t\t\n\t\t\t\t\thasCyc = true;\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(hasCyc) {\n\t\t\t\t\n\t\t\t\tpw.println(-1);\n\t\t\t\t\n\t\t\t}else {\n\t\t\t\t\t\n\t\t\t\tint maxmin = 0;\n\t\t\t\t\n\t\t\t\tArrays.fill(visited, false);\n\t\t\t\t\n\t\t\t\tfor(int i = 1; i <= n; i++)\n\t\t\t\t\tif(!visited[i])\n\t\t\t\t\t\tdfs(i);\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i <= n; i++)\n\t\t\t\t\tmaxmin = Math.max(maxmin, dp[i]);\n\t\t\t\t\n\t\t\t\tpw.println((1+maxmin));\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tpw.flush();\n\t\t\t\n\t\t}\n\t\t\n\t\tpw.close();\n\n\t}\n\t\n\tstatic void dfs(int v) {\n\t\t\n\t\tvisited[v] = true;\n\t\t\n\t\tif(map.containsKey(v)) {\n\t\t\t\n\t\t\tfor(Integer u : map.get(v)) {\n\t\t\t\t\n\t\t\t\tif(!visited[u]) {\n\t\t\t\t\t\n\t\t\t\t\tdfs(u);\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdp[v] = Math.max(dp[v], ((v > u) ? 1 + dp[u] : dp[u]));\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tstatic boolean cyc_check(int v) {\n\t\t\n\t    color[v] = 1;\n\t    \n\t    if(map.containsKey(v)) {\n\t    \t\n\t\t    for (Integer u : map.get(v)) {\n\t\t    \t\n\t\t        if (color[u] == 0) {\n\t\t        \t\n\t\t            parent[u] = v;\n\t\t            \n\t\t            if (cyc_check(u))\n\t\t                return true;\n\t\t            \n\t\t        } else if (color[u] == 1) {\n\t\n\t\t            return true;\n\t\t            \n\t\t        }\n\t\t        \n\t\t    }\n\t\t    \n\t    }\n\t    \n\t    color[v] = 2;\n\t    \n\t    return false;\n\t    \n\t}\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.io.PrintWriter;\nimport java.util.TreeSet;\n\npublic class taskc {\n\tint n;\n\tArrayList<ArrayList<Integer>> g;\n\tArrayList<ArrayList<Integer>> child;\n\tint deg[], vis[], p[];\n\tboolean cycle = false;\n\n\tpublic static void main(String[] args) {\n\t\tFastScanner in = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint tt = in.nextInt();\n\t\tfor(int tc = 0; tc < tt; tc++) {\n\t\t\ttaskc x = new taskc();\n\t\t\tx.solve(in, out);\n\t\t}\n\t\tout.flush();\n\t}\n\n\tvoid solve(FastScanner in, PrintWriter out) {\n\t\tn = in.nextInt();\n\t\tg = new ArrayList<>();\n\t\tchild = new ArrayList<>();\n\t\tdeg = new int[n]; p = new int[n];\n\t\tfor(int i = 0; i < n; i++) g.add(new ArrayList<>());\n\t\tfor(int i = 0; i < n; i++) child.add(new ArrayList<>());\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint k = in.nextInt();\n\t\t\tfor(int j = 0; j < k; j++) {\n\t\t\t\tint x = in.nextInt(); x--;\n\t\t\t\tg.get(x).add(i);\n\t\t\t\tchild.get(i).add(x);\n\t\t\t\tdeg[i] = k;\n\t\t\t}\n\t\t}\n\t\tvis = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(vis[i] == 0) {\n\t\t\t\tp[i] = i;\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\n\t\tif(cycle) {\n\t\t\tout.println(-1);\n\t\t} else {\n\t\t\tint ans = 1;\n\t\t\tTreeSet<Integer> pages = new TreeSet<>();\n\t\t\tfor(int i = 0; i < n; i++) if(deg[i] == 0) pages.add(i);\n\t\t\tint cur = -1;\n\t\t\tint child_read[]=  new int[n];\n\t\t\twhile(!pages.isEmpty()) {\n\t\t\t\tInteger nxt = pages.higher(cur);\n\t\t\t\tif(nxt == null) {\n\t\t\t\t\tcur = -1;\n\t\t\t\t\tans++;\n\t\t\t\t} else {\n//\t\t\t\t\tout.printf(\"reading book index %d\\n\", nxt+1);\n\t\t\t\t\t// read book nxt\n\t\t\t\t\tcur = nxt;\n\t\t\t\t\tfor(int v : g.get(nxt)) {\n\t\t\t\t\t\tchild_read[v]++;\n\t\t\t\t\t\tif(child_read[v] == deg[v]) {\n\t\t\t\t\t\t\tpages.add(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpages.remove(nxt);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\n\tvoid dfs(int u) {\n\t\tvis[u] = 1;\n\t\tfor(int v : g.get(u)) {\n\t\t\tif(vis[v] == 0) {\n\t\t\t\tp[v] = u;\n\t\t\t\tdfs(v);\n\t\t\t} else if(vis[v] == 1) {\n\t\t\t\tcycle = true;\n\t\t\t}\n\t\t}\n\t\tvis[u] = 2;\n\t}\n\n\tstatic class FastScanner {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer tok = new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile(!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tfloat nextFloat() {\n\t\t\treturn Float.parseFloat(next());\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> book[(200001)];\nint status[(200001)];\nint rTimes[(200001)];\nvoid deepFind(int chapter, bool &deadLock) {\n  status[chapter] = (1);\n  for (int i : book[chapter]) {\n    switch (status[i]) {\n      case (1):\n        deadLock = true;\n        return;\n      case (0):\n        deepFind(i, deadLock);\n    }\n  }\n  status[chapter] = (2);\n}\nvoid readChapter(int chapter) {\n  status[chapter] = (2);\n  if (book[chapter].empty()) {\n    rTimes[chapter] = 1;\n    return;\n  }\n  for (int require : book[chapter]) {\n    if (status[require] == (0)) readChapter(require);\n    if (require > chapter) {\n      rTimes[chapter] = max(rTimes[chapter], rTimes[require] + 1);\n    } else {\n      rTimes[chapter] = max(rTimes[chapter], rTimes[require]);\n    }\n  }\n}\nvoid solve() {\n  int chapters;\n  cin >> chapters;\n  for (int i = 1; i <= chapters; i++) {\n    book[i].clear();\n    status[i] = (0);\n    rTimes[i] = 0;\n    int amount, require;\n    cin >> amount;\n    for (int j = 0; j < amount; j++) {\n      cin >> require;\n      book[i].push_back(require);\n    }\n  }\n  bool deadLock = false;\n  for (int i = 1; i <= chapters; i++) {\n    if (status[i] == (0)) {\n      deepFind(i, deadLock);\n      if (deadLock) {\n        cout << -1 << endl;\n        return;\n      }\n    }\n  }\n  for (int i = 1; i <= chapters; i++) status[i] = (0);\n  for (int i = 1; i <= chapters; i++) {\n    if (status[i] == (0)) readChapter(i);\n  }\n  int result = 0;\n  for (int i = 1; i <= chapters; i++) result = max(result, rTimes[i]);\n  cout << result << endl;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int cases;\n  cin >> cases;\n  for (int i = 0; i < cases; i++) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint expo(int x, int y) {\n  int res = 1;\n  while (y) {\n    if (y % 2) res = (res * x % 1000000007) % 1000000007;\n    x = (x * x) % 1000000007;\n    y /= 2;\n  }\n  return res;\n}\nbool isPrime(long long n) {\n  if (n <= 1) return false;\n  if (n <= 3) return true;\n  if (n % 2 == 0 || n % 3 == 0) return false;\n  for (long long i = 5; i * i <= n; i = i + 6)\n    if (n % i == 0 || n % (i + 2) == 0) return false;\n  return true;\n}\nlong long nextPrime(long long N) {\n  if (N <= 1) return 2;\n  long long prime = N;\n  bool found = false;\n  while (!found) {\n    prime++;\n    if (isPrime(prime)) found = true;\n  }\n  return prime;\n}\nlong long cl(long long n, long long d) { return (n + d - 1) / d; }\nlong long binToDec(string s) { return bitset<64>(s).to_ullong(); }\nstring decToBin(long long a) { return bitset<64>(a).to_string(); }\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long lcm(long long a, long long b) { return (a * b) / (gcd(a, b)); }\nvoid print(pair<long long, long long> a) {\n  cout << a.first << ' ' << a.second;\n  cout << endl;\n  ;\n}\nvoid print(long long a) {\n  cout << a;\n  cout << endl;\n}\nvoid print(std::vector<long long> a) {\n  for (auto i : a) cout << i << ' ';\n  cout << endl;\n  ;\n}\nvoid print(string s) {\n  cout << s;\n  cout << endl;\n  ;\n}\nvoid printr(std::vector<long long> a, long long start, long long end) {\n  for (long long i = start; i < end; i++) cout << a[i] << ' ';\n  cout << endl;\n  ;\n}\nvoid print(long long a, long long b) { cout << a << ' ' << b; }\nvoid amax(long long &a, long long b) { a = max(a, b); }\nvoid amin(long long &a, long long b) { a = min(a, b); }\nlong long madd(long long a, long long b) {\n  return ((a % 1000000007) + (b % 1000000007)) % 1000000007;\n}\nlong long mmul(long long a, long long b) {\n  return ((a % 1000000007) * (b % 1000000007)) % 1000000007;\n}\nlong long msub(long long a, long long b) {\n  return ((a % 1000000007) - (b % 1000000007) + 1000000007) % 1000000007;\n}\nlong long fpow(long long x, long long y, long long p = 1000000007) {\n  x %= p;\n  long long sum = 1;\n  while (y) {\n    if (y & 1) sum = sum * x;\n    sum %= p;\n    y = y >> 1;\n    x = x * x;\n    x %= p;\n  }\n  return sum;\n}\nbool isPerSquare(long double a) {\n  if (a < 0) return false;\n  long long sr = sqrt(a);\n  return (sr * sr == a);\n}\nbool isPalindrome(string str) {\n  long long low = 0, high = long long(str.size()) - 1;\n  while (low < high) {\n    if (str[low] != str[high]) return false;\n    low++, high--;\n  }\n  return true;\n}\nvoid solve() {\n  long long n;\n  cin >> n;\n  ;\n  vector<set<long long>> vp(n + 1);\n  for (__typeof(n + 1) i = (1) - ((1) > (n + 1));\n       i != (n + 1) - ((1) > (n + 1)); i += 1 - 2 * ((1) > (n + 1))) {\n    long long x;\n    cin >> x;\n    ;\n    set<long long> temp;\n    for (__typeof(x) i = (0) - ((0) > (x)); i != (x) - ((0) > (x));\n         i += 1 - 2 * ((0) > (x))) {\n      long long y;\n      cin >> y;\n      ;\n      temp.insert(y);\n    }\n    vp[i] = temp;\n  }\n  vector<vector<long long>> dependent(n + 1);\n  set<long long> books;\n  for (long long i = 1; i <= n; i++) {\n    for (auto j : vp[i]) {\n      dependent[j].push_back(i);\n    }\n  }\n  long long ans = 1;\n  for (long long i = 1; i <= n; i++) {\n    if (long long(vp[i].size()) == 0) {\n      books.insert(i);\n    }\n  }\n  long long rem = 0;\n  while (long long(books.size())) {\n    bool added = false, erased = false;\n    std::vector<long long> add;\n    auto i = *books.begin();\n    while (1) {\n      if (!added && long long(dependent[i].size()) && dependent[i][0] < i) {\n        added = true;\n        ans++;\n      }\n      for (long long j = 0; j < long long(dependent[i].size()); j++) {\n        vp[dependent[i][j]].erase(i);\n        if (long long(vp[dependent[i][j]].size()) == 0) {\n          books.insert(dependent[i][j]);\n        }\n      }\n      dependent[i].clear();\n      rem++;\n      books.erase(i);\n      if (rem == n) {\n        print(ans);\n        return;\n      }\n      if (books.upper_bound(i) == books.end()) {\n        break;\n      } else {\n        i = *books.upper_bound(i);\n      }\n    }\n  }\n  print(-1);\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  long long t;\n  cin >> t;\n  while (t--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint expo(int x, int y) {\n  int res = 1;\n  while (y) {\n    if (y % 2) res = (res * x % 1000000007) % 1000000007;\n    x = (x * x) % 1000000007;\n    y /= 2;\n  }\n  return res;\n}\nbool isPrime(long long n) {\n  if (n <= 1) return false;\n  if (n <= 3) return true;\n  if (n % 2 == 0 || n % 3 == 0) return false;\n  for (long long i = 5; i * i <= n; i = i + 6)\n    if (n % i == 0 || n % (i + 2) == 0) return false;\n  return true;\n}\nlong long nextPrime(long long N) {\n  if (N <= 1) return 2;\n  long long prime = N;\n  bool found = false;\n  while (!found) {\n    prime++;\n    if (isPrime(prime)) found = true;\n  }\n  return prime;\n}\nlong long cl(long long n, long long d) { return (n + d - 1) / d; }\nlong long binToDec(string s) { return bitset<64>(s).to_ullong(); }\nstring decToBin(long long a) { return bitset<64>(a).to_string(); }\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long lcm(long long a, long long b) { return (a * b) / (gcd(a, b)); }\nvoid print(pair<long long, long long> a) {\n  cout << a.first << ' ' << a.second;\n  cout << endl;\n  ;\n}\nvoid print(long long a) {\n  cout << a;\n  cout << endl;\n}\nvoid print(std::vector<long long> a) {\n  for (auto i : a) cout << i << ' ';\n  cout << endl;\n  ;\n}\nvoid print(string s) {\n  cout << s;\n  cout << endl;\n  ;\n}\nvoid printr(std::vector<long long> a, long long start, long long end) {\n  for (long long i = start; i < end; i++) cout << a[i] << ' ';\n  cout << endl;\n  ;\n}\nvoid print(long long a, long long b) { cout << a << ' ' << b; }\nvoid amax(long long &a, long long b) { a = max(a, b); }\nvoid amin(long long &a, long long b) { a = min(a, b); }\nlong long madd(long long a, long long b) {\n  return ((a % 1000000007) + (b % 1000000007)) % 1000000007;\n}\nlong long mmul(long long a, long long b) {\n  return ((a % 1000000007) * (b % 1000000007)) % 1000000007;\n}\nlong long msub(long long a, long long b) {\n  return ((a % 1000000007) - (b % 1000000007) + 1000000007) % 1000000007;\n}\nlong long fpow(long long x, long long y, long long p = 1000000007) {\n  x %= p;\n  long long sum = 1;\n  while (y) {\n    if (y & 1) sum = sum * x;\n    sum %= p;\n    y = y >> 1;\n    x = x * x;\n    x %= p;\n  }\n  return sum;\n}\nbool isPerSquare(long double a) {\n  if (a < 0) return false;\n  long long sr = sqrt(a);\n  return (sr * sr == a);\n}\nbool isPalindrome(string str) {\n  long long low = 0, high = long long(str.size()) - 1;\n  while (low < high) {\n    if (str[low] != str[high]) return false;\n    low++, high--;\n  }\n  return true;\n}\nconst long long N = 2e5;\nvector<set<long long> > indegree(N + 1), out(N + 1);\nvoid solve() {\n  long long n;\n  cin >> n;\n  ;\n  for (__typeof(n + 1) i = (1) - ((1) > (n + 1));\n       i != (n + 1) - ((1) > (n + 1)); i += 1 - 2 * ((1) > (n + 1))) {\n    indegree[i].clear();\n    out[i].clear();\n  }\n  for (__typeof(n + 1) i = (1) - ((1) > (n + 1));\n       i != (n + 1) - ((1) > (n + 1)); i += 1 - 2 * ((1) > (n + 1))) {\n    long long x;\n    cin >> x;\n    ;\n    for (__typeof(x) j = (0) - ((0) > (x)); j != (x) - ((0) > (x));\n         j += 1 - 2 * ((0) > (x))) {\n      long long y;\n      cin >> y;\n      ;\n      indegree[y].insert(i);\n      out[i].insert(y);\n    }\n  }\n  set<long long> sink;\n  for (long long i = 1; i <= n; i++) {\n    if (long long(out[i].size()) == 0) {\n      sink.insert(i);\n    }\n  }\n  long long ans = 1, removed = 0, top;\n  if (long long(sink.size())) top = *sink.begin();\n  while (1) {\n    if (removed == n) {\n      print(ans);\n      return;\n    }\n    if (long long(sink.size()) == 0) {\n      print(-1);\n      return;\n    }\n    sink.erase(top);\n    removed++;\n    for (auto j : indegree[top]) {\n      out[j].erase(top);\n      if (long long(out[j].size()) == 0) {\n        sink.insert(j);\n      }\n    }\n    if (removed == n) {\n      print(ans);\n      return;\n    }\n    if (long long(sink.size()) == 0) {\n      print(-1);\n      return;\n    }\n    if (sink.upper_bound(top) == sink.end()) {\n      top = *sink.begin();\n      ans++;\n    } else {\n      top = *sink.upper_bound(top);\n    }\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  long long t;\n  cin >> t;\n  while (t--) solve();\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.Collection;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.Queue;\nimport java.io.BufferedReader;\nimport java.util.LinkedList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        CBook solver = new CBook();\n        int testCount = Integer.parseInt(in.next());\n        for (int i = 1; i <= testCount; i++)\n            solver.solve(i, in, out);\n        out.close();\n    }\n\n    static class CBook {\n        static ArrayList<Integer>[] g;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            g = new ArrayList[n];\n            for (int i = 0; i < n; i++) {\n                g[i] = new ArrayList<>();\n            }\n            int[] indeg = new int[n];\n            for (int i = 0; i < n; i++) {\n\n                int k = in.nextInt();\n                for (int j = 0; j < k; j++) {\n                    g[in.nextInt() - 1].add(i);\n                    indeg[i]++;\n                }\n            }\n            Queue<Integer> q = new LinkedList<>();\n            int[] dist = new int[n];\n            for (int i = 0; i < n; i++) {\n                if (indeg[i] == 0) {\n                    q.add(i);\n                    dist[i] = 1;\n                }\n            }\n            while (!q.isEmpty()) {\n                int p = q.poll();\n                for (int a : g[p]) {\n                    indeg[a]--;\n                    if (p < a) {\n                        dist[a] = Math.max(dist[a], dist[p]);\n                    } else {\n                        dist[a] = Math.max(dist[a], dist[p] + 1);\n                    }\n                    if (indeg[a] == 0) {\n                        q.add(a);\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                if (indeg[i] > 0) {\n                    out.println(-1);\n                    return;\n                }\n            }\n            long ans = 0;\n            for (int i = 0; i < n; i++) {\n                ans = Math.max(ans, dist[i]);\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin\ninput = stdin.readline\n\nimport heapq\n      \ndef answer():\n\n    ans = 1\n    while(len(q)):\n        \n        lvl , p = heapq.heappop(q)\n        if(done[p]):continue\n        \n        ans = max(ans , lvl)\n\n        x = []\n        for i in range(len(a[p])):\n            count[a[p][i]] -= 1\n\n            if(count[a[p][i]]):continue\n            \n            if(a[p][i] > p):\n                heapq.heappush(q , [lvl , a[p][i]])\n            else:\n                heapq.heappush(q , [lvl + 1, a[p][i]])\n\n        done[p] = True\n            \n\n    if(sum(count)):return -1\n\n    return ans\n \nfor T in range(int(input())):\n\n    n = int(input())\n\n    a = [[] for i in range(n + 1)]\n    count = [0 for i in range(n + 1)]\n\n    q = []\n    done = [False]*(n + 1)\n    \n    for i in range(n):\n        x = list(map(int,input().split()))\n\n        for j in range(1 , x[0] + 1):\n            a[x[j]].append(i + 1)\n            count[i + 1] += 1\n\n        if(x[0] == 0):\n            heapq.heappush(q , [1 , i + 1])\n \n    print(answer())\n"
        },
        {
            "language": 3,
            "solution": "from __future__ import print_function\nfrom math import *\nfrom collections import deque\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n#import time\n \ndef main():\n    pass\n \n# region fastio\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n#sys.stdin, sys.stdout =open(\"test.txt\",\"r\"),open(\"result.txt\",\"w\")\n#ini=time.time()\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nmod=10**9+7\n############ ---- Input Functions ---- ############\ndef inp():\n    return(int(input()))\ndef inlt():\n    return(list(map(int,input().split())))\ndef insr():\n    s = input()\n    return(list(s[:len(s) ]))\ndef invr():\n    return(map(int,input().split()))\nfrom collections import defaultdict\n \nclass Graph():\n    def __init__(self,vertices):\n        self.graph = defaultdict(list)\n        self.V = vertices\n \n    def addEdge(self,u,v):\n        self.graph[u].append(v)\n \n    def isCyclicUtil(self, v, visited, recStack):\n \n        # Mark current node as visited and\n        # adds to recursion stack\n        visited[v] = True\n        recStack[v] = True\n \n        # Recur for all neighbours\n        # if any neighbour is visited and in\n        # recStack then graph is cyclic\n        for neighbour in self.graph[v]:\n            if visited[neighbour] == False:\n                if self.isCyclicUtil(neighbour, visited, recStack) == True:\n                    return True\n            elif recStack[neighbour] == True:\n                return True\n \n        # The node needs to be poped from\n        # recursion stack before function ends\n        recStack[v] = False\n        return False\n \n    # Returns true if graph is cyclic else false\n    def isCyclic(self):\n        visited = [False] * (self.V + 1)\n        recStack = [False] * (self.V + 1)\n        for node in range(self.V):\n            if visited[node] == False:\n                if self.isCyclicUtil(node,visited,recStack) == True:\n                    return True\n        return False\n    def topologicalSortUtil(self, v, visited, stack):\n     \n        # Mark the current node as visited.\n        visited[v] = True\n        # Recur for all the vertices adjacent to this vertex\n        for i in self.graph[v]:\n            if visited[i] == False:\n                self.topologicalSortUtil(i, visited, stack)\n \n        # Push current vertex to stack which stores result\n        stack.append(v)\n \n    # The function to do Topological Sort. It uses recursive\n    # topologicalSortUtil()\n    def topologicalSort(self):\n        # Mark all the vertices as not visited\n        visited = [False]*self.V\n        stack = []\n \n        # Call the recursive helper function to store Topological\n        # Sort starting from all vertices one by one\n        for i in range(self.V):\n            if visited[i] == False:\n                self.topologicalSortUtil(i, visited, stack)\n \n        # Print contents of the stack\n        stack.reverse()\n        return(stack)  # return list in reverse order\nfor _ in range(inp()):\n    n=inp()\n    l=[]\n    for i in range(n):\n        l.append(inlt())\n    g=Graph(n)\n    for i in range(n):\n        for j in range(1,l[i][0]+1):\n            g.addEdge(l[i][j]-1,i)\n    #print(g.graph)\n    if g.isCyclic():\n        print(-1)\n        continue\n    v=[0]*n\n    c=1\n    #l.sort(key=lambda x:(len(x),x[0]))\n    h=g.topologicalSort()\n    for i in range(n-1):\n        if h[i+1]<h[i]:\n            c+=1\n    #print(h,l)\n    for i in h:\n        if l[i][0]==0:\n            v[i]=1\n            continue\n        #print(i)\n        for j in range(1,l[i][0]+1):\n            #print(j,\"a\")\n            if i+1>l[i][j]:\n                v[i]=max(v[l[i][j]-1],v[i])\n            else:\n                v[i]=max(v[l[i][j]-1]+1,v[i])\n    print(max(v))"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class C{\n\t\n\tpublic static void main(String[] args) throws IOException{\n\t\t// br = new BufferedReader(new FileReader(\".in\"));\n\t\t// out = new PrintWriter(new FileWriter(\".out\"));\n\t\t// new Thread(null, new (), \"fisa balls\", 1<<28).start();\n\t\t\n\t\t\n\t\t\n\t\tint t= readInt();\n\t\twhile(t-->0) {\n\t\t\tint n =readInt();\n\t\t\tHashSet<Integer>[] req = new HashSet[n];\n\t\t\tHashSet<Integer>[] rev = new HashSet[n];\n\t\t\tboolean[] vis = new boolean[n];\n\t\t\tTreeSet<Integer> zero = new TreeSet<Integer>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\treq[i] = new HashSet<Integer>();\n\t\t\t\trev[i] = new HashSet<Integer>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint k =readInt();\n\t\t\t\twhile(k-->0) {\n\t\t\t\t\tint x =readInt()-1;\n\t\t\t\t\treq[i].add(x);\n\t\t\t\t\trev[x].add(i);\n\t\t\t\t}\n\t\t\t\tif (req[i].size()==0) zero.add(i);\n\t\t\t}\n\t\t\tint it = 1;\n\t\t\tint cur = 0; // cur ind\n\t\t\t\n\t\t\twhile (!zero.isEmpty()) {\n\t\t\t\tif (zero.ceiling(cur) == null) {\n\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t\tint next = zero.ceiling(cur) == null ? zero.first():zero.ceiling(cur);\n\t\t\t\tzero.remove(next);\n\t\t\t\tvis[next] = true;\n\t\t\t\tcur = next;\n\t\t\t\tfor (int x: rev[next]) {\n\t\t\t\t\treq[x].remove(next);\n\t\t\t\t\tif (req[x].size()==0) zero.add(x);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tboolean works = true;\n\t\t\tfor (boolean b: vis) works &= b;\n\t\t\tout.println(works?it:-1);\n\t\t}\n\t\t\n\t\tout.close();\n\t}\n\t\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tstatic PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tstatic StringTokenizer st = new StringTokenizer(\"\");\n\tstatic String read() throws IOException{\n\t\twhile (!st.hasMoreElements()) st = new StringTokenizer(br.readLine());\n\t\treturn st.nextToken();\n\t}\n\tpublic static int readInt() throws IOException{return Integer.parseInt(read());}\n\tpublic static long readLong() throws IOException{return Long.parseLong(read());}\n}"
        },
        {
            "language": 3,
            "solution": "import os, sys\nfrom io import BytesIO, IOBase\nimport operator as op\nfrom bisect import *\nfrom itertools import chain, repeat, starmap\nfrom functools import reduce\n\n\nclass SortedList():\n    \"\"\"Sorted list is a sorted mutable sequence.\"\"\"\n    DEFAULT_LOAD_FACTOR = 500\n\n    def __init__(self, iterable=None):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        self._len = 0\n        self._load = self.DEFAULT_LOAD_FACTOR\n        self._lists = []\n        self._maxes = []\n        self._index = []\n        self._offset = 0\n        if iterable is not None:\n            self.update(iterable)\n\n    def clear(self):\n        \"\"\"Remove all values from sorted list.\"\"\"\n        self._len = 0\n        del self._lists[:]\n        del self._maxes[:]\n        del self._index[:]\n        self._offset = 0\n\n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\"\"\"\n        _lists = self._lists\n        _maxes = self._maxes\n        if _maxes:\n            pos = bisect_right(_maxes, value)\n            if pos == len(_maxes):\n                _lists[pos - 1].append(value)\n                _maxes[pos - 1] = value\n            else:\n                insort(_lists[pos], value)\n            self._expand(pos)\n        else:\n            _lists.append([value])\n            _maxes.append(value)\n        self._len += 1\n\n    def _expand(self, pos):\n        \"\"\"Split sublists with length greater than double the load-factor.\"\"\"\n        _load = self._load\n        _lists = self._lists\n        _index = self._index\n\n        if len(_lists[pos]) > (_load << 1):\n            _maxes = self._maxes\n            _lists_pos = _lists[pos]\n            half = _lists_pos[_load:]\n            del _lists_pos[_load:]\n            _maxes[pos] = _lists_pos[-1]\n            _lists.insert(pos + 1, half)\n            _maxes.insert(pos + 1, half[-1])\n            del _index[:]\n        else:\n            if _index:\n                child = self._offset + pos\n                while child:\n                    _index[child] += 1\n                    child = (child - 1) >> 1\n                _index[0] += 1\n\n    def update(self, iterable):\n        \"\"\"Update sorted list by adding all values from `iterable`.\"\"\"\n        _lists = self._lists\n        _maxes = self._maxes\n        values = sorted(iterable)\n\n        if _maxes:\n            if len(values) * 4 >= self._len:\n                values.extend(chain.from_iterable(_lists))\n                values.sort()\n                self.clear()\n            else:\n                _add = self.add\n                for val in values:\n                    _add(val)\n                return\n\n        _load = self._load\n        _lists.extend(values[pos:(pos + _load)] for pos in range(0, len(values), _load))\n        _maxes.extend(sublist[-1] for sublist in _lists)\n        self._len = len(values)\n        del self._index[:]\n\n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n        _maxes = self._maxes\n        pos = bisect_left(_maxes, value)\n        if pos == len(_maxes):\n            return False\n\n        _lists = self._lists\n        idx = bisect_left(_lists[pos], value)\n        return _lists[pos][idx] == value\n\n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n        _maxes = self._maxes\n        pos = bisect_left(_maxes, value)\n        if pos == len(_maxes):\n            return\n\n        _lists = self._lists\n        idx = bisect_left(_lists[pos], value)\n        if _lists[pos][idx] == value:\n            self._delete(pos, idx)\n\n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        _maxes = self._maxes\n        _index = self._index\n\n        _lists_pos = _lists[pos]\n        del _lists_pos[idx]\n        self._len -= 1\n\n        len_lists_pos = len(_lists_pos)\n        if len_lists_pos > (self._load >> 1):\n            _maxes[pos] = _lists_pos[-1]\n\n            if _index:\n                child = self._offset + pos\n                while child > 0:\n                    _index[child] -= 1\n                    child = (child - 1) >> 1\n                _index[0] -= 1\n        elif len(_lists) > 1:\n            if not pos:\n                pos += 1\n            prev = pos - 1\n            _lists[prev].extend(_lists[pos])\n            _maxes[prev] = _lists[prev][-1]\n            del _lists[pos]\n            del _maxes[pos]\n            del _index[:]\n            self._expand(prev)\n        elif len_lists_pos:\n            _maxes[pos] = _lists_pos[-1]\n        else:\n            del _lists[pos]\n            del _maxes[pos]\n            del _index[:]\n\n    def _loc(self, pos, idx):\n        \"\"\"Convert an index pair (lists index, sublist index) into a single\n        index number that corresponds to the position of the value in the\n        sorted list.\"\"\"\n        if not pos:\n            return idx\n\n        _index = self._index\n        if not _index:\n            self._build_index()\n        total = 0\n        pos += self._offset\n        while pos:\n            if not pos & 1:\n                total += _index[pos - 1]\n            pos = (pos - 1) >> 1\n        return total + idx\n\n    def _pos(self, idx):\n        \"\"\"Convert an index into an index pair (lists index, sublist index)\n        that can be used to access the corresponding lists position.\"\"\"\n        if idx < 0:\n            last_len = len(self._lists[-1])\n            if (-idx) <= last_len:\n                return len(self._lists) - 1, last_len + idx\n            idx += self._len\n            if idx < 0:\n                raise IndexError('list index out of range')\n        elif idx >= self._len:\n            raise IndexError('list index out of range')\n\n        if idx < len(self._lists[0]):\n            return 0, idx\n\n        _index = self._index\n        if not _index:\n            self._build_index()\n\n        pos = 0\n        child = 1\n        len_index = len(_index)\n        while child < len_index:\n            index_child = _index[child]\n            if idx < index_child:\n                pos = child\n            else:\n                idx -= index_child\n                pos = child + 1\n            child = (pos << 1) + 1\n        return (pos - self._offset, idx)\n\n    def _build_index(self):\n        \"\"\"Build a positional index for indexing the sorted list.\"\"\"\n        row0 = list(map(len, self._lists))\n        if len(row0) == 1:\n            self._index[:] = row0\n            self._offset = 0\n            return\n\n        head = iter(row0)\n        tail = iter(head)\n        row1 = list(starmap(op.add, zip(head, tail)))\n        if len(row0) & 1:\n            row1.append(row0[-1])\n        if len(row1) == 1:\n            self._index[:] = row1 + row0\n            self._offset = 1\n            return\n\n        size = 1 << (len(row1) - 1).bit_length()\n        row1.extend(repeat(0, size - len(row1)))\n        tree = [row0, row1]\n        while len(tree[-1]) > 1:\n            head = iter(tree[-1])\n            tail = iter(head)\n            row = list(starmap(op.add, zip(head, tail)))\n            tree.append(row)\n        reduce(list.__iadd__, reversed(tree), self._index)\n        self._offset = size * 2 - 1\n\n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        if isinstance(index, slice):\n            start, stop, step = index.indices(self._len)\n            if step == 1 and start < stop:\n                if start == 0 and stop == self._len:\n                    return self.clear()\n                elif self._len <= 8 * (stop - start):\n                    values = self.__getitem__(slice(None, start))\n                    if stop < self._len:\n                        values += self.__getitem__(slice(stop, None))\n                    self.clear()\n                    return self.update(values)\n\n            indices = range(start, stop, step)\n            if step > 0:\n                indices = reversed(indices)\n            _pos, _delete = self._pos, self._delete\n            for index in indices:\n                pos, idx = _pos(index)\n                _delete(pos, idx)\n        else:\n            pos, idx = self._pos(index)\n            self._delete(pos, idx)\n\n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        _lists = self._lists\n\n        if isinstance(index, slice):\n            start, stop, step = index.indices(self._len)\n\n            if step == 1 and start < stop:\n                if start == 0 and stop == self._len:\n                    return reduce(list.__iadd__, self._lists, [])\n\n                start_pos, start_idx = self._pos(start)\n                if stop == self._len:\n                    stop_pos = len(_lists) - 1\n                    stop_idx = len(_lists[stop_pos])\n                else:\n                    stop_pos, stop_idx = self._pos(stop)\n                if start_pos == stop_pos:\n                    return _lists[start_pos][start_idx:stop_idx]\n\n                prefix = _lists[start_pos][start_idx:]\n                middle = _lists[(start_pos + 1):stop_pos]\n                result = reduce(list.__iadd__, middle, prefix)\n                result += _lists[stop_pos][:stop_idx]\n                return result\n\n            if step == -1 and start > stop:\n                result = self.__getitem__(slice(stop + 1, start + 1))\n                result.reverse()\n                return result\n\n            indices = range(start, stop, step)\n            return list(self.__getitem__(index) for index in indices)\n        else:\n            if self._len:\n                if index == 0:\n                    return _lists[0][0]\n                elif index == -1:\n                    return _lists[-1][-1]\n            else:\n                raise IndexError('list index out of range')\n\n            if 0 <= index < len(_lists[0]):\n                return _lists[0][index]\n\n            len_last = len(_lists[-1])\n            if -len_last < index < 0:\n                return _lists[-1][len_last + index]\n\n            pos, idx = self._pos(index)\n            return _lists[pos][idx]\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return chain.from_iterable(self._lists)\n\n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return chain.from_iterable(map(reversed, reversed(self._lists)))\n\n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n\n    def bisect_left(self, value):\n        \"\"\"Return an index to insert `value` in the sorted list.\"\"\"\n        pos = bisect_left(self._maxes, value)\n        return self._len if pos == len(self._maxes) else self._loc(pos, bisect_left(self._lists[pos], value))\n\n    def bisect_right(self, value):\n        \"\"\"Return an index to insert `value` in the sorted list.\"\"\"\n        pos = bisect_right(self._maxes, value)\n        return self._len if pos == len(self._maxes) else self._loc(pos, bisect_right(self._lists[pos], value))\n\n    bisect = bisect_right\n\n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n        _maxes = self._maxes\n        if not _maxes:\n            return 0\n\n        pos_left = bisect_left(_maxes, value)\n        if pos_left == len(_maxes):\n            return 0\n\n        _lists = self._lists\n        idx_left = bisect_left(_lists[pos_left], value)\n        pos_right = bisect_right(_maxes, value)\n        if pos_right == len(_maxes):\n            return self._len - self._loc(pos_left, idx_left)\n\n        idx_right = bisect_right(_lists[pos_right], value)\n        if pos_left == pos_right:\n            return idx_right - idx_left\n\n        right = self._loc(pos_right, idx_right)\n        left = self._loc(pos_left, idx_left)\n        return right - left\n\n    def copy(self):\n        \"\"\"Return a shallow copy of the sorted list.\"\"\"\n        return self.__class__(self)\n\n    __copy__ = copy\n\n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n        if not self._len:\n            raise IndexError('pop index out of range')\n\n        _lists = self._lists\n        if 0 <= index < len(_lists[0]):\n            val = _lists[0][index]\n            self._delete(0, index)\n            return val\n\n        len_last = len(_lists[-1])\n        if -len_last < index < 0:\n            pos = len(_lists) - 1\n            loc = len_last + index\n            val = _lists[pos][loc]\n            self._delete(pos, loc)\n            return val\n\n        pos, idx = self._pos(index)\n        val = _lists[pos][idx]\n        self._delete(pos, idx)\n        return val\n\n    def index(self, value, start=0, stop=None):\n        \"\"\"Return first index of value in sorted list.\"\"\"\n        _len = self._len\n        if start < 0:\n            start += _len\n        if start < 0:\n            start = 0\n        if stop is None:\n            stop = _len\n        if stop < 0:\n            stop += _len\n        if stop > _len:\n            stop = _len\n\n        if stop <= start:\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        _maxes = self._maxes\n        pos_left = bisect_left(_maxes, value)\n        if pos_left == len(_maxes):\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        _lists = self._lists\n        idx_left = bisect_left(_lists[pos_left], value)\n        if _lists[pos_left][idx_left] != value:\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        stop -= 1\n        left = self._loc(pos_left, idx_left)\n        if start <= left:\n            if left <= stop:\n                return left\n        else:\n            if start <= self.bisect_right(value) - 1:\n                return start\n        raise ValueError('{0!r} is not in list'.format(value))\n\n    def __add__(self, other):\n        \"\"\"Return new sorted list containing all values in both sequences.\"\"\"\n        values = reduce(list.__iadd__, self._lists, [])\n        values.extend(other)\n        return self.__class__(values)\n\n    __radd__ = __add__\n\n    def __iadd__(self, other):\n        \"\"\"Update sorted list with values from `other`.\"\"\"\n        self.update(other)\n        return self\n\n    def __mul__(self, num):\n        \"\"\"Return new sorted list with `num` shallow copies of values.\"\"\"\n        values = reduce(list.__iadd__, self._lists, []) * num\n        return self.__class__(values)\n\n    __rmul__ = __mul__\n\n    def __imul__(self, num):\n        \"\"\"Update the sorted list with `num` shallow copies of values.\"\"\"\n        values = reduce(list.__iadd__, self._lists, []) * num\n        self.clear()\n        self.update(values)\n        return self\n\n    def __make_cmp(seq_op):\n        \"Make comparator method.\"\n\n        def comparer(self, other):\n            \"Compare method for sorted list and sequence.\"\n            self_len = self._len\n            len_other = len(other)\n            if self_len != len_other:\n                if seq_op is op.eq:\n                    return False\n                if seq_op is op.ne:\n                    return True\n\n            for alpha, beta in zip(self, other):\n                if alpha != beta:\n                    return seq_op(alpha, beta)\n            return seq_op(self_len, len_other)\n\n        comparer.__name__ = '__{0}__'.format(seq_op.__name__)\n        return comparer\n\n    __eq__ = __make_cmp(op.eq)\n    __ne__ = __make_cmp(op.ne)\n    __lt__ = __make_cmp(op.lt)\n    __gt__ = __make_cmp(op.gt)\n    __le__ = __make_cmp(op.le)\n    __ge__ = __make_cmp(op.ge)\n    __make_cmp = staticmethod(__make_cmp)\n\n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return 'SortedList({0})'.format(reduce(list.__iadd__, self._lists, []))\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\ninp = lambda dtype: [dtype(x) for x in input().split()]\ninp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]\ninp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]\ninp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]\ninp_enus = lambda dtype, n: [[i] + inp(dtype) for i in range(n)]\nceil1 = lambda a, b: (a + b - 1) // b\n\n\nclass graph:\n    def __init__(self, n):\n        self.n, self.gdict = n, [[] for _ in range(n + 1)]\n        self.indeg = [0] * (n + 1)\n\n    def addEdge(self, node1, node2, w=None):\n        self.gdict[node1].append(node2)\n        self.indeg[node2] += 1\n\n    def kahn(self, n):\n        # enqueue all node with 0 in degree\n        queue, ans, lst = SortedList([i for i in range(1, n + 1) if not self.indeg[i]] + [10 ** 9]), 1, -1\n        cnt = 0\n\n        while len(queue) > 1:\n            # pop and push into topsort\n            ix = queue.bisect_right(lst)\n\n            if queue[ix] == 10 ** 9:\n                ix = 0\n                ans += 1\n\n            lst = s = queue.pop(ix)\n\n            for i in self.gdict[s]:\n                self.indeg[i] -= 1\n                if not self.indeg[i]:\n                    queue.add(i)\n\n            cnt += 1\n        # check cycle\n        print(-1 if cnt != n else ans)\n\n\nfor _ in range(int(input())):\n    n = int(input())\n    g = graph(n)\n\n    for i in range(n):\n        for x in inp(int)[1:]:\n            g.addEdge(x, i + 1)\n    g.kahn(n)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class C {\n    private static void sport(List<Integer>[] g) {\n        int n = g.length;\n\n        int[] dp = new int[n];\n            List<Integer> topSort = new ArrayList<>();\n            boolean[] marked = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            if (!marked[i]) {\n                dfs2(g, i, topSort,marked);\n            }\n        }\n        Map<Integer,Integer> map = new HashMap<>();\n        for (int i = 0; i < topSort.size(); i++) {\n            map.put(topSort.get(i),i);\n        }\n            for (Integer v : topSort) {\n                for (Integer u : g[v]) {\n                    if (map.get(v)<map.get(u)){\n                        System.out.println(-1);\n                        return;\n                    }\n                    dp[v]=Math.max(dp[v],dp[u]+(v<u?1:0));\n                }\n            }\n        int ans=0;\n        for (int i : dp) {\n            ans=Math.max(ans,i);\n        }\n        System.out.println(ans+1);\n    }\n\n    static void dfs2(List<Integer>[] g, int v,List<Integer> ans,boolean[] m){\n        m[v]=true;\n        for (Integer u : g[v]) {\n            if (!m[u]) {\n                dfs2(g, u, ans, m);\n            }\n        }\n        ans.add(v);\n    }\n\n    public static void main(String[] args) throws IOException {\n        FastScanner sc = new FastScanner();\n        int t = sc.nextInt();\n        for (int i = 0; i < t; i++) {\n            int n = sc.nextInt();\n            List<Integer>[] g= new ArrayList[n];\n            for (int j = 0; j < n; j++) {\n                int k = sc.nextInt();\n                g[j]=new ArrayList<>();\n                for (int l = 0; l < k; l++) {\n                    g[j].add(sc.nextInt()-1);\n                }\n            }\n            sport(g);\n        }\n    }\n\n    static void shuffleArray(int[] ar) {\n        // If running on Java 6 or older, use `new Random()` on RHS here\n        Random rnd = ThreadLocalRandom.current();\n        for (int i = ar.length - 1; i > 0; i--) {\n            int index = rnd.nextInt(i + 1);\n            // Simple swap\n            int a = ar[index];\n            ar[index] = ar[i];\n            ar[i] = a;\n        }\n    }\n\n    static class FastScanner {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        String next() {\n            while (!st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        void nextLine() throws IOException {\n            br.readLine();\n        }\n\n        long[] readArrayLong(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextLong();\n            }\n            return a;\n        }\n\n        int[] readArrayInt(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException{\n        //BufferedReader f = new BufferedReader(new FileReader(\"uva.in\"));\n        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        int t = Integer.parseInt(f.readLine());\n        while(t-- > 0) {\n            int n = Integer.parseInt(f.readLine());\n            ArrayList<ArrayList<Integer>> adjacencyList = new ArrayList<>(n);\n            for(int i = 0; i < n; i++) {\n                adjacencyList.add(new ArrayList<>());\n            }\n            int[] indegree = new int[n];\n            for(int i = 0; i < n; i++) {\n                StringTokenizer st = new StringTokenizer(f.readLine());\n                int k = Integer.parseInt(st.nextToken());\n                indegree[i] = k;\n                for(int j = 0; j < k; j++) {\n                    adjacencyList.get(Integer.parseInt(st.nextToken())-1).add(i);\n                }\n            }\n            Queue<Integer> queue = new LinkedList<>();\n            for(int i = 0; i < n; i++) {\n                if(indegree[i] == 0) {\n                    queue.offer(i);\n                }\n            }\n            int steps = 0;\n            int visited = 0;\n            while(!queue.isEmpty()) {\n                int size = queue.size();\n                PriorityQueue<Integer> level = new PriorityQueue<>();\n                for(int i = 0; i < size; i++) {\n                    level.offer(queue.poll());\n                }\n                while(!level.isEmpty()) {\n                    int cur = level.poll();\n                    visited++;\n                    for(int next: adjacencyList.get(cur)) {\n                        indegree[next]--;\n                        if(indegree[next] < 0) {\n                            visited = -1;\n                            break;\n                        }\n                        if(indegree[next] == 0) {\n                            if(next < cur) {\n                                queue.offer(next);\n                            } else {\n                                level.offer(next);\n                            }\n                        }\n                    }\n                    if(visited < 0) {\n                        break;\n                    }\n                }\n                if(visited < 0) {\n                    break;\n                }\n                steps++;\n            }\n            out.println(visited == n ? steps : -1);\n        }\n        f.close();\n        out.close();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nvoid solve() {\n  ll n;\n  cin >> n;\n  vector<vector<ll>> adj(n);\n  vector<ll> indegree(n, 0);\n  for (ll i = 0; i < n; i++) {\n    ll k;\n    cin >> k;\n    for (ll j = 0; j < k; j++) {\n      ll x = i, y;\n      cin >> y;\n      y--;\n      adj[y].push_back(x);\n      indegree[x]++;\n    }\n  }\n  vector<ll> topo;\n  priority_queue<ll, vector<ll>, greater<ll>> q;\n  vector<ll> r(n, 1);\n  for (ll i = 0; i < n; i++) {\n    if (indegree[i] == 0) q.push(i);\n  }\n  while (!q.empty()) {\n    ll v = q.top();\n    q.pop();\n    topo.push_back(v);\n    for (auto x : adj[v]) {\n      indegree[x]--;\n      if (indegree[x] == 0) q.push(x);\n      if (v < x)\n        r[x] = max(r[x], r[v]);\n      else\n        r[x] = max(r[x], r[v] + 1);\n    }\n  }\n  if ((ll)topo.size() < n)\n    cout << -1 << \"\\n\";\n  else\n    cout << *max_element(r.begin(), r.end()) << \"\\n\";\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int _t = 1;\n  cin >> _t;\n  for (int i = 1; i <= _t; i++) {\n    solve();\n  }\n  {};\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class C {\n    private static final FastReader fs = new FastReader();\n    private static final PrintWriter out = new PrintWriter(System.out);\n    private static long m = 1_000_000_009;\n    private static long p = 31;\n    private static long mod = 1_000_000_007;\n    private static long ool = 1_000_000_000_000_000_009l;\n    private static int ooi = 1_000_000_009;\n    private static int numOfBooks, inDeg;\n    private static int[] inDegree;\n    private static ArrayList<Integer>[] adj;\n    private static ArrayDeque<Integer> q;\n    private static int[] rank;\n    private static boolean[] vis;\n\n    private static void solve() {\n        numOfBooks = fs.nextInt();\n        adj = new ArrayList[numOfBooks];\n        inDegree = new int[numOfBooks];\n        q = new ArrayDeque<>();\n        rank = new int[numOfBooks];\n        vis = new boolean[numOfBooks];\n        for(int i = 0; i < numOfBooks; i++)\n            adj[i] = new ArrayList<>();\n        for(int i = 0; i < numOfBooks; i++){\n            inDeg = fs.nextInt();\n            inDegree[i] += inDeg;\n            if(inDeg == 0) {\n                q.add(i);\n                rank[i] = 1;\n            }\n            for(int j = 0; j < inDeg; j++)\n                adj[fs.nextInt()-1].add(i);\n        }\n        ArrayList<Integer> topo = new ArrayList<>();\n        while(!q.isEmpty()){\n            int chapterNum = q.getFirst();\n            q.removeFirst();\n            vis[chapterNum] = true;\n            topo.add(chapterNum);\n            for(int childChapterNum : adj[chapterNum]){\n                if(vis[childChapterNum]){\n                    out.println(-1);\n                    return;\n                }\n                inDegree[childChapterNum]-=1;\n                if(inDegree[childChapterNum] == 0)\n                    q.add(childChapterNum);\n            }\n        }\n        /*out.println(\"topilogicalSort is ::\");\n        for(int i = 0; i < topo.size(); i++){\n            out.println(topo.get(i))\n        }*/\n        for(int i = 0; i < numOfBooks; i++)\n            if(!vis[i]){\n                out.println(-1);\n                return;\n            }\n        int ans = 0;\n        for(int i = 0; i < topo.size(); i++){\n            int node = topo.get(i);\n            for(int j : adj[node])\n                rank[j] = max(rank[j], j > node ? rank[node] : rank[node] + 1);\n        }\n        for(int i = 0; i < numOfBooks; i++)\n            ans = max(ans, rank[i]);\n        out.println(ans);\n    }\n\n    public static void main(String[] args) {\n        Thread t = new Thread(null, null, \"\", 1 << 28) {\n            public void run() {\n                int test_case = 1;\n                test_case = fs.nextInt();\n                for (int cs = 1; cs <= test_case; cs++)\n                    solve();\n                out.close();\n            }\n        };\n        t.start();\n        try {\n            t.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        int[] readintarray(int n) {\n            int res[] = new int[n];\n            for (int i = 0; i < n; i++)\n                res[i] = nextInt();\n            return res;\n        }\n\n        long[] readlongarray(int n) {\n            long res[] = new long[n];\n            for (int i = 0; i < n; i++)\n                res[i] = nextLong();\n            return res;\n        }\n    }\n\n    private static int max(int... arg) {\n        int length = arg.length;\n        if(length == 0)\n            throw null;\n        int maxVal = arg[0];\n        for(int i = 1; i < length; i++)\n            maxVal = Math.max(maxVal, arg[i]);\n        return maxVal;\n    }\n\n    private static int min(int... arg) {\n        int length = arg.length;\n        if(length == 0)\n            throw null;\n        int maxVal = arg[0];\n        for(int i = 1; i < length; i++)\n            maxVal = Math.min(maxVal, arg[i]);\n        return maxVal;\n    }\n\n    private static long max(long... arg) {\n        int length = arg.length;\n        if(length == 0)\n            throw null;\n        long maxVal = arg[0];\n        for(int i = 1; i < length; i++)\n            maxVal = Math.max(maxVal, arg[i]);\n        return maxVal;\n    }\n\n    private static long min(long... arg) {\n        int length = arg.length;\n        if(length == 0)\n            throw null;\n        long maxVal = arg[0];\n        for(int i = 1; i < length; i++)\n            maxVal = Math.min(maxVal, arg[i]);\n        return maxVal;\n    }\n\n    private static int abs(int a) {\n        return a >= 0 ? a : -a;\n    }\n\n    private static int abs(int a, int b) {\n        return a-b >= 0 ? a-b : b-a;\n    }\n\n    private static long abs(long a) {\n        return a >= 0 ? a : -a;\n    }\n\n    private static long abs(long a, long b) {\n        return a-b >= 0 ? a-b : b-a;\n    }\n\n    private static int power(int base, int exponent) {\n        int res = 1;\n        while(exponent > 0) {\n            if((exponent & 1) != 0)\n                res *= base;\n            exponent >>= 1;\n            base *= base;\n        }\n        return res;\n    }\n\n    private static long power(long base, long exponent) {\n        long res = 1;\n        while(exponent > 0) {\n            if((exponent & 1) != 0)\n                res *= base;\n            exponent >>= 1;\n            base *= base;\n        }\n        return res;\n    }\n\n    private static long mPower(long base, long exponent) throws Exception {\n        long res = 1;\n        base %= mod;\n        while(exponent > 0) {\n            if((exponent & 1) != 0)\n                res = mul(res, base);\n            exponent >>= 1;\n            base = mul(base, base);\n        }\n        return res;\n    }\n\n    private static long mul(long a, long b) {\n        return a*b % mod;\n    }\n\n    private static long add(long a, long b) {\n        return (a+b) % mod;\n    }\n\n    private static long sub(long a, long b) {\n        long res = (a - b) % mod;\n        if(res < 0)\n            res += mod;\n        return res;\n    }\n\n    private static long xor(long n){\n        long r = n % 4;\n        if(r == 0)\n            return n;\n        else if(r == 1)\n            return 1;\n        else if(r == 2)\n            return n+1;\n        else\n            return 0;\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 2e5 + 10;\nint k[M];\nint fa[M];\nint head[M];\nint next1[M];\nint qu[M];\nint inq[M];\nint ouq[M];\nint ce[M];\nint cnt = 0;\nvoid add(int x, int y) {\n  next1[++cnt] = head[x];\n  qu[cnt] = y;\n  head[x] = cnt;\n}\nstruct node {\n  int c;\n  int xu;\n  bool operator<(const node z) const {\n    if (c == z.c) return xu > z.xu;\n    return c > z.c;\n  }\n};\nint ans = 1;\npriority_queue<node> que;\nvoid bfs() {\n  while (!que.empty()) {\n    node z = que.top();\n    que.pop();\n    int x1 = z.xu;\n    for (int i = head[x1]; i; i = next1[i]) {\n      int v = qu[i];\n      if (inq[v] == 0) continue;\n      inq[v]--;\n      if (inq[v] == 0) {\n        if (ce[z.c + 1] == 0 && v < x1) {\n          ans++;\n          ce[z.c + 1] = 1;\n        }\n        node l;\n        if (v < x1)\n          l.c = z.c + 1;\n        else\n          l.c = z.c;\n        l.xu = v;\n        que.push(l);\n      }\n    }\n  }\n}\nint fine(int x) { return fa[x] == x ? x : fa[x] = fine(fa[x]); }\nbool check(int x, int y) {\n  int z = fine(x);\n  int z1 = fine(y);\n  if (z == z1) return false;\n  fa[z] = z1;\n  return true;\n}\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    while (!que.empty()) que.pop();\n    ans = 1;\n    cnt = 0;\n    cin >> n;\n    for (int i = 1; i <= n; ++i) {\n      head[i] = 0;\n      fa[i] = i;\n      inq[i] = 0;\n      ce[i] = 0;\n    }\n    int f = 0;\n    for (int i = 1; i <= n; ++i) {\n      int k;\n      cin >> k;\n      if (k == 0) {\n        node l;\n        l.c = 1;\n        l.xu = i;\n        que.push(l);\n      }\n      for (int j = 1; j <= k; ++j) {\n        int x;\n        cin >> x;\n        add(x, i);\n        ouq[x]++;\n        inq[i]++;\n      }\n    }\n    bfs();\n    for (int i = 1; i <= n; ++i) {\n      if (inq[i] != 0) {\n        f = 1;\n        break;\n      }\n    }\n    if (!f)\n      cout << ans << \"\\n\";\n    else\n      cout << \"-1\\n\";\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStreamWriter;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Map.Entry;\n\n\nimport java.util.Random;\nimport java.util.TreeSet;\n\npublic final class CF_7433_D2_C\n{\n\n\n\tstatic boolean verb=true;\n\tstatic void log(Object X){if (verb) System.err.println(X);}\n\tstatic void log(Object[] X){if (verb) {for (Object U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n\tstatic void log(int[] X){if (verb) {for (int U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n\tstatic void logWln(int[] X){if (verb) {for (int U:X) System.err.print(U+\" \");}}\n\tstatic void log(int[] X,int L){if (verb) {for (int i=0;i<L;i++) System.err.print(X[i]+\" \");System.err.println(\"\");}}\n\tstatic void log(long[] X){if (verb) {for (long U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n\n\tstatic void logWln(Object X){if (verb) System.err.print(X);}\n\tstatic void info(Object o){\tSystem.out.println(o);}\n\tstatic void output(Object o){outputWln(\"\"+o+\"\\n\");\t}\n\tstatic void outputFlush(Object o){try {out.write(\"\"+ o+\"\\n\");out.flush();} catch (Exception e) {}}\n\tstatic void outputWln(Object o){try {out.write(\"\"+ o);} catch (Exception e) {}}\n\n\n\tstatic void logBin(int[] tm) {for (int x:tm) logWln(bin(8,x)+\" \");log(\"\");}\n\n\tstatic String bin(int L,int x) {\n\t\tString s=Integer.toBinaryString(x);\n\t\twhile (s.length()<L) s=\"0\"+s;\n\t\treturn s;\n\t}\n\n\t// Global vars\n\tstatic BufferedWriter out;\n\tstatic InputReader reader;\n\n\n\tstatic void test() {\n\t\tlog(\"testing\");\n\n\t\tRandom r=new Random();\n\t\tint NTESTS=100000;\n\t\tint NMAX=10;\n\t\tint VMAX=10;\n\t\tfor (int t=0;t<NTESTS;t++) {\n\n\t\t}\n\n\t}\n\n\tstatic int st;\n\n\n\n\n\n\n\n\tstatic void process() throws Exception {\n\n\n\t\tout = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\treader = new InputReader(System.in);\n\n\t\t//test();\n\n\n\t\tint T=reader.readInt();\n\t\tfor (int t=0;t<T;t++) {\n\t\t\tint n=reader.readInt();\n\t\t\tint[][] friends=new int[n][];\n\t\t\tboolean canStart=false;\n\t\t\tfor (int i=0;i<n;i++) {\n\t\t\t\tint k=reader.readInt();\n\t\t\t\tfriends[i]=new int[k];\n\t\t\t\tfor (int j=0;j<k;j++)\n\t\t\t\t\tfriends[i][j]=reader.readInt()-1;\n\t\t\t\tif (k==0)\n\t\t\t\t\tcanStart=true;\n\t\t\t}\n\t\t\tint ans=-1;\n\t\t\t//log(\"step 1\");\n\t\t\tif (canStart) {\n\t\t\t\t// do we have a loop\n\t\t\t\tint[] stack=new int[n];\n\t\t\t\tint[] rank=new int[n];\n\t\t\t\tboolean[] onStack=new boolean[n];\n\t\t\t\tboolean[] processed=new boolean[n];\n\t\t\t\tint[] it=new int[n];\n\t\t\t\tboolean ok=true;\n\t\t\t\tfor (int i=0;i<n;i++) {\n\n\t\t\t\t\tif (!processed[i] && friends[i].length>0) {\n\t\t\t\t\t\tint st=0;\n\t\t\t\t\t\tstack[st++]=i;\n\t\t\t\t\t\twhile (st>0) {\n\t\t\t\t\t\t\tint u=stack[st-1];\n\n\t\t\t\t\t\t\tif (it[u]<friends[u].length) {\n\t\t\t\t\t\t\t\tint v=friends[u][it[u]++];\n\t\t\t\t\t\t\t\tif (onStack[v]) {\n\t\t\t\t\t\t\t\t\tok=false;\n\t\t\t\t\t\t\t\t\tlog(\"issue\");\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!processed[v]) {\n\t\t\t\t\t\t\t\t\tonStack[v]=true;\n\t\t\t\t\t\t\t\t\tit[v]=0;\n\t\t\t\t\t\t\t\t\tstack[st++]=v;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tonStack[u]=false;\n\t\t\t\t\t\t\t\tprocessed[u]=true;\n\t\t\t\t\t\t\t\tit[u]=0;\n\t\t\t\t\t\t\t\tfor (int v:friends[u]) {\n\t\t\t\t\t\t\t\t\tint rnk=rank[v];\n\t\t\t\t\t\t\t\t\tif (v>u)\n\t\t\t\t\t\t\t\t\t\trnk++;\n\t\t\t\t\t\t\t\t\trank[u]=Math.max(rank[u],rnk);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tst--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tans=0;\n\t\t\t\t\tfor (int i=0;i<n;i++) {\n\t\t\t\t\t\tans=Math.max(ans,rank[i]);\n\t\t\t\t\t}\n\t\t\t\t\tans++;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\toutput(ans);\n\t\t}\n\n\n\n\t\ttry {\n\t\t\tout.close();\n\t\t} catch (Exception Ex) {\n\t\t}\n\n\t}\n\n\n\n\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tprocess();\n\n\t}\n\n\tstatic final class InputReader {\n\t\tprivate final InputStream stream;\n\t\tprivate final byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tprivate int read() throws IOException {\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\tif (numChars <= 0) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic final String readString() throws IOException {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.append((char) c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic final String readString(int L) throws IOException {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder(L);\n\t\t\tdo {\n\t\t\t\tres.append((char) c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic final int readInt() throws IOException {\n\t\t\tint c = read();\n\t\t\tboolean neg = false;\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tchar d = (char) c;\n\t\t\t// log(\"d:\"+d);\n\t\t\tif (d == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\t// log(\"res:\"+res);\n\t\t\tif (neg)\n\t\t\t\treturn -res;\n\t\t\treturn res;\n\n\t\t}\n\n\t\tpublic final long readLong() throws IOException {\n\t\t\tint c = read();\n\t\t\tboolean neg = false;\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tchar d = (char) c;\n\t\t\t// log(\"d:\"+d);\n\t\t\tif (d == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\t// log(\"res:\"+res);\n\t\t\tif (neg)\n\t\t\t\treturn -res;\n\t\t\treturn res;\n\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\t}\n\n}\n/*\n\n5\n1 4 5 2 3\n\n */"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Codeforces\n{\n    public static void main(String args[])throws Exception\n    {\n        BufferedReader bu=new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder sb=new StringBuilder();\n        int t=Integer.parseInt(bu.readLine());\n        while(t-->0)\n        {\n            int n=Integer.parseInt(bu.readLine());\n            int i,c[]=new int[n];\n            boolean vis[]=new boolean[n];\n            ArrayList<Integer> g[]=new ArrayList[n];\n            for(i=0;i<n;i++) g[i]=new ArrayList<>();\n\n            TreeSet<Integer> set=new TreeSet<>();\n            for(i=0;i<n;i++)\n            {\n                String s[]=bu.readLine().split(\" \");\n                int x=Integer.parseInt(s[0]),a,j;\n                for(j=1;j<=x;j++)\n                {\n                    a=Integer.parseInt(s[j])-1;\n                    g[a].add(i);\n                    c[i]++;\n                }\n                if(c[i]==0)\n                {\n                    vis[i]=true;\n                    set.add(i);\n                }\n            }\n\n            int ans=0;\n            while(!set.isEmpty())\n            {\n                i=-1; ans++;\n                while(set.higher(i)!=null)\n                {\n                    i=set.higher(i);\n                    for(int x:g[i])\n                    {\n                        c[x]--;\n                        if(!vis[x] && c[x]==0)\n                        {\n                            vis[x]=true;\n                            set.add(x);\n                        }\n                    }\n                    set.remove(i);\n                }\n            }\n\n            for(i=0;i<n;i++)\n            if(!vis[i]) ans=-1;\n            sb.append(ans+\"\\n\");\n        }\n        System.out.print(sb);\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int power(long long int a, long long int b) {\n  long long int res = 1;\n  a = a % 1000000007;\n  while (b > 0) {\n    if (b & 1) {\n      res = (res * a) % 1000000007;\n      b--;\n    }\n    a = (a * a) % 1000000007;\n    b >>= 1;\n  }\n  return res;\n}\nlong long int gcd(long long int a, long long int b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long int max(long long int a, long long int b) {\n  if (a >= b) return a;\n  return b;\n}\nlong long int min(long long int a, long long int b) {\n  if (a >= b) return b;\n  return a;\n}\nbool cycle(vector<vector<int>>& v, vector<int>& vis, int node) {\n  vis[node] = 1;\n  for (auto child : v[node]) {\n    if (vis[child]) return true;\n    if (cycle(v, vis, child)) return true;\n  }\n  vis[node] = 0;\n  return false;\n}\nint main() {\n  ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<vector<int>> adj(n);\n    vector<int> indegree(n);\n    for (long long int i = 0; i <= n - 1; i++) {\n      int x;\n      cin >> x;\n      for (long long int j = 1; j <= x; j++) {\n        int k;\n        cin >> k;\n        k--;\n        indegree[k]++;\n        adj[i].push_back(k);\n      }\n    }\n    queue<int> Q;\n    for (long long int i = 0; i <= n - 1; i++) {\n      if (indegree[i] == 0) Q.push(i);\n    }\n    stack<int> st;\n    while (Q.size()) {\n      int x = Q.front();\n      Q.pop();\n      st.push(x);\n      for (auto child : adj[x]) {\n        indegree[child]--;\n        if (indegree[child] == 0) {\n          Q.push(child);\n        }\n      }\n    }\n    if (st.size() != n) {\n      cout << \"-1\\n\";\n    } else {\n      int ans = 1;\n      vector<int> val(n, 0);\n      while (!st.empty()) {\n        int x = st.top();\n        st.pop();\n        int p = 1;\n        for (auto child : adj[x]) {\n          if (child < x)\n            p = max(p, val[child]);\n          else\n            p = max(p, val[child] + 1);\n        }\n        val[x] = p;\n        ans = max(ans, val[x]);\n      }\n      cout << ans << \"\\n\";\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\n\n\nimport java.io.*;\n\npublic class code  {\n\t// remember long, to reformat ctrl + shift +f\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic PrintWriter pw = new PrintWriter(System.out);\n \n\t  \n \n\tpublic static void main(String[] args) throws Exception {\n\n\t\tint t=sc.nextInt();\n\t\twhile(t-->0) {\n\t\t\tint n=sc.nextInt();\n\t\t\tArrayList<Integer>[]adj=new ArrayList[n];\n\t\t\tfor(int i=0;i<n;i++)adj[i]=new ArrayList();\n\t\t\tint indegree[]=new int[n];\n\t\t\tTreeSet<Integer>options=new TreeSet();\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tint k=sc.nextInt();\n\t\t\t\tindegree[i]=k;\n\t\t\t\tif(k==0)options.add(i);\n\t\t\t\tfor(int j=0;j<k;j++) {\n\t\t\t\t\tadj[sc.nextInt()-1].add(i);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cur=0;\n\t\t\tint nodes=0;\n\t\t\tint count=1;\n\t\n\t\t\twhile(!options.isEmpty()) {\n\t\t\t\tif(options.ceiling(cur)==null) {\n\t\t\t\tif(nodes!=n)count++;\n\t\t\t\tcur=0;\n\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tInteger x=options.ceiling(cur);\n\t\t\t\t\tnodes++;\n\t\t\t\t\toptions.remove(x);\n\t\t\t\t\tcur=x;\n\t\t\t\t\tfor(int y:adj[x]) {\n\t\t\t\t\t\tif(--indegree[y]==0)options.add(y);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(nodes!=n)pw.println(-1);\n\t\t\telse pw.println(count);\n\t\t\t\n\t\t}\n\t\t\n\t pw.close();\n\n\t}\n\n\t// --------------------stuff ----------------------\n\tstatic class pair implements Comparable<pair> {\n\t\tint v;\n\t\tint w;\n        \n\t\tpublic pair(int v,int  w) {\n\t\t\tthis.v = v;\n\t\t\tthis.w = w;\n\t\t\t\n\t\t}\n\n\t\tpublic int compareTo(pair p) {\n\t\t\treturn this.w- p.w;// increasing order!!\n\t\t\n\t\t\t//return Double.compare(v*w, p.w*p.v);\n\t\t\n\t\t}\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic Scanner(FileReader r) {\n\t\t\tbr = new BufferedReader(r);\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif (x.charAt(0) == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor (int i = start; i < x.length(); i++)\n\t\t\t\tif (x.charAt(i) == '.') {\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif (dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg ? -1 : 1);\n\t\t}\n\n\t\tpublic long[] nextlongArray(int n) throws IOException {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic Long[] nextLongArray(int n) throws IOException {\n\t\t\tLong[] a = new Long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic Integer[] nextIntegerArray(int n) throws IOException {\n\t\t\tInteger[] a = new Integer[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\t}\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class C_1573 {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\t\n\t\tint t = sc.nextInt();\n\t\twhile(t-->0) {\n\t\t\tint n = sc.nextInt();\n\t\t\tArrayList<Integer>[] adjList = new ArrayList[n];\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t\tadjList[i] = new ArrayList<>();\n\t\t\tint[] deg = new int[n];\n\t\t\tfor(int v = 0; v < n; v++) {\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tdeg[v] = k;\n\t\t\t\twhile(k-->0) {\n\t\t\t\t\tint u = sc.nextInt() - 1;\n\t\t\t\t\tadjList[u].add(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint read = 1;\n\t\t\tint last = -1;\n\t\t\tint cnt = 0;\n\t\t\tTreeSet<Integer> set = new TreeSet<>();\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t\tif(deg[i] == 0)\n\t\t\t\t\tset.add(i);\n\t\t\twhile(!set.isEmpty()) {\n\t\t\t\tInteger x = set.higher(last);\n\t\t\t\tif(x == null) {\n\t\t\t\t\tread++;\n\t\t\t\t\tx = set.pollFirst();\n\t\t\t\t} else \n\t\t\t\t\tset.remove(x);\n\t\t\t\tint u = x;\n\t\t\t\tlast = u;\n\t\t\t\tcnt++;\n\t\t\t\tfor(int v : adjList[u])\n\t\t\t\t\tif(--deg[v] == 0)\n\t\t\t\t\t\tset.add(v);\n\t\t\t}\n\t\t\t\n\t\t\tpw.println(cnt == n ? read : -1);\n\t\t}\n\t\t\n\t\tpw.flush();\n\t}\n\n\tpublic static class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic Integer[] nextIntegerArray(int n) throws IOException {\n\t\t\tInteger[] array = new Integer[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = new Integer(nextInt());\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic double[] nextDoubleArray(int n) throws IOException {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic static int[] shuffle(int[] a) {\n\t\t\tint n = a.length;\n\t\t\tRandom rand = new Random();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint tmpIdx = rand.nextInt(n);\n\t\t\t\tint tmp = a[i];\n\t\t\t\ta[i] = a[tmpIdx];\n\t\t\t\ta[tmpIdx] = tmp;\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1000000007;\nvector<vector<int>> adj;\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<vector<int>> adj = vector<vector<int>>(n);\n  vector<int> arr(n), ans(n, -1), cnt(n, 0);\n  deque<int> dq;\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i];\n    for (int j = 0; j < arr[i]; j++) {\n      int tmp;\n      cin >> tmp;\n      adj[tmp - 1].push_back(i);\n    }\n    if (!arr[i]) {\n      dq.push_back(i);\n      ans[i] = 1;\n    }\n  }\n  while (!dq.empty()) {\n    int tmp = dq.front();\n    dq.pop_front();\n    for (auto it : adj[tmp]) {\n      if (it < tmp)\n        ans[it] = max(ans[it], ans[tmp] + 1);\n      else\n        ans[it] = max(ans[it], ans[tmp]);\n      cnt[it]++;\n      if (cnt[it] == arr[it]) dq.push_back(it);\n    }\n  }\n  for (int i = 0; i < n; i++)\n    if (cnt[i] < arr[i]) {\n      cout << -1 << '\\n';\n      return;\n    }\n  int maxx = -1;\n  for (auto it : ans) maxx = max(maxx, it);\n  cout << maxx << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int t;\n  cin >> t;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint head[200010], next_edge[200010], to[200010];\nint sumedge;\nvoid add_edge(int s, int t) {\n  next_edge[sumedge] = head[s];\n  head[s] = sumedge;\n  to[sumedge] = t;\n  sumedge++;\n}\nint visited[200010];\nint instack[200010];\nbool dfs(int x) {\n  if (instack[x]) return false;\n  if (visited[x]) return true;\n  instack[x] = true;\n  visited[x] = true;\n  for (int e = head[x]; e != -1; e = next_edge[e]) {\n    if (!dfs(to[e])) return false;\n  }\n  instack[x] = false;\n  return true;\n}\nbool check_valid() {\n  memset(visited, 0, sizeof(visited));\n  memset(instack, 0, sizeof(instack));\n  for (int i = 0; i < n; i++) {\n    if (!dfs(i)) return false;\n  }\n  return true;\n}\nint maxLength[200010];\nint getMaxLength(int x) {\n  if (maxLength[x] != -1) return maxLength[x];\n  maxLength[x] = 0;\n  for (int i = head[x]; ~i; i = next_edge[i])\n    maxLength[x] = max(maxLength[x], getMaxLength(to[i]) + (int)(to[i] > x));\n  return maxLength[x];\n}\nvoid solve() {\n  memset(head, -1, sizeof(head));\n  sumedge = 0;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    int k, t;\n    scanf(\"%d\", &k);\n    for (int j = 0; j < k; j++) {\n      scanf(\"%d\", &t);\n      add_edge(i, t - 1);\n    }\n  }\n  if (check_valid()) {\n    int ans = 0;\n    memset(maxLength, -1, sizeof(maxLength));\n    for (int i = 0; i < n; i++) ans = max(ans, getMaxLength(i));\n    cout << ans + 1 << endl;\n  } else\n    cout << -1 << endl;\n}\nint main() {\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; i++) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long> dep;\nvector<vector<long long>> v;\nvector<int> visited;\nlong long n;\nlong long maxdepth(long long node) {\n  visited[node] = 1;\n  for (long long i = 0; i < v[node].size(); i++) {\n    if (dep[v[node][i]] == 0) {\n      if (node < v[node][i])\n        dep[node] = max(dep[node], 1 + maxdepth(v[node][i]));\n      else\n        dep[node] = max(dep[node], maxdepth(v[node][i]));\n    } else {\n      if (node < v[node][i])\n        dep[node] = max(dep[node], 1 + dep[v[node][i]]);\n      else\n        dep[node] = max(dep[node], dep[v[node][i]]);\n    }\n  }\n  return dep[node];\n}\nbool cycle(long long root, vector<long long>& stv, vector<long long>& cv) {\n  cv[root] = 1;\n  stv[root] = 1;\n  for (long long i = 0; i < v[root].size(); i++) {\n    if (cv[v[root][i]] == 0) {\n      if (cycle(v[root][i], stv, cv) == true) return true;\n    } else if (stv[v[root][i]] == true)\n      return true;\n  }\n  stv[root] = 0;\n  return false;\n}\nbool iscyclic() {\n  vector<long long> cv(n + 1);\n  vector<long long> stv(n + 1);\n  for (int i = 1; i < n + 1; i++) {\n    if (cv[i]) continue;\n    if (cycle(i, stv, cv)) return true;\n  }\n  return false;\n}\nint solve() {\n  cin >> n;\n  v.clear();\n  dep.clear();\n  visited.clear();\n  v.resize(n + 1);\n  dep.resize(n + 1);\n  visited.resize(n + 1);\n  for (long long i = 1; i < n + 1; i++) {\n    long long temp;\n    cin >> temp;\n    v[i].resize(temp);\n    for (long long j = 0; j < temp; j++) {\n      cin >> v[i][j];\n    }\n  }\n  if (iscyclic()) return -2;\n  for (long long i = 1; i < n + 1; i++) {\n    if (visited[i] == 0) {\n      maxdepth(i);\n    }\n  }\n  return *max_element(dep.begin(), dep.end());\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long t;\n  cin >> t;\n  while (t--) {\n    long long res = solve() + 1LL;\n    cout << res << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class C {\n    public static int solve(List<Set<Integer>> chap, List<Set<Integer>> depend, int n) {\n        Queue<Integer> q = new LinkedList<>();\n        int[] ret = new int[n+1];\n        int[] maxC = new int[n+1];\n        for (int i = 0; i < n; i++) {\n            ret[i] = -1;\n            if (chap.get(i).size() == 0) {\n                q.add(i);\n                ret[i] = 1;\n            }\n        }\n        while (!q.isEmpty()) {\n            int tmp = q.poll();\n            Set<Integer> other = depend.get(tmp);\n            for (int i : other) {\n                int x = ret[tmp];\n                if (tmp > i) x++;\n                maxC[i] = Math.max(x, maxC[i]);\n                chap.get(i).remove(tmp);\n                if (chap.get(i).size() == 0 && ret[i] == -1) {\n                    q.add(i);\n                    ret[i] = maxC[i];\n                }\n            }\n        }\n        int max = 0;\n        for (int i = 0; i < n; i++) {\n            if (ret[i] < 0) return -1;\n            if (ret[i] > max) max = ret[i];\n        }\n        return max;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int t = scanner.nextInt();\n        while (t-- > 0) {\n            int n = scanner.nextInt();\n            List<Set<Integer>> chap = new ArrayList<>();\n            List<Set<Integer>> depend = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                Set<Integer> set = new TreeSet<>();\n                int k = scanner.nextInt();\n                for (int j = 0; j < k; j++) set.add(scanner.nextInt() - 1);\n                chap.add(set);\n                depend.add(new TreeSet<>());\n            }\n            for (int i = 0; i < n; i++) {\n                Set<Integer> set = chap.get(i);\n                for (int j : set) {\n                    depend.get(j).add(i);\n                }\n            }\n            System.out.println(solve(chap, depend, n));\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nconst int MAXN = 3e5 + 5;\nconst int inf = 0x3f3f3f3f;\nvector<int> g[MAXN];\nint in[MAXN];\nint dp[MAXN];\nbool dfs(int n) {\n  queue<int> q;\n  for (int i = 1; i <= n; i++) {\n    if (!in[i]) q.push(i), dp[i] = 1;\n  }\n  int cnt = 0;\n  while (!q.empty()) {\n    int now = q.front();\n    in[now]--;\n    cnt++;\n    q.pop();\n    for (auto v : g[now]) {\n      in[v]--;\n      if (now < v)\n        dp[v] = max(dp[v], dp[now]);\n      else\n        dp[v] = max(dp[v], dp[now] + 1);\n      if (!in[v]) q.push(v);\n    }\n  }\n  if (cnt != n) return false;\n  return true;\n}\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++) in[i] = 0, dp[i] = 0;\n    for (int i = 1; i <= n; i++) {\n      int k;\n      cin >> k;\n      for (int j = 1; j <= k; j++) {\n        int x;\n        cin >> x;\n        g[x].push_back(i);\n        in[i]++;\n      }\n    }\n    bool flag = dfs(n);\n    if (flag) {\n      int ans = 0;\n      for (int i = 1; i <= n; i++) {\n        ans = max(ans, dp[i]);\n      }\n      printf(\"%d\\n\", ans);\n    } else {\n      printf(\"-1\\n\");\n    }\n    for (int i = 1; i <= n; i++) g[i].clear();\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class C {\n    static StringBuilder sb;\n    static long fact[];\n    static int mod = (int) (1e9 + 7);\n    static int[] arr = { 0, 1, 11, 111, 1111, 11111, 111111, 1111111, 11111111, 111111111, 1111111111 };\n\n    static ArrayList<Integer> kahnAlgo(ArrayList<Integer>[] graph, int N) {\n        LinkedList<Integer> que = new LinkedList<>();\n        int[] indegree = new int[N + 1];\n\n        for (int i = 1; i <= N; i++) {\n            for (int v : graph[i]) {\n                indegree[v]++;\n            }\n        }\n\n        for (int i = 1; i <= N; i++) {\n            if (indegree[i] == 0)\n                que.addLast(i);\n        }\n\n        ArrayList<Integer> topOrder = new ArrayList<>();\n        while (que.size() > 0) {\n            int rn = que.removeFirst();\n            for (int ele : graph[rn]) {\n                indegree[ele]--;\n                if (indegree[ele] == 0)\n                    que.add(ele);\n            }\n            topOrder.add(rn);\n\n        }\n\n        Collections.reverse(topOrder);\n\n        if (topOrder.size() == N)\n            return topOrder;\n\n        else\n            return new ArrayList<>();\n\n    }\n\n    static int solve(ArrayList<Integer>[] graph, int N) {\n        ArrayList<Integer> topOrder = kahnAlgo(graph, N);\n\n        // System.out.println(topOrder);\n        if (topOrder.size() != N)\n            return -1;\n\n        HashMap<Integer, Integer> mp = new HashMap<>();\n        int maxR = 1;\n\n        for (int ele : topOrder) {\n            int depSmaller = -1;\n            int depGreater = -1;\n            for (int v : graph[ele]) {\n                if (v < ele) {\n                    depSmaller = Math.max(depSmaller, mp.get(v));\n                } else {\n                    depGreater = Math.max(depGreater, mp.get(v));\n                }\n            }\n\n            int currR = Math.max(depSmaller, depGreater + 1);\n            if (currR == 0) {\n                mp.put(ele, 1);\n            } else {\n                mp.put(ele, currR);\n            }\n            maxR = Math.max(currR, maxR);\n        }\n\n        return maxR;\n    }\n\n    public static void main(String[] args) {\n        sb = new StringBuilder();\n        int test = i();\n        while (test-- > 0) {\n            int N = i();\n\n            @SuppressWarnings(\"unchecked\")\n            ArrayList<Integer>[] graph = new ArrayList[N + 1];\n            for (int i = 1; i <= N; i++) {\n                graph[i] = new ArrayList<>();\n\n            }\n\n            for (int i = 1; i <= N; i++) {\n                int k = i();\n                while (k-- > 0) {\n                    int v = i();\n                    graph[i].add(v);\n                }\n            }\n\n            // System.out.println(Arrays.toString(graph));\n\n            int ans = solve(graph, N);\n            sb.append(ans + \"\\n\");\n\n        }\n        System.out.println(sb);\n\n    }\n\n    /*\n     * fact=new long[(int)1e6+10]; fact[0]=fact[1]=1; for(int i=2;i<fact.length;i++)\n     * { fact[i]=((long)(i%mod)1L(long)(fact[i-1]%mod))%mod; }\n     */\n    // **************NCR%P******************\n\n    static long p(long x, long y)// POWER FXN //\n    {\n        if (y == 0)\n            return 1;\n\n        long res = 1;\n        while (y > 0) {\n            if (y % 2 == 1) {\n                res = (res * x) % mod;\n                y--;\n            }\n\n            x = (x * x) % mod;\n            y = y / 2;\n\n        }\n        return res;\n    }\n\n    static long ncr(int n, int r) {\n        if (r > n)\n            return (long) 0;\n\n        long res = fact[n] % mod;\n        // System.out.println(res);\n        res = ((long) (res % mod) * (long) (p(fact[r], mod - 2) % mod)) % mod;\n        res = ((long) (res % mod) * (long) (p(fact[n - r], mod - 2) % mod)) % mod;\n        // System.out.println(res);\n        return res;\n\n    }\n\n    // **************END******************\n\n    // *************Disjoint set\n    // union*********//\n\n    // ***************PRIME FACTORIZE\n    // ***********************************//\n    static TreeMap<Integer, Integer> prime(long n) {\n        TreeMap<Integer, Integer> h = new TreeMap<>();\n        long num = n;\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (n % i == 0) {\n                int nt = 0;\n                while (n % i == 0) {\n                    n = n / i;\n                    nt++;\n                }\n                h.put(i, nt);\n            }\n        }\n        if (n != 1)\n            h.put((int) n, 1);\n        return h;\n\n    }\n\n    // *****CLASS PAIR\n    // *************************************************\n    static class Pair implements Comparable<Pair> {\n        int x;\n        long y;\n\n        Pair(int x, long y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public int compareTo(Pair o) {\n            return (int) (this.y - o.y);\n\n        }\n\n    }\n    // *****CLASS PAIR\n    // ***************************************************\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int Int() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String String() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return String();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0)\n                    writer.print(' ');\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void flush() {\n            writer.flush();\n        }\n    }\n\n    static InputReader in = new InputReader(System.in);\n    static OutputWriter out = new OutputWriter(System.out);\n\n    public static long[] sortlong(long[] a2) {\n        int n = a2.length;\n        ArrayList<Long> l = new ArrayList<>();\n        for (long i : a2)\n            l.add(i);\n        Collections.sort(l);\n        for (int i = 0; i < l.size(); i++)\n            a2[i] = l.get(i);\n        return a2;\n    }\n\n    public static int[] sortint(int[] a2) {\n        int n = a2.length;\n        ArrayList<Integer> l = new ArrayList<>();\n        for (int i : a2)\n            l.add(i);\n        Collections.sort(l);\n        for (int i = 0; i < l.size(); i++)\n            a2[i] = l.get(i);\n        return a2;\n    }\n\n    public static long pow(long x, long y) {\n        long res = 1;\n        while (y > 0) {\n            if (y % 2 != 0) {\n                res = (res * x);// % modulus;\n                y--;\n\n            }\n            x = (x * x);// % modulus;\n            y = y / 2;\n        }\n        return res;\n    }\n\n    // GCD___+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n    public static long gcd(long x, long y) {\n        if (x == 0)\n            return y;\n        else\n            return gcd(y % x, x);\n    }\n    // ******LOWEST COMMON MULTIPLE\n    // *********************************************\n\n    public static long lcm(long x, long y) {\n        return (x * (y / gcd(x, y)));\n    }\n\n    // INPUT\n    // PATTERN********************************************************\n    public static int i() {\n        return in.Int();\n    }\n\n    public static long l() {\n        String s = in.String();\n        return Long.parseLong(s);\n    }\n\n    public static String s() {\n        return in.String();\n    }\n\n    public static int[] readArray(int n) {\n        int A[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            A[i] = i();\n        }\n        return A;\n    }\n\n    public static long[] readArray(long n) {\n        long A[] = new long[(int) n];\n        for (int i = 0; i < n; i++) {\n            A[i] = l();\n        }\n        return A;\n    }\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nconst int N = 200010;\nvoid sol() {\n  int n;\n  cin >> n;\n  vector<vector<int>> g(n);\n  vector<int> deg(n, 0);\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    while (x--) {\n      int j;\n      cin >> j;\n      --j;\n      g[j].push_back(i);\n      deg[i]++;\n    }\n  }\n  set<int> s;\n  for (int i = 0; i < n; ++i) {\n    if (deg[i] == 0) s.insert(i);\n  }\n  int last = -1, ans = 1;\n  for (int iter = 0; iter < n; ++iter) {\n    if (s.empty()) {\n      ans = -1;\n      break;\n    }\n    auto it = s.lower_bound(last);\n    if (it == s.end()) {\n      ans++;\n      it = s.begin();\n    }\n    int i = *it;\n    s.erase(it);\n    for (int j : g[i]) {\n      --deg[j];\n      if (deg[j] == 0) {\n        s.insert(j);\n      }\n    }\n    last = i;\n  }\n  cout << ans << \"\\n\";\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int v_v = 1;\n  cin >> v_v;\n  while (v_v--) sol();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Inf = 1e9 + 7;\nconst int N = 200004;\nvector<int> g[N];\nint vis[N], dp[N];\nint flag;\nvoid dfs(int u) {\n  vis[u] = 2;\n  dp[u] = 1;\n  for (int i = 0; i < g[u].size(); i++) {\n    int v = g[u][i];\n    if (vis[v] == 0) {\n      dfs(v);\n      if (v > u) {\n        dp[u] = max(dp[u], dp[v] + 1);\n      } else {\n        dp[u] = max(dp[u], dp[v]);\n      }\n    }\n    if (vis[v] == 1) {\n      if (v > u) {\n        dp[u] = max(dp[u], dp[v] + 1);\n      } else {\n        dp[u] = max(dp[u], dp[v]);\n      }\n    } else {\n      flag = 0;\n      break;\n    }\n  }\n  vis[u] = 1;\n}\nint main() {\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    int n;\n    scanf(\"%d\", &n);\n    int i, j;\n    flag = 1;\n    for (i = 1; i <= n; i++) {\n      g[i].clear();\n      vis[i] = 0;\n      dp[i] = 0;\n    }\n    for (i = 1; i <= n; i++) {\n      int k;\n      scanf(\"%d\", &k);\n      for (j = 1; j <= k; j++) {\n        int x;\n        scanf(\"%d\", &x);\n        g[i].push_back(x);\n      }\n    }\n    for (i = 1; i <= n; i++) {\n      if (!vis[i]) {\n        dfs(i);\n        if (flag == 0) break;\n      }\n    }\n    if (!flag)\n      printf(\"-1\\n\");\n    else {\n      int ans = 0;\n      for (i = 1; i <= n; i++) {\n        ans = max(ans, dp[i]);\n      }\n      printf(\"%d\\n\", ans);\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long N = 1e9 + 7;\nbool isprime(long long a) {\n  for (long long i = 2; i * i <= a; i++)\n    if (a % i == 0) return false;\n  return true;\n}\nlong long pow(long long a, long long b) {\n  if (b == 0) return 1;\n  long long ans = 1;\n  while (b) {\n    if (b & 1) ans = ans * a;\n    a = a * a;\n    b = b / 2;\n  }\n  return ans;\n}\nlong long binary(long long a, long long b) {\n  long long res = 1;\n  a = a;\n  while (b) {\n    if (b & 1) res = ((res % N) * (a % N)) % N;\n    a = ((a % N) * (a % N)) % N;\n    res = res % N;\n    b = b >> 1;\n  }\n  return res;\n}\nlong long modinverse(long long a, long long b) { return binary(a, b - 2); }\nvoid _print(long long a) { cerr << a << \" \"; }\nvoid _print(float a) { cerr << a << \" \"; }\nvoid _print(char a) { cerr << a << \"\\n\"; }\nvoid _print(string a) { cerr << a << \" \"; }\nvoid _print(bool a) { cerr << a << \" \"; }\nvoid _print(double a) { cerr << a << \" \"; }\ntemplate <class T>\nvoid _print(vector<T> v) {\n  cerr << \"[ \";\n  for (auto i : v) {\n    _print(i);\n  }\n  cerr << \" ]\";\n}\ntemplate <class T, class V>\nvoid _print(map<T, V> m) {\n  for (auto u : m) {\n    cerr << u.first << \" \" << u.second << \"\\n\";\n  }\n}\ntemplate <class T, class V>\nvoid _print(multimap<T, V> m) {\n  for (auto u : m) {\n    cerr << u.first << \" \" << u.second << \"\\n\";\n  }\n}\ntemplate <class T>\nvoid _print(set<T> s) {\n  cerr << \"[\";\n  for (auto i : s) cerr << i << \" \";\n  cerr << \"]\";\n}\ntemplate <class T>\nvoid _print(multiset<T> s) {\n  cerr << \"[\";\n  for (auto i : s) cerr << i << \" \";\n  cerr << \"]\";\n}\nlong long gcd(long long a, long long b) {\n  while (b) {\n    a = a % b;\n    swap(a, b);\n  }\n  return a;\n};\nlong long add(long long a, long long b) { return (a % N + b % N) % N; }\nlong long cycle_start, cycle_end;\nbool dfs(long long v, vector<long long> adj[], vector<long long> &color,\n         vector<long long> &parent) {\n  color[v] = 1;\n  for (long long u : adj[v]) {\n    if (color[u] == 0) {\n      parent[u] = v;\n      if (dfs(u, adj, color, parent)) return true;\n    } else if (color[u] == 1) {\n      cycle_end = v;\n      cycle_start = u;\n      return true;\n    }\n  }\n  color[v] = 2;\n  return false;\n}\nbool find_cycle(vector<long long> adj[], long long n) {\n  vector<long long> color;\n  vector<long long> parent;\n  color.assign(n, 0);\n  parent.assign(n, -1);\n  cycle_start = -1;\n  for (long long v = 0; v < n; v++) {\n    if (color[v] == 0 && dfs(v, adj, color, parent)) break;\n  }\n  if (cycle_start == -1) {\n    return false;\n  } else {\n    return true;\n  }\n}\nvoid topologicalSortUtil(long long v, vector<long long> adj[], bool visited[],\n                         stack<long long> &Stack) {\n  visited[v] = true;\n  list<long long>::iterator i;\n  for (auto u : adj[v])\n    if (!visited[u]) topologicalSortUtil(u, adj, visited, Stack);\n  Stack.push(v);\n}\nvoid topologicalSort(vector<long long> adj[], long long V,\n                     vector<set<long long>> &s, vector<long long> &dp) {\n  stack<long long> Stack;\n  bool *visited = new bool[V];\n  for (long long i = 0; i < V; i++) visited[i] = false;\n  for (long long i = 0; i < V; i++)\n    if (visited[i] == false) topologicalSortUtil(i, adj, visited, Stack);\n  while (Stack.empty() == false) {\n    long long a = Stack.top();\n    long long ans = 1;\n    for (auto u : s[a]) {\n      if (u < a)\n        ans = max(ans, dp[u]);\n      else\n        ans = max(ans, dp[u] + 1);\n    }\n    Stack.pop();\n    dp[a] = ans;\n  }\n}\nvoid solve() {\n  long long n;\n  cin >> n;\n  vector<long long> adj[n];\n  vector<set<long long>> s(n);\n  vector<long long> dp(n, 1e14 + 2);\n  for (long long i = 0; i < n; i++) {\n    long long k;\n    cin >> k;\n    if (k == 0) dp[i] = 1;\n    while (k--) {\n      long long a;\n      cin >> a;\n      a--;\n      adj[a].push_back(i);\n      s[i].insert(a);\n    };\n  }\n  bool ans = find_cycle(adj, n);\n  if (ans)\n    cout << \"-1\"\n         << \"\\n\";\n  else {\n    topologicalSort(adj, n, s, dp);\n    long long ans = 1;\n    for (auto x : dp) ans = max(ans, x);\n    cout << ans << \"\\n\";\n  }\n}\nint32_t main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long t = 1;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.File;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    // static final File ip = new File(\"input.txt\");\n    // static final File op = new File(\"output.txt\");\n    // static {\n    // try {\n    // System.setOut(new PrintStream(op));\n    // System.setIn(new FileInputStream(ip));\n    // } catch (Exception e) {\n    // }\n    // }\n\n    public static void main(String[] args) {\n        FastReader sc = new FastReader();\n        int test = sc.nextInt();\n        while (test-- != 0) {\n            int n = sc.nextInt();\n            ArrayList<Integer> adj[] = new ArrayList[n];\n            int[] dp = new int[n];\n            Arrays.fill(dp, 1);\n            int[] in = new int[n];\n            for (int i = 0; i < n; i++) {\n                adj[i] = new ArrayList<>();\n            }\n            for (int i = 0; i < n; i++) {\n                int k = sc.nextInt();\n                while (k-- > 0) {\n                    int des = sc.nextInt() - 1;\n                    adj[des].add(i);\n                    in[i]++;\n                }\n            }\n            LinkedList<Integer> q = new LinkedList<>();\n            for (int i = 0; i < n; i++) {\n                if (in[i] == 0)\n                    q.add(i);\n            }\n            ArrayList<Integer> ans = new ArrayList<>();\n            while (q.isEmpty() == false) {\n                int curr = q.poll();\n                ans.add(curr);\n                for (int i : adj[curr]) {\n                    if (i > curr)\n                        dp[i] = Math.max(dp[i], dp[curr]);\n                    else\n                        dp[i] = Math.max(dp[i], dp[curr] + 1);\n                    in[i]--;\n                    if (in[i] == 0)\n                        q.add(i);\n                }\n            }\n            if (ans.size() != n) {\n                System.out.println(\"-1\");\n            } else {\n                int cnt = 0;\n                for (int i = 0; i < n; i++)\n                    cnt = Math.max(cnt, dp[i]);\n                System.out.println(cnt);\n            }\n        }\n    }\n\n    static long power(long x, long y, long p) {\n        long res = 1;\n        x = x % p;\n        if (x == 0)\n            return 0;\n        while (y > 0) {\n            if ((y & 1) != 0)\n                res = (res * x) % p;\n            y = y >> 1;\n            x = (x * x) % p;\n        }\n        return res;\n    }\n\n    public static int countSetBits(long number) {\n        int count = 0;\n        while (number > 0) {\n            ++count;\n            number &= number - 1;\n        }\n        return count;\n    }\n\n    private static <T> void swap(int[] a, int i, int j) {\n        int tmp = a[i];\n        a[i] = a[j];\n        a[j] = tmp;\n    }\n\n    // static class pair {\n    // long a, b;\n\n    // pair(long x, long y) {\n    // this.a = x;\n    // this.b = y;\n    // }\n    // public boolean equals(Object o) {\n    // if (this == o) return true;\n    // if (!(o instanceof pair)) return false;\n    // pair key = (pair) o;\n    // return a == key.a && b == key.b;\n    // }\n\n    // @Override\n    // public int hashCode() {\n    // int result = a;\n    // result = 31 * result + b;\n    // return result;\n    // }\n\n    // public int compare(pair p1, pair p2) {\n    // if(p1.a - p2.a > 0) return -1;\n    // if(p1.a - p2.a < 0) return 1;\n    // return 0;\n    // }\n    // }\n\n    // static class comparator implements Comparator<pair> {\n\n    // public int compare(pair p1, pair p2) {\n    // if (p1.a - p2.a > 0)\n    // return 1;\n    // if (p1.a - p2.a < 0)\n    // return -1;\n    // if (p1.a == p2.a) {\n    // if (p1.b > p2.b)\n    // return -1;\n    // else if (p1.b < p2.b)\n    // return 1;\n    // }\n    // return 0;\n    // }\n    // }\n\n    private static long getSum(int[] array) {\n        long sum = 0;\n        for (int value : array) {\n            sum += value;\n        }\n        return sum;\n    }\n\n    private static boolean isPrime(Long x) {\n        if (x < 2)\n            return false;\n        for (long d = 2; d * d <= x; ++d) {\n            if (x % d == 0)\n                return false;\n        }\n        return true;\n    }\n\n    static int[] reverse(int a[], int n) {\n        int i, k, t;\n        for (i = 0; i < n / 2; i++) {\n            t = a[i];\n            a[i] = a[n - i - 1];\n            a[n - i - 1] = t;\n        }\n        return a;\n    }\n\n    private static boolean isPrimeInt(int x) {\n        if (x < 2)\n            return false;\n        for (int d = 2; d * d <= x; ++d) {\n            if (x % d == 0)\n                return false;\n        }\n        return true;\n    }\n\n    public static String reverse(String input) {\n        StringBuilder str = new StringBuilder(\"\");\n\n        for (int i = input.length() - 1; i >= 0; i--) {\n            str.append(input.charAt(i));\n        }\n\n        return str.toString();\n    }\n\n    private static int[] getPrimes(int n) {\n        boolean[] used = new boolean[n + 1];\n        used[0] = used[1] = true;\n        int size = 0;\n        for (int i = 2; i <= n; ++i) {\n            if (!used[i]) {\n                ++size;\n                for (int j = 2 * i; j <= n; j += i) {\n                    used[j] = true;\n                }\n            }\n        }\n        int[] primes = new int[size];\n        for (int i = 0, cur = 0; i <= n; ++i) {\n            if (!used[i]) {\n                primes[cur++] = i;\n            }\n        }\n        return primes;\n    }\n\n    private static long lcm(long a, long b) {\n        return a / gcd(a, b) * b;\n    }\n\n    private static long gcd(long a, long b) {\n        return (a == 0 ? b : gcd(b % a, a));\n    }\n\n    static void sortI(int[] arr) {\n        int n = arr.length;\n        Random rnd = new Random();\n        for (int i = 0; i < n; ++i) {\n            int tmp = arr[i];\n            int randomPos = i + rnd.nextInt(n - i);\n            arr[i] = arr[randomPos];\n            arr[randomPos] = tmp;\n        }\n        Arrays.sort(arr);\n    }\n\n    static void shuffleList(ArrayList<Long> arr) {\n        int n = arr.size();\n        Random rnd = new Random();\n        for (int i = 0; i < n; ++i) {\n            long tmp = arr.get(i);\n            int randomPos = i + rnd.nextInt(n - i);\n            arr.set(i, arr.get(randomPos));\n            arr.set(randomPos, tmp);\n        }\n    }\n\n    static void factorize(long n) {\n        int count = 0;\n        while (!(n % 2 > 0)) {\n            n >>= 1;\n\n            count++;\n        }\n        if (count > 0) {\n            // System.out.println(\"2\" + \" \" + count);\n        }\n        long i = 0;\n        for (i = 3; i <= (long) Math.sqrt(n); i += 2) {\n            count = 0;\n            while (n % i == 0) {\n                count++;\n                n = n / i;\n            }\n            if (count > 0) {\n                // System.out.println(i + \" \" + count);\n            }\n        }\n\n        if (n > 2) {\n            // System.out.println(i + \" \" + count);\n        }\n    }\n\n    static void sortL(long[] arr) {\n        int n = arr.length;\n        Random rnd = new Random();\n        for (int i = 0; i < n; ++i) {\n            long tmp = arr[i];\n            int randomPos = i + rnd.nextInt(n - i);\n            arr[i] = arr[randomPos];\n            arr[randomPos] = tmp;\n        }\n        Arrays.sort(arr);\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public boolean hasNext() {\n            return false;\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n \npublic class Main extends PrintWriter {\n    \n    void solve()  {\n        int t = sc.nextInt();\n        for(int i = 0; i < t; i++) {\n            test_case();\n        }\n    }\n    \n    void test_case() {\n        int n = sc.nextInt();\n        ArrayDeque<Integer>[] adj = new ArrayDeque[n];\n        for(int i = 0; i < n; i++) adj[i] = new ArrayDeque<>();\n        int[] indegree = new int[n];\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        for(int i = 0; i < n; i++) {\n            indegree[i] = sc.nextInt();\n            for(int j = 0; j < indegree[i]; j++) {\n                adj[sc.nextInt()-1].add(i);\n            }\n            if(indegree[i] == 0) pq.add(i);\n        }\n        int ans = 0;\n        int total = 0;\n        while(!pq.isEmpty()) {\n            ans++;\n            PriorityQueue<Integer> temp = new PriorityQueue<>();\n            while(!pq.isEmpty()) {\n                int u = pq.remove();\n                total++;\n                for(int v : adj[u]) {\n                    indegree[v]--;\n                    if(indegree[v] == 0) {\n                        if(v < u) temp.add(v);\n                        else pq.add(v);\n                    }\n                }\n            }\n            pq = temp;\n        }\n        \n        if(total == n) println(ans);\n        else println(-1);\n    }\n    \n//  Main() throws FileNotFoundException { super(new File(\"output.txt\")); }\n//  InputReader sc = new InputReader(new FileInputStream(\"test_input.txt\"));\n  Main() { super(System.out); }\n  InputReader sc = new InputReader(System.in);\n  static class InputReader {\n      InputReader(InputStream in) { this.in = in; } InputStream in;\n      \n      private byte[] buf = new byte[16384];\n      private int    curChar;\n      private int    numChars;\n      \n \n      public int read() {\n          if (numChars == -1)\n              throw new InputMismatchException();\n          if (curChar >= numChars) {\n              curChar = 0;\n              try {\n                  numChars = in.read(buf);\n              } catch (IOException e) {\n                  throw new InputMismatchException();\n              }\n              if (numChars <= 0)\n                  return -1;\n          }\n          return buf[curChar++];\n      }\n /*\n      private String nextLine() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          StringBuilder res = new StringBuilder();\n          do {\n              res.appendCodePoint(c);\n              c = read();\n          } while (!isEndOfLine(c));\n          return res.toString();\n      }*/\n \n      public String nextString() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          StringBuilder res = new StringBuilder();\n          do {\n              res.appendCodePoint(c);\n              c = read();\n          } while (!isSpaceChar(c));\n          return res.toString();\n      }\n \n      public long nextLong() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          int sgn = 1;\n          if (c == '-') {\n              sgn = -1;\n              c = read();\n          }\n          long res = 0;\n          do {\n              if (c < '0' || c > '9')\n                  throw new InputMismatchException();\n              res *= 10;\n              res += c - '0';\n              c = read();\n          } while (!isSpaceChar(c));\n          return res * sgn;\n      }\n \n      public int nextInt() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          int sgn = 1;\n          if (c == '-') {\n              sgn = -1;\n              c = read();\n          }\n          int res = 0;\n          do {\n              if (c < '0' || c > '9')\n                  throw new InputMismatchException();\n              res *= 10;\n              res += c - '0';\n              c = read();\n          } while (!isSpaceChar(c));\n          return res * sgn;\n      }\n \n      private boolean isSpaceChar(int c) {\n          return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n      }\n \n      private boolean isEndOfLine(int c) {\n          return c == '\\n' || c == '\\r' || c == -1;\n      }\n  }\n \n    public static void main(String[] $) {\n        new Thread(null, new Runnable() {\n            public void run() {\n                long start = System.nanoTime();\n                try {Main solution = new Main(); solution.solve(); solution.flush();} \n                catch (Exception e) {e.printStackTrace(); System.exit(1);}\n                System.err.println((System.nanoTime()-start)/1E9);\n            }\n        }, \"1\", 1 << 27).start();\n \n    }\n}"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict as dd, deque\n \nimport sys\n \n \ninput = sys.stdin.readline\n \ndef check_cycle(g, indegree, n):\n    c = 0\n    d = deque([])\n    ans = dd(lambda :1)\n    for i in range(n):\n        if indegree[i + 1] == 0:\n            d.append(i + 1)\n    #print(d)\n    while d:\n        u = d.popleft()\n        c += 1\n        for v in g[u]:\n            indegree[v] -= 1\n            if v < u:\n                ans[v] = max(ans[v], ans[u] + 1)\n            else:\n                ans[v] = max(ans[v], ans[u])\n            if indegree[v] == 0:\n                d.append(v)\n    if c != n:\n        return False\n    if ans:\n        return max(ans.values())\n    return 1\n \n \nfor _ in range(int(input())):\n    n = int(input())\n    g = dd(set)\n    indegree = dd(int)\n    for i in range(n):\n        a = list(map(int, input().split()))\n        for j in range(1, a[0] + 1):\n            indegree[i + 1] += 1\n            g[a[j]].add(i + 1)\n    #print(indegree)\n    res = check_cycle(g, indegree, n)\n    if res == False:\n        print(-1)\n    else:\n        print(res)"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict, Counter, deque\nfrom math import sqrt, log10, log, floor, factorial, gcd\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, combinations\nimport sys, io, os\ninput = sys.stdin.readline\n# input=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n# sys.setrecursionlimit(10000)\ninf = float('inf')\nmod = 10 ** 9 + 7\ndef yn(a): print(\"YES\" if a else \"NO\")\nceil = lambda a, b: (a + b - 1) // b\nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n        \"\"\"Build a fenwick tree instance.\"\"\"\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n\n    def _fen_findkth(self, k):\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n\n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def _loc_right(self, value):\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\"\"\"\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n\n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return 'SortedList({0})'.format(list(self))\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nt=int(input())\nfor test in range(1,t+1):\n    n=int(input())\n    those_ahead=[[] for i in range(n)]\n    indegree=[ 0 for i in range(n)]\n    s=SortedList()\n    for i in range(n):\n        _,*k=[int(ii)-1 for ii in input().split()]\n        for j in k:\n            those_ahead[j].append(i)\n        indegree[i]=len(k)\n        if indegree[i]==0:\n            s.add(i)\n\n    counter=0\n    visited=set()\n    for i in range(n):\n        counter+=1\n        start=-1\n        while s:\n            indexa=s.bisect_right(start)\n            if indexa==len(s):\n                break\n            start=s.pop(indexa)\n            visited.add(start)\n            # print(f\"index {start}\")\n            for iterate in those_ahead[start]:\n                indegree[iterate]-=1\n                if indegree[iterate]==0:\n                    s.add(iterate)\n        # print(\"loop end\")\n        if start==-1:\n            counter-=1\n            break\n    if len(visited)==n:\n        print(counter)\n    else:\n        print(-1)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long int> g[200003];\nlong long int ind[200003];\nlong long int mx[200003];\nbool vis[200003];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long int t;\n  cin >> t;\n  while (t--) {\n    long long int n;\n    cin >> n;\n    for (long long int i = 1ll; i <= n; i++) {\n      g[i].clear();\n      ind[i] = 0ll;\n      mx[i] = 0ll;\n      vis[i] = 0;\n    }\n    for (long long int i = 1ll; i <= n; i++) {\n      long long int k;\n      cin >> k;\n      for (long long int j = 1ll; j <= k; j++) {\n        long long int x;\n        cin >> x;\n        g[x].push_back(i);\n        ind[i]++;\n      }\n    }\n    queue<long long int> q;\n    for (long long int i = 1ll; i <= n; i++) {\n      if (ind[i] == 0ll) {\n        q.push(i);\n        mx[i] = 1ll;\n      }\n    }\n    while (!q.empty()) {\n      auto node = q.front();\n      q.pop();\n      vis[node] = 1;\n      for (auto it : g[node]) {\n        ind[it]--;\n        if (it < node) {\n          mx[it] = max(mx[it], mx[node] + 1ll);\n        } else {\n          mx[it] = max(mx[it], mx[node]);\n        }\n        if (ind[it] == 0ll) {\n          q.push(it);\n        }\n      }\n    }\n    bool flg = 1;\n    long long int ans = 0ll;\n    for (long long int i = 1ll; i <= n; i++) {\n      if (!vis[i]) {\n        flg = 0ll;\n        break;\n      }\n      ans = max(ans, mx[i]);\n    }\n    if (!flg) {\n      cout << \"-1\"\n           << \"\\n\";\n    } else {\n      cout << ans << \"\\n\";\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 5;\nvector<int> g[maxn];\nvector<int> ans;\nvector<int> used;\nbool cycles(int v) {\n  used[v] = 1;\n  for (auto u : g[v]) {\n    if (used[u] == 1) return true;\n    if (used[u] != 2) {\n      bool cyc = cycles(u);\n      if (cyc) return true;\n    }\n  }\n  used[v] = 2;\n  return false;\n}\nvoid calcAns(int v) {\n  used[v] = true;\n  ans[v] = 1;\n  for (auto u : g[v]) {\n    if (!used[u]) calcAns(u);\n    ans[v] = max(ans[v], ans[u] + (u < v));\n  }\n}\nvoid solveC() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; ++i) {\n    g[i].clear();\n  }\n  for (int i = 0; i < n; ++i) {\n    int k;\n    cin >> k;\n    for (int j = 0; j < k; ++j) {\n      int v;\n      cin >> v;\n      --v;\n      g[v].push_back(i);\n    }\n  }\n  used.assign(n, 0);\n  for (int v = 0; v < n; ++v) {\n    if (!used[v]) {\n      bool cyc = cycles(v);\n      if (cyc) {\n        cout << -1 << endl;\n        return;\n      }\n    }\n  }\n  ans.assign(n, 2 * maxn);\n  used.assign(n, 0);\n  int idx = 0;\n  for (int v = 0; v < n; ++v) {\n    if (!used[v]) calcAns(v);\n    if (ans[v] > ans[idx]) idx = v;\n  }\n  cout << ans[idx] << endl;\n}\nint32_t main() {\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  int t;\n  cin >> t;\n  while (t--) solveC();\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "# ------------------------template--------------------------#\nimport os\nimport sys\nimport math\nimport collections\nimport functools\nimport itertools\n\n# from fractions import *\nimport heapq\nimport bisect\nfrom io import BytesIO, IOBase\n\n\ndef vsInput():\n    sys.stdin = open(\"input.txt\", \"r\")\n    sys.stdout = open(\"output.txt\", \"w\")\n\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nALPHA = \"abcde\"\nMOD = 10 ** 9 + 7\nEPS = 1e-6\nINF = 10 ** 18\n\n\ndef Ceil(a, b):\n    return a // b + int(a % b > 0)\n\n\ndef INT():\n    return int(input())\n\n\ndef STR():\n    return input()\n\n\ndef INTS():\n    return tuple(map(int, input().split()))\n\n\ndef ARRINT():\n    return [int(i) for i in input().split()]\n\n\ndef ARRSTR():\n    return [i for i in input().split()]\n\n\n# -------------------------code---------------------------#\n\n\nfor t in range(INT()):\n    n = INT()\n\n    GRAPH = [[] for _ in range(n)]\n    CNT = [0] * n\n    LEVEL = [0] * n\n\n    for i in range(n):\n        ka = ARRINT()\n\n        for jj in range(1, len(ka)):\n            j = ka[jj] - 1\n            GRAPH[j] += [i]\n            CNT[i] += 1\n\n    q = collections.deque([])\n\n    for i in range(n):\n        if CNT[i] == 0:\n            q += [i]\n\n    end = 0\n    while q:\n        cur = q.popleft()\n        end += 1\n\n        for nex in GRAPH[cur]:\n            CNT[nex] -= 1\n\n            if cur > nex:\n                LEVEL[nex] = max(LEVEL[nex], LEVEL[cur] + 1)\n            else:\n                LEVEL[nex] = max(LEVEL[nex], LEVEL[cur])\n\n            if CNT[nex] == 0:\n                q += [nex]\n\n    if end == n:\n        print(max(LEVEL) + 1)\n    else:\n        print(-1)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mod_add(long long a, long long b, long long m) {\n  a = a % m;\n  b = b % m;\n  return (((a + b) % m) + m) % m;\n}\nlong long mod_mul(long long a, long long b, long long m) {\n  a = a % m;\n  b = b % m;\n  return (((a * b) % m) + m) % m;\n}\nlong long mod_sub(long long a, long long b, long long m) {\n  a = a % m;\n  b = b % m;\n  return (((a - b) % m) + m) % m;\n}\nvector<long long> to_binary(long long n) {\n  int i = 7;\n  vector<long long> ans(8);\n  while (n >= 2) {\n    ans[i] = n % 2;\n    n /= 2;\n    i--;\n  }\n  ans[i] = n;\n  return ans;\n}\nmap<long long, long long> primefactorisation(long long n) {\n  map<long long, long long> mp;\n  for (long long i = 2; i * i <= n; i++) {\n    if (n % i == 0) {\n      mp[i] = 0;\n      while (n % i == 0) {\n        mp[i]++;\n        n /= i;\n      }\n    }\n  }\n  if (n > 1) {\n    mp[n] = 1;\n  }\n  return mp;\n}\nvector<bool> seive(long long n) {\n  vector<bool> arr(n + 1, true);\n  for (int i = 2; i * i <= n; i++) {\n    if (arr[i]) {\n      for (int j = i * i; j <= n; j += i) {\n        arr[j] = false;\n      }\n    }\n  }\n  return arr;\n}\nlong long powM(long long x, long long y) {\n  long long ans = 1, r = 1;\n  x %= (long long)(1e9 + 7);\n  while (r > 0 && r <= y) {\n    if (r & y) {\n      ans *= x;\n      ans %= (long long)(1e9 + 7);\n    }\n    r <<= 1;\n    x *= x;\n    x %= (long long)(1e9 + 7);\n  }\n  return ans;\n}\nbool isprime(long long x) {\n  for (long long i = 2; i * i <= x; i++) {\n    if (x % i == 0) {\n      return 0;\n    }\n  }\n  return 1;\n}\nbool cmp(pair<long long, long long> p1, pair<long long, long long> p2) {\n  return (p1.first > p2.first);\n}\nvoid ipgraph(vector<set<long long>>& edge, long long v, long long e) {\n  for (int i = 0; i < e; i++) {\n    long long a, b;\n    cin >> a >> b;\n    edge[a].insert(b);\n    edge[b].insert(a);\n  }\n}\nvoid bfs(vector<vector<long long>>& edge, long long start,\n         vector<bool>& visited) {\n  long long curr = start;\n  queue<long long> qq;\n  qq.push(curr);\n  visited[curr] = 1;\n  while (!qq.empty()) {\n    curr = qq.front();\n    for (long long x : edge[curr]) {\n      if (!visited[x]) {\n        qq.push(x);\n        visited[x] = 1;\n      }\n    }\n    qq.pop();\n  }\n}\nvector<string> bor = {\"YES\", \"NO\"};\nlong long dfs(vector<vector<long long>>& edge, long long start,\n              vector<pair<bool, long long>>& visited) {\n  long long curr = start;\n  visited[curr].first = 1;\n  long long ans = -1;\n  if (edge[curr].empty()) {\n    visited[curr].second = 1;\n    return 1;\n  }\n  for (long long x : edge[curr]) {\n    if (!visited[x].first) {\n      long long temp = dfs(edge, x, visited);\n      if (temp < 0) {\n        visited[curr].second = -1;\n        return -1;\n      }\n      if (x < curr) {\n        ans = max(ans, temp);\n      } else {\n        ans = max(ans, temp + 1);\n      }\n    } else {\n      if (visited[x].second < 0) {\n        visited[curr].second = -1;\n        return -1;\n      }\n      if (x < curr) {\n        ans = max(ans, visited[x].second);\n      } else {\n        ans = max(ans, visited[x].second + 1);\n      }\n    }\n  }\n  visited[curr].second = ans;\n  return ans;\n}\nvoid solve() {\n  long long n;\n  cin >> n;\n  vector<pair<bool, long long>> visited(n + 1, {0, -1});\n  vector<vector<long long>> edge(n + 1);\n  long long count = 0;\n  for (int i = 1; i <= n; i++) {\n    long long k = 0;\n    cin >> k;\n    bool fg = 1;\n    for (int j = 0; j < k; j++) {\n      long long temp;\n      cin >> temp;\n      edge[i].push_back(temp);\n      if (!visited[temp].first) {\n        fg = 0;\n      }\n    }\n    if (fg) {\n      count++;\n      visited[i].second = 1;\n      visited[i].first = 1;\n    }\n  }\n  if (count == 0) {\n    cout << -1 << \"\\n\";\n    return;\n  }\n  long long ans = -1;\n  for (int i = 1; i <= n; i++) {\n    if (!visited[i].first) {\n      long long tempxx = dfs(edge, i, visited);\n      if (tempxx < 0) {\n        cout << -1 << \"\\n\";\n        return;\n      }\n      ans = max(ans, tempxx);\n    } else {\n      if (visited[i].second == -1) {\n        cout << -1 << \"\\n\";\n        return;\n      }\n      ans = max(ans, visited[i].second);\n    }\n    if (ans < 0) {\n      cout << -1 << \"\\n\";\n      return;\n    }\n  }\n  cout << ans << \"\\n\";\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long t = 1;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 2e5 + 5;\nconst long long MOD = 1e9 + 7;\nconst double EPS = 1e-8;\nvector<int> mp[MAX_N];\nint indegree[MAX_N], ans[MAX_N];\nint topo(int n) {\n  int cnt = 0, res = 1;\n  for (int i = 1; i <= n; i++) ans[i] = 1;\n  queue<int> q;\n  for (int i = 1; i <= n; i++) {\n    if (indegree[i] == 0) {\n      q.push(i);\n      cnt++;\n    }\n  }\n  while (!q.empty()) {\n    int x = q.front();\n    q.pop();\n    for (auto y : mp[x]) {\n      if (indegree[y] == 0) return false;\n      indegree[y]--;\n      ans[y] = max(ans[y], ans[x] + (x > y));\n      res = max(ans[y], res);\n      if (indegree[y] == 0) {\n        q.push(y);\n        cnt++;\n      }\n    }\n  }\n  if (cnt < n) return -1;\n  return res;\n}\nint main() {\n  int T, n, m, x;\n  scanf(\"%d\", &T);\n  while (T--) {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) mp[i].clear();\n    for (int i = 1; i <= n; i++) {\n      scanf(\"%d\", &indegree[i]);\n      for (int j = 1; j <= indegree[i]; j++) {\n        scanf(\"%d\", &x);\n        mp[x].push_back(i);\n      }\n    }\n    printf(\"%d\\n\", topo(n));\n  }\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "from sys import stdin\nfrom heapq import heappush, heappop\nraw_input = lambda: stdin.readline().rstrip()\ninput = lambda: int(raw_input())\nI=lambda: map(int, raw_input().split())\nt = input()\nfor _ in xrange(t):\n\tn = input()\n\td = {}\n\tnumLst = [0]\n\tq1 = []\n\tq2 = []\n\tfor i in xrange(n):\n\t\tlst = I()\n\t\tk = lst[0]\n\t\tnumLst.append(k)\n\t\tif k>0:\n\t\t\tfor x in lst[1:]:\n\t\t\t\tif x not in d:\n\t\t\t\t\td[x] = []\n\t\t\t\td[x].append(i+1)\n\t\telse:\n\t\t\theappush(q1, i+1)\n\tr = 0\n\twhile n>0 and q1:\n\t\tr += 1\n\t\twhile q1:\n\t\t\ti = heappop(q1)\n\t\t\tn -= 1\n\t\t\tif i in d:\n\t\t\t\tfor j in d[i]:\n\t\t\t\t\tnumLst[j] -= 1\n\t\t\t\t\tif numLst[j]==0:\n\t\t\t\t\t\tif j>i:\n\t\t\t\t\t\t\theappush(q1, j)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\theappush(q2, j)\n\t\tq1, q2 = q2, q1\n\tif n>0:\n\t\tprint -1\n\telse:\n\t\tprint r\n\t\t\n\t\t"
        },
        {
            "language": 3,
            "solution": "import os, sys\nfrom io import BytesIO, IOBase\nimport operator as op\nfrom bisect import *\nfrom itertools import chain, repeat, starmap\nfrom functools import reduce\n\n\nclass SortedList():\n    \"\"\"Sorted list is a sorted mutable sequence.\"\"\"\n    DEFAULT_LOAD_FACTOR = 500\n\n    def __init__(self, iterable=None):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        self._len = 0\n        self._load = self.DEFAULT_LOAD_FACTOR\n        self._lists = []\n        self._maxes = []\n        self._index = []\n        self._offset = 0\n        if iterable is not None:\n            self.update(iterable)\n\n    def clear(self):\n        \"\"\"Remove all values from sorted list.\"\"\"\n        self._len = 0\n        del self._lists[:]\n        del self._maxes[:]\n        del self._index[:]\n        self._offset = 0\n\n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\"\"\"\n        _lists = self._lists\n        _maxes = self._maxes\n        if _maxes:\n            pos = bisect_right(_maxes, value)\n            if pos == len(_maxes):\n                _lists[pos - 1].append(value)\n                _maxes[pos - 1] = value\n            else:\n                insort(_lists[pos], value)\n            self._expand(pos)\n        else:\n            _lists.append([value])\n            _maxes.append(value)\n        self._len += 1\n\n    def _expand(self, pos):\n        \"\"\"Split sublists with length greater than double the load-factor.\"\"\"\n        _load = self._load\n        _lists = self._lists\n        _index = self._index\n\n        if len(_lists[pos]) > (_load << 1):\n            _maxes = self._maxes\n            _lists_pos = _lists[pos]\n            half = _lists_pos[_load:]\n            del _lists_pos[_load:]\n            _maxes[pos] = _lists_pos[-1]\n            _lists.insert(pos + 1, half)\n            _maxes.insert(pos + 1, half[-1])\n            del _index[:]\n        else:\n            if _index:\n                child = self._offset + pos\n                while child:\n                    _index[child] += 1\n                    child = (child - 1) >> 1\n                _index[0] += 1\n\n    def update(self, iterable):\n        \"\"\"Update sorted list by adding all values from `iterable`.\"\"\"\n        _lists = self._lists\n        _maxes = self._maxes\n        values = sorted(iterable)\n\n        if _maxes:\n            if len(values) * 4 >= self._len:\n                values.extend(chain.from_iterable(_lists))\n                values.sort()\n                self.clear()\n            else:\n                _add = self.add\n                for val in values:\n                    _add(val)\n                return\n\n        _load = self._load\n        _lists.extend(values[pos:(pos + _load)] for pos in range(0, len(values), _load))\n        _maxes.extend(sublist[-1] for sublist in _lists)\n        self._len = len(values)\n        del self._index[:]\n\n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n        _maxes = self._maxes\n        pos = bisect_left(_maxes, value)\n        if pos == len(_maxes):\n            return False\n\n        _lists = self._lists\n        idx = bisect_left(_lists[pos], value)\n        return _lists[pos][idx] == value\n\n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n        _maxes = self._maxes\n        pos = bisect_left(_maxes, value)\n        if pos == len(_maxes):\n            return\n\n        _lists = self._lists\n        idx = bisect_left(_lists[pos], value)\n        if _lists[pos][idx] == value:\n            self._delete(pos, idx)\n\n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        _maxes = self._maxes\n        _index = self._index\n\n        _lists_pos = _lists[pos]\n        del _lists_pos[idx]\n        self._len -= 1\n\n        len_lists_pos = len(_lists_pos)\n        if len_lists_pos > (self._load >> 1):\n            _maxes[pos] = _lists_pos[-1]\n\n            if _index:\n                child = self._offset + pos\n                while child > 0:\n                    _index[child] -= 1\n                    child = (child - 1) >> 1\n                _index[0] -= 1\n        elif len(_lists) > 1:\n            if not pos:\n                pos += 1\n            prev = pos - 1\n            _lists[prev].extend(_lists[pos])\n            _maxes[prev] = _lists[prev][-1]\n            del _lists[pos]\n            del _maxes[pos]\n            del _index[:]\n            self._expand(prev)\n        elif len_lists_pos:\n            _maxes[pos] = _lists_pos[-1]\n        else:\n            del _lists[pos]\n            del _maxes[pos]\n            del _index[:]\n\n    def _loc(self, pos, idx):\n        \"\"\"Convert an index pair (lists index, sublist index) into a single\n        index number that corresponds to the position of the value in the\n        sorted list.\"\"\"\n        if not pos:\n            return idx\n\n        _index = self._index\n        if not _index:\n            self._build_index()\n        total = 0\n        pos += self._offset\n        while pos:\n            if not pos & 1:\n                total += _index[pos - 1]\n            pos = (pos - 1) >> 1\n        return total + idx\n\n    def _pos(self, idx):\n        \"\"\"Convert an index into an index pair (lists index, sublist index)\n        that can be used to access the corresponding lists position.\"\"\"\n        if idx < 0:\n            last_len = len(self._lists[-1])\n            if (-idx) <= last_len:\n                return len(self._lists) - 1, last_len + idx\n            idx += self._len\n            if idx < 0:\n                raise IndexError('list index out of range')\n        elif idx >= self._len:\n            raise IndexError('list index out of range')\n\n        if idx < len(self._lists[0]):\n            return 0, idx\n\n        _index = self._index\n        if not _index:\n            self._build_index()\n\n        pos = 0\n        child = 1\n        len_index = len(_index)\n        while child < len_index:\n            index_child = _index[child]\n            if idx < index_child:\n                pos = child\n            else:\n                idx -= index_child\n                pos = child + 1\n            child = (pos << 1) + 1\n        return (pos - self._offset, idx)\n\n    def _build_index(self):\n        \"\"\"Build a positional index for indexing the sorted list.\"\"\"\n        row0 = list(map(len, self._lists))\n        if len(row0) == 1:\n            self._index[:] = row0\n            self._offset = 0\n            return\n\n        head = iter(row0)\n        tail = iter(head)\n        row1 = list(starmap(op.add, zip(head, tail)))\n        if len(row0) & 1:\n            row1.append(row0[-1])\n        if len(row1) == 1:\n            self._index[:] = row1 + row0\n            self._offset = 1\n            return\n\n        size = 1 << (len(row1) - 1).bit_length()\n        row1.extend(repeat(0, size - len(row1)))\n        tree = [row0, row1]\n        while len(tree[-1]) > 1:\n            head = iter(tree[-1])\n            tail = iter(head)\n            row = list(starmap(op.add, zip(head, tail)))\n            tree.append(row)\n        reduce(list.__iadd__, reversed(tree), self._index)\n        self._offset = size * 2 - 1\n\n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        if isinstance(index, slice):\n            start, stop, step = index.indices(self._len)\n            if step == 1 and start < stop:\n                if start == 0 and stop == self._len:\n                    return self.clear()\n                elif self._len <= 8 * (stop - start):\n                    values = self.__getitem__(slice(None, start))\n                    if stop < self._len:\n                        values += self.__getitem__(slice(stop, None))\n                    self.clear()\n                    return self.update(values)\n\n            indices = range(start, stop, step)\n            if step > 0:\n                indices = reversed(indices)\n            _pos, _delete = self._pos, self._delete\n            for index in indices:\n                pos, idx = _pos(index)\n                _delete(pos, idx)\n        else:\n            pos, idx = self._pos(index)\n            self._delete(pos, idx)\n\n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        _lists = self._lists\n\n        if isinstance(index, slice):\n            start, stop, step = index.indices(self._len)\n\n            if step == 1 and start < stop:\n                if start == 0 and stop == self._len:\n                    return reduce(list.__iadd__, self._lists, [])\n\n                start_pos, start_idx = self._pos(start)\n                if stop == self._len:\n                    stop_pos = len(_lists) - 1\n                    stop_idx = len(_lists[stop_pos])\n                else:\n                    stop_pos, stop_idx = self._pos(stop)\n                if start_pos == stop_pos:\n                    return _lists[start_pos][start_idx:stop_idx]\n\n                prefix = _lists[start_pos][start_idx:]\n                middle = _lists[(start_pos + 1):stop_pos]\n                result = reduce(list.__iadd__, middle, prefix)\n                result += _lists[stop_pos][:stop_idx]\n                return result\n\n            if step == -1 and start > stop:\n                result = self.__getitem__(slice(stop + 1, start + 1))\n                result.reverse()\n                return result\n\n            indices = range(start, stop, step)\n            return list(self.__getitem__(index) for index in indices)\n        else:\n            if self._len:\n                if index == 0:\n                    return _lists[0][0]\n                elif index == -1:\n                    return _lists[-1][-1]\n            else:\n                raise IndexError('list index out of range')\n\n            if 0 <= index < len(_lists[0]):\n                return _lists[0][index]\n\n            len_last = len(_lists[-1])\n            if -len_last < index < 0:\n                return _lists[-1][len_last + index]\n\n            pos, idx = self._pos(index)\n            return _lists[pos][idx]\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return chain.from_iterable(self._lists)\n\n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return chain.from_iterable(map(reversed, reversed(self._lists)))\n\n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n\n    def bisect_left(self, value):\n        \"\"\"Return an index to insert `value` in the sorted list.\"\"\"\n        pos = bisect_left(self._maxes, value)\n        return self._len if pos == len(self._maxes) else self._loc(pos, bisect_left(self._lists[pos], value))\n\n    def bisect_right(self, value):\n        \"\"\"Return an index to insert `value` in the sorted list.\"\"\"\n        pos = bisect_right(self._maxes, value)\n        return self._len if pos == len(self._maxes) else self._loc(pos, bisect_right(self._lists[pos], value))\n\n    bisect = bisect_right\n\n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n        _maxes = self._maxes\n        if not _maxes:\n            return 0\n\n        pos_left = bisect_left(_maxes, value)\n        if pos_left == len(_maxes):\n            return 0\n\n        _lists = self._lists\n        idx_left = bisect_left(_lists[pos_left], value)\n        pos_right = bisect_right(_maxes, value)\n        if pos_right == len(_maxes):\n            return self._len - self._loc(pos_left, idx_left)\n\n        idx_right = bisect_right(_lists[pos_right], value)\n        if pos_left == pos_right:\n            return idx_right - idx_left\n\n        right = self._loc(pos_right, idx_right)\n        left = self._loc(pos_left, idx_left)\n        return right - left\n\n    def copy(self):\n        \"\"\"Return a shallow copy of the sorted list.\"\"\"\n        return self.__class__(self)\n\n    __copy__ = copy\n\n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n        if not self._len:\n            raise IndexError('pop index out of range')\n\n        _lists = self._lists\n        if 0 <= index < len(_lists[0]):\n            val = _lists[0][index]\n            self._delete(0, index)\n            return val\n\n        len_last = len(_lists[-1])\n        if -len_last < index < 0:\n            pos = len(_lists) - 1\n            loc = len_last + index\n            val = _lists[pos][loc]\n            self._delete(pos, loc)\n            return val\n\n        pos, idx = self._pos(index)\n        val = _lists[pos][idx]\n        self._delete(pos, idx)\n        return val\n\n    def index(self, value, start=0, stop=None):\n        \"\"\"Return first index of value in sorted list.\"\"\"\n        _len = self._len\n        if start < 0:\n            start += _len\n        if start < 0:\n            start = 0\n        if stop is None:\n            stop = _len\n        if stop < 0:\n            stop += _len\n        if stop > _len:\n            stop = _len\n\n        if stop <= start:\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        _maxes = self._maxes\n        pos_left = bisect_left(_maxes, value)\n        if pos_left == len(_maxes):\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        _lists = self._lists\n        idx_left = bisect_left(_lists[pos_left], value)\n        if _lists[pos_left][idx_left] != value:\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        stop -= 1\n        left = self._loc(pos_left, idx_left)\n        if start <= left:\n            if left <= stop:\n                return left\n        else:\n            if start <= self.bisect_right(value) - 1:\n                return start\n        raise ValueError('{0!r} is not in list'.format(value))\n\n    def __add__(self, other):\n        \"\"\"Return new sorted list containing all values in both sequences.\"\"\"\n        values = reduce(list.__iadd__, self._lists, [])\n        values.extend(other)\n        return self.__class__(values)\n\n    __radd__ = __add__\n\n    def __iadd__(self, other):\n        \"\"\"Update sorted list with values from `other`.\"\"\"\n        self.update(other)\n        return self\n\n    def __mul__(self, num):\n        \"\"\"Return new sorted list with `num` shallow copies of values.\"\"\"\n        values = reduce(list.__iadd__, self._lists, []) * num\n        return self.__class__(values)\n\n    __rmul__ = __mul__\n\n    def __imul__(self, num):\n        \"\"\"Update the sorted list with `num` shallow copies of values.\"\"\"\n        values = reduce(list.__iadd__, self._lists, []) * num\n        self.clear()\n        self.update(values)\n        return self\n\n    def __make_cmp(seq_op):\n        \"Make comparator method.\"\n\n        def comparer(self, other):\n            \"Compare method for sorted list and sequence.\"\n            self_len = self._len\n            len_other = len(other)\n            if self_len != len_other:\n                if seq_op is op.eq:\n                    return False\n                if seq_op is op.ne:\n                    return True\n\n            for alpha, beta in zip(self, other):\n                if alpha != beta:\n                    return seq_op(alpha, beta)\n            return seq_op(self_len, len_other)\n\n        comparer.__name__ = '__{0}__'.format(seq_op.__name__)\n        return comparer\n\n    __eq__ = __make_cmp(op.eq)\n    __ne__ = __make_cmp(op.ne)\n    __lt__ = __make_cmp(op.lt)\n    __gt__ = __make_cmp(op.gt)\n    __le__ = __make_cmp(op.le)\n    __ge__ = __make_cmp(op.ge)\n    __make_cmp = staticmethod(__make_cmp)\n\n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return 'SortedList({0})'.format(reduce(list.__iadd__, self._lists, []))\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\ninp = lambda dtype: [dtype(x) for x in input().split()]\ninp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]\ninp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]\ninp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]\ninp_enus = lambda dtype, n: [[i] + inp(dtype) for i in range(n)]\nceil1 = lambda a, b: (a + b - 1) // b\n\n\nclass graph:\n    def __init__(self, n):\n        self.n, self.gdict = n, [[] for _ in range(n + 1)]\n        self.indeg = [0] * (n + 1)\n\n    def addEdge(self, node1, node2, w=None):\n        self.gdict[node1].append(node2)\n        self.indeg[node2] += 1\n\n    def kahn(self, n):\n        # enqueue all node with 0 in degree\n        queue, ans, lst = SortedList([i for i in range(1, n + 1) if not self.indeg[i]] + [10 ** 6]), 1, -1\n        cnt = 0\n\n        while len(queue) > 1:\n            # pop and push into topsort\n            ix = queue.bisect_right(lst)\n\n            if queue[ix] == 10 ** 6:\n                ix = 0\n                ans += 1\n\n            lst = s = queue.pop(ix)\n\n            for i in self.gdict[s]:\n                self.indeg[i] -= 1\n                if not self.indeg[i]:\n                    queue.add(i)\n\n            cnt += 1\n        # check cycle\n        print(-1 if cnt != n else ans)\n\n\nfor _ in range(int(input())):\n    n = int(input())\n    g = graph(n)\n\n    for i in range(n):\n        for x in inp(int)[1:]:\n            g.addEdge(x, i + 1)\n    g.kahn(n)\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\n\npublic class C {\n\tpublic static void main(String[] args)\n    {\n        FastReader s=new FastReader();\n        int t = s.nextInt();         // Number of test cases\n        \n        \n        for (int i = 0; i<t; i++) {\n        \tint n = s.nextInt();\n        \tint[] indegree = new int[n+1];\n        \tList<List<Integer>> list = new ArrayList<>();\n        \t\n        \tfor (int j = 0; j<=n; j++) {                // n+1 elements in graph, 1 to n are important for us.\n        \t\tlist.add(new ArrayList<>());\n        \t}\n        \t\n        \tQueue<Integer> q = new ArrayDeque<>();\n        \tList<Integer> order = new ArrayList<>();\n        \tint[] day = new int[n+1];\n        \tArrays.fill(day, -1);\n        \tfor (int j = 1; j<=n; j++) {\n        \t\tindegree[j] = s.nextInt();\n        \t\tfor (int k = 0; k<indegree[j]; k++) {\n        \t\t\tint parent = s.nextInt();\n            \t\tlist.get(parent).add(j);\n        \t\t}\t\n        \t\tif (indegree[j] == 0) {\n        \t\t\tq.add(j);\n        \t\t\tday[j] = 1;\n        \t\t}\n        \t}\n        \tint index = 0;\n//        \tprintArray(day);\n//        \tSystem.out.print(\"indgree = \");\n//        \tprintArray(indegree);\n//        \tSystem.out.println(list);\n//        \tSystem.out.println(q.size());\n        \t\n        \t\n        \twhile (q.size() > 0) {\n        \t\tint rem = q.remove();\n        \t\torder.add(rem);\n        \t\tindex++;\n        \t\t\n        \t\tfor (int child : list.get(rem)) {\n        \t\t\tif (rem < child) {\n    \t\t\t\t\tday[child] = Math.max(day[rem], day[child]);\n    \t\t\t\t}else {\n    \t\t\t\t\tday[child] = Math.max(day[rem]+1, day[child]);\n    \t\t\t\t}\n        \t\t\t\n        \t\t\t\n        \t\t\tindegree[child] -= 1;\n        \t\t\tif (indegree[child] == 0) {\n        \t\t\t\tq.add(child);\n        \t\t\t\t\n        \t\t\t\t\n        \t\t\t}\n        \t\t}\n        \t}\n        \tif (index != n) {\n        \t\tSystem.out.println(-1);\n        \t}else {\n        \t\tint maxDay = Integer.MIN_VALUE;\n        \t\tfor (int j = 1; j<day.length; j++) {\n            \t\t\n            \t\tmaxDay = Math.max(maxDay, day[j]);\n            \t}\n        \t\tSystem.out.println(maxDay);\n        \t}\n//        \tprintArray(day);\n//        \t\n//        \tboolean done = false;\n//        \t\n//        \tif (done == false) \n        }\n\n        \n\n        \n        \n    }\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    static void printArray(int[] arr) {\n    \tfor (int i = 0; i<arr.length; i++) {\n    \t\tSystem.out.print(arr[i] + \" \");\n    \t}\n    \tSystem.out.println();\n    }\n    \n    static void sort(int[] a) {\n    \tArrayList<Integer> l = new ArrayList<>();\n    \tfor (int i : a) l.add(i);\n    \tCollections.sort(l);\n    \tfor (int i = 0; i<a.length; i++) {\n    \t\ta[i]=l.get(i);\n    \t}\n    }\n    \n    \n    \n    \n    \n\tstatic class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastReader()\n        {\n            br = new BufferedReader(new\n                     InputStreamReader(System.in));\n        }\n \n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n \n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n \n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n \n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "from __future__ import division, print_function\nimport math\nimport sys\nimport os\nfrom io import BytesIO, IOBase\nfrom collections import deque, Counter, OrderedDict, defaultdict\n#import heapq\n#ceil,floor,log,sqrt,factorial,pow,pi,gcd\n#import bisect\n#from bisect import bisect_left,bisect_right\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = \"x\" in file.mode or \"r\" not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\tself.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b\"\\n\") + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\tself.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\tself.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n\t\tself.read = lambda: self.buffer.read().decode(\"ascii\")\n\t\tself.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n\t\"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n\tsep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n\tat_start = True\n\tfor x in args:\n\t\tif not at_start:\n\t\t\tfile.write(sep)\n\t\tfile.write(str(x))\n\t\tat_start = False\n\tfile.write(kwargs.pop(\"end\", \"\\n\"))\n\tif kwargs.pop(\"flush\", False):\n\t\tfile.flush()\n\n\nif sys.version_info[0] < 3:\n\tsys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n\tsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef inp():\n    return(int(input()))\ndef inps():\n    return input().strip()\ndef inlt():\n    return(list(map(int,input().split())))\ndef insr():\n    s = input().strip()\n    return(list(s[:len(s)]))\ndef invr():\n    return(map(int,input().split()))\n\nfrom collections import defaultdict\n \nclass Graph():\n    def __init__(self,vertices):\n        self.graph = defaultdict(list)\n        self.V = vertices\n \n    def addEdge(self,u,v):\n        self.graph[u].append(v)\n \n    def isCyclicUtil(self, v, visited, recStack):\n        visited[v] = True\n        recStack[v] = True\n        for neighbour in self.graph[v]:\n            if visited[neighbour] == False:\n                if self.isCyclicUtil(neighbour, visited, recStack) == True:\n                    return True\n            elif recStack[neighbour] == True:\n                return True\n \n        recStack[v] = False\n        return False\n \n    def isCyclic(self):\n        visited = [False] * (self.V + 1)\n        recStack = [False] * (self.V + 1)\n        for node in range(self.V):\n            if visited[node] == False:\n                if self.isCyclicUtil(node,visited,recStack) == True:\n                    return True\n        return False\n    def topologicalSortUtil(self, v, visited, stack):\n        visited[v] = True\n        for i in self.graph[v]:\n            if visited[i] == False:\n                self.topologicalSortUtil(i, visited, stack)\n        stack.append(v)\n    def topologicalSort(self):\n        visited = [False]*self.V\n        stack = []\n        for i in range(self.V):\n            if visited[i] == False:\n                self.topologicalSortUtil(i, visited, stack)\n        return stack[::-1]\n\nfor _ in range(inp()):\n    n=inp()\n    d=defaultdict(lambda:[])\n    g=Graph(n)\n    d2=defaultdict(lambda:[])\n    for i in range(n):\n        lst=inlt()\n        for j in range(1,len(lst)):\n            d[i].append(lst[j]-1)\n            g.addEdge(lst[j]-1,i)\n            d2[lst[j]-1].append(i)\n            \n    if g.isCyclic():\n        print(-1)\n    else:\n        dist=[0 for i in range(n)]\n        s=g.topologicalSort()\n        for v in s:\n            if len(d[v])==0:\n                dist[v]=1\n            for u in d2[v]:\n                if u<v:\n                    dist[u]=max(dist[u],dist[v]+1)\n                else:\n                    dist[u]=max(dist[u],dist[v])\n        print(max(dist))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\nqueue<int> q;\npriority_queue<int, vector<int>, greater<int> > q1;\nint h[N], ne[N], e[N], idx = 0, d[N];\nvoid add(int a, int b) {\n  e[idx] = b;\n  ne[idx] = h[a];\n  h[a] = idx++;\n}\nvoid solve() {\n  int n, sum = 0, all = 0, i, j, b;\n  idx = 0;\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; ++i) {\n    h[i] = -1;\n    d[i] = 0;\n  }\n  for (i = 1; i <= n; ++i) {\n    scanf(\"%d\", &d[i]);\n    for (j = 1; j <= d[i]; ++j) {\n      scanf(\"%d\", &b);\n      add(b, i);\n    }\n    if (d[i] == 0) {\n      q1.push(i);\n      all++;\n    }\n  }\n  while (q1.size()) {\n    sum++;\n    while (q1.size()) {\n      int k = q1.top();\n      q1.pop();\n      for (i = h[k]; i != -1; i = ne[i]) {\n        d[e[i]]--;\n        if (d[e[i]] == 0) {\n          all++;\n          if (e[i] < k) {\n            q.push(e[i]);\n          } else {\n            q1.push(e[i]);\n          }\n        }\n      }\n    }\n    while (q.size()) {\n      int k = q.front();\n      q.pop();\n      q1.push(k);\n    }\n  }\n  if (all == n)\n    printf(\"%d\\n\", sum);\n  else\n    printf(\"-1\\n\");\n}\nint main() {\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) solve();\n}\n"
        },
        {
            "language": 3,
            "solution": "\nfrom collections import deque\ndef cycle_detectable_topological_sort(g, ind):\n    V = len(g)\n    order = []\n    depth = [-1]*V\n    for i in range(V):\n        if not ind[i]:\n            order.append(i)\n            depth[i] = 0\n\n    q = deque(order)\n    while q:\n        v = q.popleft()\n        cur_depth = depth[v]\n        for u in g[v]:\n            ind[u] -= 1\n            if not ind[u]:\n                depth[u] = max(depth[u], cur_depth+1)\n                q.append(u)\n                order.append(u)\n    if len(order) == V:\n        return (order, depth)\n    else:\n        return (None, None)\n\nimport sys\nimport io, os\n#input = sys.stdin.buffer.readline\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    A = []\n    for i in range(n):\n        temp = list(map(int, input().split()))\n        temp = temp[1:]\n        temp = [a-1 for a in temp]\n        A.append(temp)\n    #print(A)\n    g = [[] for i in range(n)]\n    rg = [[] for i in range(n)]\n    ind =[0]*n\n    for i, l in enumerate(A):\n        for j in l:\n            g[i].append(j)\n            rg[j].append(i)\n            ind[j] += 1\n    order, depth = cycle_detectable_topological_sort(g, ind)\n    #print(order, depth)\n    if not order:\n        print(-1)\n        continue\n    order.reverse()\n    dp = [0]*n\n    for v in order:\n        if len(g[v]) == 0:\n            dp[v] = 1\n        for u in rg[v]:\n            if u < v:\n                dp[u] = max(dp[u], dp[v]+1)\n            else:\n                dp[u] = max(dp[u], dp[v])\n    print(max(dp))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid test_case() {\n  long long n;\n  cin >> n;\n  vector<long long> adj[n];\n  vector<long long> indegree(n);\n  for (long long v = 0; v < n; v++) {\n    long long u, k;\n    cin >> k;\n    while (k--) {\n      cin >> u;\n      u--;\n      adj[u].push_back(v);\n      indegree[v]++;\n    }\n  }\n  set<long long> s;\n  for (long long i = 0; i < n; i++)\n    if (indegree[i] == 0) s.insert(i);\n  long long res = 0, cnt = 0;\n  while (!s.empty()) {\n    res++;\n    long long curr = -1;\n    while (true) {\n      auto it = s.upper_bound(curr);\n      if (it == s.end()) break;\n      curr = *it;\n      cnt++;\n      s.erase(it);\n      for (long long &v : adj[curr]) {\n        indegree[v]--;\n        if (indegree[v] == 0) s.insert(v);\n      }\n    }\n  }\n  cout << (cnt == n ? res : -1) << \"\\n\";\n}\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  long long tc;\n  cin >> tc;\n  while (tc--) {\n    test_case();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint expo(int x, int y) {\n  int res = 1;\n  while (y) {\n    if (y % 2) res = (res * x % 1000000007) % 1000000007;\n    x = (x * x) % 1000000007;\n    y /= 2;\n  }\n  return res;\n}\nbool isPrime(long long n) {\n  if (n <= 1) return false;\n  if (n <= 3) return true;\n  if (n % 2 == 0 || n % 3 == 0) return false;\n  for (long long i = 5; i * i <= n; i = i + 6)\n    if (n % i == 0 || n % (i + 2) == 0) return false;\n  return true;\n}\nlong long nextPrime(long long N) {\n  if (N <= 1) return 2;\n  long long prime = N;\n  bool found = false;\n  while (!found) {\n    prime++;\n    if (isPrime(prime)) found = true;\n  }\n  return prime;\n}\nlong long cl(long long n, long long d) { return (n + d - 1) / d; }\nlong long binToDec(string s) { return bitset<64>(s).to_ullong(); }\nstring decToBin(long long a) { return bitset<64>(a).to_string(); }\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long lcm(long long a, long long b) { return (a * b) / (gcd(a, b)); }\nvoid print(pair<long long, long long> a) {\n  cout << a.first << ' ' << a.second;\n  cout << endl;\n  ;\n}\nvoid print(long long a) {\n  cout << a;\n  cout << endl;\n}\nvoid print(std::vector<long long> a) {\n  for (auto i : a) cout << i << ' ';\n  cout << endl;\n  ;\n}\nvoid print(string s) {\n  cout << s;\n  cout << endl;\n  ;\n}\nvoid printr(std::vector<long long> a, long long start, long long end) {\n  for (long long i = start; i < end; i++) cout << a[i] << ' ';\n  cout << endl;\n  ;\n}\nvoid print(long long a, long long b) { cout << a << ' ' << b; }\nvoid amax(long long &a, long long b) { a = max(a, b); }\nvoid amin(long long &a, long long b) { a = min(a, b); }\nlong long madd(long long a, long long b) {\n  return ((a % 1000000007) + (b % 1000000007)) % 1000000007;\n}\nlong long mmul(long long a, long long b) {\n  return ((a % 1000000007) * (b % 1000000007)) % 1000000007;\n}\nlong long msub(long long a, long long b) {\n  return ((a % 1000000007) - (b % 1000000007) + 1000000007) % 1000000007;\n}\nlong long fpow(long long x, long long y, long long p = 1000000007) {\n  x %= p;\n  long long sum = 1;\n  while (y) {\n    if (y & 1) sum = sum * x;\n    sum %= p;\n    y = y >> 1;\n    x = x * x;\n    x %= p;\n  }\n  return sum;\n}\nbool isPerSquare(long double a) {\n  if (a < 0) return false;\n  long long sr = sqrt(a);\n  return (sr * sr == a);\n}\nbool isPalindrome(string str) {\n  long long low = 0, high = long long(str.size()) - 1;\n  while (low < high) {\n    if (str[low] != str[high]) return false;\n    low++, high--;\n  }\n  return true;\n}\nconst long long N = 1e6;\nvector<set<long long> > indegree(N + 1), out(N + 1);\nvoid solve() {\n  long long n;\n  cin >> n;\n  ;\n  for (__typeof(n + 1) i = (1) - ((1) > (n + 1));\n       i != (n + 1) - ((1) > (n + 1)); i += 1 - 2 * ((1) > (n + 1))) {\n    indegree[i].clear();\n    out[i].clear();\n  }\n  for (__typeof(n + 1) i = (1) - ((1) > (n + 1));\n       i != (n + 1) - ((1) > (n + 1)); i += 1 - 2 * ((1) > (n + 1))) {\n    long long x;\n    cin >> x;\n    ;\n    for (__typeof(x) j = (0) - ((0) > (x)); j != (x) - ((0) > (x));\n         j += 1 - 2 * ((0) > (x))) {\n      long long y;\n      cin >> y;\n      ;\n      indegree[y].insert(i);\n      out[i].insert(y);\n    }\n  }\n  set<long long> sink;\n  for (long long i = 1; i <= n; i++) {\n    if (long long(out[i].size()) == 0) {\n      sink.insert(i);\n    }\n  }\n  long long ans = 1, removed = 0, top;\n  if (long long(sink.size())) top = *sink.begin();\n  while (1) {\n    if (removed == n) {\n      print(ans);\n      return;\n    }\n    if (long long(sink.size()) == 0) {\n      print(-1);\n      return;\n    }\n    sink.erase(top);\n    removed++;\n    for (auto j : indegree[top]) {\n      out[j].erase(top);\n      if (long long(out[j].size()) == 0) {\n        sink.insert(j);\n      }\n    }\n    if (removed == n) {\n      print(ans);\n      return;\n    }\n    if (long long(sink.size()) == 0) {\n      print(-1);\n      return;\n    }\n    if (sink.upper_bound(top) == sink.end()) {\n      top = *sink.begin();\n      ans++;\n    } else {\n      top = *sink.upper_bound(top);\n    }\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  long long t;\n  cin >> t;\n  while (t--) solve();\n}\n"
        },
        {
            "language": 3,
            "solution": "import os, sys\nfrom io import BytesIO, IOBase\nimport operator as op\nfrom bisect import *\nfrom itertools import chain, repeat, starmap\nfrom functools import reduce\n\nimport sys\nimport traceback\nfrom bisect import bisect_left, bisect_right, insort\nfrom itertools import chain, repeat, starmap\nfrom math import log\nfrom operator import add, eq, ne, gt, ge, lt, le, iadd\nfrom textwrap import dedent\n\ntry:\n    from collections.abc import Sequence, MutableSequence\nexcept ImportError:\n    from collections import Sequence, MutableSequence\n\nfrom functools import wraps\nfrom sys import hexversion\nfrom functools import reduce\n\ntry:\n    from _thread import get_ident\nexcept ImportError:\n    from _dummy_thread import get_ident\n\n\ndef recursive_repr(fillvalue='...'):\n    \"Decorator to make a repr function return fillvalue for a recursive call.\"\n\n    # pylint: disable=missing-docstring\n    # Copied from reprlib in Python 3\n    # https://hg.python.org/cpython/file/3.6/Lib/reprlib.py\n\n    def decorating_function(user_function):\n        repr_running = set()\n\n        @wraps(user_function)\n        def wrapper(self):\n            key = id(self), get_ident()\n            if key in repr_running:\n                return fillvalue\n            repr_running.add(key)\n            try:\n                result = user_function(self)\n            finally:\n                repr_running.discard(key)\n            return result\n\n        return wrapper\n\n    return decorating_function\n\n\nclass SortedList(MutableSequence):\n    DEFAULT_LOAD_FACTOR = 1000\n\n    def __init__(self, iterable=None, key=None):\n        assert key is None\n        self._len = 0\n        self._load = self.DEFAULT_LOAD_FACTOR\n        self._lists = []\n        self._maxes = []\n        self._index = []\n        self._offset = 0\n\n        if iterable is not None:\n            self._update(iterable)\n\n    def __new__(cls, iterable=None, key=None):\n        if key is None:\n            return object.__new__(cls)\n        else:\n            if cls is SortedList:\n                return object.__new__(SortedKeyList)\n            else:\n                raise TypeError('inherit SortedKeyList for key argument')\n\n    @property\n    def key(self):  # pylint: disable=useless-return\n        return None\n\n    def _reset(self, load):\n        values = reduce(iadd, self._lists, [])\n        self._clear()\n        self._load = load\n        self._update(values)\n\n    def clear(self):\n        self._len = 0\n        del self._lists[:]\n        del self._maxes[:]\n        del self._index[:]\n        self._offset = 0\n\n    _clear = clear\n\n    def add(self, value):\n        _lists = self._lists\n        _maxes = self._maxes\n\n        if _maxes:\n            pos = bisect_right(_maxes, value)\n\n            if pos == len(_maxes):\n                pos -= 1\n                _lists[pos].append(value)\n                _maxes[pos] = value\n            else:\n                insort(_lists[pos], value)\n\n            self._expand(pos)\n        else:\n            _lists.append([value])\n            _maxes.append(value)\n\n        self._len += 1\n\n    def _expand(self, pos):\n        _load = self._load\n        _lists = self._lists\n        _index = self._index\n\n        if len(_lists[pos]) > (_load << 1):\n            _maxes = self._maxes\n\n            _lists_pos = _lists[pos]\n            half = _lists_pos[_load:]\n            del _lists_pos[_load:]\n            _maxes[pos] = _lists_pos[-1]\n\n            _lists.insert(pos + 1, half)\n            _maxes.insert(pos + 1, half[-1])\n\n            del _index[:]\n        else:\n            if _index:\n                child = self._offset + pos\n                while child:\n                    _index[child] += 1\n                    child = (child - 1) >> 1\n                _index[0] += 1\n\n    def update(self, iterable):\n        _lists = self._lists\n        _maxes = self._maxes\n        values = sorted(iterable)\n\n        if _maxes:\n            if len(values) * 4 >= self._len:\n                _lists.append(values)\n                values = reduce(iadd, _lists, [])\n                values.sort()\n                self._clear()\n            else:\n                _add = self.add\n                for val in values:\n                    _add(val)\n                return\n\n        _load = self._load\n        _lists.extend(values[pos:(pos + _load)]\n                      for pos in range(0, len(values), _load))\n        _maxes.extend(sublist[-1] for sublist in _lists)\n        self._len = len(values)\n        del self._index[:]\n\n    _update = update\n\n    def __contains__(self, value):\n        _maxes = self._maxes\n\n        if not _maxes:\n            return False\n\n        pos = bisect_left(_maxes, value)\n\n        if pos == len(_maxes):\n            return False\n\n        _lists = self._lists\n        idx = bisect_left(_lists[pos], value)\n\n        return _lists[pos][idx] == value\n\n    def discard(self, value):\n        _maxes = self._maxes\n\n        if not _maxes:\n            return\n\n        pos = bisect_left(_maxes, value)\n\n        if pos == len(_maxes):\n            return\n\n        _lists = self._lists\n        idx = bisect_left(_lists[pos], value)\n\n        if _lists[pos][idx] == value:\n            self._delete(pos, idx)\n\n    def remove(self, value):\n        _maxes = self._maxes\n\n        if not _maxes:\n            raise ValueError('{0!r} not in list'.format(value))\n\n        pos = bisect_left(_maxes, value)\n\n        if pos == len(_maxes):\n            raise ValueError('{0!r} not in list'.format(value))\n\n        _lists = self._lists\n        idx = bisect_left(_lists[pos], value)\n\n        if _lists[pos][idx] == value:\n            self._delete(pos, idx)\n        else:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def _delete(self, pos, idx):\n        _lists = self._lists\n        _maxes = self._maxes\n        _index = self._index\n\n        _lists_pos = _lists[pos]\n\n        del _lists_pos[idx]\n        self._len -= 1\n\n        len_lists_pos = len(_lists_pos)\n\n        if len_lists_pos > (self._load >> 1):\n            _maxes[pos] = _lists_pos[-1]\n\n            if _index:\n                child = self._offset + pos\n                while child > 0:\n                    _index[child] -= 1\n                    child = (child - 1) >> 1\n                _index[0] -= 1\n        elif len(_lists) > 1:\n            if not pos:\n                pos += 1\n\n            prev = pos - 1\n            _lists[prev].extend(_lists[pos])\n            _maxes[prev] = _lists[prev][-1]\n\n            del _lists[pos]\n            del _maxes[pos]\n            del _index[:]\n\n            self._expand(prev)\n        elif len_lists_pos:\n            _maxes[pos] = _lists_pos[-1]\n        else:\n            del _lists[pos]\n            del _maxes[pos]\n            del _index[:]\n\n    def _loc(self, pos, idx):\n        if not pos:\n            return idx\n\n        _index = self._index\n\n        if not _index:\n            self._build_index()\n\n        total = 0\n\n        # Increment pos to point in the index to len(self._lists[pos]).\n\n        pos += self._offset\n\n        # Iterate until reaching the root of the index tree at pos = 0.\n\n        while pos:\n\n            # Right-child nodes are at odd indices. At such indices\n            # account the total below the left child node.\n\n            if not pos & 1:\n                total += _index[pos - 1]\n\n            # Advance pos to the parent node.\n\n            pos = (pos - 1) >> 1\n\n        return total + idx\n\n    def _pos(self, idx):\n        if idx < 0:\n            last_len = len(self._lists[-1])\n\n            if (-idx) <= last_len:\n                return len(self._lists) - 1, last_len + idx\n\n            idx += self._len\n\n            if idx < 0:\n                raise IndexError('list index out of range')\n        elif idx >= self._len:\n            raise IndexError('list index out of range')\n\n        if idx < len(self._lists[0]):\n            return 0, idx\n\n        _index = self._index\n\n        if not _index:\n            self._build_index()\n\n        pos = 0\n        child = 1\n        len_index = len(_index)\n\n        while child < len_index:\n            index_child = _index[child]\n\n            if idx < index_child:\n                pos = child\n            else:\n                idx -= index_child\n                pos = child + 1\n\n            child = (pos << 1) + 1\n\n        return (pos - self._offset, idx)\n\n    def _build_index(self):\n        row0 = list(map(len, self._lists))\n\n        if len(row0) == 1:\n            self._index[:] = row0\n            self._offset = 0\n            return\n\n        head = iter(row0)\n        tail = iter(head)\n        row1 = list(starmap(add, zip(head, tail)))\n\n        if len(row0) & 1:\n            row1.append(row0[-1])\n\n        if len(row1) == 1:\n            self._index[:] = row1 + row0\n            self._offset = 1\n            return\n\n        size = 2 ** (int(log(len(row1) - 1, 2)) + 1)\n        row1.extend(repeat(0, size - len(row1)))\n        tree = [row0, row1]\n\n        while len(tree[-1]) > 1:\n            head = iter(tree[-1])\n            tail = iter(head)\n            row = list(starmap(add, zip(head, tail)))\n            tree.append(row)\n\n        reduce(iadd, reversed(tree), self._index)\n        self._offset = size * 2 - 1\n\n    def __delitem__(self, index):\n        if isinstance(index, slice):\n            start, stop, step = index.indices(self._len)\n\n            if step == 1 and start < stop:\n                if start == 0 and stop == self._len:\n                    return self._clear()\n                elif self._len <= 8 * (stop - start):\n                    values = self._getitem(slice(None, start))\n                    if stop < self._len:\n                        values += self._getitem(slice(stop, None))\n                    self._clear()\n                    return self._update(values)\n\n            indices = range(start, stop, step)\n\n            # Delete items from greatest index to least so\n            # that the indices remain valid throughout iteration.\n\n            if step > 0:\n                indices = reversed(indices)\n\n            _pos, _delete = self._pos, self._delete\n\n            for index in indices:\n                pos, idx = _pos(index)\n                _delete(pos, idx)\n        else:\n            pos, idx = self._pos(index)\n            self._delete(pos, idx)\n\n    def __getitem__(self, index):\n        _lists = self._lists\n\n        if isinstance(index, slice):\n            start, stop, step = index.indices(self._len)\n\n            if step == 1 and start < stop:\n                # Whole slice optimization: start to stop slices the whole\n                # sorted list.\n\n                if start == 0 and stop == self._len:\n                    return reduce(iadd, self._lists, [])\n\n                start_pos, start_idx = self._pos(start)\n                start_list = _lists[start_pos]\n                stop_idx = start_idx + stop - start\n\n                # Small slice optimization: start index and stop index are\n                # within the start list.\n\n                if len(start_list) >= stop_idx:\n                    return start_list[start_idx:stop_idx]\n\n                if stop == self._len:\n                    stop_pos = len(_lists) - 1\n                    stop_idx = len(_lists[stop_pos])\n                else:\n                    stop_pos, stop_idx = self._pos(stop)\n\n                prefix = _lists[start_pos][start_idx:]\n                middle = _lists[(start_pos + 1):stop_pos]\n                result = reduce(iadd, middle, prefix)\n                result += _lists[stop_pos][:stop_idx]\n\n                return result\n\n            if step == -1 and start > stop:\n                result = self._getitem(slice(stop + 1, start + 1))\n                result.reverse()\n                return result\n\n            # Return a list because a negative step could\n            # reverse the order of the items and this could\n            # be the desired behavior.\n\n            indices = range(start, stop, step)\n            return list(self._getitem(index) for index in indices)\n        else:\n            if self._len:\n                if index == 0:\n                    return _lists[0][0]\n                elif index == -1:\n                    return _lists[-1][-1]\n            else:\n                raise IndexError('list index out of range')\n\n            if 0 <= index < len(_lists[0]):\n                return _lists[0][index]\n\n            len_last = len(_lists[-1])\n\n            if -len_last < index < 0:\n                return _lists[-1][len_last + index]\n\n            pos, idx = self._pos(index)\n            return _lists[pos][idx]\n\n    _getitem = __getitem__\n\n    def __setitem__(self, index, value):\n        message = 'use ``del sl[index]`` and ``sl.add(value)`` instead'\n        raise NotImplementedError(message)\n\n    def __iter__(self):\n        return chain.from_iterable(self._lists)\n\n    def __reversed__(self):\n        return chain.from_iterable(map(reversed, reversed(self._lists)))\n\n    def reverse(self):\n        raise NotImplementedError('use ``reversed(sl)`` instead')\n\n    def islice(self, start=None, stop=None, reverse=False):\n        _len = self._len\n\n        if not _len:\n            return iter(())\n\n        start, stop, _ = slice(start, stop).indices(self._len)\n\n        if start >= stop:\n            return iter(())\n\n        _pos = self._pos\n\n        min_pos, min_idx = _pos(start)\n\n        if stop == _len:\n            max_pos = len(self._lists) - 1\n            max_idx = len(self._lists[-1])\n        else:\n            max_pos, max_idx = _pos(stop)\n\n        return self._islice(min_pos, min_idx, max_pos, max_idx, reverse)\n\n    def _islice(self, min_pos, min_idx, max_pos, max_idx, reverse):\n        _lists = self._lists\n\n        if min_pos > max_pos:\n            return iter(())\n\n        if min_pos == max_pos:\n            if reverse:\n                indices = reversed(range(min_idx, max_idx))\n                return map(_lists[min_pos].__getitem__, indices)\n\n            indices = range(min_idx, max_idx)\n            return map(_lists[min_pos].__getitem__, indices)\n\n        next_pos = min_pos + 1\n\n        if next_pos == max_pos:\n            if reverse:\n                min_indices = range(min_idx, len(_lists[min_pos]))\n                max_indices = range(max_idx)\n                return chain(\n                    map(_lists[max_pos].__getitem__, reversed(max_indices)),\n                    map(_lists[min_pos].__getitem__, reversed(min_indices)),\n                )\n\n            min_indices = range(min_idx, len(_lists[min_pos]))\n            max_indices = range(max_idx)\n            return chain(\n                map(_lists[min_pos].__getitem__, min_indices),\n                map(_lists[max_pos].__getitem__, max_indices),\n            )\n\n        if reverse:\n            min_indices = range(min_idx, len(_lists[min_pos]))\n            sublist_indices = range(next_pos, max_pos)\n            sublists = map(_lists.__getitem__, reversed(sublist_indices))\n            max_indices = range(max_idx)\n            return chain(\n                map(_lists[max_pos].__getitem__, reversed(max_indices)),\n                chain.from_iterable(map(reversed, sublists)),\n                map(_lists[min_pos].__getitem__, reversed(min_indices)),\n            )\n\n        min_indices = range(min_idx, len(_lists[min_pos]))\n        sublist_indices = range(next_pos, max_pos)\n        sublists = map(_lists.__getitem__, sublist_indices)\n        max_indices = range(max_idx)\n        return chain(\n            map(_lists[min_pos].__getitem__, min_indices),\n            chain.from_iterable(sublists),\n            map(_lists[max_pos].__getitem__, max_indices),\n        )\n\n    def irange(self, minimum=None, maximum=None, inclusive=(True, True),\n               reverse=False):\n        _maxes = self._maxes\n\n        if not _maxes:\n            return iter(())\n\n        _lists = self._lists\n\n        # Calculate the minimum (pos, idx) pair. By default this location\n        # will be inclusive in our calculation.\n\n        if minimum is None:\n            min_pos = 0\n            min_idx = 0\n        else:\n            if inclusive[0]:\n                min_pos = bisect_left(_maxes, minimum)\n\n                if min_pos == len(_maxes):\n                    return iter(())\n\n                min_idx = bisect_left(_lists[min_pos], minimum)\n            else:\n                min_pos = bisect_right(_maxes, minimum)\n\n                if min_pos == len(_maxes):\n                    return iter(())\n\n                min_idx = bisect_right(_lists[min_pos], minimum)\n\n        # Calculate the maximum (pos, idx) pair. By default this location\n        # will be exclusive in our calculation.\n\n        if maximum is None:\n            max_pos = len(_maxes) - 1\n            max_idx = len(_lists[max_pos])\n        else:\n            if inclusive[1]:\n                max_pos = bisect_right(_maxes, maximum)\n\n                if max_pos == len(_maxes):\n                    max_pos -= 1\n                    max_idx = len(_lists[max_pos])\n                else:\n                    max_idx = bisect_right(_lists[max_pos], maximum)\n            else:\n                max_pos = bisect_left(_maxes, maximum)\n\n                if max_pos == len(_maxes):\n                    max_pos -= 1\n                    max_idx = len(_lists[max_pos])\n                else:\n                    max_idx = bisect_left(_lists[max_pos], maximum)\n\n        return self._islice(min_pos, min_idx, max_pos, max_idx, reverse)\n\n    def __len__(self):\n        return self._len\n\n    def bisect_left(self, value):\n        _maxes = self._maxes\n\n        if not _maxes:\n            return 0\n\n        pos = bisect_left(_maxes, value)\n\n        if pos == len(_maxes):\n            return self._len\n\n        idx = bisect_left(self._lists[pos], value)\n        return self._loc(pos, idx)\n\n    def bisect_right(self, value):\n        _maxes = self._maxes\n\n        if not _maxes:\n            return 0\n\n        pos = bisect_right(_maxes, value)\n\n        if pos == len(_maxes):\n            return self._len\n\n        idx = bisect_right(self._lists[pos], value)\n        return self._loc(pos, idx)\n\n    bisect = bisect_right\n    _bisect_right = bisect_right\n\n    def count(self, value):\n        _maxes = self._maxes\n\n        if not _maxes:\n            return 0\n\n        pos_left = bisect_left(_maxes, value)\n\n        if pos_left == len(_maxes):\n            return 0\n\n        _lists = self._lists\n        idx_left = bisect_left(_lists[pos_left], value)\n        pos_right = bisect_right(_maxes, value)\n\n        if pos_right == len(_maxes):\n            return self._len - self._loc(pos_left, idx_left)\n\n        idx_right = bisect_right(_lists[pos_right], value)\n\n        if pos_left == pos_right:\n            return idx_right - idx_left\n\n        right = self._loc(pos_right, idx_right)\n        left = self._loc(pos_left, idx_left)\n        return right - left\n\n    def copy(self):\n        return self.__class__(self)\n\n    __copy__ = copy\n\n    def append(self, value):\n        raise NotImplementedError('use ``sl.add(value)`` instead')\n\n    def extend(self, values):\n        raise NotImplementedError('use ``sl.update(values)`` instead')\n\n    def insert(self, index, value):\n        raise NotImplementedError('use ``sl.add(value)`` instead')\n\n    def pop(self, index=-1):\n        if not self._len:\n            raise IndexError('pop index out of range')\n\n        _lists = self._lists\n\n        if index == 0:\n            val = _lists[0][0]\n            self._delete(0, 0)\n            return val\n\n        if index == -1:\n            pos = len(_lists) - 1\n            loc = len(_lists[pos]) - 1\n            val = _lists[pos][loc]\n            self._delete(pos, loc)\n            return val\n\n        if 0 <= index < len(_lists[0]):\n            val = _lists[0][index]\n            self._delete(0, index)\n            return val\n\n        len_last = len(_lists[-1])\n\n        if -len_last < index < 0:\n            pos = len(_lists) - 1\n            loc = len_last + index\n            val = _lists[pos][loc]\n            self._delete(pos, loc)\n            return val\n\n        pos, idx = self._pos(index)\n        val = _lists[pos][idx]\n        self._delete(pos, idx)\n        return val\n\n    def index(self, value, start=None, stop=None):\n        _len = self._len\n\n        if not _len:\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        if start is None:\n            start = 0\n        if start < 0:\n            start += _len\n        if start < 0:\n            start = 0\n\n        if stop is None:\n            stop = _len\n        if stop < 0:\n            stop += _len\n        if stop > _len:\n            stop = _len\n\n        if stop <= start:\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        _maxes = self._maxes\n        pos_left = bisect_left(_maxes, value)\n\n        if pos_left == len(_maxes):\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        _lists = self._lists\n        idx_left = bisect_left(_lists[pos_left], value)\n\n        if _lists[pos_left][idx_left] != value:\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        stop -= 1\n        left = self._loc(pos_left, idx_left)\n\n        if start <= left:\n            if left <= stop:\n                return left\n        else:\n            right = self._bisect_right(value) - 1\n\n            if start <= right:\n                return start\n\n        raise ValueError('{0!r} is not in list'.format(value))\n\n    def __add__(self, other):\n        values = reduce(iadd, self._lists, [])\n        values.extend(other)\n        return self.__class__(values)\n\n    __radd__ = __add__\n\n    def __iadd__(self, other):\n        self._update(other)\n        return self\n\n    def __mul__(self, num):\n        values = reduce(iadd, self._lists, []) * num\n        return self.__class__(values)\n\n    __rmul__ = __mul__\n\n    def __imul__(self, num):\n        values = reduce(iadd, self._lists, []) * num\n        self._clear()\n        self._update(values)\n        return self\n\n    def __make_cmp(seq_op, symbol, doc):\n        \"Make comparator method.\"\n\n        def comparer(self, other):\n            \"Compare method for sorted list and sequence.\"\n            if not isinstance(other, Sequence):\n                return NotImplemented\n\n            self_len = self._len\n            len_other = len(other)\n\n            if self_len != len_other:\n                if seq_op is eq:\n                    return False\n                if seq_op is ne:\n                    return True\n\n            for alpha, beta in zip(self, other):\n                if alpha != beta:\n                    return seq_op(alpha, beta)\n\n            return seq_op(self_len, len_other)\n\n        seq_op_name = seq_op.__name__\n        comparer.__name__ = '__{0}__'.format(seq_op_name)\n        doc_str = \"\"\"Return true if and only if sorted list is {0} `other`.\n        ``sl.__{1}__(other)`` <==> ``sl {2} other``\n        Comparisons use lexicographical order as with sequences.\n        Runtime complexity: `O(n)`\n        :param other: `other` sequence\n        :return: true if sorted list is {0} `other`\n        \"\"\"\n        comparer.__doc__ = dedent(doc_str.format(doc, seq_op_name, symbol))\n        return comparer\n\n    __eq__ = __make_cmp(eq, '==', 'equal to')\n    __ne__ = __make_cmp(ne, '!=', 'not equal to')\n    __lt__ = __make_cmp(lt, '<', 'less than')\n    __gt__ = __make_cmp(gt, '>', 'greater than')\n    __le__ = __make_cmp(le, '<=', 'less than or equal to')\n    __ge__ = __make_cmp(ge, '>=', 'greater than or equal to')\n    __make_cmp = staticmethod(__make_cmp)\n\n    def __reduce__(self):\n        values = reduce(iadd, self._lists, [])\n        return (type(self), (values,))\n\n    @recursive_repr()\n    def __repr__(self):\n        return '{0}({1!r})'.format(type(self).__name__, list(self))\n\n    def _check(self):\n        try:\n            assert self._load >= 4\n            assert len(self._maxes) == len(self._lists)\n            assert self._len == sum(len(sublist) for sublist in self._lists)\n\n            # Check all sublists are sorted.\n\n            for sublist in self._lists:\n                for pos in range(1, len(sublist)):\n                    assert sublist[pos - 1] <= sublist[pos]\n\n            # Check beginning/end of sublists are sorted.\n\n            for pos in range(1, len(self._lists)):\n                assert self._lists[pos - 1][-1] <= self._lists[pos][0]\n\n            # Check _maxes index is the last value of each sublist.\n\n            for pos in range(len(self._maxes)):\n                assert self._maxes[pos] == self._lists[pos][-1]\n\n            # Check sublist lengths are less than double load-factor.\n\n            double = self._load << 1\n            assert all(len(sublist) <= double for sublist in self._lists)\n\n            # Check sublist lengths are greater than half load-factor for all\n            # but the last sublist.\n\n            half = self._load >> 1\n            for pos in range(0, len(self._lists) - 1):\n                assert len(self._lists[pos]) >= half\n\n            if self._index:\n                assert self._len == self._index[0]\n                assert len(self._index) == self._offset + len(self._lists)\n\n                # Check index leaf nodes equal length of sublists.\n\n                for pos in range(len(self._lists)):\n                    leaf = self._index[self._offset + pos]\n                    assert leaf == len(self._lists[pos])\n\n                # Check index branch nodes are the sum of their children.\n\n                for pos in range(self._offset):\n                    child = (pos << 1) + 1\n                    if child >= len(self._index):\n                        assert self._index[pos] == 0\n                    elif child + 1 == len(self._index):\n                        assert self._index[pos] == self._index[child]\n                    else:\n                        child_sum = self._index[child] + self._index[child + 1]\n                        assert child_sum == self._index[pos]\n        except:\n            traceback.print_exc(file=sys.stdout)\n            print('len', self._len)\n            print('load', self._load)\n            print('offset', self._offset)\n            print('len_index', len(self._index))\n            print('index', self._index)\n            print('len_maxes', len(self._maxes))\n            print('maxes', self._maxes)\n            print('len_lists', len(self._lists))\n            print('lists', self._lists)\n            raise\n\n\ndef identity(value):\n    \"Identity function.\"\n    return value\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\ninp = lambda dtype: [dtype(x) for x in input().split()]\ninp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]\ninp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]\ninp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]\ninp_enus = lambda dtype, n: [[i] + inp(dtype) for i in range(n)]\nceil1 = lambda a, b: (a + b - 1) // b\n\n\nclass graph:\n    def __init__(self, n):\n        self.n, self.gdict = n, [[] for _ in range(n + 1)]\n        self.indeg = [0] * (n + 1)\n\n    def addEdge(self, node1, node2, w=None):\n        self.gdict[node1].append(node2)\n        self.indeg[node2] += 1\n\n    def kahn(self, n):\n        # enqueue all node with 0 in degree\n        queue, ans, lst = SortedList([i for i in range(1, n + 1) if not self.indeg[i]]), 1, -1\n        cnt = 0\n\n        while len(queue):\n            # pop and push into topsort\n            ix = queue.bisect_right(lst)\n\n            if ix == len(queue):\n                ix = 0\n                ans += 1\n\n            lst = s = queue.pop(ix)\n\n            for i in self.gdict[s]:\n                self.indeg[i] -= 1\n                if not self.indeg[i]:\n                    queue.add(i)\n\n            cnt += 1\n        # check cycle\n        print(-1 if cnt != n else ans)\n\n\nfor _ in range(int(input())):\n    n = int(input())\n    g = graph(n)\n\n    for i in range(n):\n        for x in inp(int)[1:]:\n            g.addEdge(x, i + 1)\n    g.kahn(n)\n\n\n\n"
        },
        {
            "language": 3,
            "solution": "def var():\n    return (map(int,input().split()))\ndef a():\n    return list((map(int,input().split())))\ndef inp():\n    return int(input())\n\nimport math\nimport copy\nfrom collections import defaultdict,deque\nimport heapq\nimport sys\n# input = sys.stdin.readline\nsys.setrecursionlimit(10**5)\nmod = 10**9+7\ninput = sys.stdin.buffer.readline\n\nt=inp()\nfor _ in range(t):\n    n=inp()\n    adj={}\n    radj={}\n    indeg=[0]*(n+1)\n    arr=[]\n    qu=deque()\n    for i in range(1,n+1):\n        arr=a()\n        radj[i]=set(list(arr[1:]))\n        indeg[i]=len(radj[i])\n        if indeg[i]==0:\n            qu.append(i)\n        for el in arr[1:]:\n            if el not in adj:\n                adj[el]=set()\n            adj[el].add(i)\n    \n    top=[]\n    while qu:\n        u=qu.popleft()\n        top.append(u)\n        if u not in adj:continue\n        for v in adj[u]:\n            indeg[v]-=1\n            if indeg[v]==0:\n                qu.append(v)\n    \n    if len(top)!=n:\n        print(-1)\n        continue\n    \n    ans=1\n    dp=[1]*(n+1)\n    for ch in top:\n        if ch not in radj:continue\n        for prech in radj[ch]:\n            dp[ch]=max(dp[ch],dp[prech]+int(ch<prech))\n        ans=max(dp[ch],ans)\n    print(ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC target(\"popcnt\")\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\"\nusing namespace std;\ntemplate <typename T, typename K>\ninline bool smax(T &x, const K &y) {\n  return x < y ? x = y, true : false;\n}\ntemplate <typename T, typename K>\ninline bool smin(T &x, const K &y) {\n  return x > y ? x = y, true : false;\n}\nconst int mod = 1e9 + 7;\nint add(int x, int y) {\n  int z = x + y;\n  if (z >= mod) {\n    z -= mod;\n  }\n  return z;\n}\nint sub(int x, int y) {\n  int z = x - y;\n  if (z < 0) {\n    z += mod;\n  }\n  return z;\n}\nint mul(int x, int y) {\n  long long z = 1ll * x * y;\n  if (z >= mod) {\n    z %= mod;\n  }\n  return z;\n}\nint binpow(int a, long long p) {\n  int r = 1;\n  while (p) {\n    if (p & 1) r = mul(r, a);\n    a = mul(a, a), p >>= 1;\n  }\n  return r;\n}\nvector<vector<int>> g;\nvector<int> in;\nset<int> alive;\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    g = vector<vector<int>>(n + 1);\n    in = vector<int>(n + 1);\n    for (int i = 1; i <= n; ++i) {\n      int k;\n      cin >> k;\n      for (int j = 1; j <= k; ++j) {\n        int x;\n        cin >> x;\n        g[x].push_back(i);\n        in[i] += 1;\n      }\n    }\n    alive.clear();\n    int done = 0, cnt = 0;\n    for (int i = 1; i <= n; ++i) {\n      if (in[i] == 0) {\n        alive.insert(i);\n      }\n    }\n    while (done != n) {\n      if (alive.empty()) {\n        cnt = 1e9;\n        break;\n      }\n      ++cnt;\n      int chapter = 0;\n      auto it = alive.begin();\n      while (!alive.empty() &&\n             (it = alive.lower_bound(chapter)) != alive.end() &&\n             *it > chapter) {\n        int cur = *it;\n        alive.erase(it);\n        ++done;\n        for (auto v : g[cur]) {\n          in[v] -= 1;\n          if (in[v] == 0) {\n            alive.insert(v);\n          }\n        }\n        chapter = cur;\n      }\n    }\n    cout << (cnt < 1e9 ? cnt : -1) << endl;\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "# for i in range(int(input())):\n#     n = int(input())\n#     c1 = n//3\n#     c2 = c1\n#     if n % 3 == 1:\n#         c1 += 1\n#     elif n % 3 == 2:\n#         c2 += 1\n#     print(c1, c2)\n\n# t = int(input())\n# for x in range(t):\n#     arr = list(input())\n#     cnt = [0] * 26\n#     for i in arr:\n#         cnt[ord(i) - 97] += 1\n#     cnt1 = cnt2 = 0\n#     for i in cnt:\n#         if i > 1:\n#             cnt2 += 1\n#         elif i == 1:\n#             cnt1 += 1\n#     print(cnt2 + cnt1//2)\n\n# def solve():\n#     n, k = map(int, input().split())\n#     cnt = [0] * (n+1)\n#     a = []\n#     for i, x in enumerate(map(int, input().split())):\n#         if cnt[x] < k:\n#             a.append((x, i))\n#         cnt[x] += 1\n#     a.sort()\n#     cc = 0\n\n#     color = [0] * n\n#     m = len(a) - len(a) % k\n#     for x, i in a[:m]:\n#         color[i] = cc + 1\n#         cc = (cc + 1) % k\n#     print(*color)\n\n# t = int(input())\n# for _ in range(t): solve()  \n\n# def solve():\n#     n, k = map(int, input().split())\n#     cnt = [0] * (n + 1)\n#     arr = []\n#     for i, x in enumerate(map(int, input().split())):\n#         if cnt[x] < k:\n#             arr.append((x, i))\n#         cnt[x] += 1\n#     arr.sort()\n#     # print(arr)\n#     color = [0] * n\n#     cc = 0\n#     m = len(arr) - len(arr) % k\n#     for x, i in arr[:m]:\n#         color[i] = cc + 1\n#         cc = (cc  + 1)%k\n#     print(*color)\n\n# t = int(input())\n# for _ in range(t): solve()\n\n# N = 3\n# X = 2\n# A = [2, 3, 4]\n# def solve(A, N, X):\n#     arr = []\n#     for i in range(len(A)):\n#         if A[i] & 1: arr.append(i)\n#     ans = 0\n#     m = len(arr)\n#     for i in range(1, m - 1):\n#         ans1 = ans2 = -1\n#         low, high = 0, i - 1\n#         b =arr[i] - X\n#         while low <= high:\n#             mid = low + high >> 1\n#             if arr[mid] <= b:\n#                 ans1 = mid\n#                 low = mid + 1\n#             else:\n#                 high = mid - 1\n#         low = i + 1\n#         r = m - 1\n#         b = arr[i] + X\n#         while l <= r:\n#             mid = l + r >> 1\n#             if arr[mid] >= b:\n#                 ans2 = mid\n#                 r = mid - 1\n#             else:\n#                 l = mid + 1\n#         if ans1 != -1 and ans2 != -1:\n#             ans += (ans1 + 1)*(m - ans2)\n#     return ans\n# 738 Div 2\n# A - \n# def solve():\n# \tn = int(input())\n# \tarr = list(map(int, input().split()))\n# \tres = arr[0]\n# \tfor i in range(len(arr)):\n# \t\tres= res & arr[i]\n# \treturn res\n# t = int(input())\n# while t:\n# \tprint(solve())\n# \tt -= 1\n\n# B - \n\n\n\n# def solve():\n# \tn = int(input())\n# \ts = input()\n# \tarr = list(s)\n# \tres = ''\n# \tl = 0\n# \tfor l in range(len(arr)):\n# \t\tif arr[l] != '?':\n# \t\t\tbreak\n# \tfor i in range(l, len(arr)):\n# \t\tif arr[i] == '?':\n# \t\t\tif arr[i - 1] == 'R': arr[i] = 'B'\n# \t\t\telse: arr[i] = 'R'\n\n# \tif arr[l] == 'R':\n# \t\tif not l & 1:\n# \t\t\tarr[0] = 'R'\n# \t\telse: arr[0] = 'B'\n\n# \tif arr[l] == 'B':\n# \t\tif not l & 1:\n# \t\t\tarr[0] = 'B'\n# \t\telse: arr[0] = 'R'\n# \tfor i in range(1, l):\n# \t\tif arr[i - 1] == 'R': arr[i] = 'B'\n# \t\telse: arr[i] = 'R'\n# \tfor i in range(len(arr)):\n# \t\tres += arr[i]\n# \treturn(res)\n\n# t = int(input())\n# while t:\n# \tprint(solve())\n# \tt -= 1\n\n\n# C---\n\n\n\n# 739Div3\n\n# 1 -\n# def solve():\n# \tn = int(input())\n# \tdp = []\n# \tfor i in range(1667):\n# \t\tif str(i)[-1] != '3' and i % 3:\n# \t\t\tdp.append(i)\n# \treturn dp[n - 1]\n\n\n# 2-\n\n# def solve():\n# \ta,b,c = map(int, input().split())\n# \tn = 2 * abs(a - b)\n# \tif a > n or b > n or c > n: return -1\n# \telse:\n# \t\td = n//2 + c\n# \t\twhile d > n: d -= n\n# \treturn d\n\n\n# 4-\n# power = [str(2 ** i) for i in range(64)]\n\n# def solve():\n# \tdef fn(x, s):\n# \t\tit = c = 0\n# \t\tfor i in x:\n# \t\t\tif i == s[it]:\n# \t\t\t\tit += 1\n# \t\t\t\tc += 1\n# \t\t\t\tif it == len(s):\n# \t\t\t\t\tbreak\n# \t\treturn len(x) - c + len(s) - c\n# \tn = input()\n# \tans = 100\n# \tfor i in power:\n# \t\tans = min(ans, fn(n, i))\n# \treturn ans\n# t = int(input()\t)\n# while t:\n# \tprint(solve())\n# \tt -= 1\n\n# 5-:\n# from collections import Counter\n# def solve(s, n):\n# \ttemp = s[:]\n# \ts = s[::-1]\n# \torder = ''\n# \tcnt = Counter()\n# \tfor c in s:\n# \t\tif c not in cnt:\n# \t\t\torder += c\n# \t\tcnt[c] += 1\n# \tm = len(order)\n# \ttrue_l = 0\n# \tfor i in range(m):\n# \t\ttrue_l += cnt[order[i]]//(m - i)\n# \torder = order[::-1]\n# \treturn (temp[:true_l], order)\n\n# def order_find(strs, order):\n# \tres = strs[:]\n# \tfor c in order:\n# \t\ttemp = ''\n# \t\tfor d in strs:\n# \t\t\tif d != c:\n# \t\t\t\ttemp += d\n# \t\t\t\tres += d\n# \t\tstrs = temp[:]\n# \treturn res\n\n# for _ in range(int(input())):\n# \ts = input()\n# \tn = len(s)\n# \tori, order = solve(s, n)\n# \tcheck = order_find(ori, order)\n# \tif s == check:\n# \t\tprint(ori, order)\n# \telse: print(-1)\n\n\n\n\n# def solve():\n# \tdef possible(k):\n# \t\tlast = arr[0]\n# \t\tn = len(arr)\n# \t\tcow = 1\n# \t\tfor i in range(1, n):\n# \t\t\tif arr[i] - last >= k:\n# \t\t\t\tlast = arr[i]\n# \t\t\t\tcow += 1\n# \t\t\t\tif cow == c:\n# \t\t\t\t\treturn True\n# \t\treturn False\n\n# \tn, c = map(int, input().split())\n# \tarr = []\n# \tfor _ in range(n):\n# \t\tarr.append(int(input()))\n# \tarr.sort()\n# \tlow, high = 0, int(1e5)\n# \tans = 0\n# \twhile low <= high:\n# \t\tmid = low + high >> 1\n# \t\tif possible(mid):\n# \t\t\tlow = mid + 1\n# \t\t\tans = mid\n# \t\telse: high = mid - 1\n# \treturn ans\n\n\n# t = int(input()\t)\n# while t:\n# \tprint(solve())\n# \tt -= 1\n\n# cook\n# import math\n# def solve():\n# \tn = int(input())\n# \tans = 0\n# \tarr = list(map(int, input().split()))\n# \tcnt = Counter(arr)\n# \tfor k in cnt.keys():\n# \t\tans += min(k - 1, cnt[k])\n# \treturn ans\n\n\n# t = int(input())\n# while t:\n# \tprint(solve())\n# \tt -= 1\n\n# cook\n\n\n# def solve():\n# \tn = int(input())\n# \tarr = list(map(int, input().split()))\n# \tcnt = Counter(arr)\n# \tmaxv = max(cnt, key = lambda x: cnt[x])\n# \tif maxv == 1: return n - 2\n# \treturn n - maxv\n\n# t = int(input())\n# while t:\n# \tprint(solve())\n# \tt -= 1\n\n\n# def solve():\n# \tn = int(input())\n# \tarr = list(map(int, input().split()))\n# \tans = [0] * len(arr)\n# \tfor i, j in zip(arr, sorted(arr)):\n# \t\tif j % i != 0:\n# \t\t\tans.append((j + abs(i - j)))\n# \t\t\tj += abs(i - j)\n# \t\telse: ans.append(j)\n# \treturn ans\n\n\n# t = int(input())\n# while t:\n# \tprint(solve())\n# \tt -= 1\n\n# def solve():\n# \tn = int(input())\n# \tk = list(map(int, input().split()))\n# \tm = sorted(k)\n# \tc = cnt = 0\n# \twhile (k != m):\n# \t\tfor j in range(c % 2, len(k) - 1, 2):\n# \t\t\tif (k[j] > k[j + 1]):\n# \t\t\t\tk[j], k[j + 1] = k[j + 1], k[j]\n# \t\tc += 1\n# \treturn (c)\n\n# t = int(input())\n# while t:\n# \tprint(solve())\n# \tt -= 1\n\n\n\n# 742 Div 2\n\n# for _ in range(int(input())):\n#     n=int(input())\n#     s=input()\n#     ans=[]\n#     for i in range(n):\n#         if s[i]==\"L\" or s[i]==\"R\":\n#             ans.append(s[i])\n#         elif s[i]==\"U\":\n#             ans.append(\"D\")\n#         else:\n#             ans.append(\"U\")\n#     print(\"\".join(ans))\n\n\n# lunch\n\n# def solve():\n#     arr = list(map(int, input().split()))\n#     A, B = arr[0], arr[1]\n#     if (arr[2] == A or arr[2] == B) and (arr[3] == B or arr[3] == A):\n#         print('1')\n#     elif (arr[4] == A or arr[4] == B) and (arr[5] == B or arr[5] == A):\n#         print('2')\n#     else: print('0')\n\n# def solve():\n#     n = int(input())\n#     s = (n * (n + 1))//2\n#     if not s & 1: print(n)\n#     else: print(n - 1)\n\n\n\n# def solve():\n#     n, k = map(int, input().split())\n#     arr = list(map(int, input().split()))\n#     maxi = max(arr)\n#     ans = 0\n#     for i in range(k - 1, len(arr)):\n#         if maxi == arr[i]:\n#             ans += n - i\n#     return ans\n# from collections import defaultdict\n# def solve():\n#     n = int(input())\n#     arr = list(map(int, input().split()))[:n]\n#     for i in range(n):\n#         arr[i] = arr[i] - i\n#     if len(set(arr)) == 1:\n#         print(n)\n#     else: print(1)\n\n\n\n# t = int(input())\n# while t:\n#     print(solve())\n#     t -= 1\n\n# starter 2-3\n\n# def solve():\n#     arr = list(map(int, input().split()))\n#     mini = min(arr)\n#     if mini = arr[1]: print('Bob')\n#     elif mini == arr[2]: print('Alice')\n#     else: print('Draw')\n\n\n# def solve():\n#     n, k, s = map(int, input().split())\n#     sumod = n*n\n#     rem = int(s - sumod)//k - 1\n#     print(rem)\n\n\n# def solve():\n#     n, k = map(int, input().split())\n#     arr = list(map(int, input().split()))\n#     arr.sort()\n#     for v in arr:\n#         if v > 0:\n#             s += v\n#     for i in range(k):\n#         if arr[i] < 0:\n#             s -= arr[i]\n#     return s\n\n\n# def solve():\n#     n = int(input())\n#     arr = list(map(int, input().split()))\n#     arr1 = list(map(int, input().split()))\n#     arr\n#     arr.sort()\n#     arr1.sort()\n#     mapp = defaultdict(int)\n#     for i in range(n - 1):\n#         d1 = arr1[i] - arr[i]\n#         d2 = arr1[i] - arr[i + 1]\n#         if d1 != d2:\n#             if d1 > 0:\n#                 mapp[d1] += 1\n#             if d2 > 0:\n#                 mapp[d2] += 1\n#         else:\n#             if d1 > 0:\n#                 mapp[d1] += 1\n#     # print(mapp)\n#     mini = float(\"inf\")\n#     for i in mapp.keys():\n#         if mapp[i] == n - 1:\n#             mini = min(mini, i)\n#     return mini\n\n# def solve():\n#     n = int(input())\n#     a = list(map(int, input().split()))\n#     b = list(map(int, input().split()))\n#     state = [-1] * n\n#     bit = 1 << 29\n#     while bit > 0:\n#         poss = True\n#         for i in range(n):\n#             if state[i] == 0 and not (a[i] & bit):\n#                 poss = False\n#             elif state[i] == 1 and not (b[i] & bit):\n#                 poss = False\n#             elif not (a[i] & bit) and not (b[i] & bit):\n#                 poss = False\n#         if not poss:\n#             bit >>= 1\n#             continue\n#         for i in range(n):\n#             if state[i] != -1: continue\n#             if not (a[i] & bit): state[i] = 1\n#             elif not(b[i] & bit): state[i] = 0\n#         bit >>= 1\n#     ans = (1 << 30) - 1\n#     flip = 0\n#     for i in range(n):\n#         if state[i] == 1:\n#             flip += 1\n#             ans &= b[i]\n#         else: ans &= a[i]\n#     print(str(ans) + ' ' + str(flip))\n\n# 743 Div2\n# def solve():\n#     n = int(input())\n#     s = list(input())\n#     s.reverse()\n#     r = 0\n#     for i in range(n):\n#         if i == 0:\n#             if int(s[i]) == 0:\n#                 pass\n#             else:\n#                 r += int(s[i])\n#         else:\n#             if int(s[i]) == 0:\n#                 pass\n#             else:\n#                 r += 1\n#                 r += int(s[i])\n#     return r\n\n# def solve():\n#     n = int(input())\n#     a = list(map(int, input().split()))\n#     b = list(map(int, input().split()))\n#     a = sorted([(a[i], i) for i in range(n)])\n#     b = sorted([(b[i], i) for i in range(n)])\n#     ans = mini = float(\"inf\")\n#     rs = []\n#     for i in range(n):\n#         mini = min(mini, a[i][1])\n#         ans = min(ans, mini + b[i][1])\n#     rs.append(ans)\n#     return rs[0]\n\nfrom collections import defaultdict, deque\ndef solve():\n    def topo(graph, indegree, n):\n        c = 0\n        queue = deque([])\n        ans = defaultdict(lambda : 1)\n        for i in range(n):\n            if indegree[i + 1] == 0:\n                queue.append(i + 1)\n        while queue:\n            node = queue.popleft()\n            c += 1\n            for v in graph[node]:\n                indegree[v] -= 1\n                if v < node:\n                    ans[v] = max(ans[v], ans[node] + 1)\n                else:\n                    ans[v] = max(ans[v], ans[node])\n                if indegree[v] == 0:\n                    queue.append(v)\n        if c != n:\n            return False\n        if ans:\n            return max(ans.values())\n        return 1\n\n\n\n\n    n = int(input())\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n    for i in range(n):\n        arr = list(map(int, input().split()))\n        # print(arr)\n        for j in range(1, arr[0] + 1):\n            indegree[i + 1] += 1\n            graph[arr[j]].append(i + 1)\n    # print(graph, indegree)\n    res = topo(graph, indegree, n)\n    if res == False:\n        return -1\n    return res\nt = int(input())\nwhile t:\n    print(solve())\n    t -= 1"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict as dd, deque\nimport sys\ninput = sys.stdin.readline\n\ndef check_cycle(g, indegree, n):\n    c = 0\n    d = deque([])\n    ans = dd(lambda :1)\n    for i in range(n):\n        if indegree[i + 1] == 0:\n            d.append(i + 1)\n    #print(d)\n    while d:\n        u = d.popleft()\n        c += 1\n        for v in g[u]:\n            indegree[v] -= 1\n            if v < u:\n                ans[v] = max(ans[v], ans[u] + 1)\n            else:\n                ans[v] = max(ans[v], ans[u])\n            if indegree[v] == 0:\n                d.append(v)\n    if c != n:\n        return False\n    if ans:\n        return max(ans.values())\n    return 1\n\n\nfor _ in range(int(input())):\n    n = int(input())\n    g = dd(set)\n    indegree = dd(int)\n    for i in range(n):\n        a = list(map(int, input().split()))\n        for j in range(1, a[0] + 1):\n            indegree[i + 1] += 1\n            g[a[j]].add(i + 1)\n    res = check_cycle(g, indegree, n)\n    if res == False:\n        print(-1)\n    else:\n        print(res)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long modInverse(long long a, long long b) {\n  return 1 < a ? b - modInverse(b % a, a) * b / a : 1;\n}\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nlong long lcm(long long a, long long b) { return (a * b) / gcd(a, b); }\nvoid solve() {\n  long long n;\n  cin >> n;\n  vector<long long> g[n];\n  priority_queue<long long> left, right;\n  long long cnt[n];\n  memset(cnt, 0, sizeof cnt);\n  for (int k = 0; k < n; k++) {\n    long long m;\n    cin >> m;\n    for (int i = 0; i < m; i++) {\n      long long x;\n      cin >> x;\n      x--;\n      g[x].push_back(k);\n    }\n    cnt[k] = m;\n    if (m == 0) {\n      left.push(k);\n    }\n  }\n  if (left.empty()) {\n    cout << \"-1\\n\";\n    return;\n  }\n  long long ans = 0;\n  while (1) {\n    if (right.empty()) {\n      if (left.empty()) break;\n      while (!left.empty()) {\n        long long x = left.top();\n        left.pop();\n        right.push(-x);\n      }\n      ans++;\n    }\n    long long me = -right.top();\n    right.pop();\n    for (long long u : g[me]) {\n      if (cnt[u] == 0) {\n        cout << \"-1\\n\";\n        return;\n      }\n      cnt[u]--;\n      if (cnt[u] == 0) {\n        if (u > me)\n          right.push(-u);\n        else\n          left.push(u);\n      }\n    }\n  }\n  for (int k = 0; k < n; k++) {\n    if (cnt[k] > 0) {\n      cout << \"-1\\n\";\n      return;\n    }\n  }\n  cout << ans << \"\\n\";\n}\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  ;\n  ;\n  long long t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class C {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        PrintWriter writer = new PrintWriter(System.out);\n        \n        int t = scanner.nextInt();\n        for (int i = 0; i < t; i++) {\n            try {\n                new SolC(scanner, writer).solve();\n            } catch (Exception e) {\n                writer.println(-1);\n            }\n        }\n        \n        writer.close();\n    }\n}\n\nclass SolC extends Input {\n\n    boolean visited[];\n    boolean computed[];\n    Integer passes[];\n\n    public SolC(Scanner scanner, PrintWriter writer) {\n        super(scanner, writer);\n        passes = new Integer[n];\n        visited = new boolean[n];\n        computed = new boolean[n];\n    }\n\n    void solve() {\n        for (int i = 0; i < n; i++)\n            dfs(i);\n        writer.println(Collections.max(Arrays.asList(passes)));\n    }\n\n    void dfs(int u) {\n        if (visited[u]) {\n            if (!computed[u])\n                throw new RuntimeException();\n            return;\n        }\n        visited[u] = true;\n\n        int[] ed = e.get(u);\n        passes[u] = 1;\n        \n        for (int i = 0; i < ed.length; i++) {\n            int v = ed[i];\n            dfs(v);\n            \n            if (v > u)\n                passes[u] = Integer.max(passes[u], passes[v]+1);\n            else\n                passes[u] = Integer.max(passes[u], passes[v]);\n        }\n        computed[u] = true;\n    }\n}\n\nclass Input {\n\n    Scanner scanner;\n    PrintWriter writer;\n\n    int n;\n    List<int[]> e;\n\n    public Input(Scanner scanner, PrintWriter writer) {\n        this.scanner = scanner;\n        this.writer = writer;\n\n        n = scanner.nextInt();\n        e = new ArrayList<>();\n\n        for (int i = 0; i < n; i++) {\n            int k = scanner.nextInt();\n            int edge[] = new int[k];\n            \n            for (int j = 0; j < k; j++)\n                edge[j] = scanner.nextInt()-1;\n            e.add(edge);\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1e9 + 8;\nmt19937_64 rang(\n    chrono::high_resolution_clock::now().time_since_epoch().count());\nint rng(int lim) {\n  uniform_int_distribution<int> uid(0, lim - 1);\n  return uid(rang);\n}\nlong long mod = 1e9 + 7;\nvoid binarySearch(long long arr[], long long l, long long r, long long x) {\n  while (l <= r) {\n    long long m = l + (r - l) / 2;\n    if (arr[m] == x) {\n      arr[m] = -1;\n      return;\n    }\n    if (arr[m] < x)\n      l = m + 1;\n    else\n      r = m - 1;\n  }\n}\nint tree[100001];\nvoid buildTree(int *a, int *tree, int start, int end, int treeNode) {\n  if (start == end) {\n    tree[treeNode] = a[start];\n    return;\n  }\n  int mid = (start + end) / 2;\n  buildTree(a, tree, start, mid, 2 * treeNode);\n  buildTree(a, tree, mid + 1, end, 2 * treeNode + 1);\n  tree[treeNode] = tree[2 * treeNode] + tree[2 * treeNode + 1];\n}\nvoid updateTree(int *a, int *tree, int start, int end, int treeNode, int idx,\n                int val) {\n  if (start == end) {\n    tree[treeNode] = val;\n    a[start] = val;\n    return;\n  }\n  int mid = (start + end) / 2;\n  if (idx > mid) {\n    updateTree(a, tree, mid + 1, end, 2 * treeNode + 1, idx, val);\n  } else {\n    updateTree(a, tree, start, mid, 2 * treeNode, idx, val);\n  }\n  tree[treeNode] = tree[2 * treeNode] + tree[2 * treeNode + 1];\n}\nint lcs(string s1, string s2) {\n  int m = s1.length(), n = s2.length();\n  int dp[m + 1][n + 1];\n  for (int i = 0; i <= m; i++) dp[i][0] = 0;\n  for (int j = 0; j <= n; j++) dp[0][j] = 0;\n  for (int i = 1; i <= m; i++) {\n    for (int j = 1; j <= n; j++) {\n      if (s1[i - 1] == s2[j - 1])\n        dp[i][j] = 1 + dp[i - 1][j - 1];\n      else\n        dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n    }\n  }\n  return dp[m][n];\n}\nint leftIndex(int tail[], int l, int r, int x) {\n  while (r > l) {\n    int m = l + (r - l) / 2;\n    if (tail[m] >= x)\n      r = m;\n    else\n      l = m + 1;\n  }\n  return r;\n}\nint longestSubsequence(int n, int a[]) {\n  int len = 1;\n  int tail[n];\n  tail[0] = a[0];\n  int i;\n  for (i = 1; i < n; i++) {\n    if (a[i] > tail[len - 1]) {\n      tail[len] = a[i];\n      len++;\n    } else {\n      int c = leftIndex(tail, 0, len - 1, a[i]);\n      tail[c] = a[i];\n    }\n  }\n  return len;\n}\nint query(int *a, int *tree, int start, int end, int treeNode, int left,\n          int right) {\n  if (start > right || end < left) {\n    return 0;\n  }\n  if (start >= left && end <= right) {\n    return tree[treeNode];\n  }\n  int mid = (start + end) / 2;\n  int ans1 = query(a, tree, start, mid, 2 * treeNode, left, right);\n  int ans2 = query(a, tree, mid + 1, end, 2 * treeNode + 1, left, right);\n  return ans1 + ans2;\n}\nvoid Dfs(vector<int> adj[], int src, vector<bool> &visited) {\n  visited[src] = true;\n  cout << src << \" \";\n  for (auto itr : adj[src]) {\n    if (visited[itr] == false) {\n      Dfs(adj, itr, visited);\n    }\n  }\n  return;\n}\nlong long binpow(long long a, long long b) {\n  long long ans = 1;\n  a %= mod;\n  while (b) {\n    if (b & 1) ans = (ans * a);\n    b /= 2;\n    a = (a * a);\n    ans %= mod;\n    a %= mod;\n  }\n  return ans;\n}\nvector<bool> prime(10000003LL, true);\nvoid Sieve(int n, vector<bool> &prime) {\n  for (int p = 2; p * p <= n; p++) {\n    if (prime[p] == true) {\n      for (int i = p * p; i <= n; i += p) prime[i] = false;\n    }\n  }\n}\nvector<long long> getFact(long long x) {\n  vector<long long> primes;\n  for (long long i = 2; i * i <= x; i++) {\n    if (x % i == 0) {\n      primes.push_back(i);\n      while (x % i == 0) x /= i;\n    }\n  }\n  if (x != 1) primes.push_back(x);\n  return primes;\n}\nlong long power(long long a, long long b) {\n  long long fact = 0;\n  while (a) {\n    a /= b;\n    fact += a;\n  }\n  return fact;\n}\nstruct FenwickTree {\n  vector<long long> bit;\n  long long n;\n  FenwickTree(long long n) {\n    this->n = n + 1;\n    bit.assign(n + 1, 0);\n  }\n  long long sum(long long idx) {\n    long long ret = 0;\n    for (++idx; idx > 0; idx -= idx & -idx) ret += bit[idx];\n    return ret;\n  }\n  long long sum(long long l, long long r) { return sum(r) - sum(l - 1); }\n  void add(long long idx, long long delta) {\n    for (++idx; idx < n; idx += idx & -idx) bit[idx] += delta;\n  }\n};\nvoid updateBiT(int BiTree[], int n, int index, int val) {\n  index += 1;\n  while (index <= n) {\n    BiTree[index] += val;\n    index += index & (-index);\n  }\n}\nvoid solve() {\n  long long n;\n  cin >> n;\n  vector<long long> adj[n + 1];\n  vector<long long> indeg(n + 1, 0);\n  for (long long i = 1; i <= n; i++) {\n    long long k;\n    cin >> k;\n    for (long long j = 1; j <= k; j++) {\n      long long u = i;\n      long long v;\n      cin >> v;\n      adj[v].push_back(u);\n      indeg[u]++;\n    }\n  }\n  queue<long long> q;\n  long long ok = false;\n  for (long long i = 1; i <= n; i++) {\n    if (indeg[i] == 0) {\n      ok = true;\n      q.push(i);\n    }\n  }\n  vector<long long> topo;\n  while (q.empty() == false) {\n    int ele = q.front();\n    topo.push_back(ele);\n    q.pop();\n    for (auto itr : adj[ele]) {\n      indeg[itr]--;\n      if (indeg[itr] == 0) q.push(itr);\n    }\n  }\n  for (long long i = 1; i <= n; i++) {\n    if (indeg[i] != 0) ok = false;\n  }\n  if (!ok) {\n    cout << \"-1\" << endl;\n    return;\n  }\n  vector<long long> dp(n + 1, 1);\n  for (long long i = 0; i < topo.size(); i++) {\n    for (auto itr : adj[topo[i]]) {\n      if (itr < topo[i]) {\n        dp[itr] = max(dp[topo[i]] + 1, dp[itr]);\n      }\n      dp[itr] = max(dp[itr], dp[topo[i]]);\n    }\n  }\n  long long ans = 0;\n  for (long long i = 1; i <= n; i++) ans = max(dp[i], ans);\n  cout << ans << endl;\n}\nint main() {\n  ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  srand(chrono::high_resolution_clock::now().time_since_epoch().count());\n  long long t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.*;\n\npublic class Q1 {\n\n  static Scanner sc = new Scanner(System.in);\n\n  public static void main(String args[]) throws Exception {\n    int t = sc.nextInt();\n    while (t-- != 0) {\n      solve();\n    }\n  }\n\n  static void solve() {\n    int n = sc.nextInt();\n    HashSet<Integer>[] requirement = new HashSet[n + 1];\n    HashSet<Integer>[] neededfor = new HashSet[n + 1];\n    TreeSet<Integer> leaves = new TreeSet();\n    int count = 0;\n    for (int i = 0; i <= n; i++) {\n      requirement[i] = new HashSet();\n      neededfor[i] = new HashSet();\n    }\n    for (int i = 0; i < n; i++) {\n      int k = sc.nextInt();\n      for (int j = 0; j < k; j++) {\n        int required = sc.nextInt();\n        requirement[i + 1].add(required);\n        neededfor[required].add(i + 1);\n      }\n      if (requirement[i + 1].isEmpty()) {\n        leaves.add(i + 1);\n      }\n    }\n    while (!leaves.isEmpty()) {\n      count++;\n      TreeSet<Integer> temp = new TreeSet();\n      while (!leaves.isEmpty()) {\n        int leaf = leaves.pollFirst();\n        for (int requiredBy : neededfor[leaf]) {\n          requirement[requiredBy].remove(leaf);\n          if (requirement[requiredBy].isEmpty()) {\n            if (requiredBy < leaf) {\n              temp.add(requiredBy);\n            } else {\n              leaves.add(requiredBy);\n            }\n          }\n        }\n      }\n      leaves = temp;\n    }\n    for (int i = 0; i <= n; i++) {\n      if (!requirement[i].isEmpty()) {\n        System.out.println(-1);\n        return;\n      }\n    }\n    System.out.println(count);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 2e5 + 5, M = 1e9 + 7, OO = 0x3f3f3f3f;\nlong long t, n, x;\nvector<long long> adj[N];\nlong long k[N];\nlong long BFS() {\n  priority_queue<pair<long long, long long>> pq;\n  vector<pair<long long, long long>> fans;\n  long long vs = 0;\n  for (int i = 0; i < n; ++i) {\n    if (k[i] == 0) pq.push({0, -i});\n  }\n  long long ret = 0;\n  while (!pq.empty()) {\n    pair<long long, long long> p = pq.top();\n    long long u = -p.second;\n    long long pr = -p.first;\n    ret = max(ret, pr);\n    fans.push_back({u, pr});\n    pq.pop();\n    for (auto v : adj[u]) {\n      k[v]--;\n      if (k[v] == 0) {\n        if (v > u)\n          pq.push({-pr, -v});\n        else\n          pq.push({-(pr + 1), -v});\n      }\n    }\n  }\n  if (fans.size() == n)\n    return ret + 1;\n  else\n    return -1;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  ;\n  cin >> t;\n  while (t--) {\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n      cin >> k[i];\n      for (int j = 0; j < k[i]; ++j) {\n        cin >> x;\n        x--;\n        adj[x].push_back(i);\n      }\n    }\n    long long ans = BFS();\n    cout << ans << \"\\n\";\n    for (int i = 0; i < n; ++i) adj[i].clear();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class BookCodeforce {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\tint  t= sc.nextInt();\n\t\tint i;\n\t\tfor(i=0; i<t; i++) {\n\t\t\tint n = sc.nextInt();\n\t\t\tArrayList<Integer>[] list= new ArrayList[n];\n\t\t\tint j;\n\t\t\tfor(j=0; j<n; j++) {\n\t\t\t\tlist[j] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor(j=0; j<n; j++) {\n\t\t\t\tint m = sc.nextInt();\n\t\t\t\tint k;\n\t\t\t\tfor(k=0; k<m; k++) {\n\t\t\t\t\tlist[j].add(sc.nextInt()-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(solve(list));\n\t\t}\n\t\tsc.close();\n\t}\n\tstatic int solve(ArrayList<Integer>[] list) {\n\t\tint n = list.length;\n\t\tint[] order = new int[n];\n\t\tint i;\n\t\tint times=1;\n\t\tPriorityQueue<chapter> pq = new PriorityQueue<>(new Comparator<chapter>() {\n\t\t\tpublic int compare(chapter a, chapter b) {\n\t\t\t\tif(a.times > b.times) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\telse if(a.times < b.times) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn a.idx - b.idx;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tfor(i=0; i<n; i++) {\n\t\t\torder[i] = list[i].size();\n\t\t\tif(order[i] == 0) {\n\t\t\t\tpq.add(new chapter(times,i));\n\t\t\t}\n\t\t}\n\t\tArrayList<Integer>[] g = new ArrayList[n];\n\t\tint j;\n\t\tfor(i=0; i<n; i++) {\n\t\t\tg[i] = new ArrayList<>();\n\t\t}\n\t\tfor(i=0; i<n; i++) {\n\t\t\tfor(j=0; j<list[i].size(); j++) {\n\t\t\t\tg[list[i].get(j)].add(i);\n\t\t\t}\n\t\t}\n\t\tchapter cp;\n\t\tint chaps=0;\n\t\twhile(!pq.isEmpty()) {\n\t\t\t\n\t\t\tcp = pq.poll();\n\t\t\tchaps++;\n\t\t\tfor(i=0; i<g[cp.idx].size(); i++) {\n\t\t\t\torder[g[cp.idx].get(i)]--;\n\t\t\t\tif(order[g[cp.idx].get(i)] == 0) {\n\t\t\t\t\tif(g[cp.idx].get(i) < cp.idx) {\n\t\t\t\t\t\ttimes = Math.max(times, cp.times + 1);\n\t\t\t\t\t\tpq.add(new chapter(cp.times+1, g[cp.idx].get(i)));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tpq.add(new chapter(cp.times, g[cp.idx].get(i)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(chaps < n) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn times;\n\t}\n}\nclass chapter{\n\tint times;\n\tint idx;\n\tchapter(int t, int i){\n\t\ttimes = t;\n\t\tidx = i;\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\nusing namespace std;\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<vector<int>> adj(n);\n  map<int, int> indegree;\n  for (int i = 0; i < n; i++) {\n    int k;\n    cin >> k;\n    for (int j = 0; j < k; j++) {\n      int chapter;\n      cin >> chapter;\n      chapter--;\n      adj[chapter].push_back(i);\n      indegree[i]++;\n    }\n  }\n  queue<int> q;\n  for (int i = 0; i < n; i++) {\n    if (indegree[i] == 0) {\n      q.push(i);\n    }\n  }\n  int read = 0;\n  vector<int> readingTime(n, 1);\n  while (!q.empty()) {\n    read++;\n    int node = q.front();\n    q.pop();\n    for (auto child : adj[node]) {\n      if (child > node) {\n        readingTime[child] = max(readingTime[child], readingTime[node]);\n      } else {\n        readingTime[child] = max(readingTime[child], readingTime[node] + 1);\n      }\n      indegree[child]--;\n      if (indegree[child] == 0) {\n        q.push(child);\n      }\n    }\n  }\n  if (read != n) {\n    cout << -1 << endl;\n  } else {\n    int ans = 0;\n    for (auto x : readingTime) {\n      ans = max(ans, x);\n    }\n    cout << ans << endl;\n  }\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\nimport java.io.*;\n \npublic class Book {\n\t\n\tprivate static class MyScanner {\n\t    BufferedReader br;\n\t    StringTokenizer st;\n\n\t    public MyScanner() {\n\t       br = new BufferedReader(new InputStreamReader(System.in));\n\t    }\n\n\t    String next() {\n\t        while (st == null || !st.hasMoreElements()) {\n\t            try {\n\t                st = new StringTokenizer(br.readLine());\n\t            } catch (IOException e) {\n\t                e.printStackTrace();\n\t            }\n\t        }\n\t        return st.nextToken();\n\t    }\n\n\t    int nextInt() {\n\t        return Integer.parseInt(next());\n\t    }\n\n\t    long nextLong() {\n\t        return Long.parseLong(next());\n\t    }\n\n\t    double nextDouble() {\n\t        return Double.parseDouble(next());\n\t    }\n\n\t    String nextLine(){\n\t        String str = \"\";\n\t\t  try {\n\t\t     str = br.readLine();\n\t\t  } catch (IOException e) {\n\t\t     e.printStackTrace();\n\t\t  }\n\t\t  return str;\n\t    }\n\n\t }\n\t\n\n    public static class Pair implements Comparable<Pair> {\n\t\t\n\t\tint x;\n\t\tint y;\n\t\t\n\t\tPair(int x, int y){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\t\n\t\tpublic int compareTo(Pair p)\n\t\t{\n\t\t\tif(this.x!=p.x)\n\t\t\t  return ((Integer)this.x).compareTo(p.x);\n\t\t\t\n\t\t    return ((Integer)this.y).compareTo(p.y);\n\t\t}\n\t}\n\t\n\tpublic static int solution( int n, HashMap<Integer, HashSet<Integer>> map)\n\t\t\t\n\t{\n\t\tHashMap<Integer, ArrayList<Integer>> graph = new HashMap<>();\n\t\tint[] level = new int[n];\n\t    PriorityQueue<Pair> q = new PriorityQueue<>();\n\t\t\n\t     for(int i = 0; i<n; i++)\n\t       graph.put(i+1, new ArrayList<>());\n\t     \n\t     for(int i : map.keySet())\n\t     {\n\t    \t if(map.get(i).isEmpty())\n\t    \t { q.add(new Pair(1,i)); level[i-1] = 1; }\n\t    \t \n\t    \t for(int j : map.get(i))\n\t    \t\t graph.get(j).add(i);\n\t    \t \n\t     }\n  \n\t     int count = 0;\n\t     \n\t     while(!q.isEmpty()) {\n\t    \t \n\t    \t int curr = q.remove().y;\n\t    \t count++;\n\t    \t \n\t    \t for(int j : graph.get(curr))\n\t    \t {\n\t    \t    if(map.get(j).remove(curr));\n\t    \t    if(map.get(j).isEmpty())\n\t    \t    {\n\t    \t    \tif(j>curr)\n\t    \t    \t\tlevel[j-1] = level[curr-1];\n\t    \t    \telse\n\t    \t    \t\tlevel[j-1] = level[curr-1]+1;\n\t    \t    \tq.add(new Pair(level[j-1], j));\n\t    \t    \t\n\t    \t    }    \t    \t\n\t    \t    \t\n\t    \t }\n\t    \t \n\t     }\n\t     \n\t     if(q.isEmpty() && count<n)\n\t    \t return -1;\n\t     \n\t     int max = Integer.MIN_VALUE;\n\t     \n\t     for(int i = 0; i<n; i++)\n\t     {\n\t    \t if(level[i]>max)\n\t    \t\t max = level[i];\n \t     }\n\t     \n\t     return max;\n\t     \n\t}\n        \nprivate static PrintWriter out = new PrintWriter(System.out);\n\npublic static void main (String[] args)\n{\n\tMyScanner s =  new MyScanner();\n     \n    int t = s.nextInt();\n    \n    for(int j = 0; j<t ; j++)\n    {\n    \tint n = s.nextInt();\n    \t\n    \tHashMap<Integer, HashSet<Integer>> map = new HashMap<>();\n    \t\n    \tfor(int i =0; i<n; i++)\n    \t{\n    \t\tmap.put(i+1, new HashSet<>());\n    \t    int m = s.nextInt();\n    \t    \n    \t    for(int k = 0; k<m ; k++)\n    \t    \tmap.get(i+1).add(s.nextInt());\n    \t}\n    \t\n    \tout.println(solution(n,map));\n    }\n    \n    out.flush();\n    out.close();\n    \n}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> book[(200001)];\nint status[(200001)];\nint rTimes[(200001)];\nvoid deepFind(int chapter, bool &deadLock) {\n  if (deadLock) return;\n  status[chapter] = (1);\n  for (int i : book[chapter]) {\n    switch (status[i]) {\n      case (1):\n        deadLock = true;\n        return;\n      case (0):\n        deepFind(i, deadLock);\n    }\n  }\n  status[chapter] = (2);\n}\nvoid readChapter(int chapter) {\n  status[chapter] = (2);\n  if (book[chapter].empty()) {\n    rTimes[chapter] = 1;\n    return;\n  }\n  for (int require : book[chapter]) {\n    if (rTimes[require] == (0)) readChapter(require);\n    if (require > chapter) {\n      rTimes[chapter] = max(rTimes[chapter], rTimes[require] + 1);\n    } else {\n      rTimes[chapter] = max(rTimes[chapter], rTimes[require]);\n    }\n  }\n}\nvoid solve() {\n  int chapters;\n  cin >> chapters;\n  for (int i = 1; i <= chapters; i++) {\n    book[i].clear();\n    status[i] = (0);\n    rTimes[i] = 0;\n    int amount, require;\n    cin >> amount;\n    for (int j = 0; j < amount; j++) {\n      cin >> require;\n      book[i].push_back(require);\n    }\n  }\n  bool deadLock = false;\n  for (int i = 1; i <= chapters; i++) {\n    if (status[i] == 0) {\n      deepFind(i, deadLock);\n      if (deadLock) {\n        cout << -1 << endl;\n        return;\n      }\n    }\n  }\n  for (int i = 1; i <= chapters; i++) status[i] = (0);\n  for (int i = 1; i <= chapters; i++) {\n    if (status[i] == (0)) readChapter(i);\n  }\n  int result = 0;\n  for (int i = 1; i <= chapters; i++) result = max(result, rTimes[i]);\n  cout << result << endl;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int cases;\n  cin >> cases;\n  for (int i = 0; i < cases; i++) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 10, M = N;\nstruct Graph {\n  struct Edge {\n    int nxt, to;\n    long long w;\n  } e[M << 1];\n  int head[N], cnt = 1, in[N];\n  void add(int x, int y, long long w) {\n    e[++cnt].nxt = head[x], head[x] = cnt, e[cnt].to = y, e[cnt].w = w, in[y]++;\n  }\n  void init(int MAXN) {\n    memset(head, 0, sizeof(int) * (MAXN + 1));\n    memset(in, 0, sizeof(int) * (MAXN + 1));\n    cnt = 1;\n  }\n} gr;\nint n, m;\nvector<int> son[N];\nstruct Tarjan {\n  int idx;\n  int col[N], cnt[N];\n  int dfn[N], low[N];\n  bool vis[N];\n  vector<int> stac;\n  void dfs(int now, Graph& graph) {\n    low[now] = dfn[now] = ++idx;\n    stac.push_back(now), vis[now] = 1;\n    for (int i = graph.head[now]; i; i = graph.e[i].nxt) {\n      int j = graph.e[i].to;\n      if (!dfn[j]) {\n        dfs(j, graph);\n        low[now] = min(low[now], low[j]);\n      } else if (vis[j])\n        low[now] = min(low[now], dfn[j]);\n    }\n    if (dfn[now] == low[now]) {\n      while (1) {\n        col[stac.back()] = now;\n        cnt[stac.back()]++;\n        vis[stac.back()] = 0;\n        if (stac.back() == now) {\n          stac.pop_back();\n          break;\n        }\n        stac.pop_back();\n      }\n    }\n  }\n  void init(Graph& graph, int MAXN) {\n    idx = 0;\n    memset(col, 0, sizeof(int) * (MAXN + 1));\n    memset(cnt, 0, sizeof(int) * (MAXN + 1));\n    memset(dfn, 0, sizeof(int) * (MAXN + 1));\n    memset(low, 0, sizeof(int) * (MAXN + 1));\n    for (int i = 1; i <= MAXN; i++)\n      if (!dfn[i]) dfs(i, graph);\n  }\n} tarjan;\nvoid solve() {\n  cin >> n;\n  gr.init(n);\n  for (int i = 1; i <= n; i++) son[i].clear();\n  vector<int> du(n + 1);\n  for (int i = 1; i <= n; i++) {\n    int k;\n    cin >> k;\n    du[i] = k;\n    for (int j = 1; j <= k; j++) {\n      int x;\n      cin >> x;\n      son[x].push_back(i);\n      gr.add(x, i, 1);\n    }\n  }\n  tarjan.init(gr, n);\n  set<int> st;\n  for (int i = 1; i <= n; i++) {\n    if (tarjan.col[i] != i) {\n      cout << -1 << '\\n';\n      return;\n    }\n    if (du[i] == 0) st.insert(i);\n  }\n  int ans = 0;\n  while (st.size()) {\n    auto it = st.begin();\n    while (it != st.end()) {\n      int u = *it;\n      for (auto sn : son[u]) {\n        du[sn]--;\n        if (du[sn] == 0) {\n          st.insert(sn);\n        }\n      }\n      st.erase(u);\n      it = st.upper_bound(u);\n    }\n    ans++;\n  }\n  cout << ans << '\\n';\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int ttt = 1;\n  cin >> ttt;\n  for (int i = 1; i <= ttt; i++) solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Book {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // BufferedReader br = new BufferedReader(new FileReader(\"input.txt\"));\n        handleMultipleTest(br);\n    }\n\n    private static void handleMultipleTest(BufferedReader br) throws IOException {\n        int T = Integer.parseInt(br.readLine());\n        for (int i = 0; i < T; i++) {\n            handleTestCase(br);\n        }\n    }\n\n    private static void handleTestCase(BufferedReader br) throws IOException {\n        int N = Integer.parseInt(br.readLine());\n        Map<Integer, Set<Integer>> dependency = new HashMap<>();\n        for (int i = 0; i < N; i++) {\n            dependency.put(i + 1, new HashSet<>());\n            String[] deps = br.readLine().split(\" \");\n            for (int k = 1; k < deps.length; k++) {\n                dependency.get(i + 1).add(Integer.parseInt(deps[k]));\n            }\n        }\n        readCount(N, dependency);\n    }\n\n    private static void readCount(int N, Map<Integer, Set<Integer>> dependency) {\n        looped = false;\n        Map<Integer, Integer> height = new HashMap<>();\n        int maxHeight = 0;\n        for (int i = 1; i <= N; i++) {\n            int h = calculateHeight(i, dependency, height, N + 1);\n            maxHeight = Math.max(maxHeight, h);\n        }\n        // System.out.println(\">> \" + height);\n        if (looped) {\n            System.out.println(-1);\n        } else {\n            System.out.println(maxHeight);\n        }\n    }\n\n    private static boolean looped = false;\n\n    private static int calculateHeight(int node, Map<Integer, Set<Integer>> dependency, Map<Integer, Integer> height, int N) {\n        if (height.containsKey(node)) return height.get(node);\n        if (N == 0) {\n            // System.out.println(node + \" \" + height + \" \" + N);\n            looped = true;\n            return 0;\n        }\n        int maxHeight = 1;\n        for (int next : dependency.get(node)) {\n            int nextHeight = calculateHeight(next, dependency, height, N - 1);\n            maxHeight = Math.max(maxHeight, next < node ? nextHeight : nextHeight + 1);\n        }\n        height.put(node, maxHeight);\n        return maxHeight;\n    }\n}"
        },
        {
            "language": 3,
            "solution": "import sys\nfrom math import factorial, gcd\n#from math import comb, perm \t\nfrom collections import Counter, deque, defaultdict\nfrom bisect import bisect_left, bisect_right \nfrom heapq import heappop, heappush, heapify, nlargest, nsmallest\nfrom itertools import groupby\nfrom copy import deepcopy\nMOD = 10**9+7\nINF = float('inf')\n\nrl = lambda : list(map(int, sys.stdin.readline().split()))\nrs = lambda : sys.stdin.readline().strip()\n\nfor _ in range(int(input())):\n\tn = int(input())\n\treq = Counter()\n\tB = defaultdict(list)\n\tfor i in range(1, n+1):\n\t\tk, *A = rl()\n\t\treq[i] = k\n\t\tfor x in A:\n\t\t\tB[x].append(i)\n\n\tq = []\n\tcount = 0\n\tfor i in range(1, n+1):\n\t\tif req[i] == 0:\n\t\t\tcount += 1\n\t\t\tq.append(i)\n\n\tans = 0\n\twhile q:\n\t\tans += 1\n\t\tnq = []\n\t\twhile q:\n\t\t\tx = heappop(q)\n\n\t\t\tfor v in B[x]:\n\t\t\t\treq[v] -= 1\n\n\t\t\t\tif req[v] == 0:\n\t\t\t\t\tcount += 1\n\t\t\t\t\tif v > x:\n\t\t\t\t\t\theappush(q, v)\n\t\t\t\t\telse:\n\t\t\t\t\t\theappush(nq, v)\n\n\t\tq = nq\n\n\tprint(ans if count == n else -1)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 5;\nconst int inf = 0x3f3f3f3f;\nvector<int> vec[maxn];\nint f[maxn], vis[maxn];\nint dfs(int u) {\n  if (vis[u]) {\n    return (f[u] == inf) ? -1 : f[u];\n  }\n  vis[u] = 1;\n  int k = 1;\n  for (int i : vec[u]) {\n    int t = dfs(i);\n    if (t == -1) return -1;\n    if (u > i)\n      k = max(k, dfs(i));\n    else\n      k = max(k, dfs(i) + 1);\n  }\n  return f[u] = k;\n}\nvoid solve() {\n  int n;\n  cin >> n;\n  for (int i = 0; i <= n + 2; i++) vec[i].clear();\n  for (int i = 0; i <= n + 2; i++) f[i] = inf, vis[i] = 0;\n  for (int i = 1; i <= n; i++) {\n    int k;\n    cin >> k;\n    while (k--) {\n      int x;\n      cin >> x;\n      vec[i].push_back(x);\n    }\n  }\n  int res = 0;\n  for (int i = 1; i <= n; i++) {\n    if (!vis[i]) {\n      int k = dfs(i);\n      if (k == -1) {\n        cout << -1 << endl;\n        return;\n      }\n      res = max(res, k);\n    }\n  }\n  cout << res << endl;\n}\nint main() {\n  int T;\n  cin >> T;\n  while (T--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long oo = 1e18;\nconst long long N = 2e5 + 5;\nlong long a[N], b[N], k[N], n, h[N];\nvector<long long> d[N];\nset<int> g[N];\nbool vis[N];\nlong long bfs(long long first) {\n  queue<int> q;\n  q.push(first);\n  h[first] = 1;\n  long long ans = 0;\n  while (q.size()) {\n    long long u = q.front();\n    q.pop();\n    ans = max(ans, h[u]);\n    for (int v : d[u]) {\n      g[v].erase(u);\n      h[v] = max(h[v], h[u] + (v < u));\n      if (vis[v] == false && g[v].size() == 0)\n        h[v] = max(h[v], h[u] + (v < u)), q.push(v);\n    }\n  }\n  return ans;\n}\nvoid solve() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) d[i].clear(), h[i] = 0, g[i].clear(), vis[i] = 0;\n  for (int i = 1; i <= n; i++) {\n    cin >> k[i];\n    for (int j = 1, u; j <= k[i]; j++) {\n      cin >> u;\n      d[u].push_back(i);\n      g[i].insert(u);\n    }\n  }\n  long long ans = -1;\n  for (int i = 1; i <= n; i++)\n    if (k[i] == 0) {\n      ans = max(ans, bfs(i));\n    }\n  for (int i = 1; i <= n; i++)\n    if (g[i].size() > 0) ans = -1;\n  cout << ans << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long t;\n  cin >> t;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nfrom sys import stdout\n\ninput = lambda: sys.stdin.readline().strip()\nP = lambda: list(map(int, input().split()))\nfrom math import factorial as f, gcd, ceil\nfrom collections import deque, defaultdict as dd, Counter as C\nfrom heapq import heapify, heappop, heappush, heappushpop, heapreplace, merge\nfrom random import randint, choice, sample\nfrom operator import itemgetter as ig, attrgetter as ag, methodcaller as mc\nimport time\nmod = 10**9+7\na = ord('a')\n\n# Fenwick Tree\nclass FT:\n    def __init__(self, N):\n        self.ft = [0] * (N+1)\n        self.N = N\n\n    def ls(self, x):\n        return x & -x\n\n    def fenwick_update(self, p, v):\n        while p <= self.N:\n            self.ft[p] += v\n            p += self.ls(p)\n\n    def fenwick_query(self, p):\n        s = 0\n        while p:\n            s += self.ft[p]\n            p -= self.ls(p)\n        # print(p, s)\n        return s\n\nstart = time.time()\ndef fast_exp(x, exp):\n    ans = 1\n    base = x\n    while exp:\n        if exp & 1:\n            ans *= base\n        base *= base\n        base %= mod\n        ans %= mod\n        exp >>= 1\n    return ans\n\ndef countBits(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef submasks(n):\n    #this is cool\n    #https://cp-algorithms.com/algebra/all-submasks.html\n    org = n\n    while n:\n        yield n\n        n = (n-1) & org\n\n# Inverse things: very magic\n# https://www.youtube.com/watch?v=-OPohCQqi_E&ab_channel=Errichto\n# MOD MUST BE PRIME\n\ndef inv_mod(a):\n    # Euler's theorem (?)\n    return fast_exp(a, mod-2)\n\ndef mod_div(a, b):\n    return a * inv_mod(b) % mod\n\nN = 200000\nfac = [1] * N\ninvfac = [1] * N\n\ndef prep_fac(n):\n    global fac, invfac\n    fac.append(1)\n    invfac.append(1)\n    for i in range(1, n+1):\n        fac[i] =((fac[i-1] * i) % mod)\n        invfac[i] = ((invfac[i-1] * inv_mod(i)) % mod)\n\ndef ncr(n, r):\n    return (fac[n] * invfac[r] * invfac[n-r]) % mod\n\n\ndef solve():\n    n = int(input())\n    req = [P() for _ in range(n)]\n\n    # adj stores things that need this chapter\n    adj = [[] for _ in range(n)]\n    for i, x in enumerate(req):\n        first = True\n        for j in x:\n            if first:\n                first = False\n                continue\n\n            adj[j-1].append(i)\n\n    # left stores the chapters left to understand this chapter\n    left = [i[0] for i in req]\n    s = [(1, i) for i, x in enumerate(left) if not x][::-1]\n    heapify(s)\n    togo = n\n    ans = 0\n    while s:\n        # print(s)\n        a, c = heappop(s)\n        # print(c)\n        # print(adj)\n        togo -= 1\n        ans = max(a, ans)\n        for x in adj[c]:\n            left[x] -= 1\n            if not left[x]:\n                heappush(s, (a if c < x else a+1, x))\n        \n    #     print(left)\n    # print(togo, 'togo')\n    print(ans if not togo else -1)\n    \n            \n \n\n\n\n    \n\n\n    \n\n    \n\n    \n\n    \n\n    \n\n\n\ntc = int(input())\nfor t in range(1, tc+1):\n    solve()\n\n# solve()\n# print(time.time()-start)\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 7;\nint a[N], k[N], sum;\nvector<int> v[N];\nchar s[N];\nstruct cmp1 {\n  bool operator()(pair<int, int> &x, pair<int, int> &y) {\n    if (x.second == y.second)\n      return x.first > y.first;\n    else\n      return x.second > y.second;\n  }\n};\nint main() {\n  int n, m, _, x;\n  scanf(\"%d\", &_);\n  while (_--) {\n    scanf(\"%d\", &n);\n    priority_queue<pair<int, int>, vector<pair<int, int> >, cmp1> q;\n    sum = 0;\n    for (int i = 1; i <= n; i++) v[i].clear();\n    for (int i = 1; i <= n; i++) {\n      scanf(\"%d\", &k[i]);\n      if (!k[i]) {\n        q.push({i, 1});\n        sum++;\n      }\n      for (int j = 1; j <= k[i]; j++) {\n        scanf(\"%d\", &x);\n        v[x].push_back(i);\n      }\n    }\n    int ans = -1;\n    while (!q.empty()) {\n      pair<int, int> tem = q.top();\n      q.pop();\n      x = tem.first;\n      ans = max(ans, tem.second);\n      for (auto it : v[x]) {\n        k[it]--;\n        if (!k[it]) {\n          if (it > x)\n            q.push({it, tem.second});\n          else\n            q.push({it, tem.second + 1});\n          sum++;\n        }\n      }\n    }\n    if (sum == n)\n      printf(\"%d\\n\", ans);\n    else\n      printf(\"-1\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        int[] intArr(int n) {\n            int res[] = new int[n];\n            for (int i = 0; i < n; i++)\n                res[i] = nextInt();\n            return res;\n        }\n\n        long[] longArr(int n) {\n            long res[] = new long[n];\n            for (int i = 0; i < n; i++)\n                res[i] = nextLong();\n            return res;\n        }\n    }\n\n    static FastReader in = new FastReader();\n    static PrintWriter out;\n\n    public static void main(String args[]) {\n        out = new PrintWriter(System.out);\n        resolve();\n        out.close();\n    }\n\n\n    public static void resolve(){\n        input();\n    }\n\n    private static void input(){\n        int t = in.nextInt();\n\n        for (int i = 0; i < t; i++) {\n            init();\n            output(calc());\n        }\n    }\n\n    private static int n;\n    private static ArrayList<Integer>[] adjacency;\n\n    private static void init() {\n        n = in.nextInt();\n        adjacency = new ArrayList[n + 1];\n        for (int i = 1; i < n + 1; i++) {\n            int k = in.nextInt();\n            adjacency[i] = new ArrayList<Integer>();\n            for (int j = 0; j < k; j++) {\n                adjacency[i].add(in.nextInt());\n            }\n        }\n    }\n\n    private static int[] neededReadingQuantity;\n    private static boolean[] alreadyKnow;\n    private static boolean isFundedCircle;\n    private static int maxDepth;\n    private static int calc(){\n        neededReadingQuantity = new int[adjacency.length];\n        alreadyKnow = new boolean[adjacency.length];\n        isFundedCircle = false;\n        maxDepth = 1;\n\n        for (int i = 1; i < adjacency.length; i++) {\n            if (alreadyKnow[i]){\n                continue;\n            }\n            inChain = new HashSet<Integer>();\n            inChain.add(i);\n            dfs(i);\n            alreadyKnow[i] = true;\n            if (isFundedCircle){\n                return -1;\n            }\n            if(maxDepth < neededReadingQuantity[i]){\n                maxDepth = neededReadingQuantity[i];\n            }\n        }\n        return maxDepth;\n    }\n\n    private static HashSet<Integer> inChain;\n\n    private static void dfs(int currentNode){\n        int d = 0;\n        int maxDepth = 1;\n        for (Integer i: adjacency[currentNode]) {\n            d = currentNode < i ? 1 : 0;\n            if (inChain.contains(i) || isFundedCircle){\n                isFundedCircle = true;\n                break;\n            }\n\n            if(!alreadyKnow[i]){\n                inChain.add(i);\n                dfs(i);\n                alreadyKnow[i]=true;\n            }\n\n            if (neededReadingQuantity[i] + d > maxDepth){\n                maxDepth = neededReadingQuantity[i] + d;\n            }\n            inChain.remove(i);\n        }\n        neededReadingQuantity[currentNode] = maxDepth;\n    }\n\n    private static void output(int d){\n        out.println(d);\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\nusing namespace std;\nbool ispoweroftwo(long long n) { return n & (!(n & (n - 1))); }\nlong long mod = 1000000007;\nlong long dx[] = {1, 0, -1, 0};\nlong long dy[] = {0, -1, 0, 1};\nbool test = 1;\nconst long long inf = 1e18;\nconst long long N = 2e5 + 5;\nlong long n;\nvector<long long> adj[N];\nlong long vis[N];\nvoid solve(long long tc = 0) {\n  cin >> n;\n  for (long long i = 1; i <= n; ++i) {\n    adj[i].clear();\n    vis[i] = 0;\n  }\n  vector<long long> store[n + 1];\n  vector<long long> in_deg(n + 5, 0);\n  for (long long i = 1, k; i <= n; ++i) {\n    cin >> k;\n    for (long long j = 1, x; j <= k; ++j) {\n      cin >> x;\n      store[i].push_back(x);\n      adj[x].push_back(i);\n      in_deg[i]++;\n    }\n  }\n  queue<long long> q;\n  for (long long i = 1; i <= n; ++i) {\n    if (in_deg[i] == 0) q.push(i);\n  }\n  vector<long long> order;\n  while (!q.empty()) {\n    long long u = q.front();\n    q.pop();\n    order.push_back(u);\n    for (auto it : adj[u]) {\n      in_deg[it]--;\n      if (in_deg[it] == 0) q.push(it);\n    }\n  }\n  if ((long long)order.size() != n) {\n    cout << \"-1\\n\";\n    return;\n  }\n  long long ans = 0;\n  vector<long long> res(n + 1, 1);\n  for (auto i : order) {\n    for (auto it : store[i]) {\n      if (it > i)\n        res[i] = max(res[i], res[it] + 1);\n      else\n        res[i] = max(res[i], res[it]);\n    }\n    ans = max(ans, res[i]);\n  }\n  cout << ans << \"\\n\";\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long t = 1;\n  if (test) cin >> t;\n  for (long long i = 1; i <= t; ++i) {\n    solve(i);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 10;\nvector<int> g[maxn];\nint d[maxn], in[maxn];\nqueue<int> q;\nsigned main() {\n  std::ios::sync_with_stdio(false);\n  cin.tie(0), cout.tie(0);\n  int T;\n  cin >> T;\n  while (T--) {\n    while (!q.empty()) q.pop();\n    int n;\n    cin >> n;\n    int sum = n;\n    for (int i = 1; i <= n; i++) g[i].clear();\n    memset(d, 0, sizeof(int) * (n + 10));\n    memset(in, 0, sizeof(int) * (n + 10));\n    for (int i = 1; i <= n; i++) {\n      int k;\n      cin >> k;\n      if (k == 0) {\n        d[i] = 1;\n        q.push(i);\n        sum--;\n      }\n      for (int j = 1; j <= k; j++) {\n        int x;\n        cin >> x;\n        g[x].push_back(i);\n        in[i]++;\n      }\n    }\n    while (!q.empty()) {\n      int x = q.front();\n      q.pop();\n      for (auto it : g[x]) {\n        in[it]--;\n        if (in[it] == 0) {\n          q.push(it);\n          sum--;\n        }\n        if (it > x)\n          d[it] = max(d[it], d[x]);\n        else\n          d[it] = max(d[it], d[x] + 1);\n      }\n    }\n    if (sum != 0)\n      cout << \"-1\" << endl;\n    else {\n      int ans = 0;\n      for (int i = 1; i <= n; i++) ans = max(ans, d[i]);\n      cout << ans << endl;\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 5;\nconst int INF = 0x3f3f3f3f;\nconst int mod = 1e9 + 7;\nvoid init() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n}\ninline int read() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = (x << 1) + (x << 3) + (ch ^ 48);\n    ch = getchar();\n  }\n  return x * f;\n}\nvoid write(int x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x > 9) write(x / 10);\n  putchar(x % 10 + '0');\n  return;\n}\nint deep[maxn], k[maxn];\nsigned main() {\n  init();\n  int t;\n  cin >> t;\n  int n;\n  while (t--) {\n    cin >> n;\n    memset(deep, 0, 4 * (n + 1));\n    vector<vector<int> > vec(n + 1);\n    int x;\n    int res = 0;\n    queue<int> que;\n    for (int i = 1; i <= n; i++) {\n      cin >> k[i];\n      if (k[i] == 0) {\n        que.push(i);\n        deep[i] = 1;\n        res = 1;\n      }\n      for (int j = 1; j <= k[i]; j++) {\n        cin >> x;\n        vec[x].push_back(i);\n      }\n    }\n    while (!que.empty()) {\n      int p = que.front();\n      que.pop();\n      for (int i = 0; i < vec[p].size(); i++) {\n        int son = vec[p][i];\n        if (k[son] != 0) {\n          if (son > p) {\n            deep[son] = max(deep[son], deep[p]);\n          } else {\n            deep[son] = max(deep[son], deep[p] + 1);\n          }\n          res = max(res, deep[son]);\n          k[son]--;\n          if (k[son] == 0) {\n            que.push(son);\n          }\n        }\n      }\n    }\n    if (count(k + 1, k + n + 1, 0) != n) {\n      cout << -1 << '\\n';\n    } else {\n      cout << res << '\\n';\n    }\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "import os, sys\nfrom io import BytesIO, IOBase\nimport operator as op\nfrom bisect import *\nfrom itertools import chain, repeat, starmap\nfrom functools import reduce\n\n\nclass SortedList():\n    \"\"\"Sorted list is a sorted mutable sequence.\"\"\"\n    DEFAULT_LOAD_FACTOR = 500\n\n    def __init__(self, iterable=None):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        self._len = 0\n        self._load = self.DEFAULT_LOAD_FACTOR\n        self._lists = []\n        self._maxes = []\n        self._index = []\n        self._offset = 0\n        if iterable is not None:\n            self.update(iterable)\n\n    def clear(self):\n        \"\"\"Remove all values from sorted list.\"\"\"\n        self._len = 0\n        del self._lists[:]\n        del self._maxes[:]\n        del self._index[:]\n        self._offset = 0\n\n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\"\"\"\n        _lists = self._lists\n        _maxes = self._maxes\n        if _maxes:\n            pos = bisect_right(_maxes, value)\n            if pos == len(_maxes):\n                _lists[pos - 1].append(value)\n                _maxes[pos - 1] = value\n            else:\n                insort(_lists[pos], value)\n            self._expand(pos)\n        else:\n            _lists.append([value])\n            _maxes.append(value)\n        self._len += 1\n\n    def _expand(self, pos):\n        \"\"\"Split sublists with length greater than double the load-factor.\"\"\"\n        _load = self._load\n        _lists = self._lists\n        _index = self._index\n\n        if len(_lists[pos]) > (_load << 1):\n            _maxes = self._maxes\n            _lists_pos = _lists[pos]\n            half = _lists_pos[_load:]\n            del _lists_pos[_load:]\n            _maxes[pos] = _lists_pos[-1]\n            _lists.insert(pos + 1, half)\n            _maxes.insert(pos + 1, half[-1])\n            del _index[:]\n        else:\n            if _index:\n                child = self._offset + pos\n                while child:\n                    _index[child] += 1\n                    child = (child - 1) >> 1\n                _index[0] += 1\n\n    def update(self, iterable):\n        \"\"\"Update sorted list by adding all values from `iterable`.\"\"\"\n        _lists = self._lists\n        _maxes = self._maxes\n        values = sorted(iterable)\n\n        if _maxes:\n            if len(values) * 4 >= self._len:\n                values.extend(chain.from_iterable(_lists))\n                values.sort()\n                self.clear()\n            else:\n                _add = self.add\n                for val in values:\n                    _add(val)\n                return\n\n        _load = self._load\n        _lists.extend(values[pos:(pos + _load)] for pos in range(0, len(values), _load))\n        _maxes.extend(sublist[-1] for sublist in _lists)\n        self._len = len(values)\n        del self._index[:]\n\n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n        _maxes = self._maxes\n        pos = bisect_left(_maxes, value)\n        if pos == len(_maxes):\n            return False\n\n        _lists = self._lists\n        idx = bisect_left(_lists[pos], value)\n        return _lists[pos][idx] == value\n\n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n        _maxes = self._maxes\n        pos = bisect_left(_maxes, value)\n        if pos == len(_maxes):\n            return\n\n        _lists = self._lists\n        idx = bisect_left(_lists[pos], value)\n        if _lists[pos][idx] == value:\n            self._delete(pos, idx)\n\n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        _maxes = self._maxes\n        _index = self._index\n\n        _lists_pos = _lists[pos]\n        del _lists_pos[idx]\n        self._len -= 1\n\n        len_lists_pos = len(_lists_pos)\n        if len_lists_pos > (self._load >> 1):\n            _maxes[pos] = _lists_pos[-1]\n\n            if _index:\n                child = self._offset + pos\n                while child > 0:\n                    _index[child] -= 1\n                    child = (child - 1) >> 1\n                _index[0] -= 1\n        elif len(_lists) > 1:\n            if not pos:\n                pos += 1\n            prev = pos - 1\n            _lists[prev].extend(_lists[pos])\n            _maxes[prev] = _lists[prev][-1]\n            del _lists[pos]\n            del _maxes[pos]\n            del _index[:]\n            self._expand(prev)\n        elif len_lists_pos:\n            _maxes[pos] = _lists_pos[-1]\n        else:\n            del _lists[pos]\n            del _maxes[pos]\n            del _index[:]\n\n    def _loc(self, pos, idx):\n        \"\"\"Convert an index pair (lists index, sublist index) into a single\n        index number that corresponds to the position of the value in the\n        sorted list.\"\"\"\n        if not pos:\n            return idx\n\n        _index = self._index\n        if not _index:\n            self._build_index()\n        total = 0\n        pos += self._offset\n        while pos:\n            if not pos & 1:\n                total += _index[pos - 1]\n            pos = (pos - 1) >> 1\n        return total + idx\n\n    def _pos(self, idx):\n        \"\"\"Convert an index into an index pair (lists index, sublist index)\n        that can be used to access the corresponding lists position.\"\"\"\n        if idx < 0:\n            last_len = len(self._lists[-1])\n            if (-idx) <= last_len:\n                return len(self._lists) - 1, last_len + idx\n            idx += self._len\n            if idx < 0:\n                raise IndexError('list index out of range')\n        elif idx >= self._len:\n            raise IndexError('list index out of range')\n\n        if idx < len(self._lists[0]):\n            return 0, idx\n\n        _index = self._index\n        if not _index:\n            self._build_index()\n\n        pos = 0\n        child = 1\n        len_index = len(_index)\n        while child < len_index:\n            index_child = _index[child]\n            if idx < index_child:\n                pos = child\n            else:\n                idx -= index_child\n                pos = child + 1\n            child = (pos << 1) + 1\n        return (pos - self._offset, idx)\n\n    def _build_index(self):\n        \"\"\"Build a positional index for indexing the sorted list.\"\"\"\n        row0 = list(map(len, self._lists))\n        if len(row0) == 1:\n            self._index[:] = row0\n            self._offset = 0\n            return\n\n        head = iter(row0)\n        tail = iter(head)\n        row1 = list(starmap(op.add, zip(head, tail)))\n        if len(row0) & 1:\n            row1.append(row0[-1])\n        if len(row1) == 1:\n            self._index[:] = row1 + row0\n            self._offset = 1\n            return\n\n        size = 1 << (len(row1) - 1).bit_length()\n        row1.extend(repeat(0, size - len(row1)))\n        tree = [row0, row1]\n        while len(tree[-1]) > 1:\n            head = iter(tree[-1])\n            tail = iter(head)\n            row = list(starmap(op.add, zip(head, tail)))\n            tree.append(row)\n        reduce(list.__iadd__, reversed(tree), self._index)\n        self._offset = size * 2 - 1\n\n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        if isinstance(index, slice):\n            start, stop, step = index.indices(self._len)\n            if step == 1 and start < stop:\n                if start == 0 and stop == self._len:\n                    return self.clear()\n                elif self._len <= 8 * (stop - start):\n                    values = self.__getitem__(slice(None, start))\n                    if stop < self._len:\n                        values += self.__getitem__(slice(stop, None))\n                    self.clear()\n                    return self.update(values)\n\n            indices = range(start, stop, step)\n            if step > 0:\n                indices = reversed(indices)\n            _pos, _delete = self._pos, self._delete\n            for index in indices:\n                pos, idx = _pos(index)\n                _delete(pos, idx)\n        else:\n            pos, idx = self._pos(index)\n            self._delete(pos, idx)\n\n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        _lists = self._lists\n\n        if isinstance(index, slice):\n            start, stop, step = index.indices(self._len)\n\n            if step == 1 and start < stop:\n                if start == 0 and stop == self._len:\n                    return reduce(list.__iadd__, self._lists, [])\n\n                start_pos, start_idx = self._pos(start)\n                if stop == self._len:\n                    stop_pos = len(_lists) - 1\n                    stop_idx = len(_lists[stop_pos])\n                else:\n                    stop_pos, stop_idx = self._pos(stop)\n                if start_pos == stop_pos:\n                    return _lists[start_pos][start_idx:stop_idx]\n\n                prefix = _lists[start_pos][start_idx:]\n                middle = _lists[(start_pos + 1):stop_pos]\n                result = reduce(list.__iadd__, middle, prefix)\n                result += _lists[stop_pos][:stop_idx]\n                return result\n\n            if step == -1 and start > stop:\n                result = self.__getitem__(slice(stop + 1, start + 1))\n                result.reverse()\n                return result\n\n            indices = range(start, stop, step)\n            return list(self.__getitem__(index) for index in indices)\n        else:\n            if self._len:\n                if index == 0:\n                    return _lists[0][0]\n                elif index == -1:\n                    return _lists[-1][-1]\n            else:\n                raise IndexError('list index out of range')\n\n            if 0 <= index < len(_lists[0]):\n                return _lists[0][index]\n\n            len_last = len(_lists[-1])\n            if -len_last < index < 0:\n                return _lists[-1][len_last + index]\n\n            pos, idx = self._pos(index)\n            return _lists[pos][idx]\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return chain.from_iterable(self._lists)\n\n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return chain.from_iterable(map(reversed, reversed(self._lists)))\n\n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n\n    def bisect_left(self, value):\n        \"\"\"Return an index to insert `value` in the sorted list.\"\"\"\n        pos = bisect_left(self._maxes, value)\n        return self._len if pos == len(self._maxes) else self._loc(pos, bisect_left(self._lists[pos], value))\n\n    def bisect_right(self, value):\n        \"\"\"Return an index to insert `value` in the sorted list.\"\"\"\n        pos = bisect_right(self._maxes, value)\n        return self._len if pos == len(self._maxes) else self._loc(pos, bisect_right(self._lists[pos], value))\n\n    bisect = bisect_right\n\n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n        _maxes = self._maxes\n        if not _maxes:\n            return 0\n\n        pos_left = bisect_left(_maxes, value)\n        if pos_left == len(_maxes):\n            return 0\n\n        _lists = self._lists\n        idx_left = bisect_left(_lists[pos_left], value)\n        pos_right = bisect_right(_maxes, value)\n        if pos_right == len(_maxes):\n            return self._len - self._loc(pos_left, idx_left)\n\n        idx_right = bisect_right(_lists[pos_right], value)\n        if pos_left == pos_right:\n            return idx_right - idx_left\n\n        right = self._loc(pos_right, idx_right)\n        left = self._loc(pos_left, idx_left)\n        return right - left\n\n    def copy(self):\n        \"\"\"Return a shallow copy of the sorted list.\"\"\"\n        return self.__class__(self)\n\n    __copy__ = copy\n\n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n        if not self._len:\n            raise IndexError('pop index out of range')\n\n        _lists = self._lists\n        if 0 <= index < len(_lists[0]):\n            val = _lists[0][index]\n            self._delete(0, index)\n            return val\n\n        len_last = len(_lists[-1])\n        if -len_last < index < 0:\n            pos = len(_lists) - 1\n            loc = len_last + index\n            val = _lists[pos][loc]\n            self._delete(pos, loc)\n            return val\n\n        pos, idx = self._pos(index)\n        val = _lists[pos][idx]\n        self._delete(pos, idx)\n        return val\n\n    def index(self, value, start=0, stop=None):\n        \"\"\"Return first index of value in sorted list.\"\"\"\n        _len = self._len\n        if start < 0:\n            start += _len\n        if start < 0:\n            start = 0\n        if stop is None:\n            stop = _len\n        if stop < 0:\n            stop += _len\n        if stop > _len:\n            stop = _len\n\n        if stop <= start:\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        _maxes = self._maxes\n        pos_left = bisect_left(_maxes, value)\n        if pos_left == len(_maxes):\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        _lists = self._lists\n        idx_left = bisect_left(_lists[pos_left], value)\n        if _lists[pos_left][idx_left] != value:\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        stop -= 1\n        left = self._loc(pos_left, idx_left)\n        if start <= left:\n            if left <= stop:\n                return left\n        else:\n            if start <= self.bisect_right(value) - 1:\n                return start\n        raise ValueError('{0!r} is not in list'.format(value))\n\n    def __add__(self, other):\n        \"\"\"Return new sorted list containing all values in both sequences.\"\"\"\n        values = reduce(list.__iadd__, self._lists, [])\n        values.extend(other)\n        return self.__class__(values)\n\n    __radd__ = __add__\n\n    def __iadd__(self, other):\n        \"\"\"Update sorted list with values from `other`.\"\"\"\n        self.update(other)\n        return self\n\n    def __mul__(self, num):\n        \"\"\"Return new sorted list with `num` shallow copies of values.\"\"\"\n        values = reduce(list.__iadd__, self._lists, []) * num\n        return self.__class__(values)\n\n    __rmul__ = __mul__\n\n    def __imul__(self, num):\n        \"\"\"Update the sorted list with `num` shallow copies of values.\"\"\"\n        values = reduce(list.__iadd__, self._lists, []) * num\n        self.clear()\n        self.update(values)\n        return self\n\n    def __make_cmp(seq_op):\n        \"Make comparator method.\"\n\n        def comparer(self, other):\n            \"Compare method for sorted list and sequence.\"\n            self_len = self._len\n            len_other = len(other)\n            if self_len != len_other:\n                if seq_op is op.eq:\n                    return False\n                if seq_op is op.ne:\n                    return True\n\n            for alpha, beta in zip(self, other):\n                if alpha != beta:\n                    return seq_op(alpha, beta)\n            return seq_op(self_len, len_other)\n\n        comparer.__name__ = '__{0}__'.format(seq_op.__name__)\n        return comparer\n\n    __eq__ = __make_cmp(op.eq)\n    __ne__ = __make_cmp(op.ne)\n    __lt__ = __make_cmp(op.lt)\n    __gt__ = __make_cmp(op.gt)\n    __le__ = __make_cmp(op.le)\n    __ge__ = __make_cmp(op.ge)\n    __make_cmp = staticmethod(__make_cmp)\n\n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return 'SortedList({0})'.format(reduce(list.__iadd__, self._lists, []))\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\ninp = lambda dtype: [dtype(x) for x in input().split()]\ninp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]\ninp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]\ninp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]\ninp_enus = lambda dtype, n: [[i] + inp(dtype) for i in range(n)]\nceil1 = lambda a, b: (a + b - 1) // b\n\n\nclass graph:\n    def __init__(self, n):\n        self.n, self.gdict = n, [[] for _ in range(n + 1)]\n        self.indeg = [0] * (n + 1)\n\n    def addEdge(self, node1, node2, w=None):\n        self.gdict[node1].append(node2)\n        self.indeg[node2] += 1\n\n    def kahn(self, n):\n        # enqueue all node with 0 in degree\n        queue, ans, lst = SortedList([i for i in range(1, n + 1) if not self.indeg[i]] + [2 * 10 ** 5 + 1]), 1, -1\n        cnt = 0\n\n        while len(queue) > 1:\n            # pop and push into topsort\n            ix = queue.bisect_right(lst)\n\n            if ix == len(queue) - 1:\n                ix = 0\n                ans += 1\n\n            lst = s = queue.pop(ix)\n\n            for i in self.gdict[s]:\n                self.indeg[i] -= 1\n                if not self.indeg[i]:\n                    queue.add(i)\n\n            cnt += 1\n        # check cycle\n        print(-1 if cnt != n else ans)\n\n\nfor _ in range(int(input())):\n    n = int(input())\n    g = graph(n)\n\n    for i in range(n):\n        for x in inp(int)[1:]:\n            g.addEdge(x, i + 1)\n    g.kahn(n)\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Main{\n\n    static int mod = (int) (Math.pow(10, 9)+7);\n\tstatic final int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };\n\tstatic final int[] dx8 = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\tstatic final int[] dx9 = { -1, -1, -1, 0, 0, 0, 1, 1, 1 }, dy9 = { -1, 0, 1, -1, 0, 1, -1, 0, 1 };\n\tstatic final int inf = Integer.MAX_VALUE / 2;\n\tstatic final long infL = Long.MAX_VALUE / 3;\n\tstatic final double infD = Double.MAX_VALUE / 3;\n\tstatic final double eps = 1e-10;\n\tstatic final double pi = Math.PI;\n    static List<Integer> primeNumbers = new ArrayList<>();\n\n    public static class graph{\n\n        //this is a directed graph\n        //now make a set storage for all of them\n        public ArrayList<ArrayList<Integer>> g;\n        public int n;\n        //set for all the elements for easy remove\n        // public ArrayList<\n        public ArrayList<Set<Integer>> parents;\n\n        graph(int n){\n\n            this.n = n;\n            g = new ArrayList<>(n+1);\n            for(int i= 0; i <= n; i++){\n                g.add(new ArrayList<>());\n            }\n\n            parents = new ArrayList<>(n+1);\n            for(int i= 0; i <= n; i++){\n                parents.add(new HashSet());\n            }\n        }\n\n        public void addEdge(int from, int to){\n            g.get(from).add(to);\n            parents.get(to).add(from);\n        }\n\n        public int count(){\n\n            //first step to put all elements with zero parents in the queue\n            //sorted set could be used tooo\n            \n            PriorityQueue<Integer> que = new PriorityQueue<>();\n            for(int i = 1; i <= n ; i++){\n                if(parents.get(i).size() == 0){\n                    que.add(i);\n                }\n            }\n\n            //and current que as always baby\n            //making new one \n            int[] visited= new int[n+1];\n            ArrayList<Integer> store = new ArrayList<>();\n\n            int count = 0;\n\n            while(true){\n                while(!que.isEmpty()){\n                    //we will keep working\n                    int curr = que.poll();\n                    visited[curr] = 1;\n\n                    for(int i : g.get(curr)){\n                        if(visited[i] == 1) continue;\n\n                        parents.get(i).remove(curr);\n                        if(parents.get(i).size() == 0){\n                            if(i > curr){\n                                que.add(i);\n                            }else{\n                                store.add(i);\n                            }\n                        }\n                    }\n                }\n\n                if(store.size() == 0){\n                    break;\n                }\n\n                for(int i : store){\n                    que.add(i);\n                }\n\n                store = new ArrayList<>();\n                count++;\n            } \n\n            for(int i = 1; i < n ; i++){\n                if(visited[i] == 0){\n                    return -2;\n                }\n            }\n\n            return count;\n        }\n\n\n    }\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n    \n        int test = sc.nextInt();\n\n        while(test -- > 0){\n\n            int n = sc.nextInt();\n\n            graph graph = new graph(n);\n\n            for(int i= 0; i < n ; i++){\n                int k = sc.nextInt();\n                for(int j = 0; j < k ; j++){\n                    int pos = sc.nextInt();\n                    graph.addEdge(pos, i+1);\n                }\n            }\n\n            // if(graph.isLoop()){\n            //     out.println(-1);\n            //     continue;\n            // }\n\n            //now i know that loop is not there atleast\n            out.println(graph.count()+1);\n          \n\n            //they both are ready now\n            //now first check if there is no cycle present\n            //first very condition\n            // System.out.println(graph.g);\n            // System.out.println(graph.parents);\n        }\n        \n        out.close();\n    }\n\n    //-------------------------------------------------------------------\n    //-------------------------------------------------------------------\n    //-------------------------------------------------------------------\n    //-------------------------------------------------------------------\n    //-------------------------------------------------------------------\n\n    public static class segmentTree{\n\n        public long[] arr;\n        public long[] tree;\n        public long[] lazy;\n\n        segmentTree(long[] array){\n            int n = array.length;\n            arr = new long[n];\n            for(int i= 0; i < n; i++) arr[i] = array[i];\n            tree = new long[4*n + 1];\n            lazy = new long[4*n + 1];\n        }\n\n        public void build(int s, int e, int index){\n            if(s == e){\n                tree[index] = arr[s];\n                return;\n            }\n            int mid = (s + e)/2;\n            build(s, mid, 2*index);\n            build(mid+1, e, 2*index + 1);\n            tree[index] = Math.max(tree[2*index], tree[2*index+1]);\n        }\n\n        //now we have to build query function\n        //there are different overlap in it, not very complicated, but definitely a lot useful\n        //you should learn them for sure\n        public long query(int s, int e, int sr, int er, int index){\n            if(lazy[index] != 0){\n                tree[index] = lazy[index];\n                if(s != e){\n                    lazy[2*index+1] = lazy[index];\n                    lazy[2*index] = lazy[index];\n                }\n                lazy[index] = 0;\n            }\n            if(er < s || sr > e) return Integer.MIN_VALUE;\n            if(sr <= s && e <= er) return tree[index];\n            int mid = (s + e)/2;\n            long left = query(s, mid, sr, er, 2*index);\n            long right = query(mid+1, e, sr, er, 2*index+1);\n            return Math.max(left, right);\n        }\n\n        public void update(int s, int e, int indexr, int increment, int index){\n            if(lazy[index] != 0){\n                tree[index] = lazy[index];\n                if(s != e){\n                    lazy[2*index+1] = lazy[index];\n                    lazy[2*index] = lazy[index];\n                }\n                lazy[index] = 0;\n            }\n            if(indexr < s || indexr > e) return;\n            if(s == e) tree[indexr] = increment;\n            int mid = (s + e)/2;\n            update(s, mid, indexr, increment, 2*index);\n            update(mid+1, e, indexr, increment, 2*index + 1);\n            tree[index] = Math.max(tree[2*index+1], tree[2*index]);\n        }\n\n        public void updateRangeLazy(int s, int e, int sr, int er, long increment, int index){\n            if(lazy[index] != 0){\n                tree[index] = lazy[index];\n\n                if(s != e){\n                    lazy[2*index + 1] = lazy[index];\n                    lazy[2*index] = lazy[index];\n                }\n                lazy[index] = 0;\n            }\n            if(sr > e || er < s) return;\n            if(sr <= s && e <= er){\n                tree[index] = increment;\n                if(s != e){\n                    lazy[2*index + 1] = increment;\n                    lazy[2*index] = increment;\n                }\n                return;\n            }\n            int mid = (s + e)/2;\n            updateRangeLazy(s, mid, sr, er, increment, 2*index);\n            updateRangeLazy(mid+1, e, sr, er, increment, 2*index + 1);\n            tree[index] = Math.max(tree[2*index], tree[2*index+1]);\n        }\n\n    }\n\n    //prime sieve\n    public static void primeSieve(int n){\n        BitSet bitset = new BitSet(n+1);\n        for(long i = 0; i < n ; i++){\n            if (i == 0 || i == 1) {\n                bitset.set((int) i);\n                continue;\n            }\n            if(bitset.get((int) i)) continue;\n            primeNumbers.add((int)i);\n            for(long j = i; j <= n ; j+= i)\n                bitset.set((int)j);\n        }\n    }\n\n    //number of divisors\n    public static int countDivisors(long number){\n        if(number == 1) return 1;\n        List<Integer> primeFactors = new ArrayList<>();\n        int index = 0;\n        long curr = primeNumbers.get(index);\n        while(curr * curr <= number){\n            while(number % curr == 0){\n                number = number/curr;\n                primeFactors.add((int) curr);\n            }    \n            index++;\n            curr = primeNumbers.get(index);\n        }\n\n        if(number != 1) primeFactors.add((int) number);\n        int current = primeFactors.get(0);\n        int totalDivisors = 1;\n        int currentCount = 2;\n        for (int i = 1; i < primeFactors.size(); i++) {\n            if (primeFactors.get(i) == current) {\n                currentCount++;\n            } else {\n                totalDivisors *= currentCount;\n                currentCount = 2;\n                current = primeFactors.get(i);\n            }\n        }\n        totalDivisors *= currentCount;\n        return totalDivisors;\n    }\n\n    //now adding next permutation function to java hehe\n    public static boolean next_permutation(int[] p) {\n        for (int a = p.length - 2; a >= 0; --a)\n          if (p[a] < p[a + 1])\n            for (int b = p.length - 1;; --b)\n              if (p[b] > p[a]) {\n                int t = p[a];\n                p[a] = p[b];\n                p[b] = t;\n                for (++a, b = p.length - 1; a < b; ++a, --b) {\n                  t = p[a];\n                  p[a] = p[b];\n                  p[b] = t;\n                }\n                return true;\n              }\n        return false;\n    }\n\n    //finding the value of NCR in O(RlogN) time and O(1) space\n    public static long getNcR(int n, int r)\n    {\n        long p = 1, k = 1;\n        if (n - r < r) r = n - r;\n\n        if (r != 0) {\n            while (r > 0) {\n                p *= n;\n                k *= r;\n                long m = __gcd(p, k);\n                p /= m;\n                k /= m;\n                n--;\n                r--;\n            }\n        }\n        else {\n            p = 1;\n        }\n        return p;\n    }\n \n    //for ncr calculator\n    public static long __gcd(long n1, long n2)\n    {\n        long gcd = 1;\n        for (int i = 1; i <= n1 && i <= n2; ++i) {\n            // Checks if i is factor of both integers\n            if (n1 % i == 0 && n2 % i == 0) {\n                gcd = i;\n            }\n        }\n        return gcd;\n    }\n\n\n\n    //is vowel function \n    public static boolean isVowel(char c)\n    {\n        return (c=='a' || c=='A' || c=='e' || c=='E' || c=='i' || c=='I' || c=='o' || c=='O' ||     c=='u' || c=='U');\n    }   \n\n    //two add two big numbers with some mod \n    public static int add(int a, int b) {\n\t\ta+=b;\n\t\tif (a>=mod) return a-mod;\n\t\treturn a;\n\t}\n\t\n    //two sub two numbers\n\tpublic static int sub(int a, int b) {\n\t\ta-=b;\n\t\tif (a<0) a+=mod;\n\t\telse if (a>=mod) a-=mod;\n\t\treturn a;\n\t}\n \n    //to sort the array with better method\n\tpublic static void sort(int[] a) {\n\t\tArrayList<Integer> l=new ArrayList<>();\n\t\tfor (int i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n\t\n    //for calculating binomialCoeff\n    public static int binomialCoeff(int n, int k)\n    {\n        int C[] = new int[k + 1];\n        // nC0 is 1\n        C[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            // Compute next row of pascal\n            // triangle using the previous row\n            for (int j = Math.min(i, k); j > 0; j--)\n                C[j] = C[j] + C[j - 1];\n        }\n        return C[k];\n    }\n\n    //Pair with int int \n    public static class Pair{\n\n        public int a;\n        public int b;\n\n        Pair(int a , int b){\n            this.a = a;\n            this.b = b;\n        }\n\n        @Override\n        public String toString(){\n            return a + \" -> \" + b; \n        }\n    }\n\n    //Triplet with int int int\n    public static class Triplet{\n\n        public int a;\n        public int b;\n        public int c;\n\n        Triplet(int a , int b, int c){\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n\n        @Override\n        public String toString(){\n            return a + \" -> \" + b; \n        }\n    }\n\n    //Shortcut function\n    public static long lcm(long a , long b){\n        return a * (b/gcd(a,b));\n    }\n\n    //let's make one for calculating lcm basically\n    public static int lcm(int a , int b){\n        return (a * b)/gcd(a,b);\n    }\n\n    //int version for gcd\n    public static int gcd(int a, int b){\n        if(b == 0)\n            return a;\n            \n        return gcd(b , a%b);\n    }\n\n    //long version for gcd\n    public static long gcd(long a, long b){\n        if(b == 0)\n            return a;\n\n        return gcd(b , a%b);\n    }\n\n    //swapping two elements in an array\n    public static void swap(int[] arr, int left , int right){\n        int temp = arr[left];\n        arr[left] = arr[right];\n        arr[right] = temp;\n    }\n\n    //\n     //for char array\n     public static void swap(char[] arr, int left , int right){\n        char temp = arr[left];\n        arr[left] = arr[right];\n        arr[right] = temp;\n    }\n\n    //reversing an array\n    public static void reverse(int[] arr){\n        int left = 0;\n        int right = arr.length-1;\n\n        while(left <= right){\n            swap(arr, left,right);\n            left++;\n            right--;\n        }\n    }\n\n     \n    //-----------PrintWriter for faster output---------------------------------\n    public static PrintWriter out;\n      \n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n      BufferedReader br;\n      StringTokenizer st;\n \n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n    \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n    \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n    \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    \n        String nextLine(){\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n    }\n   //--------------------------------------------------------\n}"
        },
        {
            "language": 3,
            "solution": "#from math import *\n#from bisect import *\n#from collections import *\n#from random import *\n#from decimal import *\"\"\"\nfrom heapq import *\n#from itertools import *\nimport sys\ninput=sys.stdin.readline\ndef inp():\n    return int(input())\ndef st():\n    return input().rstrip('\\n')\ndef lis():\n    return list(map(int,input().split()))\ndef ma():\n    return map(int,input().split())\nt=inp()\nwhile(t):\n    t-=1\n    n=inp()\n    r=[]\n    indeg=[0]*(n+1)\n    deg=[ [] for i in range(n+1)]\n    for i in range(n):\n        a=lis()\n        for j in range(a[0]):\n            indeg[i+1]+=1\n            deg[a[1+j]].append(i+1)\n    moves=1\n    cur_nodes=[]\n    heapify(cur_nodes)\n    for i in range(1,n+1):\n        if(indeg[i]==0):\n            heappush(cur_nodes,i)\n        \n    vis=set()\n    vis1=set()\n    while(1):\n        local=0\n        i=0\n        new=[]\n        while(cur_nodes):\n            y=heappop(cur_nodes)\n            vis.add(y)\n            for j in deg[y]:\n                indeg[j]-=1\n                if(indeg[j]==0):\n                    local=1\n                    if(y>j):\n                        new.append(j)\n                    else:\n                        heappush(cur_nodes,j)\n            #cur_nodes.popleft()\n        if(len(new)==0):\n            break\n        for i in new:\n            heappush(cur_nodes,i)\n        moves+=1\n    if(len(vis)==n):\n        print(moves)\n    else:\n        print(-1)\n        \n        \n        \n            \n    \n    \n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nbool time_seed = 0;\nusing namespace std;\nusing namespace std::chrono;\nstruct ListNode {\n  int val;\n  ListNode *next;\n  ListNode(int x) : val(x), next(NULL) {}\n};\nstruct TreeNode {\n  int val;\n  TreeNode *left;\n  TreeNode *right;\n  TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\nvoid show_vi(vector<int> t) {\n  for (int i = 0; i < t.size(); i++) {\n    cout << t[i] << \",\";\n  }\n  cout << endl;\n}\nvoid show_vp(vector<pair<int, int>> t) {\n  for (int i = 0; i < t.size(); i++) {\n    cout << t[i].first << \" \" << t[i].second << \"::\";\n  }\n  cout << endl;\n}\nvoid show_vd(vector<double> t) {\n  for (int i = 0; i < t.size(); i++) {\n    cout << t[i] << \",\";\n  }\n  cout << endl;\n}\nvoid show_vll(vector<long long int> t) {\n  for (int i = 0; i < t.size(); i++) {\n    cout << t[i] << \",\";\n  }\n  cout << endl;\n}\nvoid show_vt(vector<tuple<long long, long long>> t) {\n  for (int i = 0; i < t.size(); i++) {\n    cout << get<0>(t[i]) << \" \" << get<1>(t[i]) << \"::\";\n  }\n  cout << endl;\n}\nvoid show_vb(vector<bool> t) {\n  for (int i = 0; i < t.size(); i++) {\n    cout << t[i] << \" \";\n  }\n  cout << endl;\n}\nvoid show_vvi(vector<vector<int>> ans) {\n  cout << \"---------------------------\" << endl;\n  for (int i = 0; i < ans.size(); i++) {\n    show_vi(ans[i]);\n  }\n  cout << endl;\n}\nint randd() {\n  timeval start_time;\n  long milli_time, seconds, useconds;\n  gettimeofday(&start_time, NULL);\n  seconds = start_time.tv_sec;\n  useconds = start_time.tv_usec;\n  milli_time = ((seconds)*1000 + useconds / 1000.0);\n  if (time_seed == 0) {\n    time_seed = 1;\n    srand(milli_time);\n  }\n  int k = rand();\n  return k;\n}\nvoid show_vvvi(vector<vector<vector<int>>> ans) {\n  for (int i = 0; i < ans.size(); i++) {\n    cout << \"******************\" << endl;\n    show_vvi(ans[i]);\n  }\n  cout << endl;\n}\nvoid show_vvb(vector<vector<bool>> ans) {\n  cout << \"---------------------------\" << endl;\n  for (int i = 0; i < ans.size(); i++) {\n    show_vb(ans[i]);\n  }\n  cout << endl;\n}\nvoid show_vs(vector<string> A) {\n  for (int i = 0; i < A.size(); i++) {\n    cout << A[i] << \"::\";\n  }\n  cout << endl;\n}\nvoid show_vc(vector<char> A) {\n  for (int i = 0; i < A.size(); i++) {\n    cout << A[i];\n  }\n  cout << endl;\n}\nvoid show_vvc(vector<vector<char>> A) {\n  cout << \"---------------------------\" << endl;\n  for (int i = 0; i < A.size(); i++) {\n    show_vc(A[i]);\n  }\n}\nvoid show_vvs(vector<vector<string>> A) {\n  for (int i = 0; i < A.size(); i++) {\n    show_vs(A[i]);\n  }\n}\nvoid show_vvvs(vector<vector<vector<string>>> ans) {\n  for (int i = 0; i < ans.size(); i++) {\n    cout << \"******************\" << endl;\n    show_vvs(ans[i]);\n  }\n  cout << endl;\n}\nvoid show_um(unordered_map<int, int> &map) {\n  unordered_map<int, int>::iterator it;\n  it = map.begin();\n  while (it != map.end()) {\n    cout << it->first << \" \" << it->second << \"::\";\n    it++;\n  }\n  cout << endl;\n}\nlong long int ncr(long long int n, long long int r) {\n  if (r > n - r) r = n - r;\n  long long int C[r + 1];\n  memset(C, 0, sizeof(C));\n  C[0] = 1;\n  for (long long int i = 1; i <= n; i++) {\n    for (int j = min(i, r); j > 0; j--) {\n      C[j] = (C[j] + C[j - 1]);\n      C[j] %= 1000000007;\n    }\n  }\n  return C[r];\n}\nvector<long long int> prime_factors(long long int n) {\n  vector<long long int> ans;\n  while (n % 2 == 0) {\n    ans.push_back(2);\n    n = n / 2;\n  }\n  for (int i = 3; i <= sqrt(n); i = i + 2) {\n    while (n % i == 0) {\n      ans.push_back(i);\n      n = n / i;\n    }\n  }\n  if (n > 2) ans.push_back(n);\n  return ans;\n}\nlong long int pow_m(long long int a, long long int b) {\n  if (b == 0) return 1 % 1000000007;\n  long long int k = (long long int)pow_m(a, b / 2);\n  if (b % 2) {\n    return (((k * k) % 1000000007) * a) % 1000000007;\n  } else\n    return (k * k) % 1000000007;\n}\nlong long int poww(long long int a, long long int b) {\n  if (b == 1) return a;\n  if (b == 0) return 1;\n  long long int k = poww(a, b / 2);\n  if (b % 2) {\n    return k * k * a;\n  } else\n    return k * k;\n}\nlong long int modInverse(long long int a, long long int m) {\n  return pow_m(a, m - 2);\n}\nbool isPrime(int n) {\n  if (n <= 1) return false;\n  if (n <= 3) return true;\n  if (n % 2 == 0 || n % 3 == 0) return false;\n  for (int i = 5; i * i <= n; i = i + 6)\n    if (n % i == 0 || n % (i + 2) == 0) return false;\n  return true;\n}\nstring int_to_hex(int a) {\n  if (a == 0) return \"0\";\n  string ans;\n  while (a) {\n    int k = a % 16;\n    if (k <= 9) {\n      ans += ('0' + k);\n    } else {\n      ans += ('A' + (k - 10));\n    }\n    a /= 16;\n  }\n  reverse(ans.begin(), ans.end());\n  return ans;\n}\nlong long int ncrr(long long int a, long long int b) {\n  long long int ans = 1;\n  if (b > a / 2) {\n    b = a - b;\n  }\n  for (int i = 0; i < b; i++) {\n    ans *= a;\n    a--;\n    ans %= 1000000007;\n  }\n  for (int i = 1; i <= b; i++) {\n    ans *= (modInverse(i, 1000000007));\n    ans %= 1000000007;\n  }\n  return ans;\n}\nvoid init_code() {}\nclass KMP {\n public:\n  vector<int> LPS(string s) {\n    int n = s.size();\n    vector<int> lps(n, 0);\n    int len = 0;\n    int i = 1;\n    while (i < n) {\n      if (s[i] == s[len]) {\n        lps[i++] = ++len;\n      } else {\n        if (len != 0) {\n          len = lps[len - 1];\n        } else {\n          lps[i++] = 0;\n        }\n      }\n    }\n    return lps;\n  }\n  vector<int> match(string A, string B) {\n    auto lps = LPS(B);\n    vector<int> ans;\n    int n = A.size();\n    int m = B.size();\n    int i = 0;\n    int j = 0;\n    while (i < n) {\n      if (A[i] == B[j]) {\n        i++;\n        j++;\n      }\n      if (j == m) {\n        ans.push_back(i - j);\n        j = lps[j - 1];\n      } else if (i < n && A[i] != B[j]) {\n        if (j == 0)\n          i++;\n        else\n          j = lps[j - 1];\n      }\n    }\n    return ans;\n  }\n};\nclass fast_segtree {\n public:\n  static const long long int N = 2e5 + 15;\n  long long int n = N;\n  long long int t[2 * N];\n  void build() {\n    for (long long int i = n - 1; i > 0; --i) t[i] = t[i << 1] + t[i << 1 | 1];\n  }\n  void modify(long long int p, long long int value) {\n    for (t[p += n] += value; p > 1; p >>= 1) t[p >> 1] = t[p] + t[p ^ 1];\n  }\n  long long int query(long long int l, long long int r) {\n    long long int res = 0;\n    for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if (l & 1) res += t[l++];\n      if (r & 1) res += t[--r];\n    }\n    return res;\n  }\n  fast_segtree(vector<long long int> &A) {\n    n = A.size();\n    for (long long int i = 0; i < A.size(); i++) t[i + n] = A[i];\n    build();\n  };\n  fast_segtree(long long int n1) {\n    n = n1;\n    for (long long int i = 0; i < n; i++) t[i + n] = 0;\n    build();\n  };\n};\nclass segtree {\n public:\n  vector<long long int> A;\n  long long int n;\n  segtree(long long int n1) {\n    n = n1;\n    A.clear();\n    A.resize(4 * n + 5);\n  };\n  void sett(long long int id, long long int s, long long int e,\n            long long int idx, long long int val) {\n    if (idx < s || idx > e) return;\n    A[id] += val;\n    if (s == e) return;\n    long long int mid = (s + e) / 2;\n    sett(2 * id, s, mid, idx, val);\n    sett(2 * id + 1, mid + 1, e, idx, val);\n  }\n  long long int gett(long long int id, long long int s, long long int e,\n                     long long int l, long long int r) {\n    if (s >= l && e <= r) return A[id];\n    if (min(e, r) < max(s, l)) return 0;\n    long long int mid = (s + e) / 2;\n    long long int ans = 0;\n    ans += gett(2 * id, s, mid, l, r);\n    ans += gett(2 * id + 1, mid + 1, e, l, r);\n    return ans;\n  }\n  void sett(long long int id, long long int val) { sett(1, 0, n - 1, id, val); }\n  long long int gett(long long int l, long long int r) {\n    return gett(1, 0, n - 1, l, r - 1);\n  }\n};\nvector<long long int> djikstra(int sr, vector<vector<pair<int, int>>> &gr) {\n  int n = gr.size();\n  vector<long long int> ans(n, 1e15);\n  priority_queue<pair<int, int>> pq;\n  pq.push({0, sr});\n  while (pq.size()) {\n    auto top = pq.top();\n    pq.pop();\n    int id = top.second;\n    int val = -top.second;\n    if (ans[id] > val) {\n      ans[id] = val;\n      for (int j = 0; j < gr[id].size(); j++) {\n        long long int new_dis = -val - gr[id][j].second;\n        int des = gr[id][j].first;\n        if (ans[des] > -new_dis) {\n          pq.push({new_dis, des});\n        }\n      }\n    }\n  }\n  return ans;\n}\nclass union_find {\n public:\n  const int max_sz = 2e5 + 5;\n  vector<int> rank;\n  vector<int> parent;\n  union_find(int n) {\n    rank.resize(n);\n    parent = rank;\n    for (int i = 0; i < n; i++) {\n      parent[i] = i;\n    }\n  };\n  int find(int i) {\n    if (parent[i] == i) return i;\n    return find(parent[i]);\n  }\n  int connect(int i, int j) {\n    int a = find(i);\n    int b = find(j);\n    if (a == b) return -1;\n    if (rank[a] < rank[b]) swap(a, b);\n    parent[b] = a;\n    if (rank[a] == rank[b]) rank[a]++;\n    return 0;\n  }\n};\nconst int max_sz = 2e5 + 5;\nvector<set<int>> gr, gr1;\nvector<int> vis;\nvector<int> vis1;\nbool cyc = 0;\nvoid dfs1(int i) {\n  if (vis[i] == 1) cyc = 1;\n  if (vis[i] == 2 || cyc) return;\n  vis[i] = 1;\n  int maxa = -1;\n  for (int j : gr[i]) {\n    dfs1(j);\n    maxa = max(maxa, j);\n  }\n  if (maxa < i) {\n    vis1[i] = 1;\n  }\n  vis[i] = 2;\n}\nvoid help() {\n  int n;\n  cin >> n;\n  gr.clear();\n  gr1.clear();\n  vis.clear();\n  vis1.clear();\n  gr.resize(n);\n  gr1 = gr;\n  vis.resize(n);\n  vis1.resize(n);\n  cyc = 0;\n  vector<int> out(n);\n  for (int i = 0; i < n; i++) {\n    int k;\n    cin >> k;\n    out[i] = k;\n    for (int j = 0; j < k; j++) {\n      int a;\n      cin >> a;\n      a--;\n      gr[i].insert(a);\n      gr1[a].insert(i);\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    dfs1(i);\n  }\n  if (cyc) {\n    cout << -1 << endl;\n    return;\n  }\n  int ans = 0;\n  queue<int> q;\n  for (int i = 0; i < n; i++) {\n    if (out[i] == 0) {\n      q.push(i);\n    }\n  }\n  vector<int> maxas(n, -1);\n  for (int i = 0; i < n; i++) {\n    if (gr[i].size()) maxas[i] = *(gr[i].rbegin());\n  }\n  while (q.size()) {\n    vector<int> t;\n    ans++;\n    set<int> s1;\n    while (q.size()) {\n      auto top = q.front();\n      q.pop();\n      for (int j : gr1[top]) {\n        out[j]--;\n        if (out[j] == 0 && maxas[j] < j) {\n          q.push(j);\n        } else if (out[j] == 0) {\n          t.push_back(j);\n        }\n        gr[j].erase(top);\n        s1.insert(j);\n      }\n    }\n    for (int k : s1) {\n      if (out[k] == 0)\n        maxas[k] = -1;\n      else\n        maxas[k] = *(gr[k].rbegin());\n    }\n    for (int k : t) {\n      q.push(k);\n    }\n  }\n  cout << ans << endl;\n}\nint main() {\n  init_code();\n  int t = 1;\n  cin >> t;\n  for (int i = 1; i <= t; i++) {\n    help();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\nint n;\nvector<int> adj[N];\nint ind[N];\nint dp[N];\nint main() {\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) {\n      adj[i].clear();\n      ind[i] = dp[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n      int k;\n      scanf(\"%d\", &k);\n      for (int j = 1; j <= k; j++) {\n        int ai;\n        scanf(\"%d\", &ai);\n        adj[ai].push_back(i);\n        ind[i]++;\n      }\n    }\n    int vis = 0;\n    queue<int> q;\n    for (int i = 1; i <= n; i++) {\n      if (ind[i] == 0) {\n        q.push(i);\n        vis++;\n      }\n    }\n    while (!q.empty()) {\n      int node = q.front();\n      q.pop();\n      for (auto it : adj[node]) {\n        ind[it]--;\n        if (node < it) {\n          dp[it] = max(dp[it], dp[node]);\n        } else {\n          dp[it] = max(dp[it], dp[node] + 1);\n        }\n        if (ind[it] == 0) {\n          q.push(it);\n          vis++;\n        }\n      }\n    }\n    if (vis != n) {\n      printf(\"-1\\n\");\n      continue;\n    }\n    printf(\"%d\\n\", *max_element(dp + 1, dp + n + 1) + 1);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint T, n, tot, ans, num;\nconst int maxn = 1e6 + 10;\nint d[maxn], head[maxn], v[maxn], Next[maxn], dp[maxn];\npriority_queue<int, vector<int>, greater<int> > q;\nvoid init() {\n  num = n;\n  tot = 0;\n  ans = 1;\n  for (int i = 1; i <= n; i++) head[i] = d[i] = 0, dp[i] = 1;\n}\nvoid add(int x, int y) {\n  v[++tot] = y;\n  Next[tot] = head[x];\n  head[x] = tot;\n}\nvoid bfs() {\n  while (q.size()) {\n    int x = q.top();\n    q.pop();\n    num--;\n    ans = max(ans, dp[x]);\n    for (int i = head[x]; i; i = Next[i]) {\n      int y = v[i];\n      d[y]--;\n      if (y < x)\n        dp[y] = max(dp[y], dp[x] + 1);\n      else\n        dp[y] = max(dp[y], dp[x]);\n      if (!d[y]) {\n        q.push(y);\n      }\n    }\n  }\n}\nint main() {\n  scanf(\"%d\", &T);\n  while (T--) {\n    scanf(\"%d\", &n);\n    init();\n    for (int i = 1; i <= n; i++) {\n      int len;\n      scanf(\"%d\", &len);\n      for (int j = 1; j <= len; j++) {\n        int t;\n        scanf(\"%d\", &t);\n        add(t, i);\n        d[i]++;\n      }\n    }\n    for (int i = 1; i <= n; i++) {\n      if (!d[i]) q.push(i);\n    }\n    bfs();\n    if (num)\n      printf(\"-1\\n\");\n    else\n      printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "/**\n * check out my youtube channel sh0rkyboy\n * https://tinyurl.com/zdxe2y4z\n * I do screencasts, solutions, and other fun stuff in the future\n */\n\nimport java.util.*;\nimport java.io.*;\nimport static java.lang.Math.min;\nimport static java.lang.Math.abs;\nimport static java.lang.Math.max;\npublic class EdA {\n\tstatic long[] mods = {1000000007, 998244353, 1000000009};\n\tstatic long mod = mods[0];\n\tpublic static MyScanner sc;\n    public static PrintWriter out;\n    static ArrayList<ArrayList<Integer>> graph;\n\tpublic static void main(String[] largewang) throws Exception{\n\t\t// TODO Auto-generated method stub\n \t\tsc = new MyScanner();\n \t\tout = new PrintWriter(System.out);\n \t\tint t = sc.nextInt();\n \t\twhile (t-->0) {\n \t\t\tint n = sc.nextInt();\n \t\t\tint[] indegree = new int[n+1];\n \t\t\tint[] max = new int[n+1];\n \t\t\tgraph = new ArrayList<>();\n \t\t\tfor(int j = 0 ;j<=n;j++){\n \t\t\t\tgraph.add(new ArrayList<>());\n \t\t\t}\n \t\t\tfor(int j =1;j<=n;j++){\n \t\t\t\tint k = sc.nextInt();\n \t\t\t\tfor(int i=0;i<k;i++){\n \t\t\t\t\tgraph.get(sc.nextInt()).add(j);\n \t\t\t\t\tindegree[j] ++;\n \t\t\t\t}\n \t\t\t}\n \t\t\tQueue<Integer> topsort = new LinkedList<Integer>();\n\t \t\tboolean found = true;\n\t \t\tfor(int j = 1;j<=n;j++){\n\t \t\t\tif (indegree[j] == 0){\n\t \t\t\t\ttopsort.add(j);\n\t \t\t\t\tmax[j] = 1;\n\t \t\t\t\tfound = false;\n\t \t\t\t}\n\t \t\t}\n\t \t\tif (found){\n\t \t\t\tout.println(-1);\n\t \t\t}\n\t \t\telse{\n\t \t\t\tArrayList<Integer> answer = new ArrayList<Integer>();\n\t \t\t\twhile(!topsort.isEmpty()){\n\t \t\t\t\tint vertex = topsort.remove();\n\t \t\t\t\tfor(int j : graph.get(vertex)){\n\t \t\t\t\t\tindegree[j]--;\n\t \t\t\t\t\tif (j > vertex) {\n\t \t\t\t\t\t\tmax[j] = max(max[j], max[vertex]);\n\t \t\t\t\t\t} else {\n\t \t\t\t\t\t\tmax[j] = max(max[j], max[vertex] + 1);\n\t \t\t\t\t\t}\n\t \t\t\t\t\tif (indegree[j] == 0)\n\t \t\t\t\t\t\ttopsort.add(j);\n\t \t\t\t\t}\n\t \t\t\t\tanswer.add(vertex);\n\t \t\t\t}\n\t \t\t\tif (answer.size() != n){\n\t \t\t\t\tout.println(-1);\n\t \t\t\t} else {\n\t \t\t\t\tint m = 0;\n\t \t\t\t\tfor(int j : max) {\n\t \t\t\t\t\tm =max(m, j);\n\t \t\t\t\t}\n\t \t\t\t\tout.println(m);\n\t \t\t\t}\n\t \t\t}\n \t\t}\n \t\tout.close();\n \t\t\n \t}\n\t\n\tpublic static void sort(int[] array){\n\t\tArrayList<Integer> copy = new ArrayList<>();\n\t\tfor (int i : array)\n\t\t\tcopy.add(i);\n\t\tCollections.sort(copy);\n\t\tfor(int i = 0;i<array.length;i++)\n\t\t\tarray[i] = copy.get(i);\n\t}\n\tstatic String[] readArrayString(int n){\n\t\tString[] array = new String[n];\n\t\tfor(int j =0 ;j<n;j++)\n\t\t\tarray[j] = sc.next();\n\t\treturn array;\n\t}\n\tstatic int[] readArrayInt(int n){\n    \tint[] array = new int[n];\n    \tfor(int j = 0;j<n;j++)\n    \t\tarray[j] = sc.nextInt();\n    \treturn array;\n    }\n\tstatic int[] readArrayInt1(int n){\n\t\tint[] array = new int[n+1];\n\t\tfor(int j = 1;j<=n;j++){\n\t\t\tarray[j] = sc.nextInt();\n\t\t}\n\t\treturn array;\n\t}\n\tstatic long[] readArrayLong(int n){\n\t\tlong[] array = new long[n];\n\t\tfor(int j =0 ;j<n;j++)\n\t\t\tarray[j] = sc.nextLong();\n\t\treturn array;\n\t}\n\tstatic double[] readArrayDouble(int n){\n\t\tdouble[] array = new double[n];\n\t\tfor(int j =0 ;j<n;j++)\n\t\t\tarray[j] = sc.nextDouble();\n\t\treturn array;\n\t}\n\tstatic int minIndex(int[] array){\n\t\tint minValue = Integer.MAX_VALUE;\n\t\tint minIndex = -1;\n\t\tfor(int j = 0;j<array.length;j++){\n\t\t\tif (array[j] < minValue){\n\t\t\t\tminValue = array[j];\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\tstatic int minIndex(long[] array){\n\t\tlong minValue = Long.MAX_VALUE;\n\t\tint minIndex = -1;\n\t\tfor(int j = 0;j<array.length;j++){\n\t\t\tif (array[j] < minValue){\n\t\t\t\tminValue = array[j];\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\tstatic int minIndex(double[] array){\n\t\tdouble minValue = Double.MAX_VALUE;\n\t\tint minIndex = -1;\n\t\tfor(int j = 0;j<array.length;j++){\n\t\t\tif (array[j] < minValue){\n\t\t\t\tminValue = array[j];\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\tstatic long power(long x, long y){\n\t\tif (y == 0)\n\t\t\treturn 1;\n\t\tif (y%2 == 1)\n\t\t\treturn (x*power(x, y-1))%mod;\n\t\treturn power((x*x)%mod, y/2)%mod;\n\t}\n\tstatic void verdict(boolean a){\n        out.println(a ? \"YES\" : \"NO\");\n    }\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } \n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        String nextLine() {\n            String str = \"\";\n            try{\n                str = br.readLine();\n            } \n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        \n    }\t\n}\n\n//StringJoiner sj = new StringJoiner(\" \"); \n//sj.add(strings)\n//sj.toString() gives string of those stuff w spaces or whatever that sequence is"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nvoid solve() {\n  ll n;\n  cin >> n;\n  vector<vector<ll>> adj(n);\n  for (ll i = 0; i < n; i++) {\n    ll k;\n    cin >> k;\n    for (ll j = 0; j < k; j++) {\n      ll x;\n      cin >> x;\n      x--;\n      adj[x].push_back(i);\n    }\n  }\n  vector<ll> vis(n, 0);\n  bool isCycle = false;\n  function<void(ll)> dfs = [&](ll v) {\n    vis[v] = 1;\n    for (auto x : adj[v]) {\n      if (vis[x] == 1)\n        isCycle = true;\n      else if (!vis[x])\n        dfs(x);\n    }\n    vis[v] = 2;\n  };\n  for (ll i = 0; i < n; i++) {\n    if (!vis[i]) dfs(i);\n  }\n  if (isCycle) {\n    cout << \"-1\"\n         << \"\\n\";\n    return;\n  }\n  ll res = 0;\n  vector<ll> dp(n, -1);\n  function<ll(ll)> rec = [&](ll v) {\n    if (dp[v] != -1) return dp[v];\n    ll ans = 0;\n    for (auto x : adj[v]) {\n      if (x > v)\n        ans = max(ans, rec(x));\n      else\n        ans = max(ans, rec(x) + 1);\n    }\n    return dp[v] = ans;\n  };\n  for (ll i = 0; i < n; i++) res = max(res, rec(i));\n  cout << res + 1 << \"\\n\";\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int _t = 1;\n  cin >> _t;\n  for (int i = 1; i <= _t; i++) {\n    solve();\n  }\n  {};\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool checked[200005];\nbool dfs(vector<long long int> graph[], long long int node, bool visited[]) {\n  if (visited[node] == true) return false;\n  visited[node] = true;\n  checked[node] = true;\n  for (auto i : graph[node]) {\n    if (dfs(graph, i, visited) == false) return false;\n  }\n  visited[node] = false;\n  return true;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long int x24e;\n  cin >> x24e;\n  while (x24e--) {\n    long long int n;\n    cin >> n;\n    vector<long long int> graph[n];\n    for (long long int i = 0; i < n; i++) {\n      long long int size;\n      cin >> size;\n      while (size--) {\n        long long int x;\n        cin >> x;\n        x--;\n        graph[x].push_back(i);\n      }\n    }\n    bool visited[n];\n    memset(visited, false, sizeof visited);\n    memset(checked, false, sizeof checked);\n    long long int indeg[n];\n    memset(indeg, 0, sizeof indeg);\n    for (long long int i = 0; i < n; i++) {\n      for (auto j : graph[i]) indeg[j]++;\n    }\n    queue<pair<long long int, long long int>> q;\n    long long int count = 0;\n    for (long long int i = 0; i < n; i++) {\n      if (indeg[i] == 0) {\n        q.push({i, 1});\n        count++;\n      }\n    }\n    vector<long long int> order(n, 1);\n    long long int maxi = 1;\n    while (!q.empty()) {\n      auto top = q.front();\n      q.pop();\n      maxi = max(maxi, top.second);\n      for (auto i : graph[top.first]) {\n        indeg[i]--;\n        if (i > top.first)\n          order[i] = max(order[i], top.second);\n        else\n          order[i] = max(order[i], top.second + 1);\n        if (indeg[i] == 0) {\n          q.push({i, order[i]});\n          count++;\n        }\n      }\n    }\n    if (count != n)\n      cout << \"-1\\n\";\n    else\n      cout << *max_element(order.begin(), order.end()) << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class C_Book{\n    public static void main(String[] args) {\n        FastScanner s= new FastScanner();\n        StringBuilder res = new StringBuilder();\n        int t=s.nextInt();\n        int p=0;\n        while(p<t){\n        int n=s.nextInt();\n        int array[]= new int[n+1];\n        ArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>();\n        for(int i=0;i<=n;i++){\n            ArrayList<Integer> obj = new  ArrayList<Integer>();\n            list.add(obj);\n        }\n        for(int i=1;i<=n;i++){\n            int a=s.nextInt();\n            array[i]=a;\n            for(int j=0;j<a;j++){\n                int num=s.nextInt();\n                list.get(num).add(i);\n            }\n        }\n        HashMap<Integer,ArrayList<Integer>> map = new  HashMap<Integer,ArrayList<Integer>>();\n        for(int i=0;i<=n;i++){\n            ArrayList<Integer> obj = new  ArrayList<Integer>();\n            map.put(i,obj);\n        }\n        long ans[]= new long[1];\n        ans[0]=1;\n        \n        int visited[]= new int[n+1];\n        for(int i=1;i<=n;i++){\n            if(array[i]==0 && visited[i]==0){\n                dfs(list,i,array,visited,ans,1,map);\n            }\n        }\n        int flag=0;\n        for(int i=1;i<=n;i++){\n            if(array[i]!=0){\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0){\n            \n            res.append(ans[0]+\"\\n\");\n        }\n        else{\n            res.append(\"-1\\n\");\n        }\n        p++;\n    }\n    System.out.println(res);\n    }\n    private static void dfs(ArrayList<ArrayList<Integer>> list, int i, int[] array, int[] visited, long[] ans,int alpha,HashMap<Integer,ArrayList<Integer>> map) {\n        map.get(i).add(alpha);      \n        if(array[i]!=0){\n                    return;\n                }\n                int check=0;\n                visited[i]=1;\n                for(int j=0;j<list.get(i).size();j++){\n                    int num=list.get(i).get(j);\n                    if(array[num]!=0){\n                    array[num]--;\n                    if(num<i){\n                        check=1;\n                    }\n                }\n                }\n                ArrayList<Integer> nice = map.get(i);\n                Collections.sort(nice,Collections.reverseOrder());\n                alpha=nice.get(0);\n\n                if(check==1 && ans[0]==alpha){\n                    ans[0]++;\n                }\n                for(int j=0;j<list.get(i).size();j++){\n                    int num=list.get(i).get(j);\n                    if(visited[num]==0 && num>i){\n                        dfs(list,num,array,visited,ans,alpha,map);\n                    }\n                    else if(visited[num]==0 && num<i){\n                        dfs(list,num,array,visited,ans,alpha+1,map);\n                    }\n                }\n\n\n\n\n    }\n    static class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n \n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(s));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n \n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n \n\t\tString nextToken() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n \n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n \n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n \n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\t}\n\n\n\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long MOD = 1000000007;\nvoid err(istream_iterator<string> it) {}\ntemplate <typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args) {\n  cerr << *it << \" = \" << a << endl;\n  err(++it, args...);\n}\nvoid Solve() {\n  long long n, k;\n  cin >> n;\n  vector<long long> understood(n + 1, 0);\n  vector<long long> indegree(n + 1, 0);\n  vector<vector<int>> adj(n + 1);\n  priority_queue<pair<int, int>> next;\n  for (int i = 1; i <= n; i++) {\n    cin >> indegree[i];\n    if (indegree[i] == 0) {\n      next.push({-1, -i});\n    }\n    for (int j = 0; j < indegree[i]; j++) {\n      cin >> k;\n      adj[k].push_back(i);\n    }\n  }\n  while (!next.empty()) {\n    auto xoros = next.top();\n    next.pop();\n    understood[-xoros.second] = xoros.first;\n    for (int y : adj[-xoros.second]) {\n      indegree[y]--;\n      if (indegree[y] == 0) {\n        if (y > -xoros.second) {\n          next.push({xoros.first, -y});\n        } else {\n          next.push({xoros.first - 1, -y});\n        }\n      }\n    }\n  }\n  long long ans = 0;\n  for (int i = 1; i <= n; i++) {\n    if (understood[i] == 0) {\n      cout << -1 << \"\\n\";\n      return;\n    }\n    ans = max(ans, -understood[i]);\n  }\n  cout << ans << \"\\n\";\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  long long ntest;\n  cin >> ntest;\n  for (long long i = 0; i < ntest; i++) {\n    Solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n, k;\n    cin >> n;\n    set<int> adj[n + 1];\n    set<pair<int, int>> s;\n    int i, j, v;\n    vector<int> vec[n + 1];\n    for (i = 1; i <= n; i++) {\n      cin >> k;\n      for (j = 1; j <= k; j++) {\n        cin >> v;\n        vec[v].push_back(i);\n        adj[i].insert(v);\n      }\n      s.insert(make_pair(k, i));\n    }\n    int ans = 0, pre;\n    pair<int, int> p, p2;\n    for (i = 1; i <= n; i++) {\n      p = *s.begin();\n      ans++;\n      if (p.first > 0) break;\n      while (!s.empty()) {\n        if (s.lower_bound(p) == s.end()) break;\n        p = *s.lower_bound(p);\n        if (p.first > 0) break;\n        for (auto x : vec[p.second]) {\n          s.erase(make_pair(adj[x].size(), x));\n          adj[x].erase(p.second);\n          s.insert(make_pair(adj[x].size(), x));\n        }\n        s.erase(p);\n      }\n      if (s.empty()) break;\n    }\n    if (s.empty())\n      cout << ans << \"\\n\";\n    else\n      cout << \"-1\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid _print(bool t) { cerr << t; }\nvoid _print(int t) { cerr << t; }\nvoid _print(string t) { cerr << t; }\nvoid _print(char t) { cerr << t; }\nvoid _print(double t) { cerr << t; }\ntemplate <class T, class V>\nvoid _print(pair<T, V> p) {\n  cerr << \"{\";\n  _print(p.first);\n  cerr << \", \";\n  _print(p.second);\n  cerr << \"}\";\n}\ntemplate <class T>\nvoid _print(set<T> v) {\n  cerr << \"[  \";\n  for (T i : v) {\n    _print(i);\n    cerr << \"  \";\n  }\n  cerr << \"]\\n\";\n}\ntemplate <class T>\nvoid _print(vector<T> v) {\n  cerr << \"[  \";\n  for (T i : v) {\n    _print(i);\n    cerr << \"  \";\n  }\n  cerr << \"]\\n\";\n}\ntemplate <class T>\nvoid _print(multiset<T> v) {\n  cerr << \"[  \";\n  for (T i : v) {\n    _print(i);\n    cerr << \"  \";\n  }\n  cerr << \"]\\n\";\n}\ntemplate <class T, class V>\nvoid _print(map<T, V> v) {\n  cerr << \"[  \";\n  for (auto i : v) {\n    _print(i);\n    cerr << \"  \";\n  }\n  cerr << \"]\\n\";\n}\ntemplate <class T>\nvoid _print(T v[], int n) {\n  cerr << \"[  \";\n  for (int i = 0; i < n; i++) {\n    _print(v[i]);\n    cerr << \"  \";\n  }\n  cerr << \"]\\n\";\n}\nconst int MAX = 2e5 + 10;\nvector<int> adj[MAX];\nint ans[MAX], vis[MAX], rec[MAX];\nbool cycle = false;\nvoid solve(int u) {\n  vis[u] = true;\n  rec[u] = true;\n  int mx1 = 0, mx2 = 0;\n  for (int v : adj[u]) {\n    if (!vis[v])\n      solve(v);\n    else if (rec[v])\n      cycle = true;\n    if (v > u)\n      mx2 = max(mx2, ans[v]);\n    else\n      mx1 = max(mx1, ans[v]);\n  }\n  rec[u] = false;\n  if (adj[u].size() == 0) {\n    ans[u] = 1;\n    return;\n  }\n  if (mx2 > 0) {\n    ans[u] = max(mx1, mx2 + 1);\n  } else {\n    ans[u] = mx1;\n  }\n}\nvoid run() {\n  int n;\n  cin >> n;\n  for (int i = 0; i <= n; i++) {\n    adj[i].clear();\n    ans[i] = -1;\n    cycle = false;\n    vis[i] = false;\n    rec[i] = false;\n  }\n  for (int i = 0; i < n; i++) {\n    int k;\n    cin >> k;\n    for (int j = 0; j < k; j++) {\n      int v;\n      cin >> v;\n      v--;\n      adj[i].push_back(v);\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (!vis[i]) solve(i);\n  }\n  if (cycle)\n    cout << -1 << '\\n';\n  else\n    cout << *max_element(ans, ans + n) << '\\n';\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0), cout.tie();\n  int t;\n  cin >> t;\n  for (int tc = 1; tc <= t; tc++) {\n    run();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse4\")\nusing namespace std;\ntemplate <typename T>\nvoid etch(T V) {\n  for (auto x : V) cout << x << ' ';\n  cout << '\\n';\n}\nvector<string> vec_splitter(string s) {\n  s += ',';\n  vector<string> res;\n  while (!s.empty()) {\n    res.push_back(s.substr(0, s.find(',')));\n    s = s.substr(s.find(',') + 1);\n  }\n  return res;\n}\nvoid debug_out(vector<string> __attribute__((unused)) args,\n               __attribute__((unused)) long long int idx,\n               __attribute__((unused)) long long int LINE_NUM) {\n  cerr << endl;\n}\ntemplate <typename Head, typename... Tail>\nvoid debug_out(vector<string> args, long long int idx, long long int LINE_NUM,\n               Head H, Tail... T) {\n  if (idx > 0)\n    cerr << \", \";\n  else\n    cerr << \"Line(\" << LINE_NUM << \") \";\n  stringstream ss;\n  ss << H;\n  cerr << args[idx] << \" = \" << ss.str();\n  debug_out(args, idx + 1, LINE_NUM, T...);\n}\nconst long long int MOD = 1e9 + 7;\nconst long long int MOD1 = 998244353;\nconst long long int N = 2e5 + 5;\nconst long long int INF = 1000111000111000111LL;\nconst long double EPS = 1e-12;\nconst long double PI = 3.141592653589793116;\nvoid solve() {\n  long long int n;\n  cin >> n;\n  vector<long long int> g[n];\n  vector<long long int> ind(n, 0), dp(n, 0), vis(n, 0);\n  for (long long int i = (0); i < (n); i++) {\n    long long int k;\n    cin >> k;\n    ind[i] = 0;\n    for (long long int j = (0); j < (k); j++) {\n      long long int x;\n      cin >> x;\n      x--;\n      g[x].push_back(i);\n      ind[i]++;\n    }\n  }\n  queue<long long int> Q;\n  for (long long int i = (0); i < (n); i++) {\n    if (ind[i] == 0) {\n      Q.push(i);\n      vis[i] = 1;\n    }\n  }\n  while (not Q.empty()) {\n    long long int node = Q.front();\n    Q.pop();\n    for (auto it : g[node]) {\n      ind[it]--;\n      if (node < it) {\n        dp[it] = max(dp[it], dp[node]);\n      } else {\n        dp[it] = max(dp[it], dp[node] + 1);\n      }\n      if (ind[it] == 0) {\n        Q.push(it);\n        vis[it] = 1;\n      }\n    }\n  }\n  if (*min_element((vis).begin(), (vis).end()) != 1) {\n    cout << \"-1\\n\";\n    return;\n  }\n  cout << *max_element((dp).begin(), (dp).end()) + 1 << '\\n';\n}\nint32_t main() {\n  std::ios_base::sync_with_stdio(0);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long int T;\n  cin >> T;\n  while (T--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import os, sys\nfrom io import BytesIO, IOBase\nimport operator as op\nfrom bisect import *\nfrom itertools import chain, repeat, starmap\nfrom functools import reduce\n\n\nclass SortedList():\n    \"\"\"Sorted list is a sorted mutable sequence.\"\"\"\n    DEFAULT_LOAD_FACTOR = 500\n\n    def __init__(self, iterable=None):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        self._len = 0\n        self._load = self.DEFAULT_LOAD_FACTOR\n        self._lists = []\n        self._maxes = []\n        self._index = []\n        self._offset = 0\n        if iterable is not None:\n            self.update(iterable)\n\n    def clear(self):\n        \"\"\"Remove all values from sorted list.\"\"\"\n        self._len = 0\n        del self._lists[:]\n        del self._maxes[:]\n        del self._index[:]\n        self._offset = 0\n\n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\"\"\"\n        _lists = self._lists\n        _maxes = self._maxes\n        if _maxes:\n            pos = bisect_right(_maxes, value)\n            if pos == len(_maxes):\n                _lists[pos - 1].append(value)\n                _maxes[pos - 1] = value\n            else:\n                insort(_lists[pos], value)\n            self._expand(pos)\n        else:\n            _lists.append([value])\n            _maxes.append(value)\n        self._len += 1\n\n    def _expand(self, pos):\n        \"\"\"Split sublists with length greater than double the load-factor.\"\"\"\n        _load = self._load\n        _lists = self._lists\n        _index = self._index\n\n        if len(_lists[pos]) > (_load << 1):\n            _maxes = self._maxes\n            _lists_pos = _lists[pos]\n            half = _lists_pos[_load:]\n            del _lists_pos[_load:]\n            _maxes[pos] = _lists_pos[-1]\n            _lists.insert(pos + 1, half)\n            _maxes.insert(pos + 1, half[-1])\n            del _index[:]\n        else:\n            if _index:\n                child = self._offset + pos\n                while child:\n                    _index[child] += 1\n                    child = (child - 1) >> 1\n                _index[0] += 1\n\n    def update(self, iterable):\n        \"\"\"Update sorted list by adding all values from `iterable`.\"\"\"\n        _lists = self._lists\n        _maxes = self._maxes\n        values = sorted(iterable)\n\n        if _maxes:\n            if len(values) * 4 >= self._len:\n                values.extend(chain.from_iterable(_lists))\n                values.sort()\n                self.clear()\n            else:\n                _add = self.add\n                for val in values:\n                    _add(val)\n                return\n\n        _load = self._load\n        _lists.extend(values[pos:(pos + _load)] for pos in range(0, len(values), _load))\n        _maxes.extend(sublist[-1] for sublist in _lists)\n        self._len = len(values)\n        del self._index[:]\n\n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n        _maxes = self._maxes\n        pos = bisect_left(_maxes, value)\n        if pos == len(_maxes):\n            return False\n\n        _lists = self._lists\n        idx = bisect_left(_lists[pos], value)\n        return _lists[pos][idx] == value\n\n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n        _maxes = self._maxes\n        pos = bisect_left(_maxes, value)\n        if pos == len(_maxes):\n            return\n\n        _lists = self._lists\n        idx = bisect_left(_lists[pos], value)\n        if _lists[pos][idx] == value:\n            self._delete(pos, idx)\n\n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        _maxes = self._maxes\n        _index = self._index\n\n        _lists_pos = _lists[pos]\n        del _lists_pos[idx]\n        self._len -= 1\n\n        len_lists_pos = len(_lists_pos)\n        if len_lists_pos > (self._load >> 1):\n            _maxes[pos] = _lists_pos[-1]\n\n            if _index:\n                child = self._offset + pos\n                while child > 0:\n                    _index[child] -= 1\n                    child = (child - 1) >> 1\n                _index[0] -= 1\n        elif len(_lists) > 1:\n            if not pos:\n                pos += 1\n            prev = pos - 1\n            _lists[prev].extend(_lists[pos])\n            _maxes[prev] = _lists[prev][-1]\n            del _lists[pos]\n            del _maxes[pos]\n            del _index[:]\n            self._expand(prev)\n        elif len_lists_pos:\n            _maxes[pos] = _lists_pos[-1]\n        else:\n            del _lists[pos]\n            del _maxes[pos]\n            del _index[:]\n\n    def _loc(self, pos, idx):\n        \"\"\"Convert an index pair (lists index, sublist index) into a single\n        index number that corresponds to the position of the value in the\n        sorted list.\"\"\"\n        if not pos:\n            return idx\n\n        _index = self._index\n        if not _index:\n            self._build_index()\n        total = 0\n        pos += self._offset\n        while pos:\n            if not pos & 1:\n                total += _index[pos - 1]\n            pos = (pos - 1) >> 1\n        return total + idx\n\n    def _pos(self, idx):\n        \"\"\"Convert an index into an index pair (lists index, sublist index)\n        that can be used to access the corresponding lists position.\"\"\"\n        if idx < 0:\n            last_len = len(self._lists[-1])\n            if (-idx) <= last_len:\n                return len(self._lists) - 1, last_len + idx\n            idx += self._len\n            if idx < 0:\n                raise IndexError('list index out of range')\n        elif idx >= self._len:\n            raise IndexError('list index out of range')\n\n        if idx < len(self._lists[0]):\n            return 0, idx\n\n        _index = self._index\n        if not _index:\n            self._build_index()\n\n        pos = 0\n        child = 1\n        len_index = len(_index)\n        while child < len_index:\n            index_child = _index[child]\n            if idx < index_child:\n                pos = child\n            else:\n                idx -= index_child\n                pos = child + 1\n            child = (pos << 1) + 1\n        return (pos - self._offset, idx)\n\n    def _build_index(self):\n        \"\"\"Build a positional index for indexing the sorted list.\"\"\"\n        row0 = list(map(len, self._lists))\n        if len(row0) == 1:\n            self._index[:] = row0\n            self._offset = 0\n            return\n\n        head = iter(row0)\n        tail = iter(head)\n        row1 = list(starmap(op.add, zip(head, tail)))\n        if len(row0) & 1:\n            row1.append(row0[-1])\n        if len(row1) == 1:\n            self._index[:] = row1 + row0\n            self._offset = 1\n            return\n\n        size = 1 << (len(row1) - 1).bit_length()\n        row1.extend(repeat(0, size - len(row1)))\n        tree = [row0, row1]\n        while len(tree[-1]) > 1:\n            head = iter(tree[-1])\n            tail = iter(head)\n            row = list(starmap(op.add, zip(head, tail)))\n            tree.append(row)\n        reduce(list.__iadd__, reversed(tree), self._index)\n        self._offset = size * 2 - 1\n\n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        if isinstance(index, slice):\n            start, stop, step = index.indices(self._len)\n            if step == 1 and start < stop:\n                if start == 0 and stop == self._len:\n                    return self.clear()\n                elif self._len <= 8 * (stop - start):\n                    values = self.__getitem__(slice(None, start))\n                    if stop < self._len:\n                        values += self.__getitem__(slice(stop, None))\n                    self.clear()\n                    return self.update(values)\n\n            indices = range(start, stop, step)\n            if step > 0:\n                indices = reversed(indices)\n            _pos, _delete = self._pos, self._delete\n            for index in indices:\n                pos, idx = _pos(index)\n                _delete(pos, idx)\n        else:\n            pos, idx = self._pos(index)\n            self._delete(pos, idx)\n\n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        _lists = self._lists\n\n        if isinstance(index, slice):\n            start, stop, step = index.indices(self._len)\n\n            if step == 1 and start < stop:\n                if start == 0 and stop == self._len:\n                    return reduce(list.__iadd__, self._lists, [])\n\n                start_pos, start_idx = self._pos(start)\n                if stop == self._len:\n                    stop_pos = len(_lists) - 1\n                    stop_idx = len(_lists[stop_pos])\n                else:\n                    stop_pos, stop_idx = self._pos(stop)\n                if start_pos == stop_pos:\n                    return _lists[start_pos][start_idx:stop_idx]\n\n                prefix = _lists[start_pos][start_idx:]\n                middle = _lists[(start_pos + 1):stop_pos]\n                result = reduce(list.__iadd__, middle, prefix)\n                result += _lists[stop_pos][:stop_idx]\n                return result\n\n            if step == -1 and start > stop:\n                result = self.__getitem__(slice(stop + 1, start + 1))\n                result.reverse()\n                return result\n\n            indices = range(start, stop, step)\n            return list(self.__getitem__(index) for index in indices)\n        else:\n            if self._len:\n                if index == 0:\n                    return _lists[0][0]\n                elif index == -1:\n                    return _lists[-1][-1]\n            else:\n                raise IndexError('list index out of range')\n\n            if 0 <= index < len(_lists[0]):\n                return _lists[0][index]\n\n            len_last = len(_lists[-1])\n            if -len_last < index < 0:\n                return _lists[-1][len_last + index]\n\n            pos, idx = self._pos(index)\n            return _lists[pos][idx]\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return chain.from_iterable(self._lists)\n\n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return chain.from_iterable(map(reversed, reversed(self._lists)))\n\n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n\n    def bisect_left(self, value):\n        \"\"\"Return an index to insert `value` in the sorted list.\"\"\"\n        pos = bisect_left(self._maxes, value)\n        return self._len if pos == len(self._maxes) else self._loc(pos, bisect_left(self._lists[pos], value))\n\n    def bisect_right(self, value):\n        \"\"\"Return an index to insert `value` in the sorted list.\"\"\"\n        pos = bisect_right(self._maxes, value)\n        return self._len if pos == len(self._maxes) else self._loc(pos, bisect_right(self._lists[pos], value))\n\n    bisect = bisect_right\n\n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n        _maxes = self._maxes\n        if not _maxes:\n            return 0\n\n        pos_left = bisect_left(_maxes, value)\n        if pos_left == len(_maxes):\n            return 0\n\n        _lists = self._lists\n        idx_left = bisect_left(_lists[pos_left], value)\n        pos_right = bisect_right(_maxes, value)\n        if pos_right == len(_maxes):\n            return self._len - self._loc(pos_left, idx_left)\n\n        idx_right = bisect_right(_lists[pos_right], value)\n        if pos_left == pos_right:\n            return idx_right - idx_left\n\n        right = self._loc(pos_right, idx_right)\n        left = self._loc(pos_left, idx_left)\n        return right - left\n\n    def copy(self):\n        \"\"\"Return a shallow copy of the sorted list.\"\"\"\n        return self.__class__(self)\n\n    __copy__ = copy\n\n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n        if not self._len:\n            raise IndexError('pop index out of range')\n\n        _lists = self._lists\n        if 0 <= index < len(_lists[0]):\n            val = _lists[0][index]\n            self._delete(0, index)\n            return val\n\n        len_last = len(_lists[-1])\n        if -len_last < index < 0:\n            pos = len(_lists) - 1\n            loc = len_last + index\n            val = _lists[pos][loc]\n            self._delete(pos, loc)\n            return val\n\n        pos, idx = self._pos(index)\n        val = _lists[pos][idx]\n        self._delete(pos, idx)\n        return val\n\n    def index(self, value, start=0, stop=None):\n        \"\"\"Return first index of value in sorted list.\"\"\"\n        _len = self._len\n        if start < 0:\n            start += _len\n        if start < 0:\n            start = 0\n        if stop is None:\n            stop = _len\n        if stop < 0:\n            stop += _len\n        if stop > _len:\n            stop = _len\n\n        if stop <= start:\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        _maxes = self._maxes\n        pos_left = bisect_left(_maxes, value)\n        if pos_left == len(_maxes):\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        _lists = self._lists\n        idx_left = bisect_left(_lists[pos_left], value)\n        if _lists[pos_left][idx_left] != value:\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        stop -= 1\n        left = self._loc(pos_left, idx_left)\n        if start <= left:\n            if left <= stop:\n                return left\n        else:\n            if start <= self.bisect_right(value) - 1:\n                return start\n        raise ValueError('{0!r} is not in list'.format(value))\n\n    def __add__(self, other):\n        \"\"\"Return new sorted list containing all values in both sequences.\"\"\"\n        values = reduce(list.__iadd__, self._lists, [])\n        values.extend(other)\n        return self.__class__(values)\n\n    __radd__ = __add__\n\n    def __iadd__(self, other):\n        \"\"\"Update sorted list with values from `other`.\"\"\"\n        self.update(other)\n        return self\n\n    def __mul__(self, num):\n        \"\"\"Return new sorted list with `num` shallow copies of values.\"\"\"\n        values = reduce(list.__iadd__, self._lists, []) * num\n        return self.__class__(values)\n\n    __rmul__ = __mul__\n\n    def __imul__(self, num):\n        \"\"\"Update the sorted list with `num` shallow copies of values.\"\"\"\n        values = reduce(list.__iadd__, self._lists, []) * num\n        self.clear()\n        self.update(values)\n        return self\n\n    def __make_cmp(seq_op):\n        \"Make comparator method.\"\n\n        def comparer(self, other):\n            \"Compare method for sorted list and sequence.\"\n            self_len = self._len\n            len_other = len(other)\n            if self_len != len_other:\n                if seq_op is op.eq:\n                    return False\n                if seq_op is op.ne:\n                    return True\n\n            for alpha, beta in zip(self, other):\n                if alpha != beta:\n                    return seq_op(alpha, beta)\n            return seq_op(self_len, len_other)\n\n        comparer.__name__ = '__{0}__'.format(seq_op.__name__)\n        return comparer\n\n    __eq__ = __make_cmp(op.eq)\n    __ne__ = __make_cmp(op.ne)\n    __lt__ = __make_cmp(op.lt)\n    __gt__ = __make_cmp(op.gt)\n    __le__ = __make_cmp(op.le)\n    __ge__ = __make_cmp(op.ge)\n    __make_cmp = staticmethod(__make_cmp)\n\n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return 'SortedList({0})'.format(reduce(list.__iadd__, self._lists, []))\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\ninp = lambda dtype: [dtype(x) for x in input().split()]\ninp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]\ninp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]\ninp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]\ninp_enus = lambda dtype, n: [[i] + inp(dtype) for i in range(n)]\nceil1 = lambda a, b: (a + b - 1) // b\n\n\nclass graph:\n    def __init__(self, n):\n        self.n, self.gdict = n, [[] for _ in range(n + 1)]\n        self.indeg, self.outdeg = [0] * (n + 1), [0] * (n + 1)\n\n    def addEdge(self, node1, node2, w=None):\n        self.gdict[node1].append(node2)\n        self.outdeg[node1] += 1\n        self.indeg[node2] += 1\n\n    def kahn(self, n):\n        # enqueue all node with 0 in degree\n        queue, ans, lst = SortedList([i for i in range(1, n + 1) if not self.indeg[i]] + [10 ** 9]), 1, -1\n        cnt = 0\n\n        while len(queue) > 1:\n            # pop and push into topsort\n            ix = queue.bisect_right(lst)\n\n            if queue[ix] == 10 ** 9:\n                ix = 0\n                ans += 1\n\n            lst = s = queue.pop(ix)\n\n            for i in self.gdict[s]:\n                self.indeg[i] -= 1\n                if not self.indeg[i]:\n                    queue.add(i)\n\n            cnt += 1\n        # check cycle\n        print(-1 if cnt != n else ans)\n\n\nfor _ in range(int(input())):\n    n = int(input())\n    g = graph(n)\n\n    for i in range(n):\n        for x in inp(int)[1:]:\n            g.addEdge(x, i + 1)\n    g.kahn(n)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 10;\nstruct node {\n  bool friend operator<(node n1, node n2) {\n    if (n1.val == n2.val) {\n      return n1.id > n2.id;\n    } else {\n      return n1.val > n2.val;\n    }\n  }\n  int id, val;\n};\npriority_queue<node> que;\nvector<int> pre[maxn];\nint degree[maxn];\nint n;\nint solve() {\n  node cur, tmp;\n  int i, res, cnt, u, v;\n  while (!que.empty()) {\n    que.pop();\n  }\n  res = 0, cnt = 0;\n  for (i = 1; i <= n; i++) {\n    if (degree[i] == 0) {\n      tmp.id = i, tmp.val = 1;\n      que.push(tmp);\n      res = max(res, tmp.val), cnt++;\n    }\n  }\n  while (!que.empty()) {\n    cur = que.top();\n    que.pop();\n    u = cur.id;\n    for (i = 0; i < pre[u].size(); i++) {\n      v = pre[u][i];\n      degree[v]--;\n      if (degree[v] == 0) {\n        tmp.id = v;\n        if (v < u)\n          tmp.val = cur.val + 1;\n        else\n          tmp.val = cur.val;\n        que.push(tmp);\n        res = max(res, tmp.val), cnt++;\n      }\n    }\n  }\n  if (cnt < n)\n    return -1;\n  else\n    return res;\n}\nint main() {\n  int t, i, j, k;\n  scanf(\"%d\", &t);\n  while (t--) {\n    scanf(\"%d\", &n);\n    for (i = 1; i <= n; i++) {\n      pre[i].clear();\n      degree[i] = 0;\n    }\n    for (i = 1; i <= n; i++) {\n      scanf(\"%d\", &k);\n      while (k--) {\n        scanf(\"%d\", &j);\n        pre[j].push_back(i);\n        degree[i]++;\n      }\n    }\n    printf(\"%d\\n\", solve());\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/env python3\n# from typing import *\n\nimport sys\nimport io\nimport math\nimport collections\nimport decimal\nimport itertools\nimport bisect\nimport heapq\n\n\ndef input():\n    return sys.stdin.readline()[:-1]\n\n\n# sys.setrecursionlimit(1000000)\n\n# _INPUT = \"\"\"5\n# 4\n# 1 2\n# 0\n# 2 1 4\n# 1 2\n# 5\n# 1 5\n# 1 1\n# 1 2\n# 1 3\n# 1 4\n# 5\n# 0\n# 0\n# 2 1 2\n# 1 2\n# 2 2 1\n# 4\n# 2 2 3\n# 0\n# 0\n# 2 3 2\n# 5\n# 1 2\n# 1 3\n# 1 4\n# 1 5\n# 0\n\n# \"\"\"\n# sys.stdin = io.StringIO(_INPUT)\n\nINF = 10**10\n\n\nclass TopologicalSort:\n    def __init__(self, G) -> None:\n        n = len(G)\n        self.G = G\n        in_degree = [0] * n\n        for i in range(n):\n            for j in G[i]:\n                in_degree[j] += 1\n        hq1 = []\n        hq2 = [p for p in range(n) if in_degree[p] == 0]\n        heapq.heapify(hq1)\n        heapq.heapify(hq2)\n        self.Tp = []\n        while hq1 or hq2:\n            if hq2:\n                p = heapq.heappop(hq2)\n                if self.Tp and self.Tp[-1] > p:\n                    hq1.append(p)\n                    continue\n            else:\n                p = heapq.heappop(hq1)\n                hq2 = list(hq1)\n                heapq.heapify(hq2)\n                hq1 = []\n            self.Tp.append(p)\n            for p1 in G[p]:\n                if in_degree[p1] > 0:\n                    in_degree[p1] -= 1\n                    if in_degree[p1] == 0:\n                        if p < p1:\n                            heapq.heappush(hq2, p1)\n                        else:\n                            heapq.heappush(hq1, p1)\n\n    def contains_cycle(self) -> bool:\n        return (len(self.Tp) != len(self.G))\n\ndef solve(N, G):\n    tps = TopologicalSort(G)\n    if tps.contains_cycle():\n        return -1\n\n    n = 1\n    for i in range(N-1):\n        if tps.Tp[i] > tps.Tp[i+1]:\n            n += 1\n    return n\n\nT0 = int(input())\nfor _ in range(T0):\n    N = int(input())\n    G = [list() for _ in range(N)]\n    for i in range(N):\n        dat = list(map(int, input().split()))\n        for j in dat[1:]:\n            G[j-1].append(i)\n    print(solve(N, G))"
        },
        {
            "language": 4,
            "solution": "/*\n    Author : Akshat Jindal\n    from NIT Jalandhar , Punjab , India\n    JAI MATA DI\n */\nimport java.util.*;\n\nimport javax.swing.text.Segment;\n\n\nimport java.io.*;\nimport java.math.*;\nimport java.sql.Array;\n\n\n\npublic class Main {\n\t  static class FR{\n\t\t  \n\t\t\tBufferedReader br;\n\t\t\tStringTokenizer st;\n\t\t\tpublic FR() {\n\t\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t}\n\t\t\tString next() \n\t\t    { \n\t\t        while (st == null || !st.hasMoreElements()) \n\t\t        { \n\t\t            try\n\t\t            { \n\t\t                st = new StringTokenizer(br.readLine()); \n\t\t            } \n\t\t            catch (IOException  e) \n\t\t            { \n\t\t                e.printStackTrace(); \n\t\t            } \n\t\t        } \n\t\t        return st.nextToken(); \n\t\t    } \n\n\t\t    int nextInt() \n\t\t    { \n\t\t        return Integer.parseInt(next()); \n\t\t    } \n\n\t\t    long nextLong() \n\t\t    { \n\t\t        return Long.parseLong(next()); \n\t\t    } \n\n\t\t    double nextDouble() \n\t\t    { \n\t\t        return Double.parseDouble(next()); \n\t\t    } \n\n\t\t    String nextLine() \n\t\t    { \n\t\t        String str = \"\"; \n\t\t        try\n\t\t        { \n\t\t            str = br.readLine(); \n\t\t        } \n\t\t        catch (IOException e) \n\t\t        { \n\t\t            e.printStackTrace(); \n\t\t        } \n\t\t        return str; \n\t\t    } \n\t\t}\n\t \n\t  static long mod = (long)(1e9 + 7);\n\t \n\tstatic void sort(long[] arr ) {\n\t\t ArrayList<Long> al = new ArrayList<>();\n\t\t for(long e:arr) al.add(e);\n\t\t Collections.sort(al);\n\t\t for(int i = 0 ; i<al.size(); i++) arr[i] = al.get(i);\n\t }\n\tstatic void sort(int[] arr ) {\n\t\t ArrayList<Integer> al = new ArrayList<>();\n\t\t for(int e:arr) al.add(e);\n\t\t Collections.sort(al);\n\t\t for(int i = 0 ; i<al.size(); i++) arr[i] = al.get(i);\n\t }\n\tstatic void sort(char[] arr) {\n\t\tArrayList<Character> al = new ArrayList<Character>();\n\t\tfor(char cc:arr) al.add(cc);\n\t\tCollections.sort(al);\n\t\tfor(int i = 0 ;i<arr.length ;i++) arr[i] = al.get(i);\n\t}\n\tstatic void rvrs(int[] arr) {\n\t\tint i =0 , j = arr.length-1;\n\t\twhile(i>=j) {\n\t\t\tint temp = arr[i];\n\t\t\tarr[i] = arr[j];\n\t\t\tarr[j] = temp;\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t}\n\tstatic void rvrs(long[] arr) {\n\t\tint i =0 , j = arr.length-1;\n\t\twhile(i>=j) {\n\t\t\tlong temp = arr[i];\n\t\t\tarr[i] = arr[j];\n\t\t\tarr[j] = temp;\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t}\n\n\tstatic long mod_mul(long a , long b ,long mod) {\n\t\treturn ((a%mod)*(b%mod))%mod;\n\t}\n\t static long gcd(long a, long b)\n\t  {      \n\t     if (b == 0)\n\t        return a;\n\t     return gcd(b, a % b); \n\t  }\n\t static boolean[] prime(int num) {\n\t\t\tboolean[] bool = new boolean[num];\n\t\t     \n\t\t      for (int i = 0; i< bool.length; i++) {\n\t\t         bool[i] = true;\n\t\t      }\n\t\t      for (int i = 2; i< Math.sqrt(num); i++) {\n\t\t         if(bool[i] == true) {\n\t\t            for(int j = (i*i); j<num; j = j+i) {\n\t\t               bool[j] = false;\n\t\t            }\n\t\t         }\n\t\t      }\n\t\t      if(num >= 0) {\n\t\t    \t  bool[0] = false;\n\t\t    \t  bool[1] = false;\n\t\t      }\n\t\t      \n\t\t      return bool;\n\t\t}\n\n\t static long modInverse(long a, long m)\n\t    {\n\t        long g = gcd(a, m);\n\t       \n\t          return   power(a, m - 2, m);\n\t        \n\t    }\n\t   \n\t static long power(long x, long y, long m){\n\t        if (y == 0) return 1; long p = power(x, y / 2, m) % m; p = (int)((p * (long)p) % m);\n\t        if (y % 2 == 0) return p; else return (int)((x * (long)p) % m); }\n\t   \n     static class Combinations{\n\t    \t private long[] z;\n\t    \t private long[] z1;\n\t    \t private long[] z2;\n\t    \t  public Combinations(long N , long mod) {\n\t\t\t\tz = new long[(int)N+1];\n\t\t\t\tz1 = new long[(int)N+1];\n\t\t\t\tz[0] = 1;\n\t\t\t\tfor(int i =1 ; i<=N ; i++) z[i] = (z[i-1]*i)%mod;\n\t\t\t     z2 = new long[(int)N+1];\n\t\t\t\tz2[0] = z2[1] = 1;\n\t\t\t    for (int i = 2; i <= N; i++)\n\t\t\t        z2[i] = z2[(int)(mod % i)] * (mod - mod / i) % mod;\n\t\t\t    \n\t\t\t    \n\t\t\t    z1[0] = z1[1] = 1;\n\t\t\t    \n\t\t\t    for (int i = 2; i <= N; i++)\n\t\t\t        z1[i] = (z2[i] * z1[i - 1]) % mod;\n\t\t\t}\n\t    \t  long fac(long n) {\n\t    \t\t  return z[(int)n];\n\t    \t  }\n\t    \t  long invrsNum(long n) {\n\t    \t\t  return z2[(int)n];\n\t    \t  }\n\t    \t  long invrsFac(long n) {\n\t    \t\t  return invrsFac((int)n);\n\t    \t  }\n\t    \t  long ncr(long N, long R, long mod)\n\t    \t  {\t\tif(R<0 || R>N ) return 0;\n\t    \t\t    long ans = ((z[(int)N] * z1[(int)R])\n\t    \t\t              % mod * z1[(int)(N - R)])\n\t    \t\t             % mod;\n\t    \t\t    return ans;\n\t    \t\t}\n\t      }\n\t      static class DisjointUnionSets {\n\t\t\t    int[] rank, parent;\n\t\t\t    int n;\n\t\t\t  \n\t\t\t    public DisjointUnionSets(int n)\n\t\t\t    {\n\t\t\t        rank = new int[n];\n\t\t\t        parent = new int[n];\n\t\t\t        this.n = n;\n\t\t\t        makeSet();\n\t\t\t    }\n\t\t\t  \n\t\t\t    void makeSet()\n\t\t\t    {\n\t\t\t        for (int i = 0; i < n; i++) {\n\t\t\t          \n\t\t\t            parent[i] = i;\n\t\t\t        }\n\t\t\t    }\n\t\t\t  \n\t\t\t    int find(int x)\n\t\t\t    {\n\t\t\t        if (parent[x] != x) {\n\t\t\t        \n\t\t\t            parent[x] = find(parent[x]);\n\t\t\t  \n\t\t\t        }\n\t\t\t  \n\t\t\t        return parent[x];\n\t\t\t    }\n\t\t\t  \n\t\t\t    void union(int x, int y)\n\t\t\t    {\n\t\t\t        int xRoot = find(x), yRoot = find(y);\n\t\t\t  \n\t\t\t        if (xRoot == yRoot)\n\t\t\t            return;\n\t\t\t  \n\t\t\t        if (rank[xRoot] < rank[yRoot])\n\t\t\t  \n\t\t\t            parent[xRoot] = yRoot;\n\t\t\t  \n\t\t\t        else if (rank[yRoot] < rank[xRoot])\n\t\t\t  \n\t\t\t            parent[yRoot] = xRoot;\n\t\t\t  \n\t\t\t        else\n\t\t\t        {\n\t\t\t            parent[yRoot] = xRoot;\n\t\t\t  \n\t\t\t            rank[xRoot] = rank[xRoot] + 1;\n\t\t\t        }\n\t\t\t    }\n\t\t\t}\n\t      static int[] KMP(String str) {\n\t    \t  int n = str.length();\n\t    \t  int[] kmp = new int[n];\n\t    \t  for(int i = 1 ; i<n ; i++) {\n\t    \t\t  int j = kmp[i-1];\n\t    \t\t  while(j>0 && str.charAt(i) != str.charAt(j)) {\n\t    \t\t\t  j = kmp[j-1];\n\t    \t\t  }\n\t    \t\t  if(str.charAt(i) == str.charAt(j)) j++;\n\t    \t\t  kmp[i] = j;\n\t    \t  }\n\t    \t  \n\t    \t  return kmp;\n\t      }\n\t      \n\t      \n/************************************************ Query **************************************************************************************/\t  \n\t \n/***************************************** \t\tSparse Table\t********************************************************/\n\t      static class SparseTable{\n\t    \t\t\n\t    \t\tprivate long[][] st;\n\t    \t\t\n\t    \t\tSparseTable(long[] arr){\n\t    \t\t\tint n = arr.length;\n\t    \t\t\tst = new long[n][25];\n\t    \t\t\tlog = new int[n+2];\n\t    \t\t\tbuild_log(n+1);\n\t    \t\t\tbuild(arr);\n\t    \t\t}\n\t    \t\t\n\t    \t\tprivate void build(long[] arr) {\n\t    \t\t\tint n = arr.length;\n\t    \t\t\t\n\t    \t\t\tfor(int i = n-1 ; i>=0 ; i--) {\n\t    \t\t\t\tfor(int j = 0 ; j<25 ; j++) {\n\t    \t\t\t\t\tint r = i + (1<<j)-1;\n\t    \t\t\t\t\tif(r>=n) break;\n\t    \t\t\t\t\tif(j == 0 ) st[i][j] = arr[i];\n\t    \t\t\t\t\telse st[i][j] = Math.min(st[i][j-1] , st[ i + ( 1 << (j-1) ) ][ j-1 ] );\n\t    \t\t\t\t}\n\t    \t\t\t}\n\t    \t\t}\n\t    \t\tpublic long gcd(long a  ,long b) {\n\t    \t\t\tif(a == 0) return b;\n\t    \t\t\treturn gcd(b%a , a);\n\t    \t\t}\n\t    \t\tpublic long query(int l ,int r) {\n\t    \t\t\tint w = r-l+1;\n\t    \t\t\tint power = log[w];\n\t    \t\t\treturn Math.min(st[l][power],st[r - (1<<power) + 1][power]);\n\t    \t\t}\n\t    \t\tprivate int[] log;\n\t    \t\tvoid build_log(int n) {\n\t    \t\t\tlog[1] = 0;\n\t    \t\t\tfor(int i = 2 ; i<=n ; i++) {\n\t    \t\t\t\tlog[i] = 1 + log[i/2];\n\t    \t\t\t}\n\t    \t\t}\n\t    \t}\n\t      \n\t      \n/********************************************************\tSegement Tree\t*****************************************************/\n/**\n\t \t static class SegmentTree{\n\t\t\t long[] tree;\n\t\t\t long[] arr;\n\t\t\t int n;\n\t\t\t SegmentTree(long[] arr){\n\t\t\t\t this.n = arr.length;\n\t\t\t\t tree = new long[4*n+1];\n\t\t\t\t this.arr = arr;\n\t\t\t\t buildTree(0, n-1, 1);\n\t\t\t }\n\t\t\t \n\t\t\t \n\t\t\t  void buildTree(int s ,int e  ,int index ) {\n\t\t\t\t\tif(s == e) {\n\t\t\t\t\t\ttree[index] = arr[s];\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tint mid = (s+e)/2;\n\t\t\t\t\t\n\t\t\t\t\tbuildTree( s,  mid, 2*index);\n\t\t\t\t\tbuildTree( mid+1, e, 2*index+1);\n\t\t\t\t\t\n\t\t\t\t\ttree[index] = Math.min(tree[2*index] , tree[2*index+1]);\n\t\t\t\t}\n\t\t\t  \n\t\t\t long query(int si ,int ei) {\n\t\t\t\t return query(0 ,n-1 , si ,ei , 1   );\n\t\t\t }\n\t\t\t private long query( int ss ,int se ,int qs , int qe,int index) {\n\t\t\t\t\t\n\t\t\t\t\tif(ss>=qs && se<=qe) return tree[index];\n\t\t\t\t\t\n\t\t\t\t\tif(qe<ss || se<qs) return (long)(1e17);\n\t\t\t\t\t\n\t\t\t\t\tint mid = (ss + se)/2;\n\t\t\t\t\tlong left = query( ss , mid , qs ,qe , 2*index);\n\t\t\t\t\tlong right= query(mid + 1 , se , qs ,qe , 2*index+1);\n\t\t\t\t\treturn Math.min(left, right);\n\t\t\t\t}\n\t\t\t public void update(int index , int val) {\n\t\t\t\t arr[index] = val;\n\t\t\t\t for(long e:arr) System.out.print(e+\" \");\n\t\t\t\t update(index , 0 , n-1 , 1);\n\t\t\t }\n\t\t\t private void update(int id ,int si , int ei , int index) {\n\t\t\t\t if(id < si || id>ei) return;\n\t\t\t\t if(si == ei ) { \n\t\t\t\t\t tree[index] = arr[id];\n\t\t\t\t\t return;\n\t\t\t\t }\n\t\t\t\t if(si > ei) return;\n\t\t\t\t int mid = (ei + si)/2;\n\t\t\t\t\t\n\t\t\t\t\tupdate( id,  si, mid , 2*index);\n\t\t\t\t\tupdate( id , mid+1, ei , 2*index+1);\n\t\t\t\t\t\n\t\t\t\t\ttree[index] = Math.min(tree[2*index] ,tree[2*index+1]);\n\t\t\t }\n\t\t\t  \n\t\t }\n\t\t */\n\n/* ***************************************************************************************************************************************************/\t \n\t \n\t      static FR sc = new FR();\n\t static StringBuilder sb = new StringBuilder();\n\t public static void main(String args[]) throws IOException {\n\t\n\t\t int tc = 1;\n\t\t  tc = sc.nextInt();\n\t\t \n\t\t for(int i = 1 ; i<=tc ; i++) {\n\n//\t\t\t sb.append(\"Case #\" + i + \": \"  );\n\t\t\t TEST_CASE();\n\t\t\t \n\t\t }\n\t\t System.out.println(sb);\n\t }\n\t static void TEST_CASE() {\n\t\t int n = sc.nextInt();\n\t\t adj = new ArrayList<>();\n\t\t for(int i =0 ; i<n ; i++) {\n\t\t\t adj.add(new ArrayList<>());\n\t\t }\n\t\t for(int i =0 ; i<n ; i++) {\n\t\t\t int c = sc.nextInt();\n\t\t\t while(c -- >0) {\n\t\t\t\t int v = sc.nextInt() - 1;\n\t\t\t\t adj.get(i).add(v);\n\t\t\t }\n\t\t }\n\t\t boolean[] visit = new boolean[n];\n\t\t boolean[] cycle = new boolean[n];\n\t\t for(int i =0 ; i<n ; i++) {\n\t\t\t if(visit[i]) continue;\n\t\t\t if(fnc(i, visit, cycle)) {\n\t\t\t\t sb.append(\"-1\\n\");\n\t\t\t\t return;\n\t\t\t }\n\t\t }\n\t\tdp = new int[n];\n\t\tfor(int i =0 ; i <n ; i++) {\n\t\t\tif(dp[i] != 0 ) continue;\n\t\t\tdfs(i);\n\t\t}\n\t\tint max = 1;\n\t\tfor(int e:dp) max = Math.max(max, e);\n\t\tsb.append(max+\"\\n\");\n\t }\n\t static ArrayList<ArrayList<Integer>> adj;\n\t static int[] dp;\n\t \n\t static void dfs(int u) {\n\t\t if(dp[u] != 0) return;\n\t\t int max = 1;\n\t\t for(int v:adj.get(u)) {\n\t\t\t dfs(v);\n\t\t\t if(v < u) max = Math.max(max, dp[v]);\n\t\t\t else max = Math.max(max, dp[v]+1);\n\t\t }\n\t\t dp[u] = max;\n\t }\n\t static boolean fnc(int u ,boolean[] visit , boolean[] cycle) {\n\t\t if(cycle[u]) return true;\n\t\t if(visit[u] ) return false;\n\t\t visit[u] = true;\n\t\t cycle[u] = true;\n\t\t for(int v:adj.get(u)) {\n\t\t\t if(fnc(v, visit, cycle))\n\t\t\t\t return true;\n\t\t }\n\t\t cycle[u] = false;\n\t\t return false;\n\t }\n\t \n}\n\n\n\n\n\n/*******************************************************************************************************************************************************/\n\n/**\n \n \n \n */\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class CoderB {\n\n  static StringBuffer str=new StringBuffer();\n  static List<List<Integer>> l;\n  static List<List<Integer>> rl;\n  static int n;\n  static boolean vis1[];\n  static boolean rec[];\n  static int ind[];\n  static boolean vis[];\n  static List<Integer> topo;\n\n  static boolean cycle(int v){\n    if(rec[v]) return true;\n    if(vis1[v]) return false;\n    vis1[v]=true;\n    rec[v]=true;\n    for(int u:l.get(v)){\n      if(cycle(u)) return true;\n    }\n    return rec[v]=false;\n  }\n  static void solve(){\n    vis1=new boolean[n+1];\n    rec=new boolean[n+1];\n    for(int i=1;i<=n;i++){\n      if(cycle(i)){\n        str.append(\"-1\\n\");\n        return;\n      }\n    }\n    \n    vis=new boolean[n+1];\n    topo=new ArrayList<>();\n    Queue<Integer> q=new LinkedList<>();\n    for(int i=1;i<=n;i++) if(ind[i]==0) q.add(i);\n    while(!q.isEmpty()){\n      int u=q.remove();\n      topo.add(u);\n      vis[u]=true;\n      for(int v:l.get(u)){\n        if(--ind[v]==0){\n          q.add(v);\n        }\n      }\n    }\n\n    int dp[]=new int[n+1];\n    Arrays.fill(dp, 1);\n    int ans=1;\n    for(int u:topo){\n      for(int v:rl.get(u)){\n        if(v<u) dp[u]=Math.max(dp[v], dp[u]);\n        else dp[u]=Math.max(dp[v]+1, dp[u]);\n      }\n      ans=Math.max(ans, dp[u]);\n    }\n    str.append(ans).append(\"\\n\");\n  }\n  \n  public static void main(String[] args) throws java.lang.Exception {\n    BufferedReader bf;\n    PrintWriter pw;\n    boolean lenv=false;\n    if(lenv){\n      bf = new BufferedReader(\n                          new FileReader(\"input.txt\"));\n      pw=new PrintWriter(new\n            BufferedWriter(new FileWriter(\"output.txt\")));\n    }else{\n      bf = new BufferedReader(new InputStreamReader(System.in));\n      pw = new PrintWriter(new OutputStreamWriter(System.out));\n    }\n\n    int q = Integer.parseInt(bf.readLine().trim());\n    while (q-- > 0) {\n       l=new ArrayList<>();\n       rl=new ArrayList<>();\n\n       n=Integer.parseInt(bf.readLine().trim());\n       ind=new int[n+1];\n       for(int i=0;i<=n;i++){l.add(new ArrayList<>());rl.add(new ArrayList<>());}\n        boolean zero=false;\n       for(int i=1;i<=n;i++){\n        String s[]=bf.readLine().trim().split(\"\\\\s+\");\n        int k=Integer.parseInt(s[0]);\n        if(k==0) zero=true;\n        for(int j=1;j<=k;j++){\n          int x=Integer.parseInt(s[j]);\n          rl.get(i).add(x);\n          l.get(x).add(i);\n          ind[i]++;\n        }\n       }\n       \n       if(n==1){\n        str.append(\"1\\n\");\n        continue;\n       }\n       if(!zero){\n        str.append(\"-1\\n\");\n        continue;\n       }\n       solve();\n    }\n    pw.print(str);\n    pw.flush();\n    // System.out.print(str);\n  }\n}"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\nimport java.sql.Array;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        BufferedReader cin = new BufferedReader(new InputStreamReader(System.in));\n        try{\n            String line = cin.readLine();\n            int t=Integer.parseInt(line);\n            while(t-- > 0){\n                line = cin.readLine();\n                int n = Integer.parseInt(line);\n                List<List<Integer>> adj = new ArrayList<>();\n                for(int i=0;i<n;i++)adj.add(new ArrayList<Integer>());\n                int[] in = new int[n];\n                Queue<Integer>Q = new LinkedList<>();\n                int[] need = new int[n];\n                for(int i=0;i<n;i++){\n                    line = cin.readLine();\n                    String[] S = line.split(\" \");\n                    int m = Integer.parseInt(S[0]);\n                    int[] a = new int[m];\n                    for(int j=1;j<S.length;j++){\n                        adj.get(Integer.parseInt(S[j])-1).add(i);\n                    }\n                    in[i] = m;\n                    if(in[i] == 0)Q.add(i);\n                }\n                while(!Q.isEmpty()){\n                    int x = Q.poll();\n                    for(Integer p:adj.get(x)){\n                        if(p>x)need[p]=Math.max(need[p],need[x]);\n                        else need[p]=Math.max(need[p],need[x]+1);\n                        in[p]--;\n                        if(in[p]==0)Q.add(p);\n                    }\n                }\n                int ret=0;\n                boolean bad = false;\n                for(int i=0;i<n;i++){\n                    ret=Math.max(ret,need[i]);\n                    if(in[i]!=0)bad=true;\n                }\n                if(bad)System.out.println(-1);\n                else System.out.println(ret+1);\n            }\n        }catch(Exception e){\n\n        }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\nimport java.math.BigInteger;\n\nimport java.io.*;\n\npublic class Main implements Runnable {\n\n    public static void main(String[] args) {\n        new Thread(null, new Main(), \"whatever\", 1 << 26).start();\n    }\n\n\n    private FastScanner sc;\n    private PrintWriter pw;\n\n    public void run() {\n        try {\n            // pw = new PrintWriter(new BufferedWriter(new FileWriter(\"output.txt\")));\n            // sc = new FastScanner(new BufferedReader(new FileReader(\"input.txt\")));\n            pw = new PrintWriter(System.out);\n            sc = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\n        } catch (Exception e) {\n            throw new RuntimeException();\n        }\n        int t = sc.nextInt();\n        // int t = 1;\n        while (t-- > 0) {\n            // sc.nextLine();\n            solve();\n        }\n        pw.close();\n    }\n\n    public long mod = 998244353;\n    public long mod2 = 1_000_000_007;\n\n    public class Chapter {\n        int number;\n        int size;\n        boolean done;\n        ArrayList<Chapter> list;\n\n        public Chapter() {\n            // this.number = number;\n            // this.size = size;\n            this.done = false;\n            list = new ArrayList<>();\n        }\n\n        public void addToList(Chapter ch) {\n            list.add(ch);\n        }\n\n        public boolean isDone() {\n            return done;\n        }\n\n        private void check(TreeSet<Integer> set) {\n            // pw.println(\"INSIDE for \" + this.number);\n            Chapter ch;\n            // System.out.println(list.size());\n            for (int i = 0; i < list.size(); i++) {\n                ch = list.get(i);\n                // pw.println(\"Checking \" + ch.number);\n                ch.size--;\n                if (ch.size == 0) {\n                    // pw.println(\"Adding \" + ch.number + \" to set\");\n                    set.add(ch.number);\n                    ch.done = true;\n                }\n            }\n        }\n    }\n    public TreeSet<Integer> set;\n    public void solve() {\n        set = new TreeSet<>();\n        int n = sc.nextInt();\n\n        Chapter[] arr = new Chapter[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = new Chapter();\n            arr[i].number = i;\n        }\n        int temp, temp2;\n        boolean found = false;\n        for (int i = 0; i < n; i++) {\n            temp = sc.nextInt();\n            arr[i].size = temp;\n            if (temp == 0) {\n                set.add(i);\n                arr[i].done = true;\n            }\n            for (int j = 0; j < temp; j++) {\n                temp2 = sc.nextInt() - 1;\n                arr[temp2].addToList(arr[i]);\n            }\n        }\n\n\n        pw.println(solver(arr, n));\n    }\n\n    public int solver(Chapter[] arr, int n) {\n        int j = 0;\n        while (!set.isEmpty()) {\n            int q = -1;\n            while (set.higher(q) != null) {\n                q = set.higher(q);\n                arr[q].check(set);\n                set.remove(q);\n            }\n            j++;\n        }\n        for (int i = 0; i < n; i++) if (!arr[i].done) return -1;\n        return j;\n    }\n\n\n    class FastScanner {\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public FastScanner(BufferedReader bf) {\n            reader = bf;\n            tokenizer = null;\n        }\n\n        public String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public float nextFloat() {\n            return Float.parseFloat(next());\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        public String[] nextStringArray(int n) {\n            String[] a = new String[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = next();\n            }\n            return a;\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextLong();\n            }\n            return a;\n        }\n\n    }\n\n    public long fastPow(long x, long y, long mod) {\n        if (y == 0) return 1;\n        if (y == 1) return x % mod;\n\n        long temp = fastPow(x, y / 2, mod);\n        long ans = (temp * temp) % mod;\n\n        return (y % 2 == 1) ? (ans * (x % mod)) % mod : ans;\n    }\n\n    // public long fastPow(long x, long y) {\n    //     if (y == 0) return 1;\n    //     if (y == 1) return x;\n\n    //     long temp = fastPow(x, y / 2);\n    //     long ans = (temp * temp);\n\n    //     return (y % 2 == 1) ? (ans * x) : ans;\n    // }\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class C {\n    public static class UnionFind {\n        int[] p, rank, setSize;\n        int numSets;\n\n        public UnionFind(int N) {\n            p = new int[numSets = N];\n            rank = new int[N];\n            setSize = new int[N];\n            for (int i = 0; i < N; i++) {\n                p[i] = i;\n                setSize[i] = 1;\n            }\n        }\n\n        public int findSet(int i) {\n            return p[i] == i ? i : (p[i] = findSet(p[i]));\n        }\n\n        public boolean isSameSet(int i, int j) {\n            return findSet(i) == findSet(j);\n        }\n\n        public void unionSet(int i, int j) {\n            if (isSameSet(i, j))\n                return;\n            numSets--;\n            int x = findSet(i), y = findSet(j);\n            if (rank[x] > rank[y]) {\n                p[y] = x;\n                setSize[x] += setSize[y];\n            } else {\n                p[x] = y;\n                setSize[y] += setSize[x];\n                if (rank[x] == rank[y]) rank[y]++;\n            }\n        }\n\n        public int numDisjointSets() {\n            return numSets;\n        }\n\n        public int sizeOfSet(int i) {\n            return setSize[findSet(i)];\n        }\n    }\n\n    static int[][] arr;\n    static int n;\n    static ArrayList<Integer>[] adjL;\n\n    public static boolean isCyclicUtil(int i, boolean[] visited,\n                                       boolean[] recStack) {\n        if (recStack[i])\n            return true;\n\n        if (visited[i])\n            return false;\n\n        visited[i] = true;\n\n        recStack[i] = true;\n        List<Integer> children = adjL[i];\n\n        for (Integer c : children)\n            if (isCyclicUtil(c, visited, recStack))\n                return true;\n\n        recStack[i] = false;\n\n        return false;\n    }\n\n    static Integer[] memo;\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        int tests = sc.nextInt();\n        outer:\n        for (int test = 0; test < tests; test++) {\n            n = sc.nextInt();\n            arr = new int[n][];\n            adjL = new ArrayList[n];\n            for (int i = 0; i < n; i++)\n                adjL[i] = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                int size = sc.nextInt();\n                arr[i] = new int[size];\n                for (int j = 0; j < size; j++) {\n                    arr[i][j] = sc.nextInt() - 1;\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < arr[i].length; j++) {\n                    adjL[i].add(arr[i][j]);\n                }\n            }\n            boolean[] vis = new boolean[n], recStack = new boolean[n];\n            for (int i = 0; i < n; i++) {\n                if (isCyclicUtil(i, vis, recStack)) {\n                    pw.println(-1);\n                    continue outer;\n                }\n            }\n            int max = 1;\n            memo = new Integer[n];\n            for (int i = 0; i < n; i++)\n                max = Math.max(max, 1 + dp(i));\n            pw.println(max);\n        }\n\n        pw.flush();\n    }\n\n    private static int dp(int u) {\n        if (memo[u] != null)\n            return memo[u];\n        int max = 0;\n        for (int v : adjL[u]) {\n            max = Math.max(max, dp(v) + (v > u ? 1 : 0));\n        }\n        return memo[u] = max;\n    }\n\n    public static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public Scanner(String s) throws FileNotFoundException {\n            br = new BufferedReader(new InputStreamReader(new FileInputStream(s)));\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStreamWriter;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Map.Entry;\n\n\nimport java.util.Random;\nimport java.util.TreeSet;\n\npublic final class CF_7433_D2_C\n{\n\n\n\tstatic boolean verb=true;\n\tstatic void log(Object X){if (verb) System.err.println(X);}\n\tstatic void log(Object[] X){if (verb) {for (Object U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n\tstatic void log(int[] X){if (verb) {for (int U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n\tstatic void logWln(int[] X){if (verb) {for (int U:X) System.err.print(U+\" \");}}\n\tstatic void log(int[] X,int L){if (verb) {for (int i=0;i<L;i++) System.err.print(X[i]+\" \");System.err.println(\"\");}}\n\tstatic void log(long[] X){if (verb) {for (long U:X) System.err.print(U+\" \");System.err.println(\"\");}}\n\n\tstatic void logWln(Object X){if (verb) System.err.print(X);}\n\tstatic void info(Object o){\tSystem.out.println(o);}\n\tstatic void output(Object o){outputWln(\"\"+o+\"\\n\");\t}\n\tstatic void outputFlush(Object o){try {out.write(\"\"+ o+\"\\n\");out.flush();} catch (Exception e) {}}\n\tstatic void outputWln(Object o){try {out.write(\"\"+ o);} catch (Exception e) {}}\n\n\n\tstatic void logBin(int[] tm) {for (int x:tm) logWln(bin(8,x)+\" \");log(\"\");}\n\n\tstatic String bin(int L,int x) {\n\t\tString s=Integer.toBinaryString(x);\n\t\twhile (s.length()<L) s=\"0\"+s;\n\t\treturn s;\n\t}\n\n\t// Global vars\n\tstatic BufferedWriter out;\n\tstatic InputReader reader;\n\n\n\tstatic void test() {\n\t\tlog(\"testing\");\n\n\t\tRandom r=new Random();\n\t\tint NTESTS=100000;\n\t\tint NMAX=10;\n\t\tint VMAX=10;\n\t\tfor (int t=0;t<NTESTS;t++) {\n\n\t\t}\n\n\t}\n\n\tstatic int st;\n\n\n\n\n\n\n\n\tstatic void process() throws Exception {\n\n\n\t\tout = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\treader = new InputReader(System.in);\n\n\t\t//test();\n\n\n\t\tint T=reader.readInt();\n\t\tfor (int t=0;t<T;t++) {\n\t\t\tint n=reader.readInt();\n\t\t\tint[][] friends=new int[n][];\n\t\t\tboolean canStart=false;\n\t\t\tfor (int i=0;i<n;i++) {\n\t\t\t\tint k=reader.readInt();\n\t\t\t\tfriends[i]=new int[k];\n\t\t\t\tfor (int j=0;j<k;j++)\n\t\t\t\t\tfriends[i][j]=reader.readInt()-1;\n\t\t\t\tif (k==0)\n\t\t\t\t\tcanStart=true;\n\t\t\t}\n\t\t\tint ans=-1;\n\t\t\t//log(\"step 1\");\n\t\t\tif (canStart) {\n\t\t\t\t// do we have a loop\n\t\t\t\tint[] stack=new int[n];\n\t\t\t\tint[] rank=new int[n];\n\t\t\t\tboolean[] onStack=new boolean[n];\n\t\t\t\tboolean[] processed=new boolean[n];\n\t\t\t\tint[] it=new int[n];\n\t\t\t\tboolean ok=true;\n\t\t\t\tloop:for (int i=0;i<n;i++) {\n\n\t\t\t\t\tif (!processed[i] && friends[i].length>0) {\n\t\t\t\t\t\tint st=0;\n\t\t\t\t\t\tstack[st++]=i;\n\t\t\t\t\t\twhile (st>0) {\n\t\t\t\t\t\t\tint u=stack[st-1];\n\n\t\t\t\t\t\t\tif (it[u]<friends[u].length) {\n\t\t\t\t\t\t\t\tint v=friends[u][it[u]++];\n\t\t\t\t\t\t\t\tif (onStack[v]) {\n\t\t\t\t\t\t\t\t\tok=false;\n\t\t\t\t\t\t\t\t\t//log(\"issue\");\n\t\t\t\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!processed[v]) {\n\t\t\t\t\t\t\t\t\tonStack[v]=true;\n\t\t\t\t\t\t\t\t\tit[v]=0;\n\t\t\t\t\t\t\t\t\tstack[st++]=v;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tonStack[u]=false;\n\t\t\t\t\t\t\t\tprocessed[u]=true;\n\t\t\t\t\t\t\t\tit[u]=0;\n\t\t\t\t\t\t\t\tfor (int v:friends[u]) {\n\t\t\t\t\t\t\t\t\tint rnk=rank[v];\n\t\t\t\t\t\t\t\t\tif (v>u)\n\t\t\t\t\t\t\t\t\t\trnk++;\n\t\t\t\t\t\t\t\t\trank[u]=Math.max(rank[u],rnk);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tst--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tans=0;\n\t\t\t\t\tfor (int i=0;i<n;i++) {\n\t\t\t\t\t\tans=Math.max(ans,rank[i]);\n\t\t\t\t\t}\n\t\t\t\t\tans++;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\toutput(ans);\n\t\t}\n\n\n\n\t\ttry {\n\t\t\tout.close();\n\t\t} catch (Exception Ex) {\n\t\t}\n\n\t}\n\n\n\n\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tprocess();\n\n\t}\n\n\tstatic final class InputReader {\n\t\tprivate final InputStream stream;\n\t\tprivate final byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tprivate int read() throws IOException {\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\tif (numChars <= 0) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic final String readString() throws IOException {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.append((char) c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic final String readString(int L) throws IOException {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder(L);\n\t\t\tdo {\n\t\t\t\tres.append((char) c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic final int readInt() throws IOException {\n\t\t\tint c = read();\n\t\t\tboolean neg = false;\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tchar d = (char) c;\n\t\t\t// log(\"d:\"+d);\n\t\t\tif (d == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\t// log(\"res:\"+res);\n\t\t\tif (neg)\n\t\t\t\treturn -res;\n\t\t\treturn res;\n\n\t\t}\n\n\t\tpublic final long readLong() throws IOException {\n\t\t\tint c = read();\n\t\t\tboolean neg = false;\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tchar d = (char) c;\n\t\t\t// log(\"d:\"+d);\n\t\t\tif (d == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\t// log(\"res:\"+res);\n\t\t\tif (neg)\n\t\t\t\treturn -res;\n\t\t\treturn res;\n\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\t}\n\n}\n/*\n\n5\n1 4 5 2 3\n\n */"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint expo(int x, int y) {\n  int res = 1;\n  while (y) {\n    if (y % 2) res = (res * x % 1000000007) % 1000000007;\n    x = (x * x) % 1000000007;\n    y /= 2;\n  }\n  return res;\n}\nbool isPrime(long long n) {\n  if (n <= 1) return false;\n  if (n <= 3) return true;\n  if (n % 2 == 0 || n % 3 == 0) return false;\n  for (long long i = 5; i * i <= n; i = i + 6)\n    if (n % i == 0 || n % (i + 2) == 0) return false;\n  return true;\n}\nlong long nextPrime(long long N) {\n  if (N <= 1) return 2;\n  long long prime = N;\n  bool found = false;\n  while (!found) {\n    prime++;\n    if (isPrime(prime)) found = true;\n  }\n  return prime;\n}\nlong long cl(long long n, long long d) { return (n + d - 1) / d; }\nlong long binToDec(string s) { return bitset<64>(s).to_ullong(); }\nstring decToBin(long long a) { return bitset<64>(a).to_string(); }\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long lcm(long long a, long long b) { return (a * b) / (gcd(a, b)); }\nvoid print(pair<long long, long long> a) {\n  cout << a.first << ' ' << a.second;\n  cout << endl;\n  ;\n}\nvoid print(long long a) {\n  cout << a;\n  cout << endl;\n}\nvoid print(std::vector<long long> a) {\n  for (auto i : a) cout << i << ' ';\n  cout << endl;\n  ;\n}\nvoid print(string s) {\n  cout << s;\n  cout << endl;\n  ;\n}\nvoid printr(std::vector<long long> a, long long start, long long end) {\n  for (long long i = start; i < end; i++) cout << a[i] << ' ';\n  cout << endl;\n  ;\n}\nvoid print(long long a, long long b) { cout << a << ' ' << b; }\nvoid amax(long long &a, long long b) { a = max(a, b); }\nvoid amin(long long &a, long long b) { a = min(a, b); }\nlong long madd(long long a, long long b) {\n  return ((a % 1000000007) + (b % 1000000007)) % 1000000007;\n}\nlong long mmul(long long a, long long b) {\n  return ((a % 1000000007) * (b % 1000000007)) % 1000000007;\n}\nlong long msub(long long a, long long b) {\n  return ((a % 1000000007) - (b % 1000000007) + 1000000007) % 1000000007;\n}\nlong long fpow(long long x, long long y, long long p = 1000000007) {\n  x %= p;\n  long long sum = 1;\n  while (y) {\n    if (y & 1) sum = sum * x;\n    sum %= p;\n    y = y >> 1;\n    x = x * x;\n    x %= p;\n  }\n  return sum;\n}\nbool isPerSquare(long double a) {\n  if (a < 0) return false;\n  long long sr = sqrt(a);\n  return (sr * sr == a);\n}\nbool isPalindrome(string str) {\n  long long low = 0, high = long long(str.size()) - 1;\n  while (low < high) {\n    if (str[low] != str[high]) return false;\n    low++, high--;\n  }\n  return true;\n}\nconst long long N = 2e5 + 1;\nvector<set<long long> > indegree(N + 1 - 1), out(N + 1 - 1);\nvoid solve() {\n  long long n;\n  cin >> n;\n  ;\n  for (__typeof(n + 1) i = (1) - ((1) > (n + 1));\n       i != (n + 1) - ((1) > (n + 1)); i += 1 - 2 * ((1) > (n + 1))) {\n    indegree[i].clear();\n    out[i].clear();\n  }\n  for (__typeof(n + 1) i = (1) - ((1) > (n + 1));\n       i != (n + 1) - ((1) > (n + 1)); i += 1 - 2 * ((1) > (n + 1))) {\n    long long x;\n    cin >> x;\n    ;\n    for (__typeof(x) j = (0) - ((0) > (x)); j != (x) - ((0) > (x));\n         j += 1 - 2 * ((0) > (x))) {\n      long long y;\n      cin >> y;\n      ;\n      indegree[y].insert(i);\n      out[i].insert(y);\n    }\n  }\n  set<long long> sink;\n  for (long long i = 1; i <= n; i++) {\n    if (long long(out[i].size()) == 0) {\n      sink.insert(i);\n    }\n  }\n  long long ans = 1, removed = 0, top;\n  if (long long(sink.size())) top = *sink.begin();\n  while (1) {\n    if (removed == n) {\n      print(ans);\n      return;\n    }\n    if (long long(sink.size()) == 0) {\n      print(-1);\n      return;\n    }\n    sink.erase(top);\n    removed++;\n    for (auto j : indegree[top]) {\n      out[j].erase(top);\n      if (long long(out[j].size()) == 0) {\n        sink.insert(j);\n      }\n    }\n    if (removed == n) {\n      print(ans);\n      return;\n    }\n    if (long long(sink.size()) == 0) {\n      print(-1);\n      return;\n    }\n    if (sink.upper_bound(top) == sink.end()) {\n      top = *sink.begin();\n      ans++;\n    } else {\n      top = *sink.upper_bound(top);\n    }\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  long long t;\n  cin >> t;\n  while (t--) solve();\n}\n"
        },
        {
            "language": 3,
            "solution": "import io,os\nfrom collections import deque \n\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\ndef main(t):\n\n\n    n = int(input())\n    reqnum = [0 for i in range(n)]\n    req = [[] for i in range(n)]\n    neigh = [[] for i in range(n)]\n    queue = deque()\n    ans = [2147483647]*n\n\n\n\n\n\n    for i in range(n):\n        temp = list(map(int,input().split()))\n        reqnum[i] = temp[0]\n        for ele in temp[1:]:\n            neigh[ele-1].append(i)\n            req[i].append(ele-1)\n\n        if reqnum[i]==0:  queue.append(i)\n\n\n\n\n    while queue:\n        index = queue.popleft()\n        for nextindex in neigh[index]:\n            reqnum[nextindex] -= 1\n            if reqnum[nextindex] == 0:   \n                queue.append(nextindex)\n        ans[index] = 1\n\n        for preindex in req[index]:\n            if preindex <= index:   ans[index] = max(ans[index],  ans[preindex])\n            else:  ans[index] = max(ans[index], ans[preindex]+1)\n\n    maximum = max(ans)\n    if maximum==2147483647:  print(-1)\n    else: print(maximum)\n\n        \n        \n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nT = int(input())\nt = 1\nwhile t<=T:\n    main(t)\n    t += 1\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint tt, n;\nvector<int> a[200005];\npriority_queue<int, vector<int>, greater<int> > pq;\nqueue<int> q;\nint du[200005];\nint main() {\n  cin >> tt;\n  while (tt--) {\n    while (pq.size()) pq.pop();\n    while (q.size()) q.pop();\n    cin >> n;\n    for (int i = 1; i <= n; i++) a[i].clear();\n    for (int i = 1; i <= n; i++) {\n      int k;\n      scanf(\"%d\", &k);\n      du[i] = k;\n      if (k == 0) pq.push(i);\n      for (int j = 1; j <= k; j++) {\n        int u;\n        scanf(\"%d\", &u);\n        a[u].push_back(i);\n      }\n    }\n    int cnt = 0;\n    int ls = 1;\n    while (pq.size()) {\n      int t = pq.top();\n      pq.pop();\n      cnt++;\n      for (int j = 0; j <= (int)a[t].size() - 1; j++) {\n        du[a[t][j]]--;\n        if (du[a[t][j]] <= 0) {\n          if (a[t][j] > t)\n            pq.push(a[t][j]);\n          else\n            q.push(a[t][j]);\n        }\n      }\n      if (pq.size() == 0 && q.size()) {\n        ls++;\n        while (q.size()) {\n          pq.push(q.front());\n          q.pop();\n        }\n      }\n    }\n    if (cnt == n)\n      cout << ls << endl;\n    else\n      cout << \"-1\" << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint expo(int x, int y) {\n  int res = 1;\n  while (y) {\n    if (y % 2) res = (res * x % 1000000007) % 1000000007;\n    x = (x * x) % 1000000007;\n    y /= 2;\n  }\n  return res;\n}\nbool isPrime(long long n) {\n  if (n <= 1) return false;\n  if (n <= 3) return true;\n  if (n % 2 == 0 || n % 3 == 0) return false;\n  for (long long i = 5; i * i <= n; i = i + 6)\n    if (n % i == 0 || n % (i + 2) == 0) return false;\n  return true;\n}\nlong long nextPrime(long long N) {\n  if (N <= 1) return 2;\n  long long prime = N;\n  bool found = false;\n  while (!found) {\n    prime++;\n    if (isPrime(prime)) found = true;\n  }\n  return prime;\n}\nlong long cl(long long n, long long d) { return (n + d - 1) / d; }\nlong long binToDec(string s) { return bitset<64>(s).to_ullong(); }\nstring decToBin(long long a) { return bitset<64>(a).to_string(); }\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long lcm(long long a, long long b) { return (a * b) / (gcd(a, b)); }\nvoid print(pair<long long, long long> a) {\n  cout << a.first << ' ' << a.second;\n  cout << endl;\n  ;\n}\nvoid print(long long a) {\n  cout << a;\n  cout << endl;\n}\nvoid print(std::vector<long long> a) {\n  for (auto i : a) cout << i << ' ';\n  cout << endl;\n  ;\n}\nvoid print(string s) {\n  cout << s;\n  cout << endl;\n  ;\n}\nvoid printr(std::vector<long long> a, long long start, long long end) {\n  for (long long i = start; i < end; i++) cout << a[i] << ' ';\n  cout << endl;\n  ;\n}\nvoid print(long long a, long long b) { cout << a << ' ' << b; }\nvoid amax(long long &a, long long b) { a = max(a, b); }\nvoid amin(long long &a, long long b) { a = min(a, b); }\nlong long madd(long long a, long long b) {\n  return ((a % 1000000007) + (b % 1000000007)) % 1000000007;\n}\nlong long mmul(long long a, long long b) {\n  return ((a % 1000000007) * (b % 1000000007)) % 1000000007;\n}\nlong long msub(long long a, long long b) {\n  return ((a % 1000000007) - (b % 1000000007) + 1000000007) % 1000000007;\n}\nlong long fpow(long long x, long long y, long long p = 1000000007) {\n  x %= p;\n  long long sum = 1;\n  while (y) {\n    if (y & 1) sum = sum * x;\n    sum %= p;\n    y = y >> 1;\n    x = x * x;\n    x %= p;\n  }\n  return sum;\n}\nbool isPerSquare(long double a) {\n  if (a < 0) return false;\n  long long sr = sqrt(a);\n  return (sr * sr == a);\n}\nbool isPalindrome(string str) {\n  long long low = 0, high = long long(str.size()) - 1;\n  while (low < high) {\n    if (str[low] != str[high]) return false;\n    low++, high--;\n  }\n  return true;\n}\nvector<set<long long> > indegree, out;\nvoid solve() {\n  long long n;\n  cin >> n;\n  ;\n  indegree.resize(n + 1);\n  out.resize(n + 1);\n  for (__typeof(n + 1) i = (1) - ((1) > (n + 1));\n       i != (n + 1) - ((1) > (n + 1)); i += 1 - 2 * ((1) > (n + 1))) {\n    indegree[i].clear();\n    out[i].clear();\n  }\n  for (__typeof(n + 1) i = (1) - ((1) > (n + 1));\n       i != (n + 1) - ((1) > (n + 1)); i += 1 - 2 * ((1) > (n + 1))) {\n    long long x;\n    cin >> x;\n    ;\n    for (__typeof(x) j = (0) - ((0) > (x)); j != (x) - ((0) > (x));\n         j += 1 - 2 * ((0) > (x))) {\n      long long y;\n      cin >> y;\n      ;\n      indegree[y].insert(i);\n      out[i].insert(y);\n    }\n  }\n  set<long long> sink;\n  for (long long i = 1; i <= n; i++) {\n    if (long long(out[i].size()) == 0) {\n      sink.insert(i);\n    }\n  }\n  long long ans = 1, removed = 0, top;\n  if (long long(sink.size())) top = *sink.begin();\n  while (1) {\n    if (removed == n) {\n      print(ans);\n      return;\n    }\n    if (long long(sink.size()) == 0) {\n      print(-1);\n      return;\n    }\n    sink.erase(top);\n    removed++;\n    for (auto j : indegree[top]) {\n      out[j].erase(top);\n      if (long long(out[j].size()) == 0) {\n        sink.insert(j);\n      }\n    }\n    if (removed == n) {\n      print(ans);\n      return;\n    }\n    if (long long(sink.size()) == 0) {\n      print(-1);\n      return;\n    }\n    if (sink.upper_bound(top) == sink.end()) {\n      top = *sink.begin();\n      ans++;\n    } else {\n      top = *sink.upper_bound(top);\n    }\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  long long t;\n  cin >> t;\n  while (t--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 10;\nvector<int> to[N];\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++) to[i].clear();\n    vector<int> in(n);\n    for (int i = 0; i < n; i++) {\n      int x;\n      cin >> x;\n      for (int j = 0; j < x; j++) {\n        int k;\n        cin >> k;\n        k--;\n        to[k].push_back(i);\n        in[i]++;\n      }\n    }\n    queue<int> q;\n    vector<int> ts(n);\n    for (int i = 0; i < n; i++) {\n      if (in[i] == 0) {\n        q.push(i);\n        ts[i] = 1;\n      }\n    }\n    while (!q.empty()) {\n      int u = q.front();\n      q.pop();\n      for (auto v : to[u]) {\n        in[v]--;\n        if (v < u)\n          ts[v] = max(ts[v], ts[u] + 1);\n        else\n          ts[v] = max(ts[v], ts[u]);\n        if (!in[v]) q.push(v);\n      }\n    }\n    int ok = 1;\n    for (int i = 0; i < n; i++) {\n      if (in[i]) {\n        ok = 0;\n        break;\n      }\n    }\n    if (!ok) {\n      cout << \"-1\\n\";\n      continue;\n    }\n    cout << *max_element(ts.begin(), ts.end()) << '\\n';\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class C {\n    private static final FastReader fs = new FastReader();\n    private static final PrintWriter out = new PrintWriter(System.out);\n    private static long m = 1_000_000_009;\n    private static long p = 31;\n    private static long mod = 1_000_000_007;\n    private static long ool = 1_000_000_000_000_000_009l;\n    private static int ooi = 1_000_000_009;\n    private static int numOfBooks, inDeg;\n    private static int[] inDegree;\n    private static ArrayList<Integer>[] adj;\n    private static ArrayDeque<Integer> q;\n    private static int[] rank;\n    private static boolean[] vis;\n\n    private static void solve() {\n        numOfBooks = fs.nextInt();\n        adj = new ArrayList[numOfBooks];\n        inDegree = new int[numOfBooks];\n        q = new ArrayDeque<>();\n        rank = new int[numOfBooks];\n        vis = new boolean[numOfBooks];\n        for(int i = 0; i < numOfBooks; i++)\n            adj[i] = new ArrayList<>();\n        for(int i = 0; i < numOfBooks; i++){\n            inDeg = fs.nextInt();\n            inDegree[i] += inDeg;\n            if(inDeg == 0) {\n                q.add(i);\n                rank[i] = 1;\n            }\n            for(int j = 0; j < inDeg; j++)\n                adj[fs.nextInt()-1].add(i);\n        }\n        ArrayList<Integer> topo = new ArrayList<>();\n        while(!q.isEmpty()){\n            int chapterNum = q.getFirst();\n            q.removeFirst();\n            vis[chapterNum] = true;\n            topo.add(chapterNum);\n            for(int childChapterNum : adj[chapterNum]){\n                /*if(vis[childChapterNum]){\n                    out.println(-1);\n                    return;\n                }*/\n                inDegree[childChapterNum]-=1;\n                if(inDegree[childChapterNum] == 0)\n                    q.add(childChapterNum);\n            }\n        }\n        /*out.println(\"topilogicalSort is ::\");\n        for(int i = 0; i < topo.size(); i++){\n            out.println(topo.get(i))\n        }*/\n        for(int i = 0; i < numOfBooks; i++)\n            if(!vis[i]){\n                out.println(-1);\n                return;\n            }\n        int ans = 0;\n        for(int i = 0; i < topo.size(); i++){\n            int node = topo.get(i);\n            for(int j : adj[node])\n                rank[j] = max(rank[j], j > node ? rank[node] : rank[node] + 1);\n        }\n        for(int i = 0; i < numOfBooks; i++)\n            ans = max(ans, rank[i]);\n        out.println(ans);\n    }\n\n    public static void main(String[] args) {\n        Thread t = new Thread(null, null, \"\", 1 << 28) {\n            public void run() {\n                int test_case = 1;\n                test_case = fs.nextInt();\n                for (int cs = 1; cs <= test_case; cs++)\n                    solve();\n                out.close();\n            }\n        };\n        t.start();\n        try {\n            t.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        int[] readintarray(int n) {\n            int res[] = new int[n];\n            for (int i = 0; i < n; i++)\n                res[i] = nextInt();\n            return res;\n        }\n\n        long[] readlongarray(int n) {\n            long res[] = new long[n];\n            for (int i = 0; i < n; i++)\n                res[i] = nextLong();\n            return res;\n        }\n    }\n\n    private static int max(int... arg) {\n        int length = arg.length;\n        if(length == 0)\n            throw null;\n        int maxVal = arg[0];\n        for(int i = 1; i < length; i++)\n            maxVal = Math.max(maxVal, arg[i]);\n        return maxVal;\n    }\n\n    private static int min(int... arg) {\n        int length = arg.length;\n        if(length == 0)\n            throw null;\n        int maxVal = arg[0];\n        for(int i = 1; i < length; i++)\n            maxVal = Math.min(maxVal, arg[i]);\n        return maxVal;\n    }\n\n    private static long max(long... arg) {\n        int length = arg.length;\n        if(length == 0)\n            throw null;\n        long maxVal = arg[0];\n        for(int i = 1; i < length; i++)\n            maxVal = Math.max(maxVal, arg[i]);\n        return maxVal;\n    }\n\n    private static long min(long... arg) {\n        int length = arg.length;\n        if(length == 0)\n            throw null;\n        long maxVal = arg[0];\n        for(int i = 1; i < length; i++)\n            maxVal = Math.min(maxVal, arg[i]);\n        return maxVal;\n    }\n\n    private static int abs(int a) {\n        return a >= 0 ? a : -a;\n    }\n\n    private static int abs(int a, int b) {\n        return a-b >= 0 ? a-b : b-a;\n    }\n\n    private static long abs(long a) {\n        return a >= 0 ? a : -a;\n    }\n\n    private static long abs(long a, long b) {\n        return a-b >= 0 ? a-b : b-a;\n    }\n\n    private static int power(int base, int exponent) {\n        int res = 1;\n        while(exponent > 0) {\n            if((exponent & 1) != 0)\n                res *= base;\n            exponent >>= 1;\n            base *= base;\n        }\n        return res;\n    }\n\n    private static long power(long base, long exponent) {\n        long res = 1;\n        while(exponent > 0) {\n            if((exponent & 1) != 0)\n                res *= base;\n            exponent >>= 1;\n            base *= base;\n        }\n        return res;\n    }\n\n    private static long mPower(long base, long exponent) throws Exception {\n        long res = 1;\n        base %= mod;\n        while(exponent > 0) {\n            if((exponent & 1) != 0)\n                res = mul(res, base);\n            exponent >>= 1;\n            base = mul(base, base);\n        }\n        return res;\n    }\n\n    private static long mul(long a, long b) {\n        return a*b % mod;\n    }\n\n    private static long add(long a, long b) {\n        return (a+b) % mod;\n    }\n\n    private static long sub(long a, long b) {\n        long res = (a - b) % mod;\n        if(res < 0)\n            res += mod;\n        return res;\n    }\n\n    private static long xor(long n){\n        long r = n % 4;\n        if(r == 0)\n            return n;\n        else if(r == 1)\n            return 1;\n        else if(r == 2)\n            return n+1;\n        else\n            return 0;\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k, a, in[200005], dp[200005];\nvector<pair<long long, long long> > vec[200005];\nint main() {\n  long long t;\n  cin >> t;\n  while (t--) {\n    cin >> n;\n    for (long long i = 1; i <= n; i++) {\n      vec[i].clear();\n      in[i] = 0;\n      dp[i] = 0;\n    }\n    for (long long i = 1; i <= n; i++) {\n      cin >> k;\n      in[i] += k;\n      while (k--) {\n        cin >> a;\n        vec[a].push_back({i, (a > i ? 1 : 0)});\n      }\n    }\n    queue<long long> q;\n    for (long long i = 1; i <= n; i++) {\n      if (in[i] == 0) {\n        q.push(i);\n        dp[i] = 1;\n      }\n    }\n    while (!q.empty()) {\n      long long u = q.front();\n      q.pop();\n      for (auto p : vec[u]) {\n        long long v = p.first;\n        long long w = p.second;\n        dp[v] = max(dp[v], dp[u] + w);\n        in[v]--;\n        if (in[v] == 0) q.push(v);\n      }\n    }\n    long long mx = -1, flag = 0;\n    for (long long i = 1; i <= n; i++) {\n      if (in[i] > 0) flag = 1;\n      mx = max(mx, dp[i]);\n    }\n    if (flag)\n      cout << -1 << endl;\n    else\n      cout << mx << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\n\n\nimport java.math.*;\nimport java.math.BigInteger;\n\n\npublic final class A\n{    \n\tstatic PrintWriter out = new PrintWriter(System.out); \n\tstatic StringBuilder ans=new StringBuilder();\n\tstatic FastReader in=new FastReader();\n\tstatic ArrayList<Integer> g[];\n\tstatic long mod=(long)998244353,INF=Long.MAX_VALUE;\n\tstatic boolean set[],col[]; \n\tstatic int par[],tot[],partial[];\n\tstatic int Days[],P[][];\n\tstatic int dp[][],sum=0,size[];\n\tstatic int seg[];\n\tstatic ArrayList<Long> A;\n\t//\tstatic HashSet<Integer> set;\n\t//\tstatic node1 seg[];\n\t//static pair moves[]= {new pair(-1,0),new pair(1,0), new pair(0,-1), new pair(0,1)};\n\tpublic static void main(String args[])throws IOException\n\t{\t\t\n\t\tint T=i();\n\t\touter:while(T-->0)\n\t\t{\n\t\t\tint N=i();\n\t\t\tsetGraph(N);\n\t\t\tfor(int i=1; i<=N; i++)\n\t\t\t{\n\t\t\t\tint k=i();\n\t\t\t\twhile(k-->0)\n\t\t\t\t{\n\t\t\t\t\tg[i].add(i());\n\t\t\t\t}\n\t\t\t\t//System.out.println(g[i]);\n\t\t\t}\n\t\t\tint max=0;\n\t\t\tcycle=false;\n\t\t\tfor(int i=1; i<=N; i++)\n\t\t\t{\n\t\t\t\tcycle=false;\n\t\t\t\tint a=f(i);\n\t\t\t\t//print(Days);\n\t\t\t\tif(cycle)\n\t\t\t\t{\n\t\t\t\t\tmax=-1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmax=Math.max(max,a);\n\t\t\t}\n\t\t//\tprint(Days);\n\t\t\tans.append(max+\"\\n\");\n\t\t}\n\t\tout.println(ans);\n\t\tout.close();\n\t}\n\tstatic boolean cycle=false;\n\tstatic int f(int n)\n\t{\n\t\tif(set[n])return Days[n];\n\t\tset[n]=true;\n\t\tint max=1;\n\t\tfor(int x:g[n])\n\t\t{\n\t\t\tif(set[x] && Days[x]==-1)\n\t\t\t{\n\t\t\t\tcycle=true;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(!set[x])\n\t\t\t{\n\t\t\t\tf(x);\n\t\t\t}\n\t\t\tif(x<n)max=Math.max(max, Days[x]);\n\t\t\telse max=Math.max(max, Days[x]+1);\n\t\t}\n\t\treturn Days[n]=max;\n\t}\n\tstatic int index(int a,ArrayList<Integer> A)\n\t{\n\t\tint l=-1,r=A.size();\n\t\twhile(r-l>1)\n\t\t{\n\t\t\tint m=(l+r)/2;\n\t\t\tint x=A.get(m);\n\t\t\tif(x<=a)l=m;\n\t\t\telse r=m;\n\t\t}\n\t\treturn r;\n\t}\n\tstatic long and(int i,int j)\n\t{\n\t\tSystem.out.println(\"and \"+i+\" \"+j);\n\t\treturn l();\n\t}\n\tstatic long or(int i,int j)\n\t{\n\t\tSystem.out.println(\"or \"+i+\" \"+j);\n\t\treturn l();\n\t}\n\tstatic boolean is_Sorted(int A[])\n\t{\n\t\tint N=A.length;\n\t\tfor(int i=1; i<=N; i++)if(A[i-1]!=i)return false;\n\t\treturn true;\n\t}\n\tstatic boolean f(StringBuilder sb,String Y,String order)\n\t{\n\t\tStringBuilder res=new StringBuilder(sb.toString());\n\t\tHashSet<Character> set=new HashSet<>();\n\t\tfor(char ch:order.toCharArray())\n\t\t{\n\t\t\tset.add(ch);\n\t\t\tfor(int i=0; i<sb.length(); i++)\n\t\t\t{\n\t\t\t\tchar x=sb.charAt(i);\n\t\t\t\tif(set.contains(x))continue;\n\t\t\t\tres.append(x);\n\t\t\t}\n\t\t}\n\n\t\tString str=res.toString();\n\t\treturn str.equals(Y);\n\t}\n\tstatic boolean all_Zero(int f[])\n\t{\n\t\tfor(int a:f)if(a!=0)return false;\n\t\treturn true;\n\t}\n\tstatic long form(int a,int l)\n\t{\n\t\tlong x=0;\n\t\twhile(l-->0)\n\t\t{\n\t\t\tx*=10;\n\t\t\tx+=a;\n\t\t}\n\t\treturn x;\n\t}\n\tstatic int count(String X)\n\t{\n\t\tHashSet<Integer> set=new HashSet<>();\n\t\tfor(char x:X.toCharArray())set.add(x-'0');\n\t\treturn set.size();\n\t}\n\n\t\n\t//\tstatic void build(int v,int tl,int tr,long A[])\n\t//\t{\n\t//\t\tif(tl==tr)\n\t//\t\t{\n\t//\t\t\tseg[v]=A[tl];\n\t//\t\t}\n\t//\t\telse\n\t//\t\t{\n\t//\t\t\tint tm=(tl+tr)/2;\n\t//\t\t\tbuild(v*2,tl,tm,A);\n\t//\t\t\tbuild(v*2+1,tm+1,tr,A);\n\t//\t\t\tseg[v]=Math.min(seg[v*2], seg[v*2+1]);\n\t//\t\t}\n\t//\t}\n\tstatic long ask(int v,int tl,int tr,int l,int r)\n\t{\n\t\tif(l>r)return (long)(1e10);\n\t\tif(tl==l && tr==r)\n\t\t{\n\t\t\treturn seg[v];\n\t\t}\n\t\tint tm=(tl+tr)/2;\n\t\treturn Math.min(ask(v*2,tl,tm,l,Math.min(tm, r)), ask(v*2+1,tm+1,tr,Math.max(l,tm+1),r));\n\t}\n\tstatic int [] sub(int A[],int B[])\n\t{\n\t\tint N=A.length;\n\t\tint f[]=new int[N];\n\t\tfor(int i=N-1; i>=0; i--)\n\t\t{\n\t\t\tif(B[i]<A[i])\n\t\t\t{\n\t\t\t\tB[i]+=26;\n\t\t\t\tB[i-1]-=1;\n\t\t\t}\n\t\t\tf[i]=B[i]-A[i];\n\t\t}\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tif(f[i]%2!=0)f[i+1]+=26;\n\t\t\tf[i]/=2;\n\t\t}\n\t\treturn f;\n\t}\n\t\n\n\n\n\n\tstatic int max(int a ,int b,int c,int d)\n\t{\n\t\ta=Math.max(a, b);\n\t\tc=Math.max(c,d);\n\t\treturn Math.max(a, c);\n\t}\n\tstatic int min(int a ,int b,int c,int d)\n\t{\n\t\ta=Math.min(a, b);\n\t\tc=Math.min(c,d);\n\t\treturn Math.min(a, c);\n\t}\n\n\n\n\tstatic HashMap<Integer,Integer> Hash(int A[])\n\t{\n\t\tHashMap<Integer,Integer> mp=new HashMap<>();\n\t\tfor(int a:A)\n\t\t{\n\t\t\tint f=mp.getOrDefault(a,0)+1;\n\t\t\tmp.put(a, f);\n\t\t}\n\t\treturn mp;\n\t}\n\tstatic long mul(long a, long b)\n\t{\n\t\treturn ( a %mod * 1L * b%mod )%mod;\n\t}\n\tstatic void swap(int A[],int a,int b)\n\t{\n\t\tint t=A[a];\n\t\tA[a]=A[b];\n\t\tA[b]=t;\n\t}\n\n\n\tstatic int find(int a)\n\t{\n\t\tif(par[a]<0)return a;\n\t\treturn par[a]=find(par[a]);\n\t}\n\tstatic void union(int a,int b)\n\t{\n\t\ta=find(a);\n\t\tb=find(b);\n\t\tif(a!=b)\n\t\t{\n\t\t\tpar[a]+=par[b];\n\t\t\tpar[b]=a;\n\t\t}\n\t}\n\tstatic boolean isSorted(int A[])\n\t{\n\t\tfor(int i=1; i<A.length; i++)\n\t\t{\n\t\t\tif(A[i]<A[i-1])return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tstatic boolean isDivisible(StringBuilder X,int i,long num)\n\t{\n\t\tlong r=0;\n\t\tfor(; i<X.length(); i++)\n\t\t{\n\t\t\tr=r*10+(X.charAt(i)-'0');\n\t\t\tr=r%num;\n\t\t}\n\t\treturn r==0;\n\t}    \n\n\n\n\tstatic int lower_Bound(int A[],int low,int high, int x) \n\t{ \n\t\tif (low > high) \n\t\t\tif (x >= A[high]) \n\t\t\t\treturn A[high]; \n\n\t\tint mid = (low + high) / 2; \n\n\t\tif (A[mid] == x) \n\t\t\treturn A[mid]; \n\n\t\tif (mid > 0 && A[mid - 1] <= x && x < A[mid]) \n\t\t\treturn A[mid - 1]; \n\n\t\tif (x < A[mid]) \n\t\t\treturn lower_Bound( A, low, mid - 1, x); \n\n\t\treturn lower_Bound(A, mid + 1, high, x); \n\t} \n\n\tstatic String f(String A)\n\t{\n\t\tString X=\"\";\n\t\tfor(int i=A.length()-1; i>=0; i--)\n\t\t{\n\t\t\tint c=A.charAt(i)-'0';\n\t\t\tX+=(c+1)%2;\n\t\t}\n\t\treturn X;\n\t}\n\n\tstatic void sort(long[] a) //check for long\n\t{\n\t\tArrayList<Long> l=new ArrayList<>();\n\t\tfor (long i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n\n\tstatic String swap(String X,int i,int j)\n\t{\n\t\tchar ch[]=X.toCharArray();\n\t\tchar a=ch[i];\n\t\tch[i]=ch[j];\n\t\tch[j]=a;\n\t\treturn new String(ch);\n\t}\n\n\tstatic int sD(long n)  \n\t{  \n\n\t\tif (n % 2 == 0 )  \n\t\t\treturn 2;  \n\n\t\tfor (int i = 3; i * i <= n; i += 2) {  \n\t\t\tif (n % i == 0 )  \n\t\t\t\treturn i;  \n\t\t}  \n\n\t\treturn (int)n;  \n\t}  \n\n\tstatic void setGraph(int N)\n\t{\n\t\ttot=new int[N+1];\n\t\tpartial=new int[N+1];\n\t\tDays=new int[N+1];\n\t\tP=new int[N+1][(int)(Math.log(N)+10)];\n\t\tset=new boolean[N+1];\n\t\tg=new ArrayList[N+1];\n\t\tfor(int i=0; i<=N; i++)\n\t\t{\n\n\t\t\tg[i]=new ArrayList<>();\t\t\n\t\t\tDays[i]=-1;\n\t\t\t//D2[i]=INF;\n\t\t}\n\t}\n\n\n\n\tstatic  long pow(long a,long b)\n\t{\n\t\t//long mod=1000000007;\n\t\tlong pow=1;\n\t\tlong x=a;\n\t\twhile(b!=0)\n\t\t{\n\t\t\tif((b&1)!=0)pow=(pow*x)%mod;\n\t\t\tx=(x*x)%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn pow;\n\t}\n\n\tstatic long toggleBits(long x)//one's complement || Toggle bits\n\t{\n\t\tint n=(int)(Math.floor(Math.log(x)/Math.log(2)))+1;\n\n\t\treturn ((1<<n)-1)^x;\n\t}\n\n\tstatic int countBits(long a)\n\t{\n\t\treturn (int)(Math.log(a)/Math.log(2)+1);\n\t}\n\n\tstatic long fact(long N)\n\t{ \n\t\tlong n=2; \n\t\tif(N<=1)return 1;\n\t\telse\n\t\t{\n\t\t\tfor(int i=3; i<=N; i++)n=(n*i)%mod;\n\t\t}\n\t\treturn n;\n\t}\n\n\tstatic int kadane(int A[])\n\t{\n\t\tint lsum=A[0],gsum=A[0];\n\t\tfor(int i=1; i<A.length; i++)\n\t\t{\n\t\t\tlsum=Math.max(lsum+A[i],A[i]);\n\t\t\tgsum=Math.max(gsum,lsum);\n\t\t}\n\t\treturn gsum;\n\t}\n\n\tstatic void sort(int[] a) {\n\t\tArrayList<Integer> l=new ArrayList<>();\n\t\tfor (int i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n\n\tstatic boolean isPrime(long N)\n\t{\n\t\tif (N<=1)  return false; \n\t\tif (N<=3)  return true; \n\t\tif (N%2 == 0 || N%3 == 0) return false; \n\t\tfor (int i=5; i*i<=N; i=i+6) \n\t\t\tif (N%i == 0 || N%(i+2) == 0) \n\t\t\t\treturn false; \n\t\treturn true; \n\t}\n\tstatic void print(char A[])\n\t{\n\t\tfor(char c:A)System.out.print(c+\" \");\n\t\tSystem.out.println();\n\t}\n\tstatic void print(boolean A[])\n\t{\n\t\tfor(boolean c:A)System.out.print(c+\" \");\n\t\tSystem.out.println();\n\t}\n\tstatic void print(int A[])\n\t{\n\t\tfor(int a:A)System.out.print(a+\" \");\n\t\tSystem.out.println();\t\n\t}\n\tstatic void print(long A[])\n\t{\n\t\tfor(long i:A)System.out.print(i+ \" \");\n\t\tSystem.out.println();\n\n\t}\n\tstatic void print(boolean A[][])\n\t{\n\t\tfor(boolean a[]:A)print(a);\n\t}\n\tstatic void print(long A[][])\n\t{\n\t\tfor(long a[]:A)print(a);\n\t}\n\tstatic void print(int A[][])\n\t{\n\t\tfor(int a[]:A)print(a);\n\t}\n\tstatic void print(ArrayList<Integer> A)\n\t{\n\t\tfor(int a:A)System.out.print(a+\" \");\n\t\tSystem.out.println();\n\t}\n\n\tstatic int i()\n\t{\n\t\treturn in.nextInt();\n\t}\n\n\tstatic long l()\n\t{\n\t\treturn in.nextLong();\n\t}\n\n\tstatic int[] input(int N){\n\t\tint A[]=new int[N];\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tA[i]=in.nextInt();\n\t\t}\n\t\treturn A;\n\t}\n\n\tstatic long[] inputLong(int N)     {\n\t\tlong A[]=new long[N];\n\t\tfor(int i=0; i<A.length; i++)A[i]=in.nextLong();\n\t\treturn A;\n\t}\n\n\tstatic long GCD(long a,long b) \n\t{\n\t\tif(b==0)\n\t\t{\n\t\t\treturn a;\n\t\t}\n\t\telse return GCD(b,a%b );\n\t}\n\n}\nclass Pair implements Comparable<Pair>\n{\n\tlong a;\n\tint index;\n\tPair(long a,int index)\n\t{\n\t\tthis.index=index;\n\t\tthis.a=a;\n\t}\n\tpublic int compareTo(Pair x)\n\t{\n\t\tif(this.a==x.a)return x.index-this.index;\n\t\tif(this.a>x.a)return 1;\n\t\telse return -1;\n\t}\n}\n\n\n//Code For FastReader\n//Code For FastReader\n//Code For FastReader\n//Code For FastReader\nclass FastReader\n{\n\tBufferedReader br;\n\tStringTokenizer st;\n\tpublic FastReader()\n\t{\n\t\tbr=new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\tString next()\n\t{\n\t\twhile(st==null || !st.hasMoreElements())\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t\tcatch(IOException e)\n\t\t\t{\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt()\n\t{\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tlong nextLong()\n\t{\n\t\treturn Long.parseLong(next());\n\t}\n\n\tdouble nextDouble()\n\t{\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tString nextLine()\n\t{\n\t\tString str=\"\";\n\t\ttry\n\t\t{\n\t\t\tstr=br.readLine();\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn str;\n\t}\n\n}"
        },
        {
            "language": 3,
            "solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\n \n\ndef main():\n    from heapq import heappush, heappop\n\n    for _ in range(int(input())):\n        n = int(input())\n\n        indegree = [0] * (n + 1)\n        pres = [[] for _ in range(n + 1)]\n        posts = [[] for _ in range(n + 1)]\n        for t in range(1, n + 1):\n            temp = list(map(int, input().split()))\n            for f in temp[1:]:\n    #             pres[t].append(f)\n                indegree[t] += 1\n                posts[f].append(t)\n\n        heap = []\n        for i in range(1, n + 1):\n            if indegree[i] == 0:\n                heappush(heap, (1, i))\n\n    #     print(indegree)\n    #     print(pres)\n    #     print(posts)\n        count = 0\n        max_c = 0\n        while heap:\n            c, value = heappop(heap)\n    #         print(c, value)\n            max_c = max(max_c, c)\n            count += 1\n\n            for v in posts[value]:\n                indegree[v] -= 1\n                if indegree[v] == 0:\n                    if value < v:\n                        heappush(heap, (c, v))\n                    else:\n                        heappush(heap, (c + 1, v))\n\n    #     print(222, count)\n        if count < n:\n            print(-1)\n        else:\n            print(max_c)\n    \n    \n    \n    \n    \n\n# region fastio\n \nBUFSIZE = 8192\n \n\nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n# endregion\n \nif __name__ == \"__main__\":\n    main()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0},\n    dxx[8] = {0, 0, 1, 1, 1, -1, -1, -1}, dyy[8] = {1, -1, 0, 1, -1, 0, 1, -1};\nvector<int> v[200002];\nbool vis[200002];\nbool st[200002];\nint ans[200002];\nint finalAns;\nstack<int> topoStack;\nbool detectcycle(int u) {\n  if (!vis[u]) {\n    vis[u] = true;\n    st[u] = true;\n    for (int i = 0; i < v[u].size(); ++i) {\n      if (!vis[v[u][i]] && detectcycle(v[u][i]))\n        return true;\n      else if (st[v[u][i]])\n        return true;\n    }\n  }\n  st[u] = false;\n  return false;\n}\nvoid topoSort(int u) {\n  st[u] = true;\n  for (int i = 0; i < v[u].size(); ++i) {\n    if (!st[v[u][i]]) topoSort(v[u][i]);\n  }\n  topoStack.push(u);\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t;\n  for (cin >> t; t--;) {\n    int n, sz, x, i;\n    cin >> n;\n    vector<int> start;\n    finalAns = 1;\n    for (i = 1; i <= n; ++i) v[i].clear();\n    for (i = 1; i <= n; ++i) {\n      cin >> sz;\n      ans[i] = -1;\n      vis[i] = st[i] = false;\n      if (sz == 0) {\n        start.push_back(i);\n        continue;\n      }\n      for (int j = 0; j < sz; ++j) {\n        cin >> x;\n        v[x].push_back(i);\n      }\n    }\n    bool isCycle = false;\n    for (i = 1; i <= n; ++i) {\n      if (!vis[i] && detectcycle(i)) {\n        isCycle = true;\n        break;\n      }\n    }\n    if (isCycle) {\n      cout << \"-1\\n\";\n      continue;\n    }\n    for (i = 0; i < start.size(); ++i) {\n      ans[start[i]] = 1;\n      topoSort(start[i]);\n    }\n    while (!topoStack.empty()) {\n      int u = topoStack.top();\n      topoStack.pop();\n      finalAns = max(finalAns, ans[u]);\n      if (ans[u] != -1) {\n        for (i = 0; i < v[u].size(); ++i) {\n          int x = v[u][i] > u ? 0 : 1;\n          if (ans[v[u][i]] < ans[u] + x) ans[v[u][i]] = ans[u] + x;\n        }\n      }\n    }\n    cout << finalAns << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 1e6 + 7, M = N * 2;\nconst long long p = 998244353;\nlong long num, x, n, ans;\nlong long in[N];\nlong long h[N], e[N], ne[N], idx;\nvoid add(long long a, long long b) { e[idx] = b, ne[idx] = h[a], h[a] = idx++; }\nbool topo() {\n  priority_queue<pair<long long, long long>,\n                 vector<pair<long long, long long> >,\n                 greater<pair<long long, long long> > >\n      q;\n  long long cnt = 0;\n  for (long long i = 1; i <= n; ++i) {\n    if (in[i] == 0) {\n      cnt++;\n      q.push({1, i});\n    }\n  }\n  while (!q.empty()) {\n    ans = q.top().first;\n    long long pos = q.top().second;\n    q.pop();\n    for (long long i = h[pos]; i != -1; i = ne[i]) {\n      long long j = e[i];\n      --in[j];\n      if (in[j] == 0) {\n        cnt++;\n        if (j > pos)\n          q.push({ans, j});\n        else\n          q.push({ans + 1, j});\n      }\n    }\n  }\n  return cnt == n;\n}\nvoid solve() {\n  ans = -1;\n  idx = 0;\n  scanf(\"%lld\", &n);\n  for (long long i = 1; i <= n; ++i) h[i] = -1;\n  for (long long i = 1; i <= n; ++i) {\n    scanf(\"%lld%\", &num);\n    in[i] = num;\n    while (num--) {\n      scanf(\"%lld\", &x);\n      add(x, i);\n    }\n  }\n  if (topo())\n    printf(\"%lld\\n\", ans);\n  else\n    printf(\"-1\\n\");\n}\nsigned main() {\n  long long t = 1;\n  scanf(\"%lld\", &t);\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 200010;\nconst int INF = 1e9;\nint n, in[MAXN], dist[MAXN];\nvector<int> graph[MAXN];\nvoid solve() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    graph[i].clear();\n    in[i] = 0;\n    dist[i] = INF;\n  }\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &in[i]);\n    for (int j = 0, a; j < in[i]; j++) {\n      scanf(\"%d\", &a);\n      graph[a].push_back(i);\n    }\n  }\n  set<pair<int, int> > s;\n  for (int i = 1; i <= n; i++)\n    if (!in[i]) s.insert({0, i}), dist[i] = 0;\n  int ans = 0, cnt = 0;\n  while (!s.empty()) {\n    int v = s.begin()->second;\n    s.erase(s.begin());\n    cnt++;\n    ans = max(ans, dist[v]);\n    for (int i = 0; i < (int)graph[v].size(); i++) {\n      int u = graph[v][i];\n      in[u]--;\n      if (!in[u]) {\n        dist[u] = dist[v] + (u < v);\n        s.insert({dist[u], u});\n      }\n    }\n  }\n  printf(\"%d\\n\", (cnt == n) ? ans + 1 : -1);\n}\nint main() {\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nconst long long INF = 1e18 + 10;\nbool comp(pair<long long, long long> a, pair<long long, long long> b) {\n  return a.first > b.first;\n}\nvoid solve() {\n  long long n;\n  cin >> n;\n  vector<vector<long long> > a(n + 1);\n  set<long long> rtunderstood;\n  vector<long long> b(n + 1);\n  long long totu = 0;\n  for (long long i = 1; i <= n; i++) {\n    long long k;\n    cin >> k;\n    b[i] = k;\n    if (k == 0) rtunderstood.insert(i);\n    while (k--) {\n      long long ch;\n      cin >> ch;\n      a[ch].push_back(i);\n    }\n  }\n  if (rtunderstood.empty()) {\n    cout << -1 << \"\\n\";\n    return;\n  }\n  long long ans = 0;\n  while (!rtunderstood.empty()) {\n    auto it = rtunderstood.begin();\n    set<long long> nw;\n    while (it != rtunderstood.end()) {\n      long long cur = *it;\n      for (auto x : a[cur]) {\n        b[x]--;\n        if (b[x] == 0) {\n          if (x > cur)\n            rtunderstood.insert(x);\n          else\n            nw.insert(x);\n        }\n      }\n      totu++;\n      it++;\n    }\n    ans++;\n    rtunderstood = nw;\n  }\n  if (totu == n)\n    cout << ans << \"\\n\";\n  else\n    cout << -1 << \"\\n\";\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cout << fixed;\n  cout << setprecision(15);\n  long long t;\n  t = 1;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 1067, M = 1e5 + 1067;\nint t, n;\nint cnt[N];\nvector<int> to[N];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> t;\n  for (int test = 1; test <= t; test++) {\n    cin >> n;\n    for (int i = 1; i <= n; i++) to[i].clear();\n    for (int i = 1; i <= n; i++) {\n      int k;\n      cin >> k;\n      for (int j = 1; j <= k; j++) {\n        int x;\n        cin >> x;\n        to[x].push_back(i);\n      }\n      cnt[i] = k;\n    }\n    set<int> listAvail;\n    for (int i = 1; i <= n; i++)\n      if (!cnt[i]) {\n        listAvail.insert(i);\n      }\n    int dem = 0;\n    int res = 0;\n    while (!listAvail.empty()) {\n      set<int> newList;\n      res += 1;\n      while (!listAvail.empty()) {\n        int i = *listAvail.begin();\n        dem += 1;\n        for (auto j : to[i]) {\n          --cnt[j];\n          if (!cnt[j]) {\n            if (j > i)\n              listAvail.insert(j);\n            else\n              newList.insert(j);\n          }\n        }\n        listAvail.erase(i);\n      }\n      listAvail = newList;\n    }\n    if (dem < n)\n      cout << -1 << endl;\n    else\n      cout << res << endl;\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic class Cf3 {\n\t\n\tstatic ArrayList<ArrayList<Integer>> adj ;\n\tstatic ArrayList<ArrayList<Integer>> radj ;\n\t\n\tstatic int[] vis;\n\tstatic int[] lab;\n\t\n\tstatic boolean dfs(int u) {\n\t\t\n\t\tvis[u]=1;\n\t\t\n\t\t\n\t\t\t\n\t\tfor(Integer i:adj.get(u)) {\n\t\t\t\n\t\t\t\n\t\t\tif(vis[i]==0) {\n\t\t\t\tint mif=0;\n\t\t\t\tint max=0;int maxi=-1;\n\t\t\t\tfor(Integer im : radj.get(i)) {\n\t\t\t\t\tif(vis[im]==0) {\n\t\t\t\t\t\tmif=1;break;\n\t\t\t\t\t}\n\t\t\t\t    if(max<lab[im]){\n\t\t\t\t        max=lab[im];\n\t\t\t\t        maxi=im;\n\t\t\t\t    }else if (max==lab[im]){\n\t\t\t\t        maxi=Math.max(maxi,im);\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif(mif==0){\n\t\t\t\t\n\t\t\tif(i<maxi) lab[i]=lab[maxi]+1;\n\t\t\telse lab[i]=lab[maxi];\n\t\t\t\n\t\t\t\tif(dfs(i)) {return true;}\n\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(vis[i]==1) {\n\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\tvis[u]=2;\n\t\t\treturn false;\n\t\t\t\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc=new Scanner(System.in);\n\t\tint tt=sc.nextInt();\n\t\tfor(int ii=0;ii<tt;ii++) {\n\t\t\t\n\t\t\tint n=sc.nextInt();\n\t\t\tadj = new ArrayList<ArrayList<Integer>>();\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tadj.add(new ArrayList<Integer>());\t\n\t\t    }\n\t\t\tradj = new ArrayList<ArrayList<Integer>>();\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tradj.add(new ArrayList<Integer>());\t\n\t\t    }\n\t\t\t\n\t\t\t\n\t\t\tint[] noin = new int[n];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tint s=sc.nextInt();\n\t\t\t\tif(s==0) {\n\t\t\t\t\tnoin[i]=1;\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<s;j++) {\n\t\t\t\t\tint fu=sc.nextInt()-1;\n\t\t\t\t\tadj.get(fu).add(i);radj.get(i).add(fu);\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tvis=new int[n];\n\t\t\tlab=new int[n];\n\t\t\tfor(int i=0;i<n;i++) lab[i]=1;\n\t\t\tint f=0;int f1=0;\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tif(noin[i]==1) {\n\t\t\t\t\tf1=1;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(f1==0) System.out.println(-1);\n\t\t\telse {\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tif(vis[i]==0 && noin[i]==1) {\n\t\t\t\t\n\t\t\t\t\tif(dfs(i)) {\n\t\t\t\t\t\tf=1;System.out.println(-1);break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.println(Arrays.toString(lab));\n\t\t\t\n\t\t\tif(f==0) {\n\t\t\t\tint cf=0;\n\t\t\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\t\t\tif(vis[i]==0) {\n\t\t\t\t\t\t\tcf=1;break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}if(cf==1) System.out.println(-1);\n\t\t\t\t\telse {\n\t\t\t\t\tint m=0;\n\t\t\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\t\t\tm=Math.max(m, lab[i]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(m);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t\n\t\t}\n\t}\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long maxn = 2 * 1e5 + 10;\nvector<long long> a[maxn];\nlong long i, j, k, mm[maxn], t, n, aa, m;\nlong long dfs(long long i) {\n  if (a[i].empty()) return 1;\n  if (mm[i] != 0) return mm[i];\n  mm[i] = -1;\n  long long count = -1;\n  for (long long j = 0; j < a[i].size(); j++) {\n    long long k = dfs(a[i][j]);\n    if (k == -1) return -1;\n    if (a[i][j] < i)\n      count = max(count, k);\n    else\n      count = max(count, k + 1);\n  }\n  mm[i] = count;\n  return count;\n}\nint main() {\n  scanf(\"%lld\", &t);\n  while (t--) {\n    scanf(\"%lld\", &n);\n    memset(mm, 0, sizeof(mm));\n    for (i = 1; i <= n; i++) {\n      a[i].clear();\n      scanf(\"%lld\", &aa);\n      j = aa;\n      while (j--) {\n        scanf(\"%lld\", &m);\n        a[i].push_back(m);\n      }\n    }\n    long long flag = 0, val = -1;\n    for (i = 1; i <= n; i++) {\n      k = dfs(i);\n      if (k == -1) {\n        flag = 1;\n        break;\n      }\n      val = max(val, k);\n    }\n    if (flag)\n      printf(\"-1\\n\");\n    else\n      printf(\"%lld\\n\", val);\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict, deque\nimport sys\ninput = sys.stdin.readline\n\n\ndef solve():\n    num_chapters = int(input())\n    graph = defaultdict(set)\n    d_in = defaultdict(int)\n\n    for chapter in range(1, num_chapters+1):\n        line = list(map(int, input().split(\" \")))\n        d_in[chapter] += line[0]\n        \n        for j in range(1, line[0] + 1):\n            graph[line[j]].add(chapter)\n\n    # graph in the form:\n    # node -> set(required nodes)\n\n    return has_loop(graph, d_in, num_chapters)\n\ndef has_loop(graph, d_in, num_chapters):\n    counter = 0\n    queue = deque([])\n    \n    dists = defaultdict(lambda: 1)\n\n    # gather the unrequired nodes\n    for i in range(1, num_chapters + 1):\n        if d_in[i] == 0:\n            queue.append(i)\n\n    while queue:\n        current = queue.popleft()\n        counter += 1\n\n        for neighbor in graph[current]:\n            d_in[neighbor] -= 1\n            if neighbor < current:\n                dists[neighbor] = max(dists[neighbor], dists[current] + 1)\n            else:\n                dists[neighbor] = max(dists[neighbor], dists[current])\n            if d_in[neighbor] == 0:\n                queue.append(neighbor)\n\n    if counter != num_chapters:\n        return -1\n    if dists:\n        return max(dists.values())\n    return 1    \n\ndef main():\n    num_tests = int(input())\n    for t in range(1, num_tests+1):\n        print(solve())\n\nif __name__ == \"__main__\":\n    main()"
        },
        {
            "language": 3,
            "solution": "import collections\nimport sys\ninput = sys.stdin.readline\n\ndef explore(reqs, visited, post, post_visited, cycle, i):\n    visited[i] = True\n    for j in reqs[i]:\n        if not visited[j]:\n            cycle = cycle or explore(reqs, visited, post, post_visited, cycle, j)\n        elif not post_visited[j]:\n            cycle = True\n    post.append(i)\n    post_visited[i] = True\n    return cycle\n\ndef dfs(reqs, n):\n    visited = [False]*n\n    post = collections.deque()\n    post_visited = [False]*n\n    cycle = False\n    for i in range(n):\n        if not visited[i]:\n            cycle = cycle or explore(reqs, visited, post, post_visited, cycle, i)\n    return (cycle, post)\n\ndef check(reqs, n):\n    edges = [[] for i in range(n)]\n    for i in range(n):\n        for j in reqs[i]:\n            edges[j].append(i)\n    cycle, post = dfs(edges, n)\n    if cycle:\n        return -1\n    passes = [1]*n\n    while post:\n        i = post.pop()\n        for j in reqs[i]:\n            if j < i:\n                passes[i] = max(passes[i], passes[j])\n            else:\n                passes[i] = max(passes[i], passes[j] + 1)\n    return max(passes)\n\nt = int(input())\nresults = [0]*t\nfor i in range(t):\n    n = int(input())\n    reqs = []\n    for j in range(n):\n        reqs.append([int(k) - 1 for k in input().split()][1:])\n    results[i] = check(reqs, n)\nprint(\"\\n\".join([str(i) for i in results]))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ull = unsigned long long;\nvoid __print(int x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(long long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const char* x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const string& x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V>& x) {\n  cerr << '{';\n  __print(x.first);\n  cerr << ',';\n  __print(x.second);\n  cerr << '}';\n}\ntemplate <typename T>\nvoid __print(const T& x) {\n  int f = 0;\n  cerr << '{';\n  for (auto& i : x) cerr << (f++ ? \",\" : \"\"), __print(i);\n  cerr << \"}\";\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n  __print(t);\n  if (sizeof...(v)) cerr << \", \";\n  _print(v...);\n}\ntemplate <typename T>\nvoid print(vector<T> v) {\n  for (T i : v) cout << i << \" \";\n  cout << '\\n';\n}\ntemplate <typename T>\nvoid print(vector<vector<T>>& v) {\n  for (vector<T>& vv : v) {\n    for (T& i : vv) cout << i << \" \";\n    cout << '\\n';\n  }\n}\ntemplate <typename T>\nvoid read(vector<T>& v) {\n  for (T& i : v) cin >> i;\n}\ntemplate <typename T>\nvoid read(T&& t) {\n  cin >> t;\n}\ntemplate <typename T, typename... Args>\nvoid read(T&& t, Args&&... args) {\n  cin >> t;\n  read(forward<Args>(args)...);\n}\ntemplate <typename T>\nvoid print(T&& t) {\n  cout << t << '\\n';\n}\ntemplate <typename T, typename... Args>\nvoid print(T&& t, Args&&... args) {\n  cout << t << \" \";\n  print(forward<Args>(args)...);\n}\ntemplate <typename T>\nvector<T>& operator--(vector<T>& v) {\n  for (auto& i : v) --i;\n  return v;\n}\ntemplate <typename T>\nvector<T>& operator++(vector<T>& v) {\n  for (auto& i : v) ++i;\n  return v;\n}\ntemplate <typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (auto& i : v) is >> i;\n  return is;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, vector<T>& v) {\n  for (auto& i : v) os << i << ' ';\n  return os;\n}\nlong double pie = 3.141592653589793238462643383279502884197169399;\nlong long mod = 1e9 + 7;\nbool isprime(long long n) {\n  if (n <= 1) {\n    return false;\n  }\n  if (n <= 3) {\n    return true;\n  }\n  if (n % 2 == 0 || n % 3 == 0) {\n    return false;\n  }\n  for (long long i = 5; i * i <= n; i += 6) {\n    if (n % i == 0 || n % (i + 2) == 0) {\n      return false;\n    }\n  }\n  return true;\n}\nlong long binpow(long long a, long long b, long long m) {\n  a %= m;\n  long long res = 1;\n  while (b > 0) {\n    if (b & 1) res = (res * a) % m;\n    a = (a * a) % m;\n    b >>= 1;\n  }\n  return res;\n}\nlong long modInverse(long long n, long long mod) {\n  return binpow(n, mod - 2, mod);\n}\nlong long comb(long long n, long long r, long long p, vector<long long>& fac) {\n  if (r == 0 or n == r) return 1;\n  if (r > n) return 0;\n  return (fac[n] * modInverse(fac[r], p) % p * modInverse(fac[n - r], p) % p) %\n         p;\n}\nset<long long> divisors(long long n) {\n  set<long long> s;\n  for (long long i = 1; i * i <= n; i++) {\n    if (n % i == 0) {\n      s.insert(i);\n      s.insert(n / i);\n    }\n  }\n  return s;\n}\nlong long add(long long a, long long b, long long mod) {\n  a = a % mod;\n  b = b % mod;\n  return (((a + b) % mod) + mod) % mod;\n}\nlong long mul(long long a, long long b, long long mod) {\n  a = a % mod;\n  b = b % mod;\n  return (((a * b) % mod) + mod) % mod;\n}\nlong long sub(long long a, long long b, long long mod) {\n  a = a % mod;\n  b = b % mod;\n  return (((a - b) % mod) + mod) % mod;\n}\nmap<long long, long long> primeFactors(long long n) {\n  map<long long, long long> m;\n  while (n % 2 == 0) {\n    m[2]++;\n    n = n / 2;\n  }\n  for (long long i = 3; i <= sqrt(n); i = i + 2) {\n    while (n % i == 0) {\n      m[i]++;\n      n = n / i;\n    }\n  }\n  if (n > 2) m[n]++;\n  return m;\n}\nlong long C(long long n, long long r) {\n  long long res = 1;\n  for (long long i = 0; i < r; i++) {\n    res = res * (n - i) / (i + 1);\n  }\n  return res;\n}\nlong long toint(string s) {\n  long long num = 0;\n  for (long long i = 0; i < s.size(); i++) {\n    num = num * 10 + s[i] - '0';\n  }\n  return num;\n}\nlong long sumstring(string s) {\n  long long sum = 0;\n  for (long long i = 0; i < s.size(); i++) {\n    sum += (s[i] - '0');\n  }\n  return sum;\n}\nlong long sumdigit(long long n) {\n  long long sum = 0;\n  while (n) {\n    long long rem = n % 10;\n    sum += rem;\n    n /= 10;\n  }\n  return sum;\n}\nstring tobinary(long long x) {\n  string a;\n  while (x > 0) {\n    a += (x % 2) + '0';\n    x /= 2;\n  }\n  reverse(begin(a), end(a));\n  return a;\n}\nlong long todecimal(string x) {\n  long long sum = 0;\n  long long n = x.size();\n  long long j = 0;\n  for (long long i = n - 1; i >= 0; i--) {\n    if (x[i] == '1') {\n      sum += (1LL << j);\n    }\n    j++;\n  }\n  return sum;\n}\nlong long ceil(long long n, long long k) { return (n + k - 1) / k; }\nbool ispalin(string s) {\n  long long n = s.size();\n  for (long long i = 0; i < n; i++) {\n    if (s[i] != s[n - i - 1]) {\n      return false;\n    }\n  }\n  return true;\n}\nbool ispermutation(vector<long long> p) {\n  sort(begin(p), end(p));\n  for (long long i = 1; i <= p.size(); i++) {\n    if (p[i - 1] != i) return false;\n  }\n  return true;\n}\nbool isperfect(long long x) {\n  long long a = sqrtl(x);\n  return a * a == x;\n}\nbool issubsequence(string t, string x) {\n  long long j = 0;\n  for (long long i = 0; i < x.size(); i++) {\n    if (x[i] == t[j]) {\n      j++;\n    }\n    if (j == t.size()) break;\n  }\n  return j == t.size();\n}\nlong long power(long long base, long long exponent) {\n  long long res = 1;\n  while (exponent) {\n    if (exponent & 1) {\n      res = res * base;\n    }\n    base *= base;\n    exponent >>= 1;\n  }\n  return res;\n}\nbool comp(string s1, string s2) {\n  for (long long i = 0; i < s1.size(); i++) {\n    if (s1[i] == s2[i]) continue;\n    return s1[i] < s2[i];\n  }\n  return false;\n}\ndouble area(double dX0, double dY0, double dX1, double dY1, double dX2,\n            double dY2) {\n  double dArea = ((dX1 - dX0) * (dY2 - dY0) - (dX2 - dX0) * (dY1 - dY0)) / 2.0;\n  return (dArea > 0.0) ? dArea : -dArea;\n}\nlong long C(long long n, long long r, long long mod) {\n  long long ans = 1;\n  if (n - r < r) r = n - r;\n  for (long long i = n; i > n - r; i--) ans = mul(ans, i, mod);\n  for (long long i = 1; i <= r; i++) ans = mul(ans, modInverse(i, mod), mod);\n  return ans;\n}\nstruct Cmp {\n  bool operator()(const array<long long, 2>& l,\n                  const array<long long, 2>& r) const {\n    if (l[0] == r[0]) return l[1] < r[1];\n    return l[0] < r[0];\n  }\n};\nvoid loop() {\n  long long n;\n  cin >> n;\n  vector<vector<long long>> adj(n + 1);\n  vector<long long> indegree(n + 1);\n  long long total = n;\n  for (long long i = 1; i <= n; i++) {\n    long long z;\n    cin >> z;\n    for (long long j = 0; j < z; j++) {\n      long long x;\n      cin >> x;\n      indegree[i]++;\n      adj[x].push_back(i);\n    }\n  }\n  vector<long long> vis(n + 1);\n  queue<long long> q;\n  for (long long i = 1; i <= n; i++) {\n    if (indegree[i] == 0) {\n      q.push(i);\n      vis[i] = 1;\n    }\n  }\n  vector<long long> order;\n  while (q.size()) {\n    long long x = q.front();\n    q.pop();\n    total--;\n    order.push_back(x);\n    for (auto i : adj[x]) {\n      indegree[i]--;\n      if (indegree[i] == 0) q.push(i);\n    }\n  }\n  if (total) {\n    print(-1);\n    return;\n  } else {\n    vector<long long> dp(n + 1, 1);\n    for (auto i : order) {\n      for (auto j : adj[i]) {\n        if (j < i) {\n          dp[j] = max(dp[j], dp[i] + 1);\n        } else\n          dp[j] = max(dp[j], dp[i]);\n      }\n    }\n    print(*max_element(begin(dp), end(dp)));\n  }\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long t;\n  cin >> t;\n  while (t--) {\n    loop();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint T;\nint d[200005];\nint head[200005], net[2000005], v[2000000];\nint vis[200005];\nint tot = 0;\nint cnt = 0;\nint n;\nint f = 1;\nint ans[200005];\nint rans = 0;\npriority_queue<int, deque<int>, greater<int> > q;\npriority_queue<int, deque<int>, greater<int> > q2;\nvoid add(int x, int y) { tot++, v[tot] = y, net[tot] = head[x], head[x] = tot; }\nvoid init() {\n  f = 1;\n  tot = 0;\n  cnt = 0;\n  while (q2.size()) q2.pop();\n  for (int i = 1; i <= n; i++) {\n    d[i] = head[i] = vis[i] = 0;\n  }\n}\nvoid dfs() {\n  while (q.size()) {\n    rans++;\n    int lst = 0;\n    while (q.size()) {\n      int p = q.top();\n      vis[p] = 1;\n      q.pop();\n      if (lst > p) {\n        q2.push(p);\n      } else {\n        lst = p;\n        for (int i = head[p]; i; i = net[i]) {\n          int y = v[i];\n          d[y]--;\n          if (!d[y]) q.push(y);\n        }\n      }\n    }\n    if (q2.size()) {\n      swap(q, q2);\n    }\n  }\n}\nint main() {\n  scanf(\"%d\", &T);\n  while (T--) {\n    scanf(\"%d\", &n);\n    init();\n    rans = 0;\n    for (int i = 1; i <= n; i++) {\n      int t;\n      scanf(\"%d\", &t);\n      for (int j = 1; j <= t; j++) {\n        int t1;\n        scanf(\"%d\", &t1);\n        add(t1, i);\n        d[i]++;\n      }\n    }\n    for (int i = 1; i <= n; i++) {\n      if (d[i] == 0) q.push(i);\n    }\n    dfs();\n    for (int i = 1; i <= n; i++) {\n      if (!vis[i]) f = 0;\n    }\n    if (!f) {\n      printf(\"-1\\n\");\n      continue;\n    }\n    printf(\"%d\\n\", rans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename A, typename B>\nostream &operator<<(ostream &os, const pair<A, B> &p) {\n  return os << '(' << p.first << \", \" << p.second << ')';\n}\ntemplate <typename T_container, typename T = typename enable_if<\n                                    !is_same<T_container, string>::value,\n                                    typename T_container::value_type>::type>\nostream &operator<<(ostream &os, const T_container &v) {\n  os << '{';\n  string sep;\n  for (const T &x : v) os << sep << x, sep = \", \";\n  return os << '}';\n}\nvoid dbg_out() { cerr << \"\\n\"; }\ntemplate <typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n  cerr << ' ' << H;\n  dbg_out(T...);\n}\nvoid run_case() {\n  int N;\n  cin >> N;\n  vector<vector<int>> edges(N + 2);\n  vector<int> indegree(N + 2);\n  for (int i = 1; i <= N; i++) {\n    int x;\n    cin >> x;\n    for (int j = 1; j <= x; j++) {\n      int y;\n      cin >> y;\n      edges[y].push_back(i);\n      ++indegree[i];\n    }\n  }\n  set<int> q;\n  for (int i = 1; i <= N; i++) {\n    if (indegree[i] == 0) {\n      q.insert(i);\n    }\n  };\n  int cnt = 0, ans = 1, t = 1;\n  while (!q.empty()) {\n    auto it = q.lower_bound(ans);\n    if (it == q.end()) {\n      t++;\n      ans = 1;\n      continue;\n    }\n    int u = *it;\n    q.erase(it);\n    ans = u + 1;\n    ++cnt;\n    for (auto y : edges[u]) {\n      --indegree[y];\n      if (indegree[y] == 0) {\n        q.insert(y);\n      }\n    }\n  }\n  if (cnt != N) {\n    cout << \"-1\"\n         << \"\\n\";\n  } else {\n    cout << t << \"\\n\";\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int tests;\n  cin >> tests;\n  while (tests--) {\n    run_case();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class C {\n    static class Scan {\n        private byte[] buf=new byte[1024];\n        private int index;\n        private InputStream in;\n        private int total;\n        public Scan()\n        {\n            in=System.in;\n        }\n        public int scan()throws IOException\n        {\n            if(total<0)\n            throw new InputMismatchException();\n            if(index>=total)\n            {\n                index=0;\n                total=in.read(buf);\n                if(total<=0)\n                return -1;\n            }\n            return buf[index++];\n        }\n        public int scanInt()throws IOException\n        {\n            int integer=0;\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            int neg=1;\n            if(n=='-')\n            {\n                neg=-1;\n                n=scan();\n            }\n            while(!isWhiteSpace(n))\n            {\n                if(n>='0'&&n<='9')\n                {\n                    integer*=10;\n                    integer+=n-'0';\n                    n=scan();\n                }\n                else throw new InputMismatchException();\n            }\n            return neg*integer;\n        }\n        public double scanDouble()throws IOException\n        {\n            double doub=0;\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            int neg=1;\n            if(n=='-')\n            {\n                neg=-1;\n                n=scan();\n            }\n            while(!isWhiteSpace(n)&&n!='.')\n            {\n                if(n>='0'&&n<='9')\n                {\n                    doub*=10;\n                    doub+=n-'0';\n                    n=scan();\n                }\n                else throw new InputMismatchException();\n            }\n            if(n=='.')\n            {\n                n=scan();\n                double temp=1;\n                while(!isWhiteSpace(n))\n                {\n                    if(n>='0'&&n<='9')\n                    {\n                        temp/=10;\n                        doub+=(n-'0')*temp;\n                        n=scan();\n                    }\n                    else throw new InputMismatchException();\n                }\n            }\n            return doub*neg;\n        }\n        public String scanString()throws IOException\n        {\n            StringBuilder sb=new StringBuilder();\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            while(!isWhiteSpace(n))\n            {\n                sb.append((char)n);\n                n=scan();\n            }\n            return sb.toString();\n        }\n        private boolean isWhiteSpace(int n)\n        {\n            if(n==' '||n=='\\n'||n=='\\r'||n=='\\t'||n==-1)\n            return true;\n            return false;\n        }\n    }\n    \n    public static void sort(int arr[],int l,int r) {    //sort(arr,0,n-1);\n        if(l==r) {\n            return;\n        }\n        int mid=(l+r)/2;\n        sort(arr,l,mid);\n        sort(arr,mid+1,r);\n        merge(arr,l,mid,mid+1,r);\n    }\n    public static void merge(int arr[],int l1,int r1,int l2,int r2) {\n        int tmp[]=new int[r2-l1+1];\n        int indx1=l1,indx2=l2;\n        //sorting the two halves using a tmp array\n        for(int i=0;i<tmp.length;i++) {\n            if(indx1>r1) {\n                tmp[i]=arr[indx2];\n                indx2++;\n                continue;\n            }\n            if(indx2>r2) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            if(arr[indx1]<arr[indx2]) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            tmp[i]=arr[indx2];\n            indx2++;\n        }\n        //Copying the elements of tmp into the main array\n        for(int i=0,j=l1;i<tmp.length;i++,j++) {\n            arr[j]=tmp[i];\n        }\n    }\n    \n    public static void sort(long arr[],int l,int r) {    //sort(arr,0,n-1);\n        if(l==r) {\n            return;\n        }\n        int mid=(l+r)/2;\n        sort(arr,l,mid);\n        sort(arr,mid+1,r);\n        merge(arr,l,mid,mid+1,r);\n    }\n    public static void merge(long arr[],int l1,int r1,int l2,int r2) {\n        long tmp[]=new long[r2-l1+1];\n        int indx1=l1,indx2=l2;\n        //sorting the two halves using a tmp array\n        for(int i=0;i<tmp.length;i++) {\n            if(indx1>r1) {\n                tmp[i]=arr[indx2];\n                indx2++;\n                continue;\n            }\n            if(indx2>r2) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            if(arr[indx1]<arr[indx2]) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            tmp[i]=arr[indx2];\n            indx2++;\n        }\n        //Copying the elements of tmp into the main array\n        for(int i=0,j=l1;i<tmp.length;i++,j++) {\n            arr[j]=tmp[i];\n        }\n    }\n    \n    static ArrayList<Integer> adj_lst[];\n    static boolean vis[];\n    //-1->Black 0->White 1->Grey\n    static int color[];\n    static int dp[];\n    public static void main(String args[]) throws IOException {\n        Scan input=new Scan();\n        StringBuilder ans=new StringBuilder(\"\");\n        int test=input.scanInt();\n        for(int tt=1;tt<=test;tt++) {\n            int n=input.scanInt();\n            adj_lst=new ArrayList[n];\n            vis=new boolean[n];\n            color=new int[n];\n            dp=new int[n];\n            Arrays.fill(dp, -1);\n            for(int i=0;i<n;i++) {\n                adj_lst[i]=new ArrayList<>();\n            }\n            for(int i=0;i<n;i++) {\n                int k=input.scanInt();\n                for(int j=0;j<k;j++) {\n                    adj_lst[i].add(input.scanInt()-1);\n                }\n            }\n            boolean cyc=false;\n            for(int i=0;i<n;i++) {\n                if(vis[i]) {\n                    continue;\n                }\n                cyc|=mod_DFS(i);\n            }\n            if(cyc) {\n                ans.append(-1+\"\\n\");\n                continue;\n            }\n            vis=new boolean[n];\n            int max=0;\n            for(int i=0;i<n;i++) {\n                if(vis[i]) {\n                    continue;\n                }\n                max=Math.max(max,max_path(i));\n            }\n            ans.append(max+\"\\n\");\n        }\n        System.out.println(ans);\n    }\n    public static boolean mod_DFS(int root) {\n        color[root]=1;\n        vis[root]=true;\n        for(int i=0;i<adj_lst[root].size();i++) {\n            if(color[adj_lst[root].get(i)]==1) {\n                return true;\n            }\n            if(!vis[adj_lst[root].get(i)]) {\n                if(mod_DFS(adj_lst[root].get(i))) {\n                    return true;\n                }\n            }\n        }\n        color[root]=-1;\n        return false;\n    }\n    public static int max_path(int root) {\n        vis[root]=true;\n        if(dp[root]!=-1) {\n            return dp[root];\n        }\n        if(adj_lst[root].size()==0) {\n            dp[root]=1;\n            return dp[root];\n        }\n        int ans=0;\n        for(int i=0;i<adj_lst[root].size();i++) {\n            if(adj_lst[root].get(i)>root) {\n                ans=Math.max(ans, max_path(adj_lst[root].get(i))+1);\n            }\n            else {\n                ans=Math.max(ans, max_path(adj_lst[root].get(i)));\n            }\n        }\n//        ans++;\n        dp[root]=ans;\n        return dp[root];\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\nimport java.io.PrintStream;\n        \n            public class Solution {\n\n                public static boolean Local(){\n                    try{ \n                        return System.getenv(\"LOCAL_SYS\")!=null;\n                    }catch(Exception e){\n                        return false;\n                    }\n                }   \n\n                public static boolean LOCAL;\n\n                static class FastScanner {\n\n                        BufferedReader br;\n                        StringTokenizer st ;\n\n                        FastScanner(){\n                            br =  new BufferedReader(new InputStreamReader(System.in));\n                            st = new StringTokenizer(\"\");\n                        }\n\n                        FastScanner(String file) {\n\n                            try{\n                                br =  new BufferedReader(new InputStreamReader(new FileInputStream(file)));\n                                st = new StringTokenizer(\"\");\n                            }catch(FileNotFoundException e) {\n                                // TODO Auto-generated catch block\n                                System.out.println(\"file not found\");\n                                e.printStackTrace();\n                            }\n                            \n                        }\n                        \n\n                        String next() {\n                            while (!st.hasMoreTokens())\n                                try {\n                                    st = new StringTokenizer(br.readLine());\n                                } catch (IOException e) {\n                                }\n                            return st.nextToken();\n                        }\n\n                        int nextInt() {\n                            return Integer.parseInt(next());\n                        }\n\n                        long nextLong() {\n                            return Long.parseLong(next());\n                        }\n                        String readLine() throws IOException{\n                            return br.readLine();\n                        }\n                    }\n                                        \n                static class Pair<T,X> {\n\n                    T first;\n                    X second;\n                    \n                    Pair(T first,X second){\n                        this.first = first;\n                        this.second = second;\n                    }\n\n                    @Override\n                    public int hashCode(){\n                        return Objects.hash(first,second);\n                    }\n\n                    @Override\n                    public boolean equals(Object obj){\n                        return obj.hashCode() == this.hashCode();\n                    }\n\n                }\n\n            \n            static PrintStream debug = null;\n            \n            \n            static long mod = (long)(Math.pow(10,9) + 7); \n            \n\n            public static void main(String[] args) throws Exception {\n                \n                FastScanner s = new FastScanner();\n\n                LOCAL = Local();\n\n                \n                if(LOCAL){\n                    s = new FastScanner(\"src/input.txt\");\n                    PrintStream o = new PrintStream(\"src/sampleout.txt\");\n                    debug = new PrintStream(\"src/debug.txt\");\n                    System.setOut(o);\n                }\n\n                \n                long mod = 1000000007;\n\n            \n                int tcr = s.nextInt();                  \n                \n                StringBuilder sb = new StringBuilder();\n\n\n                for(int tc=0;tc<tcr;tc++){\n                    \n                    PriorityQueue<Integer> pq = new PriorityQueue<>();\n\n                    int n = s.nextInt();\n\n                    List<List<Integer>> list = new ArrayList<>();\n\n                    for(int i=0;i<n;i++){\n                        list.add(new ArrayList<>());\n                    }\n\n                    int indegree[] = new int[n];\n\n                    for(int i=0;i<n;i++){\n                        int k = s.nextInt();\n                        indegree[i] = k;\n                        if(k==0){\n                            pq.add(i);\n                        }\n                        for(int j=0;j<k;j++){\n                            int v = s.nextInt();\n                            v--;\n                            list.get(v).add(i);\n                        }\n                    }\n\n                  \n\n                    if(pq.size() == 0){\n                        sb.append(-1);\n                        sb.append('\\n');\n                        continue;\n                    }\n\n\n                    int read = 0;\n\n                    PriorityQueue<Integer> next = new PriorityQueue<>();\n\n                    Set<Integer> set = new HashSet<>();\n\n                    while(!pq.isEmpty()){\n\n                        \n                        read++;\n\n                        while(!pq.isEmpty()){\n\n                            int curr = pq.poll();\n\n                            set.add(curr);\n\n                            for(int v : list.get(curr)){\n                                indegree[v]--;\n                                if((indegree[v]==0)){\n                                    if(v < curr){\n                                        next.add(v);\n                                    }else{\n                                        pq.add(v);\n                                    }\n                                }\n                            }\n\n                        }\n\n                        // debug(debug,set);\n                        // dbg(debug,next);\n\n                        pq = next;\n                        next = new PriorityQueue<>();\n                    }\n\n                    if(set.size() == n){\n                         sb.append(read);\n                    }else{\n                        sb.append(-1);\n                    }\n                    sb.append('\\n');\n                }\n\n                print(sb.toString());\n\n            }\n\n            public static boolean inRange(int r1,int r2,int val){\n                return ((val >= r1) && (val <= r2));\n            }\n\n            static int len(long num){\n                return Long.toString(num).length();\n            }\n\n            static long mulmod(long a, long b,long mod)\n            {\n                long ans = 0l;\n                \n                while(b > 0){\n                    long curr = (b & 1l);\n                    if(curr == 1l){\n                        ans = ((ans % mod) + a) % mod;\n                    }\n                    \n                    a = (a + a) % mod;\n\n                    b = b >> 1;\n                }\n\n                return ans;\n            }\n\n\n            public static void dbg(PrintStream ps,Object... o) throws Exception{\n                if(ps == null){\n                    return;\n                }\n                Debug.dbg(ps,o);\n            }\n\n            public static long modpow(long num,long pow,long mod){\n\n                long val = num;\n                long ans = 1l;\n\n                while(pow > 0l){\n                    \n                    long bit = pow & 1l;\n\n                    if(bit == 1){\n                        ans = (ans * (val%mod))%mod;\n                    }\n\n                    val = (val * val) % mod;\n                    pow = pow >> 1;\n                }\n\n                return ans;\n\n            }\n\n            public static char get(int n){\n                return (char)('a' + n);\n            }\n\n            public static long[] sort(long arr[]){\n                List<Long> list = new ArrayList<>();\n                for(long n : arr){list.add(n);}\n                Collections.sort(list);\n                for(int i=0;i<arr.length;i++){\n                    arr[i] = list.get(i);\n                }\n                return arr;\n            }\n\n            public static int[] sort(int arr[]){\n                List<Integer> list = new ArrayList<>();\n                for(int n : arr){list.add(n);}\n                Collections.sort(list);\n                for(int i=0;i<arr.length;i++){\n                    arr[i] = list.get(i);\n                }\n                return arr;\n            }\n\n            // return the (index + 1)\n            // where index is the pos of just smaller element\n            // i.e count of elemets strictly less than num\n            public static int justSmaller(long arr[],long num){\n                //  System.out.println(num+\"@\");\n                int st = 0;\n                int e = arr.length - 1;\n        \n                int ans = -1;\n        \n                while(st <= e){\n        \n                    int mid = (st + e)/2;\n        \n                    if(arr[mid] >= num){\n                        e = mid - 1;\n                    }else{\n                        ans = mid;\n                        st = mid + 1;\n                    }\n        \n                }\n        \n        \n                return ans + 1;\n        \n            }\n            public static int justSmaller(int arr[],int num){\n                //  System.out.println(num+\"@\");\n                int st = 0;\n                int e = arr.length - 1;\n        \n                int ans = -1;\n        \n                while(st <= e){\n        \n                    int mid = (st + e)/2;\n        \n                    if(arr[mid] >= num){\n                        e = mid - 1;\n                    }else{\n                        ans = mid;\n                        st = mid + 1;\n                    }\n        \n                }\n        \n        \n                return ans + 1;\n        \n            }\n            \n            //return (index of just greater element)\n            //count of elements smaller than or equal to num\n\n            public static int justGreater(long arr[],long num){\n                int st = 0;\n                int e = arr.length - 1;\n        \n                int ans = arr.length;\n        \n                while(st <= e){\n                    \n                    int mid = (st + e)/2;\n        \n                    if(arr[mid] <= num){\n                        st = mid + 1;\n                    }else{\n                        ans = mid;\n                        e = mid - 1;\n                    }\n                }\n        \n                return ans;\n        \n            }\n\n            public static int justGreater(int arr[],int num){\n                int st = 0;\n                int e = arr.length - 1;\n        \n                int ans = arr.length;\n        \n                while(st <= e){\n                    \n                    int mid = (st + e)/2;\n        \n                    if(arr[mid] <= num){\n                        st = mid + 1;\n                    }else{\n                        ans = mid;\n                        e = mid - 1;\n                    }\n                }\n        \n                return ans;\n        \n            }\n        \n            \n\n            public static void println(Object obj){\n                System.out.println(obj.toString());\n            }\n\n            public static void print(Object obj){\n                System.out.print(obj.toString());\n            }\n\n            public static int gcd(int a,int b){\n                if(b == 0){return a;}\n                return gcd(b,a%b);\n            }\n\n            public static long gcd(long a,long b){\n                if(b == 0l){\n                    return a;\n                }\n\n                return gcd(b,a%b);\n            }\n\n            public static int find(int parent[],int v){\n                if(parent[v] == v){\n                    return v;\n                }\n                \n                return parent[v] = find(parent, parent[v]);\n            }\n\n        \n\n            public static List<Integer> sieve(){\n            \n                    List<Integer> prime = new ArrayList<>();\n\n                    int arr[] = new int[100001];\n\n                Arrays.fill(arr,1);\n\n                arr[1] = 0;\n                arr[2] = 1;\n\n                for(int i=2;i<=100000;i++){\n                    \n                    if(arr[i] == 1){\n                        \n                        prime.add(i);\n\n                        for(long j = (i*1l*i);j<100001;j+=i){\n                            arr[(int)j] = 0;\n                        }\n                    }\n                }\n\n                return prime;\n            }\n\n            static boolean isPower(long n,long a){\n                \n                long log = (long)(Math.log(n)/Math.log(a));\n\n                long power = (long)Math.pow(a,log);\n\n                if(power == n){return true;}\n\n                return false;\n            }\n\n\n            private static int mergeAndCount(int[] arr, int l,int m, int r)\n            {\n\n                // Left subarray\n                int[] left =  Arrays.copyOfRange(arr, l, m + 1);\n\n                // Right subarray\n                int[] right = Arrays.copyOfRange(arr, m + 1, r + 1);\n\n                int i = 0, j = 0, k = l, swaps = 0;\n\n                while (i < left.length && j < right.length) {\n                    if (left[i] <= right[j])\n                        arr[k++] = left[i++];\n                    else {\n                        arr[k++] = right[j++];\n                        swaps += (m + 1) - (l + i);\n                    }\n                }\n                while (i < left.length)\n                    arr[k++] = left[i++];\n                while (j < right.length)\n                    arr[k++] = right[j++];\n                return swaps;\n            }\n\n            // Merge sort function\n            private static int mergeSortAndCount(int[] arr, int l,int r)\n            {\n\n                // Keeps track of the inversion count at a\n                // particular node of the recursion tree\n                int count = 0;\n\n                if (l < r) {\n                    int m = (l + r) / 2;\n\n                    // Total inversion count = left subarray count\n                    // + right subarray count + merge count\n\n                    // Left subarray count\n                    count += mergeSortAndCount(arr, l, m);\n\n                    // Right subarray count\n                    count += mergeSortAndCount(arr, m + 1, r);\n\n                    // Merge count\n                    count += mergeAndCount(arr, l, m, r);\n                }\n\n                return count;\n            }\n\n            static class Debug{\n                //change to System.getProperty(\"ONLINE_JUDGE\")==null; for CodeForces\n                public static final boolean LOCAL = System.getProperty(\"ONLINE_JUDGE\")==null;\n\n                \n\n                private static <T> String ts(T t) {\n                    if(t==null) {\n                        return \"null\";\n                    }\n                    try {\n                        return ts((Iterable) t);\n                    }catch(ClassCastException e) {\n                        if(t instanceof int[]) {\n                            String s = Arrays.toString((int[]) t);\n                            return \"{\"+s.substring(1, s.length()-1)+\"}\\n\";\n                        }else if(t instanceof long[]) {\n                            String s = Arrays.toString((long[]) t);\n                            return \"{\"+s.substring(1, s.length()-1)+\"}\\n\";\n                        }else if(t instanceof char[]) {\n                            String s = Arrays.toString((char[]) t);\n                            return \"{\"+s.substring(1, s.length()-1)+\"}\\n\";\n                        }else if(t instanceof double[]) {\n                            String s = Arrays.toString((double[]) t);\n                            return \"{\"+s.substring(1, s.length()-1)+\"}\\n\";\n                        }else if(t instanceof boolean[]) {\n                            String s = Arrays.toString((boolean[]) t);\n                            return \"{\"+s.substring(1, s.length()-1)+\"}\\n\";\n                        }\n                        try {\n                            return ts((Object[]) t);\n                        }catch(ClassCastException e1) {\n                            return t.toString();\n                        }\n                    }\n                }\n                private static <T> String ts(T[] arr) {\n                    StringBuilder ret = new StringBuilder();\n                    ret.append(\"{\");\n                    boolean first = true;\n                    for(T t: arr) {\n                        if(!first) {\n                            ret.append(\", \");\n                        }\n                        first = false;\n                        ret.append(ts(t));\n                    }\n                    ret.append(\"}\");\n                    return ret.toString();\n                }\n                private static <T> String ts(Iterable<T> iter) {\n                    StringBuilder ret = new StringBuilder();\n                    ret.append(\"{\");\n                    boolean first = true;\n                    for(T t: iter) {\n                        if(!first) {\n                            ret.append(\", \");\n                        }\n                        first = false;\n                        ret.append(ts(t));\n                    }\n                    ret.append(\"}\");\n                    return ret.toString();\n                }\n                public static void dbg(PrintStream ps,Object... o) throws Exception {\n                    if(LOCAL) {\n                        System.setErr(ps);\n                        System.err.print(\"Line #\"+Thread.currentThread().getStackTrace()[2].getLineNumber()+\": [\");\n                        for(int i = 0; i<o.length; i++) {\n                            if(i!=0) {\n                                System.err.print(\", \");\n                            }\n                            System.err.print(ts(o[i]));\n                        }\n                        System.err.println(\"]\");\n                    }\n                }\n            }\n\n    }"
        },
        {
            "language": 3,
            "solution": "import os, sys\nfrom io import BytesIO, IOBase\n\n\nimport traceback\nfrom bisect import bisect_left, bisect_right, insort\nfrom itertools import chain, repeat, starmap\nfrom math import log\nfrom operator import add, eq, ne, gt, ge, lt, le, iadd\nfrom textwrap import dedent\nfrom collections.abc import Sequence, MutableSequence\nfrom functools import wraps,reduce\nfrom _thread import get_ident\n\n\ndef recursive_repr(fillvalue='...'):\n    \"Decorator to make a repr function return fillvalue for a recursive call.\"\n\n    # pylint: disable=missing-docstring\n    # Copied from reprlib in Python 3\n    # https://hg.python.org/cpython/file/3.6/Lib/reprlib.py\n\n    def decorating_function(user_function):\n        repr_running = set()\n\n        @wraps(user_function)\n        def wrapper(self):\n            key = id(self), get_ident()\n            if key in repr_running:\n                return fillvalue\n            repr_running.add(key)\n            try:\n                result = user_function(self)\n            finally:\n                repr_running.discard(key)\n            return result\n\n        return wrapper\n\n    return decorating_function\n\n\nclass SortedList(MutableSequence):\n    DEFAULT_LOAD_FACTOR = 1000\n\n    def __init__(self, iterable=None, key=None):\n        assert key is None\n        self._len = 0\n        self._load = self.DEFAULT_LOAD_FACTOR\n        self._lists = []\n        self._maxes = []\n        self._index = []\n        self._offset = 0\n\n        if iterable is not None:\n            self._update(iterable)\n\n    def __new__(cls, iterable=None, key=None):\n        if key is None:\n            return object.__new__(cls)\n        else:\n            if cls is SortedList:\n                return object.__new__(SortedKeyList)\n            else:\n                raise TypeError('inherit SortedKeyList for key argument')\n\n    @property\n    def key(self):  # pylint: disable=useless-return\n        return None\n\n    def _reset(self, load):\n        values = reduce(iadd, self._lists, [])\n        self._clear()\n        self._load = load\n        self._update(values)\n\n    def clear(self):\n        self._len = 0\n        del self._lists[:]\n        del self._maxes[:]\n        del self._index[:]\n        self._offset = 0\n\n    _clear = clear\n\n    def add(self, value):\n        _lists = self._lists\n        _maxes = self._maxes\n\n        if _maxes:\n            pos = bisect_right(_maxes, value)\n\n            if pos == len(_maxes):\n                pos -= 1\n                _lists[pos].append(value)\n                _maxes[pos] = value\n            else:\n                insort(_lists[pos], value)\n\n            self._expand(pos)\n        else:\n            _lists.append([value])\n            _maxes.append(value)\n\n        self._len += 1\n\n    def _expand(self, pos):\n        _load = self._load\n        _lists = self._lists\n        _index = self._index\n\n        if len(_lists[pos]) > (_load << 1):\n            _maxes = self._maxes\n\n            _lists_pos = _lists[pos]\n            half = _lists_pos[_load:]\n            del _lists_pos[_load:]\n            _maxes[pos] = _lists_pos[-1]\n\n            _lists.insert(pos + 1, half)\n            _maxes.insert(pos + 1, half[-1])\n\n            del _index[:]\n        else:\n            if _index:\n                child = self._offset + pos\n                while child:\n                    _index[child] += 1\n                    child = (child - 1) >> 1\n                _index[0] += 1\n\n    def update(self, iterable):\n        _lists = self._lists\n        _maxes = self._maxes\n        values = sorted(iterable)\n\n        if _maxes:\n            if len(values) * 4 >= self._len:\n                _lists.append(values)\n                values = reduce(iadd, _lists, [])\n                values.sort()\n                self._clear()\n            else:\n                _add = self.add\n                for val in values:\n                    _add(val)\n                return\n\n        _load = self._load\n        _lists.extend(values[pos:(pos + _load)]\n                      for pos in range(0, len(values), _load))\n        _maxes.extend(sublist[-1] for sublist in _lists)\n        self._len = len(values)\n        del self._index[:]\n\n    _update = update\n\n    def __contains__(self, value):\n        _maxes = self._maxes\n\n        if not _maxes:\n            return False\n\n        pos = bisect_left(_maxes, value)\n\n        if pos == len(_maxes):\n            return False\n\n        _lists = self._lists\n        idx = bisect_left(_lists[pos], value)\n\n        return _lists[pos][idx] == value\n\n    def discard(self, value):\n        _maxes = self._maxes\n\n        if not _maxes:\n            return\n\n        pos = bisect_left(_maxes, value)\n\n        if pos == len(_maxes):\n            return\n\n        _lists = self._lists\n        idx = bisect_left(_lists[pos], value)\n\n        if _lists[pos][idx] == value:\n            self._delete(pos, idx)\n\n    def remove(self, value):\n        _maxes = self._maxes\n\n        if not _maxes:\n            raise ValueError('{0!r} not in list'.format(value))\n\n        pos = bisect_left(_maxes, value)\n\n        if pos == len(_maxes):\n            raise ValueError('{0!r} not in list'.format(value))\n\n        _lists = self._lists\n        idx = bisect_left(_lists[pos], value)\n\n        if _lists[pos][idx] == value:\n            self._delete(pos, idx)\n        else:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def _delete(self, pos, idx):\n        _lists = self._lists\n        _maxes = self._maxes\n        _index = self._index\n\n        _lists_pos = _lists[pos]\n\n        del _lists_pos[idx]\n        self._len -= 1\n\n        len_lists_pos = len(_lists_pos)\n\n        if len_lists_pos > (self._load >> 1):\n            _maxes[pos] = _lists_pos[-1]\n\n            if _index:\n                child = self._offset + pos\n                while child > 0:\n                    _index[child] -= 1\n                    child = (child - 1) >> 1\n                _index[0] -= 1\n        elif len(_lists) > 1:\n            if not pos:\n                pos += 1\n\n            prev = pos - 1\n            _lists[prev].extend(_lists[pos])\n            _maxes[prev] = _lists[prev][-1]\n\n            del _lists[pos]\n            del _maxes[pos]\n            del _index[:]\n\n            self._expand(prev)\n        elif len_lists_pos:\n            _maxes[pos] = _lists_pos[-1]\n        else:\n            del _lists[pos]\n            del _maxes[pos]\n            del _index[:]\n\n    def _loc(self, pos, idx):\n        if not pos:\n            return idx\n\n        _index = self._index\n\n        if not _index:\n            self._build_index()\n\n        total = 0\n\n        # Increment pos to point in the index to len(self._lists[pos]).\n\n        pos += self._offset\n\n        # Iterate until reaching the root of the index tree at pos = 0.\n\n        while pos:\n\n            # Right-child nodes are at odd indices. At such indices\n            # account the total below the left child node.\n\n            if not pos & 1:\n                total += _index[pos - 1]\n\n            # Advance pos to the parent node.\n\n            pos = (pos - 1) >> 1\n\n        return total + idx\n\n    def _pos(self, idx):\n        if idx < 0:\n            last_len = len(self._lists[-1])\n\n            if (-idx) <= last_len:\n                return len(self._lists) - 1, last_len + idx\n\n            idx += self._len\n\n            if idx < 0:\n                raise IndexError('list index out of range')\n        elif idx >= self._len:\n            raise IndexError('list index out of range')\n\n        if idx < len(self._lists[0]):\n            return 0, idx\n\n        _index = self._index\n\n        if not _index:\n            self._build_index()\n\n        pos = 0\n        child = 1\n        len_index = len(_index)\n\n        while child < len_index:\n            index_child = _index[child]\n\n            if idx < index_child:\n                pos = child\n            else:\n                idx -= index_child\n                pos = child + 1\n\n            child = (pos << 1) + 1\n\n        return (pos - self._offset, idx)\n\n    def _build_index(self):\n        row0 = list(map(len, self._lists))\n\n        if len(row0) == 1:\n            self._index[:] = row0\n            self._offset = 0\n            return\n\n        head = iter(row0)\n        tail = iter(head)\n        row1 = list(starmap(add, zip(head, tail)))\n\n        if len(row0) & 1:\n            row1.append(row0[-1])\n\n        if len(row1) == 1:\n            self._index[:] = row1 + row0\n            self._offset = 1\n            return\n\n        size = 2 ** (int(log(len(row1) - 1, 2)) + 1)\n        row1.extend(repeat(0, size - len(row1)))\n        tree = [row0, row1]\n\n        while len(tree[-1]) > 1:\n            head = iter(tree[-1])\n            tail = iter(head)\n            row = list(starmap(add, zip(head, tail)))\n            tree.append(row)\n\n        reduce(iadd, reversed(tree), self._index)\n        self._offset = size * 2 - 1\n\n    def __delitem__(self, index):\n        if isinstance(index, slice):\n            start, stop, step = index.indices(self._len)\n\n            if step == 1 and start < stop:\n                if start == 0 and stop == self._len:\n                    return self._clear()\n                elif self._len <= 8 * (stop - start):\n                    values = self._getitem(slice(None, start))\n                    if stop < self._len:\n                        values += self._getitem(slice(stop, None))\n                    self._clear()\n                    return self._update(values)\n\n            indices = range(start, stop, step)\n\n            # Delete items from greatest index to least so\n            # that the indices remain valid throughout iteration.\n\n            if step > 0:\n                indices = reversed(indices)\n\n            _pos, _delete = self._pos, self._delete\n\n            for index in indices:\n                pos, idx = _pos(index)\n                _delete(pos, idx)\n        else:\n            pos, idx = self._pos(index)\n            self._delete(pos, idx)\n\n    def __getitem__(self, index):\n        _lists = self._lists\n\n        if isinstance(index, slice):\n            start, stop, step = index.indices(self._len)\n\n            if step == 1 and start < stop:\n                # Whole slice optimization: start to stop slices the whole\n                # sorted list.\n\n                if start == 0 and stop == self._len:\n                    return reduce(iadd, self._lists, [])\n\n                start_pos, start_idx = self._pos(start)\n                start_list = _lists[start_pos]\n                stop_idx = start_idx + stop - start\n\n                # Small slice optimization: start index and stop index are\n                # within the start list.\n\n                if len(start_list) >= stop_idx:\n                    return start_list[start_idx:stop_idx]\n\n                if stop == self._len:\n                    stop_pos = len(_lists) - 1\n                    stop_idx = len(_lists[stop_pos])\n                else:\n                    stop_pos, stop_idx = self._pos(stop)\n\n                prefix = _lists[start_pos][start_idx:]\n                middle = _lists[(start_pos + 1):stop_pos]\n                result = reduce(iadd, middle, prefix)\n                result += _lists[stop_pos][:stop_idx]\n\n                return result\n\n            if step == -1 and start > stop:\n                result = self._getitem(slice(stop + 1, start + 1))\n                result.reverse()\n                return result\n\n            # Return a list because a negative step could\n            # reverse the order of the items and this could\n            # be the desired behavior.\n\n            indices = range(start, stop, step)\n            return list(self._getitem(index) for index in indices)\n        else:\n            if self._len:\n                if index == 0:\n                    return _lists[0][0]\n                elif index == -1:\n                    return _lists[-1][-1]\n            else:\n                raise IndexError('list index out of range')\n\n            if 0 <= index < len(_lists[0]):\n                return _lists[0][index]\n\n            len_last = len(_lists[-1])\n\n            if -len_last < index < 0:\n                return _lists[-1][len_last + index]\n\n            pos, idx = self._pos(index)\n            return _lists[pos][idx]\n\n    _getitem = __getitem__\n\n    def __setitem__(self, index, value):\n        message = 'use ``del sl[index]`` and ``sl.add(value)`` instead'\n        raise NotImplementedError(message)\n\n    def __iter__(self):\n        return chain.from_iterable(self._lists)\n\n    def __reversed__(self):\n        return chain.from_iterable(map(reversed, reversed(self._lists)))\n\n    def reverse(self):\n        raise NotImplementedError('use ``reversed(sl)`` instead')\n\n    def islice(self, start=None, stop=None, reverse=False):\n        _len = self._len\n\n        if not _len:\n            return iter(())\n\n        start, stop, _ = slice(start, stop).indices(self._len)\n\n        if start >= stop:\n            return iter(())\n\n        _pos = self._pos\n\n        min_pos, min_idx = _pos(start)\n\n        if stop == _len:\n            max_pos = len(self._lists) - 1\n            max_idx = len(self._lists[-1])\n        else:\n            max_pos, max_idx = _pos(stop)\n\n        return self._islice(min_pos, min_idx, max_pos, max_idx, reverse)\n\n    def _islice(self, min_pos, min_idx, max_pos, max_idx, reverse):\n        _lists = self._lists\n\n        if min_pos > max_pos:\n            return iter(())\n\n        if min_pos == max_pos:\n            if reverse:\n                indices = reversed(range(min_idx, max_idx))\n                return map(_lists[min_pos].__getitem__, indices)\n\n            indices = range(min_idx, max_idx)\n            return map(_lists[min_pos].__getitem__, indices)\n\n        next_pos = min_pos + 1\n\n        if next_pos == max_pos:\n            if reverse:\n                min_indices = range(min_idx, len(_lists[min_pos]))\n                max_indices = range(max_idx)\n                return chain(\n                    map(_lists[max_pos].__getitem__, reversed(max_indices)),\n                    map(_lists[min_pos].__getitem__, reversed(min_indices)),\n                )\n\n            min_indices = range(min_idx, len(_lists[min_pos]))\n            max_indices = range(max_idx)\n            return chain(\n                map(_lists[min_pos].__getitem__, min_indices),\n                map(_lists[max_pos].__getitem__, max_indices),\n            )\n\n        if reverse:\n            min_indices = range(min_idx, len(_lists[min_pos]))\n            sublist_indices = range(next_pos, max_pos)\n            sublists = map(_lists.__getitem__, reversed(sublist_indices))\n            max_indices = range(max_idx)\n            return chain(\n                map(_lists[max_pos].__getitem__, reversed(max_indices)),\n                chain.from_iterable(map(reversed, sublists)),\n                map(_lists[min_pos].__getitem__, reversed(min_indices)),\n            )\n\n        min_indices = range(min_idx, len(_lists[min_pos]))\n        sublist_indices = range(next_pos, max_pos)\n        sublists = map(_lists.__getitem__, sublist_indices)\n        max_indices = range(max_idx)\n        return chain(\n            map(_lists[min_pos].__getitem__, min_indices),\n            chain.from_iterable(sublists),\n            map(_lists[max_pos].__getitem__, max_indices),\n        )\n\n    def irange(self, minimum=None, maximum=None, inclusive=(True, True),\n               reverse=False):\n        _maxes = self._maxes\n\n        if not _maxes:\n            return iter(())\n\n        _lists = self._lists\n\n        # Calculate the minimum (pos, idx) pair. By default this location\n        # will be inclusive in our calculation.\n\n        if minimum is None:\n            min_pos = 0\n            min_idx = 0\n        else:\n            if inclusive[0]:\n                min_pos = bisect_left(_maxes, minimum)\n\n                if min_pos == len(_maxes):\n                    return iter(())\n\n                min_idx = bisect_left(_lists[min_pos], minimum)\n            else:\n                min_pos = bisect_right(_maxes, minimum)\n\n                if min_pos == len(_maxes):\n                    return iter(())\n\n                min_idx = bisect_right(_lists[min_pos], minimum)\n\n        # Calculate the maximum (pos, idx) pair. By default this location\n        # will be exclusive in our calculation.\n\n        if maximum is None:\n            max_pos = len(_maxes) - 1\n            max_idx = len(_lists[max_pos])\n        else:\n            if inclusive[1]:\n                max_pos = bisect_right(_maxes, maximum)\n\n                if max_pos == len(_maxes):\n                    max_pos -= 1\n                    max_idx = len(_lists[max_pos])\n                else:\n                    max_idx = bisect_right(_lists[max_pos], maximum)\n            else:\n                max_pos = bisect_left(_maxes, maximum)\n\n                if max_pos == len(_maxes):\n                    max_pos -= 1\n                    max_idx = len(_lists[max_pos])\n                else:\n                    max_idx = bisect_left(_lists[max_pos], maximum)\n\n        return self._islice(min_pos, min_idx, max_pos, max_idx, reverse)\n\n    def __len__(self):\n        return self._len\n\n    def bisect_left(self, value):\n        _maxes = self._maxes\n\n        if not _maxes:\n            return 0\n\n        pos = bisect_left(_maxes, value)\n\n        if pos == len(_maxes):\n            return self._len\n\n        idx = bisect_left(self._lists[pos], value)\n        return self._loc(pos, idx)\n\n    def bisect_right(self, value):\n        _maxes = self._maxes\n\n        if not _maxes:\n            return 0\n\n        pos = bisect_right(_maxes, value)\n\n        if pos == len(_maxes):\n            return self._len\n\n        idx = bisect_right(self._lists[pos], value)\n        return self._loc(pos, idx)\n\n    bisect = bisect_right\n    _bisect_right = bisect_right\n\n    def count(self, value):\n        _maxes = self._maxes\n\n        if not _maxes:\n            return 0\n\n        pos_left = bisect_left(_maxes, value)\n\n        if pos_left == len(_maxes):\n            return 0\n\n        _lists = self._lists\n        idx_left = bisect_left(_lists[pos_left], value)\n        pos_right = bisect_right(_maxes, value)\n\n        if pos_right == len(_maxes):\n            return self._len - self._loc(pos_left, idx_left)\n\n        idx_right = bisect_right(_lists[pos_right], value)\n\n        if pos_left == pos_right:\n            return idx_right - idx_left\n\n        right = self._loc(pos_right, idx_right)\n        left = self._loc(pos_left, idx_left)\n        return right - left\n\n    def copy(self):\n        return self.__class__(self)\n\n    __copy__ = copy\n\n    def append(self, value):\n        raise NotImplementedError('use ``sl.add(value)`` instead')\n\n    def extend(self, values):\n        raise NotImplementedError('use ``sl.update(values)`` instead')\n\n    def insert(self, index, value):\n        raise NotImplementedError('use ``sl.add(value)`` instead')\n\n    def pop(self, index=-1):\n        if not self._len:\n            raise IndexError('pop index out of range')\n\n        _lists = self._lists\n\n        if index == 0:\n            val = _lists[0][0]\n            self._delete(0, 0)\n            return val\n\n        if index == -1:\n            pos = len(_lists) - 1\n            loc = len(_lists[pos]) - 1\n            val = _lists[pos][loc]\n            self._delete(pos, loc)\n            return val\n\n        if 0 <= index < len(_lists[0]):\n            val = _lists[0][index]\n            self._delete(0, index)\n            return val\n\n        len_last = len(_lists[-1])\n\n        if -len_last < index < 0:\n            pos = len(_lists) - 1\n            loc = len_last + index\n            val = _lists[pos][loc]\n            self._delete(pos, loc)\n            return val\n\n        pos, idx = self._pos(index)\n        val = _lists[pos][idx]\n        self._delete(pos, idx)\n        return val\n\n    def index(self, value, start=None, stop=None):\n        _len = self._len\n\n        if not _len:\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        if start is None:\n            start = 0\n        if start < 0:\n            start += _len\n        if start < 0:\n            start = 0\n\n        if stop is None:\n            stop = _len\n        if stop < 0:\n            stop += _len\n        if stop > _len:\n            stop = _len\n\n        if stop <= start:\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        _maxes = self._maxes\n        pos_left = bisect_left(_maxes, value)\n\n        if pos_left == len(_maxes):\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        _lists = self._lists\n        idx_left = bisect_left(_lists[pos_left], value)\n\n        if _lists[pos_left][idx_left] != value:\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        stop -= 1\n        left = self._loc(pos_left, idx_left)\n\n        if start <= left:\n            if left <= stop:\n                return left\n        else:\n            right = self._bisect_right(value) - 1\n\n            if start <= right:\n                return start\n\n        raise ValueError('{0!r} is not in list'.format(value))\n\n    def __add__(self, other):\n        values = reduce(iadd, self._lists, [])\n        values.extend(other)\n        return self.__class__(values)\n\n    __radd__ = __add__\n\n    def __iadd__(self, other):\n        self._update(other)\n        return self\n\n    def __mul__(self, num):\n        values = reduce(iadd, self._lists, []) * num\n        return self.__class__(values)\n\n    __rmul__ = __mul__\n\n    def __imul__(self, num):\n        values = reduce(iadd, self._lists, []) * num\n        self._clear()\n        self._update(values)\n        return self\n\n    def __make_cmp(seq_op, symbol, doc):\n        \"Make comparator method.\"\n\n        def comparer(self, other):\n            \"Compare method for sorted list and sequence.\"\n            if not isinstance(other, Sequence):\n                return NotImplemented\n\n            self_len = self._len\n            len_other = len(other)\n\n            if self_len != len_other:\n                if seq_op is eq:\n                    return False\n                if seq_op is ne:\n                    return True\n\n            for alpha, beta in zip(self, other):\n                if alpha != beta:\n                    return seq_op(alpha, beta)\n\n            return seq_op(self_len, len_other)\n\n        seq_op_name = seq_op.__name__\n        comparer.__name__ = '__{0}__'.format(seq_op_name)\n        doc_str = \"\"\"Return true if and only if sorted list is {0} `other`.\n        ``sl.__{1}__(other)`` <==> ``sl {2} other``\n        Comparisons use lexicographical order as with sequences.\n        Runtime complexity: `O(n)`\n        :param other: `other` sequence\n        :return: true if sorted list is {0} `other`\n        \"\"\"\n        comparer.__doc__ = dedent(doc_str.format(doc, seq_op_name, symbol))\n        return comparer\n\n    __eq__ = __make_cmp(eq, '==', 'equal to')\n    __ne__ = __make_cmp(ne, '!=', 'not equal to')\n    __lt__ = __make_cmp(lt, '<', 'less than')\n    __gt__ = __make_cmp(gt, '>', 'greater than')\n    __le__ = __make_cmp(le, '<=', 'less than or equal to')\n    __ge__ = __make_cmp(ge, '>=', 'greater than or equal to')\n    __make_cmp = staticmethod(__make_cmp)\n\n    def __reduce__(self):\n        values = reduce(iadd, self._lists, [])\n        return (type(self), (values,))\n\n    @recursive_repr()\n    def __repr__(self):\n        return '{0}({1!r})'.format(type(self).__name__, list(self))\n\n    def _check(self):\n        try:\n            assert self._load >= 4\n            assert len(self._maxes) == len(self._lists)\n            assert self._len == sum(len(sublist) for sublist in self._lists)\n\n            # Check all sublists are sorted.\n\n            for sublist in self._lists:\n                for pos in range(1, len(sublist)):\n                    assert sublist[pos - 1] <= sublist[pos]\n\n            # Check beginning/end of sublists are sorted.\n\n            for pos in range(1, len(self._lists)):\n                assert self._lists[pos - 1][-1] <= self._lists[pos][0]\n\n            # Check _maxes index is the last value of each sublist.\n\n            for pos in range(len(self._maxes)):\n                assert self._maxes[pos] == self._lists[pos][-1]\n\n            # Check sublist lengths are less than double load-factor.\n\n            double = self._load << 1\n            assert all(len(sublist) <= double for sublist in self._lists)\n\n            # Check sublist lengths are greater than half load-factor for all\n            # but the last sublist.\n\n            half = self._load >> 1\n            for pos in range(0, len(self._lists) - 1):\n                assert len(self._lists[pos]) >= half\n\n            if self._index:\n                assert self._len == self._index[0]\n                assert len(self._index) == self._offset + len(self._lists)\n\n                # Check index leaf nodes equal length of sublists.\n\n                for pos in range(len(self._lists)):\n                    leaf = self._index[self._offset + pos]\n                    assert leaf == len(self._lists[pos])\n\n                # Check index branch nodes are the sum of their children.\n\n                for pos in range(self._offset):\n                    child = (pos << 1) + 1\n                    if child >= len(self._index):\n                        assert self._index[pos] == 0\n                    elif child + 1 == len(self._index):\n                        assert self._index[pos] == self._index[child]\n                    else:\n                        child_sum = self._index[child] + self._index[child + 1]\n                        assert child_sum == self._index[pos]\n        except:\n            traceback.print_exc(file=sys.stdout)\n            print('len', self._len)\n            print('load', self._load)\n            print('offset', self._offset)\n            print('len_index', len(self._index))\n            print('index', self._index)\n            print('len_maxes', len(self._maxes))\n            print('maxes', self._maxes)\n            print('len_lists', len(self._lists))\n            print('lists', self._lists)\n            raise\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\ninp = lambda dtype: [dtype(x) for x in input().split()]\ninp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]\ninp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]\ninp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]\ninp_enus = lambda dtype, n: [[i] + inp(dtype) for i in range(n)]\nceil1 = lambda a, b: (a + b - 1) // b\n\n\nclass graph:\n    def __init__(self, n):\n        self.n, self.gdict = n, [[] for _ in range(n + 1)]\n        self.indeg = [0] * (n + 1)\n\n    def addEdge(self, node1, node2, w=None):\n        self.gdict[node1].append(node2)\n        self.indeg[node2] += 1\n\n    def kahn(self, n):\n        # enqueue all node with 0 in degree\n        queue, ans, lst = SortedList([i for i in range(1, n + 1) if not self.indeg[i]]), 1, -1\n        cnt = 0\n\n        while len(queue):\n            # pop and push into topsort\n            ix = queue.bisect_right(lst)\n\n            if ix == len(queue):\n                ix = 0\n                ans += 1\n\n            lst = s = queue.pop(ix)\n\n            for i in self.gdict[s]:\n                self.indeg[i] -= 1\n                if not self.indeg[i]:\n                    queue.add(i)\n\n            cnt += 1\n        # check cycle\n        print(-1 if cnt != n else ans)\n\n\nfor _ in range(int(input())):\n    n = int(input())\n    g = graph(n)\n\n    for i in range(n):\n        for x in inp(int)[1:]:\n            g.addEdge(x, i + 1)\n    g.kahn(n)\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  char ch = getchar();\n  int ret = 0, f = 1;\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  for (; ch >= '0' && ch <= '9'; ch = getchar()) ret = ret * 10 + ch - '0';\n  return ret * f;\n}\nconst int INF = 1 << 30;\nconst int maxn = 200000 + 10;\nconst int maxm = 200000 + 10;\nint first[maxn], nxt[maxm], ecnt;\nint dis[maxn], d[maxn];\nstruct Edge {\n  int u, v;\n  Edge(int u = 0, int v = 0) : u(u), v(v) {}\n} e[maxm];\nvoid add_edge(int u, int v) {\n  nxt[ecnt] = first[u];\n  first[u] = ecnt;\n  e[ecnt++] = Edge(u, v);\n}\nqueue<int> q;\nvoid solve() {\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; ++i) {\n    first[i] = -1;\n    dis[i] = 0;\n    d[i] = 0;\n  }\n  queue<int> q;\n  ecnt = 0;\n  int t, x;\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d\", &t);\n    while (t--) {\n      scanf(\"%d\", &x);\n      add_edge(x, i);\n      ++d[i];\n    }\n  }\n  int cnt = 0;\n  for (int i = 1; i <= n; ++i)\n    if (d[i] == 0) {\n      q.push(i);\n      ++cnt;\n      dis[i] = 1;\n    }\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n    for (int i = first[u]; i != -1; i = nxt[i]) {\n      int v = e[i].v;\n      int extra = v > u ? 0 : 1;\n      if (dis[v] < dis[u] + extra) {\n        dis[v] = dis[u] + extra;\n      }\n      if (--d[v] == 0) {\n        q.push(v);\n        ++cnt;\n      }\n    }\n  }\n  if (cnt < n) {\n    puts(\"-1\");\n    return;\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; ++i) ans = max(ans, dis[i]);\n  cout << ans << endl;\n}\nint main() {\n  int T;\n  cin >> T;\n  while (T--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint T;\nint d[200005];\nint head[200005], net[2000005], v[2000000];\nint tot = 0;\nint n;\nint num = 1;\nint rans = 0;\npriority_queue<int, deque<int>, greater<int> > q;\npriority_queue<int, deque<int>, greater<int> > q2;\nvoid add(int x, int y) { tot++, v[tot] = y, net[tot] = head[x], head[x] = tot; }\nvoid init() {\n  rans = 0;\n  num = n;\n  tot = 0;\n  while (q2.size()) q2.pop();\n  for (int i = 1; i <= n; i++) {\n    d[i] = head[i] = 0;\n  }\n}\nvoid bfs() {\n  while (q.size()) {\n    rans++;\n    int lst = 0;\n    while (q.size()) {\n      int x = q.top();\n      q.pop();\n      if (lst > x) {\n        q2.push(x);\n      } else {\n        lst = x;\n        for (int i = head[x]; i; i = net[i]) {\n          int y = v[i];\n          d[y]--;\n          if (!d[y]) q.push(y), num--;\n        }\n      }\n    }\n    if (q2.size()) {\n      swap(q, q2);\n    }\n  }\n}\nint main() {\n  scanf(\"%d\", &T);\n  while (T--) {\n    scanf(\"%d\", &n);\n    init();\n    for (int i = 1; i <= n; i++) {\n      int t;\n      scanf(\"%d\", &t);\n      for (int j = 1; j <= t; j++) {\n        int t1;\n        scanf(\"%d\", &t1);\n        add(t1, i);\n        d[i]++;\n      }\n    }\n    for (int i = 1; i <= n; i++) {\n      if (d[i] == 0) q.push(i), num--;\n    }\n    bfs();\n    if (num) {\n      printf(\"-1\\n\");\n      continue;\n    }\n    printf(\"%d\\n\", rans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nvoid solve() {\n  ll n;\n  cin >> n;\n  vector<vector<ll>> adj(n);\n  vector<ll> indegree(n, 0);\n  for (ll i = 0; i < n; i++) {\n    ll k;\n    cin >> k;\n    for (ll j = 0; j < k; j++) {\n      ll x = i, y;\n      cin >> y;\n      y--;\n      adj[y].push_back(x);\n      indegree[x]++;\n    }\n  }\n  vector<ll> topo;\n  queue<ll> q;\n  vector<ll> r(n, 1);\n  for (ll i = 0; i < n; i++) {\n    if (indegree[i] == 0) q.push(i);\n  }\n  while (!q.empty()) {\n    ll v = q.front();\n    q.pop();\n    topo.push_back(v);\n    for (auto x : adj[v]) {\n      indegree[x]--;\n      if (indegree[x] == 0) q.push(x);\n      if (v < x)\n        r[x] = max(r[x], r[v]);\n      else\n        r[x] = max(r[x], r[v] + 1);\n    }\n  }\n  if ((ll)topo.size() < n)\n    cout << -1 << \"\\n\";\n  else\n    cout << *max_element(r.begin(), r.end()) << \"\\n\";\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int _t = 1;\n  cin >> _t;\n  for (int i = 1; i <= _t; i++) {\n    solve();\n  }\n  {};\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MAXN = 5e5 + 10;\nconst long long MOD = 998244353;\nconst long long MAXnum = 2e5;\nconst long double eps = 1e-8;\nconst long double inf = 1e20;\nconst long double PI = acos(-1);\ninline long long read() {\n  long long s = 0, w = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') w = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') s = s * 10 + ch - '0', ch = getchar();\n  return s * w;\n}\ninline void print(long long x) {\n  if (x < 0) putchar('-'), x = x;\n  if (x > 9) print(x / 10);\n  putchar(x % 10 + '0');\n}\nstruct Edge {\n  long long to, w, next;\n} edges[MAXN];\nlong long head[MAXN], cnt = 0;\nvoid add(long long u, long long v, long long w) {\n  edges[++cnt].w = w;\n  edges[cnt].to = v;\n  edges[cnt].next = head[u];\n  head[u] = cnt;\n}\nlong long ind[MAXN];\npriority_queue<long long, vector<long long>, greater<long long> > que, que2;\nlong long temp[MAXN];\nvoid solve() {\n  while (!que.empty()) que.pop();\n  while (!que2.empty()) que2.pop();\n  long long n;\n  cin >> n;\n  for (long long i = 1; i <= n; i++) {\n    ind[i] = 0;\n    head[i] = 0;\n  }\n  cnt = 0;\n  for (long long i = 1; i <= n; i++) {\n    long long k = 0;\n    cin >> k;\n    for (long long j = 0; j < k; j++) cin >> temp[j];\n    sort(temp, temp + k);\n    for (long long j = 0; j < k; j++) {\n      long long v = temp[j];\n      add(v, i, 1);\n      ind[i]++;\n    }\n  }\n  for (long long i = 1; i <= n; i++) {\n    if (ind[i] == 0) {\n      que.push(i);\n    }\n  }\n  long long cntt = 0, now = 0, ans = 1;\n  while (!que.empty() || !que2.empty()) {\n    if (que.empty()) {\n      while (!que2.empty()) {\n        long long x = que2.top();\n        que2.pop();\n        que.push(x);\n      }\n      ans++;\n    }\n    long long x = que.top();\n    que.pop();\n    now = x;\n    cntt++;\n    for (long long i = head[x]; i; i = edges[i].next) {\n      long long v = edges[i].to;\n      ind[v]--;\n      if (ind[v] == 0) {\n        if (v > now)\n          que.push(v);\n        else\n          que2.push(v);\n      }\n    }\n  }\n  if (cntt != n) {\n    cout << -1 << '\\n';\n  } else {\n    cout << ans << '\\n';\n  }\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long t = 1;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class code{\n\n\tstatic class Reader\n    {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public Reader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public Reader(String file_name) throws IOException\n        {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1)\n            {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do\n            {\n                ret = ret * 10 + c - '0';\n            }  while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.')\n            {\n                while ((c = read()) >= '0' && c <= '9')\n                {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n\n\tpublic static int GCD(int a, int b)\n    {\n      if (b == 0)\n        return a;\n      return GCD(b, a % b);\n    }\n\nstatic int[] dp;\n\n\tpublic static void main(String[] arg) throws IOException{\n\t\t//Reader in=new Reader();\n\t\tScanner in=new Scanner(System.in);\n\n    int t=in.nextInt();\n\t\twhile(t-- > 0){\n\t\t\tint n=in.nextInt();\n\t\t\tdp=new int[n];\n\t\t\tArrays.fill(dp,-2);\n\n\t\t\tint[][] graph=new int[n][];\n\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint k=in.nextInt();\n\t\t\t\tgraph[i]=new int[k];\n\n\t\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\t\tgraph[i][j]=in.nextInt()-1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean[] visit=new boolean[n];\n\n\t\t\tint res=0;\n\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint v=dfs(graph,i,visit);\n\t\t\t\tif(v==-1){\n\t\t\t\t\tres=-1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tres=Math.max(res,v);\n\t\t\t}\n\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\t\tpublic static int dfs(int[][] graph,int src,boolean[] visit){\n\t\t\tif(dp[src]!=-2) return dp[src];\n\t\t\tif(visit[src]) return -1;\n\n\t\t\tvisit[src]=true;\n\t\t\tint res=1;\n\n\t\t\tfor(int i:graph[src]){\n\t\t\t\tint v=dfs(graph,i,visit);\n\t\t\t\tif(v==-1){\n\t\t\t\t\tres=-1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(i>src) v++;\n\t\t\t\tres=Math.max(res,v);\n\t\t\t}\n\n\t\t\treturn dp[src] = res;\n\t\t}\n\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Collection;\nimport java.io.IOException;\nimport java.util.Deque;\nimport java.io.InputStreamReader;\nimport java.util.TreeSet;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.util.ArrayDeque;\nimport java.util.LinkedList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author xwchen\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int testCase = in.nextInt();\n            for (int t = 0; t < testCase; t++) {\n                int n = in.nextInt();\n                TreeSet<Integer>[] adj = new TreeSet[n];\n                int[] ind = new int[n];\n                for (int i = 0; i < n; i++) {\n                    adj[i] = new TreeSet<>();\n                }\n                for (int i = 0; i < n; i++) {\n                    int m = in.nextInt();\n                    int[] a = in.nextIntArray(m);\n                    for (int k = 0; k < m; k++) {\n                        --a[k];\n                        adj[a[k]].add(i);\n                        ind[i]++;\n                    }\n                }\n                int result = Graph.topologicalSort(adj, ind, n, new ArrayList<>());\n                out.println(result);\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer = new StringTokenizer(\"\");\n\n        public InputReader(InputStream inputStream) {\n            this.reader = new BufferedReader(\n                    new InputStreamReader(inputStream));\n        }\n\n        public String next() {\n            while (!tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n    }\n\n    static class ArrayUtils {\n        public static int maxElement(int[] a) {\n            return maxElement(a, 0, a.length);\n        }\n\n        public static int maxElement(int[] a, int start, int end) {\n            int ret = a[start];\n            for (int i = start; i < end; ++i) {\n                ret = Math.max(ret, a[i]);\n            }\n            return ret;\n        }\n\n    }\n\n    static class Graph {\n        public LinkedList<Edge>[] adj;\n        int n;\n\n        public Graph() {\n\n        }\n\n        public Graph(int n) {\n            this.n = n;\n            adj = new LinkedList[n + 1];\n            for (int i = 0; i <= n; ++i) {\n//            adj[i] = new TreeSet<>((o1, o2) -> {\n//                if (o1.value != o2.value) {\n//                    return o1.value - o2.value;\n//                } else {\n//                    return o1.type - o2.type;\n//                }\n//            });\n                adj[i] = new LinkedList<>();\n            }\n        }\n\n        public static int topologicalSort(TreeSet<Integer>[] adj, int[] inDegree, int n, ArrayList<Integer> ret) {\n            Deque<Integer> dq = new ArrayDeque<>();\n            int[] dis = new int[n];\n            for (int i = 0; i < n; ++i) {\n                if (inDegree[i] == 0) {\n                    dq.addLast(i);\n                    dis[i] = 1;\n                }\n            }\n\n            while (!dq.isEmpty()) {\n                int cur = dq.removeFirst();\n                ret.add(cur);\n                for (int v : adj[cur]) {\n                    --inDegree[v];\n                    if (cur < v) {\n                        dis[v] = Math.max(dis[v], dis[cur]);\n                    } else {\n                        dis[v] = Math.max(dis[v], dis[cur] + 1);\n                    }\n                    if (inDegree[v] == 0) {\n                        dq.addLast(v);\n                    }\n                }\n            }\n            if (ret.size() < n) {\n                return -1;\n            } else {\n                return ArrayUtils.maxElement(dis);\n            }\n        }\n\n        public class Edge {\n            public int u;\n            public int v;\n            public int value;\n            public int type;\n\n            public Edge(int u, int v, int value, int type) {\n                this.u = u;\n                this.v = v;\n                this.value = value;\n                this.type = type;\n            }\n\n            public Edge(int u, int v, int value) {\n                this.u = u;\n                this.v = v;\n                this.value = value;\n            }\n\n            public Edge(int v, int value) {\n                this.v = v;\n                this.value = value;\n            }\n\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main4 {\n    public static void main(String[] args) {\n        FastReader in = new FastReader(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int t = in.nextInt();\n\n        while(t-- > 0) {\n            int n = in.nextInt();\n\n            int[] ans = new int[n];\n            int[] depsNumber = new int[n];\n            Map<Integer, Set<Integer>> graph = new HashMap<>();\n            Queue<Integer> tops = new LinkedList<>();\n\n\n            for(int i = 0; i < n; i++) {\n                ans[i] = 1;\n                int depNumber = in.nextInt();\n                depsNumber[i] = depNumber;\n\n                if(depNumber == 0) {\n                    tops.add(i);\n                }\n\n                graph.putIfAbsent(i, new HashSet<>());\n                for(int j = 0; j < depNumber; j++) {\n                    int top = in.nextInt() - 1;\n                    graph.putIfAbsent(top, new HashSet<>());\n                    graph.get(top).add(i);\n                }\n            }\n\n            int visited = 0;\n            while(!tops.isEmpty()) {\n                visited++;\n                int top = tops.poll();\n                for(int dependentTop : graph.get(top)) {\n                    if(dependentTop > top) {\n                        ans[dependentTop] = Math.max(ans[dependentTop], ans[top]);\n                    } else {\n                        ans[dependentTop] = Math.max(ans[dependentTop], ans[top] + 1);\n                    }\n\n                    depsNumber[dependentTop]--;\n\n                    if(depsNumber[dependentTop] == 0) {\n                        tops.add(dependentTop);\n                    }\n                }\n            }\n\n            if(visited != n) {\n                pw.println(-1);\n                continue;\n            }\n\n            int answer = 0;\n\n            for(int i = 0; i < n; i++) {\n                answer = Math.max(answer, ans[i]);\n            }\n\n            pw.println(answer);\n        }\n\n        pw.close();\n    }\n\n    static class FastReader {\n        private final int BS = 1 << 16;\n        private final char NC = (char) 0;\n        private final byte[] buf = new byte[BS];\n        private final BufferedInputStream in;\n        private int bId = 0;\n        private int size = 0;\n        private char c = NC;\n        private double cnt = 1;\n\n        public FastReader(InputStream is) {\n            in = new BufferedInputStream(is, BS);\n        }\n\n        private char getChar() {\n            while(bId == size) {\n                try {\n                    size = in.read(buf);\n                } catch(Exception e) {\n                    return NC;\n                }\n\n                if(size == -1) {\n                    return NC;\n                }\n                bId = 0;\n            }\n\n            return (char) buf[bId++];\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            cnt = 1;\n            boolean neg = false;\n            if(c == NC) c = getChar();\n            for(; (c < '0' || c > '9'); c = getChar()) {\n                if(c == '-') neg = true;\n            }\n            long res = 0;\n            for(; c >= '0' && c <= '9'; c = getChar()) {\n                res = (res << 3) + (res << 1) + c - '0';\n                cnt *= 10;\n            }\n            return neg ? -res : res;\n        }\n\n        public double nextDouble() {\n            double cur = nextLong();\n            return c != '.' ? cur : cur + nextLong() / cnt;\n        }\n\n        public String next() {\n            StringBuilder res = new StringBuilder();\n            while(c <= 32) c = getChar();\n            while(c > 32) {\n                res.append(c);\n                c = getChar();\n            }\n            return res.toString();\n        }\n\n        public String nextLine() {\n            StringBuilder res = new StringBuilder();\n            while(c <= 32) {\n                c = getChar();\n            }\n\n            while(c != '\\n') {\n                res.append(c);\n                c = getChar();\n            }\n\n            return res.toString();\n        }\n\n        public boolean hasNext() {\n            if(c > 32) {\n                return true;\n            }\n\n            while(true) {\n                c = getChar();\n                if(c == NC) {\n                    return false;\n                } else if(c > 32) {\n                    return true;\n                }\n            }\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict as dd, deque\ndef check_cycle(g, indegree, n):\n    c = 0\n    d = deque([])\n    ans = dd(lambda :1)\n    for i in range(n):\n        if indegree[i + 1] == 0:\n            d.append(i + 1)\n    #print(d)\n    while d:\n        u = d.popleft()\n        c += 1\n        for v in g[u]:\n            indegree[v] -= 1\n            if v < u:\n                ans[v] = max(ans[v], ans[u] + 1)\n            else:\n                ans[v] = max(ans[v], ans[u])\n            if indegree[v] == 0:\n                d.append(v)\n    if c != n:\n        return False\n    if ans:\n        return max(ans.values())\n    return 1\n\n\nfor _ in range(int(input())):\n    n = int(input())\n    g = dd(set)\n    indegree = dd(int)\n    for i in range(n):\n        a = list(map(int, input().split()))\n        for j in range(1, a[0] + 1):\n            indegree[i + 1] += 1\n            g[a[j]].add(i + 1)\n    #print(indegree)\n    res = check_cycle(g, indegree, n)\n    if res == False:\n        print(-1)\n    else:\n        print(res)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p, int lvl = 0);\ntemplate <typename A>\nstring to_string(vector<vector<A>> v, int lvl = 0);\ntemplate <typename A, typename B>\nstring to_string(map<A, B> mp, int lvl = 0);\nstring to_string(const char& ch, int lvl = 0) {\n  return \"'\" + string(1, ch) + \"'\";\n}\nstring to_string(const string& s, int lvl = 0) { return '\"' + s + '\"'; }\nstring to_string(const char* s, int lvl = 0) { return to_string((string)s); }\nstring to_string(bool b, int lvl = 0) { return (b ? \"true\" : \"false\"); }\nstring to_string(vector<bool> v, int lvl = 0) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <typename A>\nstring to_string(A v, int lvl = 0) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto& x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p, int lvl) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A, typename B>\nstring to_string(map<A, B> mp, int lvl) {\n  string res = \"{\\n\", t = string(2 * lvl, ' ');\n  for (const auto& x : mp) {\n    res += t + to_string(x.first) + \": \" + to_string(x.second, lvl + 1) + '\\n';\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <typename A>\nstring to_string(vector<vector<A>> v, int lvl) {\n  string res = \"{\\n\", t = string(2 * lvl, ' ');\n  int _ = 0;\n  for (const auto& x : v) {\n    res += t + to_string(_++) + \": \" + to_string(x, lvl + 1) + '\\n';\n  }\n  res += \"}\";\n  return res;\n}\nvoid debug_out() { cout << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cout << \" \" << to_string(H);\n  debug_out(T...);\n}\ntemplate <typename T>\nusing vv = vector<vector<T>>;\ntemplate <typename T>\nusing mxpq = priority_queue<T>;\ntemplate <typename T>\nusing mnpq = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class A, size_t S>\nistream& operator>>(istream& in, array<A, S>& a) {\n  for (A& x : a) in >> x;\n  return in;\n}\ntemplate <typename T>\nistream& operator>>(istream& in, vector<T>& a) {\n  for (T& x : a) in >> x;\n  return in;\n}\ntemplate <class A, size_t S>\nostream& operator<<(ostream& out, array<A, S>& a) {\n  bool f = false;\n  for (A& x : a) {\n    if (f) out << \" \";\n    out << x;\n    f = true;\n  }\n  return out;\n}\ntemplate <typename T>\nostream& operator<<(ostream& out, vector<T>& a) {\n  bool f = false;\n  for (T& x : a) {\n    if (f) out << \" \";\n    out << x;\n    f = true;\n  }\n  return out;\n}\ntemplate <typename T>\nT amin(T& a) {\n  return a;\n}\ntemplate <typename T>\nT amax(T& a) {\n  return a;\n}\ntemplate <typename T, typename T1, typename... Tail>\nT amin(T& a, T1 b, Tail... c) {\n  if (b < a) a = b;\n  amin(a, c...);\n  return a;\n}\ntemplate <typename T, typename T1, typename... Tail>\nT amax(T& a, T1 b, Tail... c) {\n  if (b > a) a = b;\n  amax(a, c...);\n  return a;\n}\nconst int64_t mod = 1e9 + 7;\nint64_t power(int64_t x, int64_t y, int64_t M = mod) {\n  int64_t v = 1;\n  if (M > int64_t(0)) {\n    x = x % M;\n    while (y > 0) {\n      if (y & 1) v = (v * x) % M;\n      y = y >> 1;\n      x = (x * x) % M;\n    }\n    return v;\n  } else {\n    while (y > 0) {\n      if (y & 1) v = v * x;\n      y = y >> 1;\n      x = x * x;\n    }\n    return v;\n  }\n}\nint largest_bit(long long x) { return x == 0 ? -1 : 63 - __builtin_clzll(x); }\nconst long double PI = acos(-1);\nconst int64_t INF = 0x3f3f3f3f3f3f3f3fll;\nconst int64_t maxN = 2e5 + 5;\nvoid preSolve(int& testcases) { cin >> testcases; }\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<vector<int>> com(n);\n  vector<vector<int>> g(n);\n  for (int i = 0; i < n; i++) {\n    int k;\n    cin >> k;\n    while (k--) {\n      int r;\n      cin >> r;\n      --r;\n      g[r].push_back(i);\n    }\n  }\n  vector<bool> vis(n, false), active(n, false);\n  bool hasCycle = false;\n  function<void(int)> dfs = [&](int node) {\n    vis[node] = true;\n    active[node] = true;\n    for (auto& i : g[node]) {\n      if (active[i] == true) {\n        hasCycle = true;\n        return;\n      }\n      if (!vis[i]) {\n        dfs(i);\n      }\n      if (hasCycle) {\n        return;\n      }\n    }\n    active[node] = false;\n  };\n  for (int i = 0; i < n; i++) {\n    if (!vis[i]) {\n      dfs(i);\n      if (hasCycle) {\n        cout << -1 << '\\n';\n        return;\n      }\n    }\n  }\n  vector<int> hh(n, -1);\n  int ans = 0;\n  function<void(int)> dfs2 = [&](int node) {\n    for (auto& i : g[node]) {\n      if (hh[i] == -1) {\n        dfs2(i);\n      }\n      if (node < i) {\n        amax(hh[node], hh[i]);\n      } else {\n        amax(hh[node], hh[i] + 1);\n      }\n    }\n    if (hh[node] == -1) {\n      hh[node] = 1;\n    }\n  };\n  for (int i = 0; i < n; i++) {\n    if (hh[i] == -1) {\n      dfs2(i);\n      amax(ans, hh[i]);\n    }\n  }\n  cout << ans << '\\n';\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int testcases = 1;\n  preSolve(testcases);\n  for (int caseno = 1; caseno <= testcases; ++caseno) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst long long N = 2e5 + 5, MOD = 1e9 + 7, INF = 1e18;\nusing namespace std;\nlong long n, m, t;\nset<int> graph[N];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> t;\n  while (t--) {\n    cin >> n;\n    set<int> st;\n    vector<long long> cnt(n + 1, 0);\n    long long ans = 0, f = 1;\n    for (int i = 1; i <= n; ++i) {\n      cin >> cnt[i];\n      if (!cnt[i]) st.insert(i);\n      for (int j = 0; j < cnt[i]; ++j) {\n        cin >> m;\n        graph[m].insert(i);\n      }\n    }\n    while (st.size()) {\n      auto it = st.lower_bound(f);\n      if (it == st.end()) {\n        ans++;\n        it = st.begin();\n      }\n      f = *it;\n      for (auto child : graph[f]) {\n        cnt[child]--;\n        if (!cnt[child]) st.insert(child);\n      }\n      st.erase(f);\n    }\n    int ok = 1;\n    for (int i = 1; i <= n; ++i)\n      if (cnt[i]) ok = 0;\n    cout << (ok ? ans + 1 : -1) << '\\n';\n    for (int i = 1; i <= n; ++i) graph[i].clear();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> g[200010];\nint d[200010];\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int t;\n  cin >> t;\n  for (int T = (0); T < (t); T++) {\n    int n;\n    cin >> n;\n    for (int i = (0); i < (n); i++) {\n      int x;\n      cin >> x;\n      for (int j = (0); j < (x); j++) {\n        int a;\n        cin >> a;\n        a--;\n        g[a].push_back(i);\n      }\n      d[i] = x;\n    }\n    std::priority_queue<int, std::vector<int>, std::greater<int>> q;\n    vector<int> nxt;\n    int ans = 1;\n    int cnt = 0;\n    for (int i = (0); i < (n); i++)\n      if (d[i] == 0) {\n        q.push(i);\n        cnt++;\n      }\n    while (!q.empty() || !nxt.empty()) {\n      if (q.empty()) {\n        ans++;\n        for (auto it = nxt.begin(); it != nxt.end(); it++) q.push(*it);\n        nxt.clear();\n      }\n      int aux = q.top();\n      q.pop();\n      for (auto it = g[aux].begin(); it != g[aux].end(); it++) {\n        d[*it]--;\n        if (d[*it] == 0) {\n          cnt++;\n          if (aux < *it)\n            q.push(*it);\n          else\n            nxt.push_back(*it);\n        }\n      }\n    }\n    if (cnt == n)\n      cout << ans << '\\n';\n    else\n      cout << -1 << '\\n';\n    for (int i = (0); i < (n); i++) {\n      d[i] = -1;\n      g[i].clear();\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class C {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int t = sc.nextInt();\n        while (t-->0){\n            int n = sc.nextInt();\n            List<Integer>[] lists = new List[n];\n            int[] times = new int[n];\n            for(int i = 0;i<n;i++){\n                int k = sc.nextInt();\n                lists[i] = new ArrayList<>();\n                times[i] = -1;\n                while (k-->0){\n                    int p = sc.nextInt() - 1;\n                    lists[i].add(p);\n                }\n            }\n            try{\n                int answer = 0;\n                for(int i=0;i<n;i++){\n                    int a = count(lists, times, i);\n                    if(a > answer)answer = a;\n                }\n                System.out.println(answer);\n            }catch (Exception e){\n                System.out.println(-1);\n            }\n        }\n    }\n\n    public static int count(List<Integer>[] lists,  int[] times, int i) throws Exception{\n        if(times[i] == -2){\n            throw new Exception();\n        }else if(times[i] != -1) {\n            return times[i];\n        }\n\n        times[i] = -2;\n        int now = 1;\n        for(int pre : lists[i]){\n            int a = count(lists, times, pre);\n            if(pre > i){\n                a++;\n            }\n            if(a > now){\n                now = a;\n            }\n        }\n        times[i] = now;\n        return times[i];\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool topo(vector<vector<int>> &adj, vector<int> &vis, int u) {\n  vis[u] = 1;\n  for (int v : adj[u]) {\n    if (vis[v] == 0) {\n      if (!topo(adj, vis, v)) return false;\n    } else if (vis[v] == 1) {\n      return false;\n    }\n  }\n  vis[u] = 2;\n  return true;\n}\nint main() {\n  int t, n, k, a;\n  scanf(\"%d\", &t);\n  while (t--) {\n    scanf(\"%d\", &n);\n    vector<vector<int>> adj(n + 1);\n    vector<int> p(n + 1, 0), v(n + 1, 0);\n    for (int i = 1; i <= n; ++i) {\n      scanf(\"%d\", &k);\n      while (k--) {\n        scanf(\"%d\", &a);\n        adj[a].push_back(i);\n        p[i]++;\n      }\n    }\n    bool Topo = true;\n    for (int i = 1; Topo && i <= n; ++i) {\n      if (v[i] == 0) Topo &= topo(adj, v, i);\n    }\n    if (Topo) {\n      set<int> s;\n      int c = 0;\n      for (int i = 1; i <= n; ++i)\n        if (!p[i]) s.insert(i);\n      for (; s.size(); ++c) {\n        int d = 0;\n        while (s.upper_bound(d) != s.end()) {\n          d = *(s.upper_bound(d));\n          s.erase(d);\n          for (int x : adj[d]) {\n            if (--p[x] == 0) s.insert(x);\n          }\n        }\n      }\n      printf(\"%d\\n\", c);\n    } else {\n      puts(\"-1\");\n    }\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "\ndef naiveSolve():\n    \n    \n    \n    return\n\n\n\ndef solve():\n    \n    \n    \n    return\n\n\n\ndef main():\n    \n    # when i say book i am really referring to chapter\n    \n    t=int(input())\n    allans=[]\n    for _ in range(t):\n        n=int(input())\n        # req=[set() for __ in range(n)] # req[book] requires these other books\n        req=[0]*n # store the counts of required books\n        idxes=[[] for __ in range(n)] # idxes[book] are the indexes requiring this book\n        ans=[-1]*n\n        for i in range(n):\n            temp=readIntArr()\n            for j in range(1,len(temp)):\n                req[i]+=1\n                idxes[temp[j]-1].append(i)\n        \n        completedBooks=[]\n        for book in range(n):\n            if req[book]==0:\n                completedBooks.append(book)\n                ans[book]=1\n        while completedBooks:\n            book=completedBooks.pop()\n            dist=ans[book]\n            for nex in idxes[book]:\n                if nex<book:\n                    nexDist=dist+1\n                else:\n                    nexDist=dist\n                ans[nex]=max(ans[nex],nexDist)\n                req[nex]-=1\n                if req[nex]==0: # book is complete\n                    completedBooks.append(nex)\n        \n        hasIncompleteBook=False\n        for i in range(n):\n            if req[i]>0:\n                hasIncompleteBook=True\n        if hasIncompleteBook:\n            ans2=-1\n        else:\n            ans2=max(ans)\n        allans.append(ans2)\n        \n    multiLineArrayPrint(allans)\n    \n    return\n\n\n\n\nimport sys\ninput=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\n# input=lambda: sys.stdin.readline().rstrip(\"\\r\\n\") #FOR READING STRING/TEXT INPUTS.\n\ndef oneLineArrayPrint(arr):\n    print(' '.join([str(x) for x in arr]))\ndef multiLineArrayPrint(arr):\n    print('\\n'.join([str(x) for x in arr]))\ndef multiLineArrayOfArraysPrint(arr):\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\n \ndef readIntArr():\n    return [int(x) for x in input().split()]\n# def readFloatArr():\n#     return [float(x) for x in input().split()]\n \ndef makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])\n    dv=defaultValFactory;da=dimensionArr\n    if len(da)==1:return [dv() for _ in range(da[0])]\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\n \ndef queryInteractive(x):\n    print('{}'.format(x))\n    sys.stdout.flush()\n    return int(input())\n \ndef answerInteractive(ans):\n    print('! {}'.format(ans))\n    sys.stdout.flush()\n \ninf=float('inf')\n# MOD=10**9+7\n# MOD=998244353\n\nfrom math import gcd,floor,ceil\n# from math import floor,ceil # for Python2\n \nfor _abc in range(1):\n    main()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) {\n  if (b > a) {\n    return gcd(b, a);\n  }\n  if (b == 0) {\n    return a;\n  }\n  return gcd(b, a % b);\n}\nlong long expo(long long a, long long b, long long m) {\n  long long res = 1;\n  while (b > 0) {\n    if (b & 1) res = (res * a) % m;\n    a = (a * a) % m;\n    b = b >> 1;\n  }\n  return res;\n}\nlong long inv(long long a, long long b) { return expo(a, b - 2, b); }\nvoid swap(long long &x, long long &y) {\n  long long temp = x;\n  x = y;\n  y = temp;\n}\nlong long combination(long long n, long long r, long long m, long long *fact,\n                      long long *ifact) {\n  long long val1 = fact[n];\n  long long val2 = ifact[n - r];\n  long long val3 = ifact[r];\n  return (((val1 * val2) % m) * val3) % m;\n}\nlong long mod_add(long long a, long long b, long long m) {\n  a = a % m;\n  b = b % m;\n  return (((a + b) % m) + m) % m;\n}\nlong long mod_mul(long long a, long long b, long long m) {\n  a = a % m;\n  b = b % m;\n  return (((a * b) % m) + m) % m;\n}\nlong long mod_sub(long long a, long long b, long long m) {\n  a = a % m;\n  b = b % m;\n  return (((a - b) % m) + m) % m;\n}\nlong long fact[200001];\nlong long invfact[200001];\nvector<long long> sieve(long long n) {\n  long long *arr = new long long[n + 1]();\n  vector<long long> vect;\n  for (long long i = 2; i <= n; i++)\n    if (arr[i] == 0) {\n      vect.push_back(i);\n      for (long long j = 2 * i; j <= n; j += i) arr[j] = 1;\n    }\n  return vect;\n}\nvoid toposort(long long n, vector<vector<long long>> &adj,\n              vector<long long> &indegree, vector<long long> &dp) {\n  queue<long long> q;\n  vector<long long> done;\n  for (long long i = 1; i <= n; i++) {\n    if (indegree[i] == 0) {\n      q.push(i);\n      done.push_back(i);\n    }\n  }\n  while (!q.empty()) {\n    long long sz = q.size();\n    while (sz--) {\n      long long node = q.front();\n      q.pop();\n      for (auto x : adj[node]) {\n        indegree[x]--;\n        if (indegree[x] == 0) {\n          q.push(x);\n          done.push_back(x);\n        }\n        if (x > node) {\n          dp[x] = max(dp[x], dp[node]);\n        } else {\n          dp[x] = max(dp[x], dp[node] + 1);\n        }\n      }\n    }\n  }\n  if (done.size() != n) {\n    cout << -1 << '\\n';\n  } else {\n    long long ans = 0;\n    for (long long i = 1; i <= n; i++) {\n      ans = max(ans, dp[i]);\n    }\n    cout << ans << '\\n';\n  }\n}\nint32_t main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  long long t = 1;\n  cin >> t;\n  for (long long tt = 1; tt <= t; tt++) {\n    long long n;\n    cin >> n;\n    vector<vector<long long>> adj(n + 1);\n    vector<long long> indegree(n + 1, 0);\n    for (long long i = 0; i < n; i++) {\n      long long k;\n      cin >> k;\n      for (long long j = 0; j < k; j++) {\n        long long y;\n        cin >> y;\n        adj[y].push_back(i + 1);\n        indegree[i + 1]++;\n      }\n    }\n    vector<long long> dp(n + 1, 1);\n    toposort(n, adj, indegree, dp);\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.sql.SQLSyntaxErrorException;\nimport java.util.*;\nimport java.io.*;\nimport java.util.stream.StreamSupport;\n\n\npublic class Solution {\n    static int mod = 998244353;\n    public static void main(String str[]) throws IOException{\n//        Reader sc = new Reader();\n        BufferedWriter output = new BufferedWriter(new OutputStreamWriter(System.out));\n        Scanner sc = new Scanner(System.in);\n        int t = sc.nextInt();\n        sc.nextLine();\n        int a = 1;\n        while(t-->0){\n            int n= sc.nextInt();\n            Node[] nodes = new Node[n];\n            for(int i=0;i<n;i++){\n                nodes[i] = new Node(i);\n            }\n            for(int i=0;i<n;i++){\n                int x = sc.nextInt();\n                while(x-->0){\n                    int ind = sc.nextInt()-1;\n                    nodes[ind].child.add(nodes[i]);\n                    nodes[i].parent.add(nodes[ind]);\n                }\n            }\n            ArrayList<Integer> al = new ArrayList<>();\n            for(int i=0;i<n;i++){\n                if(nodes[i].parent.isEmpty())   al.add(i);\n            }\n            for(int i: al){\n                dfs(nodes, nodes[i],null);\n            }\n            int ans =0;\n            for(int i=0;i<n;i++){\n                if(!nodes[i].parent.isEmpty()){\n                    ans = -1;\n                    break;\n                }\n                ans = Math.max(ans, nodes[i].tot);\n            }\n            System.out.println(ans);\n        }\n\n\n        output.flush();\n    }\n    static class Pair {\n        int ind;\n        char c;\n        Pair(int i, char v) {\n            ind = i;\n            c = v;\n        }\n    }\n\n    //Collections.sort(al, new Comparator<Object>() {\n    //    @Override\n    //    public int compare(Object o1, Object o2) {\n    //        return 0;\n    //    }\n    //});\n\n    static class Node{\n        int ind;\n        int tot = 1;\n        ArrayList<Node> parent = new ArrayList<>();\n        ArrayList<Node> child = new ArrayList<>();\n        Node(int i){\n            ind =i;\n        }\n    }\n    static void dfs(Node[] nodes, Node ind, Node parent){\n        if(parent!=null){\n            ind.parent.remove(parent);\n            int x = parent.tot;\n            if(parent.ind>ind.ind){\n                x++;\n            }\n            ind.tot = Math.max(x, ind.tot);\n        }\n        if(ind.parent.isEmpty()){\n            for(Node n: ind.child){\n                dfs(nodes, n, ind);\n            }\n        }\n\n    }\n    static int maxHeight(List<Integer> wallPositions, List<Integer> wallHeights){\n        int ans = 0;\n        int n = wallHeights.size();\n        for(int i=1;i<n;i++){\n            int ind1 = wallPositions.get(i-1);\n            int ind2 = wallPositions.get(i);\n            if(ind2-ind1==1)    continue;\n            int x = wallHeights.get(i-1);\n            int y = wallHeights.get(i);\n            int index = (y-x+ind1+ind2)/2;\n            if(index<=ind1){\n                index = ind1+1;\n            }\n            else if(index>=ind2){\n                index = ind2-1;\n            }\n            ans = Math.max(ans, Math.min(x+(index-ind1),y+(ind2-index)));\n        }\n        return ans;\n    }\n\n\n\n\n//        3\n//        2 1 1\n//        2 3 1\n//        3 4 1\n//        4\n//        2\n\n\n    public static ArrayList<Integer> primeFactors(int n)\n    {\n        // Print the number of 2s that divide n\n        ArrayList<Integer> al = new ArrayList<>();\n        while (n%2==0)\n        {\n            al.add(2);\n            n /= 2;\n        }\n\n        // n must be odd at this point.  So we can\n        // skip one element (Note i = i +2)\n        for (int i = 3; i <= Math.sqrt(n); i+= 2)\n        {\n            // While i divides n, print i and divide n\n            while (n%i == 0)\n            {\n                al.add(i);\n                n /= i;\n            }\n        }\n\n        // This condition is to handle the case whien\n        // n is a prime number greater than 2\n        if (n > 2)\n            al.add(n);\n\n        return al;\n    }\n\n\n\n\n    static void bfs(Graph[] g, int ind, boolean vis[], ArrayList<Node> al, Set<Integer> set){\n        vis[ind] = true;\n        set.add(ind);\n        for(int i: g[ind].pq){\n            if(!vis[i])     bfs(g,i,vis,al,set);\n        }\n        g[ind].set = set;\n    }\n\n\n//    static class tempSort implements Comparator<Node> {\n//        // Used for sorting in ascending order of\n//        // roll number\n//        public int compare(Node a, Node b) {\n//            return a.size - b.size;\n//        }\n//    }\n\n\n\n\n\n    static long divide(long p, long q, long mod)\n    {\n        long expo = mod - 2;\n\n        while (expo != 0)\n        {\n            if ((expo & 1) == 1)\n            {\n//                long temp = p;\n//                System.out.println(\"zero--> \"+temp+\" \"+q);\n                p = (p * q) % mod;\n//                if(p<0){\n//                    System.out.println(\"one--> \"+temp+\" \"+q);\n//                }\n            }\n            q = (q * q) % mod;\n//            if(q<0){\n//                System.out.println(\"two--> \"+p+\" \"+q);\n//            }\n\n            expo >>= 1;\n        }\n        return p;\n    }\n\n\n    static class Graph{\n        int ind;\n        ArrayList<Integer> pq = new ArrayList<>();\n        Set<Integer> set;\n        boolean b = false;\n        public Graph(int a){\n            ind = a;\n        }\n\n\n    }\n\n\n    //\n//    static class Pair{\n//        int a=0;\n//        int b=0;\n//        int in = 0;\n//        int ac = 0;\n//        int ex = 0;\n//    }\n    long fun2(ArrayList<Integer> arr, int x){\n        ArrayList<ArrayList> al = new ArrayList<>();\n        ArrayList<Integer> curr = new ArrayList<>();\n        fun(arr, x, al, curr, 0);\n        if(al.size()==0)    return 0;\n        int max = 0;\n        for(ArrayList<Integer> i: al){\n            if(i.size()>max)    max = i.size();\n        }\n        for(int i=0;i<al.size();i++){\n            if(al.get(i).size()!=max){\n                al.remove(i);\n                i--;\n            }\n        }\n        for(ArrayList<Integer> i: al){\n            Collections.sort(al, Collections.reverseOrder());\n        }\n        long ans = 0;\n\n        for(ArrayList<Integer> i: al){\n            long temp = 0;\n            for(int j: i){\n                temp*=10;\n                temp+=j;\n            }\n            if(ans<temp)    ans = temp;\n        }\n        return ans;\n\n    }\n    void fun(ArrayList<Integer> arr, int x, ArrayList<ArrayList> al, ArrayList<Integer> curr, int i){\n        if(x<0) return ;\n        if(x==0) {\n            al.add(curr);\n            return;\n        }\n        for(int j=i;j<arr.size();j++){\n            ArrayList<Integer> temp = new ArrayList<>(curr);\n            fun(arr, x-arr.get(j), al, temp, j);\n        }\n    }\n\n\n\n    // Returns n^(-1) mod p\n    static long modInverse(long n, long p)\n    {\n        return (long)power(n, p - 2, p);\n    }\n\n\n\n    // Returns nCr % p using Fermat's\n    // little theorem.\n    static long nCrModPFermat(int n, int r,\n                              int p, long[] fac)\n    {\n\n        if (n<r)\n            return 0;\n        // Base case\n        if (r == 0)\n            return 1;\n\n        // Fill factorial array so that we\n        // can find all factorial of r, n\n        // and n-r\n        long x = modInverse(fac[r], p);\n        long y = modInverse(fac[n - r], p);\n\n        return (fac[n] * x\n                % p * y\n                % p)\n                % p;\n    }\n\n    static long[] sum(String[] str){\n        int n = str[0].length();\n        long ans[] = new long[n];\n        for(String s: str){\n            for(int i=0;i<n;i++)   ans[i]+=s.charAt(i);\n        }\n        return ans;\n    }\n\n//    static class tSort implements Comparator<Pair>{\n//\n//        public int compare(Pair s1, Pair s2) {\n//            if (s1.b < s2.b)\n//                return -1;\n//            else if (s1.b > s2.b)\n//                return 1;\n//            return 0;\n//        }\n//    }\n\n\n//    static boolean checkCycle(Tree[] arr,  boolean[] visited, int curr, int node){\n//        if(curr==node && visited[curr]) return true;\n//        if(visited[curr])   return false;\n//        visited[curr]  = true;\n//        for(int i: arr[curr].al){\n//            if(checkCycle(arr, visited, i, node))    return true;\n//        }\n//        return false;\n//    }\n\n\n//    static boolean allCombinations(int n){      //Global round 15\n//        int three2n = 1;\n//        for (int i = 1; i <= n; i++)\n//            three2n *= 3;\n//\n//        for (int k = 1; k < three2n; k++) {\n//            int k_cp = k;\n//            int sum = 0;\n//            for (int i = 1; i <= n; i++) {\n//                int s = k_cp % 3;\n//                k_cp /= 3;\n//                if (s == 2) s = -1;\n//                sum += s * a[i];\n//            }\n//            if (sum == 0) {\n//                return true;\n//            }\n//        }\n//        return false;\n//    }\n\n    static ArrayList<String> fun( int curr, int n, char c){\n        int len = n-curr;\n        if(len==0)  return null;\n        ArrayList<String> al = new ArrayList<>();\n        if(len==1){\n            al.add(c+\"\");\n            return al;\n        }\n        String ss = \"\";\n        for(int i=0;i<len/2;i++){\n            ss+=c;\n        }\n        ArrayList<String> one = fun(len/2+curr, n, (char)(c+1));\n        for(String str: one){\n            al.add(str+ss);\n            al.add(ss+str);\n        }\n        return al;\n    }\n    static ArrayList convert(int x, int k){\n        ArrayList<Integer> al = new ArrayList<>();\n        if(x>0) {\n            while (x > 0) {\n                al.add(x % k);\n                x /= k;\n            }\n        }\n        else    al.add(0);\n        return al;\n    }\n\n\n\n\n    static int max(int x, int y, int z){\n        int ans = Math.max(x,y);\n        ans = Math.max(ans, z);\n        return ans;\n    }\n    static int min(int x, int y, int z){\n        int ans = Math.min(x,y);\n        ans = Math.min(ans, z);\n        return ans;\n    }\n\n//    static long treeTraversal(Tree arr[], int parent, int x){\n//        long tot = 0;\n//        for(int i: arr[x].al){\n//            if(i!=parent){\n//                tot+=treeTraversal(arr, x, i);\n//            }\n//        }\n//        arr[x].child = tot;\n//        if(arr[x].child==0) arr[x].child = 1;\n//        return tot+1;\n//    }\n\n    public static int primeFactors(int n, int k)\n    {\n        int ans = 0;\n\n        while (n%2==0)\n        {\n            ans++;\n            if(ans>=k)  return k;\n            n /= 2;\n        }\n        for (int i = 3; i <= Math.sqrt(n); i+= 2)\n        {\n            while (n%i == 0)\n            {\n                ans++;\n                n /= i;\n                if(ans>=k)  return k;\n            }\n        }\n\n        if (n > 2)  ans++;\n        return ans;\n    }\n    static int binaryLow(ArrayList<Integer> arr, int x, int s, int e){\n        if(s>=e){\n            if(arr.get(s)>=x)  return s;\n            else    return s+1;\n        }\n        int m = (s+e)/2;\n        if(arr.get(m)==x)  return m;\n        if(arr.get(m)>x)   return binaryLow(arr,x,s,m);\n        if(arr.get(m)<x)   return binaryLow(arr,x,m+1,e);\n        return 0;\n    }\n    static int binaryLow(int[] arr, int x, int s, int e){\n        if(s>=e){\n            if(arr[s]>=x)  return s;\n            else    return s+1;\n        }\n        int m = (s+e)/2;\n        if(arr[m]==x)  return m;\n        if(arr[m]>x)   return binaryLow(arr,x,s,m);\n        if(arr[m]<x)   return binaryLow(arr,x,m+1,e);\n        return 0;\n    }\n    static int binaryHigh(int[] arr, int x, int s, int e){\n        if(s>=e){\n            if(arr[s]<=x)  return s;\n            else    return s-1;\n        }\n        int m = (s+e)/2;\n        if(arr[m]==x)  return m;\n        if(arr[m]>x)   return binaryHigh(arr,x,s,m-1);\n        if(arr[m]<x)   return binaryHigh(arr,x,m+1,e);\n        return 0;\n    }\n\n\n//    static void arri(int arr[], int n, Reader sc) throws IOException{\n//        for(int i=0;i<n;i++){\n//            arr[i] = sc.nextInt();\n//        }\n//    }\n//    static void arrl(long arr[], int n, Reader sc) throws IOException{\n//        for(int i=0;i<n;i++){\n//            arr[i] = sc.nextLong();\n//        }\n\n\n    static long gcd(long a, long b)\n    {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n    static long power(long x, long y, long p)\n    {\n        long res = 1; // Initialize result\n\n        x = x % p; // Update x if it is more than or\n        // equal to p\n\n        if (x == 0)\n            return 0; // In case x is divisible by p;\n\n        while (y > 0)\n        {\n\n            // If y is odd, multiply x with result\n            if ((y & 1) != 0)\n                res = (res * x) % p;\n\n            // y must be even now\n            y = y >> 1; // y = y/2\n            x = (x * x) % p;\n        }\n        return res%p;\n    }\n\n\n\n\n\n\n//    static class SortbyI implements Comparator<Pair> {\n//        // Used for sorting in ascending order of\n//        // roll number\n//        public int compare(Pair a, Pair b)\n//        {\n//            if(a.a>=b.a) return 1;\n//            else return -1;\n//        }\n//    }\n//    static class SortbyD implements Comparator<Pair> {\n//        // Used for sorting in ascending order of\n//        // roll number\n//        public int compare(Pair a, Pair b)\n//        {\n//            if(a.a<b.a) return 1;\n//            else if(a.a==b.b && a.b>b.b)    return 1;\n//            else return -1;\n//        }\n//    }\n//    static int binarySearch(ArrayList<Pair> a, int x, int s, int e){\n//        if(s>=e){\n//            if(x<=a.get(s).b)  return s;\n//            else    return s+1;\n//        }\n//        int mid = (e+s)/2;\n//        if(a.get(mid).b<x){\n//            return binarySearch(a, x, mid+1, e);\n//        }\n//        else    return binarySearch(a,x,s, mid);\n//    }\n\n    //    static class Edge{\n//        int a;\n//        int b;\n//        int c;\n//        int sec;\n//        Edge(int a, int b, int c, int sec){\n//            this.a = a;\n//            this.b = b;\n//            this.c = c;\n//            this.sec = sec;\n//        }\n//\n//    }\n    static class Tree{\n        int a;\n\n        ArrayList<Tree> al = new ArrayList<>();\n        Tree(int a){\n            this.a = a;\n        }\n\n\n    }\n\n    static class Reader {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public Reader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public Reader(String file_name) throws IOException\n        {\n            din = new DataInputStream(\n                    new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') {\n                    if (cnt != 0) {\n                        break;\n                    }\n                    else {\n                        continue;\n                    }\n                }\n                buf[cnt++] = (byte)c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') {\n                c = read();\n            }\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0,\n                    BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n\n\n    static boolean isPrime(int n)\n    {\n        if (n <= 1)\n            return false;\n        if (n <= 3)\n            return true;\n        if (n % 2 == 0 ||\n                n % 3 == 0)\n            return false;\n\n        for (int i = 5;\n             i * i <= n; i = i + 6)\n            if (n % i == 0 ||\n                    n % (i + 2) == 0)\n                return false;\n\n        return true;\n    }\n    static ArrayList<Integer> sieveOfEratosthenes(int n)\n    {\n        ArrayList<Integer> al = new ArrayList<>();\n        // Create a boolean array\n        // \"prime[0..n]\" and\n        // initialize all entries\n        // it as true. A value in\n        // prime[i] will finally be\n        // false if i is Not a\n        // prime, else true.\n        boolean prime[] = new boolean[n + 1];\n        for (int i = 0; i <= n; i++)\n            prime[i] = true;\n\n        for (int p = 2; p * p <= n; p++)\n        {\n            // If prime[p] is not changed, then it is a\n            // prime\n            if (prime[p] == true)\n            {\n                // Update all multiples of p\n                for (int i = p * p; i <= n; i += p)\n                    prime[i] = false;\n            }\n        }\n\n        // Print all prime numbers\n        for (int i = 2; i <= n; i++)\n        {\n            if (prime[i] == true)\n                al.add(i);\n        }\n        return al;\n    }\n\n}\n"
        },
        {
            "language": 3,
            "solution": "\ndef func2(datalist,n):\n    fished = [0] * (n+1)\n    sid = 1\n    eid = 1\n    xlist = [[]]\n    children=[[] for i in range(n+1)]\n    xn = 0\n\n    for i in range(1,n+1):\n        if datalist[i][0] == 0:\n            fished[eid] = i\n            eid += 1\n            xlist.append([1, 0])\n            xn += 1\n        else:\n            for id in datalist[i][1:]:\n                children[id].append(i)\n            xlist.append([1, datalist[i][0]])\n    maxstep = 1\n    while sid != eid:\n        cid = fished[sid]\n        sid += 1\n        for id in children[cid]:\n            xlist[id][1] -= 1\n            if cid < id:\n                xlist[id][0] = max(xlist[id][0], xlist[cid][0])\n            else:\n                xlist[id][0] = max(xlist[id][0], xlist[cid][0]+1)\n            if xlist[id][1] == 0:\n                xn += 1\n                maxstep = max(maxstep, xlist[id][0])\n                if children[id]:\n                    fished[eid] = id\n                    eid += 1\n    if xn != n:\n        return -1\n    return maxstep\n\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    datalist = [0]\n    for i in range(n):\n        datalist.append([int(x) for x in input().split()])\n    print(func2(datalist,n))"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.File;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    // static final File ip = new File(\"input.txt\");\n    // static final File op = new File(\"output.txt\");\n    // static {\n    //     try {\n    //         System.setOut(new PrintStream(op));\n    //         System.setIn(new FileInputStream(ip));\n    //     } catch (Exception e) {\n    //     }\n    // }\n\n    public static void main(String[] args) {\n        FastReader sc = new FastReader();\n        int test = sc.nextInt();\n        while (test-- != 0) {\n            int n = sc.nextInt();\n            ArrayList<Integer> adj[] = new ArrayList[n];\n            ArrayList<Integer> radj[] = new ArrayList[n];\n            int[] in = new int[n];\n            for (int i = 0; i < n; i++) {\n                adj[i] = new ArrayList<>();\n                radj[i] = new ArrayList<>();\n            }\n            for (int i = 0; i < n; i++) {\n                int k = sc.nextInt();\n                while (k-- > 0) {\n                    int des = sc.nextInt() - 1;\n                    adj[des].add(i);\n                    radj[i].add(des);\n                    in[i]++;\n                }\n            }\n            LinkedList<Integer> q = new LinkedList<>();\n            for (int i = 0; i < n; i++) {\n                if (in[i] == 0)\n                    q.add(i);\n            }\n            ArrayList<Integer> ans = new ArrayList<>();\n            while (q.isEmpty() == false) {\n                int curr = q.poll();\n                ans.add(curr);\n                for (int i : adj[curr]) {\n                    in[i]--;\n                    if (in[i] == 0)\n                        q.add(i);\n                }\n            }\n            if (ans.size() != n) {\n                System.out.println(\"-1\");\n            } else {\n                int[] dp = new int[n];\n                Arrays.fill(dp, 1);\n                int cnt = 0;\n                for (int u : ans) {\n                    for (int v : radj[u]) {\n                        if (v > u)\n                            dp[u] = Math.max(dp[u], dp[v] + 1);\n                        else\n                            dp[u] = Math.max(dp[u], dp[v]);\n                    }\n                    cnt = Math.max(cnt, dp[u]);\n                }\n                System.out.println(cnt);\n            }\n        }\n    }\n\n    static long power(long x, long y, long p) {\n        long res = 1;\n        x = x % p;\n        if (x == 0)\n            return 0;\n        while (y > 0) {\n            if ((y & 1) != 0)\n                res = (res * x) % p;\n            y = y >> 1;\n            x = (x * x) % p;\n        }\n        return res;\n    }\n\n    public static int countSetBits(long number) {\n        int count = 0;\n        while (number > 0) {\n            ++count;\n            number &= number - 1;\n        }\n        return count;\n    }\n\n    private static <T> void swap(int[] a, int i, int j) {\n        int tmp = a[i];\n        a[i] = a[j];\n        a[j] = tmp;\n    }\n\n    // static class pair {\n    // long a, b;\n\n    // pair(long x, long y) {\n    // this.a = x;\n    // this.b = y;\n    // }\n    // public boolean equals(Object o) {\n    // if (this == o) return true;\n    // if (!(o instanceof pair)) return false;\n    // pair key = (pair) o;\n    // return a == key.a && b == key.b;\n    // }\n\n    // @Override\n    // public int hashCode() {\n    // int result = a;\n    // result = 31 * result + b;\n    // return result;\n    // }\n\n    // public int compare(pair p1, pair p2) {\n    // if(p1.a - p2.a > 0) return -1;\n    // if(p1.a - p2.a < 0) return 1;\n    // return 0;\n    // }\n    // }\n\n    // static class comparator implements Comparator<pair> {\n\n    // public int compare(pair p1, pair p2) {\n    // if (p1.a - p2.a > 0)\n    // return 1;\n    // if (p1.a - p2.a < 0)\n    // return -1;\n    // if (p1.a == p2.a) {\n    // if (p1.b > p2.b)\n    // return -1;\n    // else if (p1.b < p2.b)\n    // return 1;\n    // }\n    // return 0;\n    // }\n    // }\n\n    private static long getSum(int[] array) {\n        long sum = 0;\n        for (int value : array) {\n            sum += value;\n        }\n        return sum;\n    }\n\n    private static boolean isPrime(Long x) {\n        if (x < 2)\n            return false;\n        for (long d = 2; d * d <= x; ++d) {\n            if (x % d == 0)\n                return false;\n        }\n        return true;\n    }\n\n    static int[] reverse(int a[], int n) {\n        int i, k, t;\n        for (i = 0; i < n / 2; i++) {\n            t = a[i];\n            a[i] = a[n - i - 1];\n            a[n - i - 1] = t;\n        }\n        return a;\n    }\n\n    private static boolean isPrimeInt(int x) {\n        if (x < 2)\n            return false;\n        for (int d = 2; d * d <= x; ++d) {\n            if (x % d == 0)\n                return false;\n        }\n        return true;\n    }\n\n    public static String reverse(String input) {\n        StringBuilder str = new StringBuilder(\"\");\n\n        for (int i = input.length() - 1; i >= 0; i--) {\n            str.append(input.charAt(i));\n        }\n\n        return str.toString();\n    }\n\n    private static int[] getPrimes(int n) {\n        boolean[] used = new boolean[n + 1];\n        used[0] = used[1] = true;\n        int size = 0;\n        for (int i = 2; i <= n; ++i) {\n            if (!used[i]) {\n                ++size;\n                for (int j = 2 * i; j <= n; j += i) {\n                    used[j] = true;\n                }\n            }\n        }\n        int[] primes = new int[size];\n        for (int i = 0, cur = 0; i <= n; ++i) {\n            if (!used[i]) {\n                primes[cur++] = i;\n            }\n        }\n        return primes;\n    }\n\n    private static long lcm(long a, long b) {\n        return a / gcd(a, b) * b;\n    }\n\n    private static long gcd(long a, long b) {\n        return (a == 0 ? b : gcd(b % a, a));\n    }\n\n    static void sortI(int[] arr) {\n        int n = arr.length;\n        Random rnd = new Random();\n        for (int i = 0; i < n; ++i) {\n            int tmp = arr[i];\n            int randomPos = i + rnd.nextInt(n - i);\n            arr[i] = arr[randomPos];\n            arr[randomPos] = tmp;\n        }\n        Arrays.sort(arr);\n    }\n\n    static void shuffleList(ArrayList<Long> arr) {\n        int n = arr.size();\n        Random rnd = new Random();\n        for (int i = 0; i < n; ++i) {\n            long tmp = arr.get(i);\n            int randomPos = i + rnd.nextInt(n - i);\n            arr.set(i, arr.get(randomPos));\n            arr.set(randomPos, tmp);\n        }\n    }\n\n    static void factorize(long n) {\n        int count = 0;\n        while (!(n % 2 > 0)) {\n            n >>= 1;\n\n            count++;\n        }\n        if (count > 0) {\n            // System.out.println(\"2\" + \" \" + count);\n        }\n        long i = 0;\n        for (i = 3; i <= (long) Math.sqrt(n); i += 2) {\n            count = 0;\n            while (n % i == 0) {\n                count++;\n                n = n / i;\n            }\n            if (count > 0) {\n                // System.out.println(i + \" \" + count);\n            }\n        }\n\n        if (n > 2) {\n            // System.out.println(i + \" \" + count);\n        }\n    }\n\n    static void sortL(long[] arr) {\n        int n = arr.length;\n        Random rnd = new Random();\n        for (int i = 0; i < n; ++i) {\n            long tmp = arr[i];\n            int randomPos = i + rnd.nextInt(n - i);\n            arr[i] = arr[randomPos];\n            arr[randomPos] = tmp;\n        }\n        Arrays.sort(arr);\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public boolean hasNext() {\n            return false;\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid arraychk(int a[], int n) {\n  for (int i = 0; i < n; i++) cout << a[i] << \" \";\n  cout << \"\\n\";\n  ;\n}\nvector<int> ed[2 * 100005];\nint a[2 * 100005], now = 1, done;\nset<int> current[2 * 100005];\nint main() {\n  ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);\n  long long int tt = 1;\n  cin >> tt;\n  for (int cse = 1; cse <= tt; cse++) {\n    int i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, x = 0, y = 0, ans = 1,\n        sum = 0;\n    done = 0;\n    cin >> n;\n    current[0].clear();\n    for (int i = 0; i < n + 1; i++) ed[i].clear();\n    for (int i = 1; i < n + 1; i++) {\n      current[i].clear();\n      cin >> a[i];\n      m = a[i];\n      if (m == 0) done++, current[0].insert(i);\n      while (m--) {\n        cin >> x;\n        ed[x].push_back(i);\n      }\n    }\n    bool flag = (!current[0].empty());\n    x = 0;\n    while (flag && done < n) {\n      if (done != n && current[x].empty()) flag = 0;\n      for (auto xx : current[x]) {\n        for (auto yy : ed[xx]) {\n          a[yy]--;\n          if (a[yy] == 0) {\n            done++;\n            if (yy > xx)\n              current[x].insert(yy);\n            else\n              current[x + 1].insert(yy);\n          }\n        }\n      }\n      if (done == n) {\n        if (!current[x + 1].empty()) x++;\n        break;\n      }\n      ++x;\n    }\n    cout << ((flag) ? x + 1 : -1) << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\nimport javax.swing.Box.Filler;\n\n\npublic class Main {\n\n\tstatic class Task {\n\t\t\n\t\tint NN = 200005;\n\t\tint MOD = 998244353;\n\t\tint INF = 2000000000;\n\t\tlong INFINITY = 2000000000000000000L;\n\n\t\tclass Pair {\n\t\t\tInteger x, y;\n\t\t\tpublic Pair(int x, int y){\n\t\t\t\tthis.x = x;this.y = y;\n\t\t\t}\n\t\t}\n\n\t\tList<Integer>[]g;\n\t\tboolean [] vis;\n\t\tboolean [] rec;\n\t\tint [] turn;\n\n\t\tboolean hasCycle(int x) {\n\t\t\tif(rec[x]) return true;\n\t\t\tif(vis[x]) return false;\n\t\t\tvis[x] = true;rec[x] = true;\n\t\t\tfor(int y: g[x]) {\n\t\t\t\tif(hasCycle(y)) return true;\n\t\t\t}\n\t\t\trec[x] = false;\n\t\t\treturn false;\n\t\t}\n\n\t\tvoid dfs(int x) {\n\t\t\tif(turn[x] != -1) return;\n\t\t\tturn[x] = 1;\n\t\t\tfor(int y: g[x]) {\n\t\t\t\tdfs(y);\n\t\t\t\tif(x < y){\n\t\t\t\t\tturn[x] = Math.max(turn[x], turn[y] + 1);\n\t\t\t\t} else {\n\t\t\t\t\tturn[x] = Math.max(turn[x], turn[y]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void solve(InputReader in, PrintWriter out) {\n\t\t\tint t = in.nextInt();\n\t\t\twhile(t-->0){\n\t\t\t\tint n = in.nextInt();\n\t\t\t\tg = new ArrayList[n + 1];\n\t\t\t\tvis = new boolean[n + 1];rec = new boolean[n + 1];\n\t\t\t\tturn = new int[n + 1];\n\t\t\t\tfor(int i=1;i<=n;++i) {\n\t\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t\t\tvis[i] = false;rec[i] = false;\n\t\t\t\t\tturn[i] = -1;\n\t\t\t\t\tint k = in.nextInt();\n\t\t\t\t\twhile(k-->0) {\n\t\t\t\t\t\tg[i].add(in.nextInt());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor(int i=1;i<=n;++i) {\n\t\t\t\t\tif(hasCycle(i)) {\n\t\t\t\t\t\tok = false;break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!ok) {\n\t\t\t\t\tout.println(-1);continue;\n\t\t\t\t}\t\t\t\t\n\t\t\t\tfor(int i=1;i<=n;++i) {\n\t\t\t\t\tdfs(i);\n\t\t\t\t}\n\t\t\t\tint ans = 0;\n\t\t\t\tfor(int i=1;i<=n;++i) {\n\t\t\t\t\tans = Math.max(ans, turn[i]);\n\t\t\t\t}\n\t\t\t\tout.println(ans);\n\t\t\t}\n\t\t}\n\n\t}\n\t\n\tstatic void prepareIO(boolean isFileIO) {\n\t\t//long t1 = System.currentTimeMillis();\n\t\tTask solver = new Task();\n\t\t// Standard IO\n\t\tif(!isFileIO) { \n\t\t\tInputStream inputStream = System.in;\n\t        OutputStream outputStream = System.out;\n\t        InputReader in = new InputReader(inputStream);\n\t        PrintWriter out = new PrintWriter(outputStream);\n\t        solver.solve(in, out);\n\t        //out.println(\"time(s): \" + (1.0*(System.currentTimeMillis()-t1))/1000.0);\n\t        out.close();\n\t\t}\n        // File IO\n\t\telse {\n\t\t\tString IPfilePath = System.getProperty(\"user.home\") + \"/Downloads/ip.in\";\n\t        String OPfilePath = System.getProperty(\"user.home\") + \"/Downloads/op.out\";\n\t        InputReader fin = new InputReader(IPfilePath);\n\t        PrintWriter fout = null;\n\t        try {\n\t\t\t\tfout = new PrintWriter(new File(OPfilePath));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t        solver.solve(fin, fout);\n\t        //fout.println(\"time(s): \" + (1.0*(System.currentTimeMillis()-t1))/1000.0);\n\t        fout.close();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n        prepareIO(false);\n\t}\n\t\n\tstatic class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n        \n        public InputReader(String filePath) {\n        \tFile file = new File(filePath);\n            try {\n\t\t\t\treader = new BufferedReader(new FileReader(file));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n            tokenizer = null;\n        }\n        \n        public String nextLine() {\n        \tString str = \"\";\n        \ttry {\n\t\t\t\tstr = reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n        \treturn str;\n        }\n        \n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n        \treturn Double.parseDouble(next());\n        }\n        \n    }\n\n}"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.*;\n// import java.lang.*;\nimport java.io.*;\n\n//           THIS TEMPLATE MADE BY AKSH BANSAL.\n\npublic class Solution {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    private static boolean[] isPrime;\n    private static void primes(){\n        int num = (int)1e6; // PRIMES FROM 1 TO NUM\n        isPrime = new boolean[num];\n     \n        for (int i = 2; i< isPrime.length; i++) {\n           isPrime[i] = true;\n        }\n        for (int i = 2; i< Math.sqrt(num); i++) {\n           if(isPrime[i] == true) {\n              for(int j = (i*i); j<num; j = j+i) {\n                 isPrime[j] = false;\n              }\n           }\n        }\n    }\n    static void sort(int a[]){ // int -> long\n        ArrayList<Integer> arr=new ArrayList<>(); // Integer -> Long\n        for(int i=0;i<a.length;i++)\n        arr.add(a[i]);\n        Collections.sort(arr);\n        for(int i=0;i<a.length;i++)\n        a[i]=arr.get(i);\n        \n    }\n    private static long gcd(long a, long b){\n        if(b==0)return a;\n        return gcd(b,a%b);\n    }\n    private static long pow(long x,long y){\n        if(y==0)return 1;\n        long temp = pow(x, y/2);\n        if(y%2==1){\n            return x*temp*temp;\n        }\n        else{\n            return temp*temp;\n        }\n    }\n\n    static ArrayList<Integer>[] adj;\n    static void getAdj(int n){\n        adj = new ArrayList[n+1];\n        for(int i=1;i<=n;i++){\n            adj[i] = new ArrayList<>();\n        }\n        for(int i=0;i<n;i++){\n            int a = sc.nextInt();\n            for(int j=0;j<a;j++){\n                adj[i+1].add(sc.nextInt());\n            }\n        }\n    }\n\n    static PrintWriter out;\n    static FastReader sc ;\n    public static void main(String[] args) throws IOException {\n        sc = new FastReader();\n        out = new PrintWriter(System.out);\n        // primes();\n        // ________________________________\n\n        int test = sc.nextInt();\n        StringBuilder output = new StringBuilder();\n\n        while (test-- > 0) {\n            int n = sc.nextInt();\n            getAdj(n);\n            output.append(solver(n)).append(\"\\n\");\n        }\n\n        out.println(output);\n        // _______________________________\n\n        // int n = sc.nextInt();\n        // out.println(solver());\n        // ________________________________\n        out.flush();\n    }\n\n    public static long solver(int n) {\n        vis = new boolean[n+1];\n        dep = new ArrayList<>();\n        for(int i=1;i<=n;i++){\n            dfs(n, i);\n        }\n        // for(int i=0;i<n;i++){\n        //     System.out.print(\"__\"+ dep.get(i));\n        // }\n        // System.out.println(\"__\" );\n        int dp[] = new int[n+1];\n        vis = new boolean[n+1];\n        long res = 1;\n        for(int i=0;i<n;i++){\n            int cur = dep.get(i);\n            vis[cur] = true;\n            int cost = 0;\n            for(Integer e: adj[cur]){\n                if(!vis[e]){\n                    return -1;\n                }\n                else if(e>cur){\n                    cost=Math.max(dp[e]+1, cost);\n                }\n                else {\n                    cost = Math.max(cost, dp[e]);\n                }\n            }\n            dp[cur] = cost;\n            res=Math.max(res, 1+cost);\n            // System.out.println(i+\"__\"+ dp[i]);\n        }\n        return res;\n    }\n\n    static ArrayList<Integer> dep;\n    static void dfs(int n, int node){\n        if(vis[node])return;\n        vis[node] = true;\n        for(Integer e: adj[node]){\n            if(!vis[e])\n                dfs(n, e);\n        }\n        dep.add(node);\n    }\n\n    static boolean[] vis;\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double eps = 1e-9;\nconst long long INF = 0x3f3f3f3f3f3f3f3fll;\nconst int inf = 0x3f3f3f3f;\nconst int N = 2e5 + 7;\nconst int MAXN = 3e5 + 7;\nconst long long MOD = 998244353;\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\nlong long fpow(long long a, long long b) {\n  if (a == 0) return 0;\n  long long ans = 1;\n  for (; b; b >>= 1, a = ((a * a) % MOD))\n    if (b & 1) ans = ((ans * a) % MOD);\n  return ans;\n}\nint gcdint(int a, int b) { return b ? gcd(b, a % b) : a; }\nint fpowint(int a, int b) {\n  if (a == 0) return 0;\n  int ans = 1;\n  for (; b; b >>= 1, a = a * a)\n    if (b & 1) ans = ans * a;\n  return ans;\n}\nvoid solve(int ca) {\n  priority_queue<pair<int, int>, vector<pair<int, int>>,\n                 greater<pair<int, int>>>\n      p;\n  int n, t, u;\n  scanf(\"%d\", &n);\n  int a[n + 1];\n  vector<int> v[n + 1];\n  int ans = 0, cnt = 0;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &t);\n    a[i] = t;\n    if (t == 0) p.push({1, i}), cnt++;\n    while (t--) {\n      scanf(\"%d\", &u);\n      v[u].push_back(i);\n    }\n  }\n  while (!p.empty()) {\n    int now = p.top().first;\n    int pos = p.top().second;\n    ans = now;\n    p.pop();\n    for (int c : v[pos]) {\n      a[c]--;\n      if (a[c] == 0) {\n        cnt++;\n        if (c > pos)\n          p.push({now, c});\n        else\n          p.push({now + 1, c});\n      }\n    }\n  }\n  if (cnt < n) ans = -1;\n  printf(\"%d\\n\", ans);\n}\nint main() {\n  int T;\n  cin >> T;\n  for (int i = 1; i <= T; i++) solve(i);\n}\n"
        },
        {
            "language": 3,
            "solution": "\ndef naiveSolve():\n    \n    \n    \n    return\n\n\n\ndef solve():\n    \n    \n    \n    return\n\nfrom types import GeneratorType\ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\n\nfrom collections import defaultdict,deque\nclass Graph: \n    def __init__(self,nVertices,graphArr): \n        self.graph = defaultdict(list)\n        for u,v in graphArr:\n            self.graph[u].append(v)\n        self.V = nVertices\n    def hasCycle(self): #can comment out this method if not used\n        in_degree = [0]*(self.V) \n        for i in self.graph: \n            for j in self.graph[i]: \n                in_degree[j] += 1\n        queue = deque() \n        for i in range(self.V): \n            if in_degree[i] == 0: \n                queue.append(i) \n        cnt = 0\n        while queue:\n            u = queue.popleft()\n            for i in self.graph[u]: \n                in_degree[i] -= 1\n                if in_degree[i] == 0: \n                    queue.append(i)\n            cnt += 1\n        if cnt != self.V:return True\n        else:return False\n    def topologicalSort(self): #can comment out this method if not used\n        in_degree = [0]*(self.V) \n        for i in self.graph: \n            for j in self.graph[i]: \n                in_degree[j] += 1\n        queue = deque() \n        for i in range(self.V): \n            if in_degree[i] == 0: \n                queue.append(i) \n        cnt = 0\n        top_order = [] \n        while queue:\n            u = queue.popleft()\n            top_order.append(u)\n            for i in self.graph[u]: \n                in_degree[i] -= 1\n                if in_degree[i] == 0: \n                    queue.append(i)\n            cnt += 1\n        if cnt != self.V:return [] #Has cycle\n        else:return top_order\n## How to use:\n## N=number of nodes. graphArr = [[prevNode,nextNode],...] #nodes are numbered from 0 to N-1\n## g = Graph(N,graphArr)\n## g.hasCycle() returns True if graph has a cycle else False\n## g.topologicalSort() returns [] if graph has a cycl\n\ndef main():\n    \n    t=int(input())\n    allans=[]\n    for _ in range(t):\n        n=int(input())\n        req=[None for __ in range(n)]\n        for i in range(n):\n            temp=readIntArr()\n            temp.pop(0)\n            for j in range(len(temp)):\n                temp[j]-=1\n            req[i]=temp\n        \n        # check for cycles in a path (like topological sort)\n        graphArr=[]\n        for i in range(n):\n             for j in req[i]:\n                 graphArr.append((i,j))\n        Kahn=Graph(n,graphArr)\n        if Kahn.hasCycle():\n            allans.append(-1)\n            continue\n        \n        memo=[-1]*n\n        @bootstrap\n        def dp(book):\n            if memo[book]==-1:\n                ans=1\n                for prev in req[book]:\n                    if prev<book:\n                        ans=max(ans,(yield dp(prev)))\n                    else:\n                        ans=max(ans,1+(yield dp(prev)))\n                memo[book]=ans\n            yield memo[book]\n        ans=0\n        for book in range(n):\n            ans=max(ans,dp(book))\n        allans.append(ans)\n        \n    multiLineArrayPrint(allans)\n    \n    return\n\n\n\n\nimport sys\ninput=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\n# input=lambda: sys.stdin.readline().rstrip(\"\\r\\n\") #FOR READING STRING/TEXT INPUTS.\n\ndef oneLineArrayPrint(arr):\n    print(' '.join([str(x) for x in arr]))\ndef multiLineArrayPrint(arr):\n    print('\\n'.join([str(x) for x in arr]))\ndef multiLineArrayOfArraysPrint(arr):\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\n \ndef readIntArr():\n    return [int(x) for x in input().split()]\n# def readFloatArr():\n#     return [float(x) for x in input().split()]\n \ndef makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])\n    dv=defaultValFactory;da=dimensionArr\n    if len(da)==1:return [dv() for _ in range(da[0])]\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\n \ndef queryInteractive(x):\n    print('{}'.format(x))\n    sys.stdout.flush()\n    return int(input())\n \ndef answerInteractive(ans):\n    print('! {}'.format(ans))\n    sys.stdout.flush()\n \ninf=float('inf')\n# MOD=10**9+7\n# MOD=998244353\n\nfrom math import gcd,floor,ceil\n# from math import floor,ceil # for Python2\n \nfor _abc in range(1):\n    main()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<vector<int>> vc(n);\n  vector<int> cnt(n);\n  set<int> st;\n  for (int i = 0; i < n; ++i) {\n    int x;\n    cin >> x;\n    cnt[i] = x;\n    if (x == 0) {\n      st.insert(i);\n    }\n    for (int j = 0; j < x; ++j) {\n      int y;\n      cin >> y;\n      vc[y - 1].push_back(i);\n    }\n  }\n  int last = 0, ans = 1;\n  for (int i = 0; i < n; ++i) {\n    if (st.empty()) {\n      cout << \"-1\\n\";\n      return;\n    }\n    auto it = st.lower_bound(last);\n    if (it == end(st)) {\n      ++ans;\n      it = begin(st);\n    }\n    int j = *it;\n    st.erase(it);\n    for (const int& cur : vc[j]) {\n      --cnt[cur];\n      if (cnt[cur] == 0) {\n        st.insert(cur);\n      }\n    }\n    last = j;\n  }\n  cout << ans << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long prr[] = {2,   3,   5,   7,   11,  13,  17,  19,  23,  29,  31,  37,\n                   41,  43,  47,  53,  59,  61,  67,  71,  73,  79,  83,  89,\n                   97,  101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151,\n                   157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223,\n                   227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281,\n                   283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359,\n                   367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433,\n                   439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499};\nlong long powmod(long long a, long long b, long long modulo) {\n  if (b == 0 || a == 1) return 1;\n  long long half = powmod(a, (b / 2), modulo) % modulo;\n  long long full = (half * half) % modulo;\n  if (b % 2) return (full * a) % modulo;\n  return full % modulo;\n}\nlong long invmod(long long a, long long modulo) {\n  long long check = powmod(a, modulo - 2, modulo) % modulo;\n  return check;\n}\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long lcm(long long a, long long b) { return a / gcd(a, b) * b; }\nbool isPrime[5000005];\nint prime[5000005];\nvoid sieve(long long N) {\n  for (long long i = 0; i <= N; ++i) {\n    isPrime[i] = true;\n  }\n  isPrime[0] = false;\n  isPrime[1] = false;\n  for (int i = 2; i * i <= N; ++i) {\n    if (isPrime[i] == true) {\n      for (int j = i * i; j <= N; j += i) isPrime[j] = false;\n    }\n  }\n  int j = 0;\n  for (int i = 2; i <= N; i++) {\n    if (isPrime[i]) {\n      prime[j] = i;\n      j++;\n    }\n  }\n}\nunsigned long long nCrFermat(unsigned long long n, int r, int p) {\n  if (n < r) return 0;\n  if (r == 0) return 1;\n  unsigned long long fac[n + 1];\n  fac[0] = 1;\n  for (int i = 1; i <= n; i++) fac[i] = (fac[i - 1] * i) % p;\n  return (fac[n] * invmod(fac[r], p) % p * invmod(fac[n - r], p) % p) % p;\n}\nbool palindrome(string s) {\n  for (long long i = 0; i < (long long)s.length() / 2; i++) {\n    if (s[i] != s[s.length() - i - 1]) return 0;\n  }\n  return 1;\n}\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<int> indegree(n + 1);\n  vector<pair<int, int> > adj[n + 5];\n  for (int i = 0; i < n; i++) {\n    int k;\n    cin >> k;\n    for (int j = 0; j < k; j++) {\n      int a;\n      cin >> a;\n      if (a < i + 1)\n        adj[a].push_back({i + 1, 0});\n      else\n        adj[a].push_back({i + 1, 1});\n      indegree[i + 1]++;\n    }\n  }\n  queue<int> q;\n  int dp[n + 5];\n  memset(dp, 0, sizeof dp);\n  for (int i = 1; i <= n; i++) {\n    if (indegree[i] == 0) q.push(i), dp[i] = 0;\n  }\n  int c = 0;\n  int ans = 0;\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n    bool flag = false;\n    for (auto it : adj[u]) {\n      if (--indegree[it.first] == 0) q.push(it.first);\n      dp[it.first] = max(dp[u] + it.second, dp[it.first]);\n    }\n    c++;\n  }\n  if (c != n) {\n    cout << -1 << \"\\n\";\n  } else {\n    int mx = *max_element(dp, dp + n + 5);\n    cout << max(1, mx + 1) << \"\\n\";\n  }\n}\nint main() {\n  clock_t start, end;\n  start = clock();\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  int t = 1;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  end = clock();\n  double time = double(end - start) / (double)(CLOCKS_PER_SEC);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar _buf[100000], *_op(_buf), *_ed(_buf);\ninline int getint() {\n  int _s = 0, _f = 1;\n  char _ch = (_op == _ed && (_ed = (_op = _buf) + fread(_buf, 1, 100000, stdin),\n                             _op == _ed)\n                  ? EOF\n                  : *_op++);\n  while (!('0' <= _ch && _ch <= '9'))\n    (_ch == '-') && (_f = -1),\n        _ch =\n            (_op == _ed && (_ed = (_op = _buf) + fread(_buf, 1, 100000, stdin),\n                            _op == _ed)\n                 ? EOF\n                 : *_op++);\n  while (('0' <= _ch && _ch <= '9'))\n    _s = _s * 10 + _ch - 48,\n    _ch = (_op == _ed && (_ed = (_op = _buf) + fread(_buf, 1, 100000, stdin),\n                          _op == _ed)\n               ? EOF\n               : *_op++);\n  return _s * _f;\n}\nconst int N = 2e5 + 1, mod = 998244353, INF = 0x3f3f3f3f;\ninline void check(int& x) { x -= mod, x += x >> 31 & mod; }\ninline void cmax(int& x, int y) {\n  if (x - y >> 31) x = y;\n}\ninline void cmin(int& x, int y) {\n  if (y - x >> 31) x = y;\n}\ninline int Pow(long long int t, int x, long long int s = 1) {\n  for (; x; x >>= 1, t = t * t % mod)\n    if (x & 1) s = s * t % mod;\n  return s;\n}\nset<int> can;\nvector<int> e[N];\nint T, n, ans, d[N];\ninline void input() {\n  n = getint(), can.clear();\n  for (int i = 1; i <= n; i++) e[i].clear(), d[i] = 0;\n  for (int i = 1; i <= n; i++) {\n    d[i] = getint();\n    for (int _ = 1; _ <= d[i]; _++) e[getint()].push_back(i);\n  }\n}\ninline void init() {\n  for (int i = 1; i <= n; i++)\n    if (!d[i]) can.insert(i);\n}\ninline void work() {\n  int cnt = 0, ans = 0;\n  while (cnt < n) {\n    ans++;\n    if (can.empty()) return void(cout << \"-1\\n\");\n    for (int u = 0; can.upper_bound(u) != can.end();) {\n      u = *can.upper_bound(u), can.erase(u), cnt++;\n      for (int v : e[u])\n        if (!--d[v]) can.insert(v);\n    }\n  }\n  cout << ans << '\\n';\n}\nint main() {\n  for (scanf(\"%d\", &T); T--;) {\n    input();\n    init();\n    work();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, in[200005], ans[200005];\nvector<int> ve[200005];\nint main() {\n  int T;\n  cin >> T;\n  while (T--) {\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n      int m;\n      cin >> m;\n      for (int j = 1, u; j <= m; j++) {\n        cin >> u;\n        ve[u].push_back(i);\n        in[i]++;\n      }\n    }\n    priority_queue<int, vector<int>, greater<int>> q;\n    queue<int> tq;\n    int cnt = 0;\n    for (int i = 1; i <= n; i++)\n      if (!in[i]) q.push(i), cnt++;\n    while (!q.empty()) {\n      int now = q.top();\n      q.pop();\n      for (auto it : ve[now]) {\n        if (it < now)\n          ans[it] = max(ans[now] + 1, ans[it]);\n        else\n          ans[it] = max(ans[now], ans[it]);\n        in[it]--;\n        if (!in[it]) {\n          if (it > now)\n            q.push(it);\n          else\n            tq.push(it);\n          cnt++;\n        }\n      }\n      if (q.empty())\n        while (!tq.empty()) q.push(tq.front()), tq.pop();\n    }\n    if (cnt != n)\n      cout << -1 << endl;\n    else\n      cout << \"\" << *(max_element(ans + 1, ans + 1 + n)) + 1 << endl;\n    for (int i = 1; i <= n; i++) {\n      ans[i] = in[i] = 0;\n      ve[i].clear();\n    }\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\npublic class TestC {\n\tprivate static HashSet<Node> path;\n\n\tpublic static void main(String args[]) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint t = Integer.parseInt(br.readLine().trim());\n\t\tvar sb = new StringBuilder();\n\t\twhile (t-- > 0) {\n\t\t\tint n = Integer.parseInt(br.readLine().trim());\n\t\t\tArrayList<Node> graph = new ArrayList<>(n + 1);\n\t\t\tfor (int i = 0; i <= n; i++)\n\t\t\t\tgraph.add(new Node(i));\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tStringTokenizer st = new StringTokenizer(br.readLine().trim(), \" \");\n\t\t\t\tint x = Integer.parseInt(st.nextToken());\n\t\t\t\tgraph.get(i + 1).children = new Node[x];\n\t\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\t\tint needed = Integer.parseInt(st.nextToken());\n\t\t\t\t\tgraph.get(i + 1).children[j] = graph.get(needed);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsb.append(solve(graph)).append(\"\\n\");\n\t\t}\n\n\t\tbr.close();\n\t\tSystem.out.println(sb);\n\t}\n\n\tprivate static void getWeight(Node cur, Node prev) {\n\t\tint weight = 0;\n\t\tpath.add(cur);\n\t\tfor (Node x : cur.children) {\n\t\t\tif (path.contains(x)) { // Cycle\n\t\t\t\tx.understood = true;\n\t\t\t\tx.weight = (int) 1e6;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!x.understood)\n\t\t\t\tgetWeight(x, cur);\n\n\t\t\tweight = Math.max(weight, x.id > cur.id ? x.weight + 1 : x.weight);\n\t\t}\n\n\t\tcur.weight = weight;\n\t\tcur.understood = true;\n\t\tpath.remove(cur);\n\t}\n\n\tprivate static int solve(ArrayList<Node> graph) {\n\t\tint ret = Integer.MIN_VALUE;\n\t\tfor (int i = 1; i < graph.size(); i++) {\n\t\t\tif (!graph.get(i).understood) {\n\t\t\t\tpath = new HashSet<>();\n\t\t\t\tgetWeight(graph.get(i), graph.get(0));\n\t\t\t}\n\t\t\tret = Math.max(ret, graph.get(i).weight);\n\t\t\tif (ret >= (int) 1e6 || ret < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn ret + 1;\n\t}\n\n\tprivate static class Node {\n\t\tint id, weight = (int) 1e6;\n\t\tboolean understood = false;\n\t\tNode[] children;\n\n\t\tNode(int id) {\n\t\t\tthis.id = id;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + id + \", \" + weight + \")\";\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "\ndef naiveSolve():\n    \n    \n    \n    return\n\n\n\ndef solve():\n    \n    \n    \n    return\n\n\n\ndef main():\n    \n    # when i say book i am really referring to chapter\n    \n    t=int(input())\n    allans=[]\n    for _ in range(t):\n        n=int(input())\n        req=[set() for __ in range(n)] # req[book] requires these other books\n        idxes=[[] for __ in range(n)] # idxes[book] are the indexes requiring this book\n        ans=[-1]*n\n        for i in range(n):\n            temp=readIntArr()\n            for j in range(1,len(temp)):\n                req[i].add(temp[j]-1)\n                idxes[temp[j]-1].append(i)\n        \n        completedBooks=[]\n        for book in range(n):\n            if len(req[book])==0:\n                completedBooks.append(book)\n                ans[book]=1\n        while completedBooks:\n            book=completedBooks.pop()\n            dist=ans[book]\n            for nex in idxes[book]:\n                if nex<book:\n                    nexDist=dist+1\n                else:\n                    nexDist=dist\n                ans[nex]=max(ans[nex],nexDist)\n                req[nex].remove(book)\n                if len(req[nex])==0: # book is complete\n                    completedBooks.append(nex)\n        \n        hasIncompleteBook=False\n        for i in range(n):\n            if len(req[i])>0:\n                hasIncompleteBook=True\n        if hasIncompleteBook:\n            ans2=-1\n        else:\n            ans2=max(ans)\n        allans.append(ans2)\n        \n    multiLineArrayPrint(allans)\n    \n    return\n\n\n\n\nimport sys\ninput=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\n# input=lambda: sys.stdin.readline().rstrip(\"\\r\\n\") #FOR READING STRING/TEXT INPUTS.\n\ndef oneLineArrayPrint(arr):\n    print(' '.join([str(x) for x in arr]))\ndef multiLineArrayPrint(arr):\n    print('\\n'.join([str(x) for x in arr]))\ndef multiLineArrayOfArraysPrint(arr):\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\n \ndef readIntArr():\n    return [int(x) for x in input().split()]\n# def readFloatArr():\n#     return [float(x) for x in input().split()]\n \ndef makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])\n    dv=defaultValFactory;da=dimensionArr\n    if len(da)==1:return [dv() for _ in range(da[0])]\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\n \ndef queryInteractive(x):\n    print('{}'.format(x))\n    sys.stdout.flush()\n    return int(input())\n \ndef answerInteractive(ans):\n    print('! {}'.format(ans))\n    sys.stdout.flush()\n \ninf=float('inf')\n# MOD=10**9+7\n# MOD=998244353\n\nfrom math import gcd,floor,ceil\n# from math import floor,ceil # for Python2\n \nfor _abc in range(1):\n    main()"
        },
        {
            "language": 3,
            "solution": "import traceback\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin = IOWrapper(sys.stdin)\n# sys.stdout = IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n#####################################################################\n\nimport math\nfrom collections import defaultdict as dfd, defaultdict, Counter, deque\nfrom functools import lru_cache\nfrom itertools import accumulate\nfrom heapq import *\nfrom bisect import *\n# from sortedcontainers import SortedList\n\ndef geti():\n    return int(input())\n\ndef gets():\n    return input()\n\ndef getil():\n    return list(map(int, input().split()))\n\ndef getsl():\n    return input().split()\n\ndef getinps(s):\n    inps = s.split()\n    m = {'i': geti, 's': gets, 'il': getil, 'sl': getsl}\n    if len(inps) == 1: return m[s]()\n    return [m[k]() for k in inps]\n\ndef get2d(nrows, ncols, n=0):\n    return [[n] * ncols for r in range(nrows)]\n\ndef get_acc(a):\n    return list(accumulate(a))\n\ndef get_ncr(n, r, mod=10**9+7):\n    num = den = 1\n    r = min(r, n-r)\n    for i in range(r):\n        num = (num * (n - i)) % mod\n        den = (den * (i + 1)) % mod\n    return num * pow(den, mod - 2, mod) % mod\n\ndef get_nc2(n):\n    return n * (n-1) // 2\n    \ndef get_npr(n, r):\n    if n < r: return 0\n    return math.factorial(n) // math.factorial(r) \n\ndef put(a):\n    return ' '.join(map(str, a))\n\n# sys.stdin = open('input.txt', 'r')\n# sys.stdout = open('output.txt', 'w')\n\n# while y:\n#     x, y = y, x % y\n\n# graph = dfd(list)\n# for _ in range(N):\n#     u, v = getil()\n#     graph[u].append(v)\n#     graph[v].append(u)\n\nALPHABETS = 'abcdefghijklmnopqrstuvwxyz'\nVOWELS = 'aeiou'\nCONSONANTS = 'bcdfghjklmnpqrstvwxyz'\n\ninf = float('inf')\nmod = 10 ** 9 + 7\n\n\nclass Solution():\n    def main(self):\n        (N, ) = getil()    \n        graph = dfd(list)\n        deg = Counter()\n        for i in range(N):\n            a = getil()[1:]\n            for j in a:\n                graph[j-1].append(i)\n                deg[i] += 1\n        cur = [i for i in range(N) if deg[i] == 0]\n        ans = 0\n        while cur:\n            r = -1\n            nxt = []\n            heapify(cur)\n            while cur:\n                if cur[0] < r:\n                    nxt.append(heappop(cur))\n                    continue\n                r = heappop(cur)\n                for nei in graph[r]:\n                    deg[nei] -= 1\n                    if deg[nei] == 0:\n                        heappush(cur, nei)\n            cur = nxt\n            ans += 1\n        if all([deg[i] == 0 for i in range(N)]):\n            return ans\n        else:\n            return -1\n                \n\n\n\ntry:\n    Sol = Solution()\n    Test = geti()\n    for _ in range(Test):\n        ans = Sol.main()  \n        print(ans)      \nexcept Exception as e:\n    print(e)\n    traceback.print_exc()"
        },
        {
            "language": 3,
            "solution": "from sys import stdin, stdout\nimport random\ninput = stdin.readline\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    after_i = dict()\n    after_i = [[] for i in range(n)]\n    before_i_count = [0 for i in range(n)]\n    q = []\n    n_reads = [1 for i in range(n)]\n    for i in range(n):\n        tmp = list(map(int, input().split()))\n        before_i_count[i] = tmp[0]\n        for t in tmp[1:]:\n            after_i[t - 1].append(i)\n        if tmp[0] == 0:\n            q.append(i)\n    \n    count = 0\n    for count, i in enumerate(q):\n        for j in after_i[i]:\n            before_i_count[j] -= 1\n            if j < i:\n                n_reads[j] = max(n_reads[j], n_reads[i] + 1)\n            else:\n                n_reads[j] = max(n_reads[j], n_reads[i])\n            if before_i_count[j] == 0:\n                q.append(j)\n    if count + 1 != n:\n        print(-1)\n    else:\n        print(max(n_reads))\n            "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 200010;\nconst int INF = 1000000007;\nint T, n;\nint d[maxn], in[maxn], vis[maxn];\nint h[maxn], cnt = 0;\nstruct Node {\n  int to, next;\n} e[maxn];\nvoid add(int u, int v) {\n  e[++cnt].to = v;\n  e[cnt].next = h[u];\n  h[u] = cnt;\n}\nqueue<int> q;\nvector<int> sor;\nvoid topo() {\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n    for (int i = h[u]; i != -1; i = e[i].next) {\n      int v = e[i].to;\n      --in[v];\n      if (!in[v]) {\n        d[v] = 1;\n        sor.push_back(v);\n        q.push(v);\n      }\n    }\n  }\n}\nlong long read() {\n  long long s = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    s = s * 10 + ch - '0';\n    ch = getchar();\n  }\n  return s * f;\n}\nint main() {\n  T = read();\n  while (T--) {\n    cnt = 0;\n    while (!q.empty()) q.pop();\n    sor.clear();\n    n = read();\n    for (int i = 1; i <= n; ++i) h[i] = -1, d[i] = 0, in[i] = 0, vis[i] = 0;\n    cnt = 0;\n    int k, a;\n    for (int j = 1; j <= n; ++j) {\n      k = read();\n      for (int i = 1; i <= k; ++i) {\n        a = read();\n        add(a, j);\n        ++in[j];\n      }\n    }\n    for (int i = 1; i <= n; ++i)\n      if (!in[i]) {\n        sor.push_back(i);\n        d[i] = 1;\n        q.push(i);\n      }\n    topo();\n    if (sor.size() < n) {\n      printf(\"-1\\n\");\n      continue;\n    }\n    for (int i = 0; i < sor.size(); ++i) {\n      int u = sor[i];\n      d[u] = max(d[u], 1);\n      for (int j = h[u]; j != -1; j = e[j].next) {\n        int v = e[j].to;\n        if (v > u)\n          d[v] = max(d[v], d[u]);\n        else\n          d[v] = max(d[v], d[u] + 1);\n      }\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; ++i) ans = max(ans, d[i]);\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nbool indicator;\nvector<vector<int>> arr;\nvector<int> price;\nvector<bool> visited;\nint dfs(int x) {\n  if (visited[x]) {\n    if (price[x] == -1) {\n      printf(\"-1\\n\");\n      indicator = true;\n      return -1;\n    } else {\n      return price[x];\n    }\n  }\n  visited[x] = true;\n  int curr = 1, temp;\n  for (int i = 0; i < arr[x].size(); i++) {\n    temp = dfs(arr[x][i]);\n    if (arr[x][i] > x) temp++;\n    curr = max(temp, curr);\n    if (indicator) return -1;\n  }\n  return price[x] = curr;\n}\nvoid solve() {\n  indicator = false;\n  int n, x;\n  scanf(\"%d\", &n);\n  arr.resize(n);\n  price.resize(n, -1);\n  visited.resize(n, false);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &x);\n    arr[i].resize(x);\n    for (int j = 0; j < x; j++) {\n      scanf(\"%d\", &arr[i][j]);\n      arr[i][j]--;\n    }\n  }\n  int ans = 1;\n  for (int i = 0; i < n; i++) {\n    if (visited[i]) continue;\n    ans = max(ans, dfs(i));\n    if (indicator) return;\n  }\n  printf(\"%d\\n\", ans);\n}\nint main() {\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    solve();\n    arr.clear();\n    price.clear();\n    visited.clear();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 200010;\nvector<int> v[maxn];\nbool vis[maxn];\npriority_queue<int, vector<int>, greater<int> > q1, q2;\nint d[maxn];\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n  int T;\n  cin >> T;\n  while (T--) {\n    int k;\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n      v[i].clear();\n      vis[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n      int x;\n      cin >> k;\n      d[i] = k;\n      if (k == 0) {\n        q1.push(i);\n      }\n      while (k--) {\n        cin >> x;\n        v[x].push_back(i);\n      }\n    }\n    int tmp;\n    int cnt = 0;\n    while (!q1.empty() || !q2.empty()) {\n      cnt++;\n      while (!q1.empty()) {\n        tmp = q1.top();\n        q1.pop();\n        vis[tmp] = 1;\n        for (int i = 0; i < v[tmp].size(); i++) {\n          d[v[tmp][i]]--;\n          if (d[v[tmp][i]] == 0) {\n            if (v[tmp][i] > tmp)\n              q1.push(v[tmp][i]);\n            else\n              q2.push(v[tmp][i]);\n          }\n        }\n      }\n      while (!q2.empty()) {\n        tmp = q2.top();\n        q2.pop();\n        q1.push(tmp);\n      }\n    }\n    int flag = 0;\n    for (int i = 1; i <= n; i++) {\n      flag += vis[i];\n    }\n    if (flag == n)\n      cout << cnt << '\\n';\n    else\n      cout << \"-1\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class A {\n    Scanner in;\n\n    class Solver {\n        ArrayList[] g;\n        Integer[] f;\n        int n;\n        boolean bad = false;\n\n        Solver() {\n            n = in.nextInt();\n            g = new ArrayList[n];\n            for (int i = 0; i < n; i++) {\n                g[i] = new ArrayList<Integer>();\n                for (int k = in.nextInt(); k > 0; k--)\n                    g[i].add(in.nextInt() - 1);\n            }\n        }\n\n        void calc(int v) {\n            f[v] = -2;\n            var ma = 1;\n            for (var _x : g[v]) {\n                int x = (Integer) _x;\n                if (f[x] == -2) bad = true;\n                if (f[x] == -1) calc(x);\n                ma = Math.max(ma, f[x] + (x > v ? 1 : 0));\n            }\n            f[v] = ma;\n        }\n\n        int solve() {\n            f = new Integer[n];\n            Arrays.fill(f, -1);\n            for (int i = 0; i < n; i++)\n                if (f[i] == -1)\n                    calc(i);\n            return bad ? -1 : Collections.max(Arrays.asList(f));\n        }\n    }\n\n    public void run() {\n        in = new Scanner(System.in);\n        for (int tn = in.nextInt(); tn > 0; tn--)\n            System.out.println(new Solver().solve());\n    }\n\n    public static void main(String[] args) {\n        new A().run();\n    }\n}\n"
        }
    ]
}