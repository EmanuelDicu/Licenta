{
    "name": "979_E. Kuro and Topological Parity",
    "source": "CODEFORCES",
    "description": "Kuro has recently won the \"Most intelligent cat ever\" contest. The three friends then decided to go to Katie's home to celebrate Kuro's winning. After a big meal, they took a small break then started playing games.\n\nKuro challenged Katie to create a game with only a white paper, a pencil, a pair of scissors and a lot of arrows (you can assume that the number of arrows is infinite). Immediately, Katie came up with the game called Topological Parity.\n\nThe paper is divided into n pieces enumerated from 1 to n. Shiro has painted some pieces with some color. Specifically, the i-th piece has color c_{i} where c_{i} = 0 defines black color, c_{i} = 1 defines white color and c_{i} = -1 means that the piece hasn't been colored yet.\n\nThe rules of the game is simple. Players must put some arrows between some pairs of different pieces in such a way that for each arrow, the number in the piece it starts from is less than the number of the piece it ends at. Also, two different pieces can only be connected by at most one arrow. After that the players must choose the color (0 or 1) for each of the unpainted pieces. The score of a valid way of putting the arrows and coloring pieces is defined as the number of paths of pieces of alternating colors. For example, [1 \u2192 0 \u2192 1 \u2192 0], [0 \u2192 1 \u2192 0 \u2192 1], [1], [0] are valid paths and will be counted. You can only travel from piece x to piece y if and only if there is an arrow from x to y.\n\nBut Kuro is not fun yet. He loves parity. Let's call his favorite parity p where p = 0 stands for \"even\" and p = 1 stands for \"odd\". He wants to put the arrows and choose colors in such a way that the score has the parity of p.\n\nIt seems like there will be so many ways which satisfy Kuro. He wants to count the number of them but this could be a very large number. Let's help him with his problem, but print it modulo 10^{9} + 7.\n\nInput\n\nThe first line contains two integers n and p (1 \u2264 n \u2264 50, 0 \u2264 p \u2264 1) \u2014 the number of pieces and Kuro's wanted parity.\n\nThe second line contains n integers c_{1}, c_{2}, ..., c_{n} (-1 \u2264 c_{i} \u2264 1) \u2014 the colors of the pieces.\n\nOutput\n\nPrint a single integer \u2014 the number of ways to put the arrows and choose colors so the number of valid paths of alternating colors has the parity of p.\n\nExamples\n\nInput\n\n3 1\n-1 0 1\n\n\nOutput\n\n6\n\nInput\n\n2 1\n1 0\n\n\nOutput\n\n1\n\nInput\n\n1 1\n-1\n\n\nOutput\n\n2\n\nNote\n\nIn the first example, there are 6 ways to color the pieces and add the arrows, as are shown in the figure below. The scores are 3, 3, 5 for the first row and 5, 3, 3 for the second row, both from left to right.\n\n<image>",
    "difficulty": "E",
    "tags": [
        "dp"
    ],
    "rating": 2400,
    "public_test": [
        {
            "input": "3 1\n-1 0 1\n",
            "output": "6\n"
        },
        {
            "input": "2 1\n1 0\n",
            "output": "1\n"
        },
        {
            "input": "1 1\n-1\n",
            "output": "2\n"
        }
    ],
    "generated_test": [
        {
            "input": "9 0\n0 1 -1 -1 -1 -1 1 1 1\n",
            "output": "755810045\n"
        },
        {
            "input": "37 0\n0 -1 0 0 0 -1 0 1 -1 0 -1 0 -1 -1 0 1 1 0 -1 -1 -1 -1 1 -1 0 0 0 1 -1 -1 1 -1 1 1 -1 -1 -1\n",
            "output": "856019167\n"
        },
        {
            "input": "10 0\n1 0 0 1 1 -1 -1 0 1 0\n",
            "output": "743685088\n"
        },
        {
            "input": "41 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 -1 0 0\n",
            "output": "681095711\n"
        },
        {
            "input": "2 0\n1 -1 1 0\n",
            "output": "3\n"
        },
        {
            "input": "26 1\n1 -1 1 1 1 1 -1 1 -1 1 0 -1 0 -1 -1 -1 1 0 -1 -1 0 1 -1 0 1 0\n",
            "output": "498381559\n"
        },
        {
            "input": "34 0\n1 1 1 0 0 0 0 1 0 0 1 -1 0 1 -1 0 -1 1 1 1 0 1 1 -1 0 0 1 -1 -1 0 0 0 -1 -1\n",
            "output": "194552344\n"
        },
        {
            "input": "5 0\n-1 0 -1 0 1\n",
            "output": "1984\n"
        },
        {
            "input": "32 1\n0 0 1 0 -1 0 1 -1 -1 -1 0 1 0 0 1 0 -1 -1 1 1 1 0 -1 1 -1 -1 1 0 0 -1 0 1\n",
            "output": "495456140\n"
        },
        {
            "input": "17 0\n0 -1 -1 0 1 -1 0 -1 -1 -1 0 -1 -1 -1 0 0 0\n",
            "output": "640731229\n"
        },
        {
            "input": "7 0\n1 0 -1 1 -1 1 1\n",
            "output": "4325376\n"
        },
        {
            "input": "20 1\n1 -1 1 -1 -1 -1 0 1 1 0 1 0 -1 1 1 -1 1 0 1 1\n",
            "output": "189946716\n"
        },
        {
            "input": "2 0\n0 0 0\n",
            "output": "2\n"
        },
        {
            "input": "18 1\n1 1 1 -1 0 -1 -1 0 -1 -1 0 0 -1 0 -1 0 -1 1\n",
            "output": "870483021\n"
        },
        {
            "input": "30 0\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1\n",
            "output": "387447621\n"
        },
        {
            "input": "50 1\n-1 -1 -1 -1 -1 0 -1 -1 -1 0 1 0 -1 0 1 -1 -1 -1 1 0 1 -1 0 1 0 1 0 0 0 1 -1 1 -1 -1 1 1 -1 -1 0 -1 -1 1 -1 1 -1 1 1 0 0 -1\n",
            "output": "260843480\n"
        },
        {
            "input": "5 1\n0 1 0 0 -1\n",
            "output": "768\n"
        },
        {
            "input": "4 1\n0 0 1 1 -1 1 -1 1 0 -1 -1 -1 0 -1 0 -1 1 0 -1 1 0 -1 -1 0 -1 1 1 -1\n",
            "output": "32\n"
        },
        {
            "input": "24 1\n0 0 0 1 1 -1 -1 0 -1 1 -1 -1 0 0 1 1 0 -1 0 0 0 0 1 1\n",
            "output": "378294608\n"
        },
        {
            "input": "9 1\n-1 -1 0 1 1 -1 -1 0 1\n",
            "output": "829551862\n"
        },
        {
            "input": "5 0\n0 -1 0 0 -1\n",
            "output": "1792\n"
        },
        {
            "input": "30 0\n1 0 1 1 0 -1 0 1 -1 -1 1 -1 0 -1 1 1 -1 1 0 1 0 -1 1 1 0 1 -1 0 1 1\n",
            "output": "519096932\n"
        },
        {
            "input": "1 0\n0\n",
            "output": "0\n"
        },
        {
            "input": "6 1\n0 -1 -1 0 0 -1\n",
            "output": "126976\n"
        },
        {
            "input": "38 0\n-1 -1 1 1 -1 -1 1 -1 0 1 -1 1 1 1 -1 1 0 1 -1 -1 1 -1 -1 0 0 1 -1 -1 0 -1 0 -1 -1 0 1 0 -1 0\n",
            "output": "388948587\n"
        },
        {
            "input": "27 1\n-1 0 -1 -1 -1 0 1 -1 1 0 0 -1 -1 1 0 0 0 -1 -1 1 -1 -1 -1 0 1 0 0\n",
            "output": "617291392\n"
        },
        {
            "input": "46 0\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1\n",
            "output": "120108192\n"
        },
        {
            "input": "31 1\n-1 1 1 1 0 -1 -1 1 1 -1 1 1 1 0 0 -1 1 0 1 -1 -1 1 0 1 1 0 1 0 0 -1 -1 1 -1 1 1 1 1 0 -1 0\n",
            "output": "140063906\n"
        },
        {
            "input": "4 1\n0 1 0 -1\n",
            "output": "80\n"
        },
        {
            "input": "3 1\n1 -1 -1\n",
            "output": "18\n"
        },
        {
            "input": "38 1\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1\n",
            "output": "84306913\n"
        },
        {
            "input": "5 1\n1 1 0 -1 -1 -1\n",
            "output": "1920\n"
        },
        {
            "input": "25 1\n1 0 0 -1 -1 0 1 0 -1 1 0 0 0 -1 0 0 1 -1 -1 0 -1 -1 -1 1 1\n",
            "output": "634141034\n"
        },
        {
            "input": "21 0\n0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0\n",
            "output": "573812615\n"
        },
        {
            "input": "14 1\n-1 0 -1 1 -1 0 0 0 -1 -1 0 -1 0 0\n",
            "output": "819781395\n"
        },
        {
            "input": "8 0\n0 0 1 -1 1 -1 1 1\n",
            "output": "536870912\n"
        },
        {
            "input": "2 1\n-1 1\n",
            "output": "1\n"
        },
        {
            "input": "29 1\n0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n",
            "output": "183480587\n"
        },
        {
            "input": "13 1\n-1 1 0 0 0 0 -1 1 -1 -1 1 1 0\n",
            "output": "263298526\n"
        },
        {
            "input": "48 1\n1 0 0 0 1 -1 1 1 1 -1 0 -1 1 1 0 -1 -1 -1 0 0 0 1 0 1 0 -1 -1 -1 -1 1 0 1 -1 -1 -1 1 -1 0 1 0 0 1 -1 0 -1 0 0 0\n",
            "output": "763606955\n"
        },
        {
            "input": "37 1\n1 -1 1 -1 -1 -1 0 1 -1 -1 1 0 0 0 1 0 -1 0 -1 1 -1 0 1 -1 -1 -1 -1 -1 0 -1 0 0 -1 0 -1 -1 -1\n",
            "output": "228356749\n"
        },
        {
            "input": "47 1\n0 -1 0 1 1 -1 1 -1 1 -1 1 -1 0 0 -1 0 -1 1 -1 -1 0 1 -1 1 0 0 1 -1 0 1 0 1 0 1 0 1 -1 -1 1 -1 -1 -1 0 1 1 0 1\n",
            "output": "716651774\n"
        },
        {
            "input": "36 1\n-1 0 -1 -1 1 0 0 -1 1 0 0 -1 1 -1 1 0 1 -1 0 0 1 1 1 0 1 1 0 -1 1 -1 0 0 0 1 1 -1\n",
            "output": "155907746\n"
        },
        {
            "input": "3 1\n-1 1 1\n",
            "output": "12\n"
        },
        {
            "input": "9 0\n0 1 -1 -1 0 -1 1 1 1\n",
            "output": "877905026\n"
        },
        {
            "input": "37 0\n0 -1 0 0 0 -1 0 1 -1 0 -1 0 -1 -1 0 1 1 0 -1 -1 -1 -1 1 -1 0 0 0 1 -1 -1 1 0 1 1 -1 -1 -1\n",
            "output": "915368288\n"
        },
        {
            "input": "41 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 -1 0 0\n",
            "output": "521643563\n"
        },
        {
            "input": "34 0\n1 1 1 1 0 0 0 1 0 0 1 -1 0 1 -1 0 -1 1 1 1 0 1 1 -1 0 0 1 -1 -1 0 0 0 -1 -1\n",
            "output": "115086916\n"
        },
        {
            "input": "5 1\n-1 0 -1 0 1\n",
            "output": "2112\n"
        },
        {
            "input": "32 1\n0 0 1 0 -1 0 1 -1 -1 -1 0 1 -1 0 1 0 -1 -1 1 1 1 0 -1 1 -1 -1 1 0 0 -1 0 1\n",
            "output": "990912280\n"
        },
        {
            "input": "17 0\n0 -1 -1 0 1 -1 -1 -1 -1 -1 0 -1 -1 -1 0 0 0\n",
            "output": "791531403\n"
        },
        {
            "input": "18 1\n1 1 1 -1 0 -1 -1 0 -1 -1 0 -1 -1 0 -1 0 -1 1\n",
            "output": "771314966\n"
        },
        {
            "input": "5 0\n0 -1 1 0 -1\n",
            "output": "2176\n"
        },
        {
            "input": "30 0\n1 0 0 1 0 -1 0 1 -1 -1 1 -1 0 -1 1 1 -1 1 0 1 0 -1 1 1 0 1 -1 0 1 1\n",
            "output": "300222383\n"
        },
        {
            "input": "6 1\n0 -1 -1 1 0 -1\n",
            "output": "133120\n"
        },
        {
            "input": "50 1\n-1 -1 1 0 1 1 0 -1 1 0 -1 -1 0 -1 -1 -1 0 1 1 -1 1 0 -1 1 1 -1 -1 -1 1 -1 -1 0 -1 0 -1 0 1 -1 -1 0 1 -1 0 1 -1 1 0 -1 -1 1\n",
            "output": "606627495\n"
        },
        {
            "input": "46 0\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1\n",
            "output": "300270480\n"
        },
        {
            "input": "50 1\n-1 -1 1 0 1 1 0 -1 1 0 -1 -1 0 -1 -1 -1 0 1 1 -1 1 0 -1 1 1 -1 -1 -1 1 -1 -1 0 -1 0 -1 0 0 -1 -1 0 1 -1 0 1 -1 1 0 -1 -1 1\n",
            "output": "260843480\n"
        },
        {
            "input": "2 1\n-1 0\n",
            "output": "1\n"
        },
        {
            "input": "10 0\n1 0 1 1 1 -1 -1 0 1 0\n",
            "output": "743685088\n"
        },
        {
            "input": "2 0\n1 -1 2 0\n",
            "output": "3\n"
        },
        {
            "input": "2 0\n1 0 0\n",
            "output": "1\n"
        },
        {
            "input": "4 1\n0 0 1 1 -1 1 -1 1 0 -1 -1 -1 0 -1 0 -1 1 0 -1 1 0 -1 0 0 -1 1 1 -1\n",
            "output": "32\n"
        },
        {
            "input": "24 1\n0 0 1 1 1 -1 -1 0 -1 1 -1 -1 0 0 1 1 0 -1 0 0 0 0 1 1\n",
            "output": "378294608\n"
        },
        {
            "input": "1 0\n1\n",
            "output": "0\n"
        },
        {
            "input": "31 1\n-1 1 1 1 0 -1 -1 1 1 -1 1 1 1 0 0 -1 1 0 1 -1 -1 1 0 1 1 0 1 0 0 -1 -1 1 -1 0 1 1 1 0 -1 0\n",
            "output": "140063906\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint c[50 + 5], f[50 + 5][50 + 5][50 + 5], C[50 + 5][50 + 5], F[50 + 5][2],\n    p[50 + 5];\ninline void rw(int& x, int y) {\n  if ((x += y) >= 1000000007) x -= 1000000007;\n}\nint main() {\n  int n, m, i, j, k, l, x, ans = 0;\n  scanf(\"%d%d\", &n, &m);\n  for (i = 1; i <= n; ++i) scanf(\"%d\", &c[i]);\n  for (i = 0; i <= n; ++i) {\n    for (C[i][0] = j = 1; j <= i; ++j)\n      C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % 1000000007;\n    for (j = 0; j <= i; ++j) rw(F[i][j & 1], C[i][j]);\n  }\n  for (p[0] = i = 1; i <= n; ++i) p[i] = (p[i - 1] + p[i - 1]) % 1000000007;\n  f[0][0][0] = 1;\n  for (i = 0; i < n; ++i)\n    for (j = 0; j <= i; ++j)\n      for (k = 0; k <= i; ++k)\n        if (f[i][j][k]) {\n          if (c[i + 1] != 0)\n            rw(f[i + 1][j + 1][k],\n               1LL * f[i][j][k] * F[k][0] % 1000000007 * p[i - k] % 1000000007),\n                rw(f[i + 1][j][k], 1LL * f[i][j][k] * F[k][1] % 1000000007 *\n                                       p[i - k] % 1000000007);\n          if (c[i + 1] != 1)\n            rw(f[i + 1][j][k + 1],\n               1LL * f[i][j][k] * F[j][0] % 1000000007 * p[i - j] % 1000000007),\n                rw(f[i + 1][j][k], 1LL * f[i][j][k] * F[j][1] % 1000000007 *\n                                       p[i - j] % 1000000007);\n        }\n  for (i = 0; i <= n; ++i)\n    for (j = 0; j <= n; ++j)\n      if (((i + j) & 1) == m) rw(ans, f[n][i][j]);\n  printf(\"%d\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1000000007;\nlong long n, m, x, ans, g[52][52][2], f[52][52][52][52][2], pw[52];\nvoid upd(long long &x, long long y) {\n  x += y;\n  if (x >= mod) x %= mod;\n}\nint main() {\n  scanf(\"%lld%lld\", &n, &m);\n  pw[0] = 1;\n  for (int i = 1; i <= n; ++i) pw[i] = pw[i - 1] * 2 % mod;\n  g[0][0][0] = 1;\n  for (long long i = 1; i <= n; ++i) g[0][i][0] = g[0][i - 1][0] * 2 % mod;\n  for (long long i = 1; i <= n; ++i) {\n    g[i][0][0] = g[i][0][1] = (g[i - 1][0][0] + g[i - 1][0][1]) % mod;\n    for (long long j = 1; j <= n; ++j) {\n      g[i][j][0] = g[i][j - 1][0] * 2 % mod;\n      g[i][j][1] = g[i][j - 1][1] * 2 % mod;\n    }\n  }\n  f[0][0][0][0][0] = 1;\n  for (long long i = 1; i <= n; ++i) {\n    scanf(\"%lld\", &x);\n    for (long long j1 = 0; j1 < i; ++j1)\n      for (long long j2 = 0; j1 + j2 < i; ++j2)\n        for (long long j3 = 0; j1 + j2 + j3 < i; ++j3) {\n          long long j4 = i - 1 - j1 - j2 - j3;\n          for (long long k = 0; k < 2; ++k) {\n            if (x == 0 || x == -1) {\n              upd(f[i][j1 + 1][j2][j3][k ^ 1],\n                  f[i - 1][j1][j2][j3][k] * g[j2][j4][0] % mod * pw[j1 + j3]);\n              upd(f[i][j1][j2][j3 + 1][k],\n                  f[i - 1][j1][j2][j3][k] * g[j2][j4][1] % mod * pw[j1 + j3]);\n            }\n            if (x == 1 || x == -1) {\n              upd(f[i][j1][j2 + 1][j3][k ^ 1],\n                  f[i - 1][j1][j2][j3][k] * g[j1][j3][0] % mod * pw[j2 + j4]);\n              upd(f[i][j1][j2][j3][k],\n                  f[i - 1][j1][j2][j3][k] * g[j1][j3][1] % mod * pw[j2 + j4]);\n            }\n          }\n        }\n  }\n  for (long long j1 = 0; j1 <= n; ++j1)\n    for (long long j2 = 0; j1 + j2 <= n; ++j2)\n      for (long long j3 = 0; j1 + j2 + j3 <= n; ++j3)\n        upd(ans, f[n][j1][j2][j3][m]);\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\ninline long long read() {\n  register long long x = 0, f = 1;\n  register char c = getchar();\n  for (; !isdigit(c); c = getchar())\n    if (c == '-') f = -1;\n  for (; isdigit(c); c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);\n  return x * f;\n}\nvoid write(long long x) {\n  if (x < 0) x = -x, putchar('-');\n  if (x >= 10) write(x / 10);\n  putchar(x % 10 + '0');\n}\nvoid writeln(long long x) {\n  write(x);\n  puts(\"\");\n}\nconst int mod = 1e9 + 7;\nconst int maxn = 55;\nint n, p, pow2[maxn], f[maxn][3][3];\nvoid add(int &x, int v) {\n  x += v;\n  if (x >= mod) x -= mod;\n}\nint main() {\n  n = read(), p = read();\n  pow2[0] = 1;\n  for (register int i = (1); i <= int(n); ++i) pow2[i] = pow2[i - 1] * 2 % mod;\n  f[0][0][0] = 1;\n  for (register int i = (0); i < int(n); ++i) {\n    int x = read();\n    for (register int j = (0); j <= int(2); ++j) {\n      for (register int k = (0); k <= int(2); ++k) {\n        if (!f[i][j][k]) continue;\n        if (x != 1) {\n          if (k == 0) {\n            add(f[i + 1][j ? 3 - j : 1][k], 1ll * f[i][j][k] * pow2[i] % mod);\n          } else {\n            add(f[i + 1][j ? 3 - j : 1][k],\n                1ll * f[i][j][k] * pow2[i - 1] % mod);\n            add(f[i + 1][j ? j + 0 : 0][k],\n                1ll * f[i][j][k] * pow2[i - 1] % mod);\n          }\n        }\n        if (x != 0) {\n          if (j == 0) {\n            add(f[i + 1][j][k ? 3 - k : 1], 1ll * f[i][j][k] * pow2[i] % mod);\n          } else {\n            add(f[i + 1][j][k ? 3 - k : 1],\n                1ll * f[i][j][k] * pow2[i - 1] % mod);\n            add(f[i + 1][j][k ? k + 0 : 0],\n                1ll * f[i][j][k] * pow2[i - 1] % mod);\n          }\n        }\n      }\n    }\n  }\n  int ans = 0;\n  for (register int i = (0); i <= int(2); ++i)\n    for (register int j = (0); j <= int(2); ++j)\n      if (((i + j) & 1) == p) add(ans, f[n][i][j]);\n  writeln(ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int MAX_N = 2e5, inf = 1e9, mod = 1e9 + 7;\nlong long int a[55], dp[55][55][55][55] = {};\nint32_t main() {\n  ios ::sync_with_stdio(0);\n  cin.tie(0);\n  long long int pt[100] = {1};\n  for (long long int i = 1; i < 100; i++) pt[i] = (pt[i - 1] * 2) % mod;\n  long long int n, p;\n  cin >> n >> p;\n  dp[0][0][0][0] = 1;\n  for (long long int i = 1; i <= n; i++) cin >> a[i];\n  for (long long int i = 1; i <= n; i++) {\n    for (long long int ew = 0; ew <= i; ew++) {\n      for (long long int ow = 0; ow <= i; ow++) {\n        for (long long int eb = 0; eb <= i; eb++) {\n          long long int ob = i - ew - ow - eb - 1;\n          if (ob < 0) continue;\n          long long int r = 0;\n          if (a[i] != 1) {\n            r = ob + eb + ew;\n            if (ow) r += ow - 1;\n            dp[i][ew][ow][eb] =\n                (dp[i][ew][ow][eb] + dp[i - 1][ew][ow][eb] * (pt[r]) % mod) %\n                mod;\n            if (ow)\n              dp[i][ew][ow][eb + 1] = (dp[i][ew][ow][eb + 1] +\n                                       dp[i - 1][ew][ow][eb] * (pt[r]) % mod) %\n                                      mod;\n          }\n          if (a[i] != 0) {\n            r = ew + ow + eb;\n            if (ob) r += ob - 1;\n            dp[i][ew][ow + 1][eb] =\n                (dp[i][ew][ow + 1][eb] + dp[i - 1][ew][ow][eb] * pt[r] % mod) %\n                mod;\n            if (ob)\n              dp[i][ew + 1][ow][eb] = (dp[i][ew + 1][ow][eb] +\n                                       dp[i - 1][ew][ow][eb] * (pt[r]) % mod) %\n                                      mod;\n          }\n        }\n      }\n    }\n  }\n  long long int ans = 0;\n  for (long long int ew = 0; ew <= n; ew++) {\n    for (long long int ow = 0; ow <= n; ow++) {\n      for (long long int eb = 0; eb <= n; eb++) {\n        long long int ob = n - ew - ow - eb;\n        if (ob < 0) continue;\n        if ((ob + ow) % 2 == p) {\n          ans += dp[n][ew][ow][eb];\n          ans %= mod;\n        }\n      }\n    }\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long Count[52 + 1][52 + 1][52 + 1][52 + 1];\nint main() {\n  int n, p;\n  scanf(\"%d%d\", &n, &p);\n  int c[n + 2];\n  for (int i = 0; i < n; ++i) scanf(\"%d\", &c[i]);\n  long long ans = 0;\n  Count[0][0][0][0] = 1;\n  for (int be = 0; be <= n; ++be)\n    for (int we = 0; we + be <= n; ++we)\n      for (int bo = 0; bo + be + we <= n; ++bo)\n        for (int wo = 0; bo + be + we + wo <= n; ++wo) {\n          int i = be + we + bo + wo;\n          if (c[i] != 0) {\n            long long s = i ? ((1LL << (i - 1)) % 1000000007LL) : 1;\n            if (bo) {\n              Count[be][we + 1][bo][wo] += 1LL * Count[be][we][bo][wo] * s;\n              Count[be][we + 1][bo][wo] %= 1000000007LL;\n            } else\n              s = (1LL << i) % 1000000007LL;\n            Count[be][we][bo][wo + 1] += 1LL * Count[be][we][bo][wo] * s;\n            Count[be][we][bo][wo + 1] %= 1000000007LL;\n          }\n          if (c[i] != 1) {\n            long long s = i ? ((1LL << (i - 1)) % 1000000007LL) : 1;\n            if (wo) {\n              Count[be + 1][we][bo][wo] += 1LL * Count[be][we][bo][wo] * s;\n              Count[be + 1][we][bo][wo] %= 1000000007LL;\n            } else\n              s = (1LL << i) % 1000000007LL;\n            Count[be][we][bo + 1][wo] += 1LL * Count[be][we][bo][wo] * s;\n            Count[be][we][bo + 1][wo] %= 1000000007LL;\n          }\n          if (i == n && ((bo + wo) & 1) == p) {\n            ans += Count[be][we][bo][wo];\n            ans %= 1000000007LL;\n          }\n        }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint Q, N, M, K, L;\nstruct ModLL {\n  long long value;\n  ModLL() { this->value = 0; }\n  ModLL(long long value) { this->value = value; }\n  ModLL(int value) { this->value = value; }\n  ModLL& operator=(const ModLL& rhs) {\n    value = rhs.value;\n    return *this;\n  }\n  ModLL& operator=(int rhs) {\n    value = rhs;\n    return *this;\n  }\n  ModLL& operator=(long long rhs) {\n    value = rhs;\n    return *this;\n  }\n  ModLL operator+(const ModLL& rhs) {\n    return ModLL(ModLL{(value + rhs.value) % 1000000007});\n  }\n  ModLL operator-(const ModLL& rhs) {\n    return ModLL(\n        ModLL{((value - rhs.value) % 1000000007 + 1000000007) % 1000000007});\n  }\n  ModLL operator*(const ModLL& rhs) {\n    return ModLL(\n        ModLL{((value * rhs.value) % 1000000007 + 1000000007) % 1000000007});\n  }\n  ModLL operator+(long long rhs) {\n    return ModLL(ModLL{(value + rhs) % 1000000007});\n  }\n  ModLL operator-(long long rhs) {\n    return ModLL(ModLL{((value - rhs) % 1000000007 + 1000000007) % 1000000007});\n  }\n  ModLL operator*(long long rhs) {\n    return ModLL(ModLL{((value * rhs) % 1000000007 + 1000000007) % 1000000007});\n  }\n  ModLL& operator+=(const ModLL& rhs) {\n    *this = *this + rhs;\n    return *this;\n  }\n  ModLL& operator-=(const ModLL& rhs) {\n    *this = *this - rhs;\n    return *this;\n  }\n  ModLL& operator*=(const ModLL& rhs) {\n    *this = *this * rhs;\n    return *this;\n  }\n  ModLL& operator+=(long long rhs) {\n    *this = *this + rhs;\n    return *this;\n  }\n  ModLL& operator-=(long long rhs) {\n    *this = *this - rhs;\n    return *this;\n  }\n  ModLL& operator*=(long long rhs) {\n    *this = *this * rhs;\n    return *this;\n  }\n};\nstd::ostream& operator<<(std::ostream& stream, const ModLL& modLL) {\n  stream << modLL.value;\n  return stream;\n}\nModLL dp[51][51][51][51];\nModLL po[51];\nint A[51];\nModLL po2(int n) {\n  if (n < 0) return 1;\n  return po[n];\n}\nint main() {\n  cin >> N >> M;\n  for (int i = 1; i <= N; i++) {\n    cin >> A[i];\n  }\n  po[0] = 1;\n  for (int i = 1; i < 51; i++) po[i] = po[i - 1] * 2;\n  dp[0][0][0][0] = 1;\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j <= N; j++) {\n      for (int k = 0; k <= N; k++) {\n        for (int l = 0; l <= N; l++) {\n          int ow = j;\n          int ew = k;\n          int ob = l;\n          int eb = i - j - k - l;\n          if (eb < 0) continue;\n          if (A[i + 1] != 0) {\n            ModLL d =\n                dp[i][ow][ew][ob] * po2(ob - 1) * po2(eb) * po2(ow) * po2(ew);\n            dp[i + 1][ow + 1][ew][ob] +=\n                dp[i][ow][ew][ob] * po2(ob - 1) * po2(eb) * po2(ow) * po2(ew);\n            if (ob)\n              dp[i + 1][ow][ew + 1][ob] +=\n                  dp[i][ow][ew][ob] * po2(ob - 1) * po2(eb) * po2(ow) * po2(ew);\n          }\n          if (A[i + 1] != 1) {\n            dp[i + 1][ow][ew][ob + 1] +=\n                dp[i][ow][ew][ob] * po2(ow - 1) * po2(ew) * po2(ob) * po2(eb);\n            if (ow)\n              dp[i + 1][ow][ew][ob] +=\n                  dp[i][ow][ew][ob] * po2(ow - 1) * po2(ew) * po2(ob) * po2(eb);\n          }\n        }\n      }\n    }\n  }\n  ModLL ret = 0;\n  for (int j = 0; j <= N; j++) {\n    for (int k = 0; k <= N; k++) {\n      for (int l = 0; l <= N; l++) {\n        int ow = j;\n        int ew = k;\n        int ob = l;\n        int eb = N - j - k - l;\n        if (eb < 0) continue;\n        if ((ow + ob) % 2 != M) continue;\n        ret += dp[N][ow][ew][ob];\n      }\n    }\n  }\n  cout << ret;\n  cin >> N;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 105;\nint f[MAXN][2][2][2], n, sta, a[MAXN], bin[MAXN];\ninline void mul(int& x, int a, int b) {\n  a = (long long)a * b % 1000000007;\n  x += a;\n  if (x >= 1000000007) x -= 1000000007;\n}\nint main() {\n  scanf(\"%d%d\", &n, &sta);\n  bin[0] = 1;\n  for (int i = 1; i <= 100; ++i)\n    bin[i] = (long long)bin[i - 1] * 2 % 1000000007;\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", a + i);\n  f[0][0][0][0] = 1;\n  for (int i = 0; i < n; ++i) {\n    for (int w1 = 0; w1 <= min(i, 1); ++w1)\n      for (int b1 = 0; w1 + b1 <= i && b1 <= min(i, 1); ++b1)\n        for (int sta1 = 0; sta1 <= w1 + b1 && sta1 <= 1; ++sta1) {\n          if (a[i + 1] != 1) {\n            if (b1 && i > 0) {\n              mul(f[i + 1][w1 | 1][b1][sta1 ^ 1], f[i][w1][b1][sta1],\n                  bin[i - 1]);\n              mul(f[i + 1][w1][b1][sta1], f[i][w1][b1][sta1], bin[i - 1]);\n            } else if (!b1) {\n              mul(f[i + 1][w1 | 1][b1][sta1 ^ 1], f[i][w1][b1][sta1], bin[i]);\n            }\n          }\n          if (a[i + 1] != 0) {\n            if (w1 && i > 0) {\n              mul(f[i + 1][w1][b1 | 1][sta1 ^ 1], f[i][w1][b1][sta1],\n                  bin[i - 1]);\n              mul(f[i + 1][w1][b1][sta1], f[i][w1][b1][sta1], bin[i - 1]);\n            } else if (!w1) {\n              mul(f[i + 1][w1][b1 | 1][sta1 ^ 1], f[i][w1][b1][sta1], bin[i]);\n            }\n          }\n        }\n  }\n  int ans = 0;\n  for (int w1 = 0; w1 <= min(n, 1); ++w1)\n    for (int b1 = 0; w1 + b1 <= n && b1 <= min(n, 1); ++b1)\n      for (int sta1 = 0; sta1 <= w1 + b1 && sta1 <= 1; ++sta1)\n        if ((sta1 & 1) == sta) mul(ans, f[n][w1][b1][sta1], 1);\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <typename T>\ninline void read(T &x) {\n  x = 0;\n  char c = getchar();\n  bool flag = false;\n  while (!isdigit(c)) {\n    if (c == '-') flag = true;\n    c = getchar();\n  }\n  while (isdigit(c)) x = x * 10 + (c ^ 48), c = getchar();\n  if (flag) x = -x;\n}\nusing namespace std;\nconst int P = 1e9 + 7;\nlong long mi[123];\nint n, tp[123], p;\ninline void init() {\n  const int up = n + 5;\n  mi[0] = 1;\n  for (int i = 1; i <= up; ++i) mi[i] = mi[i - 1] * 2 % P;\n}\nlong long f[123][2][2][2];\ninline void work() {\n  f[n + 1][0][0][0] = 1;\n  for (int i = n; i; --i) {\n    for (int a = 0; a < 2; ++a) {\n      for (int b = 0; b < 2; ++b) {\n        for (int c = 0; c < 2; ++c)\n          if (f[i + 1][a][b][c]) {\n            long long tmp = f[i + 1][a][b][c];\n            if (tp[i] != 1) {\n              if (!b) {\n                f[i][1][b][c ^ 1] = (f[i][1][b][c ^ 1] + tmp * mi[n - i]) % P;\n              } else {\n                f[i][1][b][c ^ 1] =\n                    (f[i][1][b][c ^ 1] + tmp * mi[n - i - 1]) % P;\n                f[i][a][b][c] = (f[i][a][b][c] + tmp * mi[n - i - 1]) % P;\n              }\n            }\n            if (tp[i] != 0) {\n              if (!a) {\n                f[i][a][1][c ^ 1] = (f[i][a][1][c ^ 1] + tmp * mi[n - i]) % P;\n              } else {\n                f[i][a][1][c ^ 1] =\n                    (f[i][a][1][c ^ 1] + tmp * mi[n - i - 1]) % P;\n                f[i][a][b][c] = (f[i][a][b][c] + tmp * mi[n - i - 1]) % P;\n              }\n            }\n          }\n      }\n    }\n  }\n  long long res =\n      (f[1][0][0][p] + f[1][0][1][p] + f[1][1][0][p] + f[1][1][1][p]) % P;\n  printf(\"%lld\\n\", (res % P + P) % P);\n}\nint main() {\n  read(n);\n  read(p);\n  init();\n  for (int i = 1; i <= n; ++i) read(tp[i]);\n  work();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 55;\nconst long long MOD = 1000000007;\nint n, p, a[MAXN];\nlong long pw[MAXN], f[MAXN][2][2][2];\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr), cout.tie(nullptr);\n  cin >> n >> p;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  pw[0] = 1;\n  for (int i = 1; i <= n; i++) pw[i] = pw[i - 1] * 2 % MOD;\n  f[0][0][0][0] = 1;\n  for (int i = 0; i < n; i++)\n    for (int x = 0; x < 2; x++)\n      for (int y = 0; y < 2; y++)\n        for (int z = 0; z < 2; z++) {\n          if (a[i + 1] != 0) {\n            (f[i + 1][x][y][z] += f[i][x][y][z] * (x == 0 ? 0 : pw[i - 1])) %=\n                MOD;\n            (f[i + 1][x][y | 1][z ^ 1] +=\n             f[i][x][y][z] * (x == 0 ? pw[i] : pw[i - 1])) %= MOD;\n          }\n          if (a[i + 1] != 1) {\n            (f[i + 1][x][y][z] += f[i][x][y][z] * (y == 0 ? 0 : pw[i - 1])) %=\n                MOD;\n            (f[i + 1][x | 1][y][z ^ 1] +=\n             f[i][x][y][z] * (y == 0 ? pw[i] : pw[i - 1])) %= MOD;\n          }\n        }\n  long long ans = 0;\n  for (int x = 0; x < 2; x++)\n    for (int y = 0; y < 2; y++) (ans += f[n][x][y][p]) %= MOD;\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint c[55];\nconst int mod = 1000000000 + 7;\nlong long bin[111];\nint p;\nlong long mem[55][55][55][55];\nlong long dp(int cur, int white_odd, int black_odd, int white) {\n  if (cur == n + 1) {\n    if (((white_odd + black_odd) & 1) == p) return 1;\n    return 0;\n  }\n  if (mem[cur][white_odd][black_odd][white] != -1)\n    return mem[cur][white_odd][black_odd][white];\n  int black = cur - 1 - white;\n  int white_even = white - white_odd;\n  int black_even = black - black_odd;\n  long long ans = 0;\n  if (c[cur] == 1 || c[cur] == -1) {\n    long long odd = black_odd ? (bin[black_even] * bin[black_odd - 1]) : 0;\n    odd %= mod;\n    long long even =\n        black_odd ? (bin[black_even] * bin[black_odd - 1]) : bin[black_even];\n    even %= mod;\n    ans += ((bin[white] * odd) % mod) *\n           dp(cur + 1, white_odd, black_odd, white + 1);\n    ans += ((bin[white] * even) % mod) *\n           dp(cur + 1, white_odd + 1, black_odd, white + 1);\n    ans %= mod;\n  }\n  if (c[cur] == 0 || c[cur] == -1) {\n    long long odd = white_odd ? (bin[white_even] * bin[white_odd - 1]) : 0;\n    odd %= mod;\n    long long even =\n        white_odd ? (bin[white_even] * bin[white_odd - 1]) : bin[white_even];\n    even %= mod;\n    ans +=\n        ((bin[black] * odd) % mod) * dp(cur + 1, white_odd, black_odd, white);\n    ans += ((bin[black] * even) % mod) *\n           dp(cur + 1, white_odd, black_odd + 1, white);\n    ans %= mod;\n  }\n  return mem[cur][white_odd][black_odd][white] = ans;\n}\nint main(int argc, char const *argv[]) {\n  bin[0] = 1;\n  for (int i = 1; i <= 100; i++) {\n    bin[i] = bin[i - 1] + bin[i - 1];\n    bin[i] %= mod;\n  }\n  scanf(\"%d %d\", &n, &p);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &c[i]);\n  }\n  memset(mem, -1, sizeof mem);\n  printf(\"%lld\\n\", dp(1, 0, 0, 0));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long M = 1E9 + 7;\nconst long long NMAX = 55;\nconst long long inf = 1E9;\nconst long double eps = 1e-6;\nconst long long base = 29;\nlong long dp[NMAX][NMAX][NMAX][NMAX];\nint a[NMAX];\nlong long c[NMAX][NMAX];\nlong long pow2[NMAX];\nlong long sum[NMAX][2];\nint main() {\n  cin.tie(0);\n  cout.tie(0);\n  cin.sync_with_stdio(0);\n  cout.sync_with_stdio(0);\n  cout.precision(20);\n  srand(1);\n  int n, p;\n  cin >> n >> p;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  pow2[0] = 1;\n  for (int i = 1; i <= n; i++) pow2[i] = pow2[i - 1] * 2 % M;\n  for (int i = 0; i <= n; i++) c[i][0] = c[i][i] = 1;\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j < i; j++) {\n      c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % M;\n    }\n  for (int i = 0; i <= n; i++) {\n    for (int j = 0; j <= i; j += 2) {\n      sum[i][0] += c[i][j];\n      sum[i][0] %= M;\n    }\n    for (int j = 1; j <= i; j += 2) {\n      sum[i][1] += c[i][j];\n      sum[i][1] %= M;\n    }\n  }\n  dp[0][0][0][0] = 1;\n  for (int i = 1; i <= n; i++) {\n    for (int ow = 0; ow <= i; ow++) {\n      for (int ew = 0; ew <= i - ow; ew++) {\n        for (int ob = 0; ob <= i - ow - ew; ob++) {\n          int eb = i - ow - ew - ob;\n          dp[i][ow][ew][ob] = 0;\n          if (a[i] == 1) {\n            if (ow != 0) {\n              dp[i][ow][ew][ob] += pow2[ew + ow + eb - 1] *\n                                   dp[i - 1][ow - 1][ew][ob] % M * sum[ob][0] %\n                                   M;\n            }\n            if (ew != 0) {\n              dp[i][ow][ew][ob] += pow2[ew + ow + eb - 1] *\n                                   dp[i - 1][ow][ew - 1][ob] % M * sum[ob][1] %\n                                   M;\n            }\n          } else if (a[i] == 0) {\n            if (ob != 0) {\n              dp[i][ow][ew][ob] += pow2[eb + ob + ew - 1] *\n                                   dp[i - 1][ow][ew][ob - 1] % M * sum[ow][0] %\n                                   M;\n            }\n            if (eb != 0) {\n              dp[i][ow][ew][ob] += pow2[eb + ob + ew - 1] *\n                                   dp[i - 1][ow][ew][ob] % M * sum[ow][1] % M;\n            }\n          } else {\n            if (ow != 0) {\n              dp[i][ow][ew][ob] += pow2[ew + ow + eb - 1] *\n                                   dp[i - 1][ow - 1][ew][ob] % M * sum[ob][0] %\n                                   M;\n            }\n            if (ew != 0) {\n              dp[i][ow][ew][ob] += pow2[ew + ow + eb - 1] *\n                                   dp[i - 1][ow][ew - 1][ob] % M * sum[ob][1] %\n                                   M;\n            }\n            if (ob != 0) {\n              dp[i][ow][ew][ob] += pow2[eb + ob + ew - 1] *\n                                   dp[i - 1][ow][ew][ob - 1] % M * sum[ow][0] %\n                                   M;\n            }\n            if (eb != 0) {\n              dp[i][ow][ew][ob] += pow2[eb + ob + ew - 1] *\n                                   dp[i - 1][ow][ew][ob] % M * sum[ow][1] % M;\n            }\n          }\n          dp[i][ow][ew][ob] %= M;\n        }\n      }\n    }\n  }\n  long long ans = 0;\n  for (int ow = 0; ow <= n; ow++)\n    for (int ew = 0; ew <= n - ow; ew++) {\n      for (int ob = 0; ob <= n - ow - ew; ob++) {\n        int eb = n - ow - ew - ob;\n        if (p == (ob + ow) % 2) {\n          ans = (ans + dp[n][ow][ew][ob]) % M;\n        }\n      }\n    }\n  cout << ans;\n  return 0;\n};\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 55, mod = 1000000007;\nint c[N], n, p, dp[N][2][2][2], p2[N], ans;\nvoid up(int &x, int y) { x += y - mod, x += x >> 31 & mod; }\nvoid up(int &x, int y, int z) { x = (x + (long long)y * z) % mod; }\nint main() {\n  std::ios::sync_with_stdio(0), std::cin.tie(0);\n  std::cin >> n >> p;\n  for (int i = 0; i < n; ++i) std::cin >> c[i];\n  p2[0] = 1;\n  for (int i = 0; i < n; ++i) up(p2[i + 1] = p2[i], p2[i]);\n  dp[0][0][0][0] = 1;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < 2; ++j)\n      for (int k = 0; k < 2; ++k)\n        for (int l = 0; l < 2; ++l)\n          if (int v = dp[i][j][k][l]) {\n            if (c[i] != 1) {\n              if (k) {\n                up(dp[i + 1][j][k][l], v, p2[i - 1]);\n                up(dp[i + 1][1][k][l ^ 1], v, p2[i - 1]);\n              } else {\n                up(dp[i + 1][1][k][l ^ 1], v, p2[i]);\n              }\n            }\n            if (c[i] != 0) {\n              if (j) {\n                up(dp[i + 1][j][k][l], v, p2[i - 1]);\n                up(dp[i + 1][j][1][l ^ 1], v, p2[i - 1]);\n              } else {\n                up(dp[i + 1][j][1][l ^ 1], v, p2[i]);\n              }\n            }\n          }\n  for (int i = 0; i < 2; ++i)\n    for (int j = 0; j < 2; ++j) up(ans, dp[n][i][j][p]);\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint intcmp(const void *v1, const void *v2) { return *(int *)v1 - *(int *)v2; }\nconst int N = 55;\nint n, p, c[N];\nlong long f[N][N][N][N];\nlong long ans = 0, pw[N], od[N], ev[N];\nlong long power(int u, int p) {\n  if (p == 0) return 1;\n  long long ret = power(u, p >> 1);\n  (ret *= ret) %= 1000000007;\n  if (p & 1) (ret *= u) %= 1000000007;\n  return ret;\n}\nvoid init() {\n  f[0][0][0][0] = 1;\n  pw[0] = 1;\n  ev[0] = 1;\n  for (int i = 1; i < N; i++) {\n    pw[i] = pw[i - 1] * 2 % 1000000007;\n    od[i] = ev[i] = pw[i - 1];\n  }\n}\nvoid find_ans(int ob, int eb, int ow, int ew, int col, long long &ret) {\n  if (col != 0 && ew != 0)\n    (ret += f[ob][eb][ow][ew - 1] * pw[ow + ew - 1 + eb] % 1000000007 * od[ob] %\n            1000000007) %= 1000000007;\n  if (col != 0 && ow != 0)\n    (ret += f[ob][eb][ow - 1][ew] * pw[ow - 1 + ew + eb] % 1000000007 * ev[ob] %\n            1000000007) %= 1000000007;\n  if (col != 1 && eb != 0)\n    (ret += f[ob][eb - 1][ow][ew] * pw[ob + eb - 1 + ew] % 1000000007 * od[ow] %\n            1000000007) %= 1000000007;\n  if (col != 1 && ob != 0)\n    (ret += f[ob - 1][eb][ow][ew] * pw[ob - 1 + eb + ew] % 1000000007 * ev[ow] %\n            1000000007) %= 1000000007;\n}\nint main() {\n  init();\n  cin >> n >> p;\n  for (int i = 1; i < n + 1; i++) scanf(\"%d\", c + i);\n  for (int i = 1; i < n + 1; i++)\n    for (int ob = 0; ob < i + 1; ob++)\n      for (int eb = 0; eb < i - ob + 1; eb++)\n        for (int ow = 0; ow < i - ob - eb + 1; ow++) {\n          int ew = i - ob - eb - ow;\n          find_ans(ob, eb, ow, ew, c[i], f[ob][eb][ow][ew]);\n          if (i == n && ((ob + ow) & 1) == p)\n            (ans += f[ob][eb][ow][ew]) %= 1000000007;\n        }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nint main() {\n  int n, p;\n  cin >> n >> p;\n  int st[n + 1];\n  st[0] = 1;\n  for (int a = 1; a <= n; a++) st[a] = (st[a - 1] * 2) % mod;\n  int dp[n + 1][n + 1][n + 1];\n  for (int a = 0; a <= n; a++)\n    for (int b = 0; b <= n; b++)\n      for (int c = 0; c <= n; c++) dp[a][b][c] = 0;\n  dp[0][0][0] = 1;\n  for (int a = 0; a < n; a++) {\n    int x;\n    cin >> x;\n    for (int b = 0; b <= a; b++) {\n      for (int c = 0; b + c <= a; c++) {\n        if (x == 0 or x == -1) {\n          int va = (1ll * st[a - b - c] * dp[a][b][c]) % mod;\n          va = (1ll * va * st[b]) % mod;\n          if (c == 0)\n            dp[a + 1][b + 1][c] = (dp[a + 1][b + 1][c] + va) % mod;\n          else {\n            dp[a + 1][b][c] = (dp[a + 1][b][c] + 1ll * va * st[c - 1]) % mod;\n            dp[a + 1][b + 1][c] =\n                (dp[a + 1][b + 1][c] + 1ll * va * st[c - 1]) % mod;\n          }\n        }\n        if (x == 1 or x == -1) {\n          int va = (1ll * st[a - b - c] * dp[a][b][c]) % mod;\n          va = (1ll * va * st[c]) % mod;\n          if (b == 0)\n            dp[a + 1][b][c + 1] = (dp[a + 1][b][c + 1] + va) % mod;\n          else {\n            dp[a + 1][b][c] = (dp[a + 1][b][c] + 1ll * va * st[b - 1]) % mod;\n            dp[a + 1][b][c + 1] =\n                (dp[a + 1][b][c + 1] + 1ll * va * st[b - 1]) % mod;\n          }\n        }\n      }\n    }\n  }\n  int an = 0;\n  for (int a = 0; a <= n; a++) {\n    for (int b = 0; b + a <= n; b++) {\n      if ((a + b) % 2 == p) an = (an + dp[n][a][b]) % mod;\n    }\n  }\n  cout << an;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::make_pair;\nusing std::pair;\nconst int N = 55, mod = 1000000007;\nlong long dp[N][N][N][N], orip[N];\nlong long* pw = orip + 1;\nvoid init() {\n  pw[-1] = 1;\n  pw[0] = 1;\n  dp[0][0][0][0] = 1;\n  for (register int i = (1); i <= (50); ++i) (pw[i] = pw[i - 1] * 2) %= mod;\n}\nint main() {\n  std::ios::sync_with_stdio(false);\n  cout.tie(0);\n  init();\n  long long ans = 0;\n  int n, p;\n  int c[60];\n  cin >> n >> p;\n  for (register int i = (1); i <= (n); ++i) cin >> c[i];\n  for (register int i = (1); i <= (n); ++i)\n    for (register int ob = (0); ob <= (i); ++ob)\n      for (register int eb = (0); eb <= (i - ob); ++eb)\n        for (register int ow = (0); ow <= (i - ob - eb); ++ow) {\n          int ew = i - ob - eb - ow;\n          long long& cur = dp[i][ob][eb][ow];\n          cur = 0;\n          if (c[i] != 1) {\n            long long t = pw[ob + eb - 1 + ew] * pw[ow - 1] % mod;\n            if (ob > 0) (cur += dp[i - 1][ob - 1][eb][ow] * t % mod) %= mod;\n            if (eb > 0 && ow != 0)\n              (cur += dp[i - 1][ob][eb - 1][ow] * t % mod) %= mod;\n          }\n          if (c[i] != 0) {\n            long long t = pw[ow + ew + eb - 1] * pw[ob - 1] % mod;\n            if (ow > 0) (cur += dp[i - 1][ob][eb][ow - 1] * t % mod) % mod;\n            if (ew > 0 && ob != 0)\n              (cur += dp[i - 1][ob][eb][ow] * t % mod) % mod;\n          }\n          if (i == n && (ow + ob) % 2 == p) (ans += cur) %= mod;\n        }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 52;\nconst long long MOD = 1e9 + 7;\nint n, p, c[N];\nlong long C[N][N];\nlong long f[N][N][N][N];\nvoid add(long long& x, long long y) {\n  x += y;\n  x %= MOD;\n}\nvoid upd(int i, int j, int k, int x) {\n  if (f[i][j][k][x] == 0) return;\n  int y = (n - i + 1) - (j + k + x);\n  if (i == 1) return;\n  for (int col = 0; col < 2; col++) {\n    if (c[i - 1] == -1 || c[i - 1] == col) {\n      if (col == 0) {\n        long long w0 = ((1LL << x) % MOD) * ((1LL << y) / 2 % MOD) % MOD;\n        long long w1 = ((1LL << x) % MOD) * ((1LL << y) % MOD) % MOD - w0;\n        w1 = (w1 % MOD + MOD) % MOD;\n        long long P = (1LL << (j + k)) % MOD;\n        (w0 *= P) %= MOD;\n        (w1 *= P) %= MOD;\n        add(f[i - 1][j + 1][k][x], f[i][j][k][x] * w0);\n        add(f[i - 1][j][k + 1][x], f[i][j][k][x] * w1);\n      }\n      if (col == 1) {\n        long long w0 = ((1LL << j) % MOD) * ((1LL << k) / 2 % MOD) % MOD;\n        long long w1 = ((1LL << j) % MOD) * ((1LL << k) % MOD) % MOD - w0;\n        w1 = (w1 % MOD + MOD) % MOD;\n        long long P = (1LL << (x + y)) % MOD;\n        (w0 *= P) %= MOD;\n        (w1 *= P) %= MOD;\n        add(f[i - 1][j][k][x + 1], f[i][j][k][x] * w0);\n        add(f[i - 1][j][k][x], f[i][j][k][x] * w1);\n      }\n    }\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &p);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &c[i]);\n  }\n  f[n + 1][0][0][0] = 1;\n  for (int i = n + 1; i >= 1; i--) {\n    int tot = n - i + 1;\n    for (int j = 0; j <= tot; j++) {\n      for (int k = 0; k + j <= tot; k++) {\n        for (int x = 0; k + j + x <= tot; x++) {\n          upd(i, j, k, x);\n        }\n      }\n    }\n  }\n  long long ans = 0;\n  for (int j = 0; j <= n; j++)\n    for (int k = 0; k + j <= n; k++)\n      for (int x = 0; j + k + x <= n; x++) {\n        int y = n - (j + k + x);\n        if ((k + y) % 2 == p) add(ans, f[1][j][k][x]);\n      }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 55, MOD = 1e9 + 7;\nint n, p, c[MAXN], ans;\nint f[MAXN][MAXN][MAXN][MAXN];\nint pw[MAXN];\ninline int read() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (!isdigit(ch)) (ch == '-') && (f = -f), ch = getchar();\n  while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();\n  return x * f;\n}\ninline int explus(const int &a, const int &b) {\n  return a + b >= MOD ? a + b - MOD : a + b;\n}\ninline void Explus(int &a, const int &b) {\n  a = a + b >= MOD ? a + b - MOD : a + b;\n}\nint main() {\n  n = read();\n  p = read();\n  f[0][0][0][0] = 1;\n  pw[0] = 1;\n  for (int i = 1; i <= n; ++i) c[i] = read(), pw[i] = 2ll * pw[i - 1] % MOD;\n  for (int i = 1; i <= n; ++i)\n    for (int ob = 0; ob <= i; ++ob)\n      for (int ow = 0; ob + ow <= i; ++ow)\n        for (int eb = 0; eb + ob + ow <= i; ++eb) {\n          int ew = i - ob - ow - eb;\n          if (ob + eb && c[i] != 1) {\n            int res = 0;\n            if (ob) {\n              if (ow)\n                Explus(res, 1ll * f[i - 1][ob - 1][ow][eb] * pw[ow - 1] % MOD);\n              else\n                Explus(res, f[i - 1][ob - 1][ow][eb]);\n            }\n            if (eb && ow)\n              Explus(res, 1ll * f[i - 1][ob][ow][eb - 1] * pw[ow - 1] % MOD);\n            Explus(f[i][ob][ow][eb], 1ll * res * pw[ob + eb + ew - 1] % MOD);\n          }\n          if (ow + ew && c[i] != 0) {\n            int res = 0;\n            if (ow) {\n              if (ob)\n                Explus(res, 1ll * f[i - 1][ob][ow - 1][eb] * pw[ob - 1] % MOD);\n              else\n                Explus(res, f[i - 1][ob][ow - 1][eb]);\n            }\n            if (ob && ew)\n              Explus(res, 1ll * f[i - 1][ob][ow][eb] * pw[ob - 1] % MOD);\n            Explus(f[i][ob][ow][eb], 1ll * res * pw[ow + eb + ew - 1] % MOD);\n          }\n          if (i == n && ((ow + ob) % 2 == p)) Explus(ans, f[i][ob][ow][eb]);\n        }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nconst int N = 1e6 + 10;\nint n, type;\nint a[N], bit[N], f[N][2][2][2];\ntemplate <typename T>\ninline void chkmax(T &x, T y) {\n  x = max(x, y);\n}\ntemplate <typename T>\ninline void chkmin(T &x, T y) {\n  x = min(x, y);\n}\ntemplate <typename T>\ninline void read(T &x) {\n  T f = 1;\n  x = 0;\n  char c = getchar();\n  for (; !isdigit(c); c = getchar())\n    if (c == '-') f = -f;\n  for (; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + c - '0';\n  x *= f;\n}\ninline void add(int &x, int y) {\n  x += y;\n  while (x >= mod) x -= mod;\n}\nint main() {\n  read(n);\n  read(type);\n  for (int i = 1; i <= n; ++i) read(a[i]);\n  bit[0] = 1;\n  for (int i = 1; i <= n; ++i) bit[i] = 1LL * bit[i - 1] * 2 % mod;\n  f[0][0][0][0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    for (int tp = 0; tp <= 1; ++tp) {\n      for (int ob = 0; ob <= 1; ++ob) {\n        for (int ow = 0; ow <= 1; ++ow) {\n          if (a[i] != 0) {\n            if (ob) {\n              add(f[i][tp][ob][ow],\n                  1LL * f[i - 1][tp][ob][ow] * bit[i - 2] % mod);\n              add(f[i][tp ^ 1][ob][ow | 1],\n                  1LL * f[i - 1][tp][ob][ow] * bit[i - 2] % mod);\n            } else\n              add(f[i][tp ^ 1][ob][ow | 1],\n                  1LL * f[i - 1][tp][ob][ow] * bit[i - 1] % mod);\n          }\n          if (a[i] != 1) {\n            if (ow) {\n              add(f[i][tp][ob][ow],\n                  1LL * f[i - 1][tp][ob][ow] * bit[i - 2] % mod);\n              add(f[i][tp ^ 1][ob | 1][ow],\n                  1LL * bit[i - 2] * f[i - 1][tp][ob][ow] % mod);\n            } else\n              add(f[i][tp ^ 1][ob | 1][ow],\n                  1LL * f[i - 1][tp][ob][ow] * bit[i - 1] % mod);\n          }\n        }\n      }\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i <= 1; ++i)\n    for (int j = 0; j <= 1; ++j) add(ans, f[n][type][i][j]);\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 55;\nlong long read() {\n  long long x = 0, tmp = 1;\n  char ch = getchar();\n  while (!isdigit(ch)) {\n    if (ch == '-') tmp = -1;\n    ch = getchar();\n  }\n  while (isdigit(ch)) {\n    x = (x << 3) + (x << 1) + (ch ^ 48);\n    ch = getchar();\n  }\n  return tmp * x;\n}\nconst long long mod = 1e9 + 7;\nlong long n, p, a[N], pow2[N];\nlong long f[N][2][2][2];\nsigned main() {\n  n = read();\n  p = read();\n  for (long long i = 1; i <= n; i++) a[i] = read();\n  pow2[0] = 1;\n  for (long long i = 1; i <= n; i++)\n    pow2[i] = (pow2[i - 1] + pow2[i - 1]) % mod;\n  f[0][0][0][0] = 1;\n  for (long long i = 1; i <= n; i++) {\n    for (long long black = 0; black < 2; black++)\n      for (long long white = 0; white < 2; white++)\n        for (long long par = 0; par < 2; par++) {\n          long long lans = f[i - 1][black][white][par];\n          if (!lans) continue;\n          if (a[i] != 0) {\n            if (!black)\n              (f[i][0][1][par ^ 1] += lans * pow2[i - 1] % mod) %= mod;\n            else {\n              (f[i][1][1][par ^ 1] += lans * pow2[i - 2] % mod) %= mod;\n              (f[i][1][white][par] += lans * pow2[i - 2] % mod) %= mod;\n            }\n          }\n          if (a[i] != 1) {\n            if (!white)\n              (f[i][1][0][par ^ 1] += lans * pow2[i - 1] % mod) %= mod;\n            else {\n              (f[i][1][1][par ^ 1] += lans * pow2[i - 2] % mod) %= mod;\n              (f[i][black][1][par] += lans * pow2[i - 2] % mod) %= mod;\n            }\n          }\n        }\n  }\n  long long res = 0;\n  for (long long black = 0; black < 2; black++)\n    for (long long white = 0; white < 2; white++)\n      res = (res + f[n][black][white][p]) % mod;\n  printf(\"%d\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.Scanner;\nimport java.lang.StringBuilder;\nimport java.util.Arrays;\nimport java.util.Stack;\nimport java.util.TreeMap;\npublic class Test10   {  \n    //suppose: a[0] black\n    //maintain: array a[i][j]: number of coloring w/ pointer on i with j black vertices to right:\n    //if a[i] black: a[i][j] = a[i - 1][j + 1];\n    //if a[i] white:a[i][j] = total possible / 4(2 if j = 0) + 2 ^ (i + j - 1) * a[i - 1][j];\n    //total possible = 2 ^ (undecided + (i + j + 1) * (i + j) / 2)\n    //if a[i] ambiguous: a[i][j] = sum of two\n    //maintain on i\n    public static void main(String[] Args)   {\n        long huge = 1000000007;\n        long[][] a = new long[51][51];\n        long ans = 0;\n        long[] pw2 = new long[5001];\n        pw2[0] = 1;\n        for (int i = 0; i <= 4999; i++)\n            pw2[i + 1] = (pw2[i] * 2)%huge;\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n                int p = sc.nextInt();\n        int[] cl = new int[n];\n        for (int i = 0; i < n; i++) cl[i] = sc.nextInt();\n\n        if (cl[0] == -1 || cl[0] == 0)   {\n            for (int i = 0; i <= 50; i++)  {\n                if (i % 2 != p) a[0][i] = pw2[(i *(i + 1))/2];\n                else a[0][i] = 0;\n            }    \n            int undecided = 0;\n            for (int i = 1; i <= n - 1; i++)  {\n                for (int j = 0; j <= n - 1 - i; j++)   {\n                    a[i][j] = 0;\n                    if (cl[i] == 0 || cl[i] == -1)   {\n                        a[i][j] += a[i - 1][j + 1];\n                    }   \n                    if (cl[i] == 1 || cl[i] == -1)   {\n                        if (j == 0) a[i][j] += pw2[undecided + ((i + j + 1) * (i + j)) / 2 - 1];\n                        else { \n                            a[i][j] += pw2[undecided + ((i + j + 1) * (i + j)) / 2 - 2];\n                            a[i][j] += pw2[i + j - 1] * a[i - 1][j];\n                        }\n                    }    \n                    a[i][j] = a[i][j] % huge;\n                }    \n                if (cl[i] == -1) undecided++;\n            }\n            ans += a[n - 1][0];\n        }    \n        a = new long[51][51];\n        if (cl[0] == -1 || cl[0] == 1)   {\n            for (int i = 0; i <= 50; i++)  {\n                if (i % 2 != p) a[0][i] = pw2[(i *(i + 1))/2];\n                else a[0][i] = 0;\n            }    \n            int undecided = 0;\n            for (int i = 1; i <= n - 1; i++)  {\n                for (int j = 0; j <= n - 1 - i; j++)   {\n                    a[i][j] = 0;\n                    if (cl[i] == 1 || cl[i] == -1)   {\n                        a[i][j] += a[i - 1][j + 1];\n                    }   \n                    if (cl[i] == 0 || cl[i] == -1)   {\n                        if (j == 0)  {\n                            a[i][j] += pw2[undecided + ((i + j + 1) * (i + j)) / 2 - 1];\n                        }    \n                        else  { \n                            a[i][j] += pw2[undecided + ((i + j + 1) * (i + j)) / 2 - 2];\n                            a[i][j] += pw2[i + j - 1] * a[i - 1][j];\n                        }\n                    }    \n                    a[i][j] = a[i][j] % huge;\n                }    \n                if (cl[i] == -1) undecided++;\n            }\n            ans += a[n - 1][0];\n        }    \n        System.out.println(ans % huge);\n   }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid getint(int &v) {\n  char ch, fu = 0;\n  for (ch = '*'; (ch < '0' || ch > '9') && ch != '-'; ch = getchar())\n    ;\n  if (ch == '-') fu = 1, ch = getchar();\n  for (v = 0; ch >= '0' && ch <= '9'; ch = getchar()) v = v * 10 + ch - '0';\n  if (fu) v = -v;\n}\nconst int MO = 1e9 + 7;\nint n, p, c[500010];\nlong long f[500010][2][2][2], g[500010], ans, fac[500010], p2[500010],\n    inv[500010];\nlong long C(int x, int y) { return fac[x] * inv[y] % MO * inv[x - y] % MO; }\nint main() {\n  cin >> n >> p;\n  for (int i = 1; i <= n; ++i) getint(c[i]);\n  p2[0] = 1;\n  for (int i = 1; i <= n; ++i) p2[i] = p2[i - 1] * 2 % MO;\n  if (c[1] != 1) f[1][1][0][1] = 1;\n  if (c[1] != 0) f[1][0][1][1] = 1;\n  for (int i = 1; i <= n - 1; ++i)\n    for (int j = 0; j <= 1; ++j)\n      for (int k = 0; k <= 1; ++k)\n        for (int l = 0; l <= 1; ++l) {\n          long long t = f[i][j][k][l];\n          if (!t) continue;\n          if (c[i + 1] != 1) {\n            if (k) {\n              (f[i + 1][j][k][l] += t * p2[i - 1]) %= MO;\n              (f[i + 1][j | 1][k][l ^ 1] += t * p2[i - 1]) %= MO;\n            } else {\n              (f[i + 1][j | 1][k][l ^ 1] += t * p2[i]) %= MO;\n            }\n          }\n          if (c[i + 1] != 0) {\n            if (j) {\n              (f[i + 1][j][k][l] += t * p2[i - 1]) %= MO;\n              (f[i + 1][j][k | 1][l ^ 1] += t * p2[i - 1]) %= MO;\n            } else {\n              (f[i + 1][j][k | 1][l ^ 1] += t * p2[i]) %= MO;\n            }\n          }\n        }\n  for (int j = 0; j <= 1; ++j)\n    for (int k = 0; k <= 1; ++k) (ans += f[n][j][k][p]) %= MO;\n  ans = (ans % MO + MO) % MO;\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 55;\nconst int mod = 1E9 + 7;\nlong long Pow(long long v, int p) {\n  long long ret = 1;\n  while (p) {\n    if (p & 1) ret = (ret * v) % mod;\n    p >>= 1;\n    v = (v * v) % mod;\n  }\n  return ret;\n}\nlong long Div(long long a, long long b) { return (a * Pow(b, mod - 2)) % mod; }\nlong long Pc[maxn];\nlong long C(int r, int k) { return Div(Pc[r], (Pc[k] * Pc[r - k]) % mod); }\nlong long T[maxn][2];\nlong long dp[maxn][maxn][maxn][maxn];\nint N, P, D[maxn];\nint main() {\n  Pc[0] = 1;\n  for (int i = 1; i < maxn; ++i) Pc[i] = (Pc[i - 1] * i) % mod;\n  for (int i = 0; i < maxn; ++i)\n    for (int d = 0; d < 2; ++d) {\n      for (int k = 0; 2 * k + d <= i; ++k) {\n        T[i][d] += C(i, 2 * k + d);\n      }\n    }\n  scanf(\"%d%d\", &N, &P);\n  for (int i = 1; i <= N; ++i) scanf(\"%d\", D + i);\n  dp[0][0][0][0] = 1;\n  for (int i = 0; i <= N; ++i) {\n    for (int ew = 0; ew <= i; ++ew)\n      for (int ow = 0; ow + ew <= i; ++ow)\n        for (int eb = 0; ew + ow + eb <= i; ++eb) {\n          int ob = i - ew - ow - eb, u = i + 1;\n          if (D[u] == 1 || D[u] == -1) {\n            long long t = Pow(2, ew + ow + eb), o = (T[ob][0] * t) % mod,\n                      e = (T[ob][1] * t) % mod;\n            dp[u][ew + 1][ow][eb] += (e * dp[i][ew][ow][eb]) % mod;\n            if (dp[u][ew + 1][ow][eb] >= mod) dp[u][ew + 1][ow][eb] -= mod;\n            dp[u][ew][ow + 1][eb] += (o * dp[i][ew][ow][eb]) % mod;\n            if (dp[u][ew][ow + 1][eb] >= mod) dp[u][ew][ow + 1][eb] -= mod;\n          }\n          if (D[u] == 0 || D[u] == -1) {\n            long long t = Pow(2, ew + eb + ob), o = (T[ow][0] * t) % mod,\n                      e = (T[ow][1] * t) % mod;\n            dp[u][ew][ow][eb + 1] += (e * dp[i][ew][ow][eb]) % mod;\n            if (dp[u][ew][ow][eb + 1] >= mod) dp[u][ew][ow][eb + 1] -= mod;\n            dp[u][ew][ow][eb] += (o * dp[i][ew][ow][eb]) % mod;\n            if (dp[u][ew][ow][eb] >= mod) dp[u][ew][ow][eb] -= mod;\n          }\n        }\n  }\n  long long ans = 0;\n  for (int ew = 0; ew <= N; ++ew)\n    for (int ow = 0; ow + ew <= N; ++ow)\n      for (int eb = 0; ew + ow + eb <= N; ++eb) {\n        int ob = N - ew - ow - eb;\n        if ((ow + ob) % 2 == P) {\n          ans += dp[N][ew][ow][eb];\n          if (ans >= mod) ans -= mod;\n        }\n      }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, p, nums[51];\nlong long dp[51][51][51][51][2], dp1[51][2], pw2[51];\nlong long quant(int lft, int par) {\n  if (dp1[lft][par] != -1) return dp1[lft][par];\n  if (lft == 0) return par == 0;\n  long long ret = quant(lft - 1, par);\n  ret += quant(lft - 1, par ^ 1);\n  return dp1[lft][par] = ret % 1000000007;\n}\nlong long solve(int ind, int cnt0, int cnt1, int p1, int par) {\n  if (dp[ind][cnt0][cnt1][p1][par] != -1) return dp[ind][cnt0][cnt1][p1][par];\n  if (ind == n) return par == p;\n  long long ret = 0;\n  vector<int> vals;\n  if (nums[ind] != -1)\n    vals.push_back(nums[ind]);\n  else {\n    vals.push_back(0);\n    vals.push_back(1);\n  }\n  for (int v : vals) {\n    if (v == 0) {\n      long long lft = pw2[p1 - cnt1];\n      ret += (((quant(p1 - cnt1, 0) * pw2[ind - p1 + cnt1]) % 1000000007) *\n              solve(ind + 1, cnt0, cnt1, p1, par)) %\n             1000000007;\n      lft -= quant(p1 - cnt1, 0);\n      ret += (((lft * pw2[ind - p1 + cnt1]) % 1000000007) *\n              solve(ind + 1, cnt0 + 1, cnt1, p1, par ^ 1)) %\n             1000000007;\n    } else {\n      long long lft = pw2[ind - p1 - cnt0];\n      ret += (((quant(ind - p1 - cnt0, 0) * pw2[p1 + cnt0]) % 1000000007) *\n              solve(ind + 1, cnt0, cnt1, p1 + 1, par)) %\n             1000000007;\n      lft -= quant(ind - p1 - cnt0, 0);\n      ret += (((lft * pw2[p1 + cnt0]) % 1000000007) *\n              solve(ind + 1, cnt0, cnt1 + 1, p1 + 1, par ^ 1)) %\n             1000000007;\n    }\n  }\n  return dp[ind][cnt0][cnt1][p1][par] = ret % 1000000007;\n}\nint main() {\n  scanf(\"%d %d\", &n, &p);\n  for (int i = 0; i < n; i++) scanf(\"%d\", &nums[i]);\n  pw2[0] = 1;\n  for (int i = 1; i < 51; i++) pw2[i] = (pw2[i - 1] * 2) % 1000000007;\n  memset(dp, -1, sizeof dp);\n  memset(dp1, -1, sizeof dp1);\n  printf(\"%lld\\n\", solve(0, 0, 0, 0, n & 1));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long MOD = 1000000007;\nvector<long long> fact;\nlong long pw(long long a, long long b) {\n  if (b == 0) return 1;\n  if (b == 1) return a % MOD;\n  if (b % 2) {\n    return (pw(a, b - 1) * a) % MOD;\n  }\n  long long rs = pw(a, b / 2);\n  return (rs * rs) % MOD;\n}\nlong long C(long long n, long long k) {\n  long long x = fact[n] % MOD;\n  long long y = (fact[k] * fact[n - k]) % MOD;\n  return (x * pw(y, MOD - 2)) % MOD;\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  long long n, p;\n  fact.push_back(1);\n  for (long long i = 0; i < 1000; i++)\n    fact.push_back(((i + 1) * fact.back()) % MOD);\n  long long ways[100][2];\n  for (long long i = 0; i < 100; i++) {\n    long long A = 0, B = 0;\n    for (long long j = 0; j <= i; j++) {\n      if (j % 2)\n        B += C(i, j);\n      else\n        A += C(i, j);\n    }\n    A %= MOD, B %= MOD;\n    ways[i][0] = A, ways[i][1] = B;\n  }\n  cin >> n >> p;\n  vector<long long> val(n);\n  for (long long i = 0; i < n; i++) cin >> val[i];\n  long long dp[51][51][51];\n  for (long long i = 0; i <= 50; i++)\n    for (long long j = 0; j <= 50; j++)\n      for (long long k = 0; k <= 50; k++) dp[i][j][k] = 0;\n  dp[0][0][0] = 1;\n  for (long long i = n - 1; i >= 0; i--) {\n    long long dp2[51][51][51];\n    for (long long e = 0; e <= 50; e++)\n      for (long long j = 0; j <= 50; j++)\n        for (long long k = 0; k <= 50; k++) {\n          dp2[e][j][k] = 0;\n          if (e + j + k > n - i) continue;\n          long long rest = n - i - e - j - k;\n          if (val[i] == 0 || val[i] == -1) {\n            if (e > 0) {\n              long long per = (ways[rest][0] + ways[rest][1]) % MOD;\n              per *= ways[k][0];\n              per %= MOD;\n              per *= (ways[e + j - 1][0] + ways[e + j - 1][1]);\n              per %= MOD;\n              dp2[e][j][k] += dp[e - 1][j][k] * per;\n              dp2[e][j][k] %= MOD;\n            }\n            if (j > 0) {\n              long long per = (ways[rest][0] + ways[rest][1]) % MOD;\n              per *= ways[k][1];\n              per %= MOD;\n              per *= (ways[e + j - 1][0] + ways[e + j - 1][1]);\n              per %= MOD;\n              dp2[e][j][k] += dp[e][j - 1][k] * per;\n              dp2[e][j][k] %= MOD;\n            }\n          }\n          if (val[i] == 1 || val[i] == -1) {\n            if (k > 0) {\n              long long per = (ways[j][0] + ways[j][1]) % MOD;\n              per *= ways[e][0];\n              per %= MOD;\n              per *= (ways[k + rest - 1][0] + ways[k + rest - 1][1]);\n              per %= MOD;\n              dp2[e][j][k] += dp[e][j][k - 1] * per;\n              dp2[e][j][k] %= MOD;\n            }\n            if (rest > 0) {\n              long long per = (ways[j][0] + ways[j][1]) % MOD;\n              per *= ways[e][1];\n              per %= MOD;\n              per *= (ways[k + rest - 1][0] + ways[k + rest - 1][1]);\n              per %= MOD;\n              dp2[e][j][k] += dp[e][j][k] * per;\n              dp2[e][j][k] %= MOD;\n            }\n          }\n        }\n    for (long long e = 0; e <= 50; e++)\n      for (long long j = 0; j <= 50; j++)\n        for (long long k = 0; k <= 50; k++) dp[e][j][k] = dp2[e][j][k];\n  }\n  long long ans = 0;\n  for (long long i = 0; i <= 50; i++)\n    for (long long j = 0; j <= 50; j++)\n      for (long long k = 0; k <= 50; k++) {\n        long long nc = i + k;\n        if (nc % 2 == p) ans += dp[i][j][k];\n      }\n  cout << ans % MOD;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nstruct MI {\n private:\n  char bb[4096];\n  FILE* f;\n  char *bs, *be;\n  char e;\n  bool o, l;\n\n public:\n  MI() : f(stdin) {}\n  MI(FILE* f) : f(f), bs(0), be(0) {}\n  inline operator bool() { return !l; }\n  inline char get() {\n    if (o) {\n      o = 0;\n      return e;\n    }\n    if (bs == be) be = (bs = bb) + fread(bb, 1, sizeof(bb), f);\n    if (bs == be) {\n      l = 1;\n      return -1;\n    };\n    return *bs++;\n  }\n  inline void unget(char c) {\n    o = 1;\n    e = c;\n  }\n  template <typename T>\n  inline T read() {\n    T r;\n    *this > r;\n    return r;\n  }\n  template <typename T>\n  inline MI& operator>(T&);\n};\ntemplate <typename T>\nstruct Q {\n  const static bool U = T(-1) >= T(0);\n  inline void operator()(MI& t, T& r) const {\n    r = 0;\n    char c;\n    bool y = 0;\n    if (U)\n      for (;;) {\n        c = t.get();\n        if (c == -1) goto E;\n        if (isdigit(c)) break;\n      }\n    else\n      for (;;) {\n        c = t.get();\n        if (c == -1) goto E;\n        if (c == '-') {\n          c = t.get();\n          if (isdigit(c)) {\n            y = 1;\n            break;\n          };\n        } else if (isdigit(c))\n          break;\n        ;\n      };\n    for (;;) {\n      if (c == -1) goto E;\n      if (isdigit(c))\n        r = r * 10 + (c ^ 48);\n      else\n        break;\n      c = t.get();\n    }\n    t.unget(c);\n  E:;\n    if (y) r = -r;\n  }\n};\ntemplate <>\nstruct Q<char> {\n  inline void operator()(MI& t, char& r) {\n    int c;\n    for (;;) {\n      c = t.get();\n      if (c == -1) {\n        r = -1;\n        return;\n      };\n      if (!isspace(c)) {\n        r = c;\n        return;\n      };\n    }\n  }\n};\ntemplate <typename T>\ninline MI& MI::operator>(T& t) {\n  Q<T>()(*this, t);\n  return *this;\n}\ntemplate <typename T>\nstd::ostream& operator<(std::ostream& out, const T& t) {\n  return out << t;\n}\nusing std::cout;\nMI cin;\nconst int nmax = 55;\nconst int mod = 1000000007;\nconst int inv2 = 500000004;\nint n, p, a[nmax], ps[nmax], f[nmax][2][2][2];\ninline void upd(int& x) {\n  if (x >= mod) x -= mod;\n}\ninline int pro(int x) { return (x >= mod) ? x - mod : x; }\nint main() {\n  cin > n > p;\n  for (int i = ps[0] = 1; i <= n; ++i) {\n    cin > a[i];\n    ps[i] = pro(ps[i - 1] + ps[i - 1]);\n  }\n  f[0][0][0][0] = 1;\n  for (int i = 1; i <= n; ++i)\n    for (int j = 0; j < 2; ++j)\n      for (int black = 0; black < 2; ++black)\n        for (int white = 0; white < 2; ++white) {\n          const int pre = (long long)f[i - 1][j][black][white] *\n                          (i == 1 ? inv2 : ps[i - 2]) % mod;\n          if (a[i] != 1) {\n            if (white) {\n              upd(f[i][j][black][white] += pre);\n              upd(f[i][j ^ 1][black | 1][white] += pre);\n            } else\n              upd(f[i][j ^ 1][black | 1][white] += pro(pre + pre));\n          }\n          if (a[i] != 0) {\n            if (black) {\n              upd(f[i][j][black][white] += pre);\n              upd(f[i][j ^ 1][black][white | 1] += pre);\n            } else\n              upd(f[i][j ^ 1][black][white | 1] += pro(pre + pre));\n          }\n        }\n  int ans = 0;\n  for (int i = 0; i < 2; ++i)\n    for (int j = 0; j < 2; ++j) upd(ans += f[n][p][i][j]);\n  cout < ans < ('\\n');\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline void Add(int &x, int y) {\n  x = x + y >= 1000000007 ? x + y - 1000000007 : x + y;\n}\nint n, cur, P1, P2, p, f[2][2][2][2];\nint main() {\n  scanf(\"%d%d\", &n, &p);\n  f[0][0][0][0] = 1;\n  P1 = 1;\n  P2 = 0;\n  cur = 0;\n  for (int i = 1; i <= n; i++) {\n    memset(f[cur ^ 1], 0, sizeof(f[cur ^ 1]));\n    int x;\n    scanf(\"%d\", &x);\n    for (int j = 0; j <= 1; j++)\n      for (int k = 0; k <= 1; k++)\n        for (int l = 0; l <= 1; l++) {\n          if (x != 1) {\n            if (k) {\n              Add(f[cur ^ 1][j ^ 1][k][l | 1],\n                  1ll * f[cur][j][k][l] * P2 % 1000000007);\n              Add(f[cur ^ 1][j][k][l], 1ll * f[cur][j][k][l] * P2 % 1000000007);\n            } else\n              Add(f[cur ^ 1][j ^ 1][k][l | 1],\n                  1ll * f[cur][j][k][l] * P1 % 1000000007);\n          }\n          if (x != 0) {\n            if (l) {\n              Add(f[cur ^ 1][j ^ 1][k | 1][l],\n                  1ll * f[cur][j][k][l] * P2 % 1000000007);\n              Add(f[cur ^ 1][j][k][l], 1ll * f[cur][j][k][l] * P2 % 1000000007);\n            } else\n              Add(f[cur ^ 1][j ^ 1][k | 1][l],\n                  1ll * f[cur][j][k][l] * P1 % 1000000007);\n          }\n        }\n    P2 = P1;\n    P1 = 2ll * P1 % 1000000007;\n    cur ^= 1;\n  }\n  int ans = 0;\n  for (int i = 0; i <= 1; i++)\n    for (int j = 0; j <= 1; j++) Add(ans, f[cur][p][i][j]);\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nconst long long maxn = 52, MOD = (1000000007);\nlong long dp[maxn][maxn][maxn][maxn], C[maxn], tav[400];\nlong long p, ans, n;\nlong long sum(long long a, long long b) {\n  a = (a + b) % MOD;\n  return a;\n}\nlong long mul(long long a, long long b) {\n  a = (a * b) % MOD;\n  return a;\n}\nint32_t main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  tav[0] = 1;\n  for (long long i = 1; i < 300; i++) {\n    tav[i] = (tav[i - 1] * 2ll) % MOD;\n  }\n  cin >> n >> p;\n  for (long long i = 0; i < n; i++) {\n    cin >> C[i];\n  }\n  dp[0][0][0][0] = 1;\n  for (long long i = 1; i <= n; i++) {\n    for (long long fb = 0; fb < n; fb++) {\n      for (long long zb = 0; zb < n; zb++) {\n        for (long long fw = 0; fw < n; fw++) {\n          long long zw = i - 1 - (fb + zb + fw);\n          if (zw < 0) continue;\n          if (C[i - 1] == -1 || C[i - 1] == 1) {\n            long long zar = tav[fb + zb + zw];\n            if (fw != 0) zar = mul(zar, tav[fw - 1]);\n            if (10 != 1)\n              dp[i][fb + 1][zb][fw] =\n                  sum(dp[i][fb + 1][zb][fw], mul(dp[i - 1][fb][zb][fw], zar));\n            if (fw != 0)\n              dp[i][fb][zb + 1][fw] =\n                  sum(dp[i][fb][zb + 1][fw], mul(dp[i - 1][fb][zb][fw], zar));\n          }\n          if (C[i - 1] == -1 || C[i - 1] == 0) {\n            long long zar = tav[fw + zw + zb];\n            if (fb != 0) zar = mul(zar, tav[fb - 1]);\n            if (10 != 1)\n              dp[i][fb][zb][fw + 1] =\n                  sum(dp[i][fb][zb][fw + 1], mul(dp[i - 1][fb][zb][fw], zar));\n            if (fb != 0)\n              dp[i][fb][zb][fw + 0] =\n                  sum(dp[i][fb][zb][fw + 0], mul(dp[i - 1][fb][zb][fw], zar));\n          }\n        }\n      }\n    }\n  }\n  for (long long i = 0; i <= n; i++)\n    for (long long j = 0; j <= n; j++)\n      for (long long k = 0; k <= n; k++) {\n        if (i + j + k > n) continue;\n        if ((i + k) % 2 != p) continue;\n        ans = sum(ans, dp[n][i][j][k]);\n      }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n/**\n * @author Don Li\n */\npublic class KuroAndTopologicalParity2 {\n    \n    int MOD = (int) 1e9 + 7;\n    int N = 55;\n    \n    long[] p2 = new long[N];\n    long[][] c = new long[N][N];\n    long[][] cs = new long[N][2];\n    \n    long[][][] dp = new long[N][N][N];\n    \n    {\n        p2[0] = 1;\n        for (int i = 1; i < N; i++) p2[i] = p2[i - 1] * 2 % MOD;\n        \n        for (int i = 0; i < N; i++) {\n            c[i][0] = 1;\n            for (int j = 1; j <= i; j++) c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;\n        }\n        \n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j <= i; j++) {\n                cs[i][j & 1] = (cs[i][j & 1] + c[i][j]) % MOD;\n            }\n        }\n    }\n    \n    void solve() {\n        int n = in.nextInt(), p = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = in.nextInt();\n        \n        long ans = 0;\n        dp[0][0][0] = 1;\n        for (int i = 0; i < n; i++) {\n            for (int ob = 0; ob <= i + 1; ob++) {\n                for (int ow = 0; ob + ow <= i + 1; ow++) {\n                    if (a[i] != 0 && i - ob >= 0) dp[i + 1][ob][ow] += dp[i][ob][ow] * p2[i - ob]%MOD * cs[ob][1]%MOD ;\n                    if (a[i] != 0 && ow - 1 >= 0) dp[i + 1][ob][ow] += dp[i][ob][ow - 1] * p2[i - ob]%MOD  * cs[ob][0]%MOD ;\n                    if (a[i] != 1 && i - ow >= 0) dp[i + 1][ob][ow] += dp[i][ob][ow] * p2[i - ow]%MOD  * cs[ow][1]%MOD ;\n                    if (a[i] != 1 && ob - 1 >= 0) dp[i + 1][ob][ow] += dp[i][ob - 1][ow] * p2[i - ow]%MOD  * cs[ow][0]%MOD ;\n                    dp[i + 1][ob][ow] %= MOD;\n                    if (i + 1 == n && ((ob + ow) & 1) == p) ans = (ans + dp[i + 1][ob][ow])%MOD;\n                }\n            }\n        }\n        out.println(ans);\n    }\n    \n    public static void main(String[] args) {\n        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        new KuroAndTopologicalParity2().solve();\n        out.close();\n    }\n    \n    static FastScanner in;\n    static PrintWriter out;\n    \n    static class FastScanner {\n        BufferedReader in;\n        StringTokenizer st;\n        \n        public FastScanner(BufferedReader in) {\n            this.in = in;\n        }\n        \n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        \n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n        \n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 55;\nconst int M = 1e9 + 7;\nlong long ans = 0, odd[maxn], even[maxn], c[maxn][maxn], _pow[maxn];\nlong long dp[maxn][maxn][maxn][maxn];\nvoid init() {\n  _pow[0] = 1;\n  for (int i = 0; i < maxn; ++i) {\n    c[i][0] = c[i][i] = 1;\n    if (i) _pow[i] = (_pow[i - 1] * 2) % M;\n  }\n  for (int i = 1; i < maxn; ++i)\n    for (int j = 0; j < i; ++j) {\n      c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % M;\n    }\n  for (int i = 0; i < maxn; ++i) {\n    for (int j = 0; j <= i; j += 2) {\n      even[i] = (even[i] + c[i][j]) % M;\n    }\n    for (int j = 1; j <= i; j += 2) {\n      odd[i] = (odd[i] + c[i][j]) % M;\n    }\n  }\n}\nvoid solve(int ow, int ew, int ob, int eb, int n) {\n  if (n != 0 && ow != 0)\n    dp[ow][ew][ob][eb] =\n        (dp[ow][ew][ob][eb] +\n         dp[ow - 1][ew][ob][eb] * _pow[ow + ew + eb - 1] % M * even[ob]) %\n        M;\n  if (n != 0 && ew != 0)\n    dp[ow][ew][ob][eb] =\n        (dp[ow][ew][ob][eb] +\n         dp[ow][ew - 1][ob][eb] * _pow[ow + ew + eb - 1] % M * odd[ob]) %\n        M;\n  if (n != 1 && ob != 0)\n    dp[ow][ew][ob][eb] =\n        (dp[ow][ew][ob][eb] +\n         dp[ow][ew][ob - 1][eb] * _pow[ob + eb + ew - 1] % M * even[ow]) %\n        M;\n  if (n != 1 && eb != 0)\n    dp[ow][ew][ob][eb] =\n        (dp[ow][ew][ob][eb] +\n         dp[ow][ew][ob][eb - 1] * _pow[ob + eb + ew - 1] % M * odd[ow]) %\n        M;\n}\nint main() {\n  init();\n  int n, p, a[maxn];\n  dp[0][0][0][0] = 1;\n  cin >> n >> p;\n  for (int i = 1; i <= n; ++i) cin >> a[i];\n  for (int i = 1; i <= n; ++i)\n    for (int ow = 0; ow <= i; ++ow)\n      for (int ew = 0; ew + ow <= i; ++ew)\n        for (int ob = 0; ob + ew + ow <= i; ++ob) {\n          int eb = i - ow - ew - ob;\n          solve(ow, ew, ob, eb, a[i]);\n          if (i == n && ((ob + ow) & 1) == p)\n            ans = (ans + dp[ow][ew][ob][eb]) % M;\n        }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int inf = 1e9 + 7;\nusing namespace std;\nlong long read() {\n  long long x = 0, f = 1;\n  char ch = getchar();\n  while (!isdigit(ch)) {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();\n  return f * x;\n}\nint n, _p, a[55];\nlong long p[55], d[55][2][2][2], ans;\nint main() {\n  n = read();\n  _p = read();\n  for (int i = 1; i <= n; i++) a[i] = read();\n  p[0] = 1;\n  for (int i = 1; i <= n; i++) p[i] = p[i - 1] * 2 % inf;\n  if (a[1]) d[1][1][1][0] = 1;\n  if (a[1] <= 0) d[1][1][0][1] = 1;\n  for (int i = 2; i <= n; i++)\n    for (int j = 0; j <= 1; j++)\n      for (int k = 0; k <= 1; k++)\n        for (int v = 0; v <= 1; v++)\n          if (d[i - 1][j][k][v]) {\n            if (a[i]) {\n              if (v) {\n                (d[i][j][k][v] += d[i - 1][j][k][v] * p[i - 2] % inf) %= inf;\n                (d[i][j ^ 1][1][v] += d[i - 1][j][k][v] * p[i - 2] % inf) %=\n                    inf;\n              } else {\n                (d[i][j ^ 1][1][v] += d[i - 1][j][k][v] * p[i - 1] % inf) %=\n                    inf;\n              }\n            }\n            if (a[i] <= 0) {\n              if (k) {\n                (d[i][j][k][v] += d[i - 1][j][k][v] * p[i - 2] % inf) %= inf;\n                (d[i][j ^ 1][k][1] += d[i - 1][j][k][v] * p[i - 2] % inf) %=\n                    inf;\n              } else {\n                (d[i][j ^ 1][k][1] += d[i - 1][j][k][v] * p[i - 1] % inf) %=\n                    inf;\n              }\n            }\n          }\n  for (int j = 0; j <= 1; j++)\n    for (int k = 0; k <= 1; k++) ans += d[n][_p][j][k];\n  ans %= inf;\n  return 0 * printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MAXN = 60;\nint n, P, A[MAXN];\nconst int mod = 1000000007;\nvoid reduce(int& x) { x += x >> 31 & mod; }\nint mul(int a, int b) { return (long long)a * b % mod; }\nint pow(int a, int b, int res = 1) {\n  for (; b; b >>= 1, a = mul(a, a))\n    if (b & 1) res = mul(res, a);\n  return res;\n}\nint dp[MAXN][MAXN][MAXN];\nint main() {\n  std::ios_base::sync_with_stdio(false), std::cin.tie(0);\n  std::cin >> n >> P;\n  for (int i = 1; i <= n; ++i) std::cin >> A[i];\n  dp[0][0][0] = 1;\n  for (int i = 1; i <= n; ++i)\n    for (int j = 0; j <= i; ++j)\n      for (int k = 0; k <= i; ++k)\n        if (dp[i - 1][j][k]) {\n          if (A[i] == 0 || A[i] == -1) {\n            int t = pow(2, i - 1 - (!!k), dp[i - 1][j][k]);\n            reduce(dp[i][j + 1][k] += t - mod);\n            if (k) reduce(dp[i][j][k] += t - mod);\n          }\n          if (A[i] == 1 || A[i] == -1) {\n            int t = pow(2, i - 1 - (!!j), dp[i - 1][j][k]);\n            reduce(dp[i][j][k + 1] += t - mod);\n            if (j) reduce(dp[i][j][k] += t - mod);\n          }\n        }\n  int ans = 0;\n  for (int i = 0; i <= n; ++i)\n    for (int j = 0; j <= n; ++j)\n      if ((i + j & 1) == P) reduce(ans += dp[n][i][j] - mod);\n  std::cout << ans << std::endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 55, MOD = 1E9 + 7;\nint n, p, c[N];\nlong long ans = 0, pw[N], fct[N], inv[N], od[N], ev[N], f[N][N][N][N];\nlong long power(int u, int p) {\n  if (p == 0) return 1;\n  long long ret = power(u, p >> 1);\n  (ret *= ret) %= MOD;\n  if (p & 1) (ret *= u) %= MOD;\n  return ret;\n}\nlong long C(int n, int k) { return fct[n] * inv[k] % MOD * inv[n - k] % MOD; }\nvoid init() {\n  f[0][0][0][0] = 1;\n  pw[0] = 1;\n  fct[0] = 1;\n  for (int i = 1; i < N; i++) {\n    pw[i] = pw[i - 1] * 2 % MOD;\n    fct[i] = fct[i - 1] * i % MOD;\n  }\n  inv[N - 1] = power(fct[N - 1], MOD - 2);\n  for (int i = N - 2; i >= 0; i--) inv[i] = inv[i + 1] * (i + 1) % MOD;\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j <= i; j += 2) (ev[i] += C(i, j)) %= MOD;\n    for (int j = 1; j <= i; j += 2) (od[i] += C(i, j)) %= MOD;\n  }\n}\nvoid find_ans(int ob, int eb, int ow, int ew, int col, long long &ret) {\n  if (col != 0 && ew != 0)\n    (ret +=\n     f[ob][eb][ow][ew - 1] * pw[ow + ew - 1 + eb] % MOD * od[ob] % MOD) %= MOD;\n  if (col != 0 && ow != 0)\n    (ret +=\n     f[ob][eb][ow - 1][ew] * pw[ow - 1 + ew + eb] % MOD * ev[ob] % MOD) %= MOD;\n  if (col != 1 && eb != 0)\n    (ret +=\n     f[ob][eb - 1][ow][ew] * pw[ob + eb - 1 + ew] % MOD * od[ow] % MOD) %= MOD;\n  if (col != 1 && ob != 0)\n    (ret +=\n     f[ob - 1][eb][ow][ew] * pw[ob - 1 + eb + ew] % MOD * ev[ow] % MOD) %= MOD;\n}\nint main() {\n  init();\n  scanf(\"%d%d\", &n, &p);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", c + i);\n  for (int i = 1; i <= n; i++)\n    for (int ob = 0; ob <= i; ob++)\n      for (int eb = 0; ob + eb <= i; eb++)\n        for (int ow = 0; ob + eb + ow <= i; ow++) {\n          int ew = i - ob - eb - ow;\n          find_ans(ob, eb, ow, ew, c[i], f[ob][eb][ow][ew]);\n          if (i == n && ((ob + ow) & 1) == p) (ans += f[ob][eb][ow][ew]) %= MOD;\n        }\n  printf(\"%lld\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 55, mod = 1e9 + 7;\nint col[N], f[N][N][2][2], power[N];\nint main() {\n  register int n, p, i, j, a, b, res, ans;\n  scanf(\"%d%d\", &n, &p);\n  for (i = 1; i <= n; ++i) scanf(\"%d\", &col[i]);\n  power[0] = 1;\n  for (i = 1; i <= n; ++i) power[i] = (power[i - 1] << 1) % mod;\n  f[0][0][0][0] = 1;\n  for (i = 1; i <= n; ++i)\n    for (j = 0; j <= 1; ++j)\n      for (a = 0; a <= 1; ++a)\n        for (b = 0; b <= 1; ++b)\n          if (res = f[i - 1][j][a][b]) {\n            if (col[i] != 1) {\n              if (!b)\n                f[i][j ^ 1][1][b] =\n                    (f[i][j ^ 1][1][b] + (long long)res * power[i - 1]) % mod;\n              else\n                f[i][j][a][b] = (f[i][j][a][b] +\n                                 (long long)res * (i >= 2 ? power[i - 2] : 0)) %\n                                mod,\n                f[i][j ^ 1][1][b] =\n                    (f[i][j ^ 1][1][b] +\n                     (long long)res * (i >= 2 ? power[i - 2] : 0)) %\n                    mod;\n            }\n            if (col[i] != 0) {\n              if (!a)\n                f[i][j ^ 1][a][1] =\n                    (f[i][j ^ 1][a][1] + (long long)res * power[i - 1]) % mod;\n              else\n                f[i][j][a][b] = (f[i][j][a][b] +\n                                 (long long)res * (i >= 2 ? power[i - 2] : 0)) %\n                                mod,\n                f[i][j ^ 1][a][1] =\n                    (f[i][j ^ 1][a][1] +\n                     (long long)res * (i >= 2 ? power[i - 2] : 0)) %\n                    mod;\n            }\n          }\n  ans = 0;\n  for (a = 0; a <= 1; ++a)\n    for (b = 0; b <= 1; ++b) ans = (ans + f[n][p][a][b]) % mod;\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nint n, p, a[100], f[100][2][2][2], bin[100], res;\nint main() {\n  scanf(\"%d%d\", &n, &p), bin[0] = 1;\n  for (int i = 1; i <= n; i++)\n    scanf(\"%d\", &a[i]), bin[i] = (bin[i - 1] << 1) % mod;\n  f[0][0][0][0] = 1;\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < 2; j++)\n      for (int k = 0; k < 2; k++)\n        for (int l = 0; l < 2; l++) {\n          if (!f[i][j][k][l]) continue;\n          int tmp = f[i][j][k][l];\n          if (a[i + 1] != 0) {\n            if (k)\n              (f[i + 1][j][k][l] += 1ll * tmp * bin[i - 1] % mod) %= mod,\n                  (f[i + 1][j ^ 1][k][true] += 1ll * tmp * bin[i - 1] % mod) %=\n                  mod;\n            else\n              (f[i + 1][j ^ 1][k][true] += 1ll * tmp * bin[i] % mod) %= mod;\n          }\n          if (a[i + 1] != 1) {\n            if (l)\n              (f[i + 1][j][k][l] += 1ll * tmp * bin[i - 1] % mod) %= mod,\n                  (f[i + 1][j ^ 1][true][l] += 1ll * tmp * bin[i - 1] % mod) %=\n                  mod;\n            else\n              (f[i + 1][j ^ 1][true][l] += 1ll * tmp * bin[i] % mod) %= mod;\n          }\n        }\n  for (int k = 0; k < 2; k++)\n    for (int l = 0; l < 2; l++) (res += f[n][p][k][l]) %= mod;\n  printf(\"%d\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\nconst int P = 1e9 + 7;\nint dp[55][55][55][55];\nint pow_2[55];\nint a[55];\nint n, tar, ans;\nvoid add(int &x, int y) {\n  x += y;\n  if (x >= P) x -= P;\n}\nint main() {\n  scanf(\"%d%d\", &n, &tar);\n  pow_2[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    pow_2[i] = (pow_2[i - 1] << 1) % P;\n  }\n  dp[0][0][0][0] = 1;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j <= i; j++) {\n      for (int k = 0; k + j <= i; k++) {\n        for (int l = 0; j + k + l <= i; l++) {\n          if (dp[i][j][k][l] == 0) continue;\n          if (a[i + 1] == 1 || a[i + 1] == -1) {\n            if (l)\n              add(dp[i + 1][j][k + 1][l], (long long)pow_2[l - 1] *\n                                              pow_2[i - l] % P *\n                                              dp[i][j][k][l] % P);\n            add(dp[i + 1][j + 1][k][l], (long long)(l ? pow_2[l - 1] : 1) *\n                                            pow_2[i - l] % P * dp[i][j][k][l] %\n                                            P);\n          }\n          if (a[i + 1] == 0 || a[i + 1] == -1) {\n            if (j)\n              add(dp[i + 1][j][k][l], (long long)pow_2[j - 1] * pow_2[i - j] %\n                                          P * dp[i][j][k][l] % P);\n            add(dp[i + 1][j][k][l + 1], (long long)(j ? pow_2[j - 1] : 1) *\n                                            pow_2[i - j] % P * dp[i][j][k][l] %\n                                            P);\n          }\n        }\n      }\n    }\n  }\n  for (int j = 0; j <= n; j++) {\n    for (int k = 0; k + j <= n; k++) {\n      for (int l = 0; j + k + l <= n; l++) {\n        if (((j + l) & 1) == tar) add(ans, dp[n][j][k][l]);\n      }\n    }\n  }\n  printf(\"%d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline long long read() {\n  long long k = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    k = k * 10 + ch - '0';\n    ch = getchar();\n  }\n  return k * f;\n}\ninline void write(long long x) {\n  if (x < 0) {\n    putchar('-');\n    x = -x;\n  }\n  if (x > 9) write(x / 10);\n  putchar(x % 10 + '0');\n}\ninline void writeln(long long x) {\n  write(x);\n  puts(\"\");\n}\nconst long long N = 1e6 + 10, MOD = 1e9 + 7;\nlong long n, P, ans = 0;\ninline long long mi(long long a, long long b) {\n  long long x = 1, y = a;\n  for (; b; b >>= 1ll, y = y * y % MOD)\n    if (b & 1ll) x = x * y % MOD;\n  return x;\n}\ninline void upd(long long &x, long long y) { x = (x + y) % MOD; }\nlong long f[2][2][2][2];\nsigned main() {\n  n = read();\n  P = read();\n  f[0][0][0][0] = 1;\n  long long bin = 1, la = 0;\n  for (long long T = 1; T <= n; T++) {\n    long long x = read();\n    memset(f[T & 1], 0, sizeof f[T & 1]);\n    for (long long i = 0; i < 2; i++)\n      for (long long j = 0; j < 2; j++)\n        for (long long k = 0; k < 2; k++)\n          if (f[T & 1 ^ 1][j][k]) {\n            if (x != 1) {\n              if (k) {\n                upd(f[T & 1][i ^ 1][1][k], f[T & 1 ^ 1][i][j][k] * la % MOD);\n                upd(f[T & 1][i][j][k], f[T & 1 ^ 1][i][j][k] * la % MOD);\n              } else\n                upd(f[T & 1][i ^ 1][1][0], f[T & 1 ^ 1][i][j][k] * bin % MOD);\n            }\n            if (x != 0) {\n              if (j) {\n                upd(f[T & 1][i ^ 1][j][1], f[T & 1 ^ 1][i][j][k] * la % MOD);\n                upd(f[T & 1][i][j][k], f[T & 1 ^ 1][i][j][k] * la % MOD);\n              } else\n                upd(f[T & 1][i ^ 1][0][1], f[T & 1 ^ 1][i][j][k] * bin % MOD);\n            }\n          }\n    la = bin;\n    bin = bin * 2 % MOD;\n  }\n  for (long long i = 0; i < 2; i++)\n    for (long long j = 0; j < 2; j++) upd(ans, f[n & 1][P][i][j]);\n  writeln(ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nT abs(T x) {\n  return x > 0 ? x : -x;\n}\ntemplate <class T>\nT gcd(T a, T b) {\n  return a ? gcd(b % a, a) : b;\n}\ntemplate <class T>\nT sqr(T a) {\n  return a * a;\n}\ntemplate <class T>\nT sgn(T a) {\n  return a > 0 ? 1 : (a < 0 ? -1 : 0);\n}\nconst double pi = acos(-1.0);\nint n;\nint m;\nconst int N = 50 + 3;\nconst int mod = 1e9 + 7;\nint was[N][N][N][N];\nint f[N][N][N][N];\nint g[2][N], c[N], pw2[N];\nint p;\nint go(array<int, 4> a) {\n  int i = a[0] + a[1] + a[2] + a[3];\n  if (i == n) {\n    return (a[1] + a[3]) % 2 == p;\n  }\n  auto& cur_was = was[a[0]][a[1]][a[2]][a[3]];\n  auto& cur_f = f[a[0]][a[1]][a[2]][a[3]];\n  if (cur_was) return cur_f;\n  cur_was = true;\n  auto ac = a;\n  int cur;\n  if (c[i] == -1 || c[i] == 0) {\n    ac[0]++;\n    cur = ((long long)pw2[i - a[3]] * g[0][a[3]]) % mod;\n    cur_f = (cur_f + (long long)go(ac) * cur) % mod;\n    ac[0]--;\n    ac[1]++;\n    cur = ((long long)pw2[i - a[3]] * g[1][a[3]]) % mod;\n    cur_f = (cur_f + (long long)go(ac) * cur) % mod;\n    ac[1]--;\n  }\n  if (c[i] == -1 || c[i] == 1) {\n    ac[2]++;\n    cur = ((long long)pw2[i - a[1]] * g[0][a[1]]) % mod;\n    cur_f = (cur_f + (long long)go(ac) * cur) % mod;\n    ac[2]--;\n    ac[3]++;\n    cur = ((long long)pw2[i - a[1]] * g[1][a[1]]) % mod;\n    cur_f = (cur_f + (long long)go(ac) * cur) % mod;\n    ac[3]--;\n  }\n  return cur_f;\n}\nint main() {\n  cin >> n >> p;\n  for (int i = 0; i < n; i++) cin >> c[i];\n  pw2[0] = 1;\n  for (int i = 0; i < n; i++) pw2[i + 1] = (pw2[i] * 2ll) % mod;\n  g[1][0] = 1;\n  for (int i = 1; i <= n; i++) g[0][i] = g[1][i] = pw2[i - 1];\n  cout << go({0, 0, 0, 0}) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int OO = 1e9;\nconst long long INF = 1e18;\nconst int irand(int lo, int hi) {\n  return ((double)rand() / (RAND_MAX + 1.0)) * (hi - lo + 1) + lo;\n}\nconst long long lrand(long long lo, long long hi) {\n  return ((double)rand() / (RAND_MAX + 1.0)) * (hi - lo + 1) + lo;\n}\ntemplate <typename T>\nT getnum() {\n  int sign = 1;\n  T ret = 0;\n  char c;\n  do {\n    c = getchar();\n  } while (c == ' ' || c == '\\n');\n  if (c == '-')\n    sign = -1;\n  else\n    ret = c - '0';\n  while (1) {\n    c = getchar();\n    if (c < '0' || c > '9') break;\n    ret = 10 * ret + c - '0';\n  }\n  return sign * ret;\n}\ninline void ini(int& x) { x = getnum<int>(); }\ninline void scani(int& x) { scanf(\"%d\", &x); }\nconst int N = 55;\nconst long long MOD = 1e9 + 7;\ninline long long addmod(long long a, long long b) { return (a + b) % MOD; }\ninline long long submod(long long a, long long b) {\n  return (MOD + a - b) % MOD;\n}\ninline long long mulmod(long long a, long long b) { return (a * b) % MOD; }\nint pow2[N];\nint n, p;\nint arr[N];\nint dp[N][N][N][N];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  pow2[0] = 1;\n  for (int i = 1; i <= N - 1; i += 1) pow2[i] = mulmod(pow2[i - 1], 2);\n  cin >> n >> p;\n  for (int i = 1; i <= n; i += 1) cin >> arr[i];\n  int ans = 0;\n  dp[0][0][0][0] = 1;\n  for (int i = 1; i <= n; i += 1) {\n    for (int c0p0 = 0; c0p0 <= i - 1; c0p0 += 1) {\n      for (int c0p1 = 0; c0p1 <= i - 1 - c0p0; c0p1 += 1) {\n        for (int c1p0 = 0; c1p0 <= i - 1 - c0p0 - c0p1; c1p0 += 1) {\n          if (dp[i - 1][c0p0][c0p1][c1p0] == 0) continue;\n          int c1p1 = i - 1 - c0p0 - c0p1 - c1p0;\n          int ways = dp[i - 1][c0p0][c0p1][c1p0];\n          ways = mulmod(ways, pow2[c0p0]);\n          ways = mulmod(ways, pow2[c1p0]);\n          if (arr[i] == 0 || arr[i] == -1) {\n            int nways = mulmod(ways, pow2[c0p1]);\n            int ways0, ways1;\n            if (c1p1 > 0)\n              ways0 = ways1 = mulmod(nways, pow2[c1p1 - 1]);\n            else {\n              ways1 = nways;\n              ways0 = 0;\n            }\n            dp[i][c0p0 + 1][c0p1][c1p0] =\n                addmod(dp[i][c0p0 + 1][c0p1][c1p0], ways0);\n            dp[i][c0p0][c0p1 + 1][c1p0] =\n                addmod(dp[i][c0p0][c0p1 + 1][c1p0], ways1);\n          }\n          if (arr[i] == 1 || arr[i] == -1) {\n            int nways = mulmod(ways, pow2[c1p1]);\n            int ways0, ways1;\n            if (c0p1 > 0)\n              ways0 = ways1 = mulmod(nways, pow2[c0p1 - 1]);\n            else {\n              ways1 = nways;\n              ways0 = 0;\n            }\n            dp[i][c0p0][c0p1][c1p0 + 1] =\n                addmod(dp[i][c0p0][c0p1][c1p0 + 1], ways0);\n            dp[i][c0p0][c0p1][c1p0] = addmod(dp[i][c0p0][c0p1][c1p0], ways1);\n          }\n        }\n      }\n    }\n  }\n  for (int i = 0; i <= n; i += 1) {\n    for (int j = 0; j <= n - i; j += 1) {\n      for (int k = 0; k <= n - i - j; k += 1) {\n        if ((n - i - k) % 2 != p) continue;\n        ans = addmod(ans, dp[n][i][j][k]);\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            EKuroAndTopologicalParity solver = new EKuroAndTopologicalParity();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class EKuroAndTopologicalParity {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int p = in.readInt();\n            int[] c = new int[n + 1];\n            for (int i = 1; i <= n; i++) {\n                c[i] = in.readInt();\n            }\n\n            Modular mod = new Modular(1e9 + 7);\n            Composite comp = new Composite(n, mod);\n            CachedPow pow = new CachedPow(2, mod);\n            int[] pow2 = new int[n + 1];\n            int[] compEven = new int[n + 1];\n            int[] compOdd = new int[n + 1];\n            for (int i = 0; i <= n; i++) {\n                for (int j = 0; j <= n; j += 2) {\n                    compEven[i] = mod.plus(compEven[i], comp.composite(i, j));\n                }\n            }\n            for (int i = 0; i <= n; i++) {\n                for (int j = 1; j <= n; j += 2) {\n                    compOdd[i] = mod.plus(compOdd[i], comp.composite(i, j));\n                }\n            }\n            for (int i = 0; i <= n; i++) {\n                pow2[i] = pow.pow(i);\n            }\n\n            int[][][][] last = new int[n + 1][n + 1][n + 1][2];\n            int[][][][] next = new int[n + 1][n + 1][n + 1][2];\n\n            last[0][0][0][0] = 1;\n            for (int i = 1; i <= n; i++) {\n                for (int j = 0; j <= n; j++) {\n                    for (int k = 0; k <= n; k++) {\n                        for (int t = j; t + k <= i; t++) {\n                            for (int parity = 0; parity < 2; parity++) {\n                                next[j][k][t][parity] = 0;\n                                if (c[i] != 1 && t > 0) {\n                                    //it's 0 now\n\n                                    //pick even and it's odd\n                                    if (j > 0) {\n                                        next[j][k][t][parity] = mod.plus(next[j][k][t][parity],\n                                                mod.mul(mod.mul(last[j - 1][k][t - 1][1 - parity], compEven[k]), pow2[i - t - k]));\n                                    }\n\n                                    //pick odd and it's even\n                                    next[j][k][t][parity] = mod.plus(next[j][k][t][parity],\n                                            mod.mul(mod.mul(last[j][k][t - 1][parity], compOdd[k]), pow2[i - t - k]));\n                                }\n                                if (c[i] != 0) {\n                                    //it's 1 now\n\n                                    //pick even and it's odd\n                                    if (k > 0) {\n                                        next[j][k][t][parity] = mod.plus(next[j][k][t][parity],\n                                                mod.mul(mod.mul(last[j][k - 1][t][1 - parity], compEven[j]), pow2[t - j]));\n                                    }\n\n                                    //pick odd and it's even\n                                    next[j][k][t][parity] = mod.plus(next[j][k][t][parity],\n                                            mod.mul(mod.mul(last[j][k][t][parity], compOdd[j]), pow2[t - j]));\n                                }\n                            }\n                        }\n                    }\n                }\n\n                int[][][][] tmp = last;\n                last = next;\n                next = tmp;\n            }\n\n            int ans = 0;\n            for (int i = 0; i <= n; i++) {\n                for (int j = 0; j <= n; j++) {\n                    for (int k = 0; k <= n; k++) {\n                        int cnt = last[i][j][k][p];\n                        cnt = mod.mul(cnt, pow.pow(comp.composite(k, 2)));\n                        cnt = mod.mul(cnt, pow.pow(comp.composite(n - k, 2)));\n                        ans = mod.plus(ans, cnt);\n                    }\n                }\n            }\n\n            out.println(ans);\n        }\n\n    }\n\n    static class DigitUtils {\n        private DigitUtils() {\n        }\n\n        public static long round(double x) {\n            if (x >= 0) {\n                return (long) (x + 0.5);\n            } else {\n                return (long) (x - 0.5);\n            }\n        }\n\n    }\n\n    static class Composite {\n        final Factorial factorial;\n        final Modular modular;\n\n        public Composite(Factorial factorial) {\n            this.factorial = factorial;\n            this.modular = factorial.getModular();\n        }\n\n        public Composite(int limit, Modular modular) {\n            this(new Factorial(limit, modular));\n        }\n\n        public int composite(int m, int n) {\n            if (n > m) {\n                return 0;\n            }\n            return modular.mul(modular.mul(factorial.fact(m), factorial.invFact(n)), factorial.invFact(m - n));\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(int c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class Modular {\n        int m;\n\n        public int getMod() {\n            return m;\n        }\n\n        public Modular(int m) {\n            this.m = m;\n        }\n\n        public Modular(long m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public Modular(double m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int valueOf(int x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return x;\n        }\n\n        public int valueOf(long x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return (int) x;\n        }\n\n        public int mul(int x, int y) {\n            return valueOf((long) x * y);\n        }\n\n        public int plus(int x, int y) {\n            return valueOf(x + y);\n        }\n\n        public Modular getModularForPowerComputation() {\n            return new Modular(m - 1);\n        }\n\n        public String toString() {\n            return \"mod \" + m;\n        }\n\n    }\n\n    static class InverseNumber {\n        int[] inv;\n\n        public InverseNumber(int[] inv, int limit, Modular modular) {\n            this.inv = inv;\n            inv[1] = 1;\n            int p = modular.getMod();\n            for (int i = 2; i <= limit; i++) {\n                int k = p / i;\n                int r = p % i;\n                inv[i] = modular.mul(-k, inv[r]);\n            }\n        }\n\n        public InverseNumber(int limit, Modular modular) {\n            this(new int[limit + 1], limit, modular);\n        }\n\n    }\n\n    static class CachedPow {\n        private int[] first;\n        private int[] second;\n        private Modular mod;\n        private Modular powMod;\n\n        public CachedPow(int x, Modular mod) {\n            this(x, mod.getMod(), mod);\n        }\n\n        public CachedPow(int x, int maxExp, Modular mod) {\n            this.mod = mod;\n            this.powMod = mod.getModularForPowerComputation();\n            int k = Math.max(1, (int) DigitUtils.round(Math.sqrt(maxExp)));\n            first = new int[k];\n            second = new int[maxExp / k + 1];\n            first[0] = 1;\n            for (int i = 1; i < k; i++) {\n                first[i] = mod.mul(x, first[i - 1]);\n            }\n            second[0] = 1;\n            int step = mod.mul(x, first[k - 1]);\n            for (int i = 1; i < second.length; i++) {\n                second[i] = mod.mul(second[i - 1], step);\n            }\n        }\n\n        public int pow(int exp) {\n            return mod.mul(first[exp % first.length], second[exp / first.length]);\n        }\n\n    }\n\n    static class Factorial {\n        int[] fact;\n        int[] inv;\n        Modular modular;\n\n        public Modular getModular() {\n            return modular;\n        }\n\n        public Factorial(int[] fact, int[] inv, InverseNumber in, int limit, Modular modular) {\n            this.modular = modular;\n            this.fact = fact;\n            this.inv = inv;\n            fact[0] = inv[0] = 1;\n            for (int i = 1; i <= limit; i++) {\n                fact[i] = modular.mul(fact[i - 1], i);\n                inv[i] = modular.mul(inv[i - 1], in.inv[i]);\n            }\n        }\n\n        public Factorial(int limit, Modular modular) {\n            this(new int[limit + 1], new int[limit + 1], new InverseNumber(limit, modular), limit, modular);\n        }\n\n        public int fact(int n) {\n            return fact[n];\n        }\n\n        public int invFact(int n) {\n            return inv[n];\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nlong long n, p, a[200005], f[200005][2][2][2], pw[200005];\nlong long read() {\n  long long f = 0, w = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') w = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    f = f * 10 + ch - '0';\n    ch = getchar();\n  }\n  return f * w;\n}\nsigned main() {\n  n = read(), p = read();\n  for (long long i = 1; i <= n; i++) a[i] = read();\n  pw[0] = 1;\n  for (long long i = 1; i <= n; i++) pw[i] = pw[i - 1] * 2 % mod;\n  f[0][0][0][0] = 1;\n  for (long long i = 0; i < n; i++) {\n    for (long long j = 0; j <= 1; j++) {\n      for (long long k = 0; k <= 1; k++) {\n        for (long long l = 0; l <= 1; l++) {\n          if (!f[i][j][k][l]) continue;\n          if (a[i + 1] != 1) {\n            f[i + 1][j][k][l] = (f[i + 1][j][k][l] +\n                                 f[i][j][k][l] * ((j == 0) ? 0 : pw[i - 1])) %\n                                mod;\n            f[i + 1][j][k | 1][l ^ 1] =\n                (f[i + 1][j][k | 1][l ^ 1] +\n                 f[i][j][k][l] * ((j == 0) ? pw[i] : pw[i - 1])) %\n                mod;\n          }\n          if (a[i + 1] != 0) {\n            f[i + 1][j][k][l] = (f[i + 1][j][k][l] +\n                                 f[i][j][k][l] * ((k == 0) ? 0 : pw[i - 1])) %\n                                mod;\n            f[i + 1][j | 1][k][l ^ 1] =\n                (f[i + 1][j | 1][k][l ^ 1] +\n                 f[i][j][k][l] * ((k == 0) ? pw[i] : pw[i - 1])) %\n                mod;\n          }\n        }\n      }\n    }\n  }\n  long long ans = 0;\n  for (long long i = 0; i <= 1; i++) {\n    for (long long j = 0; j <= 1; j++) {\n      ans = (ans + f[n][i][j][p]) % mod;\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ninline int read() {\n  char c = getchar();\n  int n = 0;\n  bool f = false;\n  while (c < '0' || c > '9') {\n    if (c == '-') {\n      f = true;\n    }\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    n = (n << 1) + (n << 3) + (c & 15);\n    c = getchar();\n  }\n  return f ? -n : n;\n}\nconst int p = 1e9 + 7, maxN = 200005;\ninline int power(int x, int y) {\n  if (y < 0) {\n    return 0;\n  }\n  int res = 1;\n  for (; y; y >>= 1, x = 1ll * x * x % p) {\n    if (y & 1) {\n      res = 1ll * res * x % p;\n    }\n  }\n  return res;\n}\nint n, m, c, k, ans, f[2][2][2][maxN];\nint main() {\n  n = read();\n  m = read();\n  f[0][0][0][0] = 1;\n  for (int i = 0; i < n; i++) {\n    c = read();\n    if (c == -1 || c == 0) {\n      for (int j = 0; j <= 1; j++) {\n        for (int x = 0; x <= 1; x++) {\n          for (int y = 0; y <= 1; y++) {\n            if (x) {\n              k = 1ll * f[j][x][y][i] * power(2, i - 1) % p;\n              (f[j][x][y][i + 1] += k) %= p;\n            } else {\n              k = 1ll * f[j][x][y][i] * power(2, i) % p;\n            }\n            (f[j ^ 1][x][1][i + 1] += k) %= p;\n          }\n        }\n      }\n    }\n    if (c == -1 || c == 1) {\n      for (int j = 0; j <= 1; j++) {\n        for (int x = 0; x <= 1; x++) {\n          for (int y = 0; y <= 1; y++) {\n            if (y) {\n              k = 1ll * f[j][x][y][i] * power(2, i - 1) % p;\n              (f[j][x][y][i + 1] += k) %= p;\n            } else {\n              k = 1ll * f[j][x][y][i] * power(2, i) % p;\n            }\n            (f[j ^ 1][1][y][i + 1] += k) %= p;\n          }\n        }\n      }\n    }\n  }\n  for (int x = 0; x <= 1; x++) {\n    for (int y = 0; y <= 1; y++) {\n      (ans += f[m][x][y][n]) %= p;\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[55][2][2][2], a[55], pow2[55];\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  pow2[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    pow2[i] = 1ll * 2 * pow2[i - 1] % (int)(1e9 + 7);\n  }\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  dp[0][0][0][0] = 1;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j <= 1; j++) {\n      if (a[i] != 1) {\n        if (i > 1)\n          dp[i][j][0][1] +=\n              (long long)(dp[i - 1][j][0][1]) * pow2[i - 2] % (int)(1e9 + 7);\n        dp[i][j][1][0] +=\n            (long long)(dp[i - 1][j ^ 1][1][0] + dp[i - 1][j ^ 1][0][0]) *\n            pow2[i - 1] % (int)(1e9 + 7);\n        if (i > 1)\n          dp[i][j][1][1] +=\n              (long long)dp[i - 1][j][1][1] * pow2[i - 2] % (int)(1e9 + 7);\n        dp[i][j][1][1] %= (int)(1e9 + 7);\n        if (i > 1)\n          dp[i][j][1][1] +=\n              (long long)(dp[i - 1][j ^ 1][0][1] + dp[i - 1][j ^ 1][1][1]) *\n              pow2[i - 2] % (int)(1e9 + 7);\n      }\n      dp[i][j][0][1] %= (int)(1e9 + 7);\n      dp[i][j][1][0] %= (int)(1e9 + 7);\n      dp[i][j][1][1] %= (int)(1e9 + 7);\n      if (a[i] != 0) {\n        if (i > 1)\n          dp[i][j][1][0] +=\n              (long long)(dp[i - 1][j][1][0]) * pow2[i - 2] % (int)(1e9 + 7);\n        dp[i][j][0][1] +=\n            (long long)(dp[i - 1][j ^ 1][0][1] + dp[i - 1][j ^ 1][0][0]) *\n            pow2[i - 1] % (int)(1e9 + 7);\n        if (i > 1)\n          dp[i][j][1][1] +=\n              (long long)dp[i - 1][j][1][1] * pow2[i - 2] % (int)(1e9 + 7);\n        dp[i][j][1][1] %= (int)(1e9 + 7);\n        if (i > 1)\n          dp[i][j][1][1] +=\n              (long long)(dp[i - 1][j ^ 1][1][0] + dp[i - 1][j ^ 1][1][1]) *\n              pow2[i - 2] % (int)(1e9 + 7);\n      }\n      dp[i][j][0][1] %= (int)(1e9 + 7);\n      dp[i][j][1][0] %= (int)(1e9 + 7);\n      dp[i][j][1][1] %= (int)(1e9 + 7);\n    }\n  }\n  cout << ((long long)dp[n][m][1][1] + dp[n][m][1][0] + dp[n][m][0][1]) %\n              (int)(1e9 + 7);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, op, d;\nint f[(200005)][3][3], mi[1000005], a[(200005)];\nconst int P = 1000000007;\ntemplate <typename T>\nvoid read(T& t) {\n  t = 0;\n  bool fl = true;\n  char p = getchar();\n  while (!isdigit(p)) {\n    if (p == '-') fl = false;\n    p = getchar();\n  }\n  do {\n    (t *= 10) += p - 48;\n    p = getchar();\n  } while (isdigit(p));\n  if (!fl) t = -t;\n}\nint ksm(int a, int b) {\n  if (b == 0) return 1;\n  int ret = 1;\n  while (b > 1) {\n    if (b & 1) ret = 1ll * ret * a % P;\n    b >>= 1;\n    a = 1ll * a * a % P;\n  }\n  return 1ll * ret * a % P;\n}\nint Inc(int a, int b) { return (a + b >= P) ? (a + b - P) : (a + b); }\nint calc(int k, int op) {\n  if (k == 0) {\n    if (op == 0)\n      return 1;\n    else\n      return 0;\n  } else\n    return mi[k - 1];\n}\nint main() {\n  read(n), read(op);\n  mi[0] = 1;\n  for (int i = 1; i <= 1000000; i++) mi[i] = mi[i - 1] * 2 % P;\n  for (int i = 1; i <= n; i++) read(a[i]);\n  f[0][2][2] = 1;\n  for (int i = 1; i <= n; i++) {\n    for (int a1 = 0; a1 <= 2; a1++)\n      for (int a2 = 0; a2 <= 2; a2++) {\n        if (a[i] == 0) {\n          if (a2 == 2) {\n            if (a1 == 2)\n              f[i][1][a2] =\n                  Inc(f[i][1][a2], 1ll * f[i - 1][a1][a2] * mi[i - 1] % P);\n            else\n              f[i][a1 ^ 1][a2] =\n                  Inc(f[i][a1 ^ 1][a2], 1ll * f[i - 1][a1][a2] * mi[i - 1] % P);\n          } else {\n            if (a1 == 2)\n              f[i][1][a2] =\n                  Inc(f[i][1][a2], 1ll * f[i - 1][a1][a2] * mi[i - 2] % P);\n            else\n              f[i][a1 ^ 1][a2] =\n                  Inc(f[i][a1 ^ 1][a2], 1ll * f[i - 1][a1][a2] * mi[i - 2] % P);\n            f[i][a1][a2] =\n                Inc(f[i][a1][a2], 1ll * f[i - 1][a1][a2] * mi[i - 2] % P);\n          }\n        }\n        if (a[i] == 1) {\n          if (a1 == 2) {\n            if (a2 == 2)\n              f[i][a1][1] =\n                  Inc(f[i][a1][1], 1ll * f[i - 1][a1][a2] * mi[i - 1] % P);\n            else\n              f[i][a1][a2 ^ 1] =\n                  Inc(f[i][a1][a2 ^ 1], 1ll * f[i - 1][a1][a2] * mi[i - 1] % P);\n          } else {\n            if (a2 == 2)\n              f[i][a1][1] =\n                  Inc(f[i][a1][1], 1ll * f[i - 1][a1][a2] * mi[i - 2] % P);\n            else\n              f[i][a1][a2 ^ 1] =\n                  Inc(f[i][a1][a2 ^ 1], 1ll * f[i - 1][a1][a2] * mi[i - 2] % P);\n            f[i][a1][a2] =\n                Inc(f[i][a1][a2], 1ll * f[i - 1][a1][a2] * mi[i - 2] % P);\n          }\n        }\n        if (a[i] == -1) {\n          if (a2 == 2) {\n            if (a1 == 2)\n              f[i][1][a2] =\n                  Inc(f[i][1][a2], 1ll * f[i - 1][a1][a2] * mi[i - 1] % P);\n            else\n              f[i][a1 ^ 1][a2] =\n                  Inc(f[i][a1 ^ 1][a2], 1ll * f[i - 1][a1][a2] * mi[i - 1] % P);\n          } else {\n            if (a1 == 2)\n              f[i][1][a2] =\n                  Inc(f[i][1][a2], 1ll * f[i - 1][a1][a2] * mi[i - 2] % P);\n            else\n              f[i][a1 ^ 1][a2] =\n                  Inc(f[i][a1 ^ 1][a2], 1ll * f[i - 1][a1][a2] * mi[i - 2] % P);\n            f[i][a1][a2] =\n                Inc(f[i][a1][a2], 1ll * f[i - 1][a1][a2] * mi[i - 2] % P);\n          }\n          if (a1 == 2) {\n            if (a2 == 2)\n              f[i][a1][1] =\n                  Inc(f[i][a1][1], 1ll * f[i - 1][a1][a2] * mi[i - 1] % P);\n            else\n              f[i][a1][a2 ^ 1] =\n                  Inc(f[i][a1][a2 ^ 1], 1ll * f[i - 1][a1][a2] * mi[i - 1] % P);\n          } else {\n            if (a2 == 2)\n              f[i][a1][1] =\n                  Inc(f[i][a1][1], 1ll * f[i - 1][a1][a2] * mi[i - 2] % P);\n            else\n              f[i][a1][a2 ^ 1] =\n                  Inc(f[i][a1][a2 ^ 1], 1ll * f[i - 1][a1][a2] * mi[i - 2] % P);\n            f[i][a1][a2] =\n                Inc(f[i][a1][a2], 1ll * f[i - 1][a1][a2] * mi[i - 2] % P);\n          }\n        }\n      }\n  }\n  int ans = 0;\n  if (op == 1) {\n    ans = Inc(f[n][0][1], f[n][1][0]);\n    ans = Inc(ans, f[n][2][1]), ans = Inc(ans, f[n][1][2]);\n  } else {\n    ans = Inc(f[n][1][1], f[n][0][0]);\n    ans = Inc(ans, f[n][2][2]);\n    ans = Inc(ans, f[n][2][0]);\n    ans = Inc(ans, f[n][0][2]);\n  }\n  printf(\"%d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nlong long read() {\n  char last = '+', ch = getchar();\n  while (ch < '0' || ch > '9') last = ch, ch = getchar();\n  long long tmp = 0;\n  while (ch >= '0' && ch <= '9') tmp = tmp * 10 + ch - 48, ch = getchar();\n  if (last == '-') tmp = -tmp;\n  return tmp;\n}\nconst int M = 1000000007;\nconst int _n = 50 + 10;\nint n, p;\nint x[_n];\nint mi[_n];\nint f[_n][2][2][2];\nint ans;\nint main() {\n  n = read();\n  p = read();\n  for (int i = 1; i <= n; i++) {\n    x[i] = read();\n  }\n  mi[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    mi[i] = (long long)mi[i - 1] * 2 % M;\n  }\n  f[0][0][0][0] = 1;\n  for (int i = 1; i <= n; i++) {\n    if (x[i] != 0) {\n      for (int w = 0; w < 2; w++) {\n        for (int k = 0; k < 2; k++) {\n          (f[i][w | 1][0][k ^ 1] +=\n           (long long)f[i - 1][w][0][k] * mi[i - 1] % M) %= M;\n          (f[i][w | 0][1][k ^ 0] +=\n           (long long)f[i - 1][w][1][k] * mi[i - 2] % M) %= M;\n          (f[i][w | 1][1][k ^ 1] +=\n           (long long)f[i - 1][w][1][k] * mi[i - 2] % M) %= M;\n        }\n      }\n    }\n    if (x[i] != 1) {\n      for (int b = 0; b < 2; b++) {\n        for (int k = 0; k < 2; k++) {\n          (f[i][0][b | 1][k ^ 1] +=\n           (long long)f[i - 1][0][b][k] * mi[i - 1] % M) %= M;\n          (f[i][1][b | 0][k ^ 0] +=\n           (long long)f[i - 1][1][b][k] * mi[i - 2] % M) %= M;\n          (f[i][1][b | 1][k ^ 1] +=\n           (long long)f[i - 1][1][b][k] * mi[i - 2] % M) %= M;\n        }\n      }\n    }\n  }\n  ans = 0;\n  for (int w = 0; w < 2; w++) {\n    for (int b = 0; b < 2; b++) {\n      (ans += f[n][w][b][p]) %= M;\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, pp;\nint c[64];\nlong long f[64][64][64][2];\nlong long p2[1 << 16];\nint main() {\n  p2[0] = 1;\n  for (int i = 1, ThxDem = 1 << 16; i < ThxDem; ++i)\n    p2[i] = p2[i - 1] * 2 % 1000000007;\n  scanf(\"%d%d\", &n, &pp);\n  for (int i = 0, ThxDem = n; i < ThxDem; ++i) scanf(\"%d\", c + i);\n  f[0][0][0][0] = 1;\n  for (int i = 0, ThxDem = n; i < ThxDem; ++i) {\n    for (int j = 0, ThxDem = i + 1; j < ThxDem; ++j)\n      for (int k = 0, ThxDem = i + 1; k < ThxDem; ++k)\n        for (int p = 0, ThxDem = 2; p < ThxDem; ++p) {\n          if (!f[i][j][k][p]) continue;\n          if (c[i] == 0 || c[i] < 0) {\n            if (k)\n              f[i + 1][j][k][p] += f[i][j][k][p] * p2[i - 1] % 1000000007,\n                  f[i + 1][j][k][p] %= 1000000007;\n            long long t = p2[i - k];\n            if (k) t = t * p2[k - 1] % 1000000007;\n            f[i + 1][j + 1][k][p ^ 1] += f[i][j][k][p] * t % 1000000007;\n            f[i + 1][j + 1][k][p ^ 1] %= 1000000007;\n          }\n          if (c[i] == 1 || c[i] < 0) {\n            if (j)\n              f[i + 1][j][k][p] += f[i][j][k][p] * p2[i - 1] % 1000000007,\n                  f[i + 1][j][k][p] %= 1000000007;\n            long long t = p2[i - j];\n            if (j) t = t * p2[j - 1] % 1000000007;\n            f[i + 1][j][k + 1][p ^ 1] += f[i][j][k][p] * t % 1000000007;\n            f[i + 1][j][k + 1][p ^ 1] %= 1000000007;\n          }\n        }\n  }\n  long long r = 0;\n  for (int i = 0, ThxDem = n + 1; i < ThxDem; ++i)\n    for (int j = 0, ThxDem = n + 1; j < ThxDem; ++j)\n      r += f[n][i][j][pp], r %= 1000000007;\n  printf(\"%lld\\n\", r);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint intcmp(const void *v1, const void *v2) { return *(int *)v1 - *(int *)v2; }\nconst int N = 55;\nint n, p;\nlong long f[N][N][N];\nlong long ans = 0, pw[N], od[N], ev[N];\nvoid init() {\n  f[0][0][0] = 1;\n  pw[0] = 1;\n  ev[0] = 1;\n  for (int i = 1; i < N; i++) {\n    pw[i] = pw[i - 1] * 2 % 1000000007;\n    od[i] = ev[i] = pw[i - 1];\n  }\n}\nvoid push_ans(int col, int ob, int ow, int e) {\n  if (col != 0)\n    (f[ob][ow + 1][e] += f[ob][ow][e] * pw[ow + e] % 1000000007 * ev[ob] %\n                         1000000007) %= 1000000007;\n  if (col != 1)\n    (f[ob + 1][ow][e] += f[ob][ow][e] * pw[ob + e] % 1000000007 * ev[ow] %\n                         1000000007) %= 1000000007;\n  if (col != 1)\n    (f[ob][ow][e + 1] += f[ob][ow][e] * pw[ob + e] % 1000000007 * od[ow] %\n                         1000000007) %= 1000000007;\n  if (col != 0)\n    (f[ob][ow][e + 1] += f[ob][ow][e] * pw[ow + e] % 1000000007 * od[ob] %\n                         1000000007) %= 1000000007;\n}\nint main() {\n  init();\n  cin >> n >> p;\n  int c;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &c);\n    for (int ob = 0; ob < i + 1; ob++)\n      for (int ow = 0; ow < i - ob + 1; ow++) {\n        push_ans(c, ob, ow, i - ob - ow);\n      }\n  }\n  int i = n;\n  for (int ob = 0; ob < i + 1; ob++)\n    for (int ow = 0; ow < i - ob + 1; ow++) {\n      int e = i - ob - ow;\n      if (((ob + ow) & 1) == p) (ans += f[ob][ow][e]) %= 1000000007;\n    }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing PII = pair<int, int>;\nconst int N = 55;\nconst int P = 1e9 + 7;\nint F[N][N][N][N][2];\nint main() {\n  function<LL(int, int)> com = [&](int n, int k) {\n    static vector<vector<LL>> C(N, vector<LL>(N, -1));\n    if (C[n][k] != -1) return C[n][k];\n    if (k * 2 > n) return com(n, n - k);\n    if (k == 0) return C[n][k] = 1LL;\n    return C[n][k] = com(n - 1, k) + com(n - 1, k - 1);\n  };\n  memset(F, -1, sizeof F);\n  int n, p;\n  scanf(\"%d%d\", &n, &p);\n  vector<int> C(n + 1);\n  for (int i = (1); i <= (n); ++i) scanf(\"%d\", &C[i]);\n  using State = array<int, 5>;\n  queue<State> Q;\n  Q.push({0, 0, 0, 0, 0});\n  LL ans = 0;\n  F[0][0][0][0][0] = 1;\n  while (!Q.empty()) {\n    State u = Q.front();\n    Q.pop();\n    int& obj = F[u[0]][u[1]][u[2]][u[3]][u[4]];\n    int tot = u[0] + u[1] + u[2] + u[3];\n    if (tot == n) {\n      if (u[4] == p) ans = (ans + obj) % P;\n      continue;\n    }\n    auto trans = [&](int d) {\n      int same = u[d] + u[d + 2];\n      int odd = u[(d ^ 1) + 2];\n      int even = u[d ^ 1];\n      auto inner = [&](bool flag) {\n        auto v = u;\n        v[4] ^= 1;\n        if (flag)\n          v[d + 2]++;\n        else\n          v[d]++;\n        if (flag) v[4] ^= 1;\n        int& nxt = F[v[0]][v[1]][v[2]][v[3]][v[4]];\n        if (nxt == -1) {\n          nxt = 0;\n          Q.push(v);\n        }\n        int k = (1LL << (same + odd)) % P;\n        int a = 0;\n        for (int i = flag; i <= even; i += 2) {\n          a = (a + com(even, i) % P) % P;\n        }\n        nxt = (nxt + 1LL * obj * k % P * a % P) % P;\n      };\n      inner(true);\n      inner(false);\n    };\n    if (C[tot + 1] == 0)\n      trans(0);\n    else if (C[tot + 1] == 1)\n      trans(1);\n    else {\n      trans(0);\n      trans(1);\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline char gc() {\n  static char buf[1 << 14], *p1 = buf, *p2 = buf;\n  return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 14, stdin), p1 == p2)\n             ? EOF\n             : *p1++;\n}\ninline int read(int &x) {\n  x = 0;\n  bool f = 1;\n  char c = gc();\n  for (; !isdigit(c); c = gc()) {\n    if (c == '-') f ^= 1;\n    if (c == -1) return -1;\n  }\n  for (; isdigit(c); c = gc()) x = (x << 1) + (x << 3) + (c ^ 48);\n  x = f ? x : -x;\n  return 1;\n}\ninline void wr(int x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x > 9) wr(x / 10);\n  putchar(x % 10 | 48);\n}\ninline void yyhakking() {\n  freopen(\"graph.in\", \"r\", stdin);\n  freopen(\"graph.out\", \"w\", stdout);\n}\nconst int P = 1e9 + 7, N = 1e6 + 10;\nint n, p, f[2][2][2], g[2][2][2], ans;\nint main() {\n  read(n), read(p);\n  f[0][0][0] = 1;\n  int g1 = 0, g2 = 1;\n  for (int t = 0, x; t < n; ++t) {\n    read(x);\n    memset(g, 0, sizeof g);\n    if (x != 1)\n      for (int i = 0; i < 2; ++i)\n        for (int j = 0; j < 2; ++j)\n          for (int k = 0; k < 2; ++k)\n            if (f[i][j][k]) {\n              if (!k)\n                (g[!i][1][0] += 1ll * f[i][j][k] * g2 % P) %= P;\n              else {\n                (g[!i][1][k] += 1ll * f[i][j][k] * g1 % P) %= P;\n                (g[i][j][k] += 1ll * f[i][j][k] * g1 % P) %= P;\n              }\n            }\n    if (x != 0)\n      for (int i = 0; i < 2; ++i)\n        for (int j = 0; j < 2; ++j)\n          for (int k = 0; k < 2; ++k)\n            if (f[i][j][k]) {\n              if (!j)\n                (g[!i][0][1] += 1ll * f[i][j][k] * g2 % P) %= P;\n              else {\n                (g[!i][j][1] += 1ll * f[i][j][k] * g1 % P) %= P;\n                (g[i][j][k] += 1ll * f[i][j][k] * g1 % P) %= P;\n              }\n            }\n    memcpy(f, g, sizeof g);\n    g1 = g2, g2 = g2 * 2 % P;\n  }\n  for (int i = 0; i < 2; ++i)\n    for (int j = 0; j < 2; ++j) (ans += f[p][i][j]) %= P;\n  wr(ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nconst long long N = 57;\nlong long n, p;\nlong long t[N];\nlong long kom[N][N];\nlong long par[N][2];\nlong long dp[N][2][N][N];\nlong long pot[N];\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(NULL);\n  cin >> n >> p;\n  pot[0] = 1;\n  for (long long i = 1; i <= n; ++i) {\n    cin >> t[i];\n    pot[i] = (1ll << i) % mod;\n  }\n  for (long long i = 0; i <= n; ++i) {\n    kom[i][0] = 1;\n  }\n  for (long long i = 1; i <= n; ++i) {\n    for (long long j = 1; j <= i; ++j) {\n      kom[i][j] = (kom[i - 1][j] + kom[i - 1][j - 1]) % mod;\n    }\n  }\n  for (long long i = 0; i <= n; ++i) {\n    for (long long j = 0; j <= n; ++j) {\n      par[i][j % 2] += kom[i][j];\n      par[i][j % 2] %= mod;\n    }\n  }\n  dp[0][0][0][0] = 1;\n  for (long long i = 1; i <= n; ++i) {\n    for (long long x = 0; x < 2; ++x) {\n      for (long long b = 0; b <= i - 1; ++b) {\n        for (long long c = 0; b + c <= i - 1; ++c) {\n          if (t[i] != 1) {\n            dp[i][x ^ 1][b + 1][c] +=\n                dp[i - 1][x][b][c] * par[c][0] % mod * pot[i - 1 - c] % mod;\n            dp[i][x ^ 1][b + 1][c] %= mod;\n            dp[i][x][b][c] +=\n                dp[i - 1][x][b][c] * par[c][1] % mod * pot[i - 1 - c] % mod;\n            dp[i][x][b][c] %= mod;\n          }\n          if (t[i] != 0) {\n            dp[i][x ^ 1][b][c + 1] +=\n                dp[i - 1][x][b][c] * par[b][0] % mod * pot[i - 1 - b] % mod;\n            dp[i][x ^ 1][b][c + 1] %= mod;\n            dp[i][x][b][c] +=\n                dp[i - 1][x][b][c] * par[b][1] % mod * pot[i - 1 - b] % mod;\n            dp[i][x][b][c] %= mod;\n          }\n        }\n      }\n    }\n  }\n  long long ans = 0;\n  for (long long i = 0; i <= n; ++i) {\n    for (long long j = 0; j <= n; ++j) {\n      ans += dp[n][p][i][j];\n      ans %= mod;\n    }\n  }\n  cout << ans << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <class T>\nvoid cxk(T& a, T b) {\n  a = a > b ? a : b;\n}\ntemplate <class T>\nvoid cnk(T& a, T b) {\n  a = a < b ? a : b;\n}\nlong long gi() {\n  long long x = 0, f = 1;\n  char ch = getchar();\n  while (!isdigit(ch)) f ^= ch == '-', ch = getchar();\n  while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();\n  return f ? x : -x;\n}\nint col[200010], f[200010][2][2][2], p2[400010];\nvoid inc(int& x, int y) {\n  x = x + y >= 1000000007 ? x + y - 1000000007 : x + y;\n}\nint main() {\n  int n = gi(), p = gi();\n  for (int i = 1; i <= n; ++i) col[i] = gi();\n  p2[0] = 1;\n  for (int i = 1; i <= n + n; ++i) p2[i] = 2 * p2[i - 1] % 1000000007;\n  f[1][0][0][0] = 1;\n  for (int i = 1; i <= n; ++i)\n    for (int j = 0; j < 2; ++j)\n      for (int k = 0; k < 2; ++k)\n        for (int l = 0; l < 2; ++l)\n          if (f[i][j][k][l]) {\n            if (col[i] != 1) {\n              inc(f[i + 1][1][k][!l],\n                  1ll * p2[i - 1 - !!k] * f[i][j][k][l] % 1000000007);\n              if (k)\n                inc(f[i + 1][j][k][l],\n                    1ll * p2[i - 2] * f[i][j][k][l] % 1000000007);\n            }\n            if (col[i] != 0) {\n              inc(f[i + 1][j][1][!l],\n                  1ll * p2[i - 1 - !!j] * f[i][j][k][l] % 1000000007);\n              if (j)\n                inc(f[i + 1][j][k][l],\n                    1ll * p2[i - 2] * f[i][j][k][l] % 1000000007);\n            }\n          }\n  int ans = 0;\n  for (int i = 0; i < 2; ++i)\n    for (int j = 0; j < 2; ++j) inc(ans, f[n + 1][i][j][p]);\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma warning(disable : 4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\nint IT_MAX = 1 << 18;\nconst long long MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst long long LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst double PI = acos(-1);\nconst double ERR = 1e-10;\nlong long dp[55][55][55];\nlong long tdp[55][55][55];\nlong long C[55][55];\nlong long F[55];\nlong long po2[55];\nlong long cnt[55][2];\nint main() {\n  int i, j, k, l, m;\n  for (i = 0; i <= 50; i++) {\n    C[i][0] = C[i][i] = 1;\n    for (j = 1; j < i; j++) C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;\n    for (j = 0; j <= i; j++) cnt[i][j % 2] = (cnt[i][j % 2] + C[i][j]) % MOD;\n  }\n  F[0] = 1;\n  for (i = 1; i <= 50; i++) F[i] = F[i - 1] * i % MOD;\n  po2[0] = 1;\n  for (i = 1; i <= 50; i++) po2[i] = po2[i - 1] * 2 % MOD;\n  dp[0][0][0] = 1;\n  int N, tus;\n  scanf(\"%d %d\", &N, &tus);\n  for (i = 1; i <= N; i++) {\n    int st = 0, en = 1;\n    int t;\n    scanf(\"%d\", &t);\n    if (t == 1) st = 1;\n    if (t == 0) en = 0;\n    for (k = 0; k < i; k++) {\n      for (l = 0; k + l < i; l++) {\n        m = i - 1 - k - l;\n        if (st == 0) {\n          long long c0 = cnt[l][1] * po2[k + m] % MOD;\n          long long c1 = cnt[l][0] * po2[k + m] % MOD;\n          dp[k + 1][l][m] += c1 * dp[k][l][m] % MOD;\n          dp[k][l][m + 1] += c0 * dp[k][l][m] % MOD;\n        }\n        if (en == 1) {\n          long long c0 = cnt[k][1] * po2[l + m] % MOD;\n          long long c1 = cnt[k][0] * po2[l + m] % MOD;\n          dp[k][l + 1][m] += c1 * dp[k][l][m] % MOD;\n          dp[k][l][m + 1] += c0 * dp[k][l][m] % MOD;\n        }\n      }\n    }\n    for (j = 0; j <= i; j++) {\n      for (k = 0; j + k <= i; k++) {\n        l = i - j - k;\n        dp[j][k][l] %= MOD;\n      }\n    }\n  }\n  long long ans = 0;\n  for (i = 0; i <= N; i++) {\n    for (j = 0; i + j <= N; j++) {\n      k = N - i - j;\n      if ((i + j) % 2 == tus) ans = (ans + dp[i][j][k]) % MOD;\n    }\n  }\n  return !printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = (int)1e9 + 7;\nconst int FFTMOD = 1007681537;\nconst int INF = (int)1e9;\nconst long long LINF = (long long)1e18;\nconst long double PI = acos((long double)-1);\nconst long double EPS = 1e-9;\ninline long long gcd(long long a, long long b) {\n  long long r;\n  while (b) {\n    r = a % b;\n    a = b;\n    b = r;\n  }\n  return a;\n}\ninline long long lcm(long long a, long long b) { return a / gcd(a, b) * b; }\ninline long long fpow(long long n, long long k, int p = MOD) {\n  long long r = 1;\n  for (; k; k >>= 1) {\n    if (k & 1) r = r * n % p;\n    n = n * n % p;\n  }\n  return r;\n}\ntemplate <class T>\ninline int chkmin(T& a, const T& val) {\n  return val < a ? a = val, 1 : 0;\n}\ntemplate <class T>\ninline int chkmax(T& a, const T& val) {\n  return a < val ? a = val, 1 : 0;\n}\ninline long long isqrt(long long k) {\n  long long r = sqrt(k) + 1;\n  while (r * r > k) r--;\n  return r;\n}\ninline long long icbrt(long long k) {\n  long long r = cbrt(k) + 1;\n  while (r * r * r > k) r--;\n  return r;\n}\ninline void addmod(int& a, int val, int p = MOD) {\n  if ((a = (a + val)) >= p) a -= p;\n}\ninline void submod(int& a, int val, int p = MOD) {\n  if ((a = (a - val)) < 0) a += p;\n}\ninline int mult(int a, int b, int p = MOD) { return (long long)a * b % p; }\ninline int inv(int a, int p = MOD) { return fpow(a, p - 2, p); }\ninline int sign(long double x) { return x < -EPS ? -1 : x > +EPS; }\ninline int sign(long double x, long double y) { return sign(x - y); }\nconst int maxn = 50 + 5;\nint n, p;\nint c[maxn];\nint f[maxn][maxn];\nint p2[maxn];\nint dp[maxn][maxn][maxn][2];\nint calc(int pos, int u, int v, int fa) {\n  if (pos == n) return fa == p;\n  int& res = dp[pos][u][v][fa];\n  if (~res) return res;\n  res = 0;\n  for (int i = (0); i < (2); ++i) {\n    int num = c[pos] == -1 || c[pos] == i;\n    if (!num) continue;\n    int ar[] = {u, v};\n    for (int j = (0); j < (ar[i ^ 1] + 1); ++j) {\n      int add = j + 1 & 1;\n      ar[i] += add;\n      int nfa = fa + j + 1 & 1;\n      addmod(res,\n             mult(p2[pos - ar[i ^ 1]],\n                  mult(f[j][ar[i ^ 1]], calc(pos + 1, ar[0], ar[1], nfa))));\n      ar[i] -= add;\n    }\n  }\n  return res;\n}\nvoid chemthan() {\n  for (int i = (0); i < (maxn); ++i) f[0][i] = 1;\n  for (int i = (1); i < (maxn); ++i)\n    for (int j = (1); j < (maxn); ++j)\n      f[i][j] = (f[i][j - 1] + f[i - 1][j - 1]) % MOD;\n  for (int i = (0); i < (maxn); ++i) p2[i] = fpow(2, i);\n  cin >> n >> p;\n  for (int i = (0); i < (n); ++i) cin >> c[i];\n  memset(dp, -1, sizeof(dp));\n  cout << calc(0, 0, 0, 0) << \"\\n\";\n}\nint main(int argc, char* argv[]) {\n  ios_base::sync_with_stdio(0), cin.tie(0);\n  if (argc > 1) {\n    assert(freopen(argv[1], \"r\", stdin));\n  }\n  if (argc > 2) {\n    assert(freopen(argv[2], \"wb\", stdout));\n  }\n  chemthan();\n  cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N, P;\nsigned long long dp[51][51][51][51];\nsigned long long p2[51];\nconst int CN = 101;\nsigned long long C[CN][CN];\nsigned long long CS[CN][2];\nsigned long long mo = 1000000007;\nint col[51];\nvoid solve() {\n  int i, j, k, l, r, x, y;\n  string s;\n  for (i = 0; i < (CN); i++)\n    for (j = 0; j <= i; j++) {\n      C[i][j] = (j == 0 || j == i) ? 1 : (C[i - 1][j - 1] + C[i - 1][j]) % mo;\n      (CS[i][j % 2] += C[i][j]) %= mo;\n    }\n  p2[0] = 1;\n  for (i = 0; i < (50); i++) p2[i + 1] = p2[i] * 2 % mo;\n  cin >> N >> P;\n  for (i = 0; i < (N); i++) cin >> col[i];\n  dp[0][0][0][0] = 1;\n  signed long long ret = 0;\n  for (int b0 = 0; b0 <= N; b0++)\n    for (int b1 = 0; b1 <= N; b1++)\n      for (int w0 = 0; w0 <= N; w0++)\n        for (int w1 = 0; b0 + b1 + w0 + w1 <= N; w1++) {\n          signed long long d = dp[b0][b1][w0][w1];\n          int done = b0 + b1 + w0 + w1;\n          if (col[done] == 0 || col[done] == -1) {\n            signed long long pat = p2[b0 + b1 + w1];\n            (dp[b0 + 1][b1][w0][w1] += d * pat % mo * CS[w0][0] % mo) %= mo;\n            (dp[b0][b1 + 1][w0][w1] += d * pat % mo * CS[w0][1] % mo) %= mo;\n          }\n          if (col[done] == 1 || col[done] == -1) {\n            signed long long pat = p2[b1 + w0 + w1];\n            (dp[b0][b1][w0 + 1][w1] += d * pat % mo * CS[b0][0] % mo) %= mo;\n            (dp[b0][b1][w0][w1 + 1] += d * pat % mo * CS[b0][1] % mo) %= mo;\n          }\n          if (b0 + b1 + w0 + w1 == N && (b0 + w0) % 2 == P)\n            (ret += dp[b0][b1][w0][w1]) %= mo;\n        }\n  cout << ret % mo << endl;\n}\nint main(int argc, char** argv) {\n  string s;\n  int i;\n  if (argc == 1) ios::sync_with_stdio(false), cin.tie(0);\n  for (i = 0; i < (argc - 1); i++) s += argv[i + 1], s += '\\n';\n  for (i = 0; i < (s.size()); i++) ungetc(s[s.size() - 1 - i], stdin);\n  cout.tie(0);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nstatic char s[1 << 20 | 1] = {0}, *p1 = s, *p2 = s;\ninline char gc() {\n  return (p1 == p2) && (p2 = (p1 = s) + fread(s, 1, 1 << 20, stdin), p1 == p2)\n             ? EOF\n             : *(p1++);\n}\ninline int read() {\n  int ret = 0;\n  bool flag = 0;\n  char c = gc();\n  while ((c < '0') | (c > '9')) flag ^= !(c ^ '-'), c = gc();\n  while ((c >= '0') & (c <= '9'))\n    ret = (ret << 1) + (ret << 3) + (c ^ '0'), c = gc();\n  return flag ? -ret : ret;\n}\nconst int MaxN = 2e5 + 11;\nconst int P = 1e9 + 7;\nint Po[MaxN] = {1}, Dp[MaxN][2][2][2], A[MaxN];\nint n, ans;\ninline int Mul(int x, int y) { return (long long)x * y % P; }\ninline int Add(int x, int y) { return (x += y) >= P ? x - P : x; }\ninline void Inc(int& x, int y) { x += y, x -= (x >= P) ? P : 0; }\ninline int c(int i, int g, int opt) {\n  if ((!i) && g) return 0;\n  if (opt) {\n    if (!g) return 0;\n    return Po[i - 1];\n  }\n  if (!g) return Po[i];\n  return Po[i - 1];\n}\nint main(void) {\n  int opt;\n  n = read(), opt = read();\n  for (int i = 1; i <= n; ++i) Po[i] = Mul(Po[i - 1], 2), A[i] = read();\n  Po[n + 1] = 0;\n  Dp[0][0][0][0] = 1;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j <= 1; ++j)\n      for (int k = 0; k <= 1; ++k)\n        for (int h = 0; h <= 1; ++h) {\n          if (A[i + 1] != 1)\n            Inc(Dp[i + 1][j][k][h], Mul(Dp[i][j][k][h], Po[k ? i - 1 : n + 1])),\n                Inc(Dp[i + 1][1][k][h ^ 1],\n                    Mul(Dp[i][j][k][h], Po[k ? i - 1 : i]));\n          if (A[i + 1])\n            Inc(Dp[i + 1][j][k][h], Mul(Dp[i][j][k][h], Po[j ? i - 1 : n + 1])),\n                Inc(Dp[i + 1][j][1][h ^ 1],\n                    Mul(Dp[i][j][k][h], Po[j ? i - 1 : i]));\n        }\n  ans = Add(Add(Dp[n][0][0][opt], Dp[n][0][1][opt]),\n            Add(Dp[n][1][1][opt], Dp[n][1][0][opt]));\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 55;\nconst long long mo = 1e9 + 7;\nlong long n, p, kai[N], f[N][2][2][2], ans, jc[N];\ninline long long read() {\n  char c = getchar();\n  long long fu = 1, x = 0;\n  while (!isdigit(c)) {\n    if (c == '-') fu = -1;\n    c = getchar();\n  }\n  while (isdigit(c)) {\n    x = (x << 3) + (x << 1) + c - '0';\n    c = getchar();\n  }\n  return fu * x;\n}\nsigned main() {\n  n = read();\n  p = read();\n  for (long long i = 1; i <= n; i++) kai[i] = read();\n  f[0][0][0][0] = 1;\n  jc[0] = 1;\n  for (long long i = 1; i <= n; i++) jc[i] = jc[i - 1] * 2ll % mo;\n  for (long long i = 1; i <= n; i++) {\n    for (long long j = 0; j <= 1; j++)\n      for (long long k = 0; k <= 1; k++)\n        for (long long l = 0; l <= 1; l++) {\n          long long hu = f[i - 1][j][k][l];\n          if (kai[i] != 0) {\n            if (l) {\n              f[i][j][k][l] = (f[i][j][k][l] + hu * jc[i - 2] % mo) % mo;\n              f[i][j ^ 1][k | 1][l] =\n                  (f[i][j ^ 1][k | 1][l] + hu * jc[i - 2] % mo) % mo;\n            } else\n              f[i][j ^ 1][k | 1][l] =\n                  (f[i][j ^ 1][k | 1][l] + hu * jc[i - 1] % mo) % mo;\n          }\n          if (kai[i] != 1) {\n            if (k) {\n              f[i][j][k][l] = (f[i][j][k][l] + hu * jc[i - 2] % mo) % mo;\n              f[i][j ^ 1][k][l | 1] =\n                  (f[i][j ^ 1][k][l | 1] + hu * jc[i - 2] % mo) % mo;\n            } else\n              f[i][j ^ 1][k][l | 1] =\n                  (f[i][j ^ 1][k][l | 1] + hu * jc[i - 1] % mo) % mo;\n          }\n        }\n  }\n  for (long long i = 0; i <= 1; i++)\n    for (long long j = 0; j <= 1; j++) ans = (ans + f[n][p][i][j]) % mo;\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 60;\nconst int mo = (int)1e9 + 7;\nint n, p, a[N];\nlong long pw[N], f[N][N][N];\nint main() {\n  pw[0] = 1;\n  for (int i = 1; i < N; i++) pw[i] = pw[i - 1] * 2 % mo;\n  scanf(\"%d%d\", &n, &p);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", a + i);\n  f[0][0][0] = 1;\n  for (int i = 1; i <= n; i++)\n    for (int wb0 = 0; wb0 <= i - 1; wb0++)\n      for (int w1 = 0; w1 <= i - 1 - wb0; w1++) {\n        int b1 = i - 1 - wb0 - w1;\n        if (a[i] != 1) {\n          if (b1) {\n            (f[i][wb0][w1 + 1] +=\n             f[i - 1][wb0][w1] * pw[wb0 + w1 + b1 - 1] % mo) %= mo;\n            (f[i][wb0 + 1][w1] +=\n             f[i - 1][wb0][w1] * pw[wb0 + w1 + b1 - 1] % mo) %= mo;\n          } else {\n            (f[i][wb0][w1 + 1] += f[i - 1][wb0][w1] * pw[wb0 + w1] % mo) %= mo;\n          }\n        }\n        if (a[i] != 0) {\n          if (w1) {\n            (f[i][wb0][w1] += f[i - 1][wb0][w1] * pw[wb0 + b1 + w1 - 1] % mo) %=\n                mo;\n            (f[i][wb0 + 1][w1] +=\n             f[i - 1][wb0][w1] * pw[wb0 + b1 + w1 - 1] % mo) %= mo;\n          } else {\n            (f[i][wb0][w1] += f[i - 1][wb0][w1] * pw[wb0 + b1] % mo) %= mo;\n          }\n        }\n      }\n  long long ans = 0;\n  for (int wb0 = 0; wb0 <= n; wb0++)\n    for (int w1 = 0; w1 <= n - wb0; w1++) {\n      int b1 = n - wb0 - w1;\n      if ((w1 + b1) % 2 == p) (ans += f[n][wb0][w1]) %= mo;\n    }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = (int)1e9 + 7;\nint n, p, c[55], dp[55][55][55][55], nCk[55][55], sum[55][55], sum2[55];\nvoid add(int &x, int y) {\n  x += y, x %= mod;\n  if (x < 0) x += mod;\n}\nint main() {\n  for (int i = 0; i <= 50; ++i) {\n    nCk[i][i] = nCk[i][0] = 1;\n  }\n  for (int i = 2; i <= 50; ++i) {\n    for (int j = 1; j < i; ++j) {\n      nCk[i][j] = (nCk[i - 1][j - 1] + nCk[i - 1][j]) % mod;\n    }\n  }\n  for (int i = 0; i <= 50; ++i) {\n    for (int j = 0; j <= 50; ++j) {\n      sum[i][j] = ((j > 1 ? sum[i][j - 2] : 0) + nCk[i][j]) % mod;\n    }\n    sum2[i] = (i == 0 ? 1 : 2ll * sum2[i - 1] % mod);\n  }\n  scanf(\"%d%d\", &n, &p);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", &c[i]);\n  if (c[1] == -1)\n    dp[1][1][0][0] = dp[1][0][0][1] = 1;\n  else if (c[1] == 0)\n    dp[1][1][0][0] = 1;\n  else\n    dp[1][0][0][1] = 1;\n  for (int i = 2; i <= n; ++i) {\n    for (int bo = 0; bo <= n; ++bo) {\n      for (int be = 0; be <= n; ++be) {\n        for (int wo = 0; wo <= n; ++wo) {\n          if (bo + be + wo > i) break;\n          int we = i - bo - be - wo;\n          if (c[i] == -1 || c[i] == 0) {\n            if (bo > 0) {\n              int tmp =\n                  1ll * dp[i - 1][bo - 1][be][wo] * sum[wo][wo - wo % 2] % mod;\n              tmp = 1ll * tmp * sum2[we + be + bo - 1] % mod;\n              add(dp[i][bo][be][wo], tmp);\n            }\n            if (be > 0 && wo > 0) {\n              int tmp = 01ll * dp[i - 1][bo][be - 1][wo] *\n                        sum[wo][wo - (wo % 2 == 0)] % mod;\n              tmp = 1ll * tmp * sum2[we + bo + be - 1] % mod;\n              add(dp[i][bo][be][wo], tmp);\n            }\n          }\n          if (c[i] == -1 || c[i] == 1) {\n            if (wo > 0) {\n              int tmp =\n                  1ll * dp[i - 1][bo][be][wo - 1] * sum[bo][bo - bo % 2] % mod;\n              tmp = 1ll * tmp * sum2[be + we + wo - 1] % mod;\n              add(dp[i][bo][be][wo], tmp);\n            }\n            if (we > 0 && bo > 0) {\n              int tmp = 1ll * dp[i - 1][bo][be][wo] *\n                        sum[bo][bo - (bo % 2 == 0)] % mod;\n              tmp = 1ll * tmp * sum2[be + wo + we - 1] % mod;\n              add(dp[i][bo][be][wo], tmp);\n            }\n          }\n        }\n      }\n    }\n  }\n  int ans = 0;\n  for (int bo = 0; bo <= n; ++bo) {\n    for (int be = 0; be <= n; ++be) {\n      for (int wo = 0; wo <= n; ++wo) {\n        if ((bo + wo) % 2 == p) {\n          add(ans, dp[n][bo][be][wo]);\n        }\n      }\n    }\n  }\n  printf(\"%d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 1e9 + 7;\nint dp[2][52][52], n, p, power[51];\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= M) a -= M;\n}\nint main() {\n  scanf(\"%d%d\", &n, &p);\n  power[0] = 1;\n  for (int i = 1; i <= 50; i++) power[i] = (power[i - 1] << 1) % M;\n  dp[0][0][0] = 1;\n  for (int u = 0, col; u < n; u++) {\n    scanf(\"%d\", &col);\n    int at = u & 1, to = !at;\n    for (int wo = 0; wo <= u; wo++)\n      for (int bo = 0; bo + wo <= u; bo++) {\n        int &ref = dp[at][wo][bo], even = u - wo - bo;\n        if (col) {\n          int val = power[even + wo] * 1LL * power[max(0, bo - 1)] % M;\n          if (bo) add(dp[to][wo][bo], ref * 1LL * val % M);\n          add(dp[to][wo + 1][bo], ref * 1LL * val % M);\n        }\n        if (col != 1) {\n          int val = power[even + bo] * 1LL * power[max(0, wo - 1)] % M;\n          if (wo) add(dp[to][wo][bo], ref * 1LL * val % M);\n          add(dp[to][wo][bo + 1], ref * 1LL * val % M);\n        }\n        ref = 0;\n      }\n  }\n  int ans = 0;\n  for (int i = 0; i <= n; i++)\n    for (int j = 0; j + i <= n; j++)\n      if (((i + j) & 1) == p) add(ans, dp[n & 1][i][j]);\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1000000007;\nvoid sets() {}\nlong long f[60][4][3][3], a[60], mi[60], n, m, ans;\nint main() {\n  cin >> n >> m;\n  for (long long i = 1; i <= n; i++) {\n    scanf(\"%lld\", &a[i]);\n  }\n  f[0][0][0][0] = 1;\n  mi[0] = 1;\n  for (long long i = 1; i <= n; i++) mi[i] = (mi[i - 1] * 2) % mod;\n  for (long long i = 1; i <= n; i++) {\n    for (long long _ = 0; _ <= 1; _++) {\n      for (long long bl = 0; bl <= 1; bl++) {\n        for (long long wi = 0; wi <= 1; wi++) {\n          if (a[i] != 1) {\n            if (bl) {\n              f[i][_][bl][wi] =\n                  (f[i][_][bl][wi] + f[i - 1][_][bl][wi] * mi[i - 2] % mod) %\n                  mod;\n              f[i][_ ^ 1][bl][wi | 1] =\n                  (f[i][_ ^ 1][bl][wi | 1] +\n                   f[i - 1][_][bl][wi] * mi[i - 2] % mod) %\n                  mod;\n            } else\n              f[i][_ ^ 1][bl][wi | 1] =\n                  (f[i][_ ^ 1][bl][wi | 1] +\n                   f[i - 1][_][bl][wi] * mi[i - 1] % mod) %\n                  mod;\n          }\n          if (a[i] != 0) {\n            if (wi) {\n              f[i][_][bl][wi] =\n                  (f[i][_][bl][wi] + f[i - 1][_][bl][wi] * mi[i - 2] % mod) %\n                  mod;\n              f[i][_ ^ 1][bl | 1][wi] =\n                  (f[i][_ ^ 1][bl | 1][wi] +\n                   f[i - 1][_][bl][wi] * mi[i - 2] % mod) %\n                  mod;\n            } else\n              f[i][_ ^ 1][bl | 1][wi] =\n                  (f[i][_ ^ 1][bl | 1][wi] +\n                   f[i - 1][_][bl][wi] * mi[i - 1] % mod) %\n                  mod;\n          }\n        }\n      }\n    }\n  }\n  for (long long bl = 0; bl <= 1; bl++) {\n    for (long long wi = 0; wi <= 1; wi++) {\n      ans = (ans + f[n][m][bl][wi]) % mod;\n    }\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int N = 55;\nconst ll mod = 1e9 + 7;\nll A[N], bin_pows[N], dp[N][N][N];\nll sumC(int n, int p) {\n  if (n == 0) return p ? 0 : 1;\n  return bin_pows[n - 1];\n}\nll getDP(int i, int ow, int ob) {\n  if (i < ow + ob || ow < 0 || ob < 0) return 0;\n  return dp[i][ow][ob];\n}\ninline ll sum(ll a, ll b) { return (a + b) % mod; }\ninline ll mul(ll a, ll b) { return (a * b) % mod; }\nvoid solve() {\n  int n, p;\n  scanf(\"%d%d\", &n, &p);\n  for (int i = 1; i <= n; ++i) scanf(\"%lld\", A + i);\n  bin_pows[0] = 1;\n  for (int i = 1; i < N; ++i) bin_pows[i] = (2 * bin_pows[i - 1]) % mod;\n  dp[0][0][0] = 1;\n  ll ans = 0;\n  for (int i = 1; i <= n; ++i) {\n    for (int ow = 0; ow <= i; ++ow) {\n      for (int ob = 0; ob <= i - ow; ++ob) {\n        if (A[i] == 0 || A[i] == -1) {\n          ll a = mul(getDP(i - 1, ow, ob), sumC(ob, 1));\n          ll b = mul(getDP(i - 1, ow - 1, ob), sumC(ob, 0));\n          dp[i][ow][ob] += mul(bin_pows[i - ob - 1], sum(a, b));\n        }\n        if (A[i] == 1 || A[i] == -1) {\n          ll a = mul(getDP(i - 1, ow, ob), sumC(ow, 1));\n          ll b = mul(getDP(i - 1, ow, ob - 1), sumC(ow, 0));\n          dp[i][ow][ob] += mul(bin_pows[i - ow - 1], sum(a, b));\n        }\n        if (i == n && (ow + ob) % 2 == p) ans = sum(ans, dp[i][ow][ob]);\n      }\n    }\n  }\n  printf(\"%lld\", ans);\n}\nint main() {\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 59, Mod = 1e9 + 7;\nint n, p, tot, C[N], Pw[N], dp[N][N][N];\nint main() {\n  scanf(\"%d%d\", &n, &p);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &C[i]);\n  dp[n + 1][0][0] = Pw[0] = 1;\n  for (int i = 1; i < N; i++) Pw[i] = (Pw[i - 1] + Pw[i - 1]) % Mod;\n  for (int i = n; i; i--)\n    for (int b = 0; b <= n - i + 1; b++)\n      for (int w = 0; w + b <= n - i + 1; w++) {\n        if (C[i] == -1 || C[i] == 0) {\n          if (b)\n            dp[i][b][w] = (dp[i][b][w] +\n                           dp[i + 1][b - 1][w] * 1ll * Pw[n - i - (w > 0)]) %\n                          Mod;\n          if (w)\n            dp[i][b][w] =\n                (dp[i][b][w] + dp[i + 1][b][w] * 1ll * Pw[n - i - 1]) % Mod;\n        }\n        if (C[i] == -1 || C[i] == 1) {\n          if (w)\n            dp[i][b][w] = (dp[i][b][w] +\n                           dp[i + 1][b][w - 1] * 1ll * Pw[n - i - (b > 0)]) %\n                          Mod;\n          if (b)\n            dp[i][b][w] =\n                (dp[i][b][w] + dp[i + 1][b][w] * 1ll * Pw[n - i - 1]) % Mod;\n        }\n      }\n  for (int i = 0; i <= n; i++)\n    for (int j = 0; j <= n; j++)\n      if ((i + j) % 2 == p) tot = (tot + dp[1][i][j]) % Mod;\n  return !printf(\"%d\", tot);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 50 + 2;\nconst int maxm = 2 + 2;\nconst int mod = 1e9 + 7;\nint n, p;\nint a[maxn], _2[maxn];\nint dp[maxn][maxm][maxm][maxm];\nvoid DP() {\n  dp[0][0][0][0] = 1;\n  for (int i = 1; i <= n; i++)\n    for (int j = 0; j <= 1; j++)\n      for (int ob = 0; ob <= 1; ob++)\n        for (int ow = 0; ow <= 1; ow++) {\n          int tmp = dp[i - 1][j][ob][ow];\n          if (a[i] != 0) {\n            if (ob) {\n              dp[i][j][ob][ow] =\n                  (dp[i][j][ob][ow] + 1LL * tmp * _2[i - 2]) % mod;\n              dp[i][j ^ 1][ob][ow | 1] =\n                  (dp[i][j ^ 1][ob][ow | 1] + 1LL * tmp * _2[i - 2]) % mod;\n            } else\n              dp[i][j ^ 1][ob][ow | 1] =\n                  (dp[i][j ^ 1][ob][ow | 1] + 1LL * tmp * _2[i - 1]) % mod;\n          }\n          if (a[i] != 1) {\n            if (ow) {\n              dp[i][j][ob][ow] =\n                  (dp[i][j][ob][ow] + 1LL * tmp * _2[i - 2]) % mod;\n              dp[i][j ^ 1][ob | 1][ow] =\n                  (dp[i][j ^ 1][ob | 1][ow] + 1LL * tmp * _2[i - 2]) % mod;\n            } else\n              dp[i][j ^ 1][ob | 1][ow] =\n                  (dp[i][j ^ 1][ob | 1][ow] + 1LL * tmp * _2[i - 1]) % mod;\n          }\n        }\n}\nvoid init() {\n  _2[0] = 1;\n  for (int i = 1; i <= n; i++) _2[i] = (_2[i - 1] << 1) % mod;\n}\nint main() {\n  scanf(\"%d%d\", &n, &p);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  init();\n  DP();\n  int ans = 0;\n  for (int ob = 0; ob <= 1; ob++)\n    for (int ow = 0; ow <= 1; ow++) ans = (ans + dp[n][p][ob][ow]) % mod;\n  printf(\"%d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long dp[51][51][51][51];\nint n, p, c[51];\nlong long even[51], odd[51], pascal[51][51], p2[51];\nvoid init() {\n  p2[0] = 1;\n  for (int i = 1; (i) <= int(51 - 1); (i)++)\n    p2[i] = (2 * p2[i - 1]) % 1000000007;\n  for (int n = 0; (n) < int(51); (n)++)\n    for (int k = 0; (k) < int(51); (k)++) {\n      if (k > n)\n        pascal[n][k] = 0;\n      else if (k == 0 || k == n)\n        pascal[n][k] = 1;\n      else\n        pascal[n][k] = (pascal[n - 1][k] + pascal[n - 1][k - 1]) % 1000000007;\n    }\n  for (int n = 0; (n) < int(51); (n)++) {\n    even[n] = 0;\n    odd[n] = 0;\n    for (int k = 0; (k) < int(n + 1); (k)++) {\n      if (k % 2 == 0)\n        even[n] = (even[n] + pascal[n][k]) % 1000000007;\n      else\n        odd[n] = (odd[n] + pascal[n][k]) % 1000000007;\n    }\n  }\n}\nint main() {\n  init();\n  scanf(\"%d %d\", &n, &p);\n  for (int i = 1; (i) <= int(n); (i)++) scanf(\"%d\", &c[i]);\n  long long ans = 0;\n  for (int i = 0; i <= n; i++)\n    for (int ew = 0; ew <= i; ew++)\n      for (int ow = 0; ew + ow <= i; ow++)\n        for (int eb = 0; ew + ow + eb <= i; eb++) {\n          int ob = i - ew - ow - eb;\n          if (i == 0) {\n            dp[i][ew][ow][eb] = 1;\n            continue;\n          }\n          dp[i][ew][ow][eb] = 0;\n          if (c[i] == 1 || c[i] == -1) {\n            if (ow > 0) {\n              dp[i][ew][ow][eb] += (dp[i - 1][ew][ow - 1][eb] *\n                                    p2[ow + ew - 1 + eb] % 1000000007) *\n                                   even[ob] % 1000000007;\n              dp[i][ew][ow][eb] %= 1000000007;\n            }\n            if (ew > 0) {\n              dp[i][ew][ow][eb] += (dp[i - 1][ew - 1][ow][eb] *\n                                    p2[ow + ew - 1 + eb] % 1000000007) *\n                                   odd[ob] % 1000000007;\n              dp[i][ew][ow][eb] %= 1000000007;\n            }\n          }\n          if (c[i] == 0 || c[i] == -1) {\n            if (ob > 0) {\n              dp[i][ew][ow][eb] +=\n                  (dp[i - 1][ew][ow][eb] * p2[ob + eb - 1 + ew] % 1000000007) *\n                  even[ow] % 1000000007;\n              dp[i][ew][ow][eb] %= 1000000007;\n            }\n            if (eb > 0) {\n              dp[i][ew][ow][eb] += (dp[i - 1][ew][ow][eb - 1] *\n                                    p2[ob + eb - 1 + ew] % 1000000007) *\n                                   odd[ow] % 1000000007;\n              dp[i][ew][ow][eb] %= 1000000007;\n            }\n          }\n          if (i == n && (ob + ow) % 2 == p)\n            ans = (ans + dp[i][ew][ow][eb]) % 1000000007;\n        }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline void read(T &x) {\n  x = 0;\n  char c = getchar();\n  int f = 1;\n  while (!isdigit(c)) {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (isdigit(c)) x = x * 10 - '0' + c, c = getchar();\n  x *= f;\n}\nconst int N = 55, mod = 1e9 + 7;\nint c[N][N], sum[N][2], dp[N][N][N][N], pw[N], n, a[N];\nint main() {\n  int p;\n  read(n), read(p);\n  for (int i = 1; i <= n; ++i) read(a[i]);\n  for (int i = 0; i <= n; ++i)\n    for (int j = 0; j <= i; ++j)\n      c[i][j] = j ? (c[i - 1][j - 1] + c[i - 1][j]) % mod : 1;\n  for (int i = 0; i <= n; ++i)\n    for (int j = 0; j <= i; ++j) (sum[i][j & 1] += c[i][j]) %= mod;\n  pw[0] = 1;\n  for (int i = 1; i <= n; ++i) pw[i] = pw[i - 1] * 2 % mod;\n  dp[0][0][0][0] = 1;\n  for (int i = 0; i < n; ++i)\n    for (int w = 0; w <= i; ++w)\n      for (int ow = 0; ow <= w; ++ow)\n        for (int ob = 0; w + ob <= i; ++ob)\n          if (dp[i][w][ow][ob]) {\n            if (a[i + 1] == 0 || a[i + 1] == -1) {\n              (dp[i + 1][w + 1][ow + 1][ob] += dp[i][w][ow][ob] *\n                                               (long long)pw[i - ob] % mod *\n                                               sum[ob][0] % mod) %= mod;\n              (dp[i + 1][w + 1][ow][ob] += dp[i][w][ow][ob] *\n                                           (long long)pw[i - ob] % mod *\n                                           sum[ob][1] % mod) %= mod;\n            }\n            if (a[i + 1] == 1 || a[i + 1] == -1) {\n              (dp[i + 1][w][ow][ob + 1] += dp[i][w][ow][ob] *\n                                           (long long)pw[i - ow] % mod *\n                                           sum[ow][0] % mod) %= mod;\n              (dp[i + 1][w][ow][ob] += dp[i][w][ow][ob] *\n                                       (long long)pw[i - ow] % mod *\n                                       sum[ow][1] % mod) %= mod;\n            }\n          }\n  int ans = 0;\n  for (int w = 0; w <= n; ++w)\n    for (int ow = 0; ow <= w; ++ow)\n      for (int ob = (p ^ (ow & 1)) ? 1 : 0; ob + w <= n; ob += 2)\n        (ans += dp[n][w][ow][ob]) %= mod;\n  printf(\"%d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = (long long)1e9 + 7;\nint n;\nint c[50];\nlong long dp[50][51][51][2];\nlong long f(int i, int w, int b, int p) {\n  if (w < 0 || b < 0 || w + b > n - i) return 0;\n  if (i == n) return !(w | b | p);\n  assert(n <= 50 && n >= 0 && i >= 0 && i < n && p >= 0 && p < 2);\n  assert(c[i] >= -1 && c[i] <= 1);\n  long long &res = dp[i][w][b][p];\n  if (res != -1) return res;\n  res = 0;\n  if (c[i] != 1) {\n    res += f(i + 1, w - 0, b, +p) *\n           (n - (i + 1) - b < 0 ? 0 : (1ll << (n - (i + 1) - b)) % mod) % mod *\n           (b ? (1ll << (b - 1)) % mod : 0) % mod;\n    res += f(i + 1, w - 1, b, !p) *\n           (n - (i + 1) - b < 0 ? 0 : (1ll << (n - (i + 1) - b)) % mod) % mod *\n           (b ? (1ll << (b - 1)) % mod : 1) % mod;\n  }\n  if (c[i] != 0) {\n    res += f(i + 1, w, b - 0, +p) *\n           (n - (i + 1) - w < 0 ? 0 : (1ll << (n - (i + 1) - w)) % mod) % mod *\n           (w ? (1ll << (w - 1)) % mod : 0) % mod;\n    res += f(i + 1, w, b - 1, !p) *\n           (n - (i + 1) - w < 0 ? 0 : (1ll << (n - (i + 1) - w)) % mod) % mod *\n           (w ? (1ll << (w - 1)) % mod : 1) % mod;\n  }\n  assert(res <= 4ll * mod);\n  return res %= mod;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int p;\n  cin >> n >> p;\n  for (int i = 0; i < n; ++i) cin >> c[i];\n  memset(dp, -1, sizeof dp);\n  long long res = 0;\n  for (int w = 0; w <= n; ++w)\n    for (int b = 0; b <= n; ++b) res = (res + f(0, w, b, p)) % mod;\n  cout << res;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, p, w[60];\nlong long f[60][60][60][60], mi[60], u[60], v[60], C[60][60];\nint main() {\n  mi[0] = 1;\n  for (int i = 0; i <= 50; i++) {\n    if (i > 0) mi[i] = (mi[i - 1] * 2) % 1000000007;\n    C[i][0] = 1;\n    v[i] = 1;\n    for (int j = 1; j <= i; j++) {\n      C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % 1000000007;\n      if (j % 2 == 0) v[i] = (v[i] + C[i][j]) % 1000000007;\n      if (j % 2 == 1) u[i] = (u[i] + C[i][j]) % 1000000007;\n    }\n  }\n  cin >> n >> p;\n  for (int i = 1; i <= n; i++) cin >> w[i];\n  f[0][0][0][0] = 1;\n  for (int i = 0; i < n; i++)\n    for (int a = 0; a <= i; a++)\n      for (int b = 0; b <= i - a; b++)\n        for (int c = 0; c <= i - a - b; c++) {\n          int d = i - a - b - c;\n          if (w[i + 1] == 0 || w[i + 1] == -1) {\n            if (d > 0)\n              f[i + 1][a + 1][b][c] =\n                  (f[i + 1][a + 1][b][c] +\n                   ((f[i][a][b][c] * mi[a + b + c]) % 1000000007 * u[d]) %\n                       1000000007) %\n                  1000000007;\n            f[i + 1][a][b + 1][c] =\n                (f[i + 1][a][b + 1][c] +\n                 ((f[i][a][b][c] * mi[a + b + c]) % 1000000007 * v[d]) %\n                     1000000007) %\n                1000000007;\n          }\n          if (w[i + 1] == 1 || w[i + 1] == -1) {\n            if (b > 0)\n              f[i + 1][a][b][c + 1] =\n                  (f[i + 1][a][b][c + 1] +\n                   ((f[i][a][b][c] * mi[a + c + d]) % 1000000007 * u[b])) %\n                  1000000007;\n            f[i + 1][a][b][c] =\n                (f[i + 1][a][b][c] +\n                 ((f[i][a][b][c] * mi[a + c + d]) % 1000000007 * v[b]) %\n                     1000000007) %\n                1000000007;\n          }\n        }\n  long long ans = 0;\n  for (int a = 0; a <= n; a++)\n    for (int b = 0; b <= n - a; b++)\n      for (int c = 0; c <= n - a - b; c++) {\n        int d = n - a - b - c;\n        if (p == 0) {\n          if ((b + d) % 2 == 0) ans = (ans + f[n][a][b][c]) % 1000000007;\n        } else if ((b + d) % 2 == 1)\n          ans = (ans + f[n][a][b][c]) % 1000000007;\n      }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst bool print = false;\nconst int N = 57;\nconst long long mod = 1e9 + 7;\nint n, p;\nint in[N];\nlong long DP[N][N][N][N];\nlong long add(long long &a, long long b) { a = (a + b) % mod; }\nvoid modulo(long long &a) { a %= mod; }\nint main() {\n  scanf(\"%d%d\", &n, &p);\n  for (int i = (1); i <= (n); i++) scanf(\"%d\", &in[i]);\n  DP[0][0][0][0] = 1;\n  long long res = 0;\n  for (int i = (0); i <= (n); i++)\n    for (int j = (0); j <= (n); j++)\n      for (int l = (0); l <= (n); l++)\n        for (int k = (0); k <= (n); k++) {\n          int s = i + j + l + k;\n          if (s == n && ((j + k) % 2) == p) add(res, DP[i][j][l][k]);\n          if (s >= n) continue;\n          s++;\n          for (int f = (0); f <= (1); f++) {\n            if (in[s] == (f ^ 1)) continue;\n            if (DP[i][j][l][k])\n              if (!f) {\n                long long chan = (1LL << l) * (((1LL << k) + 1) / 2);\n                long long stay = (1LL << l) * ((1LL << k) / 2);\n                modulo(chan);\n                modulo(stay);\n                chan *= (1LL << (i + j));\n                stay *= (1LL << (i + j));\n                modulo(chan);\n                modulo(stay);\n                add(DP[i + 1][j][l][k], DP[i][j][l][k] * stay);\n                add(DP[i][j + 1][l][k], DP[i][j][l][k] * chan);\n              } else {\n                long long chan = (1LL << i) * (((1LL << j) + 1) / 2);\n                long long stay = (1LL << i) * ((1LL << j) / 2);\n                modulo(chan);\n                modulo(stay);\n                chan *= (1LL << (l + k));\n                stay *= (1LL << (l + k));\n                modulo(chan);\n                modulo(stay);\n                add(DP[i][j][l + 1][k], DP[i][j][l][k] * stay);\n                add(DP[i][j][l][k + 1], DP[i][j][l][k] * chan);\n              }\n          }\n        }\n  printf(\"%lld\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace thecold {\ninline int read() {\n  int res = 0;\n  bool flag = false;\n  char c = getchar();\n  while (!isdigit(c)) flag = (c == '-'), c = getchar();\n  while (isdigit(c)) res = res * 10 + (c ^ 48), c = getchar();\n  return !flag ? res : -res;\n}\nconst int Max_n = 2e5 + 5;\nconst int jzp = 1e9 + 7;\ninline void ADD(int &x, const int y) {\n  x += y;\n  if (x >= jzp) x -= jzp;\n}\ninline int add(const int x, const int y) {\n  int ret = x + y;\n  if (ret >= jzp) ret -= jzp;\n  return ret;\n}\nint f[Max_n][2][2][2], h[Max_n], n;\nlong long mi[Max_n], type;\ninline void main() {\n  n = read();\n  type = read();\n  mi[0] = 1;\n  for (int i = 1; i <= n; ++i) mi[i] = 2ll * mi[i - 1] % jzp;\n  for (int i = 1; i <= n; ++i) h[i] = read();\n  f[0][0][0][0] = 1;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < 2; ++j)\n      for (int k = 0; k < 2; ++k)\n        for (int l = 0; l < 2; ++l)\n          if (f[i][j][k][l]) {\n            if (h[i + 1] != 0) {\n              if (!j)\n                ADD(f[i + 1][0][1][l ^ 1], mi[i] * f[i][j][k][l] % jzp);\n              else\n                ADD(f[i + 1][j][1][l ^ 1], mi[i - 1] * f[i][j][k][l] % jzp),\n                    ADD(f[i + 1][j][k][l], mi[i - 1] * f[i][j][k][l] % jzp);\n            }\n            if (h[i + 1] != 1) {\n              if (!k)\n                ADD(f[i + 1][1][0][l ^ 1], mi[i] * f[i][j][k][l] % jzp);\n              else\n                ADD(f[i + 1][1][k][l ^ 1], mi[i - 1] * f[i][j][k][l] % jzp),\n                    ADD(f[i + 1][j][k][l], mi[i - 1] * f[i][j][k][l] % jzp);\n            }\n          }\n  int ans = 0;\n  for (int j = 0; j < 2; ++j)\n    for (int k = 0; k < 2; ++k) ADD(ans, f[n][j][k][type]);\n  printf(\"%d\\n\", ans);\n}\n}  // namespace thecold\nint main() {\n  thecold::main();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int _ML = 228;\nconst char _inpf[] = \"\";\nconst char _outf[] = \"\";\n#pragma GCC optimize(\"O3,no-stack-protector\")\nusing namespace std;\nconst double PI = 3.14159265358979323846;\nmt19937 rd(228);\ntemplate <class T, class U>\ninline ostream &operator<<(ostream &, const pair<T, U> &);\ntemplate <class T, class U>\ninline istream &operator>>(istream &, pair<T, U> &);\ntemplate <class T>\ninline ostream &operator<<(ostream &, const vector<T> &);\ntemplate <class T>\ninline istream &operator>>(istream &, vector<T> &);\ntemplate <class T>\ninline ostream &operator<<(ostream &, const set<T> &);\ntemplate <class T>\ninline ostream &operator<<(ostream &, const multiset<T> &);\ntemplate <class T>\ninline ostream &operator<<(ostream &, const unordered_set<T> &);\ntemplate <class T>\ninline ostream &operator<<(ostream &, const unordered_multiset<T> &);\ntemplate <class T, class U>\ninline ostream &operator<<(ostream &, const map<T, U> &);\ntemplate <class T, class U>\ninline ostream &operator<<(ostream &, const unordered_map<T, U> &);\nconst int N = 52;\nconst int M = 1000 * 1000 * 1000 + 7;\nint dp[2][N][N][N][N];\nint a[N];\nint pww[N];\ninline int pw2(int first) {\n  if (first == -1) {\n    return 1;\n  }\n  return pww[first];\n}\ninline int mul(int a, int b) { return (int)((long long)a * b % M); }\ninline void addeq(int &a, int b) { a = (a + b) % M; }\ninline void _main_function() {\n  pww[0] = 1;\n  for (int i = 1; i < N; ++i) {\n    pww[i] = mul(pww[i - 1], 2);\n  }\n  int n, p;\n  cin >> n >> p;\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n  }\n  dp[1][0][0][0][0] = 1;\n  for (int i = 0; i < n; ++i) {\n    int cur = (i & 1);\n    int lst = (~i & 1);\n    memset(dp[cur], 0, sizeof dp[cur]);\n    for (int be = 0; be <= i; ++be) {\n      for (int bo = 0; bo <= i; ++bo) {\n        for (int we = 0; we <= i; ++we) {\n          for (int wo = 0; wo <= i; ++wo) {\n            if (dp[lst][be][bo][we][wo] == 0) {\n              continue;\n            }\n            if (a[i] != 1) {\n              int value = mul(pw2(be + bo + we), pw2(wo - 1));\n              addeq(dp[cur][be][bo + 1][we][wo],\n                    mul(dp[lst][be][bo][we][wo], value));\n              if (wo != 0) {\n                addeq(dp[cur][be + 1][bo][we][wo],\n                      mul(dp[lst][be][bo][we][wo], value));\n              }\n            }\n            if (a[i] != 0) {\n              int value = mul(pw2(we + wo + be), pw2(bo - 1));\n              if (bo != 0) {\n                addeq(dp[cur][be][bo][we + 1][wo],\n                      mul(dp[lst][be][bo][we][wo], value));\n              }\n              addeq(dp[cur][be][bo][we][wo + 1],\n                    mul(dp[lst][be][bo][we][wo], value));\n            }\n          }\n        }\n      }\n    }\n  }\n  int cur = ((n - 1) & 1);\n  int ans = 0;\n  for (int be = 0; be <= n; ++be) {\n    for (int bo = 0; bo <= n; ++bo) {\n      for (int we = 0; we <= n; ++we) {\n        for (int wo = 0; wo <= n; ++wo) {\n          if (((bo + wo) & 1) == p) {\n            addeq(ans, dp[cur][be][bo][we][wo]);\n          }\n        }\n      }\n    }\n  }\n  cout << ans << '\\n';\n}\nint main() {\n  if (_inpf[0] != '\\0') assert(freopen(_inpf, \"r\", stdin) != nullptr);\n  if (_outf[0] != '\\0') assert(freopen(_outf, \"w\", stdout) != nullptr);\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  cout << setprecision(20);\n  _main_function();\n}\ntemplate <class T, class U>\ninline ostream &operator<<(ostream &_out, const pair<T, U> &_p) {\n  _out << _p.first << ' ' << _p.second;\n  return _out;\n}\ntemplate <class T, class U>\ninline istream &operator>>(istream &_in, pair<T, U> &_p) {\n  _in >> _p.first >> _p.second;\n  return _in;\n}\ntemplate <class T>\ninline ostream &operator<<(ostream &_out, const vector<T> &_v) {\n  if (_v.empty()) {\n    return _out;\n  }\n  _out << *_v.begin();\n  for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) {\n    _out << ' ' << *_it;\n  }\n  return _out;\n}\ntemplate <class T>\ninline istream &operator>>(istream &_in, vector<T> &_v) {\n  for (auto &_i : _v) {\n    _in >> _i;\n  }\n  return _in;\n}\ntemplate <class T>\ninline ostream &operator<<(ostream &_out, const set<T> &_s) {\n  if (_s.empty()) {\n    return _out;\n  }\n  _out << *_s.begin();\n  for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) {\n    _out << ' ' << *_it;\n  }\n  return _out;\n}\ntemplate <class T>\ninline ostream &operator<<(ostream &_out, const multiset<T> &_s) {\n  if (_s.empty()) {\n    return _out;\n  }\n  _out << *_s.begin();\n  for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) {\n    _out << ' ' << *_it;\n  }\n  return _out;\n}\ntemplate <class T>\ninline ostream &operator<<(ostream &_out, const unordered_set<T> &_s) {\n  if (_s.empty()) {\n    return _out;\n  }\n  _out << *_s.begin();\n  for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) {\n    _out << ' ' << *_it;\n  }\n  return _out;\n}\ntemplate <class T>\ninline ostream &operator<<(ostream &_out, const unordered_multiset<T> &_s) {\n  if (_s.empty()) {\n    return _out;\n  }\n  _out << *_s.begin();\n  for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) {\n    _out << ' ' << *_it;\n  }\n  return _out;\n}\ntemplate <class T, class U>\ninline ostream &operator<<(ostream &_out, const map<T, U> &_m) {\n  if (_m.empty()) {\n    return _out;\n  }\n  _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')';\n  for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) {\n    _out << \", (\" << _it->first << \": \" << _it->second << ')';\n  }\n  return _out;\n}\ntemplate <class T, class U>\ninline ostream &operator<<(ostream &_out, const unordered_map<T, U> &_m) {\n  if (_m.empty()) {\n    return _out;\n  }\n  _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')';\n  for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) {\n    _out << \", (\" << _it->first << \": \" << _it->second << ')';\n  }\n  return _out;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nint n, p, a[55];\nlong long f[55][2][2][2], er[55], ans;\nvoid add(long long &a, long long b) { a = (a + b) % mod; }\nint main() {\n  scanf(\"%d%d\", &n, &p);\n  er[0] = 1;\n  for (int i = 1; i <= n; i++)\n    scanf(\"%d\", &a[i]), er[i] = (er[i - 1] << 1) % mod;\n  f[0][0][0][0] = 1;\n  for (int i = 1; i <= n; i++)\n    for (int j = 0; j < 2; j++)\n      for (int k = 0; k < 2; k++)\n        for (int l = 0; l < 2; l++) {\n          int t = f[i - 1][j][k][l];\n          if (a[i] != 0) {\n            if (k)\n              add(f[i][j][k][l], 1ll * t * er[i - 2] % mod),\n                  add(f[i][j ^ 1][k][l | 1], 1ll * t * er[i - 2] % mod);\n            else\n              add(f[i][j ^ 1][k][l | 1], 1ll * t * er[i - 1] % mod);\n          }\n          if (a[i] != 1) {\n            if (l)\n              add(f[i][j][k][l], 1ll * t * er[i - 2] % mod),\n                  add(f[i][j ^ 1][k | 1][l], 1ll * t * er[i - 2] % mod);\n            else\n              add(f[i][j ^ 1][k | 1][l], 1ll * t * er[i - 1] % mod);\n          }\n        }\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 2; j++) add(ans, f[n][p][i][j]);\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int NMax = 55;\nint N, P;\nint C[NMax];\nint DP[NMax][NMax][NMax][NMax];\nint Power[NMax], ans;\nconst int MOD = 1000000007;\nvoid Add(int& x, int y) {\n  x += y;\n  if (x >= MOD) x -= MOD;\n}\nvoid Read() {\n  cin >> N >> P;\n  for (int i = 1; i <= N; i++) {\n    cin >> C[i];\n  }\n}\nvoid initPower() {\n  Power[0] = 1;\n  for (int i = 1; i <= N; i++) {\n    Power[i] = (Power[i - 1] * 2) % MOD;\n  }\n}\nvoid initialize() { DP[0][0][0][0] = 1; }\nvoid solveDPForWhiteNode(int currNode) {\n  for (int ew = 0; ew <= currNode; ew++) {\n    for (int ow = 0; ow + ew <= currNode; ow++) {\n      for (int ed = 0; ed + ow + ew <= currNode; ed++) {\n        int od = currNode - ew - ow - ed;\n        if (ew + ow == 0) continue;\n        int powerFactor = Power[ew + ow + ed - 1];\n        int ewFactor = (od > 0) ? (Power[od - 1]) : 0;\n        int owFactor = (od > 0) ? (Power[od - 1]) : 1;\n        int term =\n            (ew > 0)\n                ? ((1LL * ewFactor * DP[currNode - 1][ew - 1][ow][ed]) % MOD)\n                : 0;\n        Add(term,\n            (ow > 0)\n                ? ((1LL * owFactor * DP[currNode - 1][ew][ow - 1][ed]) % MOD)\n                : 0);\n        Add(DP[currNode][ew][ow][ed], (1LL * powerFactor * term) % MOD);\n      }\n    }\n  }\n}\nvoid solveDPForBlackNode(int currNode) {\n  for (int ew = 0; ew <= currNode; ew++) {\n    for (int ow = 0; ow + ew <= currNode; ow++) {\n      for (int ed = 0; ed + ow + ew <= currNode; ed++) {\n        int od = currNode - ew - ow - ed;\n        if (ed + od == 0) continue;\n        int powerFactor = Power[ew + od + ed - 1];\n        int edFactor = (ow > 0) ? Power[ow - 1] : 0;\n        int odFactor = (ow > 0) ? Power[ow - 1] : 1;\n        int term =\n            ((ed > 0)\n                 ? ((1LL * edFactor * DP[currNode - 1][ew][ow][ed - 1]) % MOD)\n                 : 0);\n        Add(term,\n            ((od > 0) ? ((1LL * odFactor * DP[currNode - 1][ew][ow][ed]) % MOD)\n                      : 0));\n        Add(DP[currNode][ew][ow][ed], (1LL * powerFactor * term) % MOD);\n      }\n    }\n  }\n}\nvoid computeAns() {\n  initialize();\n  for (int i = 1; i <= N; i++) {\n    if (C[i] != 0) solveDPForWhiteNode(i);\n    if (C[i] != 1) solveDPForBlackNode(i);\n  }\n  for (int ew = 0; ew <= N; ew++) {\n    for (int ow = 0; ow + ew <= N; ow++) {\n      for (int ed = 0; ed + ow + ew <= N; ed++) {\n        int od = N - ew - ow - ed;\n        if ((ow + od) % 2 == P) Add(ans, DP[N][ew][ow][ed]);\n      }\n    }\n  }\n  cout << ans << \"\\n\";\n}\nint main() {\n  Read();\n  initPower();\n  computeAns();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mo = 1e9 + 7, N = 100;\nlong long n, p, _2[N], a[N];\nlong long f[N][2][2][2], ans;\nvoid upd(long long &x, long long y) { x += y - mo, x += x >> 63 & mo; }\nsigned main() {\n  scanf(\"%lld%lld\", &n, &p);\n  for (long long i = 1; i <= n; i++) scanf(\"%lld\", &a[i]);\n  _2[0] = 1;\n  for (long long i = 1; i <= n; i++) _2[i] = (_2[i - 1] << 1) % mo;\n  f[0][0][0][0] = 1;\n  for (long long i = 1; i <= n; i++)\n    for (long long _ = 0; _ <= 1; _++)\n      for (long long b = 0; b <= 1; b++)\n        for (long long w = 0; w <= 1; w++) {\n          long long res = f[i - 1][_][b][w];\n          if (a[i] != 0) {\n            if (b) {\n              upd(f[i][_][b][w], res * _2[i - 2] % mo);\n              upd(f[i][_ ^ 1][b][w | 1], res * _2[i - 2] % mo);\n            } else\n              upd(f[i][_ ^ 1][b][w | 1], res * _2[i - 1] % mo);\n          }\n          if (a[i] != 1) {\n            if (w) {\n              upd(f[i][_][b][w], res * _2[i - 2] % mo);\n              upd(f[i][_ ^ 1][b | 1][w], res * _2[i - 2] % mo);\n            } else\n              upd(f[i][_ ^ 1][b | 1][w], res * _2[i - 1] % mo);\n          }\n        }\n  for (long long b = 0; b <= 1; b++)\n    for (long long w = 0; w <= 1; w++) upd(ans, f[n][p][b][w]);\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\ninline int add(int x, int y) {\n  int res = x + y;\n  while (res >= MOD) res -= MOD;\n  return res;\n}\ninline int mul(int x, int y) { return (1LL * x * y) % MOD; }\nint modpow(int x, int p) {\n  int res = 1;\n  while (p) {\n    if (p & 1) res = mul(res, x);\n    x = mul(x, x);\n    p /= 2;\n  }\n  return res;\n}\ninline int invert(int x) { return modpow(x, MOD - 2); }\nconst int N = 50 + 2;\nint dp[N][2][N][N][N];\nint powers[N];\nint main() {\n  cin.tie(0);\n  cout.tie(0);\n  ios_base::sync_with_stdio(0);\n  powers[0] = 1;\n  for (int i = 1; i < N; ++i) powers[i] = mul(2, powers[i - 1]);\n  int n, p;\n  cin >> n >> p;\n  vector<int> v(n);\n  for (int i = 0; i < n; ++i) cin >> v[i];\n  dp[n][0][0][0][0] = 1;\n  for (int i = n; i > 0; --i) {\n    for (int par = 0; par < 2; ++par) {\n      for (int b = 0; b < n + 1; ++b) {\n        for (int w = 0; w < n + 1; ++w) {\n          for (int bcnt = 0; bcnt < n + 1; ++bcnt) {\n            int B = bcnt;\n            int W = n - i - bcnt;\n            if (W < w || B < b) continue;\n            if (v[i - 1] != 0) {\n              int flip = powers[max(w - 1, 0) + B + W - w];\n              int same = w == 0 ? 0 : powers[w - 1 + B + W - w];\n              dp[i - 1][par ^ 1][b + 1][w][B + 1] =\n                  add(dp[i - 1][par ^ 1][b + 1][w][B + 1],\n                      mul(flip, dp[i][par][b][w][bcnt]));\n              dp[i - 1][par][b][w][B + 1] =\n                  add(dp[i - 1][par][b][w][B + 1],\n                      mul(same, dp[i][par][b][w][bcnt]));\n            }\n            if (v[i - 1] != 1) {\n              int flip = powers[max(b - 1, 0) + W + B - b];\n              int same = b == 0 ? 0 : powers[b - 1 + W + B - b];\n              dp[i - 1][par ^ 1][b][w + 1][B] =\n                  add(dp[i - 1][par ^ 1][b][w + 1][B],\n                      mul(flip, dp[i][par][b][w][bcnt]));\n              dp[i - 1][par][b][w][B] = add(dp[i - 1][par][b][w][B],\n                                            mul(same, dp[i][par][b][w][bcnt]));\n            }\n          }\n        }\n      }\n    }\n  }\n  int ans = 0;\n  for (int b = 0; b < n + 1; ++b)\n    for (int w = 0; w < n + 1; ++w)\n      for (int bcnt = 0; bcnt < n + 1; ++bcnt)\n        ans = add(ans, dp[0][p][b][w][bcnt]);\n  cout << ans << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nclass Solution {\n public:\n  int count(vector<int>& pieces, int p) {\n    int n = pieces.size();\n    preprocess(n);\n    vector<vector<vector<int>>> cur(\n        n + 1, vector<vector<int>>(n + 1, vector<int>(n + 1, 0)));\n    vector<vector<vector<int>>> nxt(\n        n + 1, vector<vector<int>>(n + 1, vector<int>(n + 1, 0)));\n    cur[0][0][0] = 1;\n    for (int i = 0; i < n; ++i) {\n      vector<int> cv;\n      if (pieces[i] == -1) {\n        cv.push_back(0);\n        cv.push_back(1);\n      } else {\n        cv.push_back(pieces[i]);\n      }\n      for (auto& vv : nxt) {\n        for (auto& v : vv) {\n          fill(v.begin(), v.end(), 0);\n        }\n      }\n      for (int j = 0; j <= i; ++j) {\n        for (int k = 0; k <= j; ++k) {\n          for (int l = 0; l <= i - j; ++l) {\n            if (cur[j][k][l] == 0) {\n              continue;\n            }\n            for (auto c : cv) {\n              if (c == 0) {\n                int nj = j + 1;\n                nxt[nj][k + 1][l] =\n                    add(nxt[nj][k + 1][l],\n                        multiply(cur[j][k][l],\n                                 multiply(1LL << j, multiply(1LL << (i - j - l),\n                                                             csums[l][0]))));\n                nxt[nj][k][l] =\n                    add(nxt[nj][k][l],\n                        multiply(cur[j][k][l],\n                                 multiply(1LL << j, multiply(1LL << (i - j - l),\n                                                             csums[l][1]))));\n              } else {\n                int nj = j;\n                nxt[nj][k][l + 1] = add(\n                    nxt[nj][k][l + 1],\n                    multiply(cur[j][k][l],\n                             multiply(1LL << (i - j),\n                                      multiply(1LL << (j - k), csums[k][0]))));\n                nxt[nj][k][l] = add(\n                    nxt[nj][k][l],\n                    multiply(cur[j][k][l],\n                             multiply(1LL << (i - j),\n                                      multiply(1LL << (j - k), csums[k][1]))));\n              }\n            }\n          }\n        }\n      }\n      cur.swap(nxt);\n    }\n    long long res = 0;\n    for (int i = 0; i <= n; ++i) {\n      for (int j = 0; j <= i; ++j) {\n        for (int k = 0; k <= n - i; ++k) {\n          if ((j + k) % 2 == p) {\n            res = add(res, cur[i][j][k]);\n          }\n        }\n      }\n    }\n    return res;\n  }\n\n private:\n  const static int M = 1e9 + 7;\n  vector<int> fv;\n  vector<int> ifv;\n  vector<vector<int>> cs;\n  vector<vector<int>> csums;\n  long long add(long long a, long long b) {\n    long long res = (a + b) % M;\n    return res;\n  }\n  long long multiply(long long a, long long b) { return (a * b) % M; }\n  long long pow(long long x, long long e) {\n    long long res = 1;\n    while (e > 0) {\n      if (e & 1) {\n        res = multiply(res, x);\n      }\n      x = multiply(x, x);\n      e >>= 1;\n    }\n    return res;\n  }\n  void preprocess(int n) {\n    fv.clear();\n    fv.resize(n + 1);\n    ifv.clear();\n    ifv.resize(n + 1);\n    cs.clear();\n    cs.resize(n + 1);\n    csums.clear();\n    csums.resize(n + 1);\n    for (auto& v : csums) {\n      v.resize(2);\n      fill(v.begin(), v.end(), 0);\n    }\n    fv[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n      fv[i] = multiply(fv[i - 1], i);\n    }\n    ifv[0] = 1;\n    ifv[n] = pow(fv[n], M - 2);\n    for (int i = n - 1; i >= 1; --i) {\n      ifv[i] = multiply(ifv[i + 1], i + 1);\n    }\n    for (int i = 1; i <= n; ++i) {\n      cs[i].resize(i + 1);\n      for (int j = 0; j <= i; ++j) {\n        cs[i][j] = multiply(multiply(fv[i], ifv[j]), ifv[i - j]);\n      }\n    }\n    csums[0][0] = 1;\n    for (int i = 1; i <= n; ++i) {\n      for (int j = 0; j <= i; ++j) {\n        if (j % 2) {\n          csums[i][1] = add(csums[i][1], cs[i][j]);\n        } else {\n          csums[i][0] = add(csums[i][0], cs[i][j]);\n        }\n      }\n    }\n  }\n};\nint main(int argc, char** argv) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  int p;\n  cin >> n >> p;\n  vector<int> nums(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> nums[i];\n  }\n  Solution sol;\n  cout << sol.count(nums, p) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            EKuroAndTopologicalParity solver = new EKuroAndTopologicalParity();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class EKuroAndTopologicalParity {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int p = in.readInt();\n\n            Modular mod = new Modular(1e9 + 7);\n            CachedPow pow = new CachedPow(2, n, mod);\n\n            int[][][][] dp = new int[n + 1][2][2][2];\n            dp[0][0][0][0] = 1;\n\n            for (int i = 1; i <= n; i++) {\n                int c = in.readInt();\n\n                for (int j = 0; j < 2; j++) {\n                    for (int k = 0; k < 2; k++) {\n                        for (int t = 0; t < 2; t++) {\n                            int cnt = i - 2 >= 0 ? pow.pow(i - 2) : 1;\n                            if (c != 1) {\n                                if (t == 1) {\n                                    //pick odd\n                                    dp[i][j][k][t] = mod.plus(dp[i][j][k][t], mod.mul(dp[i - 1][j][k][t], cnt));\n                                    if (k == 1) {\n                                        //pick even\n                                        dp[i][j][k][t] = mod.plus(dp[i][j][k][t], mod.mul(mod.plus(dp[i - 1][1 - j][1][t], dp[i - 1][1 - j][0][t]), cnt));\n                                    }\n                                } else {\n                                    if (k == 1) {\n                                        dp[i][j][k][t] = mod.plus(dp[i][j][k][t], mod.mul(mod.plus(dp[i - 1][1 - j][0][t], dp[i - 1][1 - j][1][t]), pow.pow(i - 1)));\n                                    }\n                                }\n                            }\n                            if (c != 0) {\n                                //pick odd\n                                if (k == 1) {\n                                    dp[i][j][k][t] = mod.plus(dp[i][j][k][t], mod.mul(dp[i - 1][j][k][t], cnt));\n                                    if (t == 1) {\n                                        //pick even\n                                        dp[i][j][k][t] = mod.plus(dp[i][j][k][t], mod.mul(mod.plus(dp[i - 1][1 - j][k][1], dp[i - 1][1 - j][k][0]), cnt));\n                                    }\n                                } else {\n                                    if (t == 1) {\n                                        //pick even\n                                        dp[i][j][k][t] = mod.plus(dp[i][j][k][t], mod.mul(mod.plus(dp[i - 1][1 - j][k][1], dp[i - 1][1 - j][k][0]), pow.pow(i - 1)));\n                                    }\n                                }\n\n                            }\n                        }\n                    }\n                }\n            }\n\n            int ans = 0;\n            for (int i = 0; i < 2; i++) {\n                for (int j = 0; j < 2; j++) {\n                    ans = mod.plus(dp[n][p][i][j], ans);\n                }\n            }\n\n            out.println(ans);\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(int c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class Modular {\n        int m;\n\n        public int getMod() {\n            return m;\n        }\n\n        public Modular(int m) {\n            this.m = m;\n        }\n\n        public Modular(long m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public Modular(double m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int valueOf(int x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return x;\n        }\n\n        public int valueOf(long x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return (int) x;\n        }\n\n        public int mul(int x, int y) {\n            return valueOf((long) x * y);\n        }\n\n        public int plus(int x, int y) {\n            return valueOf(x + y);\n        }\n\n        public Modular getModularForPowerComputation() {\n            return new Modular(m - 1);\n        }\n\n        public String toString() {\n            return \"mod \" + m;\n        }\n\n    }\n\n    static class DigitUtils {\n        private DigitUtils() {\n        }\n\n        public static long round(double x) {\n            if (x >= 0) {\n                return (long) (x + 0.5);\n            } else {\n                return (long) (x - 0.5);\n            }\n        }\n\n    }\n\n    static class CachedPow {\n        private int[] first;\n        private int[] second;\n        private Modular mod;\n        private Modular powMod;\n\n        public CachedPow(int x, Modular mod) {\n            this(x, mod.getMod(), mod);\n        }\n\n        public CachedPow(int x, int maxExp, Modular mod) {\n            this.mod = mod;\n            this.powMod = mod.getModularForPowerComputation();\n            int k = Math.max(1, (int) DigitUtils.round(Math.sqrt(maxExp)));\n            first = new int[k];\n            second = new int[maxExp / k + 1];\n            first[0] = 1;\n            for (int i = 1; i < k; i++) {\n                first[i] = mod.mul(x, first[i - 1]);\n            }\n            second[0] = 1;\n            int step = mod.mul(x, first[k - 1]);\n            for (int i = 1; i < second.length; i++) {\n                second[i] = mod.mul(second[i - 1], step);\n            }\n        }\n\n        public int pow(int exp) {\n            return mod.mul(first[exp % first.length], second[exp / first.length]);\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\nconst int MAXN = 2e5 + 5;\nint n, opt, dat[MAXN], f[MAXN][2][2][2], p[MAXN];\ninline int read() {\n  int x = 0;\n  int f = 1;\n  char ch = getchar();\n  while (!isdigit(ch)) {\n    ch == '-' && (f = -1);\n    ch = getchar();\n  }\n  while (isdigit(ch)) {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return x * f;\n}\ninline int add(int x, int y) { return x + y >= MOD ? x + y - MOD : x + y; }\ninline void Add(int &x, int y) { x += y, x >= MOD && (x -= MOD); }\nint main() {\n  n = read(), opt = read(), p[0] = 1;\n  for (int i = 1; i <= n; i++) dat[i] = read();\n  for (int i = 1; i <= n; i++) p[i] = add(p[i - 1], p[i - 1]);\n  f[0][0][0][0] = 1;\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < 2; j++)\n      for (int k = 0; k < 2; k++)\n        for (int l = 0; l < 2; l++) {\n          if (!f[i][j][k][l]) continue;\n          if (dat[i + 1] != 1)\n            f[i + 1][j][k][l] =\n                (f[i + 1][j][k][l] +\n                 1ll * f[i][j][k][l] * (j == 0 ? 0 : p[i - 1])) %\n                MOD,\n                  f[i + 1][j][k | 1][l ^ 1] =\n                      (f[i + 1][j][k | 1][l ^ 1] +\n                       1ll * f[i][j][k][l] * (j == 0 ? p[i] : p[i - 1])) %\n                      MOD;\n          if (dat[i + 1] != 0)\n            f[i + 1][j][k][l] =\n                (f[i + 1][j][k][l] +\n                 1ll * f[i][j][k][l] * (k == 0 ? 0 : p[i - 1])) %\n                MOD,\n                  f[i + 1][j | 1][k][l ^ 1] =\n                      (f[i + 1][j | 1][k][l ^ 1] +\n                       1ll * f[i][j][k][l] * (k == 0 ? p[i] : p[i - 1])) %\n                      MOD;\n        }\n  int ans = 0;\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 2; j++) Add(ans, f[n][i][j][opt]);\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\ninline T gi() {\n  T x = 0, f = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n  return f * x;\n}\nconst int N = 100003, M = N << 1, mod = 1000000007;\nint n, p;\nlong long dp[N][2][2][2];\nlong long pw[N];\nint col[N];\ninline void Add(long long &x, long long y) { x = (x + y) % mod; }\nint main() {\n  n = gi<int>(), p = gi<int>();\n  for (int i = (pw[0] = 1); i <= n; i += 1)\n    col[i] = gi<int>(), pw[i] = 1ll * pw[i - 1] * 2 % mod;\n  dp[0][0][0][0] = 1;\n  for (int i = 0; i < n; i += 1)\n    for (int j = 0; j <= 1; j += 1)\n      for (int x = 0; x <= 1; x += 1)\n        for (int y = 0; y <= 1; y += 1) {\n          if (col[i + 1] == 1 || col[i + 1] == -1) {\n            if (!x)\n              Add(dp[i + 1][1 - j][x][1], 1ll * pw[i] * dp[i][j][x][y]);\n            else\n              Add(dp[i + 1][1 - j][x][1], 1ll * pw[i - 1] * dp[i][j][x][y]),\n                  Add(dp[i + 1][j][x][y], 1ll * pw[i - 1] * dp[i][j][x][y]);\n          }\n          if (col[i + 1] == 0 || col[i + 1] == -1) {\n            if (!y)\n              Add(dp[i + 1][1 - j][1][y], 1ll * pw[i] * dp[i][j][x][y]);\n            else\n              Add(dp[i + 1][1 - j][1][y], 1ll * pw[i - 1] * dp[i][j][x][y]),\n                  Add(dp[i + 1][j][x][y], 1ll * pw[i - 1] * dp[i][j][x][y]);\n          }\n        }\n  long long ans = 0;\n  Add(ans, dp[n][p][0][0]);\n  Add(ans, dp[n][p][0][1]);\n  Add(ans, dp[n][p][1][0]);\n  Add(ans, dp[n][p][1][1]);\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint n, p, fang[55], a[55];\nint f[55][2][2][2], ans;\nvoid add(int &x, int y) {\n  x += y;\n  if (x >= 1000000007) x -= 1000000007;\n}\nint main() {\n  scanf(\"%d%d\", &n, &p);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  fang[0] = 1;\n  for (int i = 1; i <= n; i++) fang[i] = fang[i - 1] * 2 % 1000000007;\n  f[0][0][0][0] = 1;\n  for (int i = 1; i <= n; i++)\n    for (int zong = 0; zong <= 1; zong++)\n      for (int bla = 0; bla <= 1; bla++)\n        for (int whi = 0; whi <= 1; whi++) {\n          if (a[i] != 0)\n            if (bla) {\n              add(f[i][zong][bla][whi],\n                  1ll * f[i - 1][zong][bla][whi] * fang[i - 2] % 1000000007);\n              add(f[i][zong ^ 1][bla][whi | 1],\n                  1ll * f[i - 1][zong][bla][whi] * fang[i - 2] % 1000000007);\n            } else\n              add(f[i][zong ^ 1][bla][whi | 1],\n                  1ll * f[i - 1][zong][bla][whi] * fang[i - 1] % 1000000007);\n          if (a[i] != 1)\n            if (whi) {\n              add(f[i][zong][bla][whi],\n                  1ll * f[i - 1][zong][bla][whi] * fang[i - 2] % 1000000007);\n              add(f[i][zong ^ 1][bla | 1][whi],\n                  1ll * f[i - 1][zong][bla][whi] * fang[i - 2] % 1000000007);\n            } else\n              add(f[i][zong ^ 1][bla | 1][whi],\n                  1ll * f[i - 1][zong][bla][whi] * fang[i - 1] % 1000000007);\n        }\n  for (int i = 0; i <= 1; i++)\n    for (int j = 0; j <= 1; j++) add(ans, f[n][p][i][j]);\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\nint n, p, ans, a[200005], fac[200005], f[200005][2][2], g[200005][2][2];\nint main() {\n  scanf(\"%d%d\", &n, &p);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  fac[0] = 1;\n  for (int i = 1; i <= n; i++) fac[i] = fac[i - 1] * 2 % mod;\n  g[0][0][0] = 1;\n  for (int i = 1; i <= n; i++)\n    for (int j = 0; j <= 1; j++)\n      for (int k = 0; k <= 1; k++) {\n        if (a[i] != 0) {\n          f[i][1][k] = (f[i][1][k] + (long long)g[i - 1][j][k] *\n                                         (k ? fac[i - 2] : fac[i - 1]) % mod) %\n                       mod;\n          g[i][1][k] = (g[i][1][k] + (long long)f[i - 1][j][k] *\n                                         (k ? fac[i - 2] : fac[i - 1]) % mod) %\n                       mod;\n          f[i][j][k] = (f[i][j][k] + (long long)f[i - 1][j][k] *\n                                         (k ? fac[i - 2] : 0) % mod) %\n                       mod;\n          g[i][j][k] = (g[i][j][k] + (long long)g[i - 1][j][k] *\n                                         (k ? fac[i - 2] : 0) % mod) %\n                       mod;\n        }\n        if (a[i] != 1) {\n          f[i][j][1] = (f[i][j][1] + (long long)g[i - 1][j][k] *\n                                         (j ? fac[i - 2] : fac[i - 1]) % mod) %\n                       mod;\n          g[i][j][1] = (g[i][j][1] + (long long)f[i - 1][j][k] *\n                                         (j ? fac[i - 2] : fac[i - 1]) % mod) %\n                       mod;\n          f[i][j][k] = (f[i][j][k] + (long long)f[i - 1][j][k] *\n                                         (j ? fac[i - 2] : 0) % mod) %\n                       mod;\n          g[i][j][k] = (g[i][j][k] + (long long)g[i - 1][j][k] *\n                                         (j ? fac[i - 2] : 0) % mod) %\n                       mod;\n        }\n      }\n  for (int i = 0; i <= 1; i++)\n    for (int j = 0; j <= 1; j++)\n      ans = (ans + (p ? f[n][i][j] : g[n][i][j])) % mod;\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 51;\nconst int lbt = 1e9 + 7;\nvoid init(int n);\nint C[maxn][maxn];\nint pow2[maxn];\nint f[maxn];\nint dp[maxn][maxn][maxn];\nint a[maxn];\nint main() {\n  int n, p;\n  scanf(\"%d%d\", &n, &p);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  init(n);\n  dp[0][0][0] = 1;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j <= i; j++) {\n      for (int k = 0; k <= i; k++) {\n        if (!dp[i][j][k]) continue;\n        if (a[i + 1] == 1 || a[i + 1] == -1) {\n          dp[i + 1][j][k] += (long long)pow2[i - k] * (pow2[k] - f[k]) % lbt *\n                             dp[i][j][k] % lbt;\n          if (dp[i + 1][j][k] < 0) dp[i + 1][j][k] += lbt;\n          if (dp[i + 1][j][k] >= lbt) dp[i + 1][j][k] -= lbt;\n          dp[i + 1][j + 1][k] +=\n              (long long)pow2[i - k] * f[k] % lbt * dp[i][j][k] % lbt;\n          if (dp[i + 1][j + 1][k] >= lbt) dp[i + 1][j + 1][k] -= lbt;\n        }\n        if (a[i + 1] == 0 || a[i + 1] == -1) {\n          dp[i + 1][j][k] += (long long)pow2[i - j] * (pow2[j] - f[j]) % lbt *\n                             dp[i][j][k] % lbt;\n          if (dp[i + 1][j][k] < 0) dp[i + 1][j][k] += lbt;\n          if (dp[i + 1][j][k] >= lbt) dp[i + 1][j][k] -= lbt;\n          dp[i + 1][j][k + 1] +=\n              (long long)pow2[i - j] * f[j] % lbt * dp[i][j][k] % lbt;\n          if (dp[i + 1][j][k + 1] >= lbt) dp[i + 1][j][k + 1] -= lbt;\n        }\n      }\n    }\n  }\n  if (p == 1) {\n    int ans = 0;\n    for (int i = 0; i <= n; i++) {\n      for (int j = 0; j <= n; j++) {\n        if ((i + j) % 2) {\n          ans += dp[n][i][j];\n          if (ans >= lbt) ans -= lbt;\n        }\n      }\n    }\n    printf(\"%d\", ans);\n  } else {\n    int ans = 0;\n    for (int i = 0; i <= n; i++) {\n      for (int j = 0; j <= n; j++) {\n        if ((i + j) % 2 == 0) {\n          ans += dp[n][i][j];\n          if (ans >= lbt) ans -= lbt;\n        }\n      }\n    }\n    printf(\"%d\", ans);\n  }\n  return 0;\n}\nvoid init(int n) {\n  for (int i = 0; i <= n; i++) {\n    C[i][0] = 1;\n    C[i][i] = 1;\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j < i; j++) {\n      C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\n      if (C[i][j] >= lbt) C[i][j] -= lbt;\n    }\n  }\n  for (int i = 0; i <= n; i++) {\n    for (int j = 0; j <= i; j++) {\n      if (j % 2 == 0) {\n        f[i] += C[i][j];\n        if (f[i] >= lbt) f[i] -= lbt;\n      }\n    }\n  }\n  pow2[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    pow2[i] = pow2[i - 1] * 2;\n    if (pow2[i] >= lbt) pow2[i] -= lbt;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, p, c[51];\nlong long dp[51][51][51], t[51];\nconst long long M = 1E9 + 7;\nvoid init() {\n  t[0] = 1;\n  for (int i = 1; i <= n; i++) t[i] = t[i - 1] * 2 % M;\n}\ninline long long add(long long a, long long b) { return (a + b) % M; }\nvoid solve() {\n  init();\n  dp[0][0][0] = 1;\n  for (int i = 1; i <= n; i++) {\n    for (int ob = 0; ob <= i; ob++) {\n      for (int ow = 0; ow + ob <= i; ow++) {\n        if (c[i] == 0 || c[i] == -1) {\n          if (ob - 1 >= 0) {\n            dp[i][ob][ow] = add(dp[i][ob][ow], dp[i - 1][ob - 1][ow] *\n                                                   t[ow - 1 >= 0 ? ow - 1 : 0] %\n                                                   M * t[i - 1 - ow] % M);\n          }\n          if (ow >= 1) {\n            dp[i][ob][ow] = add(dp[i][ob][ow], dp[i - 1][ob][ow] * t[ow - 1] %\n                                                   M * t[i - 1 - ow] % M);\n          }\n        }\n        if (c[i] == 1 || c[i] == -1) {\n          if (ow - 1 >= 0) {\n            dp[i][ob][ow] = add(dp[i][ob][ow], dp[i - 1][ob][ow - 1] *\n                                                   t[ob - 1 >= 0 ? ob - 1 : 0] %\n                                                   M * t[i - 1 - ob] % M);\n          }\n          if (ob >= 1) {\n            dp[i][ob][ow] = add(dp[i][ob][ow], dp[i - 1][ob][ow] * t[ob - 1] %\n                                                   M * t[i - 1 - ob] % M);\n          }\n        }\n      }\n    }\n  }\n  long long res = 0;\n  for (int ob = 0; ob <= n; ob++) {\n    for (int ow = 0; ob + ow <= n; ow++) {\n      if ((ob + ow) % 2 == p) {\n        res = add(res, dp[n][ob][ow]);\n      }\n    }\n  }\n  cout << res << endl;\n}\nint main() {\n  cin >> n >> p;\n  for (int i = 1; i <= n; i++) scanf(\"%d\", c + i);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 55;\nconst int MOD = 1000000000 + 7;\nint dp[N][N][N][N];\nint c[N];\nlong long ceven[N];\nlong long codd[N];\nlong long fact[N];\nlong long inv_fact[N];\nlong long pow2[N];\nlong long power(long long s, long long p) {\n  long long base = s;\n  long long val = 1;\n  long long tmp = p;\n  while (tmp > 0) {\n    if (tmp & 1) val = (val * base) % MOD;\n    base = (base * base) % MOD;\n    tmp >>= 1;\n  }\n  return val;\n}\nvoid init() {\n  fact[0] = 1;\n  pow2[0] = 1;\n  for (int i = 1; i < N; i += 1) {\n    fact[i] = (i * fact[i - 1]) % MOD;\n    pow2[i] = (2 * pow2[i - 1]) % MOD;\n  }\n  inv_fact[N - 1] = power(fact[N - 1], MOD - 2);\n  for (int i = N - 2; i >= 0; i--)\n    inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD;\n  for (int i = 0; i < N; i += 1) {\n    for (int j = 0; j <= i; j += 2) {\n      ceven[i] += (((fact[i] * inv_fact[j]) % MOD) * inv_fact[i - j]) % MOD;\n      ceven[i] %= MOD;\n    }\n    for (int j = 1; j <= i; j += 2) {\n      codd[i] += (((fact[i] * inv_fact[j]) % MOD) * inv_fact[i - j]) % MOD;\n      codd[i] %= MOD;\n    }\n  }\n}\nint main() {\n  int n, p;\n  cin >> n >> p;\n  for (int i = 0; i < n; i += 1) cin >> c[i];\n  init();\n  long long ans = 0;\n  dp[0][0][0][0] = 1;\n  for (int i = 1; i <= n; i += 1) {\n    for (int w1 = 0; w1 <= i; w1 += 1) {\n      for (int w2 = 0; w2 + w1 <= i; w2 += 1) {\n        for (int b1 = 0; b1 + w2 + w1 <= i; b1 += 1) {\n          int b2 = i - w1 - w2 - b1;\n          if (c[i - 1] == 0 || c[i - 1] == -1) {\n            long long tpe = w1 == 0 ? 1 : pow2[w1 - 1];\n            long long tpo = w1 == 0 ? 0 : pow2[w1 - 1];\n            if (b1 > 0) {\n              dp[i][w1][w2][b1] += (dp[i - 1][w1][w2][b1 - 1] * tpe % MOD) *\n                                   pow2[w2 + b1 - 1 + b2] % MOD;\n              dp[i][w1][w2][b1] %= MOD;\n            }\n            if (b2 > 0) {\n              dp[i][w1][w2][b1] += (dp[i - 1][w1][w2][b1] * tpo % MOD) *\n                                   pow2[w2 + b1 - 1 + b2] % MOD;\n              dp[i][w1][w2][b1] %= MOD;\n            }\n          }\n          if (c[i - 1] == 1 || c[i - 1] == -1) {\n            long long tpe = b1 == 0 ? 1 : pow2[b1 - 1];\n            long long tpo = b1 == 0 ? 0 : pow2[b1 - 1];\n            if (w1 > 0) {\n              dp[i][w1][w2][b1] += (dp[i - 1][w1 - 1][w2][b1] * tpe % MOD) *\n                                   pow2[w1 - 1 + w2 + b2] % MOD;\n              dp[i][w1][w2][b1] %= MOD;\n            }\n            if (w2 > 0) {\n              dp[i][w1][w2][b1] += (dp[i - 1][w1][w2 - 1][b1] * tpo % MOD) *\n                                   pow2[w1 + w2 - 1 + b2] % MOD;\n              dp[i][w1][w2][b1] %= MOD;\n            }\n          }\n          if (i == n && ((w1 + b1) & 1) == p) {\n            ans += dp[i][w1][w2][b1];\n            ans %= MOD;\n          }\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 55, M = 1e9 + 7;\nint add(int a, int b) {\n  a += b;\n  if (a >= M) return a - M;\n  return a;\n}\nint n, p;\nint ar[N];\nint pow2[N];\nint f[N][2][2][2];\ninline void init() {\n  scanf(\"%d%d\", &n, &p);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", ar + i);\n  pow2[0] = 1;\n  for (int i = 1; i <= n; i++) pow2[i] = add(pow2[i - 1], pow2[i - 1]);\n}\ninline void solve() {\n  f[0][0][0][0] = 1;\n  for (int i = 1; i <= n; i++)\n    for (int hob = 0; hob < 2; hob++)\n      for (int how = 0; how < 2; how++)\n        for (int par = 0; par < 2; par++) {\n          int lans = f[i - 1][hob][how][par];\n          if (!lans) continue;\n          if (ar[i] != 0) {\n            if (!hob)\n              f[i][0][1][par ^ 1] =\n                  add(f[i][0][1][par ^ 1], lans * 1ll * pow2[i - 1] % M);\n            else {\n              f[i][1][1][par ^ 1] =\n                  add(f[i][1][1][par ^ 1], lans * 1ll * pow2[i - 2] % M);\n              f[i][1][how][par] =\n                  add(f[i][1][how][par], lans * 1ll * pow2[i - 2] % M);\n            }\n          }\n          if (ar[i] != 1) {\n            if (!how)\n              f[i][1][0][par ^ 1] =\n                  add(f[i][1][0][par ^ 1], lans * 1ll * pow2[i - 1] % M);\n            else {\n              f[i][1][1][par ^ 1] =\n                  add(f[i][1][1][par ^ 1], lans * 1ll * pow2[i - 2] % M);\n              f[i][hob][1][par] =\n                  add(f[i][hob][1][par], lans * 1ll * pow2[i - 2] % M);\n            }\n          }\n        }\n  int res = 0;\n  for (int x = 0; x < 2; x++)\n    for (int y = 0; y < 2; y++) res = add(res, f[n][x][y][p]);\n  printf(\"%d\\n\", res);\n}\nint main() {\n  init();\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint n, f;\nlong long dp[55][2][2][2];\nint col[55];\nlong long pw[55];\ninline int read() {\n  int ans = 0;\n  int f = 1;\n  char ch = getchar();\n  for (; ch < '0' || ch > '9'; ch = getchar())\n    if (ch == '-') f = -1;\n  for (; ch >= '0' && ch <= '9'; ch = getchar()) ans = ans * 10 + ch - '0';\n  return ans * f;\n}\nint main() {\n  n = read(), f = read();\n  register int i, j;\n  pw[0] = 1;\n  for (i = 1; i <= n; i++) pw[i] = pw[i - 1] * 2 % 1000000007;\n  for (i = 1; i <= n; i++) col[i] = read();\n  dp[0][0][0][0] = 1;\n  for (i = 1; i <= n; i++) {\n    for (j = 0; j <= 1; j++) {\n      if (col[i] == 0 || col[i] == -1) {\n        if (i > 1) dp[i][j][0][1] += dp[i - 1][j][0][1] * pw[i - 2];\n        if (i > 1) dp[i][j][1][1] += dp[i - 1][j][1][1] * pw[i - 2];\n        if (i > 1)\n          dp[i][j ^ 1][1][1] += (dp[i - 1][j][0][1] + dp[i - 1][j][1][1]) *\n                                pw[i - 2] % 1000000007;\n        dp[i][j ^ 1][1][0] +=\n            (dp[i - 1][j][1][0] + dp[i - 1][j][0][0]) * pw[i - 1];\n        dp[i][j][0][1] %= 1000000007, dp[i][j][1][1] %= 1000000007;\n        dp[i][j ^ 1][1][1] %= 1000000007, dp[i][j ^ 1][1][0] %= 1000000007;\n      }\n      if (col[i] == 1 || col[i] == -1) {\n        if (i > 1) dp[i][j][1][0] += dp[i - 1][j][1][0] * pw[i - 2];\n        if (i > 1) dp[i][j][1][1] += dp[i - 1][j][1][1] * pw[i - 2];\n        if (i > 1)\n          dp[i][j ^ 1][1][1] += (dp[i - 1][j][1][0] + dp[i - 1][j][1][1]) *\n                                pw[i - 2] % 1000000007;\n        dp[i][j ^ 1][0][1] +=\n            (dp[i - 1][j][0][1] + dp[i - 1][j][0][0]) * pw[i - 1];\n        dp[i][j][1][0] %= 1000000007, dp[i][j][1][1] %= 1000000007;\n        dp[i][j ^ 1][1][1] %= 1000000007, dp[i][j ^ 1][0][1] %= 1000000007;\n      }\n    }\n  }\n  long long ans = 0;\n  ans = (ans + dp[n][f][0][0] + dp[n][f][0][1] + dp[n][f][1][0] +\n         dp[n][f][1][1]) %\n        1000000007;\n  printf(\"%I64d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace my_std {\nconst long long inf = 0x3f3f3f3f;\nconst long long inff = 1e15;\ninline long long read() {\n  long long sum = 0, f = 1;\n  char ch = 0;\n  while (!isdigit(ch)) {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (isdigit(ch)) {\n    sum = sum * 10 + (ch ^ 48);\n    ch = getchar();\n  }\n  return sum * f;\n}\ninline void write(long long x) {\n  if (x < 0) {\n    x = -x;\n    putchar('-');\n  }\n  if (x > 9) write(x / 10);\n  putchar(x % 10 + '0');\n}\ninline void writeln(long long x) {\n  write(x);\n  putchar('\\n');\n}\ninline void writesp(long long x) {\n  write(x);\n  putchar(' ');\n}\n}  // namespace my_std\nusing namespace my_std;\nconst long long N = 55, mod = 1e9 + 7;\nlong long n, p, a[N], f[N][N][N][N], mi[N] = {1}, ans;\nint main(void) {\n  n = read(), p = read();\n  for (register long long i = (1); i <= (n); ++i) a[i] = read();\n  for (register long long i = (1); i <= (n); ++i)\n    mi[i] = (mi[i - 1] << 1) % mod;\n  if (a[1] == 1 || a[1] == -1) {\n    f[1][1][0][0] = 1;\n    if (p && n == 1) ans++;\n  }\n  if (!a[1] || a[1] == -1) {\n    f[1][0][1][0] = 1;\n    if (p && n == 1) ans++;\n  }\n  for (register long long i = (2); i <= (n); ++i)\n    for (register long long jb = (0); jb <= (i); ++jb)\n      for (register long long jh = (0); jh <= (i - jb); ++jh)\n        for (register long long ob = (0); ob <= (i - jb - jh); ++ob) {\n          long long oh = i - jb - jh - ob;\n          if (a[i] == 1 || a[i] == -1) {\n            long long add = 0;\n            if ((jb + ob) != 0) {\n              if (jb != 0) {\n                if (jh == 0)\n                  add = (add + f[i - 1][jb - 1][jh][ob]) % mod;\n                else\n                  add = (add + mi[jh - 1] * f[i - 1][jb - 1][jh][ob]) % mod;\n              }\n              if (ob != 0 && jh != 0)\n                add = (add + mi[jh - 1] * f[i - 1][jb][jh][ob - 1] % mod);\n            }\n            add = (add * mi[jb + ob + oh - 1]) % mod;\n            f[i][jb][jh][ob] = (f[i][jb][jh][ob] + add) % mod;\n          }\n          if (a[i] == 0 || a[i] == -1) {\n            long long add = 0;\n            if ((jh + oh) != 0) {\n              if (jh != 0) {\n                if (jb == 0)\n                  add = (add + f[i - 1][jb][jh - 1][ob]) % mod;\n                else\n                  add = (add + mi[jb - 1] * f[i - 1][jb][jh - 1][ob]) % mod;\n              }\n              if (jb != 0 && oh != 0)\n                add = (add + mi[jb - 1] * f[i - 1][jb][jh][ob] % mod) % mod;\n            }\n            add = (add * mi[jh + ob + oh - 1]) % mod;\n            f[i][jb][jh][ob] = (f[i][jb][jh][ob] + add) % mod;\n          }\n          if (i == n && (jb + jh) % 2 == p)\n            ans = (ans + f[i][jb][jh][ob]) % mod;\n        }\n  writeln(ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint colors[55];\nlong long int dp[55][55][55];\nlong long int sum2s[55];\nvoid solve(int i, int j, int k) {\n  if (i == 0) {\n    return;\n  }\n  if (colors[i] == 0) {\n    if (dp[i - 1][j][k] == -1) {\n      solve(i - 1, j, k);\n    }\n    if (j > 0 && dp[i - 1][j - 1][k] == -1) {\n      solve(i - 1, j - 1, k);\n    }\n    if (j > 0) {\n    }\n    if (i == 1) {\n      return;\n    }\n    if (j == 0 && k == 0) {\n      dp[i][j][k] = 0;\n    } else if (j == 0) {\n      dp[i][j][k] =\n          sum2s[i - k - 1] * ((dp[i - 1][j][k] * sum2s[k - 1]) % 1000000007);\n      dp[i][j][k] %= 1000000007;\n    } else if (k == 0) {\n      dp[i][j][k] = sum2s[i - k - 1] * ((dp[i - 1][j - 1][k]) % 1000000007);\n      dp[i][j][k] %= 1000000007;\n    } else {\n      dp[i][j][k] = sum2s[i - k - 1] *\n                    ((dp[i - 1][j - 1][k] * sum2s[k - 1]) % 1000000007 +\n                     (dp[i - 1][j][k] * sum2s[k - 1]) % 1000000007);\n      dp[i][j][k] %= 1000000007;\n    }\n  } else if (colors[i] == 1) {\n    if (dp[i - 1][j][k] == -1) {\n      solve(i - 1, j, k);\n    }\n    if (k > 0 && dp[i - 1][j][k - 1] == -1) {\n      solve(i - 1, j, k - 1);\n    }\n    if (k > 0) {\n    }\n    if (i == 1) {\n      return;\n    }\n    if (j == 0 && k == 0) {\n      dp[i][j][k] = 0;\n    } else if (k == 0) {\n      dp[i][j][k] =\n          sum2s[i - j - 1] * ((dp[i - 1][j][k] * sum2s[j - 1]) % 1000000007);\n      dp[i][j][k] %= 1000000007;\n    } else if (j == 0) {\n      dp[i][j][k] = sum2s[i - j - 1] * ((dp[i - 1][j][k - 1]) % 1000000007);\n      dp[i][j][k] %= 1000000007;\n    } else {\n      dp[i][j][k] = sum2s[i - j - 1] *\n                    ((dp[i - 1][j][k] * sum2s[j - 1]) % 1000000007 +\n                     (dp[i - 1][j][k - 1] * sum2s[j - 1]) % 1000000007);\n      dp[i][j][k] %= 1000000007;\n    }\n  } else if (colors[i] == -1) {\n    if (dp[i - 1][j][k] == -1) {\n      solve(i - 1, j, k);\n    }\n    if (j > 0 && dp[i - 1][j - 1][k] == -1) {\n      solve(i - 1, j - 1, k);\n    }\n    if (j > 0) {\n    }\n    if (k > 0 && dp[i - 1][j][k - 1] == -1 && k > 0) {\n      solve(i - 1, j, k - 1);\n    }\n    if (k > 0) {\n    }\n    if (i == 1) {\n      return;\n    } else if (j == 0 && k == 0) {\n      dp[i][j][k] = 0;\n    } else if (j == 0) {\n      dp[i][j][k] =\n          sum2s[i - k - 1] * ((dp[i - 1][j][k] * sum2s[k - 1]) % 1000000007);\n      dp[i][j][k] %= 1000000007;\n      dp[i][j][k] += sum2s[i - j - 1] * ((dp[i - 1][j][k - 1]) % 1000000007);\n      dp[i][j][k] %= 1000000007;\n    } else if (k == 0) {\n      dp[i][j][k] = sum2s[i - k - 1] * ((dp[i - 1][j - 1][k]) % 1000000007);\n      dp[i][j][k] %= 1000000007;\n      dp[i][j][k] +=\n          sum2s[i - j - 1] * ((dp[i - 1][j][k] * sum2s[j - 1]) % 1000000007);\n      dp[i][j][k] %= 1000000007;\n    } else {\n      dp[i][j][k] = sum2s[i - k - 1] *\n                    ((dp[i - 1][j - 1][k] * sum2s[k - 1]) % 1000000007 +\n                     (dp[i - 1][j][k] * sum2s[k - 1]) % 1000000007);\n      dp[i][j][k] %= 1000000007;\n      dp[i][j][k] += sum2s[i - j - 1] *\n                     ((dp[i - 1][j][k] * sum2s[j - 1]) % 1000000007 +\n                      (dp[i - 1][j][k - 1] * sum2s[j - 1]) % 1000000007);\n      dp[i][j][k] %= 1000000007;\n    }\n  }\n}\nint main() {\n  int n;\n  bool p;\n  cin >> n >> p;\n  for (int i = 0; i < n; i++) {\n    cin >> colors[i + 1];\n  }\n  long long int pow2 = 1;\n  for (int i = 0; i < n; i++) {\n    sum2s[i] = pow2;\n    pow2 *= 2;\n    pow2 %= 1000000007;\n  }\n  for (int i = 0; i < 55; i++) {\n    for (int j = 0; j < 55; j++) {\n      for (int k = 0; k < 55; k++) {\n        dp[i][j][k] = -1;\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < 55; j++) {\n      dp[1][i][j] = 0;\n    }\n  }\n  if (colors[1] == 0) {\n    dp[1][1][0] = 1;\n  } else if (colors[1] == 1) {\n    dp[1][0][1] = 1;\n  } else if (colors[1] == -1) {\n    dp[1][0][1] = 1;\n    dp[1][1][0] = 1;\n  }\n  long long int ans = 0;\n  for (int i = 0; i <= n; i++) {\n    for (int j = 0; j <= n - i; j++) {\n      solve(n, i, j);\n      if ((i + j) % 2 == p) {\n        ans += dp[n][i][j];\n        ans %= 1000000007;\n      }\n    }\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, p, c[55], mo = 1000000007;\nint dp[52][52][52][52];\nint bi[52][52], p2[52];\nint ans() {\n  for (int s = 0; s < 52; s++) {\n    bi[s][0] = bi[s][s] = 1;\n    for (int i = 1; i < s; i++)\n      bi[s][i] = (bi[s - 1][i - 1] + bi[s - 1][i]) % mo;\n  }\n  p2[0] = 1;\n  for (int i = 1; i < 52; i++) {\n    p2[i] = p2[i - 1] * 2 % mo;\n  }\n  dp[0][0][0][0] = 1;\n  long long pre;\n  int b1;\n  for (int s = 0; s < n; s++) {\n    for (int w0 = 0; w0 <= s; w0++)\n      for (int w1 = 0; w1 + w0 <= s; w1++)\n        for (int b0 = 0; b0 + w0 + w1 <= s; b0++)\n          if (pre = dp[s][w0][w1][b0]) {\n            b1 = s - w0 - w1 - b0;\n            if (c[s] < 0 || c[s] == 1) {\n              for (int x = 0; x <= b1; x++) {\n                int &z = dp[s + 1][w0 + (x) % 2][w1 + (x + 1) % 2][b0];\n                z = (z + pre * p2[s - b1] % mo * bi[b1][x]) % mo;\n              }\n            }\n            if (c[s] < 0 || c[s] == 0) {\n              for (int x = 0; x <= w1; x++) {\n                int &z = dp[s + 1][w0][w1][b0 + x % 2];\n                z = (z + pre * p2[s - w1] % mo * bi[w1][x]) % mo;\n              }\n            }\n          }\n  }\n  int re = 0;\n  for (int w0 = 0; w0 <= n; w0++)\n    for (int w1 = 0; w1 + w0 <= n; w1++)\n      for (int b0 = 0; b0 + w0 + w1 <= n; b0++) {\n        b1 = n - w0 - w1 - b0;\n        if ((w1 + b1) % 2 == p) re = (re + dp[n][w0][w1][b0]) % mo;\n      }\n  return re;\n}\nint main() {\n  cin >> n >> p;\n  for (int i = 0; i < n; i++) cin >> c[i];\n  cout << ans() << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100, mod = 1e9 + 7;\nint n, k, ans, a[maxn], pw[maxn], f[2][2][2][2];\nint read() {\n  int x = 0, f = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') x = x * 10 + (c ^ 48), c = getchar();\n  return x * f;\n}\nint main() {\n  n = read(), k = read(), pw[0] = 1;\n  for (int i = 1; i <= n; i++) a[i] = read(), pw[i] = pw[i - 1] * 2 % mod;\n  if (a[1] != 0) f[1][1][1][0] = 1;\n  if (a[1] != 1) f[1][1][0][1] = 1;\n  for (int i = 1; i < n; i++) {\n    for (int j = 0; j <= 1; j++) {\n      for (int p = 0; p <= 1; p++) {\n        for (int q = 0; q <= 1; q++) {\n          if (a[i + 1] != 0) {\n            if (q) {\n              f[i & 1 ^ 1][j][p][q] =\n                  (f[i & 1 ^ 1][j][p][q] +\n                   1ll * f[i & 1][j][p][q] * pw[i - 1] % mod) %\n                  mod;\n              f[i & 1 ^ 1][j ^ 1][1][q] =\n                  (f[i & 1 ^ 1][j ^ 1][1][q] +\n                   1ll * f[i & 1][j][p][q] * pw[i - 1] % mod) %\n                  mod;\n            } else\n              f[i & 1 ^ 1][j ^ 1][1][q] =\n                  (f[i & 1 ^ 1][j ^ 1][1][q] +\n                   1ll * f[i & 1][j][p][q] * pw[i] % mod) %\n                  mod;\n          }\n          if (a[i + 1] != 1) {\n            if (p) {\n              f[i & 1 ^ 1][j][p][q] =\n                  (f[i & 1 ^ 1][j][p][q] +\n                   1ll * f[i & 1][j][p][q] * pw[i - 1] % mod) %\n                  mod;\n              f[i & 1 ^ 1][j ^ 1][p][1] =\n                  (f[i & 1 ^ 1][j ^ 1][p][1] +\n                   1ll * f[i & 1][j][p][q] * pw[i - 1] % mod) %\n                  mod;\n            } else\n              f[i & 1 ^ 1][j ^ 1][p][1] =\n                  (f[i & 1 ^ 1][j ^ 1][p][1] +\n                   1ll * f[i & 1][j][p][q] * pw[i] % mod) %\n                  mod;\n          }\n          f[i & 1][j][p][q] = 0;\n        }\n      }\n    }\n  }\n  for (int p = 0; p <= 1; p++)\n    for (int q = 0; q <= 1; q++) ans = (ans + f[n & 1][k][p][q]) % mod;\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long dp[55][55][55][55];\nint n, typ;\nint c[55];\nlong long mul[55];\nint main() {\n  scanf(\"%d%d\", &n, &typ);\n  mul[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &c[i]);\n    mul[i] = (mul[i - 1] << 1) % 1000000007;\n  }\n  long long ret = 0;\n  if (c[1] == 0 || c[1] == -1) {\n    dp[1][0][1][0] = 1;\n    if (typ == 1 && n == 1) {\n      ret++;\n    }\n  }\n  if (c[1] == 1 || c[1] == -1) {\n    dp[1][1][0][0] = 1;\n    if (typ == 1 && n == 1) {\n      ret++;\n    }\n  }\n  for (int i = 2; i <= n; i++) {\n    for (int j = 0; j <= i; j++) {\n      for (int k = 0; k + j <= i; k++) {\n        for (int p = 0; j + k + p <= i; p++) {\n          int t = i - j - k - p;\n          if (c[i] == 1 || c[i] == -1) {\n            long long s = 0;\n            if (j + p) {\n              if (j) {\n                if (!k) {\n                  s += dp[i - 1][j - 1][k][p];\n                } else {\n                  s += mul[k - 1] * dp[i - 1][j - 1][k][p] % 1000000007;\n                }\n                s %= 1000000007;\n              }\n              if (p) {\n                if (k) {\n                  s += mul[k - 1] * dp[i - 1][j][k][p - 1] % 1000000007;\n                }\n                s %= 1000000007;\n              }\n            }\n            s *= mul[j + p + t - 1];\n            s %= 1000000007;\n            dp[i][j][k][p] += s;\n            dp[i][j][k][p] %= 1000000007;\n          }\n          if (c[i] == 0 || c[i] == -1) {\n            long long s = 0;\n            if (k + t) {\n              if (k) {\n                if (!j) {\n                  s += dp[i - 1][j][k - 1][p];\n                } else {\n                  s += mul[j - 1] * dp[i - 1][j][k - 1][p] % 1000000007;\n                }\n                s %= 1000000007;\n              }\n              if (t) {\n                if (j) {\n                  s += mul[j - 1] * dp[i - 1][j][k][p] % 1000000007;\n                }\n                s %= 1000000007;\n              }\n            }\n            s *= mul[k + p + t - 1];\n            s %= 1000000007;\n            dp[i][j][k][p] += s;\n            dp[i][j][k][p] %= 1000000007;\n          }\n          if (i == n) {\n            if ((j + k) % 2 == typ) {\n              ret += dp[i][j][k][p];\n              ret %= 1000000007;\n            }\n          }\n        }\n      }\n    }\n  }\n  printf(\"%lld\\n\", ret);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int inf = 1e16;\nlong long int mod = 1e9 + 7;\nchar en = '\\n';\nlong long int abs1(long long int x) {\n  if (x < 0) return -x;\n  return x;\n}\nlong long int power(long long int x, long long int n, long long int mod) {\n  long long int res = 1;\n  x %= mod;\n  while (n) {\n    if (n & 1) res = (res * x) % mod;\n    x = (x * x) % mod;\n    n >>= 1;\n  }\n  return res;\n}\nlong long int dp[55][55][55][55];\nlong long int arr[55];\nlong long int pow2[55];\nvector<long long int> choices[55];\nlong long int myPow(long long int a, long long int n, long long int flag) {\n  if (n < 0) {\n    return flag;\n  }\n  return pow2[n];\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  memset(dp, 0, sizeof(dp));\n  pow2[0] = 1;\n  for (long long int i = 1; i < 55; i++) {\n    pow2[i] = (pow2[i - 1] * 2) % mod;\n  }\n  long long int n;\n  long long int p;\n  cin >> n >> p;\n  for (long long int i = 1; i <= n; i++) {\n    cin >> arr[i];\n    if (arr[i] != -1)\n      choices[i].push_back(arr[i]);\n    else {\n      choices[i].push_back(0);\n      choices[i].push_back(1);\n    }\n  }\n  dp[0][0][0][0] = 1;\n  for (long long int i = 1; i <= n; i++) {\n    for (long long int bo = 0; bo <= i; bo++) {\n      for (long long int be = 0; be <= i - bo; be++) {\n        for (long long int wo = 0; wo <= i - bo - be; wo++) {\n          long long int we = i - bo - be - wo;\n          for (long long int type : choices[i]) {\n            if (type == 1) {\n              if ((wo - 1) >= 0) {\n                dp[i][bo][be][wo] += pow2[be + wo + we - 1] *\n                                     dp[i - 1][bo][be][wo - 1] % mod *\n                                     myPow(2, bo - 1, 1) % mod;\n                if (dp[i][bo][be][wo] >= mod) dp[i][bo][be][wo] -= mod;\n              }\n              if ((we - 1) >= 0) {\n                dp[i][bo][be][wo] += pow2[be + wo + we - 1] *\n                                     dp[i - 1][bo][be][wo] % mod *\n                                     myPow(2, bo - 1, 0) % mod;\n                if (dp[i][bo][be][wo] >= mod) dp[i][bo][be][wo] -= mod;\n              }\n            } else {\n              if ((bo - 1) >= 0) {\n                dp[i][bo][be][wo] += pow2[we + bo + be - 1] *\n                                     dp[i - 1][bo - 1][be][wo] % mod *\n                                     myPow(2, wo - 1, 1) % mod;\n                if (dp[i][bo][be][wo] >= mod) dp[i][bo][be][wo] -= mod;\n              }\n              if ((be - 1) >= 0) {\n                dp[i][bo][be][wo] += pow2[we + bo + be - 1] *\n                                     dp[i - 1][bo][be - 1][wo] % mod *\n                                     myPow(2, wo - 1, 0) % mod;\n                if (dp[i][bo][be][wo] >= mod) dp[i][bo][be][wo] -= mod;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  long long int res = 0;\n  for (long long int bo = 0; bo <= n; bo++) {\n    for (long long int be = 0; be <= n - bo; be++) {\n      for (long long int wo = 0; wo <= n - bo - be; wo++) {\n        long long int we = n - bo - be - wo;\n        long long int parity = (bo & 1) ^ (wo & 1);\n        if (parity == p) res += dp[n][bo][be][wo];\n        if (res >= mod) res -= mod;\n      }\n    }\n  }\n  cout << res << en;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint c[105];\nlong long two[105];\nint n, p;\nlong long power(long long a, long long b) {\n  if (b == 0) return 1;\n  long long f = power(a, b / 2);\n  f = (f * f) % 1000000007;\n  if (b % 2) return (a * f) % 1000000007;\n  return f;\n}\nlong long dp[55][55][55][55][2];\nint main() {\n  cin >> n >> p;\n  for (int i = 1; i <= n; ++i) cin >> c[i];\n  two[0] = 1;\n  for (int i = 1; i <= 100; ++i) {\n    two[i] = (2 * two[i - 1]) % 1000000007;\n  }\n  dp[0][0][0][0][0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 0; j < i; ++j) {\n      for (int k = 0; k + j < i; ++k) {\n        for (int l = 0; j + k + l < i; ++l) {\n          int m = i - 1 - j - k - l;\n          for (int p = 0; p < 2; ++p) {\n            if (c[i] != 0) {\n              long long zeroodd = j;\n              long long oneodd = k;\n              long long zeroeven = l;\n              long long oneeven = m;\n              long long temp = 1;\n              if (j) temp = (temp * two[j - 1]) % 1000000007;\n              temp = (temp * two[k + l + m]) % 1000000007;\n              dp[i][j][k + 1][l][(p + 1) % 2] =\n                  (dp[i][j][k + 1][l][(p + 1) % 2] +\n                   dp[i - 1][j][k][l][p] * temp) %\n                  1000000007;\n              if (j == 0) temp = 0;\n              dp[i][j][k][l][p] =\n                  (dp[i][j][k][l][p] + dp[i - 1][j][k][l][p] * temp) %\n                  1000000007;\n            }\n            if (c[i] != 1) {\n              long long zeroodd = j;\n              long long oneodd = k;\n              long long zeroeven = l;\n              long long oneeven = m;\n              long long temp = 1;\n              if (k) temp = (temp * two[k - 1]) % 1000000007;\n              temp = (temp * two[j + l + m]) % 1000000007;\n              dp[i][j + 1][k][l][(p + 1) % 2] =\n                  (dp[i][j + 1][k][l][(p + 1) % 2] +\n                   dp[i - 1][j][k][l][p] * temp) %\n                  1000000007;\n              if (k == 0) temp = 0;\n              dp[i][j][k][l + 1][p] =\n                  (dp[i][j][k][l + 1][p] + dp[i - 1][j][k][l][p] * temp) %\n                  1000000007;\n            }\n          }\n        }\n      }\n    }\n  }\n  long long ans = 0;\n  for (int j = 0; j <= n; ++j) {\n    for (int k = 0; k <= n; ++k) {\n      for (int l = 0; l <= n; ++l) {\n        ans = (ans + dp[n][j][k][l][p]) % 1000000007;\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 52, mod = 1e9 + 7;\nint n, p, s, ans, a[N], Pow[N], dp[N][N][N];\nvoid calc1(int sia, int sef) {\n  if (sia + sef > s) return;\n  if (sef) {\n    if (sia)\n      dp[s][sia][sef] = 1ll * dp[s - 1][sia][sef - 1] * Pow[s - 2] % mod;\n    else\n      dp[s][sia][sef] = 1ll * dp[s - 1][sia][sef - 1] * Pow[s - 1] % mod;\n  }\n  if (sia + sef == s || sia == 0) return;\n  dp[s][sia][sef] =\n      (dp[s][sia][sef] + 1ll * dp[s - 1][sia][sef] * Pow[s - 2] % mod) % mod;\n}\nvoid calc0(int fs, int sef) {\n  if (fs + sef > s) return;\n  if (fs) {\n    if (sef)\n      dp[s][fs][sef] =\n          (dp[s][fs][sef] + 1ll * dp[s - 1][fs - 1][sef] * Pow[s - 2] % mod) %\n          mod;\n    else\n      dp[s][fs][sef] =\n          (dp[s][fs][sef] + 1ll * dp[s - 1][fs - 1][sef] * Pow[s - 1] % mod) %\n          mod;\n  }\n  if (fs + sef == s || sef == 0) return;\n  dp[s][fs][sef] =\n      (dp[s][fs][sef] + 1ll * dp[s - 1][fs][sef] * Pow[s - 2] % mod) % mod;\n}\nint main() {\n  Pow[0] = 1;\n  for (int i = 1; i < N; i++) Pow[i] = Pow[i - 1] * 2ll % mod;\n  cin >> n >> p;\n  for (int i = 1; i < n + 1; i++) scanf(\"%d\", &a[i]);\n  ;\n  dp[1][1][0] = (a[1] != 1);\n  dp[1][0][1] = (a[1] != 0);\n  for (int an = 2; an < n + 1; an++) {\n    s = an;\n    for (int i = 0; i < n + 1; i++)\n      for (int j = 0; j < n + 1; j++) {\n        if (a[an] != 0) calc1(i, j);\n        if (a[an] != 1) calc0(i, j);\n      }\n  }\n  for (int i = 0; i < n + 1; i++)\n    for (int j = 0; j < n + 1; j++)\n      if ((i + j) % 2 == p) ans = (ans + dp[n][i][j]) % mod;\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 200005;\nconst int cIz = 1000000007;\nint n, p, pw2[N], c[N], f[2][2][3];\ninline void add(int a, int b, int &c) { c = (c + (long long)a * b) % cIz; }\ninline void calc(int i, int c) {\n  int I = i & 1;\n  for (int j = 0; j < 2; ++j) {\n    add(f[I][j][c], pw2[i], f[I ^ 1][j ^ 1][c]);\n    add(f[I][j][c ^ 1], pw2[i - 1], f[I ^ 1][j ^ 1][2]);\n    add(f[I][j][c ^ 1], pw2[i - 1], f[I ^ 1][j][c ^ 1]);\n    add(f[I][j][2], pw2[i - 1], f[I ^ 1][j ^ 1][2]);\n    add(f[I][j][2], pw2[i - 1], f[I ^ 1][j][2]);\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &p);\n  pw2[0] = 1;\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", c + i);\n  if (c[1] != 1) f[1][1][0] = 1;\n  if (c[1] != 0) f[1][1][1] = 1;\n  for (int i = 1; i < n; ++i) {\n    pw2[i] = pw2[i - 1] * 2 % cIz;\n    memset(f[(i & 1) ^ 1], 0, sizeof(f[0]));\n    if (c[i + 1] != 1) calc(i, 0);\n    if (c[i + 1] != 0) calc(i, 1);\n  }\n  int *b = f[n & 1][p];\n  int ans = ((long long)b[0] + b[1] + b[2]) % cIz;\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 55;\nconst int mod = 1e9 + 7;\nint odd[N];\nint even[N];\nint frac[N];\nint inv[N];\nint a[N];\nint pw[N];\nint dp[N][N][N][N];\nint n, p;\nint C(int k, int n) {\n  return (long long)frac[n] * inv[k] % mod * inv[n - k] % mod;\n}\nint binpow(int n, int k) {\n  int res = 1;\n  while (k > 0) {\n    if (k & 1) res = (long long)res * n % mod;\n    k >>= 1;\n    n = (long long)n * n % mod;\n  }\n  return res;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> p;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  frac[0] = 1;\n  for (int i = 1; i <= n; i++) frac[i] = (long long)frac[i - 1] * i % mod;\n  inv[n] = binpow(frac[n], mod - 2);\n  for (int i = n - 1; i >= 0; i--)\n    inv[i] = (long long)inv[i + 1] * (i + 1) % mod;\n  pw[0] = 1;\n  for (int i = 1; i <= n; i++) pw[i] = 2 * pw[i - 1] % mod;\n  for (int i = 0; i <= n; i++) {\n    for (int j = 0; j <= i; j += 2) even[i] = (even[i] + C(j, i)) % mod;\n    for (int j = 1; j <= i; j += 2) odd[i] = (odd[i] + C(j, i)) % mod;\n  }\n  int ans = 0;\n  dp[0][0][0][0] = 1;\n  for (int i = 1; i <= n; i++)\n    for (int ob = 0; ob <= i; ob++)\n      for (int ow = 0; ob + ow <= i; ow++)\n        for (int eb = 0; eb + ob + ow <= i; eb++) {\n          int ew = i - ob - ow - eb;\n          long long res = 0;\n          if (a[i] != 0 && ob > 0)\n            res += (long long)pw[ob + eb + ew - 1] * even[ow] % mod *\n                   dp[ob - 1][ow][eb][ew];\n          if (a[i] != 0 && eb > 0)\n            res += (long long)pw[ob + eb + ew - 1] * odd[ow] % mod *\n                   dp[ob][ow][eb - 1][ew];\n          if (a[i] != 1 && ow > 0)\n            res += (long long)pw[ew + ow + eb - 1] * even[ob] % mod *\n                   dp[ob][ow - 1][eb][ew];\n          if (a[i] != 1 && ew > 0)\n            res += (long long)pw[ew + ow + eb - 1] * odd[ob] % mod *\n                   dp[ob][ow][eb][ew - 1];\n          dp[ob][ow][eb][ew] = res % mod;\n          if (i == n && ((ow + ob) % 2 == p)) ans = (ans + res) % mod;\n        }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 50;\nconst int MOD = 1E9 + 7;\nint dp[MAXN + 1][2][MAXN + 1][MAXN + 1][MAXN + 1];\nint c[MAXN + 1];\nint twopow[MAXN + 1];\nint fac[MAXN + 1];\nint invFac[MAXN + 1];\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= MOD) a -= MOD;\n}\nint modpow(int b, int e) {\n  int ans = 1;\n  while (e) {\n    if (e & 1) ans = (int)((long long)ans * b % MOD);\n    b = (int)((long long)b * b % MOD);\n    e >>= 1;\n  }\n  return ans;\n}\nint modinv(int x) { return modpow(x, MOD - 2); }\nint choose(int n, int k) {\n  int ans = (int)((long long)fac[n] * invFac[k] % MOD);\n  return (int)((long long)ans * invFac[n - k] % MOD);\n}\nint chooseSum(int n, int k) {\n  int ans = 0;\n  while (k <= n) {\n    ans += choose(n, k);\n    if (ans >= MOD) ans -= MOD;\n    k += 2;\n  }\n  return ans;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  twopow[0] = 1;\n  fac[0] = invFac[0] = 1;\n  for (int i = 1; i <= MAXN; i++) {\n    twopow[i] = (int)((long long)twopow[i - 1] * 2 % MOD);\n    fac[i] = (int)((long long)fac[i - 1] * i % MOD);\n    invFac[i] = modinv(fac[i]);\n  }\n  int n, p;\n  cin >> n >> p;\n  for (int i = 1; i <= n; i++) {\n    cin >> c[i];\n  }\n  dp[0][0][0][0][0] = 1;\n  for (int len = 1; len <= n; len++) {\n    for (int par = 0; par < 2; par++) {\n      for (int ew = 0; ew <= len; ew++) {\n        for (int ow = 0; ow + ew <= len; ow++) {\n          for (int eb = 0; eb + ow + ew <= len; eb++) {\n            int ob = len - ew - ow - eb;\n            if (ew && c[len] != 0) {\n              int val = dp[len - 1][par][ew - 1][ow][eb];\n              val = (int)((long long)val * twopow[eb] % MOD);\n              val = (int)((long long)val * twopow[ow] % MOD);\n              val = (int)((long long)val * twopow[ew - 1] % MOD);\n              val = (int)((long long)val * chooseSum(ob, 1) % MOD);\n              add(dp[len][par][ew][ow][eb], val);\n            }\n            if (ow && c[len] != 0) {\n              int val = dp[len - 1][!par][ew][ow - 1][eb];\n              val = (int)((long long)val * twopow[eb] % MOD);\n              val = (int)((long long)val * twopow[ow - 1] % MOD);\n              val = (int)((long long)val * twopow[ew] % MOD);\n              val = (int)((long long)val * chooseSum(ob, 0) % MOD);\n              add(dp[len][par][ew][ow][eb], val);\n            }\n            if (eb && c[len] != 1) {\n              int val = dp[len - 1][par][ew][ow][eb - 1];\n              val = (int)((long long)val * twopow[ew] % MOD);\n              val = (int)((long long)val * twopow[ob] % MOD);\n              val = (int)((long long)val * twopow[eb - 1] % MOD);\n              val = (int)((long long)val * chooseSum(ow, 1) % MOD);\n              add(dp[len][par][ew][ow][eb], val);\n            }\n            if (ob && c[len] != 1) {\n              int val = dp[len - 1][!par][ew][ow][eb];\n              val = (int)((long long)val * twopow[ew] % MOD);\n              val = (int)((long long)val * twopow[ob - 1] % MOD);\n              val = (int)((long long)val * twopow[eb] % MOD);\n              val = (int)((long long)val * chooseSum(ow, 0) % MOD);\n              add(dp[len][par][ew][ow][eb], val);\n            }\n          }\n        }\n      }\n    }\n  }\n  int ans = 0;\n  for (int ew = 0; ew <= n; ew++) {\n    for (int ow = 0; ow + ew <= n; ow++) {\n      for (int eb = 0; eb + ow + ew <= n; eb++) {\n        add(ans, dp[n][p][ew][ow][eb]);\n      }\n    }\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nint n, g[200010];\nlong long f[200010][2][2][2], ba[200010], ans = 0, p;\nint main() {\n  cin >> n >> p;\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &g[i]);\n  ba[0] = 1;\n  for (int i = 1; i <= n; i++) ba[i] = ba[i - 1] * 2 % mod;\n  f[0][0][0][0] = 1;\n  for (int i = 1; i <= n; i++)\n    for (int j = 0; j < 2; j++)\n      for (int k = 0; k < 2; k++)\n        for (int h = 0; h < 2; h++) {\n          if (!f[i - 1][j][k][h]) continue;\n          long long tt = f[i - 1][j][k][h];\n          if (g[i] != 0) {\n            if (!j)\n              f[i][0][1][h ^ 1] =\n                  (f[i][0][1][h ^ 1] + tt * ba[i - 1] % mod) % mod;\n            else\n              f[i][1][1][h ^ 1] =\n                  (f[i][1][1][h ^ 1] + tt * ba[i - 2] % mod) % mod,\n                             f[i][1][k][h] =\n                                 (f[i][1][k][h] + tt * ba[i - 2] % mod) % mod;\n          }\n          if (g[i] != 1) {\n            if (!k)\n              f[i][1][0][h ^ 1] =\n                  (f[i][1][0][h ^ 1] + tt * ba[i - 1] % mod) % mod;\n            else\n              f[i][1][1][h ^ 1] =\n                  (f[i][1][1][h ^ 1] + tt * ba[i - 2] % mod) % mod,\n                             f[i][j][1][h] =\n                                 (f[i][j][1][h] + tt * ba[i - 2] % mod) % mod;\n          }\n        }\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 2; j++) ans = (ans + f[n][i][j][p]) % mod;\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, p, col[51];\nlong long bin[51], dp[51][2][2][2];\nint main() {\n  scanf(\"%d%d\", &n, &p);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &col[i]);\n  }\n  bin[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    bin[i] = bin[i - 1] * 2ll % 1000000007;\n  }\n  dp[0][0][0][0] = 1ll;\n  for (int i = 1; i <= n; i++) {\n    for (int w = 0; w <= 1; w++) {\n      for (int b = 0; b <= 1; b++) {\n        for (int l = 0; l <= 1; l++) {\n          int lt = dp[i - 1][w][b][l];\n          if (!lt) {\n            continue;\n          }\n          if (col[i]) {\n            if (!b) {\n              dp[i][1][b][l ^ 1] =\n                  (dp[i][1][b][l ^ 1] + lt * bin[i - 1] % 1000000007) %\n                  1000000007;\n            } else {\n              dp[i][1][b][l ^ 1] =\n                  (dp[i][1][b][l ^ 1] + lt * bin[i - 2] % 1000000007) %\n                  1000000007;\n              dp[i][w][b][l] =\n                  (dp[i][w][b][l] + lt * bin[i - 2] % 1000000007) % 1000000007;\n            }\n          }\n          if (col[i] != 1) {\n            if (!w) {\n              dp[i][w][1][l ^ 1] =\n                  (dp[i][w][1][l ^ 1] + lt * bin[i - 1] % 1000000007) %\n                  1000000007;\n            } else {\n              dp[i][w][1][l ^ 1] =\n                  (dp[i][w][1][l ^ 1] + lt * bin[i - 2] % 1000000007) %\n                  1000000007;\n              dp[i][w][b][l] =\n                  (dp[i][w][b][l] + lt * bin[i - 2] % 1000000007) % 1000000007;\n            }\n          }\n        }\n      }\n    }\n  }\n  long long ans = 0;\n  for (int w = 0; w <= 1; w++) {\n    for (int b = 0; b <= 1; b++) {\n      ans = (ans + dp[n][w][b][p]) % 1000000007;\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, p;\nint a[5003], POW[5003], f[5003][2][2][2];\nint main() {\n  scanf(\"%d%d\", &n, &p);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  POW[0] = 1;\n  for (int i = 1; i <= n; i++) POW[i] = 1ll * POW[i - 1] * 2 % 1000000007;\n  f[0][0][0][0] = 1;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j < 2; j++)\n      for (int k = 0; k < 2; k++)\n        for (int l = 0; l < 2; l++) {\n          int res = f[i - 1][j][k][l];\n          if (!res) continue;\n          if (a[i] != 0) {\n            if (!j)\n              f[i][0][1][l ^ 1] =\n                  (f[i][0][1][l ^ 1] + 1ll * res * POW[i - 1] % 1000000007) %\n                  1000000007;\n            else {\n              f[i][1][1][l ^ 1] =\n                  (f[i][1][1][l ^ 1] + 1ll * res * POW[i - 2] % 1000000007) %\n                  1000000007;\n              f[i][1][k][l] =\n                  (f[i][1][k][l] + 1ll * res * POW[i - 2] % 1000000007) %\n                  1000000007;\n            }\n          }\n          if (a[i] != 1) {\n            if (!k)\n              f[i][1][0][l ^ 1] =\n                  (f[i][1][0][l ^ 1] + 1ll * res * POW[i - 1] % 1000000007) %\n                  1000000007;\n            else {\n              f[i][1][1][l ^ 1] =\n                  (f[i][1][1][l ^ 1] + 1ll * res * POW[i - 2] % 1000000007) %\n                  1000000007;\n              f[i][j][1][l] =\n                  (f[i][j][1][l] + 1ll * res * POW[i - 2] % 1000000007) %\n                  1000000007;\n            }\n          }\n        }\n  }\n  int ans = 0;\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 2; j++) ans = (ans + f[n][i][j][p]) % 1000000007;\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 55, P = 1e9 + 7;\nint w[N], n, r, o, dp[N][2][2][2], ans;\nvoid inc(int& x, long long y) { x = (x + y) % P; }\nint main() {\n  scanf(\"%d%d\", &n, &r);\n  w[0] = 1;\n  for (int i = 1; i <= n; i++) w[i] = (w[i - 1] + w[i - 1]) % P;\n  scanf(\"%d\", &o);\n  if (o != 1) dp[1][1][0][1] = 1;\n  if (o != 0) dp[1][0][1][1] = 1;\n  for (int i = 2; i <= n; i++) {\n    int o;\n    scanf(\"%d\", &o);\n    if (o != 1) {\n      for (int j = 0; j < 2; ++j)\n        for (int k = 0; k < 2; ++k) {\n          inc(dp[i][j | 1][1][!k], (long long)dp[i - 1][j][1][k] * w[i - 2]);\n          inc(dp[i][j][1][k], (long long)dp[i - 1][j][1][k] * w[i - 2]);\n        }\n      inc(dp[i][1][0][0], (long long)dp[i - 1][1][0][1] * w[i - 1]);\n      inc(dp[i][1][0][1], (long long)dp[i - 1][1][0][0] * w[i - 1]);\n    }\n    if (o != 0) {\n      for (int j = 0; j < 2; ++j)\n        for (int k = 0; k < 2; ++k) {\n          inc(dp[i][1][j | 1][!k], (long long)dp[i - 1][1][j][k] * w[i - 2]);\n          inc(dp[i][1][j][k], (long long)dp[i - 1][1][j][k] * w[i - 2]);\n        }\n      inc(dp[i][0][1][0], (long long)dp[i - 1][0][1][1] * w[i - 1]);\n      inc(dp[i][0][1][1], (long long)dp[i - 1][0][1][0] * w[i - 1]);\n    }\n  }\n  for (int j = 0; j < 2; ++j)\n    for (int k = 0; k < 2; ++k) inc(ans, dp[n][j][k][r]);\n  printf(\"%d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline void amin(T &x, const T &y) {\n  if (y < x) x = y;\n}\ntemplate <class T>\ninline void amax(T &x, const T &y) {\n  if (x < y) x = y;\n}\ntemplate <class Iter>\nvoid rprintf(const char *fmt, Iter begin, Iter end) {\n  for (bool sp = 0; begin != end; ++begin) {\n    if (sp)\n      putchar(' ');\n    else\n      sp = true;\n    printf(fmt, *begin);\n  }\n  putchar('\\n');\n}\ntemplate <unsigned MOD>\nstruct ModInt {\n  static const unsigned static_MOD = MOD;\n  unsigned x;\n  void undef() { x = (unsigned)-1; }\n  bool isnan() const { return x == (unsigned)-1; }\n  inline int geti() const { return (int)x; }\n  ModInt() { x = 0; }\n  ModInt(const ModInt &y) { x = y.x; }\n  ModInt(int y) {\n    if (y < 0 || (int)MOD <= y) y %= (int)MOD;\n    if (y < 0) y += MOD;\n    x = y;\n  }\n  ModInt(unsigned y) {\n    if (MOD <= y)\n      x = y % MOD;\n    else\n      x = y;\n  }\n  ModInt(long long y) {\n    if (y < 0 || MOD <= y) y %= MOD;\n    if (y < 0) y += MOD;\n    x = y;\n  }\n  ModInt(unsigned long long y) {\n    if (MOD <= y)\n      x = y % MOD;\n    else\n      x = y;\n  }\n  ModInt &operator+=(const ModInt y) {\n    if ((x += y.x) >= MOD) x -= MOD;\n    return *this;\n  }\n  ModInt &operator-=(const ModInt y) {\n    if ((x -= y.x) & (1u << 31)) x += MOD;\n    return *this;\n  }\n  ModInt &operator*=(const ModInt y) {\n    x = (unsigned long long)x * y.x % MOD;\n    return *this;\n  }\n  ModInt &operator/=(const ModInt y) {\n    x = (unsigned long long)x * y.inv().x % MOD;\n    return *this;\n  }\n  ModInt operator-() const { return (x ? MOD - x : 0); }\n  ModInt inv() const {\n    unsigned a = MOD, b = x;\n    int u = 0, v = 1;\n    while (b) {\n      int t = a / b;\n      a -= t * b;\n      swap(a, b);\n      u -= t * v;\n      swap(u, v);\n    }\n    if (u < 0) u += MOD;\n    return ModInt(u);\n  }\n  ModInt pow(long long y) const {\n    ModInt b = *this, r = 1;\n    if (y < 0) {\n      b = b.inv();\n      y = -y;\n    }\n    for (; y; y >>= 1) {\n      if (y & 1) r *= b;\n      b *= b;\n    }\n    return r;\n  }\n  friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n  friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n  friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n  friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n  friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n  friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n  friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\nconst long long MOD = 1000000007;\nconst int MAX = 100;\nModInt<MOD> inv[MAX + 1], fact[MAX + 1], fact_inv[MAX + 1];\nvoid init() {\n  inv[1] = 1;\n  for (int i = 2; i <= MAX; i++) inv[i] = inv[MOD % i] * (MOD - MOD / i);\n  fact[0] = fact_inv[0] = 1;\n  for (int i = 1; i <= MAX; i++) {\n    fact[i] = fact[i - 1] * i;\n    fact_inv[i] = fact_inv[i - 1] * inv[i];\n  }\n}\nModInt<MOD> nCk(int n, int k) {\n  return fact[n] * fact_inv[k] * fact_inv[n - k];\n}\nint N, P;\nint C[55];\nModInt<MOD> dp[55][55][55][55];\nvoid MAIN() {\n  scanf(\"%d%d\", &N, &P);\n  for (int i = 0, i_len = (N); i < i_len; ++i) scanf(\"%d\", C + i);\n  init();\n  dp[0][0][0][0] = 1;\n  for (int i = 0, i_len = (N); i < i_len; ++i)\n    for (int EB = 0, EB_len = (i + 1); EB < EB_len; ++EB)\n      for (int EW = 0, EW_len = (i + 1 - EB); EW < EW_len; ++EW)\n        for (int OB = 0, OB_len = (i + 1 - EB - EW); OB < OB_len; ++OB) {\n          ModInt<MOD> val = dp[i][EB][EW][OB];\n          if (val.x == 0u) continue;\n          int OW = i - EB - EW - OB;\n          if (C[i] != 1) {\n            for (int ow = 0, ow_len = (OW + 1); ow < ow_len; ++ow) {\n              int mypath = (ow + 1) & 1;\n              int nEB = EB + (mypath == 0);\n              int nOB = OB + (mypath == 1);\n              dp[i + 1][nEB][EW][nOB] += val * nCk(OW, ow) * (1LL << (i - OW));\n            }\n          }\n          if (C[i] != 0) {\n            for (int ob = 0, ob_len = (OB + 1); ob < ob_len; ++ob) {\n              int mypath = (ob + 1) & 1;\n              int nEW = EW + (mypath == 0);\n              int nOW = OW + (mypath == 1);\n              dp[i + 1][EB][nEW][OB] += val * nCk(OB, ob) * (1LL << (i - OB));\n            }\n          }\n        }\n  ModInt<MOD> ans = 0;\n  for (int EB = 0, EB_len = (N + 1); EB < EB_len; ++EB)\n    for (int EW = 0, EW_len = (N + 1 - EB); EW < EW_len; ++EW)\n      for (int OB = 0, OB_len = (N + 1 - EB - EW); OB < OB_len; ++OB) {\n        int OW = N - EB - EW - OB;\n        int parity = (OB + OW) & 1;\n        if (parity == P) ans += dp[N][EB][EW][OB];\n      }\n  printf(\"%d\\n\", ans.geti());\n}\nint main() {\n  int TC = 1;\n  for (int tc = 0, tc_len = (TC); tc < tc_len; ++tc) MAIN();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long get() {\n  long long x = 0, f = 1;\n  char c = getchar();\n  while (!isdigit(c)) {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (isdigit(c)) {\n    x = x * 10 + c - '0';\n    c = getchar();\n  }\n  return x * f;\n}\nconst long long N = 55, P = 1e9 + 7;\nlong long n, p, a[N], f[N][N][N][N], qpow[N], ans;\nvoid init() {\n  qpow[0] = 1;\n  for (long long i = 1; i <= n; i++) qpow[i] = qpow[i - 1] * 2 % P;\n}\nsigned main() {\n  n = get(), p = get();\n  for (long long i = 1; i <= n; i++) a[i] = get();\n  init();\n  if (a[1] == 0 || a[1] == -1) f[1][1][0][0] = 1;\n  if (a[1] == 1 || a[1] == -1) f[1][0][0][1] = 1;\n  for (long long i = 1; i <= n; i++)\n    for (long long j = 0; j <= i; j++)\n      for (long long k = 0; j + k <= i; k++)\n        for (long long l = 0; j + k + l <= i; l++) {\n          if (i == n) {\n            if (((j + l) & 1) == p) (ans += f[i][j][k][l]) %= P;\n            continue;\n          }\n          long long now = f[i][j][k][l];\n          if (a[i + 1] == 0 || a[i + 1] == -1) {\n            if (l) {\n              (f[i + 1][j + 1][k][l] +=\n               now * qpow[l - 1] % P * qpow[i - l] % P) %= P;\n              (f[i + 1][j][k + 1][l] +=\n               now * qpow[l - 1] % P * qpow[i - l] % P) %= P;\n            } else {\n              (f[i + 1][j + 1][k][l] += now * qpow[i] % P) %= P;\n            }\n          }\n          if (a[i + 1] == 1 || a[i + 1] == -1) {\n            if (j) {\n              (f[i + 1][j][k][l + 1] +=\n               now * qpow[j - 1] % P * qpow[i - j] % P) %= P;\n              (f[i + 1][j][k][l] += now * qpow[j - 1] % P * qpow[i - j] % P) %=\n                  P;\n            } else {\n              (f[i + 1][j][k][l + 1] += now * qpow[i] % P) %= P;\n            }\n          }\n        }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Codeforces979E {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint p = Integer.parseInt(st.nextToken());\n\t\tint[] c = new int[n];\n\t\tst = new StringTokenizer(br.readLine());\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tc[i] = Integer.parseInt(st.nextToken());\n\t\t}\n\t\t\n\t\t//list of powers of 2 until 2^{n^2}, mod 1000000007\n\t\tint[] twopower = new int[n*n+1];\n\t\ttwopower[0] = 1;\n\t\tfor (int i = 1; i <= n*n; i++) {\n\t\t\ttwopower[i] = (2*twopower[i-1])%1000000007;\n\t\t}\n\t\t\n\t\t//Pascal's triangle until n choose k, mod 1000000007\n\t\tint[][] pascal = new int[n+1][n+1];\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tpascal[i][0] = 1;\n\t\t\tpascal[0][i] = 1;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tpascal[i][j] = (pascal[i][j-1]+pascal[i-1][j])%1000000007;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//dp[x][y][z] means the last x have all arrows intact\n\t\t//and there are y 0's and z 1's at the start with no\n\t\t//arrows going between them.\n\t\t//we only care when 0 <= x+y+z <= n.\n\t\t//answer is dp[n][0][0].\n\t\tint[][][] dp = new int[n+1][n+1][n+1];\n\t\t//base case of x = 0\n\t\tfor (int y = 0; y <= n; y++) {\n\t\t\tfor (int z = 0; z <= (n-y); z++) {\n\t\t\t\tif (p == (y+z)%2) {\n\t\t\t\t\tdp[0][y][z] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int x = 1; x <= n; x++) {\n\t\t\tfor (int y = 0; y <= (n-x); y++) {\n\t\t\t\tfor (int z = 0; z <= (n-x-y); z++) {\n\t\t\t\t\tif (c[n-x] != 1) {\n\t\t\t\t\t\tint evenmultiple;\n\t\t\t\t\t\tint oddmultiple;\n\t\t\t\t\t\tif (z == 0) {\n\t\t\t\t\t\t\tevenmultiple = 1;\n\t\t\t\t\t\t\toddmultiple = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tevenmultiple = twopower[z-1];\n\t\t\t\t\t\t\toddmultiple = twopower[z-1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlong evenk = (long) evenmultiple * (long) dp[x-1][y+1][z];\n\t\t\t\t\t\tevenk %= 1000000007;\n\t\t\t\t\t\tlong oddk = (long) oddmultiple * (long) dp[x-1][y][z];\n\t\t\t\t\t\toddk %= 1000000007;\n\t\t\t\t\t\toddk *= (long) twopower[x-1];\n\t\t\t\t\t\toddk %= 1000000007;\n\t\t\t\t\t\tlong totalk = evenk+oddk;\n\t\t\t\t\t\ttotalk *= twopower[y];\n\t\t\t\t\t\ttotalk %= 1000000007;\n\t\t\t\t\t\tdp[x][y][z] += (int) totalk;\n\t\t\t\t\t}\n\t\t\t\t\tif (c[n-x] != 0) {\n\t\t\t\t\t\tint evenmultiple;\n\t\t\t\t\t\tint oddmultiple;\n\t\t\t\t\t\tif (y == 0) {\n\t\t\t\t\t\t\tevenmultiple = 1;\n\t\t\t\t\t\t\toddmultiple = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tevenmultiple = twopower[y-1];\n\t\t\t\t\t\t\toddmultiple = twopower[y-1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlong evenk = (long) evenmultiple * (long) dp[x-1][y][z+1];\n\t\t\t\t\t\tevenk %= 1000000007;\n\t\t\t\t\t\tlong oddk = (long) oddmultiple * (long) dp[x-1][y][z];\n\t\t\t\t\t\toddk %= 1000000007;\n\t\t\t\t\t\toddk *= (long) twopower[x-1];\n\t\t\t\t\t\toddk %= 1000000007;\n\t\t\t\t\t\tlong totalk = evenk+oddk;\n\t\t\t\t\t\ttotalk *= twopower[z];\n\t\t\t\t\t\ttotalk %= 1000000007;\n\t\t\t\t\t\tdp[x][y][z] += (int) totalk;\n\t\t\t\t\t}\n\t\t\t\t\tdp[x][y][z] %= 1000000007;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpw.println(dp[n][0][0]);\n\t\t\n\t\tpw.close();\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long read() {\n  long long s = 0, w = 1;\n  char c;\n  while (c = getchar(), c > '9' || c < '0')\n    if (c == '-') w = -1;\n  while (c >= '0' && c <= '9') s = s * 10 + c - '0', c = getchar();\n  return s * w;\n}\nconst long long md = 1000000007;\nlong long n, p, f[2][2][2], g[2][2][2], B, BB;\ninline void Ad(long long &x, long long y) {\n  x = (x + y);\n  x -= (x >= md) ? md : 0;\n}\nsigned main() {\n  long long t, i, j, k, x, re = 0LL;\n  n = read();\n  p = read();\n  x = read();\n  B = 1LL;\n  BB = 2LL;\n  if (x != 1) g[1][1][0] = 1LL;\n  if (x != 0) g[1][0][1] = 1LL;\n  memmove(f, g, sizeof f);\n  for (t = 2; t <= n; t++) {\n    x = read();\n    memset(f, 0, sizeof f);\n    if (x != 1) {\n      for (i = 0; i <= 1; i++) {\n        for (j = 0; j <= 1; j++) {\n          for (k = 0; k <= 1; k++) {\n            if (k) {\n              Ad(f[i][j][k], g[i][j][k] * B % md);\n              Ad(f[i ^ 1][1][k], g[i][j][k] * B % md);\n            } else\n              Ad(f[i ^ 1][1][k], g[i][j][k] * BB % md);\n          }\n        }\n      }\n    }\n    if (x != 0) {\n      for (i = 0; i <= 1; i++) {\n        for (j = 0; j <= 1; j++) {\n          for (k = 0; k <= 1; k++) {\n            if (j) {\n              Ad(f[i][j][k], g[i][j][k] * B % md);\n              Ad(f[i ^ 1][j][1], g[i][j][k] * B % md);\n            } else\n              Ad(f[i ^ 1][j][1], g[i][j][k] * BB % md);\n          }\n        }\n      }\n    }\n    B = BB;\n    BB = (B << 1) % md;\n    for (i = 0; i <= 1; i++)\n      for (j = 0; j <= 1; j++)\n        for (k = 0; k <= 1; k++) g[i][j][k] = f[i][j][k] % md;\n  }\n  for (i = 0; i <= 1; i++)\n    for (j = 0; j <= 1; j++) Ad(re, f[p][i][j]);\n  printf(\"%lld\\n\", re);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nconst int N = 1e6 + 10;\nint n, type;\nint a[N], bit[N], f[N][2][2][2];\ntemplate <typename T>\ninline void chkmax(T &x, T y) {\n  x = max(x, y);\n}\ntemplate <typename T>\ninline void chkmin(T &x, T y) {\n  x = min(x, y);\n}\ntemplate <typename T>\ninline void read(T &x) {\n  T f = 1;\n  x = 0;\n  char c = getchar();\n  for (; !isdigit(c); c = getchar())\n    if (c == '-') f = -f;\n  for (; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + c - '0';\n  x *= f;\n}\ninline void add(int &x, int y) {\n  x += y;\n  while (x >= mod) x -= mod;\n}\nint main() {\n  read(n);\n  read(type);\n  for (int i = 1; i <= n; ++i) read(a[i]);\n  bit[0] = 1;\n  for (int i = 1; i <= n; ++i) bit[i] = 1LL * bit[i - 1] * 2 % mod;\n  f[0][0][0][0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    for (int tp = 0; tp <= 1; ++tp) {\n      for (int ob = 0; ob <= 1; ++ob) {\n        for (int ow = 0; ow <= 1; ++ow) {\n          if (a[i] != 0) {\n            if (ob) {\n              add(f[i][tp][ob][ow],\n                  1LL * f[i - 1][tp][ob][ow] * bit[i - 2] % mod);\n              add(f[i][tp ^ 1][ob][ow | 1],\n                  1LL * f[i - 1][tp][ob][ow] * bit[i - 2] % mod);\n            } else\n              add(f[i][tp ^ 1][ob][ow | 1],\n                  1LL * f[i - 1][tp][ob][ow] * bit[i - 1] % mod);\n          }\n          if (a[i] != 1) {\n            if (ow) {\n              add(f[i][tp][ob][ow],\n                  1LL * f[i - 1][tp][ob][ow] * bit[i - 2] % mod);\n              add(f[i][tp ^ 1][ob | 1][ow],\n                  1LL * bit[i - 2] * f[i - 1][tp][ob][ow] % mod);\n            } else\n              add(f[i][tp ^ 1][ob | 1][ow],\n                  1LL * f[i - 1][tp][ob][ow] * bit[i - 1] % mod);\n          }\n        }\n      }\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i <= 1; ++i)\n    for (int j = 0; j <= 1; ++j) add(ans, f[n][type][i][j]);\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 52;\nconst long long MOD = 1000000007;\nlong long dp[MAX_N][MAX_N][MAX_N][MAX_N];\nint n, p;\nint color[MAX_N];\nlong long pw[MAX_N];\nlong long C[MAX_N][MAX_N];\nlong long odd[MAX_N], even[MAX_N];\nvoid init() {\n  pw[0] = 1LL;\n  for (int i = 1; i <= n; i++) {\n    pw[i] = (pw[i - 1] * 2LL) % MOD;\n  }\n  for (int i = 0; i <= n; i++) {\n    C[i][0] = 1LL;\n    C[i][i] = 1LL;\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j < i; j++) {\n      C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD;\n    }\n  }\n  for (int i = 0; i <= n; i++) {\n    for (int j = 0; j <= i; j += 2) {\n      (even[i] += C[i][j]) %= MOD;\n    }\n    for (int j = 1; j <= i; j += 2) {\n      (odd[i] += C[i][j]) %= MOD;\n    }\n  }\n}\nvoid update(int ew, int ow, int eb, int ob, int c, long long v) {\n  if (c != 1) {\n    (dp[ew + 1][ow][eb][ob] +=\n     ((v * odd[ob]) % MOD * pw[ew + ow + eb]) % MOD) %= MOD;\n    (dp[ew][ow + 1][eb][ob] +=\n     ((v * even[ob]) % MOD * pw[ew + ow + eb]) % MOD) %= MOD;\n  }\n  if (c != 0) {\n    (dp[ew][ow][eb + 1][ob] +=\n     ((v * odd[ow]) % MOD * pw[eb + ob + ew]) % MOD) %= MOD;\n    (dp[ew][ow][eb][ob + 1] +=\n     ((v * even[ow]) % MOD * pw[eb + ob + ew]) % MOD) %= MOD;\n  }\n}\nint main() {\n  cin >> n >> p;\n  init();\n  for (int i = 1; i <= n; i++) {\n    cin >> color[i];\n  }\n  dp[0][0][0][0] = 1LL;\n  long long ans = 0LL;\n  for (int i = 0; i <= n; i++) {\n    for (int ew = 0; ew <= i; ew++) {\n      for (int ow = 0; ow + ew <= i; ow++) {\n        for (int eb = 0; eb + ew + ow <= i; eb++) {\n          int ob = i - ew - ow - eb;\n          if (dp[ew][ow][eb][ob] == 0) {\n            continue;\n          }\n          long long cur = dp[ew][ow][eb][ob];\n          if (i == n && ((ow + ob) % 2 == p)) {\n            (ans += dp[ew][ow][eb][ob]) %= MOD;\n          }\n          update(ew, ow, eb, ob, color[i + 1], cur);\n        }\n      }\n    }\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint intcmp(const void *v1, const void *v2) { return *(int *)v1 - *(int *)v2; }\nconst int N = 55;\nint n, p, c;\nlong long f[N][N][N];\nlong long ans = 0, pw[N], od[N], ev[N];\nvoid init() {\n  f[0][0][0] = 1;\n  pw[0] = 1;\n  ev[0] = 1;\n  for (int i = 1; i < N; i++) {\n    pw[i] = pw[i - 1] * 2 % 1000000007;\n    od[i] = ev[i] = pw[i - 1];\n  }\n}\nvoid push_ans(int ob, int ow, int e) {\n  if (c != 0) {\n    (f[ob][ow + 1][e] += f[ob][ow][e] * pw[ow + e] % 1000000007 * ev[ob] %\n                         1000000007) %= 1000000007;\n    (f[ob][ow][e + 1] += f[ob][ow][e] * pw[ow + e] % 1000000007 * od[ob] %\n                         1000000007) %= 1000000007;\n  }\n  if (c != 1) {\n    (f[ob + 1][ow][e] += f[ob][ow][e] * pw[ob + e] % 1000000007 * ev[ow] %\n                         1000000007) %= 1000000007;\n    (f[ob][ow][e + 1] += f[ob][ow][e] * pw[ob + e] % 1000000007 * od[ow] %\n                         1000000007) %= 1000000007;\n  }\n}\nint main() {\n  init();\n  cin >> n >> p;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &c);\n    for (int ob = 0; ob < i + 1; ob++)\n      for (int ow = 0; ow < i - ob + 1; ow++) push_ans(ob, ow, i - ob - ow);\n  }\n  for (int ob = 0; ob < n + 1; ob++)\n    for (int ow = 0; ow < n - ob + 1; ow++)\n      if (((ob + ow) & 1) == p) (ans += f[ob][ow][n - ob - ow]) %= 1000000007;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long f[54][2][2][2], n, p, col[101], two[101];\nint main() {\n  cin >> n >> p;\n  two[0] = 1;\n  for (int i = 1; i <= n; i++)\n    cin >> col[i], two[i] = two[i - 1] * 2 % 1000000007;\n  f[0][0][0][0] = 1;\n  for (int i = 1; i <= n; i++) {\n    for (int len = 0; len <= 1; len++) {\n      for (int jb = 0; jb <= 1; jb++) {\n        for (int jw = 0; jw <= 1; jw++) {\n          if (!f[i - 1][len][jb][jw]) continue;\n          long long las = f[i - 1][len][jb][jw];\n          if (col[i] != 1) {\n            if (jw) {\n              f[i][len ^ 1][1 | jb][1] =\n                  (f[i][len ^ 1][1 | jb][1] + las * two[i - 2] % 1000000007) %\n                  1000000007;\n              f[i][len][jb][1] =\n                  (f[i][len][jb][1] + las * two[i - 2] % 1000000007) %\n                  1000000007;\n            } else {\n              f[i][len ^ 1][1][0] =\n                  (f[i][len ^ 1][1][0] + las * two[i - 1]) % 1000000007;\n            }\n          }\n          if (col[i] != 0) {\n            if (jb) {\n              f[i][len ^ 1][1][1 | jw] =\n                  (f[i][len ^ 1][1][1 | jw] + las * two[i - 2] % 1000000007) %\n                  1000000007;\n              f[i][len][1][jw] =\n                  (f[i][len][1][jw] + las * two[i - 2] % 1000000007) %\n                  1000000007;\n            } else {\n              f[i][len ^ 1][0][1] =\n                  (f[i][len ^ 1][0][1] + las * two[i - 1]) % 1000000007;\n            }\n          }\n        }\n      }\n    }\n  }\n  cout << (f[n][p][0][0] + f[n][p][1][0] + f[n][p][0][1] + f[n][p][1][1]) %\n              1000000007;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint bit[55], f[55][3][3];\nint n, m, ans, to[5];\nvoid upd(int &x, int y) { (x += y) >= 1000000007 ? x -= 1000000007 : 233; }\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  bit[0] = 1;\n  for (int i = 1; i <= n; i++) bit[i] = bit[i - 1] * 2 % 1000000007;\n  f[0][0][0] = 1;\n  to[0] = to[2] = 1;\n  to[1] = 2;\n  for (int i = 0; i < n; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    for (int j = 0; j <= 2; j++)\n      for (int k = 0; k <= 2; k++) {\n        if (!f[i][j][k]) continue;\n        if (x != 1) {\n          if (!k)\n            upd(f[i + 1][to[j]][k], 1ll * f[i][j][k] * bit[i] % 1000000007);\n          else {\n            upd(f[i + 1][to[j]][k], 1ll * f[i][j][k] * bit[i - 1] % 1000000007);\n            upd(f[i + 1][j][k], 1ll * f[i][j][k] * bit[i - 1] % 1000000007);\n          }\n        }\n        if (x != 0) {\n          if (!j)\n            upd(f[i + 1][j][to[k]], 1ll * f[i][j][k] * bit[i] % 1000000007);\n          else {\n            upd(f[i + 1][j][to[k]], 1ll * f[i][j][k] * bit[i - 1] % 1000000007);\n            upd(f[i + 1][j][k], 1ll * f[i][j][k] * bit[i - 1] % 1000000007);\n          }\n        }\n      }\n  }\n  for (int i = 0; i <= 2; i++)\n    for (int j = 0; j <= 2; j++)\n      if ((i + j + m) % 2 == 0) upd(ans, f[n][i][j]);\n  printf(\"%d\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 1000000007;\nint n, a, i, j, k, l, m, p;\nlong long dp[2][2][2][2], mi[500005];\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  mi[0] = 1;\n  for (i = 1; i <= n; ++i) mi[i] = mi[i - 1] * 2 % M;\n  dp[0][0][0][0] = 1;\n  for (i = 1; i <= n; ++i) {\n    scanf(\"%d\", &a);\n    int t = i & 1;\n    memset(dp[t], 0, sizeof(dp[t]));\n    if (a == 0 || a == -1) {\n      for (j = 0; j <= 1; ++j)\n        for (k = 0; k <= 1; ++k)\n          for (p = 0; p <= 1; ++p) {\n            if (k) {\n              dp[t][j][k][p] =\n                  (dp[t][j][k][p] +\n                   dp[t ^ 1][j][k][p] * (i - 1 > 0 ? mi[i - 2] : 0)) %\n                  M;\n              dp[t][j | 1][k][p ^ 1] =\n                  (dp[t][j | 1][k][p ^ 1] +\n                   dp[t ^ 1][j][k][p] * (i - 1 > 0 ? mi[i - 2] : 0)) %\n                  M;\n            } else\n              dp[t][j | 1][k][p ^ 1] =\n                  (dp[t][j | 1][k][p ^ 1] + dp[t ^ 1][j][k][p] * mi[i - 1]) % M;\n          }\n    }\n    if (a == 1 || a == -1) {\n      for (j = 0; j <= 1; ++j)\n        for (k = 0; k <= 1; ++k)\n          for (p = 0; p <= 1; ++p) {\n            if (k) {\n              dp[t][k][j][p] =\n                  (dp[t][k][j][p] +\n                   dp[t ^ 1][k][j][p] * (i - 1 > 0 ? mi[i - 2] : 0)) %\n                  M;\n              dp[t][k][j | 1][p ^ 1] =\n                  (dp[t][k][j | 1][p ^ 1] +\n                   dp[t ^ 1][k][j][p] * (i - 1 > 0 ? mi[i - 2] : 0)) %\n                  M;\n            } else\n              dp[t][k][j | 1][p ^ 1] =\n                  (dp[t][k][j | 1][p ^ 1] + dp[t ^ 1][k][j][p] * mi[i - 1]) % M;\n          }\n    }\n  }\n  cout << ((dp[n & 1][0][0][m] + dp[n & 1][0][1][m] + dp[n & 1][1][1][m] +\n            dp[n & 1][1][0][m]) %\n               M +\n           M) %\n              M;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint read() {\n  int sum = 0, f = 1;\n  char ch = getchar();\n  while (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();\n  if (ch == '-') ch = getchar(), f = -1;\n  while (ch <= '9' && ch >= '0') sum = sum * 10 + ch - '0', ch = getchar();\n  return sum * f;\n}\nint val[100010], n, p;\nint f[100010][2][2][2];\nconst int mod = 1e9 + 7;\nint poww[100010];\nvoid pre() {\n  poww[0] = 1;\n  for (int i = 1; i <= 100000; i++) poww[i] = 1ll * poww[i - 1] * 2 % mod;\n}\nvoid fix(int &a, int b) {\n  a = (a + b) % mod;\n  a += mod;\n  a %= mod;\n}\nint main() {\n  pre();\n  n = read(), p = read();\n  for (int i = 1; i <= n; i++) val[i] = read();\n  f[0][0][0][0] = 1;\n  for (int i = 0; i < n; i++) {\n    if (!val[i + 1]) {\n      for (int j = 0; j <= 1; j++)\n        for (int k = 0; k <= 1; k++)\n          for (int l = 0; l <= 1; l++)\n            if (f[i][j][k][l]) {\n              if (l) {\n                fix(f[i + 1][j ^ 1][1][l],\n                    1ll * f[i][j][k][l] * poww[i - 1] % mod);\n                fix(f[i + 1][j][k][l], 1ll * f[i][j][k][l] * poww[i - 1] % mod);\n              } else\n                fix(f[i + 1][j ^ 1][1][l], 1ll * f[i][j][k][l] * poww[i] % mod);\n            }\n    } else if (val[i + 1] == 1) {\n      for (int j = 0; j <= 1; j++)\n        for (int k = 0; k <= 1; k++)\n          for (int l = 0; l <= 1; l++)\n            if (f[i][j][k][l]) {\n              if (k) {\n                fix(f[i + 1][j ^ 1][k][1],\n                    1ll * f[i][j][k][l] * poww[i - 1] % mod);\n                fix(f[i + 1][j][k][l], 1ll * f[i][j][k][l] * poww[i - 1] % mod);\n              } else\n                fix(f[i + 1][j ^ 1][k][1], 1ll * f[i][j][k][l] * poww[i] % mod);\n            }\n    } else {\n      for (int j = 0; j <= 1; j++)\n        for (int k = 0; k <= 1; k++)\n          for (int l = 0; l <= 1; l++)\n            if (f[i][j][k][l]) {\n              if (l) {\n                fix(f[i + 1][j ^ 1][1][l],\n                    1ll * f[i][j][k][l] * poww[i - 1] % mod);\n                fix(f[i + 1][j][k][l], 1ll * f[i][j][k][l] * poww[i - 1] % mod);\n              } else\n                fix(f[i + 1][j ^ 1][1][l], 1ll * f[i][j][k][l] * poww[i] % mod);\n            }\n      for (int j = 0; j <= 1; j++)\n        for (int k = 0; k <= 1; k++)\n          for (int l = 0; l <= 1; l++)\n            if (f[i][j][k][l]) {\n              if (k) {\n                fix(f[i + 1][j ^ 1][k][1],\n                    1ll * f[i][j][k][l] * poww[i - 1] % mod);\n                fix(f[i + 1][j][k][l], 1ll * f[i][j][k][l] * poww[i - 1] % mod);\n              } else\n                fix(f[i + 1][j ^ 1][k][1], 1ll * f[i][j][k][l] * poww[i] % mod);\n            }\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i <= 1; i++)\n    for (int j = 0; j <= 1; j++) fix(ans, f[n][p][i][j]);\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst long long llINF = 1e18;\nconst int MAXN = 1e5 + 5;\nconst int MOD = 1e9 + 7;\nnamespace ModOperation {\nint mul(int x, int y) { return 1ll * x * y % MOD; }\nint add(int x, int y) {\n  x += y;\n  if (x >= MOD) x -= MOD;\n  return x;\n}\nvoid addmod(int &x, int y) {\n  x += y;\n  if (x >= MOD) x -= MOD;\n}\nint sub(int x, int y) {\n  x -= y;\n  if (x < 0) x += MOD;\n  return x;\n}\nvoid submod(int &x, int y) {\n  x -= y;\n  if (x < 0) x += MOD;\n}\n}  // namespace ModOperation\nusing namespace ModOperation;\nint n, p;\nint c[MAXN], pow2[MAXN], f[MAXN][2][2][2];\nint main() {\n  scanf(\"%d%d\", &n, &p);\n  pow2[0] = 1;\n  for (int i = 1; i <= n; i++) pow2[i] = 1ll * pow2[i - 1] * 2 % MOD;\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &c[i]);\n  f[0][0][0][0] = 1;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j < 2; j++) {\n      for (int k = 0; k < 2; k++) {\n        for (int l = 0; l < 2; l++) {\n          if (c[i] != 1) {\n            if (l) {\n              addmod(f[i][j][k][l],\n                     1ll * f[i - 1][j][k][l] * pow2[i - 2] % MOD);\n              addmod(f[i][j ^ 1][1][l],\n                     1ll * f[i - 1][j][k][l] * pow2[i - 2] % MOD);\n            } else\n              addmod(f[i][j ^ 1][1][l],\n                     1ll * f[i - 1][j][k][l] * pow2[i - 1] % MOD);\n          }\n          if (c[i] != 0) {\n            if (k) {\n              addmod(f[i][j][k][l],\n                     1ll * f[i - 1][j][k][l] * pow2[i - 2] % MOD);\n              addmod(f[i][j ^ 1][k][1],\n                     1ll * f[i - 1][j][k][l] * pow2[i - 2] % MOD);\n            } else\n              addmod(f[i][j ^ 1][k][1],\n                     1ll * f[i - 1][j][k][l] * pow2[i - 1] % MOD);\n          }\n        }\n      }\n    }\n  }\n  int ans = 0;\n  for (int k = 0; k < 2; k++) {\n    for (int l = 0; l < 2; l++) addmod(ans, f[n][p][k][l]);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long L = 1000000;\nchar LZH[L];\nchar *SSS, *TTT;\ninline char gc() {\n  if (SSS == TTT) TTT = (SSS = LZH) + fread(LZH, 1, L, stdin);\n  return *SSS++;\n}\ninline long long read() {\n  long long x = 0, f = 1;\n  char c = getchar();\n  for (; c < '0' || c > '9'; c = getchar())\n    if (c == '-') f = -1;\n  for (; c >= '0' && c <= '9'; c = getchar()) x = (x << 1) + (x << 3) + c - 48;\n  return x * f;\n}\nvoid write(long long aa) {\n  if (aa < 0) putchar('-'), aa = -aa;\n  if (aa > 9) write(aa / 10);\n  putchar(aa % 10 + '0');\n  return;\n}\nconst long long mod = 1e9 + 7;\nlong long n, p, now, qq, pp, ans;\nlong long f[2][2][2][2];\nint main() {\n  n = read(), p = read();\n  pp = 1;\n  f[now][0][0][0] = 1;\n  for (long long i = 1; i <= n; ++i) {\n    now ^= 1;\n    memset(f[now], 0, sizeof(f[now]));\n    long long x = read();\n    if (x != 1) {\n      for (long long j = 0; j < 2; ++j)\n        for (long long k = 0; k < 2; ++k)\n          for (long long l = 0; l < 2; ++l)\n            if (f[now ^ 1][j][k][l]) {\n              if (l) {\n                f[now][j ^ 1][1][l] =\n                    (f[now][j ^ 1][1][l] + f[now ^ 1][j][k][l] * qq % mod) %\n                    mod;\n                f[now][j][k][l] =\n                    (f[now][j][k][l] + f[now ^ 1][j][k][l] * qq % mod) % mod;\n              } else\n                f[now][j ^ 1][1][l] =\n                    (f[now][j ^ 1][1][l] + f[now ^ 1][j][k][l] * pp % mod) %\n                    mod;\n            }\n    }\n    if (x != 0) {\n      for (long long j = 0; j < 2; ++j)\n        for (long long k = 0; k < 2; ++k)\n          for (long long l = 0; l < 2; ++l)\n            if (f[now ^ 1][j][k][l]) {\n              if (k) {\n                f[now][j ^ 1][k][1] =\n                    (f[now][j ^ 1][k][1] + f[now ^ 1][j][k][l] * qq % mod) %\n                    mod;\n                f[now][j][k][l] =\n                    (f[now][j][k][l] + f[now ^ 1][j][k][l] * qq % mod) % mod;\n              } else\n                f[now][j ^ 1][k][1] =\n                    (f[now][j ^ 1][k][1] + f[now ^ 1][j][k][l] * pp % mod) %\n                    mod;\n            }\n    }\n    qq = pp;\n    pp = (pp * 2) % mod;\n  }\n  for (long long i = 0; i < 2; ++i)\n    for (long long j = 0; j < 2; ++j) ans = (ans + f[now][p][i][j]) % mod;\n  write(ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int mod = 1e9 + 7;\nconst int N = 60;\nint n, p, _2[N], a[N];\nint f[N][2][2][2], ans;\nvoid add(int &x, int y) {\n  x += y;\n  if (x >= mod) x -= mod;\n}\nint main() {\n  scanf(\"%d%d\", &n, &p);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  _2[0] = 1;\n  for (int i = 1; i <= n; i++) _2[i] = (_2[i - 1] << 1) % mod;\n  f[0][0][0][0] = 1;\n  for (int i = 1; i <= n; i++)\n    for (int _ = 0; _ <= 1; _++)\n      for (int ob = 0; ob <= 1; ob++)\n        for (int ow = 0; ow <= 1; ow++) {\n          int qwq = f[i - 1][_][ob][ow];\n          if (a[i] != 0) {\n            if (ob) {\n              add(f[i][_][ob][ow], 1ll * qwq * _2[i - 2] % mod);\n              add(f[i][_ ^ 1][ob][ow | 1], 1ll * qwq * _2[i - 2] % mod);\n            } else\n              add(f[i][_ ^ 1][ob][ow | 1], 1ll * qwq * _2[i - 1] % mod);\n          }\n          if (a[i] != 1) {\n            if (ow) {\n              add(f[i][_][ob][ow], 1ll * qwq * _2[i - 2] % mod);\n              add(f[i][_ ^ 1][ob | 1][ow], 1ll * qwq * _2[i - 2] % mod);\n            } else\n              add(f[i][_ ^ 1][ob | 1][ow], 1ll * qwq * _2[i - 1] % mod);\n          }\n        }\n  for (int ob = 0; ob <= 1; ob++)\n    for (int ow = 0; ow <= 1; ow++) add(ans, f[n][p][ob][ow]);\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint n, f;\nlong long dp[55][2][2][2];\nint col[55];\nlong long pw[55];\ninline int read() {\n  int ans = 0;\n  int f = 1;\n  char ch = getchar();\n  for (; ch < '0' || ch > '9'; ch = getchar())\n    if (ch == '-') f = -1;\n  for (; ch >= '0' && ch <= '9'; ch = getchar()) ans = ans * 10 + ch - '0';\n  return ans * f;\n}\nint main() {\n  n = read(), f = read();\n  register int i, j;\n  pw[0] = 1;\n  for (i = 1; i <= n; i++) pw[i] = pw[i - 1] * 2 % 1000000007;\n  for (i = 1; i <= n; i++) col[i] = read();\n  dp[0][0][0][0] = 1;\n  for (i = 1; i <= n; i++) {\n    for (j = 0; j <= 1; j++) {\n      if (col[i] == 0 || col[i] == -1) {\n        if (i > 1) dp[i][j][0][1] += dp[i - 1][j][0][1] * pw[i - 2];\n        if (i > 1) dp[i][j][1][1] += dp[i - 1][j][1][1] * pw[i - 2];\n        if (i > 1)\n          dp[i][j ^ 1][1][1] += (dp[i - 1][j][0][1] + dp[i - 1][j][1][1]) *\n                                pw[i - 2] % 1000000007;\n        dp[i][j ^ 1][1][0] +=\n            (dp[i - 1][j][1][0] + dp[i - 1][j][0][0]) * pw[i - 1];\n        dp[i][j][0][1] %= 1000000007, dp[i][j][1][1] %= 1000000007;\n        dp[i][j ^ 1][1][1] %= 1000000007, dp[i][j ^ 1][1][0] %= 1000000007;\n      }\n      if (col[i] == 1 || col[i] == -1) {\n        if (i > 1) dp[i][j][1][0] += dp[i - 1][j][1][0] * pw[i - 2];\n        if (i > 1) dp[i][j][1][1] += dp[i - 1][j][1][1] * pw[i - 2];\n        if (i > 1)\n          dp[i][j ^ 1][1][1] += (dp[i - 1][j][1][0] + dp[i - 1][j][1][1]) *\n                                pw[i - 2] % 1000000007;\n        dp[i][j ^ 1][0][1] +=\n            (dp[i - 1][j][0][1] + dp[i - 1][j][0][0]) * pw[i - 1];\n        dp[i][j][1][0] %= 1000000007, dp[i][j][1][1] %= 1000000007;\n        dp[i][j ^ 1][1][1] %= 1000000007, dp[i][j ^ 1][0][1] %= 1000000007;\n      }\n    }\n  }\n  long long ans = 0;\n  ans = (ans + dp[n][f][0][0] + dp[n][f][0][1] + dp[n][f][1][0] +\n         dp[n][f][1][1]) %\n        1000000007;\n  printf(\"%I64d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 50 + 7;\nconst long long MOD = 1e9 + 7;\nlong long dp[2][N][N][N][N], po[N];\nvoid solve() {\n  int n, p;\n  cin >> n >> p;\n  dp[0][0][0][0][0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    int col;\n    cin >> col;\n    for (int mod = 0; mod <= 1; ++mod) {\n      for (int cnt10 = 0; cnt10 < i; ++cnt10) {\n        for (int cnt11 = 0; cnt10 + cnt11 < i; ++cnt11) {\n          for (int cnt00 = 0; cnt10 + cnt11 + cnt00 < i; ++cnt00) {\n            int cnt01 = i - 1 - cnt00 - cnt11 - cnt10;\n            if (!dp[mod][cnt10][cnt11][cnt00][cnt01]) continue;\n            if (col == 0 || col == -1) {\n              long long add = dp[mod][cnt10][cnt11][cnt00][cnt01] * po[cnt10] %\n                              MOD * po[cnt00] % MOD * po[cnt01] % MOD;\n              if (cnt11 != 0) {\n                add = add * po[cnt11 - 1] % MOD;\n              } else {\n                dp[mod ^ 1][cnt10][cnt11][cnt00][cnt01 + 1] =\n                    (dp[mod ^ 1][cnt10][cnt11][cnt00][cnt01 + 1] + add) % MOD;\n                add = 0;\n              }\n              dp[mod][cnt10][cnt11][cnt00 + 1][cnt01] =\n                  (dp[mod][cnt10][cnt11][cnt00 + 1][cnt01] + add) % MOD;\n              dp[mod ^ 1][cnt10][cnt11][cnt00][cnt01 + 1] =\n                  (dp[mod ^ 1][cnt10][cnt11][cnt00][cnt01 + 1] + add) % MOD;\n            }\n            if (col == 1 || col == -1) {\n              long long add = dp[mod][cnt10][cnt11][cnt00][cnt01] * po[cnt00] %\n                              MOD * po[cnt11] % MOD * po[cnt10] % MOD;\n              if (cnt01 != 0) {\n                add = add * po[cnt01 - 1] % MOD;\n              } else {\n                dp[mod ^ 1][cnt10][cnt11 + 1][cnt00][cnt01] =\n                    (dp[mod ^ 1][cnt10][cnt11 + 1][cnt00][cnt01] + add) % MOD;\n                add = 0;\n              }\n              dp[mod][cnt10 + 1][cnt11][cnt00][cnt01] =\n                  (dp[mod][cnt10 + 1][cnt11][cnt00][cnt01] + add) % MOD;\n              dp[mod ^ 1][cnt10][cnt11 + 1][cnt00][cnt01] =\n                  (dp[mod ^ 1][cnt10][cnt11 + 1][cnt00][cnt01] + add) % MOD;\n            }\n          }\n        }\n      }\n    }\n  }\n  long long res = 0;\n  for (int cnt10 = 0; cnt10 <= n; ++cnt10) {\n    for (int cnt11 = 0; cnt10 + cnt11 <= n; ++cnt11) {\n      for (int cnt00 = 0; cnt10 + cnt11 + cnt00 <= n; ++cnt00) {\n        int cnt01 = n - cnt00 - cnt11 - cnt10;\n        res = (res + dp[p][cnt10][cnt11][cnt00][cnt01]) % MOD;\n      }\n    }\n  }\n  cout << res << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  po[0] = 1;\n  for (int i = 1; i < N; ++i) {\n    po[i] = po[i - 1] * 2 % MOD;\n  }\n  int t;\n  t = 1;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint c[50 + 5], f[50 + 5][50 + 5][50 + 5][50 + 5], C[50 + 5][50 + 5], p[50 + 5];\ninline void rw(int& x, int y) {\n  if ((x += y) >= 1000000007) x -= 1000000007;\n}\nint main() {\n  int n, m, i, j, k, l, x, ans = 0;\n  scanf(\"%d%d\", &n, &m);\n  for (i = 1; i <= n; ++i) scanf(\"%d\", &c[i]);\n  for (i = 0; i <= n; ++i)\n    for (C[i][0] = j = 1; j <= i; ++j)\n      C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % 1000000007;\n  for (p[0] = i = 1; i <= n; ++i) p[i] = (p[i - 1] + p[i - 1]) % 1000000007;\n  f[0][0][0][0] = 1;\n  for (i = 1; i <= n; ++i)\n    for (j = 0; j < i; ++j)\n      for (k = 0; k <= j; ++k)\n        for (l = 0; l < i - j; ++l)\n          if (f[i - 1][j][k][l]) {\n            if (c[i] != 0)\n              for (x = 0; x <= l; ++x)\n                rw(f[i][j + 1][k + !(x & 1)][l], 1LL * f[i - 1][j][k][l] *\n                                                     p[i - 1 - l] % 1000000007 *\n                                                     C[l][x] % 1000000007);\n            if (c[i] != 1)\n              for (x = 0; x <= k; ++x)\n                rw(f[i][j][k][l + !(x & 1)], 1LL * f[i - 1][j][k][l] *\n                                                 p[i - 1 - k] % 1000000007 *\n                                                 C[k][x] % 1000000007);\n          }\n  for (i = 0; i <= n; ++i)\n    for (j = 0; j <= i; ++j)\n      for (k = 0; k <= n - i; ++k)\n        if (((j + k) & 1) == m) rw(ans, f[n][i][j][k]);\n  printf(\"%d\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int max_n = 51, mod = 1000000007;\nint dp[2][max_n][max_n][max_n], C[max_n][max_n], pw[max_n];\nint n, f, a[max_n], b[2][2];\nvoid init() {\n  pw[0] = 1;\n  for (int i = 1; i < max_n; ++i) {\n    pw[i] = (2LL * pw[i - 1]) % mod;\n  }\n  C[0][0] = 1;\n  for (int i = 1; i < max_n; ++i) {\n    C[i][0] = 1;\n    for (int j = 1; j <= i; ++j) {\n      C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;\n    }\n  }\n}\nint main() {\n  init();\n  cin >> n >> f;\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n  }\n  int q1 = 0, q2 = 1;\n  dp[q1][0][0][0] = 1;\n  for (int i = n - 1; i >= 0; --i) {\n    memset(dp[q2], 0, sizeof(dp[q2]));\n    int st = 0, fin = 2;\n    if (a[i] == 1) {\n      st = 1;\n    } else if (a[i] == 0) {\n      fin = 1;\n    }\n    for (int cur = st; cur < fin; ++cur) {\n      int need = n - i - 1;\n      for (int c00 = 0; c00 <= need; ++c00) {\n        for (int c01 = 0; c00 + c01 <= need; ++c01) {\n          for (int c10 = 0; c00 + c01 + c10 <= need; ++c10) {\n            if (dp[c00][c01][c10] == 0) {\n              continue;\n            }\n            int c11 = need - c00 - c01 - c10;\n            b[0][0] = c00;\n            b[0][1] = c01;\n            b[1][0] = c10;\n            b[1][1] = c11;\n            int op = cur ^ 1;\n            for (int j = 0; j <= b[op][1]; ++j) {\n              int res = 1 ^ (j % 2);\n              ++b[cur][res];\n              int x = dp[q1][c00][c01][c10];\n              x = (1LL * x * C[b[op][1]][j]) % mod;\n              x = (1LL * x * pw[need - b[op][1]]) % mod;\n              dp[q2][b[0][0]][b[0][1]][b[1][0]] += x;\n              dp[q2][b[0][0]][b[0][1]][b[1][0]] %= mod;\n              --b[cur][res];\n            }\n          }\n        }\n      }\n    }\n    swap(q1, q2);\n  }\n  int need = n;\n  int ans = 0;\n  for (int c00 = 0; c00 <= need; ++c00) {\n    for (int c01 = 0; c00 + c01 <= need; ++c01) {\n      for (int c10 = 0; c00 + c01 + c10 <= need; ++c10) {\n        int c11 = need - c00 - c01 - c10;\n        if ((c01 + c11) % 2 == f) {\n          ans += dp[q1][c00][c01][c10];\n          ans %= mod;\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N, P;\nint arr[55];\nlong long dp[2][55][55][55][55];\nlong long pas[55][55];\nlong long pows[55];\nconst long long MOD = 1e9 + 7;\nlong long add(long long a, long long b) { return (a + b) % MOD; }\nlong long mult(long long a, long long b) { return (a * b) % MOD; }\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> N >> P;\n  dp[0][0][0][0][0] = 1;\n  for (int i = 1; i <= N; i++) {\n    cin >> arr[i];\n  }\n  pows[0] = 1;\n  for (int i = 1; i <= N; i++) {\n    pows[i] = mult(pows[i - 1], 2);\n  }\n  for (int i = 0; i <= N; i++) {\n    pas[i][0] = 1;\n    for (int j = 1; j <= i; j++) {\n      pas[i][j] = add(pas[i - 1][j - 1], pas[i - 1][j]);\n    }\n  }\n  long long ans = 0;\n  for (int w0 = 0; w0 <= N; w0++) {\n    for (int w1 = 0; w1 <= N; w1++) {\n      for (int b0 = 0; b0 <= N; b0++) {\n        for (int b1 = 0; b1 <= N; b1++) {\n          if (w0 + w1 + b0 + b1 >= N) {\n            if (w0 + w1 + b0 + b1 == N) {\n              ans = add(ans, dp[P][w0][w1][b0][b1]);\n            }\n            break;\n          }\n          int idx = w0 + w1 + b0 + b1 + 1;\n          for (int p = 0; p < 2; p++) {\n            if (arr[idx] != 1) {\n              for (int k = 0; k <= b0; k++) {\n                dp[p ^ (k & 1) ^ 1][w0 + (k & 1 ^ 1)][w1 + (k & 1)][b0][b1] =\n                    add(dp[p ^ (k & 1) ^ 1][w0 + (k & 1 ^ 1)][w1 + (k & 1)][b0]\n                          [b1],\n                        mult(dp[p][w0][w1][b0][b1],\n                             mult(pas[b0][k], pows[idx - b0 - 1])));\n              }\n            }\n            if (arr[idx] != 0) {\n              for (int k = 0; k <= w0; k++) {\n                dp[p ^ (k & 1) ^ 1][w0][w1][b0 + (k & 1 ^ 1)][b1 + (k & 1)] =\n                    add(dp[p ^ (k & 1) ^ 1][w0][w1][b0 + (k & 1 ^ 1)]\n                          [b1 + (k & 1)],\n                        mult(dp[p][w0][w1][b0][b1],\n                             mult(pas[w0][k], pows[idx - w0 - 1])));\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint col[55];\nlong long dp[55][55][55][55];\nlong long inv[55], fact[55], pw[55], odd[55], even[55];\nlong long fastpow(long long x, long long y) {\n  long long ret = 1;\n  while (y) {\n    if (y & 1) ret = (ret * x) % (1000 * 1000 * 1000 + 7);\n    x = (x * x) % (1000 * 1000 * 1000 + 7);\n    y >>= 1;\n  }\n  return ret;\n}\nlong long C(int x, int y) {\n  return fact[x] * inv[y] % (1000 * 1000 * 1000 + 7) * inv[x - y] %\n         (1000 * 1000 * 1000 + 7);\n}\nvoid preprocess() {\n  pw[0] = inv[0] = fact[0] = 1;\n  for (int i = 1; i < 55; i++) {\n    pw[i] = (pw[i - 1] * 2LL) % (1000 * 1000 * 1000 + 7);\n    fact[i] = (fact[i - 1] * i) % (1000 * 1000 * 1000 + 7);\n    inv[i] = fastpow(fact[i], (1000 * 1000 * 1000 + 7) - 2);\n  }\n  for (int i = 0; i < 55; i++) {\n    for (int j = 0; j <= i; j += 2)\n      even[i] = (even[i] + C(i, j)) % (1000 * 1000 * 1000 + 7);\n    for (int j = 1; j <= i; j += 2)\n      odd[i] = (odd[i] + C(i, j)) % (1000 * 1000 * 1000 + 7);\n  }\n}\nvoid find_ans(int i, int ow, int ew, int eb, int ob, long long &ret) {\n  if (col[i] != 0 && ow != 0)\n    ret = (ret + dp[i - 1][ow - 1][ew][eb] * pw[ow - 1 + ew + eb] %\n                     (1000 * 1000 * 1000 + 7) * even[ob] %\n                     (1000 * 1000 * 1000 + 7)) %\n          (1000 * 1000 * 1000 + 7);\n  if (col[i] != 0 && ew != 0)\n    ret = (ret + dp[i - 1][ow][ew - 1][eb] * pw[ow + ew - 1 + eb] %\n                     (1000 * 1000 * 1000 + 7) * odd[ob] %\n                     (1000 * 1000 * 1000 + 7)) %\n          (1000 * 1000 * 1000 + 7);\n  if (col[i] != 1 && ob != 0)\n    ret = (ret + dp[i - 1][ow][ew][eb] * pw[ob - 1 + eb + ew] %\n                     (1000 * 1000 * 1000 + 7) * even[ow] %\n                     (1000 * 1000 * 1000 + 7)) %\n          (1000 * 1000 * 1000 + 7);\n  if (col[i] != 1 && eb != 0)\n    ret = (ret + dp[i - 1][ow][ew][eb - 1] * pw[ob + eb - 1 + ew] %\n                     (1000 * 1000 * 1000 + 7) * odd[ow] %\n                     (1000 * 1000 * 1000 + 7)) %\n          (1000 * 1000 * 1000 + 7);\n}\nint main() {\n  int n, p;\n  scanf(\"%d%d\", &n, &p);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", col + i);\n  preprocess();\n  long long ans = 0;\n  dp[0][0][0][0] = 1;\n  for (int i = 1; i <= n; i++) {\n    for (int ow = 0; ow <= n; ow++) {\n      for (int ew = 0; ew <= n; ew++) {\n        for (int eb = 0; eb <= n; eb++) {\n          int ob = i - ow - ew - eb;\n          find_ans(i, ow, ew, eb, ob, dp[i][ow][ew][eb]);\n          if (n == i && (ow + ob) % 2 == p)\n            ans = (ans + dp[i][ow][ew][eb]) % (1000 * 1000 * 1000 + 7);\n        }\n      }\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long read() {\n  long long x = 0, f = 1;\n  char c = getchar();\n  while (c > '9' || c < '0') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    x = x * 10 + c - '0';\n    c = getchar();\n  }\n  return f * x;\n}\nint n, op, a[51];\nlong long dp[51][51][51], pw[51], ans;\nint main() {\n  n = read(), op = read();\n  pw[0] = 1;\n  for (int i = 1; i <= n; ++i) pw[i] = pw[i - 1] * 2 % 1000000007;\n  for (int i = 1; i <= n; ++i) a[i] = read();\n  dp[0][0][0] = 1;\n  for (int i = 1; i <= n; ++i)\n    for (int ow = 0; ow <= i; ++ow)\n      for (int ob = 0; ow + ob <= i; ++ob) {\n        if (a[i] == 1 || a[i] == -1) {\n          long long s = 0;\n          if (ow) {\n            s = dp[i - 1][ow - 1][ob];\n            if (ob) s = s * pw[ob - 1] % 1000000007;\n          }\n          if (ob + ow < i && ob) {\n            s = (s + dp[i - 1][ow][ob] * pw[ob - 1] % 1000000007) % 1000000007;\n          }\n          s = s * pw[i - ob - 1] % 1000000007;\n          dp[i][ow][ob] = s;\n        }\n        if (a[i] == 0 || a[i] == -1) {\n          long long s = 0;\n          if (ob) {\n            s = dp[i - 1][ow][ob - 1];\n            if (ow) s = s * pw[ow - 1] % 1000000007;\n          }\n          if (ow + ob < i && ow) {\n            s = (s + dp[i - 1][ow][ob] * pw[ow - 1] % 1000000007) % 1000000007;\n          }\n          s = s * pw[i - ow - 1] % 1000000007;\n          dp[i][ow][ob] = (dp[i][ow][ob] + s) % 1000000007;\n        }\n      }\n  for (int ow = 0; ow <= n; ++ow)\n    for (int ob = 0; ob + ow <= n; ++ob)\n      if ((ow + ob) % 2 == op) ans = (ans + dp[n][ow][ob]) % 1000000007;\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 55;\nconst long long mod = 1e9 + 7;\nlong long fastPow(long long x, long long p) {\n  long long ans = 1, curr = x;\n  while (p != 0) {\n    if (p % 2 != 0) ans = (ans * curr) % mod;\n    p /= 2;\n    curr = (curr * curr) % mod;\n  }\n  return ans;\n}\nlong long inv(long long x) { return fastPow(x, mod - 2); }\nlong long dp[MAXN][MAXN][MAXN][MAXN];\nlong long fact[MAXN], invFact[MAXN];\nlong long comb(int n, int k) {\n  if (n == 0 || k == 0) return 1;\n  return (((fact[n] * invFact[k]) % mod) * invFact[n - k]) % mod;\n}\nlong long p2[MAXN];\nlong long evenComb[MAXN], oddComb[MAXN];\nvoid Init() {\n  fact[0] = invFact[0] = 1;\n  for (int i = 1; i <= 50; i++) {\n    fact[i] = (fact[i - 1] * i) % mod;\n    invFact[i] = inv(fact[i]);\n  }\n  p2[0] = 1;\n  for (int i = 1; i <= 50; i++) p2[i] = (p2[i - 1] * 2) % mod;\n  for (int i = 0; i <= 50; i++) {\n    for (int j = 0; j <= i; j++) {\n      if (j % 2 == 0)\n        evenComb[i] += comb(i, j);\n      else\n        oddComb[i] += comb(i, j);\n    }\n    oddComb[i] %= mod;\n    evenComb[i] %= mod;\n  }\n}\nlong long calcState(int ew, int ow, int eb, int ob, int col) {\n  long long answer = 0;\n  if (col != 0 && ew != 0)\n    answer += (((dp[ew - 1][ow][eb][ob] * p2[ew - 1 + ow + eb]) % mod) *\n               oddComb[ob]) %\n              mod;\n  if (col != 0 && ow != 0)\n    answer += (((dp[ew][ow - 1][eb][ob] * p2[ew + ow - 1 + eb]) % mod) *\n               evenComb[ob]) %\n              mod;\n  if (col != 1 && eb != 0)\n    answer += (((dp[ew][ow][eb - 1][ob] * p2[eb - 1 + ob + ew]) % mod) *\n               oddComb[ow]) %\n              mod;\n  if (col != 1 && ob != 0)\n    answer += (((dp[ew][ow][eb][ob - 1] * p2[eb + ob - 1 + ew]) % mod) *\n               evenComb[ow]) %\n              mod;\n  return answer % mod;\n}\nint n, p;\nint c[MAXN];\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> p;\n  for (int i = 1; i <= n; i++) cin >> c[i];\n  Init();\n  dp[0][0][0][0] = 1;\n  long long answer = 0;\n  for (int i = 1; i <= n; i++) {\n    for (int ew = 0; ew <= i; ew++) {\n      for (int ow = 0; ow + ew <= i; ow++) {\n        for (int eb = 0; eb + ow + ew <= i; eb++) {\n          int ob = i - ew - ow - eb;\n          dp[ew][ow][eb][ob] = calcState(ew, ow, eb, ob, c[i]);\n          if (i == n && (ow + ob) % 2 == p) answer += dp[ew][ow][eb][ob];\n        }\n      }\n    }\n  }\n  cout << answer % mod << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(3)\nusing namespace std;\nconst double PI = acos(-1.0);\nconst double eps = 1e-6;\nconst int INF = 0x3f3f3f3f;\nconst int maxn = 50 + 3;\nconst int MOD = 1e9 + 7;\nint N, M, T, P;\nlong long dp[maxn][maxn][maxn][maxn];\nint c[maxn];\ninline void mod(long long& x) { x = ((x % MOD) + MOD) % MOD; }\nint main() {\n  cin >> N >> P;\n  for (int i = 1; i <= N; i++) scanf(\"%d\", &c[i]);\n  dp[0][0][0][0] = 1;\n  long long ans = 0, pow2;\n  for (int i = 0; i < N; i++) {\n    for (int ew = 0; ew <= i; ew++) {\n      for (int ow = 0; ew + ow <= i; ow++) {\n        for (int eb = 0; ew + ow + eb <= i; eb++) {\n          int ob = i - ew - ow - eb;\n          pow2 = (1LL << (ob ? i - 1 : i)) % MOD;\n          if (c[i + 1] == 0 || c[i + 1] == -1) {\n            dp[i + 1][ew][ow + 1][eb] += dp[i][ew][ow][eb] * pow2;\n            mod(dp[i + 1][ew][ow + 1][eb]);\n            if (ob)\n              dp[i + 1][ew + 1][ow][eb] += dp[i][ew][ow][eb] * pow2,\n                  mod(dp[i + 1][ew + 1][ow][eb]);\n          }\n          pow2 = (1LL << (ow ? i - 1 : i)) % MOD;\n          if (c[i + 1] == 1 || c[i + 1] == -1) {\n            if (ow)\n              dp[i + 1][ew][ow][eb + 1] += dp[i][ew][ow][eb] * pow2,\n                  mod(dp[i + 1][ew][ow][eb + 1]);\n            dp[i + 1][ew][ow][eb] += dp[i][ew][ow][eb] * pow2;\n            mod(dp[i + 1][ew][ow][eb]);\n          }\n        }\n      }\n    }\n  }\n  for (int ew = 0; ew <= N; ew++) {\n    for (int ow = 0; ew + ow <= N; ow++) {\n      for (int eb = 0; ew + ow + eb <= N; eb++) {\n        int ob = N - ew - ow - eb;\n        if (((ob + ow) & 1) == P) ans += dp[N][ew][ow][eb];\n      }\n    }\n  }\n  ans %= MOD;\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mo = 1000000007;\nlong long n, p, ans, a[51], mul[51];\nlong long f[51][51][51][51];\nint main() {\n  cin >> n >> p;\n  for (long long i = 1; i <= n; i++) cin >> a[i];\n  if (n == 1) {\n    if (p == 0) cout << 0;\n    if (p == 1) {\n      if (a[1] == -1)\n        cout << 2;\n      else\n        cout << 1;\n    }\n    return 0;\n  }\n  mul[0] = 1;\n  for (long long i = 1; i <= n; i++) mul[i] = (mul[i - 1] * 2) % mo;\n  f[0][0][0][0] = 1;\n  if (a[1] == 1 || a[1] == -1) f[1][0][0][1] = 1;\n  if (a[1] == 0 || a[1] == -1) f[1][1][0][0] = 1;\n  for (long long k = 2; k <= n; k++) {\n    for (long long odB = 0; odB <= k; odB++)\n      for (long long evB = 0; evB <= k; evB++)\n        for (long long odW = 0; odW <= k; odW++) {\n          long long evW = k - odB - evB - odW;\n          if (evW < 0) continue;\n          if (a[k] == 1 || a[k] == -1) {\n            long long tot = 0;\n            if (odW) {\n              if (odB == 0) tot = (tot + f[k - 1][odB][evB][odW - 1]) % mo;\n              if (odB != 0)\n                tot = (tot + mul[odB - 1] * f[k - 1][odB][evB][odW - 1]) % mo;\n            }\n            if (evW && odB)\n              tot = (tot + mul[odB - 1] * f[k - 1][odB][evB][odW]) % mo;\n            tot = (tot * mul[evB + odW + evW - 1]) % mo;\n            f[k][odB][evB][odW] += tot;\n          }\n          if (a[k] == 0 || a[k] == -1) {\n            long long tot = 0;\n            if (odB) {\n              if (odW == 0) tot = (tot + f[k - 1][odB - 1][evB][odW]) % mo;\n              if (odW != 0)\n                tot = (tot + mul[odW - 1] * f[k - 1][odB - 1][evB][odW]) % mo;\n            }\n            if (evB && odW)\n              tot = (tot + mul[odW - 1] * f[k - 1][odB][evB - 1][odW]) % mo;\n            tot = (tot * mul[evW + odB + evB - 1]) % mo;\n            f[k][odB][evB][odW] += tot;\n          }\n          if (k == n && (odW + odB) % 2 == p)\n            ans = (ans + f[k][odB][evB][odW]) % mo;\n        }\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int mod = 1000000007;\nint dp[60][60][60][60][2];\nint p2[60];\nvoid add(int &v, int x) {\n  v += x;\n  if (v >= mod) v -= mod;\n}\ninline int pp(int x, int d) {\n  if (x == 0) return d == 0;\n  return p2[x - 1];\n}\nint main() {\n  int n, p;\n  scanf(\"%d%d\", &n, &p);\n  dp[0][0][0][0][0] = 1;\n  p2[0] = 1;\n  for (int i = 0; i < n; i++) {\n    p2[i + 1] = p2[i];\n    add(p2[i + 1], p2[i]);\n  }\n  for (int i = 0; i < n; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    for (int j = 0; j <= i; j++) {\n      int b = i - j;\n      for (int k = 0; k <= j; k++) {\n        int k0 = j - k;\n        for (int l = 0; l <= b; l++) {\n          int l0 = b - l;\n          for (int m = 0; m < 2; m++) {\n            for (int a = 0; a < 2; a++) {\n              if (x <= 0) {\n                add(dp[i + 1][j + 1][k + a][l][m ^ a],\n                    (long long)dp[i][j][k][l][m] * pp(l, a ^ 1) % mod *\n                        p2[j + l0] % mod);\n              }\n              if (x & 1) {\n                add(dp[i + 1][j][k][l + a][m ^ a],\n                    (long long)dp[i][j][k][l][m] * pp(k, a ^ 1) % mod *\n                        p2[b + k0] % mod);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i <= n; i++) {\n    for (int j = 0; j <= n; j++) {\n      for (int k = 0; k <= n; k++) {\n        add(ans, dp[n][i][j][k][p]);\n      }\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MOD = 1000000007;\ninline void inc(int &a) {\n  if (a >= MOD) a -= MOD;\n}\nint dp[2][2][2][2];\nauto *f = dp[0], *g = dp[1];\nint main() {\n  int n, p, c;\n  scanf(\"%d%d\", &n, &p);\n  int pow = f[0][0][0] = 1;\n  for (int i = 0; i < n; i++) {\n    memset(g, 0, sizeof *dp);\n    scanf(\"%d\", &c);\n    for (int a = 0; a < 2; a++)\n      for (int b = 0; b < 2; b++)\n        for (int s = 0; s < 2; s++)\n          if (int val = f[a][b][s]) {\n            val = val * (long long)pow % MOD;\n            int val2 = (val & 1 ? val + MOD : val) >> 1;\n            if (c) {\n              if (a) {\n                inc(g[1][b][s] += val2);\n                inc(g[1][1][s ^ 1] += val2);\n              } else\n                inc(g[0][1][s ^ 1] += val);\n            }\n            if (c ^ 1) {\n              if (b) {\n                inc(g[a][1][s] += val2);\n                inc(g[1][1][s ^ 1] += val2);\n              } else\n                inc(g[1][0][s ^ 1] += val);\n            }\n          }\n    std::swap(f, g);\n    inc(pow <<= 1);\n  }\n  int ans = 0;\n  for (int a = 0; a < 2; a++)\n    for (int b = 0; b < 2; b++) inc(ans += f[a][b][p]);\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::make_pair;\nusing std::pair;\nconst int N = 55, mod = 1000000007;\nlong long dp[N][N][N][N], orip[N];\nlong long* pw = orip + 1;\nvoid init() {\n  pw[-1] = 1;\n  pw[0] = 1;\n  dp[0][0][0][0] = 1;\n  for (register int i = (1); i <= (50); ++i) (pw[i] = pw[i - 1] * 2) %= mod;\n}\nint main() {\n  std::ios::sync_with_stdio(false);\n  cout.tie(0);\n  init();\n  long long ans = 0;\n  int n, p;\n  int c[60];\n  cin >> n >> p;\n  for (register int i = (1); i <= (n); ++i) cin >> c[i];\n  for (register int i = (1); i <= (n); ++i)\n    for (register int ob = (0); ob <= (i); ++ob)\n      for (register int eb = (0); eb <= (i - ob); ++eb)\n        for (register int ow = (0); ow <= (i - ob - eb); ++ow) {\n          int ew = i - ob - eb - ow;\n          long long& cur = dp[i][ob][eb][ow];\n          cur = 0;\n          if (c[i] != 1) {\n            long long t = pw[ob + eb - 1 + ew] * pw[ow - 1] % mod;\n            if (ob > 0) (cur += dp[i - 1][ob - 1][eb][ow] * t % mod) %= mod;\n            if (eb > 0 && ow != 0)\n              (cur += dp[i - 1][ob][eb - 1][ow] * t % mod) %= mod;\n          }\n          if (c[i] != 0) {\n            long long t = pw[ow + ew + eb - 1] * pw[ob - 1] % mod;\n            if (ow > 0) (cur += dp[i - 1][ob][eb][ow - 1] * t % mod) % mod;\n            if (ew > 0 && ob != 0)\n              (cur += dp[i - 1][ob][eb][ow] * t % mod) % mod;\n          }\n          if (i == n && (ow + ob) % 2 == p) (ans += cur) %= mod;\n        }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 55;\nconst long long p = 1e9 + 7;\nlong long read() {\n  long long s = 0;\n  char c = getchar(), lc = '+';\n  while (c < '0' || '9' < c) lc = c, c = getchar();\n  while ('0' <= c && c <= '9') s = s * 10 + c - '0', c = getchar();\n  return lc == '-' ? -s : s;\n}\nvoid write(long long x) {\n  if (x < 0) {\n    putchar('-');\n    x = -x;\n  }\n  if (x < 10)\n    putchar(x + '0');\n  else {\n    write(x / 10);\n    putchar(x % 10 + '0');\n  }\n}\nvoid print(long long x, char c = '\\n') {\n  write(x);\n  putchar(c);\n}\nvoid add(long long &x, long long y) {\n  x += y;\n  if (x >= p) x -= p;\n}\nlong long dp[N][N][N][N], Pow[N], a[N];\nsigned main() {\n  memset(dp, 0, sizeof(dp));\n  long long n = read(), pp = read(), ans = 0;\n  for (long long i = 1; i <= n; i++) a[i] = read();\n  dp[0][0][0][0] = Pow[0] = 1;\n  for (long long i = 1; i <= n; i++) Pow[i] = Pow[i - 1] * 2ll % p;\n  for (long long i = 1; i <= n; i++)\n    for (long long j = 0; j <= i; j++)\n      for (long long k = 0; k <= i; k++)\n        for (long long l = 0; l <= i; l++) {\n          long long L, R;\n          if (a[i] == -1)\n            L = 0, R = 1;\n          else\n            L = R = a[i];\n          for (long long t = L; t <= R; t++)\n            if (t == 0) {\n              if (i - l - k > 0) {\n                if (l && j)\n                  add(dp[i][j][k][l],\n                      dp[i - 1][j - 1][k][l - 1] * Pow[max(i - 2, 0ll)] % p);\n                if (l)\n                  add(dp[i][j][k][l],\n                      dp[i - 1][j][k][l - 1] * Pow[max(i - 2, 0ll)] % p);\n              } else if (i - l - k == 0) {\n                if (l)\n                  add(dp[i][j][k][l],\n                      dp[i - 1][j][k][l - 1] * Pow[max(i - 1, 0ll)] % p);\n              }\n            } else {\n              if (l - j > 0) {\n                if (k)\n                  add(dp[i][j][k][l],\n                      dp[i - 1][j][k - 1][l] * Pow[max(i - 2, 0ll)] % p);\n                if (j < l)\n                  add(dp[i][j][k][l],\n                      dp[i - 1][j][k][l] * Pow[max(i - 2, 0ll)] % p);\n              } else if (l - j == 0) {\n                add(dp[i][j][k][l],\n                    dp[i - 1][j][k][l] * Pow[max(i - 1, 0ll)] % p);\n              }\n            }\n        }\n  for (long long j = 0; j <= n; j++)\n    for (long long k = 0; k <= n; k++)\n      for (long long l = 0; l <= n; l++)\n        if (l - j >= 0 && n - l - k >= 0)\n          if ((l - j + n - l - k) % 2 == pp) add(ans, dp[n][j][k][l]);\n  print(ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 60;\nconst int mo = (int)1e9 + 7;\nint n, p, a[N];\nlong long pw[N], f[N][3][3][3];\nint main() {\n  pw[0] = 1;\n  for (int i = 1; i < N; i++) pw[i] = pw[i - 1] * 2 % mo;\n  scanf(\"%d%d\", &n, &p);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", a + i);\n  f[0][0][0][0] = 1;\n  for (int i = 1; i <= n; i++)\n    for (int wb1 = 0; wb1 <= 1; wb1++)\n      for (int hasb1 = 0; hasb1 <= 1; hasb1++)\n        for (int hasw1 = 0; hasw1 <= 1; hasw1++) {\n          if (a[i] != 1) {\n            if (hasb1) {\n              (f[i][wb1][hasb1][hasw1] +=\n               f[i - 1][wb1][hasb1][hasw1] * pw[i - 2] % mo) %= mo;\n              (f[i][wb1 ^ 1][hasb1][hasw1 | 1] +=\n               f[i - 1][wb1][hasb1][hasw1] * pw[i - 2] % mo) %= mo;\n            } else {\n              (f[i][wb1 ^ 1][0][hasw1 | 1] +=\n               f[i - 1][wb1][0][hasw1] * pw[i - 1] % mo) %= mo;\n            }\n          }\n          if (a[i] != 0) {\n            if (hasw1) {\n              (f[i][wb1][hasb1][hasw1] +=\n               f[i - 1][wb1][hasb1][hasw1] * pw[i - 2] % mo) %= mo;\n              (f[i][wb1 ^ 1][hasb1 | 1][hasw1] +=\n               f[i - 1][wb1][hasb1][hasw1] * pw[i - 2] % mo) %= mo;\n            } else {\n              (f[i][wb1 ^ 1][hasb1 | 1][hasw1] +=\n               f[i - 1][wb1][hasb1][hasw1] * pw[i - 1] % mo) %= mo;\n            }\n          }\n        }\n  long long ans = 0;\n  for (int hasb1 = 0; hasb1 <= 1; hasb1++)\n    for (int hasw1 = 0; hasw1 <= 1; hasw1++) {\n      (ans += f[n][p][hasb1][hasw1]) %= mo;\n    }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, p;\nlong long m = 1e9 + 7;\nlong long p2[52];\nint memo[52][52][52][52], c[52];\nint numpos(int use, int ow, int ew, int ob) {\n  if (use == 1) {\n    if (c[1] == -1 && (ow || ob)) return 1;\n    if (c[1] == 1 && ob) return 1;\n    if (c[1] == 0 && ow) return 1;\n    return 0;\n  }\n  if (memo[use][ow][ew][ob] != -1) return memo[use][ow][ew][ob];\n  int eb = use - ew - ow - ob;\n  long long ans = 0, trm;\n  if (c[use] <= 0) {\n    int prev = ow + ew - 1;\n    if (ow) {\n      if (ob <= 1)\n        trm = 1;\n      else\n        trm = p2[ob - 1];\n      trm = (trm * p2[eb]) % m;\n      trm = (trm * p2[prev]) % m;\n      ans = (ans + trm * numpos(use - 1, ow - 1, ew, ob)) % m;\n    }\n    if (ew && ob) {\n      trm = (p2[ob - 1] * p2[eb]) % m;\n      trm = (trm * p2[prev]) % m;\n      ans = (ans + trm * numpos(use - 1, ow, ew - 1, ob)) % m;\n    }\n  }\n  if (c[use]) {\n    int prev = ob + eb - 1;\n    if (ob) {\n      if (ow <= 1)\n        trm = 1;\n      else\n        trm = p2[ow - 1];\n      trm = (trm * p2[ew]) % m;\n      trm = (trm * p2[prev]) % m;\n      ans = (ans + trm * numpos(use - 1, ow, ew, ob - 1)) % m;\n    }\n    if (eb && ow) {\n      trm = (p2[ow - 1] * p2[ew]) % m;\n      trm = (trm * p2[prev]) % m;\n      ans = (ans + trm * numpos(use - 1, ow, ew, ob)) % m;\n    }\n  }\n  return memo[use][ow][ew][ob] = ans;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  memset(memo, -1, sizeof memo);\n  p2[0] = 1;\n  for (int i = 1; i <= 51; ++i) {\n    p2[i] = (p2[i - 1] * 2) % m;\n  }\n  cin >> n >> p;\n  for (int i = 1; i <= n; ++i) {\n    cin >> c[i];\n  }\n  long long ans = 0;\n  for (int ow = 0; ow <= n; ++ow) {\n    for (int ew = 0; ew + ow <= n; ++ew) {\n      for (int ob = 0; ob + ow + ew <= n; ++ob) {\n        if ((ob + ow) % 2 != p) continue;\n        ans = (ans + numpos(n, ow, ew, ob)) % m;\n      }\n    }\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 59, mod = 1e9 + 7;\nint n, p;\nint a[MAXN];\nlong long pp[MAXN], dp[MAXN][2][2][2];\nint main() {\n  scanf(\"%d%d\", &n, &p);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n  pp[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    pp[i] = pp[i - 1] * 2 % mod;\n    if (i == 1) {\n      if (a[i] == 0)\n        dp[i][1][0][1] = 1;\n      else if (a[i] == 1)\n        dp[i][0][1][1] = 1;\n      else\n        dp[i][1][0][1] = dp[i][0][1][1] = 1;\n      continue;\n    }\n    if (a[i] == 0) {\n      dp[i][1][0][0] = dp[i - 1][1][0][1] * pp[i - 1] % mod;\n      dp[i][1][0][1] = dp[i - 1][1][0][0] * pp[i - 1] % mod;\n      dp[i][1][1][0] = (dp[i - 1][0][1][1] * pp[i - 2] % mod +\n                        dp[i - 1][1][1][0] * pp[i - 2] % mod +\n                        dp[i - 1][1][1][1] * pp[i - 2] % mod) %\n                       mod;\n      dp[i][1][1][1] = (dp[i - 1][0][1][0] * pp[i - 2] % mod +\n                        dp[i - 1][1][1][0] * pp[i - 2] % mod +\n                        dp[i - 1][1][1][1] * pp[i - 2] % mod) %\n                       mod;\n      dp[i][0][1][0] = (dp[i - 1][0][1][0] * pp[i - 2] % mod) % mod;\n      dp[i][0][1][1] = (dp[i - 1][0][1][1] * pp[i - 2] % mod) % mod;\n    } else if (a[i] == 1) {\n      dp[i][0][1][0] = dp[i - 1][0][1][1] * pp[i - 1] % mod;\n      dp[i][0][1][1] = dp[i - 1][0][1][0] * pp[i - 1] % mod;\n      dp[i][1][1][0] = (dp[i - 1][1][0][1] * pp[i - 2] % mod +\n                        dp[i - 1][1][1][0] * pp[i - 2] % mod +\n                        dp[i - 1][1][1][1] * pp[i - 2] % mod) %\n                       mod;\n      dp[i][1][1][1] = (dp[i - 1][1][0][0] * pp[i - 2] % mod +\n                        dp[i - 1][1][1][0] * pp[i - 2] % mod +\n                        dp[i - 1][1][1][1] * pp[i - 2] % mod) %\n                       mod;\n      dp[i][1][0][0] = (dp[i - 1][1][0][0] * pp[i - 2] % mod) % mod;\n      dp[i][1][0][1] = (dp[i - 1][1][0][1] * pp[i - 2] % mod) % mod;\n    } else {\n      dp[i][1][0][0] = dp[i - 1][1][0][1] * pp[i - 1] % mod;\n      dp[i][1][0][1] = dp[i - 1][1][0][0] * pp[i - 1] % mod;\n      dp[i][1][1][0] = (dp[i - 1][0][1][1] * pp[i - 2] % mod +\n                        dp[i - 1][1][1][0] * pp[i - 2] % mod +\n                        dp[i - 1][1][1][1] * pp[i - 2] % mod) %\n                       mod;\n      dp[i][1][1][1] = (dp[i - 1][0][1][0] * pp[i - 2] % mod +\n                        dp[i - 1][1][1][0] * pp[i - 2] % mod +\n                        dp[i - 1][1][1][1] * pp[i - 2] % mod) %\n                       mod;\n      dp[i][0][1][0] = (dp[i - 1][0][1][0] * pp[i - 2] % mod) % mod;\n      dp[i][0][1][1] = (dp[i - 1][0][1][1] * pp[i - 2] % mod) % mod;\n      dp[i][0][1][0] += dp[i - 1][0][1][1] * pp[i - 1] % mod,\n          dp[i][0][1][0] %= mod;\n      dp[i][0][1][1] += dp[i - 1][0][1][0] * pp[i - 1] % mod,\n          dp[i][0][1][1] %= mod;\n      dp[i][1][1][0] += (dp[i - 1][1][0][1] * pp[i - 2] % mod +\n                         dp[i - 1][1][1][0] * pp[i - 2] % mod +\n                         dp[i - 1][1][1][1] * pp[i - 2] % mod) %\n                        mod,\n          dp[i][1][1][0] %= mod;\n      dp[i][1][1][1] += (dp[i - 1][1][0][0] * pp[i - 2] % mod +\n                         dp[i - 1][1][1][0] * pp[i - 2] % mod +\n                         dp[i - 1][1][1][1] * pp[i - 2] % mod) %\n                        mod,\n          dp[i][1][1][1] %= mod;\n      dp[i][1][0][0] += (dp[i - 1][1][0][0] * pp[i - 2] % mod) % mod,\n          dp[i][1][0][0] %= mod;\n      dp[i][1][0][1] += (dp[i - 1][1][0][1] * pp[i - 2] % mod) % mod,\n          dp[i][1][0][1] %= mod;\n    }\n  }\n  printf(\"%lld\\n\", (dp[n][1][1][p] + dp[n][1][0][p] + dp[n][0][1][p]) % mod);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\ntemplate <class T>\nbool ckmin(T& a, const T& b) {\n  return a > b ? a = b, 1 : 0;\n}\ntemplate <class T>\nbool ckmax(T& a, const T& b) {\n  return a < b ? a = b, 1 : 0;\n}\nconst int N = 1 << 6, M = 1e9 + 7;\nint dp[N][2][2][2];\nint c[N], q[N];\ntemplate <class T>\nvoid add(T& a, const T& b) {\n  a += b;\n  if (M <= a) a -= M;\n}\nint mult(const int& a, ll b) { return a * b % M; }\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n;\n  short p;\n  cin >> n >> p;\n  for (int i = 1; i <= n; ++i) cin >> c[i];\n  q[0] = 1;\n  for (auto i = (1); i < (N); ++i) {\n    q[i] = (q[i - 1] << 1) % M;\n  }\n  int res = 0;\n  dp[0][0][0][0] = 1;\n  for (int i = 1, cur = 1; i <= n; ++i, cur ^= 1) {\n    for (auto w1 = (0); w1 < (2); ++w1) {\n      for (auto b1 = (0); b1 < (2); ++b1) {\n        for (auto parity = (0); parity < (2); ++parity) {\n          auto& x = dp[cur][w1][b1][parity];\n          x = 0;\n          if (c[i] != 1) {\n            add(x, mult(dp[!cur][w1][b1][parity], w1 ? q[i - 2] : 0));\n            if (b1)\n              add(x, mult(dp[!cur][w1][0][!parity] + dp[!cur][w1][1][!parity],\n                          w1 ? q[i - 2] : q[i - 1]));\n          }\n          if (c[i] != 0) {\n            add(x, mult(dp[!cur][w1][b1][parity], b1 ? q[i - 2] : 0));\n            if (w1)\n              add(x, mult(dp[!cur][0][b1][!parity] + dp[!cur][1][b1][!parity],\n                          b1 ? q[i - 2] : q[i - 1]));\n          }\n          if (i == n && p == parity) add(res, x);\n        }\n      }\n    }\n  }\n  cout << res;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool home = 1;\nsigned realMain();\nsigned main() {\n  home = 0;\n  if (home) {\n    freopen(\"tony_stark\", \"r\", stdin);\n  } else {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n  }\n  realMain();\n}\nconst int M = (int)1e9 + 7;\nint add(int a, int b) {\n  a += b;\n  if (a >= M) {\n    return a - M;\n  }\n  if (a < 0) {\n    return a + M;\n  }\n  return a;\n}\nint mul(int a, int b) { return a * (long long)b % M; }\nvoid baga(int &a, int x) { a = add(a, x); }\nconst int N = 50 + 7;\nint n, want;\nint dp[N][N][N][2];\nsigned realMain() {\n  cin >> n >> want;\n  dp[0][0][0][0] = 1;\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    if (x == 0 || x == -1) {\n      for (int p = 0; p <= 1; p++) {\n        for (int w = 0; w <= n; w++) {\n          for (int b = 0; b <= n; b++) {\n            if (!dp[i][w][b][p]) {\n              continue;\n            }\n            int x = b;\n            if (x == 0) {\n              int coef = (1LL << i) % M;\n              baga(dp[i + 1][w + 1][b][p ^ 1], mul(coef, dp[i][w][b][p]));\n            } else {\n              assert(i);\n              int half = (1LL << (i - 1)) % M;\n              baga(dp[i + 1][w][b][p], mul(half, dp[i][w][b][p]));\n              baga(dp[i + 1][w + 1][b][p ^ 1], mul(half, dp[i][w][b][p]));\n            }\n          }\n        }\n      }\n    }\n    if (x == 1 || x == -1) {\n      for (int p = 0; p <= 1; p++) {\n        for (int w = 0; w <= n; w++) {\n          for (int b = 0; b <= n; b++) {\n            if (!dp[i][w][b][p]) {\n              continue;\n            }\n            int x = w;\n            if (x == 0) {\n              int coef = (1LL << i) % M;\n              baga(dp[i + 1][w][b + 1][p ^ 1], mul(coef, dp[i][w][b][p]));\n            } else {\n              assert(i);\n              int half = (1LL << (i - 1)) % M;\n              baga(dp[i + 1][w][b][p], mul(half, dp[i][w][b][p]));\n              baga(dp[i + 1][w][b + 1][p ^ 1], mul(half, dp[i][w][b][p]));\n            }\n          }\n        }\n      }\n    }\n  }\n  for (int i = 0; i <= n; i++) {\n    for (int w = 0; w <= n; w++) {\n      for (int b = 0; b <= n; b++) {\n        for (int p = 0; p <= 1; p++) {\n          if (dp[i][w][b][p]) {\n          }\n        }\n      }\n    }\n  }\n  int sol = 0;\n  for (int w = 0; w <= n; w++) {\n    for (int b = 0; b <= n; b++) {\n      sol = add(sol, dp[n][w][b][want]);\n    }\n  }\n  cout << sol << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nstatic char s[1 << 20 | 1] = {0}, *p1 = s, *p2 = s;\ninline char gc() {\n  return (p1 == p2) && (p2 = (p1 = s) + fread(s, 1, 1 << 20, stdin), p1 == p2)\n             ? EOF\n             : *(p1++);\n}\ninline int read() {\n  int ret = 0;\n  bool flag = 0;\n  char c = gc();\n  while ((c < '0') | (c > '9')) flag ^= !(c ^ '-'), c = gc();\n  while ((c >= '0') & (c <= '9'))\n    ret = (ret << 1) + (ret << 3) + (c ^ '0'), c = gc();\n  return flag ? -ret : ret;\n}\nconst int MaxN = 111;\nconst int P = 1e9 + 7;\nint Po[MaxN] = {1}, Dp[MaxN][2][2][2], A[MaxN];\nint n, ans;\ninline int Mul(int x, int y) { return (long long)x * y % P; }\ninline int Add(int x, int y) { return (x += y) >= P ? x - P : x; }\ninline void Inc(int& x, int y) { x += y, x -= (x >= P) ? P : 0; }\ninline int c(int i, int g, int opt) {\n  if ((!i) && g) return 0;\n  if (opt) {\n    if (!g) return 0;\n    return Po[i - 1];\n  }\n  if (!g) return Po[i];\n  return Po[i - 1];\n}\nint main(void) {\n  int opt;\n  n = read(), opt = read();\n  for (int i = 1; i <= n; ++i) Po[i] = Mul(Po[i - 1], 2), A[i] = read();\n  Po[n + 1] = 0;\n  Dp[0][0][0][0] = 1;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j <= 1; ++j)\n      for (int k = 0; k <= 1; ++k)\n        for (int h = 0; h <= 1; ++h) {\n          if (A[i + 1] != 1)\n            Inc(Dp[i + 1][j][k][h], Mul(Dp[i][j][k][h], Po[k ? i - 1 : n + 1])),\n                Inc(Dp[i + 1][1][k][h ^ 1],\n                    Mul(Dp[i][j][k][h], Po[k ? i - 1 : i]));\n          if (A[i + 1])\n            Inc(Dp[i + 1][j][k][h], Mul(Dp[i][j][k][h], Po[j ? i - 1 : n + 1])),\n                Inc(Dp[i + 1][j][1][h ^ 1],\n                    Mul(Dp[i][j][k][h], Po[j ? i - 1 : i]));\n        }\n  ans = Add(Add(Dp[n][0][0][opt], Dp[n][0][1][opt]),\n            Add(Dp[n][1][1][opt], Dp[n][1][0][opt]));\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n,p=map(int,input().split())\nnums=[0]+list(map(int,input().split()))\nmod=10**9+7\n\nf=[[[[0]*2 for _ in range(2)] for _ in range(2)] for _ in range(n+1)]\n\n_2=[0]*(n+1)\n_2[0]=1\nfor i in range(1,n+1):\n    _2[i]=(_2[i-1]<<1)%mod\n    \nf[0][0][0][0]=1\nif nums[1]!=0:\n    f[1][1][0][1]+=1\nif nums[1]!=1:\n    f[1][1][1][0]+=1\n\nfor i in range(2,n+1):\n    for j in range(2):\n        for ob in range(2):\n            for ow in range(2):\n                qwq=f[i-1][j][ob][ow]\n                if nums[i]!=0:\n                    if ob:\n                        f[i][j][ob][ow]=(f[i][j][ob][ow]+qwq*_2[i-2])%mod\n                        f[i][j^1][ob][ow|1]=(f[i][j^1][ob][ow|1]+qwq*_2[i-2])%mod\n                    else:\n                        f[i][j^1][ob][ow|1]=(f[i][j^1][ob][ow|1]+qwq*_2[i-1])%mod\n                if nums[i]!=1:\n                    if ow:\n                        f[i][j][ob][ow]=(f[i][j][ob][ow]+qwq*_2[i-2])%mod\n                        f[i][j^1][ob|1][ow]=(f[i][j^1][ob|1][ow]+qwq*_2[i-2])%mod\n                    else:\n                        f[i][j^1][ob|1][ow]=(f[i][j^1][ob|1][ow]+qwq*_2[i-1])%mod\n\n\nans=0\nfor i in range(2):\n    for j in range(2):\n        ans=(ans+f[n][p][i][j])%mod\nprint(ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid chmax(T &a, T b) {\n  a = max(a, b);\n}\ntemplate <typename T>\nvoid chmin(T &a, T b) {\n  a = min(a, b);\n}\ntemplate <typename T>\nvoid chadd(T &a, T b) {\n  a = a + b;\n}\nlong long int dx[] = {0, 0, 1, -1};\nlong long int dy[] = {1, -1, 0, 0};\nconst long long INF = 1001001001001001LL;\nconst long long MOD = 1000000007LL;\nconst long long int S = 50;\nlong long int pw[4 * S + 10], odd[2 * S + 10], even[2 * S + 10];\nlong long int fact[2 * S + 10], inv[2 * S + 10];\nlong long int dp[S + 10][S + 10][S + 10][S + 10];\nlong long int mod_pow(long long int n, long long int k) {\n  long long int ret = 1;\n  for (; k > 0; k >>= 1) {\n    if (k & 1) (ret *= n) %= MOD;\n    (n *= n) %= MOD;\n  }\n  return ret;\n}\nlong long int comb(long long int n, long long int r) {\n  if (r < 0 || n < r) return 0;\n  return fact[n] * inv[n - r] % MOD * inv[r] % MOD;\n}\nsigned main() {\n  pw[0] = fact[0] = 1;\n  for (long long int i = 1; i <= 4 * S; i++) {\n    pw[i] = (pw[i - 1] * 2) % MOD;\n  }\n  for (long long int i = 1; i <= 2 * S; i++) {\n    fact[i] = (fact[i - 1] * i) % MOD;\n  }\n  inv[2 * S] = mod_pow(fact[2 * S], MOD - 2);\n  for (long long int i = 2 * S; i > 0; i--) {\n    inv[i - 1] = (inv[i] * i) % MOD;\n  }\n  for (long long int i = 0; i <= 2 * S; i++) {\n    for (long long int k = 0; k <= i; k += 2) {\n      (even[i] += comb(i, k)) %= MOD;\n    }\n    for (long long int k = 1; k <= i; k += 2) {\n      (odd[i] += comb(i, k)) %= MOD;\n    }\n  }\n  long long int N, P;\n  scanf(\"%lld%lld\", &N, &P);\n  vector<long long int> col(N);\n  for (long long int i = 0; i < N; i++) {\n    scanf(\"%lld\", &col[i]);\n  }\n  if (col[0] != 0) dp[1][1][0][0] = 1;\n  if (col[0] != 1) dp[1][0][0][1] = 1;\n  for (long long int i = 1; i < N; i++) {\n    for (long long int ow = 0; ow <= i; ow++) {\n      for (long long int ew = 0; ow + ew <= i; ew++) {\n        for (long long int ob = 0; ow + ew + ob <= i; ob++) {\n          long long int eb = i - ow - ew - ob;\n          long long int base1 = dp[i][ow][ew][ob] * pw[ow + ew + eb] % MOD;\n          long long int base2 = dp[i][ow][ew][ob] * pw[ob + eb + ew] % MOD;\n          if (col[i] != 0) {\n            (dp[i + 1][ow + 1][ew][ob] += base1 * even[ob] % MOD) %= MOD;\n            (dp[i + 1][ow][ew + 1][ob] += base1 * odd[ob] % MOD) %= MOD;\n          }\n          if (col[i] != 1) {\n            (dp[i + 1][ow][ew][ob + 1] += base2 * even[ow] % MOD) %= MOD;\n            (dp[i + 1][ow][ew][ob] += base2 * odd[ow] % MOD) %= MOD;\n          }\n        }\n      }\n    }\n  }\n  long long int ans = 0;\n  for (long long int ow = 0; ow <= N; ow++) {\n    for (long long int ew = 0; ow + ew <= N; ew++) {\n      for (long long int ob = 0; ow + ew + ob <= N; ob++) {\n        long long int eb = N - ow - ew - ob, val = dp[N][ow][ew][ob];\n        if ((ow + ob) % 2 == P) (ans += val) %= MOD;\n      }\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n/**\n * @author Don Li\n */\npublic class KuroAndTopologicalParity {\n    \n    int MOD = (int) 1e9 + 7;\n    int N = 55;\n    \n    long[] p2 = new long[N];\n    long[][] c = new long[N][N];\n    long[][] cs = new long[N][2];\n    \n    long[][][][] dp = new long[N][N][N][N];\n    \n    {\n        p2[0] = 1;\n        for (int i = 1; i < N; i++) p2[i] = p2[i - 1] * 2 % MOD;\n        \n        for (int i = 0; i < N; i++) {\n            c[i][0] = 1;\n            for (int j = 1; j <= i; j++) c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;\n        }\n        \n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j <= i; j++) {\n                cs[i][j & 1] = (cs[i][j & 1] + c[i][j]) % MOD;\n            }\n        }\n    }\n    \n    void solve() {\n        int n = in.nextInt(), p = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = in.nextInt();\n        \n        long ans = 0;\n        dp[0][0][0][0] = 1;\n        for (int i = 0; i < n; i++) {\n            for (int ob = 0; ob <= i + 1; ob++) {\n                for (int eb = 0; ob + eb <= i + 1; eb++) {\n                    for (int ow = 0; ob + eb + ow <= i + 1; ow++) {\n                        int ew = (i + 1) - (ob + eb + ow);\n                        calc(a[i], ob, eb, ow, ew);\n                        if (i + 1 == n && (ob + ow) % 2 == p) {\n                            ans = (ans + dp[ob][eb][ow][ew]) % MOD;\n                        }\n                    }\n                }\n            }\n        }\n        out.println(ans);\n    }\n    \n    void calc(int color, int ob, int eb, int ow, int ew) {\n        if (color != 0 && ew > 0) {\n            dp[ob][eb][ow][ew] += dp[ob][eb][ow][ew - 1] * p2[ow + ew + eb - 1] % MOD * cs[ob][1] % MOD;\n        }\n        if (color != 0 && ow > 0) {\n            dp[ob][eb][ow][ew] += dp[ob][eb][ow - 1][ew] * p2[ow + ew + eb - 1] % MOD * cs[ob][0] % MOD;\n        }\n        if (color != 1 && eb > 0) {\n            dp[ob][eb][ow][ew] += dp[ob][eb - 1][ow][ew] * p2[ob + eb + ew - 1] % MOD * cs[ow][1] % MOD;\n        }\n        if (color != 1 && ob > 0) {\n            dp[ob][eb][ow][ew] += dp[ob - 1][eb][ow][ew] * p2[ob + eb + ew - 1] % MOD * cs[ow][0] % MOD;\n        }\n        dp[ob][eb][ow][ew] %= MOD;\n    }\n    \n    public static void main(String[] args) {\n        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        new KuroAndTopologicalParity().solve();\n        out.close();\n    }\n    \n    static FastScanner in;\n    static PrintWriter out;\n    \n    static class FastScanner {\n        BufferedReader in;\n        StringTokenizer st;\n        \n        public FastScanner(BufferedReader in) {\n            this.in = in;\n        }\n        \n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        \n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n        \n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nint c[52];\nint dp[52][52][52][52];\nint add(int x, int y) { return ((x + y) % mod + mod) % mod; }\nint mul(int x, int y) { return (long long)x * y % mod; }\nint mypow(int x, int c) {\n  int ret = 1;\n  while (c > 0) {\n    if (c & 1) {\n      ret = mul(ret, x);\n    }\n    c /= 2;\n    x = mul(x, x);\n  }\n  return ret;\n}\nint combi[52][52], p2[52], odd[52], even[52];\nvoid solve() {\n  int n, p;\n  for (int i = 0; i < 52; ++i) {\n    combi[i][i] = combi[i][0] = 1;\n    for (int j = 1; j < i; ++j) {\n      combi[i][j] = add(combi[i - 1][j], combi[i - 1][j - 1]);\n    }\n    for (int j = 1; j <= i; j += 2) {\n      odd[i] = add(odd[i], combi[i][j]);\n    }\n    for (int j = 0; j <= i; j += 2) {\n      even[i] = add(even[i], combi[i][j]);\n    }\n  }\n  p2[0] = 1;\n  for (int i = 1; i < 52; ++i) {\n    p2[i] = mul(p2[i - 1], 2);\n  }\n  scanf(\"%d %d \", &n, &p);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d \", &c[i]);\n    if (c[i] == 0) {\n      c[i] = 2;\n    }\n    if (c[i] == -1) {\n      c[i] = 3;\n    }\n  }\n  dp[0][0][0][0] = 1;\n  for (int i = 0; i < n; ++i) {\n    for (int bit = 0; bit < 2; ++bit) {\n      if (c[i] & (1 << bit)) {\n        for (int a = 0; a <= i; ++a) {\n          for (int b = 0; a + b <= i; ++b) {\n            for (int c = 0; a + b + c <= i; ++c) {\n              int d = i - a - b - c;\n              int value;\n              if (bit == 0) {\n                value = mul(dp[i][a][b][c], mul(odd[b], p2[a]));\n                value = mul(value, p2[c + d]);\n                dp[i + 1][a][b][c + 1] = add(dp[i + 1][a][b][c + 1], value);\n                value = mul(dp[i][a][b][c], mul(even[b], p2[a]));\n                value = mul(value, p2[c + d]);\n                dp[i + 1][a][b][c] = add(dp[i + 1][a][b][c], value);\n              } else {\n                value = mul(dp[i][a][b][c], mul(odd[d], p2[c]));\n                value = mul(value, p2[a + b]);\n                dp[i + 1][a + 1][b][c] = add(dp[i + 1][a + 1][b][c], value);\n                value = mul(dp[i][a][b][c], mul(even[d], p2[c]));\n                value = mul(value, p2[a + b]);\n                dp[i + 1][a][b + 1][c] = add(dp[i + 1][a][b + 1][c], value);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  int ret = 0;\n  for (int a = 0; a <= n; ++a) {\n    for (int b = 0; a + b <= n; ++b) {\n      for (int c = 0; a + b + c <= n; ++c) {\n        int d = n - a - b - c;\n        if ((b + d) % 2 == p) {\n          ret = add(ret, dp[n][a][b][c]);\n        }\n      }\n    }\n  }\n  printf(\"%d\\n\", ret);\n}\nint main() {\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 55;\nconst int MOD = 1000000000 + 7;\nint dp[N][N][N][N];\nint c[N];\nlong long ceven[N];\nlong long codd[N];\nlong long fact[N];\nlong long inv_fact[N];\nlong long pow2[N];\nlong long power(long long s, long long p) {\n  long long base = s;\n  long long val = 1;\n  long long tmp = p;\n  while (tmp > 0) {\n    if (tmp & 1) val = (val * base) % MOD;\n    base = (base * base) % MOD;\n    tmp >>= 1;\n  }\n  return val;\n}\nvoid init() {\n  fact[0] = 1;\n  pow2[0] = 1;\n  for (int i = 1; i < N; i += 1) {\n    fact[i] = (i * fact[i - 1]) % MOD;\n    pow2[i] = (2 * pow2[i - 1]) % MOD;\n  }\n  inv_fact[N - 1] = power(fact[N - 1], MOD - 2);\n  for (int i = N - 2; i >= 0; i--)\n    inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD;\n  for (int i = 0; i < N; i += 1) {\n    for (int j = 0; j <= i; j += 2) {\n      ceven[i] += (((fact[i] * inv_fact[j]) % MOD) * inv_fact[i - j]) % MOD;\n      ceven[i] %= MOD;\n    }\n    for (int j = 1; j <= i; j += 2) {\n      codd[i] += (((fact[i] * inv_fact[j]) % MOD) * inv_fact[i - j]) % MOD;\n      codd[i] %= MOD;\n    }\n  }\n}\nint main() {\n  int n, p;\n  cin >> n >> p;\n  for (int i = 0; i < n; i += 1) cin >> c[i];\n  init();\n  long long ans = 0;\n  dp[0][0][0][0] = 1;\n  for (int i = 1; i <= n; i += 1) {\n    for (int w1 = 0; w1 <= i; w1 += 1) {\n      for (int w2 = 0; w2 + w1 <= i; w2 += 1) {\n        for (int b1 = 0; b1 + w2 + w1 <= i; b1 += 1) {\n          int b2 = i - w1 - w2 - b1;\n          if (c[i - 1] == 0 || c[i - 1] == -1) {\n            if (b1 > 0) {\n              dp[i][w1][w2][b1] +=\n                  (dp[i - 1][w1][w2][b1 - 1] * ceven[w1] % MOD) *\n                  pow2[w2 + b1 - 1 + b2] % MOD;\n              dp[i][w1][w2][b1] %= MOD;\n            }\n            if (b2 > 0) {\n              dp[i][w1][w2][b1] += (dp[i - 1][w1][w2][b1] * codd[w1] % MOD) *\n                                   pow2[w2 + b1 - 1 + b2] % MOD;\n              dp[i][w1][w2][b1] %= MOD;\n            }\n          }\n          if (c[i - 1] == 1 || c[i - 1] == -1) {\n            if (w1 > 0) {\n              dp[i][w1][w2][b1] +=\n                  (dp[i - 1][w1 - 1][w2][b1] * ceven[b1] % MOD) *\n                  pow2[w1 - 1 + w2 + b2] % MOD;\n              dp[i][w1][w2][b1] %= MOD;\n            }\n            if (w2 > 0) {\n              dp[i][w1][w2][b1] +=\n                  (dp[i - 1][w1][w2 - 1][b1] * codd[b1] % MOD) *\n                  pow2[w1 + w2 - 1 + b2] % MOD;\n              dp[i][w1][w2][b1] %= MOD;\n            }\n          }\n          if (i == n && ((w1 + b1) & 1) == p) {\n            ans += dp[i][w1][w2][b1];\n            ans %= MOD;\n          }\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nconst int maxn = 1e5 + 5;\nvoid add(int &x, int y) {\n  x += y;\n  if (x >= mod) x -= mod;\n}\nint mul(int x, int y) {\n  long long z = 1LL * x * y;\n  return z - z / mod * mod;\n}\nint f[2][51][51];\nint fp[55];\nint main() {\n  int n, p, i, k, a, c, u, v, x, ans = 0;\n  scanf(\"%d%d\", &n, &p);\n  for (i = fp[0] = 1; i <= n; i++) fp[i] = mul(fp[i - 1], 2);\n  f[0][0][0] = 1;\n  for (i = u = 0; i < n; i++) {\n    v = u ^ 1;\n    memset(f[v], 0, sizeof(f[v]));\n    scanf(\"%d\", &x);\n    for (a = 0; a <= i; a++) {\n      for (c = 0; a + c <= i; c++) {\n        k = f[u][a][c];\n        if (!k) continue;\n        if (x != 0) {\n          if (c) {\n            add(f[v][a + 1][c], mul(k, fp[i - 1]));\n            add(f[v][a][c], mul(k, fp[i - 1]));\n          } else\n            add(f[v][a + 1][c], mul(k, fp[i]));\n        }\n        if (x != 1) {\n          if (a) {\n            add(f[v][a][c + 1], mul(k, fp[i - 1]));\n            add(f[v][a][c], mul(k, fp[i - 1]));\n          } else\n            add(f[v][a][c + 1], mul(k, fp[i]));\n        }\n      }\n    }\n    u ^= 1;\n  }\n  for (a = 0; a <= n; a++) {\n    for (c = 0; a + c <= n; c++) {\n      if ((a + c + p + 1) & 1) add(ans, f[u][a][c]);\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nstatic char s[1 << 20 | 1] = {0}, *p1 = s, *p2 = s;\ninline char gc() {\n  return (p1 == p2) && (p2 = (p1 = s) + fread(s, 1, 1 << 20, stdin), p1 == p2)\n             ? EOF\n             : *(p1++);\n}\ninline int read() {\n  int ret = 0;\n  bool flag = 0;\n  char c = gc();\n  while ((c < '0') | (c > '9')) flag ^= !(c ^ '-'), c = gc();\n  while ((c >= '0') & (c <= '9'))\n    ret = (ret << 1) + (ret << 3) + (c ^ '0'), c = gc();\n  return flag ? -ret : ret;\n}\nconst int MaxN = 1111;\nconst int P = 1e9 + 7;\nint Po[MaxN] = {1}, Dp[MaxN][2][2][2], A[MaxN];\nint n, ans;\ninline int Mul(int x, int y) { return (long long)x * y % P; }\ninline int Add(int x, int y) { return (x += y) >= P ? x - P : x; }\ninline void Inc(int& x, int y) { x += y, x -= (x >= P) ? P : 0; }\ninline int c(int i, int g, int opt) {\n  if ((!i) && g) return 0;\n  if (opt) {\n    if (!g) return 0;\n    return Po[i - 1];\n  }\n  if (!g) return Po[i];\n  return Po[i - 1];\n}\nint main(void) {\n  int opt;\n  n = read(), opt = read();\n  for (int i = 1; i <= n; ++i) Po[i] = Mul(Po[i - 1], 2), A[i] = read();\n  Po[n + 1] = 0;\n  Dp[0][0][0][0] = 1;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j <= 1; ++j)\n      for (int k = 0; k <= 1; ++k)\n        for (int h = 0; h <= 1; ++h) {\n          if (A[i + 1] != 1)\n            Inc(Dp[i + 1][j][k][h], Mul(Dp[i][j][k][h], Po[k ? i - 1 : n + 1])),\n                Inc(Dp[i + 1][1][k][h ^ 1],\n                    Mul(Dp[i][j][k][h], Po[k ? i - 1 : i]));\n          if (A[i + 1])\n            Inc(Dp[i + 1][j][k][h], Mul(Dp[i][j][k][h], Po[j ? i - 1 : n + 1])),\n                Inc(Dp[i + 1][j][1][h ^ 1],\n                    Mul(Dp[i][j][k][h], Po[j ? i - 1 : i]));\n        }\n  ans = Add(Add(Dp[n][0][0][opt], Dp[n][0][1][opt]),\n            Add(Dp[n][1][1][opt], Dp[n][1][0][opt]));\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst long long mod = 1000000007;\nlong long n, p, _2[60], a[60];\nlong long f[60][2][2][2], ans;\nsigned main() {\n  scanf(\"%lld%lld\", &n, &p);\n  for (long long i = 1; i <= n; i++) scanf(\"%lld\", &a[i]);\n  _2[0] = 1;\n  for (long long i = 1; i <= n; i++) _2[i] = _2[i - 1] * 2 % mod;\n  f[0][0][0][0] = 1;\n  for (long long i = 1; i <= n; i++)\n    for (long long p = 0; p <= 1; p++)\n      for (long long b = 0; b <= 1; b++)\n        for (long long w = 0; w <= 1; w++) {\n          long long x = f[i - 1][p][b][w];\n          if (a[i] != 0) {\n            if (b) {\n              if (i == 1) continue;\n              (f[i][p][b][w] += x * _2[i - 2] % mod) %= mod;\n              (f[i][p ^ 1][b][w | 1] += x * _2[i - 2] % mod) %= mod;\n            } else\n              (f[i][p ^ 1][b][w | 1] += x * _2[i - 1] % mod) %= mod;\n          }\n          if (a[i] != 1) {\n            if (w) {\n              if (i == 1) continue;\n              (f[i][p][b][w] += x * _2[i - 2] % mod) %= mod;\n              (f[i][p ^ 1][b | 1][w] += x * _2[i - 2] % mod) %= mod;\n            } else\n              (f[i][p ^ 1][b | 1][w] += x * _2[i - 1] % mod) %= mod;\n          }\n        }\n  for (long long b = 0; b <= 1; b++)\n    for (long long w = 0; w <= 1; w++) (ans += f[n][p][b][w]) %= mod;\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint color[600];\nlong long C[600][600], sum0[600], sum1[600], f[2][600][600], mi[600];\nint main() {\n  int n, P;\n  scanf(\"%d%d\", &n, &P);\n  mi[0] = 1;\n  for (int i = 1; i <= n; i++) mi[i] = 2 * mi[i - 1] % 1000000007;\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &color[i]);\n  for (int i = 0; i <= n; i++) {\n    C[i][0] = 1;\n    for (int j = 1; j <= i; j++)\n      C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % 1000000007;\n  }\n  for (int i = 0; i <= n; i++)\n    for (int j = 0; j <= i; j++)\n      if (j % 2)\n        sum1[i] = (sum1[i] + C[i][j]) % 1000000007;\n      else\n        sum0[i] = (sum0[i] + C[i][j]) % 1000000007;\n  int p = 0, q = 1;\n  f[q][0][0] = 1;\n  for (int i = 0; i <= n - 1; i++) {\n    p ^= 1;\n    q ^= 1;\n    memset(f[q], 0, sizeof(f[q]));\n    for (int j = 0; j <= i; j++)\n      for (int k = 0; k <= i - j; k++) {\n        long long tmp = f[p][j][k] * mi[i - j - k] % 1000000007;\n        if (color[i + 1] != 1) {\n          f[q][j][k] =\n              (f[q][j][k] + tmp * mi[j] % 1000000007 * sum1[k] % 1000000007) %\n              1000000007;\n          f[q][j + 1][k] = (f[q][j + 1][k] +\n                            tmp * mi[j] % 1000000007 * sum0[k] % 1000000007) %\n                           1000000007;\n        }\n        if (color[i + 1] != 0) {\n          f[q][j][k] =\n              (f[q][j][k] + tmp * mi[k] % 1000000007 * sum1[j] % 1000000007) %\n              1000000007;\n          f[q][j][k + 1] = (f[q][j][k + 1] +\n                            tmp * mi[k] % 1000000007 * sum0[j] % 1000000007) %\n                           1000000007;\n        }\n      }\n  }\n  long long res = 0;\n  for (int i = 0; i <= n; i++)\n    for (int j = 0; j <= n - i; j++)\n      if ((i + j) % 2 == P) res = (res + f[q][i][j]) % 1000000007;\n  printf(\"%I64d\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\nint c[55], N, P;\nlong long DP[55][55][55][55];\nlong long p[55];\nint main() {\n  cin >> N >> P;\n  p[0] = 1;\n  for (int i = 1; i <= N; ++i) p[i] = p[i - 1] * 2 % MOD;\n  for (int i = 1; i <= N; ++i) cin >> c[i];\n  if (c[1] == 0) {\n    DP[1][0][1][0] = 1;\n  }\n  if (c[1] == 1) {\n    DP[1][0][0][0] = 1;\n  }\n  if (c[1] == -1) {\n    DP[1][0][1][0] = 1;\n    DP[1][0][0][0] = 1;\n  }\n  for (int i = 1; i < N; ++i) {\n    for (int we = 0; we <= i; ++we) {\n      for (int wo = 0; wo <= i; ++wo) {\n        for (int be = 0; be <= i; ++be) {\n          int bo = i - be - wo - we;\n          if (bo < 0) continue;\n          if (c[i + 1] == -1) {\n            DP[i + 1][we + 1][wo][be] +=\n                DP[i][we][wo][be] *\n                (p[we + wo + be] * (bo > 0 ? p[bo - 1] : 0) % MOD) % MOD;\n            if (DP[i + 1][we + 1][wo][be] >= MOD)\n              DP[i + 1][we + 1][wo][be] -= MOD;\n            DP[i + 1][we][wo + 1][be] +=\n                DP[i][we][wo][be] *\n                (p[we + wo + be] * (bo > 0 ? p[bo - 1] : 1) % MOD) % MOD;\n            if (DP[i + 1][we][wo + 1][be] >= MOD)\n              DP[i + 1][we][wo + 1][be] -= MOD;\n            DP[i + 1][we][wo][be + 1] +=\n                DP[i][we][wo][be] *\n                (p[we + be + bo] * (wo > 0 ? p[wo - 1] : 0) % MOD) % MOD;\n            if (DP[i + 1][we][wo][be + 1] >= MOD)\n              DP[i + 1][we][wo][be + 1] -= MOD;\n            DP[i + 1][we][wo][be] +=\n                DP[i][we][wo][be] *\n                (p[we + be + bo] * (wo > 0 ? p[wo - 1] : 1) % MOD) % MOD;\n            if (DP[i + 1][we][wo][be] >= MOD) DP[i + 1][we][wo][be] -= MOD;\n          } else {\n            if (c[i + 1] == 0) {\n              DP[i + 1][we + 1][wo][be] +=\n                  DP[i][we][wo][be] *\n                  (p[we + wo + be] * (bo > 0 ? p[bo - 1] : 0) % MOD) % MOD;\n              if (DP[i + 1][we + 1][wo][be] >= MOD)\n                DP[i + 1][we + 1][wo][be] -= MOD;\n              DP[i + 1][we][wo + 1][be] +=\n                  DP[i][we][wo][be] *\n                  (p[we + wo + be] * (bo > 0 ? p[bo - 1] : 1) % MOD) % MOD;\n              if (DP[i + 1][we][wo + 1][be] >= MOD)\n                DP[i + 1][we][wo + 1][be] -= MOD;\n            } else {\n              DP[i + 1][we][wo][be + 1] +=\n                  DP[i][we][wo][be] *\n                  (p[we + be + bo] * (wo > 0 ? p[wo - 1] : 0) % MOD) % MOD;\n              if (DP[i + 1][we][wo][be + 1] >= MOD)\n                DP[i + 1][we][wo][be + 1] -= MOD;\n              DP[i + 1][we][wo][be] +=\n                  DP[i][we][wo][be] *\n                  (p[we + be + bo] * (wo > 0 ? p[wo - 1] : 1) % MOD) % MOD;\n              if (DP[i + 1][we][wo][be] >= MOD) DP[i + 1][we][wo][be] -= MOD;\n            }\n          }\n        }\n      }\n    }\n  }\n  long long ret = 0;\n  for (int we = 0; we <= N; ++we) {\n    for (int wo = 0; wo <= N; ++wo) {\n      for (int be = 0; be <= N; ++be) {\n        int bo = N - we - wo - be;\n        if (bo < 0) continue;\n        int parity = we * 2 + wo + be * 2 + bo;\n        parity %= 2;\n        if (parity == P) {\n          ret += DP[N][we][wo][be];\n          if (ret >= MOD) ret -= MOD;\n        }\n      }\n    }\n  }\n  cout << ret << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\nint dp[2][57][57][57];\nint foo(int first) { return (1LL << first) % MOD; }\nint goo(int first, int second) {\n  if (first == 0) return (second == 0 ? 1 : 0);\n  return foo(first - 1);\n}\nvoid dodaj(int &a, int b) {\n  a += b;\n  a %= MOD;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  int n, p;\n  cin >> n >> p;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) cin >> a[i];\n  dp[0][0][0][0] = 1;\n  for (int i = 1; i <= n; i++) {\n    for (int q = 0; q < 2; q++) {\n      for (int b = 0; b < i; b++) {\n        for (int c = 0; b + c < i; c++) {\n          if (a[i - 1] != 0) {\n            dodaj(dp[q][i][b][c], 1LL * dp[q][i - 1][b][c] * goo(b, 1) % MOD *\n                                      foo(i - b - 1) % MOD);\n            dodaj(dp[1 - q][i][b][c + 1], 1LL * dp[q][i - 1][b][c] * goo(b, 0) %\n                                              MOD * foo(i - b - 1) % MOD);\n          }\n          if (a[i - 1] != 1) {\n            dodaj(dp[q][i][b][c], 1LL * dp[q][i - 1][b][c] * goo(c, 1) % MOD *\n                                      foo(i - c - 1) % MOD);\n            dodaj(dp[1 - q][i][b + 1][c], 1LL * dp[q][i - 1][b][c] * goo(c, 0) %\n                                              MOD * foo(i - c - 1) % MOD);\n          }\n        }\n      }\n    }\n  }\n  int ret = 0;\n  for (int i = 0; i <= n; i++) {\n    for (int j = 0; j <= n; j++) dodaj(ret, dp[p][n][i][j]);\n  }\n  cout << ret << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace my_std {\nconst long long inf = 0x3f3f3f3f;\nconst long long inff = 1e15;\ninline long long read() {\n  long long sum = 0, f = 1;\n  char ch = 0;\n  while (!isdigit(ch)) {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (isdigit(ch)) {\n    sum = sum * 10 + (ch ^ 48);\n    ch = getchar();\n  }\n  return sum * f;\n}\ninline void write(long long x) {\n  if (x < 0) {\n    x = -x;\n    putchar('-');\n  }\n  if (x > 9) write(x / 10);\n  putchar(x % 10 + '0');\n}\ninline void writeln(long long x) {\n  write(x);\n  putchar('\\n');\n}\ninline void writesp(long long x) {\n  write(x);\n  putchar(' ');\n}\n}  // namespace my_std\nusing namespace my_std;\nconst long long N = 55, mod = 1e9 + 7;\nlong long n, p, a[N], f[N][N][N][N], mi[N] = {1}, ans;\nint main(void) {\n  n = read(), p = read();\n  for (register long long i = (1); i <= (n); ++i) a[i] = read();\n  for (register long long i = (1); i <= (n); ++i)\n    mi[i] = (mi[i - 1] << 1) % mod;\n  if (a[1] == 1 || a[1] == -1) {\n    f[1][1][0][0] = 1;\n    if (p && n == 1) ans++;\n  }\n  if (!a[1] || a[1] == -1) {\n    f[1][0][1][0] = 1;\n    if (p && n == 1) ans++;\n  }\n  for (register long long i = (2); i <= (n); ++i)\n    for (register long long jb = (0); jb <= (i); ++jb)\n      for (register long long jh = (0); jh <= (i - jb); ++jh)\n        for (register long long ob = (0); ob <= (i - jb - jh); ++ob) {\n          long long oh = i - jb - jh - ob;\n          if (a[i] == 1 || a[i] == -1) {\n            long long add = 0;\n            if ((jb + ob) != 0) {\n              if (jb != 0) {\n                if (jh == 0)\n                  add = (add + f[i - 1][jb - 1][jh][ob]) % mod;\n                else\n                  add = (add + mi[jh - 1] * f[i - 1][jb - 1][jh][ob]) % mod;\n              }\n              if (ob != 0 && jh != 0)\n                add = (add + mi[jh - 1] * f[i - 1][jb][jh][ob - 1] % mod);\n            }\n            add = (add * mi[jb + ob + oh - 1]) % mod;\n            f[i][jb][jh][ob] = (f[i][jb][jh][ob] + add) % mod;\n          }\n          if (a[i] == 0 || a[i] == -1) {\n            long long add = 0;\n            if ((jh + oh) != 0) {\n              if (jh != 0) {\n                if (jb == 0)\n                  add = (add + f[i - 1][jb][jh - 1][ob]) % mod;\n                else\n                  add = (add + mi[jb - 1] * f[i - 1][jb][jh - 1][ob]) % mod;\n              }\n              if (jb != 0 && oh != 0)\n                add = (add + mi[jb - 1] * f[i - 1][jb][jh][ob] % mod) % mod;\n            }\n            add = (add * mi[jh + ob + oh - 1]) % mod;\n            f[i][jb][jh][ob] = (f[i][jb][jh][ob] + add) % mod;\n          }\n          if (i == n && (jb + jh) % 2 == p)\n            ans = (ans + f[i][jb][jh][ob]) % mod;\n        }\n  writeln(ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nconst int MAXN = 50;\nconst int MOD = 1000000007;\nint n, wantpar;\nint fixedcol[MAXN];\nint dp[MAXN + 1][MAXN + 1][MAXN + 1][MAXN + 1];\nint p2[MAXN + 1];\nint C[MAXN + 1][MAXN + 1];\nint fac[MAXN + 1];\nint wayspar[MAXN + 1][2];\nvoid inc(int &a, int b) {\n  if ((a += b) >= MOD) a -= MOD;\n}\nvoid run() {\n  scanf(\"%d%d\", &n, &wantpar);\n  for (int i = (0); i < (n); ++i) scanf(\"%d\", &fixedcol[i]);\n  p2[0] = 1;\n  for (int i = (1); i <= (n); ++i) p2[i] = (long long)p2[i - 1] * 2 % MOD;\n  for (int i = (0); i <= (n); ++i) {\n    C[i][0] = C[i][i] = 1;\n    for (int j = (1); j < (i); ++j)\n      C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;\n  }\n  fac[0] = 1;\n  for (int i = (1); i <= (n); ++i) fac[i] = (long long)fac[i - 1] * i % MOD;\n  for (int i = (0); i <= (n); ++i)\n    for (int j = (0); j <= (i); ++j) inc(wayspar[i][j % 2], C[i][j]);\n  int ret = 0;\n  memset(dp, 0, sizeof(dp));\n  dp[0][0][0][0] = 1;\n  for (int bevn = (0); bevn <= (n); ++bevn)\n    for (int bodd = (0); bodd <= (n); ++bodd)\n      for (int wevn = (0); wevn <= (n); ++wevn)\n        for (int wodd = (0); wodd <= (n); ++wodd) {\n          int cways = dp[bevn][bodd][wevn][wodd],\n              ccnt = bevn + bodd + wevn + wodd;\n          if (ccnt == n && (bodd + wodd) % 2 == wantpar) inc(ret, cways);\n          if (cways == 0 || ccnt >= n) continue;\n          for (int ncol = (0); ncol < (2); ++ncol) {\n            if (fixedcol[ccnt] != -1 && fixedcol[ccnt] != ncol) continue;\n            for (int npar = (0); npar < (2); ++npar) {\n              int na = ncol == 0 ? bevn + bodd + wevn : wevn + wodd + bevn,\n                  nb = ccnt - na;\n              int nways =\n                  (long long)cways * p2[na] % MOD * wayspar[nb][1 - npar] % MOD;\n              inc(dp[bevn + (ncol == 0 && npar == 0 ? 1 : 0)]\n                    [bodd + (ncol == 0 && npar == 1 ? 1 : 0)]\n                    [wevn + (ncol == 1 && npar == 0 ? 1 : 0)]\n                    [wodd + (ncol == 1 && npar == 1 ? 1 : 0)],\n                  nways);\n            }\n          }\n        }\n  printf(\"%d\\n\", ret);\n}\nint main() {\n  run();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 52, mod = 1e9 + 7;\nint c[N], dp[N][N][N], power[N];\ninline long long mul(int a, int b) { return 1LL * a * b % mod; }\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int n, p;\n  cin >> n >> p;\n  for (int i = 0; i < n; i++) cin >> c[i];\n  dp[0][0][0] = 1;\n  power[0] = 1;\n  for (int i = 1; i < N; i++) power[i] = 2LL * power[i - 1] % mod;\n  for (int i = 1; i <= n; i++)\n    for (int j = 0; j <= i; j++)\n      for (int k = 0; k + j <= i; k++) {\n        if (c[i - 1] != 1) {\n          long long ways = 0;\n          if (j) {\n            if (k == 0)\n              ways = power[i - 1];\n            else\n              ways = power[i - 2];\n            dp[i][j][k] += mul(ways, dp[i - 1][j - 1][k]), dp[i][j][k] %= mod;\n          }\n          if (k == 0)\n            ways = 0;\n          else\n            ways = power[i - 2];\n          dp[i][j][k] += mul(ways, dp[i - 1][j][k]), dp[i][j][k] %= mod;\n        }\n        if (c[i - 1] != 0) {\n          long long ways = 0;\n          if (k) {\n            if (j == 0)\n              ways = power[i - 1];\n            else\n              ways = power[i - 2];\n            dp[i][j][k] += mul(ways, dp[i - 1][j][k - 1]) % mod,\n                dp[i][j][k] %= mod;\n          }\n          if (j == 0)\n            ways = 0;\n          else\n            ways = power[i - 2];\n          dp[i][j][k] += mul(ways, dp[i - 1][j][k]) % mod, dp[i][j][k] %= mod;\n        }\n      }\n  int ans = 0;\n  for (int j = 0; j <= n; j++)\n    for (int k = 0; k + j <= n; k++)\n      if ((k + j) % 2 == p) ans += dp[n][j][k], ans %= mod;\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 55, mod = 1e9 + 7;\nint n, p, a[N];\nlong long ans, pw[N], f[N][8];\ninline int calc(int x, int y, int z) { return (x << 2) | (y << 1) | z; }\nint main() {\n  scanf(\"%d%d\", &n, &p);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  pw[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    pw[i] = pw[i - 1] * 2 % mod;\n  }\n  f[0][0] = 1;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < 8; j++) {\n      int x = (j >> 2) & 1, y = (j >> 1) & 1, z = j & 1;\n      if (!f[i][j]) {\n        continue;\n      }\n      if (a[i + 1] != 0) {\n        if (z) {\n          f[i + 1][calc(x, y, z)] =\n              (f[i + 1][calc(x, y, z)] + f[i][j] * pw[i - 1] % mod) % mod;\n          f[i + 1][calc(x ^ 1, 1, z)] =\n              (f[i + 1][calc(x ^ 1, 1, z)] + f[i][j] * pw[i - 1] % mod) % mod;\n        } else {\n          f[i + 1][calc(x ^ 1, 1, z)] =\n              (f[i + 1][calc(x ^ 1, 1, z)] + pw[i] * f[i][j] % mod) % mod;\n        }\n      }\n      if (a[i + 1] != 1) {\n        if (y) {\n          f[i + 1][calc(x, y, z)] =\n              (f[i + 1][calc(x, y, z)] + f[i][j] * pw[i - 1] % mod) % mod;\n          f[i + 1][calc(x ^ 1, y, 1)] =\n              (f[i + 1][calc(x ^ 1, y, 1)] + f[i][j] * pw[i - 1] % mod) % mod;\n        } else {\n          f[i + 1][calc(x ^ 1, y, 1)] =\n              (f[i + 1][calc(x ^ 1, y, 1)] + pw[i] * f[i][j]) % mod;\n        }\n      }\n    }\n  }\n  for (int j = 0; j < 4; j++) {\n    ans = (ans + f[n][(p << 2) | j]) % mod;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst long long INFF = 0x3f3f3f3f3f3f3f3fll;\nconst long long M = 1e9 + 7;\nconst long long maxn = 1e5 + 7;\nconst double pi = acos(-1.0);\nconst double eps = 0.00000001;\nlong long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }\ntemplate <typename T>\ninline T abs(T a) {\n  return a > 0 ? a : -a;\n}\ntemplate <typename T>\ninline T powMM(T a, T b) {\n  T ret = 1;\n  for (; b; b >>= 1ll, a = (long long)a * a % M)\n    if (b & 1) ret = (long long)ret * a % M;\n  return ret;\n}\nlong long f[57][57][57][2];\nint A[57];\nlong long pow2[57];\ninline int get(int x) {\n  if (!x) return 1;\n  return pow2[x - 1];\n}\nint main() {\n  int n, p;\n  int i, j, k, t, status;\n  pow2[0] = 1;\n  for (i = 1; i <= 50; i++) pow2[i] = pow2[i - 1] * 2 % M;\n  scanf(\"%d%d\", &n, &p);\n  for (i = 1; i <= n; i++) scanf(\"%d\", &A[i]);\n  f[0][0][0][0] = 1;\n  for (k = 1; k <= n; k++) {\n    for (status = 0; status < 2; status++) {\n      for (i = 0; i < k; i++) {\n        for (j = 0; j < k; j++) {\n          if (f[k - 1][i][j][status]) {\n            if (A[k] != 1) {\n              (f[k][i + 1][j][status ^ 1] +=\n               f[k - 1][i][j][status] * pow2[k - j - 1] % M * get(j)) %= M;\n              (f[k][i][j][status] += f[k - 1][i][j][status] * pow2[k - j - 1] %\n                                     M * (pow2[j] - get(j))) %= M;\n            }\n            if (A[k] != 0) {\n              (f[k][i][j + 1][status ^ 1] +=\n               f[k - 1][i][j][status] * pow2[k - i - 1] % M * get(i)) %= M;\n              (f[k][i][j][status] += f[k - 1][i][j][status] * pow2[k - i - 1] %\n                                     M * (pow2[i] - get(i))) %= M;\n            }\n          }\n        }\n      }\n    }\n  }\n  long long ans = 0;\n  for (i = 0; i <= n; i++)\n    for (j = 0; j <= n; j++) ans += f[n][i][j][p];\n  ans %= M;\n  ans += M;\n  ans %= M;\n  printf(\"%I64d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 52;\nconst long long mod = 1e9 + 7;\nlong long dp[N][N][N], odd[N], even[N], c[N][N], color[N], mul[N];\nsigned main() {\n  long long n, i, j, k, l, par, ans = 0;\n  cin >> n >> par;\n  for (i = 1; i <= n; i++) {\n    cin >> color[i];\n  }\n  c[0][0] = 1;\n  even[0] = 1;\n  mul[0] = 1;\n  for (i = 1; i <= n; i++) {\n    mul[i] = (mul[i - 1] * 2) % mod;\n    for (j = 0; j <= i; j++) {\n      c[j][i] = c[j][i - 1];\n      if (j) {\n        c[j][i] += c[j - 1][i - 1];\n        c[j][i] %= mod;\n      }\n      if (j % 2 == 0) {\n        even[i] += c[j][i];\n        even[i] %= mod;\n      } else {\n        odd[i] += c[j][i];\n        odd[i] %= mod;\n      }\n    }\n  }\n  dp[0][0][0] = 1;\n  for (i = 1; i <= n; i++) {\n    for (j = 0; j <= i; j++) {\n      for (k = 0; k <= i - j; k++) {\n        if (color[i] == -1) {\n          if (i - 1 - k >= 0) {\n            dp[i][j][k] += (dp[i - 1][j][k] * mul[i - 1 - k]) % mod * odd[k];\n          }\n          if (i - 1 - j >= 0) {\n            dp[i][j][k] += (dp[i - 1][j][k] * mul[i - 1 - j]) % mod * odd[j];\n          }\n          if (j) {\n            if (i - 1 - k >= 0) {\n              dp[i][j][k] +=\n                  (dp[i - 1][j - 1][k] * even[k]) % mod * mul[i - 1 - k];\n            }\n          }\n          if (k) {\n            if (i - 1 - j >= 0) {\n              dp[i][j][k] +=\n                  (dp[i - 1][j][k - 1] * even[j]) % mod * mul[i - 1 - j];\n            }\n          }\n        } else {\n          if (color[i] == 0) {\n            if (i - 1 - k >= 0) {\n              dp[i][j][k] += (dp[i - 1][j][k] * mul[i - 1 - k]) % mod * odd[k];\n            }\n            if (j) {\n              if (i - 1 - k >= 0) {\n                dp[i][j][k] +=\n                    (dp[i - 1][j - 1][k] * even[k]) % mod * mul[i - 1 - k];\n              }\n            }\n          } else {\n            if (i - 1 - j >= 0) {\n              dp[i][j][k] += (dp[i - 1][j][k] * mul[i - 1 - j]) % mod * odd[j];\n            }\n            if (k) {\n              if (i - 1 - j >= 0) {\n                dp[i][j][k] +=\n                    (dp[i - 1][j][k - 1] * even[j]) % mod * mul[i - 1 - j];\n              }\n            }\n          }\n        }\n        dp[i][j][k] %= mod;\n        if (i == n && (j + k) % 2 == par) {\n          ans += dp[i][j][k];\n          ans %= mod;\n        }\n      }\n    }\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\ninline void ckmax(T& x, T y) {\n  x = (y > x ? y : x);\n}\ntemplate <typename T>\ninline void ckmin(T& x, T y) {\n  x = (y < x ? y : x);\n}\nnamespace Fread {\nconst int SIZE = 1 << 21;\nchar buf[SIZE], *S, *T;\ninline char getchar() {\n  if (S == T) {\n    T = (S = buf) + fread(buf, 1, SIZE, stdin);\n    if (S == T) return EOF;\n  }\n  return *S++;\n}\n}  // namespace Fread\nnamespace Fwrite {\nconst int SIZE = 1 << 21;\nchar buf[SIZE], *S = buf, *T = buf + SIZE;\ninline void flush() {\n  fwrite(buf, 1, S - buf, stdout);\n  S = buf;\n}\ninline void putchar(char c) {\n  *S++ = c;\n  if (S == T) flush();\n}\nstruct NTR {\n  ~NTR() { flush(); }\n} ztr;\n}  // namespace Fwrite\nnamespace Fastio {\nstruct Reader {\n  template <typename T>\n  Reader& operator>>(T& x) {\n    char c = Fread ::getchar();\n    T f = 1;\n    while (c < '0' || c > '9') {\n      if (c == '-') f = -1;\n      c = Fread ::getchar();\n    }\n    x = 0;\n    while (c >= '0' && c <= '9') {\n      x = x * 10 + (c - '0');\n      c = Fread ::getchar();\n    }\n    x *= f;\n    return *this;\n  }\n  Reader& operator>>(char& c) {\n    c = Fread ::getchar();\n    while (c == '\\n' || c == ' ') c = Fread ::getchar();\n    return *this;\n  }\n  Reader& operator>>(char* str) {\n    int len = 0;\n    char c = Fread ::getchar();\n    while (c == '\\n' || c == ' ') c = Fread ::getchar();\n    while (c != '\\n' && c != ' ') {\n      str[len++] = c;\n      c = Fread ::getchar();\n    }\n    str[len] = '\\0';\n    return *this;\n  }\n  Reader() {}\n} cin;\nconst char endl = '\\n';\nstruct Writer {\n  template <typename T>\n  Writer& operator<<(T x) {\n    if (x == 0) {\n      Fwrite ::putchar('0');\n      return *this;\n    }\n    if (x < 0) {\n      Fwrite ::putchar('-');\n      x = -x;\n    }\n    static int sta[45];\n    int top = 0;\n    while (x) {\n      sta[++top] = x % 10;\n      x /= 10;\n    }\n    while (top) {\n      Fwrite ::putchar(sta[top] + '0');\n      --top;\n    }\n    return *this;\n  }\n  Writer& operator<<(char c) {\n    Fwrite ::putchar(c);\n    return *this;\n  }\n  Writer& operator<<(char* str) {\n    int cur = 0;\n    while (str[cur]) Fwrite ::putchar(str[cur++]);\n    return *this;\n  }\n  Writer& operator<<(const char* str) {\n    int cur = 0;\n    while (str[cur]) Fwrite ::putchar(str[cur++]);\n    return *this;\n  }\n  Writer() {}\n} cout;\n}  // namespace Fastio\nconst int MAXN = 1e5;\nconst int MOD = 1e9 + 7;\ninline int mod1(int x) { return x < MOD ? x : x - MOD; }\ninline int mod2(int x) { return x < 0 ? x + MOD : x; }\ninline void add(int& x, int y) { x = mod1(x + y); }\ninline void sub(int& x, int y) { x = mod2(x - y); }\nint n, goal, a[MAXN + 5];\nint pw2[MAXN + 5];\nint dp[MAXN + 5][2][2][2];\ninline int calc0(int i, int have_1) {\n  if (have_1) assert(i);\n  return have_1 ? pw2[i - 1] : pw2[i];\n}\ninline int calc1(int i, int have_1) {\n  if (have_1) assert(i);\n  return have_1 ? pw2[i - 1] : 0;\n}\nint main() {\n  Fastio ::cin >> n >> goal;\n  for (int i = 1; i <= n; ++i) {\n    Fastio ::cin >> a[i];\n  }\n  pw2[0] = 1;\n  for (int i = 1; i <= n; ++i) pw2[i] = pw2[i - 1] * 2 % MOD;\n  dp[0][0][0][0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    for (int have_r1 = 0; have_r1 <= 1; ++have_r1) {\n      for (int have_b1 = 0; have_b1 <= 1; ++have_b1) {\n        for (int s = 0; s <= 1; ++s)\n          if (dp[i - 1][have_r1][have_b1][s]) {\n            if (a[i] != 1) {\n              add(dp[i][have_r1][have_b1][s],\n                  (long long)dp[i - 1][have_r1][have_b1][s] *\n                      calc1(i - 1, have_b1) % MOD);\n              add(dp[i][have_r1 | 1][have_b1][s ^ 1],\n                  (long long)dp[i - 1][have_r1][have_b1][s] *\n                      calc0(i - 1, have_b1) % MOD);\n            }\n            if (a[i] != 0) {\n              add(dp[i][have_r1][have_b1][s],\n                  (long long)dp[i - 1][have_r1][have_b1][s] *\n                      calc1(i - 1, have_r1) % MOD);\n              add(dp[i][have_r1][have_b1 | 1][s ^ 1],\n                  (long long)dp[i - 1][have_r1][have_b1][s] *\n                      calc0(i - 1, have_r1) % MOD);\n            }\n          }\n      }\n    }\n  }\n  int ans = 0;\n  for (int have_r1 = 0; have_r1 <= 1; ++have_r1) {\n    for (int have_b1 = 0; have_b1 <= 1; ++have_b1) {\n      add(ans, dp[n][have_r1][have_b1][goal]);\n    }\n  }\n  Fastio ::cout << ans << Fastio ::endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint const MAX = 52;\nint const MOD = 1e9 + 7;\nint n, p;\nint c[MAX];\nint d[MAX][MAX][MAX][MAX];\nint C[MAX][MAX];\nint ans;\nint add(int a, int b) {\n  a += b;\n  if (a >= MOD) a -= MOD;\n  return a;\n}\nint mult(int a, int b) { return (long long)a * b % MOD; }\nint p2[MAX * MAX];\nint C0[MAX];\nint C1[MAX];\nvoid init() {\n  for (int i = 0; i <= MAX - 1; i++) {\n    C[i][0] = 1;\n    for (int j = 1; j <= i; j++) {\n      C[i][j] = add(C[i - 1][j - 1], C[i - 1][j]);\n    }\n  }\n  for (int i = 0; i <= MAX - 1; i++) {\n    for (int j = 0; j <= i; j += 2) {\n      C0[i] = add(C0[i], C[i][j]);\n    }\n    for (int j = 1; j <= i; j += 2) {\n      C1[i] = add(C1[i], C[i][j]);\n    }\n  }\n  p2[0] = 1;\n  for (int i = 1; i <= MAX * MAX - 1; i++) {\n    p2[i] = add(p2[i - 1], p2[i - 1]);\n  }\n}\nvoid solve() {\n  d[1][0][0][0] = 1;\n  for (int i = 1; i <= n; i++) {\n    for (int w = 0; w < i; w++) {\n      for (int w1 = 0; w1 <= w; w1++) {\n        for (int b1 = 0; b1 <= i - 1 - w; b1++) {\n          if (!d[i][w][w1][b1]) continue;\n          int w0 = w - w1;\n          int b0 = (i - 1 - w) - b1;\n          if (c[i] != 1) {\n            {\n              int nw1 = w1;\n              int v1 = C1[b1];\n              int v2 = p2[b0];\n              int v3 = d[i][w][w1][b1];\n              int v = mult(v1, mult(v2, v3));\n              d[i + 1][w + 1][nw1][b1] = add(d[i + 1][w + 1][nw1][b1], v);\n            }\n            {\n              int nw1 = w1 + 1;\n              int v1 = C0[b1];\n              int v2 = p2[b0];\n              int v3 = d[i][w][w1][b1];\n              int v = mult(v1, mult(v2, v3));\n              d[i + 1][w + 1][nw1][b1] = add(d[i + 1][w + 1][nw1][b1], v);\n            }\n          }\n          if (c[i] != 0) {\n            {\n              int nb1 = b1;\n              int v1 = C1[w1];\n              int v2 = p2[w0];\n              int v3 = d[i][w][w1][b1];\n              int v = mult(v1, mult(v2, v3));\n              d[i + 1][w][w1][nb1] = add(d[i + 1][w][w1][nb1], v);\n            }\n            {\n              int nb1 = b1 + 1;\n              int v1 = C0[w1];\n              int v2 = p2[w0];\n              int v3 = d[i][w][w1][b1];\n              int v = mult(v1, mult(v2, v3));\n              d[i + 1][w][w1][nb1] = add(d[i + 1][w][w1][nb1], v);\n            }\n          }\n        }\n      }\n    }\n  }\n  for (int w = 0; w <= n; w++) {\n    for (int w1 = 0; w1 <= n; w1++) {\n      for (int b1 = 0; b1 <= n; b1++) {\n        if (!d[n + 1][w][w1][b1]) continue;\n        if ((w1 + b1) % 2 != p) continue;\n        int b = n - w;\n        int v1 = d[n + 1][w][w1][b1];\n        int v2 = p2[b * (b - 1) / 2];\n        int v3 = p2[w * (w - 1) / 2];\n        int v = mult(v1, mult(v2, v3));\n        ans = add(ans, v);\n      }\n    }\n  }\n  printf(\"%d\\n\", ans);\n}\nint main() {\n  init();\n  scanf(\"%d %d\", &n, &p);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &c[i]);\n  }\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 50 + 5, mod = 1e9 + 7, inf = 1e9 + 7;\nlong long n, p, ans;\nlong long a[N], pw[N], fac[N], invfac[N];\nlong long odd[N], even[N];\nlong long dp[N][N][N][N];\nlong long binpow(long long x, long long y) {\n  long long ans = 1;\n  while (y) {\n    if (y & 1) ans = (ans * x) % mod;\n    x = (x * x) % mod;\n    y >>= 1;\n  }\n  return ans;\n}\nlong long C(long long x, long long y) {\n  return ((fac[x] * invfac[y]) % mod * invfac[x - y]) % mod;\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  dp[0][0][0][0] = 1;\n  pw[0] = 1;\n  fac[0] = 1;\n  for (long long i = 1; i < N; i++) {\n    pw[i] = (pw[i - 1] * 2) % mod;\n    fac[i] = (fac[i - 1] * i) % mod;\n  }\n  invfac[N - 1] = binpow(fac[N - 1], mod - 2);\n  for (long long i = N - 2; i >= 0; i--) {\n    invfac[i] = (invfac[i + 1] * (i + 1)) % mod;\n  }\n  for (long long i = 0; i < N; i++) {\n    for (long long j = 0; j <= i; j++) {\n      if (j & 1) {\n        odd[i] = (odd[i] + C(i, j)) % mod;\n      } else {\n        even[i] = (even[i] + C(i, j)) % mod;\n      }\n    }\n  }\n  cin >> n >> p;\n  for (long long i = 1; i <= n; i++) {\n    cin >> a[i];\n  }\n  for (long long i = 1; i <= n; i++) {\n    for (long long ob = 0; ob <= i; ob++) {\n      for (long long emplace_back = 0; emplace_back <= i - ob; emplace_back++) {\n        for (long long ow = 0; ow <= i - ob - emplace_back; ow++) {\n          long long ew = i - ob - emplace_back - ow;\n          if (a[i] != 0 && ew != 0) {\n            dp[ob][emplace_back][ow][ew] = (dp[ob][emplace_back][ow][ew] +\n                                            ((dp[ob][emplace_back][ow][ew - 1] *\n                                              pw[ow + ew - 1 + emplace_back]) %\n                                             mod * odd[ob]) %\n                                                mod) %\n                                           mod;\n          }\n          if (a[i] != 0 && ow != 0) {\n            dp[ob][emplace_back][ow][ew] = (dp[ob][emplace_back][ow][ew] +\n                                            ((dp[ob][emplace_back][ow - 1][ew] *\n                                              pw[ow - 1 + ew + emplace_back]) %\n                                             mod * even[ob]) %\n                                                mod) %\n                                           mod;\n          }\n          if (a[i] != 1 && emplace_back != 0) {\n            dp[ob][emplace_back][ow][ew] = (dp[ob][emplace_back][ow][ew] +\n                                            ((dp[ob][emplace_back - 1][ow][ew] *\n                                              pw[ob + emplace_back - 1 + ew]) %\n                                             mod * odd[ow]) %\n                                                mod) %\n                                           mod;\n          }\n          if (a[i] != 1 && ob != 0) {\n            dp[ob][emplace_back][ow][ew] = (dp[ob][emplace_back][ow][ew] +\n                                            ((dp[ob - 1][emplace_back][ow][ew] *\n                                              pw[ob - 1 + emplace_back + ew]) %\n                                             mod * even[ow]) %\n                                                mod) %\n                                           mod;\n          }\n          if (i == n && ((ob + ow) & 1) == p) {\n            ans = (ans += dp[ob][emplace_back][ow][ew]) % mod;\n          }\n        }\n      }\n    }\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int x = 0, f = 1;\n  char c = getchar();\n  while (!isdigit(c)) {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (isdigit(c)) {\n    x = x * 10 + c - '0';\n    c = getchar();\n  }\n  return x * f;\n}\nconst int maxn = 2e5 + 10;\nconst int mod = 1e9 + 7;\ntemplate <typename T>\ninline void Sol(T &x) {\n  if (x >= mod) x -= mod;\n}\ntemplate <typename T1, typename T2>\ninline void Add(T1 &x, T2 y) {\n  x += y;\n  Sol(x);\n}\ntemplate <typename T1, typename T2>\ninline void Dec(T1 &x, T2 y) {\n  x += mod - y;\n  Sol(x);\n}\nint n, p, f[2][2][2][2], pw[maxn], c[maxn];\nint main() {\n  n = read(), p = read();\n  pw[0] = 1;\n  for (int i = 1; i <= n; i++) c[i] = read();\n  for (int i = 1; i <= n; i++) pw[i] = (pw[i - 1] << 1) % mod;\n  if (c[1] == 0)\n    f[1][0][1][1] = 1;\n  else if (c[1] == 1)\n    f[1][1][0][1] = 1;\n  else\n    f[1][0][1][1] = f[1][1][0][1] = 1;\n  for (int i = 1; i < n; i++) {\n    int np = i & 1, p = np ^ 1;\n    memset(f[p], 0, sizeof f[p]);\n    for (int j = 0; j < 2; j++)\n      for (int k = 0; k < 2; k++)\n        for (int l = 0; l < 2; l++)\n          if (f[np][j][k][l]) {\n            int now = 1LL * pw[i - 1] * f[np][j][k][l] % mod;\n            if (c[i + 1] != 0) {\n              if (k)\n                Add(f[p][j][k][l], now), Add(f[p][j | 1][k][l ^ 1], now);\n              else\n                Add(f[p][j | 1][k][l ^ 1], 1LL * (now << 1) % mod);\n            }\n            if (c[i + 1] != 1) {\n              if (j)\n                Add(f[p][j][k][l], now), Add(f[p][j][k | 1][l ^ 1], now);\n              else\n                Add(f[p][j][k | 1][l ^ 1], 1LL * (now << 1) % mod);\n            }\n          }\n  }\n  int ans = 0, np = n & 1;\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 2; j++) Add(ans, f[np][i][j][p]);\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing std::cin;\nusing std::cout;\nconst int maxn = 53;\nconst int mod = 1e9 + 7;\nint dp[maxn][maxn][maxn];\nint c[maxn];\nint n, p;\nint pw[maxn];\ninline long long dfs(int i, int j, int k) {\n  if (j < 0 || k < 0) return 0;\n  if (i == n) {\n    if (j == 0) return k == 1 && c[n] != 1;\n    if (k == 0) return j == 1 && c[n] != 0;\n    return 0;\n  }\n  int& ans = dp[i][j][k];\n  if (~ans) return ans;\n  ans = 0;\n  for (int i0 = (0), i0end = (1); i0 <= i0end; ++i0)\n    if (i0 ^ c[i] ^ 1) {\n      if (i0 ? k : j) {\n        ans = (ans + (long long)dfs(i + 1, j, k) * pw[n - i - 1]) % mod;\n        --(i0 ? j : k);\n        ans = (ans + (long long)dfs(i + 1, j, k) * pw[n - i - 1]) % mod;\n        ++(i0 ? j : k);\n      } else {\n        --(i0 ? j : k);\n        ans = (ans + (long long)dfs(i + 1, j, k) * pw[n - i]) % mod;\n        ++(i0 ? j : k);\n      }\n    }\n  return ans;\n}\nint main() {\n  memset(dp, -1, sizeof dp);\n  std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n  cin >> n >> p;\n  for (int i = (1), iend = (n); i <= iend; ++i) {\n    cin >> c[i];\n  }\n  int ans = 0;\n  *pw = 1;\n  for (int i = 1; i <= n; ++i) {\n    pw[i] = pw[i - 1] * 2 % mod;\n  }\n  for (int i = (0), iend = (n); i <= iend; ++i)\n    for (int j = (0), jend = (n); j <= jend; ++j)\n      if (i + j <= n && (i + j) % 2 == p) {\n        ans += dfs(1, i, j) - mod;\n        ans += ans >> 31 & mod;\n      }\n  cout << ans << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 55, mod = 1000000007;\nint dp[N][N][N][N], n, c[N], pw[N], jo;\nvoid upd(int& x) {\n  if (x >= mod) x -= mod;\n}\nint main() {\n  scanf(\"%d%d\", &n, &jo);\n  pw[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &c[i]);\n    pw[i] = pw[i - 1] * 2 % mod;\n  }\n  dp[0][0][0][0] = 1;\n  for (int i = 1; i <= n; i++) {\n    for (int b0 = 0; b0 < i; b0++) {\n      for (int b1 = 0; b0 + b1 < i; b1++) {\n        for (int c0 = 0; b0 + b1 + c0 < i; c0++) {\n          int c1 = i - b0 - b1 - c0 - 1;\n          if (c[i] == -1 || c[i] == 0) {\n            if (c1) {\n              dp[i][b0 + 1][b1][c0] +=\n                  (long long)dp[i - 1][b0][b1][c0] * pw[i - 2] % mod;\n              dp[i][b0][b1 + 1][c0] +=\n                  (long long)dp[i - 1][b0][b1][c0] * pw[i - 2] % mod;\n            } else {\n              dp[i][b0][b1 + 1][c0] +=\n                  (long long)dp[i - 1][b0][b1][c0] * pw[i - 1] % mod;\n            }\n            upd(dp[i][b0 + 1][b1][c0]), upd(dp[i][b0][b1 + 1][c0]);\n          }\n          if (c[i] == -1 || c[i] == 1) {\n            if (b1) {\n              dp[i][b0][b1][c0 + 1] +=\n                  (long long)dp[i - 1][b0][b1][c0] * pw[i - 2] % mod;\n              dp[i][b0][b1][c0] +=\n                  (long long)dp[i - 1][b0][b1][c0] * pw[i - 2] % mod;\n            } else {\n              dp[i][b0][b1][c0] +=\n                  (long long)dp[i - 1][b0][b1][c0] * pw[i - 1] % mod;\n            }\n            upd(dp[i][b0][b1][c0 + 1]), upd(dp[i][b0][b1][c0]);\n          }\n        }\n      }\n    }\n  }\n  int ans = 0;\n  for (int b0 = 0; b0 <= n; b0++) {\n    for (int b1 = 0; b0 + b1 <= n; b1++) {\n      for (int c0 = 0; b0 + b1 + c0 <= n; c0++) {\n        int c1 = n - b0 - b1 - c0;\n        if ((b1 + c1 & 1) == jo) ans += dp[n][b0][b1][c0], upd(ans);\n      }\n    }\n  }\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace IO {\nconst int SIZE = 1 << 20;\nchar buf[SIZE + 10], *iS, *iT;\ninline char Getc() {\n  return iS == iT && (iT = (iS = buf) + fread(buf, 1, SIZE, stdin), iS == iT)\n             ? EOF\n             : *iS++;\n}\ntemplate <class TT>\ninline void Read(TT &x) {\n  x = 0;\n  register char cc = '\\0';\n  TT fff = 1;\n  for (; cc < '0' || cc > '9'; cc = Getc())\n    if (cc == '-') fff = -1;\n  for (; cc >= '0' && cc <= '9'; cc = Getc())\n    x = (x << 1) + (x << 3) + (cc & 15);\n  x *= fff;\n}\n}  // namespace IO\nusing IO::Read;\nconst int N = 2e5 + 10, Mod = 1e9 + 7;\nint n, fid, a[N], fpw[N + 10], f[N][2][2][2];\nint main() {\n  fpw[0] = 1;\n  for (int i = 1; i <= N; ++i) fpw[i] = (long long)fpw[i - 1] * 2LL % Mod;\n  Read(n), Read(fid);\n  for (int i = 1; i <= n; ++i) Read(a[i]);\n  if (a[1] != 1) f[1][1][1][0] = 1;\n  if (a[1] != 0) f[1][1][0][1] = 1;\n  for (int i = 2; i <= n; ++i)\n    for (int j = 0; j < 2; ++j)\n      for (int k = 0; k < 2; ++k)\n        for (int u = 0; u < 2; ++u) {\n          if (!f[i - 1][j][k][u]) continue;\n          if (a[i] != 1) {\n            if (u) {\n              f[i][j ^ 1][k | 1][u] =\n                  (f[i][j ^ 1][k | 1][u] +\n                   (long long)f[i - 1][j][k][u] * fpw[i - 2]) %\n                  Mod;\n              f[i][j][k][u] =\n                  (f[i][j][k][u] + (long long)f[i - 1][j][k][u] * fpw[i - 2]) %\n                  Mod;\n            } else\n              f[i][j ^ 1][k | 1][u] =\n                  (f[i][j ^ 1][k | 1][u] +\n                   (long long)f[i - 1][j][k][u] * fpw[i - 1]) %\n                  Mod;\n          }\n          if (a[i] != 0) {\n            if (k) {\n              f[i][j ^ 1][k][u | 1] =\n                  (f[i][j ^ 1][k][u | 1] +\n                   (long long)f[i - 1][j][k][u] * fpw[i - 2]) %\n                  Mod;\n              f[i][j][k][u] =\n                  (f[i][j][k][u] + (long long)f[i - 1][j][k][u] * fpw[i - 2]) %\n                  Mod;\n            } else\n              f[i][j ^ 1][k][u | 1] =\n                  (f[i][j ^ 1][k][u | 1] +\n                   (long long)f[i - 1][j][k][u] * fpw[i - 1]) %\n                  Mod;\n          }\n        }\n  int fans = 0;\n  for (int i = 0; i < 2; ++i)\n    for (int j = 0; j < 2; ++j) fans = (fans + f[n][fid][i][j]) % Mod;\n  printf(\"%d\\n\", fans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long maxn = 60;\nconst long long mod = 1e9 + 7;\nlong long ans;\nlong long n, p;\nlong long cl[maxn];\nlong long pow2[maxn];\nlong long getzoj[maxn];\nlong long C[maxn][maxn];\nlong long getfard[maxn];\nlong long dp[maxn][maxn][maxn][maxn];\nvoid in();\nvoid pp();\nvoid solve();\nlong long getdp(long long x, long long y, long long z, long long E);\nvoid out();\nint main() {\n  in();\n  solve();\n  out();\n}\nvoid in() {\n  ios_base::sync_with_stdio(false);\n  cout.tie(0);\n  cin.tie(0);\n  cin >> n >> p;\n  for (long long i = 0; i < n; i++) cin >> cl[i];\n}\nvoid solve() {\n  pp();\n  dp[0][0][0][0] = 1;\n  for (long long i = 1; i <= n; i++) {\n    for (long long ob = 0; ob <= i; ob++) {\n      for (long long eb = 0; eb + ob <= i; eb++) {\n        for (long long ow = 0; ow + eb + ob <= i; ow++) {\n          long long ew = i - ob - eb - ow;\n          if (cl[i - 1] == 0 || cl[i - 1] == -1)\n            dp[i][ob][eb][ow] +=\n                pow2[eb + ob + ew - 1] *\n                ((getdp(i - 1, ob, eb - 1, ow) * getfard[ow] % mod +\n                  getdp(i - 1, ob - 1, eb, ow) * getzoj[ow] % mod) %\n                 mod) %\n                mod;\n          if (cl[i - 1] == 1 || cl[i - 1] == -1)\n            dp[i][ob][eb][ow] +=\n                pow2[eb + ow + ew - 1] *\n                ((getdp(i - 1, ob, eb, ow) * getfard[ob] % mod +\n                  getdp(i - 1, ob, eb, ow - 1) * getzoj[ob] % mod) %\n                 mod) %\n                mod;\n          if (i == n && (ob + ow) % 2 == p)\n            ans = (ans + dp[i][ob][eb][ow]) % mod;\n        }\n      }\n    }\n  }\n}\nvoid out() { cout << ans; }\nvoid pp() {\n  pow2[0] = 1;\n  for (long long i = 1; i < maxn; i++) pow2[i] = 2 * pow2[i - 1] % mod;\n  for (long long i = 0; i < maxn; i++) C[i][0] = 1;\n  for (long long i = 1; i < maxn; i++)\n    for (long long j = 1; j < maxn; j++)\n      C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;\n  for (long long i = 0; i < maxn; i++)\n    for (long long j = 0; j < maxn / 2; j++)\n      getzoj[i] = (getzoj[i] + C[i][2 * j]) % mod;\n  for (long long i = 0; i < maxn; i++)\n    for (long long j = 0; j < maxn / 2; j++)\n      getfard[i] = (getfard[i] + C[i][2 * j + 1]) % mod;\n}\nlong long getdp(long long x, long long y, long long z, long long e) {\n  if (x < 0) return 0;\n  if (y < 0) return 0;\n  if (z < 0) return 0;\n  if (e < 0) return 0;\n  return dp[x][y][z][e];\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\ntemplate <class T>\nbool ckmin(T& a, const T& b) {\n  return a > b ? a = b, 1 : 0;\n}\ntemplate <class T>\nbool ckmax(T& a, const T& b) {\n  return a < b ? a = b, 1 : 0;\n}\nconst int N = 1 << 6, M = 1e9 + 7;\nint dp[2][2][2][2];\nint c[N], q[N];\ntemplate <class T>\nvoid add(T& a, const T& b) {\n  a += b;\n  if (M <= a) a -= M;\n}\nint mult(const int& a, ll b) { return a * b % M; }\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n;\n  short p;\n  cin >> n >> p;\n  for (int i = 1; i <= n; ++i) cin >> c[i];\n  q[0] = 1;\n  for (auto i = (1); i < (N); ++i) {\n    q[i] = (q[i - 1] << 1) % M;\n  }\n  int res = 0;\n  dp[0][0][0][0] = 1;\n  for (int i = 1, cur = 1; i <= n; ++i, cur ^= 1) {\n    for (auto w1 = (0); w1 < (2); ++w1) {\n      for (auto b1 = (0); b1 < (2); ++b1) {\n        for (auto parity = (0); parity < (2); ++parity) {\n          auto& x = dp[cur][w1][b1][parity];\n          x = 0;\n          if (c[i] != 1) {\n            add(x, mult(dp[!cur][w1][b1][parity], w1 ? q[i - 2] : 0));\n            if (b1)\n              add(x, mult(dp[!cur][w1][0][!parity] + dp[!cur][w1][1][!parity],\n                          w1 ? q[i - 2] : q[i - 1]));\n          }\n          if (c[i] != 0) {\n            add(x, mult(dp[!cur][w1][b1][parity], b1 ? q[i - 2] : 0));\n            if (w1)\n              add(x, mult(dp[!cur][0][b1][!parity] + dp[!cur][1][b1][!parity],\n                          b1 ? q[i - 2] : q[i - 1]));\n          }\n          if (i == n && p == parity) add(res, x);\n        }\n      }\n    }\n  }\n  cout << res;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint Q, N, M, K, L;\nstruct ModLL {\n  long long value;\n  ModLL() { this->value = 0; }\n  ModLL(long long value) { this->value = value; }\n  ModLL(int value) { this->value = value; }\n  ModLL& operator=(const ModLL& rhs) {\n    value = rhs.value;\n    return *this;\n  }\n  ModLL& operator=(int rhs) {\n    value = rhs;\n    return *this;\n  }\n  ModLL& operator=(long long rhs) {\n    value = rhs;\n    return *this;\n  }\n  ModLL operator+(const ModLL& rhs) {\n    return ModLL(ModLL{(value + rhs.value) % 1000000007});\n  }\n  ModLL operator-(const ModLL& rhs) {\n    return ModLL(\n        ModLL{((value - rhs.value) % 1000000007 + 1000000007) % 1000000007});\n  }\n  ModLL operator*(const ModLL& rhs) {\n    return ModLL(\n        ModLL{((value * rhs.value) % 1000000007 + 1000000007) % 1000000007});\n  }\n  ModLL operator+(long long rhs) {\n    return ModLL(ModLL{(value + rhs) % 1000000007});\n  }\n  ModLL operator-(long long rhs) {\n    return ModLL(ModLL{((value - rhs) % 1000000007 + 1000000007) % 1000000007});\n  }\n  ModLL operator*(long long rhs) {\n    return ModLL(ModLL{((value * rhs) % 1000000007 + 1000000007) % 1000000007});\n  }\n  ModLL& operator+=(const ModLL& rhs) {\n    *this = *this + rhs;\n    return *this;\n  }\n  ModLL& operator-=(const ModLL& rhs) {\n    *this = *this - rhs;\n    return *this;\n  }\n  ModLL& operator*=(const ModLL& rhs) {\n    *this = *this * rhs;\n    return *this;\n  }\n  ModLL& operator+=(long long rhs) {\n    *this = *this + rhs;\n    return *this;\n  }\n  ModLL& operator-=(long long rhs) {\n    *this = *this - rhs;\n    return *this;\n  }\n  ModLL& operator*=(long long rhs) {\n    *this = *this * rhs;\n    return *this;\n  }\n};\nstd::ostream& operator<<(std::ostream& stream, const ModLL& modLL) {\n  stream << modLL.value;\n  return stream;\n}\nModLL dp[51][51][51];\nModLL po[51];\nint A[51];\nModLL po2(int n) {\n  if (n < 0) return 1;\n  return po[n];\n}\nint main() {\n  cin >> N >> M;\n  for (int i = 1; i <= N; i++) {\n    cin >> A[i];\n  }\n  po[0] = 1;\n  for (int i = 1; i < 51; i++) po[i] = po[i - 1] * 2;\n  dp[0][0][0] = 1;\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j <= N; j++) {\n      for (int k = 0; k <= N; k++) {\n        int ow = j;\n        int ob = k;\n        int evens = i - ow - ob;\n        if (evens < 0) continue;\n        if (A[i + 1] != 0) {\n          dp[i + 1][ow + 1][ob] +=\n              dp[i][ow][ob] * po2(ob - 1) * po2(ow) * po2(evens);\n          if (ob)\n            dp[i + 1][ow][ob] +=\n                dp[i][ow][ob] * po2(ob - 1) * po2(ow) * po2(evens);\n        }\n        if (A[i + 1] != 1) {\n          dp[i + 1][ow][ob + 1] +=\n              dp[i][ow][ob] * po2(ow - 1) * po2(ob) * po2(evens);\n          if (ow)\n            dp[i + 1][ow][ob] +=\n                dp[i][ow][ob] * po2(ow - 1) * po2(ob) * po2(evens);\n        }\n      }\n    }\n  }\n  ModLL ret = 0;\n  for (int j = 0; j <= N; j++) {\n    for (int k = 0; k <= N; k++) {\n      int ow = j;\n      int ob = k;\n      int evens = N - ow - ob;\n      if (evens < 0) continue;\n      if ((ow + ob) % 2 != M) continue;\n      ret += dp[N][ow][ob];\n    }\n  }\n  cout << ret;\n  cin >> N;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  char c = getchar();\n  int x = 0, f = 1;\n  while ((c < '0' || c > '9') && c ^ '-') c = getchar();\n  if (c == '-') f = -1, c = getchar();\n  while (c >= '0' && c <= '9') {\n    x = (x << 3) + (x << 1) + (c ^ 48);\n    c = getchar();\n  }\n  return x * f;\n}\nconst int N = 1e5 + 10;\nconst int mo = 1e9 + 7;\nint p, n, a[N], f[N][2][2][2], ci2[N];\ninline int qumo(int x) { return x + ((x >> 31) & mo); }\nint main() {\n  ci2[0] = 1;\n  for (int i = 1; i <= N - 10; i++) ci2[i] = qumo((ci2[i - 1] << 1) - mo);\n  n = read();\n  p = read();\n  for (int i = 1; i <= n; i++) a[i] = read();\n  if (a[1] ^ 1) f[1][1][1][0] = 1;\n  if (a[1]) f[1][1][0][1] = 1;\n  for (int i = 2; i <= n; i++)\n    for (int jo = 0; jo <= 1; jo++)\n      for (int bai = 0; bai <= 1; bai++)\n        for (int hei = 0; hei <= 1; hei++) {\n          int tmp = f[i - 1][jo][bai][hei];\n          if (a[i]) {\n            if (bai) {\n              f[i][jo][bai][hei] =\n                  qumo(f[i][jo][bai][hei] + 1ll * tmp * ci2[i - 2] % mo - mo);\n              f[i][jo ^ 1][bai][hei | 1] =\n                  qumo(f[i][jo ^ 1][bai][hei | 1] +\n                       1ll * tmp * ci2[i - 2] % mo - mo);\n            } else\n              f[i][jo ^ 1][bai][hei | 1] =\n                  qumo(f[i][jo ^ 1][bai][hei | 1] +\n                       1ll * tmp * ci2[i - 1] % mo - mo);\n          }\n          if (a[i] ^ 1) {\n            if (hei) {\n              f[i][jo][bai][hei] =\n                  qumo(f[i][jo][bai][hei] + 1ll * tmp * ci2[i - 2] % mo - mo);\n              f[i][jo ^ 1][bai | 1][hei] =\n                  qumo(f[i][jo ^ 1][bai | 1][hei] +\n                       1ll * tmp * ci2[i - 2] % mo - mo);\n            } else\n              f[i][jo ^ 1][bai | 1][hei] =\n                  qumo(f[i][jo ^ 1][bai | 1][hei] +\n                       1ll * tmp * ci2[i - 1] % mo - mo);\n          }\n        }\n  int dan = 0;\n  for (int bai = 0; bai <= 1; bai++)\n    for (int hei = 0; hei <= 1; hei++) dan = qumo(dan + f[n][p][bai][hei] - mo);\n  cout << dan << \"\\n\";\n  fclose(stdin);\n  fclose(stdout);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mo = 1000000007;\nlong long n, p, a[123456], ans;\nlong long f[123456][3][3][3], mul[123456];\nint main() {\n  scanf(\"%lld%lld\", &n, &p);\n  for (long long i = 1; i <= n; i++) scanf(\"%lld\", &a[i]);\n  mul[0] = 1;\n  for (long long i = 1; i <= n; i++) {\n    mul[i] = (mul[i - 1] * 2) % mo;\n  }\n  f[0][0][0][0] = 1;\n  for (long long i = 1; i <= n; i++)\n    for (long long num = 0; num <= 1; num++)\n      for (long long bla = 0; bla <= 1; bla++)\n        for (long long whi = 0; whi <= 1; whi++) {\n          long long x = f[i - 1][num][bla][whi];\n          if (a[i] == 1 || a[i] == -1) {\n            if (bla == 1) {\n              f[i][num][bla][whi] =\n                  (f[i][num][bla][whi] + (mul[i - 2] * x) % mo) % mo;\n              f[i][1 - num][bla][1] =\n                  (f[i][1 - num][bla][1] + (mul[i - 2] * x) % mo) % mo;\n            } else\n              f[i][1 - num][bla][1] =\n                  (f[i][1 - num][bla][1] + (mul[i - 1] * x) % mo) % mo;\n          }\n          if (a[i] == 0 || a[i] == -1) {\n            if (whi == 1) {\n              f[i][num][bla][whi] =\n                  (f[i][num][bla][whi] + (mul[i - 2] * x) % mo) % mo;\n              f[i][1 - num][1][whi] =\n                  (f[i][1 - num][1][whi] + (mul[i - 2] * x) % mo) % mo;\n            } else\n              f[i][1 - num][1][whi] =\n                  (f[i][1 - num][1][whi] + (mul[i - 1] * x) % mo) % mo;\n          }\n        }\n  for (long long bla = 0; bla <= 1; bla++)\n    for (long long whi = 0; whi <= 1; whi++)\n      ans = (ans + f[n][p][bla][whi]) % mo;\n  printf(\"%lld\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 55, MOD = 1E9 + 7;\nint n, p, c[N];\nlong long ans = 0, pw[N], fct[N], inv[N], od[N], ev[N], f[N][N][N][N];\nlong long power(int u, int p) {\n  if (p == 0) return 1;\n  long long ret = power(u, p >> 1);\n  (ret *= ret) %= MOD;\n  if (p & 1) (ret *= u) %= MOD;\n  return ret;\n}\nlong long C(int n, int k) { return fct[n] * inv[k] % MOD * inv[n - k] % MOD; }\nvoid init() {\n  f[0][0][0][0] = 1;\n  pw[0] = 1;\n  fct[0] = 1;\n  for (int i = 1; i < N; i++) {\n    pw[i] = pw[i - 1] * 2 % MOD;\n    fct[i] = fct[i - 1] * i % MOD;\n  }\n  inv[N - 1] = power(fct[N - 1], MOD - 2);\n  for (int i = N - 2; i >= 0; i--) inv[i] = inv[i + 1] * (i + 1) % MOD;\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j <= i; j += 2) (ev[i] += C(i, j)) %= MOD;\n    for (int j = 1; j <= i; j += 2) (od[i] += C(i, j)) %= MOD;\n  }\n}\nvoid find_ans(int ob, int eb, int ow, int ew, int col, long long &ret) {\n  if (col != 0 && ew != 0)\n    (ret +=\n     f[ob][eb][ow][ew - 1] * pw[ow + ew - 1 + eb] % MOD * od[ob] % MOD) %= MOD;\n  if (col != 0 && ow != 0)\n    (ret += f[ob][eb][ow - 1][ew] * pw[ow - 1 + ew + eb] % MOD *\n            (ob ? pw[ob - 1] : 1) % MOD) %= MOD;\n  if (col != 1 && eb != 0)\n    (ret +=\n     f[ob][eb - 1][ow][ew] * pw[ob + eb - 1 + ew] % MOD * od[ow] % MOD) %= MOD;\n  if (col != 1 && ob != 0)\n    (ret += f[ob - 1][eb][ow][ew] * pw[ob - 1 + eb + ew] % MOD *\n            (ow ? pw[ow - 1] : 1) % MOD) %= MOD;\n}\nint main() {\n  init();\n  scanf(\"%d%d\", &n, &p);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", c + i);\n  for (int i = 1; i <= n; i++)\n    for (int ob = 0; ob <= i; ob++)\n      for (int eb = 0; ob + eb <= i; eb++)\n        for (int ow = 0; ob + eb + ow <= i; ow++) {\n          int ew = i - ob - eb - ow;\n          find_ans(ob, eb, ow, ew, c[i], f[ob][eb][ow][ew]);\n          if (i == n && ((ob + ow) & 1) == p) (ans += f[ob][eb][ow][ew]) %= MOD;\n        }\n  printf(\"%lld\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint read() {\n  register int x = 0;\n  register char f = 1, ch = getchar();\n  for (; !isdigit(ch); ch = getchar())\n    if (ch == '-') f = 0;\n  for (; isdigit(ch); ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ '0');\n  return f ? x : -x;\n}\nint n, p, pw, f[2][2][2][2];\nvoid Add(int &x, long long y) {\n  (x += y % 1000000007) >= 1000000007 ? x -= 1000000007 : 0;\n}\nint main() {\n  n = read(), p = read();\n  pw = 500000004;\n  f[0][0][0][0] = 1;\n  for (register int i = 0; i < n; ++i) {\n    int x = read(), k = i & 1, t = k ^ 1;\n    memset(f[t], 0, sizeof(f[t]));\n    for (register int w = 0; w <= 1; ++w)\n      for (register int b = 0; b <= 1; ++b)\n        for (register int wb = 0; wb <= 1; ++wb)\n          if (f[k][w][b][wb]) {\n            if (x != 1) {\n              if (!b)\n                Add(f[t][1][b][wb ^ 1], 1ll * f[k][w][b][wb] * pw << 1);\n              else\n                Add(f[t][1][b][wb ^ 1], 1ll * f[k][w][b][wb] * pw),\n                    Add(f[t][w][b][wb], 1ll * f[k][w][b][wb] * pw);\n            }\n            if (x != 0) {\n              if (!w)\n                Add(f[t][w][1][wb ^ 1], 1ll * f[k][w][b][wb] * pw << 1);\n              else\n                Add(f[t][w][1][wb ^ 1], 1ll * f[k][w][b][wb] * pw),\n                    Add(f[t][w][b][wb], 1ll * f[k][w][b][wb] * pw);\n            }\n          }\n    (pw <<= 1) %= 1000000007;\n  }\n  int ans = 0;\n  for (register int i = 0; i <= 1; ++i)\n    for (register int j = 0; j <= 1; ++j) Add(ans, f[n & 1][i][j][p]);\n  printf(\"%d\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long dp[60][60][60][2];\nint C[60][60];\nint mod = 1e9 + 7;\nvoid build() {\n  for (int i = 0; i < 60; i++) {\n    C[i][0] = C[i][i] = 1;\n  }\n  for (int i = 1; i < 60; i++) {\n    for (int j = 1; j < i; j++) {\n      C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;\n    }\n  }\n}\nint main() {\n  build();\n  int n, p;\n  scanf(\"%d %d\", &n, &p);\n  int c[55];\n  for (int i = 0; i < n; i++) scanf(\"%d\", &c[i]);\n  dp[0][0][0][0] = 1;\n  for (int i = 0; i < n; i++) {\n    if (c[i] == 0 || c[i] == -1) {\n      for (int j = 0; j < n; j++) {\n        for (int k = 0; k < n; k++) {\n          for (int l = 0; l <= k; l++) {\n            if (l % 2 == 0) {\n              dp[i + 1][j + 1][k][1] +=\n                  dp[i][j][k][0] * C[k][l] % mod * ((1ll << (i - k)) % mod);\n              dp[i + 1][j + 1][k][0] +=\n                  dp[i][j][k][1] * C[k][l] % mod * ((1ll << (i - k)) % mod);\n              dp[i + 1][j + 1][k][1] %= mod;\n              dp[i + 1][j + 1][k][0] %= mod;\n            } else {\n              dp[i + 1][j][k][0] +=\n                  dp[i][j][k][0] * C[k][l] % mod * ((1ll << (i - k)) % mod);\n              dp[i + 1][j][k][1] +=\n                  dp[i][j][k][1] * C[k][l] % mod * ((1ll << (i - k)) % mod);\n              dp[i + 1][j][k][1] %= mod;\n              dp[i + 1][j][k][0] %= mod;\n            }\n          }\n        }\n      }\n    }\n    if (c[i] == 1 || c[i] == -1) {\n      for (int j = 0; j < n; j++) {\n        for (int k = 0; k < n; k++) {\n          for (int l = 0; l <= j; l++) {\n            if (l % 2 == 0) {\n              dp[i + 1][j][k + 1][1] +=\n                  dp[i][j][k][0] * C[j][l] % mod * ((1ll << (i - j)) % mod);\n              dp[i + 1][j][k + 1][0] +=\n                  dp[i][j][k][1] * C[j][l] % mod * ((1ll << (i - j)) % mod);\n              dp[i + 1][j][k + 1][1] %= mod;\n              dp[i + 1][j][k + 1][0] %= mod;\n            } else {\n              dp[i + 1][j][k][0] +=\n                  dp[i][j][k][0] * C[j][l] % mod * ((1ll << (i - j)) % mod);\n              dp[i + 1][j][k][1] +=\n                  dp[i][j][k][1] * C[j][l] % mod * ((1ll << (i - j)) % mod);\n              dp[i + 1][j][k][1] %= mod;\n              dp[i + 1][j][k][0] %= mod;\n            }\n          }\n        }\n      }\n    }\n  }\n  long long ans = 0;\n  for (int j = 0; j <= n; j++) {\n    for (int k = 0; k <= n; k++) {\n      ans += dp[n][j][k][p];\n    }\n  }\n  printf(\"%lld\\n\", ans % mod);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nconst int maxn = 55;\nlong long f[maxn][maxn][maxn][maxn];\nlong long pw[maxn];\nint c[maxn];\nvoid init() {\n  f[0][0][0][0] = 1;\n  pw[0] = 1;\n  for (int i = 1; i < maxn; i++) pw[i] = (pw[i - 1] * 2ll) % mod;\n}\nlong long cal(int x, bool xx) { return x ? pw[x - 1] : xx; }\nvoid cal_ans(int ew, int ow, int eb, int ob, int now, long long& ret) {\n  if (now != 0 && ew)\n    (ret += f[ew - 1][ow][eb][ob] * pw[ew + ow - 1 + eb] % mod * cal(ob, 0) %\n            mod) %= mod;\n  if (now != 0 && ow)\n    (ret += f[ew][ow - 1][eb][ob] * pw[ew + ow - 1 + eb] % mod * cal(ob, 1) %\n            mod) %= mod;\n  if (now != 1 && eb)\n    (ret += f[ew][ow][eb - 1][ob] * pw[eb + ob - 1 + ew] % mod * cal(ow, 0) %\n            mod) %= mod;\n  if (now != 1 && ob)\n    (ret += f[ew][ow][eb][ob - 1] * pw[eb + ob - 1 + ew] % mod * cal(ow, 1) %\n            mod) %= mod;\n}\nint main(int argc, const char** argv) {\n  init();\n  int n, p;\n  cin >> n >> p;\n  for (int i = 1; i <= n; i++) scanf(\"%d\", c + i);\n  long long ans = 0;\n  for (int i = 1; i <= n; i++)\n    for (int ew = 0; ew <= i; ew++)\n      for (int ow = 0; ow + ew <= i; ow++)\n        for (int eb = 0; ow + ew + eb <= i; eb++) {\n          int ob = i - ow - ew - eb;\n          cal_ans(ew, ow, eb, ob, c[i], f[ew][ow][eb][ob]);\n          if (i == n && ((ow + ob) & 1) == p) (ans += f[ew][ow][eb][ob]) %= mod;\n        }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Size = 5007;\nconst long long Mod = 1e9 + 7;\nlong long F[55][55][55];\nvoid modify_0(int rt) {\n  for (int j = 0; j < rt; ++j) {\n    long long k = F[0][j][rt - 1];\n    if (k == 0) continue;\n    F[0][j + 1][rt] += k * ((1LL << (rt - 1)) % Mod) % Mod;\n    F[0][j + 1][rt] %= Mod;\n  }\n  for (int i = 1; i < rt; ++i)\n    for (int j = 0; j + i < rt; ++j) {\n      long long k = F[i][j][rt - 1];\n      if (k == 0) continue;\n      F[i][j + 1][rt] += k * ((1LL << (rt - 2)) % Mod) % Mod;\n      F[i][j][rt] += k * ((1LL << (rt - 2)) % Mod) % Mod;\n      F[i][j + 1][rt] %= Mod;\n      F[i][j][rt] %= Mod;\n    }\n}\nvoid modify_1(int rt) {\n  for (int i = 0; i < rt; ++i) {\n    long long k = F[i][0][rt - 1];\n    if (k == 0) continue;\n    F[i + 1][0][rt] += k * ((1LL << (rt - 1)) % Mod) % Mod;\n    F[i + 1][0][rt] %= Mod;\n  }\n  for (int i = 0; i < rt; ++i)\n    for (int j = 1; j + i < rt; ++j) {\n      long long k = F[i][j][rt - 1];\n      if (k == 0) continue;\n      F[i + 1][j][rt] += k * ((1LL << (rt - 2)) % Mod) % Mod;\n      F[i][j][rt] += k * ((1LL << (rt - 2)) % Mod) % Mod;\n      F[i + 1][j][rt] %= Mod;\n      F[i][j][rt] %= Mod;\n    }\n}\nint a[100];\nint main() {\n  int n, p;\n  scanf(\"%d%d\", &n, &p);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n  if (a[1] == 0 || a[1] == -1) F[0][1][1] = 1;\n  if (a[1] == 1 || a[1] == -1) F[1][0][1] = 1;\n  for (int i = 2; i <= n; ++i) {\n    if (a[i] == 0)\n      modify_0(i);\n    else if (a[i] == 1)\n      modify_1(i);\n    else {\n      modify_0(i);\n      modify_1(i);\n    }\n  }\n  long long ans = 0;\n  for (int i = 0; i <= n; ++i)\n    for (int j = 0; j + i <= n; ++j) {\n      if ((i + j) % 2 == p) ans = (ans + F[i][j][n]) % Mod;\n    }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int _ML = 228;\nconst char _inpf[] = \"\";\nconst char _outf[] = \"\";\n#pragma GCC optimize(\"O3,no-stack-protector\")\nusing namespace std;\nconst double PI = 3.14159265358979323846;\nmt19937 rd(228);\ntemplate <class T, class U>\ninline ostream &operator<<(ostream &, const pair<T, U> &);\ntemplate <class T, class U>\ninline istream &operator>>(istream &, pair<T, U> &);\ntemplate <class T>\ninline ostream &operator<<(ostream &, const vector<T> &);\ntemplate <class T>\ninline istream &operator>>(istream &, vector<T> &);\ntemplate <class T>\ninline ostream &operator<<(ostream &, const set<T> &);\ntemplate <class T>\ninline ostream &operator<<(ostream &, const multiset<T> &);\ntemplate <class T>\ninline ostream &operator<<(ostream &, const unordered_set<T> &);\ntemplate <class T>\ninline ostream &operator<<(ostream &, const unordered_multiset<T> &);\ntemplate <class T, class U>\ninline ostream &operator<<(ostream &, const map<T, U> &);\ntemplate <class T, class U>\ninline ostream &operator<<(ostream &, const unordered_map<T, U> &);\nconst int N = 52;\nconst int M = 1000 * 1000 * 1000 + 7;\nint dp[2][N][N][N];\nint a[N];\nint pww[N];\ninline int pw2(int first) {\n  if (first == -1) {\n    return 1;\n  }\n  return pww[first];\n}\ninline int mul(int a, int b) { return (int)((long long)a * b % M); }\ninline void addeq(int &a, int b) { a = (a + b) % M; }\ninline void _main_function() {\n  pww[0] = 1;\n  for (int i = 1; i < N; ++i) {\n    pww[i] = mul(pww[i - 1], 2);\n  }\n  int n, p;\n  cin >> n >> p;\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n  }\n  dp[1][0][0][0] = 1;\n  for (int i = 0; i < n; ++i) {\n    int cur = (i & 1);\n    int lst = (~i & 1);\n    memset(dp[cur], 0, sizeof dp[cur]);\n    for (int e = 0; e <= i; ++e) {\n      for (int bo = 0; bo <= i; ++bo) {\n        for (int wo = 0; wo <= i; ++wo) {\n          if (dp[lst][e][bo][wo] == 0) {\n            continue;\n          }\n          if (a[i] != 1) {\n            int value = mul(pw2(e + bo), pw2(wo - 1));\n            addeq(dp[cur][e][bo + 1][wo], mul(dp[lst][e][bo][wo], value));\n            if (wo != 0) {\n              addeq(dp[cur][e + 1][bo][wo], mul(dp[lst][e][bo][wo], value));\n            }\n          }\n          if (a[i] != 0) {\n            int value = mul(pw2(e + wo), pw2(bo - 1));\n            if (bo != 0) {\n              addeq(dp[cur][e + 1][bo][wo], mul(dp[lst][e][bo][wo], value));\n            }\n            addeq(dp[cur][e][bo][wo + 1], mul(dp[lst][e][bo][wo], value));\n          }\n        }\n      }\n    }\n  }\n  int cur = ((n - 1) & 1);\n  int ans = 0;\n  for (int e = 0; e <= n; ++e) {\n    for (int bo = 0; bo <= n; ++bo) {\n      for (int wo = 0; wo <= n; ++wo) {\n        if (((bo + wo) & 1) == p) {\n          addeq(ans, dp[cur][e][bo][wo]);\n        }\n      }\n    }\n  }\n  cout << ans << '\\n';\n}\nint main() {\n  if (_inpf[0] != '\\0') assert(freopen(_inpf, \"r\", stdin) != nullptr);\n  if (_outf[0] != '\\0') assert(freopen(_outf, \"w\", stdout) != nullptr);\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  cout << setprecision(20);\n  _main_function();\n}\ntemplate <class T, class U>\ninline ostream &operator<<(ostream &_out, const pair<T, U> &_p) {\n  _out << _p.first << ' ' << _p.second;\n  return _out;\n}\ntemplate <class T, class U>\ninline istream &operator>>(istream &_in, pair<T, U> &_p) {\n  _in >> _p.first >> _p.second;\n  return _in;\n}\ntemplate <class T>\ninline ostream &operator<<(ostream &_out, const vector<T> &_v) {\n  if (_v.empty()) {\n    return _out;\n  }\n  _out << *_v.begin();\n  for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) {\n    _out << ' ' << *_it;\n  }\n  return _out;\n}\ntemplate <class T>\ninline istream &operator>>(istream &_in, vector<T> &_v) {\n  for (auto &_i : _v) {\n    _in >> _i;\n  }\n  return _in;\n}\ntemplate <class T>\ninline ostream &operator<<(ostream &_out, const set<T> &_s) {\n  if (_s.empty()) {\n    return _out;\n  }\n  _out << *_s.begin();\n  for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) {\n    _out << ' ' << *_it;\n  }\n  return _out;\n}\ntemplate <class T>\ninline ostream &operator<<(ostream &_out, const multiset<T> &_s) {\n  if (_s.empty()) {\n    return _out;\n  }\n  _out << *_s.begin();\n  for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) {\n    _out << ' ' << *_it;\n  }\n  return _out;\n}\ntemplate <class T>\ninline ostream &operator<<(ostream &_out, const unordered_set<T> &_s) {\n  if (_s.empty()) {\n    return _out;\n  }\n  _out << *_s.begin();\n  for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) {\n    _out << ' ' << *_it;\n  }\n  return _out;\n}\ntemplate <class T>\ninline ostream &operator<<(ostream &_out, const unordered_multiset<T> &_s) {\n  if (_s.empty()) {\n    return _out;\n  }\n  _out << *_s.begin();\n  for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) {\n    _out << ' ' << *_it;\n  }\n  return _out;\n}\ntemplate <class T, class U>\ninline ostream &operator<<(ostream &_out, const map<T, U> &_m) {\n  if (_m.empty()) {\n    return _out;\n  }\n  _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')';\n  for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) {\n    _out << \", (\" << _it->first << \": \" << _it->second << ')';\n  }\n  return _out;\n}\ntemplate <class T, class U>\ninline ostream &operator<<(ostream &_out, const unordered_map<T, U> &_m) {\n  if (_m.empty()) {\n    return _out;\n  }\n  _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')';\n  for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) {\n    _out << \", (\" << _it->first << \": \" << _it->second << ')';\n  }\n  return _out;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INFL = (int)1e9;\nconst long long int INFLL = (long long int)1e18;\nconst double INFD = numeric_limits<double>::infinity();\nconst double PI = 3.14159265358979323846;\nnamespace mod_op {\nconst long long int MOD = (long long int)1e9 + 7;\nclass modll {\n private:\n  long long int val;\n  inline long long int modify(long long int x) {\n    long long int ret = x % MOD;\n    if (ret < 0) ret += MOD;\n    return ret;\n  }\n  inline long long int inv(long long int x) {\n    if (x == 0)\n      return 1 / x;\n    else if (x == 1)\n      return 1;\n    else\n      return modify(inv(MOD % x) * modify(-MOD / x));\n  }\n\n public:\n  modll(long long int init = 0) {\n    val = modify(init);\n    return;\n  }\n  modll(const modll &another) {\n    val = another.val;\n    return;\n  }\n  inline modll &operator=(const modll &another) {\n    val = another.val;\n    return *this;\n  }\n  inline modll operator+(const modll &x) { return (val + x.val) % MOD; }\n  inline modll operator-(const modll &x) { return (val - x.val) % MOD; }\n  inline modll operator*(const modll &x) { return (val * x.val) % MOD; }\n  inline modll operator/(const modll &x) { return (val * inv(x.val)) % MOD; }\n  inline modll &operator+=(const modll &x) {\n    val = (val + x.val) % MOD;\n    return *this;\n  }\n  inline modll &operator-=(const modll &x) {\n    val = (val - x.val) % MOD;\n    return *this;\n  }\n  inline modll &operator*=(const modll &x) {\n    val = (val * x.val) % MOD;\n    return *this;\n  }\n  inline modll &operator/=(const modll &x) {\n    val = (val * inv(x.val)) % MOD;\n    return *this;\n  }\n  inline bool operator==(const modll &x) { return val == x.val; }\n  inline bool operator!=(const modll &x) { return val != x.val; }\n  friend inline istream &operator>>(istream &is, modll &x) {\n    is >> x.val;\n    return is;\n  }\n  friend inline ostream &operator<<(ostream &os, modll &x) {\n    os << x.val;\n    return os;\n  }\n  long long int get_val() { return val; }\n};\nmodll pow(modll n, long long int p) {\n  modll ret;\n  if (p == 0)\n    ret = 1;\n  else if (p == 1)\n    ret = n;\n  else {\n    ret = pow(n, p / 2);\n    ret *= ret;\n    if (p % 2 == 1) ret *= n;\n  }\n  return ret;\n}\nvector<modll> facts;\ninline void make_facts(int n) {\n  if (facts.empty()) facts.push_back(modll(1));\n  for (int i = facts.size(); i <= n; ++i)\n    facts.push_back(modll(facts.back() * (long long int)i));\n  return;\n}\nvector<modll> ifacts;\nvector<modll> invs;\ninline void make_invs(int n) {\n  if (invs.empty()) {\n    invs.push_back(modll(0));\n    invs.push_back(modll(1));\n  }\n  for (int i = invs.size(); i <= n; ++i) {\n    invs.push_back(invs[(int)MOD % i] * ((int)MOD - (int)MOD / i));\n  }\n  return;\n}\ninline void make_ifacts(int n) {\n  make_invs(n);\n  if (ifacts.empty()) ifacts.push_back(modll(1));\n  for (int i = ifacts.size(); i <= n; ++i)\n    ifacts.push_back(modll(ifacts.back() * invs[i]));\n  return;\n}\nmodll combination(long long int n, long long int r) {\n  if (n >= r && r >= 0) {\n    modll ret;\n    make_facts((int)n);\n    make_ifacts((int)n);\n    ret = facts[(unsigned)n] * ifacts[(unsigned)r] * ifacts[(unsigned)(n - r)];\n    return ret;\n  } else\n    return 0;\n}\nmodll get_fact(long long int n) {\n  make_facts((int)n);\n  return facts[(int)n];\n}\nlong long int disc_log(modll a, modll b) {\n  long long int ret = -1;\n  long long int m = ((long long int)sqrt((double)MOD) +\n                     ((long long int)MOD <= (long long int)sqrt((double)MOD) *\n                                                (long long int)sqrt((double)MOD)\n                          ? 0\n                          : 1));\n  unordered_map<long long int, long long int> mp;\n  modll x = 1;\n  for (int i = 0; i < (int)m; i++) {\n    mp[x.get_val()] = i;\n    x *= a;\n  }\n  x = modll(1) / pow(a, m);\n  modll k = b;\n  for (int i = 0; i < (int)m; i++) {\n    if (mp.find(k.get_val()) == mp.end())\n      k *= x;\n    else {\n      ret = i * m + mp[k.get_val()];\n      break;\n    }\n  }\n  return ret;\n}\n}  // namespace mod_op\nusing namespace mod_op;\nconst int N = 51;\nconst int NN = N * N;\nconst int NNN = NN * N;\nint index(int i, int ew, int ow, int eb) {\n  return i * NNN + ew * NN + ow * N + eb;\n}\nint main() {\n  int n;\n  cin >> n;\n  int p;\n  cin >> p;\n  vector<int> colors(n);\n  for (int i = 0; i < (int)n; i++) cin >> colors[i];\n  vector<modll> dp(NNN * N);\n  for (int i = 0; i < (int)N; i++) {\n    for (int ew = 0; ew < (int)N; ew++) {\n      for (int ow = 0; ow < (int)N; ow++) {\n        for (int eb = 0; eb < (int)N; eb++) {\n          dp[index(i, ew, ow, eb)] = 0;\n        }\n      }\n    }\n  }\n  modll divided_combination_sum[N][2];\n  for (int i = 0; i < (int)N; i++) {\n    divided_combination_sum[i][0] = 0;\n    divided_combination_sum[i][1] = 0;\n    for (int j = 0; j < (int)i + 1; j++) {\n      divided_combination_sum[i][j % 2] += combination(i, j);\n    }\n  }\n  if (colors[0] == -1 || colors[0] == 0) {\n    dp[index(1, 0, 1, 0)] = 1;\n  }\n  if (colors[0] == -1 || colors[0] == 1) {\n    dp[index(1, 0, 0, 0)] = 1;\n  }\n  for (int i = 1; i <= (int)n - 1; i++) {\n    for (int ew = 0; ew < (int)N; ew++) {\n      if (i - ew < 0) break;\n      for (int ow = 0; ow < (int)N; ow++) {\n        if (i - ew - ow < 0) break;\n        for (int eb = 0; eb < (int)N; eb++) {\n          int ob = i - ew - ow - eb;\n          if (ob < 0) break;\n          if (colors[i] == -1 || colors[i] == 0) {\n            dp[index(i + 1, ew, ow + 1, eb)] += dp[index(i, ew, ow, eb)] *\n                                                pow((modll)2, ew + ow + eb) *\n                                                divided_combination_sum[ob][0];\n            dp[index(i + 1, ew + 1, ow, eb)] += dp[index(i, ew, ow, eb)] *\n                                                pow((modll)2, ew + ow + eb) *\n                                                divided_combination_sum[ob][1];\n          }\n          if (colors[i] == -1 || colors[i] == 1) {\n            dp[index(i + 1, ew, ow, eb)] += dp[index(i, ew, ow, eb)] *\n                                            pow((modll)2, eb + ob + ew) *\n                                            divided_combination_sum[ow][0];\n            dp[index(i + 1, ew, ow, eb + 1)] += dp[index(i, ew, ow, eb)] *\n                                                pow((modll)2, eb + ob + ew) *\n                                                divided_combination_sum[ow][1];\n          }\n        }\n      }\n    }\n  }\n  modll ans = 0;\n  for (int ew = 0; ew < (int)N; ew++) {\n    if (n - ew < 0) break;\n    for (int ow = 0; ow < (int)N; ow++) {\n      if (n - ew - ow < 0) break;\n      for (int eb = 0; eb < (int)N; eb++) {\n        int ob = n - ew - ow - eb;\n        int type = (ow + ob) % 2;\n        if (p == type) ans += dp[index(n, ew, ow, eb)];\n      }\n    }\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 50, mod = 1e9 + 7;\nint dp[maxn + 5][maxn + 5][maxn + 5][maxn + 5];\nint c[maxn + 5];\nint n, p;\nint pw[maxn + 5];\nvoid inc(int& a, int b) { a = (a + b) % mod; }\nint main() {\n  scanf(\"%d%d\", &n, &p);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", &c[i]);\n  pw[0] = 1;\n  for (int i = 1; i <= maxn; ++i) pw[i] = pw[i - 1] * 2LL % mod;\n  if (c[1] == 0 || c[1] == -1) dp[1][0][0][0] = 1;\n  if (c[1] == 1 || c[1] == -1) dp[1][0][1][0] = 1;\n  for (int i = 2; i <= n; ++i)\n    for (int ew = 0; ew <= i; ++ew)\n      for (int ow = 0; ow <= i; ++ow)\n        for (int eb = 0; eb <= i; ++eb) {\n          if (ow + ew + eb > i) continue;\n          int ob = i - ew - ow - eb;\n          if (c[i] == 1 || c[i] == -1) {\n            if (ow + ew != 0) {\n              long long s = 0;\n              if (ow >= 1)\n                if (ob == 0)\n                  s = dp[i - 1][ew][ow - 1][eb];\n                else\n                  s = 1LL * pw[ob - 1] * dp[i - 1][ew][ow - 1][eb] % mod;\n              if (ew >= 1)\n                if (ob >= 1)\n                  s += 1LL * pw[ob - 1] * dp[i - 1][ew - 1][ow][eb] % mod;\n              s %= mod;\n              s = s * pw[eb + ew + ow - 1] % mod;\n              inc(dp[i][ew][ow][eb], (int)s);\n            }\n          }\n          if (c[i] == 0 || c[i] == -1) {\n            if (ob + eb != 0) {\n              long long s = 0;\n              if (ob >= 1)\n                if (ow == 0)\n                  s = dp[i - 1][ew][ow][eb];\n                else\n                  s = 1LL * pw[ow - 1] * dp[i - 1][ew][ow][eb] % mod;\n              if (eb >= 1)\n                if (ow >= 1)\n                  s += 1LL * pw[ow - 1] * dp[i - 1][ew][ow][eb - 1] % mod;\n              s %= mod;\n              s = s * pw[eb + ob + ew - 1] % mod;\n              inc(dp[i][ew][ow][eb], (int)s);\n            }\n          }\n        }\n  int ans = 0;\n  for (int ew = 0; ew <= n; ++ew)\n    for (int ow = 0; ow <= n; ++ow)\n      for (int eb = 0; eb <= n; ++eb)\n        if (ew + ow + eb <= n)\n          if ((ow + n - ew - ow - eb) % 2 == p) inc(ans, dp[n][ew][ow][eb]);\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 52;\nconst int MOD = 1000000007;\nint n, p, c[maxn];\nint64_t f[maxn][maxn][maxn][maxn], pw2[maxn];\nint64_t Choose(int x, int parity) {\n  if (x == 0) return parity == 0;\n  return pw2[x - 1];\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> p;\n  pw2[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    cin >> c[i];\n    pw2[i] = pw2[i - 1] * 2 % MOD;\n  }\n  int64_t ans = 0;\n  f[n + 1][0][0][0] = 1;\n  for (int i = n; i >= 1; --i) {\n    for (int x1 = 0; x1 <= n; ++x1) {\n      for (int x2 = 0; x2 <= n; ++x2) {\n        for (int x3 = 0; x1 + x2 + x3 <= n - i + 1; ++x3) {\n          int x4 = n - i + 1 - x1 - x2 - x3;\n          if (i == 3 && x1 + x2 + x3 == 0)\n            cerr << \"pw2[x2 - 1]\"\n                 << \" = \" << pw2[x2 - 1] << '\\n';\n          ;\n          int64_t res = 0;\n          if (c[i] != 1) {\n            if (x1 > 0)\n              res += f[i + 1][x1 - 1][x2][x3] * Choose(x4, 1) % MOD * pw2[x3] %\n                     MOD * pw2[x2] % MOD * pw2[x1 - 1] % MOD;\n            if (x2 > 0)\n              res += f[i + 1][x1][x2 - 1][x3] * Choose(x4, 0) % MOD * pw2[x3] %\n                     MOD * pw2[x1] % MOD * pw2[x2 - 1] % MOD;\n          }\n          if (c[i] != 0) {\n            if (x3 > 0)\n              res += f[i + 1][x1][x2][x3 - 1] * Choose(x2, 1) % MOD * pw2[x1] %\n                     MOD * pw2[x4] % MOD * pw2[x3 - 1] % MOD;\n            if (x4 > 0)\n              res += f[i + 1][x1][x2][x3] * Choose(x2, 0) % MOD * pw2[x1] %\n                     MOD * pw2[x3] % MOD * pw2[x4 - 1] % MOD;\n          }\n          f[i][x1][x2][x3] = res % MOD;\n          if (i == 1 && (x2 + x4) % 2 == p) ans = (ans + res) % MOD;\n        }\n      }\n    }\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 60;\nconst int P = 1e9 + 7;\nint n, p;\nint f[N][2][2][2];\nint col[N];\ninline void add(int &x, int y) {\n  x += y;\n  if (x >= P) x -= P;\n}\ninline int pow_mod(int x, int k) {\n  int res = 1, base = x;\n  while (k) {\n    if (k & 1) res = 1LL * res * base % P;\n    k >>= 1;\n    base = 1LL * base * base % P;\n  }\n  return res;\n}\nint main() {\n  scanf(\"%d%d\", &n, &p);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", col + i);\n  memset(f, 0, sizeof f);\n  f[0][0][0][0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    for (int w = 0; w <= 1; ++w)\n      for (int b = 0; b <= 1; ++b)\n        for (int k = 0; k <= 1; ++k) {\n          if (!f[i - 1][w][b][k]) continue;\n          if (col[i] == 0 || col[i] == -1) {\n            if (b) {\n              add(f[i][w][b][k],\n                  1LL * f[i - 1][w][b][k] * pow_mod(2, i - 2) % P);\n              add(f[i][1][b][k ^ 1],\n                  1LL * f[i - 1][w][b][k] * pow_mod(2, i - 2) % P);\n            } else {\n              add(f[i][1][b][k ^ 1],\n                  1LL * f[i - 1][w][b][k] * pow_mod(2, i - 1) % P);\n            }\n          }\n          if (col[i] == 1 || col[i] == -1) {\n            if (w) {\n              add(f[i][w][b][k],\n                  1LL * f[i - 1][w][b][k] * pow_mod(2, i - 2) % P);\n              add(f[i][w][1][k ^ 1],\n                  1LL * f[i - 1][w][b][k] * pow_mod(2, i - 2) % P);\n            } else {\n              add(f[i][w][1][k ^ 1],\n                  1LL * f[i - 1][w][b][k] * pow_mod(2, i - 1) % P);\n            }\n          }\n        }\n  }\n  int res = 0;\n  add(res, f[n][0][0][p]);\n  add(res, f[n][1][1][p]);\n  add(res, f[n][0][1][p]);\n  add(res, f[n][1][0][p]);\n  printf(\"%d\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nusing namespace std;\nconst long long mod7 = 1000000007LL;\ninline long long getint() {\n  long long _x = 0, _tmp = 1;\n  char _tc = getchar();\n  while ((_tc < '0' || _tc > '9') && _tc != '-') _tc = getchar();\n  if (_tc == '-') _tc = getchar(), _tmp = -1;\n  while (_tc >= '0' && _tc <= '9') _x *= 10, _x += (_tc - '0'), _tc = getchar();\n  return _x * _tmp;\n}\ninline long long add(long long _x, long long _y, long long _mod = mod7) {\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline long long sub(long long _x, long long _y, long long _mod = mod7) {\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline long long mul(long long _x, long long _y, long long _mod = mod7) {\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nlong long mypow(long long _a, long long _x, long long _mod) {\n  if (_x == 0) return 1LL;\n  long long _ret = mypow(mul(_a, _a, _mod), _x >> 1, _mod);\n  if (_x & 1) _ret = mul(_ret, _a, _mod);\n  return _ret;\n}\nlong long mymul(long long _a, long long _x, long long _mod) {\n  if (_x == 0) return 0LL;\n  long long _ret = mymul(add(_a, _a, _mod), _x >> 1, _mod);\n  if (_x & 1) _ret = add(_ret, _a, _mod);\n  return _ret;\n}\nvoid sleep(double sec = 1021) {\n  clock_t s = clock();\n  while (clock() - s < CLOCKS_PER_SEC * sec)\n    ;\n}\nint __ = 1, _cs;\nconst int N = 52;\nint C[N][N], C2[N][2];\nvoid build() {\n  for (int i = 0; i < N; i++) C[i][0] = C[i][i] = 1;\n  for (int i = 2; i < N; i++)\n    for (int j = 1; j < i; j++) C[i][j] = add(C[i - 1][j], C[i - 1][j - 1]);\n  for (int i = 0; i < N; i++)\n    for (int j = 0; j < N; j++) C2[i][j & 1] = add(C2[i][j & 1], C[i][j]);\n}\ninline int CC(int x, int p) { return C2[x][p]; }\nint n, req, c[N];\nvoid init() {\n  n = getint();\n  req = getint();\n  for (int i = 1; i <= n; i++) c[i] = getint();\n}\nint dp[2][N][N][N][N][2];\nint inq[2][N][N][N][N][2];\nvector<tuple<int, int, int, int, int> > Q[2];\nvoid solve() {\n  Q[0].push_back(make_tuple(0, 0, 0, 0, 0));\n  dp[0][0][0][0][0][0] = 1;\n  int ans = 0;\n  for (int i = 1; i <= n + 1; i++) {\n    int now = i & 1, pre = 1 - now;\n    for (auto tp : Q[pre]) {\n      int o1 = get<0>(tp);\n      int e1 = get<1>(tp);\n      int o2 = get<2>(tp);\n      int e2 = get<3>(tp);\n      int pr = get<4>(tp);\n      int val = dp[pre][o1][e1][o2][e2][pr];\n      if (i == n + 1) {\n        if (pr == req) ans = add(ans, val);\n        continue;\n      }\n      if (val == 0) continue;\n      for (int to_o1 = 0; to_o1 < 2; to_o1++)\n        for (int to_e1 = 0; to_e1 < 2; to_e1++)\n          for (int to_o2 = 0; to_o2 < 2; to_o2++)\n            for (int to_e2 = 0; to_e2 < 2; to_e2++) {\n              for (int my_clr = 0; my_clr < 2; my_clr++) {\n                if (c[i] >= 0 and c[i] != my_clr) continue;\n                int way = val;\n                way = mul(way, CC(o1, to_o1));\n                way = mul(way, CC(e1, to_e1));\n                way = mul(way, CC(o2, to_o2));\n                way = mul(way, CC(e2, to_e2));\n                int no1 = o1, ne1 = e1;\n                int no2 = o2, ne2 = e2;\n                int my_par = 1;\n                if (my_clr == 0)\n                  my_par = (my_par + to_o2) & 1;\n                else\n                  my_par = (my_par + to_o1) & 1;\n                if (my_clr == 0) {\n                  if (my_par)\n                    no1++;\n                  else\n                    ne1++;\n                } else {\n                  if (my_par)\n                    no2++;\n                  else\n                    ne2++;\n                }\n                int npr = (pr + my_par) & 1;\n                int& to = dp[now][no1][ne1][no2][ne2][npr];\n                to = add(to, way);\n                if (inq[now][no1][ne1][no2][ne2][npr] != i) {\n                  inq[now][no1][ne1][no2][ne2][npr] = i;\n                  Q[now].push_back(make_tuple(no1, ne1, no2, ne2, npr));\n                }\n              }\n            }\n      Q[pre].clear();\n    }\n  }\n  printf(\"%d\\n\", ans);\n}\nint main() {\n  build();\n  while (__--) {\n    init();\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[201000][2][2][2], n, p, a[201000], pw[201000];\nvoid upd(int& x, long long y) { x = (x + y) % 1000000007; }\nint main() {\n  scanf(\"%d%d\", &n, &p), pw[0] = 1;\n  for (int i = 1; i <= n; ++i) pw[i] = 1ll * pw[i - 1] * 2 % 1000000007;\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n  dp[0][0][0][0] = 1;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < 2; ++j)\n      for (int k = 0; k < 2; ++k)\n        for (int l = 0; l < 2; ++l)\n          if (dp[i][j][k][l]) {\n            int val = dp[i][j][k][l];\n            if (a[i + 1] == 0 || a[i + 1] == -1) {\n              int x0 = 0, x1 = 0;\n              if (k == 0)\n                x0 = pw[i], x1 = 0;\n              else\n                x0 = pw[i - 1], x1 = pw[i - 1];\n              upd(dp[i + 1][j | 0][k][l ^ 0], 1ll * val * x1);\n              upd(dp[i + 1][j | 1][k][l ^ 1], 1ll * val * x0);\n            }\n            if (a[i + 1] == 1 || a[i + 1] == -1) {\n              int x0 = 0, x1 = 0;\n              if (j == 0)\n                x0 = pw[i], x1 = 0;\n              else\n                x0 = pw[i - 1], x1 = pw[i - 1];\n              upd(dp[i + 1][j][k | 0][l ^ 0], 1ll * val * x1);\n              upd(dp[i + 1][j][k | 1][l ^ 1], 1ll * val * x0);\n            }\n          }\n  int ans = 0;\n  for (int i = 0; i < 2; ++i)\n    for (int j = 0; j < 2; ++j) ans = (ans + dp[n][i][j][p]) % 1000000007;\n  printf(\"%d\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1e9 + 7;\nconst long long linf = 1ll * inf * inf;\nconst int N = 57;\nconst int M = 1000000 + 3;\nconst int multipleTest = 0;\nconst double pi = acos(-1);\nvoid add(long long& a, long long b) {\n  a += b % inf;\n  if (a >= inf) a -= inf;\n  if (a >= inf) a %= inf;\n}\nlong long C[N][N];\nlong long f[N][N][2];\nlong long dp[2][N][N][N];\nlong long lt[N];\nint n, k;\nvoid solve() {\n  lt[0] = 1;\n  for (int i = (1), _b = (N); i < _b; ++i) lt[i] = lt[i - 1] * 2 % inf;\n  C[0][0] = 1;\n  for (int i = (1), _b = (N); i < _b; ++i) {\n    C[i][0] = C[i][i] = 1;\n    for (int j = (1), _b = (i); j < _b; ++j)\n      C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % inf;\n  }\n  for (int u = (0), _b = (N); u < _b; ++u)\n    for (int v = (0), _b = (N); v < _b; ++v) {\n      for (int p = (0), _b = (u + 1); p < _b; ++p)\n        for (int q = (0), _b = (v + 1); q < _b; ++q) {\n          add(f[u][v][((q + 1) & 1)], C[u][p] * C[v][q]);\n        }\n    }\n  cin >> n >> k;\n  int cur = 0;\n  dp[cur][0][0][0] = 1;\n  for (int i = (0), _b = (n); i < _b; ++i) {\n    int u;\n    scanf(\"%d\", &u);\n    vector<int> p;\n    if (u != -1)\n      p.push_back(u);\n    else {\n      p.push_back(0);\n      p.push_back(1);\n    }\n    int pre = cur;\n    cur ^= 1;\n    for (int u00 = (0), _b = (i + 2); u00 < _b; ++u00)\n      for (int u01 = (0), _b = (i + 2 - u01); u01 < _b; ++u01)\n        for (int v10 = (0), _b = (i + 2 - u00 - u01); v10 < _b; ++v10)\n          dp[cur][u00][u01][v10] = 0;\n    for (int u : p) {\n      for (int u00 = (0), _b = (i + 1); u00 < _b; ++u00)\n        for (int u01 = (0), _b = (i + 1 - u00); u01 < _b; ++u01)\n          for (int v10 = (0), _b = (i + 1 - u01 - u00); v10 < _b; ++v10) {\n            int v11 = i - u00 - u01 - v10;\n            long long val = dp[pre][u00][u01][v10];\n            if (val == 0) continue;\n            if (u == 0) {\n              val = val * lt[u00 + u01] % inf;\n              add(dp[cur][u00 + 1][u01][v10], val * f[v10][v11][0]);\n              add(dp[cur][u00][u01 + 1][v10], val * f[v10][v11][1]);\n            } else {\n              val = val * lt[v10 + v11] % inf;\n              add(dp[cur][u00][u01][v10 + 1], val * f[u00][u01][0]);\n              add(dp[cur][u00][u01][v10], val * f[u00][u01][1]);\n            }\n          }\n    }\n  }\n  long long res = 0;\n  for (int u = (0), _b = (N); u < _b; ++u)\n    for (int v = (0), _b = (N); v < _b; ++v)\n      for (int p = (0), _b = (N); p < _b; ++p) {\n        int t = n - u - v - p;\n        if (t >= 0 && (v + t) % 2 == k) add(res, dp[cur][u][v][p]);\n      }\n  cout << res;\n}\nint main() {\n  int Test = 1;\n  if (multipleTest) {\n    cin >> Test;\n  }\n  for (int i = 0; i < Test; ++i) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid out(T x) {\n  cout << x << endl;\n  exit(0);\n}\nconst long long mod = 1e9 + 7;\nconst int maxn = 55;\nint n, p;\nint c[maxn];\nconst int BLACK = 0;\nconst int WHITE = 1;\nlong long pw2[maxn];\nlong long fac[maxn * 10], ifac[maxn * 10], inv[maxn * 10];\nlong long nck(long long n, long long k) {\n  if (n < k) return 0;\n  return fac[n] * ifac[k] % mod * ifac[n - k] % mod;\n}\nvoid gen_inv() {\n  fac[0] = inv[0] = ifac[0] = 1;\n  fac[1] = inv[1] = ifac[1] = 1;\n  for (int i = 2; i < maxn * 10; i++) {\n    fac[i] = fac[i - 1] * i % mod;\n    inv[i] = (mod - (mod / i) * inv[mod % i] % mod) % mod;\n    ifac[i] = ifac[i - 1] * inv[i] % mod;\n  }\n  assert(nck(4, 2) == 6);\n}\nlong long even[maxn], odd[maxn];\nvoid gen() {\n  pw2[0] = 1;\n  for (int i = 1; i < maxn; i++) {\n    pw2[i] = pw2[i - 1] * 2LL % mod;\n  }\n  gen_inv();\n  for (int k = 0; k < maxn; k++) {\n    for (int j = 0; j <= k; j += 2) {\n      even[k] += nck(k, j);\n      even[k] %= mod;\n    }\n    for (int j = 1; j <= k; j += 2) {\n      odd[k] += nck(k, j);\n      odd[k] %= mod;\n    }\n  }\n}\nlong long dp[maxn][maxn][maxn][maxn];\nvoid add(long long& x, long long y) {\n  x %= mod;\n  y %= mod;\n  x += y;\n  x %= mod;\n}\nvoid solve(int color, int ob, int ow, int eb, int ew, long long& res) {\n  if (color != BLACK && ow > 0) {\n    res += pw2[eb + ew + (ow - 1)] * dp[ob][ow - 1][eb][ew] % mod * even[ob];\n  }\n  if (color != BLACK && ew > 0) {\n    res += pw2[eb + ow + (ew - 1)] * dp[ob][ow][eb][ew - 1] % mod * odd[ob];\n  }\n  if (color != WHITE && ob > 0) {\n    res +=\n        pw2[ew + eb + (ob - 1)] * dp[ob - 1][ow][eb][ew] % mod * even[ow] % mod;\n  }\n  if (color != WHITE && eb > 0) {\n    res +=\n        pw2[ew + ob + (eb - 1)] * dp[ob][ow][eb - 1][ew] % mod * odd[ow] % mod;\n  }\n  assert(res >= 0);\n  res %= mod;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> p;\n  for (int i = 1; i <= n; i++) {\n    cin >> c[i];\n  }\n  gen();\n  long long res = 0;\n  dp[0][0][0][0] = 1;\n  for (int i = 1; i <= n; i++) {\n    for (int ob = 0; ob <= i; ob++) {\n      for (int ow = 0; ow + ob <= i; ow++) {\n        for (int eb = 0; eb + ow + ob <= i; eb++) {\n          int ew = i - ob - ow - eb;\n          solve(c[i], ob, ow, eb, ew, dp[ob][ow][eb][ew]);\n          if (i == n && (ob + ow) % 2 == p) {\n            add(res, dp[ob][ow][eb][ew]);\n          }\n        }\n      }\n    }\n  }\n  res %= mod;\n  res += mod;\n  res %= mod;\n  out(res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int mod = 1e9 + 7;\nconst int N = 60;\nint n, p, _2[N], a[N];\nint f[N][2][2][2], ans;\nvoid add(int &x, int y) {\n  x += y;\n  if (x >= mod) x -= mod;\n}\nint main() {\n  scanf(\"%d%d\", &n, &p);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  _2[0] = 1;\n  for (int i = 1; i <= n; i++) _2[i] = (_2[i - 1] << 1) % mod;\n  f[0][0][0][0] = 1;\n  for (int i = 1; i <= n; i++)\n    for (int _ = 0; _ <= 1; _++)\n      for (int ob = 0; ob <= 1; ob++)\n        for (int ow = 0; ow <= 1; ow++) {\n          int qwq = f[i - 1][_][ob][ow];\n          if (a[i] != 0) {\n            if (ob) {\n              add(f[i][_][ob][ow], 1ll * qwq * _2[i - 2] % mod);\n              add(f[i][_ ^ 1][ob][ow | 1], 1ll * qwq * _2[i - 2] % mod);\n            } else\n              add(f[i][_ ^ 1][ob][ow | 1], 1ll * qwq * _2[i - 1] % mod);\n          }\n          if (a[i] != 1) {\n            if (ow) {\n              add(f[i][_][ob][ow], 1ll * qwq * _2[i - 2] % mod);\n              add(f[i][_ ^ 1][ob | 1][ow], 1ll * qwq * _2[i - 2] % mod);\n            } else\n              add(f[i][_ ^ 1][ob | 1][ow], 1ll * qwq * _2[i - 1] % mod);\n          }\n        }\n  for (int ob = 0; ob <= 1; ob++)\n    for (int ow = 0; ow <= 1; ow++) add(ans, f[n][p][ob][ow]);\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint intcmp(const void *v1, const void *v2) { return *(int *)v1 - *(int *)v2; }\nconst int N = 55;\nint n, p, c[N];\nlong long f[N][N][N][N];\nlong long ans = 0, pw[N], od[N], ev[N];\nvoid init() {\n  f[0][0][0][0] = 1;\n  pw[0] = 1;\n  ev[0] = 1;\n  for (int i = 1; i < N; i++) {\n    pw[i] = pw[i - 1] * 2 % 1000000007;\n    od[i] = ev[i] = pw[i - 1];\n  }\n}\nvoid find_ans(int ob, int eb, int ow, int ew, int col, long long &ret) {\n  if (col != 0 && ew)\n    (ret += f[ob][eb][ow][ew - 1] * pw[ow + ew - 1 + eb] % 1000000007 * od[ob] %\n            1000000007) %= 1000000007;\n  if (col != 0 && ow)\n    (ret += f[ob][eb][ow - 1][ew] * pw[ow - 1 + ew + eb] % 1000000007 * ev[ob] %\n            1000000007) %= 1000000007;\n  if (col != 1 && eb)\n    (ret += f[ob][eb - 1][ow][ew] * pw[ob + eb - 1 + ew] % 1000000007 * od[ow] %\n            1000000007) %= 1000000007;\n  if (col != 1 && ob)\n    (ret += f[ob - 1][eb][ow][ew] * pw[ob - 1 + eb + ew] % 1000000007 * ev[ow] %\n            1000000007) %= 1000000007;\n}\nint main() {\n  init();\n  cin >> n >> p;\n  for (int i = 1; i < n + 1; i++) scanf(\"%d\", c + i);\n  for (int i = 1; i < n + 1; i++)\n    for (int ob = 0; ob < i + 1; ob++)\n      for (int eb = 0; eb < i - ob + 1; eb++)\n        for (int ow = 0; ow < i - ob - eb + 1; ow++) {\n          int ew = i - ob - eb - ow;\n          find_ans(ob, eb, ow, ew, c[i], f[ob][eb][ow][ew]);\n          if (i == n && ((ob + ow) & 1) == p)\n            (ans += f[ob][eb][ow][ew]) %= 1000000007;\n        }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Div2_482E {\n\n\tstatic int nV;\n\tstatic int p;\n\n\tstatic int[] color;\n\n\tstatic long[] pow2;\n\n\tstatic long[][][][] dp;\n\n\tstatic long MOD = 1_000_000_007;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tpow2 = new long[500];\n\t\tpow2[0] = 1;\n\t\tfor (int i = 1; i < 500; i++) {\n\t\t\tpow2[i] = pow2[i - 1] * 2 % MOD;\n\t\t}\n\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter printer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\t\tStringTokenizer inputData = new StringTokenizer(reader.readLine());\n\t\tnV = Integer.parseInt(inputData.nextToken());\n\t\tp = Integer.parseInt(inputData.nextToken());\n\n\t\tcolor = new int[nV];\n\t\tinputData = new StringTokenizer(reader.readLine());\n\t\tfor (int i = 0; i < nV; i++) {\n\t\t\tcolor[i] = Integer.parseInt(inputData.nextToken());\n\t\t}\n\n\t\tdp = new long[nV + 1][nV + 1][nV + 1][nV + 1];\n\t\tdp[nV][0][0][0] = 1;\n\t\tpushDP(nV, 0, 0, 0);\n\n\t\tfor (int cV = nV - 1; cV > 0; cV--) {\n\t\t\tfor (int i = 0; i <= nV; i++) {\n\t\t\t\tfor (int j = 0; j <= nV; j++) {\n\t\t\t\t\tfor (int k = 0; k <= nV; k++) {\n\t\t\t\t\t\tint l = nV - cV - i - j - k;\n\t\t\t\t\t\tif (l >= 0 && dp[cV][i][j][k] != 0) {\n\t\t\t\t\t\t\tpushDP(cV, i, j, k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong ans = 0;\n\t\tfor (int wE = 0; wE <= nV; wE++) {\n\t\t\tfor (int wO = 0; wO <= nV; wO++) {\n\t\t\t\tfor (int bE = 0; bE <= nV; bE++) {\n\t\t\t\t\tint bO = nV - wE - wO - bE;\n\n\t\t\t\t\tif (bO >= 0 && ((wO + bO) & 1) == p) {\n\t\t\t\t\t\tans = (ans + dp[0][wE][wO][bE]) % MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprinter.println(ans);\n\t\tprinter.close();\n\t}\n\n\tstatic void pushDP(int cV, int wE, int wO, int bE) {\n\t\tint bO = nV - cV - wE - wO - bE;\n\t\tlong cDP = dp[cV][wE][wO][bE];\n\t\tif (cDP == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// white\n\t\tif (color[cV - 1] == 0 || color[cV - 1] == -1) {\n\t\t\tif (bO != 0) {\n\t\t\t\tdp[cV - 1][wE + 1][wO][bE] = (dp[cV - 1][wE + 1][wO][bE] + pow2[wE + wO + bE + bO - 1] * cDP) % MOD;\n\t\t\t\tdp[cV - 1][wE][wO + 1][bE] = (dp[cV - 1][wE][wO + 1][bE] + pow2[wE + wO + bE + bO - 1] * cDP) % MOD;\n\t\t\t} else {\n\t\t\t\tdp[cV - 1][wE][wO + 1][bE] = (dp[cV - 1][wE][wO + 1][bE] + pow2[wE + wO + bE] * cDP) % MOD;\n\t\t\t}\n\t\t}\n\t\t// black\n\t\tif (color[cV - 1] == 1 || color[cV - 1] == -1) {\n\t\t\tif (wO != 0) {\n\t\t\t\tdp[cV - 1][wE][wO][bE + 1] = (dp[cV - 1][wE][wO][bE + 1] + pow2[wE + wO + bE + bO - 1] * cDP) % MOD;\n\t\t\t\tdp[cV - 1][wE][wO][bE] = (dp[cV - 1][wE][wO][bE] + pow2[wE + wO + bE + bO - 1] * cDP) % MOD;\n\t\t\t} else {\n\t\t\t\tdp[cV - 1][wE][wO][bE] = (dp[cV - 1][wE][wO][bE] + pow2[wE + bE + bO] * cDP) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 54, mod = 1000000007, pmod = mod - 1;\nint n, par;\nint dp[2][2][2][2], (*cur)[2][2] = *dp, (*nxt)[2][2] = dp[1];\ninline void add(int &x, const int y) { x += y - mod, x += x >> 31 & mod; }\nlong long PowerMod(long long a, int n, long long c = 1) {\n  for (n += n >> 31 & pmod; n; n >>= 1, a = a * a % mod)\n    if (n & 1) c = c * a % mod;\n  return c;\n}\nint main() {\n  int i, j, k, p, c, t;\n  scanf(\"%d%d\", &n, &par);\n  for (***nxt = i = 1; i <= n; ++i) {\n    scanf(\"%d\", &c), std::swap(cur, nxt), memset(nxt, 0, sizeof *dp);\n    for (p = 0; p < 2; ++p)\n      for (j = 0; j < 2; ++j)\n        for (k = 0; k < 2; ++k)\n          if ((t = cur[p][j][k])) {\n            if (c != 1) add(nxt[!p][1][k], t), add(nxt[!p ^ k][j | !k][k], t);\n            if (c != 0) add(nxt[!p][j][1], t), add(nxt[!p ^ j][j][!j | k], t);\n          }\n  }\n  printf(\"%d\\n\", (int)PowerMod(2, (n - 1) * (n - 2) / 2 - 1,\n                               ((long long)nxt[par][0][0] + nxt[par][0][1] +\n                                nxt[par][1][0] + nxt[par][1][1]) %\n                                   mod));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 60;\nint n, p, col[N], pw[N], f[2][N][N];\nint main() {\n  scanf(\"%d%d\", &n, &p);\n  pw[0] = 1;\n  for (int i = 1; i <= n; i++) pw[i] = 2ll * pw[i - 1] % 1000000007;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &col[i]);\n  }\n  int t = 0;\n  f[0][0][0] = 1;\n  for (int i = 1; i <= n; i++, t ^= 1) {\n    memset(f[t ^ 1], 0, sizeof f[t ^ 1]);\n    if (col[i] != 0) {\n      for (int j = 0; j < i; j++) {\n        for (int k = 0; j + k < i; k++) {\n          if (!j)\n            (f[t ^ 1][j][k + 1] += 1ll * f[t][j][k] * pw[i - 1] % 1000000007) %=\n                1000000007;\n          else if (i >= 2) {\n            (f[t ^ 1][j][k] += 1ll * f[t][j][k] * pw[i - 2] % 1000000007) %=\n                1000000007;\n            (f[t ^ 1][j][k + 1] += 1ll * f[t][j][k] * pw[i - 2] % 1000000007) %=\n                1000000007;\n          }\n        }\n      }\n    }\n    if (col[i] != 1) {\n      for (int j = 0; j < i; j++) {\n        for (int k = 0; j + k < i; k++) {\n          if (!k)\n            (f[t ^ 1][j + 1][k] += 1ll * f[t][j][k] * pw[i - 1] % 1000000007) %=\n                1000000007;\n          else if (i >= 2) {\n            (f[t ^ 1][j][k] += 1ll * f[t][j][k] * pw[i - 2] % 1000000007) %=\n                1000000007;\n            (f[t ^ 1][j + 1][k] += 1ll * f[t][j][k] * pw[i - 2] % 1000000007) %=\n                1000000007;\n          }\n        }\n      }\n    }\n  }\n  int ans = 0;\n  for (int j = 0; j <= n; j++) {\n    for (int k = 0; k <= n - j; k++) {\n      if ((j + k) % 2 == p) ans = (ans + f[t][j][k]) % 1000000007;\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, p, s[55];\nlong long f[55][55][55][55], pw[55], ans;\nvoid add(long long &a, long long b) {\n  a += b;\n  if (a >= 1000000007) a -= 1000000007;\n}\nint main() {\n  scanf(\"%d%d\", &n, &p);\n  pw[0] = 1;\n  for (int i = 1; i <= n; i++)\n    scanf(\"%d\", &s[i]), pw[i] = pw[i - 1] * 2 % 1000000007;\n  f[0][0][0][0] = 1;\n  for (int i = 1; i <= n; i++)\n    for (int ew = 0; ew <= i; ew++)\n      for (int eb = 0; eb + ew <= i; eb++)\n        for (int ow = 0; ow + ew + eb <= i; ow++) {\n          int ob = i - ew - eb - ow;\n          if (ow + ew && s[i]) {\n            long long res = 0;\n            if (ow) {\n              if (ob)\n                add(res, f[i - 1][ew][eb][ow - 1] * pw[ob - 1] % 1000000007);\n              else\n                add(res, f[i - 1][ew][eb][ow - 1]);\n            }\n            if (ew && ob)\n              add(res, f[i - 1][ew - 1][eb][ow] * pw[ob - 1] % 1000000007);\n            add(f[i][ew][eb][ow], res * pw[ow + ew + eb - 1] % 1000000007);\n          }\n          if (ob + eb && s[i] < 1) {\n            long long res = 0;\n            if (ob) {\n              if (ow)\n                add(res, f[i - 1][ew][eb][ow] * pw[ow - 1] % 1000000007);\n              else\n                add(res, f[i - 1][ew][eb][ow]);\n            }\n            if (eb && ow)\n              add(res, f[i - 1][ew][eb - 1][ow] * pw[ow - 1] % 1000000007);\n            add(f[i][ew][eb][ow], res * pw[eb + ob + ew - 1] % 1000000007);\n          }\n          if (i == n && (ow + ob) % 2 == p) add(ans, f[i][ew][eb][ow]);\n        }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "/* package whatever; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\n\npublic class Main\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tScanner scan=new Scanner(System.in);\n\t\tint n=scan.nextInt();\n\t\tint p=scan.nextInt();\n\t\tint[] col=new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcol[i]=scan.nextInt();\n\t\t}\n\t\tPaths paths=new Paths();\n\t\tpaths.calc(n,p,col);\n\t\tSystem.out.println(paths.f(0,0,0));\n\t}\n}\n\nclass Paths{\n\tlong MOD=1000000007;\n\tlong[] pow2=new long[51];\n\tint[] col=new int[51];\n\tlong[][][] dp=new long[51][51][51];\n\tint n;\n\tint P;\n\t\n\tvoid calc(int N,int parity,int[] C){\n\t\tn=N;\n\t\tP=parity;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcol[i]=C[i];\n\t\t}\n\t\tpow2[0]=1;\n\t\tfor(int i=1;i<=50;i++){\n\t\t\tpow2[i]=(2*pow2[i-1])%MOD;\n\t\t}\n\t\tfor(int i=0;i<=50;i++){\n\t\t\tfor(int j=0;j<=50;j++){\n\t\t\t\tfor(int k=0;k<=50;k++){\n\t\t\t\t\tdp[i][j][k]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong f(int i,int ob,int ow){\n\t\tint p=ob+ow;\n\t\tif(i==n){\n\t\t\tif(p%2==P){return 1;}\n\t\t\telse{return 0;}\n\t\t}\n\t\tlong res=dp[i][ob][ow];\n\t\tif(res!=-1){return res;}\n\t\tres=0;\n\t\tif(col[i]==1 || col[i]==-1){ //white\n\t\t\tlong even=0;\n\t\t\tlong odd=0;\n\t\t\tif(ob>0){\n\t\t\t\teven=pow2[ob-1];\n\t\t\t\todd=pow2[ob-1];\n\t\t\t}\n\t\t\telse{\n\t\t\t\teven=1;\n\t\t\t\todd=0;\n\t\t\t}\n\t\t\tlong u=even*f(i+1,ob,ow+1)+odd*f(i+1,ob,ow);\n\t\t\tu%=MOD;\n\t\t\tres+=pow2[i-ob]*u;\n\t\t\tres%=MOD;\n\t\t}\n\t\tif(col[i]==0 || col[i]==-1){ //black\n\t\t\tlong even=0;\n\t\t\tlong odd=0;\n\t\t\tif(ow>0){\n\t\t\t\teven=pow2[ow-1];\n\t\t\t\todd=pow2[ow-1];\n\t\t\t}\n\t\t\telse{\n\t\t\t\teven=1;\n\t\t\t\todd=0;\n\t\t\t}\n\t\t\tlong u=even*f(i+1,ob+1,ow)+odd*f(i+1,ob,ow);\n\t\t\tu%=MOD;\n\t\t\tres+=pow2[i-ow]*u;\n\t\t\tres%=MOD;\n\t\t}\n\t\tdp[i][ob][ow]=res;\n\t\treturn res;\n\t}\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 60;\nconst int mo = (int)1e9 + 7;\nint n, p, a[N];\nlong long pw[N], f[N][N][N][N];\nint main() {\n  pw[0] = 1;\n  for (int i = 1; i < N; i++) pw[i] = pw[i - 1] * 2 % mo;\n  scanf(\"%d%d\", &n, &p);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", a + i);\n  f[0][0][0][0] = 1;\n  for (int i = 1; i <= n; i++)\n    for (int w0 = 0; w0 <= i - 1; w0++)\n      for (int w1 = 0; w1 <= i - 1 - w0; w1++)\n        for (int b0 = 0; b0 <= i - 1 - w0 - w1; b0++) {\n          int b1 = i - 1 - w0 - w1 - b0;\n          if (a[i] != 1) {\n            if (b1) {\n              (f[i][w0][w1 + 1][b0] +=\n               f[i - 1][w0][w1][b0] * pw[w0 + w1 + b0 + b1 - 1] % mo) %= mo;\n              (f[i][w0 + 1][w1][b0] +=\n               f[i - 1][w0][w1][b0] * pw[w0 + w1 + b0 + b1 - 1] % mo) %= mo;\n            } else {\n              (f[i][w0][w1 + 1][b0] +=\n               f[i - 1][w0][w1][b0] * pw[w0 + w1 + b0] % mo) %= mo;\n            }\n          }\n          if (a[i] != 0) {\n            if (w1) {\n              (f[i][w0][w1][b0] +=\n               f[i - 1][w0][w1][b0] * pw[b0 + b1 + w0 + w1 - 1] % mo) %= mo;\n              (f[i][w0][w1][b0 + 1] +=\n               f[i - 1][w0][w1][b0] * pw[b0 + b1 + w0 + w1 - 1] % mo) %= mo;\n            } else {\n              (f[i][w0][w1][b0] +=\n               f[i - 1][w0][w1][b0] * pw[b0 + b1 + w0] % mo) %= mo;\n            }\n          }\n        }\n  long long ans = 0;\n  for (int w0 = 0; w0 <= n; w0++)\n    for (int w1 = 0; w1 <= n - w0; w1++)\n      for (int b0 = 0; b0 <= n - w0 - w1; b0++) {\n        int b1 = n - w0 - w1 - b0;\n        if ((w1 + b1) % 2 == p) (ans += f[n][w0][w1][b0]) %= mo;\n      }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, op, d;\nint f[(55)][(55)][(55)][(55)], mi[1000005], a[(55)];\nconst int P = 1000000007;\ntemplate <typename T>\nvoid read(T& t) {\n  t = 0;\n  bool fl = true;\n  char p = getchar();\n  while (!isdigit(p)) {\n    if (p == '-') fl = false;\n    p = getchar();\n  }\n  do {\n    (t *= 10) += p - 48;\n    p = getchar();\n  } while (isdigit(p));\n  if (!fl) t = -t;\n}\nint ksm(int a, int b) {\n  if (b == 0) return 1;\n  int ret = 1;\n  while (b > 1) {\n    if (b & 1) ret = 1ll * ret * a % P;\n    b >>= 1;\n    a = 1ll * a * a % P;\n  }\n  return 1ll * ret * a % P;\n}\nint Inc(int a, int b) { return (a + b >= P) ? (a + b - P) : (a + b); }\nint calc(int k, int op) {\n  if (k == 0) {\n    if (op == 0)\n      return 1;\n    else\n      return 0;\n  } else\n    return mi[k - 1];\n}\nint main() {\n  read(n), read(op);\n  mi[0] = 1;\n  for (int i = 1; i <= 1000000; i++) mi[i] = mi[i - 1] * 2 % P;\n  for (int i = 1; i <= n; i++) read(a[i]);\n  f[0][0][0][0] = 1;\n  f[0][0][1][0] = 1;\n  for (int i = 1; i <= n; i++) {\n    for (int a1 = 0; a1 < i; a1++)\n      for (int a2 = 0; a1 + a2 < i; a2++)\n        for (int a3 = 0; a1 + a2 + a3 < i; a3++) {\n          int a4 = i - 1 - a1 - a2 - a3;\n          if (a[i] == 0) {\n            f[i][a1 + 1][a2][a3] = Inc(\n                f[i][a1 + 1][a2][a3], 1ll * f[i - 1][a1][a2][a3] * calc(a3, 0) %\n                                          P * mi[a1 + a2 + a4] % P);\n            f[i][a1][a2 + 1][a3] = Inc(\n                f[i][a1][a2 + 1][a3], 1ll * f[i - 1][a1][a2][a3] * calc(a3, 1) %\n                                          P * mi[a1 + a2 + a4] % P);\n          }\n          if (a[i] == 1) {\n            f[i][a1][a2][a3 + 1] = Inc(\n                f[i][a1][a2][a3 + 1], 1ll * f[i - 1][a1][a2][a3] * calc(a1, 0) %\n                                          P * mi[a3 + a4 + a2] % P);\n            f[i][a1][a2][a3] =\n                Inc(f[i][a1][a2][a3], 1ll * f[i - 1][a1][a2][a3] * calc(a1, 1) %\n                                          P * mi[a3 + a4 + a2] % P);\n          }\n          if (a[i] == -1) {\n            f[i][a1 + 1][a2][a3] = Inc(\n                f[i][a1 + 1][a2][a3], 1ll * f[i - 1][a1][a2][a3] * calc(a3, 0) %\n                                          P * mi[a1 + a2 + a4] % P);\n            f[i][a1][a2 + 1][a3] = Inc(\n                f[i][a1][a2 + 1][a3], 1ll * f[i - 1][a1][a2][a3] * calc(a3, 1) %\n                                          P * mi[a1 + a2 + a4] % P);\n            f[i][a1][a2][a3 + 1] = Inc(\n                f[i][a1][a2][a3 + 1], 1ll * f[i - 1][a1][a2][a3] * calc(a1, 0) %\n                                          P * mi[a3 + a4 + a2] % P);\n            f[i][a1][a2][a3] =\n                Inc(f[i][a1][a2][a3], 1ll * f[i - 1][a1][a2][a3] * calc(a1, 1) %\n                                          P * mi[a3 + a4 + a2] % P);\n          }\n        }\n  }\n  int ans = 0;\n  for (int a1 = 0; a1 <= n; a1++)\n    for (int a2 = 0; a1 + a2 <= n; a2++)\n      for (int a3 = 0; a1 + a2 + a3 <= n; a3++) {\n        if (((a1 + a3) & 1) == op) ans = Inc(ans, f[n][a1][a2][a3]);\n      }\n  printf(\"%d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool debug = 0;\nint n, m, k;\nint dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\nstring direc = \"RDLU\";\nlong long ln, lk, lm;\nvoid etp(bool f = 0) {\n  puts(f ? \"YES\" : \"NO\");\n  exit(0);\n}\nvoid addmod(int &x, int y, int mod = 1000000007) {\n  assert(y >= 0);\n  x += y;\n  if (x >= mod) x -= mod;\n  assert(x >= 0 && x < mod);\n}\nvoid et() {\n  puts(\"-1\");\n  exit(0);\n}\nlong long fastPow(long long x, long long y, int mod = 1000000007) {\n  long long ans = 1;\n  while (y > 0) {\n    if (y & 1) ans = (x * ans) % mod;\n    x = x * x % mod;\n    y >>= 1;\n  }\n  return ans;\n}\nlong long gcd1(long long x, long long y) { return y ? gcd1(y, x % y) : x; }\nint p, c[105], pw[105];\nint dp[55][55][55][55];\nvoid fmain(int ID) {\n  scanf(\"%d%d\", &n, &p);\n  for (int(i) = 1; (i) <= (int)(n); (i)++) scanf(\"%d\", c + i);\n  pw[0] = 1;\n  for (int(i) = 1; (i) <= (int)(n); (i)++) pw[i] = pw[i - 1] * 2 % 1000000007;\n  dp[0][0][0][0] = 1;\n  for (int(i) = 1; (i) <= (int)(n); (i)++) {\n    for (int(ew) = 0; (ew) < (int)(i); (ew)++)\n      for (int(ow) = 0; (ow) < (int)(i); (ow)++)\n        for (int(eb) = 0; (eb) < (int)(i); (eb)++) {\n          int ob = i - 1 - ew - ow - eb;\n          if (ob < 0) {\n            continue;\n          }\n          if (c[i] != 0) {\n            if (ob) {\n              addmod(dp[i][ew][ow + 1][eb], (long long)dp[i - 1][ew][ow][eb] *\n                                                pw[ew + ow + eb + ob - 1] %\n                                                1000000007);\n              addmod(dp[i][ew + 1][ow][eb], (long long)dp[i - 1][ew][ow][eb] *\n                                                pw[ew + ow + eb + ob - 1] %\n                                                1000000007);\n            } else {\n              addmod(dp[i][ew][ow + 1][eb], (long long)dp[i - 1][ew][ow][eb] *\n                                                pw[ew + ow + eb] % 1000000007);\n            }\n          }\n          if (c[i] != 1) {\n            if (ow) {\n              addmod(dp[i][ew][ow][eb], (long long)dp[i - 1][ew][ow][eb] *\n                                            pw[ew + ow + eb + ob - 1] %\n                                            1000000007);\n              addmod(dp[i][ew][ow][eb + 1], (long long)dp[i - 1][ew][ow][eb] *\n                                                pw[ew + ow + eb + ob - 1] %\n                                                1000000007);\n            } else {\n              addmod(dp[i][ew][ow][eb], (long long)dp[i - 1][ew][ow][eb] *\n                                            pw[ob + eb + ew] % 1000000007);\n            }\n          }\n        }\n  }\n  int ans = 0;\n  for (int(ew) = 0; (ew) < (int)(n + 1); (ew)++)\n    for (int(ow) = 0; (ow) < (int)(n + 1); (ow)++)\n      for (int(eb) = 0; (eb) < (int)(n + 1); (eb)++) {\n        int ob = n - ew - ow - eb;\n        if (ob < 0) {\n          continue;\n        }\n        if ((ob + ow) % 2 == p) addmod(ans, dp[n][ew][ow][eb]);\n      }\n  printf(\"%d\\n\", ans);\n}\nint main() {\n  int t = 1;\n  for (int(i) = 1; (i) <= (int)(t); (i)++) {\n    fmain(i);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, a[55], p;\nint dp[55][55][55][55], ans;\nint two[55];\nint T(int x, int y) {\n  if (x == 0) {\n    if (y)\n      return 0;\n    else\n      return 1;\n  }\n  return two[x - 1];\n}\nint main() {\n  scanf(\"%d %d\", &n, &p);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  two[0] = 1;\n  for (int i = 1; i <= n; i++) two[i] = 2ll * two[i - 1] % 1000000007;\n  dp[0][0][0][0] = 1;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j < i; j++) {\n      for (int k = 0; k <= j; k++) {\n        for (int l = 0; l <= i - 1 - j; l++) {\n          if (!dp[i - 1][j][k][l]) continue;\n          if (a[i] != 0) {\n            (dp[i][j + 1][k + 1][l] += 1ll * dp[i - 1][j][k][l] * T(l, 0) %\n                                       1000000007 * two[i - 1 - l] %\n                                       1000000007) %= 1000000007;\n            (dp[i][j + 1][k][l] += 1ll * dp[i - 1][j][k][l] * T(l, 1) %\n                                   1000000007 * two[i - 1 - l] % 1000000007) %=\n                1000000007;\n          }\n          if (a[i] != 1) {\n            (dp[i][j][k][l + 1] += 1ll * dp[i - 1][j][k][l] * T(k, 0) %\n                                   1000000007 * two[i - 1 - k] % 1000000007) %=\n                1000000007;\n            (dp[i][j][k][l] += 1ll * dp[i - 1][j][k][l] * T(k, 1) % 1000000007 *\n                               two[i - 1 - k] % 1000000007) %= 1000000007;\n          }\n        }\n      }\n    }\n  }\n  for (int i = 0; i <= n; i++) {\n    for (int j = 0; j <= i; j++) {\n      for (int k = 0; k <= n - i; k++) {\n        int op = (j + k) % 2;\n        if (op == p) (ans += dp[n][i][j][k]) %= 1000000007;\n      }\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100100;\nconst int mod = 1e9 + 7;\ninline int read() {\n  char ch;\n  int f = 1;\n  while ((ch = getchar()) < '0' || ch > '9')\n    if (ch == '-') f = -1;\n  int res = ch - '0';\n  while ((ch = getchar()) >= '0' && ch <= '9') res = res * 10 + ch - '0';\n  return res * f;\n}\nint n, p, c[N], f[N][2][2][2];\nint pw[N];\nint main() {\n  n = read();\n  p = read();\n  for (int i = 1; i <= n; i++) c[i] = read();\n  pw[0] = 1;\n  for (int i = 1; i <= n; i++) pw[i] = 2ll * pw[i - 1] % mod;\n  f[0][0][0][0] = 1;\n  for (int i = 1; i <= n; i++)\n    for (int j = 0; j <= 1; j++)\n      for (int jh = 0; jh < 2; jh++)\n        for (int jb = 0; jb < 2; jb++) {\n          int tmp = f[i - 1][j][jh][jb];\n          if (c[i] != 0) {\n            if (jh) {\n              if (i != 1) {\n                (f[i][j ^ 1][jh][1] += 1ll * tmp * pw[i - 2] % mod) %= mod;\n                (f[i][j][jh][jb] += 1ll * tmp * pw[i - 2] % mod) %= mod;\n              }\n            } else\n              (f[i][j ^ 1][jh][1] += 1ll * tmp * pw[i - 1] % mod) %= mod;\n          }\n          if (c[i] != 1) {\n            if (jb) {\n              if (i != 1) {\n                (f[i][j ^ 1][1][jb] += 1ll * tmp * pw[i - 2] % mod) %= mod;\n                (f[i][j][jh][jb] += 1ll * tmp * pw[i - 2] % mod) %= mod;\n              }\n            } else\n              (f[i][j ^ 1][1][jb] += 1ll * tmp * pw[i - 1] % mod) %= mod;\n          }\n        }\n  int ans = 0;\n  for (int i = 0; i <= 1; i++)\n    for (int j = 0; j <= 1; j++) (ans += f[n][p][i][j]) %= mod;\n  printf(\"%d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nlong long n, p, d, ans, a[55], p2[55], f[55][2][2][2];\nsigned main() {\n  scanf(\"%lld%lld\", &n, &p);\n  for (long long i = 1; i <= n; i++) {\n    scanf(\"%lld\", &a[i]);\n  }\n  f[0][0][0][0] = 1;\n  p2[0] = 1;\n  for (long long i = 1; i <= n; i++) p2[i] = p2[i - 1] * 2 % mod;\n  for (long long i = 1; i <= n; i++)\n    for (long long b = 0; b <= 1; b++)\n      for (long long w = 0; w <= 1; w++)\n        for (long long a2 = 0; a2 <= 1; a2++) {\n          d = f[i - 1][b][w][a2];\n          if (a[i] != 0) {\n            if ((!b) || i == 1)\n              f[i][b][w | 1][a2 ^ 1] =\n                  (f[i][b][w | 1][a2 ^ 1] + d * p2[i - 1] % mod) % mod;\n            else {\n              f[i][b][w][a2] = (f[i][b][w][a2] + d * p2[i - 2] % mod) % mod;\n              f[i][b][w | 1][a2 ^ 1] =\n                  (f[i][b][w | 1][a2 ^ 1] + d * p2[i - 2] % mod) % mod;\n            }\n          }\n          if (a[i] != 1) {\n            if ((!w) || i == 1)\n              f[i][b | 1][w][a2 ^ 1] =\n                  (f[i][b | 1][w][a2 ^ 1] + d * p2[i - 1] % mod) % mod;\n            else {\n              f[i][b][w][a2] = (f[i][b][w][a2] + d * p2[i - 2] % mod) % mod;\n              f[i][b | 1][w][a2 ^ 1] =\n                  (f[i][b | 1][w][a2 ^ 1] + d * p2[i - 2] % mod) % mod;\n            }\n          }\n        }\n  for (long long i = 0; i <= 1; i++)\n    for (long long j = 0; j <= 1; j++) ans = (ans + f[n][i][j][p]) % mod;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nint n, p, s[60];\nlong long f[60][60][60][60], pw[60], ans;\nvoid add(long long &a, long long b) {\n  a += b;\n  if (a >= mod) {\n    a -= mod;\n  }\n}\nint main() {\n  cin >> n >> p;\n  pw[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    cin >> s[i];\n    pw[i] = pw[i - 1] * 2 % mod;\n  }\n  f[0][0][0][0] = 1;\n  for (int i = 1; i <= n; i++) {\n    for (int ew = 0; ew <= i; ew++) {\n      for (int eb = 0; eb + ew <= i; eb++) {\n        for (int ow = 0; ow + ew + eb <= i; ow++) {\n          int ob = i - ew - eb - ow;\n          if (ow + ew && s[i]) {\n            long long res = 0;\n            if (ow) {\n              if (ob)\n                add(res, f[i - 1][ew][eb][ow - 1] * pw[ob - 1] % mod);\n              else\n                add(res, f[i - 1][ew][eb][ow - 1]);\n            }\n            if (ew && ob) add(res, f[i - 1][ew - 1][eb][ow] * pw[ob - 1] % mod);\n            add(f[i][ew][eb][ow], res * pw[ow + ew + eb - 1] % mod);\n          }\n          if (ob + eb && s[i] < 1) {\n            long long res = 0;\n            if (ob) {\n              if (ow)\n                add(res, f[i - 1][ew][eb][ow] * pw[ow - 1] % mod);\n              else\n                add(res, f[i - 1][ew][eb][ow]);\n            }\n            if (eb && ow) add(res, f[i - 1][ew][eb - 1][ow] * pw[ow - 1] % mod);\n            add(f[i][ew][eb][ow], res * pw[eb + ob + ew - 1] % mod);\n          }\n          if (i == n && (ow + ob) % 2 == p) add(ans, f[i][ew][eb][ow]);\n        }\n      }\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 55;\nconst int M = 1000000007;\nint n, p, c[maxn];\nlong long ans = 0, pw[maxn], od[maxn], ev[maxn], f[maxn][maxn][maxn][maxn];\nvoid init() {\n  f[0][0][0][0] = 1;\n  pw[0] = 1;\n  for (int i = 1; i < maxn; i++) pw[i] = pw[i - 1] * 2 % M;\n  ev[0] = 1, od[0] = 0;\n  for (int i = 1; i < maxn; i++) ev[i] = od[i] = pw[i - 1];\n}\nvoid find_ans(int ob, int eb, int ow, int ew, int col, long long &ret) {\n  if (col != 0 && ew != 0)\n    (ret += f[ob][eb][ow][ew - 1] * pw[ow + ew - 1 + eb] % M * od[ob] % M) %= M;\n  if (col != 0 && ow != 0)\n    (ret += f[ob][eb][ow - 1][ew] * pw[ow + ew - 1 + eb] % M * ev[ob] % M) %= M;\n  if (col != 1 && eb != 0)\n    (ret += f[ob][eb - 1][ow][ew] * pw[ob + eb - 1 + ew] % M * od[ow] % M) %= M;\n  if (col != 1 && ob != 0)\n    (ret += f[ob - 1][eb][ow][ew] * pw[ob - 1 + eb + ew] % M * ev[ow] % M) %= M;\n  return;\n}\nint main() {\n  init();\n  scanf(\"%d%d\", &n, &p);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", c + i);\n  for (int i = 1; i <= n; i++)\n    for (int ob = 0; ob <= i; ob++)\n      for (int eb = 0; ob + eb <= i; eb++)\n        for (int ow = 0; ob + eb + ow <= i; ow++) {\n          int ew = i - ob - eb - ow;\n          find_ans(ob, eb, ow, ew, c[i], f[ob][eb][ow][ew]);\n          if (i == n && ((ob + ow) & 1) == p) (ans += f[ob][eb][ow][ew]) %= M;\n        }\n  printf(\"%I64d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nint n, p, c[51], bin[51], f[51][51][51][51];\ninline void add(int &x, int y) { (x += y) >= mod ? x -= mod : 0; }\nint main() {\n  register int i, j, k, s, tmp;\n  scanf(\"%d%d\", &n, &p);\n  for (i = 1; i <= n; i++) scanf(\"%d\", &c[i]);\n  bin[0] = 1;\n  for (i = 1; i <= 50; i++) bin[i] = 2ll * bin[i - 1] % mod;\n  if (c[1] == -1 || c[1] == 0) f[1][1][0][0] = 1;\n  if (c[1] == -1 || c[1] == 1) f[1][0][0][1] = 1;\n  for (i = 1; i < n; i++) {\n    for (j = 0; j <= i; j++)\n      for (k = 0; k <= i - j; k++)\n        for (s = 0; s <= i - j - k; s++)\n          if (f[i][j][k][s]) {\n            tmp = f[i][j][k][s];\n            if (c[i + 1] == -1 || c[i + 1] == 0) {\n              if (s) add(f[i + 1][j][k + 1][s], 1ll * bin[i - 1] * tmp % mod);\n              add(f[i + 1][j + 1][k][s],\n                  1ll * (s ? bin[i - 1] : bin[i]) * tmp % mod);\n            }\n            if (c[i + 1] == -1 || c[i + 1] == 1) {\n              if (j) add(f[i + 1][j][k][s], 1ll * bin[i - 1] * tmp % mod);\n              add(f[i + 1][j][k][s + 1],\n                  1ll * (j ? bin[i - 1] : bin[i]) * tmp % mod);\n            }\n          }\n  }\n  int ans = 0;\n  for (j = 0; j <= n; j++)\n    for (k = 0; k <= n - j; k++)\n      for (s = 0; s <= n - j - k; s++)\n        if ((j + s) % 2 == p) add(ans, f[n][j][k][s]);\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 200005;\nconst int kcz = 1000000007;\nlong long f[2][2][2][2], p2[maxn];\nint cur;\nint main() {\n  int n, p, i, c, j, k, l;\n  long long ans;\n  scanf(\"%d%d\", &n, &p);\n  for (p2[0] = 1, i = 1; i <= n; i++) p2[i] = (p2[i - 1] << 1) % kcz;\n  cur = 0, memset(f[cur], 0, sizeof(f[cur])), f[cur][0][0][0] = 1;\n  for (i = 0; i < n; i++) {\n    cur ^= 1, memset(f[cur], 0, sizeof(f[cur]));\n    scanf(\"%d\", &c);\n    for (j = 0; j <= 1; j++)\n      for (k = 0; k <= 1; k++)\n        for (l = 0; l <= 1; l++) {\n          if (c != 1) {\n            (f[cur][1][k][l ^ 1] += f[cur ^ 1][j][k][l] * p2[k ? i - 1 : i]) %=\n                kcz;\n            if (k) (f[cur][j][k][l] += f[cur ^ 1][j][k][l] * p2[i - 1]) %= kcz;\n          }\n          if (c != 0) {\n            (f[cur][j][1][l ^ 1] += f[cur ^ 1][j][k][l] * p2[j ? i - 1 : i]) %=\n                kcz;\n            if (j) (f[cur][j][k][l] += f[cur ^ 1][j][k][l] * p2[i - 1]) %= kcz;\n          }\n        }\n  }\n  ans = 0;\n  for (i = 0; i <= 1; i++)\n    for (j = 0; j <= 1; j++) ans += f[cur][i][j][p];\n  printf(\"%lld\\n\", ans %= kcz);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 55, MOD = 1E9 + 7;\nint n, p, c[N];\nlong long ans = 0, pw[N], f[N][N][N][N];\nvoid init() {\n  f[0][0][0][0] = 1;\n  pw[0] = 1;\n  for (int i = 1; i < N; i++) pw[i] = pw[i - 1] * 2 % MOD;\n}\nvoid find_ans(int ob, int eb, int ow, int ew, int col, long long &ret) {\n  if (col != 0 && ew != 0)\n    (ret += f[ob][eb][ow][ew - 1] * pw[ow + ew - 1 + eb] % MOD *\n            (ob ? pw[ob - 1] : 0) % MOD) %= MOD;\n  if (col != 0 && ow != 0)\n    (ret += f[ob][eb][ow - 1][ew] * pw[ow - 1 + ew + eb] % MOD *\n            (ob ? pw[ob - 1] : 1) % MOD) %= MOD;\n  if (col != 1 && eb != 0)\n    (ret += f[ob][eb - 1][ow][ew] * pw[ob + eb - 1 + ew] % MOD *\n            (ow ? pw[ow - 1] : 0) % MOD) %= MOD;\n  if (col != 1 && ob != 0)\n    (ret += f[ob - 1][eb][ow][ew] * pw[ob - 1 + eb + ew] % MOD *\n            (ow ? pw[ow - 1] : 1) % MOD) %= MOD;\n}\nint main() {\n  init();\n  scanf(\"%d%d\", &n, &p);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", c + i);\n  for (int i = 1; i <= n; i++)\n    for (int ob = 0; ob <= i; ob++)\n      for (int eb = 0; ob + eb <= i; eb++)\n        for (int ow = 0; ob + eb + ow <= i; ow++) {\n          int ew = i - ob - eb - ow;\n          find_ans(ob, eb, ow, ew, c[i], f[ob][eb][ow][ew]);\n          if (i == n && ((ob + ow) & 1) == p) (ans += f[ob][eb][ow][ew]) %= MOD;\n        }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        }
    ]
}