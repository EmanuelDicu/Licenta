{
    "name": "459_C. Pashmak and Buses",
    "source": "CODEFORCES",
    "description": "Recently Pashmak has been employed in a transportation company. The company has k buses and has a contract with a school which has n students. The school planned to take the students to d different places for d days (each day in one place). Each day the company provides all the buses for the trip. Pashmak has to arrange the students in the buses. He wants to arrange the students in a way that no two students become close friends. In his ridiculous idea, two students will become close friends if and only if they are in the same buses for all d days.\n\nPlease help Pashmak with his weird idea. Assume that each bus has an unlimited capacity.\n\nInput\n\nThe first line of input contains three space-separated integers n, k, d (1 \u2264 n, d \u2264 1000; 1 \u2264 k \u2264 109).\n\nOutput\n\nIf there is no valid arrangement just print -1. Otherwise print d lines, in each of them print n integers. The j-th integer of the i-th line shows which bus the j-th student has to take on the i-th day. You can assume that the buses are numbered from 1 to k.\n\nExamples\n\nInput\n\n3 2 2\n\n\nOutput\n\n1 1 2 \n1 2 1 \n\n\nInput\n\n3 2 1\n\n\nOutput\n\n-1\n\nNote\n\nNote that two students become close friends only if they share a bus each day. But the bus they share can differ from day to day.",
    "difficulty": "C",
    "tags": [
        "combinatorics",
        "constructive algorithms",
        "math"
    ],
    "rating": 1900,
    "public_test": [
        {
            "input": "3 2 2\n",
            "output": "1 2 1\n1 1 2\n"
        },
        {
            "input": "3 2 1\n",
            "output": "-1\n"
        }
    ],
    "generated_test": [
        {
            "input": "512 9 3\n",
            "output": "1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 \n1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 9 9 9 9 9 9 9 9 9 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 9 9 9 9 9 9 9 9 9 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 9 9 9 9 9 9 9 9 9 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 9 9 9 9 9 9 9 9 9 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 9 9 9 9 9 9 9 9 9 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 9 9 9 9 9 9 9 9 9 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 \n"
        },
        {
            "input": "222 9 3\n",
            "output": "1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 \n1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 9 9 9 9 9 9 9 9 9 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 9 9 9 9 9 9 9 9 9 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 \n"
        },
        {
            "input": "4 3 2\n",
            "output": "1 2 3 1 \n1 1 1 2 \n"
        },
        {
            "input": "197 3 6\n",
            "output": "1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 \n1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 \n1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n"
        },
        {
            "input": "1000 941 1\n",
            "output": "-1\n"
        },
        {
            "input": "1 2 2\n",
            "output": "1 \n1 \n"
        },
        {
            "input": "56 3 4\n",
            "output": "1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 \n1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 \n1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 \n"
        },
        {
            "input": "27 5 3\n",
            "output": "1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 \n1 1 1 1 1 2 2 2 2 2 3 3 3 3 3 4 4 4 4 4 5 5 5 5 5 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 \n"
        },
        {
            "input": "1000 3 8\n",
            "output": "1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 \n1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 \n1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n"
        },
        {
            "input": "1 1 3\n",
            "output": "1 \n1 \n1 \n"
        },
        {
            "input": "343 9 3\n",
            "output": "1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 \n1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 9 9 9 9 9 9 9 9 9 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 9 9 9 9 9 9 9 9 9 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 9 9 9 9 9 9 9 9 9 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 9 9 9 9 9 9 9 9 9 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 \n"
        },
        {
            "input": "115 2 9\n",
            "output": "1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 \n1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 \n1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 \n1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n"
        },
        {
            "input": "1 3 1\n",
            "output": "1 \n"
        },
        {
            "input": "18 3 5\n",
            "output": "1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 \n1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 \n1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n"
        },
        {
            "input": "1 1001000000 512\n",
            "output": "1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n1 \n"
        },
        {
            "input": "168 3 6\n",
            "output": "1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 \n1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 \n1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n"
        },
        {
            "input": "1000 1382 1\n",
            "output": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 \n"
        },
        {
            "input": "1 1000000000 4\n",
            "output": "1 \n1 \n1 \n1 \n"
        },
        {
            "input": "60 3 4\n",
            "output": "1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 \n1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 \n1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 \n"
        },
        {
            "input": "27 5 5\n",
            "output": "1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 \n1 1 1 1 1 2 2 2 2 2 3 3 3 3 3 4 4 4 4 4 5 5 5 5 5 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n"
        },
        {
            "input": "80 3 5\n",
            "output": "1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 \n1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 \n1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n"
        },
        {
            "input": "155 2 9\n",
            "output": "1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 \n1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 \n1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 \n1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 2 2 2 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n"
        },
        {
            "input": "18 3 4\n",
            "output": "1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 \n1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 \n1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n"
        },
        {
            "input": "3 3 1\n",
            "output": "1 2 3 \n"
        },
        {
            "input": "155 3 9\n",
            "output": "1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 \n1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 \n1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n"
        },
        {
            "input": "18 4 4\n",
            "output": "1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 \n1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n"
        },
        {
            "input": "100 3 6\n",
            "output": "1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 \n1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 \n1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n"
        },
        {
            "input": "8 4 4\n",
            "output": "1 2 3 4 1 2 3 4 \n1 1 1 1 2 2 2 2 \n1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 \n"
        },
        {
            "input": "100 5 6\n",
            "output": "1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 \n1 1 1 1 1 2 2 2 2 2 3 3 3 3 3 4 4 4 4 4 5 5 5 5 5 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3 4 4 4 4 4 5 5 5 5 5 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3 4 4 4 4 4 5 5 5 5 5 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3 4 4 4 4 4 5 5 5 5 5 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n"
        },
        {
            "input": "8 4 5\n",
            "output": "1 2 3 4 1 2 3 4 \n1 1 1 1 2 2 2 2 \n1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 \n"
        },
        {
            "input": "80 2 7\n",
            "output": "1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 \n1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 \n1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 \n1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 \n"
        },
        {
            "input": "110 2 7\n",
            "output": "1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 \n1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1 1 \n1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 1 1 1 1 2 2 \n1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 2 2 2 2 2 2 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 \n"
        },
        {
            "input": "101 3 6\n",
            "output": "1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 \n1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 \n1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n"
        },
        {
            "input": "101 4 6\n",
            "output": "1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 \n1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 1 1 1 1 2 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n"
        },
        {
            "input": "263 3 6\n",
            "output": "1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 \n1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 \n1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 \n"
        },
        {
            "input": "101 8 6\n",
            "output": "1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 \n1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 5 5 5 5 5 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n"
        },
        {
            "input": "323 3 6\n",
            "output": "1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 \n1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 \n1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 \n"
        },
        {
            "input": "323 4 6\n",
            "output": "1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 \n1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n"
        },
        {
            "input": "513 3 9\n",
            "output": "1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 \n1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 \n1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n"
        },
        {
            "input": "729 13 3\n",
            "output": "1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 2 3 4 5 6 7 8 9 10 11 12 13 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 8 8 8 8 9 9 9 9 9 9 9 9 9 9 9 9 9 10 10 10 10 10 10 10 10 10 10 10 10 10 11 11 11 11 11 11 11 11 11 11 11 11 11 12 12 12 12 12 12 12 12 12 12 12 12 12 13 13 13 13 13 13 13 13 13 13 13 13 13 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 8 8 8 8 9 9 9 9 9 9 9 9 9 9 9 9 9 10 10 10 10 10 10 10 10 10 10 10 10 10 11 11 11 11 11 11 11 11 11 11 11 11 11 12 12 12 12 12 12 12 12 12 12 12 12 12 13 13 13 13 13 13 13 13 13 13 13 13 13 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 8 8 8 8 9 9 9 9 9 9 9 9 9 9 9 9 9 10 10 10 10 10 10 10 10 10 10 10 10 10 11 11 11 11 11 11 11 11 11 11 11 11 11 12 12 12 12 12 12 12 12 12 12 12 12 12 13 13 13 13 13 13 13 13 13 13 13 13 13 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 8 8 8 8 9 9 9 9 9 9 9 9 9 9 9 9 9 10 10 10 10 10 10 10 10 10 10 10 10 10 11 11 11 11 11 11 11 11 11 11 11 11 11 12 12 12 12 12 12 12 12 12 12 12 12 12 13 13 13 13 13 13 13 13 13 13 13 13 13 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 5 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 \n"
        },
        {
            "input": "1000 999 2\n",
            "output": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 \n"
        },
        {
            "input": "81 3 5\n",
            "output": "1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 \n1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 \n1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n"
        },
        {
            "input": "1 1000000000 2\n",
            "output": "1 \n1 \n"
        },
        {
            "input": "625 2 4\n",
            "output": "-1\n"
        },
        {
            "input": "266 3 5\n",
            "output": "-1\n"
        },
        {
            "input": "146 3 4\n",
            "output": "-1\n"
        },
        {
            "input": "2 1 2\n",
            "output": "-1\n"
        },
        {
            "input": "1 3 2\n",
            "output": "1 \n1 \n"
        },
        {
            "input": "3 1 1\n",
            "output": "-1\n"
        },
        {
            "input": "730 9 3\n",
            "output": "-1\n"
        },
        {
            "input": "222 9 1\n",
            "output": "-1\n"
        },
        {
            "input": "4 3 1\n",
            "output": "-1\n"
        },
        {
            "input": "772 2 4\n",
            "output": "-1\n"
        },
        {
            "input": "101 3 4\n",
            "output": "-1\n"
        },
        {
            "input": "2 1 3\n",
            "output": "-1\n"
        },
        {
            "input": "1 6 2\n",
            "output": "1 \n1 \n"
        },
        {
            "input": "3 1 3\n",
            "output": "-1\n"
        },
        {
            "input": "1 6 4\n",
            "output": "1 \n1 \n1 \n1 \n"
        },
        {
            "input": "6 1 1\n",
            "output": "-1\n"
        },
        {
            "input": "730 4 3\n",
            "output": "-1\n"
        },
        {
            "input": "1 1100000000 2\n",
            "output": "1 \n1 \n"
        },
        {
            "input": "60 1 4\n",
            "output": "-1\n"
        },
        {
            "input": "168 2 4\n",
            "output": "-1\n"
        },
        {
            "input": "80 3 3\n",
            "output": "-1\n"
        },
        {
            "input": "100 3 4\n",
            "output": "-1\n"
        },
        {
            "input": "7 1 1\n",
            "output": "-1\n"
        },
        {
            "input": "699 4 3\n",
            "output": "-1\n"
        },
        {
            "input": "1 1100000000 4\n",
            "output": "1 \n1 \n1 \n1 \n"
        },
        {
            "input": "44 2 4\n",
            "output": "-1\n"
        },
        {
            "input": "80 2 3\n",
            "output": "-1\n"
        },
        {
            "input": "155 1 9\n",
            "output": "-1\n"
        },
        {
            "input": "5 1 1\n",
            "output": "-1\n"
        },
        {
            "input": "44 2 5\n",
            "output": "-1\n"
        },
        {
            "input": "80 2 4\n",
            "output": "-1\n"
        },
        {
            "input": "155 1 7\n",
            "output": "-1\n"
        },
        {
            "input": "76 2 5\n",
            "output": "-1\n"
        },
        {
            "input": "80 2 6\n",
            "output": "-1\n"
        },
        {
            "input": "100 1 6\n",
            "output": "-1\n"
        },
        {
            "input": "93 1 7\n",
            "output": "-1\n"
        },
        {
            "input": "8 4 1\n",
            "output": "-1\n"
        },
        {
            "input": "76 2 4\n",
            "output": "-1\n"
        },
        {
            "input": "100 1 4\n",
            "output": "-1\n"
        },
        {
            "input": "24 1 7\n",
            "output": "-1\n"
        },
        {
            "input": "149 2 4\n",
            "output": "-1\n"
        },
        {
            "input": "157 2 7\n",
            "output": "-1\n"
        },
        {
            "input": "100 2 4\n",
            "output": "-1\n"
        },
        {
            "input": "263 2 4\n",
            "output": "-1\n"
        },
        {
            "input": "100 2 6\n",
            "output": "-1\n"
        },
        {
            "input": "263 4 4\n",
            "output": "-1\n"
        },
        {
            "input": "110 1 7\n",
            "output": "-1\n"
        },
        {
            "input": "101 2 6\n",
            "output": "-1\n"
        },
        {
            "input": "263 3 4\n",
            "output": "-1\n"
        },
        {
            "input": "110 1 4\n",
            "output": "-1\n"
        },
        {
            "input": "263 3 3\n",
            "output": "-1\n"
        },
        {
            "input": "110 1 3\n",
            "output": "-1\n"
        },
        {
            "input": "110 1 2\n",
            "output": "-1\n"
        },
        {
            "input": "010 1 2\n",
            "output": "-1\n"
        },
        {
            "input": "111 1 3\n",
            "output": "-1\n"
        },
        {
            "input": "323 1 6\n",
            "output": "-1\n"
        },
        {
            "input": "101 1 3\n",
            "output": "-1\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T, size_t N>\nint SIZE(const T (&t)[N]) {\n  return N;\n}\ntemplate <typename T>\nint SIZE(const T &t) {\n  return t.size();\n}\nstring to_string(const string s, int x1 = 0, int x2 = 1e9) {\n  return '\"' + ((x1 < s.size()) ? s.substr(x1, x2 - x1 + 1) : \"\") + '\"';\n}\nstring to_string(const char *s) { return to_string((string)s); }\nstring to_string(const bool b) { return (b ? \"true\" : \"false\"); }\nstring to_string(const char c) { return string({c}); }\ntemplate <size_t N>\nstring to_string(const bitset<N> &b, int x1 = 0, int x2 = 1e9) {\n  string t = \"\";\n  for (int __iii__ = min(x1, SIZE(b)), __jjj__ = min(x2, SIZE(b) - 1);\n       __iii__ <= __jjj__; ++__iii__) {\n    t += b[__iii__] + '0';\n  }\n  return '\"' + t + '\"';\n}\ntemplate <typename A, typename... C>\nstring to_string(const A(&v), int x1 = 0, int x2 = 1e9, C... coords);\nint l_v_l_v_l = 0, t_a_b_s = 0;\ntemplate <typename A, typename B>\nstring to_string(const pair<A, B> &p) {\n  l_v_l_v_l++;\n  string res = \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n  l_v_l_v_l--;\n  return res;\n}\ntemplate <typename A, typename... C>\nstring to_string(const A(&v), int x1, int x2, C... coords) {\n  int rnk = rank<A>::value;\n  string tab(t_a_b_s, ' ');\n  string res = \"\";\n  bool first = true;\n  if (l_v_l_v_l == 0) res += '\\n';\n  res += tab + \"[\";\n  x1 = min(x1, SIZE(v)), x2 = min(x2, SIZE(v));\n  auto l = begin(v);\n  advance(l, x1);\n  auto r = l;\n  advance(r, (x2 - x1) + (x2 < SIZE(v)));\n  for (auto e = l; e != r; e = next(e)) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    l_v_l_v_l++;\n    if (e != l) {\n      if (rnk > 1) {\n        res += '\\n';\n        t_a_b_s = l_v_l_v_l;\n      };\n    } else {\n      t_a_b_s = 0;\n    }\n    res += to_string(*e, coords...);\n    l_v_l_v_l--;\n  }\n  res += \"]\";\n  if (l_v_l_v_l == 0) res += '\\n';\n  return res;\n}\nvoid dbgm() { ; }\ntemplate <typename Heads, typename... Tails>\nvoid dbgm(Heads H, Tails... T) {\n  cerr << to_string(H) << \" | \";\n  dbgm(T...);\n}\nbool flag = true;\nint n, k, d;\nbool can() {\n  if (n <= k) return 1;\n  if (k == 1) {\n    if (n == 1)\n      return 1;\n    else\n      return 0;\n  }\n  int t = 1;\n  for (int i = 0; i <= d; i++) {\n    if (n <= t) return 1;\n    t = t * k;\n  }\n  return 0;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k >> d;\n  if (!can()) {\n    flag = false;\n  }\n  if (flag) {\n    vector<vector<int>> ans(d, vector<int>(n));\n    for (int i = 0; i < n; i++) {\n      int nw = i + 1;\n      for (int j = 0; j < d; j++) {\n        ans[j][i] = nw % k;\n        nw /= k;\n      }\n    }\n    for (int i = 0; i < d; i++) {\n      for (int j = 0; j < n; j++) {\n        cout << ans[i][j] + 1 << \" \";\n      }\n      cout << endl;\n    }\n  } else {\n    cout << -1 << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class C {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tArrayList<int[]> list;\n\tint n, k, d;\n\n\tvoid run() {\n\t\tn = sc.nextInt();\n\t\tk = sc.nextInt();\n\t\td = sc.nextInt();\n\t\tlist = new ArrayList<int[]>();\n\t\tint tmp = 1;\n\t\tboolean ok = false;\n\t\tfor (int i = 0; i < d; i++) {\n\t\t\ttmp *= k;\n\t\t\tif (tmp >= n) {\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!ok) {\n\t\t\tSystem.out.println(-1);\n\t\t\treturn;\n\t\t}\n\t\tgen(0, new int[d]);\n\t\tStringBuilder out = new StringBuilder();\n\t\tfor (int i = 0; i < d; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tout.append(list.get(j)[i] + \" \");\n\t\t\t}\n\t\t\tout.append(\"\\n\");\n\t\t}\n\t\tSystem.out.print(out);\n\t}\n\n\tvoid gen(int depth, int a[]) {\n\t\tif (depth == d) {\n\t\t\tint[] add = a.clone();\n\t\t\tlist.add(add);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tif (list.size() >= n) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ta[depth] = i;\n\t\t\tgen(depth + 1, a);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew C().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 1,
            "solution": "from math import log\n\n[n, k, d] = map(int, raw_input().split(\" \"))\nif d == 1 and n > 1 and k < n:\n    print \"-1\"\nelif d == 1 and n == 1:\n    print \"1\"\nelse:\n    out = [[0 for i in range(d)] for j in range(n)]\n    if k**d < n:\n        print \"-1\"\n    else:\n        if k > 1000:\n            k = 1000\n        start = 0\n        for nn in range(n):\n            istart = start\n            for dd in range(d):\n                out[nn][dd] = (istart%k)+1 \n                istart = istart / k\n            start = start + 1\n                \n        for dd in range(d):\n            for nn in range(n):\n                print out[nn][dd],\n            print \"\""
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint n, k, d, tot, a[1010], ans[1010][1010];\nvoid tr(int x) {\n  if (x > d) {\n    ++tot;\n    for (int i = 1; i <= d; ++i) ans[i][tot] = a[i];\n    return;\n  }\n  for (int i = 1; i <= k; ++i) {\n    a[x] = i;\n    tr(x + 1);\n    if (tot >= n) return;\n  }\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &d);\n  tr(1);\n  if (tot < n)\n    printf(\"-1\\n\");\n  else {\n    for (int i = 1; i <= d; ++i) {\n      for (int j = 1; j <= n; ++j) {\n        printf(\"%d\", ans[i][j]);\n        if (j == n)\n          printf(\"\\n\");\n        else\n          printf(\" \");\n      }\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn = 1005;\nint n, k, d;\nint res[Maxn][Maxn];\nbool Check(int n, int k, int d) {\n  long long cur = 1;\n  while (cur < n && d) {\n    cur *= k;\n    d--;\n  }\n  return n <= cur;\n}\nvoid Solve(int num) {\n  int j = num;\n  for (int i = d - 1; i >= 0; i--) {\n    int cur = num % k + 1;\n    res[i][j] = cur;\n    num /= k;\n  }\n}\nint main() {\n  scanf(\"%d %d %d\", &n, &k, &d);\n  if (Check(n, k, d)) {\n    for (int i = 0; i < n; i++) Solve(i);\n    for (int i = 0; i < d; i++)\n      for (int j = 0; j < n; j++)\n        printf(\"%d%c\", res[i][j], j + 1 < n ? ' ' : '\\n');\n  } else\n    printf(\"-1\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int MAXN = 1001;\nint ans[MAXN][MAXN];\nvoid solve() {\n  int n, k, d;\n  cin >> n >> k >> d;\n  bool possible = false;\n  int vv = 1;\n  for (int i = 1; i <= d; ++i) {\n    vv *= k;\n    if (vv >= n) {\n      possible = true;\n      break;\n    }\n  }\n  if (!possible) {\n    cout << -1 << endl;\n    return;\n  }\n  for (int i = 1; i < n; ++i) {\n    for (int j = 0; j < d; ++j) {\n      ans[i][j] = ans[i - 1][j];\n    }\n    for (int j = d - 1; j >= 0; --j) {\n      ans[i][j]++;\n      ans[i][j] %= k;\n      if (ans[i][j]) break;\n    }\n  }\n  for (int i = 0; i < d; ++i) {\n    for (int j = 0; j < n; ++j) {\n      cout << ans[j][i] + 1 << \" \";\n    }\n    cout << endl;\n  }\n}\nint main() {\n  int t = 1;\n  while (t--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "# by the authority of GOD     author: manhar singh sachdev #\n\nimport os,sys\nfrom io import BytesIO, IOBase\n\ndef base(x,k,d):\n    ans = []\n    while x:\n        ans.append(x%k+1)\n        x //= k\n    ans.reverse()\n    return [1]*(d-len(ans))+ans\n\ndef main():\n    n,k,d = map(int,input().split())\n    if n == 1:\n        for _ in range(d):\n            print(1)\n        exit()\n    if k == 1 or (d <= 10 and n > pow(k,d)):\n        print(-1)\n        exit()\n    arr = [base(x,k,d) for x in range(n)]\n    ans = [[0]*n for _ in range(d)]\n    for i in range(n):\n        for j in range(d):\n            ans[j][i] = arr[i][j]\n    for i in ans:\n        print(*i)\n\n# Fast IO Region\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nif __name__ == \"__main__\":\n    main()"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class CodeForces {\n\n\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        int d = sc.nextInt();\n\n        int[][] arrangement = new int[n][d];\n\n\n            for (int j =0; j <d; j++) {\n\n                arrangement[0][j]=1;\n\n            }\n            //System.out.println();\n\n        if(n>Math.pow(k,d)){\n            System.out.println(-1);\n        }\n\n        else{\n\n           // int p = 1;\n\n            for(int i=1;i<n;i++){\n\n                for(int l=0;l<d;l++){\n                    arrangement[i][l]=arrangement[i-1][l];\n                }\n\n                for(int j=d-1;j>=0;j--){\n\n                   while(arrangement[i][j]==k){\n                       j--;\n                   }\n\n                   //System.out.println(j);\n\n                   if(j<0){\n                       break;\n                   }\n\n                   arrangement[i][j] =arrangement[i][j]+1;\n\n                   for(int l=j+1;l<d;l++){\n                       arrangement[i][l]=1;\n                   }\n\n                   break;\n\n                }\n\n            }\n\n            StringBuilder ans = new StringBuilder(\"\");\n\n            for(int i=0;i<d;i++) {\n                for (int j =0; j <n; j++) {\n\n                    ans.append(arrangement[j][i]+\" \");\n\n                }\n                ans.append('\\n');\n            }\n\n            System.out.println(ans);\n\n\n\n        }\n\n\n    }\n\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mod = 1e9 + 7;\nlong long cl(long double a) {\n  if (a > (long long)a) {\n    return (long long)a + 1;\n  } else {\n    return (long long)a;\n  }\n}\nlong long flr(long double a) { return (long long)a; }\nconst long long M = 1010;\nlong long ans[M][M];\nvoid solve() {\n  long long n, k, d;\n  cin >> n;\n  cin >> k;\n  cin >> d;\n  long long pos = 1;\n  bool flag = false;\n  for (long long i = 0; i < d; i++) {\n    pos *= k;\n    if (pos >= n) {\n      flag = true;\n      break;\n    }\n  }\n  if (!flag) {\n    cout << -1 << \"\\n\";\n    return;\n  }\n  long long op;\n  long long f = 1;\n  for (long long i = 0; i < n; i++) {\n    op = f;\n    for (long long j = 0; j < d; j++) {\n      ans[i][j] = op % k;\n      op /= k;\n    }\n    f++;\n  }\n  for (long long j = 0; j < d; j++) {\n    for (long long i = 0; i < n; i++) {\n      cout << ans[i][j] + 1 << \" \";\n    }\n    cout << \"\\n\";\n  }\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long t;\n  t = 1;\n  while (t--) solve();\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n \npublic class Main {\n\n    public void solve() throws IOException{\n\n        long n = in.nextLong();\n        long k = in.nextLong();\n        long d = in.nextLong();\n\n\n        if(!check(n, k, d)){\n\n            out.println(-1);\n            return;\n\n        }else{\n            List<int[]> res = new ArrayList<>();\n            int[] arr = new int[(int) d];\n            Arrays.fill(arr, 1);\n\n            for(int i = 0; i < n; i++){\n                res.add(arr);\n                int[] arrNew = Arrays.copyOf(arr, arr.length);\n                inc(arrNew, k); \n                arr = arrNew;\n            }\n\n            for(int i = 0; i < d; i++){\n                for(int j = 0; j < n; j++){\n                    out.print(res.get(j)[i] + \" \");\n                }\n                out.println();\n            }\n\n\n        }\n    }\n\n    public void inc(int[] arr, long k){\n\n        int n = arr.length;\n        arr[n - 1]++;\n        int i = n - 1;\n        while(i != 0){\n\n            if(arr[i] == k + 1){\n                arr[i - 1]++;\n                arr[i] = 1;\n            }\n            i--;\n        }        \n\n        return;\n    }\n\n    public boolean check(long n, long k, long d){\n\n        long num = 1;\n        while(num < n && d != 0){\n            num *= k;\n            d--;\n        }\n\n        return num >= n;\n    }\n\n\n\n    public BigInteger gcdBigInt(BigInteger a, BigInteger b){\n\n        if(a.compareTo(BigInteger.valueOf(0L)) == 0){\n            return b;\n        }else{\n            return gcdBigInt(b.mod(a), a);\n        }\n\n    }\n\n \n    FastScanner in;\n    PrintWriter out;\n \n    static class FastScanner {\n \n        BufferedReader br;\n        StringTokenizer st;\n \n        FastScanner(InputStream in) {\n            br = new BufferedReader(new InputStreamReader(in));\n            st = null;\n        }\n \n        String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n \n        String nextLine() throws IOException {\n            if (st == null || !st.hasMoreTokens())\n                return br.readLine();\n            StringBuilder result = new StringBuilder(st.nextToken());\n            while (st.hasMoreTokens()) {\n                result.append(\" \");\n                result.append(st.nextToken());\n            }\n            return result.toString();\n        }\n \n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n \n        long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n \n        double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n \n    }\n \n    void run() throws IOException {\n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out, false);\n        solve();\n        out.close();\n    }\n \n    public static void main(String[] args) throws IOException{\n        new Main().run();\n    }\n \n    public void printArr(int[] arr){\n        for(int i = 0; i < arr.length; i++){\n            out.print(arr[i] + \" \");\n        }\n        out.println();\n    }\n \n    public long gcd(long a, long b){\n        if(a == 0) return b;\n        return gcd(b % a, a);\n    }\n\n    public boolean isPrime(long num){\n\n        if(num == 0 || num == 1){\n            return false;\n        }\n\n        for(int i = 2; i * i <= num; i++){\n            if(num % i == 0){\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public class Pair<A, B>{\n        public A x; \n        public B y;\n\n        Pair(A x, B y){\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Pair<?, ?> pair = (Pair<?, ?>) o;\n            if (!x.equals(pair.x)) return false;\n            return y.equals(pair.y);\n        }\n\n        @Override\n        public int hashCode() {\n            int result = x.hashCode();\n            result = 31 * result + y.hashCode();\n            return result;\n        }\n\n    }\n\n    class Tuple{\n        int x; int y; int z;\n        Tuple(int ix, int iy, int iz){\n            x = ix;\n            y = iy;\n            z = iz;\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint ans[1010][1010];\nint main() {\n  ios_base::sync_with_stdio(0);\n  int n, k, d;\n  cin >> n >> k >> d;\n  long long tmp = 1;\n  bool check = false;\n  for (int i = 0; i < d; i++) {\n    tmp *= k;\n    if (tmp >= n) {\n      check = 1;\n      break;\n    }\n  }\n  if (!check) {\n    cout << -1 << '\\n';\n    return 0;\n  }\n  for (int i = 1; i < n; i++) {\n    for (int j = 0; j < d; j++) {\n      ans[i][j] = ans[i - 1][j];\n    }\n    for (int j = d - 1; j >= 0; j--) {\n      ans[i][j] = (ans[i][j] + 1) % k;\n      if (ans[i][j]) break;\n    }\n  }\n  for (int i = 0; i < d; i++) {\n    for (int j = 0; j < n; j++) {\n      cout << ans[j][i] + 1 << ' ';\n    }\n    cout << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint ans[1005][1005];\nint main() {\n  long long n, k, d;\n  cin >> n >> k >> d;\n  long long l = 1, f = 1;\n  for (int i = 1; i <= d; i++) {\n    l *= k;\n    if (l >= n) {\n      f = 0;\n      break;\n    }\n  }\n  if (f) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n  for (int i = 0; i < n; i++) {\n    int p = i, j = 0;\n    while (p > 0) {\n      ans[j++][i] = p % k;\n      p /= k;\n    }\n  }\n  for (int i = 0; i < d; i++) {\n    for (int j = 0; j < n; j++) {\n      cout << ans[i][j] + 1 << \" \";\n    }\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\t\n\n\tpublic static void main(String[] args) throws IOException{\n\t\tScanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tint d = sc.nextInt();\n\n\t\tlong temp = 1L;\n\t\tfor(int i = 0; i < d; i++){\n\t\t\ttemp *= (long)k;\n\n\t\t\tif(temp >= n){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(n > temp){\n\t\t\tout.println(\"-1\");\n\t\t\tout.close();\n\t\t\treturn;\n\t\t}\n\n\t\tint[][] arr = new int[n][d];\n\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tfor(int j = 0; j < d; j++)\n\t\t\t\tarr[i][j] = arr[i - 1][j];\n\n\t\t\tfor(int j = d - 1; j >= 0; j--){\n\t\t\t\tarr[i][j] = (arr[i][j] + 1) % k;\n\n\t\t\t\tif(arr[i][j] != 0)\n\t\t\t\t\tbreak; \n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < d; i++){\n\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t\tout.print(arr[j][i]+1+\" \");\n\n\t\t\tout.println(\"\");\n\t\t}\n\n\t\tout.close();\n\t}\t\n}\n"
        },
        {
            "language": 1,
            "solution": "kids,buses,days = map(int,raw_input().split())\ntravel = []\nif buses**days < kids:\n    print '-1'\nelse:\n    k = 1\n    for i in range(days):\n        for j in range(kids):\n            travel.append((j/k)%buses + 1)\n        k *= buses\n        for j in travel:\n            print j,\n        travel = []\n        print"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint ans[1005][1005];\nint power(int a, int b) {\n  if (b == 0) return 1;\n  int p = power(a, b / 2);\n  if (b % 2 == 0)\n    return p * p;\n  else\n    return p * p * a;\n}\nint main() {\n  int n, k, d;\n  scanf(\"%d%d%d\", &n, &k, &d);\n  double tmp = pow(2, log2(n) / d);\n  int tk = (int)ceil((float)tmp);\n  if (tk > k) {\n    printf(\"-1\\n\");\n  } else {\n    k = tk;\n    for (int i = d - 1; i >= 0; i--) {\n      int change = power(k, (d - 1) - i);\n      int cnt = 0;\n      int print = 1;\n      for (int j = 0; j < n; j++) {\n        if (cnt == change) {\n          cnt = 0;\n          print = (print + 1) % k;\n          if (print == 0) print = k;\n        }\n        ans[i][j] = print;\n        cnt++;\n      }\n    }\n    for (int i = 0; i < d; i++) {\n      for (int j = 0; j < n; j++) printf(\"%d \", ans[i][j]);\n      printf(\"\\n\");\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long int n, d, k;\n  bool flag = 1;\n  cin >> n >> k >> d;\n  long long int tem = 1;\n  for (int i = 0; i < d; i++) {\n    tem *= k;\n    if (tem >= n) {\n      flag = 0;\n      break;\n    }\n  }\n  if (flag) {\n    cout << -1 << endl;\n    return 0;\n  }\n  vector<long long int> ans[n + 5];\n  for (long long int i = 0; i < n; i++) {\n    long long int num = i;\n    for (long long int j = 0; j < d; j++) {\n      ans[i].push_back(num % k + 1);\n      num /= k;\n    }\n  }\n  for (int i = 0; i < d; i++) {\n    for (int j = 0; j < n; j++) cout << ans[j][i] << \" \";\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import copy\n\ninp = list(map(int, input().split()))\nn, k, d = inp[0], inp[1], inp[2]\n\nc = 0\nans = []\ndef rec(arr):\n  global c\n  if c >= n: return\n  if len(arr) == d:\n    c += 1\n    ans.append(copy.deepcopy(arr))\n    return\n  temp = copy.deepcopy(arr)\n  temp.append(0)\n  for i in range(1, k + 1):\n    if c >= n:\n      break\n    temp[-1] = i\n    rec(temp)\n\nif (k**d < n):\n  print(-1)\nelse:\n  rec([])\n  a = [[0 for i in range(n)] for j in range(d)]\n  for i in range(n):\n    for j in range(d):\n      a[j][i] = ans[i][j]\n  for i in range(d):\n    print(*a[i])"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigDecimal;\nimport java.util.*;\n\npublic class ForcesC {\n\n\t\n\tpublic static class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\t//it reads the data about the specified point and divide the data about it ,it is quite fast\n\t\t//than using direct \n\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());//converts string to integer\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\n\n\tpublic static PrintWriter out = new PrintWriter (new BufferedOutputStream(System.out));\n\tstatic long mod = (long)(1e9+7);\n\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t\tFastReader sc = new FastReader();\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n\t     int d = sc.nextInt();\n\t     long pow = 1;\n\t     boolean yes = false;\n\t     for(int i=1;i<=d;++i) {\n\t    \t if(n<=pow*k) {\n\t    \t\t yes = true;\n\t    \t\t break;\n\t    \t }\n\t    \t pow*=k;\n\t     }\n\t     \n\t     if(yes) {\n\t    \t int[][] tab = new int[d+1][n+1];\n\t    \t for(int i=1;i<=d;++i) {\n\t    \t\t\t tab[i][1] = 1;\n\t    \t }\n\t    \t \n\t    \t for(int i=2;i<=n;++i) {\n\t    \t\t for(int j=1;j<=d;++j)\n\t    \t\t\t tab[j][i] = tab[j][i-1];\n\t    \t\t next(tab,i,d,k);\n\t    \t\t \n\t    \t }\n\t    \t \n\t    \t for(int i=1;i<=d;++i) {\n\t    \t\t for(int j=1;j<=n;++j) \n\t    \t\t\t out.print(tab[i][j]+\" \");\n\t    \t\t\t \n\t    \t\t out.println();\n\t    \t }\n\t    \t \n\t     }\n\t     else out.println(-1);\n\t    \n     out.close();\n\n    }\n static void next(int[][] tab, int i,int d, int k) {\n\t\tfor(int j=d;j>=0;--j) {\n\t\t\tif(tab[j][i]!=k) {\n\t\t\t\ttab[j][i]++;\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\ttab[j][i] = 1;\n\t\t}\n\t\t\n\t}\n\n    public class Pair {\n        int first = 0, second = 0;\n\n        public Pair (int x, int y) {\n            this.first = x;\n            this.second = y;\n        }\n\n    }\n\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long days[1000][1000];\nlong long n, k, d;\nint set_days(long long *cur, long long *prev) {\n  for (int i = 0; i < d; i++) {\n    cur[i] = prev[i];\n  }\n  for (int i = 0; i < d; i++) {\n    if (prev[i] < k - 1) {\n      cur[i] = prev[i] + 1;\n      break;\n    }\n    cur[i] = 0;\n  }\n  for (int i = 0; i < d; i++) {\n    if (cur[i] != 0) {\n      return 0;\n    }\n  }\n  return 1;\n}\nint main() {\n  cin >> n >> k >> d;\n  memset(days, 0, sizeof(days));\n  for (int i = 1; i < n; i++) {\n    int repeat = set_days(days[i], days[i - 1]);\n    if (repeat) {\n      printf(\"-1\\n\");\n      return 0;\n    }\n  }\n  for (int i = 0; i < d; i++) {\n    for (int j = 0; j < n; j++) {\n      if (j != 0) {\n        cout << \" \";\n      }\n      cout << days[j][i] + 1;\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int readInt() {\n  register int c = getchar();\n  int x = 0;\n  for (; (c < 48 || c > 57); c = getchar())\n    ;\n  for (; c > 47 && c < 58; c = getchar()) {\n    x = x * 10 + c - 48;\n  }\n  return x;\n}\nint main() {\n  int n, k, d;\n  cin >> n >> k >> d;\n  int ans[n][d];\n  for (int i = 0; i < int(n); i++) {\n    int t = i;\n    for (int j = 0; j < int(d); j++) {\n      ans[i][j] = t % k + 1;\n      t /= k;\n    }\n    if (t) {\n      cout << -1 << endl;\n      return 0;\n    }\n  }\n  for (int i = 0; i < int(d); i++) {\n    for (int j = 0; j < int(n); j++) {\n      cout << ans[j][i] << \" \";\n    }\n    cout << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1000 + 100;\nint n, d, k, cur;\nint a[maxn][maxn];\nint tianchong(int st, int ed, int cur) {\n  if (cur > d) {\n    return maxn;\n  }\n  int l = ed - st + 1;\n  if (l <= k) {\n    for (int i = st; i <= ed; i++) {\n      a[i][cur] = i - st + 1;\n    }\n    return 1;\n  }\n  int m = l / k;\n  if (l % k != 0) {\n    m++;\n  }\n  int ret = 0;\n  int i;\n  int cnt = 0;\n  for (i = st; i + m <= ed; i += m) {\n    cnt++;\n    ret = max(ret, tianchong(i, i + m - 1, cur + 1));\n    for (int j = i; j < i + m; j++) {\n      a[j][cur] = cnt;\n    }\n  }\n  cnt++;\n  if (i + m > ed && i <= ed) {\n    ret = max(ret, tianchong(i, ed, cur + 1));\n    for (int j = i; j <= ed; j++) {\n      a[j][cur] = cnt;\n    }\n  }\n  return ret + 1;\n}\nvoid print() {\n  for (int j = 1; j <= d; j++) {\n    for (int i = 1; i <= n; i++) {\n      if (i != 1) printf(\" \");\n      if (a[i][j])\n        printf(\"%d\", a[i][j]);\n      else\n        printf(\"1\");\n    }\n    printf(\"\\n\");\n  }\n  return;\n}\nint main() {\n  scanf(\"%d %d %d\", &n, &k, &d);\n  if (tianchong(1, n, 1) > d) {\n    printf(\"-1\\n\");\n  } else {\n    print();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint arr[2][1005];\nint main() {\n  int n, k, d, a, c = 1;\n  cin >> n >> k >> d;\n  a = n / k + (n % k != 0);\n  while (c <= d && a > 1) {\n    a = a / k + (a % k != 0);\n    c++;\n  }\n  if (c > d) {\n    puts(\"-1\");\n    return 0;\n  }\n  for (int i = 0; i < n; i++) {\n    arr[0][i] = i % k;\n    printf(\"%d \", arr[0][i] + 1);\n  }\n  puts(\"\");\n  int lim = n / k, indx;\n  bool t = 0;\n  for (int j = 1; j < d; j++) {\n    t = !t;\n    indx = 0;\n    for (int i = 0; i <= lim; i++) {\n      for (int ii = 0; ii < k && indx < n; ii++) arr[t][indx++] = arr[!t][i];\n    }\n    for (int i = 0; i < n; i++) printf(\"%d \", arr[t][i] + 1);\n    puts(\"\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/env python3\nfrom sys import stdin\nimport copy\n\ndef solve(tc):\n    n, k, d = map(int, stdin.readline().split())\n\n    ok = False\n    possibilities = 1\n    for i in range(d):\n        possibilities *= k\n        if possibilities>=n:\n            ok = True\n            break\n\n    if not ok:\n        print(-1)\n        return\n\n    mat = [[0 for i in range(n)] for j in range(d)]\n    for i in range(n):\n        num = i\n        p = 0\n        while p<d and num:\n            mat[p][i] = (num % k) + 1\n            num //= k\n            p += 1\n        for j in range(p, d):\n            mat[j][i] = mat[j][i] + 1\n\n    for i in range(d):\n        print(' '.join(map(lambda x : str(x), mat[i])))\n\ntc = 1\nsolve(tc)\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n//package codeforces;\n\n/**\n *\n * @author Pankaj Birat\n */\npublic class Pashmak_and_Buses {\n    static int mat[][] = new int[1005][1005];\n   \n    \n    private static PrintWriter out;\n    \n    public static void main(String[] args) {\n         //PrintWriter out;\n        out = new PrintWriter(System.out);\n        \n        boolean vis[] = new boolean[1111];\n        \n        Scanner scan = new Scanner(System.in);\n        int n = scan.nextInt();\n        int k = scan.nextInt();\n        int d = scan.nextInt();\n        int p = 1;\n        for(int i = 0; i < d; i++) {\n            p = p * k;\n            if(p >= n)break;\n        }\n        if(p < n) {\n            System.out.println(\"-1\");\n        }\n        else {\n            for(int i = 1; i <= d; i++) mat[1][i] = 0;\n            for(int i = 2; i <= n; i++) {\n                for(int j = 1; j <= d; j++) mat[i][j] = mat[i-1][j];\n                int j = 1;\n                while(mat[i][j] == k-1) j++;\n                if(j > d) {\n                    //System.out.println( i + \" + SD\");\n                    \n                    for(int t = 1; t < d; t++) mat[i][t] = 0;\n                }\n                else {\n                    for(int t = 1; t < j; t++) mat[i][t] = 0;\n                    mat[i][j]++;\n                }\n            }\n        for(int j = 1; j <= d; j++) {\n        for(int i = 1; i <= n; i++) {\n            mat[i][j]++;\n           // System.out.println(\"SDAC\");\n            out.print(mat[i][j]);\n            out.print(\" \");\n        }\n            out.println(\"\\n\");\n        }\n        }\n        out.close();\n    }\n  \n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int oo = 0x3f3f3f3f;\nconst double EPS = 1e-9;\nconst int MAXN = (int)1e5 + 10;\nint ANS[1010][1010];\nint n, k, d;\nvoid next(int c) {\n  for (int i = 0; i < d; ++i) {\n    if (ANS[i][c] == k)\n      ANS[i][c] = 1;\n    else {\n      ANS[i][c]++;\n      break;\n    }\n  }\n  for (int i = 0; i < d; ++i) ANS[i][c + 1] = ANS[i][c];\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> k >> d;\n  long long t = 1;\n  for (int i = 0; i < d && t < n; ++i, t *= k)\n    ;\n  if (t < 1LL * n) {\n    cout << -1 << '\\n';\n    exit(0);\n  }\n  for (int j = 0; j < d; ++j) ANS[j][0] = ANS[j][1] = 1;\n  for (int i = 1; i < n; ++i) {\n    next(i);\n  }\n  for (int i = 0; i < d; ++i) {\n    for (int j = 0; j < n; ++j) cout << ANS[i][j] << \" \";\n    cout << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 1e3 + 3;\nint m[MAX][MAX];\nint N, K, D;\nint main(int argc, char** argv) {\n  scanf(\"%d%d%d\", &N, &K, &D);\n  for (int i = (1); i <= (D); i++) m[1][i] = 1;\n  for (int i = (2); i <= (N); i++) {\n    for (int j = (D); j >= (1); j--) {\n      m[i][j] += m[i - 1][j];\n      if (j == D) m[i][j]++;\n      if (m[i][j] > K) m[i][j] = 1, m[i][j - 1]++;\n      if (m[i][0]) {\n        puts(\"-1\");\n        exit(0);\n      }\n    }\n  }\n  for (int j = (1); j <= (D); j++) {\n    for (int i = (1); i <= (N); i++) printf(\"%d \", m[i][j]);\n    printf(\"\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n/**\n * @author Don Li\n */\npublic class PashmakBuses {\n    void solve() {\n        int n = in.nextInt(), k = in.nextInt(), d = in.nextInt();\n        \n        long cnt = 1;\n        for (int i = 0; i < d; i++) {\n            cnt *= k;\n            if (cnt >= n) break;\n        }\n        \n        if (n > cnt) {\n            out.println(-1);\n            return;\n        }\n        \n        int[][] res = new int[n][d];\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < d; j++) res[i][j] = res[i - 1][j];\n            int p = d - 1, carry = 1;\n            while (p >= 0 && carry > 0) {\n                int tmp = (res[i][p] + carry) / k;\n                res[i][p] = (res[i][p] + carry) % k;\n                p--;\n                carry = tmp;\n            }\n        }\n        \n        for (int i = 0; i < d; i++) {\n            for (int j = 0; j < n; j++) {\n                if (j > 0) out.print(' ');\n                out.print(res[j][i] + 1);\n            }\n            out.println();\n        }\n    }\n    \n    public static void main(String[] args) {\n        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        new PashmakBuses().solve();\n        out.close();\n    }\n    \n    static FastScanner in;\n    static PrintWriter out;\n    \n    static class FastScanner {\n        BufferedReader in;\n        StringTokenizer st;\n        \n        public FastScanner(BufferedReader in) {\n            this.in = in;\n        }\n        \n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        \n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n        \n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n\npublic class R261D2TCPashmakAndBuses {\n\n\tpublic static void main(String args[] ) throws Exception {\n\t\t\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t    PrintWriter w = new PrintWriter(System.out);\n\t        \n\t    StringTokenizer st1 = new StringTokenizer(br.readLine());\n\t    int n = ip(st1.nextToken());\n\t\tint k = ip(st1.nextToken());\n\t    int d = ip(st1.nextToken());\n\t         \n\t    if(d == 1){\n\t    \tif(n > k)\n\t    \t\tw.println(\"-1\");\n\t    \telse{\n\t    \t\tfor(int i=1;i<=n;i++)\n\t    \t\t\tw.print(i + \" \");\n\t    \t}\n\t    }\n\t    else{\n\t    \tint ans[][] = new int[n][d];\n\t    \tif(k >= n){\n\t    \t\tfor(int i=0;i<n;i++)\n\t    \t\t\tArrays.fill(ans[i], i+1);\n\t    \t}\n\t    \telse{\n\t    \t\tif(k == 1){\n\t    \t\t\tif(n > 1){\n\t    \t\t\t\tw.println(\"-1\");\n\t    \t\t\t\tw.close();\n\t    \t\t\t\treturn;\n\t    \t\t\t}\n\t    \t\t\telse\n\t    \t\t\t\tArrays.fill(ans[0], 1);\n\t    \t\t}\n\t    \t\telse{\n\t    \t\t\tArrays.fill(ans[0],1);\n\t    \t\t\tfor(int i=1;i<n;i++){\n\t    \t\t\t\tif(next_perm(ans[i-1],ans[i],k) == false){\n\t    \t\t\t\t\tw.println(\"-1\");\n\t    \t\t\t\t\tw.close();\n\t    \t\t\t\t\treturn;\n\t    \t\t\t\t}\n\t    \t\t\t}\n\t    \t\t\t\n\t    \t\t}\n\t    \t}\n\t    \t\n\t    \tfor(int i=0;i<d;i++){\n\t    \t\tfor(int j=0;j<n;j++)\n\t    \t\t\tw.print(ans[j][i] + \" \");\n\t    \t\tw.println();\n\t    \t}\n\t    }\n\t    \n\t    w.close(); \n\t}\n\t\n\tpublic static boolean next_perm(int end[],int start[],int k){\n\t\tint n = end.length;\n\t\tboolean found = false;\n\t\t\n\t\tfor(int i=n-1;i>=0;i--){\n\t\t\tif(found){\n\t\t\t\tstart[i] = end[i];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(end[i] != k){\n\t\t\t\t\tstart[i] = end[i] + 1;\n\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstart[i] = 1;\n\t\t\t}\n\t\t}\n\t\treturn found;\n\t}\n\t\n\tpublic static int ip(String s){\n\t\treturn Integer.parseInt(s);\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  do {\n    int n, k, d;\n    if (scanf(\"%d %d %d\\n\", &n, &k, &d) == EOF) {\n      break;\n    }\n    vector<vector<int>> matrix;\n    vector<int> row(d + 1, 0);\n    matrix.push_back(row);\n    vector<int> perm(d + 1, 1);\n    matrix.push_back(perm);\n    int count = 1;\n    int pos = d;\n    while (pos > 0) {\n      int v = perm[pos] + 1;\n      if (v > k) {\n        for (int i = pos; i <= d; ++i) {\n          perm[i] = 1;\n        }\n        --pos;\n        while (pos > 1 && perm[pos] + 1 > k) {\n          perm[pos] = 1;\n          --pos;\n        }\n        if (pos < 1) {\n          break;\n        }\n        if (pos == 1 && perm[pos] + 1 > k) {\n          break;\n        }\n        ++perm[pos];\n        pos = d;\n        ++count;\n      } else {\n        perm[pos] = v;\n        ++count;\n      }\n      matrix.push_back(perm);\n      if (count >= n) {\n        break;\n      }\n    }\n    if (count >= n) {\n      for (int j = 1; j <= d; ++j) {\n        for (int i = 1; i <= n; ++i) {\n          if (i == 1) {\n            printf(\"%d\", matrix[i][j]);\n          } else {\n            printf(\" %d\", matrix[i][j]);\n          }\n        }\n        printf(\"\\n\");\n      }\n    } else {\n      printf(\"-1\\n\");\n    }\n  } while (true);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  for (auto x : v) os << x << \" \";\n  return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, const set<T>& v) {\n  for (auto it : v) os << it << \" \";\n  return os;\n}\ntemplate <typename T, typename S>\nostream& operator<<(ostream& os, const map<T, S>& v) {\n  for (auto it : v) os << it.first << \" : \" << it.second << \"\\n\";\n  return os;\n}\ntemplate <typename T, typename S>\nostream& operator<<(ostream& os, const pair<T, S>& v) {\n  os << \"(\";\n  os << v.first << \", \" << v.second << \")\";\n  return os;\n}\ntemplate <typename T>\nistream& operator>>(istream& in, vector<T>& v) {\n  for (T& it : v) in >> it;\n  return in;\n}\nmap<long long, long long> counts(const vector<long long>& v) {\n  map<long long, long long> m;\n  for (auto x : v) {\n    m[x]++;\n  }\n  return m;\n}\nmap<char, long long> counts(const string& s) {\n  map<char, long long> m;\n  for (auto x : s) {\n    m[x]++;\n  }\n  return m;\n}\nvector<long long> next_perm(vector<long long> a, long long k) {\n  for (long long i = a.size() - 1; i >= 0; i--) {\n    if (a[i] != k) {\n      a[i]++;\n      break;\n    } else {\n      a[i] = 1;\n    }\n  }\n  return a;\n}\nvoid solve() {\n  long long n, k, d;\n  cin >> n >> k >> d;\n  if (n > pow(k, d)) {\n    cout << -1;\n    return;\n  }\n  vector<long long> nums(d, 1);\n  vector<vector<long long> > seq(d, vector<long long>(n));\n  for (long long i = 0; i < n; i++) {\n    for (long long j = 0; j < d; j++) {\n      seq[j][i] = nums[j];\n    }\n    nums = next_perm(nums, k);\n  }\n  for (long long i = 0; i < d; i++) {\n    cout << seq[i] << endl;\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, d, a[1005][1005], ct = 1;\nint main(int argc, const char* argv[]) {\n  cin >> n >> k >> d;\n  if ((k == 1 && n != 1) || (n == 3 && k == 2 && d == 1)) {\n    cout << -1 << endl;\n    return 0;\n  } else if (n == 1) {\n    for (int i = 0; i < d; i++) {\n      cout << 1 << endl;\n    }\n    return 0;\n  }\n  int temp = 1;\n  for (int i = 0; i < d; i++) {\n    temp *= k;\n    if (temp > n) {\n      break;\n    }\n  }\n  if (temp < n) {\n    cout << -1 << endl;\n    return 0;\n  }\n  for (int i = 0; i < d; i++) {\n    int pnt = 0;\n    for (int j = 0; j < n; j++) {\n      int l;\n      for (l = j; l < n && l - j < ct; l++) {\n        cout << (pnt % k) + 1 << \" \";\n      }\n      pnt++;\n      j = l - 1;\n    }\n    if (ct < 1005) {\n      ct *= k;\n    }\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint a[1000][1000] = {0};\nint cek(int n, int k, int d) {\n  long long sum = 1;\n  for (int i = 0; i < d; i++) {\n    sum = sum * k;\n    if (sum >= n) {\n      return 1;\n    }\n  }\n  return 0;\n}\nvoid rek(int n, int i, int j, int k) {\n  if (n == 0) {\n    return;\n  } else {\n    a[i][j] = n % k;\n    rek(n / k, i - 1, j, k);\n    return;\n  }\n}\nvoid cetak(int n, int k, int d) {\n  for (int i = 0; i < n; i++) {\n    rek(i, d - 1, i, k);\n  }\n  for (int i = 0; i < d; i++) {\n    for (int j = 0; j < n; j++) {\n      printf(\"%d%c\", a[i][j] + 1, (j == n - 1) ? '\\n' : ' ');\n    }\n  }\n}\nint main() {\n  int n, k, d;\n  scanf(\"%d %d %d\", &n, &k, &d);\n  if (cek(n, k, d) == 1) {\n    cetak(n, k, d);\n  } else {\n    printf(\"-1\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class MainC {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tint n, k, d;\n\tArrayList<int[]> list;\n\n\tvoid run() {\n\t\tn = sc.nextInt();\n\t\tk = sc.nextInt();\n\t\td = sc.nextInt();\n\t\tlist = new ArrayList<int[]>();\n\t\tint tmp = 1;\n\t\tboolean ok = false;\n\t\tfor (int i = 0; i < d; i++) {\n\t\t\ttmp *= k;\n\t\t\tif (tmp >= n) {\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!ok) {\n\t\t\tSystem.out.println(-1);\n\t\t} else {\n\t\t\tgenerate(0, new int[d]);\n\t\t\tint out[][] = new int[d][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint[] b = list.get(i);\n\t\t\t\tfor (int j = 0; j < d; j++) {\n\t\t\t\t\tout[j][i] = b[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor (int i = 0; i < d; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tsb.append((j == 0 ? \"\" : \" \") + out[i][j]);\n\t\t\t\t}\n\t\t\t\tsb.append(\"\\n\");\n\t\t\t}\n\t\t\tSystem.out.println(sb);\n\t\t}\n\t}\n\n\tvoid generate(int i, int a[]) {\n\t\tif (list.size() == n) {\n\t\t\treturn;\n\t\t}\n\t\tif (i == d) {\n\t\t\tint[] b = new int[d];\n\t\t\tb = a.clone();\n\t\t\tlist.add(b);\n\t\t\treturn;\n\t\t}\n\t\tfor (int j = 1; j <= k; j++) {\n\t\t\tif (list.size() == n) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ta[i] = j;\n\t\t\tgenerate(i + 1, a);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew MainC().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long MAX(long long a, long long b) {\n  if (a > b) return a;\n  return b;\n}\nlong long MIN(long long a, long long b) {\n  if (a < b) return a;\n  return b;\n}\nlong long POW(long long a, long long b) {\n  long long exit = 1;\n  for (int i = 0; i < b; i++) exit *= a;\n  return exit;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long n, k, d;\n  cin >> n >> k >> d;\n  long long mult = 1;\n  bool ok = false;\n  for (int i = 0; i < d; i++) {\n    mult *= k;\n    if (mult >= n) {\n      ok = true;\n      break;\n    }\n  }\n  if (!ok) {\n    cout << \"-1\" << endl;\n    return 0;\n  }\n  long long exit[d][n];\n  memset(exit, 0, sizeof exit);\n  for (long long i = 0; i < n; i++) {\n    exit[0][i] = 0;\n  }\n  for (long long i = 1; i < n; i++) {\n    for (long long j = 0; j < d; j++) exit[j][i] = exit[j][i - 1];\n    for (long long j = d - 1; j >= 0; j--) {\n      exit[j][i] = (exit[j][i] + 1) % k;\n      if (exit[j][i] != 0) {\n        break;\n      }\n    }\n  }\n  for (long long i = 0; i < d; i++) {\n    for (long long j = 0; j < n; j++) {\n      cout << exit[i][j] + 1 << \" \";\n    }\n    cout << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int n, k, d, ncomb = 1, kidn = 1;\nvector<vector<int> > kidbuses;\nvector<int> buses;\nvoid bt() {\n  if (kidn > n) return;\n  if (buses.size() == d) {\n    kidbuses.push_back(buses);\n    kidn++;\n  } else {\n    for (int i = 1; i <= k; i++) {\n      buses.push_back(i);\n      bt();\n      if (kidn > n) break;\n      buses.pop_back();\n    }\n  }\n}\nint main() {\n  cin >> n >> k >> d;\n  bt();\n  if (kidbuses.size() != n || kidbuses[0].size() != d)\n    cout << -1 << endl;\n  else\n    for (int i = 0; i < d; i++, cout << endl)\n      for (int j = 0; j < n; j++) {\n        if (j) cout << ' ';\n        cout << kidbuses[j][i];\n      }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.List;\nimport java.util.Scanner;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.LinkedList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author desc\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tScanner in = new Scanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskC solver = new TaskC();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskC {\n\n    private int k;\n\n    public void solve(int testNumber, Scanner in, PrintWriter out) {\n        int n = in.nextInt();\n        k = in.nextInt();\n        int d = in.nextInt();\n\n        students = new int[n+1];\n        results = new int[n+1][d];\n\n        List<List<Integer>> src = new LinkedList<>();\n        List<Integer> srcZero = new LinkedList<>();\n        for (int i = 1; i <= n; i++) {\n            srcZero.add(i);\n        }\n        src.add(srcZero);\n\n        for (int i = 0; i < d; i++) {\n            src = alloc(src);\n            for (int j = 1; j <= n; j++) {\n                results[j][i] = students[j];\n            }\n        }\n\n        for (List<Integer> list : src) {\n            if (list.size() != 1) {\n                out.print(-1);\n                return;\n            }\n        }\n\n        // OK\n        for (int i = 0; i < d; i++) {\n            for (int j = 1; j <= n; j++) {\n                out.print(results[j][i] + \" \");\n            }\n            out.println();\n        }\n    }\n\n    int[] students;\n    int[][] results;\n\n    List<List<Integer>> alloc(List<List<Integer>> src){\n        List<List<Integer>> ret = new LinkedList<>();\n        for (List<Integer> list : src) {\n            if (list.size() == 1) {\n                students[list.get(0)] = 1;\n                ret.add(list);\n                continue;\n            }\n\n            int m = Math.min(k, list.size());\n            List<Integer>[] am = new List[m];\n            for (int i = 0; i < m; i++) {\n                am[i] = new LinkedList<>();\n            }\n\n            int next = 0;\n            for (Integer s : list) {\n                am[next].add(s);\n                students[s] = next + 1;\n                next++;\n                next %= m;\n            }\n\n            for (int i = 0; i < m; i++) {\n                ret.add(am[i]);\n            }\n        }\n\n        return ret;\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\n\npublic class p67 {\n    static class FastReader{ \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    }\n    \n    public static void main(String[] args){\n        FastReader sc = new FastReader();\n        PrintWriter out = new PrintWriter(System.out);\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        int d = sc.nextInt();\n        long temp = 1;\n        boolean flag = false;\n        for(int i=0;i<d;i++){\n            temp *= k;\n            if(n<=temp){\n                flag = true;\n                break;\n            }    \n        }\n\n        if(!flag){\n            System.out.println(\"-1\");\n            return;\n        }\n        \n        int[][] ans = new int[n][d];\n        for(int i=1;i<n;i++){\n            for(int j=0;j<d;j++)\n                ans[i][j] = ans[i-1][j];\n            for(int j=d-1;j>=0;j--){\n                ans[i][j] = (ans[i][j]+1)%k;\n                if(ans[i][j]>0)\n                    break;\n            }\n        }\n\n        for(int j=0;j<d;j++){\n            for(int i=0;i<n;i++)\n                out.print((ans[i][j]+1)+\" \");\n            out.println();\n        }\n        out.close();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid dbg_out() { cerr << \"\\b\\b]\\n\"; }\ntemplate <typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n  cerr << H << \", \";\n  dbg_out(T...);\n}\nconst int N = 1002;\nvector<vector<int>> ans(N, vector<int>(N, -1));\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n, k, d;\n  cin >> n >> k >> d;\n  if (k >= n) {\n    for (int i = 1; i <= d; ++i) {\n      for (int j = 1; j <= n; ++j) {\n        cout << j << ' ';\n      }\n      cout << '\\n';\n    }\n    return 0;\n  }\n  bool ok = true;\n  function<void(int, int, int, int)> go = [&](int l, int r, int bus, int d) {\n    if (d < 0) return;\n    if (d == 1) {\n      if (r - l + 1 > 1) {\n        ok = false;\n        return;\n      }\n    }\n    for (int i = l; i <= r; ++i) {\n      ans[d][i] = bus;\n    }\n    int rem = (r - l + 1) % k;\n    int segment = (r - l + 1) / k;\n    if (segment) {\n      int curr = l;\n      for (int i = 1; i <= k; ++i) {\n        int y = curr + segment + (i <= rem) - 1;\n        go(curr, y, i, d - 1);\n        curr = y + 1;\n      }\n    } else {\n      for (int i = 0; i < rem; ++i) {\n        go(l + i, l + i, i + 1, d - 1);\n      }\n    }\n  };\n  int l = 1, r = n;\n  int rem = (r - l + 1) % k;\n  int segment = (r - l + 1) / k;\n  int curr = 1;\n  for (int i = 1; i <= k; ++i) {\n    int y = curr + segment + (i <= rem) - 1;\n    go(curr, y, i, d);\n    curr = y + 1;\n  }\n  if (!ok) {\n    cout << -1;\n    return 0;\n  }\n  for (int i = d; i >= 1; --i) {\n    for (int j = 1; j <= n; ++j) {\n      cout << ans[i][j] << ' ';\n    }\n    cout << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int n, k, d, inc, a[1005][1005], i, j, temp, flag;\nint main() {\n  scanf(\"%lld\", &n), scanf(\"%lld\", &k), scanf(\"%lld\", &d);\n  temp = 1;\n  flag = 0;\n  for (i = 1; i <= d; i++) {\n    temp *= k;\n    if (temp >= n) {\n      flag = 1;\n      break;\n    }\n  }\n  if (flag == 0) {\n    printf(\"-1\\n\");\n    return 0;\n  }\n  for (i = 0; i < d; i++) a[0][i] = 0;\n  for (i = 1; i < n; i++) {\n    for (j = 0; j < d; j++) a[i][j] = a[i - 1][j];\n    for (j = d - 1; j >= 0; j--) {\n      a[i][j] = (a[i][j] + 1) % k;\n      if (a[i][j]) break;\n    }\n  }\n  for (i = 0; i < d; i++) {\n    for (j = 0; j < n; j++) printf(\"%lld \", a[j][i] + 1);\n    printf(\"\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "n,k,d = map(int, raw_input().split())\nif n > k**d: print -1\nelse:\n    ans = []\n    for i in range(n):\n        tmp = i\n        cur = []\n        for j in range(d):\n            cur.append(tmp%k+1)\n            tmp /= k\n        ans.append(cur)\n    for i in range(d):\n        for j in ans:\n            print j[i],\n        print ''\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool check(long long n, long long k, long long d) {\n  long long t = 1;\n  for (int i = 0; i < d; ++i) {\n    if (t < n) t *= k;\n  }\n  if (n > t) return 0;\n  return 1;\n}\nint main() {\n  long long n, k, d;\n  cin >> n >> k >> d;\n  if (!check(n, k, d)) {\n    cout << -1;\n    return 0;\n  }\n  long long a[n];\n  for (int i = 0; i < n; ++i) {\n    a[i] = i;\n  }\n  for (int i = 0; i < d; ++i) {\n    for (int j = 0; j < n; ++j) {\n      cout << (a[j] % k) + 1 << \" \";\n      a[j] /= k;\n    }\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.*;\nimport java.io.*;\n\npublic class PashmakAndBuses459C {\n    static void go() {\n        int n = in.nextInt();\n        int k = in.nextInt();\n        int d = in.nextInt();\n\n        int x = 1;\n        for (int i = 0; i < d; i++) {\n            x *= k;\n            if (x >= n)\n                break;\n        }\n        if (x < n) {\n            out.println(-1);\n            return;\n        }\n\n        int[][] ans = new int[n][d];\n        for (int i = 1; i < n; i++) {\n            int c = 1;\n            for (int j = d - 1; j >= 0; j--) {\n                ans[i][j] = ans[i-1][j] + c;\n                if (ans[i][j] == k) {\n                    c = 1;\n                    ans[i][j] = 0;\n                } else\n                    c = 0;\n            }\n        }\n\n        for (int i = 0; i < d; i++, out.println()) {\n            for (int j = 0; j < n; j++) {\n                out.print((ans[j][i] + 1) + \" \");\n            }\n            //out.println();\n        }\n    }\n\n    static InputReader in;\n    static PrintWriter out;\n\n    public static void main(String[] args) {\n        in = new InputReader(System.in);\n        out = new PrintWriter(System.out);\n\n        go();\n\n        out.close();\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int[] nextIntArray(int len) {\n            int[] ret = new int[len];\n            for (int i = 0; i < len; i++)\n                ret[i] = nextInt();\n            return ret;\n        }\n\n        public long[] nextLongArray(int len) {\n            long[] ret = new long[len];\n            for (int i = 0; i < len; i++)\n                ret[i] = nextLong();\n            return ret;\n        }\n\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String nextString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder sb = new StringBuilder(1024);\n            do {\n                sb.append((char) c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return sb.toString();\n        }\n\n        public static boolean isSpaceChar(int c) {\n            switch (c) {\n                case -1:\n                case ' ':\n                case '\\n':\n                case '\\r':\n                case '\\t':\n                    return true;\n                default:\n                    return false;\n            }\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1 * 1000 + 10;\nint ans[MAXN][MAXN];\nint main() {\n  ios::sync_with_stdio(false);\n  int n, d, k;\n  cin >> n >> k >> d;\n  long long tmp = 1;\n  bool check = false;\n  for (int i = 0; i < d; i++) {\n    tmp *= k;\n    if (tmp >= n) {\n      check = true;\n      break;\n    }\n  }\n  if (!check) {\n    cout << -1 << endl;\n    return 0;\n  }\n  for (int i = 1; i < n; i++) {\n    for (int j = 0; j < d; j++) ans[i][j] = ans[i - 1][j];\n    for (int j = d - 1; j >= 0; j--) {\n      ans[i][j] = (ans[i][j] + 1) % k;\n      if (ans[i][j]) break;\n    }\n  }\n  for (int i = 0; i < d; i++, cout << endl)\n    for (int j = 0; j < n; j++) cout << ans[j][i] + 1 << ' ';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1 * 1000 + 10;\nint ans[MAXN][MAXN];\nint main() {\n  int n, d, k;\n  scanf(\"%d%d%d\", &n, &k, &d);\n  long long is = 1;\n  for (int i = 1; i <= d && is < n; ++i) is *= k;\n  if (is < n) {\n    puts(\"-1\");\n    return 0;\n  }\n  for (int i = 1; i < n; i++) {\n    for (int j = 0; j < d; j++) ans[i][j] = ans[i - 1][j];\n    for (int j = d - 1; j >= 0; j--) {\n      ans[i][j] = (ans[i][j] + 1) % k;\n      if (ans[i][j]) break;\n    }\n  }\n  for (int i = 0; i < d; i++, cout << endl)\n    for (int j = 0; j < n; j++) cout << ans[j][i] + 1 << ' ';\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.Arrays;\n\n/**\n *\n * @author Anextro\n */\npublic class Main {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new PrintWriter(System.out));\n        \n        String[] ln1 = br.readLine().split(\" \");\n        int n = Integer.parseInt(ln1[0]);\n        int k = Integer.parseInt(ln1[1]);\n        int d = Integer.parseInt(ln1[2]);\n        \n        BigInteger N = new BigInteger(String.valueOf(n));\n        BigInteger K = new BigInteger(String.valueOf(k));\n        BigInteger D = new BigInteger(String.valueOf(d));\n        \n        if(N.subtract(K.pow(d)).compareTo(BigInteger.ZERO)==1){\n            bw.append(\"-1\"+\"\\n\");\n        }\n        else{\n        \n            int[][] M = new int[n][d];\n            int[] a = new int[d];\n            for(int i=0;i<d;i++){\n                a[i]=1;\n             //   bw.append(a[i]+\" \");\n                M[0][i]=a[i];\n            }\n            //bw.append(\"\\n\");\n            \n            int cnt = 1;\n            while(cnt<=n-1){\n                \n                \n                int p = d-1;\n                while(a[p]>=k){  p-=1;}\n                a[p]+=1;\n                for(int i=p+1;i<d;i++){a[i]=1;}\n                \n                for(int i=0;i<d;i++){\n                    M[cnt][i]=a[i];\n                   // bw.append(a[i]+\" \");\n                }\n                //bw.append(\"\\n\");\n                \n                cnt+=1;\n                \n            }\n            \n            \n            for(int i=0;i<d;i++){\n                for(int j=0;j<n;j++){\n                    bw.append(M[j][i]+\" \");\n                }\n                bw.append(\"\\n\");\n            }\n        }\n        \n      bw.close();  \n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class ProblemC2 {\n    private ProblemC2() throws IOException {\n        BufferedReader rd = new BufferedReader(new InputStreamReader(System.in));\n        String h = rd.readLine();\n        String[] q = h.split(\"\\\\s+\");\n        int n = Integer.parseInt(q[0]);\n        int k = Integer.parseInt(q[1]);\n        int d = Integer.parseInt(q[2]);\n        if(n == 1) {\n            for(int i=0;i<d;i++) {\n                out(1);\n            }\n        } else if(k == 1) {\n            out(-1);\n        } else if(k >= n) {\n            StringBuilder buf = new StringBuilder();\n            for(int i=0;i<n;i++) {\n                if(i > 0) {\n                    buf.append(' ');\n                }\n                buf.append(i+1);\n            }\n            String s = buf.toString();\n            for(int i=0;i<d;i++) {\n                out(s);\n            }\n        } else {\n            int[][] res = new int[d][n];\n            boolean carry = false;\n            int u=1;\n            while(!carry && u < n) {\n                for(int v=0;v<d;v++) {\n                    res[v][u] = res[v][u-1];\n                }\n                int p = 0;\n                res[p][u] = res[p][u-1]+1;\n                while(p < d && res[p][u] == k) {\n                    res[p][u] = 0;\n                    p++;\n                    if(p < d) {\n                        res[p][u] = res[p][u-1]+1;\n                    } else {\n                        carry = true;\n                    }\n                }\n                if(!carry) {\n                    u++;\n                }\n            }\n            if(u == n) {\n                for(int i=0;i<d;i++) {\n                    StringBuilder buf = new StringBuilder();\n                    for(int j=0;j<n;j++) {\n                        if(j != 0) {\n                            buf.append(' ');\n                        }\n                        buf.append(res[i][j]+1);\n                    }\n                    out(buf);\n                }\n            } else {\n                out(-1);\n            }\n        }\n    }\n\n    private static void out(Object x) {\n        System.out.println(x);\n    }\n\n    public static void main(String[] args) throws IOException {\n        new ProblemC2();\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint mat[1010][1010], d, n;\nint mul(int k, int d) {\n  long long ans = 1;\n  for (int i = 1; i <= d; i++) {\n    ans *= k;\n    if (ans >= 9999) return ans;\n  }\n  return ans;\n}\nint main() {\n  int m, i, j, k;\n  while (scanf(\"%d%d%d\", &n, &k, &d) != EOF) {\n    if (mul(k, d) < n) {\n      puts(\"-1\");\n      continue;\n    }\n    for (i = 1; i <= d; i++) mat[i][1] = 0;\n    for (i = 2; i <= n; i++) {\n      int kk = 0;\n      m = mat[d][i - 1] + 1;\n      mat[d][i] = m % k;\n      kk = m / k;\n      for (j = d - 1; j >= 1; j--) {\n        m = kk + mat[j][i - 1];\n        mat[j][i] = m % k;\n        kk = m / k;\n      }\n    }\n    for (i = 1; i <= d; i++) {\n      cout << mat[i][1] + 1;\n      for (j = 2; j <= n; j++) printf(\" %d\", mat[i][j] + 1);\n      puts(\"\");\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.lang.*;\nimport java.math.BigInteger;\n\n\npublic class Main {\n  \n    public static int[][] a;\n\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint t,ca;\n\t\tString[] my;\n\t\tString line = br.readLine();\n        int n,k,d;\n        my = line.split(\" \");\n        n = Integer.parseInt(my[0]);\n        k = Integer.parseInt(my[1]);\n        d = Integer.parseInt(my[2]);\n        boolean valid = false;\n        int ans = 1;\n        int i,j;\n        for(i=0;i<d;i++)\n        {\n            ans = ans*k;\n            if(ans>=n){\n                valid = true;\n                break;\n            }\n        }\n        if(valid)\n        {\n            a = new int[d][n];\n            int cur ;\n            int[] v = new int[d];\n            for(cur = 0; cur<n;cur++)\n            {\n                for(i=0;i<d;i++)\n                v[i] = 0;\n                int m = cur;\n                i = 0;\n                while(m>0)\n                {\n                    v[i] = m%k;\n                    m/=k;\n                    i++;\n                }\n                for(i=0;i<d;i++)\n                a[i][cur] = v[i] + 1;\n            }\n            StringBuffer bf = new StringBuffer();\n            for(i=0;i<d;i++)\n            {\n                for(j=0;j<n;j++)\n              bf.append((a[i][j] + \" \"));\n              bf.append(\"\\n\");\n                \n                \n            }\n            System.out.println(bf.toString());\n            \n            \n        }\n        else System.out.println(-1);\n\n        }\n    \n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\nimport java.util.Set;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Nasko\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n\n            int N = in.nextInt();\n            int K = in.nextInt();\n            int D = in.nextInt();\n\n\n            int[][] ret = new int[N][D];\n\n            for (int i = 1; i < N; ++i) {\n                for (int j = 0; j < D; ++j) ret[i][j] = ret[i - 1][j];\n                for (int j = 0; j < D; ++j) {\n                    ret[i][j] = (ret[i][j] + 1) % K;\n                    if (ret[i][j] > 0) break;\n                }\n            }\n\n            ArrayList<Integer> rem = new ArrayList<Integer>();\n            for (int i = 0; i < N; ++i) {\n                Set<Integer> hs = new HashSet<Integer>();\n                for (int d = 0; d < D; ++d) {\n                    hs.add(ret[i][d]);\n                }\n                if (hs.size() == 1) {\n                    rem.addAll(hs);\n                }\n            }\n            for (int i = 0; i < rem.size(); ++i) {\n                for (int j = i + 1; j < rem.size(); ++j) {\n                    if (rem.get(i) == rem.get(j)) {\n                        out.println(-1);\n                        return;\n                    }\n                }\n            }\n            for (int i = 0; i < D; ++i) {\n                for (int j = 0; j < N; ++j) {\n                    out.print((ret[j][i] + 1) + \" \");\n                }\n                out.println();\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint f[2000];\nint main() {\n  int n, d, k;\n  scanf(\"%d%d%d\", &n, &k, &d);\n  long long counter = 1;\n  bool ff = 0;\n  for (int i = 0; i < d; i++) {\n    counter *= k;\n    if (counter >= n) {\n      ff = 1;\n      break;\n    }\n  }\n  if (!ff) {\n    printf(\"-1\\n\");\n    return 0;\n  }\n  for (int i = 1; i <= n; i++) f[i] = i;\n  for (int i = 1; i <= d; i++) {\n    for (int j = 1; j <= n; j++) {\n      cout << f[j] % k + 1;\n      if (j == n)\n        printf(\"\\n\");\n      else\n        printf(\" \");\n      f[j] /= k;\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double eps = 1.0e-11;\nconst double pi = acos(-1.0);\nint main() {\n  ios_base::sync_with_stdio(0);\n  long long n, k, d;\n  cin >> n >> k >> d;\n  bool ok = false;\n  long long tmp = 1;\n  for (long long i = 0; i < d; i++) {\n    tmp *= k;\n    if (tmp >= n) {\n      ok = true;\n      break;\n    }\n  }\n  if (!ok) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n  vector<int> curr(n);\n  for (long long i = 0; i < n; i++) curr[i] = i;\n  for (long long i = 0; i < d; i++) {\n    for (long long j = 0; j < n; j++) {\n      cout << curr[j] % k + 1 << \" \";\n      curr[j] /= k;\n    }\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, d;\nint counter = 0;\nvoid dfs(int step, vector<int> &vec, vector<vector<int> > &ans) {\n  if (counter == n) return;\n  if (step == d) {\n    ans[counter] = vec;\n    counter++;\n    return;\n  }\n  for (int i = 1; i < min(1 + k, 1 + n); i++) {\n    vec[step] = i;\n    dfs(step + 1, vec, ans);\n  }\n}\nint main() {\n  cin >> n >> k >> d;\n  vector<int> vec(d);\n  vector<vector<int> > ans(n, vector<int>(d));\n  bool ok = false;\n  int temp = 1;\n  for (int i = 0; i < d; i++) {\n    temp *= k;\n    if (temp >= n) {\n      ok = true;\n      break;\n    }\n  }\n  if (!ok) {\n    cout << -1;\n    return 0;\n  }\n  dfs(0, vec, ans);\n  for (int i = 0; i < d; i++, cout << endl)\n    for (int j = 0; j < n; j++) {\n      cout << ans[j][i] << \" \";\n    }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from math import *\nn , k , d = map(int,input().split())\ndef ff(n,k):\n    if n % k !=0 :\n        return n%k\n    else: return k\ndef f(n,k,feed):\n    answer = []\n    if n < k :\n        for numbers in range(n):\n            answer.append(numbers)\n    else:\n        x_1 = ceil(n/k)\n        x_2 = floor(n/k)\n        y_1 = n % k\n        y_2 = k - n%k\n        counter = 1\n        for numbers in range(y_1):\n            answer+= x_1* [counter]\n            counter+=1\n        for numbers in range(y_2):\n            answer+= x_2 * [counter]\n            counter+=1\n    new_answer = \"\"\n    for elements in answer:\n        new_answer += str(ff((elements),k)) + \" \" ###ff((elements + feed -1),k)\n    return new_answer\n\nif k == 1:\n    if n == 1 :\n        for numbers in range(d):\n            print(1)\n    else :\n        print(-1)\nelif ceil(log(n,k)) > d :\n    print(-1)\nelif k >= n :\n    answer = \"\"\n    for numbers in range(1,n+1):\n        answer += str(numbers) + \" \"\n    for numbers in range(d):\n        print(answer)\n\nelse :\n    list_numbers = [n]\n    for numbers in range(ceil(log(n,k))):\n        list_new = []\n        for elements in list_numbers:\n            x_1 = ceil(elements / k)\n            x_2 = floor(elements / k)\n            y_1 = elements % k\n            y_2 = k - elements % k\n            list_new += [x_1]*y_1 + [x_2]*y_2\n        feed = 1\n        answer = \"\"\n        for values in list_numbers :\n            answer += f(values,k,feed)\n            feed +=1\n        print(answer)\n        list_numbers = list_new\n    for numbers in range(d- ceil(log(n,k))):\n        print(\"1 \"*n)\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long arr[1010][1010];\nint main() {\n  ios::sync_with_stdio(false);\n  long long n, k, d, x = 1;\n  cin >> n >> k >> d;\n  for (int i = (0); i < (d); i++) {\n    x *= k;\n    if (x >= n) break;\n  }\n  if (x < n) {\n    cout << -1 << endl;\n    return 0;\n  }\n  bool g = true;\n  for (int i = (1); i < (n); i++) {\n    for (int j = (0); j < (d); j++) arr[i][j] = arr[i - 1][j];\n    for (int j = (d - 1); j >= (0); j--) {\n      arr[i][j] = (arr[i][j] + 1) % k;\n      if (arr[i][j]) break;\n    }\n  }\n  for (int i = (0); i < (d); i++) {\n    for (int j = (0); j < (n); j++) cout << arr[j][i] + 1 << \" \";\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n    static int MOD = 1000000007;\n\n    // After writing solution, quick scan for:\n    //   array out of bounds\n    //   special cases e.g. n=1?\n    //\n    // Big numbers arithmetic bugs:\n    //   int overflow\n    //   sorting, or taking max, after MOD\n    void solve() throws IOException {\n        int[] nkd = ril(3);\n        int n = nkd[0];\n        int k = nkd[1];\n        int d = nkd[2];\n\n        int[][] ans = new int[d][n];\n        if (!helper(ans, 0, 0, n-1, k)) {\n            pw.println(\"-1\");\n            return;\n        }\n        for (int i = 0; i < d; i++) {\n            for (int j = 0; j < n; j++) {\n                if (ans[i][j] == 0) ans[i][j] = 1;\n            }\n        }\n        for (int[] row : ans) {\n            for (int x : row) pw.print(x + \" \");\n            pw.println();\n        }\n    }\n\n    boolean helper(int[][] ans, int d, int l, int r, int k) {\n        if (l == r) return true;\n        if (d >= ans.length) {\n            return false;\n        }\n        int cnt = r - l + 1;\n        int per = cnt / k;\n        int extra = cnt % k;\n\n        int cat = 1;\n        int here = 0;\n        int x = l;\n        for (int i = l; i <= r; i++) {\n            ans[d][i] = cat;\n            here++;\n            int tgt = per + (extra > 0 ? 1 : 0);\n            if (here == tgt) {\n                if (!helper(ans, d+1, x, i, k)) {\n                    return false;\n                }\n                cat++;\n                here = 0;\n                if (extra > 0) extra--;\n                x = i+1;\n            }\n        }\n        return true;\n    }\n\n    // Template code below\n\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    PrintWriter pw = new PrintWriter(System.out);\n\n    public static void main(String[] args) throws IOException {\n        Main m = new Main();\n        m.solve();\n        m.close();\n    }\n\n    void close() throws IOException {\n        pw.flush();\n        pw.close();\n        br.close();\n    }\n\n    int ri() throws IOException {\n        return Integer.parseInt(br.readLine().trim());\n    }\n\n    long rl() throws IOException {\n        return Long.parseLong(br.readLine().trim());\n    }\n\n    int[] ril(int n) throws IOException {\n        int[] nums = new int[n];\n        int c = 0;\n        for (int i = 0; i < n; i++) {\n            int sign = 1;\n            c = br.read();\n            int x = 0;\n            if (c == '-') {\n                sign = -1;\n                c = br.read();\n            }\n            while (c >= '0' && c <= '9') {\n                x = x * 10 + c - '0';\n                c = br.read();\n            }\n            nums[i] = x * sign;\n        }\n        while (c != '\\n' && c != -1) c = br.read();\n        return nums;\n    }\n\n    long[] rll(int n) throws IOException {\n        long[] nums = new long[n];\n        int c = 0;\n        for (int i = 0; i < n; i++) {\n            int sign = 1;\n            c = br.read();\n            long x = 0;\n            if (c == '-') {\n                sign = -1;\n                c = br.read();\n            }\n            while (c >= '0' && c <= '9') {\n                x = x * 10 + c - '0';\n                c = br.read();\n            }\n            nums[i] = x * sign;\n        }\n        while (c != '\\n' && c != -1) c = br.read();\n        return nums;\n    }\n\n    int[] rkil() throws IOException {\n        int sign = 1;\n        int c = br.read();\n        int x = 0;\n        if (c == '-') {\n            sign = -1;\n            c = br.read();\n        }\n        while (c >= '0' && c <= '9') {\n            x = x * 10 + c - '0';\n            c = br.read();\n        }\n        return ril(x);\n    }\n\n    long[] rkll() throws IOException {\n        int sign = 1;\n        int c = br.read();\n        int x = 0;\n        if (c == '-') {\n            sign = -1;\n            c = br.read();\n        }\n        while (c >= '0' && c <= '9') {\n            x = x * 10 + c - '0';\n            c = br.read();\n        }\n        return rll(x);\n    }\n\n    char[] rs() throws IOException {\n        return br.readLine().toCharArray();\n    }\n\n    void sort(int[] A) {\n        Random r = new Random();\n        for (int i = A.length-1; i > 0; i--) {\n            int j = r.nextInt(i+1);\n            int temp = A[i];\n            A[i] = A[j];\n            A[j] = temp;\n        }\n        Arrays.sort(A);\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n;\nlong long int fast_power(long long int a, long long int x, long long int mm) {\n  if (x == 0)\n    return 1;\n  else if (x == 1)\n    return a % mm;\n  else {\n    long long int y = fast_power(a, x / 2, mm) % mm;\n    y = ((y % mm) * (y % mm)) % mm;\n    if (x % 2 == 1)\n      return ((a % mm) * (y % mm)) % mm;\n    else\n      return y % mm;\n  }\n}\nlong long int mod(long long int a, long long int b) {\n  if (a < 0) {\n    a = (-a) % b;\n    if (a != 0) a = b - a;\n  } else\n    a = a % b;\n  return a;\n}\nlong long int mul(long long int a, long long int b, long long int mm) {\n  return (mod(a, mm) * mod(b, mm)) % mm;\n}\nlong long int add(long long int a, long long int b, long long int mm) {\n  return (mod(a, mm) + mod(b, mm)) % mm;\n}\nlong long int n, k, d;\nvector<long long int> str;\nvector<long long int> ans[1001];\nbool check() {\n  long long int i, aux = k;\n  for (i = 0; i < d; i++, aux *= k)\n    if (aux >= n) return true;\n  return false;\n}\nvoid print(long long int index) {\n  for (long long int i = 0; i < d; i++) ans[index].push_back(str[i] + 1);\n}\nvoid add_one(long long int index) {\n  if (str[index] == k - 1) {\n    str[index] = 0;\n    add_one(index - 1);\n  } else\n    str[index]++;\n}\nint main() {\n  long long int i;\n  scanf(\"%lld\", &n);\n  scanf(\"%lld\", &k);\n  scanf(\"%lld\", &d);\n  for (i = 0; i < d; i++) str.push_back(0);\n  if (!check())\n    printf(\"%s\", \"-1\\n\");\n  else {\n    for (i = 0; i < n; i++) {\n      print(i + 1);\n      if (i < n - 1) add_one(d - 1);\n    }\n    for (i = 0; i < d; i++) {\n      for (long long int j = 1; j <= n; j++) printf(\"%lld \", ans[j][i]);\n      printf(\"%s\", \"\\n\");\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "n, k, d = map(int, map(int, raw_input().strip().split(' ')))\n\nif n > (k ** d):\n    print -1\n    exit(0)\n\na = []\na.append([0 for _ in range(d)])\n\nfor i in range(1, n):\n    a.append([])\n    for j in range(d):\n        a[i].append(a[i - 1][j])\n\n    for j in range(d - 1, -1, -1):\n        a[i][j] = (a[i][j] + 1) % k\n        if a[i][j]:\n            break\n\nfor i in range(d):\n    print \" \".join(str(a[j][i] + 1) for j in range(n))"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int k = in.nextInt();\n            int d = in.nextInt();\n            if (n > Math.pow(k, d)) out.println(-1);\n            else {\n                int[][] ans = new int[d][n];\n                for (int i = 1; i < n; i++) {\n                    for (int j = d - 1; j >= 0; j--) {\n                        ans[j][i] = ans[j][i - 1];\n                    }\n                    ans[d - 1][i]++;\n                    for (int j = d - 1; j >= 0; j--) {\n                        if (ans[j][i] >= k) {\n                            ans[j][i] -= k;\n                            ans[j - 1][i]++;\n                        } else break;\n                    }\n                }\n                for (int i = 0; i < d; i++) {\n                    for (int j = 0; j < n; j++) {\n                        out.print((ans[i][j] + 1) + \" \");\n                    }\n                    out.print(\"\\n\");\n                }\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private StringTokenizer tokenizer;\n        private BufferedReader reader;\n\n        public InputReader(InputStream inputStream) {\n            reader = new BufferedReader(new InputStreamReader(inputStream));\n        }\n\n        private void fillTokenizer() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n\n        public String next() {\n            fillTokenizer();\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool check(int d, int n, int k) {\n  int s = 1;\n  while (d--) {\n    s *= k;\n    if (s >= n) return 0;\n  }\n  return 1;\n}\nint main(int argc, char const *argv[]) {\n  int n, k, d;\n  cin >> n >> k >> d;\n  if (k >= n) {\n    for (int i = 1; i <= d; i++) {\n      for (int j = 1; j <= n; j++) {\n        if ((i + j) % n == 0)\n          printf(\"%d \", n);\n        else\n          printf(\"%d \", (i + j) % n);\n      }\n      printf(\"\\n\");\n    }\n    return 0;\n  }\n  if (check(d, n, k)) {\n    printf(\"-1\");\n    return 0;\n  } else {\n    int di = 1;\n    int bus = 0, cur = 1;\n    for (int i = 1; i <= d; i++) {\n      for (int j = 1; j <= n; j++) {\n        printf(\"%d \", cur);\n        bus++;\n        if (bus == di) {\n          cur++;\n          bus = 0;\n        }\n        if (cur > k) cur = 1;\n      }\n      di *= k;\n      cur = 1;\n      bus = 0;\n      printf(\"\\n\");\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n    final boolean isFileIO = false; \n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer st = new StringTokenizer(\"\");\n    String delim = \" \";\n\n    public static void main(String[] args) throws IOException {\n        Main m = new Main();\n        m.initIO();\n        m.solve();\n        m.in.close();\n        m.out.close();\n    }\n\n    public void initIO() throws IOException {\n        if(!isFileIO) {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        } else {\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new PrintWriter(\"output.txt\"); \n        }\n    }\n  \n    String nextToken() throws IOException {\n        if(!st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken(delim);\n    }\n \n    String readLine() throws IOException {\n        return in.readLine();\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n    \n    void solve() throws IOException {\n        int n, k, d;\n        n = nextInt(); k = nextInt(); d = nextInt();\n        int[] a = new int[d];\n        Arrays.fill(a, 1);\n        long p = 1;\n        for(int i = 0; i < d; i++) {\n            p *= k;\n            if(p > n)\n                break;\n        }\n        if(p < n) {\n            out.println(-1);\n            return;\n        }\n        int[][] res = new int[d][n];\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < d; j++) {\n                if(a[j] + 1 != k + 1) {\n                    a[j]++;\n                    break;\n                } else {\n                    a[j] = 1;\n                }\n            }\n            for(int j = 0; j < d; j++) {\n                res[j][i] = a[j];\n            }\n        }\n        for(int i = 0; i < d; i++) {\n            for(int j = 0; j < n; j++) {\n                out.print(res[i][j] + \" \");\n            }\n            out.println();\n        }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport static java.lang.System.out;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.StringTokenizer;\n\npublic class Solution {\n\tstatic int[][] ans;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputReader in = new InputReader();\n\t\tint n = in.nextInt();\n\t\tint k = in.nextInt();\n\t\tint d = in.nextInt();\n\t\tlong x = 1;\n\t\tboolean ok = false;\n\n\t\tfor (int i = 0; i < d; i++) {\n\t\t\tx *= k;\n\t\t\tif (x >= n) {\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!ok) {\n\t\t\tout.println(-1);\n\t\t\treturn;\n\t\t}\n\t\tans = new int[n][d];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfor (int j = 0; j < d; j++)\n\t\t\t\tans[i][j] = ans[i - 1][j];\n\t\t\tfor (int j = d - 1; j >= 0; j--) {\n\t\t\t\tans[i][j] = (ans[i][j] + 1) % k;\n\t\t\t\t\n\t\t\t\tif (ans[i][j] != 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t StringBuilder answer = new StringBuilder();\n\t\t\n\t\t for(int i = 0; i < d; i++){\n\t            for(int j = 0; j < n; j++)\n\t                answer.append(ans[j][i] + 1).append(' ');\n\t            answer.append('\\n');\n\t        }\n\t        System.out.print(answer);\n\n\t}\n}\n\nclass InputReader {\n\n\tprivate BufferedReader reader;\n\n\tprivate StringTokenizer tokenizer;\n\n\tpublic InputReader() {\n\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\ttokenizer = null;\n\n\t}\n\n\tpublic String nextLine() {\n\t\ttry {\n\t\t\treturn reader.readLine();\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic String next() {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}"
        },
        {
            "language": 1,
            "solution": "n, k, d = map(int, raw_input().split())\nx = 1\nfor i in range(d):\n\tx *= k\n\tif x >= n:\n\t\tbreak\nelse:\n\tprint '-1'\n\texit(0)\na = [0] * d\nb = [[] for i in range(d)]\nfor i in range(n):\n\tfor j in range(d):\n\t\tb[j].append(a[j])\n\tfor j in range(d)[::-1]:\n\t\ta[j] += 1\n\t\tif a[j] == k:\n\t\t\ta[j] = 0\n\t\telse:\n\t\t\tbreak\nfor i in range(d):\n\tfor j in range(n):\n\t\tprint b[i][j] + 1,\n\tprint ''"
        },
        {
            "language": 1,
            "solution": "def dirichlet(n,k):\n\tq = n/k\n\tif q*k == n:\n\t\treturn q\n\telse:\n\t\treturn q+1\n\ndef possible(n,k,d):\n\tm = n\n\tfor i in range(d):\n\t\tm = dirichlet(m,k)\n\tif (m>1):\n\t\treturn -1\n\telse:\n\t\treturn 1\n\t\ndef rows(n,k,d):\n\trows = []\n\tmod = 1\n\tfor i in range(d):\n\t\trow = []\n\t\tnum = 1\n\t\tfor j in range(n):\n\t\t\trow.append(num)\n\t\t\tif(j % mod == 0):\n\t\t\t\tif(num == k):\n\t\t\t\t\tnum = 1\n\t\t\t\telse:\n\t\t\t\t\tnum+=1\n\t\trows.append(row)\n\t\tmod = mod*k\n\treturn rows\n\t\ndata = [int(n) for n in raw_input().split()]\nn = data[0]\nk = data[1]\nd = data[2]\nif (possible(n,k,d)==1):\n\trows = rows(n,k,d)\n\tfor i in range(d):\n\t\t\trow = (str)(rows[i])\n\t\t\tprint row.strip('[]').replace(\",\", \"\")\n\n\t\t\t\nelse:\n\tprint possible(n,k,d)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author mthai\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CF_459C solver = new CF_459C();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CF_459C {\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int n = in.nextInt(), k = in.nextInt(), d = in.nextInt();\n            if (n > Math.pow(k, d)) {\n                out.println(-1);\n            }\n            else {\n                for (int i = 1; i <= d; ++i) {\n                    int e = d - i, cur = 1;\n                    long step = (int) Math.pow(k, e);\n                    for (int j = 1; j <= n; ++j) {\n                        out.print(cur + \" \");\n                        if (j % step == 0) {\n                            cur++;\n                            if (cur > k) cur = 1;\n                        }\n                    }\n                    out.println();\n                }\n            }\n        }\n\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 1010;\nint a[N], b[N], n, d, k, m, i, j, u;\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &d);\n  if (k >= n) {\n    for (i = 0; i < d; i++) {\n      for (j = 1; j <= n; j++) printf(\"%d \", j);\n      printf(\"\\n\");\n    }\n  } else {\n    m = n;\n    for (i = 0; i < d; i++) m = m / k + (m % k ? 1 : 0);\n    if (m <= 1) {\n      m = n;\n      for (i = 0; i < d; i++) {\n        m = m / k + (m % k ? 1 : 0);\n        for (j = 0; j < n; j++) {\n          if (j && a[j] == a[j - 1])\n            ++u;\n          else\n            u = 0;\n          b[j] = u;\n        }\n        for (j = 0; j < n; j++) a[j] = b[j] / m % k + 1;\n        for (j = 0; j < n; j++) printf(\"%d \", a[j]);\n        printf(\"\\n\");\n      }\n    } else\n      puts(\"-1\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nT nextInt() {\n  T x = 0, p = 1;\n  char ch;\n  do {\n    ch = getchar();\n  } while (ch <= ' ');\n  if (ch == '-') {\n    p = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + (ch - '0');\n    ch = getchar();\n  }\n  return x * p;\n}\nconst int maxN = (int)2e3 + 10;\nconst int maxE = (int)4e5 + 10;\nconst int INF = (int)1e9;\nconst int mod = (int)1e9 + 7;\nconst long long LLINF = (long long)1e18;\nint myPow(int k, int d) {\n  long long res = 1;\n  while (d--) {\n    res *= k;\n    if (res > 1000) return INF;\n  }\n  return res;\n}\nint answer[maxN][maxN];\nint main() {\n  int n, k, d;\n  cin >> n >> k >> d;\n  if (myPow(k, d) < n) {\n    cout << -1 << '\\n';\n    return 0;\n  }\n  for (int i = 1; i <= d; ++i) {\n    answer[1][i] = 1;\n  }\n  for (int i = 2; i <= n; ++i) {\n    int cntK = 0;\n    for (int j = d; j >= 1 && answer[i - 1][j] == k; j--, cntK++)\n      ;\n    for (int j = 1; j <= d; ++j) {\n      if (j < d - cntK) {\n        answer[i][j] = answer[i - 1][j];\n      } else if (j == d - cntK) {\n        answer[i][j] = answer[i - 1][j] + 1;\n      } else {\n        answer[i][j] = 1;\n      }\n    }\n  }\n  for (int j = 1; j <= d; ++j) {\n    for (int i = 1; i <= n; ++i) {\n      cout << answer[i][j] << ' ';\n    }\n    cout << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint check(int n, int k, int d) {\n  int Q = k;\n  for (int i = 1; i <= d; ++i, Q *= k)\n    if (Q >= n) return 0;\n  return 1;\n}\nint a[1111];\nint main() {\n  int n, k, d;\n  a[1] = 1;\n  cin >> n >> k >> d;\n  int flg = 0;\n  if (check(n, k, d)) {\n    cout << -1 << endl;\n    return 0;\n  }\n  int i;\n  for (i = 2; i <= d && a[i - 1] < n; ++i) a[i] = a[i - 1] * k;\n  for (; i <= d; ++i) a[i] = n;\n  for (i = 1; i <= d; ++i) {\n    for (int j = 0; j < n; ++j) cout << (j / a[i]) % k + 1 << \" \";\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\npublic class C {\n\n\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tint D = sc.nextInt();\n\n\t\tif ((BigInteger.valueOf(K).pow(D)).compareTo(BigInteger.valueOf(N)) < 0)\n\t\t\tSystem.out.println(-1);\n\t\telse {\n\t\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\tint[] a = new int[D];\n\t\t\tArrays.fill(a, 1);\n\t\t\tint ans[][] = new int[D][N];\n\t\t\tfor (int d = 0; d < N; d++) {\n\t\t\t\tfor (int cur = 0; cur < D; cur++) {\n\t\t\t\t\tif (a[cur] == K) {\n\t\t\t\t\t\ta[cur] = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta[cur]++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < D; i++)\n\t\t\t\t\tans[i][d] = a[i];\n\t\t\t}\n\t\t\tfor (int i = 0; i < D; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t\t\tout.print(ans[i][j] + \" \");\n\t\t\t\tout.println();\n\t\t\t}\n\t\t\tout.flush();\n\t\t\tout.close();\n\t\t}\n\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic Scanner(String f) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(f));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic int[] nextIntArray1(int n) throws IOException {\n\t\t\tint[] a = new int[n + 1];\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic int[] nextIntArraySorted(int n) throws IOException {\n\t\t\tint[] a = nextIntArray(n);\n\t\t\tRandom r = new Random();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint j = i + r.nextInt(n - i);\n\t\t\t\tint t = a[i];\n\t\t\t\ta[i] = a[j];\n\t\t\t\ta[j] = t;\n\t\t\t}\n\t\t\tArrays.sort(a);\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray1(int n) throws IOException {\n\t\t\tlong[] a = new long[n + 1];\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArraySorted(int n) throws IOException {\n\t\t\tlong[] a = nextLongArray(n);\n\t\t\tRandom r = new Random();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint j = i + r.nextInt(n - i);\n\t\t\t\tlong t = a[i];\n\t\t\t\ta[i] = a[j];\n\t\t\t\ta[j] = t;\n\t\t\t}\n\t\t\tArrays.sort(a);\n\t\t\treturn a;\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long int n, k, d, s = 1;\n  cin >> n >> k >> d;\n  long long int mat[1010][1010];\n  for (int i = 0; i < 1010; i++)\n    for (int j = 0; j < 1010; j++) mat[i][j] = 0;\n  for (int i = 1; i < n; i++) {\n    for (int j = 0; j < d; j++) mat[i][j] = mat[i - 1][j];\n    long long int carry = 1;\n    for (int j = 0; j < d; j++) {\n      long long int temp = mat[i][j];\n      mat[i][j] = (mat[i][j] + carry) % k;\n      carry = (carry + temp) / k;\n    }\n    if (carry > 0) {\n      cout << -1 << endl;\n      return 0;\n    }\n  }\n  for (int i = 0; i < d; i++) {\n    for (int j = 0; j < n; j++) {\n      cout << mat[j][i] + 1 << \" \";\n    }\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "//package com.a2onlinejudge.ladder.CodeforcesDiv2C;\n\nimport java.io.*;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\n/**\n * Created by rahulkhairwar on 22/03/16.\n */\npublic final class PashmakAndBuses\n{\n\tstatic int n, k, d, arr[][];\n\tstatic InputReader in;\n\tstatic OutputWriter out;\n\n\tpublic static void main(String[] args)\n\t{\n\t\tin = new InputReader(System.in);\n\t\tout = new OutputWriter(System.out);\n\n\t\tsolve();\n\n\t\tout.flush();\n\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void solve()\n\t{\n\t\tn = in.nextInt();\n\t\tk = in.nextInt();\n\t\td = in.nextInt();\n\n\t\tlong temp = 1;\n\t\tboolean possible = false;\n\n\t\tfor (int i = 0; i < d; i++)\n\t\t{\n\t\t\ttemp *= k;\n\n\t\t\tif (temp >= n)\n\t\t\t{\n\t\t\t\tpossible = true;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!possible)\n\t\t{\n\t\t\tout.println(\"-1\");\n\n\t\t\treturn;\n\t\t}\n\n\t\tint[][] answer = new int[n][d];\n\n\t\tfor (int i = 1; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < d; j++)\n\t\t\t\tanswer[i][j] = answer[i - 1][j];\n\n\t\t\tanswer[i][d - 1]++;\n//\t\t\tSystem.out.println(\"** \" + Arrays.toString(answer[i]));\n\n\t\t\tfor (int j = d - 1; j > 0; j--)\n\t\t\t{\n\t\t\t\tif (answer[i][j] >= k)\n\t\t\t\t{\n//\t\t\t\t\tSystem.out.println(\"i : \" + i + \", j : \" + j);\n\t\t\t\t\tanswer[i][j] = 0;\n\t\t\t\t\tanswer[i][j - 1]++;\n//\t\t\t\t\tSystem.out.println(\"\\t&& \" + Arrays.toString(answer[i]));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < d; i++, out.println())\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tout.print((answer[j][i] + 1) + \" \");\n\n/*\t\tfor (int i = 1; i < d; i++, out.println())\n\t\t{\n//\t\t\tanswer[n - 1]++;\n\n\t\t\tfor (int j = n - 1; j >= 0; j--)\n\t\t\t{\n\t\t\t\tif (answer[j] >= k)\n\t\t\t\t{\n\t\t\t\t\tanswer[j]--;\n\t\t\t\t\tanswer[j - 1]++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tout.print((answer[j] + 1) + \" \");\n\t\t}*/\n\t}\n\n\tstatic class InputReader\n\t{\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic InputReader(InputStream stream)\n\t\t{\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic int read()\n\t\t{\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\n\t\t\tif (curChar >= numChars)\n\t\t\t{\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int nextInt()\n\t\t{\n\t\t\tint c = read();\n\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\n\t\t\tint sgn = 1;\n\n\t\t\tif (c == '-')\n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\n\t\t\tint res = 0;\n\n\t\t\tdo\n\t\t\t{\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\n\t\t\t\tres *= 10;\n\t\t\t\tres += c & 15;\n\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic int[] nextIntArray(int arraySize)\n\t\t{\n\t\t\tint array[] = new int[arraySize];\n\n\t\t\tfor (int i = 0; i < arraySize; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic long nextLong()\n\t\t{\n\t\t\tint c = read();\n\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\n\t\t\tint sign = 1;\n\n\t\t\tif (c == '-')\n\t\t\t{\n\t\t\t\tsign = -1;\n\n\t\t\t\tc = read();\n\t\t\t}\n\n\t\t\tlong result = 0;\n\n\t\t\tdo\n\t\t\t{\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\n\t\t\t\tresult *= 10;\n\t\t\t\tresult += c & 15;\n\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\n\t\t\treturn result * sign;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int arraySize)\n\t\t{\n\t\t\tlong array[] = new long[arraySize];\n\n\t\t\tfor (int i = 0; i < arraySize; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic float nextFloat() // problematic\n\t\t{\n\t\t\tfloat result, div;\n\t\t\tbyte c;\n\n\t\t\tresult = 0;\n\t\t\tdiv = 1;\n\t\t\tc = (byte) read();\n\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = (byte) read();\n\n\t\t\tboolean isNegative = (c == '-');\n\n\t\t\tif (isNegative)\n\t\t\t\tc = (byte) read();\n\n\t\t\tdo\n\t\t\t{\n\t\t\t\tresult = result * 10 + c - '0';\n\t\t\t} while ((c = (byte) read()) >= '0' && c <= '9');\n\n\t\t\tif (c == '.')\n\t\t\t\twhile ((c = (byte) read()) >= '0' && c <= '9')\n\t\t\t\t\tresult += (c - '0') / (div *= 10);\n\n\t\t\tif (isNegative)\n\t\t\t\treturn -result;\n\n\t\t\treturn result;\n\t\t}\n\n\t\tpublic double nextDouble() // not completely accurate\n\t\t{\n\t\t\tdouble ret = 0, div = 1;\n\t\t\tbyte c = (byte) read();\n\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = (byte) read();\n\n\t\t\tboolean neg = (c == '-');\n\n\t\t\tif (neg)\n\t\t\t\tc = (byte) read();\n\n\t\t\tdo\n\t\t\t{\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = (byte) read()) >= '0' && c <= '9');\n\n\t\t\tif (c == '.')\n\t\t\t\twhile ((c = (byte) read()) >= '0' && c <= '9')\n\t\t\t\t\tret += (c - '0') / (div *= 10);\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic String next()\n\t\t{\n\t\t\tint c = read();\n\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\n\t\t\tStringBuilder res = new StringBuilder();\n\n\t\t\tdo\n\t\t\t{\n\t\t\t\tres.appendCodePoint(c);\n\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c)\n\t\t{\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tpublic String nextLine()\n\t\t{\n\t\t\tint c = read();\n\n\t\t\tStringBuilder result = new StringBuilder();\n\n\t\t\tdo\n\t\t\t{\n\t\t\t\tresult.appendCodePoint(c);\n\n\t\t\t\tc = read();\n\t\t\t} while (!isNewLine(c));\n\n\t\t\treturn result.toString();\n\t\t}\n\n\t\tpublic boolean isNewLine(int c)\n\t\t{\n\t\t\treturn c == '\\n';\n\t\t}\n\n\t\tpublic void close()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tstream.close();\n\t\t\t} catch (IOException e)\n\t\t\t{\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t}\n\n\tstatic class OutputWriter\n\t{\n\t\tprivate PrintWriter writer;\n\n\t\tpublic OutputWriter(OutputStream stream)\n\t\t{\n\t\t\twriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(\n\t\t\t\t\tstream)));\n\t\t}\n\n\t\tpublic OutputWriter(Writer writer)\n\t\t{\n\t\t\tthis.writer = new PrintWriter(writer);\n\t\t}\n\n\t\tpublic void println(int x)\n\t\t{\n\t\t\twriter.println(x);\n\t\t}\n\n\t\tpublic void print(int x)\n\t\t{\n\t\t\twriter.print(x);\n\t\t}\n\n\t\tpublic void println(int array[], int size)\n\t\t{\n\t\t\tfor (int i = 0; i < size; i++)\n\t\t\t\tprintln(array[i]);\n\t\t}\n\n\t\tpublic void print(int array[], int size)\n\t\t{\n\t\t\tfor (int i = 0; i < size; i++)\n\t\t\t\tprint(array[i] + \" \");\n\t\t}\n\n\t\tpublic void println(long x)\n\t\t{\n\t\t\twriter.println(x);\n\t\t}\n\n\t\tpublic void print(long x)\n\t\t{\n\t\t\twriter.print(x);\n\t\t}\n\n\t\tpublic void println(long array[], int size)\n\t\t{\n\t\t\tfor (int i = 0; i < size; i++)\n\t\t\t\tprintln(array[i]);\n\t\t}\n\n\t\tpublic void print(long array[], int size)\n\t\t{\n\t\t\tfor (int i = 0; i < size; i++)\n\t\t\t\tprint(array[i]);\n\t\t}\n\n\t\tpublic void println(float num)\n\t\t{\n\t\t\twriter.println(num);\n\t\t}\n\n\t\tpublic void print(float num)\n\t\t{\n\t\t\twriter.print(num);\n\t\t}\n\n\t\tpublic void println(double num)\n\t\t{\n\t\t\twriter.println(num);\n\t\t}\n\n\t\tpublic void print(double num)\n\t\t{\n\t\t\twriter.print(num);\n\t\t}\n\n\t\tpublic void println(String s)\n\t\t{\n\t\t\twriter.println(s);\n\t\t}\n\n\t\tpublic void print(String s)\n\t\t{\n\t\t\twriter.print(s);\n\t\t}\n\n\t\tpublic void println()\n\t\t{\n\t\t\twriter.println();\n\t\t}\n\n\t\tpublic void printSpace()\n\t\t{\n\t\t\twriter.print(\" \");\n\t\t}\n\n\t\tpublic void flush()\n\t\t{\n\t\t\twriter.flush();\n\t\t}\n\n\t\tpublic void close()\n\t\t{\n\t\t\twriter.close();\n\t\t}\n\n\t}\n\n\tstatic class CMath\n\t{\n\t\tstatic long power(long number, long power)\n\t\t{\n\t\t\tif (number == 1 || number == 0 || power == 0)\n\t\t\t\treturn 1;\n\n\t\t\tif (power == 1)\n\t\t\t\treturn number;\n\n\t\t\tif (power % 2 == 0)\n\t\t\t\treturn power(number * number, power / 2);\n\t\t\telse\n\t\t\t\treturn power(number * number, power / 2) * number;\n\t\t}\n\n\t\tstatic long modPower(long number, long power, long mod)\n\t\t{\n\t\t\tif (number == 1 || number == 0 || power == 0)\n\t\t\t\treturn 1;\n\n\t\t\tnumber = mod(number, mod);\n\n\t\t\tif (power == 1)\n\t\t\t\treturn number;\n\n\t\t\tlong square = mod(number * number, mod);\n\n\t\t\tif (power % 2 == 0)\n\t\t\t\treturn modPower(square, power / 2, mod);\n\t\t\telse\n\t\t\t\treturn mod(modPower(square, power / 2, mod) * number, mod);\n\t\t}\n\n\t\tstatic long moduloInverse(long number, long mod)\n\t\t{\n\t\t\treturn modPower(number, mod - 2, mod);\n\t\t}\n\n\t\tstatic long mod(long number, long mod)\n\t\t{\n\t\t\treturn number - (number / mod) * mod;\n\t\t}\n\n\t}\n\n}\n\n/*\n\n12 5 3\n\n */\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(in, out);\n        out.close();\n    }\n}\n\nclass TaskC {\n\n\n    public void solve(InputReader in, OutputWriter out) {\n        int n,k,d;\n        n = in.nextInt();\n        k = in.nextInt();\n        d = in.nextInt();\n        long result = 1;\n        for (int i = 0; i < d; i++) {\n            result *= k;\n            if(result > n) {\n                break;\n            }\n        }\n        if(n > result) {\n            System.out.println(-1);\n            return;\n        }\n        int[][] a = new int[d][n];\n        for(int i=0;i<n;i++) {\n            int x = i;\n            for(int j=0;j<d;j++) {\n                a[j][i] = x % k +1;\n                x /= k;\n            }\n        }\n\n\n        for (int i=0; i<d; i++) {\n            for (int j=0; j<n; j++) out.print(a[i][j] + \" \");\n            out.printLine();\n        }\n\n    }\n\n}\n\n\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n}\n\nclass OutputWriter {\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n        this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n        for (int i = 0; i < objects.length; i++) {\n            if (i != 0) {\n                writer.print(' ');\n            }\n            writer.print(objects[i]);\n        }\n    }\n\n    public void printLine(Object... objects) {\n        print(objects);\n        writer.println();\n    }\n\n    public void close() {\n        writer.close();\n    }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, d, sl;\nint a[1010][1010], b[1010];\nvoid nhap() { cin >> n >> k >> d; }\nvoid cbi() {\n  if ((d == 1 && k < n)) {\n    cout << -1;\n    exit(0);\n  }\n  if (k >= n) {\n    for (int j = 1; j <= d; j++) {\n      for (int i = 1; i <= n; i++) printf(\"%d \", i);\n      printf(\"\\n\");\n    }\n    exit(0);\n  }\n}\nbool ktra() {\n  long long gt = 1;\n  for (int i = 1; i <= d; i++) {\n    gt *= k;\n    if (gt >= 1ll * n) return 1;\n  }\n  return 0;\n}\nvoid duyet(int u) {\n  if (u > d) {\n    sl++;\n    for (int i = 1; i <= d; i++) a[sl][i] = b[i];\n    return;\n  }\n  for (int i = 1; i <= k; i++) {\n    b[u] = i;\n    duyet(u + 1);\n    if (sl >= n) return;\n  }\n}\nvoid xuli() {\n  memset(a, 0, sizeof(a));\n  memset(b, 0, sizeof(b));\n  if (ktra()) {\n    duyet(1);\n    for (int i = 1; i <= d; i++) {\n      for (int j = 1; j <= n; j++) cout << a[j][i] << \" \";\n      cout << endl;\n    }\n  } else {\n    cout << -1;\n    return;\n  }\n}\nvoid ghikq() {}\nint main() {\n  nhap();\n  cbi();\n  xuli();\n  ghikq();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[1001][1001], k, d, n, tmp = 0;\nvoid f(int l, int r, int p) {\n  if (p == d + 1) return;\n  if (p == d && r - l >= k) {\n    tmp = 1;\n    return;\n  }\n  if (r - l < k) {\n    int s = 0;\n    for (int i = l; i <= r; ++i) {\n      ++s;\n      a[p][i] = s;\n    }\n    f(l, r, p + 1);\n    return;\n  }\n  int yu = (r - l + 1) % k, sh = (r - l + 1) / k;\n  for (int i = 1; i <= k - 1; ++i) {\n    int t = (i - 1) * sh + l, t2 = i * sh + l;\n    for (int j = t; j < t2; ++j) {\n      a[p][j] = i;\n    }\n    f(t, t2 - 1, p + 1);\n  }\n  int t = sh * (k - 1) + l;\n  for (int i = t; i <= r; ++i) {\n    a[p][i] = k;\n  }\n  f(t, r, p + 1);\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &d);\n  f(1, n, 1);\n  if (tmp == 1) {\n    printf(\"-1\");\n  } else {\n    for (int i = 1; i <= d; ++i) {\n      for (int j = 1; j <= n; ++j) printf(\"%d \", a[i][j]);\n      printf(\"\\n\");\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "import sys\n\n#sys.stdin = open('in', 'r')\n\nn, k, d = map(int, raw_input().split())\nif d == 1 and k < n or k == 1 and n > 1:\n  print -1\n  exit(0)\nif k == 1 and n == 1:\n  for i in xrange(d):\n    print 1\n  exit(0)\n\ntemp, count = k, 1\nwhile temp < n:\n  temp *= k\n  count += 1\n\nif count > d:\n  print -1\nelse:\n  res = [[0] * n for _ in xrange(d)]\n  for j in xrange(n):\n    cur = j\n    for i in xrange(d):\n      res[i][j] = cur % k + 1\n      cur /= k\n  for i in xrange(d):\n    for j in xrange(n):\n      if j == n - 1:\n        print res[i][j]\n      else:\n        print res[i][j],\n"
        },
        {
            "language": 3,
            "solution": "n, k, d = map(int, input().split())\nans = [[0 for j in range(n)] for i in range(d)]\nif any(1 for i in range(d) if k**(i + 1) >= n):\n  for i in range(n):\n    N = i\n    for j in range(d):\n      ans[j][i] = 1 + N % k\n      N //= k\n  for i in range(d):\n    print(' '.join(map(str, ans[i])))\nelse:\n  print(-1)\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.text.DecimalFormat;\nimport java.lang.Math;\nimport java.util.Iterator; \npublic class C47{\n    \n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n=sc.nextInt(),k=sc.nextInt(),d=sc.nextInt();\n        boolean f=false;\n        int cnt=0;\n        for (int i=k;;i*=k){\n            if (n<=i){\n                f=true;\n                break;\n            }\n            cnt++;\n            if (cnt==d)break;\n        }\n        if (!f) System.out.println(-1);\n        else {\n            int seq[][]=new int[n][d];\n            for (int i=0;i<n;i++){\n                int c=d-1;\n                int x=i;\n                while (x!=0){\n                    seq[i][c--]=x%k;\n                    x/=k;\n                }\n            }\n            StringBuilder sb=new StringBuilder();\n            for (int i=0;i<d;i++){\n                for (int j=0;j<n;j++){\n                    sb.append(seq[j][i]+1);sb.append(\" \");\n                }\n                sb.append(\"\\n\");\n            }\n            System.out.print(sb);\n        }\n\n\t}\n\t////////////////////////////////////////////////////////////////////////////////\n\tstatic class Pair implements Comparable<Pair>{\n\t\tint x;\n\t\tint y;\n\t\tpublic Pair(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tif(this.x==o.x){\n\t\t\t    return this.y-o.y;\n\t\t\t}\n\t\t\treturn this.x-o.x;\n\t\t}\n\t}\n\tpublic static boolean isPrime(int n){\n\t    if(n < 2){\n\t        return false;\n\t    }\n\t    if(n%2==0){\n\t        return n==2;\n\t    }\n\t    if(n%3==0){\n\t        return n==3;\n\t    }\n\t    int i = 5;\n\t    int h = (int)Math.floor(Math.sqrt(n)+1);\n\t    while(i <= h){\n\t        if(n%i==0){\n\t            return false;\n\t        }\n\t        if(n%(i+2)==0){\n\t            return false;\n\t        }\n\t        i += 6;\n\t    }\n\t    return true;\n\t}\n\tpublic static long gcd(long a, long b){\n\t    return b==0? a:gcd(b, a%b);\n\t}\n\tpublic static long bSearch(int n,ArrayList<Long> A){\n\t    int s = 0;\n\t    int e = A.size()-1;\n\t    while(s<=e){\n\t        int m = s+(e-s)/2;\n\t        if(A.get(m)==(long)n){\n\t            return A.get(m);\n\t        }\n\t        else if(A.get(m)>(long)n){\n\t            e = m-1;\n\t        }\n\t        else{\n\t            s = m+1;\n\t        }\n\t    }\n\t    return A.get(s);\n\t}\n\tstatic class Point implements Comparable<Point>{\n\t\tint x;\n\t\tint y;\n\t\tpublic Point(int x, int y){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Point o) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tif(this.x==o.x){\n\t\t\t    return this.y-o.y;\n\t\t\t}\n\t\t\treturn this.x-o.x;\n\t\t}\n\t}\n\tpublic static long[] fact;\n\tpublic static final long modulo = 1000000007;\n\tpublic static long modinv(long x){\n\t    return modpow(x, modulo-2);\n\t}\n\tpublic static long modpow(long a, long b){\n\t    if(b==0){\n\t        return 1;\n\t    }\n\t    long x = modpow(a, b/2);\n\t    x = (x*x)%modulo;\n\t    if(b%2==1){\n\t        return (x*a)%modulo;\n\t    }\n\t    return x;\n\t}\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, d, k;\nint main() {\n  cin >> n >> k >> d;\n  if (k >= n) {\n    for (int i = 0; i < d; i++) {\n      for (int j = 0; j < n; j++) {\n        cout << j + 1 << ' ';\n      }\n      cout << endl;\n    }\n    return 0;\n  }\n  long long ans = 1;\n  bool b = false;\n  for (int j = 0; j < d; j++) {\n    ans *= 1LL * k;\n    if (ans >= n) {\n      b = true;\n      break;\n    }\n  }\n  if (!b) {\n    cout << -1 << endl;\n    return 0;\n  }\n  ans = 1;\n  for (int i = 0; i < d; i++) {\n    int s = 0;\n    int t = 1;\n    for (int j = 0; j < n; j++) {\n      s++;\n      if (s > ans) {\n        t++;\n        s = 1;\n      }\n      if (t > k) {\n        t = 1;\n      }\n      printf(\"%d\\n\", t);\n    }\n    ans *= k;\n    if (ans > 10000LL) {\n      ans = 10000LL;\n    }\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "n,k,d=map(int,input().split())\np=1\nfor i in range(d):\n    p*=k\n    if p>=n:\n        break\ns=[i for i in range(n)]\nif n>p:\n    print(-1)\nelse:\n    for i in range(d):\n        ans=\"\"\n        for j in range(n):\n            ans += str(s[j] % k + 1) + ' '\n            s[j] //= k\n        print(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nT trace2(T a, T b) {\n  cerr << a << \" \" << b << '\\n';\n}\ntemplate <typename T>\nT trace3(T a, T b, T c) {\n  cerr << a << \" \" << b << \" \" << c << '\\n';\n}\ntemplate <typename T>\nT trace4(T a, T b, T c, T d) {\n  cerr << a << \" \" << b << \" \" << c << \" \" << d << '\\n';\n}\ntemplate <typename T>\nT trace5(T a, T b, T c, T d, T e) {\n  cerr << a << \" \" << b << \" \" << c << \" \" << d << \" \" << e << '\\n';\n}\ntemplate <typename T>\nT trace6(T a, T b, T c, T d, T e, T f) {\n  cerr << a << \" \" << b << \" \" << c << \" \" << d << \" \" << e << \" \" << f << '\\n';\n}\nvoid err(istream_iterator<string> it) {}\ntemplate <typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args) {\n  cerr << *it << \" = \" << a << '\\n';\n  err(++it, args...);\n}\ntemplate <typename T>\nT pow(T a, T b, long long int m) {\n  T ans = 1;\n  while (b > 0) {\n    if (b % 2 == 1) ans = (ans * a) % m;\n    b /= 2;\n    a = (a * a) % m;\n  }\n  return ans % m;\n}\nvoid swap(long long int *a, long long int *b) {\n  long long int temp = *a;\n  *a = *b;\n  *b = temp;\n  return;\n}\nlong long int n, k, d;\nlong long int arr[1000 + 10][1000 + 10];\nbool check() {\n  long long int p = 1;\n  for (__typeof(d) i = (0) - ((0) > (d)); i != (d) - ((0) > (d));\n       i += 1 - 2 * ((0) > (d))) {\n    p *= k;\n    if (p >= n) {\n      return true;\n    }\n  }\n  return false;\n}\nvoid cal() {\n  for (long long int i = 1; i <= n; i++) {\n    long long int temp = i;\n    long long int idx = 0;\n    while (temp) {\n      arr[i][idx] = (temp % k);\n      temp = temp / k;\n      idx++;\n    }\n  }\n}\nvoid print() {\n  for (long long int i = 0; i < d; i++) {\n    for (long long int j = 1; j <= n; j++) {\n      cout << arr[j][i] + 1 << \" \";\n    }\n    cout << '\\n';\n  }\n}\nvoid fuck() {\n  cin >> n >> k >> d;\n  if (k >= n) {\n    std::vector<long long int> v;\n    for (__typeof(n + 1) i = (1) - ((1) > (n + 1));\n         i != (n + 1) - ((1) > (n + 1)); i += 1 - 2 * ((1) > (n + 1)))\n      v.push_back(i);\n    for (__typeof(d) i = (0) - ((0) > (d)); i != (d) - ((0) > (d));\n         i += 1 - 2 * ((0) > (d))) {\n      for (auto i : v) cout << i << \" \";\n      cout << '\\n';\n      long long int temp = *(v.begin());\n      v.erase(v.begin());\n      v.push_back(temp);\n    }\n    exit(0);\n  }\n  if (k == 1 || d == 1) {\n    cout << -1 << '\\n';\n    exit(0);\n  }\n  if (d >= n) {\n    std::vector<long long int> v;\n    v.push_back(2);\n    for (__typeof(n) i = (1) - ((1) > (n)); i != (n) - ((1) > (n));\n         i += 1 - 2 * ((1) > (n)))\n      v.push_back(1);\n    for (__typeof(d) i = (0) - ((0) > (d)); i != (d) - ((0) > (d));\n         i += 1 - 2 * ((0) > (d))) {\n      for (auto i : v) cout << i << \" \";\n      cout << '\\n';\n      long long int temp = *(v.begin());\n      v.erase(v.begin());\n      v.push_back(temp);\n    }\n    exit(0);\n  }\n  if (check() == false) {\n    cout << -1 << '\\n';\n    exit(0);\n  }\n  cal();\n  print();\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ;\n  fuck();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long a[1005][1005];\nint main() {\n  long long n, k, d;\n  cin >> n >> k >> d;\n  long long tavan = 1;\n  for (int i = 0; i < d && tavan < n; i++) tavan *= k;\n  if (tavan < n) {\n    cout << -1 << endl;\n    return 0;\n  }\n  for (int i = 0; i < n; i++) {\n    int x = i;\n    for (int j = 0; x != 0; j++) {\n      a[i][j] = x % k;\n      x /= k;\n    }\n  }\n  for (int i = 0; i < d; i++) {\n    for (int j = 0; j < n; j++) cout << a[j][i] + 1 << ' ';\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, k, d, i, j;\n  cin >> n >> k >> d;\n  vector<int> v(n, 0);\n  v[n - 1] = n - 1;\n  for (i = 0; i < d; i++) v[n - 1] /= k;\n  if (v[n - 1]) {\n    cout << -1;\n    return 0;\n  }\n  for (i = 0; i < n; i++) v[i] = i;\n  for (i = 0; i < d; i++) {\n    for (j = 0; j < n; j++) {\n      cout << v[j] % k + 1 << \" \";\n      v[j] = v[j] / k;\n    }\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Cf261C {\n\n\tstatic int n, k, d;\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner in = new Scanner(System.in);\n\t\tn = in.nextInt();\n\t\tlong pow = 1;\n\t\tk = in.nextInt();\n\t\td = in.nextInt();\n\t\tint[][] a = new int[n][d];\n\t\tfor (int i = 0; i < d; i++) {\n\t\t\tpow *= k;\n\t\t\tif (pow > Integer.MAX_VALUE) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (n > pow) {\n\t\t\tSystem.out.println(-1);\n\t\t} else {\n\t\t\tfor (int[] i : a) {\n\t\t\t\tArrays.fill(i, 1);\n\t\t\t}\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\ta[i] = Arrays.copyOf(a[i - 1], a[i].length);\n\t\t\t\ta[i] = plusOne(a[i], d - 1);\n\t\t\t}\n\t\t\tfor (int i = 0; i < d; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tout.print(a[j][i] + \" \");\n\t\t\t\t}\n\t\t\t\tout.println();\n\t\t\t}\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static int[] plusOne(int[] digits, int index) {\n\t\tif (index == -1)\n\t\t\treturn digits;\n\t\tif (digits[index] == k) {\n\t\t\tdigits[index] = 1;\n\t\t\treturn plusOne(digits, index - 1);\n\t\t} else {\n\t\t\tdigits[index]++;\n\t\t\treturn digits;\n\t\t}\n\t}\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.StringTokenizer;\n\npublic class Solution {\n\n\tstatic InputReader in = new InputReader(System.in);\n\tstatic int mod = (int) (1e9 + 7);\n\tstatic BufferedWriter out = new BufferedWriter(new OutputStreamWriter(\n\t\t\tSystem.out));\n\n\tprivate static int divCeil(int x, int y) {\n\t\tint res = x / y;\n\t\tif (x % y > 0) {\n\t\t\t++res;\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tint n = in.nextInt();\n\t\tint k = in.nextInt();\n\t\tint d = in.nextInt();\n\n\t\tStringBuilder[] res = new StringBuilder[d];\n\n\t\tfor (int i = 0; i < res.length; i++) {\n\t\t\tres[i] = new StringBuilder();\n\t\t}\n\n\t\tint[] arr = new int[d];\n\t\tArrays.fill(arr, 1);\n\n\t\tif (divCeil(n, (int) Math.pow(k, d)) > 1) {\n\t\t\tout.write(\"-1\");\n\t\t} else {\n\n\t\t\tint count = 1;\n\n\t\t\tfor (int j = 0; j < d; j++) {\n\t\t\t\tres[j].append(\" \").append(arr[j]);\n\t\t\t}\n\n\t\t\twhile (count < n) {\n\n\t\t\t\tarr[d - 1]++;\n\n\t\t\t\tif (arr[d - 1] > k) {\n\n\t\t\t\t\tarr[d - 1] = 1;\n\n\t\t\t\t\tfor (int i = d - 2; i >= 0; i--) {\n\t\t\t\t\t\tif (arr[i] + 1 > k) {\n\t\t\t\t\t\t\tarr[i] = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tarr[i]++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor (int j = 0; j < d; j++) {\n\t\t\t\t\tres[j].append(\" \").append(arr[j]);\n\t\t\t\t}\n\n\t\t\t\tcount++;\n\t\t\t}\n\n\t\t\tfor (int i = res.length - 1; i >= 0; i--) {\n\t\t\t\tout.write(res[i].toString().trim());\n\t\t\t\tout.newLine();\n\t\t\t}\n\t\t}\n\n\t\tout.flush();\n\t}\n}\n\nclass ListComparator implements Comparator<Integer> {\n\n\t@Override\n\tpublic int compare(Integer e1, Integer e2) {\n\t\treturn e2.compareTo(e1);\n\t}\n}\n\nclass ArrayComparator implements Comparator<int[]> {\n\t@Override\n\tpublic int compare(int[] o1, int[] o2) {\n\n\t\tlong res1 = Math.abs(o1[0]) + Math.abs(o1[1]);\n\t\tlong res2 = Math.abs(o2[0]) + Math.abs(o2[1]);\n\t\treturn Long.compare(res1, res2);\n\t}\n};\n\nclass Pair {\n\n\tint x;\n\tint y;\n\n\tpublic Pair(int x, int y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Pair [x=\" + x + \", y=\" + y + \"]\";\n\t}\n}\n\nclass InputReader {\n\tprivate BufferedReader reader;\n\tprivate StringTokenizer tokenizer;\n\n\tpublic InputReader(InputStream stream) {\n\t\treader = new BufferedReader(new InputStreamReader(stream), 32768);\n\t\ttokenizer = null;\n\t}\n\n\tpublic String next() {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tpublic String readLine() {\n\t\ttry {\n\t\t\treturn reader.readLine();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tpublic float nextFloat() {\n\t\treturn Float.parseFloat(next());\n\t}\n\n}"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.*;\nimport java.io.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class j6 implements Runnable {\n\n    long md=1000000007;\n\n\n    long power(long x, long y, long p)\n    {\n\n        long res = 1;\n\n        x=(x % p);\n\n        while (y > 0)\n        {\n\n            if((y & 1)==1)\n                res = ((res%p) * (x%p))% p;\n\n            y =y >> 1;\n            x =((x%p)*(x%p))%p;\n        }\n        return res;\n    }\n\n    long gcd(long a,long b)\n    {\n        if(a==0)\n            return b;\n        else\n            return gcd(b%a,a);\n    }\n    public void run(){\n\n        InputReader in =  new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n        \n        long n=in.nextLong();\n        long k=in.nextLong();\n        long d=in.nextLong();\n        \n        //n>k^d gg        \n        \n        long k1=k;\n        \n        int f=0;\n        \n        for(int i=0;i<d;i++)\n        {\n        \tif(k1>=n)\n        \t{\n        \t\tf=1;\n        \t\tbreak;\n        \t}\n        \t\n        \tk1*=k;\n        }\n        \n        //first n d digit nos.in k base\n        if(f==1)\n        {\n        \tint[] ans=new int[(int)n];\n            for(int i=0;i<n;i++)\n            \tans[i]=i;\n            \n            for(int i=0;i<d;i++)\n            {\n            \tfor(int j=0;j<n;j++)\n            \t{\n            \t\tw.print((ans[j]%k + 1)+\" \");\n            \t\tans[j]/=k;\n            \t}\n            \tw.println();\n            }\n        }\n        else\n        \tw.println(-1);\n        w.close();\n        \n\n    }\n\n    static class InputReader {\n\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream)\n        {\n            this.stream = stream;\n        }\n\n        public int read()\n        {\n            if (numChars==-1)\n                throw new InputMismatchException();\n\n            if (curChar >= numChars)\n            {\n                curChar = 0;\n                try\n                {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e)\n                {\n                    throw new InputMismatchException();\n                }\n\n                if(numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine()\n        {\n            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt()\n        {\n            int c = read();\n\n            while(isSpaceChar(c))\n                c = read();\n\n            int sgn = 1;\n\n            if (c == '-')\n            {\n                sgn = -1;\n                c = read();\n            }\n\n            int res = 0;\n            do\n            {\n                if(c<'0'||c>'9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res * sgn;\n        }\n\n        public long nextLong()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-')\n            {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n\n            do\n            {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-')\n            {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.')\n            {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.')\n            {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c))\n                {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public String readString()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do\n            {\n                res.appendCodePoint(c);\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c)\n        {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next()\n        {\n            return readString();\n        }\n\n        public interface SpaceCharFilter\n        {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    public static void main(String args[]) throws Exception\n    {\n        new Thread(null, new j6(),\"j6\",1<<26).start();\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, d, cnt, tb[1005];\nvector<int> v[1005];\nvoid gen(int idx) {\n  int i;\n  if (idx == d) {\n    for (i = 0; i < d; i++) {\n      v[cnt].push_back(tb[i]);\n    }\n    cnt++;\n    return;\n  }\n  for (i = 1; i <= k && cnt < n; i++) {\n    tb[idx] = i;\n    gen(idx + 1);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> k >> d;\n  gen(0);\n  if (cnt < n) {\n    cout << \"-1\\n\";\n  } else {\n    int i, j;\n    for (i = 0; i < d; i++) {\n      for (j = 0; j < n; j++) {\n        cout << v[j][i] << ' ';\n      }\n      cout << '\\n';\n    }\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.awt.*;\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.math.MathContext;\nimport java.math.RoundingMode;\nimport java.util.*;\n\npublic class Abc {\n    public static void main(String[] args) {\n        FastReader sc = new FastReader();\n        int n=sc.nextInt(),k=sc.nextInt(),d=sc.nextInt();\n        boolean f=false;\n        int cnt=0;\n        for (int i=k;;i*=k){\n            if (n<=i){\n                f=true;\n                break;\n            }\n            cnt++;\n            if (cnt==d)break;\n        }\n        if (!f) System.out.println(-1);\n        else {\n            int seq[][]=new int[n][d];\n            for (int i=0;i<n;i++){\n                int c=d-1;\n                int x=i;\n                while (x!=0){\n                    seq[i][c--]=x%k;\n                    x/=k;\n                }\n            }\n            StringBuilder sb=new StringBuilder();\n            for (int i=0;i<d;i++){\n                for (int j=0;j<n;j++){\n                    sb.append(seq[j][i]+1);sb.append(\" \");\n                }\n                sb.append(\"\\n\");\n            }\n            System.out.print(sb);\n        }\n    }\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long bigmod(long long a, long long b, long long m) {\n  if (b == 0) return 1 % m;\n  long long x = bigmod(a, b / 2, m);\n  x = (x % m * x % m) % m;\n  if (b % 2) x = (x % m * a % m) % m;\n  return x;\n}\nint main() {\n  long long n, k, d, p, an = 0;\n  cin >> n >> k >> d;\n  p = k;\n  for (int i = 0; i < d; i++) {\n    if (n <= p) {\n      an = 1;\n      break;\n    }\n    p *= k;\n  }\n  if (!an) return 0 & puts(\"-1\");\n  vector<vector<int> > a;\n  for (int i = 0; i < n; i++) {\n    int m = i;\n    vector<int> s;\n    while (m && s.size() < d) {\n      s.push_back(m % k);\n      m /= k;\n    }\n    while (s.size() < d) s.push_back(0);\n    a.push_back(s);\n  }\n  for (int i = 0; i < d; i++) {\n    for (int j = 0; j < n; j++) cout << a[j][i] + 1 << \" \";\n    puts(\"\");\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.util.Scanner;\n\npublic class C_Pashmak_and_Buses {\n\tpublic static void main(String ar[]) {\n\t\tScanner x = new Scanner(System.in);\n\t\tlong n = x.nextInt(), k = x.nextInt(), d = x.nextInt(), limit = k;\n\t\tOutputStream outputStream = System.out;\n\t\t \n\t\tOutputWriter out = new OutputWriter(outputStream);\n\t\tif (Math.pow(k, d) >= n) {\n\t\t\t\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tout.print((j % k + 1) + \" \");\n\t\t\tout.println();\n\t\t\t\t//System.out.print((j % k + 1) + \" \");\n\t\t\t//System.out.println();\n\t\t\t\n\t\t\tfor (int i = 1; i < d; i++) {\n\t\t\t\tif (limit >= n) {\n\t\t\t\t\tfor (int j = 0 ; j < n; j++)\n\t\t\t\t\t\t//System.out.print(\"1 \");\n\t\t\t\t\t\tout.print(\"1 \");\n\t\t\t\t} else {\n\t\t\t\t\tfor (int j = 0, t = 0, p = 1; j < n; j++, t++) {\n\t\t\t\t\t\tif (t == limit) {\n\t\t\t\t\t\t\tif (p == k)\n\t\t\t\t\t\t\t\tp = 1;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t\tt = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//System.out.print(p + \" \");\n\t\t\t\t\t\tout.print(p + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tlimit *= k;\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t\tout.println();\n\t\t\t}\n\t\t} else\n\t\t\tout.print(-1);\n\t\t\t//System.out.print(-1);\n\t\tout.close();\n\t}\n\n}\nclass OutputWriter {\n\tprivate PrintWriter output;\n\tpublic OutputWriter() {\n\t\tthis(System.out);\n\t}\n\tpublic OutputWriter(OutputStream out) {\n\t\toutput = new PrintWriter(out);\n\t}\n\tpublic OutputWriter(Writer writer) {\n\t\toutput = new PrintWriter(writer);\n\t}\n\tpublic void print(Object o) {\n\t\toutput.print(o);\n\t}\n\n\tpublic void println() {\n\t\toutput.println();\n\t}\n\n\tpublic void close() {\n\t\toutput.close();\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint t[1002][1002];\nint main() {\n  int n, d, k;\n  cin >> n >> k >> d;\n  if (pow(n, 1.0 / (double)d) - (double)k > 1e-9) {\n    cout << -1 << endl;\n    return 0;\n  }\n  for (int i = 0; i < n; i++) {\n    if (i == 0)\n      for (int j = 0; j < d; j++) t[i][j] = 1;\n    else {\n      for (int j = 0; j < d; j++) t[i][j] = t[i - 1][j];\n      t[i][d - 1]++;\n      for (int j = d - 1; j >= 0; j--) {\n        if (t[i][j] > k) {\n          t[i][j - 1] += t[i][j] / k;\n          t[i][j] %= k;\n        }\n      }\n    }\n  }\n  for (int i = 0; i < d; i++) {\n    for (int j = 0; j < n; j++) {\n      cout << t[j][i] << \" \";\n    }\n    cout << endl;\n  }\n}\n"
        },
        {
            "language": 1,
            "solution": "\nn, k, d = map(int, raw_input().split())\nif n > k ** d:\n    print -1\nelse:\n    z=1\n    for x in range(d):\n        arr=[]\n        for y in range(n):\n            arr.append((y/z)%k+1)\n        z*=k\n        for f in arr:\n            print f,\n        print ''\n        arr=[]\n\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T, typename U>\ninline void amin(T &x, U y) {\n  if (y < x) x = y;\n}\ntemplate <typename T, typename U>\ninline void amax(T &x, U y) {\n  if (x < y) x = y;\n}\nint main() {\n  long long n, k, d;\n  cin >> n >> k >> d;\n  bool check = false;\n  long long tem = 1;\n  for (int i = 0; i < d; i++) {\n    tem *= k;\n    if (tem >= n) {\n      check = true;\n      break;\n    }\n  }\n  if (!check) {\n    cout << \"-1\";\n    return 0;\n  }\n  long long l = 1;\n  long long y = 1;\n  for (int i = 0; i < d; i++) {\n    for (int j = 1; j <= n; j++) {\n      cout << y << \" \";\n      if (j % l == 0) y++;\n      if (y > k) y = 1;\n    }\n    y = 1;\n    l = min(l * k, n);\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid dbg_out() { cerr << \"\\b\\b]\\n\"; }\ntemplate <typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n  cerr << H << \", \";\n  dbg_out(T...);\n}\nconst int N = 1002;\nvector<vector<int>> ans(N, vector<int>(N, -1));\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n, k, d;\n  cin >> n >> k >> d;\n  if (k >= n) {\n    for (int i = 1; i <= d; ++i) {\n      for (int j = 1; j <= n; ++j) {\n        cout << j << ' ';\n      }\n      cout << '\\n';\n    }\n    return 0;\n  }\n  bool ok = true;\n  function<void(int, int, int, int)> go = [&](int l, int r, int bus, int d) {\n    if (d < 0) return;\n    if (d == 1) {\n      if (r - l + 1 > 1) {\n        ok = false;\n        return;\n      }\n    }\n    for (int i = l; i <= r; ++i) {\n      ans[d][i] = bus;\n    }\n    int rem = (r - l + 1) % k;\n    int segment = (r - l + 1) / k;\n    if (segment) {\n      int curr = l;\n      for (int i = 1; i <= k; ++i) {\n        int y = curr + segment + (i <= rem) - 1;\n        go(curr, y, i, d - 1);\n        curr = y + 1;\n      }\n    } else {\n      for (int i = 0; i < rem; ++i) {\n        go(l + i, l + i, i + 1, d - 1);\n      }\n    }\n  };\n  int l = 1, r = n;\n  int rem = (r - l + 1) % k;\n  int segment = (r - l + 1) / k;\n  int curr = 1;\n  for (int i = 1; i <= k; ++i) {\n    int y = curr + segment + (i <= rem) - 1;\n    go(curr, y, i, d);\n    curr = y + 1;\n  }\n  if (!ok) {\n    cout << -1;\n    return 0;\n  }\n  for (int i = d; i >= 1; --i) {\n    for (int j = 1; j <= n; ++j) {\n      cout << ans[i][j] << ' ';\n    }\n    cout << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "import sys\nsys.setrecursionlimit(10**7)\n\ndef generate_subsets(k,d):\n\t\n\tif d<=0:\n\t\tyield []\n\telse:\n\t\tfor i in xrange(k):\n\t\t\tfor s in generate_subsets(k,d-1):\n\t\t\t\ts.append(i)\n\t\t\t\tyield s\n\n\n\n\n\ndef main():\n\tn,k,d=map(int,raw_input().strip().split())\n\n\tif n>k**d:\n\t\tprint -1\n\telse:\n\t\t#generate students orders\n\t\tstudents_order=[]\n\t\tcounter=0\n\t\tfor order in generate_subsets(k,d):\n\t\t\tcounter+=1\n\t\t\tstudents_order.append(order)\t\t\t\n\t\t\tif counter>=n:break\n\n\n\t\tfor i in range(d):\n\t\t\ttmp=[]\n\n\t\t\tfor j in range(n):\n\t\t\t\ttmp.append(str(students_order[j][i]+1))\n\t\t\tprint \" \".join(tmp)\n\nmain()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, k, d;\n  cin >> n >> k >> d;\n  bool ok = false;\n  int temp = 1;\n  for (int i = 0; i < d; i++) {\n    temp *= k;\n    if (temp >= n) {\n      ok = true;\n      break;\n    }\n  }\n  if (!ok) {\n    cout << -1;\n    return 0;\n  }\n  vector<vector<int> > ans(n, vector<int>(d));\n  for (int i = 0; i < d; i++) ans[0][i] = 0;\n  for (int j = 1; j < n; j++) {\n    for (int i = 0; i < d; i++) {\n      ans[j][i] = ans[j - 1][i];\n    }\n    for (int i = d - 1; i >= 0; i--) {\n      ans[j][i] = (ans[j][i] + 1) % k;\n      if (ans[j][i]) break;\n    }\n  }\n  for (int i = 0; i < d; i++, cout << endl)\n    for (int j = 0; j < n; j++) {\n      cout << ans[j][i] + 1 << \" \";\n    }\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "#!/usr/bin/env python\n\n\ndef read():\n    return map(int, raw_input().split())\n\n\ndef work((n, k, d)):\n    if n > k ** d:\n        print -1\n        return\n\n    cur = range(n)\n        \n    for i in range(d):\n        toPrint = []\n        for j in range(n):\n            toPrint.append(cur[j] % k + 1)\n            cur[j] /= k\n\n        print \" \".join(map(str, toPrint))\n\n\nif __name__ == \"__main__\":\n    work(read())\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool isprime(long long n) {\n  if (n <= 1) return false;\n  if (n <= 3) return true;\n  if (n % 2 == 0 || n % 3 == 0) return false;\n  for (long long i = 5; i * i <= n; i += 6) {\n    if (n % i == 0 || n % (i + 2) == 0) return false;\n  }\n  return true;\n}\nlong long modexp(long long a, long long b, long long m) {\n  long long r = 1;\n  a = a % m;\n  while (b > 0) {\n    if (b & 1) r = (r * a) % m;\n    b = b >> 1;\n    a = (a * a) % m;\n  }\n  return r % m;\n}\nstruct CustomCompare {\n  bool operator()(const int& lhs, const int& rhs) { return lhs < rhs; }\n};\nlong long builtin_popcount(long long x) {\n  long long cnt = 0;\n  for (long long i = 60; i >= 0; i--) {\n    if ((1LL << i) & x) cnt++;\n  }\n  return cnt;\n}\nlong long addmod(long long a, long long b, long long r) {\n  a %= r;\n  b %= r;\n  return (a + b) % r;\n}\nlong long mulmod(long long a, long long b, long long r) {\n  a %= r;\n  b %= r;\n  return (a * b) % r;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long n, k, d;\n  cin >> n >> k >> d;\n  long long res = 1;\n  bool flag = false;\n  for (int i = 0; i < d; i++) {\n    res *= k;\n    if (res >= n) {\n      flag = true;\n      break;\n    }\n  }\n  if (!flag || (d == 1 && n > k)) {\n    cout << -1 << endl;\n    return 0;\n  }\n  int ans[d][n];\n  memset(ans, 0, sizeof(ans));\n  for (int i = 0; i < n; i++) {\n    long long bit = i, j = 0;\n    while (bit > 0) {\n      ans[j++][i] = bit % k;\n      bit /= k;\n    }\n  }\n  for (int i = 0; i < d; i++) {\n    for (int j = 0; j < n; j++) cout << ans[i][j] + 1 << \" \";\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.util.InputMismatchException;\n\npublic class PashmakandBuses {\n\n\tpublic static void main(String[] args) {\n\t\tInputReader in = new InputReader(System.in);\n\t\tOutputWriter out = new OutputWriter(System.out);\n\t\tlong n = in.readInt();\n\t\tlong k = in.readInt();\n\t\tlong d = in.readInt();\n\t\tlong a[][] = new long[1001][1001];\n\t\tint i = 0, j = 0;\n\t\tif (Math.pow(k, d) < n) {\n\t\t\tSystem.out.println(-1);\n\t\t} else {\n\t\t\tfor (i = 2; i <= n; i++) {\n\t\t\t\tfor (j = 1; j <= d; j++)\n\t\t\t\t\ta[i][j] = a[i - 1][j];\n\t\t\t\tfor (j = (int) d; j >= 1; j--) {\n\t\t\t\t\ta[i][j] = (a[i][j] + 1) % k;\n\t\t\t\t\tif (a[i][j] == 1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder(\"\");\n\t\t\tfor (i = 1; i <= d; i++) {\n\t\t\t\tfor (j = 1; j <= n; j++)\n\t\t\t\t\tsb.append(a[j][i] + 1 + \" \");\n\t\t\t\tsb.append(\"\\n\");\n\t\t\t}\n\t\t\tSystem.out.println(sb);\n\t\t}\n\t\tout.close();\n\t}\n\n\tprivate static class InputReader {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic long readLong() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tlong sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic int readInt() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic String readString() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuffer res = new StringBuffer();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tstatic boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\treturn readString();\n\t\t}\n\t}\n\n\tprivate static class OutputWriter {\n\t\tprivate final PrintWriter writer;\n\n\t\tpublic OutputWriter(OutputStream outputStream) {\n\t\t\twriter = new PrintWriter(outputStream);\n\t\t}\n\n\t\tpublic OutputWriter(Writer writer) {\n\t\t\tthis.writer = new PrintWriter(writer);\n\t\t}\n\n\t\tpublic void print(Object... objects) {\n\t\t\tfor (int i = 0; i < objects.length; i++) {\n\t\t\t\tif (i != 0)\n\t\t\t\t\twriter.print(' ');\n\t\t\t\twriter.print(objects[i]);\n\t\t\t}\n\t\t}\n\n\t\tpublic void printLine(Object... objects) {\n\t\t\tprint(objects);\n\t\t\twriter.println();\n\t\t}\n\n\t\tpublic void close() {\n\t\t\twriter.close();\n\t\t}\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.SortedSet;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n/**\n * #\n * \n * @author pttrung\n */\npublic class C_Round_261_Div2 {\n\n\tpublic static long MOD = 1000000007;\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\t// PrintWriter out = new PrintWriter(new FileOutputStream(new File(\n\t\t// \"output.txt\")));\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tScanner in = new Scanner();\n\t\tint n = in.nextInt();\n\t\tint k = in.nextInt();\n\t\tint d = in.nextInt();\n\t\tif (k == 1 && n > 1) {\n\t\t\tout.println(-1);\n\t\t} else if (k >= n) {\n\t\t\tfor (int i = 0; i < d; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tout.print(j + \" \");\n\t\t\t\t}\n\t\t\t\tout.println();\n\t\t\t}\n\t\t} else {\n\t\t\tint v = (int) (Math.log(n)/Math.log(k));\n\t\t\t//System.out.println(v + \" \" + Math.pow(k, v));\n\t\t\tif((int)Math.pow(k,v) == n){\n\t\t\t\tv--;\n\t\t\t}\n\t\t\t//System.out.println(v + \" \" + Math.pow(k, v));\n\t\t\t if (d < v + 1) {\n\t\t\t\tout.println(-1);\n\t\t\t} else {\n\t\t\t\tint start = (int) Math.pow(k, v);\n\t\t\t\t//System.out.println(start);\n\t\t\t\tfor (int i = 0; i <= v; i++) {\n\t\t\t\t\tint car = 0;\n\t\t\t\t\tint c = 0;\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tout.print((car + 1) + \" \");\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tif (c == start) {\n\t\t\t\t\t\t\tc = 0;\n\t\t\t\t\t\t\tcar = (car + 1) % k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tout.println();\n\t\t\t\t\tstart /= k;\n\n\t\t\t\t}\n\t\t\t\tfor (int i = v + 1; i < d; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tout.print(1 + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tout.println();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tout.close();\n\t}\n\n\tpublic static int[] KMP(String val) {\n\t\tint i = 0;\n\t\tint j = -1;\n\t\tint[] result = new int[val.length() + 1];\n\t\tresult[0] = -1;\n\t\twhile (i < val.length()) {\n\t\t\twhile (j >= 0 && val.charAt(j) != val.charAt(i)) {\n\t\t\t\tj = result[j];\n\t\t\t}\n\t\t\tj++;\n\t\t\ti++;\n\t\t\tresult[i] = j;\n\t\t}\n\t\treturn result;\n\n\t}\n\n\tpublic static boolean nextPer(int[] data) {\n\t\tint i = data.length - 1;\n\t\twhile (i > 0 && data[i] < data[i - 1]) {\n\t\t\ti--;\n\t\t}\n\t\tif (i == 0) {\n\t\t\treturn false;\n\t\t}\n\t\tint j = data.length - 1;\n\t\twhile (data[j] < data[i - 1]) {\n\t\t\tj--;\n\t\t}\n\t\tint temp = data[i - 1];\n\t\tdata[i - 1] = data[j];\n\t\tdata[j] = temp;\n\t\tArrays.sort(data, i, data.length);\n\t\treturn true;\n\t}\n\n\tpublic static int digit(long n) {\n\t\tint result = 0;\n\t\twhile (n > 0) {\n\t\t\tn /= 10;\n\t\t\tresult++;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static double dist(long a, long b, long x, long y) {\n\t\tdouble val = (b - a) * (b - a) + (x - y) * (x - y);\n\t\tval = Math.sqrt(val);\n\t\tdouble other = x * x + a * a;\n\t\tother = Math.sqrt(other);\n\t\treturn val + other;\n\n\t}\n\n\tpublic static class Point implements Comparable<Point> {\n\n\t\tint x, y;\n\n\t\tpublic Point(int start, int end) {\n\t\t\tthis.x = start;\n\t\t\tthis.y = end;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tint hash = 5;\n\t\t\thash = 47 * hash + this.x;\n\t\t\thash = 47 * hash + this.y;\n\t\t\treturn hash;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (obj == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (getClass() != obj.getClass()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfinal Point other = (Point) obj;\n\t\t\tif (this.x != other.x) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this.y != other.y) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Point o) {\n\t\t\treturn x - o.x;\n\t\t}\n\t}\n\n\tpublic static class FT {\n\n\t\tlong[] data;\n\n\t\tFT(int n) {\n\t\t\tdata = new long[n];\n\t\t}\n\n\t\tpublic void update(int index, long value) {\n\t\t\twhile (index < data.length) {\n\t\t\t\tdata[index] += value;\n\t\t\t\tindex += (index & (-index));\n\t\t\t}\n\t\t}\n\n\t\tpublic long get(int index) {\n\t\t\tlong result = 0;\n\t\t\twhile (index > 0) {\n\t\t\t\tresult += data[index];\n\t\t\t\tindex -= (index & (-index));\n\t\t\t}\n\t\t\treturn result;\n\n\t\t}\n\t}\n\n\tpublic static long gcd(long a, long b) {\n\t\tif (b == 0) {\n\t\t\treturn a;\n\t\t}\n\t\treturn gcd(b, a % b);\n\t}\n\n\tpublic static long pow(long a, long b) {\n\t\tif (b == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (b == 1) {\n\t\t\treturn a;\n\t\t}\n\t\tlong val = pow(a, b / 2);\n\t\tif (b % 2 == 0) {\n\t\t\treturn val * val % MOD;\n\t\t} else {\n\t\t\treturn val * (val * a % MOD) % MOD;\n\n\t\t}\n\t}\n\n\tstatic class Scanner {\n\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic Scanner() throws FileNotFoundException {\n\t\t\t// System.setOut(new PrintStream(new\n\t\t\t// BufferedOutputStream(System.out), true));\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t// br = new BufferedReader(new InputStreamReader(new\n\t\t\t// FileInputStream(new File(\"input.txt\"))));\n\t\t}\n\n\t\tpublic String next() {\n\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tthrow new RuntimeException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tst = null;\n\t\t\ttry {\n\t\t\t\treturn br.readLine();\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new RuntimeException();\n\t\t\t}\n\t\t}\n\n\t\tpublic boolean endLine() {\n\t\t\ttry {\n\t\t\t\tString next = br.readLine();\n\t\t\t\twhile (next != null && next.trim().isEmpty()) {\n\t\t\t\t\tnext = br.readLine();\n\t\t\t\t}\n\t\t\t\tif (next == null) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tst = new StringTokenizer(next);\n\t\t\t\treturn st.hasMoreTokens();\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new RuntimeException();\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long matrix[1010][1010];\nbool is_ok(long long k, long long d, long long n) {\n  double t = (double)1.0 * log((double)n) / log((double)k);\n  double dd = (double)1.0 * d;\n  if (t < dd || fabs(t - dd) < 1e-9)\n    return true;\n  else\n    return false;\n}\nvector<long long> change_ten_to_k(long long x, long long k) {\n  vector<long long> res;\n  long long t;\n  while (x != 0) {\n    t = x % k;\n    x /= k;\n    res.push_back(t);\n  }\n  return res;\n}\nvoid build_matrix(long long k, long long d, long long n) {\n  vector<long long> v;\n  long long id;\n  for (int i = 1; i <= n; i++) {\n    id = i - 1;\n    v = change_ten_to_k(id, k);\n    int len = (int)v.size();\n    for (int j = 0; j < len; j++) {\n      matrix[i][j + 1] = v[j];\n    }\n  }\n}\nint main() {\n  long long n, d;\n  long long k;\n  cin >> n >> k >> d;\n  if (k == 1) {\n    if (n > 1)\n      cout << -1 << endl;\n    else {\n      for (int i = 1; i <= d; i++) {\n        cout << 1 << endl;\n      }\n    }\n    return 0;\n  }\n  if (!is_ok(k, d, n)) {\n    cout << -1 << endl;\n    return 0;\n  }\n  build_matrix(k, d, n);\n  for (int i = 1; i <= d; i++) {\n    for (int j = 1; j <= n; j++) {\n      cout << matrix[j][i] + 1;\n      if (j != n) printf(\" \");\n    }\n    cout << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint ans[1000][1000];\nvoid solve() {\n  int n, k, d;\n  cin >> n >> k >> d;\n  long long cur = 1;\n  int tempd = d;\n  bool isGood = 0;\n  while (tempd--) {\n    cur *= k;\n    if (cur >= n) {\n      isGood = 1;\n      break;\n    }\n  }\n  if (!isGood) {\n    cout << -1;\n    return;\n  }\n  for (int i = 0; i < n; i++) {\n    int curnum = i;\n    for (int j = 0; j < d; j++) {\n      ans[i][j] = curnum % k + 1;\n      curnum /= k;\n    }\n  }\n  for (int i = 0; i < d; i++) {\n    for (int j = 0; j < n; j++) {\n      cout << ans[j][i] << \" \\n\"[j == n - 1];\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class Main{\n    FastScanner in;\n    PrintWriter out;\n\n\n    public void solve()\n    {\n        int n = in.nextInt();\n        int k = in.nextInt();\n        int d = in.nextInt();\n\n        boolean lg = false;\n        long st = 1;\n        for (int i = 0; !lg && i < d; i++) {\n            st *= k;\n            if (st >= n)\n                lg = true;\n        }\n\n        if (!lg) {\n            out.println(-1);\n            return;\n        }\n\n        int[][] ans = new int[n][d];\n        for (int i = 0; i < d; i++) {\n            ans[0][i] = 0;\n        }\n\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < d; j++) {\n                ans[i][j] = ans[i-1][j];\n            }\n            for (int j = 0; j < d; j++) {\n                ans[i][j] = (ans[i][j]+1)%k;\n                if (ans[i][j] == 0)\n                    break;\n            }\n        }\n\n\n\n        for (int i = 0; i < d; i++) {\n            for (int j = 0; j < n; j++) {\n                out.print((ans[j][i]+1) + \" \");\n            }\n            out.println();\n        }\n    }\n\n\n    public void run()\n    {\n        in = new FastScanner();\n        out = new PrintWriter(System.out);\n\n        solve();\n\n        out.close();\n    }\n\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint main() {\n  long long int n, k, d;\n  std::cin >> n >> k >> d;\n  long long int k__d = k, possible = 0;\n  for (int i = 0; i < d; i++) {\n    if (n <= k__d) {\n      possible = 1;\n      break;\n    }\n    k__d = k__d * k;\n  }\n  if (!possible) {\n    printf(\"-1\");\n    return 0;\n  }\n  long long int t = 1;\n  for (int i = 0; i < d; i++) {\n    for (int j = 0; j < n; j++) {\n      long long int j_ = j / t;\n      printf(\"%d \", (int)((j_ % k) + 1));\n    }\n    printf(\"\\n\");\n    if (t <= 1001) t = t * k;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\n\nimport java.awt.Point;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.text.*;\n\npublic class cf459c {\n\n    static BufferedReader br;\n    static Scanner sc;\n    static PrintWriter OUT_;\n    static StringBuilder BUFFER_OUT = new StringBuilder();\n\n    public static void initA() {\n        try {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            sc = new Scanner(System.in);\n            OUT_ = new PrintWriter(System.out);\n        } catch (Exception e) {\n        }\n    }\n\n    static boolean next_permutation(Integer[] p) {\n        for (int a = p.length - 2; a >= 0; --a) {\n            if (p[a] < p[a + 1]) {\n                for (int b = p.length - 1;; --b) {\n                    if (p[b] > p[a]) {\n                        int t = p[a];\n                        p[a] = p[b];\n                        p[b] = t;\n                        for (++a, b = p.length - 1; a < b; ++a, --b) {\n                            t = p[a];\n                            p[a] = p[b];\n                            p[b] = t;\n                        }\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    public static String getString() {\n        try {\n            return br.readLine();\n        } catch (Exception e) {\n        }\n        return \"\";\n    }\n\n    public static Integer getInt() {\n        try {\n            return Integer.parseInt(br.readLine());\n        } catch (Exception e) {\n        }\n        return 0;\n    }\n\n    public static Integer[] getIntArr() {\n        try {\n            StringTokenizer temp = new StringTokenizer(br.readLine());\n            int n = temp.countTokens();\n            Integer temp2[] = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                temp2[i] = Integer.parseInt(temp.nextToken());\n            }\n            return temp2;\n        } catch (Exception e) {\n        }\n        return null;\n    }\n\n    public static Long[] getLongArr() {\n        try {\n            StringTokenizer temp = new StringTokenizer(br.readLine());\n            int n = temp.countTokens();\n            Long temp2[] = new Long[n];\n            for (int i = 0; i < n; i++) {\n                temp2[i] = Long.parseLong(temp.nextToken());\n            }\n            return temp2;\n        } catch (Exception e) {\n        }\n        return null;\n    }\n\n    public static String[] getStringArr() {\n        try {\n            StringTokenizer temp = new StringTokenizer(br.readLine());\n            int n = temp.countTokens();\n            String temp2[] = new String[n];\n            for (int i = 0; i < n; i++) {\n                temp2[i] = (temp.nextToken());\n            }\n            return temp2;\n        } catch (Exception e) {\n        }\n        return null;\n    }\n\n    public static void println(Object a) {\n        BUFFER_OUT.append(a + \"\\n\");\n        //out.println(a);\n    }\n\n    public static void print(Object a) {\n        BUFFER_OUT.append(a);\n        //out.println(a);\n    }\n\n    public static void print(String s, Object... a) {\n        BUFFER_OUT.append(String.format(s, a));\n        // out.printf(s, a);\n    }\n\n    public static int nextInt() {\n        return sc.nextInt();\n    }\n\n    public static double nextDouble() {\n        return sc.nextDouble();\n    }\n\n    public static void main(String[] ar) {\n        initA();\n        cf459c c = new cf459c();\n        c.solve();\n        OUT_.write(BUFFER_OUT.toString());\n        OUT_.flush();\n    }\n    HashSet<Long> sdh = new HashSet<Long>();\n    int bth;\n    int n, k, d;\n    Integer temp[] = new Integer[1000 + 5];\n    int kolom_dikerjakan = 0;\n    Integer ou[][] = new Integer[1005][1005];\n\n    void dfs(int i, int j, long hash) {\n\n        if (kolom_dikerjakan == n) {\n            // print(\"SELSE\");\n            return;\n        }\n        if (j == d) {\n            if (!sdh.contains(hash)) {\n                Integer tx[] = new Integer[d];\n                System.arraycopy(temp, 0, tx, 0, tx.length);\n\n\n                // print(Arrays.asList(tx) + \" KERJAKAN KOLOM \"+kolom_dikerjakan);\n                for (; kolom_dikerjakan < n;) {\n                    for (int x = 0; x < d; x++) {\n                        ou[x][kolom_dikerjakan] = tx[x];\n                        // print(\"SET \"+x+\",\"+kolom_dikerjakan +\" = \"+tx[x]);\n                    }\n                    kolom_dikerjakan++;\n                    boolean a = next_permutation(tx);\n                    if (!a) {\n                        break;\n                    }\n                }\n                sdh.add(hash);\n            }\n            return;\n        }\n        if (i > k) {\n            return;\n        }\n        temp[j] = i;\n        dfs(i + 1, j + 1, hash * k + i);\n\n        //ambil sama berulang\n        dfs(i, j + 1, hash * k + i);\n\n        //ini di bawahnya krn supaya tdk mengganti temp[j] dgn kanannya\n        //ambil angka berikut\n        dfs(i + 1, j, hash);\n\n\n    }\n\n    void solve() {\n        Integer xx[] = getIntArr();\n        n = xx[0];\n        k = xx[1];\n        d = xx[2];\n\n        if (n > 1 && (k == 1 || (d == 1 && k < n))) {\n            println(-1);\n            return;\n        }\n        //n = kolom d = baris\n        long st = System.currentTimeMillis();\n        bth = n * d;\n\n     \n        dfs(1, 0, 0);\n        /*\n        for (Integer[] x : list_) {\n        print(Arrays.asList(x));\n        }\n        print(sdh);\n         */\n\n        if (kolom_dikerjakan != n) {\n            println(-1);\n            return;\n        }\n        // print(\"SELSE DALAM \"+(System.currentTimeMillis() - st));\n        for (int i = 0; i < d; i++) {\n            for (int j = 0; j < n; j++) {\n                print(ou[i][j] + \" \");\n            }\n            println(\"\");\n        }\n\n\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, d, k;\nvector<vector<int>> seq;\nvoid gen(vector<int>& cur) {\n  if (seq.size() >= n) return;\n  if (cur.size() == d) {\n    seq.push_back(cur);\n    return;\n  }\n  for (int c = 1; c <= min(k, n) && seq.size() < n; c++) {\n    cur.push_back(c);\n    gen(cur);\n    cur.pop_back();\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin >> n >> k >> d;\n  vector<int> cur;\n  cur.reserve(d);\n  gen(cur);\n  if (seq.size() < n) {\n    cout << -1;\n    return 0;\n  }\n  for (int i = 0; i < d; i++) {\n    for (int j = 0; j < n; j++) cout << seq[j][i] << \" \";\n    cout << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\nimport java.util.Set;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Nasko\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n\n            int N = in.nextInt();\n            int K = in.nextInt();\n            int D = in.nextInt();\n\n\n            int[][] ret = new int[N][D];\n\n            for (int i = 1; i < N; ++i) {\n                for (int j = 0; j < D; ++j) ret[i][j] = ret[i - 1][j];\n                for (int j = D - 1; j >= 0; --j) {\n                    ret[i][j] = (ret[i][j] + 1) % K;\n                    if (ret[i][j] > 0) break;\n                }\n            }\n\n            ArrayList<Integer> rem = new ArrayList<Integer>();\n            for (int i = 0; i < N; ++i) {\n                Set<Integer> hs = new HashSet<Integer>();\n                for (int d = 0; d < D; ++d) {\n                    hs.add(ret[i][d]);\n                }\n                if (hs.size() == 1) {\n                    rem.addAll(hs);\n                }\n            }\n            for (int i = 0; i < rem.size(); ++i) {\n                for (int j = i + 1; j < rem.size(); ++j) {\n                    if (rem.get(i) == rem.get(j)) {\n                        out.println(-1);\n                        return;\n                    }\n                }\n            }\n            for (int i = 0; i < D; ++i) {\n                for (int j = 0; j < N; ++j) {\n                    out.print((ret[j][i] + 1) + \" \");\n                }\n                out.println();\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k, d;\nlong long arr[1011][1011];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> k >> d;\n  long long tot = 1LL;\n  bool f = false;\n  for (int i = 1; i <= d; ++i) {\n    tot *= k;\n    if (tot >= n) {\n      f = true;\n      break;\n    }\n  }\n  if (!f) {\n    cout << \"-1\" << '\\n';\n    return 0;\n  }\n  for (int i = 2; i <= n; ++i) {\n    for (int j = 1; j <= d; ++j) arr[i][j] = arr[i - 1][j];\n    for (int j = d; j >= 1; --j) {\n      arr[i][j] = (arr[i][j] + 1) % k;\n      if (arr[i][j]) break;\n    }\n  }\n  for (int j = 1; j <= d; ++j) {\n    for (int i = 1; i <= n; ++i) cout << arr[i][j] + 1 << \" \";\n    cout << '\\n';\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin, stdout, setrecursionlimit\ninput = stdin.readline\n# import string\n# characters = string.ascii_lowercase\n# digits = string.digits\n# setrecursionlimit(int(1e6))\n# dir = [-1,0,1,0,-1]\n# moves = 'NESW'\ninf = float('inf')\nfrom functools import cmp_to_key\nfrom collections import defaultdict as dd\nfrom collections import Counter, deque\nfrom heapq import *\nimport math\nfrom math import floor, ceil, sqrt\ndef geti(): return map(int, input().strip().split())\ndef getl(): return list(map(int, input().strip().split()))\ndef getis(): return map(str, input().strip().split())\ndef getls(): return list(map(str, input().strip().split()))\ndef gets(): return input().strip()\ndef geta(): return int(input())\ndef print_s(s): stdout.write(s+'\\n')\n\ndef solve():\n    n, k, d = geti()\n    num = 1\n    for i in range(1, d+1):\n        num *= k\n        if num >= n:\n            break\n    else:\n        print(-1)\n        return\n    def convert(prev):\n        ans = prev[:]\n        i = d - 1\n        ans[i] += 1\n        while ans[i] > k and i > 0:\n            ans[i-1] += 1\n            ans[i] = 1\n            i -= 1\n        return ans\n    ans = [[1]*d]\n    for i in range(1, n+1):\n        ans.append(convert(ans[i-1]))\n    # print(ans)\n    for i in range(d):\n        print(*[ans[j][i] for j in range(n)])\n\n\n\n# 1 2 1 2 1 2 2\n# 2 1 2 1 1 2 2\n# 1 2 2 1 1 2 1\n#\n#\n# 2 1 1 1 1 2 1 1\n# 1 2 1 1 1 2 2 1\n# 1 1 2 1 1 1 2 1\n# 1 1 1 2 1 1 1 1\n# 1 1 1 1 2 1 1 1\n\n\nif __name__=='__main__':\n    solve()\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author George Marcus\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskC solver = new TaskC();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskC {\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int N = in.nextInt();\n        int K = in.nextInt();\n        int D = in.nextInt();\n\n        long p = 1;\n        for (int i = 0; i < D; i++) {\n            p *= K;\n            if (p >= N) {\n                break;\n            }\n        }\n\n        if (p < N) {\n            out.println(-1);\n            return;\n        }\n\n        int[][] ans = new int[N][D];\n        for (int i = 0; i < N; i++) {\n            int n = i;\n            for (int j = 0; j < D && n > 0; j++) {\n                ans[i][j] = n % K;\n                n /= K;\n            }\n        }\n\n        for (int i = 0; i < D; i++) {\n            for (int j = 0; j < N; j++) {\n                out.print((ans[j][i] + 1) + \" \");\n            }\n            out.println();\n        }\n    }\n}\n\nclass InputReader {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public int read() {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(nextString());\n    }\n\n    public String nextString() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        StringBuffer res = new StringBuffer();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n\n        return res.toString();\n    }\n\n    private boolean isSpaceChar(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n}\n\n"
        },
        {
            "language": 3,
            "solution": "n,k,d=map(int,input().split())\nif n>k**d:print(-1);exit(0)\nK=1\nfor j in range(d):\n    print(\" \".join([str(i//K%k +1) for i in range(n)]))\n    K*=k\n\n\n\n\n# Made By Mostafa_Khaled"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class File {\n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\t\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tint d = sc.nextInt();\n\t\t\n\t\t\n\t\t\t\t\n\t\t// There's only 1 bus. No matter how many days, cannot separate.\n\t\tif (k == 1 && n > 1) {\n\t\t\tout.println(-1);\n\t\t}\n\t\telse if (k >= n) {\n\t\t\t// Simply place each student in a separate bus every day.\n\t\t\tfor (int day = 1; day <= d; day++) {\n\t\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t\tout.print(i + \" \");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tout.println();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// A[i][j] = student j rides this bus on day i.\n\t\t\tint[][] A = new int[d][n];\n\t\t\t\n\t\t\tfor (int r = 0; r < d; r++) {\n\t\t\t\tArrays.fill(A[r], 1);\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\n\t\t\tboolean isPossible = true;\n\t\t\t\t\t\t\n\t\t\t// Generate n numbers with length d, where values\n\t\t\t// between [1, k]\n\t\t\t// Sequence for each student.\n\t\t\tint[] curr = new int[d];\n\t\t\tArrays.fill(curr, 1);\n\t\t\t\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tint index = d-1;\n\t\t\t\t\n\t\t\t\twhile (index >= 0 && curr[index] == k) {\n\t\t\t\t\tcurr[index] = 1;\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (index < 0) {\n\t\t\t\t\tisPossible = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcurr[index]++;\n\t\t\t\t\n\t\t\t\tfor (int day = 0; day < d; day++) {\n\t\t\t\t\tA[day][i] = curr[day];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tif (isPossible) {\n\t\t\t\tfor (int day = 0; day < d; day++) {\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tout.print(A[day][i] + \" \");\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tout.println();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout.println(-1);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tout.close();\n\t}\n}\n\n\n\n\n\n\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\npublic class C {\n\tint n, d;\n\tlong k;\n\tint a[][];\n\n\tpublic static void main(String[] args) {\n\t\tnew C().go();\n\t}\n\n\tboolean probable;\n\n\tpublic void go() {\n\t\tScanner reader = new Scanner(System.in);\n\t\tn = reader.nextInt();\n\t\tk = reader.nextLong();\n\t\td = reader.nextInt();\n\t\treader.close();\n\t\tlong quantity = 1;\n\t\tfor (int i = 1; i <= d; i++) {\n\t\t\tquantity *= k;\n\t\t\tif (quantity >= n) {\n\t\t\t\tprobable = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!probable) {\n\t\t\tSystem.out.print(-1);\n\t\t\treturn;\n\t\t}\n\t\ta = new int[d + 1][n + 1];\n\t\tfor (int i = 1; i <= d; i++)\n\t\t\ta[i][1] = 1;\n\t\tfor (int j = 2; j <= n; j++) {\n\t\t\tint x = d;\n\t\t\twhile (a[x][j-1] == k) x--;\n\t\t\tfor (int i = d; i > x; i--) a[i][j] = 1;\n\t\t\ta[x][j] = a[x][j-1] + 1;\n\t\t\tfor (int i = x - 1; i >= 1; i--) a[i][j] = a[i][j-1];\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 1; i <= d; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tsb.append(a[i][j]);\n\t\t\t\tsb.append(\" \");\n\t\t\t}\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\t\tSystem.out.print(sb);\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint bus[1001][1001];\nint main() {\n  long long int n, k, d, o = 1, p, i, j, g, ar;\n  bool check = true;\n  cin >> n >> k >> d;\n  for (i = 0; i < d + 1; i++) {\n    ar = 0;\n    for (j = 0; j < n; j++) {\n      if (j % o == 0 && j != 0) ar = (ar + 1) % k;\n      bus[i][j] = ar;\n    }\n    if (o * k < n)\n      o *= k;\n    else\n      o = n;\n  }\n  if (k == 1) check = false;\n  for (i = 0; i < n - 1; i++)\n    if (bus[d][i] != bus[d][i + 1]) check = false;\n  if (!check && !(n == 1))\n    cout << -1 << \"\\n\";\n  else\n    for (i = 0; i < d; i++) {\n      for (j = 0; j < n; j++) {\n        cout << bus[i][j] + 1 << \" \";\n      }\n      cout << \"\\n\";\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n\npublic class Abood2C {\n\n\tstatic int n, k, d, ans[][];\n\t\n\tstatic boolean solve(int l, int r, int day) {\n\t\tif(l == r)\n\t\t\treturn true;\n\t\t\n\t\tif(r > l && day == d)\n\t\t\treturn false;\n\t\t\n\t\tboolean can = true;\n\t\t\n\t\tint same = (r - l + k) / k;\n\t\tint c = 0;\n\t\tfor (int i = l; i <= r; i+= same) {\n\t\t\tfor (int j = i; j < i + same && j <= r; j++) {\n\t\t\t\tans[j][day] = c;\n\t\t\t}\n\t\t\tc++;\n\t\t\tcan &= solve(i, Math.min(r, i + same - 1), day + 1);\n\t\t}\n\t\t\n\t\treturn can;\n\t}\n\t\n\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tn = sc.nextInt(); k = sc.nextInt(); d = sc.nextInt();\n\t\t\n\t\tans = new int[n][d];\n\t\t\n\t\tif(solve(0, n - 1, 0)) {\n\t\t\tfor (int i = 0; i < d; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tout.print(ans[j][i] + 1 + \" \");\n\t\t\t\tout.println();\n\t\t\t}\n\t\t} else {\n\t\t\tout.println(-1);\n\t\t}\n\n\t\tout.flush();\n\n\t}\n\n\n\tstatic class Scanner \n\n\n\n\t{\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s){\tbr = new BufferedReader(new InputStreamReader(s));}\n\n\t\tpublic String next() throws IOException \n\t\t{\n\t\t\twhile (st == null || !st.hasMoreTokens()) \n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n\n\t\tpublic long nextLong() throws IOException {return Long.parseLong(next());}\n\n\t\tpublic String nextLine() throws IOException {return br.readLine();}\n\n\n\t\tpublic double nextDouble() throws IOException\n\t\t{\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif(x.charAt(0) == '-')\n\t\t\t{\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor(int i = start; i < x.length(); i++)\n\t\t\t\tif(x.charAt(i) == '.')\n\t\t\t\t{\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif(dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg?-1:1);\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {return br.ready();}\n\n\n\n\t}\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tlong n = sc.nextLong();\n\t\tlong k = sc.nextLong();\n\t\tlong d = sc.nextLong();\n\t\t\n\t\tif(n > (long)Math.pow(k, d)) {\n\t\t\tSystem.out.println(\"-1\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint[][] matrix = new int[(int)d][(int)n];\n\n\t\tList<Integer> list;\n\t\tint div, rem;\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tlist = new ArrayList<>();\n\t\t\t\n\t\t\tdiv = i;\n\t\t\tdo {\n\t\t\t\trem = div%(int)k;\n\t\t\t\tdiv = div/(int)k;\n\t\t\t\t\n\t\t\t\tlist.add(rem);\n\t\t\t}while(div != 0);\n\t\t\t\n\t\t\tfor(int j=0; j<list.size(); j++) {\n\t\t\t\tmatrix[j][i] = list.get(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0; i<d; i++) {\n\t\t\tfor(int j=0; j<n; j++) {\n\t\t\t\tsb.append((matrix[i][j]+1) + \" \");\n\t\t\t}\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\t\t\n\t\tSystem.out.println(sb);\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char const *argv[]) {\n  int n, d;\n  long long int k;\n  cin >> n >> k >> d;\n  int **A;\n  A = (int **)malloc(d * sizeof(int *));\n  int i, j;\n  for (i = 0; i < d; ++i) {\n    A[i] = (int *)malloc(n * sizeof(int));\n  }\n  int flag = 1;\n  long long int pw = 1;\n  for (i = 0; i < d; ++i) {\n    pw *= k;\n    if (pw >= n) {\n      flag = 0;\n      break;\n    }\n  }\n  if (flag) {\n    cout << \"-1\";\n    return 0;\n  }\n  long long int jump, count;\n  jump = 1;\n  int num;\n  for (i = 0; i < d; ++i) {\n    count = jump;\n    num = 0;\n    for (j = 0; j < n; ++j) {\n      A[i][j] = num;\n      count--;\n      if (count == 0) {\n        count = jump;\n        num++;\n        if (num == k) num = 0;\n      }\n    }\n    jump *= k;\n  }\n  for (i = 0; i < d; ++i) {\n    for (j = 0; j < n; ++j) {\n      cout << A[i][j] + 1 << \" \";\n    }\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\n\ndef main():\n    # if numOfBuses >= numOfStudents: YES\n    # if numOfPermutations (numOfDays**numOfStudents) >= numOfStudents: YES\n        # at least one student will have a different permutation than\n        # any other\n\n    # for each student -> represent it in base numOfBuses and then\n    # turn it into numOfBuses'ry (like binary)\n    # loop -> get the mod of the number and divide it by numOfBuses\n    # until the result is not integer\n    # print the accumulated mods for each student\n    numOfStudents, numOfBuses, numOfDays = [ int(x) for x in input().split() ]\n\n    if numOfBuses**numOfDays >= numOfStudents:\n        studentSequences = [\n            [1] * numOfDays\n            for student in range(numOfStudents)\n        ]\n\n        for student in range(numOfStudents):\n            number = student\n\n            for day in range(numOfDays):\n                remainder = number % numOfBuses\n                studentSequences[student][day] = remainder+1\n                number //= numOfBuses\n\n                if number == 0: break\n\n        for day in range(numOfDays):\n            print(' '.join(\n                [ str(studentSequences[student][day])\n                for student in range(numOfStudents)]\n            ))\n\n    else:\n        print(-1)\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep = kwargs.pop(\"sep\", \" \")\n    file = kwargs.pop(\"file\", sys.stdout)\n\n    atStart = True\n    for x in args:\n        if not atStart:\n            file.write(sep)\n        file.write(str(x))\n        atStart = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\nmain()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint p[1000][1000];\nint main() {\n  int n, k, d;\n  cin >> n >> k >> d;\n  k = min(k, 1000);\n  for (int i = 1; i <= k; i++) {\n    int flag = 0, tmp = 1;\n    for (int j = 0; j < d; j++)\n      if ((tmp *= i) >= n) {\n        flag = 1;\n        break;\n      }\n    if (flag) {\n      k = i;\n      break;\n    }\n    if (i == k) {\n      cout << -1 << endl;\n      return 0;\n    }\n  }\n  for (int i = 1; i < n; i++) {\n    for (int j = 0; j < d; j++) p[i][j] = p[i - 1][j];\n    int t = d - 1;\n    while (t >= 0 && p[i][t] == k - 1) {\n      p[i][t] = 0;\n      t--;\n    }\n    p[i][t]++;\n  }\n  for (int i = 0; i < d; i++) {\n    for (int j = 0; j < n; j++) cout << p[j][i] + 1 << \" \";\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int gcd(long long int a, long long int b) {\n  if (a == 0 || b == 0) return max(a, b);\n  if (b % a == 0) return a;\n  return gcd(b % a, a);\n}\nint64_t arr[1001][1001];\nint main() {\n  int64_t n, k, d;\n  cin >> n >> k >> d;\n  int cn = 1, fl = 0;\n  int64_t an = 1;\n  if (k < n) {\n    int64_t tmp = 1;\n    while (1) {\n      tmp *= k;\n      if (tmp > n) {\n        break;\n      }\n      if (cn == d) break;\n      cn++;\n    }\n    if (n > tmp) {\n      fl = 1;\n    }\n  }\n  if (fl)\n    cout << \"-1\";\n  else {\n    int x1 = 0;\n    for (int64_t i = 1; i < n; i++) {\n      for (int j = 0; j < d; j++) arr[j][i] = arr[j][i - 1];\n      for (int64_t j = d - 1; j >= 0; j--) {\n        arr[j][i] = (arr[j][i - 1] + 1) % k;\n        if (arr[j][i]) break;\n      }\n    }\n    for (int i = 0; i < d; i++) {\n      for (int j = 0; j < n; j++) {\n        cout << arr[i][j] + 1 << \" \";\n      }\n      cout << \"\\n\";\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "// package com.MahmoudHamdy;\n\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n\n    static final int INF = (int) 2e9;\n    static int n, k, d;\n    static ArrayList<ArrayList<Integer>> arr;\n    static ArrayList<Integer> temp;\n\n    public static void main(String[] args) throws IOException {\n//        Scanner Sc = new Scanner(\"input.txt\");\n//        PrintWriter Out = new PrintWriter(new FileWriter(\"output.txt\"));\n        Scanner Sc = new Scanner(System.in);\n        PrintWriter Out = new PrintWriter(System.out);\n\n        arr = new ArrayList<>();\n        temp = new ArrayList<>();\n        n = Sc.nextInt();\n        k = Sc.nextInt();\n        d = Sc.nextInt();\n        solve();\n        if(arr.size() < n)\n            Out.print(-1);\n        else\n        {\n            for(int i = 0; i < d; i++)\n            {\n                for(int j = 0; j < n; j++)\n                    Out.print(arr.get(j).get(i) + \" \");\n                Out.println();\n            }\n        }\n\n        Out.flush();\n        Out.close();\n    }\n\n    static void solve()\n    {\n        if(temp.size() == d)\n        {\n            arr.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int i = 1; i<= k; i++)\n        {\n            temp.add(i);\n            solve();\n            temp.remove(temp.size() - 1);\n            if(arr.size() >= n)\n                return;\n        }\n    }\n\n\n    static class Comp\n    {\n        TreeMap<Integer, Integer> mop = new TreeMap<>();\n        TreeSet<Integer> st = new TreeSet<>();\n\n        void add(int x)\n        {\n            st.add(x);\n        }\n        int get(int x)\n        {\n            return mop.get(x);\n        }\n        void compress()\n        {\n            for(int i : st)\n                mop.put(i, mop.size());\n        }\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n        Scanner(String s) throws FileNotFoundException { br = new BufferedReader(new FileReader(s)); }\n\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            String x = next();\n            StringBuilder sb = new StringBuilder(\"0\");\n            double res = 0, f = 1;\n            boolean dec = false, neg = false;\n            int start = 0;\n            if (x.charAt(0) == '-') {\n                neg = true;\n                start++;\n            }\n            for (int i = start; i < x.length(); i++)\n                if (x.charAt(i) == '.') {\n                    res = Long.parseLong(sb.toString());\n                    sb = new StringBuilder(\"0\");\n                    dec = true;\n                } else {\n                    sb.append(x.charAt(i));\n                    if (dec)\n                        f *= 10;\n                }\n            res += Long.parseLong(sb.toString()) / f;\n            return res * (neg ? -1 : 1);\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n\n    }\n\n    static class pair implements Comparable<pair>{\n        char f;long s;\n        pair(char a,long b){f= a;s=b;}\n\n        @Override\n        public int compareTo(pair p) {\n            if(s != p.s)\n                return s > p.s ? 1 : -1;\n            return f-p.f;\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint ls[1002];\nint ans[1002][1002];\nint st[1002];\nint fin, k, d, num;\nvoid sol(int now) {\n  if (now > d) {\n    fin--;\n    for (int j = 1; j < now; j++) ans[num][j] = st[j];\n    num++;\n    return;\n  }\n  for (int j = 1; j <= k; j++) {\n    st[now] = j;\n    sol(now + 1);\n    if (!fin) return;\n  }\n}\nbool bigger(int a, int b, int d) {\n  if (a == 1) return b == 1;\n  int c = a;\n  while (--d) {\n    if (a >= b) return true;\n    a = a * c;\n  }\n  return a >= b;\n}\nint main() {\n  int n;\n  scanf(\"%d %d %d\", &n, &k, &d);\n  if (!bigger(k, n, d))\n    cout << -1;\n  else {\n    fin = n;\n    num = 1;\n    sol(1);\n    for (int i = 1; i <= d; i++) {\n      for (int j = 1; j <= n; j++) {\n        printf(\"%d \", ans[j][i]);\n      }\n      printf(\"\\n\");\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nconst int N = (int)1e6 + 7;\nconst int MOD = (int)1e9 + 7;\nconst int INF = 2e9;\nconst long long BIG = 1e11;\nconst int P = 1000;\nlong long k, d, a[N], n;\nint main() {\n  ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  ;\n  int cur = 1;\n  cin >> n >> k >> d;\n  long long res = k;\n  for (int i = 1; i < d; i++) {\n    res *= k;\n    if (res >= n) break;\n  }\n  if (res < n) cout << -1, exit(0);\n  for (int i = 0; i < n; i++) a[i] = i;\n  for (int i = 0; i < d; i++) {\n    for (int j = 0; j < n; j++) {\n      cout << (a[j] % k) + 1 << ' ', a[j] /= k;\n    }\n    cout << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\n\npublic class Main {\n    static PrintWriter out;\n    static Reader in;\n    public static void main(String[] args) throws IOException {\n        input_output();\n        //out = new PrintWriter(System.out);\n        //in = new Reader(new FileInputStream(\"card.in\"));\n        Main solver = new Main();\n        solver.solve();\n        out.close(); \n        out.flush(); \n    }\n\n    static int INF = (int)1e9+2;\n    static int maxn = (int)1e6+5;\n    static int mod = (int)1e9+7;\n    static int n, m, q, t, k;\n    static double pi = 3.141592653589;\n\n    static int days;\n    static boolean good;\n\n    void solve() throws IOException{\n        n = in.nextInt();\n        k = in.nextInt();\n        days = in.nextInt();\n\n        List<Integer> arr = new ArrayList<Integer>();\n        for (int i = 1; i <= n; i++) arr.add(i);\n        int[][] ans = new int[n+1][days+1];\n\n        good = true;\n        work(arr, n, 1, ans);\n\n        if (!good) out.println(-1);\n        else {\n            for (int i = 1; i <= days; i++) {\n                for (int j = 1; j <= n; j++) {\n                    out.print(ans[j][i]+\" \");\n                }\n                out.println();\n            }\n        }\n    }\n\n    //<>\n\n    static void work(List<Integer> list, int size, int d, int[][] ans) {\n        if (d > days) return;\n        if (d == days && size > k) {good = false;return;}\n\n\n        int rest = size%k,\n            div = size/k,\n            idx = 0,\n            group = 1;\n        while (idx < size) {\n            List<Integer> list2 = new ArrayList<>();\n            for (int i = idx; i < idx+div; i++) {\n                list2.add(list.get(i));\n                ans[list.get(i)][d] = group;\n            }\n            idx += div;\n            if (rest != 0) {\n                ans[list.get(idx)][d] = group;\n                list2.add(list.get(idx++));\n                rest--;\n            }\n            if (list2.size() == 0) break;\n            group++;\n            work(list2, list2.size(), d+1, ans);\n        }\n\n    }\n\n    static class Reader {\n \n        private InputStream mIs;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n    \n        public Reader() {\n            this(System.in);\n        }\n    \n        public Reader(InputStream is) {\n            mIs = is;\n        }\n    \n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n    \n        }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = mIs.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n    \n        public String nextLine() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        }\n    \n        public String next() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n    \n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n    \n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n    \n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n    \n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    \n        public boolean isEndOfLine(int c) {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n \n    }\n    static void input_output() throws IOException {\n        File f = new File(\"in.txt\");\n        if(f.exists() && !f.isDirectory()) { \n            in = new Reader(new FileInputStream(\"in.txt\"));\n        } else in = new Reader();\n        f = new File(\"out.txt\");\n        if(f.exists() && !f.isDirectory()) {\n            out = new PrintWriter(new File(\"out.txt\"));\n        } else out = new PrintWriter(System.out);\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.awt.*;\nimport java.awt.event.*;\nimport java.awt.geom.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*; \nimport java.util.*;\nimport java.util.regex.*;\n\n/*\n  br = new BufferedReader(new FileReader(\"input.txt\"));\n  pw = new PrintWriter(new BufferedWriter(new FileWriter(\"output.txt\")));\n  br = new BufferedReader(new InputStreamReader(System.in));\n  pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n */\n\n\npublic class Main {\n\tprivate static BufferedReader br;\n\tprivate static StringTokenizer st;\n\tprivate static PrintWriter pw;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tpw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\t\t//int qq = 1;\n\t\tint qq = Integer.MAX_VALUE;\n\t\t//int qq = readInt();\n\t\tfor(int casenum = 1; casenum <= qq; casenum++) {\n\t\t\tint n = readInt();\n\t\t\tint maxVal = readInt();\n\t\t\tint dim = readInt();\n\t\t\tlong total = 1;\n\t\t\tfor(int i = 0; i < dim; i++) {\n\t\t\t\ttotal *= maxVal;\n\t\t\t\tif(total >= n) break;\n\t\t\t}\n\t\t\tif(total < n) {\n\t\t\t\tpw.println(\"-1\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint[][] ret = new int[n][dim];\n\t\t\tfor(int val = 0; val < n; val++) {\n\t\t\t\tint temp = val;\n\t\t\t\tfor(int i = 0; i < dim; i++) {\n\t\t\t\t\tret[val][i] = temp % maxVal;\n\t\t\t\t\ttemp /= maxVal;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < dim; i++) {\n\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\tpw.print(++ret[j][i] + \" \");\n\t\t\t\t}\n\t\t\t\tpw.println();\n\t\t\t}\n\t\t}\n\t\texitImmediately();\n\t}\n\n\tprivate static void exitImmediately() {\n\t\tpw.close();\n\t\tSystem.exit(0);\n\t}\n\n\tprivate static long readLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tprivate static double readDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tprivate static int readInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tprivate static String nextLine() throws IOException  {\n\t\tif(!br.ready()) {\n\t\t\texitImmediately();\n\t\t}\n\t\tst = null;\n\t\treturn br.readLine();\n\t}\n\n\tprivate static String nextToken() throws IOException  {\n\t\twhile(st == null || !st.hasMoreTokens())  {\n\t\t\tif(!br.ready()) {\n\t\t\t\texitImmediately();\n\t\t\t}\n\t\t\tst = new StringTokenizer(br.readLine().trim());\n\t\t}\n\t\treturn st.nextToken();\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, d;\nlong long int k;\nvector<vector<long long int> > grid;\nvector<long long int> curr;\nvoid dfs(int D) {\n  if (D == d) {\n    grid.push_back(curr);\n    return;\n  }\n  for (int i = 1; i <= k; i++) {\n    curr.push_back(i);\n    dfs(D + 1);\n    if ((int)grid.size() >= n) return;\n    curr.pop_back();\n  }\n}\nint main() {\n  cin >> n >> k >> d;\n  double l = d;\n  l *= log(k);\n  double r = log(n);\n  if ((r - l) > 0.0000000001) {\n    cout << -1;\n  } else {\n    dfs(0);\n    for (int j = 0; j < d; j++, cout << endl) {\n      for (int i = 0; i < n; i++) {\n        cout << grid[i][j] << \" \";\n      }\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.math.*;\nimport java.io.*;\nimport java.text.*;\n\npublic class A{\n\t\nstatic class Pair implements Comparable<Pair> {\n\tlong x;\n\tlong y;\n\tpublic Pair(long x,long y) {\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t\t\n\t\t\n\t}\n\tpublic int compareTo(Pair c) {\n\t   int i= Long.compare(abs(this.x)+abs(this.y),abs(c.x)+abs(c.y));\n\t   if(i!=0)return i;\n\t   i=Long.compare(this.x,c.x);\n\t   if(i!=0) return i;\n\t   i=Long.compare(this.y, c.y);\n\t   return i;\n\t}\n}\nstatic class Node {\n\tlong cnt;\n\tchar ch;\n\tpublic  Node(long cnt,char ch) {\n\t\tthis.cnt=cnt;\n\t\tthis.ch=ch;\n\t}\n}\n//public static PrintWriter pw; \npublic static PrintWriter pw=new PrintWriter(System.out);\npublic static void solve() throws IOException{\n//\tpw=new PrintWriter(new FileWriter(\"C:\\\\Users\\\\shree\\\\Downloads\\\\small_output_in\"));\n\tFastReader sc=new FastReader();\n\tlong n=sc.nextLong();\n\tlong k=sc.nextLong();\n\tlong d=sc.nextLong();\n\tif(n>Math.pow(k, d)) {\n\t\tpw.println(-1);\n\t\tpw.close();\n\t\treturn;\n\t}\n\tlong ans[][]=new long[(int)d][(int)n];\n\tfor(int i=0;i<n;i++) {\n\t\tlong p=i;\n\t\tint j=0;\n\t\twhile(p>0) {\n\t\t\tans[j++][i]=p%k;\n\t\t\tp/=k;\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<d;i++) {\n\t\tfor(int j=0;j<n;j++) pw.print((ans[i][j]+1)+\" \");\n\t\tpw.println(\"\");\n\t}\n\tpw.close();\n\t\n}\nstatic long  abs(long x) {\n\treturn Math.abs(x);\n}\npublic static void main(String[] args)  {\n    new Thread(null ,new Runnable(){\n      public void run(){\n          try{\n          \n              solve();\n          } catch(Exception e){\n              e.printStackTrace();\n          }\n      }\n  },\"1\",1<<26).start();\n \n}\nstatic long modPow(long x,long y,long M){\n\tif(y==0) return 1;\n\tif(y%2==0) return modPow((x*x)%M,y/2,M)%M;\n\telse return (x*modPow((x*x)%M,(y-1)/2,M))%M;\n}\n\nstatic long M=(long)Math.pow(10,9)+7;\n \n\tstatic class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastReader() throws FileNotFoundException{\n            //br=new BufferedReader(new FileReader(\"C:\\\\Users\\\\shree\\\\Downloads\\\\B-small-practice.in\"));\t\n        \t br = new BufferedReader(new InputStreamReader(System.in));\n        \t\t\n        }\n \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n       \n        int nextInt(){   return Integer.parseInt(next()); }\n        long nextLong(){  return Long.parseLong(next()); }\n        double nextDouble() {  return Double.parseDouble(next()); }\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n     }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int> > V;\nint n, k, d, pos = 1, c = 0;\nvector<int> tmp;\nvoid calc(int id) {\n  if (id == d) {\n    V.push_back(tmp);\n    return;\n  }\n  for (int i = 1; i <= k; i++) {\n    tmp[id] = i;\n    if (V.size() == n) return;\n    calc(id + 1);\n  }\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &d);\n  tmp.resize(d);\n  long long tmp1 = 1;\n  int c = 0;\n  for (int i = 0; i < d; i++) {\n    tmp1 *= (long long)k;\n    if (tmp1 >= n) {\n      c = 1;\n      break;\n    }\n  }\n  if (!c) {\n    printf(\"-1\\n\");\n    return 0;\n  }\n  calc(0);\n  for (int j = 0; j < d; j++) {\n    for (int i = 0; i < n; i++) {\n      printf(\"%d \", V[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.util.Scanner;\n\n/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n/**\n *\n * @author sagimbekov_ma\n */\npublic class C459 {\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(System.out));\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        int d = sc.nextInt();\n\n        long pow = 1;\n        boolean bigger = false;\n        for (int i = 0; i < d; i++) {\n            pow *= k;\n            if (pow >= n) {\n                bigger = true;\n                break;\n            }\n        }\n        \n        if (!bigger) {\n            System.out.println(\"-1\");\n        } else {\n\n            for (int i = 0; i < d; i++) {\n                for (int j = 0; j < n; j++) {\n\n                    long q = j;\n                    int cnt = 0;\n                    while (q != 0 && cnt < i) {\n                        q = (long) q / (long) k;\n                        cnt++;\n                    }\n                    bw.write((q % (long) k + 1) + \" \");\n                }\n                bw.write(\"\\n\");\n            }\n            bw.flush();\n        }\n    }\n\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput=sys.stdin.readline\nn,k,d=map(int,input().split())\nif n>k**d:\n    print(-1)\n    exit()\nx=1\nfor i in range(d):\n    ans=[1+i//x%k for i in range(n)]\n    print(*ans)\n    x*=k"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double PI = acos(-1);\nconst double eps = 1e-9;\nconst int inf = 2000000000;\nconst long long infLL = 9000000000000000000;\ninline bool checkBit(long long n, int i) { return n & (1LL << i); }\ninline long long setBit(long long n, int i) { return n | (1LL << i); }\ninline long long resetBit(long long n, int i) { return n & (~(1LL << i)); }\ninline void normal(long long &a) {\n  a %= 1000000007;\n  (a < 0) && (a += 1000000007);\n}\ninline long long modMul(long long a, long long b) {\n  a %= 1000000007;\n  b %= 1000000007;\n  normal(a);\n  normal(b);\n  return (a * b) % 1000000007;\n}\ninline long long modAdd(long long a, long long b) {\n  a %= 1000000007;\n  b %= 1000000007;\n  normal(a);\n  normal(b);\n  return (a + b) % 1000000007;\n}\ninline long long modSub(long long a, long long b) {\n  a %= 1000000007;\n  b %= 1000000007;\n  normal(a);\n  normal(b);\n  a -= b;\n  normal(a);\n  return a;\n}\ninline long long modPow(long long b, long long p) {\n  long long r = 1LL;\n  while (p) {\n    if (p & 1) r = modMul(r, b);\n    b = modMul(b, b);\n    p >>= 1;\n  }\n  return r;\n}\ninline long long modInverse(long long a) { return modPow(a, 1000000007 - 2); }\ninline long long modDiv(long long a, long long b) {\n  return modMul(a, modInverse(b));\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  int n, k, d;\n  cin >> n >> k >> d;\n  long long p = 1LL;\n  bool ok = 0;\n  for (int i = 1; i <= d; ++i) {\n    p *= (long long)k;\n    if (n <= p) {\n      ok = 1;\n      break;\n    }\n  }\n  if (!ok) {\n    cout << \"-1\" << '\\n';\n    return 0;\n  }\n  long long ans[n][d];\n  for (int i = 0; i < d; ++i) ans[0][i] = 0;\n  for (int i = 1; i < n; ++i) {\n    for (int j = 0; j < d; ++j) ans[i][j] = ans[i - 1][j];\n    for (int j = d - 1; j >= 0; --j) {\n      ans[i][j] = (ans[i][j] + 1) % k;\n      if (ans[i][j]) break;\n    }\n  }\n  for (int i = 0; i < d; ++i) {\n    for (int j = 0; j < n; ++j) {\n      if (j != 0) cout << \" \";\n      cout << ans[j][i] + 1;\n    }\n    cout << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n,k,d=map(int,input().split())\nif n>k**d:print(-1);exit(0)\nr=1\nfor j in range(d):\n    print(\" \".join([str(i//r%k +1) for i in range(n)]));r*=k"
        },
        {
            "language": 3,
            "solution": "n, k, d = map(int, input().split())\nif k < n ** (1 / d):\n    print(-1)\nelse:\n    k1 = 1\n    for i in range(d):\n        print(\" \".join(map(str, [(j // k1 % k) + 1 for j in range(n)])))\n        k1 = k * k1\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int n, k, d;\n  cin >> n >> k >> d;\n  int t = 0;\n  int K = 1;\n  while (K <= 1000 and t < d) {\n    K *= k;\n    t++;\n  }\n  if (n > K) {\n    cout << -1 << \"\\n\";\n    return 0;\n  }\n  vector<int> kid(n);\n  for (int i = 0; i < n; ++i) {\n    kid[i] = i;\n  }\n  for (int i = 0; i < d; ++i) {\n    for (int j = 0; j < n; ++j) {\n      cout << (kid[j] % k + 1) << \" \";\n      kid[j] /= k;\n    }\n    cout << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 1,
            "solution": "import sys\n\nday=0\nbus=0;\nN=0;\n\ndef canDo():\n    can=1;\n    for i in range(day):\n        can=can*bus;\n        if(can>=N):\n            return True;\n    return False;\n\ndef getNext(prev):\n    assert( len(prev) == day);\n    prev[day-1]+=1;\n    for i in range(day-1,0,-1):\n        assert(i>0);\n        if( prev[i] == bus+1):\n            prev[i]=1;\n            prev[i-1]+=1;\n    return prev;\n\nif( __name__ == '__main__'):\n    N,bus,day=map(long,str(raw_input()).split() );\n\n    if( not canDo() ):\n        print(\"-1\");\n        sys.exit();\n\n    curr=[ 1 for x in range(day)];\n\n    ans=[ [ 0 for s in range(N+1) ] for x in range(day+1)];\n\n    for i in range(N):\n        for j in range(day):\n            ans[j+1][i+1]= curr[j];\n\n        #print(curr);\n\n        if(i!=N-1):\n            curr=getNext(curr);\n\n    #print(ans)\n\n    for i in range(1,day+1,1):\n        for j in range(1,N+1,1):\n            print(ans[i][j]),\n        print(\"\");\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.StringTokenizer;\n\npublic class PashmakAndBuses implements Closeable {\n\n    private InputReader in = new InputReader(System.in);\n    private PrintWriter out = new PrintWriter(System.out);\n\n    public void solve() {\n        int n = in.ni(), k = in.ni(), d = in.ni();\n        int[][] result = new int[d][n];\n        int temp = 1;\n        boolean ok = false;\n        for (int i = 0; i < d; i++) {\n            temp *= k;\n            if (temp >= n) {\n                ok = true;\n                break;\n            }\n        }\n        if (!ok) {\n            out.println(~0);\n            return;\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < d; j++) {\n                result[j][i] = result[j][i - 1];\n            }\n            for (int j = d - 1; j >= 0; j--) {\n                result[j][i] = (result[j][i] + 1) % k;\n                if (result[j][i] > 0) break;\n            }\n        }\n        for (int i = 0; i < d; i++) {\n            for (int j = 0; j < n; j++) {\n                out.print(result[i][j] + 1);\n                out.print(' ');\n            }\n            out.println();\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        in.close();\n        out.close();\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int ni() {\n            return Integer.parseInt(next());\n        }\n\n        public long nl() {\n            return Long.parseLong(next());\n        }\n\n        public void close() throws IOException {\n            reader.close();\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        try (PashmakAndBuses instance = new PashmakAndBuses()) {\n            instance.solve();\n        }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "\n\n/* Shubhang Verma */\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\npublic class Main {\n\n    public static void main(String[] args) \n    {\t\n        InputStream inputstream = System.in;\n        OutputStream outputstream = System.out;\n        InputReader in = new InputReader(inputstream);\n        OutputWriter out = new OutputWriter(outputstream);\n        mysolver mysol = new mysolver();\n        mysol.solve(in, out);\n        out.close();\n    }\n\n}\nclass node implements Comparable<node>{\n\tint count;\n\tlong value;\n\tpublic int compareTo(node t)\n\t{\n\t\tif(this.value == t.value)\n\t\t\treturn 0;\n\t\telse if(this.value < t.value)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 1;\n\t}\n}\nclass mysolver {\n\tpublic long mod = 1000000007;\n    public void solve(InputReader in,OutputWriter out)\n    {\n    \tPrintWriter pout = new PrintWriter(new BufferedOutputStream(System.out));\t\n    \tint n = in.readInt();\n    \tint k = in.readInt();\n    \tint d = in.readInt();\n    \t\n    \tint dp[][] = new int[n][d];\n    \tint A[] = new int[d];\n    \tfill(dp,d,k,n,A,0);\n    \tif(count < n)\n    \t{\n    \t\tpout.println(\"-1\");\n    \t}\n    \telse\n    \t{\n    \t\tfor(int j=0;j<d;j++)\n    \t\t{\n    \t\t\tfor(int i=0;i<n;i++)\n    \t\t\t{\n    \t\t\t\tpout.print(dp[i][j]+\" \");\n    \t\t\t}\n    \t\t\tpout.println();\n    \t\t}\n    \t}\n        pout.close();\n    }\n    int count = 0;\n   public void fill(int dp[][], int d, int k,int n,int[] A,int idx)\n   {\n\t   if(count == n)\n\t\t   return;\n\t   if(idx == d)\n\t   {\n\n\t\t   for(int i=0;i<d;i++)\n\t\t\t   dp[count][i] = A[i];\n\t\t   count++;\n\t   }\n\t   else\n\t   {\n\t\t   for(int i=1;i<=k;i++)\n\t\t   {\n\t\t\t   if(count == n)\n\t\t\t\t   return;\n\t\t\t   A[idx] = i;\n\t\t\t   fill(dp,d,k,n,A,idx+1);\n\t\t   }\n\t   }\n   }\n    public boolean findpower(int k,int d)\n    {\n    \tlong ans = 1;\n    \tlong val = k;\n    \tint D = d;\n    \twhile(D!=0)\n    \t{\n    \t\tif(D%2==1)\n    \t\t{\n    \t\t\tans = ans*val;\n    \t\t}\n    \t\tif(ans >= d)\n    \t\t\treturn true;\n    \t\tval = val*k;\n    \t\tD = D/2;\n    \t}\n    \treturn false;\n    }\n     \n}\nclass InputReader {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private SpaceCharFilter filter;\n \n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n    \n    public int read() {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n \n    public int readInt() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n \n    public String readString() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n        return res.toString();\n    }\n \n    public boolean isSpaceChar(int c) {\n        if (filter != null)\n            return filter.isSpaceChar(c);\n        return isWhitespace(c);\n    }\n \n    public static boolean isWhitespace(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n \n    public String next() {\n        return readString();\n    }\n \n    public interface SpaceCharFilter {\n        public boolean isSpaceChar(int ch);\n    }\n}\n \nclass OutputWriter {\n    private final PrintWriter writer;\n \n    public OutputWriter(OutputStream outputStream) {\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n \n    public OutputWriter(Writer writer) {\n        this.writer = new PrintWriter(writer);\n    }\n \n    public void close() {\n        writer.close();\n    }\n \n    public void printLine(int i) {\n        writer.println(i);\n    }\n}\n \nclass IOUtils {\n \n    public static void readIntArrays(InputReader in, int[]... arrays) {\n        for (int i = 0; i < arrays[0].length; i++) {\n            for (int j = 0; j < arrays.length; j++)\n                arrays[j][i] = in.readInt();\n        }\n    }\n \n    }\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double pi = acos(-1);\nlong long int n, k, d;\nint anss[1001][1001];\nint main() {\n  bool ans = false;\n  cin >> n >> k >> d;\n  long long int temp = 1;\n  for (int i = 1; i <= d; ++i) {\n    temp *= k;\n    if (temp >= n) {\n      ans = true;\n      break;\n    }\n  }\n  if (!ans) {\n    cout << -1 << endl;\n  } else {\n    for (int i = 1; i <= d; ++i) anss[i][1] = 1;\n    for (int s = 2; s <= n; ++s) {\n      int carry = 1;\n      for (int i = 1; i <= d; ++i) {\n        if (carry == 1) {\n          anss[i][s] = (anss[i][s - 1] % k + carry);\n          carry = (anss[i][s - 1] == k);\n        } else {\n          anss[i][s] = anss[i][s - 1];\n          carry = 0;\n        }\n      }\n    }\n    for (int i = 1; i <= d; ++i) {\n      for (int j = 1; j <= n; ++j) cout << anss[i][j] << \" \";\n      cout << endl;\n    }\n  }\n}\n"
        },
        {
            "language": 1,
            "solution": "#! /usr/bin/env python\n\na=[int(i) for i in raw_input().split()]\nn,k,d=a[0],a[1],a[2]\n\ndef ok(n,k,d):\n    s,p=1,0\n    while(s<=1000 and p<d):\n        s=s*k\n        p=p+1\n    return n<=s\n\ndef ll(n,k,d):\n    s,p=1,0\n    while(s<=1000 and p<d):\n        s=s*k\n        p=p+1\n    return min(n,s)\n\nif ok(n,k,d):\n    for i in range(1,d+1):\n        t,o=1,[]\n        while len(o)<n:\n            o=o+[str(t),]*ll(n-len(o),k,d-i)\n            t=t+1\n            if t>k:t=1\n        print ' '.join(o)\nelse:\n    print -1\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n\npublic class B {\n\n\tpublic static void main(String[] args) throws IOException \n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tint n = sc.nextInt(), k = sc.nextInt(), d = sc.nextInt();\n\t\tif(!possible(n, k, d))\n\t\t\tout.println(-1);\n\t\telse\n\t\t{\n\t\t\tint[][] ans = new int[n][d];\n\t\t\tint[] a = new int[d];\n\t\t\tArrays.fill(a, 1);\n\t\t\tfor(int i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tans[i] = Arrays.copyOf(a, d);\n\t\t\t\tinc(a, k);\n\t\t\t}\n\t\t\tfor(int j = 0; j < d; ++j)\n\t\t\t{\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tfor(int i = 0; i < n; ++i)\n\t\t\t\t{\n\t\t\t\t\tif(i != 0)\n\t\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\tsb.append(ans[i][j]);\n\t\t\t\t}\n\t\t\t\tout.println(sb);\n\t\t\t}\n\t\t}\n\t\tout.flush();\n\t\tout.close();\n\t}\n\t\n\tstatic void inc(int[] a, int k)\n\t{\n\t\tint i = a.length - 1;\n\t\ta[i]++;\n\t\twhile(i >= 0 && a[i] == k + 1)\n\t\t{\n\t\t\ta[i] = 1;\n\t\t\tif(i > 0)\n\t\t\t\ta[i - 1]++;\n\t\t\ti--;\n\t\t}\n\t}\n\n\tstatic boolean possible(int n, int k, int d)\n\t{\n\t\tint res = 1;\n\t\twhile(res < n && d-->0)\n\t\t\tres *= k;\n\t\treturn res >= n;\t\n\t}\n\n\tstatic class Scanner \n\t{\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s){\tbr = new BufferedReader(new InputStreamReader(s));}\n\n\t\tpublic Scanner(FileReader r){\tbr = new BufferedReader(r);}\n\n\t\tpublic String next() throws IOException \n\t\t{\n\t\t\twhile (st == null || !st.hasMoreTokens()) \n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n\n\t\tpublic long nextLong() throws IOException {return Long.parseLong(next());}\n\n\t\tpublic String nextLine() throws IOException {return br.readLine();}\n\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(next()); }\n\n\t\tpublic boolean ready() throws IOException {return br.ready();}\n\n\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "n,k,d=map(int,input().split())\nif(n>pow(k,d)):\n    print(-1)\nelse:\n    temp=[]\n    ans=[1]*d\n    temp.append(ans)\n    m=n\n    m-=1\n    count=1\n    r=1\n    while(m):\n        ans=[0 for i in range(d)]\n        count=r\n        \n        for i in range(d):\n            ans[len(ans)-1-i]=count%k\n            count=count//k\n    \n        for i in range(len(ans)):\n            ans[i]+=1\n        temp.append(ans)\n        r+=1\n        m-=1\n    for i in range(d):\n        for j in range(len(temp)):\n            print(temp[j][i],end=\" \")\n        print(' ')\n        \n"
        },
        {
            "language": 1,
            "solution": "n,k,d=(int(u) for u in raw_input().split())\ng,c=[[0]*n for i in xrange(d)],0\nif n>k**d: print -1,exit()\nfor i in xrange(n):\n    e=c\n    for j in xrange(d):\n        g[j][i]=1+(e%k)\n        e/=k\n    c+=1\nprint '\\n'.join(' '.join(str(r) for r in k) for k in g)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, d, di[1000 + 10][1000 + 10];\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &d);\n  for (int i = 0; i < n; ++i) {\n    int l = 0;\n    bool f = 0;\n    for (int j = i; j; j /= k) {\n      di[i][++l] = j % k;\n      if (l > d) {\n        f = 1;\n        break;\n      }\n    }\n    if (f) {\n      puts(\"-1\");\n      return 0;\n    }\n  }\n  for (int i = d; i; --i)\n    for (int j = 0; j < n; ++j)\n      printf(\"%d%c\", di[j][i] + 1, j == n - 1 ? '\\n' : ' ');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, k, d;\n  cin >> n >> k >> d;\n  long long tmp = 1;\n  bool check = false;\n  for (int i = 0; i < d; i++) {\n    tmp *= k;\n    if (tmp >= n) {\n      check = true;\n      break;\n    }\n  }\n  if (!check) {\n    cout << -1 << endl;\n    return 0;\n  }\n  int temp[d];\n  int ans[n][d];\n  int ind = d - 1;\n  for (int i = 0; i < d; i++) temp[i] = 1;\n  for (int i = 0; i < n; i++) {\n    for (int j = d - 1; j >= 0; j--) {\n      ans[i][j] = temp[j];\n      if (ans[i][j] > k) {\n        ans[i][j] = 1;\n        ans[i][j - 1] += 1;\n      }\n    }\n    int j = d - 1;\n    while (j >= 0 && temp[j] == k) {\n      temp[j] = 1;\n      j--;\n    }\n    if (j >= 0) {\n      ++temp[j];\n    }\n  }\n  for (int i = 0; i < d; i++) {\n    for (int j = 0; j < n; j++) cout << ans[j][i] << ' ';\n    cout << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n,k,d=map(int,input().split(\" \"))\nif n>pow(k,d):\n    print(-1)\nelse:\n    raw = [' ']*n\n    table = [[1]*d]\n    p = 1\n    for i in range(d):\n    \tcv = 1\n    \tfor j in range(n):\n    \t\tif j % p == 0 and j != 0:\n    \t\t\tcv = cv + 1\n    \t\t\tif cv == k+1:\n    \t\t\t\tcv = 1\n    \t\traw[j]= str(cv)\n    \tprint(' '.join(raw))\n    \tp = p * k\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid _fill_int(int* p, int val, int rep) {\n  int i;\n  for (i = 0; i < rep; i++) p[i] = val;\n}\nsigned long long N, K, D;\nint mat[1001][1001];\nvoid dfs(int d, int l, int r) {\n  if (d >= D) return;\n  int i;\n  if (r - l <= K) {\n    for (i = 0; i < r - l; i++) mat[d][i + l] = i;\n  } else {\n    int st = (r - l + (K - 1)) / K;\n    for (i = 0; i * st + l < r; i++) {\n      int j;\n      for (j = 0; j < st; j++)\n        if (l + i * st + j < r) mat[d][l + i * st + j] = i;\n      dfs(d + 1, l + i * st, min(l + (i + 1) * st, r));\n    }\n  }\n}\nvoid solve() {\n  int f, i, j, k, l, x, y;\n  cin >> N >> K >> D;\n  if (K >= N) {\n    for (i = 0; i < D; i++) {\n      for (j = 0; j < N; j++) (void)printf(\"%d \", j + 1);\n      (void)printf(\"\\n\");\n    }\n    return;\n  }\n  signed long long t = 1;\n  for (i = 0; i < D; i++) {\n    t *= K;\n    if (t >= N) break;\n  }\n  if (i == D) return (void)printf(\"-1\\n\");\n  dfs(0, 0, N);\n  for (i = 0; i < D; i++) {\n    for (j = 0; j < N; j++) (void)printf(\"%d \", mat[i][j] + 1);\n    (void)printf(\"\\n\");\n  }\n}\nint main(int argc, char** argv) {\n  string s;\n  if (argc == 1) ios::sync_with_stdio(false);\n  for (int i = 1; i < argc; i++) s += argv[i], s += '\\n';\n  for (int i = s.size() - 1; i >= 0; i--) ungetc(s[i], stdin);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "def incr(a, k):\n    carry = 1\n    for i in range(len(a) - 1, -1, -1):\n        newval = a[i] + carry\n        if newval >= k:\n            if i == 0:\n                return False\n            newval = 0\n            carry = 1\n        else:\n            carry = 0\n        a[i] = newval\n    return True\ndef sol():\n    n, k, d = map(int, raw_input().split())\n    a = [0] * d\n    tempres = list()\n    nextFine = True\n    for want in xrange(n):\n        if not nextFine:\n            print(-1)\n            return\n        tempres.append(list(val + 1 for val in a))\n        nextFine = incr(a, k)\n    res = [[0] * n for _ in xrange(d)]\n    for day in xrange(d):\n        for student in xrange(n):\n            res[day][student] = tempres[student][day]\n    print('\\n'.join(' '.join(map(str, l)) for l in res))\nsol()"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\n\n/**\n * Created by hama_du on 2014/08/24.\n */\npublic class ProblemC {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        int n = in.nextInt();\n        int k = in.nextInt();\n        int d = in.nextInt();\n\n\n        long data = 1L;\n        boolean isOK = false;\n        for (int i = 0 ; i < d ; i++) {\n            data *= k;\n            if (n <= data) {\n                isOK = true;\n                break;\n            }\n        }\n        if (!isOK) {\n            System.out.println(-1);\n            return;\n        }\n\n        int[][] ans = new int[d][n];\n        for (int i = 0 ; i < n ; i++) {\n            int f = i;\n            for (int j = 0 ; j < d ; j++) {\n                ans[j][i] = (f % k) + 1;\n                f /= k;\n            }\n        }\n\n        for (int[] l : ans) {\n            StringBuffer b = new StringBuffer();\n            for (int i : l) {\n                b.append(' ').append(i);\n            }\n            System.out.println(b.substring(1));\n        }\n\n\n\n\n    }\n\n    static int[] compress(int[] a) {\n        int n = a.length;\n        Set<Integer> set = new HashSet<>();\n        for (int i : a) {\n            set.add(i);\n        }\n        List<Integer> list = new ArrayList<>();\n        for (int s : set) {\n            list.add(s);\n        }\n        Collections.sort(list);\n\n        Map<Integer,Integer> map = new HashMap<>();\n        for (int i = 0 ; i < list.size() ; i++) {\n            map.put(list.get(i), i);\n        }\n        int[] ret = new int[n];\n        for (int i = 0 ; i < n ; i++) {\n            ret[i] = map.get(a[i]);\n        }\n        return ret;\n    }\n\n\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return x * f;\n}\nint n, k, d;\nint a[1005][1005];\nint main() {\n  n = read();\n  k = read();\n  d = read();\n  long long tmp = 1;\n  for (int i = 1; i <= d; i++) {\n    tmp *= k;\n    if (tmp >= n) break;\n  }\n  if (tmp < n) {\n    puts(\"-1\");\n    return 0;\n  }\n  for (int i = 1; i <= d; i++) a[i][1] = 1;\n  for (int i = 2; i <= n; i++) {\n    for (int j = 1; j <= d; j++) a[j][i] = a[j][i - 1];\n    int j = d;\n    while (a[j][i] == k) j--;\n    a[j][i]++;\n    for (int q = j + 1; q <= n; q++) a[q][i] = 1;\n  }\n  for (int i = 1; i <= d; i++) {\n    for (int j = 1; j <= n; j++) printf(\"%d \", a[i][j]);\n    puts(\"\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class CR261_pashmak_and_buses {\n\n    public static void main(String... args) throws IOException {\n        MyScanner sc = new MyScanner();\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        int d = sc.nextInt();\n\n        if (Math.pow(k, d) < n) {\n            System.out.println(\"-1\");\n            return;\n        }\n        long step = 1;\n        for (int i = 0; i < d; i++) {\n            int v = 0;\n            int c = 0;\n            StringBuilder sb = new StringBuilder();\n            for (int j = 0; j < n; j++) {\n                sb.append(v + 1).append(' ');\n                c++;\n                if (c == step) {\n                    v = (v + 1) % k;\n                    c = 0;\n                }\n            }\n            System.out.println(sb.toString());\n            step = Math.min(n+1, step * k);\n        }\n    }\n\n    static class MyScanner {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public String next() throws IOException {\n            if (st == null || !st.hasMoreTokens()) {\n                String line = br.readLine();\n                st = new StringTokenizer(line);\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            String next = next();\n            return Integer.parseInt(next);\n        }\n\n        private long nextLong() throws IOException {\n            String next = next();\n            return Long.parseLong(next);\n        }\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "In = lambda :  map(int,input().split())\nn , k ,d = In()\nif(n > k**d):\n    print (-1)\nelse :\n    k1 = 1\n    for i in range(d):\n        print(\" \".join(map(str, [(j // k1 % k) + 1 for j in range(n)])))\n        k1 = k1 * k;\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\n\npublic class E {\n\tpublic static void main(String[] args) {\n\t\tFastScannerE sc = new FastScannerE(System.in);\n\t\t\n\t\tint N = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tint D = sc.nextInt();\n\t\t\n\t\t//check for -1\n\t\tint kids = N;\n\t\tfor(int i = 0; i<D; i++){\n\t\t\tint ceil = kids / K;\n\t\t\tif(kids % K > 0) ceil++;\n\t\t\tkids = ceil;\n\t\t}\n\t\t\n\t\tif(kids > 1){\n\t\t\tSystem.out.println(-1);\n\t\t}\n\t\telse{\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint[] list = new int[N];\n\t\t\tfor(int i = 0; i<N; i++) list[i] = i;\n\t\t\tfor(int d = 0; d<D; d++){\n\t\t\t\t\n\t\t\t\tint[] newlist = new int[N];\n\t\t\t\tint[] busses = new int[N];\n\t\t\t\tint ii = 0;\n\t\t\t\tfor(int i = 0, min1 = Math.min(K, N); i < min1; i++){\n\t\t\t\t\tfor(int j = i; j<N; j += K){\n\t\t\t\t\t\tint ind = list[j];\n\t\t\t\t\t\tnewlist[ii] = ind;\n\t\t\t\t\t\tii++;\n\t\t\t\t\t\tbusses[ind] = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist = newlist;\n\t\t\t\t\n\t\t\t\tfor(int i : busses){\n\t\t\t\t\tsb.append(i + 1);\n\t\t\t\t\tsb.append(' ');\n\t\t\t\t}\n\t\t\t\tsb.setLength(sb.length() - 1);\n\t\t\t\tsb.append('\\n');\n\t\t\t}\n\t\t\tSystem.out.print(sb);\n\t\t}\n\t}\n}\n\nclass FastScannerE {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private SpaceCharFilter filter;\n\n    public FastScannerE(InputStream is) {\n        stream = is;\n    }\n\n    public int read() {\n        if (numChars == -1) throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try{\n                numChars = stream.read(buf);\n            }\n            catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0) return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int nextInt(){\n        int c = read();\n        while (isSpaceChar(c)) c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9') throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public String next() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n        return res.toString();\n    }  \n\n    public double nextDouble() {\n        int c = read();\n        while (isSpaceChar(c)) c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        double res = 0;\n        while (!isSpaceChar(c) && c != '.') {\n            if (c == 'e' || c == 'E') return res * Math.pow(10, nextInt());\n            if (c < '0' || c > '9') throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        }\n        if (c == '.') {\n            c = read();\n            double m = 1;\n            while (!isSpaceChar(c)) {\n                if (c == 'e' || c == 'E') return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9') throw new InputMismatchException();\n                m /= 10;\n                res += (c - '0') * m;\n                c = read();\n            }\n        }\n        return res * sgn;\n    }\n    \n    public long nextLong() {\n        int c = read();\n        while (isSpaceChar(c)) c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0;\n        do {\n            if (c < '0' || c > '9') throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n    \n    public boolean isSpaceChar(int c) {\n        if (filter != null) return filter.isSpaceChar(c);\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public interface SpaceCharFilter {\n        public boolean isSpaceChar(int ch);\n    }\n}"
        },
        {
            "language": 3,
            "solution": "import sys\ndef get_ints(): return list(map(int, sys.stdin.readline().strip().split()))\n \narr = get_ints()\n\nn = arr[0]\nk = arr[1]\nd = arr[2]\n\nmaxs = pow(k,d)\nif n > maxs:\n    print(-1)\nelse:\n    ans = []\n    count = 0 \n    strs = \"\"\n    numarr = []\n    countarr = []\n    for i in range(d):\n        numarr.append(1)    \n        countarr.append(0)\n    countarr[0] = -1\n    #ans.append(strs)\n    flag = 1\n    for ii in range(n):\n        countarr[0]  += 1\n        flag = 0 \n        digit = countarr[0] +numarr[0]\n        if digit <= k :\n            subsubarr = []\n            for i in range(d):\n                subsubarr.append(str(countarr[i] + numarr[i]  ) )\n            subsubarr = subsubarr[::-1]\n            subans = \"\"\n            for subss in subsubarr:\n                subans += subss\n                subans += \" \"\n            #print(subans)\n            ans.append(subans[:-1])\n        else:\n            finalarr = []\n            nn = len(countarr)\n            for j in range(nn):\n                if countarr[j] + numarr[j] > k :\n                    countarr[j] = 0 \n                    countarr[j + 1] += 1 \n            subsubarr = []\n            for i in range(d):\n                subsubarr.append(str(countarr[i] + numarr[i]  ) )\n            subsubarr = subsubarr[::-1]\n            subans = \"\"\n            for subss in subsubarr:\n                subans += subss\n                subans += \" \"\n            ans.append(subans[:-1])\n    # for subans in ans:\n    #     print(subans)\n            \n            # strsnum = str(count)\n            # strsnum = strsnum[::-1]\n            # carry = 0 \n            # finalstrs = \"\"\n            # print(\"hhh\")\n            # #print(strsnum)\n            # for j in strsnum:\n            #     jint = int(j)\n            #     if jint + carry == k:\n            #         #print(\"hi\")\n            #         carry = 1 \n            #         finalstrs += \"1\"\n            #     else:\n            #         finalstrs += str(jint + carry)\n            #         carry = 0 \n            # if carry == 1 :\n            #     finalstrs += \"1\"\n            # print(finalstrs)\n            # finalstrs = finalstrs[::-1]\n            # flag = 0 \n            # count = int(finalstrs)\n            # newnumstrs =  numstrs  + count \n            # ans.append(str(newnumstrs))\n            \n    # for i in range(d):\n    #     substring = \"\"\n    #     for subans in ans:\n    #         substring += subans[i]\n    #         substring += \" \"\n    #     print(substring)\n    finalans = []\n    #print(ans)\n    for subans in ans:\n        subs = subans.split(\" \")\n        finalans.append(subs)\n\n    for i in range(d):\n        substring = \"\"\n        for subans in finalans:\n            substring += subans[i]\n            substring += \" \"\n        print(substring)\n        \n    \n    \n    \n    \n    "
        },
        {
            "language": 4,
            "solution": "/**\n * DA-IICT\n * Author : PARTH PATEL\n */\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.fill;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.sort;\nimport static java.util.Collections.sort;\n\n\npublic class C459 {\n\n\tpublic static int mod = 1000000007;\n\tpublic static long INF = (1L << 58);\n\tstatic FasterScanner in = new FasterScanner();\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\n\tpublic static void main(String[] args) {\n\n\t\tint n=in.nextInt();\n\t\tint k=in.nextInt();\n\t\tint d=in.nextInt();\n\t\tif(n>Math.pow(k, d))\n\t\t{\n\t\t\tSystem.out.println(-1);\n\t\t\treturn;\n\t\t}\n\t\tint[][] answer=new int[1005][1005];\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint p=i;\n\t\t\tint j=0;\n\t\t\twhile(p>0)\n\t\t\t{\n\t\t\t\tanswer[j++][i]=p%k;\n\t\t\t\tp/=k;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<d;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tout.print((answer[i][j]+1)+\" \");\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t\tout.close();\n\n\t}\n\n\tpublic static long pow(long x, long n, long mod) {\n\t\tlong res = 1;\n\t\tfor (long p = x; n > 0; n >>= 1, p = (p * p) % mod) {\n\t\t\tif ((n & 1) != 0) {\n\t\t\t\tres = (res * p % mod);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static long gcd(long n1, long n2) {\n\t\tlong r;\n\t\twhile (n2 != 0) {\n\t\t\tr = n1 % n2;\n\t\t\tn1 = n2;\n\t\t\tn2 = r;\n\t\t}\n\t\treturn n1;\n\t}\n\n\tpublic static long lcm(long n1, long n2) {\n\t\tlong answer = (n1 * n2) / (gcd(n1, n2));\n\t\treturn answer;\n\t}\n\n\tstatic class FasterScanner {\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int snumChars;\n\n\t\tpublic int read() {\n\t\t\tif (snumChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= snumChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tsnumChars = System.in.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextString() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] arr = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextInt();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] arr = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextLong();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tprivate boolean isEndOfLine(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\t}\n\n}\n"
        },
        {
            "language": 4,
            "solution": "//Author: QCC\n\nimport java.io.*;\nimport java.util.*;\n\n/*------------------------------------*/\n\npublic class CF459C {\n\n    //Global Variables\n    int n, k, d;\n    int[][] res;\n    int[] x = new int[1001];\n    int cnt = 1;\n    //Methods\n\n    private void attempt(int i) {\n        if (cnt > n) return;\n        if (i > d) {\n            for(int j = 1; j <= d; ++j)\n                res[j][cnt] = x[j];\n            cnt++;\n            return;\n        }\n        for(int j = 1; j <= k; j++) {\n            x[i] = j;\n            attempt(i+1);\n            x[i] = 0;\n            if (cnt > n) return;\n        }\n    }\n\n    private void solve() {\n        n = in.nextInt();\n        k = in.nextInt();\n        d = in.nextInt();\n        long cntMaximumResult = 1;\n        for(int i = 1; i <= d; ++i)\n            cntMaximumResult = Math.min((long)1000000001, (long)cntMaximumResult*(long)k);\n        if (cntMaximumResult < n) {\n            out.println(\"-1\");\n            return;\n        }\n        res = new int[1001][1001];\n        attempt(1);\n        for(int i = 1; i <= d; ++i ) {\n            for (int j = 1; j <= n; ++j ) {\n                out.print(res[i][j] + \" \");\n            }\n            out.println();\n        }\n\n    }\n    \n    public static void main (String[] args) throws java.lang.Exception {        \n        long startTime = System.currentTimeMillis();\n\n        out = new PrintWriter(System.out);\n        new CF459C().solve();   \n        //out.println((String.format(\"%.2f\",(double)(System.currentTimeMillis()-startTime)/1000)));\n        out.close();\n    }\n\n    static PrintWriter out;\n    static class in {\n        static BufferedReader reader = new BufferedReader( new InputStreamReader(System.in) ) ;\n        static StringTokenizer tokenizer = new StringTokenizer(\"\");             \n        static String next() {      \n            while ( !tokenizer.hasMoreTokens() )\n                try { tokenizer = new StringTokenizer( reader.readLine() ); }\n                catch (IOException e){\n                    throw new RuntimeException(e);          \n                }       \n            return tokenizer.nextToken();\n        }\n        static int nextInt() { return Integer.parseInt( next() ); }         \n    }\n}"
        },
        {
            "language": 4,
            "solution": "/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\n\nimport java.awt.Point;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.text.*;\n\npublic class cf459c {\n\n    static BufferedReader br;\n    static Scanner sc;\n    static PrintWriter OUT_;\n    static StringBuilder BUFFER_OUT = new StringBuilder();\n    \n    public static void initA() {\n        try {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            sc = new Scanner(System.in);\n            OUT_ = new PrintWriter(System.out);\n        } catch (Exception e) {\n        }\n    }\n\n    static boolean next_permutation(Integer[] p) {\n        for (int a = p.length - 2; a >= 0; --a) {\n            if (p[a] < p[a + 1]) {\n                for (int b = p.length - 1;; --b) {\n                    if (p[b] > p[a]) {\n                        int t = p[a];\n                        p[a] = p[b];\n                        p[b] = t;\n                        for (++a, b = p.length - 1; a < b; ++a, --b) {\n                            t = p[a];\n                            p[a] = p[b];\n                            p[b] = t;\n                        }\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    public static String getString() {\n        try {\n            return br.readLine();\n        } catch (Exception e) {\n        }\n        return \"\";\n    }\n\n    public static Integer getInt() {\n        try {\n            return Integer.parseInt(br.readLine());\n        } catch (Exception e) {\n        }\n        return 0;\n    }\n\n    public static Integer[] getIntArr() {\n        try {\n            StringTokenizer temp = new StringTokenizer(br.readLine());\n            int n = temp.countTokens();\n            Integer temp2[] = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                temp2[i] = Integer.parseInt(temp.nextToken());\n            }\n            return temp2;\n        } catch (Exception e) {\n        }\n        return null;\n    }\n\n    public static Long[] getLongArr() {\n        try {\n            StringTokenizer temp = new StringTokenizer(br.readLine());\n            int n = temp.countTokens();\n            Long temp2[] = new Long[n];\n            for (int i = 0; i < n; i++) {\n                temp2[i] = Long.parseLong(temp.nextToken());\n            }\n            return temp2;\n        } catch (Exception e) {\n        }\n        return null;\n    }\n\n    public static String[] getStringArr() {\n        try {\n            StringTokenizer temp = new StringTokenizer(br.readLine());\n            int n = temp.countTokens();\n            String temp2[] = new String[n];\n            for (int i = 0; i < n; i++) {\n                temp2[i] = (temp.nextToken());\n            }\n            return temp2;\n        } catch (Exception e) {\n        }\n        return null;\n    }\n\n    public static void println(Object a) {\n        BUFFER_OUT.append(a+\"\\n\");\n        //out.println(a);\n    }\n    public static void print(Object a) {\n        BUFFER_OUT.append(a);\n        //out.println(a);\n    }\n\n    public static void print(String s, Object... a) {\n        BUFFER_OUT.append(String.format(s, a));\n       // out.printf(s, a);\n    }\n\n    public static int nextInt() {\n        return sc.nextInt();\n    }\n\n    public static double nextDouble() {\n        return sc.nextDouble();\n    }\n\n    public static void main(String[] ar) {\n        initA();\n        cf459c c = new cf459c();\n        c.solve();\n        OUT_.write(BUFFER_OUT.toString());\n        OUT_.flush();\n    }\n    ArrayList<Integer> base_perm = new ArrayList<Integer>();\n    HashSet<Long> sdh = new HashSet<Long>();\n    int bth;\n    int n, k, d;\n    Integer temp[] = new Integer[1000 + 5];\n    int kolom_dikerjakan = 0;\n    Integer ou[][] = new Integer[1005][1005];\n\n    void dfs(int i, int j, long hash) {\n\n        if (kolom_dikerjakan == n) {\n            // print(\"SELSE\");\n            return;\n        }\n        if (j == d) {\n            if (!sdh.contains(hash)) {\n                Integer tx[] = new Integer[d];\n                System.arraycopy(temp, 0, tx, 0, tx.length);\n\n\n               // print(Arrays.asList(tx) + \" KERJAKAN KOLOM \"+kolom_dikerjakan);\n                for (; kolom_dikerjakan < n; ) {\n                    for (int x = 0; x < d; x++) {\n                        ou[x][kolom_dikerjakan] = tx[x];\n                       // print(\"SET \"+x+\",\"+kolom_dikerjakan +\" = \"+tx[x]);\n                    }\n                    kolom_dikerjakan++;\n                    boolean a = next_permutation(tx);\n                    if (!a) {\n                        break;\n                    }\n                }\n                sdh.add(hash);\n            }\n            return;\n        }\n        if (i == base_perm.size()) {\n            return;\n        }\n        temp[j] = base_perm.get(i);\n        dfs(i + 1, j + 1, hash * k + base_perm.get(i));\n\n        //ambil sama berulang\n        dfs(i, j + 1, hash * k + base_perm.get(i));\n\n        //ini di bawahnya krn supaya tdk mengganti temp[j] dgn kanannya\n        //ambil angka berikut\n        dfs(i + 1, j, hash);\n\n\n    }\n\n    void solve() {\n        Integer xx[] = getIntArr();\n        n = xx[0];\n        k = xx[1];\n        d = xx[2];\n\n        if (n > 1 && (k == 1 || (d == 1 && k < n) )) {\n            print(-1);\n            return;\n        }\n        //n = kolom d = baris\n        long st =System.currentTimeMillis();\n        bth = n * d;\n\n        //print(\"BUTUH \"+bth);\n        for (int i = 1; base_perm.size() < bth && i <= k; i++) {\n            //for (int j = 0; base_perm.size() < bth && j < d; j++) {\n            base_perm.add(i);\n            //}\n        }\n        //print(\"BASE \" + base_perm);\n        dfs(0, 0, 0);\n        /*\n        for (Integer[] x : list_) {\n        print(Arrays.asList(x));\n        }\n        print(sdh);\n         */\n\n        if (kolom_dikerjakan != n) {\n            print(-1);\n            return;\n        }\n       // print(\"SELSE DALAM \"+(System.currentTimeMillis() - st));\n        for (int i = 0; i < d; i++) {\n            for (int j = 0; j < n; j++) {\n                print(ou[i][j]+\" \");\n            }\n            println(\"\");\n        }\n\n\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class CF261C \n{\n\tstatic boolean check(long n,long k,long d)\n\t{\n\t\tlong res=k;\n\t\tfor(int i=0;i<d-1;i++)\n\t\t{\n\t\t\tif(n<=res)\n\t\t\t\treturn true;\n\t\t\tres*=k;\n\t\t}\n\t\tif(n<=res)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tpublic static void main(String args[]) {\n\t\tInputReader in = new InputReader(System.in);\n\t\tOutputStream outputStream = System.out;\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\t/*------------------------------My Code starts here------------------------------*/\n\t\tint n=in.nextInt(),k=in.nextInt(),d=in.nextInt(),i=0,j=0,t;\n\t\tif(!check(n, k, d))\n\t\t{\n\t\t\tout.print(-1);\n\t\t\tout.close();\n\t\t\treturn ;\n\t\t}\t\n\t\tint[][] dp=new int[d][n];\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tt=i;\n\t\t\tfor(j=0;j<d;j++)\n\t\t\t{\n\t\t\t\tdp[d-j-1][i]=t%k;\n\t\t\t\tt/=k;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<d;i++)\n\t\t{\n\t\t\tfor(j=0;j<n;j++)\n\t\t\t\tout.print((dp[i][j]+1)+\" \");\n\t\t\tout.println();\n\t\t}\n\t\tout.close();\n\t\t/*------------------------------The End------------------------------------------*/\n\t}\n\n\tpublic static final long l = (int) (1e9 + 7);\n\n\tprivate static int[] nextIntArray(InputReader in, int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = in.nextInt();\n\t\treturn a;\n\t}\n\n\tprivate static long[] nextLongArray(InputReader in, int n) {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = in.nextLong();\n\t\treturn a;\n\t}\n\n\tprivate static int[][] nextIntMatrix(InputReader in, int n, int m) {\n\t\tint[][] a = new int[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = in.nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\n\tprivate static void show(int[] a) {\n\t\tfor (int i = 0; i < a.length; i++)\n\t\t\tSystem.out.print(a[i] + \" \");\n\t\tSystem.out.println();\n\t}\n\n\tprivate static void show2DArray(char[][] a) {\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[0].length; j++)\n\t\t\t\tSystem.out.print(a[i][j]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic class Pair {\n\t\tprivate int first;\n\t\tprivate int second;\n\n\t\tpublic Pair(int i, int j) {\n\t\t\tthis.first = i;\n\t\t\tthis.second = j;\n\t\t}\n\n\t\tpublic int getFirst() {\n\t\t\treturn first;\n\t\t}\n\n\t\tpublic int getSecond() {\n\t\t\treturn second;\n\t\t}\n\n\t\tpublic void setFirst(int k) {\n\t\t\tthis.first = k;\n\t\t}\n\n\t\tpublic void setSecond(int k) {\n\t\t\tthis.second = k;\n\t\t}\n\t}\n\n\tstatic int modPow(int a, int b, int p) {\n\t\tint result = 1;\n\t\ta %= p;\n\t\twhile (b > 0) {\n\t\t\tif ((b & 1) != 0)\n\t\t\t\tresult = (result * a) % p;\n\t\t\tb = b >> 1;\n\t\ta = (a * a) % p;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static void SieveOfEratosthenes(int n) {\n\t\tboolean[] prime = new boolean[n + 1];\n\t\tArrays.fill(prime, true);\n\t\tprime[1] = false;\n\t\tint i, j;\n\t\tfor (i = 2; i * i <= n; i++) {\n\t\t\tif (prime[i]) {\n\t\t\t\tfor (j = i; j <= n; j += i) {\n\t\t\t\t\tif (j != i)\n\t\t\t\t\t\tprime[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tpublic BufferedReader reader;\n\t\tpublic StringTokenizer tokenizer;\n\n\t\tpublic InputReader(InputStream inputstream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(inputstream));\n\t\t\ttokenizer = null;\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tString fullLine = null;\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tfullLine = reader.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t\treturn fullLine;\n\t\t\t}\n\t\t\treturn fullLine;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1000;\nconst int K = 1000000000;\nlong long max_power_of(long long k, int d, long long n, long long acc) {\n  if (acc >= n) {\n    return acc;\n  } else if (d == 0) {\n    return acc;\n  } else {\n    return max_power_of(k, d - 1, n, acc * k);\n  }\n}\nbool feasible(int n, int d, long long k) {\n  return max_power_of(k, d, n, 1) >= n;\n}\nvoid next_number(int *begin, int *end, int base) {\n  int *curr = begin;\n  while (curr != end) {\n    if (*curr + 1 <= base) {\n      *curr += 1;\n      break;\n    } else {\n      *curr = 1;\n      curr++;\n    }\n  }\n}\nint main() {\n  int n, d;\n  long long k;\n  cin >> n >> k >> d;\n  if (feasible(n, d, k)) {\n    int permutation[N];\n    int assignments[N * N];\n    for (int i = 0; i < d; i++) {\n      permutation[i] = 1;\n    }\n    for (int j = 0; j < n; j++) {\n      for (int i = 0; i < d; i++) {\n        assignments[i * n + j] = permutation[i];\n      }\n      next_number(permutation, permutation + d, (int)k);\n    }\n    for (int i = 0; i < d; i++) {\n      for (int j = 0; j < n; j++) {\n        cout << assignments[i * n + j] << ' ';\n      }\n      cout << endl;\n    }\n  } else {\n    cout << -1 << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nT min3(T a, T b, T c) {\n  return min(a, min(b, c));\n};\ntemplate <class T>\nT max3(T a, T b, T c) {\n  return max(a, max(b, c));\n};\nvoid openFile() {\n  freopen(\"/home/khaihanhdk/MyWorkplace/cpp file/a.inp\", \"r\", stdin);\n}\nvector<int> r[1010];\nint n, k, d;\nbool trying(int ind) {\n  int h = ind - 1;\n  for (int i = 0; i < r[h].size(); i++) {\n    int b = r[h][i] / k;\n    int c = r[h][i] % k;\n    for (int j = 0; j < c; j++) {\n      int x = b + 1;\n      r[ind].push_back(x);\n    }\n    if (b != 0)\n      for (int j = 0; j < k - c; j++) {\n        r[ind].push_back(b);\n      }\n  }\n  if ((int)r[ind].size() == n) return true;\n  return false;\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &d);\n  r[0].push_back(n);\n  bool p = false;\n  for (int i = 1; i <= d; i++) {\n    p = (trying(i) == true || p);\n  }\n  if (!p) {\n    cout << -1;\n    return 0;\n  }\n  for (int i = 1; i <= d; i++) {\n    for (int j = 0; j < (int)r[i].size(); j++) {\n      for (int l = 0; l < r[i][j]; l++) cout << (j % k) + 1 << \" \";\n    }\n    cout << endl;\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\nimport math\n\n\ndef main():\n    pass\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\n\ndef main():\n    pass\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nn,k,d=map(int,input().split())\nif(n>k**d):\n    print(-1)\nelse:\n    ans=[i for i in range(0,n)]\n    for i in range(0,d):\n        for j in range(0,n):\n            print(ans[j]%k+1,end=\" \")\n            ans[j]//=k\n        print(\"\")\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long power(long long x, long long y) {\n  long long res = 1LL;\n  x = x % 1000000007;\n  while (y > 0) {\n    if (y & 1) res = (res * x) % 1000000007;\n    y = y >> 1;\n    x = (x * x) % 1000000007;\n  }\n  return res % 1000000007;\n}\nlong long inv(long long n) { return power(n, 1000000007 - 2) % 1000000007; }\nlong long n, k, d, m[1005][1005];\nvoid solve() {\n  cin >> n >> k >> d;\n  long long p = 1, i, j;\n  for (i = 1; i <= d; i++) {\n    p *= k;\n    if (p >= n) break;\n  }\n  if (p < n) {\n    cout << \"-1\\n\";\n    return;\n  }\n  for (i = 0; i < n; i++) {\n    long long j = 0;\n    long long x = i;\n    for (j = 0; j < d; j++) {\n      m[i][j] = x % k;\n      x /= k;\n    }\n  }\n  for (i = 0; i < d; i++) {\n    for (j = 0; j < n; j++) cout << 1 + m[j][i] << \" \";\n    cout << \"\\n\";\n  }\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long t = 1;\n  while (t--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "import math \nn,k,d = map(int,input().split())\n# if math.log(n)>d*math.log(k): chadar%\nif n>k**d:\n\tprint(-1)\nelse:\n\t# no pgh shit \n\tt = 1\n\tfor i in range(d):\n\t\tli = []\n\t\tfor j in range(n):\n\t\t\tli.append((j//t)%k+1)\n\t\tprint(*li)\n\t\tt*=k\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedInputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * Created by jizhe on 2016/1/14.\n */\npublic class PashmakAndBuses {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(new BufferedInputStream(System.in));\n        StringBuilder out = new StringBuilder();\n\n        int N = in.nextInt();\n        int K = in.nextInt();\n        int D = in.nextInt();\n\n        if( (double)N > Math.pow(K, D) )\n        {\n            System.out.printf(\"-1\\n\");\n            return;\n        }\n\n        int[] number = new int[D+1];\n        int[][] result = new int[D+1][N+1];\n        Arrays.fill(number, 1);\n\n        int count = 1;\n        while( count <= N )\n        {\n            /*for( int i = 1; i < D+1; i++ )\n            {\n                System.out.printf(\"%d \", number[i]);\n            }\n            System.out.printf(\"\\n\");*/\n\n            for( int i = 1; i < D+1; i++ )\n            {\n                result[i][count] = number[i];\n            }\n            number[D]++;\n            if( number[D] == K+1 )\n            {\n                number[D] = 1;\n\n                int i;\n                for( i = D-1; i > 0; i-- )\n                {\n                    if( number[i] != K )\n                    {\n                        number[i]++;\n                        break;\n                    }\n                    else\n                    {\n                        number[i] = 1;\n                    }\n                }\n                if( i == 0 )\n                {\n                    break;\n                }\n            }\n            count++;\n        }\n\n        for( int i = 1; i < D+1; i++ )\n        {\n            for( int j = 1; j < N+1; j++ )\n            {\n                out.append(result[i][j]+\" \");\n            }\n            out.append(\"\\n\");\n        }\n\n        System.out.printf(\"%s\\n\", out.toString());\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "\npublic class C {\n\n\tpublic C () {\n\t\tint N = sc.nextInt(), K = sc.nextInt(), D = sc.nextInt();\n\n\t\tif (N == 1) {\n\t\t\tfor (@SuppressWarnings(\"unused\") int d : rep (D))\n\t\t\t\tprint(1);\n\t\t\treturn;\n\t\t}\n\n\t\tint [][] res = new int [D][N]; int [] C = new int [D];\n\t\tfor (int n : rep(N))\n\t\t\tif (n > 0 && !inc(C, 0, K))\n\t\t\t\texit(-1);\n\t\t\telse\n\t\t\t\tfor (int d : rep(D))\n\t\t\t\t\tres[d][n] = 1 + C[d];\n\n\t\tprintln(res);\n\t}\n\n\tboolean inc(int [] C, int i, int K) {\n\t\tif (i >= C.length) return false;\n\t\telse {\n\t\t\tC[i] = (C[i] + 1) % K;\n\t\t\treturn C[i] == 0 ? inc(C, i+1, K) : true;\n\t\t}\n\t}\n\n\tprivate static int [] rep(int N) { return rep(0, N); }\n\tprivate static int [] rep(int S, int T) { if (T <= S) return new int [0]; int [] res = new int [T-S]; for (int i = S; i < T; ++i) res[i-S] = i; return res; }\n\t////////////////////////////////////////////////////////////////////////////////////\n\tprivate final static IOUtils.MyScanner sc = new IOUtils.MyScanner();\n\tprivate static void print (Object o, Object ... A) { IOUtils.print(o, A); }\n\tprivate static void println (Object o) { IOUtils.println(o); }\n\tprivate static void exit (Object o, Object ... A) { IOUtils.print(o, A); IOUtils.exit(); }\n\tprivate static class IOUtils {\n\t\tpublic static class MyScanner {\n\t\t\tpublic String next() { newLine(); return line[index++]; }\n\t\t\tpublic int nextInt() { return Integer.parseInt(next()); }\n\t\t\t//////////////////////////////////////////////\n\t\t\tprivate boolean eol() { return index == line.length; }\n\t\t\tprivate String readLine() {\n\t\t\t\ttry {\n\t\t\t\t\treturn r.readLine();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tthrow new Error (e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprivate final java.io.BufferedReader r;\n\t\t\tprivate MyScanner () { this(new java.io.BufferedReader(new java.io.InputStreamReader(System.in))); }\n\t\t\tprivate MyScanner (java.io.BufferedReader r) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.r = r;\n\t\t\t\t\twhile (!r.ready())\n\t\t\t\t\t\tThread.sleep(1);\n\t\t\t\t\tstart();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tthrow new Error(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprivate String [] line;\n\t\t\tprivate int index;\n\t\t\tprivate void newLine() {\n\t\t\t\tif (line == null || eol()) {\n\t\t\t\t\tline = split(readLine());\n\t\t\t\t\tindex = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprivate String [] split(String s) { return s.length() > 0 ? s.split(\" \") : new String [0]; }\n\t\t}\n\t\tprivate static String build(Object o, Object ... A) { return buildDelim(\" \", o, A); }\n\t\tprivate static String buildDelim(String delim, Object o, Object ... A) {\n\t\t\tStringBuilder b = new StringBuilder();\n\t\t\tappend(b, o, delim);\n\t\t\tfor (Object p : A)\n\t\t\t\tappend(b, p, delim);\n\t\t\treturn b.substring(delim.length());\n\t\t}\n\t\t//////////////////////////////////////////////////////////////////////////////////\n\t\tprivate static void start() { if (t == 0) t = millis(); }\n\t\tprivate static void append(StringBuilder b, Object o, String delim) {\n\t\t\tif (o.getClass().isArray()) {\n\t\t\t\tint len = java.lang.reflect.Array.getLength(o);\n\t\t\t\tfor (int i = 0; i < len; ++i)\n\t\t\t\t\tappend(b, java.lang.reflect.Array.get(o, i), delim);\n\t\t\t} else if (o instanceof Iterable<?>)\n\t\t\t\tfor (Object p : (Iterable<?>) o)\n\t\t\t\t\tappend(b, p, delim);\n\t\t\telse {\n\t\t\t\tif (o instanceof Double)\n\t\t\t\t\to = new java.text.DecimalFormat(\"#.############\").format(o);\n\t\t\t\tb.append(delim).append(o);\n\t\t\t}\n\t\t}\n\t\tprivate static java.io.PrintWriter pw = new java.io.PrintWriter(System.out);\n\t\tprivate static void print(Object o, Object ... A) { pw.println(build(o, A)); }\n\t\tprivate static void println(Object o) {\n\t\t\tif (o.getClass().isArray()) {\n\t\t\t\tint len = java.lang.reflect.Array.getLength(o);\n\t\t\t\tfor (int i = 0; i < len; ++i)\n\t\t\t\t\tprint(java.lang.reflect.Array.get(o, i));\n\t\t\t} else if (o instanceof Iterable<?>)\n\t\t\t\tfor (Object p : (Iterable<?>) o)\n\t\t\t\t\tprint(p);\n\t\t\telse\n\t\t\t\tprint(o);\n\t\t}\n\t\tprivate static void err(Object o, Object ... A) { System.err.println(build(o, A)); }\n\t\tprivate static void exit() {\n\t\t\tIOUtils.pw.close();\n\t\t\tSystem.out.flush();\n\t\t\terr(\"------------------\");\n\t\t\terr(IOUtils.time());\n\t\t\tSystem.exit(0);\n\t\t}\n\t\tprivate static long t;\n\t\tprivate static long millis() { return System.currentTimeMillis(); }\n\t\tprivate static String time() { return \"Time: \" + (millis() - t) / 1000.0; }\n\t}\n\tpublic static void main (String[] args) { new C(); IOUtils.exit(); }\n}\n"
        },
        {
            "language": 1,
            "solution": "import math\n\nz = raw_input().split(\" \")\nnStu = int(z[0]) #n\nnBus = int(z[1]) #k\nnDay = int(z[2]) #d\n\n\"\"\"\n\t\tstu 1\t\tstu 2\t\tstu 3\nday 1\nday 2\n...\n\nnumber of possible student-strings: nBus^nDay\nif nBus ^ nDay < nStu then it's impossible to do\notherwise just print nStu vertical strings that are different\n\nnDay * log(nBus) < log(nStu)\n\"\"\"\ndef run():\n if (nBus == 1):\n  if (nStu == 1):\n   for x in range(0, nDay):\n    print 1\n  else:\n   print -1\n  return\n else:\n  output = [None] * nDay\n  for day in range(0, nDay):\n   output[day] = [None] * nStu\n  \n  uStr = [0] * nDay\n  for stu in range(0, nStu):\n   for day in range(0, nDay):\n    output[day][stu] = uStr[day]\n\n   #iterate uStr\n   placeValue = nDay - 1\n   while True:\n    uStr[placeValue] = (uStr[placeValue] + 1) % nBus\n    if uStr[placeValue] != 0:\n     break\n    placeValue -= 1\n    if placeValue < 0 and stu != nStu - 1:\n     print -1\n     return\n  for day in range(0, nDay):\n   out = \"\"\n   for stu in range(0, nStu):\n    out += str(output[day][stu] + 1)\n    if stu != nStu - 1:\n     out += \" \"\n   print out\n\nrun()\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Bat-Orgil\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskC solver = new TaskC();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskC {\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int n= in.nextInt();\n        int k =in.nextInt();\n        int d= in.nextInt();\n        long all=1;\n        for(int i=0; i<d; i++){\n            all*=(long)k;\n            if(all>= n){\n                break;\n            }\n        }\n        if(all<n){\n            out.println(-1);\n            return;\n        }\n\n        int[][] ans = new int[d][n];\n        for(int i=0; i<n; i++){\n            int val=i;\n            for(int j=0; j<d; j++){\n                ans[j][i]= val%k+1;\n                val/=k;\n            }\n        }\n        for(int i=0; i<d; i++){\n            for(int j=0; j<n; j++){\n                out.print(ans[i][j] + \" \");\n            }\n            out.println();\n        }\n\n\n    }\n}\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint st, bus, tr;\nint num[1100][1100];\nint main() {\n  cin >> st >> bus >> tr;\n  if (bus <= 1000) {\n    if (st > pow(bus, tr)) {\n      cout << -1 << endl;\n      return 0;\n    }\n  }\n  for (int j = 1; j < st; j++) {\n    num[j][0] = 1;\n    for (int i = 0; i < tr; i++) {\n      num[j][i] += num[j - 1][i];\n      num[j][i + 1] += num[j][i] / bus;\n      num[j][i] %= bus;\n    }\n  }\n  for (int i = 0; i < tr; i++) {\n    for (int j = 0; j < st; j++) {\n      cout << num[j][i] + 1 << \" \";\n    }\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline long long max(long long a, long long b) { return ((a > b) ? a : b); }\ninline long long min(long long a, long long b) { return ((a > b) ? b : a); }\ninline long long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  a %= b;\n  return gcd(b, a);\n}\nlong long power(long long x, long long y) {\n  if (y == 0) return 1;\n  long long a = power(x, y / 2);\n  if (y % 2 == 0)\n    return a * a;\n  else\n    return x * a * a;\n}\nlong long powermod(long long x, long long ex, long long md) {\n  long long ans = 1ll;\n  while (ex > 0) {\n    if (ex & 1ll) ans = (ans * x) % md;\n    ex >>= 1ll;\n    x = (x * x) % md;\n  }\n  return ans;\n}\nconst long long inf = 1e18 + 9;\nconst long long mod = 1e9 + 7;\nconst long double eps = 1e-9;\nconst long long N = 1e6 + 1;\nlong long n, k, d;\nvoid solve() {\n  bool flag = 0;\n  cin >> n >> k >> d;\n  long long arr[n + 1];\n  long long p = 1;\n  for (long long i = 1; i <= d; i++) {\n    p = p * k;\n    if (p >= n) {\n      flag = 1;\n      break;\n    }\n  }\n  if (!flag)\n    cout << \"-1\\n\";\n  else {\n    for (int(i) = 0; i < (n); i++) arr[i + 1] = i + 1;\n    for (long long i = 1; i <= d; i++) {\n      for (long long j = 1; j <= n; j++) {\n        cout << arr[j] % k + 1 << \" \";\n        arr[j] /= k;\n      }\n      cout << \"\\n\";\n    }\n  }\n}\nint main() {\n  {\n    ios ::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n  };\n  cout << fixed << setprecision(20);\n  long long NTC = 1;\n  long long PTC = 0;\n  while (PTC++ < NTC) {\n    solve();\n  }\n  cerr << \"Time : \" << 1000 * ((double)clock()) / (double)CLOCKS_PER_SEC\n       << \"ms\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid init() {}\nint main() {\n  init();\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long n, k, d;\n  cin >> n >> k >> d;\n  if (pow(k, d) < n) {\n    cout << -1;\n    return 0;\n  }\n  long long ans[n][d];\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < d; j++) {\n      ans[i][j] = 1;\n    }\n  }\n  for (int i = 1; i < n; i++) {\n    int j = d - 1;\n    for (int x = 0; x < d; x++) {\n      ans[i][x] = ans[i - 1][x];\n    }\n    while (j >= 0 && ans[i][j] == k) {\n      ans[i][j] = 1;\n      j--;\n    }\n    ans[i][j]++;\n  }\n  for (int i = 0; i < d; i++) {\n    for (int j = 0; j < n; j++) {\n      cout << ans[j][i] << \" \";\n    }\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[1001][1001];\nint main() {\n  int n, k, d;\n  cin >> n >> k >> d;\n  int tmp = 1;\n  bool flag = false;\n  for (int i = 1; i <= d; i++) {\n    tmp *= k;\n    if (tmp >= n) {\n      flag = true;\n      break;\n    }\n  }\n  if (!flag) {\n    cout << -1 << endl;\n    return 0;\n  }\n  for (int i = 1; i < n; i++) {\n    for (int j = 0; j < d; j++) a[i][j] = a[i - 1][j];\n    for (int j = d - 1; j >= 0; j--) {\n      a[i][j] = (a[i][j] + 1) % k;\n      if (a[i][j]) break;\n    }\n  }\n  for (int i = 0; i < d; i++) {\n    cout << a[0][i] + 1;\n    for (int j = 1; j < n; j++) cout << ' ' << a[j][i] + 1;\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\n\npublic class C implements Runnable {\n\t\n\tvoid solve() {\n\t\tint n = nextInt(), k = nextInt(), d = nextInt();\n\t\tif (n == 1) {\n\t\t\tfor (int i = 0; i < d; i++)\n\t\t\t\tprintln(1);\n\t\t\treturn;\n\t\t}\n\t\tif (k == 1) {\n\t\t\tprint(-1);\n\t\t\treturn;\n\t\t}\n\t\tint cur = n, cnt = 0;\n\t\twhile (cur > 1) {\n\t\t\tcnt++;\n\t\t\tcur = (cur + k - 1) / k;\n\t\t}\n\t\tif (cnt > d) {\n\t\t\tprint(-1);\n\t\t\treturn;\n\t\t}\n\t\tint[][] list = new int[n + 1][n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tlist[0][i] = i;\n\t\tint first = 0, last = 1, current = 1;\n\t\tint[] len = new int[n + 1];\n\t\tlen[0] = n;\n\t\tfor (int i = 0; i < d; i++) {\n\t\t\tint[] ans = new int[n];\n\t\t\tfor (int j = first; j != last; j = (j == n) ? 0 : (j + 1)) {\n\t\t\t\tint max = Math.min(len[j], k);\n\t\t\t\tfor (int l = current, g = 0; g < max; l = (l == n) ? 0 : (l + 1), g++)\n\t\t\t\t\tlen[l] = 0;\n\t\t\t\tfor (int l = 0, g = 0; g < len[j]; l = (l == k - 1) ? 0 : (l + 1), g++) {\n\t\t\t\t\tans[list[j][g]] = l;\n\t\t\t\t\tint num = (current + l) % (n + 1);\n\t\t\t\t\tlist[num][len[num]++] = list[j][g];\n\t\t\t\t}\n\t\t\t\tcurrent = (current + max) % (n + 1);\n//\t\t\t\tSystem.out.println(current);\n//\t\t\t\tfor (int x = 0; x < n + 1; x++) {\n//\t\t\t\t\tfor (int y = 0; y < n; y++) {\n//\t\t\t\t\t\tif (y != 0) System.out.print(' ');\n//\t\t\t\t\t\tSystem.out.print(list[x][y]);\n//\t\t\t\t\t}\n//\t\t\t\t\tSystem.out.println();\n//\t\t\t\t}\n\t\t\t}\n\t\t\tfirst = last;\n\t\t\tlast = current;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (j != 0) print(' ');\n\t\t\t\tprint(ans[j] + 1);\n\t\t\t}\n\t\t\tprintln();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew C().run();\n\t}\n\t\n\tC() {\n\t\tthis.stream = System.in;\n\t\tthis.writer = new PrintWriter(System.out);\n\t}\n\t\n\tC(String input, String output) throws IOException {\n\t\tFile inputFile = new File(input);\n\t\tinputFile.createNewFile();\n\t\tstream = new FileInputStream(inputFile);\n\t\tFile outputFile = new File(output);\n\t\toutputFile.createNewFile();\n\t\twriter = new PrintWriter(outputFile);\n\t}\n\t\n\tpublic void run() {\n\t\tsolve();\n\t\twriter.close();\n\t}\n\t\n\tvoid halt() {\n\t\twriter.close();\n\t\tSystem.exit(0);\n\t}\n\t\n\tPrintWriter writer;;\n\t\n\tvoid print(Object... objects) {\n\t\tfor (int i = 0; i < objects.length; i++) {\n\t\t\tif (i != 0)\n\t\t\t\twriter.print(' ');\n\t\t\twriter.print(objects[i]);\n\t\t}\n\t}\n\t\n\tvoid println(Object... objects) {\n\t\tprint(objects);\n\t\twriter.println();\n\t}\n\t\n\tvoid printArray(int[] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tif (i != 0) writer.print(' ');\n\t\t\twriter.print(array[i]);\n\t\t}\n\t\twriter.println();\n\t}\n\t\n\tvoid printArray(long[] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tif (i != 0) writer.print(' ');\n\t\t\twriter.print(array[i]);\n\t\t}\n\t\twriter.println();\n\t}\n\t\n\tvoid printMatrix(int[][] matrix) {\n\t\tfor (int i = 0; i < matrix.length; i++)\n\t\t\tprintArray(matrix[i]);\n\t}\n\t\n\tvoid printMatrix(long[][] matrix) {\n\t\tfor (int i = 0; i < matrix.length; i++)\n\t\t\tprintArray(matrix[i]);\n\t}\n\t\n\t/**\n\t * Pure Egor's code is straight ahead.\n\t */\n\t\n\tInputStream stream;\n\tbyte[] buf = new byte[1024];\n\tint curChar, numChars;\n\t\n\tint nextInt() {\n\t\tint c = next();\n\t\twhile (isWhitespace(c))\n\t\t\tc = next();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = next();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = next();\n\t\t} while (!isWhitespace(c));\n\t\treturn res * sgn;\n\t}\n\t\n\tlong nextLong() {\n\t\tint c = next();\n\t\twhile (isWhitespace(c))\n\t\t\tc = next();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = next();\n\t\t}\n\t\tlong res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = next();\n\t\t} while (!isWhitespace(c));\n\t\treturn res * sgn;\n\t}\n\t\n\tdouble nextDouble() {\n\t\tint c = next();\n\t\twhile (isWhitespace(c))\n\t\t\tc = next();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = next();\n\t\t}\n\t\tdouble res = 0;\n\t\twhile (!isWhitespace(c) && c != '.') {\n\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = next();\n\t\t}\n\t\tif (c == '.') {\n\t\t\tc = next();\n\t\t\tdouble m = 1;\n\t\t\twhile (!isWhitespace(c)) {\n\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tm /= 10;\n\t\t\t\tres += (c - '0') * m;\n\t\t\t\tc = next();\n\t\t\t}\n\t\t}\n\t\treturn res * sgn;\n\t}\n\t\n\tBigInteger nextBigInteger() {\n\t\ttry {\n\t\t\treturn new BigInteger(nextString());\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t}\n\t\n\tint next() {\n\t\tif (numChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= numChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (numChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n\t\n\tString nextString() {\n\t\tint c = next();\n\t\twhile (isWhitespace(c))\n\t\t\tc = next();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tif (Character.isValidCodePoint(c))\n\t\t\t\tres.appendCodePoint(c);\n\t\t\tc = next();\n\t\t} while (!isWhitespace(c));\n\t\treturn res.toString();\n\t}\n\t\n\tString nextLine() {\n\t\tStringBuilder buf = new StringBuilder();\n\t\tint c = next();\n\t\twhile (c != '\\n' && c != -1) {\n\t\t\tif (c != '\\r')\n\t\t\t\tbuf.appendCodePoint(c);\n\t\t\tc = next();\n\t\t}\n\t\treturn buf.toString();\n\t}\n\t\n\tboolean EOF() {\n\t\tint value;\n\t\twhile (isWhitespace(value = peek()) && value != -1)\n\t\t\tnext();\n\t\treturn value == -1;\n\t}\n\t\n\tint peek() {\n\t\tif (numChars == -1)\n\t\t\treturn -1;\n\t\tif (curChar >= numChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (numChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar];\n\t}\n\t\n\tboolean isWhitespace(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n}"
        },
        {
            "language": 1,
            "solution": "n,k,d=map(int,raw_input().split())\nif k**d<n:\n    print -1\nelse:\n    ans=[]\n    for i in range(n):\n        cur=[]\n        evaluate=i\n        for j in range(d):\n            cur.append(evaluate%k+1)\n            evaluate/=k\n        ans.append(cur)\n    for i in range(d):\n        for j in ans:\n            print j[i],\n        print '\\n'"
        },
        {
            "language": 1,
            "solution": "\n# Author : raj1307 - Raj Singh\n# Date   : 10.02.2020\n\nfrom __future__ import division, print_function\n\nimport os,sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef ii(): return int(input())\ndef si(): return input()\ndef mi(): return map(int,input().strip().split(\" \"))\ndef msi(): return map(str,input().strip().split(\" \"))\ndef li(): return list(mi())\n\ndef dmain():\n    sys.setrecursionlimit(100000000)\n    threading.stack_size(40960000)\n    thread = threading.Thread(target=main)\n    thread.start()\n    \n#from collections import deque, Counter, OrderedDict,defaultdict\n#from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\nfrom math import ceil,floor,log,sqrt,factorial\n#from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n#from decimal import *,threading\nfrom itertools import permutations\n#Copy 2D list  m = [x[:] for x in mark] .. Avoid Using Deepcopy\n\nabc='abcdefghijklmnopqrstuvwxyz'\nabd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod=1000000007\n#mod=998244353\ninf = float(\"inf\")\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\ndef getKey(item): return item[1] \ndef sort2(l):return sorted(l, key=getKey,reverse=True)\ndef d2(n,m,num):return [[num for x in range(m)] for y in range(n)]\ndef isPowerOfTwo (x): return (x and (not(x & (x - 1))) )\ndef decimalToBinary(n): return bin(n).replace(\"0b\",\"\")\ndef ntl(n):return [int(i) for i in str(n)]\n\ndef powerMod(x,y,p):\n    res = 1\n    x %= p\n    while y > 0:\n        if y&1:\n            res = (res*x)%p\n        y = y>>1\n        x = (x*x)%p\n    return res\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n    \ndef isPrime(n) : # Check Prime Number or not \n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n    return True\n\n\n\ndef read():\n    sys.stdin = open('input.txt', 'r')  \n    sys.stdout = open('output.txt', 'w') \n\n\n\n\n\ndef main():\n        \n\n \n    #for _ in range(ii()):\n    \n\n\n    n,k,d=mi()\n    \n    f=0\n    p=1\n    for i in range(d):\n        p*=k\n        if p>=n:\n            f=1\n            break\n\n    if f==0:\n        print(-1)\n        exit()\n\n\n    ans=d2(n,d,0)\n\n    for i in range(1,n):\n\n        for j in range(d):\n            ans[i][j]=ans[i-1][j]\n\n        for j in range(d-1,-1,-1):\n            ans[i][j]=(ans[i][j]+1)%k\n\n            if ans[i][j]: break\n\n\n    for i in range(d):\n        for j in range(n):\n            print(ans[j][i]+1,end=' ')\n        print()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\n\nif __name__ == \"__main__\":\n    #read()\n    main()\n    #dmain()\n\n# Comment Read()\n"
        },
        {
            "language": 1,
            "solution": "n,k,d=map(int,raw_input().split())\nif k**d<n:\n    print -1\nelse:\n    ans=[]\n    for i in range(n):\n        cur=[]\n        evaluate=i\n        for j in range(d):\n            cur+=[evaluate%k+1]\n            evaluate/=k\n        ans+=[cur]\n    ans=zip(*ans)\n    print '\\n'.join(' '.join(map(str,ans[i])) for i in range(d))\n"
        },
        {
            "language": 1,
            "solution": "from sys import stdin, stdout\nfrom collections import Counter, defaultdict\nfrom itertools import permutations, combinations\nraw_input = stdin.readline\npr = stdout.write\n\n\ndef in_arr():\n    return map(int,raw_input().split())\n\n\ndef pr_num(n):\n    stdout.write(str(n)+'\\n')\n\n\ndef pr_arr(arr):\n    for i in arr:\n        stdout.write(str(i+1)+' ')\n    stdout.write('\\n')\n\n\nrange = xrange # not for python 3.0+\n\n# main code\n\nn,k,d=in_arr()\nif n>k**d:\n    pr_num(-1)\nelse:\n    arr=[]\n    ans=[0]*d\n    for i in range(n):\n        arr.append(list(ans))\n        #pr_arr(ans)\n        q=[d-1]\n        while i!=n-1 and q:\n            x=q.pop()\n            ans[x]+=1\n            if ans[x]>=k:\n                ans[x]%=k\n                q.append(x-1)\n    \n    for i in range(d):\n        for j in range(n):\n            pr(str(arr[j][i]+1)+' ')\n        pr('\\n')\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint ans[1009][1009];\nint main() {\n  long long n, k, d;\n  cin >> n >> k >> d;\n  for (int i = 0; i < n; i++) {\n    int cur = i;\n    for (int j = 0; j < d; j++) {\n      ans[j][i] = cur % k + 1;\n      cur /= k;\n    }\n    if (cur) {\n      printf(\"-1\");\n      return 0;\n    }\n  }\n  for (int i = 0; i < d; i++)\n    for (int j = 0; j < n; j++)\n      printf(\"%d%c\", ans[i][j], j == n - 1 ? '\\n' : ' ');\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1009;\nlong long ans[MAXN][MAXN];\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  long long n, d, k;\n  scanf(\"%lld%lld%lld\", &n, &k, &d);\n  int ok = 0;\n  long long b = k;\n  for (int i = 0; i < d; ++i) {\n    if (b >= n) {\n      ok = 1;\n      break;\n    }\n    b *= k;\n  }\n  if (!ok) {\n    printf(\"-1\\n\");\n    return 0;\n  }\n  for (int i = 1; i < n; ++i) {\n    for (int j = 0; j < d; ++j) ans[i][j] = ans[i - 1][j];\n    for (int j = d - 1; j >= 0; j--) {\n      ans[i][j] = (ans[i][j] + 1) % k;\n      if (ans[i][j]) break;\n    }\n  }\n  for (int i = 0; i < d; ++i) {\n    for (int j = 0; j < n; ++j) {\n      if (j) printf(\" \");\n      printf(\"%lld\", ans[j][i] + 1);\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int limN = 1005;\nint ans[limN][limN];\nint main() {\n  int n, d, k;\n  scanf(\"%d%d%d\", &n, &k, &d);\n  if (n == 1) {\n    for (int i = 0; i < d; i++) printf(\"1\\n\");\n    return 0;\n  }\n  if (k >= n) {\n    for (int i = 0; i < d; i++) {\n      for (int j = 1; j <= n; j++) printf(\"%d \", j);\n      printf(\"\\n\");\n    }\n    return 0;\n  }\n  if (d == 1 || k == 1) {\n    printf(\"-1\\n\");\n    return 0;\n  }\n  int num[limN];\n  for (int i = 0; i < d; i++) num[i] = 0;\n  for (int w = 0; w < n; w++) {\n    for (int i = 0; i < d; i++) {\n      ans[i][w] = num[i] + 1;\n    }\n    int xtra = 1;\n    for (int i = 0; i < d && xtra; i++) {\n      num[i] += xtra;\n      xtra = num[i] / k;\n      num[i] %= k;\n    }\n    if (xtra && w + 1 < n) {\n      printf(\"-1\\n\");\n      return 0;\n    }\n  }\n  for (int i = 0; i < d; i++) {\n    for (int j = 0; j < n; j++) printf(\"%d \", ans[i][j]);\n    printf(\"\\n\");\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.lang.*;\n\npublic class Main {\n    static BigInteger five = BigInteger.valueOf(5);\n    static BigInteger two  = BigInteger.valueOf(2);\n    static BigInteger one  = BigInteger.ONE;\n    static BigInteger zero = BigInteger.ZERO;\n    \n    public static OutputStream outputStream = System.out;\n    public static PrintWriter out = new PrintWriter(outputStream);\n\n    public static void main(String[] args) {\n        new Main().run();\n        out.close();\n    }\n    \n    Scanner in = new Scanner(System.in);\n    int n, k, d;\n    \n    void run(){\n        n = in.nextInt();\n        k = in.nextInt();\n        d = in.nextInt();\n        if(BigInteger.valueOf(k).pow(d).compareTo(BigInteger.valueOf(n))<0){\n            System.out.println(-1);\n        }else{\n            int[][] ans = new int[d][n];\n            for(int i=1; i<n; i++){\n                int carry = 1;\n                for(int j=d-1; j>=0; j--){\n                    int sum = ans[j][i-1] + carry;\n                    if(sum==k){\n                        carry = 1;\n                        ans[j][i] = 0;\n                    }else{\n                        carry = 0;\n                        ans[j][i] = sum;\n                    }\n                }\n            }\n            for(int i=0; i<d; i++){\n                for(int j=0; j<n; j++){\n                    out.print((ans[i][j]+1) + \" \");\n                }\n                out.println();\n            }\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie();\n  long long n, k, d;\n  cin >> n >> k >> d;\n  vector<vector<long long> > arr(n, vector<long long>(d));\n  long long lst = 0;\n  long long cur = 1;\n  for (long long i = 0; i < d; i++) arr[0][i] = 1;\n  for (long long i = 1; i < n; i++) {\n    arr[i] = arr[i - 1];\n    arr[i][d - 1]++;\n    for (long long j = d - 1; j > 0; j--)\n      if (arr[i][j] > k) {\n        arr[i][j] %= k;\n        arr[i][j - 1]++;\n      }\n    if (arr[i][0] > k) {\n      cout << -1 << endl;\n      return 0;\n    }\n  }\n  for (long long i = 0; i < d; i++) {\n    for (long long j = 0; j < n; j++) cout << arr[j][i] << \" \";\n    cout << endl;\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class C\n{\t\n\tpublic static void main(String[] args) throws Exception \n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint n = sc.nextInt() , k = sc.nextInt() , d = sc.nextInt();\n\t\t\n\t\tif(Math.log(n) > d*1.0 *Math.log(k) + 1e-9)\n\t\t{\n\t\t\tSystem.out.println(-1);\n\t\t\treturn ; \n\t\t}\n\t\t\n\t\tint [][] ans = new int [n][d] ; \n\t\t\n\t\tfor(int i = 0 ; i < n ; i++)\n\t\t\tans[i] = getStudent(i, d , k);\n\t\t\t\n\t\t\t\n\t\tfor(int j = 0 ; j < d ;j++)\n\t\t{\n\t\t\tfor(int i = 0 ; i < n ; i++)\t\n\t\t\t\tout.print(ans[i][j]+\" \");\n\t\t\tout.println();\n\t\t}\n\t\t\n\t\t\n\t\tout.flush();\n\t\tout.close();\n\t\n\t}\n\t\n\tstatic int[] getStudent(int curr , int d , int k)\n\t{\n\t\tint [] a = new int [d] ; \n\t\t\n\t\tint idx = 0 ; \n\t\twhile(curr > 0)\n\t\t{\n\t\t\ta[idx++] = curr % k ; \n\t\t\tcurr /= k ; \n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i <  d ; i++) a[i] ++ ; \n\t\t\n\t\treturn a ; \n\t}\n\t\n\t\n\tstatic class Scanner\n\t{\n\t  \tBufferedReader br = new BufferedReader(new InputStreamReader(System.in)); \n\t   \tStringTokenizer st ;\n\t   \tScanner(){}\n\t\tScanner(InputStream in) throws Exception{br = new BufferedReader(new InputStreamReader(in));}\n\t\tScanner(String path) throws Exception{br = new BufferedReader(new FileReader(path));}\n\t   \tString next() throws Exception {while(st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine()) ; return st.nextToken();}\n\t   \tint nextInt() throws Exception { return Integer.parseInt(next()) ; }\n\t   \tlong nextLong () throws Exception {return Long.parseLong(next());}\n\t   \tdouble nextDouble () throws Exception{return Double.parseDouble(next());}\n\t}\n\t\n\tstatic void shuffle(int [] a) \n\t{\n\t\tint n = a.length;\n\t\tfor (int i = 0; i < n; i++) \n\t\t{\n\t\t\tint r = i + (int) (Math.random() * (n - i));\n\t\t\tint tmp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = tmp;\n\t\t}\n\t}\n\tstatic void shuffle(char[] a) \n\t{\n\t\tint n = a.length;\n\t\tfor (int i = 0; i < n; i++) \n\t\t{\n\t\t\tint r = i + (int) (Math.random() * (n - i));\n\t\t\tchar tmp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = tmp;\n\t\t}\n\t}\n\tstatic void shuffle(long[] a) \n\t{\n\t\tint n = a.length;\n\t\tfor (int i = 0; i < n; i++) \n\t\t{\n\t\t\tint r = i + (int) (Math.random() * (n - i));\n\t\t\tlong tmp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = tmp;\n\t\t}\n\t}\n\t\n\t\n\tprivate static boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate static void tr(Object... o) {if (!oj)System.out.println(Arrays.deepToString(o));\n\t\n\t}\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int> > V;\nint n, k, d, pos = 1, c = 0;\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &d);\n  long long tmp1 = 1;\n  int c = 0;\n  for (int i = 0; i < d; i++) {\n    tmp1 *= (long long)k;\n    if (tmp1 >= n) {\n      c = 1;\n      break;\n    }\n  }\n  if (!c) {\n    printf(\"-1\\n\");\n    return 0;\n  }\n  long long dvv = 1;\n  for (int i = 1; i <= d; i++) {\n    long long ne = 1;\n    long long rem = n;\n    while (rem) {\n      for (int j = 1; j <= min(rem, dvv); j++) cout << ne << \" \";\n      rem -= min(rem, dvv);\n      if (++ne == k + 1) ne = 1;\n    }\n    (dvv * k < n) ? dvv *= k : dvv = n;\n    printf(\"\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e3 + 10;\nconst int MOD = 1e9 + 7;\nconst int INF = 0x3f3f3f3f;\nbool check(long long a, long long b, long long n) {\n  long long ret = 1;\n  while (b) {\n    if (b & 1) ret = ret * a;\n    a = a * a;\n    b >>= 1;\n    if (ret >= n) return true;\n  }\n  return false;\n}\nint ans[maxn][maxn];\nint main() {\n  int n, k, d;\n  scanf(\"%d%d%d\", &n, &k, &d);\n  if (check(min(k, n), d, n)) {\n    for (int i = 1; i <= d; i++) ans[i][1] = 1;\n    for (int i = 2; i <= n; i++) {\n      int c = 0;\n      ans[1][i] = ans[1][i - 1] + 1;\n      if (ans[1][i] > k) {\n        ans[1][i] = 1;\n        c = 1;\n      }\n      for (int j = 2; j <= d; j++) {\n        ans[j][i] = ans[j][i - 1] + c;\n        c = 0;\n        if (ans[j][i] > k) {\n          ans[j][i] = 1;\n          c = 1;\n        }\n      }\n    }\n    for (int i = 1; i <= d; i++) {\n      for (int j = 1; j <= n; j++) {\n        if (j != 1) printf(\" \");\n        printf(\"%d\", ans[i][j]);\n      }\n      printf(\"\\n\");\n    }\n  } else\n    printf(\"-1\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "//package codeforces;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class C {\n    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n    PrintWriter writer = new PrintWriter(System.out);\n    StringTokenizer stringTokenizer;\n\n    String next() throws IOException {\n        while (stringTokenizer == null || !stringTokenizer.hasMoreTokens()) {\n            stringTokenizer = new StringTokenizer(reader.readLine());\n        }\n        return stringTokenizer.nextToken();\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    void solve() throws IOException {\n        int n = nextInt();\n        int k = nextInt();\n        int d = nextInt();\n        if(n == 1) {\n            for(int i = 0; i < d; i++) {\n                writer.println(1);\n            }\n        } else {\n            long df = 1;\n            int[][] seats = new int[d][n];\n            for(int day = 0; day < d; day++) {\n                for(int i = 0; i < Math.min(df, n); i++) {\n                    for(long j = i; j < n; j += df) {\n                        int bus = (int)(j / df % k + 1);\n                        seats[day][(int)j] = bus;\n                    }\n                }\n                if(df <= n) {\n                    df *= k;\n                }\n            }\n            if(df >= n) {\n                for(int i = 0; i < seats.length; i++) {\n                    for(int j = 0; j < seats[i].length; j++) {\n                        writer.print(seats[i][j] + \" \");\n                    }\n                    writer.println();\n                }\n            } else {\n                writer.println(-1);\n            }\n        }\n        writer.close();\n    }\n\n    public static void main(String[] args) throws IOException {\n        new C().solve();\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dig[1005][1005];\nint main() {\n  int n, d, k;\n  cin >> n >> k >> d;\n  if (k == 1) {\n    if (n == 1) {\n      for (int i = 0; i < d; i++) {\n        cout << 1 << endl;\n      }\n    } else\n      cout << -1 << endl;\n    return 0;\n  }\n  int r = ceil(log(n) / log(k));\n  if (r > d)\n    cout << -1 << endl;\n  else {\n    for (int i = 0; i < n; i++) {\n      int j = 0;\n      int num = i;\n      while (num > 0) {\n        dig[i][j] = num % k;\n        num /= k;\n        j++;\n      }\n    }\n    for (int i = 0; i < d; i++) {\n      for (int j = 0; j < n; j++) {\n        cout << dig[j][i] + 1 << \" \";\n      }\n      cout << endl;\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, k, d;\n  cin >> n >> k >> d;\n  long long r = 1;\n  for (int i = 1; i <= d; i++) {\n    r = r * k;\n    if (n <= r) break;\n  }\n  if (n > r) {\n    cout << -1;\n    return 0;\n  }\n  int a[n];\n  for (int i = 0; i < n; i++) {\n    a[i] = i;\n  }\n  for (int i = 0; i < d; i++) {\n    for (int j = 0; j < n; j++) {\n      cout << (a[j] % k) + 1 << \" \";\n      a[j] = a[j] / k;\n    }\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.PrintWriter;\nimport java.util.*;\n\npublic class CF261C {\n\tpublic static void main(String [] args) {\n\t\tScanner input = new Scanner(System.in);\n\t\t\n\t\tint n = input.nextInt();\n\t\tint k = input.nextInt();\n\t\tint d = input.nextInt();\n\t\t\n\t\tinput.close();\n\t\t\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint [][] a = new int[d][n];\n\t\t\n\t\tfor (int i = 0; i < d; i++) a[i][0] = 1;\n\t\t\n\t\tboolean feasible = true;\n\t\t\n\t\tfor (int j = 1; j < n; j++) {\n\t\t\t\n\t\t\tboolean carry = true;\n\t\t\t\n\t\t\tfor (int i = 0; i < d; i++) {\n\t\t\t\tif (carry) { \n\t\t\t\t\tif (a[i][j-1] == k) {\n\t\t\t\t\t\tif (i == d-1) {\n\t\t\t\t\t\t\tfeasible = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ta[i][j] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\t\t\t\t\t\n\t\t\t\t\t\ta[i][j] = a[i][j-1] + 1;\n\t\t\t\t\t\tcarry = false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ta[i][j] = a[i][j-1];\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!feasible) {\n\t\t\t\tout.println(-1);\n\t\t\t\tout.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n//\t\tfinal long startTime = System.currentTimeMillis();\n\t\t\n\t\tfor (int i = 0; i < d; i++) {\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tout.print(a[i][j] + \" \");\n\t\t\tout.println();\n\t\t}\n\t\t\n//\t\tfinal long endTime = System.currentTimeMillis();\n\n//\t\tout.println(\"Total execution time: \" + (endTime - startTime) );\n\t\t\n\t\tout.close();\n\t\t\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskC solver = new TaskC();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskC {\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int student = in.nextInt();\n        int bus = in.nextInt();\n        int day = in.nextInt();\n        long tmp = 1;\n        for (int i = 0; i < day; ++i)\n            tmp = Math.min(tmp * bus, (long) 1e9);\n        if (tmp >= student) {\n            int div = 1;\n            for (int i = 0; i < day; ++i) {\n                for (int j = 0; j < student; ++j) {\n                    if (j > 0) out.print(\" \");\n                    out.print(j / div % bus + 1);\n                }\n                out.println();\n                div = (int) Math.min(1L * div * bus, (long) 1e9);\n            }\n        } else {\n            out.println(-1);\n        }\n    }\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens())\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n}\n\n"
        },
        {
            "language": 1,
            "solution": "n,k,d=map(int,raw_input().split())\nif (k**d<n):\n\tprint -1\n\texit()\nrk=[1]*d\nstu=[rk[:]]\nfor i in xrange(n-1):\n\tj=d-1\n\twhile rk[j]==k:\n\t\trk[j]=1\n\t\tj-=1\n\trk[j]+=1\n\tstu.append(rk[:])\nfor i in xrange(d):\n\tfor j in xrange(n):\n\t\tprint stu[j][i],\n\tprint\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\npublic class A {\n\tpublic static void main (String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tbuses = in.nextInt();\n\t\tdays = in.nextInt();\n\t\tbuses = Math.min(n, buses);\n\t\tint[][] a = new int[days][n];\n\t\tboolean ok = fill(0, 0, n - 1, a);\n\t\tif (!ok) {\n\t\t\tSystem.out.println(-1);\n\t\t} else {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor (int i = 0; i < days; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tsb.append(a[i][j] + \" \");\n\t\t\t\tsb.append(\"\\n\");\n\t\t\t}\n\t\t\tSystem.out.println(sb);\n\t\t}\n\t}\n\n\tstatic int days;\n\tstatic int buses;\n\n\tpublic static boolean fill (int d, int f, int t, int[][] a) {\n\t\tif (d == days) return t - f + 1 == 1;\n\t\tint sec = 1;\n\t\tif (buses < t - f + 1) sec = (t - f + 1) / buses;\n\t\tint curbus = 1;\n\t\tboolean res = true;\n\t\tint cnt = 0;\n\t\tfor (int i = f; i <= t; i++) {\n\t\t\tcnt++;\n\t\t\ta[d][i] = curbus;\n\t\t\tif (cnt == sec && curbus < buses) {\n\t\t\t\tres &= fill(d + 1, i - cnt + 1, i, a);\n\t\t\t\tcnt = 0;\n\t\t\t\tif (!res) return false;\n\t\t\t\tcurbus++;\n\t\t\t}\n\t\t}\n\t\tif (cnt != 0) res &= fill(d + 1, t - cnt + 1, t, a);\n\t\treturn res;\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint ans[2000][2000];\nint main() {\n  long long n, k, d, f = 0;\n  cin >> n >> k >> d;\n  long long x = 1;\n  for (int i = 1; i <= d; i++) {\n    x *= k;\n    if (x >= n) {\n      f = 1;\n      break;\n    }\n  }\n  if (!f) {\n    cout << -1 << endl;\n    return 0;\n  }\n  for (int i = 0; i < n; i++) {\n    int l = i, j = 0;\n    while (l > 0) {\n      ans[j++][i] = l % k;\n      l /= k;\n    }\n  }\n  for (int i = 0; i < d; i++) {\n    for (int j = 0; j < n; j++) cout << ans[i][j] + 1 << \" \";\n    cout << endl;\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\nimport java.util.StringTokenizer;\n\n\npublic class Codeforces459C\n{\n\tpublic static boolean isBiggerThan(int n, int k, int d)\n\t{\n\t\tBigInteger bigN = new BigInteger(n+\"\");\n\t\tBigInteger bigK = new BigInteger(k+\"\");\n\t\tBigInteger a = new BigInteger(k+\"\");\n\t\tif(bigN.compareTo(bigK) <= 0)\n\t\t\treturn false;\n\t\telse\n\t\t{\n\t\t\tfor(int i = 1; i < d; i++)\n\t\t\t{\n\t\t\t\ta = a.multiply(bigK);\n\t\t\t\tif(bigN.compareTo(a) <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tpublic static void main(String[] args)\n\t{\n\t\ttry\n\t\t{\n\t\t\tBufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tStringTokenizer st = new StringTokenizer(f.readLine());\n\t\t\tint n = Integer.parseInt(st.nextToken());\n\t\t\tint k = Integer.parseInt(st.nextToken());\n\t\t\tint d = Integer.parseInt(st.nextToken());\n\t\t\tif(isBiggerThan(n, k, d))\n\t\t\t{\n\t\t\t\tSystem.out.println(-1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint[][] students = new int[n][d];\n\t\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t\t{\n\t\t\t\t\tint num = i;\n\t\t\t\t\tfor(int j = 0; j < d; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tstudents[i][j] = num%k + 1;\n\t\t\t\t\t\tnum/=k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i = 0; i < d; i++)\n\t\t\t\t{\n\t\t\t\t\tStringBuffer s = new StringBuffer(students[0][i]+\"\");\n\t\t\t\t\tfor(int j = 1; j < n; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\ts.append(\" \" + students[j][i]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch(IOException e)\n\t\t{\n\t\t\tSystem.out.println(e);\n\t\t}\t\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\n\n\npublic class Main implements Runnable {\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars==-1)\n                throw new InputMismatchException();\n\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n\n                if(numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n\n            while(isSpaceChar(c))\n                c = read();\n\n            int sgn = 1;\n\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n\n            int res = 0;\n            do {\n                if(c<'0'||c>'9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new Main(),\"Main\",1<<26).start();\n    }\n\n    static long gcd(long a,long b){ if(b==0)return a;return gcd(b,a%b); }\n    static long modPow(long a,long p,long m){ if(a==1)return 1;long ans=1;while (p>0){ if(p%2==1)ans=(ans*a)%m;a=(a*a)%m;p>>=1; }return ans; }\n    static long modInv(long a,long m){return modPow(a,m-2,m);}\n\n\n\n    public void run() {\n        InputReader sc = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n=sc.nextInt();\n        int k=sc.nextInt();\n        int d=sc.nextInt();\n\n        long temp=1;\n        int ff=0;\n        for (int i = 0; i <d ; i++) {\n            temp*=k;\n            if(temp>=n){\n                ff=1;\n                break;\n            }\n        }\n\n        if(ff==1){\n            int a[]=new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i]=i;\n            }\n            for (int i = 0; i <d ; i++) {\n                for (int j = 0; j <n ; j++) {\n                    out.print(((a[j]%k)+1)+\" \");\n                    a[j]/=k;\n                }\n                out.println();\n            }\n        }\n        else{\n            out.println(-1);\n        }\n\n\n        out.close();\n    }\n\n\n}"
        },
        {
            "language": 1,
            "solution": "read = lambda: map(int, raw_input().split())\n\nn, k, d = read()\n\nif (k == 1 and n > 1) or (d <= 10 and k ** d < n):\n\tprint -1\nelse:\n\tans = []\n\tfor i in xrange(n):\n\t\tcur = []\n\t\tnum = i\n\t\tfor j in xrange(d):\n\t\t\tcur.append(1 + num % k)\n\t\t\tnum /= k\n\t\tans.append(cur)\n\tfor i in xrange(d):\n\t\tfor j in xrange(n):\n\t\t\tprint ans[j][d - 1 - i],\n\t\tprint ''"
        },
        {
            "language": 4,
            "solution": "// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF459C extends PrintWriter {\n\tCF459C() { super(System.out); }\n\tScanner sc = new Scanner(System.in);\n\tpublic static void main(String[] $) {\n\t\tCF459C o = new CF459C(); o.main(); o.flush();\n\t}\n\n\tvoid main() {\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tint d = sc.nextInt();\n\t\tif (k < n) {\n\t\t\tint p = 1;\n\t\t\tfor (int h = 0; h < d; h++) {\n\t\t\t\tp = p * k;\n\t\t\t\tif (p > n)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p < n) {\n\t\t\t\tprintln(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tint[][] aa = new int[n][d];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = i;\n\t\t\tfor (int h = 0; h < d; h++) {\n\t\t\t\taa[i][h] = j % k;\n\t\t\t\tj /= k;\n\t\t\t}\n\t\t}\n\t\tfor (int h = 0; h < d; h++) {\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tprint(aa[i][h] + 1 + \" \");\n\t\t\tprintln();\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T, size_t size>\nostream &operator<<(ostream &os, const array<T, size> &arr) {\n  os << '{';\n  string sep;\n  for (const auto &x : arr) os << sep << x, sep = \", \";\n  return os << '}';\n}\ntemplate <class T>\nostream &operator<<(ostream &os, vector<T> V) {\n  os << \"[ \";\n  for (auto v : V) os << v << \" \";\n  return os << \"]\";\n}\ntemplate <class T>\nostream &operator<<(ostream &os, set<T> S) {\n  os << \"{ \";\n  for (auto s : S) os << s << \" \";\n  return os << \"}\";\n}\ntemplate <class L, class R>\nostream &operator<<(ostream &os, pair<L, R> P) {\n  return os << \"(\" << P.first << \",\" << P.second << \")\";\n}\ntemplate <class L, class R>\nostream &operator<<(ostream &os, map<L, R> M) {\n  os << \"{ \";\n  for (auto m : M) os << \"(\" << m.first << \":\" << m.second << \") \";\n  return os << \"}\";\n}\nconst int MAX = 1000010;\nconst int MOD2 = 998244353;\nconst int MOD1 = 1000000007;\nconst int INF = 0x3f;\nconst long long int LLINF = 0x3f3f3f3f3f3f3f3fll;\nconst long double EPS = 1e-7;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cout << fixed << setprecision(25);\n  cerr << fixed << setprecision(10);\n  long long int n, k, d;\n  cin >> n >> k >> d;\n  long long int a = 1;\n  for (int i = 1; i <= d; i++) {\n    a *= k;\n    if (a <= n) continue;\n    break;\n  }\n  if (a < n) {\n    cout << -1 << \"\\n\";\n    return 0;\n  }\n  vector<vector<int>> ans(d, vector<int>(n, 0));\n  for (int i = 0; i < n; i++) {\n    int x = i;\n    for (int j = 0; j < d; j++) {\n      ans[j][i] = x % k + 1;\n      x /= k;\n    }\n  }\n  42;\n  for (int i = 0; i < d; i++) {\n    for (int j = 0; j < n; j++) cout << ans[i][j] << \" \";\n    cout << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "n, k, d = map(int, raw_input().split())\n\nok = False\nm = 1\nfor i in xrange(d):\n    m *= k\n    if m >= n:\n        ok = True\n        break\n\nif ok:\n    a = [i for i in xrange(n)]\n    for i in xrange(d):\n        for j in xrange(n):\n            print (a[j] % k) + 1,\n            a[j] /= k\n        print\nelse:\n    print -1"
        },
        {
            "language": 4,
            "solution": "\n\nimport static java.util.Arrays.deepToString;\n\nimport java.io.BufferedReader;\nimport java.util.Arrays;\n\npublic class C {\n\n\tstatic int n,k,d;\n\tstatic int[] a;\n\tpublic static void main(String[] args) {\n\t\tn=NI();\n\t\tk=NI();\n\t\td=NI();\n\t\t\n\t\t\n\t\tlong lk=1;\n\t\tfor(int i=0;i<d;i++){\n\t\t\tlk=lk*(long)k;\n\t\t\tif((long)n<=lk)break;\n\t\t}\n\t\tif(n>lk){\n\t\t\tSystem.out.println(-1);\n\t\t\treturn;\n\t\t}\n\t\tint[]a = new int[d];\n\t\tArrays.fill(a, 1);\n\t\tint[][] ans=new int[d][n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<d;j++){\n\t\t\t\tans[j][i]=a[j];\n\t\t\t}\n\t\t\tadd(a,0,k);\n\t\t}\n\t\tStringBuffer sb = new StringBuffer();\n\t\tfor(int i=0;i<d;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(j==0){\n\t\t\t\t\tsb.append(ans[i][j]);\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(' ');\n\t\t\t\t\tsb.append(ans[i][j]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tsb.append('\\n');\n\t\t}\n\t\tSystem.out.print(sb);\n\t}\n\tstatic void add(int[] a,int digit,int k){\n//\t\tdebug(a);\n\t\tif(digit>=a.length)return;\n\t\ta[digit]++;\n\t\tif(a[digit]>k){\n\t\t\ta[digit]=1;\n\t\t\tadd(a,digit+1,k);\n\t\t}\n\t}\n\tstatic int NI(){\n\t\ttry {\n\t\t\tint c=System.in.read(),r=0;\n\t\t\tfor(;c!='-'&&(c<'0'||'9'<c);)c=System.in.read();\n\t\t\tif(c=='-') return -NI();\n\t\t\tfor(;'0'<=c&&c<='9';c=System.in.read())\n\t\t\t\tr = r * 10 + c - '0';\n\t\t\treturn r;\n\t\t} catch (Exception e) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tstatic void debug(Object...os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.ObjectInputStream.GetField;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main\n{\n\n\tprivate static BufferedWriter out;\n\n\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\t// The input and output streams\n\t\tboolean file = false;\n\t\tBufferedReader in;\n\t\tif (file)\n\t\t\tin = new BufferedReader(new FileReader(\"input.txt\"), 32768);\n\t\telse\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in), 32768);\n\t\tout = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\tStringTokenizer tok;\n\n\t\t// take input\n\t\ttok = new StringTokenizer(in.readLine());\n\t\tint n = Integer.parseInt(tok.nextToken());\n\t\tlong k = Long.parseLong(tok.nextToken());\n\t\tint d = Integer.parseInt(tok.nextToken());\n\t\t\n\t\tlong max = k;\n\t\tfor (int i = 0; i < d-1; i++)\n\t\t{\n\t\t\tif (max > n)\n\t\t\t\tbreak;\n\t\t\tmax *= k;\n\t\t}\n\t\t\n\t\t\n\t\tif (max < n)\n\t\t{\n\t\t\tout.write(\"-1\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsolve(n, k, d);\n\t\t}\n\t\tout.flush();\n\t\t\n\n\t}\n\n\n\tprivate static void solve(int n, long k, int d) throws IOException\n\t{\n\t\tlong done = 1;\n\t\t\n\t\t// add the first day\n\t\tArrayList<Long> firstDay = new ArrayList<>();\n\t\tlong curr = 1;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfirstDay.add(curr);\n\t\t\tcurr = (curr  % k) +1;\n\t\t}\n\t\t// output it \n\t\tStringBuilder str = new StringBuilder();\n\t\tfor (Long integer : firstDay)\n\t\t\tstr.append(integer + \" \");\n\t\tout.write(str.toString().trim()+ \"\\n\");\n\t\t\n\t\tlong matched = k;\n\t\tfor (int i = 1; i < d; i++)\n\t\t{\n\t\t\t// add the already matched\n\t\t\tArrayList<Long> day = new ArrayList<>();\n\t\t\tcurr = 1;\n\t\t\tfor (int j = 0; j < matched && j < n; j++)\n\t\t\t{\n\t\t\t\tday.add(curr);\n\t\t\t\tcurr = (curr  % k) +1;\n\t\t\t}\n\t\t\t\n\t\t\t// match the rest\n\t\t\tfor (long j = matched; j < n; j++)\n\t\t\t{\n\t\t\t\tLong prev = day.get((int) (j - matched));\n\t\t\t\tday.add((prev  % k) +1);\n\t\t\t}\n\t\t\t\n\t\t\tif (matched < n)\n\t\t\t\tmatched *= k;\n\t\t\t\n\t\t\t// output it \n\t\t\tstr = new StringBuilder();\n\t\t\tfor (Long integer : day)\n\t\t\t\tstr.append(integer + \" \");\n\t\t\tout.write(str.toString().trim() + \"\\n\");\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n\n\tpublic static double round(double value, int places)\n\t{\n\t\tif (places < 0)\n\t\t\tthrow new IllegalArgumentException();\n\n\t\tlong factor = (long) Math.pow(10, places);\n\t\tvalue = value * factor;\n\t\tlong tmp = Math.round(value);\n\t\treturn (double) tmp / factor;\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, d, ans[1010][1010];\nlong long l = 1, inf = 1e12;\nvoid update(int j) {\n  for (int i = 0; i < d; i++) ans[j][i] = ans[j - 1][i];\n  ans[j][0]++;\n  int i = 0;\n  while (ans[j][i] >= k) {\n    ans[j][i] = 0;\n    ans[j][i + 1] += 1;\n    i++;\n  }\n}\nint main() {\n  cin >> n >> k >> d;\n  for (int i = 0; i < d; i++) {\n    l *= (k * 1ll);\n    if (l >= inf) break;\n  }\n  if (l < n) {\n    cout << \"-1\" << endl;\n    return 0;\n  }\n  for (int i = 0; i < d; i++) ans[0][i] = 0;\n  for (int i = 1; i < n; i++) update(i);\n  for (int i = 0; i < d; i++, cout << endl)\n    for (int j = 0; j < n; j++) cout << ans[j][i] + 1 << ' ';\n}\n"
        },
        {
            "language": 4,
            "solution": "/*\n *created by Kraken on 07-05-2020 at 15:34\n */\n//package com.kraken.cf.practice;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class C459 {\n\n  public static void main(String[] args) {\n    FastReader sc = new FastReader();\n    int n = sc.nextInt();\n    long k = sc.nextLong();\n    int d = sc.nextInt();\n    if (n > Math.pow(k , d)) {\n      System.out.println(-1);\n      return;\n    }\n    long[][] res = new long[n][d];\n    for (int col = 0; col < d; col++) {\n      int step = (int) Math.pow(k, col);\n      long cnt = 1;\n      for (int row = 0; row < n; row += step) {\n        res[row][col] = cnt;\n        cnt++;\n        if (cnt > k) cnt = 1;\n      }\n    }\n    for (int row = 0; row < n; row++) {\n      for (int col = 0; col < d; col++) {\n        if (res[row][col] == 0) res[row][col] = res[row - 1][col];\n      }\n    }\n    StringBuilder sb = new StringBuilder();\n    for (int col = 0; col < d; col++) {\n      for (int row = 0; row < n; row++) {\n        sb.append(res[row][col] + \" \");\n      }\n      sb.append(\"\\n\");\n    }\n    System.out.print(sb);\n  }\n\n  static class FastReader {\n\n    BufferedReader br;\n\n    StringTokenizer st;\n\n    public FastReader() {\n      br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    String next() {\n      while (st == null || !st.hasMoreElements()) {\n        try {\n          st = new StringTokenizer(br.readLine());\n        }\n        catch (IOException e) {\n          e.printStackTrace();\n        }\n      }\n      return st.nextToken();\n    }\n\n    int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    long nextLong() {\n      return Long.parseLong(next());\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    String nextLine() {\n      String str = \"\";\n      try {\n        str = br.readLine();\n      }\n      catch (IOException e) {\n        e.printStackTrace();\n      }\n      return str;\n    }\n  }\n}\n\n\t\t\t\t   \t  \t  \t\t\t \t  \t \t \t \t \t\t"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class Buses {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        int d = sc.nextInt();\n\n        int[][] comb = new int[d][n];\n\n        int[] start = new int[d];\n        for (int i = 0; i < d; i++) {\n            start[i] = 1;\n            comb[i][0] = 1;\n        }\n\n        boolean allOnes = false;\n        for (int i = 1; i < n; i++) {\n            int[] next = nextComb(n, k, d,  start);\n            allOnes = true;\n            for (int j = 0; j < d; j++) {\n                comb[j][i] = next[j];\n                allOnes &= next[j] == 1;\n            }\n            if (allOnes) {\n                break;\n            }\n\n        }\n        if (allOnes) {\n            System.out.println(-1);\n        } else {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < d; i++) {\n                for (int j = 0; j < n; j++) {\n                   sb.append(comb[i][j]).append(\" \");\n                }\n                sb.append(\"\\n\");\n            }\n            System.out.println(sb.toString());\n        }\n    }\n\n    private static int[] nextComb(int n, int k, int d,  int[] comb) {\n        for (int i = d - 1; i >= 0; i--) {\n\n            if(comb[i] < k) {\n                comb[i] ++;\n                return comb;\n            }  else {\n                comb[i] = 1;\n            }\n\n        }\n        return comb;\n    }\n}\n"
        },
        {
            "language": 1,
            "solution": "from sys import stdin, stdout\nn, k, d = map(int, stdin.readline().split())\nif n > k ** d:\n    print -1\nelse:\n    z=1\n    for x in range(d):\n        arr=[]\n        for y in range(n):\n            arr.append((y/z)%k+1)\n        z*=k\n        for f in arr:\n            stdout.write(str(f)+' ')\n        stdout.write('\\n')\n        arr=[]\n\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, k, d;\n  cin >> n >> k >> d;\n  long long l = 1;\n  int f = 0;\n  for (int i = 0; i < d; i++) {\n    l = l * k;\n    if (l >= n) {\n      f = 1;\n      break;\n    }\n  }\n  if (f == 0) {\n    cout << \"-1\";\n    return 0;\n  }\n  int ans[n][d];\n  memset(ans, 0, sizeof(ans));\n  for (int i = 1; i < n; i++) {\n    for (int j = 0; j < d; j++) {\n      ans[i][j] = ans[i - 1][j];\n    }\n    for (int j = d - 1; j >= 0; j--) {\n      ans[i][j] = (ans[i][j] + 1) % k;\n      if (ans[i][j]) {\n        break;\n      }\n    }\n  }\n  for (int i = 0; i < d; i++) {\n    for (int j = 0; j < n; j++) {\n      cout << ans[j][i] + 1 << \" \";\n    }\n    cout << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long d1;\nlong long m;\nlong long n;\nlong long mas[5000][5000];\nbool f = false;\nvoid rec(long long hod, long long start, long long h) {\n  if (hod > d1) {\n    return;\n  }\n  long long m1 = 1;\n  for (long long i = start; i <= n; i += h) {\n    mas[hod][i] = m1;\n    m1++;\n    if (m1 > m) {\n      m1 = 1;\n    }\n  }\n  m1 = 1;\n  for (long long i = start; i <= n; i += h) {\n    if (m1 > m) {\n      break;\n    }\n    rec(hod + 1, i, h * m);\n    m1++;\n  }\n}\nint main() {\n  long long d;\n  cin >> n >> m >> d;\n  int k = 0;\n  int t = 1;\n  while (t < n) {\n    t *= m;\n    k++;\n    if (k > d) {\n      cout << -1 << endl;\n      return 0;\n    }\n  }\n  d1 = min(d, (long long)k);\n  d1 = max(d1, (long long)1);\n  rec(1, 1, 1);\n  for (int i = 1; i <= d; i++) {\n    if (i <= d1) {\n      for (int j = 1; j <= n; j++) {\n        printf(\"%lld \", mas[i][j]);\n      }\n    } else {\n      for (int j = 1; j <= n; j++) {\n        printf(\"%lld \", mas[1][j]);\n      }\n    }\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint g[1200][1200];\nint i, j, k, l, m, n;\ninline bool check() {\n  if (m == 1)\n    if (n == 1)\n      return false;\n    else\n      return true;\n  for (int i = m, j = 1; j <= l; i = i * m, j++)\n    if (i >= n) return false;\n  return true;\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &l);\n  if (check())\n    puts(\"-1\");\n  else {\n    for (i = 0; i < n; i++)\n      for (j = 1, k = i; j <= l; j++, k = k / m) g[j][i + 1] = k % m + 1;\n    for (i = 1; i <= l; i++) {\n      for (j = 1; j <= n; j++) printf(\"%d \", g[i][j]);\n      printf(\"\\n\");\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 1200;\nusing namespace std;\nint a[N][N];\nint main() {\n  int n, k, d;\n  while (~scanf(\"%d%d%d\", &n, &k, &d)) {\n    if (double(n) > pow((double)k, d))\n      printf(\"-1\\n\");\n    else {\n      memset(a, 0, sizeof(a));\n      for (int st = 0; st < n; st++) {\n        int tmp = st, j = 0;\n        while (tmp) {\n          a[j][st] = tmp % k;\n          tmp /= k;\n          j++;\n        }\n      }\n      for (int i = 0; i < d; i++) {\n        for (int j = 0; j < n; j++) {\n          printf(\"%d%c\", a[i][j] + 1, j == n ? '\\n' : ' ');\n        }\n        printf(\"\\n\");\n      }\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.lang.*;\nimport java.math.*;\npublic class C {\n    public static void main(String[] args) throws Exception {\n        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n        // Scanner scan = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); \n        // int n = Integer.parseInt(bf.readLine());\n        StringTokenizer st = new StringTokenizer(bf.readLine());\n        // int[] a = new int[n]; for(int i=0; i<n; i++) a[i] = Integer.parseInt(st.nextToken());\n        int n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        int d = Integer.parseInt(st.nextToken());\n        if(k < Math.pow(n, 1.0/d)) System.out.println(\"-1\");\n        else {\n            for(int i=0; i<d; i++) {\n                for(int j=0; j<n; j++) {\n                    int toput = (int)(((j/Math.round(Math.pow(k, i))) + 1) % k);\n                    if(toput == 0) toput = k;\n                    out.print(toput + \" \");\n                }\n                out.print(\"\\n\");\n            }\n        }\n        // int n = scan.nextInt();\n        \n        out.close(); System.exit(0);\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\n\nimport java.awt.Point;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.text.*;\n\npublic class cf459c {\n\n    static BufferedReader br;\n    static Scanner sc;\n    static PrintWriter out;\n\n    public static void initA() {\n        try {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            sc = new Scanner(System.in);\n            out = new PrintWriter(System.out);\n        } catch (Exception e) {\n        }\n    }\n\n    static boolean next_permutation(Integer[] p) {\n        for (int a = p.length - 2; a >= 0; --a) {\n            if (p[a] < p[a + 1]) {\n                for (int b = p.length - 1;; --b) {\n                    if (p[b] > p[a]) {\n                        int t = p[a];\n                        p[a] = p[b];\n                        p[b] = t;\n                        for (++a, b = p.length - 1; a < b; ++a, --b) {\n                            t = p[a];\n                            p[a] = p[b];\n                            p[b] = t;\n                        }\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    public static String getString() {\n        try {\n            return br.readLine();\n        } catch (Exception e) {\n        }\n        return \"\";\n    }\n\n    public static Integer getInt() {\n        try {\n            return Integer.parseInt(br.readLine());\n        } catch (Exception e) {\n        }\n        return 0;\n    }\n\n    public static Integer[] getIntArr() {\n        try {\n            StringTokenizer temp = new StringTokenizer(br.readLine());\n            int n = temp.countTokens();\n            Integer temp2[] = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                temp2[i] = Integer.parseInt(temp.nextToken());\n            }\n            return temp2;\n        } catch (Exception e) {\n        }\n        return null;\n    }\n\n    public static Long[] getLongArr() {\n        try {\n            StringTokenizer temp = new StringTokenizer(br.readLine());\n            int n = temp.countTokens();\n            Long temp2[] = new Long[n];\n            for (int i = 0; i < n; i++) {\n                temp2[i] = Long.parseLong(temp.nextToken());\n            }\n            return temp2;\n        } catch (Exception e) {\n        }\n        return null;\n    }\n\n    public static String[] getStringArr() {\n        try {\n            StringTokenizer temp = new StringTokenizer(br.readLine());\n            int n = temp.countTokens();\n            String temp2[] = new String[n];\n            for (int i = 0; i < n; i++) {\n                temp2[i] = (temp.nextToken());\n            }\n            return temp2;\n        } catch (Exception e) {\n        }\n        return null;\n    }\n\n    public static void print(Object a) {\n        out.println(a);\n    }\n\n    public static void print(String s, Object... a) {\n        out.printf(s, a);\n    }\n\n    public static int nextInt() {\n        return sc.nextInt();\n    }\n\n    public static double nextDouble() {\n        return sc.nextDouble();\n    }\n\n    public static void main(String[] ar) {\n        initA();\n        cf459c c = new cf459c();\n        c.solve();\n        out.flush();\n    }\n    ArrayList<Integer> base_perm = new ArrayList<Integer>();\n    HashSet<Long> sdh = new HashSet<Long>();\n    int bth;\n    int n, k, d;\n    Integer temp[] = new Integer[1000 + 5];\n    int kolom_dikerjakan = 0;\n    Integer ou[][] = new Integer[1005][1005];\n\n    void dfs(int i, int j, long hash) {\n\n        if (kolom_dikerjakan == n) {\n            // print(\"SELSE\");\n            return;\n        }\n        if (j == d) {\n            if (!sdh.contains(hash)) {\n                Integer tx[] = new Integer[d];\n                System.arraycopy(temp, 0, tx, 0, tx.length);\n\n\n               // print(Arrays.asList(tx) + \" KERJAKAN KOLOM \"+kolom_dikerjakan);\n                for (; kolom_dikerjakan < n; ) {\n                    for (int x = 0; x < d; x++) {\n                        ou[x][kolom_dikerjakan] = tx[x];\n                       // print(\"SET \"+x+\",\"+kolom_dikerjakan +\" = \"+tx[x]);\n                    }\n                    kolom_dikerjakan++;\n                    boolean a = next_permutation(tx);\n                    if (!a) {\n                        break;\n                    }\n                }\n                sdh.add(hash);\n            }\n            return;\n        }\n        if (i == base_perm.size()) {\n            return;\n        }\n        temp[j] = base_perm.get(i);\n        dfs(i + 1, j + 1, hash * k + base_perm.get(i));\n\n        //ambil sama berulang\n        dfs(i, j + 1, hash * k + base_perm.get(i));\n\n        //ini di bawahnya krn supaya tdk mengganti temp[j] dgn kanannya\n        //ambil angka berikut\n        dfs(i + 1, j, hash);\n\n\n    }\n\n    void solve() {\n        Integer xx[] = getIntArr();\n        n = xx[0];\n        k = xx[1];\n        d = xx[2];\n\n        if (n > 1 && (k == 1 || (d == 1 && k < n) )) {\n            print(-1);\n            return;\n        }\n        //n = kolom d = baris\n        long st =System.currentTimeMillis();\n        bth = n * d;\n\n        //print(\"BUTUH \"+bth);\n        for (int i = 1; base_perm.size() < bth && i <= k; i++) {\n            //for (int j = 0; base_perm.size() < bth && j < d; j++) {\n            base_perm.add(i);\n            //}\n        }\n        //print(\"BASE \" + base_perm);\n        dfs(0, 0, 0);\n        /*\n        for (Integer[] x : list_) {\n        print(Arrays.asList(x));\n        }\n        print(sdh);\n         */\n\n        if (kolom_dikerjakan != n) {\n            print(-1);\n            return;\n        }\n       // print(\"SELSE DALAM \"+(System.currentTimeMillis() - st));\n        for (int i = 0; i < d; i++) {\n            StringBuilder p = new StringBuilder();\n            for (int j = 0; j < n; j++) {\n                p.append(ou[i][j]+\" \");\n                //print(\"%d \", ou[i][j]);\n            }\n            print(p);\n        }\n\n\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, d, k, ans[1010][1010];\nint main() {\n  ios::sync_with_stdio(0);\n  cin >> n >> k >> d;\n  for (int i = 0; i < d; i++) ans[0][i] = 1;\n  for (int i = 1; i < n; i++) {\n    for (int j = 0; j < d; j++) ans[i][j] = ans[i - 1][j];\n    ans[i][0]++;\n    for (int j = 0; j < d; j++) {\n      if (ans[i][j] > k) {\n        ans[i][j] = 1;\n        ans[i][j + 1]++;\n      } else\n        break;\n    }\n    if (ans[i][d]) {\n      cout << -1 << '\\n';\n      return 0;\n    }\n  }\n  for (int i = 0; i < d; i++) {\n    for (int j = 0; j < n; j++) cout << ans[j][i] << ' ';\n    cout << '\\n';\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.PrintWriter;\nimport java.util.Scanner;\npublic class TestC {\n\n    public static void main (String args[]) {\n        Scanner sc = new Scanner(System.in);\n        int student = sc.nextInt();\n        int bus = sc.nextInt();\n        int day = sc.nextInt();\n        long tmp = 1;\n        for (int i = 0; i < day; ++i)\n              tmp = Math.min(tmp * bus, (long) 1e9);\n        if (tmp >= student) {\n             int div = 1;\n             for (int i = 0; i < day; ++i) {\n                 StringBuilder sb = new StringBuilder();\n                 for (int j = 0; j < student; ++j) {\n                      if (j > 0) sb.append(\" \");\n                      sb.append(j / div % bus + 1);\n                  }\n                  System.out.println(sb);\n                  div = (int) Math.min(1L * div * bus, (long) 1e9);\n\n                }\n            } else {\n                System.out.println(-1);\n            }\n        }\n}"
        },
        {
            "language": 3,
            "solution": "#------------------------template--------------------------#\nimport os\nimport sys\nfrom math import *\nfrom collections import *\nfrom fractions import *\nfrom bisect import *\nfrom heapq import*\nfrom io import BytesIO, IOBase\ndef vsInput():\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nALPHA='abcdefghijklmnopqrstuvwxyz'\nM=10**9+7\nEPS=1e-6\ndef value():return tuple(map(int,input().split()))\ndef array():return [int(i) for i in input().split()]\ndef Int():return int(input())\ndef Str():return input()\ndef arrayS():return [i for i in input().split()]\n\n\n#-------------------------code---------------------------#\n# vsInput()\n\n\nn,k,d=value()\n\nif(n>k**d):\n    print(-1)\nelse:\n    \n    each=1\n    for i in range(d):\n        key=1\n        c=0\n\n        for i in range(n):\n            print(key,end=\" \")\n            c+=1\n            if(c==each):\n                c=0\n                key+=1\n                if(key>k): key=1\n        each*=k\n\n\n        print()\n\n    \n        \n\n\n\n\n\n\n\n\n\n\n\n    \n\n        \n\n\n\n\n\n                \n\n    \n\n\n\n\n\n\n\n\n\n    "
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main\n{\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Runnable() {\n\t\t\tpublic void run() {\n                solve();\n            }\n        }, \"1\", 1 << 26).start();\n\t}\n\tstatic void solve () {\n\t\tFastReader fr =new FastReader();\tPrintWriter op =new PrintWriter(System.out);\n \n \t\tint n =fr.nextInt() ,x =fr.nextInt() ,d =fr.nextInt() ,i =1 ,j ,k ,l ,m ;\tlong dm ;\n \t\tboolean f =false ;\n \t\tfor (j =0 ; j<=d ; ++j) {\n \t\t\tif (i>=n)\tbreak;\ti *= x ;\n \t\t}\n \t\tif (j>d)\top.println(\"-1\") ;\n \t\telse {\n \t\t\tint mat[][] =new int[d][n] ;\tl =1 ;\n \t\t\tfor (i =d-1 ; i>-1 ; --i) {\n \t\t\t\tj =m =0 ;\n \t\t\t\twhile (j<n) {\n \t\t\t\t\tfor (k =0 ; k<l ; ++k) {\n \t\t\t\t\t\tif (j+k >= n)\tbreak; \tmat[i][j+k] =m ;\n \t\t\t\t\t}\n \t\t\t\t\tm =(m+1)%x ;\tj += l ;\n \t\t\t\t}\n \t\t\t\tif (f)\tcontinue;\n \t\t\t\tdm =l * x ;\n \t\t\t\tif (dm>n)\t{\tf =true ;\tl =n ;\t}\n \t\t\t\telse \tl =(int)dm ;\n \t\t\t}\n \t\t\tfor (i =0 ; i<d ; ++i) {\n \t\t\t\tfor (j =0 ; j<n ; ++j)\top.print((mat[i][j]+1) + \" \") ;\n \t\t\t\top.println() ;\n \t\t\t}\n \t\t}\n\t\top.flush();\top.close();\n\t}\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastReader() {\n\t\t\tbr =new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st==null || (!st.hasMoreElements())) \n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tst =new StringTokenizer(br.readLine());\n\t\t\t\t}\n\t\t\t\tcatch(IOException e)\n\t\t\t\t{\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str =\"\";\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tstr =br.readLine();\n\t\t\t}\n\t\t\tcatch(IOException e)\n\t\t\t{\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t\t\treturn str;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next()) ;\n\t\t}\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/python3\n\nimport sys\n\nn, k, d = list(map(int, sys.stdin.readline().split()))\n\nx = 1\nwhile x ** d < n:\n    x += 1\n    \nif x > k:\n    sys.stdout.write(\"-1\\n\")\n    sys.exit(0)\n    \nans = [[1 for i in range(d)] for j in range(n)]\nfor i in range(1, n):\n    for j in range(d): \n        ans[i][j] = ans[i - 1][j]\n    ans[i][d - 1] += 1\n    memo = 0\n    for j in range(d - 1, -1, -1):\n        ans[i][j] += memo\n        memo = 0\n        if ans[i][j] > x:\n            memo = ans[i][j] - x\n            ans[i][j] = 1\n            \nfor i in range(d):\n    sys.stdout.write(' '.join([str(ans[j][i]) for j in range(n)]) + '\\n')"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1111;\nint data[maxn], sum;\nint n, d, k, cnt[maxn][maxn];\nvoid dfs(int x) {\n  if (sum >= n) return;\n  if (x >= d) {\n    for (int i = 0; i < d; i++) cnt[i][sum] = data[i];\n    sum++;\n    return;\n  }\n  for (int i = 1; i <= min(k, 1001); i++) {\n    data[x] = i;\n    dfs(x + 1);\n  }\n}\nint main() {\n  while (~scanf(\"%d%d%d\", &n, &k, &d)) {\n    memset(cnt, 0, sizeof(cnt));\n    sum = 0;\n    dfs(0);\n    if (sum < n)\n      puts(\"-1\");\n    else {\n      for (int i = 0; i < d; i++) {\n        for (int j = 0; j < n; j++) printf(\"%d \", cnt[i][j]);\n        puts(\"\");\n      }\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid fast() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << setprecision(12) << fixed;\n}\nvoid solve() {\n  long long n, k, d;\n  cin >> n >> k >> d;\n  long long pp = 1, f = 0;\n  for (long long i = 1; i <= d; i++) {\n    pp *= k;\n    if (pp >= n) {\n      f = i;\n      break;\n    }\n  }\n  if (f == 0) {\n    cout << -1 << \"\\n\";\n    return;\n  };\n  long long a[n];\n  for (long long i = 0; i < n; i++) a[i] = i;\n  for (long long i = 0; i < d; i++) {\n    for (long long j = 0; j < n; j++) {\n      cout << (a[j] % k) + 1 << \" \";\n      a[j] /= k;\n    }\n    cout << endl;\n  }\n}\nint main() {\n  fast();\n  long long t = 1;\n  while (t--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, d, f[1005][1005];\nbool check() {\n  int p = 1;\n  for (int i = 1; i <= d; i++) {\n    p *= k;\n    if (p >= n) return true;\n  }\n  return false;\n}\nint main() {\n  cin >> n >> k >> d;\n  if (!check())\n    cout << -1;\n  else {\n    for (int i = 1; i <= n; i++) {\n      for (int j = 1; j <= d; j++) f[i][j] = f[i - 1][j];\n      for (int j = d; j >= 1; j--) {\n        f[i][j] = (f[i][j] + 1) % k;\n        if (f[i][j]) break;\n      }\n    }\n    for (int j = 1; j <= d; j++) {\n      for (int i = 1; i <= n; i++) cout << f[i][j] + 1 << ' ';\n      cout << endl;\n    }\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int k = in.nextInt();\n            int d = in.nextInt();\n\n            {\n                long acc = 1;\n                int i;\n                for (i = 0; i < d; i++, acc *= k) {\n                    if (acc >= n)\n                        break;\n                }\n                if (acc < n) {\n                    out.println(-1);\n                    return;\n                }\n            }\n\n            for (int i = 0; i < d; i++) {\n                long nbus = (long) Math.pow(k, i);\n                int bi = 1;\n                for (int j = 0; j < n; ) {\n                    for (int l = 1; l <= nbus && j < n; l++, j++) {\n                        out.print(bi + \" \");\n                    }\n                    bi++;\n                    if (bi > k)\n                        bi = 1;\n                }\n                out.println();\n            }\n        }\n\n    }\n\n    static class InputReader {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public InputReader(InputStream is) {\n            BufferedReader br = new BufferedReader(new InputStreamReader(is));\n            this.br = br;\n        }\n\n        public String n() {\n            if (st == null || !st.hasMoreTokens()) {\n                String nextLine = null;\n                try {\n                    nextLine = br.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (nextLine == null)\n                    return null;\n                st = new StringTokenizer(nextLine);\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(n());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.math.BigInteger;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Rishabhdeep Singh\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt(), k = in.nextInt(), d = in.nextInt();\n            if (BigInteger.valueOf(k).pow(d).compareTo(BigInteger.valueOf(n)) < 0) {\n                out.println(\"-1\");\n            } else {\n                int[][] ans = new int[n][];\n                int[] t = new int[d];\n                for (int i = 0; i < n; i++) {\n                    ans[i] = Arrays.copyOf(t, t.length);\n                    t[d - 1]++;\n                    for (int j = d - 1; j > 0; j--) {\n                        t[j - 1] += t[j] / k;\n                        t[j] %= k;\n                    }\n                }\n                for (int i = 0; i < d; i++) {\n                    for (int j = 0; j < n; j++) {\n                        out.print(ans[j][i] + 1);\n                        out.print(\" \");\n                    }\n                    out.println();\n                }\n            }\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void println() {\n            writer.println();\n        }\n\n        public void println(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void print(int i) {\n            writer.print(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios ::sync_with_stdio(false);\n  int n, k, d;\n  cin >> n >> k >> d;\n  int temp = 1, j, i = 1, flag = 0;\n  while (i <= d) {\n    temp *= k;\n    i++;\n    if (temp >= n) {\n      flag = 1;\n      break;\n    }\n  }\n  if (flag == 0) {\n    cout << -1;\n    return 0;\n  }\n  int ans[n][d];\n  for (long long int i = 0; i < n; i++)\n    for (long long int j = 0; j < d; j++) ans[i][j] = 0;\n  for (i = 1; i < n; i++) {\n    for (j = 0; j < d; j++) ans[i][j] = ans[i - 1][j];\n    for (j = d - 1; j >= 0; j--) {\n      ans[i][j] = (ans[i][j] + 1) % k;\n      if (ans[i][j]) break;\n    }\n  }\n  for (i = 0; i < d; i++) {\n    for (j = 0; j < n; j++) {\n      cout << ans[j][i] + 1 << \" \";\n    }\n    cout << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint res[1010][1010];\nint n, k, d;\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &d);\n  bool flag = 0;\n  int tmp = 1;\n  for (int i = 1; i <= d; i++) {\n    tmp *= k;\n    if (tmp >= n) {\n      flag = 1;\n      break;\n    }\n  }\n  if (!flag) {\n    puts(\"-1\");\n    return 0;\n  }\n  for (int i = 1; i <= n; i++) {\n    int num = i;\n    for (int j = 1; j <= d; j++) {\n      res[i][j] = num % k;\n      num /= k;\n    }\n  }\n  for (int i = 1; i <= d; i++) {\n    printf(\"%d\", res[1][i] + 1);\n    for (int j = 2; j <= n; j++) {\n      printf(\" %d\", res[j][i] + 1);\n    }\n    puts(\"\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class pashmak_buses \n{\n\t\n\tpublic static void main(String args[])throws IOException\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\tpashmak_buses pb = new pashmak_buses();\n\t\t\n\t\t PrintWriter out;\n\t\t out = new PrintWriter(new BufferedOutputStream(System.out));\n\t\t\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tint d = sc.nextInt();\n\t\t\n\t\tif (n > (int)Math.pow(k, d))\n\t\t\tSystem.out.println(-1);\n\t\telse\n\t\t{\n\t\t\tint [][] grid = new int [d+1][n+1];\n\t\t\tfor (int i = 0; i< n; i++)\n\t\t\t{\n\t\t\t\tint no = i;\n\t\t\t\tfor (int j = 0; j< d; j++)\n\t\t\t\t{\n\t\t\t\t\tgrid[j+1][i+1] = 1 + no%k;\n\t\t\t\t\tno = no/k;\n\t\t\t\t}\n\t\t\t}//\n\t\t\t\n\t\t\tfor (int i = 1; i<= d; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 1; j<= n; j++)\n\t\t\t\t{\n\t\t\t\t\tout.print(grid[i][j]+\" \");\n\t\t\t\t}\n\t\t\t\tout.println();\n\t\t\t\t\n\t\t\t}\n\t\t\tout.flush();\n\t\t\tout.close();\n\t\t\t\t\t\t\n\t\t}\n\t\t\t\t\n\t}\n\n}\n"
        },
        {
            "language": 1,
            "solution": "n, k, d = map(int, raw_input().strip().split())\np, t = 0, n\nwhile t >= k and k > 1:\n    t /=k\n    p += 1\nif p > d or (k == 1 and n > 1):\n    print -1\nelse:\n    ok = True\n    a = [[1]*d for _ in range(n)]\n    for i in range(1, n):\n        t, j = i, 0\n        while t > 0 and j < d:\n            a[i][j] += t % k\n            t /= k\n            j += 1\n        if t > 0:\n            ok = False\n            break\n    if not ok:\n        print -1\n    else:\n        for j in range(d):\n            v = [a[i][j] for i in range(n)]\n            print ' '.join(map(str, v))\n\n\n\n"
        },
        {
            "language": 3,
            "solution": "n,k,d=map(int,input().split())\nif n>k**d:print(-1);exit()\nK=1\nfor j in range(d):\n    print(\" \".join([str(i//K%k +1) for i in range(n)]))\n    K*=k"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1e9 + 7;\nconst int N = 1e3 + 10;\nconst int M = 1e4;\nint a[N][N];\nint main() {\n  int n, k, d;\n  cin >> n >> k >> d;\n  int flag = 1;\n  memset((a), (0), sizeof(a));\n  if (n == 1) {\n    while (d--) cout << 1 << endl;\n    return 0;\n  }\n  for (int i = 1; i <= d; i++) a[1][i] = 1;\n  for (int i = 2; i <= n; i++) {\n    for (int j = 1; j <= d; j++) a[i][j] = a[i - 1][j];\n    a[i][d]++;\n    for (int j = d; j > 0; j--) {\n      if (a[i][j] > k)\n        a[i][j] = 1, a[i][j - 1]++;\n      else\n        break;\n    }\n    if (a[i][0] == 1) {\n      flag = 0;\n      break;\n    }\n  }\n  if (!flag) {\n    cout << -1 << endl;\n    return 0;\n  }\n  for (int j = 1; j <= d; j++) {\n    for (int i = 1; i <= n; i++) {\n      if (i > 1) cout << ' ';\n      cout << a[i][j];\n    }\n    cout << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "n, k, d = map(int, raw_input().split())\nif n > k**d: print -1; exit(0)\nki = 1\nfor i in xrange(d):\n    print \" \".join(map(str, [(j/ki)%k+1 for j in xrange(n)]))\n    ki *= k"
        },
        {
            "language": 1,
            "solution": "import math\n\n\ndef print_kids(kids):\n\tfor i in kids:\n\t\tprint i + 1,\n\tprint\n\n\n(kidCount, busCount, dayCount) = [int(x) for x in raw_input().split()]\n\nkidBuses = []\nfor i in range(0, kidCount):\n\tkidBuses.append([])\n\nif busCount >= kidCount:\n\tkids = range(0, kidCount)\n\tfor i in xrange(0, dayCount):\n\t\tprint_kids(kids)\nelse:\n\tif kidCount > busCount ** dayCount:\n\t\tprint -1\n\telse:\n\t\tkids = [0] * kidCount\n\t\tchunks = [range(0, kidCount)]\n\n\t\tprevChunkSize = kidCount\n\t\tfor i in xrange(0, dayCount):\n\t\t\tchunkSize = int(math.ceil(float(prevChunkSize) / busCount))\n\n\t\t\tnewChunks = []\n\t\t\tfor chunk in chunks:\n\t\t\t\tbusIndex = 0\n\t\t\t\tbus = []\n\n\t\t\t\tfor kid in chunk:\n\t\t\t\t\tkids[kid] = busIndex\n\t\t\t\t\tbus.append(kid)\n\t\t\t\t\tif len(bus) == chunkSize:\n\t\t\t\t\t\tnewChunks.append(bus)\n\n\t\t\t\t\t\tbus = []\n\t\t\t\t\t\tbusIndex += 1\n\n\t\t\t\tif len(bus) > 0:\n\t\t\t\t\tnewChunks.append(bus)\n\t\t\tchunks = newChunks\n\n\t\t\tprint_kids(kids)\n\t\t\tif chunkSize == 1:\n\t\t\t\tbreak\n\n\t\t\tprevChunkSize = chunkSize\n\n\t\tfor j in xrange(i + 1, dayCount):\n\t\t\tprint_kids(kids)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nlong long MM = 1000000007;\nusing namespace std;\nlong long gcd(long long a, long long b) {\n  if (a == 0 || b == 0) return abs(a - b);\n  long long res = a % b;\n  while (res) {\n    a = b;\n    b = res;\n    res = a % b;\n  }\n  return b;\n}\nlong long lcm(long long a, long long b) { return a * b / gcd(a, b); }\nlong long max(long long a, long long b) {\n  if (a > b)\n    return a;\n  else\n    return b;\n}\nlong long min(long long a, long long b) {\n  if (a < b)\n    return a;\n  else\n    return b;\n}\nlong long numberofdiviser(long long a) {\n  long long ans = 0;\n  long long i;\n  for (i = 1; i * i < a; i++) {\n    if (a % i == 0) ans += 2;\n  }\n  if (i * i == a) ans++;\n  return ans;\n}\nvoid fival(long long* a, long long b, long long n) {\n  for (int i = 0; i < n; i++) {\n    a[i] = b;\n  }\n}\nlong long sum, ans, l, r, x;\nlong long ss(vector<long long> a, vector<long long>& b, int ii) {\n  for (int i = ii; i < a.size(); i++) {\n    b.push_back(a[i]);\n    sum += a[i];\n    if (b.size() > 1 && sum >= l && sum <= r && b[b.size() - 1] - b[0] >= x)\n      ans++;\n    ss(a, b, i + 1);\n    sum -= b[b.size() - 1];\n    b.pop_back();\n  }\n  return ans;\n}\nunsigned long long fact(long long n) {\n  if (n == 0) return 1;\n  long long r = n * fact(n - 1);\n  r %= MM;\n  return r;\n}\nunsigned long long Combinations(unsigned long long n, unsigned long long r) {\n  if (r > n) return 0;\n  if (r * 2 > n) r = n - r;\n  if (r == 0) return 1;\n  unsigned long long res = n;\n  for (int i = 2; i <= r; ++i) {\n    res *= (n - i + 1);\n    res /= i;\n  }\n  return res;\n}\nlong long pow(long long a, long long b, long long m = MM) {\n  if (b == 0) return 1;\n  if (b == 1) return a;\n  long long x = pow(a, b / 2, m);\n  x = (x * x) % m;\n  if (b % 2) x = (x * a);\n  return x % m;\n}\nint dd(string s) {\n  long long res = 0;\n  for (int i = 0; i < s.size(); i++) {\n    res *= 2;\n    res += s[i] - 48;\n  }\n  return res;\n}\nint solve() {\n  int n, k, d;\n  cin >> n >> k >> d;\n  vector<vector<long long>> v = {{n}};\n  vector<long long> vv;\n  int f = 1;\n  int l = 0;\n  if (k == 1 && n > 1) return cout << -1, 0;\n  if (k >= n) {\n    while (d--) {\n      for (int i = 1; i <= n; i++) {\n        cout << i << \" \";\n      }\n      cout << \"\\n\";\n    }\n    return 0;\n  }\n  while (f) {\n    f = 0;\n    v.emplace_back(vv);\n    for (int i = 0; i < v[l].size(); i++) {\n      if (v[l][i] == 1) {\n        v.back().emplace_back(1);\n        continue;\n      }\n      int r = v[l][i] % k;\n      for (int j = 0; j < k; j++) {\n        v.back().emplace_back(v[l][i] / k);\n        if (r) {\n          v.back().back()++;\n          r--;\n        }\n        if (v.back().back() > 1) f = 1;\n      }\n    }\n    l++;\n  }\n  if (v.size() - 1 > d) return cout << -1, 0;\n  for (int i = 1, n = 1; n <= d; n++) {\n    for (int j = 0; j < v[i].size(); j++) {\n      for (int m = 0; m < v[i][j]; m++) {\n        if (j % k == 0) {\n          cout << k << \" \";\n        } else {\n          cout << j % k << \" \";\n        }\n      }\n    }\n    cout << \"\\n\";\n    if (i + 1 < v.size()) i++;\n  }\n  return 0;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 1,
            "solution": "n,k,d = map(float,raw_input().split())\n\nt_n = n\n\nfor i in xrange(int(d)):\n\tt_n = t_n/k\n\t\nif t_n > 1:\n\tprint \"-1\"\nelse:\n\tval = 1\n\tfor i in xrange(int(d)):\n\t\ts = ''\n\t\tno = 1\n\t\tcnt = 0\n\t\twhile cnt<n:\n\t\t\tfor i in xrange(int(val)):\n\t\t\t\tif cnt>=n: break\n\t\t\t\ts += str(no)+\" \"\n\t\t\t\tcnt += 1\n\t\t\tno += 1\n\t\t\tif no>int(k):\n\t\t\t\tno -= int(k)\n\t\tif val<=n:\n\t\t\tval *= k\n\t\tprint s\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, d;\nint a[1010][1010];\nvoid solve() {\n  memset(a, 0, sizeof(a));\n  for (int i = 0; i < n; i++) {\n    int x = i, j = 0;\n    while (x) {\n      a[i][j++] = x % k;\n      x /= k;\n    }\n  }\n}\nint main() {\n  int i, j;\n  scanf(\"%d %d %d\", &n, &k, &d);\n  if ((double)n > pow((double)k, d))\n    printf(\"-1\\n\");\n  else {\n    solve();\n    for (i = 0; i < d; i++) {\n      for (j = 0; j < n - 1; j++) {\n        printf(\"%d \", a[j][i] + 1);\n      }\n      printf(\"%d\\n\", a[j][i] + 1);\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.List;\n\n// atharva washimkar\n// May 19, 2018\n\npublic class CODEFORCES_459_C {\n\n\tstatic int N, K, D;\n\tstatic int done;\n\n\tpublic static void dfs (Node cur, int d) {\n\t\tif (done >= N || d == D - 1) {\n\t\t\t++done;\n\t\t}\n\t\telse {\n\t\t\tfor (int k = 0; k < K && done < N; ++k) {\n\t\t\t\tNode nxt = new Node (k);\n\t\t\t\tcur.list.add (nxt);\n\t\t\t\tdfs (nxt, d + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void printdfs (Node cur, int d, int[] seating) {\n\t\tseating[d] = cur.v + 1;\n\t\tint i = 0;\n\n\t\tfor (; i < cur.list.size (); ++i) {\n\t\t\tif (!cur.list.get (i).done) {\n\t\t\t\tprintdfs (cur.list.get (i), d + 1, seating);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcur.done = true;\n\n\t\tfor (int j = 0; j < cur.list.size (); ++j)\n\t\t\tcur.done &= cur.list.get (j).done;\n\t}\n\n\tpublic static void main (String[] t) throws IOException {\n\t\tINPUT in = new INPUT (System.in);\n\t\tPrintWriter out = new PrintWriter (System.out);\n\n\t\tN = in.iscan ();\n\t\tK = Math.min (in.iscan (), N);\n\t\tD = in.iscan ();\n\n\t\tNode[] nodes = new Node[K];\n\n\t\tfor (int k = 0; k < K; ++k) {\n\t\t\tnodes[k] = new Node (k);\n\t\t\tdfs (nodes[k], 0);\n\t\t}\n\n\t\tif (done < N) {\n\t\t\tout.print (-1);\n\t\t}\n\t\telse {\n\t\t\tint[][] seating = new int[N][D];\n\n\t\t\tfor (int n = 0, k = 0; n < N && k < K; ++n) {\n\t\t\t\tprintdfs (nodes[k], 0, seating[n]);\n\n\t\t\t\tif (nodes[k].done)\n\t\t\t\t\t++k;\n\t\t\t}\n\n\t\t\tfor (int d = 0; d < D; ++d) {\n\t\t\t\tfor (int n = 0; n < N; ++n)\n\t\t\t\t\tout.print (seating[n][d] + \" \");\n\n\t\t\t\tout.println ();\n\t\t\t}\n\t\t}\n\n\t\tout.close ();\n\t}\n\n\tprivate static class Node {\n\n\t\tint v;\n\t\tList<Node> list;\n\t\tboolean done;\n\n\t\tpublic Node (int v) {\n\t\t\tthis.v = v;\n\t\t\tthis.list = new ArrayList<Node> ();\n\t\t}\n\t}\n\n\tprivate static class INPUT {\n\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar, numChars;\n\n\t\tpublic INPUT (InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic INPUT (String file) throws IOException {\n\t\t\tthis.stream = new FileInputStream (file);\n\t\t}\n\n\t\tpublic int cscan () throws IOException {\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\tnumChars = stream.read (buf);\n\t\t\t}\n\n\t\t\tif (numChars == -1)\n\t\t\t\treturn numChars;\n\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int iscan () throws IOException {\n\t\t\tint c = cscan (), sgn = 1;\n\n\t\t\twhile (space (c))\n\t\t\t\tc = cscan ();\n\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = cscan ();\n\t\t\t}\n\n\t\t\tint res = 0;\n\n\t\t\tdo {\n\t\t\t\tres = (res << 1) + (res << 3);\n\t\t\t\tres += c - '0';\n\t\t\t\tc = cscan ();\n\t\t\t}\n\t\t\twhile (!space (c));\n\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic String sscan () throws IOException {\n\t\t\tint c = cscan ();\n\n\t\t\twhile (space (c))\n\t\t\t\tc = cscan ();\n\n\t\t\tStringBuilder res = new StringBuilder ();\n\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint (c);\n\t\t\t\tc = cscan ();\n\t\t\t}\n\t\t\twhile (!space (c));\n\n\t\t\treturn res.toString ();\n\t\t}\n\n\t\tpublic double dscan () throws IOException {\n\t\t\tint c = cscan (), sgn = 1;\n\n\t\t\twhile (space (c))\n\t\t\t\tc = cscan ();\n\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = cscan ();\n\t\t\t}\n\n\t\t\tdouble res = 0;\n\n\t\t\twhile (!space (c) && c != '.') {\n\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\treturn res * UTILITIES.fast_pow (10, iscan ());\n\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = cscan ();\n\t\t\t}\n\n\t\t\tif (c == '.') {\n\t\t\t\tc = cscan ();\n\t\t\t\tdouble m = 1;\n\n\t\t\t\twhile (!space (c)) {\n\t\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\t\treturn res * UTILITIES.fast_pow (10, iscan ());\n\n\t\t\t\t\tm /= 10;\n\t\t\t\t\tres += (c - '0') * m;\n\t\t\t\t\tc = cscan ();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic long lscan () throws IOException {\n\t\t\tint c = cscan (), sgn = 1;\n\n\t\t\twhile (space (c))\n\t\t\t\tc = cscan ();\n\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = cscan ();\n\t\t\t}\n\n\t\t\tlong res = 0;\n\n\t\t\tdo {\n\t\t\t\tres = (res << 1) + (res << 3);\n\t\t\t\tres += c - '0';\n\t\t\t\tc = cscan ();\n\t\t\t}\n\t\t\twhile (!space (c));\n\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic boolean space (int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\t}\n\n\tpublic static class UTILITIES {\n\n\t\tstatic final double EPS = 10e-6;\n\n\t\tpublic static int lower_bound (int[] arr, int x) {\n\t\t\tint low = 0, high = arr.length, mid = -1;\n\n\t\t\twhile (low < high) {\n\t\t\t\tmid = (low + high) / 2;\n\n\t\t\t\tif (arr[mid] >= x)\n\t\t\t\t\thigh = mid;\n\t\t\t\telse\n\t\t\t\t\tlow = mid + 1;\n\t\t\t}\n\n\t\t\treturn low;\n\t\t}\n\n\t\tpublic static int upper_bound (int[] arr, int x) {\n\t\t\tint low = 0, high = arr.length, mid = -1;\n\n\t\t\twhile (low < high) {\n\t\t\t\tmid = (low + high) / 2;\n\n\t\t\t\tif (arr[mid] > x)\n\t\t\t\t\thigh = mid;\n\t\t\t\telse\n\t\t\t\t\tlow = mid + 1;\n\t\t\t}\n\n\t\t\treturn low;\n\t\t}\n\n\t\tpublic static int gcd (int a, int b) {\n\t\t\treturn b == 0 ? a : gcd (b, a % b);\n\t\t}\n\n\t\tpublic static int lcm (int a, int b) {\n\t\t\treturn a * b / gcd (a, b);\n\t\t}\n\n\t\tpublic static int fast_pow_mod (int b, int x, int mod) {\n\t\t\tif (x == 0) return 1;\n\t\t\tif (x == 1) return b;\n\t\t\tif (x % 2 == 0) return fast_pow_mod (b * b % mod, x / 2, mod) % mod;\n\n\t\t\treturn b * fast_pow_mod (b * b % mod, x / 2, mod) % mod;\n\t\t}\n\n\t\tpublic static int fast_pow (int b, int x) {\n\t\t\tif (x == 0) return 1;\n\t\t\tif (x == 1) return b;\n\t\t\tif (x % 2 == 0) return fast_pow (b * b, x / 2);\n\n\t\t\treturn b * fast_pow (b * b, x / 2);\n\t\t}\n\n\t\tpublic static long choose (long n, long k) {\n\t\t\tk = Math.min (k, n - k);\n\t\t\tlong val = 1;\n\n\t\t\tfor (int i = 0; i < k; ++i)\n\t\t\t\tval = val * (n - i) / (i + 1);\n\n\t\t\treturn val;\n\t\t}\n\n\t\tpublic static long permute (int n, int k) {\n\t\t\tif (n < k) return 0;\n\t\t\tlong val = 1;\n\n\t\t\tfor (int i = 0; i < k; ++i)\n\t\t\t\tval = (val * (n - i));\n\n\t\t\treturn val;\n\t\t}\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.Map.Entry;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.Stack;\nimport java.util.TreeSet;\n\npublic class Main\n{\n\tpublic void foo()\n\t{\n\t\tMyScanner scan = new MyScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n = scan.nextInt();\n\t\tint k = scan.nextInt();\n\t\tint d = scan.nextInt();\n\t\tif(Math.pow((double)n, 1.0 / d) > k)\n\t\t{\n\t\t\tout.println(-1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint[][] map = new int[d][n];\n\t\t\tfor(int i = 0;i < n;++i)\n\t\t\t{\n\t\t\t\tint tmp = i;\n\t\t\t\tint j = 0;\n\t\t\t\twhile(tmp > 0)\n\t\t\t\t{\n\t\t\t\t\tmap[j++][i] = tmp % k;\n\t\t\t\t\ttmp /= k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i < d;++i)\n\t\t\t{\n\t\t\t\tfor(int j = 0;j < n;++j)\n\t\t\t\t{\n\t\t\t\t\tout.print((map[i][j] + 1) + \" \");\n\t\t\t\t}\n\t\t\t\tout.println();\n\t\t\t}\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args)\n\t{\n\t\tnew Main().foo();\n\t}\n\t\n\tclass MyScanner\n\t{\n\t    private byte[] buf = new byte[1024];\n\t    private int curChar;\n\t    private int numChars;\n\t    BufferedInputStream bis = new BufferedInputStream(System.in);\n\n\t    public int read() \n\t    {\n\t        if (-1 == numChars)\n\t        {\n\t        \tthrow new InputMismatchException();\n\t        }\n\t        if (curChar >= numChars)\n\t        {\n\t            curChar = 0;\n\t            try \n\t            {\n\t                numChars = bis.read(buf);\n\t            }\n\t            catch (IOException e)\n\t            {\n\t                throw new InputMismatchException();\n\t            }\n\t            if (numChars <= 0)\n\t            {\n\t            \treturn -1;\n\t            }\n\t        }\n\t        return buf[curChar++];\n\t    }\n\n\t    public int nextInt() \n\t    {\n\t        int c = read();\n\t        while (isSpaceChar(c))\n\t        {\n\t        \tc = read();\n\t        }\n\t        int sgn = 1;\n\t        if (c == '-') \n\t        {\n\t            sgn = -1;\n\t            c = read();\n\t        }\n\t        int res = 0;\n\t        do \n\t        {\n\t            if (c < '0' || c > '9')\n\t            {\n\t            \tthrow new InputMismatchException();\n\t            }\n\t            res *= 10;\n\t            res += c - '0';\n\t            c = read();\n\t        } while (!isSpaceChar(c));\n\t        return res * sgn;\n\t    }\n\t    \n\t    public long nextLong() \n\t    {\n\t    \tint c = read();\n\t    \twhile (isSpaceChar(c))\n\t    \t{\n\t    \t\tc = read();\n\t    \t}\n\t    \tint sgn = 1;\n\t    \tif (c == '-') \n\t    \t{\n\t    \t\tsgn = -1;\n\t    \t\tc = read();\n\t    \t}\n\t    \tlong res = 0;\n\t    \tdo \n\t    \t{\n\t    \t\tif (c < '0' || c > '9')\n\t    \t\t{\n\t    \t\t\tthrow new InputMismatchException();\n\t    \t\t}\n\t    \t\tres *= 10;\n\t    \t\tres += c - '0';\n\t    \t\tc = read();\n\t    \t} while (!isSpaceChar(c));\n\t    \treturn res * sgn;\n\t    }\n\t    \n\t    public String next()\n\t    {\n\t        int c = read();\n\t        while (isSpaceChar(c))\n\t        {\n\t        \tc = read();\n\t        }\n\t        StringBuilder res = new StringBuilder();\n\t        do \n\t        {\n\t            res.appendCodePoint(c);\n\t            c = read();\n\t        } while (!isSpaceChar(c));\n\t        return res.toString();\n\t    }\n\n\t    private boolean isSpaceChar(int c) \n\t    {\n\t        return ' ' == c || '\\n' == c || '\\r' == c || '\\t' == c || -1 == c;\n\t    }\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 1010;\nlong long n, k, d;\nlong long cnt;\nlong long seq[N];\nlong long ans[N][N];\nvoid solve(long long day) {\n  if (!day) {\n    if (cnt == n) return;\n    cnt++;\n    for (int i = d; i > day; --i) ans[cnt][i] = seq[i];\n    return;\n  }\n  for (int i = 1; i <= k; ++i) {\n    if (cnt == n) return;\n    seq[day] = i;\n    solve(day - 1);\n  }\n}\nint main() {\n  cin >> n >> k >> d;\n  bool chk = true;\n  long long x = 1;\n  for (int i = 0; i < d; ++i) {\n    x *= k;\n    if (x >= n) {\n      chk = false;\n      break;\n    }\n  }\n  if (chk) {\n    cout << -1 << \"\\n\";\n    return 0;\n  }\n  solve(d);\n  for (int i = 1; i <= d; ++i) {\n    for (int j = 1; j <= n; ++j) cout << ans[j][i] << \" \";\n    cout << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Cf459C {\n\n    private int n, k, d;\n    private int [][]ans;\n    private FastScanner scanner;\n\n    public static void main(String args[]) {\n        Cf459C cf = new Cf459C();\n        if (cf.run())\n            cf.print();\n        else\n            System.out.println(\"-1\");\n    }\n\n    Cf459C() {\n        scanner = new FastScanner();\n        n = scanner.nextInt();\n        k = scanner.nextInt();\n        d = scanner.nextInt();\n    }\n\n    public boolean run() {\n        if (Math.pow(k, d) < n)\n            return false;\n        ans = new int[d][n];\n        for (int i = 0; i < n; ++i) {\n            int s = i;\n            for (int j = 0; j < d; ++j) {\n                ans[j][i] = (s % k) + 1;\n                s /= k;\n            }\n        }\n        return true;\n    }\n\n    public void print() {\n        for (int i = 0; i < d; ++i) {\n            StringBuilder builder = new StringBuilder();\n            builder.append(ans[i][0]);\n            for (int j = 1; j < n; ++j) {\n                builder.append(' ');\n                builder.append(ans[i][j]);\n            }\n            System.out.println(builder.toString());\n        }\n    }\npublic class FastScanner {\n    BufferedReader br;\n    StringTokenizer st;\n\n    FastScanner() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    String next() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint ans[1001][1001];\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, d, k;\n  cin >> n >> k >> d;\n  long long int temp = 1;\n  bool flag = false;\n  for (int i = 0; i < d; i++) {\n    temp *= k;\n    if (temp >= n) {\n      flag = true;\n      break;\n    }\n  }\n  if (!flag) {\n    cout << -1 << endl;\n    return 0;\n  }\n  for (int i = 1; i < n; i++) {\n    for (int j = 0; j < d; j++) ans[i][j] = ans[i - 1][j];\n    for (int j = d - 1; j >= 0; j--) {\n      ans[i][j] = (ans[i][j] + 1) % k;\n      if (ans[i][j]) break;\n    }\n  }\n  for (int i = 0; i < d; i++, cout << endl)\n    for (int j = 0; j < n; j++) cout << ans[j][i] + 1 << ' ';\n}\n"
        },
        {
            "language": 3,
            "solution": "n,k,d=map(int,input().split())\nif n>k**d:print(-1);exit()\nK=1\nfor j in range(d):\n    print(\" \".join([str(i//K%k +1) for i in range(n)]));K*=k"
        },
        {
            "language": 3,
            "solution": "n, k, d = list( map( int, input().split() ) )\n\nans = []\n\nfor i in range(d):\n    tmp = [0]*n\n    ans.append( tmp )\n\ntmp = []\n\ndef add( val ):\n    pos = d-1\n    while pos >= 0:\n        #print(tmp,val,pos)\n        tmp[pos] += val\n        if tmp[pos] == k:\n            tmp[pos] = 0\n            val = 1\n        elif tmp[pos] > k:\n            val = tmp[pos]-k\n            tmp[pos] %= k\n        else:\n            val = 0\n            break\n        pos -= 1\n\ndef fill( col ):\n\n    cnt = 0\n    for i in tmp:\n        ans[cnt][col] = i\n        #print( ans )\n        cnt += 1\n\nif k ** d < n:\n    print( \"-1\" )\nelse:\n\n    tmp = [0]*(d)\n\n    for i in range(n):\n        #for j in tmp:\n        #    print( j+1, end=' ' )\n        #print()\n        fill(i)\n        add(1)\n\n    for i in ans:\n        for j in i:\n            print( j+1, end=' ' )\n        print()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid solve();\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed;\n  cout.precision(12);\n  solve();\n  return 0;\n}\ntemplate <typename T>\nvoid sc(T& x) {\n  cin >> x;\n}\ntemplate <typename Head, typename... Tail>\nvoid sc(Head& head, Tail&... tail) {\n  cin >> head;\n  sc(tail...);\n}\ntemplate <typename T>\nvoid pr(const T& x) {\n  cout << x << '\\n';\n}\ntemplate <typename Head, typename... Tail>\nvoid pr(const Head& head, const Tail&... tail) {\n  cout << head << ' ';\n  pr(tail...);\n}\nbool can(int n, int k, int d) {\n  if (k == 1 && n > 1) {\n    return false;\n  }\n  int need = 0;\n  n = (n + k - 1) / k;\n  while (n > 1) {\n    need++;\n    n = (n + k - 1) / k;\n  }\n  return (need + 1 <= d);\n}\nvoid solve() {\n  int n, k, d;\n  sc(n, k, d);\n  if (!can(n, k, d)) {\n    pr(-1);\n    return;\n  }\n  int jump = 1;\n  while (d--) {\n    vector<int> cur(n, -1);\n    for (int j = 0; j < n; j++) {\n      if (cur[j] == -1) {\n        int step = 0;\n        for (int x = j; x < n; x += jump) {\n          cur[x] = step + 1;\n          step++;\n          step %= k;\n        }\n      }\n    }\n    jump = min(1LL * n, 1LL * k * jump);\n    for (int __ii = 0; __ii < ((int)cur.size()); __ii++) {\n      if (__ii) cout << ' ';\n      cout << cur[__ii];\n    }\n    cout << '\\n';\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.util.Scanner;\n\npublic class C {\n    static int n,k,d;\n    public static void main(String[] args) {\n        \n        Scanner cin = new Scanner(System.in);\n        n = cin.nextInt();\n        k = cin.nextInt();\n        d = cin.nextInt();\n        boolean ok = false;\n        \n        int i, j, p;\n        int pre = 0;\n        if((d==1 && n>k) || k == 1){\n            ok = false;\n        }\n        else if (check(n,k,d)) {\n            ok = true;\n        } else {\n            ok = false;\n        }\n        if(n==1) ok = true;\n        if (ok) {\n            /*\n             * java \u8f93\u51fa\u6d41\u592a\u6162\u4e86\u3002\u4e00\u76f4WA\n             * \u6362\u6210String\u8fd8\u662f\u4e0d\u884c\u3002\n             * \u6362\u6210StringBuilder\n             */\n            for (i = 0; i < d ; i++) {\n                StringBuilder str = new StringBuilder();\n                for (j = 0; j < n; j++) {\n                    str.append(((j / pow(i, k)) % k) + 1).append(\" \");\n                }\n                System.out.println(str.toString());\n            }\n            \n        }\n        else\n            System.out.println(-1);\n    }\n    public static int pow(int x,int k){\n        if(k>1000) return 1;\n        int ans = 1;\n        while(x-- >0 ){\n            if(ans < 1000)ans = ans*k;\n            else return 1000;\n        }\n        return ans;\n    }\n    public static boolean check(int n,int k,int d){\n        int ans = 1;\n        if(k>n) return true;\n        while(d-->0){\n            ans *= k;\n            if(ans >= n) return true;\n        }\n        return false;\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class code\n{\n\tstatic class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n\n    public static void main(String args[])throws IOException\n\t{\n        FastReader scn = new FastReader();\n        \n        long n = scn.nextLong();\n        long k = scn.nextLong();\n        long d = scn.nextLong();\n\n        long pow = 1L;\n        int i;\n        for(i = 1; i <= d; i++)\n        {\n            pow = pow * k;\n            if(pow >= n)\n                break;\n        }\n\n        if( i == d + 1)\n        {\n            System.out.println(-1);\n            return;\n        }\n\n        OutputStream out = new BufferedOutputStream( System.out );\n\n        long cycle_length = 1;\n        for(i = 1; i <= d; i++)\n        {\n            long counter = 0;\n            while(counter < n)\n            {\n                long temp = ((counter/cycle_length)%k) + 1;\n                out.write((temp + \" \").getBytes());\n                counter++;\n            }\n            out.write(\"\\n\".getBytes());\n            cycle_length = Math.min(cycle_length*k, n);\n            //cycle_length = cycle_length*k;\n        }\n        out.flush();\n\t}  \n\n    public static long inverseModulo(long a, long P)\n    {\n        return powerModulo(a, P-2, P);\n    }\n\n    public static long powerModulo(long a, long p, long m)\n    {   \n        if(p==0)\n            return 1;\n\n        long temp = powerModulo(a, p/2, m);\n        temp = (temp * temp)%m;\n        if(p%2 == 0)\n            return temp;\n        else\n            return (a * temp)%m;\n\n    }\n}\n\n\nclass Node implements Comparable<Node>\n{\n    int index;\n    int degree;\n    int xor_value;\n\n    public Node(int index, int degree, int xor_value)\n    {\n        this.index = index;\n        this.degree = degree;\n        this.xor_value = xor_value;\n    }\n\n    public int compareTo(Node n)\n    {\n        if(this.degree < n.degree)\n            return -1;\n        else if(this.degree == n.degree)\n            return 0;\n        else return 1;\n    }\n}"
        },
        {
            "language": 3,
            "solution": "n,k,d = [int(x) for x in input().split()]\n\nif n <= k:\n    comb = [str(x+1) for x in range(n)]\n    for x in range(d):\n        print(' '.join(comb))\nelif k == 1:\n    print(-1)\nelse:\n    base = k\n    exp = d\n\n    if pow(base,exp) >= n:\n        total = 1\n        while total < n:\n            total *= base\n        count = 0\n        while total > 0:\n            total = total//base\n            if total == 0:\n                break\n            count += 1\n            out = []\n\n            for y in range(n):\n                out.append((y//total)%base)\n            print(' '.join([str(z+1) for z in out]))\n        for x in range(d-count):\n            print(' '.join(['1' for x in range(n)]))\n    else:\n        print(-1)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MAXN = 1e5 + 5;\nconst int MOD = 1e9 + 7;\nusing namespace std;\nbool great(long long int n, long long int k, long long int d) {\n  long long int ans = 1;\n  for (int i = 1; i <= d; i++) {\n    ans = ans * k;\n    if (ans >= n) return false;\n  }\n  return true;\n}\nbool kPoweredIMinusOneIsGreaterThanOrEqualToN(long long int base,\n                                              long long int power,\n                                              long long int x) {\n  long long int ans = 1;\n  for (int i = 1; i <= power; i++) {\n    ans = (ans * base);\n    if (ans >= x) {\n      return true;\n    }\n  }\n  return false;\n}\nlong long int power(long long int base, long long int power) {\n  long long int ans = 1;\n  for (int i = 1; i <= power; i++) {\n    ans = (ans * base);\n  }\n  return ans;\n}\nint main() {\n  long long int n, k, d;\n  cin >> n >> k >> d;\n  if (great(n, k, d)) {\n    cout << -1 << '\\n';\n  } else {\n    for (int i = 1; i <= d; i++) {\n      int ptr = 0;\n      if (i == 1) {\n        for (int j = 1; j <= n; j++) {\n          cout << ptr + 1 << ' ';\n          ptr = (ptr + 1) % k;\n        }\n      } else {\n        if (kPoweredIMinusOneIsGreaterThanOrEqualToN(k, i - 1, n)) {\n          for (int j = 1; j <= n; j++) {\n            cout << 1 << ' ';\n          }\n        } else {\n          long long int ans = power(k, i - 1);\n          int ptr = 0;\n          for (long long int j = 1; j <= n; j++) {\n            cout << ptr + 1 << ' ';\n            if (j % ans == 0) {\n              ptr = (ptr + 1) % k;\n            }\n          }\n        }\n      }\n      cout << '\\n';\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstring to_string(string s) { return \"\\\"\" + s + \"\\\"\"; }\ntemplate <typename T>\nstring to_string(vector<T>);\ntemplate <typename U, typename V>\nstring to_string(pair<U, V> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename T>\nstring to_string(vector<T> v) {\n  string r = \"[\";\n  for (int i = 0; i < (int)v.size() - 1; i++) r += to_string(v[i]) + \", \";\n  if (!v.empty()) r += to_string(v.back());\n  return r + \"]\";\n}\nconst int N = 1010;\nint n, k, d, f[N][N];\nbool can() {\n  if (k >= n) return true;\n  int x = k, y = d - 1;\n  while (y--) {\n    x *= k;\n    if (x >= n) return true;\n  }\n  return false;\n}\nvoid fill(int s) {\n  if (f[0][s - 1] < k - 1) {\n    f[0][s] = f[0][s - 1] + 1;\n    for (int i = 1; i < d; i++) f[i][s] = f[i][s - 1];\n  } else {\n    int z = 0;\n    while (f[z][s - 1] == k - 1) z++;\n    for (int i = 0; i < z; i++) f[i][s] = 0;\n    f[z][s] = f[z][s - 1] + 1;\n    for (int i = z + 1; i < d; i++) f[i][s] = f[i][s - 1];\n  }\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &d);\n  if (can()) {\n    for (int i = 0; i < d; i++) f[i][0] = 0;\n    for (int i = 1; i < n; i++) fill(i);\n    for (int i = 0; i < d; i++) {\n      for (int j = 0; j < n; j++) printf(\"%d \", f[i][j] + 1);\n      printf(\"\\n\");\n    }\n  } else\n    printf(\"-1\\n\");\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\t\n\tpublic static void main(String args[]){\n\t\tInputReader in = new InputReader(System.in);\n\t\tOutputStream outputStream = System.out;\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tint n=in.nextInt();\n\t\tint k=in.nextInt();\n\t\tint d=in.nextInt();\n\t\tint no=(int)Math.ceil((double)n/k);\n\t\tif(n>Math.pow(k,d)){\n\t\t\tout.println(\"-1\");\n\t\t\tout.close();\n\t\t\treturn;\n\t\t}\n\t\tint a[][]=new int[n][d];\n\t\tint copy=n;\n\t\tfor(int ii=0;ii<n;ii++){\n\t\t\tcopy=ii;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\ta[ii][d-i-1]=(copy)%k;\n\t\t\t\tcopy/=k;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<d;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tout.print((a[j][i]+1)+\" \");\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t\t//==============================================\n\t\tout.close();\n\t}\n\t\n\tstatic class InputReader {\n\t    public BufferedReader reader;\n\t    public StringTokenizer tokenizer;\n\n\t    public InputReader(InputStream inputstream) {\n\t      reader = new BufferedReader(new InputStreamReader(inputstream));\n\t      tokenizer = null;\n\t    }\n\t    \n\t    public String nextLine(){\n\t    \tString fullLine=null;\n\t    \twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t            try {\n\t              fullLine=reader.readLine();\n\t            } catch (IOException e) {\n\t              throw new RuntimeException(e);\n\t            }\n\t            return fullLine;\n\t          }\n\t          return fullLine;\n\t    }\n\t\tpublic String next() {\n\t      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t        try {\n\t          tokenizer = new StringTokenizer(reader.readLine());\n\t        } catch (IOException e) {\n\t          throw new RuntimeException(e);\n\t        }\n\t      }\n\t      return tokenizer.nextToken();\n\t    }\n\t\tpublic long nextLong() {\n\t\t      return Long.parseLong(next());\n\t\t    }\n\t    public int nextInt() {\n\t      return Integer.parseInt(next());\n\t    }\n\t  }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1 * 1000 + 10;\nint ans[MAXN][MAXN];\nint main() {\n  ios::sync_with_stdio(false);\n  int n, d, k;\n  cin >> n >> k >> d;\n  long long tmp = 1;\n  bool check = false;\n  for (int i = 0; i < d; i++) {\n    tmp *= k;\n    if (tmp >= n) {\n      check = true;\n      break;\n    }\n  }\n  if (!check) {\n    cout << -1 << endl;\n    return 0;\n  }\n  for (int i = 1; i < n; i++) {\n    for (int j = 0; j < d; j++) ans[i][j] = ans[i - 1][j];\n    for (int j = d - 1; j >= 0; j--) {\n      ans[i][j] = (ans[i][j] + 1) % k;\n      if (ans[i][j]) break;\n    }\n  }\n  for (int i = 0; i < d; i++, cout << endl)\n    for (int j = 0; j < n; j++) cout << ans[j][i] + 1 << ' ';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k, d, ans = 1, f[2000];\nint main() {\n  cin >> n >> k >> d;\n  for (int i = 1; i <= d && ans < n; i++) ans = ans * k;\n  if (ans < n)\n    puts(\"-1\");\n  else {\n    for (int i = 1; i <= n; i++) f[i] = i;\n    for (int i = 1; i <= d; i++) {\n      for (int j = 1; j <= n; j++) {\n        cout << f[j] % k + 1;\n        if (j == n)\n          puts(\"\");\n        else\n          cout << ' ';\n        f[j] /= k;\n      }\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\nimport java.lang.*;\nimport java.util.stream.*;\n\n/**\n * @author Pradyumn\n */\n\npublic class Main implements Runnable{\n\tpublic int TC = 0;\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \":)\", 1L << 26).start();\n\t}\n\t@SuppressWarnings(\"Unchecked\")\n\tpublic void solve() throws IOException {\n\t\tint n = ni(),k = ni(),d = ni();\n\t\tif(d == 1) {\n\t\t\tif(n > k) {\n\t\t\t\tout.println(-1);\n\t\t\t} else {\n\t\t\t\tfor(int i = 1;i <= n; ++i) {\n\t\t\t\t\tout.print(i + \" \");\n\t\t\t\t}\n\t\t\t\tout.println();\n\t\t\t}\n\t\t} else {\n\t\t\tint[][] ans = new int[n][d];\n\t\t\tif(k >= n) {\n\t\t\t\tfor(int i = 0;i < n; ++i) {\n\t\t\t\t\tArrays.fill(ans[i], i + 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(k == 1) {\n\t\t\t\t\tif(n > 1) {\n\t\t\t\t\t\tout.println(-1);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tArrays.fill(ans[0], 1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tArrays.fill(ans[0], 1);\n\t\t\t\t\tfor (int i = 1;i < n; ++i) {\n\t\t\t\t\t\tif(next_perm(ans[i - 1], ans[i], k) == false) {\n\t\t\t\t\t\t\tout.println(-1);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i < d; ++i) {\n\t\t\t\tfor(int j = 0;j < n; ++j) {\n\t\t\t\t\tif(j != 0) out.print(\" \");\n\t\t\t\t\tout.print(ans[j][i]);\n\t\t\t\t}\n\t\t\t\tout.println();\n\t\t\t}\n\t\t}\n\t}\n\tpublic static boolean next_perm(int end[],int start[],int k){\n\t\tint n = end.length;\n\t\tboolean found = false;\n\t\t\n\t\tfor(int i = n - 1;i >= 0; --i) {\n\t\t\tif(found) {\n\t\t\t\tstart[i] = end[i];\n\t\t\t} else {\n\t\t\t\tif(end[i] != k) {\n\t\t\t\t\tstart[i] = end[i] + 1;\n\t\t\t\t\tfound = true;\n\t\t\t\t} else {\n\t\t\t\t\tstart[i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn found;\n\t}\n\tBufferedReader br;\n\tStringTokenizer st;\n\tPrintWriter out;\n\tpublic void run() {\n\t\ttry {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in),32768);\n\t\t\tst = null;\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tif(TC == 1) {\n\t\t\t\tfor(int T = ni();T > 0; --T) {\n\t\t\t\t\tsolve();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsolve();\n\t\t\t}\n\t\t\tbr.close();\n\t\t\tout.close();\n\t\t} catch(IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\tpublic char[] ns(int n) throws IOException {\n\t\treturn ns().toCharArray();\n\t}\n\tpublic char[][] nm(int n, int m) throws IOException {\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n; ++i) {\n\t\t\tmap[i] = ns(m);\n\t\t}\n\t\treturn map;\n\t}\n\tpublic String ns() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\tpublic String nextLine() throws IOException {\n\t\treturn br.readLine();\n\t}\n\tpublic int ni() throws IOException {\n\t\treturn Integer.parseInt(ns());\n\t}\n\n\tpublic int[] na(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n; ++i) a[i] = ni();\n\t\treturn a;\n\t}\n\n\tpublic long nl() throws IOException {\n\t\treturn Long.parseLong(ns());\n\t}\n\n\tpublic long[] nal(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor(int i = 0;i < n; ++i) a[i] = nl();\n\t\treturn a;\n\t}\n\n\tpublic double nd() throws IOException {\n\t\treturn Double.parseDouble(ns());\n\t}\n\tprivate static boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate static void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); } \n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double eps = 1e-14;\nconst int maxn = 1E3 + 10;\nint n, k, d;\nint ans[maxn][maxn], arr[maxn];\nint cnt = 0;\nbool judge() {\n  long long tot = 1;\n  for (int i = 0; i < d; i++) {\n    tot *= k;\n    if (tot >= n) return 1;\n  }\n  return 0;\n}\nvoid solve(int u) {\n  if (d == u) {\n    memcpy(ans[cnt++], arr, sizeof arr);\n    return;\n  }\n  int& i = arr[u];\n  for (i = 1; i <= k; i++) {\n    solve(u + 1);\n    if (cnt == n) return;\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> k >> d;\n  if (!judge()) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n  solve(0);\n  for (int i = 0; i < d; i++) {\n    cout << ans[0][i];\n    for (int j = 1; j < n; j++) {\n      cout << \" \" << ans[j][i];\n    }\n    cout << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "# -*- coding: utf-8 -*-\n\nimport math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport random\nimport itertools\nimport sys\nfrom typing import List\n\n\"\"\"\ncreated by shhuan at 2020/1/8 21:47\n\n\"\"\"\n\n\ndef bit(val, n, l):\n    x = []\n    while val > 0:\n        x.append(val % n)\n        val //= n\n    return [0] * (l - len(x)) + x[::-1]\n\n\ndef solve(N, K, D):\n    if math.log(N, K) > D or K ** D < N:\n        print(-1)\n        return\n    a = []\n    for i in range(N):\n        x = bit(i, K, D)\n        a.append(x)\n    ans = []\n    for d in range(D):\n        ans.append(' '.join(map(str, [a[i][d] + 1 for i in range(N)])))\n\n    print('\\n'.join(ans))\n\n\nN, K, D = map(int, input().split())\nsolve(N, K, D)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1010;\nint ans[MAXN][MAXN];\nint N, D, K;\nint main(void) {\n  scanf(\"%d%d%d\", &N, &K, &D);\n  if (N > 1 && K == 1) {\n    printf(\"-1\\n\");\n    return 0;\n  }\n  int rep = 1;\n  bool possible = false;\n  for (int i = 0; i < D; ++i) {\n    int curr = 0;\n    int pos = 0;\n    bool ok = true;\n    while (pos < N) {\n      for (int j = 0; pos < N && j < rep; ++j) {\n        ans[i][pos++] = curr + 1;\n      }\n      ++curr;\n      if (curr == K) {\n        if (pos < N) ok = false;\n        curr = 0;\n      }\n    }\n    if (rep >= N || rep * K >= N) ok = true;\n    possible |= ok;\n    if (rep >= N || rep * K >= N)\n      rep = N;\n    else\n      rep *= K;\n  }\n  if (!possible) {\n    printf(\"-1\\n\");\n  } else {\n    for (int i = 0; i < D; ++i) {\n      for (int j = 0; j < N; ++j) printf(\"%d%c\", ans[i][j], \" \\n\"[j + 1 == N]);\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\n\npublic class hals {\n\t\n\tpublic static void main(String[] args)throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] in = br.readLine().split(\" \");\n\t\tint n = Integer.parseInt(in[0]);\n\t\tint k = Integer.parseInt(in[1]);\n\t\tint d = Integer.parseInt(in[2]);\n\t\tint temp = 1;\n\t\tboolean flag = false;\n\t\tfor(int i=0;i<d;i++){\n\t\t\ttemp*=k;\n\t\t\tif(temp>=n){\n\t\t\t\tflag=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag)\n\t\t\tSystem.out.println(\"-1\");\n\t\telse{\n\t\t\tint[][] arr = new int[n][d];\n\t\t\tfor(int i=0;i<d;i++)\n\t\t\t\tarr[0][i]=1;\n\t\t\tfor(int i=1;i<n;i++){\n\t\t\t\tfor(int j=0;j<d;j++)\n\t\t\t\t\tarr[i][j]=arr[i-1][j];\n\t\t\t\tfor(int j=d-1;j>=0;j--){\n\t\t\t\t\tarr[i][j]++;\n\t\t\t\t\tarr[i][j]%=k;\n\t\t\t\t\tif(arr[i][j]!=0)break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tStringBuilder s = new StringBuilder();\n\t\t\tfor(int j=0;j<d;j++){\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(arr[i][j]==0)\n\t\t\t\t\t\ts.append(k+\" \");\n\t\t\t\t\telse\n\t\t\t\t\t\ts.append(arr[i][j]+\" \");\n\t\t\t\t}\n\t\t\t\ts.append(\"\\n\");\n\t\t\t}\n\t\t\tSystem.out.println(s);\n\t\t}\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class Pasha_And_Busese {\n    public static int student[][];\n\n    public static void main(String[] args) {\n        // TODO Auto-generated method stub\n        Scanner input = new Scanner(System.in);\n        int n = input.nextInt();\n        int k = input.nextInt();\n        int d = input.nextInt();\n        student = new int[d][n];\n        int counter = 1;\n        Random rand = new Random();\n        int repeat = 0;\n        if (Math.pow(k, d) < n) {\n            System.out.println(-1);\n\n        } else {\n            if(k>=n){\n                for (int i = 0; i < d; i++) {\n                    if(i!=d-1){\n                        for (int j = 0; j < n; j++) {\n                            student[i][j] = 1;\n                        }\n                    }\n                    else{\n                        int y=1;\n                        for (int j = 0; j < n; j++) {\n                            student[i][j] = y;\n                            y++;\n                        }\n                    }\n                }\n                 for (int[] arr : student) {\n\n                       System.out.println(Arrays.toString(arr).replace(\",\", \"\").replace(\"[\", \"\") .replace(\"]\", \"\").trim() );\n                    }\n                 return;\n            }\n            else{\n                for(int i =0 ; i <d ; i++){\n                    int j=0;\n                    while(j!=n){\n                        for(int m=1;( m<=k && (j!=n)) ;m++){\n                            for(int u=0 ;( u<Math.pow(k, i) && (j!=n)) ;u++){\n                                student[i][j]=m;\n                                j++;\n                            }\n                            }\n                            \n                        }\n                    }\n                }\n        \n                for (int[] arr : student) {\n\n                   System.out.println(Arrays.toString(arr).replace(\",\", \"\").replace(\"[\", \"\") .replace(\"]\", \"\").trim() );\n                }\n        }\n    }\n    \n\n    \n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Input in = new Input(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task solver = new Task();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass Task {\n    static int ans[][];\n    static int nStudent;\n    static int nBus;\n    static int nDay;\n\n    public void solve(int testNumber, Input in, PrintWriter out) {\n        nStudent = in.nextInt();\n        nBus = in.nextInt();\n        nDay = in.nextInt();\n\n        ans = new int[nDay][nStudent];\n\n        int cur = 1;\n        boolean enough = false;\n        for (int i = 0; i <= nDay; ++i) {\n            if (cur >= nStudent) {\n                enough = true;\n                break;\n            }\n            cur *= nBus;\n        }\n        if (!enough) {\n            out.println(-1);\n            return;\n        }\n\n        for (int j = 0; j < nStudent; ++j) {\n            int val = j;\n            for (int i = 0; i < nDay; i++) {\n                ans[i][j] = (val % nBus) + 1;\n                val /= nBus;\n            }\n        }\n        for (int i = 0; i < nDay; ++i) {\n            for (int j = 0; j < nStudent; ++j) {\n                out.print(ans[i][j] + \" \");\n            }\n            out.println();\n        }\n    }\n}\n\nclass Input {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public Input(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n}"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\n\n\n\n\n\npublic class JavaApplication7 {\n    static boolean is(int n , int k , int d)\n    {\n    for(int i = 0 ; i < d ; i++)\n    {\n    int x = n /k ;\n    if(n % k != 0)\n        x++;\n    if(x <= 1 ) return true ;\n    n = x ;\n    \n    }\n    return false ;\n    }\n    \n    \n      static int isi(int n , int k , int d)\n    {\n    for(int i = 0 ; i < d ; i++)\n    {\n    int x = n /k ;\n    if(n % k != 0)\n        x++;\n    if(x <= 1 ) return i +1 ;\n    n = x ;\n    \n    }\n    return -1 ;\n    }\n    static Queue<Integer> qu = new LinkedList<Integer>() ; \n    static void doit(int n , int k)\n    {\n     int x = n / k ;\n     int y = n % k ;\n      boolean flag = false ;\n      for(int i = 0 ; i < k ; i++)\n          if(y >= 1)\n          {qu.add(x+1 ); y--;}\n          else \n          { qu.add(x) ; flag = true ;}\n      if(flag)\n      qu.add(-1) ;\n    \n    }\n    \n    public static void main(String[] args) throws Exception\n    {\n      Reader.init(System.in);\n      int n = Reader.nextInt(),k = Reader.nextInt(),d = Reader.nextInt() ;\n      if(k > n)\n          k = n ;\n      StringBuilder st = new StringBuilder() ;\n      int p = isi(n,k,d);\n      if(is(n,k,d))\n      {\n       \n       doit( n,  k) ;\n       int w = qu.poll() ;\n       int j = 0 ;\n       int sum = 0 ;\n       int l = 0 ;\n      \n       while(l != p)\n       { sum += w; \n        if(w == -1)\n        {    j = 0 ;\n        sum++;\n        }\n        else j++ ;\n        for(int i = 0 ; i < w ; i++)\n            st.append(j + \" \") ;\n       if(sum == n)\n       {    st.append(\"\\n\") ;\n            sum = 0;\n            \n            l++;\n       }\n           \n       if(w > 0)\n       doit(w , k) ;\n           \n       w = qu.poll() ;\n       \n           \n       }\n       for(int q = p ; q < d ; q++)\n       {    \n           for(int i = 0 ; i < n ; i++)\n               st.append(\"1 \") ;\n       st.append(\"\\n\") ;\n       }\n       System.out.print(st);\n          \n       \n      }else System.out.println(\"-1\");\n      \n    }\n          \n             \n    \n    \n    \n}\n        \n    \n    \n    class pair implements Comparable<pair>\n    {\n     long  i,j; \n     double d ; \n    pair( long  b  , long x)\n    {\n   \n    \n    \n    i = b ;\n    j = x ;\n  \n    }\n    @Override\n    public int compareTo(pair t) {\n        if(t.d < d)\n            return 1 ;\n        else if(t.d > d) return -1 ;\n        else return 0 ;\n    }\n    \n    \n    \n    }\n    \n   \n    \nclass Reader {\n    static BufferedReader reader;\n    static StringTokenizer tokenizer;\n\n    \n    static void init(InputStream input) {\n        reader = new BufferedReader(\n                     new InputStreamReader(input) );\n        tokenizer = new StringTokenizer(\"\");\n    }\n\n   \n    static String next() throws IOException {\n        while ( ! tokenizer.hasMoreTokens() ) {\n            \n            tokenizer = new StringTokenizer(\n                   reader.readLine() );\n        }\n        return tokenizer.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return Integer.parseInt( next() );\n    }\n\t\n    static double nextDouble() throws IOException {\n        return Double.parseDouble( next() );\n    }\n    static long nextLong() throws IOException{\n    return Long.parseLong(next()) ;\n    }\n}\n\n\n\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class C {\n  int fp[];\n  int k;\n  private void solve() throws IOException {\n    int n = ni();\n    k = ni();\n    int d = ni();\n    if (k < n) {\n      int i = d;\n      int c = k;\n      while (i > 1 && c < n) {\n        c *= k;\n        i--;\n      }\n      if (c < n) {\n        prln(-1);\n        return;\n      }\n    }\n\n    fp = new int[d + 1];\n    Arrays.fill(fp, 1);\n    fp[d] = 0;\n\n    int res[][] = new int[d][n];\n    for (int j = 0; j < n; ++j) {\n      nextPerm();\n      for (int i = 0; i < d; ++i) {\n        res[i][j] = fp[i + 1];\n      }\n    }\n\n    for (int i = 0; i < d; ++i) {\n      for (int j = 0; j < n; ++j) {\n        pr(res[i][j] + \" \");\n      }\n      prln();\n    }\n  }\n  private void nextPerm() {\n    int idx = fp.length - 1;\n    fp[idx]++;\n    while (fp[idx] > k) {fp[idx] = 1; idx--; fp[idx]++; }\n  }\n\n  public static void main(String ... args) throws IOException { new C().run(); }\n\n  private PrintWriter pw;\n  private BufferedReader br;\n  private StringTokenizer st;\n\n  private void run() throws IOException {\n    pw = new PrintWriter(System.out);\n    br = new BufferedReader(new InputStreamReader(System.in));\n    solve();\n    br.close();\n    pw.close();\n  }\n\n  private void pr(Object o) { pw.print(o); }\n  private void prln(Object o) {pw.println(o);}\n  private void prln() {pw.println();}\n\n  private long nl() throws IOException { return Long.parseLong(nt());   }\n\n  private double nd() throws IOException  { return Double.parseDouble(nt()); }\n\n  private int ni()throws IOException  { return Integer.parseInt(nt()); }\n\n  private String nt() throws IOException {\n    if (st == null || !st.hasMoreTokens())\n      st = new StringTokenizer(br.readLine());\n    return st.nextToken();\n  }\n}\n"
        },
        {
            "language": 1,
            "solution": "'''\nProject name : Pashmak_and_Buses\nCreated on : Sat Aug 23 21:48:28 2014\nAuthor : Anant Pushkar\nhttp://codeforces.com/contest/459/problem/C\n'''\nimport sys\ndebug_mode = len(sys.argv)>1 and sys.argv[1]==\"DEBUG\"\ndef debug(msg):\n\tif debug_mode:\n\t\tprint msg\n[n,k,d] = [int(x) for x in str(raw_input()).split(\" \")]\nif n > k**d:\n\tprint -1\nelse:\n\tchild = [range(d) for i in xrange(n)]\n\tarr = 0\n\tfor i in xrange(n):\t\n\t\ttemp = arr\n\t\tfor j in range(d):\n\t\t\tchild[i][j] = temp%k + 1\n\t\t\ttemp /= k\n\t\tarr += 1\n\tfor j in xrange(d):\t\n\t\tfor i in range(n):\n\t\t\tprint child[i][j] ,\n\t\tprint \"\""
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint st[1001][1001];\nint mem[1001];\nlong long int n, k, d;\nint j = 0;\nint cnt = 0;\nvoid rec(int depth) {\n  if (cnt == n) return;\n  if (depth == d) {\n    for (int i = 0; i < d; i++) st[i][cnt] = mem[i];\n    cnt++;\n    return;\n  }\n  for (long long int i = 1; i <= k; i++) {\n    if (cnt == n) return;\n    mem[depth] = i;\n    rec(depth + 1);\n  }\n}\nint main(int argc, char** argv) {\n  cin >> n >> k >> d;\n  long long int save = d;\n  long long int p = 1;\n  bool ok = false;\n  while (save--) {\n    p *= k;\n    if (p >= n) {\n      ok = true;\n      break;\n    };\n  }\n  if (!ok) {\n    cout << -1 << endl;\n    return 0;\n  }\n  rec(0);\n  for (int i = 0; i < d; i++) {\n    for (int j = 0; j < n; j++) cout << st[i][j] << \" \";\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import math as mt\nimport collections as cc\n\nI=lambda:list(map(int,input().split()))\n\n\nn,k,d=I()\nif n>k**d:\n\tprint(-1)\nelse:\n\tans=[[0]*d for i in range(n)]\n\tfor i in range(1,n):\n\t\tfor j in range(d):\n\t\t\tans[i][j]=ans[i-1][j]\n\t\tfor j in range(d-1,-1,-1):\n\t\t\tans[i][j]=(ans[i][j]+1)%k\n\t\t\tif ans[i][j]:break\n\tfor i in range(d):\n\t\tfor j in range(n):\n\t\t\tprint(ans[j][i]+1,end=' ')\n\t\tprint()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid solve();\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed;\n  cout.precision(12);\n  solve();\n  return 0;\n}\ntemplate <typename T>\nvoid sc(T& x) {\n  cin >> x;\n}\ntemplate <typename Head, typename... Tail>\nvoid sc(Head& head, Tail&... tail) {\n  cin >> head;\n  sc(tail...);\n}\ntemplate <typename T>\nvoid pr(const T& x) {\n  cout << x << '\\n';\n}\ntemplate <typename Head, typename... Tail>\nvoid pr(const Head& head, const Tail&... tail) {\n  cout << head << ' ';\n  pr(tail...);\n}\nbool can(int n, int k, int d) {\n  int need = 0;\n  n = (n + k - 1) / k;\n  while (n > 1) {\n    need++;\n    n = (n + k - 1) / k;\n  }\n  return (need + 1 <= d);\n}\nvoid solve() {\n  int n, k, d;\n  sc(n, k, d);\n  if (d == 1 && n > k) {\n    pr(-1);\n    return;\n  }\n  if (k == 1 && n > 1) {\n    pr(-1);\n    return;\n  }\n  if (!can(n, k, d)) {\n    pr(-1);\n    return;\n  }\n  int jump = 1;\n  while (d--) {\n    vector<int> cur(n, -1);\n    for (int j = 0; j < n; j++) {\n      if (cur[j] == -1) {\n        int step = 0;\n        for (int x = j; x < n; x += jump) {\n          cur[x] = step + 1;\n          step++;\n          step %= k;\n        }\n      }\n    }\n    jump = min(1LL * n, 1LL * k * jump);\n    for (int __ii = 0; __ii < ((int)cur.size()); __ii++) {\n      if (__ii) cout << ' ';\n      cout << cur[__ii];\n    }\n    cout << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N, D, K;\nint main() {\n  scanf(\"%d%d%d\", &N, &K, &D);\n  vector<vector<int> > A(N, vector<int>(D, 0));\n  for (int i = 0; i < N; i++) {\n    int x = i;\n    for (int j = D - 1; j >= 0; j--) {\n      A[i][j] = x % K;\n      x /= K;\n    }\n    if (x) {\n      printf(\"-1\\n\");\n      return 0;\n    }\n  }\n  for (int i = 0; i < D; i++) {\n    for (int j = 0; j < N; j++) printf(\"%d \", A[j][i] + 1);\n    printf(\"\\n\");\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint v[1010];\nint ans[1010][1010];\nint main() {\n  int n, k, d;\n  scanf(\" %d %d %d\", &(n), &(k), &(d));\n  int pot = 1;\n  for (int i = 0; i < (d); ++i) {\n    pot *= k;\n    if (pot >= n) {\n      break;\n    }\n  }\n  if (n > pot) {\n    printf(\"-1\\n\");\n    return 0;\n  }\n  for (int i = 0; i < (n); ++i) {\n    for (int j = 0; j < (d); ++j) {\n      ans[j][i] = v[j] + 1;\n    }\n    int carry = 1;\n    for (int i = 0; i < (d); ++i) {\n      int nval = v[i] + carry;\n      carry = nval / k;\n      v[i] = nval % k;\n    }\n  }\n  for (int i = 0; i < (d); ++i) {\n    for (int j = 0; j < (n); ++j) {\n      if (j) printf(\" \");\n      printf(\"%d\", ans[i][j]);\n    }\n    printf(\"\\n\");\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.Scanner;\n\npublic class Main\n{\n    public static void main(String args[]) throws java.lang.Exception\n    {\n        \n        Scanner sc=new Scanner(System.in);\n        int N=sc.nextInt();\n        int K=sc.nextInt();\n        int D=sc.nextInt();\n        int[][] A=new int[D][N];\n        for(int i=0;i<D;i++)\n        A[i][0]=1;\n        int ct=0;\n        boolean print=true;\n        for(int i=1;i<N;i++)\n        {\n            ct=1;\n            for(int j=0;j<D;j++)\n            {\n                A[j][i]=A[j][i-1]+ct;\n                if(A[j][i]>K)\n                {\n                    A[j][i]=1;\n                    ct=1;\n                }\n                else\n                ct=0;\n            }\n            if(ct==1)\n            {\n                print=false;\n                System.out.println(-1);\n                return;\n            }\n        }\n        StringBuilder S=new StringBuilder();\n        \n        for(int i=0;i<D;i++)\n        {\n            S.append(A[i][0]);\n            for(int j=1;j<N;j++)\n            S.append(\" \"+A[i][j]);\n            S.append(\"\\n\");\n        }\n            System.out.print(S);\n    }\n}"
        },
        {
            "language": 3,
            "solution": "load = [int(i) for i in input().split()]\n\nn = load[0]\nk = load[1]\nd = load[2]\n\np = 1\nfor i in range(d):\n    p *= k\n    if p >= n:\n        break\n\nif n > p:\n    print(-1)\nelse:\n    nums = [i for i in range(n)]\n    for i in range(d):\n        buff = \"\"\n        for j in range(n):\n            buff += str(nums[j] % k + 1) + ' '\n            nums[j] //= k\n        print(buff)\n\n    \n"
        },
        {
            "language": 4,
            "solution": "import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.Collections;\nimport java.util.HashSet;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class MainC {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskC solver = new TaskC();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskC {\n    public void increment(int[] permute, int k) {\n        for (int i = permute.length - 1; i >= 0; --i) {\n            if (permute[i] != k) {\n                permute[i]++;\n                for (int j = i + 1; j < permute.length; ++j) {\n                    permute[j] = 1;\n                }\n                return;\n            }\n        }\n    }\n\n\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n        int n = in.nextInt(); // students\n        int k = in.nextInt(); // num buses\n        int d = in.nextInt(); // days\n\n        // If two students are friends, it means they rode the same\n        // bus every day of the trip\n\n        // How many possible ways for a student to choose to ride the\n        // bus for d days?\n        // How many d-length permutations of numbers 1 - k?\n        // If it is fewer than the number of students, it is impossible\n        int total = 1;\n        boolean isValid = false;\n        for (int i = 0; i < d; ++i) {\n            total *= k;\n            if (total >= n) {\n                isValid = true;\n                break;\n            }\n        }\n        if (!isValid) {\n            out.write(\"-1\\n\");\n            return;\n        }\n\n        // the length is d because we need to know which bus is being\n        // ridden each of the d days\n        int[] permute = new int[d];\n        for (int i = 0; i < d; ++i) permute[i] = 1;\n\n        int[][] ans = new int[d][n];\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < d; ++j) {\n                ans[j][i] = permute[j];\n            }\n            increment(permute, k);\n        }\n\n        for (int i = 0; i < d; ++i) {\n            for (int j = 0; j < n; ++j) {\n                out.write(ans[i][j] + \" \");\n            }\n            out.write(\"\\n\");\n        }\n    }\n\n}\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.StringTokenizer;\n\npublic class Solution {\n\n\tstatic InputReader in = new InputReader(System.in);\n\tstatic int mod = (int) (1e9 + 7);\n\tstatic BufferedWriter out = new BufferedWriter(new OutputStreamWriter(\n\t\t\tSystem.out));\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tint n = in.nextInt();\n\t\tint k = in.nextInt();\n\t\tint d = in.nextInt();\n\t\tStringBuilder[] res = new StringBuilder[d];\n\t\tfor (int i = 0; i < res.length; i++) {\n\t\t\tres[i] = new StringBuilder();\n\t\t}\n\t\tint[] arr = new int[d];\n\t\tArrays.fill(arr, 1);\n\t\tlong pow = 1;\n\t\tboolean bigger = false;\n\t\tfor (int i = 0; i < d & !bigger; i++) {\n\t\t\tpow *= k;\n\t\t\tif (pow >= n) {\n\t\t\t\tbigger = true;\n\t\t\t}\n\t\t}\n\t\tif (!bigger) {\n\t\t\tout.write(\"-1\");\n\t\t} else {\n\t\t\tint count = 1;\n\t\t\tfor (int j = 0; j < d; j++) {\n\t\t\t\tres[j].append(\" \").append(arr[j]);\n\t\t\t}\n\t\t\twhile (count < n) {\n\t\t\t\tarr[d - 1]++;\n\t\t\t\tif (arr[d - 1] > k) {\n\t\t\t\t\tarr[d - 1] = 1;\n\t\t\t\t\tfor (int i = d - 2; i >= 0; i--) {\n\t\t\t\t\t\tif (arr[i] + 1 > k) {\n\t\t\t\t\t\t\tarr[i] = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tarr[i]++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < d; j++) {\n\t\t\t\t\tres[j].append(\" \").append(arr[j]);\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tfor (int i = res.length - 1; i >= 0; i--) {\n\t\t\t\tout.write(res[i].toString().trim());\n\t\t\t\tout.newLine();\n\t\t\t}\n\t\t}\n\n\t\tout.flush();\n\t}\n}\n\nclass ListComparator implements Comparator<Integer> {\n\n\t@Override\n\tpublic int compare(Integer e1, Integer e2) {\n\t\treturn e2.compareTo(e1);\n\t}\n}\n\nclass ArrayComparator implements Comparator<int[]> {\n\t@Override\n\tpublic int compare(int[] o1, int[] o2) {\n\n\t\tlong res1 = Math.abs(o1[0]) + Math.abs(o1[1]);\n\t\tlong res2 = Math.abs(o2[0]) + Math.abs(o2[1]);\n\t\treturn Long.compare(res1, res2);\n\t}\n};\n\nclass Pair {\n\n\tint x;\n\tint y;\n\n\tpublic Pair(int x, int y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Pair [x=\" + x + \", y=\" + y + \"]\";\n\t}\n}\n\nclass InputReader {\n\tprivate BufferedReader reader;\n\tprivate StringTokenizer tokenizer;\n\n\tpublic InputReader(InputStream stream) {\n\t\treader = new BufferedReader(new InputStreamReader(stream), 32768);\n\t\ttokenizer = null;\n\t}\n\n\tpublic String next() {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tpublic String readLine() {\n\t\ttry {\n\t\t\treturn reader.readLine();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tpublic float nextFloat() {\n\t\treturn Float.parseFloat(next());\n\t}\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k, d;\nint dp[1004][1004];\nint check() {\n  long long t = 1;\n  for (int i = 1; i <= d; i++) {\n    t = t * k;\n    if (t >= n) return 0;\n  }\n  printf(\"-1\\n\");\n  return 1;\n}\nint main() {\n  scanf(\"%I64d %I64d %I64d\", &n, &k, &d);\n  if (check()) return 0;\n  for (int i = 1; i <= d; i++) dp[i][1] = 1;\n  int t = 0;\n  for (int i = 2; i <= n; i++) {\n    t = 1;\n    for (int j = 1; j <= d; j++) {\n      t = dp[j][i - 1] + t;\n      if (t == k + 1) {\n        dp[j][i] = 1;\n      } else {\n        dp[j][i] = t;\n      }\n      t = t / (k + 1);\n    }\n  }\n  for (int i = 1; i <= d; i++) {\n    for (int j = 1; j <= n; j++) printf(\"%d \", dp[i][j]);\n    printf(\"\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import time,math,bisect,sys\nsys.setrecursionlimit(100000)\nfrom sys import stdin,stdout\nfrom collections import deque\nfrom fractions import Fraction\nfrom collections import Counter\nfrom collections import OrderedDict\npi=3.14159265358979323846264338327950\ndef II(): # to take integer input\n    return int(stdin.readline())\ndef IO(): # to take string input\n    return stdin.readline()\ndef IP(): # to take tuple as input\n    return map(int,stdin.readline().split())\ndef L(): # to take list as input\n    return list(map(int,stdin.readline().split()))\ndef P(x): # to print integer,list,string etc..\n    return stdout.write(str(x)+\"\\n\")\ndef PI(x,y): # to print tuple separatedly\n    return stdout.write(str(x)+\" \"+str(y)+\"\\n\")\ndef lcm(a,b): # to calculate lcm\n    return (a*b)//gcd(a,b)\ndef gcd(a,b): # to calculate gcd\n    if a==0:\n        return b\n    elif b==0:\n        return a\n    if a>b:\n        return gcd(a%b,b)\n    else:\n        return gcd(a,b%a)\ndef readTree(): # to read tree\n    v=int(input())\n    adj=[set() for i in range(v+1)]\n    for i in range(v-1):\n        u1,u2=In()\n        adj[u1].add(u2)\n        adj[u2].add(u1)\n    return adj,v\ndef bfs(adj,v): # a schema of bfs\n    visited=[False]*(v+1)\n    q=deque()\n    while q:\n        pass\ndef sieve():\n    li=[True]*1000001\n    li[0],li[1]=False,False\n    for i in range(2,len(li),1):\n        if li[i]==True:\n            for j in range(i*i,len(li),i):\n                li[j]=False\n    prime=[]\n    for i in range(1000001):\n        if li[i]==True:\n            prime.append(i)\n    return prime\ndef setBit(n):\n    count=0\n    while n!=0:\n        n=n&(n-1)\n        count+=1\n    return count\n#####################################################################################\nmx=10**9+7\ndef solve():\n    n,k,d=IP()\n    if n>pow(k,d):\n        print(-1)\n        return\n    elif d==1:\n        li=[i for i in range(1,n+1)]\n        print(*li)\n    else:\n        li=[[0 for j in range(n)] for i in range(d)]\n        student=0\n        for i in range(1,n):\n            for j in range(d):\n                li[j][i]=li[j][i-1]\n            for j in range(d):\n                li[j][i]=(li[j][i]+1)%k\n                if li[j][i]:\n                    break\n        for i in range(d):\n            for j in range(n):\n                print(int(li[i][j])+1,end=\" \")\n            print()\n        return\n\n\n#t=II()\n#for i in range(t):\nsolve()\n    #######\n   #\n  #\n #######   #     #  # ####   # #     #\n       #  # #   #  # #   #  # # #   #\n      #  ####  #  # ####   ####  # #\n######  #   # #### #    # #   #   #"
        },
        {
            "language": 3,
            "solution": "a = input()\nb = a.split()\nn = int(b[0])\nk = int(b[1])\nd = int(b[2])\nif n > k**d:\n    print(-1)\n    exit()\ntable = [[1]*d]\nfor i in range(n - 1):\n    v = list(table[-1])\n    j = len(v)-1\n    while v[j]==k:\n        v[j]=1\n        j = j - 1\n    v[j] = v[j] + 1\n    table.append(v)\ncurrent_power = 1\nanswer = [0] * n\nfor m in range(0, d):\n    current_value = 1\n    for s in range(0, n):\n        if s % current_power == 0 and s > 0:\n            current_value = current_value % k + 1\n        answer[s] = str(current_value)\n    current_power *= k\n    print(\" \".join(answer))\n"
        },
        {
            "language": 4,
            "solution": "/* package whatever; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Ideone\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tScanner sc=new Scanner(System.in);\n\t\tlong n=sc.nextLong(),k=sc.nextLong(),d=sc.nextLong();\n\t\tboolean flag = false;\n        long p = 1;\n        for (int i = 1; i <= d; i++) {\n            p *= k;\n            if (p >= n) {\n                flag = true;\n                break;\n            }\n        }\n        if (!flag) {\n                System.out.println(-1);\n                return;\n            }\n\t\tlong[][] ans = new long[(int) d][(int) n];\n            for (int i = 0; i < n; i++) {\n                int q = i;\n                int j = 0;\n                while (q > 0 && j < d) {\n                    ans[j++][i] = (q % k);\n                    q /= k;\n                }\n            }\n            StringBuilder sb=new StringBuilder();\n            for (int i = 0; i < d; i++) {\n                for (int j = 0; j < n; j++)\n                sb.append((ans[i][j] + 1) + \" \");\n            \tsb.append(\"\\n\");\n            }\n            System.out.print(sb);\n\t\t\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.io.UnsupportedEncodingException;\nimport java.util.InputMismatchException;\nimport java.util.Comparator;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n\n public class mC {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tC solver = new C();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass C {\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int n = in.readInt();\n        int k = in.readInt();\n\t     int d = in.readInt();\n\t     long pow = 1;\n\t     boolean yes = false;\n\t     for(int i=1;i<=d;++i) {\n\t    \t if(n<=pow*k) {\n\t    \t\t yes = true;\n\t    \t\t break;\n\t    \t }\n\t    \t pow*=k;\n\t     }\n\t     \n\t     if(yes) {\n\t    \t int[][] tab = new int[d+1][n+1];\n\t    \t for(int i=1;i<=d;++i) {\n\t    \t\t\t tab[i][1] = 1;\n\t    \t }\n\t    \t \n\t    \t for(int i=2;i<=n;++i) {\n\t    \t\t for(int j=1;j<=d;++j)\n\t    \t\t\t tab[j][i] = tab[j][i-1];\n\t    \t\t next(tab,i,d,k);\n\t    \t\t \n\t    \t }\n\t    \t \n\t    \t for(int i=1;i<=d;++i) {\n\t    \t\t for(int j=1;j<=n;++j) \n\t    \t\t\t out.print(tab[i][j]+\" \");\n\t    \t\t\t \n\t    \t\t out.println();\n\t    \t }\n\t    \t \n\t     }\n\t     else out.println(-1);\n\t    \n\n\n    }\n static void next(int[][] tab, int i,int d, int k) {\n\t\tfor(int j=d;j>=0;--j) {\n\t\t\tif(tab[j][i]!=k) {\n\t\t\t\ttab[j][i]++;\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\ttab[j][i] = 1;\n\t\t}\n\t\t\n\t}\n\n    public class Pair {\n        int first = 0, second = 0;\n\n        public Pair (int x, int y) {\n            this.first = x;\n            this.second = y;\n        }\n\n    }\n}\n\nclass InputReader {\n\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public int read() {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int readInt() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public static boolean isSpaceChar(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    }"
        },
        {
            "language": 4,
            "solution": "/*\nIf you want to aim high, aim high\nDon't let that studying and grades consume you\nJust live life young\n******************************\nWhat do you think? What do you think?\n1st on Billboard, what do you think of it\nNext is a Grammy, what do you think of it\nHowever you think, I\u2019m sorry, but shit, I have no fcking interest\n*******************************\nI'm standing on top of my Monopoly board\nThat means I'm on top of my game and it don't stop\ntil my hip don't hop anymore\nhttps://www.a2oj.com/Ladder16.html\n*******************************\nShining through the city with a little funk and soul\n*/\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\n\n   public class x459C\n   {\n      public static void main(String hi[]) throws Exception\n      {\n         BufferedReader infile = new BufferedReader(new InputStreamReader(System.in));\n         StringTokenizer st = new StringTokenizer(infile.readLine());\n         int N = Integer.parseInt(st.nextToken());\n         int K = Integer.parseInt(st.nextToken());\n         int D = Integer.parseInt(st.nextToken());\n         long temp = 1L;\n         for(int d=0; d < D; d++)\n         {\n            temp *= K;\n            if(temp >= N)\n               break;\n         }\n         if(temp < N)\n            System.out.println(-1);\n         else\n         {\n            StringBuilder sb = new StringBuilder();\n            int[][] grid = new int[N][D];\n            for(int i=1; i < N; i++)\n            {\n               for(int d=0; d < D; d++)\n                  grid[i][d] = grid[i-1][d];\n               grid[i][D-1]++;\n               int dex = D-1;\n               while(dex >= 0 && grid[i][dex] == K)\n               {\n                  grid[i][dex] = 0;\n                  grid[i][--dex]++;\n               }\n            }\n            for(int d=0; d < D; d++)\n            {\n               for(int i=0; i < N; i++)\n                  sb.append(grid[i][d]+1+\" \");\n               sb.append(\"\\n\");\n            }\n            System.out.print(sb);\n         }\n      }\n   }"
        },
        {
            "language": 4,
            "solution": "import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Niyaz Nigmatullin\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tFastPrinter out = new FastPrinter(outputStream);\n\t\tTaskC solver = new TaskC();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskC {\n    static int cn;\n    static int n;\n    static int[] cur;\n    static int[][] answer;\n\n    static boolean go(int x, int d, int k) {\n        if (x == d) {\n            answer[cn++] = cur.clone();\n            return cn >= n;\n        }\n        for (int i = 1; i <= k; i++) {\n            cur[x] = i;\n            if (go(x + 1, d, k)) return true;\n        }\n        return false;\n    }\n\n    public void solve(int testNumber, FastScanner in, FastPrinter out) {\n        n = in.nextInt();\n        int k = in.nextInt();\n        int d = in.nextInt();\n        long cc = 1;\n        for (int i = 0; i < d; i++) {\n            cc *= k;\n            if (cc >= n) break;\n        }\n        if (cc < n) {\n            out.println(\"-1\");\n            return;\n        }\n        cn = 0;\n        cur = new int[d];\n        answer = new int[n][];\n        go(0, d, k);\n        for (int i = 0; i < d; i++) {\n            for (int j = 0; j < n; j++) {\n                if (j > 0) {\n                    out.print(' ');\n                }\n                out.print(answer[j][i]);\n            }\n            out.println();\n        }\n    }\n}\n\nclass FastScanner extends BufferedReader {\n\n    public FastScanner(InputStream is) {\n        super(new InputStreamReader(is));\n    }\n\n    public int read() {\n        try {\n            int ret = super.read();\n//            if (isEOF && ret < 0) {\n//                throw new InputMismatchException();\n//            }\n//            isEOF = ret == -1;\n            return ret;\n        } catch (IOException e) {\n            throw new InputMismatchException();\n        }\n    }\n\n    static boolean isWhiteSpace(int c) {\n        return c >= 0 && c <= 32;\n    }\n\n    public int nextInt() {\n        int c = read();\n        while (isWhiteSpace(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int ret = 0;\n        while (c >= 0 && !isWhiteSpace(c)) {\n            if (c < '0' || c > '9') {\n                throw new NumberFormatException(\"digit expected \" + (char) c\n                        + \" found\");\n            }\n            ret = ret * 10 + c - '0';\n            c = read();\n        }\n        return ret * sgn;\n    }\n\n    public String readLine() {\n        try {\n            return super.readLine();\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    }\n\nclass FastPrinter extends PrintWriter {\n\n    public FastPrinter(OutputStream out) {\n        super(out);\n    }\n\n    public FastPrinter(Writer out) {\n        super(out);\n    }\n\n\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Random;\n\n\npublic class Main {\n\n\n\tpublic static class pair implements Comparable<pair>\n\t{\n\t\tint a;\n\t\tint b;\n\t\tpublic pair(int pa, int pb)\n\t\t{\n\t\t\ta = pa; b= pb;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(pair o) {\n\t\t\tif(this.a < o.a)\n\t\t\t\treturn -1;\n\t\t\tif(this.a > o.a)\n\t\t\t\treturn 1;\n\t\t\treturn Integer.compare(o.b, this.b);\n\t\t}\n\t}\n\n\n\t//int n = Integer.parseInt(in.readLine());\n\t//int n = Integer.parseInt(spl[0]);\n\t//String[] spl = in.readLine().split(\" \");\n\n\n\tpublic static void main (String[] args) throws Exception\n\t{\t\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] spl = in.readLine().split(\" \");\n\t\tint n = Integer.parseInt(spl[0]);\n\t\tint k = Integer.parseInt(spl[1]);\n\t\tint d = Integer.parseInt(spl[2]);\n\t\tboolean pued = false;\n\t\tif(k>=n) pued = true;\n\t\telse if(Math.pow(k, d) >= n) pued = true;\n\t\tif(pued)\n\t\t{\n\t\t\tint[] arr = new int[d];\n\t\t\tArrays.fill(arr, 1);\n\t\t\tint[][] ans = new int[d][n];\n\t\t\tfor(int i=0; i<n; i++)\n\t\t\t{\n\t\t\t\tfor(int j=0; j<d; j++) ans[j][i] = arr[j];\n\t\t\t\tfor(int j=d-1; j>=0; j--)\n\t\t\t\t{\n\t\t\t\t\tif(arr[j] < k)\n\t\t\t\t\t{\n\t\t\t\t\t\tarr[j]++; break;\n\t\t\t\t\t}\n\t\t\t\t\telse arr[j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<d; i++)\n\t\t\t{\n\t\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\t\tfor(int j=0; j<n; j++)\n\t\t\t\t{\n\t\t\t\t\tsb.append(ans[i][j]);\n\t\t\t\t\tif(j<n-1)\n\t\t\t\t\t\tsb.append(\" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println(sb);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tSystem.out.println(-1);\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, d, ans[1005][1005], cur[1005];\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &d);\n  for (int i = 1; i <= d; ++i) cur[i] = 1;\n  for (int j = 1; j <= n; ++j) {\n    for (int i = 1; i <= d; ++i) ans[i][j] = cur[i];\n    if (j == n) break;\n    int t = d;\n    while (t >= 1 && cur[t] == k) --t;\n    if (t < 1) {\n      printf(\"-1\\n\");\n      return 0;\n    }\n    ++cur[t];\n    for (int i = t + 1; i <= d; ++i) cur[i] = 1;\n  }\n  for (int i = 1; i <= d; ++i) {\n    for (int j = 1; j <= n; ++j) printf(\"%d \", ans[i][j]);\n    printf(\"\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int N, K, D;\n  cin >> N >> K >> D;\n  vector<vector<int>> A(N, vector<int>(D, 0));\n  for (int i = 1; i < N; ++i) {\n    int curry = 1;\n    for (int j = D - 1; j >= 0; --j) {\n      int value = A[i - 1][j] + curry;\n      curry = 0;\n      if (value == K) {\n        curry = 1;\n        value = 0;\n      }\n      A[i][j] = value;\n    }\n    if (curry == 1) {\n      cout << -1 << '\\n';\n      return 0;\n    }\n  }\n  for (int j = 0; j < D; ++j) {\n    for (int i = 0; i < N; ++i) {\n      cout << A[i][j] + 1 << ' ';\n    }\n    cout << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Problem21 {\n\n\tpublic static long[][] ans_;\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tout=new PrintWriter (new BufferedOutputStream(System.out));\n\t\tFastReader s=new FastReader();\n\t\tint n=s.nextInt();\n\t\tint k=s.nextInt();\n\t\tint d=s.nextInt();\n\t\tboolean ans=false;\n\t\tlong temp=1;\n\t\tfor(int i=0;i<d;i++) {\n\t\t\tif(temp<n) {\n\t\t\t\ttemp*=k;\n\t\t\t}else {\n\t\t\t\tans=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ans && temp<n) {\n\t\t\tout.println(\"-1\");\n\t\t\tout.close();\n\t\t\treturn;\n\t\t}\n\t\tans_=new long[d][n];\n\t\tfor(int i=0;i<d;i++) {\n\t\t\tans_[i][0]=0;\n\t\t}\n\t\tfor(int j=1;j<n;j++) {\n\t\t\tAddition(j,k,d);\n\t\t}\n\t\tfor(int i=0;i<d;i++) {\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\tout.print((ans_[i][j]+1)+\" \");\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void Addition(int j,int modulo,int d) {\n\t\tans_[d-1][j]=ans_[d-1][j-1]+1;\n\t\tlong carry=ans_[d-1][j]/modulo;\n\t\tans_[d-1][j]%=modulo;\n\t\tfor(int i=d-2;i>=0;i--) {\n\t\t\tans_[i][j]=(ans_[i][j-1]+carry);\n\t\t\tcarry=ans_[i][j]/modulo;\n\t\t\tans_[i][j]%=modulo;\n\t\t}\n\t}\n\t\n\tpublic static PrintWriter out;\n\t\n\tpublic static class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\t//it reads the data about the specified point and divide the data about it ,it is quite fast\n\t\t//than using direct \n\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t//InputStream reads the data and decodes in character stream\n\t\t\t//It acts as bridge between byte stream and character stream\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());//converts string to integer\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\t\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\nn,k,d=map(int,input().split())\nif k>=n:\n    for i in range(d):\n        print(\" \".join([str(i) for i in range(1,n+1)]))\nelse:\n    if math.log(n,k)>d:\n        print(-1)\n    else:\n        #arr=[[1 for i in range(n)] for j in range(d)]        \n        pk=1       \n        for i in range(d):\n            times=0\n            val=1\n            \n            for j in range(n):                \n                if times<pk:\n                    print(val,end=\" \")\n                    times+=1\n                else:\n                    val+=1\n                    if val>k:\n                        val=1                \n                    times=0\n                    print(val,end=\" \")\n                    times+=1                    \n            pk*=k\n            print()\n            \n        # for val in arr:\n        #     print(\" \".join([str(_) for _ in val]))\n            \n            \n            \n\n        \n    "
        },
        {
            "language": 4,
            "solution": "import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.FileReader;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Agostinho Junior (junior94)\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tOutputWriter out = new OutputWriter(outputStream);\n\t\tTaskC solver = new TaskC();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskC {\n\tOutputWriter out;\n\tInputReader in;\n\tpublic void solve(int testNumber, InputReader in, OutputWriter out) {\n\t\tthis.in = in; this.out = out;\n\t\tint n = in.readInt();\n\t\tint k = in.readInt();\n\t\tint d = in.readInt();\n\t\tint[][] ans = new int[d][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint value = i;\n\t\t\tint day = 0;\n\t\t\twhile (value > 0) {\n\t\t\t\tif (day == d) {\n\t\t\t\t\tout.print(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tans[day][i] = (value % k);\n\t\t\t\tvalue /= k;\n\t\t\t\tday++;\n\t\t\t}\n\t\t\twhile (day < d) {\n\t\t\t\tans[day++][i] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int[] days: ans) {\n\t\t\tfor (int student: days) {\n\t\t\t\tout.print((student + 1) + \" \");\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t}\n}\n\nclass OutputWriter {\n\tprivate PrintWriter output;\n\tpublic OutputWriter() {\n\t\tthis(System.out);\n\t}\n\tpublic OutputWriter(OutputStream out) {\n\t\toutput = new PrintWriter(out);\n\t}\n\tpublic OutputWriter(Writer writer) {\n\t\toutput = new PrintWriter(writer);\n\t}\n\tpublic void print(Object o) {\n\t\toutput.print(o);\n\t}\n\n\tpublic void println() {\n\t\toutput.println();\n\t}\n\n\tpublic void close() {\n\t\toutput.close();\n\t}\n}\n\nclass InputReader {\n\tprivate BufferedReader input;\n\tprivate StringTokenizer line = new StringTokenizer(\"\");\n\tpublic InputReader() {\n\t\tthis(System.in);\n\t}\n\tpublic InputReader(InputStream in) {\n\t\tinput = new BufferedReader(new InputStreamReader(in));\n\t}\n\tpublic InputReader(String s) {\n\t\ttry {\n\t\t\tinput = new BufferedReader(new FileReader(s));\n\t\t} catch(IOException io) { io.printStackTrace(); System.exit(0);}\n\t}\n\tpublic void fill() {\n\t\ttry {\n\t\t\tif(!line.hasMoreTokens()) line = new StringTokenizer(input.readLine());\n\t\t} catch(IOException io) { io.printStackTrace(); System.exit(0);}\n\t}\n\n\tpublic int readInt() {\n\t\tfill();\n\t\treturn Integer.parseInt(line.nextToken());\n\t}\n}\n\n"
        },
        {
            "language": 4,
            "solution": "//package codeforces;\n\n/**\n * Created by nitin.s on 09/10/16.\n */\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\n\npublic class PashmakAndBuses {\n    FastIO io;\n\n    int n, d, k;\n\n    // File names!!!\n\n    void solve() throws Exception {\n        n = io.nextInt();\n        k = io.nextInt();\n        d = io.nextInt();\n        if (BigInteger.valueOf(k).pow(d).compareTo(BigInteger.valueOf(n)) < 0) {\n            io.println(-1);\n            return;\n        }\n        int[][] ans = new int[n][];\n        int[] t = new int[d];\n        for (int i = 0; i < n; i++) {\n            ans[i] = Arrays.copyOf(t, t.length);\n            t[d - 1]++;\n            for (int j = d - 1; j > 0; j--) {\n                t[j - 1] += t[j] / k;\n                t[j] %= k;\n            }\n        }\n        for (int i = 0; i < d; i++) {\n            for (int j = 0; j < n; j++) {\n                io.print(ans[j][i] + 1);\n                io.print(\" \");\n            }\n            io.println();\n        }\n    }\n\n    void run() {\n        try {\n            io = new FastIO();\n            solve();\n            io.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(abs(-1));\n        }\n    }\n\n    public static void main(String[] args) {\n        try {\n            Locale.setDefault(Locale.US);\n        } catch (Exception ignore) {\n        }\n        new PashmakAndBuses().run();\n    }\n\n    class FastIO extends PrintWriter {\n        private BufferedReader in;\n        private StringTokenizer stok;\n\n        FastIO() {\n            super(System.out);\n            in = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        FastIO(String s) throws FileNotFoundException {\n            super(\"\".equals(s) ? \"output.txt\" : s + \".out\");\n            in = new BufferedReader(new FileReader(\"\".equals(s) ? \"input.txt\" : s + \".in\"));\n        }\n\n        @Override\n        public void close() {\n            super.close();\n            try {\n                in.close();\n            } catch (IOException ignored) {\n            }\n        }\n\n        String next() {\n            while (stok == null || !stok.hasMoreTokens()) {\n                try {\n                    stok = new StringTokenizer(in.readLine());\n                } catch (Exception e) {\n                    return null;\n                }\n            }\n            return stok.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        char nextChar() {\n            try {\n                return (char) in.read();\n            } catch (IOException e) {\n                return (char) -1;\n            }\n        }\n\n        String nextLine() {\n            try {\n                return in.readLine();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n\n        char[] nextCharArray() {\n            return next().toCharArray();\n        }\n    }\n\n    void shuffleSort(int[] a) {\n        Random rand = new Random();\n        for (int i = 1; i < a.length; i++) {\n            int x = rand.nextInt(i + 1);\n            int chg = a[i];\n            a[i] = a[x];\n            a[x] = chg;\n        }\n        Arrays.sort(a);\n    }\n\n    class IntArray {\n        private int capacity;\n        private int[] data;\n        private int size = 0;\n\n        IntArray(int capacity) {\n            this.capacity = capacity;\n            this.data = new int[capacity];\n        }\n\n        IntArray() {\n            this(16);\n        }\n\n        int get(int index) {\n            return data[index];\n        }\n\n        void add(int x) {\n            if (size == capacity) {\n                int[] newData = new int[capacity * 2];\n                System.arraycopy(data, 0, newData, 0, capacity);\n                data = newData;\n                capacity *= 2;\n            }\n            data[size++] = x;\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, d, ans[1005][1005];\nvoid setup() {\n  cin >> n >> k >> d;\n  long long check = 1;\n  for (int i = 1; i <= d; i++) {\n    check *= k;\n    if (check > n) break;\n  }\n  if (check < n) {\n    cout << -1;\n    exit(0);\n  }\n}\nvoid xuly() {\n  for (int i = 1; i <= d; i++) ans[1][i] = 1;\n  for (int i = 2; i <= n; i++) {\n    for (int j = 1; j <= d; j++) ans[i][j] = ans[i - 1][j];\n    for (int j = d; j >= 1; j--) {\n      if (ans[i][j] < k) {\n        ans[i][j]++;\n        break;\n      }\n      ans[i][j] = 1;\n    }\n  }\n  for (int i = 1; i <= d; i++) {\n    for (int j = 1; j <= n; j++) cout << ans[j][i] << ' ';\n    cout << '\\n';\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  setup();\n  xuly();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": " import java.util.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\t\n\t// ArrayList<Integer> lis = new ArrayList<Integer>();\n\t// ArrayList<String> lis = new ArrayList<String>();\n\t//  PriorityQueue<P> que = new PriorityQueue<P>();\n\t// PriorityQueue<Integer> que = new PriorityQueue<Integer>();\n\t//  Stack<Integer> que = new Stack<Integer>();\n    //\tstatic long sum=0;\n\t// 1000000007 (10^9+7)\n\tstatic int mod = 1000000007;\n\t//static int mod = 1000000009,r=0; ArrayList<Integer> l[]= new ArrayList[n];\n   // static int dx[]={1,-1,0,0};\n//\tstatic int dy[]={0,0,1,-1};\n//\tstatic int dx[]={1,-1,0,0,1,1,-1,-1};\n//  static int dy[]={0,0,1,-1,1,-1,1,-1};\n\t//static Set<Integer> set = new HashSet<Integer>();\n\t\n\t\npublic  static void main(String[] args)   throws Exception, IOException{\n   //String line=\"\"; throws Exception, IOException\n   //(line=br.readLine())!=null\n\t//Scanner sc =new Scanner(System.in);\n\t// !!caution!! int long //  \n\tReader sc = new Reader(System.in);\n//\tint n=0;\n\n //,a=sc.nextInt(),b=sc.nextInt();\n \t// int a=sc.nextInt(),b=sc.nextInt();\n\tint n=sc.nextInt(),k=sc.nextInt(),d=sc.nextInt();\n\tint x[]=new int[n];\n     long s=1;\n\t  for(int i=1;i<=d;i++){\n\t\t  s*=k;\n\t\t  if( n<s )break;\n\t  }\n\t  \n\t  if( n>s ){System.out.println(-1); return;}\n\t \n      \n\t  StringBuilder r[]=new StringBuilder[d];\n\t  \n\t  for(int i=0;i<d;i++)r[i]=new StringBuilder(\"\");\n\t  \n\t  \n\t\t for(int i=0,c=0;i<n;i++,c++){\n\t\t\tint f=c; \n\t\t\t for(int t=0;t<d;t++){\n\t\t\t\t// db(c,f);\n\t\t\t\t r[t].append((f%k+1)+\" \");\n\t\t\t\tf/=k;\n\t\t\t\t \n\t\t\t }\n\t }\n\n\t\t for(int i=0;i<d;i++){\n\t\t\t\t\t\tSystem.out.print(r[i]);\n\t\t\t\t\tSystem.out.println();\n\t\t }\n\n//\tSystem.out.println();\n\n}\n\n\nstatic void db(Object... os){\n    System.err.println(Arrays.deepToString(os));\n\n}\n\n}\n\n  \n   class P implements Comparable<P>{\n//\t\timplements Comparable<Pair>\n\t\tint id; long d;\n\t\tP(int id,long d){\n\t\t\tthis.id=id;\n\t\t\tthis.d=d;\n\t\t} \n\t\tpublic int compareTo(P x){\n\t\t   \t return  0<=d-x.d?1:-1 ;  //ascend\n\t\t   }\n\t \n }\n\n\n/*\nclass Pair implements Comparable<Pair>{\n//\timplements Comparable<Pair>\n\tint a,b;\n\tPair(int a,int b){\n\t\tthis.a=a;\n\t\tthis.b=b;\n\t} \n\tpublic int compareTo(Pair x){\n\t   \t return a-x.a; //descend\n\t   }\n}*/\n\nclass Reader\n{ \n\tprivate BufferedReader x;\n\tprivate StringTokenizer st;\n\t\n\tpublic Reader(InputStream in)\n\t{\n\t\tx = new BufferedReader(new InputStreamReader(in));\n\t\tst = null;\n\t}\n\tpublic String nextString() throws IOException\n\t{\n\t\twhile( st==null || !st.hasMoreTokens() )\n\t\t\tst = new StringTokenizer(x.readLine());\n\t\treturn st.nextToken();\n\t}\n\tpublic int nextInt() throws IOException\n\t{\n\t\treturn Integer.parseInt(nextString());\n\t}\n\tpublic long nextLong() throws IOException\n\t{\n\t\treturn Long.parseLong(nextString());\n\t}\n\tpublic double nextDouble() throws IOException\n\t{\n\t\treturn Double.parseDouble(nextString());\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long n, m, d, maxx = 1;\n  cin >> n >> m >> d;\n  for (int i = 0; i < d; i++) {\n    maxx *= m;\n    if (maxx >= n) break;\n  }\n  if (maxx < n) {\n    cout << -1 << endl;\n  } else {\n    long long cnt = 1;\n    for (int i = 1; i <= d; i++) {\n      int k;\n      int num = 0;\n      for (int j = 0; j < n; j++) {\n        for (k = j; k < j + cnt && k < n; k++) {\n          cout << num % m + 1 << \" \";\n        }\n        num++;\n        j = k - 1;\n      }\n      cnt *= m;\n      if (cnt > n) cnt = n;\n      cout << endl;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n\npublic class PashmakAndBuses {\n\tpublic static void main(String[] args) {\n\t\tMyScanner sc = new MyScanner();\n\t\t\n\t\tint N = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tint D = sc.nextInt();\n\t\t\n//\t\tlong pow = 1;\n//\t\tfor (int i = 0; i < D; i++) {\n//\t\t\tpow *= K;\n//\t\t\tif (N <= pow) {\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t}\n//\t\tif (N > pow) {\n//\t\t\tSystem.out.println(-1);\n//\t\t\treturn;\n//\t\t}\n\t\t\n\t\tint[][] students = new int[N][D];\n\t\tint[] busOrder = new int[N];\n\t\tfor (int i = 1; i < N; i++) {\n\t\t\tSystem.arraycopy(students[i - 1], 0, students[i], 0, D);\n\t\t\tstudents[i][0]++;\n\t\t\tfor (int j = 0; j < D - 1; j++) {\n\t\t\t\tif (students[i][j] >= K) {\n\t\t\t\t\tstudents[i][j + 1] += students[i][j] / K;\n\t\t\t\t\tstudents[i][j] %= K;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < D; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (students[j][i] >= K) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsb.append((students[j][i] + 1) + \" \");\n\t\t\t}\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\t\tSystem.out.print(sb.toString());\n\t}\n\n\tpublic static class MyScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry { str = br.readLine(); }\n\t\t\tcatch (IOException e) { e.printStackTrace(); }\n\t\t\treturn str;\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, d, d1;\nlong long k, kpre;\nlong long a[1001][1001] = {};\nint main() {\n  cin >> n >> k >> d;\n  long long c = 1;\n  d1 = d, kpre = k;\n  for (int i = 0; i < d; i++) {\n    c *= k;\n    if (c >= n) {\n      c = 0;\n      break;\n    }\n  }\n  if (c != 0) return cout << -1 << endl, 0;\n  k = kpre;\n  for (int i = 2; i <= n; i++) {\n    for (int j = 0; j < d; j++) a[i][j] = a[i - 1][j];\n    for (int j = d - 1; j >= 0; j--) {\n      a[i][j] = (a[i][j] + 1) % k;\n      if (a[i][j]) break;\n    }\n  }\n  for (int i = 0; i < d; i++) {\n    for (int j = 1; j <= n; j++) cout << a[j][i] + 1 << \" \";\n    cout << endl;\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Collection;\nimport java.util.Locale;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Thread(null, new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tlong prevTime = System.currentTimeMillis();\n\t\t\t\t\tnew Main().run();\n\t\t\t\t\tSystem.err.println(\"Total time: \"\n\t\t\t\t\t\t\t+ (System.currentTimeMillis() - prevTime) + \" ms\");\n\t\t\t\t\tSystem.err.println(\"Memory status: \" + memoryStatus());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}, \"1\", 1L << 24).start();\n\t}\n\n\tvoid run() throws IOException {\n\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tObject o = solve();\n\t\tif (o != null)\n\t\t\tout.println(o);\n\t\tout.close();\n\t\tin.close();\n\t}\n\n\tprivate Object solve() throws IOException {\n\t\tint n = ni();\n\t\tint k = ni();\n\t\tint d = ni();\n\t\t\n\t\tint[][] ret = new int[d][n];\n\t\tfor(int i =0;i<d;i++)\n\t\t\tret[i][0]=1;\n\t\t\n\t\tfor(int j =1;j<n;j++){\n\t\t\t\n\t\t\tint r = d-1;\n\t\t\twhile(r>=0 && ret[r][j-1]==k){\n\t\t\t\tret[r][j]=1;\n\t\t\t\tr--;\n\t\t\t}\n\t\t\tif(r==-1)\n\t\t\t\treturn -1;\n\t\t\tret[r][j]=1+ret[r][j-1];\n\t\t\tr--;\n\t\t\twhile(r>=0){\n\t\t\t\tret[r][j]=ret[r][j-1];\n\t\t\t\tr--;\n\t\t\t}\n\t\t}\n\t\tfor(int[] arr : ret)\n\t\t\tprintArray(arr);\n\t\treturn null;\n\t}\n\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer strTok = new StringTokenizer(\"\");\n\n\tString nextToken() throws IOException {\n\t\twhile (!strTok.hasMoreTokens())\n\t\t\tstrTok = new StringTokenizer(in.readLine());\n\t\treturn strTok.nextToken();\n\t}\n\n\tint ni() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nl() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nd() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tint[] nia(int size) throws IOException {\n\t\tint[] ret = new int[size];\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tret[i] = ni();\n\t\treturn ret;\n\t}\n\n\tlong[] nla(int size) throws IOException {\n\t\tlong[] ret = new long[size];\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tret[i] = nl();\n\t\treturn ret;\n\t}\n\n\tdouble[] nda(int size) throws IOException {\n\t\tdouble[] ret = new double[size];\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tret[i] = nd();\n\t\treturn ret;\n\t}\n\n\tString nextLine() throws IOException {\n\t\tstrTok = new StringTokenizer(\"\");\n\t\treturn in.readLine();\n\t}\n\n\tboolean EOF() throws IOException {\n\t\twhile (!strTok.hasMoreTokens()) {\n\t\t\tString s = in.readLine();\n\t\t\tif (s == null)\n\t\t\t\treturn true;\n\t\t\tstrTok = new StringTokenizer(s);\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid printRepeat(String s, int count) {\n\t\tfor (int i = 0; i < count; i++)\n\t\t\tout.print(s);\n\t}\n\n\tvoid printArray(int[] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tif (i > 0)\n\t\t\t\tout.print(' ');\n\t\t\tout.print(array[i]);\n\t\t}\n\t\tout.println();\n\t}\n\n\tvoid printArray(long[] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tif (i > 0)\n\t\t\t\tout.print(' ');\n\t\t\tout.print(array[i]);\n\t\t}\n\t\tout.println();\n\t}\n\n\tvoid printArray(double[] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tif (i > 0)\n\t\t\t\tout.print(' ');\n\t\t\tout.print(array[i]);\n\t\t}\n\t\tout.println();\n\t}\n\n\tvoid printArray(double[] array, String spec) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tif (i > 0)\n\t\t\t\tout.print(' ');\n\t\t\tout.printf(Locale.US, spec, array[i]);\n\t\t}\n\t\tout.println();\n\t}\n\n\tvoid printArray(Object[] array) {\n\t\tboolean blank = false;\n\t\tfor (Object x : array) {\n\t\t\tif (blank)\n\t\t\t\tout.print(' ');\n\t\t\telse\n\t\t\t\tblank = true;\n\t\t\tout.print(x);\n\t\t}\n\t\tout.println();\n\t}\n\n\t@SuppressWarnings(\"rawtypes\")\n\tvoid printCollection(Collection collection) {\n\t\tboolean blank = false;\n\t\tfor (Object x : collection) {\n\t\t\tif (blank)\n\t\t\t\tout.print(' ');\n\t\t\telse\n\t\t\t\tblank = true;\n\t\t\tout.print(x);\n\t\t}\n\t\tout.println();\n\t}\n\n\tstatic String memoryStatus() {\n\t\treturn (Runtime.getRuntime().totalMemory()\n\t\t\t\t- Runtime.getRuntime().freeMemory() >> 20)\n\t\t\t\t+ \"/\" + (Runtime.getRuntime().totalMemory() >> 20) + \" MB\";\n\t}\n\n\tpublic void pln() {\n\t\tout.println();\n\t}\n\n\tpublic void pln(int arg) {\n\t\tout.println(arg);\n\t}\n\n\tpublic void pln(long arg) {\n\t\tout.println(arg);\n\t}\n\n\tpublic void pln(double arg) {\n\t\tout.println(arg);\n\t}\n\n\tpublic void pln(String arg) {\n\t\tout.println(arg);\n\t}\n\n\tpublic void pln(boolean arg) {\n\t\tout.println(arg);\n\t}\n\n\tpublic void pln(char arg) {\n\t\tout.println(arg);\n\t}\n\n\tpublic void pln(float arg) {\n\t\tout.println(arg);\n\t}\n\n\tpublic void pln(Object arg) {\n\t\tout.println(arg);\n\t}\n\n\tpublic void p(int arg) {\n\t\tout.print(arg);\n\t}\n\n\tpublic void p(long arg) {\n\t\tout.print(arg);\n\t}\n\n\tpublic void p(double arg) {\n\t\tout.print(arg);\n\t}\n\n\tpublic void p(String arg) {\n\t\tout.print(arg);\n\t}\n\n\tpublic void p(boolean arg) {\n\t\tout.print(arg);\n\t}\n\n\tpublic void p(char arg) {\n\t\tout.print(arg);\n\t}\n\n\tpublic void p(float arg) {\n\t\tout.print(arg);\n\t}\n\n\tpublic void p(Object arg) {\n\t\tout.print(arg);\n\t}\n\n}"
        },
        {
            "language": 1,
            "solution": "import sys\n#sys.stdin = open(\"in.txt\",\"r\")\nn,k,d = map(int,raw_input().split())\nif k ** d < n:\n    print -1\nelse:\n    ans = []\n    for i in range(0,n):\n        tmp = i\n        cur = []\n        for _ in range(d):\n            cur.append(tmp%k + 1)\n            tmp /= k\n        ans.append(cur)\n    for i in range(d):\n        for j in ans:\n            print j[i],\n        print\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\t\n\tpublic static void main(String args[]){\n\t\tInputReader in = new InputReader(System.in);\n\t\tOutputStream outputStream = System.out;\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\t//==============================================\n\t\tint n=in.nextInt();\n\t\tint k=in.nextInt();\n\t\tint d=in.nextInt();\n\t\tint no=(int)Math.ceil((double)n/k);\n\t\tif(n>Math.pow(k,d)){\n\t\t\tout.println(\"-1\");\n\t\t\tout.close();\n\t\t\treturn;\n\t\t}\n\t\tint a[][]=new int[n][d];\n\t\tint copy=n;\n\t\tfor(int ii=0;ii<n;ii++){\n\t\t\tcopy=ii;\n\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\ta[ii][d-i-1]=(copy)%k;\n\t\t\t\tcopy/=k;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<d;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tout.print((a[j][i]+1)+\" \");\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t\t//==============================================\n\t\tout.close();\n\t}\n\t\n\tstatic class InputReader {\n\t    public BufferedReader reader;\n\t    public StringTokenizer tokenizer;\n\n\t    public InputReader(InputStream inputstream) {\n\t      reader = new BufferedReader(new InputStreamReader(inputstream));\n\t      tokenizer = null;\n\t    }\n\t    \n\t    public String nextLine(){\n\t    \tString fullLine=null;\n\t    \twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t            try {\n\t              fullLine=reader.readLine();\n\t            } catch (IOException e) {\n\t              throw new RuntimeException(e);\n\t            }\n\t            return fullLine;\n\t          }\n\t          return fullLine;\n\t    }\n\t\tpublic String next() {\n\t      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t        try {\n\t          tokenizer = new StringTokenizer(reader.readLine());\n\t        } catch (IOException e) {\n\t          throw new RuntimeException(e);\n\t        }\n\t      }\n\t      return tokenizer.nextToken();\n\t    }\n\t\tpublic long nextLong() {\n\t\t      return Long.parseLong(next());\n\t\t    }\n\t    public int nextInt() {\n\t      return Integer.parseInt(next());\n\t    }\n\t  }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    private static PrintWriter out;\n    private static FastReader in;\n\n    private static class FastReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public FastReader(InputStream inputStream) {\n            reader = new BufferedReader(\n                    new InputStreamReader(inputStream), 1 << 16);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                }\n                catch (IOException ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            }\n            catch (IOException ex) {\n                throw new RuntimeException(ex);\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n\n    public static void main(String[] args) throws FileNotFoundException {\n        in = new FastReader(System.in);\n        out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int k = in.nextInt();\n        int d = in.nextInt();\n        boolean solvable = false;\n        long pow = 1;\n        for (int i = 0; i <= d; ++i) {\n            if (pow >= n) {\n                solvable = true;\n                break;\n            }\n            pow *= k;\n        }\n        if (solvable) {\n            int[][] A = new int[n][d];\n            for (int i = 1; i < n; ++i) {\n                for (int j = 0; j < d; ++j) {\n                    A[i][j] = A[i - 1][j];\n                }\n                for (int j = 0; j < d; ++j) {\n                    A[i][j]++;\n                    if (A[i][j] >= k) {\n                        A[i][j] = 0;\n                    }\n                    else\n                        break;\n                }\n            }\n            for (int i = 0; i < d; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    out.print(++A[j][i] + \" \");\n                }\n                out.println();\n            }\n        }\n        else {\n            out.println(-1);\n        }\n\n        out.flush();\n    }\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class PashmakAndBuses {\n\n    public static void main(String[] args) throws IOException {\n        Init(System.in);\n\n        int n = nextInt();\n\n        int k = nextInt();\n        int d = nextInt();\n        StringBuilder result = new StringBuilder();\n        if ((k == 1 && n > 1)) {\n            System.out.println(-1);\n            return;\n        } else if (n == 1 && k == 1) {\n            for (int i = 0; i < d; ++i) {\n                result.append(1 + \"\\n\");\n            }\n\n            System.out.print(result);\n            return;\n        }\n\n        int temp = 1;\n        boolean check = false;\n\n        for (int i = 0; i < d; ++i) {\n            temp *= k;\n            if (temp >= n) {\n                check = true;\n                break;\n            }\n        }\n\n        if (!check) {\n            System.out.println(-1);\n            return;\n        }\n\n        if (n == 1) {\n            for (int i = 0; i < d; ++i) {\n                result.append(1 + \"\\n\");\n            }\n            System.out.print(result);\n            return;\n        } else if (k >= n) {\n            for (int i = 0; i < d; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    result.append((j + 1) + \" \");\n                }\n                result.append(\"\\n\");\n            }\n            System.out.println(result);\n            return;\n        }\n\n        for (int i = 0; i < d; ++i) {\n            for (int j = 0; j < n; ++j) {\n                result.append((((j / temp) + (j % (temp / k))) % k + 1) + \" \");\n            }\n            if (temp != k) {\n                temp /= k;\n            }\n            result.append(\"\\n\");\n        }\n\n        System.out.print(result);\n\n    }\n\n    static BufferedReader reader;\n    static StringTokenizer tokenizer;\n\n    static void Init(InputStream input) {\n        reader = new BufferedReader(new InputStreamReader(input));\n        tokenizer = new StringTokenizer(\"\");\n    }\n\n    static String next() throws IOException {\n        while (!tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    static Double NextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "n, k, d = map(int, input().split())\ndef go(stu, j, ans, d, n, count):\n    stu.append(str(j))\n    if len(stu)==d:\n        #print('ans mein dala', end=' ')\n        #print(stu)\n        #print('ans tha ye', end=' ')\n        #print(ans)\n        count.append([1])\n        ans.append(' '.join(stu))\n        #print('ye bana ans', end = ' ')\n        #print(ans)\n        stu.pop()\n        return\n    for i in range(1, k+1):\n        if len(count)>=n:\n            break\n        go(stu, i, ans, d, n, count)\n    stu.pop()\n\nif n>(k**d):\n    print(-1)\nelse:\n    ans = []\n    count = []\n    for j in range(1, k+1):\n        if len(count)>=n:\n            break\n        stu = []\n        go(stu, j, ans, d, n, count)\n    x = []\n    for i in range(n):\n        x.append(list(map(str, ans[i].split())))\n    y = [[None for i in range(n)] for j in range(d)]\n    for i in range(n):\n        for j in range(d):\n            y[j][i] = x[i][j]\n    for i in range(d):\n        print(' '.join(y[i]))"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class PashmakAndBuses {\n    private void solve() {\n        int n = in.nextInt(), k = in.nextInt(), d = in.nextInt();\n        outer: {\n            for (int i = 0, possibilites = 1; i < d; ++i) {\n                possibilites *= k;\n                if (possibilites >= n) {\n                    break outer;\n                }\n            }\n            out.println(-1);\n            return;\n        }\n\n        long[][] matrix = new long[d][n];\n        int[] cnum_grammer = new int[Math.min(k, 2000)];\n        for (int i = 0; i < cnum_grammer.length; ++i) {\n            cnum_grammer[i] = i + 1;\n        }\n        NDigitNumber cnum = new NDigitNumber(cnum_grammer, d);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < d; ++j) {\n                matrix[j][i] = cnum.cnum[j];\n            }\n            cnum.next();\n        }\n        for (int i = 0; i < d; ++i) {\n            for (int j = 0; j < n; ++j) {\n                out.print(matrix[i][j] + \" \");\n            }\n            out.println();\n        }\n    }\n\n    private static class NDigitNumber { // subjected to overflows\n        private int[] grammer;\n        private int[] number;\n        public int[] cnum;\n        public NDigitNumber(int[] grammer, int n) {\n            this.grammer = grammer;\n            this.number = new int[n];\n            for (int i = 0; i < n; ++i) {\n                this.number[i] = 0;\n            }\n            this.cnum = new int[n];\n            for (int i = 0; i < n; ++i) {\n                this.cnum[i] = this.grammer[this.number[i]];\n            }\n        }\n\n        public int[] next() {\n            for (int i = number.length - 1; i >= 0; --i) {\n                number[i] = (number[i] + 1) % grammer.length;\n                if (number[i] != 0)\n                    break;\n            }\n            for (int i = 0; i < cnum.length; ++i) {\n                cnum[i] = grammer[number[i]];\n            }\n            return cnum;\n        }\n    }\n\n    private class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in), 327680);\n            st = new StringTokenizer(\"\");\n        }\n\n        String next() {\n            while (!st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        char nextChar() {\n            String s = next();\n            if (s.length() > 1)\n                throw new RuntimeException(\"character expected but string provided\");\n            return s.charAt(0);\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            return str;\n        }\n    }\n\n    private FastScanner in;\n    private PrintWriter out;\n\n    private void run() {\n        try {\n            in = new FastScanner();\n            out = new PrintWriter(new BufferedOutputStream(System.out));\n            solve();\n        } finally {\n            out.close();\n        }\n    }\n\n    public static void main(String[] arg) {\n        new PashmakAndBuses().run();\n    }\n}\n\n\n"
        },
        {
            "language": 1,
            "solution": "from sys import stdin\n\nn, k, d = map(int, stdin.readline().split())\nans, tem = [[] for _ in range(d)], [1] * d\n\nwhile n and tem:\n    for i in range(d):\n        ans[i].append(tem[i])\n\n    while tem and tem[-1] >= k:\n        tem.pop()\n\n    if tem:\n        tem[-1] += 1\n        tem += [1] * (d - len(tem))\n\n    n -= 1\n\nif n:\n    print(-1)\nelse:\n    print('\\n'.join([' '.join(map(str, ans[i])) for i in range(d)]))\n"
        },
        {
            "language": 3,
            "solution": "n,k,d = map(int, input().split())\nif (n > k ** d):\n    print(-1)\n    exit()\nfor i in range(d):\n    power = k**i\n    resArray = [((j // power) % k +1) for j in range(n)]\n    print(' '.join(map(str,resArray)))"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/env python3\n\nn, k, d = map(int, input().split())\nif k ** d < n:\n    print(-1)\nelse:\n    for i in range(d):\n        p = k ** i\n        arr = [j // p % k + 1 for j in range(n)]\n        print(' '.join(map(str, arr)))\n"
        },
        {
            "language": 3,
            "solution": "n,k,d = map(int, input().split())\nif (n > k ** d):\n    print(-1)\n    exit()\nfor i in range(d):\n    power = k**i\n    resArray = [((j // power) % k +1) for j in range(n)]\n    #for j in range(n//(k**i)+1):\n    #    resArray.extend([(j % k) + 1] * (k ** i))\n    print(' '.join(map(str,resArray)))"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.*;\npublic class cf\n{\n    static class Reader\n    {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public Reader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public Reader(String file_name) throws IOException\n        {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1)\n            {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do\n            {\n                ret = ret * 10 + c - '0';\n            }  while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.')\n            {\n                while ((c = read()) >= '0' && c <= '9')\n                {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n\n    static int arr[]=new int[100001];\n\n    public static void main(String[] args) throws IOException \n    {\n        Scanner ob=new Scanner(System.in);\n        Print p=new Print();\n        int n=ob.nextInt();\n        int k=ob.nextInt();\n        int d=ob.nextInt();\n        long pr=1;\n        for(int i=0;i<d;i++)\n        {\n            pr*=k;\n            if(pr>=n)\n                break;\n        }\n        if(pr<n)\n        {\n            p.printLine(\"-1\");\n            p.close();\n            return;\n        }\n        for(int i=0;i<n;i++)\n        {\n            arr[i]=i;\n        }\n        for(int i=0;i<d;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                p.print((arr[j]%k+1)+\" \");\n                arr[j]/=k;\n            }\n            p.printLine(\"\");\n        }\n        p.close();\n    }\n}\nclass Print\n{\n    private final BufferedWriter bw;\n    public Print()\n    {\n        bw=new BufferedWriter(new OutputStreamWriter(System.out));\n    }\n\n    public void print(String str)throws IOException\n    {\n        bw.append(str);\n    }\n\n    public void printLine(String str)throws IOException\n    {\n        print(str);\n        bw.append(\"\\n\");\n    }\n\n    public void close()throws IOException\n    {\n        bw.close();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long fnc(long long k, long long d) {\n  if (d <= 1) return k;\n  if (k > 1000) return 100000;\n  if (d % 2 == 1) {\n    return k * fnc(k * k, d / 2);\n  }\n  return fnc(k * k, d / 2);\n}\nbool fc(long long n, long long k, long long d) {\n  if (k >= n) return 1;\n  if (fnc(k, d) >= n) return 1;\n  return 0;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long n, k, d, e = 1;\n  cin >> n >> k >> d;\n  if (fc(n, k, d) == false) {\n    cout << -1;\n    return 0;\n  }\n  for (int i = 1; i <= d; i++) {\n    for (int j = 1; j <= n; j++) {\n      long long c = j / e;\n      cout << c % k + 1 << \" \";\n    }\n    e %= 100000007;\n    e *= k;\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "// package mainpackage;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String... args) throws Exception {\n\t\t\n\t\tout = new PrintWriter(System.out);\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\t\n\tprivate BufferedReader reader;\n\tprivate StringTokenizer st;\n\tprivate int n, d, k;\n\tprivate int[][] table;\n\tprivate static PrintWriter out;\n\t\n\tprivate void solve() throws Exception {\n\t\t\n\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tst = new StringTokenizer(reader.readLine());\n\t\tn = Integer.parseInt(st.nextToken());\n\t\tk = Integer.parseInt(st.nextToken());\n\t\td = Integer.parseInt(st.nextToken());\n\t\t\n\t\treader.close();\n\t\t\n\t\tint pow = 1;\n\t\tboolean hasSolution = false;\n\t\tfor (int i = 1; i <= d; ++i) {\n\t\t\tpow *= k;\n\t\t\t\n\t\t\tif (pow >= n) {\n\t\t\t\thasSolution = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!hasSolution) {\n\t\t\tout.println(-1);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\ttable = new int[d][n];\n\t\t\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\n\t\t\tint value = i;\n\t\t\tfor (int j = 0; j < d; ++j) {\n\t\t\t\t\n\t\t\t\ttable[j][i] = value % k + 1;\n\t\t\t\tvalue /= k;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor (int i = 0; i < d; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\t\n\t\t\t\tout.print(table[i][j] + \" \");\n\t\t\t}\n\t\t\t\n\t\t\tout.println();\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 1,
            "solution": "from sys import stdout\nmaxn = 1010\nn, k, d = map(int, raw_input().split())\nok = False\nsz = 1\nfor _ in xrange(d):\n    sz *= k\n    if sz >= n:\n        ok = True\n        break\nif not ok:\n    print -1\n    exit()\n\nans = [[0 for _ in xrange(maxn)] for _ in xrange(maxn)]\n\n\nfor i in xrange(1,n):\n    for j in xrange(d):\n        ans[i][j] = ans[i - 1][j]\n    for j in xrange(d - 1, -1, -1):\n        ans[i][j] = (ans[i][j] + 1) % k\n        if ans[i][j]: break\n    \nfor i in xrange(d):\n    for j in xrange(n):\n        stdout.write(str(ans[j][i] + 1) + ' ')\n    stdout.write('\\n');"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10;\nconst int Inf = 0x3f3f3f3f;\nint read() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || '9' < ch) {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while ('0' <= ch && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n  return x * f;\n}\nint n, k, d, t;\nint a[1005][1005];\nint main() {\n  n = t = read();\n  k = read();\n  d = read();\n  for (int i = 1; i <= d; ++i) t = t / k + (int)(t % k > 0);\n  if (t == 1) {\n    memset(a, 0, sizeof(a));\n    for (int i = 0; i < n; ++i) {\n      int tmp = i, j = 1;\n      while (tmp) {\n        a[j++][i] = tmp % k;\n        tmp /= k;\n      }\n    }\n    for (int i = 1; i <= d; ++i) {\n      for (int j = 0; j < n; ++j) printf(\"%d \", a[i][j] + 1);\n      puts(\"\");\n    }\n  } else\n    puts(\"-1\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.util.StringTokenizer;\n\n/**\n * 459C\n *\n * @author artyom\n */\npublic class PashmakAndBuses3 implements Runnable {\n    private BufferedReader in;\n    private PrintStream out;\n    private StringTokenizer tok;\n\n    private StringBuilder sb;\n    private int target;\n    private int busesCount;\n\n    private void solve() throws IOException {\n        int students = nextInt();\n        int k = nextInt(); // buses\n        int d = nextInt(); // days\n        int t = divCeil(students, (int) Math.pow(k, d));\n        if (t > 1) {\n            out.print(\"-1\");\n            return;\n        }\n        busesCount = Math.min(students, k);\n        int count = 0;\n        for (int m = k; ; m *= k) {\n            target = divCeil(students, m);\n            sb = new StringBuilder();\n            populateBuses(students, 1);\n            out.println(sb);\n            count++;\n            if (target == 1) {\n                break;\n            }\n        }\n        String s = sb.toString().trim();\n        for (int i = 0, rem = d - count; i < rem; i++) {\n            out.println(s);\n        }\n    }\n\n    private void populateBuses(int students, int busIndex) {\n        if (students <= target) {\n            for (int i = 0; i < students; i++) {\n                sb.append(busIndex).append(' ');\n            }\n        } else {\n            for (int i = 1, j = 0, t = divCeil(students, busesCount); j < students; i++, j += t) {\n                populateBuses(Math.min(students - j, t), i);\n            }\n        }\n    }\n\n    private static int divCeil(int x, int y) {\n        int res = x / y;\n        if (x % y > 0) {\n            ++res;\n        }\n        return res;\n    }\n\n    //--------------------------------------------------------------\n    public static void main(String[] args) {\n        new PashmakAndBuses3().run();\n    }\n\n    @Override\n    public void run() {\n        try {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = System.out;\n            tok = null;\n            solve();\n            in.close();\n        } catch (IOException e) {\n            System.exit(0);\n        }\n    }\n\n    private String nextToken() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n\n    private int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\n\n\npublic class TestClass {\n\n    \n    public static void main(String[] args) throws IOException {\n        \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line[]=br.readLine().split(\" \");\n        \n        int n,k,d;\n        n=Integer.parseInt(line[0]);\n        k=Integer.parseInt(line[1]);\n        d=Integer.parseInt(line[2]);\n        \n        long permu=1;\n        boolean flag=true;\n        \n        for(int i=1;i<=d;i++)\n        {\n            permu*=k;\n            \n            if(permu >= n)\n            {\n                flag=false;\n                break;\n            }\n            \n        }\n        \n        if(flag)\n            System.out.println(-1);\n        else\n            generateArrangment(n,k,d);\n        \n    }\n    \n    \n    public static void generateArrangment(int n,int k,int d) throws IOException\n    {\n        BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(System.out));\n        int arrangment[][]=new int[d][n];\n        \n        long time=System.currentTimeMillis();\n        for(int i=0;i<n;i++)\n        {\n            arrangment[0][i]=i;\n        }\n        \n        for(int i=0;i<d;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                bw.write((arrangment[0][j])%k+1+\" \");\n                arrangment[0][j]/=k;\n            }\n            bw.write('\\n');\n            /*Scanner scan=new Scanner(System.in);\n            scan.next();*/\n        }\n        \n        \n        bw.flush();\n    }\n    \n    \n    \n    \n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\n\n\tpublic static void main(String[] args){\n\t\tScan scan = new Scan();\n\t\tint students = scan.nextInt();\n\t\tint buses = scan.nextInt();\n\t\tint days = scan.nextInt();\n\t\tif(students > Math.pow(buses, days)){\n\t\t\tSystem.out.println(-1);\n\t\t\treturn;\n\t\t}\n\n\t\tint[][] chart = new int[students][days];\n\t\tfor(int i=0;i<days;i++) chart[0][i] = 1;\n\t\tfor(int i=1;i<students;i++){\n\t\t\tfor(int j=0;j<days;j++) chart[i][j] = chart[i-1][j];\n\t\t\tadd(chart[i], 0, buses);\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0;i<days;i++){\n\t\t\tfor(int j=0;j<students;j++){\n\t\t\t\tsb.append(chart[j][i]);\n\t\t\t\tif(j==students-1) sb.append('\\n');\n\t\t\t\telse sb.append(\" \");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\n\tstatic void add(int[] arr, int target, int buses){\n\t\tif(arr[target] < buses) arr[target]++;\n\t\telse{\n\t\t\tarr[target] = 1;\n\t\t\tadd(arr, target+1, buses);\n\t\t}\n\t}\n\n}\n\n\nclass Scan implements Iterator<String>{\n\n\tBufferedReader buffer;\n\tStringTokenizer tok;\n\n\tScan(){\n\t\tbuffer = new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\n\t@Override\n\tpublic boolean hasNext(){\n\t\twhile(tok==null || !tok.hasMoreElements()){\n\t\t\ttry{\n\t\t\t\ttok = new StringTokenizer(buffer.readLine());\n\t\t\t}catch(Exception e){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic String next(){\n\t\tif(hasNext()) return tok.nextToken();\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void remove(){\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\tint nextInt(){\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tString nextLine(){\n\t\tif(hasNext()) return tok.nextToken(\"\\n\");\n\t\treturn null;\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class C{\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint n = scan.nextInt();\n\t\tint k = scan.nextInt();\n\t\tint d = scan.nextInt();\n\t\tlong val = 1;\n\t\tboolean ex = true;\n\t\tfor(int i = 0;i < d;i++)\n\t\t{\n\t\t\tval*=k;\n\t\t\tif(val >= n)\n\t\t\t{\n\t\t\t\tex = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ex)\n\t\t{\n\t\t\tSystem.out.println(-1);\n\t\t\treturn;\n\t\t}\n\t\tint arr[][] = new int[n][d];\n\t\tfor(int i = 1;i < n;i++)\n\t\t{\n\t\t\tfor(int j = 0;j < d;j++)\n\t\t\t\tarr[i][j] = arr[i - 1][j];\n\t\t\tfor(int j = d-1;j>=0;j--)\n\t\t\t{\n\t\t\t\tarr[i][j] = (arr[i][j] + 1)%k;\n\t\t\t\tif(arr[i][j] > 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0;j < d;j++)\n\t\t{\n\t\t\tfor(int i = 0;i < n;i++)\n\t\t\t\tpw.print((arr[i][j] + 1)+\" \");\n\t\t\tpw.println();\n\t\t}\n\t\tpw.close();\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\nimport static java.lang.Math.*;\n\npublic class Solution implements Runnable {\n\t\n\tvoid solve() throws Exception {\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tint d = sc.nextInt();\n\t\tif (k == 1) {\n\t\t\tif (n == 1) {\n\t\t\t\tfor (int i = 0; i < d; i++) {\n\t\t\t\t\tout.println(1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tout.println(-1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tint p = 1, l = 0;\n\t\twhile (p < n) {\n\t\t\tp *= k;\n\t\t\tl++;\n\t\t}\n\t\tif (l > d) {\n\t\t\tout.println(-1);\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0, pw = 1; i < l; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tout.print(((j / pw) % k + 1) + \" \");\n\t\t\t}\n\t\t\tpw *= k;\n\t\t\tout.println();\n\t\t}\n\t\tfor (int i = l; i < d; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tout.print(1 + \" \");\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t}\n\t\n\tBufferedReader in;\n\tPrintWriter out;\n\tFastScanner sc;\n\t\n\tstatic Throwable throwable;\n\t\n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\t//in = new BufferedReader(new FileReader(\".in\"));\n\t\t\t//out = new PrintWriter(\".out\");\n\t\t\tsc = new FastScanner(in);\n\t\t\tsolve();\n\t\t} catch (Exception e) {\n\t\t\tthrowable = e;\n\t\t} finally {\n\t\t\tout.close();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Throwable {\n\t\tThread thread = new Thread(null, new Solution(), \"\", (1 << 26));\n\t\tthread.start();\n\t\tthread.join();\n\t\tthread.run();\n\t\tif (Solution.throwable != null)\n\t\t\tthrow Solution.throwable;\n\t}\n\n}\n\nclass FastScanner {\n\tBufferedReader reader;\n\tStringTokenizer strTok;\n\t\n\tpublic FastScanner(BufferedReader reader) {\n\t\tthis.reader = reader;\n\t}\n\t\n\tpublic String nextToken() throws Exception {\n\t\twhile (strTok == null || !strTok.hasMoreTokens())\n\t\t\tstrTok = new StringTokenizer(reader.readLine());\n\t\treturn strTok.nextToken();\n\t}\n\t\n\tpublic int nextInt() throws Exception {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\t\n\tpublic long nextLong() throws Exception {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\t\n\tpublic double nextDouble() throws Exception {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint power(int a, int b) {\n  int ans = 1;\n  while (b > 0) {\n    if (b % 2 == 1) {\n      ans *= a;\n    }\n    a *= a;\n    b /= 2;\n  }\n  return ans;\n}\nlong long int max(long long int a, long long int b) { return a > b ? a : b; }\nlong long int min(long long int a, long long int b) { return a > b ? b : a; }\nint main() {\n  long long int n, k, d;\n  cin >> n >> k >> d;\n  int x = 1;\n  for (int i = 0; i < d; i++) {\n    x *= k;\n    if (x >= n) {\n      x = -1;\n      break;\n    }\n  }\n  if (x != -1) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n  x = 1;\n  for (int i = 0; i < d; i++) {\n    for (int j = 0; j < n; j++) {\n      cout << 1 + (j / x) % k << \" \";\n    }\n    cout << endl;\n    if (x < n) {\n      x *= k;\n    }\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\n\npublic class Main1 {\n\n    public static void main(String[] args) throws NumberFormatException,\n            IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] in = br.readLine().split(\" \");\n        \n        int n =Integer.parseInt(in[0]);\n        int k =Integer.parseInt(in[1]);\n        int d =Integer.parseInt(in[2]);\n        boolean f = true;\n        long s = 1;\n        for(int i = 0;i<d;i++){\n            s*=k;\n            if(s>=n){\n                f = false;\n                break;\n            }\n        }\n        if(f){\n            System.out.println(\"-1\");\n        }else{\n            int[][]seq = new int[n][d];\n            for(int i = 1;i<n;i++){\n                for(int j = 0;j<d;j++)\n                    seq[i][j] = seq[i-1][j];\n                \n                for(int j = d-1;j>=0;j--){\n                    seq[i][j] = (seq[i][j]+1)%k;\n                    if(seq[i][j]!=0)\n                        break;\n                }\n            }\n            StringBuilder b = new StringBuilder();\n            for(int i = 0;i<d;i++){\n                for(int j = 0;j<n;j++){\n                    b.append((seq[j][i]+1)+\" \");\n                }\n                b.append('\\n');\n            }\n            System.out.println(b.toString());\n        }\n\n    }\n    public static long powFn(int base,int power)\n    {\n        if(power==0)\n            return 1;\n        if((power%2)!=0)\n        {\n            return ((base)*(powFn(base,power-1)));\n        }\n        long res = powFn(base,power/2);\n        return res * res;\n    }   \n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class GenericProblem\n{\n\t/*\n\t * This FastReader code is taken from GeeksForGeeks.com\n\t * https://www.geeksforgeeks.org/fast-io-in-java-in-competitive-programming/\n\t * \n\t * The article was written by Rishabh Mahrsee\n\t */\n\tpublic static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    }\n\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\tFastReader file = new FastReader();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint n = file.nextInt(), k = file.nextInt(), d = file.nextInt();\n\t\tk = Math.min(n, k); // Remove unnecessary buses\n\t\t\n\t\t// PSUEDOCODE\n\t\t\n\t\t/*\n\t\t * create an 2d array in which the numbers 1, 2, 3, ..., n are evenly distributed\n\t\t * between the k buses\n\t\t * \n\t\t * Do a Level-order-Traversal like algorithm like so for every bus and level in the queue:\n\t\t * The queue will start out with the entire bus\n\t\t * \n\t\t * Attempt to divide up the bus as much as possible for the next day creating k distinct\n\t\t * sub-friend groups that are only friends with each other\n\t\t * \n\t\t * Add these divisions that were made to the queue\n\t\t * \n\t\t * repeat until all of the groups are of size 1 or less\n\t\t * \n\t\t * print the result after each level of the traversal\n\t\t * \n\t\t * Notes: the number of steps this will take is logk( ceil(n / k) ) or\n\t\t * Math.log(Math.ceil(n / (double)k)) / Math.log(k);\n\t\t * \n\t\t * So that means that the number of steps must be <= d - 1, otherwise print -1\n\t\t */\n\t\t\n\t\tint stepCount = 0;\n\t\tStringBuilder result = new StringBuilder();\n\t\t\n\t\tint[][] busArrangement = new int[k][(int)Math.ceil(n / (double) k)];\n\t\tint[] len = new int[k];\n\t\t\n\t\treset(busArrangement, n, k, len);\n\t\tresult.append(format(busArrangement) + \"\\n\");\n\t\t\n\t\tstepCount++;\n\t\t\n\t\t// Level order traversal\n\t\tQueue<Integer> startQ = new LinkedList<>();\n\t\tQueue<Integer> endQ = new LinkedList<>();\n\t\t\n\t\tstartQ.add(0);\n\t\tendQ.add(busArrangement[0].length - 1);\n\t\t\n\t\twhile (!finished(startQ, endQ) && stepCount <= d + 1) // Prevents TLE\n\t\t{\n\t\t\tint size = startQ.size();\n\t\t\tfor (int i = 0; i < size; i++)\n\t\t\t{\n\t\t\t\tint start = startQ.poll();\n\t\t\t\tint end = endQ.poll();\n\t\t\t\t\n\t\t\t\tif (start == end)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tint elemsLeft = end - start + 1;\n\t\t\t\tint groupsLeft = k;\n\t\t\t\t\n\t\t\t\tint rot = 0;\n\t\t\t\tfor (int student = start; student <= end && student < busArrangement[0].length; student++)\n\t\t\t\t{\n\t\t\t\t\tint oldStart = student;\n\t\t\t\t\tfor (int j = 0; j < elemsLeft / groupsLeft && student <= end && student < busArrangement[0].length; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int bus = 0; bus < k; bus++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (busArrangement[bus][student] != -1)\n\t\t\t\t\t\t\t\tbusArrangement[bus][student] = (busArrangement[bus][student] + rot) % k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstudent++;\n\t\t\t\t\t}\n\t\t\t\t\tstudent--;\n\t\t\t\t\t\n\t\t\t\t\tif (elemsLeft / groupsLeft > 0) // We don't want to visit it again if it had 0 elements\n\t\t\t\t\t{\n\t\t\t\t\t\tstartQ.add(oldStart);\n\t\t\t\t\t\tendQ.add(student);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\trot++;\n\t\t\t\t\telemsLeft -= elemsLeft / groupsLeft;\n\t\t\t\t\tgroupsLeft--;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult.append(format(busArrangement) + \"\\n\");\n\t\t\treset(busArrangement, n, k, len);\n\t\t\tstepCount++;\n\t\t}\n\t\t\n\t\tint timesLeft = d - stepCount;\n\t\t\n\t\tif (timesLeft < 0)\n\t\t{\n\t\t\tout.println(-1);\n\t\t\tout.close();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < timesLeft; i++)\n\t\t{\n\t\t\tresult.append(format(busArrangement) + \"\\n\");\n\t\t}\n\t\t\n\t\tout.println(result);\n\t\t\n\t\tout.close();\n\t}\n\t\n\tprivate static boolean finished(Queue<Integer> startQ, Queue<Integer> endQ)\n\t{\n\t\tIterator<Integer> it1 = startQ.iterator();\n\t\tIterator<Integer> it2 = endQ.iterator();\n\t\t\n\t\twhile (it1.hasNext())\n\t\t{\n\t\t\tif (it1.next() < it2.next())\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static void reset(int[][] busArrangement, int n, int k, int[] len)\n\t{\n\t\tfor (int i = 0; i < busArrangement.length; i++)\n\t\t{\n\t\t\tArrays.fill(busArrangement[i], -1);\n\t\t}\n\t\tint i = 0;\n\t\t// Make sure to print the extra buses first\n\t\tfor (; i < n % k; i++)\n\t\t{\n\t\t\tlen[i] = busArrangement[0].length;\n\t\t\tfor (int j = 0; j < busArrangement[0].length; j++)\n\t\t\t{\n\t\t\t\tbusArrangement[i][j] = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (; i < k; i++)\n\t\t{\n\t\t\tlen[i] = n / k;\n\t\t\tfor (int j = 0; j < n / k; j++)\n\t\t\t{\n\t\t\t\tbusArrangement[i][j] = i;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static String format(int[][] arr)\n\t{\n\t\tStringBuilder res = new StringBuilder();\n\n\t\tfor (int[] a : arr)\n\t\t{\n\t\t\tfor (int i : a)\n\t\t\t{\n\t\t\t\tif (i != -1)\n\t\t\t\t\tres.append((i + 1) + \" \");\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res.substring(0, res.length() - 1);\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid read() {\n  freopen(\"in.in\", \"r\", stdin);\n  freopen(\"out.out\", \"w\", stdout);\n}\nint ans[1111][1111];\nint main() {\n  ios::sync_with_stdio(false);\n  int n, d, k;\n  cin >> n >> k >> d;\n  if (pow(k, d) + 0.5 < (double)n) return cout << -1, 0;\n  for (int i = 1; i < n; i++) {\n    for (int j = 0; j < d; j++) ans[i][j] = ans[i - 1][j];\n    for (int j = d - 1; j >= 0; j--) {\n      ans[i][j] = (ans[i][j] + 1) % k;\n      if (ans[i][j]) break;\n    }\n  }\n  for (int i = 0; i < d; i++, cout << endl)\n    for (int j = 0; j < n; j++) cout << ans[j][i] + 1 << ' ';\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "//package com.company;\n\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        int n = sc.nextInt();\n        int K = sc.nextInt();\n        int d = sc.nextInt();\n        long kk = 1;\n        for(int i = 0;i < d;i++){\n            kk *= K;\n            if(kk >= n)kk = n+1;\n        }\n        if(kk < n){\n            out.println(-1);\n        }else{\n            StringBuilder[] sbs = new StringBuilder[d];\n            for(int i = 0;i < d;i++)sbs[i] = new StringBuilder();\n            int[] num = new int[d];\n            for(int i = 0;i < n;i++){\n                for(int j = 0;j < d;j++){\n                    sbs[j].append(\" \" + (num[j]+1));\n                }\n\n                for(int j = d-1;j >= 0;j--){\n                    if(++num[j] >= K){\n                        num[j] = 0;\n                    }else{\n                        break;\n                    }\n                }\n            }\n            for(int i = 0;i < d;i++){\n                out.println(sbs[i].substring(1));\n            }\n        }\n        out.close();\n    }\n}"
        },
        {
            "language": 3,
            "solution": "import sys\nfrom functools import lru_cache, cmp_to_key\nfrom heapq import merge, heapify, heappop, heappush\n# from math import *\nfrom collections import defaultdict as dd, deque, Counter as C\nfrom itertools import combinations as comb, permutations as perm\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\nfrom time import perf_counter\nfrom fractions import Fraction\nimport copy\nimport time\n# import numpy as np\nstarttime = time.time()\n# import numpy as np\nmod = int(pow(10, 9) + 7)\nmod2 = 998244353\ndef data(): return sys.stdin.readline().strip()\ndef out(*var, end=\"\\n\"): sys.stdout.write(' '.join(map(str, var))+end)\ndef L(): return list(sp())\ndef sl(): return list(ssp())\ndef sp(): return map(int, data().split())\ndef ssp(): return map(str, data().split())\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]\n\ntry:\n    # sys.setrecursionlimit(int(pow(10,5)))\n    sys.stdin = open(\"input.txt\", \"r\")\n    # sys.stdout = open(\"../output.txt\", \"w\")\nexcept:\n    pass\n\nn,k,d=L()\nif n>k**d:\n    print(-1)\n    exit()\nA=[]\nfor i in range(n):\n    x=[]\n    y=i\n    for j in range(d):\n        x.append(y%k+1)\n        y//=k\n    A.append(x)\n# print(A)\nfor i in range(d):\n    for j in range(n):\n        print(A[j][i],end=\" \")\n    print()\n\n\n\n\nendtime = time.time()\n# print(f\"Runtime of the program is {endtime - starttime}\")\n"
        },
        {
            "language": 3,
            "solution": "n,k,d=map(int,input().split())\nlimit=1\np=True\nfor i in range(d):\n    limit*=k\n    if limit>=n:\n        p=False\n        break\nif p:\n    print(\"-1\")\n    exit()\na=[i for i in range(1,n+1)]\nfor i in range(d):\n    b=\"\"\n    for j in range(n):\n        b+=str(a[j]%(k)+1)+\" \"\n        a[j]//=k\n    print(b)\n    "
        },
        {
            "language": 1,
            "solution": "import sys\n\n\nsys.setrecursionlimit(1500)\n\n\n\nn, k, d = map(int, raw_input().split())\nres = [[] for _ in xrange(d)]\n\np = 1\ncur_list = []\ndef rec():\n    if len(cur_list) == d:\n        for i, x in enumerate(cur_list):\n            res[i].append(x)\n        if len(res[0]) == n:\n            # print ans and exit\n            for i in xrange(d):\n                print ' '.join(map(str, res[i]))\n            sys.exit(0)\n    else:\n        for num in xrange(1, k + 1):\n            cur_list.append(num)\n            rec()\n            cur_list.pop()\n\n\nfor _ in xrange(d):\n    p *= k\n    if p >= n:\n        break\nelse:\n    print -1\n    sys.exit(0)\n\nrec()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint ans[1080][1080], n, k, d;\nint main() {\n  cin >> n >> k >> d;\n  for (int i = 0; i < n; i++) {\n    int num = i;\n    for (int j = 0; j < d; j++) {\n      ans[i][j] = num % k;\n      num /= k;\n    }\n  }\n  for (int i = 1; i < n; i++) {\n    int allzero = 1;\n    for (int j = 0; j < d; j++) {\n      if (ans[i][j]) allzero = 0;\n    }\n    if (allzero) {\n      cout << -1 << endl;\n      return 0;\n    }\n  }\n  for (int i = 0; i < d; i++) {\n    for (int j = 0; j < n; j++) {\n      if (j) printf(\" \");\n      printf(\"%d\", ans[j][i] + 1);\n    }\n    puts(\"\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1 * 1000 + 10;\nint ans[MAXN][MAXN];\nint main(int argc, char** argv) {\n  int n, k, d;\n  cin >> n >> k >> d;\n  long long tmp = 1L;\n  int i = 0;\n  bool check = false;\n  while (i++ < d) {\n    tmp *= k;\n    if (tmp >= n) {\n      check = true;\n      break;\n    }\n  }\n  if (!check) {\n    cout << -1 << endl;\n    return 0;\n  }\n  for (int i = 1; i < n; i++) {\n    for (int j = 0; j < d; j++) {\n      ans[i][j] = ans[i - 1][j];\n    }\n    for (int j = d - 1; j >= 0; j--) {\n      ans[i][j] = (ans[i][j] + 1) % k;\n      if (ans[i][j]) break;\n    }\n  }\n  for (int i = 0; i < d; i++, cout << endl)\n    for (int j = 0; j < n; j++) cout << ans[j][i] + 1 << ' ';\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n,k,d=list(map(int,input().split()))\nif k**d<n:\n    print(-1)\nelse:\n    ans=[]\n    for i in range(d):\n        ans.append([1 for j in range(n)])\n    for i in range(n):\n        j=0\n        p=i\n        while p>0:\n            ans[j][i]=p%k+1\n            p=p//k\n            j=j+1\n            if j==d:\n                break\n    for i in range(d):\n        print(' '.join(map(str, ans[i])))"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int k = in.nextInt();\n            int d = in.nextInt();\n\n            long acc = 1;\n            for (int i = 0; i < d; i++, acc *= k) {\n                if (acc >= n)\n                    break;\n            }\n            if (acc < n) {\n                out.println(-1);\n                return;\n            }\n\n            long r = 1;\n            for (int i = 0; i < d; i++) {\n                int bi = 1;\n                for (int j = 0; j < n; ) {\n                    for (int l = 1; l <= r && j < n; l++, j++)\n                        out.print(bi + \" \");\n                    bi = bi == k ? 1 : bi + 1;\n                }\n                r = Math.min(n, r * k);\n                out.println();\n            }\n        }\n\n    }\n\n    static class InputReader {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public InputReader(InputStream is) {\n            BufferedReader br = new BufferedReader(new InputStreamReader(is));\n            this.br = br;\n        }\n\n        public String n() {\n            if (st == null || !st.hasMoreTokens()) {\n                String nextLine = null;\n                try {\n                    nextLine = br.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (nextLine == null)\n                    return null;\n                st = new StringTokenizer(nextLine);\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(n());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MAX = 1000000000000000000;\nlong long mod = 1000000000;\nlong double pi = 3.141592653589793238;\nvoid pls() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n}\nlong long n, k, d;\nvector<vector<int>> res;\nvoid backtrack(vector<int> &temp) {\n  if (res.size() == n) return;\n  if (temp.size() == d) {\n    res.push_back(temp);\n    return;\n  }\n  for (int i = 1; i <= k; i++) {\n    temp.push_back(i);\n    backtrack(temp);\n    if (res.size() == n) return;\n    temp.pop_back();\n  }\n}\nvoid solve() {\n  cin >> n >> k >> d;\n  long long permu = 1;\n  long long cnt = 0;\n  while (permu < n && cnt < d) {\n    permu *= k;\n    cnt++;\n  }\n  if (cnt == d && permu < n) {\n    cout << \"-1\" << endl;\n    return;\n  }\n  vector<int> tt;\n  backtrack(tt);\n  for (int i = 0; i < d; i++) {\n    for (int j = 0; j < res.size(); j++) {\n      cout << res[j][i] << \" \";\n    }\n    cout << endl;\n  }\n}\nint main() {\n  pls();\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n \npublic class Main {\n    FastScanner in;\n    PrintWriter out;\n \n    void solve() {\n        int n = in.nextInt();\n        int k = in.nextInt();\n        int d = in.nextInt();\n        boolean c = false;\n        int temp = 1;\n        for (int i = 0; i < d; i++) {\n            temp *= k;\n            if (temp >= n) {\n                c = true;\n                break;\n            }\n        }\n        if (!c) {\n            out.println(\"-1\\n\");\n            return;\n        }\n        int[][] dp = new int[n][d];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < d; j++) {\n                dp[i][j] = 0;\n            }\n        }\n        for (int i = 1; i < n; i++) {\n            boolean f = true;\n            for (int j = 0; j < d; j++) dp[i][j] = dp[i - 1][j];\n            for (int j = d - 1; j >= 0 && f; j--) {\n                dp[i][j]++;\n                if (dp[i][j] >= k) {\n                    dp[i][j] -= k;\n                    f = true;\n                } else f = false;\n            }\n        }\n        for (int i = 0; i < d; i++) {\n            for (int j = 0; j < n; j++) {\n                out.print(dp[j][i] + 1);\n                out.print(' ');\n            }\n            out.println();\n        }\n    }\n \n    void run() {\n        try {\n            in = new FastScanner(new File(\"A.in\"));\n            out = new PrintWriter(new File(\"A.out\"));\n \n            solve();\n \n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n \n    void runIO() {\n \n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out);\n \n        solve();\n \n        out.close();\n    }\n \n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n \n        public FastScanner(InputStream f) {\n            br = new BufferedReader(new InputStreamReader(f));\n        }\n \n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return null;\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n \n        boolean hasMoreTokens() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return false;\n                st = new StringTokenizer(s);\n            }\n            return true;\n        }\n \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n \n    public static void main(String[] args) {\n        new Main().runIO();\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class PashmakBus {\n    public static void main(String[]args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        int d = Integer.parseInt(st.nextToken());\n\n        float tmp = n;\n        int count = 0;\n        while(count < d) {\n            tmp /= k;\n            count++;\n        }\n\n        if ((int)Math.ceil(tmp) > 1) {\n            System.out.println(-1);\n            return;\n        }\n\n        int [][] arr = new int[d][n];\n        for (int i = 0; i < d; i++) {\n            arr[i][0] = 1;\n        }\n\n        for (int i = 1; i < n; i++) {\n            arr[0][i] = arr[0][i-1]+1;\n            int carry = 0;\n            if (arr[0][i] > k) {\n                arr[0][i] = 1;\n                carry = 1;\n            }\n\n            for (int j = 1; j < d; j++) {\n                arr[j][i] = arr[j][i-1]+carry;\n                if (arr[j][i] > k) {\n                    arr[j][i] = 1;\n                    carry = 1;\n                } else {\n                    carry = 0;\n                }\n            }\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < d; i++) {\n            for (int j = 0; j < n; j++) {\n                sb.append(arr[i][j]).append(' ');\n            }\n            sb.append('\\n');\n        }\n        System.out.print(sb);\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\nimport java.lang.*;\nimport java.util.stream.*;\n\n/**\n * @author Pradyumn\n */\n\npublic class Main implements Runnable{\n\tpublic int TC = 0;\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \":)\", 1L << 26).start();\n\t}\n\t@SuppressWarnings(\"Unchecked\")\n\tpublic void solve() throws IOException {\n\t\tint n = ni(), K = ni(), d = ni();\n\t\tlong kk = 1;\n\t\tfor(int i = 0;i < d;i++){\n\t\t\tkk *= K;\n\t\t\tif(kk >= n)kk = n+1;\n\t\t}\n\t\tif(kk < n){\n\t\t\tout.println(-1);\n\t\t}else{\n\t\t\tStringBuilder[] sbs = new StringBuilder[d];\n\t\t\tfor(int i = 0;i < d;i++)sbs[i] = new StringBuilder();\n\t\t\tint[] num = new int[d];\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = 0;j < d;j++){\n\t\t\t\t\tsbs[j].append(\" \" + (num[j]+1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int j = d-1;j >= 0;j--){\n\t\t\t\t\tif(++num[j] >= K){\n\t\t\t\t\t\tnum[j] = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i < d;i++){\n\t\t\t\tout.println(sbs[i].substring(1));\n\t\t\t}\n\t\t}\n\t}\n\tBufferedReader br;\n\tStringTokenizer st;\n\tPrintWriter out;\n\tpublic void run() {\n\t\ttry {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in),32768);\n\t\t\tst = null;\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tif(TC == 1) {\n\t\t\t\tfor(int T = ni();T > 0; --T) {\n\t\t\t\t\tsolve();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsolve();\n\t\t\t}\n\t\t\tbr.close();\n\t\t\tout.close();\n\t\t} catch(IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\tpublic char[] ns(int n) throws IOException {\n\t\treturn ns().toCharArray();\n\t}\n\tpublic char[][] nm(int n, int m) throws IOException {\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n; ++i) {\n\t\t\tmap[i] = ns(m);\n\t\t}\n\t\treturn map;\n\t}\n\tpublic String ns() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\tpublic String nextLine() throws IOException {\n\t\treturn br.readLine();\n\t}\n\tpublic int ni() throws IOException {\n\t\treturn Integer.parseInt(ns());\n\t}\n\n\tpublic int[] na(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n; ++i) a[i] = ni();\n\t\treturn a;\n\t}\n\n\tpublic long nl() throws IOException {\n\t\treturn Long.parseLong(ns());\n\t}\n\n\tpublic long[] nal(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor(int i = 0;i < n; ++i) a[i] = nl();\n\t\treturn a;\n\t}\n\n\tpublic double nd() throws IOException {\n\t\treturn Double.parseDouble(ns());\n\t}\n\tprivate static boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate static void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); } \n}\n"
        },
        {
            "language": 1,
            "solution": "# Represent each student as a vector of length d.  As long as each student\n# has a different vector, we should be fine.\nline = raw_input().split()\nn = int(line[0])\nk = int(line[1])\nd = int(line[2])\n\ndef get_next_vector(v):\n    for i in range(d):\n        if v[i] < k:\n            v[i] += 1\n            return v\n        else:\n            v[i] = 1\n    else:\n        assert False\n\nif n > pow(k, d):\n    print -1\nelse:\n    students = []\n    students.append([1] * d)\n    \n    v = students[0]\n    for i in range(1, n):\n        v = get_next_vector(v[:])\n        students.append(v)\n    \n    for i in range(d):\n        for j in students:\n            print j[i],\n        print\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Popa Andrei\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskC solver = new TaskC();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskC {\n    private int[][] Ans;\n    private int[] A;\n    private int N, K, D, cnt;\n    private boolean stop;\n\n    private void Back(int k) {\n        if (k == D) {\n            for (int i = 0; i < D; i++)\n                Ans[i][cnt] = A[i];\n            ++cnt;\n\n            if (cnt == N)\n                stop = true;\n        } else {\n            A[k] = 0;\n\n            while (!stop && A[k] < K) {\n                ++A[k];\n                Back(k + 1);\n            }\n        }\n    }\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        N = in.nextInt();\n        K = in.nextInt();\n        D = in.nextInt();\n\n        Ans = new int[D][N];\n        A = new int[D];\n\n        cnt = 0;\n        stop = false;\n        Back(0);\n        \n        if (cnt < N) {\n            out.println(-1);\n            return;\n        }\n\n        for (int i = 0; i < D; i++) {\n            for (int j = 0; j < N; j++)\n                out.print(\"\" + Ans[i][j] + ' ');\n            out.println();\n        }\n    }\n}\n\nclass InputReader {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public int read() {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(nextString());\n    }\n\n    public String nextString() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        StringBuffer res = new StringBuffer();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n\n        return res.toString();\n    }\n\n    private boolean isSpaceChar(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\nint mod = 1e9 + 7;\nlong long power(long long b, long long p) {\n  long long r = 1;\n  while (p) {\n    if (p & 1ll) r *= b;\n    b *= b;\n    p >>= 1ll;\n  }\n  return r;\n}\nvector<int> convert_to_other_base(int m, int b, int d) {\n  vector<int> v;\n  while (m) {\n    v.push_back(m % b);\n    m /= b;\n  }\n  int sz = v.size();\n  while (sz < d) v.push_back(0), ++sz;\n  reverse(v.begin(), v.end());\n  return v;\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, k, d;\n  cin >> n >> k >> d;\n  int cd = d;\n  long long ck = k;\n  while (--cd) {\n    ck *= k;\n    if (ck >= n) break;\n  }\n  if (ck < n) return cout << -1, 0;\n  vector<vector<int>> a(n, vector<int>(d, 0));\n  int i, j;\n  for (i = 1; i < n; ++i) a[i] = convert_to_other_base(i, k, d);\n  for (i = 0; i < d; ++i, cout << '\\n')\n    for (j = 0; j < n; ++j) cout << a[j][i] + 1 << ' ';\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "# Target - Expert on CF\n# Be Humblefool\n\nimport sys\n\ndef get_array(): return list(map(int, sys.stdin.readline().strip().split()))\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef input(): return sys.stdin.readline().strip()\n\nn,k,d = get_ints()\nif (n > k ** d):\n    print(-1)\n    exit()\nfor i in range(d):\n    power = k**i\n    resArray = [((j // power) % k +1) for j in range(n)]\n    print(' '.join(map(str,resArray)))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint read() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return x * f;\n}\nint n, d;\nlong long k, now;\nint a[1005][1005];\nvoid Dfs(int u, int i) {\n  if (a[u][i] == k) {\n    a[u][i] = 0;\n    a[u][i + 1]++;\n    Dfs(u, i + 1);\n  }\n}\nint main() {\n  n = read();\n  k = read();\n  d = read();\n  int t = n;\n  for (int i = 1; i <= d; i++) t = t / k + (int)(t % k > 0);\n  memset(a, 0, sizeof(a));\n  if (t == 1) {\n    for (int u = 2; u <= n; u++) {\n      for (int i = 1; i <= d; i++) a[u][i] = a[u - 1][i];\n      a[u][1] += 1;\n      Dfs(u, 1);\n    }\n    for (int i = 1; i <= d; i++) {\n      for (int j = 1; j <= n; j++) printf(\"%d \", a[j][i] + 1);\n      puts(\"\");\n    }\n  } else\n    puts(\"-1\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int inf = (1 << 30), mod = 1000000007;\nusing namespace std;\nint n, d, k, k1;\nint a[1005], go[1005][1005];\nvoid print(int x) {\n  if (x == 0) return;\n  for (int i = 1; i <= d; i++) go[i][x] = a[i];\n  int cur = d;\n  a[cur]++;\n  while (a[cur] > k) {\n    a[cur] = 1;\n    a[--cur]++;\n  }\n  print(x - 1);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> k >> d;\n  long long x = 1;\n  bool ok = false;\n  for (int i = 1; i <= d && !ok; i++) {\n    x *= k;\n    if (x >= n) ok = true;\n  }\n  if (!ok) {\n    cout << -1;\n    return 0;\n  }\n  for (int i = 1; i <= d; i++) a[i] = 1;\n  print(n);\n  for (int i = 1; i <= d; i++)\n    for (int j = 1; j <= n; j++) {\n      cout << go[i][j] << (j == n ? \"\\n\" : \" \");\n    }\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "n,k,d = map(int,raw_input().split())\nif(n> k**d):\n    print -1\nelse:\n    ans = []\n    for  i in range(n):\n        tmp = i;\n        cur = []\n        for j in range(d):\n            cur.append(tmp%k+1)\n            tmp/=k\n        ans.append(cur)\n    for i in range(d):\n        for j in ans:\n            print j[i],\n        print '\\n'\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.util.regex.*;\nimport java.text.*;\nimport java.math.*;\nimport java.io.*;\nimport java.lang.reflect.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tOutputWriter out = new OutputWriter(outputStream);\n\t\tTask solver = new Task();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass Task {\n\n\tint [][] arr;\n\t\n\tpublic void solve(int testNumber, InputReader in, OutputWriter out) {\n\t\tint n=in.readInt(), k=MiscUtils.min(in.readInt(), n), d=in.readInt();\n\t\tarr=new int[d][n];\n\t\tfor (int i=0; i<d; i++) arr[i][0]=1;\n\t\tfor (int i=1; i<n; i++) {\n\t\t\tint j;\n\t\t\tfor (j=0; j<d; j++) arr[j][i]=arr[j][i-1];\n\t\t\tfor (j=d-1; j>=0 && arr[j][i]==k; j--);\n\t\t\tif (j>=0) {\n\t\t\t\tarr[j][i]++;\n\t\t\t\tfor (j++; j<d; j++) arr[j][i]=1;\n\t\t\t} else {\n\t\t\t\tout.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfor (int i=0; i<d; i++) {\n\t\t\tfor (int j=0; j<n; j++) out.print(arr[i][j]+\" \");\n\t\t\tout.println();\n\t\t}\n\t}\n\n}\n\nclass OutputWriter extends PrintWriter {\n\n\tpublic OutputWriter(OutputStream outputStream) {\n\t\tsuper(new BufferedWriter(new OutputStreamWriter(outputStream)));\n\t}\n\n}\n\nclass InputReader {\n\tprivate boolean finished = false;\n\n\tprivate InputStream stream;\n\tprivate byte[] buf = new byte[1024];\n\tprivate int curChar;\n\tprivate int numChars;\n\tprivate SpaceCharFilter filter;\n\n\tpublic InputReader(InputStream stream) {\n\t\tthis.stream = stream;\n\t}\n\n\tpublic int read() {\n\t\tif (numChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= numChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (numChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n\n\tpublic int peek() {\n\t\tif (numChars == -1)\n\t\t\treturn -1;\n\t\tif (curChar >= numChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (numChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar];\n\t}\n\n\tpublic int readInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\n\tpublic long readLong() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tlong res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tif (Character.isValidCodePoint(c))\n\t\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n\n\tpublic boolean isSpaceChar(int c) {\n\t\tif (filter != null)\n\t\t\treturn filter.isSpaceChar(c);\n\t\treturn isWhitespace(c);\n\t}\n\n\tpublic static boolean isWhitespace(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n\n\tprivate String readLine0() {\n\t\tStringBuilder buf = new StringBuilder();\n\t\tint c = read();\n\t\twhile (c != '\\n' && c != -1) {\n\t\t\tif (c != '\\r')\n\t\t\t\tbuf.appendCodePoint(c);\n\t\t\tc = read();\n\t\t}\n\t\treturn buf.toString();\n\t}\n\n\tpublic String readLine() {\n\t\tString s = readLine0();\n\t\twhile (s.trim().length() == 0)\n\t\t\ts = readLine0();\n\t\treturn s;\n\t}\n\n\tpublic String readLine(boolean ignoreEmptyLines) {\n\t\tif (ignoreEmptyLines)\n\t\t\treturn readLine();\n\t\telse\n\t\t\treturn readLine0();\n\t}\n\n\tpublic BigInteger readBigInteger() {\n\t\ttry {\n\t\t\treturn new BigInteger(readString());\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t}\n\n\tpublic char readCharacter() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\treturn (char) c;\n\t}\n\n\tpublic double readDouble() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tdouble res = 0;\n\t\twhile (!isSpaceChar(c) && c != '.') {\n\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\treturn res * Math.pow(10, readInt());\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t}\n\t\tif (c == '.') {\n\t\t\tc = read();\n\t\t\tdouble m = 1;\n\t\t\twhile (!isSpaceChar(c)) {\n\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\treturn res * Math.pow(10, readInt());\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tm /= 10;\n\t\t\t\tres += (c - '0') * m;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t}\n\t\treturn res * sgn;\n\t}\n\n\tpublic boolean isExhausted() {\n\t\tint value;\n\t\twhile (isSpaceChar(value = peek()) && value != -1)\n\t\t\tread();\n\t\treturn value == -1;\n\t}\n\n\tpublic String next() {\n\t\treturn readString();\n\t}\n\n\tpublic SpaceCharFilter getFilter() {\n\t\treturn filter;\n\t}\n\n\tpublic void setFilter(SpaceCharFilter filter) {\n\t\tthis.filter = filter;\n\t}\n\n\tpublic interface SpaceCharFilter {\n\t\tpublic boolean isSpaceChar(int ch);\n\t}\n}\n\nclass MiscUtils {\n\tpublic static final int[] DX4 = { 1, 0, -1, 0 };\n\tpublic static final int[] DY4 = { 0, -1, 0, 1 };\n\tpublic static final int[] DX8 = { 1, 1, 1, 0, -1, -1, -1, 0 };\n\tpublic static final int[] DY8 = { -1, 0, 1, 1, 1, 0, -1, -1 };\n\tpublic static final int[] DX_KNIGHT = { 2, 1, -1, -2, -2, -1, 1, 2 };\n\tpublic static final int[] DY_KNIGHT = { 1, 2, 2, 1, -1, -2, -2, -1 };\n\n\tprivate static final String[] ROMAN_TOKENS = { \"M\", \"CM\", \"D\", \"CD\", \"C\",\n\t\t\t\"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" };\n\tprivate static final int[] ROMAN_VALUES = { 1000, 900, 500, 400, 100, 90,\n\t\t\t50, 40, 10, 9, 5, 4, 1 };\n\n\tpublic static long josephProblem(long n, int k) {\n\t\tif (n == 1)\n\t\t\treturn 0;\n\t\tif (k == 1)\n\t\t\treturn n - 1;\n\t\tif (k > n)\n\t\t\treturn (josephProblem(n - 1, k) + k) % n;\n\t\tlong count = n / k;\n\t\tlong result = josephProblem(n - count, k);\n\t\tresult -= n % k;\n\t\tif (result < 0)\n\t\t\tresult += n;\n\t\telse\n\t\t\tresult += result / (k - 1);\n\t\treturn result;\n\t}\n\n\tpublic static int parseIP(String ip) {\n\t\tString[] components = ip.split(\"[.]\");\n\t\tint result = 0;\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tresult += (1 << (24 - 8 * i)) * Integer.parseInt(components[i]);\n\t\treturn result;\n\t}\n\n\tpublic static String buildIP(int mask) {\n\t\tStringBuilder result = new StringBuilder();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (i != 0)\n\t\t\t\tresult.append('.');\n\t\t\tresult.append(mask >> (24 - 8 * i) & 255);\n\t\t}\n\t\treturn result.toString();\n\t}\n\n\tpublic static String convertToRoman(int number) {\n\t\tStringBuilder result = new StringBuilder();\n\t\tfor (int i = 0; i < ROMAN_TOKENS.length; i++) {\n\t\t\twhile (number >= ROMAN_VALUES[i]) {\n\t\t\t\tnumber -= ROMAN_VALUES[i];\n\t\t\t\tresult.append(ROMAN_TOKENS[i]);\n\t\t\t}\n\t\t}\n\t\treturn result.toString();\n\t}\n\n\tpublic static int convertFromRoman(String number) {\n\t\tint result = 0;\n\t\tfor (int i = 0; i < ROMAN_TOKENS.length; i++) {\n\t\t\twhile (number.startsWith(ROMAN_TOKENS[i])) {\n\t\t\t\tnumber = number.substring(ROMAN_TOKENS[i].length());\n\t\t\t\tresult += ROMAN_VALUES[i];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static <T extends Comparable<T>> T min(T first, T second) {\n\t\tif (first.compareTo(second) <= 0)\n\t\t\treturn first;\n\t\treturn second;\n\t}\n\n\tpublic static <T extends Comparable<T>> T max(T first, T second) {\n\t\tif (first.compareTo(second) <= 0)\n\t\t\treturn second;\n\t\treturn first;\n\t}\n\n\tpublic static int[] getIntArray(String s) {\n\t\tString[] tokens = s.split(\" \");\n\t\tint[] result = new int[tokens.length];\n\t\tfor (int i = 0; i < result.length; i++)\n\t\t\tresult[i] = Integer.parseInt(tokens[i]);\n\t\treturn result;\n\t}\n}\n\nclass IntegerUtils {\n\tpublic static long gcd(long a, long b) {\n\t\ta = Math.abs(a);\n\t\tb = Math.abs(b);\n\t\twhile (b != 0) {\n\t\t\tlong temp = a % b;\n\t\t\ta = b;\n\t\t\tb = temp;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static int gcd(int a, int b) {\n\t\ta = Math.abs(a);\n\t\tb = Math.abs(b);\n\t\twhile (b != 0) {\n\t\t\tint temp = a % b;\n\t\t\ta = b;\n\t\t\tb = temp;\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static int[] generatePrimes(int upTo) {\n\t\tint[] isPrime = generateBitPrimalityTable(upTo);\n\t\tList<Integer> primes = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < upTo; i++) {\n\t\t\tif ((isPrime[i >> 5] >>> (i & 31) & 1) == 1)\n\t\t\t\tprimes.add(i);\n\t\t}\n\t\tisPrime = new int[primes.size()];\n\t\tfor (int i = 0; i < primes.size(); i++)\n\t\t\tisPrime[i] = primes.get(i);\n\t\treturn isPrime;\n\t}\n\n\tpublic static boolean[] generatePrimalityTable(int upTo) {\n\t\tboolean[] isPrime = new boolean[upTo];\n\t\tif (upTo < 2)\n\t\t\treturn isPrime;\n\t\tArrays.fill(isPrime, true);\n\t\tisPrime[0] = isPrime[1] = false;\n\t\tfor (int i = 2; i * i < upTo; i++) {\n\t\t\tif (isPrime[i]) {\n\t\t\t\tfor (int j = i * i; j < upTo; j += i)\n\t\t\t\t\tisPrime[j] = false;\n\t\t\t}\n\t\t}\n\t\treturn isPrime;\n\t}\n\n\tpublic static int[] generateBitPrimalityTable(int upTo) {\n\t\tint[] isPrime = new int[(upTo + 31) >> 5];\n\t\tif (upTo < 2)\n\t\t\treturn isPrime;\n\t\tArrays.fill(isPrime, -1);\n\t\tisPrime[0] &= -4;\n\t\tfor (int i = 2; i * i < upTo; i++) {\n\t\t\tif ((isPrime[i >> 5] >>> (i & 31) & 1) == 1) {\n\t\t\t\tfor (int j = i * i; j < upTo; j += i)\n\t\t\t\t\tisPrime[j >> 5] &= -1 - (1 << (j & 31));\n\t\t\t}\n\t\t}\n\t\treturn isPrime;\n\t}\n\n\tpublic static int[] generateDivisorTable(int upTo) {\n\t\tint[] divisor = new int[upTo];\n\t\tfor (int i = 1; i < upTo; i++)\n\t\t\tdivisor[i] = i;\n\t\tfor (int i = 2; i * i < upTo; i++) {\n\t\t\tif (divisor[i] == i) {\n\t\t\t\tfor (int j = i * i; j < upTo; j += i)\n\t\t\t\t\tdivisor[j] = i;\n\t\t\t}\n\t\t}\n\t\treturn divisor;\n\t}\n\n\tpublic static long powerInFactorial(long n, long p) {\n\t\tlong result = 0;\n\t\twhile (n != 0) {\n\t\t\tresult += n /= p;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static int sumDigits(CharSequence number) {\n\t\tint result = 0;\n\t\tfor (int i = number.length() - 1; i >= 0; i--)\n\t\t\tresult += digitValue(number.charAt(i));\n\t\treturn result;\n\t}\n\n\tpublic static int digitValue(char digit) {\n\t\tif (Character.isDigit(digit))\n\t\t\treturn digit - '0';\n\t\tif (Character.isUpperCase(digit))\n\t\t\treturn digit + 10 - 'A';\n\t\treturn digit + 10 - 'a';\n\t}\n\n\tpublic static int longCompare(long a, long b) {\n\t\tif (a < b)\n\t\t\treturn -1;\n\t\tif (a > b)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tpublic static long[][] generateBinomialCoefficients(int n) {\n\t\tlong[][] result = new long[n + 1][n + 1];\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tresult[i][0] = 1;\n\t\t\tfor (int j = 1; j <= i; j++)\n\t\t\t\tresult[i][j] = result[i - 1][j - 1] + result[i - 1][j];\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static long[][] generateBinomialCoefficients(int n, long module) {\n\t\tlong[][] result = new long[n + 1][n + 1];\n\t\tif (module == 1)\n\t\t\treturn result;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tresult[i][0] = 1;\n\t\t\tfor (int j = 1; j <= i; j++) {\n\t\t\t\tresult[i][j] = result[i - 1][j - 1] + result[i - 1][j];\n\t\t\t\tif (result[i][j] >= module)\n\t\t\t\t\tresult[i][j] -= module;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static long[] generateBinomialRow(int n, long module) {\n\t\tlong[] result = generateReverse(n + 1, module);\n\t\tresult[0] = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tresult[i] = result[i - 1] * (n - i + 1) % module * result[i]\n\t\t\t\t\t% module;\n\t\treturn result;\n\t}\n\n\tpublic static int[] representationInBase(long number, int base) {\n\t\tlong basePower = base;\n\t\tint exponent = 1;\n\t\twhile (number >= basePower) {\n\t\t\tbasePower *= base;\n\t\t\texponent++;\n\t\t}\n\t\tint[] representation = new int[exponent];\n\t\tfor (int i = 0; i < exponent; i++) {\n\t\t\tbasePower /= base;\n\t\t\trepresentation[i] = (int) (number / basePower);\n\t\t\tnumber %= basePower;\n\t\t}\n\t\treturn representation;\n\t}\n\n\tpublic static int trueDivide(int a, int b) {\n\t\treturn (a - trueMod(a, b)) / b;\n\t}\n\n\tpublic static long trueDivide(long a, long b) {\n\t\treturn (a - trueMod(a, b)) / b;\n\t}\n\n\tpublic static int trueMod(int a, int b) {\n\t\ta %= b;\n\t\ta += b;\n\t\ta %= b;\n\t\treturn a;\n\t}\n\n\tpublic static long trueMod(long a, long b) {\n\t\ta %= b;\n\t\ta += b;\n\t\ta %= b;\n\t\treturn a;\n\t}\n\n\tpublic static long factorial(int n) {\n\t\tlong result = 1;\n\t\tfor (int i = 2; i <= n; i++)\n\t\t\tresult *= i;\n\t\treturn result;\n\t}\n\n\tpublic static long factorial(int n, long mod) {\n\t\tlong result = 1;\n\t\tfor (int i = 2; i <= n; i++)\n\t\t\tresult = result * i % mod;\n\t\treturn result % mod;\n\t}\n\n\tpublic static List<Pair<Long, Integer>> factorize(long number) {\n\t\tList<Pair<Long, Integer>> result = new ArrayList<Pair<Long, Integer>>();\n\t\tfor (long i = 2; i * i <= number; i++) {\n\t\t\tif (number % i == 0) {\n\t\t\t\tint power = 0;\n\t\t\t\tdo {\n\t\t\t\t\tpower++;\n\t\t\t\t\tnumber /= i;\n\t\t\t\t} while (number % i == 0);\n\t\t\t\tresult.add(Pair.makePair(i, power));\n\t\t\t}\n\t\t}\n\t\tif (number != 1)\n\t\t\tresult.add(Pair.makePair(number, 1));\n\t\treturn result;\n\t}\n\n\tpublic static List<Long> getDivisors(long number) {\n\t\tList<Pair<Long, Integer>> primeDivisors = factorize(number);\n\t\treturn getDivisorsImpl(primeDivisors, 0, 1, new ArrayList<Long>());\n\t}\n\n\tprivate static List<Long> getDivisorsImpl(\n\t\t\tList<Pair<Long, Integer>> primeDivisors, int index, long current,\n\t\t\tList<Long> result) {\n\t\tif (index == primeDivisors.size()) {\n\t\t\tresult.add(current);\n\t\t\treturn result;\n\t\t}\n\t\tlong p = primeDivisors.get(index).first;\n\t\tint power = primeDivisors.get(index).second;\n\t\tfor (int i = 0; i <= power; i++) {\n\t\t\tgetDivisorsImpl(primeDivisors, index + 1, current, result);\n\t\t\tcurrent *= p;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static long power(long base, long exponent) {\n\t\tif (exponent == 0)\n\t\t\treturn 1;\n\t\tlong result = power(base, exponent >> 1);\n\t\tresult = result * result;\n\t\tif ((exponent & 1) != 0)\n\t\t\tresult = result * base;\n\t\treturn result;\n\t}\n\n\tpublic static long power(long base, long exponent, long mod) {\n\t\tif (base >= mod)\n\t\t\tbase %= mod;\n\t\tif (exponent == 0)\n\t\t\treturn 1 % mod;\n\t\tlong result = power(base, exponent >> 1, mod);\n\t\tresult = result * result % mod;\n\t\tif ((exponent & 1) != 0)\n\t\t\tresult = result * base % mod;\n\t\treturn result;\n\t}\n\n\tpublic static long lcm(long a, long b) {\n\t\treturn a / gcd(a, b) * b;\n\t}\n\n\tpublic static long[] generateFibonacci(long upTo) {\n\t\tint count = 0;\n\t\tlong last = 0;\n\t\tlong current = 1;\n\t\twhile (current <= upTo) {\n\t\t\tlong next = last + current;\n\t\t\tlast = current;\n\t\t\tcurrent = next;\n\t\t\tcount++;\n\t\t}\n\t\treturn generateFibonacci(count, -1);\n\t}\n\n\tpublic static long[] generateFibonacci(int count, long module) {\n\t\tlong[] result = new long[count];\n\t\tif (module == -1) {\n\t\t\tif (count != 0)\n\t\t\t\tresult[0] = 1;\n\t\t\tif (count > 1)\n\t\t\t\tresult[1] = 1;\n\t\t\tfor (int i = 2; i < count; i++)\n\t\t\t\tresult[i] = result[i - 1] + result[i - 2];\n\t\t} else {\n\t\t\tif (count != 0)\n\t\t\t\tresult[0] = 1 % module;\n\t\t\tif (count > 1)\n\t\t\t\tresult[1] = 1 % module;\n\t\t\tfor (int i = 2; i < count; i++)\n\t\t\t\tresult[i] = (result[i - 1] + result[i - 2]) % module;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static long[] generateHappy(int digits) {\n\t\tlong[] happy = new long[(1 << (digits + 1)) - 2];\n\t\thappy[0] = 4;\n\t\thappy[1] = 7;\n\t\tint first = 0;\n\t\tint last = 2;\n\t\tfor (int i = 2; i <= digits; i++) {\n\t\t\tfor (int j = 0; j < last - first; j++) {\n\t\t\t\thappy[last + 2 * j] = 10 * happy[first + j] + 4;\n\t\t\t\thappy[last + 2 * j + 1] = 10 * happy[first + j] + 7;\n\t\t\t}\n\t\t\tint next = last + 2 * (last - first);\n\t\t\tfirst = last;\n\t\t\tlast = next;\n\t\t}\n\t\treturn happy;\n\t}\n\n\tpublic static long[] generateFactorial(int count, long module) {\n\t\tlong[] result = new long[count];\n\t\tif (module == -1) {\n\t\t\tif (count != 0)\n\t\t\t\tresult[0] = 1;\n\t\t\tfor (int i = 1; i < count; i++)\n\t\t\t\tresult[i] = result[i - 1] * i;\n\t\t} else {\n\t\t\tif (count != 0)\n\t\t\t\tresult[0] = 1 % module;\n\t\t\tfor (int i = 1; i < count; i++)\n\t\t\t\tresult[i] = (result[i - 1] * i) % module;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static long reverse(long number, long module) {\n\t\treturn power(number, module - 2, module);\n\t}\n\n\tpublic static boolean isPrime(long number) {\n\t\tif (number < 2)\n\t\t\treturn false;\n\t\tfor (long i = 2; i * i <= number; i++) {\n\t\t\tif (number % i == 0)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static long[] generateReverse(int upTo, long module) {\n\t\tlong[] result = new long[upTo];\n\t\tif (upTo > 1)\n\t\t\tresult[1] = 1;\n\t\tfor (int i = 2; i < upTo; i++)\n\t\t\tresult[i] = (module - module / i * result[((int) (module % i))]\n\t\t\t\t\t% module)\n\t\t\t\t\t% module;\n\t\treturn result;\n\t}\n\n\tpublic static long[] generateReverseFactorials(int upTo, long module) {\n\t\tlong[] result = generateReverse(upTo, module);\n\t\tif (upTo > 0)\n\t\t\tresult[0] = 1;\n\t\tfor (int i = 1; i < upTo; i++)\n\t\t\tresult[i] = result[i] * result[i - 1] % module;\n\t\treturn result;\n\t}\n\n\tpublic static long[] generatePowers(long base, int count, long mod) {\n\t\tlong[] result = new long[count];\n\t\tif (count != 0)\n\t\t\tresult[0] = 1 % mod;\n\t\tfor (int i = 1; i < count; i++)\n\t\t\tresult[i] = result[i - 1] * base % mod;\n\t\treturn result;\n\t}\n\n\tpublic static long nextPrime(long from) {\n\t\tif (from <= 2)\n\t\t\treturn 2;\n\t\tfrom += 1 - (from & 1);\n\t\twhile (!isPrime(from))\n\t\t\tfrom += 2;\n\t\treturn from;\n\t}\n\n\tpublic static long binomialCoefficient(int n, int m, long mod) {\n\t\tif (m < 0 || m > n)\n\t\t\treturn 0;\n\t\tif (2 * m > n)\n\t\t\tm = n - m;\n\t\tlong result = 1;\n\t\tfor (int i = n - m + 1; i <= n; i++)\n\t\t\tresult = result * i % mod;\n\t\treturn result\n\t\t\t\t* BigInteger.valueOf(factorial(m, mod))\n\t\t\t\t\t\t.modInverse(BigInteger.valueOf(mod)).longValue() % mod;\n\t}\n\n\tpublic static boolean isSquare(long number) {\n\t\tlong sqrt = Math.round(Math.sqrt(number));\n\t\treturn sqrt * sqrt == number;\n\t}\n\n\tpublic static long findCommon(long aRemainder, long aMod, long bRemainder,\n\t\t\tlong bMod) {\n\t\tlong modGCD = gcd(aMod, bMod);\n\t\tlong gcdRemainder = aRemainder % modGCD;\n\t\tif (gcdRemainder != bRemainder % modGCD)\n\t\t\treturn -1;\n\t\taMod /= modGCD;\n\t\taRemainder /= modGCD;\n\t\tbMod /= modGCD;\n\t\tbRemainder /= modGCD;\n\t\tlong aReverse = BigInteger.valueOf(aMod)\n\t\t\t\t.modInverse(BigInteger.valueOf(bMod)).longValue();\n\t\tlong bReverse = BigInteger.valueOf(bMod)\n\t\t\t\t.modInverse(BigInteger.valueOf(aMod)).longValue();\n\t\tlong mod = aMod * bMod;\n\t\treturn (bReverse * aRemainder % mod * bMod + aReverse * bRemainder\n\t\t\t\t% mod * aMod)\n\t\t\t\t% mod * modGCD + gcdRemainder;\n\t}\n\n\tpublic static long[] generatePowers(long base, long maxValue) {\n\t\tif (maxValue <= 0)\n\t\t\treturn new long[0];\n\t\tint size = 1;\n\t\tlong current = 1;\n\t\twhile (maxValue / base >= current) {\n\t\t\tcurrent *= base;\n\t\t\tsize++;\n\t\t}\n\t\treturn generatePowers(base, size, Long.MAX_VALUE);\n\t}\n}\n\ninterface Edge {\n\tpublic int getSource();\n\n\tpublic int getDestination();\n\n\tpublic long getWeight();\n\n\tpublic long getCapacity();\n\n\tpublic long getFlow();\n\n\tpublic void pushFlow(long flow);\n\n\tpublic boolean getFlag(int bit);\n\n\tpublic void setFlag(int bit);\n\n\tpublic void removeFlag(int bit);\n\n\tpublic int getTransposedID();\n\n\tpublic Edge getTransposedEdge();\n\n\tpublic int getReverseID();\n\n\tpublic Edge getReverseEdge();\n\n\tpublic int getID();\n\n\tpublic void remove();\n\n\tpublic void restore();\n}\n\nclass Graph {\n\tpublic static final int REMOVED_BIT = 0;\n\n\tprotected int vertexCount;\n\tprotected int edgeCount;\n\n\tprivate int[] firstOutbound;\n\tprivate int[] firstInbound;\n\n\tprivate Edge[] edges;\n\tprivate int[] nextInbound;\n\tprivate int[] nextOutbound;\n\tprivate int[] from;\n\tprivate int[] to;\n\tprivate long[] weight;\n\tprivate long[] capacity;\n\tprivate int[] reverseEdge;\n\tprivate int[] flags;\n\n\tpublic Graph(int vertexCount) {\n\t\tthis(vertexCount, vertexCount);\n\t}\n\n\tpublic Graph(int vertexCount, int edgeCapacity) {\n\t\tthis.vertexCount = vertexCount;\n\t\tfirstOutbound = new int[vertexCount];\n\t\tArrays.fill(firstOutbound, -1);\n\n\t\tfrom = new int[edgeCapacity];\n\t\tto = new int[edgeCapacity];\n\t\tnextOutbound = new int[edgeCapacity];\n\t\tflags = new int[edgeCapacity];\n\t}\n\n\tpublic static Graph createGraph(int vertexCount, int[] from, int[] to) {\n\t\tGraph graph = new Graph(vertexCount, from.length);\n\t\tfor (int i = 0; i < from.length; i++)\n\t\t\tgraph.addSimpleEdge(from[i], to[i]);\n\t\treturn graph;\n\t}\n\n\tpublic static Graph createWeightedGraph(int vertexCount, int[] from,\n\t\t\tint[] to, long[] weight) {\n\t\tGraph graph = new Graph(vertexCount, from.length);\n\t\tfor (int i = 0; i < from.length; i++)\n\t\t\tgraph.addWeightedEdge(from[i], to[i], weight[i]);\n\t\treturn graph;\n\t}\n\n\tpublic static Graph createFlowGraph(int vertexCount, int[] from, int[] to,\n\t\t\tlong[] capacity) {\n\t\tGraph graph = new Graph(vertexCount, from.length * 2);\n\t\tfor (int i = 0; i < from.length; i++)\n\t\t\tgraph.addFlowEdge(from[i], to[i], capacity[i]);\n\t\treturn graph;\n\t}\n\n\tpublic static Graph createFlowWeightedGraph(int vertexCount, int[] from,\n\t\t\tint[] to, long[] weight, long[] capacity) {\n\t\tGraph graph = new Graph(vertexCount, from.length * 2);\n\t\tfor (int i = 0; i < from.length; i++)\n\t\t\tgraph.addFlowWeightedEdge(from[i], to[i], weight[i], capacity[i]);\n\t\treturn graph;\n\t}\n\n\tpublic static Graph createTree(int[] parent) {\n\t\tGraph graph = new Graph(parent.length + 1, parent.length);\n\t\tfor (int i = 0; i < parent.length; i++)\n\t\t\tgraph.addSimpleEdge(parent[i], i + 1);\n\t\treturn graph;\n\t}\n\n\tpublic int addEdge(int fromID, int toID, long weight, long capacity,\n\t\t\tint reverseEdge) {\n\t\tensureEdgeCapacity(edgeCount + 1);\n\t\tif (firstOutbound[fromID] != -1)\n\t\t\tnextOutbound[edgeCount] = firstOutbound[fromID];\n\t\telse\n\t\t\tnextOutbound[edgeCount] = -1;\n\t\tfirstOutbound[fromID] = edgeCount;\n\t\tif (firstInbound != null) {\n\t\t\tif (firstInbound[toID] != -1)\n\t\t\t\tnextInbound[edgeCount] = firstInbound[toID];\n\t\t\telse\n\t\t\t\tnextInbound[edgeCount] = -1;\n\t\t\tfirstInbound[toID] = edgeCount;\n\t\t}\n\t\tthis.from[edgeCount] = fromID;\n\t\tthis.to[edgeCount] = toID;\n\t\tif (capacity != 0) {\n\t\t\tif (this.capacity == null)\n\t\t\t\tthis.capacity = new long[from.length];\n\t\t\tthis.capacity[edgeCount] = capacity;\n\t\t}\n\t\tif (weight != 0) {\n\t\t\tif (this.weight == null)\n\t\t\t\tthis.weight = new long[from.length];\n\t\t\tthis.weight[edgeCount] = weight;\n\t\t}\n\t\tif (reverseEdge != -1) {\n\t\t\tif (this.reverseEdge == null) {\n\t\t\t\tthis.reverseEdge = new int[from.length];\n\t\t\t\tArrays.fill(this.reverseEdge, 0, edgeCount, -1);\n\t\t\t}\n\t\t\tthis.reverseEdge[edgeCount] = reverseEdge;\n\t\t}\n\t\tif (edges != null)\n\t\t\tedges[edgeCount] = createEdge(edgeCount);\n\t\treturn edgeCount++;\n\t}\n\n\tprotected final GraphEdge createEdge(int id) {\n\t\treturn new GraphEdge(id);\n\t}\n\n\tpublic final int addFlowWeightedEdge(int from, int to, long weight,\n\t\t\tlong capacity) {\n\t\tif (capacity == 0) {\n\t\t\treturn addEdge(from, to, weight, 0, -1);\n\t\t} else {\n\t\t\tint lastEdgeCount = edgeCount;\n\t\t\taddEdge(to, from, -weight, 0, lastEdgeCount + entriesPerEdge());\n\t\t\treturn addEdge(from, to, weight, capacity, lastEdgeCount);\n\t\t}\n\t}\n\n\tprotected int entriesPerEdge() {\n\t\treturn 1;\n\t}\n\n\tpublic final int addFlowEdge(int from, int to, long capacity) {\n\t\treturn addFlowWeightedEdge(from, to, 0, capacity);\n\t}\n\n\tpublic final int addWeightedEdge(int from, int to, long weight) {\n\t\treturn addFlowWeightedEdge(from, to, weight, 0);\n\t}\n\n\tpublic final int addSimpleEdge(int from, int to) {\n\t\treturn addWeightedEdge(from, to, 0);\n\t}\n\n\tpublic final int vertexCount() {\n\t\treturn vertexCount;\n\t}\n\n\tpublic final int edgeCount() {\n\t\treturn edgeCount;\n\t}\n\n\tprotected final int edgeCapacity() {\n\t\treturn from.length;\n\t}\n\n\tpublic final Edge edge(int id) {\n\t\tinitEdges();\n\t\treturn edges[id];\n\t}\n\n\tpublic final int firstOutbound(int vertex) {\n\t\tint id = firstOutbound[vertex];\n\t\twhile (id != -1 && isRemoved(id))\n\t\t\tid = nextOutbound[id];\n\t\treturn id;\n\t}\n\n\tpublic final int nextOutbound(int id) {\n\t\tid = nextOutbound[id];\n\t\twhile (id != -1 && isRemoved(id))\n\t\t\tid = nextOutbound[id];\n\t\treturn id;\n\t}\n\n\tpublic final int firstInbound(int vertex) {\n\t\tinitInbound();\n\t\tint id = firstInbound[vertex];\n\t\twhile (id != -1 && isRemoved(id))\n\t\t\tid = nextInbound[id];\n\t\treturn id;\n\t}\n\n\tpublic final int nextInbound(int id) {\n\t\tinitInbound();\n\t\tid = nextInbound[id];\n\t\twhile (id != -1 && isRemoved(id))\n\t\t\tid = nextInbound[id];\n\t\treturn id;\n\t}\n\n\tpublic final int source(int id) {\n\t\treturn from[id];\n\t}\n\n\tpublic final int destination(int id) {\n\t\treturn to[id];\n\t}\n\n\tpublic final long weight(int id) {\n\t\tif (weight == null)\n\t\t\treturn 0;\n\t\treturn weight[id];\n\t}\n\n\tpublic final long capacity(int id) {\n\t\tif (capacity == null)\n\t\t\treturn 0;\n\t\treturn capacity[id];\n\t}\n\n\tpublic final long flow(int id) {\n\t\tif (reverseEdge == null)\n\t\t\treturn 0;\n\t\treturn capacity[reverseEdge[id]];\n\t}\n\n\tpublic final void pushFlow(int id, long flow) {\n\t\tif (flow == 0)\n\t\t\treturn;\n\t\tif (flow > 0) {\n\t\t\tif (capacity(id) < flow)\n\t\t\t\tthrow new IllegalArgumentException(\"Not enough capacity\");\n\t\t} else {\n\t\t\tif (flow(id) < -flow)\n\t\t\t\tthrow new IllegalArgumentException(\"Not enough capacity\");\n\t\t}\n\t\tcapacity[id] -= flow;\n\t\tcapacity[reverseEdge[id]] += flow;\n\t}\n\n\tpublic int transposed(int id) {\n\t\treturn -1;\n\t}\n\n\tpublic final int reverse(int id) {\n\t\tif (reverseEdge == null)\n\t\t\treturn -1;\n\t\treturn reverseEdge[id];\n\t}\n\n\tpublic final void addVertices(int count) {\n\t\tensureVertexCapacity(vertexCount + count);\n\t\tArrays.fill(firstOutbound, vertexCount, vertexCount + count, -1);\n\t\tif (firstInbound != null)\n\t\t\tArrays.fill(firstInbound, vertexCount, vertexCount + count, -1);\n\t\tvertexCount += count;\n\t}\n\n\tprotected final void initEdges() {\n\t\tif (edges == null) {\n\t\t\tedges = new Edge[from.length];\n\t\t\tfor (int i = 0; i < edgeCount; i++)\n\t\t\t\tedges[i] = createEdge(i);\n\t\t}\n\t}\n\n\tpublic final void removeVertex(int vertex) {\n\t\tint id = firstOutbound[vertex];\n\t\twhile (id != -1) {\n\t\t\tremoveEdge(id);\n\t\t\tid = nextOutbound[id];\n\t\t}\n\t\tinitInbound();\n\t\tid = firstInbound[vertex];\n\t\twhile (id != -1) {\n\t\t\tremoveEdge(id);\n\t\t\tid = nextInbound[id];\n\t\t}\n\t}\n\n\tprivate void initInbound() {\n\t\tif (firstInbound == null) {\n\t\t\tfirstInbound = new int[firstOutbound.length];\n\t\t\tArrays.fill(firstInbound, 0, vertexCount, -1);\n\t\t\tnextInbound = new int[from.length];\n\t\t\tfor (int i = 0; i < edgeCount; i++) {\n\t\t\t\tnextInbound[i] = firstInbound[to[i]];\n\t\t\t\tfirstInbound[to[i]] = i;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic final boolean flag(int id, int bit) {\n\t\treturn (flags[id] >> bit & 1) != 0;\n\t}\n\n\tpublic final void setFlag(int id, int bit) {\n\t\tflags[id] |= 1 << bit;\n\t}\n\n\tpublic final void removeFlag(int id, int bit) {\n\t\tflags[id] &= -1 - (1 << bit);\n\t}\n\n\tpublic final void removeEdge(int id) {\n\t\tsetFlag(id, REMOVED_BIT);\n\t}\n\n\tpublic final void restoreEdge(int id) {\n\t\tremoveFlag(id, REMOVED_BIT);\n\t}\n\n\tpublic final boolean isRemoved(int id) {\n\t\treturn flag(id, REMOVED_BIT);\n\t}\n\n\tpublic final Iterable<Edge> outbound(final int id) {\n\t\tinitEdges();\n\t\treturn new Iterable<Edge>() {\n\t\t\tpublic Iterator<Edge> iterator() {\n\t\t\t\treturn new EdgeIterator(id, firstOutbound, nextOutbound);\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic final Iterable<Edge> inbound(final int id) {\n\t\tinitEdges();\n\t\tinitInbound();\n\t\treturn new Iterable<Edge>() {\n\t\t\tpublic Iterator<Edge> iterator() {\n\t\t\t\treturn new EdgeIterator(id, firstInbound, nextInbound);\n\t\t\t}\n\t\t};\n\t}\n\n\tprotected void ensureEdgeCapacity(int size) {\n\t\tif (from.length < size) {\n\t\t\tint newSize = Math.max(size, 2 * from.length);\n\t\t\tif (edges != null)\n\t\t\t\tedges = resize(edges, newSize);\n\t\t\tfrom = resize(from, newSize);\n\t\t\tto = resize(to, newSize);\n\t\t\tnextOutbound = resize(nextOutbound, newSize);\n\t\t\tif (nextInbound != null)\n\t\t\t\tnextInbound = resize(nextInbound, newSize);\n\t\t\tif (weight != null)\n\t\t\t\tweight = resize(weight, newSize);\n\t\t\tif (capacity != null)\n\t\t\t\tcapacity = resize(capacity, newSize);\n\t\t\tif (reverseEdge != null)\n\t\t\t\treverseEdge = resize(reverseEdge, newSize);\n\t\t\tflags = resize(flags, newSize);\n\t\t}\n\t}\n\n\tprivate void ensureVertexCapacity(int size) {\n\t\tif (firstOutbound.length < size) {\n\t\t\tint newSize = Math.max(size, 2 * from.length);\n\t\t\tfirstOutbound = resize(firstOutbound, newSize);\n\t\t\tif (firstInbound != null)\n\t\t\t\tfirstInbound = resize(firstInbound, newSize);\n\t\t}\n\t}\n\n\tprotected final int[] resize(int[] array, int size) {\n\t\tint[] newArray = new int[size];\n\t\tSystem.arraycopy(array, 0, newArray, 0, array.length);\n\t\treturn newArray;\n\t}\n\n\tprivate long[] resize(long[] array, int size) {\n\t\tlong[] newArray = new long[size];\n\t\tSystem.arraycopy(array, 0, newArray, 0, array.length);\n\t\treturn newArray;\n\t}\n\n\tprivate Edge[] resize(Edge[] array, int size) {\n\t\tEdge[] newArray = new Edge[size];\n\t\tSystem.arraycopy(array, 0, newArray, 0, array.length);\n\t\treturn newArray;\n\t}\n\n\tpublic final boolean isSparse() {\n\t\treturn vertexCount == 0 || edgeCount * 20 / vertexCount <= vertexCount;\n\t}\n\n\tprotected class GraphEdge implements Edge {\n\t\tprotected int id;\n\n\t\tprotected GraphEdge(int id) {\n\t\t\tthis.id = id;\n\t\t}\n\n\t\tpublic int getSource() {\n\t\t\treturn source(id);\n\t\t}\n\n\t\tpublic int getDestination() {\n\t\t\treturn destination(id);\n\t\t}\n\n\t\tpublic long getWeight() {\n\t\t\treturn weight(id);\n\t\t}\n\n\t\tpublic long getCapacity() {\n\t\t\treturn capacity(id);\n\t\t}\n\n\t\tpublic long getFlow() {\n\t\t\treturn flow(id);\n\t\t}\n\n\t\tpublic void pushFlow(long flow) {\n\t\t\tGraph.this.pushFlow(id, flow);\n\t\t}\n\n\t\tpublic boolean getFlag(int bit) {\n\t\t\treturn flag(id, bit);\n\t\t}\n\n\t\tpublic void setFlag(int bit) {\n\t\t\tGraph.this.setFlag(id, bit);\n\t\t}\n\n\t\tpublic void removeFlag(int bit) {\n\t\t\tGraph.this.removeFlag(id, bit);\n\t\t}\n\n\t\tpublic int getTransposedID() {\n\t\t\treturn transposed(id);\n\t\t}\n\n\t\tpublic Edge getTransposedEdge() {\n\t\t\tint reverseID = getTransposedID();\n\t\t\tif (reverseID == -1)\n\t\t\t\treturn null;\n\t\t\tinitEdges();\n\t\t\treturn edge(reverseID);\n\t\t}\n\n\t\tpublic int getReverseID() {\n\t\t\treturn reverse(id);\n\t\t}\n\n\t\tpublic Edge getReverseEdge() {\n\t\t\tint reverseID = getReverseID();\n\t\t\tif (reverseID == -1)\n\t\t\t\treturn null;\n\t\t\tinitEdges();\n\t\t\treturn edge(reverseID);\n\t\t}\n\n\t\tpublic int getID() {\n\t\t\treturn id;\n\t\t}\n\n\t\tpublic void remove() {\n\t\t\tremoveEdge(id);\n\t\t}\n\n\t\tpublic void restore() {\n\t\t\trestoreEdge(id);\n\t\t}\n\t}\n\n\tpublic class EdgeIterator implements Iterator<Edge> {\n\t\tprivate int edgeID;\n\t\tprivate final int[] next;\n\t\tprivate int lastID = -1;\n\n\t\tpublic EdgeIterator(int id, int[] first, int[] next) {\n\t\t\tthis.next = next;\n\t\t\tedgeID = nextEdge(first[id]);\n\t\t}\n\n\t\tprivate int nextEdge(int id) {\n\t\t\twhile (id != -1 && isRemoved(id))\n\t\t\t\tid = next[id];\n\t\t\treturn id;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\treturn edgeID != -1;\n\t\t}\n\n\t\tpublic Edge next() {\n\t\t\tif (edgeID == -1)\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tlastID = edgeID;\n\t\t\tedgeID = nextEdge(next[lastID]);\n\t\t\treturn edges[lastID];\n\t\t}\n\n\t\tpublic void remove() {\n\t\t\tif (lastID == -1)\n\t\t\t\tthrow new IllegalStateException();\n\t\t\tremoveEdge(lastID);\n\t\t\tlastID = -1;\n\t\t}\n\t}\n\n}\n\nclass BidirectionalGraph extends Graph {\n\tpublic int[] transposedEdge;\n\n\tpublic BidirectionalGraph(int vertexCount) {\n\t\tthis(vertexCount, vertexCount);\n\t}\n\n\tpublic BidirectionalGraph(int vertexCount, int edgeCapacity) {\n\t\tsuper(vertexCount, 2 * edgeCapacity);\n\t\ttransposedEdge = new int[2 * edgeCapacity];\n\t}\n\n\tpublic static BidirectionalGraph createGraph(int vertexCount, int[] from,\n\t\t\tint[] to) {\n\t\tBidirectionalGraph graph = new BidirectionalGraph(vertexCount,\n\t\t\t\tfrom.length);\n\t\tfor (int i = 0; i < from.length; i++)\n\t\t\tgraph.addSimpleEdge(from[i], to[i]);\n\t\treturn graph;\n\t}\n\n\tpublic static BidirectionalGraph createWeightedGraph(int vertexCount,\n\t\t\tint[] from, int[] to, long[] weight) {\n\t\tBidirectionalGraph graph = new BidirectionalGraph(vertexCount,\n\t\t\t\tfrom.length);\n\t\tfor (int i = 0; i < from.length; i++)\n\t\t\tgraph.addWeightedEdge(from[i], to[i], weight[i]);\n\t\treturn graph;\n\t}\n\n\tpublic static BidirectionalGraph createFlowGraph(int vertexCount,\n\t\t\tint[] from, int[] to, long[] capacity) {\n\t\tBidirectionalGraph graph = new BidirectionalGraph(vertexCount,\n\t\t\t\tfrom.length * 2);\n\t\tfor (int i = 0; i < from.length; i++)\n\t\t\tgraph.addFlowEdge(from[i], to[i], capacity[i]);\n\t\treturn graph;\n\t}\n\n\tpublic static BidirectionalGraph createFlowWeightedGraph(int vertexCount,\n\t\t\tint[] from, int[] to, long[] weight, long[] capacity) {\n\t\tBidirectionalGraph graph = new BidirectionalGraph(vertexCount,\n\t\t\t\tfrom.length * 2);\n\t\tfor (int i = 0; i < from.length; i++)\n\t\t\tgraph.addFlowWeightedEdge(from[i], to[i], weight[i], capacity[i]);\n\t\treturn graph;\n\t}\n\n\t@Override\n\tpublic int addEdge(int fromID, int toID, long weight, long capacity,\n\t\t\tint reverseEdge) {\n\t\tint lastEdgeCount = edgeCount;\n\t\tsuper.addEdge(fromID, toID, weight, capacity, reverseEdge);\n\t\tsuper.addEdge(toID, fromID, weight, capacity, reverseEdge == -1 ? -1\n\t\t\t\t: reverseEdge + 1);\n\t\tthis.transposedEdge[lastEdgeCount] = lastEdgeCount + 1;\n\t\tthis.transposedEdge[lastEdgeCount + 1] = lastEdgeCount;\n\t\treturn lastEdgeCount;\n\t}\n\n\t@Override\n\tprotected int entriesPerEdge() {\n\t\treturn 2;\n\t}\n\n\t@Override\n\tpublic final int transposed(int id) {\n\t\treturn transposedEdge[id];\n\t}\n\n\t@Override\n\tprotected void ensureEdgeCapacity(int size) {\n\t\tif (size > edgeCapacity()) {\n\t\t\tsuper.ensureEdgeCapacity(size);\n\t\t\ttransposedEdge = resize(transposedEdge, edgeCapacity());\n\t\t}\n\t}\n}\n\ninterface IntComparator extends Comparator<Integer> {\n\tpublic static final IntComparator DEFAULT = new IntComparator() {\n\t\tpublic int compare(Integer first, Integer second) {\n\t\t\tif (first < second)\n\t\t\t\treturn -1;\n\t\t\tif (first > second)\n\t\t\t\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t};\n\n\tpublic static final IntComparator REVERSE = new IntComparator() {\n\t\tpublic int compare(Integer first, Integer second) {\n\t\t\tif (first < second)\n\t\t\t\treturn 1;\n\t\t\tif (first > second)\n\t\t\t\treturn -1;\n\t\t\treturn 0;\n\t\t}\n\t};\n\n\tpublic int compare(Integer first, Integer second);\n}\n\ninterface IndependentSetSystem {\n\tpublic boolean join(int first, int second);\n\n\tpublic int get(int index);\n\n\tpublic int getSetCount();\n\n\tpublic void setListener(Listener listener);\n\n\tpublic static interface Listener {\n\t\tpublic void joined(int joinedRoot, int root);\n\t}\n}\n\nclass RecursiveIndependentSetSystem implements IndependentSetSystem {\n\tprivate final int[] color;\n\tprivate final int[] rank;\n\tprivate int setCount;\n\tprivate Listener listener;\n\n\tpublic RecursiveIndependentSetSystem(int size) {\n\t\tcolor = new int[size];\n\t\trank = new int[size];\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tcolor[i] = i;\n\t\tsetCount = size;\n\t}\n\n\tpublic RecursiveIndependentSetSystem(RecursiveIndependentSetSystem other) {\n\t\tcolor = other.color.clone();\n\t\trank = other.rank.clone();\n\t\tsetCount = other.setCount;\n\t}\n\n\tpublic boolean join(int first, int second) {\n\t\tfirst = get(first);\n\t\tsecond = get(second);\n\t\tif (first == second)\n\t\t\treturn false;\n\t\tif (rank[first] < rank[second]) {\n\t\t\tint temp = first;\n\t\t\tfirst = second;\n\t\t\tsecond = temp;\n\t\t} else if (rank[first] == rank[second])\n\t\t\trank[first]++;\n\t\tsetCount--;\n\t\tcolor[second] = first;\n\t\tif (listener != null)\n\t\t\tlistener.joined(second, first);\n\t\treturn true;\n\t}\n\n\tpublic int get(int index) {\n\t\tif (color[index] == index)\n\t\t\treturn index;\n\t\treturn color[index] = get(color[index]);\n\t}\n\n\tpublic int getSetCount() {\n\t\treturn setCount;\n\t}\n\n\tpublic void setListener(Listener listener) {\n\t\tthis.listener = listener;\n\t}\n}\n\nclass Pair<U, V> implements Comparable<Pair<U, V>> {\n\tpublic final U first;\n\tpublic final V second;\n\n\tpublic static <U, V> Pair<U, V> makePair(U first, V second) {\n\t\treturn new Pair<U, V>(first, second);\n\t}\n\n\tprivate Pair(U first, V second) {\n\t\tthis.first = first;\n\t\tthis.second = second;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (this == o)\n\t\t\treturn true;\n\t\tif (o == null || getClass() != o.getClass())\n\t\t\treturn false;\n\n\t\tPair pair = (Pair) o;\n\n\t\treturn !(first != null ? !first.equals(pair.first) : pair.first != null)\n\t\t\t\t&& !(second != null ? !second.equals(pair.second)\n\t\t\t\t\t\t: pair.second != null);\n\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tint result = first != null ? first.hashCode() : 0;\n\t\tresult = 31 * result + (second != null ? second.hashCode() : 0);\n\t\treturn result;\n\t}\n\n\tpublic Pair<V, U> swap() {\n\t\treturn makePair(second, first);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"(\" + first + \",\" + second + \")\";\n\t}\n\n\t@SuppressWarnings({ \"unchecked\" })\n\tpublic int compareTo(Pair<U, V> o) {\n\t\tint value = ((Comparable<U>) first).compareTo(o.first);\n\t\tif (value != 0)\n\t\t\treturn value;\n\t\treturn ((Comparable<V>) second).compareTo(o.second);\n\t}\n}\n\nclass ArrayUtils {\n\n\tpublic static void sort(int[] array, IntComparator comparator) {\n\t\tInteger[] aux = new Integer[array.length];\n\t\tArrays.sort(aux, comparator);\n\t\tfor (int i = 0; i < aux.length; i++)\n\t\t\tarray[i] = aux[i];\n\t}\n\n\tpublic static void sort(int[] array) {\n\t\tsort(array, IntComparator.DEFAULT);\n\t}\n\n}\n\nclass StringUtils {\n\tpublic static String reverse(String sample) {\n\t\tStringBuilder result = new StringBuilder(sample);\n\t\tresult.reverse();\n\t\treturn result.toString();\n\t}\n\n\tpublic static int count(String string, char c) {\n\t\tint count = 0;\n\t\tfor (int i = string.length() - 1; i >= 0; i--) {\n\t\t\tif (string.charAt(i) == c) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\tpublic static String unite(String[] array) {\n\t\tStringBuilder result = new StringBuilder();\n\t\tfor (String s : array) {\n\t\t\tresult.append(s);\n\t\t}\n\t\treturn result.toString();\n\t}\n\n\tpublic static int differs(String first, String second) {\n\t\tint result = 0;\n\t\tfor (int i = 0; i < first.length(); i++) {\n\t\t\tif (first.charAt(i) != second.charAt(i)) {\n\t\t\t\tresult++;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static int[] zAlgorithm(CharSequence s) {\n\t\tint length = s.length();\n\t\tint[] z = new int[length];\n\t\tint left = 0, right = 0;\n\t\tfor (int i = 1; i < length; i++) {\n\t\t\tif (i > right) {\n\t\t\t\tint j;\n\t\t\t\t// noinspection StatementWithEmptyBody\n\t\t\t\tfor (j = 0; i + j < length && s.charAt(i + j) == s.charAt(j); j++)\n\t\t\t\t\t;\n\t\t\t\tz[i] = j;\n\t\t\t\tleft = i;\n\t\t\t\tright = i + j - 1;\n\t\t\t} else if (z[i - left] < right - i + 1)\n\t\t\t\tz[i] = z[i - left];\n\t\t\telse {\n\t\t\t\tint j;\n\t\t\t\t// noinspection StatementWithEmptyBody\n\t\t\t\tfor (j = 1; right + j < length\n\t\t\t\t\t\t&& s.charAt(right + j) == s.charAt(right - i + j); j++)\n\t\t\t\t\t;\n\t\t\t\tz[i] = right - i + j;\n\t\t\t\tleft = i;\n\t\t\t\tright = right + j - 1;\n\t\t\t}\n\t\t}\n\t\treturn z;\n\t}\n\n\tpublic static int[] prefixFunction(CharSequence s) {\n\t\tint l = s.length();\n\t\tint[] p = new int[l];\n\t\tint k = 0;\n\t\tfor (int i = 1; i < l; i++) {\n\t\t\twhile ((k > 0) && (s.charAt(k) != s.charAt(i)))\n\t\t\t\tk = p[k - 1];\n\t\t\tif (s.charAt(k) == s.charAt(i))\n\t\t\t\tk++;\n\t\t\tp[i] = k;\n\t\t}\n\t\treturn p;\n\t}\n\n\tpublic static int[] suffixArray(CharSequence s) {\n\t\tint length = s.length();\n\t\tint[] result = new int[length];\n\t\tfor (int i = 0; i < length; i++)\n\t\t\tresult[i] = length - i - 1;\n\t\tfinal long[] type = new long[length];\n\t\tfor (int i = 0; i < length; i++)\n\t\t\ttype[i] = s.charAt(i);\n\t\tfinal long[] nextType = new long[length];\n\t\tint curLength = 1;\n\t\tArrayUtils.sort(result, new IntComparator() {\n\t\t\tpublic int compare(Integer first, Integer second) {\n\t\t\t\treturn IntegerUtils.longCompare(type[first], type[second]);\n\t\t\t}\n\t\t});\n\t\twhile (curLength < length) {\n\t\t\tfor (int i = 0; i < length; i++)\n\t\t\t\tnextType[i] = (type[i] << 32)\n\t\t\t\t\t\t+ (i + curLength < length ? type[i + curLength] : -1);\n\t\t\tArrayUtils.sort(result, new IntComparator() {\n\t\t\t\tpublic int compare(Integer first, Integer second) {\n\t\t\t\t\treturn IntegerUtils.longCompare(nextType[first],\n\t\t\t\t\t\t\tnextType[second]);\n\t\t\t\t}\n\t\t\t});\n\t\t\tlong currentType = nextType[result[0]];\n\t\t\tlong currentIndex = 0;\n\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\tif (nextType[result[i]] != currentType) {\n\t\t\t\t\tcurrentIndex++;\n\t\t\t\t\tcurrentType = nextType[result[i]];\n\t\t\t\t}\n\t\t\t\ttype[result[i]] = currentIndex;\n\t\t\t}\n\t\t\tcurLength <<= 1;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static int[][] buildPrefixAutomaton(CharSequence s) {\n\t\treturn buildPrefixAutomaton(s, 'a', 'z');\n\t}\n\n\tpublic static int[][] buildPrefixAutomaton(CharSequence s, char from,\n\t\t\tchar to) {\n\t\tint[] prefixFunction = prefixFunction(s);\n\t\tint length = to - from + 1;\n\t\tint[][] result = new int[s.length() + 1][length];\n\t\tresult[0][s.charAt(0) - from] = 1;\n\t\tfor (int i = 1; i <= s.length(); i++) {\n\t\t\tSystem.arraycopy(result[prefixFunction[i - 1]], 0, result[i], 0,\n\t\t\t\t\tlength);\n\t\t\tif (i != s.length())\n\t\t\t\tresult[i][s.charAt(i) - from] = i + 1;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static boolean contains(final String s, final String target) {\n\t\tint[] z = zAlgorithm(new CharSequence() {\n\t\t\tpublic int length() {\n\t\t\t\treturn s.length() + target.length();\n\t\t\t}\n\n\t\t\tpublic char charAt(int index) {\n\t\t\t\tif (index < target.length())\n\t\t\t\t\treturn target.charAt(index);\n\t\t\t\treturn s.charAt(index - target.length());\n\t\t\t}\n\n\t\t\tpublic CharSequence subSequence(int start, int end) {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t});\n\t\tfor (int i = target.length(); i < z.length; i++) {\n\t\t\tif (z[i] >= target.length())\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static int[] suffixArray(String s) {\n\t\tint length = s.length();\n\t\tint[] position = new int[length];\n\t\tint[] count = new int[Math.max(256, length)];\n\t\tint[] order = new int[length];\n\t\tfor (int i = 0; i < length; ++i)\n\t\t\tcount[s.charAt(i)]++;\n\t\tfor (int i = 1; i < 256; ++i)\n\t\t\tcount[i] += count[i - 1];\n\t\tfor (int i = 0; i < length; ++i)\n\t\t\tposition[--count[s.charAt(i)]] = i;\n\t\torder[position[0]] = 0;\n\t\tint currentClass = 0;\n\t\tfor (int i = 1; i < length; ++i) {\n\t\t\tif (s.charAt(position[i]) != s.charAt(position[i - 1]))\n\t\t\t\tcurrentClass++;\n\t\t\torder[position[i]] = currentClass;\n\t\t}\n\t\tint[] nextPosition = new int[length];\n\t\tint[] nextOrder = new int[length];\n\t\tfor (int h = 0; (1 << h) < length; h++) {\n\t\t\tfor (int i = 0; i < length; ++i) {\n\t\t\t\tnextPosition[i] = position[i] - (1 << h);\n\t\t\t\tif (nextPosition[i] < 0)\n\t\t\t\t\tnextPosition[i] += length;\n\t\t\t}\n\t\t\tArrays.fill(count, 0);\n\t\t\tfor (int i = 0; i < length; ++i)\n\t\t\t\tcount[order[nextPosition[i]]]++;\n\t\t\tfor (int i = 1; i < currentClass; ++i)\n\t\t\t\tcount[i] += count[i - 1];\n\t\t\tfor (int i = length - 1; i >= 0; --i)\n\t\t\t\tposition[--count[order[nextPosition[i]]]] = nextPosition[i];\n\t\t\tnextOrder[position[0]] = 0;\n\t\t\tcurrentClass = 0;\n\t\t\tfor (int i = 1; i < length; ++i) {\n\t\t\t\tint mid1 = (position[i] + (1 << h));\n\t\t\t\tif (mid1 >= length)\n\t\t\t\t\tmid1 -= length;\n\t\t\t\tint mid2 = (position[i - 1] + (1 << h));\n\t\t\t\tif (mid2 >= length)\n\t\t\t\t\tmid2 -= length;\n\t\t\t\tif (order[position[i]] != order[position[i - 1]]\n\t\t\t\t\t\t|| order[mid1] != order[mid2])\n\t\t\t\t\tcurrentClass++;\n\t\t\t\tnextOrder[position[i]] = currentClass;\n\t\t\t}\n\t\t\tSystem.arraycopy(nextOrder, 0, order, 0, length);\n\t\t}\n\t\treturn order;\n\t}\n}\n\nclass MaxFlow {\n\tprivate final Graph graph;\n\tprivate int source;\n\tprivate int destination;\n\tprivate int[] queue;\n\tprivate int[] distance;\n\tprivate int[] nextEdge;\n\n\tprivate MaxFlow(Graph graph, int source, int destination) {\n\t\tthis.graph = graph;\n\t\tthis.source = source;\n\t\tthis.destination = destination;\n\t\tint vertexCount = graph.vertexCount();\n\t\tqueue = new int[vertexCount];\n\t\tdistance = new int[vertexCount];\n\t\tnextEdge = new int[vertexCount];\n\t}\n\n\tpublic static long dinic(Graph graph, int source, int destination) {\n\t\treturn new MaxFlow(graph, source, destination).dinic();\n\t}\n\n\tprivate long dinic() {\n\t\tlong totalFlow = 0;\n\t\twhile (true) {\n\t\t\tedgeDistances();\n\t\t\tif (distance[destination] == -1)\n\t\t\t\tbreak;\n\t\t\tArrays.fill(nextEdge, -2);\n\t\t\ttotalFlow += dinicImpl(source, Long.MAX_VALUE);\n\t\t}\n\t\treturn totalFlow;\n\t}\n\n\tprivate void edgeDistances() {\n\t\tArrays.fill(distance, -1);\n\t\tdistance[source] = 0;\n\t\tint size = 1;\n\t\tqueue[0] = source;\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tint current = queue[i];\n\t\t\tint id = graph.firstOutbound(current);\n\t\t\twhile (id != -1) {\n\t\t\t\tif (graph.capacity(id) != 0) {\n\t\t\t\t\tint next = graph.destination(id);\n\t\t\t\t\tif (distance[next] == -1) {\n\t\t\t\t\t\tdistance[next] = distance[current] + 1;\n\t\t\t\t\t\tqueue[size++] = next;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tid = graph.nextOutbound(id);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate long dinicImpl(int source, long flow) {\n\t\tif (source == destination)\n\t\t\treturn flow;\n\t\tif (flow == 0 || distance[source] == distance[destination])\n\t\t\treturn 0;\n\t\tint id = nextEdge[source];\n\t\tif (id == -2)\n\t\t\tnextEdge[source] = id = graph.firstOutbound(source);\n\t\tlong totalPushed = 0;\n\t\twhile (id != -1) {\n\t\t\tint nextDestinationID = graph.destination(id);\n\t\t\tif (graph.capacity(id) != 0\n\t\t\t\t\t&& distance[nextDestinationID] == distance[source] + 1) {\n\t\t\t\tlong pushed = dinicImpl(nextDestinationID,\n\t\t\t\t\t\tMath.min(flow, graph.capacity(id)));\n\t\t\t\tif (pushed != 0) {\n\t\t\t\t\tgraph.pushFlow(id, pushed);\n\t\t\t\t\tflow -= pushed;\n\t\t\t\t\ttotalPushed += pushed;\n\t\t\t\t\tif (flow == 0)\n\t\t\t\t\t\treturn totalPushed;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnextEdge[source] = id = graph.nextOutbound(id);\n\t\t}\n\t\treturn totalPushed;\n\t}\n}\n\nclass Heap {\n\tprivate IntComparator comparator;\n\tprivate int size = 0;\n\tprivate int[] elements;\n\tprivate int[] at;\n\n\tpublic Heap(int maxElement) {\n\t\tthis(10, maxElement);\n\t}\n\n\tpublic Heap(IntComparator comparator, int maxElement) {\n\t\tthis(10, comparator, maxElement);\n\t}\n\n\tpublic Heap(int capacity, int maxElement) {\n\t\tthis(capacity, IntComparator.DEFAULT, maxElement);\n\t}\n\n\tpublic Heap(int capacity, IntComparator comparator, int maxElement) {\n\t\tthis.comparator = comparator;\n\t\telements = new int[capacity];\n\t\tat = new int[maxElement];\n\t\tArrays.fill(at, -1);\n\t}\n\n\tpublic int getSize() {\n\t\treturn size;\n\t}\n\n\tpublic void setComparator(IntComparator comparator) {\n\t\tthis.comparator = comparator;\n\t}\n\n\tpublic boolean isEmpty() {\n\t\treturn size == 0;\n\t}\n\n\tpublic int add(int element) {\n\t\tensureCapacity(size + 1);\n\t\telements[size] = element;\n\t\tat[element] = size;\n\t\tshiftUp(size++);\n\t\treturn at[element];\n\t}\n\n\tpublic void shiftUp(int index) {\n\t\t// if (index < 0 || index >= size)\n\t\t// throw new IllegalArgumentException();\n\t\tint value = elements[index];\n\t\twhile (index != 0) {\n\t\t\tint parent = (index - 1) >>> 1;\n\t\t\tint parentValue = elements[parent];\n\t\t\tif (comparator.compare(parentValue, value) <= 0) {\n\t\t\t\telements[index] = value;\n\t\t\t\tat[value] = index;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telements[index] = parentValue;\n\t\t\tat[parentValue] = index;\n\t\t\tindex = parent;\n\t\t}\n\t\telements[0] = value;\n\t\tat[value] = 0;\n\t}\n\n\tpublic void shiftDown(int index) {\n\t\tif (index < 0 || index >= size)\n\t\t\tthrow new IllegalArgumentException();\n\t\twhile (true) {\n\t\t\tint child = (index << 1) + 1;\n\t\t\tif (child >= size)\n\t\t\t\treturn;\n\t\t\tif (child + 1 < size\n\t\t\t\t\t&& comparator.compare(elements[child], elements[child + 1]) > 0)\n\t\t\t\tchild++;\n\t\t\tif (comparator.compare(elements[index], elements[child]) <= 0)\n\t\t\t\treturn;\n\t\t\tswap(index, child);\n\t\t\tindex = child;\n\t\t}\n\t}\n\n\tpublic int getIndex(int element) {\n\t\treturn at[element];\n\t}\n\n\tprivate void swap(int first, int second) {\n\t\tint temp = elements[first];\n\t\telements[first] = elements[second];\n\t\telements[second] = temp;\n\t\tat[elements[first]] = first;\n\t\tat[elements[second]] = second;\n\t}\n\n\tprivate void ensureCapacity(int size) {\n\t\tif (elements.length < size) {\n\t\t\tint[] oldElements = elements;\n\t\t\telements = new int[Math.max(2 * elements.length, size)];\n\t\t\tSystem.arraycopy(oldElements, 0, elements, 0, this.size);\n\t\t}\n\t}\n\n\tpublic int peek() {\n\t\tif (isEmpty())\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\treturn elements[0];\n\t}\n\n\tpublic int poll() {\n\t\tif (isEmpty())\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\tint result = elements[0];\n\t\tat[result] = -1;\n\t\tif (size == 1) {\n\t\t\tsize = 0;\n\t\t\treturn result;\n\t\t}\n\t\telements[0] = elements[--size];\n\t\tat[elements[0]] = 0;\n\t\tshiftDown(0);\n\t\treturn result;\n\t}\n\n\tpublic void clear() {\n\t\tsize = 0;\n\t\tArrays.fill(at, -1);\n\t}\n}\n\nclass ShortestDistance {\n\tpublic static Pair<long[], int[]> dijkstraAlgorithm(Graph graph, int source) {\n\t\tint vertexCount = graph.vertexCount();\n\t\tfinal long[] distance = new long[vertexCount];\n\t\tint[] last = new int[vertexCount];\n\t\tArrays.fill(distance, Long.MAX_VALUE);\n\t\tArrays.fill(last, -1);\n\t\tdistance[source] = 0;\n\t\tif (graph.isSparse()) {\n\t\t\tHeap heap = new Heap(vertexCount, new IntComparator() {\n\t\t\t\tpublic int compare(Integer first, Integer second) {\n\t\t\t\t\treturn IntegerUtils.longCompare(distance[first],\n\t\t\t\t\t\t\tdistance[second]);\n\t\t\t\t}\n\t\t\t}, vertexCount);\n\t\t\theap.add(source);\n\t\t\twhile (!heap.isEmpty()) {\n\t\t\t\tint current = heap.poll();\n\t\t\t\tint id = graph.firstOutbound(current);\n\t\t\t\twhile (id != -1) {\n\t\t\t\t\tint next = graph.destination(id);\n\t\t\t\t\tlong total = graph.weight(id) + distance[current];\n\t\t\t\t\tif (distance[next] > total) {\n\t\t\t\t\t\tdistance[next] = total;\n\t\t\t\t\t\tif (heap.getIndex(next) == -1)\n\t\t\t\t\t\t\theap.add(next);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\theap.shiftUp(heap.getIndex(next));\n\t\t\t\t\t\tlast[next] = id;\n\t\t\t\t\t}\n\t\t\t\t\tid = graph.nextOutbound(id);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tboolean[] visited = new boolean[vertexCount];\n\t\t\tfor (int i = 0; i < vertexCount; i++) {\n\t\t\t\tint index = -1;\n\t\t\t\tlong length = Long.MAX_VALUE;\n\t\t\t\tfor (int j = 0; j < vertexCount; j++) {\n\t\t\t\t\tif (!visited[j] && distance[j] < length) {\n\t\t\t\t\t\tlength = distance[j];\n\t\t\t\t\t\tindex = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (index == -1)\n\t\t\t\t\tbreak;\n\t\t\t\tvisited[index] = true;\n\t\t\t\tint id = graph.firstOutbound(index);\n\t\t\t\twhile (id != -1) {\n\t\t\t\t\tint next = graph.destination(id);\n\t\t\t\t\tif (!visited[next]) {\n\t\t\t\t\t\tlong total = graph.weight(id) + length;\n\t\t\t\t\t\tif (distance[next] > total) {\n\t\t\t\t\t\t\tdistance[next] = total;\n\t\t\t\t\t\t\tlast[next] = id;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tid = graph.nextOutbound(id);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Pair.makePair(distance, last);\n\t}\n\n\tpublic static Pair<Long, List<Integer>> dijkstraAlgorithm(Graph graph,\n\t\t\tint source, int destination) {\n\t\tif (source == destination)\n\t\t\treturn Pair.makePair(0L, (List<Integer>) new ArrayList<Integer>());\n\t\tPair<long[], int[]> result = dijkstraAlgorithm(graph, source);\n\t\tif (result.second[destination] == -1)\n\t\t\treturn null;\n\t\tList<Integer> path = new ArrayList<Integer>();\n\t\tint id = destination;\n\t\twhile (id != source) {\n\t\t\tpath.add(result.second[id]);\n\t\t\tid = graph.source(result.second[id]);\n\t\t}\n\t\tCollections.reverse(path);\n\t\treturn Pair.makePair(result.first[destination], path);\n\t}\n}\n\nclass ReverseComparator<T extends Comparable<T>> implements Comparator<T> {\n\tpublic int compare(T o1, T o2) {\n\t\treturn o2.compareTo(o1);\n\t}\n}\n\nclass Indexer<K> extends TreeMap<K, Integer> {\n\tprivate int index = 0;\n\n\t@Override\n\tpublic Integer get(Object key) {\n\t\tif (!containsKey(key))\n\t\t\tput((K) key, index++);\n\t\treturn super.get(key);\n\t}\n}\n\nclass Counter<K> extends TreeMap<K, Long> {\n\tpublic Counter() {\n\t\tsuper();\n\t}\n\n\tpublic Counter(int capacity) {\n\t\tsuper();\n\t}\n\n\tpublic long add(K key) {\n\t\tlong result = get(key);\n\t\tput(key, result + 1);\n\t\treturn result + 1;\n\t}\n\n\tpublic void add(K key, long delta) {\n\t\tput(key, get(key) + delta);\n\t}\n\n\t@Override\n\tpublic Long get(Object key) {\n\t\tif (containsKey(key))\n\t\t\treturn super.get(key);\n\t\treturn 0L;\n\t}\n}\n\ninterface StringHash {\n\tlong hash(int from, int to);\n\n\tlong hash(int from);\n\n\tint length();\n}\n\nabstract class AbstractStringHash implements StringHash {\n\tpublic static final long MULTIPLIER;\n\tprotected static final long FIRST_REVERSE_MULTIPLIER;\n\tprotected static final long SECOND_REVERSE_MULTIPLIER;\n\tpublic static final long FIRST_MOD;\n\tpublic static final long SECOND_MOD;\n\n\tstatic {\n\t\tRandom random = new Random(System.currentTimeMillis());\n\t\tFIRST_MOD = IntegerUtils.nextPrime((long) (1e9 + random\n\t\t\t\t.nextInt((int) 1e9)));\n\t\tSECOND_MOD = IntegerUtils.nextPrime((long) (1e9 + random\n\t\t\t\t.nextInt((int) 1e9)));\n\t\tMULTIPLIER = random.nextInt((int) 1e9 - 257) + 257;\n\t\tFIRST_REVERSE_MULTIPLIER = IntegerUtils.reverse(MULTIPLIER, FIRST_MOD);\n\t\tSECOND_REVERSE_MULTIPLIER = IntegerUtils\n\t\t\t\t.reverse(MULTIPLIER, SECOND_MOD);\n\t}\n\n\tpublic long hash(int from) {\n\t\treturn hash(from, length());\n\t}\n}\n\nclass SimpleStringHash extends AbstractStringHash {\n\tprivate static long[] firstReversePower = new long[0];\n\tprivate static long[] secondReversePower = new long[0];\n\n\tprivate final long[] firstHash;\n\tprivate final long[] secondHash;\n\n\tpublic SimpleStringHash(CharSequence string) {\n\t\tint length = string.length();\n\t\tensureCapacity(length);\n\t\tfirstHash = new long[length + 1];\n\t\tsecondHash = new long[length + 1];\n\t\tlong firstPower = 1;\n\t\tlong secondPower = 1;\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tfirstHash[i + 1] = (firstHash[i] + string.charAt(i) * firstPower)\n\t\t\t\t\t% FIRST_MOD;\n\t\t\tsecondHash[i + 1] = (secondHash[i] + string.charAt(i) * secondPower)\n\t\t\t\t\t% SECOND_MOD;\n\t\t\tfirstPower *= MULTIPLIER;\n\t\t\tfirstPower %= FIRST_MOD;\n\t\t\tsecondPower *= MULTIPLIER;\n\t\t\tsecondPower %= SECOND_MOD;\n\t\t}\n\t}\n\n\tprivate void ensureCapacity(int length) {\n\t\tif (firstReversePower.length >= length)\n\t\t\treturn;\n\t\tlength = Math.max(length + 1, firstReversePower.length << 1);\n\t\tlong[] oldFirst = firstReversePower;\n\t\tlong[] oldSecond = secondReversePower;\n\t\tfirstReversePower = new long[length];\n\t\tsecondReversePower = new long[length];\n\t\tSystem.arraycopy(oldFirst, 0, firstReversePower, 0, oldFirst.length);\n\t\tSystem.arraycopy(oldSecond, 0, secondReversePower, 0, oldSecond.length);\n\t\tfirstReversePower[0] = secondReversePower[0] = 1;\n\t\tfor (int i = Math.max(oldFirst.length, 1); i < length; i++) {\n\t\t\tfirstReversePower[i] = firstReversePower[i - 1]\n\t\t\t\t\t* FIRST_REVERSE_MULTIPLIER % FIRST_MOD;\n\t\t\tsecondReversePower[i] = secondReversePower[i - 1]\n\t\t\t\t\t* SECOND_REVERSE_MULTIPLIER % SECOND_MOD;\n\t\t}\n\t}\n\n\tpublic long hash(int from, int to) {\n\t\treturn (((firstHash[to] - firstHash[from] + FIRST_MOD)\n\t\t\t\t* firstReversePower[from] % FIRST_MOD) << 32)\n\t\t\t\t+ ((secondHash[to] - secondHash[from] + SECOND_MOD)\n\t\t\t\t\t\t* secondReversePower[from] % SECOND_MOD);\n\t}\n\n\tpublic int length() {\n\t\treturn firstHash.length - 1;\n\t}\n}\n\nclass SubstringAutomaton {\n\tpublic int[][] edges;\n\tpublic int[] ends;\n\n\tpublic SubstringAutomaton(String[] words) {\n\t\tthis(words, 'a', 'z');\n\t}\n\n\tpublic SubstringAutomaton(String[] words, char first, char last) {\n\t\tIndexer<Long> indexer = new Indexer<>();\n\t\tCounter<Long> fullWords = new Counter<>();\n\t\tStringHash[] hashes = new StringHash[words.length];\n\t\tint totalLength = 0;\n\t\tfor (int i = 0; i < words.length; i++) {\n\t\t\tString s = words[i];\n\t\t\thashes[i] = new SimpleStringHash(s);\n\t\t\tfor (int j = 0; j <= s.length(); j++)\n\t\t\t\tindexer.get(hashes[i].hash(0, j));\n\t\t\tfullWords.add(hashes[i].hash(0));\n\t\t\ttotalLength += s.length();\n\t\t}\n\t\tint size = indexer.size();\n\t\tedges = new int[size][last - first + 1];\n\t\tends = new int[size];\n\t\tint[] link = new int[size];\n\t\tArrays.fill(link, -1);\n\t\tint[] start = new int[size];\n\t\tArrays.fill(start, -1);\n\t\tint[] next = new int[totalLength];\n\t\tint[] to = new int[totalLength];\n\t\tint index = 0;\n\t\tGraph graph = new Graph(size);\n\t\tint[] length = new int[size];\n\t\tfor (int i = 0; i < words.length; i++) {\n\t\t\tString s = words[i];\n\t\t\tfor (int j = 0; j <= s.length(); j++) {\n\t\t\t\tint at = indexer.get(hashes[i].hash(0, j));\n\t\t\t\tif (j != s.length()) {\n\t\t\t\t\tto[index] = i;\n\t\t\t\t\tnext[index] = start[at];\n\t\t\t\t\tstart[at] = index++;\n\t\t\t\t}\n\t\t\t\tif (link[at] == -1) {\n\t\t\t\t\tlength[at] = j;\n\t\t\t\t\tfor (int k = 1; k <= j; k++) {\n\t\t\t\t\t\tlong key = hashes[i].hash(k, j);\n\t\t\t\t\t\tif (indexer.containsKey(key)) {\n\t\t\t\t\t\t\tlink[at] = indexer.get(key);\n\t\t\t\t\t\t\tgraph.addSimpleEdge(link[at], at);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int k = 0; k <= j; k++)\n\t\t\t\t\t\tends[at] += fullWords.get(hashes[i].hash(k, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[] queue = new int[size];\n\t\tint count = 1;\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tint current = queue[i];\n\t\t\tfor (int j = start[current]; j != -1; j = next[j]) {\n\t\t\t\tint at = to[j];\n\t\t\t\tedges[current][words[at].charAt(length[current]) - first] = indexer\n\t\t\t\t\t\t.get(hashes[at].hash(0, length[current] + 1));\n\t\t\t}\n\t\t\tfor (int j = graph.firstOutbound(current); j != -1; j = graph\n\t\t\t\t\t.nextOutbound(j)) {\n\t\t\t\tint at = graph.destination(j);\n\t\t\t\tqueue[count++] = at;\n\t\t\t\tSystem.arraycopy(edges[current], 0, edges[at], 0, last - first\n\t\t\t\t\t\t+ 1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass MinCostFlow {\n\tprivate final Graph graph;\n\tprivate final int source;\n\tprivate final int destination;\n\tprivate final long[] phi;\n\tprivate final long[] dijkstraResult;\n\tprivate final int[] lastEdge;\n\tprivate final Heap heap;\n\tprivate final int vertexCount;\n\tprivate final int[] visited;\n\tprivate int visitIndex;\n\n\tpublic MinCostFlow(Graph graph, int source, int destination,\n\t\t\tboolean hasNegativeEdges) {\n\t\tthis.graph = graph;\n\t\tthis.source = source;\n\t\tthis.destination = destination;\n\t\tvertexCount = graph.vertexCount();\n\t\tphi = new long[vertexCount];\n\t\tif (hasNegativeEdges)\n\t\t\tfordBellman();\n\t\tdijkstraResult = new long[vertexCount];\n\t\tlastEdge = new int[vertexCount];\n\t\tif (graph.isSparse()) {\n\t\t\theap = new Heap(vertexCount, new IntComparator() {\n\t\t\t\tpublic int compare(Integer first, Integer second) {\n\t\t\t\t\treturn IntegerUtils.longCompare(dijkstraResult[first],\n\t\t\t\t\t\t\tdijkstraResult[second]);\n\t\t\t\t}\n\t\t\t}, vertexCount);\n\t\t\tvisited = null;\n\t\t} else {\n\t\t\theap = null;\n\t\t\tvisited = new int[vertexCount];\n\t\t}\n\t}\n\n\tprivate void fordBellman() {\n\t\tArrays.fill(phi, Long.MAX_VALUE);\n\t\tphi[source] = 0;\n\t\tboolean[] inQueue = new boolean[vertexCount];\n\t\tint[] queue = new int[vertexCount + 1];\n\t\tqueue[0] = source;\n\t\tinQueue[source] = true;\n\t\tint stepCount = 0;\n\t\tint head = 0;\n\t\tint end = 1;\n\t\tint maxSteps = 2 * vertexCount * vertexCount;\n\t\twhile (head != end) {\n\t\t\tint vertex = queue[head++];\n\t\t\tif (head == queue.length)\n\t\t\t\thead = 0;\n\t\t\tinQueue[vertex] = false;\n\t\t\tint edgeID = graph.firstOutbound(vertex);\n\t\t\twhile (edgeID != -1) {\n\t\t\t\tlong total = phi[vertex] + graph.weight(edgeID);\n\t\t\t\tint destination = graph.destination(edgeID);\n\t\t\t\tif (graph.capacity(edgeID) != 0 && phi[destination] > total) {\n\t\t\t\t\tphi[destination] = total;\n\t\t\t\t\tif (!inQueue[destination]) {\n\t\t\t\t\t\tqueue[end++] = destination;\n\t\t\t\t\t\tinQueue[destination] = true;\n\t\t\t\t\t\tif (end == queue.length)\n\t\t\t\t\t\t\tend = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tedgeID = graph.nextOutbound(edgeID);\n\t\t\t}\n\t\t\tif (++stepCount > maxSteps)\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Graph contains negative cycle\");\n\t\t}\n\t}\n\n\tpublic static Pair<Long, Long> minCostMaxFlow(Graph graph, int source,\n\t\t\tint destination, boolean hasNegativeEdges) {\n\t\treturn new MinCostFlow(graph, source, destination, hasNegativeEdges)\n\t\t\t\t.minCostMaxFlow();\n\t}\n\n\tpublic static Pair<Long, Long> minCostMaxFlow(Graph graph, int source,\n\t\t\tint destination, boolean hasNegativeEdges, long maxFlow) {\n\t\treturn new MinCostFlow(graph, source, destination, hasNegativeEdges)\n\t\t\t\t.minCostMaxFlow(maxFlow);\n\t}\n\n\tpublic Pair<Long, Long> minCostMaxFlow() {\n\t\treturn minCostMaxFlow(Long.MAX_VALUE);\n\t}\n\n\tpublic Pair<Long, Long> minCostMaxFlow(long maxFlow) {\n\t\tlong cost = 0;\n\t\tlong flow = 0;\n\t\twhile (maxFlow != 0) {\n\t\t\tif (graph.isSparse())\n\t\t\t\tdijkstraAlgorithm();\n\t\t\telse\n\t\t\t\tdijkstraAlgorithmFull();\n\t\t\tif (lastEdge[destination] == -1)\n\t\t\t\treturn Pair.makePair(cost, flow);\n\t\t\tfor (int i = 0; i < dijkstraResult.length; i++) {\n\t\t\t\tif (dijkstraResult[i] != Long.MAX_VALUE)\n\t\t\t\t\tphi[i] += dijkstraResult[i];\n\t\t\t}\n\t\t\tint vertex = destination;\n\t\t\tlong currentFlow = maxFlow;\n\t\t\tlong currentCost = 0;\n\t\t\twhile (vertex != source) {\n\t\t\t\tint edgeID = lastEdge[vertex];\n\t\t\t\tcurrentFlow = Math.min(currentFlow, graph.capacity(edgeID));\n\t\t\t\tcurrentCost += graph.weight(edgeID);\n\t\t\t\tvertex = graph.source(edgeID);\n\t\t\t}\n\t\t\tmaxFlow -= currentFlow;\n\t\t\tcost += currentCost * currentFlow;\n\t\t\tflow += currentFlow;\n\t\t\tvertex = destination;\n\t\t\twhile (vertex != source) {\n\t\t\t\tint edgeID = lastEdge[vertex];\n\t\t\t\tgraph.pushFlow(edgeID, currentFlow);\n\t\t\t\tvertex = graph.source(edgeID);\n\t\t\t}\n\t\t}\n\t\treturn Pair.makePair(cost, flow);\n\t}\n\n\tprivate void dijkstraAlgorithm() {\n\t\tArrays.fill(dijkstraResult, Long.MAX_VALUE);\n\t\tArrays.fill(lastEdge, -1);\n\t\tdijkstraResult[source] = 0;\n\t\theap.add(source);\n\t\twhile (!heap.isEmpty()) {\n\t\t\tint current = heap.poll();\n\t\t\tint edgeID = graph.firstOutbound(current);\n\t\t\twhile (edgeID != -1) {\n\t\t\t\tif (graph.capacity(edgeID) != 0) {\n\t\t\t\t\tint next = graph.destination(edgeID);\n\t\t\t\t\tlong total = graph.weight(edgeID) - phi[next]\n\t\t\t\t\t\t\t+ phi[current] + dijkstraResult[current];\n\t\t\t\t\tif (dijkstraResult[next] > total) {\n\t\t\t\t\t\tdijkstraResult[next] = total;\n\t\t\t\t\t\tif (heap.getIndex(next) == -1)\n\t\t\t\t\t\t\theap.add(next);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\theap.shiftUp(heap.getIndex(next));\n\t\t\t\t\t\tlastEdge[next] = edgeID;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tedgeID = graph.nextOutbound(edgeID);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void dijkstraAlgorithmFull() {\n\t\tvisitIndex++;\n\t\tArrays.fill(dijkstraResult, Long.MAX_VALUE);\n\t\tlastEdge[destination] = -1;\n\t\tdijkstraResult[source] = 0;\n\t\tfor (int i = 0; i < vertexCount; i++) {\n\t\t\tint index = -1;\n\t\t\tlong length = Long.MAX_VALUE;\n\t\t\tfor (int j = 0; j < vertexCount; j++) {\n\t\t\t\tif (visited[j] != visitIndex && dijkstraResult[j] < length) {\n\t\t\t\t\tlength = dijkstraResult[j];\n\t\t\t\t\tindex = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (index == -1) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvisited[index] = visitIndex;\n\t\t\tint edgeID = graph.firstOutbound(index);\n\t\t\twhile (edgeID != -1) {\n\t\t\t\tif (graph.capacity(edgeID) != 0) {\n\t\t\t\t\tint next = graph.destination(edgeID);\n\t\t\t\t\tif (visited[next] != visitIndex) {\n\t\t\t\t\t\tlong total = graph.weight(edgeID) - phi[next]\n\t\t\t\t\t\t\t\t+ phi[index] + length;\n\t\t\t\t\t\tif (dijkstraResult[next] > total) {\n\t\t\t\t\t\t\tdijkstraResult[next] = total;\n\t\t\t\t\t\t\tlastEdge[next] = edgeID;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tedgeID = graph.nextOutbound(edgeID);\n\t\t\t}\n\t\t}\n\t}\n}\n\nabstract class IntList {\n\tpublic abstract int get(int index);\n\n\tpublic abstract void set(int index, int value);\n\n\tpublic abstract int size();\n\n\tpublic abstract void add(int value);\n}\n\nclass SuffixAutomaton {\n\tpublic final int[] length;\n\tpublic final int[] link;\n\tpublic final int[] first;\n\tpublic final int[] next;\n\tpublic final int[] to;\n\tpublic final int[] label;\n\tpublic int size;\n\tpublic int last;\n\tpublic int edgeSize;\n\n\tpublic SuffixAutomaton(final CharSequence s) {\n\t\tthis(new IntList() {\n\t\t\t@Override\n\t\t\tpublic int get(int index) {\n\t\t\t\treturn s.charAt(index);\n\t\t\t}\n\n\t\t\tpublic void set(int index, int value) {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn s.length();\n\t\t\t}\n\n\t\t\tpublic void add(int value) {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic SuffixAutomaton(IntList s) {\n\t\tint count = s.size();\n\t\tlength = new int[2 * count + 1];\n\t\tlink = new int[2 * count + 1];\n\t\tfirst = new int[2 * count + 1];\n\t\tnext = new int[4 * count];\n\t\tlabel = new int[4 * count];\n\t\tto = new int[4 * count];\n\t\tArrays.fill(first, -1);\n\t\tlink[0] = -1;\n\t\tsize = 1;\n\t\tedgeSize = 0;\n\t\tlast = 0;\n\t\tfor (int i = 0; i < s.size(); i++) {\n\t\t\tint c = s.get(i);\n\t\t\tint current = size++;\n\t\t\tlength[current] = length[last] + 1;\n\t\t\tfor (int previous = last;; previous = link[previous]) {\n\t\t\t\tif (previous == -1) {\n\t\t\t\t\tlink[current] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint index = findEdge(previous, c);\n\t\t\t\tif (index != -1) {\n\t\t\t\t\tint curLink = to[index];\n\t\t\t\t\tif (length[previous] + 1 == length[curLink])\n\t\t\t\t\t\tlink[current] = curLink;\n\t\t\t\t\telse {\n\t\t\t\t\t\tint clone = size++;\n\t\t\t\t\t\tlength[clone] = length[previous] + 1;\n\t\t\t\t\t\tlink[clone] = link[curLink];\n\t\t\t\t\t\tint linkEdge = first[curLink];\n\t\t\t\t\t\twhile (linkEdge != -1) {\n\t\t\t\t\t\t\tnext[edgeSize] = first[clone];\n\t\t\t\t\t\t\tfirst[clone] = edgeSize;\n\t\t\t\t\t\t\tlabel[edgeSize] = label[linkEdge];\n\t\t\t\t\t\t\tto[edgeSize++] = to[linkEdge];\n\t\t\t\t\t\t\tlinkEdge = next[linkEdge];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (; previous != -1; previous = link[previous]) {\n\t\t\t\t\t\t\tint edge = findEdge(previous, c);\n\t\t\t\t\t\t\tif (edge == -1 || to[edge] != curLink)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tto[edge] = clone;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlink[current] = link[curLink] = clone;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnext[edgeSize] = first[previous];\n\t\t\t\tfirst[previous] = edgeSize;\n\t\t\t\tlabel[edgeSize] = c;\n\t\t\t\tto[edgeSize++] = current;\n\t\t\t}\n\t\t\tlast = current;\n\t\t}\n\t}\n\n\tpublic int findEdge(int vertex, int label) {\n\t\tint edge = first[vertex];\n\t\twhile (edge != -1) {\n\t\t\tif (this.label[edge] == label)\n\t\t\t\treturn edge;\n\t\t\tedge = next[edge];\n\t\t}\n\t\treturn -1;\n\t}\n}\n\nclass StronglyConnectedComponents {\n\tprivate final Graph graph;\n\tprivate int[] order;\n\tprivate boolean[] visited;\n\tprivate int index = 0;\n\tprivate int vertexCount;\n\tprivate int[] condensed;\n\tprivate Set<Integer> next;\n\n\tprivate StronglyConnectedComponents(Graph graph) {\n\t\tthis.graph = graph;\n\t\tvertexCount = graph.vertexCount();\n\t\torder = new int[vertexCount];\n\t\tvisited = new boolean[vertexCount];\n\t\tcondensed = new int[vertexCount];\n\t}\n\n\tpublic static Pair<int[], Graph> kosaraju(Graph graph) {\n\t\treturn new StronglyConnectedComponents(graph).kosaraju();\n\t}\n\n\tprivate Pair<int[], Graph> kosaraju() {\n\t\tfor (int i = 0; i < vertexCount; i++) {\n\t\t\tif (!visited[i])\n\t\t\t\tfirstDFS(i);\n\t\t}\n\t\tArrays.fill(visited, false);\n\t\tGraph result = new Graph(0);\n\t\tindex = 0;\n\t\tfor (int i = vertexCount - 1; i >= 0; i--) {\n\t\t\tif (!visited[order[i]]) {\n\t\t\t\tnext = new TreeSet<Integer>();\n\t\t\t\tsecondDFS(order[i]);\n\t\t\t\tresult.addVertices(1);\n\t\t\t\tfor (int set : (Integer[]) next.toArray())\n\t\t\t\t\tresult.addSimpleEdge(set, index);\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t\treturn Pair.makePair(condensed, result);\n\t}\n\n\tprivate void secondDFS(int vertexID) {\n\t\tif (visited[vertexID]) {\n\t\t\tif (condensed[vertexID] != index)\n\t\t\t\tnext.add(condensed[vertexID]);\n\t\t\treturn;\n\t\t}\n\t\tcondensed[vertexID] = index;\n\t\tvisited[vertexID] = true;\n\t\tint edgeID = graph.firstInbound(vertexID);\n\t\twhile (edgeID != -1) {\n\t\t\tsecondDFS(graph.source(edgeID));\n\t\t\tedgeID = graph.nextInbound(edgeID);\n\t\t}\n\t}\n\n\tprivate void firstDFS(int vertexID) {\n\t\tif (visited[vertexID])\n\t\t\treturn;\n\t\tvisited[vertexID] = true;\n\t\tint edgeID = graph.firstOutbound(vertexID);\n\t\twhile (edgeID != -1) {\n\t\t\tfirstDFS(graph.destination(edgeID));\n\t\t\tedgeID = graph.nextOutbound(edgeID);\n\t\t}\n\t\torder[index++] = vertexID;\n\t}\n}"
        },
        {
            "language": 1,
            "solution": "from sys import stdout\nfrom itertools import product, islice, izip\ndef main():\n    n, k, d = map(int, raw_input().split())\n    a = [x for x in izip(*islice(product(*(xrange(1, min(k,n)+1) for _ in xrange(d))), 0, n))]\n    if len(a[0]) >= n:\n        stdout.write('\\n'.join(' '.join(map(str, x)) for x in a))\n    else:\n        stdout.write(\"-1\")\nmain()\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class PashmakAndBuses {\n    public static void main(String[] args) throws Exception {\n        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n        String l[] = bf.readLine().split(\" \");\n        int n = Integer.parseInt(l[0]);\n        int k = Integer.parseInt(l[1]);\n        int d = Integer.parseInt(l[2]);\n\n        int arr[][] = new int[n][d];\n        Arrays.fill(arr[0], 1);\n        boolean flag = true;\n        loop: for (int i = 1; i < n; i++) {\n            arr[i] = arr[i - 1].clone();\n            for (int j = 0; j < d; j++) {\n                if (arr[i][j] < k) {\n                    arr[i][j]++;\n                    continue loop;\n                } else {\n                    arr[i][j] = 1;\n                }\n            }\n            flag = false;\n            break;\n        }\n        if (flag) {\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < d; i++) {\n                for (int j = 0; j < n; j++) {\n                    sb.append(arr[j][i] + \" \");\n                }\n                sb.append(\"\\n\");\n            }\n            System.out.print(sb);\n        } else {\n            System.out.println(-1);\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long x, y, z, ans = 1, arr[1000][1000], c;\nvoid tot(int cnt) {\n  if (c == x - 1) {\n    for (int i = 0; i < z; i++) {\n      for (int j = 0; j < x; j++) {\n        printf(\"%I64d \", arr[j][i] + 1);\n      }\n      printf(\"\\n\");\n    }\n    exit(0);\n  }\n  if (cnt == z) {\n    for (int i = 0; i < cnt; i++) {\n      arr[c + 1][i] = arr[c][i];\n    }\n    c++;\n    return;\n  }\n  for (int i = 0; i < y; i++) {\n    arr[c][cnt] = i;\n    tot(cnt + 1);\n  }\n}\nbool power(long long a, long long b) {\n  for (int i = 0; i < b; i++) {\n    ans *= a;\n    if (ans >= x) return 1;\n  }\n  return 0;\n}\nint main() {\n  cin >> x >> y >> z;\n  if (power(y, z) == 1)\n    tot(0);\n  else\n    printf(\"-1\\n\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, k, d;\n  cin >> n >> k >> d;\n  bool done = false;\n  long long tot = 1;\n  for (int i = 0; (i) < (d); i++) {\n    tot *= k;\n    if (tot >= n) {\n      done = true;\n      break;\n    }\n  }\n  if (!done) {\n    cout << -1 << endl;\n    return 0;\n  }\n  int arr[1001][1001];\n  for (int i = 0; (i) < (n); i++) {\n    for (int j = 0; (j) < (d); j++) arr[i][j] = 1;\n    if (i) {\n      arr[i][d - 1] = arr[i - 1][d - 1] + 1;\n    }\n  }\n  for (int i = 1; (i) <= (n - 1); i++) {\n    int ind = d - 1;\n    while (arr[i][ind] > k) {\n      int temp = arr[i][ind];\n      arr[i][ind] %= k;\n      if (!arr[i][ind]) {\n        arr[i][ind] = k;\n        temp -= k;\n      }\n      arr[i][--ind] += temp / k;\n    }\n  }\n  for (int i = 0; (i) < (d); i++) {\n    for (int j = 0; (j) < (n); j++) {\n      cout << arr[j][i] << \" \";\n    }\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n \n \npublic class Main {\n\tstatic int[] nxtseq(int[]seq,int k) {\n\t\tfor(int i=seq.length-1;i>=0;i--) {\n\t\t\tseq[i]++;\n\t\t\tif(seq[i]<=k)break;\n\t\t\tseq[i]=1;\n\t\t}\n\t\treturn seq;\n\t}\n\tpublic static void main(String[] args) throws Exception {\n\t\tMScanner sc=new MScanner(System.in);\n\t\tPrintWriter pw=new PrintWriter(System.out);\n\t\tint n=sc.nextInt(),k=sc.nextInt(),d=sc.nextInt();\n\t\tlong base=1;\n\t\tboolean can=false;\n\t\tfor(int i=0;i<d;i++) {\n\t\t\tbase*=k;\n\t\t\tif(base>=n) {\n\t\t\t\tcan=true;break;\n\t\t\t}\n\t\t}\n\t\tif(!can) {\n\t\t\tpw.println(-1);\n\t\t}\n\t\telse {\n\t\t\tint[]seq=new int[d];Arrays.fill(seq, 1);\n\t\t\tint[][]ans=new int[d][n];\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\tfor(int i=0;i<d;i++) {\n\t\t\t\t\tans[i][j]=seq[i];\n\t\t\t\t}\n\t\t\t\tseq=nxtseq(seq,k);\n\t\t\t}\n\t\t\tfor(int i=0;i<d;i++) {\n\t\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\t\tpw.print(ans[i][j]+\" \");\n\t\t\t\t}\n\t\t\t\tpw.println();\n\t\t\t}\n\t\t}\n\t\tpw.flush();\n\t}\n    static class MScanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n \n\t\tpublic MScanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n \n\t\tpublic MScanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n \n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n \n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n \n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n \n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.math.BigInteger;\nimport java.util.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\n\npublic class Main {\n    FastIO io;\n\n    int n, d, k;\n\n    // File names!!!\n\n    void solve() throws Exception {\n        n = io.nextInt();\n        k = io.nextInt();\n        d = io.nextInt();\n        if (BigInteger.valueOf(k).pow(d).compareTo(BigInteger.valueOf(n)) < 0) {\n            io.println(-1);\n            return;\n        }\n        int[][] ans = new int[n][];\n        int[] t = new int[d];\n        for (int i = 0; i < n; i++) {\n            ans[i] = Arrays.copyOf(t, t.length);\n            t[d - 1]++;\n            for (int j = d - 1; j > 0; j--) {\n                t[j - 1] += t[j] / k;\n                t[j] %= k;\n            }\n        }\n        for (int i = 0; i < d; i++) {\n            for (int j = 0; j < n; j++) {\n                io.print(ans[j][i] + 1);\n                io.print(\" \");\n            }\n            io.println();\n        }\n    }\n\n    void run() {\n        try {\n            io = new FastIO();\n            solve();\n            io.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(abs(-1));\n        }\n    }\n\n    public static void main(String[] args) {\n        try {\n            Locale.setDefault(Locale.US);\n        } catch (Exception ignore) {\n        }\n        new Main().run();\n    }\n\n    class FastIO extends PrintWriter {\n        private BufferedReader in;\n        private StringTokenizer stok;\n\n        FastIO() {\n            super(System.out);\n            in = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        FastIO(String s) throws FileNotFoundException {\n            super(\"\".equals(s) ? \"output.txt\" : s + \".out\");\n            in = new BufferedReader(new FileReader(\"\".equals(s) ? \"input.txt\" : s + \".in\"));\n        }\n\n        @Override\n        public void close() {\n            super.close();\n            try {\n                in.close();\n            } catch (IOException ignored) {\n            }\n        }\n\n        String next() {\n            while (stok == null || !stok.hasMoreTokens()) {\n                try {\n                    stok = new StringTokenizer(in.readLine());\n                } catch (Exception e) {\n                    return null;\n                }\n            }\n            return stok.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        char nextChar() {\n            try {\n                return (char) in.read();\n            } catch (IOException e) {\n                return (char) -1;\n            }\n        }\n\n        String nextLine() {\n            try {\n                return in.readLine();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n\n        char[] nextCharArray() {\n            return next().toCharArray();\n        }\n    }\n\n    void shuffleSort(int[] a) {\n        Random rand = new Random();\n        for (int i = 1; i < a.length; i++) {\n            int x = rand.nextInt(i + 1);\n            int chg = a[i];\n            a[i] = a[x];\n            a[x] = chg;\n        }\n        Arrays.sort(a);\n    }\n\n    class IntArray {\n        private int capacity;\n        private int[] data;\n        private int size = 0;\n\n        IntArray(int capacity) {\n            this.capacity = capacity;\n            this.data = new int[capacity];\n        }\n\n        IntArray() {\n            this(16);\n        }\n\n        int get(int index) {\n            return data[index];\n        }\n\n        void add(int x) {\n            if (size == capacity) {\n                int[] newData = new int[capacity * 2];\n                System.arraycopy(data, 0, newData, 0, capacity);\n                data = newData;\n                capacity *= 2;\n            }\n            data[size++] = x;\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class pashmakAndBuses {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner scnr = new Scanner(System.in);\n\t\tint student = scnr.nextInt();\n\t\tint bus = scnr.nextInt();\n\t\tint day = scnr.nextInt();\n\t\tint cycle = 1;\n\t\tscnr.close();\n\n\t\tint detec = 1;\n\t\tfor (int i = 0; i < day; i ++){\n\t\t\tdetec = detec * bus;\n\n\t\t\tif (detec >= student){\n\t\t\t\tdetec = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcycle = detec;\n\n\t\t}\n\t\tif (detec != -1){\n\t\t\tSystem.out.print(-1);\n\t\t}\n\t\telse{\n\t\t\tint printNo = 1;\n\t\t\tint count;\n\t\t\twhile (cycle != 0 && day != 0){\n\t\t\t\tcount = cycle;\n\t\t\t\tfor (int j = 0; j < student - 1; j++){\n\t\t\t\t\tSystem.out.print(printNo + \" \");\n\t\t\t\t\tcount --;\n\t\t\t\t\tif (count == 0){\n\t\t\t\t\t\tcount = cycle;\n\t\t\t\t\t\tprintNo = (printNo % bus)+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(bus);\n\t\t\t\tday--;\n\t\t\t\tif (cycle == 1){\n\t\t\t\t\tcycle = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcycle = cycle / bus;\n\t\t\t\tprintNo = 1;\n\t\t\t}\n\t\t\tif (day != 0){\n\t\t\t\tString output = \"\";\n\n\t\t\t\tfor (int j = 0; j < student - 1; j++)\n\t\t\t\t\toutput = output + \"1 \";\n\t\t\t\toutput = output + \"1\";\n\t\t\t\tfor (int i = 0; i < day; i ++)\n\t\t\t\t\tSystem.out.println(output);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.DataInputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\npublic class P459C5 {\n    public static void main(String[] args) throws IOException {\n        InputReader2 ir = new InputReader2();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = ir.nextInt();\n        int k = ir.nextInt();\n        int d = ir.nextInt();\n\n        if (k >= n) {\n            StringBuilder sb = new StringBuilder(n * n);\n            for (int i = 1; i <= n; i++) {\n                sb.append(i).append(\" \");\n            }\n            for (int i = 0; i < d; i++) {\n                pw.println(sb);\n            }\n        } else if (k == 1) {\n            pw.println(-1);\n        } else if (pos(n, k, d)) {\n            int[] num = new int[n];\n            for (int i = 0; i < n; i++) {\n                num[i] = i;\n            }\n            for (int i = 1; i <= d; i++) {\n                for (int j = 0; j < n; j++) {\n                    pw.print((num[j] % k) + 1 + \" \");\n                    num[j] /= k;\n                }\n                pw.println();\n            }\n        } else {\n            pw.println(-1);\n        }\n\n        pw.close();\n    }\n\n    private static boolean pos(int n, int k, int d) {\n        long res = 1;\n        for (int i = 0; i < d; i++) {\n            res *= k;\n            if (res >= n) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static class InputReader2 {\n        final private int BUFFER_SIZE = 1 << 16;\n        private final DataInputStream dis;\n        private final byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public InputReader2() {\n            dis = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        private int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = dis.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport static java.lang.Math.*;\nimport static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.Double.parseDouble;\nimport static java.lang.String.*;\n\npublic class Main {\n    \n    static int [][] g;\n    static int n,k,d,ind;\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                                            //(new FileReader(\"input.in\"));\n        StringBuilder out = new StringBuilder();\n        StringTokenizer tk;\n        //PrintWriter pw = new PrintWriter(\"output.out\", \"UTF-8\");\n        \n        tk = new StringTokenizer(in.readLine());\n        n = parseInt(tk.nextToken());\n        k = parseInt(tk.nextToken());\n        d = parseInt(tk.nextToken());\n        \n        if((long)pow(k,d) < n) \n            System.out.println(\"-1\");\n        else {\n            g = new int[d][n];\n            \n            generate(0,new int[d]);\n            \n            for(int i=0; i<d; i++) {\n                out.append(g[i][0]);\n                for(int j=1; j<n; j++)\n                    out.append(\" \").append(g[i][j]);\n                out.append(\"\\n\");\n            }\n            \n            System.out.print(out);\n        }\n    }\n    \n    static void generate(int j,int [] t) {\n        if(ind==n)\n            return;\n        \n        if(j==d) {\n            for(int x=0; x<d; x++)\n                g[x][ind] = t[x];\n            ind++;\n            return;\n        }\n        \n        for(int x=1; x<=k; x++) {\n            t[j] = x;\n            \n            generate(j+1,t);\n            \n            if(ind==n) return;\n        }\n    }\n}"
        },
        {
            "language": 1,
            "solution": "n,k,d=map(int,raw_input().split())\ncombs=k**d\n\ndef nextNum(a,k,d):\n\tst=[]\n\tcount=0\n\twhile count!=d:\n\t\tst.append(a%k+1)\n\t\ta=a/k\n\t\tcount+=1\n\treturn st\nif n>combs:\n\tprint -1\n\n\nelse:\n\tstrs=[]\n\tfor i in range(n):\n\t\tstrs.append(nextNum(i,k,d))\n\tfor i in range(d):\n\t\tfor j in range(n):\n\t\t\tprint strs[j][i],\n\t\tprint \"\"\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class PashmakBuses {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n = sc.nextInt(), k = sc.nextInt(), d = sc.nextInt();\n\t\t\n\t\t// invalid if k ^ d < n\n\t\tlong pow = 1;\n\t\tfor(int i = 0; i < d; i++) {\n\t\t\tpow *= k;\n\t\t\tif(pow > n)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif(pow < n) {\n\t\t\tSystem.out.println(-1);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint res[][] = new int[d][n];\n\t\t\n\t\tfor(int i = 0; i < d; i++)\n\t\t\tres[i][0] = 1;\n\t\t\n\t\tfor(int i = 1; i < n; i++) {\n\t\t\tfor(int j = 0; j < d; j++)\n\t\t\t\tres[j][i] = res[j][i - 1];\n\t\t\tres[d - 1][i]++;\n\t\t\tint last = d - 1;\n\t\t\twhile(res[last][i] > k) {\n\t\t\t\tres[last][i] = 1;\n\t\t\t\tlast--;\n\t\t\t\tres[last][i]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int day = 0; day < d; day++)\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t\tout.print(res[day][i] + (i == n - 1? \"\\n\" : \" \"));\n\t\t\n\t\tout.flush();\n\t\tout.close();\n\t}\n}"
        },
        {
            "language": 1,
            "solution": "n, k, d = map(int, raw_input().strip().split())\nc = 0\ngrid = [[0] * n for i in range(d)]\nif n > k ** d:\n    print -1\n    exit()\n\nfor i in range(n):\n    mod = k\n    cc = c\n    for j in range(d):\n        grid[j][i] = 1 + (cc % mod)\n        cc /= mod        \n    c += 1\n\nprint '\\n'.join(' '.join(str(r) for r in k) for k in grid)\n\n        \n    \n"
        },
        {
            "language": 3,
            "solution": "def f(t):\n    i = -1\n    t[i] += 1\n    while t[i] > k:\n        t[i] = 1\n        i -= 1\n        t[i] += 1\n    return list(map(str, t))\nn, k, d = map(int, input().split())\nif k ** d < n: print(-1)\nelse:\n    t = [1] * d\n    t[-1] = 0\n    s = [f(t) for i in range(n)]\n    print('\\n'.join([' '.join(t) for t in zip(*s)]))"
        },
        {
            "language": 4,
            "solution": "import java.util.InputMismatchException;\nimport java.math.BigInteger;\nimport java.io.*;\nimport java.util.*;\n\n/**\n * Generated by Contest helper plug-in\n * Actual solution is at the bottom\n */\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputReader in = new StreamInputReader(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\trun(in, out);\n\t}\n\n\tpublic static void run(InputReader in, PrintWriter out) {\n\t\tSolver solver = new Task();\n\t\tsolver.solve(1, in, out);\n\t\tExit.exit(in, out);\n\t}\n}\n\nabstract class InputReader {\n\tprivate boolean finished = false;\n\n\tpublic abstract int read();\n\n\tpublic long readLong() {\n\t\treturn new BigInteger(readString()).longValue();\n\t}\n\n\tpublic int readInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuffer res = new StringBuffer();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n\n\tprivate boolean isSpaceChar(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n\n\tpublic void setFinished(boolean finished) {\n\t\tthis.finished = finished;\n\t}\n\n\tpublic abstract void close();\n}\n\nclass StreamInputReader extends InputReader {\n\tprivate InputStream stream;\n\tprivate byte[] buf = new byte[1024];\n\tprivate int curChar, numChars;\n\n\tpublic StreamInputReader(InputStream stream) {\n\t\tthis.stream = stream;\n\t}\n\n\tpublic int read() {\n\t\tif (numChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= numChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (numChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n\n\tpublic void close() {\n\t\ttry {\n\t\t\tstream.close();\n\t\t} catch (IOException ignored) {\n\t\t}\n\t}\n}\n\nclass Exit {\n\tprivate Exit() {\n\t}\n\n\tpublic static void exit(InputReader in, PrintWriter out) {\n\t\tin.setFinished(true);\n\t\tin.close();\n\t\tout.close();\n\t}\n}\n\ninterface Solver {\n\tpublic void solve(int testNumber, InputReader in, PrintWriter out);\n}\n\nclass Task implements Solver {\n\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\t\tint n = in.readInt();\n\t\tint k = in.readInt();\n\t\tint d = in.readInt();\n\t\t\n\t\tif (n > (int)Math.pow(k, d)) {\n\t\t\tSystem.out.println(-1);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t/*\n\t\tif (k>=n) {\n\t\t\tfor (int i = 0; i<d; i++) {\n\t\t\t\tfor (int j = 1; j<=n; j++)\n\t\t\t\t\tout.print(j + \" \");\n\t\t\t\tout.println();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t*/\n\t\t\n\t\tlong rate = (long)Math.pow(k,d);\n\t\t\n\t\tfor (int i = 0; i<d; i++) {\n\t\t\t\n\t\t\trate = 1;\n\t\t\tfor (int j = i+1; j<d; j++) {\n\t\t\t\trate *= k;\n\t\t\t\tif (rate >= n)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint count = 0;\n\t\t\tint at = 1;\n\t\t\t\n\t\t\tfor (int j = 0; j<n; j++) {\n\t\t\t\tout.print(at + \" \");\n\t\t\t\tcount++;\n\t\t\t\tif (count == rate) {\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tat++;\n\t\t\t\t\tif (at>k)\n\t\t\t\t\t\tat = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tout.println();\n\t\t}\n\t\t\n\t}\n}\n\n///\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 2e9 + 9;\nvoid f(vector<int> &V, int k) {\n  reverse((V).begin(), (V).end());\n  for (int i = 0; i < (int)((int)(V.size())); i++) {\n    if (V[i] != k) {\n      V[i]++;\n      reverse((V).begin(), (V).end());\n      return;\n    }\n    V[i] = 1;\n  }\n  reverse((V).begin(), (V).end());\n  return;\n}\nint fi(int n, int b) {\n  n--;\n  if (b == 1) return INF;\n  int ans = 0;\n  while (n) {\n    ans++;\n    n /= b;\n  }\n  return ans;\n}\nint main() {\n  int n, d, k;\n  cin >> n >> k >> d;\n  if (n == 1 and k == 1) {\n    for (int i = 0; i < (int)(d); i++) cout << 1 << endl;\n    return 0;\n  }\n  if (fi(n, k) > d) {\n    cout << -1 << endl;\n    return 0;\n  }\n  vector<int> V(d, 1);\n  vector<vector<int> > ans;\n  for (int i = 0; i < (int)(n); i++) {\n    ans.push_back(V);\n    f(V, k);\n  }\n  for (int i = 0; i < (int)(d); i++) {\n    for (int j = 0; j < (int)(n); j++) cout << ans[j][i] << \" \";\n    cout << endl;\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic class C implements Runnable {\n\tint n, d;\n\tlong k;\n\tint a[][];\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(new C()).start();\n\t}\n\n\tboolean probable;\n\n\t@Override\n\tpublic void run() {\n\t\tScanner reader = new Scanner(System.in);\n\t\tn = reader.nextInt();\n\t\tk = reader.nextLong();\n\t\td = reader.nextInt();\n\t\treader.close();\n\t\tlong quantity = 1;\n\t\tfor (int i = 1; i <= d; i++) {\n\t\t\tquantity *= k;\n\t\t\tif (quantity >= n) {\n\t\t\t\tprobable = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!probable) {\n\t\t\tSystem.out.print(-1);\n\t\t\treturn;\n\t\t}\n\t\ta = new int[d + 1][n + 1];\n\t\tfor (int i = 1; i <= d; i++)\n\t\t\ta[i][1] = 1;\n\t\tfor (int j = 2; j <= n; j++) {\n\t\t\tint x = d;\n\t\t\twhile (a[x][j - 1] == k)\n\t\t\t\tx--;\n\t\t\tfor (int i = d; i > x; i--)\n\t\t\t\ta[i][j] = 1;\n\t\t\ta[x][j] = a[x][j - 1] + 1;\n\t\t\tfor (int i = x - 1; i >= 1; i--)\n\t\t\t\ta[i][j] = a[i][j - 1];\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 1; i <= d; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tsb.append(a[i][j]);\n\t\t\t\tsb.append(\" \");\n\t\t\t}\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\t\tSystem.out.print(sb);\n\t}\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class TaskD {\n\n    final static double EPS = 1e-8;\n\n    public void solve() throws IOException {\n        int n = in.nextInt();\n        int k = in.nextInt();\n        int d = in.nextInt();\n        int good = 1;\n        for (int i = 0; good < n && i < d; ++i) {\n            good *= k;\n        }\n        if (good < n) {\n            out.println(-1);\n            return;\n        }\n        int[][] ans = new int[d][n];\n        for (int i = 0; i < n; ++i) {\n            int val = i;\n            for (int j = 0; j < d; ++j) {\n                ans[j][i] = val % k + 1;\n                val /= k;\n            }\n        }\n        for (int i = 0; i < d; ++i) {\n            for (int j = 0; j < n; ++j) {\n                out.print(ans[i][j] + \" \");\n            }\n            out.println();\n        }\n    }\n\n    static FastReader in;\n    static PrintWriter out;\n    static PrintStream err;\n\n    public static void main(String[] args) throws IOException {\n        try {\n            in = new FastReader();\n            out = new PrintWriter(System.out);\n            err = System.err;\n            new TaskD().solve();\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n}\n\nclass FastReader {\n    BufferedReader br;\n    StringTokenizer in;\n\n    FastReader() {\n        this.br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    FastReader(String filename) {\n        try {\n            this.br = new BufferedReader(new FileReader(filename));\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    public String nextToken() throws IOException {\n        while (in == null || !in.hasMoreTokens()) {\n            in = new StringTokenizer(br.readLine());\n        }\n        return in.nextToken();\n    }\n\n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    public double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    public long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n1, n2, n, k, l, d, i, j, a[1013];\nint main() {\n  cin >> n >> k >> d;\n  n1 = n;\n  while ((n1 > 1) && (i <= d)) {\n    n1 = (n1 + k - 1) / k;\n    ++i;\n  }\n  if (i > d) {\n    cout << \"-1\";\n  } else {\n    for (i = 0; i < n; ++i) {\n      a[i] = i;\n    }\n    n1 = n;\n    for (i = 0; i < d; ++i) {\n      for (j = 0; j < n; ++j) {\n        cout << a[j] % k + 1 << \" \";\n        a[j] /= k;\n      }\n      cout << \"\\n\";\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "import sys\n\nn, k, d = [int(x) for x in raw_input().strip().split()]\n\nif n > k ** d:\n    print -1\n    sys.exit()\n\ndef converttobase(x, b, d):\n    res = []\n    for i in range(d):\n        res = [x % b] + res\n        x /= b\n        if x == 0:\n            break\n    res = [0]*(d - len(res)) + res\n    return res\n\nans = [converttobase(i, k, d) for i in range(n)]\nfor i in range(d):\n    print ' '.join([str(ans[x][i] + 1) for x in range(n)])\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt(), k = in.nextInt(), d = in.nextInt();\n            if (n > Math.pow(k, d)) {\n                out.println(-1);\n                return;\n            }\n            for (int i = 1; i <= d; ++i) {\n                int e = d - i, cur = 1;\n                long step = (int) Math.pow(k, e);\n                for (int j = 1; j <= n; ++j) {\n                    out.print(cur + \" \");\n                    if (j % step == 0) {\n                        cur++;\n                        if (cur > k) cur = 1;\n                    }\n                }\n                out.println();\n            }\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32758);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e9;\nconst int MAX_COUNT = 1e5;\nconst int MOD = 1e9 + 7;\nint main() {\n  ios::sync_with_stdio(false);\n  int n, k, d;\n  cin >> n >> k >> d;\n  if (d < ceil(log(n) / log(k))) {\n    cout << -1 << endl;\n    return 0;\n  }\n  long long period = 1;\n  for (int i = 0; i < (d); ++i) {\n    for (int j = 0; j < (n); ++j) {\n      cout << (j / period) % k + 1 << \" \";\n    }\n    cout << endl;\n    period *= k;\n    period %= 1007;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def add1(array, base):\n    array[-1] += 1\n    array = [0] + array\n    k= len(array)-1\n    while array[k]>=base:\n        array[k] -= base\n        array[k-1] += 1\n        k -= 1\n    if array[0] == 0:\n        return array[1:]\n    return array\n\n\nn, k, d = list(map(int, input().split(' ')))\nif n == 1:\n    for i in range(d):\n        print(1)\n    quit()\nif n > k**d:\n    print(\"-1\")\n\n    quit()\narr = []\narray = [0]*d\nfor i in range(n):\n    arr.append(array)\n    array = add1(array[:], k)\n\nnew = [[0]*len(arr) for _ in range(len(arr[0]))]\nfor i in range(len(arr)):\n    for j in range(len(arr[0])):\n        new[j][i] = arr[i][j]+1\n\nfor i in new:\n    print(' '.join([str(x) for x in i]))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, d;\nvector<vector<int> > v;\nvector<int> va;\nvoid incr(int i) {\n  if (va[i] < k)\n    va[i]++;\n  else {\n    va[i] = 1;\n    incr(i - 1);\n  }\n}\nint main() {\n  scanf(\"%i%i%i\", &n, &k, &d);\n  double nd = n, kd = k, dd = d;\n  double pw = pow(kd, dd);\n  if (nd > pw + 0.5) {\n    printf(\"%i\", -1);\n    exit(0);\n  }\n  va.assign(d, 1);\n  for (int i = 0; i < n; i++) {\n    incr(d - 1);\n    v.push_back(va);\n  }\n  for (int i = 0; i < d; i++) {\n    for (int j = 0; j < n; j++) printf(\"%i \", v[j][i]);\n    printf(\"%c\", '\\n');\n  }\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "def solve(n, k, d):\n    if n > k**d:\n        return [[-1]]\n    res = [[1 for i in range(n)] for j in range(d)]\n    for i in range(n):\n        j, c = i, -1\n        while j > 0:\n            res[c][i] = j % k + 1\n            c -= 1\n            j /= k\n    return res\n\nn, k, d = map(int, raw_input().split())\nres = solve(n, k, d)\nfor i in range(len(res)):\n    print ' '.join(map(str, res[i]))"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt() , k = sc.nextInt(), d = sc.nextInt();\n\t\tlong tmp = 1l;\n\t\tboolean flag = false;\n\t\tfor(int i = 0; i <= d;i++)\n\t\t{\n\t\t\tif(n<=tmp)\n\t\t\t{\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp*=k;\n\t\t}\n\t\tif(!flag)\n\t\t{\n\t\t\tSystem.out.println(-1);\n\t\t\treturn;\n\t\t}\n\t\tint[][] a = new int[n][d];\n\t\tfor(int i = 1; i < n;i++)\n\t\t{\n\t\t\tint carry = 1;\n\t\t\tfor(int j = 0; j < d;j++)\n\t\t\t{\n\t\t\t\tcarry = Math.max(0, carry);\n\t\t\t\ta[i][j] = a[i-1][j] + carry--;\n\t\t\t\tif(a[i][j]==k)\n\t\t\t\t{\n\t\t\t\t\ta[i][j] = 0;\n\t\t\t\t\tcarry=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int j = 0;j<d;j++)\n\t\t{\n\t\t\tfor(int i = 0; i < n;i++)\n\t\t\t\tsb.append(1+a[i][j]+\" \");\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\t\tSystem.out.print(sb);\n\t\t\n\t}\n\t\n\n\tstatic class Scanner \n\t{\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\t\tpublic Scanner(InputStream s){\tbr = new BufferedReader(new InputStreamReader(s));}\n\t\tpublic Scanner(String s) throws FileNotFoundException {br = new BufferedReader(new FileReader(s));}\n\t\tpublic String next() throws IOException \n\t\t{\n\t\t\twhile (st == null || !st.hasMoreTokens()) \n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n\t\tpublic String nextLine() throws IOException {return br.readLine();}\t\t\n\t\tpublic long nextLong() throws IOException {return Long.parseLong(next());}\t\t\n\t\tpublic double nextDouble() throws IOException {return Double.parseDouble(next());}\t\n\t\tpublic char nextChar() throws IOException{return next().charAt(0);}\n\t\tpublic boolean ready() throws IOException {return br.ready();}\n\t\tpublic int[] nextIntArr() throws IOException{\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tint[] res = new int[st.countTokens()];\n\t\t\tfor (int i = 0; i < res.length; i++)\n\t\t\t\tres[i] = nextInt();\n\t\t\treturn res;\n\t\t}\n\t\tpublic char[] nextCharArr() throws IOException{\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tchar[] res = new char[st.countTokens()];\n\t\t\tfor (int i = 0; i < res.length; i++) \n\t\t\t\tres[i] = nextChar();\n\t\t\treturn res;\n\t\t}\n\t}\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\nimport java.util.HashMap;\n\npublic class main /// help from editorial\n{\n    static class Reader \n    { \n        private InputStream mIs;private byte[] buf = new byte[1024];private int curChar,numChars;public Reader() { this(System.in); }public Reader(InputStream is) { mIs = is;} \n        public int read() {if (numChars == -1) throw new InputMismatchException();if (curChar >= numChars) {curChar = 0;try { numChars = mIs.read(buf);} catch (IOException e) { throw new InputMismatchException();}if (numChars <= 0) return -1; }return buf[curChar++];} \n        public String nextLine(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isEndOfLine(c));return res.toString() ;} \n        public String s(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isSpaceChar(c));return res.toString();} \n        public long l(){int c = read();while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }long res = 0; do{ if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read();}while(!isSpaceChar(c));return res * sgn;} \n        public int i(){int c = read() ;while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }int res = 0;do{if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read() ;}while(!isSpaceChar(c));return res * sgn;} \n        public double d() throws IOException {return Double.parseDouble(s()) ;}\n        public boolean isSpaceChar(int c) { return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1; } \n        public boolean isEndOfLine(int c) { return c == '\\n' || c == '\\r' || c == -1; } \n    } \n    \n    \n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    \n    public static void main(String args[])\n    {\n        Reader sc=new Reader();\n        PrintWriter out=new PrintWriter(System.out);\n        int n=sc.i();\n        int k=sc.i();\n        int d=sc.i();\n        long tmp = 1;\n        boolean b=false;\n    \tfor (int i=1; i<=d; i++)\n    \t{\n    \t\ttmp *= k;\n    \t\tif (tmp >= n) \n    \t\t{\n    \t\t\tb = true;\n    \t\t\tbreak;\n    \t\t}\n    \t}\n        if(!b)\n        {\n            System.out.println(-1);\n            System.exit(0);\n        }\n        int arr[][]=new int[n+1][d+1];\n        for(int i=2;i<=n;i++)\n        {\n    \t\tfor(int j=1;j<=d;j++)\n    \t\tarr[i][j]=arr[i-1][j];\n    \t\tarr[i][d]++;\n    \t\tfor(int j=d;j>=1;j--)\n    \t\t{\n    \t\t\tarr[i][j-1]+=(arr[i][j]/k);\n    \t\t\tarr[i][j]%=k;\n    \t\t}\n    \t}\n    \tfor(int j=1;j<=d;j++)\n    \t{\n    \t\tfor(int i=1;i<=n;i++)\n    \t\tout.print(arr[i][j]+1+\" \");\n    \t\tout.println();\n    \t}\n    \tout.flush();\n    }\n}\n"
        },
        {
            "language": 1,
            "solution": "# def gen(n, k, d, l, S):\n\n    # if len(l) >= n:\n    #     return\n    #\n    # if len(S) == d:\n    #     l.append(S[:])\n    # else:\n    #     for i in range(1, k + 1):\n    #         S.append(i)\n    #         gen(n, k, d, l, S)\n    #         S.pop()\n\ndef gen(n, k, d, l):\n\n    S = [0]\n    while len(S) != 0:\n\n        if len(S) - 1 == d:\n            S.pop()\n            l.append(S[:])\n\n            if len(l) >= n:\n                return\n\n        else:\n            if S[-1] < k:\n                S[-1] += 1\n                S.append(0)\n            else:\n                S.pop()\n\ndef main():\n    n, k, d = map(int,raw_input().split())\n\n    res = k\n    for i in range(2, d + 1):\n        if res >= n:\n            break\n        res *= k\n\n    if res < n:\n        print -1\n        exit(0)\n\n    l = []\n    gen(n, k, d, l)\n\n    for j in range(d):\n        for i in range(n):\n            print\"%d \" % (l[i][j],),\n        print '\\n',\n\n    pass\n\nmain()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool cmp(pair<long long, long long> a, pair<long long, long long> b) {\n  if (a.first == b.first)\n    return a.second < b.second;\n  else\n    return a.first < b.first;\n}\nlong long exp(long long a, long long b) {\n  long long ans = 1;\n  while (b != 0) {\n    if (b % 2) ans = ans * a;\n    a = a * a;\n    b /= 2;\n  }\n  return ans;\n}\nlong long arr[1005][1005];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long n, k, d;\n  cin >> n >> k >> d;\n  long long tmp = 1;\n  bool fg = 0;\n  for (long long i = (long long)0; i < (long long)d; i++) {\n    tmp = tmp * k;\n    if (tmp >= n) {\n      fg = 1;\n      break;\n    }\n  }\n  if (!fg) {\n    cout << -1 << endl;\n    return 0;\n  }\n  for (long long i = (long long)1; i < (long long)n + 1; i++) {\n    for (long long j = (long long)0; j < (long long)d; j++) {\n      arr[i][j] = arr[i - 1][j];\n    }\n    for (long long j = (long long)0; j < (long long)d; j++) {\n      arr[i][j] = (arr[i][j] + 1) % k;\n      if (arr[i][j]) break;\n    }\n  }\n  for (long long j = (long long)0; j < (long long)d; j++) {\n    for (long long i = (long long)1; i < (long long)n + 1; i++)\n      cout << arr[i][j] + 1 << \" \";\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "# -*- coding: utf-8 -*-\nimport sys\n\ndef main():\n    n,k,d = map(int,sys.stdin.readline().split())\n\n    blocksize = n\n\n    for i in range(d):\n        blocksize = blocksize//k + (blocksize%k != 0)\n    # print(blocksize)\n\n    if(blocksize > 1):\n        print(\"-1\")\n        sys.exit(0)\n\n    for days in range(d):\n        i = 0\n        bus = 1\n        while i < n:\n            for j in range(blocksize):\n                sys.stdout.write(str(bus) + ' ')\n                i += 1\n                if i == n: break\n            bus += 1\n            if(bus > k): bus = 1\n        blocksize *= k\n        sys.stdout.write('\\n')\n\n\nif __name__ == \"__main__\":\n    main()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint A[1005][1005];\nint main() {\n  int n, d, k;\n  while (~scanf(\"%d%d%d\", &n, &k, &d)) {\n    bool f1 = false;\n    long long tmp = 1;\n    for (int i = 1; i <= d; i++) {\n      tmp *= k;\n      if (tmp >= n) {\n        f1 = true;\n        break;\n      }\n    }\n    if (!f1) {\n      puts(\"-1\");\n      continue;\n    }\n    for (int i = 0; i < n; i++) {\n      tmp = i;\n      for (int j = 0; j < d; j++) {\n        A[i][j] = tmp % k + 1;\n        tmp /= k;\n      }\n    }\n    for (int i = 0; i < d; i++)\n      for (int j = 0; j < n; j++) {\n        printf(\"%d%c\", A[j][i], j == n - 1 ? '\\n' : ' ');\n      }\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport static java.lang.System.out;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.StringTokenizer;\n\npublic class Solution {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputReader in = new InputReader();\n\t\tint n = in.nextInt();\n\t\tint k = in.nextInt();\n\t\tint d = in.nextInt();\n\t\tlong x = 1;\n\t\tboolean ok = false;\n\n\t\tfor (int i = 0; i < d; i++) {\n\t\t\tx *= k;\n\t\t\tif (x >= n) {\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!ok) {\n\t\t\tout.println(-1);\n\t\t\treturn;\n\t\t}\n\t\tint[][] ans = new int[n][d];\n\t\tArrays.fill(ans[0], 1);\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfor (int j = 0; j < d; j++)\n\t\t\t\tans[i][j] = ans[i - 1][j];\n\t\t\tfor (int j = d - 1; j >= 0; j--) {\n\t\t\t\tans[i][j] = (ans[i][j] + 1) % k;\n\t\t\t\tif (ans[i][j] == 0) {\n\t\t\t\t\tans[i][j] = k;\n\t\t\t\t}\n\t\t\t\tif (ans[i][j] != 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t StringBuilder answer = new StringBuilder();\n\t\t\t\n\t\t for(int i = 0; i < d; i++){\n\t            for(int j = 0; j < n; j++)\n\t                answer.append(ans[j][i]).append(' ');\n\t            answer.append('\\n');\n\t        }\n\t        System.out.print(answer);\n\n\t}\n}\n\nclass InputReader {\n\n\tprivate BufferedReader reader;\n\n\tprivate StringTokenizer tokenizer;\n\n\tpublic InputReader() {\n\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\ttokenizer = null;\n\n\t}\n\n\tpublic String nextLine() {\n\t\ttry {\n\t\t\treturn reader.readLine();\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic String next() {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}"
        },
        {
            "language": 1,
            "solution": "n,k,d = map(int,raw_input().split())\nif n>k**d:\n    print -1\nelse:\n    ans = []\n    l = 1\n    # print k\n    for i in xrange(d):\n        ki = []\n        temp = 0\n        w = 1\n        if l>n:\n            l = n\n        for j in xrange(n):\n            for t in xrange(l):\n                ki.append(j%k+1)\n                temp+=1\n                if temp==n:\n                    w = 0\n                    break\n            if w==0:\n                break\n        l*=k\n        ans.append(ki)\n    for i in ans:\n        for j in i:\n            print j,\n        print \"\"\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main3 {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tint d = sc.nextInt();\n\n\t\tint[] p = new int[n];\n\t\tp[0] = 1;\n\t\t\n\t\tint init = n / k;\n\t\tif (n % k != 0) {\n\t\t\tinit++;\n\t\t}\n\n\t\tif (k == 1 && n > 1) {\n\t\t\tSystem.out.println(\"-1\");\n\t\t\treturn;\n\t\t}\n\n\t\tint minDays = 1;\n\t\tint needTransfer = init;\n\t\twhile (needTransfer > 1) {\n\t\t\tneedTransfer = (needTransfer + k - 1) / k;\n\t\t\tminDays++;\n\t\t}\n\n\t\tif (minDays > d) {\n\t\t\tSystem.out.println(\"-1\");\n\t\t\treturn;\n\t\t}\n\n\t\tList<Integer> intervalsFrom = new ArrayList<Integer>();\n\t\tList<Integer> intervalsTo = new ArrayList<Integer>();\n\t\tintervalsFrom.add(0);\n\t\tintervalsTo.add(p.length - 1);\n\n\t\tfor (int x = 0; x < d; x++) {\n\n\t\t\tList<Integer> intervalsFromN = new ArrayList<Integer>();\n\t\t\tList<Integer> intervalsToN = new ArrayList<Integer>();\n\n\t\t\tfor (int i = 0; i < intervalsTo.size(); i++) {\n\t\t\t\tint s = intervalsTo.get(i) - intervalsFrom.get(i) + 1;\n\t\t\t\tint from = intervalsFrom.get(i);\n\t\t\t\tint to = intervalsTo.get(i);\n\t\t\t\tif (s > 1) {\n\t\t\t\t\tintervalsFromN.add(intervalsFrom.get(i));\n\t\t\t\t\tint interval = (s + k - 1) / k;\n\t\t\t\t\tint cbus = 1;\n\t\t\t\t\tint cbusc = 0;\n\t\t\t\t\tfor (int j = from; j <= to; j++) {\n\t\t\t\t\t\tp[j] = cbus;\n\t\t\t\t\t\tcbusc++;\n\t\t\t\t\t\tif (cbusc == interval) {\n\t\t\t\t\t\t\tcbusc = 0;\n\t\t\t\t\t\t\tcbus++;\n\t\t\t\t\t\t\tintervalsToN.add(j);\n\t\t\t\t\t\t\tintervalsFromN.add(j + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tintervalsToN.add(intervalsTo.get(i));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tintervalsTo = intervalsToN;\n\t\t\tintervalsFrom = intervalsFromN;\n\n\t\t\tSystem.out.println(toString(p));\n\t\t}\n\t}\n\n\tstatic String toString(int[] p) {\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tsb.append(p[0]);\n\t\tfor (int i = 1; i < p.length; i++) {\n\t\t\tsb.append(\" \");\n\t\t\tsb.append(p[i]);\n\t\t}\n\n\t\treturn sb.toString();\n\t}\n\n}\n"
        },
        {
            "language": 3,
            "solution": "m=list(input().split())\nn=int(m[0])\nk=int(m[1])\nd=int(m[2])\n\nif n==1:\n    for i in range(d):\n        print(\"1\")\n    exit()\nif k==1:\n    print(\"-1\")\n    exit()\nif k>=n:\n    m=list(i for i in range(n))\n    o=\"\"\n    for j in range(1,n+1):\n        o+=\" \"+str(j)\n    o=o[1:] \n    for i in range(d):\n        print(o)\n    exit()\nif d==1:\n    print('-1')\n    exit()\nif d>=n:\n    m=list(\"1\" for i in range(n))\n    for i in range(n):\n        m[i]=\"2\"\n        #print(m)\n        o=str(m[0])\n        for j in range(1,n):\n            o+=\" \"+str(m[j])\n        print(o)\n        #m[i]=\"1\"\n    for i in range(n,d):\n        #print(m)\n        print(o)\n    exit()\n\nfrom math import ceil, floor\ntc=ceil(n/k) #days\ntf=floor(n/k) #len k\n\nif n>(k**d):\n    print('-1')\n    exit()\n\nsc=1\nfor stp in range(1,d+1):\n    o=\"\"\n    kc=0\n    \n    while kc<n:\n        for kk in range(1,k+1):\n            for i in range (sc):\n                if kc<n:\n                    o+=' '+str(kk)\n                    kc+=1\n                else:\n                    break\n    sc*=k #change from 2\n    print(o[1:])\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.util.StringTokenizer;\n\n/**\n * 459C\n *\n * @author artyom\n */\npublic class PashmakAndBuses3 implements Runnable {\n    private BufferedReader in;\n    private PrintStream out;\n    private StringTokenizer tok;\n\n    private StringBuilder sb;\n    private int target;\n    private int busesCount;\n\n    private void solve() throws IOException {\n        int students = nextInt();\n        int k = nextInt(); // buses\n        int d = nextInt(); // days\n        int t = divCeil(students, (int) Math.pow(k, d));\n        if (t > 1) {\n            out.print(\"-1\");\n            return;\n        }\n        busesCount = Math.min(students, k);\n        int count = 0;\n        for (int m = k, i = 0; ; m *= k, i++) {\n            target = divCeil(students, m);\n            sb = new StringBuilder();\n            populateBuses(students, 1);\n            String x = sb.append('\\n').toString().trim();\n            out.println(x);\n            count++;\n            if (target == 1) {\n                break;\n            }\n        }\n        String s = sb.toString().trim();\n        for (int i = 0, rem = d - count; i < rem; i++) {\n            out.println(s);\n        }\n    }\n\n    private void populateBuses(int students, int busIndex) {\n        if (students <= target) {\n            for (int i = 0; i < students; i++) {\n                sb.append(busIndex).append(' ');\n            }\n        } else {\n            int t = divCeil(students, busesCount);\n            for (int i = 1, j = 0; i <= busesCount && j < students; i++, j += t) {\n                populateBuses(Math.min(students - j, t), i);\n            }\n        }\n    }\n\n    private static int divCeil(int x, int y) {\n        int res = x / y;\n        if (x % y > 0) {\n            ++res;\n        }\n        return res;\n    }\n\n    //--------------------------------------------------------------\n    public static void main(String[] args) {\n        new PashmakAndBuses3().run();\n    }\n\n    @Override\n    public void run() {\n        try {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = System.out;\n            tok = null;\n            solve();\n            in.close();\n        } catch (IOException e) {\n            System.exit(0);\n        }\n    }\n\n    private String nextToken() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n\n    private int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n, k, d;\n  cin >> n >> k >> d;\n  int aux = 1;\n  for (int i = 0; i < d; ++i) {\n    aux *= k;\n    if (aux > n) break;\n  }\n  if (aux < n) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n  vector<vector<int> > ans(d, vector<int>(n));\n  for (int i = 0; i < n; ++i) {\n    int u = i;\n    for (int j = 0; j < d; ++j) {\n      ans[j][i] = (u % k) + 1;\n      u /= k;\n    }\n  }\n  for (int i = 0; i < d; ++i) {\n    for (int j = 0; j < n; ++j) {\n      cout << ans[i][j] << \" \";\n    }\n    cout << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n, k, d = [int(k) for k in input().split()]\nbase_rep = [[0 for _ in range(d)] for _ in range(n)]\n\n\nif k**d  < n:\n    print(-1)\nelse:\n    for j in range(n):\n        num = j\n        i=0\n        while num >= k**i:\n           i+=1\n        i-=1\n        #print(i)\n        while num:\n            base_rep[j-1][i] = num//k**i\n            num = num % k**i\n            i -=1\n    for i in range(d):\n        s =\"\"\n        for j in range(n):\n            s += str(base_rep[j][i]+1) + \" \"\n        print(s)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1010, inf = 1000000007;\nconst double eps = 0.000000001;\nlong long n, d, k, g = 1, br, a[N][N], b[N];\nvoid iz() {\n  for (long long i = 1; i <= d; i++) {\n    for (long long j = 1; j <= n; j++) printf(\"%I64d \", a[i][j]);\n    printf(\"\\n\");\n  }\n  exit(0);\n}\nvoid calc(long long x, long long de) {\n  br++;\n  b[de] = x;\n  if (de == d) {\n    for (long long i = 1; i <= d; i++) a[i][g] = b[i];\n    g++;\n    if (g > n) iz();\n    return;\n  }\n  for (long long i = 1; i <= k; i++) calc(i, de + 1);\n}\nint main() {\n  scanf(\"%I64d %I64d %I64d\", &n, &k, &d);\n  for (long long i = 1; i <= k; i++) calc(i, 1);\n  printf(\"-1\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "a = input()\nb = a.split()\nn = int(b[0])\nk = int(b[1])\nd = int(b[2])\nraw = [' ']*n\nif n > k**d:\n\tprint(-1)\n\texit()\ntable = [[1]*d]\np = 1\nfor i in range(d):\n\tcv = 1\n\tfor j in range(n):\n\t\tif j % p == 0 and j != 0:\n\t\t\tcv = cv + 1\n\t\t\tif cv == k+1:\n\t\t\t\tcv = 1\n\t\traw[j]= str(cv)\n\tprint(' '.join(raw))\n\tp = p * k"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\n/**\n * Class: ProblemC<br />\n * Date: 2014/8/15 23:30<br />\n * Description:<br />\n *\n * @author sjtudesigner\n */\npublic class ProblemC {\n\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n\n        int n, k, d;\n        n = sc.nextInt();\n        k = sc.nextInt();\n        d = sc.nextInt();\n\n        if (k >= n)\n        {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < n; i++) {\n                sb.append(i + 1);\n                if (i != n - 1) sb.append(' ');\n            }\n            for (int j = 0;j < d;j++) {\n                System.out.println(sb);\n            }\n        }\n        else\n        {\n            if (!div(n, k, d)) System.out.println(-1);\n            else\n            {\n                StringBuilder sb = new StringBuilder();\n                int jk = 1;\n                for (int i = 0; i < n; i++) {\n                    System.out.print(i % k + 1);\n                    if (i != n - 1) System.out.print(' ');\n                }\n                System.out.println();\n                for (int j = 1;j < d;j++) {\n                    int temp = 0;\n                    int temp2 = 0;\n                    if (jk < 1000) jk *= k;\n                    for (int i = 0; i < n; i++) {\n                        sb.append((i % k + temp) % k + 1);\n                        if (i != n - 1) sb.append(' ');\n                        temp2++;\n                        if (temp2 == jk) { temp2 = 0; temp++; }\n                        if (temp == jk * k) { temp = 0; }\n                    }\n                    System.out.println(sb);\n                    sb = new StringBuilder();\n                }\n            }\n        }\n    }\n\n    private static int move(int i, int k, int j) {\n\n        int mul = 1;\n        if (j == 0) return 0;\n        while (j > 0)\n        {\n            if (mul > 1000)\n                return 0;\n            mul *= k;\n            j--;\n        }\n        return (i % (mul * k)) / mul;\n    }\n\n    private static boolean div(double n, double k, int d) {\n\n        while (d > 0)\n        {\n            n /= k;\n            d--;\n        }\n        return n <= 1.00000000001;\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main (String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader (inputStream);\n\t\tPrintWriter out = new PrintWriter (outputStream);\n\t\tTaskC solver = new TaskC ();\n\t\tsolver.solve (1, in, out);\n\t\tout.close ();\n\t}\n\t\n\tstatic class TaskC {\n\t\tpublic void solve (int testNumber, InputReader in, PrintWriter out) {\n\t\t\tint n = in.nextInt ();\n\t\t\tint k = in.nextInt ();\n\t\t\tint d = in.nextInt ();\n//we are going to use pigeonhole principal and unique permutation generator here\n//according to pegionhole if a student can take k buses at one day, then there\n//can be k^d combinations in d days so here hole is k^d\n\t\t\tif (n>Math.round (Math.pow (k, d))) {\n\t\t\t\tout.println (-1);\n\t\t\t\treturn;\n\t\t\t}\n//now we are going to apply unique permuation or number generator in a range\n// in this technique we will have to know about the range of numbers (suppose\n//range is 2-4 then actually there are 3 numbers in range so basically we\n// weill create such permutations where the range is between 3\n//when we know the range of a number we can call it base of that number, so basically\n//we are going to create 3 based numbers' unique permutation, five numbers of base 3\n//can be 00 01 02 10 11, now as the range of numbers doesn't start with 0 so we will\n//add 2 with every digit: 22 23 24 32 33, see this is the unique permutation\n//as we all know base changing in hsc way is very easy and can be done to every base\n\t\t\tint[] os = new int[n+5];\n\t\t\tint j, res;\n\t\t\tint[][] ans = new int[d+5][n+5];\n\t\t\tfor (int i = 0; i<n; i++) {\n\t\t\t\tres = i;\n\t\t\t\tj = 0;\n\t\t\t\twhile (res != 0) {\n\t\t\t\t\tos[j++] = res%k;\n\t\t\t\t\tres /= k;\n\t\t\t\t}\n\t\t\t\tint cnt = j;\n\t\t\t\tj = 0;\n\t\t\t\tfor (int l = d-1; l>=0; l--) {\n\t\t\t\t\tans[l][i] = j<cnt ? os[j++] : 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i<d; i++) {\n\t\t\t\tfor (int l = 0; l<n; l++) {\n\t\t\t\t\tout.print ((ans[i][l]+1)+\" \");\n\t\t\t\t}\n\t\t\t\tout.println ();\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tstatic class InputReader {\n\t\tprivate BufferedReader reader;\n\t\tprivate StringTokenizer tokenizer;\n\t\t\n\t\tpublic InputReader (InputStream stream) {\n\t\t\treader = new BufferedReader (new InputStreamReader (stream), 32768);\n\t\t\ttokenizer = null;\n\t\t}\n\t\t\n\t\tpublic String next () {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens ()) {\n\t\t\t\ttry {\n\t\t\t\t\tString str;\n\t\t\t\t\tif ((str = reader.readLine ()) != null) tokenizer = new StringTokenizer (str);\n\t\t\t\t\telse return null;//to detect eof\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException (e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken ();\n\t\t}\n\t\t\n\t\tpublic int nextInt () {\n\t\t\treturn Integer.parseInt (next ());\n\t\t}\n\t\t\n\t}\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author shubh09\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskC solver = new TaskC();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskC {\n\n    public boolean check(int n,int k,int d)\n    {\n        long k2=1L;\n        for(int i=0;i<d;i++)\n        {\n            k2*=(long)k;\n            if (k2>=(long)n) return true;\n        }\n        return false;\n    }\n\n    public int[] addOne(int[] arr,int base)\n    {\n        int n=arr.length,c=1,i;\n        int[] ans=new int[n];\n        for(i=n-1;i>=0;i--)\n        {\n            ans[i]=arr[i]+c;\n            if (ans[i]>=base)\n            {\n                ans[i]-=base;\n                c=1;\n            }\n            else c=0;\n        }\n        return ans;\n    }\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int n=in.nextInt();\n        int k=in.nextInt();\n        int d=in.nextInt();\n        if (!check(n,k,d))\n        {\n            out.println(-1);\n            return;\n        }\n        int[][] mat=new int[n][d];\n        int i,j;\n        for(i=0;i<d;i++) mat[0][i]=0;\n        for(i=1;i<n;i++)\n        {\n            mat[i]=addOne(mat[i-1],k);\n        }\n        /*for(i=0;i<n;i++)\n        {\n            for(j=0;j<d;j++) out.print(mat[i][j]+\" \");\n            out.println();\n        }*/\n        for(j=0;j<d;j++)\n        {\n            for(i=0;i<n;i++) out.print(mat[i][j]+1+\" \");\n            out.println();\n        }\n    }\n}\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n}\n\n"
        },
        {
            "language": 3,
            "solution": "# Enter your code here. Read input from STDIN. Print output to STDOUT# ===============================================================================================\n# importing some useful libraries.\nfrom __future__ import division, print_function\nfrom fractions import Fraction\nimport sys\nimport os\nfrom io import BytesIO, IOBase\nfrom itertools import *\nimport bisect\nfrom heapq import *\nfrom math import ceil, floor\nfrom copy import *\nfrom collections import deque, defaultdict\nfrom collections import Counter as counter  # Counter(list)  return a dict with {key: count}\nfrom itertools import combinations  # if a = [1,2,3] then print(list(comb(a,2))) -----> [(1, 2), (1, 3), (2, 3)]\nfrom itertools import permutations as permutate\nfrom bisect import bisect_left as bl\nfrom operator import *\n# If the element is already present in the list,\n\n# the left most position where element has to be inserted is returned.\nfrom bisect import bisect_right as br\nfrom bisect import bisect\n\n# If the element is already present in the list,\n# the right most position where element has to be inserted is returned\n\n# ==============================================================================================\n# fast I/O region\n\nBUFSIZE = 8192\nfrom sys import stderr\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n# inp = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# ===============================================================================================\n### START ITERATE RECURSION ###\nfrom types import GeneratorType\n\n\ndef iterative(f, stack=[]):\n    def wrapped_func(*args, **kwargs):\n        if stack: return f(*args, **kwargs)\n        to = f(*args, **kwargs)\n        while True:\n            if type(to) is GeneratorType:\n                stack.append(to)\n                to = next(to)\n                continue\n            stack.pop()\n            if not stack: break\n            to = stack[-1].send(to)\n        return to\n\n    return wrapped_func\n\n\n#### END ITERATE RECURSION ####\n###########################\n# Sorted list\nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n        \"\"\"Build a fenwick tree instance.\"\"\"\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n\n    def _fen_findkth(self, k):\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n\n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def _loc_right(self, value):\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\"\"\"\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n\n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return 'SortedList({0})'.format(list(self))\n\n\n# ===============================================================================================\n# some shortcuts\n\nmod = 1000000007\n\n\ndef testcase(t):\n    for p in range(t):\n        solve()\n\n\ndef pow(x, y, p):\n    res = 1  # Initialize result\n    x = x % p  # Update x if it is more , than or equal to p\n    if (x == 0):\n        return 0\n    while (y > 0):\n        if ((y & 1) == 1):  # If y is odd, multiply, x with result\n            res = (res * x) % p\n\n        y = y >> 1  # y = y/2\n        x = (x * x) % p\n    return res\n\n\nfrom functools import reduce\n\n\ndef factors(n):\n    return set(reduce(list.__add__,\n                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\n\n\ndef gcd(a, b):\n    if a == b: return a\n    while b > 0: a, b = b, a % b\n    return a\n\n\n# discrete binary search\n# minimise:\n# def search():\n#     l = 0\n#     r = 10 ** 15\n#\n#     for i in range(200):\n#         if isvalid(l):\n#             return l\n#         if l == r:\n#             return l\n#         m = (l + r) // 2\n#         if isvalid(m) and not isvalid(m - 1):\n#             return m\n#         if isvalid(m):\n#             r = m + 1\n#         else:\n#             l = m\n#     return m\n\n# maximise:\n# def search():\n#     l = 0\n#     r = 10 ** 15\n#\n#     for i in range(200):\n#         # print(l,r)\n#         if isvalid(r):\n#             return r\n#         if l == r:\n#             return l\n#         m = (l + r) // 2\n#         if isvalid(m) and not isvalid(m + 1):\n#             return m\n#         if isvalid(m):\n#             l = m\n#         else:\n#             r = m - 1\n#     return m\n\n\n##############Find sum of product of subsets of size k in a array\n# ar=[0,1,2,3]\n# k=3\n# n=len(ar)-1\n# dp=[0]*(n+1)\n# dp[0]=1\n# for pos in range(1,n+1):\n#     dp[pos]=0\n#     l=max(1,k+pos-n-1)\n#     for j in range(min(pos,k),l-1,-1):\n#         dp[j]=dp[j]+ar[pos]*dp[j-1]\n# print(dp[k])\n\ndef prefix_sum(ar):  # [1,2,3,4]->[1,3,6,10]\n    return list(accumulate(ar))\n\n\ndef suffix_sum(ar):  # [1,2,3,4]->[10,9,7,4]\n    return list(accumulate(ar[::-1]))[::-1]\n\n\ndef N():\n    return int(inp())\n\n\ndx = [0, 0, 1, -1]\ndy = [1, -1, 0, 0]\n\n\ndef YES():\n    print(\"YES\")\n\n\ndef NO():\n    print(\"NO\")\n\n\ndef Yes():\n    print(\"Yes\")\n\n\ndef No():\n    print(\"No\")\n\n\n# =========================================================================================\nfrom collections import defaultdict\n\n\ndef numberOfSetBits(i):\n    i = i - ((i >> 1) & 0x55555555)\n    i = (i & 0x33333333) + ((i >> 2) & 0x33333333)\n    return (((i + (i >> 4) & 0xF0F0F0F) * 0x1010101) & 0xffffffff) >> 24\n\n\nclass MergeFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n        # self.lista = [[_] for _ in range(n)]\n\n    def find(self, a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n\n    def merge(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return\n        if self.size[a] < self.size[b]:\n            a, b = b, a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        # self.lista[a] += self.lista[b]\n        # self.lista[b] = []\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\n\ndef lcm(a, b):\n    return abs((a // gcd(a, b)) * b)\n\n\n#\n# to find factorial and ncr\n# tot = 200005\n# mod = 10**9 + 7\n# fac = [1, 1]\n# finv = [1, 1]\n# inv = [0, 1]\n#\n# for i in range(2, tot + 1):\n#     fac.append((fac[-1] * i) % mod)\n#     inv.append(mod - (inv[mod % i] * (mod // i) % mod))\n#     finv.append(finv[-1] * inv[-1] % mod)\n\n\ndef comb(n, r):\n    if n < r:\n        return 0\n    else:\n        return fac[n] * (finv[r] * finv[n - r] % mod) % mod\n\n\ndef inp(): return sys.stdin.readline().rstrip(\"\\r\\n\")  # for fast input\n\n\ndef out(var): sys.stdout.write(str(var))  # for fast output, always take string\n\n\ndef lis(): return list(map(int, inp().split()))\n\n\ndef stringlis(): return list(map(str, inp().split()))\n\n\ndef sep(): return map(int, inp().split())\n\n\ndef strsep(): return map(str, inp().split())\n\n\ndef fsep(): return map(float, inp().split())\n\n\ndef nextline(): out(\"\\n\")  # as stdout.write always print sring.\n\n\ndef arr1d(n, v):\n    return [v] * n\n\n\ndef arr2d(n, m, v):\n    return [[v] * m for _ in range(n)]\n\n\ndef arr3d(n, m, p, v):\n    return [[[v] * p for _ in range(m)] for i in range(n)]\n\nans=[]\ndef solve():\n    n,k,d=sep()\n    if n>(k**d):\n        print(-1)\n        return\n    cur=[1]*d\n    for i in range(n):\n        ans.append(cur.copy())\n        for j in range(d-1,-1,-1):\n            if cur[j]==k:\n                cur[j]=1\n            else:\n                cur[j]+=1\n                break\n    \n    for j in range(d):\n        for i in range(n):\n            print(ans[i][j],end=\" \")\n        print()\n\n\n\n\n\nsolve()\n#testcase(int(inp()))"
        },
        {
            "language": 1,
            "solution": "#!/usr/bin/env python\n# coding=utf-8\n\nn, k, d = map(int, raw_input().split())\nif n > k ** d:\n    print -1\nelse:\n    cur = range(n)\n    for i in range(d):\n        toPrint = []\n        for j in range(n):\n            toPrint.append(cur[j] % k + 1)\n            cur[j] /= k\n        print \" \".join(map(str, toPrint))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nbool mini(T &a, T b) {\n  return a > b ? (a = b, true) : false;\n}\ntemplate <class T>\nbool maxi(T &a, T b) {\n  return a < b ? (a = b, true) : false;\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.precision(10);\n  cout << fixed;\n  int n, k, d;\n  cin >> n >> k >> d;\n  int tmp = 1, ok = 0;\n  for (int i = 0; i < (int)(d); i++) {\n    tmp *= k;\n    if (tmp >= n) {\n      ok = 1;\n      break;\n    }\n  }\n  if (!ok)\n    cout << \"-1\";\n  else {\n    vector<vector<int> > ans(d, vector<int>(n, 0));\n    for (int i = 0; i < (int)(n); i++) {\n      int cur = i, j = 0;\n      while (cur) {\n        ans[j++][i] = cur % k;\n        cur /= k;\n      }\n    }\n    for (int i = 0; i < (int)(d); i++) {\n      for (int j = 0; j < (int)(n); j++) cout << ans[i][j] + 1 << ' ';\n      cout << \"\\n\";\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint res[1010][1010];\nint n, k, d;\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &d);\n  int tmp = 1;\n  bool flag = 0;\n  for (int i = 1; i <= d; i++) {\n    tmp *= k;\n    if (tmp >= n) {\n      flag = 1;\n      break;\n    }\n  }\n  if (!flag) {\n    puts(\"-1\");\n    return 0;\n  }\n  for (int i = 1; i <= n; i++) {\n    int num = i;\n    for (int j = 1; j <= d; j++) {\n      res[i][j] = num % k;\n      num /= k;\n    }\n  }\n  for (int i = 1; i <= d; i++) {\n    printf(\"%d\", res[1][i] + 1);\n    for (int j = 2; j <= n; j++) {\n      printf(\" %d\", res[j][i] + 1);\n    }\n    puts(\"\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long int k, l, d, i, n, j = 1, m, c, b;\n  cin >> n >> k >> d;\n  for (i = 0; i < d; i++) {\n    j *= k;\n    if (j > n) break;\n  }\n  if (i == d && j < n) {\n    cout << \"-1\";\n    return 0;\n  }\n  int a[1000][1000] = {0};\n  b = j / k;\n  for (m = 0; m < d && b > 0; m++) {\n    for (i = 0; i < n; i++) a[m][i] = (i / b) % k;\n    b /= k;\n  }\n  for (j = 0; j < d; j++) {\n    for (i = 0; i < n; i++) cout << a[j][i] + 1 << ' ';\n    cout << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long n, k, d;\n  cin >> n >> k >> d;\n  bool ok = false;\n  int dd = d;\n  long long aux = 1;\n  while (dd-- && !ok) {\n    aux *= k;\n    if (aux >= n) ok = true;\n  }\n  if (!ok)\n    cout << -1 << endl;\n  else {\n    long long pot = 1;\n    for (int i = 0; i < d; i++) {\n      for (int num = 0; num < n; num++) {\n        if (num) printf(\" \");\n        printf(\"%lld\", (((num / pot)) % k) + 1);\n      }\n      pot *= k;\n      if (pot > 1000000000) pot = 1000000000;\n      printf(\"\\n\");\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint mod = 1e9 + 7;\nint n, k, d;\nbool check() {\n  if (n <= k) return true;\n  long long a = 1;\n  for (int i = 0; i < d; i++) {\n    a *= k;\n    a %= mod;\n    if (a >= n) return true;\n  }\n  return n <= a;\n}\nvector<vector<int>> ans;\nbool flag = false;\nvoid go(vector<int>& vec) {\n  if (flag) return;\n  if (ans.size() == n) {\n    flag = true;\n    return;\n  }\n  if (vec.size() == d) {\n    ans.push_back(vec);\n    return;\n  }\n  for (int i = 1; i <= min(n, k); i++) {\n    vec.push_back(i);\n    go(vec);\n    vec.pop_back();\n  }\n}\nint main() {\n  cin >> n >> k >> d;\n  if (!check()) {\n    cout << -1 << endl;\n    return 0;\n  }\n  vector<int> dummy = {};\n  go(dummy);\n  for (int j = 0; j < d; j++) {\n    for (int i = 0; i < n; i++) {\n      cout << ans[i][j] << \" \";\n    }\n    cout << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, d;\nint a[1111][1111];\nbool farm() {\n  int i;\n  if ((double)n > (pow((double)k, d))) return 0;\n  memset(a, 0, sizeof(a));\n  for (i = 0; i < n; i++) {\n    int x = i, j = 0;\n    while (x) {\n      a[i][j++] = x % k;\n      x /= k;\n    }\n  }\n  return 1;\n}\nint main() {\n  int i, j;\n  scanf(\"%d%d%d\", &n, &k, &d);\n  int ans = farm();\n  if (ans == 0)\n    puts(\"-1\");\n  else {\n    for (i = 0; i < d; i++) {\n      printf(\"%d\", a[0][i] + 1);\n      for (j = 1; j < n; j++) {\n        printf(\" %d\", a[j][i] + 1);\n      }\n      puts(\"\");\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def main(inp):\n    n, k, d = split_inp_int(inp)\n    sols = []\n    k = min(1000, k)\n    import itertools\n    source = itertools.product(*[range(1, k + 1) for __ in range(d)])\n    for s in source:\n        sols.append(s)\n        if len(sols) == n:\n            break\n    if len(sols) < n:\n        print(-1)\n        return\n    for i in range(d):\n        for j in range(n):\n            print(sols[j][i], end=\" \")\n        print()\n\n\n\ndef split_inp_int(inp):\n    return list(map(int, inp().split()))\n\n\ndef use_fast_io():\n    import sys\n\n    class InputStorage:\n        def __init__(self, lines):\n            lines.reverse()\n            self.lines = lines\n\n        def input_func(self):\n            if self.lines:\n                return self.lines.pop()\n            else:\n                return \"\"\n\n    input_storage_obj = InputStorage(sys.stdin.readlines())\n    return input_storage_obj.input_func\n\n\nfrom collections import Counter, defaultdict\nfrom functools import reduce\nimport operator\nimport math\n\n\ndef product(arr_):\n    return reduce(operator.mul, arr_, 1)\n\nif __name__ == \"__main__\":\n\n    main(use_fast_io())\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.Scanner;\n\npublic class PashmakAndBuses \n{\n\tpublic static void main(String[] args) \n\t{\n\t\tint students;\n\t\tint buses;\n\t\tint d;\n\t\t//1000000\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tstudents = sc.nextInt();\n\t\tbuses = sc.nextInt();\n\t\td = sc.nextInt();\n\t\tint[][] table = new int[students][d];\n\t\t\n\t\tif(buses < students && Math.pow(buses, d) < students)\n\t\t{\n\t\t\tSystem.out.println(-1);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint simpen = 0;\n\t\tfor(int i = 0; i < students; i++)\n\t\t{\n\t\t\tfor(int j = d-1; j >= 0; j--)\n\t\t\t{\n\t\t\t\tif(i == 0)\n\t\t\t\t{\n\t\t\t\t\ttable[i][j] = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttable[i][j] = table[i-1][j] + simpen;\n\t\t\t\t\tif(j == d-1)table[i][j]++;\n\t\t\t\t\tsimpen = 0;\n\t\t\t\t\tif(table[i][j] >= buses)\n\t\t\t\t\t{\n\t\t\t\t\t\ttable[i][j] -= buses;\n\t\t\t\t\t\tsimpen = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int j = 0; j < d; j++)\n\t\t{\n\t\t\tfor(int i = 0; i < students; i++)\n\t\t\t{\n\t\t\t\tsb.append(table[i][j]+1);\n\t\t\t\tif(i < students-1)sb.append(\" \");\n\t\t\t}\n\t\t\tif(j < d-1)sb.append(\"\\n\");\n\t\t}\n\t\t\n\t\tSystem.out.println(sb);\n\t\t\n\t\t\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\nusing namespace std;\nint a[1005][1005];\nint main() {\n  int N, K, D, i, j;\nloop:\n  while (~scanf(\"%d%d%d\", &N, &K, &D)) {\n    memset(a, 0, sizeof(a));\n    for (j = 0; j < N; ++j) {\n      a[D - 1][j] = j;\n    }\n    for (i = D - 1; i > 0; --i) {\n      for (j = 0; j < N; ++j) {\n        a[i - 1][j] += a[i][j] / K;\n        a[i][j] %= K;\n      }\n    }\n    for (i = 0; i < D; ++i) {\n      for (j = 0; j < N; ++j) {\n        if (a[i][j] >= K) {\n          puts(\"-1\");\n          goto loop;\n        }\n      }\n    }\n    for (i = 0; i < D; ++i) {\n      for (j = 0; j < N; ++j) {\n        printf(\"%d%s\", a[i][j] + 1, j == N - 1 ? \"\\n\" : \" \");\n      }\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Main{\n\n    BufferedReader in;\n    StringTokenizer str = null;\n    PrintWriter out;\n\n    private String next() throws Exception{\n    \twhile (str == null || !str.hasMoreElements())\n    \t    str = new StringTokenizer(in.readLine());\n    \treturn str.nextToken();\n    }\n    \n    private int nextInt() throws Exception{\n\treturn Integer.parseInt(next());\n    }\n    \n    public void run() throws Exception{\n    \tin = new BufferedReader(new InputStreamReader(System.in));\n    \tout = new PrintWriter(System.out);\n\t\n\tint n = nextInt(), k = nextInt(), d = nextInt();\n\tint p = 1;\n\tfor(int i=0;i<d;i++){\n\t    if (n <= p) break;\n\t    p*=k;\n\t}\n\tif (n > p){\n\t    out.println(-1);\n\t    out.close();\n\t    return;\n\t}\n\t\n\tint [][]r = new int[d][n];\n\tfor(int j=0;j<n;j++){\n\t    int []x = convert(j, k);\n\t    for(int i=0;i<Math.min(x.length, d);i++){\n\t\tr[i][j] = x[i];\n\t    }\n\t}\n\t\n\tfor(int i=0;i<d;i++){\n\t    for(int j=0;j<n;j++){\n\t\tout.print(++r[i][j] + \" \");\n\t    }\n\t    out.println();\n\t}\n\t\n        out.close();\n    }\n    \n    private int[] convert(int n, int base){\n\tList<Integer> lst = new ArrayList<Integer>();\n\twhile(n > 0){\n\t    lst.add(n % base);\n\t    n/=base;\n\t}\n\tint []ret = new int[lst.size()];\n\tint at = 0;\n\tfor(int i : lst) ret[at++] = i;\n\treturn ret;\n    }\n\n    public static void main(String args[]) throws Exception{\n\tnew Main().run();\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        int d = sc.nextInt();\n\n        int num = n;\n        for (int i = 0; i < d; i++) {\n            num = (num + k - 1) / k;\n        }\n\n        if (num > 1) {\n            System.out.println(-1);\n            return;\n        }\n\n        long diff = 1;\n        for (int i = 0; i < d; i++) {\n            int [] arr = new int[n];\n            Arrays.fill(arr, -1);\n            for (int j = 0; j < n; j++) {\n                int put = 0;\n                if (arr[j] == -1) {\n                    for (int z = j; z < n; z += diff) {\n                        arr[z] = put;\n                        put++;\n                        if (put == k) put = 0;\n                    }\n                }\n                if (j == 0) out.print(arr[j] + 1);\n                else out.print(\" \" + (arr[j] + 1));\n            }\n            out.println();\n            diff *= k;\n            diff = Math.min(diff, n);\n        }\n\n        out.flush();\n        out.close();\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public Scanner (FileReader f) {br = new BufferedReader(f);}\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            String x = next();\n            StringBuilder sb = new StringBuilder(\"0\");\n            double res = 0, f = 1;\n            boolean dec = false, neg = false;\n            int start = 0;\n            if (x.charAt(0) == '-') {\n                neg = true;\n                start++;\n            }\n            for (int i = start; i < x.length(); i++)\n                if (x.charAt(i) == '.') {\n                    res = Long.parseLong(sb.toString());\n                    sb = new StringBuilder(\"0\");\n                    dec = true;\n                } else {\n                    sb.append(x.charAt(i));\n                    if (dec)\n                        f *= 10;\n                }\n            res += Long.parseLong(sb.toString()) / f;\n            return res * (neg ? -1 : 1);\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n\n    }\n}"
        },
        {
            "language": 3,
            "solution": "import time,math,bisect,sys\nsys.setrecursionlimit(100000)\nfrom sys import stdin,stdout\nfrom collections import deque\nfrom fractions import Fraction\nfrom collections import Counter\nfrom collections import OrderedDict\npi=3.14159265358979323846264338327950\ndef II(): # to take integer input\n    return int(stdin.readline())\ndef IO(): # to take string input\n    return stdin.readline()\ndef IP(): # to take tuple as input\n    return map(int,stdin.readline().split())\ndef L(): # to take list as input\n    return list(map(int,stdin.readline().split()))\ndef P(x): # to print integer,list,string etc..\n    return stdout.write(str(x)+\"\\n\")\ndef PI(x,y): # to print tuple separatedly\n    return stdout.write(str(x)+\" \"+str(y)+\"\\n\")\ndef lcm(a,b): # to calculate lcm\n    return (a*b)//gcd(a,b)\ndef gcd(a,b): # to calculate gcd\n    if a==0:\n        return b\n    elif b==0:\n        return a\n    if a>b:\n        return gcd(a%b,b)\n    else:\n        return gcd(a,b%a)\ndef readTree(): # to read tree\n    v=int(input())\n    adj=[set() for i in range(v+1)]\n    for i in range(v-1):\n        u1,u2=In()\n        adj[u1].add(u2)\n        adj[u2].add(u1)\n    return adj,v\ndef bfs(adj,v): # a schema of bfs\n    visited=[False]*(v+1)\n    q=deque()\n    while q:\n        pass\ndef sieve():\n    li=[True]*1000001\n    li[0],li[1]=False,False\n    for i in range(2,len(li),1):\n        if li[i]==True:\n            for j in range(i*i,len(li),i):\n                li[j]=False\n    prime=[]\n    for i in range(1000001):\n        if li[i]==True:\n            prime.append(i)\n    return prime\ndef setBit(n):\n    count=0\n    while n!=0:\n        n=n&(n-1)\n        count+=1\n    return count\n#####################################################################################\nmx=10**9+7\ndef solve():\n    n,k,d=IP()\n    if n>pow(k,d):\n        print(-1)\n        return\n    \n    else:\n        li=[[0 for j in range(n)] for i in range(d)]\n        student=0\n        for i in range(1,n):\n            for j in range(d):\n                li[j][i]=li[j][i-1]\n            for j in range(d):\n                li[j][i]=(li[j][i]+1)%k\n                if li[j][i]:\n                    break\n        for i in range(d):\n            for j in range(n):\n                print(int(li[i][j])+1,end=\" \")\n            print()\n        return\n\n\n#t=II()\n#for i in range(t):\nsolve()\n    #######\n   #\n  #\n #######   #     #  # ####   # #     #\n       #  # #   #  # #   #  # # #   #\n      #  ####  #  # ####   ####  # #\n######  #   # #### #    # #   #   #"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int size = 1000;\nint res[size + 10][size + 10];\nint main() {\n  bool flag;\n  int n, k, d, temp;\n  while (cin >> n >> k >> d) {\n    temp = 1;\n    flag = true;\n    for (int i = 1; i <= d; ++i) {\n      temp *= k;\n      if (n <= temp) {\n        flag = false;\n        break;\n      }\n    }\n    if (flag) {\n      cout << -1 << endl;\n    } else {\n      memset(res, 0, sizeof(res));\n      for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < d; ++j) {\n          res[i][j] = res[i - 1][j];\n        }\n        for (int j = d - 1; j >= 0; --j) {\n          res[i][j] = (res[i][j] + 1) % k;\n          if (res[i][j]) break;\n        }\n      }\n      for (int i = 0; i < d; ++i) {\n        for (int j = 0; j < n; ++j) {\n          cout << res[j][i] + 1 << \" \\n\"[j == n - 1];\n        }\n      }\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/env python3\nimport io\nimport os\nimport sys\n\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n\ndef printd(*args, **kwargs):\n    #print(*args, **kwargs, file=sys.stderr)\n    #print(*args, **kwargs)\n    pass\n\ndef get_str():\n    return input().decode().strip()\n\ndef rint():\n    return map(int, input().split())\n\ndef oint():\n    return int(input())\n\ndef conv(i):\n    ret = [1]*d\n    for ii in range(d):\n        ret[ii] = i%k + 1\n        i //= k\n        if i == 0:\n            break\n    return ret\n\n\nn, k, d = rint()\nprintd(n,k,d)\nif k**d < n:\n    print(-1)\n    exit()\nans = [[0 for i in range(n)] for j in range(d)]\nans1 = []\n\nfor i in range(n):\n    ans1.append(conv(i))\nprintd(ans)\nprintd(ans1)\nfor i in range(d):\n    for j in range(n):\n        ans[i][j] = ans1[j][i]\n\nfor i in range(d):\n    print(*ans[i])"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        int n;\n        int k;\n        int d;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            n = in.nextInt();\n            k = in.nextInt();\n            d = in.nextInt();\n            int[][] ans = new int[n][d];\n            for (int i = 1; i < n; ++i) {\n                int[] nxt = getNext(ans[i - 1], k);\n                if (nxt[0] == -1) {\n                    out.println(\"-1\");\n                    return;\n                }\n                ans[i] = nxt;\n            }\n\n            for (int i = 0; i < d; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    if (j > 0) out.print(\" \");\n                    out.print((ans[j][i] + 1));\n                }\n                out.println();\n            }\n        }\n\n        private int[] getNext(int[] v, int k) {\n            int n = v.length;\n            int[] ret = v.clone();\n            boolean carry = true;\n            for (int i = n - 1; i >= 0 && carry; --i) {\n                if (carry) ++ret[i];\n                carry = ret[i] == k;\n                ret[i] %= k;\n            }\n            if (carry) ret[0] = -1;\n            return ret;\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 65536 / 2);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint students[1100][1100];\nint main() {\n  bool flag = true;\n  int n, k, d, tmp = 1;\n  cin >> n >> k >> d;\n  for (int i = 0; i < d && flag; i++) {\n    tmp *= k;\n    if (tmp >= n) flag = false;\n  }\n  if (flag)\n    cout << \"-1 \\n\";\n  else {\n    for (int i = 1; i < n; i++) {\n      int tmp = 1;\n      for (int j = 0; j < d; j++) {\n        students[i][j] = students[i - 1][j] + tmp;\n        if (students[i][j] >= k)\n          students[i][j] = 0;\n        else\n          tmp = 0;\n      }\n    }\n    for (int i = 0; i < d; i++) {\n      for (int j = 0; j < n; j++) cout << students[j][i] + 1 << ' ';\n      cout << endl;\n    }\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author xwchen\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int k = in.nextInt();\n            int d = in.nextInt();\n            long m = 1;\n            int[] a = new int[n];\n            for (int i = 0; i < n; ++i) {\n                a[i] = i;\n            }\n            for (int i = 0; i < d; ++i) {\n                m *= k;\n                if (m >= n) {\n                    m = n;\n                }\n            }\n            if (n > m) {\n                out.println(-1);\n            } else {\n                long p = 1;\n                for (int i = 0; i < d; ++i) {\n                    p *= k;\n                    for (int j = 0; j < n; ++j) {\n                        out.print((a[j] % k) + 1 + \" \");\n                        a[j] /= k;\n                    }\n                    out.println();\n                }\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer = new StringTokenizer(\"\");\n\n        public InputReader(InputStream inputStream) {\n            this.reader = new BufferedReader(\n                    new InputStreamReader(inputStream));\n        }\n\n        public String next() {\n            while (!tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 1,
            "solution": "from sys import stdin,stdout,setrecursionlimit,maxint,exit\nsetrecursionlimit(2*10**4)\ndef listInput():\n return map(long,stdin.readline().split())\ndef printBS(li):\n for i in xrange(len(li)-1):\n  stdout.write(\"%d \"%li[i])\n stdout.write(\"%d\\n\"%li[-1])\ndef sin():\n return stdin.readline().rstrip()\n# n- no of students\n# d- no of days(trips)\n# k- no of buses\n# for each day..a stduenr can be assigned a\n# bus\n# i.e. for for d days...k^d possible ordering \n# of buses for d days..\n# i.e. atmax..k^d distinct orderings of buses possible that \n#can be assigned to students\n# n>k^d not possible\n# otherwise to find a order can use\n# orderings of k upto nth ordering in increasing order\n#for each student\ndef maxprod(k,d):\n t=float(1)\n for i in xrange(1,d+1):\n  t*=k\n  if t>1000:\n   return t\n return t\nn,k,d=listInput()\nif n>maxprod(k,d):\n print -1\n exit(0)\norders=[]\nos=0\ndef ways(i,d,no):\n global os\n if i==d+1:\n  orders.append(list(no))\n  os+=1\n  return\n for j in xrange(1,k+1):\n  if os>n:\n   return\n  no.append(j)\n  ways(i+1,d,no)\n  no.pop()\nways(1,d,[])\n#print orders\nfor i in xrange(d):\n  out=[str(orders[j][i]) for j in xrange(n)]\n  stdout.write(\" \".join(out)+\"\\n\")"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\nI = lambda : list(map(int,input().split()))\n\nn,k,d = I()\nst=0;ct=0\nif n<=k:\n\tfor i in range(d):\n\t\tfor j in range(n):\n\t\t\tprint(j+1,end=\" \")\n\t\tprint(\"\")\n\texit()\nan=[[0]*n for i in range(d)]\ntp=1;s=0\nfor i in range(d):\n\ttp*=k\n\tif tp>=n:\n\t\ts=1;break\nif s:\n\tst=0\n\n\tdef conv(x):\n\t\tp=[]\n\t\twhile x:\n\t\t\tp.append(x%k)\n\t\t\tx//=k\n\t\tp=[0]*(d-len(p))+p[::-1]\n\t\treturn p\n\tfor i in range(n):\n\t\ts=conv(st)\n\t\tfor j in range(d-1,-1,-1):\n\t\t\tan[j][i]=s[j]+1\n\t\tst+=1\n\tfor i in range(d):\n\t\tprint(*an[i])\nelse:\n\tprint(-1)"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Solution{\n    public static int n,k,d;\n    public static int[][] t;\n    public static void divise(HashSet<Integer> hs,int l){\n        if(l==d) return;\n        int div = hs.size()/k;\n        int mod = hs.size()%k;\n        HashSet<Integer>[] h = new HashSet[k];\n        for(int i=0;i<k;i++) h[i] = new HashSet<Integer>();\n        int[] num = new int[k];\n        num[0] = div;\n        if(mod>0){\n            mod--;\n            num[0]++;\n        }\n        for(int i=1;i<k;i++){\n            num[i] = num[i-1]+div;\n            if(mod>0){\n                mod--;\n                num[i]++;\n            }\n        }\n        int id = 0;\n        int p = 0;\n        for(int x:hs){\n            while(id>=num[p]){\n                p++;\n            }\n            h[p].add(x);\n            id++;\n        }\n        for(int i=0;i<k;i++){\n            for(int x:h[i]){\n                t[l][x-1] = i+1;\n            }\n        }\n        for(int i=0;i<k;i++) if(h[i].size()>1) divise(h[i],l+1);\n    }\n    public static void main(String[] args)throws IOException{\n        BufferedReader br =  new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        n = Integer.parseInt(st.nextToken());\n        k = Integer.parseInt(st.nextToken());\n        d = Integer.parseInt(st.nextToken());\n        t = new int[d][n];\n        for(int i=0;i<d;i++) Arrays.fill(t[i],1);\n        boolean ok = false;\n        if(k>=n){\n            for(int i=0;i<n;i++) t[0][i] = i+1;\n            ok = true;\n            //affiche(t,d,n);\n        }else{\n            int r = n;\n            for(int i=0;i<d;i++){\n                if(r%k==0) r /= k;\n                else r = r/k+1;\n            }\n            if(r!=1) out.println(\"-1\");\n            else{\n                HashSet<Integer> hs = new HashSet<Integer>();\n                for(int i=1;i<=n;i++) hs.add(i);\n                divise(hs,0);\n                ok = true;\n                //affiche(t,d,n);\n            }\n        }\n        if(ok){\n            for(int i=0;i<d;i++){\n                out.print(t[i][0]);\n                for(int j=1;j<n;j++){\n                    out.print(\" \"+t[i][j]);\n                }\n                out.println(\"\");\n            }\n        }\n        out.flush();\n   }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long n, k, d, x;\n  cin >> n >> k >> d;\n  int i, j;\n  x = 1;\n  for (i = 0; i < d && x < n; ++i) {\n    x = x * k;\n  }\n  if (x < n) {\n    printf(\"-1\\n\");\n    return 0;\n  }\n  x /= k;\n  x = max(1LL, x);\n  int c = 0;\n  for (i = 0; i < d; ++i) {\n    c = -1;\n    for (j = 0; j < n; ++j) {\n      if (j % x == 0) {\n        c = (c + 1) % k;\n      }\n      printf(\"%d \", c + 1);\n    }\n    putchar('\\n');\n    x = max(1LL, x / k);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, d, k;\nbool b() {\n  if (n <= 1) return true;\n  if (d == 1) return false;\n  if (k == 1) return false;\n  return true;\n}\nint x[2000][2000];\ninline bool f(int lev, long long k) {\n  long long den = 1;\n  for (int i = 0; i < lev; i++) {\n    den = den * k;\n    if (den > n) break;\n  }\n  int w = -1;\n  for (long long i = 0; i < n; i++) {\n    if (i % den == 0) {\n      w = (w + 1) % k;\n    }\n    x[lev][i] = w;\n  }\n}\nbool g() {\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      bool w = 1;\n      for (int p = 0; p < d && w; p++) {\n        if (x[p][i] != x[p][j]) w = 0;\n      }\n      if (w) return 1;\n    }\n  }\n  return false;\n}\nint main() {\n  while (cin >> n >> k >> d) {\n    int s = 0;\n    if (k >= n) {\n      for (int p = 0; p < d; p++) {\n        for (int i = 0; i < n; i++) {\n          x[p][i] = i;\n        }\n      }\n    } else {\n      for (int p = 0; p < d; p++) {\n        f(p, k);\n      }\n    }\n    if (g()) {\n      printf(\"-1\\n\");\n      return 0;\n    }\n    stringstream ss;\n    for (int p = 0; p < d; p++) {\n      for (int i = 0; i < n; i++) {\n        ss << x[p][i] + 1 << (i < n - 1 ? ' ' : '\\n');\n      }\n    }\n    cout << ss.str();\n    return 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class C {\n\tpublic C() \n\t{\n\t\tScanner s = new Scanner();\n\t\n\t\tlong n = s.nextInt();\n\t\tlong k = s.nextInt();\n\t\tlong d = s.nextInt();\n\t\n\t\tif (k == 1 && n > 1) {\n\t\t\tSystem.out.println(-1);\n\t\t\tSystem.exit(0);\n\t\t}\n\t\tint[][] ints = new int[(int)n][(int)d];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t//System.out.println(i);\n\t\t\tints[i] = convertToNBits(i, (int)k,(int) d );\n\t\t}\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < d; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tsb.append((ints[j][i] + 1) + \" \" );\n\t\t\t\tif (ints[j].length > d) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsb.append(\"\\n\");\n\t\t\t\n\t\t}\n\t\tSystem.out.print(sb);\n\t\n\t}\n\t\n\n\t//start, an array of integers at each position\n\t\t//n the base of the integers.\n\t\t//Example   createBigInt({1,1,2}, 3)  returns   22\n\t\t//NOTE, the digits in the int[]s are such that lowest \"bit\"/power is to the left\n\t\tpublic static BigInteger createBigInt(int[] start, int n) {\n\t\t\tBigInteger total = BigInteger.ZERO;\n\t\t\tBigInteger base = BigInteger.valueOf(n);\n\t\t\tfor (int i = 0; i < start.length; i++) {\n\t\t\t\tBigInteger cur = BigInteger.valueOf(start[i]);\n\t\t\t\ttotal = total.add(cur.multiply(base.pow(i)));\n\t\t\t}\n\t\t\t\n\t\t\treturn total;\n\t\t}\n\t\t\n\t\tpublic static int[] convertToNBits (BigInteger value, int base, int min_size) {\n\t\t\tArrayList<Integer> result = new ArrayList<Integer>();\n\t\t\tBigInteger b = BigInteger.valueOf(base);\n\t\t\twhile (value.compareTo(BigInteger.ZERO) > 0) {\n\t\t\t\tBigInteger mod = value.remainder(b);\n\t\t\t\tresult.add((int) mod.longValue());\n\t\t\t\tvalue = value.divide(b);\n\t\t\t}\n\t\t\t\n\t\t\tint[] fin = new int[Integer.max(min_size, result.size())];\n\t\t\tint i;\n\t\t\tfor (i = 0; i < result.size(); i++) {\n\t\t\t\tfin[i] = result.get(i);\n\t\t\t}\n\t\t\tfor (;i<min_size;i++){//set \"leading\" zeroes\n\t\t\t\tfin[i] = 0;\n\t\t\t}\n\t\t\treturn fin;\n\t\t\t\n\t\t}\n\t\tstatic ArrayList<Integer> result = new ArrayList<Integer>(1000);\n\t\tpublic static int[] convertToNBits (int value, int base, int min_size) {\n\t\t\t\n\t\t\tresult.clear();\n\t\t\twhile (value > 0) {\n\t\t\t\tint mod = value % base;\n\t\t\t\tresult.add( mod);\n\t\t\t\tvalue /= base;\n\t\t\t}\n\t\t\t\n\t\t\tint[] fin = new int[Integer.max(min_size, result.size())];\n\t\t\tint i;\n\t\t\tfor (i = 0; i < result.size(); i++) {\n\t\t\t\tfin[i] = result.get(i);\n\t\t\t}\n\t\t\tfor (;i<min_size;i++){//set \"leading\" zeroes\n\t\t\t\tfin[i] = 0;\n\t\t\t}\n\t\t\treturn fin;\n\t\t\t\n\t\t\t\n\t\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew C();\n\t}\n\n\tpublic static class Scanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic Scanner(Reader in) {\n\t\t\tbr = new BufferedReader(in);\n\t\t}\n\n\t\tpublic Scanner() {\n\t\t\tthis(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\t// Slightly different from java.util.Scanner.nextLine(),\n\t\t// which returns any remaining characters in current line,\n\t\t// if any.\n\t\tString readNextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t\tpublic int[] readNextLineInts(int numberOfInts) {\n\t\t\tint[] ints = new int[numberOfInts];\n\t\t\tfor (int i = 0; i < numberOfInts; i++)\n\t\t\t\tints[i] = nextInt();\n\t\t\treturn ints;\n\t\t}\n\t\t\n\t\tpublic double[] readNextLineDoubles(int numberOfDoubles) {\n\t\t\tdouble[] doubles = new double[numberOfDoubles];\n\t\t\tfor (int i = 0; i < numberOfDoubles; i++)\n\t\t\t\tdoubles[i] = nextDouble();\n\t\t\treturn doubles;\n\t\t}\n\t\t// --------------------------------------------------------\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint res[1005][1005];\nint main() {\n  int n, k, d, i, j;\n  while (cin >> n >> k >> d) {\n    int flag = 0;\n    int t = 1;\n    for (i = 0; i < d; i++) {\n      t *= k;\n      if (t >= n) {\n        flag = 1;\n        break;\n      }\n    }\n    if (flag == 0) {\n      puts(\"-1\");\n    } else {\n      for (j = 0; j < n; j++) {\n        for (i = 0; i < d; i++) {\n          if (j == 0)\n            res[i][j] = 1;\n          else\n            res[i][j] = res[i][j - 1];\n        }\n        if (j == 0) continue;\n        res[d - 1][j]++;\n        for (i = d - 1; i >= 0; i--) {\n          if (res[i][j] > k) {\n            res[i][j] %= k;\n            res[i - 1][j]++;\n          } else\n            break;\n        }\n      }\n      for (i = 0; i < d; i++) {\n        for (j = 0; j < n; j++) {\n          printf(\"%d \", res[i][j]);\n        }\n        printf(\"\\n\");\n      }\n    }\n    return 0;\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "n,k,d=map(int,input().split())\nif n>k**d:print(-1);exit(0)\nK=1\nfor j in range(d):\n    print(\" \".join([str(i//K%k +1) for i in range(n)]))\n    K*=k"
        },
        {
            "language": 4,
            "solution": "import java.util.*;import java.io.*;import java.math.*;\npublic class Main\n{\n    public static void process()throws IOException\n    {\n        int n=ni();\n        int k=ni();\n        int d=ni();\n        if(n==1)\n            {for(int i=0;i<d;i++)pn(1);return;}\n        if(k==1)\n            {pn(-1);return;}\n        long curr=1;\n        int flag=0;\n        for(int i=1;i<=d;i++)\n        {\n            curr*=k;\n            if(curr>=n)\n                {flag=1;break;}\n        }\n\n        if(flag==0)\n        {pn(-1);return;}\n        curr=1;\n        for(int i=0;i<d;i++)\n        {\n            if(curr>=n)\n            {\n                for(int j=0;j<n;j++)\n                    p(1+\" \");\n                pn(\"\");\n            }\n            else\n            {\n                for(int j=0;j<n;j++)\n                {\n                    int term=(j/(int)curr)%k+1;\n                    p(term+\" \");\n                }\n                pn(\"\");\n                curr*=k; \n            }\n              \n        }\n    }\n\n    static AnotherReader sc;\n    static PrintWriter out;\n    public static void main(String[]args)throws IOException\n    {\n        boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n        if(oj){sc=new AnotherReader();out=new PrintWriter(System.out);}\n        else{sc=new AnotherReader(100);out=new PrintWriter(\"output.txt\");}\n        int t=1;\n       // t=ni();\n        while(t-->0) {process();}\n        out.flush();out.close();  \n    }\n\n    static void pn(Object o){out.println(o);}\n    static void p(Object o){out.print(o);}\n    static void pni(Object o){out.println(o);out.flush();}\n    static int ni()throws IOException{return sc.nextInt();}\n    static long nl()throws IOException{return sc.nextLong();}\n    static double nd()throws IOException{return sc.nextDouble();}\n    static String nln()throws IOException{return sc.nextLine();}\n    static int[] nai(int N)throws IOException{int[]A=new int[N];for(int i=0;i!=N;i++){A[i]=ni();}return A;}\n    static long[] nal(int N)throws IOException{long[]A=new long[N];for(int i=0;i!=N;i++){A[i]=nl();}return A;}\n    static long gcd(long a, long b)throws IOException{return (b==0)?a:gcd(b,a%b);}\n    static int gcd(int a, int b)throws IOException{return (b==0)?a:gcd(b,a%b);}\n    static int bit(long n)throws IOException{return (n==0)?0:(1+bit(n&(n-1)));}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    static class AnotherReader{BufferedReader br; StringTokenizer st;\n    AnotherReader()throws FileNotFoundException{\n    br=new BufferedReader(new InputStreamReader(System.in));}\n    AnotherReader(int a)throws FileNotFoundException{\n    br = new BufferedReader(new FileReader(\"input.txt\"));}\n    String next()throws IOException{\n    while (st == null || !st.hasMoreElements()) {try{\n    st = new StringTokenizer(br.readLine());}\n    catch (IOException  e){ e.printStackTrace(); }}\n    return st.nextToken(); } int nextInt() throws IOException{\n    return Integer.parseInt(next());}\n    long nextLong() throws IOException\n    {return Long.parseLong(next());}\n    double nextDouble()throws IOException { return Double.parseDouble(next()); }\n    String nextLine() throws IOException{ String str = \"\"; try{\n    str = br.readLine();} catch (IOException e){\n    e.printStackTrace();} return str;}}\n   \n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, d, k;\nint ans[1100][1100];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> k >> d;\n  long long int temp = 1;\n  bool check = false;\n  for (int i = 0; i < d; i += 1) {\n    temp *= k;\n    if (temp >= n) {\n      check = true;\n      break;\n    }\n  }\n  if (check == false) {\n    cout << \"-1\" << endl;\n    return 0;\n  }\n  for (int i = 1; i < n; i += 1) {\n    for (int j = 0; j < d; j += 1) {\n      ans[i][j] = ans[i - 1][j];\n      for (int j = d - 1; j >= 0; j -= 1) {\n        ans[i][j] = (ans[i][j] + 1) % k;\n        if (ans[i][j]) {\n          break;\n        }\n      }\n    }\n  }\n  for (int i = 0; i < d; i += 1) {\n    for (int j = 0; j < n; j += 1) {\n      cout << ans[j][i] + 1 << \" \";\n    }\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dcmp(double x, double y) {\n  return fabs(x - y) <= 1e-8 ? 0 : x < y ? -1 : 1;\n}\nint n, k, d, nk = 1;\nset<vector<int> > second;\nvector<int> v;\nvoid solve(int l) {\n  if (second.size() == n) return;\n  if (l == d) return void(second.insert(v));\n  for (int i = 1; i <= nk; i++) {\n    v.push_back(i);\n    solve(l + 1);\n    v.pop_back();\n  }\n}\nint ans[1005][1005];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k >> d;\n  if (dcmp(d * log(k), log(n)) < 0) return cout << -1, 0;\n  while (dcmp(d * log(nk), log(n)) < 0) nk++;\n  solve(0);\n  int i = 0;\n  for (auto x : second) {\n    for (int j = 0; j < d; j++) ans[j][i] = x[j];\n    i++;\n  }\n  for (int i = 0; i < d; i++, cout << '\\n')\n    for (int j = 0; j < n; j++) cout << ans[i][j] << \" \";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int n, k, d;\nbool pw() {\n  long long int i, res = 1;\n  for (i = 0; i < d; i++) {\n    res *= k;\n    if (res >= n) return true;\n  }\n  return false;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  long long int i, j, x, y, temp;\n  cin >> n >> k >> d;\n  long long int result[n][d];\n  if (!pw()) {\n    cout << -1 << \"\\n\";\n  } else {\n    for (i = 0; i < d; i++) result[0][i] = 1;\n    for (i = 1; i < n; i++) {\n      copy(result[i - 1], result[i - 1] + d, result[i]);\n      result[i][d - 1]++;\n      temp = d - 1;\n      while (result[i][temp] == k + 1) {\n        result[i][temp] = 1;\n        temp--;\n        result[i][temp]++;\n      }\n    }\n    for (i = 0; i < d; i++) {\n      for (j = 0; j < n; j++) {\n        cout << result[j][i] << \"\\t\";\n      }\n      cout << \"\\n\";\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class Main{\n    public static void main(String args[]) throws IOException\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st;\n        st=new StringTokenizer(br.readLine());\n        int n=Integer.parseInt(st.nextToken());\n        int  k=Integer.parseInt(st.nextToken());\n        int d=Integer.parseInt(st.nextToken());\n        int f=1;\n        boolean yes=false;\n        for(int i=0;i<d;i++)\n        {\n            f*=k;\n            if(f>=n)\n            {\n                yes=true;\n                break;\n            }\n        }\n        if(!yes)\n        {\n            System.out.print(-1);\n            return;\n        }\n        int ans[][]=new int[d][n];\n        for(int i=1;i<n;i++)\n        {\n            for(int j=0;j<d;j++)\n                ans[j][i]=ans[j][i-1];\n            for(int j=0;j<d;j++)\n            {\n                ans[j][i]=(ans[j][i]+1)%k;\n                if(ans[j][i]!=0)\n                    break;\n            }\n        }\n        StringBuilder res=new StringBuilder(\"\");\n        for(int i=0;i<d;i++){\n            for(int j=0;j<n;j++)\n                res.append((ans[i][j]+1)+\" \");//System.out.print((ans[i][j]+1)+\" \");\n            res.append(\"\\n\");//System.out.println();\n        } \n        System.out.print(res);\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.util.List;\n\npublic class Main {\n    private static StringTokenizer st;\n    private static BufferedReader br;\n    public static long MOD = 1000000007;\n\n    public static void print(Object x) {\n        System.out.println(x + \"\");\n    }\n    public static String join(List<?> x, String space) {\n        StringBuilder sb = new StringBuilder();\n        for (Object elt : x) {\n            sb.append(elt);\n            sb.append(space);\n        }\n        return sb.toString();\n    }\n\n    public static String nextToken() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine().trim());\n        }\n        return st.nextToken();\n    }\n    public static double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n    public static long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n    public static List<Double> nextDoubles(int n) throws IOException{\n        List<Double> lst = new ArrayList<Double>();\n        for (int i = 0; i < n; i++) {\n            lst.add(nextDouble());\n        }\n        return lst;\n    }\n    public static List<Integer> nextInts(int n) throws IOException{\n        List<Integer> lst = new ArrayList<Integer>();\n        for (int i = 0; i < n; i++) {\n            lst.add(nextInt());\n        }\n        return lst;\n    }\n    public static List<Long> nextLongs(int n) throws IOException{\n        List<Long> lst = new ArrayList<Long>();\n        for (int i = 0; i < n; i++) {\n            lst.add(nextLong());\n        }\n        return lst;\n    }\n\n    public static List<Integer> emptyList(int n, int val) {\n        List<Integer> lst = new ArrayList<Integer>();\n        for (int i = 0; i < n; i++) {\n            lst.add(val);\n        }\n        return lst;\n    }\n\n    public static String solve(int n, int k, int d) {\n        if (n == 1) {\n            for (int i = 0; i < d; i++) print(\"1\");\n            return \"\";\n        }\n        if (k == 1) {\n            return \"-1\";\n        }\n\n        int maxDay = 1;\n        long val = k;\n        while (val < n) {\n            maxDay += 1;\n            val *= k;\n        }\n        if (maxDay > d) return \"-1\";\n\n        for (int i = 0; i < d; i++) {\n            if (i < maxDay) {\n                int rollover = (int) Math.pow(k, i);\n                int bus = 0;\n                int counter = 0;\n                StringBuilder s = new StringBuilder();\n                for (int student = 0; student < n; student++) {\n                    s.append((bus + 1) + \" \");\n                    counter++;\n                    if (counter == rollover) {\n                        counter = 0;\n                        bus = (bus + 1) % k;\n                    }\n                }\n                print(s.toString());\n            } else {\n                StringBuilder s = new StringBuilder();\n                for (int j = 0; j < n; j++) {\n                    s.append(\"1 \");\n                }\n                print(s.toString());\n            }\n        }\n        return \"\";\n    }\n\n    public static void main(String[] args) throws Exception {\n        //long time = System.currentTimeMillis();\n        boolean debug = false;\n        InputStream in = System.in;\n        if (debug) {\n            in = new FileInputStream(\"input.in\");\n        }\n        br = new BufferedReader(new InputStreamReader(in));\n\n        int n = nextInt();\n        int k = nextInt();\n        int d = nextInt();\n        print(solve(n, k, d));\n    }\n}\n"
        },
        {
            "language": 1,
            "solution": "from sys import stdin,stdout\nfrom itertools import product\nn,k,d=map(int,stdin.readline().split())\nif n>k**d:\n    print -1\nelse:\n    l1=[]\n    if k>=10**3 or n<=k:\n        a='1'\n        l=['1']*(d-1)\n        for i in range(n):\n            l1.append(l+[a])\n            a=str(int(a)+1)\n    else:\n        c=product([str(i) for i in range(1,k+1)],repeat=d)\n        l=[0]*d\n        a=1\n        for l in c:\n            l1.append(l)\n            a+=1\n            if a==n+1:\n                  break\n    l2=[]\n    for i in range(d):\n        l2.append([])\n    for i in range(d):\n        for j in range(n):\n            l2[i].append(l1[j][i])\n    for i in l2:\n        stdout.write(' '.join(i)+'\\n')\n            \n    \n            \n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.util.InputMismatchException;\n\n/**\n *\n * @author jigsaw\n */\npublic class Main {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        InputStream inputstream = System.in;\n        OutputStream outputstream = System.out;\n        InputReader in = new InputReader(inputstream);\n        OutputWriter outt = new OutputWriter(outputstream);\n        int n = in.readInt();\n        int k = in.readInt();\n        int d = in.readInt();\n        if(d==1){\n            if(k<n)\n                outt.printLine(-1);\n            else{\n                for(int i=1;i<=n;i++)\n                    outt.print(i+\" \");\n                outt.printLine();\n            }\n        }\n        else if(k==1&&n>1){\n            outt.printLine(-1);\n        }\n        else if(n>Math.pow(k, d)){\n            outt.printLine(-1);\n        }\n        else{\n            if(n<=k){\n                for(int i=1;i<=d;i++){\n                    for(int j=1;j<=n;j++)\n                        outt.print(j+\" \");\n                    outt.printLine(\"\");\n                }\n                    \n            }\n            else{\n                for(int D=0;D<d;D++){\n                    long m = (long)Math.pow(k, D);\n                    int x = 0;\n                    int count = 0;\n                    for(int i=0;i<n;i++){\n                        if(count%m==0){\n                            x++;\n                        }\n                        x = x%k;\n                        if(x==0)\n                            x = k;\n                        outt.print(x+\" \");\n                        count++;\n                    }\n                    outt.printLine(\"\");\n                }\n            }\n            \n        }\n        outt.close();\n    }\n}\nclass InputReader {\n \n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private InputReader.SpaceCharFilter filter;\n \n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n \n    public int read() {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n \n    public int readInt() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n \n    public String readString() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        StringBuffer res = new StringBuffer();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n        return res.toString();\n    }\n \n    public boolean isSpaceChar(int c) {\n        if (filter != null)\n            return filter.isSpaceChar(c);\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n \n    public String next() {\n        return readString();\n    }\n \n    public interface SpaceCharFilter {\n        public boolean isSpaceChar(int ch);\n    }\n}\n \nclass OutputWriter {\n    private final PrintWriter writer;\n \n    public OutputWriter(OutputStream outputStream) {\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n \n    public OutputWriter(Writer writer) {\n        this.writer = new PrintWriter(writer);\n    }\n \n    public void print(Object...objects) {\n        for (int i = 0; i < objects.length; i++) {\n            if (i != 0)\n                writer.print(' ');\n            writer.print(objects[i]);\n        }\n    }\n \n    public void printLine(Object...objects) {\n        print(objects);\n        writer.println();\n    }\n \n    public void close() {\n        writer.close();\n    }}\n\n"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/python3\n\nimport sys\n\n# 1\u2009<=\u2009n,\u2009d\u2009<=\u20091000, 1\u2009<=\u2009k\u2009<=\u200910**9\nn, k, d = map(int, sys.stdin.readline().split())\n\nno_sol = False\nsolution = [[1 for j in range(n)] for i in range(d)]\n\n\ndef schedule(i, j, level):\n    global no_sol\n    if level >= d:\n        no_sol = True\n        return\n    count = j - i\n    chunk = count // k\n    extra = count % k\n    r = i\n    for t in range(min(k, count)):\n        size = chunk + (1 if t < extra else 0)\n        for z in range(size):\n            solution[level][r+z] = t+1\n        if size > 1:\n            schedule(r, r + size, level + 1)\n        r += size\n\nif k == 1:\n    if n > 1:\n        no_sol = True\nelse:\n    schedule(0, n, 0)\n\nif no_sol:\n    print(-1)\nelse:\n    for l in solution:\n        print(' '.join(str(x) for x in l))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nT in() {\n  char ch;\n  T n = 0;\n  bool ng = false;\n  while (1) {\n    ch = getchar();\n    if (ch == '-') {\n      ng = true;\n      ch = getchar();\n      break;\n    }\n    if (ch >= '0' && ch <= '9') break;\n  }\n  while (1) {\n    n = n * 10 + (ch - '0');\n    ch = getchar();\n    if (ch < '0' || ch > '9') break;\n  }\n  return (ng ? -n : n);\n}\ntemplate <typename T>\ninline T POW(T B, T P) {\n  if (P == 0) return 1;\n  if (P & 1)\n    return B * POW(B, P - 1);\n  else\n    return (POW(B, P / 2) * POW(B, P / 2));\n}\ntemplate <typename T>\ninline T Gcd(T a, T b) {\n  if (a < 0) return Gcd(-a, b);\n  if (b < 0) return Gcd(a, -b);\n  return (b == 0) ? a : Gcd(b, a % b);\n}\ntemplate <typename T>\ninline T Lcm(T a, T b) {\n  if (a < 0) return Lcm(-a, b);\n  if (b < 0) return Lcm(a, -b);\n  return a * (b / Gcd(a, b));\n}\nlong long Bigmod(long long base, long long power, long long MOD) {\n  long long ret = 1;\n  while (power) {\n    if (power & 1) ret = (ret * base) % MOD;\n    base = (base * base) % MOD;\n    power >>= 1;\n  }\n  return ret;\n}\nbool isVowel(char ch) {\n  ch = toupper(ch);\n  if (ch == 'A' || ch == 'U' || ch == 'I' || ch == 'O' || ch == 'E')\n    return true;\n  return false;\n}\ntemplate <typename T>\nlong long int isLeft(T a, T b, T c) {\n  return (a.x - b.x) * (b.y - c.y) - (b.x - c.x) * (a.y - b.y);\n}\nlong long ModInverse(long long number, long long MOD) {\n  return Bigmod(number, MOD - 2, MOD);\n}\nbool isConst(char ch) {\n  if (isalpha(ch) && !isVowel(ch)) return true;\n  return false;\n}\nint toInt(string s) {\n  int sm;\n  stringstream second(s);\n  second >> sm;\n  return sm;\n}\nvector<vector<int> > A;\nint d, n, k;\nvoid Dekhi(vector<int> v, int ln) {\n  if (A.size() == n) return;\n  if (ln == d) {\n    A.push_back(v);\n    return;\n  }\n  for (int i = 1; i < k + 1; i++) {\n    vector<int> tp = v;\n    tp.push_back(i);\n    Dekhi(tp, ln + 1);\n    if (A.size() == n) {\n      break;\n    }\n  }\n}\nint main() {\n  n = in<int>(), k = in<int>(), d = in<int>();\n  vector<int> v;\n  Dekhi(v, 0);\n  if (A.size() < n) {\n    return 0 * puts(\"-1\");\n  }\n  for (int i = 0; i < d; i++) {\n    for (int j = 0; j < A.size(); j++) {\n      printf(\"%d \", A[j][i]);\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k, d;\nlong long a[10000];\nlong long ans[1005][1005];\nlong long ppow(long long a, long long k) {\n  long long ans = 1;\n  for (int i = 1; i <= k; i++) ans *= a;\n  return ans;\n}\nint main() {\n  cin >> n >> k >> d;\n  int s = 1;\n  bool flag = 0;\n  for (int i = 1; i <= d; i++) {\n    s *= k;\n    if (s >= n) {\n      flag = 1;\n      break;\n    }\n  }\n  if (flag == 0)\n    puts(\"-1\");\n  else {\n    for (int y = 2; y <= n; y++) {\n      for (int x = 1; x <= d; x++) ans[x][y] = ans[x][y - 1];\n      for (int x = 1; x <= d; x++) {\n        ans[x][y] = (ans[x][y] + 1) % k;\n        if (ans[x][y]) break;\n      }\n    }\n    for (int i = 1; i <= d; i++, cout << endl)\n      for (int j = 1; j <= n; j++) cout << ans[i][j] + 1 << \" \";\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class P_459C {\n    static final FS sc = new FS();\n    static final PrintWriter pw = new PrintWriter(System.out);\n    static int[][] s;\n    static long pow;\n//    static void stringify(long k, long n, long d){\n//        int[] t = new int[(int) k];\n//        for(int i=0; i<k; i++){\n//            t[i] = i+1;\n//        }\n//        for(int i=0; i<n; i++){\n//            long temp = i;\n//            int index = (int) (d-1);\n//            String si = \"\";\n//            while(index>=0){\n//                int rem = (int) (temp%k);\n//                s[i][index] = Integer.toString(t[rem]).charAt(0);\n//                temp /= k;\n//                index--;\n//            }\n//        }\n//    }\n    public static void main(String[] args) {\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        int d = sc.nextInt();\n        pow = (long) Math.pow(k,d);\n        s = new int[n][d];\n        if(n>pow){\n            System.out.println(\"-1\");\n        }\n        else{\n            for(int i=1; i<n; i++){\n                if (d >= 0) System.arraycopy(s[i - 1], 0, s[i], 0, d);\n                for(int j = (int) (d-1); j>=0; j--){\n                    s[i][j] = (int) ((s[i][j] + 1)%k);\n                    if(s[i][j]!=0) break;\n                }\n            }\n            StringBuilder sb = new StringBuilder();\n            for(int i=0; i<d; i++){\n                for(int j=0; j<n; j++){\n                    sb.append(s[j][i] + 1).append(\" \");\n                }\n                sb.append(\"\\n\");\n            }\n            System.out.print(sb.toString());\n        }\n    }\n\n    static class FS {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        String next() {\n            while (!st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (Exception ignored) {\n                }\n            }\n            return st.nextToken();\n        }\n\n        int[] nextArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextLong();\n            }\n            return a;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\n\npublic class C\n{\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tScanner in = new Scanner(System.in);\n\t\tPrintWriter writer = new PrintWriter(new OutputStreamWriter(System.out));\n\t\tint n = in.nextInt();\n\t\tlong k = in.nextInt();\n\t\tint d = in.nextInt();\n\n\t\tlong pow = 1;\n\t\tboolean ok = false;\n\t\tfor(int i = 0 ; i < d ; i++)\n\t\t{\n\t\t\tpow *= k;\n\t\t\tif(pow >= n)\n\t\t\t{\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!ok)\n\t\t{\n\t\t\twriter.println(-1);\n\t\t\twriter.flush();\n\t\t\twriter.close();\n\t\t\treturn;\n\t\t}\n\n\t\tint [][] nd = new int[n][d];\n\n\t\tfor(int i = 1 ; i < n ; i++)\n\t\t\tnd[i] = add(nd[i-1], k);\n\n\t\tfor(int j = 0 ; j < d ; j++)\n\t\t{\n\t\t\tfor(int i = 0 ; i < n ; i++)\n\t\t\t{\n\t\t\t\twriter.print(nd[i][j]+1);\n\t\t\t\tif(i==n-1)\n\t\t\t\t\twriter.println();\n\t\t\t\telse\n\t\t\t\t\twriter.print(\" \");\n\t\t\t}\n\t\t}\n\n\t\twriter.flush();\n\t\twriter.close();\n\n\n\t}\n\n\tprivate static int[] add(int[] p, long k)\n\t{\n\t\tint [] r = p.clone();\n\n\t\tfor(int i = p.length-1 ; i >= 0 ; i--)\n\t\t{\n\t\t\tif(p[i] == k-1)\n\t\t\t{\n\t\t\t\tr[i] = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr[i]++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn r;\n\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint main() {\n  int n, k, d;\n  int r[1000][1000] = {};\n  std::scanf(\"%d%d%d\", &n, &k, &d);\n  for (int i(1); i < n; ++i) {\n    std::memcpy(r[i], r[i - 1], sizeof(r[0]));\n    r[i][0]++;\n    for (int j(0); j < d - 1; ++j) {\n      if (r[i][j] < k) break;\n      r[i][j] = 0, r[i][j + 1]++;\n    }\n  }\n  if (r[n - 1][d - 1] < k) {\n    for (int j(0); j < d; ++j) {\n      for (int i(0); i < n; ++i) {\n        if (0 < i) std::printf(\" \");\n        std::printf(\"%d\", r[i][j] + 1);\n      }\n      std::puts(\"\");\n    }\n  } else {\n    std::puts(\"-1\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "#http://codeforces.com/problemset/problem/459/C\n\n# Input of the values\nn, k, d = map(int, input().split())\n\n#Convention : \tBusses are numbered from 1 to k\n#\t\t\t\tStudents are numbered from 0 to k - 1\n# \t\t\t\tDays are numbered from 0 to k - 1\n\n# Variable for success\nsuccess = True\n\n# answer is a  2-d array that stores the bus number each student used on a particular day\n# Students are numbered from 0 to n-1\nanswer = [[] for x in range(n)]\n\n# Initialising the first students details manually\n# The first student uses the bus 1 for all of the days\nanswer[0] = [1 for x in range(d)]\n\n# we will be filling the details for each and every student and \n# would print -1 only if we cannot allot any bus number to the next student\nfor i_th_student in range(1,n):\n\t\n\t#answer for previous value\n\ti_minus_one_student = answer[i_th_student - 1]\n\n\t# Answer to the current student\n\tcurrent_student = list(i_minus_one_student)\n\n\t# Days are also numbered from 0 to d-1\n\tfor i_th_day in reversed(range(d)):\n\n\t\t# the condition to change the bus number \n\t\tif i_minus_one_student[i_th_day] < k :\n\n\t\t\tcurrent_student[i_th_day] += 1\n\n\t\t\t# all the numbers next to it are reset\n\t\t\tfor i in range(i_th_day + 1, d):\n\t\t\t\tcurrent_student[i] = 1\n\t\t\t\n\t\t\tbreak\n\t\n\t#Save the value\n\tanswer[i_th_student] = current_student\n\t\n\t#Failed\n\tif current_student == i_minus_one_student:\n\t\tsuccess = False\n\t\tbreak\n\n# printing the output\nif not(success):\n\tprint (\"-1\")\n\nelse:\n\t# ans_trans is used for giving the output fast\n\tanswer_trans= [[] for i in range(d)]\n\tfor y in range(n):\n\t\ti = 0\n\t\tfor x in answer[y]:\n\t\t\tanswer_trans[i].append(x)\n\t\t\ti += 1\n\tfor bla in answer_trans:\n\t\tprint (' '.join(map(str, bla)))\n"
        },
        {
            "language": 1,
            "solution": "def f(n, k, d):\n    if n > k**d:\n        print -1\n        return\n    s = [0] * d\n    t = [list(s)]\n    for _ in xrange(n-1):\n        j = d-1\n        while s[j] == k-1:\n            s[j] = 0\n            j -= 1\n        s[j] += 1\n        t.append(list(s))\n    for i in xrange(d):\n        print \" \".join(str(t[j][i]+1) for j in xrange(n))\nn, k, d = map(int, raw_input().split())\nf(n, k, d)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool binpow(long long a, long long n, long long c) {\n  long long b = 1;\n  while (n > 0) {\n    if (n & 1) b *= a;\n    a *= a;\n    n >>= 1;\n    if (b >= c) return true;\n    if (a >= c && n != 0) return true;\n  }\n  return false;\n}\nlong long binpow1(long long a, long long n) {\n  long long b = 1;\n  while (n > 0) {\n    if (n & 1) b *= a;\n    a *= a;\n    n >>= 1;\n    if (b >= 1000) return 1000;\n    if (a >= 1000 && n != 0) return 1000;\n  }\n  return b;\n}\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long n, k, d;\nint res[1100][1100];\nvoid solve() {\n  cin >> n >> k >> d;\n  if (!binpow(k, d, n)) {\n    cout << \"-1\\n\";\n    return;\n  }\n  long long p = 0;\n  for (int i = 1; i <= d; i++) {\n    p = binpow1(k, d - i);\n    int j = 1;\n    int z = 1;\n    while (j <= n) {\n      for (int l = 0; l < p; l++, j++) res[i][j] = z;\n      z++;\n      if (z == k + 1) z = 1;\n    }\n  }\n  for (int i = 1; i <= d; i++) {\n    for (int j = 1; j <= n; j++) cout << res[i][j] << \" \";\n    cout << endl;\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/python3\n\nimport sys\n\nn, k, d = list(map(int, sys.stdin.readline().split()))\n\nx = 1\nwhile x ** d < n:\n    x += 1\n    \nif x > k:\n    sys.stdout.write(\"-1\\n\")\n    sys.exit(0)\n    \nans = [[1 for i in range(n)] for j in range(d)]\nfor i in range(1, n):\n    for j in range(d): \n        ans[j][i] = ans[j][i - 1]\n    ans[d - 1][i] += 1\n    memo = 0\n    for j in range(d - 1, -1, -1):\n        ans[j][i] += memo\n        memo = 0\n        if ans[j][i] > x:\n            memo = ans[j][i] - x\n            ans[j][i] = 1\n            \nfor i in range(d):\n    sys.stdout.write(' '.join(map(str, ans[i])) + '\\n')"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class a {\npublic static void main(String[] args) throws IOException\n{\n    input.init(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n    int n = input.nextInt(), k = input.nextInt(), d = input.nextInt();\n    boolean good = false;\n    long cur = 1;\n    for(int i = 0; i<d; i++)\n    {\n        cur *= k;\n        if(cur >= n) good = true;\n    }\n    if(!good) out.println(-1);\n    else\n    {\n        int[][] res = new int[d][n];\n        long div = 1;\n        for(int i = 0; i<d; i++)\n        {\n            \n            for(int j = 0; j<n; j++)\n            {\n                res[i][j] = 1+(int)((j/div)%k);\n            }\n            if(div < n) div *= k;\n        }\n        for(int[] A: res)\n        {\n            for(int x: A) out.print(x+\" \");\n            out.println();\n        }\n    }\n    out.close();\n}\npublic static class input {\n    static BufferedReader reader;\n    static StringTokenizer tokenizer;\n\n    /** call this method to initialize reader for InputStream */\n    static void init(InputStream input) {\n        reader = new BufferedReader(\n                     new InputStreamReader(input) );\n        tokenizer = new StringTokenizer(\"\");\n    }\n\n    /** get next word */\n    static String next() throws IOException {\n        while ( ! tokenizer.hasMoreTokens() ) {\n            //TODO add check for eof if necessary\n            tokenizer = new StringTokenizer(\n                   reader.readLine() );\n        }\n        return tokenizer.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return Integer.parseInt( next() );\n    }\n    \n    static double nextDouble() throws IOException {\n        return Double.parseDouble( next() );\n    }\n    static long nextLong() throws IOException {\n        return Long.parseLong( next() );\n    }\n}\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\n\ndef no():\n    print(-1)\n    sys.exit(0)\n\nn, k, d = map(int, input().split())\n\nif n <= k:\n    for i in range(d):\n        print(' '.join(map(str, range(1, n + 1))))\nelif d == 1:\n    no()\nelif k == 1:\n    no()\nelse:\n    cur_step = 1\n    arrangement = []\n\n    while 1 + cur_step <= n:\n        arrangement.append([])\n        idx = 0\n        for i in range(1, n + 1):\n            arrangement[-1].append(idx + 1)\n            if i % cur_step == 0:\n                idx = (idx + 1) % k\n        cur_step *= k\n\n    if len(arrangement) > d:\n        no()\n    while len(arrangement) < d:\n        arrangement.append([1] * n)\n\n    print('\\n'.join(map(lambda x: ' '.join(map(str, x)), arrangement)))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, d;\nvoid genPer() {\n  long long int ii = 1;\n  for (int i = 1; i <= d; i++) {\n    for (int j = 1, b = 1; j <= n;) {\n      if (b > k) b = 1;\n      printf(\"%d\", b);\n      j++;\n      for (int c = 1; c < ii && j <= n; c++) {\n        printf(\" %d\", b);\n        j++;\n      }\n      if (j <= n) printf(\" \");\n      b++;\n    }\n    printf(\"\\n\");\n    ii *= k;\n  }\n}\nint main() {\n  scanf(\"%d %d %d\", &n, &k, &d);\n  if (log(n) / log(k) - (double)d > 1e-9) {\n    printf(\"-1\\n\");\n  } else {\n    genPer();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.StringTokenizer;\n\npublic class Problem458C {\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer stringTokenizer = new StringTokenizer(in.readLine());\n        long time = System.currentTimeMillis();\n        int numStudents = Integer.parseInt(stringTokenizer.nextToken());\n        int numBuses = Integer.parseInt(stringTokenizer.nextToken());\n        int numPlaces = Integer.parseInt(stringTokenizer.nextToken());\n        int[][] studentLoc = new int[numStudents][numPlaces];\n\n        for (int i = 0; i < numPlaces; i++) {\n            studentLoc[0][i] = 1;\n        }\n        for (int i = 1; i < numStudents; i++) {\n            System.arraycopy(studentLoc[i - 1], 0, studentLoc[i], 0, numPlaces);\n            studentLoc[i][0]++;\n            for (int j = 0; j < numPlaces; j++) {\n                if (studentLoc[i][j] > numBuses) {\n                    studentLoc[i][j] = 1;\n                    if (j < numPlaces - 1) {\n                        studentLoc[i][j + 1]++;\n                    } else {\n                        System.out.println(-1);\n                        System.exit(0);\n                    }\n                } else {\n                    break;\n                }\n            }\n        }\n        PrintWriter out = new PrintWriter(System.out);\n        for (int i = 0; i < numPlaces; i++) {\n            for (int j = 0; j < numStudents; j++) {\n                out.print((studentLoc[j][i]) + \" \");\n            }\n            out.println();\n        }\n        out.close();\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.FilterInputStream;\nimport java.io.BufferedInputStream;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Jenish\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        ScanReader in = new ScanReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CPashmakAndBuses solver = new CPashmakAndBuses();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CPashmakAndBuses {\n        public void solve(int testNumber, ScanReader in, PrintWriter out) {\n            long n = in.scanLong();\n            long k = in.scanLong();\n            long d = in.scanLong();\n\n            boolean flag = false;\n            long p = 1;\n            for (int i = 1; i <= d; i++) {\n                p *= k;\n                if (p >= n) {\n                    flag = true;\n                    break;\n                }\n            }\n            if (!flag) {\n                out.println(-1);\n                return;\n            }\n\n            long[][] ans = new long[(int) d][(int) n];\n            for (int i = 0; i < n; i++) {\n                int q = i;\n                int j = 0;\n                while (q > 0 && j < d) {\n                    ans[j++][i] = (q % k);\n                    q /= k;\n                }\n            }\n            for (int i = 0; i < d; i++) {\n                for (int j = 0; j < n; j++)\n                    out.print((ans[i][j] + 1) + \" \");\n                out.println();\n            }\n\n        }\n\n    }\n\n    static class ScanReader {\n        private byte[] buf = new byte[4 * 1024];\n        private int INDEX;\n        private BufferedInputStream in;\n        private int TOTAL;\n\n        public ScanReader(InputStream inputStream) {\n            in = new BufferedInputStream(inputStream);\n        }\n\n        private int scan() {\n            if (INDEX >= TOTAL) {\n                INDEX = 0;\n                try {\n                    TOTAL = in.read(buf);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                if (TOTAL <= 0) return -1;\n            }\n            return buf[INDEX++];\n        }\n\n        private boolean isWhiteSpace(int n) {\n            if (n == ' ' || n == '\\n' || n == '\\r' || n == '\\t' || n == -1) return true;\n            else return false;\n        }\n\n        public long scanLong() {\n            long I = 0;\n            int n = scan();\n            while (isWhiteSpace(n)) n = scan();\n            int neg = 1;\n            if (n == '-') {\n                neg = -1;\n                n = scan();\n            }\n            while (!isWhiteSpace(n)) {\n                if (n >= '0' && n <= '9') {\n                    I *= 10;\n                    I += n - '0';\n                    n = scan();\n                }\n            }\n            return neg * I;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ndouble pi = 3.141592653589793238;\nconst int M = 1e9 + 7;\nconst int Nmax = 5005;\nconst int MM = 1e7 + 1;\nconst int N = 300010;\nint a[1005][1005], v[1005];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int T = 1;\n  while (T--) {\n    int i, j, n, k, d, ok;\n    cin >> n >> k >> d;\n    ok = 1;\n    for (i = 1; i <= d; ++i) v[i] = 1;\n    for (i = 1; i <= n && ok; ++i) {\n      for (j = 1; j <= d; ++j) a[i][j] = v[j];\n      for (j = d; j && v[j] == k; --j)\n        ;\n      if (!j && i != n) ok = 0;\n      ++v[j];\n      for (++j; j <= d; ++j) v[j] = 1;\n    }\n    if (!ok)\n      cout << \"-1\\n\";\n    else {\n      for (int i = 1; i <= d; i++) {\n        for (int j = 1; j <= n; j++) {\n          cout << a[j][i] << \" \";\n        }\n        cout << \"\\n\";\n      }\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  int n, k, d;\n  cin >> n >> k >> d;\n  vector<vector<int> > answer(n, vector<int>(d));\n  long long base = 1;\n  for (int i = 0; i < d; ++i) {\n    for (int j = 0; j < n; ++j) {\n      answer[j][i] = (j / base) % k + 1;\n    }\n    base = min<long long>(base * k, n);\n  }\n  sort(answer.begin(), answer.end());\n  bool accept = true;\n  for (int i = 0; i + 1 < n; ++i) {\n    if (answer[i] == answer[i + 1]) {\n      accept = false;\n    }\n  }\n  if (!accept) {\n    cout << -1 << endl;\n    return 0;\n  }\n  for (int i = 0; i < d; ++i) {\n    for (int j = 0; j < n; ++j) {\n      if (j != 0) {\n        cout << \" \";\n      }\n      cout << answer[j][i];\n    }\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, d;\nint check(int n) {\n  int sum = 0;\n  while (n != 1) {\n    n = (n + k - 1) / k;\n    sum++;\n  }\n  return sum;\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &k, &d);\n  if (k == 1) {\n    if (n == 1)\n      for (int i = 1; i <= d; i++) puts(\"1\");\n    else\n      puts(\"-1\");\n    return 0;\n  }\n  int mx = check(n);\n  if (mx > d)\n    puts(\"-1\");\n  else {\n    int step = 1;\n    for (int j = 1; j <= mx; j++) {\n      step *= k;\n      int big = (j - 1) % k + 1;\n      int p = big;\n      printf(\"%d\", p);\n      for (int i = 2; i <= n; i++) {\n        if (i % step == 1) {\n          big = big % k + 1;\n          p = big;\n        } else\n          p = p % k + 1;\n        printf(\" %d\", p);\n      }\n      printf(\"\\n\");\n    }\n    for (int i = mx + 1; i <= d; i++) {\n      puts(\"1\");\n      for (int j = 2; j <= n; j++) printf(\" %d\", 1);\n      printf(\"\\n\");\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int n = s.nextInt();\n        int k = s.nextInt();\n        int d = s.nextInt();\n        PrintWriter out = new PrintWriter(System.out);\n        long pow = 1;\n        boolean flag = false;\n        for(int i=0;i<d;i++){\n            pow = pow*k;\n\n            if(pow>=n){\n                flag = true;\n                break;\n            }\n        }\n\n        if(!flag){\n            System.out.println(-1);\n            return;\n        }\n        int res[][] = new int[d][n];\n        for(int i=0;i<d;i++){\n            res[i][0] = 1;\n        }\n\n        for(int i=1;i<n;i++){\n            for(int j=0;j<d;j++){\n                res[j][i] = res[j][i-1];\n            }\n            res[d-1][i]++;\n            int index = d-1;\n            while(res[index][i]>k){\n                res[index][i] = 1;\n                index--;\n                res[index][i]++;\n            }\n\n        }\n\n        for(int i=0;i<d;i++){\n            for(int j=0;j<n;j++){\n                out.print(res[i][j]+\" \");\n            }\n            out.println();\n        }\n\n        out.flush();\n        out.close();\n    }\n}"
        },
        {
            "language": 3,
            "solution": "n, k, d = map(int, input().split())\nbits = n\nfor i in range(d):\n    bits = bits//k + (bits % k != 0)\nif bits > 1:\n    print(\"-1\")\n    exit()\nfor _ in range(d):\n    i = 0\n    res = 1\n    while i < n:\n        for j in range(bits):\n            print(res, end=' ')\n            i += 1\n            if i == n: \n                break\n        res += 1\n        if res > k:\n            res = 1\n    bits *= k\n    print()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k, d;\n  cin >> n >> k >> d;\n  long long res = 1;\n  bool ok = false;\n  for (int i = 0; i < d; i++) {\n    res *= k;\n    if (res >= n) {\n      ok = true;\n      break;\n    }\n  }\n  if (!ok) {\n    cout << -1 << '\\n';\n    return 0;\n  }\n  vector<vector<int>> ans(d, vector<int>(n));\n  for (int i = 0; i < n; i++) {\n    int top = 0;\n    int cur = i;\n    while (cur > 0) {\n      ans[top++][i] = cur % k;\n      cur /= k;\n    }\n  }\n  for (int i = 0; i < d; i++) {\n    for (int j = 0; j < n; j++) {\n      cout << ans[i][j] + 1 << ' ';\n    }\n    cout << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.util.Random;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.math.BigInteger;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTask solver = new Task();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class Task {\n\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\t\t\tint n = in.nextInt();\n\t\t\tint k = in.nextInt();\n\t\t\tint d = in.nextInt();\n\t\t\tint[] bus = new int[d];\n\t\t\tArrays.fill(bus, 1);\n\n\t\t\tint[][] ans = new int[n][d];\n\n\t\t\tBigInteger bound = new BigInteger(Integer.toString(k));\n\t\t\tbound = bound.pow(d);\n\t\t\tif ((new BigInteger(Integer.toString(n))).compareTo(bound) > 0) {\n\t\t\t\tout.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t//System.out.println(Arrays.toString(bus));\n\t\t\t\tans[i] = bus.clone();\n\t\t\t\ttry{int index = d - 1;\n\t\t\t\twhile (bus[index] == k) {\n\t\t\t\t\tbus[index] = 1;\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\tbus[index]++;}\n\t\t\t\tcatch(Exception e){}\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < d; i++) {\n\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\tout.print(ans[j][i] + \" \");\n\t\t\t\t}\n\t\t\t\tout.println();\n\t\t\t}\n\t\t\treturn;\n\n\n\t\t}\n\n\t}\n\n\tstatic class InputReader {\n\t\tpublic BufferedReader reader;\n\t\tpublic StringTokenizer st;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream), 32768);\n\t\t\tst = null;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid dbg_out() { cerr << \"\\b\\b]\\n\"; }\ntemplate <typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n  cerr << H << \", \";\n  dbg_out(T...);\n}\nconst int N = 1002;\nvector<vector<int>> ans(N, vector<int>(N, -1));\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n, k, d;\n  cin >> n >> k >> d;\n  if (k >= n) {\n    for (int i = 1; i <= d; ++i) {\n      for (int j = 1; j <= n; ++j) {\n        cout << j << ' ';\n      }\n      cout << '\\n';\n    }\n    return 0;\n  }\n  bool ok = true;\n  function<void(int, int, int, int)> go = [&](int l, int r, int bus, int d) {\n    if (d < 0) return;\n    if (d == 1) {\n      if (r - l + 1 > 1) {\n        ok = false;\n        return;\n      }\n    }\n    for (int i = l; i <= r; ++i) {\n      ans[d][i] = bus;\n    }\n    int rem = (r - l + 1) % k;\n    int segment = (r - l + 1) / k;\n    if (segment) {\n      int curr = l;\n      for (int i = 1; i <= k; ++i) {\n        int y = curr + segment + (i <= rem) - 1;\n        go(curr, y, i, d - 1);\n        curr = y + 1;\n      }\n    } else {\n      for (int i = 0; i < rem; ++i) {\n        go(l + i, l + i, i + 1, d - 1);\n      }\n    }\n  };\n  int l = 1, r = n;\n  int rem = (r - l + 1) % k;\n  int segment = (r - l + 1) / k;\n  int curr = 1;\n  for (int i = 1; i <= k; ++i) {\n    int y = curr + segment + (i <= rem) - 1;\n    go(curr, y, i, d);\n    curr = y + 1;\n  }\n  if (!ok) {\n    cout << -1;\n    return 0;\n  }\n  for (int i = d; i >= 1; --i) {\n    for (int j = 1; j <= n; ++j) {\n      cout << ans[i][j] << ' ';\n    }\n    cout << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint nxt() {\n  int res;\n  scanf(\"%d\", &res);\n  return res;\n}\ninline void solve() {\n  int n = nxt();\n  int k = nxt();\n  int d = nxt();\n  vector<vector<int> > ans;\n  ans.push_back(vector<int>(d, 0));\n  while (int(ans.size()) < n) {\n    vector<int> q = ans.back();\n    int add = 1;\n    for (int i = 0; i < d && add; ++i) {\n      q[i] += add;\n      add = 0;\n      if (q[i] >= k) {\n        q[i] -= k;\n        add = 1;\n      }\n    }\n    if (add) {\n      break;\n    }\n    ans.push_back(q);\n  }\n  if (int(ans.size()) != n) {\n    cout << \"-1\\n\";\n    return;\n  }\n  for (int i = 0; i < d; ++i) {\n    for (int j = 0; j < n; ++j) {\n      cout << ans[j][i] + 1 << \" \";\n    }\n    cout << \"\\n\";\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.lang.*;\n\npublic class Rextester{\n    public static void main(String[] args)throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        br.close();\n        int n = new Integer(st.nextToken());\n        int k = new Integer(st.nextToken());\n        int d = new Integer(st.nextToken());\n        if(n>(int)Math.pow(k,d)){\n            System.out.println(\"-1\");\n            return;\n        }\n        else{\n            StringBuffer sb = new StringBuffer();\n            int t=0,x=1,count=0;\n            for(int i=0;i<d;i++){\n                t=(int)Math.pow(k,i);\n                x=1;\n                count=0;\n                for(int j=0;j<n;j++){\n                    count++;\n                    sb.append(x).append(\" \");\n                    if(count==t){\n                        x++;\n                        if(x>k){\n                            x=1;\n                        }\n                        count=0;\n                    }\n                }\n                sb.append(\"\\n\");\n            }\n            System.out.println(sb);\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);\n  int t = 1;\n  while (t--) {\n    long long n, k, d;\n    cin >> n >> k >> d;\n    long long cn = 1;\n    int p = 0;\n    while (cn < n && p < d) {\n      cn *= k;\n      p++;\n    }\n    int arr[n][d];\n    if (cn < n) {\n      cout << \"-1\\n\";\n      return 0;\n    } else {\n      for (int i = 0; i < n; i++) {\n        int crr = i;\n        for (int j = d - 1; j >= 0; j--) {\n          arr[i][j] = crr % k + 1;\n          crr /= k;\n        }\n      }\n      for (int i = 0; i < d; i++) {\n        for (int j = 0; j < n; j++) {\n          cout << arr[j][i] << \" \";\n        }\n        cout << \"\\n\";\n      }\n    }\n    return 0;\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.io.*;\nimport java.util.*;\n\n\n\npublic class Cf459C {\n   \n    static int ans[][];\n    \n    public static void main(String args[]) throws IOException\n    {\n        InputReader in = new InputReader(System.in);\n\tPrintWriter w = new PrintWriter(System.out);\n        int n = in.nextInt();\n        int k = in.nextInt();\n        int d = in.nextInt();\n        ans = new int[d][n];\n        boolean friends = false;\n        if(k < n) friends = check(n, k, d);\n        if(friends) w.println(-1);\n        else{\n            for(int i = 0; i < n; i ++){\n                solve(i, k, d);\n            }\n        \n        for(int i = 0; i < d; i++){\n            for(int j = 0; j < n; j++){\n                w.print(ans[i][j] + \" \");\n            }\n            w.println();\n        }\n        }w.close();\n    }\n    \n    public static void solve(int num , int k, int d){\n        int col = num;\n        for(int i = 0; i < d; i++){\n           int r = num%k;\n           ans[i][col] = (r+1);\n           num /= k;\n       }\n    }\n    \n    public static boolean check(int n, int k, int d){\n        \n        for(int i = 1; i <= d; i++){\n            if(Math.pow(k, i) >= n) return false;\n        }\n        \n        return true;\n    }\n\n      static class InputReader {\n\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[8192];\n\t\tprivate int curChar, snumChars;\n\t\tprivate SpaceCharFilter filter;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic int snext() {\n\t\t\tif (snumChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= snumChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = snext();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = snext();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint a[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic String readString() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = snext();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tpublic interface SpaceCharFilter {\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n}\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint abs(int a) {\n  if (a < 0) a = -a;\n  return a;\n}\nlong long n, k, d;\nvector<int> b[1111];\nvoid pro(int num) {\n  b[num].clear();\n  int x = num;\n  for (int i = 1; i <= d; i++) b[num].push_back(x % k + 1), x /= k;\n}\nint main() {\n  cin >> n >> k >> d;\n  long long cnt = 1;\n  for (int i = 1; i <= d; i++) {\n    cnt *= k;\n    if (cnt > n) break;\n  }\n  if (cnt >= n) {\n    for (int i = 1; i <= (n); i++) pro(i);\n    for (int i = 0; i < d; i++) {\n      for (int j = 1; j <= n; j++) {\n        if (j != 1) cout << \" \";\n        printf(\"%d\", b[j][i]);\n      }\n      cout << endl;\n    }\n  } else\n    puts(\"-1\");\n}\n"
        }
    ]
}