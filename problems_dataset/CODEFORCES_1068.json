{
    "name": "1068_D. Array Without Local Maximums ",
    "source": "CODEFORCES",
    "description": "Ivan unexpectedly saw a present from one of his previous birthdays. It is array of n numbers from 1 to 200. Array is old and some numbers are hard to read. Ivan remembers that for all elements at least one of its neighbours ls not less than it, more formally:\n\na_{1} \u2264 a_{2},\n\na_{n} \u2264 a_{n-1} and\n\na_{i} \u2264 max(a_{i-1},    a_{i+1}) for all i from 2 to n-1.\n\nIvan does not remember the array and asks to find the number of ways to restore it. Restored elements also should be integers from 1 to 200. Since the number of ways can be big, print it modulo 998244353.\n\nInput\n\nFirst line of input contains one integer n (2 \u2264 n \u2264 10^{5}) \u2014 size of the array.\n\nSecond line of input contains n integers a_{i} \u2014 elements of array. Either a_{i} = -1 or 1 \u2264 a_{i} \u2264 200. a_{i} = -1 means that i-th element can't be read.\n\nOutput\n\nPrint number of ways to restore the array modulo 998244353.\n\nExamples\n\nInput\n\n3\n1 -1 2\n\n\nOutput\n\n1\n\n\nInput\n\n2\n-1 -1\n\n\nOutput\n\n200\n\nNote\n\nIn the first example, only possible value of a_{2} is 2.\n\nIn the second example, a_{1} = a_{2} so there are 200 different values because all restored elements should be integers between 1 and 200. ",
    "difficulty": "D",
    "tags": [
        "dp"
    ],
    "rating": 1900,
    "public_test": [
        {
            "input": "3\n1 -1 2\n",
            "output": "1\n"
        },
        {
            "input": "2\n-1 -1\n",
            "output": "200\n"
        }
    ],
    "generated_test": [
        {
            "input": "2\n23 38\n",
            "output": "0\n"
        },
        {
            "input": "2\n-1 18\n",
            "output": "1\n"
        },
        {
            "input": "37\n52 52 87 149 149 130 47 47 26 110 185 -1 73 73 65 -1 -1 130 -1 -1 -1 94 97 190 -1 -1 49 49 54 -1 92 92 5 25 48 79 79\n",
            "output": "903952722\n"
        },
        {
            "input": "5\n1 -1 -1 4 3\n",
            "output": "200\n"
        },
        {
            "input": "5\n2 -1 -1 4 3\n",
            "output": "199\n"
        },
        {
            "input": "5\n2 -1 -1 4 4\n",
            "output": "203\n"
        },
        {
            "input": "3\n-1 160 -1\n",
            "output": "319\n"
        },
        {
            "input": "37\n52 52 66 149 149 130 47 47 26 110 185 -1 73 73 65 -1 -1 130 -1 -1 -1 94 97 190 -1 -1 49 49 2 -1 92 92 5 25 48 79 79\n",
            "output": "673428777\n"
        },
        {
            "input": "5\n1 -1 -1 5 5\n",
            "output": "210\n"
        },
        {
            "input": "2\n23 49\n",
            "output": "0\n"
        },
        {
            "input": "8\n12 35 58 58 39 36 41 20\n",
            "output": "0\n"
        },
        {
            "input": "5\n1 -1 -1 5 4\n",
            "output": "200\n"
        },
        {
            "input": "2\n37 38\n",
            "output": "0\n"
        },
        {
            "input": "2\n-1 22\n",
            "output": "1\n"
        },
        {
            "input": "37\n52 52 87 149 149 130 47 47 26 010 185 -1 73 73 65 -1 -1 130 -1 -1 -1 94 97 190 -1 -1 49 49 54 -1 92 92 5 25 48 79 79\n",
            "output": "903952722\n"
        },
        {
            "input": "2\n23 16\n",
            "output": "0\n"
        },
        {
            "input": "8\n12 35 58 58 39 43 41 20\n",
            "output": "0\n"
        },
        {
            "input": "2\n37 16\n",
            "output": "0\n"
        },
        {
            "input": "37\n52 52 87 89 149 130 47 47 26 010 185 -1 73 73 65 -1 -1 130 -1 -1 -1 94 97 190 -1 -1 49 49 54 -1 92 92 5 25 48 79 79\n",
            "output": "0\n"
        },
        {
            "input": "2\n45 16\n",
            "output": "0\n"
        },
        {
            "input": "8\n12 35 58 58 39 7 41 20\n",
            "output": "0\n"
        },
        {
            "input": "2\n37 17\n",
            "output": "0\n"
        },
        {
            "input": "37\n52 52 87 89 149 130 47 47 26 010 185 -1 73 73 65 -1 -1 130 -1 -1 -1 94 97 190 -1 -1 49 49 54 -1 92 92 5 25 48 103 79\n",
            "output": "0\n"
        },
        {
            "input": "2\n45 30\n",
            "output": "0\n"
        },
        {
            "input": "8\n12 35 58 58 21 7 41 20\n",
            "output": "0\n"
        },
        {
            "input": "2\n37 30\n",
            "output": "0\n"
        },
        {
            "input": "37\n52 52 87 89 149 130 47 47 26 010 185 -1 73 73 65 -1 -1 130 -1 -1 -1 94 54 190 -1 -1 49 49 54 -1 92 92 5 25 48 103 79\n",
            "output": "0\n"
        },
        {
            "input": "2\n45 21\n",
            "output": "0\n"
        },
        {
            "input": "8\n12 35 58 58 21 7 73 20\n",
            "output": "0\n"
        },
        {
            "input": "2\n24 30\n",
            "output": "0\n"
        },
        {
            "input": "37\n52 52 87 89 149 130 47 47 26 010 185 -1 73 73 65 -1 -1 130 -1 -1 -1 94 54 190 -1 -1 49 49 48 -1 92 92 5 25 48 103 79\n",
            "output": "0\n"
        },
        {
            "input": "2\n2 21\n",
            "output": "0\n"
        },
        {
            "input": "8\n6 35 58 58 21 7 73 20\n",
            "output": "0\n"
        },
        {
            "input": "2\n28 30\n",
            "output": "0\n"
        },
        {
            "input": "2\n1 21\n",
            "output": "0\n"
        },
        {
            "input": "8\n6 35 90 58 21 7 73 20\n",
            "output": "0\n"
        },
        {
            "input": "2\n35 30\n",
            "output": "0\n"
        },
        {
            "input": "2\n2 9\n",
            "output": "0\n"
        },
        {
            "input": "8\n6 35 90 78 21 7 73 20\n",
            "output": "0\n"
        },
        {
            "input": "2\n3 30\n",
            "output": "0\n"
        },
        {
            "input": "2\n1 9\n",
            "output": "0\n"
        },
        {
            "input": "8\n6 35 90 78 17 7 73 20\n",
            "output": "0\n"
        },
        {
            "input": "2\n1 30\n",
            "output": "0\n"
        },
        {
            "input": "2\n1 2\n",
            "output": "0\n"
        },
        {
            "input": "8\n6 35 90 78 17 3 73 20\n",
            "output": "0\n"
        },
        {
            "input": "2\n1 58\n",
            "output": "0\n"
        },
        {
            "input": "2\n1 3\n",
            "output": "0\n"
        },
        {
            "input": "8\n10 35 90 78 17 3 73 20\n",
            "output": "0\n"
        },
        {
            "input": "2\n1 107\n",
            "output": "0\n"
        },
        {
            "input": "8\n10 35 90 78 21 3 73 20\n",
            "output": "0\n"
        },
        {
            "input": "2\n1 161\n",
            "output": "0\n"
        },
        {
            "input": "8\n10 35 90 78 24 3 73 20\n",
            "output": "0\n"
        },
        {
            "input": "2\n2 161\n",
            "output": "0\n"
        },
        {
            "input": "8\n13 35 90 78 24 3 73 20\n",
            "output": "0\n"
        },
        {
            "input": "8\n13 35 90 78 24 3 73 31\n",
            "output": "0\n"
        },
        {
            "input": "8\n13 35 90 78 24 3 100 31\n",
            "output": "0\n"
        },
        {
            "input": "8\n13 35 90 78 24 3 101 31\n",
            "output": "0\n"
        },
        {
            "input": "8\n13 35 90 78 24 2 101 31\n",
            "output": "0\n"
        },
        {
            "input": "8\n13 1 90 78 24 2 101 31\n",
            "output": "0\n"
        },
        {
            "input": "8\n13 1 90 78 24 3 101 31\n",
            "output": "0\n"
        },
        {
            "input": "2\n69 38\n",
            "output": "0\n"
        },
        {
            "input": "2\n-1 33\n",
            "output": "1\n"
        },
        {
            "input": "2\n9 -1\n",
            "output": "1\n"
        },
        {
            "input": "5\n1 3 1 1 1\n",
            "output": "0\n"
        },
        {
            "input": "2\n29 12\n",
            "output": "0\n"
        },
        {
            "input": "8\n12 35 58 62 39 41 41 20\n",
            "output": "0\n"
        },
        {
            "input": "5\n1 -1 -1 7 2\n",
            "output": "200\n"
        },
        {
            "input": "5\n1 -1 -1 6 4\n",
            "output": "200\n"
        },
        {
            "input": "3\n-1 -1 2\n",
            "output": "200\n"
        },
        {
            "input": "2\n38 20\n",
            "output": "0\n"
        },
        {
            "input": "2\n-1 16\n",
            "output": "1\n"
        },
        {
            "input": "37\n52 52 87 40 149 130 47 47 26 110 185 -1 73 73 65 -1 -1 130 -1 -1 -1 94 97 190 -1 -1 49 49 54 -1 92 92 5 25 48 79 79\n",
            "output": "0\n"
        },
        {
            "input": "2\n5 49\n",
            "output": "0\n"
        },
        {
            "input": "8\n12 35 58 58 39 36 62 20\n",
            "output": "0\n"
        },
        {
            "input": "2\n7 38\n",
            "output": "0\n"
        },
        {
            "input": "37\n52 52 87 149 149 130 47 47 26 010 185 -1 73 131 65 -1 -1 130 -1 -1 -1 94 97 190 -1 -1 49 49 54 -1 92 92 5 25 48 79 79\n",
            "output": "0\n"
        },
        {
            "input": "2\n32 16\n",
            "output": "0\n"
        },
        {
            "input": "8\n12 35 58 58 39 43 41 15\n",
            "output": "0\n"
        },
        {
            "input": "5\n2 -1 -1 5 3\n",
            "output": "199\n"
        },
        {
            "input": "2\n27 16\n",
            "output": "0\n"
        },
        {
            "input": "2\n61 16\n",
            "output": "0\n"
        },
        {
            "input": "8\n12 35 58 58 68 7 41 20\n",
            "output": "0\n"
        },
        {
            "input": "2\n37 11\n",
            "output": "0\n"
        },
        {
            "input": "37\n52 52 87 89 149 130 47 47 26 010 185 -1 73 73 65 -1 -1 130 -1 -1 -1 94 97 190 -1 -1 49 84 54 -1 92 92 5 25 48 103 79\n",
            "output": "0\n"
        },
        {
            "input": "2\n26 30\n",
            "output": "0\n"
        },
        {
            "input": "8\n12 35 58 58 40 7 41 20\n",
            "output": "0\n"
        },
        {
            "input": "2\n37 51\n",
            "output": "0\n"
        },
        {
            "input": "37\n52 52 87 89 149 130 43 47 26 010 185 -1 73 73 65 -1 -1 130 -1 -1 -1 94 54 190 -1 -1 49 49 54 -1 92 92 5 25 48 103 79\n",
            "output": "0\n"
        },
        {
            "input": "2\n45 40\n",
            "output": "0\n"
        },
        {
            "input": "8\n12 35 58 58 21 7 73 28\n",
            "output": "0\n"
        },
        {
            "input": "2\n26 19\n",
            "output": "0\n"
        },
        {
            "input": "37\n52 52 87 89 149 130 47 47 26 010 185 -1 73 73 65 -1 -1 130 -1 -1 -1 94 54 190 -1 -1 49 49 79 -1 92 92 5 25 48 103 79\n",
            "output": "0\n"
        },
        {
            "input": "2\n2 26\n",
            "output": "0\n"
        },
        {
            "input": "8\n6 35 58 58 21 7 140 20\n",
            "output": "0\n"
        },
        {
            "input": "2\n5 30\n",
            "output": "0\n"
        },
        {
            "input": "2\n1 19\n",
            "output": "0\n"
        },
        {
            "input": "8\n6 35 90 58 21 7 146 20\n",
            "output": "0\n"
        },
        {
            "input": "2\n34 30\n",
            "output": "0\n"
        },
        {
            "input": "2\n2 17\n",
            "output": "0\n"
        },
        {
            "input": "8\n6 35 90 78 21 7 73 11\n",
            "output": "0\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 2e5 + 5, inf = 1e18, mod = 998244353;\nlong long n, dp[2][202][2], ps[2][202][2], a[N], PS[2][202][2];\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  dp[0][0][1] = 1;\n  for (long long j = 0; j <= 200; j++) ps[0][j][1] = 1;\n  cin >> n;\n  for (long long i = 1; i <= n; i++) {\n    cin >> a[i];\n    if (a[i] != -1) {\n      dp[i % 2][a[i]][0] =\n          ps[(i - 1) % 2][a[i] - 1][0] + ps[(i - 1) % 2][a[i] - 1][1];\n      dp[i % 2][a[i]][0] %= mod;\n      dp[i % 2][a[i]][1] = dp[(i - 1) % 2][a[i]][0] + PS[(i - 1) % 2][a[i]][1];\n      dp[i % 2][a[i]][1] %= mod;\n    } else {\n      for (long long j = 1; j <= 200; j++) {\n        dp[i % 2][j][0] = ps[(i - 1) % 2][j - 1][0] + ps[(i - 1) % 2][j - 1][1];\n        dp[i % 2][j][0] %= mod;\n        dp[i % 2][j][1] = dp[(i - 1) % 2][j][0] + PS[(i - 1) % 2][j][1];\n        dp[i % 2][j][1] %= mod;\n      }\n    }\n    ps[0][0][1] = 0;\n    for (long long j = 1; j <= 200; j++) {\n      ps[i % 2][j][0] = ps[i % 2][j - 1][0] + dp[i % 2][j][0];\n      ps[i % 2][j][0] %= mod;\n      ps[i % 2][j][1] = ps[i % 2][j - 1][1] + dp[i % 2][j][1];\n      ps[i % 2][j][1] %= mod;\n    }\n    for (long long j = 200; j >= 1; j--) {\n      PS[i % 2][j][1] = PS[i % 2][j + 1][1] + dp[i % 2][j][1];\n      PS[i % 2][j][1] %= mod;\n    }\n    for (long long j = 0; j <= 200; j++)\n      dp[(i - 1) % 2][j][0] = dp[(i - 1) % 2][j][1] = 0;\n  }\n  cout << ps[n % 2][200][1];\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10;\nconst int K = 200;\nconst int mod = 998244353;\nint power(int a, int b) {\n  int res = 1;\n  while (b) {\n    if (b & 1) {\n      res = 1LL * res * a % mod;\n    }\n    a = 1LL * a * a % mod;\n    b >>= 1;\n  }\n  return res;\n}\nint main() {\n  int n, a[N], b = 0, dp[2][K + 5][2] = {0}, sum[2][K + 5][2] = {0};\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  if (a[1] != -1) {\n    dp[b][a[1]][1] = 1;\n  } else {\n    for (int i = 1; i <= K; i++) {\n      dp[b][i][1] = 1;\n    }\n  }\n  for (int i = 1; i <= K; i++) {\n    sum[b][i][1] = (dp[b][i][1] + sum[b][i - 1][1]) % mod;\n    sum[b][i][0] = (dp[b][i][0] + sum[b][i - 1][0]) % mod;\n  }\n  b = 1;\n  for (int i = 2; i <= n; i++) {\n    for (int j = 1; j <= K; j++) {\n      dp[b][j][1] = dp[b][j][0] = 0;\n      if (a[i] == -1 || a[i] == j) {\n        if (i != 2) {\n          dp[b][j][1] += (sum[b ^ 1][K][1] + mod - sum[b ^ 1][j][1]) % mod;\n          dp[b][j][1] %= mod;\n        }\n        dp[b][j][1] += (dp[b ^ 1][j][0] + dp[b ^ 1][j][1]) % mod;\n        dp[b][j][1] %= mod;\n        dp[b][j][0] += (sum[b ^ 1][j - 1][0] + sum[b ^ 1][j - 1][1]) % mod;\n        dp[b][j][0] %= mod;\n      }\n    }\n    for (int j = 1; j <= K; j++) {\n      sum[b][j][1] = (dp[b][j][1] + sum[b][j - 1][1]) % mod;\n      sum[b][j][0] = (dp[b][j][0] + sum[b][j - 1][0]) % mod;\n    }\n    b ^= 1;\n  }\n  printf(\"%d\\n\", sum[b ^ 1][K][1]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 998244353;\nint dp[2][2][202], n;\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= M) a -= M;\n}\nint main() {\n  scanf(\"%d\", &n);\n  dp[0][0][0] = 1;\n  bool is = 1;\n  for (int i = 0, a; i < n; i++) {\n    bool at = i & 1;\n    int cs[2] = {};\n    scanf(\"%d\", &a);\n    for (int j = 0; j < 201; j++) dp[!at][1][j] = dp[!at][0][j] = 0;\n    if (a != -1) {\n      for (int j = 0; j < a; j++) add(cs[0], (dp[at][0][j] + dp[at][1][j]) % M);\n      for (int j = a; j < 201; j++) add(cs[1], dp[at][1][j]);\n      add(cs[1], dp[at][0][a]);\n      dp[!at][1][a] = cs[1];\n      dp[!at][0][a] = cs[0];\n      continue;\n    }\n    for (int j = 0; j <= 200; j++) {\n      dp[!at][0][j] = cs[0];\n      add(cs[0], (dp[at][1][j] + dp[at][0][j]) % M);\n    }\n    for (int j = 200; j >= 1; j--) {\n      add(cs[1], dp[at][1][j]);\n      dp[!at][1][j] = cs[1] + dp[at][0][j];\n      if (dp[!at][1][j] >= M) dp[!at][1][j] -= M;\n    }\n  }\n  int ans = 0;\n  for (int i = 1; i <= 200; i++) add(ans, dp[n & 1][1][i]);\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\nconst int maxn = 1e5 + 10;\nlong long dp[205][3], sum[205][3];\nint n, a[maxn];\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  if (a[1] != -1)\n    dp[a[1]][0] = 1;\n  else\n    for (int i = 1; i <= 200; i++) dp[i][0] = 1;\n  for (int i = 2; i <= n; i++) {\n    for (int j = 1; j <= 200; j++) {\n      sum[j][0] = (sum[j - 1][0] + dp[j][0]) % mod;\n      sum[j][1] = (sum[j - 1][1] + dp[j][1]) % mod;\n      sum[j][2] = (sum[j - 1][2] + dp[j][2]) % mod;\n    }\n    if (a[i] == -1) {\n      for (int j = 1; j <= 200; j++) {\n        dp[j][2] = (dp[j][0] + dp[j][1] + dp[j][2]) % mod;\n        dp[j][0] = (sum[j - 1][0] + sum[j - 1][1] + sum[j - 1][2]) % mod;\n        dp[j][1] = ((sum[200][1] - sum[j][1] + mod) % mod +\n                    (sum[200][2] - sum[j][2] + mod) % mod) %\n                   mod;\n      }\n    } else {\n      int j = a[i];\n      dp[j][2] = (dp[j][0] + dp[j][1] + dp[j][2]) % mod;\n      dp[j][0] = (sum[j - 1][0] + sum[j - 1][1] + sum[j - 1][2]) % mod;\n      dp[j][1] = ((sum[200][1] - sum[j][1] + mod) % mod +\n                  (sum[200][2] - sum[j][2] + mod) % mod) %\n                 mod;\n      for (j = 1; j <= 200; j++)\n        if (j != a[i]) dp[j][0] = dp[j][1] = dp[j][2] = 0;\n    }\n  }\n  for (int j = 1; j <= 200; j++) {\n    sum[j][1] = (sum[j - 1][1] + dp[j][1]) % mod;\n    sum[j][2] = (sum[j - 1][2] + dp[j][2]) % mod;\n  }\n  cout << (sum[200][1] + sum[200][2]) % mod;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author llamaoo7\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DArrayWithoutLocalMaximums solver = new DArrayWithoutLocalMaximums();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DArrayWithoutLocalMaximums {\n        int mod = 998_244_353;\n\n        int add(int a, int b) {\n            return (a + b) % mod;\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int max = 200;\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = in.nextInt() - 1;\n            for (int i = 0; i < n; i++) if (a[i] == -2) a[i] = -1;\n            int[][] dp = new int[max][2];\n            if (a[0] == -1) for (int i = 0; i < max; i++) dp[i][0] = 1;\n            else dp[a[0]][0] = 1;\n            int[][] ps = new int[max][2];\n            int[] ss = new int[max];\n            for (int i = 1; i < n; i++) {\n                int[][] ndp = new int[max][2];\n                ps[0][0] = dp[0][0];\n                ps[0][1] = dp[0][1];\n                for (int j = 1; j < max; j++) {\n                    ps[j][0] = add(ps[j - 1][0], dp[j][0]);\n                    ps[j][1] = add(ps[j - 1][1], dp[j][1]);\n                }\n                ss[max - 1] = dp[max - 1][1];\n                for (int j = max - 2; j >= 0; j--)\n                    ss[j] = add(ss[j + 1], dp[j][1]);\n                int st = a[i] == -1 ? 0 : a[i];\n                int en = a[i] == -1 ? max : a[i] + 1;\n                for (int j = st; j < en; j++) {\n                    ndp[j][0] = j > 0 ? add(ps[j - 1][0], ps[j - 1][1]) : 0;\n                    ndp[j][1] = add(ss[j], dp[j][0]);\n                }\n                dp = ndp;\n            }\n            int ret = 0;\n            for (int i = 0; i < max; i++) ret = add(ret, dp[i][1]);\n            out.println(ret);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n \npublic class Main {\n    static PrintWriter out = new PrintWriter(System.out);\n    static Reader in = new Reader();\n    public static void main(String[] args) throws IOException {\n        //Scanner sc = new Scanner();\n        Main solver = new Main();\n        solver.solve();\n        out.flush();\n        out.close();\n \n    }\n \n    static int INF = (int)1e9;\n    static int maxn = (int)1e5+5;\n    static int mod  = 998244353;\n    static int n,m,q,k,t;\n    \n    \n    void solve() throws IOException{\n        n = in.nextInt();\n        \n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) arr[i] = in.nextInt();\n        \n        \n        long[][] dp = new long[201][2];\n        \n        if (arr[0] == -1)\n            for (int i = 1; i <= 200; i++) \n                dp[i][0] = 1;\n        if (arr[0] != -1) {\n            dp[arr[0]][0] = 1;\n        }\n        \n        long[][] sum = new long[201][2];\n        \n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j < 201; j++)\n                for (int z = 0; z < 2; z++)\n                    sum[j][z] = (sum[j-1][z] + dp[j][z])%mod;\n            \n            for (int j = 1; j < 201; j++) {\n                if (arr[i] == -1 || arr[i] == j) {\n                    dp[j][0] = (sum[j-1][0] + sum[j-1][1])%mod;\n                    dp[j][1] = (sum[200][1] - sum[j-1][1] + mod)%mod;\n                    dp[j][1] = (dp[j][1] + sum[j][0] - sum[j-1][0] + mod)%mod;\n                } else {\n                    dp[j][0] = 0;\n                    dp[j][1] = 0;\n                }\n            }\n        }\n        \n        long ans = 0;\n        for (int i = 1; i <= 200; i++)\n            ans = (ans + dp[i][1]) % mod;\n        out.println(ans);\n    }\n    \n    //<>\n    \n    static class Reader {\n \n    private InputStream mIs;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n \n    public Reader() {\n        this(System.in);\n    }\n \n    public Reader(InputStream is) {\n        mIs = is;\n    }\n \n    public int read() {\n        if (numChars == -1) {\n            throw new InputMismatchException();\n \n    }\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = mIs.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0) {\n                return -1;\n            }\n        }\n        return buf[curChar++];\n    }\n \n    public String nextLine() {\n        int c = read();\n        while (isSpaceChar(c)) {\n            c = read();\n        }\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isEndOfLine(c));\n        return res.toString();\n    }\n \n    public String next() {\n        int c = read();\n        while (isSpaceChar(c)) {\n            c = read();\n        }\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n        return res.toString();\n    }\n \n    double nextDouble()\n    {\n        return Double.parseDouble(next());\n    }\n \n    public long nextLong() {\n        int c = read();\n        while (isSpaceChar(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0;\n        do {\n            if (c < '0' || c > '9') {\n                throw new InputMismatchException();\n            }\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n \n    public int nextInt() {\n        int c = read();\n        while (isSpaceChar(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9') {\n                throw new InputMismatchException();\n            }\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n \n    public boolean isSpaceChar(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n \n    public boolean isEndOfLine(int c) {\n        return c == '\\n' || c == '\\r' || c == -1;\n    }\n \n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long sze = 3e5 + 50, INF = 1e18 + 500, mod = 998244353;\nconst long double eps = 5e-10, PI = 2 * acos(0.0);\ntemplate <class T>\nvoid show(const vector<T> &a) {\n  for (T x : a) cout << x << \" \";\n  cout << '\\n';\n}\nvector<long long> vertices[sze];\nvector<char> visit(sze, false);\nvector<long long> arr(sze, 0);\nlong long n, m, k, t;\nlong long d = 0;\nlong long cnt = 0;\nstring s;\nvector<long long> col(sze, 0);\nvector<long long> sum(sze, INF);\nlong long x, y;\nlong long dp[2][2][210];\ninline long long mode(long long val) {\n  if (val < 0) {\n    val %= mod;\n    if (val < 0) val += mod;\n    return val;\n  }\n  return val % mod;\n}\nvoid add(long long p, long long type, long long val, long long l, long long r) {\n  if (r < l) return;\n  val = mode(val);\n  dp[p][type][l] = mode(dp[p][type][l] + val);\n  dp[p][type][r + 1] = mode(dp[p][type][r + 1] - val);\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cin >> n;\n  for (long long i = 0; i < n; i++) {\n    cin >> arr[i];\n  }\n  long long c = 0, p = 1;\n  if (arr[0] == -1) {\n    for (long long i = 1; i < 201; i++) {\n      dp[c][0][i]++;\n    }\n  } else {\n    dp[c][0][arr[0]]++;\n  }\n  for (long long i = 1; i < n; i++) {\n    if (arr[i] == -1) {\n      for (long long j = 1; j < 201; j++) {\n        add(p, 1, dp[c][0][j] + dp[c][1][j], j, j);\n        add(p, 0, dp[c][0][j] + dp[c][1][j], j + 1, 200);\n        add(p, 1, dp[c][1][j], 1, j - 1);\n      }\n    } else {\n      for (long long j = 1; j < 201; j++) {\n        if (j == arr[i]) {\n          add(p, 1, dp[c][0][j], j, j);\n          add(p, 1, dp[c][1][j], j, j);\n          continue;\n        }\n        if (j < arr[i]) {\n          add(p, 0, dp[c][1][j] + dp[c][0][j], arr[i], arr[i]);\n        } else {\n          add(p, 1, dp[c][1][j], arr[i], arr[i]);\n        }\n      }\n    }\n    for (long long j = 1; j < 201; j++) {\n      dp[p][0][j] = mode(dp[p][0][j] + dp[p][0][j - 1]);\n      dp[p][1][j] = mode(dp[p][1][j] + dp[p][1][j - 1]);\n    }\n    for (long long j = 0; j < 201; j++) {\n      dp[c][0][j] = 0;\n      dp[c][1][j] = 0;\n    }\n    swap(c, p);\n  }\n  cnt = 0;\n  for (long long j = 1; j < 201; j++) {\n    cnt = mode(cnt + dp[c][1][j]);\n  }\n  cout << cnt;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long int;\nconst ll INF = 1e15 + 373;\ntemplate <typename T>\nusing vector2 = vector<vector<T>>;\ntemplate <typename T>\nvector2<T> init_vector2(size_t n0, size_t n1, T e = T()) {\n  return vector2<T>(n0, vector<T>(n1, e));\n}\ntemplate <typename T>\nusing vector3 = vector<vector<vector<T>>>;\ntemplate <typename T>\nvector3<T> init_vector3(size_t n0, size_t n1, size_t n2, T e = T()) {\n  return vector3<T>(n0, vector2<T>(n1, vector<T>(n2, e)));\n}\nll readInt() {\n  ll ret;\n  cin >> ret;\n  return ret;\n}\nvector<ll> readInt(ll n) {\n  vector<ll> ret(n);\n  for (ll i = 0; i < (ll)(n); ++i) {\n    cin >> ret[i];\n  }\n  return ret;\n}\nconst ll MOD = 998244353;\nll addM(ll a, ll b) { return (a + b) % MOD; }\nll subM(ll a, ll b) { return (a - b + 2 * MOD) % MOD; }\nvoid addRange(vector<uint32_t>& a, ll s, ll t, ll c) {\n  a[s] = addM(a[s], c);\n  a[t] = subM(a[t], c);\n}\nsigned main() {\n  ll n = readInt();\n  auto a = readInt(n);\n  ;\n  ;\n  auto dp = init_vector3<uint32_t>(n, 2, 202, 0);\n  if (a[0] == -1) {\n    fill(dp[0][1].begin(), dp[0][1].end(), 0);\n    fill(dp[0][0].begin(), dp[0][0].end(), 1);\n  } else {\n    fill(dp[0][1].begin(), dp[0][1].end(), 0);\n    fill(dp[0][0].begin(), dp[0][0].end(), 0);\n    dp[0][0][a[0]] = 1;\n  }\n  for (ll i = 0; i < n - 1; i++) {\n    {\n      for (ll j = 1; j <= 200; j++) {\n        const ll comb = dp[i][0][j];\n        if (a[i + 1] == -1) {\n          addRange(dp[i + 1][1], j, j + 1, comb);\n          addRange(dp[i + 1][0], j + 1, 201, comb);\n        } else if (a[i + 1] == j) {\n          addRange(dp[i + 1][1], a[i + 1], a[i + 1] + 1, comb);\n        } else if (a[i + 1] > j) {\n          addRange(dp[i + 1][0], a[i + 1], a[i + 1] + 1, comb);\n        }\n      }\n    }\n    {\n      for (ll j = 1; j <= 200; j++) {\n        const ll comb = dp[i][1][j];\n        if (a[i + 1] == -1) {\n          addRange(dp[i + 1][0], j + 1, 201, comb);\n          addRange(dp[i + 1][1], 1, j + 1, comb);\n        } else if (a[i + 1] == j) {\n          addRange(dp[i + 1][1], a[i + 1], a[i + 1] + 1, comb);\n        } else if (a[i + 1] > j) {\n          addRange(dp[i + 1][0], a[i + 1], a[i + 1] + 1, comb);\n        } else if (a[i + 1] < j) {\n          addRange(dp[i + 1][1], a[i + 1], a[i + 1] + 1, comb);\n        }\n      }\n    }\n    for (ll j = 0; j <= 200; j++) {\n      dp[i + 1][0][j + 1] = addM(dp[i + 1][0][j + 1], dp[i + 1][0][j]);\n      dp[i + 1][1][j + 1] = addM(dp[i + 1][1][j + 1], dp[i + 1][1][j]);\n    }\n  }\n  ll ans = 0;\n  for (ll i = 1; i <= 200; i++) {\n    ans = addM(ans, dp[n - 1][1][i]);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint64_t calc(int64_t l, int64_t r, int64_t ln) {\n  if (ln < 2) return 1;\n  int64_t mx = max(l, r);\n  int64_t mn = min(l, r);\n  int64_t ans = (int64_t)pow(201, (ln - 2));\n  cout << ans << endl;\n  ans += (int64_t)pow((201 - mx + 1), (ln - 1));\n  cout << ans << endl;\n  int64_t to = 201 - mn;\n  int64_t fr = to - mx + mn + 1;\n  cout << fr << ' ' << to << endl;\n  ans += (to * (to + 1)) / 2;\n  ans -= (fr * (fr + 1)) / 2;\n  cout << \"ANS: \" << l << ' ' << r << ' ' << ln << \" = \" << ans << endl;\n  return ans;\n}\nint main() {\n  int n;\n  cin >> n;\n  int a[n + 2];\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", &a[i + 1]);\n  }\n  a[0] = 1;\n  a[n + 1] = 1;\n  n += 2;\n  int64_t *dp[2][201], ps[2][201];\n  for (int i = 0; i < 2; ++i) {\n    for (int j = 0; j < 201; ++j) {\n      dp[i][j] = (int64_t *)calloc(n, sizeof(int64_t));\n      ps[i][j] = 0;\n    }\n  }\n  dp[0][1][0] = 1;\n  ps[0][0] = dp[0][0][0];\n  ps[1][0] = dp[1][0][0];\n  for (int j = 1; j < 201; ++j) {\n    ps[0][j] = ps[0][j - 1] + dp[0][j][0];\n    ps[1][j] = ps[1][j - 1] + dp[1][j][0];\n    ps[0][j] %= 998244353;\n    ps[1][j] %= 998244353;\n  }\n  for (int i = 1; i < n; ++i) {\n    if (a[i] == -1) {\n      for (int j = 1; j < 201; ++j) {\n        dp[0][j][i] = ps[1][j - 1] + ps[0][j - 1];\n        dp[0][j][i] %= 998244353;\n        dp[1][j][i] = dp[0][j][i - 1] +\n                      ((ps[1][201 - 1] - ps[1][j - 1] + 998244353) % 998244353);\n        dp[1][j][i] %= 998244353;\n      }\n    } else {\n      dp[1][a[i]][i] = dp[0][a[i]][i - 1];\n      for (int j = a[i]; j < 201; ++j) {\n        dp[1][a[i]][i] += dp[1][j][i - 1];\n        dp[1][a[i]][i] %= 998244353;\n      }\n      dp[0][a[i]][i] = 0;\n      for (int j = 1; j < a[i]; ++j) {\n        dp[0][a[i]][i] += dp[0][j][i - 1] + dp[1][j][i - 1];\n        dp[0][a[i]][i] %= 998244353;\n      }\n    }\n    ps[0][0] = dp[0][0][i];\n    ps[1][0] = dp[1][0][i];\n    for (int j = 1; j < 201; ++j) {\n      ps[0][j] = ps[0][j - 1] + dp[0][j][i];\n      ps[1][j] = ps[1][j - 1] + dp[1][j][i];\n      ps[0][j] %= 998244353;\n      ps[1][j] %= 998244353;\n    }\n  }\n  int64_t ans = 0;\n  for (int i = 1; i < 201; ++i) {\n    ans += dp[0][i][n - 1];\n    ans %= 998244353;\n    ans += dp[1][i][n - 1];\n    ans %= 998244353;\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  const int m = 200;\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) cin >> a[i];\n  pair<long long, long long>** d = new pair<long long, long long>*[m];\n  for (int i = 0; i < m; i++) {\n    d[i] = new pair<long long, long long>[n];\n    d[i][0] = make_pair(0, 0);\n  }\n  if (a[0] > 0)\n    d[a[0] - 1][0].second = 1;\n  else\n    for (int i = 0; i < m; i++) d[i][0].second = 1;\n  for (int j = 1; j < n; j++) {\n    d[0][j].second = 0;\n    for (int i = 1; i < m; i++)\n      d[i][j].second = (d[i - 1][j].second + d[i - 1][j - 1].first +\n                        d[i - 1][j - 1].second) %\n                       998244353;\n    d[m - 1][j].first = 0;\n    for (int i = m - 2; i >= 0; i--)\n      d[i][j].first = (d[i + 1][j].first + d[i + 1][j - 1].first) % 998244353;\n    for (int i = 0; i < m; i++)\n      d[i][j].first += (d[i][j - 1].first + d[i][j - 1].second) % 998244353;\n    if (a[j] >= 1)\n      for (int i = 0; i < m; i++)\n        if (i != a[j] - 1) d[i][j] = make_pair(0, 0);\n  }\n  long long s = 0;\n  for (int i = 0; i < m; i++) s = (s + d[i][n - 1].first) % 998244353;\n  cout << s << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n/**\n * @author Don Li\n */\npublic class ArrayWithoutLocalMaximums {\n    \n    int MOD = 998244353;\n    \n    void solve() {\n        int n = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = in.nextInt();\n        \n        int[][][] dp = new int[n + 1][2][205];\n        if (a[0] == -1) {\n            for (int x = 1; x <= 200; x++) dp[1][1][x] = 1;\n        } else {\n            dp[1][1][a[0]] = 1;\n        }\n        \n        int[][] sum = new int[2][205];\n        for (int i = 1; i < n; i++) {\n            if (a[i] == -1) {\n                for (int gt = 0; gt < 2; gt++) {\n                    for (int x = 1; x <= 200; x++) sum[gt][x] = dp[i][gt][x];\n                    for (int x = 1; x <= 200; x++) sum[gt][x] = add(sum[gt][x], sum[gt][x - 1]);\n                }\n                for (int y = 1; y <= 200; y++) {\n                    dp[i + 1][1][y] = add(dp[i + 1][1][y], sum[0][y - 1]);\n                    dp[i + 1][0][y] = add(dp[i + 1][0][y], sub(sum[0][200], sum[0][y - 1]));\n                    dp[i + 1][1][y] = add(dp[i + 1][1][y], sum[1][y - 1]);\n                    dp[i + 1][0][y] = add(dp[i + 1][0][y], dp[i][1][y]);\n                }\n            } else {\n                for (int gt = 0; gt < 2; gt++) {\n                    for (int x = 1; x <= 200; x++) {\n                        if (dp[i][gt][x] == 0) continue;\n                        if (gt == 0) {\n                            if (x < a[i]) dp[i + 1][1][a[i]] = add(dp[i + 1][1][a[i]], dp[i][gt][x]);\n                            else dp[i + 1][0][a[i]] = add(dp[i + 1][0][a[i]], dp[i][gt][x]);\n                        } else {\n                            if (x > a[i]) continue;\n                            if (x == a[i]) dp[i + 1][0][a[i]] = add(dp[i + 1][0][a[i]], dp[i][gt][x]);\n                            else dp[i + 1][1][a[i]] = add(dp[i + 1][1][a[i]], dp[i][gt][x]);\n                        }\n                    }\n                }\n            }\n        }\n        \n        if (a[n - 1] == -1) {\n            int ans = 0;\n            for (int x = 1; x <= 200; x++) ans = add(ans, dp[n][0][x]);\n            out.println(ans);\n        } else {\n            int ans = dp[n][0][a[n - 1]];\n            out.println(ans);\n        }\n    }\n    \n    int add(int a, int b) {\n        return (a + b) % MOD;\n    }\n    \n    int sub(int a, int b) {\n        return (a - b + MOD) % MOD;\n    }\n    \n    public static void main(String[] args) {\n        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        new ArrayWithoutLocalMaximums().solve();\n        out.close();\n    }\n    \n    static FastScanner in;\n    static PrintWriter out;\n    \n    static class FastScanner {\n        BufferedReader in;\n        StringTokenizer st;\n        \n        public FastScanner(BufferedReader in) {\n            this.in = in;\n        }\n        \n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        \n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n        \n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nint mod = 998244353;\nvector<vector<vector<int> > > dp(2,\n                                 vector<vector<int> >(205, vector<int>(2, 0)));\nvector<vector<vector<int> > > sum(2,\n                                  vector<vector<int> >(205, vector<int>(2, 0)));\nint a[N];\nint n;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n;\n  for (int i = 1; i <= n; ++i) {\n    cin >> a[i];\n  }\n  a[0] = a[n + 1] = 0;\n  for (int p = 200; p >= 0; --p) {\n    dp[(n + 1) & 1][p][0] = 0;\n    dp[(n + 1) & 1][p][1] = 1;\n    sum[(n + 1) & 1][p][1] =\n        (sum[(n + 1) & 1][p + 1][1] + dp[(n + 1) & 1][p][1]) % mod;\n  }\n  for (int i = n; i > 0; i--) {\n    int idx = i & 1;\n    for (int p = 200; p >= 0; p--) {\n      if (a[i] != -1) {\n        if (p > a[i]) {\n          dp[idx][p][0] = 0;\n        } else if (p < a[i]) {\n          dp[idx][p][0] = dp[idx ^ 1][a[i]][0];\n        } else\n          dp[idx][p][0] = dp[idx ^ 1][a[i]][1];\n      } else {\n        dp[idx][p][0] = sum[idx ^ 1][p + 1][0];\n        if (p > 0) dp[idx][p][0] = (dp[idx][p][0] + dp[idx ^ 1][p][1]) % mod;\n      }\n      sum[idx][p][0] = (sum[idx][p + 1][0] + dp[idx][p][0]) % mod;\n      if (a[i] != -1) {\n        if (p >= a[i]) {\n          dp[idx][p][1] = dp[idx ^ 1][a[i]][1];\n        } else\n          dp[idx][p][1] = dp[idx ^ 1][a[i]][0];\n      } else {\n        dp[idx][p][1] = (sum[idx ^ 1][p + 1][0] + sum[idx ^ 1][1][1]) % mod -\n                        sum[idx ^ 1][p + 1][1];\n        dp[idx][p][1] = (dp[idx][p][1] + mod) % mod;\n      }\n      sum[idx][p][1] = (sum[idx][p + 1][1] + dp[idx][p][1]) % mod;\n    }\n  }\n  cout << dp[1][1][0];\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class D{\n\n\tstatic class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                     InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n\tstatic long mod = 998244353L;\n\n\tpublic static void main(String[] args){\n\t\t\n        FastReader sc = new FastReader();\n\t\t\n        int n = sc.nextInt();\n\t\tint[] arr = new int[n];\n\t\t\n        for(int i=0;i<n;i++)\n\t\t\tarr[i] = sc.nextInt();\n\n\t\tlong dp[][][] = new long[2][202][3];\n\n\t\tif(arr[0]==-1){\n\t\t\tfor(int j=1;j<=200;j++)\n\t\t\t\tdp[0][j][0] = 1;\n\t\t}else{\n\t\t\tdp[0][arr[0]][0] = 1;\n\t\t}\n\n\t\tfor(int i=1;i<n;i++){\n            \n            int c = i%2;\n            int p = (i+1)%2;\n\n\t\t\tif(arr[i]==-1){\n\t\t\t\n\t\t\t\tfor(int j=1;j<=200;j++){\n\t\t\t\t\tdp[c][j+1][0] = ( dp[c][j+1][0] + dp[p][j][0] + dp[p][j][1] + dp[p][j][2] )%mod;\n\n\t\t\t\t\tdp[c][j][1] = ( dp[c][j][1] + dp[p][j][0] + dp[p][j][1] + dp[p][j][2] )%mod;\n\n\t\t\t\t\tdp[c][j-1][2] = ( dp[c][j-1][2] + dp[p][j][1] + dp[p][j][2] )%mod;\n\t\t\t\t}\n\n\t\t\t\tfor(int j=1;j<=200;j++){\n\t\t\t\t\tdp[c][j][0] = (dp[c][j][0] + dp[c][j-1][0])%mod;\n\t\t\t\t\tdp[c][201-j][2] = (dp[c][201-j][2] + dp[c][201-j+1][2])%mod;\n                }\n                \n                dp[c][0][2] = (dp[c][0][2] + dp[c][0][2])%mod;\n\t\t\t\t\n\t\t\t}else{\n\t\t\t\t\n\t\t\t\tfor(int j=1;j<=200;j++){\n\t\t\t\t\tif(arr[i]>j)\n\t\t\t\t\t\tdp[c][arr[i]][0] = ( dp[c][arr[i]][0] + dp[p][j][0] + dp[p][j][1] + dp[p][j][2] )%mod;\n\t\t\t\t\telse if(arr[i]==j)\t\n\t\t\t\t\t\tdp[c][arr[i]][1] = ( dp[c][arr[i]][1] + dp[p][j][0] + dp[p][j][1] + dp[p][j][2] )%mod;\n\t\t\t\t\telse\n\t\t\t\t\t\tdp[c][arr[i]][2] = ( dp[c][arr[i]][2] + dp[p][j][1] + dp[p][j][2] )%mod;\n\t\t\t\t}\n\t\t\t}\n\n            for(int j=0;j<=200;j++)\n                dp[p][j][0] = dp[p][j][1] = dp[p][j][2] = 0;\n\t\t}\n\n\t\tlong res  = 0;\n        int c = (n-1)%2;\n\n\t\tfor(int j=1;j<=200;j++)\n\t\t\tres = ( res + dp[c][j][1] + dp[c][j][2] )%mod;\n\n\t\tSystem.out.println(res);\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937 gen_rand;\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, pair<T, U> &a) {\n  os << \"(\";\n  os << a.first << \", \";\n  os << a.second;\n  os << \")\";\n  return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, vector<T> &a) {\n  os << \"{\";\n  bool was = false;\n  for (auto &x : a) {\n    if (was) {\n      os << \", \";\n    }\n    was = true;\n    os << x;\n  }\n  os << \"}\";\n  return os;\n}\ntemplate <typename T>\ninline void debug(const char *sdbg, T x) {\n  cerr << \"The value of \" << sdbg << \" is \" << x << \"\\n\";\n};\ntemplate <typename T, typename... U>\ninline void debug(const char *sdbg, T h, U... t) {\n  cerr << \"The value of \";\n  while (*sdbg != ',') {\n    cerr << *sdbg++;\n  }\n  cerr << \" is \" << h << \"\\n\";\n  debug(sdbg + 1, t...);\n  cerr << \"\\n\";\n}\ntemplate <typename T>\nT abs(T x) {\n  if (x < 0) {\n    return -x;\n  } else {\n    return x;\n  }\n}\ntemplate <typename T>\nT sqr(T x) {\n  return x * x;\n};\nconst long long INF_FOR_SHORT_TIME = (long long)(1e9);\ntemplate <typename T>\nT mul(T a, T b, T m) {\n  if (a <= INF_FOR_SHORT_TIME && b <= INF_FOR_SHORT_TIME) {\n    return (a * b) % m;\n  }\n  T q = (long long)((long double)a * (long double)b / (long double)m);\n  T r = a * b - q * m;\n  return (r + 5 * m) % m;\n}\ntemplate <typename T, typename U>\nT binpow(T a, U n, T MOD) {\n  T res = 1;\n  while (n) {\n    if (n & 1) {\n      res = mul(res, a, MOD);\n    }\n    a = mul(a, a, MOD);\n    n >>= 1;\n  }\n  return res;\n};\ntemplate <typename T>\nint sign(T x) {\n  if (x < 0) {\n    return -1;\n  } else if (x > 0) {\n    return 1;\n  } else {\n    return 0;\n  }\n};\ntemplate <typename T>\nT gcd(T a, T b) {\n  if (a > b) {\n    swap(a, b);\n  }\n  while (a) {\n    b %= a;\n    swap(a, b);\n  }\n  return b;\n};\ntemplate <typename T>\nbool uin(T &a, T b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n};\ntemplate <typename T>\nbool uax(T &a, T b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n};\nconst int mod = 998244353;\nconst int MAXN = 200;\nint main() {\n  gen_rand.seed(time(0));\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n  }\n  int dp[2][MAXN + 1][2] = {};\n  int cur = 0;\n  if (a[0] == -1) {\n    for (int x = 1; x <= MAXN; ++x) {\n      dp[0][x][0] = 1;\n    }\n  } else {\n    dp[0][a[0]][0] = 1;\n  }\n  for (int i = 1; i < n; ++i) {\n    vector<vector<int>> prv(MAXN + 1, vector<int>(2, 0));\n    for (int j = 1; j <= MAXN; ++j) {\n      prv[j][0] = (prv[j - 1][0] + dp[cur][j][0]) % mod;\n      prv[j][1] = (prv[j - 1][1] + dp[cur][j][1]) % mod;\n    }\n    if (a[i] != -1) {\n      dp[cur ^ 1][a[i]][0] = (prv[a[i] - 1][1] + prv[a[i] - 1][0]) % mod;\n      dp[cur ^ 1][a[i]][1] =\n          (((prv[MAXN][1] - prv[a[i] - 1][1]) + mod) % mod + dp[cur][a[i]][0]) %\n          mod;\n      cur ^= 1;\n      for (int i = 0; i <= MAXN; ++i) {\n        dp[cur ^ 1][i][0] = 0;\n        dp[cur ^ 1][i][1] = 0;\n      }\n      continue;\n    }\n    for (int x = 1; x <= MAXN; ++x) {\n      dp[cur ^ 1][x][0] = (prv[x - 1][1] + prv[x - 1][0]) % mod;\n      dp[cur ^ 1][x][1] =\n          (((prv[MAXN][1] - prv[x - 1][1]) + mod) % mod + dp[cur][x][0]) % mod;\n    }\n    cur ^= 1;\n    for (int i = 0; i <= MAXN; ++i) {\n      dp[cur ^ 1][i][0] = 0;\n      dp[cur ^ 1][i][1] = 0;\n    }\n  }\n  if (a[n - 1] != -1) {\n    cout << dp[cur][a[n - 1]][1];\n  } else {\n    int res = 0;\n    for (int x = 1; x <= MAXN; ++x) {\n      res = (res + dp[cur][x][1]) % mod;\n    }\n    cout << res;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class P1068D\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tFastScanner in = new FastScanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint mod = 998244353;\n\t\t// arr[0]: leq unsatisfied\n\t\t// arr[1]: leq satisfied\n\t\t// arr[x][i]: value == i\n\t\tint[][] arr = new int[2][201];\n\t\tint x = in.nextInt();\n\t\tif (x == -1) {\n\t\t\tArrays.fill(arr[0], 1);\n\t\t\tarr[0][0] = 0;\n\t\t}\n\t\telse\n\t\t\tarr[0][x] = 1;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tx = in.nextInt();\n\t\t\tint[][] pass = new int[2][201];\n\t\t\tif (x == -1) {\n\t\t\t\tlong cum = 0;\n\t\t\t\tfor (int j = 1; j <= 200; j++) {\n\t\t\t\t\tpass[0][j] += cum;\n\t\t\t\t\tpass[0][j] %= mod;\n\t\t\t\t\tcum += arr[0][j];\n\t\t\t\t\tcum %= mod;\n\t\t\t\t\tpass[1][j] += arr[0][j];\n\t\t\t\t\tpass[1][j] %= mod;\n\t\t\t\t}\n\t\t\t\tcum = 0;\n\t\t\t\tfor (int j = 200; j >= 1; j--) {\n\t\t\t\t\tcum += arr[1][j];\n\t\t\t\t\tcum %= mod;\n\t\t\t\t\tpass[1][j] += cum;\n\t\t\t\t\tpass[1][j] %= mod;\n\t\t\t\t}\n\t\t\t\tcum = 0;\n\t\t\t\tfor (int j = 1; j < 200; j++) {\n\t\t\t\t\tcum += arr[1][j];\n\t\t\t\t\tcum %= mod;\n\t\t\t\t\tpass[0][j + 1] += cum;\n\t\t\t\t\tpass[0][j + 1] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 1; j <= 200; j++) {\n\t\t\t\t\tif (j < x)\n\t\t\t\t\t\tpass[0][x] += arr[0][j];\n\t\t\t\t\telse if (j == x)\n\t\t\t\t\t\tpass[1][x] += arr[0][j];\n\t\t\t\t\tpass[0][x] %= mod;\n\t\t\t\t\tpass[1][x] %= mod;\n\t\t\t\t\tif (j >= x)\n\t\t\t\t\t\tpass[1][x] += arr[1][j];\n\t\t\t\t\telse\n\t\t\t\t\t\tpass[0][x] += arr[1][j];\n\t\t\t\t\tpass[0][x] %= mod;\n\t\t\t\t\tpass[1][x] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tarr = pass;\n\t\t}\n\t\tlong sum = 0;\n\t\tfor (int i = 1; i <= 200; i++) {\n\t\t\tsum += arr[1][i];\n\t\t\tsum %= mod;\n\t\t}\n\t\tSystem.out.println(sum);\n\t}\n\t\n\t/**\n\t * Source: Matt Fontaine\n\t */\n\tpublic static class FastScanner\n\t{\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream)\n\t\t{\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tint read()\n\t\t{\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars)\n\t\t\t{\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c)\n\t\t{\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c)\n\t\t{\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tpublic int nextInt()\n\t\t{\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong()\n\t\t{\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble()\n\t\t{\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String next()\n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo\n\t\t\t{\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine()\n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo\n\t\t\t{\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\nusing namespace std;\nbool is_prime(long long n) {\n  if (n <= 1) {\n    return false;\n  }\n  for (long long i = 2; i * i <= n; ++i) {\n    if (n % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\ninline long long getPow(long long a, long long b) {\n  long long res = 1ll, tp = a;\n  while (b) {\n    if (b & 1ll) {\n      res *= tp;\n    }\n    tp *= tp;\n    b >>= 1ll;\n  }\n  return res;\n}\nlong long coso(long long x1, long long y1, long long x2, long long y2,\n               long long x3, long long y3) {\n  return abs((x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1));\n}\ninline long long nxt() {\n  long long x;\n  cin >> x;\n  return x;\n}\nvoid ok() {\n  puts(\"YES\");\n  exit(0);\n}\nvoid no() {\n  puts(\"NO\");\n  exit(0);\n}\nconst long long N = 1e6 + 5;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long n = nxt();\n  vector<long long> mas(n);\n  for (int i = 0; i < n; i++) {\n    mas[i] = nxt();\n  }\n  vector<vector<long long>> dp(200 + 5, vector<long long>(2, 0LL));\n  if (mas[0] == -1) {\n    for (int i = 1; i <= 200; i++) {\n      dp[i][1] = 1;\n    }\n  } else\n    dp[mas[0]][1] = 1;\n  for (int i = 1; i < n; i++) {\n    long long cur = 0;\n    vector<vector<long long>> dp2(200 + 5, vector<long long>(2, 0LL));\n    for (int j = 1; j <= 200; j++) {\n      dp2[j][1] = cur;\n      cur = (cur + dp[j][0] + dp[j][1]);\n      while (cur > 998244353) {\n        cur -= 998244353;\n      }\n    }\n    cur = 0;\n    for (int j = 200; j >= 1; j--) {\n      dp2[j][0] =\n          ((dp2[j][0] + dp[j][0] + dp[j][1]) % 998244353 + cur) % 998244353;\n      while (dp2[j][0] > 998244353) {\n        dp2[j][0] -= 998244353;\n      }\n      cur = (cur + dp[j][0]);\n      while (cur > 998244353) {\n        cur -= 998244353;\n      }\n    }\n    for (int j = 1; j <= 200; j++) {\n      if (mas[i] != -1 && mas[i] != j) {\n        dp2[j][0] = dp2[j][1] = 0;\n      }\n    }\n    dp = dp2;\n  }\n  long long ans = 0LL;\n  for (int i = 1; i <= 200; i++) {\n    ans += dp[i][0];\n  }\n  cout << ans % 998244353;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nint n, a[100005];\nll ans = 1, dp1[2][201], dp2[2][201];\nconst ll MOD = 998244353;\nconst int T = 200;\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", a + i);\n  for (int i = 1; i <= n; ++i) {\n    if (a[i] != -1 && a[i - 1] != -1 && a[i + 1] != -1 && a[i - 1] < a[i] &&\n        a[i + 1] < a[i]) {\n      printf(\"0\\n\");\n      return 0;\n    }\n  }\n  int start = 1;\n  while (start <= n) {\n    if (a[start] != -1) {\n      ++start;\n      continue;\n    }\n    int end = start;\n    while (end + 1 <= n && a[end + 1] == -1 || end + 2 <= n && a[end + 2] == -1)\n      ++end;\n    for (int b = 1; b <= T; ++b) {\n      if (end == n) {\n        dp1[0][b] = 1;\n        dp2[0][b] = 0;\n      } else if (end == n - 1) {\n        dp1[0][b] = (b >= a[end + 1]) ? 1 : 0;\n        dp2[0][b] = (b == a[end + 1]) ? 1 : 0;\n      } else {\n        if (a[end + 1] <= a[end + 2]) {\n          dp1[0][b] = 1;\n          dp2[0][b] = (b <= a[end + 1]) ? 1 : 0;\n        } else {\n          dp1[0][b] = (b >= a[end + 1]) ? 1 : 0;\n          dp2[0][b] = (b == a[end + 1]) ? 1 : 0;\n        }\n      }\n    }\n    for (int m = 1; m <= end - start + 1; ++m) {\n      if (a[end - m + 1] != -1) {\n        for (int b = 1; b <= T; ++b) {\n          if (a[end - m + 1] < b)\n            dp2[m & 1][b] = 0;\n          else if (a[end - m + 1] == b)\n            dp2[m & 1][b] = dp1[(m - 1) & 1][b];\n          else\n            dp2[m & 1][b] = dp2[(m - 1) & 1][a[end - m + 1]];\n          if (a[end - m + 1] <= b)\n            dp1[m & 1][b] = dp1[(m - 1) & 1][a[end - m + 1]];\n          else\n            dp1[m & 1][b] = dp2[(m - 1) & 1][a[end - m + 1]];\n        }\n      } else {\n        dp2[m & 1][T] = dp1[(m - 1) & 1][T];\n        for (int b = T - 1; b; --b) {\n          dp2[m & 1][b] = dp2[m & 1][b + 1] - dp1[(m - 1) & 1][b + 1] +\n                          dp2[(m - 1) & 1][b + 1] + dp1[(m - 1) & 1][b];\n          dp2[m & 1][b] %= MOD;\n        }\n        dp1[m & 1][1] = dp1[(m - 1) & 1][1];\n        for (int k = 2; k <= T; ++k) {\n          dp1[m & 1][1] += dp2[(m - 1) & 1][k];\n          dp1[m & 1][1] %= MOD;\n        }\n        for (int b = 2; b <= T; ++b) {\n          dp1[m & 1][b] =\n              dp1[m & 1][b - 1] + dp1[(m - 1) & 1][b] - dp2[(m - 1) & 1][b];\n          dp1[m & 1][b] %= MOD;\n        }\n      }\n    }\n    int m = (end - start + 1) & 1;\n    if (start == 1) {\n      ll x = 0;\n      for (int k = 1; k <= T; ++k) x += dp2[m ^ 1][k];\n      ans = (ans * x) % MOD;\n    } else if (start == 2) {\n      ans = (ans * dp2[m][a[start - 1]]) % MOD;\n    } else {\n      if (a[start - 1] <= a[start - 2]) {\n        ans = (ans * dp1[m][a[start - 1]]) % MOD;\n      } else {\n        ans = (ans * dp2[m][a[start - 1]]) % MOD;\n      }\n    }\n    start = end + 1;\n  }\n  ans %= MOD;\n  ans = (ans + MOD) % MOD;\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100000 + 9;\nconst int M = 200;\nconst int MOD = 998244353;\nint N, dp[maxn][M + 9][2];\ninline void Mod(int &x) {\n  if (x >= MOD) x -= MOD;\n  if (x < 0) x += MOD;\n}\nvoid upd(int i, int val) {\n  Mod(dp[i][val][0] = dp[i - 1][val - 1][0] + dp[i - 1][val - 1][1]);\n  Mod(dp[i][val][1] = dp[i - 1][M][1] - dp[i - 1][val - 1][1]);\n  Mod(dp[i][val][1] += dp[i - 1][val][0] - dp[i - 1][val - 1][0]);\n}\nint main() {\n  scanf(\"%d\", &N);\n  for (int j = 0; j <= M; j++) dp[0][j][1] = 1;\n  for (int i = 1, val; i <= N; i++) {\n    scanf(\"%d\", &val);\n    if (val == -1)\n      for (int j = 1; j <= M; j++) upd(i, j);\n    else\n      upd(i, val);\n    for (int j = 1; j <= M; j++) {\n      Mod(dp[i][j][0] += dp[i][j - 1][0]);\n      Mod(dp[i][j][1] += dp[i][j - 1][1]);\n    }\n  }\n  printf(\"%d\\n\", dp[N][M][1]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 5;\nconst long long M = 998244353;\nconst int INF = 1e9;\nconst double eps = 1e-8;\nint n;\nlong long dp[205][2], sum[maxn][2];\nint a[maxn];\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  for (int j = 1; j <= 200; j++) {\n    sum[j][0] = 1;\n  }\n  if (a[1] == -1) {\n    for (int j = 1; j <= 200; j++) {\n      dp[j][0] = 1;\n    }\n  } else {\n    dp[a[1]][0] = 1;\n  }\n  for (int i = 2; i <= n; i++) {\n    for (int j = 1; j <= 200; j++) {\n      sum[j][0] = dp[j][0] + sum[j - 1][0];\n      sum[j][0] %= M;\n      sum[j][1] = dp[j][1] + sum[j - 1][1];\n      sum[j][1] %= M;\n    }\n    if (a[i] == -1) {\n      for (int j = 1; j <= 200; j++) {\n        dp[j][1] = (sum[200][1] - sum[j - 1][1] + M) % M +\n                   (sum[j][0] - sum[j - 1][0] + M) % M;\n        dp[j][0] = sum[j - 1][1] + sum[j - 1][0];\n        dp[j][0] %= M;\n        dp[j][1] %= M;\n      }\n    } else {\n      memset(dp, 0, sizeof(dp));\n      int j = a[i];\n      dp[j][1] = (sum[200][1] - sum[j - 1][1] + M) % M +\n                 (sum[j][0] - sum[j - 1][0] + M) % M;\n      dp[j][0] = sum[j - 1][1] + sum[j - 1][0];\n      dp[j][0] %= M;\n      dp[j][1] %= M;\n    }\n  }\n  long long ans = 0;\n  if (a[n] == -1) {\n    for (int j = 1; j <= 200; j++) {\n      sum[j][1] = dp[j][1] + sum[j - 1][1];\n      sum[j][1] %= M;\n    }\n    ans = sum[200][1];\n  } else {\n    ans = dp[a[n]][1];\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import os\nfrom io import BytesIO\nfrom math import trunc\n\nif os.name == 'nt':\n    input = BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\nMX = 201\nMOD = 998244353\nMODF = float(MOD)\nMODF_inv = 1.0 / MODF\n\nquickmod1 = lambda x: x - MODF * trunc(x / MODF)\n\n\ndef quickmod(a):\n    return a - MODF * trunc(a * MODF_inv)\n\n\ndef main():\n    n = int(input())\n    a = map(int, input().split())\n\n    dp0 = [1.0] * MX\n    dp1 = [0.0] * MX\n\n    for x in a:\n        pomdp0 = [0.0] * MX\n        pomdp1 = [0.0] * MX\n        if x == -1:\n            for val in range(1, MX):\n                pomdp0[val] = quickmod(\n                    pomdp0[val - 1] + dp1[val - 1] + dp0[val - 1])\n                pomdp1[val] = quickmod(\n                    pomdp1[val - 1] + dp1[MX - 1] - dp1[val - 1] + dp0[val] -\n                    dp0[val - 1])\n        else:\n            pomdp0[x] = quickmod(dp1[x - 1] + dp0[x - 1])\n            pomdp1[x] = quickmod(dp1[MX - 1] - dp1[x - 1] + dp0[x] - dp0[x - 1])\n            for val in range(x + 1, MX):\n                pomdp0[val] = pomdp0[val - 1]\n                pomdp1[val] = pomdp1[val - 1]\n\n        dp0, dp1 = pomdp0, pomdp1\n\n    print(int(dp1[MX - 1] if n > 1 else dp0[MX - 1]) % MOD)\n\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main1 {\n\t\n\tstatic final int mod = 998244353;\n\t\n\t\n    public static void main(String[] args) throws Throwable {\n        Scanner sc = new Scanner(System.in);\n//\t\tScanner sc = new Scanner(\"out\");\n        int n = sc.nextInt() , a[] = sc.nexIntArray();\n\t\tint[][] dpMin = new int[n][201] , dpMax = new int[n][201] ;\n\t\tint[] minSum = new int[201] , maxSum = new int[201] ;\n\t\t\n\t\tif(a[1]==-1)\n\t\t{\n\t\t\tif(a[0]==-1)\n\t\t\t{\n\t\t\t\tfor(int i = 1;i<=200;i++)\n\t\t\t\t{\n\t\t\t\t\tdpMin[1][i] = 1;\n\t\t\t\t\tdpMax[1][i] = i-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdpMin[1][a[0]] = 1;\n\t\t\t\tfor(int i = a[0]+1;i<=200;i++)\n\t\t\t\t\tdpMax[1][i] = 1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(a[0]==-1)\n\t\t\t{\n\t\t\t\tdpMax[1][a[1]] = a[1]-1;\n\t\t\t\tdpMin[1][a[1]] = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(a[0]<a[1])\n\t\t\t\t\tdpMax[1][a[1]] = 1;\n\t\t\t\telse\n\t\t\t\t\tdpMin[1][a[1]] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 1;i<=200;i++)\n\t\t{\n\t\t\tminSum[i] = (dpMin[1][i] + minSum[i-1])%mod;\n\t\t\tmaxSum[i] = (dpMax[1][i] + maxSum[i-1])%mod;\n\t\t}\n\t\t\n\t\tfor(int i = 2;i<n;i++)\n\t\t{\n\t\t\tif(a[i]!=-1)\n\t\t\t{\n\t\t\t\tint cur = a[i];\n\t\t\t\tint dif = minSum[200] - minSum[cur];if(dif<0)dif+=mod;\n\t\t\t\tdpMin[i][cur] = dif;\n\t\t\t\tdpMin[i][cur] = ((dpMin[i][cur] + dpMin[i-1][cur])%mod + dpMax[i-1][cur])%mod;\n\t\t\t\tdpMax[i][cur] = (minSum[cur-1] + maxSum[cur-1])%mod;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int cur = 1;cur<=200;cur++)\n\t\t\t\t{\n\t\t\t\t\tint dif = minSum[200] - minSum[cur];if(dif<0)dif+=mod;\n\t\t\t\t\tdpMin[i][cur] = dif;\n\t\t\t\t\tdpMin[i][cur] = ((dpMin[i][cur] + dpMin[i-1][cur])%mod + dpMax[i-1][cur])%mod;\n\t\t\t\t\tdpMax[i][cur] = (minSum[cur-1] + maxSum[cur-1])%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int v = 1;v<=200;v++)\n\t\t\t{\n\t\t\t\tminSum[v] = (minSum[v-1]+dpMin[i][v])%mod;\n\t\t\t\tmaxSum[v] = (maxSum[v-1] + dpMax[i][v])%mod;\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong ans = 0;\n\t\tfor(int i = 0; i <= 200;i++) \n\t\t\tans = (ans+dpMin[n-1][i])%mod;\n\t\tSystem.out.println(ans%mod);\n\t\t\n    }\n\n    static class Scanner{\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\t\tpublic Scanner(InputStream s){\tbr = new BufferedReader(new InputStreamReader(s));}\n\t\tpublic Scanner(String file) throws FileNotFoundException { br = new BufferedReader(new FileReader(file));}\n\t\tpublic String next() throws IOException \n\t\t{\n\t\t\twhile (st == null || !st.hasMoreTokens())st = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n\t\tpublic long nextLong() throws IOException {return Long.parseLong(next());}\n\t\tpublic String nextLine() throws IOException {return br.readLine();}\n\t\tpublic double nextDouble() throws IOException\n\t\t{\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif(x.charAt(0) == '-'){neg = true;start++;}\n\t\t\tfor(int i = start; i < x.length(); i++)\n\t\t\t\tif(x.charAt(i) == '.')\n\t\t\t\t{\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t}\n\t\t\t\telse{sb.append(x.charAt(i));if(dec)f *= 10;}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg?-1:1);\n\t\t}\n\t\tpublic int[] nexIntArray() throws Throwable\n\t\t{\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tint[] a = new int[st.countTokens()];\n\t\t\tfor(int i = 0; i < a.length;i++)a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tpublic boolean ready() throws IOException {return br.ready();\n\t}\n\n}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct edge {\n  int to;\n};\nconst long long LINF = 123123123123123123;\nconst int INF = 1231231234;\nconst int MOD = 998244353;\nconst long double EPS = 1e-9;\nconst int MAXN = 100000;\nconst int MAXV = 200;\nint dp[MAXN + 5][MAXV + 5][3];\nint prefixUp[MAXV + 5][3], prefixDown[MAXV + 5][3];\nbool valid(vector<int> &a, int i, int val) {\n  if (a[i] == -1)\n    return true;\n  else\n    return a[i] == val;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  memset(dp, 0, sizeof(dp));\n  for (int curr = 1; curr <= 200; curr++)\n    if (valid(a, 0, curr)) {\n      dp[0][curr][0] = 1;\n    }\n  for (int i = 1; i < n; i++) {\n    for (int curr = 200; curr >= 1; curr--) {\n      for (int t = 0; t < 3; t++) {\n        prefixUp[curr][t] =\n            curr == 200\n                ? 0\n                : (prefixUp[curr + 1][t] + dp[i - 1][curr + 1][t]) % MOD;\n      }\n    }\n    for (int curr = 1; curr <= 200; curr++) {\n      for (int t = 0; t < 3; t++) {\n        prefixDown[curr][t] =\n            curr == 1\n                ? 0\n                : (prefixDown[curr - 1][t] + dp[i - 1][curr - 1][t]) % MOD;\n      }\n    }\n    for (int curr = 1; curr <= 200; curr++)\n      if (valid(a, i, curr)) {\n        for (int bit = 0; bit < 3; bit++) {\n          if (bit == 0) {\n            dp[i][curr][bit] += prefixDown[curr][0];\n            dp[i][curr][bit] %= MOD;\n            dp[i][curr][bit] += prefixDown[curr][1];\n            dp[i][curr][bit] %= MOD;\n            dp[i][curr][bit] += prefixDown[curr][2];\n            dp[i][curr][bit] %= MOD;\n          } else if (bit == 2) {\n            dp[i][curr][bit] += prefixUp[curr][1];\n            dp[i][curr][bit] %= MOD;\n            dp[i][curr][bit] += prefixUp[curr][2];\n            dp[i][curr][bit] %= MOD;\n          } else {\n            dp[i][curr][bit] += dp[i - 1][curr][0];\n            dp[i][curr][bit] %= MOD;\n            dp[i][curr][bit] += dp[i - 1][curr][1];\n            dp[i][curr][bit] %= MOD;\n            dp[i][curr][bit] += dp[i - 1][curr][2];\n            dp[i][curr][bit] %= MOD;\n          }\n        }\n      }\n  }\n  int sol = 0;\n  for (int curr = 1; curr <= 200; curr++)\n    if (valid(a, n - 1, curr)) {\n      sol += dp[n - 1][curr][1];\n      sol %= MOD;\n      sol += dp[n - 1][curr][2];\n      sol %= MOD;\n    }\n  cout << sol << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100000 + 10;\nconst int maxm = 200 + 5;\nconst int mod = 998244353;\nint dp[maxn][maxm][2], a[maxn];\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    memset(dp[i], 0, sizeof(dp[i]));\n  }\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  if (a[1] == -1) {\n    for (int i = 1; i <= 200; i++) {\n      dp[1][i][0] = 1;\n    }\n  } else {\n    dp[1][a[1]][0] = 1;\n  }\n  for (int i = 2; i <= n; i++) {\n    if (a[i] == -1) {\n      int cnt = 0;\n      for (int j = 200; j >= 1; j--) {\n        cnt = (cnt + dp[i - 1][j][1]) % mod;\n        dp[i][j][1] = (cnt + dp[i - 1][j][0]) % mod;\n      }\n      int cnt2 = 0;\n      for (int j = 2; j <= 200; j++) {\n        cnt2 = ((cnt2 + dp[i - 1][j - 1][0]) % mod + dp[i - 1][j - 1][1]) % mod;\n        dp[i][j][0] = cnt2;\n      }\n    } else {\n      for (int k = 200; k >= a[i]; k--)\n        dp[i][a[i]][1] = (dp[i][a[i]][1] + dp[i - 1][k][1]) % mod;\n      dp[i][a[i]][1] = (dp[i][a[i]][1] + dp[i - 1][a[i]][0]) % mod;\n      for (int t = 1; t < a[i]; t++)\n        dp[i][a[i]][0] =\n            ((dp[i][a[i]][0] + dp[i - 1][t][1]) % mod + dp[i - 1][t][0]) % mod;\n    }\n  }\n  int ans = 0;\n  for (int i = 1; i <= 200; i++) {\n    ans = (ans + dp[n][i][1]) % mod;\n  }\n  printf(\"%d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 998244353;\nconst int MAXN = 100000;\nconst int MAXV = 200;\nint dp[MAXN + 5][MAXV + 5][3];\nint prefixUp[MAXV + 5][3], prefixDown[MAXV + 5][3];\nbool valid(vector<int> &a, int i, int val) {\n  if (a[i] == -1)\n    return true;\n  else\n    return a[i] == val;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  memset(dp, 0, sizeof(dp));\n  for (int curr = 1; curr <= 200; curr++)\n    if (valid(a, 0, curr)) {\n      dp[0][curr][0] = 1;\n    }\n  for (int i = 1; i < n; i++) {\n    for (int curr = 200; curr >= 1; curr--) {\n      for (int t = 0; t < 3; t++) {\n        prefixUp[curr][t] =\n            curr == 200\n                ? 0\n                : (prefixUp[curr + 1][t] + dp[i - 1][curr + 1][t]) % MOD;\n      }\n    }\n    for (int curr = 1; curr <= 200; curr++) {\n      for (int t = 0; t < 3; t++) {\n        prefixDown[curr][t] =\n            curr == 1\n                ? 0\n                : (prefixDown[curr - 1][t] + dp[i - 1][curr - 1][t]) % MOD;\n      }\n    }\n    vector<int> pd(MAXV + 1);\n    for (int curr = 2; curr <= MAXV; curr++) {\n      for (int t = 0; t < 3; t++)\n        pd[curr] += prefixDown[curr][t], pd[curr] %= MOD;\n    }\n    for (int curr = 1; curr <= 200; curr++)\n      if (valid(a, i, curr)) {\n        for (int bit = 0; bit < 3; bit++) {\n          if (bit == 0) {\n            dp[i][curr][bit] = pd[curr];\n          } else if (bit == 2) {\n            dp[i][curr][bit] += prefixUp[curr][1];\n            dp[i][curr][bit] %= MOD;\n            dp[i][curr][bit] += prefixUp[curr][2];\n            dp[i][curr][bit] %= MOD;\n          } else {\n            dp[i][curr][bit] += dp[i - 1][curr][0];\n            dp[i][curr][bit] %= MOD;\n            dp[i][curr][bit] += dp[i - 1][curr][1];\n            dp[i][curr][bit] %= MOD;\n            dp[i][curr][bit] += dp[i - 1][curr][2];\n            dp[i][curr][bit] %= MOD;\n          }\n        }\n      }\n  }\n  int sol = 0;\n  for (int curr = 1; curr <= 200; curr++)\n    if (valid(a, n - 1, curr)) {\n      sol += dp[n - 1][curr][1];\n      sol %= MOD;\n      sol += dp[n - 1][curr][2];\n      sol %= MOD;\n    }\n  cout << sol << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 998244353;\nconst int MAXN = 100000;\nconst int MAXV = 200;\nint dp[MAXN + 5][MAXV + 5][3];\nint prefixUp[MAXV + 5][3], prefixDown[MAXV + 5][3];\nbool valid(vector<int> &a, int i, int val) {\n  if (a[i] == -1)\n    return true;\n  else\n    return a[i] == val;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  memset(dp, 0, sizeof(dp));\n  for (int curr = 1; curr <= 200; curr++)\n    if (valid(a, 0, curr)) {\n      dp[0][curr][0] = 1;\n    }\n  for (int i = 1; i < n; i++) {\n    for (int curr = 200; curr >= 1; curr--) {\n      for (int t = 0; t < 3; t++) {\n        prefixUp[curr][t] =\n            curr == 200\n                ? 0\n                : (prefixUp[curr + 1][t] + dp[i - 1][curr + 1][t]) % MOD;\n      }\n    }\n    for (int curr = 1; curr <= 200; curr++) {\n      for (int t = 0; t < 3; t++) {\n        prefixDown[curr][t] =\n            curr == 1\n                ? 0\n                : (prefixDown[curr - 1][t] + dp[i - 1][curr - 1][t]) % MOD;\n      }\n    }\n    for (int curr = 1; curr <= 200; curr++)\n      if (valid(a, i, curr)) {\n        for (int bit = 0; bit < 3; bit++) {\n          if (bit == 0) {\n            dp[i][curr][bit] += prefixDown[curr][0];\n            dp[i][curr][bit] %= MOD;\n            dp[i][curr][bit] += prefixDown[curr][1];\n            dp[i][curr][bit] %= MOD;\n            dp[i][curr][bit] += prefixDown[curr][2];\n            dp[i][curr][bit] %= MOD;\n          } else if (bit == 2) {\n            dp[i][curr][bit] += prefixUp[curr][1];\n            dp[i][curr][bit] %= MOD;\n            dp[i][curr][bit] += prefixUp[curr][2];\n            dp[i][curr][bit] %= MOD;\n          } else {\n            dp[i][curr][bit] += dp[i - 1][curr][0];\n            dp[i][curr][bit] %= MOD;\n            dp[i][curr][bit] += dp[i - 1][curr][1];\n            dp[i][curr][bit] %= MOD;\n            dp[i][curr][bit] += dp[i - 1][curr][2];\n            dp[i][curr][bit] %= MOD;\n          }\n        }\n      }\n  }\n  int sol = 0;\n  for (int curr = 1; curr <= 200; curr++)\n    if (valid(a, n - 1, curr)) {\n      sol += dp[n - 1][curr][1];\n      sol %= MOD;\n      sol += dp[n - 1][curr][2];\n      sol %= MOD;\n    }\n  cout << sol << '\\n';\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Solution{\n    InputStream is;\n    static PrintWriter out;\n    String INPUT = \"\";\n    static long mod = 998244353L;\n    \n    int n;\n    long[][][] dp;\n    int[] a;\n    public void solve(){\n        n = ni();\n        a = na(n);\n        dp = new long[2][201][2];\n\n        if(a[0] == -1){\n\t        for(int v = 1; v <= 200; v++){\n\t\t\t\tdp[0][v][0] = 1 + dp[0][v-1][0];\n\t        }\n\t    }\n\t    else{\n\t    \tfor(int v = a[0]; v <= 200; v++)\n\t    \t\tdp[0][v][0] = 1;\n\t    }\n        for(int i = 1; i < n; i++){\n        \tfor(int v = 1; v <= 200; v++){\n        \t\tfor(int ok = 0; ok < 2; ok++){\n        \t\t\tif(a[i] == -1 || (a[i] == v)){\n        \t\t\t\tif(ok == 1){\n        \t\t\t\t\tdp[1][v][ok] = ((dp[0][200][ok]-dp[0][v-1][ok]+mod) + (dp[0][v][ok-1]-dp[0][v-1][ok-1]+mod));\n        \t\t\t\t}\n        \t\t\t\telse{\n        \t\t\t\t\tdp[1][v][ok] = (dp[0][v-1][ok] + dp[0][v-1][ok+1]);\n        \t\t\t\t}\n        \t\t\t}\n        \t\t\tdp[1][v][ok] = (dp[1][v-1][ok] + dp[1][v][ok])%mod;\n        \t\t}\n        \t}\n\n        \tfor(int v = 1; v <= 200; v++){\n        \t\tfor(int ok = 0; ok < 2; ok ++){\n        \t\t\tdp[0][v][ok] = dp[1][v][ok];\n        \t\t\tdp[1][v][ok] = 0;\n        \t\t}\n        \t}\n        \t\n\n        }\n\n        out.println(dp[0][200][1]);\n    }\n    \n\n    void run(){\n        is = new DataInputStream(System.in);\n        out = new PrintWriter(System.out);\n        int t=1;while(t-->0)solve();\n        out.flush();\n    }\n    public static void main(String[] args)throws Exception{new Solution().run();}\n    long mod(long v, long m){if(v<0){long q=(Math.abs(v)+m-1L)/m;v=v+q*m;}return v%m;}\n    long mod(long v){if(v<0){long q=(Math.abs(v)+mod-1L)/mod;v=v+q*mod;}return v%mod;}\n    //Fast I/O code is copied from uwi code.\n    private byte[] inbuf = new byte[1024];\n    public int lenbuf = 0, ptrbuf = 0;\n    private int readByte(){\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n    private String ns(){\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    private char[] ns(int n){\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    private char[][] nm(int n, int m){\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n    private int[] na(int n){\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n    private int ni(){\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    private long nl(){\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    static  int i(long x){return (int)Math.round(x);}\n    static class Pair implements Comparable<Pair>{\n        long fs,sc;\n        Pair(long a,long b){\n            fs=a;sc=b;\n        }\n        public int compareTo(Pair p){\n            if(this.fs>p.fs)return 1;\n            else if(this.fs<p.fs)return -1;\n            else{\n                return i(this.sc-p.sc);\n            }\n            //return i(this.sc-p.sc);\n        }\n        public String toString(){\n            return \"(\"+fs+\",\"+sc+\")\";\n        }    \n    }\n    \n}"
        },
        {
            "language": 4,
            "solution": "/*\nKeep solving problems.\n*/\n\nimport java.util.*;\nimport java.io.*;\n\npublic class CFA {\n    BufferedReader br;\n    PrintWriter out;\n    StringTokenizer st;\n    boolean eof;\n    private static final long MOD = 998244353L;\n    private static final int[] dx = {0, -1, 0, 1};\n    private static final int[] dy = {1, 0, -1, 0};\n    private static final String yes = \"Yes\";\n    private static final String no = \"No\";\n\n    int n;\n    int[] arr;\n    long[][] dp;\n    long[][] pref;\n    int limit = 205;\n    void solve() throws IOException {\n        n = nextInt();\n        arr = nextIntArr(n);\n\n        dp = new long[2][limit];\n        pref = new long[2][limit];\n        dp[1][1] = 1;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < limit; j++) {\n                for (int k = 0; k < 2; k++) {\n                    if (dp[k][j] == 0) {\n                        continue;\n                    }\n\n                    if (arr[i] == -1) {\n                        if (k == 1) {\n                            //[j + 1, 200]\n                            pref[0][j + 1] += dp[k][j];\n                            pref[0][201] -= dp[k][j];\n\n                            if (pref[0][j + 1] >= MOD) {\n                                pref[0][j + 1] -= MOD;\n                            }\n                            if (pref[0][201] < 0) {\n                                pref[0][201] += MOD;\n                            }\n\n                            //[1, j]\n                            pref[1][1] += dp[k][j];\n                            pref[1][j + 1] -= dp[k][j];\n                            if (pref[1][1] >= MOD) {\n                                pref[1][1] -= MOD;\n                            }\n                            if (pref[1][j + 1] < 0) {\n                                pref[1][j + 1] += MOD;\n                            }\n                        }\n                        else {\n                            //[j + 1, 200]\n                            pref[0][j + 1] += dp[k][j];\n                            pref[0][201] -= dp[k][j];\n                            if (pref[0][j + 1] >= MOD) {\n                                pref[0][j + 1] -= MOD;\n                            }\n                            if (pref[0][201] < 0) {\n                                pref[0][201] += MOD;\n                            }\n\n                            //[j, j]\n                            pref[1][j] += dp[k][j];\n                            pref[1][j + 1] -= dp[k][j];\n                            if (pref[1][j] >= MOD) {\n                                pref[1][j] -= MOD;\n                            }\n\n                            if (pref[1][j + 1] < 0) {\n                                pref[1][j + 1] -= MOD;\n                            }\n                        }\n                    }\n                    else {\n                        int nj = arr[i];\n                        if (k == 1) {\n                            if (nj > j) {\n                                //[nj, nj]\n                                pref[0][nj] += dp[k][j];\n                                if (pref[0][nj] >= MOD) {\n                                    pref[0][nj] -= MOD;\n                                }\n\n                                pref[0][nj + 1] -= dp[k][j];\n                                if (pref[0][nj + 1] < 0) {\n                                    pref[0][nj + 1] += MOD;\n                                }\n                            }\n                            else {\n                                //[nj, nj]\n                                pref[1][nj] += dp[k][j];\n                                if (pref[1][nj] >= MOD) {\n                                    pref[1][nj] -= MOD;\n                                }\n                                pref[1][nj + 1] -= dp[k][j];\n                                if (pref[1][nj + 1] < 0) {\n                                    pref[1][nj + 1] += MOD;\n                                }\n                            }\n                        }\n                        else {\n                            if (nj > j) {\n                                //[nj, nj]\n                                pref[0][nj] += dp[k][j];\n                                pref[0][nj + 1] -= dp[k][j];\n                                if (pref[0][nj] >= MOD) {\n                                    pref[0][nj] -= MOD;\n                                }\n                                if (pref[0][nj + 1] < 0) {\n                                    pref[0][nj + 1] += MOD;\n                                }\n                            }\n                            else if (nj == j){\n                                //[nj, nj]\n                                pref[1][nj] += dp[k][j];\n                                pref[1][nj + 1] -= dp[k][j];\n                                if (pref[1][nj] >= MOD) {\n                                    pref[1][nj] -= MOD;\n                                }\n                                if (pref[1][nj + 1] < 0) {\n                                    pref[1][nj + 1] += MOD;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            calcPref();\n        }\n\n        long res = 0;\n        for (int j = 0; j < limit; j++) {\n            res += dp[1][j];\n            if (res >= MOD) {\n                res -= MOD;\n            }\n        }\n\n        outln(res);\n    }\n\n    void calcPref() {\n        for (int j = 1; j < limit; j++) {\n            pref[0][j] += pref[0][j - 1];\n            if (pref[0][j] >= MOD) {\n                pref[0][j] -= MOD;\n            }\n            if (pref[0][j] < 0) {\n                pref[0][j] += MOD;\n            }\n\n            dp[0][j] = pref[0][j];\n            pref[1][j] += pref[1][j - 1];\n            if (pref[1][j] >= MOD) {\n                pref[1][j] -= MOD;\n            }\n            if (pref[1][j] < 0) {\n                pref[1][j] += MOD;\n            }\n\n            dp[1][j] = pref[1][j];\n        }\n\n        for (int j = 0; j < limit; j++) {\n            pref[0][j] = 0;\n            pref[1][j] = 0;\n        }\n    }\n\n//    long add(long a, long b) {\n//        long res = a + b;\n//        if (res >= MOD) {\n//            res -= MOD;\n//        }\n//        if (res < 0) {\n//            res += MOD;\n//        }\n//        return res;\n//    }\n\n    void shuffle(int[] a) {\n        int n = a.length;\n        for(int i = 0; i < n; i++) {\n            int r = i + (int) (Math.random() * (n - i));\n            int tmp = a[i];\n            a[i] = a[r];\n            a[r] = tmp;\n        }\n    }\n    long gcd(long a, long b) {\n        while(a != 0 && b != 0) {\n            long c = b;\n            b = a % b;\n            a = c;\n        }\n        return a + b;\n    }\n    private void outln(Object o) {\n        out.println(o);\n    }\n    private void out(Object o) {\n        out.print(o);\n    }\n    private void formatPrint(double val) {\n        outln(String.format(\"%.9f%n\", val));\n    }\n    public CFA() throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n    public static void main(String[] args) throws IOException {\n        new CFA();\n    }\n\n    public long[] nextLongArr(int n) throws IOException{\n        long[] res = new long[n];\n        for(int i = 0; i < n; i++)\n            res[i] = nextLong();\n        return res;\n    }\n    public int[] nextIntArr(int n) throws IOException {\n        int[] res = new int[n];\n        for(int i = 0; i < n; i++)\n            res[i] = nextInt();\n        return res;\n    }\n    public String nextToken() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                eof = true;\n                return null;\n            }\n        }\n        return st.nextToken();\n    }\n    public String nextString() {\n        try {\n            return br.readLine();\n        } catch (IOException e) {\n            eof = true;\n            return null;\n        }\n    }\n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n    public long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n    public double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\nint dp[2][2][202];\nint main() {\n  int n;\n  cin >> n;\n  dp[0][0][0] = 1;\n  for (int i = 1; i <= n; i++) {\n    int x;\n    cin >> x;\n    if (x == -1) {\n      for (int j = 200; j >= 1; j--) {\n        dp[i & 1][0][j] = dp[1 & i][0][j + 1];\n        dp[i & 1][0][j] += dp[1 & i ^ 1][0][j];\n        if (dp[i & 1][0][j] >= mod) dp[i & 1][0][j] -= mod;\n      }\n      for (int j = 1; j <= 200; j++) {\n        dp[i & 1][0][j] += dp[1 & i ^ 1][1][j];\n        if (dp[i & 1][0][j] >= mod) dp[i & 1][0][j] -= mod;\n        dp[i & 1][1][j] = dp[1 & i][1][j - 1];\n        dp[i & 1][1][j] += dp[1 & i ^ 1][0][j - 1];\n        if (dp[i & 1][1][j] >= mod) dp[i & 1][1][j] -= mod;\n        dp[i & 1][1][j] += dp[1 & i ^ 1][1][j - 1];\n        if (dp[i & 1][1][j] >= mod) dp[i & 1][1][j] -= mod;\n      }\n    } else {\n      fill(dp[i & 1][0], dp[i & 1][0] + 201, 0);\n      fill(dp[i & 1][1], dp[i & 1][1] + 201, 0);\n      for (int j = 0; j < x; j++) {\n        dp[i & 1][1][x] += dp[1 & i ^ 1][1][j];\n        if (dp[i & 1][1][x] >= mod) dp[i & 1][1][x] -= mod;\n        dp[i & 1][1][x] += dp[1 & i ^ 1][0][j];\n        if (dp[i & 1][1][x] >= mod) dp[i & 1][1][x] -= mod;\n      }\n      dp[i & 1][0][x] = dp[1 & i ^ 1][1][x];\n      for (int j = x; j <= 200; j++) {\n        dp[i & 1][0][x] += dp[1 & i ^ 1][0][j];\n        if (dp[i & 1][0][x] >= mod) dp[i & 1][0][x] -= mod;\n      }\n    }\n    if (i == 1) dp[0][0][0] = 0;\n  }\n  cout << accumulate(dp[n & 1][0], dp[n & 1][0] + 201, 0LL) % mod << endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "import os\nfrom io import BytesIO\nfrom math import trunc\n\ninput = BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\nMX = 201\nMOD = 998244353\nMODF = float(MOD)\n\nquickmod = lambda x: x - MODF * trunc(x / MODF)\n\n\ndef main():\n    n = int(input())\n    a = map(int, input().split())\n\n    dp0 = [1.0] * MX\n    dp1 = [0.0] * MX\n\n    for x in a:\n        pomdp0 = [0.0] * MX\n        pomdp1 = [0.0] * MX\n        if x == -1:\n            for val in range(1, MX):\n                pomdp0[val] = quickmod(\n                    pomdp0[val - 1] + dp1[val - 1] + dp0[val - 1])\n                pomdp1[val] = quickmod(\n                    pomdp1[val - 1] + dp1[MX - 1] - dp1[val - 1] + dp0[val] -\n                    dp0[val - 1])\n        else:\n            pomdp0[x] = quickmod(dp1[x - 1] + dp0[x - 1])\n            pomdp1[x] = quickmod(dp1[MX - 1] - dp1[x - 1] + dp0[x] - dp0[x - 1])\n            for val in range(x + 1, MX):\n                pomdp0[val] = pomdp0[val - 1]\n                pomdp1[val] = pomdp1[val - 1]\n\n        dp0, dp1 = pomdp0, pomdp1\n\n    print(int(dp1[MX - 1] if n > 1 else dp0[MX - 1]) % MOD)\n\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int MOD = 998244353;\nconst long long BIG = 1446803456761533460LL;\nconst int Big = 336860180;\nconst long long int INF = LONG_LONG_MAX;\nconst long long int adj4[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\nconst long long int adj8[8][2] = {{0, 1},   {0, -1}, {1, 0},  {-1, 0},\n                                  {-1, -1}, {1, -1}, {-1, 1}, {1, 1}};\nlong long int clk_ar[10];\nlong long int gcd(long long int a, long long int b) {\n  return b == 0 ? a : gcd(b, a % b);\n}\nlong long int powMod(long long int a, long long int b) {\n  long long int n = 1;\n  long long int p = a;\n  while (b > 0) {\n    if (b % 2 == 1) {\n      n *= p;\n      n %= MOD;\n    }\n    p *= p;\n    p %= MOD;\n    b /= 2;\n  }\n  return n;\n}\nlong long int modularInverse(long long int a) { return powMod(a, MOD - 2); }\nstringstream sss;\nconst long long int maxn = 100010;\nconst long long int maxm = 200;\nlong long int dp[2][3][maxm + 1];\nlong long int ps[2][3][maxm + 1];\nlong long int ar[maxn];\nvoid MAIN() {\n  long long int n;\n  cin >> n;\n  for (long long int i = 0; i < (n); ++i) {\n    cin >> ar[i];\n  }\n  if (ar[0] == -1) {\n    for (long long int i = (1); i < (maxm + 1); ++i) {\n      dp[0][1][i] = 1;\n    }\n  } else {\n    dp[0][1][ar[0]] = 1;\n  }\n  for (long long int j = (0); j < (maxm); ++j) {\n    ps[0][1][j + 1] = (ps[0][1][j] + dp[0][1][j + 1]) % MOD;\n  }\n  for (long long int i = (1); i < (n); ++i) {\n    memset(dp[i & 1], 0, sizeof dp[0]);\n    for (long long int j = (1); j < (maxm + 1); ++j) {\n      if (ar[i] != -1 && ar[i] != j) continue;\n      dp[i & 1][2][j] =\n          (dp[i & 1 ^ 1][0][j] + dp[i & 1 ^ 1][1][j] + dp[i & 1 ^ 1][2][j]) %\n          MOD;\n      dp[i & 1][0][j] = (ps[i & 1 ^ 1][0][maxm] - ps[i & 1 ^ 1][0][j] + MOD +\n                         ps[i & 1 ^ 1][2][maxm] - ps[i & 1 ^ 1][2][j] + MOD) %\n                        MOD;\n      dp[i & 1][1][j] = (ps[i & 1 ^ 1][0][j - 1] + ps[i & 1 ^ 1][1][j - 1] +\n                         ps[i & 1 ^ 1][2][j - 1]) %\n                        MOD;\n    }\n    for (long long int k = 0; k < (3); ++k) {\n      for (long long int j = (0); j < (maxm); ++j) {\n        ps[i & 1][k][j + 1] = (ps[i & 1][k][j] + dp[i & 1][k][j + 1]) % MOD;\n      }\n    }\n  }\n  long long int res = (ps[n & 1 ^ 1][0][maxm] + ps[n & 1 ^ 1][2][maxm]) % MOD;\n  cout << (res) << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cout << fixed << setprecision(10);\n  sss << R\"(\n3\n1 -1 2\n2\n-1 -1\n    )\";\n  MAIN();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nclass Solution {\n public:\n  int count(vector<int>& nums) {\n    int n = nums.size();\n    int m = 200;\n    if (n == 0) {\n      return 0;\n    }\n    if (n == 1) {\n      return nums[0] == -1 ? 200 : 1;\n    }\n    vector<vector<int>> dp(m + 1, vector<int>(2, 0));\n    if (nums[0] == -1) {\n      for (int i = 1; i <= m; ++i) {\n        dp[i][0] = 1;\n      }\n    } else {\n      dp[nums[0]][0] = 1;\n    }\n    vector<vector<int>> nxt = dp;\n    for (int i = 1; i < n; ++i) {\n      long long sum = 0;\n      for (int j = 1; j <= m; ++j) {\n        nxt[j][0] = sum;\n        sum = addM(sum, 0LL + dp[j][0] + dp[j][1]);\n      }\n      sum = 0;\n      for (int j = m; j >= 1; --j) {\n        sum = addM(sum, dp[j][1]);\n        nxt[j][1] = addM(sum, dp[j][0]);\n      }\n      if (nums[i] != -1) {\n        for (int j = 1; j <= m; ++j) {\n          if (j != nums[i]) {\n            nxt[j][0] = nxt[j][1] = 0;\n          }\n        }\n      }\n      swap(dp, nxt);\n    }\n    long long res = 0;\n    for (int i = 1; i <= m; ++i) {\n      res = addM(res, dp[i][1]);\n    }\n    return res;\n  }\n\n private:\n  const int M = 998244353;\n  long long normalize(long long a) {\n    a %= M;\n    if (a < 0) {\n      a += M;\n    }\n    return a;\n  }\n  long long addM(long long a, long long b) { return normalize(a + b); }\n  long long mulM(long long a, long long b) { return normalize(a * b); }\n};\nint main(int argc, char** argv) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> nums(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> nums[i];\n  }\n  Solution sol;\n  cout << sol.count(nums) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.PrintWriter;\n\npublic class D {\n\t\n\tint N = 200;\n\tint n;\n\t\n\tfinal int DONE = 0, MISSING = 1;\n\tfinal int mod = 998244353;\n\t\n\tint[] a;\n\t\n\tlong[][][] memo;\n\tlong dp(int ind, int prev, int state) {\n\t\tif(ind == n) {\n\t\t\treturn state == MISSING ? 0 : 1;\n\t\t}\n\t\tif(memo[state][prev][ind] != -1) return memo[state][prev][ind];\n\t\tlong ans = 0;\n\t\tif(a[ind] != -1) {\n\t\t\tint x = a[ind];\n\t\t\tif(state == MISSING) {\n\t\t\t\tif(x > prev) ans = dp(ind + 1, x, MISSING);\n\t\t\t\tif(x == prev) ans = dp(ind + 1, x, DONE);\n\t\t\t} else { //prev is DONE\n\t\t\t\tif(x <= prev) ans = dp(ind + 1, x, DONE);\n\t\t\t\telse ans = dp(ind + 1, x, MISSING); //I am greater than previous\n\t\t\t}\n\t\t} else if(state == MISSING) {\n\t\t\tfor(int i = prev; i <= N; ++i) {\n\t\t\t\tif(i > prev) ans += dp(ind + 1, i, MISSING);\n\t\t\t\telse ans += dp(ind + 1, i, DONE); //equal case\n\t\t\t\tans %= mod;\n\t\t\t}\n\t\t} else {\n\t\t\tfor(int i = 1; i <= N; ++i) {\n\t\t\t\tif(i <= prev) ans += dp(ind + 1, i, DONE);\n\t\t\t\telse ans += dp(ind + 1, i, MISSING);\n\t\t\t\tans %= mod;\n\t\t\t}\n\t\t}\n\t\tmemo[state][prev][ind] = ans;\n\t\treturn ans;\n\t}\n\t\n\tlong doit() {\n\t\tBIT[][] dp = new BIT[2][n + 1];\n\t\tfor(int i = 0; i < 2; ++i) for(int j = 0; j <= n; ++j) dp[i][j] = new BIT(N + 1);\n\t\tfor(int ind = n; ind >= 0; --ind) {\n\t\t\tfor(int prev = 1; prev <= N; ++prev) {\n\t\t\t\tfor(int state = 0; state < 2; ++state) {\n\t\t\t\t\t\n\t\t\t\t\tif(ind == n) {\n\t\t\t\t\t\tdp[state][ind].update(prev, state == MISSING ? 0 : 1);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(a[ind] != -1) {\n\t\t\t\t\t\tint x = a[ind];\n\t\t\t\t\t\tif(state == MISSING) {\n\t\t\t\t\t\t\tif(x > prev) dp[state][ind].update(prev, dp[MISSING][ind + 1].sum(x, x));\n\t\t\t\t\t\t\tif(x == prev) dp[state][ind].update(prev, dp[DONE][ind + 1].sum(x, x));\n\t\t\t\t\t\t} else { //prev is DONE\n\t\t\t\t\t\t\tif(x <= prev) dp[state][ind].update(prev, dp[DONE][ind + 1].sum(x, x));\n\t\t\t\t\t\t\telse dp[state][ind].update(prev, dp[MISSING][ind + 1].sum(x, x)); //I am greater than previous\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(state == MISSING) {\n\t\t\t\t\t\tdp[state][ind].update(prev, dp[DONE][ind + 1].sum(prev, prev));\n\t\t\t\t\t\tdp[state][ind].update(prev, dp[MISSING][ind + 1].sum(prev + 1, N));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdp[state][ind].update(prev, dp[DONE][ind + 1].sum(1, prev));\n\t\t\t\t\t\tdp[state][ind].update(prev, dp[MISSING][ind + 1].sum(prev + 1, N));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn dp[DONE][0].sum(N, N);\n\t}\n\t\n\tint sum(int[] arr, int l, int r) {\n\t\tint ans = arr[r];\n\t\tif(l > 0) ans -= arr[l - 1];\n\t\tif(ans < 0) ans += mod;\n\t\treturn ans;\n\t}\n\t\n\t\n\tint doit2() {\n\t\tint[][][] dp = new int[2][n + 1][N + 1];\n\t\tfor(int ind = n; ind >= 0; --ind) {\n\t\t\tfor(int state = 0; state < 2; ++state) {\n\t\t\t\tfor(int prev = 1; prev <= N; ++prev) {\t\n\t\t\t\t\tif(ind == n) {\n\t\t\t\t\t\tdp[state][ind][prev] = state == MISSING ? 0 : 1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint ans = 0;\n\t\t\t\t\tif(a[ind] != -1) {\n\t\t\t\t\t\tint x = a[ind];\n\t\t\t\t\t\tif(state == MISSING) {\n\t\t\t\t\t\t\tif(x > prev) ans += sum(dp[MISSING][ind + 1], x, x);\n\t\t\t\t\t\t\tif(x == prev) ans += sum(dp[DONE][ind + 1], x, x);\n\t\t\t\t\t\t} else { //prev is DONE\n\t\t\t\t\t\t\tif(x <= prev) ans += sum(dp[DONE][ind + 1], x, x);\n\t\t\t\t\t\t\telse ans += sum(dp[MISSING][ind + 1], x, x); //I am greater than previous\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(state == MISSING) {\n\t\t\t\t\t\tans += sum(dp[DONE][ind + 1], prev, prev);\n\t\t\t\t\t\tans += sum(dp[MISSING][ind + 1], prev + 1, N);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tans += sum(dp[DONE][ind + 1], 1, prev);\n\t\t\t\t\t\tans += sum(dp[MISSING][ind + 1], prev + 1, N);\n\t\t\t\t\t}\n\t\t\t\t\tdp[state][ind][prev] = ans % mod;\n\t\t\t\t}\n\t\t\t\tfor(int prev = 1; prev <= N; ++prev) {\n\t\t\t\t\tdp[state][ind][prev] += dp[state][ind][prev - 1];\n\t\t\t\t\tdp[state][ind][prev] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn sum(dp[MISSING][0], 1, 1);\n\t}\n\t\n\tpublic void solve(JS in, PrintWriter out) {\n\t\t n = in.nextInt();\n\t\t a = new int[n];\n\t\t for(int i = 0; i < n; ++i) a[i] = in.nextInt();\n\t\t\n//\t\tn = 1000;\n//\t\ta = new int[n];\n//\t\tArrays.fill(a, -1);\n//\t\ta[42] = 63;\n\t\t\n\t\tout.println(doit2());\n\t\t/*\n\t\tif(n == 2) {\n\t\t\t if(a[0] == -1 && a[1] == -1) {\n\t\t\t\t out.println(N);\n\t\t\t } else if(Math.min(a[0], a[1]) == -1) {\n\t\t\t\t out.println(1);\n\t\t\t } else {\n\t\t\t\t out.println(0);\n\t\t\t }\n\t\t } \n\t\t else {\n\t\t\t out.println(doit2());\n\t\t \n//\t\t \t\tout.println(doit());\n//\t\t \t\tmemo = new long[2][N + 1][n];\n//\t\t \t\tfor(long[][] x : memo) for(long[] y : x) Arrays.fill(y, -1);\n//\t\t \t\tout.println(dp(0, 1, MISSING));\n\t\t }\n\t\t */\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tJS in = new JS();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tnew D().solve(in, out);\n\t\tout.close();\n\t}\n\t\n\tclass BIT {\n\t\tint n;\n\t\tint[] tree;\n\t\t\n\t\tpublic BIT(int nn) {\n\t\t\tn = nn + 10;\n\t\t\ttree = new int[n + 1];\n\t\t}\n\t\t\n\t\tint read(int i) {\n\t\t\ti += 5;\n\t\t\tint sum = 0;\n\t\t\twhile (i > 0) {\n\t\t\t\tsum += tree[i];\n\t\t\t\tsum %= mod;\n\t\t\t\ti -= i & -i;\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t\t\n\t\tint sum(int l, int r) {\n\t\t\tint ans = read(r) - read(l - 1);\n\t\t\tif(ans < 0) ans += mod;\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\tvoid update(int i, int val) {\n\t\t\ti += 5;\n\t\t\twhile (i <= n) {\n\t\t\t\ttree[i] += val;\n\t\t\t\ttree[i] %= mod;\n\t\t\t\ti += i & -i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic class JS {\n\t\tpublic int BS = 1<<16;\n\t\tpublic char NC = (char)0;\n\t\tbyte[] buf = new byte[BS];\n\t\tint bId = 0, size = 0;\n\t\tchar c = NC;\n\t\tdouble num = 1;\n\t\tBufferedInputStream in;\n\n\t\tpublic JS() {\n\t\t\tin = new BufferedInputStream(System.in, BS);\n\t\t}\n\n\t\tpublic JS(String s) throws FileNotFoundException {\n\t\t\tin = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n\t\t}\n\n\t\tpublic char nextChar(){\n\t\t\twhile(bId==size) {\n\t\t\t\ttry {\n\t\t\t\t\tsize = in.read(buf);\n\t\t\t\t}catch(Exception e) {\n\t\t\t\t\treturn NC;\n\t\t\t\t}\n\t\t\t\tif(size==-1)return NC;\n\t\t\t\tbId=0;\n\t\t\t}\n\t\t\treturn (char)buf[bId++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tnum=1;\n\t\t\tboolean neg = false;\n\t\t\tif(c==NC)c=nextChar();\n\t\t\tfor(;(c<'0' || c>'9'); c = nextChar()) {\n\t\t\t\tif(c=='-')neg=true;\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tfor(; c>='0' && c <='9'; c=nextChar()) {\n\t\t\t\tres = (res<<3)+(res<<1)+c-'0';\n\t\t\t\tnum*=10;\n\t\t\t}\n\t\t\treturn neg?-res:res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\tdouble cur = nextLong();\n\t\t\treturn c!='.' ? cur:cur+nextLong()/num;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile(c<=32)c=nextChar();\n\t\t\twhile(c>32) {\n\t\t\t\tres.append(c);\n\t\t\t\tc=nextChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile(c<=32)c=nextChar();\n\t\t\twhile(c!='\\n') {\n\t\t\t\tres.append(c);\n\t\t\t\tc=nextChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tif(c>32)return true;\n\t\t\twhile(true) {\n\t\t\t\tc=nextChar();\n\t\t\t\tif(c==NC)return false;\n\t\t\t\telse if(c>32)return true;\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class H {\n\n\tstatic int n, a[];\n\tstatic int MOD = 998244353;\n\t\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tn = sc.nextInt();\n\t\t\n\t\ta = new int[n];\n\t\tfor (int i = 0; i < n; i++) \n\t\t\ta[i] = sc.nextInt();\n\t\tint curr=0;\n\t\tint [][][]dp=new int [2][201][2],cum=new int [2][201][2];\n\t\tfor(int idx=n-1;idx>0;idx--)\n\t\t{\n\t\t\t\n\t\t\tint x=a[idx];\n\t\t\tfor(int f=0;f<=1;f++)\n\t\t\t{\n\t\t\t\tint sum=0;\n\t\t\t\tfor(int last=1;last<=200;last++)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tint ans=0;\n\t\t\t\t\tif(f==0)\n\t\t\t\t\t{\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(x==-1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(idx==n-1)\n\t\t\t\t\t\t\t\tans=last;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tans=cum[1-curr][last][0]+cum[1-curr][200][1]-cum[1-curr][last][1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(idx==n-1)\n\t\t\t\t\t\t\t\tans=x<=last?1:0;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tans=dp[1-curr][x][x<=last?0:1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(x==-1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(idx==n-1)\n\t\t\t\t\t\t\t\tans=1;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tans=dp[1-curr][last][0]+cum[1-curr][200][1]-cum[1-curr][last][1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(x>=last) {\n\t\t\t\t\t\t\tif(idx==n-1)\n\t\t\t\t\t\t\t\tans=x==last?1:0;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tans=dp[1-curr][x][x<=last?0:1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ans>=MOD)\n\t\t\t\t\t\tans-=MOD;\n\t\t\t\t\tif(ans<0)\n\t\t\t\t\t\tans+=MOD;\n\t\t\t\t\tsum+=ans;\n\t\t\t\t\tif(sum>=MOD)\n\t\t\t\t\t\tsum-=MOD;\n\t\t\t\t\t\n\t\t\t\t\tdp[curr][last][f]=ans;\n\t\t\t\t\t\n\t\t\t\t\tcum[curr][last][f]=sum;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurr=1-curr;\n\t\t}\n\t\tcurr=1-curr;\t\n\t\tint ans=0;\n\t\tif(a[0]==-1)\n\t\t\tfor(int last=1;last<=200;last++)\n\t\t\t{\n\t\t\t\tans=ans+dp[curr][last][1];\n\t\t\t\t\n\t\t\t\tif(ans>=MOD)\n\t\t\t\t\tans-=MOD;\n\t\t\t}\n\t\telse\n\t\t\tans=dp[curr][a[0]][1];\n\t\t\t\t\n\t\tSystem.out.println(ans);\n\t\tout.close();\n\t}\n\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tString nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tdouble nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\nint n, a[100010], dp[100010][205][2], b[205][2];\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  memset(dp, 0, sizeof(dp));\n  for (int i = 1; i <= 200; i++)\n    if (a[1] == i || a[1] == -1) dp[1][i][0] = 1;\n  for (int i = 2; i <= n; i++) {\n    b[0][0] = 0;\n    b[0][1] = 0;\n    for (int j = 1; j <= 200; j++) {\n      b[j][0] = (b[j - 1][0] + dp[i - 1][j][0]) % mod;\n      b[j][1] = (b[j - 1][1] + dp[i - 1][j][1]) % mod;\n    }\n    for (int j = 1; j <= 200; j++) {\n      if (a[i] != -1 && a[i] != j) continue;\n      dp[i][j][0] = (dp[i][j][0] + b[j - 1][0]) % mod;\n      dp[i][j][0] = (dp[i][j][0] + b[j - 1][1]) % mod;\n      dp[i][j][1] = (dp[i][j][1] + b[200][1]) % mod;\n      dp[i][j][1] = (dp[i][j][1] - b[j - 1][1] + mod) % mod;\n      dp[i][j][1] = (dp[i][j][1] + dp[i - 1][j][0]) % mod;\n    }\n  }\n  int ans = 0;\n  for (int i = 1; i <= 200; i++) ans = (ans + dp[n][i][1]) % mod;\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 998244353;\nint GM(int Num) { return (Num < 0 ? Num + MOD : Num % MOD); }\nint N, M;\nint A[100005];\nint dp[2][205][100005];\nint Solve() {\n  for (int b = 1; b <= 200; b++) dp[1][b][N] = dp[1][b - 1][N] + 1;\n  for (int i = N - 1; i; i--) {\n    for (int b = 1; b <= 200; b++) {\n      if (~A[i] && A[i] < b)\n        dp[0][b][i] = 0;\n      else if (A[i] == -1)\n        dp[0][b][i] = GM(GM(dp[1][b][i + 1] - dp[1][b - 1][i + 1]) +\n                         GM(dp[0][200][i + 1] - dp[0][b][i + 1]));\n      else\n        dp[0][b][i] =\n            GM(dp[A[i] == b][A[i]][i + 1] - dp[A[i] == b][A[i] - 1][i + 1]);\n      dp[0][b][i] = GM(dp[0][b][i] + dp[0][b - 1][i]);\n      if (~A[i])\n        dp[1][b][i] =\n            GM(dp[A[i] <= b][A[i]][i + 1] - dp[A[i] <= b][A[i] - 1][i + 1]);\n      else\n        dp[1][b][i] = GM(GM(dp[1][b][i + 1] - dp[1][0][i + 1]) +\n                         GM(dp[0][200][i + 1] - dp[0][b][i + 1]));\n      dp[1][b][i] = GM(dp[1][b][i] + dp[1][b - 1][i]);\n    }\n  }\n  return (~A[0] ? GM(dp[0][A[0]][1] - dp[0][A[0] - 1][1]) : dp[0][200][1]);\n}\nint main() {\n  scanf(\"%d\", &N);\n  for (int i = 0; i < N; i++) scanf(\"%d\", &A[i]);\n  printf(\"%d\\n\", Solve());\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 1;\nconst long long Base = 998244353;\nint n;\nlong long ans;\nint a[N];\nlong long t[2][202][3], u[2][202][3], d[2][202][3];\nvoid Init() {\n  int s = 1, e = 200;\n  if (a[1] > -1) s = e = a[1];\n  for (int j = s; j <= e; j++) t[0][j][1] = 1;\n  for (int j = 1; j <= 200; j++) u[0][j][1] = u[0][j - 1][1] + t[0][j][1];\n  for (int j = 200; j >= 1; j--) d[0][j][1] = d[0][j + 1][1] + t[0][j][1];\n}\nvoid Solve() {\n  int s, e;\n  for (int i = 2; i <= n; i++) {\n    s = 1, e = 200;\n    if (a[i] > -1) s = e = a[i];\n    for (int j = s; j <= e; j++) {\n      if (i > 2)\n        t[1][j][0] =\n            (t[1][j][0] + (d[0][j + 1][0] + d[0][j + 1][1]) % Base) % Base;\n      t[1][j][1] =\n          (t[1][j][1] + (t[0][j][0] + t[0][j][1] + t[0][j][2]) % Base) % Base;\n      t[1][j][2] = (t[1][j][2] +\n                    (u[0][j - 1][0] + u[0][j - 1][1] + u[0][j - 1][2]) % Base) %\n                   Base;\n    }\n    for (int j = 1; j <= 200; j++) {\n      u[1][j][0] = (u[1][j - 1][0] + t[1][j][0]) % Base;\n      u[1][j][1] = (u[1][j - 1][1] + t[1][j][1]) % Base;\n      u[1][j][2] = (u[1][j - 1][2] + t[1][j][2]) % Base;\n    }\n    for (int j = 200; j >= 1; j--) {\n      d[1][j][0] = (d[1][j + 1][0] + t[1][j][0]) % Base;\n      d[1][j][1] = (d[1][j + 1][1] + t[1][j][1]) % Base;\n      d[1][j][2] = (d[1][j + 1][2] + t[1][j][2]) % Base;\n    }\n    for (int j = 1; j <= 200; j++) {\n      for (int k = 0; k <= 2; k++) {\n        t[0][j][k] = t[1][j][k];\n        t[1][j][k] = 0;\n        d[0][j][k] = d[1][j][k];\n        d[1][j][k] = 0;\n        u[0][j][k] = u[1][j][k];\n        u[1][j][k] = 0;\n      }\n    }\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  Init();\n  Solve();\n  int s = 1, e = 200;\n  if (a[n] > -1) s = e = a[n];\n  for (int i = s; i <= e; i++)\n    ans = (ans + (t[0][i][0] + t[0][i][1]) % Base) % Base;\n  printf(\"%I64d\", ans);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.lang.*;\nimport java.math.*;\npublic class Main extends Thread  {\n    boolean[] prime;\n    FastScanner sc;\n    PrintWriter pw;\n    long startTime = System.currentTimeMillis();\n    final class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastScanner() {\n            try {\n                br = new BufferedReader(new InputStreamReader(System.in));\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n \n        public long nlo() {\n            return Long.parseLong(next());\n        }\n \n        public String next() {\n            if (st.hasMoreTokens()) return st.nextToken();\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return st.nextToken();\n        }\n \n        public int ni() {\n            return Integer.parseInt(next());\n        }\n \n        public String nli() {\n            String line = \"\";\n            if (st.hasMoreTokens()) line = st.nextToken();\n            else try {\n                return br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            while (st.hasMoreTokens()) line += \" \" + st.nextToken();\n            return line;\n        }\n \n        public double nd() {\n            return Double.parseDouble(next());\n        }\n    }\n    public Main(ThreadGroup t,Runnable r,String s,long d )\n    {\n        super(t,r,s,d);\n    }\n    public void run()\n    {\n        sc=new FastScanner();\n        pw=new PrintWriter(System.out);\n        solve();\n        pw.flush();\n        pw.close();\n    }\n    public static void main(String[] args)\n    {\n        new Main(null,null,\"\",1<<20).start();\n    }\n \n \n    /////////////------------------------------------//////////////\n    ////////////------------------Main-Logic--------//////////////\n    ///////////-------------------------------------//////////////\n \n \n    public void solve() {\n         int n=sc.ni();\n        int[] arr=new int[n];\n        for(int i=0;i<n;i++)\n        arr[i]=sc.ni();\n        long[][][] dp=new long[2][202][3];\n        if(arr[n-1]==-1)\n        {\n            if(arr[n-2]==-1)\n            {\n                for(int j=1;j<=200;j++)\n                {\n                    dp[1][j][1]=1;\n                    dp[1][j][2]=j-1;\n                }\n            }\n            else\n            {\n                dp[1][arr[n-2]][1]=1;\n                dp[1][arr[n-2]][2]=arr[n-2]-1;\n            }\n        }\n        else\n        {\n            if(arr[n-2]==-1)\n            {\n                dp[1][arr[n-1]][1]=1;\n                for(int j=arr[n-1]+1;j<=200;j++)\n                {\n                    dp[1][j][2]=1;    \n                }\n            }\n            else\n            {\n                if(arr[n-2]>arr[n-1])\n                dp[1][arr[n-2]][2]=1;\n                else if(arr[n-2]==arr[n-1])\n                dp[1][arr[n-2]][1]=1;\n                else\n                {pw.println(\"0\");return;}\n            }\n        }\n        int mod= 998244353;\n        long[] brr=new long[202];\n        long[] brr1=new long[202];\n        for(int j=1;j<=201;j++)\n            {\n                brr[j]=((brr[j-1]+dp[1][j][0]+dp[1][j][1]+dp[1][j][2])%mod);\n                brr1[j]=(brr1[j-1]+dp[1][j][1]+dp[1][j][0])%mod;\n            }\n        for(int i=n-3;i>=0;i--)\n        {\n            for(int j=0;j<=201;j++)\n            {\n                dp[0][j][0]=dp[0][j][1]=dp[0][j][2]=0;\n            }\n            if(arr[i]==-1)\n                for(int j=1;j<=200;j++)\n                {\n                    dp[0][j][0]=(brr1[200]-brr1[j]+998244353L);\n                    dp[0][j][1]=(dp[1][j][0]+dp[1][j][1]+dp[1][j][2]);\n                    dp[0][j][2]=brr[j-1];\n                    while(dp[0][j][0]>=mod)\n\t\t\t\t\t\tdp[0][j][0]-=mod;\n\t\t\t\t\t\twhile(dp[0][j][1]>=mod)\n\t\t\t\t\t\tdp[0][j][1]-=mod;\n\t\t\t\t\t\twhile(dp[0][j][2]>=mod)\n\t\t\t\t\t\tdp[0][j][2]-=mod;\n\t\t\t\t\t\n                }\n            else\n            {\n                    int j=arr[i];\n                    dp[0][j][0]=(brr1[200]-brr1[j]+mod)%mod;\n                    dp[0][j][1]=(dp[1][j][0]+dp[1][j][1]+dp[1][j][2])%mod;\n                    dp[0][j][2]=brr[j-1];\n            }\n            for(int j=1;j<=201;j++)\n            {\n                brr[j]=((brr[j-1]+dp[0][j][0]+dp[0][j][1]+dp[0][j][2])%mod);\n                brr1[j]=((brr1[j-1]+dp[0][j][1]+dp[0][j][0])%mod);\n            }\n            for(int j=1;j<=201;j++)\n            {\n             dp[1][j][0]=dp[0][j][0];\n             dp[1][j][1]=dp[0][j][1];\n             dp[1][j][2]=dp[0][j][2];\n            }\n        }\n        long ans=0;\n        for(int i=1;i<=200;i++)\n        {\n             ans+=(dp[1][i][1]+dp[1][i][0])%mod;\n             ans%=mod;\n        }\n          pw.println(ans);\n        }\n \n}\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nconst int MOD = 998244353;\nint n;\nint a[100005];\nint dp[100005][205][2];\nint pref[205], suff[205];\nint add(int x, int y) { return (x + y) % MOD; }\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0), cout.tie(0);\n  cin >> n;\n  for (int i = 1; i <= n; ++i) {\n    cin >> a[i];\n  }\n  for (int i = 0; i <= 200; ++i) {\n    pref[i] = 1;\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (a[i] == -1) {\n      for (int x = 1; x <= 200; ++x) {\n        dp[i][x][0] = pref[x - 1];\n        dp[i][x][1] = add(suff[x], dp[i - 1][x][0]);\n      }\n    } else {\n      dp[i][a[i]][0] = pref[a[i] - 1];\n      dp[i][a[i]][1] = add(suff[a[i]], dp[i - 1][a[i]][0]);\n    }\n    pref[0] = 0;\n    for (int x = 1; x <= 200; ++x) {\n      pref[x] = add(pref[x - 1], add(dp[i][x][0], dp[i][x][1]));\n    }\n    for (int x = 200; x > 0; --x) {\n      suff[x] = add(suff[x + 1], dp[i][x][1]);\n    }\n  }\n  int ans = 0;\n  for (int x = 1; x <= 200; ++x) {\n    ans = add(ans, dp[n][x][1]);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool is_prime(long long n) {\n  if (n <= 1) {\n    return false;\n  }\n  for (long long i = 2; i * i <= n; ++i) {\n    if (n % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\ninline long long getPow(long long a, long long b) {\n  long long res = 1ll, tp = a;\n  while (b) {\n    if (b & 1ll) {\n      res *= tp;\n    }\n    tp *= tp;\n    b >>= 1ll;\n  }\n  return res;\n}\nlong long coso(long long x1, long long y1, long long x2, long long y2,\n               long long x3, long long y3) {\n  return abs((x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1));\n}\ninline long long nxt() {\n  long long x;\n  cin >> x;\n  return x;\n}\nvoid ok() {\n  puts(\"YES\");\n  exit(0);\n}\nvoid no() {\n  puts(\"NO\");\n  exit(0);\n}\nconst long long N = 1e6 + 5;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long n;\n  cin >> n;\n  vector<long long> mas(n);\n  for (int i = 0; i < n; i++) {\n    cin >> mas[i];\n  }\n  vector<vector<long long>> dp(200 + 5, vector<long long>(2, 0LL));\n  if (mas[0] == -1) {\n    for (int i = 1; i <= 200; i++) {\n      dp[i][1] = 1;\n    }\n  } else\n    dp[mas[0]][1] = 1;\n  for (int i = 1; i < n; i++) {\n    long long cur = 0;\n    vector<vector<long long>> dp2(200 + 5, vector<long long>(2, 0LL));\n    for (int j = 1; j <= 200; j++) {\n      dp2[j][1] = cur;\n      cur = (cur + dp[j][0] + dp[j][1]);\n      while (cur > 998244353) {\n        cur -= 998244353;\n      }\n    }\n    cur = 0;\n    for (int j = 200; j >= 1; j--) {\n      dp2[j][0] =\n          ((dp2[j][0] + dp[j][0] + dp[j][1]) % 998244353 + cur) % 998244353;\n      while (dp2[j][0] > 998244353) {\n        dp2[j][0] -= 998244353;\n      }\n      cur = (cur + dp[j][0]);\n      while (cur > 998244353) {\n        cur -= 998244353;\n      }\n    }\n    for (int j = 1; j <= 200; j++) {\n      if (mas[i] != -1 && mas[i] != j) {\n        dp2[j][0] = dp2[j][1] = 0;\n      }\n    }\n    dp = dp2;\n  }\n  long long ans = 0LL;\n  for (int i = 1; i <= 200; i++) {\n    ans += dp[i][0];\n  }\n  cout << ans % 998244353;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 9, M = 998244353;\nint dp[2][205][2], n, a[N];\nlong long sum[2][205][2];\nint f(int i, int x, int z) {\n  if (a[i] > 0 && x != a[i]) return dp[i % 2][x][z] = 0;\n  if (i == n - 1) return dp[i % 2][x][z] = z;\n  long long ans = 0, l = 0, r = 200;\n  i %= 2;\n  ans = z * (sum[1 - i][x - 1][1] - sum[1 - i][l][1]) % M + dp[1 - i][x][1] +\n        (sum[1 - i][r][0] - sum[1 - i][x][0]) % M + 2 * M;\n  return dp[i][x][z] = ans % M;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long i, j;\n  cin >> n;\n  for (i = 0; i < n; i++) cin >> a[i];\n  for (i = n - 1; i >= 0; i--)\n    for (j = 1; j < 201; j++) {\n      sum[i % 2][j][0] = f(i, j, 0) + sum[i % 2][j - 1][0];\n      sum[i % 2][j][1] = f(i, j, 1) + sum[i % 2][j - 1][1];\n    }\n  cout << sum[0][200][0] % M << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool is_prime(long long n) {\n  if (n <= 1) {\n    return false;\n  }\n  for (long long i = 2; i * i <= n; ++i) {\n    if (n % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\ninline long long getPow(long long a, long long b) {\n  long long res = 1ll, tp = a;\n  while (b) {\n    if (b & 1ll) {\n      res *= tp;\n    }\n    tp *= tp;\n    b >>= 1ll;\n  }\n  return res;\n}\nlong long coso(long long x1, long long y1, long long x2, long long y2,\n               long long x3, long long y3) {\n  return abs((x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1));\n}\ninline long long nxt() {\n  long long x;\n  cin >> x;\n  return x;\n}\nvoid ok() {\n  puts(\"YES\");\n  exit(0);\n}\nvoid no() {\n  puts(\"NO\");\n  exit(0);\n}\nconst long long N = 1e6 + 5;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long n = nxt();\n  vector<long long> mas(n);\n  for (int i = 0; i < n; i++) {\n    mas[i] = nxt();\n  }\n  long long dp[210][2];\n  memset(dp, 0, sizeof(dp));\n  if (mas[0] == -1) {\n    for (int i = 1; i <= 200; i++) {\n      dp[i][1] = 1;\n    }\n  } else\n    dp[mas[0]][1] = 1;\n  for (int i = 1; i < n; i++) {\n    long long cur = 0;\n    long long dp2[210][2];\n    memset(dp2, 0, sizeof(dp2));\n    for (int j = 1; j <= 200; j++) {\n      dp2[j][1] = cur;\n      cur = (cur + dp[j][0] + dp[j][1]);\n      if (cur > 998244353) {\n        cur %= 998244353;\n      }\n    }\n    cur = 0;\n    for (int j = 200; j >= 1; j--) {\n      dp2[j][0] = ((dp2[j][0] + dp[j][0] + dp[j][1]) + cur);\n      if (dp2[j][0] > 998244353) {\n        dp2[j][0] %= 998244353;\n      }\n      cur = (cur + dp[j][0]);\n      if (cur > 998244353) {\n        cur %= 998244353;\n      }\n    }\n    for (int j = 1; j <= 200; j++) {\n      if (mas[i] != -1 && mas[i] != j) {\n        dp2[j][0] = dp2[j][1] = 0;\n      }\n    }\n    memcpy(dp, dp2, sizeof(dp));\n  }\n  long long ans = 0LL;\n  for (int i = 1; i <= 200; i++) {\n    ans += dp[i][0];\n  }\n  cout << ans % 998244353;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 100;\nconst long long MOD = 998244353;\nconst int L = 201;\nlong long stab(long long a) { return (((a % MOD) + MOD) % MOD); }\nint main() {\n  ios::sync_with_stdio(false);\n  cout.tie(0);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  long long mas[MAXN];\n  long long dp0[2][L];\n  long long dp1[2][L];\n  for (int i = 0; i < n; ++i) {\n    cin >> mas[i];\n  }\n  fill(dp0[0], dp0[0] + L, 0);\n  fill(dp0[1], dp0[1] + L, 0);\n  fill(dp1[0], dp1[0] + L, 0);\n  fill(dp1[1], dp1[1] + L, 0);\n  if (mas[0] == -1) {\n    fill(dp0[0], dp0[0] + L, 1);\n  } else {\n    dp0[0][mas[0]] = 1;\n  }\n  for (int i = 1; i < n; ++i) {\n    if (mas[i] == -1) {\n      mas[i] = L - 1;\n      for (int l = 1; l < mas[i]; ++l) {\n        dp1[0][mas[i]] += dp0[0][l] + dp0[1][l];\n      }\n      dp1[1][mas[i]] += dp0[0][mas[i]];\n      for (int l = mas[i]; l < L; ++l) {\n        dp1[1][mas[i]] += dp0[1][l];\n      }\n      dp1[0][mas[i]] = stab(dp1[0][mas[i]]);\n      dp1[1][mas[i]] = stab(dp1[1][mas[i]]);\n      for (int l = mas[i] - 1; l >= 1; --l) {\n        dp1[0][l] = stab(dp1[0][l + 1] - dp0[0][l] - dp0[1][l]);\n        dp1[1][l] = stab(dp1[1][l + 1] - dp0[0][l + 1] + dp0[0][l] + dp0[1][l]);\n      }\n    } else {\n      for (int l = 1; l < mas[i]; ++l) {\n        dp1[0][mas[i]] += dp0[0][l] + dp0[1][l];\n      }\n      dp1[1][mas[i]] += dp0[0][mas[i]];\n      for (int l = mas[i]; l < L; ++l) {\n        dp1[1][mas[i]] += dp0[1][l];\n      }\n      dp1[0][mas[i]] = stab(dp1[0][mas[i]]);\n      dp1[1][mas[i]] = stab(dp1[1][mas[i]]);\n    }\n    swap(dp1, dp0);\n    fill(dp1[0], dp1[0] + L, 0);\n    fill(dp1[1], dp1[1] + L, 0);\n  }\n  long long ans = 0;\n  for (int i = 1; i < L; ++i) {\n    ans += dp0[1][i];\n  }\n  cout << stab(ans) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from math import trunc\n\nMX = 201\nMOD = 998244353\nMODF = MOD * 1.0\n\nquickmod = lambda x: x - MODF * trunc(x / MODF)\n\n\ndef main():\n    n = int(input())\n    a = map(int, input().split())\n\n    dp0 = [1.0] * MX\n    dp1 = [0.0] * MX\n\n    for x in a:\n        pomdp0 = [0.0] * MX\n        pomdp1 = [0.0] * MX\n        if x == -1:\n            for val in range(1, MX):\n                pomdp0[val] = quickmod(\n                    pomdp0[val - 1] + dp1[val - 1] + dp0[val - 1])\n                pomdp1[val] = quickmod(\n                    pomdp1[val - 1] + dp1[MX - 1] - dp1[val - 1] + dp0[val] -\n                    dp0[val - 1])\n        else:\n            pomdp0[x] = quickmod(dp1[x - 1] + dp0[x - 1])\n            pomdp1[x] = quickmod(dp1[MX - 1] - dp1[x - 1] + dp0[x] - dp0[x - 1])\n            for val in range(x + 1, MX):\n                pomdp0[val] = pomdp0[val - 1]\n                pomdp1[val] = pomdp1[val - 1]\n\n        dp0, dp1 = pomdp0, pomdp1\n\n    print(int(dp1[MX - 1] if n > 1 else dp0[MX - 1]) % MOD)\n\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint amount, moder = 998244353;\nint numbers[100005];\nint big = 1, no_small = 0;\nint dif_arr[100005][205][3];\nint sums_dif[100005][3];\nvoid solve() {\n  if (numbers[1] == -1) {\n    for (int i = 1; i <= 200; i++) dif_arr[1][i][big] = 1, sums_dif[i][big] = i;\n  } else {\n    dif_arr[1][numbers[1]][big] = 1;\n    for (int i = numbers[1]; i <= 200; i++) sums_dif[i][big] = 1;\n  }\n  for (int i = 2; i <= amount; i++) {\n    int tail = 1, head = 200;\n    if (numbers[i] != -1) tail = numbers[i], head = numbers[i];\n    for (int j = tail; j <= head; j++) {\n      dif_arr[i][j][big] =\n          (sums_dif[j - 1][big] + sums_dif[j - 1][no_small]) % moder;\n      dif_arr[i][j][no_small] =\n          ((sums_dif[200][no_small] - sums_dif[j - 1][no_small] + moder) %\n               moder +\n           dif_arr[i - 1][j][big]) %\n          moder;\n    }\n    for (int j = 1; j <= 200; j++) {\n      sums_dif[j][big] = (sums_dif[j - 1][big] + dif_arr[i][j][big]) % moder;\n      sums_dif[j][no_small] =\n          (sums_dif[j - 1][no_small] + dif_arr[i][j][no_small]) % moder;\n    }\n  }\n  printf(\"%d\", sums_dif[200][no_small] % moder);\n}\nint main() {\n  scanf(\"%d\", &amount);\n  for (int i = 1; i <= amount; i++) scanf(\"%d\", &numbers[i]);\n  solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 998244353;\nconst int MAXN = 100000;\nconst int MAXV = 200;\nint dp[MAXN + 5][MAXV + 5][3];\nint prefixUp[MAXV + 5][3], prefixDown[MAXV + 5][3];\nbool valid(vector<int> &a, int i, int val) {\n  if (a[i] == -1)\n    return true;\n  else\n    return a[i] == val;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  memset(dp, 0, sizeof(dp));\n  for (int curr = 1; curr <= MAXV; curr++)\n    if (valid(a, 0, curr)) dp[0][curr][0] = 1;\n  for (int i = 1; i < n; i++) {\n    for (int curr = MAXV; curr >= 1; curr--) {\n      for (int t = 0; t < 3; t++)\n        prefixUp[curr][t] =\n            curr == MAXV\n                ? 0\n                : (prefixUp[curr + 1][t] + dp[i - 1][curr + 1][t]) % MOD;\n    }\n    for (int curr = 1; curr <= MAXV; curr++) {\n      for (int t = 0; t < 3; t++)\n        prefixDown[curr][t] =\n            curr == 1\n                ? 0\n                : (prefixDown[curr - 1][t] + dp[i - 1][curr - 1][t]) % MOD;\n    }\n    for (int curr = 1; curr <= MAXV; curr++)\n      if (valid(a, i, curr)) {\n        for (int t = 0; t <= 2; t++) {\n          dp[i][curr][0] += prefixDown[curr][t];\n          dp[i][curr][0] %= MOD;\n        }\n        for (int t = 1; t <= 2; t++) {\n          dp[i][curr][2] += prefixUp[curr][t];\n          dp[i][curr][2] %= MOD;\n        }\n        for (int t = 0; t <= 2; t++) {\n          dp[i][curr][1] += dp[i - 1][curr][t];\n          dp[i][curr][1] %= MOD;\n        }\n      }\n  }\n  int sol = 0;\n  for (int curr = 1; curr <= MAXV; curr++)\n    if (valid(a, n - 1, curr)) {\n      sol += (dp[n - 1][curr][1] + dp[n - 1][curr][2]) % MOD;\n      sol %= MOD;\n    }\n  cout << sol << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 998244353;\nconst int MAXN = 100000;\nconst int MAXV = 200;\nint dp[MAXN + 5][MAXV + 5][3];\nint prefixUp[MAXV + 5][3], prefixDown[MAXV + 5][3];\nbool valid(vector<int> &a, int i, int val) {\n  if (a[i] == -1)\n    return true;\n  else\n    return a[i] == val;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  memset(dp, 0, sizeof(dp));\n  for (int curr = 1; curr <= 200; curr++)\n    if (valid(a, 0, curr)) dp[0][curr][0] = 1;\n  for (int i = 1; i < n; i++) {\n    for (int curr = 200; curr >= 1; curr--) {\n      for (int t = 0; t < 3; t++) {\n        prefixUp[curr][t] =\n            curr == 200\n                ? 0\n                : (prefixUp[curr + 1][t] + dp[i - 1][curr + 1][t]) % MOD;\n      }\n    }\n    for (int curr = 1; curr <= 200; curr++) {\n      for (int t = 0; t < 3; t++) {\n        prefixDown[curr][t] =\n            curr == 1\n                ? 0\n                : (prefixDown[curr - 1][t] + dp[i - 1][curr - 1][t]) % MOD;\n      }\n    }\n    for (int curr = 1; curr <= 200; curr++)\n      if (valid(a, i, curr)) {\n        for (int t = 0; t <= 2; t++) {\n          dp[i][curr][0] += prefixDown[curr][t];\n          dp[i][curr][0] %= MOD;\n        }\n        for (int t = 1; t <= 2; t++) {\n          dp[i][curr][2] += prefixUp[curr][t];\n          dp[i][curr][2] %= MOD;\n        }\n        for (int t = 0; t <= 2; t++) {\n          dp[i][curr][1] += dp[i - 1][curr][t];\n          dp[i][curr][1] %= MOD;\n        }\n      }\n  }\n  int sol = 0;\n  for (int curr = 1; curr <= 200; curr++)\n    if (valid(a, n - 1, curr)) {\n      sol += (dp[n - 1][curr][1] + dp[n - 1][curr][2]) % MOD;\n      sol %= MOD;\n    }\n  cout << sol << '\\n';\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class H {\n\n\tstatic int n, a[];\n\tstatic int MOD = 998244353;\n\t\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tn = sc.nextInt();\n\t\t\n\t\ta = new int[n];\n\t\tfor (int i = 0; i < n; i++) \n\t\t\ta[i] = sc.nextInt();\n\t\tint curr=0;\n\t\tlong [][][]cum=new long [2][201][2];\n\t\tfor(int idx=n-1;idx>0;idx--)\n\t\t{\n\t\t\t\n\t\t\tint x=a[idx];\n\t\t\tfor(int f=0;f<=1;f++)\n\t\t\t{\n\t\t\t\tint sum=0;\n\t\t\t\tfor(int last=1;last<=200;last++)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tlong ans=0;\n\t\t\t\t\tif(f==0)\n\t\t\t\t\t{\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(x==-1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(idx==n-1)\n\t\t\t\t\t\t\t\tans=last;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tans=cum[1-curr][last][0]+cum[1-curr][200][1]-cum[1-curr][last][1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(idx==n-1)\n\t\t\t\t\t\t\t\tans=x<=last?1:0;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tans=cum[1-curr][x][x<=last?0:1]-cum[1-curr][x-1][x<=last?0:1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(x==-1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(idx==n-1)\n\t\t\t\t\t\t\t\tans=1;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tans=cum[1-curr][last][0]-cum[1-curr][last-1][0]+cum[1-curr][200][1]-cum[1-curr][last][1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(x>=last) {\n\t\t\t\t\t\t\tif(idx==n-1)\n\t\t\t\t\t\t\t\tans=x==last?1:0;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tans=cum[1-curr][x][x<=last?0:1]-cum[1-curr][x-1][x<=last?0:1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\twhile(ans>=MOD)\n\t\t\t\t\t\tans-=MOD;\n\t\t\t\t\twhile(ans<0)\n\t\t\t\t\t\tans+=MOD;\n\t\t\t\t\tsum+=ans;\n\t\t\t\t\twhile(sum>=MOD)\n\t\t\t\t\t\tsum-=MOD;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tcum[curr][last][f]=sum;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurr=1-curr;\n\t\t}\n\t\tcurr=1-curr;\t\n\t\tlong ans=0;\n\t\tif(a[0]==-1)\n\t\t\t\n\t\t\t{\n\t\t\t\tans=cum[curr][200][1];\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\telse\n\t\t\tans=cum[curr][a[0]][1]-cum[curr][a[0]-1][1];\n\t\twhile(ans<0)\n\t\t\tans+=MOD;\t\t\n\t\tSystem.out.println(ans);\n\t\tout.close();\n\t}\n\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tString nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tdouble nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nusing min_heap = priority_queue<T, std::vector<T>, std::greater<T> >;\nconst int lim = 1e5 + 5;\nlong long dp[202][3], s[202][3];\nlong long n, a[lim], ans = 0, MOD = 998244353;\nvoid mymod(long long &x) {\n  x %= MOD;\n  x += MOD;\n  x %= MOD;\n}\nint main() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  for (int k = 1; k <= 200; k++) {\n    if (a[1] == -1 || a[1] == k) {\n      dp[k][1] = 1;\n    }\n    s[k][1] = s[k - 1][1] + dp[k][1];\n  }\n  for (int i = 2; i <= n; i++) {\n    for (int k = 1; k <= 200; k++) {\n      if (a[i] == -1 || a[i] == k) {\n        dp[k][0] = dp[k][0] + dp[k][1] + s[200][0] - s[k][0];\n        mymod(dp[k][0]);\n        dp[k][1] = s[k - 1][0] + s[k - 1][1];\n        mymod(dp[k][1]);\n      } else {\n        dp[k][0] = 0;\n        dp[k][1] = 0;\n      }\n    }\n    for (int k = 1; k <= 200; k++) {\n      s[k][0] = s[k - 1][0] + dp[k][0];\n      mymod(s[k][0]);\n      s[k][1] = s[k - 1][1] + dp[k][1];\n      mymod(s[k][1]);\n    }\n  }\n  ans = s[200][0];\n  ans %= MOD;\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "/*\nKeep solving problems.\n*/\n\nimport java.util.*;\nimport java.io.*;\n\npublic class CFA {\n    BufferedReader br;\n    PrintWriter out;\n    StringTokenizer st;\n    boolean eof;\n    private static final long MOD = 998244353L;\n    private static final int[] dx = {0, -1, 0, 1};\n    private static final int[] dy = {1, 0, -1, 0};\n    private static final String yes = \"Yes\";\n    private static final String no = \"No\";\n\n    int n;\n    int[] arr;\n    long[][] dp;\n    long[][] pref;\n    int limit = 205;\n    void solve() throws IOException {\n        n = nextInt();\n        arr = nextIntArr(n);\n\n        dp = new long[2][limit];\n        pref = new long[2][limit];\n        dp[1][1] = 1;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < limit; j++) {\n                for (int k = 0; k < 2; k++) {\n                    if (dp[k][j] == 0) {\n                        continue;\n                    }\n\n                    if (arr[i] == -1) {\n                        if (k == 1) {\n                            addRange(j + 1, 200, 0, dp[k][j]); //[j + 1, 200]\n                            addRange(1, j, 1, dp[k][j]); //[1, j]\n                        }\n                        else {\n                            addRange(j + 1, 200, 0, dp[k][j]); //[j + 1, 200]\n                            addRange(j, j, 1, dp[k][j]); //[j, j]\n                        }\n                    }\n                    else {\n                        int nj = arr[i];\n                        if (k == 1) {\n                            if (nj > j) {\n                                addRange(nj, nj, 0, dp[k][j]); //[nj, nj]\n                            }\n                            else {\n                                addRange(nj, nj, 1, dp[k][j]); //[nj, nj]\n                            }\n                        }\n                        else {\n                            if (nj > j) {\n                                addRange(nj, nj, 0, dp[k][j]); //[nj, nj]\n                            }\n                            else if (nj == j){\n                                addRange(nj, nj, 1, dp[k][j]); //[nj, nj]\n                            }\n                        }\n                    }\n                }\n            }\n\n            calcPref();\n        }\n\n        long res = 0;\n        for (int j = 0; j < limit; j++) {\n            res = add(res, dp[1][j]);\n        }\n\n        outln(res);\n    }\n\n    void addRange(int start, int end, int parity, long val) {\n        pref[parity][start] = add(pref[parity][start], val);\n        pref[parity][end + 1] = add(pref[parity][end + 1], -val);\n    }\n\n    void calcPref() {\n        for (int j = 1; j < limit; j++) {\n            pref[0][j] = add(pref[0][j], pref[0][j - 1]);\n            dp[0][j] = pref[0][j];\n            pref[1][j] = add(pref[1][j], pref[1][j - 1]);\n            dp[1][j] = pref[1][j];\n        }\n\n        for (int j = 0; j < limit; j++) {\n            pref[0][j] = 0;\n            pref[1][j] = 0;\n        }\n    }\n\n    long add(long a, long b) {\n        long res = a + b;\n        if (res >= MOD) {\n            res -= MOD;\n        }\n        if (res < 0) {\n            res += MOD;\n        }\n        return res;\n    }\n\n    void shuffle(int[] a) {\n        int n = a.length;\n        for(int i = 0; i < n; i++) {\n            int r = i + (int) (Math.random() * (n - i));\n            int tmp = a[i];\n            a[i] = a[r];\n            a[r] = tmp;\n        }\n    }\n    long gcd(long a, long b) {\n        while(a != 0 && b != 0) {\n            long c = b;\n            b = a % b;\n            a = c;\n        }\n        return a + b;\n    }\n    private void outln(Object o) {\n        out.println(o);\n    }\n    private void out(Object o) {\n        out.print(o);\n    }\n    private void formatPrint(double val) {\n        outln(String.format(\"%.9f%n\", val));\n    }\n    public CFA() throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n    public static void main(String[] args) throws IOException {\n        new CFA();\n    }\n\n    public long[] nextLongArr(int n) throws IOException{\n        long[] res = new long[n];\n        for(int i = 0; i < n; i++)\n            res[i] = nextLong();\n        return res;\n    }\n    public int[] nextIntArr(int n) throws IOException {\n        int[] res = new int[n];\n        for(int i = 0; i < n; i++)\n            res[i] = nextInt();\n        return res;\n    }\n    public String nextToken() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                eof = true;\n                return null;\n            }\n        }\n        return st.nextToken();\n    }\n    public String nextString() {\n        try {\n            return br.readLine();\n        } catch (IOException e) {\n            eof = true;\n            return null;\n        }\n    }\n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n    public long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n    public double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double PI = acos(-1);\nconst double eps = 1e-12;\nconst int inf = 2000000000;\nconst long long int infLL = (long long int)2e18;\nlong long int MOD = 998244353;\nint MOD1 = 1000000007;\nint MOD2 = 1000000009;\ninline bool checkBit(long long int n, long long int i) {\n  return n & (1LL << i);\n}\ninline long long int setBit(long long int n, long long int i) {\n  return n | (1LL << i);\n  ;\n}\ninline long long int resetBit(long long int n, long long int i) {\n  return n & (~(1LL << i));\n}\nint dx[] = {0, 0, +1, -1};\nint dy[] = {+1, -1, 0, 0};\ninline bool EQ(double a, double b) { return fabs(a - b) < 1e-9; }\ninline bool isLeapYear(long long int year) {\n  return (year % 400 == 0) || (year % 4 == 0 && year % 100 != 0);\n}\ninline void normal(long long int &a) {\n  a %= MOD;\n  (a < 0) && (a += MOD);\n}\ninline long long int modMul(long long int a, long long int b) {\n  a %= MOD, b %= MOD;\n  normal(a), normal(b);\n  return (a * b) % MOD;\n}\ninline long long int modAdd(long long int a, long long int b) {\n  a %= MOD, b %= MOD;\n  normal(a), normal(b);\n  return (a + b) % MOD;\n}\ninline long long int modSub(long long int a, long long int b) {\n  a %= MOD, b %= MOD;\n  normal(a), normal(b);\n  a -= b;\n  normal(a);\n  return a;\n}\ninline long long int modPow(long long int b, long long int p) {\n  long long int r = 1LL;\n  while (p) {\n    if (p & 1) r = modMul(r, b);\n    b = modMul(b, b);\n    p >>= 1LL;\n  }\n  return r;\n}\ninline long long int modDiv(long long int a, long long int b) {\n  return modMul(a, modPow(b, MOD - 2));\n}\nbool comp(const pair<long long int, pair<long long int, long long int> > &p1,\n          const pair<long long int, pair<long long int, long long int> > &p2) {\n  return p1.first > p2.first;\n}\nbool comp1(const pair<long long int, long long int> &p1,\n           const pair<long long int, long long int> &p2) {\n  if (p1.first == p2.first) {\n    return p1.second > p2.second;\n  }\n  return p1.first < p2.first;\n}\nlong long int converter(string a) {\n  long long int i, mul = 1, r, t, ans = 0LL;\n  if (a.length() == 0) return 0;\n  for (i = a.length() - 1; i >= 0; i--) {\n    t = a[i] - '0';\n    r = t % 10;\n    ans += (mul * r);\n    mul = mul * 10;\n  }\n  return ans;\n}\nint msb(unsigned x) {\n  union {\n    double a;\n    int b[2];\n  };\n  a = x;\n  return (b[1] >> 20) - 1023;\n}\nconst int MAX = (int)1e5 + 1;\nint a[MAX];\nlong long int dp[2][201], sum[2][201];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  int n, i, j, ok;\n  cin >> n;\n  for (i = 1; i <= n; ++i) cin >> a[i];\n  if (a[1] == -1) {\n    for (i = 1; i <= 200; ++i) {\n      dp[0][i] = 1;\n      sum[0][i] = 1;\n    }\n  } else {\n    dp[0][a[1]] = 1;\n    sum[0][a[1]] = 1;\n  }\n  for (i = 1; i <= 200; ++i) {\n    sum[0][i] += sum[0][i - 1];\n    sum[1][i] += sum[1][i - 1];\n  }\n  for (i = 2; i <= n; ++i) {\n    for (j = 1; j <= 200; ++j) {\n      dp[0][j] = (sum[1][j - 1] + sum[0][j - 1]);\n      dp[1][j] = (sum[1][200] - sum[1][j - 1] + MOD) +\n                 (sum[0][j] - sum[0][j - 1] + MOD);\n      dp[0][j] %= MOD;\n      dp[1][j] %= MOD;\n    }\n    memset(sum, 0, sizeof(sum));\n    for (j = 1; j <= 200; ++j) {\n      if (a[i] == -1 || a[i] == j) {\n        sum[0][j] = dp[0][j];\n        sum[1][j] = dp[1][j];\n      } else {\n        dp[0][j] = 0;\n        dp[1][j] = 0;\n      }\n      sum[0][j] += sum[0][j - 1];\n      sum[1][j] += sum[1][j - 1];\n      sum[0][j] %= MOD;\n      sum[1][j] %= MOD;\n    }\n  }\n  long long int ans = 0LL;\n  for (i = 1; i <= 200; ++i) {\n    ans += dp[1][i];\n    ans %= MOD;\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline long long power(long long a, long long b) {\n  long long x = 1;\n  a = a % 998244353LL;\n  while (b) {\n    if (b & 1) x = (x * a) % 998244353LL;\n    a = (a * a) % 998244353LL;\n    b >>= 1;\n  }\n  return x;\n}\ninline long long inv(long long a) { return power(a, 998244353LL - 2); }\nlong long gcd(long long a, long long b) { return a ? gcd(b % a, a) : b; }\nconst int N = 1e5 + 5;\nlong long dp[2][205][2];\nlong long n, a[N];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin >> n;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  if (n == 2) {\n    if (a[0] == a[1]) {\n      if (a[0] == -1)\n        cout << \"200\\n\";\n      else\n        cout << \"1\\n\";\n      return 0;\n    } else if (a[0] == -1 || a[1] == -1) {\n      cout << \"1\\n\";\n      return 0;\n    } else {\n      cout << \"0\\n\";\n      return 0;\n    }\n  }\n  if (a[0] != -1 && a[1] != -1) {\n    if (a[0] > a[1]) {\n      cout << \"0\\n\";\n      return 0;\n    }\n  }\n  if (a[n - 1] != -1 && a[n - 2] != -1) {\n    if (a[n - 1] > a[n - 2]) {\n      cout << \"0\\n\";\n      return 0;\n    }\n  }\n  for (int i = 1; i < n - 1; i++) {\n    if (a[i - 1] != -1 && a[i + 1] != -1 && a[i] != -1) {\n      if (max(a[i - 1], a[i + 1]) < a[i]) {\n        cout << \"0\\n\";\n        return 0;\n      }\n    }\n  }\n  if (a[0] != -1)\n    dp[0][a[0]][1] = 1;\n  else {\n    for (int i = 1; i <= 200; i++) dp[0][i][1] = 1;\n  }\n  for (int i = 1; i < n; i++) {\n    long long sum = 0, sum1 = 0;\n    for (int j = 1; j <= 200; j++) {\n      sum1 += (dp[0][j][1] + dp[0][j][0]);\n      sum += dp[0][j][0];\n      sum1 %= 998244353LL;\n      sum %= 998244353LL;\n    }\n    for (int j = 200; j > 0; j--) {\n      sum1 = (sum1 - dp[0][j][1] - dp[0][j][0] + 998244353LL + 998244353LL) %\n             998244353LL;\n      dp[1][j][1] = sum1;\n    }\n    for (int j = 1; j <= 200; j++) {\n      dp[1][j][0] = (sum + dp[0][j][1]) % 998244353LL;\n      sum = (sum + 998244353LL - dp[0][j][0]) % 998244353LL;\n    }\n    if (a[i] == -1) {\n      for (int j = 1; j <= 200; j++) {\n        dp[0][j][0] = dp[1][j][0];\n        dp[0][j][1] = dp[1][j][1];\n      }\n    } else {\n      for (int j = 1; j <= 200; j++) {\n        dp[0][j][0] = 0;\n        dp[0][j][1] = 0;\n      }\n      dp[0][a[i]][0] = dp[1][a[i]][0];\n      dp[0][a[i]][1] = dp[1][a[i]][1];\n    }\n    for (int j = 1; j <= 200; j++) {\n      dp[1][j][0] = 0;\n      dp[1][j][1] = 0;\n    }\n  }\n  long long ans = 0;\n  for (int j = 1; j <= 200; j++) {\n    ans += dp[0][j][0];\n    if (ans >= 998244353LL) ans -= 998244353LL;\n  }\n  ans %= 998244353LL;\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\nconst int maxn = 1e5 + 10, maxm = 205;\nint sum[2][2][maxm], dp[maxn][maxm][2];\ninline void _add(int& x, int y) {\n  x = ((x + y) >= mod ? (x + y - mod) : (x + y));\n}\nvoid add(int p1, int p2, int x, int v) {\n  for (int i = x; i < maxm; i += i & -i) _add(sum[p1][p2][i], v);\n}\nint que(int p1, int p2, int x) {\n  int ret = 0;\n  for (int i = x; i > 0; i -= i & -i) _add(ret, sum[p1][p2][i]);\n  return ret;\n}\nconst int up = 200;\nint n, a[maxn];\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  int now = 0, nxt = 1;\n  memset(dp, 0, sizeof(dp));\n  if (a[1] > 0)\n    dp[1][a[1]][0] = 1, add(now, 0, a[1], 1);\n  else\n    for (int i = 1; i <= up; i++) dp[1][i][0] = 1, add(now, 0, i, 1);\n  for (int i = 2; i <= n; i++) {\n    memset(sum[nxt], 0, sizeof(sum[nxt]));\n    int x = 1, y = up;\n    if (a[i] > 0) x = y = a[i];\n    for (int j = x; j <= y; j++) {\n      dp[i][j][0] = (que(now, 1, j - 1) + que(now, 0, j - 1)) % mod;\n      dp[i][j][1] = (que(now, 1, maxm - 1) - que(now, 1, j) + mod) % mod;\n      _add(dp[i][j][1], dp[i - 1][j][0]);\n      _add(dp[i][j][1], dp[i - 1][j][1]);\n      add(nxt, 0, j, dp[i][j][0]);\n      add(nxt, 1, j, dp[i][j][1]);\n    }\n    swap(now, nxt);\n  }\n  long long ans = 0;\n  for (int i = 1; i <= up; i++) ans = (ans + dp[n][i][1]) % mod;\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long dp[2][201][2];\nint f = 1;\nint a[100009];\nconst long long mod = 998244353;\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", a + i);\n  }\n  if (a[1] == -1) {\n    for (int i = 1; i <= 200; i++) dp[f][i][1] = 1;\n  } else\n    dp[f][a[1]][1] = 1;\n  for (int i = 2; i <= n; i++) {\n    if (a[i] != -1) {\n      int u = a[i];\n      for (int j = 1; j < u; j++) dp[!f][u][1] += dp[f][j][1] + dp[f][j][0];\n      dp[!f][u][0] += dp[f][u][1];\n      for (int j = u; j <= 200; j++) dp[!f][u][0] += dp[f][j][0];\n      dp[!f][u][0] %= mod;\n      dp[!f][u][1] %= mod;\n      memset(dp[f], 0, sizeof(dp[f]));\n      f = !f;\n    } else {\n      long long tmp[2][301];\n      memset(tmp, 0, sizeof(tmp));\n      for (int j = 1; j <= 200; j++) {\n        tmp[0][j] += dp[f][j][1];\n        tmp[0][j + 1] -= dp[f][j][1];\n        tmp[1][j + 1] += dp[f][j][1];\n        tmp[0][1] += dp[f][j][0];\n        tmp[0][j + 1] -= dp[f][j][0];\n        tmp[1][j + 1] += dp[f][j][0];\n      }\n      long long now0 = 0, now1 = 0;\n      for (int j = 1; j <= 200; j++) {\n        now0 += tmp[0][j];\n        now1 += tmp[1][j];\n        now0 %= mod, now1 %= mod;\n        dp[!f][j][0] = now0;\n        dp[!f][j][1] = now1;\n      }\n      memset(dp[f], 0, sizeof(dp[f]));\n      f = !f;\n    }\n  }\n  long long ans = 0;\n  for (int i = 1; i <= 200; i++) {\n    ans += dp[f][i][0];\n  }\n  ans = (ans % mod + mod) % mod;\n  printf(\"%I64d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 998244353;\nconst int MAXN = 100000;\nconst int MAXV = 200;\nint dp[MAXN + 5][MAXV + 5][3];\nint prefixUp[MAXV + 5][3], prefixDown[MAXV + 5][3];\nbool valid(vector<int> &a, int i, int val) {\n  if (a[i] == -1)\n    return true;\n  else\n    return a[i] == val;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  memset(dp, 0, sizeof(dp));\n  for (int curr = 1; curr <= MAXV; curr++)\n    if (valid(a, 0, curr)) dp[0][curr][0] = 1;\n  for (int i = 1; i < n; i++) {\n    for (int t = 0; t < 3; t++) {\n      prefixUp[MAXV][t] = 0;\n      for (int curr = MAXV - 1; curr >= 1; curr--) {\n        prefixUp[curr][t] =\n            (prefixUp[curr + 1][t] + dp[i - 1][curr + 1][t]) % MOD;\n      }\n    }\n    for (int t = 0; t < 3; t++) {\n      prefixDown[1][t] = 0;\n      for (int curr = 2; curr <= MAXV; curr++) {\n        prefixDown[curr][t] =\n            (prefixDown[curr - 1][t] + dp[i - 1][curr - 1][t]) % MOD;\n      }\n    }\n    for (int curr = 1; curr <= 200; curr++)\n      if (valid(a, i, curr)) {\n        for (int t = 0; t <= 2; t++) {\n          dp[i][curr][0] += prefixDown[curr][t];\n          dp[i][curr][0] %= MOD;\n        }\n        for (int t = 1; t <= 2; t++) {\n          dp[i][curr][2] += prefixUp[curr][t];\n          dp[i][curr][2] %= MOD;\n        }\n        for (int t = 0; t <= 2; t++) {\n          dp[i][curr][1] += dp[i - 1][curr][t];\n          dp[i][curr][1] %= MOD;\n        }\n      }\n  }\n  int sol = 0;\n  for (int curr = 1; curr <= 200; curr++)\n    if (valid(a, n - 1, curr)) {\n      sol += (dp[n - 1][curr][1] + dp[n - 1][curr][2]) % MOD;\n      sol %= MOD;\n    }\n  cout << sol << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:10000000000\")\nusing namespace std;\nconst int MOD = 1000000007;\nconst int INF = 1000000007LL;\nconst long long INF2 = 1000000007LL * 1000000007LL;\nconst long double EPS = 1e-9;\nconst int SIZE = 100100;\nmt19937 rng(time(0));\nuniform_int_distribution<int> uid(-1000000000, 1000000000);\nint n;\nint a[SIZE];\nint d[210][SIZE][2];\nconst long long md = 998244353;\nconst int val = 200;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n;\n  if (n == 1) {\n    cout << 0;\n    return 0;\n  }\n  for (int i = 1; i <= n; ++i) cin >> a[i];\n  for (int lst = 1; lst <= val; ++lst) {\n    if (a[n] == -1) {\n      d[lst][n][0] = lst;\n      d[lst][n][1] = 1;\n    } else {\n      d[lst][n][0] = (a[n] <= lst);\n      d[lst][n][1] = (a[n] == lst);\n    }\n  }\n  for (int i = n - 1; i >= 1; --i) {\n    if (a[i] != -1) {\n      for (int lst = 1; lst <= val; ++lst) {\n        d[lst][i][0] = d[a[i]][i + 1][lst < a[i]];\n      }\n      for (int lst = 1; lst <= a[i]; ++lst) {\n        d[lst][i][1] = d[a[i]][i + 1][lst < a[i]];\n      }\n      continue;\n    }\n    long long pref = 0, suff = 0;\n    for (int b = 1; b <= val; ++b) {\n      suff += d[b][i + 1][1];\n      suff %= md;\n    }\n    for (int lst = 1; lst <= val; ++lst) {\n      pref += d[lst][i + 1][0];\n      pref %= md;\n      suff += md - d[lst][i + 1][1];\n      suff %= md;\n      d[lst][i][0] = (pref + suff) % md;\n    }\n    suff = 0;\n    for (int lst = val; lst >= 1; --lst) {\n      d[lst][i][1] = (suff + d[lst][i + 1][0]) % md;\n      suff += d[lst][i + 1][1];\n      suff %= md;\n    }\n  }\n  cout << d[1][1][0];\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author prakharjain\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        int[][][] dp = new int[2][201][2];\n        int mod = 998244353;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n\n            int[] a = new int[n];\n\n            in.readArray(a, n, 0);\n\n//        if (n == 2) {\n//            if (a[0] == -1 && a[1] == -1) {\n//                out.println(200);\n//            } else if (a[0] == -1 || a[1] == -1) {\n//                out.println(1);\n//            } else {\n//                if (a[0] == a[1]) {\n//                    out.println(1);\n//                } else {\n//                    out.println(0);\n//                }\n//            }\n//\n//            return;\n//        }\n            int[][] cum = new int[201][2];\n\n\n            if (a[0] == -1) {\n                for (int i = 1; i <= 200; i++) {\n                    dp[0][i][0] = 1;\n                }\n            } else {\n                dp[0][a[0]][0] = 1;\n            }\n\n            cum[0][0] = dp[0][0][0];\n            for (int i = 1; i <= 200; i++) {\n                cum[i][0] = cum[i - 1][0] + dp[0][i][0];\n            }\n\n            for (int i = 1; i < n; i++) {\n                if (i > 1) {\n                    if (a[i] != -1) {\n\n                        int j = a[i];\n\n                        dp[1][j][1] = cum[j - 1][0] + cum[j - 1][1];\n\n                        dp[1][j][0] = remcum(j, cum, 0) + dp[0][j][1];\n\n                        dp[1][j][0] %= mod;\n                        dp[1][j][1] %= mod;\n                    } else {\n                        for (int j = 1; j <= 200; j++) {\n                            dp[1][j][1] = cum[j - 1][0] + cum[j - 1][1];\n\n                            dp[1][j][0] = remcum(j, cum, 0) + dp[0][j][1];\n\n                            dp[1][j][0] %= mod;\n                            dp[1][j][1] %= mod;\n                        }\n                    }\n                } else {\n                    if (a[i] != -1) {\n                        int j = a[i];\n\n                        dp[1][j][1] = cum[j - 1][0] + cum[j - 1][1];\n\n                        dp[1][j][0] = dp[0][j][0] + dp[0][j][1];\n\n                        dp[1][j][0] %= mod;\n                        dp[1][j][1] %= mod;\n                    } else {\n                        for (int j = 1; j <= 200; j++) {\n                            dp[1][j][1] = cum[j - 1][0] + cum[j - 1][1];\n\n                            dp[1][j][0] = dp[0][j][0] + dp[0][j][1];\n\n                            dp[1][j][0] %= mod;\n                            dp[1][j][1] %= mod;\n                        }\n                    }\n                }\n\n                cum[0][0] = dp[1][0][0];\n                cum[0][1] = dp[1][0][1];\n                for (int j = 1; j <= 200; j++) {\n                    cum[j][0] = cum[j - 1][0] + dp[1][j][0];\n                    cum[j][0] %= mod;\n                    cum[j][1] = cum[j - 1][1] + dp[1][j][1];\n                    cum[j][1] %= mod;\n                }\n\n                for (int j = 0; j <= 200; j++) {\n                    dp[0][j][0] = dp[1][j][0];\n                    dp[0][j][1] = dp[1][j][1];\n                }\n\n                for (int j = 0; j <= 200; j++) {\n                    dp[1][j][0] = dp[1][j][1] = 0;\n                }\n            }\n\n            long ans = cum[200][0];\n\n//        for (int i = 1; i <= 200; i++) {\n//            ans += dp[n - 1][i][0];\n//            ans += dp[n - 1][i][1];\n//\n//            ans %= mod;\n//        }\n\n            ans %= mod;\n\n            if (ans < 0) {\n                ans += mod;\n            }\n\n            out.println(ans);\n        }\n\n        int remcum(int s, int[][] cum, int o) {\n            int val = cum[200][o];\n\n            if (s > 1) {\n                val -= cum[s - 1][o];\n            }\n\n            val %= mod;\n\n            return val;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public void readArray(int[] a, int n, int offset) {\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt() - offset;\n            }\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.PrintStream;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Wolfgang Beyer\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        long MODUL = 998244353L;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] a = in.readIntArray(n);\n//        long result = 1;\n\n            long[] nonMax = new long[201];\n            long[] stillMax = new long[201];\n            for (int i = 1; i <= 200; i++) {\n                if (a[0] > 0) {\n                    if (a[0] == i) {\n                        stillMax[i] = 1;\n                    }\n                } else {\n                    stillMax[i] = 1;\n                }\n            }\n\n            for (int i = 1; i < n; i++) {\n                long[] newNonMax = new long[201];\n                long[] newStillMax = new long[201];\n                if (a[i] > 0) {\n                    int val = a[i];\n                    newNonMax[val] = stillMax[val];\n                    for (int j = val; j <= 200; j++) {\n                        newNonMax[val] += nonMax[j];\n                        newNonMax[val] %= MODUL;\n                    }\n                    for (int j = 1; j < val; j++) {\n                        newStillMax[val] += nonMax[j] + stillMax[j];\n                        newStillMax[val] %= MODUL;\n                    }\n\n                } else {\n                    long sumNonMax = 0;\n                    for (int j = 1; j <= 200; j++) sumNonMax += nonMax[j];\n//                sumNonMax %= MODUL;\n                    for (int j = 1; j <= 200; j++) {\n                        newNonMax[j] = (stillMax[j] + sumNonMax) % MODUL;\n                        sumNonMax -= nonMax[j];\n                        newStillMax[j] = (newStillMax[j - 1] + nonMax[j - 1] + stillMax[j - 1]) % MODUL;\n                    }\n\n                }\n                nonMax = newNonMax;\n                stillMax = newStillMax;\n            }\n\n            if (a[n - 1] > 0) {\n                out.println(nonMax[a[n - 1]]);\n            } else {\n                long result = 0;\n                for (int i = 1; i <= 200; i++) {\n                    result += nonMax[i];\n                }\n                result %= MODUL;\n                out.println(result);\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private static BufferedReader in;\n        private static StringTokenizer tok;\n\n        public InputReader(InputStream in) {\n            this.in = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public int[] readIntArray(int n) {\n            int[] ar = new int[n];\n            for (int i = 0; i < n; i++) {\n                ar[i] = nextInt();\n            }\n            return ar;\n        }\n\n        public String next() {\n            try {\n                while (tok == null || !tok.hasMoreTokens()) {\n                    tok = new StringTokenizer(in.readLine());\n                    //tok = new StringTokenizer(in.readLine(), \", \\t\\n\\r\\f\"); //adds commas as delimeter\n                }\n            } catch (IOException ex) {\n                System.err.println(\"An IOException was caught :\" + ex.getMessage());\n            }\n            return tok.nextToken();\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\n\npublic class Main {\n\n\tstatic class Task {\n\t\t\n\t\tint NN = 300005;\n\t\tint MOD = 1000000007;\n\t\tint INF = 2009000000;\n\t\tlong INFINITY = 2000000000000000000L;\n\t\t\n\t\tint [] a;\n\t\tint n;\n\t\t\n\t\tlong [][]dp;\n\t\tlong [][]dp1;\n\t\tlong [][]sum1;\n\t\t\n\t\tpublic void solve(InputReader in, PrintWriter out) {\n\t\t\tn = in.nextInt();\n\t\t\ta = new int[n];\n\t\t\tdp = new long [201][2];\n\t\t\tdp1 = new long [201][2];\n\t\t\tsum1 = new long [201][2];\n\t\t\tfor(int i=0;i<n;++i)\n\t\t\t\ta[i] = in.nextInt();\n\t\t\tfor(int i=n-1;i>=1;--i) {\n\t\t\t\tfor(int p=1;p<=200;++p) {\n\t\t\t\t\tfor(int f=0;f<2;++f) {\n\t\t\t\t\t\tif(i == n - 1) {\n\t\t\t\t\t\t\tif(a[i] == -1) {\n\t\t\t\t\t\t\t\tif(f == 0)\n\t\t\t\t\t\t\t\t\tdp[p][f] = 1;\n\t\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\t\tdp[p][f] = p;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif(f==1)\n\t\t\t\t\t\t\t\t\tdp[p][f] = a[i] <= p ? 1: 0;\n\t\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\t\tdp[p][f] = (a[i]==p ? 1: 0);\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(f == 0) {\n\t\t\t\t\t\t\t\tif(a[i] != -1) {\n\t\t\t\t\t\t\t\t\tif(a[i] < p)\n\t\t\t\t\t\t\t\t\t\tdp[p][f] = 0;\n\t\t\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\t\t\tdp[p][f] = dp1[a[i]][a[i]==p?1:0];\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tdp[p][f] = (dp1[p][1] + \n\t\t\t\t\t\t\t\t\t\t\t1L*(sum1[200][0]\n\t\t\t\t\t\t\t\t\t\t\t\t-sum1[p-1][0]-dp1[p][0]\n\t\t\t\t\t\t\t\t\t\t\t\t+ 998244353L + 998244353L))%998244353;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif(a[i] != -1) {\n\t\t\t\t\t\t\t\t\tdp[p][f] = dp1[a[i]][a[i]<=p?1:0];\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tdp[p][f] = (sum1[p][1] + \n\t\t\t\t\t\t\t\t\t\t\t1L*(sum1[200][0]-sum1[p][0] + 998244353L))%998244353;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int p=1;p<=200;++p) {\n\t\t\t\t\tfor(int f=0;f<2;++f) {\n\t\t\t\t\t\tdp1[p][f] = dp[p][f];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsum1[0][0] = sum1[0][1] = 0;\n\t\t\t\tfor(int f=0;f<2;++f) {\n\t\t\t\t\tfor(int p=1;p<=200;++p) {\n\t\t\t\t\t\tsum1[p][f] = (sum1[p-1][f] + dp1[p][f])%998244353;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(a[0] != -1) {\n\t\t\t\tout.println(dp[a[0]][0]);\t\n\t\t\t} else {\n\t\t\t\tlong ans = 0;\n\t\t\t\tfor(int i=1;i<=200;++i) {\n\t\t\t\t\tans = (ans + dp[i][0])%998244353;\n\t\t\t\t}\n\t\t\t\tout.println(ans);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tstatic void prepareIO(boolean isFileIO) {\n\t\t//long t1 = System.currentTimeMillis();\n\t\tTask solver = new Task();\n\t\t// Standard IO\n\t\tif(!isFileIO) { \n\t\t\tInputStream inputStream = System.in;\n\t        OutputStream outputStream = System.out;\n\t        InputReader in = new InputReader(inputStream);\n\t        PrintWriter out = new PrintWriter(outputStream);\n\t        solver.solve(in, out);\n\t        //out.println(\"time(s): \" + (1.0*(System.currentTimeMillis()-t1))/1000.0);\n\t        out.close();\n\t\t}\n        // File IO\n\t\telse {\n\t\t\tString IPfilePath = System.getProperty(\"user.home\") + \"/Downloads/ip.in\";\n\t        String OPfilePath = System.getProperty(\"user.home\") + \"/Downloads/op.out\";\n\t        InputReader fin = new InputReader(IPfilePath);\n\t        PrintWriter fout = null;\n\t        try {\n\t\t\t\tfout = new PrintWriter(new File(OPfilePath));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t        solver.solve(fin, fout);\n\t        //fout.println(\"time(s): \" + (1.0*(System.currentTimeMillis()-t1))/1000.0);\n\t        fout.close();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n        prepareIO(false);\n\t}\n\t\n\tstatic class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n        \n        public InputReader(String filePath) {\n        \tFile file = new File(filePath);\n            try {\n\t\t\t\treader = new BufferedReader(new FileReader(file));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n            tokenizer = null;\n        }\n        \n        public String nextLine() {\n        \tString str = \"\";\n        \ttry {\n\t\t\t\tstr = reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n        \treturn str;\n        }\n        \n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n        \treturn Double.parseDouble(next());\n        }\n        \n    }\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool is_prime(long long n) {\n  if (n <= 1) {\n    return false;\n  }\n  for (long long i = 2; i * i <= n; ++i) {\n    if (n % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\ninline long long getPow(long long a, long long b) {\n  long long res = 1ll, tp = a;\n  while (b) {\n    if (b & 1ll) {\n      res *= tp;\n    }\n    tp *= tp;\n    b >>= 1ll;\n  }\n  return res;\n}\nlong long coso(long long x1, long long y1, long long x2, long long y2,\n               long long x3, long long y3) {\n  return abs((x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1));\n}\ninline long long nxt() {\n  long long x;\n  cin >> x;\n  return x;\n}\nvoid ok() {\n  puts(\"YES\");\n  exit(0);\n}\nvoid no() {\n  puts(\"NO\");\n  exit(0);\n}\nconst long long N = 1e6 + 5;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long n = nxt();\n  vector<long long> mas(n);\n  for (int i = 0; i < n; i++) {\n    mas[i] = nxt();\n  }\n  vector<vector<long long>> dp(200 + 5, vector<long long>(2, 0LL));\n  if (mas[0] == -1) {\n    for (int i = 1; i <= 200; i++) {\n      dp[i][1] = 1;\n    }\n  } else\n    dp[mas[0]][1] = 1;\n  for (int i = 1; i < n; i++) {\n    long long cur = 0;\n    vector<vector<long long>> dp2(200 + 5, vector<long long>(2, 0LL));\n    for (int j = 1; j <= 200; j++) {\n      dp2[j][1] = cur;\n      cur = (cur + dp[j][0] + dp[j][1]);\n      while (cur > 998244353) {\n        cur -= 998244353;\n      }\n    }\n    cur = 0;\n    for (int j = 200; j >= 1; j--) {\n      dp2[j][0] =\n          ((dp2[j][0] + dp[j][0] + dp[j][1]) % 998244353 + cur) % 998244353;\n      while (dp2[j][0] > 998244353) {\n        dp2[j][0] -= 998244353;\n      }\n      cur = (cur + dp[j][0]);\n      while (cur > 998244353) {\n        cur -= 998244353;\n      }\n    }\n    for (int j = 1; j <= 200; j++) {\n      if (mas[i] != -1 && mas[i] != j) {\n        dp2[j][0] = dp2[j][1] = 0;\n      }\n    }\n    dp = dp2;\n  }\n  long long ans = 0LL;\n  for (int i = 1; i <= 200; i++) {\n    ans += dp[i][0];\n  }\n  cout << ans % 998244353;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int dp[201][2];\nlong long int presum[201][2];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  long long int n;\n  cin >> n;\n  vector<long long int> arr(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> arr[i];\n  }\n  vector<vector<long long int> > dp(200, vector<long long int>(2, 0));\n  vector<vector<long long int> > prev(200, vector<long long int>(2, 0));\n  vector<vector<long long int> > presum(200, vector<long long int>(2, 0));\n  vector<vector<long long int> > prevpresum(200, vector<long long int>(2, 0));\n  vector<vector<long long int> > zeros(200, vector<long long int>(2, 0));\n  if (arr[0] != -1)\n    dp[arr[0] - 1][0] = 1;\n  else {\n    for (int i = 0; i < 200; ++i) {\n      dp[i][0] = 1;\n    }\n  }\n  for (int i = 0; i < 200; ++i) {\n    presum[i][0] = (((i > 0) ? presum[i - 1][0] : 0) + dp[i][0]) % 998244353;\n    presum[i][1] = (((i > 0) ? presum[i - 1][1] : 0) + dp[i][1]) % 998244353;\n  }\n  for (int i = 1; i < n; ++i) {\n    prev = dp;\n    prevpresum = presum;\n    dp = zeros;\n    for (int j = 0; j < 200; ++j) {\n      if (!(arr[i] != -1 && j != arr[i] - 1)) {\n        dp[j][0] =\n            (((j > 0) ? (prevpresum[j - 1][1] + prevpresum[j - 1][0]) : 0)) %\n            998244353;\n        dp[j][1] =\n            ((prevpresum[199][1] - prevpresum[j][1] + prev[j][1] + prev[j][0]) %\n                 998244353 +\n             998244353) %\n            998244353;\n      }\n      presum[j][0] = (((j > 0) ? presum[j - 1][0] : 0) + dp[j][0]) % 998244353;\n      presum[j][1] = (((j > 0) ? presum[j - 1][1] : 0) + dp[j][1]) % 998244353;\n    }\n  }\n  long long int res = presum[199][1];\n  cout << res << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class D {\n\n    public static final int MOD = 998244353;\n    public static final int MAX_VAL = 200;\n\n    static class FastScanner extends BufferedReader {\n        public FastScanner(InputStream is) {\n            super(new InputStreamReader(is));\n        }\n\n\n        public int read() {\n            try {\n                int ret = super.read();\n//            if (isEOF && ret < 0) {\n//                throw new InputMismatchException();\n//            }\n//            isEOF = ret == -1;\n                return ret;\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n        }\n\n        public String next() {\n            StringBuilder sb = new StringBuilder();\n            int c = read();\n            while (isWhiteSpace(c)) {\n                c = read();\n            }\n            if (c < 0) {\n                return null;\n            }\n            while (c >= 0 && !isWhiteSpace(c)) {\n                sb.appendCodePoint(c);\n                c = read();\n            }\n            return sb.toString();\n        }\n\n        static boolean isWhiteSpace(int c) {\n            return c >= 0 && c <= 32;\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isWhiteSpace(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int ret = 0;\n            while (c >= 0 && !isWhiteSpace(c)) {\n                if (c < '0' || c > '9') {\n                    throw new NumberFormatException(\"digit expected \" + (char) c\n                            + \" found\");\n                }\n                ret = ret * 10 + c - '0';\n                c = read();\n            }\n            return ret * sgn;\n        }\n\n        public String readLine() {\n            try {\n                return super.readLine();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n\n    }\n\n    FastScanner sc;\n\n    public void solve() throws IOException {\n        int n = sc.nextInt();\n        long[][] dpConf = new long[n][MAX_VAL + 2];\n        long[][] dpUnConf = new long[n][MAX_VAL + 2];\n        long[] prefConf = new long[MAX_VAL + 2];\n        long[] prefUnConf = new long[MAX_VAL + 2];\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n        }\n        if (a[0] == -1) {\n            for (int i = 1; i <= MAX_VAL; i++) {\n                dpUnConf[0][i] = 1;\n            }\n        } else {\n            dpUnConf[0][a[0]] = 1;\n        }\n        for (int i = 1; i < n; i++) {\n            prefConf[0] = 0;\n            for (int j = 1; j <= MAX_VAL; j++) {\n                prefConf[j] = (prefConf[j - 1] + dpConf[i - 1][j]) % MOD;\n            }\n            prefUnConf[0] = 0;\n            for (int j = 1; j <= MAX_VAL; j++) {\n                prefUnConf[j] = (prefUnConf[j - 1] + dpUnConf[i - 1][j]) % MOD;\n            }\n            for (int j = 1; j <= MAX_VAL; j++) {\n                if (j == a[i] || a[i] == -1) {\n                    dpConf[i][j] += dpConf[i - 1][j];\n                    dpConf[i][j] += dpUnConf[i - 1][j];\n                    dpConf[i][j] %= MOD;\n                    dpUnConf[i][j] += (prefConf[j - 1] + prefUnConf[j - 1]) % MOD;\n                    dpConf[i][j] += (prefConf[MAX_VAL] - prefConf[j]) % MOD;//[j+1;MAX]\n                }\n            }\n        }\n        long ans = 0;\n        for (int i = 1; i <= MAX_VAL; i++) {\n            ans += dpConf[n - 1][i];\n            ans %= MOD;\n        }\n        out.print((ans + MOD) % MOD);\n    }\n\n    public void run() throws IOException {\n        sc = new FastScanner(System.in);\n        out = new PrintWriter(System.out);\n        solve();\n        sc.close();\n        out.close();\n    }\n\n    BufferedReader br;\n    StringTokenizer in;\n    PrintWriter out;\n\n    public String nextToken() throws IOException {\n        while (in == null || !in.hasMoreTokens()) {\n            in = new StringTokenizer(br.readLine());\n        }\n        return in.nextToken();\n    }\n\n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    public double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    public long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    public static void main(String... args) throws IOException {\n        new D().run();\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 998244353;\nvector<int> A;\nint N, D[3][2][201];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ((void)0);\n  ((void)0);\n  int ans = 0;\n  cin >> N;\n  A.resize(N);\n  for (auto &a : A) {\n    cin >> a;\n  }\n  for (int i = 1; i <= 200; i++) {\n    D[2][0][i] = (A[0] == -1 || A[0] == i);\n  }\n  for (int i = 1; i < N; i++) {\n    for (int j = 1; j <= 200; j++) {\n      D[0][i & 1][j] = D[1][i & 1][j] = D[2][i & 1][j] = 0;\n    }\n    if (A[i] == -1) {\n      int temp = 0;\n      for (int j = 200; j > 0; j--) {\n        D[0][i & 1][j] = temp;\n        temp = (0LL + temp + D[0][(i - 1) & 1][j] + D[1][(i - 1) & 1][j]) % MOD;\n        D[1][i & 1][j] = (0LL + D[0][(i - 1) & 1][j] + D[1][(i - 1) & 1][j] +\n                          D[2][(i - 1) & 1][j]) %\n                         MOD;\n      }\n      temp = 0;\n      for (int j = 1; j <= 200; j++) {\n        D[2][i & 1][j] = temp;\n        temp = (temp + D[1][i & 1][j]) % MOD;\n      }\n    } else {\n      for (int j = 1; j <= 200; j++) {\n        if (j > A[i]) {\n          D[0][i & 1][A[i]] = (0LL + D[0][i & 1][A[i]] + D[0][(i - 1) & 1][j] +\n                               D[1][(i - 1) & 1][j]) %\n                              MOD;\n        } else if (j == A[i]) {\n          D[1][i & 1][A[i]] = (0LL + D[0][(i - 1) & 1][j] +\n                               D[1][(i - 1) & 1][j] + D[2][(i - 1) & 1][j]) %\n                              MOD;\n        } else {\n          D[2][i & 1][A[i]] = (0LL + D[2][i & 1][A[i]] + D[0][(i - 1) & 1][j] +\n                               D[1][(i - 1) & 1][j] + D[2][(i - 1) & 1][j]) %\n                              MOD;\n        }\n      }\n    }\n  }\n  for (int i = 1; i <= 200; i++) {\n    ans = (0LL + ans + D[0][(N - 1) & 1][i] + D[1][(N - 1) & 1][i]) % MOD;\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class Solution {\n\tstatic class FastReader {\n        BufferedReader br; \n        StringTokenizer st; \n        public FastReader() {\n        \tboolean env=System.getProperty(\"ONLINE_JUDGE\") != null;\n        \tif(!env) {\n        \t\ttry {\n\t\t\t\t\tbr=new BufferedReader(new FileReader(\"src\\\\input.txt\"));\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n        \t}\n        \telse br = new BufferedReader(new InputStreamReader(System.in)); \n        } \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) {\n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n        int nextInt() {\n            return Integer.parseInt(next()); \n        } \n        long nextLong() {\n            return Long.parseLong(next()); \n        } \n        double nextDouble() {\n            return Double.parseDouble(next()); \n        } \n        String nextLine() {\n            String str = \"\"; \n            try {\n                str = br.readLine(); \n            } \n            catch (IOException e) {\n                e.printStackTrace(); \n            } \n            return str; \n        } \n    }\n\tstatic FastReader sc=new FastReader();\n\tstatic PrintWriter out=new PrintWriter(System.out);\n\t//Main\n\tstatic int N=201;\n\tstatic long MOD=998244353;\n\tpublic static void main(String args[]) {\n\t\tint test=1;\n\t\t//test=sc.nextInt();\n\t\twhile(test-->0) {\n\t\t\t//Focus\n\t\t\tint n=sc.nextInt(),a[]=new int[n];\n\t\t\tlong dp[][][]=new long[2][N][n];\n\t\t\tlong g[][]=new long[N][2];\n\t\t\tfor(int i=0;i<n;i++) a[i]=sc.nextInt();\n\t\t\tfor(int j=1;j<N;j++) {\n\t\t\t\tif(a[0]==-1 || a[0]==j) dp[0][j][0]=1;\n\t\t\t\tg[j][0]=(g[j-1][0]+dp[0][j][0]);\n\t\t\t}\n\t\t\tfor(int i=1;i<n;i++) {\n\t\t\t\tfor(int j=1;j<N;j++) {\n\t\t\t\t\tif(a[i]!=-1 && a[i]!=j) continue;\n\t\t\t\t\tdp[0][j][i]=(g[j-1][0]-g[0][0]+g[j-1][1]-g[0][1]+MOD+MOD)%MOD;\n\t\t\t\t\tdp[1][j][i]=((g[N-1][1]-g[j-1][1]+dp[0][j][i-1]+MOD))%MOD;\n\t\t\t\t}\n\t\t\t\tfor(int j=1;j<N;j++) {\n\t\t\t\t\tg[j][0]=(g[j-1][0]+dp[0][j][i])%MOD;\n\t\t\t\t\tg[j][1]=(g[j-1][1]+dp[1][j][i])%MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(g[N-1][1]);\n\t\t}\n\t\tout.flush();\n\t\tout.close();\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "import os\nfrom io import BytesIO\nfrom math import trunc\n\ninput = BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\nMX = 201\nMOD = 998244353\nMODF = MOD * 1.0\n\nquickmod = lambda x: x - MODF * trunc(x / MODF)\n\n\ndef main():\n    n = int(input())\n    a = map(int, input().split())\n\n    dp0 = [1.0] * MX\n    dp1 = [0.0] * MX\n\n    for x in a:\n        pomdp0 = [0.0] * MX\n        pomdp1 = [0.0] * MX\n        if x == -1:\n            for val in range(1, MX):\n                pomdp0[val] = quickmod(\n                    pomdp0[val - 1] + dp1[val - 1] + dp0[val - 1])\n                pomdp1[val] = quickmod(\n                    pomdp1[val - 1] + dp1[MX - 1] - dp1[val - 1] + dp0[val] -\n                    dp0[val - 1])\n        else:\n            pomdp0[x] = quickmod(dp1[x - 1] + dp0[x - 1])\n            pomdp1[x] = quickmod(dp1[MX - 1] - dp1[x - 1] + dp0[x] - dp0[x - 1])\n            for val in range(x + 1, MX):\n                pomdp0[val] = pomdp0[val - 1]\n                pomdp1[val] = pomdp1[val - 1]\n\n        dp0, dp1 = pomdp0, pomdp1\n\n    print(int(dp1[MX - 1] if n > 1 else dp0[MX - 1]) % MOD)\n\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing vi = vector<int>;\nusing vpii = vector<pii>;\nusing vl = vector<ll>;\nusing ld = long double;\nusing vs = vector<string>;\nconst int MAXN = (int)1e5 + 22;\nconst int MAX_VAL = 200;\nconst int MOD = 998244353;\nint N;\nvi A;\nint dp[MAXN][MAX_VAL][2];\ninline void add(int &x, int y) {\n  x += y;\n  while (x >= MOD) x -= MOD;\n  while (x < 0) x += MOD;\n}\nvoid solve() {\n  cin >> N;\n  A.resize(N);\n  for (auto &x : A) {\n    cin >> x;\n    if (x >= 1) x--;\n  }\n  if (A[0] == -1)\n    add(dp[0][0][0], 1);\n  else {\n    add(dp[0][A[0]][0], 1);\n    if (A[0] + 1 < MAX_VAL) add(dp[0][A[0] + 1][0], -1);\n  }\n  for (int i = 0; i < N; i++) {\n    for (int f = 0; f < 2; f++) {\n      int val = 0;\n      for (int last = 0; last < MAX_VAL; last++) {\n        add(val, dp[i][last][f]);\n        dp[i][last][f] = val;\n      }\n    }\n    if (i >= N - 1) break;\n    for (int last = 0; last < MAX_VAL; last++) {\n      for (int f = 0; f < 2; f++) {\n        auto state = dp[i][last][f];\n        if (!state) continue;\n        if (A[i + 1] == -1) {\n          int ne = (f ? 0 : last);\n          add(dp[i + 1][ne][1], state);\n          if (last + 1 < MAX_VAL) {\n            add(dp[i + 1][last + 1][1], -state);\n            add(dp[i + 1][last + 1][0], state);\n          }\n        } else {\n          int ne = A[i + 1];\n          int nf = (last >= ne);\n          bool good = (f | (ne >= last));\n          if (good) {\n            add(dp[i + 1][ne][nf], state);\n            if (ne + 1 < MAX_VAL) add(dp[i + 1][ne + 1][nf], -state);\n          }\n        }\n      }\n    }\n  }\n  int ans = 0;\n  for (int last = 0; last < MAX_VAL; last++) {\n    add(ans, dp[N - 1][last][1]);\n  }\n  cout << ans;\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  clock_t start = clock();\n  solve();\n  cerr << ((double)clock() - start) / CLOCKS_PER_SEC << \" sec.\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 998244353;\nconst int MAXN = 100000;\nconst int MAXV = 200;\nint dp[MAXN + 5][MAXV + 5][3];\nint prefixUp[MAXV + 5][3], prefixDown[MAXV + 5][3];\nbool valid(vector<int> &a, int i, int val) {\n  if (a[i] == -1)\n    return true;\n  else\n    return a[i] == val;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  memset(dp, 0, sizeof(dp));\n  for (int curr = 1; curr <= 200; curr++)\n    if (valid(a, 0, curr)) {\n      dp[0][curr][0] = 1;\n    }\n  for (int i = 1; i < n; i++) {\n    for (int curr = 200; curr >= 1; curr--) {\n      for (int t = 0; t < 3; t++) {\n        prefixUp[curr][t] =\n            curr == 200\n                ? 0\n                : (prefixUp[curr + 1][t] + dp[i - 1][curr + 1][t]) % MOD;\n      }\n    }\n    for (int curr = 1; curr <= 200; curr++) {\n      for (int t = 0; t < 3; t++) {\n        prefixDown[curr][t] =\n            curr == 1\n                ? 0\n                : (prefixDown[curr - 1][t] + dp[i - 1][curr - 1][t]) % MOD;\n      }\n    }\n    for (int curr = 1; curr <= 200; curr++)\n      if (valid(a, i, curr)) {\n        for (int bit = 0; bit < 3; bit++) {\n          if (bit == 0) {\n            for (int t = 0; t <= 2; t++) {\n              dp[i][curr][bit] += prefixDown[curr][t];\n              dp[i][curr][bit] %= MOD;\n            }\n          } else if (bit == 2) {\n            dp[i][curr][bit] += prefixUp[curr][1];\n            dp[i][curr][bit] %= MOD;\n            dp[i][curr][bit] += prefixUp[curr][2];\n            dp[i][curr][bit] %= MOD;\n          } else {\n            dp[i][curr][bit] += dp[i - 1][curr][0];\n            dp[i][curr][bit] %= MOD;\n            dp[i][curr][bit] += dp[i - 1][curr][1];\n            dp[i][curr][bit] %= MOD;\n            dp[i][curr][bit] += dp[i - 1][curr][2];\n            dp[i][curr][bit] %= MOD;\n          }\n        }\n      }\n  }\n  int sol = 0;\n  for (int curr = 1; curr <= 200; curr++)\n    if (valid(a, n - 1, curr)) {\n      sol += dp[n - 1][curr][1];\n      sol %= MOD;\n      sol += dp[n - 1][curr][2];\n      sol %= MOD;\n    }\n  cout << sol << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 110000, K = 205, mod = 998244353;\nint n, a[N], f[K][2], sum[K][2], ans;\ntemplate <class T>\ninline void read(T &x) {\n  x = 0;\n  char ch = getchar(), w = 0;\n  while (!isdigit(ch)) w = (ch == '-'), ch = getchar();\n  while (isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();\n  x = w ? -x : x;\n  return;\n}\ninline int addMod(int x, int y) { return (x += y) >= mod ? x - mod : x; }\nint main() {\n  read(n);\n  for (register int i = 1; i <= n; ++i) read(a[i]);\n  if (a[1] == -1) {\n    for (register int i = 1; i <= 200; ++i) f[i][0] = 1;\n  } else\n    f[a[1]][0] = 1;\n  for (register int i = 2; i <= n; ++i) {\n    for (register int j = 1; j <= 200; ++j)\n      sum[j][0] = addMod(sum[j - 1][0], f[j][0]),\n      sum[j][1] = addMod(sum[j - 1][1], f[j][1]);\n    for (register int j = 1; j <= 200; ++j)\n      f[j][0] = addMod(sum[j - 1][0], sum[j - 1][1]),\n      f[j][1] = addMod(addMod(sum[200][1], mod - sum[j - 1][1]),\n                       addMod(sum[j][0], mod - sum[j - 1][0]));\n    if (a[i] != -1)\n      for (register int j = 1; j <= 200; ++j)\n        if (j != a[i]) f[j][0] = f[j][1] = 0;\n  }\n  for (register int i = 1; i <= 200; ++i) ans = addMod(ans, f[i][1]);\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\nconst int N = 1e5 + 7;\nconst int mod = 998244353;\nint dp[2][N][222];\nint qry(int c, int lv, int i, int j) {\n  if (i > j) return 0;\n  return (dp[c][lv][j] + mod - dp[c][lv][i - 1]) % mod;\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vector<int> a(n + 1);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n  if (a[1] == -1)\n    for (int i = 1; i <= 200; ++i) dp[0][1][i] = dp[0][1][i - 1] + 1;\n  else {\n    dp[0][1][a[1]] = 1;\n    for (int i = 1; i <= 200; ++i) dp[0][1][i] += dp[0][1][i - 1];\n  }\n  for (int i = 2; i <= n; ++i) {\n    if (~a[i]) {\n      dp[1][i][a[i]] =\n          (qry(1, i - 1, a[i], 200) + qry(0, i - 1, a[i], a[i])) % mod;\n      dp[0][i][a[i]] =\n          (qry(1, i - 1, 1, a[i] - 1) + qry(0, i - 1, 1, a[i] - 1)) % mod;\n    } else {\n      for (int k = 1; k <= 200; ++k)\n        dp[1][i][k] = (qry(1, i - 1, k, 200) + qry(0, i - 1, k, k)) % mod;\n      for (int k = 1; k <= 200; ++k)\n        dp[0][i][k] = (qry(1, i - 1, 1, k - 1) + qry(0, i - 1, 1, k - 1)) % mod;\n    }\n    for (int c = 0; c < 2; ++c)\n      for (int k = 1; k <= 200; ++k)\n        dp[c][i][k] = (dp[c][i][k - 1] + dp[c][i][k]) % mod;\n  }\n  cout << dp[1][n][200] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 998244353;\nconst int MAXN = 100000;\nconst int MAXV = 200;\nint dp[MAXN + 5][MAXV + 5][3];\nint prefixUp[MAXV + 5][3], prefixDown[MAXV + 5][3];\nbool valid(vector<int> &a, int i, int val) {\n  if (a[i] == -1)\n    return true;\n  else\n    return a[i] == val;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  memset(dp, 0, sizeof(dp));\n  for (int curr = 1; curr <= 200; curr++)\n    if (valid(a, 0, curr)) dp[0][curr][0] = 1;\n  for (int i = 1; i < n; i++) {\n    for (int curr = 200; curr >= 1; curr--) {\n      for (int t = 0; t < 3; t++) {\n        prefixUp[curr][t] =\n            curr == 200\n                ? 0\n                : (prefixUp[curr + 1][t] + dp[i - 1][curr + 1][t]) % MOD;\n      }\n    }\n    for (int curr = 1; curr <= 200; curr++) {\n      for (int t = 0; t < 3; t++) {\n        prefixDown[curr][t] =\n            curr == 1\n                ? 0\n                : (prefixDown[curr - 1][t] + dp[i - 1][curr - 1][t]) % MOD;\n      }\n    }\n    for (int curr = 1; curr <= 200; curr++)\n      if (valid(a, i, curr)) {\n        for (int t = 0; t <= 2; t++) {\n          dp[i][curr][0] += prefixDown[curr][t];\n          dp[i][curr][0] %= MOD;\n        }\n        for (int t = 1; t <= 2; t++) {\n          dp[i][curr][2] += prefixUp[curr][t];\n          dp[i][curr][2] %= MOD;\n        }\n        for (int t = 0; t <= 2; t++) {\n          dp[i][curr][1] += dp[i - 1][curr][t];\n          dp[i][curr][1] %= MOD;\n        }\n      }\n  }\n  int sol = 0;\n  for (int curr = 1; curr <= 200; curr++)\n    if (valid(a, n - 1, curr)) {\n      sol += dp[n - 1][curr][1];\n      sol %= MOD;\n      sol += dp[n - 1][curr][2];\n      sol %= MOD;\n    }\n  cout << sol << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[3][2000][3];\nint pre[2000][3];\nint MOD = 998244353;\nint n;\nint a[200010];\nvoid Build() {\n  memset(pre, 0, sizeof(pre));\n  for (int i = 1; i <= 200; i++) {\n    pre[i][0] = (dp[0][i][0] + pre[i - 1][0]) % MOD;\n    pre[i][1] = (dp[0][i][1] + pre[i - 1][1]) % MOD;\n  }\n  return;\n}\nint Query(int st, int en, int type) {\n  if (st == 0 || st > en) return 0;\n  return ((pre[en][type] - pre[st - 1][type] + MOD) % MOD);\n}\nint main() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  if (a[1] == -1) {\n    for (int i = 1; i <= 200; i++) dp[0][i][1] = 1;\n  } else\n    dp[0][a[1]][1] = 1;\n  Build();\n  for (int i = 2; i <= n; i++) {\n    if (a[i] == -1) {\n      for (int j = 1; j <= 200; j++) {\n        dp[1][j][0] = (Query(j, 200, 0) + dp[1][j][0]) % MOD;\n        dp[1][j][1] = (Query(1, j - 1, 1) + dp[1][j][1]) % MOD;\n        dp[1][j][1] = (Query(1, j - 1, 0) + dp[1][j][1]) % MOD;\n        dp[1][j][0] = (dp[1][j][0] + dp[0][j][1]) % MOD;\n      }\n    } else {\n      dp[1][a[i]][0] = (Query(a[i], 200, 0) + dp[1][a[i]][0]) % MOD;\n      dp[1][a[i]][1] = (Query(1, a[i] - 1, 1) + dp[1][a[i]][1]) % MOD;\n      dp[1][a[i]][1] = (Query(1, a[i] - 1, 0) + dp[1][a[i]][1]) % MOD;\n      dp[1][a[i]][0] = (dp[1][a[i]][0] + dp[0][a[i]][1]) % MOD;\n    }\n    for (int j = 1; j <= 200; j++) {\n      dp[0][j][0] = dp[1][j][0];\n      dp[0][j][1] = dp[1][j][1];\n    }\n    memset(dp[1], 0, sizeof(dp[1]));\n    Build();\n  }\n  cout << Query(1, 200, 0) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "import os\nfrom io import BytesIO\n\nrange = xrange\ninput = BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\nMOD = 998244353\nMODF = 1.0*MOD\nfrom math import trunc\ndef quickmod(a):\n    return a-MODF*trunc(a/MODF)\n\ndef main():\n    n = int(input())\n    a = [int(i) for i in input().split()]\n\n    f0, f1 = [1.0] * 201, [0.0] * 201\n    for i in range(n):\n        nf0, nf1 = [0.0] * 201, [0.0] * 201\n        if a[i] == -1:\n            for j in range(200):\n                nf0[j + 1] = quickmod(nf0[j] + f0[j] + f1[j])\n                nf1[j + 1] = quickmod(nf1[j] - f0[j] + f0[j + 1] - f1[j] + f1[200])\n        else:\n            for j in range(200):\n                nf0[j + 1], nf1[j + 1] = nf0[j], nf1[j]\n                if j + 1 == a[i]:\n                    nf0[j + 1] = quickmod(nf0[j] + f0[j] + f1[j])\n                    nf1[j + 1] = quickmod(nf1[j] - f0[j] + f0[j + 1] - f1[j] + f1[200])\n        f0, f1 = nf0, nf1\n\n    os.write(1, str(int(quickmod(f1[200]))%MOD))\n\n\nif __name__ == '__main__':\n    main()"
        }
    ]
}