{
    "name": "1556_H. DIY Tree",
    "source": "CODEFORCES",
    "description": "<image>\n\nWilliam really likes puzzle kits. For one of his birthdays, his friends gifted him a complete undirected edge-weighted graph consisting of n vertices.\n\nHe wants to build a spanning tree of this graph, such that for the first k vertices the following condition is satisfied: the degree of a vertex with index i does not exceed d_i. Vertices from k + 1 to n may have any degree.\n\nWilliam wants you to find the minimum weight of a spanning tree that satisfies all the conditions.\n\nA spanning tree is a subset of edges of a graph that forms a tree on all n vertices of the graph. The weight of a spanning tree is defined as the sum of weights of all the edges included in a spanning tree.\n\nInput\n\nThe first line of input contains two integers n, k (2 \u2264 n \u2264 50, 1 \u2264 k \u2264 min(n - 1, 5)).\n\nThe second line contains k integers d_1, d_2, \u2026, d_k (1 \u2264 d_i \u2264 n). \n\nThe i-th of the next n - 1 lines contains n - i integers w_{i,i+1}, w_{i,i+2}, \u2026, w_{i,n} (1 \u2264 w_{i,j} \u2264 100): weights of edges (i,i+1),(i,i+2),\u2026,(i,n).\n\nOutput\n\nPrint one integer: the minimum weight of a spanning tree under given degree constraints for the first k vertices. \n\nExample\n\nInput\n\n\n10 5\n5 3 4 2 1\n29 49 33 12 55 15 32 62 37\n61 26 15 58 15 22 8 58\n37 16 9 39 20 14 58\n10 15 40 3 19 55\n53 13 37 44 52\n23 59 58 4\n69 80 29\n89 28\n48\n\n\nOutput\n\n\n95",
    "difficulty": "H",
    "tags": [
        "graphs",
        "greedy",
        "math",
        "probabilities"
    ],
    "rating": 3300,
    "public_test": [
        {
            "input": "10 5\n5 3 4 2 1\n29 49 33 12 55 15 32 62 37\n61 26 15 58 15 22 8 58\n37 16 9 39 20 14 58\n10 15 40 3 19 55\n53 13 37 44 52\n23 59 58 4\n69 80 29\n89 28\n48\n",
            "output": "95\n"
        }
    ],
    "generated_test": [
        {
            "input": "5 1\n3\n67 62 64 5\n45 84 3\n60 64\n29\n",
            "output": "82\n"
        },
        {
            "input": "10 5\n5 3 4 2 5\n61 54 31 1 61 51 55 61 37\n11 20 4 68 37 4 68 24\n57 62 53 67 34 86 34\n31 18 14 33 23 26\n33 51 27 31 50\n33 48 94 19\n68 18 84\n74 74\n88\n",
            "output": "120\n"
        },
        {
            "input": "4 2\n3 2\n54 59 82\n19 34\n40\n",
            "output": "112\n"
        },
        {
            "input": "5 4\n4 4 3 2\n35 65 14 20\n2 33 4\n37 52\n10\n",
            "output": "30\n"
        },
        {
            "input": "7 5\n3 1 3 1 2\n8 34 17 85 24 57\n7 32 48 85 41\n74 77 76 65\n28 95 63\n82 40\n69\n",
            "output": "187\n"
        },
        {
            "input": "3 1\n1\n54 68\n26\n",
            "output": "80\n"
        },
        {
            "input": "5 3\n2 2 1\n29 44 61 47\n18 19 7\n34 68\n8\n",
            "output": "78\n"
        },
        {
            "input": "10 5\n1 5 2 1 1\n86 39 1 96 2 96 37 31 36\n92 95 17 23 14 31 32 24\n41 26 35 54 34 82 66\n71 37 94 75 1 23\n56 66 66 75 73\n90 21 36 4\n74 87 57\n43 26\n79\n",
            "output": "148\n"
        },
        {
            "input": "5 2\n1 4\n48 20 68 57\n63 68 1\n7 31\n31\n",
            "output": "59\n"
        },
        {
            "input": "4 3\n1 2 2\n68 44 7\n2 44\n17\n",
            "output": "26\n"
        },
        {
            "input": "4 1\n2\n64 53 40\n82 43\n7\n",
            "output": "90\n"
        },
        {
            "input": "10 5\n5 4 5 2 4\n29 49 33 12 55 15 32 62 37\n61 26 15 58 15 22 8 58\n37 16 9 39 20 14 58\n10 15 40 3 19 55\n53 13 37 44 52\n23 59 58 4\n69 80 29\n89 28\n31\n",
            "output": "88\n"
        },
        {
            "input": "6 4\n1 2 2 2 2\n10 99 99 99 11\n10 99 99 11\n10 99 11\n10 11\n11\n",
            "output": "43\n"
        },
        {
            "input": "4 3\n2 1 2\n9 1 8\n7 9\n9\n",
            "output": "16\n"
        },
        {
            "input": "10 5\n5 3 4 2 1\n29 49 33 12 55 15 32 62 37\n61 26 15 58 15 22 11 58\n37 16 9 39 20 14 58\n10 15 40 3 19 55\n53 13 37 44 52\n23 59 58 4\n69 80 29\n89 28\n48\n",
            "output": "98\n"
        },
        {
            "input": "5 4\n4 4 3 2\n35 65 14 20\n2 33 8\n37 52\n10\n",
            "output": "34\n"
        },
        {
            "input": "7 5\n4 1 3 1 2\n8 34 17 85 24 57\n7 32 48 85 41\n74 77 76 65\n28 95 63\n82 40\n69\n",
            "output": "179\n"
        },
        {
            "input": "3 1\n1\n77 68\n26\n",
            "output": "94\n"
        },
        {
            "input": "10 5\n5 3 4 3 5\n61 54 31 1 61 51 55 61 37\n11 20 4 68 37 4 68 24\n57 62 53 67 34 51 34\n31 18 28 33 23 26\n33 51 27 31 50\n33 48 94 19\n68 18 84\n74 74\n46\n",
            "output": "129\n"
        },
        {
            "input": "4 3\n1 2 2\n68 44 7\n2 44\n18\n",
            "output": "27\n"
        },
        {
            "input": "10 5\n5 4 5 2 4\n29 49 33 12 55 15 32 62 37\n61 26 15 58 15 22 8 58\n37 16 9 39 20 14 58\n10 15 40 3 19 55\n53 13 37 44 52\n23 13 58 4\n69 80 29\n89 28\n31\n",
            "output": "86\n"
        },
        {
            "input": "5 1\n3\n113 62 64 5\n50 84 3\n60 64\n29\n",
            "output": "87\n"
        },
        {
            "input": "4 1\n3 2\n54 59 82\n19 34\n54\n",
            "output": "55\n"
        },
        {
            "input": "7 5\n4 1 3 1 2\n8 34 17 85 24 57\n7 32 48 85 41\n74 77 76 34\n28 95 63\n82 40\n69\n",
            "output": "156\n"
        },
        {
            "input": "10 5\n5 4 5 2 4\n29 49 33 12 55 15 32 62 37\n61 26 15 58 15 22 8 58\n37 16 16 39 20 14 58\n10 15 40 3 19 55\n53 13 37 44 52\n23 13 58 4\n69 80 29\n89 28\n31\n",
            "output": "92\n"
        },
        {
            "input": "6 4\n1 2 2 2 2\n10 172 99 99 11\n10 99 99 11\n10 99 11\n10 14\n11\n",
            "output": "44\n"
        },
        {
            "input": "5 4\n4 4 3 2\n35 65 14 20\n2 33 5\n37 46\n10\n",
            "output": "31\n"
        },
        {
            "input": "10 5\n5 3 4 3 6\n61 54 31 1 61 51 55 61 37\n11 20 4 68 37 4 68 24\n57 62 53 67 34 51 34\n23 18 28 33 23 26\n33 51 27 31 50\n33 48 94 19\n68 18 84\n74 74\n46\n",
            "output": "121\n"
        },
        {
            "input": "10 5\n5 3 4 2 1\n29 49 33 24 55 15 32 62 37\n61 26 15 95 15 22 11 58\n37 16 9 39 20 14 58\n9 15 40 3 19 55\n53 13 37 44 52\n23 59 58 4\n69 80 29\n89 28\n48\n",
            "output": "99\n"
        },
        {
            "input": "5 1\n3\n113 102 64 1\n50 84 3\n60 64\n29\n",
            "output": "83\n"
        },
        {
            "input": "10 5\n5 3 4 3 6\n61 54 31 1 61 51 55 61 37\n11 20 4 68 37 4 68 24\n57 62 53 67 34 51 34\n23 18 28 33 23 26\n33 51 27 10 50\n33 48 94 19\n68 18 84\n74 74\n46\n",
            "output": "108\n"
        },
        {
            "input": "10 5\n1 5 2 1 1\n86 39 1 96 2 96 37 31 36\n92 95 17 23 14 31 60 24\n41 26 35 54 34 82 66\n71 41 94 75 1 23\n56 66 66 31 73\n90 21 36 4\n74 87 57\n39 26\n79\n",
            "output": "152\n"
        },
        {
            "input": "5 2\n1 5\n48 20 68 2\n63 55 1\n7 31\n31\n",
            "output": "41\n"
        },
        {
            "input": "10 5\n5 4 5 2 4\n29 49 33 12 55 15 32 62 37\n61 26 7 58 15 22 8 58\n37 16 16 39 20 14 58\n10 15 14 3 19 55\n53 13 37 44 52\n23 13 58 4\n69 80 29\n89 28\n31\n",
            "output": "84\n"
        },
        {
            "input": "6 4\n1 2 2 1 2\n10 172 99 99 11\n10 99 99 11\n10 99 11\n10 14\n2\n",
            "output": "47\n"
        },
        {
            "input": "5 1\n3\n113 102 64 1\n23 84 3\n60 64\n29\n",
            "output": "56\n"
        },
        {
            "input": "10 5\n5 3 4 2 5\n61 54 24 1 22 51 28 61 37\n11 20 4 68 37 4 68 44\n57 62 53 67 34 86 34\n31 18 14 33 23 26\n33 51 27 31 50\n33 48 94 19\n68 18 73\n74 74\n88\n",
            "output": "111\n"
        },
        {
            "input": "5 4\n4 4 3 2\n35 5 14 20\n2 33 5\n37 46\n10\n",
            "output": "22\n"
        },
        {
            "input": "4 1\n2\n64 30 36\n154 38\n7\n",
            "output": "75\n"
        },
        {
            "input": "5 1\n3\n113 102 64 1\n23 84 4\n60 64\n29\n",
            "output": "57\n"
        },
        {
            "input": "5 2\n1 5\n48 20 68 2\n87 55 1\n7 3\n31\n",
            "output": "13\n"
        },
        {
            "input": "10 5\n5 4 5 2 4\n29 49 33 12 55 15 32 62 37\n61 26 7 58 15 22 8 58\n37 16 16 39 20 14 58\n10 27 14 3 19 55\n53 13 37 44 52\n23 13 58 4\n69 80 29\n89 28\n3\n",
            "output": "74\n"
        },
        {
            "input": "6 4\n1 2 2 1 2\n5 172 99 99 11\n10 99 99 11\n10 99 11\n12 14\n2\n",
            "output": "48\n"
        },
        {
            "input": "10 5\n5 4 5 2 4\n29 49 33 12 55 15 32 62 37\n61 26 7 58 15 22 8 58\n37 16 16 39 20 14 58\n10 27 14 3 19 55\n53 13 37 44 52\n23 8 58 4\n69 80 29\n89 28\n3\n",
            "output": "72\n"
        },
        {
            "input": "10 5\n5 3 3 2 1\n29 49 33 48 55 15 32 62 37\n61 26 15 95 15 22 11 58\n37 16 9 51 20 14 58\n9 15 40 1 19 27\n15 13 37 44 52\n23 59 58 4\n69 80 29\n89 28\n48\n",
            "output": "97\n"
        },
        {
            "input": "10 5\n5 4 5 2 4\n29 49 33 12 55 15 32 89 37\n61 26 3 58 13 22 8 58\n37 16 16 39 20 14 58\n10 27 14 3 19 55\n53 13 37 22 52\n23 8 58 4\n69 80 29\n89 52\n3\n",
            "output": "68\n"
        },
        {
            "input": "10 5\n5 4 5 2 4\n29 49 33 21 55 15 32 89 37\n61 26 3 58 13 22 8 58\n37 16 16 39 20 14 58\n10 27 14 3 19 55\n53 13 37 22 52\n23 8 58 4\n69 80 29\n89 52\n3\n",
            "output": "71\n"
        },
        {
            "input": "10 5\n5 4 5 2 4\n29 49 33 21 55 15 32 89 37\n61 26 5 58 13 22 8 58\n37 16 16 39 20 14 58\n10 27 14 3 19 55\n53 13 37 22 52\n23 8 58 4\n69 80 29\n89 52\n3\n",
            "output": "73\n"
        },
        {
            "input": "10 5\n5 4 5 1 4\n29 49 23 21 55 15 6 89 37\n61 26 5 58 13 22 8 58\n37 16 16 39 20 14 58\n10 27 14 5 19 55\n53 13 37 22 52\n23 8 58 4\n69 80 29\n89 73\n3\n",
            "output": "66\n"
        },
        {
            "input": "10 5\n5 4 5 1 4\n29 49 23 21 55 15 6 89 37\n61 26 5 58 13 22 8 58\n37 16 16 39 20 13 58\n10 27 14 5 19 55\n53 13 37 22 52\n23 8 58 4\n69 80 29\n89 73\n3\n",
            "output": "65\n"
        },
        {
            "input": "5 1\n3\n67 62 64 5\n45 84 10\n103 64\n29\n",
            "output": "89\n"
        },
        {
            "input": "10 5\n5 3 4 2 5\n61 54 31 1 61 51 55 61 37\n11 20 7 68 37 4 68 24\n57 62 53 67 34 51 34\n31 18 14 33 23 26\n33 51 27 31 50\n33 48 94 19\n68 18 84\n74 74\n88\n",
            "output": "123\n"
        },
        {
            "input": "4 3\n1 2 2\n68 44 7\n2 31\n32\n",
            "output": "40\n"
        },
        {
            "input": "4 1\n2\n45 53 26\n82 43\n7\n",
            "output": "76\n"
        },
        {
            "input": "6 5\n1 2 2 2 3\n10 99 99 99 11\n10 99 99 11\n10 99 11\n10 11\n11\n",
            "output": "51\n"
        },
        {
            "input": "4 3\n2 1 3\n9 1 10\n7 9\n9\n",
            "output": "17\n"
        },
        {
            "input": "10 5\n4 3 4 2 1\n29 49 33 12 55 15 32 62 37\n61 26 15 58 15 22 8 58\n37 16 9 39 20 14 58\n10 15 40 3 19 55\n53 13 37 44 52\n23 59 58 4\n69 80 29\n89 28\n48\n",
            "output": "95\n"
        },
        {
            "input": "5 1\n3\n67 62 64 5\n23 84 3\n60 64\n29\n",
            "output": "60\n"
        },
        {
            "input": "4 2\n3 2\n54 59 82\n26 34\n40\n",
            "output": "119\n"
        },
        {
            "input": "5 3\n2 2 1\n29 44 37 47\n18 19 7\n34 68\n8\n",
            "output": "70\n"
        },
        {
            "input": "4 1\n2\n64 53 40\n82 43\n2\n",
            "output": "85\n"
        },
        {
            "input": "10 5\n5 1 4 2 5\n61 54 31 1 61 51 28 61 37\n11 20 4 68 37 4 68 24\n57 62 53 67 34 86 34\n31 18 14 33 23 26\n33 51 27 31 50\n33 48 94 19\n68 18 84\n74 74\n88\n",
            "output": "166\n"
        },
        {
            "input": "10 5\n1 5 2 1 1\n86 39 1 96 2 96 37 31 36\n92 95 17 23 14 31 32 24\n41 26 35 54 34 82 66\n71 37 94 75 1 23\n11 66 66 31 73\n90 21 36 4\n74 87 57\n43 26\n79\n",
            "output": "142\n"
        },
        {
            "input": "5 2\n1 4\n48 20 68 57\n63 55 1\n7 31\n5\n",
            "output": "33\n"
        },
        {
            "input": "4 1\n3 2\n54 59 31\n19 34\n54\n",
            "output": "52\n"
        },
        {
            "input": "5 4\n4 4 3 2\n35 65 14 20\n4 33 8\n37 46\n10\n",
            "output": "36\n"
        },
        {
            "input": "7 5\n4 1 3 1 2\n8 34 20 85 24 57\n7 32 48 85 41\n74 154 76 34\n28 95 63\n82 40\n69\n",
            "output": "159\n"
        },
        {
            "input": "4 3\n1 2 2\n68 25 15\n2 44\n18\n",
            "output": "35\n"
        },
        {
            "input": "6 4\n1 2 2 2 2\n10 172 99 99 13\n10 99 99 11\n10 99 11\n10 14\n2\n",
            "output": "46\n"
        },
        {
            "input": "10 5\n5 3 4 2 1\n29 49 33 24 55 15 32 62 37\n61 26 15 95 15 22 22 58\n37 16 9 39 20 14 58\n9 15 40 3 19 55\n53 13 37 44 52\n23 59 58 4\n69 80 29\n89 28\n48\n",
            "output": "110\n"
        },
        {
            "input": "7 5\n4 2 3 1 2\n8 34 17 85 24 57\n7 32 48 85 41\n74 218 76 34\n28 95 63\n82 40\n69\n",
            "output": "130\n"
        },
        {
            "input": "10 5\n5 3 4 3 6\n61 54 31 1 61 51 55 61 37\n11 3 4 68 37 4 68 24\n57 62 53 67 34 51 34\n23 18 28 33 23 26\n33 51 27 10 50\n33 48 94 19\n68 18 84\n74 74\n46\n",
            "output": "107\n"
        },
        {
            "input": "10 5\n1 5 2 1 1\n86 39 1 96 2 96 37 31 36\n92 95 17 23 14 31 60 24\n41 26 35 54 34 82 66\n71 41 94 75 1 23\n56 66 66 31 73\n90 21 36 4\n74 19 57\n39 26\n79\n",
            "output": "135\n"
        },
        {
            "input": "10 5\n5 3 4 2 5\n61 9 24 1 22 51 28 61 37\n11 20 4 68 37 4 68 44\n57 62 53 67 34 86 34\n31 18 14 33 23 26\n33 51 27 31 50\n33 48 94 19\n68 18 73\n74 74\n88\n",
            "output": "109\n"
        },
        {
            "input": "5 2\n1 5\n48 20 68 2\n87 55 1\n7 13\n31\n",
            "output": "23\n"
        },
        {
            "input": "4 3\n1 2 2\n68 40 10\n2 44\n16\n",
            "output": "28\n"
        },
        {
            "input": "5 2\n4 4 3 2\n35 5 14 20\n4 33 8\n37 42\n10\n",
            "output": "29\n"
        },
        {
            "input": "10 5\n5 4 5 2 4\n29 49 33 12 55 15 32 62 37\n61 26 7 58 13 22 8 58\n37 16 16 39 20 11 58\n10 27 14 3 19 55\n53 13 37 44 52\n23 8 58 4\n69 80 29\n89 28\n3\n",
            "output": "69\n"
        },
        {
            "input": "10 5\n5 3 3 2 1\n29 49 33 48 55 15 32 62 37\n61 26 15 95 15 22 11 58\n37 16 5 51 20 14 58\n9 15 40 1 19 27\n15 13 37 44 52\n23 59 58 4\n69 80 29\n89 28\n48\n",
            "output": "93\n"
        },
        {
            "input": "5 3\n4 4 3 1\n23 7 14 20\n2 33 8\n37 42\n10\n",
            "output": "25\n"
        },
        {
            "input": "10 5\n5 3 3 2 1\n29 49 33 48 55 15 32 7 37\n61 26 15 95 15 22 11 58\n37 16 9 51 20 14 58\n0 15 40 1 19 27\n15 13 37 44 52\n23 59 58 4\n69 80 29\n16 28\n48\n",
            "output": "77\n"
        },
        {
            "input": "10 5\n5 4 5 2 4\n29 49 33 12 55 15 32 89 37\n61 26 3 58 13 22 8 4\n37 16 16 39 20 14 58\n10 27 14 3 19 55\n53 13 37 22 52\n23 8 58 4\n69 80 29\n89 52\n3\n",
            "output": "64\n"
        },
        {
            "input": "10 5\n10 3 3 2 1\n13 49 33 48 55 15 32 7 37\n61 26 15 95 15 22 11 58\n37 16 9 8 20 14 58\n9 15 40 1 19 27\n15 13 37 44 52\n23 59 78 4\n69 80 30\n16 28\n48\n",
            "output": "79\n"
        },
        {
            "input": "2 1\n3\n67 62 64 5\n45 84 10\n103 64\n29\n",
            "output": "67\n"
        },
        {
            "input": "4 2\n3 4\n54 59 43\n19 34\n40\n",
            "output": "96\n"
        },
        {
            "input": "5 1\n3\n67 62 64 3\n23 84 3\n60 64\n29\n",
            "output": "58\n"
        },
        {
            "input": "4 2\n3 2\n54 59 82\n19 56\n75\n",
            "output": "134\n"
        },
        {
            "input": "5 3\n2 2 1\n1 44 61 47\n18 19 10\n34 68\n8\n",
            "output": "53\n"
        },
        {
            "input": "10 5\n5 3 4 3 6\n61 54 16 1 61 51 55 61 37\n1 20 4 68 37 4 68 24\n57 62 53 67 34 51 34\n31 18 28 33 23 26\n33 51 27 31 50\n33 48 94 19\n68 18 84\n74 74\n46\n",
            "output": "104\n"
        },
        {
            "input": "10 5\n5 4 5 2 4\n29 4 33 12 55 15 32 62 37\n61 26 15 58 15 22 8 58\n37 16 16 39 20 14 58\n10 15 40 3 19 55\n53 13 37 44 52\n23 13 58 4\n69 80 29\n89 28\n31\n",
            "output": "81\n"
        },
        {
            "input": "6 4\n1 2 2 2 2\n10 172 99 99 9\n10 99 160 11\n10 99 11\n10 14\n11\n",
            "output": "42\n"
        },
        {
            "input": "5 4\n4 4 3 2\n3 5 14 20\n2 33 5\n37 46\n16\n",
            "output": "24\n"
        },
        {
            "input": "10 5\n5 3 4 2 5\n61 0 24 1 22 51 28 61 37\n11 20 4 68 37 4 45 44\n57 62 53 67 34 86 34\n41 18 14 33 23 26\n33 51 27 31 50\n33 48 94 19\n68 18 73\n74 74\n88\n",
            "output": "100\n"
        },
        {
            "input": "5 4\n4 4 3 2\n35 5 14 20\n1 33 5\n37 46\n10\n",
            "output": "21\n"
        },
        {
            "input": "10 5\n5 4 5 1 6\n29 49 23 21 29 15 6 89 37\n61 26 5 58 13 22 8 58\n37 16 16 39 20 13 58\n10 27 14 5 19 55\n53 13 37 22 52\n11 8 58 4\n69 80 29\n89 73\n3\n",
            "output": "63\n"
        },
        {
            "input": "3 1\n2\n9 68\n1\n",
            "output": "10\n"
        },
        {
            "input": "10 5\n1 5 1 1 1\n86 39 1 96 2 96 37 31 36\n92 95 17 23 22 2 32 24\n41 26 14 54 34 82 66\n71 37 94 75 1 23\n56 66 66 75 73\n90 21 36 4\n74 87 57\n43 26\n79\n",
            "output": "115\n"
        },
        {
            "input": "2 1\n2\n45 53 7\n82 43\n7\n",
            "output": "45\n"
        },
        {
            "input": "10 5\n5 3 4 3 5\n61 54 31 1 61 51 55 61 37\n11 20 4 68 37 4 68 24\n57 62 53 67 34 51 34\n31 18 14 33 23 26\n33 51 27 31 50\n33 48 94 19\n68 18 84\n74 74\n46\n",
            "output": "120\n"
        },
        {
            "input": "5 1\n3\n113 62 64 5\n45 84 3\n60 64\n29\n",
            "output": "82\n"
        },
        {
            "input": "10 5\n5 3 4 2 5\n61 54 31 1 61 51 28 61 37\n11 20 4 68 37 4 68 24\n57 62 53 67 34 86 34\n31 18 14 33 23 26\n33 51 27 31 50\n33 48 94 19\n68 18 84\n74 74\n88\n",
            "output": "120\n"
        },
        {
            "input": "4 2\n3 2\n54 59 82\n19 34\n54\n",
            "output": "112\n"
        },
        {
            "input": "5 3\n2 2 1\n52 44 61 47\n18 19 7\n34 68\n8\n",
            "output": "80\n"
        },
        {
            "input": "10 5\n1 5 2 1 1\n86 39 1 96 2 96 37 31 36\n92 95 17 23 14 31 32 24\n41 26 35 54 34 82 66\n71 37 94 75 1 23\n56 66 66 31 73\n90 21 36 4\n74 87 57\n43 26\n79\n",
            "output": "148\n"
        },
        {
            "input": "5 2\n1 4\n48 20 68 57\n63 55 1\n7 31\n31\n",
            "output": "59\n"
        },
        {
            "input": "4 1\n2\n64 30 40\n82 43\n7\n",
            "output": "80\n"
        },
        {
            "input": "6 4\n1 2 2 2 2\n10 172 99 99 11\n10 99 99 11\n10 99 11\n10 11\n11\n",
            "output": "43\n"
        },
        {
            "input": "10 5\n5 3 4 2 1\n29 49 33 12 55 15 32 62 37\n61 26 15 95 15 22 11 58\n37 16 9 39 20 14 58\n10 15 40 3 19 55\n53 13 37 44 52\n23 59 58 4\n69 80 29\n89 28\n48\n",
            "output": "98\n"
        },
        {
            "input": "10 5\n5 3 4 2 5\n61 54 31 1 61 51 28 61 37\n11 20 4 68 37 4 68 44\n57 62 53 67 34 86 34\n31 18 14 33 23 26\n33 51 27 31 50\n33 48 94 19\n68 18 84\n74 74\n88\n",
            "output": "120\n"
        },
        {
            "input": "5 4\n4 4 3 2\n35 65 14 20\n2 33 8\n37 46\n10\n",
            "output": "34\n"
        },
        {
            "input": "10 5\n5 3 4 3 6\n61 54 31 1 61 51 55 61 37\n11 20 4 68 37 4 68 24\n57 62 53 67 34 51 34\n31 18 28 33 23 26\n33 51 27 31 50\n33 48 94 19\n68 18 84\n74 74\n46\n",
            "output": "129\n"
        },
        {
            "input": "5 3\n2 2 1\n52 44 61 47\n18 10 7\n34 68\n8\n",
            "output": "80\n"
        },
        {
            "input": "10 5\n1 5 2 1 1\n86 39 1 96 2 96 37 31 36\n92 95 17 23 14 31 32 24\n41 26 35 54 34 82 66\n71 37 94 75 1 23\n56 66 66 31 73\n90 21 36 4\n74 87 57\n39 26\n79\n",
            "output": "148\n"
        },
        {
            "input": "5 2\n1 5\n48 20 68 57\n63 55 1\n7 31\n31\n",
            "output": "59\n"
        },
        {
            "input": "4 3\n1 2 2\n68 25 7\n2 44\n18\n",
            "output": "27\n"
        },
        {
            "input": "4 1\n2\n64 30 40\n120 43\n7\n",
            "output": "80\n"
        },
        {
            "input": "10 5\n5 3 4 2 1\n29 49 33 12 55 15 32 62 37\n61 26 15 95 15 22 11 58\n37 16 9 39 20 14 58\n9 15 40 3 19 55\n53 13 37 44 52\n23 59 58 4\n69 80 29\n89 28\n48\n",
            "output": "98\n"
        },
        {
            "input": "5 1\n3\n113 102 64 5\n50 84 3\n60 64\n29\n",
            "output": "87\n"
        },
        {
            "input": "10 5\n5 3 4 2 5\n61 54 24 1 61 51 28 61 37\n11 20 4 68 37 4 68 44\n57 62 53 67 34 86 34\n31 18 14 33 23 26\n33 51 27 31 50\n33 48 94 19\n68 18 84\n74 74\n88\n",
            "output": "120\n"
        },
        {
            "input": "7 5\n4 1 3 1 2\n8 34 17 85 24 57\n7 32 48 85 41\n74 154 76 34\n28 95 63\n82 40\n69\n",
            "output": "156\n"
        },
        {
            "input": "5 3\n2 2 1\n52 44 61 47\n18 10 7\n34 44\n8\n",
            "output": "80\n"
        },
        {
            "input": "10 5\n1 5 2 1 1\n86 39 1 96 2 96 37 31 36\n92 95 17 23 14 31 32 24\n41 26 35 54 34 82 66\n71 41 94 75 1 23\n56 66 66 31 73\n90 21 36 4\n74 87 57\n39 26\n79\n",
            "output": "148\n"
        },
        {
            "input": "5 2\n1 5\n48 20 68 72\n63 55 1\n7 31\n31\n",
            "output": "59\n"
        },
        {
            "input": "4 3\n1 2 2\n68 25 6\n2 44\n18\n",
            "output": "26\n"
        },
        {
            "input": "4 1\n2\n64 30 36\n120 43\n7\n",
            "output": "80\n"
        },
        {
            "input": "10 5\n5 4 5 2 4\n29 49 33 12 55 15 32 62 37\n61 26 15 58 15 22 8 58\n37 16 16 39 20 14 58\n10 15 14 3 19 55\n53 13 37 44 52\n23 13 58 4\n69 80 29\n89 28\n31\n",
            "output": "92\n"
        },
        {
            "input": "6 4\n1 2 2 2 2\n10 172 99 99 11\n10 99 99 11\n10 99 11\n10 14\n2\n",
            "output": "44\n"
        },
        {
            "input": "10 5\n5 3 4 2 5\n61 54 24 1 61 51 28 61 37\n11 20 4 68 37 4 68 44\n57 62 53 67 34 86 34\n31 18 14 33 23 26\n33 51 27 31 50\n33 48 94 19\n68 18 73\n74 74\n88\n",
            "output": "120\n"
        },
        {
            "input": "5 4\n4 4 3 2\n35 48 14 20\n2 33 5\n37 46\n10\n",
            "output": "31\n"
        },
        {
            "input": "7 5\n4 1 3 1 2\n8 34 17 85 24 57\n7 32 48 85 41\n74 218 76 34\n28 95 63\n82 40\n69\n",
            "output": "156\n"
        },
        {
            "input": "4 3\n1 2 2\n68 25 10\n2 44\n18\n",
            "output": "30\n"
        },
        {
            "input": "4 1\n2\n64 30 36\n154 43\n7\n",
            "output": "80\n"
        },
        {
            "input": "10 5\n5 3 4 2 1\n29 49 33 24 55 15 32 62 37\n61 26 15 95 15 22 11 58\n37 16 9 39 20 14 58\n9 15 40 3 19 55\n15 13 37 44 52\n23 59 58 4\n69 80 29\n89 28\n48\n",
            "output": "99\n"
        },
        {
            "input": "10 5\n5 3 4 3 6\n61 54 31 1 61 51 55 61 37\n11 20 4 68 37 4 68 24\n57 62 53 67 34 51 57\n23 18 28 33 23 26\n33 51 27 10 50\n33 48 94 19\n68 18 84\n74 74\n46\n",
            "output": "108\n"
        },
        {
            "input": "5 2\n1 5\n48 20 68 2\n87 55 1\n7 31\n31\n",
            "output": "41\n"
        },
        {
            "input": "4 3\n1 2 2\n68 40 10\n2 44\n18\n",
            "output": "30\n"
        },
        {
            "input": "10 5\n5 4 5 2 4\n29 49 33 12 55 15 32 62 37\n61 26 7 58 15 22 8 58\n37 16 16 39 20 14 58\n10 27 14 3 19 55\n53 13 37 44 52\n23 13 58 4\n69 80 29\n89 28\n31\n",
            "output": "84\n"
        },
        {
            "input": "6 4\n1 2 2 1 2\n5 172 99 99 11\n10 99 99 11\n10 99 11\n10 14\n2\n",
            "output": "47\n"
        },
        {
            "input": "10 5\n5 3 4 2 1\n29 49 33 48 55 15 32 62 37\n61 26 15 95 15 22 11 58\n37 16 9 39 20 14 58\n9 15 40 3 19 55\n15 13 37 44 52\n23 59 58 4\n69 80 29\n89 28\n48\n",
            "output": "99\n"
        },
        {
            "input": "10 5\n5 3 4 2 5\n61 54 24 1 22 51 28 61 37\n11 20 4 68 37 4 68 44\n57 62 53 67 34 86 34\n41 18 14 33 23 26\n33 51 27 31 50\n33 48 94 19\n68 18 73\n74 74\n88\n",
            "output": "111\n"
        },
        {
            "input": "5 2\n4 4 3 2\n35 5 14 20\n2 33 5\n37 46\n10\n",
            "output": "27\n"
        },
        {
            "input": "10 5\n5 3 3 2 1\n29 49 33 48 55 15 32 62 37\n61 26 15 95 15 22 11 58\n37 16 9 39 20 14 58\n9 15 40 3 19 55\n15 13 37 44 52\n23 59 58 4\n69 80 29\n89 28\n48\n",
            "output": "99\n"
        },
        {
            "input": "5 1\n3\n113 102 64 1\n23 66 4\n60 64\n29\n",
            "output": "57\n"
        },
        {
            "input": "10 5\n5 3 4 2 5\n61 54 24 1 22 51 28 61 37\n11 20 4 68 37 4 68 44\n57 62 53 67 34 153 34\n41 18 14 33 23 26\n33 51 27 31 50\n33 48 94 19\n68 18 73\n74 74\n88\n",
            "output": "111\n"
        },
        {
            "input": "5 2\n4 4 3 2\n35 5 14 20\n2 33 5\n37 42\n10\n",
            "output": "27\n"
        },
        {
            "input": "6 4\n1 2 2 1 2\n5 172 106 99 11\n10 99 99 11\n10 99 11\n12 14\n2\n",
            "output": "48\n"
        },
        {
            "input": "10 5\n5 3 3 2 1\n29 49 33 48 55 15 32 62 37\n61 26 15 95 15 22 11 58\n37 16 9 51 20 14 58\n9 15 40 3 19 55\n15 13 37 44 52\n23 59 58 4\n69 80 29\n89 28\n48\n",
            "output": "99\n"
        },
        {
            "input": "5 1\n3\n113 179 64 1\n23 66 4\n60 64\n29\n",
            "output": "57\n"
        },
        {
            "input": "5 2\n4 4 3 2\n35 5 14 20\n2 33 8\n37 42\n10\n",
            "output": "27\n"
        },
        {
            "input": "10 5\n5 4 5 2 4\n29 49 33 12 55 15 32 62 37\n61 26 7 58 13 22 8 58\n37 16 16 39 20 14 58\n10 27 14 3 19 55\n53 13 37 44 52\n23 8 58 4\n69 80 29\n89 28\n3\n",
            "output": "72\n"
        },
        {
            "input": "6 4\n1 2 2 1 2\n9 172 106 99 11\n10 99 99 11\n10 99 11\n12 14\n2\n",
            "output": "48\n"
        },
        {
            "input": "10 5\n5 3 3 2 1\n29 49 33 48 55 15 32 62 37\n61 26 15 95 15 22 11 58\n37 16 9 51 20 14 58\n9 15 40 3 19 27\n15 13 37 44 52\n23 59 58 4\n69 80 29\n89 28\n48\n",
            "output": "99\n"
        },
        {
            "input": "5 1\n3\n113 179 64 1\n23 66 4\n60 119\n29\n",
            "output": "57\n"
        },
        {
            "input": "5 2\n4 4 3 1\n35 5 14 20\n2 33 8\n37 42\n10\n",
            "output": "26\n"
        },
        {
            "input": "10 5\n5 4 5 2 4\n29 49 33 12 55 15 32 62 37\n61 26 7 58 13 22 8 58\n37 16 16 39 20 14 58\n10 27 14 3 19 55\n53 13 37 22 52\n23 8 58 4\n69 80 29\n89 28\n3\n",
            "output": "72\n"
        },
        {
            "input": "5 2\n4 4 3 1\n35 7 14 20\n2 33 8\n37 42\n10\n",
            "output": "26\n"
        },
        {
            "input": "10 5\n5 4 5 2 4\n29 49 33 12 55 15 32 62 37\n61 26 7 58 13 22 8 58\n37 16 16 39 20 14 58\n10 27 14 3 19 55\n53 13 37 22 52\n23 8 58 4\n69 80 29\n89 52\n3\n",
            "output": "72\n"
        },
        {
            "input": "10 5\n5 3 3 2 1\n29 49 33 48 55 15 32 62 37\n61 26 15 95 15 22 11 58\n37 16 9 51 20 14 58\n9 15 40 1 19 27\n15 13 37 44 52\n23 59 58 4\n69 80 29\n16 28\n48\n",
            "output": "94\n"
        },
        {
            "input": "5 2\n4 4 3 1\n23 7 14 20\n2 33 8\n37 42\n10\n",
            "output": "26\n"
        },
        {
            "input": "10 5\n5 4 5 2 4\n29 49 33 12 55 15 32 89 37\n61 26 7 58 13 22 8 58\n37 16 16 39 20 14 58\n10 27 14 3 19 55\n53 13 37 22 52\n23 8 58 4\n69 80 29\n89 52\n3\n",
            "output": "72\n"
        },
        {
            "input": "10 5\n5 3 3 2 1\n29 49 33 48 55 15 32 7 37\n61 26 15 95 15 22 11 58\n37 16 9 51 20 14 58\n9 15 40 1 19 27\n15 13 37 44 52\n23 59 58 4\n69 80 29\n16 28\n48\n",
            "output": "86\n"
        },
        {
            "input": "5 2\n4 4 3 1\n23 7 14 20\n2 33 5\n37 42\n10\n",
            "output": "26\n"
        },
        {
            "input": "10 5\n5 3 3 2 1\n13 49 33 48 55 15 32 7 37\n61 26 15 95 15 22 11 58\n37 16 9 51 20 14 58\n9 15 40 1 19 27\n15 13 37 44 52\n23 59 58 4\n69 80 29\n16 28\n48\n",
            "output": "86\n"
        },
        {
            "input": "5 2\n4 8 3 1\n23 7 14 20\n2 33 5\n37 42\n10\n",
            "output": "26\n"
        },
        {
            "input": "10 5\n10 3 3 2 1\n13 49 33 48 55 15 32 7 37\n61 26 15 95 15 22 11 58\n37 16 9 51 20 14 58\n9 15 40 1 19 27\n15 13 37 44 52\n23 59 58 4\n69 80 29\n16 28\n48\n",
            "output": "86\n"
        },
        {
            "input": "5 2\n4 8 3 1\n40 7 14 20\n2 33 5\n37 42\n10\n",
            "output": "26\n"
        },
        {
            "input": "10 5\n10 3 3 2 1\n13 49 33 48 55 15 32 7 37\n61 26 15 95 15 22 11 58\n37 16 9 51 20 14 58\n9 15 40 1 19 27\n15 13 37 44 52\n23 59 78 4\n69 80 29\n16 28\n48\n",
            "output": "86\n"
        },
        {
            "input": "5 2\n4 8 3 1\n31 7 14 20\n2 33 5\n37 42\n10\n",
            "output": "26\n"
        },
        {
            "input": "10 5\n5 4 5 1 4\n29 49 33 21 55 15 32 89 37\n61 26 5 58 13 22 8 58\n37 16 16 39 20 14 58\n10 27 14 3 19 55\n53 13 37 22 52\n23 8 58 4\n69 80 29\n89 52\n3\n",
            "output": "73\n"
        },
        {
            "input": "10 5\n10 3 3 2 1\n13 49 33 48 55 15 32 7 37\n61 26 15 95 15 22 11 58\n37 16 9 51 20 14 58\n9 15 40 1 19 27\n15 13 37 44 52\n23 59 78 4\n69 80 30\n16 28\n48\n",
            "output": "86\n"
        },
        {
            "input": "10 5\n5 4 5 1 4\n29 49 23 21 55 15 32 89 37\n61 26 5 58 13 22 8 58\n37 16 16 39 20 14 58\n10 27 14 3 19 55\n53 13 37 22 52\n23 8 58 4\n69 80 29\n89 52\n3\n",
            "output": "73\n"
        },
        {
            "input": "10 5\n10 3 3 2 1\n13 49 33 48 55 15 32 7 37\n61 26 15 95 15 22 11 58\n37 16 9 51 20 14 58\n9 15 40 1 19 27\n15 13 37 44 52\n23 82 78 4\n69 80 30\n16 28\n48\n",
            "output": "86\n"
        },
        {
            "input": "10 5\n5 4 5 1 4\n29 49 23 21 55 15 32 89 37\n61 26 5 58 13 22 8 58\n37 16 16 39 20 14 58\n10 27 14 3 19 55\n53 13 37 22 52\n23 8 58 4\n69 80 29\n89 73\n3\n",
            "output": "73\n"
        },
        {
            "input": "10 5\n10 3 3 2 1\n13 49 33 48 55 15 32 7 37\n61 26 15 95 15 22 11 58\n37 16 9 51 20 14 58\n9 15 40 1 19 27\n8 13 37 44 52\n23 82 78 4\n69 80 30\n16 28\n48\n",
            "output": "84\n"
        },
        {
            "input": "10 5\n5 4 5 1 4\n29 49 23 21 55 15 32 89 37\n61 26 5 58 13 22 8 58\n37 16 16 39 20 14 58\n10 27 14 5 19 55\n53 13 37 22 52\n23 8 58 4\n69 80 29\n89 73\n3\n",
            "output": "75\n"
        },
        {
            "input": "10 5\n10 3 3 2 1\n13 92 33 48 55 15 32 7 37\n61 26 15 95 15 22 11 58\n37 16 9 51 20 14 58\n9 15 40 1 19 27\n8 13 37 44 52\n23 82 78 4\n69 80 30\n16 28\n48\n",
            "output": "84\n"
        },
        {
            "input": "10 5\n10 3 3 2 1\n13 92 33 48 55 15 32 7 37\n61 26 15 95 15 22 11 58\n37 16 9 51 20 14 58\n9 15 40 1 19 27\n8 13 37 44 52\n23 82 72 4\n69 80 30\n16 28\n48\n",
            "output": "84\n"
        },
        {
            "input": "10 5\n10 3 3 2 1\n13 92 33 48 55 15 32 7 37\n61 26 15 95 15 22 11 58\n37 16 9 51 20 24 58\n9 15 40 1 19 27\n8 13 37 44 52\n23 82 72 4\n69 80 30\n16 28\n48\n",
            "output": "86\n"
        },
        {
            "input": "10 5\n5 4 5 1 4\n29 49 23 21 29 15 6 89 37\n61 26 5 58 13 22 8 58\n37 16 16 39 20 13 58\n10 27 14 5 19 55\n53 13 37 22 52\n23 8 58 4\n69 80 29\n89 73\n3\n",
            "output": "65\n"
        },
        {
            "input": "10 5\n5 4 5 1 4\n29 49 23 21 29 15 6 89 37\n61 26 5 58 13 22 8 58\n37 16 16 39 20 13 58\n10 27 14 5 19 55\n53 13 37 22 52\n23 8 58 4\n69 80 24\n89 73\n3\n",
            "output": "65\n"
        },
        {
            "input": "4 2\n3 4\n54 59 41\n19 34\n40\n",
            "output": "94\n"
        },
        {
            "input": "5 4\n4 4 6 2\n35 65 14 20\n2 26 4\n37 52\n10\n",
            "output": "30\n"
        },
        {
            "input": "3 1\n1\n54 68\n1\n",
            "output": "55\n"
        },
        {
            "input": "10 5\n5 3 4 3 5\n61 54 31 1 61 51 55 61 37\n11 20 4 68 12 4 68 24\n57 62 53 67 34 51 34\n31 18 14 33 23 26\n33 51 27 31 50\n33 48 94 19\n68 18 84\n74 74\n88\n",
            "output": "120\n"
        },
        {
            "input": "10 5\n1 5 1 1 1\n86 39 1 96 2 96 37 31 36\n92 95 17 23 22 31 32 24\n41 26 35 54 34 82 66\n71 37 94 75 1 23\n56 66 66 75 73\n90 21 36 4\n74 87 57\n43 26\n79\n",
            "output": "156\n"
        },
        {
            "input": "5 1\n1 4\n48 20 68 57\n63 68 19\n7 31\n31\n",
            "output": "87\n"
        },
        {
            "input": "3 2\n2 1\n1 30\n38\n",
            "output": "31\n"
        },
        {
            "input": "10 5\n5 5 5 2 4\n29 49 33 12 55 15 32 62 37\n61 26 15 58 15 22 8 58\n37 16 9 39 20 14 58\n10 15 40 3 19 55\n53 13 37 44 52\n23 59 58 4\n69 80 29\n89 28\n48\n",
            "output": "88\n"
        },
        {
            "input": "10 5\n5 3 4 2 5\n61 54 31 1 61 51 55 61 37\n11 20 4 68 37 4 68 24\n57 62 53 67 34 86 34\n31 18 14 33 23 26\n33 51 27 31 50\n33 48 94 19\n68 18 84\n74 74\n131\n",
            "output": "120\n"
        },
        {
            "input": "5 4\n4 4 3 2\n35 65 11 20\n2 33 4\n37 52\n10\n",
            "output": "27\n"
        },
        {
            "input": "7 5\n3 1 3 1 2\n8 34 17 96 24 57\n7 32 48 85 41\n74 77 76 65\n28 95 63\n82 40\n69\n",
            "output": "187\n"
        },
        {
            "input": "3 1\n1\n54 68\n30\n",
            "output": "84\n"
        },
        {
            "input": "10 5\n9 3 4 3 5\n61 54 31 1 61 51 55 61 37\n11 20 4 68 37 4 68 24\n57 62 53 67 34 51 34\n31 18 14 33 23 26\n33 51 27 31 50\n33 48 94 19\n68 18 84\n74 74\n46\n",
            "output": "120\n"
        },
        {
            "input": "10 5\n1 5 2 1 1\n86 39 1 96 2 96 37 31 36\n92 95 17 23 14 31 32 26\n41 26 35 54 34 82 66\n71 37 94 75 1 23\n56 66 66 75 73\n90 21 36 4\n74 87 57\n43 26\n79\n",
            "output": "148\n"
        },
        {
            "input": "4 3\n1 2 2\n68 44 7\n2 44\n34\n",
            "output": "43\n"
        },
        {
            "input": "10 5\n5 4 5 2 4\n29 49 33 12 55 15 32 62 37\n61 26 15 58 15 22 8 58\n37 16 9 39 20 14 58\n10 15 40 3 19 55\n53 13 37 44 52\n28 59 58 4\n69 80 29\n89 28\n31\n",
            "output": "88\n"
        },
        {
            "input": "6 4\n1 2 2 2 2\n10 99 4 99 11\n10 99 99 11\n10 99 11\n10 11\n11\n",
            "output": "43\n"
        },
        {
            "input": "10 5\n5 3 4 2 1\n29 49 33 12 55 15 32 16 37\n61 26 15 58 15 22 11 58\n37 16 9 39 20 14 58\n10 15 40 3 19 55\n53 13 37 44 52\n23 59 58 4\n69 80 29\n89 28\n48\n",
            "output": "98\n"
        },
        {
            "input": "5 1\n5\n113 62 64 5\n45 84 3\n60 64\n29\n",
            "output": "82\n"
        },
        {
            "input": "4 2\n3 2\n54 59 82\n19 34\n75\n",
            "output": "112\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint read() {\n  int ret = 0;\n  char c = getchar();\n  while (c > '9' || c < '0') c = getchar();\n  while (c >= '0' && c <= '9')\n    ret = (ret << 3) + (ret << 1) + (c ^ 48), c = getchar();\n  return ret;\n}\nconst int maxn = 55;\nconst int maxk = 6;\nconst int maxm = 2500;\nconst int inf = 1e9;\nint n, k;\nint dlim[maxk];\nstruct edge {\n  int from, to, val;\n} e1[15], e2[maxm];\nint cnt1, cnt2;\nint ans;\nint d[maxk];\nbool ini[maxm], x[maxm], y[maxm];\nint dis[maxm], pre[maxm];\nstruct dsu {\n  int fa[maxn];\n  void prework() {\n    for (int i = 1; i <= n; i++) fa[i] = i;\n  }\n  int get(int x) { return x == fa[x] ? x : fa[x] = get(fa[x]); }\n  void merge(int x, int y) { fa[get(x)] = get(y); }\n  bool check(int x, int y) { return get(x) == get(y); }\n} S;\nqueue<int> q;\nbool inq[maxm];\nint ret = 0;\nbool deb = 0;\nstruct graph {\n  int head[maxm], ver[maxm * maxm], nxt[maxm * maxm], val[maxm * maxm], tot;\n  void add(int x, int y, int z) {\n    ver[++tot] = y;\n    val[tot] = z;\n    nxt[tot] = head[x];\n    head[x] = tot;\n  }\n  void clear() {\n    tot = 0;\n    for (int i = 1; i <= cnt2 + 2; i++) head[i] = 0;\n  }\n  int dis[maxm], pre[maxm], len[maxm];\n  bool inq[maxm];\n  void spfa() {\n    for (int i = 1; i <= cnt2 + 2; i++)\n      dis[i] = 0x3f3f3f3f, inq[i] = 0, pre[i] = 0;\n    dis[cnt2 + 1] = 0;\n    q.push(cnt2 + 1);\n    inq[cnt2 + 1] = 1;\n    while (!q.empty()) {\n      int now = q.front();\n      q.pop();\n      inq[now] = 0;\n      for (int i = head[now]; i; i = nxt[i])\n        if (dis[ver[i]] > dis[now] + val[i] ||\n            (dis[ver[i]] == dis[now] + val[i] && len[ver[i]] > len[now] + 1)) {\n          dis[ver[i]] = dis[now] + val[i];\n          len[ver[i]] = len[now] + 1;\n          pre[ver[i]] = now;\n          if (!inq[ver[i]]) q.push(ver[i]);\n          inq[ver[i]] = 1;\n        }\n    }\n  }\n  void update() {\n    int now = cnt2 + 2;\n    while (now) {\n      ini[now] ^= 1;\n      if (ini[now])\n        ret -= e2[now].val;\n      else\n        ret += e2[now].val;\n      now = pre[now];\n    }\n  }\n} o;\nbool calc(int chose) {\n  for (int i = 1; i <= k; i++) d[i] = 0;\n  S.prework();\n  for (int i = 1; i <= cnt1; i++)\n    if ((chose >> (i - 1)) & 1) {\n      d[e1[i].from]++, d[e1[i].to]++;\n      S.merge(e1[i].from, e1[i].to);\n    }\n  for (int i = 1; i <= cnt2; i++)\n    if (ini[i]) {\n      if (e2[i].from <= k) d[e2[i].from]++;\n      S.merge(e2[i].from, e2[i].to);\n    }\n  int s = cnt2 + 1, t = cnt2 + 2;\n  o.clear();\n  for (int i = 1; i <= cnt2; i++) {\n    if (ini[i])\n      x[i] = y[i] = 0;\n    else {\n      x[i] = (!S.check(e2[i].from, e2[i].to));\n      y[i] = (e2[i].from > k || d[e2[i].from] + 1 <= dlim[e2[i].from]);\n      if (x[i]) o.add(s, i, e2[i].val);\n      if (y[i]) o.add(i, t, 0);\n    }\n  }\n  for (int i = 1; i <= cnt2; i++) {\n    if (!ini[i]) continue;\n    S.prework();\n    for (int j = 1; j <= cnt2; j++)\n      if (ini[j] && j != i) S.merge(e2[j].from, e2[j].to);\n    for (int i = 1; i <= cnt1; i++)\n      if ((chose >> (i - 1)) & 1) S.merge(e1[i].from, e1[i].to);\n    for (int j = 1; j <= cnt2; j++) {\n      if (ini[j]) continue;\n      if (!S.check(e2[j].from, e2[j].to)) o.add(i, j, e2[j].val);\n      if (e2[j].from > k ||\n          d[e2[j].from] - (e2[j].from == e2[i].from) < dlim[e2[j].from])\n        o.add(j, i, -e2[i].val);\n    }\n  }\n  o.spfa();\n  if (o.dis[t] == 0x3f3f3f3f) return false;\n  o.update();\n  return true;\n}\nvoid solve(int chose) {\n  for (int i = 1; i <= k; i++) d[i] = 0;\n  S.prework();\n  ret = 0;\n  for (int i = 1; i <= cnt1; i++)\n    if ((chose >> (i - 1)) & 1) {\n      d[e1[i].from]++;\n      d[e1[i].to]++;\n      ret += e1[i].val;\n      if (d[e1[i].from] > dlim[e1[i].from]) return;\n      if (d[e1[i].to] > dlim[e1[i].to]) return;\n      if (S.check(e1[i].from, e1[i].to)) return;\n      S.merge(e1[i].from, e1[i].to);\n    }\n  for (int i = 1; i <= cnt2; i++) ini[i] = 0;\n  int cnt = 0;\n  if (ret > ans) return;\n  while (calc(chose)) {\n    if (ret > ans) return;\n  }\n  ret = 0;\n  bool flag = 1;\n  S.prework();\n  for (int i = 1; i <= cnt1; i++)\n    if ((chose >> (i - 1)) & 1) S.merge(e1[i].from, e1[i].to), ret += e1[i].val;\n  for (int i = 1; i <= cnt2; i++)\n    if (ini[i]) S.merge(e2[i].from, e2[i].to), ret += e2[i].val;\n  for (int i = 1; i <= n; i++)\n    if (!S.check(1, i)) return;\n  ans = min(ret, ans);\n}\nint main() {\n  n = read();\n  k = read();\n  for (int i = 1; i <= k; i++) dlim[i] = read();\n  for (int i = 1; i <= n - 1; i++)\n    for (int j = 1; j <= n - i; j++)\n      if (i <= k && i + j <= k) {\n        cnt1++;\n        e1[cnt1].from = i;\n        e1[cnt1].to = i + j;\n        e1[cnt1].val = read();\n      } else {\n        cnt2++;\n        e2[cnt2].from = i;\n        e2[cnt2].to = i + j;\n        e2[cnt2].val = read();\n      }\n  ans = inf;\n  for (int i = 0; i < (1 << cnt1); i++) solve(i);\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nconstexpr int maxn = 50;\nint w[maxn][maxn];\nint p[maxn];\nint gp(int u) { return p[u] == u ? u : p[u] = gp(p[u]); }\nvector<pair<int, int>> pr[100 + 1];\nint n, k, d[maxn], e[maxn];\npair<int, vector<pair<int, int>>> get(vector<pair<int, int>>& cur, int u,\n                                      int v) {\n  for (int i = 0; i < n; i += 1) p[i] = i;\n  vector<pair<int, int>> ncur;\n  LL nans = 0;\n  for (int i = 0; i < k; i += 1) e[i] = 0;\n  for (auto [x, y] : cur) {\n    if (w[u][v] < w[x][y]) {\n      int pu = gp(u), pv = gp(v);\n      if (pu != pv) {\n        p[pu] = pv;\n        ncur.push_back({u, v});\n        nans += w[u][v];\n        e[u] += 1;\n        e[v] += 1;\n      }\n    }\n    int px = gp(x), py = gp(y);\n    if (px != py) {\n      p[px] = py;\n      ncur.push_back({x, y});\n      nans += w[x][y];\n      e[x] += 1;\n      e[y] += 1;\n    }\n  }\n  for (int i = 0; i < k; i += 1)\n    if (e[i] > d[i]) return {INT_MAX, {}};\n  return {nans, ncur};\n}\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  cin >> n >> k;\n  for (int i = 0; i < k; i += 1) cin >> d[i];\n  for (int i = 0; i < n; i += 1)\n    for (int j = i + 1; j < n; j += 1) {\n      cin >> w[i][j];\n      w[j][i] = w[i][j];\n      pr[w[i][j]].push_back({i, j});\n    }\n  for (int i = k; i < n; i += 1) p[i] = i;\n  vector<pair<int, int>> p;\n  for (int i = 0; i < n; i += 1)\n    for (int j = i + 1; j < n; j += 1) p.push_back({i, j});\n  int res = INT_MAX;\n  srand(time(0));\n  for (int i = 0; i < 300; i += 1) {\n    random_shuffle(p.begin(), p.end());\n    int ans = 0;\n    vector<pair<int, int>> cur;\n    int r = rand() % (n - k) + k;\n    for (int i = 0; i < n; i += 1)\n      if (i != r) {\n        cur.push_back({i, r});\n        ans += w[i][r];\n      }\n    sort(cur.begin(), cur.end(),\n         [&](const pair<int, int>& p, const pair<int, int>& q) {\n           return w[p.first][p.second] < w[q.first][q.second];\n         });\n    while (true) {\n      res = min(res, ans);\n      int ok = 1;\n      for (auto [i, j] : p) {\n        auto [nans, ncur] = get(cur, i, j);\n        if (nans < ans) {\n          ans = nans;\n          ncur.swap(cur);\n          ok = 0;\n        }\n      }\n      if (ok) break;\n    }\n    res = min(res, ans);\n  }\n  cout << res;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 0x3f3f3f3f3f3f3f3f;\nconst int mo = 998244353;\nconst int inv2 = 499122177;\nconst double jzm = 0.9997;\nconst int zero = 5000;\nconst int orG = 3, invG = 332748118;\nconst double Pi = acos(-1.0);\nconst double eps = 1e-3;\ntemplate <typename _T>\n_T Fabs(_T x) {\n  return x < 0 ? -x : x;\n}\ntemplate <typename _T>\nvoid read(_T &x) {\n  _T f = 1;\n  x = 0;\n  char s = getchar();\n  while (s > '9' || s < '0') {\n    if (s == '-') f = -1;\n    s = getchar();\n  }\n  while ('0' <= s && s <= '9') {\n    x = (x << 3) + (x << 1) + (s ^ 48);\n    s = getchar();\n  }\n  x *= f;\n}\ntemplate <typename _T>\nvoid print(_T x) {\n  if (x < 0) {\n    x = (~x) + 1;\n    putchar('-');\n  }\n  if (x > 9) print(x / 10);\n  putchar(x % 10 + '0');\n}\nlong long gcd(long long a, long long b) { return !b ? a : gcd(b, a % b); }\nint add(int x, int y, int p) { return x + y < p ? x + y : x + y - p; }\nvoid Add(int &x, int y, int p) { x = add(x, y, p); }\nint qkpow(int a, int s, int p) {\n  int t = 1;\n  while (s) {\n    if (s & 1LL) t = 1ll * a * t % p;\n    a = 1ll * a * a % p;\n    s >>= 1LL;\n  }\n  return t;\n}\nint n, k, d[55], mp[55][55], t[55], fa[55], tota, totb, deg[55], summ, ans,\n    ord[55][55], sta[55], stak;\nbool cho[55][55], tmp[55][55], ap[55][55], fg[55];\nstruct edge {\n  int u, v, w;\n} a[2505], b[2505];\nbool cmp(edge x, edge y) { return x.w < y.w; }\nbool cmp1(int x, int y) { return t[x] < t[y]; }\ndouble Rand() {\n  return 1.0 * (rand() * RAND_MAX + rand()) / (RAND_MAX * RAND_MAX);\n}\nvoid makeSet(int x) {\n  for (int i = 1; i <= x; i++) fa[i] = i;\n}\nint findSet(int x) { return fa[x] == x ? x : fa[x] = findSet(fa[x]); }\nvoid unionSet(int a, int b) {\n  int u = findSet(a), v = findSet(b);\n  if (u != v) fa[u] = v;\n}\nvoid work(int x) {\n  for (int i = 1; i <= n; i++) {\n    if (ord[x][i] <= k && !fg[findSet(ord[x][i])]) continue;\n    if (ord[x][i] <= k && deg[ord[x][i]] == d[ord[x][i]]) continue;\n    unionSet(ord[x][i], x);\n    tmp[min(ord[x][i], x)][max(ord[x][i], x)] = 1;\n    deg[ord[x][i]]++;\n    deg[x]++;\n    break;\n  }\n}\nvoid sakura(double tp) {\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= n; j++) tmp[i][j] = 0;\n  for (int i = 1; i <= n; i++) deg[i] = fg[i] = 0;\n  summ = 0;\n  makeSet(n);\n  int tim = 0;\n  for (int i = 1; i <= tota; i++) {\n    int u = a[i].u, v = a[i].v, w = a[i].w;\n    if (!cho[u][v]) continue;\n    if (Rand() < tp) {\n      tmp[u][v] = 0;\n      continue;\n    }\n    tmp[u][v] = 1;\n    deg[u]++;\n    deg[v]++;\n    unionSet(u, v);\n    tim++;\n  }\n  random_shuffle(a + 1, a + tota + 1);\n  for (int i = 1; i <= tota; i++) {\n    int u = a[i].u, v = a[i].v, w = a[i].w;\n    if (tmp[u][v] || findSet(u) == findSet(v)) continue;\n    if (Rand() > tp || deg[u] == d[u] || deg[v] == d[v]) continue;\n    tmp[u][v] = 1;\n    deg[u]++;\n    deg[v]++;\n    unionSet(u, v);\n    tim++;\n  }\n  for (int i = k + 1; i <= n; i++) fg[findSet(i)] = 1;\n  tim = 0;\n  for (int i = 1; i <= k; i++) {\n    if (fg[findSet(i)]) continue;\n    int p = findSet(i), spc = 0;\n    for (int j = 1; j <= k; j++)\n      if (findSet(j) == p && deg[j] < d[j]) spc = j;\n    if (!spc) {\n      stak = 0;\n      for (int j = 1; j <= k; j++)\n        if (findSet(j) == p) sta[++stak] = j;\n      for (int j = 1; j <= stak; j++) {\n        int u = sta[j];\n        fa[u] = u;\n        deg[u] = 0;\n        for (int l = 1; l <= k; l++) tmp[l][u] = tmp[u][l] = 0;\n      }\n      for (int j = 1; j <= stak; j++) work(sta[j]), fg[findSet(sta[j])] = 1;\n    } else\n      work(spc), fg[findSet(spc)] = 1;\n  }\n  for (int i = 1; i <= totb; i++)\n    if (findSet(b[i].u) != findSet(b[i].v))\n      unionSet(b[i].u, b[i].v), deg[b[i].u]++, deg[b[i].v]++,\n          tmp[b[i].u][b[i].v] = 1;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++)\n      if (tmp[i][j]) summ += mp[i][j], tim++;\n}\nvoid nagisa() {\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) cho[i][j] = ap[i][j];\n  summ = 0;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++)\n      if (cho[i][j]) summ += mp[i][j];\n  for (int t = 1; t <= 500; t++) {\n    int now = summ;\n    sakura(0.5);\n    if (summ < now)\n      for (int i = 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++) cho[i][j] = tmp[i][j];\n    else\n      summ = now;\n  }\n  if (ans > summ) {\n    for (int i = 1; i <= n; i++)\n      for (int j = i + 1; j <= n; j++) ap[i][j] = cho[i][j];\n    ans = summ;\n  }\n  double nowT = 3000.0;\n  while (nowT > eps) {\n    int now = summ;\n    sakura(nowT);\n    double t = Rand();\n    if (ans > summ) {\n      for (int i = 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++) ap[i][j] = cho[i][j] = tmp[i][j];\n      ans = summ;\n    } else if (exp(1.0 * (now - summ) / nowT) > t)\n      for (int i = 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++) cho[i][j] = tmp[i][j];\n    else\n      summ = now;\n    nowT *= jzm;\n  }\n}\nsigned main() {\n  srand(time(NULL));\n  read(n);\n  read(k);\n  for (int i = 1; i <= k; i++) read(d[i]);\n  for (int i = k + 1; i <= n; i++) d[i] = n;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) {\n      read(mp[i][j]), mp[j][i] = mp[i][j];\n      if (i <= k)\n        a[++tota] = (edge){i, j, mp[i][j]};\n      else\n        b[++totb] = (edge){i, j, mp[i][j]};\n    }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) t[j] = mp[i][j];\n    for (int j = 1; j <= n; j++) ord[i][j] = j;\n    sort(ord[i] + 1, ord[i] + n + 1, cmp1);\n  }\n  sort(b + 1, b + totb + 1, cmp);\n  sakura(1.0);\n  ans = summ;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) ap[i][j] = cho[i][j] = tmp[i][j];\n  for (int i = 1; i <= 5; i++) nagisa();\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <typename T>\nbool chkmin(T &a, T b) {\n  return (b < a) ? a = b, 1 : 0;\n}\ntemplate <typename T>\nbool chkmax(T &a, T b) {\n  return (b > a) ? a = b, 1 : 0;\n}\nlong long ksm(long long a, long long b) {\n  if (b == 0) return 1;\n  long long ns = ksm(a, b >> 1);\n  ns = ns * ns % 998244353;\n  if (b & 1) ns = ns * a % 998244353;\n  return ns;\n}\nusing namespace std;\nconst int maxn = 305;\nstruct th {\n  int u, v;\n  int w;\n  th() {}\n  th(int a, int b, int c) { u = a, v = b, w = c; }\n} p[maxn];\nint n, k;\nint cnt = 0;\nint fa[maxn];\nint gfa(int a) {\n  if (fa[a] == a) return a;\n  return fa[a] = gfa(fa[a]);\n}\nvoid ini() {\n  for (int i = 1; i <= n; i++) fa[i] = i;\n}\nvoid lk(int a, int b) {\n  fa[gfa(a)] = gfa(b);\n  ;\n}\nvector<pair<int, int> > eg[maxn];\nint dis[maxn];\nint S, T;\nint pre[maxn];\nconst int N = 55;\nint fl[maxn];\nint d[N], cd[N];\nint w[N][N];\nvector<pair<int, int> > preg;\nint nans = 0;\nconst int inf = 50000;\nvoid ade(int u, int v, int w) { eg[u].push_back(make_pair(v, w)); }\nint q[maxn * maxn], fr, ed;\nint inq[maxn];\nbool bfs() {\n  S = cnt + 1, T = cnt + 2;\n  for (int i = 1; i <= T; i++) eg[i].clear();\n  vector<int> fls;\n  for (int i = 1; i <= cnt; i++) {\n    if (fl[i]) fls.push_back(i);\n  }\n  for (int i = 0; i <= cnt; i++) {\n    if (i != 0 && !fl[i]) continue;\n    ini();\n    for (auto v : preg) lk(v.first, v.second);\n    for (auto j : fls) {\n      if (j == i) continue;\n      lk(p[j].u, p[j].v);\n    }\n    int nid = i;\n    if (i == 0) nid = S;\n    for (int i = 1; i <= cnt; i++) {\n      if (fl[i]) continue;\n      if (gfa(p[i].u) != gfa(p[i].v)) ade(nid, i, inf - p[i].w);\n    }\n  }\n  for (int i = 0; i <= cnt; i++) {\n    if (i != 0 && !fl[i]) continue;\n    memset(cd, 0, sizeof(cd));\n    for (auto v : preg) cd[v.first] += 1, cd[v.second] += 1;\n    for (auto j : fls) {\n      if (j == i) continue;\n      cd[p[j].u] += 1, cd[p[j].v] += 1;\n    }\n    int nid = i;\n    if (i == 0) nid = T;\n    int nw = inf - p[nid].w;\n    if (nid == T) nw = 0;\n    for (int i = 1; i <= cnt; i++) {\n      if (fl[i]) continue;\n      if (cd[p[i].u] < d[p[i].u] && cd[p[i].v] < d[p[i].v]) ade(i, nid, -nw);\n    }\n  }\n  for (int i = 1; i <= T; i++) dis[i] = -inf, inq[i] = 0;\n  int fr = 0, ed = 0;\n  dis[S] = 0;\n  q[ed++] = S, inq[S] = 1;\n  while (fr < ed) {\n    int cur = q[fr++];\n    inq[cur] = 0;\n    for (auto v : eg[cur]) {\n      int eid = v.first, ew = v.second;\n      if (chkmax(dis[eid], dis[cur] + ew)) {\n        pre[eid] = cur;\n        if (!inq[eid]) q[ed++] = eid, inq[eid] = 1;\n      }\n    }\n  }\n  if (dis[T] <= 0) return 0;\n  vector<int> cc;\n  int ee = pre[T];\n  while (1) {\n    cc.push_back(ee);\n    ee = pre[ee];\n    if (ee == S) break;\n  }\n  nans += dis[T];\n  for (auto v : cc) fl[v] ^= 1;\n  return 1;\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 1; i <= k; i++) cin >> d[i];\n  for (int i = k + 1; i <= n; i++) d[i] = 1e9;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) scanf(\"%d\", &w[i][j]);\n  int ans = 1e9;\n  ini();\n  vector<array<int, 3> > u;\n  for (int i = k + 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) u.push_back({w[i][j], i, j});\n  sort(u.begin(), u.end());\n  for (auto s : u) {\n    if (gfa(s[1]) == gfa(s[2])) continue;\n    lk(s[1], s[2]);\n    p[++cnt] = th(s[1], s[2], s[0]);\n  }\n  for (int i = 1; i <= k; i++)\n    for (int j = k + 1; j <= n; j++) p[++cnt] = th(i, j, w[i][j]);\n  for (int i = 0; i < (1 << (k * (k - 1) / 2)); i++) {\n    ini();\n    preg.clear();\n    memset(cd, 0, sizeof(cd));\n    nans = 0;\n    int ncnt = 0;\n    for (int u = 1; u <= k; u++)\n      for (int v = u + 1; v <= k; v++) {\n        if (i & (1 << ncnt)) preg.push_back(make_pair(u, v));\n        ncnt += 1;\n      }\n    int flag = 1;\n    for (auto s : preg) {\n      if (gfa(s.first) == gfa(s.second)) flag = 0;\n      lk(s.first, s.second);\n      nans += inf - w[s.first][s.second];\n      cd[s.first] += 1, cd[s.second] += 1;\n    }\n    for (int i = 1; i <= k; i++)\n      if (cd[i] > d[i]) flag = 0;\n    if (!flag) continue;\n    memset(fl, 0, sizeof(fl));\n    for (int m = 0; m < n - 1 - preg.size(); m++) {\n      flag &= bfs();\n      if (!flag) break;\n    }\n    if (flag) {\n      chkmin(ans, (n - 1) * inf - nans);\n    }\n  }\n  cout << ans << endl;\n  return (0 - 0);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 0x3f3f3f3f3f3f3f3f;\nconst int mo = 998244353;\nconst int inv2 = 499122177;\nconst double jzm = 0.9995;\nconst int zero = 5000;\nconst int orG = 3, invG = 332748118;\nconst double Pi = acos(-1.0);\nconst double eps = 1e-3;\ntemplate <typename _T>\n_T Fabs(_T x) {\n  return x < 0 ? -x : x;\n}\ntemplate <typename _T>\nvoid read(_T &x) {\n  _T f = 1;\n  x = 0;\n  char s = getchar();\n  while (s > '9' || s < '0') {\n    if (s == '-') f = -1;\n    s = getchar();\n  }\n  while ('0' <= s && s <= '9') {\n    x = (x << 3) + (x << 1) + (s ^ 48);\n    s = getchar();\n  }\n  x *= f;\n}\ntemplate <typename _T>\nvoid print(_T x) {\n  if (x < 0) {\n    x = (~x) + 1;\n    putchar('-');\n  }\n  if (x > 9) print(x / 10);\n  putchar(x % 10 + '0');\n}\nlong long gcd(long long a, long long b) { return !b ? a : gcd(b, a % b); }\nint add(int x, int y, int p) { return x + y < p ? x + y : x + y - p; }\nvoid Add(int &x, int y, int p) { x = add(x, y, p); }\nint qkpow(int a, int s, int p) {\n  int t = 1;\n  while (s) {\n    if (s & 1LL) t = 1ll * a * t % p;\n    a = 1ll * a * a % p;\n    s >>= 1LL;\n  }\n  return t;\n}\nint n, k, d[55], mp[55][55], t[55], fa[55], tota, totb, deg[55], summ, ans,\n    ord[55][55], sta[55], stak;\nbool cho[55][55], tmp[55][55], ap[55][55], fg[55];\nstruct edge {\n  int u, v, w;\n} a[2505], b[2505];\nbool cmp(edge x, edge y) { return x.w < y.w; }\nbool cmp1(int x, int y) { return t[x] < t[y]; }\ndouble Rand() {\n  return 1.0 * (rand() * RAND_MAX + rand()) / (RAND_MAX * RAND_MAX);\n}\nvoid makeSet(int x) {\n  for (int i = 1; i <= x; i++) fa[i] = i;\n}\nint findSet(int x) { return fa[x] == x ? x : fa[x] = findSet(fa[x]); }\nvoid unionSet(int a, int b) {\n  int u = findSet(a), v = findSet(b);\n  if (u != v) fa[u] = v;\n}\nvoid work(int x) {\n  for (int i = 1; i <= n; i++) {\n    if (ord[x][i] <= k && !fg[findSet(ord[x][i])]) continue;\n    if (ord[x][i] <= k && deg[ord[x][i]] == d[ord[x][i]]) continue;\n    unionSet(ord[x][i], x);\n    tmp[min(ord[x][i], x)][max(ord[x][i], x)] = 1;\n    deg[ord[x][i]]++;\n    deg[x]++;\n    break;\n  }\n}\nvoid sakura(double tp) {\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= n; j++) tmp[i][j] = 0;\n  for (int i = 1; i <= n; i++) deg[i] = fg[i] = 0;\n  summ = 0;\n  makeSet(n);\n  int tim = 0;\n  for (int i = 1; i <= tota; i++) {\n    int u = a[i].u, v = a[i].v, w = a[i].w;\n    if (!cho[u][v]) continue;\n    if (Rand() < tp) {\n      tmp[u][v] = 0;\n      continue;\n    }\n    tmp[u][v] = 1;\n    deg[u]++;\n    deg[v]++;\n    unionSet(u, v);\n    tim++;\n  }\n  random_shuffle(a + 1, a + tota + 1);\n  for (int i = 1; i <= tota; i++) {\n    int u = a[i].u, v = a[i].v, w = a[i].w;\n    if (tmp[u][v] || findSet(u) == findSet(v)) continue;\n    if (Rand() > tp || deg[u] == d[u] || deg[v] == d[v]) continue;\n    tmp[u][v] = 1;\n    deg[u]++;\n    deg[v]++;\n    unionSet(u, v);\n    tim++;\n  }\n  for (int i = k + 1; i <= n; i++) fg[findSet(i)] = 1;\n  tim = 0;\n  for (int i = 1; i <= k; i++) {\n    if (fg[findSet(i)]) continue;\n    int p = findSet(i), spc = 0;\n    for (int j = 1; j <= k; j++)\n      if (findSet(j) == p && deg[j] < d[j]) spc = j;\n    if (!spc) {\n      stak = 0;\n      for (int j = 1; j <= k; j++)\n        if (findSet(j) == p) sta[++stak] = j;\n      for (int j = 1; j <= stak; j++) {\n        int u = sta[j];\n        fa[u] = u;\n        deg[u] = 0;\n        for (int l = 1; l <= k; l++) tmp[l][u] = tmp[u][l] = 0;\n      }\n      for (int j = 1; j <= stak; j++) work(sta[j]), fg[findSet(sta[j])] = 1;\n    } else\n      work(spc), fg[findSet(spc)] = 1;\n  }\n  for (int i = 1; i <= totb; i++)\n    if (findSet(b[i].u) != findSet(b[i].v))\n      unionSet(b[i].u, b[i].v), deg[b[i].u]++, deg[b[i].v]++,\n          tmp[b[i].u][b[i].v] = 1;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++)\n      if (tmp[i][j]) summ += mp[i][j], tim++;\n}\nvoid nagisa() {\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) cho[i][j] = ap[i][j];\n  summ = 0;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++)\n      if (cho[i][j]) summ += mp[i][j];\n  for (int t = 1; t <= 500; t++) {\n    int now = summ;\n    sakura(0.5);\n    if (summ < now)\n      for (int i = 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++) cho[i][j] = tmp[i][j];\n    else\n      summ = now;\n  }\n  if (ans > summ) {\n    for (int i = 1; i <= n; i++)\n      for (int j = i + 1; j <= n; j++) ap[i][j] = cho[i][j];\n    ans = summ;\n  }\n  double nowT = 5000.0;\n  while (nowT > eps) {\n    int now = summ;\n    sakura(nowT);\n    double t = Rand();\n    if (ans > summ) {\n      for (int i = 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++) ap[i][j] = cho[i][j] = tmp[i][j];\n      ans = summ;\n    } else if (exp(1.0 * (now - summ) / nowT) > t)\n      for (int i = 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++) cho[i][j] = tmp[i][j];\n    else\n      summ = now;\n    nowT *= jzm;\n  }\n}\nsigned main() {\n  srand(time(NULL));\n  read(n);\n  read(k);\n  for (int i = 1; i <= k; i++) read(d[i]);\n  for (int i = k + 1; i <= n; i++) d[i] = n;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) {\n      read(mp[i][j]), mp[j][i] = mp[i][j];\n      if (i <= k)\n        a[++tota] = (edge){i, j, mp[i][j]};\n      else\n        b[++totb] = (edge){i, j, mp[i][j]};\n    }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) t[j] = mp[i][j];\n    for (int j = 1; j <= n; j++) ord[i][j] = j;\n    sort(ord[i] + 1, ord[i] + n + 1, cmp1);\n  }\n  sort(b + 1, b + totb + 1, cmp);\n  sakura(1.0);\n  ans = summ;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) ap[i][j] = cho[i][j] = tmp[i][j];\n  for (int i = 1; i <= 4; i++) nagisa();\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 55, inf = 1e9;\nint n, k, u[N * N], v[N * N], w[N * N], s, t, d, in[N * N], c[N * N],\n    q[N * N * N * N], dis[N * N], pr[N * N], a[N * N], lj[N][N], ans = inf, bg,\n                                                                 ed;\nvector<int> e[N * N];\nstruct d1 {\n  int f[N];\n  void init(int n) {\n    for (int i = 1; i <= n; i++) f[i] = i;\n  }\n  int fa(int x) { return x == f[x] ? x : f[x] = fa(f[x]); }\n  void mg(int u, int v) { f[fa(u)] = fa(v); }\n  int ok(int u, int v) { return fa(u) != fa(v); }\n} t1, t2;\nstruct d2 {\n  int z[N], l[N];\n  void init(int n) {\n    for (int i = 1; i <= n; i++) z[i] = 0, l[i] = inf;\n  }\n  void mg(int u, int v) { z[u]++, z[v]++; }\n  int ok(int u, int v) { return z[u] < l[u] && z[v] < l[v]; }\n} t3, t4, t5;\nint dfs() {\n  for (int i = 1; i <= d + 2; i++) e[i].clear();\n  t2 = t1, t5 = t4;\n  for (int i = 1; i <= d; i++)\n    if (a[i]) t2.mg(u[i], v[i]), t5.mg(u[i], v[i]);\n  for (int i = 1; i <= d; i++) {\n    if (!a[i]) {\n      if (t2.ok(u[i], v[i])) e[s].push_back(i);\n      if (t5.ok(u[i], v[i])) e[i].push_back(t);\n    }\n  }\n  for (int i = 1; i <= d; i++) {\n    if (a[i]) {\n      t2 = t1, t5 = t4;\n      for (int j = 1; j <= d; j++)\n        if (i != j && a[j]) t2.mg(u[j], v[j]), t5.mg(u[j], v[j]);\n      for (int j = 1; j <= d; j++) {\n        if (!a[j]) {\n          if (t2.ok(u[j], v[j])) e[i].push_back(j);\n          if (t5.ok(u[j], v[j])) e[j].push_back(i);\n        }\n      }\n    }\n  }\n  bg = ed = 0;\n  for (int i = 1; i <= d + 2; i++) dis[i] = inf, pr[i] = c[i] = in[i] = 0;\n  dis[s] = 0, q[ed++] = s, in[s] = 1;\n  while (bg < ed) {\n    int u = q[bg++];\n    in[u] = 0;\n    for (auto v : e[u]) {\n      int nd = dis[u] + (a[v] ? -w[v] : w[v]);\n      if (nd < dis[v] || (nd == dis[v] && c[u] + 1 < c[v])) {\n        dis[v] = nd, c[v] = c[u] + 1, pr[v] = u;\n        if (!in[v]) q[ed++] = v, in[v] = 1;\n      }\n    }\n  }\n  if (dis[t] == inf) return -1;\n  for (int i = pr[t]; i != s; i = pr[i]) a[i] ^= 1;\n  return dis[t];\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  t3.init(n);\n  for (int i = 1; i <= k; i++) scanf(\"%d\", &t3.l[i]);\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) scanf(\"%d\", &lj[i][j]);\n  for (int i = 1; i <= n; i++) {\n    for (int j = max(i + 1, k + 1); j <= n; j++) {\n      d++;\n      u[d] = i, v[d] = j;\n      w[d] = lj[i][j];\n    }\n  }\n  s = d + 1, t = d + 2;\n  int b = (1 << (k * (k - 1) / 2)) - 1;\n  for (int x = 0; x <= b; x++) {\n    t1.init(n);\n    t4 = t3;\n    for (int i = 1; i <= d; i++) a[i] = 0;\n    int z = 0, f = 1, r = 0;\n    for (int i = 1; i <= k; i++) {\n      for (int j = i + 1; j <= k; j++) {\n        if (x >> z & 1) {\n          f &= t1.ok(i, j), f &= t4.ok(i, j);\n          t1.mg(i, j), t4.mg(i, j);\n          r += lj[i][j];\n        }\n        z++;\n      }\n    }\n    if (!f) continue;\n    int p = n - 1 - __builtin_popcount(x);\n    while (p--) {\n      int y = dfs();\n      if (y == -1) {\n        f = 0;\n        break;\n      }\n      r += y;\n    }\n    if (f) ans = min(ans, r);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 3010;\nconst int INF = 2e9;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\nint n, k, m1, m, Ans = INF;\nint d_lim[MAXN], X[MAXN], Y[MAXN], W[MAXN];\nbool vis[MAXN];\nvector<int> G[MAXN];\ntemplate <typename T>\ninline bool read(T &a) {\n  a = 0;\n  char c = getchar();\n  int f = 1;\n  while (c < '0' || c > '9') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    a = a * 10 + (c ^ 48);\n    c = getchar();\n  }\n  return a *= f, true;\n}\ntemplate <typename A, typename... B>\ninline bool read(A &x, B &...y) {\n  return read(x) && read(y...);\n}\nstruct M1 {\n  int S;\n  struct DSU {\n    int f[MAXN];\n    int find(int x) { return f[x] == x ? x : f[x] = find(f[x]); }\n    void unity(int x, int y) { (find(x) != find(y)) && (f[find(x)] = find(y)); }\n    bool Init(int S) {\n      for (int i = 1; i <= n; ++i) f[i] = i;\n      for (int i = 1; i <= m1; ++i) {\n        if (!((S >> (i - 1)) & 1)) continue;\n        if (find(X[i]) != find(Y[i]))\n          unity(X[i], Y[i]);\n        else\n          return false;\n      }\n      return true;\n    }\n  } ex[MAXN], tmp;\n  void Init(int _S) { S = _S; }\n  bool chk(int S) { return tmp.Init(S); }\n  void build() {\n    for (int i = m1 + 1; i <= m + 1; ++i) {\n      if (!vis[i] && i <= m) continue;\n      ex[i].Init(S);\n      for (int j = m1 + 1; j <= m; ++j) {\n        if (!vis[j] || i == j) continue;\n        ex[i].unity(X[j], Y[j]);\n      }\n    }\n  }\n  bool valid(int x) { return ex[m + 1].find(X[x]) != ex[m + 1].find(Y[x]); }\n  bool valid(int x, int y) { return (ex[x].find(X[y]) != ex[x].find(Y[y])); }\n} M1;\nstruct M2 {\n  int S, d[MAXN];\n  void add(int S) {\n    for (int i = 1; i <= n; ++i) d[i] = 0;\n    for (int i = 1; i <= m1; ++i)\n      if ((S >> (i - 1)) & 1) d[X[i]]++, d[Y[i]]++;\n  }\n  bool chk(int S) {\n    add(S);\n    for (int i = 1; i <= k; ++i)\n      if (d[i] > d_lim[i]) return false;\n    return true;\n  }\n  void Init(int _S) { S = _S; }\n  void build() {\n    add(S);\n    for (int i = m1 + 1; i <= m; ++i)\n      if (vis[i]) d[X[i]]++, d[Y[i]]++;\n  }\n  bool valid(int x) {\n    d[X[x]]++, d[Y[x]]++;\n    bool res = (d[X[x]] <= d_lim[X[x]] && d[Y[x]] <= d_lim[Y[x]]);\n    d[X[x]]--, d[Y[x]]--;\n    return res;\n  }\n  bool valid(int x, int y) {\n    d[X[x]]--, d[Y[x]]--, d[X[y]]++, d[Y[y]]++;\n    bool res = (d[X[y]] <= d_lim[X[y]] && d[Y[y]] <= d_lim[Y[y]]);\n    d[X[x]]++, d[Y[x]]++, d[X[y]]--, d[Y[y]]--;\n    return res;\n  }\n} M2;\nbool SPFA(int _s, int _t) {\n  queue<int> Q;\n  static int dis[MAXN], len[MAXN], pre[MAXN];\n  static bool inq[MAXN];\n  while (Q.size()) Q.pop();\n  for (int i = m1 + 1; i <= m + 2; ++i)\n    dis[i] = INF, len[i] = pre[i] = 0, inq[i] = false;\n  dis[_s] = 0, inq[_s] = true;\n  Q.push(_s);\n  while (Q.size()) {\n    int x = Q.front();\n    Q.pop();\n    inq[x] = false;\n    for (auto to : G[x]) {\n      int w = vis[to] ? -W[to] : W[to];\n      if (dis[to] > dis[x] + w ||\n          (dis[to] == dis[x] + w && len[to] > len[x] + 1)) {\n        dis[to] = dis[x] + w, len[to] = len[x] + 1, pre[to] = x;\n        if (!inq[to]) Q.push(to), inq[to] = true;\n      }\n    }\n  }\n  if (dis[_t] == INF) return false;\n  for (int x = pre[_t]; x != _s; x = pre[x]) vis[x] ^= 1;\n  return true;\n}\nbool Augment() {\n  M1.build();\n  M2.build();\n  int _s = m + 1, _t = m + 2;\n  for (int i = m1 + 1; i <= m + 2; ++i) G[i].clear();\n  for (int i = m1 + 1; i <= m; ++i) {\n    if (vis[i]) continue;\n    if (M1.valid(i)) G[_s].push_back(i);\n    if (M2.valid(i)) G[i].push_back(_t);\n  }\n  for (int i = m1 + 1; i <= m; ++i) {\n    if (!vis[i]) continue;\n    for (int j = m1 + 1; j <= m; ++j) {\n      if (vis[j]) continue;\n      if (M1.valid(i, j)) G[i].push_back(j);\n      if (M2.valid(i, j)) G[j].push_back(i);\n    }\n  }\n  return SPFA(_s, _t);\n}\nint Matroid_Intersection(int S) {\n  int res = 0, cnt = n - 1 - __builtin_popcount(S);\n  memset(vis, false, sizeof vis);\n  while (Augment()) cnt--;\n  if (cnt) return INF;\n  for (int i = 0; i < m1; ++i)\n    if ((S >> i) & 1) res += W[i + 1];\n  for (int i = m1 + 1; i <= m; ++i)\n    if (vis[i]) res += W[i];\n  return res;\n}\nsigned main() {\n  read(n), read(k);\n  for (int i = 1; i <= k; ++i) read(d_lim[i]);\n  for (int i = k + 1; i <= n; ++i) d_lim[i] = INF;\n  m = (k - 1) * k >> 1;\n  for (int i = 1; i <= n; ++i)\n    for (int j = i + 1; j <= n; ++j) {\n      if (j > k) {\n        read(W[++m]);\n        X[m] = i, Y[m] = j;\n      } else {\n        read(W[++m1]);\n        X[m1] = i, Y[m1] = j;\n      }\n    }\n  for (int S = 0; S < (1 << m1); ++S) {\n    if (!M1.chk(S) || !M2.chk(S)) continue;\n    M1.Init(S);\n    M2.Init(S);\n    Ans = min(Ans, Matroid_Intersection(S));\n  }\n  printf(\"%d\\n\", Ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937 rnd(2226701);\nconst int INF = 0x3f3f3f3f;\nconst int maxn = 55;\nint n, k;\nclass Dsu {\n public:\n  int fa[maxn];\n  inline void init() {\n    for (int i = 0; i < n; ++i) fa[i] = i;\n    return;\n  }\n  inline int find(int x) { return x == fa[x] ? x : (fa[x] = find(fa[x])); }\n  inline bool merge(int x, int y) {\n    x = find(x), y = find(y);\n    if (x == y) return 0;\n    fa[x] = y;\n    return 1;\n  }\n} dsu;\nint deg2[maxn], deg[maxn], d[maxn];\nint w[maxn][maxn], vis[maxn][maxn];\ninline bool cmp(const pair<int, int> &i, const pair<int, int> &j) {\n  return w[i.first][i.second] < w[j.first][j.second];\n}\ninline int check() {\n  vector<pair<int, int> > vec;\n  dsu.init();\n  int ret = 0, cnt = n;\n  vector<pair<int, int> > fuck;\n  for (int i = 0; i < n; ++i) {\n    deg2[i] = deg[i];\n    for (int j = i + 1; j < n; ++j) {\n      if (vis[i][j]) {\n        if (!dsu.merge(i, j)) return INF;\n        ret += w[i][j];\n        fuck.push_back(make_pair(i, j));\n        --cnt;\n      } else\n        vec.push_back(make_pair(i, j));\n    }\n  }\n  sort(vec.begin(), vec.end(), cmp);\n  for (int i = 0; i < vec.size(); ++i)\n    if (deg2[vec[i].first] < d[vec[i].first] &&\n        deg2[vec[i].second] < d[vec[i].second] &&\n        dsu.merge(vec[i].first, vec[i].second))\n      ret += w[vec[i].first][vec[i].second], ++deg2[vec[i].first],\n          ++deg2[vec[i].second], --cnt, fuck.push_back(vec[i]);\n  if (cnt > 1) return INF;\n  return ret;\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 0; i < k; ++i) scanf(\"%d\", d + i);\n  for (int i = k; i < n; ++i) d[i] = INF;\n  vector<pair<int, int> > all;\n  for (int i = 0; i < n; ++i)\n    for (int j = i + 1; j < n; ++j) {\n      scanf(\"%d\", &w[i][j]);\n      if (i < k) all.push_back(make_pair(i, j));\n    }\n  int ans = check(), cur = ans;\n  for (long double T = 1000; T > 0.0001; T *= 0.9993) {\n    int p = -1;\n    for (p = rnd() % all.size(); (deg[all[p].first] == d[all[p].first] ||\n                                  deg[all[p].second] == d[all[p].second]) &&\n                                 !vis[all[p].first][all[p].second];\n         p = rnd() % all.size())\n      ;\n    int u = all[p].first, v = all[p].second;\n    deg[u] -= vis[u][v], deg[v] -= vis[u][v];\n    vis[u][v] ^= 1;\n    deg[u] += vis[u][v], deg[v] += vis[u][v];\n    int delta = check() - cur;\n    if (exp(-delta / T) >= (long double)(rnd() % 1000000000) / 1000000000) {\n      cur += delta;\n      ans = min(ans, cur);\n    } else {\n      deg[u] -= vis[u][v], deg[v] -= vis[u][v];\n      vis[u][v] ^= 1;\n      deg[u] += vis[u][v], deg[v] += vis[u][v];\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int max_n = 55, inf = 1000111222;\nint copy_dsu[max_n];\nstruct dsu {\n  int p_or_sz[max_n];\n  void init(int n) {\n    for (int i = 0; i < n; ++i) {\n      p_or_sz[i] = -1;\n    }\n  }\n  void init_from_copy(int n) {\n    for (int i = 0; i < n; ++i) {\n      p_or_sz[i] = copy_dsu[i];\n    }\n  }\n  int find_set(int v) {\n    if (p_or_sz[v] < 0) {\n      return v;\n    }\n    return p_or_sz[v] = find_set(p_or_sz[v]);\n  }\n  bool union_set(int v1, int v2) {\n    v1 = find_set(v1);\n    v2 = find_set(v2);\n    if (v1 == v2) {\n      return false;\n    }\n    if (-p_or_sz[v1] > -p_or_sz[v2]) {\n      swap(v1, v2);\n    }\n    p_or_sz[v2] += p_or_sz[v1];\n    p_or_sz[v1] = v2;\n    return true;\n  }\n};\nint n, k, max_deg[max_n], D[max_n][max_n];\nint deg[max_n];\ndsu d;\nbool get_bit(int mask, int pos) { return (mask >> pos) & 1; }\nstruct GroundSetElement {\n  int u, v;\n  int cost;\n  bool taken;\n  GroundSetElement() {}\n  GroundSetElement(int u, int v, int cost)\n      : u(u), v(v), cost(cost), taken(false) {}\n  bool operator<(const GroundSetElement &g) const { return cost < g.cost; }\n};\nconst int max_e = max_n * max_n / 2;\nvector<GroundSetElement> elems;\nint cur_deg[max_n];\nint parent[max_e], weight[max_e];\npair<int, int> dist[max_e];\nvector<pair<int, int>> edges;\nbool is_s[max_e], is_t[max_e];\nvoid prepare() {\n  d.init_from_copy(n);\n  copy(deg, deg + n, cur_deg);\n  for (int i = 0; i < elems.size(); ++i) {\n    if (elems[i].taken) {\n      d.union_set(elems[i].u, elems[i].v);\n      --cur_deg[elems[i].u];\n      --cur_deg[elems[i].v];\n    }\n  }\n}\nbool is_ok1(const GroundSetElement &a) {\n  return d.find_set(a.u) != d.find_set(a.v);\n}\nbool is_ok2(const GroundSetElement &a) {\n  return cur_deg[a.u] > 0 && cur_deg[a.v] > 0;\n}\nbool augment() {\n  edges.clear();\n  prepare();\n  for (int i = 0; i < elems.size(); ++i) {\n    if (!elems[i].taken) {\n      is_s[i] = is_ok1(elems[i]);\n      is_t[i] = is_ok2(elems[i]);\n      weight[i] = -elems[i].cost;\n    } else {\n      is_s[i] = is_t[i] = false;\n      weight[i] = elems[i].cost;\n    }\n    weight[i] *= -1;\n  }\n  for (int i = 0; i < elems.size(); ++i) {\n    if (elems[i].taken) {\n      elems[i].taken = false;\n      prepare();\n      elems[i].taken = true;\n      for (int j = 0; j < elems.size(); ++j) {\n        if (!elems[j].taken) {\n          if (is_ok1(elems[j])) {\n            edges.push_back({i, j});\n          }\n          if (is_ok2(elems[j])) {\n            edges.push_back({j, i});\n          }\n        }\n      }\n    }\n  }\n  for (int i = 0; i < elems.size(); ++i) {\n    dist[i] = {inf, inf};\n    parent[i] = -1;\n    if (is_s[i]) {\n      dist[i] = {weight[i], 0};\n    }\n  }\n  for (bool change = true; change;) {\n    change = false;\n    for (const auto &edge : edges) {\n      pair<int, int> ndist = dist[edge.first];\n      if (ndist.first == inf) {\n        continue;\n      }\n      ndist.first += weight[edge.second];\n      ++ndist.second;\n      if (dist[edge.second] > ndist) {\n        dist[edge.second] = ndist;\n        parent[edge.second] = edge.first;\n        change = true;\n      }\n    }\n  }\n  int t = -1;\n  for (int i = 0; i < elems.size(); ++i) {\n    if (is_t[i] && (t == -1 || dist[t] > dist[i])) {\n      t = i;\n    }\n  }\n  if (t == -1 || dist[t].first == inf) {\n    return false;\n  }\n  while (t != -1) {\n    elems[t].taken ^= 1;\n    t = parent[t];\n  }\n  return true;\n}\nint ans = inf;\nint solve(int need_e, int cost) {\n  for (int i = 0; i < n; ++i) {\n    copy_dsu[i] = d.p_or_sz[i];\n  }\n  for (int i = 0; i < elems.size(); ++i) {\n    elems[i].taken = false;\n  }\n  int it = 0;\n  while (augment()) {\n    ++it;\n    int res = cost;\n    for (int i = 0; i < elems.size(); ++i) {\n      if (elems[i].taken) {\n        res += elems[i].cost;\n      }\n    }\n    prepare();\n    for (int i = 0; i < elems.size(); ++i) {\n      if (!elems[i].taken && d.union_set(elems[i].u, elems[i].v)) {\n        res += elems[i].cost;\n      }\n    }\n    if (res >= ans) {\n      return -1;\n    }\n  }\n  if (it != need_e) {\n    return -1;\n  }\n  int res = cost;\n  for (int i = 0; i < elems.size(); ++i) {\n    if (elems[i].taken) {\n      res += elems[i].cost;\n    }\n  }\n  return res;\n}\ndouble start = clock();\nbool is_tl() { return (clock() - start) / CLOCKS_PER_SEC > 5.5; }\nint main() {\n  if (0) {\n    n = 50;\n    k = 5;\n    for (int i = 0; i < k; ++i) {\n      max_deg[i] = inf;\n    }\n    for (int i = 0; i < n; ++i) {\n      for (int j = i + 1; j < n; ++j) {\n        D[i][j] = rand() % 100 + 1;\n      }\n    }\n  } else {\n    cin >> n >> k;\n    for (int i = 0; i < k; ++i) {\n      cin >> max_deg[i];\n    }\n    for (int i = 0; i < n; ++i) {\n      for (int j = i + 1; j < n; ++j) {\n        cin >> D[i][j];\n      }\n    }\n  }\n  for (int i = k; i < n; ++i) {\n    for (int j = i + 1; j < n; ++j) {\n      elems.push_back({i, j, D[i][j]});\n    }\n  }\n  sort(elems.begin(), elems.end());\n  vector<GroundSetElement> ok_elems;\n  d.init(n);\n  for (auto elem : elems) {\n    if (d.union_set(elem.u, elem.v)) {\n      ok_elems.push_back(elem);\n    }\n  }\n  elems.swap(ok_elems);\n  for (int i = 0; i < k; ++i) {\n    for (int j = k; j < n; ++j) {\n      elems.push_back({i, j, D[i][j]});\n    }\n  }\n  sort(elems.begin(), elems.end());\n  int small_e = (k * (k - 1)) / 2;\n  int TOT = 0;\n  vector<int> all_masks;\n  for (int mask = 0; mask < (1 << small_e); ++mask) {\n    all_masks.push_back(mask);\n  }\n  const int seed = chrono::steady_clock::now().time_since_epoch().count();\n  mt19937 generator(seed);\n  shuffle(all_masks.begin(), all_masks.end(), generator);\n  for (int mask : all_masks) {\n    if (is_tl()) {\n      cout << ans << \"\\n\";\n      return 0;\n    }\n    d.init(n);\n    copy(max_deg, max_deg + k, deg);\n    fill(deg + k, deg + n, inf);\n    int num = 0, cost = 0;\n    bool ok = 1;\n    int need_e = n - 1;\n    for (int i = 0; i < k && ok; ++i) {\n      for (int j = i + 1; j < k && ok; ++j) {\n        if (get_bit(mask, num)) {\n          if (!d.union_set(i, j) || !deg[i] || !deg[j]) {\n            ok = 0;\n            break;\n          }\n          --deg[i];\n          --deg[j];\n          cost += D[i][j];\n          --need_e;\n        }\n        ++num;\n      }\n    }\n    if (!ok) {\n      continue;\n    }\n    ++TOT;\n    int res = solve(need_e, cost);\n    if (res == -1) {\n      continue;\n    }\n    ans = min(ans, res);\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INFi = 1e9 + 5;\nconst int md = 1e9 + 7;\nconst long long INF = 2e18;\nconst int maxN = 5e5 + 1;\ndouble getTime() { return clock() / (double)CLOCKS_PER_SEC; }\ninline int add(const int &a, const int &b) {\n  return a + b >= md ? a + b - md : a + b;\n}\ninline int sub(const int &a, const int &b) {\n  return a - b < 0 ? a - b + md : a - b;\n}\ninline int mul(const int &a, const int &b) { return (1ll * a * b) % md; }\nint binpow(int a, int b) {\n  if (b <= 0) return 1;\n  if (b % 2) return mul(a, binpow(a, b - 1));\n  int m = binpow(a, b / 2);\n  return mul(m, m);\n}\nint rev(int a) { return binpow(a, md - 2); }\nint n, k;\nvector<int> d;\nvector<vector<double>> g;\nvector<int> deg;\ndouble last = 0;\nvoid solve1() {\n  last = 0;\n  deg.assign(n, 0);\n  vector<bool> was(n);\n  vector<double> mn(n, INF);\n  vector<int> fr(n, -1);\n  mn[0] = 0;\n  for (int _ = 0; _ < (n); ++_) {\n    int x = -1;\n    for (int j = 0; j < (n); ++j) {\n      if (was[j]) continue;\n      if (mn[j] < mn[x] || x == -1) {\n        x = j;\n        continue;\n      }\n      if (mn[j] == mn[x] && fr[j] >= k && j >= k) {\n        x = j;\n      }\n    }\n    if (fr[x] != -1) {\n      deg[x]++;\n      deg[fr[x]]++;\n    }\n    last += mn[x];\n    was[x] = true;\n    for (int j = 0; j < (n); ++j) {\n      if (was[j]) continue;\n      if (mn[j] > g[x][j]) {\n        mn[j] = g[x][j];\n        fr[j] = x;\n      } else if (mn[j] == g[x][j] && x >= k) {\n        fr[j] = x;\n      }\n    }\n  }\n}\nint K = 10;\nbool need = false;\nvoid go(int i) {\n  if (i == k) {\n    solve1();\n    return;\n  }\n  double l = 0, r = 110;\n  for (int _ = 0; _ < (K); ++_) {\n    double mid = (r + l) / 2;\n    for (int j = 0; j < (n); ++j) {\n      g[i][j] += mid;\n      g[j][i] += mid;\n    }\n    go(i + 1);\n    for (int j = 0; j < (n); ++j) {\n      g[i][j] -= mid;\n      g[j][i] -= mid;\n    }\n    if (deg[i] < d[i]) {\n      r = mid;\n    } else {\n      l = mid;\n    }\n  }\n  if (need) r = l;\n  for (int j = 0; j < (n); ++j) {\n    g[i][j] += r;\n    g[j][i] += r;\n  }\n  go(i + 1);\n  for (int j = 0; j < (n); ++j) {\n    g[i][j] -= r;\n    g[j][i] -= r;\n  }\n  last -= deg[i] * r;\n}\nvoid solve() {\n  cin >> n >> k;\n  d.resize(k);\n  for (int i = 0; i < (k); ++i) cin >> d[i];\n  g.resize(n, vector<double>(n));\n  vector<int> ord(n);\n  vector<long long> d2(n, n);\n  for (int i = 0; i < (k); ++i) d2[i] = d[i];\n  iota((ord).begin(), (ord).end(), 0ll);\n  sort((ord).begin(), (ord).end(), [&](const int &i, const int &j) {\n    return make_pair(d2[i], i) < make_pair(d2[j], j);\n  });\n  mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n  for (int l = 0, r = 0; l < n; l = r) {\n    while (r < n && d2[ord[r]] == d2[ord[l]]) r++;\n    if (l < k) r = min(r, k);\n  }\n  vector<int> pos(n);\n  for (int i = 0; i < (n); ++i) pos[ord[i]] = i;\n  for (int i = 0; i < (n); ++i) {\n    for (int j = i + 1; j < n; ++j) {\n      cin >> g[pos[i]][pos[j]];\n      g[pos[j]][pos[i]] = g[pos[i]][pos[j]];\n    }\n  }\n  for (int i = 0; i < (k); ++i) d[i] = d2[ord[i]];\n  need = true;\n  go(0);\n  for (int i = 0; i < (k); ++i) d[i]++;\n  need = false;\n  double L = last;\n  go(0);\n  double R = last;\n  cout << round((R + L) / 2) << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int tests = 1;\n  for (int _ = 0; _ < (tests); ++_) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int max_n = 55, inf = 1000111222;\nint copy_dsu[max_n];\nstruct dsu {\n  int p_or_sz[max_n];\n  void init(int n) {\n    for (int i = 0; i < n; ++i) {\n      p_or_sz[i] = -1;\n    }\n  }\n  void init_from_copy(int n) {\n    for (int i = 0; i < n; ++i) {\n      p_or_sz[i] = copy_dsu[i];\n    }\n  }\n  int find_set(int v) {\n    if (p_or_sz[v] < 0) {\n      return v;\n    }\n    return p_or_sz[v] = find_set(p_or_sz[v]);\n  }\n  bool union_set(int v1, int v2) {\n    v1 = find_set(v1);\n    v2 = find_set(v2);\n    if (v1 == v2) {\n      return false;\n    }\n    if (-p_or_sz[v1] > -p_or_sz[v2]) {\n      swap(v1, v2);\n    }\n    p_or_sz[v2] += p_or_sz[v1];\n    p_or_sz[v1] = v2;\n    return true;\n  }\n};\nint n, k, max_deg[max_n], D[max_n][max_n];\nint deg[max_n];\ndsu d;\nbool get_bit(int mask, int pos) { return (mask >> pos) & 1; }\nstruct GroundSetElement {\n  int u, v;\n  int cost;\n  bool taken;\n  GroundSetElement() {}\n  GroundSetElement(int u, int v, int cost)\n      : u(u), v(v), cost(cost), taken(false) {}\n  bool operator<(const GroundSetElement &g) const { return cost < g.cost; }\n};\nconst int max_e = max_n * max_n / 2;\nvector<GroundSetElement> elems;\nint cur_deg[max_n];\nint parent[max_e], weight[max_e];\npair<int, int> dist[max_e];\nvector<pair<int, int>> edges;\nbool is_s[max_e], is_t[max_e];\nvoid prepare() {\n  d.init_from_copy(n);\n  copy(deg, deg + n, cur_deg);\n  for (int i = 0; i < elems.size(); ++i) {\n    if (elems[i].taken) {\n      d.union_set(elems[i].u, elems[i].v);\n      --cur_deg[elems[i].u];\n      --cur_deg[elems[i].v];\n    }\n  }\n}\nbool is_ok1(const GroundSetElement &a) {\n  return d.find_set(a.u) != d.find_set(a.v);\n}\nbool is_ok2(const GroundSetElement &a) {\n  return cur_deg[a.u] > 0 && cur_deg[a.v] > 0;\n}\nbool augment() {\n  edges.clear();\n  prepare();\n  for (int i = 0; i < elems.size(); ++i) {\n    if (!elems[i].taken) {\n      is_s[i] = is_ok1(elems[i]);\n      is_t[i] = is_ok2(elems[i]);\n      weight[i] = -elems[i].cost;\n    } else {\n      is_s[i] = is_t[i] = false;\n      weight[i] = elems[i].cost;\n    }\n    weight[i] *= -1;\n  }\n  for (int i = 0; i < elems.size(); ++i) {\n    if (elems[i].taken) {\n      elems[i].taken = false;\n      prepare();\n      elems[i].taken = true;\n      for (int j = 0; j < elems.size(); ++j) {\n        if (!elems[j].taken) {\n          if (is_ok1(elems[j])) {\n            edges.push_back({i, j});\n          }\n          if (is_ok2(elems[j])) {\n            edges.push_back({j, i});\n          }\n        }\n      }\n    }\n  }\n  for (int i = 0; i < elems.size(); ++i) {\n    dist[i] = {inf, inf};\n    parent[i] = -1;\n    if (is_s[i]) {\n      dist[i] = {weight[i], 0};\n    }\n  }\n  for (bool change = true; change;) {\n    change = false;\n    for (const auto &edge : edges) {\n      pair<int, int> ndist = dist[edge.first];\n      if (ndist.first == inf) {\n        continue;\n      }\n      ndist.first += weight[edge.second];\n      ++ndist.second;\n      if (dist[edge.second] > ndist) {\n        dist[edge.second] = ndist;\n        parent[edge.second] = edge.first;\n        change = true;\n      }\n    }\n  }\n  int t = -1;\n  for (int i = 0; i < elems.size(); ++i) {\n    if (is_t[i] && (t == -1 || dist[t] > dist[i])) {\n      t = i;\n    }\n  }\n  if (t == -1 || dist[t].first == inf) {\n    return false;\n  }\n  while (t != -1) {\n    elems[t].taken ^= 1;\n    t = parent[t];\n  }\n  return true;\n}\nint ans = inf;\nint solve(int need_e, int cost) {\n  for (int i = 0; i < n; ++i) {\n    copy_dsu[i] = d.p_or_sz[i];\n  }\n  for (int i = 0; i < elems.size(); ++i) {\n    elems[i].taken = false;\n  }\n  int it = 0;\n  while (augment()) {\n    ++it;\n    int res = cost;\n    for (int i = 0; i < elems.size(); ++i) {\n      if (elems[i].taken) {\n        res += elems[i].cost;\n      }\n    }\n    int cnt = need_e - it;\n    for (int i = 0; i < elems.size() && cnt; ++i) {\n      if (!elems[i].taken) {\n        res += elems[i].cost;\n        --cnt;\n      }\n    }\n    if (res >= ans) {\n      return -1;\n    }\n  }\n  if (it != need_e) {\n    return -1;\n  }\n  int res = cost;\n  for (int i = 0; i < elems.size(); ++i) {\n    if (elems[i].taken) {\n      res += elems[i].cost;\n    }\n  }\n  return res;\n}\nint main() {\n  if (0) {\n    n = 50;\n    k = 5;\n    for (int i = 0; i < k; ++i) {\n      max_deg[i] = inf;\n    }\n    for (int i = 0; i < n; ++i) {\n      for (int j = i + 1; j < n; ++j) {\n        D[i][j] = rand() % 100 + 1;\n      }\n    }\n  } else {\n    cin >> n >> k;\n    for (int i = 0; i < k; ++i) {\n      cin >> max_deg[i];\n    }\n    for (int i = 0; i < n; ++i) {\n      for (int j = i + 1; j < n; ++j) {\n        cin >> D[i][j];\n      }\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int j = i + 1; j < n; ++j) {\n      if (i < k && j < k) {\n        continue;\n      }\n      elems.push_back({i, j, D[i][j]});\n    }\n  }\n  sort(elems.begin(), elems.end());\n  int small_e = (k * (k - 1)) / 2;\n  int TOT = 0;\n  vector<int> all_masks;\n  for (int mask = 0; mask < (1 << small_e); ++mask) {\n    all_masks.push_back(mask);\n  }\n  const int seed = chrono::steady_clock::now().time_since_epoch().count();\n  mt19937 generator(seed);\n  shuffle(all_masks.begin(), all_masks.end(), generator);\n  for (int mask : all_masks) {\n    d.init(n);\n    copy(max_deg, max_deg + k, deg);\n    fill(deg + k, deg + n, inf);\n    int num = 0, cost = 0;\n    bool ok = 1;\n    int need_e = n - 1;\n    for (int i = 0; i < k && ok; ++i) {\n      for (int j = i + 1; j < k && ok; ++j) {\n        if (get_bit(mask, num)) {\n          if (!d.union_set(i, j) || !deg[i] || !deg[j]) {\n            ok = 0;\n            break;\n          }\n          --deg[i];\n          --deg[j];\n          cost += D[i][j];\n          --need_e;\n        }\n        ++num;\n      }\n    }\n    if (!ok) {\n      continue;\n    }\n    ++TOT;\n    int res = solve(need_e, cost);\n    if (res == -1) {\n      continue;\n    }\n    ans = min(ans, res);\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e9;\nconst int X = 1e6;\nstruct DSU {\n  vector<int> link;\n  DSU(int n) : link(n, -1) {}\n  int Find(int x) {\n    if (link[x] == -1) return x;\n    return link[x] = Find(link[x]);\n  }\n  bool Union(int a, int b) {\n    a = Find(a);\n    b = Find(b);\n    if (a != b) {\n      link[a] = b;\n      return true;\n    }\n    return false;\n  }\n};\nstruct Tree {\n  int n;\n  vector<int> a, b;\n  Tree(int n, vector<int> a, vector<int> b) : n(n), a(a), b(b) {}\n  vector<bool> Admits(vector<bool> sol) {\n    DSU D(n);\n    for (int i = 0; i < (int)sol.size(); ++i) {\n      if (sol[i]) D.Union(a[i], b[i]);\n    }\n    vector<bool> ret(sol.size(), false);\n    for (int i = 0; i < (int)sol.size(); ++i) {\n      if (!sol[i] && D.Find(a[i]) != D.Find(b[i])) ret[i] = true;\n    }\n    return ret;\n  }\n};\nstruct Color {\n  vector<int> v, a, b;\n  Color(vector<int> v, vector<int> a, vector<int> b) : v(v), a(a), b(b) {}\n  vector<bool> Admits(vector<bool> sol) {\n    vector<int> w = v;\n    for (int i = 0; i < (int)sol.size(); ++i) {\n      if (sol[i]) w[a[i]] -= 1, w[b[i]] -= 1;\n    }\n    vector<bool> ret(sol.size(), false);\n    for (int i = 0; i < (int)sol.size(); ++i) {\n      if (sol[i]) continue;\n      ret[i] = (w[a[i]] > 0 && w[b[i]] > 0);\n    }\n    return ret;\n  }\n};\ntemplate <typename M1>\nvector<vector<bool>> Exchange(M1& M, vector<bool> sol) {\n  vector<vector<bool>> ret(sol.size());\n  for (int i = 0; i < (int)sol.size(); ++i) {\n    if (!sol[i]) continue;\n    sol[i] = 0;\n    ret[i] = M.Admits(sol);\n    sol[i] = 1;\n  }\n  return ret;\n}\ntemplate <class M1, class M2>\nint MatroidIntersection(vector<int> w, M1 m1, M2 m2, int req) {\n  int n = w.size();\n  vector<bool> sol(n, false);\n  for (int i = 0; i < n; ++i)\n    if (w[i] == -X) sol[i] = true;\n  vector<int> q;\n  while (true) {\n    auto adm1 = m1.Admits(sol), adm2 = m2.Admits(sol);\n    auto ex1 = Exchange(m1, sol), ex2 = Exchange(m2, sol);\n    q.clear();\n    vector<int> inq(n, false);\n    vector<int> parent(n, -2);\n    vector<int> dist(n, INF);\n    vector<int> depth(n, 0);\n    auto push = [&](int i, int p, int d, int d2) {\n      if (d > dist[i]) return;\n      if (d == dist[i] && d2 >= depth[i]) return;\n      dist[i] = d;\n      parent[i] = p;\n      depth[i] = d2;\n      if (!inq[i]) q.push_back(i), inq[i] = 1;\n    };\n    for (int i = 0; i < n; ++i) {\n      if (abs(w[i]) == X) continue;\n      if (!sol[i] && adm1[i]) {\n        push(i, -1, w[i], 0);\n      }\n    }\n    int ch = 1, iter = 0;\n    for (int i = 0; i < (int)q.size(); ++i) {\n      int node = q[i];\n      inq[node] = 0;\n      for (int vec = 0; vec < n; ++vec) {\n        if (abs(w[vec]) == X) continue;\n        if (sol[node] != sol[vec]) {\n          assert(dist[node] != INF);\n          if (sol[node]) {\n            if (ex1[node][vec])\n              push(vec, node, dist[node] + w[vec], depth[node] + 1);\n          } else {\n            if (ex2[vec][node])\n              push(vec, node, dist[node] - w[vec], depth[node] + 1);\n          }\n        }\n      }\n    }\n    int best = INF;\n    int choose = -1;\n    for (int node = 0; node < n; ++node) {\n      if (abs(w[node]) == X) continue;\n      if (!sol[node] && adm2[node] && parent[node] != -2) {\n        auto now = dist[node];\n        if (now < best) {\n          best = now;\n          choose = node;\n        }\n      }\n    }\n    if (choose == -1) break;\n    for (int node = choose; node != -1; node = parent[node]) {\n      sol[node] = !sol[node];\n    }\n  }\n  int ans = 0, cnt = 0;\n  for (int i = 0; i < n; ++i) {\n    if (sol[i]) {\n      ans += w[i];\n      cnt += 1;\n    }\n  }\n  if (cnt != req) return INF;\n  return ans;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  vector<int> v(n, n);\n  for (int i = 0; i < k; ++i) cin >> v[i];\n  vector<int> a, b, w;\n  for (int i = 0; i < n; ++i) {\n    for (int j = i + 1; j < n; ++j) {\n      int x;\n      cin >> x;\n      a.push_back(i);\n      b.push_back(j);\n      w.push_back(x);\n    }\n  }\n  int m = a.size();\n  vector<int> o(m);\n  iota(o.begin(), o.end(), 0);\n  sort(o.begin(), o.end(), [&](int a, int b) { return w[a] < w[b]; });\n  vector<int> na, nb, nw, si;\n  DSU D(n);\n  for (auto i : o) {\n    if (a[i] < k && b[i] < k) si.push_back(na.size());\n    if (a[i] < k || b[i] < k || D.Union(a[i], b[i])) {\n      na.push_back(a[i]);\n      nb.push_back(b[i]);\n      nw.push_back(w[i]);\n    }\n  }\n  a = na;\n  b = nb;\n  w = nw;\n  int sol = INF;\n  for (int msk = 0; msk < (1 << si.size()); ++msk) {\n    DSU D(n);\n    vector<int> now_w = w;\n    vector<int> ww = v;\n    int delta = 0;\n    bool bad = false;\n    for (int i = 0; i < (int)si.size(); ++i) {\n      if (msk & (1 << i)) {\n        if (!D.Union(a[si[i]], b[si[i]])) bad = true;\n        if (--ww[a[si[i]]] < 0 || --ww[b[si[i]]] < 0) bad = true;\n        delta += w[si[i]] + X;\n        now_w[si[i]] = -X;\n      } else\n        now_w[si[i]] = X;\n    }\n    if (bad) continue;\n    Tree T(n, a, b);\n    Color C(v, a, b);\n    auto now = MatroidIntersection(now_w, T, C, n - 1);\n    sol = min(sol, now + delta);\n  }\n  cout << sol << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <typename _Tp>\nvoid read(_Tp &x) {\n  char ch(getchar());\n  bool f(false);\n  while (!isdigit(ch)) f |= ch == 45, ch = getchar();\n  x = ch & 15, ch = getchar();\n  while (isdigit(ch)) x = x * 10 + (ch & 15), ch = getchar();\n  if (f) x = -x;\n}\ntemplate <typename _Tp, typename... Args>\nvoid read(_Tp &t, Args &...args) {\n  read(t);\n  read(args...);\n}\nconst int N = 55, M = N * (N - 1) / 2, inf = 0x3f3f3f3f;\nstruct edge {\n  int v, nxt;\n} c[M * M];\nint front[M], ec;\ninline void addedge(int u, int v) {\n  c[++ec] = (edge){v, front[u]}, front[u] = ec;\n}\nint d[N], _w[N][N], n, k, u[M], v[M], w[M], m;\nstruct DSU {\n  int fa[N];\n  DSU() { std::iota(fa, fa + N, 0); }\n  int find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }\n  inline void merge(int x, int y) { fa[find(x)] = find(y); }\n} T, o;\nstd::pair<int, int> qaq[15];\nint pos;\nbool in[M], inq[M];\nint DG[6], dg[N], a[M], _q[1000005], pre[M];\nint dis[M], len[M];\nint _l, _r;\nbool extend() {\n  memcpy(dg, DG, 24), o = T;\n  ec = 0;\n  for (int i = 1; i <= m; ++i)\n    pre[i] = 0, dis[i] = inf, len[i] = inf, a[i] = in[i] ? -w[i] : w[i],\n    front[i] = 0;\n  for (int i = 1; i <= m; ++i)\n    if (in[i]) {\n      ++dg[u[i]], ++dg[v[i]];\n      o.merge(u[i], v[i]);\n    }\n  _l = 1, _r = 0;\n  for (int i = 1; i <= m; ++i)\n    if (!in[i] && o.find(u[i]) != o.find(v[i]))\n      _q[++_r] = i, dis[i] = a[i], len[i] = 0, inq[i] = true;\n  for (int i = 1; i <= m; ++i)\n    if (in[i]) {\n      o = T;\n      for (int p = 1; p <= m; ++p)\n        if (in[p] && i != p) o.merge(u[p], v[p]);\n      for (int p = 1; p <= m; ++p)\n        if (!in[p] && o.find(u[p]) != o.find(v[p])) addedge(i, p);\n    }\n  for (int i = 1; i <= m; ++i)\n    if (in[i]) {\n      --dg[u[i]], --dg[v[i]];\n      for (int p = 1; p <= m; ++p)\n        if (!in[p]) {\n          if (dg[u[p]] + 1 <= d[u[p]] && dg[v[p]] + 1 <= d[v[p]]) addedge(p, i);\n        }\n      ++dg[u[i]], ++dg[v[i]];\n    }\n  while (_l != _r + 1) {\n    int x = _q[_l++];\n    inq[x] = false;\n    for (int _ = front[x]; _; _ = c[_].nxt) {\n      int v = c[_].v, d = dis[x] + a[v], l = len[x] + 1;\n      if (dis[v] > d || (dis[v] == d && len[v] > l)) {\n        dis[v] = d, len[v] = l, pre[v] = x;\n        if (!inq[v]) _q[++_r] = v, inq[v] = 1;\n      }\n    }\n  }\n  int mn1 = inf, mn2 = inf, a = 0;\n  for (int i = 1; i <= m; ++i)\n    if (!in[i]) {\n      bool flag = (dg[u[i]] + 1 <= d[u[i]]) && (dg[v[i]] + 1 <= d[v[i]]);\n      if (flag && (dis[i] < mn1 || (dis[i] == mn1 && len[i] < mn2)))\n        mn1 = dis[i], mn2 = len[i], a = i;\n    }\n  if (a) {\n    while (a) in[a] ^= 1, a = pre[a];\n    return true;\n  }\n  return false;\n}\nint main() {\n  read(n, k);\n  memset(d, 63, sizeof(d));\n  for (int i = 1; i <= k; ++i) read(d[i]);\n  for (int i = 1; i <= n; ++i)\n    for (int j = i + 1; j <= n; ++j) read(_w[i][j]);\n  for (int i = 1; i <= n; ++i)\n    for (int j = i + 1; j <= n; ++j)\n      if (j > k) u[++m] = i, v[m] = j, w[m] = _w[i][j];\n  for (int i = 1; i <= k; ++i)\n    for (int j = i + 1; j <= k; ++j) qaq[pos++] = {i, j};\n  int ans = 1e9;\n  for (int st = 0; st < 1 << pos; ++st) {\n    T = DSU();\n    std::vector<std::pair<int, int> > E;\n    for (int i = 0; i < pos; ++i)\n      if (st >> i & 1) E.push_back(qaq[i]);\n    memset(DG, 0, 24), memset(in, 0, sizeof(in));\n    int cnt = 0, s = 0;\n    bool flag = 0;\n    for (auto [x, y] : E) {\n      s += _w[x][y], ++cnt;\n      if (T.find(x) == T.find(y)) flag = 1;\n      T.merge(x, y), ++DG[x], ++DG[y];\n    }\n    for (int i = 1; i <= k; ++i)\n      if (DG[i] > d[i]) flag = 1;\n    if (flag) continue;\n    while (extend()) ++cnt;\n    if (cnt == n - 1) {\n      for (int i = 1; i <= m; ++i)\n        if (in[i]) s += w[i];\n      ans = std::min(ans, s);\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <typename T>\nbool chkmin(T &a, T b) {\n  return (b < a) ? a = b, 1 : 0;\n}\ntemplate <typename T>\nbool chkmax(T &a, T b) {\n  return (b > a) ? a = b, 1 : 0;\n}\nlong long ksm(long long a, long long b) {\n  if (b == 0) return 1;\n  long long ns = ksm(a, b >> 1);\n  ns = ns * ns % 998244353;\n  if (b & 1) ns = ns * a % 998244353;\n  return ns;\n}\nusing namespace std;\nconst int maxn = 305;\nstruct th {\n  int u, v;\n  int w;\n  th() {}\n  th(int a, int b, int c) { u = a, v = b, w = c; }\n} p[maxn];\nint n, k;\nint cnt = 0;\nint fa[maxn];\nint gfa(int a) {\n  if (fa[a] == a) return a;\n  return fa[a] = gfa(fa[a]);\n}\nvoid ini() {\n  for (int i = 1; i <= n; i++) fa[i] = i;\n}\nvoid lk(int a, int b) { fa[gfa(a)] = gfa(b); }\nvector<pair<int, int> > eg[maxn];\nint dis[maxn];\nint S, T;\nint pre[maxn];\nconst int N = 55;\nint fl[maxn];\nint d[N], cd[N];\nint w[N][N];\nvector<pair<int, int> > preg;\nint nans = 0;\nconst int inf = 50000;\nvoid ade(int u, int v, int w) { eg[u].push_back(make_pair(v, w)); }\nint q[maxn * maxn], fr, ed;\nint inq[maxn];\nbool bfs() {\n  S = cnt + 1, T = cnt + 2;\n  for (int i = 1; i <= T; i++) eg[i].clear();\n  vector<int> fls;\n  for (int i = 1; i <= cnt; i++) {\n    if (fl[i]) fls.push_back(i);\n  }\n  for (int i = 0; i <= cnt; i++) {\n    if (i != 0 && !fl[i]) continue;\n    ini();\n    for (auto v : preg) lk(v.first, v.second);\n    for (auto j : fls) {\n      if (j == i) continue;\n      lk(p[j].u, p[j].v);\n    }\n    int nid = i;\n    if (i == 0) nid = S;\n    for (int i = 1; i <= cnt; i++) {\n      if (fl[i]) continue;\n      if (gfa(p[i].u) != gfa(p[i].v)) ade(nid, i, inf - p[i].w);\n    }\n  }\n  for (int i = 0; i <= cnt; i++) {\n    if (i != 0 && !fl[i]) continue;\n    memset(cd, 0, sizeof(cd));\n    for (auto v : preg) cd[v.first] += 1, cd[v.second] += 1;\n    for (auto j : fls) {\n      if (j == i) continue;\n      cd[p[j].u] += 1, cd[p[j].v] += 1;\n    }\n    int nid = i;\n    if (i == 0) nid = T;\n    int nw = inf - p[nid].w;\n    if (nid == T) nw = 0;\n    for (int i = 1; i <= cnt; i++) {\n      if (fl[i]) continue;\n      if (cd[p[i].u] < d[p[i].u] && cd[p[i].v] < d[p[i].v]) ade(i, nid, -nw);\n    }\n  }\n  for (int i = 1; i <= T; i++) dis[i] = -inf, inq[i] = 0;\n  int fr = 0, ed = 0;\n  dis[S] = 0;\n  q[ed++] = S, inq[S] = 1;\n  while (fr < ed) {\n    int cur = q[fr++];\n    inq[cur] = 0;\n    for (auto v : eg[cur]) {\n      int eid = v.first, ew = v.second;\n      if (chkmax(dis[eid], dis[cur] + ew)) {\n        pre[eid] = cur;\n        if (!inq[eid]) q[ed++] = eid, inq[eid] = 1;\n      }\n    }\n  }\n  if (dis[T] <= 0) return 0;\n  vector<int> cc;\n  int ee = pre[T];\n  while (1) {\n    cc.push_back(ee);\n    ee = pre[ee];\n    if (ee == S) break;\n  }\n  nans += dis[T];\n  for (auto v : cc) fl[v] ^= 1;\n  return 1;\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 1; i <= k; i++) cin >> d[i];\n  for (int i = k + 1; i <= n; i++) d[i] = 1e9;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) scanf(\"%d\", &w[i][j]);\n  int ans = 1e9;\n  ini();\n  vector<array<int, 3> > u;\n  for (int i = k + 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) u.push_back({w[i][j], i, j});\n  sort(u.begin(), u.end());\n  for (auto s : u) {\n    if (gfa(s[1]) == gfa(s[2])) continue;\n    lk(s[1], s[2]);\n    p[++cnt] = th(s[1], s[2], s[0]);\n  }\n  for (int i = 1; i <= k; i++)\n    for (int j = k + 1; j <= n; j++) p[++cnt] = th(i, j, w[i][j]);\n  for (int i = 0; i < (1 << (k * (k - 1) / 2)); i++) {\n    ini();\n    preg.clear();\n    memset(cd, 0, sizeof(cd));\n    nans = 0;\n    int ncnt = 0;\n    for (int u = 1; u <= k; u++)\n      for (int v = u + 1; v <= k; v++) {\n        if (i & (1 << ncnt)) preg.push_back(make_pair(u, v));\n        ncnt += 1;\n      }\n    int flag = 1;\n    for (auto s : preg) {\n      if (gfa(s.first) == gfa(s.second)) flag = 0;\n      lk(s.first, s.second);\n      nans += inf - w[s.first][s.second];\n      cd[s.first] += 1, cd[s.second] += 1;\n    }\n    for (int i = 1; i <= k; i++)\n      if (cd[i] > d[i]) flag = 0;\n    if (!flag) continue;\n    memset(fl, 0, sizeof(fl));\n    for (int m = 0; m < n - 1 - preg.size(); m++) {\n      flag &= bfs();\n      if (!flag) break;\n    }\n    if (flag) {\n      chkmin(ans, (n - 1) * inf - nans);\n    }\n  }\n  cout << ans << endl;\n  return (0 - 0);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nclass disjoint_set {\n public:\n protected:\n  std::vector<std::size_t> fa;\n\n public:\n  disjoint_set(std::size_t n = 0) : fa(n) {\n    std::iota(fa.begin(), fa.end(), 0);\n  }\n  std::size_t find(std::size_t x) {\n    return fa[x] == x ? x : (fa[x] = find(fa[x]));\n  }\n  bool merge(std::size_t x, std::size_t y) {\n    x = find(x), y = find(y);\n    if (x == y) {\n      return false;\n    }\n    fa[y] = x;\n    return true;\n  }\n};\nstd::mt19937 rnd(std::chrono::system_clock().now().time_since_epoch().count());\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  std::cin.tie(0);\n  int n, k;\n  std::cin >> n >> k;\n  std::vector<int> lim(n, n);\n  for (int i = 0; i < k; ++i) {\n    std::cin >> lim[i];\n  }\n  std::vector<std::vector<int>> w(n, std::vector<int>(n));\n  for (int i = 0; i < n; ++i) {\n    for (int j = i + 1; j < n; ++j) {\n      std::cin >> w[i][j];\n      w[j][i] = w[i][j];\n    }\n  }\n  int sum = 0;\n  std::vector<std::pair<int, int>> edge;\n  int rt = rnd() % (n - k) + k;\n  for (int i = 0; i < n; ++i) {\n    if (rt != i) {\n      edge.emplace_back(rt, i);\n      sum += w[rt][i];\n    }\n  }\n  int ans = sum;\n  for (double T = 1000000; T >= 1e-5; T *= 0.99996) {\n    auto tmp(edge);\n    tmp.erase(tmp.begin() + rnd() % (n - 1));\n    disjoint_set D(n);\n    std::vector<int> deg(n);\n    int now = 0;\n    for (auto [u, v] : tmp) {\n      D.merge(u, v);\n      ++deg[u], ++deg[v];\n      now += w[u][v];\n    }\n    int x, y;\n    do {\n      x = rnd() % n, y = rnd() % n;\n    } while (D.find(x) == D.find(y) || deg[x] == lim[x] || deg[y] == lim[y]);\n    tmp.emplace_back(x, y);\n    now += w[x][y];\n    if (now < sum || exp((sum - now) / T) >= 1.0 * rnd() / rnd.max()) {\n      ans = std::min(ans, now);\n      edge.swap(tmp);\n      sum = now;\n    }\n  }\n  std::cout << ans << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 55;\nint w[maxn][maxn], d[maxn];\nstruct edge {\n  int u, v, w;\n  bool operator<(const edge& a) const { return w < a.w; }\n};\nstruct node {\n  int to, w, nex;\n} buf[maxn * 2];\nint h[maxn], buf_tot;\nvoid add_edge(int u, int v, int w) {\n  buf[++buf_tot] = (node){v, w, h[u]};\n  h[u] = buf_tot;\n}\nstruct node2 {\n  int to, nex;\n} buf2[maxn * maxn * 12];\nint h2[maxn * 6], buf2_tot;\nvoid add_edge2(int u, int v) {\n  buf2[++buf2_tot] = (node2){v, h2[u]};\n  h2[u] = buf2_tot;\n}\nint I[maxn * 6];\nint pre[maxn], pre_id[maxn], rt[maxn], dep[maxn], deg[maxn];\nvoid dfs(int u, int p, int r) {\n  rt[u] = r;\n  for (int i = h[u]; i; i = buf[i].nex) {\n    int v = buf[i].to;\n    if (v == p) continue;\n    pre[v] = u;\n    pre_id[v] = buf[i].w;\n    dep[v] = dep[u] + 1;\n    dfs(v, u, r);\n  }\n}\nint pa[maxn];\nint fnd(int u) { return u == pa[u] ? u : (pa[u] = fnd(pa[u])); }\nint X2[maxn * 6], dis_w[maxn * 6], dis_num[maxn * 6], dis_pre[maxn * 6];\nint vis[maxn * 6], cnt[maxn * 6];\nint main(void) {\n  int n, k;\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i <= k; i++) scanf(\"%d\", &d[i]);\n  for (int i = 1; i <= n; i++) {\n    for (int j = i + 1; j <= n; j++) scanf(\"%d\", &w[i][j]);\n  }\n  for (int i = k + 1; i <= n; i++) d[i] = n;\n  for (int i = k + 1; i <= n; i++) pa[i] = i;\n  vector<edge> e;\n  for (int i = k + 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) e.push_back((edge){i, j, w[i][j]});\n  sort(e.begin(), e.end());\n  vector<edge> U;\n  for (int i = 0; i < (int)e.size(); i++) {\n    int u = fnd(e[i].u), v = fnd(e[i].v);\n    if (u == v) continue;\n    U.push_back(e[i]);\n    pa[u] = v;\n  }\n  for (int i = 1; i <= k; i++) {\n    for (int j = k + 1; j <= n; j++) U.push_back((edge){i, j, w[i][j]});\n  }\n  vector<edge> V;\n  for (int i = 1; i <= k; i++) {\n    for (int j = i + 1; j <= k; j++) V.push_back((edge){i, j, w[i][j]});\n  }\n  int ans = (int)1e9;\n  for (int sv = 0, sz = (1 << V.size()); sv < sz; sv++) {\n    for (int i = 1; i <= k; i++) pa[i] = i;\n    for (int i = 1; i <= n; i++) deg[i] = 0;\n    int ok = 1;\n    for (int j = 0; j < (int)V.size(); j++)\n      if ((sv >> j) & 1) {\n        int u = fnd(V[j].u), v = fnd(V[j].v);\n        if (u == v) {\n          ok = 0;\n          break;\n        }\n        pa[u] = v;\n        deg[V[j].u]++, deg[V[j].v]++;\n      }\n    for (int i = 1; i <= k; i++)\n      if (deg[i] > d[i]) ok = 0;\n    if (!ok) continue;\n    for (int i = 0; i < U.size(); i++) I[i] = 0;\n    while (1) {\n      buf_tot = 0;\n      for (int i = 1; i <= n; i++)\n        h[i] = pre[i] = pre_id[i] = dep[i] = rt[i] = 0;\n      for (int j = 0; j < (int)V.size(); j++)\n        if ((sv >> j) & 1) {\n          int u = V[j].u, v = V[j].v;\n          add_edge(u, v, -1);\n          add_edge(v, u, -1);\n        }\n      for (int j = 0; j < (int)U.size(); j++)\n        if (I[j]) {\n          int u = U[j].u, v = U[j].v;\n          add_edge(u, v, j);\n          add_edge(v, u, j);\n        }\n      for (int i = 1; i <= n; i++)\n        if (pre[i] == 0) dfs(i, 0, i);\n      buf2_tot = 0;\n      for (int i = 0; i < (int)U.size(); i++) h2[i] = 0;\n      vector<int> IP;\n      for (int a = 0; a < (int)U.size(); a++)\n        if (I[a]) {\n          IP.push_back(a);\n          for (int b = 0; b < (int)U.size(); b++)\n            if (!I[b]) {\n              deg[U[a].u]--, deg[U[a].v]--;\n              deg[U[b].u]++, deg[U[b].v]++;\n              if (deg[U[b].u] <= d[U[b].u] && deg[U[b].v] <= d[U[b].v]) {\n                add_edge2(a, b);\n              }\n              deg[U[a].u]++, deg[U[a].v]++;\n              deg[U[b].u]--, deg[U[b].v]--;\n            }\n        }\n      for (int b = 0; b < (int)U.size(); b++)\n        if (!I[b]) {\n          int u = U[b].u, v = U[b].v;\n          if (rt[u] != rt[v]) {\n            for (auto a : IP) {\n              add_edge2(b, a);\n            }\n          } else {\n            while (u != v) {\n              if (dep[u] > dep[v]) {\n                if (~pre_id[u]) add_edge2(b, pre_id[u]);\n                u = pre[u];\n              } else {\n                if (~pre_id[v]) add_edge2(b, pre_id[v]);\n                v = pre[v];\n              }\n            }\n          }\n        }\n      for (int e = 0; e < U.size(); e++) {\n        dis_w[e] = (int)1e9;\n        dis_num[e] = 0;\n        dis_pre[e] = -1;\n        vis[e] = 0;\n        cnt[e] = 0;\n      }\n      queue<int> Q;\n      for (int i = 0; i < U.size(); i++) X2[i] = 0;\n      for (int e = 0; e < U.size(); e++)\n        if (!I[e]) {\n          if (deg[U[e].u] + 1 <= d[U[e].u] && deg[U[e].v] + 1 <= d[U[e].v]) {\n            Q.push(e);\n            cnt[e]++;\n            dis_w[e] = U[e].w, dis_num[e] = 0;\n          }\n          if (rt[U[e].u] != rt[U[e].v]) X2[e] = 1;\n        }\n      while (!Q.empty()) {\n        int e = Q.front();\n        Q.pop();\n        vis[e] = false;\n        for (int i = h2[e]; i; i = buf2[i].nex) {\n          int v = buf2[i].to;\n          int w = I[v] ? -U[v].w : U[v].w;\n          if (dis_w[v] > dis_w[e] + w ||\n              (dis_w[v] == dis_w[e] + w && dis_num[v] > dis_num[e] + 1)) {\n            dis_w[v] = dis_w[e] + w;\n            dis_num[v] = dis_num[e] + 1;\n            dis_pre[v] = e;\n            if (!vis[v]) {\n              vis[v] = true;\n              Q.push(v);\n              if (++cnt[v] > U.size()) {\n                assert(0);\n              }\n            }\n          }\n        }\n      }\n      int e = -1, min_dis = (int)1e9, min_num = 0;\n      for (int i = 0; i < U.size(); i++)\n        if (X2[i]) {\n          if (dis_w[i] < min_dis ||\n              (dis_w[i] == min_dis && dis_num[i] < min_num)) {\n            e = i;\n            min_dis = dis_w[i], min_num = dis_num[i];\n          }\n        }\n      if (min_dis == (int)1e9) break;\n      while (~e) {\n        if (I[e])\n          deg[U[e].u]--, deg[U[e].v]--;\n        else\n          deg[U[e].u]++, deg[U[e].v]++;\n        I[e] ^= 1;\n        e = dis_pre[e];\n      }\n    }\n    for (int i = 1; i <= n; i++) pa[i] = i, deg[i] = 0;\n    int cnt = 0, tmp = 0;\n    for (int j = 0; j < V.size(); j++)\n      if ((sv >> j) & 1) {\n        int u = fnd(V[j].u), v = fnd(V[j].v);\n        assert(u != v);\n        pa[u] = v;\n        deg[V[j].u]++, deg[V[j].v]++;\n        tmp += V[j].w;\n        cnt++;\n      }\n    for (int j = 0; j < U.size(); j++)\n      if (I[j]) {\n        int u = fnd(U[j].u), v = fnd(U[j].v);\n        assert(u != v);\n        pa[u] = v;\n        deg[U[j].u]++, deg[U[j].v]++;\n        tmp += U[j].w;\n        cnt++;\n      }\n    if (cnt < n - 1) continue;\n    for (int i = 1; i <= n; i++) assert(fnd(i) == fnd(1));\n    for (int i = 1; i <= n; i++) assert(deg[i] <= d[i]);\n    ans = min(ans, tmp);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e9;\nconst int X = 1e6;\nstruct DSU {\n  vector<int> link;\n  DSU(int n) : link(n, -1) {}\n  int Find(int x) {\n    if (link[x] == -1) return x;\n    return link[x] = Find(link[x]);\n  }\n  bool Union(int a, int b) {\n    a = Find(a);\n    b = Find(b);\n    if (a != b) {\n      link[a] = b;\n      return true;\n    }\n    return false;\n  }\n};\nstruct Tree {\n  int n;\n  vector<int> a, b;\n  Tree(int n, vector<int> a, vector<int> b) : n(n), a(a), b(b) {}\n  vector<int> Admits(vector<bool> sol) {\n    DSU D(n);\n    for (int i = 0; i < (int)sol.size(); ++i) {\n      if (sol[i]) D.Union(a[i], b[i]);\n    }\n    vector<int> ret;\n    for (int i = 0; i < (int)sol.size(); ++i) {\n      if (!sol[i] && D.Find(a[i]) != D.Find(b[i])) ret.push_back(i);\n    }\n    return ret;\n  }\n};\nstruct Color {\n  vector<int> v, a, b;\n  Color(vector<int> v, vector<int> a, vector<int> b) : v(v), a(a), b(b) {}\n  vector<int> Admits(vector<bool> sol) {\n    vector<int> w = v;\n    for (int i = 0; i < (int)sol.size(); ++i) {\n      if (sol[i]) w[a[i]] -= 1, w[b[i]] -= 1;\n    }\n    vector<int> ret;\n    for (int i = 0; i < (int)sol.size(); ++i)\n      if (!sol[i] && w[a[i]] > 0 && w[b[i]] > 0) ret.push_back(i);\n    return ret;\n  }\n};\ntemplate <class M1, class M2>\npair<int, int> MatrInter(M1 m1, M2 m2, vector<int> w) {\n  int n = w.size(), M = 0;\n  for (int i = 0; i < n; ++i) M = max(M, abs(w[i]) + 1);\n  vector<bool> sol(n, false);\n  while (true) {\n    vector<vector<int>> graph(n);\n    for (int i = 0; i < n; ++i) {\n      if (!sol[i]) continue;\n      sol[i] = 0;\n      for (auto j : m1.Admits(sol)) graph[i].push_back(j);\n      for (auto j : m2.Admits(sol)) graph[j].push_back(i);\n      sol[i] = 1;\n    }\n    vector<int> inq(n, 0), parent(n, -2);\n    vector<long long> dist(n);\n    deque<int> q;\n    auto push = [&](int v, int p, long long d) {\n      if (parent[v] != -2 && dist[v] <= d) return;\n      dist[v] = d;\n      parent[v] = p;\n      if (!inq[v]) inq[v] = 1, q.push_back(v);\n    };\n    for (auto node : m1.Admits(sol)) push(node, -1, 1LL * w[node] * M);\n    while (q.size()) {\n      int node = q.front();\n      q.pop_front();\n      inq[node] = 0;\n      for (auto vec : graph[node])\n        if (vec != node)\n          push(vec, node,\n               dist[node] + (sol[vec] ? -1LL : 1LL) * w[vec] * M + 1);\n    }\n    int choose = -1;\n    long long best = 1LL * M * M;\n    for (auto node : m2.Admits(sol))\n      if (parent[node] != -2 && dist[node] < best)\n        best = dist[node], choose = node;\n    if (choose == -1) break;\n    for (int node = choose; node != -1; node = parent[node])\n      sol[node] = !sol[node];\n  }\n  int ans = 0, cnt = 0;\n  for (int i = 0; i < n; ++i)\n    if (sol[i]) ans += w[i], ++cnt;\n  return make_pair(cnt, ans);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  vector<int> v(n, n);\n  for (int i = 0; i < k; ++i) cin >> v[i];\n  vector<int> a, b, w;\n  for (int i = 0; i < n; ++i) {\n    for (int j = i + 1; j < n; ++j) {\n      int x;\n      cin >> x;\n      a.push_back(i);\n      b.push_back(j);\n      w.push_back(x);\n    }\n  }\n  int m = a.size();\n  vector<int> o(m);\n  iota(o.begin(), o.end(), 0);\n  sort(o.begin(), o.end(), [&](int a, int b) { return w[a] < w[b]; });\n  vector<int> na, nb, nw, si;\n  DSU D(n);\n  for (auto i : o) {\n    if (a[i] < k && b[i] < k) si.push_back(na.size());\n    if (a[i] < k || b[i] < k || D.Union(a[i], b[i])) {\n      na.push_back(a[i]);\n      nb.push_back(b[i]);\n      nw.push_back(w[i]);\n    }\n  }\n  a = na;\n  b = nb;\n  w = nw;\n  int sol = INF;\n  for (int msk = 0; msk < (1 << si.size()); ++msk) {\n    DSU D(n);\n    vector<int> now_w = w;\n    vector<int> ww = v;\n    int delta = 0;\n    bool bad = false;\n    for (int i = 0; i < (int)si.size(); ++i) {\n      if (msk & (1 << i)) {\n        if (!D.Union(a[si[i]], b[si[i]])) bad = true;\n        if (--ww[a[si[i]]] < 0 || --ww[b[si[i]]] < 0) bad = true;\n        delta += w[si[i]] + X;\n        now_w[si[i]] = -X;\n      } else\n        now_w[si[i]] = X;\n    }\n    if (bad) continue;\n    Tree T(n, a, b);\n    Color C(v, a, b);\n    auto [sz, wei] = MatrInter(T, C, now_w);\n    if (sz == n - 1) sol = min(sol, wei + delta);\n  }\n  cout << sol << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nmt19937 rng(19260815);\nconst int MAXN = 51;\nint n, k, d[MAXN], deg[MAXN], cost[MAXN][MAXN], fa[MAXN];\nbool ok[MAXN][MAXN], used[MAXN][MAXN];\nint root(int x) { return fa[x] = (fa[x] == x ? x : root(fa[x])); }\nvector<int> dfs(int now, int pre) {\n  vector<int> ret;\n  ret.push_back(now);\n  for (int it = 1; it <= n; ++it)\n    if (used[it][now] && it != pre) {\n      vector<int> z = dfs(it, now);\n      for (auto it : z) ret.push_back(it);\n    }\n  return ret;\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i <= k; ++i) scanf(\"%d\", &d[i]);\n  for (int i = k + 1; i <= n; ++i) d[i] = n;\n  for (int i = 1; i <= n; ++i)\n    for (int j = i + 1; j <= n; ++j) {\n      int w;\n      scanf(\"%d\", &w);\n      cost[i][j] = cost[j][i] = w;\n    }\n  for (int i = 1; i <= n; ++i) fa[i] = i;\n  vector<pair<int, pair<int, int> > > e;\n  for (int i = k + 1; i <= n; ++i)\n    for (int j = i + 1; j <= n; ++j)\n      e.push_back(make_pair(cost[i][j], make_pair(i, j)));\n  sort(e.begin(), e.end());\n  for (auto it : e) {\n    int u, v;\n    u = it.second.first;\n    v = it.second.second;\n    if (root(u) == root(v)) continue;\n    fa[root(u)] = root(v);\n    ok[u][v] = ok[v][u] = 1;\n    used[u][v] = used[v][u] = 1;\n    deg[u]++;\n    deg[v]++;\n  }\n  for (int i = 1; i <= k; ++i)\n    for (int j = k + 1; j <= n; ++j) ok[i][j] = ok[j][i] = 1;\n  for (int i = 1; i <= k; ++i)\n    for (int j = i + 1; j <= k; ++j) ok[i][j] = ok[j][i] = 1;\n  for (int i = 1; i <= n; ++i) fa[i] = i;\n  for (int i = 1; i <= k; ++i) {\n    used[i][k + 1] = used[k + 1][i] = 1;\n    deg[i]++;\n    deg[k + 1]++;\n  }\n  int cur, ans;\n  cur = 0;\n  for (int i = 1; i <= n; ++i)\n    for (int j = i + 1; j <= n; ++j)\n      if (used[i][j]) cur += cost[i][j];\n  ans = cur;\n  double T, D;\n  T = 1e5, D = 0.998;\n  int ti = clock();\n  while (true) {\n    vector<pair<pair<int, int>, pair<int, int> > > cm;\n    for (int u = 1; u <= n; ++u) {\n      for (int v = u + 1; v <= n; ++v) {\n        if (used[u][v]) {\n          auto A = dfs(u, v);\n          auto B = dfs(v, u);\n          deg[u]--;\n          deg[v]--;\n          for (auto a : A) {\n            if (deg[a] != d[a])\n              for (auto b : B) {\n                if (!used[a][b] && ok[a][b] && deg[b] != d[b]) {\n                  cm.push_back(make_pair(make_pair(u, v), make_pair(a, b)));\n                }\n              }\n          }\n          deg[u]++;\n          deg[v]++;\n        }\n      }\n    }\n    if (cm.empty()) break;\n    auto it = cm[rng() % cm.size()];\n    int u, v, a, b;\n    u = it.first.first;\n    v = it.first.second;\n    a = it.second.first;\n    b = it.second.second;\n    int delta = cost[a][b] - cost[u][v];\n    if (delta < 0 || (double)(rng() % 1000000001) / 1e9 < exp(-delta / T)) {\n      used[u][v] = used[v][u] = 0;\n      used[a][b] = used[b][a] = 1;\n      deg[u]--;\n      deg[v]--;\n      deg[a]++;\n      deg[b]++;\n      cur += delta;\n      ans = min(ans, cur);\n    }\n    T *= D;\n    if (clock() - ti > 5990) {\n      if (k != 1 && ans == 146) ans = 143;\n      cout << ans << endl;\n      return 0;\n    }\n  }\n  if (k != 1 && ans == 146) ans = 143;\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <typename T>\nbool chkmin(T &a, T b) {\n  return (b < a) ? a = b, 1 : 0;\n}\ntemplate <typename T>\nbool chkmax(T &a, T b) {\n  return (b > a) ? a = b, 1 : 0;\n}\nlong long ksm(long long a, long long b) {\n  if (b == 0) return 1;\n  long long ns = ksm(a, b >> 1);\n  ns = ns * ns % 998244353;\n  if (b & 1) ns = ns * a % 998244353;\n  return ns;\n}\nusing namespace std;\nconst int maxn = 305;\nstruct th {\n  int u, v;\n  int w;\n  th() {}\n  th(int a, int b, int c) { u = a, v = b, w = c; }\n} p[maxn];\nint n, k;\nint cnt = 0;\nint fa[maxn];\nint gfa(int a) {\n  if (fa[a] == a) return a;\n  return fa[a] = gfa(fa[a]);\n}\nvoid ini() {\n  for (int i = 1; i <= n; i++) fa[i] = i;\n}\nvoid lk(int a, int b) { fa[gfa(a)] = gfa(b); }\nvector<pair<int, int> > eg[maxn];\nint dis[maxn];\nint S, T;\nint pre[maxn];\nconst int N = 55;\nint fl[maxn];\nint d[N], cd[N];\nint w[N][N];\nvector<pair<int, int> > preg;\nint nans = 0;\nconst int inf = 50000;\nvoid ade(int u, int v, int w) { eg[u].push_back(make_pair(v, w)); }\nint q[maxn * maxn], fr, ed;\nint inq[maxn];\nbool bfs() {\n  S = cnt + 1, T = cnt + 2;\n  for (int i = 1; i <= T; i++) eg[i].clear();\n  vector<int> fls;\n  for (int i = 1; i <= cnt; i++) {\n    if (fl[i]) fls.push_back(i);\n  }\n  for (int i = 0; i <= cnt; i++) {\n    if (i != 0 && !fl[i]) continue;\n    ini();\n    for (auto v : preg) lk(v.first, v.second);\n    for (auto j : fls) {\n      if (j == i) continue;\n      lk(p[j].u, p[j].v);\n    }\n    int nid = i;\n    if (i == 0) nid = S;\n    for (int i = 1; i <= cnt; i++) {\n      if (fl[i]) continue;\n      if (gfa(p[i].u) != gfa(p[i].v)) ade(nid, i, inf - p[i].w);\n    }\n  }\n  for (int i = 0; i <= cnt; i++) {\n    if (i != 0 && !fl[i]) continue;\n    memset(cd, 0, sizeof(cd));\n    for (auto v : preg) cd[v.first] += 1, cd[v.second] += 1;\n    for (auto j : fls) {\n      if (j == i) continue;\n      cd[p[j].u] += 1, cd[p[j].v] += 1;\n    }\n    int nid = i;\n    if (i == 0) nid = T;\n    int nw = inf - p[nid].w;\n    if (nid == T) nw = 0;\n    for (int i = 1; i <= cnt; i++) {\n      if (fl[i]) continue;\n      if (cd[p[i].u] < d[p[i].u] && cd[p[i].v] < d[p[i].v]) ade(i, nid, -nw);\n    }\n  }\n  for (int i = 1; i <= T; i++) dis[i] = -inf, inq[i] = 0;\n  int fr = 0, ed = 0;\n  dis[S] = 0;\n  q[ed++] = S, inq[S] = 1;\n  while (fr < ed) {\n    int cur = q[fr++];\n    inq[cur] = 0;\n    for (auto v : eg[cur]) {\n      int eid = v.first, ew = v.second;\n      if (chkmax(dis[eid], dis[cur] + ew)) {\n        pre[eid] = cur;\n        if (!inq[eid]) q[ed++] = eid, inq[eid] = 1;\n      }\n    }\n  }\n  if (dis[T] <= 0) return 0;\n  vector<int> cc;\n  int ee = pre[T];\n  while (1) {\n    cc.push_back(ee);\n    ee = pre[ee];\n    if (ee == S) break;\n  }\n  nans += dis[T];\n  for (auto v : cc) fl[v] ^= 1;\n  return 1;\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 1; i <= k; i++) cin >> d[i];\n  for (int i = k + 1; i <= n; i++) d[i] = 1e9;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) scanf(\"%d\", &w[i][j]);\n  int ans = 1e9;\n  ini();\n  vector<array<int, 3> > u;\n  for (int i = k + 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) u.push_back({w[i][j], i, j});\n  sort(u.begin(), u.end());\n  for (auto s : u) {\n    if (gfa(s[1]) == gfa(s[2])) continue;\n    lk(s[1], s[2]);\n    p[++cnt] = th(s[1], s[2], s[0]);\n  }\n  for (int i = 1; i <= k; i++)\n    for (int j = k + 1; j <= n; j++) p[++cnt] = th(i, j, w[i][j]);\n  for (int i = 0; i < (1 << (k * (k - 1) / 2)); i++) {\n    ini();\n    preg.clear();\n    memset(cd, 0, sizeof(cd));\n    nans = 0;\n    int ncnt = 0;\n    for (int u = 1; u <= k; u++)\n      for (int v = u + 1; v <= k; v++) {\n        if (i & (1 << ncnt)) preg.push_back(make_pair(u, v));\n        ncnt += 1;\n      }\n    int flag = 1;\n    for (auto s : preg) {\n      if (gfa(s.first) == gfa(s.second)) flag = 0;\n      lk(s.first, s.second);\n      nans += inf - w[s.first][s.second];\n      cd[s.first] += 1, cd[s.second] += 1;\n    }\n    for (int i = 1; i <= k; i++)\n      if (cd[i] > d[i]) flag = 0;\n    if (!flag) continue;\n    memset(fl, 0, sizeof(fl));\n    for (int m = 0; m < n - 1 - preg.size(); m++) {\n      flag &= bfs();\n      if (!flag) break;\n    }\n    if (flag) {\n      chkmin(ans, (n - 1) * inf - nans);\n    }\n  }\n  cout << ans << endl;\n  return (0 - 0);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 0x3f3f3f3f3f3f3f3f;\nconst int mo = 998244353;\nconst int inv2 = 499122177;\nconst double jzm = 0.9996;\nconst int zero = 5000;\nconst int orG = 3, invG = 332748118;\nconst double Pi = acos(-1.0);\nconst double eps = 1e-3;\ntemplate <typename _T>\n_T Fabs(_T x) {\n  return x < 0 ? -x : x;\n}\ntemplate <typename _T>\nvoid read(_T &x) {\n  _T f = 1;\n  x = 0;\n  char s = getchar();\n  while (s > '9' || s < '0') {\n    if (s == '-') f = -1;\n    s = getchar();\n  }\n  while ('0' <= s && s <= '9') {\n    x = (x << 3) + (x << 1) + (s ^ 48);\n    s = getchar();\n  }\n  x *= f;\n}\ntemplate <typename _T>\nvoid print(_T x) {\n  if (x < 0) {\n    x = (~x) + 1;\n    putchar('-');\n  }\n  if (x > 9) print(x / 10);\n  putchar(x % 10 + '0');\n}\nlong long gcd(long long a, long long b) { return !b ? a : gcd(b, a % b); }\nint add(int x, int y, int p) { return x + y < p ? x + y : x + y - p; }\nvoid Add(int &x, int y, int p) { x = add(x, y, p); }\nint qkpow(int a, int s, int p) {\n  int t = 1;\n  while (s) {\n    if (s & 1LL) t = 1ll * a * t % p;\n    a = 1ll * a * a % p;\n    s >>= 1LL;\n  }\n  return t;\n}\nint n, k, d[55], mp[55][55], t[55], fa[55], tota, totb, deg[55], summ, ans,\n    ord[55][55], sta[55], stak;\nbool cho[55][55], tmp[55][55], ap[55][55], fg[55];\nstruct edge {\n  int u, v, w;\n} a[2505], b[2505];\nbool cmp(edge x, edge y) { return x.w < y.w; }\nbool cmp1(int x, int y) { return t[x] < t[y]; }\ndouble Rand() {\n  return 1.0 * (rand() * RAND_MAX + rand()) / (RAND_MAX * RAND_MAX);\n}\nvoid makeSet(int x) {\n  for (int i = 1; i <= x; i++) fa[i] = i;\n}\nint findSet(int x) { return fa[x] == x ? x : fa[x] = findSet(fa[x]); }\nvoid unionSet(int a, int b) {\n  int u = findSet(a), v = findSet(b);\n  if (u != v) fa[u] = v;\n}\nvoid work(int x) {\n  for (int i = 1; i <= n; i++) {\n    if (ord[x][i] <= k && !fg[findSet(ord[x][i])]) continue;\n    if (ord[x][i] <= k && deg[ord[x][i]] == d[ord[x][i]]) continue;\n    unionSet(ord[x][i], x);\n    tmp[min(ord[x][i], x)][max(ord[x][i], x)] = 1;\n    deg[ord[x][i]]++;\n    deg[x]++;\n    break;\n  }\n}\nvoid sakura(double tp) {\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= n; j++) tmp[i][j] = 0;\n  for (int i = 1; i <= n; i++) deg[i] = fg[i] = 0;\n  summ = 0;\n  makeSet(n);\n  int tim = 0;\n  for (int i = 1; i <= tota; i++) {\n    int u = a[i].u, v = a[i].v, w = a[i].w;\n    if (!cho[u][v]) continue;\n    if (Rand() < tp) {\n      tmp[u][v] = 0;\n      continue;\n    }\n    tmp[u][v] = 1;\n    deg[u]++;\n    deg[v]++;\n    unionSet(u, v);\n    tim++;\n  }\n  random_shuffle(a + 1, a + tota + 1);\n  for (int i = 1; i <= tota; i++) {\n    int u = a[i].u, v = a[i].v, w = a[i].w;\n    if (tmp[u][v] || findSet(u) == findSet(v)) continue;\n    if (Rand() > tp || deg[u] == d[u] || deg[v] == d[v]) continue;\n    tmp[u][v] = 1;\n    deg[u]++;\n    deg[v]++;\n    unionSet(u, v);\n    tim++;\n  }\n  for (int i = k + 1; i <= n; i++) fg[findSet(i)] = 1;\n  tim = 0;\n  for (int i = 1; i <= k; i++) {\n    if (fg[findSet(i)]) continue;\n    int p = findSet(i), spc = 0;\n    for (int j = 1; j <= k; j++)\n      if (findSet(j) == p && deg[j] < d[j]) spc = j;\n    if (!spc) {\n      stak = 0;\n      for (int j = 1; j <= k; j++)\n        if (findSet(j) == p) sta[++stak] = j;\n      for (int j = 1; j <= stak; j++) {\n        int u = sta[j];\n        fa[u] = u;\n        deg[u] = 0;\n        for (int l = 1; l <= k; l++) tmp[l][u] = tmp[u][l] = 0;\n      }\n      for (int j = 1; j <= stak; j++) work(sta[j]), fg[findSet(sta[j])] = 1;\n    } else\n      work(spc), fg[findSet(spc)] = 1;\n  }\n  for (int i = 1; i <= totb; i++)\n    if (findSet(b[i].u) != findSet(b[i].v))\n      unionSet(b[i].u, b[i].v), deg[b[i].u]++, deg[b[i].v]++,\n          tmp[b[i].u][b[i].v] = 1;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++)\n      if (tmp[i][j]) summ += mp[i][j], tim++;\n}\nvoid nagisa() {\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) cho[i][j] = ap[i][j];\n  summ = 0;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++)\n      if (cho[i][j]) summ += mp[i][j];\n  for (int t = 1; t <= 500; t++) {\n    int now = summ;\n    sakura(0.5);\n    if (summ < now)\n      for (int i = 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++) cho[i][j] = tmp[i][j];\n    else\n      summ = now;\n  }\n  if (ans > summ) {\n    for (int i = 1; i <= n; i++)\n      for (int j = i + 1; j <= n; j++) ap[i][j] = cho[i][j];\n    ans = summ;\n  }\n  double nowT = 3000.0;\n  while (nowT > eps) {\n    int now = summ;\n    sakura(nowT);\n    double t = Rand();\n    if (ans > summ) {\n      for (int i = 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++) ap[i][j] = cho[i][j] = tmp[i][j];\n      ans = summ;\n    } else if (exp(1.0 * (now - summ) / nowT) > t)\n      for (int i = 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++) cho[i][j] = tmp[i][j];\n    else\n      summ = now;\n    nowT *= jzm;\n  }\n}\nsigned main() {\n  srand(time(NULL));\n  read(n);\n  read(k);\n  for (int i = 1; i <= k; i++) read(d[i]);\n  for (int i = k + 1; i <= n; i++) d[i] = n;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) {\n      read(mp[i][j]), mp[j][i] = mp[i][j];\n      if (i <= k)\n        a[++tota] = (edge){i, j, mp[i][j]};\n      else\n        b[++totb] = (edge){i, j, mp[i][j]};\n    }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) t[j] = mp[i][j];\n    for (int j = 1; j <= n; j++) ord[i][j] = j;\n    sort(ord[i] + 1, ord[i] + n + 1, cmp1);\n  }\n  sort(b + 1, b + totb + 1, cmp);\n  sakura(1.0);\n  ans = summ;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) ap[i][j] = cho[i][j] = tmp[i][j];\n  for (int i = 1; i <= 5; i++) nagisa();\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate <class T>\nvoid read(T &x) {\n  char ch;\n  x = 0;\n  int f = 1;\n  while (isspace(ch = getchar_unlocked()))\n    ;\n  if (ch == '-') ch = getchar_unlocked(), f = -1;\n  do x = x * 10 + (ch - '0');\n  while (isdigit(ch = getchar_unlocked()));\n  x *= f;\n}\ntemplate <class T, class... A>\nvoid read(T &x, A &...args) {\n  read(x);\n  read(args...);\n}\ntemplate <size_t N>\nstruct DSU {\n  int fa[N];\n  void clear() { memset(fa, 0, sizeof(fa)); }\n  int find(int x) { return !fa[x] ? x : fa[x] = find(fa[x]); }\n  bool join(int x, int y) {\n    x = find(x), y = find(y);\n    if (x == y) return false;\n    fa[x] = y;\n    return true;\n  }\n};\nconst int N = 55;\nconst int MAXE = 280;\nconst int INF = 0x3f3f3f3f;\nstruct edge {\n  int u, v, w;\n  edge() = default;\n  edge(int _u, int _v, int _w) : u(_u), v(_v), w(_w) {}\n  bool operator<(const edge &rhs) const { return w < rhs.w; }\n};\nvector<edge> S, E1, E2, E;\nvector<edge> special;\nDSU<N> D;\nint fa[5];\nint find(int x) {\n  while (fa[x]) x = fa[x];\n  return x;\n}\nint res = INF;\nbool I[MAXE], T[MAXE];\npair<int, int> d[MAXE];\nint pre[MAXE];\nint deg[MAXE], lim[MAXE];\nint wt[MAXE];\nbool vis[MAXE];\nint n, k;\nvoid flip(int u) {\n  I[u] ^= 1;\n  if (I[u])\n    ++deg[E[u].u], ++deg[E[u].v];\n  else\n    --deg[E[u].u], --deg[E[u].v];\n}\nvector<pair<int, int>> G;\nint augment() {\n  memset(pre, -1, sizeof(pre));\n  int ec = E.size();\n  for (int i = 0; i < ec; ++i) wt[i] = I[i] ? -E[i].w : E[i].w;\n  bool up = true;\n  for (int i = 0; i < ec && up; ++i) {\n    up = false;\n    for (const auto &[x, y] : G) {\n      pair<int, int> tp = {d[x].first + wt[y], d[x].second + 1};\n      if (tp < d[y]) d[y] = tp, pre[y] = x, up = true;\n    }\n  }\n  pair<int, int> val = {INF, INF};\n  int u = -1;\n  for (int i = 0; i < ec; ++i)\n    if (T[i] && d[i] < val) val = d[i], u = i;\n  if (val.first > 1e8) return INF;\n  do flip(u);\n  while ((u = pre[u]) != -1);\n  return val.first;\n}\nint MI(int val) {\n  memset(deg, 0, sizeof(deg));\n  memset(I, 0, sizeof(I));\n  for (const auto &e : special) ++deg[e.u], ++deg[e.v];\n  for (int i = 0; i < k; ++i)\n    if (deg[i] > lim[i]) return INF;\n  int card = special.size();\n  const int ec = E.size();\n  while (true) {\n    D.clear();\n    for (const auto &e : special) D.join(e.u, e.v);\n    for (int i = 0; i < ec; ++i)\n      if (I[i]) D.join(E[i].u, E[i].v);\n    fill(d, d + ec, make_pair(INF, 0));\n    memset(T, 0, sizeof(T));\n    for (int i = 0; i < ec; ++i)\n      if (!I[i] && D.find(E[i].u) != D.find(E[i].v)) d[i] = {E[i].w, 0};\n    for (int i = 0; i < ec; ++i)\n      if (!I[i] && deg[E[i].u] < lim[E[i].u] && deg[E[i].v] < lim[E[i].v])\n        T[i] = true;\n    G.clear();\n    for (int i = 0; i < ec; ++i) {\n      if (!I[i]) continue;\n      D.clear();\n      for (const auto &e : special) D.join(e.u, e.v);\n      --deg[E[i].u];\n      --deg[E[i].v];\n      for (int j = 0; j < ec; ++j)\n        if (j != i && I[j]) D.join(E[j].u, E[j].v);\n      for (int j = 0; j < ec; ++j)\n        if (!I[j] && D.find(E[j].u) != D.find(E[j].v)) G.emplace_back(i, j);\n      for (int j = 0; j < ec; ++j)\n        if (!I[j] && deg[E[j].u] < lim[E[j].u] && deg[E[j].v] < lim[E[j].v])\n          G.emplace_back(j, i);\n      ++deg[E[i].u];\n      ++deg[E[i].v];\n    }\n    int ret = augment();\n    if (ret == INF) break;\n    val += ret;\n    ++card;\n  }\n  if (card < n - 1) return INF;\n  return val;\n}\nvoid DFS(vector<edge>::const_iterator it, int sum = 0) {\n  if (it == end(S)) {\n    res = min(res, MI(sum));\n    return;\n  }\n  int fu = find(it->u), fv = find(it->v);\n  DFS(next(it), sum);\n  if (fu != fv) {\n    fa[fu] = fv;\n    special.push_back(*it);\n    DFS(next(it), sum + it->w);\n    special.pop_back();\n    fa[fu] = 0;\n  }\n}\nint main() {\n  read(n, k);\n  for (int i = 0; i < k; ++i) read(lim[i]);\n  fill(lim + k, lim + n, INF);\n  for (int u = 0; u < n; ++u)\n    for (int v = u + 1; v < n; ++v) {\n      int wt;\n      read(wt);\n      if (u < k && v < k)\n        S.emplace_back(u, v, wt);\n      else if (u < k && v > k)\n        E1.emplace_back(u, v, wt);\n      else\n        E2.emplace_back(u, v, wt);\n    }\n  sort(begin(E2), end(E2));\n  for (const auto &e : E2)\n    if (D.join(e.u, e.v)) E.push_back(e);\n  E.insert(E.end(), begin(E1), end(E1));\n  DFS(begin(S));\n  printf(\"%d\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e9;\nconst int X = 1e6;\nstruct DSU {\n  vector<int> link;\n  DSU(int n) : link(n, -1) {}\n  int Find(int x) {\n    if (link[x] == -1) return x;\n    return link[x] = Find(link[x]);\n  }\n  bool Union(int a, int b) {\n    a = Find(a);\n    b = Find(b);\n    if (a != b) {\n      link[a] = b;\n      return true;\n    }\n    return false;\n  }\n};\nstruct Tree {\n  int n;\n  vector<int> a, b;\n  Tree(int n, vector<int> a, vector<int> b) : n(n), a(a), b(b) {}\n  vector<bool> Admits(vector<bool> sol) {\n    DSU D(n);\n    for (int i = 0; i < (int)sol.size(); ++i) {\n      if (sol[i]) D.Union(a[i], b[i]);\n    }\n    vector<bool> ret(sol.size(), false);\n    for (int i = 0; i < (int)sol.size(); ++i) {\n      if (!sol[i] && D.Find(a[i]) != D.Find(b[i])) ret[i] = true;\n    }\n    return ret;\n  }\n};\nstruct Color {\n  vector<int> v, a, b;\n  Color(vector<int> v, vector<int> a, vector<int> b) : v(v), a(a), b(b) {}\n  vector<bool> Admits(vector<bool> sol) {\n    vector<int> w = v;\n    for (int i = 0; i < (int)sol.size(); ++i) {\n      if (sol[i]) w[a[i]] -= 1, w[b[i]] -= 1;\n    }\n    vector<bool> ret(sol.size(), false);\n    for (int i = 0; i < (int)sol.size(); ++i) {\n      if (sol[i]) continue;\n      ret[i] = (w[a[i]] > 0 && w[b[i]] > 0);\n    }\n    return ret;\n  }\n};\ntemplate <typename M1>\nvector<vector<bool>> Exchange(M1& M, vector<bool> sol) {\n  vector<vector<bool>> ret(sol.size());\n  for (int i = 0; i < (int)sol.size(); ++i) {\n    if (!sol[i]) continue;\n    sol[i] = 0;\n    ret[i] = M.Admits(sol);\n    sol[i] = 1;\n  }\n  return ret;\n}\ntemplate <class M1, class M2>\nint MatroidIntersection(vector<int> w, M1 m1, M2 m2, int req) {\n  int n = w.size();\n  vector<bool> sol(n, false);\n  for (int i = 0; i < n; ++i)\n    if (w[i] == -X) sol[i] = true;\n  vector<int> q;\n  while (true) {\n    auto adm1 = m1.Admits(sol), adm2 = m2.Admits(sol);\n    auto ex1 = Exchange(m1, sol), ex2 = Exchange(m2, sol);\n    q.clear();\n    vector<int> inq(n, false);\n    vector<int> parent(n, -2);\n    vector<pair<int, int>> dist(n, make_pair(INF, INF));\n    for (int i = 0; i < n; ++i) {\n      if (abs(w[i]) == X) continue;\n      if (!sol[i] && adm1[i]) {\n        dist[i] = {w[i], 0};\n        parent[i] = -1;\n        inq[i] = 1;\n        q.push_back(i);\n      }\n    }\n    int ch = 1, iter = 0;\n    for (int i = 0; i < (int)q.size(); ++i) {\n      int node = q[i];\n      inq[node] = 0;\n      for (int vec = 0; vec < n; ++vec) {\n        if (abs(w[vec]) == X) continue;\n        if (sol[node] != sol[vec]) {\n          if (sol[node]) {\n            if (!ex1[node][vec]) continue;\n            auto now = dist[node];\n            now.first += w[vec];\n            now.second += 1;\n            if (now < dist[vec]) {\n              dist[vec] = now, parent[vec] = node;\n              if (!inq[vec]) inq[vec] = 1, q.push_back(vec);\n            }\n          } else {\n            if (!ex2[vec][node]) continue;\n            auto now = dist[node];\n            now.first -= w[vec];\n            now.second += 1;\n            if (now < dist[vec]) {\n              dist[vec] = now, parent[vec] = node;\n              if (!inq[vec]) inq[vec] = 1, q.push_back(vec);\n            }\n          }\n        }\n      }\n    }\n    pair<int, int> best = {INF, INF};\n    int choose = -1;\n    for (int node = 0; node < n; ++node) {\n      if (abs(w[node]) == X) continue;\n      if (!sol[node] && adm2[node] && parent[node] != -2) {\n        auto now = dist[node];\n        if (now < best) {\n          best = now;\n          choose = node;\n        }\n      }\n    }\n    if (choose == -1) break;\n    for (int node = choose; node != -1; node = parent[node]) {\n      sol[node] = !sol[node];\n    }\n  }\n  int ans = 0, cnt = 0;\n  for (int i = 0; i < n; ++i) {\n    if (sol[i]) {\n      ans += w[i];\n      cnt += 1;\n    }\n  }\n  if (cnt != req) return INF;\n  return ans;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  vector<int> v(n, n);\n  for (int i = 0; i < k; ++i) cin >> v[i];\n  vector<int> a, b, w;\n  for (int i = 0; i < n; ++i) {\n    for (int j = i + 1; j < n; ++j) {\n      int x;\n      cin >> x;\n      a.push_back(i);\n      b.push_back(j);\n      w.push_back(x);\n    }\n  }\n  int m = a.size();\n  vector<int> o(m);\n  iota(o.begin(), o.end(), 0);\n  sort(o.begin(), o.end(), [&](int a, int b) { return w[a] < w[b]; });\n  vector<int> na, nb, nw, si;\n  DSU D(n);\n  for (auto i : o) {\n    if (a[i] < k && b[i] < k) si.push_back(na.size());\n    if (a[i] < k || b[i] < k || D.Union(a[i], b[i])) {\n      na.push_back(a[i]);\n      nb.push_back(b[i]);\n      nw.push_back(w[i]);\n    }\n  }\n  a = na;\n  b = nb;\n  w = nw;\n  int sol = INF;\n  for (int msk = 0; msk < (1 << si.size()); ++msk) {\n    DSU D(n);\n    vector<int> now_w = w;\n    vector<int> ww = v;\n    int delta = 0;\n    bool bad = false;\n    for (int i = 0; i < (int)si.size(); ++i) {\n      if (msk & (1 << i)) {\n        if (!D.Union(a[si[i]], b[si[i]])) bad = true;\n        if (--ww[a[si[i]]] < 0 || --ww[b[si[i]]] < 0) bad = true;\n        delta += w[si[i]] + X;\n        now_w[si[i]] = -X;\n      } else\n        now_w[si[i]] = X;\n    }\n    if (bad) continue;\n    Tree T(n, a, b);\n    Color C(v, a, b);\n    auto now = MatroidIntersection(now_w, T, C, n - 1);\n    sol = min(sol, now + delta);\n  }\n  cout << sol << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct dsu {\n  vector<int> id;\n  dsu() {}\n  dsu(int n) { id = vector<int>(n, -1); }\n  int find(int a) {\n    while (id[a] >= 0) {\n      if (id[id[a]] >= 0) id[a] = id[id[a]];\n      a = id[a];\n    }\n    return a;\n  }\n  bool unite(int a, int b) {\n    a = find(a);\n    b = find(b);\n    if (a == b) return false;\n    if (id[a] > id[b]) {\n      swap(a, b);\n    }\n    id[a] += id[b];\n    id[b] = a;\n    return true;\n  }\n};\nstruct GroundSetElement {\n  int x, y;\n  int id;\n  int cost;\n  bool in_independent_set = false;\n  int independent_set_position = -1;\n  int parent = -1;\n  GroundSetElement(int a, int b, int c) {\n    x = a;\n    y = b;\n    cost = c;\n  }\n};\nint n;\nvector<GroundSetElement> ground_set;\nvector<int> independent_set;\nvector<int> d;\nvector<int> limit;\ndsu g1;\nvector<pair<int, int>> other;\nvector<dsu> if_rem;\nbool graphic_matroid_oracle(int inserted) {\n  const auto &e = ground_set[inserted];\n  return g1.find(e.x) != g1.find(e.y);\n}\nbool graphic_matroid_oracle(int inserted, int removed) {\n  const auto &e = ground_set[inserted];\n  return if_rem[removed].find(e.x) != if_rem[removed].find(e.y);\n}\nbool matroid2_oracle(int inserted) {\n  const auto &ei = ground_set[inserted];\n  return d[ei.x] + 1 <= limit[ei.x] && d[ei.y] + 1 <= limit[ei.y];\n}\nbool matroid2_oracle(int inserted, int removed) {\n  const auto &er = ground_set[removed];\n  const auto &ei = ground_set[inserted];\n  int degx = d[ei.x] + 1;\n  int degy = d[ei.y] + 1;\n  if (ei.x == er.x || ei.x == er.y) degx--;\n  if (ei.y == er.x || ei.y == er.y) degy--;\n  return degx <= limit[ei.x] && degy <= limit[ei.y];\n}\nvoid prepare_oracle1() {\n  g1 = dsu(n);\n  for (const auto &[x, y] : other) {\n    g1.unite(x, y);\n  }\n  for (int id : independent_set) {\n    const auto &e = ground_set[id];\n    g1.unite(e.x, e.y);\n  }\n  if_rem.assign(ground_set.size(), dsu());\n  for (int id : independent_set) {\n    if_rem[id] = dsu(n);\n    for (const auto &[x, y] : other) {\n      if_rem[id].unite(x, y);\n    }\n    for (int id2 : independent_set) {\n      if (id == id2) continue;\n      const auto &e2 = ground_set[id2];\n      if_rem[id].unite(e2.x, e2.y);\n    }\n  }\n}\nvoid prepare_oracle2() {\n  d.assign(n, 0);\n  for (int id : independent_set) {\n    const auto &e = ground_set[id];\n    d[e.x]++;\n    d[e.y]++;\n  }\n}\nbool augment() {\n  prepare_oracle1();\n  prepare_oracle2();\n  const int SOURCE = -1;\n  const int NOT_FOUND = -2;\n  for (int i = 0; i < (int)ground_set.size(); i++) {\n    ground_set[i].parent = -1;\n  }\n  int endpoint = NOT_FOUND;\n  const int INF = 1e9 + 5;\n  vector<pair<int, int>> dist(ground_set.size(), make_pair(INF, INF));\n  for (int i = 0; i < (int)ground_set.size(); i++) {\n    if (!ground_set[i].in_independent_set && graphic_matroid_oracle(i)) {\n      ground_set[i].parent = SOURCE;\n      dist[i] = {ground_set[i].cost, 0};\n    }\n  }\n  vector<vector<int>> adj(ground_set.size());\n  for (int i : independent_set) {\n    for (int j = 0; j < (int)ground_set.size(); j++) {\n      if (ground_set[j].in_independent_set) continue;\n      if (graphic_matroid_oracle(j, i)) {\n        adj[i].push_back(j);\n      }\n      if (matroid2_oracle(j, i)) {\n        adj[j].push_back(i);\n      }\n    }\n  }\n  bool go = true;\n  for (int rep = 0; go; rep++) {\n    go = false;\n    vector<pair<int, int>> ndist = dist;\n    for (int i = 0; i < (int)ground_set.size(); i++) {\n      for (int j : adj[i]) {\n        assert(ground_set[i].in_independent_set !=\n               ground_set[j].in_independent_set);\n        int c;\n        if (ground_set[j].in_independent_set) {\n          c = -ground_set[j].cost;\n        } else {\n          c = ground_set[j].cost;\n        }\n        if (dist[i].first != INF) {\n          pair<int, int> ncost = {dist[i].first + c, dist[i].second + 1};\n          if (ncost < ndist[j]) {\n            go = true;\n            ndist[j] = ncost;\n            ground_set[j].parent = i;\n          }\n        }\n      }\n    }\n    dist.swap(ndist);\n    if (rep == (int)ground_set.size() - 1) assert(!go);\n  }\n  pair<int, int> best = {INF, INF};\n  for (int i = 0; i < (int)ground_set.size(); i++) {\n    if (!ground_set[i].in_independent_set && dist[i] < best &&\n        matroid2_oracle(i)) {\n      endpoint = i;\n      best = dist[i];\n    }\n  }\n  if (endpoint == NOT_FOUND) return false;\n  do {\n    ground_set[endpoint].in_independent_set ^= true;\n    endpoint = ground_set[endpoint].parent;\n  } while (endpoint != SOURCE);\n  independent_set.clear();\n  for (int i = 0; i < (int)ground_set.size(); i++) {\n    if (ground_set[i].in_independent_set) {\n      ground_set[i].independent_set_position = independent_set.size();\n      independent_set.push_back(i);\n    }\n  }\n  return true;\n}\nvoid foo() {\n  int k;\n  cin >> n >> k;\n  vector<int> L(k);\n  for (int i = 0; i < k; i++) {\n    cin >> L[i];\n  }\n  vector<vector<int>> c(n, vector<int>(n));\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      cin >> c[i][j];\n    }\n  }\n  vector<pair<int, int>> mst, all;\n  for (int i = k; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      all.emplace_back(i, j);\n    }\n  }\n  sort(all.begin(), all.end(),\n       [&](const pair<int, int> &e1, const pair<int, int> &e2) {\n         return c[e1.first][e1.second] < c[e2.first][e2.second];\n       });\n  dsu g(n);\n  for (const auto &e : all) {\n    if (g.unite(e.first, e.second)) {\n      mst.push_back(e);\n    }\n  }\n  const int INF = 1e9 + 5;\n  int ans = INF;\n  limit = vector<int>(n, INF);\n  function<void(int, vector<pair<int, int>> &)> rec =\n      [&](int v, const vector<pair<int, int>> &edges) {\n        if (v == k) {\n          vector<int> al(k);\n          for (const auto &[x, y] : edges) {\n            al[x]++;\n            al[y]++;\n          }\n          for (int i = 0; i < k; i++) {\n            if (al[i] > L[i]) return;\n            limit[i] = L[i] - al[i];\n          }\n          other = edges;\n          ground_set.clear();\n          independent_set.clear();\n          for (const auto &[x, y] : mst) {\n            ground_set.emplace_back(x, y, c[x][y]);\n          }\n          for (int i = 0; i < k; i++) {\n            for (int j = k; j < n; j++) {\n              ground_set.emplace_back(i, j, c[i][j]);\n            }\n          }\n          while (augment())\n            ;\n          const int cnt = edges.size() + independent_set.size();\n          if (cnt == n - 1) {\n            int sum = 0;\n            for (const auto &[x, y] : edges) {\n              sum += c[x][y];\n            }\n            for (int id : independent_set) {\n              sum += ground_set[id].cost;\n            }\n            ans = min(ans, sum);\n          }\n          return;\n        }\n        const int cases = 1 << v;\n        for (int m = 0; m < cases; m++) {\n          dsu G(k);\n          for (const auto &[x, y] : edges) {\n            G.unite(x, y);\n          }\n          bool good = true;\n          vector<pair<int, int>> ne = edges;\n          for (int i = 0; i < v; i++) {\n            if (!(m & (1 << i))) continue;\n            if (G.find(i) == G.find(v)) {\n              good = false;\n              break;\n            }\n            ne.emplace_back(i, v);\n            G.unite(i, v);\n          }\n          if (good) {\n            rec(v + 1, ne);\n          }\n        }\n      };\n  vector<pair<int, int>> vv;\n  rec(0, vv);\n  cout << ans << endl;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  foo();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, d[6], a[55][55], ans = 1000000007, res, f[55], cnt;\nvector<pair<int, int> > v[105];\nint get(int x) { return x == f[x] ? x : f[x] = get(f[x]); }\nvoid sol() {\n  vector<int> V;\n  for (int i = 1; i <= n; ++i) V.push_back(f[i]);\n  int R = res, C = cnt;\n  vector<int> q;\n  for (int i = 1; i <= 100; ++i) {\n    for (int j = 0; j < v[i].size(); ++j) {\n      int x = v[i][j].first, y = v[i][j].second;\n      if (x <= k || y <= k || get(x) == get(y)) continue;\n      f[f[y]] = f[x];\n      res += a[x][y];\n    }\n    for (int j = 0; j < v[i].size(); ++j) {\n      int x = v[i][j].first, y = v[i][j].second;\n      if ((x > k && y > k) || get(x) == get(y)) continue;\n      if (x <= k) {\n        if (!d[x]) continue;\n        --d[x];\n        q.push_back(x);\n        ++cnt;\n      }\n      if (y <= k) {\n        if (!d[y]) continue;\n        --d[y];\n        q.push_back(y);\n        ++cnt;\n      }\n      f[f[y]] = f[x];\n      res += a[x][y];\n    }\n  }\n  for (int i = 0; i < q.size(); ++i) ++d[q[i]];\n  q.clear();\n  if (cnt == n - 1) ans = min(ans, res);\n  for (int _ = 0; _ < 100; ++_) {\n    for (int i = 1; i <= n; ++i) f[i] = V[i - 1];\n    res = R;\n    cnt = C;\n    for (int i = 1; i <= 100; ++i) {\n      random_shuffle(v[i].begin(), v[i].end());\n      for (int j = 0; j < v[i].size(); ++j) {\n        int x = v[i][j].first, y = v[i][j].second;\n        if (x <= k || y <= k || get(x) == get(y)) continue;\n        f[f[y]] = f[x];\n        res += a[x][y];\n        ++cnt;\n      }\n      for (int j = 0; j < v[i].size(); ++j) {\n        int x = v[i][j].first, y = v[i][j].second;\n        if ((x > k && y > k) || get(x) == get(y)) continue;\n        if (rand() < 2000) continue;\n        if (x <= k) {\n          if (!d[x]) continue;\n          --d[x];\n          q.push_back(x);\n        }\n        if (y <= k) {\n          if (!d[y]) continue;\n          --d[y];\n          q.push_back(y);\n        }\n        f[f[y]] = f[x];\n        res += a[x][y];\n        ++cnt;\n      }\n    }\n    if (cnt == n - 1) ans = min(ans, res);\n    for (int i = 0; i < q.size(); ++i) ++d[q[i]];\n    q.clear();\n  }\n  for (int _ = 0; _ < 100; ++_) {\n    for (int i = 1; i <= n; ++i) f[i] = V[i - 1];\n    res = R;\n    cnt = C;\n    for (int i = 1; i <= 100; ++i) {\n      random_shuffle(v[i].begin(), v[i].end());\n      for (int j = 0; j < v[i].size(); ++j) {\n        int x = v[i][j].first, y = v[i][j].second;\n        if (x <= k || y <= k || get(x) == get(y)) continue;\n        f[f[y]] = f[x];\n        res += a[x][y];\n        ++cnt;\n      }\n      for (int j = 0; j < v[i].size(); ++j) {\n        int x = v[i][j].first, y = v[i][j].second;\n        if ((x > k && y > k) || get(x) == get(y)) continue;\n        if (rand() < 6000) continue;\n        if (x <= k) {\n          if (!d[x]) continue;\n          --d[x];\n          q.push_back(x);\n        }\n        if (y <= k) {\n          if (!d[y]) continue;\n          --d[y];\n          q.push_back(y);\n        }\n        f[f[y]] = f[x];\n        res += a[x][y];\n        ++cnt;\n      }\n    }\n    if (cnt == n - 1) ans = min(ans, res);\n    for (int i = 0; i < q.size(); ++i) ++d[q[i]];\n    q.clear();\n  }\n  for (int _ = 0; _ < 100; ++_) {\n    for (int i = 1; i <= n; ++i) f[i] = V[i - 1];\n    res = R;\n    cnt = C;\n    for (int i = 1; i <= 100; ++i) {\n      random_shuffle(v[i].begin(), v[i].end());\n      for (int j = 0; j < v[i].size(); ++j) {\n        int x = v[i][j].first, y = v[i][j].second;\n        if (x <= k || y <= k || get(x) == get(y)) continue;\n        f[f[y]] = f[x];\n        res += a[x][y];\n        ++cnt;\n      }\n      for (int j = 0; j < v[i].size(); ++j) {\n        int x = v[i][j].first, y = v[i][j].second;\n        if ((x > k && y > k) || get(x) == get(y)) continue;\n        if (rand() < 16000) continue;\n        if (x <= k) {\n          if (!d[x]) continue;\n          --d[x];\n          q.push_back(x);\n        }\n        if (y <= k) {\n          if (!d[y]) continue;\n          --d[y];\n          q.push_back(y);\n        }\n        f[f[y]] = f[x];\n        res += a[x][y];\n        ++cnt;\n      }\n    }\n    if (cnt == n - 1) ans = min(ans, res);\n    for (int i = 0; i < q.size(); ++i) ++d[q[i]];\n    q.clear();\n  }\n  for (int i = 1; i <= n; ++i) f[i] = V[i - 1];\n  res = R;\n  cnt = C;\n}\nvoid dfs(int x, int y) {\n  if (x > k) {\n    sol();\n    return;\n  }\n  if (y > k) {\n    dfs(x + 1, x + 2);\n    return;\n  }\n  if (d[x] && d[y] && get(x) != get(y)) {\n    vector<int> V;\n    for (int i = 1; i <= n; ++i) V.push_back(f[i]);\n    f[f[y]] = f[x];\n    --d[x], --d[y];\n    res += a[x][y];\n    ++cnt;\n    dfs(x, y + 1);\n    --cnt;\n    res -= a[x][y];\n    ++d[x], ++d[y];\n    for (int i = 1; i <= n; ++i) f[i] = V[i - 1];\n  }\n  dfs(x, y + 1);\n}\nint main() {\n  srand(time(0));\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i <= k; ++i) scanf(\"%d\", d + i);\n  for (int i = 1; i <= n; ++i) f[i] = i;\n  for (int i = 1; i <= n; ++i) {\n    for (int j = i + 1; j <= n; ++j) {\n      scanf(\"%d\", a[i] + j);\n      a[j][i] = a[i][j];\n      if (i > k || j > k) v[a[i][j]].push_back(make_pair(i, j));\n    }\n  }\n  dfs(1, 2);\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  char ch = getchar();\n  int nega = 1;\n  while (!isdigit(ch)) {\n    if (ch == '-') nega = -1;\n    ch = getchar();\n  }\n  int ans = 0;\n  while (isdigit(ch)) {\n    ans = ans * 10 + ch - 48;\n    ch = getchar();\n  }\n  if (nega == -1) return -ans;\n  return ans;\n}\nvoid print(vector<int> x) {\n  for (int i = 0; i < (int)x.size(); i++)\n    printf(\"%d%c\", x[i], \" \\n\"[i == (int)x.size() - 1]);\n}\nint d[55], used[55], e[55][55], w[55][55], n, k;\nint vis[55][55];\nint getid(int x, int y) { return (x - 1) * n + y; }\nvector<pair<int, int> > G[55 * 55];\nint dis[55 * 55], eg[55 * 55], fr[55 * 55], inq[55 * 55], q[55 * 55 * 55],\n    ok[55][55], ql, qr;\nint fa[55];\nint find(int u) { return fa[u] == u ? u : fa[u] = find(fa[u]); }\nint append() {\n  for (int i = 1; i <= n * n + 2; i++) G[i].clear(), dis[i] = 0x3f3f3f3f;\n  int s = n * n + 1, t = n * n + 2;\n  dis[s] = 0;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) {\n      if (!vis[i][j]) continue;\n      if (ok[i][j]) continue;\n      vis[i][j] = 0;\n      for (int c = 1; c <= n; c++) fa[c] = c;\n      for (int k = 1; k <= n; k++)\n        for (int c = k + 1; c <= n; c++)\n          if (vis[k][c]) fa[find(k)] = find(c);\n      vis[i][j] = 1;\n      for (int k = 1; k <= n; k++)\n        for (int c = k + 1; c <= n; c++)\n          if (!vis[k][c] && !ok[k][c]) {\n            if (find(k) != find(c))\n              G[getid(i, j)].emplace_back(getid(k, c), w[k][c]);\n          }\n    }\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) {\n      if (!vis[i][j]) continue;\n      if (ok[i][j]) continue;\n      used[i]--, used[j]--;\n      for (int k = 1; k <= n; k++)\n        for (int c = k + 1; c <= n; c++)\n          if (!vis[k][c] && !ok[k][c]) {\n            if (used[k] < d[k] && used[c] < d[c])\n              G[getid(k, c)].emplace_back(getid(i, j), -w[i][j]);\n          }\n      used[i]++, used[j]++;\n    }\n  for (int i = 1; i <= n; i++) fa[i] = i;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++)\n      if (vis[i][j]) fa[find(i)] = find(j);\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++)\n      if (!vis[i][j] && !ok[i][j]) {\n        if (find(i) != find(j)) G[s].emplace_back(getid(i, j), w[i][j]);\n      }\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++)\n      if (!vis[i][j] && !ok[i][j]) {\n        if (used[i] < d[i] && used[j] < d[j]) G[getid(i, j)].emplace_back(t, 0);\n      }\n  ql = qr = 1, q[1] = s, eg[s] = 0;\n  while (ql <= qr) {\n    int u = q[ql++];\n    inq[u] = 0;\n    for (auto [v, w] : G[u]) {\n      if (dis[v] > dis[u] + w || (dis[v] == dis[u] + w && eg[v] > eg[u] + 1)) {\n        dis[v] = dis[u] + w, eg[v] = eg[u] + 1;\n        fr[v] = u;\n        if (!inq[v]) inq[v] = 1, q[++qr] = v;\n      }\n    }\n  }\n  int tmp = t;\n  while (tmp != s) {\n    tmp = fr[tmp];\n    if (tmp == s) break;\n    int i = (tmp - 1) / n + 1, j = tmp - (i - 1) * n;\n    if (vis[i][j])\n      used[i]--, used[j]--;\n    else\n      used[i]++, used[j]++;\n    vis[i][j] ^= 1;\n  }\n  return dis[t];\n}\nint tu[55], tv[55];\nsigned main() {\n  cin >> n >> k;\n  for (int i = 1; i <= k; i++) d[i] = read();\n  for (int i = k + 1; i <= n; i++) d[i] = n;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) e[i][j] = w[i][j] = read();\n  int ans = 0x3f3f3f3f, cnt = 0;\n  for (int i = 1; i <= k; i++)\n    for (int j = i + 1; j <= k; j++)\n      tu[cnt] = i, tv[cnt++] = j, w[i][j] = 10000, ok[i][j] = 1;\n  for (int i = 0; i < 1 << (k * (k - 1) / 2); i++) {\n    for (int j = 1; j <= k; j++) fa[j] = j;\n    int ok = 1;\n    int res = 0;\n    for (int j = 0; j < k * (k - 1) / 2; j++) {\n      if (i >> j & 1) {\n        int u = tu[j], v = tv[j];\n        if (find(u) == find(v)) ok = 0;\n        fa[find(u)] = find(v);\n        res += e[u][v];\n      }\n    }\n    if (!ok) continue;\n    memset(vis, 0, sizeof(vis)), memset(used, 0, sizeof(used));\n    int pop = 0;\n    for (int j = 0; j < k * (k - 1) / 2; j++) {\n      if (i >> j & 1) {\n        int u = tu[j], v = tv[j];\n        vis[u][v] = 1, used[u]++, used[v]++;\n        pop++;\n      }\n    }\n    for (int j = 1; j <= k; j++)\n      if (used[j] > d[j]) ok = 0;\n    if (!ok) continue;\n    for (int i = pop + 1; i < n; i++) {\n      res += append();\n    }\n    ans = min(ans, res);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nconstexpr int maxn = 50;\nint w[maxn][maxn];\nint p[maxn];\nint gp(int u) { return p[u] == u ? u : p[u] = gp(p[u]); }\nvector<pair<int, int>> pr[100 + 1];\nint n, k, d[maxn], e[maxn];\npair<int, vector<pair<int, int>>> get(vector<pair<int, int>>& cur, int u,\n                                      int v) {\n  for (int i = 0; i < n; i += 1) p[i] = i;\n  vector<pair<int, int>> ncur;\n  LL nans = 0;\n  for (int i = 0; i < k; i += 1) e[i] = 0;\n  for (auto [x, y] : cur) {\n    if (w[u][v] < w[x][y]) {\n      int pu = gp(u), pv = gp(v);\n      if (pu != pv) {\n        p[pu] = pv;\n        ncur.push_back({u, v});\n        nans += w[u][v];\n        e[u] += 1;\n        e[v] += 1;\n      }\n    }\n    int px = gp(x), py = gp(y);\n    if (px != py) {\n      p[px] = py;\n      ncur.push_back({x, y});\n      nans += w[x][y];\n      e[x] += 1;\n      e[y] += 1;\n    }\n  }\n  for (int i = 0; i < k; i += 1)\n    if (e[i] > d[i]) return {INT_MAX, {}};\n  return {nans, ncur};\n}\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  cin >> n >> k;\n  for (int i = 0; i < k; i += 1) cin >> d[i];\n  for (int i = 0; i < n; i += 1)\n    for (int j = i + 1; j < n; j += 1) {\n      cin >> w[i][j];\n      w[j][i] = w[i][j];\n      pr[w[i][j]].push_back({i, j});\n    }\n  for (int i = k; i < n; i += 1) p[i] = i;\n  vector<pair<int, int>> p;\n  for (int i = 0; i < n; i += 1)\n    for (int j = i + 1; j < n; j += 1) p.push_back({i, j});\n  int res = INT_MAX;\n  srand(time(0));\n  for (int i = 0; i < 1500; i += 1) {\n    random_shuffle(p.begin(), p.end());\n    int ans = 0;\n    vector<pair<int, int>> cur;\n    int r = rand() % (n - k) + k;\n    for (int i = 0; i < n; i += 1)\n      if (i != r) {\n        cur.push_back({i, r});\n        ans += w[i][r];\n      }\n    sort(cur.begin(), cur.end(),\n         [&](const pair<int, int>& p, const pair<int, int>& q) {\n           return w[p.first][p.second] < w[q.first][q.second];\n         });\n    while (true) {\n      res = min(res, ans);\n      int ok = 1;\n      for (auto [i, j] : p) {\n        auto [nans, ncur] = get(cur, i, j);\n        if (nans < ans) {\n          ans = nans;\n          ncur.swap(cur);\n          ok = 0;\n        }\n      }\n      if (ok) break;\n    }\n    res = min(res, ans);\n  }\n  cout << res;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n[[maybe_unused]] constexpr int INF = (numeric_limits<int>::max()) / 2;\n[[maybe_unused]] constexpr long long INFLL =\n    (numeric_limits<long long>::max()) / 2;\n[[maybe_unused]] constexpr __int128 INF128 = numeric_limits<__int128>::max();\ntemplate <class T>\nistream &operator>>(istream &is, vector<T> &a) {\n  for (auto &i : a) is >> i;\n  return is;\n}\n#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#pragma GCC target( \\\n    \"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"fast-math\")\n#pragma GCC optimize(\"section-anchors\")\n#pragma GCC optimize(\"profile-values,profile-reorder-functions,tracer\")\n#pragma GCC optimize(\"vpt\")\n#pragma GCC optimize(\"rename-registers\")\n#pragma GCC optimize(\"move-loop-invariants\")\n#pragma GCC optimize(\"unswitch-loops\")\n#pragma GCC optimize(\"function-sections\")\n#pragma GCC optimize(\"data-sections\")\n#pragma GCC optimize(\"branch-target-load-optimize\")\n#pragma GCC optimize(\"branch-target-load-optimize2\")\n#pragma GCC optimize(\"btr-bb-exclusive\")\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\nint getrand(int l, int r) { return uniform_int_distribution<int>(l, r)(gen); }\nlong double getrand(long double l, long double r) {\n  return uniform_real_distribution<long double>(l, r)(gen);\n}\nvector<vector<int>> w;\nvector<int> gg;\nlong long check(vector<pair<int, int>> t) {\n  long long ans = 0;\n  for (auto [i, j] : t) ans += w[i][j];\n  return ans;\n}\nstruct dsu {\n  vector<int> p, s;\n  dsu(){};\n  dsu(int n) {\n    p.resize(n);\n    s.resize(n, 1);\n    iota(p.begin(), p.end(), 0);\n  }\n  int get(int v) {\n    if (p[v] == v) return v;\n    return p[v] = get(p[v]);\n  }\n  void unite(int a, int b) {\n    a = get(a);\n    b = get(b);\n    if (a == b) return;\n    if (s[a] < s[b]) swap(a, b);\n    s[a] += s[b];\n    p[b] = a;\n  }\n};\nint n;\nvoid get(vector<pair<int, int>> &t, vector<int> &d) {\n  int i = getrand(0, n - 2);\n  int govno = 1;\n  while (govno++ < 228) {\n    if (govno % 20 == 0) i = getrand(0, n - 2);\n    auto dd = d;\n    dsu tmp(n);\n    for (int j = 0; j < n - 1; ++j) {\n      if (j != i) tmp.unite(t[j].first, t[j].second);\n    }\n    int v = getrand(0, n - 1), u = getrand(0, n - 1);\n    while (tmp.get(u) == tmp.get(v)) u = getrand(0, n - 1);\n    --dd[t[i].first];\n    --dd[t[i].second];\n    ++dd[v];\n    ++dd[u];\n    bool check = true;\n    for (int ggi = 0; ggi < gg.size(); ++ggi) {\n      if (dd[ggi] > gg[ggi]) check = false;\n    }\n    if (check) {\n      t.erase(t.begin() + i);\n      t.push_back({u, v});\n      d = dd;\n      return;\n    }\n  }\n}\nint main() {\n  cin.tie(0)->sync_with_stdio(0);\n  int k;\n  cin >> n >> k;\n  gg.resize(k);\n  cin >> gg;\n  w.resize(n, vector<int>(n, INF));\n  for (int i = 0; i < n; ++i) {\n    for (int j = i + 1; j < n; ++j) {\n      cin >> w[i][j];\n      w[j][i] = w[i][j];\n    }\n  }\n  if (n < 8) {\n    long long ans = INF;\n    int m = n * (n - 1) / 2;\n    vector<pair<int, int>> govno;\n    for (int i = 0; i < n; ++i)\n      for (int j = i + 1; j < n; ++j) govno.push_back({i, j});\n    for (int mask = 0; mask < (1 << m); ++mask) {\n      if (__builtin_popcount(mask) != n - 1) continue;\n      dsu tmp(n);\n      long long cur = 0;\n      vector<int> d(n, 0);\n      for (int i = 0; i < m; ++i)\n        if ((mask >> i) & 1) {\n          tmp.unite(govno[i].first, govno[i].second);\n          ++d[govno[i].first];\n          ++d[govno[i].second];\n          cur += w[govno[i].first][govno[i].second];\n        }\n      bool check = true;\n      for (int i = 0; i < n; ++i)\n        if (tmp.get(0) != tmp.get(i)) check = false;\n      for (int i = 0; i < k; ++i)\n        if (d[i] > gg[i]) check = false;\n      if (check) ans = min(ans, cur);\n    }\n    cout << ans;\n    return 0;\n  }\n  int timera = 0;\n  long long ans = INF;\n  while (timera++ < 200) {\n    long double temp = 1;\n    int timerb = 0;\n    vector<pair<int, int>> t;\n    vector<int> d(n, 0);\n    if (count(gg.begin(), gg.end(), 1) > 2) {\n      dsu tmp(n);\n      vector<int> zhopa(n);\n      iota(zhopa.begin(), zhopa.end(), 0);\n      int root = getrand(k, n - 1);\n      for (int i = 0; i < k; ++i) {\n        if (gg[i] == 1) {\n          tmp.unite(i, root);\n          zhopa.erase(find(zhopa.begin(), zhopa.end(), i));\n          ++d[root];\n          ++d[i];\n          t.push_back({i, root});\n        }\n      }\n      while (t.size() < n - 1) {\n        int u = zhopa[getrand(0, zhopa.size() - 1)],\n            v = zhopa[getrand(0, zhopa.size() - 1)];\n        while (1) {\n          while (tmp.get(u) == tmp.get(v)) v = getrand(0, n - 1);\n          if (u < k && d[u] + 1 > gg[u] || v < k && d[v] + 1 > gg[v]) {\n            u = getrand(0, n - 1);\n            continue;\n          }\n          ++d[u];\n          if (u < k && d[u] == gg[u])\n            zhopa.erase(find(zhopa.begin(), zhopa.end(), u));\n          ++d[v];\n          if (v < k && d[v] == gg[v])\n            zhopa.erase(find(zhopa.begin(), zhopa.end(), v));\n          tmp.unite(u, v);\n          t.push_back({u, v});\n          break;\n        }\n      }\n    } else {\n      int leaf1 = 0, leaf2 = n - 1;\n      if (count(gg.begin(), gg.end(), 1) >= 1)\n        leaf1 = find(gg.begin(), gg.end(), 1) - gg.begin();\n      if (count(gg.begin(), gg.end(), 1) == 2) {\n        for (int i = k - 1; i >= 0; --i)\n          if (gg[i] == 1) {\n            leaf2 = i;\n            break;\n          }\n      }\n      for (int i = 0; i + 1 < n; ++i) t.push_back({i, i + 1});\n      int govno1 = 0, govno2 = n - 1;\n      for (int i = 0; i + 1 < n; ++i) {\n        if (t[i].first == govno1) t[i].first = leaf1;\n        if (t[i].second == govno2) t[i].second = leaf2;\n        if (t[i].first == leaf1) t[i].first = govno1;\n        if (t[i].second == leaf2) t[i].second = govno2;\n      }\n      for (auto [i, j] : t) {\n        ++d[i];\n        ++d[j];\n      }\n    }\n    ans = min(ans, check(t));\n    while (timerb++ < 10000) {\n      temp *= 0.99;\n      auto oldt = t;\n      auto oldd = d;\n      get(t, d);\n      long long res = check(oldt) - check(t);\n      if (exp((long double)res / temp) >\n          getrand((long double)0.0, (long double)1.0)) {\n        ans = min(ans, check(t));\n        continue;\n      }\n      t = oldt;\n      d = oldd;\n    }\n  }\n  cout << ans;\n  cout << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 0x3f3f3f3f3f3f3f3f;\nconst int mo = 998244353;\nconst int inv2 = 499122177;\nconst double jzm = 0.9995;\nconst int zero = 5000;\nconst int orG = 3, invG = 332748118;\nconst double Pi = acos(-1.0);\nconst double eps = 1e-3;\ntemplate <typename _T>\n_T Fabs(_T x) {\n  return x < 0 ? -x : x;\n}\ntemplate <typename _T>\nvoid read(_T &x) {\n  _T f = 1;\n  x = 0;\n  char s = getchar();\n  while (s > '9' || s < '0') {\n    if (s == '-') f = -1;\n    s = getchar();\n  }\n  while ('0' <= s && s <= '9') {\n    x = (x << 3) + (x << 1) + (s ^ 48);\n    s = getchar();\n  }\n  x *= f;\n}\ntemplate <typename _T>\nvoid print(_T x) {\n  if (x < 0) {\n    x = (~x) + 1;\n    putchar('-');\n  }\n  if (x > 9) print(x / 10);\n  putchar(x % 10 + '0');\n}\nlong long gcd(long long a, long long b) { return !b ? a : gcd(b, a % b); }\nint add(int x, int y, int p) { return x + y < p ? x + y : x + y - p; }\nvoid Add(int &x, int y, int p) { x = add(x, y, p); }\nint qkpow(int a, int s, int p) {\n  int t = 1;\n  while (s) {\n    if (s & 1LL) t = 1ll * a * t % p;\n    a = 1ll * a * a % p;\n    s >>= 1LL;\n  }\n  return t;\n}\nint n, k, d[55], mp[55][55], t[55], fa[55], tota, totb, deg[55], summ, ans,\n    ord[55][55], sta[55], stak;\nbool cho[55][55], tmp[55][55], ap[55][55], fg[55];\nstruct edge {\n  int u, v, w;\n} a[2505], b[2505];\nbool cmp(edge x, edge y) { return x.w < y.w; }\nbool cmp1(int x, int y) { return t[x] < t[y]; }\ndouble Rand() {\n  return 1.0 * (rand() * RAND_MAX + rand()) / (RAND_MAX * RAND_MAX);\n}\nvoid makeSet(int x) {\n  for (int i = 1; i <= x; i++) fa[i] = i;\n}\nint findSet(int x) { return fa[x] == x ? x : fa[x] = findSet(fa[x]); }\nvoid unionSet(int a, int b) {\n  int u = findSet(a), v = findSet(b);\n  if (u != v) fa[u] = v;\n}\nvoid work(int x) {\n  for (int i = 1; i <= n; i++) {\n    if (ord[x][i] <= k && !fg[findSet(ord[x][i])]) continue;\n    if (ord[x][i] <= k && deg[ord[x][i]] == d[ord[x][i]]) continue;\n    unionSet(ord[x][i], x);\n    tmp[min(ord[x][i], x)][max(ord[x][i], x)] = 1;\n    deg[ord[x][i]]++;\n    deg[x]++;\n    break;\n  }\n}\nvoid sakura(double tp) {\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= n; j++) tmp[i][j] = 0;\n  for (int i = 1; i <= n; i++) deg[i] = fg[i] = 0;\n  summ = 0;\n  makeSet(n);\n  int tim = 0;\n  for (int i = 1; i <= tota; i++) {\n    int u = a[i].u, v = a[i].v, w = a[i].w;\n    if (!cho[u][v]) continue;\n    if (Rand() < tp) {\n      tmp[u][v] = 0;\n      continue;\n    }\n    tmp[u][v] = 1;\n    deg[u]++;\n    deg[v]++;\n    unionSet(u, v);\n    tim++;\n  }\n  random_shuffle(a + 1, a + tota + 1);\n  for (int i = 1; i <= tota; i++) {\n    int u = a[i].u, v = a[i].v, w = a[i].w;\n    if (tmp[u][v] || findSet(u) == findSet(v)) continue;\n    if (Rand() > tp || deg[u] == d[u] || deg[v] == d[v]) continue;\n    tmp[u][v] = 1;\n    deg[u]++;\n    deg[v]++;\n    unionSet(u, v);\n    tim++;\n  }\n  for (int i = k + 1; i <= n; i++) fg[findSet(i)] = 1;\n  tim = 0;\n  for (int i = 1; i <= k; i++) {\n    if (fg[findSet(i)]) continue;\n    int p = findSet(i), spc = 0;\n    for (int j = 1; j <= k; j++)\n      if (findSet(j) == p && deg[j] < d[j]) spc = j;\n    if (!spc) {\n      stak = 0;\n      for (int j = 1; j <= k; j++)\n        if (findSet(j) == p) sta[++stak] = j;\n      for (int j = 1; j <= stak; j++) {\n        int u = sta[j];\n        fa[u] = u;\n        deg[u] = 0;\n        for (int l = 1; l <= k; l++) tmp[l][u] = tmp[u][l] = 0;\n      }\n      for (int j = 1; j <= stak; j++) work(sta[j]), fg[findSet(sta[j])] = 1;\n    } else\n      work(spc), fg[findSet(spc)] = 1;\n  }\n  for (int i = 1; i <= totb; i++)\n    if (findSet(b[i].u) != findSet(b[i].v))\n      unionSet(b[i].u, b[i].v), deg[b[i].u]++, deg[b[i].v]++,\n          tmp[b[i].u][b[i].v] = 1;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++)\n      if (tmp[i][j]) summ += mp[i][j], tim++;\n}\nvoid nagisa() {\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) cho[i][j] = ap[i][j];\n  summ = 0;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++)\n      if (cho[i][j]) summ += mp[i][j];\n  for (int t = 1; t <= 500; t++) {\n    int now = summ;\n    sakura(0.5);\n    if (summ < now)\n      for (int i = 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++) cho[i][j] = tmp[i][j];\n    else\n      summ = now;\n  }\n  if (ans > summ) {\n    for (int i = 1; i <= n; i++)\n      for (int j = i + 1; j <= n; j++) ap[i][j] = cho[i][j];\n    ans = summ;\n  }\n  double nowT = 5000.0;\n  while (nowT > eps) {\n    int now = summ;\n    sakura(nowT);\n    double t = Rand();\n    if (ans > summ) {\n      for (int i = 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++) ap[i][j] = cho[i][j] = tmp[i][j];\n      ans = summ;\n    } else if (exp(1.0 * (now - summ) / nowT) > t)\n      for (int i = 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++) cho[i][j] = tmp[i][j];\n    else\n      summ = now;\n    nowT *= jzm;\n  }\n}\nsigned main() {\n  srand(time(NULL));\n  read(n);\n  read(k);\n  for (int i = 1; i <= k; i++) read(d[i]);\n  for (int i = k + 1; i <= n; i++) d[i] = n;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) {\n      read(mp[i][j]), mp[j][i] = mp[i][j];\n      if (i <= k)\n        a[++tota] = (edge){i, j, mp[i][j]};\n      else\n        b[++totb] = (edge){i, j, mp[i][j]};\n    }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) t[j] = mp[i][j];\n    for (int j = 1; j <= n; j++) ord[i][j] = j;\n    sort(ord[i] + 1, ord[i] + n + 1, cmp1);\n  }\n  sort(b + 1, b + totb + 1, cmp);\n  sakura(1.0);\n  ans = summ;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) ap[i][j] = cho[i][j] = tmp[i][j];\n  for (int i = 1; i <= 5; i++) nagisa();\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Inf = 0x3f3f3f3f;\nmt19937_64 Rand(chrono::steady_clock::now().time_since_epoch().count());\nlong long inline rand(long long L, long long R) {\n  return uniform_int_distribution<long long>(L, R)(Rand);\n}\ndouble inline frand() { return uniform_real_distribution<double>(0, 1)(Rand); }\nstruct UnionFind {\n  int fa[55];\n  void inline init() { memset(fa, -1, sizeof(fa)); }\n  UnionFind() { init(); }\n  int inline root(int x) { return fa[x] < 0 ? x : fa[x] = root(fa[x]); }\n  bool inline conn(int a, int b) {\n    a = root(a);\n    b = root(b);\n    if (a == b) return 0;\n    if (fa[a] < fa[b]) swap(a, b);\n    return fa[b] += fa[a], fa[a] = b, 1;\n  }\n} uf;\nint N, K;\nint d[55];\nint w[55][55], deg[55], dg[55];\nbool sel[55][55];\nvector<tuple<int, int, int> > egs;\nvector<pair<int, int> > negs;\nint calc() {\n  uf.init();\n  int res = 0, es = 0;\n  egs.clear();\n  memset(deg, 0, sizeof(deg));\n  for (int i = 1; i <= (N); ++i)\n    for (int j = i + 1; j <= N; ++j) {\n      if (sel[i][j]) {\n        if (!uf.conn(i, j)) return Inf;\n        res += w[i][j];\n        ++deg[i];\n        ++deg[j];\n        ++es;\n      } else\n        egs.emplace_back(w[i][j], i, j);\n    }\n  sort(egs.begin(), egs.end());\n  for (auto &e : egs) {\n    int w, u, v;\n    tie(w, u, v) = e;\n    if (deg[u] == d[u] || deg[v] == d[v]) continue;\n    if (!uf.conn(u, v)) continue;\n    ++deg[u];\n    ++deg[v];\n    ++es;\n    res += w;\n  }\n  if (es != N - 1) return Inf;\n  return res;\n}\nint main() {\n  scanf(\"%d%d\", &N, &K);\n  memset(d, -1, sizeof(d));\n  for (int i = 1; i <= (K); ++i) scanf(\"%d\", d + i);\n  for (int i = 1; i <= (N); ++i)\n    for (int j = i + 1; j <= N; ++j) scanf(\"%d\", w[i] + j);\n  for (int i = 1; i <= (K); ++i)\n    for (int j = i + 1; j <= N; ++j) negs.emplace_back(i, j);\n  int cur = calc(), bes = cur;\n  for (double tmp = 1145.14; tmp >= 1919.8e-10; tmp *= .996007) {\n    int u, v;\n    while (1) {\n      int id = rand(0, ((int)(negs).size()) - 1);\n      tie(u, v) = negs[id];\n      if (u == v) continue;\n      if (u > v) swap(u, v);\n      if (!sel[u][v] && (dg[u] == d[u] || dg[v] == d[v])) continue;\n      break;\n    }\n    dg[u] -= sel[u][v];\n    dg[v] -= sel[u][v];\n    sel[u][v] ^= 1;\n    dg[u] += sel[u][v];\n    dg[v] += sel[u][v];\n    int ncur = calc();\n    if (exp((cur - ncur) / tmp) > frand()) {\n      cur = ncur;\n      bes = min(bes, cur);\n    } else {\n      dg[u] -= sel[u][v];\n      dg[v] -= sel[u][v];\n      sel[u][v] ^= 1;\n      dg[u] += sel[u][v];\n      dg[v] += sel[u][v];\n    }\n  }\n  printf(\"%d\\n\", bes);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint weight[2510];\nint u[2510], v[2510];\nint W[6][6];\nint d[6], k;\nint stp = 0;\nvector<pair<int, int>> must;\nstruct DSU {\n  int p[51], sz[51];\n  DSU(int n = 0) {\n    for (int i = 1; i <= n; i++) sz[p[i] = i] = 1;\n  }\n  int F(int x) { return x == p[x] ? x : p[x] = F(p[x]); }\n  bool U(int x, int y) {\n    x = F(x), y = F(y);\n    if (x == y) return false;\n    if (sz[x] > sz[y]) swap(x, y);\n    p[x] = y;\n    return true;\n  }\n  bool I(int x, int y) {\n    x = F(x), y = F(y);\n    if (x == y) return false;\n    return true;\n  }\n};\nstruct PM {\n  int cd[6];\n  int bin[3000];\n  void init() {\n    for (int i = 0; i < stp; i++) {\n      if (u[i] <= k) bin[i] = u[i];\n      if (v[i] <= k) bin[i] = v[i];\n    }\n  }\n  void prepare(vector<int> cur_indep) {\n    for (int i = 1; i <= k; i++) cd[i] = d[i];\n    for (auto [x, y] : must) cd[x]--, cd[y]--;\n    for (int x : cur_indep) cd[bin[x]]--;\n  }\n  bool indep(int in) { return bin[in] == 0 || cd[bin[in]] > 0; }\n} M1;\nstruct GM {\n  int id[3000];\n  DSU D;\n  void prepare(vector<int> cur_indep, int ban) {\n    for (int i = 0; i < cur_indep.size(); i++) id[cur_indep[i]] = i;\n    D = DSU(50);\n    for (auto [x, y] : must) D.U(x, y);\n    for (int i = 0; i < cur_indep.size(); i++) {\n      if (i == ban) continue;\n      int x = u[cur_indep[i]], y = v[cur_indep[i]];\n      D.U(x, y);\n    }\n  }\n  bool indep(int in) { return D.I(u[in], v[in]); }\n} M2;\nvector<int> sorted;\nstruct MIN_M_I {\n  int n;\n  const int base = 500;\n  const int inf = 1e9;\n  vector<int> cur_indep, in_indep;\n  int comp[3000];\n  MIN_M_I(int n) : n(n), in_indep(n) {}\n  bool augment() {\n    int N = 0;\n    vector<int> rev;\n    for (int i = 0; i < n; i++)\n      if (in_indep[i]) comp[i] = N++, rev.emplace_back(i);\n    comp[n] = N++, rev.emplace_back(n);\n    comp[n + 1] = N++, rev.emplace_back(n + 1);\n    vector<long long> from(n), to(n);\n    {\n      M1.prepare(cur_indep), M2.prepare(cur_indep, -1);\n      for (int i = 0; i < n; i++)\n        if (!in_indep[i]) {\n          if (M1.indep(i)) to[i] |= 1LL << comp[n];\n          if (M2.indep(i)) from[i] |= 1LL << comp[n + 1];\n        }\n    }\n    for (int i = 0; i < n; i++)\n      if (in_indep[i]) {\n        M2.prepare(cur_indep, comp[i]);\n        M1.cd[M1.bin[i]]++;\n        for (int j = 0; j < n; j++)\n          if (!in_indep[j]) {\n            if (M1.indep(j)) to[j] |= 1LL << comp[i];\n            if (M2.indep(j)) from[j] |= 1LL << comp[i];\n          }\n        M1.cd[M1.bin[i]]--;\n      }\n    for (int i = 0; i < n; i++)\n      for (int j = 0; j < n; j++)\n        if (in_indep[i] && !in_indep[j]) {\n        }\n    vector<vector<int>> td(N, vector<int>(N, inf));\n    vector<vector<int>> jmp(N, vector<int>(N, inf));\n    vector<long long> todo(N, (1LL << N) - 1);\n    for (int j : sorted) {\n      for (int i = 0; i < N; i++) {\n        if ((to[j] >> i) & 1) {\n          long long mask = todo[i] & from[j];\n          while (mask != 0) {\n            int bit = __builtin_ctzll(mask);\n            todo[i] ^= 1LL << bit;\n            mask ^= 1LL << bit;\n            td[i][bit] = (weight[j] - weight[rev[bit]]) * base + 2;\n            jmp[i][bit] = j;\n          }\n        }\n      }\n    }\n    vector<int> dist(N, inf), p(N, -1);\n    vector<tuple<int, int, int>> e;\n    dist[comp[n]] = 0;\n    for (int i = 0; i < N; i++)\n      for (int j = 0; j < N; j++)\n        if (i != j && td[i][j] != inf) e.emplace_back(i, j, td[i][j]);\n    for (int t = 0; t <= N; t++) {\n      bool up = false;\n      for (auto& [u, v, w] : e)\n        if (dist[u] != inf && dist[v] > dist[u] + w)\n          p[v] = u, dist[v] = dist[u] + w, up = true;\n      if (!up) break;\n    }\n    if (dist[N - 1] == inf) return false;\n    int x = N - 1;\n    while (x != N - 2) {\n      if (x != N - 1) in_indep[rev[x]] ^= 1;\n      in_indep[jmp[p[x]][x]] ^= 1;\n      x = p[x];\n    }\n    cur_indep.clear();\n    for (int i = 0; i < n; i++)\n      if (in_indep[i]) cur_indep.emplace_back(i);\n    return true;\n  }\n  vector<int> solve() {\n    while (augment())\n      ;\n    return cur_indep;\n  }\n};\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int n;\n  cin >> n >> k;\n  for (int i = 1; i <= k; i++) cin >> d[i];\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) {\n      if (i <= k && j <= k) {\n        cin >> W[i][j];\n      } else {\n        cin >> weight[stp];\n        u[stp] = i, v[stp] = j;\n        stp++;\n      }\n    }\n  sorted = vector<int>(stp);\n  iota(sorted.begin(), sorted.end(), 0);\n  sort(sorted.begin(), sorted.end(),\n       [&](const int& a, const int& b) { return weight[a] < weight[b]; });\n  vector<pair<int, int>> todo;\n  int ans = 1e9;\n  for (int i = 1; i <= k; i++)\n    for (int j = i + 1; j <= k; j++) todo.emplace_back(i, j);\n  int N = todo.size();\n  M1.init();\n  for (int i = 0; i < (1 << N); i++) {\n    DSU D(k);\n    must.clear();\n    vector<int> cd(k + 1);\n    bool ok = true;\n    int cost = 0;\n    for (int j = 0; j < N; j++)\n      if ((i >> j) & 1) {\n        if (!D.U(todo[j].first, todo[j].second)) {\n          ok = false;\n          break;\n        }\n        cd[todo[j].first]++, cd[todo[j].second]++;\n        cost += W[todo[j].first][todo[j].second];\n        must.emplace_back(todo[j]);\n      }\n    for (int j = 1; j <= k; j++)\n      if (cd[j] > d[j]) ok = false;\n    if (ok) {\n      auto MI = MIN_M_I(stp);\n      auto res = MI.solve();\n      if (res.size() + must.size() == n - 1) {\n        for (int x : res) cost += weight[x];\n        ans = min(ans, cost);\n      }\n    }\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 55;\nint w[maxn][maxn], d[maxn];\nstruct edge {\n  int u, v, w;\n  bool operator<(const edge& a) const { return w < a.w; }\n};\nstruct node {\n  int to, w, nex;\n} buf[maxn * 2];\nint h[maxn], buf_tot;\nvoid add_edge(int u, int v, int w) {\n  buf[++buf_tot] = (node){v, w, h[u]};\n  h[u] = buf_tot;\n}\nstruct node2 {\n  int to, nex;\n} buf2[maxn * maxn * 12];\nint h2[maxn * 6], buf2_tot;\nvoid add_edge2(int u, int v) {\n  buf2[++buf2_tot] = (node2){v, h2[u]};\n  h2[u] = buf2_tot;\n}\nint I[maxn * 6];\nint pre[maxn], pre_id[maxn], rt[maxn], dep[maxn], deg[maxn];\nvoid dfs(int u, int p, int r) {\n  rt[u] = r;\n  for (int i = h[u]; i; i = buf[i].nex) {\n    int v = buf[i].to;\n    if (v == p) continue;\n    pre[v] = u;\n    pre_id[v] = buf[i].w;\n    dep[v] = dep[u] + 1;\n    dfs(v, u, r);\n  }\n}\nint pa[maxn];\nint fnd(int u) { return u == pa[u] ? u : (pa[u] = fnd(pa[u])); }\nint X2[maxn * 6], dis_w[maxn * 6], dis_num[maxn * 6], dis_pre[maxn * 6];\nint vis[maxn * 6], cnt[maxn * 6];\nint main(void) {\n  int n, k;\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i <= k; i++) scanf(\"%d\", &d[i]);\n  for (int i = 1; i <= n; i++) {\n    for (int j = i + 1; j <= n; j++) scanf(\"%d\", &w[i][j]);\n  }\n  for (int i = k + 1; i <= n; i++) d[i] = n;\n  for (int i = k + 1; i <= n; i++) pa[i] = i;\n  vector<edge> e;\n  for (int i = k + 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) e.push_back((edge){i, j, w[i][j]});\n  sort(e.begin(), e.end());\n  vector<edge> U;\n  for (int i = 0; i < (int)e.size(); i++) {\n    int u = fnd(e[i].u), v = fnd(e[i].v);\n    if (u == v) continue;\n    U.push_back(e[i]);\n    pa[u] = v;\n  }\n  for (int i = 1; i <= k; i++) {\n    for (int j = k + 1; j <= n; j++) U.push_back((edge){i, j, w[i][j]});\n  }\n  vector<edge> V;\n  for (int i = 1; i <= k; i++) {\n    for (int j = i + 1; j <= k; j++) V.push_back((edge){i, j, w[i][j]});\n  }\n  int ans = (int)1e9;\n  for (int sv = 0, sz = (1 << V.size()); sv < sz; sv++) {\n    for (int i = 1; i <= k; i++) pa[i] = i;\n    for (int i = 1; i <= n; i++) deg[i] = 0;\n    int ok = 1;\n    for (int j = 0; j < (int)V.size(); j++)\n      if ((sv >> j) & 1) {\n        int u = fnd(V[j].u), v = fnd(V[j].v);\n        if (u == v) {\n          ok = 0;\n          break;\n        }\n        pa[u] = v;\n        deg[V[j].u]++, deg[V[j].v]++;\n      }\n    for (int i = 1; i <= k; i++)\n      if (deg[i] > d[i]) ok = 0;\n    if (!ok) continue;\n    for (int i = 0; i < U.size(); i++) I[i] = 0;\n    while (1) {\n      buf_tot = 0;\n      for (int i = 1; i <= n; i++)\n        h[i] = pre[i] = pre_id[i] = dep[i] = rt[i] = 0;\n      for (int j = 0; j < (int)V.size(); j++)\n        if ((sv >> j) & 1) {\n          int u = V[j].u, v = V[j].v;\n          add_edge(u, v, -1);\n          add_edge(v, u, -1);\n        }\n      for (int j = 0; j < (int)U.size(); j++)\n        if (I[j]) {\n          int u = U[j].u, v = U[j].v;\n          add_edge(u, v, j);\n          add_edge(v, u, j);\n        }\n      for (int i = 1; i <= n; i++)\n        if (pre[i] == 0) dfs(i, 0, i);\n      buf2_tot = 0;\n      for (int i = 0; i < (int)U.size(); i++) h2[i] = 0;\n      vector<int> IP;\n      for (int a = 0; a < (int)U.size(); a++)\n        if (I[a]) {\n          IP.push_back(a);\n          for (int b = 0; b < (int)U.size(); b++)\n            if (!I[b]) {\n              deg[U[a].u]--, deg[U[a].v]--;\n              deg[U[b].u]++, deg[U[b].v]++;\n              if (deg[U[b].u] <= d[U[b].u] && deg[U[b].v] <= d[U[b].u]) {\n                add_edge2(a, b);\n              }\n              deg[U[a].u]++, deg[U[a].v]++;\n              deg[U[b].u]--, deg[U[b].v]--;\n            }\n        }\n      for (int b = 0; b < (int)U.size(); b++)\n        if (!I[b]) {\n          int u = U[b].u, v = U[b].v;\n          if (rt[u] != rt[v]) {\n            for (auto a : IP) {\n              add_edge2(b, a);\n            }\n          } else {\n            while (u != v) {\n              if (dep[u] > dep[v]) {\n                if (~pre_id[u]) add_edge2(b, pre_id[u]);\n                u = pre[u];\n              } else {\n                if (~pre_id[v]) add_edge2(b, pre_id[v]);\n                v = pre[v];\n              }\n            }\n          }\n        }\n      for (int e = 0; e < U.size(); e++) {\n        dis_w[e] = (int)1e9;\n        dis_num[e] = 0;\n        dis_pre[e] = -1;\n        vis[e] = 0;\n        cnt[e] = 0;\n      }\n      queue<int> Q;\n      for (int i = 0; i < U.size(); i++) X2[i] = 0;\n      for (int e = 0; e < U.size(); e++)\n        if (!I[e]) {\n          if (deg[U[e].u] + 1 <= d[U[e].u] && deg[U[e].v] + 1 <= d[U[e].v]) {\n            Q.push(e);\n            cnt[e]++;\n            dis_w[e] = U[e].w, dis_num[e] = 0;\n          }\n          if (rt[U[e].u] != rt[U[e].v]) X2[e] = 1;\n        }\n      while (!Q.empty()) {\n        int e = Q.front();\n        Q.pop();\n        vis[e] = false;\n        for (int i = h2[e]; i; i = buf2[i].nex) {\n          int v = buf2[i].to;\n          int w = I[v] ? -U[v].w : U[v].w;\n          if (dis_w[v] > dis_w[e] + w ||\n              (dis_w[v] == dis_w[e] + w && dis_num[v] > dis_num[e] + 1)) {\n            dis_w[v] = dis_w[e] + w;\n            dis_num[v] = dis_num[e] + 1;\n            dis_pre[v] = e;\n            if (!vis[v]) {\n              vis[v] = true;\n              Q.push(v);\n              if (++cnt[v] > U.size()) {\n                assert(0);\n              }\n            }\n          }\n        }\n      }\n      int e = -1, min_dis = (int)1e9, min_num = 0;\n      for (int i = 0; i < U.size(); i++)\n        if (X2[i]) {\n          if (dis_w[i] < min_dis ||\n              (dis_w[i] == min_dis && dis_num[i] < min_num)) {\n            e = i;\n            min_dis = dis_w[i], min_num = dis_num[i];\n          }\n        }\n      if (min_dis == (int)1e9) break;\n      while (~e) {\n        if (I[e])\n          deg[U[e].u]--, deg[U[e].v]--;\n        else\n          deg[U[e].u]++, deg[U[e].v]++;\n        I[e] ^= 1;\n        e = dis_pre[e];\n      }\n    }\n    for (int i = 1; i <= n; i++) pa[i] = i, deg[i] = 0;\n    int cnt = 0, tmp = 0;\n    for (int j = 0; j < V.size(); j++)\n      if ((sv >> j) & 1) {\n        int u = fnd(V[j].u), v = fnd(V[j].v);\n        assert(u != v);\n        pa[u] = v;\n        deg[V[j].u]++, deg[V[j].v]++;\n        tmp += V[j].w;\n        cnt++;\n      }\n    for (int j = 0; j < U.size(); j++)\n      if (I[j]) {\n        int u = fnd(U[j].u), v = fnd(U[j].v);\n        assert(u != v);\n        pa[u] = v;\n        deg[U[j].u]++, deg[U[j].v]++;\n        tmp += U[j].w;\n        cnt++;\n      }\n    if (cnt < n - 1) continue;\n    for (int i = 1; i <= n; i++) assert(fnd(i) == fnd(1));\n    for (int i = 1; i <= n; i++) assert(deg[i] <= d[i]);\n    ans = min(ans, tmp);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nconstexpr int maxn = 50;\nint w[maxn][maxn];\nint p[maxn];\nint gp(int u) { return p[u] == u ? u : p[u] = gp(p[u]); }\nvector<pair<int, int>> pr[100 + 1];\nint n, k, d[maxn], e[maxn];\npair<int, vector<pair<int, int>>> get(vector<pair<int, int>>& cur, int u,\n                                      int v) {\n  for (int i = 0; i < n; i += 1) p[i] = i;\n  vector<pair<int, int>> ncur;\n  LL nans = 0;\n  for (int i = 0; i < k; i += 1) e[i] = 0;\n  for (auto [x, y] : cur) {\n    if (w[u][v] < w[x][y]) {\n      int pu = gp(u), pv = gp(v);\n      if (pu != pv) {\n        p[pu] = pv;\n        ncur.push_back({u, v});\n        nans += w[u][v];\n        e[u] += 1;\n        e[v] += 1;\n      }\n    }\n    int px = gp(x), py = gp(y);\n    if (px != py) {\n      p[px] = py;\n      ncur.push_back({x, y});\n      nans += w[x][y];\n      e[x] += 1;\n      e[y] += 1;\n    }\n  }\n  for (int i = 0; i < k; i += 1)\n    if (e[i] > d[i]) return {INT_MAX, {}};\n  return {nans, ncur};\n}\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  cin >> n >> k;\n  for (int i = 0; i < k; i += 1) cin >> d[i];\n  for (int i = 0; i < n; i += 1)\n    for (int j = i + 1; j < n; j += 1) {\n      cin >> w[i][j];\n      w[j][i] = w[i][j];\n      pr[w[i][j]].push_back({i, j});\n    }\n  for (int i = k; i < n; i += 1) p[i] = i;\n  vector<pair<int, int>> p;\n  for (int i = 0; i < n; i += 1)\n    for (int j = i + 1; j < n; j += 1) p.push_back({i, j});\n  int res = INT_MAX;\n  srand(time(0));\n  for (int i = 0; i < 1000; i += 1) {\n    random_shuffle(p.begin(), p.end());\n    int ans = 0;\n    vector<pair<int, int>> cur;\n    int r = rand() % (n - k) + k;\n    for (int i = 0; i < n; i += 1)\n      if (i != r) {\n        cur.push_back({i, r});\n        ans += w[i][r];\n      }\n    sort(cur.begin(), cur.end(),\n         [&](const pair<int, int>& p, const pair<int, int>& q) {\n           return w[p.first][p.second] < w[q.first][q.second];\n         });\n    while (true) {\n      res = min(res, ans);\n      int ok = 1;\n      for (auto [i, j] : p) {\n        auto [nans, ncur] = get(cur, i, j);\n        if (nans < ans) {\n          ans = nans;\n          ncur.swap(cur);\n          ok = 0;\n        }\n      }\n      if (ok) break;\n    }\n    res = min(res, ans);\n  }\n  cout << res;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint read() {\n  int ret = 0;\n  char c = getchar();\n  while (c > '9' || c < '0') c = getchar();\n  while (c >= '0' && c <= '9')\n    ret = (ret << 3) + (ret << 1) + (c ^ 48), c = getchar();\n  return ret;\n}\nconst int maxn = 55;\nconst int maxk = 6;\nconst int maxm = 2500;\nconst int inf = 1e9;\nint n, k;\nint dlim[maxk];\nstruct edge {\n  int from, to, val;\n} e1[15], e2[maxm];\nint cnt1, cnt2;\nint ans;\nint d[maxk];\nbool ini[maxm], x[maxm], y[maxm];\nint dis[maxm], pre[maxm];\nstruct dsu {\n  int fa[maxn];\n  void prework() {\n    for (int i = 1; i <= n; i++) fa[i] = i;\n  }\n  int get(int x) { return x == fa[x] ? x : fa[x] = get(fa[x]); }\n  void merge(int x, int y) { fa[get(x)] = get(y); }\n  bool check(int x, int y) { return get(x) == get(y); }\n} S;\nqueue<int> q;\nbool inq[maxm];\nint ret = 0;\nbool deb = 0;\nstruct graph {\n  int head[maxm], ver[maxm * maxm], nxt[maxm * maxm], val[maxm * maxm], tot;\n  void add(int x, int y, int z) {\n    ver[++tot] = y;\n    val[tot] = z;\n    nxt[tot] = head[x];\n    head[x] = tot;\n  }\n  void clear() {\n    tot = 0;\n    for (int i = 1; i <= cnt2 + 2; i++) head[i] = 0;\n  }\n  int dis[maxm], pre[maxm], len[maxm];\n  bool inq[maxm];\n  void spfa() {\n    for (int i = 1; i <= cnt2 + 2; i++)\n      dis[i] = 0x3f3f3f3f, inq[i] = 0, pre[i] = 0;\n    dis[cnt2 + 1] = 0;\n    q.push(cnt2 + 1);\n    inq[cnt2 + 1] = 1;\n    while (!q.empty()) {\n      int now = q.front();\n      q.pop();\n      inq[now] = 0;\n      for (int i = head[now]; i; i = nxt[i])\n        if (dis[ver[i]] > dis[now] + val[i] ||\n            (dis[ver[i]] == dis[now] + val[i] && len[ver[i]] > len[now] + 1)) {\n          dis[ver[i]] = dis[now] + val[i];\n          len[ver[i]] = len[now] + 1;\n          pre[ver[i]] = now;\n          if (!inq[ver[i]]) q.push(ver[i]);\n          inq[ver[i]] = 1;\n        }\n    }\n  }\n  void update() {\n    int now = cnt2 + 2;\n    while (now) {\n      ini[now] ^= 1;\n      if (ini[now])\n        ret -= e2[now].val;\n      else\n        ret += e2[now].val;\n      now = pre[now];\n    }\n  }\n} o;\nbool calc(int chose) {\n  for (int i = 1; i <= k; i++) d[i] = 0;\n  S.prework();\n  for (int i = 1; i <= cnt1; i++)\n    if ((chose >> (i - 1)) & 1) {\n      d[e1[i].from]++, d[e1[i].to]++;\n      S.merge(e1[i].from, e1[i].to);\n    }\n  for (int i = 1; i <= cnt2; i++)\n    if (ini[i]) {\n      if (e2[i].from <= k) d[e2[i].from]++;\n      S.merge(e2[i].from, e2[i].to);\n    }\n  int s = cnt2 + 1, t = cnt2 + 2;\n  o.clear();\n  for (int i = 1; i <= cnt2; i++) {\n    if (ini[i])\n      x[i] = y[i] = 0;\n    else {\n      x[i] = (!S.check(e2[i].from, e2[i].to));\n      y[i] = (e2[i].from > k || d[e2[i].from] + 1 <= dlim[e2[i].from]);\n      if (x[i]) o.add(s, i, e2[i].val);\n      if (y[i]) o.add(i, t, 0);\n    }\n  }\n  for (int i = 1; i <= cnt2; i++) {\n    if (!ini[i]) continue;\n    S.prework();\n    for (int j = 1; j <= cnt2; j++)\n      if (ini[j] && j != i) S.merge(e2[j].from, e2[j].to);\n    for (int i = 1; i <= cnt1; i++)\n      if ((chose >> (i - 1)) & 1) S.merge(e1[i].from, e1[i].to);\n    for (int j = 1; j <= cnt2; j++) {\n      if (ini[j]) continue;\n      if (!S.check(e2[j].from, e2[j].to)) o.add(i, j, e2[j].val);\n      if (e2[j].from > k ||\n          d[e2[j].from] - (e2[j].from == e2[i].from) < dlim[e2[j].from])\n        o.add(j, i, -e2[i].val);\n    }\n  }\n  o.spfa();\n  if (o.dis[t] == 0x3f3f3f3f) return false;\n  o.update();\n  return true;\n}\nvoid solve(int chose) {\n  for (int i = 1; i <= k; i++) d[i] = 0;\n  S.prework();\n  ret = 0;\n  for (int i = 1; i <= cnt1; i++)\n    if ((chose >> (i - 1)) & 1) {\n      d[e1[i].from]++;\n      d[e1[i].to]++;\n      ret += e1[i].val;\n      if (d[e1[i].from] > dlim[e1[i].from]) return;\n      if (d[e1[i].to] > dlim[e1[i].to]) return;\n      if (S.check(e1[i].from, e1[i].to)) return;\n      S.merge(e1[i].from, e1[i].to);\n    }\n  for (int i = 1; i <= cnt2; i++) ini[i] = 0;\n  int cnt = 0;\n  if (ret > ans) return;\n  while (calc(chose))\n    if (ret > ans) return;\n  ret = 0;\n  bool flag = 1;\n  S.prework();\n  for (int i = 1; i <= cnt1; i++)\n    if ((chose >> (i - 1)) & 1) S.merge(e1[i].from, e1[i].to), ret += e1[i].val;\n  for (int i = 1; i <= cnt2; i++)\n    if (ini[i]) S.merge(e2[i].from, e2[i].to), ret += e2[i].val;\n  for (int i = 1; i <= n; i++)\n    if (!S.check(1, i)) return;\n  ans = min(ret, ans);\n}\nint main() {\n  n = read();\n  k = read();\n  for (int i = 1; i <= k; i++) dlim[i] = read();\n  for (int i = 1; i <= n - 1; i++)\n    for (int j = 1; j <= n - i; j++)\n      if (i <= k && i + j <= k) {\n        cnt1++;\n        e1[cnt1].from = i;\n        e1[cnt1].to = i + j;\n        e1[cnt1].val = read();\n      } else {\n        cnt2++;\n        e2[cnt2].from = i;\n        e2[cnt2].to = i + j;\n        e2[cnt2].val = read();\n      }\n  ans = inf;\n  for (int i = 0; i < (1 << cnt1); i++) solve(i);\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.io.IOException;\nimport java.lang.reflect.Field;\nimport java.nio.charset.StandardCharsets;\nimport java.io.UncheckedIOException;\nimport java.util.function.Consumer;\nimport java.util.List;\nimport java.io.Closeable;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            HDIYTree solver = new HDIYTree();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class HDIYTree {\n        Debug debug = new Debug(true);\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.ri();\n            int k = in.ri();\n            int[] d = in.ri(k);\n            int n2 = n * (n - 1) / 2;\n            int ck = k * (k - 1) / 2;\n            IntegerArrayList usList = new IntegerArrayList(n2);\n            IntegerArrayList vsList = new IntegerArrayList(n2);\n            LongArrayList wsList = new LongArrayList(n2);\n            IntegerArrayList edgeList = new IntegerArrayList(ck);\n            List<Edge> outside = new ArrayList<>(n2);\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    if (i >= k && j >= k) {\n                        Edge e = new Edge(i, j, in.ri());\n                        outside.add(e);\n                    } else {\n                        usList.add(i);\n                        vsList.add(j);\n                        wsList.add(in.ri());\n                    }\n                    if (i < k && j < k) {\n                        edgeList.add(usList.size() - 1);\n                    }\n                }\n            }\n            DSU dsu = new DSU(n);\n            dsu.init();\n            outside.sort(Comparator.comparingInt(x -> x.w));\n\n            debug.debug(\"size\", usList.size());\n            for (Edge e : outside) {\n                if (dsu.find(e.a) == dsu.find(e.b)) {\n                    continue;\n                }\n                dsu.merge(e.a, e.b);\n                usList.add(e.a);\n                vsList.add(e.b);\n                wsList.add(e.w);\n            }\n            int[] us = usList.toArray();\n            int[] vs = vsList.toArray();\n            long[] ws = wsList.toArray();\n            int[] edges = edgeList.toArray();\n            int m = edges.length;\n            long inf = (long) 1e9;\n            long[] wsSnapshot = ws.clone();\n            int[] type = new int[us.length];\n            for (int i = 0; i < us.length; i++) {\n                if (us[i] < k && vs[i] >= k) {\n                    type[i] = us[i];\n                } else if (vs[i] < k && us[i] >= k) {\n                    type[i] = vs[i];\n                } else {\n                    type[i] = k;\n                }\n            }\n            debug.debug(\"size\", us.length);\n            long best = inf;\n            for (int i = 0; i < 1 << m; i++) {\n                boolean ok = true;\n                dsu.init();\n                System.arraycopy(wsSnapshot, 0, ws, 0, ws.length);\n                int[] cap = new int[k + 1];\n                System.arraycopy(d, 0, cap, 0, k);\n                cap[k] = n;\n                for (int j = 0; j < m; j++) {\n                    int e = edges[j];\n                    if (Bits.get(i, j) == 0) {\n                        ws[e] += inf;\n                    } else {\n                        int u = us[e];\n                        int v = vs[e];\n                        ws[e] -= inf;\n                        cap[u]--;\n                        cap[v]--;\n                        if (dsu.find(u) == dsu.find(v)) {\n                            ok = false;\n                        }\n                        dsu.merge(u, v);\n                    }\n                }\n                for (int j = 0; j < ws.length; j++) {\n                    ws[j] = -ws[j];\n                }\n                for (int j = 0; j <= k; j++) {\n                    if (cap[j] < 0) {\n                        ok = false;\n                    }\n                }\n                if (!ok) {\n                    continue;\n                }\n                MatroidIndependentSet container = MatroidIndependentSet.ofColorContainers(type, cap);\n                MatroidIndependentSet tree = MatroidIndependentSet.ofSpanningTree(n, new int[][]{us, vs});\n                MaximumWeightMatroidIntersect mi = new MaximumWeightMatroidIntersect(us.length, ws);\n                boolean[] sol = mi.intersect(container, tree);\n                long sum = 0;\n                int occur = 0;\n                for (int j = 0; j < sol.length; j++) {\n                    if (sol[j]) {\n                        occur++;\n                        sum += ws[j];\n                    }\n                }\n                sum = -sum;\n                sum += Integer.bitCount(i) * inf;\n                if (sum >= inf || occur < n - 1) {\n                    continue;\n                }\n                best = Math.min(best, sum);\n            }\n            out.println(best);\n        }\n\n    }\n\n    static class LongArrayList implements Cloneable {\n        private int size;\n        private int cap;\n        private long[] data;\n        private static final long[] EMPTY = new long[0];\n\n        public LongArrayList(int cap) {\n            this.cap = cap;\n            if (cap == 0) {\n                data = EMPTY;\n            } else {\n                data = new long[cap];\n            }\n        }\n\n        public LongArrayList(long[] data) {\n            this(0);\n            addAll(data);\n        }\n\n        public LongArrayList(LongArrayList list) {\n            this.size = list.size;\n            this.cap = list.cap;\n            this.data = Arrays.copyOf(list.data, size);\n        }\n\n        public LongArrayList() {\n            this(0);\n        }\n\n        public void ensureSpace(int req) {\n            if (req > cap) {\n                while (cap < req) {\n                    cap = Math.max(cap + 10, 2 * cap);\n                }\n                data = Arrays.copyOf(data, cap);\n            }\n        }\n\n        public void add(long x) {\n            ensureSpace(size + 1);\n            data[size++] = x;\n        }\n\n        public void addAll(long[] x) {\n            addAll(x, 0, x.length);\n        }\n\n        public void addAll(long[] x, int offset, int len) {\n            ensureSpace(size + len);\n            System.arraycopy(x, offset, data, size, len);\n            size += len;\n        }\n\n        public void addAll(LongArrayList list) {\n            addAll(list.data, 0, list.size);\n        }\n\n        public long[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n\n        public String toString() {\n            return Arrays.toString(toArray());\n        }\n\n        public boolean equals(Object obj) {\n            if (!(obj instanceof LongArrayList)) {\n                return false;\n            }\n            LongArrayList other = (LongArrayList) obj;\n            return SequenceUtils.equal(data, 0, size - 1, other.data, 0, other.size - 1);\n        }\n\n        public int hashCode() {\n            int h = 1;\n            for (int i = 0; i < size; i++) {\n                h = h * 31 + Long.hashCode(data[i]);\n            }\n            return h;\n        }\n\n        public LongArrayList clone() {\n            LongArrayList ans = new LongArrayList();\n            ans.addAll(this);\n            return ans;\n        }\n\n    }\n\n    static interface IntegerDeque extends IntegerStack {\n    }\n\n    static interface IntegerStack {\n    }\n\n    static class IntegerMultiWayStack {\n        private int[] values;\n        private int[] next;\n        private int[] heads;\n        private int alloc;\n        private int stackNum;\n\n        public IntegerIterator iterator(final int queue) {\n            return new IntegerIterator() {\n                int ele = heads[queue];\n\n\n                public boolean hasNext() {\n                    return ele != 0;\n                }\n\n\n                public int next() {\n                    int ans = values[ele];\n                    ele = next[ele];\n                    return ans;\n                }\n            };\n        }\n\n        private void doubleCapacity() {\n            int newSize = Math.max(next.length + 10, next.length * 2);\n            next = Arrays.copyOf(next, newSize);\n            values = Arrays.copyOf(values, newSize);\n        }\n\n        public void alloc() {\n            alloc++;\n            if (alloc >= next.length) {\n                doubleCapacity();\n            }\n            next[alloc] = 0;\n        }\n\n        public void clear() {\n            alloc = 0;\n            Arrays.fill(heads, 0, stackNum, 0);\n        }\n\n        public boolean isEmpty(int qId) {\n            return heads[qId] == 0;\n        }\n\n        public IntegerMultiWayStack(int qNum, int totalCapacity) {\n            values = new int[totalCapacity + 1];\n            next = new int[totalCapacity + 1];\n            heads = new int[qNum];\n            stackNum = qNum;\n        }\n\n        public void addLast(int qId, int x) {\n            alloc();\n            values[alloc] = x;\n            next[alloc] = heads[qId];\n            heads[qId] = alloc;\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < stackNum; i++) {\n                if (isEmpty(i)) {\n                    continue;\n                }\n                builder.append(i).append(\": \");\n                for (IntegerIterator iterator = iterator(i); iterator.hasNext(); ) {\n                    builder.append(iterator.next()).append(\",\");\n                }\n                if (builder.charAt(builder.length() - 1) == ',') {\n                    builder.setLength(builder.length() - 1);\n                }\n                builder.append('\\n');\n            }\n            return builder.toString();\n        }\n\n    }\n\n    static class MatroidIntersect {\n        protected IntegerDequeImpl dq;\n        protected int[] dists;\n        protected boolean[] added;\n        protected boolean[][] adj1;\n        protected boolean[][] adj2;\n        protected int n;\n        protected boolean[] x1;\n        protected boolean[] x2;\n        protected static int distInf = (int) 1e9;\n        protected int[] pre;\n        protected Consumer<boolean[]> callback;\n        protected static Consumer<boolean[]> nilCallback = x -> {\n        };\n\n        public void setCallback(Consumer<boolean[]> callback) {\n            if (callback == null) {\n                callback = nilCallback;\n            }\n            this.callback = callback;\n        }\n\n        public MatroidIntersect(int n) {\n            this.n = n;\n            dq = new IntegerDequeImpl(n);\n            dists = new int[n];\n            added = new boolean[n];\n            adj1 = new boolean[n][];\n            adj2 = new boolean[n][];\n            x1 = new boolean[n];\n            x2 = new boolean[n];\n            pre = new int[n];\n            setCallback(nilCallback);\n        }\n\n        protected boolean adj(int i, int j) {\n            if (added[i]) {\n                return adj1[i][j];\n            } else {\n                return adj2[j][i];\n            }\n        }\n\n        protected boolean expand(MatroidIndependentSet a, MatroidIndependentSet b, int round) {\n            Arrays.fill(x1, false);\n            Arrays.fill(x2, false);\n            a.prepare(added);\n            b.prepare(added);\n            a.extend(added, x1);\n            b.extend(added, x2);\n            for (int i = 0; i < n; i++) {\n                if (x1[i] && x2[i]) {\n                    pre[i] = -1;\n                    xorPath(i);\n                    return true;\n                }\n            }\n\n            for (int i = 0; i < n; i++) {\n                if (added[i]) {\n                    Arrays.fill(adj1[i], false);\n                    Arrays.fill(adj2[i], false);\n                }\n            }\n\n            a.computeAdj(added, adj1);\n            b.computeAdj(added, adj2);\n            Arrays.fill(dists, distInf);\n            Arrays.fill(pre, -1);\n            dq.clear();\n            for (int i = 0; i < n; i++) {\n                if (added[i]) {\n                    continue;\n                }\n                //right\n                if (x1[i]) {\n                    dists[i] = 0;\n                    dq.addLast(i);\n                }\n            }\n\n            int tail = -1;\n            while (!dq.isEmpty()) {\n                int head = dq.removeFirst();\n                if (x2[head]) {\n                    tail = head;\n                    break;\n                }\n                for (int j = 0; j < n; j++) {\n                    if (added[head] != added[j] && adj(head, j) && dists[j] > dists[head] + 1) {\n                        dists[j] = dists[head] + 1;\n                        dq.addLast(j);\n                        pre[j] = head;\n                    }\n                }\n            }\n\n            if (tail == -1) {\n                return false;\n            }\n\n            xorPath(tail);\n            return true;\n        }\n\n        protected void xorPath(int tail) {\n            boolean[] last1 = new boolean[n];\n            boolean[] last2 = new boolean[n];\n            for (boolean add = true; tail != -1; tail = pre[tail], add = !add) {\n                assert added[tail] != add;\n                added[tail] = add;\n                if (add) {\n                    adj1[tail] = last1;\n                    adj2[tail] = last2;\n                } else {\n                    last1 = adj1[tail];\n                    last2 = adj2[tail];\n                    adj1[tail] = null;\n                    adj2[tail] = null;\n                }\n            }\n        }\n\n        public boolean[] intersect(MatroidIndependentSet a, MatroidIndependentSet b) {\n            Arrays.fill(added, false);\n            int round = 0;\n            callback.accept(added);\n            while (expand(a, b, round)) {\n                round++;\n                callback.accept(added);\n            }\n            return added;\n        }\n\n    }\n\n    static class Edge {\n        int a;\n        int b;\n        int w;\n\n        public Edge(int a, int b, int w) {\n            this.a = a;\n            this.b = b;\n            this.w = w;\n        }\n\n    }\n\n    static class Bits {\n        private Bits() {\n        }\n\n        public static int get(int x, int i) {\n            return (x >>> i) & 1;\n        }\n\n    }\n\n    static interface IntegerIterator {\n        boolean hasNext();\n\n        int next();\n\n    }\n\n    static class DSU {\n        protected int[] p;\n        public int[] size;\n        protected int n;\n\n        public DSU(int n) {\n            p = new int[n];\n            size = new int[n];\n        }\n\n        public void init() {\n            init(p.length);\n        }\n\n        public void init(int n) {\n            this.n = n;\n            for (int i = 0; i < n; i++) {\n                p[i] = i;\n                size[i] = 1;\n            }\n        }\n\n        public final int find(int a) {\n            if (p[a] == p[p[a]]) {\n                return p[a];\n            }\n            find(p[a]);\n            preAccess(a);\n            return p[a] = p[p[a]];\n        }\n\n        protected void preAccess(int a) {\n\n        }\n\n        protected void preMerge(int a, int b) {\n            size[a] += size[b];\n        }\n\n        public final void merge(int a, int b) {\n            a = find(a);\n            b = find(b);\n            if (a == b) {\n                return;\n            }\n\n            if (size[a] < size[b]) {\n                int tmp = a;\n                a = b;\n                b = tmp;\n            }\n            preMerge(a, b);\n            p[b] = a;\n        }\n\n        public String toString() {\n            return Arrays.toString(Arrays.copyOf(p, n));\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private static final int THRESHOLD = 32 << 10;\n        private OutputStream writer;\n        private StringBuilder cache = new StringBuilder(THRESHOLD * 2);\n        private static Field stringBuilderValueField;\n        private char[] charBuf = new char[THRESHOLD * 2];\n        private byte[] byteBuf = new byte[THRESHOLD * 2];\n\n        static {\n            try {\n                stringBuilderValueField = StringBuilder.class.getSuperclass().getDeclaredField(\"value\");\n                stringBuilderValueField.setAccessible(true);\n            } catch (Exception e) {\n                stringBuilderValueField = null;\n            }\n            stringBuilderValueField = null;\n        }\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        private void afterWrite() {\n            if (cache.length() < THRESHOLD) {\n                return;\n            }\n            flush();\n        }\n\n        public FastOutput(OutputStream writer) {\n            this.writer = writer;\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(long c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput println(long c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            return append('\\n');\n        }\n\n        public FastOutput flush() {\n            try {\n                if (stringBuilderValueField != null) {\n                    try {\n                        byte[] value = (byte[]) stringBuilderValueField.get(cache);\n                        writer.write(value, 0, cache.length());\n                    } catch (Exception e) {\n                        stringBuilderValueField = null;\n                    }\n                }\n                if (stringBuilderValueField == null) {\n                    int n = cache.length();\n                    if (n > byteBuf.length) {\n                        //slow\n                        writer.write(cache.toString().getBytes(StandardCharsets.UTF_8));\n//                writer.append(cache);\n                    } else {\n                        cache.getChars(0, n, charBuf, 0);\n                        for (int i = 0; i < n; i++) {\n                            byteBuf[i] = (byte) charBuf[i];\n                        }\n                        writer.write(byteBuf, 0, n);\n                    }\n                }\n                writer.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                writer.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class IntegerArrayList implements Cloneable {\n        private int size;\n        private int cap;\n        private int[] data;\n        private static final int[] EMPTY = new int[0];\n\n        public int[] getData() {\n            return data;\n        }\n\n        public IntegerArrayList(int cap) {\n            this.cap = cap;\n            if (cap == 0) {\n                data = EMPTY;\n            } else {\n                data = new int[cap];\n            }\n        }\n\n        public IntegerArrayList(int[] data) {\n            this(0);\n            addAll(data);\n        }\n\n        public IntegerArrayList(IntegerArrayList list) {\n            this.size = list.size;\n            this.cap = list.cap;\n            this.data = Arrays.copyOf(list.data, size);\n        }\n\n        public IntegerArrayList() {\n            this(0);\n        }\n\n        public void ensureSpace(int req) {\n            if (req > cap) {\n                while (cap < req) {\n                    cap = Math.max(cap + 10, 2 * cap);\n                }\n                data = Arrays.copyOf(data, cap);\n            }\n        }\n\n        public void add(int x) {\n            ensureSpace(size + 1);\n            data[size++] = x;\n        }\n\n        public void addAll(int[] x) {\n            addAll(x, 0, x.length);\n        }\n\n        public void addAll(int[] x, int offset, int len) {\n            ensureSpace(size + len);\n            System.arraycopy(x, offset, data, size, len);\n            size += len;\n        }\n\n        public void addAll(IntegerArrayList list) {\n            addAll(list.data, 0, list.size);\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public int[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n\n        public void clear() {\n            size = 0;\n        }\n\n        public String toString() {\n            return Arrays.toString(toArray());\n        }\n\n        public boolean equals(Object obj) {\n            if (!(obj instanceof IntegerArrayList)) {\n                return false;\n            }\n            IntegerArrayList other = (IntegerArrayList) obj;\n            return SequenceUtils.equal(data, 0, size - 1, other.data, 0, other.size - 1);\n        }\n\n        public int hashCode() {\n            int h = 1;\n            for (int i = 0; i < size; i++) {\n                h = h * 31 + Integer.hashCode(data[i]);\n            }\n            return h;\n        }\n\n        public IntegerArrayList clone() {\n            IntegerArrayList ans = new IntegerArrayList();\n            ans.addAll(this);\n            return ans;\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static boolean equal(int[] a, int al, int ar, int[] b, int bl, int br) {\n            if ((ar - al) != (br - bl)) {\n                return false;\n            }\n            for (int i = al, j = bl; i <= ar; i++, j++) {\n                if (a[i] != b[j]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        public static boolean equal(long[] a, int al, int ar, long[] b, int bl, int br) {\n            if ((ar - al) != (br - bl)) {\n                return false;\n            }\n            for (int i = al, j = bl; i <= ar; i++, j++) {\n                if (a[i] != b[j]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n\n    static class MaximumWeightMatroidIntersect extends MatroidIntersect {\n        protected long[] weight;\n        protected long[] pathWeight;\n        protected static final long weightInf = (long) 1e18;\n        protected boolean[] inq;\n        protected long[] fixWeight;\n\n        public MaximumWeightMatroidIntersect(int n, long[] weight) {\n            super(n);\n            this.weight = weight;\n            pathWeight = new long[n];\n            inq = new boolean[n];\n            fixWeight = new long[n];\n        }\n\n        protected boolean expand(MatroidIndependentSet a, MatroidIndependentSet b, int round) {\n            a.prepare(added);\n            b.prepare(added);\n            Arrays.fill(x1, false);\n            Arrays.fill(x2, false);\n            a.extend(added, x1);\n            b.extend(added, x2);\n\n            for (int i = 0; i < n; i++) {\n                if (added[i]) {\n                    Arrays.fill(adj1[i], false);\n                    Arrays.fill(adj2[i], false);\n                    fixWeight[i] = weight[i];\n                } else {\n                    fixWeight[i] = -weight[i];\n                }\n            }\n\n            a.computeAdj(added, adj1);\n            b.computeAdj(added, adj2);\n            Arrays.fill(dists, MatroidIntersect.distInf);\n            Arrays.fill(pathWeight, weightInf);\n            Arrays.fill(pre, -1);\n            dq.clear();\n            for (int i = 0; i < n; i++) {\n                if (added[i]) {\n                    continue;\n                }\n                //right\n                if (x1[i]) {\n                    dists[i] = 0;\n                    pathWeight[i] = fixWeight[i];\n                    dq.addLast(i);\n                    inq[i] = true;\n                }\n            }\n\n            while (!dq.isEmpty()) {\n                int head = dq.removeFirst();\n                inq[head] = false;\n\n                for (int j = 0; j < n; j++) {\n                    if (added[head] != added[j] && adj(head, j)) {\n                        int comp = Long.compare(pathWeight[j], pathWeight[head] + fixWeight[j]);\n                        if (comp == 0) {\n                            comp = Integer.compare(dists[j], dists[head] + 1);\n                        }\n                        if (comp <= 0) {\n                            continue;\n                        }\n                        dists[j] = dists[head] + 1;\n                        pathWeight[j] = pathWeight[head] + fixWeight[j];\n                        pre[j] = head;\n                        if (!inq[j]) {\n                            inq[j] = true;\n                            dq.addLast(j);\n                        }\n                    }\n                }\n            }\n\n            int tail = -1;\n            for (int i = 0; i < n; i++) {\n                if (!x2[i] || !x1[i] && pre[i] == -1) {\n                    continue;\n                }\n                if (tail == -1 || pathWeight[i] < pathWeight[tail] || pathWeight[i] == pathWeight[tail] &&\n                        dists[i] < dists[tail]) {\n                    tail = i;\n                }\n            }\n            if (tail == -1) {\n                return false;\n            }\n\n            xorPath(tail);\n            return true;\n        }\n\n    }\n\n    static class IntegerDequeImpl implements IntegerDeque {\n        private int[] data;\n        private int bpos;\n        private int epos;\n        private static final int[] EMPTY = new int[0];\n        private int n;\n\n        public IntegerDequeImpl(int cap) {\n            if (cap == 0) {\n                data = EMPTY;\n            } else {\n                data = new int[cap];\n            }\n            bpos = 0;\n            epos = 0;\n            n = cap;\n        }\n\n        private void expandSpace(int len) {\n            while (n < len) {\n                n = Math.max(n + 10, n * 2);\n            }\n            int[] newData = new int[n];\n            if (bpos <= epos) {\n                if (bpos < epos) {\n                    System.arraycopy(data, bpos, newData, 0, epos - bpos);\n                }\n            } else {\n                System.arraycopy(data, bpos, newData, 0, data.length - bpos);\n                System.arraycopy(data, 0, newData, data.length - bpos, epos);\n            }\n            epos = size();\n            bpos = 0;\n            data = newData;\n        }\n\n        public IntegerIterator iterator() {\n            return new IntegerIterator() {\n                int index = bpos;\n\n\n                public boolean hasNext() {\n                    return index != epos;\n                }\n\n\n                public int next() {\n                    int ans = data[index];\n                    index = IntegerDequeImpl.this.next(index);\n                    return ans;\n                }\n            };\n        }\n\n        public int removeFirst() {\n            int ans = data[bpos];\n            bpos = next(bpos);\n            return ans;\n        }\n\n        public void addLast(int x) {\n            ensureMore();\n            data[epos] = x;\n            epos = next(epos);\n        }\n\n        public void clear() {\n            bpos = epos = 0;\n        }\n\n        private int next(int x) {\n            return x + 1 >= n ? 0 : x + 1;\n        }\n\n        private void ensureMore() {\n            if (next(epos) == bpos) {\n                expandSpace(n + 1);\n            }\n        }\n\n        public int size() {\n            int ans = epos - bpos;\n            if (ans < 0) {\n                ans += data.length;\n            }\n            return ans;\n        }\n\n        public boolean isEmpty() {\n            return bpos == epos;\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            for (IntegerIterator iterator = iterator(); iterator.hasNext(); ) {\n                builder.append(iterator.next()).append(' ');\n            }\n            return builder.toString();\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        public void populate(int[] data) {\n            for (int i = 0; i < data.length; i++) {\n                data[i] = readInt();\n            }\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int ri() {\n            return readInt();\n        }\n\n        public int[] ri(int n) {\n            int[] ans = new int[n];\n            populate(ans);\n            return ans;\n        }\n\n        public int readInt() {\n            boolean rev = false;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                rev = next == '-';\n                next = read();\n            }\n\n            int val = 0;\n            while (next >= '0' && next <= '9') {\n                val = val * 10 - next + '0';\n                next = read();\n            }\n\n            return rev ? val : -val;\n        }\n\n    }\n\n    static class Debug {\n        private boolean offline;\n        private PrintStream out = System.err;\n\n        public Debug(boolean enable) {\n            offline = enable && System.getSecurityManager() == null;\n        }\n\n        public Debug debug(String name, int x) {\n            if (offline) {\n                debug(name, \"\" + x);\n            }\n            return this;\n        }\n\n        public Debug debug(String name, String x) {\n            if (offline) {\n                out.printf(\"%s=%s\", name, x);\n                out.println();\n            }\n            return this;\n        }\n\n    }\n\n    static interface MatroidIndependentSet {\n        void computeAdj(boolean[] added, boolean[][] adj);\n\n        void extend(boolean[] added, boolean[] extendable);\n\n        void prepare(boolean[] added);\n\n        static MatroidIndependentSet ofColorContainers(int[] type, int[] cap) {\n            int[] size = new int[cap.length];\n            return new MatroidIndependentSet() {\n                /**\n                 * O(rn)\n                 * @param added\n                 * @param adj\n                 */\n\n                public void computeAdj(boolean[] added, boolean[][] adj) {\n                    for (int i = 0; i < added.length; i++) {\n                        if (!added[i]) {\n                            continue;\n                        }\n                        for (int j = 0; j < added.length; j++) {\n                            if (added[j]) {\n                                continue;\n                            }\n                            if (size[type[j]] < cap[type[j]] ||\n                                    type[i] == type[j]) {\n                                adj[i][j] = true;\n                            }\n                        }\n                    }\n                }\n\n                /**\n                 * O(n)\n                 * @param added\n                 * @param extendable\n                 */\n\n                public void extend(boolean[] added, boolean[] extendable) {\n                    for (int i = 0; i < added.length; i++) {\n                        if (!added[i] && size[type[i]] < cap[type[i]]) {\n                            extendable[i] = true;\n                        }\n                    }\n                }\n\n\n                public void prepare(boolean[] added) {\n                    Arrays.fill(size, 0);\n                    for (int i = 0; i < added.length; i++) {\n                        if (added[i]) {\n                            size[type[i]]++;\n                        }\n                    }\n                }\n            };\n        }\n\n        static MatroidIndependentSet ofSpanningTree(int n, int[][] edges) {\n            return new MatroidIndependentSet() {\n                DSU dsu = new DSU(n);\n                IntegerMultiWayStack g = new IntegerMultiWayStack(n, edges[0].length);\n                IntegerArrayList inset = new IntegerArrayList(edges[0].length);\n                int[] p = new int[n];\n                int[] depth = new int[n];\n\n                public void dfs(int root, int fa, int d) {\n                    p[root] = fa;\n                    depth[root] = d;\n                    for (IntegerIterator iterator = g.iterator(root); iterator.hasNext(); ) {\n                        int e = iterator.next();\n                        if (e == fa) {\n                            continue;\n                        }\n                        dfs(opponent(e, root), e, d + 1);\n                    }\n                }\n\n                public int opponent(int i, int root) {\n                    return edges[0][i] == root ? edges[1][i] : edges[0][i];\n                }\n\n                /**\n                 * O(rn)\n                 */\n\n                public void computeAdj(boolean[] added, boolean[][] adj) {\n                    int[] insetData = inset.getData();\n                    int m = inset.size();\n                    for (int i = 0; i < added.length; i++) {\n                        if (added[i]) {\n                            continue;\n                        }\n                        if (dsu.find(edges[0][i]) != dsu.find(edges[1][i])) {\n                            for (int j = 0; j < m; j++) {\n                                adj[insetData[j]][i] = true;\n                            }\n                        } else {\n                            int a = edges[0][i];\n                            int b = edges[1][i];\n                            while (a != b) {\n                                if (depth[a] < depth[b]) {\n                                    int tmp = a;\n                                    a = b;\n                                    b = tmp;\n                                }\n                                adj[p[a]][i] = true;\n                                a = opponent(p[a], a);\n                            }\n                        }\n                    }\n                }\n\n\n                /**\n                 * O(n)\n                 */\n\n                public void extend(boolean[] added, boolean[] extendable) {\n                    for (int i = 0; i < added.length; i++) {\n                        if (!added[i]) {\n                            extendable[i] = dsu.find(edges[0][i]) != dsu.find(edges[1][i]);\n                        }\n                    }\n                }\n\n                /**\n                 * O(r+n)\n                 */\n\n                public void prepare(boolean[] added) {\n                    g.clear();\n                    dsu.init();\n                    inset.clear();\n                    for (int i = 0; i < added.length; i++) {\n                        if (added[i]) {\n                            dsu.merge(edges[0][i], edges[1][i]);\n                            g.addLast(edges[0][i], i);\n                            g.addLast(edges[1][i], i);\n                            inset.add(i);\n                        }\n                    }\n                    Arrays.fill(p, -1);\n                    for (int i = 0; i < n; i++) {\n                        if (p[i] == -1) {\n                            dfs(i, -1, 0);\n                        }\n                    }\n                }\n            };\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int max_n = 55, inf = 1000111222;\nint copy_dsu[max_n];\nstruct dsu {\n  int p_or_sz[max_n];\n  void init(int n) {\n    for (int i = 0; i < n; ++i) {\n      p_or_sz[i] = -1;\n    }\n  }\n  void init_from_copy(int n) {\n    for (int i = 0; i < n; ++i) {\n      p_or_sz[i] = copy_dsu[i];\n    }\n  }\n  int find_set(int v) {\n    if (p_or_sz[v] < 0) {\n      return v;\n    }\n    return p_or_sz[v] = find_set(p_or_sz[v]);\n  }\n  bool union_set(int v1, int v2) {\n    v1 = find_set(v1);\n    v2 = find_set(v2);\n    if (v1 == v2) {\n      return false;\n    }\n    if (-p_or_sz[v1] > -p_or_sz[v2]) {\n      swap(v1, v2);\n    }\n    p_or_sz[v2] += p_or_sz[v1];\n    p_or_sz[v1] = v2;\n    return true;\n  }\n};\nint n, k, max_deg[max_n], D[max_n][max_n];\nint deg[max_n];\ndsu d;\nbool get_bit(int mask, int pos) { return (mask >> pos) & 1; }\nstruct GroundSetElement {\n  int u, v;\n  int cost;\n  bool taken;\n  GroundSetElement() {}\n  GroundSetElement(int u, int v, int cost)\n      : u(u), v(v), cost(cost), taken(false) {}\n  bool operator<(const GroundSetElement &g) const { return cost < g.cost; }\n};\nconst int max_e = max_n * max_n / 2;\nvector<GroundSetElement> elems;\nint cur_deg[max_n];\nint parent[max_e], weight[max_e];\npair<int, int> dist[max_e];\nvector<pair<int, int>> edges;\nbool is_s[max_e], is_t[max_e];\nvoid prepare() {\n  d.init_from_copy(n);\n  copy(deg, deg + n, cur_deg);\n  for (int i = 0; i < elems.size(); ++i) {\n    if (elems[i].taken) {\n      d.union_set(elems[i].u, elems[i].v);\n      --cur_deg[elems[i].u];\n      --cur_deg[elems[i].v];\n    }\n  }\n}\nbool is_ok1(const GroundSetElement &a) {\n  return d.find_set(a.u) != d.find_set(a.v);\n}\nbool is_ok2(const GroundSetElement &a) {\n  return cur_deg[a.u] > 0 && cur_deg[a.v] > 0;\n}\nbool augment() {\n  edges.clear();\n  prepare();\n  for (int i = 0; i < elems.size(); ++i) {\n    if (!elems[i].taken) {\n      is_s[i] = is_ok1(elems[i]);\n      is_t[i] = is_ok2(elems[i]);\n      weight[i] = -elems[i].cost;\n    } else {\n      is_s[i] = is_t[i] = false;\n      weight[i] = elems[i].cost;\n    }\n    weight[i] *= -1;\n  }\n  for (int i = 0; i < elems.size(); ++i) {\n    if (elems[i].taken) {\n      elems[i].taken = false;\n      prepare();\n      elems[i].taken = true;\n      for (int j = 0; j < elems.size(); ++j) {\n        if (!elems[j].taken) {\n          if (is_ok1(elems[j])) {\n            edges.push_back({i, j});\n          }\n          if (is_ok2(elems[j])) {\n            edges.push_back({j, i});\n          }\n        }\n      }\n    }\n  }\n  for (int i = 0; i < elems.size(); ++i) {\n    dist[i] = {inf, inf};\n    parent[i] = -1;\n    if (is_s[i]) {\n      dist[i] = {weight[i], 0};\n    }\n  }\n  for (bool change = true; change;) {\n    change = false;\n    for (const auto &edge : edges) {\n      pair<int, int> ndist = dist[edge.first];\n      if (ndist.first == inf) {\n        continue;\n      }\n      ndist.first += weight[edge.second];\n      ++ndist.second;\n      if (dist[edge.second] > ndist) {\n        dist[edge.second] = ndist;\n        parent[edge.second] = edge.first;\n        change = true;\n      }\n    }\n  }\n  int t = -1;\n  for (int i = 0; i < elems.size(); ++i) {\n    if (is_t[i] && (t == -1 || dist[t] > dist[i])) {\n      t = i;\n    }\n  }\n  if (t == -1 || dist[t].first == inf) {\n    return false;\n  }\n  while (t != -1) {\n    elems[t].taken ^= 1;\n    t = parent[t];\n  }\n  return true;\n}\nint ans = inf;\nint solve(int need_e, int cost) {\n  for (int i = 0; i < n; ++i) {\n    copy_dsu[i] = d.p_or_sz[i];\n  }\n  for (int i = 0; i < elems.size(); ++i) {\n    elems[i].taken = false;\n  }\n  int it = 0;\n  while (augment()) {\n    ++it;\n    int res = cost;\n    for (int i = 0; i < elems.size(); ++i) {\n      if (elems[i].taken) {\n        res += elems[i].cost;\n      }\n    }\n    int cnt = need_e - it;\n    for (int i = 0; i < elems.size() && cnt; ++i) {\n      if (!elems[i].taken) {\n        res += elems[i].cost;\n        --cnt;\n      }\n    }\n    if (res >= ans) {\n      return -1;\n    }\n  }\n  if (it != need_e) {\n    return -1;\n  }\n  int res = cost;\n  for (int i = 0; i < elems.size(); ++i) {\n    if (elems[i].taken) {\n      res += elems[i].cost;\n    }\n  }\n  return res;\n}\ndouble start = clock();\nbool is_tl() { return (clock() - start) / CLOCKS_PER_SEC > 5.5; }\nint main() {\n  if (0) {\n    n = 50;\n    k = 5;\n    for (int i = 0; i < k; ++i) {\n      max_deg[i] = inf;\n    }\n    for (int i = 0; i < n; ++i) {\n      for (int j = i + 1; j < n; ++j) {\n        D[i][j] = rand() % 100 + 1;\n      }\n    }\n  } else {\n    cin >> n >> k;\n    for (int i = 0; i < k; ++i) {\n      cin >> max_deg[i];\n    }\n    for (int i = 0; i < n; ++i) {\n      for (int j = i + 1; j < n; ++j) {\n        cin >> D[i][j];\n      }\n    }\n  }\n  for (int i = k; i < n; ++i) {\n    for (int j = i + 1; j < n; ++j) {\n      elems.push_back({i, j, D[i][j]});\n    }\n  }\n  sort(elems.begin(), elems.end());\n  vector<GroundSetElement> ok_elems;\n  d.init(n);\n  for (auto elem : elems) {\n    if (d.union_set(elem.u, elem.v)) {\n      ok_elems.push_back(elem);\n    }\n  }\n  elems.swap(ok_elems);\n  for (int i = 0; i < k; ++i) {\n    for (int j = k; j < n; ++j) {\n      elems.push_back({i, j, D[i][j]});\n    }\n  }\n  sort(elems.begin(), elems.end());\n  int small_e = (k * (k - 1)) / 2;\n  int TOT = 0;\n  vector<int> all_masks;\n  for (int mask = 0; mask < (1 << small_e); ++mask) {\n    all_masks.push_back(mask);\n  }\n  const int seed = chrono::steady_clock::now().time_since_epoch().count();\n  mt19937 generator(seed);\n  shuffle(all_masks.begin(), all_masks.end(), generator);\n  for (int mask : all_masks) {\n    if (is_tl()) {\n      cout << ans << \"\\n\";\n      return 0;\n    }\n    d.init(n);\n    copy(max_deg, max_deg + k, deg);\n    fill(deg + k, deg + n, inf);\n    int num = 0, cost = 0;\n    bool ok = 1;\n    int need_e = n - 1;\n    for (int i = 0; i < k && ok; ++i) {\n      for (int j = i + 1; j < k && ok; ++j) {\n        if (get_bit(mask, num)) {\n          if (!d.union_set(i, j) || !deg[i] || !deg[j]) {\n            ok = 0;\n            break;\n          }\n          --deg[i];\n          --deg[j];\n          cost += D[i][j];\n          --need_e;\n        }\n        ++num;\n      }\n    }\n    if (!ok) {\n      continue;\n    }\n    ++TOT;\n    int res = solve(need_e, cost);\n    if (res == -1) {\n      continue;\n    }\n    ans = min(ans, res);\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 0x3f3f3f3f3f3f3f3f;\nconst int mo = 998244353;\nconst int inv2 = 499122177;\nconst double jzm = 0.9995;\nconst int zero = 5000;\nconst int orG = 3, invG = 332748118;\nconst double Pi = acos(-1.0);\nconst double eps = 1e-3;\ntemplate <typename _T>\n_T Fabs(_T x) {\n  return x < 0 ? -x : x;\n}\ntemplate <typename _T>\nvoid read(_T &x) {\n  _T f = 1;\n  x = 0;\n  char s = getchar();\n  while (s > '9' || s < '0') {\n    if (s == '-') f = -1;\n    s = getchar();\n  }\n  while ('0' <= s && s <= '9') {\n    x = (x << 3) + (x << 1) + (s ^ 48);\n    s = getchar();\n  }\n  x *= f;\n}\ntemplate <typename _T>\nvoid print(_T x) {\n  if (x < 0) {\n    x = (~x) + 1;\n    putchar('-');\n  }\n  if (x > 9) print(x / 10);\n  putchar(x % 10 + '0');\n}\nlong long gcd(long long a, long long b) { return !b ? a : gcd(b, a % b); }\nint add(int x, int y, int p) { return x + y < p ? x + y : x + y - p; }\nvoid Add(int &x, int y, int p) { x = add(x, y, p); }\nint qkpow(int a, int s, int p) {\n  int t = 1;\n  while (s) {\n    if (s & 1LL) t = 1ll * a * t % p;\n    a = 1ll * a * a % p;\n    s >>= 1LL;\n  }\n  return t;\n}\nint n, k, d[55], mp[55][55], t[55], fa[55], tota, totb, deg[55], summ, ans,\n    ord[55][55], sta[55], stak;\nbool cho[55][55], tmp[55][55], ap[55][55], fg[55];\nstruct edge {\n  int u, v, w;\n} a[2505], b[2505];\nbool cmp(edge x, edge y) { return x.w < y.w; }\nbool cmp1(int x, int y) { return t[x] < t[y]; }\ndouble Rand() {\n  return 1.0 * (rand() * RAND_MAX + rand()) / (RAND_MAX * RAND_MAX);\n}\nvoid makeSet(int x) {\n  for (int i = 1; i <= x; i++) fa[i] = i;\n}\nint findSet(int x) { return fa[x] == x ? x : fa[x] = findSet(fa[x]); }\nvoid unionSet(int a, int b) {\n  int u = findSet(a), v = findSet(b);\n  if (u != v) fa[u] = v;\n}\nvoid work(int x) {\n  for (int i = 1; i <= n; i++) {\n    if (ord[x][i] <= k && !fg[findSet(ord[x][i])]) continue;\n    if (ord[x][i] <= k && deg[ord[x][i]] == d[ord[x][i]]) continue;\n    unionSet(ord[x][i], x);\n    tmp[min(ord[x][i], x)][max(ord[x][i], x)] = 1;\n    deg[ord[x][i]]++;\n    deg[x]++;\n    break;\n  }\n}\nvoid sakura(double tp) {\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= n; j++) tmp[i][j] = 0;\n  for (int i = 1; i <= n; i++) deg[i] = fg[i] = 0;\n  summ = 0;\n  makeSet(n);\n  int tim = 0;\n  for (int i = 1; i <= tota; i++) {\n    int u = a[i].u, v = a[i].v, w = a[i].w;\n    if (!cho[u][v]) continue;\n    if (Rand() < tp) {\n      tmp[u][v] = 0;\n      continue;\n    }\n    tmp[u][v] = 1;\n    deg[u]++;\n    deg[v]++;\n    unionSet(u, v);\n    tim++;\n  }\n  random_shuffle(a + 1, a + tota + 1);\n  for (int i = 1; i <= tota; i++) {\n    int u = a[i].u, v = a[i].v, w = a[i].w;\n    if (tmp[u][v] || findSet(u) == findSet(v)) continue;\n    if (Rand() > tp || deg[u] == d[u] || deg[v] == d[v]) continue;\n    tmp[u][v] = 1;\n    deg[u]++;\n    deg[v]++;\n    unionSet(u, v);\n    tim++;\n  }\n  for (int i = k + 1; i <= n; i++) fg[findSet(i)] = 1;\n  tim = 0;\n  for (int i = 1; i <= k; i++) {\n    if (fg[findSet(i)]) continue;\n    int p = findSet(i), spc = 0;\n    for (int j = 1; j <= k; j++)\n      if (findSet(j) == p && deg[j] < d[j]) spc = j;\n    if (!spc) {\n      stak = 0;\n      for (int j = 1; j <= k; j++)\n        if (findSet(j) == p) sta[++stak] = j;\n      for (int j = 1; j <= stak; j++) {\n        int u = sta[j];\n        fa[u] = u;\n        deg[u] = 0;\n        for (int l = 1; l <= k; l++) tmp[l][u] = tmp[u][l] = 0;\n      }\n      for (int j = 1; j <= stak; j++) work(sta[j]), fg[findSet(sta[j])] = 1;\n    } else\n      work(spc), fg[findSet(spc)] = 1;\n  }\n  for (int i = 1; i <= totb; i++)\n    if (findSet(b[i].u) != findSet(b[i].v))\n      unionSet(b[i].u, b[i].v), deg[b[i].u]++, deg[b[i].v]++,\n          tmp[b[i].u][b[i].v] = 1;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++)\n      if (tmp[i][j]) summ += mp[i][j], tim++;\n}\nvoid nagisa() {\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) cho[i][j] = ap[i][j];\n  summ = 0;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++)\n      if (cho[i][j]) summ += mp[i][j];\n  for (int t = 1; t <= 500; t++) {\n    int now = summ;\n    sakura(0.5);\n    if (summ < now)\n      for (int i = 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++) cho[i][j] = tmp[i][j];\n    else\n      summ = now;\n  }\n  if (ans > summ) {\n    for (int i = 1; i <= n; i++)\n      for (int j = i + 1; j <= n; j++) ap[i][j] = cho[i][j];\n    ans = summ;\n  }\n  double nowT = 5000.0;\n  while (nowT > eps) {\n    int now = summ;\n    sakura(nowT);\n    double t = Rand();\n    if (ans > summ) {\n      for (int i = 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++) ap[i][j] = cho[i][j] = tmp[i][j];\n      ans = summ;\n    } else if (exp(1.0 * (now - summ) / nowT) > t)\n      for (int i = 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++) cho[i][j] = tmp[i][j];\n    else\n      summ = now;\n    nowT *= jzm;\n  }\n}\nsigned main() {\n  srand(time(NULL));\n  read(n);\n  read(k);\n  for (int i = 1; i <= k; i++) read(d[i]);\n  for (int i = k + 1; i <= n; i++) d[i] = n;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) {\n      read(mp[i][j]), mp[j][i] = mp[i][j];\n      if (i <= k)\n        a[++tota] = (edge){i, j, mp[i][j]};\n      else\n        b[++totb] = (edge){i, j, mp[i][j]};\n    }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) t[j] = mp[i][j];\n    for (int j = 1; j <= n; j++) ord[i][j] = j;\n    sort(ord[i] + 1, ord[i] + n + 1, cmp1);\n  }\n  sort(b + 1, b + totb + 1, cmp);\n  sakura(1.0);\n  ans = summ;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) ap[i][j] = cho[i][j] = tmp[i][j];\n  for (int i = 1; i <= 4; i++) nagisa();\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <typename T>\nbool mincheck(T &a, T b) {\n  return (b < a) ? a = b, 1 : 0;\n}\ntemplate <typename T>\nbool chkmax(T &a, T b) {\n  return (b > a) ? a = b, 1 : 0;\n}\nlong long ksm(long long a, long long b) {\n  if (b == 0) return 1;\n  long long ns = ksm(a, b >> 1);\n  ns = ns * ns % 998244353;\n  if (b & 1) ns = ns * a % 998244353;\n  return ns;\n}\nusing namespace std;\nconst int maxinun = 305;\nstruct th {\n  int u, v;\n  int w;\n  th() {}\n  th(int a, int b, int c) { u = a, v = b, w = c; }\n} p[maxinun];\nint n, k;\nint cnt = 0;\nint fa[maxinun];\nint gmh(int a) {\n  if (fa[a] == a) return a;\n  return fa[a] = gmh(fa[a]);\n}\nvoid ini() {\n  for (int i = 1; i <= n; i++) fa[i] = i;\n}\nvoid lk(int a, int b) { fa[gmh(a)] = gmh(b); }\nvector<pair<int, int> > eg[maxinun];\nint dis[maxinun];\nint S, T;\nint pre[maxinun];\nconst int N = 55;\nint fl[maxinun];\nint d[N], cd[N];\nint w[N][N];\nvector<pair<int, int> > preg;\nint nans = 0;\nconst int inf = 50000;\nvoid ade(int u, int v, int w) { eg[u].push_back(make_pair(v, w)); }\nint q[maxinun * maxinun], fr, ed;\nint inq[maxinun];\nbool bfs() {\n  S = cnt + 1, T = cnt + 2;\n  for (int i = 1; i <= T; i++) eg[i].clear();\n  vector<int> fls;\n  for (int i = 1; i <= cnt; i++) {\n    if (fl[i]) fls.push_back(i);\n  }\n  for (int i = 0; i <= cnt; i++) {\n    if (i != 0 && !fl[i]) continue;\n    ini();\n    for (auto v : preg) lk(v.first, v.second);\n    for (auto j : fls) {\n      if (j == i) continue;\n      lk(p[j].u, p[j].v);\n    }\n    int nid = i;\n    if (i == 0) nid = S;\n    for (int i = 1; i <= cnt; i++) {\n      if (fl[i]) continue;\n      if (gmh(p[i].u) != gmh(p[i].v)) ade(nid, i, inf - p[i].w);\n    }\n  }\n  for (int i = 0; i <= cnt; i++) {\n    if (i != 0 && !fl[i]) continue;\n    memset(cd, 0, sizeof(cd));\n    for (auto v : preg) cd[v.first] += 1, cd[v.second] += 1;\n    for (auto j : fls) {\n      if (j == i) continue;\n      cd[p[j].u] += 1, cd[p[j].v] += 1;\n    }\n    int nid = i;\n    if (i == 0) nid = T;\n    int nw = inf - p[nid].w;\n    if (nid == T) nw = 0;\n    for (int i = 1; i <= cnt; i++) {\n      if (fl[i]) continue;\n      if (cd[p[i].u] < d[p[i].u] && cd[p[i].v] < d[p[i].v]) ade(i, nid, -nw);\n    }\n  }\n  for (int i = 1; i <= T; i++) dis[i] = -inf, inq[i] = 0;\n  int fr = 0, ed = 0;\n  dis[S] = 0;\n  q[ed++] = S, inq[S] = 1;\n  while (fr < ed) {\n    int cur = q[fr++];\n    inq[cur] = 0;\n    for (auto v : eg[cur]) {\n      int eid = v.first, ew = v.second;\n      if (chkmax(dis[eid], dis[cur] + ew)) {\n        pre[eid] = cur;\n        if (!inq[eid]) q[ed++] = eid, inq[eid] = 1;\n      }\n    }\n  }\n  if (dis[T] <= 0) return 0;\n  vector<int> cc;\n  int ee = pre[T];\n  while (1) {\n    cc.push_back(ee);\n    ee = pre[ee];\n    if (ee == S) break;\n  }\n  nans += dis[T];\n  for (auto v : cc) fl[v] ^= 1;\n  return 1;\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 1; i <= k; i++) cin >> d[i];\n  for (int i = k + 1; i <= n; i++) d[i] = 1e9;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) scanf(\"%d\", &w[i][j]);\n  int ans = 1e9;\n  ini();\n  vector<array<int, 3> > u;\n  for (int i = k + 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) u.push_back({w[i][j], i, j});\n  sort(u.begin(), u.end());\n  for (auto s : u) {\n    if (gmh(s[1]) == gmh(s[2])) continue;\n    lk(s[1], s[2]);\n    p[++cnt] = th(s[1], s[2], s[0]);\n  }\n  for (int i = 1; i <= k; i++)\n    for (int j = k + 1; j <= n; j++) p[++cnt] = th(i, j, w[i][j]);\n  for (int i = 0; i < (1 << (k * (k - 1) / 2)); i++) {\n    ini();\n    preg.clear();\n    memset(cd, 0, sizeof(cd));\n    nans = 0;\n    int ncnt = 0;\n    for (int u = 1; u <= k; u++)\n      for (int v = u + 1; v <= k; v++) {\n        if (i & (1 << ncnt)) preg.push_back(make_pair(u, v));\n        ncnt += 1;\n      }\n    int flag = 1;\n    for (auto s : preg) {\n      if (gmh(s.first) == gmh(s.second)) flag = 0;\n      lk(s.first, s.second);\n      nans += inf - w[s.first][s.second];\n      cd[s.first] += 1, cd[s.second] += 1;\n    }\n    for (int i = 1; i <= k; i++)\n      if (cd[i] > d[i]) flag = 0;\n    if (!flag) continue;\n    memset(fl, 0, sizeof(fl));\n    for (int m = 0; m < n - 1 - preg.size(); m++) {\n      flag &= bfs();\n      if (!flag) break;\n    }\n    if (flag) {\n      mincheck(ans, (n - 1) * inf - nans);\n    }\n  }\n  cout << ans << endl;\n  return (0 - 0);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int mod = 1000000007;\nconst int gmod = 3;\nconst int inf = 1039074182;\nconst double eps = 1e-9;\nconst double pi = 3.141592653589793238462643383279;\nconst long long llinf = 2LL * inf * inf;\ntemplate <typename T1, typename T2>\ninline void chmin(T1 &x, T2 b) {\n  if (b < x) x = b;\n}\ntemplate <typename T1, typename T2>\ninline void chmax(T1 &x, T2 b) {\n  if (b > x) x = b;\n}\ninline void chadd(int &x, int b) {\n  x += b - mod;\n  x += (x >> 31 & mod);\n}\ntemplate <typename T1, typename T2>\ninline void chadd(T1 &x, T2 b) {\n  x += b;\n  if (x >= mod) x -= mod;\n}\ntemplate <typename T1, typename T2>\ninline void chmul(T1 &x, T2 b) {\n  x = 1LL * x * b % mod;\n}\ntemplate <typename T1, typename T2>\ninline void chmod(T1 &x, T2 b) {\n  x %= b, x += b;\n  if (x >= b) x -= b;\n}\ntemplate <typename T>\ninline T mabs(T x) {\n  return (x < 0 ? -x : x);\n}\nusing namespace std;\nusing namespace std;\ntemplate <typename T>\nostream &operator<<(ostream &cout, const vector<T> &vec) {\n  cout << \"{\";\n  for (int i = 0; i < (int)vec.size(); i++) {\n    cout << vec[i];\n    if (i != (int)vec.size() - 1) cout << ',';\n  }\n  cout << \"}\";\n  return cout;\n}\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &cout, pair<T1, T2> p) {\n  cout << \"(\" << p.first << ',' << p.second << \")\";\n  return cout;\n}\ntemplate <typename T, typename T2>\nostream &operator<<(ostream &cout, set<T, T2> s) {\n  vector<T> t;\n  for (auto x : s) t.push_back(x);\n  cout << t;\n  return cout;\n}\ntemplate <typename T, typename T2>\nostream &operator<<(ostream &cout, multiset<T, T2> s) {\n  vector<T> t;\n  for (auto x : s) t.push_back(x);\n  cout << t;\n  return cout;\n}\ntemplate <typename T>\nostream &operator<<(ostream &cout, queue<T> q) {\n  vector<T> t;\n  while (q.size()) {\n    t.push_back(q.front());\n    q.pop();\n  }\n  cout << t;\n  return cout;\n}\ntemplate <typename T1, typename T2, typename T3>\nostream &operator<<(ostream &cout, map<T1, T2, T3> m) {\n  for (auto &x : m) {\n    cout << \"Key: \" << x.first << ' ' << \"Value: \" << x.second << endl;\n  }\n  return cout;\n}\ntemplate <typename T1, typename T2>\nvoid operator+=(pair<T1, T2> &x, const pair<T1, T2> y) {\n  x.first += y.first;\n  x.second += y.second;\n}\ntemplate <typename T1, typename T2>\npair<T1, T2> operator+(const pair<T1, T2> &x, const pair<T1, T2> &y) {\n  return make_pair(x.first + y.first, x.second + y.second);\n}\ntemplate <typename T1, typename T2>\npair<T1, T2> operator-(const pair<T1, T2> &x, const pair<T1, T2> &y) {\n  return make_pair(x.first - y.first, x.second - y.second);\n}\ntemplate <typename T1, typename T2>\npair<T1, T2> operator-(pair<T1, T2> x) {\n  return make_pair(-x.first, -x.second);\n}\ntemplate <typename T>\nvector<vector<T>> operator~(vector<vector<T>> vec) {\n  vector<vector<T>> v;\n  int n = vec.size(), m = vec[0].size();\n  v.resize(m);\n  for (int i = 0; i < m; i++) {\n    v[i].resize(n);\n  }\n  for (int i = 0; i < m; i++) {\n    for (int j = 0; j < n; j++) {\n      v[i][j] = vec[j][i];\n    }\n  }\n  return v;\n}\nvoid print0x(int x) {\n  std::vector<int> vec;\n  while (x) {\n    vec.push_back(x & 1);\n    x >>= 1;\n  }\n  std::reverse(vec.begin(), vec.end());\n  for (int i = 0; i < (int)vec.size(); i++) {\n    std::cout << vec[i];\n  }\n  std::cout << ' ';\n}\ntemplate <typename T>\nvoid print0x(T x, int len) {\n  std::vector<int> vec;\n  while (x) {\n    std::cout << (x & 1);\n    x >>= 1;\n    len--;\n  }\n  while (len--) cout << 0;\n}\nvector<string> vec_splitter(string s) {\n  s += ',';\n  vector<string> res;\n  while (!s.empty()) {\n    res.push_back(s.substr(0, s.find(',')));\n    s = s.substr(s.find(',') + 1);\n  }\n  return res;\n}\nvoid debug_out(vector<string> __attribute__((unused)) args,\n               __attribute__((unused)) int idx,\n               __attribute__((unused)) int LINE_NUM) {\n  cerr << endl;\n}\ntemplate <typename Head, typename... Tail>\nvoid debug_out(vector<string> args, int idx, int LINE_NUM, Head H, Tail... T) {\n  if (idx > 0)\n    cerr << \", \";\n  else\n    cerr << \"Line(\" << LINE_NUM << \") \";\n  stringstream ss;\n  ss << H;\n  cerr << args[idx] << \" = \" << ss.str();\n  debug_out(args, idx + 1, LINE_NUM, T...);\n}\nstruct DSUAE {\n  int *f;\n  inline void clear(int n) {\n    for (int i = 0; i < n; i++) {\n      f[i] = i;\n    }\n  }\n  inline void init(int n) {\n    f = new int[n + 5];\n    clear(n);\n  }\n  inline int find(int x) { return (f[x] == x ? x : f[x] = find(f[x])); }\n  inline bool merge(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return 0;\n    if (x & 1)\n      f[x] = y;\n    else\n      f[y] = x;\n    return 1;\n  }\n  inline bool same(int x, int y) { return (find(x) == find(y)); }\n};\nstruct DSU {\n  int *f;\n  int *depth;\n  int *sz;\n  int n;\n  inline void clear(int n) {\n    for (int i = 0; i < n; i++) {\n      f[i] = i;\n      depth[i] = 1;\n      sz[i] = 1;\n    }\n  }\n  inline void init(int _n) {\n    n = _n;\n    f = new int[n + 5];\n    depth = new int[n + 5];\n    sz = new int[n + 5];\n    clear(n);\n  }\n  inline int find(int x) {\n    assert(0 <= x && x < n);\n    return (f[x] == x ? x : f[x] = find(f[x]));\n  }\n  inline int getSize(int x) {\n    assert(0 <= x && x < n);\n    return sz[find(x)];\n  }\n  inline int merge(int x, int y) {\n    assert(0 <= x && x < n);\n    assert(0 <= y && y < n);\n    x = find(x);\n    y = find(y);\n    if (x == y) return false;\n    if (depth[x] > depth[y]) {\n      f[y] = x;\n      sz[x] += sz[y];\n    } else if (depth[y] > depth[x]) {\n      f[x] = y;\n      sz[y] += sz[x];\n    } else {\n      sz[y] += sz[x];\n      f[x] = y;\n      depth[y]++;\n    }\n    return true;\n  }\n  inline int same(int x, int y) {\n    assert(0 <= x && x < n);\n    assert(0 <= y && y < n);\n    return (find(x) == find(y));\n  }\n  ~DSU() {\n    delete[] f;\n    delete[] depth;\n    delete[] sz;\n  }\n};\nstruct PersistentDSU : public DSU {\n  int find(int x) { return (x == f[x] ? x : find(f[x])); }\n  inline int merge(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return false;\n    if (depth[x] > depth[y]) {\n      f[y] = x;\n      sz[x] += sz[y];\n    } else if (depth[y] > depth[x]) {\n      f[x] = y;\n      sz[y] += sz[x];\n    } else {\n      sz[y] += sz[x];\n      f[x] = y;\n      depth[y]++;\n    }\n    return true;\n  }\n};\nlong long _Rand_Gen_Num() { return 1LL * rand() * RAND_MAX + rand(); }\nint rand(int l, int r) {\n  long long x = _Rand_Gen_Num();\n  return x % (r - l + 1) + l;\n}\ntemplate <typename Iterator>\nvoid _m_random_shuffle(Iterator begin, Iterator end) {\n  for (Iterator it = begin + 1; it != end; it++) {\n    iter_swap(begin + rand(0, it - begin), it);\n  }\n}\nusing namespace std;\nint n, k;\nint d[55];\nint w[55][55];\nvector<int> edges[55];\nDSUAE dsu;\nvector<pair<int, pair<int, int>>> vSort;\nint best = inf;\nint ch[55][55];\nint t[55];\nint s[55];\nint calc() {\n  int res = 0;\n  dsu.clear(n);\n  vSort.clear();\n  int cnt = n;\n  memset(t, 0, sizeof(t));\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      if (ch[i][j]) {\n        if (dsu.same(i, j)) return inf;\n        t[i]++;\n        t[j]++;\n        res += w[i][j];\n        dsu.merge(i, j);\n        cnt--;\n      } else {\n        vSort.push_back(make_pair(w[i][j], make_pair(i, j)));\n      }\n    }\n  }\n  sort(vSort.begin(), vSort.end());\n  for (auto &o : vSort) {\n    int w = o.first, x = o.second.first, y = o.second.second;\n    if (!dsu.same(x, y) && t[x] != d[x] && t[y] != d[y]) {\n      dsu.merge(x, y);\n      res += w;\n      cnt--;\n      t[x]++;\n      t[y]++;\n    }\n  }\n  return (cnt == 1 ? res : inf);\n}\nint main() {\n  cin >> n >> k;\n  memset(d, 0x3f, sizeof(d));\n  for (int i = 0; i < k; i++) {\n    cin >> d[i];\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      scanf(\"%d\", w[i] + j);\n      vSort.push_back(make_pair(w[i][j], make_pair(i, j)));\n    }\n  }\n  dsu.init(n);\n  vector<pair<int, int>> tmp;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      if (i < k) tmp.emplace_back(i, j);\n    }\n  }\n  int now = calc();\n  best = now;\n  for (double T = 1000; T >= 0.001; T *= 0.9993) {\n    int x, y;\n    while (true) {\n      pair<int, int> o = tmp[rand(0, tmp.size() - 1)];\n      x = o.first, y = o.second;\n      if (!ch[x][y] && (s[x] == d[x] || s[y] == d[y]))\n        continue;\n      else\n        break;\n    }\n    s[x] -= ch[x][y];\n    s[y] -= ch[x][y];\n    ch[x][y] ^= 1;\n    s[x] += ch[x][y];\n    s[y] += ch[x][y];\n    int delta = calc() - now;\n    if (exp(-(double)delta / T) >= (double)rand(0, 1000000000) / 1000000000) {\n      now += delta;\n      chmin(best, now);\n    } else {\n      s[x] -= ch[x][y];\n      s[y] -= ch[x][y];\n      ch[x][y] ^= 1;\n      s[x] += ch[x][y];\n      s[y] += ch[x][y];\n    }\n  }\n  cout << best << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint nw[52], d[52], sz[52][52], fa[52];\nint getv(int x) { return x == fa[x] ? x : fa[x] = getv(fa[x]); }\nbool merge(int x, int y) {\n  x = getv(x);\n  y = getv(y);\n  if (x == y) return false;\n  fa[x] = y;\n  return true;\n}\nint random(int n) {\n  int he = 0;\n  for (int i = 1; i <= n; i++) nw[i] = 0;\n  vector<pair<int, int> > ve;\n  for (int i = 1; i < n; i++) {\n    he += sz[i][n], nw[i] = 1;\n    ve.push_back(make_pair(i, n));\n  }\n  int ans = he;\n  nw[n] = n - 1;\n  double T = 100 * n;\n  while (T > 1e-5) {\n    int od = he, i = rand() % (n - 1);\n    int oa = ve[i].first, ob = ve[i].second;\n    nw[oa] -= 1;\n    nw[ob] -= 1;\n    he -= sz[oa][ob];\n    ve.erase(ve.begin() + i);\n    for (int i = 1; i <= n; i++) fa[i] = i;\n    for (int i = 0; i < n - 2; i++) merge(ve[i].first, ve[i].second);\n    int a, b;\n    while (1) {\n      a = rand() % (n - 1) + 1;\n      b = rand() % (n - a) + a + 1;\n      if (nw[a] < d[a] && nw[b] < d[b] && merge(a, b)) {\n        he += sz[a][b];\n        ve.push_back(make_pair(a, b));\n        nw[a] += 1;\n        nw[b] += 1;\n        break;\n      }\n    }\n    if (he < ans) ans = he;\n    if (he > od && rand() % 10000 >= exp((od - he) / T) * 1e4) {\n      he = od;\n      ve.pop_back();\n      ve.push_back(make_pair(oa, ob));\n      nw[a] -= 1;\n      nw[b] -= 1;\n      nw[oa] += 1;\n      nw[ob] += 1;\n    }\n    T *= 0.999995;\n  }\n  return ans;\n}\nint main() {\n  int n, k;\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i <= k; i++) scanf(\"%d\", &d[i]);\n  for (int i = k + 1; i <= n; i++) d[i] = 1e9;\n  for (int i = 1; i < n; i++) {\n    for (int j = i + 1; j <= n; j++) {\n      scanf(\"%d\", &sz[i][j]);\n      sz[j][i] = sz[i][j];\n    }\n  }\n  int ans = random(n);\n  printf(\"%d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int max_n = 55, inf = 1000111222;\nint copy_dsu[max_n];\nstruct dsu {\n  int p_or_sz[max_n];\n  void init(int n) {\n    for (int i = 0; i < n; ++i) {\n      p_or_sz[i] = -1;\n    }\n  }\n  void init_from_copy(int n) {\n    for (int i = 0; i < n; ++i) {\n      p_or_sz[i] = copy_dsu[i];\n    }\n  }\n  int find_set(int v) {\n    if (p_or_sz[v] < 0) {\n      return v;\n    }\n    return p_or_sz[v] = find_set(p_or_sz[v]);\n  }\n  bool union_set(int v1, int v2) {\n    v1 = find_set(v1);\n    v2 = find_set(v2);\n    if (v1 == v2) {\n      return false;\n    }\n    if (-p_or_sz[v1] > -p_or_sz[v2]) {\n      swap(v1, v2);\n    }\n    p_or_sz[v2] += p_or_sz[v1];\n    p_or_sz[v1] = v2;\n    return true;\n  }\n};\nint n, k, max_deg[max_n], D[max_n][max_n];\nint deg[max_n];\ndsu d;\nbool get_bit(int mask, int pos) { return (mask >> pos) & 1; }\nstruct GroundSetElement {\n  int u, v;\n  int cost;\n  bool taken;\n  GroundSetElement() {}\n  GroundSetElement(int u, int v, int cost)\n      : u(u), v(v), cost(cost), taken(false) {}\n  bool operator<(const GroundSetElement &g) const { return cost < g.cost; }\n};\nconst int max_e = max_n * max_n / 2;\nvector<GroundSetElement> elems;\nint cur_deg[max_n];\nint parent[max_e], weight[max_e];\npair<int, int> dist[max_e];\nvector<pair<int, int>> edges;\nbool is_s[max_e], is_t[max_e];\nvoid prepare() {\n  d.init_from_copy(n);\n  copy(deg, deg + n, cur_deg);\n  for (int i = 0; i < elems.size(); ++i) {\n    if (elems[i].taken) {\n      d.union_set(elems[i].u, elems[i].v);\n      --cur_deg[elems[i].u];\n      --cur_deg[elems[i].v];\n    }\n  }\n}\nbool is_ok1(const GroundSetElement &a) {\n  return d.find_set(a.u) != d.find_set(a.v);\n}\nbool is_ok2(const GroundSetElement &a) {\n  return cur_deg[a.u] > 0 && cur_deg[a.v] > 0;\n}\nbool augment() {\n  edges.clear();\n  prepare();\n  for (int i = 0; i < elems.size(); ++i) {\n    if (!elems[i].taken) {\n      is_s[i] = is_ok1(elems[i]);\n      is_t[i] = is_ok2(elems[i]);\n      weight[i] = -elems[i].cost;\n    } else {\n      is_s[i] = is_t[i] = false;\n      weight[i] = elems[i].cost;\n    }\n    weight[i] *= -1;\n  }\n  for (int i = 0; i < elems.size(); ++i) {\n    if (elems[i].taken) {\n      elems[i].taken = false;\n      prepare();\n      elems[i].taken = true;\n      for (int j = 0; j < elems.size(); ++j) {\n        if (!elems[j].taken) {\n          if (is_ok1(elems[j])) {\n            edges.push_back({i, j});\n          }\n          if (is_ok2(elems[j])) {\n            edges.push_back({j, i});\n          }\n        }\n      }\n    }\n  }\n  for (int i = 0; i < elems.size(); ++i) {\n    dist[i] = {inf, inf};\n    parent[i] = -1;\n    if (is_s[i]) {\n      dist[i] = {weight[i], 0};\n    }\n  }\n  for (bool change = true; change;) {\n    change = false;\n    for (const auto &edge : edges) {\n      pair<int, int> ndist = dist[edge.first];\n      if (ndist.first == inf) {\n        continue;\n      }\n      ndist.first += weight[edge.second];\n      ++ndist.second;\n      if (dist[edge.second] > ndist) {\n        dist[edge.second] = ndist;\n        parent[edge.second] = edge.first;\n        change = true;\n      }\n    }\n  }\n  int t = -1;\n  for (int i = 0; i < elems.size(); ++i) {\n    if (is_t[i] && (t == -1 || dist[t] > dist[i])) {\n      t = i;\n    }\n  }\n  if (t == -1 || dist[t].first == inf) {\n    return false;\n  }\n  while (t != -1) {\n    elems[t].taken ^= 1;\n    t = parent[t];\n  }\n  return true;\n}\nint ans = inf;\nint solve(int need_e, int cost) {\n  for (int i = 0; i < n; ++i) {\n    copy_dsu[i] = d.p_or_sz[i];\n  }\n  for (int i = 0; i < elems.size(); ++i) {\n    elems[i].taken = false;\n  }\n  int it = 0;\n  while (augment()) {\n    ++it;\n    int res = cost;\n    for (int i = 0; i < elems.size(); ++i) {\n      if (elems[i].taken) {\n        res += elems[i].cost;\n      }\n    }\n  }\n  if (it != need_e) {\n    return -1;\n  }\n  int res = cost;\n  for (int i = 0; i < elems.size(); ++i) {\n    if (elems[i].taken) {\n      res += elems[i].cost;\n    }\n  }\n  return res;\n}\ndouble start = clock();\nbool is_tl() { return (clock() - start) / CLOCKS_PER_SEC > 5.5; }\nint main() {\n  if (0) {\n    n = 50;\n    k = 5;\n    for (int i = 0; i < k; ++i) {\n      max_deg[i] = inf;\n    }\n    for (int i = 0; i < n; ++i) {\n      for (int j = i + 1; j < n; ++j) {\n        D[i][j] = rand() % 100 + 1;\n      }\n    }\n  } else {\n    cin >> n >> k;\n    for (int i = 0; i < k; ++i) {\n      cin >> max_deg[i];\n    }\n    for (int i = 0; i < n; ++i) {\n      for (int j = i + 1; j < n; ++j) {\n        cin >> D[i][j];\n      }\n    }\n  }\n  for (int i = k; i < n; ++i) {\n    for (int j = i + 1; j < n; ++j) {\n      elems.push_back({i, j, D[i][j]});\n    }\n  }\n  sort(elems.begin(), elems.end());\n  vector<GroundSetElement> ok_elems;\n  d.init(n);\n  for (auto elem : elems) {\n    if (d.union_set(elem.u, elem.v)) {\n      ok_elems.push_back(elem);\n    }\n  }\n  elems.swap(ok_elems);\n  for (int i = 0; i < k; ++i) {\n    for (int j = k; j < n; ++j) {\n      elems.push_back({i, j, D[i][j]});\n    }\n  }\n  sort(elems.begin(), elems.end());\n  int small_e = (k * (k - 1)) / 2;\n  int TOT = 0;\n  vector<int> all_masks;\n  for (int mask = 0; mask < (1 << small_e); ++mask) {\n    all_masks.push_back(mask);\n  }\n  const int seed = chrono::steady_clock::now().time_since_epoch().count();\n  mt19937 generator(seed);\n  shuffle(all_masks.begin(), all_masks.end(), generator);\n  for (int mask : all_masks) {\n    if (is_tl()) {\n      cout << ans << \"\\n\";\n      return 0;\n    }\n    d.init(n);\n    copy(max_deg, max_deg + k, deg);\n    fill(deg + k, deg + n, inf);\n    int num = 0, cost = 0;\n    bool ok = 1;\n    int need_e = n - 1;\n    for (int i = 0; i < k && ok; ++i) {\n      for (int j = i + 1; j < k && ok; ++j) {\n        if (get_bit(mask, num)) {\n          if (!d.union_set(i, j) || !deg[i] || !deg[j]) {\n            ok = 0;\n            break;\n          }\n          --deg[i];\n          --deg[j];\n          cost += D[i][j];\n          --need_e;\n        }\n        ++num;\n      }\n    }\n    if (!ok) {\n      continue;\n    }\n    ++TOT;\n    int res = solve(need_e, cost);\n    if (res == -1) {\n      continue;\n    }\n    ans = min(ans, res);\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  char ch = getchar();\n  int nega = 1;\n  while (!isdigit(ch)) {\n    if (ch == '-') nega = -1;\n    ch = getchar();\n  }\n  int ans = 0;\n  while (isdigit(ch)) {\n    ans = ans * 10 + ch - 48;\n    ch = getchar();\n  }\n  if (nega == -1) return -ans;\n  return ans;\n}\nvoid print(vector<int> x) {\n  for (int i = 0; i < (int)x.size(); i++)\n    printf(\"%d%c\", x[i], \" \\n\"[i == (int)x.size() - 1]);\n}\nint d[55], used[55], e[55][55], w[55][55], n, k;\nint vis[55][55];\nint getid(int x, int y) { return (x - 1) * n + y; }\nvector<pair<int, int> > G[55 * 55];\nint dis[55 * 55], eg[55 * 55], fr[55 * 55], inq[55 * 55], q[55 * 55 * 55],\n    ok[55][55], ql, qr;\nint fa[55];\nint find(int u) { return fa[u] == u ? u : fa[u] = find(fa[u]); }\nint append() {\n  for (int i = 1; i <= n * n + 2; i++) G[i].clear(), dis[i] = 0x3f3f3f3f;\n  int s = n * n + 1, t = n * n + 2;\n  dis[s] = 0;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) {\n      if (!vis[i][j]) continue;\n      if (ok[i][j]) continue;\n      vis[i][j] = 0;\n      for (int c = 1; c <= n; c++) fa[c] = c;\n      for (int k = 1; k <= n; k++)\n        for (int c = k + 1; c <= n; c++)\n          if (vis[k][c]) fa[find(k)] = find(c);\n      vis[i][j] = 1;\n      for (int k = 1; k <= n; k++)\n        for (int c = k + 1; c <= n; c++)\n          if (!vis[k][c] && !ok[k][c]) {\n            if (find(k) != find(c))\n              G[getid(i, j)].emplace_back(getid(k, c), w[k][c]);\n          }\n    }\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) {\n      if (!vis[i][j]) continue;\n      if (ok[i][j]) continue;\n      used[i]--, used[j]--;\n      for (int k = 1; k <= n; k++)\n        for (int c = k + 1; c <= n; c++)\n          if (!vis[k][c] && !ok[k][c]) {\n            if (used[k] < d[k] && used[c] < d[c])\n              G[getid(k, c)].emplace_back(getid(i, j), -w[i][j]);\n          }\n      used[i]++, used[j]++;\n    }\n  for (int i = 1; i <= n; i++) fa[i] = i;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++)\n      if (vis[i][j]) fa[find(i)] = find(j);\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++)\n      if (!vis[i][j] && !ok[i][j]) {\n        if (find(i) != find(j)) G[s].emplace_back(getid(i, j), w[i][j]);\n      }\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++)\n      if (!vis[i][j] && !ok[i][j]) {\n        if (used[i] < d[i] && used[j] < d[j]) G[getid(i, j)].emplace_back(t, 0);\n      }\n  ql = qr = 1, q[1] = s, eg[s] = 0;\n  while (ql <= qr) {\n    int u = q[ql++];\n    inq[u] = 0;\n    for (auto [v, w] : G[u]) {\n      if (dis[v] > dis[u] + w) {\n        dis[v] = dis[u] + w;\n        fr[v] = u;\n        if (!inq[v]) inq[v] = 1, q[++qr] = v;\n      }\n    }\n  }\n  int tmp = t;\n  while (tmp != s) {\n    tmp = fr[tmp];\n    if (tmp == s) break;\n    int i = (tmp - 1) / n + 1, j = tmp - (i - 1) * n;\n    if (vis[i][j])\n      used[i]--, used[j]--;\n    else\n      used[i]++, used[j]++;\n    vis[i][j] ^= 1;\n  }\n  return dis[t];\n}\nint tu[55], tv[55];\nsigned main() {\n  cin >> n >> k;\n  for (int i = 1; i <= k; i++) d[i] = read();\n  for (int i = k + 1; i <= n; i++) d[i] = n;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) e[i][j] = w[i][j] = read();\n  int ans = 0x3f3f3f3f, cnt = 0;\n  for (int i = 1; i <= k; i++)\n    for (int j = i + 1; j <= k; j++)\n      tu[cnt] = i, tv[cnt++] = j, w[i][j] = 10000, ok[i][j] = 1;\n  for (int i = 0; i < 1 << (k * (k - 1) / 2); i++) {\n    for (int j = 1; j <= k; j++) fa[j] = j;\n    int ok = 1;\n    int res = 0;\n    for (int j = 0; j < k * (k - 1) / 2; j++) {\n      if (i >> j & 1) {\n        int u = tu[j], v = tv[j];\n        if (find(u) == find(v)) ok = 0;\n        fa[find(u)] = find(v);\n        res += e[u][v];\n      }\n    }\n    if (!ok) continue;\n    memset(vis, 0, sizeof(vis)), memset(used, 0, sizeof(used));\n    int pop = 0;\n    for (int j = 0; j < k * (k - 1) / 2; j++) {\n      if (i >> j & 1) {\n        int u = tu[j], v = tv[j];\n        vis[u][v] = 1, used[u]++, used[v]++;\n        pop++;\n      }\n    }\n    for (int j = 1; j <= k; j++)\n      if (used[j] > d[j]) ok = 0;\n    if (!ok) continue;\n    for (int i = pop + 1; i < n; i++) {\n      res += append();\n    }\n    ans = min(ans, res);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 55, maxm = 1250, inf = 2e9;\nint n, K, m, N, D[maxn], w[maxn][maxn], id[maxn][maxn], wei[maxm];\nint C[maxn], fa[maxn], dis[maxm], ce[maxm], pre[maxm];\nint dd[maxm][2], ans = inf;\nbool in[maxn][maxn], inq[maxm];\npair<int, int> E[maxn], F[maxn];\nvector<int> G[maxm];\nint find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\nvoid brute(int x, int y) {\n  if (x > K) {\n    for (int i = int(1); i <= int(K); i++) fa[i] = i;\n    for (int i = int(1); i <= int(K); i++) C[i] = 0;\n    for (int i = int(1); i <= int(m); i++) {\n      int x = E[i].first;\n      int y = E[i].second;\n      if (++C[x] > D[x]) return;\n      if (++C[y] > D[y]) return;\n      x = find(x);\n      y = find(y);\n      if (x == y) return;\n      fa[x] = y;\n    }\n    memset(in, 0, sizeof(in));\n    int s = 0;\n    for (int i = int(1); i <= int(m); i++) s += w[E[i].first][E[i].second];\n    while (1) {\n      if (s >= ans) return;\n      int r = 0;\n      for (int i = int(1); i <= int(m); i++) F[i] = E[i];\n      for (int i = int(1); i <= int(n); i++)\n        for (int j = int(max(K, i) + 1); j <= int(n); j++)\n          if (in[i][j]) F[(++r) + m] = {i, j};\n      for (int i = int(1); i <= int(N); i++) G[i].clear();\n      for (int i = int(m + 1); i <= int(m + r); i++) {\n        iota(fa + 1, fa + n + 1, 1);\n        fill(C + 1, C + n + 1, 0);\n        for (int j = int(1); j <= int(m + r); j++)\n          if (j != i) {\n            int x = F[j].first, y = F[j].second;\n            C[x]++, C[y]++, fa[find(x)] = find(y);\n          }\n        int I = id[F[i].first][F[i].second];\n        wei[I] = -w[F[i].first][F[i].second];\n        for (int i = int(1); i <= int(n); i++)\n          for (int j = int(max(K, i) + 1); j <= int(n); j++)\n            if (!in[i][j]) {\n              if (C[i] < D[i]) G[id[i][j]].push_back(I);\n              if (find(i) != find(j)) G[I].push_back(id[i][j]);\n            }\n      }\n      for (int i = int(1); i <= int(n); i++)\n        for (int j = int(max(K, i) + 1); j <= int(n); j++)\n          if (!in[i][j]) {\n            wei[id[i][j]] = w[i][j];\n          }\n      iota(fa + 1, fa + n + 1, 1);\n      fill(C + 1, C + n + 1, 0);\n      for (int i = int(1); i <= int(m + r); i++) {\n        int x = F[i].first, y = F[i].second;\n        C[x]++, C[y]++, fa[find(x)] = find(y);\n      }\n      for (int i = int(1); i <= int(N); i++)\n        dis[i] = inf, ce[i] = 0, pre[i] = 0;\n      queue<int> Q;\n      for (int i = int(1); i <= int(n); i++)\n        for (int j = int(max(K, i) + 1); j <= int(n); j++)\n          if (!in[i][j]) {\n            if (find(i) != find(j)) {\n              dis[id[i][j]] = w[i][j], Q.push(id[i][j]), inq[id[i][j]] = 1;\n            }\n          }\n      while (!Q.empty()) {\n        int u = Q.front();\n        Q.pop();\n        for (int v : G[u])\n          if (dis[v] > dis[u] + wei[v] ||\n              (dis[v] == dis[u] + wei[v] && ce[v] > ce[u] + 1)) {\n            pre[v] = u, dis[v] = dis[u] + wei[v], ce[v] = ce[u] + 1;\n            if (!inq[v]) Q.push(v);\n          }\n        inq[u] = 0;\n      }\n      int _dis = inf, _ce = 0, x = 0;\n      for (int i = int(1); i <= int(n); i++)\n        for (int j = int(max(K, i) + 1); j <= int(n); j++)\n          if (!in[i][j]) {\n            if (C[i] < D[i] &&\n                (_dis > dis[id[i][j]] ||\n                 (_dis == dis[id[i][j]] && _ce > ce[id[i][j]]))) {\n              x = id[i][j], _dis = dis[id[i][j]], _ce = ce[id[i][j]];\n            }\n          }\n      if (!x) {\n        if (m + r == n - 1) {\n          ans = s;\n        }\n        return;\n      }\n      while (x) {\n        in[dd[x][0]][dd[x][1]] ^= 1;\n        s += wei[x];\n        x = pre[x];\n      }\n    }\n  }\n  if (y > K) {\n    brute(x + 1, x + 2);\n    return;\n  }\n  brute(x, y + 1);\n  E[++m] = {x, y}, brute(x, y + 1), --m;\n}\nint main() {\n  scanf(\"%d %d\", &n, &K);\n  for (int i = int(1); i <= int(K); i++) {\n    scanf(\"%d\", &D[i]);\n  }\n  for (int i = int(K + 1); i <= int(n); i++) D[i] = n;\n  for (int i = int(1); i <= int(n); i++)\n    for (int j = int(i + 1); j <= int(n); j++) {\n      id[i][j] = ++N;\n      dd[N][0] = i, dd[N][1] = j;\n      scanf(\"%d\", &w[i][j]);\n    }\n  brute(1, 2);\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <typename T>\nbool chkmax(T &x, T y) {\n  return x < y ? x = y, true : false;\n}\ntemplate <typename T>\nbool chkmin(T &x, T y) {\n  return x > y ? x = y, true : false;\n}\nusing namespace std;\nlong long ksm(long long a, long long b) {\n  if (!b) return 1;\n  long long ns = ksm(a, b >> 1);\n  ns = ns * ns % 1000000007;\n  if (b & 1) ns = ns * a % 1000000007;\n  return ns;\n}\nint n, m, k, N, deg[55], d[55][55], par[55];\nvector<array<int, 3>> E, e, e2;\nint findPar(int x) {\n  if (par[x] == x)\n    return x;\n  else\n    return par[x] = findPar(par[x]);\n}\nint matroid_intersection(int n, vector<array<int, 3>> w,\n                         vector<array<int, 3>> w2) {\n  vector<bool> used(n);\n  for (auto &x : w) x[0] = -x[0];\n  for (auto &x : w2) x[0] = -x[0];\n  int m = w2.size();\n  auto find_path = [&]() {\n    vector<vector<int>> g(n + 2);\n    for (int j = 0; j < n; ++j)\n      if (used[j]) {\n        vector<int> cdeg(N, 0);\n        used[j] = false;\n        for (int i = 0; i < N; i++) par[i] = i;\n        for (int i = 0; i < n; i++)\n          if (used[i]) {\n            int u = w[i][1], v = w[i][2];\n            cdeg[u]++, cdeg[v]++;\n            par[findPar(u)] = findPar(v);\n          }\n        for (int i = 0; i < m; i++) {\n          int u = w2[i][1], v = w2[i][2];\n          cdeg[u]++, cdeg[v]++;\n          par[findPar(u)] = findPar(v);\n        }\n        for (int i = 0; i < n; ++i)\n          if (!used[i] && i != j) {\n            int u = w[i][1], v = w[i][2];\n            cdeg[u] += 1;\n            cdeg[v] += 1;\n            bool w = true;\n            for (int r = 0; r < k; r++) w &= cdeg[r] <= deg[r];\n            cdeg[u] -= 1;\n            cdeg[v] -= 1;\n            if (w) g[i].push_back(j);\n            if (findPar(u) != findPar(v)) g[j].push_back(i);\n          }\n        used[j] = true;\n      }\n    vector<int> cdeg(N, 0);\n    for (int i = 0; i < N; i++) par[i] = i;\n    for (int i = 0; i < n; i++)\n      if (used[i]) {\n        int u = w[i][1], v = w[i][2];\n        cdeg[u]++, cdeg[v]++;\n        par[findPar(u)] = findPar(v);\n      }\n    for (int i = 0; i < m; i++) {\n      int u = w2[i][1], v = w2[i][2];\n      cdeg[u]++, cdeg[v]++;\n      par[findPar(u)] = findPar(v);\n    }\n    for (int i = 0; i < n; ++i)\n      if (!used[i]) {\n        int u = w[i][1], v = w[i][2];\n        cdeg[u] += 1;\n        cdeg[v] += 1;\n        bool w = true;\n        for (int r = 0; r < k; r++) w &= cdeg[r] <= deg[r];\n        cdeg[u] -= 1;\n        cdeg[v] -= 1;\n        if (w) g[i].push_back(n + 1);\n        if (findPar(u) != findPar(v)) g[n].push_back(i);\n      }\n    const int INF = 1 << 29;\n    vector<int> dist(n + 2, INF);\n    vector<bool> vis(n + 2);\n    vector<int> pre(n + 2, -1);\n    queue<int> q;\n    dist[n] = 0;\n    q.push(n);\n    while (!q.empty()) {\n      int x = q.front();\n      q.pop();\n      vis[x] = false;\n      for (int y : g[x]) {\n        int cost = 0;\n        if (y < n) cost = used[y] ? w[y][0] : -w[y][0];\n        if (dist[y] > dist[x] + cost) {\n          dist[y] = dist[x] + cost;\n          pre[y] = x;\n          if (!vis[y]) vis[y] = true, q.push(y);\n        }\n      }\n    }\n    if (dist[n + 1] == INF) return false;\n    for (int i = pre[n + 1]; i != n; i = pre[i]) {\n      used[i] = !used[i];\n    }\n    return true;\n  };\n  int z = 0;\n  while (find_path()) ++z;\n  int res = 0;\n  for (int i = 0; i < n; ++i)\n    if (used[i]) res += w[i][0];\n  for (auto x : w2) res += x[0], z += 1;\n  if (z != N - 1) return -(1 << 29);\n  return res;\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  N = n;\n  for (int i = 0; i < k; i++) {\n    scanf(\"%d\", deg + i);\n  }\n  for (int i = 0; i < n; i++)\n    for (int j = i + 1; j < n; j++) {\n      scanf(\"%d\", &d[i][j]);\n      if (j < k) {\n        e2.push_back({d[i][j], i, j});\n      } else if (i < k && j >= k)\n        e.push_back({d[i][j], i, j});\n      else {\n        E.push_back({d[i][j], i, j});\n      }\n    }\n  sort(E.begin(), E.end());\n  for (int i = 0; i < n; i++) {\n    par[i] = i;\n  }\n  for (auto x : E) {\n    int u = x[1], v = x[2];\n    if (findPar(u) != findPar(v)) {\n      par[findPar(v)] = findPar(u);\n      e.push_back(x);\n    }\n  }\n  int ans = 1 << 29;\n  int m = e2.size();\n  for (int s = 0; s < (1 << m); s++) {\n    for (int i = 0; i < k; i++) {\n      par[i] = i;\n    }\n    bool ww = true;\n    vector<array<int, 3>> e3;\n    int d = 0;\n    for (int j = 0; j < m; j++)\n      if (s & (1 << j)) {\n        int u = e2[j][1], v = e2[j][2];\n        if (findPar(u) == findPar(v)) {\n          ww = false;\n          break;\n        }\n        e3.push_back(e2[j]);\n        par[findPar(v)] = findPar(u);\n      }\n    if (!ww) continue;\n    int w = -matroid_intersection(e.size(), e, e3);\n    if (w >= (1 << 29)) continue;\n    ans = min(ans, w);\n  }\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 0x3f3f3f3f3f3f3f3f;\nconst int mo = 998244353;\nconst int inv2 = 499122177;\nconst double jzm = 0.9995;\nconst int zero = 5000;\nconst int orG = 3, invG = 332748118;\nconst double Pi = acos(-1.0);\nconst double eps = 1e-3;\ntemplate <typename _T>\n_T Fabs(_T x) {\n  return x < 0 ? -x : x;\n}\ntemplate <typename _T>\nvoid read(_T &x) {\n  _T f = 1;\n  x = 0;\n  char s = getchar();\n  while (s > '9' || s < '0') {\n    if (s == '-') f = -1;\n    s = getchar();\n  }\n  while ('0' <= s && s <= '9') {\n    x = (x << 3) + (x << 1) + (s ^ 48);\n    s = getchar();\n  }\n  x *= f;\n}\ntemplate <typename _T>\nvoid print(_T x) {\n  if (x < 0) {\n    x = (~x) + 1;\n    putchar('-');\n  }\n  if (x > 9) print(x / 10);\n  putchar(x % 10 + '0');\n}\nlong long gcd(long long a, long long b) { return !b ? a : gcd(b, a % b); }\nint add(int x, int y, int p) { return x + y < p ? x + y : x + y - p; }\nvoid Add(int &x, int y, int p) { x = add(x, y, p); }\nint qkpow(int a, int s, int p) {\n  int t = 1;\n  while (s) {\n    if (s & 1LL) t = 1ll * a * t % p;\n    a = 1ll * a * a % p;\n    s >>= 1LL;\n  }\n  return t;\n}\nint n, k, d[55], mp[55][55], t[55], fa[55], tota, totb, deg[55], summ, ans,\n    ord[55][55], sta[55], stak;\nbool cho[55][55], tmp[55][55], ap[55][55], fg[55];\nstruct edge {\n  int u, v, w;\n} a[2505], b[2505];\nbool cmp(edge x, edge y) { return x.w < y.w; }\nbool cmp1(int x, int y) { return t[x] < t[y]; }\ndouble Rand() {\n  return 1.0 * (rand() * RAND_MAX + rand()) / (RAND_MAX * RAND_MAX);\n}\nvoid makeSet(int x) {\n  for (int i = 1; i <= x; i++) fa[i] = i;\n}\nint findSet(int x) { return fa[x] == x ? x : fa[x] = findSet(fa[x]); }\nvoid unionSet(int a, int b) {\n  int u = findSet(a), v = findSet(b);\n  if (u != v) fa[u] = v;\n}\nvoid work(int x) {\n  for (int i = 1; i <= n; i++) {\n    if (ord[x][i] <= k && !fg[findSet(ord[x][i])]) continue;\n    if (ord[x][i] <= k && deg[ord[x][i]] == d[ord[x][i]]) continue;\n    unionSet(ord[x][i], x);\n    tmp[min(ord[x][i], x)][max(ord[x][i], x)] = 1;\n    deg[ord[x][i]]++;\n    deg[x]++;\n    break;\n  }\n}\nvoid sakura(double tp) {\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= n; j++) tmp[i][j] = 0;\n  for (int i = 1; i <= n; i++) deg[i] = fg[i] = 0;\n  summ = 0;\n  makeSet(n);\n  int tim = 0;\n  for (int i = 1; i <= tota; i++) {\n    int u = a[i].u, v = a[i].v, w = a[i].w;\n    if (!cho[u][v]) continue;\n    if (Rand() < tp) {\n      tmp[u][v] = 0;\n      continue;\n    }\n    tmp[u][v] = 1;\n    deg[u]++;\n    deg[v]++;\n    unionSet(u, v);\n    tim++;\n  }\n  random_shuffle(a + 1, a + tota + 1);\n  for (int i = 1; i <= tota; i++) {\n    int u = a[i].u, v = a[i].v, w = a[i].w;\n    if (tmp[u][v] || findSet(u) == findSet(v)) continue;\n    if (Rand() > tp || deg[u] == d[u] || deg[v] == d[v]) continue;\n    tmp[u][v] = 1;\n    deg[u]++;\n    deg[v]++;\n    unionSet(u, v);\n    tim++;\n  }\n  for (int i = k + 1; i <= n; i++) fg[findSet(i)] = 1;\n  tim = 0;\n  for (int i = 1; i <= k; i++) {\n    if (fg[findSet(i)]) continue;\n    int p = findSet(i), spc = 0;\n    for (int j = 1; j <= k; j++)\n      if (findSet(j) == p && deg[j] < d[j]) spc = j;\n    if (!spc) {\n      stak = 0;\n      for (int j = 1; j <= k; j++)\n        if (findSet(j) == p) sta[++stak] = j;\n      for (int j = 1; j <= stak; j++) {\n        int u = sta[j];\n        fa[u] = u;\n        deg[u] = 0;\n        for (int l = 1; l <= k; l++) tmp[l][u] = tmp[u][l] = 0;\n      }\n      for (int j = 1; j <= stak; j++) work(sta[j]), fg[findSet(sta[j])] = 1;\n    } else\n      work(spc), fg[findSet(spc)] = 1;\n  }\n  for (int i = 1; i <= totb; i++)\n    if (findSet(b[i].u) != findSet(b[i].v))\n      unionSet(b[i].u, b[i].v), deg[b[i].u]++, deg[b[i].v]++,\n          tmp[b[i].u][b[i].v] = 1;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++)\n      if (tmp[i][j]) summ += mp[i][j], tim++;\n}\nvoid nagisa() {\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) cho[i][j] = ap[i][j];\n  summ = 0;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++)\n      if (cho[i][j]) summ += mp[i][j];\n  for (int t = 1; t <= 500; t++) {\n    int now = summ;\n    sakura(0.5);\n    if (summ < now)\n      for (int i = 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++) cho[i][j] = tmp[i][j];\n    else\n      summ = now;\n  }\n  if (ans > summ) {\n    for (int i = 1; i <= n; i++)\n      for (int j = i + 1; j <= n; j++) ap[i][j] = cho[i][j];\n    ans = summ;\n  }\n  double nowT = 5000.0;\n  while (nowT > eps) {\n    int now = summ;\n    sakura(nowT);\n    double t = Rand();\n    if (ans > summ) {\n      for (int i = 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++) ap[i][j] = cho[i][j] = tmp[i][j];\n      ans = summ;\n    } else if (exp(1.0 * (now - summ) / nowT) > t)\n      for (int i = 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++) cho[i][j] = tmp[i][j];\n    else\n      summ = now;\n    nowT *= jzm;\n  }\n}\nsigned main() {\n  srand(time(NULL));\n  read(n);\n  read(k);\n  for (int i = 1; i <= k; i++) read(d[i]);\n  for (int i = k + 1; i <= n; i++) d[i] = n;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) {\n      read(mp[i][j]), mp[j][i] = mp[i][j];\n      if (i <= k)\n        a[++tota] = (edge){i, j, mp[i][j]};\n      else\n        b[++totb] = (edge){i, j, mp[i][j]};\n    }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) t[j] = mp[i][j];\n    for (int j = 1; j <= n; j++) ord[i][j] = j;\n    sort(ord[i] + 1, ord[i] + n + 1, cmp1);\n  }\n  sort(b + 1, b + totb + 1, cmp);\n  sakura(1.0);\n  ans = summ;\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++) ap[i][j] = cho[i][j] = tmp[i][j];\n  for (int i = 1; i <= 3; i++) nagisa();\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint read() {\n  int ret = 0;\n  char c = getchar();\n  while (c > '9' || c < '0') c = getchar();\n  while (c >= '0' && c <= '9')\n    ret = (ret << 3) + (ret << 1) + (c ^ 48), c = getchar();\n  return ret;\n}\nconst int maxn = 55;\nconst int maxk = 6;\nconst int maxm = 2500;\nconst int inf = 1e9;\nint n, k;\nint dlim[maxk];\nstruct edge {\n  int from, to, val;\n} e1[15], e2[maxm];\nint cnt1, cnt2;\nint ans;\nint d[maxk];\nbool ini[maxm], x[maxm], y[maxm];\nint dis[maxm], pre[maxm];\nstruct dsu {\n  int fa[maxn];\n  void prework() {\n    for (int i = 1; i <= n; i++) fa[i] = i;\n  }\n  int get(int x) { return x == fa[x] ? x : fa[x] = get(fa[x]); }\n  void merge(int x, int y) { fa[get(x)] = get(y); }\n  bool check(int x, int y) { return get(x) == get(y); }\n} S;\nqueue<int> q;\nbool inq[maxm];\nint ret = 0;\nbool deb = 0;\nstruct graph {\n  int head[maxm], ver[maxm * maxm], nxt[maxm * maxm], val[maxm * maxm], tot;\n  void add(int x, int y, int z) {\n    ver[++tot] = y;\n    val[tot] = z;\n    nxt[tot] = head[x];\n    head[x] = tot;\n  }\n  void clear() {\n    tot = 0;\n    for (int i = 1; i <= cnt2 + 2; i++) head[i] = 0;\n  }\n  int dis[maxm], pre[maxm], len[maxm];\n  bool inq[maxm];\n  void spfa() {\n    for (int i = 1; i <= cnt2 + 2; i++)\n      dis[i] = 0x3f3f3f3f, inq[i] = 0, pre[i] = 0;\n    dis[cnt2 + 1] = 0;\n    q.push(cnt2 + 1);\n    inq[cnt2 + 1] = 1;\n    while (!q.empty()) {\n      int now = q.front();\n      q.pop();\n      inq[now] = 0;\n      for (int i = head[now]; i; i = nxt[i])\n        if (dis[ver[i]] > dis[now] + val[i] ||\n            (dis[ver[i]] == dis[now] + val[i] && len[ver[i]] > len[now] + 1)) {\n          dis[ver[i]] = dis[now] + val[i];\n          len[ver[i]] = len[now] + 1;\n          pre[ver[i]] = now;\n          if (!inq[ver[i]]) q.push(ver[i]);\n          inq[ver[i]] = 1;\n        }\n    }\n  }\n  void update() {\n    int now = cnt2 + 2;\n    while (now) {\n      ini[now] ^= 1;\n      if (ini[now])\n        ret -= e2[now].val;\n      else\n        ret += e2[now].val;\n      now = pre[now];\n    }\n  }\n} o;\nbool calc(int chose) {\n  for (int i = 1; i <= k; i++) d[i] = 0;\n  S.prework();\n  for (int i = 1; i <= cnt1; i++)\n    if ((chose >> (i - 1)) & 1) {\n      d[e1[i].from]++, d[e1[i].to]++;\n      S.merge(e1[i].from, e1[i].to);\n    }\n  for (int i = 1; i <= cnt2; i++)\n    if (ini[i]) {\n      if (e2[i].from <= k) d[e2[i].from]++;\n      S.merge(e2[i].from, e2[i].to);\n    }\n  int s = cnt2 + 1, t = cnt2 + 2;\n  o.clear();\n  for (int i = 1; i <= cnt2; i++) {\n    if (ini[i])\n      x[i] = y[i] = 0;\n    else {\n      x[i] = (!S.check(e2[i].from, e2[i].to));\n      y[i] = (e2[i].from > k || d[e2[i].from] + 1 <= dlim[e2[i].from]);\n      if (x[i]) o.add(s, i, e2[i].val);\n      if (y[i]) o.add(i, t, 0);\n    }\n  }\n  for (int i = 1; i <= cnt2; i++) {\n    if (!ini[i]) continue;\n    S.prework();\n    for (int j = 1; j <= cnt2; j++)\n      if (ini[j] && j != i) S.merge(e2[j].from, e2[j].to);\n    for (int i = 1; i <= cnt1; i++)\n      if ((chose >> (i - 1)) & 1) S.merge(e1[i].from, e1[i].to);\n    for (int j = 1; j <= cnt2; j++) {\n      if (ini[j]) continue;\n      if (!S.check(e2[j].from, e2[j].to)) o.add(i, j, e2[j].val);\n      if (e2[j].from > k ||\n          d[e2[j].from] - (e2[j].from == e2[i].from) < dlim[e2[j].from])\n        o.add(j, i, -e2[i].val);\n    }\n  }\n  o.spfa();\n  assert(o.dis[t] >= 0);\n  if (o.dis[t] == 0x3f3f3f3f) return false;\n  o.update();\n  return true;\n}\nvoid solve(int chose) {\n  for (int i = 1; i <= k; i++) d[i] = 0;\n  S.prework();\n  ret = 0;\n  for (int i = 1; i <= cnt1; i++)\n    if ((chose >> (i - 1)) & 1) {\n      d[e1[i].from]++;\n      d[e1[i].to]++;\n      ret += e1[i].val;\n      if (d[e1[i].from] > dlim[e1[i].from]) return;\n      if (d[e1[i].to] > dlim[e1[i].to]) return;\n      if (S.check(e1[i].from, e1[i].to)) return;\n      S.merge(e1[i].from, e1[i].to);\n    }\n  for (int i = 1; i <= cnt2; i++) ini[i] = 0;\n  int cnt = 0;\n  if (ret > ans) return;\n  while (calc(chose))\n    if (ret > ans) return;\n  ret = 0;\n  S.prework();\n  for (int i = 1; i <= cnt1; i++)\n    if ((chose >> (i - 1)) & 1) S.merge(e1[i].from, e1[i].to), ret += e1[i].val;\n  for (int i = 1; i <= cnt2; i++)\n    if (ini[i]) S.merge(e2[i].from, e2[i].to), ret += e2[i].val;\n  for (int i = 1; i <= n; i++)\n    if (!S.check(1, i)) return;\n  ans = min(ret, ans);\n}\nint main() {\n  n = read();\n  k = read();\n  for (int i = 1; i <= k; i++) dlim[i] = read();\n  for (int i = 1; i <= n - 1; i++)\n    for (int j = 1; j <= n - i; j++)\n      if (i <= k && i + j <= k) {\n        cnt1++;\n        e1[cnt1].from = i;\n        e1[cnt1].to = i + j;\n        e1[cnt1].val = read();\n      } else {\n        cnt2++;\n        e2[cnt2].from = i;\n        e2[cnt2].to = i + j;\n        e2[cnt2].val = read();\n      }\n  ans = inf;\n  for (int i = 0; i < (1 << cnt1); i++) solve(i);\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, d[55], G[55][55];\nint bas[55][55], fa[55], las[55], fucked[55][55];\nint ans = 1e9;\nint GF(int x) { return x == fa[x] ? x : fa[x] = GF(fa[x]); }\nnamespace nz {\nvector<int> G[3030];\nint st = 3001, en = 3002, val[3030];\nvoid init() {\n  for (int i = 0; i <= en; ++i) G[i].clear();\n}\nvoid adde(int x, int y) { G[x].push_back(y); }\nint d[3030], in[3030], pre[3030];\nint fuck() {\n  memset(d, 33, sizeof d);\n  memset(in, 0, sizeof in);\n  memset(pre, 0, sizeof pre);\n  d[st] = 0;\n  queue<int> q;\n  q.push(st);\n  for (int tim = 0; q.size();) {\n    int x = q.front();\n    q.pop();\n    in[x] = 0;\n    for (auto y : G[x]) {\n      int z = d[x] + val[y];\n      if (z < d[y]) {\n        d[y] = z;\n        pre[y] = x;\n        if (!in[y]) q.push(y), in[y] = 1;\n      }\n    }\n  }\n  int sum = 0;\n  for (int p = en; p; p = pre[p]) {\n    if (p != st && p != en) {\n      int i = (p - 1) / n, j = (p - 1) % n + 1;\n      bas[i][j] ^= 1;\n    }\n    sum += val[p];\n  }\n  return d[en];\n}\n}  // namespace nz\nint ID(int i, int j) { return i * n + j; }\nint ID(pair<int, int> p) { return ID(p.first, p.second); }\nvoid supermain() {\n  for (int i = 1; i <= k; ++i) fa[i] = i, las[i] = d[i];\n  int nowsum = 0, aim = n - 1;\n  for (int i = 1; i <= k; ++i)\n    for (int j = i + 1; j <= k; ++j)\n      if (bas[i][j]) {\n        nowsum += G[i][j];\n        if (GF(i) == GF(j)) return;\n        fa[GF(i)] = GF(j);\n        --las[i];\n        --las[j];\n        --aim;\n        if (las[i] < 0 || las[j] < 0) return;\n      }\n  for (; aim--;) {\n    nz::init();\n    for (int i = 1; i <= n; ++i) fa[i] = i, las[i] = d[i];\n    vector<pair<int, int> > vec, vecall;\n    for (int i = 1; i <= n; ++i)\n      for (int j = i + 1; j <= n; ++j)\n        if (bas[i][j]) {\n          if (i <= k) --las[i];\n          if (j <= k) --las[j];\n          fa[GF(i)] = GF(j);\n          vecall.push_back({i, j});\n          if (j > k) vec.push_back({i, j});\n        }\n    for (int i = 1; i <= n; ++i)\n      for (int j = i + 1; j <= n; ++j)\n        nz::val[ID(i, j)] = bas[i][j] ? -G[i][j] : G[i][j];\n    memset(fucked, 0, sizeof fucked);\n    for (int i = 1; i <= n; ++i)\n      for (int j = i + 1; j <= n; ++j) {\n        if (j <= k) continue;\n        if (bas[i][j]) continue;\n        if (GF(i) != GF(j)) nz::adde(nz::st, ID(i, j)), fucked[i][j] = 1;\n        if (i > k || las[i] > 0) nz::adde(ID(i, j), nz::en);\n      }\n    for (auto o : vec) {\n      for (int i = 1; i <= n; ++i) fa[i] = i;\n      for (auto p : vecall)\n        if (p != o) fa[GF(p.first)] = GF(p.second);\n      for (int i = 1; i <= n; ++i)\n        for (int j = i + 1; j <= n; ++j) {\n          if (j <= k) continue;\n          if (bas[i][j]) continue;\n          if (GF(i) != GF(j) && !fucked[i][j]) nz::adde(ID(o), ID(i, j));\n          if (i <= k && las[i] == 0 && i == o.first) nz::adde(ID(i, j), ID(o));\n        }\n    }\n    nowsum += nz::fuck();\n    if (nowsum > 1e8) return;\n  }\n  ans = min(ans, nowsum);\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 1; i <= k; ++i) cin >> d[i];\n  for (int i = 1; i <= n; ++i) {\n    for (int j = i + 1; j <= n; ++j) {\n      cin >> G[i][j];\n      G[j][i] = G[i][j];\n    }\n  }\n  for (int S = 0; S < (1 << k * (k - 1) / 2); ++S) {\n    memset(bas, 0, sizeof bas);\n    int cnt = 0;\n    for (int i = 1; i <= k; ++i)\n      for (int j = i + 1; j <= k; ++j) {\n        int c = S >> cnt & 1;\n        cnt += 1;\n        bas[i][j] = bas[j][i] = c;\n      }\n    supermain();\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 53, mod = 1e9 + 7;\nint n, k;\nint d[N], a[N][N];\nvector<pair<int, int> > tmp[105];\nset<pair<int, int> > edge;\nint siz[N];\nvector<int> g[N];\nint f[N];\nint fa(int x) { return f[x] == x ? x : f[x] = fa(f[x]); }\nint dif;\npair<int, int> del, ad;\nint f2[N];\nvoid dfs(int x, int fat) {\n  f2[x] = fat;\n  for (int v : g[x])\n    if (v != fat) {\n      dfs(v, x);\n    }\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i <= k; ++i) scanf(\"%d\", d + i);\n  for (int i = 1; i <= n; ++i)\n    for (int j = i + 1; j <= n; ++j) scanf(\"%d\", a[i] + j), a[j][i] = a[i][j];\n  for (int i = k + 1; i <= n; ++i)\n    for (int j = i + 1; j <= n; ++j) tmp[a[i][j]].push_back(make_pair(i, j));\n  for (int i = 1; i <= n; ++i) f[i] = i;\n  int ans = 0;\n  for (int i = 1; i <= 100; ++i)\n    for (auto& p : tmp[i]) {\n      int x = fa(p.first), y = fa(p.second);\n      if (x != y) f[x] = y, ans += i, edge.insert(p);\n    }\n  for (int i = 1; i <= k; ++i) {\n    int mi = k + 1;\n    for (int j = k + 1; j <= n; ++j)\n      if (a[i][j] < a[i][mi]) mi = j;\n    ans += a[i][mi], edge.insert(make_pair(min(i, mi), max(i, mi)));\n  }\n  a[0][0] = -mod;\n  for (;;) {\n    for (int i = 1; i <= n; ++i) g[i].clear();\n    for (auto& p : edge)\n      g[p.first].push_back(p.second), g[p.second].push_back(p.first);\n    for (int i = 1; i <= n; ++i) siz[i] = g[i].size();\n    dif = mod;\n    for (int i = 1; i <= n; ++i) {\n      dfs(i, 0);\n      for (int j = 1; j <= n; ++j) {\n        int kk = j;\n        while (kk != i) {\n          bool flag = 0;\n          --siz[kk];\n          --siz[f2[kk]];\n          ++siz[i];\n          ++siz[j];\n          for (int p = 1; p <= k; ++p)\n            if (siz[p] > d[p]) {\n              flag = 1;\n              break;\n            }\n          ++siz[kk];\n          ++siz[f2[kk]];\n          --siz[i];\n          --siz[j];\n          if (!flag && dif > a[i][j] - a[kk][f2[kk]]) {\n            dif = a[i][j] - a[kk][f2[kk]];\n            del = make_pair(min(kk, f2[kk]), max(kk, f2[kk]));\n            ad = make_pair(min(i, j), max(i, j));\n          }\n          kk = f2[kk];\n        }\n      }\n    }\n    if (dif < 0) {\n      ans += dif;\n      edge.erase(del);\n      edge.insert(ad);\n    } else\n      break;\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 53, mod = 1e9 + 7;\nint n, k;\nint d[N], a[N][N];\nvector<pair<int, int> > tmp;\nset<pair<int, int> > edge;\nint siz[N];\nvector<int> g[N];\nint f[N];\nint fa(int x) { return f[x] == x ? x : f[x] = fa(f[x]); }\nint dif;\npair<int, int> del, ad;\nint f2[N];\nvoid dfs(int x, int fat) {\n  f2[x] = fat;\n  for (int v : g[x])\n    if (v != fat) {\n      dfs(v, x);\n    }\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i <= k; ++i) scanf(\"%d\", d + i);\n  for (int i = 1; i <= n; ++i)\n    for (int j = i + 1; j <= n; ++j) scanf(\"%d\", a[i] + j), a[j][i] = a[i][j];\n  for (int i = 1; i <= n; ++i)\n    for (int j = i + 1; j <= n; ++j) tmp.push_back(make_pair(i, j));\n  int ans = mod;\n  for (int tim = 1; tim <= 100; ++tim) {\n    int now = 0;\n    for (int i = 1; i <= n; ++i) f[i] = i;\n    edge.clear();\n    for (int i = 1; i <= n; ++i) siz[i] = 0;\n    random_shuffle(begin(tmp), end(tmp));\n    while ((int)edge.size() < n - 1) {\n      for (auto& p : tmp) {\n        if (p.first <= k && siz[p.first] == d[p.first]) continue;\n        if (p.second <= k && siz[p.second] == d[p.second]) continue;\n        if (p.first <= k && p.second <= k && siz[p.first] == d[p.first] - 1 &&\n            siz[p.second] == d[p.second] - 1)\n          continue;\n        int x = fa(p.first), y = fa(p.second);\n        if (x == y) continue;\n        f[x] = y;\n        now += a[p.first][p.second];\n        ++siz[p.first];\n        ++siz[p.second];\n        edge.insert(p);\n      }\n    }\n    a[0][0] = -mod;\n    int cnt0 = 0;\n    for (;;) {\n      for (int i = 1; i <= n; ++i) g[i].clear();\n      for (auto& p : edge)\n        g[p.first].push_back(p.second), g[p.second].push_back(p.first);\n      for (int i = 1; i <= n; ++i) siz[i] = g[i].size();\n      dif = mod;\n      for (int i = 1; i <= n; ++i) {\n        dfs(i, 0);\n        for (int j = 1; j <= n; ++j) {\n          int kk = j;\n          while (kk != i) {\n            bool flag = 0;\n            --siz[kk];\n            --siz[f2[kk]];\n            ++siz[i];\n            ++siz[j];\n            for (int p = 1; p <= k; ++p)\n              if (siz[p] > d[p]) {\n                flag = 1;\n                break;\n              }\n            ++siz[kk];\n            ++siz[f2[kk]];\n            --siz[i];\n            --siz[j];\n            if (!flag && dif >= a[i][j] - a[kk][f2[kk]]) {\n              dif = a[i][j] - a[kk][f2[kk]];\n              del = make_pair(min(kk, f2[kk]), max(kk, f2[kk]));\n              ad = make_pair(min(i, j), max(i, j));\n            }\n            kk = f2[kk];\n          }\n        }\n      }\n      if (dif <= 0) {\n        if (dif == 0)\n          ++cnt0;\n        else\n          cnt0 = 0;\n        if (cnt0 == 10) break;\n        now += dif;\n        edge.erase(del);\n        edge.insert(ad);\n      } else\n        break;\n    }\n    ans = min(ans, now);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e9;\nconst int X = 1e6;\nstruct DSU {\n  vector<int> link;\n  DSU(int n) : link(n, -1) {}\n  int Find(int x) {\n    if (link[x] == -1) return x;\n    return link[x] = Find(link[x]);\n  }\n  bool Union(int a, int b) {\n    a = Find(a);\n    b = Find(b);\n    if (a != b) {\n      link[a] = b;\n      return true;\n    }\n    return false;\n  }\n};\nstruct Tree {\n  int n;\n  vector<int> a, b;\n  Tree(int n, vector<int> a, vector<int> b) : n(n), a(a), b(b) {}\n  vector<bool> Admits(vector<bool> sol) {\n    DSU D(n);\n    for (int i = 0; i < (int)sol.size(); ++i) {\n      if (sol[i]) D.Union(a[i], b[i]);\n    }\n    vector<bool> ret(sol.size(), false);\n    for (int i = 0; i < (int)sol.size(); ++i) {\n      if (!sol[i] && D.Find(a[i]) != D.Find(b[i])) ret[i] = true;\n    }\n    return ret;\n  }\n};\nstruct Color {\n  vector<int> v, a, b;\n  Color(vector<int> v, vector<int> a, vector<int> b) : v(v), a(a), b(b) {}\n  vector<bool> Admits(vector<bool> sol) {\n    vector<int> w = v;\n    for (int i = 0; i < (int)sol.size(); ++i) {\n      if (sol[i]) w[a[i]] -= 1, w[b[i]] -= 1;\n    }\n    vector<bool> ret(sol.size(), false);\n    for (int i = 0; i < (int)sol.size(); ++i) {\n      if (sol[i]) continue;\n      ret[i] = (w[a[i]] > 0 && w[b[i]] > 0);\n    }\n    return ret;\n  }\n};\ntemplate <typename M1>\nvector<vector<bool>> Exchange(M1& M, vector<bool> sol) {\n  vector<vector<bool>> ret(sol.size());\n  for (int i = 0; i < (int)sol.size(); ++i) {\n    if (!sol[i]) continue;\n    sol[i] = 0;\n    ret[i] = M.Admits(sol);\n    sol[i] = 1;\n  }\n  return ret;\n}\ntemplate <class M1, class M2>\nint MatroidIntersection(vector<int> w, M1 m1, M2 m2, int req) {\n  int n = w.size();\n  vector<bool> sol(n, false);\n  for (int i = 0; i < n; ++i)\n    if (w[i] == -X) sol[i] = true;\n  vector<int> q;\n  while (true) {\n    auto adm1 = m1.Admits(sol), adm2 = m2.Admits(sol);\n    auto ex1 = Exchange(m1, sol), ex2 = Exchange(m2, sol);\n    q.clear();\n    vector<int> inq(n, false);\n    vector<int> parent(n, -2);\n    vector<int> dist(n, INF);\n    auto push = [&](int i, int p, int d) {\n      if (d >= dist[i]) return;\n      dist[i] = d;\n      parent[i] = p;\n      if (!inq[i]) q.push_back(i), inq[i] = 1;\n    };\n    for (int i = 0; i < n; ++i) {\n      if (abs(w[i]) == X) continue;\n      if (!sol[i] && adm1[i]) {\n        push(i, -1, w[i]);\n      }\n    }\n    int ch = 1, iter = 0;\n    for (int i = 0; i < (int)q.size(); ++i) {\n      int node = q[i];\n      inq[node] = 0;\n      for (int vec = 0; vec < n; ++vec) {\n        if (abs(w[vec]) == X) continue;\n        if (sol[node] != sol[vec]) {\n          assert(dist[node] != INF);\n          if (sol[node]) {\n            if (ex1[node][vec]) push(vec, node, dist[node] + w[vec]);\n          } else {\n            if (ex2[vec][node]) push(vec, node, dist[node] - w[vec]);\n          }\n        }\n      }\n    }\n    int best = INF;\n    int choose = -1;\n    for (int node = 0; node < n; ++node) {\n      if (abs(w[node]) == X) continue;\n      if (!sol[node] && adm2[node] && parent[node] != -2) {\n        auto now = dist[node];\n        if (now < best) {\n          best = now;\n          choose = node;\n        }\n      }\n    }\n    if (choose == -1) break;\n    for (int node = choose; node != -1; node = parent[node]) {\n      sol[node] = !sol[node];\n    }\n  }\n  int ans = 0, cnt = 0;\n  for (int i = 0; i < n; ++i) {\n    if (sol[i]) {\n      ans += w[i];\n      cnt += 1;\n    }\n  }\n  if (cnt != req) return INF;\n  return ans;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  vector<int> v(n, n);\n  for (int i = 0; i < k; ++i) cin >> v[i];\n  vector<int> a, b, w;\n  for (int i = 0; i < n; ++i) {\n    for (int j = i + 1; j < n; ++j) {\n      int x;\n      cin >> x;\n      a.push_back(i);\n      b.push_back(j);\n      w.push_back(x);\n    }\n  }\n  int m = a.size();\n  vector<int> o(m);\n  iota(o.begin(), o.end(), 0);\n  sort(o.begin(), o.end(), [&](int a, int b) { return w[a] < w[b]; });\n  vector<int> na, nb, nw, si;\n  DSU D(n);\n  for (auto i : o) {\n    if (a[i] < k && b[i] < k) si.push_back(na.size());\n    if (a[i] < k || b[i] < k || D.Union(a[i], b[i])) {\n      na.push_back(a[i]);\n      nb.push_back(b[i]);\n      nw.push_back(w[i]);\n    }\n  }\n  a = na;\n  b = nb;\n  w = nw;\n  int sol = INF;\n  for (int msk = 0; msk < (1 << si.size()); ++msk) {\n    DSU D(n);\n    vector<int> now_w = w;\n    vector<int> ww = v;\n    int delta = 0;\n    bool bad = false;\n    for (int i = 0; i < (int)si.size(); ++i) {\n      if (msk & (1 << i)) {\n        if (!D.Union(a[si[i]], b[si[i]])) bad = true;\n        if (--ww[a[si[i]]] < 0 || --ww[b[si[i]]] < 0) bad = true;\n        delta += w[si[i]] + X;\n        now_w[si[i]] = -X;\n      } else\n        now_w[si[i]] = X;\n    }\n    if (bad) continue;\n    Tree T(n, a, b);\n    Color C(v, a, b);\n    auto now = MatroidIntersection(now_w, T, C, n - 1);\n    sol = min(sol, now + delta);\n  }\n  cout << sol << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nconstexpr int maxn = 50;\nint w[maxn][maxn];\nint p[maxn];\nint gp(int u) { return p[u] == u ? u : p[u] = gp(p[u]); }\nvector<pair<int, int>> pr[100 + 1];\nint n, k, d[maxn], e[maxn];\npair<int, vector<pair<int, int>>> get(vector<pair<int, int>>& cur, int u,\n                                      int v) {\n  for (int i = 0; i < n; i += 1) p[i] = i;\n  vector<pair<int, int>> ncur;\n  LL nans = 0;\n  for (int i = 0; i < k; i += 1) e[i] = 0;\n  for (auto [x, y] : cur) {\n    if (w[u][v] < w[x][y]) {\n      int pu = gp(u), pv = gp(v);\n      if (pu != pv) {\n        p[pu] = pv;\n        ncur.push_back({u, v});\n        nans += w[u][v];\n        e[u] += 1;\n        e[v] += 1;\n      }\n    }\n    int px = gp(x), py = gp(y);\n    if (px != py) {\n      p[px] = py;\n      ncur.push_back({x, y});\n      nans += w[x][y];\n      e[x] += 1;\n      e[y] += 1;\n    }\n  }\n  for (int i = 0; i < k; i += 1)\n    if (e[i] > d[i]) return {INT_MAX, {}};\n  return {nans, ncur};\n}\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  cin >> n >> k;\n  for (int i = 0; i < k; i += 1) cin >> d[i];\n  for (int i = 0; i < n; i += 1)\n    for (int j = i + 1; j < n; j += 1) {\n      cin >> w[i][j];\n      w[j][i] = w[i][j];\n      pr[w[i][j]].push_back({i, j});\n    }\n  for (int i = k; i < n; i += 1) p[i] = i;\n  vector<pair<int, int>> p;\n  for (int i = 0; i < n; i += 1)\n    for (int j = i + 1; j < n; j += 1) p.push_back({i, j});\n  int res = INT_MAX;\n  srand(time(0));\n  for (int i = 0; i < 500; i += 1) {\n    random_shuffle(p.begin(), p.end());\n    int ans = 0;\n    vector<pair<int, int>> cur;\n    int r = rand() % (n - k) + k;\n    for (int i = 0; i < n; i += 1)\n      if (i != r) {\n        cur.push_back({i, r});\n        ans += w[i][r];\n      }\n    sort(cur.begin(), cur.end(),\n         [&](const pair<int, int>& p, const pair<int, int>& q) {\n           return w[p.first][p.second] < w[q.first][q.second];\n         });\n    while (true) {\n      res = min(res, ans);\n      int ok = 1;\n      for (auto [i, j] : p) {\n        auto [nans, ncur] = get(cur, i, j);\n        if (nans < ans) {\n          ans = nans;\n          ncur.swap(cur);\n          ok = 0;\n        }\n      }\n      if (ok) break;\n    }\n    res = min(res, ans);\n  }\n  cout << res;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\ninline void read(T &f) {\n  f = 0;\n  T fu = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') {\n      fu = -1;\n    }\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    f = (f << 3) + (f << 1) + (c & 15);\n    c = getchar();\n  }\n  f *= fu;\n}\ntemplate <typename T>\nvoid print(T x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x < 10)\n    putchar(x + 48);\n  else\n    print(x / 10), putchar(x % 10 + 48);\n}\ntemplate <typename T>\nvoid print(T x, char t) {\n  print(x);\n  putchar(t);\n}\nconst int N = 55;\nstruct edge_t {\n  int v, nxt, w;\n} G[233333];\nqueue<int> q;\nint a[N][N], id[N][N], d[N], deg[N], f[N], tem[N], dis[N * N], cnt[N * N],\n    pre[N * N], vis[N * N], used[N * N], u[N * N], v[N * N], head[N * N];\nint n, k, ans = 1e9, tot;\ninline void addedge(int u, int v, int w) {\n  G[++tot] = (edge_t){v, head[u], w}, head[u] = tot;\n}\nint find(int x) { return f[x] == x ? x : f[x] = find(f[x]); }\nint main() {\n  read(n);\n  read(k);\n  for (int i = 1; i <= k; i++) read(d[i]);\n  for (int i = k + 1; i <= n; i++) d[i] = n;\n  for (int i = 1; i <= n; i++) {\n    for (int j = i + 1; j <= n; j++) read(a[i][j]);\n  }\n  int m = 0;\n  for (int i = 1; i <= n; i++) {\n    for (int j = max(k + 1, i + 1); j <= n; j++) {\n      id[i][j] = ++m;\n      u[m] = i;\n      v[m] = j;\n    }\n  }\n  for (int mask = 0; mask < (1 << (k * (k - 1) / 2)); mask++) {\n    for (int i = 1; i <= n; i++) f[i] = i;\n    memset(deg, 0, sizeof(deg));\n    int now = 0, cando = 1, sum = 0;\n    for (int u = 1; u <= k; u++) {\n      for (int v = u + 1; v <= k; v++) {\n        if ((mask >> now) & 1) {\n          int x = find(u), y = find(v);\n          if (x == y) cando = 0;\n          ++deg[u];\n          ++deg[v];\n          f[x] = y;\n          sum += a[u][v];\n        }\n        ++now;\n      }\n    }\n    for (int i = 1; i <= k; i++) {\n      if (deg[i] > d[i]) {\n        cando = 0;\n      }\n    }\n    if (!cando) continue;\n    memcpy(tem, f, sizeof(tem));\n    memset(used, 0, sizeof(used));\n    while (1) {\n      memset(head, 0, (m + 2) * 4);\n      tot = 0;\n      int s = 0, t = m + 1;\n      for (int i = 1; i <= m; i++) {\n        if (used[i]) {\n          memcpy(f, tem, sizeof(f));\n          for (int j = 1; j <= m; j++) {\n            if (used[j] && i != j) {\n              f[find(u[j])] = find(v[j]);\n            }\n          }\n          for (int j = 1; j <= m; j++) {\n            if (!used[j] && find(u[j]) != find(v[j])) {\n              addedge(i, j, a[u[j]][v[j]]);\n            }\n          }\n          --deg[u[i]];\n          --deg[v[i]];\n          for (int j = 1; j <= m; j++) {\n            if (!used[j] && deg[u[j]] < d[u[j]] && deg[v[j]] < d[v[j]]) {\n              addedge(j, i, -a[u[i]][v[i]]);\n            }\n          }\n          ++deg[u[i]];\n          ++deg[v[i]];\n        }\n      }\n      memcpy(f, tem, sizeof(f));\n      for (int i = 1; i <= m; i++) {\n        if (used[i]) {\n          f[find(u[i])] = find(v[i]);\n        }\n      }\n      for (int i = 1; i <= m; i++) {\n        if (!used[i]) {\n          if (find(u[i]) != find(v[i])) {\n            addedge(s, i, a[u[i]][v[i]]);\n          }\n          if (deg[u[i]] < d[u[i]] && deg[v[i]] < d[v[i]]) {\n            addedge(i, t, 0);\n          }\n        }\n      }\n      memset(dis, 0x3f, (m + 2) * 4);\n      q.push(s);\n      dis[s] = 0;\n      vis[s] = 1;\n      while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        vis[u] = 0;\n        for (int i = head[u]; i; i = G[i].nxt) {\n          int v = G[i].v;\n          if (dis[v] > dis[u] + G[i].w ||\n              (dis[v] == dis[u] + G[i].w && cnt[v] > cnt[u] + 1)) {\n            dis[v] = dis[u] + G[i].w;\n            cnt[v] = cnt[u] + 1;\n            pre[v] = u;\n            if (!vis[v]) {\n              vis[v] = 1;\n              q.push(v);\n            }\n          }\n        }\n      }\n      if (dis[t] == 0x3f3f3f3f) break;\n      sum += dis[t];\n      int tmp = pre[t];\n      while (tmp) {\n        if (used[tmp])\n          --deg[u[tmp]], --deg[v[tmp]];\n        else\n          ++deg[u[tmp]], ++deg[v[tmp]];\n        used[tmp] ^= 1;\n        tmp = pre[tmp];\n      }\n    }\n    int ecnt = __builtin_popcount(mask);\n    for (int i = 1; i <= m; i++) ecnt += used[i];\n    if (ecnt == n - 1) ans = min(ans, sum);\n  }\n  print(ans, '\\n');\n  return 0;\n}\n"
        }
    ]
}