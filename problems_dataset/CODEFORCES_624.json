{
    "name": "624_D. Array GCD",
    "source": "CODEFORCES",
    "description": "You are given array ai of length n. You may consecutively apply two operations to this array:\n\n  * remove some subsegment (continuous subsequence) of length m < n and pay for it m\u00b7a coins; \n  * change some elements of the array by at most 1, and pay b coins for each change. \n\n\n\nPlease note that each of operations may be applied at most once (and may be not applied at all) so you can remove only one segment and each number may be changed (increased or decreased) by at most 1. Also note, that you are not allowed to delete the whole array.\n\nYour goal is to calculate the minimum number of coins that you need to spend in order to make the greatest common divisor of the elements of the resulting array be greater than 1.\n\nInput\n\nThe first line of the input contains integers n, a and b (1 \u2264 n \u2264 1 000 000, 0 \u2264 a, b \u2264 109) \u2014 the length of the array, the cost of removing a single element in the first operation and the cost of changing an element, respectively.\n\nThe second line contains n integers ai (2 \u2264 ai \u2264 109) \u2014 elements of the array.\n\nOutput\n\nPrint a single number \u2014 the minimum cost of changes needed to obtain an array, such that the greatest common divisor of all its elements is greater than 1.\n\nExamples\n\nInput\n\n3 1 4\n4 2 3\n\n\nOutput\n\n1\n\n\nInput\n\n5 3 2\n5 17 13 5 6\n\n\nOutput\n\n8\n\n\nInput\n\n8 3 4\n3 7 5 4 3 12 9 4\n\n\nOutput\n\n13\n\nNote\n\nIn the first sample the optimal way is to remove number 3 and pay 1 coin for it.\n\nIn the second sample you need to remove a segment [17, 13] and then decrease number 6. The cost of these changes is equal to 2\u00b73 + 2 = 8 coins.",
    "difficulty": "D",
    "tags": [
        "dp",
        "greedy",
        "number theory"
    ],
    "rating": 2300,
    "public_test": [
        {
            "input": "3 1 4\n4 2 3\n",
            "output": "                                                               1\n"
        },
        {
            "input": "8 3 4\n3 7 5 4 3 12 9 4\n",
            "output": "                                                              13\n"
        },
        {
            "input": "5 3 2\n5 17 13 5 6\n",
            "output": "                                                               8\n"
        }
    ],
    "generated_test": [
        {
            "input": "93 1985 9702\n1711 6269 9689 9119 569 3990 5129 6314 2171 4078 2607 3063 5410 7140 7831 4622 2597 8486 267 3110 1673 5435 8981 6871 4679 8854 5675 39 7227 2533 1782 7833 7029 5919 7792 4192 5856 6020 4735 9772 3145 8757 3853 6371 7217 815 6643 837 3490 1667 2360 983 653 2708 5795 9203 1405 2875 7590 2682 8667 5369 8371 1235 3093 1802 483 2359 677 2044 4556 8403 6419 301 7410 1964 9587 392 1712 1105 7882 3215 5212 1885 1772 4865 1248 7410 9690 6840 7981 8550 4561\n",
            "output": "182620"
        },
        {
            "input": "6 100 1\n4 2 2 2 2 3\n",
            "output": "1"
        },
        {
            "input": "3 2 0\n463 926 925\n",
            "output": "0"
        },
        {
            "input": "4 457 423\n559 559 561 327\n",
            "output": "846"
        },
        {
            "input": "7 735937743 207711841\n43 400 667 521 729 413 878\n",
            "output": "1038559205"
        },
        {
            "input": "2 10 7\n2 5\n",
            "output": "7"
        },
        {
            "input": "7 46 23\n47 17 90 30 53 6 63\n",
            "output": "69"
        },
        {
            "input": "5 4 5\n7 4 7 4 8\n",
            "output": "9"
        },
        {
            "input": "2 965 473\n569 90\n",
            "output": "473"
        },
        {
            "input": "5 2 10\n124 777 133 616 618\n",
            "output": "4"
        },
        {
            "input": "45 393296667 817784089\n513035443 513035443 513035445 513035445 513035443 555648978 463549879 830693049 524420119 541365334 562791911 736173182 644390537 639730339 913702156 807631127 679411095 457747249 554394051 803981524 901463184 651788488 792766018 587562656 564169971 645381787 497940709 886010956 577261234 513035444 513035443 513035443 902522059 513035445 513035444 513035444 513035443 513035443 513035445 513035445 513035443 513035443 513035443 513035443 513035445\n",
            "output": "16911756681"
        },
        {
            "input": "10 8 4\n256 402 803 803 801 226 802 801 401 801\n",
            "output": "24"
        },
        {
            "input": "6 128454855 446458629\n920 204 261 770 485 919\n",
            "output": "513819420"
        },
        {
            "input": "5 10 1\n1300333 1300332 2600666 1300334 2426257\n",
            "output": "2"
        },
        {
            "input": "3 63 850\n764 383 381\n",
            "output": "126"
        },
        {
            "input": "6 4 10\n577 576 883 679 956 864\n",
            "output": "16"
        },
        {
            "input": "13 219 292\n879 798 798 797 328 263 148 931 92 578 262 798 796\n",
            "output": "1095"
        },
        {
            "input": "2 7 5\n5 12\n",
            "output": "5"
        },
        {
            "input": "8 3 4\n3 7 6 4 3 12 9 4\n",
            "output": "11"
        },
        {
            "input": "5 3 2\n5 17 8 5 6\n",
            "output": "6"
        },
        {
            "input": "5 4 5\n7 7 7 4 8\n",
            "output": "8"
        },
        {
            "input": "10 8 4\n39 402 803 803 801 226 802 801 401 801\n",
            "output": "20"
        },
        {
            "input": "3 102 850\n764 383 381\n",
            "output": "204"
        },
        {
            "input": "13 245 292\n879 798 798 797 328 263 148 931 92 578 262 798 796\n",
            "output": "1121"
        },
        {
            "input": "7 735937743 207711841\n43 112 667 674 729 413 878\n",
            "output": "830847364"
        },
        {
            "input": "1 6 2\n12\n",
            "output": "0"
        },
        {
            "input": "1 476059451 601925138\n609\n",
            "output": "0"
        },
        {
            "input": "1 5 10\n99\n",
            "output": "0"
        },
        {
            "input": "5 1 1\n1300333 1300332 2600666 1300334 153728\n",
            "output": "1"
        },
        {
            "input": "2 10 2\n18 13\n",
            "output": "2"
        },
        {
            "input": "1 16 276\n104\n",
            "output": "0"
        },
        {
            "input": "1 334159859 249565919\n92\n",
            "output": "0"
        },
        {
            "input": "93 1985 9702\n1711 6269 9689 9119 569 3990 5129 6314 2171 4078 2607 3063 5410 7140 7831 4622 2597 8486 267 3110 1673 5435 8981 6871 4679 8854 5675 39 7227 2533 1782 7833 7029 5919 7792 4192 5856 6020 4735 9772 3145 8757 3853 6371 7217 815 6643 837 3490 1667 2360 983 653 2708 5795 9203 1405 2875 7590 2682 8667 5369 8371 1235 3093 1802 483 2359 677 2044 1897 8403 6419 301 7410 1964 9587 392 1712 1105 7882 3215 5212 1885 1772 4865 1248 7410 9690 6840 7981 8550 4561\n",
            "output": "182620"
        },
        {
            "input": "6 100 1\n4 3 2 2 2 3\n",
            "output": "2"
        },
        {
            "input": "3 4 0\n463 926 925\n",
            "output": "0"
        },
        {
            "input": "1 6 2\n13\n",
            "output": "0"
        },
        {
            "input": "4 457 423\n559 559 561 135\n",
            "output": "846"
        },
        {
            "input": "7 735937743 207711841\n43 112 667 521 729 413 878\n",
            "output": "1038559205"
        },
        {
            "input": "7 46 23\n47 17 90 30 17 6 63\n",
            "output": "69"
        },
        {
            "input": "2 965 473\n358 90\n",
            "output": "0"
        },
        {
            "input": "5 2 10\n124 1278 133 616 618\n",
            "output": "2"
        },
        {
            "input": "45 393296667 817784089\n513035443 513035443 965106677 513035445 513035443 555648978 463549879 830693049 524420119 541365334 562791911 736173182 644390537 639730339 913702156 807631127 679411095 457747249 554394051 803981524 901463184 651788488 792766018 587562656 564169971 645381787 497940709 886010956 577261234 513035444 513035443 513035443 902522059 513035445 513035444 513035444 513035443 513035443 513035445 513035445 513035443 513035443 513035443 513035443 513035445\n",
            "output": "16911756681"
        },
        {
            "input": "6 128454855 733824005\n920 204 261 770 485 919\n",
            "output": "513819420"
        },
        {
            "input": "5 1 2\n1300333 1300332 2600666 1300334 153728\n",
            "output": "1"
        },
        {
            "input": "5 10 1\n1300333 1300332 2600666 1300334 1554775\n",
            "output": "2"
        },
        {
            "input": "6 4 10\n577 576 883 679 956 863\n",
            "output": "20"
        },
        {
            "input": "2 7 5\n2 12\n",
            "output": "0"
        },
        {
            "input": "8 3 4\n3 7 6 4 3 12 9 8\n",
            "output": "11"
        },
        {
            "input": "93 1985 9702\n1711 6269 9689 9119 569 3990 5129 6314 2171 4078 2607 3063 5410 7140 7831 4622 2597 8486 267 3110 1673 5435 8981 6871 4679 8854 5675 39 7227 2533 1782 7833 7029 5919 7792 4192 5856 6020 4735 9772 3145 8757 3853 6371 7217 815 6643 837 3490 1667 2360 983 653 2708 5795 9203 1405 2875 7590 2682 8667 5369 8371 1235 3093 1802 483 3493 677 2044 1897 8403 6419 301 7410 1964 9587 392 1712 1105 7882 3215 5212 1885 1772 4865 1248 7410 9690 6840 7981 8550 4561\n",
            "output": "182620"
        },
        {
            "input": "1 6 0\n13\n",
            "output": "0"
        },
        {
            "input": "4 457 423\n559 634 561 135\n",
            "output": "846"
        },
        {
            "input": "7 80 23\n47 17 90 30 17 6 63\n",
            "output": "69"
        },
        {
            "input": "5 4 5\n7 7 7 4 10\n",
            "output": "8"
        },
        {
            "input": "2 965 312\n358 90\n",
            "output": "0"
        },
        {
            "input": "5 2 10\n124 1278 133 1052 618\n",
            "output": "2"
        },
        {
            "input": "45 393296667 817784089\n513035443 513035443 965106677 513035445 513035443 555648978 463549879 830693049 524420119 541365334 562791911 736173182 644390537 639730339 913702156 807631127 679411095 457747249 554394051 803981524 901463184 651788488 792766018 587562656 564169971 233597349 497940709 886010956 577261234 513035444 513035443 513035443 902522059 513035445 513035444 513035444 513035443 513035443 513035445 513035445 513035443 513035443 513035443 513035443 513035445\n",
            "output": "16911756681"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 3000000000000000000LL;\nlong long dp[1000001][3];\nvoid pf(long a, set<long long> &s) {\n  long long i;\n  for (i = 2; i * i <= a; ++i) {\n    if (a % i == 0) {\n      s.insert(i);\n      while (a % i == 0) a /= i;\n    }\n  }\n  if (a > 1) s.insert(a);\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  long long i, j;\n  long long n;\n  long long A, B;\n  cin >> n >> A >> B;\n  vector<long long> a(n);\n  for (i = 0; i < n; ++i) cin >> a[i];\n  set<long long> p;\n  pf(a[0] - 1, p);\n  pf(a[0], p);\n  pf(a[0] + 1, p);\n  pf(a[n - 1] - 1, p);\n  pf(a[n - 1], p);\n  pf(a[n - 1] + 1, p);\n  long long ans = INF;\n  for (__typeof(p.begin()) it = p.begin(); it != p.end(); it++) {\n    int d = *it;\n    for (i = 0; i < 3; ++i) dp[0][i] = 0;\n    for (i = 0; i < n; ++i) {\n      long x = a[i] % d;\n      if (x == 0) {\n        dp[i + 1][0] = dp[i][0];\n        dp[i + 1][1] = min(dp[i][0], dp[i][1] + A);\n        dp[i + 1][2] = min(dp[i][1], dp[i][2]);\n      } else if (x == 1 || x == d - 1) {\n        dp[i + 1][0] = dp[i][0] + B;\n        dp[i + 1][1] = min(dp[i][0] + B, dp[i][1] + A);\n        dp[i + 1][2] = min(dp[i][1] + B, dp[i][2] + B);\n      } else {\n        dp[i + 1][0] = INF;\n        dp[i + 1][1] = min(dp[i][0], dp[i][1]) + A;\n        dp[i + 1][2] = dp[i + 1][1];\n      }\n    }\n    long long tmp = INF;\n    for (i = 0; i < 3; ++i) tmp = min(tmp, dp[n][i]);\n    ans = min(ans, tmp);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long arr[(int)(1e6 + 10)], n, a, b, ans = 1e16;\nvector<long long> d;\nvoid div(long long x) {\n  for (int i = 2; i * i <= x; i++) {\n    if (x % i == 0) {\n      d.push_back(i);\n      while (x % i == 0) x /= i;\n    }\n  }\n  if (x > 1) d.push_back(x);\n}\nlong long solve(long long x) {\n  long long op1 = 0, op2 = 0, op3 = 0, cur = 1e16;\n  for (int i = 1; i <= n; i++) {\n    cur = 1e16;\n    if (arr[i] % x == 0)\n      cur = 0;\n    else if ((arr[i] + 1) % x == 0 or (arr[i] - 1) % x == 0)\n      cur = b;\n    op1 += cur;\n    op2 += a;\n    op3 += cur;\n    op1 = min((long long)1e16, op1);\n    op2 = min(op1, op2);\n    op3 = min(op3, op2);\n  }\n  return op3;\n}\nint main() {\n  cin >> n >> a >> b;\n  for (int i = 1; i <= n; i++) scanf(\"%lld\", &arr[i]);\n  for (int i = -1; i <= 1; i++) div(arr[1] + i), div(arr[n] + i);\n  sort(d.begin(), d.end());\n  d.erase(unique(d.begin(), d.end()), d.end());\n  for (__typeof(d.begin()) i = d.begin(); i != d.end(); i++)\n    ans = min(ans, solve(*i));\n  cout << ans << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct __io_dev {\n  __io_dev(const bool& __fastio = false) {\n    if (__fastio) ios_base::sync_with_stdio(false), cin.tie(nullptr);\n    srand(time(nullptr));\n    if (!string(\"\").empty())\n      freopen(\n          \"\"\n          \".in\",\n          \"r\", stdin),\n          freopen(\n              \"\"\n              \".out\",\n              \"w\", stdout);\n  }\n  ~__io_dev() { fprintf(stderr, \"%.6f ms\\n\", 1e3 * clock() / CLOCKS_PER_SEC); }\n} __io(false);\nconst long long inf = (long long)1e+9 + 7ll;\nconst long long linf = (long long)1e+18 + 7ll;\nconst long double eps = (long double)1e-9;\nconst long double pi = acosl((long double)-1.0);\nconst int alph = 26;\nconst int sqr = 3017;\nstatic char buff[(int)2e6 + 17];\nlong long __p[3] = {29ll, 31ll, 33ll};\nlong long __mod[3] = {inf, inf + 2ll, 14881337ll};\nconst int maxn = (int)3e6 + 17;\nint n;\nlong long a, b;\nlong long A[maxn], dp[maxn][3];\nset<long long> D;\nvoid add(long long x) {\n  for (long long i = 2; i * i <= x; ++i)\n    for (; x % i == 0; x /= i, D.insert(i))\n      ;\n  if (x != 1) D.insert(x);\n}\nlong long solve(long long d) {\n  dp[0][0] = 0, dp[0][1] = dp[0][2] = linf;\n  for (long long i = (long long)1; i < (long long)n + 1; ++i) {\n    if (A[i] % d == 0) {\n      dp[i][0] = dp[i - 1][0];\n      dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + a;\n      dp[i][2] = min(dp[i - 1][1], dp[i - 1][2]);\n    }\n    if ((A[i] + 1) % d == 0 || (A[i] - 1) % d == 0) {\n      dp[i][0] = dp[i - 1][0] + b;\n      dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + a;\n      dp[i][2] = min(linf, min(dp[i - 1][1], dp[i - 1][2]) + b);\n    }\n    if (A[i] % d != 0 && (A[i] + 1) % d != 0 && (A[i] - 1) % d != 0) {\n      dp[i][0] = linf;\n      dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + a;\n      dp[i][2] = linf;\n    }\n  }\n  return min(dp[n][0], min(dp[n][1], dp[n][2]));\n}\nint main() {\n  scanf(\"%d %lld %lld\", &n, &a, &b);\n  for (long long i = 0ll; i < (long long)n; ++i) scanf(\"%lld\", A + i + 1);\n  add(A[1] - 1), add(A[1]), add(A[1] + 1);\n  add(A[n] - 1), add(A[n]), add(A[n] + 1);\n  long long ans = linf;\n  for (auto i : D) ans = min(ans, solve(i));\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int TEN_18 = 10000000000000000;\nlong long int n, a, b;\nlong long int l[1000100];\nvector<long long int> test;\nvoid fillTest(long long int x) {\n  if (x % 2 == 0) test.push_back(2);\n  while (x % 2 == 0) x = x / 2;\n  for (long long int i = 3; i <= sqrt(x); i = i + 2) {\n    if (x % i == 0) test.push_back(i);\n    while (x % i == 0) x /= i;\n  }\n  if (x > 2) test.push_back(x);\n}\nlong long int solve(long long int p) {\n  long long int s1[n + 1], s2[n + 1], dp[n + 1], c[n + 1];\n  for (int i = 0; i < n + 1; i++) {\n    s1[i] = dp[i] = 0;\n    c[i] = TEN_18;\n  }\n  for (int i = 0; i < n; i++) {\n    if (l[i] % p == 0)\n      c[i] = 0;\n    else if ((l[i] + 1) % p == 0 || (l[i] - 1) % p == 0)\n      c[i] = b;\n  }\n  s2[n] = 0LL;\n  for (int i = n - 1; i >= 0; i--) {\n    s2[i] = min(c[i] + s2[i + 1], TEN_18);\n    dp[i] = min(dp[i + 1] + a, s2[i]);\n  }\n  long long int result = dp[0];\n  s1[0] = 0LL;\n  for (int i = 1; i < n; i++) {\n    s1[i] = min(s1[i - 1] + c[i - 1], TEN_18);\n    result = min(s1[i] + dp[i], result);\n  }\n  return result;\n}\nint main() {\n  while (scanf(\"%lld %lld %lld\", &n, &a, &b) != EOF) {\n    test.clear();\n    for (int i = 0; i < n; i++) scanf(\"%lld\", &l[i]);\n    fillTest(l[0]);\n    fillTest(l[0] + 1);\n    fillTest(l[0] - 1);\n    fillTest(l[n - 1]);\n    fillTest(l[n - 1] + 1);\n    fillTest(l[n - 1] - 1);\n    long long int ans = TEN_18;\n    for (int i = 0; i < test.size(); i++) {\n      ans = min(ans, solve(test[i]));\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint shu[1100000];\nint sushu[110000];\nlong long dai[1100000];\nlong long ans;\nint n;\nlong long a[1100000];\nlong long aa, bb;\nint aaa, bbb;\nmap<long long, int> w1, wn;\nint main() {\n  for (int i = 2; i <= 1000000; i++) {\n    if (!shu[i]) {\n      for (int j = i * 2; j <= 1000000; j += i) shu[j] = 1;\n    }\n  }\n  for (int i = 2; i <= 1000000; i++) {\n    if (!shu[i]) {\n      sushu[0]++;\n      sushu[sushu[0]] = i;\n    }\n  }\n  scanf(\"%d%d%d\", &n, &aaa, &bbb);\n  aa = aaa;\n  bb = bbb;\n  for (int i = 1; i <= n; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    a[i] = x;\n  }\n  for (int i = 1; i <= sushu[0]; i++) {\n    if (a[1] % sushu[i] == 0) w1[sushu[i]] = 1;\n    if ((a[1] - 1) % sushu[i] == 0) w1[sushu[i]] = 1;\n    if ((a[1] + 1) % sushu[i] == 0) w1[sushu[i]] = 1;\n    w1[a[1]] = 1;\n    w1[a[1] + 1] = 1;\n    w1[a[1] - 1] = 1;\n    if (a[n] % sushu[i] == 0) wn[sushu[i]] = 1;\n    if ((a[n] - 1) % sushu[i] == 0) wn[sushu[i]] = 1;\n    if ((a[n] + 1) % sushu[i] == 0) wn[sushu[i]] = 1;\n    wn[a[n]] = 1;\n    wn[a[n] - 1] = 1;\n    wn[a[n] + 1] = 1;\n  }\n  sushu[0]++;\n  sushu[sushu[0]] = a[1];\n  sushu[0]++;\n  sushu[sushu[0]] = a[1] + 1;\n  sushu[0]++;\n  sushu[sushu[0]] = a[n];\n  sushu[0]++;\n  sushu[sushu[0]] = a[n] + 1;\n  sushu[0]++;\n  sushu[sushu[0]] = a[1] - 1;\n  sushu[0]++;\n  sushu[sushu[0]] = a[n] - 1;\n  ans = -1;\n  for (int i = 1; i <= sushu[0]; i++) {\n    if (sushu[i] == 1) continue;\n    if ((!w1[sushu[i]]) && (!wn[sushu[i]])) {\n    } else {\n      long long q = sushu[i];\n      for (int j = 1; j <= n; j++) {\n        if (a[j] % q == 0) {\n          dai[j] = 0;\n        } else {\n          if (((a[j] + 1) % q == 0) || ((a[j] - 1) % q == 0)) {\n            dai[j] = bb;\n          } else {\n            dai[j] = aa * (long long)100;\n          }\n        }\n      }\n      int ji = 0;\n      long long temp = 0;\n      long long anss;\n      for (int j = 2; j <= n; j++) dai[j] += dai[j - 1];\n      anss = dai[n];\n      for (int j = 1; j <= n; j++) {\n        temp += dai[j] - dai[j - 1];\n        ji++;\n        if (temp >= (long long)ji * aa) {\n          anss = min(anss, dai[j - ji] + dai[n] - dai[j] + (long long)ji * aa);\n        } else {\n          temp = 0;\n          ji = 0;\n        }\n      }\n      if (ans == -1) ans = anss;\n      ans = min(ans, anss);\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD9 = 1e9 + 7;\nconst int MOD91 = 1e9 + 9;\nconst long long MOD12 = 1e12 + 39LL;\nconst long long MOD15 = 1e15 + 37LL;\nconst long long INF = 1e16;\nconst int base = 1e9;\nconst int MAX = 2e6;\nconst long double EPS = 1e-10;\nset<long long> prime;\nvoid fp(long long x) {\n  long long i = 2;\n  prime.insert(i);\n  while (x > 1 && i <= sqrt(x)) {\n    if (x % i == 0) prime.insert(i);\n    while (x % i == 0) {\n      x /= i;\n    }\n    i++;\n  }\n  if (x != 1) {\n    prime.insert(x);\n  }\n}\nlong long dp[3][MAX];\nlong long a, b, n;\nlong long c[MAX];\nint main() {\n  cin >> n >> a >> b;\n  for (int i = (0); i < (n); ++i) {\n    scanf(\"%I64d\", &c[i]);\n  }\n  long long ans = INF;\n  fp(c[0]);\n  fp(c[0] - 1);\n  fp(c[0] + 1);\n  fp(c[n - 1]);\n  fp(c[n - 1] - 1);\n  fp(c[n - 1] + 1);\n  for (auto &p : prime) {\n    for (int i = (0); i < (n + 1); ++i) {\n      for (int j = (0); j < (3); ++j) {\n        dp[j][i] = INF;\n      }\n    }\n    if (c[0] % p == 0) {\n      dp[0][0] = 0;\n    } else if ((c[0] + 1) % p == 0 || (c[0] - 1) % p == 0) {\n      dp[0][0] = b;\n    }\n    dp[1][0] = a;\n    for (int i = 0; i < n - 1; ++i) {\n      if (c[i + 1] % p == 0) {\n        dp[0][i + 1] = min(dp[0][i + 1], dp[0][i]);\n        dp[2][i + 1] = min(dp[2][i + 1], dp[2][i]);\n        dp[2][i + 1] = min(dp[2][i + 1], dp[1][i]);\n      }\n      if ((c[i + 1] + 1) % p == 0) {\n        dp[0][i + 1] = min(dp[0][i + 1], dp[0][i] + b);\n        dp[2][i + 1] = min(dp[2][i + 1], dp[2][i] + b);\n        dp[2][i + 1] = min(dp[2][i + 1], dp[1][i] + b);\n      }\n      if ((c[i + 1] - 1) % p == 0) {\n        dp[0][i + 1] = min(dp[0][i + 1], dp[0][i] + b);\n        dp[2][i + 1] = min(dp[2][i + 1], dp[2][i] + b);\n        dp[2][i + 1] = min(dp[2][i + 1], dp[1][i] + b);\n      }\n      dp[1][i + 1] = min(dp[1][i + 1], min(dp[1][i] + a, dp[0][i] + a));\n    }\n    for (int i = 0; i < 3; ++i) {\n      ans = min(ans, dp[i][n - 1]);\n    }\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 0x3f3f3f3f3f3f3f3fLL;\nconst int maxn = 100010;\nconst int maxp = 20010;\nint prime[maxp], prime_n;\nint divisors[maxn], divisorset[maxn], phi[maxn], mu[maxn];\nbool isprime[maxn];\nvoid gen(int n) {\n  prime_n = 0;\n  memset(isprime, 1, sizeof isprime);\n  isprime[0] = isprime[1] = 0;\n  phi[1] = 1;\n  for (int i = 2; i < n; ++i) {\n    if (isprime[i]) {\n      prime[prime_n++] = i;\n      divisors[i] = 1;\n      phi[i] = i - 1;\n      mu[i] = -1;\n    }\n    for (int j = 0, k; j < prime_n && (k = i * prime[j]) < n; ++j) {\n      isprime[k] = 0;\n      divisors[k] = divisors[i] + divisors[prime[j]];\n      if (!(i % prime[j])) {\n        phi[k] = phi[i] * prime[j];\n        divisorset[k] = divisorset[i];\n        mu[k] = 0;\n        break;\n      } else {\n        phi[k] = phi[i] * (prime[j] - 1);\n        divisorset[k] = divisorset[i] + 1;\n        mu[k] = -mu[i];\n      }\n    }\n  }\n}\nint pri[maxp * 6];\nint get_pri(int n, int *pri) {\n  int pri_n = 0;\n  for (int i = 0, p; (p = prime[i]) <= n / p; ++i)\n    if (n % p == 0) {\n      pri[pri_n] = p;\n      while (n % p == 0) n /= p;\n      ++pri_n;\n    }\n  if (n > 1) {\n    pri[pri_n] = n;\n    ++pri_n;\n  }\n  return pri_n;\n}\nconst int MAXN = 1000010;\nint n, A, B;\nint a[MAXN];\nlong long f[MAXN][3];\nlong long calc(int d) {\n  for (int i = 1; i <= n; ++i) {\n    f[i][1] = min(f[i - 1][0], f[i - 1][1]) + A;\n    if (a[i] % d == 0) {\n      f[i][0] = f[i - 1][0];\n      f[i][2] = min(f[i - 1][1], f[i - 1][2]);\n    } else if ((a[i] + 1) % d == 0 || (a[i] - 1) % d == 0) {\n      f[i][0] = f[i - 1][0] + B;\n      f[i][2] = min(f[i - 1][1], f[i - 1][2]) + B;\n    } else {\n      f[i][0] = INF;\n      f[i][2] = INF;\n    }\n  }\n  return min(f[n][0], min(f[n][1], f[n][2]));\n}\nvoid solve() {\n  scanf(\"%d%d%d\", &n, &A, &B);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", a + i);\n  int num = 0;\n  for (int d = -1; d <= 1; ++d) {\n    num += get_pri(a[1] + d, pri + num);\n    num += get_pri(a[n] + d, pri + num);\n  }\n  sort(pri, pri + num);\n  num = unique(pri, pri + num) - pri;\n  long long res = INF;\n  for (int i = 0; i < num; ++i) {\n    int p = pri[i];\n    long long x = calc(p);\n    res = min(res, x);\n  }\n  printf(\"%I64d\\n\", res);\n}\nint main() {\n  gen(100000);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nconst int INF = 1e9 + 100;\nconst LL INF64 = INF * 1LL * INF;\nvector<int> factorize(int x) {\n  vector<int> fact;\n  for (int i = 2; i * 1LL * i <= x; ++i) {\n    if (x % i == 0) {\n      fact.push_back(i);\n      while (x % i == 0) x /= i;\n    }\n  }\n  if (x > 1) {\n    fact.push_back(x);\n  }\n  return fact;\n}\nint is_good(int x, int pr) {\n  return x % pr == 0 || (x + 1) % pr == 0 || (x - 1) % pr == 0;\n}\nint cost(int x, int pr) {\n  if (x % pr == 0)\n    return 0;\n  else if ((x + 1) % pr == 0 || (x - 1) % pr == 0)\n    return 1;\n  else\n    return INF;\n}\nLL check(vector<int> &ar, int pr, LL a, LL b) {\n  vector<vector<LL>> dp(2, vector<LL>(3, INF64));\n  dp[0][0] = 0;\n  for (int i = 0; i < ar.size(); ++i) {\n    for (int j = 0; j < 3; ++j) {\n      if (j == 0) {\n        dp[!(i & 1)][0] =\n            min(dp[!(i & 1)][0], dp[i & 1][0] + cost(ar[i], pr) * b);\n      }\n      if (j == 1 || j == 0) {\n        dp[!(i & 1)][1] = min(dp[!(i & 1)][1], dp[i & 1][j] + a);\n        dp[!(i & 1)][2] = min(dp[!(i & 1)][2], dp[i & 1][j] + a);\n      }\n      if (j == 2) {\n        dp[!(i & 1)][2] =\n            min(dp[!(i & 1)][2], dp[i & 1][j] + cost(ar[i], pr) * b);\n      }\n    }\n    dp[i & 1][0] = dp[i & 1][1] = dp[i & 1][2] = INF64;\n  }\n  return min(dp[ar.size() & 1][0], dp[ar.size() & 1][2]);\n}\nvoid solve() {\n  int n, a, b;\n  cin >> n >> a >> b;\n  vector<int> ar(n);\n  for (auto &it : ar) cin >> it;\n  set<int> factors;\n  auto v = factorize(ar.front());\n  factors.insert(v.begin(), v.end());\n  v = factorize(ar.front() + 1);\n  factors.insert(v.begin(), v.end());\n  v = factorize(ar.front() - 1);\n  factors.insert(v.begin(), v.end());\n  v = factorize(ar.back());\n  factors.insert(v.begin(), v.end());\n  v = factorize(ar.back() + 1);\n  factors.insert(v.begin(), v.end());\n  v = factorize(ar.back() - 1);\n  factors.insert(v.begin(), v.end());\n  LL ans = INF * 1LL * INF;\n  for (auto pr : factors) {\n    ans = min(ans, check(ar, pr, a, b));\n  }\n  cout << ans << endl;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long powmod(long long a, long long b) {\n  long long res = 1;\n  a %= 1000000007;\n  for (; b; b >>= 1) {\n    if (b & 1) res = res * a % 1000000007;\n    a = a * a % 1000000007;\n  }\n  return res;\n}\nvector<int> pr;\nvoid gao(int x) {\n  for (int i = 2; i * i <= x; i++)\n    if (x % i == 0) {\n      pr.push_back(i);\n      while (x % i == 0) {\n        x /= i;\n      }\n    }\n  if (x != 1) pr.push_back(x);\n}\nlong long p1[3000100], p2[3000100];\nint aa[3000100];\nint n;\nint a, b;\nlong long solve(int x) {\n  p2[n + 1] = 0;\n  for (int i = n; i >= 1; i--) {\n    p2[i] = 1LL << 60;\n    if (aa[i] % x == 0)\n      p2[i] = p2[i + 1];\n    else if ((aa[i] + 1) % x == 0 || (aa[i] - 1) % x == 0)\n      p2[i] = p2[i + 1] + (long long)b;\n  }\n  p1[0] = 0;\n  for (int i = 1; i <= n; i++) {\n    p1[i] = 1LL << 60;\n    if (aa[i] % x == 0)\n      p1[i] = p1[i - 1];\n    else if ((aa[i] + 1) % x == 0 || (aa[i] - 1) % x == 0)\n      p1[i] = p1[i - 1] + (long long)b;\n  }\n  long long m = -a;\n  long long ans = 1LL << 60;\n  for (int i = 1; i <= n; i++) {\n    ans = min(ans, p2[i] + (long long)i * a + m);\n    m = min(m, p1[i] - (long long)(i + 1) * a);\n  }\n  for (int i = 1; i <= n; i++) {\n    ans = min(ans, p1[i] + (long long)(n - i) * a);\n  }\n  return ans;\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &a, &b);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &aa[i]);\n  gao(aa[1]);\n  gao(aa[1] - 1);\n  gao(aa[1] + 1);\n  gao(aa[n]);\n  gao(aa[n] - 1);\n  gao(aa[n] + 1);\n  long long ans = 1LL << 60;\n  for (auto p : pr) ans = min(ans, solve(p));\n  printf(\"%lld\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:134217728\")\nusing namespace std;\nvector<int> get_primes(int n) {\n  vector<int> res;\n  for (long long i = 2; i * i <= n; i++) {\n    if (n % i == 0) {\n      res.push_back(i);\n      while (n % i == 0) n /= i;\n    }\n  }\n  if (n != 1) res.push_back(n);\n  return res;\n}\nconst long long inf = 1e16;\nlong long get_min_first(const vector<int>& v, long long a, long long b) {\n  vector<int> f = get_primes(v[0]);\n  long long res = inf;\n  const int UNOPENED = 0;\n  const int OPENED = 1;\n  const int CLOSED = 2;\n  for (auto p : f) {\n    long long dp[3];\n    for (int i = 0; i < 3; i++) {\n      dp[i] = 0;\n    }\n    for (int i = 1; i < v.size(); i++) {\n      dp[OPENED] = min(dp[OPENED] + a, dp[UNOPENED] + a);\n      if (v[i] % p != 0) {\n        if ((v[i] + 1) % p == 0 || (v[i] - 1) % p == 0) {\n          dp[UNOPENED] += b;\n          dp[CLOSED] += b;\n        } else {\n          dp[UNOPENED] = inf;\n          dp[CLOSED] = inf;\n        }\n      }\n      dp[CLOSED] = min(dp[CLOSED], dp[OPENED]);\n    }\n    res = min(res, *min_element(dp, dp + 3));\n  }\n  return res;\n}\nint main() {\n  long long n, a, b;\n  cin >> n >> a >> b;\n  vector<int> v(n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &v[i]);\n  }\n  long long ans = inf;\n  ans = min(ans, get_min_first(v, a, b));\n  v[0]++;\n  ans = min(ans, b + get_min_first(v, a, b));\n  v[0] -= 2;\n  ans = min(ans, b + get_min_first(v, a, b));\n  v[0]++;\n  reverse(v.begin(), v.end());\n  ans = min(ans, get_min_first(v, a, b));\n  v[0]++;\n  ans = min(ans, b + get_min_first(v, a, b));\n  v[0] -= 2;\n  ans = min(ans, b + get_min_first(v, a, b));\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1000010;\nconst long long inf = 1000000000000000000L;\nint arr[N];\nlong long prefix[N], cost[N], suffix[N];\nset<int> factors;\nset<int>::iterator it;\nvoid pf(long long x) {\n  for (int i = x - 1; i <= x + 1; i++) {\n    int p = i;\n    for (int j = 2; j * j <= i; j++) {\n      if (p % j == 0) {\n        factors.insert(j);\n        while (p % j == 0) p /= j;\n      }\n    }\n    if (p != 1) factors.insert(p);\n  }\n}\nint main() {\n  int n, a, b, p;\n  scanf(\"%d %d %d\", &n, &a, &b);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &arr[i]);\n  if (n == 1) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  pf(arr[1]);\n  pf(arr[n]);\n  long long ans = inf;\n  for (it = factors.begin(); it != factors.end(); ++it) {\n    int p = *it;\n    prefix[0] = 0LL;\n    for (int i = 1; i <= n; i++) {\n      if (arr[i] % p == 0)\n        cost[i] = 0LL;\n      else if ((arr[i] + 1) % p == 0 || (arr[i] - 1) % p == 0)\n        cost[i] = (long long)b;\n      else\n        cost[i] = inf;\n      prefix[i] = prefix[i - 1] + cost[i];\n      if (prefix[i] > inf) prefix[i] = inf;\n    }\n    prefix[0] = inf;\n    suffix[n + 1] = 0LL;\n    long long suffix_sum = 0LL;\n    for (int i = n; i > 0; i--) {\n      suffix_sum += cost[i];\n      if (suffix_sum > inf) suffix_sum = inf;\n      suffix[i] = min(a + suffix[i + 1], suffix_sum);\n    }\n    ans = min(ans, suffix[1]);\n    for (int i = 2; i <= n; i++) {\n      ans = min(ans, prefix[i - 1] + suffix[i]);\n    }\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long arr[(int)(1e6 + 10)], n, a, b, ans = 1e16;\nvector<long long> d;\nvoid div(long long x) {\n  for (int i = 2; i * i <= x; i++) {\n    if (x % i == 0) {\n      d.push_back(i);\n      while (x % i == 0) x /= i;\n    }\n  }\n  if (x > 1) d.push_back(x);\n}\nlong long solve(long long x) {\n  long long op1 = 0, op2 = 0, op3 = 0, cur = 1e16;\n  for (int i = 1; i <= n; i++) {\n    cur = 1e16;\n    if (arr[i] % x == 0)\n      cur = 0;\n    else if ((arr[i] + 1) % x == 0 or (arr[i] - 1) % x == 0)\n      cur = b;\n    op1 += cur;\n    op2 += a;\n    op3 += cur;\n    op1 = min((long long)1e16, op1);\n    op2 = min(op1, op2);\n    op3 = min(op3, op2);\n  }\n  return op3;\n}\nint main() {\n  cin >> n >> a >> b;\n  for (int i = 1; i <= n; i++) scanf(\"%lld\", &arr[i]);\n  for (int i = -1; i <= 1; i++) div(arr[1] + i), div(arr[n] + i);\n  sort(d.begin(), d.end());\n  d.erase(unique(d.begin(), d.end()), d.end());\n  for (__typeof(d.begin()) i = d.begin(); i != d.end(); i++)\n    ans = min(ans, solve(*i));\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e6 + 10;\nconst long long INF = 0x3f3f3f3f3f3f3f3fLL;\nint m, n, a, b;\nint t[maxn];\nlong long d[maxn][3];\nvector<int> fac;\nlong long solve(int tt, int B) {\n  fac.clear();\n  for (int i = 2; i * i <= tt; ++i) {\n    if (tt % i == 0) {\n      fac.push_back(i);\n      if (i * i != tt) fac.push_back(tt / i);\n      while (tt % i == 0) tt /= i;\n    }\n    if (tt == 1) break;\n  }\n  if (tt > 1) fac.push_back(tt);\n  sort(fac.begin(), fac.end());\n  long long res = INF;\n  for (int i = 0; i < fac.size(); ++i) {\n    int pr = fac[i];\n    memset(d, INF, sizeof d);\n    d[1][0] = B;\n    for (int j = 2; j <= n; ++j) {\n      if (t[j - 1] % pr) {\n        if (t[j - 1] % pr == 1 || t[j - 1] % pr == pr - 1) {\n          d[j][0] = min(d[j][0], d[j - 1][0] + b);\n          d[j][2] = min(d[j][2], min(d[j - 1][1], d[j - 1][2]) + b);\n        }\n        d[j][1] = min(d[j][1], min(d[j - 1][0], d[j - 1][1]) + a);\n      } else {\n        d[j][0] = d[j - 1][0];\n        d[j][1] = min(d[j][1], d[j - 1][1] + a);\n        d[j][2] = min(d[j - 1][2], d[j - 1][1]);\n      }\n    }\n    res = min(res, min(d[n][0], min(d[n][1], d[n][2])));\n  }\n  return res;\n}\nint main() {\n  scanf(\"%d %d %d\", &n, &a, &b);\n  for (int i = 0; i < n; ++i) scanf(\"%d\", t + i);\n  long long ans = INF;\n  ans = min(ans, solve(t[0] - 1, b));\n  ans = min(ans, solve(t[0], 0));\n  ans = min(ans, solve(t[0] + 1, b));\n  reverse(t, t + n);\n  ans = min(ans, solve(t[0] - 1, b));\n  ans = min(ans, solve(t[0], 0));\n  ans = min(ans, solve(t[0] + 1, b));\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MX = 1e6 + 9, INF = 1e16;\nlong long arr[MX], dp[MX][3];\nset<long long> s;\nvoid FUN(long long x) {\n  if (x == 2) return;\n  for (long long i = 2; i * i <= x; i++)\n    while (x > 1 && x % i == 0) x /= i, s.insert(i);\n  if (x > 1) s.insert(x);\n}\nint32_t main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  long long n, a, b;\n  cin >> n >> a >> b;\n  for (long long i = 0; i < n; i++) cin >> arr[i];\n  FUN(arr[0] + 1);\n  FUN(arr[0]);\n  FUN(arr[0] - 1);\n  FUN(arr[n - 1] + 1);\n  FUN(arr[n - 1]);\n  FUN(arr[n - 1] - 1);\n  long long minn = 1e18;\n  for (long long x : s) {\n    dp[0][0] = dp[0][1] = dp[0][2] = 0;\n    for (long long i = 1; i <= n; i++) {\n      if (arr[i - 1] % x == 0 || arr[i - 1] % x == 1 ||\n          arr[i - 1] % x == x - 1) {\n        dp[i][0] = dp[i - 1][0] + b * (arr[i - 1] % x != 0);\n        dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + a;\n        dp[i][2] = min(dp[i - 1][1], dp[i - 1][2]) + b * (arr[i - 1] % x != 0);\n      } else {\n        dp[i][0] = dp[i][2] = INF;\n        dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + a;\n      }\n      dp[i][0] = min(INF, dp[i][0]), dp[i][1] = min(INF, dp[i][1]),\n      dp[i][2] = min(INF, dp[i][2]);\n    }\n    minn = min(min(minn, dp[n][0]), min(dp[n][1], dp[n][2]));\n  }\n  cout << minn;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9 + 7;\nconst long long maxn = 1e9 + 7;\nconst double PI = acos(-1);\nint prime[100000];\nint isprime[100000];\nint num;\nint ai[1000050];\nint ok[100000];\nvoid init() {\n  memset(prime, 0, sizeof(prime));\n  memset(isprime, 0, sizeof(isprime));\n  for (int i = 2; i < 100000; i++) {\n    if (!isprime[i]) {\n      prime[num++] = i;\n    }\n    for (int j = i * 2; j < 100000; j += i) {\n      isprime[j] = 1;\n    }\n  }\n}\nlong long n, a, b;\nlong long dp[1000050][3];\nlong long solve(int aa) {\n  for (int i = 0; i < n + 1; i++) {\n    for (int j = 0; j < 3; j++) dp[i][j] = 1e18;\n  }\n  dp[0][0] = 0;\n  dp[0][1] = 0;\n  for (int i = 0; i < n; i++) {\n    if (((ai[i] - 1) % aa == 0) || (((ai[i] + 1) % aa == 0))) {\n      dp[i + 1][0] = min(dp[i + 1][0], dp[i][0] + b);\n      dp[i + 1][1] = min(dp[i + 1][1], dp[i][0] + a);\n      dp[i + 1][1] = min(dp[i + 1][1], dp[i][1] + a);\n      dp[i + 1][2] = min(dp[i + 1][2], dp[i][1] + b);\n      dp[i + 1][2] = min(dp[i + 1][2], dp[i][2] + b);\n    } else if (ai[i] % aa == 0) {\n      dp[i + 1][0] = min(dp[i + 1][0], dp[i][0]);\n      dp[i + 1][1] = min(dp[i + 1][1], dp[i][1] + a);\n      dp[i + 1][2] = min(dp[i + 1][2], dp[i][1]);\n      dp[i + 1][2] = min(dp[i + 1][2], dp[i][2]);\n    } else {\n      dp[i + 1][1] = min(dp[i + 1][1], dp[i][0] + a);\n      dp[i + 1][1] = min(dp[i + 1][1], dp[i][1] + a);\n    }\n  }\n  long long res = min(dp[n][0], dp[n][1]);\n  res = min(res, dp[n][2]);\n  return res;\n}\nint main() {\n  cin >> n >> a >> b;\n  memset(ok, 0, sizeof(ok));\n  init();\n  for (int i = 0; i < n; i++) scanf(\"%d\", &ai[i]);\n  long long ans = 1e18;\n  long long zz = 0;\n  for (int j = -1; j <= 1; j++) {\n    int mm = ai[0] + j;\n    for (int i = 0; i < num; i++) {\n      if (mm % prime[i] == 0) {\n        while (mm % prime[i] == 0) mm /= prime[i];\n        if (ok[prime[i]]) continue;\n        ans = min(ans, solve(prime[i]));\n        ok[prime[i]] = 1;\n      }\n    }\n    if (mm != 1) {\n      ans = min(ans, solve(mm));\n      zz = mm;\n    }\n  }\n  for (int j = -1; j <= 1; j++) {\n    int mm = ai[n - 1] + j;\n    for (int i = 0; i < num; i++) {\n      if (mm % prime[i] == 0) {\n        while (mm % prime[i] == 0) mm /= prime[i];\n        if (ok[prime[i]]) continue;\n        ans = min(ans, solve(prime[i]));\n        ok[prime[i]] = 1;\n      }\n    }\n    if (mm != 1) {\n      ans = min(ans, solve(mm));\n      zz = mm;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 10;\nconst long long INF = 1e18;\nlong long dp[N][3];\nlong long val[N];\nlong long a, b;\nint n;\nvector<long long> gcd;\nvoid init(long long x) {\n  for (long long i = 2; i * i <= x; i++) {\n    if (x % i == 0) gcd.push_back(i);\n    while (x % i == 0) x /= i;\n  }\n  if (x != 1) gcd.push_back(x);\n}\nlong long solve(long long g) {\n  long long temp;\n  dp[0][0] = dp[0][1] = dp[0][2] = 0;\n  for (int i = 1; i <= n; i++) {\n    temp = 1e18;\n    if ((val[i] + 1) % g == 0 || (val[i] - 1) % g == 0) temp = b;\n    if (val[i] % g == 0) temp = 0;\n    dp[i][0] = dp[i - 1][0] + temp;\n    dp[i][0] = min(dp[i][0], INF);\n    dp[i][2] = min(dp[i - 1][1], dp[i - 1][2]) + temp;\n    dp[i][2] = min(dp[i][2], INF);\n    dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + a;\n    dp[i][1] = min(dp[i][1], INF);\n  }\n  return min(dp[n][0], min(dp[n][1], dp[n][2]));\n}\nint main() {\n  scanf(\"%d%I64d%I64d\", &n, &a, &b);\n  for (int i = 1; i <= n; i++) scanf(\"%I64d\", &val[i]);\n  gcd.clear();\n  init(val[1]);\n  init(val[1] + 1);\n  init(val[1] - 1);\n  init(val[n]);\n  init(val[n] + 1);\n  init(val[n] - 1);\n  sort(gcd.begin(), gcd.end());\n  gcd.erase(unique(gcd.begin(), gcd.end()), gcd.end());\n  long long ans = 2e18;\n  for (int i = 0; i < gcd.size(); i++) {\n    ans = min(solve(gcd[i]), ans);\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1) {\n  cerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args) {\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \" : \" << arg1 << \" | \";\n  __f(comma + 1, args...);\n}\nconst int N = 1e5 + 1;\nbool prime[N];\nmap<int, int> M;\nint A[10 * N];\nlong long dp[10 * N][3];\nint cur_prime, n, a, b;\nlong long solve(int ind, int flag) {\n  if (ind == 1) {\n    long long ret;\n    if (flag == 0) {\n      if (A[ind] % cur_prime == 0)\n        ret = 0;\n      else if ((A[ind] + 1) % cur_prime == 0 || (A[ind] - 1) % cur_prime == 0)\n        ret = (long long)b;\n      else\n        ret = (long long)1e16;\n    } else if (flag == 1) {\n      ret = (long long)a;\n    } else {\n      ret = (long long)a;\n    }\n    return ret;\n  }\n  if (dp[ind][flag] != -1) return dp[ind][flag];\n  long long& ret = dp[ind][flag];\n  ret = LLONG_MAX;\n  if (flag == 0) {\n    if (A[ind] % cur_prime == 0) {\n      ret = solve(ind - 1, 0);\n    } else if ((A[ind] + 1) % cur_prime == 0 || (A[ind] - 1) % cur_prime == 0) {\n      ret = b + solve(ind - 1, 0);\n    } else {\n      ret = (long long)1e16;\n    }\n  } else if (flag == 1) {\n    ret = min(solve(ind - 1, 0) + a, solve(ind - 1, 1) + a);\n  } else {\n    ret = min(ret, a + solve(ind - 1, 0));\n    ret = min(ret, a + solve(ind - 1, 1));\n    long long ty;\n    if (A[ind] % cur_prime == 0)\n      ty = 0;\n    else if ((A[ind] + 1) % cur_prime == 0 || (A[ind] - 1) % cur_prime == 0)\n      ty = b;\n    else\n      ty = (long long)1e16;\n    ret = min(ret, ty + solve(ind - 1, 2));\n  }\n  return ret;\n}\nvoid seive() {\n  for (int i = 2; i < N; i++) prime[i] = true;\n  for (int i = 2; i * i < N; i++) {\n    if (prime[i]) {\n      for (int j = 2 * i; j < N; j += i) {\n        prime[j] = false;\n      }\n    }\n  }\n}\nint main() {\n  seive();\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &a);\n  scanf(\"%d\", &b);\n  for (int i = 1; i < n + 1; i++) {\n    scanf(\"%d\", &A[i]);\n  }\n  if (n == 1) {\n    printf(\"%d\\n\", 0);\n    return 0;\n  }\n  vector<int> cand;\n  cand.push_back(A[1]);\n  cand.push_back(A[1] + 1);\n  cand.push_back(A[1] - 1);\n  cand.push_back(A[n]);\n  cand.push_back(A[n] + 1);\n  cand.push_back(A[n] - 1);\n  for (int x : cand) {\n    if (x == 1) continue;\n    for (int i = 1; i < N; i++) {\n      if (prime[i] && x % i == 0) {\n        M[i];\n        while (x % i == 0) x /= i;\n      }\n    }\n    if (x > 1) M[x];\n  }\n  long long ans = LLONG_MAX;\n  for (auto itr = M.begin(); itr != M.end(); ++itr) {\n    memset(dp, -1, sizeof(dp));\n    cur_prime = itr->first;\n    ans = min(ans, min(solve(n, 0), min(solve(n, 1), solve(n, 2))));\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class CF_624D implements Runnable {\n\tpublic static int[] arr;\n\tpublic static long a, b;\n\n\tpublic static void main(String[] args) {\n\t\t//new Thread(null, new CF_624D(), \"Solver\"/*, 1L << 288*/).start();\n\t\tnew CF_624D().run();\n\t}\n\n\tpublic static long[][] memo;\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\tFastScanner scan = new FastScanner(System.in);\n\t\tint n = scan.nextInt();\n\t\ta = scan.nextInt();\n\t\tb = scan.nextInt();\n\t\tarr = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarr[i] = scan.nextInt();//(int)(Math.random() * 1000000000)+2;//scan.nextInt();\n\t\t}\n\t\tArrayList<Integer> factorList = new ArrayList<>();\n\t\tHashSet<Integer> factorSet = new HashSet<>();\n\n\t\tint size = Math.max(arr[0] + 1, arr[arr.length - 1] + 1);\n\t\tArrayList<Integer> candidates = new ArrayList<>(6);\n\t\tfor (int dv = -1; dv <= 1; dv++) {\n\t\t\tif (!candidates.contains(arr[0] + dv))\n\t\t\t\tcandidates.add(arr[0] + dv);\n\t\t\tif (!candidates.contains(arr[arr.length - 1] + dv))\n\t\t\t\tcandidates.add(arr[arr.length - 1] + dv);\n\t\t}\n\t\t\n\t\tBitSet sieve = new BitSet((int) Math.ceil(Math.sqrt(size)) + 2);\n\t\tint sieveSize = sieve.size();\n\t\tArrayList<Integer> primes = new ArrayList<>();\n\t\tfor (int i = 2; i < sieveSize; i++) {\n\t\t\tif (sieve.get(i))\n\t\t\t\tcontinue;\n\t\t\tprimes.add(i);\n\t\t\t\n\t\t\t\n\t\t\tfor (long j = i * (long)i; j < sieveSize; j += i) {\n\t\t\t\tsieve.set((int)j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tsieve = null;\n\t\tSystem.gc();\n\t\tfor (int tmp : candidates) {\n\t\t\tint primeIdx = 0;\n\t\t\twhile (tmp > 1) {\n\t\t\t\tif (primeIdx >= primes.size()) {\n\t\t\t\t\tif (!factorSet.contains(tmp)) {\n\t\t\t\t\t\tfactorSet.add(tmp);\n\t\t\t\t\t\tfactorList.add(tmp);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint prime = primes.get(primeIdx);\n\t\t\t\tif (tmp % prime == 0) {\n\t\t\t\t\tif (!factorSet.contains(prime)) {\n\t\t\t\t\t\tfactorSet.add(prime);\n\t\t\t\t\t\tfactorList.add(prime);\n\t\t\t\t\t}\n\t\t\t\t\twhile (tmp % prime == 0) {\n\t\t\t\t\t\ttmp /= prime;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprimeIdx++;\n\t\t\t}\n\t\t}\n\t\tfactorSet = null;\n\t\tprimes = null;\n\t\tSystem.gc();\n\t\t\n\t\tlong minCost = Long.MAX_VALUE;\n\t\tmemo = new long[3][arr.length+1];\n\t\tfor (int factor : factorList) {\n\t\t\t\tfor (long[] mem : memo) {\n\t\t\t\t\tArrays.fill(mem, -1);\n\t\t\t\t\tmem[mem.length-1]= 0;\n\t\t\t\t}\n\t\t\tlong ans;\n\t\t\tlong go;\n\t\t\tfor(int index=arr.length-1;index>=0;index--) {\n\t\t\t\tint mod = arr[index] % factor;\n\t\t\t\tboolean works = mod == 0;\n\t\t\t\tboolean changeWorks = mod == 1 || mod == (factor-1);\n\t\t\t\t\tfor(int removeState = 0;removeState <= 2; removeState++) {\n\t\t\t\t\t\tans = Long.MAX_VALUE;\n\t\t\t\t\t\tswitch (removeState) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tif (works) {\n\t\t\t\t\t\t\t\tans = Math.min(ans,\n\t\t\t\t\t\t\t\t\t\tmemo[removeState][index + 1]);\n\t\t\t\t\t\t\t} else if (changeWorks) {\n\t\t\t\t\t\t\t\tgo = memo[removeState][index + 1];\n\t\t\t\t\t\t\t\tif(go != Long.MAX_VALUE)\n\t\t\t\t\t\t\t\t\tans = Math.min(ans, go + b);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tgo = memo[removeState][index+1];\n\t\t\t\t\t\t\tif(go != Long.MAX_VALUE)\n\t\t\t\t\t\t\t\tans = Math.min(ans, go + a);\n\t\t\t\t\t\t\tif (works) {\n\t\t\t\t\t\t\t\tans = Math.min(ans, memo[0][index+1]);\n\t\t\t\t\t\t\t} else if (changeWorks) {\n\t\t\t\t\t\t\t\tgo = memo[0][index+1];\n\t\t\t\t\t\t\t\tif(go != Long.MAX_VALUE)\n\t\t\t\t\t\t\t\t\tans = Math.min(ans, go + b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tif (works) {\n\t\t\t\t\t\t\t\tans = Math.min(ans,\n\t\t\t\t\t\t\t\t\t\tmemo[removeState][index+1]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlong goa2 = memo[1][index+1];\n\t\t\t\t\t\t\t\tif(goa2 != Long.MAX_VALUE)\n\t\t\t\t\t\t\t\t\tans = Math.min(ans, goa2 + a);\n\t\t\t\t\t\t\t\tif (changeWorks) {\n\t\t\t\t\t\t\t\t\tlong gob = memo[removeState][index+1];\n\t\t\t\t\t\t\t\t\tif(gob != Long.MAX_VALUE)\n\t\t\t\t\t\t\t\t\t\tans = Math.min(ans, gob + b);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//System.out.println(\"memo[\" + changeState + \"][\" + removeState + \"][\"\n\t\t\t\t\t\t//\t\t+ index + \"]=\" + ans);\n\n\t\t\t\t\t\tmemo[removeState][index] = ans;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t//long cost = go(factor, 0, 1, 2);\n\t\t\tlong cost = memo[2][0];\n\t\t\tminCost = Math.min(cost, minCost);\n\t\t}\n\t\tSystem.out.println(minCost);\n\t\t} catch(Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner(InputStream i) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(i));\n\t\t\tst = new StringTokenizer(\"\");\n\t\t}\n\n\t\tpublic FastScanner(File f) throws IOException {\n\t\t\tbr = new BufferedReader(new FileReader(f));\n\t\t\tst = new StringTokenizer(\"\");\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tif (st.hasMoreTokens())\n\t\t\t\treturn st.nextToken();\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn next();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n/*\n\tpublic static long go(int factor, int index, int changeState, int removeState) {\n\t\tif (index == arr.length) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (memo[changeState][removeState][index] != -1)\n\t\t\treturn memo[changeState][removeState][index];\n\t\tboolean works = arr[index] % factor == 0;\n\t\tboolean changeWorks = (arr[index] - 1) % factor == 0\n\t\t\t\t|| (arr[index] + 1) % factor == 0;\n\t\t//System.out.println(\"Called on idx \" + index + \" \" + works + \" [\" + changeWorks + \"]\");\n\t\tlong ans = Long.MAX_VALUE;\n\t\tswitch (removeState) {\n\t\tcase 0:\n\t\t\tif (works) {\n\t\t\t\tans = Math.min(ans,\n\t\t\t\t\t\tgo(factor, index + 1, changeState, removeState));\n\t\t\t} else if (changeWorks && changeState != 0) {\n\t\t\t\tlong go = go(factor, index + 1, 0, removeState);\n\t\t\t\tif(go != Long.MAX_VALUE)\n\t\t\t\t\tans = Math.min(ans, go + b);\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tlong goa = go(factor, index + 1, changeState, removeState);\n\t\t\tif(goa != Long.MAX_VALUE)\n\t\t\t\tans = Math.min(ans, goa\t+ a);\n\t\t\tif (works) {\n\t\t\t\tans = Math.min(ans, go(factor, index + 1, changeState, 0));\n\t\t\t} else if (changeWorks && changeState != 0) {\n\t\t\t\tlong gob = go(factor, index + 1, 0, 0);\n\t\t\t\tif(gob != Long.MAX_VALUE)\n\t\t\t\t\tans = Math.min(ans, gob + b);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (works) {\n\t\t\t\tans = Math.min(ans,\n\t\t\t\t\t\tgo(factor, index + 1, changeState, removeState));\n\t\t\t} else {\n\t\t\t\tlong goa2 = go(factor, index + 1, changeState, 1);\n\t\t\t\tif(goa2 != Long.MAX_VALUE)\n\t\t\t\t\tans = Math.min(ans, goa2 + a);\n\t\t\t\tif (changeWorks && removeState != 0) {\n\t\t\t\t\tlong gob = go(factor, index + 1, 0, removeState);\n\t\t\t\t\tif(gob != Long.MAX_VALUE)\n\t\t\t\t\t\tans = Math.min(ans, gob + b);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t//System.out.println(\"memo[\" + changeState + \"][\" + removeState + \"][\"\n\t\t//\t\t+ index + \"]=\" + ans);\n\n\t\treturn memo[changeState][removeState][index] = ans;\n\t}*/\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, tot;\nlong long A, B, a[1000005], ans = 1ll << 60, f[1000005][3];\nvoid Cal(long long x) {\n  long long sum, w;\n  for (int i = 1; i <= n; i++) {\n    if (a[i] % x == 0)\n      w = 0;\n    else if (a[i] % x == 1 || a[i] % x == x - 1)\n      w = B;\n    else\n      w = 1ll << 35;\n    f[i][0] = f[i - 1][0] + w;\n    f[i][1] = min(f[i - 1][0], f[i - 1][1]) + A;\n    f[i][2] = min(f[i - 1][1], f[i - 1][2]) + w;\n  }\n  sum = min(f[n][0], min(f[n][1], f[n][2]));\n  ans = min(sum, ans);\n}\nvoid Push(long long x) {\n  if (x <= 1) return;\n  long long t = x;\n  for (long long i = 2; i * i <= x; i++) {\n    if (t % i == 0) {\n      Cal(i);\n      while (t % i == 0) t /= i;\n    }\n    if (t == 1) break;\n  }\n  if (t != 1) Cal(t);\n}\nint main() {\n  scanf(\"%d%I64d%I64d\", &n, &A, &B);\n  for (int i = 1; i <= n; i++) scanf(\"%I64d\", &a[i]);\n  Push(a[1]);\n  Push(a[1] - 1);\n  Push(a[1] + 1);\n  Push(a[n]);\n  Push(a[n] - 1);\n  Push(a[n] + 1);\n  printf(\"%I64d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 5;\nset<int> p;\nint A[N];\nint n;\nlong long a, b;\nint mark[N];\nlong long prefix[N], suffix[N];\nlong long ans = LLONG_MAX;\nvoid compute(int x) {\n  memset(mark, 0, sizeof mark);\n  memset(prefix, -1, sizeof prefix);\n  memset(suffix, -1, sizeof suffix);\n  for (int i = 1; i <= n; i++) {\n    if ((A[i] % x) == 0)\n      continue;\n    else if ((A[i] % x) == 1 or (A[i] % x) == x - 1)\n      mark[i] = 1;\n    else\n      mark[i] = 2;\n  }\n  prefix[0] = suffix[n + 1] = 0;\n  for (int i = 1; i <= n; i++) {\n    if (mark[i] == 2)\n      break;\n    else\n      prefix[i] = prefix[i - 1] + (mark[i] == 1);\n  }\n  for (int i = n; i >= 1; i--) {\n    if (mark[i] == 2)\n      break;\n    else\n      suffix[i] = suffix[i + 1] + (mark[i] == 1);\n  }\n  for (int i = n; i >= 1; i--) {\n    if (suffix[i] == -1) break;\n    ans = min(ans, suffix[i] * b + (i - 1) * 1LL * a);\n  }\n  suffix[n + 1] = (n + 1) * 1LL * a;\n  for (int i = n; i >= 1; i--) {\n    if (suffix[i] == -1)\n      suffix[i] = suffix[i + 1];\n    else\n      suffix[i] = min(suffix[i + 1], suffix[i] * b + i * 1LL * a);\n  }\n  for (int i = 1; i <= n; i++) {\n    if (prefix[i] == -1) break;\n    ans = min(ans, prefix[i] * b + suffix[i + 1] - a * 1LL * (i + 1));\n  }\n}\nvoid solve(int x) {\n  if (x == 1) return;\n  p.clear();\n  for (long long i = 2; i * i <= x;) {\n    if ((x % i) == 0) {\n      p.insert(i);\n      x /= i;\n    } else\n      i++;\n  }\n  if (x != 1) p.insert(x);\n  for (auto it : p) compute(it);\n}\nint main() {\n  cin >> n >> a >> b;\n  for (int i = 1; i <= n; i++) cin >> A[i];\n  solve(A[1]);\n  solve(A[1] + 1);\n  solve(A[1] - 1);\n  solve(A[n]);\n  solve(A[n] + 1);\n  solve(A[n] - 1);\n  cout << ans;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\n\npublic class D {\n    public static void solution(BufferedReader reader, PrintWriter out)\n            throws IOException {\n        In in = new In(reader);\n        n = in.nextInt();\n        a = in.nextInt();\n        b = in.nextInt();\n        d = new int[n];\n        for (int i = 0; i < n; i++)\n            d[i] = in.nextInt();\n        for (int j = -1; j <= 1; j++) {\n            fact(d[0] + j);\n            fact(d[n - 1] + j);\n        }\n        long res = (n - 1L) * a;\n        for (Integer fa : f)\n            res = Math.min(res, solve(fa));\n        out.println(res);\n    }\n\n    private static int n, a, b;\n    private static int[] d;\n    private static HashSet<Integer> f = new HashSet<Integer>();\n\n    private static void fact(int n) {\n        for (int i = 2; i * i <= n; i++)\n            if (n % i == 0) {\n                f.add(i);\n                while (n % i == 0)\n                    n /= i;\n            }\n        if (n > 1)\n            f.add(n);\n    }\n\n    private static long MAX = (long) 1e16;\n    private static long[][] dp;\n\n    private static void update(int i, int j, long v) {\n        if (v < dp[i][j])\n            dp[i][j] = v;\n    }\n\n    private static long solve(int gcd) {\n        dp = new long[3][n];\n        Arrays.fill(dp[0], MAX);\n        Arrays.fill(dp[1], MAX);\n        Arrays.fill(dp[2], MAX);\n        if (d[0] % gcd == 0)\n            dp[0][0] = 0;\n        else if ((d[0] - 1) % gcd == 0 || (d[0] + 1) % gcd == 0)\n            dp[0][0] = b;\n        dp[1][0] = a;\n        dp[2][0] = a;\n        for (int i = 1; i < n; i++) {\n            update(1, i, Math.min(dp[0][i - 1], dp[1][i - 1]) + a);\n            update(2, i, dp[1][i]);\n            if (d[i] % gcd == 0) {\n                update(0, i, dp[0][i - 1]);\n                update(2, i, dp[2][i - 1]);\n            }\n            else if ((d[i] - 1) % gcd == 0 || (d[i] + 1) % gcd == 0) {\n                update(0, i, dp[0][i - 1] + b);\n                update(2, i, dp[2][i - 1] + b);\n            }\n        }\n        return Math.min(dp[0][n - 1], dp[2][n - 1]);\n    }\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader reader = new BufferedReader(\n                new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(\n                new BufferedWriter(new OutputStreamWriter(System.out)));\n        solution(reader, out);\n        out.close();\n    }\n\n    protected static class In {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer = new StringTokenizer(\"\");\n\n        public In(BufferedReader reader) {\n            this.reader = reader;\n        }\n\n        public String next() throws IOException {\n            while (!tokenizer.hasMoreTokens())\n                tokenizer = new StringTokenizer(reader.readLine());\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MAX = 1e18 + 10;\nlong long n, a, b;\nlong long x[1000100], f[1000100], g[1000100];\nvector<long long> prime;\nbool isprime[1000100];\nset<long long> s;\nvoid getPrime() {\n  int i, j;\n  for (i = 0; i < 1000100; i++) isprime[i] = true;\n  isprime[0] = isprime[1] = 0;\n  for (i = 2; i < 1000100; i++) {\n    if (!isprime[i]) continue;\n    for (j = 2 * i; j < 1000100; j += i) isprime[j] = false;\n  }\n  prime.clear();\n  for (i = 2; i < 1000100; i++) prime.push_back(i);\n}\nlong long change(long long a, long long p) {\n  if (a % p == 0) return 0;\n  if ((a + 1) % p == 0 || (a - 1) % p == 0) return b;\n  return -1;\n}\nlong long Solve(long long p) {\n  int L = n + 1, R = 0, i, tag = 0;\n  long long t, G, res;\n  f[0] = 0;\n  for (i = 1; i <= n; i++) {\n    t = change(x[i], p);\n    if (t == -1) {\n      L = i;\n      tag = 1;\n    }\n    if (tag)\n      f[i] = MAX;\n    else\n      f[i] = f[i - 1] + t;\n  }\n  g[n + 1] = 0;\n  tag = 0;\n  for (i = n; i > 0; i--) {\n    t = change(x[i], p);\n    if (t == -1) {\n      R = i;\n      tag = 1;\n    }\n    if (tag)\n      g[i] = MAX;\n    else\n      g[i] = g[i + 1] + t;\n  }\n  G = g[n + 1] + (n + 1) * a;\n  res = f[n];\n  for (i = n; i >= 0; i--) {\n    res = min(res, f[i] - (i + 1) * a + G);\n    G = min(G, g[i] + i * a);\n  }\n  return res;\n}\nvoid Get(long long a) {\n  if (a == 0 || a == 1) return;\n  int i, l = prime.size(), t;\n  for (i = 0; i < l; i++) {\n    t = prime[i];\n    if (t * t > a) break;\n    while (a % t == 0) {\n      if (s.find(t) == s.end()) s.insert(t);\n      a /= t;\n    }\n  }\n  if (a > 1) s.insert(a);\n}\nvoid Init() {\n  s.clear();\n  Get(x[1]);\n  Get(x[1] + 1);\n  Get(x[1] - 1);\n  Get(x[n]);\n  Get(x[n] + 1);\n  Get(x[n] - 1);\n}\nint main() {\n  int i, j;\n  long long ans;\n  set<long long>::iterator it;\n  getPrime();\n  scanf(\"%I64d%I64d%I64d\", &n, &a, &b);\n  for (i = 1; i <= n; i++) scanf(\"%I64d\", &x[i]);\n  Init();\n  ans = MAX;\n  for (it = s.begin(); it != s.end(); it++) ans = min(ans, Solve(*it));\n  printf(\"%I64d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, a, b, res;\nlong long dp[1000100][3];\nvector<long long> vet;\nset<long long> primes;\nbool is_prime(long long val) {\n  bool prime = true;\n  for (long long i = 2; i * i <= val; i++) {\n    if (val % i) continue;\n    prime = false;\n    break;\n  }\n  return prime;\n}\nvoid decompose(long long num) {\n  for (long long i = 2; i * i <= num; i++) {\n    if (!is_prime(i)) continue;\n    if (!(num % i)) {\n      primes.insert(i);\n      primes.insert(num / i);\n    }\n  }\n  if (is_prime(num)) primes.insert(num);\n}\nbool one_diff(long long val, long long p) {\n  return (val % p == 1 || val % p == p - 1);\n}\nlong long fmin(long long a, long long b) {\n  if (a < b) return a;\n  return b;\n}\nlong long f(long long p) {\n  dp[0][0] = 0;\n  dp[0][1] = 0;\n  dp[0][2] = 0;\n  long long inc;\n  for (int j = 1; j <= n; j++) {\n    if (one_diff(vet[j - 1], p))\n      inc = b;\n    else if (!(vet[j - 1] % p))\n      inc = 0;\n    else\n      inc = -1;\n    if (inc == -1) {\n      dp[j][0] = -1;\n      dp[j][2] = -1;\n      if (dp[j - 1][0] == -1)\n        dp[j][1] = dp[j - 1][1] + a;\n      else\n        dp[j][1] = fmin(dp[j - 1][0], dp[j - 1][1]) + a;\n      continue;\n    }\n    if (dp[j - 1][0] == -1)\n      dp[j][0] = -1;\n    else\n      dp[j][0] = dp[j - 1][0] + inc;\n    if (j == 1 && !one_diff(vet[n - 1], p) && vet[n - 1] % p)\n      dp[j][1] = inc;\n    else {\n      dp[j][1] = dp[j - 1][1] + a;\n      if (dp[j - 1][0] != -1) dp[j][1] = fmin(dp[j][1], dp[j - 1][0] + a);\n    }\n    dp[j][2] = dp[j - 1][1] + inc;\n    if (dp[j - 1][2] != -1) dp[j][2] = fmin(dp[j][2], dp[j - 1][2] + inc);\n  }\n  long long acm;\n  acm = dp[n][1];\n  if (dp[n][0] != -1) acm = fmin(acm, dp[n][0]);\n  if (dp[n][2] != -1) acm = fmin(acm, dp[n][2]);\n  return acm;\n}\nint main() {\n  cin >> n >> a >> b;\n  vet = vector<long long>(n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%I64d\", &vet[i]);\n  }\n  for (int i = -1; i <= 1; i++) {\n    decompose(vet[0] + i);\n    decompose(vet[n - 1] + i);\n  }\n  res = (long long)1000000007 * (long long)1000000007;\n  for (set<long long>::iterator it = primes.begin(); it != primes.end(); it++)\n    res = fmin(res, f(*it));\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1000005;\nint n, A, B, a[maxn];\nlong long dp[maxn][3];\nlong long solve(int x, int y) {\n  if (x == 1) return LLONG_MAX;\n  vector<int> facs;\n  for (int i = 2; i * i <= x; i++) {\n    if (x % i == 0) {\n      facs.push_back(i);\n      while (x % i == 0) x /= i;\n    }\n  }\n  if (x > 1) facs.push_back(x);\n  long long ans = LLONG_MAX;\n  for (int j = 0; j < facs.size(); j++) {\n    memset(dp, 0x3f, sizeof(dp));\n    dp[1][0] = y;\n    for (int i = 2; i <= n; i++) {\n      if ((a[i] - 1) % facs[j] == 0) {\n        dp[i][0] = min(dp[i][0], dp[i - 1][0] + B);\n        dp[i][2] = min(dp[i][2], min(dp[i - 1][1], dp[i - 1][2]) + B);\n      }\n      if ((a[i] + 1) % facs[j] == 0) {\n        dp[i][0] = min(dp[i][0], dp[i - 1][0] + B);\n        dp[i][2] = min(dp[i][2], min(dp[i - 1][1], dp[i - 1][2]) + B);\n      }\n      if (a[i] % facs[j] == 0) {\n        dp[i][0] = min(dp[i][0], dp[i - 1][0]);\n        dp[i][2] = min(dp[i][2], min(dp[i - 1][1], dp[i - 1][2]));\n      }\n      dp[i][1] = min(dp[i][1], min(dp[i - 1][0], dp[i - 1][1]) + A);\n    }\n    ans = min(ans, dp[n][0]);\n    ans = min(ans, dp[n][1]);\n    ans = min(ans, dp[n][2]);\n  }\n  return ans;\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &A, &B);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  long long ans = LLONG_MAX;\n  ans = min(ans, solve(a[1] - 1, B));\n  ans = min(ans, solve(a[1], 0));\n  ans = min(ans, solve(a[1] + 1, B));\n  reverse(a + 1, a + 1 + n);\n  ans = min(ans, solve(a[1] - 1, B));\n  ans = min(ans, solve(a[1], 0));\n  ans = min(ans, solve(a[1] + 1, B));\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\n\npublic class D {\n    public static void solution(BufferedReader reader, PrintWriter out)\n            throws IOException {\n        In in = new In(reader);\n        n = in.nextInt();\n        a = in.nextInt();\n        b = in.nextInt();\n        d = new int[n + 1];\n        for (int i = 1; i <= n; i++)\n            d[i] = in.nextInt();\n        for (int j = -1; j <= 1; j++) {\n            fact(d[1] + j);\n            fact(d[n] + j);\n        }\n        long res = MAX = (n - 1L) * a;\n        for (Integer fa : f)\n            res = Math.min(res, solve(fa));\n        out.println(res);\n    }\n\n    private static int n, a, b;\n    private static int[] d;\n    private static HashSet<Integer> f = new HashSet<Integer>();\n\n    private static void fact(int n) {\n        for (int i = 2; i * i <= n; i++)\n            if (n % i == 0) {\n                f.add(i);\n                while (n % i == 0)\n                    n /= i;\n            }\n        if (n > 1)\n            f.add(n);\n    }\n\n    private static long MAX;\n\n    private static long solve(int gcd) {\n        long[][] dp = new long[3][n + 1];\n        for (int i = 0; i < 3; i++)\n            Arrays.fill(dp[i], MAX);\n        dp[0][0] = dp[1][0] = dp[2][0] = 0;\n        for (int i = 1; i <= n; i++) {\n            dp[1][i] = dp[2][i] = Math.min(dp[0][i - 1], dp[1][i - 1]) + a;\n            if (d[i] % gcd == 0) {\n                dp[0][i] = dp[0][i - 1];\n                dp[2][i] = Math.min(dp[2][i], dp[2][i - 1]);\n            }\n            else if ((d[i] - 1) % gcd == 0 || (d[i] + 1) % gcd == 0) {\n                dp[0][i] = dp[0][i - 1] + b;\n                dp[2][i] = Math.min(dp[2][i], dp[2][i - 1] + b);\n            }\n            for (int j = 0; j < 3; j++)\n                if (dp[j][i] > MAX)\n                    dp[j][i] = MAX;\n        }\n        return Math.min(dp[0][n], dp[2][n]);\n    }\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader reader = new BufferedReader(\n                new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(\n                new BufferedWriter(new OutputStreamWriter(System.out)));\n        solution(reader, out);\n        out.close();\n    }\n\n    protected static class In {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer = new StringTokenizer(\"\");\n\n        public In(BufferedReader reader) {\n            this.reader = reader;\n        }\n\n        public String next() throws IOException {\n            while (!tokenizer.hasMoreTokens())\n                tokenizer = new StringTokenizer(reader.readLine());\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace output {\nvoid pr(short x) { cout << x; }\nvoid pr(unsigned x) { cout << x; }\nvoid pr(int x) { cout << x; }\nvoid pr(long long x) { cout << x; }\nvoid pr(unsigned long long x) { cout << x; }\nvoid pr(double x) { cout << x; }\nvoid pr(long double x) { cout << x; }\nvoid pr(char x) { cout << x; }\nvoid pr(const char* x) { cout << x; }\nvoid pr(const string& x) { cout << x; }\nvoid pr(bool x) { cout << (x ? \"true\" : \"false\"); }\ntemplate <class S, class T>\nvoid pr(const pair<S, T>& x) {\n  pr(0 ? \"(\" : \"\"), pr(x.first), pr(0 ? \", \" : \" \"), pr(x.second),\n      pr(0 ? \")\" : \"\");\n}\ntemplate <class T>\nvoid pr(const vector<T>& x) {\n  pr(0 ? \"{\" : \"\");\n  bool _ = 0;\n  for (const auto& v : x) pr(_ ? 0 ? \", \" : \" \" : \"\"), pr(v), _ = 1;\n  pr(0 ? \"}\" : \"\");\n}\ntemplate <class T>\nvoid pr(const set<T>& x) {\n  pr(0 ? \"{\" : \"\");\n  bool _ = 0;\n  for (const auto& v : x) pr(_ ? 0 ? \", \" : \" \" : \"\"), pr(v), _ = 1;\n  pr(0 ? \"}\" : \"\");\n}\ntemplate <class T>\nvoid pr(const multiset<T>& x) {\n  pr(0 ? \"{\" : \"\");\n  bool _ = 0;\n  for (const auto& v : x) pr(_ ? 0 ? \", \" : \" \" : \"\"), pr(v), _ = 1;\n  pr(0 ? \"}\" : \"\");\n}\ntemplate <class S, class T>\nvoid pr(const map<S, T>& x) {\n  pr(0 ? \"{\" : \"\");\n  bool _ = 0;\n  for (const auto& v : x) pr(_ ? 0 ? \", \" : \" \" : \"\"), pr(v), _ = 1;\n  pr(0 ? \"}\" : \"\");\n}\ntemplate <class S, class... T>\nvoid pr(const S& a, const T&... b) {\n  pr(a);\n  if (sizeof...(b))\n    pr(\" \"), pr(b...);\n  else\n    pr(\"\\n\");\n}\n}  // namespace output\nusing namespace output;\nconst long long MN = 1e6 + 6, inf = 1LL << 60;\nlong long n, a, b, arr[MN], dp[MN][3], i, j, ans;\nlong long chk(long long p, long long s, long long e) {\n  for (long long j = 0; j < 3; j++) dp[s - 1][j] = 0;\n  for (long long i = s; i <= e; i++) {\n    for (long long j = 0; j < 3; j++) dp[i][j] = inf;\n    long long k = arr[i] / p, t = k * p;\n    dp[i][1] = min(dp[i - 1][1], dp[i - 1][0]) + a;\n    if (t == arr[i]) {\n      dp[i][2] = min(dp[i - 1][2], dp[i - 1][1]);\n      dp[i][0] = dp[i - 1][0];\n    } else if (t == arr[i] - 1 || t + p == arr[i] + 1) {\n      dp[i][2] = min(dp[i - 1][2], dp[i - 1][1]) + b;\n      dp[i][0] = dp[i - 1][0] + b;\n    }\n  }\n  long long res = inf;\n  for (long long j = 0; j < 3; j++) res = min(res, dp[e][j]);\n  return res;\n}\nlong long go(long long t, long long s, long long e) {\n  if (t <= 1) return inf;\n  long long r = t, res = inf;\n  for (long long i = 2; i * i <= t; i++) {\n    if (r % i == 0) {\n      while (r % i == 0) r /= i;\n      res = min(res, chk(i, s, e));\n    }\n  }\n  if (r != 1) res = min(res, chk(r, s, e));\n  return res;\n}\nint main() {\n  scanf(\"%lld%lld%lld\", &n, &a, &b);\n  ans = inf;\n  for (i = 1; i <= n; i++) scanf(\"%lld\", &arr[i]);\n  if (n == 1)\n    pr(arr[1] > 1 ? 0 : b);\n  else {\n    for (i = -1; i <= 1; i++) {\n      ans = min(ans, go(arr[1] + i, 2, n) + abs(i) * b);\n      ans = min(ans, go(arr[n] + i, 1, n - 1) + abs(i) * b);\n    }\n    pr(ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long int> v;\nlong long int dp[1000002][3];\nbool val[40002];\nset<long long int> s;\nvoid get(long long int z) {\n  long long int i, p;\n  bool f = false;\n  p = v.size();\n  for (i = 0; i < p; i++) {\n    f = false;\n    while (z % v[i] == 0) {\n      z = z / v[i];\n      f = true;\n    }\n    if (f == true) s.insert(v[i]);\n    if (z != 1) s.insert(z);\n  }\n}\nint main() {\n  long long int a, b, c, d = 1e18, e, i, j, p, q, t = 1e18;\n  long long int y[1000002];\n  cin >> a >> b >> c;\n  for (i = 1; i <= a; i++) {\n    scanf(\"%lld\", &y[i]);\n  }\n  for (i = 2; i <= 40000; i++) {\n    if (val[i]) continue;\n    v.push_back(i);\n    for (j = i; j <= 40000; j = j + i) val[j] = false;\n  }\n  get(y[1]);\n  get(y[1] - 1);\n  get(y[1] + 1);\n  get(y[a]);\n  get(y[a] + 1);\n  get(y[a] - 1);\n  q = s.size();\n  for (set<long long int>::iterator it = s.begin(); it != s.end(); it++) {\n    e = *it;\n    if (y[1] % e == 0) {\n      dp[1][0] = 0;\n    } else if ((y[1] + 1) % e == 0) {\n      dp[1][0] = c;\n    } else if ((y[1] - 1) % e == 0) {\n      dp[1][0] = c;\n    } else\n      dp[1][0] = t;\n    dp[1][1] = b;\n    dp[1][2] = b;\n    for (i = 2; i <= a; i++) {\n      if (y[i] % e == 0) {\n        dp[i][0] = dp[i - 1][0];\n        dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + b;\n        dp[i][2] = min(dp[i][1], dp[i - 1][2]);\n      } else if (((y[i] - 1) % e == 0) || ((y[i] + 1) % e == 0)) {\n        dp[i][0] = dp[i - 1][0] + c;\n        dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + b;\n        dp[i][2] = min(dp[i][1], dp[i - 1][2] + c);\n      } else {\n        dp[i][0] = t;\n        dp[i][1] = dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + b;\n        dp[i][2] = dp[i][1];\n      }\n    }\n    d = min(d, dp[a][0]);\n    d = min(d, dp[a][1]);\n    d = min(d, dp[a][2]);\n  }\n  cout << d;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline void upmax(T& a, T b) {\n  if (a < b) a = b;\n}\ntemplate <class T>\ninline void upmin(T& a, T b) {\n  if (a > b) a = b;\n}\nconst int maxn = 1000007;\nconst int maxm = 200007;\nconst int mod = 1000000007;\nconst long long inf = 0x3f3f3f3f3f3f3f3f;\nconst double eps = 1e-7;\ntypedef int arr[maxn];\ntypedef int adj[maxm];\ninline int fcmp(double a, double b) {\n  if (fabs(a - b) <= eps) return 0;\n  if (a < b - eps) return -1;\n  return 1;\n}\ninline int add(int a, int b) { return ((long long)a + b) % mod; }\ninline int mul(int a, int b) { return ((long long)a * b) % mod; }\ninline int dec(int a, int b) { return add(a, mod - b % mod); }\ninline int Pow(int a, int b) {\n  int t = 1;\n  while (b) {\n    if (b & 1) t = mul(t, a);\n    a = mul(a, a), b >>= 1;\n  }\n  return t;\n}\ntemplate <typename Type>\ninline Type RD() {\n  char c = getchar();\n  Type x = 0, flag = 1;\n  while (!isdigit(c) && c != '-') c = getchar();\n  if (c == '-')\n    flag = -1;\n  else\n    x = c - '0';\n  while (isdigit(c = getchar())) x = x * 10 + c - '0';\n  return x * flag;\n}\ninline char rdch() {\n  char c = getchar();\n  while (!isalpha(c)) c = getchar();\n  return c;\n}\nconst int N = 100000;\narr pr, vis;\nint ptt;\ninline void sieve() {\n  for (int i = 2, _ = N; i <= _; i++) {\n    if (!vis[i]) pr[++ptt] = i;\n    for (int j = 1, _ = ptt; j <= _; j++)\n      if (pr[j] * i > N)\n        break;\n      else {\n        vis[pr[j] * i] = 1;\n        if (i % pr[j] == 0) break;\n      }\n  }\n}\nint fact[120], tot;\ninline void gf(int n) {\n  int m = (int)(sqrt(n) + 0.5);\n  for (int i = 1, _ = ptt; i <= _; i++)\n    if (pr[i] > m)\n      break;\n    else if (n % pr[i] == 0) {\n      fact[++tot] = pr[i];\n      while (n % pr[i] == 0) n /= pr[i];\n    }\n  if (n != 1) fact[++tot] = n;\n}\narr v;\nint n, a, b;\nvoid input() {\n  n = RD<int>(), a = RD<int>(), b = RD<int>();\n  for (int i = 1, _ = n; i <= _; i++) v[i] = RD<int>();\n  gf(v[1]), gf(v[1] + 1), gf(v[1] - 1);\n  gf(v[n]), gf(v[n] + 1), gf(v[n] - 1);\n  sort(fact + 1, fact + tot + 1);\n  tot = unique(fact + 1, fact + tot + 1) - fact - 1;\n}\nlong long f[maxn][4];\ninline long long dp(int p) {\n  memset(f, (0x3f), sizeof(f));\n  f[0][0] = 0;\n  for (int i = 1, _ = n; i <= _; i++) {\n    if (i == 1) {\n      f[i][1] = a;\n    }\n    if (v[i] % p == 0) {\n      if (i != n) upmin(f[i][3], f[i - 1][1]);\n      upmin(f[i][0], f[i - 1][0]);\n      upmin(f[i][3], min(f[i - 1][2], f[i - 1][3]));\n    }\n    if (i != n) upmin(f[i][1], f[i - 1][1] + a);\n    upmin(f[i][2], min(f[i - 1][2], f[i - 1][0]) + a);\n    if ((v[i] + 1) % p == 0 || (v[i] - 1) % p == 0) {\n      upmin(f[i][0], f[i - 1][0] + b), upmin(f[i][3], f[i - 1][2] + b);\n      upmin(f[i][3], f[i - 1][3] + b);\n      if (i != n) upmin(f[i][3], f[i - 1][1] + b);\n    }\n  }\n  long long ret = inf;\n  for (int i = 0, _ = 3; i <= _; i++) upmin(ret, f[n][i]);\n  return ret;\n}\nvoid solve() {\n  long long ans = inf;\n  for (int i = 1, _ = tot; i <= _; i++) {\n    upmin(ans, dp(fact[i]));\n  }\n  cout << ans << \"\\n\";\n}\nint main() {\n  sieve();\n  input();\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n;\nlong long a, b;\nset<int> primes;\nvoid func(int num) {\n  for (int i = 2; i * i <= num; i++) {\n    if (num % i == 0) {\n      primes.insert(i);\n      while (num % i == 0) num /= i;\n    }\n  }\n  if (num != 1) primes.insert(num);\n}\nlong long calc(vector<int> &A, int p) {\n  int si = -1, ei = -1;\n  vector<long long> val(n + 3, 0);\n  for (int i = 1; i <= n; i++) {\n    if (A[i] % p == 0) {\n      val[i] = 0;\n    } else {\n      if (((A[i] - 1) % p == 0) || (A[i] + 1) % p == 0) {\n        val[i] = b;\n      } else {\n        val[i] = -1;\n        si = i;\n        break;\n      }\n    }\n  }\n  for (int i = n; i >= 1; i--) {\n    if (A[i] % p == 0) {\n      val[i] = 0;\n    } else {\n      if (((A[i] - 1) % p == 0) || (A[i] + 1) % p == 0) {\n        val[i] = b;\n      } else {\n        val[i] = -1;\n        ei = i;\n        break;\n      }\n    }\n  }\n  if (si == -1) {\n    for (int i = 2; i <= n; i++) {\n      val[i] += val[i - 1];\n    }\n    vector<long long> arr(n + 3);\n    arr[1] = a;\n    long long v = min(val[n], a + val[n] - val[1]);\n    for (int i = 2; i <= n; i++) {\n      arr[i] = min(arr[i - 1], val[i - 1]) + a;\n      v = min(v, arr[i] + val[n] - val[i]);\n    }\n    return v;\n  } else {\n    for (int i = 2; i < si; i++) {\n      val[i] += val[i - 1];\n    }\n    for (int i = n - 1; i > ei; i--) {\n      val[i] += val[i + 1];\n    }\n    long long ans = a * (ei - si + 1);\n    long long v = min((si - 1) * a, val[si - 1]);\n    for (int i = si - 1; i >= 2; i--) {\n      v = min(v, a * (si - i) + val[i - 1]);\n    }\n    ans += v;\n    v = min(a * (n - ei), val[ei + 1]);\n    for (int i = ei + 1; i <= n; i++) {\n      v = min(v, a * (i - ei) + val[i + 1]);\n    }\n    ans += v;\n    return ans;\n  }\n}\nint main() {\n  cin >> n >> a >> b;\n  if (a == 0 || b == 0) {\n    cout << 0 << endl;\n    return 0;\n  }\n  vector<int> A(n + 1);\n  for (int i = 1; i <= n; i++) cin >> A[i];\n  func(A[1]);\n  func(A[1] + 1);\n  if (A[1] != 2) func(A[1] - 1);\n  func(A[n]);\n  func(A[n] + 1);\n  if (A[n] != 2) func(A[n] - 1);\n  vector<int> ps;\n  while (!primes.empty()) {\n    ps.push_back(*primes.begin());\n    primes.erase(primes.begin());\n  }\n  long long ans = (n - 1) * a;\n  for (int i = 0; i < ps.size(); i++) {\n    ans = min(ans, calc(A, ps[i]));\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.text.DecimalFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.Map.Entry;\nimport java.util.Queue;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.SortedSet;\nimport java.util.Stack;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class Main\n{\t\n\t/********************************************** a list of common variables **********************************************/\n\tprivate MyScanner scan = new MyScanner();\n\tprivate PrintWriter out = new PrintWriter(System.out);\n\tprivate final long INF = Long.MAX_VALUE;\n\tprivate final double PI = Math.acos(-1.0);\n\tprivate final int SIZEN = (int)(1e5);\n\tprivate final int MOD = (int)(1e9 + 7);\n\tprivate final int[] DX = {0, 1, 0, -1}, DY = {-1, 0, 1, 0};\n\tprivate ArrayList<Integer>[] edge;\n\t\n\tpublic void decompose(HashSet<Integer> f, int x)\n\t{\n\t\tif(x >= 2)\n\t\t{\n\t\t\tint sqrtx = (int)Math.sqrt((double)x);\n\t\t\tfor(int i = 2;i <= sqrtx && x > 1;++i)\n\t\t\t{\n\t\t\t\tif(0 == x % i)\n\t\t\t\t{\n\t\t\t\t\tf.add(i);\n\t\t\t\t\twhile(0 == x % i)\n\t\t\t\t\t{\n\t\t\t\t\t\tx /= i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(x > 1)\n\t\t\t{\n\t\t\t\tf.add(x);\n\t\t\t}\n\t\t}\t\t\n\t}\n\n\tpublic void foo()\n\t{\n\t\tint n = scan.nextInt();\n\t\tint a = scan.nextInt();\n\t\tint b = scan.nextInt();\n\t\tint[] c = new int[n];\n\t\tfor(int i = 0;i < n;++i)\n\t\t{\n\t\t\tc[i] = scan.nextInt();\n\t\t}\n\t\tHashSet<Integer> f = new HashSet<Integer>();\n\t\tfor(int i = -1;i <= 1;++i)\n\t\t{\n\t\t\tdecompose(f, c[0] + i);\n\t\t\tdecompose(f, c[n - 1] + i);\n\t\t}\n\t\tlong ans = INF;\n\t\tlong [] d = new long[n];\n\t\tfor(int i : f)\n\t\t{\n\t\t\tlong sum = 0;\n\t\t\tfor(int j = 0;j < n;++j)\n\t\t\t{\n\t\t\t\tif(0 == c[j] % i)\n\t\t\t\t{\n\t\t\t\t\td[j] = 0;\n\t\t\t\t}\n\t\t\t\telse if(0 == (c[j] - 1) % i || 0 == (c[j] + 1) % i)\n\t\t\t\t{\n\t\t\t\t\td[j] = b;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\td[j] = INF / n;\n\t\t\t\t}\n\t\t\t\tsum += d[j];\n\t\t\t}\n\t\t\tlong maxSum = 0, pre = 0;\n\t\t\tint begin = -1, end = -1, k = -1;\n\t\t\tfor(int j = 0;j < n;++j)\n\t\t\t{\n\t\t\t\tlong cur = d[j] - a;\n\t\t\t\tif(pre > 0)\n\t\t\t\t{\n\t\t\t\t\tpre += cur;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpre = cur;\n\t\t\t\t\tk = j;\n\t\t\t\t}\n\t\t\t\tif(pre > maxSum)\n\t\t\t\t{\n\t\t\t\t\tmaxSum = pre;\n\t\t\t\t\tbegin = k;\n\t\t\t\t\tend = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(0 == begin && end == n - 1)\n\t\t\t{\n\t\t\t\tmaxSum -= Math.min(d[0] - a, d[n - 1] - a);\n\t\t\t}\n\t\t\tans = Math.min(ans, sum - maxSum);\n\t\t}\t\n\t\tout.println(ans);\n\t} \n\n\tpublic static void main(String[] args)\n\t{\n\t\tMain m = new Main();\n\t\tm.foo();\n\t\tm.out.close();\n\t}\n\n\t/********************************************** a list of common algorithms **********************************************/\n\t/**\n\t * 1---Get greatest common divisor\n\t * @param a :\tfirst number\n\t * @param b :\tsecond number\n\t * @return\t\tgreatest common divisor\n\t */\n\tpublic long gcd(long a, long b)\n\t{\n\t\treturn 0 == b ? a : gcd(b, a % b);\n\t}\n\t\n\t/**\n\t * 2---Get the distance from a point to a line\n\t * @param x1\tthe x coordinate of one endpoint of the line\n\t * @param y1\tthe y coordinate of one endpoint of the line\n\t * @param x2\tthe x coordinate of the other endpoint of the line\n\t * @param y2\tthe y coordinate of the other endpoint of the line\n\t * @param x\t\tthe x coordinate of the point \n\t * @param y\t\tthe x coordinate of the point\n\t * @return\t\tthe distance from a point to a line\n\t */\n\tpublic double getDist(long x1, long y1, long x2, long y2, long x, long y)\n\t{\n\t\tlong a = y2 - y1;\n\t\tlong b = x1 - x2;\n\t\tlong c = y1 * (x2 - x1) - x1 * (y2 - y1);\n\t\treturn Math.abs(a * x + b * y + c) / Math.sqrt(a * a + b * b);\n\t}\n\t\n\t/**\n\t * 3---Get the distance from one point to a segment (not a line)\n\t * @param x1\tthe x coordinate of one endpoint of the segment\n\t * @param y1\tthe y coordinate of one endpoint of the segment\n\t * @param x2\tthe x coordinate of the other endpoint of the segment\n\t * @param y2\tthe y coordinate of the other endpoint of the segment\n\t * @param x\t\tthe x coordinate of the point\n\t * @param y\t\tthe y coordinate of the point\n\t * @return\t\tthe distance from one point to a segment (not a line)\n\t */\n\tpublic double ptToSeg(long x1, long y1, long x2, long y2, long x, long y)\n\t{\n\t\tdouble cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);\n\t\tif(cross <= 0)\n\t\t{\n\t\t\treturn (x - x1) * (x - x1) + (y - y1) * (y - y1);\n\t\t}\n\t\tdouble d = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n\t\tif(cross >= d) \n\t\t{\n\t\t\treturn (x - x2) * (x - x2) + (y - y2) * (y - y2);\n\t\t}\n\t\tdouble r = cross / d;\n\t\tdouble px = x1 + (x2 - x1) * r;\n\t\tdouble py = y1 + (y2 - y1) * r;\n\t\treturn (x - px) * (x - px) + (y - py) * (y - py);\n\t}\n\t\n\t/**\n\t * 4---KMP match, i.e. kmpMatch(\"abcd\", \"bcd\") = 1, kmpMatch(\"abcd\", \"bfcd\") = -1.\n\t * @param t:\tString to match.\n\t * @param p:\tString to be matched.\n\t * @return\t\tif can match, first index; otherwise -1.\n\t */\n\tpublic int kmpMatch(char[] t, char[] p)\n\t{\n\t\tint n = t.length;\n\t\tint m = p.length;\n\t\tint[] next = new int[m + 1];\n\t\tnext[0] = -1;\n\t\tint j = -1;\n\t\tfor(int i = 1;i < m;++i)\n\t\t{\n\t\t\twhile(j >= 0 && p[i] != p[j + 1])\n\t\t\t{\n\t\t\t\tj = next[j];\n\t\t\t}\n\t\t\tif(p[i] == p[j + 1])\n\t\t\t{\n\t\t\t\t++j;\n\t\t\t}\n\t\t\tnext[i] = j;\n\t\t}\n\t\tj = -1;\n\t\tfor(int i = 0;i < n;++i)\n\t\t{\n\t\t\twhile(j >= 0 && t[i] != p[j + 1])\n\t\t\t{\n\t\t\t\tj = next[j];\n\t\t\t}\n\t\t\tif(t[i] == p[j + 1])\n\t\t\t{\n\t\t\t\t++j;\n\t\t\t}\n\t\t\tif(j == m - 1)\n\t\t\t{\n\t\t\t\treturn i - m + 1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tclass MyScanner\n\t{\n\t    private byte[] buf = new byte[1024];\n\t    private int curChar;\n\t    private int numChars;\n\t    BufferedInputStream bis = new BufferedInputStream(System.in);\n\n\t    public int read() \n\t    {\n\t        if (-1 == numChars)\n\t        {\n\t        \tthrow new InputMismatchException();\n\t        }\n\t        if (curChar >= numChars)\n\t        {\n\t            curChar = 0;\n\t            try \n\t            {\n\t                numChars = bis.read(buf);\n\t            }\n\t            catch (IOException e)\n\t            {\n\t                throw new InputMismatchException();\n\t            }\n\t            if (numChars <= 0)\n\t            {\n\t            \treturn -1;\n\t            }\n\t        }\n\t        return buf[curChar++];\n\t    }\n\n\t    public int nextInt() \n\t    {\n\t        int c = read();\n\t        while (isSpaceChar(c))\n\t        {\n\t        \tc = read();\n\t        }\n\t        int sgn = 1;\n\t        if (c == '-') \n\t        {\n\t            sgn = -1;\n\t            c = read();\n\t        }\n\t        int res = 0;\n\t        do \n\t        {\n\t            if (c < '0' || c > '9')\n\t            {\n\t            \tthrow new InputMismatchException();\n\t            }\n\t            res *= 10;\n\t            res += c - '0';\n\t            c = read();\n\t        } while (!isSpaceChar(c));\n\t        return res * sgn;\n\t    }\n\t    \n\t    public long nextLong() \n\t    {\n\t    \tint c = read();\n\t    \twhile (isSpaceChar(c))\n\t    \t{\n\t    \t\tc = read();\n\t    \t}\n\t    \tint sgn = 1;\n\t    \tif (c == '-') \n\t    \t{\n\t    \t\tsgn = -1;\n\t    \t\tc = read();\n\t    \t}\n\t    \tlong res = 0;\n\t    \tdo \n\t    \t{\n\t    \t\tif (c < '0' || c > '9')\n\t    \t\t{\n\t    \t\t\tthrow new InputMismatchException();\n\t    \t\t}\n\t    \t\tres *= 10;\n\t    \t\tres += c - '0';\n\t    \t\tc = read();\n\t    \t} while (!isSpaceChar(c));\n\t    \treturn res * sgn;\n\t    }\n\t    \n\t    public double nextDouble() \n\t    {\n\t        int c = read();\n\t        while (isSpaceChar(c))\n\t        {\n\t        \tc = read();\n\t        }\n\t        int sgn = 1;\n\t        if (c == '-')\n\t        {\n\t            sgn = -1;\n\t            c = read();\n\t        }\n\t        double res = 0;\n\t        while (!isSpaceChar(c) && c != '.') \n\t        {\n\t            if (c == 'e' || c == 'E')\n\t            {\n\t            \treturn res * Math.pow(10, nextInt());\n\t            }\n\t            if (c < '0' || c > '9')\n\t            {\n\t            \tthrow new InputMismatchException();\n\t            }\n\t            res *= 10;\n\t            res += c & 15;\n\t            c = read();\n\t        }\n\t        if (c == '.') \n\t        {\n\t            c = read();\n\t            double m = 1;\n\t            while (!isSpaceChar(c)) \n\t            {\n\t                if (c == 'e' || c == 'E')\n\t                {\n\t                \treturn res * Math.pow(10, nextInt());\n\t                }\n\t                if (c < '0' || c > '9')\n\t                {\n\t                \tthrow new InputMismatchException();\n\t                }\n\t                m /= 10;\n\t                res += (c & 15) * m;\n\t                c = read();\n\t            }\n\t        }\n\t        return res * sgn;\n\t    }\n\t    \n\t    public String next()\n\t    {\n\t        int c = read();\n\t        while (isSpaceChar(c))\n\t        {\n\t        \tc = read();\n\t        }\n\t        StringBuilder res = new StringBuilder();\n\t        do \n\t        {\n\t            res.appendCodePoint(c);\n\t            c = read();\n\t        } while (!isSpaceChar(c));\n\t        return res.toString();\n\t    }\n\n\t    private boolean isSpaceChar(int c) \n\t    {\n\t        return ' ' == c || '\\n' == c || '\\r' == c || '\\t' == c || -1 == c;\n\t    }\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 1000100;\nint n, arr[MAX];\nlong long mem[MAX][3], a, b, ans = (1LL << 60);\nvector<int> factorize(int num) {\n  vector<int> ret;\n  for (int i = 2; i <= num / i; i += 1 + (i & 1))\n    while (num % i == 0) ret.push_back(i), num /= i;\n  if (num > 1) ret.push_back(num);\n  return ret;\n}\nlong long dp(int idx, int flag, int p) {\n  if (idx == n) return 0;\n  long long &ret = mem[idx][flag];\n  if (ret != -1) return ret;\n  if (arr[idx] % p == 0)\n    ret = dp(idx + 1, 2 * (flag != 0), p);\n  else if ((arr[idx] - 1) % p == 0 || (arr[idx] + 1) % p == 0)\n    ret = b + dp(idx + 1, 2 * (flag != 0), p);\n  else\n    ret = (1LL << 60);\n  if (flag < 2) ret = min(ret, a + dp(idx + 1, 1, p));\n  return ret;\n}\nint main() {\n  cin >> n >> a >> b;\n  for (int i = 0; i < n; i++) cin >> arr[i];\n  int f[6] = {arr[0],     arr[0] - 1,     arr[0] + 1,\n              arr[n - 1], arr[n - 1] - 1, arr[n - 1] + 1};\n  set<int> s;\n  for (int i = 0; i < 6; i++) {\n    vector<int> temp = factorize(f[i]);\n    s.insert(temp.begin(), temp.end());\n  }\n  for (int p : s) {\n    memset(mem, -1, (n + 1) * sizeof mem[0]);\n    ans = min(ans, dp(0, 0, p));\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\ninline void read(T &x) {\n  char c;\n  bool neg = false;\n  while (!isdigit(c = getchar()) && c != '-')\n    ;\n  x = 0;\n  if (c == '-') {\n    neg = true;\n    c = getchar();\n  }\n  do {\n    x = x * 10 + c - '0';\n  } while (isdigit(c = getchar()));\n  if (neg) x = -x;\n}\ntemplate <typename T>\ninline void write(T x) {\n  if (x < 0) {\n    putchar('-');\n    write(-x);\n    return;\n  }\n  if (x < 10) {\n    putchar(char(x + 48));\n  } else {\n    write(x / 10);\n    putchar(char(48 + x % 10));\n  }\n}\ntemplate <typename T>\ninline void writeln(T x) {\n  write(x);\n  putchar('\\n');\n}\nint n, a[1000005], A, B;\nlong long res;\nvector<int> P;\nvoid pt(int x) {\n  for (int i = 2; i * i <= x; ++i) {\n    if (x % i == 0) {\n      while (x % i == 0) x /= i;\n      P.push_back(i);\n    }\n  }\n  if (x > 1) P.push_back(x);\n}\nlong long f[1000005][3];\nvoid solve(int k) {\n  for (int i = 1; i <= n; ++i)\n    for (int j = 0; j <= 2; ++j) f[i][j] = 1e16;\n  if (a[1] % k == 0)\n    f[1][0] = 0;\n  else if ((a[1] + 1) % k == 0 || (a[1] - 1) % k == 0)\n    f[1][0] = B;\n  f[1][1] = A;\n  f[1][2] = A;\n  for (int i = 2; i <= n; ++i) {\n    if (a[i] % k == 0)\n      f[i][0] = f[i - 1][0];\n    else if ((a[i] + 1) % k == 0 || (a[i] - 1) % k == 0)\n      f[i][0] = f[i - 1][0] + B;\n    f[i][1] = min(f[i - 1][1], f[i - 1][0]) + A;\n    if (a[i] % k == 0)\n      f[i][2] = min(f[i - 1][2], f[i - 1][1]);\n    else if ((a[i] - 1) % k == 0 || (a[i] + 1) % k == 0)\n      f[i][2] = min(f[i - 1][2], f[i - 1][1]) + B;\n  }\n  res = min(res, min(f[n][0], min(f[n][1], f[n][2])));\n}\nint main() {\n  cin.tie(0);\n  cout.tie(0);\n  read(n);\n  read(A);\n  read(B);\n  for (int i = 1; i <= n; ++i) read(a[i]);\n  res = 1e18;\n  pt(a[1]);\n  pt(a[1] + 1);\n  pt(a[1] - 1);\n  pt(a[n]);\n  pt(a[n] + 1);\n  pt(a[n] - 1);\n  sort(P.begin(), P.end());\n  solve(P[0]);\n  for (int i = 1; i < P.size(); ++i) {\n    if (P[i] == P[i - 1]) continue;\n    solve(P[i]);\n  }\n  write(res);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, *x;\nlong long a, b;\nlong long solve(int d) {\n  char* type = new char[n];\n  vector<int> pos;\n  for (int i = 0; i < n; i++) {\n    if (x[i] % d == 0)\n      type[i] = 0;\n    else if ((x[i] - 1) % d == 0 || (x[i] + 1) % d == 0)\n      type[i] = 1;\n    else\n      type[i] = 2;\n    if (type[i] > 0) pos.push_back(i);\n  }\n  if (pos.empty()) return 0;\n  if (pos.size() == 1) {\n    if (type[pos[0]] == 1)\n      return min(a, b);\n    else\n      return a;\n  }\n  long long dd = 0, dl = 0;\n  bool good = 1;\n  vector<long long> left;\n  left.resize(pos.size());\n  for (int i = 0; i < pos.size() - 1; i++) {\n    if (type[pos[i]] == 2) good = 0;\n    if (type[pos[i]] == 1 && good) dd += -(pos[i + 1] - pos[i]) * a + b;\n    dl = min(dl, dd);\n    left[i] = dl;\n  }\n  if (type[pos.back()] == 1 && good) {\n    dd += -a + b;\n    dl = min(dl, dd);\n    left[pos.size() - 1] = dl;\n  }\n  dd = 0;\n  long long dr = 0;\n  good = 1;\n  vector<long long> right;\n  right.resize(pos.size());\n  for (int i = pos.size() - 1; i > 0; i--) {\n    if (type[pos[i]] == 2) good = 0;\n    if (type[pos[i]] == 1 && good) dd += -(pos[i] - pos[i - 1]) * a + b;\n    dr = min(dr, dd);\n    right[i] = dr;\n  }\n  if (type[pos[0]] == 1 && good) {\n    dd += -a + b;\n    dr = min(dr, dd);\n    right[0] = dr;\n  }\n  long long cost = (pos.back() - pos[0] + 1) * a;\n  dd = min(0ll, right[1]);\n  right.push_back(0);\n  right.push_back(0);\n  for (int i = 0; i < pos.size(); i++) dd = min(dd, left[i] + right[i + 2]);\n  cost += dd;\n  delete[] type;\n  return cost;\n}\nint main() {\n  scanf(\"%d%I64d%I64d\", &n, &a, &b);\n  x = new int[n];\n  for (int i = 0; i < n; i++) scanf(\"%d\", x + i);\n  int y[6] = {x[0], x[0] - 1, x[0] + 1, x[n - 1], x[n - 1] - 1, x[n - 1] + 1};\n  long long pen[6] = {0, b, b, 0, b, b};\n  long long ssol = max(n * b, n * a) + 10;\n  int* x0 = x;\n  int n0 = n;\n  for (int i = 0; i < 6; i++) {\n    if (i == 1 || i == 2) {\n      n = n - 1;\n      x += 1;\n    } else if (i == 4 || i == 5) {\n      n = n - 1;\n    }\n    for (int d = 2; d * d <= y[i]; d++) {\n      if (y[i] % d == 0) ssol = min(ssol, solve(d) + pen[i]);\n      while (y[i] % d == 0) y[i] /= d;\n    }\n    if (y[i] > 1) ssol = min(ssol, solve(y[i]) + pen[i]);\n    n = n0;\n    x = x0;\n  }\n  printf(\"%I64d\", ssol);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing ii = pair<int, int>;\nusing vii = vector<ii>;\nusing l = long long;\nusing vl = vector<l>;\nusing vvl = vector<vl>;\nusing ll = pair<l, l>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing lu = unsigned long long;\nusing vb = vector<bool>;\nusing vvb = vector<vb>;\nusing vd = vector<double>;\nusing vvd = vector<vd>;\nconst int INF = numeric_limits<int>::max();\nconst double EPS = 1e-10;\nconst l e5 = 100000, e6 = 1000000, e7 = 10000000, e9 = 1000000000;\nconst l MAX_PRIME = 1000000;\nvl sieve_primes() {\n  bitset<MAX_PRIME + 1> b;\n  vl primes;\n  primes.emplace_back(2);\n  for (l i = 3; i <= MAX_PRIME; i += 2) {\n    if (b[i]) continue;\n    primes.emplace_back(i);\n    for (l j = i * i; j <= MAX_PRIME; j += i) b.set(j);\n  }\n  return primes;\n}\nvl factorize_to_primes(vl& primes, l n) {\n  vl factors;\n  auto p = primes.begin();\n  while (p != primes.end() && (*p) * (*p) <= n) {\n    if (n % *p == 0) {\n      factors.emplace_back(*p);\n      while (n % *p == 0) n /= *p;\n    }\n    p++;\n  }\n  if (n != 1) factors.emplace_back(n);\n  return factors;\n}\nl penalty(l x, l p, l b) {\n  if (x == 0) return 0;\n  if (x == 1 || x == p - 1) return b;\n  return -1;\n}\nl cost(vl& v, l p, l a, l b) {\n  l sa = 0;\n  l remove_from = 0;\n  l best_sa = 0;\n  l total = 0;\n  for (l i = 1; i < v.size(); i++) {\n    l x = penalty(v[i] % p, p, b);\n    total += x;\n    if (x < 0) {\n      remove_from = i;\n      break;\n    }\n    sa += x - a;\n    best_sa = max(best_sa, sa);\n    sa = max(0LL, sa);\n  }\n  if (remove_from) {\n    l remove_to = 0;\n    for (l i = v.size() - 1; i >= remove_from; i--) {\n      l x = penalty(v[i] % p, p, b);\n      if (x < 0) {\n        remove_to = i;\n        break;\n      }\n    }\n    total = (remove_to - remove_from + 1) * a;\n    sa = 0;\n    l t = 0;\n    for (l i = remove_from - 1; i > 0; i--) {\n      l x = penalty(v[i] % p, p, b);\n      total += x;\n      sa += x - a;\n      t = max(sa, t);\n    }\n    total -= t;\n    sa = t = 0;\n    for (l i = remove_to + 1; i < v.size(); i++) {\n      l x = penalty(v[i] % p, p, b);\n      total += x;\n      sa += x - a;\n      t = max(sa, t);\n    }\n    total -= t;\n  } else {\n    total -= best_sa;\n  }\n  return total;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  l n, a, b;\n  auto primes = sieve_primes();\n  while (cin >> n >> a >> b) {\n    vl v(n);\n    l best_cost = (n - 1) * a;\n    for (l i = 0; i < n; i++) cin >> v[i];\n    for (l j = -1; j <= 1; j++) {\n      auto f = factorize_to_primes(primes, v[0] + j);\n      for (auto p : f) {\n        if (p == 1) continue;\n        best_cost = min(best_cost, cost(v, p, a, b) + (j == 0 ? 0 : b));\n      }\n    }\n    reverse(v.begin(), v.end());\n    for (l j = -1; j <= 1; j++) {\n      auto f = factorize_to_primes(primes, v[0] + j);\n      for (auto p : f) {\n        if (p == 1) continue;\n        best_cost = min(best_cost, cost(v, p, a, b) + (j == 0 ? 0 : b));\n      }\n    }\n    cout << best_cost << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1000005;\nconst long long inf = 1e18;\nint c[N];\nlong long dp[3][N];\nvector<int> v;\nint n;\nlong long a, b;\nlong long cal(int x) {\n  for (int i = 0; i < 3; i++) {\n    dp[i][0] = inf;\n  }\n  dp[0][0] = 0;\n  for (int i = 1; i <= n; i++) {\n    if (c[i] % x == 0) {\n      dp[0][i] = dp[0][i - 1];\n      dp[1][i] = min(dp[0][i - 1], dp[1][i - 1]) + a;\n      dp[2][i] = min(dp[1][i - 1], dp[2][i - 1]);\n    } else if ((c[i] - 1) % x == 0 || (c[i] + 1) % x == 0) {\n      dp[0][i] = dp[0][i - 1] + b;\n      dp[1][i] = min(dp[0][i - 1], dp[1][i - 1]) + a;\n      dp[2][i] = min(dp[1][i - 1], dp[2][i - 1]) + b;\n    } else {\n      dp[0][i] = inf;\n      dp[1][i] = min(dp[0][i - 1], dp[1][i - 1]) + a;\n      dp[2][i] = inf;\n    }\n  }\n  long long ans = inf;\n  for (int i = 0; i < 3; i++) {\n    ans = min(ans, dp[i][n]);\n  }\n  return ans;\n}\nlong long f(int x) {\n  for (int i = 2; i * i <= x; i++) {\n    if (x % i == 0) {\n      v.push_back(i);\n      while (x % i == 0) {\n        x /= i;\n      }\n    }\n  }\n  long long ans = inf;\n  if (x != 1) v.push_back(x);\n  for (int i = 0; i < v.size(); i++) {\n    ans = min(ans, cal(v[i]));\n  }\n  return ans;\n}\nint main() {\n  scanf(\"%d%I64d%I64d\", &n, &a, &b);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &c[i]);\n  }\n  long long ans = inf;\n  for (int i = c[1] - 1; i <= c[1] + 1; i++) {\n    ans = min(ans, f(i));\n  }\n  for (int i = c[n] - 1; i <= c[n] + 1; i++) ans = min(ans, f(i));\n  printf(\"%I64d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long dp[1000100][3];\nint val[1000100];\nlong long a, b;\nint prime[1000100];\nint vis[1000100];\nint n, cnt, fac[1000100];\nvoid init() {\n  for (int i = 2; i < 1000100; i++) {\n    if (!vis[i]) prime[cnt++] = i;\n    for (int j = 0; j < cnt && prime[j] * i < 1000100; j++) {\n      vis[prime[j] * i] = 1;\n      if (i % prime[j] == 0) break;\n    }\n  }\n}\nlong long solve(int st, int ed, int v) {\n  memset(dp, 0x3f3f3f3f3f3f3f3f, sizeof(dp));\n  dp[st - 1][0] = 0;\n  for (int i = st; i <= ed; i++) {\n    dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + a;\n    if (val[i] % v != 0) {\n      if ((val[i] + 1) % v == 0 || (val[i] - 1) % v == 0) {\n        dp[i][0] = dp[i - 1][0] + b;\n        dp[i][2] = min(dp[i - 1][1], dp[i - 1][2]) + b;\n      }\n    } else {\n      dp[i][0] = dp[i - 1][0];\n      dp[i][2] = min(dp[i - 1][1], dp[i - 1][2]);\n    }\n  }\n  return min(min(dp[ed][0], dp[ed][1]), dp[ed][2]);\n}\nint factor(int x) {\n  int tot = 0;\n  for (int j = 0; j < cnt && x >= prime[j]; j++) {\n    if (x % prime[j] == 0) {\n      fac[tot++] = prime[j];\n      while (x % prime[j] == 0) x /= prime[j];\n    }\n  }\n  if (x != 1) fac[tot++] = x;\n  return tot;\n}\nint main() {\n  int t, C = 1;\n  init();\n  while (scanf(\"%d%lld%lld\", &n, &a, &b) != EOF) {\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &val[i]);\n    long long ans = a * (long long)n;\n    for (int i = -1; i <= 1; i++) {\n      long long cost = i == 0 ? 0 : b;\n      int len = factor(val[n] + i);\n      for (int j = 0; j < len; j++)\n        ans = min(ans, solve(1, n - 1, fac[j]) + cost);\n      len = factor(val[1] + i);\n      for (int j = 0; j < len; j++) ans = min(ans, solve(2, n, fac[j]) + cost);\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int nmax = 1e6 + 3;\nconst long long inf = 1e15;\nlong long v[nmax], k, t[93], n, a, b, d[nmax][3], sol, p;\nvoid divizor(long long usu) {\n  for (long long i = 2; i * i <= usu; ++i) {\n    if (usu % i == 0) {\n      t[++k] = i;\n      while (usu % i == 0) usu /= i;\n    }\n  }\n  if (usu > 1) t[++k] = usu;\n}\nvoid clean() {\n  for (int i = 1; i <= n; ++i) {\n    d[i][0] = inf;\n    d[i][1] = inf;\n    d[i][2] = inf;\n  }\n}\nvoid solve() {\n  divizor(v[1]);\n  divizor(v[1] - 1);\n  divizor(v[1] + 1);\n  divizor(v[n]);\n  divizor(v[n] - 1);\n  divizor(v[n] + 1);\n  sort(t + 1, t + k + 1);\n  sol = inf;\n  for (int i = 1; i <= k; ++i) {\n    clean();\n    if (t[i] == t[i - 1]) continue;\n    p = t[i];\n    for (int j = 1; j <= n; ++j) {\n      if (v[j] % p == 0) {\n        d[j][0] = d[j - 1][0];\n        d[j][1] = min(d[j - 1][0] + a, d[j - 1][1] + a);\n        d[j][2] = min(d[j - 1][1], d[j - 1][2]);\n        continue;\n      }\n      if ((v[j] - 1) % p == 0 || (v[j] + 1) % p == 0) {\n        d[j][0] = d[j - 1][0] + b;\n        d[j][1] = min(d[j - 1][0] + a, d[j - 1][1] + a);\n        d[j][2] = min(d[j - 1][1] + b, d[j - 1][2] + b);\n        continue;\n      }\n      d[j][1] = min(d[j - 1][0] + a, d[j - 1][1] + a);\n    }\n    sol = min(min(sol, d[n][0]), min(d[n][1], d[n][2]));\n  }\n}\nint main() {\n  cin >> n >> a >> b;\n  for (int i = 1; i <= n; ++i) cin >> v[i];\n  solve();\n  cout << sol;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1000010;\nconst long long inf = 1000000000000000000LL;\nint a[N];\nlong long prefix_cost[N], cost[N], suffix_cost[N];\nset<int> factors;\nset<int>::iterator it;\nvoid pf(int x) {\n  for (int j = x - 1; j <= x + 1; j++) {\n    int d = j;\n    for (int i = 2; i * i <= j; i++) {\n      if (d % i == 0) {\n        factors.insert(i);\n        while (d % i == 0) d /= i;\n      }\n    }\n    if (d != 1) factors.insert(d);\n  }\n}\nint main() {\n  int n, p, A, B;\n  scanf(\"%d %d %d\", &n, &A, &B);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  if (n == 1) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  pf(a[1]);\n  pf(a[n]);\n  long long ans = inf;\n  for (it = factors.begin(); it != factors.end(); ++it) {\n    prefix_cost[0] = 0LL;\n    p = *it;\n    for (int i = 1; i <= n; i++) {\n      if (a[i] % p == 0)\n        cost[i] = 0LL;\n      else if ((a[i] + 1) % p == 0 || (a[i] - 1) % p == 0)\n        cost[i] = (long long)B;\n      else\n        cost[i] = inf;\n      prefix_cost[i] = prefix_cost[i - 1] + cost[i];\n      if (prefix_cost[i] > inf) prefix_cost[i] = inf;\n    }\n    prefix_cost[0] = inf;\n    suffix_cost[n + 1] = 0LL;\n    long long suffix_sum = 0LL;\n    for (int i = n; i > 0; i--) {\n      suffix_sum += cost[i];\n      if (suffix_sum > inf) suffix_sum = inf;\n      suffix_cost[i] = min(A + suffix_cost[i + 1], suffix_sum);\n    }\n    ans = min(ans, suffix_cost[1]);\n    for (int i = 2; i <= n; i++)\n      ans = min(ans, prefix_cost[i - 1] + suffix_cost[i]);\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a, b;\nset<int> trobat;\nvector<int> divisors;\nvoid divisor(int n) {\n  int i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      if (not trobat.count(i)) {\n        divisors.push_back(i);\n        trobat.insert(i);\n      }\n      n /= i;\n    } else\n      i++;\n  }\n  if (n != 1 and not trobat.count(n)) {\n    divisors.push_back(n);\n    trobat.insert(n);\n  }\n}\nint main() {\n  int n;\n  cin >> n >> a >> b;\n  vector<int> v(n);\n  for (int i = 0; i < n; i++) {\n    cin >> v[i];\n  }\n  divisor(v[0] + 1);\n  divisor(v[0] - 1);\n  divisor(v[0]);\n  divisor(v[n - 1]);\n  divisor(v[n - 1] + 1);\n  divisor(v[n - 1] - 1);\n  long long int m = 10000000000000000;\n  int primer;\n  vector<vector<long long int> > dp(n, vector<long long int>(3, -1));\n  for (int i = 0; i < divisors.size(); i++) {\n    primer = divisors[i];\n    if (v[0] % primer == 0) {\n      dp[0][0] = 0;\n      dp[0][1] = 0;\n      dp[0][2] = 0;\n    } else if ((v[0] + 1) % primer == 0 or (v[0] - 1) % primer == 0) {\n      dp[0][0] = min(a, b);\n      dp[0][1] = min(a, b);\n      dp[0][2] = b;\n    } else {\n      dp[0][0] = a;\n      dp[0][1] = a;\n      dp[0][2] = 10000000000000000;\n    }\n    for (int k = 1; k < n; k++) {\n      for (int j = 0; j < 3; j++) {\n        if (j == 0) {\n          if (v[k] % primer == 0) {\n            dp[k][0] = dp[k - 1][0];\n          } else if ((v[k] + 1) % primer == 0 or (v[k] - 1) % primer == 0) {\n            dp[k][0] = min(b + dp[k - 1][0], a + dp[k - 1][1]);\n          } else\n            dp[k][0] = a + dp[k - 1][1];\n        }\n        if (j == 1) {\n          if (v[k] % primer == 0) {\n            dp[k][1] = min(a + dp[k - 1][1], dp[k - 1][2]);\n          } else if ((v[k] + 1) % primer == 0 or (v[k] - 1) % primer == 0) {\n            dp[k][1] = min(b + dp[k - 1][2], a + dp[k - 1][1]);\n          } else\n            dp[k][1] = a + dp[k - 1][1];\n        }\n        if (j == 2) {\n          if (v[k] % primer == 0) {\n            dp[k][2] = dp[k - 1][2];\n          } else if ((v[k] + 1) % primer == 0 or (v[k] - 1) % primer == 0) {\n            dp[k][2] = b + dp[k - 1][2];\n          } else\n            dp[k][2] = 10000000000000000;\n        }\n      }\n    }\n    m = min(m, dp[n - 1][0]);\n  }\n  cout << m << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1000010;\nconst long long INF = 1e17;\nvector<int> div1[3], divn[3];\nlong long n, t[N], a, b;\nlong long dp[N][2][3];\nvector<int> divisor(int x) {\n  int i = 2;\n  vector<int> ans;\n  while (i * i <= x) {\n    if (x % i == 0) {\n      ans.push_back(i);\n      while (x % i == 0) x /= i;\n    }\n    i++;\n  }\n  if (x != 1) ans.push_back(x);\n  return ans;\n}\nvoid Init() {\n  div1[0] = divisor(t[1] - 1);\n  div1[1] = divisor(t[1]);\n  div1[2] = divisor(t[1] + 1);\n  divn[0] = divisor(t[n] - 1);\n  divn[1] = divisor(t[n]);\n  divn[2] = divisor(t[n] + 1);\n}\nlong long Solve(int div, int cp) {\n  for (int k = 1; k <= n; k++)\n    for (int i = 0; i <= 1; i++)\n      for (int j = 0; j <= 2; j++) dp[k][i][j] = INF;\n  dp[1][0][0] = 0;\n  for (int i = 2; i <= n; i++)\n    for (int j = 0; j <= 1; j++) {\n      if (t[i] % div)\n        dp[i][j][0] = INF;\n      else\n        dp[i][j][0] =\n            min(dp[i - 1][j][1], min(dp[i - 1][j][0], dp[i - 1][j][2]));\n      if ((t[i] + 1) % div == 0 || (t[i] - 1) % div == 0)\n        dp[i][j][1] =\n            b + min(dp[i - 1][j][0], min(dp[i - 1][j][1], dp[i - 1][j][2]));\n      if (j == 0)\n        dp[i][j][2] = INF;\n      else\n        dp[i][j][2] = a + min(min(dp[i - 1][j - 1][0], dp[i - 1][j - 1][1]),\n                              dp[i - 1][j][2]);\n    }\n  long long ans = INF;\n  for (int i = 0; i <= 1; i++)\n    for (int j = 0; j <= 2; j++) ans = min(ans, dp[n][i][j]);\n  ans += cp;\n  return ans;\n}\nlong long Solve2(int div, int cp) {\n  for (int k = 1; k <= n; k++)\n    for (int i = 0; i <= 1; i++)\n      for (int j = 0; j <= 2; j++) dp[k][i][j] = INF;\n  dp[0][0][0] = 0;\n  for (int i = 1; i <= n - 1; i++)\n    for (int j = 0; j <= 1; j++) {\n      if (t[i] % div)\n        dp[i][j][0] = INF;\n      else\n        dp[i][j][0] =\n            min(dp[i - 1][j][1], min(dp[i - 1][j][0], dp[i - 1][j][2]));\n      if ((t[i] + 1) % div == 0 || (t[i] - 1) % div == 0)\n        dp[i][j][1] =\n            b + min(dp[i - 1][j][0], min(dp[i - 1][j][1], dp[i - 1][j][2]));\n      if (j == 0)\n        dp[i][j][2] = INF;\n      else\n        dp[i][j][2] = a + min(min(dp[i - 1][j - 1][0], dp[i - 1][j - 1][1]),\n                              dp[i - 1][j][2]);\n    }\n  long long ans = INF;\n  for (int i = 0; i <= 1; i++)\n    for (int j = 0; j <= 2; j++) ans = min(ans, dp[n - 1][i][j]);\n  ans += cp;\n  return ans;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin >> n >> a >> b;\n  for (int i = 1; i <= n; i++) cin >> t[i];\n  Init();\n  long long res = INF;\n  for (int i = 0; i <= 2; i++) {\n    int cp;\n    if (i == 1)\n      cp = 0;\n    else\n      cp = b;\n    for (int j = 0; j < div1[i].size(); j++)\n      res = min(res, Solve(div1[i][j], cp));\n  }\n  for (int i = 0; i <= 2; i++) {\n    int cp;\n    if (i == 1)\n      cp = 0;\n    else\n      cp = b;\n    for (int j = 0; j < divn[i].size(); j++)\n      res = min(res, Solve2(divn[i][j], cp));\n  }\n  cout << res;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MX = 1e6 + 9, INF = 1e16;\nlong long arr[MX], dp[MX][3];\nset<long long> s;\nvoid FUN(long long x) {\n  if (x == 2) return;\n  for (long long i = 2; i * i <= x; i++)\n    while (x > 1 && x % i == 0) x /= i, s.insert(i);\n  if (x > 1) s.insert(x);\n}\nint32_t main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  long long n, a, b;\n  cin >> n >> a >> b;\n  for (long long i = 0; i < n; i++) cin >> arr[i];\n  FUN(arr[0] + 1);\n  FUN(arr[0]);\n  FUN(arr[0] - 1);\n  FUN(arr[n - 1] + 1);\n  FUN(arr[n - 1]);\n  FUN(arr[n - 1] - 1);\n  long long minn = 1e18;\n  for (long long x : s) {\n    dp[0][0] = dp[0][1] = dp[0][2] = 0;\n    for (long long i = 1; i <= n; i++) {\n      if (arr[i - 1] % x == 0 || arr[i - 1] % x == 1 ||\n          arr[i - 1] % x == x - 1) {\n        dp[i][0] = dp[i - 1][0] + b * (arr[i - 1] % x != 0);\n        dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + a;\n        dp[i][2] = min(dp[i - 1][1], dp[i - 1][2]) + b * (arr[i - 1] % x != 0);\n      } else {\n        dp[i][0] = dp[i][2] = INF;\n        dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + a;\n      }\n      dp[i][0] = min(INF, dp[i][0]), dp[i][1] = min(INF, dp[i][1]),\n      dp[i][2] = min(INF, dp[i][2]);\n    }\n    minn = min(min(minn, dp[n][0]), min(dp[n][1], dp[n][2]));\n  }\n  cout << minn;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, a, b, arr[1000006 + 10];\nlong long dp[1000006][3], ans = (1ll << 60);\nvoid solve(int p) {\n  dp[0][0] = arr[0] % p == 0 ? 0 : b;\n  dp[0][1] = (1ll << 60);\n  dp[0][2] = dp[0][0];\n  for (int i = 1; i < n; i++) {\n    dp[i][0] = dp[i][1] = dp[i][2] = (1ll << 60);\n    for (int j = -1; j <= 1; j++) {\n      if ((arr[i] + j) % p == 0) {\n        if (j == 0) {\n          dp[i][0] = min(dp[i][0], dp[i - 1][0]);\n          dp[i][2] = min(dp[i][2], min(dp[i - 1][2], dp[i - 1][1]));\n        } else {\n          dp[i][0] = min(dp[i][0], dp[i - 1][0] + b);\n          dp[i][2] = min(dp[i][2], min(dp[i - 1][2] + b, dp[i - 1][1] + b));\n        }\n      }\n    }\n    dp[i][1] = min(dp[i][1], min(dp[i - 1][0] + a, dp[i - 1][1] + a));\n  }\n  ans = min(ans, min(dp[n - 1][0], min(dp[n - 1][1], dp[n - 1][2])));\n}\nint main() {\n  cin >> n >> a >> b;\n  for (int i = 0; i < n; i++) cin >> arr[i];\n  set<int> st;\n  for (int i = -1; i <= 1; i++) {\n    int num = arr[0] + i;\n    for (int j = 2; j * j <= num; j++) {\n      if (num % j == 0) {\n        st.insert(j);\n        while (num % j == 0) num /= j;\n      }\n    }\n    if (num > 1) st.insert(num);\n  }\n  set<int>::iterator it;\n  for (it = st.begin(); it != st.end(); it++) solve(*it);\n  reverse(arr, arr + n);\n  st.clear();\n  for (int i = -1; i <= 1; i++) {\n    int num = arr[0] + i;\n    for (int j = 2; j * j <= num; j++) {\n      if (num % j == 0) {\n        st.insert(j);\n        while (num % j == 0) num /= j;\n      }\n    }\n    if (num > 1) st.insert(num);\n  }\n  for (it = st.begin(); it != st.end(); it++) solve(*it);\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 5;\nconst long long INF = 1e16;\nint abs(int x) { return x > 0 ? x : -x; }\nvoid primeDiv(int a, vector<int>& p) {\n  p.clear();\n  for (int i = 2; i * i <= a; ++i) {\n    if (a % i == 0) {\n      p.push_back(i);\n      while (a % i == 0) a /= i;\n    }\n  }\n  if (a > 1) p.push_back(a);\n}\nint n, a[N];\nlong long x, y, dp[N][3];\nbool check(int x, int p) {\n  bool ok = false;\n  for (int d = -1; d <= 1; ++d) ok |= ((x + d) % p == 0);\n  return ok;\n}\nlong long solve(int p) {\n  for (int i = 0; i < 3; ++i) dp[0][i] = 0;\n  for (int i = 1; i <= n; ++i) {\n    dp[i][1] = min(dp[i - 1][1], dp[i - 1][0]) + x;\n    if (!check(a[i - 1], p))\n      dp[i][0] = dp[i][2] = INF;\n    else {\n      dp[i][0] = dp[i - 1][0] + y * (a[i - 1] % p != 0);\n      dp[i][2] = min(dp[i - 1][1], dp[i - 1][2]) + y * (a[i - 1] % p != 0);\n    }\n  }\n  long long res = INF;\n  for (int i = 0; i < 3; ++i) res = min(res, dp[n][i]);\n  return res;\n}\nint main() {\n  scanf(\"%d%I64d%I64d\", &n, &x, &y);\n  for (int* it = a; it < a + n; ++it) scanf(\"%d\", it);\n  long long ans = INF;\n  vector<int> prime;\n  for (int d = -1; d <= 1; ++d) {\n    primeDiv(a[0] + d, prime);\n    for (int p : prime) ans = min(ans, solve(p));\n  }\n  for (int d = -1; d <= 1; ++d) {\n    primeDiv(a[n - 1] + d, prime);\n    for (int p : prime) ans = min(ans, solve(p));\n  }\n  printf(\"%I64d\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T, typename S>\nostream &operator<<(ostream &os, const pair<T, S> &p) {\n  return os << \"(\" << p.first << \", \" << p.second << \")\";\n}\ntemplate <typename C, typename T = decay<decltype(*begin(declval<C>()))>,\n          typename enable_if<!is_same<C, string>::value>::type * = nullptr>\nostream &operator<<(ostream &os, const C &c) {\n  bool f = true;\n  os << \"[\";\n  for (const auto &x : c) {\n    if (!f) os << \", \";\n    f = false;\n    os << x;\n  }\n  return os << \"]\";\n}\ntemplate <typename T>\nvoid debug(string s, T x) {\n  cerr << s << \" = \" << x << \"\\n\";\n}\ntemplate <typename T, typename... Args>\nvoid debug(string s, T x, Args... args) {\n  cerr << s.substr(0, s.find(',')) << \" = \" << x << \" | \";\n  debug(s.substr(s.find(',') + 2), args...);\n}\nconst long long INF = 2e18;\nint c[1000005];\nlong long dp[1000005][3];\nunordered_set<int> st;\nvoid factor(int x) {\n  for (int i = 2; 1LL * i * i <= x; i++)\n    if (x % i == 0) {\n      st.insert(i);\n      while (x % i == 0) x /= i;\n    }\n  if (x > 1) st.insert(x);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n, a, b;\n  cin >> n >> a >> b;\n  for (int i = 0; i < n; i++) cin >> c[i];\n  factor(c[0] - 1);\n  factor(c[0]);\n  factor(c[0] + 1);\n  factor(c[n - 1] - 1);\n  factor(c[n - 1]);\n  factor(c[n - 1] + 1);\n  long long ret = LLONG_MAX;\n  for (int p : st) {\n    dp[0][0] = dp[0][1] = dp[0][2] = 0;\n    for (int i = 0; i < n; i++) {\n      dp[i + 1][1] = min(dp[i][0], dp[i][1]) + a;\n      if (c[i] % p == 0) {\n        dp[i + 1][0] = dp[i][0];\n        dp[i + 1][2] = min(dp[i][1], dp[i][2]);\n      } else if ((c[i] - 1) % p == 0 || (c[i] + 1) % p == 0) {\n        dp[i + 1][0] = dp[i][0] + b;\n        dp[i + 1][2] = min(dp[i][1], dp[i][2]) + b;\n      } else {\n        dp[i + 1][0] = dp[i + 1][2] = INF;\n      }\n    }\n    ret = min({ret, dp[n][0], dp[n][1], dp[n][2]});\n  }\n  cout << ret << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1000000 + 1000;\nint n, x, y;\nint a[maxn];\nvector<int> prime;\nbool l1[maxn], r1[maxn];\nint l2[maxn], r2[maxn];\nconst long long inf = (long long)1e18;\nvoid factor(int x) {\n  int v = x;\n  for (int i = 2; 1ll * i * i <= x; i++)\n    if (v % i == 0) {\n      prime.push_back(i);\n      while (v % i == 0) v /= i;\n    }\n  if (v > 1) prime.push_back(v);\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &x, &y);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  prime.clear();\n  factor(a[1]);\n  factor(a[1] - 1);\n  factor(a[1] + 1);\n  factor(a[n]);\n  factor(a[n] + 1);\n  factor(a[n] - 1);\n  sort(prime.begin(), prime.end());\n  long long ans = inf;\n  for (int t = 0; t < (int)prime.size(); t++)\n    if (t == 0 || prime[t] != prime[t - 1]) {\n      int g = prime[t];\n      l1[0] = 1;\n      l2[0] = 0;\n      for (int i = 1; i <= n; i++) {\n        l1[i] =\n            l1[i - 1] && (a[i] % g == 0 || a[i] % g == g - 1 || a[i] % g == 1);\n        l2[i] = l2[i - 1] + (a[i] % g == 0 ? 0 : 1);\n      }\n      r1[n + 1] = 1;\n      r2[n + 1] = 0;\n      for (int i = n; i > 0; i--) {\n        r1[i] =\n            r1[i + 1] && (a[i] % g == 0 || a[i] % g == g - 1 || a[i] % g == 1);\n        r2[i] = r2[i + 1] + (a[i] % g == 0 ? 0 : 1);\n      }\n      long long cur = inf;\n      if (l1[n]) cur = min(cur, 1ll * l2[n] * y);\n      long long lft = inf;\n      for (int j = 1; j <= n; j++) {\n        if (j >= 2 && l1[j - 1])\n          lft = min(lft, 1ll * l2[j - 1] * y - 1ll * x * j);\n        if (r1[j + 1])\n          cur = min(cur, lft + 1ll * (j + 1) * x + 1ll * r2[j + 1] * y);\n      }\n      for (int j = 1; j < n; j++) {\n        if (r1[j + 1]) cur = min(cur, 1ll * r2[j + 1] * y + 1ll * j * x);\n      }\n      ans = min(ans, cur);\n    }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 29;\nconst double EPS = 1e-10;\ndouble zero(double d) { return d < EPS ? 0.0 : d; }\ntemplate <class T>\nbool chmax(T &a, const T &b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <class T>\nbool chmin(T &a, const T &b) {\n  if (b < a) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n  return os << '(' << p.first << ',' << p.second << ')';\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &a) {\n  os << '[';\n  for (int i = 0; i < (int)(a.size()); i++) os << (i ? \" \" : \"\") << a[i];\n  return os << ']';\n}\nstring toString(int i) {\n  stringstream ss;\n  ss << i;\n  return ss.str();\n}\nconst int MOD = 1000000007;\nlong long fpow(long long a, long long k, int M) {\n  long long res = 1ll;\n  long long x = a;\n  while (k != 0) {\n    if ((k & 1) == 1) res = (res * x) % M;\n    x = (x * x) % M;\n    k >>= 1;\n  }\n  return res;\n}\nstruct prepare {\n  prepare() {\n    cout.setf(ios::fixed, ios::floatfield);\n    cout.precision(8);\n    ios_base::sync_with_stdio(false);\n  }\n} _prepare;\nset<int> enumPrimeFactors(int a) {\n  set<int> ans;\n  for (int i = 2; i * i <= a; i++) {\n    while (a % i == 0) {\n      ans.insert(i);\n      a /= i;\n    }\n  }\n  if (a != 1) ans.insert(a);\n  return ans;\n}\nint main() {\n  const long long INF = (1ll << 60);\n  int n, a, b;\n  cin >> n >> a >> b;\n  vector<int> nums(n);\n  for (int i = 0; i < (int)(n); i++) cin >> nums[i];\n  set<int> factors;\n  for (int i = -1; i < (int)(1 + 1); i++) {\n    set<int> tmp = enumPrimeFactors(nums[0] + i);\n    set<int> tmp2 = enumPrimeFactors(nums[n - 1] + i);\n    factors.insert(((tmp).begin()), ((tmp).end()));\n    factors.insert(((tmp2).begin()), ((tmp2).end()));\n  }\n  long long ans = INF;\n  vector<vector<long long> > dp(n + 1, vector<long long>(3, INF));\n  for (__typeof((factors).begin()) fact = (factors).begin();\n       fact != (factors).end(); fact++) {\n    for (int i = 0; i < (int)(n + 1); i++)\n      fill(((dp[i]).begin()), ((dp[i]).end()), INF);\n    dp[0][0] = 0;\n    for (int i = 0; i < (int)(n); i++) {\n      for (int j = -1; j < (int)(1 + 1); j++) {\n        if ((nums[i] + j) % (*fact) == 0) {\n          chmin(dp[i + 1][0], dp[i][0] + (long long)b * abs(j));\n          chmin(dp[i + 1][2], dp[i][1] + (long long)b * abs(j));\n          chmin(dp[i + 1][2], dp[i][2] + (long long)b * abs(j));\n        }\n      }\n      chmin(dp[i + 1][1], dp[i][0] + a);\n      chmin(dp[i + 1][1], dp[i][1] + a);\n    }\n    for (int i = 0; i < (int)(3); i++) chmin(ans, dp[n][i]);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long inf = (1ll << 60);\nint n, a, b;\nint aa[1000011];\nlong long p1[1000011], p2[1000011];\nint vec[1000011] = {}, num = 0;\nbool vis[1000011] = {};\nvoid getprime(int q) {\n  for (int i = 2; i * i <= q; i++) {\n    if (q % i != 0) continue;\n    while (q % i == 0) q = q / i;\n    if (vis[i] == true) continue;\n    vis[i] = true;\n    num++;\n    vec[num] = i;\n  }\n  if (q != 1) {\n    num++;\n    vec[num] = q;\n  }\n}\nlong long solve(int k) {\n  long long ans = inf;\n  for (int i = 1; i <= n; i++) {\n    p1[i] = p2[i] = inf;\n  }\n  p1[0] = p2[n + 1] = 0;\n  for (int i = 1; i <= n; i++) {\n    if (aa[i] % k == 0)\n      p1[i] = p1[i - 1];\n    else if ((aa[i] + 1) % k == 0 || (aa[i] - 1) % k == 0)\n      p1[i] = p1[i - 1] + b;\n  }\n  for (int i = n; i >= 1; i--) {\n    if (aa[i] % k == 0)\n      p2[i] = p2[i + 1];\n    else if ((aa[i] + 1) % k == 0 || (aa[i] - 1) % k == 0)\n      p2[i] = p2[i + 1] + b;\n  }\n  long long mv = -a;\n  for (int i = 1; i <= n; i++) {\n    ans = min(ans, p2[i] + (long long)i * a + mv);\n    mv = min(mv, p1[i] - (long long)(i + 1) * a);\n  }\n  for (int i = 1; i <= n; i++) {\n    ans = min(ans, p1[i] + (long long)(n - i) * a);\n  }\n  return ans;\n}\nint main() {\n  cin >> n >> a >> b;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &aa[i]);\n  }\n  getprime(aa[1]);\n  getprime(aa[1] + 1);\n  getprime(aa[1] - 1);\n  getprime(aa[n]);\n  getprime(aa[n] + 1);\n  getprime(aa[n] - 1);\n  long long ans = inf;\n  for (int i = 1; i <= num; i++) {\n    ans = min(ans, solve(vec[i]));\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9 + 9;\nconst int N = 1e6 + 10;\nint n;\nlong long ans, a, b;\nlong long f[N];\nvector<long long> p;\nmap<long long, bool> use;\nint type[N];\nint s[N];\nvoid getp(long long x) {\n  while (!(x & 1LL)) x >>= 1LL;\n  for (long long i = 3; i * i <= x; i += 2)\n    if (x % i == 0) {\n      do {\n        x /= i;\n      } while (x % i == 0);\n      if (!use[i]) {\n        use[i] = true;\n        p.push_back(i);\n      }\n    }\n  if (x > 2 && !use[x]) {\n    use[x] = true;\n    p.push_back(x);\n  }\n}\nvoid init() {\n  scanf(\"%d %I64d %I64d\", &n, &a, &b);\n  for (int i = 1; i <= n; i++) scanf(\"%I64d\", &f[i]);\n  p.push_back(2);\n  use[2] = true;\n  ans = (n - 1LL) * a;\n  for (long long i = -1; i <= 1; i++) {\n    if (f[1] + i > 1) getp(f[1] + i);\n    if (f[n] + i > 1) getp(f[n] + i);\n  }\n}\nvoid getans(long long p0) {\n  int l = 1, r = 0;\n  long long s0, s1, s2, mp;\n  s[0] = 0;\n  for (int i = 1; i <= n; i++) {\n    mp = f[i] % p0;\n    if (mp == 0)\n      type[i] = 0;\n    else if (mp == p0 - 1 || mp == 1)\n      type[i] = 1;\n    else {\n      l = (r == 0) ? i : l;\n      r = i;\n      type[i] = 0;\n    }\n    s[i] = s[i - 1] + type[i];\n  }\n  if (l <= r) {\n    s0 = a * (r - l + 1LL);\n    s1 = a * (l - 1);\n    s2 = a * (n - r);\n    for (long long i = 1; i < l; i++) s1 = min(s1, s[i] * b + (l - i - 1) * a);\n    for (long long i = n; i > r; i--)\n      s2 = min(s2, (s[n] - s[i - 1]) * b + (i - r - 1) * a);\n  } else {\n    long long dp = 0;\n    s1 = s2 = 0, s0 = a * (n - 1LL);\n    for (long long i = 1; i <= n; i++) {\n      dp = min(s[i] * b, dp + a);\n      s0 = min(s0, dp + (s[n] - s[i]) * b);\n    }\n  }\n  ans = min(ans, s0 + s1 + s2);\n}\nvoid work() {\n  for (int i = 0; i < p.size(); i++) getans(p[i]);\n  printf(\"%I64d\\n\", ans);\n}\nint main() {\n  init();\n  work();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e6;\nconst long long Max = 1e16;\nint n, A[maxn + 1], a, b;\nvector<int> B;\nlong long Dp[maxn + 1][4], ans;\nvoid Init(int x) {\n  for (int i = 2; i * i <= x; i++) {\n    if (x % i == 0) B.push_back(i);\n    while (x % i == 0) x /= i;\n  }\n  if (x > 1) B.push_back(x);\n}\nvoid DP(int x) {\n  for (int i = 1; i <= n; i++) {\n    long long val = 1e16;\n    if (A[i] % x == 0) val = 0;\n    if ((A[i] + 1) % x == 0 || (A[i] - 1) % x == 0) val = b;\n    Dp[i][1] = min(Dp[i - 1][1] + val, Max);\n    Dp[i][2] = min(Max, min(Dp[i - 1][1], Dp[i - 1][2]) + a);\n    Dp[i][3] =\n        min(Max, min(Dp[i - 1][1], min(Dp[i - 1][2], Dp[i - 1][3])) + val);\n  }\n  ans = min(ans, min(Dp[n][1], min(Dp[n][2], Dp[n][3])));\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cin >> n >> a >> b;\n  for (int i = 1; i <= n; i++) cin >> A[i];\n  for (int i = -1; i <= 1; i++) Init(A[1] + i), Init(A[n] + i);\n  sort(B.begin(), B.end());\n  B.erase(unique(B.begin(), B.end()), B.end());\n  ans = Max;\n  for (int i = 0; i < B.size(); i++) DP(B[i]);\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int SQN = 31630;\nconst int MAXN = 1e6 + 1;\nvector<int> prosti_brojevi;\nbool prost[SQN];\nconst long long inf = (long long)1e17;\nlong long n, A, B;\nlong long minV = inf;\nint niz[MAXN];\nlong long dp[MAXN][3];\nvoid solve() {\n  for (int k = 0; k < prosti_brojevi.size(); k++) {\n    long long cp = prosti_brojevi[k];\n    long long delta;\n    if (niz[0] % cp == 0)\n      delta = 0;\n    else if ((niz[0] - 1) % cp == 0 || (niz[0] + 1) % cp == 0)\n      delta = B;\n    else\n      delta = inf;\n    dp[0][0] = delta;\n    dp[0][2] = dp[0][1] = A;\n    for (int i = 1; i < n; i++) {\n      if (niz[i] % cp == 0)\n        delta = 0;\n      else if ((niz[i] - 1) % cp == 0 || (niz[i] + 1) % cp == 0)\n        delta = B;\n      else\n        delta = inf;\n      dp[i][0] = dp[i - 1][0] + delta;\n      dp[i][1] = min(dp[i - 1][1] + delta, dp[i - 1][2] + delta);\n      dp[i][2] = min(dp[i - 1][0] + A, dp[i - 1][2] + A);\n      dp[i][0] = min(dp[i][0], inf);\n      dp[i][1] = min(dp[i][1], inf);\n      dp[i][2] = min(dp[i][2], inf);\n    }\n    minV = min(minV, min(dp[n - 1][0], min(dp[n - 1][1], dp[n - 1][2])));\n  }\n}\nset<long long> brojiproste;\nvoid generatePrimes() {\n  for (int i = 0; i < SQN; i++) prost[i] = true;\n  prost[0] = prost[1] = false;\n  for (int i = 2; i < SQN; i++) {\n    if (!prost[i]) continue;\n    for (int j = i * 2; j < SQN; j += i) prost[j] = false;\n  }\n  long long mogucnosti[] = {niz[0],     niz[0] + 1,     niz[0] - 1,\n                            niz[n - 1], niz[n - 1] + 1, niz[n - 1] - 1};\n  for (int i = 0; i < 6; i++) {\n    for (int j = 2; j < SQN; j++) {\n      if (!prost[j]) continue;\n      if (mogucnosti[i] % j == 0) brojiproste.insert(j);\n      while (mogucnosti[i] % j == 0) {\n        mogucnosti[i] /= j;\n      }\n    }\n    if (mogucnosti[i] > 1) brojiproste.insert(mogucnosti[i]);\n  }\n  for (set<long long>::iterator iter = brojiproste.begin();\n       iter != brojiproste.end(); iter++) {\n    prosti_brojevi.push_back(*iter);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin >> n >> A >> B;\n  for (int i = 0; i < n; i++) cin >> niz[i];\n  generatePrimes();\n  solve();\n  cout << minV << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, A, B;\nint a[1000010];\nbool vis[1000010];\nvector<int> p;\nvoid init() {\n  for (int i = 2; i < 40000; i++) {\n    if (vis[i]) continue;\n    int x = i * 2;\n    while (x < 40000) {\n      vis[x] = true;\n      x += i;\n    }\n  }\n  for (int i = 2; i < 40000; i++) {\n    if (!vis[i]) p.push_back(i);\n  }\n}\nlong long dp[1000010][3];\nlong long getcost(int x, int y) {\n  long long inf = (long long)n * (1e9);\n  if (x % y == 0) return 0;\n  if ((x + 1) % y == 0 || (x - 1) % y == 0) return B;\n  return inf;\n}\nlong long solve(int prime) {\n  long long inf = (long long)n * (1e9);\n  dp[1][0] = getcost(a[1], prime);\n  dp[1][1] = A;\n  dp[1][2] = inf;\n  for (int i = 2; i <= n; i++) {\n    dp[i][0] = min(inf, getcost(a[i], prime) + dp[i - 1][0]);\n    dp[i][1] = min(inf, min(dp[i - 1][0], dp[i - 1][1]) + A);\n    dp[i][2] = min(inf, min(dp[i - 1][2], dp[i - 1][1]) + getcost(a[i], prime));\n  }\n  return min(dp[n][0], min(dp[n][1], dp[n][2]));\n}\nint main() {\n  init();\n  scanf(\"%d%d%d\", &n, &A, &B);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", a + i);\n  }\n  int op[6] = {0, -1, 1, 0, -1, 1};\n  int num[6] = {a[1], a[1], a[1], a[n], a[n], a[n]};\n  long long ans = -1;\n  for (int i = 0; i < 6; i++) {\n    int x = op[i] + num[i], len = p.size();\n    for (int j = 0; j < len; j++) {\n      if (x == 1) break;\n      if (x % p[j] == 0) {\n        while (x % p[j] == 0) x /= p[j];\n        long long tmp = solve(p[j]);\n        if (ans == -1 || ans > tmp) ans = tmp;\n      }\n    }\n    if (x != 1) {\n      long long tmp = solve(x);\n      if (ans == -1 || ans > tmp) ans = tmp;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = (int)1e6 + 3;\nset<int> p;\nvoid f(int x) {\n  for (int i = 2; i * i <= x; i++)\n    if (x % i == 0) {\n      do x /= i;\n      while (x % i == 0);\n      p.insert(i);\n    }\n  if (x != 1) p.insert(x);\n}\nint n;\nlong long a, b;\nint arr[MAXN];\nlong long solve(int g) {\n  static long long s[MAXN];\n  memset(s, 0, sizeof(s));\n  int ll = -1, rr = 0;\n  int cntb = 0;\n  for (int i = 0; i < n; i++) {\n    int x = arr[i];\n    if (x % g == 0) continue;\n    if ((x + 1) % g == 0 || (x - 1) % g == 0) {\n      s[i] = 1;\n      cntb++;\n    } else {\n      s[i] = 2;\n      if (ll == -1) ll = i;\n      rr = i;\n    }\n  }\n  if (ll == -1) {\n    for (int i = 1; i < n; i++) s[i] += s[i - 1];\n    long long reduce = 0;\n    long long trace = -a;\n    int j = -1;\n    for (int i = 0; i < n; i++) {\n      long long _trace = b * s[i] - a * i;\n      long long score = _trace + trace;\n      if (score > reduce) {\n        reduce = score;\n        rr = i;\n        ll = j + 1;\n      }\n      _trace = -_trace;\n      if (_trace > trace) {\n        trace = _trace;\n        j = i;\n      }\n    }\n    for (int i = n - 1; i > 0; i--) s[i] -= s[i - 1];\n  } else {\n    long long reduce = 0;\n    int cnt = 0, tll = ll;\n    for (int i = ll - 1; i >= 0; i--)\n      if (s[i]) {\n        cnt++;\n        long long t = (long long)cnt * b - (long long)(ll - i) * a;\n        if (t > reduce) {\n          reduce = t;\n          tll = i;\n        }\n      }\n    ll = tll;\n    cnt = 0;\n    reduce = 0;\n    int trr = rr;\n    for (int i = rr + 1; i < n; i++)\n      if (s[i]) {\n        cnt++;\n        long long t = (long long)cnt * b - (long long)(i - rr) * a;\n        if (t > reduce) {\n          reduce = t;\n          trr = i;\n        }\n      }\n    rr = trr;\n  }\n  long long ret = 0;\n  if (ll != -1) {\n    for (int i = 0; i < ll; i++)\n      if (s[i]) ret += b;\n    for (int i = rr + 1; i < n; i++)\n      if (s[i]) ret += b;\n    ret += (long long)(rr - ll + 1) * a;\n    if (ll == 0 && rr == n - 1) ret += b - a;\n  } else\n    for (int i = 0; i < n; i++)\n      if (s[i]) ret += b;\n  return ret;\n}\nint main() {\n  cin >> n >> a >> b;\n  for (int i = 0; i < n; i++) scanf(\"%d\", arr + i);\n  for (int i = -1; i <= 1; i++) {\n    f(arr[0] + i);\n    f(arr[n - 1] + i);\n  }\n  long long ans = -1;\n  for (set<int>::iterator iter = p.begin(); iter != p.end(); iter++) {\n    long long temp = solve(*iter);\n    if (ans == -1 || temp < ans) ans = temp;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid addp(int a, vector<int>& P) {\n  int x = a;\n  for (int p = 2; p * p <= a; p++) {\n    if (x % p == 0) {\n      P.push_back(p);\n      while (x % p == 0) x = x / p;\n    }\n  }\n  if (x > 1) {\n    P.push_back(x);\n  }\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  long long a, b;\n  scanf(\"%I64d %I64d\", &a, &b);\n  if (n == 1) {\n    printf(\"0\");\n    return 0;\n  }\n  vector<int> A(n);\n  for (int i = 0; i < n; i++) scanf(\"%d\", &A[i]);\n  vector<int> P;\n  for (int i = -1; i < 2; i++) {\n    addp(A[0] + i, P);\n    addp(A[n - 1] + i, P);\n  }\n  sort(P.begin(), P.end());\n  P.erase(unique(P.begin(), P.end()), P.end());\n  long long INF = 1e18;\n  long long ans = INF;\n  for (int p : P) {\n    vector<long long> C(n);\n    for (int i = 0; i < n; i++) {\n      if (A[i] % p == 0)\n        C[i] = 0;\n      else if ((A[i] + 1) % p == 0 || (A[i] - 1) % p == 0)\n        C[i] = b;\n      else\n        C[i] = -1;\n    }\n    vector<pair<int, long long> > dp(n);\n    long long sall = 0;\n    int numx = 0;\n    for (int i = 0; i < n; i++) (C[i] == -1) ? numx++ : sall += C[i];\n    dp[0] = {numx, sall};\n    if (C[0] < 0) {\n      dp[0] = {numx - 1, sall + a};\n    } else\n      dp[0] = min(dp[0], {numx, sall - C[0] + a});\n    long long cur = INF;\n    if (dp[0].first == 0) cur = dp[0].second;\n    for (int i = 1; i < n; i++) {\n      dp[i] = {numx, sall};\n      if (C[i] < 0) {\n        dp[i] = {numx - 1, sall + a};\n      } else\n        dp[i] = min(dp[i], {numx, sall + a - C[i]});\n      int x = dp[i - 1].first;\n      long long y = dp[i - 1].second;\n      if (C[i] < 0) {\n        dp[i] = min(dp[i], {x - 1, y + a});\n      } else\n        dp[i] = min(dp[i], {x, y + a - C[i]});\n      if (dp[i].first == 0) cur = min(cur, dp[i].second);\n    }\n    ans = min(ans, cur);\n  }\n  printf(\"%I64d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long oo = 1e15 + 1;\nconst int mod = 1e9 + 7;\nconst int maxn = 1e6 + 5;\nlong long n, f[maxn][3], a, b, s[maxn], res(+oo);\nvoid Check(int x, int w) {\n  f[1][0] = f[1][1] = f[1][2] = w;\n  for (int i = 2; i <= n; ++i) {\n    f[i][0] = f[i - 1][0];\n    f[i][2] = f[i - 1][2];\n    if (s[i] % x != 0) {\n      if ((s[i] - 1) % x == 0 || (s[i] + 1) % x == 0)\n        f[i][0] += b, f[i][2] += b;\n      else\n        f[i][0] = +oo, f[i][2] = +oo;\n    }\n    f[i][1] = min(f[i - 1][1], f[i - 1][0]) + a;\n    f[i][2] = min(f[i][2], f[i][1]);\n  }\n  res = min(res, min(f[n][0], min(f[n][1], f[n][2])));\n}\nvoid Factorize(int x, int w) {\n  if (x <= 1) return;\n  for (int i = 2; i * i <= x; ++i)\n    if (x % i == 0) {\n      while (x % i == 0) x /= i;\n      Check(i, w);\n    }\n  if (x != 1) Check(x, w);\n}\nvoid Init() {\n  cin >> n >> a >> b;\n  for (int i = 1; i <= n; ++i) cin >> s[i];\n  Factorize(s[1] - 1, b);\n  Factorize(s[1], 0);\n  Factorize(s[1] + 1, b);\n  for (int i = 1; i <= n / 2 + 1; ++i) swap(s[i], s[n + 1 - i]);\n  Factorize(s[1] - 1, b);\n  Factorize(s[1], 0);\n  Factorize(s[1] + 1, b);\n  Check(5, b);\n  cout << res;\n}\nint main() {\n  ios_base ::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  Init();\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\n\npublic class D {\n    public static void solution(BufferedReader reader, PrintWriter out)\n            throws IOException {\n        In in = new In(reader);\n        n = in.nextInt();\n        a = in.nextInt();\n        b = in.nextInt();\n        d = new int[n];\n        for (int i = 0; i < n; i++)\n            d[i] = in.nextInt();\n        for (int j = -1; j <= 1; j++) {\n            fact(d[0] + j);\n            fact(d[n - 1] + j);\n        }\n        long res = (n - 1L) * a;\n        for (Integer fa : f)\n            res = Math.min(res, solve(fa));\n        out.println(res);\n    }\n\n    private static int n, a, b;\n    private static int[] d;\n    private static HashSet<Integer> f = new HashSet<Integer>();\n\n    private static void fact(int n) {\n        for (int i = 2; i * i <= n; i++)\n            if (n % i == 0) {\n                f.add(i);\n                while (n % i == 0)\n                    n /= i;\n            }\n        if (n > 1)\n            f.add(n);\n    }\n\n    private static long MAX = (long) 1e16;\n\n    private static long solve(int gcd) {\n        long[][] dp = new long[3][n];\n        Arrays.fill(dp[0], MAX);\n        Arrays.fill(dp[1], MAX);\n        Arrays.fill(dp[2], MAX);\n        if (d[0] % gcd == 0)\n            dp[0][0] = 0;\n        else if ((d[0] - 1) % gcd == 0 || (d[0] + 1) % gcd == 0)\n            dp[0][0] = b;\n        dp[1][0] = a;\n        dp[2][0] = a;\n        for (int i = 1; i < n; i++) {\n            dp[1][i] = Math.min(dp[0][i - 1], dp[1][i - 1]) + a;\n            dp[2][i] = Math.min(dp[0][i - 1], dp[1][i - 1]) + a;\n            if (d[i] % gcd == 0) {\n                dp[0][i] = dp[0][i - 1];\n                dp[2][i] = Math.min(dp[2][i], dp[2][i - 1]);\n            }\n            else if ((d[i] - 1) % gcd == 0 || (d[i] + 1) % gcd == 0) {\n                dp[0][i] = dp[0][i - 1] + b;\n                dp[2][i] = Math.min(dp[2][i], dp[2][i - 1] + b);\n            }\n            dp[0][i] = Math.min(dp[0][i], MAX);\n            dp[1][i] = Math.min(dp[1][i], MAX);\n            dp[2][i] = Math.min(dp[2][i], MAX);\n        }\n        return Math.min(dp[0][n - 1], dp[2][n - 1]);\n    }\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader reader = new BufferedReader(\n                new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(\n                new BufferedWriter(new OutputStreamWriter(System.out)));\n        solution(reader, out);\n        out.close();\n    }\n\n    protected static class In {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer = new StringTokenizer(\"\");\n\n        public In(BufferedReader reader) {\n            this.reader = reader;\n        }\n\n        public String next() throws IOException {\n            while (!tokenizer.hasMoreTokens())\n                tokenizer = new StringTokenizer(reader.readLine());\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long MOD = 1e9 + 7;\nlong long A, B;\nlong long ans = 1e18;\nlong long dp[1100000][3];\nint a[2000000], n;\nvector<int> v1;\nvoid gcd(int x) {\n  for (int i = 2; i * i <= x; i++) {\n    if (x % i == 0) {\n      v1.push_back(i);\n      while (x % i == 0) x /= i;\n    }\n  }\n  if (x > 1) v1.push_back(x);\n}\nvoid javab(int x) {\n  int k, j;\n  for (int i = 1; i <= n; i++) {\n    dp[i][0] = dp[i][1] = dp[i][2] = 1e18;\n    int s = -1;\n    if (a[i - 1] % x == 0)\n      s = 0;\n    else if ((a[i - 1] + 1) % x == 0 || (a[i - 1] - 1) % x == 0)\n      s = 1;\n    if (s != -1) {\n      dp[i][0] = dp[i - 1][0] + B * (long long)(s);\n      dp[i][2] = dp[i - 1][2] + B * (long long)(s);\n      dp[i][2] = min(dp[i][2], dp[i - 1][0] + B * (long long)(s));\n      dp[i][2] = min(dp[i][2], dp[i - 1][1] + B * (long long)(s));\n    }\n    dp[i][1] = dp[i - 1][1] + A;\n    dp[i][1] = min(dp[i][1], dp[i - 1][0] + A);\n  }\n  long long q = min(dp[n][0], dp[n][1]);\n  q = min(q, dp[n][2]);\n  ans = min(ans, q);\n}\nint main() {\n  cin >> n >> A >> B;\n  for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n  gcd(a[0]);\n  gcd(a[0] - 1);\n  gcd(a[0] + 1);\n  gcd(a[n - 1]);\n  gcd(a[n - 1] + 1);\n  gcd(a[n - 1] - 1);\n  sort(v1.begin(), v1.end());\n  vector<int> v2;\n  v2.push_back(v1[0]);\n  for (int i = 1; i < v1.size(); i++)\n    if (v1[i] != v1[i - 1]) v2.push_back(v1[i]);\n  v1 = v2;\n  for (int i = 0; i < v1.size(); i++) javab(v1[i]);\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N;\nlong long A, B;\nlong long arr[1100000];\nset<long long> pri;\nlong long ans = 1000000000000000001ll;\nvoid genprime(long long u) {\n  if (u == 1ll) {\n    return;\n  }\n  int x = (int)(sqrt(u));\n  for (long long i = 2; i <= x; i++) {\n    if (u % i == 0) {\n      pri.insert(i);\n      while (u % i == 0) {\n        u /= i;\n      }\n    }\n  }\n  if (u > 1) {\n    pri.insert(u);\n  }\n  return;\n}\nlong long cost(long long p) {\n  long long a = 0, b = 0, c = 0;\n  for (int i = 0; i < N; i++) {\n    if (arr[i] % p == 0ll) {\n      b += A;\n    } else if ((arr[i] - 1) % p == 0ll || (arr[i] + 1) % p == 0ll) {\n      a += B;\n      c += B;\n      b += A;\n    } else {\n      a += 1000000000000000001ll;\n      c += 1000000000000000001ll;\n      b += A;\n    }\n    a = min(a, 1000000000000000001ll);\n    b = min(b, a);\n    c = min(c, b);\n  }\n  return c;\n}\nint readint() {\n  char c = ' ';\n  while (c < '0') {\n    c = getchar();\n  }\n  int res = 0;\n  while (c >= '0') {\n    res = 10 * res + c - '0';\n    c = getchar();\n  }\n  return res;\n}\nlong long readll() {\n  char c = ' ';\n  while (c < '0') {\n    c = getchar();\n  }\n  long long res = 0;\n  while (c >= '0') {\n    res = 10 * res + c - '0';\n    c = getchar();\n  }\n  return res;\n}\nint32_t main() {\n  if (fopen(\"cf624d.in\", \"r\")) {\n    freopen(\"cf624d.in\", \"r\", stdin);\n    freopen(\"cf624d.out\", \"w\", stdout);\n  }\n  N = readint();\n  A = readll();\n  B = readll();\n  for (int i = 0; i < N; i++) {\n    arr[i] = readll();\n  }\n  genprime(arr[0]);\n  genprime(arr[0] - 1);\n  genprime(arr[0] + 1);\n  genprime(arr[N - 1]);\n  genprime(arr[N - 1] - 1);\n  genprime(arr[N - 1] + 1);\n  for (set<long long>::iterator it = pri.begin(); it != pri.end(); it++) {\n    long long p = *it;\n    ans = min(ans, cost(p));\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1111111;\nconst int M = 111111;\nvector<int> vec;\nint a[N];\nint n, A, B;\nlong long dp[N][3];\nvoid get_pri_factor(int x) {\n  for (int i = 2; i * i <= x; i++) {\n    if (x % i == 0) {\n      vec.push_back(i);\n      while (x % i == 0) x /= i;\n    }\n  }\n  if (x > 1) vec.push_back(x);\n}\nlong long get_cost(int x, int y) {\n  if (x % y == 0) return 0;\n  if ((x + 1) % y == 0) return B;\n  if ((x - 1) % y == 0) return B;\n  return LLONG_MAX;\n}\nvoid check_min(long long &a, long long b) {\n  if (a > b) a = b;\n}\nvoid solve() {\n  get_pri_factor(a[1]);\n  get_pri_factor(a[1] - 1);\n  get_pri_factor(a[1] + 1);\n  get_pri_factor(a[n]);\n  get_pri_factor(a[n] - 1);\n  get_pri_factor(a[n] + 1);\n  sort(vec.begin(), vec.end());\n  vec.erase(unique(vec.begin(), vec.end()), vec.end());\n  long long ans = LLONG_MAX;\n  for (int k = 0; k < vec.size(); k++) {\n    int x = vec[k];\n    for (int i = 0; i <= n; i++) {\n      for (int j = 0; j <= 2; j++) {\n        dp[i][j] = LLONG_MAX;\n      }\n    }\n    dp[0][0] = 0;\n    for (int i = 1; i <= n; i++) {\n      long long cost = get_cost(a[i], x);\n      if (dp[i - 1][0] < LLONG_MAX) {\n        if (cost < LLONG_MAX) check_min(dp[i][0], dp[i - 1][0] + cost);\n        check_min(dp[i][1], dp[i - 1][0] + A);\n      }\n      if (dp[i - 1][1] < LLONG_MAX) {\n        check_min(dp[i][1], dp[i - 1][1] + A);\n        if (cost < LLONG_MAX) dp[i][2] = min(dp[i][2], dp[i - 1][1] + cost);\n      }\n      if (dp[i - 1][2] < LLONG_MAX) {\n        if (cost < LLONG_MAX) check_min(dp[i][2], dp[i - 1][2] + cost);\n      }\n    }\n    ans = min(ans, min(dp[n][0], min(dp[n][1], dp[n][2])));\n  }\n  cout << ans << endl;\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &A, &B);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int SQN = 31630;\nconst int MAXN = 1e6 + 1;\nvector<int> prosti_brojevi;\nbool prost[SQN];\nconst long long inf = (long long)1e17;\nlong long n, A, B;\nlong long minV = inf;\nint niz[MAXN];\nlong long dp[MAXN][3];\nvoid solve() {\n  for (int k = 0; k < prosti_brojevi.size(); k++) {\n    long long cp = prosti_brojevi[k];\n    long long delta;\n    if (niz[0] % cp == 0)\n      delta = 0;\n    else if ((niz[0] - 1) % cp == 0 || (niz[0] + 1) % cp == 0)\n      delta = B;\n    else\n      delta = inf;\n    dp[0][0] = delta;\n    dp[0][2] = dp[0][1] = A;\n    for (int i = 1; i < n; i++) {\n      if (niz[i] % cp == 0)\n        delta = 0;\n      else if ((niz[i] - 1) % cp == 0 || (niz[i] + 1) % cp == 0)\n        delta = B;\n      else\n        delta = inf;\n      dp[i][0] = dp[i - 1][0] + delta;\n      dp[i][1] = min(dp[i - 1][1] + delta, dp[i - 1][2] + delta);\n      dp[i][2] = min(dp[i - 1][0] + A, dp[i - 1][2] + A);\n      dp[i][0] = min(dp[i][0], inf);\n      dp[i][1] = min(dp[i][1], inf);\n      dp[i][2] = min(dp[i][2], inf);\n    }\n    minV = min(minV, min(dp[n - 1][0], min(dp[n - 1][1], dp[n - 1][2])));\n  }\n}\nset<long long> brojiproste;\nvoid generatePrimes() {\n  for (int i = 0; i < SQN; i++) prost[i] = true;\n  prost[0] = prost[1] = false;\n  for (int i = 2; i < SQN; i++) {\n    if (!prost[i]) continue;\n    for (int j = i * 2; j < SQN; j += i) prost[j] = false;\n  }\n  long long mogucnosti[] = {niz[0],     niz[0] + 1,     niz[0] - 1,\n                            niz[n - 1], niz[n - 1] + 1, niz[n - 1] - 1};\n  for (int i = 0; i < 6; i++) {\n    for (int j = 2; j < SQN; j++) {\n      if (!prost[j]) continue;\n      if (mogucnosti[i] % j == 0) brojiproste.insert(j);\n      while (mogucnosti[i] % j == 0) {\n        mogucnosti[i] /= j;\n      }\n    }\n    if (mogucnosti[i] > 1) brojiproste.insert(mogucnosti[i]);\n  }\n  for (set<long long>::iterator iter = brojiproste.begin();\n       iter != brojiproste.end(); iter++) {\n    prosti_brojevi.push_back(*iter);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin >> n >> A >> B;\n  for (int i = 0; i < n; i++) cin >> niz[i];\n  generatePrimes();\n  solve();\n  cout << minV << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 1000100;\nint n, arr[MAX];\nlong long mem[MAX][3], a, b, ans = (1LL << 60);\nvector<int> factorize(int num) {\n  vector<int> ret;\n  for (int i = 2; i <= num / i; i += 1 + (i & 1))\n    while (num % i == 0) ret.push_back(i), num /= i;\n  if (num > 1) ret.push_back(num);\n  return ret;\n}\nlong long dp(int idx, int flag, int p) {\n  if (idx == n) return 0;\n  long long &ret = mem[idx][flag];\n  if (ret != -1) return ret;\n  if (arr[idx] % p == 0)\n    ret = dp(idx + 1, 2 * (flag != 0), p);\n  else if ((arr[idx] - 1) % p == 0 || (arr[idx] + 1) % p == 0)\n    ret = b + dp(idx + 1, 2 * (flag != 0), p);\n  else\n    ret = (1LL << 60);\n  if (flag < 2) ret = min(ret, a + dp(idx + 1, 1, p));\n  return ret;\n}\nint main() {\n  cin >> n >> a >> b;\n  for (int i = 0; i < n; i++) scanf(\"%d\", arr + i);\n  int f[6] = {arr[0],     arr[0] - 1,     arr[0] + 1,\n              arr[n - 1], arr[n - 1] - 1, arr[n - 1] + 1};\n  set<int> s;\n  for (int i = 0; i < 6; i++) {\n    vector<int> temp = factorize(f[i]);\n    s.insert(temp.begin(), temp.end());\n  }\n  for (int p : s) {\n    memset(mem, -1, (n + 1) * sizeof mem[0]);\n    ans = min(ans, dp(0, 0, p));\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, *x;\nlong long a, b;\nconst long long INF = 1e16;\nlong long solve(int d) {\n  char* type = new char[n];\n  vector<int> pos;\n  for (int i = 0; i < n; i++) {\n    if (x[i] % d == 0)\n      type[i] = 0;\n    else if ((x[i] - 1) % d == 0 || (x[i] + 1) % d == 0)\n      type[i] = 1;\n    else\n      type[i] = 2;\n    if (type[i] > 0) pos.push_back(i);\n  }\n  if (pos.empty()) return 0;\n  if (pos.size() == 1) {\n    if (type[pos[0]] == 1)\n      return min(a, b);\n    else\n      return a;\n  }\n  long long dd = 0, dl = 0;\n  bool good = 1;\n  vector<long long> left;\n  left.resize(pos.size());\n  for (int i = 0; i < pos.size() - 1; i++) {\n    if (type[pos[i]] == 2) good = 0;\n    if (type[pos[i]] == 1 && good) dd += -(pos[i + 1] - pos[i]) * a + b;\n    dl = min(dl, dd);\n    left[i] = dl;\n  }\n  if (type[pos.back()] == 1 && good) {\n    dd += -a + b;\n    dl = min(dl, dd);\n    left[pos.size() - 1] = dl;\n  }\n  dd = 0;\n  long long dr = 0;\n  good = 1;\n  vector<long long> right;\n  right.resize(pos.size());\n  for (int i = pos.size() - 1; i > 0; i--) {\n    if (type[pos[i]] == 2) good = 0;\n    if (type[pos[i]] == 1 && good) dd += -(pos[i] - pos[i - 1]) * a + b;\n    dr = min(dr, dd);\n    right[i] = dr;\n  }\n  if (type[pos[0]] == 1 && good) {\n    dd += -a + b;\n    dr = min(dr, dd);\n    right[0] = dr;\n  }\n  long long cost = (pos.back() - pos[0] + 1) * a;\n  dd = min(0ll, right[1]);\n  right.push_back(0);\n  right.push_back(0);\n  for (int i = 0; i < pos.size(); i++) dd = min(dd, left[i] + right[i + 2]);\n  cost += dd;\n  delete[] type;\n  return cost;\n}\nlong long solve2(int r) {\n  long long s1 = 0, s2 = 0, s3 = 0;\n  for (int i = 0; i < n; ++i) {\n    long long cost = INF;\n    if (x[i] % r == 0) {\n      cost = 0;\n    } else if ((x[i] - 1) % r == 0 || (x[i] + 1) % r == 0) {\n      cost = b;\n    }\n    s1 += cost, s2 += a, s3 += cost;\n    s1 = min(s1, INF), s2 = min(s2, s1), s3 = min(s2, s3);\n  }\n  return s3;\n}\nint main() {\n  scanf(\"%d%I64d%I64d\", &n, &a, &b);\n  x = new int[n];\n  for (int i = 0; i < n; i++) scanf(\"%d\", x + i);\n  int y[6] = {x[0], x[0] - 1, x[0] + 1, x[n - 1], x[n - 1] - 1, x[n - 1] + 1};\n  long long pen[6] = {0, b, b, 0, b, b};\n  long long ssol = max(n * b, n * a) + 10;\n  int* x0 = x;\n  int n0 = n;\n  for (int i = 0; i < 6; i++) {\n    if (i == 1 || i == 2) {\n      n = n - 1;\n      x += 1;\n    } else if (i == 4 || i == 5) {\n      n = n - 1;\n    }\n    for (int d = 2; d * d <= y[i]; d++) {\n      if (y[i] % d == 0) ssol = min(ssol, solve2(d) + pen[i]);\n      while (y[i] % d == 0) y[i] /= d;\n    }\n    if (y[i] > 1) ssol = min(ssol, solve2(y[i]) + pen[i]);\n    n = n0;\n    x = x0;\n  }\n  printf(\"%I64d\", ssol);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid ga(int N, int *A) {\n  for (int i(0); i < N; i++) scanf(\"%d\", A + i);\n}\nlong long P[(1000006) >> 1] = {2}, L(1), cn[(1000006) >> 5];\nvoid gen() {\n  (cn[0 >> 6] |= 1ULL << ((0 & 63))), (cn[1 >> 6] |= 1ULL << ((1 & 63)));\n  int Q(1 + sqrt((1 << 17)));\n  for (int k(3); k <= Q; k += 2)\n    if (!((cn[k >> 6] >> (k & 63)) & 1))\n      for (long long h(k << 1), j(k * k); j < (1 << 17); j += h)\n        (cn[j >> 6] |= 1ULL << ((j & 63)));\n  for (int i(3); i < (1 << 17); i += 2)\n    if (!((cn[i >> 6] >> (i & 63)) & 1)) P[L++] = i;\n}\nint fc(int N, int *f, int *c) {\n  int L(0);\n  for (int i(0), h(0); N >= P[i] * P[i]; ++i, h = 0) {\n    while (!(N % P[i])) ++h, N /= P[i];\n    if (h) f[L] = P[i], c[L++] = h;\n  }\n  if (N > 1) f[L] = N, c[L++] = 1;\n  return L;\n}\nint N, A[(1000006)], a, b, f[16], c[16], W, sx[] = {1, 0, -1};\nlong long dp[(1000006)][2][2], B((1ll << 60));\nlong long dyn(int u, int d, int f) {\n  if (u == N) return 0;\n  long long &v(dp[u][d][f]);\n  if (~v) return v;\n  v = (1ll << 60);\n  for (int i(0); i < 3; i++)\n    if (!((A[u] + sx[i]) % W)) v = min(v, dyn(u + 1, d, 0) + (sx[i] ? b : 0));\n  if (!d || f) v = min(v, a + dyn(u + 1, 1, 1));\n  return v;\n}\nint main(void) {\n  gen();\n  scanf(\"%d%d%d\", &N, &a, &b), ga(N, A);\n  for (int i(0); i < 3; i++) {\n    int l = fc(A[0] + sx[i], f, c), p(sx[i] ? b : 0);\n    for (int i(0); i < l; i++)\n      (memset(dp, -1, sizeof(dp))), W = f[i], B = min(B, dyn(1, 0, 0) + p);\n  }\n  --N;\n  for (int i(0); i < 3; i++) {\n    (memset(dp, -1, sizeof(dp)));\n    int l = fc(A[N] + sx[i], f, c), p(sx[i] ? b : 0);\n    for (int i(0); i < l; i++)\n      (memset(dp, -1, sizeof(dp))), W = f[i], B = min(B, dyn(0, 1, 1) + p);\n  }\n  printf(\"%lld\\n\", B);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint gcd(int a, int b) {\n  if (a < b) swap(b, a);\n  while (b != 0) {\n    int tmp = b;\n    b = a % b;\n    a = tmp;\n  }\n  return a;\n}\nint n;\nlong long x, y;\nvector<pair<int, long long> > ra[1000111], rb[1000111], rc[1000111];\nvoid solve(vector<int> &a, vector<pair<int, long long> > r[]) {\n  vector<pair<int, long long> > d;\n  d.push_back(make_pair(a[0], 0LL));\n  d.push_back(make_pair(a[0] - 1, y));\n  d.push_back(make_pair(a[0] + 1, y));\n  r[0] = d;\n  for (int i = 1; i < n; ++i) {\n    vector<pair<int, long long> > dd;\n    for (int j = 0; j < d.size(); ++j) {\n      int d1 = gcd(d[j].first, a[i] - 1);\n      int d2 = gcd(d[j].first, a[i]);\n      int d3 = gcd(d[j].first, a[i] + 1);\n      if (d1 != 1) dd.push_back(make_pair(d1, d[j].second + y));\n      if (d2 != 1) dd.push_back(make_pair(d2, d[j].second));\n      if (d3 != 1) dd.push_back(make_pair(d3, d[j].second + y));\n    }\n    sort(dd.begin(), dd.end());\n    d.clear();\n    for (int j = 0; j < dd.size(); ++j) {\n      if (!d.empty() && d.back().first == dd[j].first)\n        d.back().second = min(d.back().second, dd[j].second);\n      else\n        d.push_back(dd[j]);\n    }\n    r[i] = d;\n  }\n}\nlong long ans = 1000000000000000000LL;\nvoid update(int i, vector<pair<int, long long> > &rb) {\n  for (int j = 0; j < ra[n - 1 - i].size(); ++j)\n    for (int k = 0; k < rb.size(); ++k)\n      if (gcd(ra[n - 1 - i][j].first, rb[k].first) != 1)\n        ans = min(ans, ra[n - 1 - i][j].second + rb[k].second);\n}\nvoid reform(vector<pair<int, long long> > r[]) {\n  vector<pair<int, long long> > r2;\n  r2.push_back(make_pair(0, x));\n  for (int i = 1; i < n; ++i) {\n    update(i, r2);\n    vector<pair<int, long long> > dd;\n    dd = r2;\n    for (int j = 0; j < r2.size(); ++j) dd[j].second += x;\n    for (int j = 0; j < r[i - 1].size(); ++j) {\n      pair<int, long long> q = r[i - 1][j];\n      q.second += x;\n      dd.push_back(q);\n    }\n    for (int j = 0; j < dd.size(); ++j) {\n      for (int k = j + 1; k < dd.size(); ++k) {\n        if (dd[j].first && dd[k].second <= dd[j].second &&\n            dd[k].first % dd[j].first == 0) {\n          dd[j] = dd.back();\n          dd.pop_back();\n          --j;\n          break;\n        }\n        if (dd[k].first && dd[j].second <= dd[k].second &&\n            dd[j].first % dd[k].first == 0) {\n          dd[k] = dd.back();\n          dd.pop_back();\n          --k;\n        }\n      }\n    }\n    sort(dd.begin(), dd.end());\n    vector<pair<int, long long> > d(1, dd[0]);\n    for (int j = 1; j < dd.size(); ++j) {\n      if (d.back().first == dd[j].first)\n        d.back().second = min(d.back().second, dd[j].second);\n      else\n        d.push_back(dd[j]);\n    }\n    r2 = d;\n  }\n  for (int j = 0; j < r2.size(); ++j) ans = min(ans, r2[j].second);\n}\nlong long solve2() {\n  for (int j = 0; j < ra[n - 1].size(); ++j)\n    ans = min(ans, ra[n - 1][j].second);\n  return ans;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> n >> x >> y;\n  vector<int> a(n);\n  for (int i = 0; i < n; ++i) cin >> a[i];\n  solve(a, ra);\n  for (int i = 0, j = n - 1; i < j; ++i, --j) swap(a[i], a[j]);\n  solve(a, rc);\n  reform(rc);\n  long long res = solve2();\n  cout << res << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = int(1e6) + 10;\nlong long dp[maxn][3];\nint arr[maxn];\nint n, a, b;\nlong long solve(int x, int y) {\n  if (x == 1) return LLONG_MAX;\n  vector<int> vp;\n  for (int i = 2; 1ll * i * i <= x; i++) {\n    if (x % i == 0) {\n      vp.push_back(i);\n      while (x % i == 0) x /= i;\n    }\n  }\n  if (x > 1) vp.push_back(x);\n  long long ans = LLONG_MAX;\n  for (int i : vp) {\n    memset(dp, 0x3f, sizeof(dp));\n    dp[0][0] = y;\n    dp[0][2] = y;\n    for (int j = 1; j < n; j++) {\n      dp[j][1] = min(dp[j][1], a + min(dp[j - 1][1], dp[j - 1][0]));\n      if (arr[j] % i == 0) {\n        dp[j][0] = min(dp[j - 1][0], dp[j][0]);\n        dp[j][2] = min(dp[j][2], min(dp[j - 1][1], dp[j - 1][2]));\n      }\n      if ((arr[j] + 1) % i == 0 || (arr[j] - 1) % i == 0) {\n        dp[j][2] = min(dp[j][2], min(dp[j - 1][1], dp[j - 1][2]) + b);\n        dp[j][0] = min(dp[j][0], dp[j - 1][0] + b);\n      }\n    }\n    ans = min(ans, dp[n - 1][0]);\n    ans = min(ans, dp[n - 1][1]);\n    ans = min(ans, dp[n - 1][2]);\n  }\n  return ans;\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &a, &b);\n  for (int i = 0; i < n; i++) scanf(\"%d\", &arr[i]);\n  long long ans = LLONG_MAX;\n  ans = min(ans, solve(arr[0], 0));\n  ans = min(ans, solve(arr[0] + 1, b));\n  ans = min(ans, solve(arr[0] - 1, b));\n  reverse(arr, arr + n);\n  ans = min(ans, solve(arr[0] + 1, b));\n  ans = min(ans, solve(arr[0] - 1, b));\n  ans = min(ans, solve(arr[0], 0));\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INFint = 2e9;\nconst unsigned long long INF = 1e18;\nconst int MOD = 1e9 + 7;\nset<int> all;\nvector<int> v;\nunsigned long long a, b;\nvoid factorize(int x) {\n  vector<int> cur;\n  for (int d = 2; 1ll * d * d <= x; d += 1 + (d != 2)) {\n    if (x % d == 0) {\n      cur.push_back(d);\n      while (x % d == 0) x /= d;\n    }\n  }\n  if (x > 1) all.insert(x);\n  all.insert(cur.begin(), cur.end());\n}\nunsigned long long price(int x, int p) {\n  int r = min(x % p, p - x % p);\n  if (r > 1) return INF;\n  return b * r;\n}\nunsigned long long solve(int p) {\n  int n = v.size();\n  vector<vector<unsigned long long> > dp(n, vector<unsigned long long>(3, INF));\n  dp[0][0] = price(v[0], p);\n  dp[0][1] = a;\n  for (int i = 1; i < n; i++) {\n    dp[i][0] = dp[i - 1][0] + price(v[i], p);\n    dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + a;\n    dp[i][2] = min(dp[i - 1][1], dp[i - 1][2]) + price(v[i], p);\n    dp[i][0] = min(dp[i][0], INF);\n    dp[i][1] = min(dp[i][1], INF);\n    dp[i][2] = min(dp[i][2], INF);\n  }\n  return min(dp[n - 1][0], min(dp[n - 1][1], dp[n - 1][2]));\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  int n;\n  cin >> n >> a >> b;\n  v.resize(n);\n  for (auto &x : v) cin >> x;\n  for (int d = -1; d < 2; d++) {\n    factorize(v[0] + d);\n    factorize(v.back() + d);\n  }\n  vector<int> cur(all.begin(), all.end());\n  unsigned long long ans = INF;\n  for (auto p : cur) {\n    ans = min(ans, solve(p));\n  }\n  cout << ans;\n  fprintf(stderr, \"\\nTIME = %lf\\n\", 1.0 * clock() / CLOCKS_PER_SEC);\n  ;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1e18;\nconst int MAX = 1e6 + 5;\nint n, l, e[MAX], p[MAX], a, b;\nlong long dp[MAX][3];\nvoid factor(int x) {\n  for (int i = 2; i * i <= x; i++) {\n    if (x % i == 0) {\n      while (x % i == 0) x /= i;\n      p[++l] = i;\n    }\n  }\n  if (x > 1) p[++l] = x;\n}\nbool can(int x, int p) {\n  return (x - 1) % p == 0 || x % p == 0 || (x + 1) % p == 0;\n}\nint cost(int x, int p) { return x % p == 0 ? 0 : b; }\nlong long solve(int p) {\n  for (int i = 1; i <= n + 1; i++)\n    for (int j = 0; j < 3; j++) dp[i][j] = INF;\n  dp[n + 1][0] = dp[n + 1][1] = dp[n + 1][2] = 0;\n  for (int i = n; i > 0; i--) {\n    int r = can(e[i], p);\n    int ct = cost(e[i], p);\n    if (r == 1) dp[i][0] = dp[i + 1][0] + ct;\n    dp[i][0] = min(dp[i][0], dp[i + 1][1] + a);\n    if (r == 1) dp[i][1] = dp[i + 1][2] + ct;\n    dp[i][1] = min(dp[i][1], dp[i + 1][1] + a);\n    if (r == 1) dp[i][2] = dp[i + 1][2] + ct;\n  }\n  return dp[1][0];\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &a, &b);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &e[i]);\n  factor(e[1] - 1);\n  factor(e[1] + 1);\n  factor(e[1]);\n  factor(e[n] - 1);\n  factor(e[n] + 1);\n  factor(e[n]);\n  long long sol = INF;\n  for (int i = 1; i <= l; i++) sol = min(sol, solve(p[i]));\n  printf(\"%I64d\\n\", sol);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 999999999;\nconst int mod = 1000000007;\ninline int Getint() {\n  char ch = getchar();\n  while (ch < '0' || ch > '9') ch = getchar();\n  int ret = 0;\n  while (ch >= '0' && ch <= '9') ret = ret * 10 + ch - '0', ch = getchar();\n  return ret;\n}\nlong long f[1000010][3];\nint a[1000010];\nint n, costa, costb;\ninline void Add(set<int> &s, int x) {\n  for (int i = 2; i * i <= x; i++) {\n    if (x % i == 0) {\n      s.insert(i);\n      while (x % i == 0) x /= i;\n    }\n  }\n  if (x != 1) s.insert(x);\n}\ninline bool Check(int x, int y) {\n  return x % y == 0 || (x - 1) % y == 0 || (x + 1) % y == 0;\n}\ninline bool Check2(int x, int y) { return x % y != 0; }\ninline long long Calc(int x) {\n  memset(f, 0, sizeof(f));\n  f[0][0] = 0;\n  f[0][1] = f[0][2] = (long long)inf * inf;\n  for (int i = 1; i <= n; i++) {\n    f[i][0] = f[i][1] = f[i][2] = (long long)inf * inf;\n    if (Check(a[i], x)) {\n      int cur = Check2(a[i], x);\n      f[i][0] = min(f[i][0], f[i - 1][0] + Check2(a[i], x) * costb);\n      f[i][2] =\n          min(f[i][0], min(f[i - 1][1], f[i - 1][2]) + Check2(a[i], x) * costb);\n    }\n    f[i][1] = min(f[i][1], min(f[i - 1][0], f[i - 1][1]) + costa);\n  }\n  return min(f[n][0], min(f[n][1], f[n][2]));\n}\ninline void Work() {\n  set<int> s;\n  Add(s, a[1] - 1), Add(s, a[1]), Add(s, a[1] + 1);\n  Add(s, a[n] - 1), Add(s, a[n]), Add(s, a[n] + 1);\n  long long ans = (long long)inf * inf;\n  for (set<int>::iterator it = s.begin(); it != s.end(); it++) {\n    ans = min(ans, Calc(*it));\n  }\n  cout << ans << endl;\n}\nint main() {\n  n = Getint(), costa = Getint(), costb = Getint();\n  if (n == 1) {\n    puts(\"0\");\n    return 0;\n  }\n  for (int i = 1; i <= n; i++) {\n    a[i] = Getint();\n  }\n  Work();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long inf = (1LL << 60);\nconst int N = 1e6 + 1;\nlong long n, a, b;\nvector<long long> ve;\nint p;\nlong long memo[N][3][2];\nlong long solve(int i, int flag, bool ok) {\n  if (i == n) return (ok ? 0 : inf);\n  long long &ret = memo[i][flag][ok];\n  if (ret != -1) return ret;\n  ret = inf;\n  if (flag == 2) {\n    if (ve[i] % p == 0)\n      ret = solve(i + 1, flag, true);\n    else if ((ve[i] - 1) % p == 0 || (ve[i] + 1) % p == 0)\n      ret = b + solve(i + 1, flag, true);\n  }\n  if (flag == 1) {\n    ret = a + solve(i + 1, 1, ok);\n    if (ve[i] % p == 0)\n      ret = min(ret, solve(i + 1, 2, true));\n    else if ((ve[i] - 1) % p == 0 || (ve[i] + 1) % p == 0)\n      ret = min(ret, b + solve(i + 1, 2, true));\n  }\n  if (flag == 0) {\n    ret = a + solve(i + 1, 1, ok);\n    if (ve[i] % p == 0)\n      ret = min(ret, solve(i + 1, flag, true));\n    else if ((ve[i] - 1) % p == 0 || (ve[i] + 1) % p == 0)\n      ret = min(ret, b + solve(i + 1, flag, true));\n  }\n  return ret;\n}\nbitset<N> isprime;\nvector<int> primes;\nvoid sieve() {\n  isprime.set();\n  primes.push_back(2);\n  for (int i = 3; i * i <= N; i += 2) {\n    for (int j = i * 2; j <= N; j += i) isprime[j] = 0;\n  }\n  for (int i = 3; i <= N; i += 2)\n    if (isprime[i]) primes.push_back(i);\n}\nset<int> se;\nvoid fact(int n) {\n  int PF_idx = 0, PF = primes[PF_idx];\n  while (PF * PF <= n) {\n    if (n % PF == 0) {\n      se.insert(PF);\n      while (n % PF == 0) n /= PF;\n    }\n    PF = primes[++PF_idx];\n  }\n  if (n > 1) se.insert(n);\n}\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n  sieve();\n  cin >> n >> a >> b;\n  for (int i = 0; i < n; i++) {\n    long long x;\n    cin >> x;\n    ve.push_back(x);\n    if (i == 0 || i == n - 1) {\n      fact(x);\n      fact(x - 1);\n      fact(x + 1);\n    }\n  }\n  long long ret = inf;\n  for (auto i : se) {\n    p = i;\n    memset(memo, -1, sizeof memo);\n    ret = min(ret, solve(0, 0, 0));\n  }\n  cout << ret << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 1000005;\nconst int X_NOTB = 0;\nconst int X_BEG = 1;\nconst int X_END = 2;\nconst long long INF = 1000000000000000000LL;\nint mas[MAX_N];\nlong long dp[MAX_N][3];\nset<int> st;\nlong long n, a, b;\nvoid razlozh(int x) {\n  int p = 2;\n  while (p * p <= x) {\n    if (x % p == 0) st.insert(p);\n    while (x % p == 0) x /= p;\n    p++;\n  }\n  if (x > 1) st.insert(x);\n  return;\n}\nlong long get_ans(int p) {\n  for (int i = 0; i < MAX_N; i++)\n    for (int j = 0; j < 3; j++) dp[i][j] = INF;\n  dp[0][X_NOTB] = dp[0][X_END] = dp[0][X_BEG] = 0;\n  for (int i = 0; i < n; i++) {\n    if (mas[i] % p == 0) {\n      dp[i + 1][X_NOTB] = dp[i][X_NOTB];\n      dp[i + 1][X_BEG] = min(dp[i][X_BEG], dp[i][X_NOTB]) + a;\n      dp[i + 1][X_END] = min(dp[i][X_END], dp[i][X_BEG]);\n    } else if ((mas[i] + 1) % p == 0 || (mas[i] - 1) % p == 0) {\n      dp[i + 1][X_NOTB] = dp[i][X_NOTB] + b;\n      dp[i + 1][X_BEG] = min(dp[i][X_BEG], dp[i][X_NOTB]) + a;\n      dp[i + 1][X_END] = min(dp[i][X_END], dp[i][X_BEG]) + b;\n    } else {\n      dp[i + 1][X_NOTB] = INF;\n      dp[i + 1][X_BEG] = min(dp[i][X_BEG], dp[i][X_NOTB]) + a;\n      dp[i + 1][X_END] = INF;\n    }\n  }\n  long long ans = min(dp[n][X_NOTB], dp[n][X_END]);\n  if (dp[n][X_BEG] < ans) {\n    if (dp[n][X_BEG] == n * a) {\n      if (mas[0] % p == 0 || (mas[0] - 1) % p == 0 || (mas[0] + 1) % p == 0)\n        ans = min(ans, (n - 1) * a + b);\n    } else\n      ans = dp[n][X_BEG];\n  }\n  return ans;\n}\nint main() {\n  scanf(\"%d %d %d\", &n, &a, &b);\n  for (int i = 0; i < n; i++) scanf(\"%d\", &mas[i]);\n  razlozh(mas[0] - 1);\n  razlozh(mas[0]);\n  razlozh(mas[0] + 1);\n  razlozh(mas[n - 1] - 1);\n  razlozh(mas[n - 1]);\n  razlozh(mas[n - 1] + 1);\n  long long ans = INF;\n  for (set<int>::iterator i = st.begin(); i != st.end(); i++) {\n    long long sum = get_ans(*i);\n    ans = min(ans, sum);\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long double eps = 1e-12;\nconst long long INF = 1000LL * 1000 * 1000 * 1000 * 1000 * 1000 + 1912;\nconst int maxn = 1000000 + 1912;\nint n, a[maxn];\nint x, y;\nvoid ReadData() {\n  cin >> n >> x >> y;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n}\nlong long dp[maxn][3];\nvoid minimize(long long &a, const long long &b) {\n  if (a > b) a = b;\n}\nlong long Solve(int p) {\n  long long res = INF;\n  for (int i = 0; i <= n; i++)\n    for (int j = 0; j < 3; j++) dp[i][j] = INF;\n  dp[0][0] = 0;\n  for (int i = 1; i <= n; i++) {\n    if (a[i] % p == 0) {\n      minimize(dp[i][0], dp[i - 1][0]);\n    }\n    if ((a[i] + 1) % p == 0 || (a[i] - 1) % p == 0) {\n      minimize(dp[i][0], dp[i - 1][0] + y);\n    }\n    minimize(dp[i][1], dp[i - 1][1] + x);\n    minimize(dp[i][1], dp[i - 1][0] + x);\n    if (a[i] % p == 0) {\n      minimize(dp[i][2], dp[i - 1][2]);\n      minimize(dp[i][2], dp[i - 1][1]);\n    }\n    if ((a[i] + 1) % p == 0 || (a[i] - 1) % p == 0) {\n      minimize(dp[i][2], dp[i - 1][2] + y);\n      minimize(dp[i][2], dp[i - 1][1] + y);\n    }\n  }\n  res = min(dp[n][0], min(dp[n][1], dp[n][2]));\n  return res;\n}\nvoid Process() {\n  if (n == 1) {\n    int res = 0;\n    if (a[1] == 1) res = y;\n    cout << res << endl;\n    return;\n  }\n  long long res = 1LL * n * x;\n  for (int k = -1; k <= 1; k++) {\n    int z = a[1] + k;\n    for (int i = 2; i <= sqrt(z); i++) {\n      bool ok = (z % i == 0);\n      while (z % i == 0) {\n        z /= i;\n      }\n      if (ok) res = min(res, Solve(i));\n    }\n    if (z > 1) res = min(res, Solve(z));\n    z = a[n] + k;\n    for (int i = 2; i <= sqrt(z); i++) {\n      bool ok = (z % i == 0);\n      while (z % i == 0) {\n        z /= i;\n      }\n      if (ok) res = min(res, Solve(i));\n    }\n    if (z > 1) res = min(res, Solve(z));\n  }\n  cout << res << endl;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  ReadData();\n  Process();\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\n// AIM Tech Round (Div. 2)\n// Array GCD\npublic class Problem_624_D {\n    \n\n    public static void main(String[] args)\n    {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        PrintWriter out = new PrintWriter(outputStream);\n        Problem_624_D solver = new Problem_624_D();\n        solver.solve(1, new InputStreamReader(inputStream), out);\n        out.close();\n    }\n    \n    ArrayList<Integer> factor(int n)\n    {\n      ArrayList<Integer> factors = new ArrayList<Integer>();\n      int i;\n      for(i = 2; i <= (int)Math.sqrt(n); i++) {\n        while(n % i == 0) {\n          factors.add(i);\n          n /= i;\n        }\n      }\n      if(n > 1)\n        factors.add(n);\n      return factors;\n    }\n\n    public void solve(int test, Reader input, PrintWriter out)\n    {\n        MyScanner in = new MyScanner(input);\n        \n        int n = in.nextInt();\n        int a = in.nextInt();\n        int b = in.nextInt();\n        \n        int[] x = in.nextIntArray(n);\n        \n        TreeSet<Integer> s = new TreeSet<>();\n        \n        ArrayList<Integer> f = factor(x[0]);\n        s.addAll(f);\n        f = factor(x[0] + 1);\n        s.addAll(f);\n        f = factor(x[0] - 1);\n        s.addAll(f);\n        f = factor(x[n-1]);\n        s.addAll(f);\n        f = factor(x[n-1] + 1);\n        s.addAll(f);\n        f = factor(x[n-1] - 1);\n        s.addAll(f);\n        \n        int[] w = new int[s.size()];\n        \n        Iterator<Integer> it = s.iterator();\n        for(int i = 0; i < s.size(); i++) w[i] = it.next();\n        long res = (long)1e18;\n        for(int p : w) {\n            long s1 = 0, s2 = 0, s3 = 0, INF = (long) 1e16;\n            for (int i = 0; i < n; i++){\n                long cost = INF;\n                if (x[i] % p == 0){\n                    cost = 0;\n                } else if ((x[i] - 1) % p == 0 || (x[i] + 1) % p == 0) {\n                    cost = b;\n                }\n                s1 += cost;\n                s2 += a;\n                s3 += cost;\n                s1 = Math.min(s1, INF);\n                s2 = Math.min(s2, s1);\n                s3 = Math.min(s2, s3);\n            }\n            res = Math.min(res, s3);\n        }\n        out.println(res);\n    }\n\n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner(Reader reader) {\n            br = new BufferedReader(reader);\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        \n        int[] nextIntArray(int n)\n        {\n            int[] r = new int[n];\n            for(int i = 0; i < n; i++)\n                r[i] = nextInt();\n            return r;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine(){\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n    }\n    //--------------------------------------------------------\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, -1, 1};\nvoid arquivo() {\n  freopen(\"\", \"r\", stdin);\n  freopen(\"\", \"w\", stdout);\n}\nconst int N = 5000100;\nint n;\nlong long a, b;\nint v[N];\nbool memo[N][3];\nlong long pd[N][3];\nint atPrime;\nlong long func(int pos, int op) {\n  if (pos == n) return 0LL;\n  if (memo[pos][op]) return pd[pos][op];\n  long long ret = 1000000000000000001LL;\n  if (!op) {\n    ret = func(pos + 1, 1) + a;\n    if (v[pos] % atPrime == 0) ret = min(ret, func(pos + 1, 0));\n    if ((v[pos] + 1) % atPrime == 0) ret = min(ret, func(pos + 1, 0) + b);\n    if ((v[pos] - 1) % atPrime == 0) ret = min(ret, func(pos + 1, 0) + b);\n  } else if (op == 1) {\n    ret = func(pos + 1, 1) + a;\n    if (v[pos] % atPrime == 0) ret = min(ret, func(pos + 1, 2));\n    if ((v[pos] + 1) % atPrime == 0) ret = min(ret, func(pos + 1, 2) + b);\n    if ((v[pos] - 1) % atPrime == 0) ret = min(ret, func(pos + 1, 2) + b);\n  } else {\n    if (v[pos] % atPrime == 0) ret = min(ret, func(pos + 1, 2));\n    if ((v[pos] + 1) % atPrime == 0) ret = min(ret, func(pos + 1, 2) + b);\n    if ((v[pos] - 1) % atPrime == 0) ret = min(ret, func(pos + 1, 2) + b);\n  }\n  memo[pos][op] = 1;\n  return pd[pos][op] = ret;\n}\nvoid fatora(long long x, set<int> &all) {\n  for (long long i = 2; i * i <= x; ++i) {\n    if (x % i == 0) {\n      all.insert(i);\n      while (x % i == 0) x /= i;\n    }\n  }\n  if (x > 1) all.insert(x);\n}\nint main() {\n  scanf(\"%d %lld %lld\", &n, &a, &b);\n  set<int> all;\n  long long x;\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", v + i);\n  }\n  for (int i = 0; i < 1; ++i) {\n    x = v[i];\n    fatora(x, all);\n    x = v[i] + 1;\n    fatora(x, all);\n    x = v[i] - 1;\n    fatora(x, all);\n  }\n  for (int i = n - 1; i < n; ++i) {\n    x = v[i];\n    fatora(x, all);\n    x = v[i] + 1;\n    fatora(x, all);\n    x = v[i] - 1;\n    fatora(x, all);\n  }\n  long long ans = (long long)(n - 1LL) * a;\n  for (set<int>::iterator it = all.begin(); it != all.end(); it++) {\n    atPrime = *it;\n    if (atPrime == 1) continue;\n    memset(memo, 0, sizeof memo);\n    for (int j = n - 1; j >= 0; --j) {\n      func(j, 0);\n      func(j, 1);\n      func(j, 2);\n    }\n    ans = min(ans, func(0, 0));\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, b, c;\nint a[1000001];\nvector<int> q;\nlong long dp[1000001][3];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> b >> c;\n  for (int i = 1; i <= n; ++i) cin >> a[i];\n  int x = a[1];\n  for (int i = 2; i <= sqrt(x); ++i) {\n    if (x % i != 0) continue;\n    q.push_back(i);\n    while (x % i == 0) x /= i;\n  }\n  if (x > 1) q.push_back(x);\n  x = a[n];\n  for (int i = 2; i <= sqrt(x); ++i) {\n    if (x % i != 0) continue;\n    q.push_back(i);\n    while (x % i == 0) x /= i;\n  }\n  if (x > 1) q.push_back(x);\n  x = a[n] - 1;\n  for (int i = 2; i <= sqrt(x); ++i) {\n    if (x % i != 0) continue;\n    q.push_back(i);\n    while (x % i == 0) x /= i;\n  }\n  if (x > 1) q.push_back(x);\n  x = a[n] + 1;\n  for (int i = 2; i <= sqrt(x); ++i) {\n    if (x % i != 0) continue;\n    q.push_back(i);\n    while (x % i == 0) x /= i;\n  }\n  if (x > 1) q.push_back(x);\n  x = a[1] - 1;\n  for (int i = 2; i <= sqrt(x); ++i) {\n    if (x % i != 0) continue;\n    q.push_back(i);\n    while (x % i == 0) x /= i;\n  }\n  if (x > 1) q.push_back(x);\n  x = a[1] + 1;\n  for (int i = 2; i <= sqrt(x); ++i) {\n    if (x % i != 0) continue;\n    q.push_back(i);\n    while (x % i == 0) x /= i;\n  }\n  if (x > 1) q.push_back(x);\n  long long ans = 1e18;\n  for (int i = 0; i < q.size(); ++i) {\n    int x = q[i];\n    for (int i = 1; i <= n; ++i) {\n      dp[i][0] = 1e18;\n      dp[i][1] = 1e18;\n      dp[i][2] = 1e18;\n      if (a[i] % x == 0) dp[i][0] = dp[i - 1][0];\n      if ((a[i] + 1) % x == 0 && dp[i - 1][0] != 1e18)\n        dp[i][0] = min(dp[i][0], dp[i - 1][0] + c);\n      if ((a[i] - 1) % x == 0 && dp[i - 1][0] != 1e18)\n        dp[i][0] = min(dp[i][0], dp[i - 1][0] + c);\n      if (dp[i - 1][0] != 1e18) dp[i][1] = dp[i - 1][0] + b;\n      dp[i][1] = min(dp[i][1], dp[i - 1][1] + b);\n      if (a[i] % x == 0) dp[i][2] = dp[i - 1][2];\n      if ((a[i] + 1) % x == 0) dp[i][2] = min(dp[i][2], dp[i - 1][2] + c);\n      if ((a[i] - 1) % x == 0) dp[i][2] = min(dp[i][2], dp[i - 1][2] + c);\n      dp[i][2] = min(dp[i][2], dp[i][1]);\n    }\n    ans = min(ans, dp[n][0]);\n    ans = min(ans, dp[n][1]);\n    ans = min(ans, dp[n][2]);\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e6 + 5;\nint n, x, y;\nvector<int> a;\nlong long f[maxn][3];\nlong long Cost(int num, int gcd, int del) {\n  if (del) return x;\n  num %= gcd;\n  if (num == 0) return 0;\n  if (num == 1 || num == gcd - 1) return y;\n  return 1e15;\n}\nlong long Calc(int gcd) {\n  f[n][0] = f[n][1] = f[n][2] = 0;\n  for (int i = n - 1; i >= 0; --i) {\n    long long c0 = Cost(a[i], gcd, 0);\n    long long c1 = Cost(a[i], gcd, 1);\n    f[i][0] = min(f[i + 1][0] + c0, f[i + 1][1] + c1);\n    f[i][1] = min(f[i + 1][1] + c1, f[i + 1][2] + c0);\n    f[i][2] = f[i + 1][2] + c0;\n    if (f[i][0] > 1e17) f[i][0] = 1e17;\n    if (f[i][1] > 1e17) f[i][1] = 1e17;\n    if (f[i][2] > 1e17) f[i][2] = 1e17;\n  }\n  return f[0][0];\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> x >> y;\n  a.resize(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n  }\n  vector<int> candidate;\n  for (int x = -1; x <= 1; ++x) {\n    candidate.push_back(a[0] + x);\n    candidate.push_back(a.back() + x);\n  }\n  long long res = 1ll * n * x;\n  for (int gcd = 2; gcd * gcd <= 1e9; ++gcd) {\n    bool ok = false;\n    for (int &x : candidate)\n      while (x % gcd == 0) x /= gcd, ok = 1;\n    if (ok) res = min(res, Calc(gcd));\n  }\n  for (int gcd : candidate)\n    if (gcd != 1) res = min(res, Calc(gcd));\n  cout << res;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 5;\nint c[N];\nlong long a, b;\nvector<int> d;\nvoid div(int n) {\n  for (int i = 2; i * i <= n; i++) {\n    if (n % i == 0) {\n      d.push_back(i);\n      while (n % i == 0) n /= i;\n    }\n  }\n  if (n > 1) d.push_back(n);\n}\nvoid f(int n) {\n  div(n);\n  div(n - 1);\n  div(n + 1);\n}\nlong long L[N], R[N];\nconst long long inf = 1LL << 60;\nlong long ans = 1LL << 60;\nlong long sol(int fac, int n) {\n  long long ans = inf;\n  L[0] = 0;\n  for (int i = 1; i <= n; i++) {\n    L[i] = inf;\n    if (c[i] % fac == 0)\n      L[i] = L[i - 1];\n    else if ((c[i] - 1) % fac == 0 || (c[i] + 1) % fac == 0)\n      L[i] = L[i - 1] + b;\n    ans = min(ans, L[i] + (n - i) * a);\n  }\n  R[n + 1] = 0;\n  for (int i = n; i >= 1; i--) {\n    R[i] = inf;\n    if (c[i] % fac == 0)\n      R[i] = R[i + 1];\n    else if ((c[i] - 1) % fac == 0 || (c[i] + 1) % fac == 0)\n      R[i] = R[i + 1] + b;\n  }\n  for (int i = 1; i <= n; i++) L[i] -= i * a;\n  for (int i = 1; i <= n; i++) R[i] += (i - 1) * a;\n  long long mn = 0;\n  for (int i = 1; i <= n; i++) {\n    ans = min(ans, R[i] + mn);\n    mn = min(mn, L[i]);\n  }\n  return ans;\n}\nint main() {\n  int n;\n  scanf(\"%d%d%d\", &n, &a, &b);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", c + i);\n  f(c[1]);\n  f(c[n]);\n  sort(d.begin(), d.end());\n  d.erase(unique(d.begin(), d.end()), d.end());\n  for (int i = 0; i < d.size(); i++) ans = min(ans, sol(d[i], n));\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1000005;\nint n, A, B, a[maxn];\nlong long dp[maxn][3];\nlong long solve(int x, int y) {\n  if (x == 1) return LLONG_MAX;\n  vector<int> facs;\n  for (int i = 2; i * i <= x; ++i) {\n    if (x % i == 0) {\n      facs.push_back(i);\n      while (x % i == 0) x /= i;\n    }\n  }\n  if (x > 1) facs.push_back(x);\n  long long ans = LLONG_MAX;\n  for (int j = 0; j < facs.size(); ++j) {\n    memset(dp, 0x3f, sizeof(dp));\n    dp[1][0] = y;\n    for (int i = 2; i <= n; ++i) {\n      if ((a[i] - 1) % facs[j] == 0) {\n        dp[i][0] = min(dp[i][0], dp[i - 1][0] + B);\n        dp[i][2] = min(dp[i][2], min(dp[i - 1][1], dp[i - 1][2]) + B);\n      }\n      if ((a[i] + 1) % facs[j] == 0) {\n        dp[i][0] = min(dp[i][0], dp[i - 1][0] + B);\n        dp[i][2] = min(dp[i][2], min(dp[i - 1][1], dp[i - 1][2]) + B);\n      }\n      if (a[i] % facs[j] == 0) {\n        dp[i][0] = min(dp[i][0], dp[i - 1][0]);\n        dp[i][2] = min(dp[i][2], min(dp[i - 1][1], dp[i - 1][2]));\n      }\n      dp[i][1] = min(dp[i][1], min(dp[i - 1][0], dp[i - 1][1]) + A);\n    }\n    ans = min(ans, dp[n][0]);\n    ans = min(ans, dp[n][1]);\n    ans = min(ans, dp[n][2]);\n  }\n  return ans;\n}\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  scanf(\"%d%d%d\", &n, &A, &B);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d\", &a[i]);\n  }\n  long long ans = LLONG_MAX;\n  ans = min(ans, solve(a[1] - 1, B));\n  ans = min(ans, solve(a[1], 0));\n  ans = min(ans, solve(a[1] + 1, B));\n  reverse(a + 1, a + 1 + n);\n  ans = min(ans, solve(a[1] - 1, B));\n  ans = min(ans, solve(a[1], 0));\n  ans = min(ans, solve(a[1] + 1, B));\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nlong long a, b;\nvector<long long> v, p;\nvector<vector<long long> > dp;\nvoid fill_p();\nlong long solve(long long x);\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin >> n >> a >> b;\n  v.resize(n);\n  for (int i = 0; i < n; ++i) cin >> v[i];\n  fill_p();\n  long long res = (long long)1e18;\n  for (int i = 0; i < p.size(); ++i) res = min(res, solve(p[i]));\n  cout << res << endl;\n  return 0;\n}\nlong long solve(long long x) {\n  dp.assign(n + 1, vector<long long>(3, (long long)1e18));\n  dp[0][0] = dp[0][1] = dp[0][2] = 0;\n  for (int i = 0; i < n; ++i) {\n    dp[i + 1][1] = min(dp[i][0], dp[i][1]) + a;\n    if (v[i] % x == 0) {\n      dp[i + 1][0] = dp[i][0];\n      dp[i + 1][2] = min(dp[i][1], dp[i][2]);\n    } else if ((v[i] % x == 1) || (v[i] % x == x - 1)) {\n      dp[i + 1][0] = dp[i][0] + b;\n      dp[i + 1][2] = min(dp[i][1], dp[i][2]) + b;\n    }\n  }\n  long long res = (long long)1e18;\n  for (int j = 0; j < 3; ++j) res = min(res, dp[n][j]);\n  return res;\n}\nvoid fill_p() {\n  vector<long long> w;\n  w.push_back(v[0]);\n  w.push_back(v[0] + 1);\n  w.push_back(v[0] - 1);\n  w.push_back(v[n - 1]);\n  w.push_back(v[n - 1] + 1);\n  w.push_back(v[n - 1] - 1);\n  set<long long> S;\n  for (int i = 0; i < w.size(); ++i) {\n    long long x = w[i];\n    for (long long j = 2; j * j <= x; ++j) {\n      if (x % j == 0) {\n        S.insert(j);\n        while (x % j == 0) x /= j;\n      }\n    }\n    if (x > 1) S.insert(x);\n  }\n  for (set<long long>::iterator it = S.begin(); it != S.end(); ++it)\n    p.push_back(*it);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\nusing namespace std;\nbool is_prime(long long n) {\n  for (long long i = 2; i * i <= n; ++i) {\n    if (n % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\nvector<long long> fact(long long n) {\n  vector<long long> ans;\n  for (int i = 2; i * i <= n; i++) {\n    if (n % i == 0) {\n      ans.push_back(i);\n      while (n % i == 0) {\n        n /= i;\n      }\n    }\n  }\n  if (n > 1) ans.push_back(n);\n  return ans;\n}\nlong long getPow(long long a, long long b) {\n  long long res = 1ll, tp = a;\n  while (b) {\n    if (b & 1ll) {\n      res *= tp;\n    }\n    tp *= tp;\n    b >>= 1ll;\n  }\n  return res;\n}\nlong long vec_mult(long long x1, long long y1, long long x2, long long y2,\n                   long long x3, long long y3) {\n  return abs((x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1));\n}\nvoid ok() {\n  cout << \"YES\" << endl;\n  exit(0);\n}\nvoid no() {\n  cout << \"NO\" << endl;\n  exit(0);\n}\ninline long long nxt() {\n  long long x;\n  cin >> x;\n  return x;\n}\nconst long long N = 3e3 + 10, inf = 2e16;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0), cout.tie(0);\n  long long n = nxt(), a = nxt(), b = nxt();\n  vector<long long> mas(n + 1);\n  for (int i = 1; i <= n; i++) {\n    mas[i] = nxt();\n  }\n  vector<long long> arr = {mas[1], mas[1] + 1, mas[1] - 1,\n                           mas[n], mas[n] - 1, mas[n] + 1};\n  vector<long long> factors;\n  for (auto t : arr) {\n    vector<long long> cur = fact(t);\n    for (auto x : cur) {\n      factors.push_back(x);\n    }\n  }\n  sort((factors).begin(), (factors).end());\n  (factors).resize(unique((factors).begin(), (factors).end()) -\n                   (factors).begin());\n  long long ans = inf;\n  vector<vector<long long>> dp(n + 1, vector<long long>(3));\n  for (int j = 0; j < 3; j++) {\n    dp[0][j] = 0;\n  }\n  for (int i = 0; i < factors.size(); i++) {\n    long long p = factors[i];\n    for (int j = 1; j <= n; j++) {\n      long long type;\n      if (mas[j] % p == 0)\n        type = 0;\n      else if ((mas[j] - 1) % p == 0 || (mas[j] + 1) % p == 0)\n        type = 1;\n      else\n        type = 2;\n      if (type == 0) {\n        dp[j][0] = dp[j - 1][0];\n        dp[j][1] = min(dp[j - 1][0], dp[j - 1][1]) + a;\n        dp[j][2] = min(dp[j - 1][1], dp[j - 1][2]);\n      }\n      if (type == 1) {\n        dp[j][0] = dp[j - 1][0] + b;\n        dp[j][1] = min(dp[j - 1][0], dp[j - 1][1]) + a;\n        dp[j][2] = min(dp[j - 1][1], dp[j - 1][2]) + b;\n      }\n      if (type == 2) {\n        for (int t = 0; t < 3; t++) {\n          dp[j][t] = inf;\n        }\n        dp[j][1] = min(dp[j - 1][1], dp[j - 1][0]) + a;\n      }\n    }\n    for (auto x : dp[n]) {\n      ans = min(ans, x);\n    }\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1e18;\nconst int P_MAX = 100000;\nbool P[P_MAX];\nint N, A, B;\nvector<int> V;\nlong long dp[1000010][3];\nlong long solve(int d) {\n  for (int i = 0; i <= N; i++) {\n    for (int j = 0; j < 3; j++) {\n      dp[i][j] = INF;\n    }\n  }\n  dp[0][0] = 0;\n  for (int i = 0; i < N; i++) {\n    dp[i + 1][1] = min(dp[i + 1][1], dp[i][0] + A);\n    dp[i + 1][1] = min(dp[i + 1][1], dp[i][1] + A);\n    if (V[i] % d == 0) {\n      dp[i + 1][0] = min(dp[i + 1][0], dp[i][0]);\n      dp[i + 1][2] = min(dp[i + 1][2], dp[i][1]);\n      dp[i + 1][2] = min(dp[i + 1][2], dp[i][2]);\n    } else if ((V[i] + 1) % d == 0 || (V[i] - 1) % d == 0) {\n      dp[i + 1][0] = min(dp[i + 1][0], dp[i][0] + B);\n      dp[i + 1][2] = min(dp[i + 1][2], dp[i][1] + B);\n      dp[i + 1][2] = min(dp[i + 1][2], dp[i][2] + B);\n    }\n  }\n  return min(dp[N][0], min(dp[N][1], dp[N][2]));\n}\nint main() {\n  for (int p = 2; p < P_MAX; p++) {\n    P[p] = true;\n  }\n  for (int p = 2; p < P_MAX; p++) {\n    if (!P[p]) continue;\n    for (int i = p + p; i < P_MAX; i += p) {\n      P[i] = false;\n    }\n  }\n  cin >> N >> A >> B;\n  for (int i = 0; i < N; i++) {\n    int t;\n    cin >> t;\n    V.push_back(t);\n  }\n  long long ans = INF;\n  int cands[] = {V[0],     V[0] + 1,     V[0] - 1,\n                 V[N - 1], V[N - 1] + 1, V[N - 1] - 1};\n  for (int i = 0; i < 6; i++) {\n    int cand = cands[i];\n    for (int p = 2; p < P_MAX; p++) {\n      if (!P[p]) continue;\n      if (cand % p != 0) continue;\n      while (cand % p == 0) cand /= p;\n      ans = min(ans, solve(p));\n    }\n    if (cand != 1) ans = min(ans, solve(cand));\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nistream* pin;\nintmax_t tmin = std::numeric_limits<intmax_t>::min();\nintmax_t tmax = std::numeric_limits<intmax_t>::max();\nintmax_t konstansmod = (1e9) + 7;\ntemplate <typename T>\nvector<T> read(int num = -1, int szorzo = 1, istream& in = *pin) {\n  vector<T> container;\n  if (num == -1) in >> num;\n  num *= szorzo;\n  for (int i = 0; i < num; i++) {\n    T q;\n    in >> q;\n    container.push_back(q);\n  }\n  return container;\n}\nstruct printer {\n  ostream* o;\n  printer(ostream& a = cout) : o(&a) {}\n  void pr() { *o << \"\\n\"; }\n  template <typename T>\n  void pr(T intmax_t) {\n    *o << std::setprecision(9) << intmax_t << \"\\n\";\n  }\n  template <typename T>\n  void pr(vector<T> intmax_t) {\n    for (T w : intmax_t) pr(w);\n    pr();\n  }\n  template <typename T, typename... Args>\n  void pr(T value, Args... args) {\n    pr(value);\n    pr(args...);\n  }\n};\ntemplate <typename H1>\nvoid show(std::ostream& out, const char* label, H1&& value) {\n  out << label << \"=\";\n  printer(out).pr(value);\n}\ntemplate <typename H1, typename... T>\nvoid show(std::ostream& out, const char* label, H1&& value, T&&... rest) {\n  const char* pcomma = strchr(label, ',');\n  out.write(label, pcomma - label) << \"=\";\n  printer(out).pr(value);\n  show(out, pcomma + 1, std::forward<T>(rest)...);\n}\nvoid print(bool b) { cout << (b ? \"Yes\" : \"No\") << \"\\n\"; }\nvoid solve();\nint main(int argc, char** argv) {\n  srand((unsigned)time(NULL));\n  ifstream* argfile = NULL;\n  string filename = \"\";\n  if (argc >= 2 && filename.length() == 0) filename = argv[1];\n  if (filename.length() > 0) {\n    argfile = new ifstream(filename);\n    if (!argfile->is_open()) {\n      cerr << \"file cant be opened,exiting. Filename:\" << filename << \"\\n\";\n      cerr << \"Error: \" << strerror(errno) << \"\\n\";\n      return 1;\n    }\n  }\n  if (argfile) std::cin.rdbuf(argfile->rdbuf());\n  istream& myfile = argfile ? *argfile : cin;\n  pin = &myfile;\n  int num;\n  solve();\n  return 0;\n  myfile >> num;\n  for (int i = 0; i < num; i++) {\n    cout << \"Case #\" << (i + 1) << \": \";\n    solve();\n  }\n  return 0;\n}\nvector<intmax_t> decompose(intmax_t n) {\n  vector<intmax_t> ret;\n  intmax_t i(2);\n  while (n % i == intmax_t(0)) {\n    ret.push_back(i);\n    n /= i;\n  }\n  ++i;\n  while (n != 1) {\n    while (n % i == intmax_t(0)) {\n      ret.push_back(i);\n      n /= i;\n    }\n    i += 2;\n  }\n  return ret;\n}\nvoid solve() {\n  intmax_t rret = tmax;\n  intmax_t n, a, b;\n  cin >> n >> a >> b;\n  vector<intmax_t> nums;\n  nums.reserve(1000002);\n  nums.push_back(0);\n  for (int i = 0; i < n; i++) {\n    intmax_t e;\n    cin >> e;\n    nums.push_back(e);\n  }\n  unordered_set<intmax_t> tt;\n  for (int z = 1; z <= n; z += max((int)n - 1, (int(1))))\n    for (int j2 = nums[z] - 1; j2 < nums[z] + 2; j2++) {\n      intmax_t j = j2;\n      for (intmax_t i2 = 2; i2 * i2 <= j; ++i2) {\n        if (j % i2 == 0) {\n          tt.insert(i2);\n          if (i2 * i2 != j) tt.insert(j / i2);\n          while (j % i2 == 0) j /= i2;\n        }\n        if (j == 1) break;\n      }\n      if (j > 1) tt.insert(j);\n    }\n  for (intmax_t fact : tt) {\n    intmax_t ret = tmax;\n    int pontnum = 0;\n    intmax_t megtakar = 0;\n    intmax_t aktmegtak = 0;\n    intmax_t ba = b - a;\n    bool elsorosszpontos = false;\n    bool rosszpontos = false;\n    for (intmax_t j = 1; j < nums.size(); j++) {\n      elsorosszpontos = false;\n      intmax_t modi = nums[j] % fact;\n      if (modi == 0) {\n        aktmegtak -= a;\n        if (!rosszpontos) aktmegtak = max(aktmegtak, (intmax_t)0);\n      } else {\n        pontnum++;\n        if (modi != 1 && modi != fact - 1) {\n          megtakar = tmin;\n          if (!rosszpontos) elsorosszpontos = true;\n          rosszpontos = true;\n        }\n        intmax_t newtakar = aktmegtak + (ba);\n        aktmegtak = newtakar;\n        megtakar = max(megtakar, newtakar);\n        if (newtakar < (ba) && (!rosszpontos || elsorosszpontos)) {\n          aktmegtak = ba;\n          megtakar = max(megtakar, newtakar);\n        }\n      }\n    }\n    show(std::cerr,\n         \"pontnum, megtakar, fact, pontnum * b - megtakar, aktmegtak\", pontnum,\n         megtakar, fact, pontnum * b - megtakar, aktmegtak);\n    ret = pontnum * b - megtakar;\n    rret = min(ret, rret);\n  }\n  printer().pr(rret);\n  ;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 5;\nint a[N];\nvector<int> pp;\nlong long n, A, B;\nvoid prime(int first) {\n  int i;\n  for (i = 2; i <= sqrt(first); ++i)\n    if (first % i == 0) {\n      while (first % i == 0) first /= i;\n      pp.push_back(i);\n    }\n  if (first > 1) pp.push_back(first);\n}\nlong long get(int r) {\n  int i;\n  long long T = n * A, K = 0;\n  priority_queue<pair<long long, int> > q;\n  for (i = n; i >= 1; --i) {\n    T -= A;\n    if (a[i] % r != 0) {\n      if (((a[i] + 1) % r == 0 || (a[i] - 1) % r == 0))\n        K += B;\n      else\n        break;\n    }\n    q.push(make_pair(-(T + K), i));\n  }\n  long long ret = 8e18;\n  if (!q.empty()) ret = -q.top().first;\n  K = 0, T = 0;\n  for (i = 1; i < n; ++i) {\n    if (a[i] % r != 0) {\n      if (((a[i] + 1) % r == 0 || (a[i] - 1) % r == 0))\n        K += B;\n      else\n        break;\n    }\n    T += A;\n    while (!q.empty()) {\n      if (q.top().second > i) break;\n      q.pop();\n    }\n    ret = min(ret, K + A * (n - i));\n    if (!q.empty()) ret = min(ret, K - q.top().first - T);\n  }\n  return ret;\n}\nint main() {\n  int i, j, k;\n  cin >> n >> A >> B;\n  for (i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n  for (i = -1; i <= 1; ++i) prime(a[1] + i), prime(a[n] + i);\n  sort(pp.begin(), pp.end());\n  vector<int>::iterator it = unique(pp.begin(), pp.end());\n  pp.resize(distance(pp.begin(), it));\n  long long ret = 8e18;\n  for (i = 0; i < pp.size(); ++i) ret = min(ret, get(pp[i]));\n  cout << ret << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1000000 + 1000;\nint n, x, y;\nint a[maxn];\nvector<int> prime;\nbool l1[maxn], r1[maxn];\nint l2[maxn], r2[maxn];\nconst long long inf = (long long)1e18;\nvoid factor(int x) {\n  int v = x;\n  for (int i = 2; 1ll * i * i <= x; i++)\n    if (v % i == 0) {\n      prime.push_back(i);\n      while (v % i == 0) v /= i;\n    }\n  if (v > 1) prime.push_back(v);\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &x, &y);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  prime.clear();\n  factor(a[1]);\n  factor(a[1] - 1);\n  factor(a[1] + 1);\n  factor(a[n]);\n  factor(a[n] + 1);\n  factor(a[n] - 1);\n  sort(prime.begin(), prime.end());\n  long long ans = inf;\n  for (int t = 0; t < (int)prime.size(); t++)\n    if (t == 0 || prime[t] != prime[t - 1]) {\n      int g = prime[t];\n      l1[0] = 1;\n      l2[0] = 0;\n      for (int i = 1; i <= n; i++) {\n        l1[i] =\n            l1[i - 1] && (a[i] % g == 0 || a[i] % g == g - 1 || a[i] % g == 1);\n        l2[i] = l2[i - 1] + (a[i] % g == 0 ? 0 : 1);\n      }\n      r1[n + 1] = 1;\n      r2[n + 1] = 0;\n      for (int i = n; i > 0; i--) {\n        r1[i] =\n            r1[i + 1] && (a[i] % g == 0 || a[i] % g == g - 1 || a[i] % g == 1);\n        r2[i] = r2[i + 1] + (a[i] % g == 0 ? 0 : 1);\n      }\n      long long cur = inf;\n      if (l1[n]) cur = min(cur, 1ll * l2[n] * y);\n      long long lft = inf;\n      for (int j = 1; j <= n; j++) {\n        if (j >= 2 && l1[j - 1])\n          lft = min(lft, 1ll * l2[j - 1] * y - 1ll * x * j);\n        if (r1[j + 1])\n          cur = min(cur, lft + 1ll * (j + 1) * x + 1ll * r2[j + 1] * y);\n      }\n      for (int j = 1; j < n; j++) {\n        if (r1[j + 1]) cur = min(cur, 1ll * r2[j + 1] * y + 1ll * j * x);\n      }\n      ans = min(ans, cur);\n    }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 1000001;\nconst long long INF = ~0ull >> 2;\nint mpf[N], p[N], pn;\nint n, a, b;\nint c[N];\nlong long ans = INF;\nlong long dp0[N], dp1[N], dp2[N];\ninline void update(long long &a, long long b) {\n  if (a > b) {\n    a = b;\n  }\n}\nvoid test(int d, int c[], int e) {\n  for (int i = 1; i < n; i++) {\n    dp0[i] = dp1[i] = dp2[i] = INF;\n    int t = c[i] % d;\n    if (t == 0) {\n      update(dp0[i], dp0[i - 1]);\n      update(dp2[i], dp2[i - 1]);\n    } else if (t == 1 || t == d - 1) {\n      update(dp0[i], dp0[i - 1] + b);\n      update(dp2[i], dp2[i - 1] + b);\n    }\n    update(dp1[i], dp1[i - 1] + a);\n    update(dp1[i], dp0[i]);\n    update(dp2[i], dp1[i]);\n  }\n  update(ans, e + dp2[n - 1]);\n}\nvoid cal(int x, int c[], int e) {\n  for (int i = 0; i < pn; i++) {\n    while (x % p[i] == 0) {\n      test(p[i], c, e);\n      x /= p[i];\n    }\n  }\n  if (x != 1) {\n    test(x, c, e);\n  }\n}\nint main() {\n  for (int i = 2; i < N; i++) {\n    if (mpf[i] == 0) {\n      mpf[i] = p[pn++] = i;\n    } else {\n      for (int j = 0; j < pn && i * p[j] < N && p[j] < mpf[i]; j++) {\n        mpf[i * p[j]] = p[j];\n      }\n    }\n  }\n  scanf(\"%d%d%d\", &n, &a, &b);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &c[i]);\n  }\n  cal(c[1], c + 1, 0);\n  cal(c[1] + 1, c + 1, b);\n  cal(c[1] - 1, c + 1, b);\n  cal(c[n], c, 0);\n  cal(c[n] + 1, c, b);\n  cal(c[n] - 1, c, b);\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long segs[] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};\nlong long n, a, b, val[1000005], dp[1000005][3];\nbool primes[1000005];\nvector<long long> pms;\nbool reachable[1000005][3];\nset<long long> check;\nvoid sieve() {\n  primes[0] = primes[1] = false;\n  pms.push_back(2);\n  for (long long i = 4; i < 1000005; i += 2) {\n    primes[i] = false;\n  }\n  for (long long i = 3; i < 1000005; i += 2) {\n    if (primes[i]) {\n      pms.push_back(i);\n      for (long long j = 2 * i; j < 1000005; j += i) {\n        primes[j] = false;\n      }\n    }\n  }\n}\nvoid getPrimes(long long x) {\n  long long ox = x;\n  for (long long i = 0; x && pms[i] <= (long long)(sqrt(ox) + 10); i++) {\n    while (x && x % pms[i] == 0) {\n      check.insert(pms[i]);\n      x /= pms[i];\n    }\n  }\n  if (x > 1) check.insert(x);\n}\nint main() {\n  memset(primes, true, sizeof(primes));\n  std::ios::sync_with_stdio(false);\n  sieve();\n  cin >> n >> a >> b;\n  for (int i = 0; i < n; i++) {\n    cin >> val[i];\n  }\n  for (int i = -1; i <= 1; i++) {\n    getPrimes(val[0] + i);\n    getPrimes(val[n - 1] + i);\n  }\n  long long res = 10e16;\n  for (long long p : check) {\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < 3; j++) {\n        dp[i][j] = 0;\n      }\n    }\n    memset(reachable, false, sizeof(reachable));\n    for (int i = 0; i < n; i++) {\n      if (val[i] % p && val[i] > 1) {\n        if (i == 0) {\n          if ((val[i] + 1) % p == 0 || (val[i] - 1) % p == 0) {\n            reachable[0][0] = reachable[0][2] = true;\n            dp[i][0] = b;\n            dp[i][2] = b;\n          }\n          dp[i][1] = a;\n          reachable[0][1] = true;\n        } else {\n          reachable[i][1] = true;\n          dp[i][1] = dp[i - 1][1] + a;\n          if ((val[i] + 1) % p == 0 || (val[i] - 1) % p == 0) {\n            if (reachable[i - 1][0]) {\n              dp[i][0] = dp[i - 1][0] + b;\n              reachable[i][0] = true;\n              dp[i][1] = min(dp[i][1], dp[i - 1][0] + a);\n            }\n            dp[i][2] = dp[i - 1][1] + b;\n            reachable[i][2] = true;\n            if (reachable[i - 1][2]) {\n              dp[i][2] = min(dp[i][2], dp[i - 1][2] + b);\n              reachable[i][2] = true;\n            }\n          }\n        }\n      } else {\n        if (!i) {\n          dp[0][0] = dp[0][2] = 0;\n          dp[0][1] = a;\n          reachable[0][0] = reachable[0][1] = reachable[0][2] = true;\n          continue;\n        }\n        dp[i][1] = dp[i - 1][1] + a;\n        dp[i][2] = dp[i - 1][1];\n        reachable[i][1] = true;\n        reachable[i][2] = true;\n        if (reachable[i - 1][0]) {\n          reachable[i][0] = true;\n          dp[i][0] = dp[i - 1][0];\n          dp[i][1] = min(dp[i][1], dp[i - 1][0]);\n        }\n        if (reachable[i - 1][2]) {\n          dp[i][2] = min(dp[i][2], dp[i - 1][2]);\n        }\n      }\n    }\n    for (int i = 0; i < 3; i++) {\n      if (reachable[n - 1][i]) res = min(res, dp[n - 1][i]);\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class CF_624D implements Runnable {\n\tpublic static int[] arr;\n\tpublic static long a, b;\n\n\tpublic static void main(String[] args) {\n\t\t//new Thread(null, new CF_624D(), \"Solver\"/*, 1L << 288*/).start();\n\t\tnew CF_624D().run();\n\t}\n\n\tpublic static long[][] memo;\n\t@Override\n\tpublic void run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\ta = scan.nextInt();\n\t\tb = scan.nextInt();\n\t\tarr = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarr[i] = scan.nextInt();//(int)(Math.random() * 1000000000)+2;//scan.nextInt();\n\t\t}\n\t\tArrayList<Integer> factorList = new ArrayList<>();\n\t\tHashSet<Integer> factorSet = new HashSet<>();\n\n\t\tint size = Math.max(arr[0] + 1, arr[arr.length - 1] + 1);\n\t\tArrayList<Integer> candidates = new ArrayList<>(6);\n\t\tfor (int dv = -1; dv <= 1; dv++) {\n\t\t\tif (!candidates.contains(arr[0] + dv))\n\t\t\t\tcandidates.add(arr[0] + dv);\n\t\t\tif (!candidates.contains(arr[arr.length - 1] + dv))\n\t\t\t\tcandidates.add(arr[arr.length - 1] + dv);\n\t\t}\n\t\t\n\t\tBitSet sieve = new BitSet((int) Math.ceil(Math.sqrt(size)) + 2);\n\t\tint sieveSize = sieve.size();\n\t\tArrayList<Integer> primes = new ArrayList<>();\n\t\tfor (int i = 2; i < sieveSize; i++) {\n\t\t\tif (sieve.get(i))\n\t\t\t\tcontinue;\n\t\t\tprimes.add(i);\n\t\t\t\n\t\t\t\n\t\t\tfor (long j = i * (long)i; j < sieveSize; j += i) {\n\t\t\t\tsieve.set((int)j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tsieve = null;\n\t\tSystem.gc();\n\t\tfor (int tmp : candidates) {\n\t\t\tint primeIdx = 0;\n\t\t\twhile (tmp > 1) {\n\t\t\t\tif (primeIdx >= primes.size()) {\n\t\t\t\t\tif (!factorSet.contains(tmp)) {\n\t\t\t\t\t\tfactorSet.add(tmp);\n\t\t\t\t\t\tfactorList.add(tmp);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint prime = primes.get(primeIdx);\n\t\t\t\tif (tmp % prime == 0) {\n\t\t\t\t\tif (!factorSet.contains(prime)) {\n\t\t\t\t\t\tfactorSet.add(prime);\n\t\t\t\t\t\tfactorList.add(prime);\n\t\t\t\t\t}\n\t\t\t\t\twhile (tmp % prime == 0) {\n\t\t\t\t\t\ttmp /= prime;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprimeIdx++;\n\t\t\t}\n\t\t}\n\t\tfactorSet = null;\n\t\tprimes = null;\n\t\tSystem.gc();\n\t\t\n\t\tlong minCost = Long.MAX_VALUE;\n\t\tmemo = new long[3][arr.length+1];\n\t\tfor (int factor : factorList) {\n\t\t\t\tfor (long[] mem : memo) {\n\t\t\t\t\tArrays.fill(mem, -1);\n\t\t\t\t\tmem[mem.length-1]= 0;\n\t\t\t\t}\n\t\t\tlong ans;\n\t\t\tlong go;\n\t\t\tfor(int index=arr.length-1;index>=0;index--) {\n\t\t\t\tint mod = arr[index] % factor;\n\t\t\t\tboolean works = mod == 0;\n\t\t\t\tboolean changeWorks = mod == 1 || mod == (factor-1);\n\t\t\t\t\tfor(int removeState = 0;removeState <= 2; removeState++) {\n\t\t\t\t\t\tans = Long.MAX_VALUE;\n\t\t\t\t\t\tswitch (removeState) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tif (works) {\n\t\t\t\t\t\t\t\tans = Math.min(ans,\n\t\t\t\t\t\t\t\t\t\tmemo[removeState][index + 1]);\n\t\t\t\t\t\t\t} else if (changeWorks) {\n\t\t\t\t\t\t\t\tgo = memo[removeState][index + 1];\n\t\t\t\t\t\t\t\tif(go != Long.MAX_VALUE)\n\t\t\t\t\t\t\t\t\tans = Math.min(ans, go + b);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tgo = memo[removeState][index+1];\n\t\t\t\t\t\t\tif(go != Long.MAX_VALUE)\n\t\t\t\t\t\t\t\tans = Math.min(ans, go + a);\n\t\t\t\t\t\t\tif (works) {\n\t\t\t\t\t\t\t\tans = Math.min(ans, memo[0][index+1]);\n\t\t\t\t\t\t\t} else if (changeWorks) {\n\t\t\t\t\t\t\t\tgo = memo[0][index+1];\n\t\t\t\t\t\t\t\tif(go != Long.MAX_VALUE)\n\t\t\t\t\t\t\t\t\tans = Math.min(ans, go + b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tif (works) {\n\t\t\t\t\t\t\t\tans = Math.min(ans,\n\t\t\t\t\t\t\t\t\t\tmemo[removeState][index+1]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlong goa2 = memo[1][index+1];\n\t\t\t\t\t\t\t\tif(goa2 != Long.MAX_VALUE)\n\t\t\t\t\t\t\t\t\tans = Math.min(ans, goa2 + a);\n\t\t\t\t\t\t\t\tif (changeWorks) {\n\t\t\t\t\t\t\t\t\tlong gob = memo[removeState][index+1];\n\t\t\t\t\t\t\t\t\tif(gob != Long.MAX_VALUE)\n\t\t\t\t\t\t\t\t\t\tans = Math.min(ans, gob + b);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//System.out.println(\"memo[\" + changeState + \"][\" + removeState + \"][\"\n\t\t\t\t\t\t//\t\t+ index + \"]=\" + ans);\n\n\t\t\t\t\t\tmemo[removeState][index] = ans;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t//long cost = go(factor, 0, 1, 2);\n\t\t\tlong cost = memo[2][0];\n\t\t\tminCost = Math.min(cost, minCost);\n\t\t}\n\t\tSystem.out.println(minCost);\n\t}\n\n/*\n\tpublic static long go(int factor, int index, int changeState, int removeState) {\n\t\tif (index == arr.length) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (memo[changeState][removeState][index] != -1)\n\t\t\treturn memo[changeState][removeState][index];\n\t\tboolean works = arr[index] % factor == 0;\n\t\tboolean changeWorks = (arr[index] - 1) % factor == 0\n\t\t\t\t|| (arr[index] + 1) % factor == 0;\n\t\t//System.out.println(\"Called on idx \" + index + \" \" + works + \" [\" + changeWorks + \"]\");\n\t\tlong ans = Long.MAX_VALUE;\n\t\tswitch (removeState) {\n\t\tcase 0:\n\t\t\tif (works) {\n\t\t\t\tans = Math.min(ans,\n\t\t\t\t\t\tgo(factor, index + 1, changeState, removeState));\n\t\t\t} else if (changeWorks && changeState != 0) {\n\t\t\t\tlong go = go(factor, index + 1, 0, removeState);\n\t\t\t\tif(go != Long.MAX_VALUE)\n\t\t\t\t\tans = Math.min(ans, go + b);\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tlong goa = go(factor, index + 1, changeState, removeState);\n\t\t\tif(goa != Long.MAX_VALUE)\n\t\t\t\tans = Math.min(ans, goa\t+ a);\n\t\t\tif (works) {\n\t\t\t\tans = Math.min(ans, go(factor, index + 1, changeState, 0));\n\t\t\t} else if (changeWorks && changeState != 0) {\n\t\t\t\tlong gob = go(factor, index + 1, 0, 0);\n\t\t\t\tif(gob != Long.MAX_VALUE)\n\t\t\t\t\tans = Math.min(ans, gob + b);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (works) {\n\t\t\t\tans = Math.min(ans,\n\t\t\t\t\t\tgo(factor, index + 1, changeState, removeState));\n\t\t\t} else {\n\t\t\t\tlong goa2 = go(factor, index + 1, changeState, 1);\n\t\t\t\tif(goa2 != Long.MAX_VALUE)\n\t\t\t\t\tans = Math.min(ans, goa2 + a);\n\t\t\t\tif (changeWorks && removeState != 0) {\n\t\t\t\t\tlong gob = go(factor, index + 1, 0, removeState);\n\t\t\t\t\tif(gob != Long.MAX_VALUE)\n\t\t\t\t\t\tans = Math.min(ans, gob + b);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t//System.out.println(\"memo[\" + changeState + \"][\" + removeState + \"][\"\n\t\t//\t\t+ index + \"]=\" + ans);\n\n\t\treturn memo[changeState][removeState][index] = ans;\n\t}*/\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing std::abs;\nusing std::bitset;\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::deque;\nusing std::map;\nusing std::max;\nusing std::min;\nusing std::pair;\nusing std::queue;\nusing std::set;\nusing std::sort;\nusing std::string;\nusing std::swap;\nusing std::unordered_map;\nusing std::unordered_set;\nusing std::vector;\nvoid init() {\n  std::iostream::sync_with_stdio(0);\n  cout << std::fixed;\n  cout.precision(10);\n  cerr << std::fixed;\n  cerr.precision(10);\n  srand(time(0));\n}\nconst int MAXN = 1e6 + 1;\nlong long arr[MAXN];\nlong long dp[MAXN][3];\nint n;\nlong long a, b;\nconst long long INF = 1e18;\nvector<int> fact(int x) {\n  vector<int> res;\n  int k = x;\n  for (int i = 2; i * i <= k; ++i)\n    if (!(x % i)) {\n      x /= i;\n      res.push_back(i);\n    }\n  if (x > 1) res.push_back(x);\n  return res;\n}\nlong long solve(int p) {\n  for (int i = 0; i <= n; ++i)\n    for (int j = 0; j < 3; ++j) dp[i][j] = INF;\n  for (int i = 0; i < 3; ++i) dp[0][i] = 0;\n  for (int i = 1; i <= n; ++i) {\n    dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + a;\n    if (arr[i] % p == 0) {\n      dp[i][0] = dp[i - 1][0];\n      dp[i][2] = min(dp[i - 1][2], dp[i - 1][1]);\n    } else if ((arr[i] + 1) % p == 0 || (arr[i] - 1) % p == 0) {\n      dp[i][0] = dp[i - 1][0] + b;\n      dp[i][2] = min(dp[i - 1][2], dp[i - 1][1]) + b;\n    }\n  }\n  long long ans = INF;\n  for (int i = 0; i < 3; ++i) ans = min(ans, dp[n][i]);\n  return ans;\n}\nint main() {\n  init();\n  cin >> n >> a >> b;\n  for (int i = 1; i <= n; ++i) cin >> arr[i];\n  set<int> ma;\n  for (int i = -1; i <= 1; ++i) {\n    vector<int> tmp;\n    tmp = fact(arr[1] + i);\n    for (auto j : tmp) ma.insert(j);\n    tmp = fact(arr[n] + i);\n    for (auto j : tmp) ma.insert(j);\n  }\n  long long ans = INF;\n  for (auto i : ma) ans = min(ans, solve(i));\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, a, b, st, ed, ara[1000010], na[1000010], len, t[10], pr;\nset<int> s;\nset<int>::iterator it;\nunsigned long long dp[1000010][5][2];\nbool vis[1000010][5][2];\nunsigned long long solve(int pos, int st, int fe) {\n  if (pos > len) {\n    if (fe && st == 1) return LLONG_MAX;\n    return 0;\n  }\n  if (vis[pos][st][fe]) return dp[pos][st][fe];\n  unsigned long long op = LLONG_MAX;\n  if (na[pos] % pr == 0) {\n    if (st == 0 || st == 2)\n      op = solve(pos + 1, st, fe);\n    else\n      op = min(a + solve(pos + 1, 1, fe || (pos == 1)), solve(pos + 1, 2, fe));\n  } else {\n    if (((ara[pos] - 1) % pr == 0) || ((ara[pos] + 1) % pr == 0)) {\n      if (st == 0 || st == 2)\n        op = b + solve(pos + 1, st, fe);\n      else\n        op = b + solve(pos + 1, 2, fe);\n    }\n    if (st != 2) op = min(op, a + solve(pos + 1, 1, fe || (pos == 1)));\n  }\n  vis[pos][st][fe] = 1;\n  return dp[pos][st][fe] = op;\n}\nint main() {\n  scanf(\"%d %d %d\", &n, &a, &b);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &ara[i]);\n  for (st = 1; st <= n && !ara[st]; st++)\n    ;\n  for (ed = n; ed >= 1 && !ara[ed]; ed--)\n    ;\n  for (int i = st; i <= ed; i++) na[++len] = ara[i];\n  t[1] = na[1], t[2] = na[1] - 1, t[3] = na[1] + 1, t[4] = na[len],\n  t[5] = na[len] - 1, t[6] = na[len] + 1;\n  for (int i = 1; i <= 6; i++) {\n    if (t[i] > 1) {\n      int sq = sqrt(t[i]);\n      for (int j = 2; j <= sq && t[i] > 1; j++) {\n        if (t[i] % j == 0) s.insert(j);\n        while (t[i] % j == 0) t[i] /= j;\n      }\n      if (t[i] != 1) s.insert(t[i]);\n    }\n  }\n  unsigned long long ans = LLONG_MAX;\n  for (it = s.begin(); it != s.end(); it++) {\n    pr = *it;\n    ans = min(ans, solve(1, 0, 0));\n    memset(vis, 0, sizeof vis);\n  }\n  if (ans == LLONG_MAX) ans = 0;\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.SortedSet;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n/**\n * #\n * \n * @author pttrung\n */\npublic class D_AimTech_2016_Div2 {\n\n\tpublic static long MOD = 1000000007;\n\tstatic int[] unit = { 0, 1, -1 };\n\tstatic int index;\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\t// PrintWriter out = new PrintWriter(new FileOutputStream(new File(\n\t\t// \"output.txt\")));\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tScanner in = new Scanner();\n\t\tint N = in.nextInt();\n\t\tlong n = N;\n\t\tlong a = in.nextInt();\n\t\tlong b = in.nextInt();\n\t\tint[] data = new int[N];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdata[i] = in.nextInt();\n\t\t}\n\t\tif (n == 1) {\n\t\t\tout.println(0);\n\t\t} else {\n\t\t\tlong result = a * (n - 1);\n\t\t\tHashSet<Long> set = new HashSet();\n\t\t\tlong[] pre = new long[N];\n\t\t\tfor (int i : unit) {\n\t\t\t\tlong v = data[0] + i;\n\t\t\t\tfor (long k = 2; k * k <= v; k++) {\n\t\t\t\t\tif (v % k == 0) {\n\t\t\t\t\t\twhile (v % k == 0) {\n\t\t\t\t\t\t\tv /= k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (set.contains(k)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tset.add(k);\n\t\t\t\t\t\tlong tmp = a * (n - 1) + (i != 0 ? b : 0);\n\t\t\t\t\t\tlong min = tmp;\n\t\t\t\t\t\tpre[0] = tmp;\n\t\t\t\t\t\tfor (int j = 1; j < n; j++) {\n\t\t\t\t\t\t\tif (data[j] % k == 0) {\n\t\t\t\t\t\t\t\ttmp -= a;\n\t\t\t\t\t\t\t\tmin = min(tmp, min);\n\t\t\t\t\t\t\t} else if (data[j] % k == 1\n\t\t\t\t\t\t\t\t\t|| data[j] % k == (k - 1)) {\n\t\t\t\t\t\t\t\ttmp += b - a;\n\t\t\t\t\t\t\t\tmin = min(tmp, min);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (int h = j; h < n; h++) {\n\t\t\t\t\t\t\t\t\tpre[h] = min;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//System.out.println(tmp + \" \" + j);\n\t\t\t\t\t\t\tpre[j] = min;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult = min(min, result);\n\t\t\t\t\t\tresult = min(cal(k, pre, a, b, data), result);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (v != 1) {\n\t\t\t\t\tif (set.contains(v)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tset.add(v);\n\t\t\t\t\tlong k = v;\n\t\t\t\t\tlong tmp = a * (n - 1) + (i != 0 ? b : 0);\n\t\t\t\t\tlong min = tmp;\n\n\t\t\t\t\tpre[0] = tmp;\n\t\t\t\t\tfor (int j = 1; j < n; j++) {\n\t\t\t\t\t\tif (data[j] % k == 0) {\n\t\t\t\t\t\t\ttmp -= a;\n\t\t\t\t\t\t\tmin = min(tmp, min);\n\t\t\t\t\t\t} else if (data[j] % k == 1 || data[j] % k == (k - 1)) {\n\t\t\t\t\t\t\ttmp += b - a;\n\t\t\t\t\t\t\tmin = min(tmp, min);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (int h = j; h < n; h++) {\n\t\t\t\t\t\t\t\tpre[h] = min;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//System.out.println(min  + \" \" + k + \" \" + j);\n\n\t\t\t\t\t\tpre[j] = min;\n\t\t\t\t\t}\n\t\t\t\t\tresult = min(min, result);\n\t\t\t\t\tresult = min(cal(k, pre, a, b, data), result);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println(result);\n\t\t\tset.clear();\n\t\t\tfor (int i : unit) {\n\t\t\t\tlong v = data[N - 1] + i;\n\t\t\t\tfor (long k = 2; k * k <= v; k++) {\n\t\t\t\t\tif (v % k == 0) {\n\t\t\t\t\t\twhile (v % k == 0) {\n\t\t\t\t\t\t\tv /= k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (set.contains(k)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tset.add(k);\n\t\t\t\t\t\tlong tmp = a * (n - 1) + (i != 0 ? b : 0);\n\t\t\t\t\t\tlong min = tmp;\n\n\t\t\t\t\t\tfor (int j = N - 2; j >= 0; j--) {\n\t\t\t\t\t\t\tif (data[j] % k == 0) {\n\t\t\t\t\t\t\t\ttmp -= a;\n\t\t\t\t\t\t\t\tmin = min(tmp, min);\n\t\t\t\t\t\t\t} else if (data[j] % k == 1\n\t\t\t\t\t\t\t\t\t|| data[j] % k == (k - 1)) {\n\t\t\t\t\t\t\t\ttmp += b - a;\n\t\t\t\t\t\t\t\tmin = min(tmp, min);\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult = min(min, result);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (v != 1) {\n\t\t\t\t\tif (set.contains(v)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tset.add(v);\n\t\t\t\t\tlong k = v;\n\t\t\t\t\tlong tmp = a * (n - 1) + (i != 0 ? b : 0);\n\t\t\t\t\tlong min = tmp;\n\n\t\t\t\t\tfor (int j = N - 2; j >= 0; j --) {\n\t\t\t\t\t\tif (data[j] % k == 0) {\n\t\t\t\t\t\t\ttmp -= a;\n\t\t\t\t\t\t\tmin = min(tmp, min);\n\t\t\t\t\t\t} else if (data[j] % k == 1 || data[j] % k == (k - 1)) {\n\t\t\t\t\t\t\ttmp += b - a;\n\t\t\t\t\t\t\tmin = min(tmp, min);\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tresult = min(min, result);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout.println(result);\n\n\t\t}\n\n\t\tout.close();\n\t}\n\n\tstatic long cal(long k, long[] pre, long a, long b, int[] data) {\n\t\tlong result = pre[data.length - 1];\n\t\tlong cur = 0;\n\t\tfor (int i = data.length - 1; i >= 0; i--) {\n\t\t\tif (data[i] % k == 0) {\n\t\t\t\tcur -= a;\n\t\t\t} else if (data[i] % k == 1 || data[i] % k == k - 1) {\n\t\t\t\tcur += b - a;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlong tmp = cur + (i > 0 ? pre[i - 1] : data.length * a);\n\t\t\t//System.out.println(tmp + \" \" + i + \" \" + k);\n\t\t\tresult = min(tmp, result);\n\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic long min(long a, long b) {\n\t\treturn a < b ? a : b;\n\t}\n\n\tstatic long min(long a, long b, int cur) {\n\t\tif (a < b) {\n\t\t\tindex = cur;\n\t\t\treturn a;\n\t\t}\n\t\treturn b;\n\t}\n\n\tpublic static int[] KMP(String val) {\n\t\tint i = 0;\n\t\tint j = -1;\n\t\tint[] result = new int[val.length() + 1];\n\t\tresult[0] = -1;\n\t\twhile (i < val.length()) {\n\t\t\twhile (j >= 0 && val.charAt(j) != val.charAt(i)) {\n\t\t\t\tj = result[j];\n\t\t\t}\n\t\t\tj++;\n\t\t\ti++;\n\t\t\tresult[i] = j;\n\t\t}\n\t\treturn result;\n\n\t}\n\n\tpublic static boolean nextPer(int[] data) {\n\t\tint i = data.length - 1;\n\t\twhile (i > 0 && data[i] < data[i - 1]) {\n\t\t\ti--;\n\t\t}\n\t\tif (i == 0) {\n\t\t\treturn false;\n\t\t}\n\t\tint j = data.length - 1;\n\t\twhile (data[j] < data[i - 1]) {\n\t\t\tj--;\n\t\t}\n\t\tint temp = data[i - 1];\n\t\tdata[i - 1] = data[j];\n\t\tdata[j] = temp;\n\t\tArrays.sort(data, i, data.length);\n\t\treturn true;\n\t}\n\n\tpublic static int digit(long n) {\n\t\tint result = 0;\n\t\twhile (n > 0) {\n\t\t\tn /= 10;\n\t\t\tresult++;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static double dist(long a, long b, long x, long y) {\n\t\tdouble val = (b - a) * (b - a) + (x - y) * (x - y);\n\t\tval = Math.sqrt(val);\n\t\tdouble other = x * x + a * a;\n\t\tother = Math.sqrt(other);\n\t\treturn val + other;\n\n\t}\n\n\tpublic static class Point implements Comparable<Point> {\n\n\t\tint x, y;\n\n\t\tpublic Point(int start, int end) {\n\t\t\tthis.x = start;\n\t\t\tthis.y = end;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tint hash = 5;\n\t\t\thash = 47 * hash + this.x;\n\t\t\thash = 47 * hash + this.y;\n\t\t\treturn hash;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (obj == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (getClass() != obj.getClass()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfinal Point other = (Point) obj;\n\t\t\tif (this.x != other.x) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this.y != other.y) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Point o) {\n\t\t\treturn x - o.x;\n\t\t}\n\t}\n\n\tpublic static class FT {\n\n\t\tlong[] data;\n\n\t\tFT(int n) {\n\t\t\tdata = new long[n];\n\t\t}\n\n\t\tpublic void update(int index, long value) {\n\t\t\twhile (index < data.length) {\n\t\t\t\tdata[index] += value;\n\t\t\t\tindex += (index & (-index));\n\t\t\t}\n\t\t}\n\n\t\tpublic long get(int index) {\n\t\t\tlong result = 0;\n\t\t\twhile (index > 0) {\n\t\t\t\tresult += data[index];\n\t\t\t\tindex -= (index & (-index));\n\t\t\t}\n\t\t\treturn result;\n\n\t\t}\n\t}\n\n\tpublic static long gcd(long a, long b) {\n\t\tif (b == 0) {\n\t\t\treturn a;\n\t\t}\n\t\treturn gcd(b, a % b);\n\t}\n\n\tpublic static long pow(long a, long b) {\n\t\tif (b == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (b == 1) {\n\t\t\treturn a;\n\t\t}\n\t\tlong val = pow(a, b / 2);\n\t\tif (b % 2 == 0) {\n\t\t\treturn val * val % MOD;\n\t\t} else {\n\t\t\treturn val * (val * a % MOD) % MOD;\n\n\t\t}\n\t}\n\n\tstatic class Scanner {\n\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic Scanner() throws FileNotFoundException {\n\t\t\t// System.setOut(new PrintStream(new\n\t\t\t// BufferedOutputStream(System.out), true));\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t// br = new BufferedReader(new InputStreamReader(new\n\t\t\t// FileInputStream(new File(\"input.txt\"))));\n\t\t}\n\n\t\tpublic String next() {\n\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tthrow new RuntimeException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tst = null;\n\t\t\ttry {\n\t\t\t\treturn br.readLine();\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new RuntimeException();\n\t\t\t}\n\t\t}\n\n\t\tpublic boolean endLine() {\n\t\t\ttry {\n\t\t\t\tString next = br.readLine();\n\t\t\t\twhile (next != null && next.trim().isEmpty()) {\n\t\t\t\t\tnext = br.readLine();\n\t\t\t\t}\n\t\t\t\tif (next == null) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tst = new StringTokenizer(next);\n\t\t\t\treturn st.hasMoreTokens();\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new RuntimeException();\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:100000000000000\")\nusing namespace std;\nint n, arr[1000001], a, b;\nvector<int> p;\nvoid doit(int x) {\n  long long y = 2;\n  while (y * y <= x) {\n    int cnt = 0;\n    while (x % y == 0) x /= y, cnt++;\n    if (cnt) p.push_back(y);\n    y++;\n  }\n  if (x > 1) p.push_back(x);\n}\nlong long dp[1000001][3], d, inf = 1ll << 58;\nlong long rec(int p, int s) {\n  if (p == n) return 0;\n  if (~dp[p][s]) return dp[p][s];\n  long long ret = inf;\n  if (s == 0) {\n    ret = rec(p + 1, 1) + a;\n    long long tmp = rec(p + 1, 0);\n    int need = arr[p] % d;\n    if (need == 0) {\n      ret = min(ret, tmp);\n    } else if (need == 1 || need == d - 1) {\n      tmp += b;\n      ret = min(ret, tmp);\n    }\n  } else if (s == 1) {\n    ret = rec(p + 1, 1) + a;\n    long long tmp = rec(p + 1, 2);\n    int need = arr[p] % d;\n    if (need == 0) {\n      ret = min(ret, tmp);\n    } else if (need == 1 || need == d - 1) {\n      tmp += b;\n      ret = min(ret, tmp);\n    }\n  } else {\n    long long tmp = rec(p + 1, 2);\n    int need = arr[p] % d;\n    if (need == 0) {\n      ret = min(ret, tmp);\n    } else if (need == 1 || need == d - 1) {\n      tmp += b;\n      ret = min(ret, tmp);\n    }\n  }\n  return dp[p][s] = ret;\n}\nint main() {\n  scanf(\"%d %d %d\", &n, &a, &b);\n  for (int i = 0; i < n; i++) scanf(\"%d\", &arr[i]);\n  doit(arr[0]);\n  doit(arr[0] - 1);\n  doit(arr[0] + 1);\n  doit(arr[n - 1]);\n  doit(arr[n - 1] - 1);\n  doit(arr[n - 1] + 1);\n  sort((p).begin(), (p).end());\n  (p).resize(unique((p).begin(), (p).end()) - (p).begin());\n  long long ans = 1ll << 60;\n  for (int i = 0; i < p.size(); i++) {\n    memset((dp), (-1), sizeof(dp));\n    d = p[i];\n    ans = min(ans, rec(0, 0));\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nconst int inf = 1e9;\nconst long long linf = 1e18;\nlong long powm(long long a, long long p, long long m) {\n  long long r = 1 % m;\n  while (p) {\n    if (p & 1) r = r * a % m;\n    p >>= 1;\n    a = a * a % m;\n  }\n  return r;\n}\nint v[1000000];\nset<int> var;\nvoid fact(int x) {\n  for (int i = 2; i * i <= x; ++i)\n    for (; x % i == 0; x /= i) var.insert(i);\n  if (x > 1) var.insert(x);\n}\nint main() {\n  int n, a, b;\n  scanf(\"%d%d%d\", &n, &a, &b);\n  for (int i = 0; i < n; ++i) scanf(\"%d\", v + i);\n  for (int i = -1; i < 2; ++i) {\n    fact(v[0] + i);\n    fact(v[n - 1] + i);\n  }\n  vector<int> s(var.begin(), var.end());\n  vector<vector<long long> > dp(3, vector<long long>(s.size(), 0));\n  for (int i = 0; i < n; ++i) {\n    vector<vector<long long> > tmp(3, vector<long long>(s.size(), linf));\n    for (int j = 0; j < s.size(); ++j)\n      for (int k = 0; k < 3; ++k)\n        if (dp[k][j] < linf) {\n          for (int d = -1; d < 2; ++d)\n            if ((v[i] + d) % s[j] == 0) {\n              if (k == 0 || k == 2)\n                tmp[k][j] = min(tmp[k][j], dp[k][j] + abs(d) * b);\n              if (k == 1) tmp[2][j] = min(tmp[2][j], dp[k][j] + abs(d) * b);\n            }\n          if (k < 2) tmp[1][j] = min(tmp[1][j], dp[k][j] + a);\n        }\n    dp = tmp;\n  }\n  long long ans = 1ll * (n - 1) * a;\n  for (int j = 0; j < s.size(); ++j)\n    for (int k = 0; k < 3; ++k) ans = min(ans, dp[k][j]);\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = int(1e9);\nconst int MOD = int(1e9) + 7;\nconst unsigned long long N = 1000010;\nconst long long INFll = 1ll * INF * INF;\nconst long double ldINF = 1e+018;\nconst long double EPS = 0.000000001;\nconst int sdx[4] = {-1, 0, 1, 0};\nconst int sdy[4] = {0, 1, 0, -1};\nconst long double PI = 3.1415926535897932384;\ntemplate <typename T>\nostream& operator<<(ostream& out, pair<T, T>& a) {\n  out << a.first << \" \" << a.second;\n  return out;\n}\ntemplate <typename T>\nistream& operator>>(istream& in, pair<T, T>& a) {\n  in >> a.first >> a.second;\n  return in;\n}\ntemplate <typename T>\nistream& operator>>(istream& in, vector<T>& a) {\n  for (int i = 0; i < a.size(); ++i) in >> a[i];\n  return in;\n}\ntemplate <typename T>\nostream& operator<<(ostream& out, vector<T> a) {\n  for (int i = 0; i < a.size(); ++i)\n    if (i == a.size() - 1)\n      out << a[i];\n    else\n      out << a[i] << \" \";\n  return out;\n}\nmap<int, bool> used;\nvector<int> c;\nvoid go(int x) {\n  int d = 2;\n  while (1ll * d * d <= 1ll * x) {\n    if (x % d == 0) {\n      if (!used[d]) {\n        c.push_back(d);\n        used[d] = true;\n      }\n      while (x % d == 0) x /= d;\n    }\n    d = (d == 2 ? 3 : d + 1);\n  }\n  if (x > 1 && !used[x]) {\n    c.push_back(x);\n    used[x] = true;\n  }\n}\nint main() {\n  cin.tie(0);\n  int n;\n  unsigned long long a, b;\n  scanf(\"%d%I64d%I64d\", &n, &a, &b);\n  vector<int> v(n);\n  for (int i = 0; i < n; i++) scanf(\"%d\", &v[i]);\n  go(v[0]);\n  go(v[0] - 1);\n  go(v[0] + 1);\n  go(v.back());\n  go(v.back() + 1);\n  go(v.back() - 1);\n  unsigned long long ans = INFll;\n  for (int x = 0; x < c.size(); x++) {\n    int p = c[x];\n    unsigned long long dp[n + 10][4];\n    for (int i = 0; i < n + 2; i++) dp[i][0] = dp[i][1] = dp[i][2] = 0;\n    int m = v[0] % p;\n    int cnt = min(m, p - m);\n    unsigned long long value = cnt * b;\n    dp[0][0] = (cnt < 2 ? value : INFll);\n    dp[0][1] = a;\n    dp[0][2] = INFll;\n    for (int i = 1; i < n; i++) {\n      m = v[i] % p;\n      cnt = min(m, p - m);\n      value = cnt * b;\n      dp[i][0] = (cnt < 2 ? dp[i - 1][0] + value : INFll);\n      dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + a;\n      if (cnt < 2)\n        dp[i][2] = min(dp[i - 1][2], dp[i - 1][1]) + value;\n      else\n        dp[i][2] = INFll;\n    }\n    ans = min(ans, dp[n - 1][0]);\n    ans = min(ans, dp[n - 1][1]);\n    ans = min(ans, dp[n - 1][2]);\n  }\n  cout << ans << endl;\n  if (0)\n    cerr << fixed << setprecision(0)\n         << \"TIME = \" << clock() / (long double)CLOCKS_PER_SEC * 1000 << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MX = 1e6 + 9, INF = 1e16;\nlong long arr[MX], dp[MX][3];\nset<long long> s;\nvoid FUN(long long x) {\n  if (x == 2) return;\n  for (long long i = 2; i * i <= x; i++)\n    while (x > 1 && x % i == 0) x /= i, s.insert(i);\n  if (x > 1) s.insert(x);\n}\nint32_t main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  long long n, a, b;\n  cin >> n >> a >> b;\n  for (long long i = 0; i < n; i++) cin >> arr[i];\n  FUN(arr[0] + 1);\n  FUN(arr[0]);\n  FUN(arr[0] - 1);\n  FUN(arr[n - 1] + 1);\n  FUN(arr[n - 1]);\n  FUN(arr[n - 1] - 1);\n  long long minn = 1e18;\n  for (long long x : s) {\n    dp[0][0] = dp[0][1] = dp[0][2] = 0;\n    for (long long i = 1; i <= n; i++) {\n      if (arr[i - 1] % x == 0 || arr[i - 1] % x == 1 ||\n          arr[i - 1] % x == x - 1) {\n        dp[i][0] = dp[i - 1][0] + b * (arr[i - 1] % x != 0);\n        dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + a;\n        dp[i][2] = min(dp[i - 1][1], dp[i - 1][2]) + b * (arr[i - 1] % x != 0);\n      } else {\n        dp[i][0] = dp[i][2] = INF;\n        dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + a;\n      }\n      dp[i][0] = min(INF, dp[i][0]), dp[i][1] = min(INF, dp[i][1]),\n      dp[i][2] = min(INF, dp[i][2]);\n    }\n    minn = min(min(minn, dp[n][0]), min(dp[n][1], dp[n][2]));\n  }\n  cout << minn;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1000100;\nconst long long inf = 1ll << 42;\nint n, a, b, color, l[maxn], bio[maxn][3];\nlong long dp[maxn][3], sol = 1ll << 62;\nlong long rek(int p, int na, int id);\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin >> n >> a >> b;\n  for (int i = 0; i < n; i++) {\n    cin >> l[i];\n  }\n  int d = max(sqrt(l[0]), sqrt(l[n - 1]));\n  vector<int> v{l[0] - 1, l[0], l[0] + 1, l[n - 1] - 1, l[n - 1], l[n - 1] + 1};\n  set<int> pr;\n  for (int i = 2; i <= d; i++) {\n    for (int j = 0; j < 6; j++) {\n      bool ima = false;\n      while (v[j] % i == 0) {\n        v[j] /= i;\n        ima = true;\n      }\n      if (ima) {\n        pr.insert(i);\n      }\n    }\n  }\n  for (int i = 0; i < 6; i++) {\n    if (v[i] != 1) {\n      pr.insert(v[i]);\n    }\n  }\n  for (int i : pr) {\n    color++;\n    if (rek(i, n - 1, 0) >= 0) sol = min(sol, rek(i, n - 1, 0));\n  }\n  cout << sol << endl;\n}\nlong long rek(int p, int na, int id) {\n  if (na == -1) return 0;\n  if (bio[na][id] == color) return dp[na][id];\n  bio[na][id] = color;\n  int x = l[na];\n  long long c = inf;\n  if ((x + 1) % p == 0 || (x - 1) % p == 0)\n    c = b;\n  else if (x % p == 0)\n    c = 0;\n  if (id == 0)\n    return dp[na][id] = min(c + rek(p, na - 1, 0), a + rek(p, na - 1, 1));\n  if (id == 1)\n    return dp[na][id] = min(c + rek(p, na - 1, 2), a + rek(p, na - 1, 1));\n  return dp[na][id] = c + rek(p, na - 1, 2);\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\n\npublic class D {\n    public static void solution(BufferedReader reader, PrintWriter out)\n            throws IOException {\n        In in = new In(reader);\n        n = in.nextInt();\n        a = in.nextInt();\n        b = in.nextInt();\n        d = new int[n];\n        for (int i = 0; i < n; i++)\n            d[i] = in.nextInt();\n        for (int j = -1; j <= 1; j++) {\n            fact(d[0] + j);\n            fact(d[n - 1] + j);\n        }\n        long res = (n - 1L) * a;\n        for (Integer fa : f)\n            res = Math.min(res, solve(fa));\n        out.println(res);\n    }\n\n    private static int n, a, b;\n    private static int[] d;\n    private static HashSet<Integer> f = new HashSet<Integer>();\n\n    private static void fact(int n) {\n        for (int i = 2; i * i <= n; i++)\n            if (n % i == 0) {\n                f.add(i);\n                while (n % i == 0)\n                    n /= i;\n            }\n        if (n > 1)\n            f.add(n);\n    }\n\n    private static long MAX = (long) 1e16;\n    private static long[][] dp;\n\n    private static void update(int i, int j, long v) {\n        if (v < dp[i][j])\n            dp[i][j] = v;\n    }\n\n    private static long solve(int gcd) {\n        dp = new long[3][n];\n        Arrays.fill(dp[0], MAX);\n        Arrays.fill(dp[1], MAX);\n        Arrays.fill(dp[2], MAX);\n        if (d[0] % gcd == 0)\n            dp[0][0] = 0;\n        else if ((d[0] - 1) % gcd == 0 || (d[0] + 1) % gcd == 0)\n            dp[0][0] = b;\n        dp[1][0] = a;\n        dp[2][0] = a;\n        for (int i = 1; i < n; i++) {\n            update(1, i, dp[0][i - 1] + a);\n            update(1, i, dp[1][i - 1] + a);\n            update(2, i, dp[0][i - 1] + a);\n            update(2, i, dp[1][i - 1] + a);\n            if (d[i] % gcd == 0) {\n                update(0, i, dp[0][i - 1]);\n                update(2, i, dp[2][i - 1]);\n            }\n            else if ((d[i] - 1) % gcd == 0 || (d[i] + 1) % gcd == 0) {\n                update(0, i, dp[0][i - 1] + b);\n                update(2, i, dp[2][i - 1] + b);\n            }\n        }\n        return Math.min(dp[0][n - 1], dp[2][n - 1]);\n    }\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader reader = new BufferedReader(\n                new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(\n                new BufferedWriter(new OutputStreamWriter(System.out)));\n        solution(reader, out);\n        out.close();\n    }\n\n    protected static class In {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer = new StringTokenizer(\"\");\n\n        public In(BufferedReader reader) {\n            this.reader = reader;\n        }\n\n        public String next() throws IOException {\n            while (!tokenizer.hasMoreTokens())\n                tokenizer = new StringTokenizer(reader.readLine());\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "var data = readline().split(' ').map(Number);\nvar n = data[0],\n    p1 = data[1],\n    p2 = data[2];\n\nvar arr = readline().split(' ').map(Number);\n\nfunction fact(v, primes) {\n    for (var p = 2; p*p <= v; p++) {\n        if (v % p ==0) {\n            primes.push(p);\n            while (v % p == 0) v /= p;\n        }\n    }\n    if (v != 1) primes.push(v);\n}\n\nfunction sortNumber(a,b) {\n    return a - b;\n}\n\nfunction onlyUnique(value, index, self) { \n    return self.indexOf(value) === index;\n}\n\nvar cand = new Array();\nfor (var d = -1; d <= 1; d++) {\n    fact(arr[0]+d,cand);\n    fact(arr[n-1]+d,cand);\n}\n\ncand = cand.filter(onlyUnique);\ncand.sort(sortNumber);\n\nvar cost = [];\nvar rightcostsum = [];\nvar dp = [];\nvar result = Number.MAX_VALUE;\nfor (var p = 0; p < cand.length; p++) {\n    for (var i = 0; i < n; i++) {\n        if (arr[i] % cand[p] == 0) cost[i] = 0;\n        else if ((arr[i]-1) % cand[p] == 0) cost[i] = p2;\n        else if ((arr[i]+1) % cand[p] == 0) cost[i] = p2;\n        else cost[i] = Number.MAX_VALUE;\n    }\n    \n    rightcostsum[n-1] = cost[n-1];\n    \n    for (var i = n-2; i>=0; i--) {\n        rightcostsum[i] = Math.min(Number.MAX_VALUE, rightcostsum[i+1] + cost[i]);\n    }\n    dp[n] = 0;\n    for (var i = n-1; i >=  0; i--) {\n        dp[i] = Math.min(p1 + dp[i+1], rightcostsum[i]);\n    }\n    result = Math.min(result, dp[0]);\n    var leftcostsum = 0;\n    for (var i = 0; i < n; i++) {\n        leftcostsum = Math.min(Number.MAX_VALUE, leftcostsum + cost[i]);\n        result = Math.min(result, leftcostsum + dp[i+1]);\n    }\n    \n}\n\nprint(result);"
        },
        {
            "language": 4,
            "solution": "import com.sun.org.apache.xerces.internal.impl.dv.xs.IntegerDV;\nimport com.sun.org.apache.xerces.internal.impl.xpath.regex.Match;\n\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.BigInteger;\nimport java.util.*;\n\n\npublic class Main {\n    MyScanner cin = new MyScanner(System.in);\n    PrintWriter cout = new PrintWriter(System.out);\n\n    int inf = (int)2e9;\n    int N = (int) 500;\n\n    TreeSet<Integer> s = new TreeSet<Integer>();\n\n    private void run() throws FileNotFoundException {\n        //MyScanner cin = new MyScanner(new FileReader(\"strange.in\"));\n        //PrintWriter cout = new PrintWriter(new File(\"strange.out\"));\n        int n = cin.nextInt(), a = cin.nextInt(), b = cin.nextInt();\n        int[] q = new int[n];\n        for (int i = 0; i < n; i++){\n            q[i] = cin.nextInt();\n        }\n        factorize(q[0]);\n        factorize(q[0] + 1);\n        factorize(q[0] - 1);\n        factorize(q[n - 1]);\n        factorize(q[n - 1] + 1);\n        factorize(q[n - 1] - 1);\n        int[] w = new int[s.size()];\n        int n1 = 0;\n        for (int x: s) w[n1++] = x;\n        long res = (long) 1e18;\n        for (int p: w){\n            long s1 = 0, s2 = 0, s3 = 0, INF = (long) 1e16;\n            for (int i = 0; i < n; i++){\n                long cost = INF;\n                if (q[i] % p == 0){\n                    cost = 0;\n                } else if ((q[i] - 1) % p == 0 || (q[i] + 1) % p == 0){\n                    cost = b;\n                }\n                s1 += cost;\n                s2 += a;\n                s3 += cost;\n                s1 = Math.min(s1, INF);\n                s2 = Math.min(s2, s1);\n                s3 = Math.min(s2, s3);\n            }\n            res = Math.min(res, s3);\n        }\n        cout.print(res);\n        cout.close();\n    }\n\n    void factorize(int n){\n        for (int i = 2; i * i <= n; i++){\n            if(n % i == 0){\n                s.add(i);\n                while(n % i == 0) n /= i;\n            }\n        }\n        if (n > 1) s.add(n);\n    }\n\n\n    public static void main(String[] args) throws FileNotFoundException {\n        new Main().run();\n    }\n\n    class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        public MyScanner(FileReader in){\n            br = new BufferedReader(in);\n        }\n        public MyScanner(InputStream in) {\n            br = new BufferedReader(new InputStreamReader(in));\n        }\n\n        String next(){\n            while(st == null || !st.hasMoreElements()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e){\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        String tmp = \"\";\n        int nextInt(){return Integer.parseInt(next());}\n        double nextDouble(){return Double.parseDouble(next());}\n        long nextLong(){return Long.parseLong(next());}\n\n        String nextLine(){\n            String str = \"\";\n            try{\n                str = br.readLine();\n            } catch (IOException e){\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> ar;\nlong long int dp[1000005][4];\nset<int> prime;\nint n, a, b;\nlong long int ans = 1e18;\nvoid factorise(int n) {\n  for (int i = 2; i * i <= n; i++) {\n    if (n % i == 0) {\n      prime.insert(i);\n      while (n % i == 0) {\n        n = n / i;\n      }\n    }\n  }\n  if (n > 1) prime.insert(n);\n}\nvoid solve(int gcd) {\n  for (int i = 0; i <= n; i++) {\n    dp[i][0] = dp[i][1] = dp[i][2] = 1E15;\n  }\n  dp[0][0] = dp[0][1] = dp[0][2] = 0;\n  for (int i = 0; i < n; i++) {\n    long long int cost = 1E15;\n    int rem = ar[i] % gcd;\n    if (rem == 1 || rem == gcd - 1) {\n      cost = b;\n    } else if (rem == 0)\n      cost = 0;\n    for (int j = 0; j < 3; j++) {\n      if (j == 2) {\n        dp[i + 1][2] = min(dp[i + 1][2], dp[i][2] + cost);\n      } else if (j == 1) {\n        dp[i + 1][2] = min(dp[i + 1][2], dp[i][1] + a);\n        dp[i + 1][1] = min(dp[i + 1][1], dp[i][1] + a);\n        dp[i][1] = min(dp[i][1], dp[i][2]);\n      } else {\n        dp[i + 1][0] = min(dp[i + 1][0], dp[i][0] + cost);\n        dp[i + 1][1] = min(dp[i + 1][1], dp[i][0] + a);\n        dp[i][1] = min(dp[i][1], dp[i][0]);\n      }\n    }\n  }\n  ans = min(ans, dp[n][0]);\n  ans = min(ans, dp[n][1]);\n  ans = min(ans, dp[n][2]);\n}\nint main() {\n  cin >> n >> a >> b;\n  ar.resize(n);\n  for (int i = 0; i < n; i++) {\n    cin >> ar[i];\n  }\n  for (int i = -1; i <= 1; i++) {\n    factorise(ar[0] + i);\n    factorise(ar[n - 1] + i);\n  }\n  set<int>::iterator it;\n  for (it = prime.begin(); it != prime.end(); it++) {\n    solve(*it);\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class D624 {\n    private static final long MAX_N = 1000000100;\n    private static List<Integer> primes;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] line = br.readLine().split(\" \");\n        int n = Integer.valueOf(line[0]);\n        int removeCost = Integer.valueOf(line[1]);\n        int modifyCost = Integer.valueOf(line[2]);\n        int[] values = Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::valueOf).toArray();\n        long bestCost = Long.MAX_VALUE;\n\n        primes = generatePrimes((int) Math.sqrt(MAX_N) + 1);\n        Set<Integer> testPrimes = new HashSet<>();\n        addFactors(values[0], testPrimes);\n        addFactors(values[values.length - 1], testPrimes);\n\n        for (int prime : testPrimes) {\n            int[] costs = new int[n];\n            long leftCost = 0, rightCost = 0;\n            int minIdx = Integer.MAX_VALUE;\n            int maxIdx = Integer.MIN_VALUE;\n            for (int i = 0; i < values.length; i++) {\n                int mod = values[i] % prime;\n                if (mod == 0) {\n                    costs[i] = removeCost;\n                } else if (mod == 1 || mod == prime - 1) {\n                    costs[i] = removeCost - modifyCost;\n                    if (minIdx == Integer.MAX_VALUE) {\n                        leftCost += modifyCost;\n                    } else {\n                        rightCost += modifyCost;\n                    }\n                } else {\n                    costs[i] = 0;\n                    minIdx = Math.min(minIdx, i);\n                    if (i > maxIdx) {\n                        maxIdx = i;\n                        rightCost = 0;\n                    }\n                }\n            }\n\n            long currentCost = leftCost + rightCost;\n            if (minIdx == Integer.MAX_VALUE) {\n                currentCost += minSubArray(costs);\n            } else {\n                currentCost += (long) (maxIdx - minIdx + 1) * removeCost;\n                long bestLeft = 0, actLeft = 0;\n                for (int i = minIdx - 1; i >= 0; i--) {\n                    actLeft += costs[i];\n                    bestLeft = Math.min(bestLeft, actLeft);\n                }\n                currentCost += bestLeft;\n                long bestRight = 0, actRight = 0;\n                for (int i = maxIdx + 1; i < costs.length; i++) {\n                    actRight += costs[i];\n                    bestRight = Math.min(bestRight, actRight);\n                }\n                currentCost += bestRight;\n            }\n            bestCost = Math.min(currentCost, bestCost);\n        }\n        System.out.println(bestCost);\n    }\n\n    private static long minSubArray(int[] costs) {\n        long value = 0, result = 0;\n        for (int cost : costs) {\n            value += cost;\n            if (value > 0) {\n                value = 0;\n            }\n            result = Math.min(result, value);\n        }\n        return result;\n    }\n\n    private static void addFactors(int initValue, Set<Integer> testPrimes) {\n        for (int i = -1; i <= 1; i++) {\n            int value = initValue + i;\n            for (int prime : primes) {\n                boolean found = false;\n                while (value % prime == 0) {\n                    value /= prime;\n                    found = true;\n                }\n                if (found) {\n                    testPrimes.add(prime);\n                }\n            }\n            if (value != 1) {\n                testPrimes.add(value);\n            }\n        }\n    }\n\n    static List<Integer> generatePrimes(int maxPrime) {\n        List<Integer> primes = new ArrayList<>();\n        primes.add(2);\n        for (int i = 3; i <= maxPrime; i += 2) {\n            if (isPrime(i, primes)) {\n                primes.add(i);\n            }\n        }\n        return primes;\n    }\n\n    static boolean isPrime(long x, List<Integer> primes) {\n        for (int prime : primes) {\n            if (prime * prime > x) {\n                return true;\n            }\n            if (x % prime == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.*;\n\npublic class D {\n    public static void solution(BufferedReader reader, PrintWriter out)\n            throws IOException {\n        In in = new In(reader);\n        n = in.nextInt();\n        a = in.nextInt();\n        b = in.nextInt();\n        d = new int[n + 1];\n        for (int i = 1; i <= n; i++)\n            d[i] = in.nextInt();\n        for (int j = -1; j <= 1; j++) {\n            fact(d[1] + j);\n            fact(d[n] + j);\n        }\n        long res = (n - 1L) * a;\n        for (Integer fa : f)\n            res = Math.min(res, solve(fa));\n        out.println(res);\n    }\n\n    private static int n, a, b;\n    private static int[] d;\n    private static HashSet<Integer> f = new HashSet<Integer>();\n\n    private static void fact(int n) {\n        for (int i = 2; i * i <= n; i++)\n            if (n % i == 0) {\n                f.add(i);\n                while (n % i == 0)\n                    n /= i;\n            }\n        if (n > 1)\n            f.add(n);\n    }\n\n    private static long MAX = (long) 1e16;\n\n    private static long solve(int gcd) {\n        long[][] dp = new long[3][n + 1];\n        for (int i = 0; i < 3; i++)\n            Arrays.fill(dp[i], MAX);\n        dp[0][0] = dp[1][0] = dp[2][0] = 0;\n        for (int i = 1; i <= n; i++) {\n            dp[1][i] = dp[2][i] = Math.min(dp[0][i - 1], dp[1][i - 1]) + a;\n            if (d[i] % gcd == 0) {\n                dp[0][i] = dp[0][i - 1];\n                dp[2][i] = Math.min(dp[2][i], dp[2][i - 1]);\n            }\n            else if ((d[i] - 1) % gcd == 0 || (d[i] + 1) % gcd == 0) {\n                dp[0][i] = dp[0][i - 1] + b;\n                dp[2][i] = Math.min(dp[2][i], dp[2][i - 1] + b);\n            }\n            dp[0][i] = Math.min(dp[0][i], MAX);\n            dp[1][i] = Math.min(dp[1][i], MAX);\n            dp[2][i] = Math.min(dp[2][i], MAX);\n        }\n        return Math.min(dp[0][n], dp[2][n]);\n    }\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader reader = new BufferedReader(\n                new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(\n                new BufferedWriter(new OutputStreamWriter(System.out)));\n        solution(reader, out);\n        out.close();\n    }\n\n    protected static class In {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer = new StringTokenizer(\"\");\n\n        public In(BufferedReader reader) {\n            this.reader = reader;\n        }\n\n        public String next() throws IOException {\n            while (!tokenizer.hasMoreTokens())\n                tokenizer = new StringTokenizer(reader.readLine());\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.util.Collection;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.Set;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Tifuera\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskD solver = new TaskD();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskD {\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int n = in.nextInt();\n        long a = in.nextInt();\n        long b = in.nextInt();\n\n        int[] numbers = new int[n];\n        for (int i = 0; i < n; i++) {\n            numbers[i] = in.nextInt();\n        }\n\n        if (b == 0) {\n            out.println(0);\n            return;\n        }\n\n        Set<Integer> divisors = new HashSet<>();\n\n        getDivisors(numbers[0], divisors);\n        getDivisors(numbers[0] - 1, divisors);\n        getDivisors(numbers[0] + 1, divisors);\n\n        getDivisors(numbers[n - 1], divisors);\n        getDivisors(numbers[n - 1] - 1, divisors);\n        getDivisors(numbers[n - 1] + 1, divisors);\n\n        long answer = getAnswer(a, b, divisors, numbers);\n//        answer = Math.min(answer, getAnswer(a, b, getDivisors(numbers[0] - 1), numbers));\n//        answer = Math.min(answer, getAnswer(a, b, getDivisors(numbers[0] + 1), numbers));\n//\n//        answer = Math.min(answer, getAnswer(a, b, getDivisors(numbers[n - 1]), numbers));\n//        answer = Math.min(answer, getAnswer(a, b, getDivisors(numbers[n - 1] - 1), numbers));\n//        answer = Math.min(answer, getAnswer(a, b, getDivisors(numbers[n - 1] + 1), numbers));\n\n        out.println(answer);\n    }\n\n    private long getAnswer(long a, long b, Collection<Integer> divisors, int[] numbers) {\n        long answer = Long.MAX_VALUE;\n        long[][] dp = new long[numbers.length + 1][3];\n        for (int p : divisors) {\n            answer = Math.min(answer, getAnswer(a, b, numbers, p, dp));\n        }\n\n        return answer;\n    }\n\n    private void getDivisors(int num, Collection<Integer> divisors) {\n        for (int i = 2; i * 1L * i <= num; i++) {\n            if (num % i == 0) {\n                divisors.add(i);\n            }\n\n            while (num % i == 0) {\n                num /= i;\n            }\n        }\n\n        if (num > 1) {\n            divisors.add(num);\n        }\n\n    }\n\n    private long getAnswer(long a, long b, int[] numbers, int p, long[][] dp) {\n        boolean isOk = true;\n        for (long nb : numbers) {\n            if (nb % p != 0) {\n                isOk = false;\n                break;\n            }\n        }\n\n        if (isOk) {\n            return 0;\n        }\n\n        int len = numbers.length;\n        for (long[] arr : dp) {\n            Arrays.fill(arr, Long.MAX_VALUE - a - b);\n        }\n        dp[0][0] = 0;\n\n        for (int i = 0; i < len; i++) {\n            int cur = numbers[i];\n            dp[i + 1][1] = Math.min(dp[i + 1][1], a + dp[i][1]);\n            dp[i + 1][1] = Math.min(dp[i + 1][1], a + dp[i][0]);\n\n            if (cur % p == 0) {\n                dp[i + 1][0] = Math.min(dp[i + 1][0], dp[i][0]);\n\n                dp[i + 1][2] = Math.min(dp[i + 1][2], dp[i][2]);\n                dp[i + 1][2] = Math.min(dp[i + 1][2], dp[i][1]);\n            }\n            if ((cur + 1) % p == 0 || (cur - 1) % p == 0) {\n                dp[i + 1][0] = Math.min(dp[i + 1][0], b + dp[i][0]);\n\n                dp[i + 1][2] = Math.min(dp[i + 1][2], b + dp[i][2]);\n                dp[i + 1][2] = Math.min(dp[i + 1][2], b + dp[i][1]);\n            }\n        }\n\n\n        long answer = Math.min(dp[len][1], dp[len][2]);\n        if (dp[len][0] > 0) {\n            answer = Math.min(dp[len][0], answer);\n        }\n        return answer;\n    }\n\n\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private String[] currentArray;\n    private int curPointer;\n\n    public InputReader(InputStream inputStream) {\n        reader = new BufferedReader(new InputStreamReader(inputStream));\n    }\n\n\n    public int nextInt() {\n        if ((currentArray == null) || (curPointer >= currentArray.length)) {\n            try {\n                currentArray = reader.readLine().split(\" \");\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            curPointer = 0;\n        }\n        return Integer.parseInt(currentArray[curPointer++]);\n    }\n\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, a, b, st, ed, ara[1000010], na[1000010], len, t[10], pr;\nset<int> s;\nset<int>::iterator it;\nunsigned long long dp[1000010][5][2];\nint main() {\n  scanf(\"%d %d %d\", &n, &a, &b);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &ara[i]);\n  for (st = 1; st <= n && !ara[st]; st++)\n    ;\n  for (ed = n; ed >= 1 && !ara[ed]; ed--)\n    ;\n  for (int i = st; i <= ed; i++) na[++len] = ara[i];\n  t[1] = na[1], t[2] = na[1] - 1, t[3] = na[1] + 1, t[4] = na[len],\n  t[5] = na[len] - 1, t[6] = na[len] + 1;\n  for (int i = 1; i <= 6; i++) {\n    if (t[i] > 1) {\n      int sq = sqrt(t[i]);\n      for (int j = 2; j <= sq && t[i] > 1; j++) {\n        if (t[i] % j == 0) s.insert(j);\n        while (t[i] % j == 0) t[i] /= j;\n      }\n      if (t[i] != 1) s.insert(t[i]);\n    }\n  }\n  unsigned long long ans = LLONG_MAX;\n  for (it = s.begin(); it != s.end(); it++) {\n    pr = *it;\n    for (int pos = len + 1; pos >= 1; pos--) {\n      for (int st = 2; st >= 0; st--) {\n        for (int fe = 1; fe >= 0; fe--) {\n          if (pos > len) {\n            if (fe && st == 1)\n              dp[pos][st][fe] = LLONG_MAX;\n            else\n              dp[pos][st][fe] = 0;\n            continue;\n          }\n          unsigned long long op = LLONG_MAX;\n          if (na[pos] % pr == 0) {\n            if (st == 0 || st == 2)\n              op = dp[pos + 1][st][fe];\n            else\n              op =\n                  min(a + dp[pos + 1][1][fe || (pos == 1)], dp[pos + 1][2][fe]);\n          } else {\n            if (((ara[pos] - 1) % pr == 0) || ((ara[pos] + 1) % pr == 0)) {\n              if (st == 0 || st == 2)\n                op = b + dp[pos + 1][st][fe];\n              else\n                op = b + dp[pos + 1][2][fe];\n            }\n            if (st != 2) op = min(op, a + dp[pos + 1][1][fe || (pos == 1)]);\n          }\n          dp[pos][st][fe] = op;\n        }\n      }\n    }\n    ans = min(ans, dp[1][0][0]);\n  }\n  if (ans == LLONG_MAX) ans = 0;\n  cout << ans << endl;\n}\n"
        }
    ]
}