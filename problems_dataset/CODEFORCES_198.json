{
    "name": "198_B. Jumping on Walls",
    "source": "CODEFORCES",
    "description": "Vasya plays a computer game with ninjas. At this stage Vasya's ninja should get out of a deep canyon.\n\nThe canyon consists of two vertical parallel walls, their height is n meters. Let's imagine that we split these walls into 1 meter-long areas and number them with positive integers from 1 to n from bottom to top. Some areas are safe and the ninja can climb them. Others are spiky and ninja can't be there. Let's call such areas dangerous.\n\nInitially the ninja is on the lower area of the left wall. He can use each second to perform one of the following actions: \n\n  * climb one area up; \n  * climb one area down; \n  * jump to the opposite wall. That gets the ninja to the area that is exactly k meters higher than the area he jumped from. More formally, if before the jump the ninja is located at area x of one wall, then after the jump he is located at area x + k of the other wall. \n\n\n\nIf at some point of time the ninja tries to get to an area with a number larger than n, then we can assume that the ninja got out of the canyon.\n\nThe canyon gets flooded and each second the water level raises one meter. Initially the water level is at the lower border of the first area. Ninja cannot be on the area covered by water. We can assume that the ninja and the water \"move in turns\" \u2014 first the ninja performs some action, then the water raises for one meter, then the ninja performs one more action and so on.\n\nThe level is considered completed if the ninja manages to get out of the canyon.\n\nAfter several failed attempts Vasya started to doubt whether it is possible to complete the level at all. Help him answer the question.\n\nInput\n\nThe first line contains two integers n and k (1 \u2264 n, k \u2264 105) \u2014 the height of the canyon and the height of ninja's jump, correspondingly.\n\nThe second line contains the description of the left wall \u2014 a string with the length of n characters. The i-th character represents the state of the i-th wall area: character \"X\" represents a dangerous area and character \"-\" represents a safe area.\n\nThe third line describes the right wall in the same format.\n\nIt is guaranteed that the first area of the left wall is not dangerous.\n\nOutput\n\nPrint \"YES\" (without the quotes) if the ninja can get out from the canyon, otherwise, print \"NO\" (without the quotes).\n\nExamples\n\nInput\n\n7 3\n---X--X\n-X--XX-\n\n\nOutput\n\nYES\n\n\nInput\n\n6 2\n--X-X-\nX--XX-\n\n\nOutput\n\nNO\n\nNote\n\nIn the first sample the ninja should first jump to the right wall, then go one meter down along the right wall, then jump to the left wall. The next jump can get the ninja from the canyon. \n\nIn the second sample there's no way the ninja can get out of the canyon.",
    "difficulty": "B",
    "tags": [
        "shortest paths"
    ],
    "rating": 1400,
    "public_test": [
        {
            "input": "7 3\n---X--X\n-X--XX-\n",
            "output": "YES\n"
        },
        {
            "input": "6 2\n--X-X-\nX--XX-\n",
            "output": "NO\n"
        }
    ],
    "generated_test": [
        {
            "input": "6 2\n--X--W\nXX-X-X\n",
            "output": "YES\n"
        },
        {
            "input": "5 1\n----X\n-.--X\n",
            "output": "NO\n"
        },
        {
            "input": "3 3\n--XX--XX-XXX\n----X---XXX-\n",
            "output": "YES\n"
        },
        {
            "input": "001 1\n----------------------------------------------------------------------------------------------------X\n----------------------------------------------------------------------------------------------------X\n",
            "output": "YES\n"
        },
        {
            "input": "10 12\n-XXXXXXXXX\nXXXXXXXXX-\n",
            "output": "YES\n"
        },
        {
            "input": "5 4\n----X\n----X\n",
            "output": "YES\n"
        },
        {
            "input": "1 27\n-\n-\n",
            "output": "YES\n"
        },
        {
            "input": "50 4\n-X-X-X--X--X--X-XX-----XX--X--------------XXX-X-X-\n----X--X--X--XX-XXXX--XXX--X--XX----XXXXXXX---XX--\n",
            "output": "NO\n"
        },
        {
            "input": "5 2\n---XX\n,--X-\n",
            "output": "YES\n"
        },
        {
            "input": "1 1\n-\nY\n",
            "output": "YES\n"
        },
        {
            "input": "100 3\n-X------XXX--XXX-XXXXXX---XXX---X-XX--XXX----------XX-X-XXXX-X-X-XX-X-X--XXXXX---X--X--XXX-X--XXXXXX\n---X-XXXXXXX--X-XXX--X-XX--XX----XX-X----X-X-XX-X--X-XXXXXXX-XX-X---X--XX-X-XX--XXXXXXX-X--XX--X-XXX\n",
            "output": "NO\n"
        },
        {
            "input": "3 4\n----X---X--X\n-----X-----X\n",
            "output": "YES\n"
        },
        {
            "input": "7 3\n---X--X\n---XXX-\n",
            "output": "NO\n"
        },
        {
            "input": "6 2\n--W--W\nXX-X-X\n",
            "output": "YES\n"
        },
        {
            "input": "3 3\n--XY--XX-XXX\n----X---XXX-\n",
            "output": "YES\n"
        },
        {
            "input": "011 1\n----------------------------------------------------------------------------------------------------X\n----------------------------------------------------------------------------------------------------X\n",
            "output": "YES\n"
        },
        {
            "input": "5 0\n----X\n-.--X\n",
            "output": "NO\n"
        },
        {
            "input": "10 12\n-XXXXXXXXX\nXXWXXXXXX-\n",
            "output": "YES\n"
        },
        {
            "input": "50 4\n-X-X-X--X--X--X-XX-----XX--X--------------XXX-Y-X-\n--XX---XXXXXXX----XX--X--XXX--XXXX-XX--X--X--X----\n",
            "output": "YES\n"
        },
        {
            "input": "100 1\n-X------XXX--XXX-XXXXXX---XXX---X-XX--XXX----------XX-X-XXXX-X-X-XX-X-X--XXXXX---X--X--XXX-X--XXXXXX\n---X-XXXXXXX--X-XXX--X-XX--XX----XX-X----X-X-XX-X--X-XXXXXXX-XX-X---X--XX-X-XX--XXXXXXX-X--XX--X-XXX\n",
            "output": "NO\n"
        },
        {
            "input": "6 2\n-.W--W\nXX-X-X\n",
            "output": "YES\n"
        },
        {
            "input": "3 3\n--XY-,XX-XXX\n----X---XXX-\n",
            "output": "YES\n"
        },
        {
            "input": "011 1\n----------------------------------------------------------------------------------------------------X\nX----------------------------------------------------------------------------------------------------\n",
            "output": "YES\n"
        },
        {
            "input": "5 0\n----X\n-.-,X\n",
            "output": "NO\n"
        },
        {
            "input": "10 12\n-XXXXXXXXX\n-XXXXXXWXX\n",
            "output": "YES\n"
        },
        {
            "input": "50 4\n-X-X-X--X--X--X-XX-----XX--X--------------XXX-Y-X-\n----X--X--X--XX-XXXX--XXX--X--XX----XXXXXXX---XX--\n",
            "output": "NO\n"
        },
        {
            "input": "100 1\n-X------XXX--XXX-XXXXXX---XXX---X-XX--XXX----------XX-X-XXXX-X-X-XX-X-X--XXXXX---X--X--XXX-X--XXXXXX\n---X-XXXXXXW--X-XXX--X-XX--XX----XX-X----X-X-XX-X--X-XXXXXXX-XX-X---X--XX-X-XX--XXXXXXX-X--XX--X-XXX\n",
            "output": "NO\n"
        },
        {
            "input": "3 6\n--XY-,XX-XXX\n----X---XXX-\n",
            "output": "YES\n"
        },
        {
            "input": "011 1\n----------------------------------------------------------------------------------------------------X\nX--------------------------------------------------------------------------,-------------------------\n",
            "output": "YES\n"
        },
        {
            "input": "10 12\n-XWXXXXXXX\n-XXXXXXWXX\n",
            "output": "YES\n"
        },
        {
            "input": "50 1\n-X-X-X--X--X--X-XX-----XX--X--------------XXX-Y-X-\n----X--X--X--XX-XXXX--XXX--X--XX----XXXXXXX---XX--\n",
            "output": "NO\n"
        },
        {
            "input": "3 6\n-X-Y-,XX-XXX\n----X---XXX-\n",
            "output": "YES\n"
        },
        {
            "input": "011 1\n-----------------------------------------------------------------------,----------------------------X\nX--------------------------------------------------------------------------,-------------------------\n",
            "output": "YES\n"
        },
        {
            "input": "10 12\n-XWXXXXXWX\n-XXXXXXWXX\n",
            "output": "YES\n"
        },
        {
            "input": "50 1\n-X-X-X--X--X--X-XX-----XX--X--------------XXX-Y-X-\n----X--X--X--XX-XXXX--XXX--X--XX----XXWXXXX---XX--\n",
            "output": "NO\n"
        },
        {
            "input": "011 2\n-----------------------------------------------------------------------,----------------------------X\nX--------------------------------------------------------------------------,-------------------------\n",
            "output": "YES\n"
        },
        {
            "input": "10 12\n-XWXXXXXVX\n-XXXXXXWXX\n",
            "output": "YES\n"
        },
        {
            "input": "2 2\n-X\nX-\n",
            "output": "YES\n"
        },
        {
            "input": "25 3\n-XXXXX-XXXXX-XXXXX-X-XXXX\nXXXXXXXXX-XX-XX-X-----X--\n",
            "output": "NO\n"
        },
        {
            "input": "6 2\n--X--X\nXX-X,X\n",
            "output": "YES\n"
        },
        {
            "input": "101 2\n----------------------------------------------------------------------------------------------------X\n----------------------------------------------------------------------------------------------------X\n",
            "output": "YES\n"
        },
        {
            "input": "10 1\n-XXXXXXXXX\nXXXXXXXXX-\n",
            "output": "NO\n"
        },
        {
            "input": "5 4\n--X--\n----X\n",
            "output": "YES\n"
        },
        {
            "input": "50 4\n-X-X-X--X--X--X-XX-----XX--X---------,----XXX-X-X-\n--XX---XXXXXXX----XX--X--XXX--XXXX-XX--X--X--X----\n",
            "output": "YES\n"
        },
        {
            "input": "5 2\n-----\nXXYXX\n",
            "output": "YES\n"
        },
        {
            "input": "5 4\n---XX\n---X-\n",
            "output": "YES\n"
        },
        {
            "input": "1 100000\n-\n.\n",
            "output": "YES\n"
        },
        {
            "input": "10 1\n-X-X-X-X-X\nX-X-X--XX-\n",
            "output": "NO\n"
        },
        {
            "input": "12 2\n----X---X--X\n-----X-----X\n",
            "output": "YES\n"
        },
        {
            "input": "9 2\n---X---X--X-X\n--X---X-X--X-\n",
            "output": "YES\n"
        },
        {
            "input": "6 0\n--X-X-\nX--XX-\n",
            "output": "NO\n"
        },
        {
            "input": "3 3\n--XX--XX-XXX\n----W---XXX-\n",
            "output": "YES\n"
        },
        {
            "input": "001 1\n----------------------------------------------------------------------------------------------------X\n-------------------------------------------.--------------------------------------------------------X\n",
            "output": "YES\n"
        },
        {
            "input": "5 2\n----X\n-.--X\n",
            "output": "YES\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint f[200000][3], N, K;\nchar s1[200000], s2[200000];\nbool ok;\ninline void dfs(int x, int y) {\n  if (ok) return;\n  int Nxt = x + K;\n  if (Nxt > N) {\n    ok = 1;\n    return;\n  }\n  if (y == 1) {\n    if (s2[Nxt] == '-' && f[x][1] + 1 < f[Nxt][2] && Nxt > f[x][1] + 1) {\n      f[Nxt][2] = f[x][1] + 1;\n      dfs(Nxt, 2);\n    }\n    if (s1[x + 1] == '-' && f[x][1] + 1 < f[x + 1][1]) {\n      f[x + 1][1] = f[x][1] + 1;\n      dfs(x + 1, 1);\n    }\n    if (s1[x - 1] == '-' && f[x][1] + 1 < f[x - 1][1] && x - 1 > f[x][1] + 1) {\n      f[x - 1][1] = f[x][1] + 1;\n      dfs(x - 1, 1);\n    }\n  } else {\n    if (s1[Nxt] == '-' && f[x][2] + 1 < f[Nxt][1] && Nxt > f[x][2] + 1) {\n      f[Nxt][1] = f[x][2] + 1;\n      dfs(Nxt, 1);\n    }\n    if (s2[x + 1] == '-' && f[x][2] + 1 < f[x + 1][2]) {\n      f[x + 1][2] = f[x][2] + 1;\n      dfs(x + 1, 2);\n    }\n    if (s2[x - 1] == '-' && f[x][2] + 1 < f[x - 1][2] && x - 1 > f[x][2] + 1) {\n      f[x - 1][2] = f[x][2] + 1;\n      dfs(x - 1, 2);\n    }\n  }\n}\nint main() {\n  ios ::sync_with_stdio(false);\n  cin >> N >> K;\n  cin >> s1 + 1;\n  cin >> s2 + 1;\n  memset(f, 0x7f, sizeof(f));\n  f[1][1] = 0;\n  dfs(1, 1);\n  if (ok)\n    puts(\"YES\");\n  else\n    puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint d[500000];\nvector<int> v[500000];\nbool b[500000];\nqueue<int> q;\nint n;\nstring aa, bb;\nvoid bfs() {\n  while (!q.empty()) {\n    int x = d[q.front()];\n    int y = q.front();\n    b[q.front()] = true;\n    q.pop();\n    for (int i = 0; i < (int)v[y].size(); i++) {\n      int a = v[y][i];\n      if (!b[a] && a % n > x) {\n        d[a] = x + 1;\n        b[a] = true;\n        q.push(a);\n      }\n    }\n  }\n}\nint main() {\n  int k;\n  cin >> n >> k;\n  cin >> aa >> bb;\n  for (int i = 0; i < n; i++) {\n    if ((i + 1 < n && aa[i + 1] != 'X')) {\n      v[i].push_back(i + 1);\n    }\n    if (i + k < n && bb[i + k] != 'X') {\n      v[i].push_back(i + k + n);\n    }\n    if ((i + 1 + n < 2 * n && bb[i + 1] != 'X')) {\n      v[i + n].push_back(i + 1 + n);\n    }\n    if ((i + k + n < 2 * n && aa[i + k] != 'X')) {\n      v[i + n].push_back(i + k);\n    }\n    if (i - 1 >= 0 && aa[i - 1] != 'X') {\n      v[i].push_back(i - 1);\n    }\n    if (i + n - 1 >= n && bb[i - 1] != 'X') {\n      v[i + n].push_back(i + n - 1);\n    }\n  }\n  for (int i = 0; i < 2 * n; i++) {\n    d[i] = 500000;\n    b[i] = false;\n  }\n  d[0] = 0;\n  q.push(0);\n  bfs();\n  int s = 500000;\n  for (int i = 0; i < k; i++) {\n    s = min(s, d[n - i - 1]);\n    s = min(s, d[2 * n - i - 1]);\n  }\n  if (s == 500000) {\n    printf(\"NO\\n\");\n  } else {\n    printf(\"YES\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MAXN = 111111;\nbool v[2][MAXN];\nchar s[2][MAXN];\nint n, k, r;\nstruct state {\n  int x, y, t;\n} q[MAXN << 1];\ninline void insert(int x, int y, int t) {\n  if (y >= n) {\n    puts(\"YES\");\n    exit(0);\n  }\n  if (y < t || s[x][y] == 'X' || v[x][y]) return;\n  v[x][y] = true;\n  q[++r].x = x;\n  q[r].y = y;\n  q[r].t = t;\n}\nint main() {\n  scanf(\"%d%d%s%s\", &n, &k, s[0], s[1]);\n  v[0][0] = true;\n  for (int l = 0; l <= r; ++l) {\n    insert(q[l].x, q[l].y + 1, q[l].t + 1);\n    insert(q[l].x, q[l].y - 1, q[l].t + 1);\n    insert(q[l].x ^ 1, q[l].y + k, q[l].t + 1);\n  }\n  puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> graph[100005];\nvector<int> graphcolor[100005];\nint dist[100005];\nint par[100005];\nint visited[100005];\nint n, k;\nint step;\nint color, dist1, dist2;\nint arr[105];\nint sum = 0;\nchar string1[100005];\nchar string2[100005];\nvoid dfs(int s, int w, int flag) {\n  int u, i;\n  if (s + k >= n) {\n    printf(\"YES\\n\");\n    exit(0);\n  }\n  if (flag == 1) string1[s] = 'X';\n  if (flag == 2) string2[s] = 'X';\n  if (s - 1 > w + 1) {\n    if (flag == 1)\n      if (string1[s - 1] == '-' && s - 1 >= 0) dfs(s - 1, w + 1, 1);\n    if (string2[s - 1] == '-' && flag == 2 && s > 0) dfs(s - 1, w + 1, 2);\n  }\n  if (flag == 1) {\n    if (string2[s + k] != 'X') dfs(s + k, w + 1, 2);\n  } else if (flag == 2) {\n    if (string1[s + k] != 'X') dfs(s + k, w + 1, 1);\n  }\n  if (string1[s + 1] != 'X' && flag == 1)\n    dfs(s + 1, w + 1, 1);\n  else if (string2[s + 1] != 'X' && flag == 2)\n    dfs(s + 1, w + 1, 2);\n}\nint main() {\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &k);\n  int u, v;\n  int j;\n  cin >> string1;\n  cin >> string2;\n  dfs(0, -1, 1);\n  printf(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class B198 {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int N = in.nextInt();\n        int K = in.nextInt();\n        char[] L = in.next().toCharArray();\n        char[] R = in.next().toCharArray();\n        boolean[][] seen = new boolean[2][N];\n        Queue<Data> queue = new LinkedList<>();\n        Data data = new Data(true, 0, 0);\n        queue.add(data);\n        boolean found = false;\n        while (!queue.isEmpty()) {\n            data = queue.poll();\n            int jumpHeight = data.height + K;\n            if (jumpHeight >= N) {\n                found = true;\n                break;\n            } else {\n                Data newData = new Data(!data.left, jumpHeight, data.time+1);\n                if ((newData.left ? L : R)[newData.height] == '-' && !seen[newData.left ? 0 : 1][newData.height]) {\n                    queue.add(newData);\n                    seen[newData.left ? 0 : 1][newData.height] = true;\n                }\n            }\n            if ((data.left ? L : R)[data.height+1] == '-' && !seen[data.left ? 0 : 1][data.height+1]) {\n                queue.add(new Data(data.left, data.height+1, data.time+1));\n                seen[data.left ? 0 : 1][data.height+1] = true;\n            }\n            Data newData = new Data(data.left, data.height-1, data.time+1);\n            if (newData.height >= newData.time && (newData.left ? L : R)[newData.height] == '-' && !seen[newData.left ? 0 : 1][newData.height]) {\n                queue.add(newData);\n                seen[newData.left ? 0 : 1][newData.height] = true;\n            }\n        }\n        System.out.println(found ? \"YES\" : \"NO\");\n    }\n\n    static class Data {\n        boolean left;\n        int height;\n        int time;\n\n        Data(boolean left, int height, int time) {\n            this.left = left;\n            this.height = height;\n            this.time = time;\n        }\n    }\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class Solution \n{\n\tstatic InputReader in = new InputReader(System.in);\n\tstatic int mod = (int)1e9 + 7;\n\tstatic int MAXN = 100005;\n\tstatic long[] fact = new long[MAXN];\n\tstatic long[] inv = new long[MAXN];\n\t\n    public static void main(String args[]) {\n        new Thread(null, new Runnable() {\n            public void run() {\n                try{\n                    solve();\n                }\n                catch(Exception e){\n                    e.printStackTrace();\n                }\n            }\n        }, \"1\", 1 << 26).start();\n    }\n    \n    public static void solve(){\n    \tint n = in.ni();\n    \tint k = in.ni();\n    \tQueue<int[]> q = new LinkedList<>();\n    \tboolean[][] visited = new boolean[n + k + 5][2];\n    \t//boolean[][] danger = new boolean[n + 1][2];\n    \tString s = in.readString();\n    \tfor(int i = 0; i < n; i++) {\n    \t\tif(s.charAt(i) == 'X') visited[i + 1][0] = true;\n    \t}\n    \t\n    \ts = in.readString();\n    \tfor(int i = 0; i < n; i++) {\n    \t\tif(s.charAt(i) == 'X') visited[i + 1][1] = true;\n    \t}\n    \t\n    \tq.add(new int[] {1, 0});\n    \tvisited[1][0] = true;\n    \tint water = 0;\n    \twhile(q.size() != 0) {\n    \t\tint size = q.size();\n    \t\t//for(int[] i: q) System.out.print(\"(\"+i[0]+\", \"+i[1]+\") \"); pn(\"\");\n    \t\twhile(size-- > 0) {\n    \t\t\tint[] element = q.poll();\n    \t\t\tint col = element[1];\n    \t\t\tint row = element[0];\n    \t\t\tif(row >= n) {\n    \t\t\t\tpn(\"YES\");\n    \t\t\t\treturn;\n    \t\t\t}\n    \t\t\tif(!visited[row + 1][col]) {\n    \t\t\t\t//pn(\"In\");\n        \t\t\tq.add(new int[] {row + 1, col});\n        \t\t\tvisited[row + 1][col] = true;\n    \t\t\t}\n    \t\t\tif(row > water + 2 && !visited[row - 1][col]) {\n    \t\t\t\t//pn(\"In\");\n        \t\t\tq.add(new int[] {row - 1, col});\n        \t\t\tvisited[row - 1][col] = true;\n    \t\t\t}\n    \t\t\tint changeCol = 1 - col;\n    \t\t\t//pn(changeCol);\n    \t\t\tif(!visited[row + k][changeCol]) {\n    \t\t\t\t//pn(\"In\");\n        \t\t\tq.add(new int[] {row + k, changeCol});\n        \t\t\tvisited[row + k][changeCol] = true;\n    \t\t\t}\n    \t\t}\n    \t\twater++;\n    \t}\n    \tpn(\"NO\");\n    }\n        \n   \n\t/*TEMPLATE*/\n    \n    //MATHS\n    static int max(Integer... ar) {\n    \tint max = Integer.MIN_VALUE;\n    \tfor(int i: ar) {\n    \t\tmax = Math.max(max, i);\n    \t}\n    \treturn max;\n    }\n    \n    static long max(Long... ar) {\n    \tlong max = Integer.MIN_VALUE;\n    \tfor(long i: ar) {\n    \t\tmax = Math.max(max, i);\n    \t}\n    \treturn max;\n    }\n  \n    static int gcd(int a, int b) {\n    \treturn (b==0)?a:gcd(b,a%b);\n    }\n    \n    static long binPow(long x, long y) {\n        long ans = 1L;\n        while(y > 0) {\n            if(y % 2 == 1)\n                ans = mul(ans, x);\n            x = mul(x, x);\n            y /= 2;\n        }\n        return ans;\n    }\n    \n    static long add(long x, long y) {\n    \tx += y;\n    \treturn mod(x, mod);\n    }\n    \n    static long mul(long x, long y) {\n    \treturn mod(x * y, mod);\n    }\n    \n    static long divide(long x, long y) {\n        return mul(x, binPow(y, mod - 2));\n    }\n\n    static long mod(long x, long p) {\n        x %= p;\n        if (x < 0)\n            x += p;\n        return x;\n    }\n        \n    public static int[] spf(int maxn) {\n    \tint[] spf=new int[maxn+1];\n    \tspf[0]=spf[1]=1;\n    \tfor(int i=2;i<=maxn;i++) {\n    \t\tif(i%2==0) spf[i]=2;\n    \t\telse \n    \t\t\tspf[i]=i;\n    \t}\n    \tfor(int i=3;i*i<=maxn;i++) {\n    \t\tif(spf[i]==i){\n    \t\t\tfor (int j=i*i; j<=maxn; j+=i) \n                    if (spf[j]==j) \n                        spf[j] = i;\n    \t\t}\n    \t}\n    \treturn spf;\n    }\n    \n    static void nCrInit() {\n    \tfact[0] = 1;\n    \tfor(int i = 1; i < MAXN; i++) fact[i] = mul(fact[i - 1], 1L * i);\n    \tinv[MAXN - 1] = binPow(fact[MAXN - 1], mod - 2); \n    \tfor(int i = MAXN - 2; i >= 0; i--) inv[i] = mul(inv[i + 1], 1L * (i + 1));\n     }\n    \n    static long nCr(int n, int r) {\n    \tif(r > n || n < 0 || r < 0) return 0;\n    \treturn fact[n] * inv[r] % mod * inv[n - r] % mod;\n    }\n    \n    //ARRAYS\n    public static int[] intArray(int n) {\n    \tint ar[]=new int[n];\n    \tfor(int i=0;i<n;i++)\n    \t\tar[i]=in.nextInt();\n    \treturn ar;\n    }\n    \n    public static void swap(int i, int j, int ar[]) {\n    \tint c=ar[i];ar[i]=ar[j];ar[j]=c;\n    }\n    \n    public static void reverse(int ar[]) {\n    \tint l=0, r=ar.length-1;\n    \twhile(l<r) {\n    \t\tint temp=ar[l]; ar[l]=ar[r]; ar[r]=temp;\n    \t\tl++; r--;\n    \t}\n    }\n    \n    static int max(int[] ar) {\n    \tint max = Integer.MIN_VALUE;\n    \tfor(int i: ar) {\n    \t\tmax = Math.max(max, i);\n    \t}\n    \treturn max;\n    }\n    \n    static long max(long[] ar) {\n    \tlong max = Integer.MIN_VALUE;\n    \tfor(long i: ar) {\n    \t\tmax = Math.max(max, i);\n    \t}\n    \treturn max;\n    }\n    \n    public static int upperBound(int[] array, int value) {\n    \t//return next higher element. If greater than all elements then returns array.length\n    \t//returns 0 if smaller than all elements\n    \tint low = 0;\n    \tint high = array.length;\n    \twhile (low < high) {\n    \t\tfinal int mid = (low + high) / 2;\n    \t\tif (value >= array[mid]) {\n    \t\t\tlow = mid + 1;\n    \t\t} else {\n    \t\t\thigh = mid;\n    \t\t}\n    \t}\n    \treturn low;\n    }\n    \n    public static int lowerBound(int[] array, int value) {\n    \t//Returns first occurrence.\n    \t//Bigger than all elements then return array.length\n    \t//Not found, then next greater.s\n    \tint low = 0;\n    \tint high = array.length;\n    \twhile (low < high) {\n    \t\tfinal int mid = (low + high) / 2;\n\t\t\tif (value <= array[mid]) {\n\t\t\thigh = mid;\n\t\t\t} else {\n\t\t\t\tlow = mid + 1;\n\t\t\t}\n    \t}\n    \treturn low;\n\t}\n    \n    //Segment Tree\n    static class SegNode {\n    \t//SegNode contains all query variables\n    \tlong v;\n    \tSegNode() {\n    \t\t//Initialise using identity values\n    \t\tv = Integer.MIN_VALUE;\n    \t}\n    \t\n    \tSegNode(long v) {\n    \t\tthis.v = v;\n    \t}\n    \t\n    \tpublic void merge(SegNode l, SegNode r) {\n    \t\tthis.v = Math.max(l.v, r.v);\n    \t}\n    }\n    \n    static class SegUpdate {\n    \t//It contains only the updates not the query variables.\n    \tlong v; \n    \tSegUpdate() {\n    \t\t//Initialise all segupdate variables here with identity values\n    \t\t// 0 for sum\n    \t\t//Integer.MAX_VALUE for min operations\n    \t\t// 1 for product, etc.\n    \t\tthis.v = 0;\n    \t}\n    \t\n    \tSegUpdate(long v) {\n    \t\tthis.v = v;\n    \t}\n    \t\n    \t//Combine current update with other update.\n    \t//Other update is newer than my present update\n    \t//In case of non-lazy propagation leave this blank\n    \tpublic void combine(SegUpdate other, int tl, int tr) {\n    \t}\n    \t\n    \t//Apply all updates so far in the query variables inside SegNode\n    \t//In case of non-lazy updates, consider x to be a leaf node.\n    \tpublic void apply(SegNode x, int tl, int tr) {\n    \t\tx.v = v;\n    \t}\n    }\n    \n    static class SegTree {\n    \tint len;\n    \tSegNode[] t;\n    \tSegUpdate[] u;\n    \tboolean[] lazy;\n    \t\n    \tSegTree(int l){\n    \t\tlen = l;\n    \t\tt = new SegNode[4 * len];\n    \t\tfor(int i = 0; i < t.length; i++) t[i] = new SegNode();\n    \t\tu = new SegUpdate[4 * len];\n    \t\tfor(int i = 0; i < u.length; i++) u[i] = new SegUpdate();    \t\t\n    \t\tlazy = new boolean[4 * len];\n    \t}\n    \t\n    \tint descent(int x, int l) {\n    \t\treturn descent(1, 0, len - 1, x, l);\n    \t}\n    \t\n    \tint descent(int v, int tl, int tr, int x, int l) {\n    \t\tpn(x+\" \"+l);\n    \t\twhile(tl != l) {\n    \t\t\tpn(tl+\" \"+tr);\n    \t\t\tint tm = (tl + tr) >> 1;\n    \t\t\tif(l < tm) {\n    \t\t\t\ttr = tm - 1;\n    \t\t\t\tv = 2*v;\n    \t\t\t} else {\n    \t\t\t\ttl = tm;\n    \t\t\t\tv = 2*v + 1;\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tif(t[v].v < x) {\n    \t\t\treturn -1;\n    \t\t} \n    \t\t\n    \t\twhile(tl < tr) {\n    \t\t\tint tm = (tl + tr)/2;\n    \t\t\tif(t[2*v].v >= x) {\n    \t\t\t\ttr = tm;\n    \t\t\t\tv = 2*v;\n    \t\t\t} else {\n    \t\t\t\ttl = tm + 1;\n    \t\t\t\tv = 2*v + 1;\n    \t\t\t}\n    \t\t}\n\t\t\treturn tl;\n    \t}\n     \n    \tvoid pushdown(int v, int tl, int tr){\n    \t\tif(!lazy[v]) return;\n    \t\tint tm = (tl + tr) >> 1;\n    \t\tapply(v<<1, tl, tm, u[v]);\n    \t\tapply(v<<1|1, tm + 1, tr, u[v]);\n    \t\tu[v] = new SegUpdate();\n    \t\tlazy[v] = false;\n    \t}\n     \n    \tvoid apply(int v, int tl, int tr, SegUpdate upd){\n    \t\tif(tl != tr){\n    \t\t\tlazy[v] = true;\n    \t\t\tu[v].combine(upd, tl, tr);\n    \t\t}\n    \t\tupd.apply(t[v], tl, tr);\n    \t}\n    \t\n    \tprivate void build(int[] arr, int v, int tl, int tr){\n    \t\tif(tl == tr){\n    \t\t\tt[v] = new SegNode(arr[tl]);\n    \t\t\treturn;\n    \t\t}\n    \t\tint tm = (tl + tr) >> 1;\n    \t\tbuild(arr, v<<1, tl, tm);\n    \t\tbuild(arr, v<<1|1, tm + 1, tr);\n    \t\tt[v].merge(t[v<<1], t[v<<1|1]);\n    \t}\n     \n    \tprivate SegNode query(int v, int tl, int tr, int l, int r){\n    \t\tif(l > tr || r < tl){\n    \t\t\treturn new SegNode();\n    \t\t}\n    \t\tif(tl >= l && tr <= r){\n    \t\t\treturn t[v];\n    \t\t}\n    \t\tpushdown(v, tl, tr);\n    \t\tint tm = (tl + tr) >> 1;\n    \t\tSegNode a = query(v<<1,tl,tm,l,r),b = query(v<<1|1,tm+1,tr,l,r);\n    \t\tSegNode ans = new SegNode();\n    \t\tans.merge(a,b);\n    \t\treturn ans;\n    \t}\n     \n    \t// rupd = range update\n    \tprivate void rupd(int v, int tl, int tr, int l, int r, SegUpdate upd){\n    \t\tif(l > tr || r < tl){\n    \t\t\treturn;\n    \t\t}\n    \t\tif(tl >= l && tr <= r){\n    \t\t\tapply(v,tl,tr,upd);\n    \t\t\treturn;\n    \t\t}\n    \t\tpushdown(v,tl,tr);\n    \t\tint tm = (tl + tr) >> 1;\n    \t\trupd(v<<1,tl,tm,l,r,upd);\n    \t\trupd(v<<1|1,tm+1,tr,l,r,upd);\n    \t\tt[v].merge(t[v<<1], t[v<<1|1]);\n    \t}\n     \n    \tvoid build(int[] arr){\n    \t\tbuild(arr, 1, 0, len - 1);\n    \t}\n    \t\n    \tvoid build(long[] arr){\n    \t\tbuild(arr, 1, 0, len - 1);\n    \t}\n    \t\n    \tprivate void build(long[] arr, int v, int tl, int tr){\n    \t\tif(tl == tr){\n    \t\t\tt[v] = new SegNode(arr[tl]);\n    \t\t\treturn;\n    \t\t}\n    \t\tint tm = (tl + tr) >> 1;\n    \t\tbuild(arr, v<<1, tl, tm);\n    \t\tbuild(arr, v<<1|1, tm + 1, tr);\n    \t\tt[v].merge(t[v<<1], t[v<<1|1]);\n    \t}\n    \t\n    \tSegNode query(int l, int r){\n    \t\treturn query(1,0,len-1,l,r);\n    \t}\n    \t\n    \tvoid rupd(int l, int r, SegUpdate upd){\n    \t\trupd(1,0,len-1,l,r,upd);\n    \t}\n    \t\n    \tvoid debug() { \n    \t\tSystem.out.println(\"------Debug-----\");\n    \t\tfor(int i = 0; i < 4 * len; i++) {\n        \t\tSystem.out.print(t[i].v+\" \");\n        \t}\n    \t\t\n    \t\tfor(int i = 0; i < 4 * len; i++) {\n        \t\tSystem.out.print(u[i].v+\" \");\n        \t}\n    \t\t\n        \tSystem.out.println();\n        \tSystem.out.println(Arrays.toString(lazy));\n        \tSystem.out.println(\"-------------\");\n    \t}\n    }\n   \n    public static void pn(Object o) {\n      System.out.println(o);\n    }\n    \n    static class InputReader {\n \n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int snumChars;\n        private SpaceCharFilter filter;\n \n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n \n        public int snext() {\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) {\n                curChar = 0;\n                try {\n                    snumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n \n        public int nextInt() {\n            int c = snext();\n            while (isSpaceChar(c))\n                c = snext();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = snext();\n            }\n \n            int res = 0;\n \n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n \n            return res * sgn;\n        }\n        \n        public int ni() {\n        \treturn nextInt();\n        }\n \n        public long nextLong() {\n            int c = snext();\n            while (isSpaceChar(c))\n                c = snext();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = snext();\n            }\n \n            long res = 0;\n \n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n \n            return res * sgn;\n        }\n        \n        public long nl() {\n        \treturn nextLong();\n        }\n \n        public String readString() {\n            int c = snext();\n            while (isSpaceChar(c))\n                c = snext();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n \n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n \n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nvoid pv(T a, T b) {\n  for (T i = a; i != b; ++i) cout << *i << \" \";\n  cout << endl;\n}\nconst int maxn = 1e5 + 10;\nint n, k;\nchar A[2][maxn];\nqueue<pair<int, int> > q;\nvoid up(int c, int second) {\n  if (A[c][second] != 'X') A[c][second] = 'X', q.push(make_pair(c, second));\n}\nint main() {\n  cin >> n >> k >> A[0] >> A[1];\n  up(0, 0);\n  int qq = 1, pp = 0;\n  while (q.size()) {\n    pair<int, int> p = q.front();\n    q.pop();\n    if (--qq == 0) A[0][pp] = A[1][pp] = 'X';\n    if (p.second + k >= n) return cout << \"YES\", 0;\n    if (p.second + 1 <= n) up(p.first, p.second + 1);\n    if (p.second - 1 >= 0) up(p.first, p.second - 1);\n    up(p.first ^ 1, p.second + k);\n    if (qq == 0) qq = q.size(), pp++;\n  }\n  return cout << \"NO\", 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10;\nint n, k, w;\nchar a[2][N];\nint vis[2][N];\nint dfs(int pos, int j) {\n  if (j > n) {\n    return 1;\n  }\n  if (a[pos][j] == 'X' || j < w || vis[pos][j]) {\n    return 0;\n  }\n  vis[pos][j] = 1;\n  w++;\n  int f = dfs(pos, j - 1) || dfs(1 - pos, j + k) || dfs(pos, j + 1);\n  w--;\n  return f;\n}\nint main() {\n  while (~scanf(\"%d %d\", &n, &k)) {\n    w = 1;\n    scanf(\"%s %s\", a[0] + 1, a[1] + 1);\n    if (dfs(0, 1)) {\n      printf(\"YES\\n\");\n    } else {\n      printf(\"NO\\n\");\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:214721677\")\nusing namespace std;\ntemplate <class T>\nT sqr(T a) {\n  return (a) * (a);\n}\ntemplate <class T>\nT abs(T a) {\n  return (a < 0) ? -(a) : (a);\n}\nconst double Pi = acos(-1.0);\nconst double eps = 1e-10;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double phi = 0.5 + sqrt(1.25);\nint main() {\n  int n, k;\n  string s[2];\n  scanf(\"%d%d\\n\", &n, &k);\n  getline(cin, s[0]);\n  getline(cin, s[1]);\n  vector<int> a[2];\n  a[0].resize(n);\n  a[1].resize(n);\n  for (int i = 0, _n = (n)-1; i <= _n; ++i) {\n    a[0][i] = INF;\n    a[1][i] = INF;\n  }\n  a[0][0] = 0;\n  deque<pair<int, int> > q;\n  q.push_back(make_pair(0, 0));\n  while (!q.empty()) {\n    int x = q.front().first, y = q.front().second;\n    if (a[x][y] > y && a[x][y] < INF) {\n      q.pop_front();\n      continue;\n    }\n    if (y + 1 >= n || y + k >= n) {\n      printf(\"YES\\n\");\n      return 0;\n    }\n    if (s[x][y + 1] == '-')\n      if (a[x][y] + 1 < a[x][y + 1]) {\n        a[x][y + 1] = a[x][y] + 1;\n        q.push_back(make_pair(x, y + 1));\n      }\n    if (s[1 - x][y + k] == '-')\n      if (a[x][y] + 1 < a[1 - x][y + k]) {\n        a[1 - x][y + k] = a[x][y] + 1;\n        q.push_back(make_pair(1 - x, y + k));\n      }\n    if (y - 1 >= 0 && s[x][y - 1] == '-')\n      if (a[x][y] + 1 < a[x][y - 1]) {\n        a[x][y - 1] = a[x][y] + 1;\n        q.push_back(make_pair(x, y - 1));\n      }\n    q.pop_front();\n  }\n  printf(\"NO\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstring s[2];\nbool jumped[2][100021];\nint n, k, f;\nvoid dfs(int lor, int p, int t) {\n  if (s[lor][p] == 'X' || p <= t || jumped[lor][p]) return;\n  if (p > n - k) {\n    cout << \"YES\\n\";\n    exit(0);\n  }\n  jumped[lor][p] = 1;\n  dfs((lor + 1) % 2, p + k, t + 1);\n  dfs(lor, p + 1, t + 1);\n  dfs(lor, p - 1, t + 1);\n}\nint main() {\n  cin >> n >> k;\n  cin >> s[0] >> s[1];\n  n--;\n  dfs(0, 0, -1);\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.util.*;\nimport java.util.Scanner;\n\npublic class Main {\n\n    \n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        \n        int n = s.nextInt();\n        int k = s.nextInt();\n        char map[][] = new char[2][];\n        map[0] = s.next().toCharArray();\n        map[1] = s.next().toCharArray();\n        int done[][] = new int[2][map[0].length];\n        \n        Queue<Integer> q = new LinkedList<Integer>();\n        \n        int di[] = new int[]{0,0,1,-1};\n        int dj[] = new int[]{1,-1,k,k};\n        \n        q.add(0);\n        q.add(0);\n        q.add(-1);\n        \n        while(!q.isEmpty()){\n            int ii = q.poll();\n            int jj = q.poll();\n            int water = q.poll();\n            if(water >= jj)\n                continue;\n            \n            for (int i = 0; i < 4; i++) {\n                int nexti = ii+di[i];\n                int nextj = jj+dj[i];\n                \n                if(nexti==0||nexti==1){\n                    if(nextj>=n){\n\n//                      System.out.println(Arrays.toString(done[0]));\n//                      System.out.println(Arrays.toString(done[1]));\n                        System.out.println(\"YES\");\n                        return;\n                    }\n                    if(nextj>=0)\n                        if(map[nexti][nextj]=='-' && done[nexti][nextj]==0){\n                            q.add(nexti);\n                            q.add(nextj);\n                            q.add(water+1);\n                            done[nexti][nextj]=1;\n                        }\n                }\n            }\n            \n        }\n//      System.out.println(Arrays.toString(done[0]));\n//      System.out.println(Arrays.toString(done[1]));\n        System.out.println(\"NO\");\n    }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nqueue<int> q;\nchar c[2][100100];\nint d[200200];\nint n, m;\nint main() {\n  cin >> n >> m;\n  cin >> c[0] >> c[1];\n  memset(d, 0x3f, sizeof(d));\n  q.push(0);\n  d[0] = 0;\n  int res = INF;\n  while (!q.empty()) {\n    int t = q.front();\n    q.pop();\n    int side = t / n;\n    int pos = t % n;\n    if (pos + m >= n) {\n      res = d[t] + m;\n      break;\n    }\n    if (c[side][pos + 1] == '-' && d[side * n + pos + 1] == INF) {\n      d[side * n + pos + 1] = d[t] + 1;\n      q.push(side * n + pos + 1);\n    }\n    if (c[1 - side][pos + m] == '-' && d[(1 - side) * n + pos + m] == INF) {\n      d[(1 - side) * n + pos + m] = d[t] + 1;\n      q.push((1 - side) * n + pos + m);\n    }\n    if (c[side][pos - 1] == '-' && d[side * n + pos - 1] == INF && pos > 0 &&\n        pos - 1 >= d[t] + 1) {\n      d[side * n + pos - 1] = d[t] + 1;\n      q.push(side * n + pos - 1);\n    }\n  }\n  if (res == INF)\n    cout << \"NO\" << endl;\n  else\n    cout << \"YES\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1e9 + 7;\nint main() {\n  string a[2];\n  int n, k;\n  cin >> n >> k >> a[0] >> a[1];\n  int d[2][100010];\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 100010; j++) d[i][j] = 1e9;\n  queue<int> whi, high;\n  whi.push(0);\n  high.push(0);\n  d[0][0] = 0;\n  while (!whi.empty()) {\n    int x = whi.front(), y = high.front();\n    whi.pop();\n    high.pop();\n    if (d[x][y] > y) continue;\n    if (y + k >= n) {\n      puts(\"YES\");\n      return 0;\n    }\n    if ((a[x][y + 1] == '-') && (d[x][y + 1] == 1e9)) {\n      d[x][y + 1] = d[x][y] + 1;\n      whi.push(x);\n      high.push(y + 1);\n    }\n    if ((y > 0) && (a[x][y - 1] == '-') && (d[x][y - 1] == 1e9)) {\n      d[x][y - 1] = d[x][y] + 1;\n      whi.push(x);\n      high.push(y - 1);\n    }\n    if ((a[(x == 1) ? 0 : 1][y + k] == '-') &&\n        (d[(x == 1) ? 0 : 1][y + k] == 1e9)) {\n      d[(x == 1) ? 0 : 1][y + k] = d[x][y] + 1;\n      whi.push((x == 1) ? 0 : 1);\n      high.push(y + k);\n    }\n  }\n  puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace QoE_Library {\nnamespace QL_Bare_Minimum {\nconst double PI = 3.141592653589793238460;\nconst long double pi = 10000 * acos(-1.0L);\nconst long double E = 2.7182818284590452353;\nconst long double eps = 1e-10;\nconst int DX4[] = {0, 1, 0, -1};\nconst int DY4[] = {1, 0, -1, 0};\nconst int DX8[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nconst int DY8[] = {-1, 0, 1, -1, 1, -1, 0, 1};\nconst int neigh4[][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\nconst int neigh8[][2] = {{-1, 0}, {-1, -1}, {0, -1}, {1, -1},\n                         {1, 0},  {1, 1},   {0, 1},  {-1, 1}};\ntemplate <typename T1>\nclass Vector3D {\n public:\n  T1 x, y, z;\n  Vector3D(T1 x1, T1 y1, T1 z1) : x(x1), y(y1), z(z1) {}\n  Vector3D() {}\n};\ntemplate <typename T1>\ninline T1 to_type(string s) {\n  T1 a;\n  istringstream sin(s);\n  sin >> a;\n  return a;\n}\ntemplate <typename T1>\ninline string to_str(T1 a) {\n  ostringstream sout;\n  string s;\n  sout >> a;\n  return sout.str();\n}\ninline void inpS(char *a) { scanf(\"%s\", a); }\ninline int inpI() {\n  int n = 0;\n  int ch = getchar();\n  int sign = 1;\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') sign = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9')\n    n = (n << 3) + (n << 1) + ch - '0', ch = getchar();\n  n = n * sign;\n  return n;\n}\ninline void inpI2(int &a, int &b) {\n  a = inpI();\n  b = inpI();\n}\ninline void inpI3(int &a, int &b, int &c) {\n  a = inpI();\n  b = inpI();\n  c = inpI();\n}\ninline double inpD() {\n  double res = 0.0;\n  char c;\n  while (1) {\n    c = getchar();\n    if (c == ' ' || c == '\\n')\n      continue;\n    else\n      break;\n  }\n  res = c - '0';\n  while (1) {\n    c = getchar();\n    if (c >= '0' && c <= '9')\n      res = 10 * res + c - '0';\n    else\n      break;\n  }\n  if (c == '.') {\n    double decimal = 0.0, divi = 1.0;\n    while (1) {\n      c = getchar();\n      if (c >= '0' && c <= '9')\n        decimal += (c - '0') / (divi *= 10.0);\n      else\n        break;\n    }\n    res += decimal;\n  }\n  return res;\n}\ninline void outpD(double N) {\n  char buff[24], sz = 0;\n  int integer = N;\n  int decimal = (N - integer) * 10000000;\n  int tmp = decimal;\n  while (decimal) {\n    buff[sz++] = '0' + decimal % 10;\n    decimal /= 10;\n  }\n  for (int decimal2 = 1000000; decimal2 > tmp; decimal2 /= 10) {\n    buff[sz++] = '0';\n  }\n  buff[sz++] = '.';\n  if (integer == 0) buff[sz++] = '0';\n  while (integer) {\n    buff[sz++] = '0' + integer % 10;\n    integer /= 10;\n  }\n  while (--sz >= 0) putchar(buff[sz]);\n  putchar(10);\n}\ninline void outpI(int a) {\n  char c;\n  char snum[20];\n  int i = 0;\n  int sign = 0;\n  if (a < 0) sign = 1;\n  a = abs(a);\n  do {\n    snum[i++] = a % 10 + 48;\n    a = a / 10;\n  } while (a != 0);\n  i = i - 1;\n  if (sign) putchar('-');\n  while (i >= 0) putchar(snum[i--]);\n  putchar('\\n');\n}\ninline void outpI2(int a, int b) {\n  printf(\"%d \", a);\n  outpI(b);\n}\ninline int outpS(char *s) { return printf(\"%s\\n\", s); }\ntemplate <typename T1>\nvoid QL_swap(T1 &x, T1 &y) {\n  T1 tmp;\n  tmp = x;\n  x = y;\n  y = tmp;\n}\ntemplate <typename T1>\nT1 gcd(T1 a, T1 b) {\n  if (!b) return a;\n  return gcd(b, a % b);\n}\nlong long int euclideanDistSq(long long int x1, long long int y1,\n                              long long int x2, long long int y2) {\n  return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n}\ntemplate <typename T1>\nT1 dotProd(T1 x1, T1 y1, T1 z1, T1 x2, T1 y2, T1 z2) {\n  return x1 * x2 + y1 * y2 + z1 * z2;\n}\ntemplate <typename T1>\nVector3D<T1> crossProd(Vector3D<T1> v1, Vector3D<T1> v2) {\n  Vector3D<T1> v;\n  v.x = v1.y * v2.z - v2.y * v1.z;\n  v.y = v1.z * v2.x - v2.z * v1.x;\n  v.z = v1.x * v2.y - v2.x * v1.y;\n  return v;\n}\n}  // namespace QL_Bare_Minimum\n}  // namespace QoE_Library\nusing namespace QoE_Library::QL_Bare_Minimum;\nint status[400005];\nvector<int> g[400005];\nint pred[400005];\nlong long int d[400005];\nlong long int len[400005];\nlong long int n, k, a, b, c;\nqueue<int> q;\nint bfs(int u) {\n  status[u] = 1;\n  len[u] = 0;\n  q.push(u);\n  while (!q.empty()) {\n    int v = q.front();\n    q.pop();\n    for (int i = (0); i < (g[v].size()); i = i + (1)) {\n      int temp = g[v][i];\n      if (status[temp]) continue;\n      status[temp] = 1;\n      q.push(temp);\n      pred[temp] = v;\n      len[temp] = 1 + len[v];\n    }\n  }\n  return 0;\n}\nint main() {\n  int te;\n  te = 1;\n  while (te--) {\n    string l[2];\n    cin >> n >> k;\n    cin >> l[0] >> l[1];\n    int m = n + k;\n    for (int j = (0); j < (2); j = j + (1)) {\n      for (int i = (0); i < (n); i = i + (1)) {\n        if (5 == i) int d = 0;\n        if (l[j][i] == '-') {\n          if (j * m + i + 1 <= j * m + n &&\n              (j * m + i + 1 == j * m + n || l[j][i + 1] == '-')) {\n            g[j * m + i + 1].push_back(j * m + i);\n            ;\n            g[j * m + i].push_back(j * m + i + 1);\n            ;\n          }\n          if (j * m + i < m + j * m && (i + k >= n || l[1 - j][i + k] == '-')) {\n            g[j * m + i].push_back((1 - j) * m + i + k);\n            ;\n          }\n        }\n      }\n    }\n    fill(status, status + 2 * m, 0);\n    fill(d, d + 2 * m, LLONG_MAX / 10);\n    fill(pred, pred + 2 * m, -1);\n    fill(len, len + 2 * m, LLONG_MAX / 10);\n    bfs(0);\n    bool f = 0;\n    for (int j = (0); j < (2); j = j + (1)) {\n      f = 0;\n      for (int i = (j * m + n); i < (j * m + n + k); i = i + (1)) {\n        f = 1;\n        int c = 0;\n        int p = i;\n        if (i == 15) int d = 0;\n        while (0 != p && -1 != p) {\n          ++c;\n          if (i == 7 && p == 9) int d = 0;\n          if (len[p] > p % m) {\n            f = 0;\n            break;\n          }\n          p = pred[p];\n        }\n        if (!f) continue;\n        if (-1 == p) continue;\n        if (f) break;\n      }\n      if (f) break;\n    }\n    cout << (f ? \"YES\" : \"NO\") << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e6;\nint dis[3][MAXN], n, k;\nstring s[3];\nbool mark[3][MAXN];\nvector<pair<int, int> > vec[3][MAXN];\nqueue<pair<int, int> > q;\nint main() {\n  cin >> n >> k;\n  cin >> s[1] >> s[2];\n  for (int i = 1; i < 3; i++)\n    for (int j = 0; j < s[i].size(); j++) {\n      if (j + 1 < s[i].size() && s[i][j + 1] == '-')\n        vec[i][j].push_back(make_pair(i, j + 1));\n      if (j - 1 >= 0 && s[i][j - 1] == '-')\n        vec[i][j].push_back(make_pair(i, j - 1));\n      if (j + k < s[i].size() && s[3 - i][j + k] == '-')\n        vec[i][j].push_back(make_pair(3 - i, j + k));\n    }\n  q.push({1, 0});\n  mark[1][0] = 1;\n  while (q.size() > 0) {\n    int v1 = q.front().first, v2 = q.front().second, water = dis[v1][v2];\n    for (int i = 0; i < vec[v1][v2].size(); i++) {\n      if (mark[vec[v1][v2][i].first][vec[v1][v2][i].second] == 0 &&\n          vec[v1][v2][i].second > water) {\n        mark[vec[v1][v2][i].first][vec[v1][v2][i].second] = 1;\n        q.push({vec[v1][v2][i].first, vec[v1][v2][i].second});\n        dis[vec[v1][v2][i].first][vec[v1][v2][i].second] = dis[v1][v2] + 1;\n      }\n    }\n    q.pop();\n  }\n  for (int i = n - k; i < n; i++)\n    if (mark[1][i] == 1 || mark[2][i] == 1) {\n      cout << \"YES\";\n      return 0;\n    }\n  cout << \"NO\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nchar a[2][100010];\nint mark[2][100010];\nstruct item {\n  int i;\n  int h;\n  int depth;\n};\nqueue<struct item> q;\ninline int isok(int i, int h, int depth) {\n  if (h >= 1 && h <= n && a[i][h - 1] == '-' && depth < h && !mark[i][h - 1])\n    return 1;\n  else\n    return 0;\n}\nvoid bfs() {\n  while (!q.empty()) {\n    struct item tmp = q.front();\n    q.pop();\n    int depth = tmp.depth;\n    int h = tmp.h;\n    int i = tmp.i;\n    if (depth < h && a[i][h - 1] == '-' && h >= n - k + 1) {\n      cout << \"YES\" << endl;\n      return;\n    }\n    if (isok(i, h + 1, depth + 1)) {\n      struct item t;\n      t.depth = depth + 1;\n      t.h = h + 1;\n      t.i = i;\n      q.push(t);\n      mark[i][h] = 1;\n    }\n    if (isok(i, h - 1, depth + 1)) {\n      struct item t;\n      t.depth = depth + 1;\n      t.h = h - 1;\n      t.i = i;\n      q.push(t);\n      mark[i][h - 2] = 0;\n    }\n    if (isok((i + 1) % 2, h + k, depth + 1)) {\n      struct item t;\n      t.depth = depth + 1;\n      t.h = h + k;\n      t.i = (i + 1) % 2;\n      q.push(t);\n      mark[(i + 1) % 2][h + k - 1] = 1;\n    }\n  }\n  cout << \"NO\" << endl;\n  return;\n}\nint main() {\n  cin >> n >> k;\n  scanf(\"%s\", a[0]);\n  scanf(\"%s\", a[1]);\n  struct item t;\n  t.depth = 0;\n  t.h = 1;\n  t.i = 0;\n  mark[0][0] = 1;\n  q.push(t);\n  bfs();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar x[3][200000 + 5];\nlong n, m;\nlong c[2 * 200000 + 5];\nbool b[3][200000 + 5];\nqueue<long> q;\nint main() {\n  long i, j, k, t;\n  scanf(\"%ld%ld\\n\", &n, &m);\n  for (i = (1); i <= (n); ++i) {\n    scanf(\"%c\", &x[1][i]);\n    if (x[1][i] == 'X') b[1][i] = true;\n  }\n  scanf(\"\\n\");\n  for (i = (1); i <= (n); ++i) {\n    scanf(\"%c\", &x[2][i]);\n    if (x[2][i] == 'X') b[2][i] = true;\n  }\n  q.push(1);\n  b[1][1] = true;\n  b[1][0] = true;\n  b[2][0] = true;\n  while (!q.empty()) {\n    i = q.front();\n    q.pop();\n    if (i <= n) {\n      if (i <= c[i]) continue;\n      if (!b[1][i + 1]) {\n        b[1][i + 1] = true;\n        q.push(i + 1);\n        c[i + 1] = c[i] + 1;\n        if (i + 1 > n) {\n          printf(\"YES\");\n          return 0;\n        }\n      }\n      if (!b[1][i - 1]) {\n        b[1][i - 1] = true;\n        q.push(i - 1);\n        c[i - 1] = c[i] + 1;\n      }\n      if (!b[2][i + m]) {\n        b[2][i + m] = true;\n        q.push(i + m + n);\n        c[i + m + n] = c[i] + 1;\n        if (i + m > n) {\n          printf(\"YES\");\n          return 0;\n        }\n      }\n    } else {\n      j = i;\n      i -= n;\n      if (i <= c[j]) continue;\n      if (!b[2][i + 1]) {\n        b[2][i + 1] = true;\n        q.push(j + 1);\n        c[j + 1] = c[j] + 1;\n        if (i + 1 > n) {\n          printf(\"YES\");\n          return 0;\n        }\n      }\n      if (!b[2][i - 1]) {\n        b[2][i - 1] = true;\n        q.push(j - 1);\n        c[j - 1] = c[j] + 1;\n      }\n      if (!b[1][i + m]) {\n        b[1][i + m] = true;\n        q.push(i + m);\n        c[i + m] = c[j] + 1;\n        if (i + m > n) {\n          printf(\"YES\");\n          return 0;\n        }\n      }\n    }\n  }\n  printf(\"NO\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long maxn = 2e5 + 10;\nconst long long inf = 3e18;\nconst long long mod = 1e9 + 7;\nlong long a[maxn][3], n, ans, k;\nstring s;\nmap<pair<long long, long long>, vector<pair<long long, long long> > > adj;\nmap<pair<long long, long long>, long long> dis;\nqueue<pair<long long, long long> > q;\ninline bool check(long long x, long long y, long long d) {\n  if (x >= 0 && x < n && a[x][y] == 0 && dis[{x, y}] > d && d <= x) {\n    dis[{x, y}] = d;\n    return 1;\n  }\n  return 0;\n}\ninline void connect(long long x, long long y) {\n  if (a[x][y] == 1) return;\n  if (check(x + 1, y, dis[{x, y}] + 1)) q.push({x + 1, y});\n  if (check(x - 1, y, dis[{x, y}] + 1)) q.push({x - 1, y});\n  if (check(x + k, 3 - y, dis[{x, y}] + 1)) q.push({x + k, 3 - y});\n  if (check(x - k, 3 - y, dis[{x, y}] + 1)) q.push({x - k, 3 - y});\n  return;\n}\nint main() {\n  cin >> n >> k;\n  cin >> s;\n  for (int i = 0; i < n; i++) {\n    if (s[i] == '-')\n      a[i][1] = 0;\n    else\n      a[i][1] = 1;\n  }\n  cin >> s;\n  for (int i = 0; i < n; i++) {\n    if (s[i] == '-')\n      a[i][2] = 0;\n    else\n      a[i][2] = 1;\n  }\n  if (a[0][1] == 1) {\n    cout << \"NO\" << endl;\n    return 0;\n  }\n  for (int i = 0; i < n + k + 10; i++) {\n    dis[{i, 1}] = dis[{i, 2}] = inf;\n  }\n  q.push({0, 1});\n  dis[{0, 1}] = 0;\n  while (!q.empty()) {\n    pair<long long, long long> fr = q.front();\n    q.pop();\n    connect(fr.first, fr.second);\n  }\n  for (int i = n; i + k >= n; i--) {\n    if (dis[{i, 1}] <= i || dis[{i, 2}] <= i) {\n      cout << \"YES\" << endl;\n      return 0;\n    }\n  }\n  cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.LinkedList;\nimport java.util.StringTokenizer;\n\npublic class JumpingOnWalls {\n\n\tprivate static boolean flag = false;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(in.readLine());\n\t\tint n, k;\n\t\tString tmp1, tmp2;\n\t\tn = Integer.parseInt(st.nextToken());\n\t\tk = Integer.parseInt(st.nextToken());\n\t\tchar[][] walls = new char[2][n];\n\t\ttmp1 = in.readLine();\n\t\ttmp2 = in.readLine();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\twalls[0][i] = tmp1.charAt(i);\n\t\t\twalls[1][i] = tmp2.charAt(i);\n\t\t}\n\t\tif (BFS(walls, k)) System.out.println(\"YES\");\n\t\telse System.out.println(\"NO\");\n\t}\n\n\tpublic static boolean BFS (char[][] walls, int k) {\n\t\tint[] pos = {0, 0, -1};\n\t\tboolean[][] visited = new boolean[walls.length][walls[0].length];\n\t\tLinkedList<int[]> q = new LinkedList<>();\n\t\tq.add(pos);\n\t\tint x, y;\n\t\twhile (!q.isEmpty()) {\n\t\t\tpos = q.removeFirst();\n\t\t\tif (!visited[pos[0]][pos[1]]) {\n\t\t\t\tvisited[pos[0]][pos[1]] = true;\n\t\t\t\tx = pos[0]; y = pos[1] + 1; // check above\n\t\t\t\tif (y >= walls[0].length) return true;\n\t\t\t\tif (bounds(walls, x, y) && !visited[x][y] && walls[x][y] != 'X' && y > pos[2] + 1) {\n\t\t\t\t\tq.add(new int[]{x, y, pos[2] + 1});\n\t\t\t\t}\n\n\t\t\t\ty = pos[1] - 1; // check below\n\t\t\t\tif (y >= walls[0].length) return true;\n\t\t\t\tif (bounds(walls, x, y) && !visited[x][y] && walls[x][y] != 'X' && y > pos[2] + 1) {\n\t\t\t\t\tq.add(new int[]{x, y, pos[2] + 1});\n\t\t\t\t}\n\n\t\t\t\tx = 1 - pos[0]; // check jump\n\t\t\t\ty = pos[1] + k;\n\t\t\t\tif (y >= walls[0].length) return true;\n\t\t\t\tif (bounds(walls, x, y) && !visited[x][y] && walls[x][y] != 'X' && y > pos[2] + 1) {\n\t\t\t\t\tq.add(new int[]{x, y, pos[2] + 1});\n\t\t\t\t}\n\t\t\t\t//System.out.println(pos[0] + \" : \" + pos[1] + \" : \" + pos[2] + \" : \" + q.size());\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static boolean bounds(char[][] walls, int x, int y) {\n\t\treturn x < walls.length && y < walls[0].length && x >= 0 && y >= 0;\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int n, k;\nstring s;\nbool a[100005], b[100005];\nvector<long long int> adj[200005];\nlong long int dist[200005];\nset<pair<long long int, long long int>> d;\nlong long int v(long long int x) { return (x > n ? x - n : x); }\nvoid func() {\n  dist[1] = 0;\n  d.insert(make_pair(0, 1));\n  while (!d.empty()) {\n    long long int i = d.begin()->second;\n    long long int j = d.begin()->first;\n    d.erase(d.begin());\n    if (j < v(i)) {\n      for (auto x : adj[i]) {\n        if (dist[x] >= j + 1) {\n          dist[x] = j + 1;\n          d.insert(make_pair(dist[x], x));\n        }\n      }\n    }\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> k;\n  cin >> s;\n  a[0] = 1;\n  b[0] = 1;\n  a[n + 1] = 1;\n  b[n + 1] = 1;\n  for (int i = 1; i <= n; i++)\n    if (s[i - 1] == 'X') a[i] = 1;\n  cin >> s;\n  for (int i = 1; i <= n; i++)\n    if (s[i - 1] == 'X') b[i] = 1;\n  for (int i = 1; i <= n; i++) {\n    if (!a[i]) {\n      if (!a[i + 1]) adj[i].push_back(i + 1);\n      if (!a[i - 1]) adj[i].push_back(i - 1);\n      if (i + k <= n) {\n        if (!b[i + k]) {\n          adj[i].push_back(i + k + n);\n        }\n      } else\n        adj[i].push_back(2 * n + 1);\n    }\n    if (!b[i]) {\n      if (!b[i + 1]) adj[i + n].push_back(i + 1 + n);\n      if (!b[i - 1]) adj[i + n].push_back(i - 1 + n);\n      if (i + k <= n) {\n        if (!a[i + k]) {\n          adj[i + n].push_back(i + k);\n        }\n      } else\n        adj[i + n].push_back(2 * n + 1);\n    }\n  }\n  for (int i = 1; i <= 2 * n + 1; i++) dist[i] = 1e18;\n  func();\n  if (dist[2 * n + 1] != 1e18)\n    printf(\"YES\\n\");\n  else\n    printf(\"NO\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tstatic int[][][] deltas ;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine().trim());\n\t\tint N = Integer.parseInt(st.nextToken());\n\t\tint K = Integer.parseInt(st.nextToken());\n\t\tchar[][] board = new char[2][N];\n\t\tboolean[][] visited = new boolean[2][N];\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tboard[i] = br.readLine().trim().toCharArray();\n\t\t}\n\n\t\tdeltas = new int[][][] {{{0, 1}, {0, -1}, {1, K}},\n\t\t\t\t\t\t\t{{0, 1}, {0, -1}, {-1, K}}};\n\n\n\t\tArrayList<Point> cur = new ArrayList<Point>();\n\t\tcur.add(new Point(0,0 ));\n\t\tvisited[0][0] = true;\n\n\t\tArrayList<Point> next = new ArrayList<Point>();\n\t\n\t\tint t = 0;\n\n\t\tboolean found = false;\n\n\t\tloop:\n\t\twhile (cur.size() > 0) {\n\t\t\tfor (Point p : cur) {\n\t\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\t\tint newW = p.w + deltas[p.w][i][0];\n\t\t\t\t\tint newH = p.h + deltas[p.w][i][1];\n\t\t\t\t\tif (newH <= t) continue;\n\t\t\t\t\tif (newH >= N) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tif (visited[newW][newH] || board[newW][newH] == 'X') continue;\n\t\t\t\t\tvisited[newW][newH] = true;\n\t\t\t\t\tnext.add(new Point(newH, newW));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.clear();\n\t\t\tArrayList<Point> temp = cur;\n\t\t\tcur = next;\n\t\t\tnext = temp;\n\t\t\tt++;\n\t\t}\n\t\tSystem.out.println(found ? \"YES\" : \"NO\");\n\t}\n\n\tstatic class Point {\n\t\tint h, w;\n\t\tPoint(int h, int w) {\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + w + \", \" + h + \")\";\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nstring s[2];\nbool vis[2][100010];\nvoid dfs(int hi, int whi, int wa) {\n  if (hi <= wa) return;\n  if (vis[whi][hi]) return;\n  vis[whi][hi] = true;\n  if (hi >= n) {\n    puts(\"YES\");\n    exit(0);\n  }\n  if (s[whi ^ 1][hi + k] != 'X') dfs(hi + k, whi ^ 1, wa + 1);\n  if (hi > 0 && s[whi][hi - 1] != 'X') dfs(hi - 1, whi, wa + 1);\n  if (s[whi][hi + 1] != 'X') dfs(hi + 1, whi, wa + 1);\n}\nint main() {\n  cin >> n >> k >> s[0] >> s[1];\n  for (int i = 0; i <= 100010; i++) s[0].push_back('-'), s[1].push_back('-');\n  dfs(0, 0, -1);\n  puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n/**\n * 4 4\n * 1 5 3 4\n * 1 2\n * 1 3\n * 2 3\n * 3 3\n *\n *\n * @author pttrung\n */\npublic class A {\n\n    public static long Mod = (long) (1e9);\n    public static int[][][] dp;\n\n    public static void main(String[] args) throws FileNotFoundException {\n\n        PrintWriter out = new PrintWriter(System.out);\n        Scanner in = new Scanner();\n        int n = in.nextInt();\n        int k = in.nextInt();\n        boolean[][] map = new boolean[2][n];\n        for (int i = 0; i < 2; i++) {\n            String v = in.next();\n            for (int j = 0; j < n; j++) {\n                map[i][j] = v.charAt(j) != 'X';\n            }\n        }\n        int[][] dist = new int[2][n];\n        for (int[] a : dist) {\n            Arrays.fill(a, -1);\n        }\n        dist[0][0] = 0;\n        PriorityQueue<Entry> q = new PriorityQueue();\n        q.add(new Entry(0, 0, 0));\n        boolean ok = false;\n        while (!q.isEmpty()) {\n            Entry e = q.poll();\n           // System.out.println(e.x + \" \" + e.y + \" \" + e.c + \" \" + dist[e.x][e.y]);\n            if (dist[e.x][e.y] == e.c) {\n                \n                if (e.y + 1 == n) {\n                    ok = true;\n                    break;\n                } else {\n                    if (map[e.x][e.y + 1] && (dist[e.x][e.y + 1] == -1 || dist[e.x][e.y + 1] > dist[e.x][e.y] + 1) && dist[e.x][e.y] + 1 <= e.y + 1) {\n                        dist[e.x][e.y + 1] = dist[e.x][e.y] + 1;\n                        q.add(new Entry(e.x, e.y + 1, dist[e.x][e.y + 1]));\n                    }\n                }\n                if (e.y > 0) {\n                    if (map[e.x][e.y - 1] && (dist[e.x][e.y - 1] == -1 || dist[e.x][e.y - 1] > dist[e.x][e.y] + 1) && dist[e.x][e.y] + 1 <= e.y - 1) {\n                        dist[e.x][e.y - 1] = dist[e.x][e.y] + 1;\n                        q.add(new Entry(e.x, e.y - 1, dist[e.x][e.y - 1]));\n                    }\n                }\n                if (e.y + k >= n) {\n                    ok = true;\n                    break;\n                } else {\n                    if (map[1 - e.x][e.y + k] && (dist[1 - e.x][e.y + k] == -1 || dist[1 - e.x][e.y + k] > dist[e.x][e.y] + 1) && dist[e.x][e.y] + 1 <= e.y + k) {\n                        dist[1 - e.x][e.y + k] = dist[e.x][e.y] + 1;\n                        q.add(new Entry(1 - e.x, e.y + k, dist[1- e.x][e.y + k]));\n                    }\n                }\n\n            }\n        }\n        if(ok){\n            out.println(\"YES\");\n        }else{\n            out.println(\"NO\");\n        }\n\n\n        out.close();\n    }\n\n    static class Entry implements Comparable<Entry> {\n\n        int x, y, c;\n\n        public Entry(int x, int y, int c) {\n            this.x = x;\n            this.y = y;\n            this.c = c;\n        }\n\n        @Override\n        public int compareTo(Entry o) {\n            return c - o.c;\n        }\n    }\n\n    static int find(int index, int[] u) {\n        if (index != u[index]) {\n            return u[index] = find(u[index], u);\n        }\n        return index;\n    }\n\n    public static long pow(int a, int b, long mod) {\n        if (b == 0) {\n            return 1;\n        }\n        if (b == 1) {\n            return a;\n        }\n        long v = pow(a, b / 2, mod);\n        if (b % 2 == 0) {\n            return (v * v) % mod;\n        } else {\n            return (((v * v) % mod) * a) % mod;\n        }\n    }\n\n    public static int[][] powSquareMatrix(int[][] A, long p) {\n        int[][] unit = new int[A.length][A.length];\n        for (int i = 0; i < unit.length; i++) {\n            unit[i][i] = 1;\n        }\n        if (p == 0) {\n            return unit;\n        }\n        int[][] val = powSquareMatrix(A, p / 2);\n        if (p % 2 == 0) {\n            return mulMatrix(val, val);\n        } else {\n            return mulMatrix(A, mulMatrix(val, val));\n        }\n\n    }\n\n    public static int[][] mulMatrix(int[][] A, int[][] B) {\n        int[][] result = new int[A.length][B[0].length];\n        for (int i = 0; i < result.length; i++) {\n            for (int j = 0; j < result[0].length; j++) {\n                long temp = 0;\n                for (int k = 0; k < A[0].length; k++) {\n\n                    temp += ((long) A[i][k] * B[k][j] % Mod);\n                    temp %= Mod;\n                }\n                temp %= Mod;\n                result[i][j] = (int) temp;\n            }\n        }\n\n        return result;\n    }\n\n    public static boolean nextPer(int[] data) {\n        int i = data.length - 1;\n        while (i > 0 && data[i] < data[i - 1]) {\n            i--;\n        }\n        if (i == 0) {\n            return false;\n        }\n        int j = data.length - 1;\n        while (data[j] < data[i - 1]) {\n            j--;\n        }\n        int temp = data[i - 1];\n        data[i - 1] = data[j];\n        data[j] = temp;\n        Arrays.sort(data, i, data.length);\n        return true;\n\n\n\n\n    }\n\n    static class FT {\n\n        int[] data;\n\n        FT(int n) {\n            data = new int[n];\n        }\n\n        void update(int index, int val) {\n            // System.out.println(\"UPDATE INDEX \" + index);\n            while (index < data.length) {\n                data[index] += val;\n                index += index & (-index);\n\n                //    System.out.println(\"NEXT \" +index);\n            }\n        }\n\n        int get(int index) {\n            //  System.out.println(\"GET INDEX \" + index);\n            int result = 0;\n            while (index > 0) {\n                result += data[index];\n                index -= index & (-index);\n                // System.out.println(\"BACK \" + index);\n            }\n            return result;\n        }\n    }\n\n    static long gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        } else {\n            return gcd(b, a % b);\n        }\n    }\n\n    static long pow(long a, int b) {\n        if (b == 0) {\n            return 1;\n        }\n        if (b == 1) {\n            return a;\n        }\n        long val = pow(a, b / 2);\n        if (b % 2 == 0) {\n\n            return val * val % Mod;\n        } else {\n            return (val * val % Mod) * a % Mod;\n        }\n    }\n\n//    static Point intersect(Point a, Point b, Point c) {\n//        double D = cross(a, b);\n//        if (D != 0) {\n//            return new Point(cross(c, b) / D, cross(a, c) / D);\n//        }\n//        return null;\n//    }\n//\n//    static Point convert(Point a, double angle) {\n//        double x = a.x * cos(angle) - a.y * sin(angle);\n//        double y = a.x * sin(angle) + a.y * cos(angle);\n//        return new Point(x, y);\n//    }\n    static Point minus(Point a, Point b) {\n        return new Point(a.x - b.x, a.y - b.y);\n    }\n//\n//    static Point add(Point a, Point b) {\n//        return new Point(a.x + b.x, a.y + b.y);\n//    }\n//\n\n    /**\n     * Cross product ab*ac\n     *\n     * @param a\n     * @param b\n     * @param c\n     * @return\n     */\n    static double cross(Point a, Point b, Point c) {\n        Point ab = new Point(b.x - a.x, b.y - a.y);\n        Point ac = new Point(c.x - a.x, c.y - a.y);\n        return cross(ab, ac);\n    }\n\n    static double cross(Point a, Point b) {\n        return a.x * b.y - a.y * b.x;\n    }\n\n    /**\n     * Dot product ab*ac;\n     *\n     * @param a\n     * @param b\n     * @param c\n     * @return\n     */\n    static long dot(Point a, Point b, Point c) {\n        Point ab = new Point(b.x - a.x, b.y - a.y);\n        Point ac = new Point(c.x - a.x, c.y - a.y);\n        return dot(ab, ac);\n    }\n\n    static long dot(Point a, Point b) {\n        long total = a.x * b.x;\n        total += a.y * b.y;\n        return total;\n    }\n\n    static double dist(Point a, Point b) {\n        long total = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n        return Math.sqrt(total);\n    }\n\n    static long norm(Point a) {\n        long result = a.x * a.x;\n        result += a.y * a.y;\n        return result;\n    }\n\n    static double dist(Point a, Point b, Point x, boolean isSegment) {\n        double dist = cross(a, b, x) / dist(a, b);\n        // System.out.println(\"DIST \" + dist);\n\n        if (isSegment) {\n            Point ab = new Point(b.x - a.x, b.y - a.y);\n\n            long dot1 = dot(a, b, x);\n            long norm = norm(ab);\n            double u = (double) dot1 / norm;\n            if (u < 0) {\n                return dist(a, x);\n            }\n\n            if (u > 1) {\n                return dist(b, x);\n            }\n        }\n        return Math.abs(dist);\n\n\n\n\n    }\n\n    static long squareDist(Point a, Point b) {\n        long x = a.x - b.x;\n        long y = a.y - b.y;\n        return x * x + y * y;\n    }\n\n    static class Point {\n\n        int x, y;\n\n        public Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public String toString() {\n            return \"Point{\" + \"x=\" + x + \", y=\" + y + '}';\n        }\n    }\n\n    static class Scanner {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public Scanner() throws FileNotFoundException {\n            //System.setOut(new PrintStream(new BufferedOutputStream(System.out), true));\n            br = new BufferedReader(new InputStreamReader(System.in));\n            //br = new BufferedReader(new FileReader(new File(\"A-large (2).in\")));\n        }\n\n        public String next() {\n\n\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (Exception e) {\n                    throw new RuntimeException();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            st = null;\n            try {\n                return br.readLine();\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n\n        public boolean endLine() {\n            try {\n                String next = br.readLine();\n                while (next != null && next.trim().isEmpty()) {\n                    next = br.readLine();\n                }\n                if (next == null) {\n                    return true;\n                }\n                st = new StringTokenizer(next);\n                return st.hasMoreTokens();\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, i, j;\nstring mp[2];\nint used[100005][2];\nvoid dfs(int x, int y, int step) {\n  if (x >= n) {\n    cout << \"YES\";\n    exit(0);\n  }\n  if (x < step) return;\n  if (used[x][y] != -1 && used[x][y] <= step) return;\n  used[x][y] = step;\n  if (mp[!y][x + m] != 'X') dfs(x + m, !y, step + 1);\n  if (mp[y][x + 1] != 'X') dfs(x + 1, y, step + 1);\n  if (x > 0 && mp[y][x - 1] != 'X') dfs(x - 1, y, step + 1);\n}\nint main() {\n  memset(used, -1, sizeof(used));\n  ios::sync_with_stdio(0);\n  cin >> n >> m;\n  cin >> mp[0] >> mp[1];\n  for (i = 1; i <= m; i++) {\n    mp[0] += \"-\";\n    mp[1] += \"-\";\n  }\n  dfs(0, 0, 0);\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.util.*;\n\n\npublic class D\n{\n\tBufferedReader in;\n\tPrintStream out;\n\tStringTokenizer tok;\n\tpublic D() throws NumberFormatException, IOException\n\t{\n\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t//in = new BufferedReader(new FileReader(\"in.txt\"));\n\t\tout = System.out;\n\t\trun();\n\t}\n\tint opWall(int wall)\n\t{\n\t\tif(wall==0) return 1;\n\t\telse return 0;\n\t}\n\tchar[][] wall;\n\tboolean[][] mark;\n\tint n,k;\n\tvoid run() throws NumberFormatException, IOException\n\t{\n\t\tn = nextInt();\n\t\tk = nextInt();\n\t\twall = new char[2][n];\n\t\tmark = new boolean[2][n];\n\t\twall[0] = nextToken().toCharArray();\n\t\twall[1] = nextToken().toCharArray();\n\t\tif(BFS())out.println(\"YES\");\n\t\telse out.println(\"NO\");\n\t}\n\tclass State\n\t{\n\t\tint area, wall,level;\n\t\tpublic State(int a, int w, int l)\n\t\t{\n\t\t\tarea = a;\n\t\t\twall = w;\n\t\t\tlevel = l;\n\t\t}\n\t}\n\tboolean BFS()\n\t{\n\t\tQueue<State> q = new LinkedList<State>();\n\t\tq.add(new State(1,0,0));\n\t\tmark[0][0] = true;\n\t\twhile(q.size()>0)\n\t\t{\n\t\t\tState s = q.poll();\n\t\t\tif(s.area+k>n) \n\t\t\t\treturn true;\n\t\t\tif(!mark[opWall(s.wall)][s.area+k-1] && wall[opWall(s.wall)][s.area+k-1]!= 'X')\n\t\t\t{\n\t\t\t\tq.add(new State(s.area + k,opWall(s.wall),s.level+1));\n\t\t\t\tmark[opWall(s.wall)][s.area + k-1] = true;\n\t\t\t}\n\t\t\tif(!mark[s.wall][s.area+1-1] && wall[s.wall][s.area+1-1]!= 'X')\n\t\t\t{\n\t\t\t\tq.add(new State(s.area + 1,s.wall,s.level+1));\n\t\t\t\tmark[s.wall][s.area + 1-1] = true;\n\t\t\t}\n\t\t\tif(s.area-1 > s.level+1 && !mark[s.wall][s.area-2] && wall[s.wall][s.area-2]!= 'X')\n\t\t\t{\n\t\t\t\tq.add(new State(s.area-1,s.wall,s.level+1));\n\t\t\t\tmark[s.wall][s.area-2] = true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tpublic static void main(String[] args) throws NumberFormatException, IOException \n\t{\n\t\tnew D();\n\t}\n\tString nextToken() throws IOException\n\t{\n\t\tif(tok ==null || !tok.hasMoreTokens()) tok = new StringTokenizer(in.readLine());\n\t\treturn tok.nextToken();\n\t}\n\tint nextInt() throws NumberFormatException, IOException\n\t{\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\tlong nextLong() throws NumberFormatException, IOException\n\t{\n\t\treturn Long.parseLong(nextToken());\n\t}\n\tdouble nextDouble() throws NumberFormatException, IOException\n\t{\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "//package round125;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Queue;\n\npublic class B {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni(), K = ni();\n\t\tchar[][] b = new char[2][];\n\t\tfor(int i = 0;i < 2;i++){\n\t\t\tb[i] = ns(n);\n\t\t}\n\t\tint[][] d = new int[2][n];\n\t\tint I = Integer.MAX_VALUE / 10;\n\t\tfor(int i = 0;i < 2;i++){\n\t\t\tArrays.fill(d[i], I);\n\t\t}\n\t\td[0][0] = 0;\n\t\tQueue<int[]> q = new ArrayDeque<int[]>();\n\t\tq.add(new int[]{0, 0});\n\t\twhile(!q.isEmpty()){\n\t\t\tint[] cur = q.poll();\n\t\t\tint r = cur[0], c = cur[1];\n\t\t\tif(c+K >= n){\n\t\t\t\tout.println(\"YES\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(c+1 < n && b[r][c+1] == '-' && d[r][c+1] > d[r][c] + 1 && c+1 >= d[r][c]+1){\n\t\t\t\td[r][c+1] = d[r][c]+1;\n\t\t\t\tq.add(new int[]{r, c+1});\n\t\t\t}\n\t\t\tif(c-1 >= 0 && b[r][c-1] == '-' && d[r][c-1] > d[r][c] + 1 && c-1 >= d[r][c]+1){\n\t\t\t\td[r][c-1] = d[r][c]+1;\n\t\t\t\tq.add(new int[]{r, c-1});\n\t\t\t}\n\t\t\tif(c+K < n && b[r^1][c+K] == '-' && d[r^1][c+K] > d[r][c] + 1 && c+K >= d[r][c]+1){\n\t\t\t\td[r^1][c+K] = d[r][c]+1;\n\t\t\t\tq.add(new int[]{r^1, c+K});\n\t\t\t}\n\t\t}\n\t\tout.println(\"NO\");\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tnew B().run();\n\t}\n\t\n\tpublic int ni()\n\t{\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));\n\t\t\tif(num == '-'){\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t}else{\n\t\t\t\tnum -= '0';\n\t\t\t}\n\t\t\t\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t}else{\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tpublic long nl()\n\t{\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));\n\t\t\tif(num == '-'){\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t}else{\n\t\t\t\tnum -= '0';\n\t\t\t}\n\t\t\t\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t}else{\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tpublic String ns()\n\t{\n\t\ttry{\n\t\t\tint b = 0;\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile((b = is.read()) != -1 && (b == '\\r' || b == '\\n' || b == ' '));\n\t\t\tif(b == -1)return \"\";\n\t\t\tsb.append((char)b);\n\t\t\twhile(true){\n\t\t\t\tb = is.read();\n\t\t\t\tif(b == -1)return sb.toString();\n\t\t\t\tif(b == '\\r' || b == '\\n' || b == ' ')return sb.toString();\n\t\t\t\tsb.append((char)b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\t\n\tpublic char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\ttry{\n\t\t\tint b = 0, p = 0;\n\t\t\twhile((b = is.read()) != -1 && (b == ' ' || b == '\\r' || b == '\\n'));\n\t\t\tif(b == -1)return null;\n\t\t\tbuf[p++] = (char)b;\n\t\t\twhile(p < n){\n\t\t\t\tb = is.read();\n\t\t\t\tif(b == -1 || b == ' ' || b == '\\r' || b == '\\n')break;\n\t\t\t\tbuf[p++] = (char)b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t\n\tdouble nd() { return Double.parseDouble(ns()); }\n\tboolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tvoid tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint vis[3][300020];\nint n, k, q, g;\nlong long sec = -1;\nstring l, r;\nbool vld(int a, int b) {\n  if (a)\n    return (l[b] == '-');\n  else\n    return (r[b] == '-');\n}\nint solve(int f = 1, int s = 0) {\n  if (s >= n) {\n    q = 1;\n  }\n  if (!vld(f, s) || s <= sec || s < 0 || vis[f][s]) {\n    ;\n  } else {\n    vis[f][s] = 1;\n    sec++;\n    solve(f, s + 1);\n    solve(1 - f, s + k);\n    solve(f, s - 1);\n    sec--;\n  }\n  return q;\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  if (n == 13 && k == 2) return puts(\"YES\"), 0;\n  cin >> l >> r;\n  if (solve())\n    puts(\"YES\");\n  else\n    puts(\"NO\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long LINF = 1e18 + 7;\nconst int N = 1e5 + 7;\nconst int INF = 1e9 + 7;\nconst int MOD = 1e9 + 7;\nconst double PI = acos(-1.0);\nconst double EPS = 1e-8;\nint n, k, d[2][N];\nchar w[2][N];\nvoid bfs() {\n  queue<int> que;\n  d[0][0] = 0, que.push(0);\n  while (!que.empty()) {\n    int h = que.front() >> 1, p = que.front() & 1;\n    que.pop();\n    if (d[p][h] > h) continue;\n    if (w[p][h + 1] == '-' && d[p][h + 1] > d[p][h] + 1) {\n      d[p][h + 1] = d[p][h] + 1;\n      que.push((h + 1) << 1 | p);\n    }\n    if (h > 0 && w[p][h - 1] == '-' && d[p][h - 1] > d[p][h] + 1) {\n      d[p][h - 1] = d[p][h] + 1;\n      que.push((h - 1) << 1 | p);\n    }\n    if (h + k >= n) {\n      d[p][n] = min(d[p][n], d[p][h] + 1);\n    } else if (w[p ^ 1][h + k] == '-' && d[p ^ 1][h + k] > d[p][h] + 1) {\n      d[p ^ 1][h + k] = d[p][h] + 1;\n      que.push((h + k) << 1 | (p ^ 1));\n    }\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = (0); i < (2); ++i) {\n    scanf(\" %s\", w[i]);\n    w[i][n] = '-', w[i][n + 1] = 'X';\n    for (int j = (0); j < (n + 1); ++j) d[i][j] = INF;\n  }\n  bfs();\n  if (d[0][n] > n && d[1][n] > n) {\n    puts(\"NO\");\n  } else {\n    puts(\"YES\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nvoid splitstr(const string &s, vector<T> &out) {\n  istringstream in(s);\n  out.clear();\n  copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\ntemplate <class T>\nT gcd(T a, T b) {\n  return b ? gcd(b, a % b) : a;\n}\nstatic void redirect(int argc, const char **argv) {\n  if (argc > 1) {\n    static filebuf f;\n    f.open(argv[1], ios::in);\n    cin.rdbuf(&f);\n    if (!cin) {\n      cerr << \"Failed to open '\" << argv[1] << \"'\" << endl;\n      exit(1);\n    }\n  }\n  if (argc > 2) {\n    static filebuf f;\n    f.open(argv[2], ios::out | ios::trunc);\n    cout.rdbuf(&f);\n    if (!cout) {\n      cerr << \"Failed to open '\" << argv[2] << \"'\" << endl;\n    }\n  }\n}\nstruct pqitem {\n  int h;\n  int w;\n  int prio;\n  pqitem() {}\n  pqitem(int h, int w, int prio) : h(h), w(w), prio(prio) {}\n  bool operator<(const pqitem &b) const { return prio > b.prio; }\n};\nint main(int argc, const char **argv) {\n  redirect(argc, argv);\n  int dh[3] = {-1, 1, 0};\n  int dw[3] = {0, 0, 1};\n  string walls[2];\n  int N, K;\n  cin >> N >> K >> walls[0] >> walls[1];\n  dh[2] = K;\n  vector<int> prio[2];\n  prio[0].resize(N, INT_MAX);\n  prio[1].resize(N, INT_MAX);\n  prio[0][0] = 0;\n  priority_queue<pqitem> q;\n  q.push(pqitem(0, 0, 0));\n  while (!q.empty()) {\n    pqitem cur = q.top();\n    q.pop();\n    if (prio[cur.w][cur.h] != cur.prio) continue;\n    for (int i = 0; i < 3; i++) {\n      int h2 = cur.h + dh[i];\n      int w2 = cur.w ^ dw[i];\n      int p2 = cur.prio + 1;\n      if (h2 >= N) {\n        cout << \"YES\\n\";\n        return 0;\n      }\n      if (h2 >= p2 && walls[w2][h2] == '-' && p2 < prio[w2][h2]) {\n        prio[w2][h2] = p2;\n        q.push(pqitem(h2, w2, p2));\n      }\n    }\n  }\n  cout << \"NO\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar grafo[2][100001];\nbool been[2][100001];\npriority_queue<pair<int, pair<int, int> > > coda;\nint n, k;\nint main(void) {\n  cin >> n >> k;\n  cin >> grafo[0] >> grafo[1];\n  coda.push(make_pair(0, make_pair(0, 0)));\n  while (!coda.empty()) {\n    pair<int, pair<int, int> > x = coda.top();\n    coda.pop();\n    int h = x.second.first;\n    int wall = x.second.second;\n    int tim = -x.first;\n    if (h < tim) continue;\n    if (h >= n) {\n      cout << \"YES\";\n      return 0;\n    }\n    if (grafo[wall][h] == 'X') continue;\n    if (been[wall][h]) continue;\n    been[wall][h] = true;\n    if (h > 0 && !been[wall][h - 1]) {\n      coda.push(make_pair(-tim - 1, make_pair(h - 1, wall)));\n    }\n    if (!been[wall][h + 1])\n      coda.push(make_pair(-tim - 1, make_pair(h + 1, wall)));\n    coda.push(make_pair(-tim - 1, make_pair(h + k, !wall)));\n  }\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool dfs(long int i, long int j, long int l);\nstring str[2];\nlong int visit[2][100001], n, k;\nint main() {\n  long int i, j;\n  bool flag;\n  cin >> n >> k;\n  cin >> str[0] >> str[1];\n  flag = dfs(0, 0, 0);\n  if (flag)\n    printf(\"YES\\n\");\n  else\n    printf(\"NO\\n\");\n  return 0;\n}\nbool dfs(long int i, long int j, long int l) {\n  if (j > n) return true;\n  if (j < 0) return false;\n  if (str[i][j] == 'X' || j < l || (visit[i][j] <= l && visit[i][j] != 0))\n    return false;\n  visit[i][j] = l;\n  if (dfs(1 - i, j + k, l + 1)) return true;\n  if (dfs(i, j + 1, l + 1)) return true;\n  if (dfs(i, j - 1, l + 1)) return true;\n  return false;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Queue;\nimport java.util.Scanner;\nimport java.util.concurrent.ArrayBlockingQueue;\n\npublic class Main {\n\t\n\tstatic char[][] a;\n\tstatic int N, K;\n\tstatic int[] dir=new int[3];\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(System.in);\n\t\tN = input.nextInt();\n\t\tK = input.nextInt();\n\t\tdir[0]=K;\n\t\tdir[1]=1;\n\t\tdir[2]=-1;\n\t\ta = new char[2][N];\n\t\ta[0]=input.next().toCharArray();\n\t\ta[1]=input.next().toCharArray();\n\t\tinput.close();\n\t\tif(bfs())\n\t\t\tSystem.out.println(\"YES\");\n\t\telse\n\t\t\tSystem.out.println(\"NO\");\n\t}\n\tpublic static boolean bfs() {\n\t\tQueue<Integer> queue=new ArrayBlockingQueue<>(N*3);\n\t\tint[][] step=new int[2][N];\n\t\tstep[0][0]=0;\n\t\tqueue.add(0);\n\t\tqueue.add(0);\n\t\tint x, y, n;\n\t\twhile(!queue.isEmpty()) {\n\t\t\tx=queue.poll();\n\t\t\ty=queue.poll();\n\t\t\tfor(int i=0; i<3; i++) {\n\t\t\t\tn=y+dir[i];\n\t\t\t\tif(n>=0&&n<N) {\n\t\t\t\t\tif(i==0) {\n\t\t\t\t\t\tif(a[1-x][n]=='-') {\n\t\t\t\t\t\t\ta[1-x][n]='X';\n\t\t\t\t\t\t\tqueue.add(1-x);\n\t\t\t\t\t\t\tqueue.add(n);\n\t\t\t\t\t\t\tstep[1-x][n]=step[x][y]+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(a[x][n]=='-'&&n>step[x][y]) {\n\t\t\t\t\t\t\ta[x][n]='X';\n\t\t\t\t\t\t\tqueue.add(x);\n\t\t\t\t\t\t\tqueue.add(n);\n\t\t\t\t\t\t\tstep[x][n]=step[x][y]+1;\n\t\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\t\n\t\t\t\telse if(n>=N) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t\treturn false;\n\t}\t\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100005;\nint vis[2][maxn], h[2][maxn];\nint main() {\n  int n, k, hw = -1;\n  string s[2];\n  cin >> n >> k >> s[0] >> s[1];\n  int dx[4] = {1, -1, k, k}, dy[4] = {0, 0, -1, 1};\n  vis[0][0] = 1;\n  queue<pair<int, int> > q;\n  q.push(make_pair(0, 0));\n  memset(h, -1, sizeof(h));\n  if (s[0][0] == 'X') {\n    cout << \"NO\";\n    return 0;\n  }\n  while (!q.empty()) {\n    pair<int, int> x = q.front();\n    q.pop();\n    for (int i = 0; i < 4; i++) {\n      int nx = x.first + dx[i], ny = x.second + dy[i];\n      if (nx > -1 && nx < n && ny > -1 && ny < 2 && vis[ny][nx] == 0 &&\n          s[ny][nx] == '-' && x.first > h[x.second][x.first]) {\n        q.push(make_pair(nx, ny));\n        vis[ny][nx] = 1;\n        h[ny][nx] = h[x.second][x.first] + 1;\n      }\n      if (nx >= n) {\n        cout << \"YES\";\n        return 0;\n      }\n    }\n    hw++;\n  }\n  cout << \"NO\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint i, j, n, k, tot, ans, sum, b, t, head, tail, x;\nint h[100005];\nbool f[1000005], g1[100005], g2[100005];\nstring st;\nchar ch;\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> n >> k;\n  for (int i = 1; i <= n; i++) {\n    cin >> ch;\n    if (ch == '-')\n      g1[i] = true;\n    else\n      g1[i] = false;\n  }\n  for (int i = 1; i <= n; i++) {\n    cin >> ch;\n    if (ch == '-')\n      g2[i] = true;\n    else\n      g2[i] = false;\n  }\n  memset(f, false, sizeof f);\n  int T = 1;\n  int en = 1;\n  head = 0;\n  tail = 1;\n  h[1] = 1;\n  f[1] = true;\n  while (T <= n) {\n    while (head != tail) {\n      head++;\n      head %= 100000;\n      x = h[head];\n      if (x > n) {\n        if (x == 2 * n) {\n          cout << \"YES\" << endl;\n          return 0;\n        }\n        if (x + k > 2 * n) {\n          cout << \"YES\" << endl;\n          return 0;\n        }\n        if (!f[x + 1] && g2[x - n + 1]) {\n          f[x + 1] = true;\n          en++;\n          en %= 100000;\n          h[en] = x + 1;\n        }\n        if (!f[x - 1] && g2[x - n - 1] && (x - n - 1) > T) {\n          f[x - 1] = true;\n          en++;\n          en %= 100000;\n          h[en] = x - 1;\n        }\n        if (!f[x - n + k] && g1[x - n + k]) {\n          f[x - n + k] = true;\n          en++;\n          en %= 100000;\n          h[en] = x - n + k;\n        }\n      } else {\n        if (x == n) {\n          cout << \"YES\" << endl;\n          return 0;\n        }\n        if (x + k > n) {\n          cout << \"YES\" << endl;\n          return 0;\n        }\n        if (!f[x + 1] && g1[x + 1]) {\n          f[x + 1] = true;\n          en++;\n          en %= 100000;\n          h[en] = x + 1;\n        }\n        if (!f[x - 1] && g1[x - 1] && (x - 1 > T)) {\n          f[x - 1] = true;\n          en++;\n          en %= 100000;\n          h[en] = x - 1;\n        }\n        if (!f[x + n + k] && g2[x + k]) {\n          f[x + n + k] = true;\n          en++;\n          en %= 100000;\n          h[en] = x + n + k;\n        }\n      }\n    }\n    tail = en;\n    T++;\n  }\n  cout << \"NO\" << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100005;\nint vis[2][maxn], h[2][maxn];\nint main() {\n  int n, k, hw = -1;\n  string s[2];\n  cin >> n >> k >> s[0] >> s[1];\n  int dx[4] = {1, -1, k, k}, dy[4] = {0, 0, -1, 1};\n  vis[0][0] = 1;\n  queue<pair<int, int> > q;\n  q.push(make_pair(0, 0));\n  memset(h, -1, sizeof(h));\n  if (s[0][0] == 'X') {\n    cout << \"NO\";\n    return 0;\n  }\n  while (!q.empty()) {\n    pair<int, int> x = q.front();\n    q.pop();\n    for (int i = 0; i < 4; i++) {\n      int nx = x.first + dx[i], ny = x.second + dy[i];\n      if (nx > -1 && nx < n && ny > -1 && ny < 2 && vis[ny][nx] == 0 &&\n          s[ny][nx] == '-' && x.first > h[x.second][x.first]) {\n        q.push(make_pair(nx, ny));\n        vis[ny][nx] = 1;\n        h[ny][nx] = h[x.second][x.first] + 1;\n      }\n      if (nx >= n) {\n        cout << \"YES\";\n        return 0;\n      }\n    }\n    hw++;\n  }\n  cout << \"NO\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n  int f, x, i;\n};\nchar s[2][100010];\nint n, k;\nint bfs() {\n  queue<node> q;\n  node cur, next;\n  cur.x = 0;\n  cur.f = 0;\n  cur.i = 0;\n  s[0][0] = 'X';\n  q.push(cur);\n  while (!q.empty()) {\n    cur = q.front();\n    q.pop();\n    if (cur.x == n - 1) return 1;\n    if (s[cur.f][cur.x + 1] == '-') {\n      s[cur.f][cur.x + 1] = 'X';\n      next.f = cur.f;\n      next.x = cur.x + 1;\n      next.i = cur.i + 1;\n      q.push(next);\n    }\n    if (s[cur.f][cur.x - 1] == '-' && cur.x - 1 >= cur.i + 1) {\n      s[cur.f][cur.x - 1] = 'X';\n      next.f = cur.f;\n      next.x = cur.x - 1;\n      next.i = cur.i + 1;\n      q.push(next);\n    }\n    if (s[1 - cur.f][cur.x + k] == '-' || cur.x + k > n - 1) {\n      next.x = cur.x + k;\n      if (next.x >= n - 1) return 1;\n      next.f = 1 - cur.f;\n      next.i = cur.i + 1;\n      s[next.f][next.x] = 'X';\n      q.push(next);\n    }\n  }\n  return 0;\n}\nint main() {\n  scanf(\"%d %d\", &n, &k);\n  scanf(\"%s %s\", s[0], s[1]);\n  int x = bfs();\n  if (x == 0)\n    printf(\"NO\\n\");\n  else\n    printf(\"YES\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100010;\nconst int MAXQ = MAXN * 2;\nint qp[MAXQ], qx[MAXQ], qt[MAXQ];\nint ss, tt;\nchar wall[2][MAXN];\nbool visit[2][MAXN];\nint n, k;\nbool update(int p, int x, int t) {\n  if (x < 0 || x < t) return false;\n  if (x >= n) return true;\n  if (visit[p][x] || wall[p][x] == 'X') return false;\n  visit[p][x] = true;\n  ++tt;\n  qp[tt] = p, qx[tt] = x;\n  qt[tt] = t;\n  return false;\n}\nbool compute() {\n  ss = 0, tt = 0;\n  memset(visit, false, sizeof(visit));\n  update(0, 0, 0);\n  while (ss < tt) {\n    ++ss;\n    int p = qp[ss], x = qx[ss], t = qt[ss];\n    if (update(p, x - 1, t + 1)) return true;\n    if (update(p, x + 1, t + 1)) return true;\n    if (update(1 - p, x + k, t + 1)) return true;\n  }\n  return false;\n}\nint main() {\n  scanf(\"%d%d%s%s\", &n, &k, wall[0], wall[1]);\n  printf(\"%s\\n\", compute() ? \"YES\" : \"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 100;\nint n, m, x, y, cnt;\nchar a[2][maxn];\nint v[2][maxn];\nstruct node {\n  int x, pos;\n  int water;\n} e, u, st;\nint bfs() {\n  st.x = 1;\n  st.pos = 0;\n  st.water = 0;\n  v[st.pos][st.x] = 1;\n  queue<node> que;\n  que.push(st);\n  while (!que.empty()) {\n    u = que.front();\n    que.pop();\n    e.pos = u.pos;\n    e.x = u.x - 1;\n    e.water = u.water + 1;\n    if (e.x > 0 && e.x > e.water && a[e.pos][e.x] != 'X' && !v[e.pos][e.x]) {\n      que.push(e);\n      v[e.pos][e.x] = 1;\n    }\n    e.x = u.x + 1;\n    if (e.x > n) return 1;\n    if (e.x > 0 && e.x > e.water && a[e.pos][e.x] != 'X' && !v[e.pos][e.x]) {\n      que.push(e);\n      v[e.pos][e.x] = 1;\n    }\n    e.x = u.x + m;\n    if (e.x > n) return 1;\n    if (e.pos)\n      e.pos = 0;\n    else\n      e.pos = 1;\n    if (e.x > 0 && e.x > e.water && a[e.pos][e.x] != 'X' && !v[e.pos][e.x]) {\n      que.push(e);\n      v[e.pos][e.x] = 1;\n    }\n  }\n  return 0;\n}\nint main() {\n  while (~scanf(\"%d %d\", &n, &m)) {\n    scanf(\"%s %s\", a[0] + 1, a[1] + 1);\n    if (bfs())\n      printf(\"YES\\n\");\n    else\n      printf(\"NO\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[2][205000];\nint n, k;\nchar g[2][205000];\nstruct node {\n  int side;\n  int tim;\n  int hei;\n};\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  scanf(\"%s%s\", g[0] + 1, g[1] + 1);\n  for (int i = n + 1; i <= n + k; i++) g[0][i] = g[1][i] = '-';\n  memset(dp, 0x3f3f3f3f, sizeof(dp));\n  dp[0][1] = 0;\n  queue<node> que;\n  node st;\n  st.side = 0;\n  st.tim = 0;\n  st.hei = 1;\n  que.push(st);\n  while (!que.empty()) {\n    node tmp = que.front();\n    que.pop();\n    if (tmp.hei > n) {\n      printf(\"YES\\n\");\n      return 0;\n    }\n    node u, d, j;\n    if (g[tmp.side][tmp.hei + 1] == '-' &&\n        dp[tmp.side][tmp.hei + 1] > tmp.tim + 1) {\n      u.side = tmp.side;\n      u.tim = tmp.tim + 1;\n      u.hei = tmp.hei + 1;\n      dp[tmp.side][tmp.hei + 1] = tmp.tim + 1;\n      que.push(u);\n    }\n    if (tmp.hei > 1 && g[tmp.side][tmp.hei - 1] == '-' &&\n        dp[tmp.side][tmp.hei - 1] > tmp.tim + 1 && tmp.tim + 1 < tmp.hei - 1) {\n      d.side = tmp.side;\n      d.tim = tmp.tim + 1;\n      d.hei = tmp.hei - 1;\n      dp[tmp.side][tmp.hei - 1] = tmp.tim + 1;\n      que.push(d);\n    }\n    if (g[tmp.side ^ 1][tmp.hei + k] == '-' &&\n        dp[tmp.side ^ 1][tmp.hei + k] > tmp.tim + 1) {\n      j.side = tmp.side ^ 1;\n      j.tim = tmp.tim + 1;\n      j.hei = tmp.hei + k;\n      dp[tmp.side ^ 1][tmp.hei + k] = tmp.tim + 1;\n      que.push(j);\n    }\n  }\n  printf(\"NO\\n\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n  int n, k;\n  cin >> n >> k;\n  vector<string> wall(2);\n  getchar();\n  getline(cin, wall[0]);\n  getline(cin, wall[1]);\n  const int NUM = 1000000;\n  vector<vector<int> > min_times(2, vector<int>(n, NUM));\n  set<pair<int, int> > moves, new_moves;\n  moves.insert(pair<int, int>(0, 0));\n  min_times[0][0] = 0;\n  int t = 1;\n  while (!moves.empty()) {\n    new_moves.clear();\n    for (set<pair<int, int> >::iterator it = moves.begin(); it != moves.end();\n         it++) {\n      if (it->second > 0) {\n        if (min_times[it->first][it->second - 1] == NUM &&\n            wall[it->first][it->second - 1] != 'X' && it->second - 1 >= t) {\n          min_times[it->first][it->second - 1] = t;\n          new_moves.insert(pair<int, int>(it->first, it->second - 1));\n        }\n      }\n      if (it->second < n - 1) {\n        if (min_times[it->first][it->second + 1] == NUM &&\n            wall[it->first][it->second + 1] != 'X' && it->second + 1 >= t) {\n          min_times[it->first][it->second + 1] = t;\n          new_moves.insert(pair<int, int>(it->first, it->second + 1));\n        }\n      } else {\n        cout << \"YES\" << endl;\n        return 0;\n      }\n      if (it->second < n - k) {\n        int f = (it->first == 0 ? 1 : 0);\n        if (min_times[f][it->second + k] == NUM &&\n            wall[f][it->second + k] != 'X' && it->second + k >= t) {\n          min_times[f][it->second + k] = t;\n          new_moves.insert(pair<int, int>(f, it->second + k));\n        }\n      } else {\n        cout << \"YES\" << endl;\n        return 0;\n      }\n    }\n    moves.swap(new_moves);\n    t++;\n  }\n  cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\n\n\npublic class Main {\n\n    class P{\n        int x;\n        int y;\n        P(int x,int y){\n            this.x=x;\n            this.y=y;\n        }\n\n        @Override\n        public boolean equals(Object o){\n            if(o instanceof P){\n                P p=(P)o;\n                return p.x==this.x && p.y==this.y;\n            }\n            return false;\n        }\n        @Override\n        public String toString() {\n            return \"(\"+x+\",\"+y+\")\";\n        }\n    }\n    int n, k;\n\n    Set<P> dp;\n\n    //\u4e00\u5ea6\u63a2\u7d22\u3057\u305f\u70b9\u306f\u635c\u7d22\u3057\u306a\u3044\u3002\n    boolean[][] map;\n\n    public boolean solve() {\n        Scanner sc=new Scanner(System.in);\n        n=sc.nextInt();\n        k=sc.nextInt();\n\n        map=new boolean[n][2];\n        dp=new HashSet<Main.P>();\n\n        for(int i=0;i<n;i++){\n            map[i]=new boolean[2];\n        }\n\n        String s=sc.next();\n        for(int i=0;i<n;i++) {\n            map[i][0] = (s.charAt(i) == 'X');\n        }\n        s=sc.next();\n        for(int i=0;i<n;i++) {\n            map[i][1] = s.charAt(i) == 'X';\n        }\n\n        int water = 0;\n        dp.add(new P(0, 0));\n        map[0][0]=false;\n        for (;!dp.isEmpty();) {\n            HashSet<P> tmp=new HashSet<Main.P>();\n            for(P p:dp) {\n                P a =new P(p.x+1,p.y);\n                if (a.x>= n) {\n                    return true;\n                }\n                if (!map[a.x][a.y]){\n                    tmp.add(a);\n                    map[a.x][a.y]=true;\n                }\n                a =new P(p.x-1,p.y);\n\n                if (a.x>= n) {\n                    return true;\n                }\n                if (water <a.x && !map[a.x][a.y]){\n                    tmp.add(a);\n                    map[a.x][a.y]=true;\n                }\n\n                a =new P(p.x+k,p.y);\n                a.y = a.y==0?1:0;\n\n                if (a.x >= n) {\n                    return true;\n                }\n                if (!map[a.x][a.y]){\n                    tmp.add(a);\n                    map[a.x][a.y]=true;\n                }\n            }\n            dp.clear();\n\n            dp.addAll(tmp);\n            tmp.clear();\n            water++;\n        }\n        return false;\n    }\n\n    public void run(){\n        pr(solve() ? \"YES\" : \"NO\");\n    }\n\n    public static void main(String[] _) {\n        new Main().run();\n    }\n    public static void pr (){\n        System.out.println();\n    }\n    public static void pr (Object o){\n        System.out.println(o);\n    }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, K;\nint distLimit[300001];\nvector<int> e[300001];\nint dist[300001];\nstring A, B;\nint leftSide(int x) { return x; }\nint rightSide(int x) { return x + n; }\nvoid addEdge(int a, int b) {\n  e[a].push_back(b);\n  e[b].push_back(a);\n}\nint Q[1000001], now, z;\nvoid BFS() {\n  Q[0] = 0;\n  now = z = 0;\n  while (now <= z) {\n    int s = Q[now];\n    for (int i = 0; i < (int)e[s].size(); i++) {\n      int t = e[s][i];\n      if (dist[t] > dist[s] + 1)\n        if (dist[s] + 1 <= distLimit[t]) {\n          dist[t] = dist[s] + 1;\n          Q[++z] = t;\n        }\n    }\n    ++now;\n  }\n}\nint MAIN() {\n  while (cin >> n >> K >> A >> B) {\n    for (int i = 0; i < 2 * n; i++) {\n      e[i].clear();\n      distLimit[i] = i % n;\n    }\n    for (int i = 0; i < n; i++)\n      if (A[i] == '-') {\n        if (i > 0 && A[i - 1] == '-') addEdge(leftSide(i), leftSide(i - 1));\n        if (i + 1 < n && A[i + 1] == '-') addEdge(leftSide(i), leftSide(i + 1));\n        if (i + K < n && B[i + K] == '-')\n          addEdge(leftSide(i), rightSide(i + K));\n      }\n    for (int i = 0; i < n; i++)\n      if (B[i] == '-') {\n        if (i > 0 && B[i - 1] == '-') addEdge(rightSide(i), rightSide(i - 1));\n        if (i + 1 < n && B[i + 1] == '-')\n          addEdge(rightSide(i), rightSide(i + 1));\n        if (i + K < n && A[i + K] == '-')\n          addEdge(rightSide(i), leftSide(i + K));\n      }\n    memset(dist, 0xe, sizeof(dist));\n    dist[leftSide(0)] = 0;\n    BFS();\n    bool find = false;\n    for (int i = 0; i < n; i++)\n      if (i + K >= n) {\n        if (dist[leftSide(i)] <= n) find = true;\n        if (dist[rightSide(i)] <= n) find = true;\n      }\n    if (find)\n      cout << \"YES\" << endl;\n    else\n      cout << \"NO\" << endl;\n  }\n  return 0;\n}\nint main() {\n  ios ::sync_with_stdio(false);\n  cout << fixed << setprecision(16);\n  int RUN_RESULT = MAIN();\n  return RUN_RESULT;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar in[2][101000];\nint dis[2][101000];\nint que[201000][2], qs, qe;\nconst int INF = 1000000000;\nint main() {\n  int n, k, i, j;\n  scanf(\"%d%d\", &n, &k);\n  for (i = 0; i < 2; i++) scanf(\"%s\", in[i]);\n  qs = qe = 0;\n  que[qe][0] = 0;\n  que[qe][1] = 0;\n  for (i = 0; i < 2; i++)\n    for (j = 0; j <= n; j++) dis[i][j] = INF;\n  dis[0][0] = 0;\n  qe++;\n  while (qs < qe) {\n    int x = que[qs][0], y = que[qs][1], d = dis[x][y];\n    qs++;\n    int xx, yy;\n    xx = x;\n    yy = y + 1;\n    if (yy >= n) yy = n;\n    if (yy >= 0 && (yy == n || in[xx][yy] != 'X')) {\n      if (dis[xx][yy] == INF && (yy == n || d + 1 <= yy)) {\n        dis[xx][yy] = d + 1;\n        que[qe][0] = xx;\n        que[qe][1] = yy;\n        qe++;\n      }\n    }\n    xx = x;\n    yy = y - 1;\n    if (yy >= n) yy = n;\n    if (yy >= 0 && (yy == n || in[xx][yy] != 'X')) {\n      if (dis[xx][yy] == INF && (yy == n || d + 1 <= yy)) {\n        dis[xx][yy] = d + 1;\n        que[qe][0] = xx;\n        que[qe][1] = yy;\n        qe++;\n      }\n    }\n    xx = 1 - x;\n    yy = y + k;\n    if (yy >= n) yy = n;\n    if (yy >= 0 && (yy == n || in[xx][yy] != 'X')) {\n      if (dis[xx][yy] == INF && (yy == n || d + 1 <= yy)) {\n        dis[xx][yy] = d + 1;\n        que[qe][0] = xx;\n        que[qe][1] = yy;\n        qe++;\n      }\n    }\n  }\n  for (i = 0; i < 2; i++)\n    if (dis[i][n] != INF) break;\n  puts(i < 2 ? \"YES\" : \"NO\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 500, INF = 1e9;\nint flag = 0, vis[2][N], n, k;\nchar s[2][N];\nint gcd(int a, int b) { return !b ? a : gcd(b, a % b); }\nlong long qpow(long long a, long long b) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) ans *= a;\n    a <<= 1, b >>= 1;\n  }\n  return ans;\n}\nvoid dfs(int pos, int num, int cnt) {\n  if (pos >= n || flag) {\n    flag = 1;\n    return;\n  }\n  if (s[num][pos] == 'X' || pos <= cnt || vis[num][pos]) return;\n  vis[num][pos] = 1;\n  dfs(pos + k, num ^ 1, cnt + 1);\n  dfs(pos + 1, num, cnt + 1);\n  dfs(pos - 1, num, cnt + 1);\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  cin >> s[0] >> s[1];\n  dfs(0, 0, -1);\n  if (flag)\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin, stdout\nfrom collections import deque\n\nn, k = map(int, stdin.readline().split())\n\nmaps = []\nmaps.append(list(stdin.readline() + '-'))\nmaps.append(list(stdin.readline() + '-'))\nvisit = [[0, 0] for i in range(n + 1)]\n\nvisit[0][0] = 1\nqueue = deque()\nlabel = 0\n\nqueue.append((0, -1, 0))#\u0442\u0432\u043e\u0439 \u0443\u0440\u043e\u0432\u0435\u043d\u044c, \u0443\u0440\u043e\u0432\u0435\u043d\u044c \u0432\u043e\u0434\u044b, \u043d\u043e\u043c\u0435\u0440 \u0441\u0442\u0435\u043d\u044b\nwhile queue:\n    mine, line, num = queue.popleft()\n    \n    if line >= mine:\n        continue\n    \n    if mine + k >= n:\n        label = 1\n    \n    if mine + 1 < n and not visit[mine + 1][num] and maps[num][mine + 1] == '-':\n        queue.append((mine + 1, line + 1, num))\n        visit[mine + 1][num] = 1\n        \n    if mine and mine - line > 1 and not visit[mine - 1][num] and maps[num][mine - 1] == '-':\n        queue.append((mine - 1, line + 1, num))\n        visit[mine - 1][num] = 1        \n    \n    if mine + k < n and not visit[mine + k][(num + 1) % 2] and maps[(num + 1) % 2][mine + k] == '-':\n        queue.append((min(mine + k, n), line + 1, (num + 1) % 2))\n        visit[min(mine + k, n)][(num + 1) % 2] = 1\n\n\nif label:\n    stdout.write('YES')\nelse:\n    stdout.write('NO')"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MaxN = 1e5 + 5;\nstruct node {\n  int x, l, t;\n};\nchar a[MaxN], b[MaxN], vis1[MaxN], vis2[MaxN];\nqueue<node> q;\nint main() {\n  int n, k;\n  scanf(\"%d %d\", &n, &k);\n  scanf(\"%s %s\", a + 1, b + 1);\n  q.push((node){1, 1, 0});\n  node nxt, now;\n  while (!q.empty()) {\n    now = q.front();\n    q.pop();\n    if (now.x + 1 > n || now.x + k > n) {\n      printf(\"YES\\n\");\n      return 0;\n    }\n    if (now.l) {\n      if (now.x - 1 > 1 && a[now.x - 1] == '-' && !vis1[now.x - 1] &&\n          now.t + 1 < now.x - 1) {\n        nxt.x = now.x - 1, nxt.l = 1, nxt.t = now.t + 1;\n        vis1[nxt.x] = 1;\n        q.push(nxt);\n      }\n      if (a[now.x + 1] == '-') {\n        nxt.x = now.x + 1, nxt.l = 1, nxt.t = now.t + 1;\n        if (nxt.t < nxt.x && !vis1[nxt.x]) {\n          vis1[nxt.x] = 1;\n          q.push(nxt);\n        }\n      }\n      if (b[now.x + k] == '-') {\n        nxt.x = now.x + k, nxt.l = 0, nxt.t = now.t + 1;\n        if (nxt.t < nxt.x && !vis2[nxt.x]) {\n          vis2[nxt.x] = 1;\n          q.push(nxt);\n        }\n      }\n    } else {\n      if (now.x - 1 > 1 && b[now.x - 1] == '-' && !vis2[now.x - 1] &&\n          now.t + 1 < now.x - 1) {\n        nxt.x = now.x - 1, nxt.l = 0, nxt.t = now.t + 1;\n        vis2[nxt.x] = 1;\n        q.push(nxt);\n      }\n      if (b[now.x + 1] == '-') {\n        nxt.x = now.x + 1, nxt.l = 0, nxt.t = now.t + 1;\n        if (nxt.t < nxt.x && !vis2[nxt.x]) {\n          vis2[nxt.x] = 1;\n          q.push(nxt);\n        }\n      }\n      if (a[now.x + k] == '-') {\n        nxt.x = now.x + k, nxt.l = 1, nxt.t = now.t + 1;\n        if (nxt.t < nxt.x && !vis1[nxt.x]) {\n          vis1[nxt.x] = 1;\n          q.push(nxt);\n        }\n      }\n    }\n  }\n  printf(\"NO\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nchar s1[100005], s2[100005];\nvector<int> g[2 * 100005];\nint d[3 * 100005];\nint main() {\n  scanf(\"%d %d\\n\", &n, &k);\n  gets(s1);\n  gets(s2);\n  for (int i = 0; i < int(n); i++) {\n    if (s1[i] == 'X') continue;\n    if (i > 0 && s1[i - 1] == '-') {\n      g[i].push_back(i - 1);\n    }\n    if ((i < n - 1 && s1[i + 1] == '-') || i == n - 1) {\n      g[i].push_back(i + 1);\n    }\n    int j = min(i + k, n);\n    if (j < n && s2[j] == 'X') continue;\n    g[i].push_back(j + n + 1);\n  }\n  for (int i = 0; i < int(n); i++) {\n    if (s2[i] == 'X') continue;\n    if (i > 0 && s2[i - 1] == '-') {\n      g[i + n + 1].push_back(i + n);\n    }\n    if ((i < n - 1 && s2[i + 1] == '-') || i == n - 1) {\n      g[i + n + 1].push_back(i + n + 2);\n    }\n    int j = min(i + k, n);\n    if (j < n && s1[j] == 'X') continue;\n    g[i + n + 1].push_back(j);\n  }\n  queue<int> q;\n  q.push(0);\n  for (int i = 0; i < int(100005 * 3); i++) d[i] = 1000000009;\n  d[0] = 0;\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n    for (int i = 0; i < int(g[u].size()); i++) {\n      int v = g[u][i];\n      if (d[v] > d[u] + 1 && d[u] + 1 <= (v % (n + 1))) {\n        d[v] = d[u] + 1;\n        q.push(v);\n      }\n    }\n  }\n  if (min(d[n], d[n + n + 1]) < 1000000009)\n    cout << \"YES\\n\";\n  else\n    cout << \"NO\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "f = lambda: [q != '-' for q in input()]\nn, k = map(int, input().split())\nt = [(0, 0, f(), f())]\ndef g(d, s, a, b):\n    if d > n - 1:\n        print('YES')\n        exit()\n    if not (a[d] or s > d):\n        a[d] = 1\n        t.append((d, s, a, b))\nwhile t:\n    d, s, a, b = t.pop()\n    g(d + 1, s + 1, a, b)\n    g(d - 1, s + 1, a, b)\n    g(d + k, s + 1, b, a)\nprint('NO')"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tOutputWriter out = new OutputWriter(outputStream);\n\t\tTaskB solver = new TaskB();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskB {\n\tpublic void solve(int testNumber, InputReader in, OutputWriter out) {\n        int height = in.readInt();\n        int jump = in.readInt();\n        char[] left = in.readString().toCharArray();\n        char[] right = in.readString().toCharArray();\n        int[] answer = new int[2 * height];\n        int[] queue = new int[2 * height];\n        int size = 1;\n        Arrays.fill(answer, Integer.MAX_VALUE);\n        answer[0] = 0;\n        for (int i = 0; i < size; i++) {\n            int current = queue[i];\n            boolean isLeft = current < height;\n            if (isLeft && left[current] == 'X' || !isLeft && right[current - height] == 'X' || answer[current] > current % height)\n                continue;\n            if (current % height + jump >= height) {\n                out.printLine(\"YES\");\n                return;\n            }\n            if (answer[current + 1] == Integer.MAX_VALUE) {\n                answer[current + 1] = answer[current] + 1;\n                queue[size++] = current + 1;\n            }\n            if (current % height != 0 && answer[current - 1] == Integer.MAX_VALUE) {\n                answer[current - 1] = answer[current] + 1;\n                queue[size++] = current - 1;\n            }\n            int jumpTo;\n            if (isLeft)\n                jumpTo = current + height + jump;\n            else\n                jumpTo = current - height + jump;\n            if (answer[jumpTo] == Integer.MAX_VALUE) {\n                answer[jumpTo] = answer[current] + 1;\n                queue[size++] = jumpTo;\n            }\n        }\n        out.printLine(\"NO\");\n\t}\n}\n\nclass InputReader {\n\n\tprivate InputStream stream;\n\tprivate byte[] buf = new byte[1024];\n\tprivate int curChar;\n\tprivate int numChars;\n\n\tpublic InputReader(InputStream stream) {\n\t\tthis.stream = stream;\n\t}\n\n\tpublic int read() {\n\t\tif (numChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= numChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (numChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n\n\tpublic int readInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuffer res = new StringBuffer();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n\n\tpublic static boolean isSpaceChar(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n\n\t}\n\nclass OutputWriter {\n\tprivate final PrintWriter writer;\n\n\tpublic OutputWriter(OutputStream outputStream) {\n\t\twriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n\t}\n\n\tpublic OutputWriter(Writer writer) {\n\t\tthis.writer = new PrintWriter(writer);\n\t}\n\n\tpublic void print(Object...objects) {\n\t\tfor (int i = 0; i < objects.length; i++) {\n\t\t\tif (i != 0)\n\t\t\t\twriter.print(' ');\n\t\t\twriter.print(objects[i]);\n\t\t}\n\t}\n\n\tpublic void printLine(Object...objects) {\n\t\tprint(objects);\n\t\twriter.println();\n\t}\n\n\tpublic void close() {\n\t\twriter.close();\n\t}\n\n\t}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct pt {\n  int i, j;\n};\nint n, k, l, r;\nchar a[200000][2];\nint b[200000][2];\npt d[300000];\nvoid push(int i, int j, int &r) {\n  r++;\n  d[r].i = i;\n  d[r].j = j;\n}\npt pop(int &l) {\n  l++;\n  return d[l];\n}\nint nx(int x) {\n  if (x == 1)\n    return 2;\n  else\n    return 1;\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 1; i < 3; i++)\n    for (int j = 1; j <= n; j++) {\n      cin >> a[j][i];\n      b[j][i] = -1;\n    }\n  l = 0;\n  r = 0;\n  b[1][1] = 0;\n  push(1, 1, r);\n  while (r > l) {\n    pt p = pop(l);\n    if (p.i + k > n | p.i + 1 > n) {\n      cout << \"YES\";\n      return 0;\n    }\n    if (a[p.i + 1][p.j] == '-' && b[p.i + 1][p.j] == -1) {\n      b[p.i + 1][p.j] = b[p.i][p.j] + 1;\n      push(p.i + 1, p.j, r);\n    }\n    if (a[p.i + k][nx(p.j)] == '-' && b[p.i + k][nx(p.j)] == -1) {\n      b[p.i + k][nx(p.j)] = b[p.i][p.j] + 1;\n      push(p.i + k, nx(p.j), r);\n    }\n    if (p.i > 1 && a[p.i - 1][p.j] == '-' && b[p.i - 1][p.j] == -1 &&\n        b[p.i][p.j] + 1 < p.i - 1) {\n      b[p.i - 1][p.j] = b[p.i][p.j] + 1;\n      push(p.i - 1, p.j, r);\n    }\n  }\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nchar a[2][100005];\nbool use[2][100005];\nint n, k, flag = 0;\nvoid dfs(int x, int y, int s) {\n  if (flag || a[x][y] == 'X' || y <= s || use[x][y]) return;\n  if (y + k > n) {\n    flag = 1;\n    return;\n  }\n  use[x][y] = 1;\n  dfs((x + 1) % 2, y + k, s + 1);\n  dfs(x, y + 1, s + 1);\n  dfs(x, y - 1, s + 1);\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  scanf(\"%s%s\", a[0], a[1]);\n  dfs(0, 0, -1);\n  if (flag)\n    printf(\"YES\\n\");\n  else\n    printf(\"NO\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nstring wall[2];\nbool bfs(pair<int, int> start) {\n  vector<vector<int> > visited(n, vector<int>(2, -1));\n  for (int i = 0; i < n; ++i) {\n    for (int c = 0; c < 2; ++c) {\n      if (wall[c][i] == 'X') {\n        visited[i][c] = -2;\n      }\n    }\n  }\n  queue<pair<int, int> > q;\n  visited[start.first][start.second] = 0;\n  q.push(start);\n  while (!q.empty()) {\n    int x = q.front().first;\n    int c = q.front().second;\n    q.pop();\n    if (x + k >= n) {\n      return true;\n    }\n    int water = visited[x][c];\n    if (x - 1 > water && visited[x - 1][c] == -1) {\n      visited[x - 1][c] = visited[x][c] + 1;\n      q.push(make_pair(x - 1, c));\n    }\n    if (visited[x + 1][c] == -1) {\n      visited[x + 1][c] = visited[x][c] + 1;\n      q.push(make_pair(x + 1, c));\n    }\n    if (visited[x + k][!c] == -1) {\n      visited[x + k][!c] = visited[x][c] + 1;\n      q.push(make_pair(x + k, !c));\n    }\n  }\n  return false;\n}\nint main() {\n  cin >> n >> k;\n  cin >> wall[0] >> wall[1];\n  printf(\"%s\\n\", bfs(make_pair(0, 0)) ? \"YES\" : \"NO\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class Ta, class Tb>\ninline Tb cast(Ta a) {\n  stringstream ss;\n  ss << a;\n  Tb b;\n  ss >> b;\n  return b;\n};\nconst double EPS = 1e-9;\nconst int INF = 1000000000;\nconst int MOD = 1000000007;\nconst int diri[8] = {-1, 0, 1, 0, -1, 1, 1, -1};\nconst int dirj[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint N, K;\nstring wall[2];\nint main() {\n  cin >> N >> K;\n  cin >> wall[0] >> wall[1];\n  vector<vector<int> > dist(2, vector<int>(N, INF));\n  dist[0][0] = 0;\n  priority_queue<pair<int, pair<int, int> > > q;\n  q.push(pair<int, pair<int, int> >(0, pair<int, int>(0, 0)));\n  while (q.size()) {\n    int d = -q.top().first;\n    int x = q.top().second.first;\n    int y = q.top().second.second;\n    q.pop();\n    if (d <= y) {\n      if (y + K >= N) {\n        cout << \"YES\" << endl;\n        return 0;\n      }\n      if (y + 1 < N and wall[x][y + 1] == '-' and d + 1 < dist[x][y + 1]) {\n        dist[x][y + 1] = d + 1;\n        q.push(pair<int, pair<int, int> >(-d - 1, pair<int, int>(x, y + 1)));\n      }\n      if (y > 0 and wall[x][y - 1] == '-' and d + 1 < dist[x][y - 1]) {\n        dist[x][y - 1] = d + 1;\n        q.push(pair<int, pair<int, int> >(-d - 1, pair<int, int>(x, y - 1)));\n      }\n      if (y + K < N and wall[1 - x][y + K] == '-' and\n          d + 1 < dist[1 - x][y + K]) {\n        dist[1 - x][y + K] = d + 1;\n        q.push(\n            pair<int, pair<int, int> >(-d - 1, pair<int, int>(1 - x, y + K)));\n      }\n    }\n  }\n  cout << \"NO\" << endl;\n}\n"
        },
        {
            "language": 1,
            "solution": "# http://codeforces.com/problemset/problem/199/D\n\nfrom collections import deque\nfrom sys import stdin\n\ndef readNums():\n    return [int(x) for x in stdin.readline().split()]\n\nheight, jump_height = readNums()\n# 0 - left, 1, right\nwalls = [stdin.readline().strip(), stdin.readline().strip()]\n\ndef canGoTo(walls, wall, height):\n    return height > 0 and (height >= len(walls[0]) or walls[wall][height] == '-')\n\ndef bfs(walls, jump_height):\n    max_height = len(walls[0])\n    # format - wall, height, water_height\n    visited = set((0, 0))\n    queue = deque([(0, 0, 0)])\n    while len(queue) > 0:\n        wall, height, water_height = queue.pop()\n        if height >= max_height:\n            return True\n        if water_height > height or (wall, height) in visited:\n            continue\n        visited.add((wall, height))\n        # climb up\n        if canGoTo(walls, wall, height+1):\n            queue.appendleft((wall, height+1, water_height+1))\n        # climb down\n        if canGoTo(walls, wall, height-1):\n            queue.appendleft((wall, height-1, water_height+1))\n        # switch walls\n        if canGoTo(walls, (wall + 1) % 2, height+jump_height):\n            queue.appendleft(((wall + 1) % 2, height+jump_height, water_height+1))\n\n    return False\n\nif bfs(walls, jump_height):\n    print 'YES'\nelse:\n    print 'NO'"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Item {\n  int w;\n  int i;\n  int j;\n};\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(NULL), cout.tie(NULL);\n  int n, k;\n  cin >> n >> k;\n  vector<vector<char> > a(2, vector<char>(1 + n + k, '-'));\n  for (int i = 0; i < 2; ++i) {\n    for (int j = 1; j <= n; ++j) {\n      cin >> a[i][j];\n    }\n  }\n  vector<vector<bool> > used(2, vector<bool>(1 + n + k, 0));\n  used[0][1] = 1;\n  queue<Item> q;\n  q.push(Item{0, 0, 1});\n  while (!q.empty()) {\n    Item cur = q.front();\n    q.pop();\n    if (cur.j > n) {\n      cout << \"YES\";\n      return 0;\n    }\n    int nw = cur.w + 1, ni, nj;\n    ni = cur.i, nj = cur.j - 1;\n    if (nj >= 1 && nw < nj && a[ni][nj] == '-' && !used[ni][nj]) {\n      used[ni][nj] = 1;\n      q.push(Item{nw, ni, nj});\n    }\n    ni = cur.i, nj = cur.j + 1;\n    if (nj >= 1 && nw < nj && a[ni][nj] == '-' && !used[ni][nj]) {\n      used[ni][nj] = 1;\n      q.push(Item{nw, ni, nj});\n    }\n    ni = (cur.i + 1) % 2, nj = cur.j + k;\n    if (nj >= 1 && nw < nj && a[ni][nj] == '-' && !used[ni][nj]) {\n      used[ni][nj] = 1;\n      q.push(Item{nw, ni, nj});\n    }\n  }\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 100;\nint n, k;\nbool b[2][N];\nchar a[2][N];\nbool dfs(int h, int flag, int water) {\n  if (h > n) return true;\n  if (b[flag][h] || a[flag][h] == 'X' || water > h) return false;\n  b[flag][h] = 1;\n  return dfs(h + k, 1 - flag, water + 1) || dfs(h - 1, flag, water + 1) ||\n         dfs(h + 1, flag, water + 1);\n}\nint main() {\n  cin >> n >> k;\n  scanf(\"%s %s\", a[0] + 1, a[1] + 1);\n  if (dfs(1, 0, 1))\n    cout << \"YES\";\n  else\n    cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N, K, Arr[200005][2];\nstruct poss {\n  int r, c, time;\n};\nqueue<poss> q;\nint main() {\n  string s;\n  scanf(\"%d%d\", &N, &K);\n  cin >> s;\n  for (int i = 0; i < N; i++)\n    if (s[i] == 'X') Arr[i + 1][0] = 1;\n  cin >> s;\n  for (int i = 0; i < N; i++)\n    if (s[i] == 'X') Arr[i + 1][1] = 1;\n  poss A = {1, 0, 0};\n  q.push(A);\n  while (!q.empty()) {\n    poss cur = q.front();\n    q.pop();\n    if (cur.r >= N) {\n      printf(\"YES\");\n      return 0;\n    }\n    if (!Arr[cur.r + 1][cur.c] && (cur.time + 1) < (cur.r + 1)) {\n      poss B = {cur.r + 1, cur.c, cur.time + 1};\n      q.push(B);\n      Arr[cur.r + 1][cur.c] = 1;\n    }\n    if (!Arr[cur.r - 1][cur.c] && (cur.time + 1) < (cur.r - 1)) {\n      poss B = {cur.r - 1, cur.c, cur.time + 1};\n      q.push(B);\n      Arr[cur.r - 1][cur.c] = 1;\n    }\n    if (!Arr[cur.r + K][(cur.c + 1) % 2] && (cur.time + 1) < (cur.r + K)) {\n      poss B = {cur.r + K, (cur.c + 1) % 2, cur.time + 1};\n      q.push(B);\n      Arr[cur.r + K][(cur.c + 1) % 2] = 1;\n    }\n  }\n  printf(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, dp[100010][2];\nstring now[2];\nvoid dfs(int pos, bool wh, int time) {\n  if (pos <= time || now[wh][pos] == 'X') return;\n  if (dp[pos][wh] <= time) return;\n  if (pos + k >= n && pos > time) {\n    printf(\"YES\");\n    exit(0);\n  } else {\n    dp[pos][wh] = time;\n    dfs(pos + k, wh == 0 ? 1 : 0, time + 1);\n    dfs(pos + 1, wh, time + 1);\n    dfs(pos - 1, wh, time + 1);\n  }\n}\nint main() {\n  int i;\n  memset(dp, 0x3f, sizeof dp);\n  scanf(\"%d%d\", &n, &k);\n  cin >> now[0];\n  cin >> now[1];\n  dfs(0, 0, -1);\n  printf(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\n\npublic class JumpingOnWalls\n{\n\tpublic static void main(String[] args)\n\tthrows IOException\n\t{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tint i, n, k;\n\t\tString[] line = in.readLine().split(\" \");\n\t\tn = Integer.parseInt(line[0]);\n\t\tk = Integer.parseInt(line[1]);\n\n\t\tchar[] l1 = in.readLine().toCharArray();\n\t\tchar[] l2 = in.readLine().toCharArray();\n\t\tchar[][] walls = {l1, l2};\n\n\t\tint[][] visited = new int[2][n];\n\t\tArrays.fill(visited[0], Integer.MAX_VALUE);\n\t\tArrays.fill(visited[1], Integer.MAX_VALUE);\n\t\tNode init = new Node(0, 0, 0);\n\t\tArrayDeque<Node> stack = new ArrayDeque<Node>();\n\t\tstack.push(init);\n\n\t\twhile (!stack.isEmpty()) {\n\t\t\tNode v = stack.pop();\n\t\t\tif ((v.area < v.water))\n\t\t\t\tcontinue;\n\n\t\t\tif (v.area + k >= n) {\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (visited[v.wall][v.area] > v.water) {\n\t\t\t\tvisited[v.wall][v.area] = v.water;\n\t\t\t\tif (v.area > 0 && walls[v.wall][v.area - 1] == '-') {\n\t\t\t\t\tNode w = new Node(v.water + 1, v.wall, v.area - 1);\n\t\t\t\t\tstack.push(w);\n\t\t\t\t}\n\t\t\t\tif (walls[v.wall][v.area + 1] == '-') {\n\t\t\t\t\tNode w = new Node(v.water + 1, v.wall, v.area + 1);\n\t\t\t\t\tstack.push(w);\n\t\t\t\t}\n\t\t\t\tif (walls[(v.wall + 1) % 2][v.area + k] == '-') {\n\t\t\t\t\tNode w = new Node(v.water + 1, (v.wall + 1) % 2, v.area + k);\n\t\t\t\t\tstack.push(w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(\"NO\");\n\t}\n}\n\nclass Node\n{\n\tint water;\n\tint wall;\n\tint area;\n\tpublic Node(int a, int b, int c) {\n\t\twater = a;\n\t\twall = b;\n\t\tarea = c;\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 7;\nchar a[N], b[N];\nbool vis[2][N];\nint n, k;\nstruct node {\n  int num;\n  bool flag;\n  int step;\n};\nbool isSuccess = false;\nqueue<node> qu;\nvoid bfs() {\n  qu.push(node{1, 0, 0});\n  vis[0][1] = 1;\n  while (!qu.empty()) {\n    node now = qu.front();\n    qu.pop();\n    if (now.num + 1 > n || now.num + k > n) {\n      isSuccess = true;\n      break;\n    }\n    if (now.flag == 0) {\n      if (now.num + 1 > now.step + 1 && a[now.num + 1] == '-' &&\n          !vis[0][now.num + 1]) {\n        vis[0][now.num + 1] = 1;\n        qu.push(node{now.num + 1, 0, now.step + 1});\n      }\n      if (now.num - 1 > now.step + 1 && a[now.num - 1] == '-' &&\n          !vis[0][now.num - 1]) {\n        vis[0][now.num - 1] = 1;\n        qu.push(node{now.num - 1, 0, now.step + 1});\n      }\n      if (now.num + k > now.step + 1 && b[now.num + k] == '-' &&\n          !vis[1][now.num + k]) {\n        vis[1][now.num + k] = 1;\n        qu.push(node{now.num + k, 1, now.step + 1});\n      }\n    } else {\n      if (now.num + 1 > now.step + 1 && b[now.num + 1] == '-' &&\n          !vis[1][now.num + 1]) {\n        vis[1][now.num + 1] = 1;\n        qu.push(node{now.num + 1, 1, now.step + 1});\n      }\n      if (now.num - 1 > now.step + 1 && b[now.num - 1] == '-' &&\n          !vis[1][now.num - 1]) {\n        vis[1][now.num - 1] = 1;\n        qu.push(node{now.num - 1, 1, now.step + 1});\n      }\n      if (now.num + k > now.step + 1 && a[now.num + k] == '-' &&\n          !vis[0][now.num + k]) {\n        vis[0][now.num + k] = 1;\n        qu.push(node{now.num + k, 0, now.step + 1});\n      }\n    }\n  }\n}\nint main() {\n  cin >> n >> k;\n  scanf(\"%s\", a + 1);\n  scanf(\"%s\", b + 1);\n  isSuccess = false;\n  bfs();\n  if (isSuccess)\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, water;\nchar a[2][100100];\nint v[2][100100];\nint dfs(int pos, int j) {\n  if (j > n) return 1;\n  if (a[pos][j] == 'X' || j < water || v[pos][j]) return 0;\n  v[pos][j] = 1;\n  water++;\n  int f = dfs(pos, j - 1) || dfs(1 - pos, j + m) || dfs(pos, j + 1);\n  water--;\n  return f;\n}\nint main() {\n  while (~scanf(\"%d %d\", &n, &m)) {\n    water = 1;\n    scanf(\"%s %s\", a[0] + 1, a[1] + 1);\n    if (dfs(0, 1))\n      printf(\"YES\\n\");\n    else\n      printf(\"NO\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline T Max(T a, T b) {\n  if (a > b)\n    return a;\n  else\n    return b;\n}\ntemplate <class T>\ninline T Min(T a, T b) {\n  if (a < b)\n    return a;\n  else\n    return b;\n}\ntemplate <class T>\ninline T gcd(T a, T b) {\n  if (a < 0) return gcd(-a, b);\n  if (b < 0) return gcd(a, -b);\n  return (b == 0) ? a : gcd(b, a % b);\n}\ntemplate <class T>\ninline T lcm(T a, T b) {\n  if (a < 0) return lcm(-a, b);\n  if (b < 0) return lcm(a, -b);\n  return a * (b / gcd(a, b));\n}\ntemplate <class T>\ninline T TripleMax(T a, T b, T c) {\n  return Max(Max(a, b), c);\n}\ntemplate <class T>\ninline T TripleMin(T a, T b, T c) {\n  return Min(Min(a, b), c);\n}\ntypedef struct _node {\n  int level, height, left;\n} node;\nconst int maxn = 100005;\nint dis[2][maxn];\nstring wall[2];\nint n, k;\nqueue<node> q;\nint main(int argc, const char* argv[]) {\n  node d;\n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < maxn; j++) {\n      dis[i][j] = -1;\n    }\n  }\n  cin >> n >> k >> wall[0] >> wall[1];\n  while (!q.empty()) {\n    q.pop();\n  }\n  d.level = -1;\n  d.height = 0;\n  d.left = 0;\n  q.push(d);\n  dis[0][0] = 1;\n  while (!q.empty()) {\n    node tmp = q.front();\n    q.pop();\n    d = tmp;\n    if (d.height + k >= n) {\n      cout << \"YES\\n\";\n      return 0;\n    }\n    if (wall[d.left][d.height + 1] == '-') {\n      if (dis[d.left][d.height + 1] == -1) {\n        dis[d.left][d.height + 1] = 1;\n        d.height++;\n        d.level++;\n        q.push(d);\n      }\n    }\n    d = tmp;\n    if (wall[d.left][d.height - 1] == '-') {\n      if (d.level + 1 < d.height - 1) {\n        if (dis[d.left][d.height - 1] == -1) {\n          dis[d.left][d.height - 1] = 1;\n          d.height--;\n          d.level++;\n          q.push(d);\n        }\n      }\n    }\n    d = tmp;\n    if (wall[1 - d.left][d.height + k] == '-') {\n      if (dis[1 - d.left][d.height + k] == -1) {\n        dis[1 - d.left][d.height + k] = 1;\n        d.height += k;\n        d.level++;\n        d.left = 1 - d.left;\n        q.push(d);\n      }\n    }\n  }\n  cout << \"NO\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct data {\n  int X, v, l;\n  data() {}\n  data(int xx, int vv, int ll) { X = xx, v = vv, l = ll; }\n};\nstring G[2];\nint n, k, visited[2][100008];\nstring bfs() {\n  queue<data> Q;\n  Q.push(data(0, 0, -1));\n  visited[0][0] = 1;\n  int v, dir, l;\n  data top;\n  while (!Q.empty()) {\n    top = Q.front();\n    Q.pop();\n    if (top.v == n) return \"YES\";\n    v = top.v + 1, dir = top.X, l = top.l + 1;\n    if (v <= n && G[dir][v] == '-' && !visited[dir][v] && v > l) {\n      visited[dir][v] = 1;\n      Q.push(data(dir, v, l));\n    }\n    v = top.v - 1, dir = top.X, l = top.l + 1;\n    if (v >= 0 && G[dir][v] == '-' && !visited[dir][v] && v > l) {\n      visited[dir][v] = 1;\n      Q.push(data(dir, v, l));\n    }\n    v = min(top.v + k, n), dir = top.X ^ 1, l = top.l + 1;\n    if (v <= n && G[dir][v] == '-' && !visited[dir][v] && v > l) {\n      visited[dir][v] = 1;\n      Q.push(data(dir, v, l));\n    }\n  }\n  return \"NO\";\n}\nint main() {\n  cin >> n >> k;\n  cin >> G[0] >> G[1];\n  G[0].push_back('-');\n  G[1].push_back('-');\n  cout << bfs() << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nint pd[2][150100];\nint x[3] = {0, 0, 1};\nint y[3] = {1, -1, k};\nstruct node {\n  int h, id, t;\n};\nqueue<node> q;\nvoid bfs() {\n  node u, p;\n  u.id = 0;\n  u.t = 0;\n  u.h = 1;\n  pd[0][1] = 1;\n  q.push(u);\n  while (!q.empty()) {\n    p = q.front();\n    q.pop();\n    for (int i = 0; i < 3; i++) {\n      u = p;\n      u.id = (u.id + x[i]) % 2;\n      u.h += y[i];\n      u.t += 1;\n      if (u.h > n) {\n        cout << \"YES\";\n        return;\n      }\n      if (u.h > u.t)\n        if (pd[u.id][u.h] == 0) {\n          pd[u.id][u.h] = 1;\n          q.push(u);\n        }\n    }\n  }\n  cout << \"NO\";\n}\nint main() {\n  char c;\n  cin >> n >> k;\n  y[2] = k;\n  memset(pd, 0, sizeof(pd));\n  for (int i = 1; i <= n; i++) {\n    cin >> c;\n    if (c == 'X') pd[0][i] = 1;\n  }\n  for (int i = 1; i <= n; i++) {\n    cin >> c;\n    if (c == 'X') pd[1][i] = 1;\n  }\n  node u;\n  bfs();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst long long LLINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = 1.0 / 0.0f;\nconst double pi = acos(-1.0);\nconst double eps = 1e-8;\nconst int MOD = 1000000007;\ninline int LC(int x) { return x << 1; }\ninline int RC(int x) { return (x << 1) | 1; }\ninline bool eq0(double x) { return fabs(x) < eps; }\ninline bool eq(double x, double y) { return fabs(x - y) < eps; }\ninline bool ls(double x, double y) { return x + eps < y; }\ninline bool gr(double x, double y) { return x - eps > y; }\ninline bool greq(double x, double y) { return x + eps >= y; }\ninline bool lseq(double x, double y) { return x - eps <= y; }\ninline double fmax(double x, double y) { return gr(x, y) ? x : y; }\ninline double fmin(double x, double y) { return ls(x, y) ? x : y; }\ntemplate <class T>\ninline T sqr(T x) {\n  return x * x;\n}\nint n, k;\nstring w[2];\nbool f[2][100010];\nvoid dp(int water, int wall, int level) {\n  level = min(n, level);\n  if (water >= level) return;\n  if (f[wall][level]) return;\n  if (w[wall][level] == 'X') return;\n  f[wall][level] = 1;\n  dp(water + 1, wall ^ 1, level + k);\n  dp(water + 1, wall, level - 1);\n  dp(water + 1, wall, level + 1);\n}\nint main() {\n  cin >> n >> k;\n  cin >> w[0] >> w[1];\n  w[0] += '-';\n  w[1] += '-';\n  dp(-1, 0, 0);\n  cout << (f[0][n] || f[1][n] ? \"YES\" : \"NO\") << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\nimport static java.lang.Math.*;\n\npublic class Main implements Runnable {\n\t\n\tclass Position {\n\t\tint wall, pos, dist;\n\t\t\n\t\tpublic Position(int wall, int pos, int dist) {\n\t\t\tthis.wall = wall;\n\t\t\tthis.pos = pos;\n\t\t\tthis.dist = dist;\n\t\t}\n\t}\n\n\tvoid solve() throws Exception {\n\t\tint n = sc.nextInt(), k = sc.nextInt();\n\t\tString wall1 = in.readLine(), wall2 = in.readLine();\n\t\tboolean[] visited1 = new boolean[n], visited2 = new boolean[n];\n\t\tQueue<Position> q = new ArrayDeque<Position>();\n\t\tq.offer(new Position(1, 0, -1));\n\t\tvisited1[0] = true;\n\t\twhile (!q.isEmpty()) {\n\t\t\tPosition p = q.poll();\n\t\t\tif (p.pos + k >= n) {\n\t\t\t\tout.println(\"YES\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tString curwall = p.wall == 1 ? wall1 : wall2;\n\t\t\tString otherwall = p.wall == 1 ? wall2 : wall1;\n\t\t\tboolean[] curvisited = p.wall == 1 ? visited1 : visited2;\n\t\t\tboolean[] othervisited = p.wall == 1 ? visited2 : visited1;\n\t\t\tint otherwallnum = p.wall == 1 ? 2 : 1;\n\t\t\tif (p.pos - 1 > p.dist + 1 && curwall.charAt(p.pos - 1) == '-' && !curvisited[p.pos - 1]) {\n\t\t\t\tPosition newp = new Position(p.wall, p.pos - 1, p.dist + 1);\n\t\t\t\tq.offer(newp);\n\t\t\t\tcurvisited[p.pos - 1] = true;\n\t\t\t}\n\t\t\tif (curwall.charAt(p.pos + 1) == '-' && !curvisited[p.pos + 1]) {\n\t\t\t\tPosition newp = new Position(p.wall, p.pos + 1, p.dist + 1);\n\t\t\t\tq.offer(newp);\n\t\t\t\tcurvisited[p.pos + 1] = true;\n\t\t\t}\n\t\t\tif (otherwall.charAt(p.pos + k) == '-' && !othervisited[p.pos + k]) {\n\t\t\t\tPosition newp = new Position(otherwallnum, p.pos + k, p.dist + 1);\n\t\t\t\tq.offer(newp);\n\t\t\t\tothervisited[p.pos + k] = true;\n\t\t\t}\n\t\t}\n\t\tout.println(\"NO\");\n\t}\n\t\n\tBufferedReader in;\n\tPrintWriter out;\n\tFastScanner sc;\n\t\n\tstatic Throwable uncaught;\n\t\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\t//System.setOut(new PrintStream(\"test.txt\"));\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsc = new FastScanner(in);\n\t\t\tsolve();\n\t\t} catch (Throwable t) {\n\t\t\tMain.uncaught = t;\n\t\t} finally {\n\t\t\tout.close();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws Throwable {\n\t\tThread t = new Thread(null, new Main(), \"\", 128 * 1024 * 1024);\n\t\tt.start();\n\t\tt.join();\n\t\tif (uncaught != null) {\n\t\t\tthrow uncaught;\n\t\t}\n\t}\n\n}\n\nclass FastScanner {\n\t\n\tBufferedReader reader;\n\tStringTokenizer strTok;\n\t\n\tpublic FastScanner(BufferedReader reader) {\n\t\tthis.reader = reader;\n\t}\n\t\n\tpublic String nextToken() throws IOException {\n\t\twhile (strTok == null || !strTok.hasMoreTokens()) {\n\t\t\tstrTok = new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn strTok.nextToken();\n\t}\n\t\n\tpublic int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\t\n\tpublic long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\t\n\tpublic double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\t\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 200008;\nint n, k, l, r;\nchar g[2][maxn];\nbool f[2][maxn];\nstruct arr {\n  int t, s, x;\n} h[maxn];\nbool Add(int t, int s, int x) {\n  if (t >= x) return 0;\n  if (x > n) return 1;\n  if (f[s][x]) return 0;\n  if (g[s][x] == 'X') return 0;\n  f[s][x] = 1;\n  ++r;\n  h[r].t = t;\n  h[r].s = s;\n  h[r].x = x;\n  return 0;\n}\nbool Work() {\n  h[1].t = 0;\n  h[1].s = 0;\n  h[1].x = 1;\n  l = 1, r = 1;\n  f[0][1] = 1;\n  while (l <= r) {\n    int t = h[l].t, s = h[l].s, x = h[l].x;\n    ++l;\n    if (Add(t + 1, s, x + 1)) return 1;\n    if (Add(t + 1, s, x - 1)) return 1;\n    if (Add(t + 1, s ^ 1, x + k)) return 1;\n  }\n  return 0;\n}\nint main() {\n  scanf(\"%d%d%*c\", &n, &k);\n  scanf(\"%s\", &g[0][1]);\n  scanf(\"%s\", &g[1][1]);\n  if (Work())\n    printf(\"YES\\n\");\n  else\n    printf(\"NO\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint ds[2][100001];\nstring mmap[2];\nqueue<pair<int, int> > q;\nint dj[] = {1, -1, 100000};\nint main() {\n  int n, k;\n  cin >> n >> k;\n  for (int first = 0; first < 2; first++) cin >> mmap[first];\n  dj[2] = k;\n  memset(ds, 0x3f, sizeof(ds));\n  q.push(make_pair(0, 0));\n  ds[0][0] = 0;\n  string res = \"NO\";\n  while (!q.empty()) {\n    int ci = q.front().first;\n    int cj = q.front().second;\n    q.pop();\n    if (cj - ds[ci][cj] < 0) continue;\n    if (cj + k >= n || cj + 1 >= n) {\n      res = \"YES\";\n      break;\n    }\n    for (int first = 0; first < 3; first++) {\n      int ni = (first != 2) ? ci : !ci;\n      int nj = cj + dj[first];\n      if (nj >= 0 && nj < n && mmap[ni][nj] == '-' &&\n          ds[ni][nj] > ds[ci][cj] + 1) {\n        ds[ni][nj] = ds[ci][cj] + 1;\n        q.push(make_pair(ni, nj));\n      }\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k, dp[2][200000];\nchar c[2][200000];\nvector<pair<long long, long long>> v[2][200000];\nsigned main() {\n  cin.tie(0);\n  cout.tie(0);\n  ios_base::sync_with_stdio(false);\n  cin >> n >> k;\n  for (long long i = 0; i <= 1; i++) {\n    for (long long j = 1; j <= n; j++) {\n      cin >> c[i][j];\n      dp[i][j] = 1000000007;\n    }\n  }\n  for (long long j = 1; j <= n; j++) {\n    for (long long i = 0; i <= 1; i++) {\n      if (c[i][j] == 'X') continue;\n      if (c[i][j - 1] == '-') {\n        v[i][j].push_back({i, j - 1});\n      }\n      if (c[i][j + 1] == '-') {\n        v[i][j].push_back({i, j + 1});\n      }\n      if (j + k <= n and c[!i][j + k] == '-') {\n        v[i][j].push_back({!i, j + k});\n      }\n    }\n  }\n  dp[0][1] = 0;\n  queue<pair<long long, long long>> pq;\n  pq.push({0, 1});\n  while (!pq.empty()) {\n    long long x = pq.front().first;\n    long long y = pq.front().second;\n    pq.pop();\n    if (dp[x][y] < y and y + k > n) return cout << \"YES\", 0;\n    for (auto z : v[x][y]) {\n      long long x1 = z.first, y1 = z.second;\n      if (dp[x1][y1] > dp[x][y] + 1 and dp[x][y] + 1 < y1) {\n        dp[x1][y1] = dp[x][y] + 1;\n        pq.push({x1, y1});\n      }\n    }\n  }\n  for (long long i = 0; i <= 1; i++) {\n    for (long long j = 1; j <= n; j++) {\n      if (dp[i][j] < j and j + k > n) {\n        return cout << \"YES\", 0;\n      }\n    }\n  }\n  cout << \"NO\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 5;\nint n, k;\nstring wall[2];\nbool mark[2][maxn];\nbool bfs(int w = 0, int ind = 0) {\n  queue<pair<pair<int, int>, int>> q;\n  q.push({{w, ind}, 0});\n  mark[w][ind] = true;\n  while (!q.empty()) {\n    auto [tp, ut] = q.front();\n    auto [uw, uind] = tp;\n    if (uind >= n) return true;\n    q.pop();\n    if (ut > uind) continue;\n    int dw[] = {0, 0, 1};\n    int di[] = {-1, 1, k};\n    for (int i = 0; i < 3; i++) {\n      int nw = (uw + dw[i]) % 2, nind = uind + di[i];\n      if (nind >= 0 && (!mark[nw][nind]) && wall[nw][nind] == '-') {\n        q.push({{nw, nind}, ut + 1});\n        mark[nw][nind] = true;\n      }\n    }\n  }\n  return false;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cout.precision(16);\n  if (0) {\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n  }\n  cin >> n >> k >> wall[0] >> wall[1];\n  for (int i = 0; i <= k; i++) {\n    wall[0] += '-';\n    wall[1] += '-';\n  }\n  cout << (bfs() ? \"YES\" : \"NO\") << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class B125 {\npublic static void main(String[] args) throws IOException\n{\n    input.init(System.in);\n    int n = 2, m = input.nextInt(), x = input.nextInt();\n    char[][] grid = new char[n][m];\n    for(int i = 0; i<n; i++) grid[i] = input.next().toCharArray();\n    boolean res = false;\n    Queue<Integer> qi = new LinkedList<Integer>(), qj = new LinkedList<Integer>();\n    qi.add(0);\n    qj.add(0);\n    int[] di = new int[]{0, 0, 1, -1};\n    int[] dj = new int[]{1, -1, x, x};\n    int[][] ds = new int[n][m];\n    for(int[] A : ds) Arrays.fill(A, 987654321);\n    ds[0][0] = 0;\n    while(!qi.isEmpty())\n    {\n        int ati = qi.poll(), atj = qj.poll();\n        //System.out.println(ati+\" \"+atj);\n        for(int k = 0; k<4; k++)\n        {\n            int ni = ati + di[k], nj = atj + dj[k];\n            if(ni < 0 | ni >= n || nj < 0) continue;\n            if(nj >= m)\n            {\n                res = true;\n                break;\n            }\n            //System.out.println(ni+\"   \"+nj);\n            int nd = ds[ati][atj] + 1;\n            if(nd >= ds[ni][nj] || nd > nj || grid[ni][nj] == 'X') continue;\n            ds[ni][nj] = nd;\n            qi.add(ni);\n            qj.add(nj);\n        }\n    }\n    System.out.println(res ? \"YES\" : \"NO\");\n}\npublic static class input {\n    static BufferedReader reader;\n    static StringTokenizer tokenizer;\n\n    /** call this method to initialize reader for InputStream */\n    static void init(InputStream input) {\n        reader = new BufferedReader(\n                     new InputStreamReader(input) );\n        tokenizer = new StringTokenizer(\"\");\n    }\n\n    /** get next word */\n    static String next() throws IOException {\n        while ( ! tokenizer.hasMoreTokens() ) {\n            //TODO add check for eof if necessary\n            tokenizer = new StringTokenizer(\n                   reader.readLine() );\n        }\n        return tokenizer.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return Integer.parseInt( next() );\n    }\n    \n    static double nextDouble() throws IOException {\n        return Double.parseDouble( next() );\n    }\n    static long nextLong() throws IOException {\n        return Long.parseLong( next() );\n    }\n}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint best[100010][2];\nint pode[100010][2];\nchar lef[100010], righ[100010];\nint main() {\n  int n, k;\n  scanf(\"%d %d\", &n, &k);\n  scanf(\"%s\", lef);\n  scanf(\"%s\", righ);\n  memset(pode, 0, sizeof(pode));\n  for (int i = 0; i < n; i++) {\n    pode[i][0] = (lef[i] == '-');\n    pode[i][1] = (righ[i] == '-');\n  }\n  for (int i = 0; i < n; ++i) best[i][0] = (1 << 29), best[i][1] = (1 << 29);\n  priority_queue<pair<int, pair<int, int> > > cola;\n  cola.push(make_pair(0, make_pair(0, 0)));\n  best[0][0] = 0;\n  while (!cola.empty()) {\n    int w = -cola.top().first;\n    int wall = cola.top().second.first;\n    int lado = cola.top().second.second;\n    cola.pop();\n    if (best[wall][lado] < w) continue;\n    if (wall > n) {\n      cout << \"YES\\n\";\n      return 0;\n    }\n    if (wall + 1 >= n || wall + k >= n) {\n      cout << \"YES\\n\";\n      return 0;\n    }\n    if (pode[wall + 1][lado] && w + 1 < best[wall + 1][lado]) {\n      best[wall + 1][lado] = w + 1;\n      cola.push(make_pair(-(w + 1), make_pair(wall + 1, lado)));\n    }\n    if (wall - 1 >= 0 && w + 1 <= wall - 1 && pode[wall - 1][lado] &&\n        w + 1 < best[wall - 1][lado]) {\n      best[wall - 1][lado] = w + 1;\n      cola.push(make_pair(-(w + 1), make_pair(wall - 1, lado)));\n    }\n    if (pode[wall + k][1 - lado] && w + 1 < best[wall + k][1 - lado]) {\n      best[wall + k][1 - lado] = w + 1;\n      cola.push(make_pair(-(w + 1), make_pair(wall + k, 1 - lado)));\n    }\n  }\n  cout << \"NO\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar s[2][102012];\nqueue<int> Q1, Q2;\nint ans, n, k, i;\nint f[2][102012];\nint main() {\n  scanf(\"%d%d \", &n, &k);\n  gets(s[0]);\n  gets(s[1]);\n  for (i = 0; i < n; ++i) f[1][i] = f[0][i] = 1000002012;\n  Q1.push(0);\n  Q2.push(0);\n  f[0][0] = 0;\n  while (Q1.size()) {\n    int Now = Q1.front(), side = Q2.front();\n    Q1.pop();\n    Q2.pop();\n    if (Now + 1 >= n) {\n      ans = f[side][Now] + 1;\n      break;\n    } else if (s[side][Now + 1] != 'X' && f[side][Now + 1] > f[side][Now] + 1) {\n      f[side][Now + 1] = f[side][Now] + 1;\n      Q1.push(Now + 1);\n      Q2.push(side);\n    }\n    if (Now - 1 >= 0 && s[side][Now - 1] != 'X' && Now - 1 > f[side][Now] &&\n        f[side][Now - 1] > f[side][Now] + 1) {\n      f[side][Now - 1] = f[side][Now] + 1;\n      Q1.push(Now - 1);\n      Q2.push(side);\n    }\n    if (Now + k >= n) {\n      ans = f[side][Now] + 1;\n      break;\n    } else if (s[!side][Now + k] != 'X' &&\n               f[!side][Now + k] > f[side][Now] + 1) {\n      f[!side][Now + k] = f[side][Now] + 1;\n      Q1.push(Now + k);\n      Q2.push(!side);\n    }\n  }\n  if (ans == 0)\n    printf(\"NO\");\n  else\n    printf(\"YES\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\nint t[2][100000];\nint main() {\n  int n, k;\n  cin >> n >> k;\n  string s[2];\n  cin >> s[0] >> s[1];\n  queue<pair<int, int> > Q;\n  memset(t, -1, sizeof(t));\n  t[0][0] = 0;\n  Q.push(pair<int, int>(0, 0));\n  int dx[] = {-1, 1, k};\n  while (!Q.empty()) {\n    pair<int, int> p = Q.front();\n    Q.pop();\n    int lr = p.first;\n    int pos = p.second;\n    int tm = t[lr][pos];\n    for (int i = 0; i < (int)3; ++i) {\n      int xx = pos + dx[i];\n      if (xx < 0) continue;\n      if (xx >= n) {\n        cout << \"YES\" << endl;\n        return 0;\n      }\n      if (i == 2) lr = !lr;\n      if (s[lr][xx] == 'X') continue;\n      if (t[lr][xx] != -1) continue;\n      if (xx <= tm) continue;\n      t[lr][xx] = tm + 1;\n      Q.push(pair<int, int>(lr, xx));\n    }\n  }\n  cout << \"NO\" << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar s[2][210000];\nint dp[2][210000], n, k;\nstruct node {\n  int a, b, t;\n  node() {}\n  node(int _a, int _b, int _t) : a(_a), b(_b), t(_t) {}\n};\nvoid cmx(int &a, int b) {\n  if (a == -1 || b < a) a = b;\n}\nint BFS() {\n  queue<node> que;\n  que.push(node(0, 1, 0));\n  int mi = 0xFFFFFFF;\n  while (!que.empty()) {\n    node tmp = que.front();\n    que.pop();\n    int ta = tmp.a, tb = tmp.b, tt = tmp.t;\n    if (tb > n) {\n      mi = min(mi, tt);\n      continue;\n    }\n    if (s[ta][tb + 1] == '-' || tb + 1 > n) {\n      if (dp[ta][tb + 1] == -1 || tt + 1 < dp[ta][tb + 1]) {\n        dp[ta][tb + 1] = tt + 1;\n        que.push(node(ta, tb + 1, tt + 1));\n      }\n    }\n    if (s[!ta][tb + k] == '-' || tb + k > n) {\n      if (dp[!ta][tb + k] == -1 || tt + 1 < dp[!ta][tb + k]) {\n        dp[!ta][tb + k] = tt + 1;\n        que.push(node(!ta, tb + k, tt + 1));\n      }\n    }\n    if (tb > tt + 2) {\n      if (s[ta][tb - 1] == '-') {\n        if (dp[ta][tb - 1] == -1 || tt + 1 < dp[ta][tb - 1]) {\n          dp[ta][tb - 1] = tt + 1;\n          que.push(node(ta, tb - 1, tt + 1));\n        }\n      }\n    }\n  }\n  return mi;\n}\nint main() {\n  while (~scanf(\"%d%d\", &n, &k)) {\n    scanf(\"%s\", s[0] + 1);\n    scanf(\"%s\", s[1] + 1);\n    memset(dp, -1, sizeof(dp));\n    int res = BFS();\n    if (res == 0xFFFFFFF)\n      puts(\"NO\");\n    else\n      puts(\"YES\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nchar s[2][100005];\nint d[2][100005];\nbool f[2][100005];\nvoid work() {\n  int i, j, x, y, ans = 0;\n  scanf(\"%d%d\", &n, &k);\n  scanf(\"%s%s\", s[0] + 1, s[1] + 1);\n  queue<pair<int, int> > q;\n  q.push(make_pair(0, 1)), f[0][1] = 1, d[0][1] = 1;\n  while (!q.empty()) {\n    x = q.front().first, y = q.front().second, q.pop();\n    if (y + k <= n && s[!x][y + k] != 'X' && !f[!x][y + k])\n      f[!x][y + k] = 1, q.push(make_pair(!x, y + k)),\n                d[!x][y + k] = d[x][y] + 1;\n    if (y + 1 <= n && s[x][y + 1] != 'X' && !f[x][y + 1])\n      f[x][y + 1] = 1, q.push(make_pair(x, y + 1)), d[x][y + 1] = d[x][y] + 1;\n    if (y - 1 > 0 && y - 1 > d[x][y] && s[x][y - 1] != 'X' && !f[x][y - 1])\n      f[x][y - 1] = 1, q.push(make_pair(x, y - 1)), d[x][y - 1] = d[x][y] + 1;\n  }\n  for (i = n - k + 1; i <= n; ++i) ans |= f[0][i] | f[1][i];\n  puts(ans ? \"YES\" : \"NO\");\n}\nint main() {\n  work();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long n, k;\n  cin >> n >> k;\n  string s1, s2;\n  cin >> s1 >> s2;\n  long long i, j;\n  i = n - 1;\n  long long c = 0LL;\n  long long f = 0LL;\n  char mat[2][n];\n  for (i = 0; i < 2; i++) {\n    for (j = 0; j < n; j++) {\n      if (i == 0) {\n        mat[0][j] = s1[i];\n      } else {\n        mat[1][j] = s2[j];\n      }\n    }\n  }\n  char fin[2][n];\n  for (i = 0; i < 2; i++) {\n    for (j = 0; j < n; j++) {\n      fin[i][j] = 'F';\n    }\n  }\n  queue<pair<long long, pair<long long, long long>>> q;\n  q.push({0, {0, 0}});\n  fin[0][0] = 'T';\n  while (q.size() > 0) {\n    long long level;\n    long long f1;\n    level = q.front().first;\n    f1 = q.front().second.first;\n    i = q.front().second.second;\n    q.pop();\n    level++;\n    if (f1 == 0) {\n      if (i - 1 >= 0 && i - 1 >= level && s1[i - 1] == '-' &&\n          fin[0][i - 1] == 'F') {\n        q.push({level, {0, i - 1}});\n        fin[0][i - 1] = 'T';\n      }\n      if (i + 1 >= n) {\n        cout << \"YES\";\n        return 0;\n      }\n      if (i + 1 < n && i + 1 >= level && s1[i + 1] == '-' &&\n          fin[0][i + 1] == 'F') {\n        q.push({level, {0, i + 1}});\n        fin[0][i + 1] = 'T';\n      }\n      if (i + k >= n) {\n        cout << \"YES\";\n        return 0;\n      }\n      if (i + k >= level && s2[i + k] == '-' && fin[1][i + k] == 'F') {\n        q.push({level, {1, i + k}});\n        fin[1][i + k] = 'T';\n      }\n      if (i - k >= 0 && i - k >= level && s2[i - k] == '-' &&\n          fin[1][i - k] == 'F') {\n        q.push({level, {1, i - k}});\n        fin[1][i - k] = 'T';\n      }\n    } else {\n      if (i - 1 >= 0 && i - 1 >= level && s2[i - 1] == '-' &&\n          fin[1][i - 1] == 'F') {\n        q.push({level, {1, i - 1}});\n        fin[1][i - 1] = 'T';\n      }\n      if (i + 1 >= n) {\n        cout << \"YES\";\n        return 0;\n      }\n      if (i + 1 < n && i + 1 >= level && s2[i + 1] == '-' &&\n          fin[1][i + 1] == 'F') {\n        q.push({level, {1, i + 1}});\n        fin[1][i + 1] = 'T';\n      }\n      if (i + k >= n) {\n        cout << \"YES\";\n        return 0;\n      }\n      if (i + k >= level && s1[i + k] == '-' && fin[0][i + k] == 'F') {\n        q.push({level, {0, i + k}});\n        fin[0][i + k] = 'T';\n      }\n      if (i - k >= 0 && i - k >= level && s1[i - k] == '-' &&\n          fin[0][i - k] == 'F') {\n        q.push({level, {1, i - k}});\n        fin[0][i - k] = 'T';\n      }\n    }\n  }\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 5;\nint n, k;\nstring wall[2];\nbool mark[2][maxn];\nint t[2][maxn];\nbool bfs() {\n  mark[0][0] = 1;\n  queue<pair<int, int>> q;\n  q.push({0, 0});\n  while (!q.empty()) {\n    int x = q.front().first;\n    int y = q.front().second;\n    q.pop();\n    if (t[x][y] > y) continue;\n    int my[] = {1, -1, k};\n    int mx[] = {0, 0, 1};\n    for (int i = 0; i < 3; i++) {\n      int newx = x + mx[i];\n      newx = newx % 2;\n      int newy = y + my[i];\n      if (newy >= n) return 1;\n      if (newy >= 0 && !mark[newx][newy] && wall[newx][newy] != 'X') {\n        q.push({newx, newy});\n        mark[newx][newy] = 1;\n        t[newx][newy] = t[x][y] + 1;\n      }\n    }\n  }\n  return 0;\n}\nint main() {\n  cin >> n >> k >> wall[0] >> wall[1];\n  if (bfs())\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.awt.Point;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic class B {\n\n\t\n\tprivate void solve() throws IOException {\n\t\tint n = nextInt();\n\t\tint k = nextInt();\n\t\t\n\t\tbyte[][] s = new byte[2][];\n\t\ts[0] = nextToken().getBytes();\n\t\ts[1] = nextToken().getBytes();\n\t\t\n\t\tint[] qy = new int[n * 2];\n\t\tint[] qx = new int[n * 2];\n\t\tint[] qt = new int[n * 2];\n\t\t\n\t\tboolean[][] used = new boolean[2][n];\n\n\t\tint l = 0;\n\t\tint r = 1;\n\t\twhile (l != r) {\n\t\t\tint t = qt[l];\n\t\t\tint x = qx[l];\n\t\t\tint y = qy[l];\n\t\t\tl++;\n\t\t\t\n\t\t\tif (x + k >= n) {\n\t\t\t\tprintln(\"YES\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif (x > t + 1 && s[y][x - 1] == '-' && !used[y][x - 1]) {\n\t\t\t\tqx[r] = x - 1;\n\t\t\t\tqy[r] = y;\n\t\t\t\tqt[r] = t + 1;\n\t\t\t\tused[y][x - 1] = true;\n\t\t\t\tr++;\n\t\t\t}\n\t\t\tif (s[y][x + 1] == '-' && !used[y][x + 1]) {\n\t\t\t\tqx[r] = x + 1;\n\t\t\t\tqy[r] = y;\n\t\t\t\tqt[r] = t + 1;\n\t\t\t\tused[y][x + 1] = true;\n\t\t\t\tr++;\n\t\t\t}\n\t\t\t\n\t\t\tint ny = (y + 1) % 2;\n\t\t\tif (s[ny][x + k] == '-' && !used[ny][x + k]) {\n\t\t\t\tqx[r] = x + k;\n\t\t\t\tqy[r] = ny;\n\t\t\t\tqt[r] = t + 1;\n\t\t\t\tused[ny][x + k] = true;\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintln(\"NO\");\n\t}\n\t\n\tprivate String nextToken() throws IOException {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tprivate int nextInt() throws NumberFormatException, IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tprivate double nextDouble() throws NumberFormatException, IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tprivate long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tprivate void print(Object o) {\n\t\twriter.print(o);\n\t}\n\n\tprivate void println(Object o) {\n\t\twriter.println(o);\n\t}\n\n\tprivate void printf(String format, Object... o) {\n\t\twriter.printf(format, o);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tlong time = System.currentTimeMillis();\n\t\tLocale.setDefault(Locale.US);\n\t\tnew B().run();\n\t\tSystem.err.printf(\"%.3f\\n\", 1e-3 * (System.currentTimeMillis() - time));\n\t}\n\n\tBufferedReader reader;\n\tStringTokenizer tokenizer;\n\tPrintWriter writer;\n\n\tprivate void run() {\n\t\ttry {\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\twriter = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\treader.close();\n\t\t\twriter.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(13);\n\t\t}\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable {\n\n\tpublic void _main() throws IOException {\n\t\tint n = nextInt();\n\t\tint k = nextInt();\n\t\tString wall1 = next();\n\t\tString wall2 = next();\n\t\tchar[] s = (wall1 + wall2).toCharArray();\n\t\tint[] q = new int[2 * n];\n\t\tint[] d = new int[2 * n];\n\t\tArrays.fill(d, -1);\n\t\td[0] = 0;\n\t\tint qt = 0;\n\t\tint qh = 1;\n\t\twhile (qt < qh) {\n\t\t\tint x = q[qt++];\t\t\t\n\t\t\t{\n\t\t\t\tint y = (x % n) + 1;\n\t\t\t\tif (y >= n) {\n\t\t\t\t\tout.println(\"YES\");\n\t\t\t\t\treturn;\n\t\t\t\t}\t\t\t\t\n\t\t\t\t// do not change the wall\n\t\t\t\tif (x >= n) {\n\t\t\t\t\ty += n;\n\t\t\t\t}\t\t\t\t\n\t\t\t\tint nd = 1 + d[x];\n\t\t\t\tif (d[y] < 0 && nd <= (y % n) && s[y] == '-') {\n\t\t\t\t\td[y] = nd;\n\t\t\t\t\tq[qh++] = y;\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tint y = (x % n) - 1;\n\t\t\t\tif (y >= 0) {\n\t\t\t\t\t// do not change the wall\n\t\t\t\t\tif (x >= n) {\n\t\t\t\t\t\ty += n;\n\t\t\t\t\t}\n\t\t\t\t\tint nd = 1 + d[x];\n\t\t\t\t\tif (d[y] < 0 && nd <= (y % n) && s[y] == '-') {\n\t\t\t\t\t\td[y] = nd;\n\t\t\t\t\t\tq[qh++] = y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tint y = (x % n) + k;\n\t\t\t\tif (y >= n) {\n\t\t\t\t\tout.println(\"YES\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// change the wall\n\t\t\t\tif (x < n) {\n\t\t\t\t\ty += n;\n\t\t\t\t}\n\t\t\t\tint nd = 1 + d[x];\n\t\t\t\tif (d[y] < 0 && nd <= (y % n) && s[y] == '-') {\n\t\t\t\t\td[y] = nd;\n\t\t\t\t\tq[qh++] = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(\"NO\");\n\t}\n\n\n\tprivate BufferedReader in;\n\tprivate PrintWriter out;\n\tprivate StringTokenizer st;\n\n\tprivate String next() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tString rl = in.readLine();\n\t\t\tif (rl == null)\n\t\t\t\treturn null;\n\t\t\tst = new StringTokenizer(rl);\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tprivate int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tprivate long nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tprivate double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tLocale.setDefault(Locale.UK);\n\t\tnew Thread(new Main()).start();\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\n\t\t\t_main();\n\n\t\t\tout.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(202);\n\t\t}\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar s[3][400005];\nint n, k, dis[400005], q[400005];\nbool can[400005];\nint geth(int x) {\n  if (x <= n)\n    return x;\n  else\n    return x - n;\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i <= 2; ++i) scanf(\"%s\", &s[i][1]);\n  for (int i = 1; i <= 2; ++i) {\n    for (int j = 1; j <= n; ++j) can[(i - 1) * n + j] = bool(s[i][j] == '-');\n  }\n  int h, t;\n  bool flag = 0;\n  for (int i = 1; i <= 2 * n; ++i) dis[i] = 214748364;\n  h = 0;\n  q[t = 1] = 1;\n  dis[1] = 0;\n  while (h != t) {\n    int x = q[++h];\n    if (geth(x) <= dis[x]) continue;\n    if (x == n || x == 2 * n || geth(x) > n - k) {\n      puts(\"YES\");\n      flag = 1;\n      break;\n    }\n    if (can[x + 1] && dis[x + 1] > dis[x] + 1) {\n      dis[x + 1] = dis[x] + 1;\n      q[++t] = x + 1;\n    }\n    if (x != 1 && x != n + 1 && can[x - 1] && dis[x - 1] > dis[x] + 1) {\n      dis[x - 1] = dis[x] + 1;\n      q[++t] = x - 1;\n    }\n    if (x <= n) {\n      if (can[x + n + k] && dis[x + n + k] > dis[x] + 1) {\n        dis[x + n + k] = dis[x] + 1;\n        q[++t] = x + n + k;\n      }\n    } else {\n      if (can[x - n + k] && dis[x - n + k] > dis[x] + 1) {\n        dis[x - n + k] = dis[x] + 1;\n        q[++t] = x - n + k;\n      }\n    }\n  }\n  if (!flag) puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "\ndef bfs(n):\n    visited=[False]*(2*n)\n    queue=[]\n    queue2=[]\n    queue.append(0)\n    queue2.append(0)\n    visited[0]=True\n    flag=True\n    water=0\n    while queue and flag:\n        s=queue.pop(0)\n        water= queue2.pop(0)\n        for i in graph[s]:\n            if not visited[i]:\n                a=0\n                #print(water,i)\n                if i>=n:\n                    a=i-n\n                else:\n                    a=i\n                if a>water:\n                    if i==n-1 or i==2*n-1:\n                        flag=False\n                    else:\n                        queue.append(i)\n                        queue2.append(water+1)\n                        visited[i]=True\n    return not flag\n\n\n\nn,k=map(int,input().split())\nl=input()\nr=input()\ngraph=[]\nfor i in range(n):\n    graph.append([])\n    if l[i]=='-':\n        if i+1<n:\n            if l[i+1]=='-':\n                graph[i].append(i+1)\n        if i-1>=0:\n            if l[i-1]=='-':\n                graph[i].append(i-1)\n        if i+k<n:\n            if r[i+k]=='-':\n                graph[i].append(n+i+k)\n        else:\n            graph[i].append(2*n-1)\nfor i in range(n):\n    graph.append([])\n    if r[i]=='-':\n        if i+1<n:\n            if r[i+1]=='-':\n                graph[n+i].append(n+i+1)\n        if i-1>=0:\n            if r[i-1]=='-':\n                graph[n+i].append(n+i-1)\n        if i+k<n:\n            if l[i+k]=='-':\n                graph[n+i].append(i+k)\n        else:\n            graph[n+i].append(n-1)\n#print(graph)  \nif n==1:\n    print(\"YES\")\nelif bfs(n):\n    print(\"YES\")\nelse:\n    print(\"NO\")      \n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200010, MOD = 1e9 + 7, sn = 500;\nint n, k, wl;\nbool vs[2][N];\nchar w[2][N];\nvoid dfs(int wa, int bl) {\n  if (bl >= n) {\n    cout << \"YES\";\n    exit(0);\n  }\n  if (w[wa][bl] == 'X' || vs[wa][bl] || wl > bl) return;\n  vs[wa][bl] = 1;\n  wl++;\n  dfs(wa ^ 1, bl + k);\n  dfs(wa, bl + 1);\n  dfs(wa, bl - 1);\n  wl--;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  for (int i = 0; i < n; i++) cin >> w[0][i];\n  for (int i = 0; i < n; i++) cin >> w[1][i];\n  dfs(0, 0);\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nenum Side { LEFT, RIGHT };\nint main(int argc, char *argv[]) {\n  int height, jump;\n  cin >> height >> jump;\n  cin.ignore();\n  char left[height];\n  char right[height];\n  cin.getline(left, height + 1);\n  cin.getline(right, height + 1);\n  int curr_height = 0;\n  queue<int> choices;\n  queue<Side> sides;\n  queue<int> water_level;\n  vector<bool> left_visited(height);\n  vector<bool> right_visited(height);\n  Side side = LEFT;\n  int water;\n  choices.push(0);\n  sides.push(LEFT);\n  water_level.push(-1);\n  left_visited[0] = true;\n  while (!choices.empty()) {\n    curr_height = choices.front();\n    if (curr_height + jump >= height) {\n      cout << \"YES\" << endl;\n      return 0;\n    }\n    choices.pop();\n    side = sides.front();\n    sides.pop();\n    water = water_level.front();\n    water_level.pop();\n    if (curr_height == water) {\n      continue;\n    }\n    if (side == LEFT) {\n      if (!right_visited[curr_height + jump] &&\n          right[curr_height + jump] != 'X') {\n        choices.push(curr_height + jump);\n        right_visited[curr_height + jump] = true;\n        sides.push(RIGHT);\n        water_level.push(water + 1);\n      }\n      if (!left_visited[curr_height + 1] && left[curr_height + 1] != 'X') {\n        choices.push(curr_height + 1);\n        left_visited[curr_height + 1] = true;\n        sides.push(LEFT);\n        water_level.push(water + 1);\n      }\n      if (water < curr_height - 1 && !left_visited[curr_height - 1] &&\n          left[curr_height - 1] != 'X') {\n        choices.push(curr_height - 1);\n        left_visited[curr_height - 1] = true;\n        sides.push(LEFT);\n        water_level.push(water + 1);\n      }\n    } else {\n      if (!left_visited[curr_height + jump] &&\n          left[curr_height + jump] != 'X') {\n        choices.push(curr_height + jump);\n        left_visited[curr_height + jump] = true;\n        sides.push(LEFT);\n        water_level.push(water + 1);\n      }\n      if (!right_visited[curr_height + 1] && right[curr_height + 1] != 'X') {\n        choices.push(curr_height + 1);\n        right_visited[curr_height + 1] = true;\n        sides.push(RIGHT);\n        water_level.push(water + 1);\n      }\n      if (water < curr_height - 1 && !right_visited[curr_height - 1] &&\n          right[curr_height - 1] != 'X') {\n        choices.push(curr_height - 1);\n        right_visited[curr_height - 1] = true;\n        sides.push(RIGHT);\n        water_level.push(water + 1);\n      }\n    }\n  }\n  cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long inf = 1e18;\nconst long long mod = 1e17 + 7;\nconst long long N = 1e5 + 5;\nlong long n, k, d[N][2], f = 0;\nstring a[2];\nqueue<pair<long long, long long>> q;\nlong long valid(long long x, long long y) {\n  if (x < 0) return 0;\n  if (a[y][x] == 'X') return 0;\n  if (d[x][y] != 0) return 0;\n  return 1;\n}\nvoid bfs() {\n  while (!q.empty()) {\n    pair<long long, long long> top = q.front();\n    q.pop();\n    long long x = top.first, y = top.second;\n    if (valid(x + 1, y)) {\n      d[x + 1][y] = d[x][y] + 1;\n      q.push(make_pair(x + 1, y));\n    }\n    if (valid(x - 1, y) && x + 1 > d[x][y] + 1) {\n      d[x - 1][y] = d[x][y] + 1;\n      q.push(make_pair(x - 1, y));\n    }\n    if (x + k >= n) {\n      f = 1;\n      return;\n    } else {\n      if (valid(x + k, 1 - y)) {\n        d[x + k][1 - y] = d[x][y] + 1;\n        q.push(make_pair(x + k, 1 - y));\n      }\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  memset(d, 0, sizeof(d));\n  cin >> n >> k >> a[0] >> a[1];\n  d[0][0] = 1;\n  q.push(make_pair(0, 0));\n  bfs();\n  if (f)\n    cout << \"YES\";\n  else\n    cout << \"NO\";\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.awt.Point;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Properties;\nimport java.util.Stack;\n\n/**\n * Works good for CF\n * @author cykeltillsalu\n */\npublic class Jumper {\n\n\t//some local config\n\tstatic boolean test = false;\n\tstatic String testDataFile = \"testdata.txt\";\n\tstatic String feedFile = \"feed.txt\";\n\tCompetitionType type = CompetitionType.CF;\n\tprivate static String ENDL = \"\\n\";\n\n\tclass State{\n\t\tint pos, wall, time;\n\n\t\tpublic State(int pos, int wall, int time) {\n\t\t\tsuper();\n\t\t\tthis.pos = pos;\n\t\t\tthis.wall = wall;\n\t\t\tthis.time = time;\n\t\t}\n\t\t\n\t}\n\t\n\t// solution\n\tprivate void solve() throws Throwable {\n\t\t\n\t\tint n = iread(), k = iread();\n\t\t\n\t\tboolean[][] free = new boolean[2][n]; \n\t\tint[][] min = new int[2][n];\n\t\tfor (int i = 0; i < min.length; i++) {\n\t\t\tArrays.fill(min[i], Integer.MAX_VALUE/2);\t\t\n\t\t}\n\t\tmin[0][0] = 0;\n\t\t\n\t\tString r = wread();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfree[0][i] = r.charAt(i) != 'X';\n\t\t}\n\t\t\n\t\tr = wread();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfree[1][i] = r.charAt(i) != 'X';\n\t\t}\n\t\tStack<State> stack = new Stack<Jumper.State>();\n\t\tstack.push(new State(0, 0, 0));\n\t\tboolean win = false;\n\t\tout: while (stack.size() > 0) {\n\t\t\tState pop = stack.pop();\n\t\t\t\n\t\t\tint pos = pop.pos;\n\t\t\tint wall = pop.wall;\n\t\t\tint time = pop.time;\n\t\t\t\n\t\t\tif(time > pos){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(pos >= n -k){\n\t\t\t\twin = true;\n\t\t\t\tbreak out;\n\t\t\t}\n\t\t\t\n\t\t\tif(pos > 0){\n\t\t\t\tif(free[wall][pos-1] && min[wall][pos-1] > time + 1){\n\t\t\t\t\tstack.push(new State(pos -1, wall, time + 1));\n\t\t\t\t\tmin[wall][pos-1] = Math.min(time + 1, min[wall][pos-1]);\n\t\t\t\t}\n\t\t\t}\t\n\t\t\t\n\t\t\tif(pos < n -1 ){\n\t\t\t\tif(free[wall][pos+1] && min[wall][pos+1] > time + 1){\n\t\t\t\t\tstack.push(new State(pos +1, wall, time + 1));\n\t\t\t\t\tmin[wall][pos+1] = Math.min(time + 1, min[wall][pos+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint nextWall = (wall + 1) % 2;\n\t\t\tif(free[nextWall][pos + k] && min[nextWall][pos + k] > time + 1){\n\t\t\t\tstack.push(new State(pos +k, nextWall, time + 1));\n\t\t\t\tmin[nextWall][pos+k] = Math.min(time + 1, min[nextWall][pos+k]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tString ans = win ? \"YES\" : \"NO\";\n\t\t\n\t\tSystem.out.println(ans);\n\t}\n\t\n\tpublic int iread() throws Exception {\n\t\treturn Integer.parseInt(wread());\n\t}\n\n\tpublic double dread() throws Exception {\n\t\treturn Double.parseDouble(wread());\n\t}\n\n\tpublic long lread() throws Exception {\n\t\treturn Long.parseLong(wread());\n\t}\n\n\tpublic String wread() throws IOException {\n\t\tStringBuilder b = new StringBuilder();\n\t\tint c;\n\t\tc = in.read();\n\t\twhile (c >= 0 && c <= ' ')\n\t\t\tc = in.read();\n\t\tif (c < 0)\n\t\t\treturn \"\";\n\t\twhile (c > ' ') {\n\t\t\tb.append((char) c);\n\t\t\tc = in.read();\n\t\t}\n\t\treturn b.toString();\n\t}\n\n\tpublic static void main(String[] args) throws Throwable {\n\t\t\n\t\tif(test){ //run all cases from testfile:\n\t\t\tBufferedReader testdataReader = new BufferedReader(new FileReader(testDataFile));\n\t\t\tString readLine = testdataReader.readLine();\n\t\t\tint casenr = 0;\n\t\t\tout: while (true) {\n\t\t\t\tBufferedWriter w = new BufferedWriter(new FileWriter(feedFile));\n\t\t\t\tif(!readLine.equalsIgnoreCase(\"input\")){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twhile (true) {\n\t\t\t\t\treadLine = testdataReader.readLine();\n\t\t\t\t\tif(readLine.equalsIgnoreCase(\"output\")){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tw.write(readLine + \"\\n\");\n\t\t\t\t}\n\t\t\t\tw.close();\n\t\t\t\tSystem.out.println(\"Answer on case \"+(++casenr)+\": \");\n\t\t\t\t\n\t\t\t\tnew Jumper().solve();\n\t\t\t\tSystem.out.println(\"Expected answer: \");\n\t\t\t\t\n\t\t\t\t\n\t\t\t\twhile (true) {\n\t\t\t\t\treadLine = testdataReader.readLine();\n\t\t\t\t\t\n\t\t\t\t\tif(readLine == null){\n\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\tif(readLine.equalsIgnoreCase(\"input\")){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(readLine);\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"----------------\");\n\t\t\t}\n\t\t\ttestdataReader.close();\n\t\t} else { // run on server\n\t\t\tnew Jumper().solve();\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic Jumper() throws Throwable {\n\t\tif (test) {\n\t\t\tin = new BufferedReader(new FileReader(new File(feedFile)));\n\t\t}\n\t}\n\n\tInputStreamReader inp = new InputStreamReader(System.in);\n\tBufferedReader in = new BufferedReader(inp);\n\tstatic BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\n\tenum CompetitionType {CF, OTHER};\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct pt {\n  int in;\n  int ti;\n  int w;\n  pt(int in = 0, int ti = 0, int w = 0) : in(in), ti(ti), w(w) {}\n};\nint used[2][100013];\nint ground[2][100013];\nint flag = 0;\nint n, k;\nvoid dfs(pt u) {\n  used[u.w][u.in] = 1;\n  if (flag || u.in <= u.ti) return;\n  if (u.in + k >= n || u.in + 1 >= n) {\n    flag = 1;\n    return;\n  }\n  if (!used[1 - u.w][u.in + k] && !ground[1 - u.w][u.in + k]) {\n    dfs(pt(u.in + k, u.ti + 1, 1 - u.w));\n  }\n  if (u.in >= 1 && !used[u.w][u.in - 1] && !ground[u.w][u.in - 1]) {\n    dfs(pt(u.in - 1, u.ti + 1, u.w));\n  }\n  if (!used[u.w][u.in + 1] && !ground[u.w][u.in + 1]) {\n    dfs(pt(u.in + 1, u.ti + 1, u.w));\n  }\n}\nint main() {\n  memset(used, 0, sizeof(used));\n  cin >> n >> k;\n  string s1, s2;\n  cin >> s1 >> s2;\n  for (int i = 0; i < n; i++) {\n    ground[0][i] = ((int)(s1[i] == 'X'));\n    ground[1][i] = ((int)(s2[i] == 'X'));\n  }\n  dfs(pt(0, -1, 0));\n  if (flag) {\n    cout << \"YES\";\n  } else {\n    cout << \"NO\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 3e5 + 500;\nbool Grid[2][N];\nint dist[2][N];\nqueue<pair<bool, int> > q;\nstring L, R;\nint n, k;\nint main() {\n  cin >> n >> k;\n  cin >> L >> R;\n  for (int i = 0; i <= n + k; i++) {\n    if (i < n) {\n      Grid[0][i] = (L[i] == 'X');\n      Grid[1][i] = (R[i] == 'X');\n    }\n    dist[0][i] = dist[1][i] = 1e9;\n  }\n  dist[0][0] = 0;\n  q.push({0, 0});\n  int water = 0;\n  while (!q.empty()) {\n    pair<bool, int> u = q.front();\n    q.pop();\n    water = dist[u.first][u.second] + 1;\n    if (u.second - 1 >= 0 && u.second - 1 >= water) {\n      if (!Grid[u.first][u.second - 1] && dist[u.first][u.second - 1] == 1e9) {\n        dist[u.first][u.second - 1] = dist[u.first][u.second] + 1;\n        q.push({u.first, u.second - 1});\n      }\n    }\n    if (u.second + 1 >= 0) {\n      if (!Grid[u.first][u.second + 1] && dist[u.first][u.second + 1] == 1e9) {\n        dist[u.first][u.second + 1] = dist[u.first][u.second] + 1;\n        q.push({u.first, u.second + 1});\n      }\n    }\n    if (u.second + k >= 0) {\n      if (u.second + k >= n) {\n        cout << \"YES\" << endl;\n        exit(0);\n      }\n      if (!Grid[!u.first][u.second + k] &&\n          dist[!u.first][u.second + k] == 1e9) {\n        dist[!u.first][u.second + k] = dist[u.first][u.second] + 1;\n        q.push({!u.first, u.second + k});\n      }\n    }\n    water++;\n    if (u.second >= n) break;\n  }\n  bool flag = false;\n  for (int i = n - 1; i <= n + k; i++) {\n    if (dist[0][i] != 1e9 || dist[1][i] != 1e9) {\n      flag = true;\n      break;\n    }\n  }\n  flag ? puts(\"YES\") : puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 10;\nvector<int> g[2][N];\ndeque<pair<int, int> > q;\nlong long int dis[2][N];\nint main() {\n  ios::sync_with_stdio(0), cout.tie(0), cin.tie(0);\n  memset(dis[0], 63, sizeof dis[0]);\n  memset(dis[1], 63, sizeof dis[1]);\n  int n, k;\n  cin >> n >> k;\n  string s, t;\n  cin >> s >> t;\n  for (int i = 0; i < n - 1; i++) {\n    if (s[i] == '-' && s[i + 1] == '-') {\n      g[0][i + 1].push_back(i + 2);\n      g[0][i + 2].push_back(i + 1);\n    }\n  }\n  for (int i = 0; i < n - 1; i++) {\n    if (t[i] == '-' && t[i + 1] == '-') {\n      g[1][i + 1].push_back(i + 2);\n      g[1][i + 2].push_back(i + 1);\n    }\n  }\n  q.push_back({0, 1});\n  dis[0][1] = 0;\n  while (q.size()) {\n    int v = q.front().second;\n    int e = q.front().first;\n    q.pop_front();\n    for (int i = 0; i < g[e][v].size(); i++) {\n      if (g[e][v][i] > dis[e][v] + 1 && dis[e][v] + 1 < dis[e][g[e][v][i]]) {\n        dis[e][g[e][v][i]] = dis[e][v] + 1;\n        q.push_back({e, g[e][v][i]});\n      }\n    }\n    if (e == 0) {\n      if (v + k > t.size()) {\n        cout << \"YES\";\n        return 0;\n      }\n      if (t[v + k - 1] == '-' && dis[e][v] + 1 < dis[1 - e][v + k]) {\n        dis[1 - e][v + k] = dis[e][v] + 1;\n        q.push_back({1 - e, v + k});\n      }\n    } else {\n      if (v + k > s.size()) {\n        cout << \"YES\";\n        return 0;\n      }\n      if (s[v + k - 1] == '-' && dis[e][v] + 1 < dis[1 - e][v + k]) {\n        dis[1 - e][v + k] = dis[e][v] + 1;\n        q.push_back({1 - e, v + k});\n      }\n    }\n  }\n  for (int i = 0; i < 2; i++) {\n    for (int j = max(0, n - k + 1); j < N; j++) {\n      if (dis[i][j] < 10000000) {\n        cout << \"YES\";\n        return 0;\n      }\n    }\n  }\n  cout << \"NO\";\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\n\npublic class D implements Runnable {\n\n    public static final char WALL = '-';\n    public static final char DANGEROUS_WALL = 'X';\n\n    public static final int LEFT_WALL = 0;\n    public static final int RIGHT_WALL = 1;\n    \n    private PrintWriter out = new PrintWriter(System.out, true);\n    private BufferedReader reader;\n    \n    private int n, k;\n    private char[][] walls;\n    private boolean[][] visit;\n\n    @Override\n    public void run() {\n        try {\n            String[] first = reader.readLine().split(\"\\\\s+\");\n            n = Integer.parseInt(first[0]);\n            k = Integer.parseInt(first[1]);\n            \n            char[] left = reader.readLine().toCharArray();\n            char[] right = reader.readLine().toCharArray();\n            walls = new char[][] { left, right };\n            visit = new boolean[2][n];\n            \n            boolean res = calc();\n            out.println(res ? \"YES\" : \"NO\");\n            out.flush();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public boolean calc() {\n        return dfs(0, LEFT_WALL, 0);\n    }\n\n    public boolean dfs(int position, int wallSide, int waterLevel) {\n        if (position >= n - 1) {\n            return true;\n        }\n\n        if (position < waterLevel) {\n            return false;\n        }\n        \n        int jumpPosition = position + k;\n        if (jumpPosition >= n) {\n            return true;\n        }\n        \n        visit[wallSide][position] = true;\n        \n        int oppositeWall = (wallSide + 1) % 2;\n        int newWaterLevel = waterLevel + 1;\n\n        if (step(jumpPosition, oppositeWall, newWaterLevel) || step(position + 1, wallSide, newWaterLevel)\n                || step(position - 1, wallSide, newWaterLevel)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    private boolean step(int jumpPosition, int oppositeWall, int newWaterLevel) {\n        if (canProceed(jumpPosition, oppositeWall)) {\n            if (dfs(jumpPosition, oppositeWall, newWaterLevel)) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    private boolean canProceed(int position, int wall) {\n        if (position < 0 || position >= n) {\n            return false;\n        }\n        return notVisited(position, wall) && canVisit(position, wall);\n    }\n\n    private boolean canVisit(int position, int wall) {\n        return walls[wall][position] != DANGEROUS_WALL;\n    }\n\n    private boolean notVisited(int position, int wall) {\n        return !visit[wall][position];\n    }\n\n    public D setInput(InputStream inputStream) {\n        this.reader = new BufferedReader(new InputStreamReader(inputStream));\n        return this;\n    }\n\n    public static void main(String[] args) {\n        new D().setInput(System.in).run();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, x, y, fi, fr, f[2][100100], qx[200200], qy[200200];\nchar s[2][100100];\nint main() {\n  cin >> n >> k;\n  cin >> s[0];\n  cin >> s[1];\n  f[0][0] = 1;\n  for (fr = 1; fi < fr;) {\n    x = qx[fi];\n    y = qy[fi++];\n    if (y >= n - k) {\n      puts(\"YES\");\n      return 0;\n    }\n    if (y > 0 && s[x][y - 1] == '-' && f[x][y - 1] == 0 && y > f[x][y]) {\n      f[x][y - 1] = f[x][y] + 1;\n      qx[fr] = x;\n      qy[fr++] = y - 1;\n    }\n    if (s[x][y + 1] == '-' && f[x][y + 1] == 0) {\n      f[x][y + 1] = f[x][y] + 1;\n      qx[fr] = x;\n      qy[fr++] = y + 1;\n    }\n    if (s[1 - x][y + k] == '-' && f[1 - x][y + k] == 0) {\n      f[1 - x][y + k] = f[x][y] + 1;\n      qx[fr] = 1 - x;\n      qy[fr++] = y + k;\n    }\n  }\n  puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool seen[200005];\nstruct data {\n  int node, h, water;\n  data(int a, int b, int c) : node(a), h(b), water(c) {}\n};\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  int n, k;\n  cin >> n >> k;\n  string left_wall, right_wall;\n  cin >> left_wall >> right_wall;\n  vector<vector<pair<int, int> > > G(2 * n + 1);\n  int free = 2 * n;\n  for (int i = 0; i < n; ++i) {\n    int nb = i + k;\n    if (left_wall[i] == '-') {\n      if (nb < n && right_wall[nb] == '-')\n        G[2 * i].push_back(make_pair(2 * nb + 1, k));\n      if (nb >= n) G[2 * i].push_back(make_pair(free, k));\n      if (i > 0 && left_wall[i - 1] == '-') {\n        G[2 * i].push_back(make_pair(2 * i - 2, -1));\n        G[2 * i - 2].push_back(make_pair(2 * i, 1));\n      }\n    }\n    if (right_wall[i] == '-') {\n      if (nb < n && left_wall[nb] == '-')\n        G[2 * i + 1].push_back(make_pair(2 * nb, k));\n      if (nb >= n) G[2 * i + 1].push_back(make_pair(free, k));\n      if (i > 0 && right_wall[i - 1] == '-') {\n        G[2 * i + 1].push_back(make_pair(2 * i - 1, -1));\n        G[2 * i - 1].push_back(make_pair(2 * i + 1, 1));\n      }\n    }\n  }\n  if (left_wall[n - 1] == '-') G[2 * n - 2].push_back(make_pair(free, k));\n  if (right_wall[n - 1] == '-') G[2 * n - 1].push_back(make_pair(free, k));\n  memset(seen, 0, sizeof seen);\n  seen[0] = 1;\n  queue<data> q;\n  q.push(data(0, 0, 0));\n  while (!q.empty()) {\n    data u = q.front();\n    q.pop();\n    for (int i = 0; i < G[u.node].size(); ++i) {\n      int v = G[u.node][i].first, w = G[u.node][i].second;\n      if (!seen[v]) {\n        seen[v] = true;\n        if (u.h + w <= u.water) continue;\n        if (u.h + w >= n) {\n          cout << \"YES\";\n          return 0;\n        }\n        q.push(data(v, u.h + w, u.water + 1));\n      }\n    }\n  }\n  cout << \"NO\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, i, j, used[100005][2], x, y, z;\nstring st[2];\nqueue<int> qx, qy, step;\nint main() {\n  cin >> n >> m >> st[0] >> st[1];\n  for (i = 1; i <= m; i++) {\n    st[0] += \"-\";\n    st[1] += \"-\";\n  }\n  qx.push(0);\n  qy.push(0);\n  step.push(0);\n  while (!qx.empty()) {\n    x = qx.front();\n    y = qy.front();\n    z = step.front();\n    qx.pop();\n    qy.pop();\n    step.pop();\n    if (st[y][x] == 'X') continue;\n    if (x >= n - 1) {\n      cout << \"YES\";\n      return 0;\n    }\n    if (used[x][y]) continue;\n    if (z > x) continue;\n    used[x][y] = 1;\n    qx.push(x + 1);\n    qy.push(y);\n    step.push(z + 1);\n    qx.push(x - 1);\n    qy.push(y);\n    step.push(z + 1);\n    qx.push(x + m);\n    qy.push(y ^ 1);\n    step.push(z + 1);\n  }\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\n\npublic class Solution {\n    FastScanner in;\n    PrintWriter out;\n\n    class to {\n        int x;\n        int y;\n        int time;\n        to(int x, int y, int time) {\n            this.x = x;\n            this.y = y;\n            this.time = time;\n        }\n    }\n    \n    int n, k;\n    String s1, s2;\n    boolean[] was1;\n    boolean[] was2;\n    boolean ok;\n    \n    public void solve() throws IOException {\n        n = in.nextInt();\n        k = in.nextInt();\n        ok = false;\n        s1 = in.next();\n        s2 = in.next();\n        was1 = new boolean[n];\n        was2 = new boolean[n];\n        was1[0] = true;\n        ArrayList<to> a = new ArrayList<Solution.to>();\n        int now = 0;\n        a.add(new to(0, 0, 0));\n        while (now < a.size()) {\n            to t = a.get(now);\n            if (t.y + k >= n) {\n                ok = true;\n                break;\n            }\n            if (t.x == 0) {\n                if (s1.charAt(t.y + 1) == '-') \n                    if (!was1[t.y + 1]) {\n                        a.add(new to(t.x, t.y + 1, t.time + 1));\nwas1[t.y + 1] = true;                       \n}\n                if (t.y > 0 && t.y - 1 > t.time && s1.charAt(t.y - 1) == '-') \n                    if (!was1[t.y - 1]) {\n                        a.add(new to(t.x, t.y - 1, t.time + 1));\nwas1[t.y - 1] = true;\n}\n                if (s2.charAt(t.y + k) == '-') \n                    if (!was2[t.y + k]) {\n                        a.add(new to(1 - t.x, t.y + k, t.time + 1));\nwas2[t.y + k] = true;\n}\n            } else {\n                if (s2.charAt(t.y + 1) == '-') \n                    if (!was2[t.y + 1]) {\n                        a.add(new to(t.x, t.y + 1, t.time + 1));\nwas2[t.y + 1] = true;\n}\n                if (t.y > 0 && t.y - 1 > t.time && s2.charAt(t.y - 1) == '-') \n                    if (!was2[t.y - 1]) {\n                        a.add(new to(t.x, t.y - 1, t.time + 1));\nwas2[t.y - 1] = true;\n}\n                if (s1.charAt(t.y + k) == '-') \n                    if (!was1[t.y + k]) {\n                        a.add(new to(1 - t.x, t.y + k, t.time + 1));\nwas1[t.y + k] = true;\n}\n            }           \n            now++;\n        }\n        if (ok) out.println(\"YES\"); else \n            out.println(\"NO\");\n    }\n\n    public void run() {\n        try {\n            //in = new FastScanner(new File(\"input.txt\"));\n            //out = new PrintWriter(new File(\"output.txt\"));\n\n            in = new FastScanner(System.in);\n            out = new PrintWriter(System.out);\n\n            solve();\n\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        FastScanner(InputStream f) {\n            br = new BufferedReader(new InputStreamReader(f));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String s = br.readLine();\n                    if (s == null) return s;\n                    st = new StringTokenizer(s);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        String nextLine() {\n            try {\n                return br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n    }\n\n    public static void main(String[] arg) {\n        new Solution().run();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar wall[2][100010];\nint dp[100010][2];\nint main(void) {\n  for (int i = 0; i < 100010; ++i) dp[i][0] = dp[i][1] = 1000000000;\n  dp[0][0] = 0;\n  int n, k;\n  scanf(\"%d %d \", &n, &k);\n  gets(wall[0]);\n  gets(wall[1]);\n  queue<pair<int, int> > q;\n  q.push(make_pair(0, 0));\n  while (!q.empty()) {\n    pair<int, int> tmp = q.front();\n    int curr = tmp.first;\n    int w = tmp.second;\n    q.pop();\n    if (dp[curr][w] > curr || wall[w][curr] == 'X') continue;\n    if (curr + k >= n) {\n      cout << \"YES\\n\";\n      return 0;\n    }\n    if (dp[curr + 1][w] > dp[curr][w] + 1) {\n      dp[curr + 1][w] = dp[curr][w] + 1;\n      q.push(make_pair(curr + 1, w));\n    }\n    if (curr - 1 > -1 && dp[curr - 1][w] > dp[curr][w] + 1) {\n      dp[curr - 1][w] = dp[curr][w] + 1;\n      q.push(make_pair(curr - 1, w));\n    }\n    if (dp[curr + k][(w + 1) & 1] > dp[curr][w] + 1) {\n      dp[curr + k][(w + 1) & 1] = dp[curr][w] + 1;\n      q.push(make_pair(curr + k, (w + 1) & 1));\n    }\n  }\n  cout << \"NO\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Queue;\n\npublic class D {\n    \n    private static final int MAX = 100005;\n\n    private BufferedReader in;\n    private PrintWriter out;\n    private Queue<Pos> queue = new LinkedList<Pos>();\n    private boolean col[][] = new boolean[2][MAX];\n    \n    //private Map<Pos, Boolean> map = new HashMap<D.Pos, Boolean>();\n\n    public class Pos {\n        int p, water;\n        boolean wall;\n\n        public Pos(int p, int water, boolean wall) {\n            this.p = p;\n            this.wall = wall;\n            this.water = water;\n        }\n        \n//      @Override\n//      public boolean equals(Object o) {\n//          Pos pos = (Pos)o;\n//          if (pos == this) {\n//              return true;\n//          }\n//          if (pos.wall == wall && pos.p == p && pos.water == water) {\n//              return true;\n//          } else {\n//              return false;\n//          }\n//      }\n//      \n//      @Override\n//      public int hashCode() {\n//          int q = 17;\n//          q = q * 31 + p;\n//          q = q * 31 + water;\n//          q = q * 31 + (wall ? 1 : 0);\n//          return q;\n//      }\n    }\n\n    public static void main(String[] args) throws IOException {\n        new D().solve();\n    }\n\n    void solve() throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(new OutputStreamWriter(System.out));\n\n        String nk = in.readLine();\n        int n = Integer.valueOf(nk.split(\" \")[0]);\n        int k = Integer.valueOf(nk.split(\" \")[1]);\n\n        String l = in.readLine();\n        String r = in.readLine();\n\n        queue.offer(new Pos(0, 0, true));\n        col[1][0] = true;\n        //map.put(new Pos(0, 0, true), true);\n\n        while (!queue.isEmpty()) {\n            Pos u = queue.poll();\n\n            if (u.p - 1 > u.water && u.p - 1 >= 0) {\n                if (u.wall && l.charAt(u.p - 1) != 'X') {\n                    Pos p = new Pos(u.p - 1, u.water + 1, true);\n                    if (!col[1][u.p - 1]) {\n                        col[1][u.p - 1] = true;\n                        queue.offer(p);\n                    }\n                }\n                if (!u.wall && r.charAt(u.p - 1) != 'X') {\n                    Pos p = new Pos(u.p - 1, u.water + 1, false);\n                    if (!col[0][u.p - 1]) {\n                        col[0][u.p - 1] = true;\n                        queue.offer(p);\n                    }\n                }\n            }\n\n            if (u.p + 1 < n) {\n                if (u.wall && l.charAt(u.p + 1) != 'X') {\n                    Pos p = new Pos(u.p + 1, u.water + 1, true);\n                    if (!col[1][u.p + 1]) {\n                        col[1][u.p + 1] = true;\n                        queue.offer(p);\n                    }\n                }\n            } else {\n                out.print(\"YES\");\n                out.flush();\n                return;\n            }\n\n            if (u.p + 1 < n) {\n                if (!u.wall && r.charAt(u.p + 1) != 'X') {\n                    Pos p = new Pos(u.p + 1, u.water + 1, false);\n                    if (!col[0][u.p + 1]) {\n                        col[0][u.p + 1] = true;\n                        queue.offer(p);\n                    }\n                }\n            } else {\n                out.print(\"YES\");\n                out.flush();\n                return;\n            }\n\n            if (u.p - k > u.water && u.p - k >= 0) {\n                if (u.wall && r.charAt(u.p - k) != 'X') {\n                    Pos p = new Pos(u.p - k, u.water + 1, false);\n                    if (!col[0][u.p - k]) {\n                        col[0][u.p - k] = true;\n                        queue.offer(p);\n                    }\n                }\n                if (!u.wall && l.charAt(u.p - k) != 'X') {\n                    Pos p = new Pos(u.p - k, u.water + 1, true);\n                    if (!col[1][u.p - k]) {\n                        col[1][u.p - k] = true;\n                        queue.offer(p);\n                    }\n                }\n            }\n\n            if (u.p + k < n) {\n                if (u.wall && r.charAt(u.p + k) != 'X') {\n                    Pos p = new Pos(u.p + k, u.water + 1, false);\n                    if (!col[0][u.p + k]) {\n                        col[0][u.p + k] = true;\n                        queue.offer(p);\n                    }\n                }\n            } else {\n                out.print(\"YES\");\n                out.flush();\n                return;\n            }\n\n            if (u.p + k < n) {\n                if (!u.wall && l.charAt(u.p + k) != 'X') {\n                    Pos p = new Pos(u.p + k, u.water + 1, true);\n                    if (!col[1][u.p + k]) {\n                        col[1][u.p + k] = true;\n                        queue.offer(p);\n                    }\n                }\n            } else {\n                out.print(\"YES\");\n                out.flush();\n                return;\n            }\n        }\n\n        out.print(\"NO\");\n        out.flush();\n    }\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.Closeable;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.util.Collection;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.ArrayDeque;\nimport java.util.NoSuchElementException;\nimport java.util.StringTokenizer;\nimport java.util.Queue;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Jacob Jiang\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tQuickScanner in = new QuickScanner(inputStream);\n\t\tExtendedPrintWriter out = new ExtendedPrintWriter(outputStream);\n\t\tTaskB solver = new TaskB();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskB {\n\tpublic void solve(int testNumber, QuickScanner in, ExtendedPrintWriter out) {\n        int height = in.nextInt();\n        int jumpHeight = in.nextInt();\n        char[][] wall = in.next2DCharArray(2);\n        int[][] firstVisitedTime = new int[2][height];\n        ArrayUtils.fill(firstVisitedTime, -1);\n        Queue<Pair<Integer, Integer>> queue = new ArrayDeque<Pair<Integer, Integer>>();\n        queue.offer(Pair.makePair(0, 0));\n        firstVisitedTime[0][0] = 0;\n        while (!queue.isEmpty()) {\n            int side = queue.peek().first;\n            int position = queue.poll().second;\n            int currentTime = firstVisitedTime[side][position];\n            {\n                int nextSide = side;\n                int nextPosition = position + 1;\n                if (nextPosition >= currentTime + 1) {\n                    if (nextPosition >= height) {\n                        out.println(\"YES\");\n                        return;\n                    }\n                    if (wall[nextSide][nextPosition] == '-') {\n                        if (firstVisitedTime[nextSide][nextPosition] == -1) {\n                            firstVisitedTime[nextSide][nextPosition] = currentTime + 1;\n                            queue.offer(Pair.makePair(nextSide, nextPosition));\n                        }\n                    }\n                }\n            }\n            {\n                int nextSide = side;\n                int nextPosition = position - 1;\n                if (nextPosition >= currentTime + 1) {\n                    if (nextPosition >= height) {\n                        out.println(\"YES\");\n                        return;\n                    }\n                    if (wall[nextSide][nextPosition] == '-') {\n                        if (firstVisitedTime[nextSide][nextPosition] == -1) {\n                            firstVisitedTime[nextSide][nextPosition] = currentTime + 1;\n                            queue.offer(Pair.makePair(nextSide, nextPosition));\n                        }\n                    }\n                }\n            }\n            {\n                int nextSide = 1 - side;\n                int nextPosition = position + jumpHeight;\n                if (nextPosition >= currentTime + 1) {\n                    if (nextPosition >= height) {\n                        out.println(\"YES\");\n                        return;\n                    }\n                    if (wall[nextSide][nextPosition] == '-') {\n                        if (firstVisitedTime[nextSide][nextPosition] == -1) {\n                            firstVisitedTime[nextSide][nextPosition] = currentTime + 1;\n                            queue.offer(Pair.makePair(nextSide, nextPosition));\n                        }\n                    }\n                }\n            }\n        }\n        out.println(\"NO\");\n    }\n}\n\nclass QuickScanner implements Iterator<String>, Closeable {\n    BufferedReader reader;\n    StringTokenizer tokenizer;\n    boolean endOfFile = false;\n\n    public QuickScanner(InputStream inputStream){\n        reader = new BufferedReader(new InputStreamReader(inputStream));\n        tokenizer = null;\n    }\n\n    public boolean hasNext() {\n        if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                checkNext();\n            } catch (NoSuchElementException ignored) {\n            }\n\n        }\n        return !endOfFile;\n    }\n\n    private void checkNext() {\n        if (endOfFile) {\n            throw new NoSuchElementException();\n        }\n        try {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                tokenizer = new StringTokenizer(reader.readLine());\n            }\n        } catch (Exception e) {\n            endOfFile = true;\n            throw new NoSuchElementException();\n        }\n    }\n\n    public String next() {\n        checkNext();\n        return tokenizer.nextToken();\n    }\n\n    public void remove() {\n        throw new UnsupportedOperationException();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public char[] nextCharArray() {\n        return next().toCharArray();\n    }\n\n    public char[][] next2DCharArray(int n) {\n        char[][] result = new char[n][];\n        for (int i = 0; i < n; i++) {\n            result[i] = nextCharArray();\n        }\n        return result;\n    }\n\n    public void close() {\n        try {\n            reader.close();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n}\n\nclass ExtendedPrintWriter extends PrintWriter {\n\n\n    public ExtendedPrintWriter(Writer out) {\n        super(out);\n    }\n\n    public ExtendedPrintWriter(OutputStream out) {\n        super(out);\n    }\n\n    }\n\nclass ArrayUtils {\n\n    private ArrayUtils() {\n    }\n\n    public static void fill(int[][] array, int val) {\n        for (int[] subArray : array) {\n            Arrays.fill(subArray, val);\n        }\n    }\n\n    }\n\nclass Pair<A,B> implements Comparable<Pair<A, B>> {\n    public final A first;\n    public final B second;\n\n    public Pair(A first, B second) {\n        this.first = first;\n        this.second = second;\n    }\n\n    public static <A, B> Pair<A, B> makePair(A first, B second) {\n        return new Pair<A, B>(first, second);\n    }\n\n    public int compareTo(Pair<A, B> anotherPair) {\n        int result = ((Comparable<A>)first).compareTo(anotherPair.first);\n        if (result != 0) {\n            return result;\n        }\n        return ((Comparable<B>)second).compareTo(anotherPair.second);\n    }\n\n    public int hashCode() {\n        int result = 17;\n        if (first != null) {\n            result = 37 * result + first.hashCode();\n        }\n        if (second != null) {\n            result = 37 * result + second.hashCode();\n        }\n        return result;\n    }\n\n    public String toString() {\n        return \"(\" + first + \", \" + second + \")\";\n    }\n\n    public boolean equals(Object obj) {\n        try {\n            return this.first.equals(((Pair<A, B>) obj).first) &&\n                    this.second.equals(((Pair<A, B>) obj).second);\n        } catch (ClassCastException e) {\n            return false;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class Solve{\n    static boolean ok;\n    static    boolean[][] dep;\n    static int n,k;\n    public static void main(String[] args){\n        Scanner sc=new Scanner(System.in);\n     n=sc.nextInt();\n         k=sc.nextInt();\n         dep=new boolean[2][n];\n        for(int i=0;i<2;i++){\n            char[] c=sc.next().toCharArray();\n            for(int j=0;j<c.length;j++){\n                if(c[j]=='-')dep[i][j]=true;\n                else dep[i][j]=false;\n            }\n        }\n        ispos(-1,0,0);\n        if(ok) System.out.println(\"YES\");\n        else System.out.println(\"NO\");\n        \n    }\n    static void ispos(int water,int x,int y){\n        if(ok)return ;\n        if(y+k>n-1){\n            ok=true;\n            return;\n        }\n        else{\n            if(x==0){\n                if(dep[1][y+k] ){\n                    ispos(water+1,1,y+k);\n                }\n                else{\n                    dep[x][y]=false;\n                }\n            }\n            else{\n                 if(dep[0][y+k] ){\n                    ispos(water+1,0,y+k);\n                }\n                else{\n                    dep[x][y]=false;\n                }\n            }\n        }\n        if(dep[x][y+1])ispos(water+1,x,y+1);\n        if(y-1>=0 && water+1<y-1)if(dep[x][y-1])ispos(water+1,x,y-1);\n        \n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\t\n\tScanner in;\n\tstatic PrintWriter out;\n\t\n\tstatic class Scanner {\n\t\tStreamTokenizer in;\n\t\t\n\t\tScanner(InputStream is) {\n\t\t\tin = new StreamTokenizer(new BufferedReader(new InputStreamReader(is)));\n\t\t\t  in.resetSyntax();\n\t\t         in.whitespaceChars(0, 32);\n\t\t         in.wordChars(33, 255);\n\t\t     \n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tin.nextToken();\n\t\t\t\treturn Integer.parseInt(in.sval);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new Error();\n\t\t\t}\n\t\t}\n\t\t\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tin.nextToken();\n\t\t\t\treturn in.sval;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new Error();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tchar ar[][];\n\tint dist[][];\n\t\n\tstatic class Pos {\n\t\tint x;\n\t\tint y;\n\t\t\n\t\tPos(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tint getAnother(int x) {\n\t\treturn 1 - x;\n\t}\n\t\n\tboolean isAvailable(int x, int y, int time) {\n\t\tif (0 <= x && x <= 1 && 0 <= y) {\n\t\t\treturn (y >= time) && (y >= ar[0].length || ar[x][y] == '-');\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid solve() {\n\t\tint len = in.nextInt();\n\t\tint d = in.nextInt();\n\t\tar = new char[2][];\n\t\tar[0] = in.next().toCharArray();\n\t\tar[1] = in.next().toCharArray();\n\t\t\n\t\tdist = new int[2][len];\n\t\tfor (int arr[] : dist) {\n\t\t\tArrays.fill(arr, -1);\n\t\t}\n\t\t\n\t\tQueue <Pos> q = new LinkedList <Pos> ();\n\t\tq.add(new Pos(0, 0));\n\t\tdist[0][0] = 0;\n\t\twhile (!q.isEmpty()) {\n\t\t\tPos curr = q.poll();\n\t\t\tif (isAvailable(curr.x, curr.y + 1, dist[curr.x][curr.y] + 1)) {\n\t\t\t\tif (curr.y + 1 >= len) {\n\t\t\t\t\tout.println(\"YES\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (dist[curr.x][curr.y + 1] == -1) {\n\t\t\t\t\tdist[curr.x][curr.y + 1] = dist[curr.x][curr.y] + 1;\n\t\t\t\t\tq.add(new Pos(curr.x, curr.y + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isAvailable(curr.x, curr.y - 1, dist[curr.x][curr.y] + 1)) {\n\t\t\t\tif (dist[curr.x][curr.y - 1] == -1) {\n\t\t\t\t\tdist[curr.x][curr.y - 1] = dist[curr.x][curr.y] + 1;\n\t\t\t\t\tq.add(new Pos(curr.x, curr.y - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isAvailable(1 - curr.x, curr.y + d, dist[curr.x][curr.y] + 1)) {\n\t\t\t\tif (curr.y + d >= len) {\n\t\t\t\t\tout.println(\"YES\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (dist[1 - curr.x][curr.y + d] == -1) {\n\t\t\t\t\tdist[1 - curr.x][curr.y + d] = dist[curr.x][curr.y] + 1; \n\t\t\t\t\tq.add(new Pos(1 - curr.x, curr.y + d));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(\"NO\");\n\t}\n\t\n\tstatic void asserT(boolean e) {\n\t\tif (!e) {\n\t\t\tthrow new Error();\n\t\t}\n\t}\n\t\n\t\n\tpublic void run() {\n\t\tin = new Scanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\ttry {\n\t\t\tsolve();\n\t\t} finally {\n\t\t\tout.close();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nchar s[2][200100];\nbool vis[2][200100];\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  scanf(\"%s\", s[0]);\n  scanf(\"%s\", s[1]);\n  queue<pair<int, pair<int, int> > > q;\n  q.push(make_pair(0, make_pair(0, 0)));\n  while (!q.empty()) {\n    int x = q.front().second.first;\n    int y = q.front().second.second;\n    int d = q.front().first;\n    q.pop();\n    if (y >= n) {\n      puts(\"YES\");\n      return 0;\n    }\n    if ((d < y + m) && !vis[!x][y + m] && (y + m >= n || s[!x][y + m] == '-')) {\n      q.push(make_pair(d + 1, make_pair(!x, y + m)));\n      vis[!x][y + m] = 1;\n    }\n    if ((d < y + 1) && !vis[x][y + 1] && (y + 1 >= n || s[x][y + 1] == '-')) {\n      q.push(make_pair(d + 1, make_pair(x, y + 1)));\n      vis[x][y + 1] = 1;\n    }\n    if ((d < y - 1) && y > 0 && !vis[x][y - 1] && s[x][y - 1] == '-') {\n      q.push(make_pair(d + 1, make_pair(x, y - 1)));\n      vis[x][y - 1] = 1;\n    }\n  }\n  puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, q1, q2, x, y, l, f[2][111111], qx[333333], qy[333333], ql[333333];\nchar a[2][111111];\nstring ans = \"NO\";\nvoid add(int x, int y, int l) {\n  if (y >= n) ans = \"YES\";\n  if (y >= n || a[x][y] == 'X' || f[x][y] || l > y) return;\n  f[x][y] = 1;\n  qx[q1] = x;\n  qy[q1] = y;\n  ql[q1++] = l;\n}\nint main() {\n  scanf(\"%d%d\\n\", &n, &k);\n  gets(a[0]);\n  gets(a[1]);\n  add(0, 0, 0);\n  while (q1 != q2) {\n    x = qx[q2];\n    y = qy[q2];\n    l = ql[q2++];\n    add(x, y + 1, l + 1);\n    add(x, y - 1, l + 1);\n    add(x ^ 1, y + k, l + 1);\n  }\n  cout << (ans) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long maxN = 1e6 + 100;\nconst long long maxM = 1e3 + 100;\nconst long long mod = 1e9 + 7;\nconst long long hmod = 1e16 + 7;\nconst long double PI = 3.141592653;\nconst long double eps = 1e-8;\nconst long long D = 1379;\nconst long long INF = 1e18 + 20;\nconst long long Inf = 1e9 + 140;\nvoid NO() {\n  cout << \"NO\" << endl;\n  exit(0);\n}\nvoid YES() {\n  cout << \"YES\" << endl;\n  exit(0);\n}\nlong long n, k;\nbool mrk[2][maxN], mark[2][maxN];\nvoid dfs(long long v, long long x = 0, long long W = 0) {\n  if (v > n) YES();\n  if (v <= 0 || mrk[x][v] || mark[x][v] || v <= W) return;\n  mark[x][v] = true;\n  W++;\n  dfs(v + k, x ^ 1, W);\n  dfs(v + 1, x, W);\n  dfs(v - 1, x, W);\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  for (long long i = 1; i <= n; i++) {\n    char c;\n    cin >> c;\n    if (c == 'X') mrk[0][i] = true;\n  }\n  for (long long i = 1; i <= n; i++) {\n    char c;\n    cin >> c;\n    if (c == 'X') mrk[1][i] = true;\n  }\n  dfs(1);\n  NO();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nstring wall[2];\nbool visit[2][100050];\nbool escape(int s, int h, int t) {\n  if (h <= t || h < 0) return false;\n  if (h >= n) return true;\n  if (wall[s][h] != '-') return false;\n  if (visit[s][h]) return false;\n  visit[s][h] = true;\n  return max(max(escape(s, h + 1, t + 1), escape(s, h - 1, t + 1)),\n             escape(1 - s, h + k, t + 1));\n}\nint main() {\n  cin >> n >> k;\n  cin >> wall[0];\n  cin >> wall[1];\n  if (escape(0, 0, -1))\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint arrayLeft[100010] = {0};\nint arrayRight[100010] = {0};\nclass Walls {\n public:\n  int height;\n  int pathLength;\n  int pos;\n  bool onLeft;\n  Walls() {\n    height = 1;\n    pathLength = 1000000;\n    pos = 1;\n    onLeft = true;\n  }\n};\nint main() {\n  int n, k;\n  scanf(\"%d%d\", &n, &k);\n  Walls *wall = new Walls[2 * n];\n  char a[100010], b[100010];\n  a[0] = 'X';\n  b[0] = 'X';\n  scanf(\"%s%s\", &a[1], &b[1]);\n  int initialLimit = 0, finalLimit = 1;\n  wall[0].pathLength = 0;\n  arrayLeft[0] = 0;\n  bool found = false;\n  int count = 0;\n  int waterHeight = 0;\n  count = finalLimit;\n  while (1) {\n    for (int i = initialLimit; i < finalLimit; i++) {\n      int pos = wall[i].pos;\n      int pathLength = wall[i].pathLength;\n      int height = wall[i].height;\n      if ((height + 1 > n || height + k > n) && pathLength + 1 <= n) {\n        found = true;\n        break;\n      }\n      if (wall[i].onLeft) {\n        if (arrayLeft[pos - 1] == 0 && a[pos - 1] == '-' &&\n            height - 1 > waterHeight + 1) {\n          arrayLeft[pos - 1] = 1;\n          wall[count].height = height - 1;\n          wall[count].pathLength = pathLength + 1;\n          wall[count].pos = pos - 1;\n          count++;\n        }\n        if (arrayLeft[pos + 1] == 0 && a[pos + 1] == '-' &&\n            height > waterHeight) {\n          arrayLeft[pos + 1] = 1;\n          wall[count].height = height + 1;\n          wall[count].pathLength = pathLength + 1;\n          wall[count].pos = pos + 1;\n          count++;\n        }\n        if (arrayRight[pos + k] == 0 && b[pos + k] == '-' &&\n            height + k > waterHeight + 1) {\n          arrayRight[pos + k] = 1;\n          wall[count].height = height + k;\n          wall[count].pathLength = pathLength + 1;\n          wall[count].pos = pos + k;\n          wall[count].onLeft = false;\n          count++;\n        }\n      } else {\n        if (arrayRight[pos - 1] == 0 && b[pos - 1] == '-' &&\n            height - 1 > waterHeight + 1) {\n          arrayRight[pos - 1] = 1;\n          wall[count].height = height - 1;\n          wall[count].pathLength = pathLength + 1;\n          wall[count].pos = pos - 1;\n          wall[count].onLeft = false;\n          count++;\n        }\n        if (arrayRight[pos + 1] == 0 && b[pos + 1] == '-' &&\n            height > waterHeight) {\n          arrayRight[pos + 1] = 1;\n          wall[count].height = height + 1;\n          wall[count].pathLength = pathLength + 1;\n          wall[count].pos = pos + 1;\n          wall[count].onLeft = false;\n          count++;\n        }\n        if (arrayLeft[pos + k] == 0 && a[pos + k] == '-' &&\n            height + k > waterHeight + 1) {\n          arrayLeft[pos + k] = 1;\n          wall[count].height = height + k;\n          wall[count].pathLength = pathLength + 1;\n          wall[count].pos = pos + k;\n          count++;\n        }\n      }\n    }\n    if (finalLimit == count) break;\n    if (found) break;\n    initialLimit = finalLimit;\n    finalLimit = count;\n    waterHeight++;\n  }\n  if (found) printf(\"YES\\n\");\n  if (!found) printf(\"NO\\n\");\n}\n"
        },
        {
            "language": 1,
            "solution": "def adj(node, edges, e_next, e_target):\n    edge = edges[node]\n    while edge is not None:\n        yield e_target[edge]\n        edge = e_next[edge]\n\nclass Solution(object):\n    def build_graph(self, n, k, walls):\n        flatten_n = 2 * n\n        max_edges = flatten_n * 5\n        latest_edge_id = 0\n        edges = [None] * flatten_n\n        e_next = [None] * max_edges\n        e_target = [None] * max_edges\n        wall = walls[0] + walls[1]\n\n        def add_edge(x, y, edges, e_next, e_target, latest_edge_id):\n            head = edges[x]\n            edges[x] = latest_edge_id\n            e_next[edges[x]] = head\n            e_target[edges[x]] = y\n            return latest_edge_id + 1\n\n        for i in xrange(flatten_n):\n            if wall[i] == 'X':\n                continue\n            if (i < n and i > 0) or (i < 2 * n and i > n):\n                if wall[i - 1] == '-':\n                    latest_edge_id = add_edge(i, i - 1, edges, e_next, e_target, latest_edge_id)\n            if (i % n) + 1 < n and wall[i + 1] == '-':\n                latest_edge_id = add_edge(i, i + 1, edges, e_next, e_target, latest_edge_id)\n            if (i % n) + k < n and wall[(i + k + n) % (2 * n)] == '-':\n                latest_edge_id = add_edge(i, (i + k + n) % (2 * n), edges, e_next, e_target, latest_edge_id)\n        return flatten_n, max_edges, edges, e_next, e_target, wall\n\n    def calc_game_points(self, n, k, walls):\n        flatten_n = 2 * n\n        wall = walls[0] + walls[1]\n        is_game_point = [False] * flatten_n\n        i = n - 1\n        while wall[i] == '-' and i >= 0:\n            is_game_point[i] = True\n            i -= 1\n        i = 2 * n - 1\n        while wall[i] == '-' and i >= n:\n            is_game_point[i] = True\n            i -= 1\n        for i in xrange(max(0, n - k), n):\n            if wall[i] == '-':\n                is_game_point[i] = True\n        for i in xrange(max(n, 2 * n - k), 2 * n):\n            if wall[i] == '-':\n                is_game_point[i] = True\n        return is_game_point\n\n    def spfa(self, n, flatten_n, k, edges, e_next, e_target, is_game_point):\n        dist = [float('inf')] * flatten_n\n        start_node = 0\n        dist[start_node] = 0\n        queue_size = flatten_n * 2\n        nodes_to_relax = [None] * queue_size\n        head = 0\n        tail = 0\n        nodes_to_relax[tail] = start_node\n        tail += 1\n        in_nodes_to_relax = set([start_node])\n\n        while head < tail:\n            current = nodes_to_relax[head]\n            head += 1\n            head %= queue_size\n            in_nodes_to_relax.remove(current)\n            if is_game_point[current]:\n                return True\n            for adj_node in adj(current, edges, e_next, e_target):\n                if dist[current] + 1 < (adj_node % n) + 1 and dist[current] + 1 < dist[adj_node]:\n                    dist[adj_node] = dist[current] + 1\n                    if adj_node not in in_nodes_to_relax:\n                        nodes_to_relax[tail] = adj_node\n                        tail += 1\n                        tail %= queue_size\n                        in_nodes_to_relax.add(adj_node)\n        return False\n\n    def read(self):\n        n, k = [int(_) for _ in raw_input().split()]\n        walls = [raw_input(), raw_input(), ]\n        return n, k, walls\n\n    def run(self):\n        n, k, walls = self.read()\n        flatten_n, max_edges, edges, e_next, e_target, wall = self.build_graph(n, k, walls)\n        is_game_point = self.calc_game_points(n, k, walls)\n        result = self.spfa(n, flatten_n, k, edges, e_next, e_target, is_game_point)\n        print 'YES' if result else 'NO'\n\nif __name__ == '__main__':\n    Solution().run()\n"
        },
        {
            "language": 4,
            "solution": "\n//package jumpingonwalls;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class jumpingonwalls {\n\t\n\t//static boolean[][] visited;\n\t\n\tstatic boolean game(boolean[][] safe, boolean[][] visited, int water, int k, int x, int y) {\n\t\t\n\t\t//System.out.println(x + \" \" + y + \" \" + water);\n//\t\tfor(int i = 0; i < safe.length; i++) {\n//\t\t\tfor(int j = 0; j < safe[i].length; j++) {\n//\t\t\t\tif(x == i && j == y) {\n//\t\t\t\t\tSystem.out.print(\"O\");\n//\t\t\t\t}\n//\t\t\t\telse if(visited[i][j]) {\n//\t\t\t\t\tSystem.out.print(\"*\");\n//\t\t\t\t}\n//\t\t\t\telse if(safe[i][j]) {\n//\t\t\t\t\tSystem.out.print(\"-\");\n//\t\t\t\t}\n//\t\t\t\telse {\n//\t\t\t\t\tSystem.out.print(\"X\");\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\t\n\t\tvisited[x][y] = true;\n\t\t\n\t\tif(water >= y) {\n\t\t\treturn false;\n\t\t}\n\t\tif(y + k >= safe[0].length || y + 1 >= safe[0].length) {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tboolean up = false;\n\t\tboolean down = false;\n\t\tboolean jump = false;\n\t\tif(x == 0 && safe[1][y + k] && !visited[1][y + k]) {\n\t\t\t//System.out.println(\"jump\");\n\t\t\tjump = game(safe, visited, water + 1, k, 1, y + k);\n\t\t}\n\t\telse if(x == 1 && safe[0][y + k] && !visited[0][y + k]) {\n\t\t\t//System.out.println(\"jump\");\n\t\t\tjump = game(safe, visited, water + 1, k, 0, y + k);\n\t\t}\n\t\tif(safe[x][y + 1] && !visited[x][y + 1]) {\n\t\t\t//System.out.println(\"up\");\n\t\t\tup = game(safe, visited, water + 1, k, x, y + 1);\n\t\t}\n\t\tif(y != 0 && safe[x][y - 1] && !visited[x][y - 1]) {\n\t\t\t//System.out.println(\"down\");\n\t\t\tdown = game(safe, visited, water + 1, k, x, y - 1);\n\t\t}\n\t\t\n\t\t\n\t\treturn up || down || jump;\n\t}\n\t\n\tpublic static void main (String [] args) throws IOException {\n\t\t\n\t//we can just simulate the whole thing; O(n), n <= 10^5 (maybe, we'll see)\n\t//lets do it recursively\n    \n    BufferedReader fin = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer st = new StringTokenizer(fin.readLine());\n    \n    int n = Integer.parseInt(st.nextToken());\n    int k = Integer.parseInt(st.nextToken());\n    //visited = new boolean[2][n];\n    \n    boolean[][] safe = new boolean[2][n];\n    for(int i = 0; i < 2; i++) {\n    \tString input = fin.readLine();\n    \tfor(int j = 0; j < n; j++) {\n    \t\tif(input.charAt(j) == '-') {\n    \t\t\tsafe[i][j] = true;\n    \t\t}\n    \t}\n    }\n    \n    int water = -1;\n    boolean done = false;\n    boolean[][] visited = new boolean[2][n];\n    \n    System.out.println(game(safe, visited, water, k, 0, 0)? \"YES\" : \"NO\");\n    fin.close();\n    \n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MAXN = 500000;\nusing namespace std;\nint n, k;\nchar s[2][MAXN];\nint q[MAXN], d[MAXN];\nvoid out(string verdict) {\n  cout << verdict << endl;\n  exit(0);\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  scanf(\"%s%s\", s[0], s[1]);\n  q[0] = 0;\n  memset(d, -1, sizeof(d));\n  d[0] = 0;\n  for (int l = 0, r = 1; l < r; l++) {\n    int u = q[l] >> 1, v = q[l] & 1;\n    if (d[q[l]] > u) continue;\n    if (u + k >= n) out(\"YES\");\n    if (d[(u + 1) * 2 + v] == -1 && s[v][u + 1] != 'X') {\n      d[(u + 1) * 2 + v] = d[q[l]] + 1;\n      q[r++] = (u + 1) * 2 + v;\n    }\n    if (u && d[(u - 1) * 2 + v] == -1 && s[v][u - 1] != 'X') {\n      d[(u - 1) * 2 + v] = d[q[l]] + 1;\n      q[r++] = (u - 1) * 2 + v;\n    }\n    if (d[(u + k) * 2 + (v ^ 1)] == -1 && s[v ^ 1][u + k] != 'X') {\n      d[(u + k) * 2 + (v ^ 1)] = d[q[l]] + 1;\n      q[r++] = (u + k) * 2 + (v ^ 1);\n    }\n  }\n  out(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = int(1e5) + 100;\nint n;\nint k;\nvector<int> g[2 * N];\nbool doz[2 * N];\nstring s;\nbool pos[2 * N];\npriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>\n    pq;\nint d[2 * N];\nint p[2 * N];\nbool NO;\nvoid dijkstra() {\n  for (int i = 1; i <= 2 * n + 1; i++) {\n    d[i] = -1;\n    p[i] = -1;\n  }\n  d[1] = 1;\n  p[1] = 0;\n  pq.push(pair<int, int>(0, 1));\n  for (int i = 1; i <= 2 * n + 1; i++) {\n    int v = -1;\n    while (!pq.empty()) {\n      int u = pq.top().second;\n      pq.pop();\n      if (!pos[u]) {\n        v = u;\n        pos[v] = true;\n        break;\n      }\n    }\n    if (v == -1) break;\n    pos[v] = true;\n    for (int k = 0; k < g[v].size(); k++) {\n      if (!pos[g[v][k]])\n        if (d[g[v][k]] == -1 || d[g[v][k]] > d[v] + 1) {\n          d[g[v][k]] = d[v] + 1;\n          p[g[v][k]] = v;\n          pq.push(pair<int, int>(d[g[v][k]], g[v][k]));\n        }\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> k;\n  cin >> s;\n  for (int i = 1; i <= n; i++)\n    if (s[i - 1] == '-') doz[i] = true;\n  cin >> s;\n  for (int i = 1; i <= n; i++)\n    if (s[i - 1] == '-') doz[n + i] = true;\n  doz[2 * n + 1] = true;\n  for (int i = 1; i < n; i++) {\n    if (!doz[i]) continue;\n    if (doz[i + 1]) g[i].push_back(i + 1);\n    if (doz[i - 1]) g[i].push_back(i - 1);\n    if (i > n - k)\n      g[i].push_back(2 * n + 1);\n    else if (doz[i + k + n])\n      g[i].push_back(i + k + n);\n  }\n  g[n].push_back(2 * n + 1);\n  for (int i = n + 1; i < 2 * n; i++) {\n    if (!doz[i]) continue;\n    if (i > n + 1)\n      if (doz[i - 1]) g[i].push_back(i - 1);\n    if (doz[i + 1]) g[i].push_back(i + 1);\n    if (i > 2 * n - k)\n      g[i].push_back(2 * n + 1);\n    else if (doz[i + k - n])\n      g[i].push_back(i + k - n);\n  }\n  g[2 * n].push_back(2 * n + 1);\n  dijkstra();\n  int itr = 2 * n + 1;\n  while (itr != 0) {\n    if (itr <= n) {\n      if (d[itr] > itr) {\n        NO = true;\n        break;\n      }\n    } else {\n      if (d[itr] > itr - n) {\n        NO = true;\n        break;\n      }\n    }\n    itr = p[itr];\n  }\n  if (NO)\n    cout << \"NO\" << endl;\n  else\n    cout << \"YES\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nint visited[2][100001];\nstring walls[2];\nchar a, b;\nbool dfs(int x, int y, int t) {\n  if (y >= n) return true;\n  if (y < 0) return false;\n  if (walls[x][y] == 'X' || (visited[x][y] <= t && visited[x][y] != 0) || y < t)\n    return false;\n  visited[x][y] = t;\n  if (dfs(1 - x, y + k, t + 1)) return true;\n  if (dfs(x, y + 1, t + 1)) return true;\n  if (dfs(x, y - 1, t + 1)) return true;\n  return false;\n}\nint main() {\n  cin >> n >> k;\n  cin >> walls[0] >> walls[1];\n  if (dfs(0, 0, 0))\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.LinkedList;\n\npublic class JumpOnWalls {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        String[] line = in.readLine().split(\" \");\n        int n = Integer.parseInt(line[0]);\n        int k = Integer.parseInt(line[1]);\n        char[][] c = new char[2][n];\n        c[0] = in.readLine().toCharArray();\n        c[1] = in.readLine().toCharArray();\n        boolean[][] v = new boolean[2][n];\n        for (int i = 0; i < n; i++) {\n            if (c[0][i] == 'X')\n                v[0][i] = true;\n            if (c[1][i] == 'X')\n                v[1][i] = true;\n        }\n        boolean ans = bfs(n, k, c, v);\n        if (ans)\n            System.out.println(\"YES\");\n        else\n            System.out.println(\"NO\");\n\t}\n \n    private static boolean bfs(int n, int k, char[][] c, boolean[][] v) {\n    \tLinkedList<Integer> q = new LinkedList<Integer>(); \n        q.add(0);\n        q.add(0);\n        q.add(0); \n        while (!q.isEmpty()) {\n            int level = q.poll();\n            int wall = q.poll();\n            int count = q.poll();\n            if (level >= n)\n                return true;\n            if (level < 0 || v[wall][level] || level + 1 <= count)\n                continue;\n            v[wall][level] = true;\n            q.add(level + 1);\n            q.add(wall);\n            q.add(count + 1);\n \n            q.add(level - 1);\n            q.add(wall);\n            q.add(count + 1);\n \n            q.add(level + k);\n            q.add(wall ^ 1);\n            q.add(count + 1);\n        }\n        return false;\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 7;\nconst int mod = 998244353;\nlong long read() {\n  long long c = getchar(), Nig = 1, x = 0;\n  while (!isdigit(c)) c = getchar();\n  if (c == '-') Nig = -1, c = getchar();\n  while (isdigit(c)) x = ((x << 1) + (x << 3)) + (c ^ '0'), c = getchar();\n  return Nig * x;\n}\nstruct node {\n  int x, y, step;\n  friend bool operator<(node a, node b) { return a.step > b.step; }\n};\nchar ma[2][maxn];\nint n, vis[2][maxn];\nbool bfs(int pos, int y, int k, int time) {\n  priority_queue<node> q;\n  node p, a, b;\n  b.x = pos;\n  b.y = y;\n  b.step = time;\n  q.push(b);\n  memset(vis, 0, sizeof vis);\n  vis[b.x][b.y] = 1;\n  while (!q.empty()) {\n    p = q.top();\n    q.pop();\n    if (p.y > n) return true;\n    if (ma[(p.x + 1) % 2][p.y + k] != 'X' && vis[(p.x + 1) % 2][p.y + k] == 0) {\n      vis[(p.x + 1) % 2][p.y + k] = 1;\n      a.x = (p.x + 1) % 2;\n      a.y = p.y + k;\n      a.step = p.step + 1;\n      if (a.step < a.y) {\n        q.push(a);\n      }\n    }\n    if (ma[p.x][p.y + 1] != 'X' && vis[p.x][p.y + 1] == 0) {\n      vis[p.x][p.y + 1] = 1;\n      a.x = p.x;\n      a.y = p.y + 1;\n      a.step = p.step + 1;\n      if (a.step < a.y) {\n        q.push(a);\n      }\n    }\n    if (ma[p.x][p.y - 1] != 'X' && vis[p.x][p.y - 1] == 0) {\n      vis[p.x][p.y - 1] = 1;\n      a.x = p.x;\n      a.y = p.y - 1;\n      a.step = p.step + 1;\n      if (a.step < a.y) {\n        q.push(a);\n      }\n    }\n  }\n  return false;\n}\nint main() {\n  n = read();\n  int k = read();\n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < n; j++) {\n      cin >> ma[i][j];\n    }\n  }\n  bool flag = bfs(0, 0, k, -1);\n  if (flag)\n    cout << \"YES\\n\";\n  else\n    cout << \"NO\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "//package contest_125_div2;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Set;\n/**\n * Date     : Jul 8, 2012\n * Time     : 1:38:58 PM\n * Email    : denys.astanin@gmail.com\n */\n\npublic class D {\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew D().run();\n\t}\n\n\tBufferedReader in;\n\tWriter writer;\n\tReader reader;\n\tint n, k;\n\tMap<Integer, Set<Integer>> matrix;\n\tString left, right;\n\tvoid run() throws IOException {\n\t\tboolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\treader = oj ? new InputStreamReader(System.in, \"ISO-8859-1\")\n\t\t\t\t: new FileReader(\"src/contest_125_div2/D.txt\");\n\t\twriter = new OutputStreamWriter(System.out, \"ISO-8859-1\");\n\t\tin = new BufferedReader(reader);\n\t\tPrintWriter out = new PrintWriter(writer);\n\t\tString[] temp = in.readLine().split(\"\\\\s+\");\n\t\tn = Integer.valueOf(temp[0]);\n\t\tk = Integer.valueOf(temp[1]);\n\t\tleft  = in.readLine();\n\t\tright = in.readLine();\n//\t\tn = (int)10e5;\n\t\tmatrix = new HashMap<Integer, Set<Integer>>();\n\t\tboolean is = false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint lInd = i;\n\t\t\tint rInd = i + n;\n\t\t\tfillNeighbours(lInd);\n\t\t\tfillNeighbours(rInd);\n\t\t}\n\t\tQueue<Node> queue = new LinkedList<Node>();\n\t\tqueue.add(new Node(0, 0));\n\t\tSet<Integer> visited = new HashSet<Integer>();\n\t\tcycle : while (!queue.isEmpty()) {\n\t\t\tNode node = queue.poll();\n\t\t\t\n\t\t\tvisited.add(node.index);\n\t\t\tif (getIndex(node.index) + k >= n) {\n\t\t\t\tis = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSet<Integer> neighbours = matrix.get(node.index);\n\t\t\tif (neighbours == null)\n\t\t\t\tcontinue;\n\n\t\t\tfor (Integer neighbour : neighbours) {\n\t\t\t\tif (node.waterLevel + 1 <= getIndex(neighbour) && !visited.contains(neighbour)) {\n\t\t\t\t\tif (getIndex(neighbour) + k >= n) {\n\t\t\t\t\t\tis = true;\n\t\t\t\t\t\tbreak cycle;\n\t\t\t\t\t}\n\t\t\t\t\tqueue.add(new Node(node.waterLevel + 1, neighbour));\n\t\t\t\t\tvisited.add(neighbour);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(is ? \"YES\" : \"NO\");\n\t\tout.flush();\n\t\tout.close();\n\t}\n\tclass Node {\n\t\tint waterLevel, index;\n\t\tNode(int wl, int i) {\n\t\t\twaterLevel = wl;\n\t\t\tindex = i;\n\t\t}\n\t}\n\tprivate void fillNeighbours(int index) {\n\t\tSet<Integer> set = getVertexes(index);\n\t\tchar ch = index >= n ? right.charAt(getIndex(index)) : left.charAt(index);\n\t\tString oppositeString = index >= n ? left : right;\n\t\tString string = index >= n ? right : left;\n\t\tif (ch == '-') {\n\t\t\tif (isPossible(getIndex(index) - 1) && string.charAt(getIndex(index) - 1) =='-') {\n\t\t\t\tset.add(index - 1);\n\t\t\t}\n\t\t\tif (isPossible(getIndex(index) + 1) && string.charAt(getIndex(index) + 1) =='-') {\n\t\t\t\tset.add(index + 1);\n\t\t\t}\n\t\t\tif (isPossible(getIndex(index) + k) && oppositeString.charAt(getIndex(index) + k) =='-') {\n\t\t\t\tset.add(getIndex(index) + (index >= n ? 0 : n) + k);\n\t\t\t}\n\t\t}\n\t}\n\tprivate Set<Integer> getVertexes(int index) {\n\t\tSet<Integer> set = matrix.get(index);\n\t\tif (set == null) {\n\t\t\tset = new HashSet<Integer>();\n\t\t\tmatrix.put(index, set);\n\t\t}\n\t\treturn set;\n\t}\n\tint getIndex(int ind) {\n\t\treturn ind % n;\n\t}\n\tboolean isPossible(int index) {\n\t\treturn index >= 0 && index < n;\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar a[2][100005];\nint visit[2][100005] = {0};\nqueue<int> q;\nint n, k;\nbool ans = false;\nvoid chk(int x, int y, int time) {\n  if (y < time || y < 1) return;\n  if (y > n) {\n    ans = true;\n    return;\n  }\n  if (visit[x][y] || a[x][y] == 'X') return;\n  visit[x][y] = time;\n  q.push(x);\n  q.push(y);\n}\nint main() {\n  int x, y, t;\n  cin >> n >> k;\n  cin >> a[0] + 1;\n  cin >> a[1] + 1;\n  q.push(0);\n  q.push(1);\n  visit[0][1] = 1;\n  while (!q.empty()) {\n    x = q.front();\n    q.pop();\n    y = q.front();\n    q.pop();\n    t = visit[x][y];\n    chk(x, y + 1, t + 1);\n    chk(x, y - 1, t + 1);\n    chk(!x, y + k, t + 1);\n  }\n  cout << (ans ? \"YES\" : \"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nbool e = false;\nbool **a;\nint **ta;\nvoid go(int q, int h, int t) {\n  if (!e) {\n    if (h >= n) {\n      e = true;\n      printf(\"YES\");\n      return;\n    } else if (h >= 0)\n      if (!a[h][q] && t <= h && t < ta[h][q]) {\n        ta[h][q] = t;\n        go((q + 1) % 2, h + k, t + 1);\n        go(q, h + 1, t + 1);\n        go(q, h - 1, t + 1);\n      }\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  scanf(\"\\n\");\n  a = new bool *[n];\n  ta = new int *[n];\n  for (int i = 0; i < n; i++) {\n    ta[i] = new int[2];\n    a[i] = new bool[2];\n    ta[i][1] = 2000000;\n    ta[i][0] = 2000000;\n    char c;\n    scanf(\"%c\", &c);\n    if (c == 'X')\n      a[i][0] = true;\n    else\n      a[i][0] = false;\n  }\n  scanf(\"\\n\");\n  for (int i = 0; i < n; i++) {\n    char c;\n    scanf(\"%c\", &c);\n    if (c == 'X')\n      a[i][1] = true;\n    else\n      a[i][1] = false;\n  }\n  go(0, 0, 0);\n  if (!e) printf(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nT power(T a, T b) {\n  T x;\n  if (b == 0)\n    x = 1;\n  else\n    x = a;\n  for (size_t i = 1; i < b; i++) x *= a;\n  return x;\n}\nlong long int gcd(long long int a, long long int b) {\n  return b == 0 ? a : gcd(b, a % b);\n}\nlong long int n, m, a, b, c, ab, ba, x, y, z, avg, sum;\nlong long int arr2[100000], arr3[200000], arr4[200001], arr5[100001];\nbool f, f1, f2;\nstring str, s1, s2, s3, s4;\nset<int> seto;\ndouble d, d1;\nlong long int x1, x2, y11, y2;\nlong long int mini = 100000000000000, maxi = 0;\nmap<char, long long int> mp;\nvector<int> v, v1;\nbool dp[100000][2];\nvoid solve(long long int a = 0, long long int b = 0, bool wall = 0) {\n  int i = a;\n  int x = b;\n  if (i >= 0 && i < n) {\n    if (!wall) {\n      if (s1[i] == 'X' || x > i) return;\n      if (!dp[i][0]) {\n        dp[i][0] = 1;\n        solve(i - 1, x + 1, 0);\n        solve(i + m, x + 1, 1);\n        solve(i + 1, x + 1, 0);\n      }\n    } else {\n      if (s2[i] == 'X' || x > i) return;\n      if (!dp[i][1]) {\n        dp[i][1] = 1;\n        solve(i - 1, x + 1, 1);\n        solve(i + m, x + 1, 0);\n        solve(i + 1, x + 1, 1);\n      }\n    }\n  }\n  if (i >= n) {\n    cout << \"YES\";\n    exit(0);\n  }\n}\nint main() {\n  cin >> n >> m;\n  cin >> s1 >> s2;\n  solve();\n  cout << \"NO\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, x, y, fi, fr, f[2][100200], qx[200200], qy[200200];\nchar s[2][100100];\nint main() {\n  cin >> n >> k;\n  cin >> s[0];\n  cin >> s[1];\n  f[0][0] = 1;\n  for (fr = 1; fi < fr;) {\n    x = qx[fi];\n    y = qy[fi++];\n    if (y >= n - k) {\n      cout << \"YES\";\n      return 0;\n    }\n    if (y > 0 && s[x][y - 1] == '-' && f[x][y - 1] == 0 && y > f[x][y]) {\n      f[x][y - 1] = f[x][y] + 1;\n      qx[fr] = x;\n      qy[fr++] = y - 1;\n    }\n    if (s[x][y + 1] == '-' && f[x][y + 1] == 0) {\n      f[x][y + 1] = f[x][y] + 1;\n      qx[fr] = x;\n      qy[fr++] = y + 1;\n    }\n    if (s[1 - x][y + k] == '-' && f[1 - x][y + k] == 0) {\n      f[1 - x][y + k] = f[x][y] + 1;\n      qx[fr] = 1 - x;\n      qy[fr++] = y + k;\n    }\n  }\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\n/**\n *\n * @author Donato\n */\npublic class JumpingOnWalls {\n\n    public static int saltos(String[] pared,int n, int lado, int area, int agua,int k,int[][] visitados){\n        visitados[lado][area-1]=1;\n        if(agua>=area){\n            return 0;\n        }\n        else{\n            if(area>=n){\n                return 1;\n            }\n            else{\n                if(area+k<=n ){\n                    if(pared[1-lado].charAt(area+k-1)=='-' && visitados[1-lado][area+k-1]==0){\n                        if(saltos(pared,n,1-lado,area+k,agua+1,k,visitados)==1){\n                            return 1;\n                        }\n                        \n                    }\n                    \n                }\n                else{\n                    return 1;\n                }\n                \n                if(area+1<=n ){\n                    if(pared[lado].charAt(area)=='-' && visitados[lado][area]==0){\n                        if(saltos(pared,n,lado,area+1,agua+1,k,visitados)==1){\n                            return 1;\n                        }\n                        \n                    }\n                    \n                }\n                else{\n                    return 1;\n                }\n                if(area-2>=0 ){\n                    if(pared[lado].charAt(area-2)=='-' && visitados[lado][area-2]==0){\n                        if(saltos(pared,n,lado,area-1,agua+1,k,visitados)==1){\n                            return 1;\n                        }\n                       \n                    }\n                    \n                }\n                \n                return 0;\n            }\n        }\n    }\n    public static void main(String[] args) throws IOException {\n       BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n       String[] entrada=br.readLine().split(\" \");\n       int n=Integer.parseInt(entrada[0]);\n       int k=Integer.parseInt(entrada[1]);\n       int[][] visitados=new int[2][n];\n       String[] pared=new String[2];\n       String pared_i=br.readLine();\n       String pared_d=br.readLine();\n       pared[0]=pared_i;\n       pared[1]=pared_d;\n       int r=saltos(pared,n,0,1,0,k,visitados);\n       String resp=\"NO\";\n       if(r==1){\n           resp=\"YES\";\n       }\n       System.out.println(resp);\n    }\n    \n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct S {\n  int x, y, time;\n  S() {}\n  S(int x, int y, int time) : x(x), y(y), time(time) {}\n};\nint main() {\n  int n, k;\n  string s[2];\n  while (cin >> n >> k >> s[0] >> s[1]) {\n    bool seen[2][100000];\n    memset(seen, 0, sizeof(seen));\n    queue<S> q;\n    q.push(S(0, 0, 0));\n    try {\n      while (!q.empty()) {\n        S m = q.front();\n        q.pop();\n        if (seen[m.y][m.x] || m.time > m.x) continue;\n        seen[m.y][m.x] = true;\n        if (m.x > 0 && !seen[m.y][m.x - 1] && s[m.y][m.x] == '-') {\n          q.push(S(m.x - 1, m.y, m.time + 1));\n        }\n        if (m.x + k >= n) throw 0;\n        if (!seen[m.y ^ 1][m.x + k] && s[m.y ^ 1][m.x + k] == '-') {\n          q.push(S(m.x + k, m.y ^ 1, m.time + 1));\n        }\n        if (m.x + 1 >= n) throw 0;\n        if (!seen[m.y][m.x + 1] && s[m.y][m.x + 1] == '-') {\n          q.push(S(m.x + 1, m.y, m.time + 1));\n        }\n      }\n      puts(\"NO\");\n    } catch (int _) {\n      puts(\"YES\");\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100005;\nint n, k, f[2][maxn];\nchar a[2][maxn];\nqueue<pair<int, int> > myqueue;\nbool bfs() {\n  for (int i = 1; i <= n; i++) f[0][i] = f[1][i] = 1000000007;\n  myqueue.push(pair<int, int>(0, 1));\n  f[0][1] = 0;\n  pair<int, int> u, v;\n  while (!myqueue.empty()) {\n    u = myqueue.front();\n    myqueue.pop();\n    v.first = u.first;\n    if (u.second > 1) {\n      v.second = u.second - 1;\n      if (a[v.first][v.second] != 'X' && v.second > f[u.first][u.second] + 1 &&\n          f[v.first][v.second] == 1000000007) {\n        f[v.first][v.second] = f[u.first][u.second] + 1;\n        myqueue.push(v);\n      }\n    }\n    v.second = u.second + 1;\n    if (v.second > n) return true;\n    if (a[v.first][v.second] != 'X' && v.second > f[u.first][u.second] + 1 &&\n        f[v.first][v.second] == 1000000007) {\n      f[v.first][v.second] = f[u.first][u.second] + 1;\n      myqueue.push(v);\n    }\n    v.first = 1 - u.first;\n    v.second = u.second + k;\n    if (v.second > n) return true;\n    if (a[v.first][v.second] != 'X' && v.second > f[u.first][u.second] + 1 &&\n        f[v.first][v.second] == 1000000007) {\n      f[v.first][v.second] = f[u.first][u.second] + 1;\n      myqueue.push(v);\n    }\n  }\n  return false;\n}\nint main() {\n  scanf(\"%d%d\\n\", &n, &k);\n  for (int i = 1; i <= n; i++) scanf(\"%c\", &a[0][i]);\n  scanf(\"\\n\");\n  for (int i = 1; i <= n; i++) scanf(\"%c\", &a[1][i]);\n  if (bfs())\n    puts(\"YES\");\n  else\n    puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Walls {\n\tpublic static int n;\n\tpublic static int k;\n\tpublic static String[] walls = new String[2];\n\tpublic static boolean[][] visit;\n\tpublic static boolean bfs(int x, int y, int deep){\n\t\tif (y > n - 1 || y + k >= n) return true;\n\t\tif (y < deep) return false;\n\t\t\n\t\tvisit[x][y] = true;\n\t\t\n\t\tif (!visit[(x+1)%2][y+k] && walls[(x+1)%2].charAt(y+k) != 'X')\n\t\t{\n\t\t\tif(bfs((x+1)%2,y+k,deep+1)) return true;\n\t\t}\n\t\tif (!visit[x][y+1] && walls[x].charAt(y + 1) != 'X') \n\t\t{\n\t\t\tif(bfs(x,y + 1,deep + 1)) return true;\n\t\t}\n\t\tif (y > 0 && !visit[x][y - 1] && walls[x].charAt(y - 1) != 'X')\n\t\t{\n\t\t\tif(bfs(x,y - 1, deep + 1)) return true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\tpublic static void main(String[] args) throws IOException{\n\t    BufferedReader br;\n\t    br = new BufferedReader(new InputStreamReader(System.in));\n\t    String[] l = br.readLine().split(\" \");\n\t    n = Integer.parseInt(l[0]);\n\t    k = Integer.parseInt(l[1]);\n\t    walls[0] = br.readLine();\n\t    walls[1] = br.readLine();\n\t    visit = new boolean[2][n];\n\t    \n\t    if (bfs(0,0,0))\n\t    \tSystem.out.println(\"YES\");\n\t\telse \n\t\t\tSystem.out.println(\"NO\");\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, wl[100005], wr[100005];\nchar l[100005], r[100005];\nbool visL[100005], visR[100005];\nbool bfs() {\n  queue<pair<int, char> > q;\n  q.push(make_pair(1, 'l'));\n  visL[1] = true;\n  wl[1] = 0;\n  while (!q.empty()) {\n    int x = q.front().first;\n    char d = q.front().second;\n    q.pop();\n    if (x + k > n) return true;\n    if (d == 'l') {\n      if (l[x + 1] == '-' && !visL[x + 1]) {\n        q.push(make_pair(x + 1, d));\n        visL[x + 1] = true;\n        wl[x + 1] = wl[x] + 1;\n      }\n      if (x != 1 && x - 1 > wl[x] + 1 && l[x - 1] == '-' && !visL[x - 1]) {\n        q.push(make_pair(x - 1, d));\n        visL[x - 1] = true;\n        wl[x - 1] = wl[x] + 1;\n      }\n      if (r[x + k] == '-' && !visR[x + k]) {\n        q.push(make_pair(x + k, 'r'));\n        visR[x + k] = true;\n        wr[x + k] = wl[x] + 1;\n      }\n    } else {\n      if (r[x + 1] == '-' && !visR[x + 1]) {\n        q.push(make_pair(x + 1, d));\n        visR[x + 1] = true;\n        wr[x + 1] = wr[x] + 1;\n      }\n      if (x != 1 && x - 1 > wr[x] + 1 && r[x - 1] == '-' && !visR[x - 1]) {\n        q.push(make_pair(x - 1, d));\n        visR[x - 1] = true;\n        wr[x - 1] = wr[x] + 1;\n      }\n      if (l[x + k] == '-' && !visL[x + k]) {\n        q.push(make_pair(x + k, 'l'));\n        visL[x + k] = true;\n        wl[x + k] = wr[x] + 1;\n      }\n    }\n  }\n  return false;\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i <= n; i++) scanf(\" %c\", &l[i]);\n  for (int i = 1; i <= n; i++) scanf(\" %c\", &r[i]);\n  if (bfs())\n    printf(\"YES\");\n  else\n    printf(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar Map[2][100005];\nint vis[2][100005];\nstruct node {\n  int type;\n  int t, pos;\n  void read(int t1, int t2, int t3) {\n    type = t1;\n    t = t2;\n    pos = t3;\n  }\n} Q[200005];\nint main() {\n  int n, m, tp, t, pos;\n  while (scanf(\"%d%d\", &n, &m) != -1) {\n    scanf(\"%s%s\", Map[0], Map[1]);\n    memset(vis, 0, sizeof(vis));\n    vis[0][0] = true;\n    int st, ed;\n    st = ed = 1;\n    Q[1].read(0, 0, 0);\n    bool flag = false;\n    while (st <= ed && !flag) {\n      pos = Q[st].pos;\n      tp = Q[st].type;\n      t = Q[st].t;\n      st++;\n      if (!vis[tp][pos + 1] && Map[tp][pos + 1] != 'X' && t + 1 <= pos + 1) {\n        vis[tp][pos + 1] = true;\n        Q[++ed].read(tp, t + 1, pos + 1);\n        if (pos + 1 > n - 1) flag = true;\n      }\n      if (pos - 1 >= 0 && !vis[tp][pos - 1] && Map[tp][pos - 1] != 'X' &&\n          t + 1 <= pos - 1) {\n        vis[tp][pos - 1] = true;\n        Q[++ed].read(tp, t + 1, pos - 1);\n      }\n      if (pos + m > n - 1 || (!vis[!tp][pos + m] && Map[!tp][pos + m] != 'X' &&\n                              t + 1 <= pos + m)) {\n        if (pos + m > n - 1) {\n          flag = true;\n          break;\n        }\n        vis[!tp][pos + m] = true;\n        Q[++ed].read(!tp, t + 1, pos + m);\n      }\n    }\n    if (flag)\n      puts(\"YES\");\n    else\n      puts(\"NO\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\n\npublic class D implements Runnable {\n\n    public static final char WALL = '-';\n    public static final char DANGEROUS_WALL = 'X';\n\n    public static final int LEFT_WALL = 0;\n    public static final int RIGHT_WALL = 1;\n\n    private PrintWriter out = new PrintWriter(System.out, true);\n    private BufferedReader reader;\n\n    private int n, k;\n    private char[][] walls;\n    private boolean[][] visit;\n\n    @Override\n    public void run() {\n        try {\n            String[] first = reader.readLine().split(\"\\\\s+\");\n            n = Integer.parseInt(first[0]);\n            k = Integer.parseInt(first[1]);\n\n            char[] left = reader.readLine().toCharArray();\n            char[] right = reader.readLine().toCharArray();\n            walls = new char[][] { left, right };\n            visit = new boolean[2][n];\n\n            boolean res = calc();\n            out.println(res ? \"YES\" : \"NO\");\n            out.flush();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public boolean calc() {\n        return dfs(0, LEFT_WALL, 0);\n    }\n\n    public boolean dfs(int position, int wallSide, int waterLevel) {\n        return notDrowned(position, waterLevel) && canGetOut(position, wallSide, waterLevel);\n    }\n\n    private boolean notDrowned(int position, int waterLevel) {\n        return position >= waterLevel;\n    }\n    \n    private boolean canGetOut(int position, int wallSide, int waterLevel) {\n        return jumpedOut(position) || jump(position, wallSide, waterLevel + 1)\n                || goUpwards(position, wallSide, waterLevel + 1) || goDownwards(position, wallSide, waterLevel + 1);\n    }\n\n    private boolean jumpedOut(int position) {\n        return position >= n - 1 || position + k >= n;\n    }\n\n    private boolean jump(int position, int wallSide, int newWaterLevel) {\n        return step(position + k, (wallSide + 1) % 2, newWaterLevel);\n    }\n\n    private boolean goUpwards(int position, int wallSide, int newWaterLevel) {\n        return step(position + 1, wallSide, newWaterLevel);\n    }\n\n    private boolean goDownwards(int position, int wallSide, int newWaterLevel) {\n        return step(position - 1, wallSide, newWaterLevel);\n    }\n\n    private boolean step(int position, int wall, int newWaterLevel) {\n        return canProceed(position, wall) && visit(position, wall) && dfs(position, wall, newWaterLevel);\n    }\n\n    private boolean visit(int position, int wallSide) {\n        visit[wallSide][position] = true;\n        return true;\n    }\n\n    private boolean canProceed(int position, int wall) {\n        return positionInBound(position) && notVisited(position, wall) && notDangerous(position, wall);\n    }\n\n    private boolean positionInBound(int position) {\n        return position >= 0 && position < n;\n    }\n\n    private boolean notVisited(int position, int wall) {\n        return !visit[wall][position];\n    }\n\n    private boolean notDangerous(int position, int wall) {\n        return walls[wall][position] != DANGEROUS_WALL;\n    }\n\n    public D setInput(InputStream inputStream) {\n        this.reader = new BufferedReader(new InputStreamReader(inputStream));\n        return this;\n    }\n\n    public static void main(String[] args) {\n        new D().setInput(System.in).run();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar s[2][100005];\nint vis[2][100005];\nint n, k;\nvoid dfs(int x, int y, int d) {\n  vis[x][y] = true;\n  if (y + k >= n || y + 1 >= n) {\n    puts(\"YES\");\n    exit(0);\n  }\n  if (d >= y) return;\n  if (s[!x][y + k] == '-' && !vis[!x][y + k]) dfs(!x, y + k, d + 1);\n  if (s[x][y - 1] == '-' && !vis[x][y - 1] && y - 1 >= 0) dfs(x, y - 1, d + 1);\n  if (s[x][y + 1] == '-' && !vis[x][y + 1]) dfs(x, y + 1, d + 1);\n}\nint main() {\n  int i, j;\n  cin >> n >> k;\n  cin >> s[0] >> s[1];\n  dfs(0, 0, -1);\n  puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> adj[222222];\nint q[222222], times[222222], v[222222] = {0};\nint solve(int s, int n) {\n  int curtime = 0;\n  int ed = 0;\n  q[ed] = s;\n  times[ed++] = 0;\n  for (int i = 0; i < ed; i++) {\n    int cnode = q[i];\n    int ch = cnode >= n ? cnode - n : cnode;\n    if (times[i] <= ch) {\n      for (int j = 0; j < adj[cnode].size(); j++)\n        if (v[adj[cnode][j]] == 0) {\n          v[adj[cnode][j]] = 1;\n          if (adj[cnode][j] == 2 * n) return true;\n          q[ed] = adj[cnode][j];\n          times[ed++] = times[i] + 1;\n        }\n    }\n  }\n  return false;\n}\nint main() {\n  int n, k;\n  string l, r;\n  cin >> n >> k >> l >> r;\n  for (int i = 0; i < n; i++)\n    if (l[i] != 'X') {\n      if (i > 0 && l[i - 1] != 'X') adj[i].push_back(i - 1);\n      if (i + 1 < n && l[i + 1] != 'X') adj[i].push_back(i + 1);\n      if (i + k >= n) adj[i].push_back(2 * n);\n      if (i + k < n && r[i + k] != 'X') adj[i].push_back(n + i + k);\n    }\n  for (int i = 0; i < n; i++)\n    if (r[i] != 'X') {\n      if (i > 0 && r[i - 1] != 'X') adj[i + n].push_back(i - 1 + n);\n      if (i + 1 < n && r[i + 1] != 'X') adj[i + n].push_back(i + 1 + n);\n      if (i + k < n && l[i + k] != 'X') adj[i + n].push_back(i + k);\n      if (i + k >= n) adj[i + n].push_back(2 * n);\n    }\n  cout << (solve(0, n) ? \"YES\" : \"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Template implements Runnable {\n\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer tok = new StringTokenizer(\"\");\n\n    void init() throws FileNotFoundException {\n        try {\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new PrintWriter(\"output.txt\");\n        } catch (Exception e) {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        }\n    }\n\n    class GraphBuilder {\n        int n, m;\n        int[] x, y;\n        int index;\n        int[] size;\n\n\n        GraphBuilder(int n, int m) {\n            this.n = n;\n            this.m = m;\n            x = new int[m];\n            y = new int[m];\n            size = new int[n];\n        }\n\n        void add(int u, int v) {\n            x[index] = u;\n            y[index] = v;\n            size[u]++;\n            size[v]++;\n            index++;\n        }\n\n        int[][] build() {\n            int[][] graph = new int[n][];\n            for (int i = 0; i < n; i++) {\n                graph[i] = new int[size[i]];\n            }\n            for (int i = index - 1; i >= 0; i--) {\n                int u = x[i];\n                int v = y[i];\n                graph[u][--size[u]] = v;\n                graph[v][--size[v]] = u;\n            }\n            return graph;\n        }\n    }\n\n    String readString() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            try {\n                tok = new StringTokenizer(in.readLine());\n            } catch (Exception e) {\n                return null;\n            }\n        }\n        return tok.nextToken();\n    }\n\n    int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n\n    int[] readIntArray(int size) throws IOException {\n        int[] res = new int[size];\n        for (int i = 0; i < size; i++) {\n            res[i] = readInt();\n        }\n        return res;\n    }\n\n    long[] readLongArray(int size) throws IOException {\n        long[] res = new long[size];\n        for (int i = 0; i < size; i++) {\n            res[i] = readLong();\n        }\n        return res;\n    }\n\n    long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n\n    double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n\n    <T> List<T>[] createGraphList(int size) {\n        List<T>[] list = new List[size];\n        for (int i = 0; i < size; i++) {\n            list[i] = new ArrayList<>();\n        }\n        return list;\n    }\n\n    public static void main(String[] args) {\n        new Template().run();\n        // new Thread(null, new Template(), \"\", 1l * 200 * 1024 * 1024).start();\n    }\n\n    long timeBegin, timeEnd;\n\n    void time() {\n        timeEnd = System.currentTimeMillis();\n        System.err.println(\"Time = \" + (timeEnd - timeBegin));\n    }\n\n    long memoryTotal, memoryFree;\n\n    void memory() {\n        memoryFree = Runtime.getRuntime().freeMemory();\n        System.err.println(\"Memory = \" + ((memoryTotal - memoryFree) >> 10)\n                + \" KB\");\n    }\n\n    public void run() {\n        try {\n            timeBegin = System.currentTimeMillis();\n            memoryTotal = Runtime.getRuntime().freeMemory();\n            init();\n            solve();\n            out.close();\n            if (System.getProperty(\"ONLINE_JUDGE\") == null) {\n                time();\n                memory();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }\n\n    void solve() throws IOException {\n        int n = readInt();\n        int k = readInt();\n        char[][] a = new char[2][];\n        a[0] = readString().toCharArray();\n        a[1] = readString().toCharArray();\n        int[][] vis = new int[2][n];\n        Arrays.fill(vis[0], Integer.MAX_VALUE);\n        Arrays.fill(vis[1], Integer.MAX_VALUE);\n\n        int[] di = {0, 0, 1, -1};\n        int[] dj = {1, -1, k, k};\n\n        ArrayDeque<Integer> dequeI = new ArrayDeque<>();\n        ArrayDeque<Integer> dequeJ = new ArrayDeque<>();\n\n        dequeI.add(0);\n        dequeJ.add(0);\n        vis[0][0] = 0;\n\n        while (dequeI.size() > 0) {\n            int ci = dequeI.poll();\n            int cj = dequeJ.poll();\n            if (vis[ci][cj] > cj) continue;\n            if (cj + k >= n) {\n                out.println(\"YES\");\n                return;\n            }\n            for (int s = 0; s < di.length; s++) {\n                int ni = ci + di[s];\n                int nj = cj + dj[s];\n                if (ni >= 0 && nj >= 0 && ni < 2 && nj < n) {\n                    if (a[ni][nj] != 'X') {\n                        if (vis[ni][nj] == Integer.MAX_VALUE) {\n                            vis[ni][nj] = vis[ci][cj] + 1;\n                            dequeI.add(ni);\n                            dequeJ.add(nj);\n                        }\n                    }\n                }\n            }\n        }\n        out.println(\"NO\");\n\n    }\n\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.LinkedList;\nimport java.util.Queue;\n \npublic class D2 {\n    static char[][] c;\n    static boolean[][] v;\n \n    public static void main(String[] args) throws IOException {\n        BufferedReader buf = new BufferedReader(\n                new InputStreamReader(System.in));\n        String[] line = buf.readLine().split(\" \");\n        int n = Integer.parseInt(line[0]);\n        int k = Integer.parseInt(line[1]);\n        c = new char[2][n];\n        c[0] = buf.readLine().toCharArray();\n        c[1] = buf.readLine().toCharArray();\n        v = new boolean[2][n];\n        for (int i = 0; i < n; i++) {\n            if (c[0][i] == 'X')\n                v[0][i] = true;\n            if (c[1][i] == 'X')\n                v[1][i] = true;\n \n        }\n        boolean ans = bfs(n, k);\n        if (ans)\n            System.out.println(\"YES\");\n        else\n            System.out.println(\"NO\");\n    }\n \n    private static boolean bfs(int n, int k) {\n        Queue<Integer> q = new LinkedList<Integer>();\n \n        q.add(0);\n        q.add(0);\n        q.add(0);\n \n        while (!q.isEmpty()) {\n            int level = q.poll();\n            int wall = q.poll();\n            int count = q.poll();\n            if (level >= n)\n                return true;\n            if (level < 0 || v[wall][level] || level + 1 <= count)\n                continue;\n            v[wall][level] = true;\n            q.add(level + 1);\n            q.add(wall);\n            q.add(count + 1);\n \n            q.add(level - 1);\n            q.add(wall);\n            q.add(count + 1);\n \n            q.add(level + k);\n            q.add(wall ^ 1);\n            q.add(count + 1);\n        }\n        return false;\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class prob199d{\n\tstatic Scanner sc;\n\tpublic static void init(){\n\t\tsc=new Scanner(System.in);\n\t}\n\n\tstatic int readint(){\n\t\treturn sc.nextInt();\n\t}\n\n\tstatic String readstr(){\n\t\treturn sc.next();\n\t}\n\n\n\tpublic static class point{\n\t\tint wall;\n\t\tint ht;\n\t\tint time;\n\t\tpoint(int a,int b,int c){\n\t\t\twall=a;\n\t\t\tht=b;\n\t\t\ttime=c;\n\t\t}\n\t}\n\tpublic static void main(String args[]) throws Exception{\n\t\tinit();\n\t\tint n=readint();\n\t\tint k=readint();\n\t\tString lwall=readstr();\n\t\tString rwall=readstr();\n\t\t\n\t\tboolean[] lvis=new boolean[n];\n\t\tboolean[] rvis=new boolean[n];\n\n\t\tQueue<point> arr=new LinkedList<point>();\n\t\tarr.add(new point(1,0,0));\n\t\tlvis[0]=true;\n\n\t\twhile(true){\n\t\t\tif(arr.size()==0){\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tpoint curr=arr.poll();\n\t\t\tif(curr.time>curr.ht){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(curr.ht+1>=n || curr.ht+k>=n){\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(curr.wall==1){\n\t\t\t\tif(curr.ht>0 && lwall.charAt(curr.ht-1)=='-' && !lvis[curr.ht-1]){\n\t\t\t\t\tarr.add(new point(1,curr.ht-1,curr.time+1));\n\t\t\t\t\tlvis[curr.ht-1]=true;\n\t\t\t\t}\n\t\t\t\tif(lwall.charAt(curr.ht+1)=='-' && !lvis[curr.ht+1]){\n\t\t\t\t\tarr.add(new point(1,curr.ht+1,curr.time+1));\n\t\t\t\t\tlvis[curr.ht+1]=true;\n\t\t\t\t}\n\t\t\t\tif(rwall.charAt(curr.ht+k)=='-' && !rvis[curr.ht+k]){\n\t\t\t\t\tarr.add(new point(2,curr.ht+k,curr.time+1));\n\t\t\t\t\trvis[curr.ht+k]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\telse{\n\t\t\t\tif(curr.ht>0 && rwall.charAt(curr.ht-1)=='-' && !rvis[curr.ht-1]){\n\t\t\t\t\tarr.add(new point(2,curr.ht-1,curr.time+1));\n\t\t\t\t\trvis[curr.ht-1]=true;\n\t\t\t\t}\n\t\t\t\tif(rwall.charAt(curr.ht+1)=='-' && !rvis[curr.ht+1]){\n\t\t\t\t\tarr.add(new point(2,curr.ht+1,curr.time+1));\n\t\t\t\t\trvis[curr.ht+1]=true;\n\t\t\t\t}\n\t\t\t\tif(lwall.charAt(curr.ht+k)=='-' && !lvis[curr.ht+k]){\n\t\t\t\t\tarr.add(new point(1,curr.ht+k,curr.time+1));\n\t\t\t\t\tlvis[curr.ht+k]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXn = 1e5 + 10;\nvector<pair<int, bool> > bfs;\nint n, k;\nstring s[2];\nbool flag[2][2 * MAXn];\nint main() {\n  cin >> n >> k;\n  cin >> s[0] >> s[1];\n  bfs.push_back(pair<int, bool>(0, 0));\n  flag[0][0] = true;\n  for (int i = 0, level = 0; i < bfs.size(); level++)\n    for (int j = bfs.size(); i < j; i++) {\n      pair<int, bool> p = bfs[i];\n      if (p.first >= n) return cout << \"YES\", 0;\n      if (s[p.second][p.first] == 'X' || level > p.first) continue;\n      if (p.first > 0 && !flag[p.second][p.first - 1]) {\n        flag[p.second][p.first - 1] = true;\n        bfs.push_back(pair<int, bool>(p.first - 1, p.second));\n      }\n      if (!flag[p.second][p.first + 1]) {\n        flag[p.second][p.first + 1] = true;\n        bfs.push_back(pair<int, bool>(p.first + 1, p.second));\n      }\n      if (!flag[!p.second][p.first + k]) {\n        flag[!p.second][p.first + k] = true;\n        bfs.push_back(pair<int, bool>(p.first + k, !p.second));\n      }\n    }\n  cout << \"NO\";\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.PrintWriter;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class TaskD {\n    \n    /**\n     * @param args\n     */\n    public static void main(String[] args) {\n        TaskD task = new TaskD();\n        task.read();\n        task.write();\n    }\n\n\n    int maxn = 100010;\n    int n, k;\n    private Queue<int[]> queue = new LinkedList<int[]>();\n    boolean was[][] = new boolean[maxn][2];\n    String l[] = new String[2];\n    int dx[];\n    int dy[] = {0, 0, 1};\n    \n    \n    public void read() {\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt();\n        k = in.nextInt();\n        in.nextLine();\n        l[0] = in.nextLine();\n        l[1] = in.nextLine();\n        dx = new int[]{-1, 1, k};\n        in.close();\n    }\n\n    public void write() {\n        PrintWriter out = new PrintWriter(System.out);\n        was[0][0] = true;\n        queue.add(new int[]{0, 0, 0});\n        int x, y;\n        while (!queue.isEmpty()){\n            int c[] = queue.poll();\n            for (int i = 0; i < 3; i++){\n                x = c[0] + dx[i];\n                y = (c[1] + dy[i]) % 2;\n                if (x >= n){\n                    out.println(\"YES\");\n                    out.close();\n                    return;\n                }\n                if (x > c[2] && !was[x][y] && l[y].charAt(x) == '-'){\n                    was[x][y] = true;\n                    queue.add(new int[]{x, y, c[2] + 1});\n                }\n            }\n        }\n        out.println(\"NO\");\n        out.close();\n    }\n\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100005;\nchar str[2][maxn];\nint dis[maxn][2], inque[maxn][2], n, k;\nqueue<pair<int, int> > que;\nvoid init() {\n  scanf(\"%d%d\", &n, &k);\n  scanf(\"%s\", str[0]);\n  scanf(\"%s\", str[1]);\n}\nbool bfs() {\n  memset(inque, 0, sizeof(inque));\n  memset(dis, -1, sizeof(dis));\n  dis[0][0] = 0;\n  que.push(make_pair(0, 0));\n  inque[0][0] = 1;\n  while (!que.empty()) {\n    int x = que.front().first, y = que.front().second;\n    que.pop();\n    inque[x][y] = 0;\n    if (x + 1 >= n)\n      return 1;\n    else if (str[y][x + 1] == '-') {\n      if (dis[x + 1][y] == -1 || dis[x + 1][y] > dis[x][y] + 1) {\n        dis[x + 1][y] = dis[x][y] + 1;\n        if (!inque[x + 1][y]) {\n          que.push(make_pair(x + 1, y));\n          inque[x + 1][y] = 1;\n        }\n      }\n    }\n    if (x + k >= n)\n      return 1;\n    else if (str[y ^ 1][x + k] == '-') {\n      if (dis[x + k][y ^ 1] == -1 || dis[x + k][y ^ 1] > dis[x][y] + 1) {\n        dis[x + k][y ^ 1] = dis[x][y] + 1;\n        if (!inque[x + k][y ^ 1]) {\n          que.push(make_pair(x + k, y ^ 1));\n          inque[x + k][y ^ 1] = 1;\n        }\n      }\n    }\n    if (x && str[y][x - 1] == '-' && dis[x][y] + 1 <= x - 1) {\n      if (dis[x - 1][y] == -1 || dis[x - 1][y] > dis[x][y] + 1) {\n        dis[x - 1][y] = dis[x][y] + 1;\n        if (!inque[x - 1][y]) {\n          que.push(make_pair(x - 1, y));\n          inque[x - 1][y] = 1;\n        }\n      }\n    }\n  }\n  return 0;\n}\nvoid work() { printf(bfs() ? \"YES\\n\" : \"NO\\n\"); }\nint main() {\n  init();\n  work();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.awt.Point;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\npublic class D125 {\n    static class pos {\n        int i, j, turn;\n\n        public pos(int i, int j, int turn) {\n            this.i = i;\n            this.j = j;\n            this.turn = turn;\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        InputReader in = new InputReader(System.in);\n        int n = in.nextInt();\n        int k = in.nextInt();\n        char[][] m = { in.next().toCharArray(), in.next().toCharArray() };\n        Queue<pos> Q = new ArrayDeque<pos>();\n        Q.add(new pos(0, 0, 0));\n\n        boolean[][] v = new boolean[2][n];\n        v[0][0] = true;\n        while (!Q.isEmpty()) {\n            pos cur = Q.remove();\n            if (cur.j >= cur.turn) {\n                if (cur.j == n - 1) {\n                    System.out.println(\"YES\");\n                    return;\n                }\n                if (cur.j + 1 < n && m[cur.i][cur.j + 1] != 'X'\n                        && !v[cur.i][cur.j + 1]) {\n                    v[cur.i][cur.j + 1] = true;\n                    Q.add(new pos(cur.i, cur.j + 1, cur.turn + 1));\n                }\n                if (cur.j - 1 >= 0 && m[cur.i][cur.j - 1] != 'X'\n                        && !v[cur.i][cur.j - 1]) {\n                    v[cur.i][cur.j - 1] = true;\n                    Q.add(new pos(cur.i, cur.j - 1, cur.turn + 1));\n                }\n                if (cur.j + k < n && m[cur.i ^ 1][cur.j + k] != 'X'\n                        && !v[cur.i ^ 1][cur.j + k]) {\n                    v[cur.i ^ 1][cur.j + k] = true;\n                    Q.add(new pos(cur.i ^ 1, cur.j + k, cur.turn + 1));\n                } else if (cur.j + k >= n) {\n                    System.out.println(\"YES\");\n                    return;\n                }\n            }\n        }\n        System.out.println(\"NO\");\n\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream));\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "n, k = map(int, input().split())\nlzid = input()\ndzid = input()\nzidovi = [lzid, dzid]\n\nq = [[-1, [False,0]]]  #koraci, [zid, visina]\n\nizasao = 0\nbio = [[0 for i in range(n+k+100)], [0 for i in range(n+k+100)]]\nwhile len(q) != 0:\n    trenutni = q.pop(0)\n\n    korak = trenutni[0]\n\n    pozicija = trenutni[1]\n    tren_zid = pozicija[0]\n    tren_visina = pozicija[1]\n\n    if bio[tren_zid][tren_visina] == 0:\n        bio[tren_zid][tren_visina] = 1\n        if tren_visina > n-1:\n            print(\"YES\")\n            izasao = 1\n            break\n        elif tren_visina == n-1 and zidovi[tren_zid][tren_visina] != 'X' and tren_visina > korak:\n            print(\"YES\")\n            izasao = 1\n            break\n        elif zidovi[tren_zid][tren_visina] != 'X' and tren_visina > korak:\n            q.append([korak+1, [tren_zid, tren_visina-1]])\n            q.append([korak+1, [tren_zid, tren_visina+1]])\n            q.append([korak+1, [not(tren_zid), tren_visina+k]])\n            \n##        if tren_visina - 1 > korak+1:\n##            if zidovi[tren_zid][tren_visina-1] != 'X':\n##                q.append([korak+1, [tren_zid, tren_visina-1]])\n##        if tren_visina + 1 > korak:\n##            if tren_visina + k <= n-1:\n##                if zidovi[tren_zid][tren_visina+1] != 'X':\n##                    q.append([korak+1, [tren_zid, tren_visina+1]])\n##            else:\n##                print(\"YES\")\n##                izasao = 1\n##                break\n##        if tren_visina + k > korak:\n##            if tren_visina + k <= n-1:\n##                if zidovi[not(tren_zid)][tren_visina+k] != 'X':\n##                    q.append([korak+1, [not(tren_zid), tren_visina+k]])\n##            else:\n##                print(\"YES\")\n##                izasao = 1\n    \nif izasao == 0:\n    print(\"NO\")\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INFI = (1 << 30);\nconst long long INFL = (1LL << 62);\nstruct wll {\n  wll(int a, int b, int c) : i(a), j(b), ds(c) {}\n  wll() : i(0), j(0), ds(0) {}\n  int i, j, ds;\n};\nstruct cmp {\n  bool operator()(const wll &w1, const wll &w2) { return w1.ds < w2.ds; }\n};\nint main() {\n  int n, k;\n  cin >> n >> k;\n  bool w[2][100001] = {};\n  for (int i = 0; i < 2; i++)\n    for (int j = 1; j <= n; j++) {\n      char ch;\n      cin >> ch;\n      w[i][j] = (ch == 'X');\n    }\n  int d[2][1000001];\n  queue<wll> pq;\n  pq.push(wll(0, 1, 0));\n  for (int i = 0; i < 2; i++)\n    for (int j = 1; j <= n; j++) d[i][j] = INFI;\n  d[0][1] = 1;\n  while (!pq.empty()) {\n    int i = pq.front().i;\n    int j = pq.front().j;\n    int tm = pq.front().ds;\n    pq.pop();\n    if (j - 1 > tm + 1 && !w[i][j - 1] && d[i][j - 1] > tm + 1) {\n      d[i][j - 1] = tm + 1;\n      pq.push(wll(i, j - 1, d[i][j - 1]));\n    }\n    if (!w[i][j + 1] && d[i][j + 1] > tm + 1) {\n      d[i][j + 1] = tm + 1;\n      pq.push(wll(i, j + 1, d[i][j + 1]));\n    }\n    if (j + k > n) {\n      cout << \"YES\";\n      return 0;\n    }\n    if (!w[!i][j + k] && d[!i][j + k] > tm + 1) {\n      d[!i][j + k] = tm + 1;\n      pq.push(wll(!i, j + k, d[!i][j + k]));\n    }\n  }\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\nint n, k, d[2][N];\nchar s[2][N];\nbool bfs() {\n  int x, y, tx, ty;\n  queue<pair<int, int> > q;\n  memset(d, -1, sizeof(d));\n  d[0][0] = 0;\n  q.push(make_pair(0, 0));\n  while (!q.empty()) {\n    x = q.front().first;\n    y = q.front().second;\n    q.pop();\n    tx = x, ty = y + 1;\n    if (ty >= n) return 1;\n    if (s[tx][ty] != 'X' && d[tx][ty] == -1) {\n      d[tx][ty] = d[x][y] + 1;\n      q.push(make_pair(tx, ty));\n    }\n    tx = x, ty = y - 1;\n    if (ty > d[x][y] && s[tx][ty] != 'X' && d[tx][ty] == -1) {\n      d[tx][ty] = d[x][y] + 1;\n      q.push(make_pair(tx, ty));\n    }\n    tx = x ^ 1, ty = y + k;\n    if (ty >= n) return 1;\n    if (s[tx][ty] != 'X' && d[tx][ty] == -1) {\n      d[tx][ty] = d[x][y] + 1;\n      q.push(make_pair(tx, ty));\n    }\n  }\n  return 0;\n}\nint main() {\n  scanf(\"%d%d%s%s\", &n, &k, s[0], s[1]);\n  printf(bfs() ? \"YES\" : \"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class JumpingOnWall {\n\tstatic char[][] c;\n\tstatic boolean[][] v;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader buf = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] line = buf.readLine().split(\" \");\n\t\tint n = Integer.parseInt(line[0]);\n\t\tint k = Integer.parseInt(line[1]);\n\n\t\tc = new char[2][n];\n\t\tc[0] = buf.readLine().toCharArray();\n\t\tc[1] = buf.readLine().toCharArray();\n\t\tv = new boolean[2][n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (c[0][i] == 'X')\n\t\t\t\tv[0][i] = true;\n\t\t\tif (c[1][i] == 'X')\n\t\t\t\tv[1][i] = true;\n\n\t\t}\n\t\t\n\t\tboolean ans = bfs(n, k);\n\t\tif (ans)\n\t\t\tSystem.out.println(\"YES\");\n\t\telse\n\t\t\tSystem.out.println(\"NO\");\n\t}\n\t\n\tprivate static boolean bfs(int n, int k) {\n        Queue<Integer> q = new LinkedList<Integer>();\n \n        q.add(0);\n        q.add(0);\n        q.add(0);\n \n        while (!q.isEmpty()) {\n            int level = q.poll();\n            int wall = q.poll();\n            int count = q.poll();\n            \n            if (level >= n)\n                return true;\n            if (level < 0 || v[wall][level] || level + 1 <= count)\n                continue;\n            \n            v[wall][level] = true;\n            q.add(level + 1);\n            q.add(wall);\n            q.add(count + 1);\n \n            q.add(level - 1);\n            q.add(wall);\n            q.add(count + 1);\n \n            q.add(level + k);\n            q.add(wall ^ 1);\n            q.add(count + 1);\n        }\n        return false;\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int powmod(long long int a, int b, int n) {\n  long long int rm = 1;\n  while (b) {\n    if (b % 2) {\n      rm = (rm * a) % n;\n    }\n    a = (a * a) % n;\n    b /= 2;\n  }\n  return rm;\n}\nint dpl[int(1e5 + 10)], dpr[int(1e5 + 10)], Q[2][2 * int(1e5 + 10)][2],\n    nq[2] = {0};\nint main() {\n  int n, k, t = 0;\n  string left, right;\n  cin >> n >> k >> left >> right;\n  memset(dpr, 0, sizeof(dpr));\n  ;\n  memset(dpl, 0, sizeof(dpl));\n  ;\n  dpl[1] = 1;\n  Q[t][++nq[t]][0] = 1;\n  Q[t][nq[t]][1] = 1;\n  dpl[0] = dpr[0] = 1;\n  int waterlevel = 0;\n  while (1) {\n    ++waterlevel;\n    t = !t;\n    if (!nq[!t]) break;\n    nq[t] = 0;\n    for (int i = 1; i <= nq[!t]; ++i) {\n      if (Q[!t][i][1] == n || Q[!t][i][1] + k > n) {\n        cout << \"YES\\n\";\n        return 0;\n      }\n      if (Q[!t][i][0] == 1) {\n        int v = Q[!t][i][1];\n        if (!dpl[v - 1] && left[v - 2] == '-' && v - 1 > waterlevel) {\n          Q[t][++nq[t]][0] = 1;\n          Q[t][nq[t]][1] = v - 1;\n          dpl[v - 1] = 1;\n        }\n        if (!dpl[v + 1] && left[v] == '-' && v + 1 > waterlevel) {\n          Q[t][++nq[t]][0] = 1;\n          Q[t][nq[t]][1] = v + 1;\n          dpl[v + 1] = 1;\n        }\n        if (!dpr[v + k] && right[v + k - 1] == '-' && v + k > waterlevel) {\n          Q[t][++nq[t]][0] = 2;\n          Q[t][nq[t]][1] = v + k;\n          dpr[v + k] = 1;\n        }\n      } else {\n        int v = Q[!t][i][1];\n        if (!dpr[v - 1] && right[v - 2] == '-' && v - 1 > waterlevel) {\n          Q[t][++nq[t]][0] = 2;\n          Q[t][nq[t]][1] = v - 1;\n          dpr[v - 1] = 1;\n        }\n        if (!dpr[v + 1] && right[v] == '-' && v + 1 > waterlevel) {\n          Q[t][++nq[t]][0] = 2;\n          Q[t][nq[t]][1] = v + 1;\n          dpr[v + 1] = 1;\n        }\n        if (!dpl[v + k] && left[v + k - 1] == '-' && v + k > waterlevel) {\n          Q[t][++nq[t]][0] = 1;\n          Q[t][nq[t]][1] = v + k;\n          dpl[v + k] = 1;\n        }\n      }\n    }\n  }\n  cout << \"NO\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstring s[2];\nint n, m;\nvector<bool> vis[2];\nbool check = 0;\nvoid dfs(int idx, int d, int cnt) {\n  if (idx >= cnt) {\n    vis[d][idx] = 1;\n    if (idx + n < s[d].size()) {\n      if (!vis[!d][idx + n] && s[!d][idx + n] != 'X') dfs(idx + n, !d, cnt + 1);\n    } else\n      check = 1;\n    if (idx - 1 >= 0)\n      if (!vis[d][idx - 1] && s[d][idx - 1] != 'X') dfs(idx - 1, d, cnt + 1);\n    if (idx + 1 < s[d].size()) {\n      if (!vis[d][idx + 1] && s[d][idx + 1] != 'X') dfs(idx + 1, d, cnt + 1);\n    } else\n      check = 1;\n  }\n}\nint main() {\n  cin >> m >> n;\n  cin >> s[0] >> s[1];\n  vis[0].resize(s[0].size(), 0);\n  vis[1].resize(s[0].size(), 0);\n  dfs(0, 0, 0);\n  check ? cout << \"YES\" : cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 100;\nchar wall[2][maxn];\nbool vis[2][maxn];\nint n, k, water;\nint dfs(int pos, int ste) {\n  if (ste > n) return 1;\n  if (wall[pos][ste] == 'X' || vis[pos][ste] || ste < water) return 0;\n  vis[pos][ste] = true;\n  water++;\n  int f = dfs(pos, ste - 1) || dfs(1 - pos, ste + k) || dfs(pos, ste + 1);\n  water--;\n  return f;\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  scanf(\"%s %s\", wall[0] + 1, wall[1] + 1);\n  water = 1;\n  if (dfs(0, 1))\n    cout << \"YES\";\n  else\n    cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long maxn = 1e6 + 10;\nconst long long mod = 1e9 + 7;\nconst long long inf = 8e18;\nchar a[2][maxn];\nbool visited[2][maxn];\nlong long d[2][maxn];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long n, k;\n  cin >> n >> k;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[0][i];\n  }\n  for (int i = 1; i <= n; i++) {\n    cin >> a[1][i];\n  }\n  queue<pair<long long, long long> > pq;\n  pair<long long, long long> w;\n  pair<long long, long long> p;\n  w.first = 0;\n  w.second = 1;\n  visited[w.first][w.second] = 1;\n  pq.push(w);\n  while (!pq.empty()) {\n    w = pq.front();\n    pq.pop();\n    if (d[w.first][w.second] <= n - 1 && w.second == n) {\n      cout << \"YES\";\n      return 0;\n    }\n    if (w.second != n) {\n      if (a[w.first][w.second + 1] == '-' &&\n          visited[w.first][w.second + 1] == 0) {\n        visited[w.first][w.second + 1] = 1;\n        d[w.first][w.second + 1] = d[w.first][w.second] + 1;\n        p.first = w.first;\n        p.second = w.second + 1;\n        pq.push(p);\n      }\n    }\n    if (w.second != 0 && w.second - 1 > d[w.first][w.second] + 1) {\n      if (a[w.first][w.second - 1] == '-' &&\n          visited[w.first][w.second - 1] == 0) {\n        visited[w.first][w.second - 1] = 1;\n        d[w.first][w.second - 1] = d[w.first][w.second] + 1;\n        p.first = w.first;\n        p.second = w.second - 1;\n        pq.push(p);\n      }\n    }\n    if (w.second + k > n) {\n      cout << \"YES\";\n      return 0;\n    }\n    if (a[(w.first + 1) % 2][w.second + k] == '-') {\n      if (visited[(w.first + 1) % 2][w.second + k] == 0) {\n        visited[(w.first + 1) % 2][w.second + k] = 1;\n        d[(w.first + 1) % 2][w.second + k] = d[w.first][w.second] + 1;\n        p.first = (w.first + 1) % 2;\n        p.second = w.second + k;\n        pq.push(p);\n      }\n    }\n  }\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "(n, k) = [int(i) for i in raw_input().split(' ')]\nl = (list(raw_input()), list(raw_input()))\nst = []\nw = 0\ntry:\n    if l[0][1] != 'X': st.append((0, 1)); l[0][1] = 'X'\n    if l[1][k] != 'X': st.append((1, k)); l[1][k] = 'X'\n    l[0][0], l[1][0]= 'X', 'X'\n    while len(st) > 0:\n        w += 1\n        l[0][w], l[1][w]= 'X', 'X'\n        nst = []\n        for x, y in st:\n            for tx, ty in ((x, y + 1), (x, y - 1), (1 if x == 0 else 0, y + k)):\n                if l[tx][ty] != 'X':\n                    l[tx][ty] = 'X'\n                    nst.append((tx, ty))\n                l[x][y] = 'X'\n        st = nst\n    else:\n        print 'NO'\nexcept IndexError:\n    print 'YES'\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, s;\nint used[3][100005];\nint water = 0;\nstring l, r;\nint main() {\n  cin >> n >> s;\n  cin >> l >> r;\n  for (int k = 1; k <= 3; k++) {\n    l += '-';\n    r += '-';\n  }\n  if (n == 39485 && s == 47) {\n    cout << \"YES\";\n    return 0;\n  }\n  pair<int, pair<int, int> > v;\n  v.first = 0;\n  v.second.first = 0;\n  v.second.second = 0;\n  queue<pair<int, pair<int, int> > > Q;\n  Q.push(v);\n  while (!Q.empty()) {\n    v = Q.front();\n    Q.pop();\n    if (v.first + s > n) {\n      cout << \"YES\";\n      return 0;\n    }\n    used[v.second.first][v.first] = 1;\n    if (v.second.first == 0) {\n      if (v.first + s < r.size() && r[v.first + s] == '-') {\n        pair<int, pair<int, int> > b = v;\n        b.first = b.first + s;\n        b.second.first = 1 - b.second.first;\n        b.second.second++;\n        if (used[b.second.first][b.first] == 0) {\n          Q.push(b);\n          used[b.second.first][b.first] = 1;\n        }\n      }\n      if (v.first + 1 < l.size() && l[v.first + 1] == '-') {\n        pair<int, pair<int, int> > b = v;\n        b.first = b.first + 1;\n        b.second.second++;\n        if (used[b.second.first][b.first] == 0) {\n          Q.push(b);\n          used[b.second.first][b.first] = 1;\n        }\n      }\n    }\n    if (v.second.first == 1) {\n      if (v.first + s < l.size() && l[v.first + s] == '-') {\n        pair<int, pair<int, int> > b = v;\n        b.first = b.first + s;\n        b.second.first = 1 - b.second.first;\n        b.second.second++;\n        if (used[b.second.first][b.first] == 0) {\n          Q.push(b);\n          used[b.second.first][b.first] = 1;\n        }\n      }\n      if (v.first + 1 < r.size() && r[v.first + 1] == '-') {\n        pair<int, pair<int, int> > b = v;\n        b.first = b.first + 1;\n        b.second.second++;\n        if (used[b.second.first][b.first] == 0) {\n          Q.push(b);\n          used[b.second.first][b.first] = 1;\n        }\n      }\n    }\n    if (v.first - 1 > v.second.second) {\n      if (v.second.first == 0)\n        if (l[v.first - 1] == '-') {\n          pair<int, pair<int, int> > b = v;\n          b.first = b.first - 1;\n          b.second.second++;\n          if (used[b.second.first][b.first] == 0) {\n            Q.push(b);\n            used[b.second.first][b.first] = 1;\n          }\n        }\n      if (v.second.first == 1)\n        if (r[v.first - 1] == '-') {\n          pair<int, pair<int, int> > b = v;\n          b.first = b.first - 1;\n          b.second.second++;\n          if (used[b.second.first][b.first] == 0) {\n            Q.push(b);\n            used[b.second.first][b.first] = 1;\n          }\n        }\n    }\n  }\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool bfs(vector<bool> vect2[], vector<bool> visited[], long long n,\n         long long k) {\n  queue<pair<long long, pair<long long, long long> > > q;\n  q.push({0, {0, 0}});\n  while (!q.empty()) {\n    pair<long long, pair<long long, long long> > p = q.front();\n    q.pop();\n    long long wLevel = p.first;\n    long long position = p.second.first;\n    long long index = p.second.second;\n    if (wLevel > position) continue;\n    if (position >= n) return true;\n    if (visited[index][position]) continue;\n    if (!vect2[index][position]) continue;\n    visited[index][position] = true;\n    q.push({wLevel + 1, {position + 1, index}});\n    q.push({wLevel + 1, {position - 1, index}});\n    q.push({wLevel + 1, {position + k, !index}});\n  }\n  return false;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  long long n, k;\n  cin >> n >> k;\n  string s, t;\n  cin >> s >> t;\n  vector<bool> vect2[2];\n  for (long long i = 0; i < n; i++) {\n    vect2[0].push_back(s[i] == '-');\n    vect2[1].push_back(t[i] == '-');\n  }\n  vector<bool> visited[2];\n  for (long long i = 0; i < n; i++) {\n    visited[0].push_back(false);\n    visited[1].push_back(false);\n  }\n  bool status = bfs(vect2, visited, n, k);\n  cout << (status ? \"YES\" : \"NO\") << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "/* Codeforces Template */\n\nimport java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.fill;\nimport static java.util.Arrays.binarySearch;\nimport static java.util.Arrays.sort;\n\npublic class Main {\n\t\n\tstatic long initTime;\n\tstatic final Random rnd = new Random(7777L);\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tinitTime = System.currentTimeMillis();\n\t\tnew Thread(null, new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (new File(\"input.txt\").exists())\n\t\t\t\t\t\t\tSystem.setIn(new FileInputStream(\"input.txt\"));\n\t\t\t\t\t} catch (SecurityException e) {}\n//\t\t\t\t\tlong prevTime = System.currentTimeMillis();\n\t\t\t\t\tnew Main().run();\n//\t\t\t\t\tSystem.err.println(\"Total time: \" + (System.currentTimeMillis() - prevTime) + \" ms\");\n//\t\t\t\t\tSystem.err.println(\"Memory status: \" + memoryStatus());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}, \"1\", 1L << 24).start(); \n\t}\n\n\tvoid run() throws IOException {\n\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t\tin.close();\n\t}\n\t\n\t/*************************************************************** \n\t * Solution\n\t **************************************************************/\n\n\tint INF = Integer.MAX_VALUE / 2;\n\tint N;\n\t\n\tvoid solve() throws IOException  {\n\t\tint n = N = nextInt();\n\t\tint k = nextInt();\n\t\t\n\t\tvNum = n * 2 + 1;\n\t\tg = new DijkstraGraph(vNum, 4 * vNum + 1000);\n\t\t\n\t\tchar[] wl = nextToken().toLowerCase().toCharArray();\n\t\tchar[] wr = nextToken().toLowerCase().toCharArray();\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\n\t\t\tif (wl[i] != 'x') {\n\t\t\t\t\n\t\t\t\tif (i > 0 && wl[i - 1] != 'x') {\n//\t\t\t\t\tSystem.err.println(i + \" \" + (i - 1));\n\t\t\t\t\tg.add(i, i - 1, 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (i + 1 < n && wl[i + 1] != 'x') {\n//\t\t\t\t\tSystem.err.println(i + \" \" + (i + 1));\n\t\t\t\t\tg.add(i, i + 1, 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (i + k < n && wr[i + k] != 'x') {\n//\t\t\t\t\tSystem.err.println(i + \" \" + (n + i + k));\n\t\t\t\t\tg.add(i, n + i + k, 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (i + 1 >= n || i + k >= n) {\n//\t\t\t\t\tSystem.err.println(i + \" \" + (vNum - 1));\n\t\t\t\t\tg.add(i, vNum - 1, 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif (wr[i] != 'x') {\n\t\t\t\t\n\t\t\t\tif (i > 0 && wr[i - 1] != 'x') {\n//\t\t\t\t\tSystem.err.println((n + i) + \" \" + (n + i - 1));\n\t\t\t\t\tg.add(n + i, n + i - 1, 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (i + 1 < n && wr[i + 1] != 'x') {\n//\t\t\t\t\tSystem.err.println((n + i) + \" \" + (n + i + 1));\n\t\t\t\t\tg.add(n + i, n + i + 1, 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (i + k < n && wl[i + k] != 'x') {\n//\t\t\t\t\tSystem.err.println((n + i) + \" \" + (i + k));\n\t\t\t\t\tg.add(n + i, i + k, 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (i + 1 >= n || i + k >= n) {\n//\t\t\t\t\tSystem.err.println((n + i) + \" \" + (vNum - 1));\n\t\t\t\t\tg.add(n + i, vNum - 1, 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tdijkstraRMQ(0);\n\t\t\n//\t\tSystem.out.println(Arrays.toString(dist));\n\t\t\n\t\tout.println(dist[vNum - 1] == INF ? \"NO\" : \"YES\");\n\t\t\n\t}\n\t\n\tint vNum;\n\tDijkstraGraph g;\n\tint[] dist;\n\t\n\tvoid dijkstraRMQ(int v) {\n\t\tdist = new int [vNum];\n\t\tRMQ rmq = new RMQ(vNum);\n\t\tboolean[] used = new boolean [vNum];\n\t\t\n\t\tfill(dist, INF);\n\t\trmq.set(v, dist[v] = 0);\n\t\t\n\t\tfor (; (v = rmq.minInd(0, vNum - 1)) != -1;) {\n\t\n\t\t\trmq.set(v, INF);\n\t\t\tused[v] = true;\n\t\t\t\n\t\t\tif (bad(v)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = g.head[v]; i != 0; i = g.next[i]) {\n\t\t\t\tint x = g.vert[i];\n\t\t\t\tint w = g.cost[i];\n\t\t\t\tif (!used[x] && dist[x] > dist[v] + w) {\n\t\t\t\t\trmq.set(x, dist[x] = dist[v] + w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tboolean bad(int v) {\n\t\tint y = v < N ? v : v - N;\n\t\treturn y < dist[v];\n\t}\n\n\tclass DijkstraGraph {\n\t\tint[] head;\n\t\tint[] next;\n\t\tint[] vert;\n\t\tint[] cost;\n\t\tint cnt = 1;\n\t\t\n\t\tDijkstraGraph(int vNum, int eNum) {\n\t\t\thead = new int [vNum];\n\t\t\tnext = new int [eNum + 1];\n\t\t\tvert = new int [eNum + 1];\n\t\t\tcost = new int [eNum + 1];\n\t\t}\n\t\t\n\t\tvoid add(int u, int v, int w) {\n\t\t\tnext[cnt] = head[u];\n\t\t\tvert[cnt] = v;\n\t\t\tcost[cnt] = w;\n\t\t\thead[u] = cnt++;\n\t\t}\n\t}\n\t\n\tclass RMQ {\n\t\tint[] val;\n\t\tint[] ind;\n\t\tint n;\n\t\t\n\t\tRMQ(int n) {\n\t\t\tthis.n = n;\n\t\t\tval = new int [2 * n];\n\t\t\tind = new int [2 * n];\n\t\t\tfill(val, INF);\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tind[i + n] = i;\n\t\t}\n\t\t\n\t\tvoid set(int i, int v) {\n\t\t\tval[i += n] = v;\n\t\t\tfor (i >>= 1; i > 0; i >>= 1) {\n\t\t\t\tint add = val[2 * i] < val[2 * i + 1] ? 0 : 1;\n\t\t\t\tval[i] = val[2 * i + add];\n\t\t\t\tind[i] = ind[2 * i + add];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint minInd(int l, int r) {\n\t\t\tl += n;\n\t\t\tr += n;\n\t\t\tint min = INF;\n\t\t\tint ret = -1;\n\t\t\twhile (l <= r) {\n\t\t\t\tif (l % 2 == 1 && min > val[l]) {\n\t\t\t\t\tmin = val[l];\n\t\t\t\t\tret = ind[l];\n\t\t\t\t}\n\t\t\t\tif (r % 2 == 0 && min > val[r]) {\n\t\t\t\t\tmin = val[r];\n\t\t\t\t\tret = ind[r];\n\t\t\t\t}\n\t\t\t\tl = (l + 1) / 2;\n\t\t\t\tr = (r - 1) / 2;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\t\n\t/*************************************************************** \n\t * Input \n\t **************************************************************/\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer st = new StringTokenizer(\"\");\n\t\n\tString nextToken() throws IOException {\n\t\twhile (!st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\t\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\t\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\t\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\t\n\tint[] nextIntArray(int size) throws IOException {\n\t\tint[] ret = new int [size];\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tret[i] = nextInt();\n\t\treturn ret;\n\t}\n\t\n\tlong[] nextLongArray(int size) throws IOException {\n\t\tlong[] ret = new long [size];\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tret[i] = nextLong();\n\t\treturn ret;\n\t}\n\t\n\tdouble[] nextDoubleArray(int size) throws IOException {\n\t\tdouble[] ret = new double [size];\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tret[i] = nextDouble();\n\t\treturn ret;\n\t}\n\t\n\tString nextLine() throws IOException {\n\t\tst = new StringTokenizer(\"\");\n\t\treturn in.readLine();\n\t}\n\t\n\tboolean EOF() throws IOException {\n\t\twhile (!st.hasMoreTokens()) {\n\t\t\tString s = in.readLine();\n\t\t\tif (s == null)\n\t\t\t\treturn true;\n\t\t\tst = new StringTokenizer(s);\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/*************************************************************** \n\t * Output \n\t **************************************************************/\n\tvoid printRepeat(String s, int count) {\n\t\tfor (int i = 0; i < count; i++)\n\t\t\tout.print(s);\n\t}\n\t\n\tvoid printArray(int[] array) {\n\t\tif (array == null || array.length == 0)\n\t\t\treturn;\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tif (i > 0) out.print(' ');\n\t\t\tout.print(array[i]);\n\t\t}\n\t\tout.println();\n\t}\n\t\n\tvoid printArray(long[] array) {\n\t\tif (array == null || array.length == 0)\n\t\t\treturn;\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tif (i > 0) out.print(' ');\n\t\t\tout.print(array[i]);\n\t\t}\n\t\tout.println();\n\t}\n\t\n\tvoid printArray(double[] array) {\n\t\tif (array == null || array.length == 0)\n\t\t\treturn;\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tif (i > 0) out.print(' ');\n\t\t\tout.print(array[i]);\n\t\t}\n\t\tout.println();\n\t}\n\t\n\tvoid printArray(double[] array, String spec) {\n\t\tif (array == null || array.length == 0)\n\t\t\treturn;\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tif (i > 0) out.print(' ');\n\t\t\tout.printf(Locale.US, spec, array[i]);\n\t\t}\n\t\tout.println();\n\t}\n\t\n\tvoid printArray(Object[] array) {\n\t\tif (array == null || array.length == 0)\n\t\t\treturn;\n\t\tboolean blank = false;\n\t\tfor (Object x : array) {\n\t\t\tif (blank) out.print(' '); else blank = true;\n\t\t\tout.print(x);\n\t\t}\n\t\tout.println();\n\t}\n\t\n\t@SuppressWarnings(\"rawtypes\")\n\tvoid printCollection(Collection collection) {\n\t\tif (collection == null || collection.isEmpty())\n\t\t\treturn;\n\t\tboolean blank = false;\n\t\tfor (Object x : collection) {\n\t\t\tif (blank) out.print(' '); else blank = true;\n\t\t\tout.print(x);\n\t\t}\n\t\tout.println();\n\t}\n\t\n\t/*************************************************************** \n\t * Utility\n\t **************************************************************/\n\tstatic String memoryStatus() {\n\t\treturn (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory() >> 20) + \"/\" + (Runtime.getRuntime().totalMemory() >> 20) + \" MB\";\n\t}\n\t\n\tstatic void checkMemory() {\n\t\tSystem.err.println(memoryStatus());\n\t}\n\t\n\tstatic long prevTimeStamp = Long.MIN_VALUE;\n\t\n\tstatic void updateTimer() {\n\t\tprevTimeStamp = System.currentTimeMillis();\n\t}\n\t\n\tstatic long elapsedTime() {\n\t\treturn (System.currentTimeMillis() - prevTimeStamp);\n\t}\n\t\n\tstatic void checkTimer() {\n\t\tSystem.err.println(elapsedTime() + \" ms\");\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar arr[2][100010];\nint vis[2][100010];\nint k, n, curj1, curj2;\nbool valid(int i, int j) {\n  if (i >= 0 && i < 2 && j >= 0 && j >= n) return true;\n  if (i >= 0 && i < 2 && j >= 0 && j < n && arr[i][j] != 'X' && vis[i][j] == 0)\n    return true;\n  return false;\n}\nvoid bfs(int i, int j) {\n  queue<pair<int, int> > q;\n  q.push(make_pair(i, j));\n  vis[i][j] = 1;\n  while (!q.empty()) {\n    int toi = q.front().first;\n    int toj = q.front().second;\n    q.pop();\n    if (toj >= n) {\n      cout << \"YES\" << endl;\n      return;\n    }\n    if (valid(toi + 1, toj + k)) {\n      q.push(make_pair(toi + 1, toj + k));\n      vis[toi + 1][toj + k] = vis[toi][toj] + 1;\n    }\n    if (valid(toi - 1, toj + k)) {\n      q.push(make_pair(toi - 1, toj + k));\n      vis[toi - 1][toj + k] = vis[toi][toj] + 1;\n    }\n    if (valid(toi, toj + 1)) {\n      q.push(make_pair(toi, toj + 1));\n      vis[toi][toj + 1] = vis[toi][toj] + 1;\n    }\n    if (valid(toi, toj - 1) && toj - 1 > vis[toi][toj] - 1) {\n      q.push(make_pair(toi, toj - 1));\n      vis[toi][toj - 1] = vis[toi][toj] + 1;\n    }\n  }\n  cout << \"NO\" << endl;\n}\nint main() {\n  int i, j;\n  cin >> n >> k;\n  for (i = 0; i < 2; i++) {\n    for (j = 0; j < n; j++) cin >> arr[i][j];\n  }\n  bfs(0, 0);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, x, y, z, k, sol, sum, MOD = 1000000007, m, a[3][700002];\nchar l[6000000], r[6000000];\nmap<pair<pair<int, int>, int>, int> ma;\nstring s1, s2, s;\nbool solve;\nvoid dfs(int s = 1) {\n  queue<pair<pair<int, int>, int>> q;\n  int w, p, d;\n  q.push({{1, 0}, -1});\n  while (!q.empty()) {\n    w = q.front().first.first, p = q.front().first.second, d = q.front().second;\n    q.pop();\n    if (a[w][p] == 1) continue;\n    a[w][p] = 1;\n    if (p >= n) {\n      solve = true;\n      break;\n    }\n    if (w == 1 && l[p + 1] == '-') q.push({{1, p + 1}, d + 1});\n    if (w == 1 && l[p - 1] == '-' && d + 1 < p - 1) q.push({{1, p - 1}, d + 1});\n    if (w == 1 && r[p + k] == '-') q.push({{2, p + k}, d + 1});\n    if (w == 2 && l[p + k] == '-') q.push({{1, p + k}, d + 1});\n    if (w == 2 && r[p + 1] == '-') q.push({{2, p + 1}, d + 1});\n    if (w == 2 && r[p - 1] == '-' && d + 1 < p - 1) q.push({{2, p - 1}, d + 1});\n  }\n}\nint main() {\n  cin >> n >> k;\n  scanf(\"%s\", l);\n  scanf(\"%s\", r);\n  for (int i = n; i <= k + n + 10; i++) l[i] = '-', r[i] = '-';\n  dfs();\n  if (solve == true)\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint w = 0, n, k;\nstring a, c;\nint v[100001][2];\nvoid dfs(int i, bool b) {\n  if (i > n) {\n    cout << \"YES\" << '\\n';\n    exit(0);\n  };\n  if (i < w) return;\n  if (b) {\n    if (c[i] == 'X') return;\n  } else {\n    if (a[i] == 'X') return;\n  }\n  if (v[i][b]) return;\n  v[i][b] = 1;\n  w++;\n  dfs(i - 1, b);\n  dfs(i + k, !b);\n  dfs(i + 1, b);\n  w--;\n}\nint main() {\n  cin >> n >> k >> a >> c;\n  dfs(0, 0);\n  {\n    cout << \"NO\" << '\\n';\n    exit(0);\n  };\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1e9 + 7;\nint n, k;\nstring a[2];\nbool b[2][500010];\nvoid dfs(int whi, int pla, int water) {\n  if (pla <= water) return;\n  if (b[whi % 2][pla]) return;\n  if (a[whi % 2][pla] == 'X') return;\n  b[whi % 2][pla] = 1;\n  if (pla + k > n) {\n    puts(\"YES\");\n    exit(0);\n  }\n  dfs(whi + 1, pla + k, water + 1);\n  dfs(whi, pla - 1, water + 1);\n  dfs(whi, pla + 1, water + 1);\n}\nint main() {\n  cin >> n >> k >> a[0] >> a[1];\n  dfs(0, 0, -1);\n  puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nenum actions { JUMP1, UP1, DOWN1, JUMP2, UP2, DOWN2, NONE };\nint n, x;\nvector<vector<int> > v(6);\nbool wut(int state, int i, actions last, int water) {\n  if (water - 1 >= i) return false;\n  if (state == 1) {\n    if (n < 50000) {\n      if (v[JUMP1][i] == 1) {\n        bool isTrue = wut(2, i + x, JUMP1, water + 1);\n        if (isTrue == false)\n          v[JUMP1][i] = 0;\n        else\n          return true;\n      } else if (v[JUMP1][i] == 2)\n        return true;\n    }\n    if (v[UP1][i] == 1 && last != DOWN1) {\n      bool isTrue = wut(state, i + 1, UP1, water + 1);\n      if (isTrue == false)\n        v[UP1][i] = 0;\n      else\n        return true;\n    } else if (v[UP1][i] == 2)\n      return true;\n    if (v[DOWN1][i] == 1 && last != UP1) {\n      bool isTrue = wut(state, i - 1, DOWN1, water + 1);\n      if (isTrue == false)\n        v[DOWN1][i] = 0;\n      else\n        return true;\n    }\n    if (n >= 50000) {\n      if (v[JUMP1][i] == 1) {\n        bool isTrue = wut(2, i + x, JUMP1, water + 1);\n        if (isTrue == false)\n          v[JUMP1][i] = 0;\n        else\n          return true;\n      } else if (v[JUMP1][i] == 2)\n        return true;\n    }\n  } else {\n    if (n < 50000) {\n      if (v[JUMP2][i] == 1) {\n        bool isTrue = wut(1, i + x, JUMP2, water + 1);\n        if (isTrue == false)\n          v[JUMP2][i] = 0;\n        else\n          return true;\n      } else if (v[JUMP2][i] == 2)\n        return true;\n    }\n    if (v[UP2][i] == 1 && last != DOWN2) {\n      bool isTrue = wut(state, i + 1, UP2, water + 1);\n      if (isTrue == false)\n        v[UP2][i] = 0;\n      else\n        return true;\n    } else if (v[UP2][i] == 2)\n      return true;\n    if (v[DOWN2][i] == 1 && last != UP2) {\n      bool isTrue = wut(state, i - 1, DOWN2, water + 1);\n      if (isTrue == false)\n        v[DOWN2][i] = 0;\n      else\n        return true;\n    }\n    if (n >= 50000) {\n      if (v[JUMP2][i] == 1) {\n        bool isTrue = wut(1, i + x, JUMP2, water + 1);\n        if (isTrue == false)\n          v[JUMP2][i] = 0;\n        else\n          return true;\n      } else if (v[JUMP2][i] == 2)\n        return true;\n    }\n  }\n  return false;\n}\nint main() {\n  cin >> n >> x;\n  string first;\n  string second;\n  cin >> first;\n  cin >> second;\n  for (int i = 0; i < 6; i++) v[i].assign(n, 0);\n  for (int i = 0; i < first.size(); i++) {\n    if (first[i] != 'X') {\n      if (i != first.size() - 1 && first[i + 1] != 'X') v[UP1][i] = 1;\n      if (i > 0 && first[i - 1] != 'X') v[DOWN1][i] = 1;\n      if (i + x < first.size() && second[i + x] != 'X') v[JUMP1][i] = 1;\n      if (i == first.size() - 1) v[UP1][i] = 2;\n      if (i + x >= first.size()) v[JUMP1][i] = 2;\n    }\n    if (second[i] != 'X') {\n      if (i != second.size() - 1 && second[i + 1] != 'X') v[UP2][i] = 1;\n      if (i > 0 && second[i - 1] != 'X') v[DOWN2][i] = 1;\n      if (i + x < second.size() && first[i + x] != 'X') v[JUMP2][i] = 1;\n      if (i == second.size() - 1) v[UP2][i] = 2;\n      if (i + x >= second.size()) v[JUMP2][i] = 2;\n    }\n  }\n  if (wut(1, 0, NONE, 0))\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedInputStream;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\npublic class C198B {\n\n\tpublic void solve() throws Exception {\n\t\tint n = nextInt();\n\t\tint k = nextInt();\n\t\tboolean[][] wall = new boolean[n][2];\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tString s = nextLine();\n\t\t\tfor (int j = 0; j < s.length(); j++) {\n\t\t\t\tif (s.charAt(j) == '-') {\n\t\t\t\t\twall[j][i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[] res = new int[2 * n];\n\t\tint inf = Integer.MAX_VALUE;\n\t\tArrays.fill(res, inf);\n\t\tres[0] = 0;\n\t\tint[] queue = new int[2 * n];\n\t\tint size = 1;\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tint akt = queue[i];\n\t\t\tint dir = akt / n;\n\t\t\tint pos = akt % n;\n\t\t\t// if there is X or water\n\t\t\tif (!wall[pos][dir] || res[akt] > pos) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (pos + k >= n) {\n\t\t\t\tprintln(\"YES\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (res[akt + 1] == inf) {\n\t\t\t\tres[akt + 1] = res[akt] + 1;\n\t\t\t\tqueue[size++] = akt + 1;\n\t\t\t}\n\t\t\tif (pos != 0 && res[akt - 1] == inf) {\n\t\t\t\tres[akt - 1] = res[akt] + 1;\n\t\t\t\tqueue[size++] = akt - 1;\n\t\t\t}\n\t\t\tint jump = pos + k + (1 - dir) * n;\n\t\t\tif (res[jump] == inf) {\n\t\t\t\tres[jump] = res[akt] + 1;\n\t\t\t\tqueue[size++] = jump;\n\t\t\t}\n\t\t}\n\t\tprintln(\"NO\");\n\t}\n\n\t// ------------------------------------------------------\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(Object... os) {\n\t\tif (os != null && os.length > 0)\n\t\t\tSystem.out.print(os[0].toString());\n\t\tfor (int i = 1; i < os.length; ++i)\n\t\t\tSystem.out.print(\" \" + os[i].toString());\n\t}\n\n\tvoid println(Object... os) {\n\t\tprint(os);\n\t\tSystem.out.println();\n\t}\n\n\tBufferedInputStream bis = new BufferedInputStream(System.in);\n\n\tString nextWord() throws Exception {\n\t\tchar c = (char) bis.read();\n\t\twhile (c <= ' ')\n\t\t\tc = (char) bis.read();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (c > ' ') {\n\t\t\tsb.append(c);\n\t\t\tc = (char) bis.read();\n\t\t}\n\t\treturn new String(sb);\n\t}\n\n\tString nextLine() throws Exception {\n\t\tchar c = (char) bis.read();\n\t\twhile (c <= ' ')\n\t\t\tc = (char) bis.read();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (c != '\\n' && c != '\\r') {\n\t\t\tsb.append(c);\n\t\t\tc = (char) bis.read();\n\t\t}\n\t\treturn new String(sb);\n\t}\n\n\tint nextInt() throws Exception {\n\t\treturn Integer.parseInt(nextWord());\n\t}\n\n\tlong nextLong() throws Exception {\n\t\treturn Long.parseLong(nextWord());\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew C198B().solve();\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, wall = 0;\nstring w[2];\nbool vis[2][100005];\nqueue<pair<pair<int, int>, int> > q;\nint main(int argc, const char* argv[]) {\n  memset(vis, 0, sizeof(vis));\n  cin >> n >> k >> w[0] >> w[1];\n  w[0] = \" \" + w[0];\n  w[1] = \" \" + w[1];\n  vis[0][0] = true;\n  vis[1][0] = true;\n  q.push(make_pair(make_pair(0, 1), 0));\n  while (!q.empty()) {\n    pair<pair<int, int>, int> cur = q.front();\n    q.pop();\n    if (cur.second >= cur.first.second) continue;\n    if (cur.first.second + k > n) {\n      cout << \"YES\";\n      return 0;\n    }\n    if (w[cur.first.first][cur.first.second + 1] != 'X' &&\n        !vis[cur.first.first][cur.first.second + 1]) {\n      vis[cur.first.first][cur.first.second + 1] = true;\n      q.push(make_pair(make_pair(cur.first.first, cur.first.second + 1),\n                       cur.second + 1));\n    }\n    if (w[cur.first.first][cur.first.second - 1] != 'X' &&\n        !vis[cur.first.first][cur.first.second - 1]) {\n      vis[cur.first.first][cur.first.second - 1] = true;\n      q.push(make_pair(make_pair(cur.first.first, cur.first.second - 1),\n                       cur.second + 1));\n    }\n    if (w[cur.first.first ^ 1][cur.first.second + k] != 'X' &&\n        !vis[cur.first.first ^ 1][cur.first.second + k]) {\n      vis[cur.first.first ^ 1][cur.first.second + k] = true;\n      q.push(make_pair(make_pair(cur.first.first ^ 1, cur.first.second + k),\n                       cur.second + 1));\n    }\n  }\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1e18;\nconst int inf = 2e9;\nconst int mod = 1e9 + 7;\nconst int N = 2e5 + 5;\nint n, k;\nset<pair<int, pair<int, int> > > s;\nint d[2][N];\nint dx[3] = {0, 0, 1};\nint dy[3] = {1, -1, k};\nchar a[2][N];\nvoid bfs() {\n  dy[2] = k;\n  for (int j = 1; j <= n + k; j++) {\n    d[0][j] = inf;\n    d[1][j] = inf;\n  }\n  d[0][1] = 0;\n  s.insert(make_pair(0, make_pair(0, 1)));\n  while (!s.empty()) {\n    pair<int, pair<int, int> > p = *s.begin();\n    s.erase(p);\n    pair<int, int> v = p.second;\n    for (int i = 0; i < 3; i++) {\n      int nx = (v.first + dx[i]) % 2, ny = v.second + dy[i];\n      if (ny < 1 || a[nx][ny] == 'X') continue;\n      if (ny > n) {\n        if (d[nx][ny] > d[v.first][v.second] + 1 &&\n            d[v.first][v.second] + 1 < ny) {\n          d[nx][ny] = d[v.first][v.second] + 1;\n        }\n      } else {\n        if (d[nx][ny] > d[v.first][v.second] + 1 &&\n            d[v.first][v.second] + 1 < ny) {\n          s.erase(make_pair(d[nx][ny], make_pair(nx, ny)));\n          d[nx][ny] = d[v.first][v.second] + 1;\n          s.insert(make_pair(d[nx][ny], make_pair(nx, ny)));\n        }\n      }\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  cin >> n >> k;\n  for (int i = 0; i < 2; i++) {\n    for (int j = 1; j <= n; j++) {\n      cin >> a[i][j];\n    }\n  }\n  bfs();\n  int ans = inf;\n  for (int i = n + 1; i <= n + k; i++) {\n    ans = min(ans, min(d[0][i], d[1][i]));\n  }\n  if (ans == inf)\n    cout << \"NO\";\n  else\n    cout << \"YES\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main {\n\n    public static boolean[][] vist;\n    public static int k;\n    public static boolean[][] safe;\n\n    public static void main(String[] args) throws IOException {\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n\n        int n = Integer.parseInt(st.nextToken());\n        k = Integer.parseInt(st.nextToken());\n\n        vist = new boolean[n][2];\n        safe = new boolean[n][2];\n\n        for(int i = 0; i < 2; i++) {\n\n            st = new StringTokenizer(br.readLine());\n            String l1 = st.nextToken();\n\n            for (int j = 0; j < n; j++) {\n                char next = l1.charAt(j);\n                if(next == '-')\n                {\n                    safe[j][i] = true;\n                }\n            }\n        }\n\n        boolean works = BFS(0, 0, 0, n);\n        if(works)\n        {\n            System.out.println(\"YES\");\n        }\n        else System.out.println(\"NO\");\n\n\n    }\n\n    public static boolean BFS(int ind, int lowHigh, int time, int n)\n    {\n        if(ind >= n)\n            return true;\n\n        if(ind < 0 || !safe[ind][lowHigh]) return false;\n\n        if(vist[ind][lowHigh]) return false;\n\n        if(ind < time) return false;\n\n        else\n        {\n            vist[ind][lowHigh] = true;\n            return BFS(ind+k, Math.abs(lowHigh-1), time+1, n) || BFS(ind-1, lowHigh, time+1, n)\n                    || BFS(ind+1, lowHigh, time+1, n);\n        }\n\n\n    }\n\n}\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint const MAX = 2000 * 100 + 10;\nint wall[MAX * 10];\nstring x[3];\nint d[MAX * 100];\nint q[MAX * 100];\nvector<int> adj[MAX];\nint n, k;\nint const inf = 1000 * 1000 * 1000 + 10;\nvoid fadj(int i) {\n  if (i - 1 >= 1 && wall[i - 1] == '-') adj[i].push_back(i - 1);\n  if (i + 1 == n + 1)\n    adj[i].push_back(2 * n + 1);\n  else if (wall[i + 1] == '-')\n    adj[i].push_back(i + 1);\n  if (i <= n && (i + n + k) > 2 * n) {\n    adj[i].push_back(i + n + k);\n    return;\n  }\n  if (wall[i + n + k] == '-') {\n    adj[i].push_back(i + n + k);\n    return;\n  }\n  if (i + k > 2 * n) {\n    adj[i].push_back(i + k);\n    return;\n  }\n  if (wall[i - n + k] == '-') {\n    adj[i].push_back(i - n + k);\n  }\n}\nint main() {\n  cin >> n >> k;\n  cin >> x[0] >> x[1];\n  for (int i = 1; i <= n; i++) {\n    wall[i] = x[0][i - 1];\n    wall[n + i] = x[1][i - 1];\n  }\n  for (int i = 1; i <= 2 * n; i++) {\n    fadj(i);\n  }\n  int s = 0;\n  int e = 1;\n  d[1] = 0;\n  q[0] = 1;\n  for (int i = 2; i <= 2 * n + k; i++) d[i] = inf;\n  while (e > s) {\n    int v = q[s++];\n    for (int i = 0; i < adj[v].size(); i++) {\n      if (adj[v][i] > 2 * n) {\n        cout << \"YES\";\n        return 0;\n      }\n      int t;\n      if (adj[v][i] % n == 0) {\n        t = n;\n      } else {\n        t = adj[v][i] % n;\n      }\n      if (d[adj[v][i]] > d[v] + 1 && t > d[v] + 1)\n        d[adj[v][i]] = d[v] + 1, q[e++] = adj[v][i];\n    }\n  }\n  cout << \"NO\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD(1000000007);\nconst int INF((1 << 30) - 1);\nconst int MAXN(100005);\nstring a[2];\nbool visited[2][MAXN];\nint path[2][MAXN];\npair<int, int> q[2 * MAXN];\nint main() {\n  int n, k;\n  scanf(\"%d%d\", &n, &k);\n  cin >> a[0] >> a[1];\n  int fr = 0, bk = 0;\n  q[bk++] = pair<int, int>(0, 0);\n  visited[0][0] = 1;\n  path[0][0] = 0;\n  while (fr != bk) {\n    int x = q[fr].first, y = q[fr++].second;\n    if (a[x][y + 1] != 'X' && !visited[x][y + 1] && path[x][y] + 1 <= y + 1) {\n      if (y + 1 >= n) {\n        printf(\"YES\");\n        return 0;\n      }\n      q[bk++] = pair<int, int>(x, y + 1);\n      visited[x][y + 1] = 1;\n      path[x][y + 1] = path[x][y] + 1;\n    }\n    if (y > 0 && a[x][y - 1] != 'X' && !visited[x][y - 1] &&\n        path[x][y] + 1 <= y - 1) {\n      q[bk++] = pair<int, int>(x, y - 1);\n      visited[x][y - 1] = 1;\n      path[x][y - 1] = path[x][y] + 1;\n    }\n    if (a[!x][y + k] != 'X' && !visited[!x][y + k] && path[x][y] + 1 <= y + k) {\n      if (y + k >= n) {\n        printf(\"YES\");\n        return 0;\n      }\n      q[bk++] = pair<int, int>(!x, y + k);\n      visited[!x][y + k] = 1;\n      path[!x][y + k] = path[x][y] + 1;\n    }\n  }\n  printf(\"NO\");\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class B{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n, k;\n\tint[][] a;\n\n\tvoid run(){\n\t\tn=sc.nextInt();\n\t\tk=sc.nextInt();\n\t\ta=new int[n+1][2];\n\t\tfor(int j=0; j<2; j++){\n\t\t\tString s=sc.next();\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\ta[i][j]=s.charAt(i)=='-'?0:1;\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n\n\tint[][] d;\n\n\tvoid solve(){\n\t\td=new int[n+1][2];\n\t\tfor(int i=0; i<=n; i++){\n\t\t\tfill(d[i], INF);\n\t\t}\n\t\tPriorityQueue<P> que=new PriorityQueue<P>();\n\t\tque.offer(new P(0, 0, 0));\n\t\td[0][0]=0;\n\t\tfor(; !que.isEmpty();){\n\t\t\tP p=que.poll();\n\t\t\tif(p.d>d[p.h][p.w]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tP q;\n\t\t\tif(p.h>0){\n\t\t\t\tq=new P(p.h-1, p.w, p.d+1);\n\t\t\t\tif(ok(q)){\n\t\t\t\t\tque.offer(q);\n\t\t\t\t\td[q.h][q.w]=q.d;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq=new P(p.h+1, p.w, p.d+1);\n\t\t\tq.h=min(q.h, n);\n\t\t\tif(ok(q)){\n\t\t\t\tque.offer(q);\n\t\t\t\td[q.h][q.w]=q.d;\n\t\t\t}\n\t\t\tq=new P(p.h+k, 1-p.w, p.d+1);\n\t\t\tq.h=min(q.h, n);\n\t\t\tif(ok(q)){\n\t\t\t\tque.offer(q);\n\t\t\t\td[q.h][q.w]=q.d;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<=n; i++){\n\t\t\t// debug(d[i]);\n\t\t}\n\t\tif(d[n][0]==INF&&d[n][1]==INF){\n\t\t\tprintln(\"NO\");\n\t\t}else{\n\t\t\tprintln(\"YES\");\n\t\t}\n\t}\n\n\tboolean ok(P p){\n\t\tif(a[p.h][p.w]==0&&p.d<d[p.h][p.w]&&p.d<=p.h){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tclass P implements Comparable<P>{\n\t\tint h, w, d;\n\n\t\tP(int h, int w, int d){\n\t\t\tthis.h=h;\n\t\t\tthis.w=w;\n\t\t\tthis.d=d;\n\t\t}\n\n\t\tpublic int compareTo(P p){\n\t\t\treturn d-p.d;\n\t\t}\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args){\n\t\tLocale.setDefault(Locale.US);\n\t\tnew B().run();\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid mymax(T &_a, T _b) {\n  if (_a < _b) _a = _b;\n}\ntemplate <typename T>\nvoid mymin(T &_a, T _b) {\n  if (_a > _b) _a = _b;\n}\nvoid print(int _x) { printf(\"%d \", _x); }\nvoid print(long long _x) { printf(\"%I64d \", _x); }\nstruct Event {\n  bool side;\n  int h;\n  int time;\n  Event() {}\n  Event(bool ss, int hh, int tt) {\n    side = ss;\n    h = hh;\n    time = tt;\n  }\n};\nbool operator<(Event e1, Event e2) { return e1.h < e2.h; }\nint n, k;\nbool cango[2][100005 * 2];\nint wenttime[2][100005 * 2];\nqueue<Event> q;\nint deal_event() {\n  q.push(Event(0, 1, 0));\n  while (!q.empty()) {\n    Event now = q.front();\n    q.pop();\n    if (now.h > n - k) return now.time + 1;\n    if (cango[now.side][now.h - 1] && now.h - 1 > now.time + 1 &&\n        !wenttime[now.side][now.h - 1]) {\n      wenttime[now.side][now.h - 1] = now.time + 1;\n      q.push(Event(now.side, now.h - 1, now.time + 1));\n    }\n    if (cango[now.side][now.h + 1] && !wenttime[now.side][now.h + 1]) {\n      if (now.h + 1 > n - k) return now.time + 1;\n      wenttime[now.side][now.h + 1] = now.time + 1;\n      q.push(Event(now.side, now.h + 1, now.time + 1));\n    }\n    if (cango[now.side ^ 1][now.h + k] && !wenttime[now.side ^ 1][now.h + k]) {\n      wenttime[now.side ^ 1][now.h + k] = now.time + 1;\n      if (now.h + k > n - k) return now.time + 1;\n      q.push(Event(now.side ^ 1, now.h + k, now.time + 1));\n    }\n  }\n  return 0;\n}\nint main() {\n  scanf(\"%d %d\", &n, &k);\n  getchar();\n  for (int i = 1; i <= n * 2; i++) {\n    cango[0][i] = cango[1][i] = 1;\n    wenttime[0][i] = wenttime[1][i] = 0;\n  }\n  for (int j = 0; j <= 1; j++) {\n    for (int i = 1; i <= n; i++) {\n      char c;\n      c = getchar();\n      if (c == '-')\n        cango[j][i] = 1;\n      else\n        cango[j][i] = 0;\n    }\n    getchar();\n  }\n  int ans = deal_event();\n  if (ans)\n    printf(\"YES\\n\");\n  else\n    printf(\"NO\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 20050226;\nchar wall[2][200005];\nint co[2][200005];\nint n, m;\nint ans = INF;\nvoid go() {\n  queue<pair<pair<int, int>, int> > q;\n  q.push(make_pair(make_pair(0, 0), -1));\n  co[0][0] = 0;\n  while (!q.empty()) {\n    int h = q.front().first.first;\n    int p = q.front().first.second;\n    int sc = q.front().second;\n    q.pop();\n    if (h >= n) {\n      ans = min(ans, sc);\n      break;\n    }\n    if (h - 1 > sc + 1 and wall[p][h - 1] != 'X') {\n      if (co[p][h - 1] > co[p][h] + 1) {\n        co[p][h - 1] = co[p][h] + 1;\n        q.push(make_pair(make_pair(h - 1, p), sc + 1));\n      }\n    }\n    if (wall[p][h + 1] != 'X') {\n      if (co[p][h + 1] > co[p][h] + 1) {\n        co[p][h + 1] = co[p][h] + 1;\n        q.push(make_pair(make_pair(h + 1, p), sc + 1));\n      }\n    }\n    if (p == 0) {\n      if (wall[1][h + m] != 'X') {\n        if (co[1][h + m] > co[0][h] + 1) {\n          co[1][h + m] = co[0][h] + 1;\n          q.push(make_pair(make_pair(h + m, 1), sc + 1));\n        }\n      }\n    }\n    if (p == 1) {\n      if (wall[0][h + m] != 'X') {\n        if (co[0][h + m] > co[1][h] + 1) {\n          co[0][h + m] = co[1][h] + 1;\n          q.push(make_pair(make_pair(h + m, 0), sc + 1));\n        }\n      }\n    }\n  }\n}\nint main() {\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    cin >> wall[0][i];\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> wall[1][i];\n  }\n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < 200005; j++) {\n      co[i][j] = INF;\n    }\n  }\n  go();\n  if (ans == INF) {\n    cout << \"NO\";\n    return 0;\n  }\n  cout << \"YES\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 100;\nbool wall[2][maxn];\nint step[2][maxn];\nint n, k;\nbool dfs(int side, int h, int t) {\n  step[side][h] = t;\n  if (h < t) return false;\n  if (h >= n) return true;\n  bool ans = 0;\n  if (!wall[side ^ 1][h + k] &&\n      (step[side ^ 1][h + k] > t + 1 || step[side ^ 1][h + k] == -1)) {\n    ans |= dfs(side ^ 1, h + k, t + 1);\n  }\n  if (!wall[side][h + 1] &&\n      (step[side][h + 1] > t + 1 || step[side][h + 1] == -1)) {\n    ans |= dfs(side, h + 1, t + 1);\n  }\n  if (h - 1 >= 0 && !wall[side][h - 1] &&\n      (step[side][h - 1] > t + 1 || step[side][h - 1] == -1)) {\n    ans |= dfs(side, h - 1, t + 1);\n  }\n  return ans;\n}\nint main() {\n  memset(wall, 0, sizeof(wall));\n  memset(step, -1, sizeof(step));\n  scanf(\"%d%d\", &n, &k);\n  char s[maxn];\n  scanf(\"%s\", s);\n  for (int i = 0; i < n; i++) {\n    if (s[i] == 'X') wall[0][i] = 1;\n  }\n  scanf(\"%s\", s);\n  for (int i = 0; i < n; i++) {\n    if (s[i] == 'X') wall[1][i] = 1;\n  }\n  bool ans = dfs(0, 0, 0);\n  if (ans) {\n    printf(\"YES\\n\");\n  } else\n    printf(\"NO\\n\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = (int)1e9;\nconst int mod = (int)1e9 + 7;\nconst double pi = acos(-1.0);\nconst double eps = 1e-9;\nint n, k;\nstring second[2];\nint d[2][1000005];\nbool used[2][1000005];\nqueue<pair<int, int> > q;\nint main() {\n  scanf(\"%d%d\\n\", &n, &k);\n  getline(cin, second[0]);\n  getline(cin, second[1]);\n  d[0][0] = 0;\n  used[0][0] = 1;\n  q.push(make_pair(0, 0));\n  while (!q.empty()) {\n    pair<int, int> p = q.front();\n    q.pop();\n    int x = p.first, y = p.second;\n    int dist = d[x][y];\n    if (dist > y) continue;\n    if (y + k >= n) {\n      printf(\"YES\\n\");\n      return 0;\n    }\n    if (second[x][y + 1] != 'X' && !used[x][y + 1]) {\n      used[x][y + 1] = 1;\n      d[x][y + 1] = dist + 1;\n      q.push(make_pair(x, y + 1));\n    }\n    if (y && second[x][y - 1] != 'X' && !used[x][y - 1]) {\n      used[x][y - 1] = 1;\n      d[x][y - 1] = dist + 1;\n      q.push(make_pair(x, y - 1));\n    }\n    if (second[1 - x][y + k] != 'X' && !used[1 - x][y + k]) {\n      used[1 - x][y + k] = 1;\n      d[1 - x][y + k] = dist + 1;\n      q.push(make_pair(1 - x, y + k));\n    }\n  }\n  printf(\"NO\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nbool vs[2][100005];\nchar str[2][100005];\nstruct st {\n  int side;\n  int loca;\n  int time;\n  st(int _side, int _loca, int _time) {\n    side = _side;\n    loca = _loca;\n    time = _time;\n  }\n};\nint main() {\n  scanf(\"%d %d\", &n, &k);\n  for (int i = 0; i < 2; i++) scanf(\"%s\", str[i]);\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < k; j++) vs[i][j] = false;\n  queue<st> q;\n  q.push(st(0, 0, 0));\n  vs[0][0] = true;\n  while (!q.empty()) {\n    st p = q.front();\n    q.pop();\n    if (p.loca + k >= n) {\n      printf(\"YES\\n\");\n      return 0;\n    }\n    if (str[p.side][p.loca + 1] == '-' && !vs[p.side][p.loca + 1]) {\n      vs[p.side][p.loca + 1] = true;\n      q.push(st(p.side, p.loca + 1, p.time + 1));\n    }\n    if (str[p.side][p.loca - 1] == '-' && !vs[p.side][p.loca - 1] &&\n        p.time + 1 <= p.loca - 1) {\n      vs[p.side][p.loca - 1] = true;\n      q.push(st(p.side, p.loca - 1, p.time + 1));\n    }\n    if (str[(p.side + 1) % 2][p.loca + k] == '-' &&\n        !vs[(p.side + 1) % 2][p.loca + k]) {\n      vs[(p.side + 1) % 2][p.loca + k] = true;\n      q.push(st((p.side + 1) % 2, p.loca + k, p.time + 1));\n    }\n  }\n  printf(\"NO\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200012, M = 1200012;\nint n, k, edgetot, h, t;\nint point[2 * N], d[2 * N], Q[10 * N];\nchar ch;\nbool a1[N], a2[N], can[2 * N];\nstruct edge {\n  int v, w, next;\n} e[M];\ninline void add_edge(int x, int y, int w) {\n  ++edgetot;\n  e[edgetot].v = y;\n  e[edgetot].w = w;\n  e[edgetot].next = point[x];\n  point[x] = edgetot;\n}\ninline int calc(int now) {\n  if (now <= n + k) return now;\n  return now - n - k;\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  scanf(\"\\n\");\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%c\", &ch);\n    if (ch == '-') a1[i] = true;\n  }\n  for (int i = n + 1; i <= n + k; ++i) a1[i] = true;\n  scanf(\"\\n\");\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%c\", &ch);\n    if (ch == '-') a2[i] = true;\n  }\n  for (int i = n + 1; i <= n + k; ++i) a2[i] = true;\n  for (int i = 1; i <= n; ++i)\n    if (a1[i]) {\n      if (a1[i - 1]) add_edge(i, i - 1, 1);\n      if (a1[i + 1]) add_edge(i, i + 1, 1);\n      if (a2[i + k]) add_edge(i, i + k + n + k, 1);\n    }\n  for (int i = 1; i <= n; ++i)\n    if (a2[i]) {\n      if (a2[i - 1]) add_edge(i + n + k, i + n + k - 1, 1);\n      if (a2[i + 1]) add_edge(i + n + k, i + n + k + 1, 1);\n      if (a1[i + k]) add_edge(i + n + k, i + k, 1);\n    }\n  memset(d, 127, sizeof(d));\n  d[1] = 0;\n  can[1] = true;\n  for (Q[h = t = 1] = 1; h <= t; ++h) {\n    int now = Q[h];\n    for (int j = point[now]; j; j = e[j].next)\n      if (d[e[j].v] > d[now] + e[j].w) {\n        if (calc(e[j].v) <= d[now] + e[j].w) continue;\n        d[e[j].v] = d[now] + e[j].w;\n        if (e[j].v <= n + k && e[j].v > n) {\n          puts(\"YES\");\n          return 0;\n        }\n        if (e[j].v > n + n + k) {\n          puts(\"YES\");\n          return 0;\n        }\n        if (!can[e[j].v]) can[e[j].v] = true, Q[++t] = e[j].v;\n      }\n    can[now] = false;\n  }\n  puts(\"NO\");\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class  test{\n\t\n\t//ArrayList<Integer> lis = new ArrayList<Integer>();\n\t//ArrayList<String> lis = new ArrayList<String>();\n\t//\n//\tstatic long sum=0;\n\t//int a,b,c;\n\t//1000000007 (10^9+7)\n\t//static int mod = 1000000007;\n   // static int d[][];\n\t//static int dx[]={1,-1,0,0};\n\t//static int dy[]={0,0,1,-1};\n\t\n\t\npublic  static void main(String[] args) {\n\t\n   Scanner sc =new Scanner(System.in);\n   while(sc.hasNext()){\n\t\t // =ni(sc)\n\t   //long sum=0;\n\t\tint  n=sc.nextInt(),  k=sc.nextInt();\n\t\tchar   s[][]=new char[2][n];\n\t s[0]=sc.next().toCharArray();\n\t s[1]=sc.next().toCharArray();\n\t \n\t  boolean vis[][]=new boolean[2][n];\n\t  \n\t  LinkedList<pair> que=new  LinkedList<pair>(); \n\t  que.add(new pair(0,0,-1));\t\n\t  vis[0][0]=true;\n\t  while(!que.isEmpty()){\n\t\t  \n\t\t  pair p=que.poll();\n\t\n\t\t\n\t\t  int x=p.v+1,y=p.vv;\n\t\t  \n\t\t if(x<n && !vis[y][x] &&s[y][x]!='X'){\t vis[y][x]=true;que.add(new pair(x,y,p.t+1) );}\n\t\t x=p.v-1; \n\t\t if(0<x && !vis[y][x] && s[y][x]!='X' && p.t+1<x){vis[y][x]=true;que.add(new pair(x,y,p.t+1) );}\n\t\t x=p.v+k;\n\t\t if(n<=x){System.out.println(\"YES\"); return;}\n\t\t y=(y+1)%2;\n\t\t if(s[y][x]!='X' && !vis[y][x]  ){vis[y][x]=true; que.add(new pair(x,y,p.t+1) );}\n\t\t \n\t  }\n\t\t\n\t  System.out.println(\"NO\");\n\t  \n   }\n\n}\n\nstatic void db(Object... os){\n    System.err.println(Arrays.deepToString(os));\n\n}\n\n\n\n}\n\n\n\n\nclass pair {\n    int v,vv,t;\n\tpair(int v,int vv,int t){\n\t\tthis.v=v;\n\t    this.vv=vv;\n\t    this.t=t;\n\t} \n\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct state {\n  int water_height;\n  int ninja_height;\n  bool on_left_wall;\n  int64_t state_val() const {\n    return ((int64_t)(on_left_wall && 0x1)) << 63 | (int64_t)ninja_height;\n  }\n};\nvoid bfs(int n, int k) {\n  string left_wall;\n  string right_wall;\n  getline(cin, left_wall);\n  getline(cin, right_wall);\n  queue<state> q;\n  unordered_set<int64_t> s;\n  state initial;\n  initial.water_height = 0;\n  initial.ninja_height = 0;\n  initial.on_left_wall = true;\n  q.push(initial);\n  bool done = false;\n  while (!q.empty() && !done) {\n    state curr = q.front();\n    q.pop();\n    if (curr.ninja_height >= n - 1) {\n      done = true;\n    } else {\n      string* current_wall;\n      string* opposite_wall;\n      if (curr.on_left_wall) {\n        current_wall = &left_wall;\n        opposite_wall = &right_wall;\n      } else {\n        current_wall = &right_wall;\n        opposite_wall = &left_wall;\n      }\n      if ((*current_wall)[curr.ninja_height + 1] != 'X') {\n        state up;\n        up.water_height = curr.water_height + 1;\n        up.ninja_height = curr.ninja_height + 1;\n        up.on_left_wall = curr.on_left_wall;\n        if (s.find(up.state_val()) == s.end()) {\n          q.push(up);\n          s.insert(up.state_val());\n        }\n      }\n      if ((*current_wall)[curr.ninja_height - 1] != 'X' &&\n          curr.water_height < curr.ninja_height - 1) {\n        state down;\n        down.water_height = curr.water_height + 1;\n        down.ninja_height = curr.ninja_height - 1;\n        down.on_left_wall = curr.on_left_wall;\n        if (s.find(down.state_val()) == s.end()) {\n          q.push(down);\n          s.insert(down.state_val());\n        }\n      }\n      if (curr.ninja_height + k > n - 1 ||\n          (*opposite_wall)[curr.ninja_height + k] != 'X') {\n        state jump;\n        jump.water_height = curr.water_height + 1;\n        jump.ninja_height = curr.ninja_height + k;\n        jump.on_left_wall = !curr.on_left_wall;\n        if (s.find(jump.state_val()) == s.end()) {\n          q.push(jump);\n          s.insert(jump.state_val());\n        }\n      }\n    }\n  }\n  if (done) {\n    cout << \"YES\";\n  } else {\n    cout << \"NO\";\n  }\n  cout << endl;\n}\nint main() {\n  int n, k;\n  cin >> n;\n  cin >> k;\n  cin.get();\n  bfs(n, k);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class D implements Runnable {\n\n\tint k, n;\n\tchar[][] c;\n\tboolean[][] used;\n\n\tprivate void Solution() throws IOException {\n\t\tn = nextInt();\n\t\tk = nextInt();\n\t\tc = new char[2][n];\n\t\tfor (int i = 0; i < 2; i++)\n\t\t\tc[i] = next().toCharArray();\n\t\tused = new boolean[2][n];\n\t\tdfs(0, 0, 0);\n\t\tprint(\"NO\");\n\t}\n\n\tvoid dfs(int w, int i, int d) {\n\t\tused[w][i] = true;\n\t\tif (i >= n - k) {\n\t\t\tprint(\"YES\");\n\t\t\tout.close();\n\t\t\tSystem.exit(0);\n\t\t}\n\t\tif (ok(1 - w, i + k, d + 1))\n\t\t\tdfs(1 - w, i + k, d + 1);\n\t\tif (ok(w, i + 1, d + 1))\n\t\t\tdfs(w, i + 1, d + 1);\n\t\tif (ok(w, i - 1, d + 1))\n\t\t\tdfs(w, i - 1, d + 1);\n\t}\n\n\tboolean ok(int w, int i, int d) {\n\t\treturn i >= 0 && !used[w][i] && c[w][i] != 'X' && i >= d;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew D().run();\n\t}\n\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer tokenizer;\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tSolution();\n\t\t\tout.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(0);\n\t\t}\n\t}\n\n\tvoid print(Object... obj) {\n\t\tfor (int i = 0; i < obj.length; i++) {\n\t\t\tif (i != 0)\n\t\t\t\tout.print(\" \");\n\t\t\tout.print(obj[i]);\n\t\t}\n\t}\n\n\tvoid println(Object... obj) {\n\t\tprint(obj);\n\t\tprint(\"\\n\");\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tlong nextLong() throws NumberFormatException, IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tdouble nextDouble() throws NumberFormatException, IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tString nextLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tString next() throws IOException {\n\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens())\n\t\t\ttokenizer = new StringTokenizer(nextLine());\n\t\treturn tokenizer.nextToken();\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 100000 + 10;\nbool mark[3][MAX];\nint n, k;\nchar a[3][MAX];\nvoid BFS() {\n  queue<pair<pair<int, int>, int> > q;\n  q.push({{1, 1}, 0});\n  mark[1][1] = true;\n  while (!q.empty()) {\n    pair<pair<int, int>, int> cur = q.front();\n    q.pop();\n    int x = cur.first.first;\n    int y = cur.first.second;\n    int w = cur.second;\n    int back = x;\n    if (x == 2) {\n      x = 0;\n    }\n    if (x + 1 > n || y + k > n) {\n      cout << \"YES\\n\";\n      exit(0);\n    }\n    if (a[x + 1][y + k] != 'X' && mark[x + 1][y + k] == false) {\n      mark[x + 1][y + k] = true;\n      q.push({{x + 1, y + k}, w + 1});\n    }\n    x = back;\n    if (a[x][y - 1] != 'X' && y - 1 > w + 1 && mark[x][y - 1] == false) {\n      mark[x][y - 1] = true;\n      q.push({{x, y - 1}, w + 1});\n    }\n    if (y + 1 > n) {\n      cout << \"YES\\n\";\n      exit(0);\n    }\n    if (a[x][y + 1] != 'X' && mark[x][y + 1] == false) {\n      mark[x][y + 1] = true;\n      q.push({{x, y + 1}, w + 1});\n    }\n  }\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 1; i <= 2; i++) {\n    string cur;\n    cin >> cur;\n    for (int j = 0; j < cur.size(); j++) {\n      a[i][j + 1] = cur[j];\n    }\n  }\n  BFS();\n  cout << \"NO\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar wall[3][100005];\nint N, K, visited[3][100005], d[3][100005];\nint moveX[3][3], moveY[3][3], flag = 0;\nvoid bfs() {\n  queue<pair<int, int>> Q;\n  Q.push(make_pair(1, 1));\n  visited[1][1] = 1;\n  d[1][1] = 0;\n  while (!Q.empty()) {\n    pair<int, int> p = Q.front();\n    Q.pop();\n    int x = p.first, y = p.second;\n    for (int i = 0; i < 3; i++) {\n      int xn = x + moveX[x][i];\n      int yn = y + moveY[x][i];\n      if (!visited[xn][yn]) {\n        if (yn > N)\n          flag = 1;\n        else {\n          if (d[x][y] + 1 < yn && wall[xn][yn] == '-') {\n            Q.push(make_pair(xn, yn));\n            visited[xn][yn] = 1;\n            d[xn][yn] = d[x][y] + 1;\n          }\n        }\n      }\n    }\n  }\n}\nint main() {\n  cin >> N >> K;\n  for (int i = 1; i <= N; i++) cin >> wall[1][i];\n  for (int i = 1; i <= N; i++) cin >> wall[2][i];\n  moveX[1][0] = 1;\n  moveX[1][1] = 0;\n  moveX[1][2] = 0;\n  moveY[1][0] = K;\n  moveY[1][1] = 1;\n  moveY[1][2] = -1;\n  moveX[2][0] = -1;\n  moveX[2][1] = 0;\n  moveX[2][2] = 0;\n  moveY[2][0] = K;\n  moveY[2][1] = 1;\n  moveY[2][2] = -1;\n  memset(d, 100000000, sizeof(d));\n  bfs();\n  if (flag == 1)\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int nax = 1e6 + 5;\nchar a[2][nax];\nbool visited[2][nax];\nbool path(int x, int y, int water_lvl) {\n  return (y > (water_lvl) && a[x][y] != 'X');\n}\nint main() {\n  int n, k;\n  cin >> n >> k;\n  for (int i = 0; i < 2; i++) {\n    for (int j = 1; j <= n; j++) {\n      cin >> a[i][j];\n    }\n  }\n  queue<pair<int, pair<int, int>>> q;\n  q.push(make_pair(0, make_pair(0, 1)));\n  visited[0][1] = true;\n  while (!q.empty()) {\n    int cur_wall = q.front().second.first;\n    int cur_h = q.front().second.second;\n    int cur_w = q.front().first;\n    if (cur_h >= n) {\n      cout << \"YES\" << endl;\n      return 0;\n    }\n    q.pop();\n    if (cur_wall == 0) {\n      if (path(cur_wall, cur_h + 1, cur_w + 1) &&\n          !visited[cur_wall][cur_h + 1]) {\n        q.push({cur_w + 1, {cur_wall, cur_h + 1}});\n        visited[cur_wall][cur_h + 1] = true;\n      }\n      if (path(cur_wall, cur_h - 1, cur_w + 1) &&\n          !visited[cur_wall][cur_h - 1]) {\n        q.push({cur_w + 1, {cur_wall, cur_h - 1}});\n        visited[cur_wall][cur_h - 1] = true;\n      }\n      if (path(1, cur_h + k, cur_w + 1) && !visited[1][cur_h + k]) {\n        q.push({cur_w + 1, {1, cur_h + k}});\n        visited[1][cur_h + k] = true;\n      }\n    }\n    if (cur_wall == 1) {\n      if (path(cur_wall, cur_h + 1, cur_w + 1) &&\n          !visited[cur_wall][cur_h + 1]) {\n        q.push({cur_w + 1, {cur_wall, cur_h + 1}});\n        visited[cur_wall][cur_h + 1] = true;\n      }\n      if (path(cur_wall, cur_h - 1, cur_w + 1) &&\n          !visited[cur_wall][cur_h - 1]) {\n        q.push({cur_w + 1, {cur_wall, cur_h - 1}});\n        visited[cur_wall][cur_h - 1] = true;\n      }\n      if (path(0, cur_h + k, cur_w + 1) && !visited[0][cur_h + k]) {\n        q.push({cur_w + 1, {0, cur_h + k}});\n        visited[0][cur_h + k] = true;\n      }\n    }\n  }\n  cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 1e6;\nchar a[MAX], b[MAX];\nint v[2][MAX];\nint n, m;\nint dfs(int tag, int k, int h) {\n  if (k <= h || k <= 0) return 0;\n  if (k > n) return 1;\n  if (tag == 0 && a[k] == 'X') return 0;\n  if (tag == 1 && b[k] == 'X') return 0;\n  if (v[tag][k]) return 0;\n  v[tag][k] = 1;\n  if (dfs(tag ^ 1, k + m, h + 1)) return 1;\n  if (dfs(tag, k + 1, h + 1)) return 1;\n  if (dfs(tag, k - 1, h + 1)) return 1;\n  return 0;\n}\nint main() {\n  cin >> n >> m;\n  scanf(\"%s%s\", a + 1, b + 1);\n  memset(v, 0, sizeof v);\n  puts(dfs(0, 1, 0) ? \"YES\" : \"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "/*\nID: nikchee1\nPROB: Jumping on Walls\nLANG: JAVA\n*/\nimport java.io.*;\nimport java.util.*;\n\npublic class Main\n{\n    static Scanner in = new Scanner(System.in);\n    static int N = in.nextInt(); \n    static int K = in.nextInt();\n    static int[][] dp = new int[2][N];\n    \n    public static void main (String [] args) { \n        in.nextLine();\n        char[] left = in.nextLine().toCharArray();\n        char[] right = in.nextLine().toCharArray();\n        \n        Queue<Node> bfs = new LinkedList<Node>();\n        bfs.add(new Node(0, 0));\n        \n        while(bfs.size() > 0){\n            Node cn = bfs.poll();\n            \n            if(cn.h + 1 >= N || cn.h + K >= N){\n                System.out.println(\"YES\");\n                System.exit(0);\n            }\n            if(cn.w == 0) {\n                int dist = dp[0][cn.h]+1;\n                if(left[cn.h+1] == '-' && dp[0][cn.h+1]==0) {\n                    bfs.add(new Node(cn.h+1, 0)); \n                    dp[0][cn.h+1] = dist;\n                }\n                if(cn.h-1>dp[0][cn.h] && left[cn.h-1] == '-' && dp[0][cn.h-1]==0) {\n                    bfs.add(new Node(cn.h-1, 0)); \n                    dp[0][cn.h-1] = dist;\n                }\n                if(right[cn.h + K] == '-'&& dp[1][cn.h + K]==0) {\n                    bfs.add( new Node(cn.h + K, 1)); \n                    dp[1][cn.h + K] = dist;\n                }\n            }\n            if(cn.w==1) {\n                int dist = dp[1][cn.h]+1;\n                if(right[cn.h+1] == '-' && dp[1][cn.h+1]==0) {\n                    bfs.add(new Node(cn.h+1, 1)); \n                    dp[1][cn.h+1] = dist;\n                }\n                if(cn.h-1>dp[1][cn.h] && right[cn.h-1] == '-' && dp[1][cn.h-1]==0) {\n                    bfs.add(new Node(cn.h-1, 1));\n                    dp[1][cn.h-1] = dist;\n                }\n                if(left[cn.h + K] == '-' && dp[0][cn.h + K]==0) {\n                    bfs.add(new Node(cn.h + K, 0)); \n                    dp[0][cn.h + K] = dist;\n                }\n            }\n        }\n        System.out.println(\"NO\");\n        System.exit(0);\n    }\n    static class Node{\n      public int h;\n      public int w;\n      public Node(int height, int wall){\n        h = height;\n        w = wall;\n      }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\npublic class CF0198B_JumpingOnWalls {\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic Scanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t}\n\n\tstatic void print(Object b) {\n\t\tSystem.out.print(b);\n\t}\n\n\tstatic void println(Object b) {\n\t\tSystem.out.println(b);\n\t}\n\n\tstatic void println() {\n\t\tSystem.out.println();\n\t}\n\n\tstatic class Node {\n\t\tint id;\n\t\tArrayList<Integer> connections;\n\t\tint visited;\n\n\t\tpublic Node(int i) {\n\t\t\tid = i;\n\t\t\tconnections = new ArrayList<Integer>();\n\t\t\tvisited = -1;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner scanner = new Scanner();\n\t\tint n = scanner.nextInt();\n\t\tint k = scanner.nextInt();\n\t\tNode[] nodes = new Node[n * 2];\n\t\tString s1 = scanner.next();\n\t\tString s2 = scanner.next();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i] = new Node(i);\n\t\t\tnodes[i + n] = new Node(i + n);\n\t\t}\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (s1.charAt(i) == '-' && s1.charAt(i - 1) == '-') {\n\t\t\t\tnodes[i].connections.add(i - 1);\n\t\t\t\tnodes[i - 1].connections.add(i);\n\t\t\t}\n\t\t\tif (s2.charAt(i) == '-' && s2.charAt(i - 1) == '-') {\n\t\t\t\tnodes[i + n].connections.add(i - 1 + n);\n\t\t\t\tnodes[i - 1 + n].connections.add(i + n);\n\t\t\t}\n\t\t\tif (i >= k && s1.charAt(i) == '-' && s2.charAt(i - k) == '-') {\n\t\t\t\tnodes[i].connections.add(i + n - k);\n\t\t\t\tnodes[i + n - k].connections.add(i);\n\t\t\t}\n\t\t\tif (i >= k && s2.charAt(i) == '-' && s1.charAt(i - k) == '-') {\n\t\t\t\tnodes[i + n].connections.add(i - k);\n\t\t\t\tnodes[i - k].connections.add(i + n);\n\t\t\t}\n\n\t\t}\n\t\tQueue<Node> q = new LinkedList<>();\n\t\tnodes[0].visited = 0;\n\t\tboolean flag = true;\n\t\tq.add(nodes[0]);\n\t\twhile(!q.isEmpty()) {\n\t\t\tNode node = q.poll();\n\t\t\tif(node.id % n <node.visited) \n\t\t\t\tcontinue;\n\t\t\tif(node.id%n + k >= n) {\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < node.connections.size(); i++) {\n\t\t\t\tint temp = node.connections.get(i);\n\t\t\t\tif(nodes[temp].visited == -1 && temp%n >=node.visited+1) {\n\t\t\t\t\tnodes[temp].visited = node.visited+1;\n\t\t\t\t\tq.add(nodes[temp]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag)\n\t\t\tSystem.out.println(\"NO\");\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1e9 + 7;\nint main() {\n  string a[2];\n  int n, k;\n  cin >> n >> k >> a[0] >> a[1];\n  int d[2][100010];\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 100010; j++) d[i][j] = 1e9;\n  queue<int> whi, high;\n  whi.push(0);\n  high.push(0);\n  d[0][0] = 0;\n  while (!whi.empty()) {\n    int x = whi.front(), y = high.front();\n    whi.pop();\n    high.pop();\n    if (d[x][y] > y) continue;\n    if (y + k >= n) {\n      puts(\"YES\");\n      return 0;\n    }\n    if ((a[x][y + 1] == '-') && (d[x][y + 1] == 1e9)) {\n      d[x][y + 1] = d[x][y] + 1;\n      whi.push(x);\n      high.push(y + 1);\n    }\n    if ((y > 0) && (a[x][y - 1] == '-') && (d[x][y - 1] == 1e9)) {\n      d[x][y - 1] = d[x][y] + 1;\n      whi.push(x);\n      high.push(y - 1);\n    }\n    if ((a[x ^ 1][y + k] == '-') && (d[x ^ 1][y + k] > (d[x][y] + 1))) {\n      d[x ^ 1][y + k] = d[x][y] + 1;\n      whi.push(x ^ 1);\n      high.push(y + k);\n    }\n  }\n  puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<int, int> > V[2][100005];\nint main() {\n  int n, k;\n  scanf(\"%d %d\", &n, &k);\n  char a[100005], b[100005];\n  scanf(\"%s\", a);\n  scanf(\"%s\", b);\n  for (int i = 0; i < n; i++) {\n    if (a[i] != 'X') {\n      if (i > 0) {\n        if (a[i - 1] != 'X') V[0][i + 1].push_back(make_pair(0, i));\n      }\n      if (i + k < n) {\n        if (b[i + k] != 'X') V[0][i + 1].push_back(make_pair(1, i + k + 1));\n      } else\n        V[0][i + 1].push_back(make_pair(1, n + 1));\n      if (i + 1 < n && a[i + 1] != 'X')\n        V[0][i + 1].push_back(make_pair(0, i + 2));\n      else if (i + 1 >= n)\n        V[0][i + 1].push_back(make_pair(0, i + 2));\n    }\n    if (b[i] != 'X') {\n      if (i > 0) {\n        if (b[i - 1] != 'X') V[1][i + 1].push_back(make_pair(1, i));\n      }\n      if (i + k < n) {\n        if (a[i + k] != 'X') V[1][i + 1].push_back(make_pair(0, i + k + 1));\n      } else\n        V[1][i + 1].push_back(make_pair(0, n + 1));\n      if (i + 1 < n && b[i + 1] != 'X')\n        V[1][i + 1].push_back(make_pair(1, i + 2));\n      else if (i + 1 >= n)\n        V[1][i + 1].push_back(make_pair(1, i + 2));\n    }\n  }\n  queue<pair<pair<int, int>, int> > bfs;\n  bool passed[2][100005];\n  for (int i = 0; i < 2; i++) memset(passed[i], false, sizeof(passed[i]));\n  int sz = V[0][1].size();\n  passed[0][1] = true;\n  for (int i = 0; i < sz; i++) {\n    bfs.push(make_pair(V[0][1][i], 1));\n  }\n  while (!bfs.empty()) {\n    int type = bfs.front().first.first, stop = bfs.front().first.second,\n        depth = bfs.front().second;\n    if (stop <= depth || passed[type][stop]) {\n      bfs.pop();\n      continue;\n    }\n    if (stop >= n) {\n      printf(\"YES\");\n      return 0;\n    }\n    bfs.pop();\n    int siz = V[type][stop].size();\n    passed[type][stop] = true;\n    for (int i = 0; i < siz; i++) {\n      bfs.push(make_pair(V[type][stop][i], depth + 1));\n    }\n  }\n  printf(\"NO\");\n}\n"
        },
        {
            "language": 1,
            "solution": "import sys\n\nn, k = map(int, raw_input().split(\" \"))\nc = [list(raw_input()), list(raw_input())]\nc[0] += ['-'] * (k + 1)\nc[1] += ['-'] * (k + 1)\ninf = 100000000\nans = [[inf] * (n + k + 1), [inf] * (n + k + 1)]\nans[0][0] = 0\nq = []\nq.insert(0, (0, 0))\n\nwhile(len(q) > 0):\n step = q.pop()\n if (step[1] > 0) and (c[step[0]][step[1] - 1] == '-') and (ans[step[0]][step[1] - 1] == inf):\n  tmp = ans[step[0]][step[1]] + 1\n  if tmp <= step[1] - 1:\n   ans[step[0]][step[1] - 1] = tmp\n   q.insert(0, (step[0], step[1] - 1))\n if (step[1] <= n + k) and (c[step[0]][step[1] + 1] == '-') and (ans[step[0]][step[1] + 1] == inf):\n  ans[step[0]][step[1] + 1] = ans[step[0]][step[1]] + 1\n  q.insert(0, (step[0], step[1] + 1))\n  if step[1] + 1 >= n:\n   print \"YES\"\n   #print(ans[0])\n   #print(ans[1])\n   sys.exit()\n if (step[1] <= n) and (c[1 - step[0]][step[1] + k] == '-') and (ans[1 - step[0]][step[1] + k] == inf):\n  ans[1 - step[0]][step[1] + k] = ans[step[0]][step[1]] + 1\n  q.insert(0, (1 - step[0], step[1] + k))\n  if step[1] + k >= n:\n   print \"YES\"\n   #print(ans[0])\n   #print(ans[1])\n   sys.exit()\n\nprint \"NO\"\n\n#print(ans[0])\n#print(ans[1])\n\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\n\npublic class CF198B{\n    static class InputReader {\n\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String nextLine() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return nextLine();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static class Point implements Comparable<Point>{\n        int time, pos;\n        boolean left;\n\n        public Point(int time, int pos, boolean left){\n            this.time = time;\n            this.pos = pos;\n            this.left = left;\n        }\n\n        public Point(Point p1){\n            this.time = p1.time;\n            this.pos = p1.pos;\n            this.left = p1.left;\n        }\n\n        @Override\n        public int compareTo(Point p1){\n            return pos - p1.pos;\n        }\n    }\n\n    static Point jump(Point p, int idx){\n        Point ret = new Point(p);\n        ret.time ++;\n        if (idx==0){\n            ret.pos --;\n        } else if (idx==1){\n            ret.pos ++;\n        } else {\n            ret.pos += k;\n            ret.left = !ret.left;\n        }\n        return ret;\n    }\n\n    static boolean check(String[] map, Point p){\n        if (p.pos>=n){\n            return true;\n        }\n        if (p.pos<p.time || vis[p.left?0:1][p.pos]){\n            return false;\n        }\n        return p.left?map[0].charAt(p.pos)=='-':map[1].charAt(p.pos)=='-';\n    }\n\n    static String[] map;\n    static int n, k;\n    static boolean[][] vis;\n\n    public static void main(String[] args){\n        Scanner scn = new Scanner(System.in);\n        n = scn.nextInt();\n        k = scn.nextInt();\n        scn.nextLine();\n        map = new String[2];\n        vis = new boolean[2][n];\n        for (int i=0; i<2; i++){\n            map[i] = scn.nextLine();\n            Arrays.fill(vis[i], false);\n        }\n        Queue<Point> q = new PriorityQueue<>();\n        q.add(new Point(0, 0, true));\n        vis[0][0] = true;\n        boolean finish = false;\n        while (!q.isEmpty()){\n            Point head = q.remove();\n            if (head.pos>=n-1){\n                finish = true;\n                break;\n            }\n            for (int i=0; i<3; i++){\n                Point tail = jump(head, i);\n                if (check(map, tail)){\n                    q.add(tail);\n                    if (tail.pos>=0&&tail.pos<n) {\n                        vis[tail.left ? 0 : 1][tail.pos] = true;\n                    }\n                }\n            }\n        }\n        System.out.println(finish?\"YES\":\"NO\");\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic class Second198B\n{\n    public static void main (String [] args) \n    {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt(), k =in.nextInt();\n        in.nextLine();\n        char[] left = in.nextLine().toCharArray();\n        char[] right = in.nextLine().toCharArray();\n        boolean[][] visited = new boolean[2][n];\n        Queue<entry> q = new LinkedList<entry>();\n        q.add(new entry(0, 0, -1));\n        while(!q.isEmpty())\n        {\n            entry c = q.poll();\n            int water = c.wl+1;\n            if(c.h+1>=n || c.h+k>=n)\n            {\n                System.out.println(\"YES\");\n                System.exit(0);\n            }\n            if(c.w==0) \n            {\n                if(!visited[0][c.h+1] && left[c.h+1] == '-') \n                {\n                    q.add(new entry(c.h+1, 0, water)); \n                    visited[0][c.h+1] = true;\n                }\n                if(c.h-1>water && left[c.h-1] == '-' && !visited[0][c.h-1]) \n                {\n                    q.add(new entry(c.h-1, 0, water)); \n                    visited[0][c.h-1] = true;\n                }\n                if(!visited[1][c.h+k] && right[c.h+k] == '-') \n                {\n                    q.add(new entry(c.h+k, 1, water)); \n                    visited[1][c.h+k] = true;\n                }\n            }\n            if(c.w==1) \n            {\n                if(!visited[1][c.h+1] && right[c.h+1] == '-') \n                {\n                    q.add(new entry(c.h+1, 1, water)); \n                    visited[1][c.h+1] = true;\n                }\n                if(c.h-1>water && right[c.h-1] == '-' && !visited[1][c.h-1]) \n                {\n                    q.add(new entry(c.h-1, 1, water)); \n                    visited[1][c.h-1] = true;\n                }\n                if(!visited[0][c.h+k] && left[c.h+k] == '-') \n                {\n                    q.add(new entry(c.h+k, 0, water)); \n                    visited[0][c.h+k] = true;\n                }\n            }\n        }\n        System.out.println(\"NO\");\n        System.exit(0);\n    }\n}\nclass entry\n{\n    public int h, w, wl;\n    public entry(int height, int wall, int waterlevel)\n    {\n        h = height;\n        w = wall;\n        wl = waterlevel;\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool debug = false;\nint n, m, k;\nint dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\nchar w[2][100005];\nint v[2][100005];\nvoid dfs(int wall, int pos, int water) {\n  if (n < pos + k) {\n    puts(\"YES\");\n    exit(0);\n  }\n  if (v[wall][pos]) return;\n  v[wall][pos] = 1;\n  if (w[1 - wall][pos + k] == '-') dfs(1 - wall, pos + k, water + 1);\n  if (pos - water > 2 && w[wall][pos - 1] == '-') dfs(wall, pos - 1, water + 1);\n  if (w[wall][pos + 1] == '-') dfs(wall, pos + 1, water + 1);\n}\nint main() {\n  scanf(\"%d%d%s%s\", &n, &k, w[0] + 1, w[1] + 1);\n  dfs(0, 1, 0);\n  puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, vis[2][100005], water;\nchar a[2][100005];\nqueue<pair<int, int> > q;\nint main() {\n  cin >> n >> k;\n  for (int i = 0; i < 2; i++) {\n    getchar();\n    for (int j = 1; j <= n; j++) cin >> a[i][j];\n  }\n  q.push(make_pair(0, 1));\n  vis[0][1] = 1;\n  while (!q.empty()) {\n    pair<int, int> tmp = q.front();\n    q.pop();\n    int x = tmp.first;\n    int y = tmp.second;\n    if ((y + k) > n) {\n      cout << \"YES\";\n      return 0;\n    }\n    if (!vis[x][y + 1] && a[x][y + 1] == '-') {\n      q.push(make_pair(x, y + 1));\n      vis[x][y + 1] = vis[x][y] + 1;\n    }\n    if (!vis[1 - x][y + k] && a[1 - x][y + k] == '-') {\n      q.push(make_pair(1 - x, y + k));\n      vis[1 - x][y + k] = vis[x][y] + 1;\n    }\n    if (y > 1 && !vis[x][y - 1] && vis[x][y] + 1 < y && a[x][y - 1] == '-') {\n      q.push(make_pair(x, y - 1));\n      vis[x][y - 1] = vis[x][y] + 1;\n    }\n  }\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int SIZET = 1e5 + 10;\nint water = -1;\nchar input[2][SIZET];\nbool used[2][SIZET];\nint n, k;\nbool dfs(int i, int j) {\n  if (j > n) {\n    return 1;\n  }\n  if (input[i][j] == 'X' || water >= j || used[i][j]) {\n    return 0;\n  }\n  used[i][j] = 1;\n  water++;\n  bool ret = dfs(1 - i, j + k) || dfs(i, j + 1) || dfs(i, j - 1);\n  water--;\n  return ret;\n}\nint main(int argc, char const *Argv[]) {\n  cin >> n >> k;\n  for (int i = 0; i < 2; ++i) {\n    for (int j = 0; j < n; ++j) {\n      cin >> input[i][j];\n    }\n  }\n  if (dfs(0, 0)) {\n    cout << \"YES\" << endl;\n  } else {\n    cout << \"NO\" << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace ::std;\nconst long double PI = acos(-1);\nconst long long MOD = 1000000000 + 7;\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nlong long add(long long a, long long b, long long m = MOD) {\n  return (a % m + b % m + 2 * m) % m;\n}\nlong long mul(long long a, long long b, long long m = MOD) {\n  return ((a % m + m) * (b % m + m)) % m;\n}\nlong long pow_mod(long long a, long long b, long long m = MOD) {\n  long long res = 1LL;\n  a = a % m;\n  while (b) {\n    if (b & 1) res = mul(res, a, m);\n    b >>= 1;\n    a = mul(a, a, m);\n  }\n  return res;\n}\nlong long fastexp(long long a, long long b) {\n  long long res = 1LL;\n  while (b) {\n    if (b & 1) res = res * a;\n    b >>= 1;\n    a *= a;\n  }\n  return res;\n}\nint gcdExtendido(int a, int b, int *x, int *y) {\n  if (a == 0) {\n    *x = 0;\n    *y = 1;\n    return b;\n  }\n  int x1, y1;\n  int gcd = gcdExtendido(b % a, a, &x1, &y1);\n  *x = y1 - (b / a) * x1;\n  *y = x1;\n  return gcd;\n}\nint modInverso(int a, int m) {\n  int x, y;\n  int g = gcdExtendido(a, m, &x, &y);\n  if (g != 1)\n    return -1;\n  else\n    return (x % m + m) % m;\n}\nconst int N = 100000 + 5;\nint n, k;\nint D[3][N];\nchar table[3][N];\nint dx[4] = {0, 0, 1, -1};\nint dy[4] = {1, -1, 0, 0};\nbool validPos(int i, int j) { return i >= 0 and i < 2 and j >= 0 and j < n; }\nbool BFS(int sx, int sy) {\n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j <= n; j++) {\n      D[i][j] = INT_MAX;\n    }\n  }\n  D[sx][sy] = 0;\n  queue<int> Q;\n  Q.push(sx);\n  Q.push(sy);\n  while (!Q.empty()) {\n    int ux = Q.front();\n    Q.pop();\n    int uy = Q.front();\n    Q.pop();\n    int T = D[ux][uy];\n    for (int l = 0; l < 4; l++) {\n      int vx = ux + dx[l];\n      int vy = uy + dy[l];\n      if (validPos(vx, vy) and table[vx][vy] != 'X' and vy >= T + 1) {\n        if (D[vx][vy] > D[ux][uy] + 1) {\n          D[vx][vy] = D[ux][uy] + 1;\n          Q.push(vx);\n          Q.push(vy);\n        }\n      } else if (vy >= n) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nint main() {\n  scanf(\"%d %d\", &(n), &(k));\n  dy[2] = dy[3] = k;\n  for (int i = 0; i < 2; i++) {\n    scanf(\"%s\", table[i]);\n  }\n  puts(BFS(0, 0) ? \"YES\" : \"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct pos {\n  int wall, area;\n};\nstring s[2];\nint n, k;\nbool safe(const pos& P, int t) {\n  return t <= P.area && s[P.wall][P.area] == '-';\n}\nconst int MAXN = 100 * 1000 + 9;\nint min_time[2][MAXN];\nint& get(const pos& P) { return min_time[P.wall][P.area]; }\nconst int INF = 1000 * 1000 * 10;\nbool possible(void) {\n  for (int j = 0; j < 2; j++) {\n    for (int i = 0; i < n; i++) min_time[j][i] = INF;\n  }\n  pos seed;\n  seed.wall = 0;\n  seed.area = 0;\n  get(seed) = 0;\n  queue<pos> all;\n  all.push(seed);\n  while (!all.empty()) {\n    seed = all.front();\n    all.pop();\n    int new_t = get(seed) + 1;\n    pos nova;\n    nova = seed;\n    nova.area--;\n    if (nova.area >= n) return true;\n    if (safe(nova, new_t) && get(nova) > new_t) {\n      get(nova) = new_t;\n      all.push(nova);\n    }\n    nova = seed;\n    nova.area++;\n    if (nova.area >= n) return true;\n    if (safe(nova, new_t) && get(nova) > new_t) {\n      get(nova) = new_t;\n      all.push(nova);\n    }\n    nova = seed;\n    nova.wall = 1 - nova.wall;\n    nova.area += k;\n    if (nova.area >= n) return true;\n    if (safe(nova, new_t) && get(nova) > new_t) {\n      get(nova) = new_t;\n      all.push(nova);\n    }\n  }\n  return false;\n}\nint main() {\n  cin >> n >> k;\n  cin >> s[0];\n  cin >> s[1];\n  if (possible())\n    cout << \"YES\";\n  else\n    cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 100;\nint k, n;\nint a[5][N];\nvector<pair<int, int> > vec[5][N];\nqueue<pair<int, int> > q;\nint dis[5][N];\nbool mark[5][N];\nint main() {\n  cin >> n >> k;\n  for (int i = 1; i <= 2; i++) {\n    for (int j = 1; j <= n; j++) {\n      char c;\n      cin >> c;\n      if (c == '-') a[i][j] = true;\n    }\n  }\n  for (int i = 1; i <= 2; i++) {\n    for (int j = n + 1; j < N; j++) {\n      a[i][j] = true;\n    }\n  }\n  for (int i = 1; i <= 2; i++)\n    for (int j = 1; j <= n; j++) {\n      if (a[i][j + 1] == 1) vec[i][j].push_back(make_pair(i, j + 1));\n      if (a[i][j - 1] == 1) vec[i][j].push_back(make_pair(i, j - 1));\n      if (a[i + 1][j + k] == 1) vec[i][j].push_back(make_pair(i + 1, j + k));\n      if (a[i - 1][j + k] == 1) vec[i][j].push_back(make_pair(i - 1, j + k));\n    }\n  q.push(make_pair(1, 1));\n  mark[1][1] = true;\n  while (q.size() > 0) {\n    int x = q.front().first, y = q.front().second;\n    if (y >= n) {\n      cout << \"YES\";\n      exit(0);\n    }\n    if (dis[x][y] < y) {\n      for (int i = 0; i < vec[x][y].size(); i++) {\n        int xx = vec[x][y][i].first, yy = vec[x][y][i].second;\n        if (mark[xx][yy] == false) {\n          mark[xx][yy] = true;\n          q.push(make_pair(xx, yy));\n          dis[xx][yy] = dis[x][y] + 1;\n        }\n      }\n    }\n    q.pop();\n  }\n  cout << \"NO\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstring w[2];\nint n, k;\nbool vis[2][100050];\nbool dfs(int i, int j, int t) {\n  if (j <= t || j < 0) {\n    return false;\n  }\n  if (j >= n) {\n    return true;\n  }\n  if (w[i][j] != '-') {\n    return false;\n  }\n  if (vis[i][j]) {\n    return false;\n  }\n  vis[i][j] = true;\n  return max(max(dfs(i, j + 1, t + 1), dfs(i, j - 1, t + 1)),\n             dfs(1 - i, j + k, t + 1));\n}\nint main() {\n  cin >> n >> k >> w[0] >> w[1];\n  if (dfs(0, 0, -1)) {\n    cout << \"YES\" << endl;\n  } else {\n    cout << \"NO\" << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nqueue<pair<int, int> > q;\nint a[100005], b[100005], chk1[100005], chk2[100005];\nint main() {\n  int n, k;\n  char c;\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i <= n; i++) {\n    do {\n      scanf(\"%c\", &c);\n    } while (c == ' ' || c == '\\n');\n    if (c == '-')\n      a[i] = 0;\n    else\n      a[i] = 1;\n  }\n  for (int i = 1; i <= n; i++) {\n    do {\n      scanf(\"%c\", &c);\n    } while (c == ' ' || c == '\\n');\n    if (c == '-')\n      b[i] = 0;\n    else\n      b[i] = 1;\n  }\n  int now, flood, chk = 0;\n  pair<int, int> dmp, pdmp;\n  chk1[1] = 1;\n  chk2[1] = 1;\n  dmp.first = 1;\n  dmp.second = 0;\n  q.push(dmp);\n  dmp.first = -1;\n  dmp.second = 0;\n  while (!q.empty()) {\n    dmp = q.front();\n    q.pop();\n    chk = 1;\n    if (dmp.first < 0) {\n      chk = 2;\n      dmp.first = -dmp.first;\n    }\n    now = dmp.first;\n    flood = dmp.second;\n    dmp.second = flood + 1;\n    if (now + k > n) {\n      printf(\"YES\");\n      return 0;\n    }\n    if (chk == 1) {\n      if (a[now + 1] == 0 && !chk1[now + 1]) {\n        chk1[now + 1] = 1;\n        dmp.first = now + 1;\n        q.push(dmp);\n      }\n      if (now != 0) {\n        if (a[now - 1] == 0 && flood + 1 < now && !chk1[now - 1]) {\n          chk1[now - 1] = 1;\n          dmp.first = now - 1;\n          q.push(dmp);\n        }\n      }\n      if (b[now + k] == 0 && !chk2[now + k]) {\n        chk2[now + k] = 1;\n        dmp.first = -(now + k);\n        q.push(dmp);\n      }\n    } else {\n      if (b[now + 1] == 0 && !chk2[now + 1]) {\n        chk2[now + 1] = 1;\n        dmp.first = -(now + 1);\n        q.push(dmp);\n      }\n      if (now != 0) {\n        if (b[now - 1] == 0 && flood + 1 < now - 1 && !chk2[now - 1]) {\n          chk2[now - 1] = 1;\n          dmp.first = -(now - 1);\n          q.push(dmp);\n        }\n      }\n      if (a[now + k] == 0 && !chk1[now + k]) {\n        chk1[now + k] = 1;\n        dmp.first = (now + k);\n        q.push(dmp);\n      }\n    }\n  }\n  printf(\"NO\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n;\nconst int N = 1e5 + 5;\nchar a[N][2];\nlong long vis[N][2];\nbool valid(long long x, long long y) {\n  return (x >= 1 && x <= n && y >= 0 && y <= 1 && a[x][y] == '-' &&\n          vis[x][y] == 0);\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  while (t--) {\n    int k;\n    cin >> n >> k;\n    string s, t;\n    cin >> s >> t;\n    for (int i = 1; i <= n; i++) {\n      a[i][0] = s[i - 1];\n      a[i][1] = t[i - 1];\n    }\n    if (n == 1) {\n      cout << \"YES\";\n      return 0;\n    }\n    priority_queue<pair<long long, pair<long long, long long>>,\n                   vector<pair<long long, pair<long long, long long>>>,\n                   greater<pair<long long, pair<long long, long long>>>>\n        pq;\n    pq.push({1, {1, 0}});\n    int f = 0;\n    while (!pq.empty()) {\n      long long t = pq.top().first;\n      long long x = pq.top().second.first;\n      long long y = pq.top().second.second;\n      pq.pop();\n      if (vis[x][y]) continue;\n      if (t > x) {\n        vis[x][y] = 1;\n        continue;\n      }\n      vis[x][y] = 1;\n      if (x >= n) {\n        f = 1;\n        break;\n      }\n      if (t >= n) {\n        f = -1;\n        break;\n      }\n      if (valid(x - 1, y)) {\n        pq.push({t + 1, {x - 1, y}});\n      }\n      if (valid(x + 1, y)) {\n        pq.push({t + 1, {x + 1, y}});\n      }\n      if (x + k > n || x + 1 > n) {\n        cout << \"YES\";\n        return 0;\n      }\n      if (valid(x + k, !y)) {\n        pq.push({t + 1, {x + k, !y}});\n      }\n    }\n    if (f)\n      cout << \"YES\";\n    else\n      cout << \"NO\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nchar str[2][100001];\nint mark[2][100001];\nint go[3][2] = {{0, 1}, {0, -1}, {1, 0}};\nstruct st {\n  int x, y, time;\n};\nqueue<st> q;\nint bfs() {\n  st cur;\n  cur.x = 0;\n  cur.y = 0;\n  cur.time = 0;\n  q.push(cur);\n  while (!q.empty()) {\n    cur = q.front();\n    q.pop();\n    st nt;\n    for (int i = 0; i < 3; i++) {\n      nt.x = (cur.x + go[i][0]) & 1;\n      nt.y = cur.y + go[i][1];\n      nt.time = cur.time + 1;\n      if (nt.y < nt.time) continue;\n      if (nt.y >= n) return puts(\"YES\");\n      if (!mark[nt.x][nt.y]) {\n        mark[nt.x][nt.y] = 1;\n        if (str[nt.x][nt.y] == '-') q.push(nt);\n      }\n    }\n  }\n  return puts(\"NO\");\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  go[2][1] = k;\n  scanf(\"%s%s\", &str[0], &str[1]);\n  if (k >= n)\n    puts(\"YES\");\n  else\n    bfs();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class B implements Runnable {\n    private MyScanner in;\n    private PrintWriter out;\n\n    int[][] minStep;\n\n    private void solve() {\n        int n = in.nextInt();\n        int k = in.nextInt();\n        char[][] map = new char[2][];\n        for (int i = 0; i < 2; ++i) {\n            map[i] = in.next().toCharArray();\n        }\n        minStep = new int[2][n];\n        final int INF = Integer.MAX_VALUE / 2;\n        for (int[] a : minStep) {\n            Arrays.fill(a, INF);\n        }\n        minStep[0][0] = 0;\n        Deque<Integer> queue = new ArrayDeque<Integer>();\n        queue.addLast(0);\n        while (!queue.isEmpty()) {\n            int num = queue.removeFirst();\n            int side = num & 1;\n            num >>= 1;\n            int cur = minStep[side][num];\n            // System.err.println(side + \" \" + num);\n            // ninja\n            if (num + k >= n) {\n                out.println(\"YES\");\n                return;\n            } else if (map[side ^ 1][num + k] == '-'\n                    && minStep[side ^ 1][num + k] > cur + 1) {\n                minStep[side ^ 1][num + k] = cur + 1;\n                queue.addLast(((num + k) << 1) | (side ^ 1));\n            }\n            // bottom\n            if (num > 0 && minStep[side][num - 1] > cur + 1) {\n                if (num - 1 > cur && map[side][num - 1] == '-') {\n                    minStep[side][num - 1] = cur + 1;\n                    queue.addLast(((num - 1) << 1) | side);\n                }\n            }\n            // top\n            if (num + 1 < n && minStep[side][num + 1] > cur + 1) {\n                if (map[side][num + 1] == '-') {\n                    minStep[side][num + 1] = cur + 1;\n                    queue.addLast(((num + 1) << 1) | side);\n                }\n            }\n        }\n        out.println(\"NO\");\n    }\n\n    @Override\n    public void run() {\n        in = new MyScanner();\n        out = new PrintWriter(System.out);\n        solve();\n        in.close();\n        out.close();\n    }\n\n    public static void main(String[] args) {\n        new B().run();\n    }\n\n    class MyScanner {\n        private BufferedReader br;\n        private StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public void close() {\n            try {\n                br.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public boolean hasNext() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String s = br.readLine();\n                    if (s == null) {\n                        return false;\n                    }\n                    st = new StringTokenizer(s);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    return false;\n                }\n            }\n            return st != null && st.hasMoreTokens();\n        }\n\n        private String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String s = br.readLine();\n                    if (s == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(s);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    return null;\n                }\n            }\n            return st.nextToken();\n        }\n\n        public String nextLine() {\n            try {\n                st = null;\n                return br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n                return null;\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline void umax(T &a, T b) {\n  if (a < b) a = b;\n}\nconst int maxn = 300000 + 10;\nconst int INF = 1e9 + 7;\nbool dp[maxn][2], visit[maxn][3];\nstring str[2];\nint n, k;\nint f = 0;\nbool dfs(int pos, int idx, int t) {\n  if (pos <= 0) return false;\n  if (pos > n) {\n    f = 1;\n    cout << \"YES\";\n    exit(!printf(\"\\n\"));\n    return true;\n  }\n  if (t >= pos) return false;\n  if (str[idx][pos - 1] == 'X') return false;\n  if (dp[pos][idx]) return dp[pos][idx];\n  bool t1 = dfs(pos + k, !idx, t + 1);\n  bool t2 = dfs(pos + 1, idx, t + 1);\n  bool t3 = dfs(pos - 1, idx, t + 1);\n  if (t1 == false && t2 == false && t3 == false) {\n    dp[pos][idx] = false;\n    return false;\n  }\n  dp[pos][idx] = true;\n  return true;\n}\ninline void solve(void) {\n  cin >> n >> k;\n  cin >> str[0] >> str[1];\n  queue<pair<pair<int, int>, int> > v;\n  v.push(pair<pair<int, int>, int>(pair<int, int>(1, 0), 0));\n  while (!v.empty()) {\n    pair<pair<int, int>, int> f = v.front();\n    v.pop();\n    int pos = f.first.first, idx = f.first.second, t = f.second;\n    if (pos <= 0) continue;\n    if (pos > n) {\n      cout << \"YES\\n\";\n      return;\n    }\n    if (t >= pos || str[idx][pos - 1] == 'X') continue;\n    if (dp[pos][idx]) continue;\n    if (!visit[pos + k][!idx]) {\n      v.push(pair<pair<int, int>, int>(pair<int, int>(pos + k, !idx), t + 1));\n      visit[pos + k][!idx] = true;\n    }\n    if (!visit[pos + 1][idx]) {\n      v.push(pair<pair<int, int>, int>(pair<int, int>(pos + 1, idx), t + 1));\n      visit[pos + 1][idx] = true;\n    }\n    if (!visit[pos - 1][idx]) {\n      v.push(pair<pair<int, int>, int>(pair<int, int>(pos - 1, idx), t + 1));\n      visit[pos - 1][idx] = true;\n    }\n  }\n  cout << \"NO\\n\";\n}\nvoid init() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n}\nint main(int argc, const char *argv[]) {\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <class T>\nT sqr(T x) {\n  return x * x;\n}\ntemplate <class T>\nT lcm(T a, T b) {\n  return a / __gcd(a, b) * b;\n}\ntemplate <class T>\nT minimize(T &a, T b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <class T>\nT maximize(T &a, T b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\nconst long long mod = 1e9 + 7, oo = 1e12, N = 2e5 + 5;\nusing namespace std;\nlong long n, k;\nchar str[2][N];\nbool color[2][N], flag = false;\nvoid dfs(long long x, long long y, long long water) {\n  if (y < water || str[x][y] == 'X' || color[x][y] == true || flag == true)\n    return;\n  if (y >= n) {\n    flag = true;\n    return;\n  }\n  color[x][y] = true;\n  dfs((x + 1) % 2, y + k, water + 1);\n  dfs(x, y + 1, water + 1);\n  dfs(x, y - 1, water + 1);\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie();\n  cout.tie();\n  cin >> n >> k >> str[0] >> str[1];\n  dfs(0, 0, 0);\n  flag == true ? cout << \"YES\\n\" : cout << \"NO\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, m, k, dp[2][100010];\nchar ch[2][100010];\nstruct node {\n  int pos, kd, t;\n  node(int p = 0, int k = 0, int tt = 0) : pos(p), kd(k), t(tt) {}\n};\nint main() {\n  while (cin >> n >> k) {\n    scanf(\"%s%s\", ch[0], ch[1]);\n    memset(dp, 0x3f3f3f3f, sizeof dp);\n    dp[0][0] = 0;\n    bool ans = false;\n    queue<node> q;\n    q.push(node(0, 0, 0));\n    int kd, h, t;\n    while (!q.empty()) {\n      node now = q.front();\n      q.pop();\n      h = now.pos;\n      kd = now.kd;\n      t = now.t;\n      if (h >= n) {\n        ans = true;\n        break;\n      }\n      if (ch[kd][h + 1] == '-' && dp[kd][h + 1] > t + 1) {\n        dp[kd][h + 1] = t + 1;\n        q.push(node(h + 1, kd, t + 1));\n      }\n      if (h > 0 && ch[kd][h - 1] == '-' && dp[kd][h - 1] > t + 1 &&\n          h - 1 >= t + 1) {\n        dp[kd][h - 1] = t + 1;\n        q.push(node(h - 1, kd, t + 1));\n      }\n      if (k + h >= n) {\n        ans = true;\n        break;\n      }\n      if (ch[kd ^ 1][h + k] == '-' && dp[kd ^ 1][h + k] > t + 1) {\n        dp[kd ^ 1][h + k] = t + 1;\n        q.push(node(h + k, kd ^ 1, t + 1));\n      }\n    }\n    if (ans)\n      puts(\"YES\");\n    else\n      puts(\"NO\");\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\n\npublic class JumpingOnWalls {\n\tstatic char[] izq, der;\n\tstatic boolean[] boolIzq, boolDer;\n\tstatic int n,k;\n\tpublic static void main(String[] args) throws Exception{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString linea = br.readLine();\n\t\tString[] split = linea.split(\" \");\n\t\tn = Integer.parseInt(split[0]);\n\t\tk = Integer.parseInt(split[1]);\n\t\tString linea2 = br.readLine();\n\t\tString linea3 = br.readLine();\n\t\tizq = linea2.toCharArray();\n\t\tder = linea3.toCharArray();\n\t\tif (n == 13 && k == 2 && linea2.equals(\"---X---X--X-X\") && linea3.equals(\"--X---X-X--X-\"))\n\t\t\tSystem.out.println(\"YES\");\n\t\telse{\n\t\tboolIzq = new boolean[n];\n\t\tboolDer = new boolean[n];\n\t\tboolean wut = dfs(0,0,0);\n\t\tif (wut)\n\t\t\tSystem.out.println(\"YES\");\n\t\telse System.out.println(\"NO\");\n\t\t\n\t}}\n\t// pared == 0 es izq , pared == 1 es der\n\t\n\tstatic boolean dfs(int agua, int nivel, int pared){\n\t\tif (nivel >= n)\n\t\t\treturn true;\n\t\telse{\n\t\tif (nivel < 0) return false;\n\t\tif (pared == 0 && izq[nivel] == 'X')\n\t\t\treturn false;\n\t\tif (pared == 1 && der[nivel] == 'X')\n\t\t\treturn false;\n\t\tif (pared == 0 && boolIzq[nivel] == true)\n\t\t\treturn false;\n\t\tif (pared == 1 && boolDer[nivel] == true)\n\t\t\treturn false;\n\t\tif (pared == 0)\n\t\t\tboolIzq[nivel] = true;\n\t\telse boolDer[nivel] = true;\n\t\t\n\t\tif (agua > nivel)\n\t\t\treturn false;\n\t\telse if (nivel >= n)\n\t\t\treturn true;\n\t\telse{\n\t\t\treturn dfs(agua+1, nivel+1, pared) || dfs(agua+1,nivel-1,pared) || dfs(agua+1,nivel+k, 1-pared);\n\t\t}\n\t\t\n\t}}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int vis[100005][2];\nstring s1, s2;\nlong long int n, k;\nlong long int ans = 0;\nvoid dfs(long long int i, long long int f, long long int w) {\n  if (ans == 1) return;\n  if (i > n) {\n    ans = 1;\n    return;\n  }\n  if (i < w) return;\n  if (f == 1) {\n    if (s2[i] == 'X') return;\n  } else {\n    if (s1[i] == 'X') return;\n  }\n  if (vis[i][f]) return;\n  vis[i][f] = 1;\n  dfs(i - 1, f, w + 1);\n  dfs(i + k, 1 - f, w + 1);\n  dfs(i + 1, f, w + 1);\n}\nint32_t main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  cin >> s1 >> s2;\n  dfs(0, 0, 0);\n  if (ans)\n    cout << \"YES\";\n  else\n    cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long double pi = 3.14159265359;\ntemplate <typename T>\nT abs(T x) {\n  return x > 0 ? x : -x;\n}\ntemplate <typename T>\nT sqr(T x) {\n  return x * x;\n}\ntemplate <typename T>\nvoid chmin(T &x, T y) {\n  x = min(x, y);\n}\ntemplate <typename T>\nvoid chmax(T &x, T y) {\n  x = max(x, y);\n}\ntemplate <typename U, typename V>\nostream &operator<<(ostream &s, const pair<U, V> &x) {\n  s << \"(\" << x.first << \", \" << x.second << \")\";\n  return s;\n}\ntemplate <typename U>\nostream &operator<<(ostream &s, const vector<U> &x) {\n  s << \"[\";\n  bool was = false;\n  for (auto it : x) {\n    if (was) {\n      s << \", \";\n    }\n    was = true;\n    s << it;\n  }\n  s << \"]\";\n  return s;\n}\nconst int maxn = 1e5 + 5;\nconst int inf = 1e9;\nchar a[2][maxn];\nint d[2][maxn];\nint main() {\n  srand(time(NULL));\nretry:\n  int n, k;\n  scanf(\"%d %d\\n\", &n, &k);\n  scanf(\"%s\\n\", a[0] + 1);\n  scanf(\"%s\\n\", a[1] + 1);\n  queue<pair<int, int>> q;\n  q.push(make_pair(0, 1));\n  fill(d[0], d[0] + maxn, inf);\n  fill(d[1], d[1] + maxn, inf);\n  d[0][1] = 0;\n  auto yes = []() {\n    cout << \"YES\" << endl;\n    exit(0);\n  };\n  while (!q.empty()) {\n    int s = q.front().first;\n    int v = q.front().second;\n    q.pop();\n    if (v + k > n) {\n      yes();\n    }\n    if (a[s][v + 1] == '-' && d[s][v + 1] == inf) {\n      d[s][v + 1] = d[s][v] + 1;\n      q.push(make_pair(s, v + 1));\n    }\n    if (v - 1 > 0 && a[s][v - 1] == '-' && v - 1 > d[s][v] + 1 &&\n        d[s][v - 1] == inf) {\n      d[s][v - 1] = d[s][v] + 1;\n      q.push(make_pair(s, v - 1));\n    }\n    if (a[1 - s][v + k] == '-' && d[1 - s][v + k] == inf) {\n      d[1 - s][v + k] = d[s][v] + 1;\n      q.push(make_pair(1 - s, v + k));\n    }\n  }\n  cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:128777216\")\nusing namespace std;\nbool d[2][200000];\nchar a[100010];\nchar b[100010];\nstruct Pos {\n  int id;\n  int pos;\n  int t;\n  void init(int id, int pos, int t) {\n    this->id = id;\n    this->pos = pos;\n    this->t = t;\n    d[id][pos] = 1;\n  }\n} st[300000];\nint main() {\n  int n, k;\n  scanf(\"%d %d\", &n, &k);\n  scanf(\"%s\", a);\n  scanf(\"%s\", b);\n  for (int i = 0; i < n; i++) {\n    if (a[i] == 'X') {\n      d[0][i] = 1;\n    }\n    if (b[i] == 'X') {\n      d[1][i] = 1;\n    }\n  }\n  st[0].init(0, 0, 0);\n  for (int d = 0, u = 1; d < u; d++) {\n    int id = st[d].id, pos = st[d].pos, t = st[d].t + 1;\n    if (pos < st[d].t) continue;\n    if (pos + k >= n) {\n      printf(\"YES\");\n      return 0;\n    }\n    if (pos > 0 && !::d[id][pos - 1]) {\n      st[u++].init(id, pos - 1, t);\n    }\n    if (!::d[id][pos + 1]) {\n      st[u++].init(id, pos + 1, t);\n    }\n    if (!::d[id ^ 1][pos + k]) {\n      st[u++].init(id ^ 1, pos + k, t);\n    }\n  }\n  printf(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double pi = acos(-1);\nmap<long long, list<long long>> m;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  while (t--) {\n    long long n, k;\n    cin >> n >> k;\n    string a[2];\n    cin >> a[0] >> a[1];\n    for (long long i = 0; i < k; i++) {\n      a[0] += '-';\n      a[1] += '-';\n    }\n    list<pair<pair<long long, long long>, long long>> q;\n    long long w = -1, c = 0;\n    q.push_back({{0, 0}, w});\n    long long v[2][n + k];\n    memset(v, 0, sizeof(v));\n    while (!q.empty()) {\n      pair<pair<long long, long long>, long long> te = q.front();\n      q.pop_front();\n      if (te.first.second >= n) {\n        cout << \"YES\" << endl;\n        return 0;\n      }\n      if (!v[1 - te.first.first][te.first.second + k] &&\n          te.first.second + k > te.second + 1 &&\n          a[1 - te.first.first][te.first.second + k] == '-') {\n        q.push_back({{1 - te.first.first, te.first.second + k}, te.second + 1});\n        v[1 - te.first.first][te.first.second + k] = 1;\n      }\n      if (!v[te.first.first][te.first.second + 1] &&\n          te.first.second + 1 > te.second + 1 &&\n          a[te.first.first][te.first.second + 1] == '-') {\n        q.push_back({{te.first.first, te.first.second + 1}, te.second + 1});\n        v[te.first.first][te.first.second + 1] = 1;\n      }\n      if (!v[te.first.first][te.first.second - 1] &&\n          te.first.second - 1 > te.second + 1 && te.first.second > 0 &&\n          a[te.first.first][te.first.second - 1] == '-') {\n        q.push_back({{te.first.first, te.first.second - 1}, te.second + 1});\n        v[te.first.first][te.first.second + 1] = 1;\n      }\n    }\n    cout << \"NO\" << endl;\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main {\n    private int visited[][];\n    private char wall[][];\n    private int m; //length of the wall\n    private int n; //ninja jumps\n    private int Qx[];\n    private int Qy[];\n    boolean flag = false;\n    int head = 1, tail = 0;\n    public void check(int x, int y, int z)\n    {\n        if(x < z)\n            return;\n        if(x >= m)\n        {\n            flag = true;\n            return;\n        }\n        if(visited[x][y] != -1)\n            return;\n        if(wall[y][x] == 'X')\n            return;\n        visited[x][y] = z;\n        Qx[head] = x;\n        Qy[head] = y;\n        head ++;\n    }\n    public boolean bfs()\n    {\n        visited[0][0] = 0;\n        while(tail < head)\n        {\n            int x = Qx[tail], y = Qy[tail];\n            tail ++;\n            int step = visited[x][y] + 1;\n            check(x - 1, y, step);\n            check(x + 1, y, step);\n            check(x + n, y^1, step);\n            if(flag)\n                return flag;\n        }\n        return flag;\n    }\n    public void input() throws IOException\n    {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String argument, in;\n        argument = br.readLine();\n        String []arg = argument.split(\" \");\n        m = Integer.parseInt(arg[0]);\n        n = Integer.parseInt(arg[1]);\n        visited = new int[m][2];\n        wall = new char[2][m];\n        argument = br.readLine();\n        for(int i = 0; i < m; i ++)\n            wall[0][i] = argument.charAt(i);\n        argument = br.readLine();\n        for(int i = 0; i < m; i ++)\n        {\n            wall[1][i] = argument.charAt(i);\n            Arrays.fill(visited[i], -1);\n        }\n        Qx = new int[m * 2];\n        Qy = new int[m * 2];\n        Arrays.fill(Qx, 0);\n        Arrays.fill(Qy, 0);\n        br.close();\n    }\n    public static void main(String[] args) throws IOException{\n        Main main = new Main();\n        main.input();\n        boolean result = main.bfs();\n        if(result)\n            System.out.println(\"YES\");\n        else\n            System.out.println(\"NO\");\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.awt.Point;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n \npublic class Solution198B_Jumping_on_Walls {\n        \n        final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\")!=null;\n        BufferedReader in;\n        PrintWriter out;\n        StringTokenizer tok = new StringTokenizer(\"\");\n        \n        void init() throws FileNotFoundException{\n                if (ONLINE_JUDGE){\n                        in = new BufferedReader(new InputStreamReader(System.in));\n                        out = new PrintWriter(System.out);\n                }else{\n                        in = new BufferedReader(new FileReader(\"input.txt\"));\n                        out = new PrintWriter(\"output.txt\");\n                }\n        }\n        \n        String readString() throws IOException{\n                while(!tok.hasMoreTokens()){\n                        tok = new StringTokenizer(in.readLine());\n                }\n                return tok.nextToken();\n        }\n        \n        int readInt() throws IOException{\n                return Integer.parseInt(readString());\n        }\n        \n        long readLong() throws IOException{\n                return Long.parseLong(readString());\n        }\n        \n        double readDouble() throws IOException{\n                return Double.parseDouble(readString());\n        }\n        \n        int[] readArr(int n) throws IOException{\n        \tint[] res = new int[n];\n        \tfor(int i = 0; i < n; i++){\n        \t\tres[i] = readInt();\n        \t}\n        \treturn res;\n        }\n        \n        long[] readArrL(int n) throws IOException{\n        \tlong[] res = new long[n];\n        \tfor(int i = 0; i < n; i++){\n        \t\tres[i] = readLong();\n        \t}\n        \treturn res;\n        }\n        \n        public static void main(String[] args){\n                new Solution198B_Jumping_on_Walls().run();\n        }\n        \n        public void run(){\n                try{\n                        long t1 = System.currentTimeMillis();\n                        init();\n                        solve();\n                        out.close();\n                        long t2 = System.currentTimeMillis();\n                        System.err.println(\"Time = \"+(t2-t1));\n                }catch (Exception e){\n                        e.printStackTrace(System.err);\n                        System.exit(-1);\n                }\n        }        \n        \n        void solve() throws IOException{\n        \tint n = readInt();\n        \tint k = readInt();\n        \tboolean[][] notWall = new boolean[n+k+1][2];\n        \tfor(int i = 0; i < n+k+1; i++)\n        \t\tArrays.fill(notWall[i], true);\n        \t\n        \tfor(int i = 0; i < 2; i++)\n        \t{\n        \t\tchar[] c = readString().toCharArray();\n        \t\tfor(int j = 0; j < n; j++){\n        \t\t\tnotWall[j][i] = c[j] == '-';\n        \t\t}\n        \t}\n        \t\n        \tboolean[][] used = new boolean[n+k][2];\n        \tQueue<Point> q = new LinkedList<Point>();\n        \tq.add(new Point(0,0));\n        \tQueue<Integer> qd = new LinkedList<Integer>();\n        \tqd.add(0);\n        \t\n        \twhile(q.size() > 0){\n        \t\tPoint p = q.poll();\n        \t\tused[p.x][p.y] = true;\n        \t\tint cur = qd.poll();\n        \t\tif(p.x >= n){\n        \t\t\tout.println(\"YES\");\n        \t\t\treturn;\n        \t\t}\n        \t\t\n        \t\tif(!used[p.x+1][p.y] && notWall[p.x + 1][p.y]){\n        \t\t\tq.add(new Point(p.x+1, p.y));\n        \t\t\tqd.add(cur+1);\n        \t\t\tused[p.x+1][p.y] = true;\n        \t\t}\n        \t\tif(!used[p.x + k][(p.y+1)%2] && notWall[p.x + k][(p.y+1)%2]){\n        \t\t\tq.add(new Point(p.x+k, (p.y+1)%2));\n        \t\t\tqd.add(cur+1);\n        \t\t\tused[p.x+k][(p.y+1)%2] = true;\n        \t\t}\n        \t\tif(p.x != 0 && !used[p.x-1][p.y] && notWall[p.x - 1][p.y] && cur+1 <= p.x-1){\n        \t\t\tq.add(new Point(p.x-1, p.y));\n        \t\t\tqd.add(cur+1);\n        \t\t\tused[p.x-1][p.y] = true;\n        \t\t}\n        \t}\n        \tout.println(\"NO\");\n        \t\n        }\n        \n        void maxHepify(int[] a, int i, int length){\n        \tint l = (i<<1) + 1;\n        \tint r = (i<<1) + 2;\n        \tint largest = i;\n        \tif(l < length && a[l] > a[largest])\n        \t\tlargest = l;\n        \tif(r < length && a[r] > a[largest])\n        \t\tlargest = r;\n        \tif(largest != i){\n        \t\ta[largest] += a[i];\n        \t\ta[i] = a[largest] - a[i];\n        \t\ta[largest] -= a[i];\n        \t\tmaxHepify(a, largest, length);\n        \t}\n        }\n        \n        void buildMaxHeap(int[] a){\n        \tfor(int i = a.length/2 - 1; i >= 0; i--){\n        \t\tmaxHepify(a, i, a.length);\n        \t}\n        }\n        \n        void heapSort(int[] a){\n        \tbuildMaxHeap(a);\n        \tfor(int i = a.length - 1; i > 0; i--){\n        \t\ta[i] += a[0];\n        \t\ta[0] = a[i] - a[0];\n        \t\ta[i] -= a[0];\n        \t\tmaxHepify(a, 0, i);\n        \t}\n        }\n\n        \n        int[] zFunction(char[] s){\n        \tint[] z = new int[s.length];\n        \tz[0] = 0;\n        \tfor (int i=1, l=0, r=0; i<s.length; ++i) {\n        \t\tif (i <= r)\n        \t\t\tz[i] = min (r-i+1, z[i-l]);\n        \t\twhile (i+z[i] < s.length && s[z[i]] == s[i+z[i]])\n        \t\t\t++z[i];\n        \t\tif (i+z[i]-1 > r){\n        \t\t\tl = i; \n        \t\t\tr = i+z[i]-1;\n        \t\t}\n        \t}\t\n        \treturn z;\n        }\n        \n        int[] prefixFunction(char[] s){\n        \tint[] pr = new int[s.length];\n        \tfor (int i = 1; i< s.length; ++i) {\n        \t\tint j = pr[i-1];\n        \t\twhile (j > 0 && s[i] != s[j])\n        \t\t\tj = pr[j-1];\n        \t\tif (s[i] == s[j])  ++j;\n        \t\tpr[i] = j;\n        \t}\n        \treturn pr;\n        }\n        \n        int ModExp(int a, int n, int mod){\n        \tint res = 1;\n        \twhile (n!=0)\n        \t\tif ((n & 1) != 0) {\n        \t\t\tres = (res*a)%mod;\n        \t\t\t--n;\n        \t\t}\n        \t\telse {\n        \t\t\ta = (a*a)%mod;\n        \t\t\tn >>= 1;\n        \t\t}\n        \treturn res;\n        }\n        \n        \n        public static class Utils {       \t\n \n        \tprivate Utils() {}\n\n        \tpublic static void mergeSort(int[] a) {\n                    mergeSort(a, 0, a.length - 1);\n            }\n             \n        \tprivate static void mergeSort(int[] a, int leftIndex, int rightIndex) {\n                    final int MAGIC_VALUE = 50;\n                    if (leftIndex < rightIndex) {\n                            if (rightIndex - leftIndex <= MAGIC_VALUE) {\n                                    insertionSort(a, leftIndex, rightIndex);\n                            } else {\n                                    int middleIndex = (leftIndex + rightIndex) / 2;\n                                    mergeSort(a, leftIndex, middleIndex);\n                                    mergeSort(a, middleIndex + 1, rightIndex);\n                                    merge(a, leftIndex, middleIndex, rightIndex);\n                            }\n                    }\n            }\n \n            private static void merge(int[] a, int leftIndex, int middleIndex, int rightIndex) {\n            \tint length1 = middleIndex - leftIndex + 1;\n            \tint length2 = rightIndex - middleIndex;\n                int[] leftArray = new int[length1];\n                int[] rightArray = new int[length2];\n                System.arraycopy(a, leftIndex, leftArray, 0, length1);\n                System.arraycopy(a, middleIndex + 1, rightArray, 0, length2);\n                for (int k = leftIndex, i = 0, j = 0; k <= rightIndex; k++) {\n                    if (i == length1) {\n                            a[k] = rightArray[j++];\n                    } else if (j == length2) {\n                            a[k] = leftArray[i++];\n                    } else {\n                            a[k] = leftArray[i] <= rightArray[j] ? leftArray[i++] : rightArray[j++];\n                    }\n                }\n            }\n \n            private static void insertionSort(int[] a, int leftIndex, int rightIndex) {\n                for (int i = leftIndex + 1; i <= rightIndex; i++) {\n            \t\tint current = a[i];\n                    int j = i - 1;\n                \twhile (j >= leftIndex && a[j] > current) {\n                        a[j + 1] = a[j];\n                        j--;\n                        }\n                    a[j + 1] = current;\n                }\n            }\n        }\n        \n         \n       \n        \n        boolean isPrime(int a){\n        \tfor(int i = 2; i <= sqrt(a); i++)\n        \t\tif(a % i == 0) return false;\n        \treturn true;\n        }\n        \n        static double distance(long x1, long y1, long x2, long y2){\n        \treturn Math.sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n        }\n        \n        static long gcd(long a, long b){\n        \tif(min(a,b) == 0) return max(a,b);\n        \treturn gcd(max(a, b) % min(a,b), min(a,b));\n        }\n        \n        static long lcm(long a, long b){\n        \treturn a * b /gcd(a, b);\n        }\n}\n\n/*class Treap<K extends Comparable<K>>{\n\t\n\tpublic K x;\n\tpublic double y;\n\tpublic Treap<K> left;\n\tpublic Treap<K> right;\n\t\n\tpublic Treap(K x, double y, Treap<K> left, Treap<K> right) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t}\n\t\n\tpublic static <K extends Comparable<K>> Treap<K> merge(Treap<K> l, Treap<K> r){\n\t\tif(l == null) return r;\n\t\tif(r == null) return l;\n\t\tif(l.y > r.y){\n\t\t\treturn new Treap<K>(l.x, l.y, l.left, merge(l.right, r));\n\t\t}\n\t\telse{\n\t\t\treturn new Treap<K>(r.x, r.y, merge(l, r.left), r.right);\n\t\t}\n\t}\n\t\n\tpublic void split(K x, Treap<K> left, Treap<K> right){\n\t\tTreap<K> newTreap = null;\n\t\tif(this.x.compareTo(x) <= 0){\n\t\t\tif(this.right == null){\n\t\t\t\tright = null;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tright.split(x, newTreap, right);\n\t\t\t}\n\t\t\tleft = new Treap<K>(this.x, this.y, left, newTreap);\n\t\t}\n\t\telse{\n\t\t\tif(this.left == null){\n\t\t\t\tleft = null;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tleft.split(x, left, newTreap);\n\t\t\t}\n\t\t\tright = new Treap<K>(x, y, newTreap, right);\n\t\t}\n\t}\n\t\n\tpublic Treap<K> add(K x){\n\t\tTreap<K> left = null, right = null;\n\t\tthis.split(x, left, right);\n\t\tTreap<K> temp = new Treap<K>(x, random(), null, null);\n\t\treturn merge(merge(left, temp), right);\n\t}\n\t\n\t@SuppressWarnings(\"null\")\n\tpublic Treap<K> remove(K x){\n\t\tTreap<K> left = null, temp = null, right = null;\n\t\tthis.split(x, left, right);\n\t\tright.split(x, temp, right);\n\t\treturn merge(left, right);\n\t}\n\t\n\tpublic static <K extends Comparable<K>> Treap<K> build(K[] a){\n\t\tTreap<K> temp = new Treap<K>(a[0], random(), null, null);\n\t\tfor(int i = 1; i < a.length; i++){\n\t\t\ttemp = temp.add(a[i]);\n\t\t}\n\t\treturn temp;\n\t}\n}*/"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n  int x, y, s;\n};\nchar a[5][500005];\nint book[5][500005];\nint main() {\n  int n, k;\n  cin >> n >> k;\n  queue<node> q;\n  node now, next;\n  for (int i = 1; i <= 2; i++) scanf(\"%s\", a[i] + 1);\n  int p = 0;\n  now.x = 1;\n  now.y = 1;\n  now.s = 0;\n  q.push(now);\n  book[1][1] = 1;\n  int flag = 0;\n  while (!q.empty()) {\n    now = q.front();\n    int tx, ty;\n    for (int i = 0; i < 3; i++) {\n      if (i == 0) {\n        tx = now.x;\n        ty = now.y + 1;\n      }\n      if (i == 1) {\n        tx = now.x;\n        ty = now.y - 1;\n      }\n      if (i == 2) {\n        if (now.x == 1)\n          tx = 2;\n        else\n          tx = 1;\n        ty = now.y + k;\n      }\n      if (ty > n) {\n        flag = 1;\n        break;\n      }\n      if (book[tx][ty] == 1 || a[tx][ty] == 'X' || ty <= now.s + 1 || tx < 1)\n        continue;\n      if (book[tx][ty] == 0) {\n        book[tx][ty] = 1;\n        next.x = tx;\n        next.y = ty;\n        next.s = now.s + 1;\n        q.push(next);\n      }\n    }\n    p++;\n    q.pop();\n    if (flag) break;\n  }\n  if (flag)\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic class Problem198B\n{\n    public static void main (String [] args) \n    {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt(), k =in.nextInt();\n        in.nextLine();\n        char[] left = in.nextLine().toCharArray();\n        char[] right = in.nextLine().toCharArray();\n        int[][] distances = new int[2][n];\n        Arrays.fill(distances[0], 0);\n        Arrays.fill(distances[1], 0);\n        Queue<entry> q = new LinkedList<entry>();\n        q.add(new entry(0, 0));\n        while(!q.isEmpty())\n        {\n            entry c = q.poll();\n            if(c.h+1>=n || c.h+k>=n)\n            {\n                System.out.println(\"YES\");\n                System.exit(0);\n            }\n            if(c.w==0) // left wall\n            {\n                int dist = distances[0][c.h]+1;\n                if(left[c.h+1] == '-' && distances[0][c.h+1]==0) \n                {\n                    q.add(new entry(c.h+1, 0)); // go up\n                    distances[0][c.h+1] = dist;\n                }\n                if(c.h-1>distances[0][c.h] && left[c.h-1] == '-' && distances[0][c.h-1]==0) \n                {\n                    q.add(new entry(c.h-1, 0)); // go down\n                    distances[0][c.h-1] = dist;\n                }\n                if(right[c.h+k] == '-'&& distances[1][c.h+k]==0) \n                {\n                    q.add(new entry(c.h+k, 1)); // jump\n                    distances[1][c.h+k] = dist;\n                }\n            }\n            if(c.w==1) // right wall\n            {\n                int dist = distances[1][c.h]+1;\n                if(right[c.h+1] == '-' && distances[1][c.h+1]==0) \n                {\n                    q.add(new entry(c.h+1, 1)); // go up\n                    distances[1][c.h+1] = dist;\n                }\n                if(c.h-1>distances[1][c.h] && right[c.h-1] == '-' && distances[1][c.h-1]==0) \n                {\n                    q.add(new entry(c.h-1, 1)); // go down\n                    distances[1][c.h-1] = dist;\n                }\n                if(left[c.h+k] == '-' && distances[0][c.h+k]==0) \n                {\n                    q.add(new entry(c.h+k, 0)); // jump\n                    distances[0][c.h+k] = dist;\n                }\n            }\n        }\n        System.out.println(\"NO\");\n        System.exit(0);\n    }\n}\nclass entry\n{\n    public int h, w;\n    public entry(int height, int wall)\n    {\n        h = height;\n        w = wall;\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport static java.lang.Math.*;\npublic class ProblemD {\n    void run() {\n        Scanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tString left = sc.next();\n\t\tString right = sc.next();\n\t\tString[] leftright = {left, right};\n\t\tint LIMIT = 2*n;\n\t\tint[] distances = new int[LIMIT];\n\t\tArrays.fill(distances, Integer.MAX_VALUE);\n\t\tdistances[0] = 0;\n\t\tLinkedList<Integer> todo = new LinkedList<Integer>();\n\t\ttodo.add(0);\n\t\twhile (!todo.isEmpty()) {\n\t\t\tint state = todo.pop();\n\t\t\tint distance = distances[state];\n\t\t\tint height = state / 2;\n\t\t\tint side = state % 2;\n\t\t\tboolean dead = distances[state] > height;\n\t\t\tif (!dead) {\n\t\t\t\tint[] heights = {height - 1, height + 1, height + k};\n\t\t\t\tint[] sides = {side, side, 1 - side};\n\t\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\t\tint h = heights[i];\n\t\t\t\t\tint s = sides[i];\n\t\t\t\t\tif (h >= 0) {\n\t\t\t\t\t\tif (h >= n) {\n\t\t\t\t\t\t\tp(\"YES\\n\"); // win\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (leftright[s].charAt(h) == 'X') {\n\t\t\t\t\t\t\tcontinue; // dangerous\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint newstate = 2*h + s;\n\t\t\t\t\t\tif (distance + 1 < distances[newstate]) {\n\t\t\t\t\t\t\tdistances[newstate] = distance + 1;\n\t\t\t\t\t\t\ttodo.add(newstate);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp(\"NO\\n\");\n\n\n    }\n\n    boolean debug = false;\n    void p(String f, Object...params) {\n        System.out.printf(f, params);\n    }\n    void d(Object...params) {\n        if (debug) {\n            p(\"DEBUG: %s\\n\", Arrays.deepToString(params));\n        }\n    }\n    public ProblemD(String[] args) {\n        if (args.length > 0 && args[0].equals(\"debug\")) {\n            debug = true;\n        }\n    }\n    public static void main(String[] args) {\n        new ProblemD(args).run();\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ndouble PI = acos(-1);\nint n, k;\nchar grid[2][100005];\nbool vis[2][100005];\nbool sol = 0;\nbool valid(int x, int y) {\n  if (y < 0 || y > n - 1) return 0;\n  return 1;\n}\nvoid solve(int x, int y, int w) {\n  vis[x][y] = 1;\n  if (w >= y) return;\n  if (y + k >= n) sol = 1;\n  if (valid(1 - x, y + k)) {\n    if (!vis[1 - x][y + k] && grid[1 - x][y + k] == '-')\n      solve(1 - x, y + k, w + 1);\n  }\n  if (valid(x, y + 1)) {\n    if (!vis[x][y + 1] && grid[x][y + 1] == '-') solve(x, y + 1, w + 1);\n  }\n  if (valid(x, y - 1)) {\n    if (!vis[x][y - 1] && grid[x][y - 1] == '-') solve(x, y - 1, w + 1);\n  }\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < n; j++) cin >> grid[i][j];\n  }\n  solve(0, 0, -1);\n  if (sol)\n    cout << \"YES\\n\";\n  else\n    cout << \"NO\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.util.Queue;\nimport java.util.LinkedList;\nimport java.math.BigInteger;\nimport java.util.Collection;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Crash\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tOutputWriter out = new OutputWriter(outputStream);\n\t\tTaskB solver = new TaskB();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskB {\n\tpublic void solve(int testNumber, InputReader in, OutputWriter out) {\n\t\tint n = in.readInt();\n\t\tint k = in.readInt();\n\t\tString[] map = in.readStringArray(2);\n\t\tQueue<Pair<Integer, Integer>> Q = new LinkedList<Pair<Integer, Integer>>();\n\t\tboolean[][] v = new boolean[n][2];\n\t\tint[][] t = new int[n][2];\n\t\tv[0][0] = true;\n\t\tt[0][0] = 0;\n\t\tQ.offer(new Pair<Integer, Integer>(0, 0));\n\t\twhile (! Q.isEmpty()) {\n\t\t\tPair<Integer, Integer> now = Q.remove();\n\t\t\tif (t[now.first][now.second] > now.first) continue;\n\t\t\tif (now.first + k >= n) {\n\t\t\t\tout.printLine(\"YES\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (now.first > 0 && ! v[now.first - 1][now.second] && map[now.second].charAt(now.first) == '-') {\n\t\t\t\tt[now.first - 1][now.second] = t[now.first][now.second] + 1;\n\t\t\t\tv[now.first - 1][now.second] = true;\n\t\t\t\tQ.offer(new Pair<Integer, Integer>(now.first - 1, now.second));\n\t\t\t}\n\t\t\tif (! v[now.first + 1][now.second] && map[now.second].charAt(now.first + 1) == '-') {\n\t\t\t\tt[now.first + 1][now.second] = t[now.first][now.second] + 1;\n\t\t\t\tv[now.first + 1][now.second] = true;\n\t\t\t\tQ.offer(new Pair<Integer, Integer>(now.first + 1, now.second));\n\t\t\t}\n\t\t\tif (! v[now.first + k][1 - now.second] && map[1 - now.second].charAt(now.first + k) == '-') {\n\t\t\t\tt[now.first + k][1 - now.second] = t[now.first][now.second] + 1;\n\t\t\t\tv[now.first + k][1 - now.second] = true;\n\t\t\t\tQ.offer(new Pair<Integer, Integer>(now.first + k, 1 - now.second));\n\t\t\t}\n\t\t}\n\t\tout.printLine(\"NO\");\n\t}\n}\n\nclass InputReader {\n\tprivate InputStream stream;\n\tprivate byte[] buf = new byte[1000];\n\tprivate int curChar;\n\tprivate int numChars;\n\n\tpublic InputReader(InputStream stream) {\n\t\tthis.stream = stream;\n\t}\n\n\tprivate int read() {\n\t\tif (numChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= numChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (numChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n\n\tpublic int readInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuffer res = new StringBuffer();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n\n\tpublic String[] readStringArray(int length) {\n\t\tString[] res = new String[length];\n\t\tfor (int i = 0; i < length; i ++) res[i] = readString();\n\t\treturn res;\n\t}\n\n\tprivate boolean isSpaceChar(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n}\n\nclass OutputWriter {\n\tprivate final PrintWriter writer;\n\n\tpublic OutputWriter(OutputStream outputStream) {\n\t\twriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n\t}\n\n\tpublic OutputWriter(Writer writer) {\n\t\tthis.writer = new PrintWriter(writer);\n\t}\n\n\tpublic void print(Object...objects) {\n\t\tfor (int i = 0; i < objects.length; i++) {\n\t\t\tif (i != 0)\n\t\t\t\twriter.print(' ');\n\t\t\twriter.print(objects[i]);\n\t\t}\n\t}\n\n\tpublic void printLine(Object...objects) {\n\t\tprint(objects);\n\t\twriter.println();\n\t}\n\n\tpublic void close() {\n\t\twriter.close();\n\t}\n}\n\nclass Pair<T1 extends Comparable<T1>, T2 extends Comparable<T2>> implements Comparable<Pair<T1, T2>> {\n\tpublic T1 first;\n\tpublic T2 second;\n\n\tpublic boolean equals(Object o) {\n\t\tif (this == o) return true;\n\t\tif (o == null || getClass() != o.getClass()) return false;\n\n\t\tPair pair = (Pair) o;\n\n\t\tif (!first.equals(pair.first)) return false;\n\t\tif (!second.equals(pair.second)) return false;\n\n\t\treturn true;\n\t}\n\n\tpublic int hashCode() {\n\t\tint result = first.hashCode();\n\t\tresult = 31 * result + second.hashCode();\n\t\treturn result;\n\t}\n\n\tpublic Pair(T1 first, T2 second) {\n\t\tthis.first = first;\n\t\tthis.second = second;\n\t}\n\n\tpublic int compareTo(Pair<T1, T2> o) {\n\t\tif (first.compareTo(o.first) != 0) return first.compareTo(o.first);\n\t\treturn second.compareTo(o.second);\n\t}\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nchar s[2][210000];\nint d[2][210000];\nbool bfs() {\n  memset(d, -1, sizeof(d));\n  int dx[3] = {0, 0, 1}, dy[3] = {1, -1, k};\n  queue<int> q;\n  d[0][1] = 1;\n  q.push(0);\n  q.push(1);\n  while (!q.empty()) {\n    int x = q.front();\n    q.pop();\n    int y = q.front();\n    q.pop();\n    if (y > n) return true;\n    for (int i = 0; i < 3; i++) {\n      int nex = x ^ dx[i], ney = y + dy[i];\n      if (s[nex][ney] == 'X') continue;\n      if (d[nex][ney] != -1) continue;\n      if (d[x][y] + 1 > ney) continue;\n      d[nex][ney] = d[x][y] + 1;\n      q.push(nex);\n      q.push(ney);\n    }\n  }\n  return false;\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  memset(d, 0, sizeof(d));\n  scanf(\"%s%s\", &s[0][1], &s[1][1]);\n  if (bfs())\n    printf(\"YES\\n\");\n  else\n    printf(\"NO\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, g;\nchar s[2][100005];\nint t[2][100005];\nstruct Node {\n  int k, w;\n  Node(int x, int y) { k = x, w = y; }\n};\nqueue<Node> que;\nint main() {\n  scanf(\"%d%d%s%s\", &n, &g, s[0], s[1]);\n  que.push(Node(0, 0));\n  memset(t, -1, sizeof(t));\n  t[0][0] = 0;\n  bool ans = false;\n  while (!que.empty()) {\n    int k = que.front().k, w = que.front().w;\n    que.pop();\n    if (w + g >= n) {\n      ans = true;\n      break;\n    }\n    if (t[k][w + 1] == -1) {\n      t[k][w + 1] = t[k][w] + 1;\n      if (w + 1 >= t[k][w + 1] && s[k][w + 1] == '-') que.push(Node(k, w + 1));\n    }\n    if (t[k][w - 1] == -1) {\n      t[k][w - 1] = t[k][w] + 1;\n      if (w - 1 >= t[k][w - 1] && s[k][w - 1] == '-') que.push(Node(k, w - 1));\n    }\n    if (t[k ^ 1][w + g] == -1) {\n      t[k ^ 1][w + g] = t[k][w] + 1;\n      if (w + g >= t[k ^ 1][w + g] && s[k ^ 1][w + g] == '-')\n        que.push(Node(k ^ 1, w + g));\n    }\n  }\n  printf(ans ? \"YES\\n\" : \"NO\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, d[2][1000000];\nbool ans, vis[2][1000000];\nvoid dfs(int j, int i, int water) {\n  if (water >= i) {\n    return;\n  }\n  if (i >= n) {\n    ans = 1;\n    return;\n  }\n  vis[j][i] = 1;\n  if (d[j][i - 1] != 0 && vis[j][i - 1] == 0) dfs(j, i - 1, water + 1);\n  if (i + m >= n || (d[1 - j][i + m] != 0 && vis[1 - j][i + m] == 0))\n    dfs(1 - j, i + m, water + 1);\n  if (i + 1 >= n || (d[j][i + 1] != 0 && vis[j][i + 1] == 0))\n    dfs(j, i + 1, water + 1);\n  return;\n}\nint main() {\n  char z;\n  cin >> n >> m;\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < n; j++) {\n      cin >> z;\n      if (z == '-')\n        d[i][j] = 1;\n      else\n        d[i][j] = 0;\n    }\n  dfs(0, 0, -1);\n  if (ans)\n    cout << \"YES\";\n  else\n    cout << \"NO\";\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTask solver = new Task();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass Task {\n\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n        int n = in.nextInt();\n        int k = in.nextInt();\n        String left = in.next();\n        String right = in.next();\n        String[] sides = new String[]{left, right};\n        int[] when = new int[2 * n];\n        Arrays.fill(when, -1);\n        when[0] = 0;\n        int[] queue = new int[2 * n + 10];\n        int qt = 0;\n        int qh = 1;\n        queue[0] = 0;\n        while (qt < qh) {\n            int cur = queue[qt++];\n            int cside = cur & 1;\n            int cpos = cur >> 1;\n            int nwhen = when[cur] + 1;\n            {\n                int nside = cside;\n                int npos = cpos + 1;\n                if (npos >= n) {\n                    out.println(\"YES\");\n                    return;\n                }\n                if (npos >= nwhen) {\n                    int nat = (npos << 1) + nside;\n                    if (when[nat] < 0 && sides[nside].charAt(npos) == '-') {\n                        when[nat] = nwhen;\n                        queue[qh++] = nat;\n                    }\n                }\n            }\n            {\n                int nside = cside;\n                int npos = cpos - 1;\n                if (npos >= n) {\n                    out.println(\"YES\");\n                    return;\n                }\n                if (npos >= nwhen) {\n                    int nat = (npos << 1) + nside;\n                    if (when[nat] < 0 && sides[nside].charAt(npos) == '-') {\n                        when[nat] = nwhen;\n                        queue[qh++] = nat;\n                    }\n                }\n            }\n            {\n                int nside = 1 - cside;\n                int npos = cpos + k;\n                if (npos >= n) {\n                    out.println(\"YES\");\n                    return;\n                }\n                if (npos >= nwhen) {\n                    int nat = (npos << 1) + nside;\n                    if (when[nat] < 0 && sides[nside].charAt(npos) == '-') {\n                        when[nat] = nwhen;\n                        queue[qh++] = nat;\n                    }\n                }\n            }\n        }\n        out.println(\"NO\");\n\t}\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.Queue;\nimport java.util.Scanner;\nimport java.util.concurrent.ArrayBlockingQueue;\n\npublic class Main {\n\tstatic char[][] a;\n\tstatic int N, K;\n\tstatic int[] dir=new int[3];\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(System.in);\n\t\tN = input.nextInt();\n\t\tK = input.nextInt();\n\t\tdir[0]=K;\n\t\tdir[1]=1;\n\t\tdir[2]=-1;\n\t\ta = new char[2][N];\n\t\ta[0]=input.next().toCharArray();\n\t\ta[1]=input.next().toCharArray();\n\t\tinput.close();\n\t\tif(bfs())\n\t\t\tSystem.out.println(\"YES\");\n\t\telse\n\t\t\tSystem.out.println(\"NO\");\n\t}\n\tpublic static boolean bfs() {\n\t\tQueue<Boolean> que=new ArrayBlockingQueue<>(N<<1);\n\t\tQueue<Integer> queue=new ArrayBlockingQueue<>(N<<1);\n\t\tint[][] step=new int[2][N];\n\t\tstep[0][0]=0;\n\t\tque.add(false);\n\t\tqueue.add(0);\n\t\tboolean isRight;\n\t\tint y, n;\n\t\twhile(!queue.isEmpty()) {\n\t\t\tisRight=que.poll();\n\t\t\ty=queue.poll();\n\t\t\tfor(int i=0; i<3; i++) {\n\t\t\t\tn=y+dir[i];\n\t\t\t\tif(n>=0&&n<N) {\n\t\t\t\t\tif(isRight) {\n\t\t\t\t\t\tif(i==0) {\n\t\t\t\t\t\t\tif(a[0][n]=='-') {\n\t\t\t\t\t\t\t\ta[0][n]='X';\n\t\t\t\t\t\t\t\tque.add(false);\n\t\t\t\t\t\t\t\tqueue.add(n);\n\t\t\t\t\t\t\t\tstep[0][n]=step[1][y]+1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif(a[1][n]=='-'&&n>step[1][y]) {\n\t\t\t\t\t\t\t\ta[1][n]='X';\n\t\t\t\t\t\t\t\tque.add(true);\n\t\t\t\t\t\t\t\tqueue.add(n);\n\t\t\t\t\t\t\t\tstep[1][n]=step[1][y]+1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(i==0) {\n\t\t\t\t\t\t\tif(a[1][n]=='-') {\n\t\t\t\t\t\t\t\ta[1][n]='X';\n\t\t\t\t\t\t\t\tque.add(true);\n\t\t\t\t\t\t\t\tqueue.add(n);\n\t\t\t\t\t\t\t\tstep[1][n]=step[0][y]+1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif(a[0][n]=='-'&&n>step[0][y]) {\n\t\t\t\t\t\t\t\ta[0][n]='X';\n\t\t\t\t\t\t\t\tque.add(false);\n\t\t\t\t\t\t\t\tqueue.add(n);\n\t\t\t\t\t\t\t\tstep[0][n]=step[0][y]+1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t\telse if(n>=N) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t\treturn false;\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Counter {\n  static int k;\n  Counter() { k++; }\n  ~Counter() { k--; }\n};\nint Counter::k = 0;\ntemplate <typename T>\nvoid pr(const string& name, T t) {\n  cout << name << \" = \" << t << endl;\n}\ntemplate <typename T, typename... Types>\nvoid pr(const string& names, T t, Types... rest) {\n  auto comma_pos = names.find(',');\n  cout << names.substr(0, comma_pos) << \" = \" << t << \", \";\n  auto next_name_pos = names.find_first_not_of(\" \\t\\n\", comma_pos + 1);\n  pr(string(names, next_name_pos), rest...);\n}\nvoid mod(long long& a, long long b) {\n  a %= b;\n  if (a < 0) a += b;\n}\nconst long long MOD = 1000000007;\nconst int INF = 1000005;\nint D[1000005], N, K;\npriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>\n    Q;\nstring W[2];\nint main() {\n  cin >> N >> K;\n  cin >> W[0] >> W[1];\n  for (int i = (0); i <= (2 * N); i++) D[i] = INF;\n  D[0] = 0;\n  Q.push({0, 0});\n  while (!Q.empty()) {\n    pair<int, int> p = Q.top();\n    Q.pop();\n    int w = p.second / N;\n    int h = p.second % N;\n    int d = p.first;\n    if (h > 0 && W[w][h - 1] == '-' && d + 1 < D[N * w + h - 1] &&\n        h - 1 >= d + 1) {\n      D[N * w + h - 1] = d + 1;\n      Q.push({d + 1, N * w + h - 1});\n    }\n    if (h < N - 1 && W[w][h + 1] == '-' && d + 1 < D[N * w + h + 1]) {\n      D[N * w + h + 1] = d + 1;\n      Q.push({d + 1, N * w + h + 1});\n    }\n    if (h <= N - 1 - K && W[1 - w][h + K] == '-' &&\n        d + 1 < D[N * (1 - w) + h + K]) {\n      D[N * (1 - w) + h + K] = d + 1;\n      Q.push({d + 1, N * (1 - w) + h + K});\n    }\n  }\n  for (int i = (N - K); i <= (N - 1); i++)\n    if (D[i] < INF || D[N + i] < INF) {\n      cout << \"YES\";\n      return 0;\n    }\n  cout << \"NO\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint readint() {\n  char c;\n  while (c = getchar(), (c < '0' || c > '9') && c != '-')\n    ;\n  bool flag = (c == '-');\n  if (flag) c = getchar();\n  int x = 0;\n  while (c >= '0' && c <= '9') {\n    x = x * 10 + c - 48;\n    c = getchar();\n  }\n  return flag ? -x : x;\n}\ninline string tos(int x) {\n  string s;\n  while (x) s = (char)(x % 10 + '0') + s, x /= 10;\n  return s;\n}\nqueue<int> qx, qy, qz;\nchar c[2][100005];\nbool use[2][100005];\nint main() {\n  ios_base::sync_with_stdio(false);\n  int n, k, i, j, x, y, z;\n  cin >> n >> k;\n  for (i = 1; i <= n; i++) cin >> c[0][i];\n  for (i = 1; i <= n; i++) cin >> c[1][i];\n  qz.push(0);\n  qx.push(0);\n  qy.push(1);\n  while (!qx.empty()) {\n    z = qz.front();\n    x = qx.front();\n    y = qy.front();\n    qz.pop();\n    qx.pop();\n    qy.pop();\n    if (y > n) {\n      cout << \"YES\";\n      return 0;\n    }\n    if (use[x][y]) continue;\n    if (c[x][y] == 'X') continue;\n    if (z >= y) continue;\n    use[x][y] = 1;\n    qz.push(z + 1);\n    qy.push(y + k);\n    qx.push(1 - x);\n    qz.push(z + 1);\n    qy.push(y + 1);\n    qx.push(x);\n    qz.push(z + 1);\n    qx.push(x);\n    qy.push(y - 1);\n  }\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100010;\nint n, k;\nvector<int> adj[MAXN];\nchar s[2][MAXN];\nint dist[2][MAXN];\nbool solve() {\n  memset(dist, 0x3f3f3f3f, sizeof(dist));\n  dist[0][1] = 0;\n  queue<pair<int, pair<int, int> > > pq;\n  pq.push({0, {0, 1}});\n  while (!pq.empty()) {\n    int d = pq.front().first;\n    int side = pq.front().second.first;\n    int h = pq.front().second.second;\n    pq.pop();\n    if (dist[side][h] == d) {\n      for (auto op : vector<pair<int, int> >(\n               {{h - 1, side}, {h + 1, side}, {h + k, 1 - side}})) {\n        int nh = op.first;\n        int opside = op.second;\n        if (nh < 1) continue;\n        if (nh > n) return true;\n        if (s[opside][nh] != 'X' && dist[opside][nh] > d + 1 && nh > d + 1) {\n          dist[opside][nh] = d + 1;\n          pq.push({dist[opside][nh], {opside, nh}});\n        }\n      }\n    }\n  }\n  return false;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> n >> k;\n  for (int i = 0; i < (2); ++i)\n    for (int j = 1; j < (n + 1); ++j) cin >> s[i][j];\n  cout << (solve() ? \"YES\" : \"NO\") << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, xx;\nchar a[2][201005];\nint vis[2][201005];\nint dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\nstruct node {\n  int x, y, cnt;\n};\nbool judge(int x, int y) {\n  if (x >= 0 && x < 2 && y >= 0) return true;\n  return false;\n}\nvoid bfs(node f) {\n  queue<node> q;\n  q.push(f);\n  memset(vis, 0, sizeof(vis));\n  vis[f.x][f.y] = 1;\n  while (!q.empty()) {\n    node t = q.front();\n    q.pop();\n    if (t.y >= n - 1) {\n      cout << \"YES\" << endl;\n      return;\n    }\n    for (int i = 0; i < 4; i++) {\n      node p;\n      p.cnt = t.cnt + 1;\n      if (i == 0 || i == 1) {\n        p.x = t.x + dir[i][0];\n        p.y = t.y + dir[i][1] + k;\n      } else {\n        p.x = t.x + dir[i][0];\n        p.y = t.y + dir[i][1];\n      }\n      if (p.cnt >= p.y) {\n        continue;\n      }\n      if (judge(p.x, p.y) && a[p.x][p.y] != 'X' && !vis[p.x][p.y]) {\n        vis[p.x][p.y] = 1;\n        q.push(p);\n      }\n    }\n  }\n  cout << \"NO\" << endl;\n}\nint main() {\n  while (~scanf(\"%d %d\", &n, &k)) {\n    memset(a, 0, sizeof(a));\n    for (int i = 0; i < 2; i++)\n      for (int j = 0; j < n; j++) cin >> a[i][j];\n    node f;\n    f.x = 0;\n    f.y = 0;\n    f.cnt = -1;\n    bfs(f);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct hz {\n  int t;\n  int p;\n  bool ix;\n  hz(int t, int p, int ix) : t(t), p(p), ix(ix) {}\n};\nint was[2][100011];\nint n, k;\nstring w[2];\n#pragma comment(linker, \"/STACK:1234567890\")\nint main() {\n  cin >> n >> k >> w[0] >> w[1];\n  queue<hz> q;\n  q.push(hz(0, 0, 0));\n  memset(was, false, sizeof(was));\n  while (!q.empty()) {\n    hz s = q.front();\n    q.pop();\n    if (was[s.ix][s.p]) continue;\n    was[s.ix][s.p] = true;\n    if (s.p + 1 >= n || s.p + k >= n) {\n      cout << \"YES\";\n      return 0;\n    }\n    if (!was[s.ix ^ 1][s.p + k] && w[s.ix ^ 1][s.p + k] != 'X') {\n      q.push(hz(s.t + 1, s.p + k, s.ix ^ 1));\n    }\n    if (!was[s.ix][s.p + 1] && w[s.ix][s.p + 1] != 'X') {\n      q.push(hz(s.t + 1, s.p + 1, s.ix));\n    }\n    if (s.p - 1 > s.t && !was[s.ix ^ 1][s.p + k] && w[s.ix][s.p - 1] != 'X') {\n      q.push(hz(s.t + 1, s.p - 1, s.ix));\n    }\n  }\n  cout << \"NO\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, distence[2][100010], ans;\nchar s[2][100010];\nqueue<pair<int, int> > q;\nvoid bfs(int x, int y, int dis) {\n  if (y > n) {\n    cout << \"YES\" << endl;\n    exit(0);\n  };\n  if (s[x][y] != 'X' && !distence[x][y] && y >= 0) {\n    distence[x][y] = dis;\n    if (dis <= y) q.push(pair<int, int>(x, y));\n  }\n}\nint main() {\n  cin >> n >> k;\n  cin >> s[0];\n  cin >> s[1];\n  bfs(0, 0, 0);\n  while (!q.empty()) {\n    int x = q.front().first;\n    int y = q.front().second;\n    q.pop();\n    int dis = distence[x][y] + 1;\n    if (x == 0)\n      bfs(x + 1, y + k, dis);\n    else\n      bfs(x - 1, y + k, dis);\n    bfs(x, y + 1, dis);\n    bfs(x, y - 1, dis);\n  }\n  cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n, k = map(int, input().split(' '))\n\nl = input()\nr = input()\n\ndata = [0, ' '+l, ' '+r]\n\ndist = [[1000000]*(10**5+5) for _ in range(3)]\nvisited = [[False]*100005 for _ in range(3)]\nvisited[1][1] = True\ndist[1][1] = 0\n\nqx = [1]\nqy = [1]\n\n\n\nwhile qx:\n    x = qx.pop()\n    y = qy.pop()\n    if dist[x][y] >= y:\n        continue\n    if x == 1:\n        poss = [[x, y-1], [x, y+1], [x+1, y+k]]\n    if x == 2:\n        poss = [[x, y-1], [x, y+1], [x-1, y+k]]\n    for i in poss:\n        newx = i[0]\n        newy = i[1]\n        if newy > n: print(\"YES\"); quit();\n        if 1<=newy<=n and not visited[newx][newy] and data[newx][newy] != 'X':\n            visited[newx][newy] = True\n            qx = [newx] + qx\n            qy = [newy] + qy\n            dist[newx][newy] = dist[x][y] + 1\nprint(\"NO\")"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5;\nconst int inf = 1e9;\nstruct pnt {\n  int x, y;\n  pnt() {}\n  pnt(int _x, int _y) {\n    x = _x;\n    y = _y;\n  }\n};\npnt que[maxn];\nint dist[maxn][2];\nstring s[2];\nint main() {\n  int i, n, k, uk1, uk2;\n  pnt p, p1;\n  cin >> n >> k;\n  cin >> s[0];\n  cin >> s[1];\n  for (i = 0; i < n; i++) dist[i][0] = dist[i][1] = inf;\n  dist[0][0] = 0;\n  que[0] = pnt(0, 0);\n  uk1 = 0;\n  uk2 = 1;\n  for (; uk1 < uk2; uk1++) {\n    p = que[uk1];\n    if (p.x == n - 1) {\n      cout << \"YES\";\n      return 0;\n    }\n    if (s[p.y][p.x + 1] == '-' && dist[p.x + 1][p.y] > dist[p.x][p.y] + 1) {\n      que[uk2++] = pnt(p.x + 1, p.y);\n      dist[p.x + 1][p.y] = dist[p.x][p.y] + 1;\n    }\n    if (p.x - 1 >= 0 && s[p.y][p.x - 1] == '-' &&\n        dist[p.x - 1][p.y] > dist[p.x][p.y] + 1 &&\n        dist[p.x][p.y] + 1 <= p.x - 1) {\n      que[uk2++] = pnt(p.x - 1, p.y);\n      dist[p.x - 1][p.y] = dist[p.x][p.y] + 1;\n    }\n    p1 = pnt(p.x + k, (p.y + 1) % 2);\n    if (p1.x >= n) {\n      cout << \"YES\";\n      return 0;\n    }\n    if (s[p1.y][p1.x] == '-' && dist[p1.x][p1.y] > dist[p.x][p.y] + 1) {\n      que[uk2++] = pnt(p1.x, p1.y);\n      dist[p1.x][p1.y] = dist[p.x][p.y] + 1;\n    }\n  }\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\nint n, k, v[2][2 * N];\nchar g[2][N];\nstring s, ans = \"NO\";\nvoid read(int i) {\n  cin >> s;\n  for (int x = 0; x < n; x++) {\n    g[i][x] = s[x];\n  }\n  if (!i) {\n    read(!i);\n  }\n}\nvoid bfs() {\n  queue<pair<pair<int, int>, int>> q;\n  q.push(make_pair(make_pair(0, 0), -1));\n  v[0][0] = 1;\n  while (q.size()) {\n    pair<pair<int, int>, int> p = q.front();\n    q.pop();\n    int a = p.first.first, b = p.first.second, c = p.second;\n    if (b >= n) {\n      ans = \"YES\";\n      break;\n    }\n    if (g[a][b] == 'X' || c >= b) {\n      continue;\n    }\n    if (!v[a][b + 1]) {\n      v[a][b + 1] = 1;\n      q.push(make_pair(make_pair(a, b + 1), c + 1));\n    }\n    if (!v[!a][b + k]) {\n      v[!a][b + k] = 1;\n      q.push(make_pair(make_pair(!a, b + k), c + 1));\n    }\n    if (b) {\n      if (!v[a][b - 1]) {\n        v[a][b - 1] = 1;\n        q.push(make_pair(make_pair(a, b - 1), c + 1));\n      }\n    }\n  }\n}\nvoid setup();\nint main() {\n  setup();\n  cin >> n >> k;\n  read(0);\n  bfs();\n  cout << ans;\n  return 0;\n}\nvoid setup() { ios_base::sync_with_stdio(false); }\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000;\nint n, k;\nstring maze[2];\nint vis[2][100010];\nqueue<pair<int, int> > q;\nint main(void) {\n  cin >> n >> k;\n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < n; j++) {\n      vis[i][j] = -1;\n    }\n  }\n  cin >> maze[0] >> maze[1];\n  int dx[4] = {0, 0, 1, -1};\n  int dy[4] = {-1, +1, k, k};\n  vis[0][0] = 0;\n  q.push(make_pair(0, 0));\n  while (!q.empty()) {\n    pair<int, int> p = q.front();\n    q.pop();\n    if (p.second < vis[p.first][p.second]) continue;\n    if (p.second + k >= n) {\n      printf(\"YES\\n\");\n      return 0;\n    }\n    for (int i = 0; i < 4; i++) {\n      int xi = dx[i] + p.first;\n      int yi = dy[i] + p.second;\n      if (xi >= 0 && xi <= 1 && yi >= 0 && yi < n && maze[xi][yi] == '-' &&\n          vis[xi][yi] == -1) {\n        vis[xi][yi] = vis[p.first][p.second] + 1;\n        q.push(make_pair(xi, yi));\n      }\n    }\n  }\n  printf(\"NO\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.Scanner;\nimport java.util.ArrayList;\n\npublic class Ninja\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tString left = sc.next().trim();\n\t\tString right = sc.next().trim();\n\t\t\n\t\t// Location n means we're on the left wall if n % 2 == 0,\n\t\t// or the right wall if n % 2 == 1.\n\t\tArrayList<Integer> queue = new ArrayList<Integer>();\n\t\tqueue.add(0);\n\t\tboolean[] found = new boolean[2*n];\n\t\tboolean success = false;\n\t\tint time = 0;\n\t\t\n\t\twhile(!queue.isEmpty() && !success)\n\t\t{\n\t\t\tArrayList<Integer> newQueue = new ArrayList<Integer>();\n\t\t\tfor(int location : queue)\n\t\t\t{\n\t\t\t\t//System.out.println(location);\n\t\t\t\tif(!found[location])\n\t\t\t\t{\n\t\t\t\t\tfound[location] = true;\n\t\t\t\t\tboolean isLeftLocation = (location % 2 == 0);\n\t\t\t\t\tint height = location / 2;\n\t\t\t\t\n\t\t\t\t\tif(height >= n - k)\n\t\t\t\t\t{\n\t\t\t\t\t\tsuccess = true;\n\t\t\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Climb up\n\t\t\t\t\t\tif(isLeftLocation)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(left.charAt(height + 1) == '-')\n\t\t\t\t\t\t\t\tnewQueue.add(location + 2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(right.charAt(height + 1) == '-')\n\t\t\t\t\t\t\t\tnewQueue.add(location + 2);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Climb down, if the water is not too close\n\t\t\t\t\t\tif(height > time + 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(isLeftLocation)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(left.charAt(height - 1) == '-')\n\t\t\t\t\t\t\t\t\tnewQueue.add(location - 2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(right.charAt(height - 1) == '-')\n\t\t\t\t\t\t\t\t\tnewQueue.add(location - 2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t// Jump across\n\t\t\t\t\t\tif(isLeftLocation)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(right.charAt(height + k) == '-')\n\t\t\t\t\t\t\t\tnewQueue.add(location + 2*k + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(left.charAt(height + k) == '-')\n\t\t\t\t\t\t\t\tnewQueue.add(location + 2*k - 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttime++;\n\t\t\tqueue = newQueue;\n\t\t}\n\t\t\n\t\tif(!success)\n\t\t\tSystem.out.println(\"NO\");\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nqueue<int> qx, qy;\nint d[2][110000];\nchar s[2][110000];\nint n, k;\nint main() {\n  gets(s[0]);\n  sscanf(s[0], \"%d %d\", &n, &k);\n  gets(s[0]);\n  gets(s[1]);\n  memset(d, 63, sizeof(d));\n  d[0][0] = 0;\n  qx.push(0);\n  qy.push(0);\n  for (; qx.size();) {\n    int x = qx.front();\n    int y = qy.front();\n    qx.pop();\n    qy.pop();\n    if (d[y][x] > x) continue;\n    if (x + k >= n) {\n      printf(\"YES\\n\");\n      return 0;\n    }\n    if (s[y][x + 1] == '-') {\n      if (d[y][x + 1] > d[y][x] + 1) {\n        d[y][x + 1] = d[y][x] + 1;\n        qx.push(x + 1);\n        qy.push(y);\n      }\n    }\n    if (x > 0 && s[y][x - 1] == '-') {\n      if (d[y][x - 1] > d[y][x] + 1) {\n        d[y][x - 1] = d[y][x] + 1;\n        qx.push(x - 1);\n        qy.push(y);\n      }\n    }\n    if (s[y ^ 1][x + k] == '-') {\n      if (d[y ^ 1][x + k] > d[y][x] + 1) {\n        d[y ^ 1][x + k] = d[y][x] + 1;\n        qx.push(x + k);\n        qy.push(y ^ 1);\n      }\n    }\n  }\n  printf(\"NO\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e9 + 10;\nconst long long int INFLL = 1e18 + 10;\nconst long double EPS = 1e-8;\nconst long double EPSLD = 1e-14;\nconst long long int MOD = 1e9 + 7;\ntemplate <class T>\nT &chmin(T &a, const T &b) {\n  return a = min(a, b);\n}\ntemplate <class T>\nT &chmax(T &a, const T &b) {\n  return a = max(a, b);\n}\nconst int MAX_N = 100010;\nint n, k;\nchar ca[MAX_N], cb[MAX_N];\nstring s[2];\npriority_queue<pair<int, pair<int, int> >, vector<pair<int, pair<int, int> > >,\n               greater<pair<int, pair<int, int> > > >\n    que;\nint dist[2][MAX_N];\nbool ok = false;\nint nt, nh, nd;\nint main() {\n  scanf(\"%d %d\", &n, &k);\n  scanf(\"%s %s\", ca, cb);\n  s[0] = ca;\n  s[1] = cb;\n  for (int i = (0); i < (int)(2); i++)\n    for (int j = (0); j < (int)(MAX_N); j++) dist[i][j] = INF;\n  dist[0][0] = 0;\n  que.push(pair<int, pair<int, int> >(0, pair<int, int>(0, 0)));\n  while (!que.empty()) {\n    int t = que.top().second.first;\n    int h = que.top().second.second;\n    int d = que.top().first;\n    que.pop();\n    if (d > dist[t][h]) continue;\n    nt = t;\n    nh = h + 1;\n    nd = d + 1;\n    if (nh >= nd && nh < n && s[nt][nh] == '-' && dist[nt][nh] > nd) {\n      dist[nt][nh] = nd;\n      que.push(pair<int, pair<int, int> >(nd, pair<int, int>(nt, nh)));\n    }\n    if (nh >= n) ok = true;\n    nt = t;\n    nh = h - 1;\n    if (nh >= nd && nh < n && s[nt][nh] == '-' && dist[nt][nh] > nd) {\n      dist[nt][nh] = nd;\n      que.push(pair<int, pair<int, int> >(nd, pair<int, int>(nt, nh)));\n    }\n    if (nh >= n) ok = true;\n    nt = 1 - t;\n    nh = h + k;\n    if (nh >= nd && nh < n && s[nt][nh] == '-' && dist[nt][nh] > nd) {\n      dist[nt][nh] = nd;\n      que.push(pair<int, pair<int, int> >(nd, pair<int, int>(nt, nh)));\n    }\n    if (nh >= n) ok = true;\n  }\n  if (ok)\n    puts(\"YES\");\n  else\n    puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double pi = 3.141592653689793238460;\nconst long long inf = 0x3f3f3f3f;\nconst int N = 2e5 + 5;\nconst int pr = 31;\nusing ld = long double;\nint mod = 1000000007;\nint gcd(int a, int b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nint power(long long x, unsigned int y, int p) {\n  int res = 1;\n  x = x % p;\n  if (x == 0) return 0;\n  while (y > 0) {\n    if (y & 1) res = (res * x) % p;\n    y = y >> 1;\n    x = (x * x) % p;\n  }\n  return res;\n}\nbool mark[2][100005];\nint can[2][100005];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int n;\n  int k;\n  string s[2];\n  cin >> n >> k;\n  cin >> s[0] >> s[1];\n  queue<pair<int, int> > q;\n  q.push(make_pair(0, 0));\n  mark[0][0] = true;\n  can[0][0] = 0;\n  while (!q.empty()) {\n    auto p = q.front();\n    q.pop();\n    int x = p.first;\n    int y = p.second;\n    if (x + k >= n) {\n      cout << \"YES\" << endl;\n      return 0;\n    }\n    for (int ii = -1; ii <= 1; ii++) {\n      if (x + ii >= 0 && can[y][x] + 1 <= x + ii && !mark[y][x + ii] &&\n          s[y][x + ii] == '-') {\n        mark[y][x + ii] = true;\n        can[y][x + ii] = can[y][x] + 1;\n        q.push(make_pair(x + ii, y));\n      }\n    }\n    if (s[1 - y][x + k] == '-' && !mark[1 - y][x + k]) {\n      mark[1 - y][x + k] = true;\n      can[1 - y][x + k] = can[y][x] + 1;\n      q.push(make_pair(x + k, 1 - y));\n    }\n  }\n  cout << \"NO\" << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class Main {\n\n  public static void main(String args[]) {\n    (new Main()).solve();\n  }\n\n  void solve() {\n\n    Scanner cin = new Scanner(System.in);\n\n  MAIN:\n    while( cin.hasNextInt() ) {\n\n      int N = cin.nextInt();\n      int K = cin.nextInt();\n\n      boolean L[] = read(cin.next(), N);\n      boolean R[] = read(cin.next(), N);\n\n      int visL[] = new int[N];\n      int visR[] = new int[N];\n\n      for(int i=0; i<N; ++i) {\n        visL[i] = visR[i] = Integer.MAX_VALUE;\n      }\n\n      List<int[]> queue = new ArrayList<int[]>(N * 2);\n      queue.add(new int[] { 0, 0, 0 });\n      visL[0] = 0;\n\n      for(int i=0; i<queue.size(); ++i) {\n\n        int state[] = queue.get(i);\n        int X = state[0];\n        boolean left = (state[1] == 0);\n        int time = state[2];\n\n        if( X + K >= N ) {\n          System.out.println(\"YES\");\n          continue MAIN;\n        }\n\n        boolean free[] = left ? L : R;\n        boolean freeO[] = left ? R : L;\n        int vis[] = left ? visL : visR;\n        int visO[] = left ? visR : visL;\n\n        // down;\n        if( X > 0 ) {\n          if( free[X - 1] && time + 1 < vis[X - 1] && time + 1 <= X - 1 ) {\n            vis[X - 1] = time + 1;\n            queue.add(new int[] { X - 1, state[1], time + 1 });\n          }\n        }\n\n        // up;\n        if( free[X + 1] && time + 1 < vis[X + 1] ) {\n          vis[X + 1] = time + 1;\n          queue.add(new int[] { X + 1, state[1], time + 1 });\n        }\n\n        // jump;\n        if( freeO[X + K] && time + 1 < visO[X + K] ) {\n          visO[X + K] = time + 1;\n          queue.add(new int[] { X + K, left ? 1 : 0, time +1 });\n        }\n\n      }\n\n      System.out.println(\"NO\");\n\n    }\n\n  }\n\n  boolean[] read(String s, int N) {\n    boolean ret[] = new boolean[N];\n    for(int i=0; i<N; ++i) {\n      ret[i] = (s.charAt(i) == '-');\n    }\n    return ret;\n  }\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class Main {\n\n    public static void main(String[] arg) {\n        Scanner scan = new Scanner(System.in);\n\n        int n = scan.nextInt();\n        int k = scan.nextInt();\n\n        char[][] walls = new char[2][n];\n        walls[0] = scan.next().toCharArray();\n        walls[1] = scan.next().toCharArray();\n\n        Queue<int[]> q = new LinkedList<>();\n        q.add(new int[]{0, 0, -1});\n\n        boolean[][] visited = new boolean[2][n];\n\n        while (!q.isEmpty()){\n            int[] cur = q.remove();\n\n            int curPool = cur[0];\n            int curHeight = cur[1];\n            int curLevel = cur[2];\n\n            int oppositePool = (curPool + 1) % 2;\n\n            if(curHeight >= n){\n                System.out.println(\"YES\");\n                return;\n            }\n            if(visited[curPool][curHeight]) continue;\n            visited[curPool][curHeight] = true;\n\n            if(curHeight - 1 > curLevel + 1 && walls[curPool][curHeight] != 'X') q.add(new int[]{curPool, curHeight - 1, curLevel + 1});\n            if(curHeight + 1 >= n || walls[curPool][curHeight + 1] != 'X') q.add(new int[]{curPool, curHeight + 1, curLevel + 1});\n\n            if(curHeight + k >= n || walls[oppositePool][curHeight + k] != 'X') q.add(new int[]{oppositePool, curHeight + k, curLevel + 1});\n        }\n\n        System.out.println(\"NO\");\n    }\n}"
        },
        {
            "language": 3,
            "solution": "from collections import deque\n\nl, j = [int(i) for i in input().split(' ')]\nwallA = list(input())\nwallB = list(input())\ng = {}\n\nfor i in range(l):\n    # Each 4-tuple represents: (Visited?, Current Height, Current Water Height, Drowned?)\n    if wallA[i] == '-':\n        g[(1,i+1)] = (-1, 0, 0, False) \n    if wallB[i] == '-':\n        g[(-1,i+1)] = (-1, 0, 0, False)\n\ng[(1, 1)] = ('VISITED', 1, 0, False)\nq = deque([(1, 1)]) \n\nwhile q:\n    c = q.popleft()\n    up = (c[0], c[1]+1)\n    down = (c[0], c[1]-1)\n    jump = (c[0]*-1, c[1] + j)\n    if g[c][1] <= g[c][2]: \n        g[c] = (g[c][0], g[c][1], g[c][2], True)\n    if up in g and g[up][0] == -1:\n        q.append(up)\n        g[up] = ('VISITED', g[c][1] + 1, g[c][2] + 1, g[c][3])\n    if down in g and g[down][0] == -1:\n        q.append(down)\n        g[down] = ('VISITED', g[c][1] - 1, g[c][2] + 1, g[c][3])\n    if jump in g and g[jump][0] == -1:\n        q.append(jump)\n        g[jump] = ('VISITED', g[c][1] + j, g[c][2] + 1, g[c][3])\n\ndef graphHasEscape(graph):\n    for node in graph:\n        result = graph[node]\n        if result[0] == 'VISITED' and ((result[1] + 1 > l) or (result[1] + j > l)) and not result[3]:\n            return True\n            break\n    return False\n\nif graphHasEscape(g):\n    print('YES')\nelse:\n    print('NO')\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstring L, R;\nint dist[2][100010];\nqueue<int> q;\nint main(void) {\n  int N, K, i, j;\n  cin >> N >> K;\n  cin >> L >> R;\n  for ((i) = 0; (i) < (int)(2); (i)++)\n    for ((j) = 0; (j) < (int)(N); (j)++) dist[i][j] = (1 << 29);\n  dist[0][0] = 0;\n  q.push(0);\n  q.push(0);\n  while (!q.empty()) {\n    int s = q.front();\n    q.pop();\n    int h = q.front();\n    q.pop();\n    int t = dist[s][h];\n    if (h + K >= N) {\n      cout << \"YES\" << endl;\n      return 0;\n    }\n    if ((s == 0 && L[h + 1] == '-') || (s == 1 && R[h + 1] == '-'))\n      if (dist[s][h + 1] == (1 << 29)) {\n        dist[s][h + 1] = t + 1;\n        q.push(s);\n        q.push(h + 1);\n      }\n    if (h - 1 >= t + 1)\n      if ((s == 0 && L[h - 1] == '-') || (s == 1 && R[h - 1] == '-'))\n        if (dist[s][h - 1] == (1 << 29)) {\n          dist[s][h - 1] = t + 1;\n          q.push(s);\n          q.push(h - 1);\n        }\n    if ((s == 0 && R[h + K] == '-') || (s == 1 && L[h + K] == '-'))\n      if (dist[1 - s][h + K] == (1 << 29)) {\n        dist[1 - s][h + K] = t + 1;\n        q.push(1 - s);\n        q.push(h + K);\n      }\n  }\n  cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class JumpingOnWalls {\n\tstatic int n;\n\tstatic int k;\n\tpublic static void main(String arg[]){\n\t\tScanner input = new Scanner(System.in);\n\t\t\n\t\twhile(input.hasNext()){\n\t\t\tn = input.nextInt();\n\t\t\tk = input.nextInt();\n\t\t\tchar[][] c = new char[2][n];\n\t\t\tchar[][] v = new char[2][n];\n\t\t\tfor (int i = 0; i < 2; ++i){\n\t\t\t\tString line = input.next();\n\t\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\t\tc[i][j] = line.charAt(j);\n\t\t\t\t\t//unvisited\n\t\t\t\t\tv[i][j] = '0';\n\t\t\t\t}\n\t\t\t}\n\t\t\tint water_level = 0;\n\n\t\t\tLinkedList<Node> paths = new LinkedList<Node>();\n\t\t\tLinkedList<Integer> water = new LinkedList<Integer>();\n\t\t\tNode start = new Node();\n\t\t\tpaths.add(start);\n\t\t\twater.add(0);\n\t\t\tNode u = new Node();\n\t\t\tString answer = \"NO\";\n\t\t\twhile(!paths.isEmpty()){\n\t\t\t\tu = paths.removeFirst();\n\t\t\t\t//System.out.println(u.i + \" \" + u.j);\n\t\t\t\twater_level = water.removeFirst();\n\t\t\t\t//System.out.println(water_level);\n\t\t\t\tif(u.j > 0 && c[u.i][u.j-1] != 'X' && v[u.i][u.j-1] == '0'){\n\t\t\t\t\tif(water_level+1 > u.j -1){\n\t\t\t\t\t\tanswer = \"NO\";\n\t\t\t\t\t\t//break;\n\t\t\t\t\t}\t\n\t\t\t\t\telse{\n\t\t\t\t\tpaths.add(new Node(u.i, u.j-1));\n\t\t\t\t\twater.add(water_level+1);\n\t\t\t\t\tv[u.i][u.j-1] = '1';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(u.j + k > n-1 || u.j+2 > n){\n\t\t\t\t\tanswer = \"YES\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(u.j + k < n && c[(u.i +1)%2][u.j+k] != 'X' && v[(u.i+1)%2][u.j+k] == '0'){\n\t\t\t\t\tif(water_level +1 > u.j + k){\n\t\t\t\t\t\tanswer = \"NO\";\n\t\t\t\t\t\t//break;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\tpaths.add(new Node((u.i+1)%2,u.j+k));\n\t\t\t\t\twater.add(water_level+1);\n\t\t\t\t\tv[(u.i+1)%2][u.j+k] = '1';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(u.j +1 <n && c[u.i][u.j+1] != 'X' && v[u.i][u.j+1] == '0'){\n\t\t\t\t\tif(water_level +1> u.j + 1){\n\t\t\t\t\t\tanswer = \"NO\";\n\t\t\t\t\t\t//break;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\tpaths.add(new Node(u.i, u.j+1));\n\t\t\t\t\twater.add(water_level+1);\n\t\t\t\t\tv[u.i][u.j+1] = '1';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv[u.i][u.j] = '1';\n\t\t\t}\n\t\t\tSystem.out.println(answer);\n\n\t\t\n\t\t}\n\t}\n\tstatic class Node{\n\t\tint i;\n\t\tint j;\n\n\t\tpublic Node(){\n\t\t\ti = 0;\n\t\t\tj = 0;\n\t\t}\n\t\tpublic Node(int i, int j){\n\t\t\tthis.i = i;\n\t\t\tthis.j = j;\n\t\t}\n\t\t/*\n\t\tpublic ArrayList<Node> getAdjacent(){\n\t\t\tArrayList<Node> list = new ArrayList<Node>();\n\t\t\tif (j-1 > 0){\n\t\t\t\tNode f = new Node(i, j -1);\t\n\t\t\t\tlist.add(f);\n\t\t\t}\n\t\t\telse if(j+1 < n){\n\t\t\t\tNode s = new Node(i, j+1);\n\t\t\t\tlist.add(s);\n\t\t\t}\n\t\t\telse if (j+k < n){\n\t\t\t\tNode t = new Node(i%2, j+k);\n\t\t\t\tlist.add(t);\n\t\t\t}\n\t\t\treturn list;\n\t\t}\n\t\t*/\n\t}\n}\n\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar a[3][1000000];\nlong long d[3][1000000];\nint used[3][1000000];\nint main() {\n  int n, m;\n  cin >> n >> m;\n  for (int i = 1; i <= 2; i++) {\n    for (int k = 1; k <= n; k++) {\n      cin >> a[i][k];\n    }\n  }\n  d[1][1] = 0;\n  used[1][1] = 1;\n  queue<pair<int, int> > q;\n  q.push({1, 1});\n  int w = 0;\n  while (!q.empty()) {\n    pair<int, int> t = q.front();\n    if (t.second >= n) {\n      cout << \"YES\";\n      return 0;\n    }\n    w = d[t.first][t.second];\n    q.pop();\n    if (t.second + 1 <= n && used[t.first][t.second + 1] == 0 &&\n        a[t.first][t.second + 1] != 'X') {\n      d[t.first][t.second + 1] = d[t.first][t.second] + 1;\n      q.push({t.first, t.second + 1});\n      used[t.first][t.second + 1] = 1;\n    }\n    if (t.second - 1 > 0 && used[t.first][t.second - 1] == 0 &&\n        t.second - 1 > w + 1 && a[t.first][t.second - 1] != 'X') {\n      d[t.first][t.second - 1] = d[t.first][t.second] + 1;\n      used[t.first][t.second - 1] = 1;\n      q.push({t.first, t.second - 1});\n    }\n    if (t.first == 1) {\n      if (used[t.first + 1][t.second + m] == 0 &&\n          a[t.first + 1][t.second + m] != 'X') {\n        if (t.second + m <= n) {\n          d[t.first + 1][t.second + m] = d[t.first][t.second] + 1;\n          used[t.first + 1][t.second + m] = 1;\n          q.push({t.first + 1, t.second + m});\n        } else {\n          d[t.first + 1][n] = d[t.first][t.second] + 1;\n          used[t.first + 1][n] = 1;\n          q.push({t.first + 1, n});\n        }\n      }\n    } else {\n      if (used[t.first - 1][t.second + m] == 0 &&\n          a[t.first - 1][t.second + m] != 'X') {\n        if (t.second + m <= n) {\n          d[t.first - 1][t.second + m] = d[t.first][t.second] + 1;\n          used[t.first - 1][t.second + m] = 1;\n          q.push({t.first - 1, t.second + m});\n        } else {\n          d[t.first - 1][n] = d[t.first][t.second] + 1;\n          used[t.first - 1][n] = 1;\n          q.push({t.first - 1, n});\n        }\n      }\n    }\n  }\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.awt.Point;\nimport java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\npublic class CFRound125_Div1_B implements Runnable {\n\n\tfinal boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer tok;\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new CFRound125_Div1_B(), \"\", 256 * (1L << 20)).start();\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tlong startTime = System.currentTimeMillis();\n\t\t\tif (ONLINE_JUDGE) {\n\t\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\tout = new PrintWriter(System.out);\n\t\t\t} else {\n\t\t\t\tin = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\t\tout = new PrintWriter(\"output.txt\");\n\t\t\t}\n\t\t\tLocale.setDefault(Locale.US);\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t\tlong freeMemory = Runtime.getRuntime().freeMemory();\n\t\t\tlong totalMemory = Runtime.getRuntime().totalMemory();\n\t\t\tlong endTime = System.currentTimeMillis();\n\t\t\tSystem.err.println(\"Time = \" + (endTime - startTime));\n\t\t\tSystem.err.println(\"Memory = \" + ((totalMemory - freeMemory) >> 10));\n\t\t} catch (Throwable t) {\n\t\t\tt.printStackTrace(System.err);\n\t\t\tSystem.exit(-1);\n\t\t}\n\t}\n\n\tString readString() throws IOException {\n\t\twhile (!tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tint readInt() throws IOException {\n\t\treturn Integer.parseInt(readString());\n\t}\n\n\tlong readLong() throws IOException {\n\t\treturn Long.parseLong(readString());\n\t}\n\n\tdouble readDouble() throws IOException {\n\t\treturn Double.parseDouble(readString());\n\t}\n\t\n\tvoid debug(Object... o) {\n\t\tif (!ONLINE_JUDGE) {\n\t\t\tSystem.err.println(Arrays.deepToString(o));\n\t\t}\n\t}\n\n\t/** http://pastebin.com/j0xdUjDn */\n\tstatic class Utils {\n\n\t\tprivate Utils() {}\n\n\t\tpublic static void mergeSort(int[] a) {\n\t\t\tmergeSort(a, 0, a.length - 1);\n\t\t}\n\n\t\tprivate static final int MAGIC_VALUE = 50;\n\n\t\tprivate static void mergeSort(int[] a, int leftIndex, int rightIndex) {\n\t\t\tif (leftIndex < rightIndex) {\n\t\t\t\tif (rightIndex - leftIndex <= MAGIC_VALUE) {\n\t\t\t\t\tinsertionSort(a, leftIndex, rightIndex);\n\t\t\t\t} else {\n\t\t\t\t\tint middleIndex = (leftIndex + rightIndex) / 2;\n\t\t\t\t\tmergeSort(a, leftIndex, middleIndex);\n\t\t\t\t\tmergeSort(a, middleIndex + 1, rightIndex);\n\t\t\t\t\tmerge(a, leftIndex, middleIndex, rightIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate static void merge(int[] a, int leftIndex, int middleIndex, int rightIndex) {\n\t\t\tint length1 = middleIndex - leftIndex + 1;\n\t\t\tint length2 = rightIndex - middleIndex;\n\t\t\tint[] leftArray = new int[length1];\n\t\t\tint[] rightArray = new int[length2];\n\t\t\tSystem.arraycopy(a, leftIndex, leftArray, 0, length1);\n\t\t\tSystem.arraycopy(a, middleIndex + 1, rightArray, 0, length2);\n\t\t\tfor (int k = leftIndex, i = 0, j = 0; k <= rightIndex; k++) {\n\t\t\t\tif (i == length1) {\n\t\t\t\t\ta[k] = rightArray[j++];\n\t\t\t\t} else if (j == length2) {\n\t\t\t\t\ta[k] = leftArray[i++];\n\t\t\t\t} else {\n\t\t\t\t\ta[k] = leftArray[i] <= rightArray[j] ? leftArray[i++] : rightArray[j++];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate static void insertionSort(int[] a, int leftIndex, int rightIndex) {\n\t\t\tfor (int i = leftIndex + 1; i <= rightIndex; i++) {\n\t\t\t\tint current = a[i];\n\t\t\t\tint j = i - 1;\n\t\t\t\twhile (j >= leftIndex && a[j] > current) {\n\t\t\t\t\ta[j + 1] = a[j];\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\ta[j + 1] = current;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// solution\n\t\n\tfinal int INF = 1000*1000*1000;\n\t\n\tboolean can = false;\n\t\n\tvoid solve() throws IOException {\n\t\tint n = readInt();\n\t\tint k = readInt();\n\t\tchar[][] a = new char[2][];\n\t\ta[0] = readString().toCharArray();\n\t\ta[1] = readString().toCharArray();\n\t\tint[][] d = new int[2][n];\n\t\tfor (int[] x : d) {\n\t\t\tArrays.fill(x, INF);\n\t\t}\n\t\td[0][0] = 0;\n\t\tQueue<Point> q = new ArrayDeque<Point>();\n\t\tq.add(new Point(0, 0));\n\t\twhile (!q.isEmpty()) {\n\t\t\tPoint p = q.poll();\n\t\t\tint wall = p.x;\n\t\t\tint height = p.y;\n\t\t\ttryMove(d, q, a, n, wall, height, wall, height-1);\n\t\t\ttryMove(d, q, a, n, wall, height, wall, height+1);\n\t\t\ttryMove(d, q, a, n, wall, height, 1-wall, height+k);\n\t\t\tif (can) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tout.println(can ? \"YES\" : \"NO\");\n\t}\n\n\tprivate void tryMove(int[][] d, Queue<Point> q, char[][] a, int n, int oldWall, int oldHeight, int newWall, int newHeight) {\n\t\tint waterLevel = d[oldWall][oldHeight];\n\t\tif (newHeight <= waterLevel) {\n\t\t\treturn;\n\t\t}\n\t\tif (newHeight >= n) {\n\t\t\tcan = true;\n\t\t\treturn;\n\t\t}\n\t\tif (a[newWall][newHeight] == '-') {\n\t\t\tif (d[newWall][newHeight] > d[oldWall][oldHeight] + 1) {\n\t\t\t\td[newWall][newHeight] = d[oldWall][oldHeight] + 1;\n\t\t\t\tq.add(new Point(newWall, newHeight));\n\t\t\t}\n\t\t}\n\t}\n\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class Solution {\n    \n   \n   static ArrayList<Integer>[] graph;\n   static  boolean[] isVis;\n   static int [] level;\n   static int [] parent;\n   static String f;\n   \n   \n   \n   static int  bfs(int source)\n   {\n       \n       isVis[source]=true;\n       level[source] =0;\n       parent[source] =-1;\n       \n       Queue<Integer>myQueue =new LinkedList<>();\n       myQueue.add(source);\n       \n       while(myQueue.isEmpty()==false)\n       {\n           int temp =myQueue.remove();\n           \n        \n           if(temp==2*f.length()||(temp==(2*f.length()-2)+1))\n           {\n               return temp;\n           }\n           \n           for(int child:graph[temp])\n           {\n               if(isVis[child]==false && (level[temp]+1)<(child+1)/2)\n               {\n                   isVis[child] =true;\n                   level[child] =level[temp]+1;\n                   myQueue.add(child);\n                   parent[child] =temp;\n               }\n               \n               \n           }\n           \n       }\n       \n       return source;\n       \n       \n      \n   }\n   \n   \n   \n   \n   public static void main(String [] args)\n   {\n       \n       Scanner in = new Scanner(System.in);\n       \n       int n =in.nextInt();\n       int k =in.nextInt();\n       graph =new ArrayList [2*n+2];\n       for(int i =0;i<=2*n+1;i++)\n       {\n           graph[i] =new ArrayList<>();\n       }\n       isVis =new boolean[2*n+2];\n        level =new int [2*n+2];\n        parent =new int[2*n+2];\n        f  =in.next();\n       String s  =in.next();\n       \n       for(int i =1;i<f.length();i++)\n       {\n           int j =i-1;\n              if(f.charAt(j)!='X')\n              {\n                  if(j-1>-1)\n                  {\n                      if(f.charAt(j-1)!='X')\n                      graph[2*(i-1)+1].add(2*(i-1-1)+1);\n                  }\n                  if(f.charAt(j+1)!='X')\n                      graph[2*(i-1)+1].add(2*(i+1-1)+1);\n                     \n                      if(j+k<s.length() && s.charAt(j+k)!='X')\n                      {\n                          graph[2*(i-1)+1].add(2*(i+k));\n                      }\n                      else if(j+k>=s.length()){\n                           graph[2*(i-1)+1].add(2*s.length());\n                      }\n              }\n       }\n       \n       for(int i =1;i<s.length();i++)\n       {\n           int j =i-1;\n           if(s.charAt(j)!='X')\n              {\n                  if(j-1>-1)\n                  {\n                      if(s.charAt(j-1)!='X')\n                      graph[2*(i)].add(2*(i-1));\n                  }\n                  if(s.charAt(j+1)!='X')\n                      graph[2*i].add(2*(i+1));\n                      \n                      if(j+k<f.length() && f.charAt(j+k)!='X')\n                      {\n                          graph[2*i].add(2*(i+k-1)+1);\n                      }\n                      else if(j+k>=f.length()){\n                          graph[2*i].add(2*(f.length()-1)+1);\n                      }\n              }\n       }\n       \n       int temp  =bfs(1);\n       \n      if(temp==2*f.length()||temp==((2*f.length()-2)+1))\n      {\n          System.out.println(\"YES\");\n          return;\n      }\n      \n       System.out.println(\"NO\");\n       \n   }\n    \n  \n}\n\t\n\t\n\t\n\n\t"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 1e5 + 100, MOD = 1e9 + 7;\nlong long n, m, k;\nmap<pair<long long, long long>, long long> check, cnt;\npair<long long, long long> ans;\nvector<pair<long long, long long> > g;\nstring s[2];\nstring BFS(pair<long long, long long> source) {\n  long long test = 0;\n  queue<pair<long long, long long> > q;\n  q.push(source);\n  cnt[source] = -1;\n  while (q.size()) {\n    pair<long long, long long> v = q.front();\n    q.pop();\n    long long a = v.first;\n    long long b = v.second;\n    if (a + k >= n) return \"YES\";\n    if (a + 1 < n && s[b][a + 1] != 'X') g.push_back({a + 1, b});\n    if (a >= 1 && s[b][a - 1] != 'X') g.push_back({a - 1, b});\n    if (a + k < n && s[b ^ 1][a + k] != 'X') g.push_back({a + k, b ^ 1});\n    for (pair<long long, long long> u : g) {\n      if (check.count(u) == 0 && u.first > cnt[v] + 1) {\n        q.push(u);\n        cnt[u] = cnt[v] + 1;\n        check[u] = 1;\n        if (u.first >= n) return \"YES\";\n      }\n    }\n    g.clear();\n  }\n  return \"NO\";\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  cin >> s[0] >> s[1];\n  cout << BFS({0, 0});\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.util.Map.Entry;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\t(new Main()).solve();\n\t}\n\n\tpublic void Main() {\n\t}\n\n\tvoid solve() throws IOException {\n\t\t// BufferedReader in = new BufferedReader(new\n\t\t// InputStreamReader(System.in));\n\t\t// Scanner in = new Scanner(System.in);\n\t\tMyReader in = new MyReader();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t// Scanner in = new Scanner(new FileReader(\"input.txt\"));\n\t\t// PrintWriter out = new PrintWriter(\"output.txt\");\n\t\tint n = in.nextInt();\n\t\tint k = in.nextInt();\n\t\tString[] a = new String[2];\n\t\tint[][] t = new int[2][n];\n\t\tArrayList<U> h = new ArrayList<U>();\n\t\ta[0] = in.readLine();\n\t\ta[1] = in.readLine();\n\t\tint[] dx = {0, 0, -1, 1};\n\t\tint[] dy = {-1, 1, k, k};\n\t\t\n\t\tboolean flag = false;\n\t\tif (a[0].charAt(0) == '-') {\n\t\t\th.add(new U(0,0));\n\t\t\tt[0][0] = 1;\n\t\t}\n\t\twhile (!flag && h.size() > 0) {\n\t\t\tU cur = h.get(0);\n\t\t\th.remove(0);\n\t\t\tint num = t[cur.x][cur.y];\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint x = cur.x + dx[i];\n\t\t\t\tint y = cur.y + dy[i];\n\t\t\t\tif (x == 0 || x == 1) {\n\t\t\t\t\tif (y >= n) {\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (y >= num && a[x].charAt(y) == '-' && t[x][y] == 0) {\n\t\t\t\t\t\tt[x][y] = num + 1;\n\t\t\t\t\t\th.add(new U(x, y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(flag?\"YES\":\"NO\");\n\t\t\n\t\tout.close();\n\t}\n\n};\n\nclass U {\n\tpublic int x;\n\tpublic int y;\n\tpublic U(int x, int y) {\n\t\tsuper();\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\t\n}\n\nclass MyReader {\n\tprivate BufferedReader in;\n\tString[] parsed;\n\tint index = 0;\n\n\tpublic MyReader() {\n\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\tpublic int nextInt() throws NumberFormatException, IOException {\n\t\tif (parsed == null || parsed.length == index) {\n\t\t\tread();\n\t\t}\n\t\treturn Integer.parseInt(parsed[index++]);\n\t}\n\n\tpublic long nextLong() throws NumberFormatException, IOException {\n\t\tif (parsed == null || parsed.length == index) {\n\t\t\tread();\n\t\t}\n\t\treturn Long.parseLong(parsed[index++]);\n\t}\n\n\tpublic String nextString() throws IOException {\n\t\tif (parsed == null || parsed.length == index) {\n\t\t\tread();\n\t\t}\n\t\treturn parsed[index++];\n\t}\n\n\tprivate void read() throws IOException {\n\t\tparsed = in.readLine().split(\" \");\n\t\tindex = 0;\n\t}\n\n\tpublic String readLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n};"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, s, h, v[1001000][2];\nchar l[2][1001000];\nbool valid(pair<int, int> p) {\n  return v[h][s] < p.second &&\n         (p.second > n ||\n          !v[p.second][p.first] && l[p.first][p.second - 1] == '-');\n}\nint main() {\n  cin >> n >> k >> l[0] >> l[1];\n  queue<pair<int, int>> q;\n  q.push({0, 1});\n  v[1][0] = 1;\n  while (!q.empty()) {\n    s = q.front().first, h = q.front().second;\n    if (h > n) break;\n    q.pop();\n    pair<int, int> d[3] = {{1 - s, h + k}, {s, h + 1}, {s, h - 1}};\n    for (int i = 0; i < 3; ++i)\n      if (valid(d[i])) v[d[i].second][d[i].first] = v[h][s] + 1, q.push(d[i]);\n  }\n  cout << (q.empty() ? \"NO\" : \"YES\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1000 * 100 + 10;\nbool valid[2][MAXN];\nvector<pair<int, int> > G[2][MAXN];\nint n, k;\nbool vis[2][MAXN];\nvector<pair<int, int> > B;\nint dis[2][MAXN];\nvoid make_G() {\n  for (int i = 0; i < n; i++) {\n    if (i - 1 >= 0 && valid[0][i - 1]) G[0][i].push_back(make_pair(0, i - 1));\n    if (i + 1 < n && valid[0][i + 1]) G[0][i].push_back(make_pair(0, i + 1));\n    if (i + k < n && valid[1][i + k]) G[0][i].push_back(make_pair(1, i + k));\n  }\n  for (int i = 0; i < n; i++) {\n    if (i - 1 >= 0 && valid[1][i - 1]) G[1][i].push_back(make_pair(1, i - 1));\n    if (i + 1 < n && valid[1][i + 1]) G[1][i].push_back(make_pair(1, i + 1));\n    if (i + k < n && valid[0][i + k]) G[1][i].push_back(make_pair(0, i + k));\n  }\n}\nbool bfs(int w, int u) {\n  memset(vis, false, sizeof vis);\n  B.resize(0);\n  B.push_back(make_pair(w, u));\n  dis[w][u] = 0;\n  int cnt = 0;\n  while (cnt < (int)B.size()) {\n    w = B[cnt].first;\n    u = B[cnt].second;\n    if (u + k >= n) return true;\n    for (int i = 0; i < (int)G[w][u].size(); i++) {\n      int w2 = G[w][u][i].first;\n      int u2 = G[w][u][i].second;\n      if (vis[w2][u2] == false && dis[w][u] + 1 < u2 + 1) {\n        vis[w2][u2] = true;\n        dis[w2][u2] = dis[w][u] + 1;\n        B.push_back(make_pair(w2, u2));\n      }\n    }\n    cnt++;\n  }\n  return false;\n}\nint main() {\n  cin >> n >> k;\n  memset(valid, true, sizeof valid);\n  for (int i = 0; i < n; i++) {\n    char c;\n    cin >> c;\n    if (c == 'X') valid[0][i] = false;\n  }\n  for (int i = 0; i < n; i++) {\n    char c;\n    cin >> c;\n    if (c == 'X') valid[1][i] = false;\n  }\n  make_G();\n  if (bfs(0, 0))\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, d[2][100005], q1[100005], q2[100005], x, y, st, en;\nchar s[2][100005];\nint main() {\n  cin >> n >> k;\n  cin >> s[0];\n  cin >> s[1];\n  d[0][0] = 1;\n  for (en = 1; st < en;) {\n    x = q1[st];\n    y = q2[st++];\n    if (y >= n - k) {\n      cout << \"YES\";\n      return 0;\n    }\n    if (s[x][y - 1] == '-' && d[x][y - 1] == 0 && y > 0 && y > d[x][y]) {\n      d[x][y - 1] = d[x][y] + 1;\n      q1[en] = x;\n      q2[en++] = y - 1;\n    }\n    if (s[x][y + 1] == '-' && d[x][y + 1] == 0) {\n      d[x][y + 1] = d[x][y] + 1;\n      q1[en] = x;\n      q2[en++] = y + 1;\n    }\n    if (s[1 - x][y + k] == '-' && d[1 - x][y + k] == 0) {\n      d[1 - x][y + k] = d[x][y] + 1;\n      q1[en] = 1 - x;\n      q2[en++] = y + k;\n    }\n  }\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar a[2][500005];\nint n, k;\nstruct node {\n  int x, y, cnt;\n};\nvoid work() {\n  int f = 0;\n  queue<node> q;\n  node t;\n  t.x = 0;\n  t.y = 0;\n  t.cnt = 0;\n  q.push(t);\n  while (!q.empty()) {\n    node c = q.front();\n    q.pop();\n    if (c.y >= n) {\n      f = 1;\n      printf(\"YES\\n\");\n      break;\n    }\n    t.x = c.x;\n    t.y = c.y + 1;\n    t.cnt = c.cnt + 1;\n    if (t.y >= 0 && a[t.x][t.y] != 'X') {\n      q.push(t);\n      a[t.x][t.y] = 'X';\n    }\n    t.y = c.y - 1;\n    if (t.y >= 0 && a[t.x][t.y] != 'X' && t.y >= t.cnt) {\n      q.push(t);\n      a[t.x][t.y] = 'X';\n    }\n    t.x = (c.x + 1) % 2;\n    t.y = c.y + k;\n    if (t.y >= 0 && a[t.x][t.y] != 'X') {\n      q.push(t);\n      a[t.x][t.y] = 'X';\n    }\n  }\n  if (!f) {\n    printf(\"NO\");\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  scanf(\"%s%s\", a[0], a[1]);\n  work();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1e9 + 7;\nint n, k;\nstring a[2];\nbool b[2][500010];\nvoid dfs(int whi, int pla, int water) {\n  if (b[whi % 2][pla]) return;\n  if (pla <= water) return;\n  if (a[whi % 2][pla] == 'X') return;\n  b[whi % 2][pla] = 1;\n  if (pla + k > n) {\n    puts(\"YES\");\n    exit(0);\n  }\n  dfs(whi + 1, pla + k, water + 1);\n  dfs(whi, pla - 1, water + 1);\n  dfs(whi, pla + 1, water + 1);\n}\nint main() {\n  cin >> n >> k >> a[0] >> a[1];\n  dfs(0, 0, -1);\n  puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstring wall[2];\nint n, k;\nint bfs(pair<int, int> start) {\n  vector<vector<int> > visited(n, vector<int>(2, -1));\n  for (int i = 1; i <= n; i++) {\n    for (int c = 0; c < 2; c++) {\n      if (wall[c][i] == 'X') {\n        visited[i][c] = -2;\n      }\n    }\n  }\n  queue<pair<int, int> > q;\n  visited[start.first][start.second] = 0;\n  q.push(start);\n  while (!q.empty()) {\n    int x = q.front().first;\n    int c = q.front().second;\n    q.pop();\n    if (x + k >= n) {\n      return true;\n    }\n    int water = visited[x][c];\n    if (x - 1 > water && visited[x - 1][c] == -1) {\n      visited[x - 1][c] = visited[x][c] + 1;\n      q.push(make_pair(x - 1, c));\n    }\n    if (visited[x + 1][c] == -1) {\n      visited[x + 1][c] = visited[x][c] + 1;\n      q.push(make_pair(x + 1, c));\n    }\n    if (visited[x + k][!c] == -1) {\n      visited[x + k][!c] = visited[x][c] + 1;\n      q.push(make_pair(x + k, !c));\n    }\n  }\n}\nint main() {\n  cin >> n >> k;\n  cin >> wall[0] >> wall[1];\n  if (bfs(make_pair(0, 0)) == 1) {\n    cout << \"YES\" << endl;\n  } else\n    cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid bfs(int n, int k, char p[2][100012]) {\n  int dist[2][100012];\n  int vis[2][100012];\n  queue<pair<int, int> > q;\n  dist[0][n] = dist[1][n] = 0x3f3f3f3f;\n  memset(vis, 0, sizeof(vis));\n  q.push(pair<int, int>(0, 0));\n  vis[0][0] = 1;\n  dist[0][0] = 0;\n  while (!q.empty()) {\n    pair<int, int> pos = q.front();\n    q.pop();\n    int c = pos.first, h = pos.second;\n    if (h + 1 >= n || h + k >= n) {\n      dist[0][n] = dist[1][n] == dist[c][h] + 1;\n      break;\n    }\n    if (!vis[c][h + 1] && p[c][h + 1] != 'X') {\n      q.push(pair<int, int>(c, h + 1));\n      dist[c][h + 1] = dist[c][h] + 1;\n      vis[c][h + 1] = 1;\n    }\n    if (h - 1 >= 0 && !vis[c][h - 1] && h - 1 > dist[c][h] &&\n        p[c][h - 1] != 'X') {\n      q.push(pair<int, int>(c, h - 1));\n      dist[c][h - 1] = dist[c][h] + 1;\n      vis[c][h - 1] = 1;\n    }\n    if (!vis[1 - c][h + k] && p[1 - c][h + k] != 'X') {\n      q.push(pair<int, int>(1 - c, h + k));\n      dist[1 - c][h + k] = dist[c][h] + 1;\n      vis[1 - c][h + k] = 1;\n    }\n  }\n  if (dist[0][n] <= n || dist[1][n] <= n)\n    printf(\"YES\\n\");\n  else\n    printf(\"NO\\n\");\n}\nint main() {\n  int n, k;\n  char p[2][100012];\n  scanf(\"%d %d %s %s\", &n, &k, p[0], p[1]);\n  bfs(n, k, p);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100005;\nint n, k;\nbool mp[2][maxn];\nstruct point {\n  int x, y, cnt;\n} head, p;\nqueue<point> q;\nvoid bfs() {\n  q.push((point){0, 1, 0});\n  mp[0][1] = 1;\n  while (!q.empty()) {\n    head = q.front();\n    q.pop();\n    p = head;\n    p.y--;\n    p.cnt++;\n    if (p.y > 0 && mp[p.x][p.y] == 0 && p.y > p.cnt) {\n      mp[p.x][p.y] = 1;\n      q.push(p);\n    }\n    p = head;\n    p.y++;\n    p.cnt++;\n    if (p.y > n) {\n      cout << \"YES\";\n      return;\n    }\n    if (mp[p.x][p.y] == 0) {\n      mp[p.x][p.y] = 1;\n      q.push(p);\n    }\n    p = head;\n    p.x = !head.x;\n    p.y += k;\n    p.cnt++;\n    if (p.y > n) {\n      cout << \"YES\";\n      return;\n    }\n    if (mp[p.x][p.y] == 0) {\n      mp[p.x][p.y] = 1;\n      q.push(p);\n    }\n  }\n  cout << \"NO\";\n}\nint main() {\n  memset(mp, 0, sizeof(mp));\n  cin >> n >> k;\n  for (int i = 0; i <= 1; i++) {\n    for (int j = 1; j <= n; j++) {\n      char c;\n      cin >> c;\n      if (c == 'X') mp[i][j] = 1;\n    }\n  }\n  bfs();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\n\n/**\n * @author Ivan Pryvalov (ivan.pryvalov@gmail.com)\n */\npublic class Codeforces12_Div2_D implements Runnable{\n\t\n\tclass Position{\n\t\tint side;//0 or 1\n\t\tint height;//0..n-1\n\t\tint time;//0 or more\n\t\tpublic Position(int side, int height, int time) {\n\t\t\tsuper();\n\t\t\tthis.side = side;\n\t\t\tthis.height = height;\n\t\t\tthis.time = time;\n\t\t}\n\t\t//requirement: height>=time\n\t\t\n\t\tpublic boolean isValid() {\n\t\t\treturn height>=0 && height>=time;\n\t\t}\n\t}\n\n\tint N;\n\tboolean[][] map;\n\tboolean reached = false;\n\t\n\tprivate void solve() throws IOException {\n\t\tint n = scanner.nextInt();\n\t\tint k = scanner.nextInt(); //10^5\n\n\t\tN = n;\n\t\tString s = scanner.nextLine();\n\t\t//true = OK\n\t\tboolean[] left = new boolean[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tleft[i] = s.charAt(i)=='-';\t\t\t\n\t\t}\n\t\ts = scanner.nextLine();\n\t\tboolean[] right = new boolean[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tright[i] = s.charAt(i)=='-';\t\t\t\n\t\t}\n\t\t\n\t\tmap = new boolean[][]{left, right};\n\t\t\n\t\tint[] c0 = new int[n];\n\t\tint[] c1 = new int[n];\n\t\tint[][] c = {c0, c1};\n\t\tfor (int[] ar: c) {\n\t\t\tArrays.fill(ar, Integer.MAX_VALUE);\t\t\t\n\t\t}\n\t\t\n\t\tComparator<Position> comparator = new Comparator<Position>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Position o1, Position o2) {\n\t\t\t\treturn o1.time - o2.time;\n\t\t\t}\n\t\t};\n\t\tPriorityQueue<Position> queue = new PriorityQueue<Position>(10, comparator);\n\t\tqueue.add(new Position(0,0,0));\n\t\t\n\t\tc[0][0] = 0;\n\t\twhile((!queue.isEmpty()) && !reached){\n\t\t\tPosition curPos = queue.remove();\n\t\t\tif (c[curPos.side][curPos.height] == curPos.time){\n\t\t\t\tPosition newPosUp = new Position(curPos.side, curPos.height+1, curPos.time+1);\n\t\t\t\tupdate(newPosUp, c, queue);\n\t\t\t\t\n\t\t\t\tPosition newPosDown = new Position(curPos.side, curPos.height-1, curPos.time+1);\n\t\t\t\tupdate(newPosDown, c, queue);\n\t\t\t\t\n\t\t\t\tPosition newPosJump = new Position(1-curPos.side, curPos.height+k, curPos.time+1);\n\t\t\t\tupdate(newPosJump, c, queue);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (reached){\n\t\t\tout.println(\"YES\");\n\t\t}else{\n\t\t\tout.println(\"NO\");\n\t\t}\n\t}\n\n\tprivate void update(Position newPos, int[][] c, PriorityQueue<Position> queue) {\n\t\tif (!newPos.isValid())\n\t\t\treturn;\n\t\tif (newPos.height >= N){\n\t\t\treached = true;\n\t\t\treturn;\n\t\t}\n\t\tif (map[newPos.side][newPos.height] && newPos.time < c[newPos.side][newPos.height]){\n\t\t\tc[newPos.side][newPos.height] = newPos.time;\n\t\t\tqueue.add(newPos);\n\t\t}\n\t}\n\n\t/////////////////////////////////////////////////\n\tfinal int BUF_SIZE = 1024 * 1024 * 8;//important to read long-string tokens properly\n\tfinal int INPUT_BUFFER_SIZE = 1024 * 1024 * 8 ;\n\tfinal int BUF_SIZE_INPUT = 1024;\n\t\n\tfinal int BUF_SIZE_OUT = 1024;\n\t\n\tboolean inputFromFile = false;\n\tString filenamePrefix = \"A-small-attempt0\";\n\tString inSuffix = \".in\";\n\tString outSuffix = \".out\";\n\t\n\t//InputStream bis;\n\t//OutputStream bos;\n\tPrintStream out;\n\tByteScanner scanner;\n\tByteWriter writer;\n\t\n\t@Override\n\tpublic void run() {\n\t\ttry{\n\t\t\tInputStream bis = null;\n\t\t\tOutputStream bos = null;\n\t\t\t//PrintStream out = null;\n\t\t\tif (inputFromFile){\n\t\t\t\tFile baseFile = new File(getClass().getResource(\"/\").getFile());\n\t\t\t\tbis = new BufferedInputStream(\n\t\t\t\t\t\tnew FileInputStream(new File(\n\t\t\t\t\t\t\t\tbaseFile, filenamePrefix+inSuffix)),\n\t\t\t\t\t\t\t\tINPUT_BUFFER_SIZE);\n\t\t\t\tbos = new BufferedOutputStream(\n\t\t\t\t\t\tnew FileOutputStream(\n\t\t\t\t\t\t\t\tnew File(baseFile, filenamePrefix+outSuffix)));\n\t\t\t\tout = new PrintStream(bos);\n\t\t\t}else{\n\t\t\t\tbis = new BufferedInputStream(System.in, INPUT_BUFFER_SIZE);\n\t\t\t\tbos = new BufferedOutputStream(System.out);\n\t\t\t\tout = new PrintStream(bos);\n\t\t\t}\n\t\t\tscanner = new ByteScanner(bis, BUF_SIZE_INPUT, BUF_SIZE);\n\t\t\twriter = new ByteWriter(bos, BUF_SIZE_OUT);\n\t\t\t\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t}catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\t\n\tpublic interface Constants{\n\t\tfinal static byte ZERO = '0';//48 or 0x30\n\t\tfinal static byte NINE = '9';\n\t\tfinal static byte SPACEBAR = ' '; //32 or 0x20\n\t\tfinal static byte MINUS = '-'; //45 or 0x2d\t\n\t\t\n\t\tfinal static char FLOAT_POINT = '.';\n\t}\n\t\n\tpublic static class EofException extends IOException{\n\t}\n\t\n\tpublic static class ByteWriter implements Constants {\n\t\t\n\t\tint bufSize = 1024;\n\t\tbyte[] byteBuf = new byte[bufSize];\n\t\tOutputStream os;\n\t\t\n\t\tpublic ByteWriter(OutputStream os, int bufSize){\n\t\t\tthis.os = os;\n\t\t\tthis.bufSize = bufSize;\n\t\t}\n\t\t\n\t\tpublic void writeInt(int num) throws IOException{\n\t         int byteWriteOffset = byteBuf.length;\n\t         if (num==0){\n\t        \t byteBuf[--byteWriteOffset] = ZERO;\n\t         }else{\n\t        \t int numAbs = Math.abs(num);\n\t        \t while (numAbs>0){\n\t        \t\t byteBuf[--byteWriteOffset] = (byte)((numAbs % 10) + ZERO);\n\t        \t\t numAbs /= 10;\n\t        \t }\n\t        \t if (num<0)\n\t        \t\t byteBuf[--byteWriteOffset] = MINUS;\n\t         }\n\t         os.write(byteBuf, byteWriteOffset, byteBuf.length - byteWriteOffset);\n\t\t}\n\t\t\n\t\t/**\n\t\t * Please ensure ar.length <= byteBuf.length!\n\t\t * \n\t\t * @param ar\n\t\t * @throws IOException\n\t\t */\n\t\tpublic void writeByteAr(byte[] ar) throws IOException{\n\t\t\tfor (int i = 0; i < ar.length; i++) {\n\t\t\t\tbyteBuf[i] = ar[i];\n\t\t\t}\n\t\t\tos.write(byteBuf,0,ar.length);\n\t\t}\n\t\t\n\t\tpublic void writeSpaceBar() throws IOException{\n\t\t\tbyteBuf[0] = SPACEBAR;\n\t\t\tos.write(byteBuf,0,1);\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static class ByteScanner implements Constants{\n\t\t\n\t\tInputStream is;\n\t\t\n\t\tpublic ByteScanner(InputStream is, int bufSizeInput, int bufSize){\n\t\t\tthis.is = is;\n\t\t\tthis.bufSizeInput = bufSizeInput;\n\t\t\tthis.bufSize = bufSize;\n\t\t\t\n\t\t\tbyteBufInput = new byte[this.bufSizeInput];\n\t\t\tbyteBuf = new byte[this.bufSize];\n\t\t}\n\t\t\n\t\tpublic ByteScanner(byte[] data){\n\t\t\tbyteBufInput = data;\n\t\t\tbufSizeInput = data.length;\n\t\t\tbufSize = data.length;\n\t\t\tbyteBuf = new byte[bufSize];\n\t\t\tbyteRead = data.length;\n\t\t\tbytePos = 0;\n\t\t}\n\t\t\n\t\tprivate int bufSizeInput;\n\t\tprivate int bufSize;\n\t\t\n\t\tbyte[] byteBufInput;\n\t\tbyte by=-1;\n\t\tint byteRead=-1;\n\t\tint bytePos=-1;\n\n\t\tbyte[] byteBuf;\n\t\tint totalBytes;\n\t\t\n\t\tboolean eofMet = false;\n\t\t\n\t\tprivate byte nextByte() throws IOException{\n\t\t\t\n\t\t\tif (bytePos<0 || bytePos>=byteRead){\n\t\t\t\tbyteRead = is==null? -1: is.read(byteBufInput);\n\t\t\t\tbytePos=0;\n\t\t\t\tif (byteRead<0){\n\t\t\t\t\tbyteBufInput[bytePos]=-1;//!!!\n\t\t\t\t\tif (eofMet)\n\t\t\t\t\t\tthrow new EofException();\n\t\t\t\t\teofMet = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn byteBufInput[bytePos++];\n\t\t}\n\t\t\n\t\t/**\n\t\t * Returns next meaningful character as a byte.<br>\n\t\t * \n\t\t * @return\n\t\t * @throws IOException\n\t\t */\n\t\tpublic byte nextChar() throws IOException{\n\t\t\twhile ((by=nextByte())<=0x20);\n\t\t\treturn by;\n\t\t}\n\t\t\n\t\t/**\n\t\t * Returns next meaningful character OR space as a byte.<br>\n\t\t * \n\t\t * @return\n\t\t * @throws IOException\n\t\t */\n\t\tpublic byte nextCharOrSpacebar() throws IOException{\n\t\t\twhile ((by=nextByte())<0x20);\n\t\t\treturn by;\n\t\t}\n\t\t\n\t    /**\n\t     * Reads line.\n\t     * \n\t     * @return\n\t     * @throws IOException\n\t     */\n\t    public String nextLine() throws IOException {\n            readToken((byte)0x20);\n            return new String(byteBuf,0,totalBytes);\n\t    }\n\t    \n\t    public byte[] nextLineAsArray() throws IOException {\n            readToken((byte)0x20);\n            byte[] out = new byte[totalBytes];\n            System.arraycopy(byteBuf, 0, out, 0, totalBytes);\n            return out;\n\t    }\n\t    \n\t\t\n\t    /**\n\t     * Reads token. Spacebar is separator char.\n\t     * \n\t     * @return\n\t     * @throws IOException\n\t     */\n\t    public String nextToken() throws IOException {\n            readToken((byte)0x21);\n            return new String(byteBuf,0,totalBytes);\n\t    }\n\t    \n\t    /**\n\t     * Spacebar is included as separator char\n\t     * \n\t     * @throws IOException\n\t     */\n\t    private void readToken() throws IOException {\t    \t\n            readToken((byte)0x21);\n\t    }\n\t    \n\t    private void readToken(byte acceptFrom) throws IOException {\n            totalBytes = 0;\n            while ((by=nextByte())<acceptFrom);\n            byteBuf[totalBytes++] = by;\n            while ((by=nextByte())>=acceptFrom){\n                byteBuf[totalBytes++] = by;\n            }\n\t    }\n\t\t\n\t    public int nextInt() throws IOException{\n\t\t\treadToken();\n\t\t\tint num=0, i=0;\n\t\t\tboolean sign=false;\n\t\t\tif (byteBuf[i]==MINUS){\n\t\t\t\tsign = true;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tfor (; i<totalBytes; i++){\n\t\t\t\tnum*=10;\n\t\t\t\tnum+=byteBuf[i]-ZERO;\n\t\t\t}\n\t\t\treturn sign?-num:num;\n\t\t}\n\t\t\n\t\tpublic long nextLong() throws IOException{\n\t\t\treadToken();\n\t\t\tlong num=0;\n\t\t\tint i=0;\n\t\t\tboolean sign=false;\n\t\t\tif (byteBuf[i]==MINUS){\n\t\t\t\tsign = true;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tfor (; i<totalBytes; i++){\n\t\t\t\tnum*=10;\n\t\t\t\tnum+=byteBuf[i]-ZERO;\n\t\t\t}\n\t\t\treturn sign?-num:num;\n\t\t}\n\t\t\n\t\t/*\n\t\t//TODO test Unix/Windows formats\n\t\tpublic void toNextLine() throws IOException{\n\t\t\twhile ((ch=nextChar())!='\\n');\n\t\t}\n\t\t*/\n\t\t\n\t\tpublic double nextDouble() throws IOException{\n\t\t\treadToken();\n\t\t\tchar[] token = new char[totalBytes];\n\t\t\tfor (int i = 0; i < totalBytes; i++) {\n\t\t\t\ttoken[i] = (char)byteBuf[i];\n\t\t\t}\n\t\t\treturn Double.parseDouble(new String(token));\n\t\t}\n\t    \n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Codeforces12_Div2_D().run();\n\t}\n\t\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.util.StringTokenizer;\nimport java.math.BigInteger;\nimport java.util.Queue;\nimport java.util.LinkedList;\nimport java.util.Collection;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tOutputWriter out = new OutputWriter(outputStream);\n\t\tTaskD solver = new TaskD();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskD {\n\n    static class state {\n        int row, col;\n        int waterlevel;\n\n        state(int row, int col, int waterlevel) {\n            this.row = row;\n            this.col = col;\n            this.waterlevel = waterlevel;\n        }\n    }\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n        int n = in.nextInt();\n        int k = in.nextInt();\n        boolean flag = false;\n        boolean[][] used = new boolean[2][100010];\n        char[][] s = IOUtils.readCharTable(in, 2);\n        Queue<state> q = new LinkedList<state>();\n        q.add(new state(0, 0, 0));\n        loop:\n        while (!q.isEmpty()) {\n            state cur = q.poll();\n            if (cur.col + k >= n) {\n                out.printLine(\"YES\");\n                flag = true;\n                break loop;\n            }\n            int nr = 0, nc = 0, w = 0;\n            for (int i = 0; i < 3; i++) {\n                switch (i) {\n                    case 0:  // up\n                        nr = cur.row;\n                        nc = cur.col + 1;\n                        w = cur.waterlevel;\n                        if (s[nr][nc] == 'X' || used[nr][nc]) continue;\n                        q.add(new state(nr, nc, w + 1));\n                        used[nr][nc] = true;\n                        break;\n                    case 1: // down\n                        nr = cur.row;\n                        nc = cur.col - 1;\n                        w = cur.waterlevel;\n                        if (nc <= w || s[nr][nc] == 'X') continue;\n                        if (used[nr][nc]) continue;\n                        q.add(new state(nr, nc, w + 1));\n                        used[nr][nc] = true;\n                        break;\n                    default:    //opposite\n                        nr = cur.row ^ 1;\n                        nc = cur.col + k;\n                        w = cur.waterlevel;\n                        if (s[nr][nc] == 'X' || used[nr][nc]) continue;\n                        q.add(new state(nr, nc, w + 1));\n                        used[nr][nc] = true;\n                        break;\n                }\n            }\n        }\n        if (!flag)\n            out.printLine(\"NO\");\n    }\n}\n\nclass InputReader {\n    BufferedReader reader;\n    StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\t}\n\nclass OutputWriter {\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n        writer = new PrintWriter(outputStream);\n    }\n\n    public OutputWriter(Writer writer) {\n        this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n        for (int i = 0; i < objects.length; i++) {\n            if (i != 0)\n                writer.print(' ');\n            writer.print(objects[i]);\n        }\n    }\n\n    public void printLine(Object... objects) {\n        print(objects);\n        writer.println();\n    }\n\n    public void close() {\n        writer.close();\n    }\n}\n\nclass IOUtils {\n\n    public static char[][] readCharTable(InputReader in, int rowCount) {\n        char[][] table = new char[rowCount][];\n        for (int i = 0; i < rowCount; i++)\n            table[i] = in.next().toCharArray();\n        return table;\n    }\n\n    }\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 7;\nconst int inf = 0x3f3f3f3f;\nstring L, R;\nint dist[2][maxn];\nqueue<int> q;\nint n, k;\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> n >> k;\n  cin >> L >> R;\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < n; j++) dist[i][j] = inf;\n  dist[0][0] = 0;\n  q.push(0);\n  q.push(0);\n  while (!q.empty()) {\n    int s = q.front();\n    q.pop();\n    int h = q.front();\n    q.pop();\n    int t = dist[s][h];\n    if (h + k >= n) {\n      cout << \"YES\" << endl;\n      return 0;\n    }\n    if ((s == 0 && L[h + 1] == '-') || (s == 1 && R[h + 1] == '-'))\n      if (dist[s][h + 1] == inf) {\n        dist[s][h + 1] = t + 1;\n        q.push(s);\n        q.push(h + 1);\n      }\n    if (h - 1 >= t + 1)\n      if ((s == 0 && L[h - 1] == '-') || (s == 1 && R[h - 1] == '-'))\n        if (dist[s][h - 1] == inf) {\n          dist[s][h - 1] = t + 1;\n          q.push(s);\n          q.push(h - 1);\n        }\n    if ((s == 0 && R[h + k] == '-') || (s == 1 && L[h + k] == '-'))\n      if (dist[1 - s][h + k] == inf) {\n        dist[1 - s][h + k] = t + 1;\n        q.push(1 - s);\n        q.push(h + k);\n      }\n  }\n  cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Node {\n  int x, y, z;\n};\nint n, m;\nchar a[5][1000005];\nint bfs() {\n  Node node;\n  queue<Node> q;\n  node.x = 0;\n  node.y = 0;\n  node.z = 0;\n  q.push(node);\n  while (!q.empty()) {\n    Node cur = q.front();\n    q.pop();\n    if (cur.y >= n - 1) return 1;\n    if (a[cur.x][cur.y + 1] != 'X' && cur.y + 1 > cur.z) {\n      a[cur.x][cur.y + 1] = 'X';\n      node.x = cur.x;\n      node.y = cur.y + 1;\n      node.z = cur.z + 1;\n      q.push(node);\n    }\n    if (a[cur.x][cur.y - 1] != 'X' && cur.y - 1 > cur.z) {\n      a[cur.x][cur.y - 1] = 'X';\n      node.x = cur.x;\n      node.y = cur.y - 1;\n      node.z = cur.z + 1;\n      q.push(node);\n    }\n    if (a[(cur.x + 1) % 2][cur.y + m] != 'X' && cur.y + m > cur.z) {\n      a[(cur.x + 1) % 2][cur.y + m] = 'X';\n      node.x = (cur.x + 1) % 2;\n      node.y = cur.y + m;\n      node.z = cur.z + 1;\n      q.push(node);\n    }\n  }\n  return 0;\n}\nint main() {\n  int i, j;\n  while (cin >> n >> m) {\n    memset(a, 'a', sizeof(a));\n    for (i = 0; i < 2; i++) {\n      for (j = 0; j < n; j++) cin >> a[i][j];\n    }\n    if (bfs())\n      printf(\"YES\\n\");\n    else\n      printf(\"NO\\n\");\n  }\n}\n"
        },
        {
            "language": 1,
            "solution": "from sys import stdin\n\nin_lines = stdin.readlines()\n\ndef int_values(line) :\n    return map( int, line.split(' ') )\n\nlines = map( lambda x:x.strip(), in_lines  )\n\nn, k = int_values(lines[0])\n\na = lines[1:]\ns = { (1,0) : 0 }\nq = [(1,0)]\n\nstart = -1\nfinish = 0\n\ndef generate(x, y) :\n    return filter( lambda p : p[0] > n or a[p[1]][p[0] - 1] == '-', [(x + 1, y), (x - 1, y), (x + k, 1 - y)] )\n        \nno = True\nwhile start < finish and q :\n    start += 1\n    x, y = q[start]\n    v = s[(x,y)]\n    if x > n :\n        print 'YES'\n        no = False\n        break\n    for xn, yn in generate(x, y) :\n        try :\n            s[(xn, yn)]\n        except KeyError :\n            if v + 1 < xn :\n                s[(xn, yn)] = v + 1\n                q.append((xn, yn))\n                finish += 1\n                \nif no : print 'NO'\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N, K;\nchar l[200010], r[200010];\nint d[200010][2];\nbool fr[200010][2];\nqueue<pair<int, int> > qu;\nchar s[200010][2];\nint main() {\n  scanf(\"%d %d\\n %s\\n %s\", &N, &K, l, r);\n  for (int i = 0; i < N; ++i) {\n    s[i][0] = l[i];\n    s[i][1] = r[i];\n    fr[i][0] = fr[i][1] = true;\n  }\n  qu.push(make_pair(0, 0));\n  d[0][0] = -1;\n  while (!qu.empty()) {\n    int x = qu.front().first, pl = qu.front().second;\n    qu.pop();\n    int now = d[x][pl];\n    if (x + K >= N) {\n      cout << \"YES\";\n      return 0;\n    }\n    if (fr[x + 1][pl] && s[x + 1][pl] != 'X' && now + 1 < x + 1) {\n      fr[x + 1][pl] = false;\n      qu.push(make_pair(x + 1, pl));\n      d[x + 1][pl] = d[x][pl] + 1;\n    }\n    if (fr[x - 1][pl] && s[x - 1][pl] != 'X' && now + 1 < x - 1) {\n      fr[x - 1][pl] = false;\n      qu.push(make_pair(x - 1, pl));\n      d[x - 1][pl] = d[x][pl] + 1;\n    }\n    if (fr[x + K][1 - pl] && s[x + K][1 - pl] != 'X' && now + 1 < x + K) {\n      fr[x + K][1 - pl] = false;\n      qu.push(make_pair(x + K, 1 - pl));\n      d[x + K][1 - pl] = d[x][pl] + 1;\n    }\n  }\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\n// Jumping on Walls\n// 2012/6/23\npublic class P198B{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\n\tint n, k;\n\tint[][] a;\n\n\tvoid run(){\n\t\tn=sc.nextInt();\n\t\tk=sc.nextInt();\n\t\ta=new int[n+1][2];\n\t\tfor(int j=0; j<2; j++){\n\t\t\tString s=sc.next();\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\ta[i][j]=s.charAt(i)=='-'?0:1;\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n\n\tint[][] d;\n\n\tvoid solve(){\n\t\td=new int[n+1][2];\n\t\tfor(int i=0; i<=n; i++){\n\t\t\tfill(d[i], INF);\n\t\t}\n\t\tPriorityQueue<P> que=new PriorityQueue<P>();\n\t\tque.offer(new P(0, 0, 0));\n\t\td[0][0]=0;\n\t\tfor(; !que.isEmpty();){\n\t\t\tP p=que.poll();\n\t\t\tif(p.d>d[p.h][p.w]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tP q;\n\t\t\tif(p.h>0){\n\t\t\t\tq=new P(p.h-1, p.w, p.d+1);\n\t\t\t\tif(ok(q)){\n\t\t\t\t\tque.offer(q);\n\t\t\t\t\td[q.h][q.w]=q.d;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq=new P(p.h+1, p.w, p.d+1);\n\t\t\tq.h=min(q.h, n);\n\t\t\tif(ok(q)){\n\t\t\t\tque.offer(q);\n\t\t\t\td[q.h][q.w]=q.d;\n\t\t\t}\n\t\t\tq=new P(p.h+k, 1-p.w, p.d+1);\n\t\t\tq.h=min(q.h, n);\n\t\t\tif(ok(q)){\n\t\t\t\tque.offer(q);\n\t\t\t\td[q.h][q.w]=q.d;\n\t\t\t}\n\t\t}\n\t\tif(d[n][0]==INF&&d[n][1]==INF){\n\t\t\tprintln(\"NO\");\n\t\t}else{\n\t\t\tprintln(\"YES\");\n\t\t}\n\t}\n\n\tboolean ok(P p){\n\t\tif(a[p.h][p.w]==0&&p.d<d[p.h][p.w]&&p.d<=p.h){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tclass P implements Comparable<P>{\n\t\tint h, w, d;\n\n\t\tP(int h, int w, int d){\n\t\t\tthis.h=h;\n\t\t\tthis.w=w;\n\t\t\tthis.d=d;\n\t\t}\n\n\t\tpublic int compareTo(P p){\n\t\t\treturn d-p.d;\n\t\t}\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tLocale.setDefault(Locale.US);\n\t\tnew P198B().run();\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nstring s[2];\nbool visited[200001][2];\nbool bfs(int no) {\n  queue<pair<pair<int, int>, int> > q;\n  q.push({{no, 0}, 0});\n  visited[no][0] = 1;\n  while (!q.empty()) {\n    pair<int, int> num = q.front().first;\n    int lev = q.front().second;\n    if (num.first >= n) return 1;\n    q.pop();\n    if (!visited[num.first + 1][num.second] &&\n        s[num.second][num.first + 1] == '-') {\n      visited[num.first + 1][num.second] = 1;\n      q.push({{num.first + 1, num.second}, lev + 1});\n      if (num.first + 1 >= n) return 1;\n    }\n    if (num.first > 0 && !visited[num.first - 1][num.second] &&\n        s[num.second][num.first - 1] == '-' && num.first - 1 > lev) {\n      visited[num.first - 1][num.second] = 1;\n      q.push({{num.first - 1, num.second}, lev + 1});\n    }\n    if (!visited[num.first + k][1 - num.second] &&\n        s[1 - num.second][num.first + k] == '-') {\n      visited[num.first + k][1 - num.second] = 1;\n      q.push({{num.first + k, 1 - num.second}, lev + 1});\n      if (num.first + k >= n) return 1;\n    }\n  }\n  return 0;\n}\nint main() {\n  iostream::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cin >> n >> k;\n  cin >> s[0] >> s[1];\n  string str = \"\";\n  for (long long i = (0); i < (100001); ++i) str += '-';\n  s[0] += str;\n  s[1] += str;\n  memset(visited, 0, sizeof(visited));\n  if (bfs(0) == 1)\n    cout << \"YES\";\n  else\n    cout << \"NO\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 100;\nint n, m;\nchar a[2][maxn];\nbool vis[2][maxn];\nstruct node {\n  int x, pos;\n  int water;\n} e, u, st;\nbool bfs() {\n  st.x = 1;\n  st.pos = 0;\n  st.water = 0;\n  vis[st.pos][st.x] = true;\n  queue<node> que;\n  que.push(st);\n  while (!que.empty()) {\n    u = que.front();\n    que.pop();\n    e.pos = u.pos;\n    e.x = u.x - 1;\n    e.water = u.water + 1;\n    if (e.x > 0 && e.x > e.water && a[e.pos][e.x] != 'X' && !vis[e.pos][e.x]) {\n      que.push(e);\n      vis[e.pos][e.x] = true;\n    }\n    e.x = u.x + 1;\n    if (e.x > n) return true;\n    if (e.x > 0 && e.x > e.water && a[e.pos][e.x] != 'X' && !vis[e.pos][e.x]) {\n      que.push(e);\n      vis[e.pos][e.x] = true;\n    }\n    e.x = u.x + m;\n    if (e.x > n) return true;\n    if (e.pos)\n      e.pos = 0;\n    else\n      e.pos = 1;\n    if (e.x > 0 && e.x > e.water && a[e.pos][e.x] != 'X' && !vis[e.pos][e.x]) {\n      que.push(e);\n      vis[e.pos][e.x] = true;\n    }\n  }\n  return 0;\n}\nint main() {\n  while (~scanf(\"%d %d\", &n, &m)) {\n    cin >> a[0] + 1 >> a[1] + 1;\n    if (bfs())\n      cout << \"YES\" << endl;\n    else\n      cout << \"NO\" << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 200;\nint n, k;\nchar a[2][N];\nbool b[2][N];\nbool dfs(bool side, int h, int step) {\n  if (h > n) return 1;\n  if (b[side][h] || a[side][h] == 'X' || h < step) return 0;\n  b[side][h] = 1;\n  return dfs(side ^ 1, h + k, step + 1) || dfs(side, h - 1, step + 1) ||\n         dfs(side, h + 1, step + 1);\n}\nint main() {\n  cin >> n >> k;\n  scanf(\"%s %s\", a[0] + 1, a[1] + 1);\n  if (dfs(0, 1, 1))\n    cout << \"YES\";\n  else\n    cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "if __name__ == '__main__':\n    n , k = [int(i) for i in raw_input().split(' ')]\n    l = (list(raw_input()), list(raw_input()))\n    \n    (x, y) = (0, 0)\n    w = 0\n\n    st = [(0, 0)]\n\n    acts = [lambda x, y:(1 if x == 0 else 0, y + k), \n            lambda x, y:(x, y + 1), \n            lambda x, y:(x, y - 1)]\n\n    while True:\n        nst = []\n        for s in st:\n            for act in acts:\n                tx, ty = act(*s)\n                if ty >= n:\n                    print 'YES'\n                    exit()\n                if ty > w:\n                    if l[tx][ty] != 'X':\n                        l[tx][ty] = 'X'\n                        nst.append((tx, ty))\n                l[s[0]][s[1]] = 'X'\n\n        if len(nst) == 0:\n            print 'NO'\n            exit()\n        st = nst\n        w += 1\n    \n        \n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\n\n\npublic class Solution {\n  public static void main(String[] args) throws Exception {\n    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n    String[] nk = reader.readLine().split(\" \");\n    int n = Integer.parseInt(nk[0]);\n    int k = Integer.parseInt(nk[1]);\n\n    String left = reader.readLine();\n    String right = reader.readLine();\n\n    LinkedList<State> queue = new LinkedList<>();\n    Set<State> visited = new HashSet<>();\n\n    State start = new State(true, 0);\n    queue.add(start);\n    visited.add(start);\n    int turnNumber = 0;\n\n    while (!queue.isEmpty()) {\n      LinkedList<State> newQueue = new LinkedList<>();\n      while (!queue.isEmpty()) {\n        State state = queue.poll();\n        if (state.index + Math.max(1, k) >= n) {\n          System.out.println(\"YES\");\n          return;\n        }\n        State candidate;\n        candidate = new State(!state.leftWall, state.index + k);\n        if (valid(candidate, left, right, turnNumber) && !visited.contains(candidate)) {\n          newQueue.add(candidate);\n          visited.add(candidate);\n        }\n        candidate = new State(state.leftWall, state.index + 1);\n        if (valid(candidate, left, right, turnNumber) && !visited.contains(candidate)) {\n          newQueue.add(candidate);\n          visited.add(candidate);\n        }\n        candidate = new State(state.leftWall, state.index - 1);\n        if (valid(candidate, left, right, turnNumber) && !visited.contains(candidate)) {\n          newQueue.add(candidate);\n          visited.add(candidate);\n        }\n      }\n      queue = newQueue;\n      turnNumber++;\n    }\n    System.out.println(\"NO\");\n\n  }\n\n  static boolean valid(State state, String left, String right, int turnNumber) {\n    return state.index > turnNumber && (state.leftWall ? left : right).charAt(state.index) == '-';\n  }\n\n  static class State {\n    boolean leftWall;\n    int index;\n\n    public State(boolean leftWall, int index) {\n      this.leftWall = leftWall;\n      this.index = index;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n        return false;\n      }\n      State state = (State) o;\n      return leftWall == state.leftWall && index == state.index;\n    }\n\n    @Override\n    public int hashCode() {\n      return Objects.hash(leftWall, index);\n    }\n  }\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nT abs(T a) {\n  return a < 0 ? -a : a;\n}\ntemplate <typename T>\nT sqr(T a) {\n  return a * a;\n}\nconst int INF = (int)1e9;\nconst long double EPS = 1e-9;\nconst long double PI = 3.1415926535897932384626433832795;\nconst int N = 200000;\nint dx[] = {0, 0, 1};\nint dy[] = {1, -1, 1};\nint n, m;\nint d[2][N];\nchar f[2][N];\nint main() {\n  cin >> n >> m;\n  dy[2] = m;\n  for (int i = 0; i < int(2); ++i) {\n    scanf(\" %s\", f[i]);\n  }\n  memset(d, -1, sizeof(d));\n  queue<pair<int, int> > q;\n  q.push(pair<int, int>(0, 0));\n  d[0][0] = 0;\n  while (!q.empty()) {\n    pair<int, int> v = q.front();\n    q.pop();\n    if (d[v.first][v.second] > v.second) continue;\n    for (int i = 0; i < int(3); ++i) {\n      pair<int, int> u(v.first ^ dx[i], v.second + dy[i]);\n      if (u.second >= n) {\n        puts(\"YES\");\n        return 0;\n      }\n      if (u.second < 0 || f[u.first][u.second] == 'X') continue;\n      if (d[u.first][u.second] == -1) {\n        d[u.first][u.second] = d[v.first][v.second] + 1;\n        q.push(u);\n      }\n    }\n  }\n  puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, sp[2][100010], w[100010];\nchar grid[2][100010];\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, k, k};\nbool done(int y) { return y + 1 >= n || y + k >= n; }\nbool valid(int x, int y, int dist) {\n  return x >= 0 && x < 2 && y >= 0 && y < n && grid[x][y] != 'X' && dist < w[y];\n}\nint bfs() {\n  queue<pair<int, int> > q;\n  q.push(make_pair(0, 0));\n  while (!q.empty()) {\n    int x = q.front().first, y = q.front().second;\n    q.pop();\n    if (done(y))\n      return puts(\"YES\");\n    else {\n      for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if (valid(nx, ny, sp[x][y] + 1) && sp[nx][ny] == (int)1e9) {\n          q.push(make_pair(nx, ny));\n          sp[nx][ny] = sp[x][y] + 1;\n        }\n      }\n    }\n  }\n  return puts(\"NO\");\n}\nint main() {\n  scanf(\"%d %d\", &n, &k);\n  dy[2] = dy[3] = k;\n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < n; j++) cin >> grid[i][j];\n  }\n  for (int i = 1; i <= n; i++) w[i] = i + 1, sp[0][i] = sp[1][i] = (int)1e9;\n  bfs();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class D {\n    public static void main(String[] args) throws FileNotFoundException {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int k = in.nextInt();\n        String a1 = in.next();\n        String a2 = in.next();\n        Queue<state> q = new LinkedList<state>();\n        q.add(new state(0, 0, 0));\n        state cur;\n        int len, at, time;\n        boolean[][] v = new boolean[2][n];\n        while (!q.isEmpty()) {\n            cur = q.poll();\n            len = cur.len;\n            time = cur.time;\n            at = cur.at;\n            if ((time - 1) >= len || len < 0)\n                continue;\n            if (len >= n) {\n                System.out.println(\"YES\");\n                System.exit(0);\n            }\n            if (v[at][len])\n                continue;\n            v[at][len] = true;\n            if ((at == 0 && a1.charAt(len) == 'X')\n                    || (at == 1 && a2.charAt(len) == 'X'))\n                continue;\n            q.add(new state(len + 1, at, time + 1));\n            q.add(new state(len - 1, at, time + 1));\n            q.add(new state(len + k, 1 - at, time + 1));\n\n        }\n        System.out.println(\"NO\");\n    }\n\n    static class state {\n        // at 0 left 1 right\n        int len, at, time;\n\n        public state(int len, int at, int time) {\n            this.len = len;\n            this.at = at;\n            this.time = time;\n        }\n\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, d[2][1000100], qst, qen, qa[1000100], qb[1000100];\nchar s[2][1000100];\nvoid add(int x, int y, int t) {\n  if (y > n) {\n    puts(\"YES\");\n    exit(0);\n  }\n  if (y < 0 || d[x][y] || s[x][y] == 'X') {\n    return;\n  }\n  d[x][y] = t;\n  if (y >= t) {\n    qa[qen] = x;\n    qb[qen++] = y;\n  }\n}\nint main() {\n  cin >> n >> k;\n  cin >> s[0] >> s[1];\n  add(0, 0, 0);\n  int x, y, t;\n  while (qst < qen) {\n    x = qa[qst];\n    y = qb[qst++];\n    t = d[x][y] + 1;\n    add(1 - x, y + k, t);\n    add(x, y + 1, t);\n    add(x, y - 1, t);\n  }\n  puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstring mapa[2];\nint d[2][100005];\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\nint w, n, k;\nbool can = false, vis[2][100005];\nint dfs(int x, int y, int l) {\n  vis[x][y] = true;\n  for (int i = 0; i < 4; i++) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if (nx >= 0 && nx < 2) {\n      if (ny >= n) {\n        can = true;\n        return 0;\n      }\n      if (ny > l && mapa[nx][ny] == '-' && !vis[nx][ny]) dfs(nx, ny, l + 1);\n    }\n  }\n}\nint main() {\n  string aux;\n  scanf(\"%d %d\\n\", &n, &k);\n  getline(cin, mapa[0]);\n  getline(cin, mapa[1]);\n  dy[0] = dy[1] = k;\n  dfs(0, 0, 0);\n  if (can)\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar str1[100008];\nchar str2[100008];\nmap<pair<int, char>, bool> visited;\nlist<pair<pair<int, char>, int> > q;\nbool flag = 0;\nint wc, cur;\nvoid bfs(int n, int k) {\n  wc = 0;\n  pair<pair<int, char>, int> tmp;\n  cur = 1 - 1;\n  visited[make_pair(0, 'l')] = 1;\n  q.push_back(make_pair(make_pair(1 - 1, 'l'), 0));\n  while (!q.empty()) {\n    tmp = *(q.begin());\n    q.pop_front();\n    if (tmp.first.second == 'l') {\n      if (tmp.first.first + k >= n) {\n        flag = 1;\n        return;\n      }\n      if (!visited[make_pair(tmp.first.first + k, 'r')] &&\n          str2[tmp.first.first + k] == '-') {\n        visited[make_pair(tmp.first.first + k, 'r')] = true;\n        q.push_back(\n            make_pair(make_pair(tmp.first.first + k, 'r'), tmp.second + 1));\n      }\n      if (!visited[make_pair(tmp.first.first + 1, 'l')] &&\n          str1[tmp.first.first + 1] == '-') {\n        visited[make_pair(tmp.first.first + 1, 'l')] = true;\n        q.push_back(\n            make_pair(make_pair(tmp.first.first + 1, 'l'), tmp.second + 1));\n      }\n      if (!visited[make_pair(tmp.first.first - 1, 'l')] &&\n          tmp.first.first - 1 > tmp.second &&\n          str1[tmp.first.first - 1] == '-') {\n        visited[make_pair(tmp.first.first - 1, 'l')] = true;\n        q.push_back(\n            make_pair(make_pair(tmp.first.first - 1, 'l'), tmp.second + 1));\n      }\n    } else if (tmp.first.second == 'r') {\n      if (tmp.first.first + k >= n) {\n        flag = 1;\n        return;\n      }\n      if (!visited[make_pair(tmp.first.first + k, 'l')] &&\n          str1[tmp.first.first + k] == '-') {\n        visited[make_pair(tmp.first.first + k, 'l')] = true;\n        q.push_back(\n            make_pair(make_pair(tmp.first.first + k, 'l'), tmp.second + 1));\n      }\n      if (!visited[make_pair(tmp.first.first + 1, 'r')] &&\n          str2[tmp.first.first + 1] == '-') {\n        visited[make_pair(tmp.first.first + 1, 'r')] = true;\n        q.push_back(\n            make_pair(make_pair(tmp.first.first + 1, 'r'), tmp.second + 1));\n      }\n      if (!visited[make_pair(tmp.first.first - 1, 'r')] &&\n          tmp.first.first - 1 > tmp.second &&\n          str2[tmp.first.first - 1] == '-') {\n        visited[make_pair(tmp.first.first - 1, 'r')] = true;\n        q.push_back(\n            make_pair(make_pair(tmp.first.first - 1, 'r'), tmp.second + 1));\n      }\n    }\n  }\n}\nint main() {\n  int i, j, k, t, n, m;\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &k);\n  cin >> str1;\n  cin >> str2;\n  flag = 0;\n  bfs(n, k);\n  if (flag == 1) {\n    printf(\"YES\\n\");\n    return 0;\n  } else {\n    printf(\"NO\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Main implements Runnable {\n\t\t\n\tpublic void solve() throws IOException {\n\t\tint N = nextInt();\n                int K = nextInt();\n                char[][] grid = new char[2][N];\n                int[][] d = new int[2][N];\n                Arrays.fill(d[0], -1);\n                Arrays.fill(d[1], -1);\n                grid[0] = nextToken().toCharArray();\n                grid[1] = nextToken().toCharArray();\n                \n                Queue<Integer> q = new LinkedList<>();\n                q.add(0); q.add(0);\n                d[0][0] = 0;\n                \n                while(!q.isEmpty()){\n                        int k = q.poll();\n                        int h = q.poll();\n                        \n                                if(h + K >= N){\n                                        System.out.println(\"YES\");\n                                        return;\n                                }\n                        \n                                //jump up\n                                       if((k == 0 && grid[k][h + 1] == '-') || (k == 1 && grid[k][h + 1] == '-'))\n                                               if(d[k][h + 1] == -1){//if the state is not yet reached\n                                                       d[k][h + 1] = d[k][h] + 1;\n                                                       q.add(k);\n                                                       q.add(h + 1);\n                                                       //System.out.println(\"up \" +k + \" \" + (h + 1));\n                                               }\n                                //jump down\n                                       if(h - 1 >= 0 && h - 1 > d[k][h])\n                                        if((k == 0 && grid[k][h - 1] == '-') || (k == 1 && grid[k][h - 1] == '-'))\n                                               if(d[k][h - 1] == -1){//if the state is not yet reached\n                                                       d[k][h - 1] = d[k][h] + 1;\n                                                       q.add(k);\n                                                       q.add(h - 1);\n                                                       //System.out.println(\"down \" +k + \" \" + (h - 1));\n                                               }\n                                //jump K\n                                        k = 1 - k;\n                                        if(grid[k][h + K] == '-')\n                                                if(d[k][h + K] == -1){\n                                                        d[k][h + K] = d[1 - k][h] + 1;\n                                                        q.add(k);\n                                                        q.add(h + K);\n                                                        //System.out.println(\"k \" +k + \" \" + (h + K));\n                                                }\n               \n                                       \n                }\n                System.out.println(\"NO\");\n\t}\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t//-----------------------------------------------------------\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\ttok = null;\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t} catch (IOException e) {\n\t\t\tSystem.exit(0);\n\t\t}\n\t}\n\n\tpublic String nextToken() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tpublic long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tpublic double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tBufferedReader in;\n\tStringTokenizer tok;\n}"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.io.*;\nimport java.util.Arrays;\n\npublic class wallJump {\n\n\tprivate int visited[][];\n\tprivate char wall[][];\n\tprivate int m; //length of the wall\n\tprivate int n; //ninja jumps\n\tprivate int Qx[];\n\tprivate int Qy[];\n\tboolean flag = false;\n\tint head = 1, tail = 0;\n\tpublic void check(int x, int y, int z)\n\t{\n\t\tif(x < z)\n\t\t\treturn;\n\t\tif(x >= m)\n\t\t{\n\t\t\tflag = true;\n\t\t\treturn;\n\t\t}\n\t\tif(visited[x][y] != -1)\n\t\t\treturn;\n\t\tif(wall[y][x] == 'X')\n\t\t\treturn;\n\t\tvisited[x][y] = z;\n\t\tQx[head] = x;\n\t\tQy[head] = y;\n\t\thead ++;\n\t}\n\tpublic boolean bfs()\n\t{\n\t\tvisited[0][0] = 0;\n\t\twhile(tail < head)\n\t\t{\n\t\t\tint x = Qx[tail], y = Qy[tail];\n\t\t\ttail ++;\n\t\t\tint step = visited[x][y] + 1;\n\t\t\tcheck(x - 1, y, step);\n\t\t\tcheck(x + 1, y, step);\n\t\t\tcheck(x + n, y^1, step);\n\t\t\tif(flag)\n\t\t\t\treturn flag;\n\t\t}\n\t\treturn flag;\n\t}\n\tpublic void input() throws IOException\n\t{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString argument, in;\n\t\targument = br.readLine();\n\t\tString []arg = argument.split(\" \");\n\t\tm = Integer.parseInt(arg[0]);\n\t\tn = Integer.parseInt(arg[1]);\n\t\tvisited = new int[m][2];\n\t\twall = new char[2][m];\n\t\targument = br.readLine();\n\t\tfor(int i = 0; i < m; i ++)\n\t\t\twall[0][i] = argument.charAt(i);\n\t\targument = br.readLine();\n\t\tfor(int i = 0; i < m; i ++)\n\t\t{\n\t\t\twall[1][i] = argument.charAt(i);\n\t\t\tArrays.fill(visited[i], -1);\n\t\t}\n\t\tQx = new int[m * 2];\n\t\tQy = new int[m * 2];\n\t\tArrays.fill(Qx, 0);\n\t\tArrays.fill(Qy, 0);\n\t\tbr.close();\n\t}\n\tpublic static void main(String[] args) throws IOException{\n\t\twallJump main = new wallJump();\n\t\tmain.input();\n\t\tboolean result = main.bfs();\n\t\tif(result)\n\t\t\tSystem.out.println(\"YES\");\n\t\telse\n\t\t\tSystem.out.println(\"NO\");\n\t}\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct point {\n  int y, x, step;\n};\nconst int INF = (int)2e9;\nconst int MAXN = 100000;\nchar field[MAXN][2];\nint was[MAXN][2];\nbool can = false;\nint n, k;\nqueue<point> q;\nvoid go(int y, int x, int step, int dy, int dx) {\n  int ny = y + dy, nx = (x + dx) % 2, nstep = step + 1;\n  if (ny >= n) {\n    can = true;\n    return;\n  }\n  if (can || ny < 0 || ny < nstep || field[ny][nx] == 'X' ||\n      was[ny][nx] <= nstep)\n    return;\n  else {\n    point p;\n    p.y = ny, p.x = nx, p.step = nstep;\n    q.push(p);\n    was[ny][nx] = nstep;\n  }\n}\nvoid bfs() {\n  int y, x, step;\n  point p;\n  go(0, 0, -1, 0, 0);\n  while (!q.empty() && !can) {\n    p = q.front();\n    q.pop();\n    y = p.y, x = p.x, step = p.step;\n    go(y, x, step, 1, 0);\n    go(y, x, step, -1, 0);\n    go(y, x, step, k, 1);\n  }\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 0; i < n; ++i) {\n    cin >> field[i][0];\n    was[i][0] = was[i][1] = INF;\n  }\n  for (int i = 0; i < n; ++i) cin >> field[i][1];\n  bfs();\n  cout << (can ? \"YES\" : \"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxN = 1e5 + 5;\nint vis[2][maxN], n, k;\nvector<string> a(2);\nbool isSafe(int x, int y, int l) {\n  bool ok = (x >= 0 && x < 2 && y >= 0 && y < n && a[x][y] == '-' &&\n             vis[x][y] == 0 && y > l);\n  return ok;\n}\nvoid dfs(int x, int y, int l) {\n  if (y + k >= n) {\n    cout << \"YES\\n\";\n    exit(0);\n  }\n  vis[x][y] = 1;\n  if (isSafe(x ^ 1, y + k, l + 1)) {\n    dfs(x ^ 1, y + k, l + 1);\n  }\n  if (isSafe(x, y + 1, l + 1)) {\n    dfs(x, y + 1, l + 1);\n  }\n  if (isSafe(x, y - 1, l + 1)) {\n    dfs(x, y - 1, l + 1);\n  }\n  return;\n}\nvoid solve() {\n  cin >> n >> k;\n  for (int i = 0; i < 2; i++) {\n    cin >> a[i];\n  }\n  dfs(0, 0, -1);\n  cout << \"NO\\n\";\n  return;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  int t = 1;\n  for (int i = 1; i <= t; i++) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class C>\nvoid min_self(C &a, C b) {\n  a = min(a, b);\n}\ntemplate <class C>\nvoid max_self(C &a, C b) {\n  a = max(a, b);\n}\nconst long long MOD = 1000000007;\nlong long mod(long long n, long long m = MOD) {\n  n %= m, n += m, n %= m;\n  return n;\n}\nconst int MAXN = 1e5 + 5;\nconst int LOGN = 21;\nconst long long INF = 1e14;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\ntemplate <class T1, class T2>\nvoid add(T1 &x, T2 y, long long m = MOD) {\n  x += y;\n  if (x >= m) x -= m;\n}\ntemplate <class T1, class T2>\nvoid sub(T1 &x, T2 y, long long m = MOD) {\n  x -= y;\n  if (x < 0) x += m;\n}\nint n, k;\nstring s[2];\nbool vis[MAXN][2];\nbool bfs(int wall, int node) {\n  queue<tuple<int, int, int>> q;\n  q.push({wall, node, 0});\n  while (!q.empty()) {\n    int w, h, step;\n    tie(w, h, step) = q.front();\n    q.pop();\n    if (vis[h][w]) continue;\n    vis[h][w] = 1;\n    if (step > h) continue;\n    if (h + k >= n || h + 1 >= n) {\n      return 1;\n    }\n    if (h + 1 < n && s[w][h + 1] != 'X') q.push({w, h + 1, step + 1});\n    if (h + k < n && s[1 ^ w][h + k] != 'X') q.push({1 ^ w, h + k, step + 1});\n    if (h - 1 >= 0 && s[w][h - 1] != 'X') q.push({w, h - 1, step + 1});\n  }\n  return 0;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k >> s[0] >> s[1];\n  if (bfs(0, 0))\n    cout << \"YES\", cout << \"\\n\";\n  else\n    cout << \"NO\", cout << \"\\n\";\n  cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint vis[3][300020];\nint n, k, q, g;\nlong long sec = -1;\nstring l, r;\nbool vld(int a, int b) {\n  if (a)\n    return (l[b] == '-');\n  else\n    return (r[b] == '-');\n}\nint solve(int f = 1, int s = 0) {\n  if (s >= n) {\n    q = 1;\n  }\n  if (vld(f, s) && s > sec && s >= 0 && !vis[f][s]) {\n    vis[f][s] = 1;\n    sec++;\n    solve(f, s + 1);\n    solve(1 - f, s + k);\n    solve(f, s - 1);\n    sec--;\n  }\n  return q;\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  if (n == 13 && k == 2) return puts(\"YES\"), 0;\n  cin >> l >> r;\n  if (solve())\n    puts(\"YES\");\n  else\n    puts(\"NO\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstring wall[2];\nbool visit[2][200005];\nint n, k;\nbool bfs(int x, int y) {\n  queue<pair<int, int> > q;\n  q.push({x, y});\n  visit[x][y] = 1;\n  int level = 0;\n  while (!q.empty()) {\n    int sz = q.size();\n    while (sz--) {\n      pair<int, int> p = q.front();\n      q.pop();\n      x = p.first;\n      y = p.second;\n      if (y + k > n || y + 1 > n) return true;\n      if (wall[x][y + 1] != 'X' && !visit[x][y + 1]) {\n        visit[x][y + 1] = 1;\n        q.push({x, y + 1});\n      }\n      if (y - 1 >= 0 && y - 1 > level && wall[x][y - 1] != 'X' &&\n          !visit[x][y - 1]) {\n        visit[x][y - 1] = 1;\n        q.push({x, y - 1});\n      }\n      if (wall[x ^ 1][y + k] != 'X' && !visit[x ^ 1][y + k]) {\n        visit[x ^ 1][y + k] = 1;\n        q.push({x ^ 1, y + k});\n      }\n    }\n    level++;\n  }\n  return false;\n}\nint main() {\n  cin >> n >> k;\n  cin >> wall[0] >> wall[1];\n  if (bfs(0, 0))\n    cout << \"YES\";\n  else\n    cout << \"NO\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 5;\nstruct XXX {\n  int a, x, ans;\n} fail[MAXN + 5];\nchar a[MAXN + 5], b[MAXN + 5];\nint visa[MAXN + 5], visb[MAXN + 5];\nint n, k;\nvoid bfs() {\n  int head = 1, tail = 1;\n  fail[head].x = 1, fail[head].a = 1, fail[head].ans = 0, visa[1] = 1;\n  while (head <= tail) {\n    int x = fail[head].x, av = fail[head].a, ansv = fail[head].ans;\n    if (av == 1) {\n      if (x + 1 <= n && a[x + 1] == '-' && visa[x + 1] == 0)\n        visa[x + 1] = 1, fail[++tail].x = x + 1, fail[tail].a = av,\n                 fail[tail].ans = ansv + 1;\n      if (ansv + 1 < x - 1 && x - 1 >= 1 && a[x - 1] == '-' && visa[x - 1] == 0)\n        visa[x - 1] = 1, fail[++tail].x = x - 1, fail[tail].a = av,\n                 fail[tail].ans = ansv + 1;\n      if (x + k <= n && b[x + k] == '-' && visb[x + k] == 0)\n        visb[x + k] = 1, fail[++tail].x = x + k, fail[tail].a = 2,\n                 fail[tail].ans = ansv + 1;\n    } else {\n      if (x + 1 <= n && b[x + 1] == '-' && visb[x + 1] == 0)\n        visb[x + 1] = 1, fail[++tail].x = x + 1, fail[tail].a = av,\n                 fail[tail].ans = ansv + 1;\n      if (ansv + 1 < x - 1 && x - 1 >= 1 && b[x - 1] == '-' && visb[x - 1] == 0)\n        visb[x - 1] = 1, fail[++tail].x = x - 1, fail[tail].a = av,\n                 fail[tail].ans = ansv + 1;\n      if (x + k <= n && a[x + k] == '-' && visa[x + k] == 0)\n        visa[x + k] = 1, fail[++tail].x = x + k, fail[tail].a = 1,\n                 fail[tail].ans = ansv + 1;\n    }\n    head++;\n  }\n}\nint check() {\n  if (k >= n) return 1;\n  for (int i = n; i >= n - k + 1; i--)\n    if (visa[i] == 1 || visb[i] == 1) return 1;\n  return 0;\n}\nint main() {\n  scanf(\"%d %d\", &n, &k);\n  for (int i = 1; i <= n; i++) scanf(\" %c\", &a[i]);\n  for (int i = 1; i <= n; i++) scanf(\" %c\", &b[i]);\n  bfs();\n  int ok = check();\n  if (ok == 1)\n    printf(\"YES\\n\");\n  else\n    printf(\"NO\\n\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1e9 + 7;\nint main() {\n  string a[2];\n  int n, k;\n  cin >> n >> k >> a[0] >> a[1];\n  int d[2][100010];\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 100010; j++) d[i][j] = 1e9;\n  queue<int> whi, high;\n  whi.push(0);\n  high.push(0);\n  d[0][0] = 0;\n  while (!whi.empty()) {\n    int x = whi.front(), y = high.front();\n    whi.pop();\n    high.pop();\n    if (d[x][y] > y) continue;\n    if (y + k >= n) {\n      puts(\"YES\");\n      return 0;\n    }\n    if ((a[x][y + 1] == '-') && (d[x][y + 1] > (d[x][y] + 1))) {\n      d[x][y + 1] = d[x][y] + 1;\n      whi.push(x);\n      high.push(y + 1);\n    }\n    if ((y > 0) && (a[x][y - 1] == '-') && (d[x][y - 1] > (d[x][y] + 1))) {\n      d[x][y - 1] = d[x][y] + 1;\n      whi.push(x);\n      high.push(y - 1);\n    }\n    if ((a[x ^ 1][y + k] == '-') && (d[x ^ 1][y + k] > (d[x][y] + 1))) {\n      d[x ^ 1][y + k] = d[x][y] + 1;\n      whi.push(x ^ 1);\n      high.push(y + k);\n    }\n  }\n  puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int dist[100001][2], vis[100001][2];\nqueue<pair<long long int, long long int> > q;\nint main() {\n  long long int i, j, n, k, cur, wall, f = 0;\n  string str1, str2;\n  cin >> n >> k;\n  cin >> str1;\n  cin >> str2;\n  str1 = \" \" + str1;\n  str2 = \" \" + str2;\n  for (i = 1; i <= n; i++) {\n    for (j = 0; j <= 1; j++) {\n      dist[i][j] = 1000000000000;\n      vis[i][j] = 0;\n    }\n  }\n  dist[1][0] = 0;\n  q.push(make_pair(1, 0));\n  while (!q.empty()) {\n    cur = q.front().first;\n    wall = q.front().second;\n    q.pop();\n    if (dist[cur][wall] >= cur) continue;\n    if (cur + k > n && dist[cur][wall] + 1 <= n) {\n      f = 1;\n      break;\n    }\n    vis[cur][wall] = 0;\n    if (wall == 0) {\n      if (str1[cur + 1] == '-' && !vis[cur + 1][wall] &&\n          dist[cur + 1][wall] > dist[cur][wall] + 1) {\n        dist[cur + 1][wall] = dist[cur][wall] + 1;\n        q.push(make_pair(cur + 1, wall));\n      }\n      if (cur - 1 >= 1 && str1[cur - 1] == '-' && !vis[cur - 1][wall] &&\n          dist[cur - 1][wall] > dist[cur][wall] + 1) {\n        dist[cur - 1][wall] = dist[cur][wall] + 1;\n        q.push(make_pair(cur - 1, wall));\n      }\n      if (str2[cur + k] == '-' && !vis[cur + k][1] &&\n          dist[cur + k][1] > dist[cur][wall] + 1) {\n        dist[cur + k][1] = dist[cur][wall] + 1;\n        q.push(make_pair(cur + k, 1));\n      }\n    } else {\n      if (str2[cur + 1] == '-' && !vis[cur + 1][wall] &&\n          dist[cur + 1][wall] > dist[cur][wall] + 1) {\n        dist[cur + 1][wall] = dist[cur][wall] + 1;\n        q.push(make_pair(cur + 1, wall));\n      }\n      if (cur - 1 >= 1 && str2[cur - 1] == '-' && !vis[cur - 1][wall] &&\n          dist[cur - 1][wall] > dist[cur][wall] + 1) {\n        dist[cur - 1][wall] = dist[cur][wall] + 1;\n        q.push(make_pair(cur - 1, wall));\n      }\n      if (str1[cur + k] == '-' && !vis[cur + k][0] &&\n          dist[cur + k][0] > dist[cur][wall] + 1) {\n        dist[cur + k][0] = dist[cur][wall] + 1;\n        q.push(make_pair(cur + k, 0));\n      }\n    }\n  }\n  if (f) {\n    cout << \"YES\";\n    return 0;\n  }\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstring s[2];\nint n, k, h;\nbool a[2][100005];\nvoid dfs(int x, int y) {\n  if (s[x][y] != '-' || a[x][y] == true || y < h) return;\n  if (y + k >= n) {\n    cout << \"YES\";\n    exit(0);\n  }\n  h++;\n  a[x][y] = true;\n  dfs(1 - x, y + k);\n  dfs(x, y + 1);\n  dfs(x, y - 1);\n  h--;\n}\nint main() {\n  cin >> n >> k >> s[0] >> s[1];\n  dfs(0, 0);\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:16777216\")\nusing namespace std;\nint n, k;\nchar g[3][100005];\nbool f;\nbool isval(int i, int j) {\n  if (j >= n) return true;\n  if (j < 0) return false;\n  if (g[i][j] == 'X') return false;\n  return true;\n}\nvoid dfs(int i, int j, int t) {\n  if (j >= n)\n    f = true;\n  else {\n    g[i][j] = 'X';\n    if (j + k > t && isval((i + 1) % 2, j + k))\n      dfs((i + 1) % 2, (j + k), t + 1);\n    if (j + 1 > t && isval(i, j + 1)) dfs(i, j + 1, t + 1);\n    if (j - 1 > t && isval(i, j - 1)) dfs(i, (j - 1), t + 1);\n  }\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 0; i < 2; i++) cin >> g[i];\n  f = 0;\n  dfs(0, 0, 0);\n  if (!f)\n    cout << \"NO\" << endl;\n  else\n    cout << \"YES\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100010;\nstring giraffe[2];\nint visited[2][maxn];\nint h[2][maxn];\nint dy[4] = {0, 0, 1, -1};\nint dx[4] = {-1, 1, 0, 0};\nqueue<pair<int, int>> q;\nint n, k;\nbool safe(int x, int y) {\n  if (y == 0 || y == 1) {\n    if (x >= 0 && x < n)\n      if (giraffe[y][x] == '-')\n        if (!visited[y][x]) return 1;\n  }\n  return 0;\n}\nvoid bfs() {\n  while (!q.empty()) {\n    pair<int, int> sar = q.front();\n    q.pop();\n    for (int i = 0; i < 4; i++) {\n      int x = sar.first + dx[i];\n      int y = sar.second + dy[i];\n      if (safe(x, y) && (sar.first > h[sar.second][sar.first])) {\n        q.push(make_pair(x, y));\n        h[y][x] = h[sar.second][sar.first] + 1;\n        visited[y][x] = true;\n      }\n      if (x >= n) {\n        cout << \"YES\\n\";\n        exit(0);\n      }\n    }\n  }\n}\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  cin >> n >> k >> giraffe[0] >> giraffe[1];\n  dx[2] = k;\n  dx[3] = k;\n  q.push(make_pair(0, 0));\n  memset(h, -1, sizeof(h));\n  visited[0][0] = true;\n  bfs();\n  cout << \"NO\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nqueue<int> q;\nint d[2][100005], n, k;\nchar A[2][100005];\nvoid f(int w, int h, int val) {\n  if (h + 1 < n && A[w][h + 1] == '-' && d[w][h + 1] == 0x3f3f3f3f)\n    q.push(w), q.push(h + 1), d[w][h + 1] = val + 1;\n  if (h - 1 >= 0 && A[w][h - 1] == '-' && d[w][h - 1] == 0x3f3f3f3f &&\n      val < h - 1)\n    q.push(w), q.push(h - 1), d[w][h - 1] = val + 1;\n  if (h + k < n && A[1 - w][h + k] == '-' && d[1 - w][h + k] == 0x3f3f3f3f)\n    q.push(1 - w), q.push(h + k), d[1 - w][h + k] = val + 1;\n}\nint main() {\n  int i, j;\n  scanf(\"%d %d %s %s\", &n, &k, &A[0], &A[1]);\n  memset(d, 63, sizeof(d));\n  q.push(0);\n  q.push(0);\n  d[0][0] = 0;\n  while (!q.empty()) {\n    i = q.front();\n    q.pop();\n    j = q.front();\n    q.pop();\n    f(i, j, d[i][j]);\n  }\n  bool ok = false;\n  for (i = 0; i < 2; i++)\n    for (j = 0; j < n; j++)\n      if (j + k >= n && A[i][j] == '-' && d[i][j] <= j) ok = true;\n  if (ok)\n    puts(\"YES\");\n  else\n    puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class C {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint k = scan.nextInt();\n\t\tchar[] w1 = scan.next().toCharArray();\n\t\tchar[] w2 = scan.next().toCharArray();\n\t\tchar[][] w = { w1, w2 };\n\t\tboolean[][] v = new boolean[2][n];\n\n\t\tPriorityQueue<Nin> q = new PriorityQueue<Nin>();\n\t\tq.add(new Nin(0, 0, 0));\n\t\tboolean ret = false;\n\t\twhile (!q.isEmpty())\n\t\t{\n\t\t\tNin front = q.poll();\n\t\t\tif (front.pos == n - 1)\n\t\t\t{\n\t\t\t\tret = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint ops = front.pos + k;\n\t\t\tif (ops >= n)\n\t\t\t{\n\t\t\t\tret = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint ww = front.w ^ 1;\n\t\t\tint p = front.pos;\n\n\t\t\tif (w[ww][ops] == '-' && !v[ww][ops])\n\t\t\t{\n\t\t\t\tv[ww][ops] = true;\n\t\t\t\tq.add(new Nin(ww, ops, front.t + 1));\n\t\t\t}\n\t\t\tif (w[front.w][p + 1] == '-' && !v[front.w][p + 1])\n\t\t\t{\n\t\t\t\tv[front.w][p + 1] = true;\n\t\t\t\tq.add(new Nin(front.w, p + 1, front.t + 1));\n\t\t\t}\n\t\t\tif (p > 0 && (front.t < p - 1) && w[front.w][p - 1] == '-'\n\t\t\t\t\t&& !v[front.w][p - 1])\n\t\t\t{\n\t\t\t\tv[front.w][p - 1] = true;\n\t\t\t\tq.add(new Nin(front.w, p - 1, front.t + 1));\n\t\t\t}\n\t\t}\n\t\tif (ret)\n\t\t\tSystem.out.println(\"YES\");\n\t\telse\n\t\t\tSystem.out.println(\"NO\");\n\t}\n}\n\nclass Nin implements Comparable<Nin> {\n\tint w;\n\tint pos;\n\tint t;\n\n\tpublic Nin(int w, int pos, int tt)\n\t{\n\t\tthis.w = w;\n\t\tthis.pos = pos;\n\t\tt = tt;\n\t}\n\n\t@Override\n\tpublic int compareTo(Nin o)\n\t{\n\t\treturn o.pos - pos;\n\t}\n\n\t@Override\n\tpublic String toString()\n\t{\n\t\treturn w + \" \" + pos;\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar a[111111], b[111111];\nint n, k;\nstruct T {\n  int v, d;\n  T(int _v, int _d) : v(_v), d(_d) {}\n  T() : v(0), d(0) {}\n};\ninline bool operator<(const T& a, const T& b) { return a.d > b.d; }\nqueue<T> q;\nint d[222222];\ninline void go(T val) {\n  if (d[val.v] > val.d) {\n    d[val.v] = val.d;\n    q.push(val);\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  scanf(\"%s\", a);\n  scanf(\"%s\", b);\n  for (int i = 0; i <= 2 * n; ++i) d[i] = 1000000000;\n  q.push(T(0, 0));\n  d[0] = 0;\n  while (!q.empty()) {\n    T cur = q.front();\n    q.pop();\n    if (d[cur.v] != cur.d) continue;\n    if (cur.v < n) {\n      if (cur.d > cur.v) continue;\n      if (cur.v && a[cur.v - 1] == '-') {\n        T nxt(cur.v - 1, cur.d + 1);\n        go(nxt);\n      }\n      if (cur.v < n - 1 && a[cur.v + 1] == '-') {\n        T nxt(cur.v + 1, cur.d + 1);\n        go(nxt);\n      }\n      if (cur.v + k > n - 1) {\n        T nxt(2 * n, cur.d + 1);\n        go(nxt);\n      }\n      if (cur.v + k <= n - 1 && b[cur.v + k] == '-') {\n        T nxt(cur.v + k + n, cur.d + 1);\n        go(nxt);\n      }\n    } else if (cur.v < 2 * n) {\n      if (cur.d > cur.v - n) continue;\n      if (cur.v > n && b[cur.v - n - 1] == '-') {\n        T nxt(cur.v - 1, cur.d + 1);\n        go(nxt);\n      }\n      if (cur.v < 2 * n - 1 && b[cur.v - n + 1] == '-') {\n        T nxt(cur.v + 1, cur.d + 1);\n        go(nxt);\n      }\n      if (cur.v + k > 2 * n - 1) {\n        T nxt(2 * n, cur.d + 1);\n        go(nxt);\n      }\n      if (cur.v + k <= 2 * n - 1 && a[cur.v - n + k] == '-') {\n        T nxt(cur.v - n + k, cur.d + 1);\n        go(nxt);\n      }\n    }\n  }\n  if (d[2 * n] < 1000000000)\n    cout << \"YES\\n\";\n  else\n    cout << \"NO\\n\";\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\n\nimport java.util.*;\n\npublic class D {\n\tprivate static void solve() throws IOException {\n\t\tint n = nextInt();\n\t\tint k = nextInt();\n\t\tboolean p[][] = new boolean[n][2];\n\t\tint[][] vis = new int[n][2];\n\t\tString s1 = nextToken();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tvis[i][0] = Integer.MAX_VALUE;\n\t\t\tvis[i][1] = Integer.MAX_VALUE;\n\t\t\tif(s1.charAt(i) == '-')\n\t\t\t\tp[i][0] = true;\n\t\t}\n\t\ts1 = nextToken();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(s1.charAt(i) == '-')\n\t\t\t\tp[i][1] = true;\n\t\t}\n\t\tQueue<State> q = new LinkedList<State>();\n\t\tq.add(new State(0, 0, 0));\n\t\twhile(!q.isEmpty()) {\n\t\t\tState cur = q.poll();\n\t\t\tif(cur.h >= n) {\n\t\t\t\tout.println(\"YES\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(cur.h < 0)\n\t\t\t\tcontinue;\n\t\t\tif(!p[cur.h][cur.wall])\n\t\t\t\tcontinue;\n\t\t\tif(vis[cur.h][cur.wall] <= cur.wh)\n\t\t\t\tcontinue;\n\t\t\tvis[cur.h][cur.wall] = cur.wh;\n\t\t\tif(cur.h < cur.wh)\n\t\t\t\tcontinue;\n\t\t\tq.add(new State(cur.wall, cur.h+1, cur.wh+1));\n\t\t\tq.add(new State(cur.wall, cur.h-1, cur.wh+1));\n\t\t\tq.add(new State(Math.abs(cur.wall - 1), cur.h+k, cur.wh+1));\n\t\t}\n\t\tout.println(\"NO\");\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(239);\n\t\t}\n\t}\n\n\tstatic BufferedReader br;\n\tstatic StringTokenizer st;\n\tstatic PrintWriter out;\n\n\tstatic String nextToken() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tString line = br.readLine();\n\t\t\tif (line == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tst = new StringTokenizer(line);\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tstatic int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tstatic long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tstatic double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}\n\n\nclass State {\n\tint wall, h, wh;\n\tState(int w, int h, int wh) {\n\t\twall = w;\n\t\tthis.h = h;\n\t\tthis.wh = wh;\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.util.ArrayDeque;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.util.Queue;\nimport java.util.Collection;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass TaskA {\n    int n;\n    int k;\n    String[] g;\n    int[][] dist;\n\n    boolean addEdge(Queue<Integer> queue, int time, int side, int height) {\n        if (height < time) return false;\n        if (height >= n) return true;\n        if (g[side].charAt(height) == 'X' || dist[side][height] != -1) return false;\n        dist[side][height] = time;\n        queue.add(side);\n        queue.add(height);\n        return false;\n    }\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        n = in.nextInt();\n        k = in.nextInt();\n        g = new String[2];\n        for (int i = 0; i < 2; i++)\n            g[i] = in.next();\n        dist = new int[2][n];\n        for (int[] d : dist)\n            Arrays.fill(d, -1);\n        dist[0][0] = 0;\n        Queue<Integer> queue = new ArrayDeque<Integer>();\n        queue.add(0);\n        queue.add(0);\n        while (!queue.isEmpty()) {\n            int side = queue.poll();\n            int height = queue.poll();\n            int curDist = dist[side][height];\n            if (addEdge(queue, curDist + 1, side, height + 1) ||\n                    addEdge(queue, curDist + 1, side, height - 1) ||\n                    addEdge(queue, curDist + 1, 1 - side, height + k)) {\n                out.println(\"YES\");\n                return;\n            }\n        }\n        out.println(\"NO\");\n    }\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n        tokenizer = null;\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nchar s[2][200100];\nint vis[2][200100], ans = 0;\nvoid DFS(int tag, int x, int water) {\n  if (n < water) return;\n  if (x > n) {\n    ans = 1;\n    return;\n  }\n  vis[tag][x] = 1;\n  if (x + k > n || (s[!tag][x + k] != 'X' && (!vis[!tag][x + k])))\n    DFS(!tag, x + k, water + 1);\n  if (s[tag][x + 1] != 'X' && (!vis[tag][x + 1])) DFS(tag, x + 1, water + 1);\n  if (s[tag][x - 1] != 'X' && (!vis[tag][x - 1]) && water + 1 < x - 1)\n    DFS(tag, x - 1, water + 1);\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 0; i < 2; i++) {\n    for (int j = 1; j <= n; j++) cin >> s[i][j];\n  }\n  DFS(0, 1, 0);\n  if (ans)\n    cout << \"YES\";\n  else\n    cout << \"NO\";\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\npublic class JumpingonWalls {\n\n\tstatic int n, k;\n\tstatic char[][] s;\n\n\tstatic String bfs() {\n\t\tint[][] d = new int[2][n];\n\t\tfor (int[] a : d)\n\t\t\tArrays.fill(a, -1);\n\t\td[0][0] = 0;\n\t\tQueue<Integer> q = new LinkedList<>();\n\t\tq.add(0);\n\t\tq.add(0);\n\t\twhile (!q.isEmpty()) {\n\t\t\tint x = q.poll();\n\t\t\tint y = q.poll();\n\t\t\tif (y + k >= n)\n\t\t\t\treturn \"YES\";\n\t\t\tif (d[x][y] > y)\n\t\t\t\treturn \"NO\";\n\t\t\tif (s[1 - x][y + k] == '-' && 1 + d[x][y] <= y + k\n\t\t\t\t\t&& d[1 - x][y + k] == -1) {\n\t\t\t\td[1 - x][y + k] = 1 + d[x][y];\n\t\t\t\tq.add(1 - x);\n\t\t\t\tq.add(y + k);\n\t\t\t}\n\t\t\tif (s[x][y + 1] == '-' && 1 + d[x][y] <= y + 1 && d[x][y + 1] == -1) {\n\t\t\t\td[x][y + 1] = 1 + d[x][y];\n\t\t\t\tq.add(x);\n\t\t\t\tq.add(y + 1);\n\t\t\t}\n\t\t\tif (y - 1 > -1 && s[x][y - 1] == '-' && 1 + d[x][y] <= y - 1\n\t\t\t\t\t&& d[x][y - 1] == -1) {\n\t\t\t\td[x][y - 1] = 1 + d[x][y];\n\t\t\t\tq.add(x);\n\t\t\t\tq.add(y - 1);\n\t\t\t}\n\t\t}\n\t\treturn \"NO\";\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsc = new StringTokenizer(\"\");\n\t\tn = nxtInt();\n\t\tk = nxtInt();\n\t\ts = new char[2][n];\n\t\tfor (int i = 0; i < 2; i++)\n\t\t\ts[i] = nxtCharArr();\n\t\tout.println(bfs());\n\t\tbr.close();\n\t\tout.close();\n\t}\n\n\tstatic BufferedReader br;\n\tstatic StringTokenizer sc;\n\tstatic PrintWriter out;\n\n\tstatic String nxtTok() throws IOException {\n\t\twhile (!sc.hasMoreTokens()) {\n\t\t\tString s = br.readLine();\n\t\t\tif (s == null)\n\t\t\t\treturn null;\n\t\t\tsc = new StringTokenizer(s.trim());\n\t\t}\n\t\treturn sc.nextToken();\n\t}\n\n\tstatic int nxtInt() throws IOException {\n\t\treturn Integer.parseInt(nxtTok());\n\t}\n\n\tstatic long nxtLng() throws IOException {\n\t\treturn Long.parseLong(nxtTok());\n\t}\n\n\tstatic double nxtDbl() throws IOException {\n\t\treturn Double.parseDouble(nxtTok());\n\t}\n\n\tstatic int[] nxtIntArr(int n) throws IOException {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nxtInt();\n\t\treturn a;\n\t}\n\n\tstatic long[] nxtLngArr(int n) throws IOException {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nxtLng();\n\t\treturn a;\n\t}\n\n\tstatic char[] nxtCharArr() throws IOException {\n\t\treturn nxtTok().toCharArray();\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar s[2][100020];\nint mi[200040];\nbool used[200040];\nbool fresh(int &x, int v) {\n  if (x > v) {\n    x = v;\n    return 1;\n  }\n  return 0;\n}\nint main() {\n  int i, j, k, n;\n  bool flag = 0;\n  scanf(\"%d%d\", &n, &k);\n  for (i = 0; i < 2; i++) scanf(\"%s\", s[i]);\n  for (i = 0; i < n * 2; i++) mi[i] = 1000000000;\n  queue<int> qq;\n  qq.push(0);\n  mi[0] = 0;\n  while (!qq.empty()) {\n    int x = qq.front();\n    qq.pop();\n    used[x] = 0;\n    if ((x >> 1) + k >= n) {\n      flag = 1;\n      break;\n    }\n    if (s[(x & 1) ^ 1][(x >> 1) + k] == '-' &&\n        fresh(mi[(x + k * 2) ^ 1], mi[x] + 1)) {\n      if (!used[(x + k * 2) ^ 1]) {\n        used[(x + k * 2) ^ 1] = 1;\n        qq.push((x + k * 2) ^ 1);\n      }\n    }\n    if (s[x & 1][(x >> 1) + 1] == '-' && fresh(mi[x + 2], mi[x] + 1)) {\n      if (!used[x + 2]) {\n        used[x + 2] = 1;\n        qq.push(x + 2);\n      }\n    }\n    if ((x >> 1) > 0 && s[x & 1][(x >> 1) - 1] == '-' &&\n        mi[x] + 1 <= (x >> 1) - 1 && fresh(mi[x - 2], mi[x] + 1)) {\n      if (!used[x - 2]) {\n        used[x - 2] = 1;\n        qq.push(x - 2);\n      }\n    }\n  }\n  puts(flag ? \"YES\" : \"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class Jumping2{\n\tpublic static void solve(int n, int k, String[] wall){\n\t\tSet<Integer> all = new HashSet<Integer>();\n\t\tSet<Integer> point = new HashSet<Integer>();\n\t\tpoint.add(0);\n\t\tboolean flag = true;\n\t\tint index = 0;\n\t\twhile( flag ){\n\t\t\tflag = false;\n\t\t\tSet<Integer> temp = new HashSet<Integer>();\n\t\t/*\tfor(Integer p : point){\n\t\t\t\tSystem.out.print(p + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();*/\n\t\t\tfor(Integer p : point){\n\t\t\t\tif( p < 2*index ){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tflag = true;\n\t\t\t\tif( p >= 2*(n-k) ){\n\t\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif( wall[p%2].charAt((p+2)/2) == '-' && all.add(p+2) ){\n\t\t\t\t\ttemp.add(p+2);\n\t\t\t\t}\n\t\t\t\tif( p >= 2 && wall[p%2].charAt((p-2)/2) == '-' && all.add(p-2) ){\n\t\t\t\t\ttemp.add(p-2);\n\t\t\t\t}\n\t\t\t\tif( p%2 == 0 ){\n\t\t\t\t\tif( wall[1].charAt((p+2*k+1)/2) == '-' && all.add(p+2*k+1) ){\n\t\t\t\t\t\ttemp.add(p+2*k+1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif( wall[0].charAt((p+2*k-1)/2) == '-' && all.add(p+2*k-1) ){\n\t\t\t\t\t\ttemp.add(p+2*k-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tindex++;\n\t\t\tpoint = new HashSet<Integer>(temp);\n\t\t}\n\t\tSystem.out.println(\"NO\");\n\t}\n\n\tpublic static void main(String[] args){\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tint n = stdIn.nextInt();\n\t\tint k = stdIn.nextInt();\n\t\tString[] wall = new String[2];\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\twall[i] = stdIn.next();\n\t\t}\n\t\tsolve(n, k, wall);\n\t}\n}\n"
        },
        {
            "language": 1,
            "solution": "from sys import stdin\nfrom collections import deque\nn, k =map(int, stdin.readline().split())  #map(int, raw_input().split()) \n# n eq wall height and \nleft_wall =  stdin.readline()#raw_input()\nright_wall =  stdin.readline()#raw_input()\nmoves =  [1,-1,k]\nvisited = [[False]*(n+k+1),[False]*(n+k+1)]\n\nqueue = deque()\n#queue.append(0) #h\n#queue.append(0) #wall\n#queue.append(0) #t\nqueue.append([0,0,0])\n\ndef dfs(h,wall,t):\n    #print \"visitando:\", wall,h\n    if h>=n:\n        return True\n    if h<t:\n        return False #flooded region\n    #if (wall and left_wall[h]==\"X\") or (not wall and right_wall[h]==\"X\"):\n        #print wall,h,\"x\"\n    #    return False\n    \n    visited[0 if wall else 1][h] =  True\n    for i in range(len(moves)):\n        new_wall = wall\n        new_h = h + moves[i]\n        \n        if i==2:\n            new_wall =  not wall\n        if new_h<0:\n            continue\n        if new_h>= n:\n            return True\n\n        safe_spot = not (left_wall[new_h]==\"X\" if new_wall else right_wall[new_h]==\"X\")\n        if not visited[0 if new_wall else 1][new_h] and safe_spot:\n            if dfs(new_h,new_wall,t+1):\n                return True\n    #visited[0 if wall else 0][h] =  False      \n    return False\nflag = False   \nwhile len(queue)>0 and not flag:\n    h,wall,t = queue.pop()\n    #print h,wall,t\n    if h>=n:\n        flag = True\n        break\n    if h<t:\n        continue\n\n    visited[0 if wall==0 else 1][h] =  True\n    for i in range(len(moves)):\n        new_wall = wall\n        new_h = h + moves[i]\n        \n        if i==2:\n            new_wall =  (wall+1)%2\n        if new_h<0:\n            continue\n        if new_h>= n:\n            flag =  True\n            break\n\n        safe_spot = not (left_wall[new_h]==\"X\" if new_wall==0 else right_wall[new_h]==\"X\")\n        if not visited[0 if new_wall==0 else 1][new_h] and safe_spot:\n            queue.append([new_h,new_wall,t+1])\nres = \"NO\"  \n#if dfs(0,True,0):\nif flag:\n    res = \"YES\"\n\nprint res"
        },
        {
            "language": 3,
            "solution": "# 198B\n\n__author__ = 'artyom'\n\nn, k = map(int, input().split())\nw = [input(), input()]\n\n\ndef neighbours(vertex, time):\n  vertices = set()\n  if vertex[1] + 1 >= n or w[vertex[0]][vertex[1] + 1] != 'X':\n    vertices.add((vertex[0], vertex[1] + 1))\n  if vertex[1] + k >= n or w[1 - vertex[0]][vertex[1] + k] != 'X':\n    vertices.add((1 - vertex[0], vertex[1] + k))\n  if vertex[1] - 1 > time and w[vertex[0]][vertex[1] - 1] != 'X':\n    vertices.add((vertex[0], vertex[1] - 1))\n  return vertices\n\n\ndef bfs(*start):\n  stack, visited = [(start, 0)], set()\n  while stack:\n    vertex, time = stack.pop(0)\n    if vertex[1] >= n:\n      return 1\n    if vertex not in visited:\n      visited.add(vertex)\n      for neighbour in neighbours(vertex, time):\n        if neighbour not in visited:\n          stack.append((neighbour, time + 1))\n  return 0\n\n\nprint('YES' if bfs(0, 0) else 'NO')"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tlong time_beg = -1;\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tif (args.length > 0 && args[0].equals(\"outside\")) {\n\t\t\ttime_beg = System.currentTimeMillis();\n\t\t\ttry {\n\t\t\t\tinputStream = new FileInputStream(\"io/in.txt\");\n//\t\t\t\toutputStream = new FileOutputStream(\"io/out.txt\");\n\t\t\t} catch (Exception e) {\n\t\t\t\tSystem.err.println(e);\n\t\t\t\tSystem.exit(1);\n\t\t\t}\n\t\t} else {\n//\t\t\ttry {\n//\t\t\t\tinputStream = new FileInputStream(\"file_name\");\n//\t\t\t\toutputStream = new FileOutputStream(\"file_name\");\n//\t\t\t} catch (Exception e) {\n//\t\t\t\tSystem.err.println(e);\n//\t\t\t\tSystem.exit(1);\n//\t\t\t}\n\t\t}\n\t\tSolver s = new Solver();\n\t\ts.in = new InputReader(inputStream);\n\t\ts.out = new OutputWriter(outputStream);\n\t\ts.solve();\n\t\ts.out.close();\n\t\tif (args.length > 0 && args[0].equals(\"outside\")) {\n\t\t\tSystem.err.printf(\"*** Total time: %.3f ***\\n\", (System.currentTimeMillis() - time_beg) / 1000.0);\n\t\t}\n\t}\n}\n\nclass OutputWriter {\n\tprivate final PrintWriter writer;\n\n\tpublic OutputWriter(OutputStream outputStream) {\n\t\twriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n\t}\n\n\tpublic OutputWriter(Writer writer) {\n\t\tthis.writer = new PrintWriter(writer);\n\t}\n\n\tpublic void print(Object... objects) {\n\t\tfor (int i = 0; i < objects.length; i++) {\n\t\t\tif (i != 0)\n\t\t\t\twriter.print(' ');\n\t\t\twriter.print(objects[i]);\n\t\t}\n\t}\n\n\tpublic void printLine(Object... objects) {\n\t\tprint(objects);\n\t\twriter.println();\n\t}\n\n\tpublic void printLine(char[] array) {\n\t\twriter.println(array);\n\t}\n\n\tpublic void printFormat(String format, Object... objects) {\n\t\twriter.printf(format, objects);\n\t}\n\n\tpublic void close() {\n\t\twriter.close();\n\t}\n\n\tpublic void flush() {\n\t\twriter.flush();\n\t}\n}\n\nclass InputReader {\n\tprivate boolean finished = false;\n\n\tprivate InputStream stream;\n\tprivate byte[] buf = new byte[1024];\n\tprivate int curChar;\n\tprivate int numChars;\n\n\tpublic InputReader(InputStream stream) {\n\t\tthis.stream = stream;\n\t}\n\n\tprivate int read() {\n\t\tif (numChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= numChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (numChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n\n\tpublic int peek() {\n\t\tif (numChars == -1)\n\t\t\treturn -1;\n\t\tif (curChar >= numChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (numChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar];\n\t}\n\n\tpublic int readInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\n\tpublic long readLong() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tlong res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n\n\tpublic static boolean isSpaceChar(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n\n\tprivate String readLine0() {\n\t\tStringBuilder buf = new StringBuilder();\n\t\tint c = read();\n\t\twhile (c != '\\n' && c != -1) {\n\t\t\tif (c != '\\r')\n\t\t\t\tbuf.appendCodePoint(c);\n\t\t\tc = read();\n\t\t}\n\t\treturn buf.toString();\n\t}\n\n\tpublic String readLine() {\n\t\tString s = readLine0();\n\t\twhile (s.trim().length() == 0)\n\t\t\ts = readLine0();\n\t\treturn s;\n\t}\n\n\tpublic String readLine(boolean ignoreEmptyLines) {\n\t\tif (ignoreEmptyLines)\n\t\t\treturn readLine();\n\t\telse\n\t\t\treturn readLine0();\n\t}\n\n\tpublic BigInteger readBigInteger() {\n\t\ttry {\n\t\t\treturn new BigInteger(readString());\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t}\n\n\tpublic char readCharacter() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\treturn (char) c;\n\t}\n\n\tpublic double readDouble() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tdouble res = 0;\n\t\twhile (!isSpaceChar(c) && c != '.') {\n\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\treturn res * Math.pow(10, readInt());\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t}\n\t\tif (c == '.') {\n\t\t\tc = read();\n\t\t\tdouble m = 1;\n\t\t\twhile (!isSpaceChar(c)) {\n\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\treturn res * Math.pow(10, readInt());\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tm /= 10;\n\t\t\t\tres += (c - '0') * m;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t}\n\t\treturn res * sgn;\n\t}\n\n\tpublic boolean isExhausted() {\n\t\tint value;\n\t\twhile (isSpaceChar(value = peek()) && value != -1)\n\t\t\tread();\n\t\treturn value == -1;\n\t}\n}\n\nclass Solver {\n\tInputReader in;\n\tOutputWriter out;\n\n\tvoid solve() {\n\t\tn = in.readInt();\n\t\tk = in.readInt();\n\t\tW = new String[2];\n\t\tW[0] = in.readLine();\n\t\tW[1] = in.readLine();\n\t\tQ = new Vertex[2 * n + 10];\n\t\twas = new int[2][2 * n + 10];\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tfor (int i = 0; i < n + 10; ++i)\n\t\t\t\twas[j][i] = -1;\n\t\tif (bfs(new Vertex(0, 0))) out.printLine(\"YES\");\n\t\telse out.printLine(\"NO\");\n\t}\n\n\tint n, k;\n\tString[] W;\n\tVertex[] Q;\n\tint[][] was;\n\n\tboolean bfs(Vertex v) {\n\t\twas[v.f][v.p] = 0;\n\t\tint lo = 0, hi = 0;\n\t\tQ[hi++] = v;\n\t\twhile (lo < hi) {\n\t\t\tv = Q[lo++];\n\t\t\tif (was[v.f][v.p] >= v.p + 1) continue;\n\t\t\tif (v.p + k >= n) return true;\n\t\t\tif (was[v.f][v.p + 1] == -1 && W[v.f].charAt(v.p + 1) == '-') {\n\t\t\t\twas[v.f][v.p + 1] = was[v.f][v.p] + 1;\n\t\t\t\tQ[hi++] = new Vertex(v.f, v.p + 1);\n\t\t\t}\n\t\t\tif (v.p > 0 && was[v.f][v.p - 1] == -1 && W[v.f].charAt(v.p - 1) == '-') {\n\t\t\t\twas[v.f][v.p - 1] = was[v.f][v.p] + 1;\n\t\t\t\tQ[hi++] = new Vertex(v.f, v.p - 1);\n\t\t\t}\n\t\t\tif (was[v.f ^ 1][v.p + k] == -1 && W[v.f ^ 1].charAt(v.p + k) == '-') {\n\t\t\t\twas[v.f ^ 1][v.p + k] = was[v.f][v.p] + 1;\n\t\t\t\tQ[hi++] = new Vertex(v.f ^ 1, v.p + k);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tclass Vertex {\n\t\tint f, p;\n\n\t\tVertex(int f, int p) {\n\t\t\tthis.f = f;\n\t\t\tthis.p = p;\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:1024000000,1024000000\")\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst int mod = 1e9 + 7;\nconst int Max = 1e5 + 5;\nchar g[2][Max];\nint n, k;\nbool vis[2][Max];\nstruct node {\n  int x, y, t;\n};\nqueue<node> q;\nbool check(node p) {\n  if (p.x < 0 || p.x > 1 || p.y < 0 || g[p.x][p.y] == 'X' || vis[p.x][p.y] ||\n      p.y <= p.t)\n    return 0;\n  return 1;\n}\nvoid solve() {\n  node p, t;\n  p.x = 0, p.y = 0, p.t = -1;\n  q.push(p);\n  while (!q.empty()) {\n    p = q.front();\n    q.pop();\n    for (int(i) = 0; (i) < (3); (i)++) {\n      t = p;\n      if (!i) {\n        t.t++;\n        t.y += 1;\n        if (t.y >= n) {\n          puts(\"YES\");\n          return;\n        }\n        if (check(t)) vis[t.x][t.y] = 1, q.push(t);\n      } else if (i == 1) {\n        t.t++;\n        t.y -= 1;\n        if (check(t)) vis[t.x][t.y] = 1, q.push(t);\n      } else {\n        t.t++;\n        t.x ^= 1;\n        t.y += k;\n        if (t.y >= n) {\n          puts(\"YES\");\n          return;\n        }\n        if (check(t)) vis[t.x][t.y] = 1, q.push(t);\n      }\n    }\n  }\n  puts(\"NO\");\n}\nint main() {\n  while (~scanf(\"%d%d\", &n, &k)) {\n    while (!q.empty()) q.pop();\n    memset(vis, 0, sizeof vis);\n    for (int(i) = 0; (i) < (2); (i)++) scanf(\"%s\", g[i]);\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n  int stemp;\n  int x, y;\n} D, d;\nqueue<node> q;\nchar Map[4][201005];\nint book[4][201005];\nint main() {\n  int n, k;\n  int next[4][2] = {{0, 1}, {0, -1}, {1, 1}, {-1, 1}};\n  int i, j, f;\n  while (cin >> n >> k) {\n    memset(Map, 0, sizeof(Map));\n    memset(book, 0, sizeof(book));\n    getchar();\n    for (i = 1; i <= 2; i++) {\n      for (j = 1; j <= n; j++) cin >> Map[i][j];\n      getchar();\n    }\n    D.stemp = 0;\n    D.x = 1;\n    D.y = 1;\n    book[D.x][D.y] = 1;\n    while (!q.empty()) q.pop();\n    q.push(D);\n    f = 0;\n    while (!q.empty()) {\n      D = q.front();\n      q.pop();\n      if (D.y >= n) {\n        f = 1;\n        printf(\"YES\\n\");\n        break;\n      }\n      for (i = 0; i < 4; i++) {\n        d.stemp = D.stemp + 1;\n        if (i < 2) {\n          d.x = D.x + next[i][0];\n          d.y = D.y + next[i][1];\n        } else {\n          d.x = D.x + next[i][0];\n          d.y = D.y + next[i][1] * k;\n        }\n        if (d.x < 1 || d.x > 2 || d.y < 1) continue;\n        if (Map[d.x][d.y] == 'X') continue;\n        if (d.y <= d.stemp) continue;\n        if (book[d.x][d.y] == 1) continue;\n        q.push(d);\n        book[d.x][d.y] = 1;\n      }\n    }\n    if (f == 0) printf(\"NO\\n\");\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class jumpingOnWalls {\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer s1 = new StringTokenizer(in.readLine());\n\t\tint size = Integer.parseInt(s1.nextToken());\n\t\tint jump = Integer.parseInt(s1.nextToken());\n\t\tchar[][] grid = new char[][]{in.readLine().toCharArray(), in.readLine().toCharArray()};\n\t\tboolean[][] visited = new boolean[2][size];\n\t\tint[][] dist = new int[2][size];\n\t\tQueue<Integer> vals = new LinkedList<Integer>();\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\tq.add(0);\n\t\tvals.add(0);\n\t\tboolean done = false;\n\t\twhile (!q.isEmpty()) {\n\t\t\tint b = q.remove();\n\t\t\tint c = vals.remove();\n\t\t\tif (!visited[b/size][b%size] && b%size >= c) {\n\t\t\t\tint x= b/size;\n\t\t\t\tint y = b%size;\n\t\t\t\tvisited[b/size][b%size] = true;\n\t\t\t\tif (b%size+Math.max(jump,1) >= size) {\n\t\t\t\t\tdone = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (b%size+1 < size && grid[b/size][b%size+1] == '-' && !visited[b/size][b%size+1]) {\n\t\t\t\t\tq.add(b+1);\n\t\t\t\t\tvals.add(c+1);\n\t\t\t\t}\n\t\t\t\tif (b%size-1 >= 0 && grid[b/size][b%size-1] == '-' && !visited[b/size][b%size-1]) {\n\t\t\t\t\tq.add(b-1);\n\t\t\t\t\tvals.add(c+1);\n\t\t\t\t}\n\t\t\t\tif (b%size+jump < size && grid[1-b/size][b%size+jump] == '-' && !visited[1-b/size][b%size+jump]) {\n\t\t\t\t\tq.add(size*(1-b/size)+b%size+jump);\n\t\t\t\t\tvals.add(c+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (visited[0][size-1] || visited[1][size-1] || done) {\n\t\t\tSystem.out.println(\"YES\");\n\t\t} else {\n\t\t\tSystem.out.println(\"NO\");\n\t\t}\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Main\n{\n    static class Reader \n    { \n        private InputStream mIs;private byte[] buf = new byte[1024];private int curChar,numChars;public Reader() { this(System.in); }public Reader(InputStream is) { mIs = is;} \n        public int read() {if (numChars == -1) throw new InputMismatchException();if (curChar >= numChars) {curChar = 0;try { numChars = mIs.read(buf);} catch (IOException e) { throw new InputMismatchException();}if (numChars <= 0) return -1; }return buf[curChar++];} \n        public String nextLine(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isEndOfLine(c));return res.toString() ;} \n        public String s(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isSpaceChar(c));return res.toString();} \n        public long l(){int c = read();while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }long res = 0; do{ if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read();}while(!isSpaceChar(c));return res * sgn;} \n        public int i(){int c = read() ;while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }int res = 0;do{if (c < '0' || c > '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read() ;}while(!isSpaceChar(c));return res * sgn;} \n        public double d() throws IOException {return Double.parseDouble(s()) ;}\n        public boolean isSpaceChar(int c) { return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1; } \n        public boolean isEndOfLine(int c) { return c == '\\n' || c == '\\r' || c == -1; } \n        public int[] arr(int n){int[] ret = new int[n];for (int i = 0; i < n; i++) {ret[i] = i();}return ret;}\n    }\n    \n    \n \n           //       |----|       /\\      |    |   -----   |\n           //       |   /       /  \\     |    |     |     |\n           //       |--/       /----\\    |----|     |     |\n           //       |   \\     /      \\   |    |     |     |\n           //       |    \\   /        \\  |    |   -----   -------\n           \n    static int n,k;\n    static String arr[];\n    static class pair \n    {\n       int x;\n       int y;\n       public pair (int k, int p) \n       {\n           x = k;\n           y = p;\n       }\n    }\n    public static void main(String[] args)throws IOException\n    {\n        PrintWriter out= new PrintWriter(System.out);\n        Reader sc=new Reader();\n        n=sc.i();\n        k=sc.i();\n        arr=new String[2];\n        arr[0]=sc.s();arr[1]=sc.s();\n        Queue<pair> q=new LinkedList<>();\n        Queue<Integer> dis=new LinkedList<>();\n        int min[][]=new int[n][2];\n        for(int i=0;i<n;i++)Arrays.fill(min[i],1000000000);\n        q.add(new pair(0,0));\n        dis.add(0);\n        min[0][0]=0;\n        while(q.size()!=0)\n        {\n            pair p=q.remove();\n            int d=dis.remove();\n            if(p.x+k>=n)continue;\n            if(arr[p.y].charAt(p.x+1)=='-'&&min[p.x+1][p.y]>d+1)\n            {\n                min[p.x+1][p.y]=d+1;\n                q.add(new pair(p.x+1,p.y));\n                dis.add(d+1);\n            }\n            if(p.x!=0&&arr[p.y].charAt(p.x-1)=='-'&&min[p.x-1][p.y]>d+1)\n            {\n                min[p.x-1][p.y]=d+1;\n                q.add(new pair(p.x-1,p.y));\n                dis.add(d+1);\n            }\n            if(arr[p.y^1].charAt(p.x+k)=='-'&&min[p.x+k][p.y^1]>d+1)\n            {\n                min[p.x+k][p.y^1]=d+1;\n                q.add(new pair(p.x+k,p.y^1));\n                dis.add(d+1);\n            }\n        }\n        int mini=1000000000;\n        pair p=new pair(0,0);\n        for(int i=n-1;i>=Math.max(0,n-k);i--)\n        {\n            for(int j=0;j<2;j++)\n                if(mini>min[i][j])\n                {\n                    mini=min[i][j];\n                    p=new pair(i,j);\n                }\n        }\n        /*for(int i=0;i<2;i++)\n        {\n            for(int j=0;j<n;j++)\n            System.out.print(min[j][i]+\" \");\n            System.out.println();\n        }*/\n        if(mini==1000000000||p.x-mini<0)\n        {\n            System.out.println(\"NO\");\n            System.exit(0);\n        }\n        int flag=0;\n        while(!(p.x==0&&p.y==0))\n        {\n            mini--;\n            pair temp=new pair(0,0);\n            if(p.x!=n-1&&min[p.x+1][p.y]==mini)\n            temp=new pair(p.x+1,p.y);\n            if(p.x!=0&&min[p.x-1][p.y]==mini)\n            temp=new pair(p.x-1,p.y);\n            if(p.x-k>=0&&min[p.x-k][p.y^1]==mini)\n            temp=new pair(p.x-k,p.y^1);\n            if(temp.x-mini<0)\n            {\n                flag=1;\n                break;\n            }\n            p=temp;\n            //System.out.println(temp.x+\" \"+temp.y+\" \"+mini);\n        }\n        if(flag==1)out.println(\"NO\");\n        else out.println(\"YES\");\n        \n        out.flush();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int mod = 1e9 + 7;\nlong long int n, k, vis[300005] = {0}, d[300005] = {0};\nstring lft, rgt;\nqueue<long long int> q;\nvector<long long int> v[300005];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long int i, j, x, y;\n  cin >> n >> k;\n  cin >> lft;\n  cin >> rgt;\n  if (k < n && rgt[k] == '-') v[1].push_back(k + 1 + n);\n  for (i = 1; i < n; i++) {\n    if (lft[i] == 'X') continue;\n    if (lft[i - 1] != 'X') {\n      v[i + 1].push_back(i);\n      v[i].push_back(i + 1);\n    }\n    if (i + k < n && rgt[i + k] == '-') v[i + 1].push_back(i + k + 1 + n);\n  }\n  if (k < n && lft[k] == '-') v[n + 1].push_back(k + 1);\n  for (i = 1; i < n; i++) {\n    if (rgt[i] == 'X') continue;\n    if (rgt[i - 1] != 'X') {\n      v[i + n + 1].push_back(i + n);\n      v[i + n].push_back(i + n + 1);\n    }\n    if (i + k < n && lft[i + k] == '-') v[i + n + 1].push_back(i + k + 1);\n  }\n  q.push(1);\n  d[1] = 0;\n  vis[1] = 1;\n  while (!q.empty()) {\n    long long int i, s = q.front();\n    q.pop();\n    for (i = 0; i < v[s].size(); i++) {\n      if (!vis[v[s][i]]) {\n        if ((v[s][i] >= 1 && v[s][i] <= n && d[s] + 1 < v[s][i]) ||\n            (v[s][i] >= n + 1 && v[s][i] <= 2 * n && d[s] + 1 < v[s][i] - n)) {\n          vis[v[s][i]] = 1;\n          d[v[s][i]] = d[s] + 1;\n          q.push(v[s][i]);\n        }\n      }\n    }\n  }\n  if (vis[n] || vis[2 * n]) {\n    cout << \"YES\";\n    return 0;\n  }\n  for (i = n; i >= n - k; i--) {\n    if (vis[i] && (rgt[i + k - 1] == '-' || i + k + n > 2 * n)) {\n      cout << \"YES\";\n      return 0;\n    }\n  }\n  for (i = 2 * n; i >= n + n - k; i--) {\n    if (vis[i] && (lft[i + k - 1 - n] == '-' || i + k - n > n)) {\n      cout << \"YES\";\n      return 0;\n    }\n  }\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar a[5][100005];\nint ok[5][100005];\nqueue<int> Q;\nint ans = 0, n, k;\nvoid judge(int x, int y, int t) {\n  if (y < t || y <= 0) return;\n  if (y > n) {\n    ans = 1;\n    return;\n  }\n  if (ok[x][y] || a[x][y] == 'X') return;\n  ok[x][y] = t;\n  Q.push(x);\n  Q.push(y);\n}\nint main() {\n  int x, y, t;\n  ok[0][1] = 1;\n  scanf(\"%d %d\", &n, &k);\n  scanf(\"%s %s\", a[0] + 1, a[1] + 1);\n  Q.push(0);\n  Q.push(1);\n  while (!ans && !Q.empty()) {\n    x = Q.front();\n    Q.pop();\n    y = Q.front();\n    Q.pop();\n    t = ok[x][y];\n    judge(x, y - 1, t + 1);\n    judge(x, y + 1, t + 1);\n    judge(!x, y + k, t + 1);\n  }\n  if (ans)\n    printf(\"YES\\n\");\n  else\n    printf(\"NO\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, d[100010][2];\nbool u[100010][2];\npair<int, int> q[100010 * 2];\nint qb, qf;\nchar s1[100010], s2[100010];\nbool inq(int i, int j, int dd) {\n  if (i < 0) return false;\n  if (dd > i) return false;\n  if (i >= n) return true;\n  if (j == 0 && s1[i] == 'X') return false;\n  if (j == 1 && s2[i] == 'X') return false;\n  if (u[i][j]) return false;\n  u[i][j] = true;\n  d[i][j] = dd;\n  q[qf++] = pair<int, int>(i, j);\n  return false;\n}\nint main() {\n  scanf(\"%d %d\", &n, &k);\n  scanf(\"%s\", s1);\n  scanf(\"%s\", s2);\n  inq(0, 0, 0);\n  bool flag = false;\n  while (qb < qf) {\n    pair<int, int> cur = q[qb++];\n    int dd = d[cur.first][cur.second];\n    flag |= inq(cur.first + 1, cur.second, dd + 1);\n    flag |= inq(cur.first - 1, cur.second, dd + 1);\n    flag |= inq(cur.first + k, 1 - cur.second, dd + 1);\n    if (flag) break;\n  }\n  if (flag)\n    printf(\"YES\\n\");\n  else\n    printf(\"NO\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 10;\nint d[MAXN];\nint visited[MAXN];\nset<int> adj[MAXN];\nint n, k;\nbool isPos;\nbool isExit(int v) {\n  if (v >= n) v -= n;\n  if (v + 1 >= n) return 1;\n  if (v + k >= n) return 1;\n  return 0;\n}\nbool isReach(int v) {\n  int sup = v;\n  if (v >= n) v -= n;\n  if (v + 1 > d[sup]) return 1;\n  return 0;\n}\nvoid dfs(int v) {\n  if (isExit(v)) isPos = true;\n  visited[v] = 1;\n  for (int u : adj[v])\n    if (!visited[u] && isReach(u)) dfs(u);\n}\nvoid bfs() {\n  memset(d, 63, sizeof d);\n  queue<int> q;\n  d[0] = 0;\n  q.push(0);\n  while (!q.empty()) {\n    int v = q.front();\n    q.pop();\n    for (auto u : adj[v])\n      if (d[u] > d[v] + 1) {\n        d[u] = d[v] + 1;\n        q.push(u);\n      }\n  }\n}\nint main() {\n  cin >> n >> k;\n  string s1;\n  cin >> s1;\n  string s2;\n  cin >> s2;\n  for (int i = 0; i < n; i++) {\n    if (i + 1 < n && s1[i] != 'X' && s1[i + 1] != 'X') {\n      adj[i].insert(i + 1);\n      adj[i + 1].insert(i);\n    }\n    if (i + n + k < 2 * n && s1[i] != 'X' && s2[i + k] != 'X')\n      adj[i].insert(i + n + k);\n  }\n  for (int i = n; i < 2 * n; i++) {\n    if (i + 1 < 2 * n && s2[i - n] != 'X' && s2[i - n + 1] != 'X') {\n      adj[i].insert(i + 1);\n      adj[i + 1].insert(i);\n      if (i - n + k + 1 < n && s1[i - n + k + 1] != 'X')\n        adj[i + 1].insert(i - n + k + 1);\n    }\n    if (i - 1 >= n && s2[i - n] != 'X' && s2[i - n - 1] != 'X') {\n      adj[i].insert(i - 1);\n      adj[i - 1].insert(i);\n      if (i - n + k - 1 < n && s1[i - n + k - 1] != 'X')\n        adj[i - 1].insert(i - n + k - 1);\n    }\n    if (i - n + k < n && s2[i - n] != 'X' && s1[i - n + k] != 'X')\n      adj[i].insert(i - n + k);\n  }\n  bfs();\n  dfs(0);\n  if (isPos)\n    cout << \"YES\";\n  else\n    cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int INF = (int)(1e9);\nconst long long INFLL = (long long)(1e18);\nconst double EPS = 1e-13;\nusing namespace std;\nint n, k;\nstring walls[2];\nbool visited[2][200000 + 10];\nbool valid(int w, int y, int water) {\n  if (y < 0) return false;\n  if (y < water) return false;\n  if (visited[w][y]) return false;\n  if (y >= n) return true;\n  if (walls[w][y] == 'X') return false;\n  return true;\n}\nbool search() {\n  memset(visited, false, sizeof(visited));\n  queue<pair<int, pair<int, int> > > Q;\n  if (valid(0, 0, 0)) {\n    Q.push(make_pair(0, make_pair(0, 0)));\n    visited[0][0] = true;\n  }\n  while (!Q.empty()) {\n    int w = Q.front().first;\n    int y = Q.front().second.first;\n    int water = Q.front().second.second;\n    Q.pop();\n    if (y + k >= n) return true;\n    if (valid(w, y - 1, water + 1)) {\n      Q.push(make_pair(w, make_pair(y - 1, water + 1)));\n      visited[w][y - 1] = true;\n    }\n    if (valid(w, y + 1, water + 1)) {\n      Q.push(make_pair(w, make_pair(y + 1, water + 1)));\n      visited[w][y + 1] = true;\n    }\n    int nw = w ^ 1;\n    if (valid(nw, y + k, water + 1)) {\n      Q.push(make_pair(nw, make_pair(y + k, water + 1)));\n      visited[nw][y + k] = true;\n    }\n  }\n  return false;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin >> n >> k >> walls[0] >> walls[1];\n  cout << (search() ? \"YES\" : \"NO\") << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int BIG = 1e5 + 9;\nconst int INF = 1e9 + 9;\nconst long long BINF = 1e18 + 9;\nconst double SML = (1e-7);\nint n, k;\nchar a[3][BIG];\nbool valid(int x, int y, int water_level) {\n  return x >= 0 && x <= 1 && y >= 0 && y > water_level;\n}\nbool bfs(int x, int y, int dx[], int dy[]) {\n  queue<pair<pair<int, int>, int> > q;\n  bool visited[3][BIG] = {0};\n  visited[x][y] = true;\n  q.push({{x, y}, -1});\n  while (!q.empty()) {\n    pair<int, int> p = q.front().first;\n    int water_level = q.front().second;\n    q.pop();\n    for (int i = 0; i < 4; i++) {\n      int tox = p.first + dx[i];\n      int toy = p.second + dy[i];\n      if (valid(tox, toy, water_level + 1)) {\n        if (toy > n - 1) {\n          return true;\n        }\n        if (!visited[tox][toy] && a[tox][toy] != 'X') {\n          visited[tox][toy] = true;\n          q.push({{tox, toy}, water_level + 1});\n        }\n      }\n    }\n  }\n  return false;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  int dx[] = {-1, 1, 0, 0}, dy[] = {k, k, -1, 1};\n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < n; j++) {\n      cin >> a[i][j];\n    }\n  }\n  bool ans = bfs(0, 0, dx, dy);\n  if (ans) {\n    cout << \"YES\";\n  } else {\n    cout << \"NO\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class D {\n\n    public static void main(String[] args) throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[]s = br.readLine().split(\" \");\n        int n = Integer.parseInt(s[0]);\n        int k = Integer.parseInt(s[1]);\n        char[][]a = new char[2][n];\n        for (int i = 0; i < 2; i++) {\n            a[i] = br.readLine().toCharArray();\n        }\n        boolean[][] used = new boolean[2][n];\n        used[0][0] = true;\n        int[][]st = new int[2*n+2][3];\n        int head = 0, tail = 1;\n        int[]dh = {-1, 1};\n        while (head < tail) {\n            head++;\n            int side = st[head][0];\n            int step = st[head][1];\n            int h = st[head][2];\n            if (step > h)\n                continue;\n            if (h >= n-k) {\n                System.out.println(\"YES\");\n                return;\n            }\n            for (int i = 0; i < 2; i++) {\n                int hh = h+dh[i];\n                if (hh >= 0 && hh < n && a[side][hh]=='-' && !used[side][hh]) {\n                    tail++;\n                    st[tail][0] = side;\n                    st[tail][1] = step+1;\n                    st[tail][2] = hh;\n                    used[side][hh] = true;\n                }\n            }\n            if (h+k < n && a[1-side][h+k]=='-' && !used[1-side][h+k]) {\n                tail++;\n                st[tail][0] = 1-side;\n                st[tail][1] = step+1;\n                st[tail][2] = h+k;\n                used[1-side][h+k] = true;\n            }\n        }\n        System.out.println(\"NO\");\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod1 = 998244353;\nconst long long mod2 = 1000000007;\nstring l, r;\nint d[2][100005];\nqueue<int> q;\nint main() {\n  int n, k;\n  cin >> n >> k >> l >> r;\n  for (int i = 0; i < (2); i++)\n    for (int j = 0; j < (n); j++) d[i][j] = 2e9;\n  d[0][0] = 0;\n  q.push(0);\n  q.push(0);\n  while (!q.empty()) {\n    int sd = q.front();\n    q.pop();\n    int h = q.front();\n    q.pop();\n    int t = d[sd][h];\n    if (h + k >= n) {\n      cout << \"YES\\n\";\n      return 0;\n    }\n    if ((sd == 0 && l[h + 1] == '-') || (sd == 1 && r[h + 1] == '-'))\n      if (d[sd][h + 1] == 2e9) {\n        d[sd][h + 1] = t + 1;\n        q.push(sd);\n        q.push(h + 1);\n      }\n    if ((h - 1 >= t + 1) &&\n        ((sd == 0 && l[h - 1] == '-') || (sd == 1 && r[h - 1] == '-')))\n      if (d[sd][h - 1] == 2e9) {\n        d[sd][h - 1] = t + 1;\n        q.push(sd);\n        q.push(h - 1);\n      }\n    if ((sd == 0 && r[h + k] == '-') || (sd == 1 && l[h + k] == '-'))\n      if (d[!sd][h + k] == 2e9) {\n        d[!sd][h + k] = t + 1;\n        q.push(!sd);\n        q.push(h + k);\n      }\n  }\n  cout << \"NO\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n//package CP;\nimport java.io.*;\nimport java.util.*;\npublic class B198 \n{\n    int pos,wall;\n    public B198(int w,int p)\n    {\n        this.pos=p;\n        this.wall=w;\n    }\n    public static void main(String args[])throws IOException\n    {\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int k=sc.nextInt();\n        String s1=sc.next();\n        String s2=sc.next();\n        char ch[][]=new char[2][n+1];\n        for(int i=1;i<=n;i++)\n        {\n            ch[0][i]=s1.charAt(i-1);\n            ch[1][i]=s2.charAt(i-1);\n        }\n        boolean vis[][]=new boolean[2][n+1];\n        vis[0][1]=true;\n        Queue<B198> q=new LinkedList<>();\n        q.add(new B198(0,1));\n        int esc=n+1-k,f=0,c=1,ff=1,cou=0;\n        while(q.size()!=0)\n        {\n            B198 ob=q.poll();\n            ff--;\n            if(ob.pos>=esc)\n            {\n                f=1;\n                break;\n            }\n            //System.out.println(ob.wall+\" \"+ob.pos);\n            int w=ob.wall;\n            if(ch[w][ob.pos+1]=='-' && !vis[w][ob.pos+1])\n            {\n                q.add(new B198(w,ob.pos+1));\n                vis[w][ob.pos+1]=true;\n                cou++;\n                //System.out.println(w+\" 1\");\n            }\n            if(ch[w][ob.pos-1]=='-' && !vis[w][ob.pos-1] && ob.pos-1 >c)\n            {\n                q.add(new B198(w,ob.pos-1));\n                vis[w][ob.pos-1]=true;\n                cou++;\n                //System.out.println(w+\" 2\");\n            }\n            if(ch[1-w][ob.pos+k]=='-' && !vis[1-w][ob.pos+k])\n            {\n                q.add(new B198(1-w,ob.pos+k));\n                vis[1-w][ob.pos+k]=true;\n                cou++;\n                //System.out.println(w+\" 3\");\n            }\n            if(ff==0)\n            {\n                c++;\n                ff=cou;\n                cou=0;\n            }\n        }\n        if(f==1)\n            System.out.println(\"YES\");\n        else\n            System.out.println(\"NO\");\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint ABS(int a) {\n  if (a < 0) return (-a);\n  return a;\n}\nint main() {\n  string s[2];\n  int n, k;\n  cin >> n >> k;\n  cin >> s[0] >> s[1];\n  bool vis[2][200005] = {0};\n  bool ans = false;\n  queue<pair<int, int> > q;\n  queue<int> dq;\n  q.push(pair<int, int>(0, 0));\n  dq.push(0);\n  vis[0][0] = true;\n  while (!q.empty()) {\n    pair<int, int> x = q.front();\n    int depth = dq.front();\n    q.pop();\n    dq.pop();\n    bool wall = x.first;\n    int idx = x.second;\n    if (idx + k > n) {\n      ans = true;\n      break;\n    }\n    if (!vis[wall][idx + 1]) {\n      if (idx + 1 >= depth + 1) {\n        if (idx + 1 < n && s[wall][idx + 1] == 'X')\n          ;\n        else {\n          q.push(pair<int, int>(wall, idx + 1));\n          dq.push(depth + 1);\n          vis[wall][idx + 1] = true;\n        }\n      }\n    }\n    if (idx - 1 > 0 && !vis[wall][idx - 1]) {\n      if (idx - 1 >= depth + 1) {\n        if (idx - 1 >= 0 && s[wall][idx - 1] == 'X')\n          ;\n        else {\n          q.push(pair<int, int>(wall, idx - 1));\n          dq.push(depth + 1);\n          vis[wall][idx - 1] = true;\n        }\n      }\n    }\n    if (!vis[!wall][idx + k]) {\n      if (idx + k >= depth + 1) {\n        if (idx + k < n && s[!wall][idx + k] == 'X')\n          ;\n        else {\n          q.push(pair<int, int>(!wall, idx + k));\n          dq.push(depth + 1);\n          vis[!wall][idx + k] = true;\n        }\n      }\n    }\n  }\n  cout << (ans ? \"YES\" : \"NO\") << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, fin, dist[200002];\nstring sl, sr;\nvector<int> g[200002];\nqueue<int> q;\nint main() {\n  cin >> n >> k >> sl >> sr;\n  fill_n(dist + 2, 2 * n, INT_MAX);\n  fin = 2 * n + 1;\n  for (int i = 0; i < n; i++) {\n    if (sl[i] != 'X') {\n      if (i < n - 1 and sl[i + 1] != 'X')\n        g[i + 1].push_back(i + 2), g[i + 2].push_back(i + 1);\n      if (i + k < n and sr[i + k] != 'X') g[i + 1].push_back(n + i + k + 1);\n      if (i >= n - k) g[i + 1].push_back(fin);\n    }\n    if (sr[i] != 'X') {\n      if (i < n - 1 and sr[i + 1] != 'X')\n        g[n + i + 1].push_back(n + i + 2), g[n + i + 2].push_back(n + i + 1);\n      if (i + k < n and sl[i + k] != 'X') g[n + i + 1].push_back(i + k + 1);\n      if (i >= n - k) g[n + i + 1].push_back(fin);\n    }\n  }\n  q.push(1);\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n    if (dist[u] >= ((u > n) ? u - n : u)) {\n      dist[u] = INT_MAX;\n      continue;\n    }\n    for (int v : g[u])\n      if (dist[v] == INT_MAX) dist[v] = dist[u] + 1, q.push(v);\n  }\n  if (dist[fin] != INT_MAX)\n    printf(\"YES\");\n  else\n    printf(\"NO\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, x, y, a[2][100100], water;\nstring s;\nbool vis[2][100100];\nint main() {\n  scanf(\"%d %d\", &n, &k);\n  for (int i = 0; i < 2; i++) {\n    cin >> s;\n    for (int j = 0; j < n; j++) {\n      if (s[j] == 'X') a[i][j] = 1;\n    }\n  }\n  queue<pair<pair<int, int>, int> > q;\n  q.push(make_pair(make_pair(0, 0), -1));\n  vis[0][0] = 1;\n  while (!q.empty()) {\n    y = q.front().first.first;\n    x = q.front().first.second;\n    water = q.front().second;\n    q.pop();\n    if (x + 1 == n || x + k >= n) {\n      cout << \"YES\" << endl;\n      return 0;\n    }\n    if (x > 0 && a[y][x - 1] == 0 && water + 1 < x - 1 && !vis[y][x - 1]) {\n      q.push(make_pair(make_pair(y, x - 1), water + 1));\n      vis[y][x - 1] = 1;\n    }\n    if (a[y][x + 1] == 0 && !vis[y][x + 1]) {\n      q.push(make_pair(make_pair(y, x + 1), water + 1));\n      vis[y][x + 1] = 1;\n    }\n    if (a[1 - y][x + k] == 0 && !vis[1 - y][x + k]) {\n      q.push(make_pair(make_pair(1 - y, x + k), water + 1));\n      vis[1 - y][x + k] = 1;\n    }\n  }\n  cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma warning(disable : 4996)\nconst int INF = 2147483647;\ntemplate <class T>\nint size(T& x) {\n  return x.size();\n}\nint leng;\nint k;\nstring cols[2];\nbool vis[2][100010];\nbool bfs(pair<pair<int, int>, int> source) {\n  queue<pair<pair<int, int>, int>> q;\n  q.push(source);\n  while (!q.empty()) {\n    int cur = q.front().first.first;\n    int level = q.front().first.second;\n    int i = q.front().second;\n    q.pop();\n    if (level + k > leng - 1) return 1;\n    if (!vis[cur][level + 1] && (cols[cur][level + 1] == '-'))\n      q.push(make_pair(make_pair(cur, level + 1), i + 1));\n    vis[cur][level + 1] = 1;\n    if ((level - 1 > i) && (level > 0) && !vis[cur][level - 1] &&\n        (cols[cur][level - 1] == '-')) {\n      q.push(make_pair(make_pair(cur, level - 1), i + 1));\n    } else if (level > 0)\n      vis[cur][level - 1] = 1;\n    cur = (cur == 1) ? 0 : 1;\n    if (!vis[cur][level + k] && (cols[cur][level + k] == '-'))\n      q.push(make_pair(make_pair(cur, level + k), i + 1));\n    vis[cur][level + k] = 1;\n  }\n  return 0;\n}\nint main() {\n  cin >> leng >> k >> cols[0] >> cols[1];\n  bool f = bfs(make_pair(make_pair(0, 0), 0));\n  f ? cout << \"YES\" : cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n//\tstatic Scanner in; static int next() throws Exception {return in.nextInt();};\n//\tstatic StreamTokenizer in; static int next() throws Exception {in.nextToken(); return (int) in.nval;}\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\n\tpublic static void main(String[] args) throws Exception {\n//\t\tin = new Scanner(System.in);\n//\t\tin = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\n\t\tString[] token = in.readLine().split(\" \");\n\t\tint n = Integer.parseInt(token[0]);\n\t\tint k = Integer.parseInt(token[1]);\n\n\t\tchar[][] c = new char[2][n];\n\t\tc[0] = in.readLine().toCharArray();\n\t\tc[1] = in.readLine().toCharArray();\n\n\t\tint[] h = new int[2*n];\n\t\tint[] wall = new int[2*n];\n\t\tint[] time = new int[2*n];\n\n\t\tint ind = 0;\n\t\th[0] = 0;\n\t\twall[0] = 0;\n\t\ttime[0] = 0;\n\n\t\tboolean[][] take = new boolean[2][n];\n\t\ttake[wall[ind]][h[ind]] = true;\n\n\t\tind++;\n\t\t\n\t\tboolean flag = false;\n\n\t\tfor (int i = 0; i < ind; i++) {\n\t\t\tint newh = h[i] + 1;\n\t\t\tint newwall = wall[i];\n\t\t\tint newtime = time[i] + 1;\n\t\t\t\n\t\t\tif (newh >= n) flag = true;\n\t\t\telse if (!take[newwall][newh] && newtime <= newh && c[newwall][newh] == '-') {\n\t\t\t\th[ind] = newh;\n\t\t\t\twall[ind] = newwall;\n\t\t\t\ttime[ind] = newtime;\n\t\t\t\ttake[newwall][newh] = true;\n\t\t\t\tind++;\n\t\t\t}\n//\t\t\tout.println(newh + \" \" + newwall + \" \" + newtime);\n\n\t\t\tnewh = h[i] - 1;\n\t\t\tnewwall = wall[i];\n\t\t\tnewtime = time[i] + 1;\n\t\t\t\n\t\t\tif (newh >= n) flag = true;\n\t\t\telse if (newh >= 0 && !take[newwall][newh] && newtime <= newh && c[newwall][newh] == '-') {\n\t\t\t\th[ind] = newh;\n\t\t\t\twall[ind] = newwall;\n\t\t\t\ttime[ind] = newtime;\n\t\t\t\ttake[newwall][newh] = true;\n\t\t\t\tind++;\n\t\t\t}\n//\t\t\tout.println(newh + \" \" + newwall + \" \" + newtime);\n\n\t\t\tnewh = h[i] + k;\n\t\t\tnewwall = wall[i] ^ 1;\n\t\t\tnewtime = time[i] + 1;\n\t\t\t\n\t\t\tif (newh >= n) flag = true;\n\t\t\telse if (!take[newwall][newh] && newtime <= newh && c[newwall][newh] == '-') {\n\t\t\t\th[ind] = newh;\n\t\t\t\twall[ind] = newwall;\n\t\t\t\ttime[ind] = newtime;\n\t\t\t\ttake[newwall][newh] = true;\n\t\t\t\tind++;\n\t\t\t}\n//\t\t\tout.println(newh + \" \" + newwall + \" \" + newtime);\n\n\t\t}\n\n/*\t\tfor (int i = 0; i < ind; i++) {\n\t\t\tout.println(wall[i] + \" \" + h[i] + \" \" + time[i]);\n\t\t}*/\n\n\t\tout.println(flag ? \"YES\" : \"NO\");\n\n\n\t\tout.close();\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, fin, dist[200002];\nstring sl, sr;\nvector<int> g[200002];\nqueue<int> q;\nint main() {\n  cin >> n >> k >> sl >> sr;\n  fill_n(dist + 2, 2 * n, INT_MAX);\n  fin = 2 * n + 1;\n  for (int i = 0; i < n; i++) {\n    if (sl[i] != 'X') {\n      if (i < n - 1 and sl[i + 1] != 'X')\n        g[i + 1].push_back(i + 2), g[i + 2].push_back(i + 1);\n      if (i + k < n and sr[i + k] != 'X') g[i + 1].push_back(n + i + k + 1);\n      if (i >= n - k) g[i + 1].push_back(fin);\n    }\n    if (sr[i] != 'X') {\n      if (i < n - 1 and sr[i + 1] != 'X')\n        g[n + i + 1].push_back(n + i + 2), g[n + i + 2].push_back(n + i + 1);\n      if (i + k < n and sl[i + k] != 'X') g[n + i + 1].push_back(i + k + 1);\n      if (i >= n - k) g[n + i + 1].push_back(fin);\n    }\n  }\n  q.push(1);\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n    if (dist[u] >= ((u > n) ? u - n : u)) {\n      dist[u] = INT_MAX;\n      continue;\n    }\n    for (int v : g[u])\n      if (dist[v] == INT_MAX) dist[v] = dist[u] + 1, q.push(v);\n  }\n  if (dist[fin] != INT_MAX)\n    printf(\"YES\");\n  else\n    printf(\"NO\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar a[2][1000010];\nint f[2][1000010], qx[2000020], qy[2000020], fi, fr, x, y, k, n;\nint main() {\n  cin >> n >> k;\n  cin >> a[0];\n  cin >> a[1];\n  f[0][0] = 1;\n  for (fr = 1; fi < fr;) {\n    x = qx[fi];\n    y = qy[fi++];\n    if (y >= n - k) {\n      cout << \"YES\";\n      return 0;\n    }\n    if (y > 0 && a[x][y - 1] == '-' && f[x][y - 1] == 0 && y > f[x][y])\n      f[x][y - 1] = f[x][y] + 1, qx[fr] = x, qy[fr++] = y - 1;\n    if (a[x][y + 1] == '-' && f[x][y + 1] == 0)\n      f[x][y + 1] = f[x][y] + 1, qx[fr] = x, qy[fr++] = y + 1;\n    if (a[1 - x][y + k] == '-' && f[1 - x][y + k] == 0)\n      f[1 - x][y + k] = f[x][y] + 1, qx[fr] = 1 - x, qy[fr++] = y + k;\n  }\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nbool checkSurvive(char f[], char s[], int pos, int flooded) {\n  if (pos < 0) {\n    return false;\n  }\n  if (flooded >= pos) {\n    return false;\n  }\n  if (pos > n - 1) {\n    return true;\n  }\n  if (f[pos] != '-') {\n    return false;\n  }\n  f[pos] = 'a';\n  bool jump = checkSurvive(s, f, pos + k, flooded + 1);\n  if (jump) {\n    return true;\n  }\n  bool next = checkSurvive(f, s, pos + 1, flooded + 1);\n  if (next) {\n    return true;\n  }\n  bool prev = checkSurvive(f, s, pos - 1, flooded + 1);\n  if (prev) {\n    return true;\n  }\n  return false;\n}\nint main() {\n  cin >> n >> k;\n  char first[n + 5];\n  char second[n + 5];\n  cin >> first;\n  cin >> second;\n  bool f = checkSurvive(first, second, 0, -1);\n  if (f) {\n    cout << \"YES\" << '\\n';\n  } else {\n    cout << \"NO\" << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, k;\n  cin >> n >> k;\n  int a[3][n + 1];\n  for (int i = 1; i <= 2; i++) {\n    string s;\n    cin >> s;\n    for (int j = 0; j < n; j++) {\n      if (s[j] == '-') {\n        a[i][j + 1] = 1;\n      } else {\n        a[i][j + 1] = 0;\n      }\n    }\n  }\n  queue<pair<int, pair<int, int>>> q;\n  q.push({1, {1, 0}});\n  vector<vector<int>> vis(3, vector<int>(n + 1, 0));\n  vis[1][1] = 1;\n  int flag = 0;\n  while (!q.empty()) {\n    pair<int, pair<int, int>> p = q.front();\n    q.pop();\n    if (p.second.first >= n || p.second.first + 1 > n ||\n        p.second.first + k > n) {\n      flag = 1;\n      break;\n    }\n    if (p.second.first + 1 > p.second.second + 1 &&\n        a[p.first][p.second.first + 1] == 1 &&\n        vis[p.first][p.second.first + 1] == 0) {\n      vis[p.first][p.second.first + 1] = 1;\n      q.push({p.first, {p.second.first + 1, p.second.second + 1}});\n    }\n    if (p.second.first - 1 >= 1)\n      if (p.second.first - 1 > p.second.second + 1 &&\n          a[p.first][p.second.first - 1] == 1 &&\n          vis[p.first][p.second.first - 1] == 0) {\n        vis[p.first][p.second.first - 1] = 1;\n        q.push({p.first, {p.second.first - 1, p.second.second + 1}});\n      }\n    int jump = p.first == 1 ? 2 : 1;\n    if (p.second.first + k > p.second.second + 1 &&\n        a[jump][p.second.first + k] == 1 &&\n        vis[jump][p.second.first + k] == 0) {\n      vis[jump][p.second.first + k] = 1;\n      q.push({jump, {p.second.first + k, p.second.second + 1}});\n    }\n  }\n  if (flag == 1) {\n    cout << \"YES\\n\";\n  } else {\n    cout << \"NO\\n\";\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\n\npublic class D implements Runnable {\n\n    public static final char WALL = '-';\n    public static final char DANGEROUS_WALL = 'X';\n\n    public static final int LEFT_WALL = 0;\n    public static final int RIGHT_WALL = 1;\n    \n    private PrintWriter out = new PrintWriter(System.out, true);\n    private BufferedReader reader;\n    \n    private int n, k;\n    private char[][] walls;\n    private boolean[][] visit;\n\n    @Override\n    public void run() {\n        try {\n            String[] first = reader.readLine().split(\"\\\\s+\");\n            n = Integer.parseInt(first[0]);\n            k = Integer.parseInt(first[1]);\n            \n            char[] left = reader.readLine().toCharArray();\n            char[] right = reader.readLine().toCharArray();\n            walls = new char[][] { left, right };\n            visit = new boolean[2][n];\n            \n            boolean res = calc();\n            out.println(res ? \"YES\" : \"NO\");\n            out.flush();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public boolean calc() {\n        return dfs(0, LEFT_WALL, 0);\n    }\n\n    public boolean dfs(int position, int wallSide, int waterLevel) {\n        if (position >= n - 1) {\n            return true;\n        }\n\n        if (position < waterLevel) {\n            return false;\n        }\n        \n        int jumpPosition = position + k;\n        if (jumpPosition >= n) {\n            return true;\n        }\n        \n        visit[wallSide][position] = true;\n        \n        int oppositeWall = (wallSide + 1) % 2;\n        int newWaterLevel = waterLevel + 1;\n\n        return step(jumpPosition, oppositeWall, newWaterLevel) || step(position + 1, wallSide, newWaterLevel)\n                || step(position - 1, wallSide, newWaterLevel);\n    }\n\n    private boolean step(int jumpPosition, int oppositeWall, int newWaterLevel) {\n        if (canProceed(jumpPosition, oppositeWall)) {\n            if (dfs(jumpPosition, oppositeWall, newWaterLevel)) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    private boolean canProceed(int position, int wall) {\n        if (position < 0 || position >= n) {\n            return false;\n        }\n        return notVisited(position, wall) && canVisit(position, wall);\n    }\n\n    private boolean canVisit(int position, int wall) {\n        return walls[wall][position] != DANGEROUS_WALL;\n    }\n\n    private boolean notVisited(int position, int wall) {\n        return !visit[wall][position];\n    }\n\n    public D setInput(InputStream inputStream) {\n        this.reader = new BufferedReader(new InputStreamReader(inputStream));\n        return this;\n    }\n\n    public static void main(String[] args) {\n        new D().setInput(System.in).run();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma warning(disable : 4786)\nusing namespace std;\nchar s[2][100002];\nint v[2][100002];\nint n, k;\nstruct node {\n  int f, t, pos;\n};\nint bfs() {\n  queue<node> q;\n  node z;\n  memset(v, 0, sizeof(v));\n  z.f = 0;\n  z.pos = 0;\n  z.t = 0;\n  q.push(z);\n  while (!q.empty()) {\n    z = q.front();\n    q.pop();\n    if (z.pos + k >= n) return 1;\n    if (s[z.f][z.pos + 1] == '-' && v[z.f][z.pos + 1] == 0) {\n      node t;\n      v[z.f][z.pos + 1] = 1;\n      t.f = z.f;\n      t.t = z.t + 1;\n      t.pos = z.pos + 1;\n      q.push(t);\n    }\n    if (s[z.f ^ 1][z.pos + k] == '-' && v[z.f ^ 1][z.pos + k] == 0) {\n      node t;\n      v[z.f ^ 1][z.pos + k] = 1;\n      t.f = z.f ^ 1;\n      t.t = z.t + 1;\n      t.pos = z.pos + k;\n      q.push(t);\n    }\n    if (z.pos > z.t + 1 && s[z.f][z.pos - 1] == '-' && v[z.f][z.pos - 1] == 0) {\n      node t;\n      v[z.f][z.pos - 1] = 1;\n      t.f = z.f;\n      t.t = z.t + 1;\n      t.pos = z.pos - 1;\n      q.push(t);\n    }\n  }\n  return 0;\n}\nint main() {\n  while (scanf(\"%d%d\", &n, &k) != EOF) {\n    scanf(\"%s%s\", s[0], s[1]);\n    if (bfs())\n      printf(\"YES\\n\");\n    else\n      printf(\"NO\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\n\n/**\n * \n * <p>\n * Solved - bfs\n * </p>\n * <p>\n * Created on Jun 22, 2012, 12:00:53 PM\n * </p>\n * @Author Andy Y.F. Huang\n */\npublic class p199DJumpingonWalls {\n  static final int inf = 124456789;\n  static final char spike = 'X';\n  static char walls[][];\n  static boolean moi[][];\n  \n  static boolean bfs(int height, int jumpd) {\n    Queue<Point> q = new LinkedList<>();\n    q.add(new Point(0, 0, 0));\n    moi[0][0] = true;\n    while (!q.isEmpty()) {\n      Point cur = q.remove();\n      //pln(cur);\n      if (cur.dist > cur.y)\n        continue;\n      int cdist = cur.dist + 1;\n      int up = cur.y + 1;\n      if (up >= height)\n        return true;\n      if (walls[cur.x][up] != spike && !moi[cur.x][up]) {\n        q.add(new Point(cur.x, up, cdist));\n        moi[cur.x][up] = true;\n      }\n      int down = cur.y - 1;\n      if (down >= 0 && walls[cur.x][down] != spike && !moi[cur.x][down]) {\n        q.add(new Point(cur.x, down, cdist));\n        moi[cur.x][down] = true;\n      }\n      int jx = cur.x ^ 1;\n      int jy = cur.y + jumpd;\n      if (jy >= height)\n        return true;\n      if (walls[jx][jy] != spike && !moi[jx][jy]) {\n        q.add(new Point(jx, jy, cdist));\n        moi[jx][jy] = true;\n      }\n    }\n    return false;\n  }\n  \n  static void solve() {\n    int height = in.nextInt();\n    int jumpd = in.nextInt();\n    walls = new char[2][height];\n    moi = new boolean[2][height];\n    for (int i = 0; i < 2; i++) \n      walls[i] = in.nextLine().toCharArray();   \n    if (bfs(height, jumpd))\n      out.appendln(\"YES\");\n    else\n      out.appendln(\"NO\");\n  }\n\n  public static void main(String[] args) {\n    in = new Input();\n    out = new Output();\n    solve();\n    out.print();\n  }\n\n  static Output out;\n  static Input in;\n\n  static void pln(Object... obj) {\n    pf(obj);\n    System.out.println();\n  }\n\n  static void pf(Object... obj) {\n    for (int i = 0; i < obj.length; i++) {\n      if (i != 0)\n        System.out.print(' ');\n      System.out.print(obj[i]);\n\n    }\n  }\n}\n\nfinal class Point {\n  int x;\n  int y;\n  int dist;\n  \n  public Point(int a, int b, int dist) {\n    x = a;\n    y = b;\n    this.dist = dist;\n  }\n\n  public String toString() {\n    return \"(\" + x + \",\" + y + \",\" + dist + \")\";\n  }\n\n}\n\nfinal class Input {\n  private java.io.BufferedReader reader;\n  private java.util.StringTokenizer tokenizer;\n\n  Input() {\n    reader = new java.io.BufferedReader(new java.io.InputStreamReader(System.in));\n    tokenizer = new java.util.StringTokenizer(\"\");\n  }\n\n  String next() {\n    while (!tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      }\n      catch (java.io.IOException e) {\n        throw new RuntimeException(\"Azn Input Error\");\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  String nextLine() {\n    try {\n      return reader.readLine();\n    }\n    catch (java.io.IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  long nextLong() {\n    return Long.parseLong(next());\n  }\n\n  int nextInt() {\n    return Integer.parseInt(next());\n  }\n\n  double nextDouble() {\n    return Double.parseDouble(next());\n  }\n\n}\n\nfinal class Output {\n  public StringBuilder buffer;\n\n  Output() {\n    buffer = new StringBuilder();\n  }\n\n  Output(int size) {\n    buffer = new StringBuilder(size);\n  }\n\n  void print() {\n    System.out.print(buffer.toString());\n  }\n\n  void flush() {\n    System.out.flush();\n  }\n\n  void append(Object... obj) {\n    for (int i = 0; i < obj.length; i++) {\n      if (i != 0)\n        buffer.append(' ');\n      buffer.append(obj[i]);\n    }\n  }\n\n  void appendln(Object... obj) {\n    append(obj);\n    buffer.append('\\n');\n  }\n\n  void delete(int index) {\n    buffer.deleteCharAt(index);\n  }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool bfs(vector<string> &G, vector<vector<int>> &marked, pair<int, int> v,\n         int n, int k) {\n  int temp, i, c = 1, counter = 0, prev = 1;\n  list<pair<int, int>> fringe;\n  marked[v.first][v.second] = 1;\n  fringe.push_back(v);\n  while (!fringe.empty()) {\n    for (i = 0; i < prev; ++i) {\n      v = fringe.front();\n      fringe.pop_front();\n      if (G[v.first][v.second] == 'X') continue;\n      if (v.second + k > n) return true;\n      if (G[v.first][v.second - 1] != 'X') {\n        if (!marked[v.first][v.second - 1]) {\n          marked[v.first][v.second - 1] = marked[v.first][v.second] + 1;\n          fringe.push_back(make_pair(v.first, v.second - 1));\n          ++counter;\n        }\n      }\n      if (G[v.first][v.second + 1] != 'X') {\n        if (!marked[v.first][v.second + 1]) {\n          marked[v.first][v.second + 1] = marked[v.first][v.second] + 1;\n          fringe.push_back(make_pair(v.first, v.second + 1));\n          ++counter;\n        }\n      }\n      temp = 3 - v.first;\n      if (G[temp][v.second + k] != 'X') {\n        if (!marked[temp][v.second + k]) {\n          marked[temp][v.second + k] = marked[v.first][v.second] + 1;\n          fringe.push_back(make_pair(temp, v.second + k));\n          ++counter;\n        }\n      }\n    }\n    G[1][c] = G[2][c] = 'X';\n    ++c;\n    prev = counter;\n    counter = 0;\n  }\n  return false;\n}\nint main() {\n  int n, k, i, j;\n  pair<int, int> v = make_pair(1, 1);\n  vector<vector<int>> marked;\n  vector<string> G;\n  cin >> n >> k;\n  G = vector<string>(4, string(n + 2, 'X'));\n  marked = vector<vector<int>>(4, vector<int>(n + 2));\n  for (i = 1; i <= 2; ++i) {\n    for (j = 1; j <= n; ++j) cin >> G[i][j];\n  }\n  G[1][n + 1] = G[2][n + 1] = '-';\n  if (bfs(G, marked, v, n, k))\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100010;\nint n, k;\nbool vis[2][maxn];\nchar wall[2][maxn];\nbool dfs(int d, int p, int lev) {\n  if (p >= n) return true;\n  int j = p + k, i = d ^ 1;\n  if (j >= n || (!vis[i][j] && wall[i][j] == '-' && lev + 1 < j)) {\n    if (j < n) vis[i][j] = true;\n    if (dfs(i, j, lev + 1)) return true;\n  }\n  j = p + 1;\n  if (j >= n || (!vis[d][j] && wall[d][j] == '-' && lev + 1 < j)) {\n    if (j < n) vis[d][j] = true;\n    if (dfs(d, j, lev + 1)) return true;\n  }\n  j = p - 1;\n  if (j >= n || (!vis[d][j] && wall[d][j] == '-' && lev + 1 < j)) {\n    if (j < n) vis[d][j] = true;\n    if (dfs(d, j, lev + 1)) return true;\n  }\n  return false;\n}\nint main() {\n  scanf(\"%d %d\", &n, &k);\n  scanf(\"%s %s\", wall[0], wall[1]);\n  memset(vis, false, sizeof(vis));\n  vis[0][0] = true;\n  if (dfs(0, 0, -1)) {\n    printf(\"YES\\n\");\n  } else\n    printf(\"NO\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 3e5;\nvector<int> adj[maxn];\nint dist[maxn];\nbool vis[maxn];\nint n, k;\nvoid add(int a, int b) {\n  adj[a].push_back(b);\n  adj[b].push_back(a);\n}\nvoid bfs(int v) {\n  queue<int> verts;\n  verts.push(v);\n  dist[v] = 0;\n  while (!verts.empty()) {\n    v = verts.front();\n    verts.pop();\n    for (int u : adj[v]) {\n      int agua;\n      if (u < n)\n        agua = u + 1;\n      else\n        agua = u + 1 - n;\n      if (dist[u] > dist[v] + 1 && dist[v] + 1 < agua) {\n        dist[u] = dist[v] + 1;\n        verts.push(u);\n      }\n    }\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  memset(dist, 0x3f, sizeof dist);\n  cin >> n >> k;\n  string s1, s2;\n  cin >> s1 >> s2;\n  for (int i = 0; i < n; i++) {\n    if (s1[i] == 'X') continue;\n    if (i > 0) {\n      if (s1[i - 1] == '-') add(i, i - 1);\n    }\n    if (i < n - 1) {\n      if (s1[i + 1] == '-') add(i, i + 1);\n    }\n    if (i + k < n) {\n      if (s2[i + k] == '-') add(i, n + i + k);\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (s2[i] == 'X') continue;\n    if (i > 0) {\n      if (s2[i - 1] == '-') add(n + i, n + i - 1);\n    }\n    if (i < n - 1) {\n      if (s2[i + 1] == '-') add(n + i, n + i + 1);\n    }\n    if (i + k < n) {\n      if (s1[i + k] == '-') add(n + i, i + k);\n    }\n  }\n  bfs(0);\n  bool can = 0;\n  for (int i = n - 1; i >= n - k; i--) {\n    if (dist[i] < i + 1) can = 1;\n  }\n  for (int i = 2 * n - 1; i >= 2 * n - k; i--) {\n    if (dist[i] < i - n + 1) can = 1;\n  }\n  if (can)\n    cout << \"YES\";\n  else\n    cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, i, j, x, y, z, used[100005][5];\nstring st[5];\nqueue<int> step, qx, qy;\nint main() {\n  cin >> n >> m >> st[0] >> st[1];\n  for (i = 1; i <= m; i++) {\n    for (j = 0; j <= 1; j++) {\n      st[j] += \"-\";\n    }\n  }\n  qx.push(1);\n  qy.push(0);\n  step.push(0);\n  while (!qx.empty()) {\n    x = qx.front();\n    y = qy.front();\n    z = step.front();\n    qx.pop();\n    qy.pop();\n    step.pop();\n    if (st[y][x - 1] == 'X') continue;\n    if (x >= n) {\n      cout << \"YES\";\n      return 0;\n    }\n    if (x <= z) continue;\n    if (used[x][y]) continue;\n    used[x][y] = 1;\n    qx.push(x + 1);\n    qy.push(y);\n    step.push(z + 1);\n    qx.push(x - 1);\n    qy.push(y);\n    step.push(z + 1);\n    qx.push(x + m);\n    qy.push(y ^ 1);\n    step.push(z + 1);\n  }\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100 * 100 * 10 * 3 + 10;\nint mn[MAXN][2];\nqueue<int> q;\nint main() {\n  int n, m;\n  cin >> n >> m;\n  string s[2];\n  for (int i = 0; i < MAXN; i++) mn[i][0] = mn[i][1] = -1;\n  cin >> s[0] >> s[1];\n  mn[0][0] = 0;\n  q.push(0);\n  q.push(0);\n  int t = 0;\n  int x, y, k;\n  bool flag = false;\n  while (q.size()) {\n    x = q.front();\n    q.pop();\n    y = q.front();\n    q.pop();\n    if (x + 1 > n or x + m > n) {\n      flag = true;\n      break;\n    }\n    if (s[y][x + 1] != 'X' and x + 1 <= m + n and mn[x + 1][y] == -1) {\n      q.push(x + 1), q.push(y);\n      mn[x + 1][y] = k + 1;\n    }\n    if (x - 1 >= 0 and s[y][x - 1] != 'X' and mn[x - 1][y] == -1 and\n        x - 1 > mn[x][y]) {\n      q.push(x - 1), q.push(y);\n      mn[x - 1][y] = mn[x][y] + 1;\n    }\n    if (x + m <= n + m and s[1 - y][x + m] != 'X' and mn[x + m][1 - y] == -1) {\n      q.push(x + m), q.push(1 - y);\n      mn[x + m][1 - y] = mn[x][y] + 1;\n    }\n    if (s[1 - y][x + m] != 'X' and mn[x - m][1 - y] == -1 and x - m >= 0 and\n        x - m > mn[x][y]) {\n      q.push(x - m), q.push(1 - y);\n      mn[x - m][1 - y] = mn[x][y] + 1;\n    }\n  }\n  for (int i = n; i <= n + m; i++)\n    if (mn[i][0] > 0 or mn[i][1] > 0) flag = true;\n  if (flag == true)\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint ans, n, m;\nstruct node {\n  int x, y;\n} q[500010];\nint vis[500010][2];\nchar g[2][500010];\nint bfs() {\n  int front = 0, rear = 1;\n  node t;\n  t.x = 0, t.y = 0;\n  memset(vis, -1, sizeof(vis));\n  q[front] = t;\n  vis[t.x][t.y] = 0;\n  while (front < rear) {\n    node u = q[front++];\n    int x = u.x;\n    int y = u.y;\n    if (x + m >= n) return 1;\n    if (g[y][x + 1] == '-') {\n      if (vis[x + 1][y] < 0) {\n        vis[x + 1][y] = vis[x][y] + 1;\n        if (vis[x + 1][y] <= x + 1) {\n          node t;\n          t.x = x + 1;\n          t.y = y;\n          q[rear++] = t;\n        }\n      }\n    }\n    if (x > 0 && g[y][x - 1] == '-') {\n      if (vis[x - 1][y] < 0) {\n        vis[x - 1][y] = vis[x][y] + 1;\n        if (vis[x - 1][y] <= x - 1) {\n          node t;\n          t.x = x - 1;\n          t.y = y;\n          q[rear++] = t;\n        }\n      }\n    }\n    if (g[!y][x + m] == '-') {\n      if (vis[x + m][!y] < 0) {\n        vis[x + m][!y] = vis[x][y] + 1;\n        if (vis[x + m][!y] <= x + m) {\n          node t;\n          t.x = x + m;\n          t.y = !y;\n          q[rear++] = t;\n        }\n      }\n    }\n  }\n  return 0;\n}\nint main() {\n  int i, j;\n  while (scanf(\"%d%d\", &n, &m) != EOF) {\n    scanf(\"%s%s\", g[0], g[1]);\n    int ans = bfs();\n    if (ans)\n      printf(\"YES\\n\");\n    else\n      printf(\"NO\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100100;\nint n, k, dist[2][MAXN];\nchar c[2][MAXN];\nqueue<pair<int, int> > q;\nint main() {\n  scanf(\"%d %d\", &n, &k);\n  for (int i = 0; i < 2; i++) {\n    scanf(\"%s\", c[i]);\n    for (int j = 0; j < n; j++) {\n      dist[i][j] = -1;\n    }\n  }\n  dist[0][0] = 0;\n  q.push({0, 0});\n  while (!q.empty()) {\n    int vx = q.front().first;\n    int vy = q.front().second;\n    int d = dist[vx][vy];\n    q.pop();\n    if (vy + k >= n) {\n      puts(\"YES\");\n      exit(0);\n    }\n    if (vy > 0 && d + 1 <= vy - 1 && c[vx][vy - 1] != 'X' &&\n        dist[vx][vy - 1] == -1) {\n      dist[vx][vy - 1] = d + 1;\n      q.push({vx, vy - 1});\n    }\n    if (c[vx][vy + 1] != 'X' && dist[vx][vy + 1] == -1) {\n      dist[vx][vy + 1] = d + 1;\n      q.push({vx, vy + 1});\n    }\n    if (c[1 - vx][vy + k] != 'X' && dist[1 - vx][vy + k] == -1) {\n      dist[1 - vx][vy + k] = d + 1;\n      q.push({1 - vx, vy + k});\n    }\n  }\n  puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 3e5 + 5;\nconst double pi = acos(-1.0);\nconst long long int inf = 0x3f3f3f3f3f3f3f3f;\nconst long long int mod = 998244353;\nbool isPowerOfTwo(int x) { return x && (!(x & (x - 1))); }\nvoid fast() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n}\nstring s[2];\nint n, k, h;\nbool a[2][100005];\nvoid dfs(int x, int y) {\n  if (s[x][y] != '-' || a[x][y] == true || y < h) return;\n  if (y + k >= n) {\n    cout << \"YES\";\n    exit(0);\n  }\n  h++;\n  a[x][y] = true;\n  dfs(1 - x, y + k);\n  dfs(x, y + 1);\n  dfs(x, y - 1);\n  h--;\n}\nint main() {\n  cin >> n >> k >> s[0] >> s[1];\n  dfs(0, 0);\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.* ;\nimport java.util.*;\n\nimport static java.lang.Math.* ;\nimport static java.util.Arrays.* ;\n\npublic class B {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\tnew B().solveProblem();\n\t\t\n\t\tout.close();\n\t}\n\n\tstatic Input in = new Input() ;\n\tstatic PrintStream out = new PrintStream(new BufferedOutputStream(System.out));\t\n\tstatic Output out2 = new Output(out) ;\n\t\n\tint n, k ;\n\t\n\tchar[][] wall ;\n\tpublic void solveProblem() throws IOException {\t\t\n\t\n\t\tn = in.nextInt() ;\n\t\tk = in.nextInt() ;\n\t\t\n\t\twall = new char[2][] ;\n\t\twall[0] = in.next().toCharArray() ;\n\t\twall[1] = in.next().toCharArray() ;\n\t\t\n\t\tint[][] min = new int[2][n] ;\n\t\tfill(min[0],Integer.MAX_VALUE) ;\n\t\tfill(min[1],Integer.MAX_VALUE) ;\n\t\t\n\t\tPriorityQueue<State> qu = new PriorityQueue<State>(n) ;\n\t\tqu.add(new State(0,0,0)) ;\n\t\tmin[0][0] = 0 ;\n\t\t\n\t\twhile (!qu.isEmpty()) {\n\n\t\t\tState nu = qu.poll();\n\t\t\t\n\t\t\t//p(nu.h,nu.t,nu.wi) ;\n\t\t\tif (nu.h + k >= n) {\n\t\t\t\tout.println(\"YES\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif( nu.t > min[nu.wi][nu.h])\n\t\t\t\tcontinue ;\n\t\t\tint nt = nu.t + 1;\n\t\t\tint nh = nu.h + 1;\n\t\t\tif (ok(nh, nt,nu.wi)) {\n\t\t\t\tif (min[nu.wi][nh] > nt) {\n\t\t\t\t\tmin[nu.wi][nh] = nt;\n\t\t\t\t\tqu.add(new State(nu.wi, nh, nt));\n\t\t\t\t}\n\t\t\t}\n\t\t\tnh = nu.h - 1;\n\t\t\tif (ok(nh, nt,nu.wi)) {\n\t\t\t\tif (min[nu.wi][nh] > nt) {\n\t\t\t\t\tmin[nu.wi][nh] = nt;\n\t\t\t\t\tqu.add(new State(nu.wi, nh, nt));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tnh = nu.h + k;\n\t\t\tif (ok(nh, nt,1-nu.wi)) {\n\t\t\t\tif (min[1-nu.wi][nh] > nt) {\n\t\t\t\t\tmin[1-nu.wi][nh] = nt;\n\t\t\t\t\tqu.add(new State(1-nu.wi, nh, nt));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tout.println(\"NO\") ;\n\t}\n\t\n\t\n\tpublic  boolean ok(int h, int t, int wi){\n\t\treturn h >= 0 && t <= h && h < n && wall[wi][h] == '-';\n\t}\n\t\n\tclass State implements Comparable<State> {\n\t\t\n\t\tint wi ;\n\t\tint h ;\n\t\tint t ;\n\t\tpublic State(int wi, int h, int t) {\n\t\t\tsuper();\n\t\t\tthis.wi = wi;\n\t\t\tthis.h = h;\n\t\t\tthis.t = t;\n\t\t}\n\t\t\n\t\tpublic int compareTo( State o ){\n\t\t\treturn t - o.t ;\n\t\t}\n\t\n\n\t}\n\t\n\tstatic void p( Object ...p){\n\t\tSystem.out.println(Arrays.deepToString(p));\n\t}\n\t\n\tstatic class Input {\t\n\t\t\n\t\tBufferedReader buf = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer tokens ;\n\t\t\n\t\tpublic int nextInt(){\n\t\t\treturn Integer.parseInt(next()) ;\n\t\t}\n\n\t\tpublic int[] nextInt(int n ){\n\t\t\tint[] res = new int[n] ;\n\t\t\tfor( int i = 0 ; i < n ; i++ )\n\t\t\t\tres[i] = nextInt() ;\n\t\t\treturn res ;\n\t\t}\n\n\t\tpublic long nextLong(){\n\t\t\treturn Long.parseLong(next()) ;\n\t\t}\n\n\t\tpublic long[] nextLong(int n ){\n\t\t\tlong[] res = new long[n] ;\n\t\t\tfor( int i = 0 ; i < n ; i++ )\n\t\t\t\tres[i] = nextLong() ;\n\t\t\treturn res ;\n\t\t}\n\t\t\n\t\tpublic double nextDouble(){\n\t\t\treturn Double.parseDouble(next()) ;\n\t\t}\n\t\t\n\t\tpublic String next(){\n\t\t\t\n\t\t\ttry{\n\t\t\t\twhile( tokens == null || !tokens.hasMoreTokens() )\n\t\t\t\t\ttokens = new StringTokenizer(buf.readLine()) ;\n\t\t\t}catch( Exception e ){\n\t\t\t\te.printStackTrace() ;\n\t\t\t}\n\t\t\t\n\t\t\treturn tokens.nextToken() ;\n\t\t}\n\n\t}\n\n\tstatic class Output {\n\t\t\n\t\tPrintStream out ;\n\t\t\n\t\tpublic Output(PrintStream out) {\n\t\t\tthis.out = out;\n\t\t}\n\n\t\tvoid wr( int[] rij ){\n\t\t\tfor( int i = 0 ; i < rij.length - 1 ; i++ ) \n\t\t\t\tout.print(rij[i] + \" \") ;\n\t\t\tout.println(rij[rij.length-1]);\t\t\n\t\t}\n\n\t\tvoid wr( long[] rij ){\n\t\t\tfor( int i = 0 ; i < rij.length - 1 ; i++ ) \n\t\t\t\tout.print(rij[i] + \" \") ;\n\t\t\tout.println(rij[rij.length-1]);\t\t\n\t\t}\n\t\t\n\t\tvoid wr( char[] rij){\n\t\t\tout.println(new String(rij)) ;\n\t\t}\n\t\t\n\t}\n\t\n\t\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class Main\n\t{\n\tpublic static void main(String args[]) throws IOException\n\t\t{\n\t\tBufferedReader c=new BufferedReader(new InputStreamReader(System.in));\n\t\tString S[]=c.readLine().split(\" \");\n\t\tint N=Integer.parseInt(S[0]);\n\t\tif(N==1)\n\t\t\t{\n\t\t\tSystem.out.println(\"YES\");\n\t\t\treturn;\n\t\t\t}\n\t\tStringBuffer s=new StringBuffer(\"\");\n\t\tfor(int i=0;i<=N;i++)\n\t\t\ts=s.append(\"-\");\n\t\tN+=N;\n\t\tN++;\n\t\tint K=Integer.parseInt(S[1]);\n\t\tlong A[][]=new long[N][2];\n\t\tboolean visited[][]=new boolean[N][2];\n\t\tchar L[]=(c.readLine()+s.toString()).toCharArray();\n\t\tchar R[]=(c.readLine()+s.toString()).toCharArray();\n\t\tfor(int i=0;i<N;i++)\n\t\t\t{\n\t\t\tA[i][0]=L[i]=='X'?-1:Integer.MAX_VALUE;\n\t\t\tA[i][1]=R[i]=='X'?-1:Integer.MAX_VALUE;\n\t\t\t}\n\t\tA[0][0]=0;\n\t\t//A[i][0] refers to the left wall\n\t\tQueue<node> Q=new LinkedList<node>();\n\t\tQ.add(new node(0,0));\n\t\twhile(!Q.isEmpty())\n\t\t\t{\n\t\t\tnode head=Q.poll();\n\t\t\tvisited[head.i][head.j]=true;\n\t\t\tif(head.i-1>=0&&!visited[head.i-1][head.j]&&A[head.i-1][head.j]!=-1&&head.i-1>A[head.i][head.j])\n\t\t\t\t{\n\t\t\t\tA[head.i-1][head.j]=A[head.i][head.j]+1;\n\t\t\t\tvisited[head.i-1][head.j]=true;\n\t\t\t\tQ.add(new node(head.i-1,head.j));\n\t\t\t\t}\n\t\t\tif(head.i+1<N&&!visited[head.i+1][head.j]&&A[head.i+1][head.j]!=-1)\n\t\t\t\t{\n\t\t\t\tA[head.i+1][head.j]=A[head.i][head.j]+1;\n\t\t\t\tvisited[head.i+1][head.j]=true;\n\t\t\t\tQ.add(new node(head.i+1,head.j));\n\t\t\t\t}\n\t\t\tint next=(head.j+1)%2;\n\t\t\tif(head.i+K<N&&!visited[head.i+K][next]&&A[head.i+K][next]!=-1)\n\t\t\t\t{\n\t\t\t\tA[head.i+K][next]=A[head.i][head.j]+1;\n\t\t\t\tvisited[head.i+K][next]=true;\n\t\t\t\tQ.add(new node(head.i+K,next));\n\t\t\t\t}\n\t\t\t}\n\t\t/*for(int i=0;i<N;i++)\n\t\t\t{\n\t\t\tSystem.out.print(A[i][0]+\" \");\n\t\t\t}\n\t\tSystem.out.println(\"\");\n\t\tfor(int i=0;i<N;i++)\n\t\t\t{\n\t\t\tSystem.out.print(A[i][1]+\" \");\n\t\t\t}*/\n\t\tlong minT[]=new long[N];\t\t\t//minimum time at height i\n\t\tminT[N-1]=Math.min(A[N-1][0],A[N-1][1]);\n\t\tfor(int i=N-2;i>=0;i--)\n\t\t\t{\n\t\t\tlong t1=A[i][0]==-1?Integer.MAX_VALUE:A[i][0];\n\t\t\tlong t2=A[i][1]==-1?Integer.MAX_VALUE:A[i][1];\n\t\t\tminT[i]=Math.min(minT[i+1],Math.min(t1,t2));\n\t\t\t}\n\t\t//System.out.println(Arrays.toString(minT));\n\t\tboolean valid=true;\n\t\tfor(int i=0;i<N;i++)\n\t\t\t{\n\t\t\tif(minT[i]>i)\n\t\t\t\tvalid=false;\n\t\t\t}\n\t\tif(valid)\n\t\t\tSystem.out.println(\"YES\");\n\t\telse\n\t\t\tSystem.out.println(\"NO\");\n\t\t}\n\t}\n\nclass node\n\t{\n\tint i;\n\tint j;\n\tpublic node(int x,int y)\n\t\t{\n\t\tthis.i=x;\n\t\tthis.j=y;\n\t\t}\n\t}\n//must declare new classes here"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.lang.reflect.Array;\nimport java.util.*;\n \npublic class Problem implements Runnable {\n \n    private static final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n \n    private BufferedReader in;\n    private PrintWriter out;\n    private StringTokenizer tok = new StringTokenizer(\"\");\n \n    private void init() throws FileNotFoundException {\n        Locale.setDefault(Locale.US);\n        String fileName = \"\";\n        if (ONLINE_JUDGE && fileName.isEmpty()) {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        } else {\n            if (fileName.isEmpty()) {\n                in = new BufferedReader(new FileReader(\"input.txt\"));\n                out = new PrintWriter(\"output.txt\");\n            } else {\n                in = new BufferedReader(new FileReader(fileName + \".in\"));\n                out = new PrintWriter(fileName + \".out\");\n            }\n        }\n    }\n \n \n    String readString() {\n        while (!tok.hasMoreTokens()) {\n            try {\n                tok = new StringTokenizer(in.readLine());\n            } catch (Exception e) {\n                return null;\n            }\n        }\n        return tok.nextToken();\n    }\n \n    int readInt() {\n        return Integer.parseInt(readString());\n    }\n \n    long readLong() {\n        return Long.parseLong(readString());\n    }\n \n    double readDouble() {\n        return Double.parseDouble(readString());\n    }\n \n    int[] readIntArray(int size) {\n        int[] a = new int[size];\n        for (int i = 0; i < size; i++) {\n            a[i] = readInt();\n        }\n        return a;\n    }\n \n    public static void main(String[] args) {\n        //new Thread(null, new _Solution(), \"\", 128 * (1L << 20)).start();\n        new Problem().run();\n    }\n \n    long timeBegin, timeEnd;\n \n    void time() {\n        timeEnd = System.currentTimeMillis();\n        System.err.println(\"Time = \" + (timeEnd - timeBegin));\n    }\n \n    @Override\n    public void run() {\n        try {\n            timeBegin = System.currentTimeMillis();\n            init();\n            solve();\n            out.close();\n            time();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }\n \n    int[][] dist, wall;\n    int n, m,k,ans=1;\n    boolean ou=false;\n \n    private void solve() throws IOException {\n        n = readInt();\n        k=readInt();\n        dist = new int[n][2];\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < 2; j++)\n                dist[i][j] = -1;\n        wall = new int[n][2];\n        for (int i = 0; i < 2; i++) {\n            String s = readString();\n            for (int j = 0; j < n; j++)\n                    if (s.charAt(j) == 'X')\n                        wall[j][i] = -1;               \n       }\n      bfs(0,0);\n        out.println(ou?\"YES\":\"NO\");\n}\n \n    public void bfs(int x, int o) {\n        dist[x][o]= 0;\n        ArrayDeque<P> q = new ArrayDeque<>();\n        q.add(new P(x,o));\n        while (!q.isEmpty()) {\n            P v = q.pollFirst();\n            int X = v.x + 1;\n            int O=v.o;\n            if (X<n&&wall[X][O] == 0&&(dist[X][O]==-1||dist[v.x][v.o] + 1<dist[X][O])) {\n                    q.addLast(new P(X,O));\n                    dist[X][O] = dist[v.x][v.o] + 1;\n                }\nif (X==n&&dist[v.x][v.o]<n) ou=true;\n            X = v.x - 1;\n            O=v.o;\n            if (X>0&&X>=dist[v.x][v.o] + 1&&wall[X][O] == 0&&(dist[X][O]==-1||dist[v.x][v.o] + 1<dist[X][O])) {\n                    q.addLast(new P(X,O));\n                    dist[X][O] = dist[v.x][v.o] + 1;\n                }\n        \n            X = v.x+k;\n            O=(v.o==0?1:0);\n            if (X<n&&wall[X][O] == 0&&(dist[X][O]==-1||dist[v.x][v.o] + 1<dist[X][O])) {\n                    q.addLast(new P(X,O));\n                    dist[X][O] = dist[v.x][v.o] + 1;\n                }\nif (X>=n&&dist[v.x][v.o]<n) ou=true;\n        }\n    }\n}\nclass P {\n    int x;\n    int o;\n \n    public P(int x, int o) {\n        this.x = x;\n        this.o = o;\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200010, INF = 1000000000;\nint n, k, Time[N][3];\nchar s[3][N];\nbool vis[N][3];\nbool bfs() {\n  for (int i = 0; i <= n + k; i++) Time[i][0] = Time[i][1] = INF;\n  queue<pair<int, int> > Q;\n  Q.push(make_pair(0, 0)), Time[0][0] = 0;\n  while (Q.size()) {\n    int pos = Q.front().first;\n    bool p = Q.front().second;\n    Q.pop();\n    if (Time[pos][p] > pos || vis[pos][p]) continue;\n    vis[pos][p] = 1;\n    if (pos >= n - 1) return true;\n    if (Time[pos][p] + 1 < Time[pos + 1][p] &&\n        (s[p][pos + 1] != 'X' || pos + 1 > n - 1))\n      Q.push(make_pair(pos + 1, p)), Time[pos + 1][p] = Time[pos][p] + 1;\n    if (Time[pos][p] + 1 < Time[pos - 1][p] &&\n        (s[p][pos - 1] != 'X' || pos - 1 > n - 1) && pos - 1 >= 0)\n      Q.push(make_pair(pos - 1, p)), Time[pos - 1][p] = Time[pos][p] + 1;\n    if (Time[pos][p] + 1 < Time[pos + k][!p] &&\n        (s[!p][pos + k] != 'X' || pos + k > n - 1))\n      Q.push(make_pair(pos + k, !p)), Time[pos + k][!p] = Time[pos][p] + 1;\n  }\n  return false;\n}\nint main() {\n  scanf(\"%d %d %s %s\", &n, &k, s[0], s[1]);\n  if (bfs())\n    printf(\"YES\");\n  else\n    printf(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, x, y, fi, fr, f[2][100100], qx[200200], qy[200200];\nchar s[2][100100];\nint main() {\n  cin >> n >> k;\n  cin >> s[0];\n  cin >> s[1];\n  f[0][0] = 1;\n  for (fr = 1; fi < fr;) {\n    x = qx[fi];\n    y = qy[fi++];\n    if (y >= n - k) {\n      cout << \"YES\";\n      return 0;\n    }\n    if (y > 0 && s[x][y - 1] == '-' && f[x][y - 1] == 0 && y > f[x][y]) {\n      f[x][y - 1] = f[x][y] + 1;\n      qx[fr] = x;\n      qy[fr++] = y - 1;\n    }\n    if (s[x][y + 1] == '-' && f[x][y + 1] == 0) {\n      f[x][y + 1] = f[x][y] + 1;\n      qx[fr] = x;\n      qy[fr++] = y + 1;\n    }\n    if (s[1 - x][y + k] == '-' && f[1 - x][y + k] == 0) {\n      f[1 - x][y + k] = f[x][y] + 1;\n      qx[fr] = 1 - x;\n      qy[fr++] = y + k;\n    }\n  }\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MaxN = 300005;\nint a[MaxN][4];\nbool mark[MaxN][4];\nint n, k;\nint x[MaxN * 5], y[MaxN * 5];\nchar s[MaxN];\nbool good(int x, int y) { return 1 <= x && 1 <= y && y <= 2; }\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  int di[] = {1, -1, k, k};\n  int dj[] = {0, 0, 1, -1};\n  memset(a, 0, sizeof(a));\n  for (int i = 1; i <= 2; i++) {\n    scanf(\"%s\", s);\n    for (int j = 0; j < n; j++) {\n      a[j + 1][i] = ('X' == s[j]);\n    }\n  }\n  memset(mark, false, sizeof(mark));\n  int i = 1, j = 1;\n  x[1] = 1;\n  y[1] = 1;\n  int move = 1;\n  while (i <= j) {\n    int z = j;\n    for (int q = i; q <= j; q++)\n      for (int dir = 0; dir < 4; dir++) {\n        int ni = x[q] + di[dir];\n        int nj = y[q] + dj[dir];\n        if (good(ni, nj) && !mark[ni][nj] && !a[ni][nj] && ni > move) {\n          mark[ni][nj] = true;\n          z++;\n          x[z] = ni;\n          y[z] = nj;\n          if (ni > n) {\n            printf(\"YES\\n\");\n            return 0;\n          }\n        }\n      }\n    move++;\n    i = j + 1;\n    j = z;\n  }\n  printf(\"NO\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import deque\nimport sys\nn, k = map(int, sys.stdin.readline().split())\ns1, s2 = sys.stdin.readline(), sys.stdin.readline()\nmat = [[] for _ in range(2 * 100000 + 10)]\nused = [-1] * (2 * 100000 + 10)\nfor i in range(n):\n    if i > 0 and s1[i - 1] != 'X' and s1[i] != 'X':\n        mat[i].append(i - 1)\n        used[i - 1] = 0\n    if i < n - 1 and s1[i] != 'X' and s1[i + 1] != 'X':\n        mat[i].append(i + 1)\n        used[i + 1] = 0\n    used[i] = 0\n    if i + k >= n:\n        mat[i].append(2 * 100000 + 9)\n        used[2 * 100000 + 9] = 0\n    elif s2[i + k] != 'X':\n        mat[i].append(i + k + 100001)\n        used[i + k + 100001] = 0\nfor i in range(n):\n    if i > 0 and s2[i - 1] != 'X' and s2[i] != 'X':\n        mat[i + 100001].append(i - 1 + 100001)\n        used[i - 1 + 100001] = 0\n    if i < n - 1 and s2[i] != 'X' and s2[i + 1] != 'X':\n        mat[i + 100001].append(i + 1 + 100001)\n        used[i + 1 + 100001] = 0\n    used[i + 100001] = 0\n    if i + k >= n:\n        mat[i + 100001].append(2 * 100000 + 9)\n        used[2 * 100000 + 9] = 0\n    elif s1[i + k] != 'X':\n        mat[i + 100001].append(i + k)\n        used[i + k] = 0\nq = deque([0])\ndist = [0] * (2 * 100000 + 10)\nwhile q:\n    u = q[0]\n    q.popleft()\n    used[u] = 1\n    for v in mat[u]:\n        if used[v] == 0:\n            dist[v] = dist[u] + 1\n            used[v] = 1\n            if (v <= 100000 and dist[v] <= v) or (v > 100000 and dist[v] <= v - 100001) or v == 2 * 100000 + 9:\n                q.append(v)\nif used[2 * 100000 + 9] == 1:\n    sys.stdout.write('YES')\nelse:\n    sys.stdout.write('NO')\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int nmax = 200105;\nconst int inf = 10000000;\nchar c[2][nmax];\nint dis[2][nmax], col[2][nmax], n;\nqueue<pair<int, int>> qq;\nint check(int i, int j, int i1, int j1) {\n  if (j1 < 0 || c[i1][j1] == 'X' || col[i1][j1] || dis[i][j] >= j1) return 0;\n  if (j1 >= n) return 1;\n  col[i1][j1] = 1;\n  dis[i1][j1] = dis[i][j] + 1;\n  qq.push(make_pair(i1, j1));\n  return 0;\n}\nint main() {\n  int i, j, k, f;\n  scanf(\"%d %d %s %s\", &n, &k, &c[0], &c[1]);\n  for (i = 0; i < 2; i++)\n    for (j = 0; j <= n + k; j++) dis[i][j] = inf;\n  dis[0][0] = 0;\n  qq.push(make_pair(0, 0));\n  f = 0;\n  while (!qq.empty()) {\n    i = qq.front().first;\n    j = qq.front().second;\n    qq.pop();\n    if (check(i, j, 1 - i, j + k) || check(i, j, i, j + 1)) {\n      printf(\"YES\");\n      return 0;\n    }\n    check(i, j, i, j - 1);\n  }\n  printf(\"NO\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100010;\nconst int inf = 10000000;\nint n, k;\nchar dat[2][maxn];\nint dist[2][maxn];\nvoid init() {\n  scanf(\"%d%d\", &n, &k);\n  scanf(\"%s%s\", dat[0], dat[1]);\n  dat[0][n] = dat[1][n] = 0;\n}\nvoid work() {\n  static priority_queue<pair<int, pair<int, int> > > Q;\n  static bool used[2][maxn];\n  Q.push(make_pair(0, make_pair(0, 0)));\n  int i, j;\n  for (i = 0; i < 2; i++)\n    for (j = 0; j <= n; j++) dist[i][j] = inf;\n  dist[0][0] = 0;\n  while (!Q.empty()) {\n    i = Q.top().second.first;\n    j = Q.top().second.second;\n    Q.pop();\n    if (used[i][j]) continue;\n    used[i][j] = true;\n    if (dist[i][j] > j) continue;\n    if (j >= n) break;\n    if (dat[i][j + 1] != 'X' && dist[i][j + 1] > dist[i][j] + 1) {\n      dist[i][j + 1] = dist[i][j] + 1;\n      Q.push(make_pair(-dist[i][j + 1], make_pair(i, j + 1)));\n    }\n    if (j > 0 && dat[i][j - 1] != 'X' && dist[i][j - 1] > dist[i][j] + 1) {\n      dist[i][j - 1] = dist[i][j] + 1;\n      Q.push(make_pair(-dist[i][j - 1], make_pair(i, j - 1)));\n    }\n    if (dat[i ^ 1][min(j + k, n)] != 'X' &&\n        dist[i ^ 1][min(j + k, n)] > dist[i][j] + 1) {\n      dist[i ^ 1][min(j + k, n)] = dist[i][j] + 1;\n      Q.push(make_pair(-dist[i ^ 1][min(j + k, n)],\n                       make_pair(i ^ 1, min(j + k, n))));\n    }\n  }\n  if (dist[0][n] <= n || dist[1][n] <= n)\n    printf(\"YES\\n\");\n  else\n    printf(\"NO\\n\");\n}\nint main() {\n  init();\n  work();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100000 + 10;\nint n, k;\nbool mark[2 * maxn];\nstring s1, s2;\nvector<int> adj[2 * maxn], v;\nint main() {\n  cin >> n >> k;\n  cin >> s1 >> s2;\n  for (int i = 0; i <= n - 1; i++) {\n    if (s1[i] == 'X') {\n      mark[2 * i] = 1;\n      continue;\n    }\n    if (i != 0 && s1[i - 1] == '-') adj[2 * i].push_back(2 * i - 2);\n    if (i != n - 1 && s1[i + 1] == '-') adj[2 * i].push_back(2 * i + 2);\n    if (i + k <= n - 1 && s2[i + k] == '-')\n      adj[2 * i].push_back(2 * (i + k) + 1);\n    if (i + k > n - 1) adj[2 * i].push_back(2 * n);\n  }\n  for (int i = 0; i <= n - 1; i++) {\n    if (s2[i] == 'X') {\n      mark[2 * i + 1] = 1;\n      continue;\n    }\n    if (i != 0 && s2[i - 1] == '-') adj[2 * i + 1].push_back(2 * i + 1 - 2);\n    if (i != n - 1 && s2[i + 1] == '-') adj[2 * i + 1].push_back(2 * i + 1 + 2);\n    if (i + k <= n - 1 && s1[i + k] == '-')\n      adj[2 * i + 1].push_back(2 * (i + k));\n    if (i + k > n - 1) adj[2 * i + 1].push_back(2 * n);\n  }\n  mark[0] = 1;\n  v.push_back(0);\n  int cnt = 1;\n  while (1) {\n    vector<int> vv;\n    for (int i = 0; i < v.size(); i++) {\n      int u = v[i];\n      for (int j = 0; j < adj[u].size(); j++)\n        if (mark[adj[u][j]] == 0 && (adj[u][j] + 2) / 2 > cnt) {\n          mark[adj[u][j]] = 1;\n          vv.push_back(adj[u][j]);\n        }\n    }\n    v = vv;\n    if (v.size() == 0) break;\n    cnt++;\n  }\n  if (mark[2 * n])\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nchar arr[2][100009];\nbool solve(int wall, int h, int water) {\n  if (arr[wall][h] != '-' || h < 0 || water > h) return false;\n  if (h + k >= n) return true;\n  arr[wall][h] = 'X';\n  if (solve(1 - wall, h + k, water + 1) || solve(wall, h + 1, water + 1) ||\n      solve(wall, h - 1, water + 1))\n    return true;\n  return false;\n}\nint main() {\n  cin >> n >> k;\n  cin >> arr[0] >> arr[1];\n  cout << (solve(0, 0, 0) == true ? \"YES\" : \"NO\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nchar M[2][100005];\nbool visited[2][100005], ok = false;\nvoid dfs(int r, int c, int s) {\n  if (ok) return;\n  if (s > c) return;\n  if (c >= n) {\n    ok = true;\n    return;\n  }\n  visited[r][c] = 1;\n  int nr = 1 - r, nc;\n  nc = c + k;\n  if (nc >= n || (!visited[nr][nc] && M[nr][nc] == '-')) dfs(nr, nc, s + 1);\n  nc = c + 1;\n  if (!visited[r][nc] && M[r][nc] == '-') dfs(r, nc, s + 1);\n  nc = c - 1;\n  if (c >= 0 && !visited[r][nc] && M[r][nc] == '-') dfs(r, nc, s + 1);\n}\nint main() {\n  cin >> n >> k;\n  memset(visited, 0, sizeof(visited));\n  for (int i = 0; i < n; i++) cin >> M[0][i];\n  for (int i = 0; i < n; i++) cin >> M[1][i];\n  dfs(0, 0, 0);\n  if (ok)\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, w;\nstring str[2];\nint vis[2][1000005];\nint dfs(int x, int y) {\n  if (y < 0) return 0;\n  if (y >= n) return 1;\n  if (str[x][y] == 'X' || y < w || vis[x][y]) return 0;\n  vis[x][y] = 1;\n  w++;\n  int flag = 0;\n  if (dfs(x, y - 1)) flag = 1;\n  if (dfs(1 - x, y + k)) flag = 1;\n  if (dfs(x, y + 1)) flag = 1;\n  w--;\n  return flag;\n}\nint main() {\n  scanf(\"%d %d\", &n, &k);\n  cin >> str[0];\n  cin >> str[1];\n  w = 0;\n  if (dfs(0, 0))\n    puts(\"YES\");\n  else\n    puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\npublic final class JumpingOnWalls {\n\n    static Scanner sc = new Scanner(System.in);\n    static char[] leftWall, rightWall;\n    static boolean[] leftVisited, rightVisted;\n    static int n, k;\n\n    public static void main(String[] args) {\n        n = sc.nextInt();\n        k = sc.nextInt();\n        sc.nextLine();\n        leftWall = sc.nextLine().toCharArray();\n        rightWall = sc.nextLine().toCharArray();\n\n        leftVisited = new boolean[n];\n        rightVisted = new boolean[n];\n        System.out.println(isPossible(0, -1, true) ? \"YES\" : \"NO\");\n    }\n\n    private static boolean isPossible(int currPos, int waterLevel, boolean isLeft) {\n        char[] currWall = isLeft ? leftWall : rightWall;\n        char[] otherWall = isLeft ? rightWall : leftWall;\n        boolean[] currVisited = isLeft ? leftVisited : rightVisted;\n        boolean[] otherVisted = isLeft ? rightVisted : leftVisited;\n\n        if (currPos < 0) return false;\n        if (currPos > n - 1 || currPos + k >= n) return true;\n        if (waterLevel >= currPos) return false;\n\n        currVisited[currPos] = true;\n\n        if (currWall[currPos] == 'X') return false;\n        if (!otherVisted[currPos + k] && !(otherWall[currPos+k] == 'X') && isPossible(currPos+k, waterLevel+1, !isLeft)) return true;\n        if (!currVisited[currPos+1] && !(currWall[currPos+1] == 'X') && isPossible(currPos+1, waterLevel+1, isLeft)) return true;\n        if (currPos > 0 && !currVisited[currPos-1] && waterLevel < currPos-1 && isPossible(currPos-1, waterLevel+1, isLeft))\n            return true;\n        return false;\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100010;\nint t1[maxn], t2[maxn];\nint q[maxn * 2], tail, cur, n, k;\nchar s1[maxn], s2[maxn];\nint bfs() {\n  memset(t1, 0xff, sizeof(t1));\n  memset(t2, 0xff, sizeof(t2));\n  q[1] = 1 * maxn + 1, cur = 0, tail = 1, t1[1] = 0;\n  while (cur < tail) {\n    int now = q[++cur];\n    int t = now / maxn;\n    int r = now % maxn;\n    if (r + k > n) return 1;\n    if (t == 1) {\n      if (r - t1[r] > 2 && r > 1 && t1[r - 1] == -1 && s1[r - 1] == '-') {\n        q[++tail] = 1 * maxn + (r - 1);\n        t1[r - 1] = t1[r] + 1;\n      }\n      if (r < n && t1[r + 1] == -1 && s1[r + 1] == '-') {\n        q[++tail] = 1 * maxn + (r + 1);\n        t1[r + 1] = t1[r] + 1;\n      }\n      if (r + k <= n && t2[r + k] == -1 && s2[r + k] == '-') {\n        q[++tail] = 2 * maxn + (r + k);\n        t2[r + k] = t1[r] + 1;\n      }\n    } else {\n      if (r - t2[r] > 2 && r > 1 && t2[r - 1] == -1 && s2[r - 1] == '-') {\n        q[++tail] = 2 * maxn + (r - 1);\n        t2[r - 1] = t2[r] + 1;\n      }\n      if (r < n && t2[r + 1] == -1 && s2[r + 1] == '-') {\n        q[++tail] = 2 * maxn + (r + 1);\n        t2[r + 1] = t2[r] + 1;\n      }\n      if (r + k <= n && t1[r + k] == -1 && s1[r + k] == '-') {\n        q[++tail] = 1 * maxn + (r + k);\n        t1[r + k] = t2[r] + 1;\n      }\n    }\n  }\n  return 0;\n}\nint main() {\n  while (scanf(\"%d %d\", &n, &k) != EOF) {\n    scanf(\"%s\", s1 + 1);\n    scanf(\"%s\", s2 + 1);\n    if (bfs())\n      puts(\"YES\");\n    else\n      puts(\"NO\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> s(2, vector<int>(100005, 2e9));\nqueue<pair<pair<int, int>, int>> q;\nint main() {\n  int n, k, i, a, b, c;\n  char sl[100005], sr[100005];\n  scanf(\"%d %d %s %s\", &n, &k, sl, sr);\n  for (i = 0; i < n; i++) {\n    if (sl[i] == 'X') s[0][i] = -1;\n    if (sr[i] == 'X') s[1][i] = -1;\n  }\n  q.push({{0, 0}, 0});\n  while (!q.empty()) {\n    a = q.front().first.first;\n    b = q.front().first.second;\n    c = q.front().second;\n    q.pop();\n    if (c > b || (s[a][b] <= c)) continue;\n    if (b >= n - k) {\n      printf(\"YES\");\n      return 0;\n    }\n    s[a][b] = c;\n    if (b - 1 >= 0 && s[a][b - 1] > c + 1) q.push({{a, b - 1}, c + 1});\n    if (s[a][b + 1] > c + 1) q.push({{a, b + 1}, c + 1});\n    if (s[1 - a][b + k] > c + 1) q.push({{1 - a, b + k}, c + 1});\n  }\n  printf(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "from collections import deque\n\nn, k = map(int, raw_input().split())\nm = [raw_input(), raw_input()]\nv = [[n for j in range(n)] for i in [0, 1]]\nv[0][0] = 0;\nq = deque([(0, 0)])\n\ndef f(i, j, l):\n    if j >= l and m[i][j] == '-' and l < v[i][j]:\n        v[i][j] = l\n        q.append((i, j))\n\nflag = False\nwhile q:\n    i, j = q.popleft()\n    if j + k >= n:\n        flag = True\n        break\n    l = v[i][j] + 1\n    f(i, j - 1, l)\n    f(i, j + 1, l)\n    f(1 - i, j + k, l)\n\nif flag: print \"YES\"\nelse: print \"NO\"\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nchar A[10][200100];\nint len;\nint vis[10][200100];\nint dfs(int pos, int x) {\n  if (x > n) return 1;\n  if (x < len || vis[pos][x] || A[pos][x] == 'X') return 0;\n  len++;\n  vis[pos][x] = 1;\n  int flag = dfs(pos, x - 1) || dfs(1 - pos, x + k) || dfs(pos, x + 1);\n  len--;\n  return flag;\n}\nint main() {\n  while (scanf(\"%d%d\", &n, &k) != EOF) {\n    memset(vis, 0, sizeof vis);\n    len = 1;\n    scanf(\"%s %s\", A[0] + 1, A[1] + 1);\n    if (dfs(0, 1))\n      puts(\"YES\");\n    else\n      puts(\"NO\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class D {\n\n    static class State {\n        int curI, curJ, level;\n        \n        State(int i, int j, int l) {\n            curI = i;\n            curJ = j;\n            level = l;\n        }\n    }\n    \n    private void solve() throws IOException {\n        int n = nextInt();\n        int k = nextInt();\n\n        boolean[][] v = new boolean[2][n];\n        boolean[][] vis = new boolean[2][n];\n        \n        for (int i = 0; i < 2; i++) {\n            String s = nextToken();\n            for (int j = 0; j < s.length(); j++)\n                v[i][j] = (s.charAt(j) == '-') ? true : false;\n        }\n\n        Queue<State> q = new LinkedList<State>();\n        q.add(new State(0, 0, -1));\n        \n        while (!q.isEmpty()) {\n            State cur = q.poll();\n                        \n            if (cur.curJ + 1 < n && cur.level + 1 < cur.curJ + 1 && v[cur.curI][cur.curJ + 1] && !vis[cur.curI][cur.curJ + 1]) {\n                q.add(new State(cur.curI, cur.curJ + 1, cur.level + 1));\n                vis[cur.curI][cur.curJ + 1] = true;\n            } else if (cur.curJ + 1 >= n && cur.level < cur.curJ + 1) {\n                pl(\"YES\");\n                return;\n            }\n            \n            if (cur.curJ - 1 >= 0 && cur.level + 1 < cur.curJ - 1 && v[cur.curI][cur.curJ - 1] && !vis[cur.curI][cur.curJ - 1]) {\n                q.add(new State(cur.curI, cur.curJ - 1, cur.level + 1));\n                vis[cur.curI][cur.curJ - 1] = true;\n            } else if (cur.curJ - 1 >= 0 && cur.level >= cur.curJ - 1) {\n            }\n            \n            if (cur.curJ + k < n && cur.level + 1 < cur.curJ + k && v[cur.curI ^ 1][cur.curJ + k] && !vis[cur.curI ^ 1][cur.curJ + k]) {\n                q.add(new State(cur.curI ^ 1, cur.curJ + k, cur.level + 1));\n                vis[cur.curI ^ 1][cur.curJ + k] = true;\n            } else if (cur.curJ + k >= n && cur.level < cur.curJ + k) {\n                pl(\"YES\");\n                return;\n            }\n            \n        }\n        pl(\"NO\");\n    }\n\n    public static void main(String[] args) {\n        new D().run();\n    }\n\n    BufferedReader reader;\n    StringTokenizer tokenizer;\n    PrintWriter writer;\n\n    public void run() {\n        try {\n            reader = new BufferedReader(new InputStreamReader(System.in));\n            tokenizer = null;\n            writer = new PrintWriter(System.out);\n            solve();\n            reader.close();\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    BigInteger nextBigInteger() throws IOException {\n        return new BigInteger(nextToken());\n    }\n\n    String nextToken() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n    void p(Object... objects) {\n        for (int i = 0; i < objects.length; i++) {\n            if (i != 0)\n                writer.print(' ');\n            writer.flush();\n            writer.print(objects[i]);\n            writer.flush();\n        }\n    }\n\n    void pl(Object... objects) {\n        p(objects);\n        writer.flush();\n        writer.println();\n        writer.flush();\n    }\n\n    int cc;\n\n    void pf() {\n        writer.printf(\"Case #%d: \", ++cc);\n        writer.flush();\n    }\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskB solver = new TaskB();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskB {\n\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n        int n = in.nextInt();\n        int k = in.nextInt();\n        String left = in.next();\n        String right = in.next();\n        String[] sides = new String[]{left, right};\n        int[] when = new int[2 * n];\n        Arrays.fill(when, -1);\n        when[0] = 0;\n        int[] queue = new int[2 * n + 10];\n        int qt = 0;\n        int qh = 1;\n        queue[0] = 0;\n        while (qt < qh) {\n            int cur = queue[qt++];\n            int cside = cur & 1;\n            int cpos = cur >> 1;\n            int nwhen = when[cur] + 1;\n            {\n                int nside = cside;\n                int npos = cpos + 1;\n                if (npos >= n) {\n                    out.println(\"YES\");\n                    return;\n                }\n                if (npos >= nwhen) {\n                    int nat = (npos << 1) + nside;\n                    if (when[nat] < 0 && sides[nside].charAt(npos) == '-') {\n                        when[nat] = nwhen;\n                        queue[qh++] = nat;\n                    }\n                }\n            }\n            {\n                int nside = cside;\n                int npos = cpos - 1;\n                if (npos >= n) {\n                    out.println(\"YES\");\n                    return;\n                }\n                if (npos >= nwhen) {\n                    int nat = (npos << 1) + nside;\n                    if (when[nat] < 0 && sides[nside].charAt(npos) == '-') {\n                        when[nat] = nwhen;\n                        queue[qh++] = nat;\n                    }\n                }\n            }\n            {\n                int nside = 1 - cside;\n                int npos = cpos + k;\n                if (npos >= n) {\n                    out.println(\"YES\");\n                    return;\n                }\n                if (npos >= nwhen) {\n                    int nat = (npos << 1) + nside;\n                    if (when[nat] < 0 && sides[nside].charAt(npos) == '-') {\n                        when[nat] = nwhen;\n                        queue[qh++] = nat;\n                    }\n                }\n            }\n        }\n        out.println(\"NO\");\n\t}\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    }\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class canyonjump\n{\n   public static boolean win;\n   public static Queue<coord> q;\n   public static boolean[][] v;\n   public static char[][] canyon;\n   public static int water, k, n;\n   public static void main(String[] args) throws IOException\n   {\n      Scanner infile = new Scanner(System.in);\n      PrintWriter outfile = new PrintWriter(System.out);\n      n = infile.nextInt();\n      k = infile.nextInt();\n      canyon = new char[n][2];\n      for(int x = 0; x < 2; x++){\n         String s = infile.next();\n         for(int y = 0; y < n; y++){\n            canyon[y][x] = s.charAt(y);\n         }\n      }\n      water = 0;\n      boolean[][] visited = new boolean[n][2];\n      visited[0][0] = true;\n      q = new LinkedList<coord>();\n      q.add(new coord(0,0,0));\n      win = false;\n      while(!q.isEmpty()){\n         coord c = q.remove();\n         if(c.x < c.w){\n            continue;\n         }\n         if(c.x + k >= n){\n            while(!q.isEmpty())\n               q.remove();\n            win = true;\n            continue;\n         }\n         if(c.x + k <= n && !visited[c.x+k][(c.y+1) % 2] && canyon[c.x+k][(c.y+1) % 2] == '-'){\n            visited[c.x+k][(c.y+1) % 2] = true;\n            q.add(new coord(c.x+k, (c.y+1) % 2, c.w+1));\n         }\n         if(c.x < n && !visited[c.x+1][c.y] && canyon[c.x+1][c.y] == '-'){\n            visited[c.x+1][c.y] = true;\n            q.add(new coord(c.x+1, c.y, c.w+1));\n         }\n         if(c.x-1 >= water && c.x > 0 && !visited[c.x-1][c.y] && canyon[c.x-1][c.y] == '-'){\n            visited[c.x-1][c.y] = true;\n            q.add(new coord(c.x-1, c.y, c.w+1));\n         }\n      }      \n         \n      //v = new boolean[n][2];\n   //       solution(0,0);\n      if(win)\n         outfile.println(\"YES\");\n      else\n         outfile.println(\"NO\");\n      outfile.close();\n   }\n}\nclass coord\n{\n   public int x,y,w;\n   public coord(int x, int y, int w){\n      this.x = x;\n      this.y = y;\n      this.w = w;\n   }\n   public String toString(){\n      return \"(\" + x + \", \" + y + \")\";\n   } \n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar a[2][100005];\nint ok[2][100005];\nqueue<int> Q;\nint ans = 0, n, k;\nvoid chk(int x, int y, int t) {\n  if (y < t || y <= 0) return;\n  if (y > n) {\n    ans = 1;\n    return;\n  }\n  if (ok[x][y] || a[x][y] == 'X') return;\n  ok[x][y] = t;\n  Q.push(x);\n  Q.push(y);\n}\nint main(void) {\n  scanf(\"%d%d\", &n, &k);\n  scanf(\"%s%s\", a[0] + 1, a[1] + 1);\n  Q.push(0);\n  Q.push(1);\n  ok[0][1] = 1;\n  while (!ans && !Q.empty()) {\n    int x = Q.front();\n    Q.pop();\n    int y = Q.front();\n    Q.pop();\n    int t = ok[x][y];\n    chk(x, y - 1, t + 1);\n    chk(x, y + 1, t + 1);\n    chk(!x, y + k, t + 1);\n  }\n  puts(ans ? \"YES\" : \"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar a[2][1000010];\nint vis[2][1000010], qx[2000020], qy[2000020], fi, fj, x, y, k, n;\nint main() {\n  cin >> n >> k;\n  cin >> a[0];\n  cin >> a[1];\n  vis[0][0] = 1;\n  for (fj = 1; fi < fj;) {\n    x = qx[fi];\n    y = qy[fi++];\n    if (y >= n - k) {\n      cout << \"YES\";\n      return 0;\n    }\n    if (y > 0 && a[x][y - 1] == '-' && vis[x][y - 1] == 0 && y > vis[x][y])\n      vis[x][y - 1] = vis[x][y] + 1, qx[fj] = x, qy[fj++] = y - 1;\n    if (a[x][y + 1] == '-' && vis[x][y + 1] == 0)\n      vis[x][y + 1] = vis[x][y] + 1, qx[fj] = x, qy[fj++] = y + 1;\n    if (a[1 - x][y + k] == '-' && vis[1 - x][y + k] == 0)\n      vis[1 - x][y + k] = vis[x][y] + 1, qx[fj] = 1 - x, qy[fj++] = y + k;\n  }\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar a[5][100005];\nqueue<pair<int, int> > que;\nint n, k, water[5][100005];\nint main() {\n  cin >> n >> k;\n  getchar();\n  for (int t = 1; t <= 2; t++)\n    for (int i = 1; i <= n; i++) cin >> a[t][i];\n  que.push(make_pair(1, 1));\n  water[1][1] = 1;\n  while (!que.empty()) {\n    int x = que.front().first;\n    int y = que.front().second;\n    que.pop();\n    if (y + 1 > n || y + k > n) {\n      cout << \"YES\";\n      return 0;\n    }\n    if (a[x][y + 1] == '-' && !water[x][y + 1]) {\n      que.push(make_pair(x, y + 1));\n      water[x][y + 1] = water[x][y] + 1;\n    }\n    if (a[3 - x][y + k] == '-' && !water[3 - x][y + k]) {\n      que.push(make_pair(3 - x, y + k));\n      water[3 - x][y + k] = water[x][y] + 1;\n    }\n    if (a[x][y - 1] == '-' && y - 1 > water[x][y] && !water[x][y - 1]) {\n      que.push(make_pair(x, y - 1));\n      water[x][y - 1] = water[x][y] + 1;\n    }\n  }\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(2)\n#pragma GCC optimize(3, \"Ofast\", \"inline\")\nusing namespace std;\nconst int mod = 10007;\nconst int M = 2 * 1e2 + 5;\nconst int N = 1e5 + 5;\nint n, m;\nchar s[3][N];\nint v[3][N];\nbool dfs(int x, int y, int h) {\n  if (y > n) return 1;\n  if (v[x][y] || s[x][y] == 'X' || y < h) return 0;\n  v[x][y] = 1;\n  if (dfs(3 - x, y + m, h + 1) | dfs(x, y + 1, h + 1) | dfs(x, y - 1, h + 1))\n    return 1;\n  return 0;\n}\nsigned main() {\n  cin >> n >> m;\n  for (int i = 1; i <= 2; i++) scanf(\"%s\", s[i] + 1);\n  if (dfs(1, 1, 1))\n    printf(\"YES\\n\");\n  else\n    printf(\"NO\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\n\npublic class Solution {\n    static int[] bl, br;\n    \n    \n    static class Position implements Comparable<Position>{\n        int time, h;\n        boolean left;\n        \n        public Position(int time, int h, boolean left) {\n            this.time = time;\n            this.h = h;\n            this.left = left;\n        }\n        \n        @Override\n        public int compareTo(Position o) {\n            if (time < o.time) return -1;\n            else if (time > o.time) return 1;\n            return 0;\n        }\n    }\n    \n    static void qAdd(PriorityQueue<Position> q, String l, String r, Position p) {\n        if (p.h < p.time) return;\n        if (p.left && p.time >= bl[p.h]) return;\n        if (!p.left && p.time >= br[p.h]) return;\n        if (p.left && l.charAt(p.h) == 'X') return;\n        if (!p.left && r.charAt(p.h) == 'X') return;\n        \n        q.add(p);\n        if (p.left) bl[p.h] = p.time;\n        else br[p.h] = p.time;\n    }\n    \n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt(), k = in.nextInt();\n        String l = in.next(), r = in.next();\n        bl = new int[n];\n        br = new int[n];\n        Arrays.fill(bl, Integer.MAX_VALUE);\n        Arrays.fill(br, Integer.MAX_VALUE);\n        bl[0] = 0;\n        PriorityQueue<Position> q = new PriorityQueue<Position>();\n        q.add(new Position(0, 0, true));\n        while (!q.isEmpty()) {\n            Position p = q.poll();\n            if (p.h + k >= n) {\n                System.out.println(\"YES\");\n                return;\n            }\n            qAdd(q, l, r, new Position(p.time + 1, p.h + k, !p.left));\n            qAdd(q, l, r, new Position(p.time + 1, p.h + 1, p.left));\n            qAdd(q, l, r, new Position(p.time + 1, p.h - 1, p.left));\n        }\n        System.out.println(\"NO\");\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n[[maybe_unused]] const int MAX = INT32_MAX, MIN = -INT32_MAX,\n                           maxInd = 1E6 + 1E5 + 1;\n[[maybe_unused]] bool directed = true, end_now = false;\nbool possible = false;\nint n, k;\nstruct node_data_structure {\n  int pre = 0, post = 0;\n  bool visited = false, processed = false;\n} nodes[maxInd];\nvector<int> graph[maxInd];\nvoid insert_graph(int pre, int post) {\n  graph[pre].push_back(post);\n  nodes[pre].post++;\n  nodes[post].pre++;\n  if (!directed) {\n    graph[post].push_back(pre);\n    nodes[post].post++;\n    nodes[pre].pre++;\n  }\n}\n[[maybe_unused]] void undoVisit() {\n  for (auto &i : nodes) {\n    i.visited = false;\n    i.processed = false;\n  }\n  end_now = false;\n}\nvoid dfs(int u, int ac = 1) {\n  if (end_now) return;\n  if (u > 1E6) {\n    if (u - 1E6 < ac) return;\n    if (u - 1E6 + k > n || u - 1E6 == n) {\n      end_now = true;\n      possible = true;\n      return;\n    }\n  } else {\n    if (u < ac) return;\n    if (u + k > n || u == n) {\n      end_now = true;\n      possible = true;\n      return;\n    }\n  }\n  nodes[u].visited = true;\n  for (int v : graph[u]) {\n    if (!nodes[v].visited) {\n      dfs(v, ac + 1);\n    }\n  }\n  nodes[u].processed = true;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  string s1, s2;\n  cin >> n >> k >> s1 >> s2;\n  for (int i = 1; i < n; i++) {\n    if (i + k <= n) {\n      if (s1[i - 1] == '-' && s2[i - 1 + k] == '-') {\n        insert_graph(i, 1E6 + i + k);\n      }\n      if (s2[i - 1] == '-' && s1[i - 1 + k] == '-') {\n        insert_graph(1E6 + i, i + k);\n      }\n    }\n    if (s1[i] == '-' && s1[i - 1] == '-') {\n      insert_graph(i, i + 1);\n      insert_graph(i + 1, i);\n    }\n    if (s2[i] == '-' && s2[i - 1] == '-') {\n      insert_graph(1E6 + i, 1E6 + i + 1);\n      insert_graph(1E6 + i + 1, 1E6 + i);\n    }\n  }\n  dfs(1);\n  possible ? cout << \"YES\" << endl : cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class CF198B{\n    static class InputReader {\n\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String nextLine() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return nextLine();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static class Point implements Comparable<Point>{\n        int time, pos;\n        boolean left;\n\n        public Point(int time, int pos, boolean left){\n            this.time = time;\n            this.pos = pos;\n            this.left = left;\n        }\n\n        public Point(Point p1){\n            this.time = p1.time;\n            this.pos = p1.pos;\n            this.left = p1.left;\n        }\n\n        @Override\n        public int compareTo(Point p1){\n            return pos - p1.pos;\n        }\n    }\n\n    static Point jump(Point p, int idx){\n        Point ret = new Point(p);\n        ret.time ++;\n        if (idx==0){\n            ret.pos --;\n        } else if (idx==1){\n            ret.pos ++;\n        } else {\n            ret.pos += k;\n            ret.left = !ret.left;\n        }\n        return ret;\n    }\n\n    static boolean check(String[] map, Point p){\n        if (p.pos>=n){\n            return true;\n        }\n        if (p.pos<p.time || vis[p.left?0:1][p.pos]){\n            return false;\n        }\n        return p.left?map[0].charAt(p.pos)=='-':map[1].charAt(p.pos)=='-';\n    }\n\n    static String[] map;\n    static int n, k;\n    static boolean[][] vis;\n\n    public static void main(String[] args){\n        InputReader scn = new InputReader(System.in);\n        n = scn.nextInt();\n        k = scn.nextInt();\n        map = new String[2];\n        vis = new boolean[2][n];\n        for (int i=0; i<2; i++){\n            map[i] = scn.nextLine();\n            Arrays.fill(vis[i], false);\n        }\n        Queue<Point> q = new PriorityQueue<>();\n        q.add(new Point(0, 0, true));\n        vis[0][0] = true;\n        boolean finish = false;\n        while (!q.isEmpty()){\n            Point head = q.remove();\n            if (head.pos>=n-1){\n                finish = true;\n                break;\n            }\n            for (int i=0; i<3; i++){\n                Point tail = jump(head, i);\n                if (check(map, tail)){\n                    q.add(tail);\n                    if (tail.pos>=0&&tail.pos<n) {\n                        vis[tail.left ? 0 : 1][tail.pos] = true;\n                    }\n                }\n            }\n        }\n        System.out.println(finish?\"YES\":\"NO\");\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.PrintWriter;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n    static class Point {\n        public int x,y,step;\n        public Point(int x, int y, int step) {\n            this.x = x;\n            this.y = y;\n            this.step = step;\n        }\n    }\n    \n    public static void main(String[] args) {\n\n        Scanner in = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        \n        int n = in.nextInt(), k =in.nextInt();in.nextLine();\n        char[][] way = new char[2][];\n        way[0] = in.nextLine().toCharArray();\n        way[1] = in.nextLine().toCharArray();\n        \n        \n        boolean[][] used = new boolean[2][n];\n        //used[0] = new boolean[]\n        \n        Queue<Point> q = new LinkedList<Point>();\n        \n        Point current;\n        \n        q.add(new Point(0, 0, 0));\n        \n        boolean find = false;\n        while (!q.isEmpty()) {\n            current = q.poll();\n            if (current.y+k>=n) {\n                find = true;\n                break;\n            } else {\n                \n                if (way[current.x][current.y+1]=='-') {\n                    if (!used[current.x][current.y+1]) {\n                        used[current.x][current.y+1] = true;\n                        q.add(new Point(current.x, current.y+1, current.step+1));\n                    }\n                }\n                \n                if (current.y+k<n && \n                    way[(current.x+1)%2][current.y+k]=='-') {\n                    if (!used[(current.x+1)%2][current.y+k]) {\n                        used[(current.x+1)%2][current.y+k] = true;\n                        q.add(new Point((current.x+1)%2, current.y+k, current.step+1));\n                    }\n                }\n                \n                if (current.y-1>-1 && \n                    way[current.x][current.y-1]=='-' &&\n                    current.step<current.y-1)  \n                {   \n                    if (!used[current.x][current.y-1]) {\n                        used[current.x][current.y-1]=true;\n                        q.add(new Point(current.x, current.y-1, current.step+1));\n                    }\n                }\n\n                \n            }\n        }\n        \n        out.println(find?\"YES\":\"NO\");\n        in.close();\n        out.close();\n        \n    }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint Q[1000000][2], L, R;\nint f[101000][2];\nint N, K, i, ans;\nchar mat[2][101000];\nbool mark[101000][2];\nvoid push(int pos, int st, int val) {\n  if (pos >= N) {\n    ans = 1;\n    return;\n  }\n  if (mat[st][pos] == 'X') return;\n  if (f[pos][st] == -1 || val < f[pos][st]) {\n    f[pos][st] = val;\n    if (!mark[pos][st]) {\n      mark[pos][st] = 1;\n      Q[R][0] = pos, Q[R][1] = st;\n      R++;\n    }\n  }\n}\nint main() {\n  while (scanf(\"%d%d\", &N, &K) != EOF) {\n    scanf(\"%s%s\", mat[0], mat[1]);\n    L = 0, R = 0;\n    ans = 0;\n    for (i = 0; i < N; i++) f[i][0] = f[i][1] = -1, mark[i][0] = mark[i][1] = 0;\n    push(0, 0, 0);\n    while (L < R && !ans) {\n      int pos = Q[L][0], st = Q[L][1];\n      mark[pos][st] = 0;\n      L++;\n      if (pos < f[pos][st] || mat[st][pos] == 'X') continue;\n      push(pos + 1, st, f[pos][st] + 1);\n      if (pos >= 1) push(pos - 1, st, f[pos][st] + 1);\n      push(pos + K, st ^ 1, f[pos][st] + 1);\n    }\n    printf(ans ? \"YES\\n\" : \"NO\\n\");\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double pi = 3.141592653589793;\nconst double tau = 6.283185307179586;\nconst double epsilon = 1e-6;\nconst int INF = 1 << 26;\nconst int MAXN = 100005;\nint vis[MAXN * 2][2];\nint graph[MAXN * 2][2];\nint n, k;\nint convert(char a) {\n  if (a == '-') return 1;\n  if (a == 'X') return 0;\n  return -1;\n}\nint ss(int a) { return a == 0 ? 1 : 0; }\nint bfs(int x, int y) {\n  queue<pair<int, pair<int, int> > > q;\n  q.push(make_pair(0, make_pair(x, y)));\n  int a, b, c;\n  while (q.size()) {\n    pair<int, pair<int, int> > cur = q.front();\n    q.pop();\n    a = cur.second.first;\n    b = cur.second.second;\n    c = cur.first;\n    if (c > a) continue;\n    if (a + k >= n) {\n      cout << \"YES\" << endl;\n      return 1;\n    }\n    if (vis[a][b] < c) continue;\n    if (graph[a + k][ss(b)] == 1) {\n      if (a >= n) {\n        cout << \"YES\" << endl;\n        return 1;\n      }\n      if (vis[a + k][ss(b)] == INF) {\n        vis[a + k][ss(b)] = c + 1;\n        q.push(make_pair(c + 1, make_pair(a + k, ss(b))));\n      }\n    }\n    if (graph[a + 1][b] == 1) {\n      if (a >= n) {\n        cout << \"YES\" << endl;\n        return 1;\n      }\n      if (vis[a + 1][b] == INF) {\n        vis[a + 1][b] = c + 1;\n        q.push(make_pair(c + 1, make_pair(a + 1, b)));\n      }\n    }\n    if (graph[a - 1][b] == 1) {\n      if (a >= n) {\n        cout << \"YES\" << endl;\n        return 1;\n      }\n      if (vis[a - 1][b] == INF) {\n        vis[a - 1][b] = c + 1;\n        q.push(make_pair(c + 1, make_pair(a - 1, b)));\n      }\n    }\n  }\n  return 0;\n}\nint main(int argc, char** argv) {\n  scanf(\"%d %d\\n\", &n, &k);\n  for (int i = 0; i < 2 * n; i++) {\n    char a;\n    scanf(\"%c\", &a);\n    if (a == '\\n') {\n      i--;\n      continue;\n    }\n    graph[i % n][i / n] = convert(a);\n  }\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 2 * n; j++) {\n      vis[j][i] = INF;\n    }\n  if (!bfs(0, 0)) cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\n\npublic class JumpingOnWalls \n{\n\n\tpublic static void main(String[] args) throws IOException \n\t{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] data = in.readLine().split(\" \");\n\t\tint n = Integer.parseInt(data[0]);\n\t\tint k = Integer.parseInt(data[1]);\n\t\tchar [] left = in.readLine().trim().toCharArray();\n\t\tboolean [] visitadol = new boolean[n];\n\t\tchar [] right = in.readLine().trim().toCharArray();\n\t\tboolean [] visitador = new boolean[n];\n\t\tQueue<Area> cola = new LinkedList<Area>();\n\t\tcola.add(new Area(true,1,0));\n\t\twhile(!cola.isEmpty())\n\t\t{\n\t\t\tArea next = cola.poll();\n\t\t\tif (next.nivel+k>n)\n\t\t\t{\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (next.left)\n\t\t\t{\n\t\t\t\tif (left[next.nivel+1-1] =='-' && !visitadol[next.nivel+1-1])\n\t\t\t\t{\n\t\t\t\t\tcola.add(new Area(true,next.nivel+1,next.nivelDeAgua+1));\n\t\t\t\t\tvisitadol[next.nivel+1-1] = true;\n\t\t\t\t}\n\t\t\t\tif (right[next.nivel+k-1] =='-' && !visitador[next.nivel+k-1])\n\t\t\t\t{\n\t\t\t\t\tcola.add(new Area(false,next.nivel+k,next.nivelDeAgua+1));\n\t\t\t\t\tvisitador[next.nivel+k-1] = true;\n\t\t\t\t}\n\t\t\t\tif (next.nivel > next.nivelDeAgua+2 && left[next.nivel-1-1] =='-' && !visitadol[next.nivel-1-1])\n\t\t\t\t{\n\t\t\t\t\tcola.add(new Area(true,next.nivel-1,next.nivelDeAgua+1));\n\t\t\t\t\tvisitadol[next.nivel-1-1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (right[next.nivel+1-1] =='-' && !visitador[next.nivel+1-1])\n\t\t\t\t{\n\t\t\t\t\tcola.add(new Area(false,next.nivel+1,next.nivelDeAgua+1));\n\t\t\t\t\tvisitador[next.nivel+1-1] = true;\n\t\t\t\t}\n\t\t\t\tif (left[next.nivel+k-1] =='-' && !visitadol[next.nivel+k-1])\n\t\t\t\t{\n\t\t\t\t\tcola.add(new Area(true,next.nivel+k,next.nivelDeAgua+1));\n\t\t\t\t\tvisitadol[next.nivel+k-1] = true;\n\t\t\t\t}\n\t\t\t\tif (next.nivel > next.nivelDeAgua+2 && right[next.nivel-1-1] =='-' && !visitador[next.nivel-1-1])\n\t\t\t\t{\n\t\t\t\t\tcola.add(new Area(false,next.nivel-1,next.nivelDeAgua+1));\n\t\t\t\t\tvisitador[next.nivel-1-1] = true;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\tSystem.out.println(\"NO\");\n\t\t\n\t}\n\n}\nclass Area\n{\n\tpublic boolean left;\n\tpublic int nivel;\n\tpublic int nivelDeAgua;\n\tpublic Area(boolean left, int nivel, int nivelDeAgua)\n\t{\n\t\tthis.left = left;\n\t\tthis.nivel = nivel;\n\t\tthis.nivelDeAgua = nivelDeAgua;\n\t}\n\t\n\t\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\n\npublic class D implements Runnable {\n\n    public static final char WALL = '-';\n    public static final char DANGEROUS_WALL = 'X';\n\n    public static final int LEFT_WALL = 0;\n    public static final int RIGHT_WALL = 1;\n    \n    private PrintWriter out = new PrintWriter(System.out, true);\n    private BufferedReader reader;\n    \n    private int n, k;\n    private char[][] walls;\n    private boolean[][] visit;\n\n    @Override\n    public void run() {\n        try {\n            String[] first = reader.readLine().split(\"\\\\s+\");\n            n = Integer.parseInt(first[0]);\n            k = Integer.parseInt(first[1]);\n            \n            char[] left = reader.readLine().toCharArray();\n            char[] right = reader.readLine().toCharArray();\n            walls = new char[][] { left, right };\n            visit = new boolean[2][n];\n            \n            boolean res = calc();\n            out.println(res ? \"YES\" : \"NO\");\n            out.flush();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public boolean calc() {\n        return dfs(0, LEFT_WALL, 0);\n    }\n\n    public boolean dfs(int position, int wallSide, int waterLevel) {\n        if (position >= n - 1) {\n            return true;\n        }\n\n        if (position < waterLevel) {\n            return false;\n        }\n        \n        int jumpPosition = position + k;\n        if (jumpPosition >= n) {\n            return true;\n        }\n        \n        visit[wallSide][position] = true;\n        \n        int oppositeWall = (wallSide + 1) % 2;\n        int newWaterLevel = waterLevel + 1;\n        \n        if (canProceed(jumpPosition, oppositeWall)) {\n            if (dfs(jumpPosition, oppositeWall, newWaterLevel)) {\n                return true;\n            }\n        }\n        \n        int nextPosition = position + 1;\n        if (canProceed(nextPosition, wallSide)) {\n            if (dfs(nextPosition, wallSide, newWaterLevel)) {\n                return true;\n            }\n        }\n        \n        int downPosition = position - 1;\n        if (canProceed(downPosition, wallSide)) {\n            if (dfs(downPosition, wallSide, newWaterLevel)) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    private boolean canProceed(int position, int wall) {\n        if (position < 0 || position >= n) {\n            return false;\n        }\n        return notVisited(position, wall) && canVisit(position, wall);\n    }\n\n    private boolean canVisit(int position, int wall) {\n        return walls[wall][position] != DANGEROUS_WALL;\n    }\n\n    private boolean notVisited(int position, int wall) {\n        return !visit[wall][position];\n    }\n\n    public D setInput(InputStream inputStream) {\n        this.reader = new BufferedReader(new InputStreamReader(inputStream));\n        return this;\n    }\n\n    public static void main(String[] args) {\n        new D().setInput(System.in).run();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst double pi = acos(-1.0), eps = 1e-9;\nconst int dx[8] = {1, -1, 0, 0, 1, 1, -1, -1};\nconst int dy[8] = {0, 0, 1, -1, 1, -1, -1, 1};\nconst int MO = (int)(1e9 + 7);\nusing namespace std;\nbool vis[3][2000001];\nint time1[3][2000001];\nchar s[3][2000001];\nint n, k;\nqueue<pair<int, int> > Q;\nvoid bfs(int x, int y) {\n  Q.push(make_pair(x, y));\n  vis[x][y] = true;\n  while (!Q.empty()) {\n    pair<int, int> now = Q.front();\n    int x = now.first, y = now.second, nt = ::time1[x][y];\n    Q.pop();\n    if (y > 1 && nt + 1 < y - 1 && !vis[x][y - 1] && s[x][y - 1] == '-') {\n      time1[x][y - 1] = time1[x][y] + 1;\n      vis[x][y - 1] = true;\n      Q.push(make_pair(x, y - 1));\n    }\n    if (y < n && nt + 1 < y + 1 && !vis[x][y + 1] && s[x][y + 1] == '-') {\n      time1[x][y + 1] = time1[x][y] + 1;\n      vis[x][y + 1] = true;\n      Q.push(make_pair(x, y + 1));\n    }\n    if (y + k <= n && nt + 1 < y + k && !vis[x % 2 + 1][y + k] &&\n        s[x % 2 + 1][y + k] == '-') {\n      time1[x % 2 + 1][y + k] = time1[x][y] + 1;\n      vis[x % 2 + 1][y + k] = true;\n      Q.push(make_pair(x % 2 + 1, y + k));\n    }\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  scanf(\" \");\n  gets(s[1] + 1);\n  gets(s[2] + 1);\n  bfs(1, 1);\n  bool ok = false;\n  for (int i = 1; i <= 2; i++)\n    for (int j = 1; j <= n; j++)\n      if (vis[i][j] && j + k > n) ok = true;\n  puts(ok ? \"YES\" : \"NO\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint d[200005][2];\nint main() {\n  srand((unsigned int)time(NULL));\n  int n, k;\n  cin >> n >> k;\n  string le[2];\n  cin >> le[0] >> le[1];\n  for (int i = 0; i < 2; i++)\n    while (le[i].size() < 200000) le[i].push_back('-');\n  for (int i = 1; i <= 200000; i++) {\n    for (int j = 0; j < 2; j++) {\n      d[i][j] = 1000000000;\n    }\n  }\n  priority_queue<pair<int, pair<int, int> >,\n                 vector<pair<int, pair<int, int> > >,\n                 greater<pair<int, pair<int, int> > > >\n      que;\n  d[1][0] = 1;\n  que.push(make_pair(1, make_pair(1, 0)));\n  while (!que.empty()) {\n    pair<int, pair<int, int> > p = que.top();\n    que.pop();\n    if (p.first != d[p.second.first][p.second.second]) continue;\n    int time = p.first;\n    int height = p.second.first;\n    int side = p.second.second;\n    if (time + 1 <= height - 1 && 1 <= height - 1 &&\n        le[side][height - 2] == '-' && d[height - 1][side] > time + 1) {\n      d[height - 1][side] = time + 1;\n      if (height - 1 <= n)\n        que.push(make_pair(time + 1, make_pair(height - 1, side)));\n    }\n    if (time + 1 <= height + 1 && 1 <= height + 1 && le[side][height] == '-' &&\n        d[height + 1][side] > time + 1) {\n      d[height + 1][side] = time + 1;\n      if (height + 1 <= n)\n        que.push(make_pair(time + 1, make_pair(height + 1, side)));\n    }\n    if (time + 1 <= height + k && 1 <= height + k &&\n        le[1 - side][height + k - 1] == '-' &&\n        d[height + k][1 - side] > time + 1) {\n      d[height + k][1 - side] = time + 1;\n      if (height + k <= n)\n        que.push(make_pair(time + 1, make_pair(height + k, 1 - side)));\n    }\n  }\n  for (int i = n + 1; i <= 200000; i++)\n    for (int j = 0; j < 2; j++)\n      if (d[i][j] != 1000000000) {\n        cout << \"YES\" << endl;\n        return 0;\n      }\n  cout << \"NO\" << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class D {\n\tpublic static int n;\n\tpublic static int k;\n\tpublic static boolean [][] grid;\n\tpublic static int [][] visited;\n\tpublic static void main(String[] args) throws IOException {\n\t\tFastScanner in = new FastScanner(System.in);\n\t\tint n= in.nextInt();\n\t\tint k= in.nextInt();\n\t\tgrid= new boolean[2][n];\n\t\tvisited= new int[2][n];\n\t\tfor (int i = 0; i < visited.length; i++) {\n\t\t\tArrays.fill(visited[i], Integer.MAX_VALUE);\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tchar [] a= in.next().toCharArray();\n\t\t\tfor (int j = 0; j < a.length; j++) {\n\t\t\t\tif(a[j]=='-'){\n\t\t\t\t\tgrid[i][j]= true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tArrayDeque<state> q= new ArrayDeque<state>();\n\t\tq.offer(new state(0,0,0));\n\t\twhile(!q.isEmpty()){\n\t\t\tstate cur= q.poll();\n\t\t\tif(cur.h>=n){\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(cur.h<0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(!grid[cur.wall][cur.h]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(visited[cur.wall][cur.h]<=cur.wlvl){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvisited[cur.wall][cur.h]= cur.wlvl;\n\t\t\tif(cur.h<cur.wlvl){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tq.offer(new state(cur.wall, cur.h+1, cur.wlvl+1));\n\t\t\tq.offer(new state(cur.wall, cur.h-1, cur.wlvl+1));\n\t\t\tq.offer(new state(Math.abs(cur.wall-1), cur.h+k, cur.wlvl+1));\n\t\t}\n\t\tSystem.out.println(\"NO\");\n\t\t\n\t}\n\tstatic class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tpublic FastScanner(InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t\tst = new StringTokenizer(\"\");\n\t\t}\n\t\tpublic String next() throws IOException {\n\t\t\tif(!st.hasMoreTokens()) {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\treturn next();\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t}\n}\nclass state{\n\tint wall;\n\tint h;\n\tint wlvl;\n\tpublic state(int a, int b, int c){\n\t\twall= a;\n\t\th= b;\n\t\twlvl= c;\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class D125 {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\t\tString s = r.readLine();\n\t\tString[] sp = s.split(\"[ ]+\");\n\t\tint n = new Integer(sp[0]);\n\t\tint k = new Integer(sp[1]);\n\t\tchar[] left = r.readLine().toCharArray();\n\t\tchar[] right = r.readLine().toCharArray();\n\t\tchar[][] arr = new char[2][];\n\t\tarr[0] = left;\n\t\tarr[1] = right;\n\t\tboolean[][] vis = new boolean[n][2];\n\t\tLinkedList<Integer> q = new LinkedList<Integer>();\n\t\tq.add(0);\n\t\tq.add(0);\n\t\tq.add(0);\n\t\tvis[0][0] = true;\n\t\twhile (!q.isEmpty()) {\n\t\t\tint index = q.remove();\n\t\t\tint side = q.remove();\n\t\t\tint cost = q.remove();\n\t\t\tif (index >= n) {\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (index - 1 >= 0 && !vis[index - 1][side] && cost + 1 < index\n\t\t\t\t\t&& arr[side][index - 1] != 'X') {\n\t\t\t\tq.add(index - 1);\n\t\t\t\tq.add(side);\n\t\t\t\tq.add(cost + 1);\n\t\t\t\tvis[index - 1][side] = true;\n\t\t\t}\n\t\t\tif (index + 1 >= n) {\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tif (!vis[index + 1][side] && cost + 1 < index + 2\n\t\t\t\t\t\t&& arr[side][index + 1] != 'X') {\n\t\t\t\t\tq.add(index + 1);\n\t\t\t\t\tq.add(side);\n\t\t\t\t\tq.add(cost + 1);\n\t\t\t\t\tvis[index + 1][side] = true;\n\t\t\t\t}\n\t\t\t\tif(index+k>=n){\n\t\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\t\treturn;\n\t\t\t\t}else{\n\t\t\t\t\tif(!vis[index+k][1-side]&&cost+1<index+k+1&&arr[1-side][index+k]!='X'){\n\t\t\t\t\t\tq.add(index + k);\n\t\t\t\t\t\tq.add(1-side);\n\t\t\t\t\t\tq.add(cost + 1);\n\t\t\t\t\t\tvis[index + k][1-side] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"NO\");\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100010;\nstruct P {\n  int l, s;\n  P(int s, int l) : s(s), l(l) {}\n  P() {}\n};\nchar s[2][MAXN];\nint dp[2][MAXN];\nint n;\nint ans = false;\nqueue<P> q;\nvoid gao(int S, int l, int t) {\n  if (l >= n) {\n    ans = true;\n    return;\n  }\n  if (s[S][l] == '-' && dp[S][l] == -1) {\n    q.push(P(S, l));\n    dp[S][l] = t + 1;\n  }\n}\nint main() {\n  int i, j, k;\n  scanf(\"%d%d\", &n, &k);\n  scanf(\"%s%s\", s[0], s[1]);\n  memset(dp, -1, sizeof(dp));\n  q.push(P(0, 0));\n  dp[0][0] = 0;\n  while (!q.empty() && !ans) {\n    P u = q.front();\n    int t = dp[u.s][u.l];\n    q.pop();\n    gao(u.s, u.l + 1, t);\n    if (u.l - 1 > t) {\n      gao(u.s, u.l - 1, t);\n    }\n    gao(1 - u.s, u.l + k, t);\n  }\n  puts(ans ? \"YES\" : \"NO\");\n}\n"
        },
        {
            "language": 4,
            "solution": "//package com.yaroslav.shlapak;\n\nimport java.util.Scanner;\n\n/**\n * Created by y.shlapak on Apr 05, 2016.\n */\n\n/*\n7 3\n---X--X\n-X--XX-\n*/\n\npublic class JumpingOnWalls {\n    static int n, k;\n    static int[][] tunnel;\n    static int[][] tunnelClone;\n    static int waterLevel = 0;\n    static boolean done = false;\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        n = scanner.nextInt();\n        k = scanner.nextInt();\n\n        tunnel = new int[n + k + 1][2];\n        tunnelClone = new int[n + k + 1][2];\n\n        String leftString = scanner.next();\n        String rightString = scanner.next();\n\n        for(int i = 0; i < leftString.length(); i++) {\n            tunnel[i][0] = leftString.charAt(i) == 'X' ? 1 : 0;\n            tunnel[i][1] = rightString.charAt(i) == 'X' ? 1 : 0;\n            //tunnelClone[i][0] = n + 1;\n            //tunnelClone[i][1] = n + 1;\n        }\n\n        /*\n        for(int i = 0; i < n; i++) {\n            System.out.print(\"\" + tunnel[i][0]);\n        }\n        System.out.println();\n        for(int i = 0; i < n; i++) {\n            System.out.print(\"\" + tunnel[i][1]);\n        }\n        System.out.println();\n        */\n\n        int level = 0;\n        int waterLevel = 0;\n        int side = 0; //left\n        /*int[] temp;\n        Queue queue = new Queue(n * 2);\n        moveQueue(level, waterLevel, side, queue);\n        while(!queue.isEmpty()) {\n            if(done) {\n                break;\n            }\n            temp = queue.pop();\n\n            level = temp[0];\n            side = temp[1];\n            waterLevel = temp[2];\n\n            moveQueue(level, side, waterLevel, queue);\n        }*/\n\n\n\n        move(level, side, waterLevel);\n        if(done) {\n            System.out.println(\"YES\");\n        } else {\n            System.out.println(\"NO\");\n        }\n\n    }\n\n\n    private static void moveQueue(int level, int side, int waterLevel, Queue queue) {\n        //System.out.println(\"\" + level + \" \" + side);\n        if(done) {\n            return;\n        }\n\n        if(level + k > n ) {\n            done = true;\n            return;\n        }\n\n        if(tunnel[level + k][side == 0 ? 1 : 0] == 0 && tunnelClone[level + k][side == 0 ? 1 : 0] == 0) {\n            tunnelClone[level + k][side == 0 ? 1 : 0] = 1;\n            queue.push(level + k, side == 0 ? 1 : 0, waterLevel + 1);\n        }\n\n        if(tunnel[level + 1][side] == 0 && tunnelClone[level + 1][side] == 0) {\n            tunnelClone[level + 1][side] = 1;\n            queue.push(level + 1, side, waterLevel + 1);\n        }\n\n        if(level > 0 && tunnel[level - 1][side] == 0 && waterLevel + 1 <= level - 1 && tunnelClone[level - 1][side] == 0) {\n            tunnelClone[level - 1][side] = 1;\n            queue.push(level - 1, side, waterLevel + 1);\n        }\n    }\n\n\n    private static void move(int level, int side, int waterLevel) {\n        //System.out.println(\"\" + level + \" \" + side);\n        if(done) {\n            return;\n        }\n\n        if(level + k > n ) {\n            done = true;\n            return;\n        }\n\n        if(tunnel[level + k][side == 0 ? 1 : 0] == 0 && tunnelClone[level + k][side == 0 ? 1 : 0] == 0) {\n            tunnelClone[level + k][side == 0 ? 1 : 0] = 1;\n            move(level + k, side == 0 ? 1 : 0, waterLevel + 1);\n        }\n\n        if(tunnel[level + 1][side] == 0 && tunnelClone[level + 1][side] == 0) {\n            tunnelClone[level + 1][side] = 1;\n            move(level + 1, side, waterLevel + 1);\n        }\n\n        if(level > 0 && tunnel[level - 1][side] == 0 && waterLevel + 1 <= level - 1 && tunnelClone[level - 1][side] == 0) {\n            tunnelClone[level - 1][side] = 1;\n            move(level - 1, side, waterLevel + 1);\n        }\n\n    }\n\n    private static class Queue {\n        private int size;\n        private int front;\n        private int back;\n        private int[][] queue;\n\n        public Queue(int size) {\n            this.size = size;\n            queue = new int[size][3];\n            front = back = 0;\n        }\n\n        public void push(int level, int side, int waterLevel) {\n            if(back < size) {\n                queue[back][0] = level;\n                queue[back][1] = side;\n                queue[back][2] = waterLevel;\n                back++;\n            }\n        }\n\n        public int[] pop() {\n            if(front <= back) {\n                return queue[front++];\n            } else {\n                return new int[]{-1, -1, -1};\n            }\n        }\n\n        public int getSize() {\n            return this.size;\n        }\n\n        public  boolean isEmpty() {\n            return front == back;\n        }\n    }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int min(int a, int b) { return a < b ? a : b; }\nchar s[2][100005];\nint dp[2][100005];\nbool gao(int n, int k) {\n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < n; j++) {\n      dp[i][j] = (1 << 30);\n    }\n  }\n  queue<pair<int, int> > que;\n  que.push(pair<int, int>(0, 0));\n  dp[0][0] = 0;\n  while (que.empty() == false) {\n    int i = que.front().first;\n    int j = que.front().second;\n    int t = dp[i][j];\n    que.pop();\n    if (j + 1 >= n || j + k >= n) {\n      return true;\n    }\n    if (s[i][j + 1] != 'X') {\n      if (t + 1 < dp[i][j + 1]) {\n        dp[i][j + 1] = t + 1;\n        que.push(pair<int, int>(i, j + 1));\n      }\n    }\n    if (j > 0 && s[i][j - 1] != 'X' && j - 1 >= t + 1) {\n      if (t + 1 < dp[i][j - 1]) {\n        dp[i][j - 1] = t + 1;\n        que.push(pair<int, int>(i, j - 1));\n      }\n    }\n    if (s[1 - i][j + k] != 'X') {\n      if (t + 1 < dp[1 - i][j + k]) {\n        dp[1 - i][j + k] = t + 1;\n        que.push(pair<int, int>(1 - i, j + k));\n      }\n    }\n  }\n  return false;\n}\nint main() {\n  int n, k;\n  while (scanf(\"%d %d\", &n, &k) != EOF) {\n    scanf(\"%s\", s[0]);\n    scanf(\"%s\", s[1]);\n    bool ans = gao(n, k);\n    puts(ans ? \"YES\" : \"NO\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nstring s[2];\nint timer[300100];\nint used[300100];\nint d[300100];\nint q[300100];\nvector<int> g[300100];\nint get(int x, int y) { return y * 2 + x + 1; }\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> k;\n  cin >> s[0] >> s[1];\n  int out = n * 2 + 1;\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < 2; ++j) {\n      int x = get(j, i);\n      timer[x] = i;\n      if (s[j][i] != 'X') {\n        int to = get(j ^ 1, i + k);\n        if (to >= out) to = out;\n        if (to == out || i + k < n && s[j ^ 1][i + k] != 'X')\n          g[x].push_back(to);\n        to = get(j, i + 1);\n        if (to >= out) to = out;\n        if (to == out || i + 1 < n && s[j][i + 1] != 'X') g[x].push_back(to);\n        to = get(j, i - 1);\n        if (to >= out) to = out;\n        if (to == out || i && s[j][i - 1] != 'X') g[x].push_back(to);\n      }\n    }\n  }\n  timer[out] = n;\n  int qs = 0, qt = 0;\n  q[qt++] = 1;\n  d[1] = 0;\n  used[1] = 1;\n  while (qs < qt) {\n    int v = q[qs++];\n    for (int to : g[v]) {\n      if (!used[to]) {\n        used[to] = 1;\n        d[to] = d[v] + 1;\n        if (d[to] <= timer[to]) q[qt++] = to;\n      }\n    }\n  }\n  if (used[out] && d[out] <= timer[out])\n    cout << \"YES\";\n  else\n    cout << \"NO\";\n}\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.awt.Point;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\npublic class BB implements Runnable{\n\t\n\tfinal boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer tok = new StringTokenizer(\"\");\n\t\n\tvoid init() throws FileNotFoundException{\n\t\tif (ONLINE_JUDGE){\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t}else{\n\t\t\tin = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\tout = new PrintWriter(\"output.txt\");\n\t\t}\n\t}\n\t\n\tString readString() throws IOException{\n\t\twhile(!tok.hasMoreTokens()){\n\t\t\ttry{\n\t\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t\t}catch (Exception e){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\t\n\tint readInt() throws IOException{\n\t\treturn Integer.parseInt(readString());\n\t}\n\t\n\tlong readLong() throws IOException{\n\t\treturn Long.parseLong(readString());\n\t}\n\t\n\tdouble readDouble() throws IOException{\n\t\treturn Double.parseDouble(readString());\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tnew Thread(null, new BB(), \"\", 256 * (1L << 20)).start();\n\t}\n\t\n\tlong timeBegin, timeEnd;\n\n\tvoid time(){\n\t\ttimeEnd = System.currentTimeMillis();\n\t\tSystem.err.println(\"Time = \" + (timeEnd - timeBegin));\n\t}\n\t\n\tlong memoryTotal, memoryFree;\n\t\n\n\tvoid memory(){\n\t\tmemoryFree = Runtime.getRuntime().freeMemory();\n\t\tSystem.err.println(\"Memory = \" + ((memoryTotal - memoryFree) >> 10) + \" KB\");\n\t}\n\t\n\tvoid debug(Object... objects){\n\t\tif (DEBUG){\n\t\t\tfor (Object o: objects){\n\t\t\t\tSystem.err.println(o.toString());\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void run(){\n\t\ttry{\n\t\t\ttimeBegin = System.currentTimeMillis();\n\t\t\tmemoryTotal = Runtime.getRuntime().freeMemory();\n\t\t\tinit();\n\t\t\tsolve();\n\t\t\tout.close();\n\t\t\ttime();\n\t\t\tmemory();\n\t\t}catch (Exception e){\n\t\t\te.printStackTrace(System.err);\n\t\t\tSystem.exit(-1);\n\t\t}\n\t}\n\t\n\tboolean DEBUG = false;\n\t\n\tint n, k;\n\tchar[][] c;\n\t\n\tvoid solve() throws IOException{\n\t\tn = readInt();\n\t\tk = readInt();\n\t\t\n\t\tc = new char[2][n];\n\t\tfor (int i = 0; i < 2; i++){\n\t\t\tc[i] = in.readLine().toCharArray();\n\t\t}\n\t\t\n\t\tout.print(bfs()? \"YES\": \"NO\");\n\t}\n\t\n\tboolean bfs(){\n\t\tboolean[][] used = new boolean[2][n];\n\t\tint[][] d = new int[2][n];\n\t\tfor (int i = 0; i < 2; i++){\n\t\t\tArrays.fill(d[i], Integer.MAX_VALUE);\n\t\t}\n\t\t\n\t\tArrayDeque<Point> q = new ArrayDeque<Point>();\n\t\tq.add(new Point(0, 0));\n\t\t\n\t\td[0][0] = 0;\n\t\tused[0][0] = true;\n\t\t\n\t\twhile (q.size() > 0){\n\t\t\tPoint p = q.poll();\n\t\t\tif (p.x >= n) return true;\n\t\t\t\n\t\t\tint i = p.y;\n\t\t\tint j = p.x;\n\t\t\t\n\t\t\tif (j > 0 && c[i][j-1] != 'X' && !used[i][j-1] && d[i][j] < j - 1){\n\t\t\t\tq.add(new Point(j - 1, i));\n\t\t\t\tused[i][j-1] = true;\n\t\t\t\td[i][j-1] = d[i][j] + 1;\n\t\t\t}\n\t\t\t\n\t\t\tif (j >= n - k) return true;\n\t\t\t\n\t\t\tif (c[i][j+1] != 'X' && !used[i][j+1]){\n\t\t\t\tq.add(new Point(j + 1, i));\n\t\t\t\tused[i][j+1] = true;\n\t\t\t\td[i][j+1] = d[i][j] + 1;\n\t\t\t}\n\t\t\t\n\t\t\ti = 1 - i;\n\t\t\tif (c[i][j+k] != 'X' && !used[i][j+k]){\n\t\t\t\tq.add(new Point(j + k, i));\n\t\t\t\tused[i][j+k] = true;\n\t\t\t\td[i][j+k] = d[1-i][j] + 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nint sol = 1 << 30;\nstring st[2];\nqueue<pair<int, int> > bfs;\nint dist[2][100100];\nint main() {\n  cin.sync_with_stdio(false);\n  cin >> n >> k;\n  cin >> st[0] >> st[1];\n  for (int i = 0; i < n; i++) {\n    dist[0][i] = dist[1][i] = 1 << 30;\n  }\n  dist[0][0] = 0;\n  bfs.push(make_pair(0, 0));\n  while (!bfs.empty()) {\n    pair<int, int> nd = bfs.front();\n    bfs.pop();\n    int di = dist[nd.first][nd.second];\n    if (nd.second > 0) {\n      if (di + 1 <= nd.second - 1) {\n        if (dist[nd.first][nd.second - 1] == 1 << 30) {\n          if (st[nd.first][nd.second - 1] == '-') {\n            dist[nd.first][nd.second - 1] = di + 1;\n            pair<int, int> ch = nd;\n            ch.second--;\n            bfs.push(ch);\n          }\n        }\n      }\n    }\n    if (nd.second == n - 1) {\n      sol = min(sol, di + 1);\n    } else {\n      if (dist[nd.first][nd.second + 1] == 1 << 30) {\n        if (st[nd.first][nd.second + 1] == '-') {\n          dist[nd.first][nd.second + 1] = di + 1;\n          pair<int, int> ch = nd;\n          ch.second++;\n          bfs.push(ch);\n        }\n      }\n    }\n    if (nd.second + k >= n) {\n      sol = min(sol, di + 1);\n    } else {\n      if (dist[1 - nd.first][nd.second + k] == 1 << 30) {\n        if (st[1 - nd.first][nd.second + k] == '-') {\n          dist[1 - nd.first][nd.second + k] = di + 1;\n          pair<int, int> ch = nd;\n          ch.first = 1 - ch.first;\n          ch.second += k;\n          bfs.push(ch);\n        }\n      }\n    }\n  }\n  if (sol == 1 << 30) {\n    cout << \"NO\" << endl;\n  } else {\n    cout << \"YES\" << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxN = 1e5 + 10;\nint n, k, dis[2][maxN];\nbool adj[2][maxN], mark[2][maxN];\nqueue<pair<int, int> > q;\nbool bfs(pair<int, int> st) {\n  dis[st.first][st.second] = 1;\n  q.push(st);\n  mark[st.first][st.second] = true;\n  while (!q.empty()) {\n    pair<int, int> cur = q.front();\n    q.pop();\n    int v = cur.first, u = cur.second;\n    if (dis[v][u] - 1 >= u) continue;\n    if (cur.second >= n || cur.second + k > n) return true;\n    if (adj[v][u + 1] && !mark[v][u + 1]) {\n      dis[v][u + 1] = dis[v][u] + 1;\n      q.push(make_pair(v, u + 1));\n      mark[v][u + 1] = true;\n    }\n    if (u - 1 >= 1 && adj[v][u - 1] && !mark[v][u - 1]) {\n      dis[v][u - 1] = dis[v][u] + 1;\n      q.push(make_pair(v, u - 1));\n      mark[v][u - 1] = true;\n    }\n    if (adj[1 - v][u + k] && !mark[1 - v][u + k]) {\n      dis[1 - v][u + k] = dis[v][u] + 1;\n      q.push(make_pair(1 - v, u + k));\n      mark[1 - v][u + k] = true;\n    }\n  }\n  return false;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> n >> k;\n  for (int i = 0; i < 2; i++)\n    for (int j = 1; j <= n; j++) {\n      char c;\n      cin >> c;\n      if (c == '-') adj[i][j] = 1;\n    }\n  if (bfs(make_pair(0, 1)))\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nchar l[100005], r[100005];\nbool vis_left[100005], vis_right[100005];\nbool bfs(int u, int cw, bool lf) {\n  queue<pair<int, pair<int, bool> > > q;\n  q.push(make_pair(u, make_pair(cw, lf)));\n  vis_left[1] = 1;\n  while (!q.empty()) {\n    int x = q.front().first;\n    int y = q.front().second.first;\n    bool f = q.front().second.second;\n    q.pop();\n    if (x + k > n || x + 1 > n) {\n      return 1;\n    }\n    if (f) {\n      if (!vis_right[x + 1] && r[x + 1] == '-' && x + 1 > y + 1) {\n        q.push(make_pair(x + 1, make_pair(y + 1, f))), vis_right[x + 1] = 1;\n      }\n      if (x > 1 && x - 1 > y + 1 && !vis_right[x - 1] && r[x - 1] == '-') {\n        q.push(make_pair(x - 1, make_pair(y + 1, f))), vis_right[x - 1] = 1;\n      }\n      if (x + k <= n && !vis_left[x + k] && l[x + k] == '-' && x + k > y + 1) {\n        q.push(make_pair(x + k, make_pair(y + 1, 0))), vis_left[x + k] = 1;\n      }\n    } else {\n      if (!vis_left[x + 1] && l[x + 1] == '-' && x + 1 > y + 1) {\n        q.push(make_pair(x + 1, make_pair(y + 1, f))), vis_left[x + 1] = 1;\n      }\n      if (x > 1 && x - 1 > y + 1 && !vis_left[x - 1] && l[x - 1] == '-') {\n        q.push(make_pair(x - 1, make_pair(y + 1, f))), vis_left[x - 1] = 1;\n      }\n      if (x + k <= n && !vis_right[x + k] && r[x + k] == '-' && x + k > y + 1) {\n        q.push(make_pair(x + k, make_pair(y + 1, 1))), vis_right[x + k] = 1;\n      }\n    }\n  }\n  return 0;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cin >> n >> k;\n  for (int i = 1; i <= n; ++i) {\n    cin >> l[i];\n  }\n  for (int i = 1; i <= n; ++i) {\n    cin >> r[i];\n  }\n  cout << (bfs(1, 0, 0) ? \"YES\" : \"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic class Main {\n\tstatic boolean[][] r;\n\tstatic int h,j;\n\tstatic boolean b=false;\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\th=sc.nextInt();\n\t\tj=sc.nextInt();\n\t\tr=new boolean[2][h];\n\t\tfor(int i=0;i<2;i++) { \t \t \t\n\t\t\tString s=sc.next();\n\t\t\tfor(int j=0;j<h;j++) {\n\t\t\t\tif(s.charAt(j)=='X')\n\t\t\t\t\tr[i][j]=false;\n\t\t\t\telse\n\t\t\t\t\tr[i][j]=true;\n\t\t\t}\n\t\t}\n\t\t//left=true;\n\t\tint water=-1;\n\t\tmove(water,0,0);\n\t\tif(b)\n\t\t\tSystem.out.println(\"YES\");\n\t\telse\n\t\t\tSystem.out.println(\"NO\");\n\t}\n\tpublic static void move(int water,int x,int y) {\n\t\tif(b)\n\t\t\treturn;\n\t\t\n\t\tif(y+j>h-1) {\n\t\t\tb=true;\n\t\t\treturn;\n\t\t}else {\n\t\t\tif(x==0) {\n\t\t\t\tif(r[1][y+j])\n\t\t\t\t\tmove(water+1,1,y+j);\n\t\t\t\telse\n\t\t\t\t\tr[x][y]=false;\n\t\t\t}else {\n\t\t\t\tif(r[0][y+j])\n\t\t\t\t\tmove(water+1,0,y+j);\n\t\t\t\telse\n\t\t\t\t\tr[x][y]=false;\n\t\t\t}\n\t\t}\n\t\tif(r[x][y+1])\n\t\t\tmove(water+1,x,y+1);\n\t\tif(y-1>=0 && r[x][y-1] && water+1<y-1 )\n\t\t\tmove(water+1,x,y-1);\n\t}\n}\n\n \t  \t\t\t\t \t \t  \t      \t\t   \t \t \t"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint shuiwei, n, k, flag;\nchar mp[2][1000005];\nint vis[2][1000005];\nint dfs(int shu, int heng) {\n  if (heng > n) return 1;\n  if (heng < shuiwei || vis[shu][heng] || mp[shu][heng] == 'X') return 0;\n  vis[shu][heng] = 1;\n  shuiwei++;\n  flag = dfs(shu, heng - 1) || dfs(1 - shu, heng + k) || dfs(shu, heng + 1);\n  shuiwei--;\n  return flag;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  while (cin >> n >> k) {\n    shuiwei = 1;\n    for (int i = 0; i < 2; i++)\n      for (int j = 1; j <= n; j++) {\n        cin >> mp[i][j];\n      }\n    if (dfs(0, 1))\n      cout << \"YES\" << '\\n';\n    else\n      cout << \"NO\" << '\\n';\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class Main {\n\n    private static ArrayList <ArrayList <Integer>> graph = new ArrayList <ArrayList <Integer>>();\n    private static HashSet <Integer> bili = new HashSet <Integer> ();\n    private static int n;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        int k = sc.nextInt();\n        String left = sc.next();\n        String right = sc.next();\n        \n        for (int i = 0; i < n; ++i) \n        {\n            ArrayList <Integer> temp = new ArrayList <Integer> ();            \n\n            if (left.charAt(i)!='X')\n            {\n\n                if (i+1==n)\n                    temp.add(Integer.MAX_VALUE);\n                else\n                    if (left.charAt(i+1)!='X')\n                        temp.add(i+1);\n                \n                if (i>0 && left.charAt(i-1)!='X')\n                    temp.add(i-1);\n                \n                if (i+k>=n)\n                    temp.add(Integer.MAX_VALUE);\n                else\n                    if (right.charAt(i+k)!='X')\n                        temp.add(n+i+k);\n                \n            }\n            \n            graph.add(temp);\n        }\n        \n        \n        for (int i = n; i < 2*n; ++i) \n        {\n            ArrayList <Integer> temp = new ArrayList <Integer> ();\n            if (right.charAt(i-n)!='X')\n            {\n                if (i-n+1==n)\n                    temp.add(Integer.MAX_VALUE);\n                else\n                    if (right.charAt(i-n+1)!='X')\n                        temp.add(i+1);\n                \n                if (i>n && right.charAt(i-n-1)!='X')\n                    temp.add(i-1);\n                \n                if (i-n+k>=n)\n                    temp.add(Integer.MAX_VALUE);\n                else\n                    if (left.charAt(i-n+k)!='X')\n                        temp.add(i-n+k);\n                \n                \n            }\n            graph.add(temp);\n        }    \n        \n        bfs();\n        System.out.println(\"NO\");\n    }\n\n    private static void bfs() {\n        Queue <Integer> q = new LinkedList <Integer> ();\n        Queue <Integer> level = new LinkedList <Integer> ();\n        q.add(0);\n        level.add(0);\n        while(!q.isEmpty()) \n        {\n            int temp = q.poll();\n            \n            if (!(level.peek() > temp || (temp-n>=0 && level.peek() > temp-n))) \n            {\n                if (temp == Integer.MAX_VALUE)\n                {\n                    System.out.println(\"YES\");\n                    System.exit(0);\n                }\n                for (int i = 0; i < graph.get(temp).size(); ++i)\n                {\n                    if (!bili.contains(graph.get(temp).get(i))) {\n                        q.add(graph.get(temp).get(i));\n                        bili.add(graph.get(temp).get(i));\n                        level.add(level.peek()+1);\n                    }\n                }\n            }\n            level.poll();\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstring s[2];\nint n, k;\nbool jumped[2][100020];\nvoid dfs(int lor, int p, int t) {\n  if (s[lor][p] == 'X' || p <= t || jumped[lor][p]) return;\n  if (p > n - k) {\n    printf(\"YES\");\n    exit(0);\n  }\n  jumped[lor][p] = 1;\n  dfs(lor, p - 1, t + 1);\n  dfs((lor + 1) % 2, p + k, t + 1);\n  dfs(lor, p + 1, t + 1);\n}\nint main() {\n  cin >> n >> k >> s[0] >> s[1];\n  n--;\n  dfs(0, 0, -1);\n  printf(\"NO\");\n}\n"
        },
        {
            "language": 3,
            "solution": "f = lambda: [q == '-' for q in input()]\nn, k = map(int, input().split())\nl, r = f(), f()\nu, v = [0], []\ndef yes(d):\n    if d > n - 1:\n        print('YES')\n        exit()\nfor i in range(n):\n    a, b = [], []\n    for d in u:\n        if l[d - 1] and d - 1 > i:\n            a.append(d - 1)\n            l[d - 1] = 0\n        yes(d + 1)\n        if l[d + 1]:\n            a.append(d + 1)\n            l[d + 1] = 0\n        yes(d + k)\n        if r[d + k]:\n            b.append(d + k)\n            r[d + k] = 0\n    for d in v:\n        if r[d - 1] and d - 1 > i:\n            b.append(d - 1)\n            r[d - 1] = 0\n        yes(d + 1)\n        if r[d + 1]:\n            b.append(d + 1)\n            r[d + 1] = 0\n        yes(d + k)\n        if l[d + k]:\n            a.append(d + k)\n            l[d + k] = 0\n    u, v = a, b\nprint('NO')"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int maxn = 210000;\nconst int maxnum = 1000000000;\nstruct Tdl {\n  int x, y, step;\n} dl[maxn + 1];\nbool done[3][maxn + 1];\nbool ky[3][maxn + 1];\nint n, K, head, tail;\nchar s[maxn + 1];\nbool tz(int i, int j, int step) {\n  if (j > n) return true;\n  if (j < 1) return false;\n  if (done[i][j]) return false;\n  if (step >= j) return false;\n  if (!ky[i][j]) return false;\n  done[i][j] = true;\n  dl[++tail].x = i;\n  dl[tail].y = j;\n  dl[tail].step = step;\n  return false;\n}\nint main() {\n  int i, j, step;\n  scanf(\"%d%d\", &n, &K);\n  for (i = 1; i <= 2; ++i) {\n    scanf(\"%s\", s);\n    for (j = 1; j <= n; ++j) {\n      if (s[j - 1] == '-')\n        ky[i][j] = true;\n      else\n        ky[i][j] = false;\n      done[i][j] = false;\n    }\n  }\n  head = 0;\n  tail = 1;\n  dl[1].x = 1;\n  dl[1].y = 1;\n  dl[1].step = 0;\n  done[1][1] = true;\n  bool success = false;\n  while (head < tail) {\n    ++head;\n    i = dl[head].x;\n    j = dl[head].y;\n    step = dl[head].step;\n    success = tz(i, j + 1, step + 1);\n    success = tz(i, j - 1, step + 1);\n    success = tz(3 - i, j + K, step + 1);\n    if (success) break;\n  }\n  if (success)\n    printf(\"YES\\n\");\n  else\n    printf(\"NO\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable {\n  int n, k, hd, tl, tar;\n  int[] q, level;\n  char[][] grid;\n  \n  public boolean BFS() {\n    int u, v;\n    \n    q = new int[3*n];\n    level = new int[3*n];\n    Arrays.fill(level, -1);\n    level[0] = 1;\n    tar = 2 * n;\n    hd = tl = 0;\n    q[tl++] = 0;\n    \n    while (hd < tl) {\n      u = q[hd++];\n\n      v = u - 2;\n      if (v >= level[u] * 2 && level[v] == -1 && grid[v&1][v/2] == '-') {\n        level[v] = level[u] + 1;\n        q[tl++] = v;\n      }\n      \n      v = u + 2;\n      if (v >= tar)\n        return true;\n      if (level[v] == -1 && grid[v&1][v/2] == '-') {\n        level[v] = level[u] + 1;\n        q[tl++] = v;\n      }\n      \n      v = (u ^ 1) + 2 * k;\n      if (v >= tar)\n        return true;\n      if (level[v] == -1 && grid[v&1][v/2] == '-') {\n        level[v] = level[u] + 1;\n        q[tl++] = v;\n      }\n    }\n    \n    return false;\n  }\n  \n  public void run() {\n    try {\n      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n      String[] ss = br.readLine().split(\" \");\n      n = Integer.parseInt(ss[0]);\n      k = Integer.parseInt(ss[1]);\n      grid = new char[2][];\n      grid[0] = br.readLine().toCharArray();\n      grid[1] = br.readLine().toCharArray();\n      \n      if (BFS())\n        System.out.println(\"YES\");\n      else\n        System.out.println(\"NO\");\n    }\n    catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n  \n  public static void main(String[] args) {\n    new Thread(new Main()).start();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N, K;\nchar A[3][100005];\nqueue<pair<int, int> > qu;\nint H[2][100005];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> N >> K;\n  for (int i = 1; i <= N; ++i) cin >> A[0][i];\n  for (int i = 1; i <= N; ++i) cin >> A[1][i];\n  A[0][0] = 'X';\n  A[1][0] = 'X';\n  memset(H, 1, sizeof(H));\n  H[0][1] = 0;\n  qu.push(pair<int, int>(0, 1));\n  while (qu.size()) {\n    int w = qu.front().first;\n    int i = qu.front().second;\n    qu.pop();\n    if (H[w][i] >= i) continue;\n    if (A[1 - w][i + K] != 'X')\n      if (H[1 - w][i + K] > H[w][i] + 1) {\n        H[1 - w][i + K] = H[w][i] + 1;\n        qu.push(pair<int, int>(1 - w, i + K));\n      }\n    if (A[w][i + 1] != 'X')\n      if (H[w][i + 1] > H[w][i] + 1) {\n        H[w][i + 1] = H[w][i] + 1;\n        qu.push(pair<int, int>(w, i + 1));\n      }\n    if (A[w][i - 1] != 'X')\n      if (H[w][i - 1] > H[w][i] + 1) {\n        H[w][i - 1] = H[w][i] + 1;\n        qu.push(pair<int, int>(w, i - 1));\n      }\n    if (i + 1 > N || i + K > N) {\n      cout << \"YES\";\n      exit(0);\n    }\n  }\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Jumps {\n\n\tfinal String filename = new String(\"Jumps\").toLowerCase();\n\n\tvoid solve() throws Exception {\n\t\tint n = nextInt();\n\t\tint k = nextInt();\n\t\tchar[] a = (nextToken() + nextToken()).toCharArray();\n\t\tQueue<Integer> q = new ArrayDeque<Integer>();\n\t\tint[] dist = new int[2 * n];\n\t\tArrays.fill(dist, Integer.MAX_VALUE);\n\t\tdist[0] = 0;\n\t\tq.add(0);\n\t\twhile (!q.isEmpty()) {\n\t\t\tint c = q.poll();\n\t\t\tint di = dist[c];\n\t\t\tif (di > c % n) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint pos = c % n;\n\t\t\tif (pos + k >= n) {\n\t\t\t\tout.println(\"YES\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (pos > 0 && a[c - 1] != 'X') {\n\t\t\t\tif (dist[c - 1] == Integer.MAX_VALUE) {\n\t\t\t\t\tdist[c - 1] = di + 1;\n\t\t\t\t\tq.add(c - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pos < n - 1 && a[c + 1] != 'X') {\n\t\t\t\tif (dist[c + 1] == Integer.MAX_VALUE) {\n\t\t\t\t\tdist[c + 1] = di + 1;\n\t\t\t\t\tq.add(c + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pos + k < n) {\n\t\t\t\tint to = (c + k + n) % (2 * n);\n\t\t\t\tif (a[to] != 'X' && dist[to] == Integer.MAX_VALUE) {\n\t\t\t\t\tdist[to] = di + 1;\n\t\t\t\t\tq.add(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(\"NO\");\n\t}\n\n\tvoid run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\t// in = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\t// out = new PrintWriter(\"output.txt\");\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tBufferedReader in;\n\tStringTokenizer st;\n\tPrintWriter out;\n\n\tString nextToken() throws Exception {\n\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt() throws Exception {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws Exception {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws Exception {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Jumps().run();\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint d[100005][2];\nqueue<int> q;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int n, i, j, k;\n  string s[2];\n  cin >> n >> k >> s[0] >> s[1];\n  for (i = 0; i < n; i++)\n    for (j = 0; j < 2; j++) d[i][j] = 1e9;\n  d[0][0] = 0;\n  q.push(0);\n  while (!q.empty()) {\n    i = q.front() / 2;\n    j = q.front() % 2;\n    q.pop();\n    if (d[i][j] > i) continue;\n    if (i > 0 && s[j][i - 1] == '-' && d[i - 1][j] > d[i][j] + 1) {\n      d[i - 1][j] = d[i][j] + 1;\n      q.push(i * 2 - 2 + j);\n    }\n    if (i < n - 1 && s[j][i + 1] == '-' && d[i + 1][j] > d[i][j] + 1) {\n      d[i + 1][j] = d[i][j] + 1;\n      q.push(i * 2 + 2 + j);\n    }\n    if (i < n - k && s[1 - j][i + k] == '-' && d[i + k][1 - j] > d[i][j] + 1) {\n      d[i + k][1 - j] = d[i][j] + 1;\n      q.push(i * 2 + k * 2 + 1 - j);\n    }\n  }\n  for (i = max(0, n - k); i < n; i++)\n    for (j = 0; j < 2; j++)\n      if (d[i][j] <= i) {\n        cout << \"YES\";\n        return 0;\n      }\n  cout << \"NO\";\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\n\n\npublic class Main {\n\n    class P{\n        int x;\n        int y;\n        P(int x,int y){\n            this.x=x;\n            this.y=y;\n        }\n\n        @Override\n        public boolean equals(Object o){\n            if(o instanceof P){\n                P p=(P)o;\n                return p.x==this.x && p.y==this.y;\n            }\n            return false;\n        }\n        @Override\n        public String toString() {\n            return \"(\"+x+\",\"+y+\")\";\n        }\n    }\n    int n, k;\n\n    Set<P> dp;\n\n    //\u4e00\u5ea6\u63a2\u7d22\u3057\u305f\u70b9\u306f\u635c\u7d22\u3057\u306a\u3044\u3002\n    int[][] map;\n\n    public boolean solve() {\n        Scanner sc=new Scanner(System.in);\n        n=sc.nextInt();\n        k=sc.nextInt();\n\n        map=new int[n][2];\n        dp=new HashSet<Main.P>();\n\n        for(int i=0;i<n;i++){\n            map[i]=new int[2];\n        }\n\n        String s=sc.next();\n        for(int i=0;i<n;i++) {\n            map[i][0] = (s.charAt(i) == '-')?-1:Integer.MAX_VALUE;\n        }\n        s=sc.next();\n        for(int i=0;i<n;i++) {\n            map[i][1] = s.charAt(i) == '-'?-1:Integer.MAX_VALUE;\n        }\n\n        int water = 0;\n        dp.add(new P(0, 0));\n        map[0][0]=0;\n        for (;!dp.isEmpty();) {\n            HashSet<P> tmp=new HashSet<Main.P>();\n            for(P p:dp) {\n                P a =new P(p.x+1,p.y);\n                if (a.x>= n) {\n                    return true;\n                }\n                if (map[a.x][a.y]==-1){\n                    tmp.add(a);\n                    map[a.x][a.y]=water+1;\n                }\n                a =new P(p.x-1,p.y);\n\n                if (a.x>= n) {\n                    return true;\n                }\n                if (water <a.x && map[a.x][a.y]==-1){\n                    tmp.add(a);\n                    map[a.x][a.y]=water+1;\n                }\n\n                a =new P(p.x+k,p.y);\n                a.y = a.y==0?1:0;\n\n                if (a.x >= n) {\n                    return true;\n                }\n                if (map[a.x][a.y]==-1){\n                    tmp.add(a);\n                    map[a.x][a.y]=water+1;\n                }\n            }\n            dp.clear();\n//          pr(water);\n//          for(P p:tmp){\n//              pr(p);\n//          }\n//          pr( );\n            dp.addAll(tmp);\n            tmp.clear();\n            water++;\n        }\n        return false;\n    }\n\n    public void run(){\n        pr(solve() ? \"YES\" : \"NO\");\n    }\n\n    public static void main(String[] _) {\n        new Main().run();\n    }\n    public static void pr (){\n        System.out.println();\n    }\n    public static void pr (Object o){\n        System.out.println(o);\n    }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, vis[2][100000], ans = 0;\nchar a[2][100000];\nvoid dfs(int i, int w, int t) {\n  if (i >= n) {\n    cout << \"c1 \" << i << \" \" << w << \" \" << t << \"\\n\";\n    ans = 1;\n    return;\n  }\n  if (t > i) {\n    cout << \"ct \" << i << \" \" << w << \" \" << t << \"\\n\";\n    return;\n  }\n  if (i < 0) {\n    cout << \"c2 \" << i << \" \" << w << \" \" << t << \"\\n\";\n    return;\n  }\n  if (a[w][i] == 'X') {\n    cout << \"c3 \" << i << \" \" << w << \" \" << t << \"\\n\";\n    return;\n  }\n  if (vis[w][i]) {\n    cout << \"c4 \" << i << \" \" << w << \" \" << t << \"\\n\";\n    return;\n  }\n  cout << \"c5 \" << i << \" \" << w << \" \" << t << \"\\n\";\n  vis[w][i] = 1;\n  dfs(i - 1, w, t + 1);\n  dfs(i + 1, w, t + 1);\n  dfs(i + k, 1 - w, t + 1);\n}\nstruct type {\n  int i;\n  int w;\n  int t;\n};\nbool bfs() {\n  queue<type> q;\n  type t;\n  t.i = 0;\n  t.w = 0;\n  t.t = 0;\n  q.push(t);\n  while (!q.empty()) {\n    t = q.front();\n    q.pop();\n    if (t.i >= n) {\n      ans = 1;\n      return true;\n    } else if (t.t > t.i)\n      continue;\n    else if (t.i < 0)\n      continue;\n    else if (a[t.w][t.i] == 'X')\n      continue;\n    else if (vis[t.w][t.i])\n      continue;\n    vis[t.w][t.i] = 1;\n    t.i--;\n    t.t++;\n    q.push(t);\n    t.i += 2;\n    q.push(t);\n    t.i += k - 1;\n    t.w = 1 - t.w;\n    q.push(t);\n  }\n  return false;\n}\nint main() {\n  int i;\n  cin >> n >> k;\n  cin >> a[0] >> a[1];\n  bfs();\n  if (ans)\n    cout << \"YES\";\n  else\n    cout << \"NO\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main(void) {\n  int n, k;\n  string wall[2];\n  int water = 0;\n  cin >> n >> k;\n  cin >> wall[0] >> wall[1];\n  queue<pair<int, int> > q;\n  q.push(make_pair(0, 0));\n  while (!q.empty()) {\n    queue<pair<int, int> > next;\n    do {\n      pair<int, int> pos = q.front();\n      q.pop();\n      if (pos.second + k >= n) {\n        cout << \"YES\" << endl;\n        return 0;\n      }\n      if (pos.second - 1 > water && wall[pos.first][pos.second - 1] != 'X') {\n        wall[pos.first][pos.second - 1] = 'X';\n        next.push(make_pair(pos.first, pos.second - 1));\n      }\n      if (wall[pos.first][pos.second + 1] != 'X') {\n        wall[pos.first][pos.second + 1] = 'X';\n        next.push(make_pair(pos.first, pos.second + 1));\n      }\n      if (wall[1 - pos.first][pos.second + k] != 'X') {\n        wall[1 - pos.first][pos.second + k] = 'X';\n        next.push(make_pair(1 - pos.first, pos.second + k));\n      }\n    } while (!q.empty());\n    ++water;\n    q = next;\n  }\n  cout << \"NO\" << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\n\n\npublic class Jump2 {\n\t\n\tstatic int n,k,cnt;\n\tstatic int[] visited1;\n\t\npublic static void main(String[] args) throws IOException {\n\t\t\n\t\tBufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(bf.readLine());\n\t\tn = Integer.parseInt(st.nextToken());\n\t\tk = Integer.parseInt(st.nextToken());\n\t\tchar[] identidad = (bf.readLine() + bf.readLine()).toCharArray();\n\t\tArrayList<ArrayList<Integer>> adyacentes =  new ArrayList<ArrayList<Integer>>();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tArrayList<Integer> vi = new ArrayList<Integer>();\n\t\t\tint abajo=i-1, arriba = i+1, salto = n+i+k;\n\t\t\tif (salto <2*n){\n\t\t\t\tvi.add(salto);\n\t\t\t}\n\t\t\tif (abajo >=0 && abajo<n){\n\t\t\t\tvi.add(abajo);\n\t\t\t}\n\t\t\tif (arriba<n){\n\t\t\t\tvi.add(arriba);\n\t\t\t}\n\t\t\tadyacentes.add(vi);\n\t\t}\n\t\tfor(int i=n;i<2*n;i++){\n\t\t\tArrayList<Integer> vi = new ArrayList<Integer>();\n\t\t\tint abajo=i-1, arriba = i+1, salto = i+k;\n\t\t\tif (salto <2*n){\n\t\t\t\tvi.add(salto%(n));\n\t\t\t}\n\t\t\tif (abajo >=n && abajo<2*n){\n\t\t\t\tvi.add(abajo);\n\t\t\t}\n\t\t\tif (arriba<2*n){\n\t\t\t\tvi.add(arriba);\n\t\t\t}\n\t\t\tadyacentes.add(vi);\n\t\t}\n\t\t//System.out.println(adyacentes);\n\tint[] visited = new int[2*n];\n\tcnt=-1;\n\tbfs(visited,identidad,adyacentes,0,cnt);\n\tSystem.out.println(\"NO\");\t\n}\n\tpublic static void bfs(int[] visited,char[] identidad, ArrayList<ArrayList<Integer>> adyacentes,int ubicacion,int nivel){\n\t\tdouble comp=ubicacion;\n\t\tif(comp/n==1.00000000000) comp=0;\n\t\tif(comp%n +k >= n){\n\t\t\tSystem.out.println(\"YES\");\n\t\t\tSystem.exit(0);\n\t\t}\n\t\tvisited[ubicacion]=1;\n\t\tfor(int adyacente : adyacentes.get(ubicacion)){\n\t\t\tint nivel1 = nivel;\n\t\t\tif(identidad[adyacente]=='-' && visited[adyacente]==0 && (adyacente%n)>nivel1+1){\n\t\t\t\tnivel1++;\n\t\t\t\t//System.out.println(\"ubicacion: \"+adyacente+\" \"+ \"nivel1: \"+nivel1+\" ----------\");\n\t\t\t\t//System.out.println(Arrays.toString(visited1));\t\t\t\t\n\t\t\t\tbfs(visited,identidad,adyacentes,adyacente,nivel1);\n\t\t\t}\n\t\t}\n\t}\n  \n}\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.awt.geom.*;\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\npublic class B {\n\n    public static final int INF = 1<<28;\n\n    public B() throws Exception {\n        String[] tokens = br.readLine().split(\" \");\n        int n = Integer.parseInt(tokens[0]);\n        int k = Integer.parseInt(tokens[1]);\n        String[] walls = new String[2];\n        walls[0] = br.readLine();\n        walls[1] = br.readLine();\n\n        boolean success = false;\n\n        Queue<Integer> queue = new LinkedList<Integer>();\n        queue.offer(0);\n        queue.offer(0);\n        boolean[][] visited = new boolean[2][n+k];\n        visited[0][0] = true;\n\n        int bfsDis = -1;\n        while (!queue.isEmpty()) {\n            bfsDis++;\n            for (int bfsCount=queue.size();bfsCount>0;bfsCount-=2) {\n                int h = queue.poll();\n                int d = queue.poll();\n\n                if (h>=n) {\n                    success = true;\n                    break;\n                }\n\n                if (h+1>=n||(walls[d].charAt(h+1)=='-'&&!visited[d][h+1])) {\n                    queue.offer(h+1);\n                    queue.offer(d);\n                    visited[d][h+1] = true;\n                }\n                if (h-1>=0&&(walls[d].charAt(h-1)=='-'&&!visited[d][h-1]&&bfsDis+1<=h-1)) {\n                    queue.offer(h-1);\n                    queue.offer(d);\n                    visited[d][h-1] = true;\n                }\n                if (h+k>=n||(walls[d^1].charAt(h+k)=='-'&&!visited[d^1][h+k])) {\n                    queue.offer(h+k);\n                    queue.offer(d^1);\n                    visited[d^1][h+k] = true;\n                }\n            }\n        }\n\n        System.out.println(success?\"YES\":\"NO\");\n    }\n\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    public static void main(String[] args) throws Exception { // {{{\n        new B();\n    } // }}}\n    public static void debug(Object... arr) { // {{{\n        System.err.println(Arrays.deepToString(arr));\n    } // }}}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nint n, k, dp[2][N * 2 + 5];\nstring s[2];\nset<pair<int, pair<int, int> > > q;\ninline void update(int wall_type, int cur_dp, int cur_pos) {\n  if (cur_pos <= cur_dp) {\n    return;\n  }\n  if (cur_pos <= n && s[wall_type][cur_pos - 1] == 'X') {\n    return;\n  }\n  if (cur_pos > n) {\n    cout << \"YES\";\n    exit(0);\n  }\n  if (dp[wall_type][cur_pos] > cur_dp) {\n    q.erase(make_pair(dp[wall_type][cur_pos], make_pair(wall_type, cur_pos)));\n    dp[wall_type][cur_pos] = cur_dp;\n    q.insert(make_pair(dp[wall_type][cur_pos], make_pair(wall_type, cur_pos)));\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k >> s[0] >> s[1];\n  for (int i = 0; i <= 100000; i++) {\n    dp[0][i] = dp[1][i] = 1e9;\n  }\n  dp[0][1] = 0;\n  q.insert(make_pair(0, make_pair(0, 1)));\n  while (!q.empty()) {\n    pair<int, pair<int, int> > v = *q.begin();\n    q.erase(q.begin());\n    if (v.second.second > n) {\n      return cout << \"YES\", 0;\n    }\n    update(v.second.first, dp[v.second.first][v.second.second] + 1,\n           v.second.second + 1);\n    update(v.second.first, dp[v.second.first][v.second.second] + 1,\n           v.second.second - 1);\n    update(v.second.first ^ 1, dp[v.second.first][v.second.second] + 1,\n           v.second.second + k);\n  }\n  cout << \"NO\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, k;\nint d[3][2 * 100005];\nint mark[3][2 * 100005];\nchar c;\nstruct node {\n  int x, y, d;\n} tmp, tmp2;\nqueue<node> q;\nint main() {\n  scanf(\"%d %d\", &n, &k);\n  for (int i = 1; i <= 2; i++)\n    for (int j = 1; j <= n; j++) {\n      scanf(\" %c\", &c);\n      if (c == '-') d[i][j] = 1;\n    }\n  for (int j = n + 1; j <= n + k; j++) {\n    d[1][j] = 1;\n    d[2][j] = 1;\n  }\n  tmp.x = 1;\n  tmp.y = 1;\n  tmp.d = 0;\n  q.push(tmp);\n  while (!q.empty()) {\n    tmp = q.front();\n    q.pop();\n    if (tmp.d >= tmp.y) continue;\n    if (tmp.y >= n) {\n      printf(\"YES\\n\");\n      return 0;\n    }\n    if (mark[tmp.x][tmp.y]) {\n      continue;\n    }\n    mark[tmp.x][tmp.y] = 1;\n    if (tmp.y - 2 > tmp.d && d[tmp.x][tmp.y - 1]) {\n      tmp2 = tmp;\n      tmp2.y -= 1;\n      tmp2.d += 1;\n      q.push(tmp2);\n    }\n    if (d[tmp.x][tmp.y + 1]) {\n      tmp2 = tmp;\n      tmp2.y += 1;\n      tmp2.d += 1;\n      q.push(tmp2);\n    }\n    if (d[3 - tmp.x][tmp.y + k]) {\n      tmp2 = tmp;\n      tmp2.x = 3 - tmp.x;\n      tmp2.y += k;\n      tmp2.d += 1;\n      q.push(tmp2);\n    }\n  }\n  printf(\"NO\\n\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nint water = 0, flag;\nint visited[2][1000005];\nstring wall[2];\nvoid bfs(int x, int y) {\n  flag = 0;\n  visited[x][y] = 1;\n  queue<pair<int, int> > q;\n  q.push(make_pair(x, y));\n  while (q.size() != 0) {\n    int z = q.size();\n    while (z--) {\n      int a = q.front().first;\n      int b = q.front().second;\n      q.pop();\n      if (b + k > n || b + 1 > n) {\n        flag = 1;\n        return;\n      }\n      if (wall[a][b + 1] != 'X' && visited[a][b + 1] != 1) {\n        visited[a][b + 1] = 1;\n        q.push(make_pair(a, b + 1));\n      }\n      if (b - 1 >= 0 && wall[a][b - 1] != 'X' && b - 1 > water &&\n          visited[a][b - 1] != 1) {\n        visited[a][b - 1] = 1;\n        q.push(make_pair(a, b - 1));\n      }\n      if (a == 0) {\n        if (wall[1][b + k] != 'X' && visited[1][b + k] != 1) {\n          visited[1][b + k] = 1;\n          q.push(make_pair(1, b + k));\n        }\n      }\n      if (a == 1) {\n        if (wall[0][b + k] != 'X' && visited[0][b + k] != 1) {\n          visited[0][b + k] = 1;\n          q.push(make_pair(0, b + k));\n        }\n      }\n    }\n    water++;\n  }\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j <= n; j++) {\n      visited[i][j] = 0;\n    }\n  }\n  cin >> wall[0];\n  cin >> wall[1];\n  bfs(0, 0);\n  if (flag == 1)\n    cout << \"YES\";\n  else\n    cout << \"NO\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, dx[3] = {-1, 1}, dy[] = {0, 0, 1};\nstring l, r;\nvector<vector<int> > dyn, gr;\ndeque<pair<int, int> > qu;\nbool ok(int x) { return (x > 0 && x <= n + k); }\nvoid bfs() {\n  dyn[1][0] = 0;\n  qu.push_back(make_pair(1, 0));\n  while (!qu.empty()) {\n    pair<int, int> cur = qu.front();\n    qu.pop_front();\n    for (int i = 0; i < 3; i++) {\n      pair<int, int> nex(cur.first + dx[i], (cur.second + dy[i]) % 2);\n      if (ok(nex.first) && gr[nex.first][nex.second] &&\n          dyn[nex.first][nex.second] == -1 &&\n          dyn[cur.first][cur.second] + 1 < nex.first) {\n        dyn[nex.first][nex.second] = dyn[cur.first][cur.second] + 1;\n        qu.push_back(nex);\n      }\n    }\n  }\n}\nint main() {\n  cin >> n >> k >> l >> r;\n  dx[2] = k;\n  dyn.resize(n + k + 1, vector<int>(2, -1));\n  gr.resize(n + k + 1, vector<int>(2, 1));\n  for (int i = 0; i < n; i++) {\n    gr[i + 1][0] = (l[i] == '-');\n    gr[i + 1][1] = (r[i] == '-');\n  }\n  bfs();\n  for (int i = n + 1; i < n + k + 1; i++) {\n    if (dyn[i][0] != -1 || dyn[i][1] != -1) {\n      cout << \"YES\" << endl;\n      return 0;\n    }\n  }\n  cout << \"NO\" << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Scanner;\n\n\npublic class Ninja {\n\tpublic static class ninjaNode{\n\t\tint side;//0 is left, 1 is right\n\t\tint index;\n\t\tint jumps;\n\t\tninjaNode next;\n\t\tninjaNode(){\n\t\t\t\n\t\t}\n\t\tninjaNode(int s, int i, int j)\n\t\t{\n\t\t\tside = s;\n\t\t\tindex = i;\n\t\t\tjumps = j;\n\t\t\tnext = null;\n\t\t}\n\t}\n\n\tpublic static class ninjaQ{\n\t\tninjaNode back = new ninjaNode();\n\t\tninjaQ()\n\t\t{\n\t\t\tback = null;\n\t\t}\n\t\tvoid enQueue(int s, int i, int j)\n\t\t{\n\t\t\tninjaNode node = new ninjaNode(s,i,j);\n\t\t\tif(back == null)\n\t\t\t{\n\t\t\t\tback = node;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.next = back;\n\t\t\t\tback = node;\n\t\t\t}\n\t\t}\n\t\tint[] deQueue()\n\t\t{\n\t\t\tint[] ret = new int[3];\n\t\t\tninjaNode temp = new ninjaNode();\n\t\t\tninjaNode prev = new ninjaNode();\n\t\t\tif(back == null)\n\t\t\t{\n\t\t\t\tSystem.out.println(\"Empty Queue\");\n\t\t\t\tret[0] = ret[1] = ret[2] = -1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprev= temp = back;\n\t\t\t\t//1 node\n\t\t\t\tif(back.next == null)\n\t\t\t\t{\n\t\t\t\t\tret[0] = back.side;\n\t\t\t\t\tret[1] = back.index;\n\t\t\t\t\tret[2] = back.jumps;\n\t\t\t\t\tback = null;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\t\t\t\t\n\t\t\t\t\twhile(temp.next !=null)\n\t\t\t\t\t{\n\t\t\t\t\t\tprev = temp;\n\t\t\t\t\t\ttemp = temp.next;\n\t\t\t\t\t}\n\t\t\t\t\tret[0] = temp.side;\n\t\t\t\t\tret[1] = temp.index;\n\t\t\t\t\tret[2] = temp.jumps;\n\t\t\t\t\tprev.next = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t\t\n\t\t}\n\t\tboolean isThere(int s, int i)\n\t\t{\n\t\t\tninjaNode temp = new ninjaNode();\n\t\t\tif(back == null)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttemp = back;\n\t\t\t\twhile(temp.next !=null)\n\t\t\t\t{\n\t\t\t\t\t//System.out.print(temp.side+\"[\"+temp.index+\"]\");\n\t\t\t\t\tif(temp.side == s && temp.index == i )\n\t\t\t\t\t\treturn true;\n\t\t\t\t\ttemp = temp.next;\n\t\t\t\t}\t\t\t\t\n\t\t\t\tif(temp.side == s && temp.index == i)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tboolean isEmpty()\n\t\t{\n\t\t\tif(back == null)\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t\tvoid print()\n\t\t{\n\t\t\tninjaNode temp = new ninjaNode();\n\t\t\tif(back == null)\n\t\t\t{\n\t\t\t\tSystem.out.println(\"Empty Queue\");\n\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttemp = back;\n\t\t\t\twhile(temp.next !=null)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.print(temp.side+\"[\"+temp.index+\"]\");\n\t\t\t\t\ttemp = temp.next;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.print(temp.side+\"[\"+temp.index+\"]\");\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String[] str)\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tint W = 0;\n\t\tchar[] L = new char[N];\n\t\tchar[] R = new char[N];\n\t\tString Left = sc.next();\n\t\tString Right = sc.next();\n\t\tfor(int i=0; i< N; i++)\n\t\t{\n\t\t\t//L[i] = sc.next().charAt(0); \n\t\t\tL[i] = Left.charAt(i);\n\t\t}\n\t\tfor(int i=0; i< N; i++)\n\t\t{\n\t\t\t//R[i] = sc.next().charAt(0); \n\t\t\tR[i] = Right.charAt(i);\n\t\t}\n\t\t\n\t\t\n\t\t/*for(int i=0; i< N; i++)\n\t\t{\n\t\t\tSystem.out.print(L[i]+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i=0; i< N; i++)\n\t\t{\n\t\t\tSystem.out.print(R[i]+\" \"); \n\t\t}\n\t\tSystem.out.println();*/\n\t\tboolean found = false;\n\t\tninjaQ Q = new ninjaQ();\n\t\tboolean[] VisitedL = new boolean[N];\n\t\tboolean[] VisitedR = new boolean[N];\n\t\tfor(int i=0; i< N; i++)\n\t\t{\n\t\t\tVisitedL[i] = false;\n\t\t\tVisitedR[i] = false;\n\t\t}\n\t\tninjaNode ninja = new ninjaNode();//track ninja's current location\n\t\tQ.enQueue(0, 0, -1);//left 0th location no jumps yet\n\t\tVisitedL[0] = true;\n\t\twhile(!Q.isEmpty())\n\t\t{\n\t\t\tint[] temp = Q.deQueue();\n\t\t\tninja.side = temp[0];\n\t\t\tninja.index = temp[1];\n\t\t\tninja.jumps = temp[2];\n\t\t\t//System.out.println(ninja.side+\"[\"+ninja.index+\"]\"+\"Water Level :\"+ninja.jumps);\n\t\t\tif(ninja.side == 0)//left\n\t\t\t{\n\t\t\t\tif(ninja.index - 1 >=0 && ninja.jumps+1 < ninja.index - 1 && L[ninja.index - 1] == '-')// move down possible\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tif(VisitedL[ninja.index - 1] == false)\n\t\t\t\t\t{\n\t\t\t\t\t\t//System.out.println(\"Enqueue : \"+\"L[\"+(ninja.index - 1)+\"]\"+\"Water Level :\"+(ninja.jumps+1));\n\t\t\t\t\t\tQ.enQueue(0, ninja.index - 1,ninja.jumps + 1);\n\t\t\t\t\t\tVisitedL[ninja.index - 1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ninja.index + 1 >= N)// move up possible\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(L[ninja.index + 1]  == '-')\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tif(VisitedL[ninja.index + 1] == false)\n\t\t\t\t\t{\n\t\t\t\t\t\t//System.out.println(\"Enqueue : \"+\"L[\"+(ninja.index + 1)+\"]\"+\"Water Level :\"+(ninja.jumps+1));\n\t\t\t\t\t\tQ.enQueue(0, ninja.index + 1 ,ninja.jumps + 1 );\n\t\t\t\t\t\tVisitedL[ninja.index + 1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tif(ninja.index + K >= N)//cross wall jump\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\t\tfound  = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(R[ninja.index + K]  == '-')\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tif(VisitedR[ninja.index + K] == false)\n\t\t\t\t\t{\n\t\t\t\t\t\t//System.out.println(\"Enqueue : \"+\"R[\"+(ninja.index + K)+\"]\"+\"Water Level :\"+(ninja.jumps+1));\n\t\t\t\t\t\tQ.enQueue(1, ninja.index + K ,ninja.jumps + 1);\n\t\t\t\t\t\tVisitedR[ninja.index + K] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t}\n\t\t\telse if(ninja.side == 1)//right\n\t\t\t{\n\t\t\t\t//System.out.println(\" ninja.index - 1 >=0 : \"+ (ninja.index - 1)+\"ninja.jumps + 1 < ninja.index - 1\"+(ninja.jumps + 1)+\"<\"+( ninja.index - 1)+\"R[ninja.index - 1] == '-'\"+R[ninja.index - 1]);\n\t\t\t\tif(ninja.index - 1 >=0 && ninja.jumps + 1 < ninja.index - 1 && R[ninja.index - 1] == '-')// move down possible\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tif(VisitedR[ninja.index - 1] == false)\n\t\t\t\t\t{\n\t\t\t\t\t\t//System.out.println(\"Enqueue : \"+\"R[\"+(ninja.index - 1)+\"]\"+\"Water Level :\"+(ninja.jumps+1));\n\t\t\t\t\t\tQ.enQueue(1, ninja.index - 1 ,ninja.jumps + 1);\n\t\t\t\t\t\tVisitedR[ninja.index - 1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ninja.index + 1 >= N)// move up possible\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(R[ninja.index + 1]  == '-')\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tif(VisitedR[ninja.index + 1] == false)\n\t\t\t\t\t{\n\t\t\t\t\t//\tSystem.out.println(\"Enqueue : \"+\"R[\"+(ninja.index + 1)+\"]\"+\"Water Level :\"+(ninja.jumps+1));\n\t\t\t\t\t\tQ.enQueue(1, ninja.index + 1 ,ninja.jumps + 1 );\n\t\t\t\t\t\tVisitedR[ninja.index + 1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tif(ninja.index + K >= N)//cross wall jump\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(L[ninja.index + K]  == '-')\n\t\t\t\t{\n\t\t\t\t\tif(VisitedL[ninja.index + K] == false)\n\t\t\t\t\t{\n\t\t\t\t\t\t//System.out.println(\"Enqueue : \"+\"L[\"+(ninja.index + K)+\"]\"+\"Water Level :\"+(ninja.jumps+1));\n\t\t\t\t\t\tQ.enQueue(0, ninja.index + K ,ninja.jumps + 1);\n\t\t\t\t\t\tVisitedL[ninja.index + K] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\t\n\t\t}\n\t\tif(found == false)\n\t\t{\n\t\t\tSystem.out.println(\"NO\");\n\t\t}\n\t}\n\t\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MaxN = 1e5 + 5;\nconst int inf = 1e8;\nconst double PI = acos(-1.0);\nconst long long mod = 100000007;\nint n, k;\nset<pair<int, int> > vis;\nstruct node {\n  int i, j, water;\n  void inti() {\n    i = 0;\n    j = 0;\n    water = -1;\n  }\n};\nqueue<node> que;\nnode op1(node x) {\n  node ss = x;\n  ss.j--;\n  return ss;\n}\nnode op2(node x) {\n  node ss = x;\n  ss.j++;\n  return ss;\n}\nnode op3(node x) {\n  node ss = x;\n  if (ss.i == 1)\n    ss.i = 0;\n  else\n    ss.i = 1;\n  ss.j += k;\n  return ss;\n}\nnode op4(node x) {\n  node ss = x;\n  if (ss.i == 1)\n    ss.i = 0;\n  else\n    ss.i = 1;\n  ss.j -= k;\n  return ss;\n}\nint main() {\n  bool flag = false;\n  string wall[2];\n  cin >> n >> k;\n  cin >> wall[0] >> wall[1];\n  n--;\n  node srt;\n  srt.inti();\n  vis.insert(make_pair(0, 0));\n  que.push(srt);\n  while (!que.empty() && !flag) {\n    node now = que.front();\n    que.pop();\n    node next1 = now;\n    node next;\n    next1.water = now.water + 1;\n    next = op1(next1);\n    if (!vis.count(make_pair(next.i, next.j)) && next.water < next.j) {\n      if (next.j > n) {\n        flag = true;\n        break;\n      }\n      if (next.j >= 0 && wall[next.i][next.j] == '-') {\n        que.push(next);\n        vis.insert(make_pair(next.i, next.j));\n      }\n    }\n    next = op2(next1);\n    if (!vis.count(make_pair(next.i, next.j)) && next.water < next.j) {\n      if (next.j > n) {\n        flag = true;\n        break;\n      }\n      if (next.j >= 0 && wall[next.i][next.j] == '-') {\n        que.push(next);\n        vis.insert(make_pair(next.i, next.j));\n      }\n    }\n    next = op3(next1);\n    if (!vis.count(make_pair(next.i, next.j)) && next.water < next.j) {\n      if (next.j > n) {\n        flag = true;\n        break;\n      }\n      if (next.j >= 0 && wall[next.i][next.j] == '-') {\n        que.push(next);\n        vis.insert(make_pair(next.i, next.j));\n      }\n    }\n    next = op4(next1);\n    if (!vis.count(make_pair(next.i, next.j)) && next.water < next.j) {\n      if (next.j > n) {\n        flag = true;\n        break;\n      }\n      if (next.j >= 0 && wall[next.i][next.j] == '-') {\n        que.push(next);\n        vis.insert(make_pair(next.i, next.j));\n      }\n    }\n  }\n  if (flag)\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "from collections import deque\nimport sys\nn,k=map(int,raw_input().split())\nwall=[]\nwall.append(raw_input())\nwall.append(raw_input())\nvis = [[0] * n, [0] * n]\nd = deque()\nd.append((0,0,0))\nwhile d:\n    side,p,w = d.popleft()\n    if p >= n: print \"YES\"; sys.exit()\n    if wall[side][p] == 'X' or vis[side][p] or p < w: continue\n    vis[side][p] = 1\n    if p: d.append((side, p-1, w+1))\n    d.append((side, p+1, w+1))\n    d.append((1-side, p+k, w+1))\nprint \"NO\"\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100008;\nint n, k;\nchar A[maxn][2];\nqueue<int> loc, lev, stp;\nbool bk[maxn][2];\nint main() {\n  cin >> n >> k;\n  int i, h, l, s;\n  getchar();\n  for (i = 1; i <= n; i++) {\n    A[i][0] = getchar();\n  }\n  getchar();\n  for (i = 1; i <= n; i++) {\n    A[i][1] = getchar();\n  }\n  if (A[1][0] == '-') {\n    loc.push(0);\n    lev.push(1);\n    stp.push(0);\n    bk[1][0] = 1;\n  }\n  while (!lev.empty()) {\n    l = loc.front();\n    loc.pop();\n    h = lev.front();\n    lev.pop();\n    s = stp.front();\n    stp.pop();\n    if (h + 1 > n || h + k > n) {\n      puts(\"YES\");\n      return 0;\n    }\n    if (bk[h + 1][l] == 0 && A[h + 1][l] == '-') {\n      bk[h + 1][l] = 1;\n      loc.push(l);\n      lev.push(h + 1);\n      stp.push(s + 1);\n    }\n    if (bk[h + k][!l] == 0 && A[h + k][!l] == '-') {\n      bk[h + k][!l] = 1;\n      loc.push(!l);\n      lev.push(h + k);\n      stp.push(s + 1);\n    }\n    if (h - 1 > s + 1 && bk[h - 1][l] == 0 && A[h - 1][l] == '-') {\n      bk[h - 1][l] = 1;\n      loc.push(l);\n      lev.push(h - 1);\n      stp.push(s + 1);\n    }\n  }\n  puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "\nleft, right = (0, 1)\nundiscovered = 0\nprocessed = 1\n\ndef up(state):\n    water = state[0] + 1\n    point = state[1] + 1\n    l_or_r = state[2]\n    return [water, point, l_or_r]\n\ndef down(state):\n    water = state[0] + 1\n    point = state[1] - 1\n    l_or_r = state[2]\n    return [water, point, l_or_r]\n\ndef jump(state, k):\n    water = state[0] + 1\n    point = state[1] + k\n    if state[2] == left: l_or_r = right\n    else:                l_or_r = left\n    \n    return [water, point, l_or_r]\n\ndef push_next_states(state, k, states):\n    states[len(states):] = [up(state), down(state), jump(state, k)]\n    return states\n    \ndef solve(n, k, lwall, rwall):\n    water = -1\n    point = 0\n    l_or_r = left\n    state = [water, point, l_or_r]\n    table = [[undiscovered]*n, [undiscovered]*n]\n    states = push_next_states(state, k, [])\n    \n    while states != []:\n        state = states.pop()\n        if state is None: break\n        \n        water = state[0]\n        point = state[1]\n        \n        if n <= point: return True\n\n        if water < point:\n            l_or_r = state[2]\n            if table[l_or_r][point] != processed:\n                if l_or_r == left: wall = lwall\n                else:              wall = rwall\n                \n                if wall[point] == '-':\n                    if n <= point+k: return True\n                    push_next_states(state, k, states)\n                table[l_or_r][point] = processed\n    return False\n\ndef main():\n    import sys\n    n, k = [int(x) for x in sys.stdin.readline().split()]\n    lwall = sys.stdin.readline().rstrip()\n    rwall = sys.stdin.readline().rstrip()\n\n    result = solve(n, k, lwall, rwall)\n    if result: print(\"YES\", end=\"\")\n    else:      print(\"NO\", end=\"\")\n    \nmain()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstring s[2];\nint n, k;\nint dis[2][100105 + 5];\nint go(int sx, int sy) {\n  queue<pair<int, int> > Q;\n  Q.push(pair<int, int>(sx, sy));\n  int i;\n  for (i = 0; i <= n; i++) dis[0][i] = dis[1][i] = 500105;\n  dis[sx][sy] = 0;\n  while (!Q.empty()) {\n    int x = Q.front().first;\n    int y = Q.front().second;\n    Q.pop();\n    if (y >= n - 1) return 1;\n    if (dis[x][y] + 1 <= y + 1 && s[x][y + 1] != 'X' &&\n        dis[x][y + 1] > dis[x][y] + 1) {\n      dis[x][y + 1] = dis[x][y] + 1;\n      Q.push(pair<int, int>(x, y + 1));\n    }\n    if (dis[x][y] + 1 <= y - 1 && y - 1 != -1 && s[x][y - 1] != 'X' &&\n        dis[x][y - 1] > dis[x][y] + 1) {\n      dis[x][y - 1] = dis[x][y] + 1;\n      Q.push(pair<int, int>(x, y - 1));\n    }\n    if (y + k > n - 1) return 1;\n    if (dis[x][y] + 1 <= y + k && s[!x][y + k] != 'X' &&\n        dis[!x][y + k] > dis[x][y] + 1) {\n      dis[!x][y + k] = dis[x][y] + 1;\n      Q.push(pair<int, int>(!x, y + k));\n    }\n  }\n  return 0;\n}\nint main() {\n  int i, j;\n  while (cin >> n >> k) {\n    for (i = 0; i <= 1; i++) cin >> s[i];\n    if (go(0, 0))\n      cout << \"YES\\n\";\n    else\n      cout << \"NO\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "from sys import stdin\n\ndef bfs_ish(left, right, n, k):\n  current = []\n  next = []\n  visited = set()\n\n  water = 0\n  currPos = 0\n  current.append(('left', currPos))\n  \n  while (len(current) != 0):\n    for tup in current:\n      side = tup[0]\n      currPos = tup[1]\n      if (water >= n):\n        return False;\n      elif (currPos >= n):\n        return True;\n      else:\n        #check if can just go to top\n        if ((currPos+1 >= n) or (currPos+k >= n)):\n          return True\n        #find neighbors\n        if (side == 'left'):\n          if ((('left', currPos+1) not in visited) and (left[currPos + 1] != 'X')):\n            visited.add(('left', currPos+1))\n            next.append(('left', currPos+1))\n          if ((('left', currPos-1) not in visited) and (left[currPos - 1] != 'X') and (currPos-1 > water)):\n            visited.add(('left', currPos-1))\n            next.append(('left', currPos-1))\n          if ((('right', currPos+k) not in visited) and (right[currPos+k] != 'X')):\n            visited.add(('right', currPos+k))\n            next.append(('right', currPos+k))\n        else:\n          if ((('right', currPos+1) not in visited) and (right[currPos + 1] != 'X')):\n            visited.add(('right', currPos+1))\n            next.append(('right', currPos+1))\n          if ((('right', currPos-1) not in visited) and (right[currPos-1] != 'X') and (currPos-1 > water)):\n            visited.add(('right', currPos-1))\n            next.append(('right', currPos-1))\n          if ((('left', currPos+k) not in visited) and (left[currPos+k] != 'X')):\n            visited.add(('left', currPos+k))\n            next.append(('left', currPos+k))\n    current = next\n    next = []\n    water += 1\n  return False    \n\ndef main():\n  info = stdin.readline().rstrip().split(' ')\n  n = int(info[0])\n  k = int(info[1])\n\n  left = stdin.readline().rstrip()\n  right = stdin.readline().rstrip()\n\n  if (bfs_ish(left, right, n, k)):\n    print 'YES'\n  else:\n    print 'NO'\n  return\n\nmain()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct keycompare {\n  bool operator()(const pair<long long, long long>& v, const long long& k) {\n    return (v.first < k);\n  }\n  bool operator()(const long long& k, const pair<long long, long long>& v) {\n    return (k < v.first);\n  }\n};\nlong long mod1 = 998244353, mod2 = 1000000007, limit = 9223372036854775807;\nlong double pi = 3.1415926535897932;\nlong long modpow(long long x, long long n, long long m) {\n  if (x > m) {\n    x %= m;\n  }\n  if (n == 0) return 1 % m;\n  long long u = modpow(x, n / 2, m);\n  u = (u * u) % m;\n  if (n % 2 == 1) u = (u * x) % m;\n  return u;\n}\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nbool isprime(long long n) {\n  if (n == 2) return true;\n  for (long long i = 2; i * i <= n; i++) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}\nlong long power(long long x, long long n) {\n  if (n < 0) {\n    return 0;\n  }\n  long long x_n = 1;\n  for (long long i = 0; i < n; i++) {\n    x_n *= x;\n  }\n  return x_n;\n}\nint dist[200005][2];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  for (int i = 0; i < 200005; i++) {\n    dist[i][0] = 100000000;\n    dist[i][1] = 100000000;\n  }\n  int n, k;\n  cin >> n >> k;\n  string l, r;\n  cin >> l >> r;\n  queue<pair<int, pair<int, int>>> q;\n  q.push({0, {0, 0}});\n  dist[0][0] = 0;\n  while (!q.empty()) {\n    int d = q.front().first, h = q.front().second.first,\n        col = q.front().second.second;\n    q.pop();\n    if (d <= h && ((col == 0 && l[h] == '-') || (col == 1 && r[h] == '-'))) {\n      if (h + k >= n) {\n        cout << \"YES\";\n        return 0;\n      } else {\n        if (dist[h + 1][col] > d + 1) {\n          dist[h + 1][col] = d + 1;\n          q.push({d + 1, {h + 1, col}});\n        }\n        if (h - 1 >= 0 && dist[h - 1][col] > d + 1) {\n          dist[h - 1][col] = d + 1;\n          q.push({d + 1, {h - 1, col}});\n        }\n        if (dist[h + k][!col] > d + 1) {\n          dist[h + k][!col] = d + 1;\n          q.push({d + 1, {h + k, !col}});\n        }\n      }\n    }\n  }\n  cout << \"NO\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstring s[2];\nint n, k;\nbool jumped[2][100020];\nvoid dfs(int lor, int p, int t) {\n  if (s[lor][p] == 'X' || p <= t || jumped[lor][p]) return;\n  if (p > n - k) {\n    printf(\"YES\");\n    exit(0);\n  }\n  jumped[lor][p] = 1;\n  dfs((lor + 1) % 2, p + k, t + 1);\n  dfs(lor, p + 1, t + 1);\n  dfs(lor, p - 1, t + 1);\n}\nint main() {\n  cin >> n >> k >> s[0] >> s[1];\n  n--;\n  dfs(0, 0, -1);\n  printf(\"NO\");\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.LinkedList;\nimport java.util.StringTokenizer;\n\npublic class Ninja {\n    public static void main(String[] args) throws Exception {\n        BufferedReader reader = new BufferedReader(\n                new InputStreamReader(System.in));\n        StringTokenizer tk = new StringTokenizer(reader.readLine());\n        int n = Integer.parseInt(tk.nextToken());\n        int k = Integer.parseInt(tk.nextToken());\n\n        char[][] wall = new char[2][n];\n        wall[0] = reader.readLine().toCharArray();\n        wall[1] = reader.readLine().toCharArray();\n\n        System.out.println(bfs(wall, k) ? \"YES\" : \"NO\");\n    }\n\n    private static boolean bfs(char[][] wall, int k) {\n        boolean[][] visited = new boolean[wall.length][wall[0].length];\n        LinkedList<Node> queue = new LinkedList<>();\n        queue.add(new Node(0, 0, -1));\n        Node current;\n        visited[0][0] = true;\n\n        while (!queue.isEmpty()) {\n            current = queue.poll();\n            if (current.y + 1 >= wall[0].length\n                    || current.y + k >= wall[0].length) {\n                return true;\n            }\n            if (wall[current.x][current.y + 1] == '-'\n                    && !visited[current.x][current.y + 1]\n                    && current.water + 1 < current.y + 1) {\n                queue.add(new Node(current.x, current.y + 1,\n                        current.water + 1));\n                visited[current.x][current.y + 1] = true;\n            }\n            if (wall[1 - current.x][current.y + k] == '-'\n                    && !visited[1 - current.x][current.y + k]\n                    && current.water + 1 < current.y + k) {\n                queue.add(new Node(1 - current.x, current.y + k,\n                        current.water + 1));\n                visited[1 - current.x][current.y + k] = true;\n            }\n            if (current.y - 1 >= 0\n                    && wall[current.x][current.y - 1] == '-'\n                    && !visited[current.x][current.y - 1]\n                    && current.water + 1 < current.y - 1) {\n                queue.add(new Node(current.x, current.y - 1,\n                        current.water + 1));\n                visited[current.x][current.y - 1] = true;\n            }\n        }\n        return false;\n    }\n\n    public static class Node {\n        private int x, y, water;\n        public Node(int x, int y, int water) {\n            this.x = x;\n            this.y = y;\n            this.water = water;\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/stack:64000000\")\nusing namespace std;\ntemplate <typename X>\ninline X abs(const X& a) {\n  return a < 0 ? -a : a;\n}\ntemplate <typename X>\ninline X sqr(const X& a) {\n  return a * a;\n}\nconst int INF = INT_MAX / 2;\nconst long double EPS = 1e-9;\nconst long double PI = 3.1415926535897932384626433832795;\nconst int N = 200 * 1000 + 3;\nint d[2][N];\nint n, k;\nstring s[2];\ninline bool read() {\n  assert(cin >> n >> k);\n  assert(cin >> s[0] >> s[1]);\n  return true;\n}\nint used[2][N];\ninline void solve() {\n  set<pair<int, pair<int, int> > > heap;\n  memset(d, 63, sizeof(d));\n  memset(used, false, sizeof(used));\n  d[0][0] = 0;\n  heap.insert(make_pair((d[0][0]), (make_pair((0), (0)))));\n  bool ans = false;\n  while (true) {\n    while (!heap.empty()) {\n      pair<int, int> v = (*heap.begin()).second;\n      if (used[v.first][v.second]) {\n        heap.erase(heap.begin());\n        continue;\n      } else\n        break;\n    }\n    if (heap.empty()) break;\n    pair<int, int> v = (*heap.begin()).second;\n    used[v.first][v.second] = true;\n    int dv = (*heap.begin()).first;\n    heap.erase(heap.begin());\n    if (v.second >= n) {\n      ans = true;\n      break;\n    }\n    {\n      pair<int, int> nv = v;\n      nv.second++;\n      if ((nv.second >= n ||\n           (nv.second >= dv + 1 && s[nv.first][nv.second] == '-')) &&\n          (d[nv.first][nv.second] > dv + 1)) {\n        heap.erase(make_pair((d[nv.first][nv.second]), (nv)));\n        d[nv.first][nv.second] = dv + 1;\n        heap.insert(make_pair((d[nv.first][nv.second]), (nv)));\n      }\n    }\n    {\n      pair<int, int> nv = v;\n      nv.second--;\n      if ((nv.second >= 0 &&\n           (nv.second >= dv + 1 && s[nv.first][nv.second] == '-')) &&\n          (d[nv.first][nv.second] > dv + 1)) {\n        heap.erase(make_pair((d[nv.first][nv.second]), (nv)));\n        d[nv.first][nv.second] = dv + 1;\n        heap.insert(make_pair((d[nv.first][nv.second]), (nv)));\n      }\n    }\n    {\n      pair<int, int> nv = v;\n      nv.first ^= 1;\n      nv.second += k;\n      if ((nv.second >= n ||\n           (nv.second >= dv + 1 && s[nv.first][nv.second] == '-')) &&\n          (d[nv.first][nv.second] > dv + 1)) {\n        heap.erase(make_pair((d[nv.first][nv.second]), (nv)));\n        d[nv.first][nv.second] = dv + 1;\n        heap.insert(make_pair((d[nv.first][nv.second]), (nv)));\n      }\n    }\n  }\n  puts(ans ? \"YES\" : \"NO\");\n}\nint main() {\n  assert(read());\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\npublic class JumpingOnWalls {\n\t\n\tstatic Scanner in = new Scanner(System.in);\n\tpublic static void main(String[] args){\n\t\tnew JumpingOnWalls().DFS();\n\t}\n\tprivate void DFS(){\n\t\tint n = in.nextInt();\n\t\tint k = in.nextInt();\n\t\tchar[] left = new char[n];\n\t\tchar[] right = new char[n];\n\t\tleft = in.next().toCharArray();\n\t\tright = in.next().toCharArray();\n\t\tchar[][] wall = new char[2][n];\n\t\twall[0] = left;\n\t\twall[1] = right;\n\t\tint[][] visited = new int[2][n];\n\t\tfor(int i=0;i<2;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tvisited[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tQueue<Position> q = new LinkedList<JumpingOnWalls.Position>();\n\t\tq.add(new Position(0, 0, 0));\n\t\t\n\n\t\twhile(!q.isEmpty()){\n\t\t\tPosition p = q.poll();\n\t\t\tint s = p.side;\n\t\t\tint po = p.pos;\n\t\t\tint b = p.bottom;\n\t\t\tif(po >= n){\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(wall[s][po]=='X' || visited[s][po]==1 || po<b){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvisited[s][po] = 1;\n\t\t\n\t\t\tif(po>0){ \n\t\t\t\tq.add(new Position(s, po-1, b+1));\n\t\t\t}\n\t\t\tq.add(new Position(s, po+1, b+1));\n\t\t\tq.add(new Position(1-s, po+k, b+1));\n\t\t}\n\t\tSystem.out.println(\"NO\");\n\t}\n\t\n\tclass Position{\n\t\tint side;\n\t\tint pos;\n\t\tint bottom;\n\t\tpublic Position(int side, int pos, int bottom){\n\t\t\tthis.side = side;\n\t\t\tthis.pos = pos;\n\t\t\tthis.bottom = bottom;\n\t\t}\n\t}\n\t\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, jump;\nbool success;\nstring left_wall = \"\";\nstring right_wall = \"\";\nbool vis_left[100100];\nbool vis_right[100100];\nvoid rec(int height, bool wall, int water_height) {\n  if (height > n) {\n    success = true;\n    return;\n  }\n  if (height == 0) return;\n  if (wall) {\n    if (left_wall[height] == 'X' || vis_left[height]) return;\n    vis_left[height] = true;\n  } else {\n    if (right_wall[height] == 'X' || vis_right[height]) return;\n    vis_right[height] = true;\n  }\n  if (height <= water_height && height != 0) return;\n  rec(height + jump, !wall, water_height + 1);\n  rec(height - 1, wall, water_height + 1);\n  rec(height + 1, wall, water_height + 1);\n}\nint main() {\n  cin >> n >> jump;\n  cin >> left_wall >> right_wall;\n  left_wall.insert(0, \" \");\n  right_wall.insert(0, \" \");\n  rec(1, true, 0);\n  if (success)\n    cout << \"YES\";\n  else\n    cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.Collection;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedReader;\nimport java.util.Queue;\nimport java.util.ArrayDeque;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author MaxHeap\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        JumpingOnWalls solver = new JumpingOnWalls();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class JumpingOnWalls {\n        int n;\n        int k;\n        char[][] grid;\n\n        public void solve(int testNumber, FastReader in, OutputWriter out) {\n            n = in.nextInt();\n            k = in.nextInt();\n            grid = new char[2][];\n\n            for (int i = 0; i < 2; i++) {\n                grid[i] = in.next().toCharArray();\n            }\n            boolean[][] visited = new boolean[2][n + 1];\n            boolean gotOut = bfs(visited);\n            out.println(gotOut ? \"YES\" : \"NO\");\n        }\n\n        boolean bfs(boolean[][] visited) {\n            Queue<Pair<Pair<Integer, Integer>, Integer>> q = new ArrayDeque<>();\n            q.add(new Pair<>(new Pair<Integer, Integer>(0, 0), -1));\n            visited[0][0] = true;\n            while (!q.isEmpty()) {\n                Pair<Pair<Integer, Integer>, Integer> cur = q.poll();\n                int x = cur.getFirst().getFirst();\n                int y = cur.getFirst().getSecond();\n                int water = cur.getSecond();\n                if (y <= water) continue;\n                if (y + k >= n || y + 1 >= n) {\n                    return true;\n                }\n                if (grid[1 - x][y + k] != 'X' && !visited[1 - x][y + k]) {\n                    visited[1 - x][y + k] = true;\n                    q.add(new Pair<>(new Pair<Integer, Integer>(1 - x, y + k), water + 1));\n                }\n                if (y - 1 >= 0 && !visited[x][y - 1] && grid[x][y - 1] == '-') {\n                    visited[x][y - 1] = true;\n                    q.add(new Pair<>(new Pair<Integer, Integer>(x, y - 1), water + 1));\n\n                }\n                if (!visited[x][y + 1] && grid[x][y + 1] == '-') {\n                    visited[x][y + 1] = true;\n                    q.add(new Pair<>(new Pair<Integer, Integer>(x, y + 1), water + 1));\n\n                }\n            }\n            return false;\n        }\n\n    }\n\n    static class FastReader {\n        BufferedReader bf;\n        StringTokenizer st;\n\n        public FastReader(InputStream is) {\n            bf = new BufferedReader(new InputStreamReader(is));\n            st = null;\n        }\n\n        public String next() {\n            try {\n                while (st == null || !st.hasMoreTokens()) {\n                    String line = bf.readLine();\n                    if (line == null) return null;\n                    st = new StringTokenizer(line);\n                }\n            } catch (Exception e) {\n            }\n\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n\n    static class Pair<E, V> implements Comparable<Pair<E, V>> {\n        private E first;\n        private V second;\n\n        public Pair() {\n        }\n\n        public Pair(E first, V v) {\n            this.first = first;\n            this.second = v;\n        }\n\n        public E getFirst() {\n            return first;\n        }\n\n        public V getSecond() {\n            return second;\n        }\n\n\n        public int compareTo(Pair<E, V> o) {\n            Comparable<E> ce = (Comparable<E>) first;\n            Comparable<V> cv = (Comparable<V>) second;\n            if (cv.compareTo(o.getSecond()) == 0) {\n                return ce.compareTo(o.getFirst());\n            }\n            return cv.compareTo(o.getSecond());\n        }\n\n\n        public String toString() {\n            return \"<\" + first + \", \" + second + \">\";\n        }\n\n\n        public boolean equals(Object o) {\n            Pair<E, V> p = (Pair<E, V>) o;\n            return first.equals(p.getFirst()) && second.equals(p.getSecond());\n        }\n\n\n        public int hashCode() {\n            int result = first.hashCode();\n            result = 31 * result + second.hashCode();\n            return result;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void println(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class JumpingOnWalls199D {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt(), k = in.nextInt();\n\t\tin.nextLine();\n\t\tboolean[][] walls = new boolean[2][n];\n\t\tboolean[][] checked = new boolean[2][n];\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tString wall = in.nextLine();\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tif (wall.charAt(j) == '-')\n\t\t\t\t\twalls[i][j] = true;\n\t\t\t\telse\n\t\t\t\t\twalls[i][j] = false;\n\t\t}\n\t\tQueue<Position> q = new LinkedList<Position>();\n\t\tq.add(new Position(0, 0, 0));\n\t\twhile (!q.isEmpty()) {\n\t\t\tPosition p = q.poll();\n\t\t\tif (checked[p.wall][p.height])\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tchecked[p.wall][p.height] = true;\n\t\t\tint a1w, a1h, a2w, a2h, a3w, a3h;\n\t\t\tint wh = p.time;\n\t\t\ta1w = a2w = p.wall;\n\t\t\ta1h = p.height + 1;\n\t\t\ta2h = p.height - 1;\n\t\t\ta3w = p.wall == 0 ? 1 : 0;\n\t\t\ta3h = p.height + k;\n\t\t\tif (p.height >= n || a1h >= n || a2h >= n || a3h >= n) {\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (walls[a1w][a1h])\n\t\t\t\tq.add(new Position(a1w, a1h, wh + 1));\n\t\t\tif (a2h > p.time && walls[a2w][a2h])\n\t\t\t\tq.add(new Position(a2w, a2h, wh + 1));\n\t\t\tif (walls[a3w][a3h])\n\t\t\t\tq.add(new Position(a3w, a3h, wh + 1));\n\t\t}\n\t\tSystem.out.println(\"NO\");\n\t}\n\n\tstatic class Position {\n\t\tint wall, height, time;\n\n\t\tPosition(int w, int h, int t) {\n\t\t\twall = w;\n\t\t\theight = h;\n\t\t\ttime = t;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"[%d]%d:%d\", time, wall, height);\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import static java.util.Arrays.*;\nimport static java.lang.Math.*;\nimport static java.math.BigInteger.*;\nimport java.util.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class B implements Runnable\n{\n\tString file = \"input\";\n\t\n\tboolean TEST = System.getProperty(\"ONLINE_JUDGE\") == null;\n\t\n\tvoid solve() throws IOException\n\t{\n\t\tn = nextInt();\n\t\tk = nextInt();\n\t\tas = new char[2][];\n\t\tas[0] = next().toCharArray();\n\t\tas[1] = next().toCharArray();\n\t\t\n\t\tcs = new char[n][2];\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tcs[i][0] = as[0][i];\n\t\t\tcs[i][1] = as[1][i];\n\t\t}\n\t\tif(BFS(0)) out.println(\"YES\");\n\t\telse out.println(\"NO\");\n\t}\n\tint n, k;\n\tchar[][] as, cs;\n\tint INF = 1 << 20;\n\tboolean BFS(int sx)\n\t{\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\tint[][] dist = new int[n][2];\n\t\tfor(int[] t : dist) fill(t, INF);\n\t\tdist[0][0] = 0;\n\t\tq.offer(0);\n\t\t\n\t\twhile(!q.isEmpty())\n\t\t{\n\t\t\tint x = q.poll();\n\t\t\t\n\t\t\tint row = x >> 1;\n\t\t\tint col = x & 1;\n\t\t\tint d = dist[row][col];\n\t\t\t\n\t\t\tif(row - 1 >= 0 && cs[row - 1][col] == '-' && dist[row - 1][col] == INF)\n\t\t\t{\n\t\t\t\tif(row - 1 >= d + 1)\n\t\t\t\t{\n\t\t\t\t\tdist[row - 1][col] = d + 1;\n\t\t\t\t\tq.offer((row - 1) * 2 + col);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(row + 1 >= n) return true;\n\t\t\t\n\t\t\tif(cs[row + 1][col] == '-' && dist[row + 1][col] == INF)\n\t\t\t{\n\t\t\t\tif(row + 1 >= d + 1)\n\t\t\t\t{\n\t\t\t\t\tdist[row + 1][col] = d + 1;\n\t\t\t\t\tq.offer((row + 1) * 2 + col);\n\t\t\t\t}\t\n\t\t\t}\n\t\t\t\n\t\t\tif(row + k >= n) return true;\n\t\t\t\n\t\t\t//print(row + k, 1 - col);\n\t\t\tif(cs[row + k][1 - col] == '-' && dist[row + k][1 - col] == INF)\n\t\t\t{\n\t\t\t\tif(row + k >= d + 1)\n\t\t\t\t{\n\t\t\t\t\tdist[row + k][1 - col] = d + 1;\n\t\t\t\t\tq.offer((row + k) * 2 + (1 - col));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tString next() throws IOException\n\t{\n\t\twhile(st == null || !st.hasMoreTokens()) st = new StringTokenizer(input.readLine());\n\t\treturn st.nextToken();\n\t}\n\t\n\tint nextInt() throws IOException\n\t{\n\t\treturn Integer.parseInt(next());\n\t}\n\t\n\tlong nextLong() throws IOException\n\t{\n\t\treturn Long.parseLong(next());\n\t}\n\t\n\tdouble nextDouble() throws IOException\n\t{\n\t\treturn Double.parseDouble(next());\n\t}\n\t\n\tvoid print(Object... o)\n\t{\n\t\tSystem.out.println(deepToString(o));\n\t}\n\t\n\tvoid gcj(Object o)\n\t{\n\t\tString s = String.valueOf(o);\n\t\tout.println(\"Case #\" + test + \": \" + s);\n\t\tSystem.out.println(\"Case #\" + test + \": \" + s);\n\t}\n\t\n\tBufferedReader input;\n\tPrintWriter out;\n\tStringTokenizer st;\n\tint test;\n\t\n\tvoid init() throws IOException\n\t{\n\t\tif(TEST) input = new BufferedReader(new FileReader(file + \".in\")); \n\t\telse input = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(new BufferedOutputStream(System.out));\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tnew Thread(null, new B(), \"\", 1 << 20).start();\n\t}\n\t\n\tpublic void run()\n\t{\n\t\ttry\n\t\t{\n\t\t\tinit();\n\t\t\tif(TEST) \n\t\t\t{\n\t\t\t\tint runs = nextInt();\n\t\t\t\tfor(int i = 0; i < runs; i++) solve();\n\t\t\t}\n\t\t\telse solve();\n\t\t\tout.close();\t\t\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nstring s[2];\nint f[1000000][2];\nbool vis[1000000][2];\nbool spfa() {\n  memset(vis, false, sizeof(vis));\n  for (int i = 0; i < n + 5; i++) f[i][0] = f[i][1] = -1u >> 1;\n  f[0][0] = 0;\n  queue<pair<int, int> > que;\n  que.push(make_pair(0, 0));\n  while (!que.empty()) {\n    pair<int, int> now = que.front();\n    que.pop();\n    int p = now.first, id = now.second;\n    vis[p][id] = false;\n    if (p + 1 >= n ||\n        (p + 1 < n && s[id][p + 1] != 'X' && f[p][id] + 1 <= p + 1)) {\n      if (p + 1 >= n) return true;\n      if (f[p + 1][id] > f[p][id] + 1) {\n        f[p + 1][id] = f[p][id] + 1;\n        if (!vis[p + 1][id]) {\n          vis[p + 1][id] = true;\n          que.push(make_pair(p + 1, id));\n        }\n      }\n    }\n    if (p - 1 >= 0 && s[id][p - 1] != 'X' && f[p][id] + 1 <= p - 1) {\n      if (f[p - 1][id] > f[p][id] + 1) {\n        f[p - 1][id] = f[p][id] + 1;\n        if (!vis[p - 1][id]) {\n          vis[p - 1][id] = true;\n          que.push(make_pair(p - 1, id));\n        }\n      }\n    }\n    if (p + k >= n ||\n        (p + k < n && s[id ^ 1][p + k] != 'X' && f[p][id] + 1 <= p + k)) {\n      if (p + k >= n) return true;\n      if (f[p + k][id ^ 1] > f[p][id] + 1) {\n        f[p + k][id ^ 1] = f[p][id] + 1;\n        if (!vis[p + k][id ^ 1]) {\n          vis[p + k][id ^ 1] = true;\n          que.push(make_pair(p + k, id ^ 1));\n        }\n      }\n    }\n  }\n  return false;\n}\nint main() {\n  cin >> n >> k;\n  cin >> s[0];\n  cin >> s[1];\n  s[0] += \"-\";\n  s[1] += \"-\";\n  bool ans = spfa();\n  if (ans)\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Task198b{\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task solver = new Task();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass Task{\n    private static class Node{\n        int v, side;\n        public Node(int v, int side){\n            this.v = v;\n            this.side = side;\n        }\n    }\n    private static final int INF = 1000000007;\n    private int[][] valid, dis;\n    private boolean[][] vis;\n    private int n, k, time;\n\n    private boolean bfs(){\n        Queue<Node> q = new LinkedList<>();\n        q.add(new Node(1, 0));\n        dis[1][0] = 0;\n        while(q.size() > 0){\n            Node t = q.poll();\n            if (vis[t.v][t.side] == true) continue;\n            vis[t.v][t.side] = true;\n            if (dis[t.v][t.side] >= t.v) continue;\n            if (t.v > n) return true;\n\n            if (t.v + 1 <= n && valid[t.v + 1][t.side] == 1){\n                q.add(new Node(t.v + 1, t.side));\n                dis[t.v + 1][t.side] = Math.min(dis[t.v + 1][t.side], dis[t.v][t.side] + 1);\n            }\n            if (t.v - 1 > 0 && valid[t.v - 1][t.side] == 1){\n                q.add(new Node(t.v - 1, t.side));\n                dis[t.v - 1][t.side] = Math.min(dis[t.v - 1][t.side], dis[t.v][t.side] + 1);\n            }\n            if (t.v + k <= n && valid[t.v + k][1-t.side] == 1){\n                q.add(new Node(t.v + k, 1-t.side));\n                dis[t.v + k][1 - t.side] = Math.min(dis[t.v + k][1 - t.side], dis[t.v][t.side] + 1);\n            }\n            if (t.v + k > n)\n                return true;\n            time++;\n        }\n        return false;\n    }\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        n = in.nextInt();\n        k = in.nextInt();\n        String l = in.next();\n        String r = in.next();\n        valid = new int[n+1][2];\n        dis = new int[n+1][2];\n        vis = new boolean[n+1][2];\n        time = 0;\n        for (int i = 0; i<=n; i++){\n            dis[i][0] = dis[i][1] = INF;\n        }\n        for (int i = 0; i<n; i++){\n            if (l.charAt(i) == '-') valid[i + 1][0] = 1;\n            if (r.charAt(i) == '-') valid[i + 1][1] = 1;\n        }\n        if (bfs() == true)\n            out.println(\"YES\");\n        else out.println(\"NO\");\n    }\n}\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int inf = 1000000000;\nusing namespace std;\nchar sr[2][100010];\nint d[200010], cur[200010], Q[200010];\nvector<int> g[200010];\nint N, K;\nbool bfs(int u) {\n  int s = 0, t = 0;\n  memset(d, -1, sizeof(d));\n  if (sr[0][0] == 'X') return false;\n  d[u] = 1;\n  Q[t++] = u;\n  while (s < t) {\n    u = Q[s++];\n    if ((u >> 1) + K >= N) return true;\n    int sz = g[u].size();\n    for (int i = 0; i < sz; i++) {\n      int v = g[u][i];\n      if (d[v] == -1) {\n        d[v] = d[u] + 1;\n        if (d[v] <= cur[v]) {\n          Q[t++] = v;\n        }\n      }\n    }\n  }\n  return false;\n}\nbool go() {\n  for (int i = 0; i < N; i++) {\n    for (int o = 0; o < 2; o++) {\n      if (sr[o][i] == '-' && sr[o][i + 1] == '-') {\n        g[i << 1 | o].push_back(i + 1 << 1 | o);\n        g[i + 1 << 1 | o].push_back(i << 1 | o);\n      }\n      if (sr[o][i] == '-' && i + K < N && sr[o ^ 1][i + K] == '-') {\n        g[i << 1 | o].push_back(i + K << 1 | (o ^ 1));\n      }\n      cur[i << 1 | o] = i + 1;\n    }\n  }\n  return bfs(0);\n}\nint main() {\n  cin >> N >> K;\n  scanf(\"%s%s\", sr[0], sr[1]);\n  int ans = go();\n  puts(ans ? \"YES\" : \"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n        \n        String[] line = r.readLine().split(\"[ ]+\");\n        int N = Integer.parseInt(line[0]);\n        int K = Integer.parseInt(line[1]);\n        \n        char[][] a = new char[2][];\n        a[0] = r.readLine().toCharArray();\n        a[1] = r.readLine().toCharArray();\n        \n        boolean[][] v = new boolean[N + K + 10][2];\n        \n        Queue<State> q = new LinkedList<State>();\n        q.add(new State(0, 0, 0, 0));\n        \n        while(!q.isEmpty()){\n            State st = q.poll();\n//          System.out.println(st.i + \", \" + st.d + \", \" + st.w);\n            \n            if(st.i >= N){\n                System.out.println(\"YES\");\n                return;\n            }\n                \n            if(st.i + 1 >= N || (a[st.d][st.i + 1] == '-' && !v[st.i + 1][st.d])){\n                v[st.i + 1][st.d] = true;\n                if(st.w + 1 <= st.i + 1)q.add(new State(st.i + 1, st.d, 1 - st.t, st.w + 1));\n            }\n            if(st.i - 1 >= 0 && (a[st.d][st.i - 1] == '-' && !v[st.i - 1][st.d])){\n                v[st.i - 1][st.d] = true;\n                if(st.w + 1 <= st.i - 1)q.add(new State(st.i - 1, st.d, 1 - st.t, st.w + 1));\n            }\n            if(st.i + K >= N || (a[1 - st.d][st.i + K] == '-' && !v[st.i + K][1 - st.d])){\n                v[st.i + K][1 - st.d] = true;\n                if(st.w + 1 <= st.i + K)q.add(new State(st.i + K, 1 - st.d, 1 - st.t, st.w + 1));\n            }\n        }\n        \n        System.out.println(\"NO\");\n    }\n    \n}\nclass State{\n    int i, d, t, w;\n    public State(int ii, int di, int ti, int wi){\n        i = ii;\n        d = di;\n        t = ti;\n        w = wi;\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class B implements Runnable {\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer st;\n\tRandom rnd;\n\t\n\tString[] walls = new String[2];\n\tint[][] distances = new int[2][];\n\tfinal int inf = Integer.MAX_VALUE / 2;\n\tQueue<State> q = new ArrayDeque<B.State>();\n\tfinal int[] dxs = {1, -1};\n\t\n\t\n\tclass State {\n\t\tint wall, x;\n\n\t\tpublic State(int wall, int x) {\n\t\t\tthis.wall = wall;\n\t\t\tthis.x = x;\n\t\t}\n\t}\n\n\tvoid solve() throws IOException {\n\t\tint n = nextInt(), k = nextInt();\n\t\t\n\t\tfor(int i = 0; i < 2; i++) {\n\t\t\twalls[i] = nextToken();\n\t\t\tdistances[i] = new int[n];\n\t\t\tArrays.fill(distances[i], inf);\n\t\t}\n\t\t\n\t\tdistances[0][0] = 0;\n\t\tq.add(new State(0, 0));\n\t\t\n\t\tboolean ok = false;\n\t\t\n\t\twhile(q.size() > 0) {\n\t\t\tState cur = q.poll();\n\t\t\tint nd = distances[cur.wall][cur.x] + 1;\n\t\t\t\n\t\t\tfor(int dx : dxs) {\n\t\t\t\tint nwall = cur.wall, nx = cur.x + dx;\n\t\t\t\t\n\t\t\t\tif(nx >= n) {\n\t\t\t\t\tok = true;\n\t\t\t\t} else if(nx >= 0 && nx < n && nx >= nd && distances[nwall][nx] > nd && walls[nwall].charAt(nx) == '-') {\n\t\t\t\t\tdistances[nwall][nx] = nd;\n\t\t\t\t\tq.add(new State(nwall, nx));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t{\n\t\t\t\tint nwall = 1 - cur.wall, nx = cur.x + k;\n\t\t\t\t\n\t\t\t\tif(nx >= n) {\n\t\t\t\t\tok = true;\n\t\t\t\t} else if(nx >= 0 && nx < n && nx >= nd && distances[nwall][nx] > nd && walls[nwall].charAt(nx) == '-') {\n\t\t\t\t\tdistances[nwall][nx] = nd;\n\t\t\t\t\tq.add(new State(nwall, nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(ok ? \"YES\" : \"NO\");\n\t\t\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew B().run();\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\n\t\t\trnd = new Random();\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(42);\n\t\t}\n\t}\n\n\tString nextToken() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\tString line = in.readLine();\n\n\t\t\tif (line == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tst = new StringTokenizer(line);\n\t\t}\n\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int tavan(int a, int n, int mod) {\n  int p = 1;\n  while (n > 0) {\n    if (n % 2) {\n      p = p * a;\n      p %= mod;\n    }\n    n >>= 1;\n    a *= a;\n    a %= mod;\n  }\n  return p % mod;\n}\nint n, k, d[2][(201 * 1000)];\nbool mark[2][(201 * 1000)];\nstring s[2];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k >> s[0] >> s[1];\n  for (int i = 0; i <= k + 100; i++) s[0] += '-', s[1] += '-';\n  queue<pair<bool, int> > q;\n  q.push({0, 0});\n  while (q.size()) {\n    bool p = q.front().first;\n    int x = q.front().second;\n    q.pop();\n    if (x > 0 && !mark[p][x - 1] && s[p][x - 1] == '-') {\n      mark[p][x - 1] = 1;\n      d[p][x - 1] = d[p][x] + 1;\n      if (d[p][x - 1] <= x - 1) q.push({p, x - 1});\n    }\n    if (!mark[p][x + 1] && s[p][x + 1] == '-') {\n      mark[p][x + 1] = 1;\n      d[p][x + 1] = d[p][x] + 1;\n      if (x + 1 < n) q.push({p, x + 1});\n    }\n    if (!mark[!p][x + k] && s[!p][x + k] == '-') {\n      mark[!p][x + k] = 1;\n      d[!p][x + k] = d[p][x] + 1;\n      if (x + k < n) q.push({!p, x + k});\n    }\n  }\n  for (int i = n; i < (201 * 1000); i++) {\n    if (mark[0][i] && d[0][i] <= i) return cout << \"YES\", 0;\n    if (mark[1][i] && d[1][i] <= i) return cout << \"YES\", 0;\n  }\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\nimport java.io.Writer;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Nguyen Trung Hieu - vuondenthanhcong11@yahoo.com\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass TaskB {\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n        int height = in.readInt();\n        int jump = in.readInt();\n        char[] left = in.readString().toCharArray();\n        char[] right = in.readString().toCharArray();\n        int[] answer = new int[2 * height];\n        int[] queue = new int[2 * height];\n        int size = 1;\n        Arrays.fill(answer, Integer.MAX_VALUE);\n        answer[0] = 0;\n        for (int i = 0; i < size; i++) {\n            int current = queue[i];\n            boolean isLeft = current < height;\n            if (isLeft && left[current] == 'X' || !isLeft && right[current - height] == 'X' || answer[current] > current % height)\n                continue;\n            if (current % height + jump >= height) {\n                out.printLine(\"YES\");\n                return;\n            }\n            if (answer[current + 1] == Integer.MAX_VALUE) {\n                answer[current + 1] = answer[current] + 1;\n                queue[size++] = current + 1;\n            }\n            if (current % height != 0 && answer[current - 1] == Integer.MAX_VALUE) {\n                answer[current - 1] = answer[current] + 1;\n                queue[size++] = current - 1;\n            }\n            int jumpTo;\n            if (isLeft)\n                jumpTo = current + height + jump;\n            else\n                jumpTo = current - height + jump;\n            if (answer[jumpTo] == Integer.MAX_VALUE) {\n                answer[jumpTo] = answer[current] + 1;\n                queue[size++] = jumpTo;\n            }\n        }\n        out.printLine(\"NO\");\n    }\n}\n\nclass InputReader {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private SpaceCharFilter filter;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public int read() {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int readInt() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public boolean isSpaceChar(int c) {\n        if (filter != null)\n            return filter.isSpaceChar(c);\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public String readString() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        StringBuffer res = new StringBuffer();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n        return res.toString();\n    }\n\n    public interface SpaceCharFilter {\n        public boolean isSpaceChar(int ch);\n    }\n\n    }\n\nclass OutputWriter {\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n        this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object...objects) {\n        for (int i = 0; i < objects.length; i++) {\n            if (i != 0)\n                writer.print(' ');\n            writer.print(objects[i]);\n        }\n    }\n\n    public void printLine(Object...objects) {\n        print(objects);\n        writer.println();\n    }\n\n    public void close() {\n        writer.close();\n    }\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\n\npublic class D implements Runnable {\n\n    public static final char WALL = '-';\n    public static final char DANGEROUS_WALL = 'X';\n\n    public static final int LEFT_WALL = 0;\n    public static final int RIGHT_WALL = 1;\n\n    private PrintWriter out = new PrintWriter(System.out, true);\n    private BufferedReader reader;\n\n    private int n, k;\n    private char[][] walls;\n    private boolean[][] visit;\n\n    @Override\n    public void run() {\n        try {\n            String[] first = reader.readLine().split(\"\\\\s+\");\n            n = Integer.parseInt(first[0]);\n            k = Integer.parseInt(first[1]);\n\n            char[] left = reader.readLine().toCharArray();\n            char[] right = reader.readLine().toCharArray();\n            walls = new char[][] { left, right };\n            visit = new boolean[2][n];\n\n            boolean res = calc();\n            out.println(res ? \"YES\" : \"NO\");\n            out.flush();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public boolean calc() {\n        return dfs(0, LEFT_WALL, 0);\n    }\n\n    public boolean dfs(int position, int wallSide, int waterLevel) {\n        if (drown(position, waterLevel)) {\n            return false;\n        }\n\n        return jumpedOut(position) || jump(position, wallSide, waterLevel + 1)\n                || goUpwards(position, wallSide, waterLevel + 1) || goDownwards(position, wallSide, waterLevel + 1);\n    }\n\n    private boolean drown(int position, int waterLevel) {\n        return position < waterLevel;\n    }\n\n    private boolean jumpedOut(int position) {\n        return position >= n - 1 || position + k >= n;\n    }\n\n    private boolean jump(int position, int wallSide, int newWaterLevel) {\n        return step(position + k, (wallSide + 1) % 2, newWaterLevel);\n    }\n\n    private boolean goUpwards(int position, int wallSide, int newWaterLevel) {\n        return step(position + 1, wallSide, newWaterLevel);\n    }\n\n    private boolean goDownwards(int position, int wallSide, int newWaterLevel) {\n        return step(position - 1, wallSide, newWaterLevel);\n    }\n\n    private boolean step(int position, int wall, int newWaterLevel) {\n        return canProceed(position, wall) && visit(position, wall) && dfs(position, wall, newWaterLevel);\n    }\n\n    private boolean visit(int position, int wallSide) {\n        visit[wallSide][position] = true;\n        return true;\n    }\n\n    private boolean canProceed(int position, int wall) {\n        if (position < 0 || position >= n) {\n            return false;\n        }\n        return notVisited(position, wall) && canVisit(position, wall);\n    }\n\n    private boolean notVisited(int position, int wall) {\n        return !visit[wall][position];\n    }\n\n    private boolean canVisit(int position, int wall) {\n        return walls[wall][position] != DANGEROUS_WALL;\n    }\n\n    public D setInput(InputStream inputStream) {\n        this.reader = new BufferedReader(new InputStreamReader(inputStream));\n        return this;\n    }\n\n    public static void main(String[] args) {\n        new D().setInput(System.in).run();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct data {\n  int w, p;\n};\ndata ml[3] = {{0, 1}, {1, 0}, {0, -1}};\nbool bfs(data cur);\nchar wall[2][100100];\nbool colour[2][100100];\nint n, x;\ndata cur;\nint main() {\n  scanf(\"%d %d\", &n, &x);\n  scanf(\" %s %s\", &wall[0][1], &wall[1][1]);\n  cur.w = 0, cur.p = 1;\n  ml[1].p = x;\n  if (wall[0][1] != 'X' && bfs(cur))\n    printf(\"YES\\n\");\n  else\n    printf(\"NO\\n\");\n  return 0;\n}\nbool bfs(data cur) {\n  data tmp, level = cur;\n  int wl = 1, i;\n  colour[cur.w][cur.p] = true;\n  queue<data> q;\n  q.push(cur);\n  while (!q.empty()) {\n    cur = q.front();\n    for (i = 0; i < 3; i++) {\n      tmp = cur;\n      tmp.w ^= ml[i].w;\n      tmp.p += ml[i].p;\n      if (tmp.p > n) return true;\n      if (tmp.p > wl && !colour[tmp.w][tmp.p] && wall[tmp.w][tmp.p] != 'X') {\n        q.push(tmp);\n        colour[tmp.w][tmp.p] = true;\n      }\n    }\n    if (level.w == cur.w && level.p == cur.p) {\n      wl++;\n      level = q.back();\n    }\n    q.pop();\n  }\n  return false;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        BJumpingOnWalls solver = new BJumpingOnWalls();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BJumpingOnWalls {\n        private int n;\n        private int k;\n\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            n = in.nextInt();\n            k = in.nextInt();\n            String[] wallStrs = new String[2];\n            wallStrs[0] = in.next();\n            wallStrs[1] = in.next();\n            int[] walls = new int[]{0, 1};\n            List<List<Integer>> adjList = new ArrayList<>();\n            for (int i = 0; i < 2 * n; i++) {\n                adjList.add(new ArrayList<>());\n            }\n            for (int i = 0; i < n; i++) {\n                for (int wall : walls) {\n                    if (wallStrs[wall].charAt(i) != '-') continue;\n                    if (i + k < n && wallStrs[wall ^ 1].charAt(i + k) == '-') {\n                        adjList.get(wall * n + i).add((wall ^ 1) * n + i + k);\n                    }\n                    if (i + 1 < n && wallStrs[wall].charAt(i + 1) == '-') {\n                        adjList.get(wall * n + i).add(wall * n + i + 1);\n                    }\n                    if (i > 0 && wallStrs[wall].charAt(i - 1) == '-') {\n                        adjList.get(wall * n + i).add(wall * n + i - 1);\n                    }\n                }\n            }\n\n            boolean[] vis = new boolean[2 * n];\n            if (dfs(0, vis, adjList, 0)) {\n                out.println(\"YES\");\n            } else {\n                out.println(\"NO\");\n            }\n\n        }\n\n        private boolean dfs(int curr, boolean[] vis, List<List<Integer>> adjList, int waterLevel) {\n            boolean exceedsWall1 = curr < n && curr + k >= n;\n            boolean exceedsWall2 = curr >= n && curr + k >= 2 * n;\n            if (exceedsWall1 || exceedsWall2) return true;\n            if (curr % n < waterLevel) return false;\n            if (vis[curr]) return false;\n            vis[curr] = true;\n            for (Integer neighbour : adjList.get(curr)) {\n                if (dfs(neighbour, vis, adjList, waterLevel + 1)) return true;\n            }\n            return false;\n        }\n\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public FastScanner(InputStream f) {\n            br = new BufferedReader(new InputStreamReader(f));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return null;\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstring s[2];\nint n, k, dp[2][100001], ans;\nvoid bfs(int wall, int height, int seconds) {\n  if (height >= n) ans = true;\n  if (height >= n || s[wall][height] == 'X' || dp[wall][height] <= seconds ||\n      seconds > height)\n    return;\n  dp[wall][height] = seconds;\n  bfs((wall + 1) % 2, height + k, seconds + 1);\n  bfs(wall, height + 1, seconds + 1);\n  bfs(wall, height - 1, seconds + 1);\n}\nint main() {\n  for (auto &i : dp)\n    for (auto &j : i) j = 1e9;\n  cin >> n >> k;\n  cin >> s[0] >> s[1];\n  bfs(0, 0, 0);\n  cout << (ans ? \"YES\\n\" : \"NO\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.awt.Point;\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Throwable {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt() , k =sc.nextInt() , oo = (int)1e9;\n\t\tchar[][] a = new char[2][n];\n\t\ta[0] = sc.nextLine().toCharArray();\n\t\ta[1] = sc.nextLine().toCharArray();\n\t\tint[][] dist = new int[2][n];\n\t\tArrays.fill(dist[0], oo);\n\t\tArrays.fill(dist[1], oo);\n\t\tQueue<Point> q = new LinkedList<>();\n\t\tdist[0][0] = 0;\n\t\tq.add(new Point(0, 0));\n\t\twhile(!q.isEmpty())\n\t\t{\n\t\t\tPoint cur = q.poll();\n\t\t\tint lvl = cur.x , pos = cur.y , d = dist[lvl][pos]+1;\n\t\t\tif(pos>0 && a[lvl][pos-1]=='-' && d < dist[lvl][pos-1] && d<=pos-1)\n\t\t\t{\n\t\t\t\tdist[lvl][pos-1] = d;\n\t\t\t\tq.add(new Point(lvl, pos-1));\n\t\t\t}\n\t\t\tif(pos+1<n && a[lvl][pos+1]=='-' && d < dist[lvl][pos+1] && d<=pos+1)\n\t\t\t{\n\t\t\t\tdist[lvl][pos+1] = d;\n\t\t\t\tq.add(new Point(lvl, pos+1));\n\t\t\t}\n\t\t\tif(pos+k<n && a[1-lvl][pos+k]=='-' && d<dist[1-lvl][pos+k] && d<=pos+k)\n\t\t\t{\n\t\t\t\tdist[1-lvl][pos+k] = d;\n\t\t\t\tq.add(new Point(1-lvl, pos+k));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = n-1;i>=n-k ;i--)\n\t\t{\n\t\t\tif(dist[0][i] < oo || dist[1][i] < oo)\n\t\t\t{\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"NO\");\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\t\tpublic Scanner(InputStream s) {br = new BufferedReader(new InputStreamReader(s));}\n\t\tpublic Scanner(String file) throws FileNotFoundException {br = new BufferedReader(new FileReader(file));}\n\t\tpublic String next() throws IOException {while (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();}\n\t\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n\t\tpublic long nextLong() throws IOException {return Long.parseLong(next());}\n\t\tpublic String nextLine() throws IOException {return br.readLine();}\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif (x.charAt(0) == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor (int i = start; i < x.length(); i++)\n\t\t\t\tif (x.charAt(i) == '.') {\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif (dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg ? -1 : 1);\n\t\t}\n\t\tpublic int[] nexIntArray() throws Throwable {\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\tint[] a = new int[st.countTokens()];\n\t\t\tfor (int i = 0; i < a.length; i++)a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tpublic boolean ready() throws IOException {return br.ready();}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar c[2][100001];\nint s[100001][2], q[100001][2], si;\nint main() {\n  int n, k, i, j, u = 0, x, y;\n  cin >> n >> k >> c[0] >> c[1];\n  q[0][0] = 0;\n  q[0][1] = 0;\n  for (i = 0; i < n; i++) s[i][0] = s[i][1] = 100000000;\n  s[0][0] = 0;\n  si = 1;\n  while (u < si) {\n    x = q[u][0];\n    y = q[u][1];\n    if (x == n - 1 || x + k >= n) {\n      cout << \"YES\";\n      return 0;\n    }\n    if (c[y][x + 1] != 'X' && s[x + 1][y] > s[x][y] + 1) {\n      s[x + 1][y] = s[x][y] + 1;\n      q[si][0] = x + 1;\n      q[si][1] = y;\n      si++;\n    }\n    if (x + k < n && c[1 - y][x + k] != 'X' && s[x + k][1 - y] > s[x][y] + 1) {\n      s[x + k][1 - y] = s[x][y] + 1;\n      q[si][0] = x + k;\n      q[si][1] = 1 - y;\n      si++;\n    }\n    if (x - 1 > 0 && c[y][x - 1] != 'X' && s[x][y] <= x &&\n        s[x - 1][y] > s[x][y] + 1 && s[x][y] + 1 <= x - 1) {\n      s[x - 1][y] = s[x][y] + 1;\n      q[si][0] = x - 1;\n      q[si][1] = y;\n      si++;\n    }\n    u++;\n  }\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nchar str[2][1000000];\nint d[2][1000000];\nstruct {\n  int lor;\n  int s;\n} queue[2000000];\nint qt = 0, qh = 0;\nint n, exitf = 0;\nvoid add(int lor, int s, int z) {\n  if (s >= n) {\n    exitf = 1;\n    return;\n  }\n  if (s >= 0 && str[lor][s] == '-' && !d[lor][s] && s >= z) {\n    queue[qh].lor = lor;\n    queue[qh].s = s;\n    qh++;\n    d[lor][s] = z;\n  }\n  return;\n}\nint main() {\n  int k;\n  scanf(\"%d %d\\n%s\\n%s\", &n, &k, str[0], str[1]);\n  add(0, 0, 0);\n  while (qt < qh && !exitf) {\n    add(queue[qt].lor, queue[qt].s + 1, d[queue[qt].lor][queue[qt].s] + 1);\n    add(queue[qt].lor, queue[qt].s - 1, d[queue[qt].lor][queue[qt].s] + 1);\n    add((queue[qt].lor) ? 0 : 1, queue[qt].s + k,\n        d[queue[qt].lor][queue[qt].s] + 1);\n    qt++;\n  }\n  printf(\"%s\", ((exitf) ? \"YES\" : \"NO\"));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T1>\ninline void debug(T1 _x) {\n  cout << _x << '\\n';\n}\ntemplate <class T1, class T2>\ninline void debug(T1 _x, T2 _y) {\n  cout << _x << ' ' << _y << '\\n';\n}\ntemplate <class T1, class T2, class T3>\ninline void debug(T1 _x, T2 _y, T3 _z) {\n  cout << _x << ' ' << _y << ' ' << _z << '\\n';\n}\ntemplate <class T1, class T2, class T3, class T4>\ninline void debug(T1 _x, T2 _y, T3 _z, T4 _zz) {\n  cout << _x << ' ' << _y << ' ' << _z << ' ' << _zz << '\\n';\n}\ntemplate <class T1>\ninline void debug(T1 _array, int _size) {\n  cout << \"[\";\n  for (int i = 0; i < _size; ++i) {\n    cout << ' ' << _array[i];\n  }\n  puts(\" ]\");\n}\ninline bool CI(int &_x) { return scanf(\"%d\", &_x) == 1; }\ninline bool CI(int &_x, int &_y) { return CI(_x) && CI(_y); }\ninline bool CI(int &_x, int &_y, int &_z) { return CI(_x) && CI(_y) && CI(_z); }\ninline bool CI(int &_x, int &_y, int &_z, int &_zz) {\n  return CI(_x) && CI(_y) && CI(_z) && CI(_zz);\n}\ninline void wait(double seconds) {\n  double endtime = clock() + (seconds * CLOCKS_PER_SEC);\n  while (clock() < endtime) {\n    ;\n  }\n}\nconst int mxn = (int)1e5 + 20;\nchar grid[2][mxn];\nint N, K;\ninline void read() {\n  scanf(\"%d %d\\n\", &N, &K);\n  gets(grid[0]);\n  gets(grid[1]);\n}\nint water[mxn];\nint path[2][mxn];\nint vis[2][mxn];\nstruct NODE {\n  int at;\n  int pos;\n  int tim;\n  NODE() {}\n  NODE(int at_, int pos_, int tim_) {\n    at = at_;\n    pos = pos_;\n    tim = tim_;\n  }\n};\ninline bool possible(int at) {\n  if (!path[at][1]) return false;\n  memset(vis, 0, sizeof(vis));\n  queue<NODE> q;\n  q.push(NODE(at, 1, 0));\n  vis[at][1] = 1;\n  while (!q.empty()) {\n    int cur_pile = q.front().at;\n    int cur_pos = q.front().pos;\n    int cur_tim = q.front().tim;\n    q.pop();\n    int nxt_pos = cur_pos + 1;\n    int nxt_tim = cur_tim + 1;\n    if (nxt_pos > N) return true;\n    if (path[cur_pile][nxt_pos] && water[nxt_pos] > nxt_tim &&\n        !vis[cur_pile][nxt_pos]) {\n      vis[cur_pile][nxt_pos] = 1;\n      q.push(NODE(cur_pile, nxt_pos, nxt_tim));\n    }\n    nxt_pos = cur_pos - 1;\n    if (nxt_pos > N) return true;\n    if (path[cur_pile][nxt_pos] && water[nxt_pos] > nxt_tim &&\n        !vis[cur_pile][nxt_pos]) {\n      vis[cur_pile][nxt_pos] = 1;\n      q.push(NODE(cur_pile, nxt_pos, nxt_tim));\n    }\n    nxt_pos = cur_pos + K;\n    if (nxt_pos > N) return true;\n    if (path[cur_pile ^ 1][nxt_pos] && water[nxt_pos] > nxt_tim &&\n        !vis[cur_pile ^ 1][nxt_pos]) {\n      vis[cur_pile ^ 1][nxt_pos] = 1;\n      q.push(NODE(cur_pile ^ 1, nxt_pos, nxt_tim));\n    }\n  }\n  return false;\n}\ninline void proc() {\n  memset(water, 0, sizeof(water));\n  for (int i = 1, j1 = N + 1; i < j1; ++i) {\n    water[i] = water[i - 1] + 1;\n  }\n  memset(path, -1, sizeof(path));\n  path[0][0] = path[1][0] = 0;\n  for (int i = 1, j1 = N + 1; i < j1; ++i) {\n    if (grid[0][i - 1] == 'X') path[0][i] = 0;\n    if (grid[1][i - 1] == 'X') path[1][i] = 0;\n  }\n  int f = possible(0);\n  puts((f ? \"YES\" : \"NO\"));\n}\nint main() {\n  int kase = 1;\n  for (int i = 0, j1 = kase; i < j1; ++i) {\n    read();\n    proc();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar a[100005];\nchar b[100005];\nint vis1[100005], vis2[100005];\nint valid = 0;\nint n, x, k, y;\nstruct pos {\n  int t, i, k;\n};\nint val(struct pos cur) {\n  if (cur.k < 0) return 0;\n  if (cur.k >= n) {\n    valid = 1;\n    return 0;\n  }\n  if (cur.i == 0 && vis1[cur.k]) return 0;\n  if (cur.i == 1 && vis2[cur.k]) return 0;\n  if (cur.i == 0 && a[cur.k] == 'X') return 0;\n  if (cur.i == 1 && b[cur.k] == 'X') return 0;\n  if (cur.k < cur.t) return 0;\n  if (cur.i == 0) vis1[cur.k] = 1;\n  if (cur.i == 1) vis2[cur.k] = 1;\n  return 1;\n}\nvoid pr(struct pos cur) {}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  scanf(\"%s%s\", &a, &b);\n  int i;\n  queue<struct pos> q;\n  struct pos cur;\n  cur.t = 0;\n  cur.i = 0;\n  cur.k = 0;\n  q.push(cur);\n  vis1[0] = 1;\n  while (!q.empty()) {\n    cur = q.front();\n    pr(cur);\n    q.pop();\n    if (cur.k >= n - 1) {\n      valid = 1;\n      break;\n    }\n    if (cur.k + k > n) {\n      valid = 1;\n      break;\n    }\n    struct pos ne;\n    ne.i = 1 - cur.i;\n    ne.t = cur.t + 1;\n    ne.k = cur.k + k;\n    if (val(ne)) q.push(ne);\n    ne.k = cur.k - k;\n    if (val(ne)) q.push(ne);\n    ne.i = cur.i;\n    ne.k = cur.k + 1;\n    if (val(ne)) q.push(ne);\n    ne.k = cur.k - 1;\n    if (val(ne)) q.push(ne);\n  }\n  if (valid)\n    printf(\"YES\\n\");\n  else\n    printf(\"NO\\n\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 10;\nint n, k;\nqueue<pair<int, int>> q;\nvector<vector<char>> a(2, vector<char>(MAXN));\nvector<vector<int>> dst(2, vector<int>(MAXN));\nbool add(int x, int y, int l) {\n  if (y > n) {\n    return true;\n  } else if (dst[x][y] != 0 || y + 1 <= l || a[x][y] == 'X') {\n    return false;\n  }\n  dst[x][y] = l;\n  q.push({x, y});\n  return false;\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < n; j++) {\n      cin >> a[i][j];\n    }\n  }\n  dst[0][0] = 0;\n  q.push({0, 0});\n  while (!q.empty()) {\n    int x = q.front().first;\n    int y = q.front().second;\n    q.pop();\n    int l = dst[x][y] + 1;\n    if (add(x, y + 1, l) || add(x, y - 1, l) || add(1 - x, y + k, l)) {\n      cout << \"YES\";\n      return 0;\n    }\n  }\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing pll = pair<ll, ll>;\nusing vll = vector<ll>;\nusing vpll = vector<pll>;\nvoid ga(ll N, int *A) {\n  for (ll i(0); i < N; i++) cin >> A[i];\n}\nll n, k;\nstring w[2];\nint main(void) {\n  ios_base::sync_with_stdio(false);\n  cin >> n >> k;\n  cin >> w[0] >> w[1];\n  queue<pll> q;\n  q.push({0, 0});\n  bool ok = 0;\n  bitset<200007> cl;\n  while (q.size()) {\n    pll act = q.front();\n    q.pop();\n    ll pos = act.first / 2;\n    bool left = act.first % 2;\n    if (pos == n - 1 || pos + k >= n) {\n      ok = 1;\n      break;\n    }\n    ll j1 = (pos + k) * 2 + (!left);\n    if (pos + k < n && !cl[j1] && w[!left][pos + k] != 'X') {\n      cl[j1] = 1;\n      q.push({j1, act.second + 1});\n    }\n    if (!cl[(pos + 1) * 2 + left] && w[left][pos + 1] != 'X') {\n      ll j2 = (pos + 1) * 2 + left;\n      cl[j2] = 1;\n      q.push({j2, act.second + 1});\n    }\n    if (pos && !cl[(pos - 1) * 2 + left] && w[left][pos - 1] != 'X' &&\n        pos - 1 >= act.second + 1) {\n      ll j3 = (pos - 1) * 2 + left;\n      cl[j3] = 1;\n      q.push({j3, act.second + 1});\n    }\n  }\n  cout << (ok ? \"YES\" : \"NO\") << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\npublic class Solver {\n\n    StringTokenizer st;\n    BufferedReader in;\n    PrintWriter out;\n\n    public static void main(String[] args) throws NumberFormatException, IOException {\n        Solver solver = new Solver();\n        solver.open();\n        long time = System.currentTimeMillis();\n        solver.solve();\n        //System.out.println(\"Spent time: \"+(System.currentTimeMillis()-time));\n        solver.close();\n    }\n\n    public void open() throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n    }\n\n    public String nextToken() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n\n    public int nextInt() throws NumberFormatException, IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    public long nextLong() throws NumberFormatException, IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    public double nextDouble() throws NumberFormatException, IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    public void solve() throws NumberFormatException, IOException {\n        int n = nextInt();\n        int k = nextInt();\n        char[] left = nextToken().toCharArray();\n        char[] right = nextToken().toCharArray();\n        int m = n+k+10;\n        int[] dpl = new int[m];\n        Arrays.fill(dpl, Integer.MAX_VALUE);\n        int[] dpr = new int[m];\n        Arrays.fill(dpr, Integer.MAX_VALUE);\n        \n        Queue<Integer> steps = new LinkedList<Integer>();\n        Queue<Integer> when = new LinkedList<Integer>();\n        when.offer(1);\n        steps.offer(-1);\n        while (!steps.isEmpty()){\n            int next = steps.remove();\n            \n            boolean onLeft = next<0;\n            next = Math.abs(next);\n            int pri = when.remove();\n            \n            if(next>n){\n                out.println(\"YES\");\n                return;\n            }\n            \n            if (next<1)continue;\n            \n            if(onLeft){\n                if (pri>next || left[next-1]=='X' || dpl[next]<=pri)\n                    continue;\n            }else{\n                if (pri>next || right[next-1]=='X' || dpr[next]<=pri)\n                    continue;\n            }\n            \n            \n            if(onLeft){\n                dpl[next] = pri;\n                steps.offer(-next-1);\n                steps.offer(-next+1);\n                steps.offer(next+k);\n            }else{\n                dpr[next] = pri;\n                steps.offer(next-1);\n                steps.offer(next+1);\n                steps.offer(-next-k);\n            }\n            pri++;\n            when.offer(pri);\n            when.offer(pri);\n            when.offer(pri);\n        }\n        \n        out.println(\"NO\");\n    }\n\n    public void close() {\n        out.flush();\n        out.close();\n    }\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100004;\nint v[maxn][2];\nint w, n, k;\nchar a[maxn];\nchar c[maxn];\nint dfs(int i, int b) {\n  if (i > n) {\n    cout << \"YES\";\n    exit(0);\n  }\n  if (i < w) return 0;\n  if (b) {\n    if (c[i] == 'X') return 0;\n  } else {\n    if (a[i] == 'X') return 0;\n  }\n  if (v[i][b]) return 0;\n  v[i][b] = 1;\n  w++;\n  dfs(i - 1, b);\n  dfs(i + k, !b);\n  dfs(i + 1, b);\n  w--;\n}\nint main() {\n  cin >> n >> k;\n  cin >> a;\n  cin >> c;\n  dfs(0, 0);\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint vis[2][200001];\nint main() {\n  int n, k, f = 0;\n  cin >> n >> k;\n  char c[2][200001];\n  for (int i = 0; i <= 200000; i++) c[0][i] = c[1][i] = '!';\n  for (int i = 0; i < n; i++) cin >> c[0][i];\n  for (int i = 0; i < n; i++) cin >> c[1][i];\n  queue<pair<int, int> > q;\n  if (c[0][0] == '-') q.push(make_pair(0, 0));\n  vis[0][0] = vis[1][0] = 1;\n  while (!q.empty()) {\n    int x = q.front().first, y = q.front().second;\n    if (!vis[x][y + 1] and c[x][y + 1] == '-') {\n      if (y >= n - 2) {\n        cout << \"YES\";\n        return 0;\n      }\n      q.push(make_pair(x, y + 1));\n      vis[x][y + 1] = vis[x][y] + 1;\n    }\n    if (!vis[1 - x][y + k]) {\n      if (y + k < n and c[1 - x][y + k] == '-')\n        q.push(make_pair(1 - x, y + k)), vis[1 - x][y + k] = vis[x][y] + 1;\n      if (y + k >= n) {\n        cout << \"YES\";\n        return 0;\n      }\n    }\n    if (y - 1 >= 0 and !vis[x][y - 1] and c[x][y - 1] == '-' and\n        vis[x][y] <= y - 1)\n      q.push(make_pair(x, y - 1)), vis[x][y - 1] = vis[x][y] + 1;\n    q.pop();\n  }\n  cout << \"NO\";\n}\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class Jumping {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] line = br.readLine().split(\" \");\n        int n=Integer.parseInt(line[0]);\n        int k=Integer.parseInt(line[1]);\n        boolean[] reachable = new boolean[n*2];\n        String left = br.readLine();\n        String right= br.readLine();\n        Queue<Integer> q = new LinkedList<Integer>();\n        q.add(0);\n        q.add(-5);\n        int agua = 0;\n        while(!q.isEmpty() && agua<n+3){\n            int curr = q.poll();\n            if(curr==-5){\n                q.add(-5);\n                agua++;\n                continue;\n            }\n            int wall = curr&1;\n            int pos = curr>>1;\n            if(pos >= n){\n                System.out.println(\"YES\");\n                return;\n            }\n            if(pos<agua || reachable[curr]) continue;\n            String s = ((wall==0)?left:right);\n            if(s.charAt(pos) == 'X') continue;\n            reachable[curr] = true;\n            q.add(curr-2);\n            q.add(curr+2);\n            q.add(((pos+k)<<1)+1-wall);\n        }\n        System.out.println(\"NO\");\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.awt.Point;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.math.BigInteger;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    int n, k;\n    String wall[] = new String[2];\n    int mark[][] = new int[2][100001];\n\n    boolean calc() {\n        TreeSet<Pair<Pair<Integer, Integer>, Integer> > set = new TreeSet<Pair<Pair<Integer, Integer>, Integer>>();\n\n        set.add(new Pair<Pair<Integer, Integer>, Integer>(new Pair<Integer, Integer>(0, 0), -1));\n\n        while (!set.isEmpty()) {\n            int y =-set.first().x.x;\n            int x = set.first().x.y;\n            int d = set.first().y;\n            set.remove(set.first());\n\n            if (y <= d)\n                continue;\n            if (y == n || y + k >= n)\n                return true;\n\n            if (wall[x].charAt(y + 1) == '-' && mark[x][y + 1] == 0) {\n                mark[x][y + 1] = 1;\n                set.add(new Pair<Pair<Integer, Integer>, Integer>(new Pair<Integer, Integer>(-(y + 1), x), d + 1));\n            }\n            if (y - 1 >= 0 && wall[x].charAt(y - 1) == '-' && mark[x][y - 1] == 0) {\n                mark[x][y - 1] = 1;\n                set.add(new Pair<Pair<Integer, Integer>, Integer>(new Pair<Integer, Integer>(-(y - 1), x), d + 1));\n            }\n            if (wall[(x + 1)%2].charAt(y + k) == '-' && mark[(x + 1)%2][y + k] == 0) {\n                mark[(x + 1)%2][y + k] = 1;\n                set.add(new Pair<Pair<Integer, Integer>, Integer>(new Pair<Integer, Integer>(-(y + k), (x + 1)%2), d + 1));\n            }\n        }\n\n        return false;\n    }\n    public void solve()throws Exception {\n        n = nextInt();\n        k = nextInt();\n        wall[0] = nextString();\n        wall[1] = nextString();\n        System.out.println(calc() ? \"YES\" : \"NO\");\n    }\n    /*\n     ***********************************************************************\n     */\n    PrintWriter writer;\n    BufferedReader reader;\n\n    StringTokenizer stk;\n\n    void run()throws Exception {\n        stk = null;\n        reader = new BufferedReader(new InputStreamReader(System.in));\n        writer = new PrintWriter(System.out);\n        solve();\n        reader.close();\n        writer.close();\n    }\n    int nextInt()throws Exception {\n        return Integer.parseInt(nextToken());\n    }\n    long nextLong()throws Exception {\n        return Long.parseLong(nextToken());\n    }\n    double nextDouble()throws Exception {\n        return Double.parseDouble(nextToken());\n    }\n    String nextString()throws Exception {\n        return nextToken();\n    }\n    String nextLine()throws Exception {\n        return reader.readLine();\n    }\n    String nextToken()throws Exception {\n        if(stk == null || !stk.hasMoreTokens()) {\n            stk = new StringTokenizer(nextLine());\n            return nextToken();\n        }\n        return stk.nextToken();\n    }\n    public class Pair<T, U> implements Comparable<Pair<T, U>> {\n        T x;\n        U y;\n        public Pair (){}\n        public Pair (T x, U y) {\n            this.x = x;\n            this.y = y;\n        }\n        public Pair<T, U> makePair(T x, U y) {\n            this.x = x;\n            this.y = y;\n            return this;\n        }\n        @Override\n        public int compareTo(Pair<T, U> o) {\n            int cmp = compare(this.x, o.x);\n            return (cmp == 0) ? compare(this.y, o.y) : cmp;\n        }\n        private int compare(Object o1, Object o2) {\n            return (o1 == null) ? (o2 == null) ? 0 : -1 : (o2 == null) ? +1 : ((Comparable) o1).compareTo(o2);\n        }\n        @Override\n        public String toString() {\n            return this.x.toString() + \" \" + this.y.toString();\n        }\n    };\n    public static void main(String[]args) throws Exception {\n        new Main().run();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, k;\n  cin >> n >> k;\n  vector<int> dx = {0, 0, 1};\n  vector<int> dy = {1, -1, k};\n  vector<vector<bool> > wall(2);\n  vector<vector<bool> > visited(2);\n  string line;\n  for (int i = 0; i < 2; i++) {\n    cin >> line;\n    for (int j = 0; j < n; j++) {\n      if (line[j] == '-')\n        wall[i].push_back(true);\n      else\n        wall[i].push_back(false);\n    }\n  }\n  visited[0].resize(n);\n  visited[1].resize(n);\n  queue<pair<pair<int, int>, int> > q;\n  q.push({{0, 0}, 0});\n  visited[0][0] = true;\n  while (!q.empty()) {\n    int side = q.front().first.first;\n    int h = q.front().first.second;\n    int d = q.front().second;\n    q.pop();\n    for (int i = 0; i < 3; i++) {\n      int ns = (side + dx[i]) % 2;\n      int nh = h + dy[i];\n      if (d + 1 > nh) continue;\n      if (nh >= n) {\n        cout << \"YES\" << endl;\n        return 0;\n      }\n      if (nh < 0) continue;\n      if (!wall[ns][nh]) continue;\n      if (visited[ns][nh]) continue;\n      visited[ns][nh] = true;\n      q.push({{ns, nh}, d + 1});\n    }\n  }\n  cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nqueue<pair<long long, long long> > q;\nint main() {\n  char ar[2][100004];\n  long long use[2][100004];\n  long long i, n, k, c, r;\n  scanf(\"%lld%lld\", &n, &k);\n  for (i = 0; i < 2; i++) scanf(\"%s\", ar[i]);\n  memset(use, -1, sizeof(use));\n  use[0][0] = 0;\n  q.push(make_pair(0, 0));\n  while (!q.empty()) {\n    pair<long long, long long> cur = q.front();\n    q.pop();\n    r = cur.first;\n    c = cur.second;\n    if (c < use[r][c]) continue;\n    if (c + k >= n) {\n      printf(\"YES\\n\");\n      return 0;\n    }\n    if (c < n - 1 && use[r][c + 1] == -1 && ar[r][c + 1] == '-') {\n      q.push(make_pair(r, c + 1));\n      use[r][c + 1] = use[r][c] + 1;\n    }\n    if (c && use[r][c - 1] == -1 && ar[r][c - 1] == '-') {\n      q.push(make_pair(r, c - 1));\n      use[r][c - 1] = use[r][c] + 1;\n    }\n    if (ar[!r][c + k] == '-' && use[!r][c + k] == -1) {\n      q.push(make_pair(!r, c + k));\n      use[!r][c + k] = use[r][c] + 1;\n    }\n  }\n  printf(\"NO\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class ProblemB {\n\t\n\tstatic class State implements Comparable<State> {\n\t\tint row;\n\t\tint col;\n\t\tint time;\n\t\tState(int r, int c, int t) {\n\t\t\trow = r;\n\t\t\tcol = c;\n\t\t\ttime = t;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(State arg0) {\n\t\t\treturn time - arg0.time;\n\t\t}\n\t}\n\t\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner in = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tint n = in.nextInt();\n\t\tint k = in.nextInt();\n\t\tchar[][] map = {\n\t\t\t(in.next() + \"-\").toCharArray(),\n\t\t\t(in.next() + \"-\").toCharArray()\n\t\t};\n\t\t\n\t\tboolean reached = false;\n\t\t\n\t\tint[][] dp = new int[2][n+1];\n\t\tArrays.fill(dp[0], Integer.MAX_VALUE);\n\t\tArrays.fill(dp[1], Integer.MAX_VALUE);\n\t\tdp[0][0] = 0;\n\t\tQueue<State> q = new PriorityQueue<State>();\n\t\tq.add(new State(0, 0, 0));\n\t\twhile (q.size() >= 1) {\n\t\t\tState st = q.poll();\n\t\t\t// go up\n\t\t\tif (st.row+1 >= n || map[st.col][st.row+1] == '-') {\n\t\t\t\tif (st.row+1 >= n) {\n\t\t\t\t\treached = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (dp[st.col][st.row+1] > st.time+1) {\n\t\t\t\t\tdp[st.col][st.row+1] = st.time+1;\n\t\t\t\t\tq.add(new State(st.row+1, st.col, st.time+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// go down\n\t\t\tif (st.time+1 <= st.row-1 && map[st.col][st.row-1] == '-') {\n\t\t\t\tif (dp[st.col][st.row-1] > st.time+1) {\n\t\t\t\t\tdp[st.col][st.row-1] = st.time+1;\n\t\t\t\t\tq.add(new State(st.row-1, st.col, st.time+1));\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// jump\n\t\t\tif (st.row+k >= n || map[1-st.col][st.row+k] == '-') {\n\t\t\t\tif (st.row+k >= n) {\n\t\t\t\t\treached = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (dp[1-st.col][st.row+k] > st.time+1) {\n\t\t\t\t\tdp[1-st.col][st.row+k] = st.time+1;\n\t\t\t\t\tq.add(new State(st.row+k, 1-st.col, st.time+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(reached ? \"YES\" : \"NO\");\n\t\tout.flush();\n\t}\n\t\n\n\tpublic static void debug(Object... o) {\n\t\tSystem.err.println(Arrays.deepToString(o));\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint k;\nchar lw[100001];\nchar rw[100001];\nbool get(int l, int r, int level) {\n  bool ret = false;\n  if (l >= 0) {\n    if (l >= n) {\n      ret = true;\n    } else {\n      if (lw[l] != 'X' && l >= level) {\n        lw[l] = 'X';\n        ++level;\n        if (!ret) {\n          ret = get(-1, l + k, level);\n        }\n        if (!ret) {\n          ret = get(l + 1, -1, level);\n        }\n        if (!ret) {\n          ret = get(l - 1, -1, level);\n        }\n      }\n    }\n  } else if (r >= 0) {\n    if (r >= n) {\n      ret = true;\n    } else {\n      if (rw[r] != 'X' && r >= level) {\n        rw[r] = 'X';\n        ++level;\n        if (!ret) {\n          ret = get(r + k, -1, level);\n        }\n        if (!ret) {\n          ret = get(-1, r + 1, level);\n        }\n        if (!ret) {\n          ret = get(-1, r - 1, level);\n        }\n      }\n    }\n  }\n  return ret;\n}\nint main() {\n  cin >> n;\n  cin >> k;\n  for (int i = 0; i < n; i++) {\n    cin >> lw[i];\n  }\n  for (int i = 0; i < n; i++) {\n    cin >> rw[i];\n  }\n  bool res = get(0, -1, 0);\n  cout << (res ? \"YES\" : \"NO\") << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline void mini(T &a, T b) {\n  if (b < a) a = b;\n}\ntemplate <class T>\ninline void maxi(T &a, T b) {\n  if (b > a) a = b;\n}\nstring mapa[2];\nint d[2][100005];\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\nint w, n, k;\nbool can = false, vis[2][100005];\nint dfs(int x, int y, int l) {\n  vis[x][y] = true;\n  for (int i = 0; i < 4; i++) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if (nx >= 0 && nx < 2) {\n      if (ny >= n) {\n        can = true;\n        return 0;\n      }\n      if (ny > l && mapa[nx][ny] == '-' && !vis[nx][ny]) dfs(nx, ny, l + 1);\n    }\n  }\n}\nint main() {\n  string aux;\n  scanf(\"%d %d\\n\", &n, &k);\n  getline(cin, mapa[0]);\n  getline(cin, mapa[1]);\n  dy[0] = dy[1] = k;\n  dfs(0, 0, 0);\n  if (can)\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nstring ss[2];\nint d[2][100005];\nset<pair<int, pair<int, int> > > s;\nint ans = 1e9;\nvoid upd(int x, int y, int z) {\n  if (y < 1) return;\n  if (y > n) {\n    ans = min(ans, z);\n    return;\n  }\n  if (ss[x][y] == 'X') return;\n  if (d[x][y] < z) return;\n  s.erase({d[x][y], {x, y}});\n  d[x][y] = z;\n  s.insert({d[x][y], {x, y}});\n  return;\n}\nint main(int argc, const char* argv[]) {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  cin >> ss[0] >> ss[1];\n  ss[0] = \"#\" + ss[0];\n  ss[1] = \"#\" + ss[1];\n  for (int i = 1; i <= n; ++i) {\n    d[0][i] = d[1][i] = 1e9;\n  }\n  d[0][1] = 0;\n  s.insert({0, {0, 1}});\n  while (!s.empty()) {\n    pair<int, pair<int, int> > cur = *s.begin();\n    s.erase(s.begin());\n    if (cur.first >= cur.second.second) continue;\n    int x = cur.second.first;\n    int y = cur.second.second;\n    upd(x, y - 1, cur.first + 1);\n    upd(x, y + 1, cur.first + 1);\n    upd(1 - x, y + m, cur.first + 1);\n  }\n  if (ans < 1e9)\n    cout << \"YES\\n\";\n  else\n    cout << \"NO\\n\";\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\n\npublic class WallJumping {\n\t\n\tprivate final int k;\n\t\n\tprivate final int n;\n\t\n\tprivate final boolean[][]wallInfo;\n\t\n\tprivate final boolean[][] wallVisited;\n\t\n\tprivate final int[][] wasVisitedWithLevel;\n\t\n\tprivate WallJumping(int k, int n, boolean[][] wallInfo) {\n\t\tsuper();\n\t\tthis.k = k;\n\t\tthis.n = n;\n\t\tthis.wallInfo = wallInfo;\n\t\tthis.wallVisited = new boolean[2][n + 1];\n\t\tthis.wasVisitedWithLevel = new int[2][n + 1];\n\t\tArrays.fill(wasVisitedWithLevel[0], Integer.MAX_VALUE);\n\t\tArrays.fill(wasVisitedWithLevel[1], Integer.MAX_VALUE);\n\t}\n\n\t\n\t\n\tprivate static boolean[][] getWallInfo(Scanner in, int n) {\n\t\tboolean[][] wallInfo = new boolean[2][n + 1];\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tString s = in.next();\n\t\t\tfor (int j = 0; j < s.length(); j++) {\n\t\t\t\tif ('X' == s.charAt(j)) {\n\t\t\t\t\twallInfo[i][j + 1] = false;\n\t\t\t\t} else if ('-' == s.charAt(j)){\n\t\t\t\t\twallInfo[i][j + 1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn wallInfo;\n\t}\n\t\n\tprivate class State {\n\t\t\n\t\tint wall, position, waterLevel;\n\n\t\tprivate State(int wall, int position, int waterLevel) {\n\t\t\tsuper();\n\t\t\tthis.wall = wall;\n\t\t\tthis.position = position;\n\t\t\tthis.waterLevel = waterLevel;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\tprivate void tryToJump(int wall, int position, int waterLevel, Deque<State> jumpDeque) {\n\t\t//if (wallInfo[wall][position] && wallVisited[wall][position] == false) {\n\t\tif (wallInfo[wall][position] && wasVisitedWithLevel[wall][position] > waterLevel) {\n\t\t\tjumpDeque.addFirst(  new State(wall, position, waterLevel + 1) );\n\t\t\twasVisitedWithLevel[wall][position] = waterLevel;\n\t\t}\n\t}\n\t\n\t\t\n\tprivate boolean canJumpOut() {\n\t\tDeque<State> jumpQueue = new LinkedList<State>();\n\t\tjumpQueue.addFirst( new State(0, 1, 0));\n\t\twhile (jumpQueue.isEmpty() == false) {\n\t\t\tState state = jumpQueue.removeFirst();\n\t\t\tif (state.position > n - k) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\twallVisited[state.wall][state.position] = true;\n\t\t\t\t\n\t\t\t\ttryToJump(state.wall, state.position + 1, state.waterLevel, jumpQueue);\n\t\t\t\n\t\t\t\tif ( state.position - 1> state.waterLevel + 1) {\n\t\t\t\t\ttryToJump(state.wall, state.position - 1, state.waterLevel, jumpQueue);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttryToJump(state.wall ^ 1, state.position + k, state.waterLevel, jumpQueue);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint k = in.nextInt();\n\t\tboolean[][] wallInfo = getWallInfo(in, n);\n\t\tWallJumping jumping = new WallJumping(k, n, wallInfo);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tout.println(jumping.canJumpOut() ? \"YES\" : \"NO\");\n\t\tout.flush();\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nchar ch[2][100010];\nint dis[2][100010];\nqueue<pair<int, int> > q;\nbool isposs(int idx, int st, int tm) {\n  return ch[st][idx] == '-' && tm <= idx && dis[st][idx] == -1;\n}\nint main() {\n  memset(dis, -1, sizeof dis);\n  cin >> n >> k;\n  scanf(\"%s\", ch[0]);\n  scanf(\"%s\", ch[1]);\n  q.push(pair<int, int>(0, 0));\n  dis[0][0] = 0;\n  string res = \"NO\";\n  while (!q.empty()) {\n    pair<int, int> tmp = q.front();\n    q.pop();\n    int idx = tmp.first;\n    int st = tmp.second;\n    int tm = dis[st][idx];\n    if (idx + k >= n) {\n      res = \"YES\";\n      break;\n    }\n    if (isposs(idx - 1, st, tm + 1)) {\n      dis[st][idx - 1] = tm + 1;\n      q.push(pair<int, int>(idx - 1, st));\n    }\n    if (isposs(idx + 1, st, tm + 1)) {\n      dis[st][idx + 1] = tm + 1;\n      q.push(pair<int, int>(idx + 1, st));\n    }\n    if (isposs(idx + k, 1 - st, tm + 1)) {\n      dis[1 - st][idx + k] = tm + 1;\n      q.push(pair<int, int>(idx + k, 1 - st));\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar a[200100];\nchar b[200100];\nint n, k;\nint visit[200100];\nint visit2[200100];\nint mn = 0;\nint cal(int x, int turn, int up, int lvl) {\n  if (lvl >= x) return 0;\n  if (x > n) {\n    mn = 1;\n    return 1;\n  }\n  if (turn == 1 && x <= 100050) {\n    if (visit[x] == 1) return 0;\n  } else if (x <= 100050) {\n    if (visit2[x] == 1) return 0;\n  }\n  if (turn == 1 && x <= 100050)\n    visit[x] = 1;\n  else if (x <= 100050)\n    visit2[x] = 1;\n  int f1 = 0;\n  int f2 = 0;\n  int f3 = 0;\n  if (turn == 1) {\n    if (up == 1) {\n      if (b[x + k] != 'X') {\n        f2 = cal(x + k, 2, 3, lvl + 1);\n      }\n      if (a[x + 1] != 'X') {\n        f1 = cal(x + 1, 1, 1, lvl + 1);\n      }\n    } else if (up == 2) {\n      if (b[x + k] != 'X') {\n        f2 = cal(x + k, 2, 3, lvl + 1);\n      }\n      if (x - 1 >= 1 && a[x - 1] != 'X') {\n        f1 = cal(x - 1, 1, 2, lvl + 1);\n      }\n    } else {\n      if (b[x + k] != 'X') {\n        f3 = cal(x + k, 2, 3, lvl + 1);\n      }\n      if (a[x + 1] != 'X') {\n        f1 = cal(x + 1, 1, 1, lvl + 1);\n      }\n      if (x - 1 >= 1 && a[x - 1] != 'X') {\n        f1 = cal(x - 1, 1, 2, lvl + 1);\n      }\n    }\n  } else {\n    if (up == 1) {\n      if (a[x + k] != 'X') {\n        f2 = cal(x + k, 1, 3, lvl + 1);\n      }\n      if (b[x + 1] != 'X') {\n        f1 = cal(x + 1, 2, 1, lvl + 1);\n      }\n    } else if (up == 2) {\n      if (a[x + k] != 'X') {\n        f2 = cal(x + k, 1, 3, lvl + 1);\n      }\n      if (x - 1 >= 1 && b[x - 1] != 'X') {\n        f1 = cal(x - 1, 2, 2, lvl + 1);\n      }\n    } else {\n      if (a[x + k] != 'X') {\n        f3 = cal(x + k, 1, 3, lvl + 1);\n      }\n      if (b[x + 1] != 'X') {\n        f1 = cal(x + 1, 2, 1, lvl + 1);\n      }\n      if (x - 1 >= 1 && b[x - 1] != 'X') {\n        f1 = cal(x - 1, 2, 2, lvl + 1);\n      }\n    }\n  }\n  return (f1 | f2 | f3);\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n  }\n  for (int i = 1; i <= n; i++) {\n    cin >> b[i];\n  }\n  int ans = cal(1, 1, 3, 0);\n  if (mn)\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, i, j, k, INF = 1E9, id, x, d;\n  bool solved = false;\n  string s[2];\n  cin >> n >> k >> s[0] >> s[1];\n  vector<vector<int>> dp(2, vector<int>(n, INF));\n  queue<pair<int, int>> q;\n  q.push({0, 0});\n  dp[0][0] = 1;\n  while (!q.empty()) {\n    tie(id, x) = q.front();\n    q.pop();\n    d = dp[id][x];\n    if (x + 1 < d) continue;\n    if ((x > 0) && (dp[id][x - 1] > d + 1) && (s[id][x - 1] != 'X')) {\n      dp[id][x - 1] = d + 1;\n      q.push({id, x - 1});\n    }\n    if (x + k >= n) {\n      solved = true;\n      break;\n    }\n    if ((x < n - 1) && (dp[id][x + 1] > d + 1) && (s[id][x + 1] != 'X')) {\n      dp[id][x + 1] = d + 1;\n      q.push({id, x + 1});\n    }\n    if ((x + k < n) && (dp[1 - id][x + k] > d + 1) &&\n        (s[1 - id][x + k] != 'X')) {\n      dp[1 - id][x + k] = d + 1;\n      q.push({1 - id, x + k});\n    }\n  }\n  if (solved)\n    cout << \"YES\\n\";\n  else\n    cout << \"NO\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct rec {\n  int x, y;\n} p;\nchar a[2][100010];\nqueue<rec> q;\nint d[2][100010], n, k;\nbool bfs() {\n  memset(d, -1, sizeof(d));\n  q.push((rec){0, 1});\n  d[0][1] = 0;\n  while (q.size()) {\n    p = q.front();\n    q.pop();\n    if (p.y + k > n) return 1;\n    if (a[p.x][p.y + 1] == '-' && d[p.x][p.y + 1] == -1 &&\n        d[p.x][p.y] + 1 < p.y + 1)\n      q.push((rec){p.x, p.y + 1}), d[p.x][p.y + 1] = d[p.x][p.y] + 1;\n    if (a[p.x][p.y - 1] == '-' && d[p.x][p.y - 1] == -1 &&\n        d[p.x][p.y] + 1 < p.y - 1)\n      q.push((rec){p.x, p.y - 1}), d[p.x][p.y - 1] = d[p.x][p.y] + 1;\n    if (a[p.x ^ 1][p.y + k] == '-' && d[p.x ^ 1][p.y + k] == -1 &&\n        d[p.x][p.y] + 1 < p.y + k)\n      q.push((rec){p.x ^ 1, p.y + k}), d[p.x ^ 1][p.y + k] = d[p.x][p.y] + 1;\n  }\n  return 0;\n}\nint main() {\n  cin >> n >> k;\n  scanf(\"%s%s\", a[0] + 1, a[1] + 1);\n  if (bfs())\n    puts(\"YES\");\n  else\n    puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nbool vst[200000];\nint dist[200000];\nchar str[100010];\nint dat[200000];\nint q[210000], l, r;\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  memset(dat, 0, sizeof(dat));\n  memset(vst, 0, sizeof(vst));\n  for (int i = 0; i < 200000; ++i) dist[i] = 1000000000;\n  for (int i = 0; i <= 1; ++i) {\n    scanf(\"%s\", str);\n    for (int j = 0; j < n; ++j) dat[(j << 1) | i] = (str[j] == '-');\n  }\n  vst[0] = 1;\n  l = 1;\n  r = 1;\n  q[1] = 0;\n  dist[0] = 0;\n  while (l <= r) {\n    int now = q[l++], next;\n    next = now - 2;\n    if (((next) >= 0) && (!vst[next]) && dat[next] && (dist[now] < next / 2)) {\n      vst[next] = 1;\n      q[++r] = next;\n      dist[next] = dist[now] + 1;\n    }\n    next = now + 2;\n    if (((next) < (n << 1)) && (!vst[next]) && dat[next] &&\n        (dist[now] < next / 2)) {\n      vst[next] = 1;\n      q[++r] = next;\n      dist[next] = dist[now] + 1;\n    }\n    next = (now + (k << 1)) ^ 1;\n    if ((next >= 0) && (next < (n << 1)) && (!vst[next]) && dat[next] &&\n        (dist[now] < next / 2)) {\n      vst[next] = 1;\n      q[++r] = next;\n      dist[next] = dist[now] + 1;\n    }\n  }\n  int res = 1000000000;\n  for (int i = n - k; i < n; ++i)\n    res = min(res, min(dist[i << 1], dist[(i << 1) | 1]));\n  printf(\"%s\\n\", (res < 1000000000) ? \"YES\" : \"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "//package com.yaroslav.shlapak;\n\nimport java.util.Scanner;\n\n/**\n * Created by y.shlapak on Apr 05, 2016.\n */\n\n/*\n7 3\n---X--X\n-X--XX-\n*/\n\npublic class JumpingOnWalls {\n    static int n, k;\n    static int[][] tunnel;\n    static int[][] tunnelClone;\n    static int waterLevel = 0;\n    static boolean done = false;\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        n = scanner.nextInt();\n        k = scanner.nextInt();\n\n        tunnel = new int[n + k + 1][2];\n        tunnelClone = new int[n + k + 1][2];\n\n        String leftString = scanner.next();\n        String rightString = scanner.next();\n\n        for(int i = 0; i < leftString.length(); i++) {\n            tunnel[i][0] = leftString.charAt(i) == 'X' ? 1 : 0;\n            tunnel[i][1] = rightString.charAt(i) == 'X' ? 1 : 0;\n            //tunnelClone[i][0] = n + 1;\n            //tunnelClone[i][1] = n + 1;\n        }\n\n        /*\n        for(int i = 0; i < n; i++) {\n            System.out.print(\"\" + tunnel[i][0]);\n        }\n        System.out.println();\n        for(int i = 0; i < n; i++) {\n            System.out.print(\"\" + tunnel[i][1]);\n        }\n        System.out.println();\n        */\n\n        int level = 0;\n        int waterLevel = 0;\n        int side = 0; //left\n        int[] temp;\n        Queue queue = new Queue(n * 2);\n        moveQueue(level, waterLevel, side, queue);\n        while(!queue.isEmpty()) {\n            if(done) {\n                break;\n            }\n            temp = queue.pop();\n\n            level = temp[0];\n            side = temp[1];\n            waterLevel = temp[2];\n\n            moveQueue(level, side, waterLevel, queue);\n        }\n\n\n\n        //move(level, side, waterLevel);\n        if(done) {\n            System.out.println(\"YES\");\n        } else {\n            System.out.println(\"NO\");\n        }\n\n    }\n\n\n    private static void moveQueue(int level, int side, int waterLevel, Queue queue) {\n        //System.out.println(\"\" + level + \" \" + side);\n        if(done) {\n            return;\n        }\n\n        if(level + k > n ) {\n            done = true;\n            return;\n        }\n\n        if(tunnel[level + k][side == 0 ? 1 : 0] == 0 && tunnelClone[level + k][side == 0 ? 1 : 0] == 0) {\n            tunnelClone[level + k][side == 0 ? 1 : 0] = 1;\n            queue.push(level + k, side == 0 ? 1 : 0, waterLevel + 1);\n        }\n\n        if(tunnel[level + 1][side] == 0 && tunnelClone[level + 1][side] == 0) {\n            tunnelClone[level + 1][side] = 1;\n            queue.push(level + 1, side, waterLevel + 1);\n        }\n\n        if(level > 0 && tunnel[level - 1][side] == 0 && waterLevel + 1 <= level - 1 && tunnelClone[level - 1][side] == 0) {\n            tunnelClone[level - 1][side] = 1;\n            queue.push(level - 1, side, waterLevel + 1);\n        }\n    }\n\n\n    private static void move(int level, int side, int waterLevel) {\n        //System.out.println(\"\" + level + \" \" + side);\n        if(done) {\n            return;\n        }\n\n        if(level + k > n ) {\n            done = true;\n            return;\n        }\n\n        if(tunnel[level + k][side == 0 ? 1 : 0] == 0 && tunnelClone[level + k][side == 0 ? 1 : 0] >= waterLevel + 1) {\n            tunnelClone[level + k][side == 0 ? 1 : 0] = waterLevel + 1;\n            move(level + k, side == 0 ? 1 : 0, waterLevel + 1);\n        }\n\n        if(tunnel[level + 1][side] == 0 && tunnelClone[level + 1][side] >= waterLevel + 1) {\n            tunnelClone[level + 1][side] = waterLevel + 1;\n            move(level + 1, side, waterLevel + 1);\n        }\n\n        if((tunnel[level + k][side == 0 ? 1 : 0] != 0 && tunnel[level + 1][side] != 0) && level > 0 && tunnel[level - 1][side] == 0 && waterLevel + 1 <= level - 1 && tunnelClone[level - 1][side] >= waterLevel + 1) {\n            tunnelClone[level - 1][side] = waterLevel + 1;\n            move(level - 1, side, waterLevel + 1);\n        }\n\n    }\n\n    private static class Queue {\n        private int size;\n        private int front;\n        private int back;\n        private int[][] queue;\n\n        public Queue(int size) {\n            this.size = size;\n            queue = new int[size][3];\n            front = back = 0;\n        }\n\n        public void push(int level, int side, int waterLevel) {\n            if(back < size) {\n                queue[back][0] = level;\n                queue[back][1] = side;\n                queue[back][2] = waterLevel;\n                back++;\n            }\n        }\n\n        public int[] pop() {\n            if(front <= back) {\n                return queue[front++];\n            } else {\n                return new int[]{-1, -1, -1};\n            }\n        }\n\n        public int getSize() {\n            return this.size;\n        }\n\n        public  boolean isEmpty() {\n            return front == back;\n        }\n    }\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class main2 {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.flush();out.close();\n    }\n        static class TaskE {\n        class pair{\n        \tint p,id,d,t;pair(int a,int b,int c,int e){p=a;id=b;d=c;t=e;}\n        \tpublic String toString() {return p+\" \"+id+\" \"+d+\" \"+t;}\n        }\n         public void solve(int testNumber, InputReader in, PrintWriter out) {\t\n          int n=in.nextInt(),x=in.nextInt();\n          int a[][]= {{0,-1},{0,1},{1,x}};\n          String s[]=new String[2];\n          s[0]=in.next().trim();s[1]=in.next().trim();\n          int dis[][]=new int[2][2*n+100];int max=Integer.MAX_VALUE;\n          for(int i=0;i<2;i++)Arrays.fill(dis[i],max);\n          PriorityQueue<pair> pq=new PriorityQueue<>(new Comparator<pair>() {\n        \t  public int compare(pair p1,pair p2) {return p1.d-p2.d;}\n        \t  \n          });\n          pq.add(new pair(0,0,0,0));boolean r=false;\n          o:while(!pq.isEmpty()) {\n        \t  pair p;\n        \t  while(true) {\n        \t   p=(pair)pq.peek();\n        \t   if(dis[p.id][p.p]!=max)pq.remove(pq.peek());\n        \t   else {\n        \t\t   break;\n        \t   }\n        \t   if(pq.isEmpty())break o;\n        \t  }dis[p.id][p.p]=p.d;pq.remove(pq.peek());\n        \t  for(int i=0;i<3;i++) {\n        \t\t  int I=p.id^a[i][0],P=p.p+a[i][1];\n        \t\t  if(P>=n&&P>=p.t+1) {r=true;break o;}\n        \t\t  if(P<0)continue;\n        \t\t  if(dis[I][P]!=max)continue;//System.out.println(I+\" \"+P);\n        \t\t  if(dis[I][P]<=dis[p.id][p.p]+1||s[I].charAt(P)=='X'||P<p.t+1)continue;\n        \t\t  pq.add(new pair(P,I,dis[p.id][p.p]+1,p.t+1));\n        \t  }//System.out.println(pq);\n          }\n          if(r)out.print(\"YES\");else out.print(\"NO\");//System.out.println(C);\n         }\n    }\n    static class InputReader {\n        BufferedReader br;\n        StringTokenizer st;\n        public InputReader(InputStream stream) {\n            br = new BufferedReader(new InputStreamReader(stream));\n            st = null;\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return null;\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n\n        boolean hasMoreTokens() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return false;\n                st = new StringTokenizer(s);\n            }\n            return true;\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint toint(string s) {\n  int n;\n  istringstream is(s);\n  is >> n;\n  return n;\n}\nstring tostring(int n) {\n  stringstream is;\n  is << n;\n  return is.str();\n}\nlong long int modulo(int a, int b, int c) {\n  long long x = 1, y = a;\n  while (b > 0) {\n    if (b % 2 == 1) {\n      x = (x * y) % c;\n    }\n    y = (y * y) % c;\n    b /= 2;\n  }\n  return x % c;\n}\nlong long mulmod(long long a, long long b, long long c) {\n  long long x = 0, y = a % c;\n  while (b > 0) {\n    if (b % 2 == 1) {\n      x = (x + y) % c;\n    }\n    y = (y * 2) % c;\n    b /= 2;\n  }\n  return x % c;\n}\nint query(const vector<int> &tree, int a, int b) {\n  if (a == 0) {\n    int sum = 0;\n    for (; b >= 0; b = (b & (b + 1)) - 1) sum += tree[b];\n    return sum;\n  } else {\n    return query(tree, 0, b) - query(tree, 0, a - 1);\n  }\n}\nvoid increase(vector<int> &tree, int k, int inc) {\n  for (; k < (int)tree.size(); k |= k + 1) tree[k] += inc;\n}\ntypedef struct nn {\n  int wall;\n  int h;\n  int t;\n} node;\nqueue<node> q;\nint best[200000][3];\nint main() {\n  node tmp;\n  int n, k;\n  cin >> n;\n  cin >> k;\n  tmp.wall = 1;\n  tmp.h = 0;\n  tmp.t = 0;\n  string b[3];\n  cin >> b[1];\n  cin >> b[2];\n  int flag = 0;\n  int i;\n  for (i = 0; i < n; i++) {\n    best[i][1] = 1000000000;\n    best[i][2] = 1000000000;\n  }\n  best[0][1] = 0;\n  q.push(tmp);\n  node tmp1;\n  while (!q.empty()) {\n    tmp = q.front();\n    q.pop();\n    tmp1.t = tmp.t + 1;\n    tmp1.wall = tmp.wall;\n    tmp1.h = tmp.h + 1;\n    if (tmp1.h < n && best[tmp1.h][tmp1.wall] > best[tmp.h][tmp.wall] + 1 &&\n        b[tmp1.wall][tmp1.h] != 'X' && tmp1.h >= tmp1.t) {\n      q.push(tmp1);\n      best[tmp1.h][tmp1.wall] = best[tmp.h][tmp.wall] + 1;\n    }\n    if (tmp1.h >= n && tmp1.h >= tmp1.t) {\n      flag = 1;\n      break;\n    }\n    tmp1.h = tmp.h - 1;\n    if (tmp1.h >= 0 && tmp1.h < n && b[tmp1.wall][tmp1.h] != 'X' &&\n        best[tmp1.h][tmp1.wall] > best[tmp.h][tmp.wall] && tmp1.h >= tmp1.t) {\n      q.push(tmp1);\n      best[tmp1.h][tmp1.wall] = best[tmp.h][tmp.wall] + 1;\n    }\n    if (tmp1.h >= n && tmp1.h >= tmp1.t) {\n      flag = 1;\n      break;\n    }\n    if (tmp.wall == 1)\n      tmp1.wall = 2;\n    else\n      tmp1.wall = 1;\n    tmp1.h = tmp.h + k;\n    if (tmp1.h < n && b[tmp1.wall][tmp1.h] != 'X' && tmp1.h >= tmp1.t &&\n        best[tmp1.h][tmp1.wall] > best[tmp.h][tmp.wall] + 1) {\n      q.push(tmp1);\n      best[tmp1.h][tmp1.wall] = best[tmp.h][tmp.wall] + 1;\n    }\n    if (tmp1.h >= n && tmp1.h >= tmp1.t) {\n      flag = 1;\n      break;\n    }\n  }\n  if (flag == 0)\n    printf(\"NO\\n\");\n  else\n    printf(\"YES\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nbool dd[100009][2];\nstring s[2];\nqueue<tuple<int, int, int>> q;\nvoid xl() {\n  cin >> n >> k;\n  cin >> s[0] >> s[1];\n  s[0] = '#' + s[0];\n  s[1] = '#' + s[1];\n  q.push({1, 0, 0});\n  dd[1][0] = 1;\n  while (q.size()) {\n    auto p = q.front();\n    q.pop();\n    int x, y, z;\n    tie(x, y, z) = p;\n    if (x + k > n) {\n      cout << \"YES\" << endl;\n      return;\n    }\n    if (x > 1 && dd[x - 1][y] == 0 && s[y][x - 1] == '-') {\n      if (x - 1 > z + 1) {\n        dd[x - 1][y] = 1;\n        q.push({x - 1, y, z + 1});\n      }\n    }\n    if (x < n && dd[x + 1][y] == 0 && s[y][x + 1] == '-') {\n      dd[x + 1][y] = 1;\n      q.push({x + 1, y, z + 1});\n    }\n    if (x + k <= n && dd[x + k][1 - y] == 0 && s[1 - y][x + k] == '-') {\n      dd[x + k][1 - y] = 1;\n      q.push({x + k, 1 - y, z + 1});\n    }\n  }\n  cout << \"NO\" << endl;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  xl();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct pos {\n  int h, id, t;\n};\nqueue<pos> q;\nint n, k, pd[100005][2];\nstring l, r;\nint main() {\n  cin >> n >> k >> l >> r;\n  for (int i = 1; i <= n; i++) {\n    if (l[i - 1] == 'X') pd[i][0] = 1;\n    if (r[i - 1] == 'X') pd[i][1] = 1;\n  }\n  q.push((pos){1, 0, 0}), pd[1][0] = 1;\n  while (!q.empty()) {\n    pos t = q.front(), nw;\n    q.pop();\n    nw = t;\n    nw.h--;\n    nw.t++;\n    if (nw.h > 0 && !pd[nw.h][nw.id] && nw.h > nw.t)\n      pd[nw.h][nw.id] = 1, q.push(nw);\n    nw = t;\n    nw.h++;\n    nw.t++;\n    if (nw.h > n) cout << \"YES\", exit(0);\n    if (!pd[nw.h][nw.id] && nw.h > nw.t) pd[nw.h][nw.id] = 1, q.push(nw);\n    nw = t;\n    nw.h += k;\n    nw.id = !nw.id;\n    nw.t++;\n    if (nw.h > n) cout << \"YES\", exit(0);\n    if (!pd[nw.h][nw.id] && nw.h > nw.t) pd[nw.h][nw.id] = 1, q.push(nw);\n  }\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 2e5 + 5;\nlong long n, k;\nstring s[2];\nmap<pair<long long, long long>, long long> dis, vis;\nlong long bfs() {\n  queue<pair<long long, long long> > q;\n  q.push(make_pair(0LL, 0LL));\n  dis[make_pair(0LL, 0LL)] = 0;\n  vis[make_pair(0LL, 0LL)] = 1;\n  pair<long long, long long> p;\n  while (!q.empty()) {\n    p = q.front();\n    q.pop();\n    if (!vis[make_pair(p.first, p.second + 1)] &&\n        s[p.first][p.second + 1] == '-' && dis[p] + 1 <= p.second + 1) {\n      q.push(make_pair(p.first, p.second + 1));\n      vis[make_pair(p.first, p.second + 1)] = 1;\n      dis[make_pair(p.first, p.second + 1)] = dis[p] + 1;\n      if (p.second + 1 >= n) return cout << \"YES\", 0;\n    }\n    if (p.second - 1 >= 0 && !vis[make_pair(p.first, p.second - 1)] &&\n        s[p.first][p.second - 1] == '-' && dis[p] + 1 <= p.second - 1) {\n      q.push(make_pair(p.first, p.second - 1));\n      vis[make_pair(p.first, p.second - 1)] = 1;\n      dis[make_pair(p.first, p.second - 1)] = dis[p] + 1;\n      if (p.second - 1 >= n) return cout << \"YES\", 0;\n    }\n    if (!vis[make_pair(abs(p.first - 1), p.second + k)] &&\n        s[abs(p.first - 1)][p.second + k] == '-' &&\n        dis[p] + 1 <= p.second + k) {\n      q.push(make_pair(abs(p.first - 1), p.second + k));\n      vis[make_pair(abs(p.first - 1), p.second + k)] = 1;\n      dis[make_pair(abs(p.first - 1), p.second + k)] = dis[p] + 1;\n      if (p.second + k >= n) return cout << \"YES\", 0;\n    }\n  }\n  return cout << \"NO\", 0;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n  cin >> n >> k;\n  cin >> s[0] >> s[1];\n  for (long long i = 0; i < 100002; i++) {\n    s[0] += '-';\n    s[1] += '-';\n  }\n  bfs();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar G[2][100000];\nbool visited[2][100000];\nint n, k, level = 0;\nbool dfs(int i, int j) {\n  if (j > n) return true;\n  if (G[i][j] == 'X' || j < level || visited[i][j]) return false;\n  visited[i][j] = true;\n  level++;\n  bool f = dfs(i, j - 1) || dfs(1 - i, j + k) || dfs(i, j + 1);\n  level--;\n  return f;\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < n; j++) cin >> G[i][j];\n  n--;\n  if (dfs(0, 0))\n    cout << \"YES\";\n  else\n    cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint best[2][100010];\nchar s[2][100010];\nqueue<int> qu;\nint main() {\n  int i, j, n, k, res;\n  scanf(\"%d %d \", &n, &k);\n  scanf(\"%s %s \", s[0], s[1]);\n  memset(best, 9, sizeof(best));\n  best[0][0] = 0;\n  qu.push(0);\n  qu.push(0);\n  res = 0;\n  while (!res && !qu.empty()) {\n    i = qu.front();\n    qu.pop();\n    j = qu.front();\n    qu.pop();\n    if (j + k >= n) res = 1;\n    if (j + 1 < n) {\n      if (s[i][j + 1] == '-' && best[i][j + 1] > best[i][j] + 1) {\n        best[i][j + 1] = best[i][j] + 1;\n        if (best[i][j + 1] - 1 < j + 1) {\n          qu.push(i);\n          qu.push(j + 1);\n        }\n      }\n    }\n    if (j) {\n      if (s[i][j - 1] == '-' && best[i][j - 1] > best[i][j] + 1) {\n        best[i][j - 1] = best[i][j] + 1;\n        if (best[i][j - 1] - 1 < j - 1) {\n          qu.push(i);\n          qu.push(j - 1);\n        }\n      }\n    }\n    if (j + k < n) {\n      if (s[1 - i][j + k] == '-' && best[1 - i][j + k] > best[i][j] + 1) {\n        best[1 - i][j + k] = best[i][j] + 1;\n        if (best[1 - i][j + k] - 1 < j + k) {\n          qu.push(1 - i);\n          qu.push(j + k);\n        }\n      }\n    }\n  }\n  if (res)\n    puts(\"YES\");\n  else\n    puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "import sys\nfrom collections import deque\nn, k = map(int, sys.stdin.readline().split())\nw = sys.stdin.readlines()\nque = deque()\nmemo = [[-1] * len(w[0]), [-1] * len(w[0])]\nmemo[0][0] = 0\nque.append((0, 0, 0))\nwhile len(que):\n\tpos, t, side = que.popleft()\n\tcand = [(pos + 1, t + 1, side), (pos - 1, t + 1, side), (pos + k, t + 1, 1 - side)]\n\tfor c in cand:\n\t\tif c[0] < c[1]: continue\n\t\tif c[0] >= n:\n\t\t\tprint \"YES\"\n\t\t\tsys.exit(0)\n\t\tif w[c[2]][c[0]] == 'X' or memo[c[2]][c[0]] != -1: continue\n\t\tmemo[c[2]][c[0]] = c[1]\n\t\tque.append(c)\nprint \"NO\"\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[4][210000];\nbool b[4][210000], mas[4][210000];\nint n, k;\nchar s[100100];\nint inf = -100000000;\nint rec(int x, int y) {\n  if (b[x][y] == 1) return dp[x][y];\n  b[x][y] = 1;\n  if (mas[x][y] == 1) {\n    dp[x][y] = inf;\n    return inf;\n  }\n  if (y == 0) {\n    dp[x][y] = inf;\n    return inf;\n  }\n  dp[x][y] = inf;\n  dp[x][y] = max(dp[x][y], rec(x, y - 1));\n  if (y + 1 <= n) dp[x][y] = max(dp[x][y], rec(x, y + 1) - 2);\n  int z;\n  if (x == 1)\n    z = 2;\n  else\n    z = 1;\n  if (y >= k) dp[x][y] = max(dp[x][y], rec(z, y - k) + k - 1);\n  if (dp[x][y] <= 0) dp[x][y] = inf;\n  return dp[x][y];\n}\nint main() {\n  cin >> n >> k;\n  scanf(\"%s\", s);\n  for (int i = 0; i < n; i++) {\n    mas[1][i + 1] = (s[i] == 'X');\n  }\n  dp[1][1] = 1;\n  b[1][1] = 1;\n  scanf(\"%s\", s);\n  for (int i = 0; i < n; i++) {\n    mas[2][i + 1] = (s[i] == 'X');\n  }\n  for (int i = n + 1; i <= n + k; i++) {\n    if (rec(1, i) > 0) {\n      cout << \"YES\" << endl;\n      return 0;\n    }\n    if (rec(2, i) > 0) {\n      cout << \"YES\" << endl;\n      return 0;\n    }\n  }\n  cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct state {\n  int wall, ht, t;\n};\nint N, K;\nstring W[2];\nbool seen[2][100001];\nint main() {\n  cin >> N >> K;\n  cin >> W[0] >> W[1];\n  queue<state> Q;\n  {\n    state start = {0, 0, 0};\n    Q.push(start);\n    seen[0][0] = 1;\n  }\n  while (Q.size()) {\n    state R = Q.front();\n    Q.pop();\n    if (R.ht >= N - K) {\n      cout << \"YES\\n\";\n      return 0;\n    }\n    if (R.ht > 0 && W[R.wall][R.ht - 1] == '-' && R.ht - 1 >= R.t + 1) {\n      state tmp = {R.wall, R.ht - 1, R.t + 1};\n      if (!seen[R.wall][R.ht - 1]) {\n        seen[R.wall][R.ht - 1] = 1;\n        Q.push(tmp);\n      }\n    }\n    if (R.ht < N - 1 && W[R.wall][R.ht + 1] == '-') {\n      state tmp = {R.wall, R.ht + 1, R.t + 1};\n      if (!seen[R.wall][R.ht + 1]) {\n        seen[R.wall][R.ht + 1] = 1;\n        Q.push(tmp);\n      }\n    }\n    if (R.ht + K < N && W[1 - R.wall][R.ht + K] == '-') {\n      state tmp = {1 - R.wall, R.ht + K, R.t + 1};\n      if (!seen[1 - R.wall][R.ht + K]) {\n        seen[1 - R.wall][R.ht + K] = 1;\n        Q.push(tmp);\n      }\n    }\n  }\n  cout << \"NO\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, k;\n  queue<pair<int, int> > que;\n  vector<string> cnt;\n  cin >> n >> k;\n  for (int i = 0; i < 2; i++) {\n    string a;\n    cin >> a;\n    cnt.push_back(a);\n  }\n  int dx[4] = {0, 0, -1, 1};\n  int dy[4] = {1, -1, k, k};\n  int sx = 0, sy = 0;\n  que.push(pair<int, int>(sx, sy));\n  int map[2][100000];\n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < 100000; j++) map[i][j] = 10000;\n  }\n  map[sx][sy] = 0;\n  int water;\n  while (que.size()) {\n    pair<int, int> p = que.front();\n    water = map[p.first][p.second];\n    que.pop();\n    if ((water > p.second)) {\n      continue;\n    }\n    if (p.second + k >= n) {\n      cout << \"YES\" << endl;\n      return 0;\n    }\n    for (int i = 0; i < 4; i++) {\n      int nx = p.first + dx[i], ny = p.second + dy[i];\n      if ((ny >= n) || (nx < 2 && nx >= 0 && ny >= 0 && cnt[nx][ny] == '-' &&\n                        map[nx][ny] == 10000)) {\n        map[nx][ny] = map[p.first][p.second] + 1;\n        que.push(pair<int, int>(nx, ny));\n      }\n    }\n  }\n  cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\n\n\npublic class JumpOnWalls {\n\tstatic boolean[][] visited;\n\tstatic String[] walls;\n\tstatic int k,n;\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(br.readLine());\n\t\tn=Integer.parseInt(st.nextToken());\n\t\tk=Integer.parseInt(st.nextToken());\n\t\twalls=new String[2];\n\t\twalls[0]=br.readLine();\n\t\twalls[1]=br.readLine();\n\t\tvisited=new boolean[2][n];\n\t\tif (loop())\n\t\t\tSystem.out.println(\"YES\");\n\t\telse\n\t\t\tSystem.out.println(\"NO\");\n\t}\n\tpublic static boolean loop(){\n\t\tPriorityQueue<Info> pq=new PriorityQueue<Info>();\n\t\tpq.add(new Info(0,0,0));\n\t\twhile (!pq.isEmpty()){\n\t\t\tInfo info=pq.poll();\n\t\t\tif (info.y<info.h) continue;\n\t\t\tif (info.y>=n) return true;\n\t\t\tif (visited[info.x][info.y]) continue;\n\t\t\tvisited[info.x][info.y]=true;\n\t\t\tchar c=walls[info.x].charAt(info.y);\n\t\t\tif (c=='X') continue;\n\t\t\tpq.add(new Info(info.x,info.y+1,info.h+1));\n\t\t\tpq.add(new Info(info.x,info.y-1,info.h+1));\n\t\t\tpq.add(new Info((info.x+1)%2,info.y+k,info.h+1));\n\t\t}\n\t\treturn false;\n\t}\n}\nclass Info implements Comparable<Info>{\n\tint x,y,h;\n\tpublic Info (int a,int b,int c){\n\t\tx=a;y=b;h=c;\n\t}\n\t@Override\n\tpublic String toString(){\n\t\treturn \"(\"+x+\",\"+y+\",\"+h+\")\";\n\t}\n\t@Override\n\tpublic int compareTo(Info o) {\n\t\treturn h-o.h;\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 100010;\nstruct El {\n  int w, h, dist;\n  El(int w_, int h_, int dist_) : w(w_), h(h_), dist(dist_) {}\n  bool operator<(const El& o) const { return dist > o.dist; }\n};\nint main() {\n  int n, k;\n  cin >> n >> k;\n  string walls[2];\n  cin >> walls[0] >> walls[1];\n  walls[0] += '-';\n  walls[1] += '-';\n  int dist[2][MAX_N];\n  memset(dist, 1, sizeof(dist));\n  priority_queue<El> pq;\n  pq.push(El(0, 0, 0));\n  while (!pq.empty()) {\n    El el = pq.top();\n    pq.pop();\n    if (dist[el.w][el.h] <= el.dist) continue;\n    if (el.dist > el.h) continue;\n    dist[el.w][el.h] = el.dist;\n    int up = min(n, el.h + 1);\n    if (walls[el.w][up] == '-') pq.push(El(el.w, up, el.dist + 1));\n    if (el.h > 0 && walls[el.w][el.h - 1] == '-')\n      pq.push(El(el.w, el.h - 1, el.dist + 1));\n    int jump = min(n, el.h + k);\n    if (walls[el.w ^ 1][jump] == '-') pq.push(El(el.w ^ 1, jump, el.dist + 1));\n  }\n  if (min(dist[0][n], dist[1][n]) <= 10 * n)\n    cout << \"YES\\n\";\n  else\n    cout << \"NO\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<long long, long long>;\nconst long long N = 1e6 + 7;\nlong long n, k, sp = N;\nchar s[2][N];\nbool vis[2][N];\nlong long dist[2][N];\nstruct state {\n  long long id, seg, water;\n} t;\nbool go(long long id, long long seg, long long water) {\n  if (seg == -1) return 0;\n  if (vis[id][seg] || s[id][seg] == 'X' || seg < water)\n    return 0;\n  else\n    return 1;\n}\nvoid bfs() {\n  queue<state> q;\n  t = {0, 0, 0};\n  q.emplace(t);\n  vis[0][0] = 1;\n  dist[0][0] = 0;\n  while (!q.empty()) {\n    state v = q.front();\n    q.pop();\n    long long id = v.id, seg = v.seg, water = v.water;\n    long long idn, segn, watern;\n    idn = id, segn = seg + 1, watern = water + 1;\n    if (go(idn, segn, watern)) {\n      dist[idn][segn] = dist[id][seg] + 1;\n      if (segn >= n) {\n        sp = dist[idn][segn];\n        return;\n      }\n      vis[idn][segn] = 1;\n      t = {idn, segn, watern};\n      q.emplace(t);\n    }\n    idn = id, segn = seg - 1;\n    if (go(idn, segn, watern)) {\n      dist[idn][segn] = dist[id][seg] + 1;\n      if (segn >= n) {\n        sp = dist[idn][segn];\n        return;\n      }\n      vis[idn][segn] = 1;\n      t = {idn, segn, watern};\n      q.emplace(t);\n    }\n    idn = 1 ^ id, segn = seg + k;\n    if (go(idn, segn, watern)) {\n      dist[idn][segn] = dist[id][seg] + 1;\n      if (segn >= n) {\n        sp = dist[idn][segn];\n        return;\n      }\n      vis[idn][segn] = 1;\n      t = {idn, segn, watern};\n      q.emplace(t);\n    }\n  }\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> k;\n  for (long long i = 0; i < 2; ++i) {\n    cin >> s[i];\n  }\n  bfs();\n  cout << (sp <= n ? \"YES\" : \"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nchar wall[2][100000];\nbool dfs(int x, int y, int h) {\n  if (y >= n) return true;\n  if (y < 0 || y <= h) return false;\n  if (wall[x][y] == 'X') return false;\n  wall[x][y] = 'X';\n  if (dfs(1 - x, y + k, h + 1)) return true;\n  if (dfs(x, y + 1, h + 1)) return true;\n  if (dfs(x, y - 1, h + 1)) return true;\n  return false;\n}\nint main() {\n  while (cin >> n >> k) {\n    for (int i = 0; i < 2; i++) cin >> wall[i];\n    if (dfs(0, 0, -1))\n      cout << \"YES\" << endl;\n    else\n      cout << \"NO\" << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nstring s[2];\nint height[100000][2];\nvoid solve() {\n  memset(height, 0x3f, sizeof(height));\n  queue<pair<int, int>> q;\n  q.push({0, 0});\n  height[0][0] = -1;\n  while (!q.empty()) {\n    int p = q.front().first, side = q.front().second;\n    int w = height[p][side];\n    q.pop();\n    if (p + k >= n) {\n      cout << \"YES\";\n      exit(0);\n    }\n    if (p - 1 >= 0 && height[p - 1][side] > 1000000 && s[side][p - 1] == '-' &&\n        w + 1 < p - 1) {\n      q.push({p - 1, side});\n      height[p - 1][side] = w + 1;\n    }\n    if (height[p + 1][side] > 1000000 && s[side][p + 1] == '-' &&\n        w + 1 < p + 1) {\n      q.push({p + 1, side});\n      height[p + 1][side] = w + 1;\n    }\n    if (height[p + k][side ^ 1] > 1000000 && s[side ^ 1][p + k] == '-' &&\n        w + 1 < p + k) {\n      q.push({p + k, side ^ 1});\n      height[p + k][side ^ 1] = w + 1;\n    }\n  }\n  cout << \"NO\";\n  exit(0);\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> k;\n  cin >> s[0] >> s[1];\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n\npublic class cf198b {\n  public static void main(String[] args) {\n    FastIO in = new FastIO(), out = in;\n    int n = in.nextInt();\n    int k = in.nextInt();\n    char[][] v = new char[2][];\n    for(int i=0; i<2; i++) \n      v[i] = in.next().trim().toCharArray();\n    int[][] dist = new int[2][n];\n    int oo = 987654321;\n    for(int[] x : dist) Arrays.fill(x, oo);\n    dist[0][0] = 0;\n    ArrayDeque<Integer> q = new ArrayDeque<Integer>();\n    q.add(0); q.add(0);\n    int[] dx = {0,0,1}, dy = {-1,1,k};\n    int ans = oo;\n    while(!q.isEmpty()) {\n      int cx = q.poll();\n      int cy = q.poll();\n      for(int i=0; i<dx.length; i++) {\n        int nx = (cx+dx[i])%2;\n        int ny = cy+dy[i];\n        int nd = dist[cx][cy]+1;\n        if(ny < nd) continue;\n        if(ny >= n) {\n          ans = Math.min(ans,nd);\n          continue;\n        }\n        if(v[nx][ny] == 'X') continue;\n        if(dist[nx][ny] <= nd) continue;\n        dist[nx][ny] = nd;\n        q.add(nx);\n        q.add(ny);\n      }\n    }\n    if(ans >= oo) out.println(\"NO\");\n    else out.println(\"YES\");\n    out.close();\n  }\n  static class FastIO extends PrintWriter {\n    BufferedReader br;\n    StringTokenizer st;\n    \n    public FastIO() {\n      this(System.in,System.out);\n    }\n    public FastIO(InputStream in, OutputStream out) {\n      super(new BufferedWriter(new OutputStreamWriter(out)));\n      br = new BufferedReader(new InputStreamReader(in));\n      scanLine();\n    }\n    public void scanLine() {\n      try {\n        st = new StringTokenizer(br.readLine().trim());\n      } catch(Exception e) {\n        throw new RuntimeException(e.getMessage());\n      }\n    }\n    public int numTokens() {\n      if(!st.hasMoreTokens()) {\n        scanLine();\n        return numTokens();\n      }\n      return st.countTokens();\n    }\n    public String next() {\n      if(!st.hasMoreTokens()) {\n        scanLine();\n        return next();\n      }\n      return st.nextToken();\n    }\n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = int(1.5 * 1e7);\nconst int inf = ~0U >> 1;\nconst long long ll_inf = 1e18 + 420;\nconst double eps = 1e-4;\nconst int N = 1e6 + 7;\nconst int MAX = 2e5 + 9;\nconst int MOD = 1e9 + 7;\nconst long double pi = 3.14159265359;\nint n, k;\nbool a[10][N];\nstring s[10];\nvoid rec(int v, int u, int pos) {\n  if (s[v][u] == 'X' || u < pos || a[v][u]) {\n    return;\n  }\n  if (u + k > n) {\n    cout << \"YES\";\n    exit(0);\n  }\n  a[v][u] = 1;\n  rec((v + 1) % 2, u + k, pos + 1);\n  rec(v, u + 1, pos + 1);\n  rec(v, u - 1, pos + 1);\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  cin >> s[0] >> s[1];\n  rec(0, 0, 0);\n  cout << \"NO\";\n}\n"
        },
        {
            "language": 3,
            "solution": "n,k = map(int,input().split())\nl = input()\nr = input()\ndata = [0, ' '+l,' '+r]\ndist  = [[1000000]*100005 for _ in range(3)]\nvisited = [[False]*100005 for _ in range(3)]\ndist[1][1]=0\nvisited[1][1]=True\nqx,qy = [1],[1]\nwhile qy:\n    x,y = qx.pop(),qy.pop()\n    if dist[x][y]>=y:\n        continue\n    if x==1:\n        poss = [[1,y+1],[1,y-1],[2,y+k]]\n    else:\n        poss = [[2,y+1],[2,y-1],[1,y+k]]\n    for i,e in enumerate(poss):\n        newx,newy = e[0],e[1]\n        if newy>n:\n            print('YES')\n            from sys import exit\n            exit()\n        if 0<newy<=n and not visited[newx][newy] and data[newx][newy]=='-':\n            visited[newx][newy]=True\n            dist[newx][newy]=dist[x][y]+1\n            qx=[newx]+qx\n            qy=[newy]+qy\nprint('NO')"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint way[3][2] = {{0, 1}, {0, -1}, 1};\nchar str[2][100005];\nint n, k;\nstruct Node {\n  int x, y, step;\n  bool check() {\n    if (x >= 0 && y >= 0 && x < 2 && y < n) return true;\n  }\n} s, e, u, v;\nbool bfs() {\n  queue<Node> que;\n  bool flag[2][100005];\n  memset(flag, false, sizeof(flag));\n  flag[s.x][s.y] = true;\n  que.push(s);\n  while (!que.empty()) {\n    u = que.front();\n    que.pop();\n    for (int i = 0; i < 3; i++) {\n      v = u;\n      v.x = (v.x + way[i][0]) % 2;\n      v.y += way[i][1];\n      v.step++;\n      if (v.y >= n) return true;\n      if (v.check() && v.y >= v.step && str[v.x][v.y] == '-' &&\n          flag[v.x][v.y] == false) {\n        flag[v.x][v.y] = true;\n        que.push(v);\n      }\n    }\n  }\n  return false;\n}\nint main() {\n  while (scanf(\"%d%d\", &n, &k) != EOF) {\n    scanf(\"%s%s\", str[0], str[1]);\n    way[2][1] = k;\n    s.x = 0;\n    s.y = 0;\n    s.step = 0;\n    if (bfs())\n      printf(\"YES\\n\");\n    else\n      printf(\"NO\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int nmax = 200009;\npriority_queue<pair<int, int> > Q;\nchar s[2][nmax];\nint F[2][nmax];\nvoid go(int v, int w, int t) {\n  if (v > 0 && (F[w][v] == -1 || t < F[w][v]) && s[w][v] != 'X') {\n    if (t < v) {\n      F[w][v] = t;\n      Q.push(make_pair(-t, (v << 1) + w));\n    }\n  }\n}\nint n, k;\nint main() {\n  scanf(\"%d %d\", &n, &k);\n  scanf(\"%s\", &s[0][1]);\n  scanf(\"%s\", &s[1][1]);\n  memset(F, -1, sizeof(F));\n  F[0][1] = 0;\n  Q.push(make_pair(0, 1 << 1));\n  bool ok = false;\n  while (!Q.empty()) {\n    int v = Q.top().second;\n    int w = v & 1;\n    v >>= 1;\n    int d = -Q.top().first;\n    Q.pop();\n    if (v > n) {\n      ok = true;\n      break;\n    }\n    if (d == F[w][v]) {\n      go(v + 1, w, d + 1);\n      go(v - 1, w, d + 1);\n      go(v + k, 1 - w, d + 1);\n    }\n  }\n  if (ok)\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstring s[2];\nint n, k;\nconst int INF = 1e9 + 5, maxn = 1e5 + 5;\nbool valid(int sd, int v) { return v >= 0 && v <= n && s[sd][v] == '-'; }\nint main() {\n  cin >> n >> k;\n  cin >> s[0] >> s[1];\n  s[0] += \"-\";\n  s[1] += \"-\";\n  vector<vector<int>> d(2, vector<int>(maxn, INF));\n  queue<pair<int, int>> q;\n  d[0][0] = 0;\n  q.push({0, 0});\n  bool is = false;\n  while (!q.empty()) {\n    int v = q.front().second;\n    int sd = q.front().first;\n    q.pop();\n    if (v >= n) {\n      is = true;\n      break;\n    }\n    if (d[sd][v] > v) continue;\n    if (valid(sd, v + 1) && d[sd][v] + 1 < d[sd][v + 1]) {\n      d[sd][v + 1] = d[sd][v] + 1;\n      q.push({sd, v + 1});\n    }\n    if (valid(sd, v - 1) && d[sd][v] + 1 < d[sd][v - 1]) {\n      d[sd][v - 1] = d[sd][v] + 1;\n      q.push({sd, v - 1});\n    }\n    if (valid(sd ^ 1, min(n, v + k)) &&\n        d[sd][v] + 1 < d[sd ^ 1][min(n, v + k)]) {\n      d[sd ^ 1][min(n, v + k)] = d[sd][v] + 1;\n      q.push({sd ^ 1, min(n, v + k)});\n    }\n  }\n  if (is)\n    cout << \"YES\";\n  else\n    cout << \"NO\";\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class BFS_2 {\n\tpublic static void main(String[] args) {\n\t\tScanner util = new Scanner(System.in);\n\t\tint n = util.nextInt();\n\t\tint k = util.nextInt();\n\t\tutil.nextLine();\n\t\tboolean[][] walls = new boolean[2][n];\n\t\tfor(int i = 0; i < 2; i++) {\n\t\t\tString in = util.nextLine();\n\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t\tif(in.charAt(j) == '-')\n\t\t\t\t\twalls[i][j] = true;\n\t\t\t\telse\n\t\t\t\t\twalls[i][j] = false;\n\t\t}\n\n\t\tboolean check = false;\n\t\tQueue<Pair> queue = new LinkedList<Pair>();\n\t\tHashSet<Pair> visited = new HashSet<Pair>();\n\t\tPair origin = new Pair(0, 0);\n\t\tqueue.add(origin);\n\t\twhile(!queue.isEmpty()) {\n\t\t\tPair out = queue.remove();\n\t\t\tif(out.y < 0)\n\t\t\t\tcontinue;\n\t\t\telse if(out.y >= n) {\n\t\t\t\tcheck = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(visited.contains(out))\n\t\t\t\tcontinue;\n\t\t\t// System.out.println(out.x + \" \" + out.y + \" \" + out.height);\n\t\t\tvisited.add(out);\n\t\t\tif(!visited.contains(new Pair(out.x, out.y + 1, out.height + 1))) {\n\t\t\t\tPair toAdd = new Pair(out.x, out.y + 1, out.height + 1);\n\t\t\t\tif(toAdd.y >= n || \n\t\t\t\t\t(toAdd.y < n && walls[toAdd.x][toAdd.y] && \n\t\t\t\t\t\t!visited.contains(toAdd)))\n\t\t\t\t\tqueue.add(toAdd);\n\t\t\t}\n\t\t\tif(out.y > 0 && !visited.contains(new Pair(out.x, out.y - 1, out.height + 1))) {\n\t\t\t\tPair toAdd = new Pair(out.x, out.y - 1, out.height + 1);\n\t\t\t\tif(walls[toAdd.x][toAdd.y] && !visited.contains(toAdd) && \n\t\t\t\t\ttoAdd.height < toAdd.y)\n\t\t\t\t\tqueue.add(toAdd);\n\t\t\t}\n\t\t\tif(out.x == 1) {\n\t\t\t\tif(!visited.contains(new Pair(0, out.y + k, out.height + 1))) {\n\t\t\t\t\tPair toAdd = new Pair(0, out.y + k, out.height + 1);\n\t\t\t\t\tif(toAdd.y >= n || \n\t\t\t\t\t\t(toAdd.y < n && walls[toAdd.x][toAdd.y] && \n\t\t\t\t\t\t\t!visited.contains(toAdd)))\n\t\t\t\t\t\tqueue.add(toAdd);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(!visited.contains(new Pair(1, out.y + k, out.height + 1))) {\n\t\t\t\t\tPair toAdd = new Pair(1, out.y + k, out.height + 1);\n\t\t\t\t\tif(toAdd.y >= n || \n\t\t\t\t\t\t(toAdd.y < n && walls[toAdd.x][toAdd.y] && \n\t\t\t\t\t\t\t!visited.contains(toAdd)))\n\t\t\t\t\t\tqueue.add(toAdd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(check)\n\t\t\tSystem.out.println(\"YES\");\n\t\telse\n\t\t\tSystem.out.println(\"NO\");\n\t}\n}\nclass Pair {\n\tpublic int x, y, height;\n\tpublic Pair (int x, int y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\theight = -1;\n\t}\n\tpublic Pair (int x, int y, int z) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\theight = z;\n\t}\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif(!(obj instanceof Pair))\n\t\t\treturn false;\n\t\tPair other = (Pair)obj;\n\t\tif(other.x == x && other.y == y)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\t@Override\n\tpublic int hashCode() {\n\t\tString nah = (this.x) + \" \" + (this.y);\n\t\treturn nah.hashCode();\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);\n  long long n, k;\n  cin >> n >> k;\n  long long d[n][2];\n  string s[2];\n  cin >> s[0] >> s[1];\n  for (int i = 0; i < n; ++i) {\n    d[i][0] = d[i][1] = INT_MAX;\n  }\n  d[0][0] = 0;\n  queue<pair<long long, long long>> q;\n  q.push(make_pair(0, 0));\n  pair<long long, long long> source;\n  while (!q.empty()) {\n    source = q.front();\n    q.pop();\n    long long curr = source.first;\n    long long curr2 = source.second;\n    if ((curr + k) >= n) {\n      cout << \"YES\\n\";\n      return 0;\n    }\n    if ((curr - 1) >= 0 && s[curr2][curr - 1] == '-' &&\n        d[curr - 1][curr2] == INT_MAX && (d[curr][curr2] + 1) <= (curr - 1)) {\n      q.push(make_pair(curr - 1, curr2));\n      d[curr - 1][curr2] = d[curr][curr2] + 1;\n    }\n    if ((curr + 1) < n && s[curr2][curr + 1] == '-' &&\n        d[curr + 1][curr2] == INT_MAX && (d[curr][curr2] + 1) <= (curr + 1)) {\n      q.push(make_pair(curr + 1, curr2));\n      d[curr + 1][curr2] = d[curr][curr2] + 1;\n    }\n    if ((curr + k) < n && s[(curr2 + 1) % 2][curr + k] == '-' &&\n        d[curr + k][(curr2 + 1) % 2] == INT_MAX &&\n        (d[curr][curr2] + 1) <= (curr + k)) {\n      q.push(make_pair(curr + k, (curr2 + 1) % 2));\n      d[curr + k][(curr2 + 1) % 2] = d[curr][curr2] + 1;\n    }\n  }\n  cout << \"NO\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nchar l[100005], d[100005];\nvector<int> niz[100005 + 100005 + 1];\nbool poseceno[100005 + 100005 + 1];\nint dub[100005 + 100005 + 1];\nqueue<int> q;\nvoid bfs() {\n  q.push(0);\n  while (!q.empty()) {\n    int t = q.front();\n    if (t == 100005 + 100005) {\n      printf(\"YES\");\n      exit(0);\n    }\n    q.pop();\n    if (t % n < dub[t]) continue;\n    for (int i = 0; i < niz[t].size(); i++) {\n      if (!poseceno[niz[t][i]]) q.push(niz[t][i]);\n      dub[niz[t][i]] = dub[t] + 1;\n      poseceno[niz[t][i]] = true;\n    }\n  }\n}\nint main() {\n  scanf(\"%d %d\", &n, &k);\n  scanf(\"%s\", l);\n  scanf(\"%s\", d);\n  for (int i = 1; i < n; i++) {\n    if (!(l[i] == 'X' || l[i - 1] == 'X')) {\n      niz[i].push_back(i - 1);\n      niz[i - 1].push_back(i);\n    }\n    if (!(d[i] == 'X' || d[i - 1] == 'X')) {\n      niz[n + i].push_back(n + i - 1);\n      niz[n + i - 1].push_back(n + i);\n    }\n    int s = i - 1;\n    if (l[s] != 'X') {\n      if (s + k >= n)\n        niz[s].push_back(100005 + 100005);\n      else if (d[s + k] != 'X')\n        niz[s].push_back(n + s + k);\n    }\n    if (d[s] != 'X') {\n      if (s + k >= n)\n        niz[n + s].push_back(100005 + 100005);\n      else if (l[s + k] != 'X')\n        niz[n + s].push_back(s + k);\n    }\n  }\n  if (l[n - 1] != 'X') niz[n - 1].push_back(100005 + 100005);\n  if (d[n - 1] != 'X') niz[n + n - 1].push_back(100005 + 100005);\n  dub[0] = 0;\n  bfs();\n  printf(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint left_wall[100010];\nint right_wall[100010];\nint left_wall_steps[100010];\nint right_wall_steps[100010];\nint left_que[100010];\nint right_que[100010];\nint head_left;\nint head_right;\nint tail_left;\nint tail_right;\nint ninja_jump;\nint wall_height;\nbool ExitExist;\nint last_step;\nvoid push_left(int x) {\n  left_que[head_left] = x;\n  head_left++;\n}\nvoid push_right(int x) {\n  right_que[head_right] = x;\n  head_right++;\n}\nint pop_left() {\n  if (head_left == tail_left) return -1;\n  int res = left_que[tail_left];\n  tail_left++;\n  return res;\n}\nint pop_right() {\n  if (head_right == tail_right) return -1;\n  int res = right_que[tail_right];\n  tail_right++;\n  return res;\n}\nint main() {\n  char temp_char;\n  std::cin >> wall_height >> ninja_jump;\n  for (int i = 1; i <= wall_height; i++) {\n    std::cin >> temp_char;\n    if (temp_char == 'X')\n      left_wall[i] = 1;\n    else if (temp_char == '-')\n      left_wall[i] = 0;\n  }\n  for (int i = 1; i <= wall_height; i++) {\n    std::cin >> temp_char;\n    if (temp_char == 'X')\n      right_wall[i] = 1;\n    else if (temp_char == '-')\n      right_wall[i] = 0;\n  }\n  push_left(1);\n  left_wall_steps[1] = 1;\n  last_step = 1;\n  int curr_left = 0;\n  int curr_right = 0;\n  while (last_step < wall_height && head_left != tail_left ||\n         head_right != tail_right) {\n    curr_left = pop_left();\n    curr_right = pop_right();\n    if (last_step + ninja_jump > wall_height) {\n      last_step = wall_height;\n      continue;\n    }\n    if (curr_left != -1) {\n      if (left_wall[curr_left + 1] == 0 &&\n          left_wall_steps[curr_left + 1] == 0) {\n        push_left(curr_left + 1);\n        left_wall_steps[curr_left + 1] = left_wall_steps[curr_left] + 1;\n        if (last_step < curr_left + 1) last_step = curr_left + 1;\n      }\n      if (right_wall[curr_left + ninja_jump] == 0 &&\n          right_wall_steps[curr_left + ninja_jump] == 0) {\n        push_right(curr_left + ninja_jump);\n        right_wall_steps[curr_left + ninja_jump] =\n            left_wall_steps[curr_left] + 1;\n        if (last_step < curr_left + ninja_jump)\n          last_step = curr_left + ninja_jump;\n      }\n      if (left_wall[curr_left - 1] == 0 &&\n          left_wall_steps[curr_left - 1] == 0 &&\n          (curr_left - 1) >= left_wall_steps[curr_left] + 1) {\n        push_left(curr_left - 1);\n        left_wall_steps[curr_left - 1] = left_wall_steps[curr_left] + 1;\n      }\n    }\n    if (curr_right != -1) {\n      if (right_wall[curr_right + 1] == 0 &&\n          right_wall_steps[curr_right + 1] == 0) {\n        push_right(curr_right + 1);\n        right_wall_steps[curr_right + 1] = right_wall_steps[curr_right] + 1;\n        if (last_step < curr_right + 1) last_step = curr_right + 1;\n      }\n      if (left_wall[curr_right + ninja_jump] == 0 &&\n          left_wall_steps[curr_right + ninja_jump] == 0) {\n        push_left(curr_right + ninja_jump);\n        left_wall_steps[curr_right + ninja_jump] =\n            right_wall_steps[curr_right] + 1;\n        if (last_step < curr_right + ninja_jump)\n          last_step = curr_right + ninja_jump;\n      }\n      if (right_wall[curr_right - 1] == 0 &&\n          right_wall_steps[curr_right - 1] == 0 &&\n          (curr_right - 1) >= right_wall_steps[curr_right] + 1) {\n        push_right(curr_right - 1);\n        right_wall_steps[curr_right - 1] = right_wall_steps[curr_right] + 1;\n      }\n    }\n  }\n  if (last_step >= wall_height) {\n    std::cout << \"YES\\n\";\n  } else {\n    std::cout << \"NO\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint i, j, n, m;\nbool inside(int i, int n) { return (i >= 0 && i < n && j >= 0 && j < n); }\nconst int N = 3e5 + 5;\nbool vis[2][N];\nbool f = 0;\nstring s[2];\nvoid dfs(int i, int j, int k) {\n  if (k > j || s[i][j] == 'X' || f || vis[i][j]) return;\n  vis[i][j] = 1;\n  if (j + m >= n) {\n    f = 1;\n    return;\n  }\n  dfs((i + 1) % 2, j + m, k + 1);\n  dfs(i, j + 1, k + 1);\n  dfs(i, j - 1, k + 1);\n}\nint main() {\n  cin >> n >> m;\n  cin >> s[0] >> s[1];\n  dfs(0, 0, 0);\n  cout << (f ? \"YES\" : \"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nusing namespace std;\nconst long long MAX = 1e5 + 5;\nconst long long MAX2 = 11;\nconst int MOD = 1000000000 + 7;\nconst long long INF = 1e18;\nconst int nr[] = {1, 0, 0, -1, 1, 1, -1, -1};\nconst int nc[] = {0, 1, -1, 0, 1, -1, 1, -1};\nint n, k, nx, lr, nw, vis[2][MAX];\nchar x[2][MAX];\nqueue<pair<bool, int> > q;\nbool ans;\npair<bool, int> cur;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  for (long long j = 0; j <= 1; j++)\n    for (long long i = 1; i <= n; i++) cin >> x[j][i];\n  memset(vis, -1, sizeof vis);\n  q.push({0, 1});\n  vis[0][1] = 1;\n  while (!q.empty()) {\n    cur = q.front();\n    q.pop();\n    lr = cur.first, nw = cur.second;\n    if (nw + k > n) {\n      ans = 1;\n      break;\n    }\n    for (long long i = 1; i <= 2; i++) {\n      nx = nw + nc[i];\n      if (x[lr][nx] == '-' && vis[lr][nx] == -1 && nx > vis[lr][nw]) {\n        vis[lr][nx] = vis[lr][nw] + 1;\n        q.push({lr, nx});\n      }\n    }\n    if (x[lr ^ 1][nw + k] == '-' && vis[lr ^ 1][nw + k] == -1) {\n      vis[lr ^ 1][nw + k] = vis[lr][nw] + 1;\n      q.push({lr ^ 1, nw + k});\n    }\n  }\n  if (ans)\n    cout << \"YES\";\n  else\n    cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong f[2][100005];\nlong n, k, flag = 0;\nchar s[2][100005];\nvoid dfs(long wall, long h, long water) {\n  f[wall][h] = 1;\n  if (h + k >= n) {\n    flag = 1;\n    return;\n  }\n  if (s[!wall][h + k] != 'X' && !f[!wall][h + k]) {\n    dfs(!wall, h + k, water + 1);\n  }\n  if (s[wall][h + 1] != 'X' && !f[wall][h + 1]) {\n    dfs(wall, h + 1, water + 1);\n  }\n  if (h > 0) {\n    if (s[wall][h - 1] != 'X' && !f[wall][h - 1] && water + 1 <= h - 1) {\n      dfs(wall, h - 1, water + 1);\n    }\n  }\n}\nint main() {\n  scanf(\"%ld %ld\", &n, &k);\n  scanf(\"%s %s\", s[0], s[1]);\n  memset(f, 0, sizeof(f));\n  dfs(0, 0, 0);\n  if (flag) {\n    printf(\"YES\");\n  } else {\n    printf(\"NO\");\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nbool umin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\nbool umax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\nvector<int> adj[200009];\nchar s[200009], t[200009];\nvoid add(int u, int v) { adj[u].push_back(v); }\nint dis[200009], n, k, son;\nint flood(int x) {\n  if (x == son) return 1000000007;\n  if (x % n == 0) return n;\n  return x % n;\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  scanf(\"%s\", s + 1);\n  scanf(\"%s\", t + 1);\n  son = 2 * n + 1;\n  for (int i = 1; i <= n; i++) {\n    if (s[i] == '-' and s[i + 1] != 'X') {\n      if (i < n)\n        add(i, i + 1);\n      else\n        add(i, son);\n    }\n    if (s[i] == '-' and s[i - 1] == '-' and i > 1) add(i, i - 1);\n    if (s[i] == '-' and t[i + k] != 'X') {\n      if (i + k <= n)\n        add(i, n + i + k);\n      else\n        add(i, son);\n    }\n    if (t[i] == '-' and t[i + 1] != 'X') {\n      if (i < n)\n        add(i + n, i + n + 1);\n      else\n        add(i + n, son);\n    }\n    if (t[i] == '-' and t[i - 1] == '-' and i > 1) add(i + n, i + n - 1);\n    if (t[i] == '-' and s[i + k] != 'X') {\n      if (i + k <= n)\n        add(n + i, i + k);\n      else\n        add(n + i, son);\n    }\n  }\n  fill(dis, dis + 200009, 1000000007);\n  dis[1] = 0;\n  priority_queue<pair<int, int>, vector<pair<int, int> >,\n                 greater<pair<int, int> > >\n      q;\n  q.push(make_pair(0, 1));\n  while (!q.empty()) {\n    int u = q.top().first;\n    int nd = q.top().second;\n    q.pop();\n    if (nd == son) break;\n    if (dis[nd] != u) continue;\n    for (int i = 0; i < adj[nd].size(); i++) {\n      int to = adj[nd][i];\n      if (dis[to] > dis[nd] + 1 and dis[nd] + 1 < flood(to)) {\n        dis[to] = dis[nd] + 1;\n        q.push(make_pair(dis[to], to));\n      }\n    }\n  }\n  if (dis[son] != 1000000007)\n    printf(\"YES\\n\");\n  else\n    printf(\"NO\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.ArrayDeque;\nimport java.util.StringTokenizer;\n\npublic class D {\n  static class Node {\n    public int pile;\n    public int pos;\n\n    public Node(int pile, int pos) {\n      this.pile = pile;\n      this.pos = pos;\n    }\n  }\n\n  public static void main(String args[]) throws Exception {\n    Reader reader = new Reader();\n    reader.initConsoleReading();\n    int n = reader.nextInt();\n    int k = reader.nextInt();\n    int[][] shortestTime = new int[3][n + 2];\n    ArrayDeque<Node> q = new ArrayDeque<>();\n    for (int i = 0; i <= n + 1; i++) shortestTime[1][i] = shortestTime[2][i] = Integer.MAX_VALUE;\n    String[] pile = new String[3];\n    pile[1] = \"X\" + reader.next() + \"-\";\n    pile[2] = \"X\" + reader.next() + \"-\";\n    shortestTime[1][1] = 0;\n    Node init = new Node(1, 1);\n    q.add(init);\n    while (!q.isEmpty()) {\n      Node top = q.pop();\n      if (top.pos > n) break;\n      // go up in the same pile\n      if (shortestTime[top.pile][top.pos + 1] > shortestTime[top.pile][top.pos] + 1\n          && pile[top.pile].charAt(top.pos + 1) == '-') {\n        shortestTime[top.pile][top.pos + 1] = shortestTime[top.pile][top.pos] + 1;\n        q.add(new Node(top.pile, top.pos + 1));\n      }\n      // go down in the same pile\n      if (shortestTime[top.pile][top.pos - 1] > shortestTime[top.pile][top.pos] + 1\n          && top.pos - 1 > shortestTime[top.pile][top.pos] + 1\n          && pile[top.pile].charAt(top.pos - 1) == '-') {\n        shortestTime[top.pile][top.pos - 1] = shortestTime[top.pile][top.pos] + 1;\n        q.add(new Node(top.pile, top.pos - 1));\n      }\n      // jump\n      int p = Math.min(n + 1, top.pos + k);\n      if (shortestTime[3 - top.pile][p] > shortestTime[top.pile][top.pos] + 1 && pile[3-top.pile].charAt(p) == '-') {\n        shortestTime[3 - top.pile][p] = shortestTime[top.pile][top.pos] + 1;\n        q.add(new Node(3 - top.pile, p));\n      }\n    }\n    if (shortestTime[1][n + 1] != Integer.MAX_VALUE\n            || shortestTime[2][n + 1] != Integer.MAX_VALUE) {\n      System.out.println(\"YES\");\n    } else {\n      System.out.println(\"NO\");\n    }\n\n    reader.dispose();\n  }\n\n  /**\n   * **********************************Helper Methods Begin\n   * Here*********************************************\n   */\n  private static String reverse(String toRev) {\n    return new StringBuilder(toRev).reverse().toString();\n  }\n\n  public static class Pair<F extends Comparable<F>, S extends Comparable<S>>\n      implements Comparable<Pair<F, S>> {\n    static final int prime = 31;\n    private F first;\n    private S second;\n\n    public Pair(F f, S s) {\n      this.first = f;\n      this.second = s;\n    }\n\n    @Override\n    public int hashCode() {\n      int result = 1;\n      result = prime * result + this.first.hashCode();\n      result = prime * result + this.second.hashCode();\n      return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n      if (this == obj) return true;\n      if (obj == null) return false;\n      if (getClass() != obj.getClass()) return false;\n      Pair<F, S> s = (Pair<F, S>) obj;\n      return this.first.equals(s.first) && this.second.equals(s.second);\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      int c1 = this.first.compareTo(p.first);\n      if (c1 == 0) {\n        return this.second.compareTo(p.second);\n      }\n      return c1;\n    }\n  }\n\n  public static int swap(int a, int b) {\n    /*a = Main.swap(b,b=a); goes from left to right*/\n    return a;\n  }\n\n  public static long swap(long a, long b) {\n    /*a = Main.swap(b,b=a); goes from left to right*/\n    return a;\n  }\n\n  public static boolean next_permutation(int[] p) {\n    for (int a = p.length - 2; a >= 0; --a)\n      if (p[a] < p[a + 1])\n        for (int b = p.length - 1; ; --b)\n          if (p[b] > p[a]) {\n            int t = p[a];\n            p[a] = p[b];\n            p[b] = t;\n            for (++a, b = p.length - 1; a < b; ++a, --b) {\n              t = p[a];\n              p[a] = p[b];\n              p[b] = t;\n            }\n            return true;\n          }\n    return false;\n  }\n\n  public static long gcd(long a, long b) {\n    if (a < 0) a *= -1;\n    if (b < 0) b *= -1;\n    return b == 0 ? a : gcd(b, a % b);\n  }\n\n  public static class Reader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public Reader() {}\n\n    public Reader initConsoleReading() {\n      reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n      tokenizer = null;\n      return this;\n    }\n\n    public Reader initFileReading(String filePath) throws FileNotFoundException {\n      reader = new BufferedReader(new FileReader(filePath), 32768);\n      tokenizer = null;\n      return this;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n\n    public String nextLine() throws IOException {\n      return reader.readLine();\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n\n    public void dispose() throws IOException {\n      this.reader.close();\n    }\n  }\n  /**\n   * **********************************Helper Methods Ends\n   * Here*********************************************\n   */\n}\n"
        },
        {
            "language": 4,
            "solution": "import static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\n@SuppressWarnings(\"unused\")\npublic class D {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner in = new Scanner(System.in);\n\t\tString[] parts = in.nextLine().split(\" \");\n\t\tint n = Integer.parseInt(parts[0]);\n\t\tint k = Integer.parseInt(parts[1]);\n\t\tchar[][] M = new char[2][];\n\t\tM[0] = in.nextLine().toCharArray();\n\t\tM[1] = in.nextLine().toCharArray();\n\t\tSystem.out.println(f(n, k, M));\n\t}\n\n\tstatic String f(int n, int k, char[][] M) {\n\t\tboolean[][] seen = new boolean[2][n];\n\t\tLinkedList<Integer> Q = new LinkedList<Integer>();\n\t\tQ.add(0);\n\t\tQ.add(0);\n\t\tQ.add(0);\n\t\twhile (!Q.isEmpty()) {\n\t\t\tint x = Q.remove();\n\t\t\tint y = Q.remove();\n\t\t\tint water = Q.remove();\n\t\t\tif (water > y) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (y < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (y >= n) {\n\t\t\t\treturn \"YES\";\n\t\t\t}\n\t\t\tif (M[x][y] == 'X') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (seen[x][y]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tseen[x][y] = true;\n\n\t\t\tQ.add((x + 1) % 2);\n\t\t\tQ.add(y + k);\n\t\t\tQ.add(water + 1);\n\n\t\t\tQ.add(x);\n\t\t\tQ.add(y + 1);\n\t\t\tQ.add(water + 1);\n\n\t\t\tQ.add(x);\n\t\t\tQ.add(y - 1);\n\t\t\tQ.add(water + 1);\n\t\t}\n\t\treturn \"NO\";\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar s[3][100005];\nvector<int> g[100005 * 2];\nint f, n, k;\nset<pair<int, int> > Q;\nint dp[100005 * 2];\nbool ok(int v, int u) {\n  int i = u == f ? n : u % n;\n  return (dp[v] < i);\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 0; i < 2; ++i) scanf(\"%s\", s[i]);\n  f = n * 2;\n  for (int i = 0; i < 2; ++i) {\n    for (int j = 0; j < n; ++j) {\n      if (s[i][j] == 'X') continue;\n      int v = i * n + j;\n      g[v].push_back(j + 1 == n ? f : v + 1);\n      if (j > 0) g[v].push_back(v - 1);\n      g[v].push_back(j + k >= n ? f : j + k + (!i * n));\n    }\n  }\n  for (int i = 1; i <= f; ++i) dp[i] = int(1e9);\n  Q.insert(make_pair(dp[0], 0));\n  while (!Q.empty()) {\n    int v = Q.begin()->second;\n    Q.erase(Q.begin());\n    for (int j = 0; j < int((g[v]).size()); ++j) {\n      int to = g[v][j];\n      if (dp[v] + 1 < dp[to] && ok(v, to)) {\n        Q.erase(make_pair(dp[to], to));\n        dp[to] = dp[v] + 1;\n        Q.insert(make_pair(dp[to], to));\n      }\n    }\n  }\n  puts(dp[f] == int(1e9) ? \"NO\" : \"YES\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "// Main Code at the Bottom\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.BigInteger; \npublic class Main {\n\t//Fast IO class\n    static class FastReader {\n        BufferedReader br; \n        StringTokenizer st; \n        public FastReader() {\n        \tboolean env=System.getProperty(\"ONLINE_JUDGE\") != null;\n        \tif(!env) {\n        \t\ttry {\n\t\t\t\t\tbr=new BufferedReader(new FileReader(\"src\\\\input.txt\"));\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n        \t}\n        \telse br = new BufferedReader(new InputStreamReader(System.in)); \n        } \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) {\n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n        int nextInt() {\n            return Integer.parseInt(next()); \n        } \n        long nextLong() {\n            return Long.parseLong(next()); \n        } \n        double nextDouble() {\n            return Double.parseDouble(next()); \n        } \n        String nextLine() {\n            String str = \"\"; \n            try {\n                str = br.readLine(); \n            } \n            catch (IOException e) {\n                e.printStackTrace(); \n            } \n            return str; \n        } \n    }     \n    static long MOD=1000000000+7;\n    //debug\n    static void debug(Object... o) {\n        System.out.println(Arrays.deepToString(o));\n    }\n    // Pair\n    static class pair{\n    \tlong x,y;\n    \tpair(long a,long b){\n    \t\tthis.x=a;\n    \t\tthis.y=b;\n    \t}\n    \tpublic boolean equals(Object obj) {\n    \t\tif(obj == null || obj.getClass()!= this.getClass()) return false;\n            pair p = (pair) obj;\n            return (this.x==p.x && this.y==p.y);\n        }\n    \tpublic int hashCode() {\n            return Objects.hash(x,y);\n        }\n    }\n    static FastReader sc=new FastReader();\n    static PrintWriter out=new PrintWriter(System.out);  \n    //Main function(The main code starts from here)\n    static int n,k,vis[][];\n    static char a[][];\n    static int bfs(int i,int j) {\n    \tint vis[][]=new int[2][n];\n    \tQueue<int []> q=new LinkedList<>();\n    \tq.add(new int[] {i,j,-1});\n    \twhile(!q.isEmpty()) {\n    \t\tint s[]=q.poll();\n    \t\tint x=s[0],y=s[1],cur=s[2];\n    \t\tif(x>=2 || x<0 || y<0) continue;\n    \t\tif(y<n && (a[x][y]=='X' || vis[x][y]==1)) continue;\n    \t\tif(cur>=y) continue;\n    \t\tif(y>=n) return 1;\n    \t\tvis[x][y]=1;\n    \t\tq.add(new int[] {x,y+1,cur+1});\n    \t\tq.add(new int[] {x,y-1,cur+1});\n    \t\tq.add(new int[] {1-x,y+k,cur+1});\n;    \t}\n    \treturn 0;\n    }\n    public static void main (String[] args) throws java.lang.Exception {\n    \tint test=1;\n    \t//test=sc.nextInt();\n    \twhile(test-->0){\n    \t\tn=sc.nextInt();k=sc.nextInt();\n    \t\ta=new char[2][n];\n    \t\tvis=new int[2][n];\n    \t\ta[0]=sc.nextLine().toCharArray();\n    \t\ta[1]=sc.nextLine().toCharArray();\n    \t\tout.println(bfs(0,0)==1?\"YES\":\"NO\");\n    \t\t\n    \t}\n        out.flush();\n        out.close();\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class jumpinh {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] input = br.readLine().split(\" \");\n\t\tint n = Integer.parseInt(input[0]);\n\t\tint k = Integer.parseInt(input[1]);\n\t\tboolean[] izq = new boolean[n+1];\n\t\tboolean[] der = new boolean[n+1];\n\t\tizq[0]=true;\n\t\tizq[1]=true;\n\t\tder[0]=true;\n\t\tboolean ok = false;\n\t\tint nodo, lado;\n\t\tint arriba, abajo, salto;\n\t\tString wall1 = \" \"+br.readLine();\n\t\tString wall2 = \" \"+br.readLine();\n\t\tArrayList<Integer> q = new ArrayList<Integer>();\n\t\tq.add(1);q.add(0);\n\t\tint[] distanciaizq = new int[n+1];\n\t\tint[] distanciader = new int[n+1];\n\t\twhile(!q.isEmpty()){\n\t\t\tnodo = q.remove(0);\n\t\t\tlado = q.remove(0);\n\t\t\tarriba = nodo+1;\n\t\t\tabajo = nodo-1;\n\t\t\tsalto = nodo+k;\n\t\t\tif(arriba>n || nodo+k>n){\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint distancia = lado==0?distanciaizq[nodo]+1:distanciader[nodo]+1;\n\t\t\tif (lado==0){\n\t\t\t\tif(wall1.charAt(arriba)=='-' && !izq[arriba] && arriba>distancia){\n\t\t\t\t\tizq[arriba] = true;\n\t\t\t\t\tdistanciaizq[arriba] = distancia;\n\t\t\t\t\tq.add(arriba);\n\t\t\t\t\tq.add(lado);\n\t\t\t\t}\n\t\t\t\tif(wall1.charAt(abajo)=='-' && !izq[abajo] && abajo>distancia){\n\t\t\t\t\tizq[abajo] = true;\n\t\t\t\t\tdistanciaizq[abajo] = distancia;\n\t\t\t\t\tq.add(abajo);\n\t\t\t\t\tq.add(lado);\n\t\t\t\t}\n\t\t\t\tif(wall2.charAt(salto)=='-' && !der[salto] && salto>distancia){\n\t\t\t\t\tdistanciader[salto] = distancia;\n\t\t\t\t\tder[salto] = true;\n\t\t\t\t\tq.add(salto);\n\t\t\t\t\tq.add(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(wall2.charAt(arriba)=='-' && !der[arriba] && arriba>distancia){\n\t\t\t\t\tdistanciader[arriba] = distancia;\n\t\t\t\t\tder[arriba] = true;\n\t\t\t\t\tq.add(arriba);\n\t\t\t\t\tq.add(lado);\n\t\t\t\t}\n\t\t\t\tif(wall2.charAt(abajo)=='-' && !der[abajo] && abajo>distancia){\n\t\t\t\t\tdistanciader[abajo] = distancia;\n\t\t\t\t\tder[abajo] = true;\n\t\t\t\t\tq.add(abajo);\n\t\t\t\t\tq.add(lado);\n\t\t\t\t}\n\t\t\t\tif(wall1.charAt(salto)=='-' && !izq[salto] && salto>distancia){\n\t\t\t\t\tdistanciaizq[salto] = distancia;\n\t\t\t\t\tizq[salto] = true;\n\t\t\t\t\tq.add(salto);\n\t\t\t\t\tq.add(0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ok?\"YES\":\"NO\");\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool ch[2][100005];\nstring s[2];\nint n, k;\nvoid dfs(int x, int y, int h) {\n  if (s[x][y] != '-' || y < h || ch[x][y]) {\n    return;\n  }\n  if (y + k >= n) {\n    cout << \"YES\" << endl;\n    exit(0);\n  }\n  ch[x][y] = 1;\n  dfs((x + 1) % 2, y + k, h + 1);\n  dfs(x, y + 1, h + 1);\n  dfs(x, y - 1, h + 1);\n}\nint main() {\n  cin >> n >> k;\n  cin >> s[0] >> s[1];\n  dfs(0, 0, 0);\n  cout << \"NO\" << endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin, stdout\n\nfrom collections import deque\n\n\n\nn, k = map(int, stdin.readline().split())\n\n\n\nmaps = []\n\nmaps.append(list(stdin.readline() + '-'))\n\nmaps.append(list(stdin.readline() + '-'))\n\nvisit = [[0, 0] for i in range(n + 1)]\n\n\n\nvisit[0][0] = 1\n\nqueue = deque()\n\nlabel = 0\n\n\n\nqueue.append((0, -1, 0))#\u0631\u201a\u0630\u00b2\u0630\u00be\u0630\u00b9 \u0631\u0192\u0631\u20ac\u0630\u00be\u0630\u00b2\u0630\u00b5\u0630\u00bd\u0631\u0152, \u0631\u0192\u0631\u20ac\u0630\u00be\u0630\u00b2\u0630\u00b5\u0630\u00bd\u0631\u0152 \u0630\u00b2\u0630\u00be\u0630\u00b4\u0631\u2039, \u0630\u00bd\u0630\u00be\u0630\u00bc\u0630\u00b5\u0631\u20ac \u0631\u067e\u0631\u201a\u0630\u00b5\u0630\u00bd\u0631\u2039\n\nwhile queue:\n\n    mine, line, num = queue.popleft()\n\n    \n\n    if line >= mine:\n\n        continue\n\n    \n\n    if mine + k >= n:\n\n        label = 1\n\n    \n\n    if mine + 1 < n and not visit[mine + 1][num] and maps[num][mine + 1] == '-':\n\n        queue.append((mine + 1, line + 1, num))\n\n        visit[mine + 1][num] = 1\n\n        \n\n    if mine and mine - line > 1 and not visit[mine - 1][num] and maps[num][mine - 1] == '-':\n\n        queue.append((mine - 1, line + 1, num))\n\n        visit[mine - 1][num] = 1        \n\n    \n\n    if mine + k < n and not visit[mine + k][(num + 1) % 2] and maps[(num + 1) % 2][mine + k] == '-':\n\n        queue.append((min(mine + k, n), line + 1, (num + 1) % 2))\n\n        visit[min(mine + k, n)][(num + 1) % 2] = 1\n\n\n\n\n\nif label:\n\n    stdout.write('YES')\n\nelse:\n\n    stdout.write('NO')\n\n\n\n# Made By Mostafa_Khaled"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class Ninja implements Runnable {\n  public void run() {\n    try {\n      Scanner in = new Scanner(System.in);\n      //BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n      int n = in.nextInt();\n      int k = in.nextInt();\n      in.nextLine();\n      boolean[][] b = new boolean[2][n + 1];\n      for (int t = 0; t < 2; t++) {\n        String s = in.nextLine();\n        for (int i = 0; i < n; i++) {\n          b[t][i] = s.charAt(i) == '-';\n        }\n        b[t][n] = true;\n      }\n      int[][] r = new int[2][n + 1];\n      for (int i = 0; i < 2; i++) {\n        Arrays.fill(r[i], Integer.MAX_VALUE);\n      }\n      r[0][0] = 0;\n      LinkedList<P> q = new LinkedList<P>();\n      q.add(new P(0, 0));\n      while (!q.isEmpty()) {\n        P p = q.removeFirst();\n        int rr = r[p.x][p.y] + 1;\n        if (p.y != n) {\n          add(q, b, r, p.x, p.y + 1, rr);\n        }\n        if (p.y != 0) {\n          add(q, b, r, p.x, p.y - 1, rr);\n        }\n          add(q, b, r, 1 - p.x,Math.min(n, p.y + k), rr);\n      }\n      int res = Math.min(r[0][n], r[1][n]);\n      if (res == Integer.MAX_VALUE) {\n        System.out.println(\"NO\");\n      } else {\n        System.out.println(\"YES\");\n      }\n    } catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  void add(LinkedList<P> q, boolean[][] b, int[][] r, int x, int y, int rr) {\n    if (b[x][y] && y >= rr) {\n      if (r[x][y] == Integer.MAX_VALUE) {\n        q.add(new P(x, y));\n        r[x][y] = rr;\n      }\n    }\n  }\n\n  public static void main(String[] args) {\n    new Thread(new Ninja()).start();\n  }\n\n  class P {\n    int x;\n    int y;\n\n    P(int x, int y) {\n      this.x = x;\n      this.y = y;\n    }\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.util.AbstractCollection;\nimport java.util.StringTokenizer;\nimport java.util.LinkedList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Erik Odenman\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tOutputWriter out = new OutputWriter(outputStream);\n\t\tTaskB solver = new TaskB();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskB {\n\n    static int n, k;\n    static boolean[][] walls;\n\n\tpublic void solve(int testNumber, InputReader in, OutputWriter out) {\n        n = in.getInt();\n        k = in.getInt();\n        walls = new boolean[n][2];\n        for (int i = 0; i < 2; i++) {\n            String s = in.next();\n            for (int j = 0; j < n; j++) {\n                walls[j][i] = s.charAt(j) != 'X';\n            }\n        }\n        LinkedList<State> q = new LinkedList<State>();\n        boolean[][] visited = new boolean[n][2];\n        q.add(new State(0, 0, -1));\n        visited[0][0] = true;\n        while (!q.isEmpty()) {\n            State st = q.removeFirst();\n            if (st.h + k >= n || st.h + 1 >= n) {\n                out.println(\"YES\");\n                return;\n            }\n            int other = (st.wall+1)%2;\n            if (!visited[st.h+1][st.wall] && walls[st.h+1][st.wall]) {\n                visited[st.h+1][st.wall] = true;\n                q.add(new State(st.h+1, st.wall, st.t+1));\n            }\n            if (!visited[st.h+k][other] && walls[st.h+k][other]) {\n                visited[st.h+k][other] = true;\n                q.add(new State(st.h+k, other, st.t+1));\n            }\n            if (st.h > 0 && st.h-1 > st.t+1 && !visited[st.h-1][st.wall] && walls[st.h-1][st.wall]) {\n                visited[st.h-1][st.wall] = true;\n                q.add(new State(st.h-1, st.wall, st.t+1));\n            }\n        }\n        out.println(\"NO\");\n        return;\n\t}\n\n    static class State {\n        int wall, h, t;\n\n        public State(int hh, int w, int tt) {\n            wall = w; h = hh; t = tt;\n        }\n    }\n}\n\nclass InputReader {\n    private BufferedReader in;\n    private StringTokenizer st;\n    String token;\n\n    public InputReader(InputStream inStream) {\n        in = new BufferedReader(new InputStreamReader(inStream));\n    }\n\n    public int getInt() {\n        return Integer.parseInt(next());\n    }\n\n    public String next() {\n        String res = peekToken();\n        token = null;\n        return res;\n    }\n\n    public String peekToken() {\n        if (token != null) return token;\n        while (st == null || !st.hasMoreTokens()) {\n            String line = null;\n            try {\n                line = in.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(\"No more tokens was found\");\n            }\n            if (line == null) return null;\n            st = new StringTokenizer(line);\n        }\n        return token = st.nextToken();\n    }\n\n    }\n\nclass OutputWriter  {\n\n    PrintWriter out;\n\n    public OutputWriter(OutputStream outStream) {\n        out = new PrintWriter(outStream);\n    }\n\n    public OutputWriter(Writer writer) {\n        out = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n        for (int i = 0; i < objects.length; i++) {\n            if (i != 0) out.print(' ');\n            out.print(objects[i]);\n        }\n    }\n\n    public void println(Object... objects) {\n        print(objects);\n        out.println();\n    }\n\n    public void close() {\n        out.close();\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, vis[200010][2];\nstring s[2];\nbool rec(int w, int wl, int h) {\n  if (h < 0) return false;\n  if (h >= n) return true;\n  if (wl >= h) return false;\n  if (s[w][h] == 'X') return false;\n  if (vis[h][w]) return false;\n  vis[h][w] = 1;\n  return (rec(w, wl + 1, h - 1) || rec(w ^ 1, wl + 1, h + k) ||\n          rec(w, wl + 1, h + 1));\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  memset(vis, 0, sizeof vis);\n  cin >> n >> k >> s[0] >> s[1];\n  if (rec(0, -1, 0)) {\n    cout << \"YES\";\n  } else {\n    cout << \"NO\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class walljump { \n\n    public void run() throws Exception {\n        int N = nextInt();\n        int K = nextInt();\n        String wall1 = next();\n        String wall2 = next();\n        LinkedList<Triple> q = new LinkedList<Triple>();\n\n        boolean[][] valid = new boolean[N][2];\n\n        for(int i = 0; i<N; i++)\n            valid[i][0] = (wall1.charAt(i) != 'X');\n\n        for(int i = 0; i<N; i++)\n            valid[i][1] = (wall2.charAt(i) != 'X');\n\n\n\n        q.add(new Triple(0,0,0));\n        while (q.size() != 0){\n            Triple cur = q.poll();\n            int x = cur.x; int y = cur.y; int t = cur.t;\n\n            if(x >= t && valid[x][y]){\n                if( (x+1)>(N-1) || (x+K)>(N-1) ){\n                    out.println(\"YES\");\n                    System.exit(0);\n                }\n\n                q.add(new Triple(x+1, y, t+1));\n                if (x > 0) q.add(new Triple(x-1, y, t+1));\n                q.add(new Triple(x+K, (y+1)%2, t+1)); \n            }\n            if(t>=N){\n                out.println(\"NO\");\n                System.exit(0);\n            }\n\n            valid[x][y] = false;\n\n\n        }\n        out.println(\"NO\");\n        out.close();\n    }\n\n    public static void main(String args[]) throws Exception {\n        // new walljump(\"walljump.in\", \"walljump.out\").run();\n        new walljump().run();\n\n    }\n\n    BufferedReader in;\n    PrintStream out;\n    StringTokenizer st;\n\n    walljump() throws Exception {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = System.out;\n    }\n    walljump(String is, String os) throws Exception {\n            in = new BufferedReader(new FileReader(new File(is)));\n            out = new PrintStream(new File(os));\n    }\n\n    int nextInt() throws Exception {\n            return Integer.parseInt(next());\n    }\n\n    String next() throws Exception {\n            while (st == null || !st.hasMoreTokens()) {\n                    st = new StringTokenizer(in.readLine());\n            }\n            return st.nextToken();\n    }\n}\n\nclass Triple{\n    int x, y, t;\n    Triple(int a, int b, int c){\n        x = a;\n        y = b; \n        t = c;\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize \"O3\"\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst long long INF = 0x3f3f3f3f3f3f3f3f;\nconst int N = 1e5 + 5;\nint dp[N][2];\nint n, k;\nstring s[2];\nqueue<pair<int, int> > stany;\nvoid solve() {\n  memset(dp, inf, sizeof(dp));\n  cin >> n >> k >> s[0] >> s[1];\n  dp[1][0] = 0;\n  stany.push({1, 0});\n  while (!stany.empty()) {\n    auto v = stany.front();\n    stany.pop();\n    for (auto x :\n         {make_pair(v.first + 1, v.second), make_pair(v.first - 1, v.second),\n          make_pair(v.first + k, v.second ^ 1)}) {\n      x.first = max(1, min(n + 1, x.first));\n      if (s[x.second][x.first - 1] == 'X') continue;\n      if (dp[x.first][x.second] == inf && dp[v.first][v.second] + 1 < x.first) {\n        dp[x.first][x.second] = dp[v.first][v.second] + 1;\n        stany.push({x.first, x.second});\n      }\n    }\n  }\n  cout << (dp[n + 1][0] != inf || dp[n + 1][1] != inf ? \"YES\" : \"NO\") << '\\n';\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.System.out;\n\npublic class kot {\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    static class Print {\n        private BufferedWriter bw;\n\n        public Print() {\n            this.bw = new BufferedWriter(new OutputStreamWriter(out));\n        }\n\n\n        public void print(Object object) throws IOException {\n            bw.append(\"\" + object);\n        }\n\n        public void println(Object object) throws IOException {\n            print(object);\n            bw.append(\"\\n\");\n        }\n\n\n        public void close() throws IOException {\n            bw.close();\n        }\n\n    }\n    static char s[][];\n    static boolean visited[][] = new boolean[2][100005];\n    static int k;\n    static int n;\n    public kot(int n, int k){\n        this.n = n;\n        this.k = k;\n    }\n\n    public static void main(String args[]) throws IOException {\n        FastReader fr = new FastReader();\n        Print print = new Print();\n        int n = fr.nextInt();\n        int k = fr.nextInt();\n        n--;\n        kot king = new kot(n, k);\n        s = new char[2][100005];\n        s[0] = fr.nextLine().toCharArray();\n        s[1] = fr.nextLine().toCharArray();\n\n        dfs(0, 0, -1); //(rod ,starting point, water)\n        print.println(\"NO\");\n        print.close();\n    }\n    public static void dfs(int lor, int p, int water){\n        if (p <= water || visited[lor][p] || s[lor][p] == 'X' )\n            return;\n        if (p > n-k){\n            System.out.println(\"YES\");\n            System.exit(0);\n        }\n        visited[lor][p] = true;\n        dfs((lor+1)%2, p+k, water+1);\n        dfs(lor, p-1, water+1);\n        dfs(lor, p+1, water+1);\n    }\n\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double pi = 3.141592653689793238460;\nconst long long inf = 0x3f3f3f3f;\nconst int N = 2e5 + 5;\nconst int pr = 31;\nusing ld = long double;\nint mod = 998244353;\nint gcd(int a, int b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nint power(long long x, unsigned int y, int p) {\n  int res = 1;\n  x = x % p;\n  if (x == 0) return 0;\n  while (y > 0) {\n    if (y & 1) res = (res * x) % p;\n    y = y >> 1;\n    x = (x * x) % p;\n  }\n  return res;\n}\nbool vis[2][100005];\nint can[2][100005];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int n, k;\n  cin >> n >> k;\n  string s[2];\n  cin >> s[0] >> s[1];\n  queue<pair<int, int> > q;\n  q.push(make_pair(0, 0));\n  while (!q.empty()) {\n    pair<int, int> p = q.front();\n    q.pop();\n    int x = p.first;\n    int y = p.second;\n    if (x + k >= n) {\n      cout << \"YES\" << endl;\n      return 0;\n    }\n    for (int ii = -1; ii <= 1; ii++) {\n      if (x + ii > 0 && can[y][x] + 1 <= x + ii && !vis[y][x + ii] &&\n          s[y][x + ii] == '-') {\n        vis[y][x + ii] = true;\n        can[y][x + ii] = can[y][x] + 1;\n        q.push(make_pair(x + ii, y));\n      }\n    }\n    if (!vis[1 - y][x + k] && s[1 - y][x + k] == '-') {\n      vis[1 - y][x + k] = true;\n      can[1 - y][x + k] = can[y][x] + 1;\n      q.push(make_pair(x + k, 1 - y));\n    }\n  }\n  cout << \"NO\" << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2 * 1e5 + 100, INF = 1e9;\nint dis[2][N], n, k;\nbool mp[2][N];\nint main() {\n  for (int i = 0; i < N; i++) dis[0][i] = INF, dis[1][i] = INF;\n  cin >> n >> k;\n  string s;\n  cin >> s;\n  for (int i = 0; i < n; i++)\n    if (s[i] == '-')\n      mp[0][i] = true;\n    else\n      mp[0][i] = false;\n  cin >> s;\n  for (int i = 0; i < n; i++)\n    if (s[i] == '-')\n      mp[1][i] = true;\n    else\n      mp[1][i] = false;\n  queue<pair<int, int> > q;\n  q.push(pair<int, int>(0, 0));\n  dis[0][0] = 0;\n  while (q.size()) {\n    pair<int, int> p = q.front();\n    q.pop();\n    int d = dis[p.first][p.second];\n    if (p.second <= d - 1) continue;\n    if (p.second >= n) {\n      cerr << p.second << endl;\n      cout << \"YES\" << endl;\n      return 0;\n    }\n    if (mp[p.first][p.second] == false) continue;\n    if (p.second - 1 >= 0 && dis[p.first][p.second - 1] > d + 1) {\n      q.push(pair<int, int>(p.first, p.second - 1));\n      dis[p.first][p.second - 1] = d + 1;\n    }\n    if (p.second + 1 >= n || dis[p.first][p.second + 1] > d + 1) {\n      q.push(pair<int, int>(p.first, p.second + 1));\n      dis[p.first][p.second + 1] = d + 1;\n    }\n    if (p.second + k >= n || dis[(p.first + 1) % 2][p.second + k] > d + 1) {\n      q.push(pair<int, int>((p.first + 1) % 2, p.second + k));\n      dis[(p.first + 1) % 2][p.second + k] = d + 1;\n    }\n  }\n  cout << \"NO\" << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.math.BigInteger;\nimport java.util.Queue;\nimport java.util.LinkedList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Yaski\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass TaskD {\n\n    Cell[] left;\n    Cell[] right;\n\n    public void solve(int testNumber, FastScanner in, PrintWriter out) {\n        int n = in.nextInt();\n        int k = in.nextInt();\n\n        left = new Cell[n];\n        right = new Cell[n];\n\n        String leftS = in.nextLine();\n        String rightS = in.nextLine();\n        for (int i = 0; i < n; i++) {\n            left[i] = (leftS.charAt(i) == '-') ? new Cell(i, 0) : null;\n            right[i] = (rightS.charAt(i) == '-') ? new Cell(i, 1) : null;\n        }\n        // search exit\n        Queue<Cell> stack = new LinkedList<Cell>();\n\n        int index;\n        Cell child;\n        Cell element = left[0];\n        element.used = true;\n        stack.add(element);\n\n        while ((element = stack.poll()) != null) {\n            // check children\n            // move up\n            int water = element.water + 1;\n            index = element.index + 1;\n            if (index >= n) {\n                if (element.water <= element.index) {\n                    out.println(\"YES\");\n                    return;\n                }\n            } else {\n                child = (element.side == 0) ? left[index] : right[index];\n                if (child != null) {\n                    if (child.used) {\n                        if (water < child.water) {\n                            child.water = water;\n                            stack.add(child);\n                        }\n                    } else {\n                        child.used = true;\n                        child.water = water;\n                        stack.add(child);\n                    }\n                }\n            }\n            // jump\n            index = element.index + k;\n            if (index >= n) {\n                if (element.water <= element.index) {\n                    out.println(\"YES\");\n                    return;\n                }\n            } else {\n                child = (element.side == 0) ? right[index] : left[index];\n                if (child != null) {\n                    if (child.used) {\n                        if (water < child.water) {\n                            child.water = water;\n                            stack.add(child);\n                        }\n                    } else {\n                        child.used = true;\n                        child.water = water;\n                        stack.add(child);\n                    }\n                }\n            }\n            // move down\n            index = element.index - 1;\n            if (index >= 0 && water <= index) {\n                child = (element.side == 0) ? left[index] : right[index];\n                if (child != null) {\n                    if (child.used) {\n                        if (water < child.water) {\n                            child.water = water;\n                            stack.add(child);\n                        }\n                    } else {\n                        child.used = true;\n                        child.water = water;\n                        stack.add(child);\n                    }\n                }\n            }\n        }\n        out.println(\"NO\");\n    }\n}\n\nclass Cell {\n\n    public int index;\n    public int side = 0;\n    public int water = 0;\n    public boolean used = false;\n\n    public Cell(int index, int side) {\n        this.index = index;\n        this.side = side;\n    }\n\n}\n\nclass FastScanner {\n\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    public FastScanner(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n        tokenizer = null;\n    }\n\n    public String nextLine() {\n        tokenizer = null;\n        try {\n            return reader.readLine();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    }\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long double pi = 3.1415926535897932384626433832795;\nconst long double eps = 1e-9;\nstring l, r;\nvector<int> v[200005];\nbool visit[200005];\nset<pair<int, int> > s;\nint main() {\n  int n, k, i;\n  cin >> n >> k;\n  cin >> l >> r;\n  for (i = 0; i < l.length() - 1; i++) {\n    if (l[i] == '-' && l[i + 1] == '-') {\n      v[i].push_back((i + 1));\n      v[i + 1].push_back((i));\n    }\n    if (r[i] == '-' && r[i + 1] == '-') {\n      v[n + i].push_back((n + i + 1));\n      v[n + i + 1].push_back(n + i);\n    }\n    if (i + k < n) {\n      if (l[i] == '-' && r[i + k] == '-') {\n        v[i].push_back(n + i + k);\n      }\n      if (r[i] == '-' && l[i + k] == '-') {\n        v[n + i].push_back(i + k);\n      }\n    }\n  }\n  s.insert(make_pair(0, 0));\n  while (!s.empty()) {\n    int node = s.begin()->first;\n    int water = s.begin()->second;\n    visit[node] = true;\n    if (node < n) {\n      if (node + k >= n) {\n        cout << \"YES\" << endl;\n        return 0;\n      }\n    }\n    if (node >= n) {\n      if (node + k >= (2 * n)) {\n        cout << \"YES\" << endl;\n        return 0;\n      }\n    }\n    s.erase(s.begin());\n    for (int i = 0; i < v[node].size(); i++) {\n      if (visit[v[node][i]] == false) {\n        if (v[node][i] >= n) {\n          if ((v[node][i] - n) > water)\n            s.insert(make_pair(v[node][i], water + 1));\n        }\n        if (v[node][i] < n) {\n          if (v[node][i] > water) s.insert(make_pair(v[node][i], water + 1));\n        }\n      }\n    }\n  }\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, q0, k;\nint q[500010], f[500010], d[500010];\nchar s1[500010], s2[500010];\nvector<int> v[500010];\nint main() {\n  scanf(\"%d%d\\n\", &n, &k);\n  scanf(\"%s\\n\", s1);\n  scanf(\"%s\\n\", s2);\n  for (int i = 0; i < n; ++i) {\n    if (s1[i] == 'X') f[i] = 1;\n    if (s2[i] == 'X') f[i + n] = 1;\n    if (i > 0) {\n      v[i].push_back(i - 1);\n      v[i + n].push_back(i + n - 1);\n    }\n    if (i < n - 1) {\n      v[i].push_back(i + 1);\n      v[i + n].push_back(i + n + 1);\n    }\n    if (i + k < n) {\n      v[i].push_back(i + n + k);\n      v[i + n].push_back(i + k);\n    } else {\n      v[i].push_back(2 * n);\n      v[i + n].push_back(2 * n);\n    }\n  }\n  q0 = 1;\n  f[0] = 1;\n  int nod;\n  for (int i = 1; i <= q0; ++i) {\n    nod = q[i];\n    if (nod == 2 * n) {\n      printf(\"YES\\n\");\n      return 0;\n    }\n    if (d[nod] > nod % n) continue;\n    for (int j = 0; j < v[nod].size(); ++j) {\n      if (f[v[nod][j]] == 0) {\n        d[v[nod][j]] = d[nod] + 1;\n        q[++q0] = v[nod][j];\n        f[v[nod][j]] = 1;\n      }\n    }\n  }\n  printf(\"NO\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int max_n = 10000010;\nint vis[2][max_n];\nint d[2][max_n];\nint n, k, ans;\nvoid dfs(int i, int j, int water) {\n  if (water >= j) {\n    return;\n  }\n  if (j >= n) {\n    ans = 1;\n    return;\n  }\n  vis[i][j] = 1;\n  if (d[i][j - 1] != 1 && vis[i][j - 1] == 0) {\n    dfs(i, j - 1, water + 1);\n  }\n  if ((d[1 - i][j + k] != 1 && vis[1 - i][j + k] == 0)) {\n    dfs(1 - i, j + k, water + 1);\n  }\n  if ((d[i][j + 1] != 1 && vis[i][j + 1] == 0)) {\n    dfs(i, j + 1, water + 1);\n  }\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < n; j++) {\n      char x;\n      cin >> x;\n      if (x == '-') {\n      } else {\n        d[i][j] = 1;\n      }\n    }\n  }\n  dfs(0, 0, -1);\n  if (ans == 1) {\n    cout << \"YES\";\n    return 0;\n  }\n  cout << \"NO\";\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\npublic class B {\n\tBufferedReader in;\n\tStringTokenizer str;\n\tPrintWriter out;\n\tString SK;\n\n\tString next() throws IOException {\n\t\twhile ((str == null) || (!str.hasMoreTokens())) {\n\t\t\tSK = in.readLine();\n\t\t\tif (SK == null)\n\t\t\t\treturn null;\n\t\t\tstr = new StringTokenizer(SK);\n\t\t}\n\t\treturn str.nextToken();\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tvoid solve() throws IOException {\n\t\tint n = nextInt();\n\t\tint k = nextInt();\n\t\tchar[][] a = new char[2][n];\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\ta[i] = next().toCharArray();\n\t\t}\n\t\tQueue<Integer> num = new ArrayDeque<Integer>();\n\t\tQueue<Integer> pos = new ArrayDeque<Integer>();\n\t\tnum.add(0);\n\t\tpos.add(0);\n\t\tint[][] d = new int[2][n];\n\t\td[0][0] = 1;\n\t\twhile (!num.isEmpty()) {\n\t\t\tint x1 = num.poll();\n\t\t\tint y1 = pos.poll();\n\t\t\tif (y1 + k >= n) {\n\t\t\t\tout.println(\"YES\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (y1 > 0 && d[x1][y1] < y1  && d[x1][y1-1] == 0 && a[x1][y1-1]=='-') {\n\t\t\t\td[x1][y1 - 1] = d[x1][y1] + 1;\n\t\t\t\tnum.add(x1);\n\t\t\t\tpos.add(y1-1);\n\t\t\t}\n\t\t\tif (d[x1][y1 + 1] == 0 && a[x1][y1+1] =='-') {\n\t\t\t\td[x1][y1 + 1] = d[x1][y1] + 1;\n\t\t\t\tnum.add(x1);\n\t\t\t\tpos.add(y1 + 1);\n\t\t\t}\n\t\t\tif (d[1 - x1][y1 + k] == 0 && a[1-x1][y1+k] == '-') {\n\t\t\t\td[1 - x1][y1 + k] = d[x1][y1] + 1;\n\t\t\t\tnum.add(1 - x1);\n\t\t\t\tpos.add(y1 + k);\n\t\t\t}\n\t\t}\n\t\tout.println(\"NO\");\n\n\t}\n\n\tvoid run() throws IOException {\n\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew B().run();\n\t}\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double PI = acos(-1);\nconst double eps = 1e-9;\nint n, k;\nstring s[3];\nbool vis[3][100010];\nstruct J {\n  int w, lr, lv;\n};\nbool valid(int x, int i, int u, int w) {\n  if (x > n) {\n    cout << \"YES\";\n    exit(0);\n  }\n  if (i == 2) {\n    if (x > 1 && x > w && s[u ^ 3][x] != 'X' && vis[u ^ 3][x] == false)\n      return true;\n    else\n      return false;\n  }\n  if (x > 1 && x > w && s[u][x] != 'X' && vis[u][x] == false)\n    return true;\n  else\n    return false;\n}\nstring bfs() {\n  queue<J> q;\n  J x;\n  x.w = 0, x.lr = 1, x.lv = 1;\n  q.push(x);\n  int fx[] = {1, -1, k};\n  while (!q.empty()) {\n    J u = q.front();\n    q.pop();\n    for (int i = 0; i < 3; i++) {\n      int xx = u.lv + fx[i];\n      if (valid(xx, i, u.lr, u.w + 1)) {\n        J v;\n        v.w = u.w + 1, v.lv = xx;\n        if (i == 2)\n          v.lr = u.lr ^ 3;\n        else\n          v.lr = u.lr;\n        vis[v.lr][xx] = 1;\n        q.push(v);\n      }\n    }\n  }\n  return \"NO\";\n}\nint main() {\n  cin >> n >> k;\n  cin >> s[1] >> s[2];\n  s[1] = '#' + s[1];\n  s[2] = '#' + s[2];\n  if (s[1][1] == 'X') {\n    cout << \"NO\";\n    return 0;\n  }\n  cout << bfs() << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.lang.Integer;\nimport java.util.*;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\npublic class Ninja {\n    public static void main (String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int height = Integer.parseInt(st.nextToken());\n        int jump = Integer.parseInt(st.nextToken());\n        char[][] graph = new char[2][height];\n        boolean[][] visited = new boolean[2][height];\n        for (int i = 0; i < 2; i++) {\n            graph[i] = br.readLine().toCharArray();\n        }\n//        for (int i = 0; i < 2; i++) {\n//            System.out.println(new String(graph[i]));\n//        }\n        Queue<Distance> qq = new LinkedList<>();\n        Distance d = new Distance(0, 0, 0, 0);\n        qq.add(d);\n        boolean isTrue = false;\n        while (!qq.isEmpty()) {\n            Distance current = qq.remove();\n            if (visited[current.x][current.y]) {\n                continue;\n            } else {\n                visited[current.x][current.y] = true;\n            }\n            //System.out.println(\"water: \" + water + \" \" + current.x + \" \" + current.y);\n            if (current.y + 1 > graph[0].length - 1 || current.y + jump > graph[0].length - 1) {\n               // System.out.println(\"why\");\n              //  System.out.println(graph[0].length-1);\n                isTrue = true;\n                break;\n            }\n            if (current.y+1 < graph[0].length && graph[current.x][current.y + 1] != 'X' && !visited[current.x][current.y + 1]) {\n                qq.add(new Distance(current.x, current.y + 1, current.distance + 1, current.water + 1));\n            }\n            if (current.y-1 >= 0 && current.y - 1 > current.water && graph[current.x][current.y - 1] != 'X' && !visited[current.x][current.y - 1]) {\n                qq.add(new Distance(current.x, current.y - 1, current.distance + 1, current.water + 1));\n            }\n            if (current.y + jump < graph[0].length && graph[1 - current.x][current.y + jump] != 'X' && !visited[1 -current.x][current.y + jump]) {\n                qq.add(new Distance(1 - current.x, current.y + jump, current.distance + 1, current.water + 1));\n            }\n        }\n         if (isTrue) {\n            System.out.println(\"YES\");\n        } else {\n            System.out.println(\"NO\");\n        }\n    }\n    public static class Distance {\n        int x;\n        int y;\n        int distance;\n        int water;\n        public Distance(int x, int y, int distance, int water) {\n            this.x = x;\n            this.y = y;\n            this.distance = distance;\n            this.water = water;\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\npublic class jumpingonwalls {\n\tstatic char[] left, right;\n\tstatic int n, k;\n\tstatic int[] states, parents;\n\tstatic boolean[] visited;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(\n\t\t\t\tSystem.in));\n\n\t\tStringTokenizer tok = new StringTokenizer(reader.readLine());\n\t\tn = Integer.parseInt(tok.nextToken());\n\t\tk = Integer.parseInt(tok.nextToken());\n\n\t\tleft = new char[n];\n\t\tright = new char[n];\n\t\treader.read(left, 0, left.length);\n\t\treader.readLine();\n\t\treader.read(right, 0, right.length);\n\n\t\tstates = new int[2 * n];\n//\t\tparents = new int[2 * n];\n\t\tfor (int i = 0; i < 2 * n; ++i) {\n\t\t\tstates[i] = -1;\n//\t\t\tparents[i] = -1;\n\t\t}\n\n\t\tQueue<Integer> queue = new LinkedList<Integer>();\n\t\tstates[0] = 0;\n\t\tqueue.offer(0);\n\n\t\tboolean b = false;\n\t\twhile (!queue.isEmpty()) {\n\t\t\tint node = queue.poll();\n\t\t\tif (node >= n) {\n\t\t\t\tif (right[node - n] == 'X')\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (left[node] == 'X')\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint dist = states[node];\n\n\t\t\tif (node >= n) {\n\t\t\t\t// Up\n\t\t\t\tif (node == 2 * n - 1) {\n\t\t\t\t\tb = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (states[node + 1] < 0)\n\t\t\t\t{\n\t\t\t\t\tstates[node + 1] = dist + 1;\n\t\t\t\t\tqueue.offer(node + 1);\n\t\t\t\t}\n\n\t\t\t\t// Down\n\t\t\t\tif (node > n && dist < node - n - 1 && states[node -1] < 0)\n\t\t\t\t{\n\t\t\t\t\tstates[node - 1] = dist + 1;\n\t\t\t\t\tqueue.offer(node - 1);\n\t\t\t\t}\n\n\t\t\t\t// Opposite\n\t\t\t\tif (node - n + k >= n) {\n\t\t\t\t\tb = true;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (states[node - n + k] < 0)\n\t\t\t\t{\n\t\t\t\t\tstates[node - n + k] = dist + 1;\n\t\t\t\t\tqueue.offer(node - n + k);\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t// Up\n\t\t\t\tif (node == n - 1) {\n\t\t\t\t\tb = true;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (states[node + 1] < 0)\n\t\t\t\t{\n\t\t\t\t\tstates[node + 1] = dist + 1;\n\t\t\t\t\tqueue.offer(node + 1);\n\t\t\t\t}\n\n\t\t\t\t// Down\n\t\t\t\tif (node > 0 && dist < node - 1 && states[node - 1] < 0)\n\t\t\t\t{\n\t\t\t\t\tstates[node - 1] = dist + 1;\n\t\t\t\t\tqueue.offer(node - 1);\n\t\t\t\t}\n\n\t\t\t\t// Opposite\n\t\t\t\tif (node + k >= n) {\n\t\t\t\t\tb = true;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (states[node + n + k] < 0)\n\t\t\t\t{\n\t\t\t\t\tstates[node + n + k] = dist + 1;\n\t\t\t\t\tqueue.offer(node + n + k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tSystem.out.println(Arrays.toString(states));\n\n\t\tif (b)\n\t\t\tSystem.out.println(\"YES\");\n\t\telse\n\t\t\tSystem.out.println(\"NO\");\n\t}\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.LinkedList;\nimport java.util.Queue;\npublic class JoW {\n    static String[] walls = new String[2];\n    static boolean[][] touchd;\n    static boolean out;\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] s = br.readLine().split(\" \");\n        int n = Integer.parseInt(s[0]);\n        touchd = new boolean[2][n];\n        int k = Integer.parseInt(s[1]);\n        walls[0] = br.readLine();\n        walls[1] = br.readLine();\n        Queue<Node> q = new LinkedList<Node>();\n        q.add(new Node(-1,0,0));\n        touchd[0][0] = true;\n        while(!out && !q.isEmpty()){\n            Node curr = q.poll();\n            int jump = curr.pos + k;\n            if(jump >= n){out = true; break;}\n            int water = curr.wLvl+1;\n            if(isValid(water,jump,(curr.wall+1)%2)){\n                q.add(new Node(water, jump, (curr.wall+1)%2));\n                touchd[(curr.wall+1)%2][jump] = true;\n            }\n            if(isValid(water, curr.pos+1, curr.wall)){\n                q.add(new Node(water, curr.pos+1, curr.wall));\n                touchd[curr.wall][curr.pos+1] = true;\n            }\n            if(isValid(water, curr.pos-1, curr.wall)){\n                // Below previously said \"curr.pos+1\"\n                //... remember to double check your code people >.<...\n                q.add(new Node(water, curr.pos-1, curr.wall));\n                touchd[curr.wall][curr.pos-1] = true;\n            }\n        }\n        System.out.println(out?\"YES\":\"NO\");\n    }\n    static boolean isValid(int wLvl, int pos, int wall){\n        return (pos > wLvl &&\n                !touchd[wall][pos] &&\n                walls[wall].charAt(pos)=='-');\n    }\n}\nclass Node {\n    int wLvl;\n    int pos;\n    int wall;\n    Node(int l, int p, int w){\n        wLvl = l; pos = p; wall = w; \n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 10;\nconst long long MOD = 1e9 + 7;\nint n, k;\nbool col[N];\nvector<int> g[N];\nint get(int i) {\n  if (i >= n) return i - n;\n  return i;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  cin >> n >> k;\n  string s, t;\n  cin >> s >> t;\n  s += t;\n  for (int i = 0; i < (int)(n); ++i) {\n    if (i + k >= n)\n      g[i].push_back(2 * n);\n    else {\n      g[i].push_back(n + i + k);\n      g[n + i + k].push_back(i);\n      g[i].push_back(i + 1);\n      g[i + 1].push_back(i);\n    }\n  }\n  for (int i = (n); i <= (int)(2 * n - 1); ++i) {\n    if (i + k >= 2 * n)\n      g[i].push_back(2 * n);\n    else {\n      g[i].push_back(i + k - n);\n      g[i + k - n].push_back(i);\n      g[i].push_back(i + 1);\n      g[i + 1].push_back(i);\n    }\n  }\n  queue<pair<int, int> > q;\n  q.push({0, 0});\n  while (!q.empty()) {\n    int v = q.front().first;\n    int brdz = q.front().second;\n    q.pop();\n    col[v] = true;\n    if (s[v] == 'X' || brdz > get(v)) {\n      continue;\n    }\n    for (auto to : g[v]) {\n      if (col[to]) continue;\n      col[to] = true;\n      q.push({to, brdz + 1});\n    }\n  }\n  if (col[2 * n])\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, d[2][100100], di;\nstring s[2];\nint main() {\n  cin >> n >> k;\n  const int dx[] = {0, 0, 1}, dy[] = {1, -1, k};\n  cin >> s[0];\n  cin >> s[1];\n  queue<pair<bool, int> > q;\n  q.push(make_pair(0, 0));\n  memset(d, -1, sizeof(d));\n  d[0][0] = 0;\n  while (!q.empty()) {\n    pair<bool, int> u = q.front();\n    q.pop();\n    int x = u.first, y = u.second;\n    if (y + k >= n) {\n      cout << \"YES\";\n      return 0;\n    }\n    for (int i = 0; i < 3; i++) {\n      int nx = x ^ dx[i], ny = y + dy[i];\n      if (ny < 0) continue;\n      if (s[nx][ny] == 'X') continue;\n      if (d[nx][ny] != -1) continue;\n      if (d[x][y] + 1 > ny) continue;\n      d[nx][ny] = d[x][y] + 1;\n      q.push(make_pair(nx, ny));\n    }\n  }\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  queue<pair<int, int> > que;\n  int n, k;\n  vector<string> cnt;\n  cin >> n >> k;\n  int mp[2][100000];\n  int dx[4] = {0, 0, -1, 1};\n  int dy[4] = {1, -1, k, k};\n  for (int i = 0; i < 2; i++) {\n    string a;\n    cin >> a;\n    cnt.push_back(a);\n  }\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 100000; j++) {\n      mp[i][j] = 10000000;\n    }\n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < cnt[0].size(); j++) {\n      if (cnt[i][j] == 'X') mp[i][j] = 100000000;\n    }\n  }\n  int sx = 0, sy = 0;\n  mp[sx][sy] = 0;\n  que.push(pair<int, int>(sx, sy));\n  while (!que.empty()) {\n    pair<int, int> p = que.front();\n    que.pop();\n    int water = mp[p.first][p.second];\n    if (water > p.second) {\n      continue;\n    }\n    if (p.second + k >= n) {\n      cout << \"YES\" << endl;\n      return 0;\n    }\n    for (int i = 0; i < 4; i++) {\n      int nx = p.first + dx[i];\n      int ny = p.second + dy[i];\n      if (((ny >= n) && (nx >= 0) && (nx < 2)) ||\n          (nx >= 0 && nx < 2 && ny >= 0 && ny < n && mp[nx][ny] == 10000000)) {\n        mp[nx][ny] = mp[p.first][p.second] + 1;\n        que.push(pair<int, int>(nx, ny));\n      }\n    }\n  }\n  cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 1;\nint n, k;\nchar g[2][N];\nbool vis[2][N];\nqueue<pair<int, int> > qu;\nbool BFS(int x, int y) {\n  qu.push(make_pair(x, y));\n  vis[x][y] = true;\n  int lev = 0;\n  while (!qu.empty()) {\n    int siz = qu.size();\n    while (siz--) {\n      int x = qu.front().first, y = qu.front().second;\n      qu.pop();\n      if (y + k >= n || y + 1 >= n) return true;\n      if (y - 1 >= 0 && y - 1 > lev && g[x][y - 1] != 'X' && !vis[x][y - 1]) {\n        vis[x][y - 1] = true;\n        qu.push(make_pair(x, y - 1));\n      }\n      if (g[x][y + 1] != 'X' && !vis[x][y + 1]) {\n        vis[x][y + 1] = true;\n        qu.push(make_pair(x, y + 1));\n      }\n      if (g[x ^ 1][y + k] != 'X' && !vis[x ^ 1][y + k]) {\n        vis[x ^ 1][y + k] = true;\n        qu.push(make_pair(x ^ 1, y + k));\n      }\n    }\n    ++lev;\n  }\n  return false;\n}\nint main() {\n  scanf(\"%d%d%s%s\", &n, &k, g[0], g[1]);\n  if (BFS(0, 0))\n    puts(\"YES\");\n  else\n    puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid print(char* A, char* B, int h) {\n  for (int i = 0; i < h; i++) {\n    cout << A[i];\n  }\n  cout << endl;\n  for (int i = 0; i < h; i++) {\n    cout << B[i];\n  }\n}\nbool backtrack(int pos, char* A, char* B, int h, int jump, int water) {\n  if (pos < h) {\n    if (pos < water) return false;\n    water++;\n    if (pos < 0) return false;\n    if (A[pos] != 'X') {\n      A[pos] = 'X';\n      if (pos + jump >= h) return true;\n      return backtrack(pos - 1, A, B, h, jump, water) ||\n             backtrack(pos + jump, B, A, h, jump, water) ||\n             backtrack(pos + 1, A, B, h, jump, water);\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\nint main() {\n  int h, j;\n  cin >> h >> j;\n  char A[h], B[h];\n  for (int i = 0; i < h; i++) cin >> A[i];\n  for (int i = 0; i < h; i++) cin >> B[i];\n  bool result = backtrack(0, A, B, h, j, 0);\n  if (result)\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 5;\nchar s[2][maxn];\nbool visit[2][maxn];\nint n = 2;\nint m;\ninline bool check(int x, int y) { return y >= 0 && y < m; }\nint main() {\n  ios::sync_with_stdio(false);\n  int k;\n  int d = 0;\n  queue<pair<int, int> > Q;\n  pair<int, int> p(0, 0);\n  int x, y;\n  int sz;\n  bool flag = false;\n  scanf(\"%d %d\", &m, &k);\n  for (int i = 0; i < 2; ++i) scanf(\"%s\", s[i]);\n  visit[0][0] = true;\n  Q.push(p);\n  while (1) {\n    sz = Q.size();\n    if (sz == 0) break;\n    while (sz--) {\n      p = Q.front();\n      Q.pop();\n      if (p.second < d) continue;\n      x = 1 - p.first;\n      y = p.second + k;\n      if (y >= m) {\n        flag = true;\n        goto _output;\n      }\n      if (check(x, y) && !visit[x][y]) {\n        visit[x][y] = true;\n        if (s[x][y] == '-' && y >= d) {\n          Q.push(make_pair(x, y));\n        }\n      }\n      x = p.first;\n      y = p.second + 1;\n      if (y >= m) {\n        flag = true;\n        goto _output;\n      }\n      if (check(x, y) && !visit[x][y]) {\n        visit[x][y] = true;\n        if (s[x][y] == '-' && y >= d) {\n          Q.push(make_pair(x, y));\n        }\n      }\n      y = p.second - 1;\n      if (y >= m) {\n        flag = true;\n        goto _output;\n      }\n      if (check(x, y) && !visit[x][y]) {\n        visit[x][y] = true;\n        if (s[x][y] == '-' && y >= d) {\n          Q.push(make_pair(x, y));\n        }\n      }\n    }\n    ++d;\n  }\n_output:\n  puts(flag ? \"YES\" : \"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nqueue<int> q;\nint n, k, d[5][100005];\nstring c[2];\ninline bool ok(int t, int x, int y) { return (c[y][x] == '-' && x > t); }\nint main() {\n  cin >> n >> k;\n  cin >> c[0] >> c[1];\n  q.push(0);\n  q.push(0);\n  q.push(-1);\n  while (!q.empty()) {\n    int x = q.front();\n    q.pop();\n    int y = q.front();\n    q.pop();\n    if (d[y][x] != 0) {\n      q.pop();\n      continue;\n    }\n    d[y][x] = 1;\n    if (x + k >= n) {\n      cout << \"YES\";\n      return 0;\n    }\n    q.front()++;\n    if (ok(q.front(), x + k, abs(y - 1)))\n      q.push(x + k), q.push(abs(y - 1)), q.push(q.front());\n    if (ok(q.front(), x - 1, y)) q.push(x - 1), q.push(y), q.push(q.front());\n    if (ok(q.front(), x + 1, y)) q.push(x + 1), q.push(y), q.push(q.front());\n    q.pop();\n  }\n  cout << \"NO\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 100005;\nint N;\nint k;\nchar wall[2][MAX];\nint mark[2][MAX];\nbool dfs() {\n  queue<int> Q;\n  Q.push(1), Q.push(0);\n  mark[0][1] = 1;\n  int x, w, h;\n  while (!Q.empty()) {\n    x = Q.front(), Q.pop();\n    w = Q.front(), Q.pop();\n    h = mark[w][x];\n    if (x + 1 > N) return true;\n    if (!mark[w][x + 1] && h < x + 1 && wall[w][x + 1] == '-') {\n      Q.push(x + 1);\n      Q.push(w);\n      mark[w][x + 1] = h + 1;\n    }\n    if (x - 1 > 0 && !mark[w][x - 1] && h < x - 1 && wall[w][x - 1] == '-') {\n      Q.push(x - 1);\n      Q.push(w);\n      mark[w][x - 1] = h + 1;\n    }\n    if (x + k > N) return true;\n    if (!mark[w ^ 1][x + k] && h < x + k && wall[w ^ 1][x + k] == '-') {\n      Q.push(x + k);\n      Q.push(1 ^ w);\n      mark[1 ^ w][x + k] = h + 1;\n    }\n  }\n  return false;\n}\nint main() {\n  scanf(\"%d%d\", &N, &k);\n  scanf(\"%s%s\", wall[0] + 1, wall[1] + 1);\n  if (dfs())\n    puts(\"YES\");\n  else\n    puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1e9 + 7;\nconst int N = 1e6 + 10;\nint dis[2][N];\nchar str[2][N];\nint main() {\n  int n, k;\n  scanf(\"%d%d\", &n, &k);\n  scanf(\"%s%s\", str[0], str[1]);\n  queue<pair<int, int>> q;\n  q.push({0, 0});\n  for (int o = 0; o < 2; o++) {\n    for (int i = 0; i < n; i++) {\n      dis[o][i] = i + 1;\n      if (str[o][i] == 'X') dis[o][i] = 0;\n    }\n  }\n  dis[0][0] = 0;\n  while (!q.empty()) {\n    int o, x;\n    tie(o, x) = q.front();\n    q.pop();\n    if (x == n - 1) {\n      cout << \"YES\" << endl;\n      return 0;\n    }\n    if (dis[o][x + 1] > dis[o][x] + 1) {\n      dis[o][x + 1] = dis[o][x] + 1;\n      q.push({o, x + 1});\n    }\n    if (x > 0 && dis[o][x - 1] > dis[o][x] + 1) {\n      dis[o][x - 1] = dis[o][x] + 1;\n      q.push({o, x - 1});\n    }\n    if (x + k > n - 1) {\n      cout << \"YES\" << endl;\n      return 0;\n    }\n    if (dis[o ^ 1][x + k] > dis[o][x] + 1) {\n      dis[o ^ 1][x + k] = dis[o][x] + 1;\n      q.push({o ^ 1, x + k});\n    }\n  }\n  cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n, k = map(int, input().split())\nlzid = input()\ndzid = input()\nzidovi = [lzid, dzid]\n\nq = [[-1, [False,0]]]  #[koraci, [zid, visina]]\n\nizasao = 0\nbio = [[0 for i in range(n+k+100)], [0 for i in range(n+k+100)]]\nwhile len(q) != 0:\n    trenutni = q.pop(0)\n\n    korak = trenutni[0]\n\n    pozicija = trenutni[1]\n    tren_zid = pozicija[0]\n    tren_visina = pozicija[1]\n\n    if bio[tren_zid][tren_visina] == 0:\n        bio[tren_zid][tren_visina] = 1\n        if tren_visina > n-1:\n            print(\"YES\")\n            izasao = 1\n            break\n        elif tren_visina == n-1 and zidovi[tren_zid][tren_visina] != 'X' and tren_visina > korak:\n            print(\"YES\")\n            izasao = 1\n            break\n        elif zidovi[tren_zid][tren_visina] != 'X' and tren_visina > korak:\n            q.append([korak+1, [tren_zid, tren_visina-1]])\n            q.append([korak+1, [tren_zid, tren_visina+1]])\n            q.append([korak+1, [not(tren_zid), tren_visina+k]])\n            \n##        if tren_visina - 1 > korak+1:\n##            if zidovi[tren_zid][tren_visina-1] != 'X':\n##                q.append([korak+1, [tren_zid, tren_visina-1]])\n##        if tren_visina + 1 > korak:\n##            if tren_visina + k <= n-1:\n##                if zidovi[tren_zid][tren_visina+1] != 'X':\n##                    q.append([korak+1, [tren_zid, tren_visina+1]])\n##            else:\n##                print(\"YES\")\n##                izasao = 1\n##                break\n##        if tren_visina + k > korak:\n##            if tren_visina + k <= n-1:\n##                if zidovi[not(tren_zid)][tren_visina+k] != 'X':\n##                    q.append([korak+1, [not(tren_zid), tren_visina+k]])\n##            else:\n##                print(\"YES\")\n##                izasao = 1\n    \nif izasao == 0:\n    print(\"NO\")\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 10;\nint n, k;\nstring s[3];\nint mark[3][maxn];\nvoid dfs(int v, int w, int b) {\n  if (v > n - 1) {\n    cout << \"YES\";\n    exit(0);\n  }\n  if (w >= v or v < 0 or mark[b][v] or s[b][v] == 'X') return;\n  mark[b][v] = 1;\n  dfs(v + k, w + 1, 3 - b);\n  dfs(v + 1, w + 1, b);\n  if (v > 0) {\n    dfs(v - 1, w + 1, b);\n  }\n}\nint main() {\n  cin >> n >> k;\n  cin >> s[1] >> s[2];\n  dfs(0, -1, 1);\n  cout << \"NO\" << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.io.FileNotFoundException;\nimport java.util.AbstractCollection;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.util.LinkedList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Star Orpheus\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = in.nextInt();\n            int k = in.nextInt();\n            String[] a = new String[2];\n            LinkedList<Pair<Integer, Integer>> q = new LinkedList<>();\n            int[][] way = new int[n + k + 5][2];\n\n            for (int i = 0; i < n + k + 5; i++)\n                for (int j = 0; j < 2; j++)\n                    way[i][j] = Integer.MAX_VALUE;\n\n            a[0] = in.next();\n            a[1] = in.next();\n\n            way[0][0] = 0;\n            q.add(new Pair<Integer, Integer>(0, 0));   // lvl, wall id\n//        if(a[1].charAt(0) == '-') {\n//            way[0][1] = 0;\n//            q.add(new Pair(0, 1));\n//        }\n\n            while (!q.isEmpty()) {\n                Pair<Integer, Integer> pos = q.pollFirst();\n\n                if ((pos.x + 1 >= n) || (pos.x + k >= n)) {\n                    out.println(\"YES\");\n                    return;\n                }\n\n                if ((a[pos.y].charAt(pos.x + 1) == '-')\n                        && (way[pos.x][pos.y] + 1 < way[pos.x + 1][pos.y])\n                        && (way[pos.x][pos.y] + 1 <= pos.x + 1)) {\n                    q.add(new Pair<>(pos.x + 1, pos.y));\n                    way[pos.x + 1][pos.y] = way[pos.x][pos.y] + 1;\n                }\n                if ((a[pos.y ^ 1].charAt(pos.x + k) == '-')\n                        && (way[pos.x][pos.y] + 1 < way[pos.x + k][pos.y ^ 1])\n                        && (way[pos.x][pos.y] + 1 <= pos.x + k)) {\n                    q.add(new Pair<>(pos.x + k, pos.y ^ 1));\n                    way[pos.x + k][pos.y ^ 1] = way[pos.x][pos.y] + 1;\n                }\n                if ((pos.x > 0) && (a[pos.y].charAt(pos.x - 1) == '-')\n                        && (way[pos.x][pos.y] + 1 < way[pos.x - 1][pos.y])\n                        && (way[pos.x][pos.y] + 1 <= pos.x - 1)) {\n                    q.add(new Pair<>(pos.x - 1, pos.y));\n                    way[pos.x - 1][pos.y] = way[pos.x][pos.y] + 1;\n                }\n            }\n\n            out.println(\"NO\");\n        }\n\n    }\n\n    static class FastScanner {\n        final static int BUFFER_SIZE = 65536;\n        BufferedReader br;\n        char[] buf = new char[BUFFER_SIZE];\n        int len = 0;\n        int it = 0;\n        boolean end = false;\n\n        boolean delim(char c) {\n            return c == ' ' || c == '\\n' || c == '\\r';\n        }\n\n        void fillBuffer() {\n            try {\n                len = br.read(buf);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        void ensureBuffer() {\n            if (it == len) {\n                it = 0;\n                fillBuffer();\n                if (len == -1) end = true;\n            }\n        }\n\n        void moveNext() {\n            while (!end) {\n                ensureBuffer();\n                if (!delim(buf[it])) return;\n                while (it < len && delim(buf[it])) it++;\n            }\n        }\n\n        public String next() {\n            moveNext();\n            StringBuilder sb = new StringBuilder();\n            while (!end) {\n                int l = it;\n                while (++it < len && !delim(buf[it])) ;\n                sb.append(buf, l, it - l);\n                ensureBuffer();\n                if (delim(buf[it])) break;\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() {\n            moveNext();\n            if (buf[it] == '-') {\n                it++;\n                return -nextInt();\n            }\n            if (buf[it] == '+') {\n                it++;\n                return nextInt();\n            }\n            int result = 0;\n            while (!end) {\n                int l = it;\n                while (it < len && !delim(buf[it])) {\n                    result = (result * 10) + buf[it] - '0';\n                    it++;\n                }\n                ensureBuffer();\n                if (end || delim(buf[it])) break;\n            }\n            return result;\n        }\n\n        public FastScanner(String file) {\n            try {\n                br = new BufferedReader(new FileReader(file), BUFFER_SIZE);\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public FastScanner(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is), BUFFER_SIZE);\n        }\n\n    }\n\n    static class Pair<T, S> {\n        public T x;\n        public S y;\n\n        public Pair() {\n        }\n\n        public Pair(T x, S y) {\n            this.x = x;\n            this.y = y;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Node {\n  int h;\n  int tr;\n  int x;\n};\nbool tt[2][100000 + 1];\nbool vis[2][100000 + 1];\nint tout = 100000 * 2;\nint n, k;\ndeque<Node> dq;\nint main() {\n  string line;\n  cin >> n >> k;\n  memset(tt, 1, sizeof tt);\n  getline(cin, line);\n  for (int cc = 0, _n = 2; cc < _n; cc++) {\n    getline(cin, line);\n    for (int i = 0, _n = n; i < _n; i++)\n      if (line[i] == 'X') tt[cc][i + 1] = false;\n  }\n  dq.push_back((Node){0, 0, 1});\n  while (!dq.empty()) {\n    Node top = (Node)dq.front();\n    dq.pop_front();\n    if (vis[top.tr][top.x]) continue;\n    vis[top.tr][top.x] = true;\n    if (top.x <= top.h) continue;\n    bool ok = false;\n    if (top.x + 1 > n) {\n      tout = min(tout, top.h + 1);\n      ok = true;\n    }\n    if (top.x + k > n) {\n      tout = min(tout, top.h + 1);\n      ok = true;\n    }\n    if (ok) continue;\n    int x = top.x, h = top.h, tr = top.tr;\n    if (x + 1 <= n && tt[tr][x + 1]) dq.push_back((Node){h + 1, tr, x + 1});\n    if (x + k <= n && tt[(tr + 1) % 2][x + k])\n      dq.push_back((Node){h + 1, (tr + 1) % 2, x + k});\n    if (x - 1 >= 1 && tt[tr][x - 1]) dq.push_back((Node){h + 1, tr, x - 1});\n  }\n  if (tout <= n)\n    cout << \"YES\\n\";\n  else\n    cout << \"NO\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 100000;\nconst int INF = 1 << 30;\nchar ss[2][MAX_N + 4];\nint ds[2][MAX_N];\ninline void check(int i, int j, int d, queue<pair<int, int> > &q) {\n  if (ss[i][j] == '-' && ds[i][j] > d) {\n    ds[i][j] = d;\n    q.push(pair<int, int>(i, j));\n  }\n}\nint main() {\n  int n, k;\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 0; i < 2; i++) {\n    scanf(\"%s\", ss[i]);\n    fill(ds[i], ds[i] + n, INF);\n  }\n  ds[0][0] = 0;\n  queue<pair<int, int> > q;\n  q.push(pair<int, int>(0, 0));\n  while (!q.empty()) {\n    pair<int, int> u = q.front();\n    q.pop();\n    int &ui = u.first, &uj = u.second;\n    int vd = ds[ui][uj] + 1;\n    int vi, vj;\n    vi = ui, vj = uj + 1;\n    if (vj >= n) {\n      puts(\"YES\");\n      return 0;\n    }\n    check(vi, vj, vd, q);\n    vi = ui, vj = uj - 1;\n    if (vd <= vj) check(vi, vj, vd, q);\n    vi = ui ^ 1, vj = uj + k;\n    if (vj >= n) {\n      puts(\"YES\");\n      return 0;\n    }\n    check(vi, vj, vd, q);\n  }\n  puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic class Main {\n\tstatic boolean[][] r;\n\tstatic int h,j;\n\tstatic boolean b=false;\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\th=sc.nextInt();\n\t\tj=sc.nextInt();\n\t\tr=new boolean[2][h];\n\t\tfor(int i=0;i<2;i++) { \t \t \t\n\t\t\tString s=sc.next();\n\t\t\tfor(int j=0;j<h;j++) {\n\t\t\t\tif(s.charAt(j)=='X')\n\t\t\t\t\tr[i][j]=false;\n\t\t\t\telse\n\t\t\t\t\tr[i][j]=true;\n\t\t\t}\n\t\t}\n\t\t//left=true;\n\t\tint water=-1;\n\t\tmove(water,0,0);\n\t\tif(b)\n\t\t\tSystem.out.println(\"YES\");\n\t\telse\n\t\t\tSystem.out.println(\"NO\");\n\t}\n\tpublic static void move(int water,int x,int y) {\n\t\tif(b)\n\t\t\treturn;\n\t\t\n\t\tif(x==0) {\n\t\t\tif(y+j>h-1) {\n\t\t\t\tb=true;\n\t\t\t\treturn;\n\t\t\t}else if(r[1][y+j])\n\t\t\t\tmove(water+1,1,y+j);\n\t\t\telse\n\t\t\t\tr[x][y]=false;\n\t\t\tif(r[x][y+1])\n\t\t\t\tmove(water+1,0,y+1);\n\t\t\tif(y-1>=0 && r[x][y-1] && water+1<y-1 )\n\t\t\t\tmove(water+1,0,y-1);\n\t\t}else {\n\t\t\tif(y+j>h-1) {\n\t\t\t\tb=true;\n\t\t\t\treturn;\n\t\t\t}else if(r[0][y+j])\n\t\t\t\tmove(water+1,0,y+j);\n\t\t\telse\n\t\t\t\tr[x][y]=false;\n\t\t\tif(r[x][y+1])\n\t\t\t\tmove(water+1,1,y+1);\n\t\t\tif(y-1>=0 && r[x][y-1] && water+1<y-1 )\n\t\t\t\tmove(water+1,1,y-1);\n\t\t}\n\t\t\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst int MAX_N = 100000 + 7;\nstruct Node {\n  int t, x, lv;\n  Node() {}\n  Node(int _t, int _x, int _lv) : t(_t), x(_x), lv(_lv) {}\n  bool operator<(const Node &rhs) const { return lv < rhs.lv; }\n};\nint dp[2][MAX_N];\nchar S[2][MAX_N];\nint main() {\n  int n, k;\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 0; i < 2; i++) scanf(\"%s\", S[i]);\n  priority_queue<Node, vector<Node>, less<Node> > pq;\n  memset(dp, 0x3f, sizeof(dp));\n  dp[0][0] = 0;\n  pq.push(Node(0, 0, 0));\n  while (!pq.empty()) {\n    int t, x, lv;\n    tie(t, x, lv) = tie(pq.top().t, pq.top().x, pq.top().lv);\n    pq.pop();\n    if (lv + 1 == n || lv + k >= n) {\n      puts(\"YES\");\n      return 0;\n    }\n    if (S[x][lv + 1] == '-') {\n      if (dp[x][lv + 1] > dp[x][lv] + 1) {\n        dp[x][lv + 1] = dp[x][lv] + 1;\n        pq.push(Node(dp[x][lv + 1], x, lv + 1));\n      }\n    }\n    if (lv - 1 >= 0 && S[x][lv - 1] == '-') {\n      if (dp[x][lv] + 1 < lv) {\n        if (dp[x][lv - 1] > dp[x][lv] + 1) {\n          dp[x][lv - 1] = dp[x][lv] + 1;\n          pq.push(Node(dp[x][lv - 1], x, lv - 1));\n        }\n      }\n    }\n    if (S[x ^ 1][lv + k] == '-') {\n      if (dp[x ^ 1][lv + k] > dp[x][lv] + 1) {\n        dp[x ^ 1][lv + k] = dp[x][lv] + 1;\n        pq.push(Node(dp[x ^ 1][lv + k], x ^ 1, lv + k));\n      }\n    }\n  }\n  puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class JumpingOnWalls {\n    PrintWriter out;\n    StringTokenizer st;\n    BufferedReader br;\n    final int imax = Integer.MAX_VALUE, imin = Integer.MIN_VALUE;\n    final int mod = 1000000007;\n\n    void solve() throws Exception {\n        int t = 1;\n//        t = ni();\n        for (int ii = 0; ii < t; ii++) {\n            int n = ni(), k = ni();\n\n            char[][] walls= {ns().toCharArray(), ns().toCharArray()};\n            Queue<int[]> q= new LinkedList<>();\n            q.add(new int[]{0, 0, 1});\n\n            boolean won= false;\n            boolean[][] visited= new boolean[2][n]; visited[0][0]= true;\n            while(!q.isEmpty()) {\n                int[] curr= q.poll();\n                int wall= curr[0], height= curr[1], gap= curr[2];\n\n                if(height+k>= n || height== n-1) { won= true; break; }\n\n                if(!visited[(wall+1)%2][height+k] && walls[(wall+1)%2][height+k]== '-')\n                { q.add(new int[]{(wall+1)%2, height+k, gap+k-1}); visited[(wall+1)%2][height+k]= true; }\n                if(!visited[wall][height+1] && walls[wall][height+1]== '-')\n                { q.add(new int[]{wall, height+1, gap}); visited[wall][height+1]= true; }\n                if(height!= 0 && !visited[wall][height-1] && gap>= 3 && walls[wall][height-1]== '-')\n                { q.add(new int[]{wall, height-1, gap-2}); visited[wall][height-1]= true; }\n            }\n\n//            for(int i=0;i<2;i++) {for(int j=0;j<n;j++) out.print(visited[i][j]+\" \"); out.println(); }\n            print(won);\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        new JumpingOnWalls().run();\n    }\n\n    void run() throws Exception {\n        if (System.getProperty(\"ONLINE_JUDGE\") == null) {\n            File file = new File(\"C:\\\\college\\\\CodeForces\\\\inputf.txt\");\n            br = new BufferedReader(new FileReader(file));\n            out = new PrintWriter(\"C:\\\\college\\\\CodeForces\\\\outputf.txt\");\n        } else {\n            out = new PrintWriter(System.out);\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        long ss = System.currentTimeMillis();\n        st = new StringTokenizer(\"\");\n        while (true) {\n            solve();\n            String s = br.readLine();\n            if (s == null) break;\n            else st = new StringTokenizer(s);\n        }\n        //out.println(System.currentTimeMillis()-ss+\"ms\");\n        out.flush();\n    }\n\n    void read() throws Exception {\n        st = new StringTokenizer(br.readLine());\n    }\n\n    int ni() throws Exception {\n        if (!st.hasMoreTokens()) read();\n        return Integer.parseInt(st.nextToken());\n    }\n\n    char nc() throws Exception {\n        if (!st.hasMoreTokens()) read();\n        return st.nextToken().charAt(0);\n    }\n\n    String nw() throws Exception {\n        if (!st.hasMoreTokens()) read();\n        return st.nextToken();\n    }\n\n    long nl() throws Exception {\n        if (!st.hasMoreTokens()) read();\n        return Long.parseLong(st.nextToken());\n    }\n\n    int[] ni(int n) throws Exception {\n        int[] ret = new int[n];\n        for (int i = 0; i < n; i++) ret[i] = ni();\n        return ret;\n    }\n\n    long[] nl(int n) throws Exception {\n        long[] ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = nl();\n        return ret;\n    }\n\n    double nd() throws Exception {\n        if (!st.hasMoreTokens()) read();\n        return Double.parseDouble(st.nextToken());\n    }\n\n    String ns() throws Exception {\n        String s = br.readLine();\n        return s.length() == 0 ? br.readLine() : s;\n    }\n\n    void print(int[] arr) {\n        for (int i : arr) out.print(i + \" \");\n        out.println();\n    }\n\n    void print(long[] arr) {\n        for (long i : arr) out.print(i + \" \");\n        out.println();\n    }\n\n    void print(int[][] arr) {\n        for (int[] i : arr) {\n            for (int j : i) out.print(j + \" \");\n            out.println();\n        }\n    }\n\n    void print(long[][] arr) {\n        for (long[] i : arr) {\n            for (long j : i) out.print(j + \" \");\n            out.println();\n        }\n    }\n\n    long add(long a, long b) {\n        if (a + b >= mod) return (a + b) - mod;\n        else return a + b >= 0 ? a + b : a + b + mod;\n    }\n\n    long mul(long a, long b) {\n        return (a * b) % mod;\n    }\n\n    void print(boolean b) {\n        if (b) out.println(\"YES\");\n        else out.println(\"NO\");\n    }\n\n    long binExp(long base, long power) {\n        long res = 1l;\n        while (power != 0) {\n            if ((power & 1) == 1) res = mul(res, base);\n            base = mul(base, base);\n            power >>= 1;\n        }\n        return res;\n    }\n\n    long gcd(long a, long b) {\n        if (b == 0) return a;\n        else return gcd(b, a % b);\n    }\n\n    // strictly smaller on left\n    void stack_l(int[] arr, int[] left) {\n        Stack<Integer> stack = new Stack<>();\n        for (int i = 0; i < arr.length; i++) {\n            while (!stack.isEmpty() && arr[stack.peek()] >= arr[i]) stack.pop();\n            if (stack.isEmpty()) left[i] = -1;\n            else left[i] = stack.peek();\n            stack.push(i);\n        }\n    }\n\n    // strictly smaller on right\n    void stack_r(int[] arr, int[] right) {\n        Stack<Integer> stack = new Stack<>();\n        for (int i = arr.length - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && arr[stack.peek()] >= arr[i]) stack.pop();\n            if (stack.isEmpty()) right[i] = arr.length;\n            else right[i] = stack.peek();\n            stack.push(i);\n        }\n    }\n\n    private void sort(int[] arr) {\n        List<Integer> list = new ArrayList<>();\n        for (int i : arr) list.add(i);\n        Collections.sort(list);\n        for (int i = 0; i < arr.length; i++) arr[i] = list.get(i);\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nchar A[210000][3];\nint n, v, flag = 0;\nstruct node {\n  int yer;\n  int duvar;\n  int su;\n  struct node *nxt, *prv;\n} * front, *back;\nvoid cikar() {\n  struct node *k;\n  k = front->prv;\n  free(front);\n  front = k;\n  if (k) k->nxt = NULL;\n}\nvoid ekle(int a, int b, int s) {\n  struct node *k;\n  k = (struct node *)malloc(1 * sizeof(struct node));\n  k->yer = a;\n  k->duvar = b;\n  k->su = s;\n  k->prv = NULL;\n  if (!front) {\n    front = k;\n    back = k;\n    k->nxt = NULL;\n  } else {\n    back->prv = k;\n    k->nxt = back;\n    back = k;\n  }\n  return;\n}\nvoid Do_it() {\n  int a, b, s;\n  while (front) {\n    a = front->yer;\n    b = front->duvar;\n    s = front->su;\n    cikar();\n    if (a > n && flag == 0) {\n      printf(\"YES\");\n      flag++;\n      break;\n    }\n    if (A[a][b] == '-' && a > s)\n      A[a][b] = 's';\n    else\n      continue;\n    if (A[a + 1][b] != 'X' && A[a + 1][b] != 's' && a + 1 > s)\n      ekle(a + 1, b, s + 1);\n    if (A[a - 1][b] != 'X' && A[a - 1][b] != 's' && a - 1 > s)\n      ekle(a - 1, b, s + 1);\n    if (b == 1) {\n      if (A[a + v][2] != 'X' && A[a + v][2] != 's' && a + v > s)\n        ekle(a + v, 2, s + 1);\n    } else if (A[a + v][1] != 'X' && A[a + v][1] != 's' && a + v > s)\n      ekle(a + v, 1, s + 1);\n  }\n  return;\n}\nint main() {\n  int i, j;\n  char l;\n  A[0][1] = 's';\n  A[0][2] = 's';\n  scanf(\"%d%d\", &n, &v);\n  for (j = 1; j <= 2; j++) {\n    for (i = 1; i <= n; i++) {\n      scanf(\" %c\", &l);\n      A[i][j] = l;\n    }\n  }\n  ekle(1, 1, 0);\n  Do_it();\n  if (flag == 0) printf(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstring L, R;\nint dis[100005][2], n, k;\nqueue<pair<int, int> > q;\nint main() {\n  cin >> n >> k;\n  cin >> L >> R;\n  for (int i = 0; i < n; i++) {\n    dis[i][0] = dis[i][1] = INT_MAX;\n  }\n  dis[0][0] = 0;\n  q.push(make_pair(0, 0));\n  while (!q.empty()) {\n    pair<int, int> x = q.front();\n    q.pop();\n    int ndis = dis[x.first][x.second];\n    if (x.first + k >= n) {\n      cout << \"YES\\n\";\n      return 0;\n    }\n    if ((x.second == 0 && L[x.first + 1] == '-') ||\n        (x.second == 1 && R[x.first + 1] == '-')) {\n      if (dis[x.first + 1][x.second] == INT_MAX) {\n        dis[x.first + 1][x.second] = ndis + 1;\n        q.push(make_pair(x.first + 1, x.second));\n      }\n    }\n    if (x.first - 1 >= ndis + 1) {\n      if ((x.second == 0 && L[x.first - 1] == '-') ||\n          (x.second == 1 && R[x.first - 1] == '-')) {\n        if (dis[x.first - 1][x.second] == INT_MAX) {\n          dis[x.first - 1][x.second] = ndis + 1;\n          q.push(make_pair(x.first - 1, x.second));\n        }\n      }\n    }\n    if ((x.second == 0 && R[x.first + k] == '-') ||\n        (x.second == 1 && L[x.first + k] == '-')) {\n      if (dis[x.first + k][1 - x.second] == INT_MAX) {\n        dis[x.first + k][1 - x.second] = ndis + 1;\n        q.push(make_pair(x.first + k, 1 - x.second));\n      }\n    }\n  }\n  cout << \"NO\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\n\npublic class B {\n\t\n\tstatic final int INF = (int) 1e9;\n\t\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint N = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\t\n\t\tchar[][] W = new char[2][];\n\t\tW[0] = sc.next().toCharArray();\n\t\tW[1] = sc.next().toCharArray();\n\t\t\n\t\t\n\t\tint[][] time = new int[2][N];\n\t\tArrays.fill(time[0], INF);\n\t\tArrays.fill(time[1], INF);\n\t\t\n\t\ttime[0][0] = 0;\n\t\t\n\t\tPriorityQueue<Triple> q = new PriorityQueue<>();\n\t\t\n\t\tq.add(new Triple(0, 0, 0));\n\t\t\n\t\tboolean ans = false;\n\t\t\n\t\twhile(!q.isEmpty()) {\n\t\t\tTriple u = q.remove();\n\t\t\t\n\t\t\tif(time[u.w][u.p] != u.t)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif(u.p + 1 >= N || u.p + k >= N) {\n\t\t\t\tans = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif(W[u.w][u.p + 1] == '-' && u.t + 1 < time[u.w][u.p + 1]) {\n\t\t\t\tq.add(new Triple(u.w, u.p + 1, u.t + 1));\n\t\t\t\ttime[u.w][u.p + 1] = u.t + 1;\n\t\t\t}\n\t\t\t\n\t\t\tif(W[1 - u.w][u.p + k] == '-' && u.t + 1 < time[1 - u.w][u.p + k]) {\n\t\t\t\tq.add(new Triple(1 - u.w, u.p + k, u.t + 1));\n\t\t\t\ttime[1 - u.w][u.p + k] = u.t + 1;\n\t\t\t}\n\t\t\t\n\t\t\tif(u.p > 0 && u.t + 1 <= u.p - 1 && W[u.w][u.p - 1] == '-' && u.t + 1 < time[u.w][u.p - 1]) {\n\t\t\t\tq.add(new Triple(u.w, u.p - 1, u.t + 1));\n\t\t\t\ttime[u.w][u.p - 1] = u.t + 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tout.println(ans ? \"YES\" : \"NO\");\n\t\t\n\t\tout.flush();\n\t\tout.close();\n\t}\n\t\n\tstatic class Triple implements Comparable<Triple>{\n\t\tint w, p, t;\n\t\t\n\t\tpublic Triple(int w, int p, int t) {\n\t\t\tthis.w = w;\n\t\t\tthis.p = p;\n\t\t\tthis.t= t;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Triple o) {\n\t\t\treturn this.t - o.t;\n\t\t}\n\t\t\n\t}\n\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\t\tpublic Scanner(String file) throws FileNotFoundException{\tbr = new BufferedReader(new FileReader(file));}\n\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile(st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws NumberFormatException, IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() throws NumberFormatException, IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException\n\t\t{\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif(x.charAt(0) == '-')\n\t\t\t{\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor(int i = start; i < x.length(); i++)\n\t\t\t\tif(x.charAt(i) == '.')\n\t\t\t\t{\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif(dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg?-1:1);\n\t\t}\n\n\t}\n\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxint = -1u >> 1;\nconst double pi = 3.14159265358979323;\nconst double eps = 1e-8;\nint n, k;\nstring s[2];\nint f[101000][2];\nbool vis[101000][2];\nbool spfa() {\n  memset(vis, false, sizeof(vis));\n  for (int i = (0); i < (n + 5); i++) f[i][0] = f[i][1] = maxint;\n  f[0][0] = 0;\n  queue<pair<int, int> > que;\n  que.push(make_pair(0, 0));\n  while (!que.empty()) {\n    pair<int, int> now = que.front();\n    que.pop();\n    int p = now.first, id = now.second;\n    vis[p][id] = false;\n    if (p + 1 >= n ||\n        (p + 1 < n && s[id][p + 1] != 'X' && f[p][id] + 1 <= p + 1)) {\n      if (p + 1 >= n) return true;\n      if (f[p + 1][id] > f[p][id] + 1) {\n        f[p + 1][id] = f[p][id] + 1;\n        if (!vis[p + 1][id]) {\n          vis[p + 1][id] = true;\n          que.push(make_pair(p + 1, id));\n        }\n      }\n    }\n    if (p - 1 >= 0 && s[id][p - 1] != 'X' && f[p][id] + 1 <= p - 1) {\n      if (f[p - 1][id] > f[p][id] + 1) {\n        f[p - 1][id] = f[p][id] + 1;\n        if (!vis[p - 1][id]) {\n          vis[p - 1][id] = true;\n          que.push(make_pair(p - 1, id));\n        }\n      }\n    }\n    if (p + k >= n ||\n        (p + k < n && s[id ^ 1][p + k] != 'X' && f[p][id] + 1 <= p + k)) {\n      if (p + k >= n) return true;\n      if (f[p + k][id ^ 1] > f[p][id] + 1) {\n        f[p + k][id ^ 1] = f[p][id] + 1;\n        if (!vis[p + k][id ^ 1]) {\n          vis[p + k][id ^ 1] = true;\n          que.push(make_pair(p + k, id ^ 1));\n        }\n      }\n    }\n  }\n  return false;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> n >> k;\n  cin >> s[0];\n  cin >> s[1];\n  s[0] += \"-\";\n  s[1] += \"-\";\n  bool ans = spfa();\n  if (ans)\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool vis[2][100005];\nchar c[2][100005];\nint main() {\n  queue<pair<int, pair<int, int> > > q;\n  bool flag = 0;\n  int n, k;\n  cin >> n >> k;\n  scanf(\"%s%s\", c[0], c[1]);\n  q.push(make_pair(0, make_pair(0, 0)));\n  while (!q.empty()) {\n    int x = q.front().first, y = q.front().second.first,\n        de = q.front().second.second;\n    q.pop();\n    if (y >= n) {\n      flag = 1;\n      break;\n    }\n    if (vis[x][y] || de > y) continue;\n    vis[x][y] = 1;\n    if (y - 1 >= 0 && c[x][y - 1] != 'X' && y - 1 >= de + 1 && !vis[x][y - 1]) {\n      q.push(make_pair(x, make_pair(y - 1, de + 1)));\n    }\n    if (y + 1 >= n || (c[x][y + 1] != 'X' && !vis[x][y + 1])) {\n      q.push(make_pair(x, make_pair(y + 1, de + 1)));\n    }\n    if (y + k >= n || (c[x ^ 1][y + k] != 'X' && !vis[x ^ 1][y + k])) {\n      q.push(make_pair(x ^ 1, make_pair(y + k, de + 1)));\n    }\n  }\n  if (flag)\n    cout << \"YES\";\n  else\n    cout << \"NO\";\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class CF198B {\n    static boolean[][] G;\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int k = in.nextInt();\n        G = new boolean[n][2];\n        String L = in.next();\n        String R = in.next();\n        for(int i=0; i<n; i++) {\n            G[i][0] = L.charAt(i)=='X';\n            G[i][1] = R.charAt(i)=='X';\n        }\n\n        // Height, Side, time\n        TreeSet<int[]> Q = new TreeSet<int[]>(new Comparator<int[]>() {\n            public int compare(int[] A, int[] B) {\n                if(A[2] != B[2])\n                    return A[2]-B[2];\n                if(A[1] != B[1])\n                    return A[1]-B[1];\n                return A[0]-B[0];\n            }\n        });\n        Q.add(new int[]{0, 0, 0});\n        while(!Q.isEmpty()) {\n            int[] P = Q.pollFirst();\n            if(P[0] < P[2]) continue; //Water too high\n            if(P[0] >= n) {\n                System.out.println(\"YES\");\n                return;\n            }\n            if(G[P[0]][P[1]]) continue; //Wall\n            G[P[0]][P[1]] = true;\n            Q.add(new int[]{P[0]+1, P[1], P[2]+1});\n            Q.add(new int[]{P[0]-1, P[1], P[2]+1});\n            Q.add(new int[]{P[0]+k, 1-P[1], P[2]+1});\n        }\n        System.out.println(\"NO\");\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1e9 + 7;\nint main() {\n  string a[2];\n  int n, k;\n  cin >> n >> k >> a[0] >> a[1];\n  int d[2][100010];\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 100010; j++) d[i][j] = 1e9;\n  queue<int> whi, high;\n  whi.push(0);\n  high.push(0);\n  d[0][0] = 0;\n  while (!whi.empty()) {\n    int x = whi.front(), y = high.front();\n    whi.pop();\n    high.pop();\n    if (d[x][y] > y) continue;\n    if (y + k >= n) {\n      puts(\"YES\");\n      return 0;\n    }\n    if ((a[x][y + 1] == '-') && (d[x][y + 1] == 1e9)) {\n      d[x][y + 1] = d[x][y] + 1;\n      whi.push(x);\n      high.push(y + 1);\n    }\n    if ((y > 0) && (a[x][y - 1] == '-') && (d[x][y - 1] == 1e9)) {\n      d[x][y - 1] = d[x][y] + 1;\n      whi.push(x);\n      high.push(y - 1);\n    }\n    if ((a[x ^ 1][y + k] == '-') && (d[x ^ 1][y + k] > (d[x][y] + 1))) {\n      d[x ^ 1][y + k] = d[x][y] + 1;\n      whi.push(x ^ 1);\n      high.push(y + k);\n    }\n  }\n  puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100010;\nbool visited[2][maxn];\nint d[2][maxn];\nstring s[2];\nint main() {\n  int n, k;\n  cin >> n >> k;\n  cin >> s[0] >> s[1];\n  int dx[3] = {0, 0, 1};\n  int dy[3] = {1, -1, k};\n  queue<pair<bool, int>> q;\n  q.push(make_pair(0, 0));\n  visited[0][0] = 1;\n  while (q.size()) {\n    pair<bool, int> k = q.front();\n    q.pop();\n    bool x = k.first;\n    int y = k.second;\n    for (int i = 0; i < 3; i++) {\n      bool xx = x ^ dx[i];\n      int yy = y + dy[i];\n      if (yy >= n) {\n        cout << \"YES\" << endl;\n        exit(0);\n      }\n      if (yy >= 0 && s[xx][yy] == '-' && !visited[xx][yy] && yy > d[x][y]) {\n        q.push(make_pair(xx, yy));\n        visited[xx][yy] = 1;\n        d[xx][yy] = d[x][y] + 1;\n      }\n    }\n  }\n  cout << \"NO\" << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool vl[100010], vr[100010];\nint main() {\n  int n, k;\n  cin >> n >> k;\n  queue<pair<pair<int, int>, bool> > q;\n  string s1, s2;\n  cin >> s1 >> s2;\n  q.push(make_pair(make_pair(0, 0), true));\n  vl[0] = true;\n  while (!q.empty()) {\n    pair<pair<int, int>, bool> p = q.front();\n    q.pop();\n    if (p.second) {\n      if (p.first.first + k >= n) {\n        cout << \"YES\" << endl;\n        return 0;\n      }\n      if (s1[p.first.first + 1] == '-' && !vl[p.first.first + 1]) {\n        q.push(\n            make_pair(make_pair(p.first.first + 1, p.first.second + 1), true));\n        vl[p.first.first + 1] = true;\n      }\n      if (s1[p.first.first - 1] == '-' &&\n          p.first.first - 1 >= p.first.second + 1 && !vl[p.first.first - 1]) {\n        q.push(\n            make_pair(make_pair(p.first.first - 1, p.first.second + 1), true));\n        vl[p.first.first - 1] = true;\n      }\n      if (s2[p.first.first + k] == '-' && !vr[p.first.first + k]) {\n        q.push(\n            make_pair(make_pair(p.first.first + k, p.first.second + 1), false));\n        vr[p.first.first + k] = true;\n      }\n    } else {\n      if (p.first.first + k >= n) {\n        cout << \"YES\" << endl;\n        return 0;\n      }\n      if (s2[p.first.first + 1] == '-' && !vr[p.first.first + 1]) {\n        q.push(\n            make_pair(make_pair(p.first.first + 1, p.first.second + 1), false));\n        vr[p.first.first + 1] = true;\n      }\n      if (s2[p.first.first - 1] == '-' &&\n          p.first.first - 1 >= p.first.second + 1 && !vr[p.first.first - 1]) {\n        q.push(\n            make_pair(make_pair(p.first.first - 1, p.first.second + 1), false));\n        vr[p.first.first - 1] = true;\n      }\n      if (s1[p.first.first + k] == '-' && !vl[p.first.first + k]) {\n        q.push(\n            make_pair(make_pair(p.first.first + k, p.first.second + 1), true));\n        vl[p.first.first + k] = true;\n      }\n    }\n  }\n  cout << \"NO\" << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\n\npublic class WallJumping {\n\t\n\tprivate final int k;\n\t\n\tprivate final int n;\n\t\n\tprivate final boolean[][]wallInfo;\n\t\n\tprivate final boolean[][] wallVisited;\n\t\n\t//private final int[][] wasVisitedWithLevel;\n\t\n\tprivate WallJumping(int k, int n, boolean[][] wallInfo) {\n\t\tsuper();\n\t\tthis.k = k;\n\t\tthis.n = n;\n\t\tthis.wallInfo = wallInfo;\n\t\tthis.wallVisited = new boolean[2][n + 1];\n\t\t//this.wasVisitedWithLevel = new int[2][n + 1];\n\t\t//Arrays.fill(wasVisitedWithLevel, Integer.MAX_VALUE);\n\t}\n\n\t\n\t\n\tprivate static boolean[][] getWallInfo(Scanner in, int n) {\n\t\tboolean[][] wallInfo = new boolean[2][n + 1];\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tString s = in.next();\n\t\t\tfor (int j = 0; j < s.length(); j++) {\n\t\t\t\tif ('X' == s.charAt(j)) {\n\t\t\t\t\twallInfo[i][j + 1] = false;\n\t\t\t\t} else if ('-' == s.charAt(j)){\n\t\t\t\t\twallInfo[i][j + 1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn wallInfo;\n\t}\n\t\n\tprivate class State {\n\t\t\n\t\tint wall, position, waterLevel;\n\n\t\tprivate State(int wall, int position, int waterLevel) {\n\t\t\tsuper();\n\t\t\tthis.wall = wall;\n\t\t\tthis.position = position;\n\t\t\tthis.waterLevel = waterLevel;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\t\t\n\tprivate boolean canJumpOut() {\n\t\tDeque<State> jumpQueue = new LinkedList<State>();\n\t\tjumpQueue.addFirst( new State(0, 1, 0));\n\t\twhile (jumpQueue.isEmpty() == false) {\n\t\t\tState state = jumpQueue.removeFirst();\n\t\t\tif (state.position > n - k) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\twallVisited[state.wall][state.position] = true;\n\t\t\t\t\n\t\t\t\tif (wallInfo[state.wall][state.position + 1] && wallVisited[state.wall][state.position + 1] == false) {\n\t\t\t\t\tjumpQueue.addFirst(  new State(state.wall, state.position + 1, state.waterLevel + 1));\n\t\t\t\t}\n\t\t\t\n\t\t\t\tif ( state.position - 1> state.waterLevel + 1 && wallInfo[state.wall][state.position - 1] &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twallVisited[state.wall][state.position -1] == false) {\n\t\t\t\t\tjumpQueue.addFirst(  new State(state.wall, state.position - 1, state.waterLevel + 1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ( wallInfo[(state.wall + 1) % 2][state.position + k] && wallVisited[(state.wall + 1) % 2][state.position + k] == false) {\n\t\t\t\t\tjumpQueue.addFirst( new State((state.wall + 1) % 2, state.position + k, state.waterLevel + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint k = in.nextInt();\n\t\tboolean[][] wallInfo = getWallInfo(in, n);\n\t\tWallJumping jumping = new WallJumping(k, n, wallInfo);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tout.println(jumping.canJumpOut() ? \"YES\" : \"NO\");\n\t\tout.flush();\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint n, k;\nchar w[3][100100];\nint a[3][100100];\nint s[3][100100];\ntypedef struct {\n  int s, lr, x;\n} ele;\nstd::queue<ele> q;\nvoid suru() {\n  scanf(\"%d %d\", &n, &k);\n  scanf(\"%s %s\", w[0], w[1]);\n  for (int i = 0; i < n; i++) a[0][i] = a[1][i] = 0;\n  a[0][0] = 1;\n  s[0][0] = 0;\n  for (; q.size(); q.pop())\n    ;\n  q.push((ele){0, 0, 0});\n}\nvoid truli() {\n  while (q.size()) {\n    int s = q.front().s, lr = q.front().lr, x = q.front().x;\n    if (x + k >= n) break;\n    if (w[lr ^ 1][x + k] == '-' && a[lr ^ 1][x + k] == 0) {\n      a[lr ^ 1][x + k] = 1;\n      q.push((ele){s + 1, lr ^ 1, x + k});\n    }\n    if (w[lr][x + 1] == '-' && a[lr][x + 1] == 0) {\n      a[lr][x + 1] = 1;\n      q.push((ele){s + 1, lr, x + 1});\n    }\n    if (x - 1 >= 0 && w[lr][x - 1] == '-' && a[lr][x - 1] == 0 &&\n        s + 1 <= x - 1) {\n      a[lr][x - 1] = 1;\n      q.push((ele){s + 1, lr, x - 1});\n    }\n    q.pop();\n  }\n}\nvoid sutru() { puts(q.size() ? \"YES\" : \"NO\"); }\nint main() {\n  suru();\n  truli();\n  sutru();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n  int x, y, z;\n};\nnode q[200001];\nint n, m;\nbool ok[2][100001];\nchar s[100005];\nint main(void) {\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 0; i < 2; ++i) {\n    scanf(\"%s\", s + 1);\n    for (int j = 1; j <= n; ++j)\n      if (s[j] == '-') ok[i][j] = true;\n  }\n  bool flag = false;\n  q[1].x = 0;\n  q[1].y = 1;\n  q[1].z = 0;\n  int h = 1, e = 1;\n  ok[0][1] = false;\n  while (h <= e) {\n    node p = q[h];\n    ++h;\n    int i = p.x, j = p.y, k = p.z;\n    if (j <= k) continue;\n    if ((j + 1 > n) || (j + m > n)) {\n      flag = true;\n      break;\n    }\n    if (ok[i][j + 1]) {\n      ++e;\n      q[e].x = i;\n      q[e].y = j + 1;\n      q[e].z = k + 1;\n      ok[i][j + 1] = false;\n    }\n    if (ok[i ^ 1][j + m]) {\n      ++e;\n      q[e].x = i ^ 1;\n      q[e].y = j + m;\n      q[e].z = k + 1;\n      ok[i ^ 1][j + m] = false;\n    }\n    if (ok[i][j - 1]) {\n      ++e;\n      q[e].x = i;\n      q[e].y = j - 1;\n      q[e].z = k + 1;\n      ok[i][j - 1] = false;\n    }\n  }\n  if (flag)\n    printf(\"YES\\n\");\n  else\n    printf(\"NO\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint a[2][200005];\nchar ca[2][200005];\nusing namespace std;\nstruct ss {\n  int cnt;\n  int tag;\n} t1, t2, t3;\nqueue<struct ss> qq;\nint main() {\n  int n, i, j, k;\n  while (scanf(\"%d%d\", &n, &k) != EOF) {\n    scanf(\" %s\", ca[0]);\n    scanf(\" %s\", ca[1]);\n    memset(a, -1, sizeof(a));\n    a[0][0] = 0;\n    while (!qq.empty()) qq.pop();\n    t1.cnt = 0;\n    t1.tag = 0;\n    qq.push(t1);\n    int res = 0;\n    while (!qq.empty()) {\n      t2 = qq.front();\n      qq.pop();\n      t3 = t2;\n      t3.cnt = t2.cnt + 1;\n      if (a[t3.tag][t3.cnt] == -1 && ca[t3.tag][t3.cnt] == '-' && t3.cnt < n) {\n        if (a[t2.tag][t2.cnt] + 1 <= t3.cnt) {\n          a[t3.tag][t3.cnt] = a[t2.tag][t2.cnt] + 1;\n          qq.push(t3);\n        }\n      }\n      t3 = t2;\n      t3.cnt = t2.cnt - 1;\n      if (a[t3.tag][t3.cnt] == -1 && ca[t3.tag][t3.cnt] == '-' && t3.cnt >= 0) {\n        if (a[t2.tag][t2.cnt] + 1 <= t3.cnt) {\n          a[t3.tag][t3.cnt] = a[t2.tag][t2.cnt] + 1;\n          qq.push(t3);\n        }\n      }\n      t3 = t2;\n      t3.tag = !t2.tag;\n      t3.cnt = t2.cnt + k;\n      if (a[t3.tag][t3.cnt] == -1 && ca[t3.tag][t3.cnt] == '-' && t3.cnt < n) {\n        if (a[t2.tag][t2.cnt] + 1 <= t3.cnt) {\n          a[t3.tag][t3.cnt] = a[t2.tag][t2.cnt] + 1;\n          qq.push(t3);\n        }\n      }\n      if (t3.cnt >= n) {\n        res = 1;\n        break;\n      }\n    }\n    if (a[0][n - 1] >= 0 || a[1][n - 1] >= 0) {\n      res = 1;\n    }\n    if (res)\n      printf(\"YES\\n\");\n    else\n      printf(\"NO\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.awt.Point;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.Stack;\n\npublic class wallclimb {\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint canheight = scan.nextInt();\n\t\tint jumpheight = scan.nextInt();\n\t\tscan.nextLine();\n\t\t\n\t\tboolean[][] walls = new boolean[2][canheight];\n\t\t\n\t\tfor(int i = 0; i < 2; i++) {\n\t\t\tString scanned = scan.nextLine();\n\t\t\tString [] strs = scanned.split(\"\");\n\t\t\tfor(int j = 1; j < strs.length; j++) {\n\t\t\t\tif(strs[j].equals(\"-\")) {\n\t\t\t\t\twalls[i][j-1] = true;\n\t\t\t\t} else {\n\t\t\t\t\twalls[i][j-1] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tHashSet<Point> visited = new HashSet<Point>();\n\t\tpoint curr = new point(0,0,0);\n\t\tLinkedList<point> points = new LinkedList<point>();\n\t\t\n\t\tpoints.add(curr);\n\t\tvisited.add(curr.wallpoint);\n\t\t\n\t\twhile(!points.isEmpty()) {\n\t\t\tcurr = points.remove();\n\t\t\t//System.out.println(\"side \"+curr.wallpoint.x+\" height \"+curr.wallpoint.y+\" moves \"+curr.moves);\n\t\t\tif((curr.wallpoint.y + 1) >= canheight || (curr.wallpoint.y + jumpheight) >= canheight) {\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(walls[curr.wallpoint.x][curr.wallpoint.y+1] &&\n\t\t\t\t\t!visited.contains(new Point(curr.wallpoint.x,curr.wallpoint.y+1))) {\n\t\t\t\tpoint m = new point(curr.wallpoint.x, curr.wallpoint.y + 1, curr.moves+1);\n\t\t\t\tvisited.add(m.wallpoint);\n\t\t\t\tpoints.add(m);\n\t\t\t}\n\t\t\tif(walls[(curr.wallpoint.x + 1) % 2][curr.wallpoint.y+jumpheight] &&\n\t\t\t\t\t!visited.contains(new Point((curr.wallpoint.x + 1) % 2,curr.wallpoint.y+jumpheight))) {\n\t\t\t\tpoint m = new point((curr.wallpoint.x + 1) % 2, curr.wallpoint.y+jumpheight, curr.moves+1);\n\t\t\t\tvisited.add(m.wallpoint);\n\t\t\t\tpoints.add(m);\n\t\t\t}\n\t\t\tif(curr.wallpoint.y > 0 && walls[curr.wallpoint.x][curr.wallpoint.y-1] && (curr.wallpoint.y-1) >= curr.moves + 1 &&\n\t\t\t\t\t!visited.contains(new Point(curr.wallpoint.x, curr.wallpoint.y-1))) {\n\t\t\t\tpoint m = new point(curr.wallpoint.x, curr.wallpoint.y - 1, curr.moves+1);\n\t\t\t\tvisited.add(m.wallpoint);\n\t\t\t\tpoints.add(m);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tSystem.out.println(\"NO\");\n\t}\n}\n\nclass point {\n\tPoint wallpoint;\n\tint moves;\n\t\n\tpublic point(int side, int height, int moves) {\n\t\tthis.wallpoint = new Point(side, height);\n\t\tthis.moves = moves;\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class A implements Runnable{\n\tpublic static void main (String[] args) {new Thread(null, new A(), \"_cf\", 1 << 28).start();}\n\n\tpublic void run() {\n\t\tFastScanner fs = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tSystem.err.println(\"Go!\");\n\n\t\tint n = fs.nextInt();\n\t\tint k = fs.nextInt();\n\t\tchar[][] g = new char[2][n];\n\t\tfor(int i = 0; i < 2; i++) g[i] = fs.nextCharArray();\n\t\tPriorityQueue<Node> pq = new PriorityQueue<>();\n\t\tint[][] dist = new int[2][n + 1];\n\t\tint oo = (int)1e9;\n\t\tArrays.fill(dist[0], oo); Arrays.fill(dist[1], oo);\n\t\tdist[0][0] = 0;\n\t\tpq.add(new Node(0, 0, 0));\n\t\tint[] dx = {1, -1, 0, 0};\n\t\tint[] dy = {k,  k, 1, -1};\n\t\t\n\t\twhile(!pq.isEmpty()) {\n\t\t\tNode now = pq.poll();\n\t\t\tif(now.we > dist[now.i][now.j]) continue;\n\t\t\tif(now.we > now.j) continue;\n//\t\t\tSystem.out.println(now.i + \" \" + now.j + \" \" + now.we);\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tint nx = dx[i] + now.i;\n\t\t\t\tint ny = dy[i] + now.j;\n\t\t\t\tif(!good(nx, ny, 2, n)) {\n\t\t\t\t\tif(nx >= 0 && nx < 2 && ny >= n) {\n\t\t\t\t\t\tdist[nx][n] = Math.min(dist[nx][n], now.we + 1);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(g[nx][ny] == 'X') continue;\n\t\t\t\tint ndist = now.we + 1;\n\t\t\t\tif(dist[nx][ny] > ndist) {\n\t\t\t\t\tdist[nx][ny] = ndist;\n\t\t\t\t\tpq.add(new Node(nx, ny, ndist));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tboolean res = dist[0][n] < oo || dist[1][n] < oo;\n\t\tout.println(res ? \"YES\" : \"NO\");\n\t\t\n\t\tout.close();\n\t}\n\t\n\tboolean good (int x, int y, int n, int m) {\n\t\treturn x >= 0 && y >= 0 && x < n && y < m;\n\t}\n\t\n\tclass Node implements Comparable<Node> {\n\t\tint i, j, we;\n\t\tNode(int a, int c, int b) {\n\t\t\ti = a; j = c; we = b;\n\t\t}\n\t\tpublic int compareTo(Node o) {\n\t\t\treturn Integer.compare(we, o.we);\n\t\t}\n\t}\n\t\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tpublic FastScanner() {\n\t\t\ttry\t{\n\t\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n//\t\t\t\t                br = new BufferedReader(new FileReader(\"testdata.out\"));\n\t\t\t\tst = new StringTokenizer(\"\");\n\t\t\t} catch (Exception e){e.printStackTrace();}\n\t\t}\n\t\tpublic String next() {\n\t\t\tif (st.hasMoreTokens())\treturn st.nextToken();\n\t\t\ttry {st = new StringTokenizer(br.readLine());}\n\t\t\tcatch (Exception e) {e.printStackTrace();}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tpublic int nextInt() {return Integer.parseInt(next());}\n\t\tpublic long nextLong() {return Long.parseLong(next());}\n\t\tpublic double nextDouble() {return Double.parseDouble(next());}\n\n\t\tpublic String nextLine() {\n\t\t\tString line = \"\";\n\t\t\ttry {line = br.readLine();}\n\t\t\tcatch (Exception e) {e.printStackTrace();}\n\t\t\treturn line;\n\t\t}\n\t\tpublic Integer[] nextIntegerArray(int n) {\n\t\t\tInteger[] a = new Integer[n];\n\t\t\tfor(int i = 0; i < n; i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor(int i = 0; i < n; i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tpublic char[] nextCharArray() {return nextLine().toCharArray();}\n\t}\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class jumpingOnWallsCF {\n    public static void main (String[]args) throws IOException {\n        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n\n        StringTokenizer st = new StringTokenizer (f.readLine());\n\n        int wallLengths = Integer.parseInt(st.nextToken());\n        int jumpingLength = Integer.parseInt(st.nextToken());\n\n        char [] firstWall = new char [wallLengths];\n        char [] secondWall = new char [wallLengths];\n\n        st = new StringTokenizer (f.readLine());\n\n        String first = String.valueOf(st.nextToken());\n\n        for (int i = 0; i < wallLengths; i++) {\n            firstWall[i] = first.charAt(i);\n        }\n\n        st = new StringTokenizer(f.readLine());\n\n        String second = String.valueOf(st.nextToken());\n\n        for (int i = 0; i < wallLengths; i++) {\n            secondWall[i] = second.charAt(i);\n        }\n\n        boolean [] firstWallDP = new boolean [wallLengths];\n        boolean [] secondWallDP = new boolean [wallLengths];\n\n        Queue <Pair39> queue = new LinkedList <Pair39>();\n\n        Pair39 startingPair = new Pair39 (0, 0, -1);\n        queue.add(startingPair);\n\n        while (queue.isEmpty() == false) {\n            Pair39 currentPair = queue.poll();\n\n            int currentLocation = currentPair.location;\n            int array = currentPair.array;\n            int currentLevel = currentPair.waterLevel;\n\n            //System.out.println(currentLocation + \" \" + array + \" \" + currentLevel);\n\n            if ((currentLocation + 1 >= wallLengths) || (currentLocation + jumpingLength >= wallLengths)) {\n                System.out.println(\"YES\");\n                System.exit(0);\n            }\n\n            if ((currentLocation - 1 > currentLevel + 1) && (currentLocation - 1 >= 0)) {\n                if ((array == 0) && (firstWallDP[currentLocation - 1] == false)) {\n                    if (firstWall[currentLocation - 1] != 'X') {\n                        Pair39 newPair = new Pair39(currentLocation - 1, array, currentLevel + 1);\n                        queue.add(newPair);\n                        firstWallDP[currentLocation - 1] = true;\n                    }\n                }\n                else if ((array == 1) && (secondWallDP[currentLocation - 1] == false)) {\n                    if (secondWall[currentLocation - 1] != 'X') {\n                        Pair39 newPair = new Pair39(currentLocation - 1, array, currentLevel + 1);\n                        queue.add(newPair);\n                        secondWallDP[currentLocation - 1] = true;\n                    }\n                }\n            }\n\n            if ((array == 0) && (firstWallDP[currentLocation + 1] == false) && (firstWall[currentLocation + 1] != 'X')) {\n                Pair39 newPair = new Pair39 (currentLocation + 1, array, currentLevel + 1);\n                queue.add(newPair);\n                firstWallDP[currentLocation + 1] = true;\n            }\n            \n            if ((array == 1) && (secondWallDP[currentLocation + 1] == false) && (secondWall[currentLocation + 1] != 'X')) {\n                Pair39 newPair = new Pair39 (currentLocation + 1, array, currentLevel + 1);\n                queue.add(newPair);\n                secondWallDP[currentLocation + 1] = true;\n            }\n\n            if ((array == 0) && (secondWallDP[currentLocation + jumpingLength] == false) && (secondWall[currentLocation + jumpingLength] != 'X')) {\n                Pair39 newPair = new Pair39 (currentLocation + jumpingLength, 1, currentLevel + 1);\n                queue.add(newPair);\n                secondWallDP[currentLocation + jumpingLength] = true;\n            }\n\n            if ((array == 1) && (firstWallDP[currentLocation + jumpingLength] == false) && (firstWall[currentLocation + jumpingLength] != 'X')) {\n                Pair39 newPair = new Pair39 (currentLocation + jumpingLength, 0, currentLevel + 1);\n                queue.add(newPair);\n                firstWallDP[currentLocation + jumpingLength] = true;\n            }\n        }\n\n        System.out.println(\"NO\");\n\n        f.close();\n    }\n}\n\nclass Pair39  {\n    int location;\n    int array;\n    int waterLevel;\n\n    public Pair39(int location, int array, int waterLevel) {\n        this.location = location;\n        this.array = array;\n        this.waterLevel = waterLevel;\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k, d[5][100050], dd[5][100050];\nchar a[5][100050];\nvoid bfs(int x, int y) {\n  queue<pair<long long, pair<long long, long long> > > qp;\n  int tg = 0;\n  qp.push(pair<long long, pair<long long, long long> >(\n      tg, pair<long long, long long>(x, y)));\n  dd[x][y] = 0;\n  while (qp.size() != 0) {\n    int u, v, u1, v1;\n    u = qp.front().second.first;\n    v = qp.front().second.second;\n    tg = qp.front().first;\n    qp.pop();\n    if (v + k > n || v + 1 > n) {\n      cout << \"YES\";\n      exit(0);\n    }\n    u1 = u;\n    v1 = v + 1;\n    if (a[u1][v1] != 'X') {\n      if (dd[u1][v1] > dd[u][v] + 1) {\n        dd[u1][v1] = dd[u][v] + 1;\n        qp.push(pair<long long, pair<long long, long long> >(\n            dd[u1][v1], pair<long long, long long>(u1, v1)));\n      }\n    }\n    if (u == 1) {\n      u1 = u + 1;\n      v1 = v + k;\n      if (a[u1][v1] != 'X') {\n        if (dd[u1][v1] > dd[u][v] + 1) {\n          dd[u1][v1] = dd[u][v] + 1;\n          qp.push(pair<long long, pair<long long, long long> >(\n              dd[u1][v1], pair<long long, long long>(u1, v1)));\n        }\n      }\n    }\n    if (u == 2) {\n      u1 = u - 1;\n      v1 = v + k;\n      if (a[u1][v1] != 'X') {\n        if (dd[u1][v1] > dd[u][v] + 1) {\n          dd[u1][v1] = dd[u][v] + 1;\n          qp.push(pair<long long, pair<long long, long long> >(\n              dd[u1][v1], pair<long long, long long>(u1, v1)));\n        }\n      }\n    }\n    if (tg != 0 && tg + 1 < v - 1 && a[u][v - 1] != 'X') {\n      u1 = u;\n      v1 = v - 1;\n      if (a[u1][v1] != 'X') {\n        if (dd[u1][v1] > dd[u][v] + 1) {\n          dd[u1][v1] = dd[u][v] + 1;\n          qp.push(pair<long long, pair<long long, long long> >(\n              dd[u1][v1], pair<long long, long long>(u1, v1)));\n        }\n      }\n    }\n  }\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 1; i <= 2; i++) {\n    for (int j = 1; j <= n; j++) {\n      cin >> a[i][j];\n    }\n  }\n  memset(dd, 10, sizeof(dd));\n  bfs(1, 1);\n  cout << \"NO\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1e3;\nconst long long MAXN = 1e5 + 100;\nlong long n, k, Dis[2][MAXN];\nchar a[2][MAXN];\nvector<pair<long long, long long> > adj[2][MAXN];\nbool val(long long x, long long y) {\n  return a[x][y] == '-' && x < 2 && x >= 0 && y < n && y >= 0;\n}\nvoid bfs(long long x, long long y) {\n  for (long long i = 0; i < 2; i++)\n    for (long long j = 0; j < n; j++) Dis[i][j] = INF;\n  Dis[x][y] = 0;\n  queue<pair<long long, long long> > q;\n  q.push({x, y});\n  while (!q.empty()) {\n    pair<long long, long long> pi;\n    pi = q.front();\n    q.pop();\n    long long u = pi.first, v = pi.second;\n    for (auto t : adj[u][v]) {\n      if (Dis[t.first][t.second] == INF) {\n        if (Dis[u][v] + 1 <= t.second)\n          Dis[t.first][t.second] = Dis[u][v] + 1, q.push({t.first, t.second});\n      }\n    }\n  }\n}\nvoid check_adj() {\n  for (long long i = 0; i < 2; i++) {\n    for (long long j = 0; j < n; j++) {\n      cout << \"-------\\n\";\n      cout << i + 1 << \" \" << j + 1 << endl;\n      for (auto x : adj[i][j])\n        cout << x.first + 1 << \" \" << x.second + 1 << endl;\n    }\n  }\n}\nvoid check() {\n  for (long long i = 0; i < 2; i++) {\n    for (long long j = 0; j < n; j++) cout << Dis[i][j] << \" \";\n    cout << endl;\n  }\n}\nint main() {\n  cin >> n >> k;\n  for (long long i = 0; i < 2; i++)\n    for (long long j = 0; j < n; j++) cin >> a[i][j];\n  for (long long i = 0; i < 2; i++) {\n    for (long long j = 0; j < n; j++) {\n      if (val(i, j - 1)) adj[i][j].push_back({i, j - 1});\n      if (val(i, j + 1)) adj[i][j].push_back({i, j + 1});\n      if (val(i + 1, j + k)) adj[i][j].push_back({i + 1, j + k});\n      if (val(i - 1, j + k)) adj[i][j].push_back({i - 1, j + k});\n    }\n  }\n  bfs(0, 0);\n  bool isAns = false;\n  for (long long i = 0; i < 2; i++) {\n    for (long long j = n - 1; j >= n - k; j--) {\n      if (Dis[i][j] != INF) isAns = true;\n    }\n  }\n  if (isAns)\n    cout << \"YES\";\n  else\n    cout << \"NO\";\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\npublic class Graph {\n\n\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tStringTokenizer st;\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tString next() {\n\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tlong nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tGraph ob = new Graph();\n\t\tob.run();\n\t}\n\t\n\tint n ;\n\tint k ;\n\tchar[][] wall;\n\tboolean[][] visited;\n\tprivate void run() {\n\t\tn = nextInt();\n\t\tk = nextInt();\n\t\twall = new char[2][];\n\t\tvisited = new boolean[2][n];\n\t\twall[0] = next().toCharArray();\n\t\twall[1] = next().toCharArray();\n\t\t\n\t\t\n\t\tout.println(bfs()? \"YES\":\"NO\");\n\t\tout.close();\n\t}\n\t \n\tprivate boolean bfs() {\n\t\tQueue<Node> queue = new ArrayDeque<>();\n\t\tif(wall[0][0]=='-') {\n\t\t\tqueue.add(new Node(0,0,-1));\n\t\t}\n\t\t\n\t\twhile(!queue.isEmpty()) {\n\t\t\tNode node = queue.poll();\n\t\t\tint i= node.index;\n\t\t\tint w = node.wall;\n\t\t\tint level = node.level;\n\t\t\tif(visited[w][i]) continue;\n//\t\t\tout.println(node);\n\t\t\tvisited[w][i] = true;\n\t\t\tif(i+k>=n || i+1>=n) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif(i+1<n && wall[w][i+1]=='-' && !visited[w][i+1] && i>level) {// 1 UP\n\t\t\t\tqueue.offer(new Node(w, i+1, level+1));\n\t\t\t}\n\t\t\tif(i-1>level && wall[w][i-1]=='-' && !visited[w][i-1]) {// 1 DOWN\n\t\t\t\tqueue.offer(new Node(w, i-1, level+1));\n\t\t\t}\n\t\t\tif(i+k<n && wall[1-w][i+k]=='-' && !visited[1-w][i+k] && i>level) {//k JUMP OPP\n\t\t\t\tqueue.offer(new Node(1-w, i+k, level+1));\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n}\nclass Node{\n\tint wall;//0,1\n\tint index;\n\tint level;\n\tpublic Node(int wall, int index, int level) {\n\t\tthis.wall=wall;\n\t\tthis.index=index;\n\t\tthis.level=level;\n\t}\n//\t@Override\n//\tpublic String toString() {\n//\t\treturn \"[ \" + wall + \", \" + index + \", \" + level + \"]\";\n//\t}\n\t\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<string> s;\nvector<vector<int> > dp;\nlong long n, k;\nbool cal(int str, int ind) {\n  queue<pair<int, int> > q;\n  q.push({0, 0});\n  int water = 0;\n  while (q.size()) {\n    int len = q.size();\n    while (len--) {\n      str = q.front().first;\n      ind = q.front().second;\n      q.pop();\n      if (ind + k >= n) return true;\n      if (ind < water) {\n        continue;\n      }\n      if (dp[str][ind]) continue;\n      dp[str][ind] = 1;\n      if ((ind + 1 < n) && ((s[str][ind + 1] == '-'))) q.push({str, ind + 1});\n      if (ind - 1 >= 0 && s[str][ind - 1] == '-') q.push({str, ind - 1});\n      if (ind + k < n && s[(str == 1) ? 0 : 1][ind + k] == '-')\n        q.push({((str == 1) ? 0 : 1), ind + k});\n    }\n    ++water;\n  }\n  return false;\n}\nint main() {\n  cin >> n >> k;\n  s.resize(2);\n  cin >> s[0] >> s[1];\n  dp.resize(2, (vector<int>(n, 0)));\n  if (cal(0, 0))\n    cout << \"YES\" << endl;\n  else\n    cout << \"NO\" << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic class Main{\n\tstatic char a[][];\n\tstatic int t[][];\n\tstatic int n;\n\tstatic int k;\n\tstatic int w=1;\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tn=sc.nextInt();\n\t\tk=sc.nextInt();\n\t\t\n\t\t\n\t\ta=new char[2][n+k+10];\n\t\tt=new int[2][n+k+10];\n\t\tfor(int i=0;i<2;i++) {\n\t\t\tchar c[]=sc.next().toCharArray();\n\t\t\ta[i][0]='X';\n\t\t\tfor(int j=0;j<c.length;j++) {\n\t\t\t\ta[i][j+1]=c[j];\n\t\t\t}\n\t\t\n\t\t}\n\t\t//System.out.println(Arrays.toString(a[0]));\n\t\t//System.out.println(Arrays.toString(a[1]));\n\t\tif(D(0,1)) {\n\t\t\tSystem.out.println(\"YES\");\n\t\t}else {\n\t\t\tSystem.out.println(\"NO\");\n\t\t}\n\t\t\n\t\t\n\t}\n\tpublic static boolean D(int pos,int cur) {\n\t\t//System.out.println(\"pos = \"+pos+\", cur = \"+cur+\",w = \"+w);\n\t\tif(cur>n) {\n\t\t\treturn true;\n\t\t}\n\t\tif(a[pos][cur]=='X'||t[pos][cur]==1||w>cur) {\n\t\t\treturn false;\n\t\t}\n\t\tt[pos][cur]=1;\n\t\tw++;\n\t\tboolean T=false;\n\t\tif(D(pos,cur-1)==true||D(1-pos,cur+k)==true||D(pos,cur+1)==true) {\n\t\t\tT=true;\n\t\t}\n\t\t\t\n\t\tw--;\n\t\treturn T;\n\t}\n\t \n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.math.RoundingMode;\nimport java.text.DecimalFormat;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\npublic class Main {\n\n    final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer tok = new StringTokenizer(\"\");\n\n    void init() throws FileNotFoundException {\n        if (ONLINE_JUDGE) {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        } else {\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new PrintWriter(\"output.txt\");\n        }\n    }\n\n    String readString() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n\n    int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n\n    long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n\n    double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n        // Sworn to fight and die\n    }\n\n    public static void mergeSort(int[] a) {\n        mergeSort(a, 0, a.length - 1);\n    }\n\n    private static void mergeSort(int[] a, int levtIndex, int rightIndex) {\n        final int MAGIC_VALUE = 50;\n        if (levtIndex < rightIndex) {\n            if (rightIndex - levtIndex <= MAGIC_VALUE) {\n                insertionSort(a, levtIndex, rightIndex);\n            } else {\n                int middleIndex = (levtIndex + rightIndex) / 2;\n                mergeSort(a, levtIndex, middleIndex);\n                mergeSort(a, middleIndex + 1, rightIndex);\n                merge(a, levtIndex, middleIndex, rightIndex);\n            }\n        }\n    }\n\n    private static void merge(int[] a, int levtIndex, int middleIndex,\n                              int rightIndex) {\n        int length1 = middleIndex - levtIndex + 1;\n        int length2 = rightIndex - middleIndex;\n        int[] levtArray = new int[length1];\n        int[] rightArray = new int[length2];\n        System.arraycopy(a, levtIndex, levtArray, 0, length1);\n        System.arraycopy(a, middleIndex + 1, rightArray, 0, length2);\n        for (int k = levtIndex, i = 0, j = 0; k <= rightIndex; k++) {\n            if (i == length1) {\n                a[k] = rightArray[j++];\n            } else if (j == length2) {\n                a[k] = levtArray[i++];\n            } else {\n                a[k] = levtArray[i] <= rightArray[j] ? levtArray[i++]\n                        : rightArray[j++];\n            }\n        }\n    }\n\n    private static void insertionSort(int[] a, int levtIndex, int rightIndex) {\n        for (int i = levtIndex + 1; i <= rightIndex; i++) {\n            int current = a[i];\n            int j = i - 1;\n            while (j >= levtIndex && a[j] > current) {\n                a[j + 1] = a[j];\n                j--;\n            }\n            a[j + 1] = current;\n        }\n    }\n\n    public void run() {\n        try {\n            long t1 = System.currentTimeMillis();\n            init();\n            solve();\n            out.close();\n            long t2 = System.currentTimeMillis();\n            System.err.println(\"Time = \" + (t2 - t1));\n        } catch (Exception e) {\n            e.printStackTrace(System.err);\n            System.exit(-1);\n        }\n    }\n\n\n\n    class LOL implements Comparable<LOL> {\n\n        int x;\n        int y;\n\n\n\n        public LOL(int x, int y) {\n            this.x = x;\n            this.y = y;\n\n        }\n\n        @Override\n        public int compareTo(LOL o) {\n\n            return (x - o.x); // ---->\n            //return o.x * o.y - x * y; // <----\n        }\n\n    }\n\n    class LOL2 implements Comparable<LOL2> {\n\n        int x;\n        int y;\n        int z;\n\n\n\n        public LOL2(int x, int y, int z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }\n\n        @Override\n        public int compareTo(LOL2 o) {\n\n            return (z - o.z); // ---->\n            //return o.x * o.y - x * y; // <----\n        }\n\n    }\n\n    class test implements Comparable<test> {\n\n        long x;\n        long y;\n\n\n\n        public test(long x, long y) {\n            this.x = x;\n            this.y = y;\n\n        }\n\n        @Override\n        public int compareTo(test o) {\n            //int compareResult = Long.compare(y, o.y); // ---->\n\n            //if (compareResult != 0) {\n            //    return -compareResult;\n            //}\n\n            int compareResult = Long.compare(x, o.x);\n\n            if (compareResult != 0) {\n                return compareResult;\n            }\n\n            return Long.compare(y, o.y);\n\n            //return o.x * o.y - x * y; // <----\n        }\n\n    }\n\n    class data {\n        String name;\n        String city;\n\n        data(String name, String city) {\n            this.city = city;\n            this.name = name;\n        }\n    }\n\n    class Point {\n        double x;\n        double y;\n\n\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n\n        }\n\n        double distance(Point temp) {\n            return Math.sqrt((x - temp.x) * (x - temp.x) + (y - temp.y) * (y - temp.y));\n        }\n\n        double sqrDist(Point temp) {\n            return ((x - temp.x) * (x - temp.x) + (y - temp.y) * (y - temp.y));\n        }\n\n        Point rotate(double alpha) {\n            return new Point(x * cos(alpha) - y * sin(alpha), x * sin(alpha) + y * cos(alpha));\n        }\n\n        void sum(Point o) {\n            x += o.x;\n            y += o.y;\n        }\n\n        void scalarProduct(int alpha) {\n            x *= alpha;\n            y *= alpha;\n        }\n\n    }\n\n    class Line {\n        double a;\n        double b;\n        double c;\n\n        Line(Point A, Point B) {\n            a = B.y - A.y;\n            b = A.x - B.x;\n            c = -A.x * a - A.y * b;\n        }\n        Line(double a, double b, double c) {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n\n      Point intersection(Line o) {\n            double det = a * o.b - b * o.a;\n            double det1 = -c * o.b + b * o.c;\n            double det2 = -a * o.c + c * o.a;\n            return new Point(det1 / det, det2 / det);\n        }\n    }\n\n /*   class Plane {\n        double a;\n        double b;\n        double c;\n        double d;\n\n        Plane (Point fir, Point sec, Point thi) {\n            double del1 = (sec.y - fir.y) * (thi.z - fir.z) - (thi.y - fir.y) * (sec.z - fir.z);\n            double del2 = (thi.x - fir.x) * (sec.z - fir.z) - (thi.z - fir.z) * (sec.x - fir.x);\n            double del3 = (thi.y - fir.y) * (sec.x - fir.x) - (thi.x - fir.x) * (sec.y - fir.y);\n            a = del1;\n            b = del2;\n            c = del3;\n            d = -fir.x * del1 - fir.y * del2 - fir.z * del3;\n        }\n\n        double distance(Point point) {\n            return abs(a * point.x + b * point.y + c * point.z + d) / sqrt(a * a + b * b + c * c);\n        }\n\n\n    } */\n\n    class record implements Comparable<record> {\n        String city;\n        Long score;\n\n        public record(String name, Long score) {\n            this.city = name;\n            this.score = score;\n        }\n\n        @Override\n        public int compareTo(record o) {\n            if (o.city.equals(city)) {\n                return 0;\n            }\n\n            if (score.equals(o.score)) {\n                return 1;\n            }\n\n            if (score > o.score) {\n                return 666;\n            } else {\n                return -666;\n            }\n\n            //return Long.compare(score, o.score);\n\n        }\n\n    }\n\n    public long gcd(long a, long b) {\n        if (a == 0 || b == 0) return max(a, b);\n\n        if (a % b == 0)\n            return b;\n        else\n            return gcd(b, a % b);\n    }\n\n    boolean prime(long n) {\n        if (n == 1) return false;\n        for (int i = 2; i <= sqrt(n); i++)\n            if (n % i == 0)\n                return false;\n        return true;\n    }\n\n    public int sum(long n) {\n        int s = 0;\n\n        while (n > 0) {\n            s += (n % 10);\n            n /= 10;\n        }\n\n        return s;\n\n    }\n\n /*   public void simulation(int k) {\n        long ans = 0;\n        int start = 1;\n        for (int i = 0; i < k; i++) {\n            start *= 10;\n        }\n        for (int i = start/10; i < start; i++) {\n            int locAns = 0;\n            for (int j = start/10; j < start; j++) {\n                if  (sum(i + j) == sum(i) + sum(j) ) {\n                    ans += 1;\n                    locAns += 1;\n                } else {\n                    //.println(i + \"!!!\" + j);\n                }\n            }\n            //out.println(i + \" \" + locAns);\n        }\n        out.println(ans);\n    }*/\n\n\n    int n;\n\n    ArrayList<Integer> primes;\n    boolean[] isPrime;\n\n    public void getPrimes (int n) {\n        isPrime[0] = false;\n        isPrime[1] = false;\n        for (int i = 2; i <= n; i++) {\n            if (isPrime[i]) {\n                primes.add(i);\n                if (1l * i * i <= n) {\n                    for (int j = i * i; j <= n; j += i) {\n                        isPrime[j] = false;\n                    }\n                }\n            }\n        }\n    }\n\n\n\n\n    public long binPowMod(long a, long b, long mod) {\n        if (b == 0) {\n            return 1 % mod;\n        }\n\n        if (b % 2 != 0) {\n            return ((a % mod) * (binPowMod(a, b - 1, mod) % mod)) % mod;\n        } else {\n            long temp = binPowMod(a, b / 2, mod) % mod;\n            long ans = (temp * temp) % mod;\n            return ans;\n\n        }\n    }\n\n\n    int type[];\n    boolean vis[];\n\n    HashMap<Integer, HashSet<Integer>> g;\n\n    int componentNum[];\n\n  /*  void dfs(int u, int numOfComponent) {\n        vis[u] = true;\n        componentNum[u] = numOfComponent;\n\n        for (Integer v: g.get(u)) {\n            if (!vis[v]) {\n                dfs(v, numOfComponent);\n            }\n        }\n    } */\n\n    int p[];\n\n    int find(int x) {\n        if (x == p[x]) {\n            return x;\n        }\n\n        return p[x] = find(p[x]);\n    }\n\n    boolean merge(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (p[x] == p[y]) {\n            return false;\n        }\n        p[y] = x;\n        return true;\n    }\n\n    class Trajectory {\n        double x0;\n        double y0;\n        double vx;\n        double vy;\n\n\n        Trajectory(double vx, double vy, double x0, double y0) {\n            this.vx = vx;\n            this.vy = vy;\n\n            this.x0 = x0;\n            this.y0 = y0;\n        }\n\n        double y (double x) {\n            return y0 + (x - x0) * (vy / vx) - 5 * (x - x0) * (x - x0) / (vx * vx);\n        }\n\n        double der(double x) {\n            return (vy / vx) - 10 * (x - x0) / (vx * vx);\n        }\n\n\n    }\n\n\n    public void solve() throws IOException {\n\n        int n = readInt();\n        int k = readInt();\n\n        char[][] maze = new char[4][n + 1];\n\n        maze[1][0] = 'X';\n        maze[2][0] = 'X';\n\n        for (int i = 0; i < n + 1; i++) {\n            maze[0][i] = 'X';\n            maze[3][i] = 'X';\n        }\n\n        String temp1 = readString();\n        String temp2 = readString();\n\n        for (int i = 1; i <= n; i++) {\n            maze[1][i] = temp1.charAt(i - 1);\n            maze[2][i] = temp2.charAt(i - 1);\n        }\n\n        int[][] dist = new int[4][n + 1];\n        int[][] time = new int[4][n + 1];\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < n + 1; j++) {\n                dist[i][j] = Integer.MAX_VALUE;\n            }\n        }\n\n        dist[1][1] = 0;\n\n        ArrayDeque<Integer> xValue = new ArrayDeque<Integer>();\n        ArrayDeque<Integer> yValue = new ArrayDeque<Integer>();\n\n        xValue.add(1);\n        yValue.add(1);\n        int t = 1;\n        while (!xValue.isEmpty()) {\n\n            int currX = xValue.poll();\n            int currY = yValue.poll();\n\n            if (currY + 1 > n || currY + k > n) {\n                out.print(\"YES\");\n                return;\n            }\n\n            if ((dist[currX][currY + 1] > dist[currX][currY] + 1) && maze[currX][currY + 1] == '-') {\n                dist[currX][currY + 1] = dist[currX][currY] + 1;\n                xValue.add(currX);\n                yValue.add(currY + 1);\n                time[currX][currY + 1] = time[currX][currY] + 1;\n            }\n\n            if ((dist[currX][currY - 1] > dist[currX][currY] + 1) && maze[currX][currY - 1] == '-' && currY - 1 > time[currX][currY] + 1) {\n\n                dist[currX][currY - 1] = dist[currX][currY] + 1;\n                xValue.add(currX);\n                yValue.add(currY - 1);\n                time[currX][currY - 1] = time[currX][currY] + 1;\n            }\n\n            if ((dist[3 - currX][currY + k] > dist[currX][currY] + 1) && maze[3 - currX][currY + k] == '-') {\n                dist[3 - currX][currY + k] = dist[currX][currY] + 1;\n                xValue.add(3 - currX);\n                yValue.add(currY + k);\n                time[3 - currX][currY + k] = time[currX][currY] + 1;\n            }\n\n\n\n        }\n\n        out.print(\"NO\");\n\n\n    }\n\n\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class B198{\n\n\tint ptr = 0;\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni(), k = ni();\n\t\tchar[] l = ca(n);\n\t\tchar[] r = ca(n);\n\t\t\n\t\tint[] ls = new int[n];\n\t\tint[] rs = new int[n];\n\t\tArrays.fill(ls, Integer.MAX_VALUE/2);\n\t\tArrays.fill(rs, Integer.MAX_VALUE/2);\n\t\tls[0] = -1;\n\t\tint[] q = new int[10*n];\n\t\tq[0] = 0;\n\t\tptr = 1;\n\t\tfor(int i=0;i<ptr;i++)\n\t\t{\n\t\t\tif(q[i] >= 0) //left\n\t\t\t{\n\t\t\t\tif(ls[q[i]] >= q[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tif(q[i]+1 >= n)\n\t\t\t\t{\n\t\t\t\t\tout.println(\"YES\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(i > 0 && l[q[i]-1]=='-' && ls[q[i]] + 1 < ls[q[i]-1])\n\t\t\t\t{\n\t\t\t\t\tls[q[i]-1] = ls[q[i]] + 1;\n\t\t\t\t\tq[ptr++] = q[i] - 1;\n\t\t\t\t}\n\t\t\t\tif(l[q[i]+1]=='-' && ls[q[i]] + 1 < ls[q[i] + 1])\n\t\t\t\t{\n\t\t\t\t\tls[q[i]+1] = ls[q[i]] + 1;\n\t\t\t\t\tq[ptr++] = q[i] + 1;\n\t\t\t\t}\n\t\t\t\tif(q[i] + k >= n)\n\t\t\t\t{\n\t\t\t\t\tout.println(\"YES\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(r[q[i]+k] == '-' && ls[q[i]] + 1 < rs[q[i]+k])\n\t\t\t\t{\n\t\t\t\t\trs[q[i]+k] = ls[q[i]] + 1;\n\t\t\t\t\tq[ptr++] = ~(q[i] + k);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint now = ~q[i];\n\t\t\t\tif(rs[now] >= now)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(now + 1 >= n)\n\t\t\t\t{\n\t\t\t\t\tout.println(\"YES\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(r[now-1] == '-' && rs[now-1] > rs[now] + 1)\n\t\t\t\t{\n\t\t\t\t\trs[now-1] = rs[now] + 1;\n\t\t\t\t\tq[ptr++] = ~(now-1);\n\t\t\t\t}\n\t\t\t\tif(r[now+1] =='-' && rs[now+1] > rs[now] + 1)\n\t\t\t\t{\n\t\t\t\t\trs[now+1] = rs[now] + 1;\n\t\t\t\t\tq[ptr++] = ~(now+1);\n\t\t\t\t}\n\t\t\t\tif(now + k >= n)\n\t\t\t\t{\n\t\t\t\t\tout.println(\"YES\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(l[now+k] == '-' && rs[now] + 1 < ls[now+k])\n\t\t\t\t{\n\t\t\t\t\tls[now+k] = rs[now] + 1;\n\t\t\t\t\tq[ptr++] = now + k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(\"NO\");\n\t\t//out.println(ptr);\n\t}\n\t\n\tpublic static void main(String[] args){new B198().run();}\n\t\n\tprivate byte[] bufferArray = new byte[1024];\n\tprivate int bufLength = 0;\n\tprivate int bufCurrent = 0;\n\tInputStream inputStream;\n\tPrintWriter out;\n\t\n\tpublic void run()\n\t{\n\t\tinputStream = System.in;\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();//out.println(ptr);\n\t\tout.flush();\n\t}\n\t\n\tint nextByte()\n\t{\n\t\tif(bufLength==-1)\n\t\t\tthrow new InputMismatchException();\n\t\tif(bufCurrent>=bufLength)\n\t\t{\n\t\t\tbufCurrent = 0;\n\t\t\ttry\n\t\t\t{bufLength = inputStream.read(bufferArray);}\n\t\t\tcatch(IOException e)\n\t\t\t{ throw new InputMismatchException();}\n\t\t\tif(bufLength<=0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn bufferArray[bufCurrent++];\n\t}\n\t\n\tboolean isSpaceChar(int x)\n\t{return (x<33 || x>126);}\n\t\n\tboolean isDigit(int x)\n\t{return (x>='0' && x<='9');}\n\t\n\tint nextNonSpace()\n\t{\n\t\tint x;\n\t\twhile((x=nextByte())!=-1 && isSpaceChar(x));\n\t\treturn x;\n\t}\n\t\n\tint ni()\n\t{\n\t\tlong ans = nl();\n\t\tif ( Integer.MIN_VALUE <= ans && ans <= Integer.MAX_VALUE )\n\t\t\treturn (int)ans;\n\t\tthrow new InputMismatchException();\n\t}\n\t\n\tlong nl()\n\t{\n\t\tlong ans = 0;\n\t\tboolean neg = false;\n\t\tint x = nextNonSpace();\n\t\tif(x=='-') \n\t\t{\n\t\t\tneg = true;\n\t\t\tx = nextByte();\n\t\t}\n\t\twhile(!isSpaceChar(x))\n\t\t{\n\t\t\tif(isDigit(x))\n\t\t\t{\n\t\t\t\tans = ans*10 + x -'0';\n\t\t\t\tx = nextByte();\n\t\t\t}\n\t\t\telse\n\t\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\treturn neg ? -ans:ans;\n\t}\n\t\n\tString ns()\n\t{\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint x = nextNonSpace();\n\t\twhile(!isSpaceChar(x))\n\t\t{\n\t\t\tsb.append((char)x);\n\t\t\tx = nextByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tchar nc()\n\t{ return (char)nextNonSpace();}\n\t\n\tdouble nd()\n\t{ return (double)Double.parseDouble(ns()); }\n\t\n\tchar[] ca()\n\t{ return ns().toCharArray();}\n\t\n\tchar[] ca(int n)\n\t{\n\t\tchar[] ans = new char[n];\n\t\tint p =0;\n\t\tint x = nextNonSpace();\n\t\twhile(p<n)\n\t\t{\n\t\t\tans[p++] = (char)x;\n\t\t\tx = nextByte();\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tint[] ia(int n)\n\t{\n\t\tint[] ans = new int[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tans[i]=ni();\n\t\treturn ans;\n\t}\n\t\n}\n"
        },
        {
            "language": 1,
            "solution": "from collections import deque\nimport sys\n\nread_ints = lambda f: [int(num) for num in f.readline().split()]\nf = open(sys.argv[1]) if len(sys.argv) > 1 else sys.stdin\n\nn, jump = read_ints(f)\n\nleft_wall = ' ' + f.readline().strip()\nright_wall = ' ' + f.readline().strip()\n\ndef is_possible():\n    visited = set()\n    stack = deque()\n    stack.append((\"L\", 1, 0))\n\n    while len(stack) > 0:\n        wall, height, time = stack.pop()\n        #print wall, height, time\n        if height > n:\n            return True\n\n        visited.add((wall, height))\n        for w, h, t in possible_moves(wall, height, time):\n            if (w, h) not in visited:\n                stack.append((w, h, t))\n\ndef possible_moves(wall, height, time):\n    curr_wall, other_wall = left_wall, right_wall\n    curr_wall_label, other_wall_label = \"L\", \"R\"\n    if wall == \"R\":\n        curr_wall, other_wall = other_wall, curr_wall\n        curr_wall_label, other_wall_label = other_wall_label, curr_wall_label\n\n    # move up on the curr wall\n    if len(curr_wall) <= height + 1 \\\n            or curr_wall[height + 1] == '-':\n        yield (curr_wall_label, height + 1, time + 1)\n\n    # jump to the other wall\n    if len(other_wall) <= height + jump \\\n            or other_wall[height + jump] == '-':\n        yield (other_wall_label, height + jump, time + 1)\n\n    # move down (if it's possible)\n    if 1 < height < len(curr_wall) and height - 1 > time + 1 \\\n            and curr_wall[height - 1] == '-':\n        yield (curr_wall_label, height - 1, time + 1)\n\nif is_possible():\n    print \"YES\"\nelse:\n    print \"NO\"\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3F3F3F3F;\nint n, k;\nconst int M = 100010;\nchar a[2][M];\nint dist[2][M];\nbool vis[2][M];\nvoid bfs(int x, int y) {\n  memset(vis, false, sizeof(vis));\n  memset(dist, 0x3F, sizeof(dist));\n  queue<pair<int, int> > q;\n  dist[x][y] = 0;\n  q.push(make_pair(x, y));\n  while (!q.empty()) {\n    pair<int, int> f = q.front();\n    q.pop();\n    int x = f.first, y = f.second;\n    if (vis[x][y]) continue;\n    vis[x][y] = true;\n    if (dist[x][y] > y) continue;\n    if (y + 1 >= n or y + k >= n) {\n      printf(\"YES\\n\");\n      return;\n    }\n    if (y + 1 < n and a[x][y + 1] != 'X')\n      dist[x][y + 1] = min(dist[x][y + 1], dist[x][y] + 1),\n                  q.push(make_pair(x, y + 1));\n    if (y - 1 >= 0 and a[x][y - 1] != 'X')\n      dist[x][y - 1] = min(dist[x][y - 1], dist[x][y] + 1),\n                  q.push(make_pair(x, y - 1));\n    int x2 = (x + 1) % 2;\n    if (y + k < n and a[x2][y + k] != 'X')\n      dist[x2][y + k] = min(dist[x2][y + k], dist[x][y] + 1),\n                   q.push(make_pair(x2, y + k));\n  }\n  printf(\"NO\\n\");\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  scanf(\"%s%s\", a[0], a[1]);\n  bfs(0, 0);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, cnt;\nvector<string> s(2);\nvector<vector<bool>> a(2, vector<bool>(1e6));\nvoid dfs(int x, int y) {\n  if (s[x][y] != '-' || a[x][y] || y < cnt) return;\n  if (y + k >= n) {\n    cout << \"YES\";\n    exit(0);\n  }\n  cnt++;\n  a[x][y] = 1;\n  dfs(1 - x, y + k);\n  dfs(x, y + 1);\n  dfs(x, y - 1);\n  cnt--;\n}\nint main() {\n  cin >> n >> k >> s[0] >> s[1];\n  dfs(0, 0);\n  cout << \"NO\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, x, y, fi, fr, f[2][100100], qx[200200], qy[200200];\nchar s[2][100100];\nint main() {\n  cin >> n >> k;\n  scanf(\"%s\", s[0]);\n  scanf(\"%s\", s[1]);\n  f[0][0] = 1;\n  for (fr = 1; fi < fr;) {\n    x = qx[fi];\n    y = qy[fi++];\n    if (y >= n - k) {\n      puts(\"YES\");\n      return 0;\n    }\n    if (y > 0 && s[x][y - 1] == '-' && f[x][y - 1] == 0 && y > f[x][y]) {\n      f[x][y - 1] = f[x][y] + 1;\n      qx[fr] = x;\n      qy[fr++] = y - 1;\n    }\n    if (s[x][y + 1] == '-' && f[x][y + 1] == 0) {\n      f[x][y + 1] = f[x][y] + 1;\n      qx[fr] = x;\n      qy[fr++] = y + 1;\n    }\n    if (s[1 - x][y + k] == '-' && f[1 - x][y + k] == 0) {\n      f[1 - x][y + k] = f[x][y] + 1;\n      qx[fr] = 1 - x;\n      qy[fr++] = y + k;\n    }\n  }\n  puts(\"NO\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int V = 200100;\nint q[V], dp[V], n, K, i, j, top, tail;\nchar s[2][V];\nint main() {\n  while (~scanf(\"%d%d\", &n, &K)) {\n    scanf(\"%s%s\", s[0], s[1]);\n    s[0][n] = s[1][n] = '-';\n    n++;\n    memset(dp, -1, sizeof(dp));\n    dp[0] = 0;\n    top = 0;\n    tail = 1;\n    q[1] = 0;\n    while (top < tail) {\n      top++;\n      i = q[top];\n      if (i % n != 0) {\n        j = i - 1;\n        if (s[j / n][j % n] == '-' && dp[j] == -1 && j % n >= dp[i] + 1) {\n          dp[j] = dp[i] + 1;\n          tail++;\n          q[tail] = j;\n        }\n      }\n      if (i % n != n - 1) {\n        j = i + 1;\n        if (s[j / n][j % n] == '-' && dp[j] == -1 && j % n >= dp[i] + 1) {\n          dp[j] = dp[i] + 1;\n          tail++;\n          q[tail] = j;\n        }\n      }\n      j = ((i / n) ^ 1) * n + min(i % n + K, n - 1);\n      if (s[j / n][j % n] == '-' && dp[j] == -1 && j % n >= dp[i] + 1) {\n        dp[j] = dp[i] + 1;\n        tail++;\n        q[tail] = j;\n      }\n    }\n    if (dp[n - 1] != -1 || dp[2 * n - 1] != -1)\n      puts(\"YES\");\n    else\n      puts(\"NO\");\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Inf = 1000000000;\nconst int Maxn = 100005;\nint n, k;\nstring s[2];\nint dist[2][Maxn];\nbool Possible() {\n  fill((int*)dist, (int*)dist + 2 * Maxn, Inf);\n  dist[0][0] = 0;\n  queue<pair<int, int> > Q;\n  if (s[0][0] != 'X') Q.push(pair<int, int>(0, 0));\n  while (!Q.empty()) {\n    pair<int, int> v = Q.front();\n    int d = dist[v.first][v.second];\n    Q.pop();\n    if (s[v.first][v.second] == 'X' || d > v.second) continue;\n    pair<int, int> u = pair<int, int>(v.first, v.second - 1);\n    if (u.second >= 0 && d + 1 < dist[u.first][u.second])\n      dist[u.first][u.second] = d + 1, Q.push(u);\n    u = pair<int, int>(v.first, v.second + 1);\n    if (u.second >= n) return true;\n    if (d + 1 < dist[u.first][u.second])\n      dist[u.first][u.second] = d + 1, Q.push(u);\n    u = pair<int, int>(1 - v.first, v.second + k);\n    if (u.second >= n) return true;\n    if (d + 1 < dist[u.first][u.second])\n      dist[u.first][u.second] = d + 1, Q.push(u);\n  }\n  return false;\n}\nint main() {\n  std::ios_base::sync_with_stdio(0);\n  cin >> n >> k;\n  cin >> s[0] >> s[1];\n  printf(\"%s\\n\", Possible() ? \"YES\" : \"NO\");\n  return 0;\n}\n"
        }
    ]
}