{
    "name": "1109_F. Sasha and Algorithm of Silence's Sounds",
    "source": "CODEFORCES",
    "description": "One fine day Sasha went to the park for a walk. In the park, he saw that his favorite bench is occupied, and he had to sit down on the neighboring one. He sat down and began to listen to the silence. Suddenly, he got a question: what if in different parts of the park, the silence sounds in different ways? So it was. Let's divide the park into 1 \u00d7 1 meter squares and call them cells, and numerate rows from 1 to n from up to down, and columns from 1 to m from left to right. And now, every cell can be described with a pair of two integers (x, y), where x \u2014 the number of the row, and y \u2014 the number of the column. Sasha knows that the level of silence in the cell (i, j) equals to f_{i,j}, and all f_{i,j} form a permutation of numbers from 1 to n \u22c5 m. Sasha decided to count, how many are there pleasant segments of silence?\n\nLet's take some segment [l \u2026 r]. Denote S as the set of cells (i, j) that l \u2264 f_{i,j} \u2264 r. Then, the segment of silence [l \u2026 r] is pleasant if there is only one simple path between every pair of cells from S (path can't contain cells, which are not in S). In other words, set S should look like a tree on a plain. Sasha has done this task pretty quickly, and called the algorithm \u2014 \"algorithm of silence's sounds\".\n\nTime passed, and the only thing left from the algorithm is a legend. To prove the truthfulness of this story, you have to help Sasha and to find the number of different pleasant segments of silence. Two segments [l_1 \u2026 r_1], [l_2 \u2026 r_2] are different, if l_1 \u2260 l_2 or r_1 \u2260 r_2 or both at the same time.\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n, m \u2264 1000, 1 \u2264 n \u22c5 m \u2264 2 \u22c5 10^5) \u2014 the size of the park.\n\nEach from next n lines contains m integers f_{i,j} (1 \u2264 f_{i,j} \u2264 n \u22c5 m) \u2014 the level of silence in the cell with number (i, j).\n\nIt is guaranteed, that all f_{i,j} are different.\n\nOutput\n\nPrint one integer \u2014 the number of pleasant segments of silence.\n\nExamples\n\nInput\n\n1 5\n1 2 3 4 5\n\n\nOutput\n\n15\n\nInput\n\n2 3\n1 2 3\n4 5 6\n\n\nOutput\n\n15\n\nInput\n\n4 4\n4 3 2 16\n1 13 14 15\n5 7 8 12\n6 11 9 10\n\n\nOutput\n\n50\n\nNote\n\nIn the first example, all segments of silence are pleasant.\n\nIn the second example, pleasant segments of silence are the following:\n\n<image>",
    "difficulty": "F",
    "tags": [
        "data structures",
        "trees"
    ],
    "rating": 3200,
    "public_test": [
        {
            "input": "4 4\n4 3 2 16\n1 13 14 15\n5 7 8 12\n6 11 9 10\n",
            "output": "50\n"
        },
        {
            "input": "2 3\n1 2 3\n4 5 6\n",
            "output": "15\n"
        },
        {
            "input": "1 5\n1 2 3 4 5\n",
            "output": "15\n"
        }
    ],
    "generated_test": [
        {
            "input": "1 5\n2 1 3 4 5\n",
            "output": "12\n"
        },
        {
            "input": "1 1\n1 2 3 4 5\n",
            "output": "1\n"
        },
        {
            "input": "1 2\n1 2 3 4 2\n",
            "output": "3\n"
        },
        {
            "input": "4 1\n1 2 3 4 2\n",
            "output": "10\n"
        },
        {
            "input": "3 1\n1 2 3 4 2\n",
            "output": "6\n"
        },
        {
            "input": "1 1\n1 2 3 4 2\n",
            "output": "1\n"
        },
        {
            "input": "2 1\n1 2 3 4 2\n",
            "output": "3\n"
        },
        {
            "input": "1 2\n1 2 5 4 2\n",
            "output": "3\n"
        },
        {
            "input": "1 1\n1 2 5 4 2\n",
            "output": "1\n"
        },
        {
            "input": "1 1\n1 2 5 4 3\n",
            "output": "1\n"
        },
        {
            "input": "1 1\n1 2 3 4 0\n",
            "output": "1\n"
        },
        {
            "input": "2 1\n1 2 3 1 2\n",
            "output": "3\n"
        },
        {
            "input": "1 2\n1 2 5 4 0\n",
            "output": "3\n"
        },
        {
            "input": "1 1\n1 2 6 4 2\n",
            "output": "1\n"
        },
        {
            "input": "1 1\n1 2 5 4 0\n",
            "output": "1\n"
        },
        {
            "input": "1 1\n1 4 3 4 0\n",
            "output": "1\n"
        },
        {
            "input": "1 2\n1 2 7 4 0\n",
            "output": "3\n"
        },
        {
            "input": "1 1\n1 2 3 1 2\n",
            "output": "1\n"
        },
        {
            "input": "1 1\n1 2 5 4 -1\n",
            "output": "1\n"
        },
        {
            "input": "1 1\n1 2 3 1 4\n",
            "output": "1\n"
        },
        {
            "input": "1 1\n1 2 5 4 -2\n",
            "output": "1\n"
        },
        {
            "input": "2 1\n1 2 5 4 -2\n",
            "output": "3\n"
        },
        {
            "input": "2 1\n1 2 5 3 -2\n",
            "output": "3\n"
        },
        {
            "input": "1 2\n1 2 3 4 5\n",
            "output": "3\n"
        },
        {
            "input": "1 2\n1 2 3 4 4\n",
            "output": "3\n"
        },
        {
            "input": "2 1\n1 2 3 4 0\n",
            "output": "3\n"
        },
        {
            "input": "1 2\n1 2 9 4 2\n",
            "output": "3\n"
        },
        {
            "input": "1 1\n1 2 4 4 2\n",
            "output": "1\n"
        },
        {
            "input": "1 2\n1 2 5 4 3\n",
            "output": "3\n"
        },
        {
            "input": "3 1\n1 2 3 1 2\n",
            "output": "6\n"
        },
        {
            "input": "1 2\n1 2 0 4 0\n",
            "output": "3\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1000005;\nnamespace LCT {\nstruct TNode {\n  int ch[2], f;\n  bool r;\n};\nTNode t[N];\ninline bool isroot(int pos) {\n  return t[t[pos].f].ch[0] != pos && t[t[pos].f].ch[1] != pos;\n}\ninline void pushdown(int pos) {\n  if (t[pos].r) {\n    t[pos].r = 0;\n    t[t[pos].ch[0]].r ^= 1;\n    t[t[pos].ch[1]].r ^= 1;\n    swap(t[pos].ch[0], t[pos].ch[1]);\n  }\n}\nvoid rotate(int pos) {\n  int y = t[pos].f, z = t[y].f, k = t[y].ch[1] == pos, w = t[pos].ch[k ^ 1];\n  if (!isroot(y)) t[z].ch[t[z].ch[1] == y] = pos;\n  t[pos].f = z;\n  t[pos].ch[!k] = y;\n  t[y].ch[k] = w;\n  t[w].f = y;\n  t[y].f = pos;\n}\nint stk[N];\nvoid splay(int pos) {\n  int ptr = 0, tmp = pos;\n  stk[ptr++] = tmp;\n  while (!isroot(tmp)) stk[ptr++] = tmp = t[tmp].f;\n  while (ptr--) pushdown(stk[ptr]);\n  while (!isroot(pos)) {\n    int y = t[pos].f, z = t[y].f;\n    if (!isroot(y)) rotate((t[y].ch[0] == pos) ^ (t[z].ch[0] == y) ? pos : y);\n    rotate(pos);\n  }\n}\nvoid access(int pos) {\n  for (int last = 0; pos; pos = t[last = pos].f)\n    splay(pos), t[pos].ch[1] = last;\n}\ninline void makeroot(int pos) {\n  access(pos);\n  splay(pos);\n  t[pos].r ^= 1;\n}\nint findroot(int pos) {\n  access(pos);\n  splay(pos);\n  pushdown(pos);\n  while (t[pos].ch[0]) pushdown(pos = t[pos].ch[0]);\n  splay(pos);\n  return pos;\n}\ninline void split(int x, int y) {\n  makeroot(x);\n  access(y);\n  splay(y);\n}\ninline bool link(int x, int y) {\n  makeroot(x);\n  if (findroot(y) != x) {\n    t[x].f = y;\n    return 1;\n  } else\n    return 0;\n}\ninline void cut(int x, int y) {\n  makeroot(x);\n  if (findroot(y) == x && t[y].f == x && !t[y].ch[0]) t[x].ch[1] = t[y].f = 0;\n}\n}  // namespace LCT\nstruct SegTree {\n  struct TNode {\n    int l, r, mn, v;\n  } t[N << 2];\n  int lazy[N << 2];\n  inline int lc(int pos) { return pos << 1; }\n  inline int rc(int pos) { return pos << 1 | 1; }\n  inline void pushdown(int pos) {\n    if (lazy[pos]) {\n      lazy[lc(pos)] += lazy[pos];\n      lazy[rc(pos)] += lazy[pos];\n      t[lc(pos)].mn += lazy[pos];\n      t[rc(pos)].mn += lazy[pos];\n      lazy[pos] = 0;\n    }\n  }\n  void pushup(int pos) {\n    t[pos].mn = min(t[lc(pos)].mn, t[rc(pos)].mn);\n    t[pos].v = t[lc(pos)].v * (t[pos].mn == t[lc(pos)].mn) +\n               t[rc(pos)].v * (t[pos].mn == t[rc(pos)].mn);\n  }\n  void build(int pos, int l, int r) {\n    t[pos].l = l;\n    t[pos].r = r;\n    if (l == r) {\n      t[pos].v = 1;\n      return;\n    }\n    int mid = (l + r) >> 1;\n    build(lc(pos), l, mid);\n    build(rc(pos), mid + 1, r);\n    pushup(pos);\n  }\n  void modify(int pos, int l, int r, int v) {\n    if (t[pos].l == l && t[pos].r == r) {\n      lazy[pos] += v, t[pos].mn += v;\n      return;\n    }\n    pushdown(pos);\n    int mid = (t[pos].l + t[pos].r) >> 1;\n    if (r <= mid)\n      modify(lc(pos), l, r, v);\n    else if (l > mid)\n      modify(rc(pos), l, r, v);\n    else\n      modify(lc(pos), l, mid, v), modify(rc(pos), mid + 1, r, v);\n    pushup(pos);\n  }\n  int query(int pos, int l, int r) {\n    if (t[pos].l == l && t[pos].r == r) return (t[pos].mn == 1) * t[pos].v;\n    pushdown(pos);\n    int mid = (t[pos].l + t[pos].r) >> 1;\n    if (r <= mid)\n      return query(lc(pos), l, r);\n    else if (l > mid)\n      return query(rc(pos), l, r);\n    else\n      return query(lc(pos), l, mid) + query(rc(pos), mid + 1, r);\n  }\n} t;\nusing ll = long long;\nvector<int> v[N];\nconst int M = 3005;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\nint n, m, w[M][M];\nll ans;\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) cin >> w[i][j];\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      for (int k = 0; k < 4; k++) {\n        int x = i + dx[k], y = j + dy[k];\n        if (x < 1 || y < 1 || x > n || y > m || w[i][j] > w[x][y]) continue;\n        v[w[x][y]].push_back(w[i][j]);\n        v[w[i][j]].push_back(w[x][y]);\n      }\n  int r = 0, tt = n * m;\n  t.build(1, 1, tt);\n  for (int i = 1; i <= tt; i++) {\n    for (int j = r + 1; j <= tt; j++) {\n      int fl = 0;\n      for (auto &d : v[j])\n        if (d < j && d >= i && !LCT::link(d, j)) {\n          fl = 1;\n          break;\n        }\n      for (auto &d : v[j]) LCT::cut(j, d);\n      if (fl == 1) break;\n      r = j;\n      int cc = 0;\n      for (auto &d : v[j])\n        if (d < j && d >= i) LCT::link(d, j), ++cc;\n      t.modify(1, r, r, r - i + 1);\n      t.modify(1, r, tt, -cc);\n    }\n    ans += t.query(1, i, r);\n    for (auto &d : v[i])\n      if (d <= r && d > i) LCT::cut(d, i), t.modify(1, d, tt, 1);\n    t.modify(1, i, r, -1);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nlong long gi() {\n  long long x = 0, f = 1;\n  char ch = getchar();\n  while (!isdigit(ch)) f ^= ch == '-', ch = getchar();\n  while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();\n  return f ? x : -x;\n}\nint n, m, N;\nint get(int i, int j) { return m * (i - 1) + j; }\nint f[1010][1010], px[200010], py[200010], _[5], __[5], o;\nint fa[200010], ch[200010][2];\nbool rev[200010];\nbool isrt(int x) { return ch[fa[x]][0] != x && ch[fa[x]][1] != x; }\nvoid Rev(int x) {\n  if (x) rev[x] ^= 1, std::swap(ch[x][0], ch[x][1]);\n}\nvoid down(int x) {\n  if (!isrt(x)) down(fa[x]);\n  if (rev[x]) Rev(ch[x][0]), Rev(ch[x][1]), rev[x] = 0;\n}\nvoid rotate(int x) {\n  int y = fa[x], z = fa[y], o = x == ch[y][1];\n  if (!isrt(y)) ch[z][y == ch[z][1]] = x;\n  fa[x] = z;\n  ch[y][o] = ch[x][!o];\n  fa[ch[x][!o]] = y;\n  ch[x][!o] = y;\n  fa[y] = x;\n}\nvoid splay(int x) {\n  down(x);\n  int y, z;\n  while (!isrt(x)) {\n    y = fa[x], z = fa[y];\n    if (!isrt(y)) rotate(((x == ch[y][0]) ^ (y == ch[z][0])) ? x : y);\n    rotate(x);\n  }\n}\nvoid access(int x) {\n  for (int y = 0; x; x = fa[y = x]) splay(x), ch[x][1] = y;\n}\nvoid makert(int x) { access(x), splay(x), Rev(x); }\nvoid link(int x, int y) { makert(x), fa[x] = y; }\nvoid cut(int x, int y) {\n  makert(x), access(y), splay(y);\n  fa[x] = ch[y][0] = 0;\n}\nint find(int x) {\n  access(x), splay(x);\n  while (ch[x][0]) x = ch[x][0];\n  splay(x);\n  return x;\n}\nstruct data {\n  int mn, cnt;\n};\ndata operator+(data a, data b) {\n  if (a.mn < b.mn)\n    return a;\n  else if (a.mn > b.mn)\n    return b;\n  else\n    return {a.mn, a.cnt + b.cnt};\n}\ndata operator+(data a, int b) { return {a.mn + b, a.cnt}; }\ndata seg[800010];\nint lz[800010];\nvoid Upd(int x, int d) { lz[x] += d, seg[x] = seg[x] + d; }\nvoid sdown(int x) {\n  if (lz[x]) Upd(x << 1, lz[x]), Upd(x << 1 | 1, lz[x]), lz[x] = 0;\n}\nvoid update(int x, int l, int r, const int& L, const int& R, const int& d) {\n  if (L <= l && r <= R) return Upd(x, d);\n  sdown(x);\n  if (L <= ((l + r) >> 1)) update(x << 1, l, ((l + r) >> 1), L, R, d);\n  if (((l + r) >> 1) < R) update(x << 1 | 1, ((l + r) >> 1) + 1, r, L, R, d);\n  seg[x] = seg[x << 1] + seg[x << 1 | 1];\n}\nvoid build(int x, int l, int r) {\n  seg[x].cnt = r - l + 1;\n  seg[x].mn = l;\n  if (l == r) return;\n  build(x << 1, l, ((l + r) >> 1)), build(x << 1 | 1, ((l + r) >> 1) + 1, r);\n}\nint get(int x, int l, int r, int p) {\n  if (l == r) return seg[x].mn;\n  sdown(x);\n  if (p <= ((l + r) >> 1))\n    return get(x << 1, l, ((l + r) >> 1), p);\n  else\n    return get(x << 1 | 1, ((l + r) >> 1) + 1, r, p);\n}\nint main() {\n  n = gi(), m = gi(), N = n * m;\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n      f[i][j] = gi(), px[f[i][j]] = i, py[f[i][j]] = j;\n  long long ans = 0;\n  build(1, 1, N);\n  for (int i = 2; i <= N; ++i) update(1, 1, N, i, i, 10000000);\n  for (int i = 1, j = 1; i <= N; ++i) {\n    while (j < N) {\n      o = 0;\n      ++j;\n      if (px[j] > 1) _[++o] = f[px[j] - 1][py[j]];\n      if (px[j] < n) _[++o] = f[px[j] + 1][py[j]];\n      if (py[j] > 1) _[++o] = f[px[j]][py[j] - 1];\n      if (py[j] < m) _[++o] = f[px[j]][py[j] + 1];\n      for (int p = 1; p <= o; ++p)\n        if (i <= _[p] && _[p] < j)\n          __[p] = find(_[p]);\n        else\n          _[p] = _[o], --o, --p;\n      std::sort(__ + 1, __ + o + 1);\n      for (int p = 1; p < o; ++p)\n        if (__[p] == __[p + 1]) o = -1;\n      if (o == -1) {\n        --j;\n        break;\n      }\n      for (int p = 1; p <= o; ++p) link(j, _[p]);\n      update(1, 1, N, j, N, -o);\n      update(1, 1, N, j, j, -10000000);\n    }\n    if (seg[1].mn == 1) ans += seg[1].cnt;\n    o = 0;\n    if (px[i] > 1) _[++o] = f[px[i] - 1][py[i]];\n    if (px[i] < n) _[++o] = f[px[i] + 1][py[i]];\n    if (py[i] > 1) _[++o] = f[px[i]][py[i] - 1];\n    if (py[i] < m) _[++o] = f[px[i]][py[i] + 1];\n    for (int p = 1; p <= o; ++p)\n      if (i < _[p] && _[p] <= j) cut(i, _[p]), update(1, 1, N, _[p], N, 1);\n    update(1, 1, N, i, i, 10000000);\n    Upd(1, -1);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing ll = long long;\nnamespace LCT {\nint lson[200005], rson[200005], fa[200005];\nbool rev[200005];\ninline bool isrt(int u) { return lson[fa[u]] != u && rson[fa[u]] != u; }\ninline void push_up(int u) {}\ninline void push_down(int u) {\n  if (!u || !rev[u]) return;\n  std::swap(lson[u], rson[u]);\n  rev[lson[u]] ^= 1;\n  rev[rson[u]] ^= 1;\n  rev[u] = false;\n}\ninline void rotate(int u) {\n  int v = fa[u], *same = lson[v] == u ? lson : rson,\n      *ano = lson[v] == u ? rson : lson;\n  fa[u] = fa[v];\n  if (!isrt(v)) (lson[fa[v]] == v ? lson : rson)[fa[v]] = u;\n  same[v] = ano[u];\n  fa[ano[u]] = v;\n  ano[u] = v;\n  fa[v] = u;\n  push_up(v);\n  push_up(u);\n}\nvoid splay(int u) {\n  static int stk[200005];\n  int tp = 0;\n  stk[tp++] = u;\n  for (int v = u; !isrt(v); v = fa[v]) stk[tp++] = fa[v];\n  while (tp--) push_down(stk[tp]);\n  while (!isrt(u)) {\n    int v = fa[u];\n    if (!isrt(v)) {\n      if ((lson[fa[v]] == v) != (lson[v] == u))\n        rotate(u);\n      else\n        rotate(v);\n    }\n    rotate(u);\n  }\n}\nvoid access(int u) {\n  for (int v = 0; u; v = u, u = fa[u]) {\n    splay(u);\n    rson[u] = v;\n    push_up(u);\n  }\n}\nint getfa(int u) {\n  access(u);\n  splay(u);\n  push_down(u);\n  while (lson[u]) {\n    u = lson[u];\n    push_down(u);\n  }\n  return u;\n}\nvoid mkrt(int u) {\n  access(u);\n  splay(u);\n  rev[u] ^= 1;\n}\nvoid link(int u, int v) {\n  mkrt(u);\n  fa[u] = v;\n}\nvoid cut(int u, int v) {\n  mkrt(u);\n  access(v);\n  splay(v);\n  lson[v] = fa[u] = 0;\n}\n}  // namespace LCT\nnamespace segT {\nstruct data {\n  int val, cnt;\n} seg[800005];\nint lazy[800005];\ndata operator+(const data &a, const data &b) {\n  data res;\n  res.val = std::min(a.val, b.val);\n  res.cnt = a.cnt * (a.val == res.val) + b.cnt * (b.val == res.val);\n  return res;\n}\ninline void paint(int u, int x) {\n  lazy[u] += x;\n  seg[u].val += x;\n}\ninline void push_down(int u) {\n  if (lazy[u]) {\n    paint(u << 1, lazy[u]);\n    paint(u << 1 | 1, lazy[u]);\n    lazy[u] = 0;\n  }\n}\nvoid build(int u, int l, int r) {\n  if (l == r) {\n    seg[u] = {l, 1};\n    return;\n  }\n  int m = l + r >> 1;\n  build(u << 1, l, m);\n  build(u << 1 | 1, m + 1, r);\n  seg[u] = seg[u << 1] + seg[u << 1 | 1];\n}\nvoid modify(int u, int l, int r, int L, int R, int x) {\n  if (L <= l && r <= R) {\n    paint(u, x);\n    return;\n  }\n  push_down(u);\n  int m = l + r >> 1;\n  if (L <= m) modify(u << 1, l, m, L, R, x);\n  if (m < R) modify(u << 1 | 1, m + 1, r, L, R, x);\n  seg[u] = seg[u << 1] + seg[u << 1 | 1];\n}\ndata query(int u, int l, int r, int L, int R) {\n  if (L <= l && r <= R) return seg[u];\n  push_down(u);\n  int m = l + r >> 1;\n  data res = {(int)1e9, 0};\n  if (L <= m) res = res + query(u << 1, l, m, L, R);\n  if (m < R) res = res + query(u << 1 | 1, m + 1, r, L, R);\n  return res;\n}\n}  // namespace segT\nconstexpr int dx[] = {1, -1, 0, 0}, dy[] = {0, 0, 1, -1};\nint n, m, arr[1005][1005], pos_x[200005], pos_y[200005], lim[200005], seq[5];\ntemplate <typename T>\nvoid for_adj(int u, T func) {\n  int x = pos_x[u], y = pos_y[u];\n  for (int i = 0; i < 4; i++) {\n    int xx = x + dx[i], yy = y + dy[i];\n    if (xx >= 0 && xx < n && yy >= 0 && yy < m) func(arr[xx][yy]);\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      scanf(\"%d\", arr[i] + j);\n      pos_x[--arr[i][j]] = i;\n      pos_y[arr[i][j]] = j;\n    }\n  }\n  for (int l = 0, r = 0; l < n * m; l++) {\n    while (r < n * m) {\n      int cnt = 0;\n      for_adj(r, [&](int u) {\n        if (u >= l && u < r) seq[cnt++] = LCT::getfa(u + 1) - 1;\n      });\n      bool flg = false;\n      for (int i = 0; i < cnt && !flg; i++) {\n        for (int j = 0; j < i && !flg; j++) flg |= seq[i] == seq[j];\n      }\n      if (flg) break;\n      for_adj(r, [&](int u) {\n        if (u >= l && u < r) LCT::link(u + 1, r + 1);\n      });\n      r++;\n    }\n    lim[l] = r - 1;\n    for_adj(l, [&](int u) {\n      if (u >= l && u < r) LCT::cut(u + 1, l + 1);\n    });\n  }\n  segT::build(1, 0, n * m - 1);\n  ll ans = 0;\n  for (int i = n * m - 1; i >= 0; i--) {\n    for_adj(i, [&](int u) {\n      if (u >= i) segT::modify(1, 0, n * m - 1, u, n * m - 1, -1);\n    });\n    auto res = segT::query(1, 0, n * m - 1, i, lim[i]);\n    ans += res.cnt * (res.val == i);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\nint dx[] = {0, 0, -1, 1};\nint dy[] = {-1, 1, 0, 0};\nconst int N = 1e6;\nconst int inf = ~0u >> 2;\nstruct Node* null;\nstruct Node {\n  Node* ch[2];\n  Node* fa;\n  int mi, val, rev;\n  inline bool isroot() {\n    return fa == null || fa->ch[0] != this && fa->ch[1] != this;\n  }\n  inline bool d() { return fa->ch[1] == this; }\n  inline void setc(int s, Node* who) {\n    who->fa = this;\n    ch[s] = who;\n  }\n  inline void rotate() {\n    bool f = d();\n    Node* y = fa;\n    y->setc(f, ch[!f]), fa = y->fa;\n    if (!y->isroot()) fa->ch[y->d()] = this;\n    this->setc(!f, y), y->up();\n  }\n  void splay() {\n    for (go(); !isroot(); rotate())\n      if (!fa->isroot()) (fa->d() ^ d()) ? rotate() : fa->rotate();\n    up();\n  }\n  inline void up() {\n    mi = std::min(ch[0]->mi, ch[1]->mi);\n    mi = std::min(mi, val);\n  }\n  void init(int v, Node* f) {\n    fa = f;\n    val = mi = v;\n    ch[0] = ch[1] = null;\n    rev = 0;\n  }\n  void flip() {\n    std::swap(ch[0], ch[1]);\n    rev ^= 1;\n  }\n  void push() {\n    if (rev) {\n      ch[0]->flip(), ch[1]->flip(), rev = 0;\n    }\n  }\n  void go() {\n    if (!isroot()) fa->go();\n    push();\n  }\n};\nstruct Edge {\n  int a, b;\n} edge[N];\nint musorka = -1;\nint my_n;\nint kekos[N];\nstruct Link_Cut_Tree {\n  Node node[N];\n  int tot;\n  Node* access(Node* u) {\n    Node* v = null;\n    for (; u != null; v = u, u = u->fa) u->splay(), u->ch[1] = v, u->up();\n    return v;\n  }\n  int ask(Node* x, Node* y) {\n    access(x);\n    for (x = null; y != null; y = y->fa) {\n      y->splay();\n      if (y->fa == null) {\n        return std::min(y->ch[1]->mi, x->mi);\n      }\n      y->ch[1] = x, y->up(), x = y;\n    }\n  }\n  int ask(int a, int b) { return ask(node + a, node + b); }\n  void cut(Node* u) {\n    u->splay();\n    u->ch[0]->fa = u->fa;\n    u->fa = u->ch[0] = null;\n    u->up();\n  }\n  void cut(Node* u, Node* v) {\n    access(u), v->splay();\n    if (v->fa == u) {\n      v->fa = null;\n    } else {\n      access(v), u->splay(), u->fa = null;\n    }\n  }\n  void link(Node* u, Node* v) {\n    make_root(u);\n    u->fa = v;\n  }\n  void make_root(Node* u) {\n    Node* tmp = access(u);\n    tmp->flip();\n    u->splay();\n  }\n  bool judge(Node* u, Node* v) {\n    while (u->fa != null) u = u->fa;\n    while (v->fa != null) v = v->fa;\n    return u == v;\n  }\n  void insert(int a, int b, int c, int w) {\n    edge[c].a = a, edge[c].b = b;\n    kekos[c] = w;\n    Node* u = node + a;\n    Node* v = node + b;\n    Node* edge_node = &node[my_n + c + 1];\n    edge_node->init(c, null);\n    if (judge(u, v)) {\n      int id = ask(u, v);\n      musorka = min(kekos[c], kekos[id]);\n      if (kekos[c] <= kekos[id]) return;\n      cut(node + my_n + id + 1, node + edge[id].a);\n      cut(node + my_n + id + 1, node + edge[id].b);\n    }\n    link(edge_node, node + a), link(edge_node, node + b);\n  }\n} lct;\npair<int, int> ret[300000];\nstruct abacabadabacaba {\n  int mn, mn_cnt;\n};\nabacabadabacaba merge(abacabadabacaba a, abacabadabacaba b) {\n  if (a.mn == b.mn) {\n    return {a.mn, a.mn_cnt + b.mn_cnt};\n  }\n  if (a.mn > b.mn) {\n    return a;\n  } else {\n    return b;\n  }\n}\nabacabadabacaba t[4 * N];\nint d[4 * N];\nvoid push(int v) {\n  t[v * 2 + 1].mn += d[v];\n  t[v * 2 + 2].mn += d[v];\n  d[v * 2 + 1] += d[v];\n  d[v * 2 + 2] += d[v];\n  d[v] = 0;\n}\nabacabadabacaba get(int v, int l, int r, int tl, int tr) {\n  if (tl >= r || tr <= l) {\n    return {-inf, 0};\n  }\n  if (tl >= l && tr <= r) {\n    return t[v];\n  } else {\n    int tm = (tl + tr) / 2;\n    push(v);\n    return merge(get(v * 2 + 1, l, r, tl, tm), get(v * 2 + 2, l, r, tm, tr));\n  }\n}\nvoid build(int v, int l, int r) {\n  d[v] = 0;\n  if (r - l == 1) {\n    t[v] = {-l, 1};\n  } else {\n    int m = (l + r) / 2;\n    build(v * 2 + 1, l, m);\n    build(v * 2 + 2, m, r);\n    t[v] = merge(t[v * 2 + 1], t[v * 2 + 2]);\n  }\n}\nvoid upd(int v, int l, int r, int tl, int tr) {\n  if (tl >= r || tr <= l) {\n    return;\n  }\n  if (tl >= l && tr <= r) {\n    d[v]++;\n    t[v].mn++;\n  } else {\n    int tm = (tl + tr) / 2;\n    push(v);\n    upd(v * 2 + 1, l, r, tl, tm);\n    upd(v * 2 + 2, l, r, tm, tr);\n    t[v] = merge(t[v * 2 + 1], t[v * 2 + 2]);\n  }\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<vector<int> > f(n, vector<int>(m));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      cin >> f[i][j];\n      f[i][j]--;\n      ret[f[i][j]] = {i, j};\n    }\n  }\n  int v = n * m;\n  my_n = v;\n  null = new Node();\n  null->ch[0] = null->ch[1] = null->fa = null;\n  null->mi = null->val = inf;\n  for (int i = 1; i <= v; i++) {\n    lct.node[i].init(inf, null);\n  }\n  vector<int> vl(v, v);\n  int ptr = 0;\n  vector<vector<int> > g(v);\n  vector<pair<int, int> > edg;\n  for (int i = 0; i < n * m; i++) {\n    int x = ret[i].first, y = ret[i].second;\n    for (int t = 0; t < 4; t++) {\n      if (0 <= x + dx[t] && x + dx[t] < n && 0 <= y + dy[t] && y + dy[t] < m &&\n          f[x + dx[t]][y + dy[t]] < f[x][y]) {\n        int j = f[x + dx[t]][y + dy[t]];\n        edg.push_back({j, i});\n      }\n    }\n  }\n  sort(edg.begin(), edg.end());\n  for (int i = 0; i < n * m; i++) {\n    int x = ret[i].first, y = ret[i].second;\n    for (int t = 0; t < 4; t++) {\n      if (0 <= x + dx[t] && x + dx[t] < n && 0 <= y + dy[t] && y + dy[t] < m &&\n          f[x + dx[t]][y + dy[t]] < f[x][y]) {\n        int j = f[x + dx[t]][y + dy[t]];\n        g[j].push_back(i);\n        musorka = -1;\n        int ptr =\n            lower_bound(edg.begin(), edg.end(), make_pair(j, i)) - edg.begin();\n        lct.insert(j + 1, i + 1, ptr, j + 1);\n        if (musorka != -1) {\n          vl[musorka - 1] = min(vl[musorka - 1], i);\n        }\n      }\n    }\n  }\n  for (int i = v - 2; i >= 0; i--) {\n    vl[i] = min(vl[i], vl[i + 1]);\n  }\n  long long ans = 0;\n  build(0, 0, v);\n  for (int i = v - 1; i >= 0; i--) {\n    for (int x : g[i]) {\n      upd(0, x, v, 0, v);\n    }\n    if (i < vl[i]) {\n      abacabadabacaba ret = get(0, i, vl[i], 0, v);\n      if (ret.mn == -i) ans += ret.mn_cnt;\n    }\n  }\n  cout << ans << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 10;\nconst int dx[] = {0, 0, -1, 1};\nconst int dy[] = {1, -1, 0, 0};\nint add(int x, int y) {\n  x += y;\n  if (x >= 998244353) x -= 998244353;\n  return x;\n}\nint ch[N][2], fa[N], rev[N];\nint isroot(int x) { return ch[fa[x]][0] != x && ch[fa[x]][1] != x; }\nint get(int x) { return ch[fa[x]][1] == x; }\nvoid pushup(int x) {}\nvoid Rev(int x) {\n  swap(ch[x][0], ch[x][1]);\n  rev[x] ^= 1;\n}\nvoid pushdown(int x) {\n  if (x && rev[x]) {\n    if (ch[x][0]) Rev(ch[x][0]);\n    if (ch[x][1]) Rev(ch[x][1]);\n    rev[x] = 0;\n  }\n}\nvoid rotate(int x) {\n  int old = fa[x], oldf = fa[old];\n  if (!isroot(old)) {\n    ch[oldf][get(old)] = x;\n  }\n  fa[x] = oldf;\n  int d = ch[old][1] == x;\n  ch[old][d] = ch[x][d ^ 1];\n  if (ch[x][d ^ 1]) fa[ch[x][d ^ 1]] = old;\n  ch[x][d ^ 1] = old;\n  fa[old] = x;\n  pushup(old);\n  pushup(x);\n}\nint stay[N];\nvoid splay(int x) {\n  int top = 0;\n  stay[++top] = x;\n  for (int i = x; !isroot(i); i = fa[i]) stay[++top] = fa[i];\n  for (int i = top; i >= 1; i--) pushdown(stay[i]);\n  for (int f = fa[x]; !isroot(x); rotate(x))\n    if (!isroot(f = fa[x])) {\n      rotate(get(f) == get(x) ? f : x);\n    }\n}\nvoid access(int x) {\n  for (int t = 0; x; t = x, x = fa[x]) {\n    splay(x);\n    ch[x][1] = t;\n  }\n}\nvoid wroot(int x) {\n  access(x);\n  splay(x);\n  Rev(x);\n}\nvoid link(int x, int y) {\n  wroot(x);\n  wroot(y);\n  fa[x] = y;\n}\nvoid cut(int x, int y) {\n  wroot(x);\n  access(y);\n  splay(y);\n  ch[y][0] = fa[x] = 0;\n}\nint find(int x) {\n  access(x);\n  splay(x);\n  while (ch[x][0]) {\n    x = ch[x][0];\n  }\n  return x;\n}\nstruct Node {\n  int minm, cnt, tag;\n} tr[N << 2];\nvoid down(int x) {\n  if (tr[x].tag != 0) {\n    tr[x << 1].minm += tr[x].tag;\n    tr[x << 1].tag += tr[x].tag;\n    tr[x << 1 | 1].minm += tr[x].tag;\n    tr[x << 1 | 1].tag += tr[x].tag;\n    tr[x].tag = 0;\n  }\n}\nvoid up(int x) {\n  tr[x].minm = tr[x << 1].minm;\n  tr[x].cnt = tr[x << 1].cnt;\n  if (tr[x << 1 | 1].minm < tr[x].minm)\n    tr[x].minm = tr[x << 1 | 1].minm, tr[x].cnt = tr[x << 1 | 1].cnt;\n  else if (tr[x << 1 | 1].minm == tr[x].minm)\n    tr[x].cnt += tr[x << 1 | 1].cnt;\n}\nvoid build(int x, int l, int r) {\n  if (l == r) {\n    tr[x].cnt = 1;\n    return;\n  }\n  int mid = l + r >> 1;\n  build(x << 1, l, mid);\n  build(x << 1 | 1, mid + 1, r);\n  up(x);\n  return;\n}\nvoid modify(int x, int l, int r, int ql, int qr, int v) {\n  if (ql <= l && r <= qr) {\n    tr[x].minm += v;\n    tr[x].tag += v;\n    return;\n  }\n  int mid = l + r >> 1;\n  down(x);\n  if (ql <= mid) modify(x << 1, l, mid, ql, qr, v);\n  if (mid < qr) modify(x << 1 | 1, mid + 1, r, ql, qr, v);\n  up(x);\n}\nvoid Merge(pair<int, int> &x, pair<int, int> y) {\n  if (x.first > y.first)\n    x = y;\n  else if (x.first == y.first)\n    x.second += y.second;\n}\npair<int, int> query(int x, int l, int r, int ql, int qr) {\n  if (ql <= l && r <= qr) {\n    return make_pair(tr[x].minm, tr[x].cnt);\n  }\n  int mid = l + r >> 1;\n  pair<int, int> res = make_pair(998244353, 0);\n  down(x);\n  if (ql <= mid) Merge(res, query(x << 1, l, mid, ql, qr));\n  if (mid < qr) Merge(res, query(x << 1 | 1, mid + 1, r, ql, qr));\n  return res;\n}\nint n, m, mat[2010][2010];\nlong long res;\npair<int, int> pos[N];\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      scanf(\"%d\", &mat[i][j]);\n      pos[mat[i][j]] = make_pair(i, j);\n    }\n  }\n  build(1, 1, n * m);\n  int p = 1;\n  for (int i = 1; i <= n * m; i++) {\n    int x = pos[i].first, y = pos[i].second;\n    while (1) {\n      bool flag = 1;\n      for (int j = 0; j < 4; j++) {\n        int nx = x + dx[j], ny = y + dy[j];\n        if (nx < 1 || nx > n || ny < 1 || ny > m || mat[nx][ny] > i ||\n            mat[nx][ny] < p)\n          continue;\n        for (int d = j + 1; d < 4; d++) {\n          int nnx = x + dx[d], nny = y + dy[d];\n          if (nnx < 1 || nnx > n || nny < 1 || nny > m || mat[nnx][nny] > i ||\n              mat[nnx][nny] < p)\n            continue;\n          if (find(mat[nx][ny]) == find(mat[nnx][nny])) {\n            flag = 0;\n          }\n        }\n      }\n      if (flag) break;\n      int x = pos[p].first, y = pos[p].second;\n      for (int d = 0; d < 4; d++) {\n        int nx = x + dx[d], ny = y + dy[d];\n        if (nx < 1 || nx > n || ny < 1 || ny > m || mat[nx][ny] > i ||\n            mat[nx][ny] < p)\n          continue;\n        cut(p, mat[nx][ny]);\n      }\n      p++;\n    }\n    modify(1, 1, n * m, 1, i, 1);\n    for (int j = 0; j < 4; j++) {\n      int nx = x + dx[j], ny = y + dy[j];\n      if (nx < 1 || nx > n || ny < 1 || ny > m || mat[nx][ny] > i) continue;\n      modify(1, 1, n * m, 1, mat[nx][ny], -1);\n    }\n    for (int j = 0; j < 4; j++) {\n      int nx = x + dx[j], ny = y + dy[j];\n      if (nx < 1 || nx > n || ny < 1 || ny > m || mat[nx][ny] > i ||\n          mat[nx][ny] < p)\n        continue;\n      link(mat[nx][ny], i);\n    }\n    pair<int, int> ret = query(1, 1, n * m, p, i);\n    res += ret.second;\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2 * 1e5 + 10;\nconst int dx[4] = {1, -1, 0, 0};\nconst int dy[4] = {0, 0, -1, 1};\nint n, m;\nstruct mar {\n  int f[N * 2];\n  inline int* operator[](const int& x) { return f + x * m; }\n} val;\nbool book[N];\nstruct data {\n  int x, y;\n} nod[N];\nint ctt, ptr, totr;\nstruct tnod {\n  int val;\n  int cnt;\n  friend tnod operator+(tnod a, tnod b) {\n    if (a.val < b.val) return a;\n    if (a.val > b.val) return b;\n    return (tnod){a.val, a.cnt + b.cnt};\n  }\n  void operator+=(const int& x) { val += x; }\n};\nstruct linkcuttree {\n  int s[N][2];\n  int fa[N];\n  int mi[N];\n  int rv[N];\n  int st[N];\n  int tp;\n  linkcuttree() { mi[0] = 0x3f3f3f3f; }\n  inline int gc(int x) { return s[fa[x]][1] == x; }\n  inline bool isr(int x) { return (s[fa[x]][1] != x && s[fa[x]][0] != x); }\n  inline void ud(int x) { mi[x] = min(min(mi[s[x][0]], mi[s[x][1]]), x); }\n  inline void pd(int p) {\n    if (rv[p])\n      rv[s[p][0]] ^= 1, rv[s[p][1]] ^= 1, swap(s[p][0], s[p][1]), rv[p] = 0;\n  }\n  inline void pdall(int p) {\n    for (int x = p; (st[++tp] = x, !isr(x)); x = fa[x])\n      ;\n    while (tp) pd(st[tp--]);\n  }\n  inline void rt(int x) {\n    int d = fa[x];\n    int t = gc(x);\n    s[d][t] = s[x][t ^ 1];\n    fa[s[x][t ^ 1]] = d;\n    if (!isr(d)) s[fa[d]][gc(d)] = x;\n    fa[x] = fa[d];\n    s[x][t ^ 1] = d;\n    fa[d] = x;\n    ud(d);\n    ud(x);\n  }\n  inline void rtup(int x) {\n    rt((gc(x) ^ gc(fa[x])) ? x : fa[x]);\n    rt(x);\n  }\n  inline void splay(int x) {\n    pdall(x);\n    for (; !isr(x) && !isr(fa[x]); rtup(x))\n      ;\n    if (!isr(x)) rt(x);\n  }\n  inline void acc(int p) {\n    for (splay(p), s[p][1] = 0, ud(p); fa[p];\n         splay(fa[p]), s[fa[p]][1] = p, ud(fa[p]), splay(p))\n      ;\n  }\n  inline void mkr(int p) {\n    acc(p);\n    rv[p] ^= 1;\n  }\n  inline void lk(int u, int v) {\n    mkr(u);\n    acc(v);\n    fa[u] = v;\n  }\n  inline void cu(int u, int v) {\n    mkr(u);\n    acc(v);\n    if (s[v][0] == u && s[u][1] == 0) s[v][0] = 0, fa[u] = 0, ud(v);\n  }\n  inline int cmi(int u, int v) {\n    mkr(u);\n    acc(v);\n    if (fa[u] == 0)\n      return 0x3f3f3f3f;\n    else\n      return mi[v];\n  }\n} lct;\nstruct linetree {\n  tnod v[N << 2];\n  int add[N << 2];\n  inline void pd(int p, int p1, int p2) {\n    if (add[p])\n      v[p1] += add[p], v[p2] += add[p], add[p1] += add[p], add[p2] += add[p],\n          add[p] = 0;\n  }\n  inline void build(int p, int l, int r) {\n    v[p] = (tnod){0, r - l};\n    if (r - l == 1) {\n      return;\n    }\n    int mid = (l + r) >> 1;\n    build(p << 1, l, mid);\n    build(p << 1 | 1, mid, r);\n  }\n  inline void stadd(int p, int l, int r, int dl, int dr, int pl) {\n    if (dl == l && dr == r) {\n      v[p] += pl;\n      add[p] += pl;\n      return;\n    }\n    int mid = (l + r) >> 1;\n    pd(p, p << 1, p << 1 | 1);\n    if (dl < mid) stadd(p << 1, l, mid, dl, min(dr, mid), pl);\n    if (mid < dr) stadd(p << 1 | 1, mid, r, max(dl, mid), dr, pl);\n    v[p] = v[p << 1] + v[p << 1 | 1];\n  }\n  inline tnod sum(int p, int l, int r, int dl, int dr) {\n    if (dl == l && dr == r) return v[p];\n    int mid = (l + r) >> 1;\n    pd(p, p << 1, p << 1 | 1);\n    if (dl < mid && mid < dr)\n      return sum(p << 1, l, mid, dl, mid) + sum(p << 1 | 1, mid, r, mid, dr);\n    if (dl < mid)\n      return sum(p << 1, l, mid, dl, dr);\n    else\n      return sum(p << 1 | 1, mid, r, dl, dr);\n  }\n} lt;\ninline void delnod(int sx, int sy) {\n  int np = val[sx][sy];\n  for (int k = 0, tx, ty; k < 4; k++) {\n    tx = sx + dx[k];\n    ty = sy + dy[k];\n    if (tx < 1 || tx > n || ty < 1 || ty > m || val[tx][ty] < ptr ||\n        val[tx][ty] > totr)\n      continue;\n    lct.cu(np, val[tx][ty]);\n  }\n  ptr++;\n}\ninline void insed(int p1, int p2) {\n  lt.stadd(1, 0, ctt, 0, p2, -1);\n  int tmp = lct.cmi(p1, p2);\n  if (tmp == 0x3f3f3f3f) {\n    lct.lk(p1, p2);\n    return;\n  }\n  for (int k = ptr; k <= tmp; k++) delnod(nod[k].x, nod[k].y);\n  lct.lk(p1, p2);\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  ctt = n * m;\n  lt.build(1, 0, ctt);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1, t; j <= m; j++)\n      scanf(\"%d\", &t), val[i][j] = t, nod[t] = (data){i, j};\n  long long ans = 0;\n  ptr = 1;\n  totr = 1;\n  for (int i = 1; i <= ctt; i++) {\n    totr = i;\n    int sx = nod[i].x, sy = nod[i].y;\n    lt.stadd(1, 0, ctt, 0, i, 1);\n    for (int k = 0, tx, ty; k < 4; k++) {\n      tx = sx + dx[k], ty = sy + dy[k];\n      if (tx < 1 || tx > n || ty < 1 || ty > m || val[tx][ty] > i ||\n          val[tx][ty] < ptr)\n        continue;\n      insed(i, val[tx][ty]);\n    }\n    tnod ret = lt.sum(1, 0, ctt, ptr - 1, i);\n    if (ret.val == 1) ans += ret.cnt;\n  }\n  printf(\"%I64d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 201000;\nint c[2][N], fa[N], rev[N];\nbool it(int o) { return c[0][fa[o]] != o && c[1][fa[o]] != o; }\nvoid pd(int o) {\n  if (rev[o]) {\n    swap(c[0][o], c[1][o]);\n    rev[c[0][o]] ^= 1;\n    rev[c[1][o]] ^= 1;\n    rev[o] = 0;\n  }\n}\nvoid rot(int o) {\n  int x = fa[o], k = c[0][x] == o;\n  fa[c[!k][x] = c[k][o]] = x;\n  fa[o] = fa[x];\n  if (!it(x)) c[c[1][fa[x]] == x][fa[x]] = o;\n  fa[c[k][o] = x] = o;\n}\nvoid down(int o) {\n  if (!it(o)) down(fa[o]);\n  pd(o);\n}\nvoid sy(int o) {\n  for (down(o); !it(o); rot(o))\n    if (!it(fa[o]))\n      rot(c[0][fa[o]] == o ^ c[0][fa[fa[o]]] == fa[o] ? o : fa[o]);\n}\nvoid acs(int o) {\n  for (int y = 0; o; c[1][o] = y, y = o, o = fa[o]) sy(o);\n}\nvoid mt(int o) {\n  acs(o);\n  sy(o);\n  rev[o] ^= 1;\n}\nint fd(int o) {\n  acs(o);\n  sy(o);\n  for (; c[0][o]; pd(o = c[0][o]))\n    ;\n  sy(o);\n  return o;\n}\nvoid cut(int x, int y) {\n  mt(y);\n  acs(x);\n  sy(x);\n  assert(c[0][x] == y);\n  fa[y] = c[0][x] = 0;\n}\nint mn[N * 4], tag[N * 4], mn_cnt[N * 4];\nvoid bt(int o, int l, int r) {\n  mn[o] = tag[o] = 0;\n  mn_cnt[o] = r - l + 1;\n  if (l == r) return;\n  int mid = (l + r) / 2;\n  bt(o * 2, l, mid);\n  bt(o * 2 + 1, mid + 1, r);\n}\nint q1, q2;\nlong long ans;\nvoid query(int o, int l, int r, int tg = 0) {\n  if (q1 <= l && r <= q2) {\n    if (mn[o] + tg == 0) ans += mn_cnt[o];\n    return;\n  }\n  int mid = (l + r) / 2;\n  tg += tag[o];\n  if (q1 <= mid) query(o * 2, l, mid, tg);\n  if (q2 > mid) query(o * 2 + 1, mid + 1, r, tg);\n}\nvoid modify(int o, int l, int r) {\n  if (q1 <= l) {\n    tag[o] += q2;\n    mn[o] += q2;\n    return;\n  }\n  int mid = (l + r) / 2;\n  if (q1 <= mid) modify(o * 2, l, mid);\n  modify(o * 2 + 1, mid + 1, r);\n  mn[o] = min(mn[o * 2], mn[o * 2 + 1]);\n  mn_cnt[o] = (mn[o] == mn[o * 2] ? mn_cnt[o * 2] : 0) +\n              (mn[o] == mn[o * 2 + 1] ? mn_cnt[o * 2 + 1] : 0);\n  mn[o] += tag[o];\n}\nconst int dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0}, M = 1234;\nint idx[N], idy[N], a[M][M];\nint n, m, K, L, R;\nbool push(int x, int op) {\n  int u = idx[x], v = idy[x], nu = u + dx[op], nv = v + dy[op];\n  if (nu < 1 || nu > n || nv < 1 || nv > m || a[nu][nv] < L || a[nu][nv] > R)\n    return 1;\n  int y = a[nu][nv];\n  mt(y);\n  if (fd(x) == y) return 0;\n  fa[y] = x;\n  q1 = max(x, y);\n  q2 = -1;\n  modify(1, 1, K);\n  return 1;\n}\nvoid pop(int t) {\n  for (int op = 0; op < 4; ++op) {\n    int u = idx[R], v = idy[R], nu = u - dx[op], nv = v - dy[op];\n    if (nu < 1 || nu > n || nv < 1 || nv > m ||\n        (a[nu][nv] < L || (a[nu][nv] == L && op >= t)) || a[nu][nv] > R)\n      continue;\n    int y = a[nu][nv];\n    cut(y, R);\n    q1 = max(R, y);\n    q2 = 1;\n    modify(1, 1, K);\n  }\n  --R;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  K = n * m;\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n      cin >> a[i][j], idx[a[i][j]] = i, idy[a[i][j]] = j;\n  bt(1, 1, K);\n  for (L = R = K; L; --L) {\n    for (int i = 0; i < 4; ++i)\n      for (; !push(L, i); pop(i))\n        ;\n    q1 = L;\n    q2 = R;\n    query(1, 1, K);\n    q1 = L;\n    q2 = 1;\n    modify(1, 1, K);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5, M = 1005;\nconst int way[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\nstruct node {\n  int x, y;\n} a[N];\nint n, m, up, top, qx, qy, qz;\nlong long ans;\nint fa[N], s[N][2], st[N];\nbool rev[N];\npair<int, int> f[N << 2];\nint b[M][M], c[N << 2];\ninline int read() {\n  int X = 0, w = 0;\n  char ch = 0;\n  while (!isdigit(ch)) w |= ch == '-', ch = getchar();\n  while (isdigit(ch)) X = (X << 3) + (X << 1) + (ch ^ 48), ch = getchar();\n  return w ? -X : X;\n}\ninline bool pd(int x) { return x == s[fa[x]][1]; }\ninline bool isroot(int x) { return x ^ s[fa[x]][0] && x ^ s[fa[x]][1]; }\ninline void rotate(int x) {\n  int y = fa[x], w = pd(x);\n  if ((fa[x] = fa[y]) && !isroot(y)) s[fa[y]][pd(y)] = x;\n  if (s[y][w] = s[x][w ^ 1]) fa[s[y][w]] = y;\n  s[fa[y] = x][w ^ 1] = y;\n}\ninline void reverse(int x) {\n  if (x) swap(s[x][0], s[x][1]), rev[x] ^= 1;\n}\ninline void down(int x) {\n  if (rev[x]) {\n    reverse(s[x][0]), reverse(s[x][1]);\n    rev[x] = false;\n  }\n}\ninline void splay(int x) {\n  for (int y = st[top = 1] = x; !isroot(y); y = fa[y]) st[++top] = fa[y];\n  while (top) down(st[top--]);\n  for (int y; !isroot(x); rotate(x))\n    if (!isroot(y = fa[x])) rotate(pd(x) == pd(y) ? y : x);\n}\ninline void access(int x) {\n  for (int y = 0; x; x = fa[y = x]) splay(x), s[x][1] = y;\n}\ninline void mkroot(int x) { access(x), splay(x), reverse(x); }\ninline void link(int x, int y) { mkroot(x), fa[x] = y; }\ninline void cut(int x, int y) {\n  mkroot(x), access(y), splay(y);\n  s[y][0] = fa[x] = 0;\n}\ninline bool connect(int x, int y) {\n  mkroot(x), access(y), splay(y);\n  while (s[y][0]) y = s[y][0];\n  return x == y;\n}\ninline void down1(int v) {\n  if (c[v]) {\n    f[v << 1].first += c[v];\n    f[v << 1 | 1].first += c[v];\n    c[v << 1] += c[v];\n    c[v << 1 | 1] += c[v];\n    c[v] = 0;\n  }\n}\nvoid make(int v, int l, int r) {\n  if (l == r) {\n    f[v].second = 1;\n    return;\n  }\n  int mid = l + r >> 1;\n  make(v << 1, l, mid);\n  make(v << 1 | 1, mid + 1, r);\n  f[v].second = f[v << 1].second + f[v << 1 | 1].second;\n}\npair<int, int> cmin(pair<int, int> x, pair<int, int> y) {\n  if (x.first < y.first) return x;\n  if (x.first > y.first) return y;\n  return make_pair(x.first, x.second + y.second);\n}\nvoid change(int v, int l, int r) {\n  if (qx <= l && r <= qy) {\n    f[v].first += qz;\n    c[v] += qz;\n    return;\n  }\n  down1(v);\n  int mid = l + r >> 1;\n  if (qx <= mid) change(v << 1, l, mid);\n  if (qy > mid) change(v << 1 | 1, mid + 1, r);\n  f[v] = cmin(f[v << 1], f[v << 1 | 1]);\n}\npair<int, int> find(int v, int l, int r) {\n  if (qx <= l && r <= qy) return f[v];\n  down1(v);\n  int mid = l + r >> 1;\n  pair<int, int> val(N, 0);\n  if (qx <= mid) val = find(v << 1, l, mid);\n  if (qy > mid) val = cmin(val, find(v << 1 | 1, mid + 1, r));\n  return val;\n}\ninline bool judge(int l, int r) {\n  for (int i = 0; i < 3; i++) {\n    int x = a[r].x + way[i][0], y = a[r].y + way[i][1];\n    if (!x || x > n || !y || y > m) continue;\n    if (b[x][y] < l || b[x][y] > r) continue;\n    for (int j = i + 1; j < 4; j++) {\n      int xx = a[r].x + way[j][0], yy = a[r].y + way[j][1];\n      if (!xx || xx > n || !yy || yy > m) continue;\n      if (b[xx][yy] < l || b[xx][yy] > r) continue;\n      if (connect(b[x][y], b[xx][yy])) return true;\n    }\n  }\n  return false;\n}\ninline void del(int l) {\n  for (int i = 0; i < 4; i++) {\n    int x = a[l].x + way[i][0], y = a[l].y + way[i][1];\n    if (!x || x > n || !y || y > m) continue;\n    if (connect(b[x][y], l)) cut(b[x][y], l);\n  }\n}\ninline void add(int l, int r) {\n  for (int i = 0; i < 4; i++) {\n    int x = a[r].x + way[i][0], y = a[r].y + way[i][1];\n    if (!x || x > n || !y || y > m) continue;\n    if (l <= b[x][y] && b[x][y] < r) {\n      link(b[x][y], r);\n      qx = 1, qy = b[x][y], qz = -1;\n      change(1, 1, up);\n    }\n  }\n  qx = l, qy = r, qz = 1;\n  change(1, 1, up);\n}\nint main() {\n  n = read(), m = read(), up = n * m;\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) {\n      b[i][j] = read();\n      a[b[i][j]] = (node){i, j};\n    }\n  make(1, 1, up);\n  for (int i = 1, j = 1; i <= up; i++) {\n    while (judge(j, i)) del(j++);\n    add(j, i);\n    qx = j, qy = i;\n    pair<int, int> sum = find(1, 1, up);\n    ans += sum.first == 1 ? sum.second : 0;\n  }\n  printf(\"%I64d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int x = 0, f = 1;\n  char c = getchar();\n  for (; !isdigit(c); c = getchar())\n    if (c == '-') f = -1;\n  for (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n  return x * f;\n}\nconst int INF = 9999999;\nconst int MAXN = 1000100;\nconst int MAXM = 200010;\nint N, M;\nint a[MAXM + 1];\nnamespace LCT {\nint ch[MAXN + 1][2];\npair<int, int> mx[MAXN + 1];\nbool rev[MAXN + 1];\nint fa[MAXN + 1];\nint val[MAXN + 1];\ninline bool chd(int x) { return ch[fa[x]][1] == x; }\ninline bool nroot(int x) { return ch[fa[x]][0] == x || ch[fa[x]][1] == x; }\ninline void merge(pair<int, int> &a, pair<int, int> b) {\n  if (a.first < b.first) a = b;\n}\ninline void update(int x) {\n  mx[x] = make_pair(val[x], x);\n  if (ch[x][0]) merge(mx[x], mx[ch[x][0]]);\n  if (ch[x][1]) merge(mx[x], mx[ch[x][1]]);\n}\ninline void Colorf(int x) {\n  if (!x) return;\n  rev[x] ^= 1;\n  swap(ch[x][0], ch[x][1]);\n}\ninline void pushdown(int x) {\n  if (rev[x]) {\n    Colorf(ch[x][0]);\n    Colorf(ch[x][1]);\n    rev[x] = 0;\n  }\n}\ninline void Con(int son, int Fa, int c) {\n  ch[Fa][c] = son;\n  fa[son] = Fa;\n}\ninline void rotate(int x) {\n  int y = fa[x], z = fa[y];\n  bool cx = chd(x), cy = chd(y);\n  int b = ch[x][cx ^ 1];\n  if (nroot(y))\n    Con(x, z, cy);\n  else\n    fa[x] = z;\n  Con(y, x, cx ^ 1);\n  if (b)\n    Con(b, y, cx);\n  else\n    ch[y][cx] = 0;\n  update(y);\n  update(x);\n}\nint sta[MAXN + 1];\ninline void Splay(int x) {\n  int top = 0, y = x;\n  sta[++top] = x;\n  while (nroot(y)) sta[++top] = y = fa[y];\n  while (top) pushdown(sta[top--]);\n  while (nroot(x)) {\n    y = fa[x];\n    if (nroot(y)) {\n      rotate((chd(x) ^ chd(y)) ? x : y);\n    }\n    rotate(x);\n  }\n  update(x);\n}\ninline void access(int x) {\n  for (int y = 0; x; y = x, x = fa[x]) {\n    Splay(x);\n    ch[x][1] = y;\n    update(x);\n  }\n}\ninline void chroot(int x) {\n  access(x);\n  Splay(x);\n  Colorf(x);\n}\ninline void split(int x, int y) {\n  chroot(x);\n  access(y);\n  Splay(y);\n  return;\n}\ninline int findroot(int x) {\n  access(x);\n  Splay(x);\n  while (ch[x][0]) x = ch[x][0];\n  return x;\n}\ninline void Cut(int x, int y) {\n  chroot(x);\n  if (findroot(y) != x || fa[x] != y || ch[x][1]) return;\n  fa[x] = 0;\n  ch[y][0] = 0;\n  update(y);\n}\ninline void Link(int x, int y) {\n  chroot(x);\n  if (findroot(y) != x) fa[x] = y;\n}\ninline void ud(int x) { mx[x] = make_pair(val[x], x); }\n}  // namespace LCT\nnamespace Seg {\nint tag[MAXN << 2];\npair<int, int> mn[MAXN << 2];\ninline void tage_lazy(int rt) {\n  if (tag[rt]) {\n    tag[rt << 1] += tag[rt];\n    tag[rt << 1 | 1] += tag[rt];\n    mn[rt << 1].first += tag[rt];\n    mn[rt << 1 | 1].first += tag[rt];\n    tag[rt] = 0;\n  }\n}\ninline pair<int, int> mg(pair<int, int> a, pair<int, int> b) {\n  if (a.first == b.first) return make_pair(a.first, a.second + b.second);\n  if (a.first < b.first) return a;\n  return b;\n}\ninline void update(int rt) { mn[rt] = mg(mn[rt << 1], mn[rt << 1 | 1]); }\ninline void build(int rt, int l, int r) {\n  if (l == r) {\n    mn[rt] = make_pair(l, 1);\n    return;\n  }\n  int mid = (l + r) >> 1;\n  build(rt << 1, l, mid);\n  build(rt << 1 | 1, mid + 1, r);\n  update(rt);\n}\ninline void Add(int rt, int l, int r, int L, int R, int x) {\n  if (L <= l && R >= r) {\n    tag[rt] += x;\n    mn[rt].first += x;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  tage_lazy(rt);\n  if (L <= mid) Add(rt << 1, l, mid, L, R, x);\n  if (R > mid) Add(rt << 1 | 1, mid + 1, r, L, R, x);\n  update(rt);\n}\ninline void Query(int rt, int l, int r, int L, int R) {\n  if (L <= l && R >= r) {\n    mn[0] = mg(mn[0], mn[rt]);\n    return;\n  }\n  int mid = (l + r) >> 1;\n  tage_lazy(rt);\n  if (L <= mid) Query(rt << 1, l, mid, L, R);\n  if (R > mid) Query(rt << 1 | 1, mid + 1, r, L, R);\n  update(rt);\n  return;\n}\n}  // namespace Seg\npair<int, int> pos[MAXM + 1];\nusing namespace LCT;\nusing namespace Seg;\nint Beg[MAXM + 1];\nint U[MAXM * 4 + 1], V[MAXM * 4 + 1];\nint dis[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\nvector<int> vec[MAXM + 1];\nvector<int> Vx;\nint main() {\n  N = read(), M = read();\n  for (int i = 1; i <= N; i++) {\n    for (int j = 1; j <= M; j++) {\n      a[(i - 1) * M + j] = read();\n      pos[a[(i - 1) * M + j]] = make_pair(i, j);\n    }\n  }\n  int cnte = 0;\n  for (int i = 1; i <= N * M; i++) val[i] = -INF, ud(i);\n  Beg[N * M + 1] = INF;\n  for (int i = N * M; i >= 1; i--) {\n    int x = pos[i].first, y = pos[i].second;\n    Beg[i] = N * M + 1;\n    for (int j = 0; j < 4; j++) {\n      int xx = x + dis[j][0];\n      int yy = y + dis[j][1];\n      if (xx < 1 || yy < 1 || xx > N || yy > M) continue;\n      if (a[(xx - 1) * M + yy] < i) continue;\n      vec[i + 1].push_back(a[(xx - 1) * M + yy]);\n      Vx.push_back(a[(xx - 1) * M + yy]);\n      if (findroot((xx - 1) * M + yy) == findroot((x - 1) * M + y)) {\n        split((xx - 1) * M + yy, (x - 1) * M + y);\n        pair<int, int> ret = mx[(x - 1) * M + y];\n        Beg[i] = min(max(ret.first, a[(xx - 1) * M + yy]), Beg[i]);\n        int cutnod = ret.second - N * M;\n        if (ret.first < a[(xx - 1) * M + yy]) continue;\n        Cut(U[cutnod], ret.second);\n        Cut(V[cutnod], ret.second);\n      }\n      U[++cnte] = (xx - 1) * M + yy;\n      V[cnte] = (x - 1) * M + y;\n      val[cnte + N * M] = a[(xx - 1) * M + yy];\n      ud(cnte + N * M);\n      Link(cnte + N * M, (x - 1) * M + y);\n      Link(cnte + N * M, (xx - 1) * M + yy);\n    }\n    Beg[i] = min(Beg[i], Beg[i + 1]);\n  }\n  build(1, 1, N * M);\n  long long ans = 0;\n  for (int i = 0; i < Vx.size(); i++) Add(1, 1, N * M, Vx[i], N * M, -1);\n  for (int i = 1; i <= N * M; i++) {\n    if (i > 1) Add(1, 1, N * M, i - 1, N * M, -1);\n    for (int j = 0; j < vec[i].size(); j++)\n      Add(1, 1, N * M, vec[i][j], N * M, 1);\n    mn[0] = make_pair(INF, 0);\n    if (i <= Beg[i] - 1) Query(1, 1, N * M, i, Beg[i] - 1);\n    if (mn[0].first == 1) ans += mn[0].second;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, N, a[1005][1005];\npair<int, int> pos[200005];\nnamespace LCT {\nint fa[200005], ch[200005][2];\nbool rev[200005];\ninline bool isc(int x) { return ch[fa[x]][1] == x; }\ninline bool isr(int x) { return ch[fa[x]][0] != x && ch[fa[x]][1] != x; }\ninline void rot(int x) {\n  int y = fa[x], z = fa[y], c = isc(x);\n  !isr(y) && (ch[z][isc(y)] = x);\n  (ch[y][c] = ch[x][!c]) && (fa[ch[y][c]] = y);\n  fa[ch[x][!c] = y] = x, fa[x] = z;\n}\ninline void pd(int x) {\n  if (rev[x]) {\n    swap(ch[x][0], ch[x][1]);\n    rev[ch[x][0]] ^= 1, rev[ch[x][1]] ^= 1;\n    rev[x] = 0;\n  }\n}\ninline void pdpath(int x) {\n  if (!isr(x)) pdpath(fa[x]);\n  pd(x);\n}\ninline void splay(int x) {\n  for (pdpath(x); !isr(x); rot(x))\n    if (!isr(fa[x])) rot(isc(fa[x]) == isc(x) ? fa[x] : x);\n}\ninline void access(int x) {\n  for (int y = 0; x; x = fa[y = x]) splay(x), ch[x][1] = y;\n}\ninline void bert(int x) { access(x), splay(x), rev[x] ^= 1; }\ninline int sert(int x) {\n  access(x), splay(x);\n  for (; ch[x][0]; x = ch[x][0])\n    ;\n  return x;\n}\ninline void link(int x, int y) { bert(x), fa[x] = y; }\ninline void cut(int x, int y) {\n  bert(x), access(y), splay(y), ch[y][0] = fa[x] = 0;\n}\ninline bool connect(int x, int y) {\n  bert(x);\n  return sert(y) == x;\n}\n}  // namespace LCT\nstruct Segment_Tree {\n  pair<int, int> val[200005 << 2];\n  int tag[200005 << 2];\n  void build(int i, int l, int r) {\n    val[i] = pair<int, int>(0, r - l + 1);\n    if (l == r) return;\n    int mid = (l + r) >> 1;\n    build(i << 1, l, mid), build(i << 1 | 1, mid + 1, r);\n  }\n  inline pair<int, int> merge(pair<int, int> a, pair<int, int> b) {\n    if (a.first != b.first) return a.first < b.first ? a : b;\n    return pair<int, int>(a.first, a.second + b.second);\n  }\n  inline void pushdown(int i) {\n    if (tag[i])\n      val[i << 1].first += tag[i], tag[i << 1] += tag[i],\n          val[i << 1 | 1].first += tag[i], tag[i << 1 | 1] += tag[i],\n          tag[i] = 0;\n  }\n  void modify(int i, int l, int r, int first, int second, int v) {\n    if (first <= l && r <= second) {\n      val[i].first += v, tag[i] += v;\n      return;\n    }\n    int mid = (l + r) >> 1;\n    pushdown(i);\n    if (first <= mid) modify(i << 1, l, mid, first, second, v);\n    if (second > mid) modify(i << 1 | 1, mid + 1, r, first, second, v);\n    val[i] = merge(val[i << 1], val[i << 1 | 1]);\n  }\n  pair<int, int> query(int i, int l, int r, int first, int second) {\n    if (first <= l && r <= second) return val[i];\n    int mid = (l + r) >> 1;\n    pair<int, int> ret = pair<int, int>(1e9, 0);\n    pushdown(i);\n    if (first <= mid) ret = merge(ret, query(i << 1, l, mid, first, second));\n    if (second > mid)\n      ret = merge(ret, query(i << 1 | 1, mid + 1, r, first, second));\n    return ret;\n  }\n} T;\nint dx[4] = {1, -1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\nbool check(int k) {\n  for (int i = 0, first; i < 4; i++)\n    if (first = a[pos[k].first + dx[i]][pos[k].second + dy[i]])\n      for (int j = i + 1, second; j < 4; j++)\n        if (second = a[pos[k].first + dx[j]][pos[k].second + dy[j]])\n          if (LCT::connect(first, second)) return 0;\n  return 1;\n}\nvoid del(int k) {\n  for (int i = 0, first; i < 4; i++)\n    if (first = a[pos[k].first + dx[i]][pos[k].second + dy[i]])\n      if (LCT::connect(k, first)) LCT::cut(k, first);\n}\nvoid solve(int l, int r) {\n  for (int i = 0, first; i < 4; i++)\n    if ((first = a[pos[r].first + dx[i]][pos[r].second + dy[i]]) >= l &&\n        first <= r)\n      LCT::link(first, r), T.modify(1, 1, N, l, first, -1);\n  T.modify(1, 1, N, l, r, 1);\n}\nint main() {\n  scanf(\"%d%d\", &n, &m), N = n * m;\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      scanf(\"%d\", &a[i][j]), pos[a[i][j]] = pair<int, int>(i, j);\n  T.build(1, 1, N);\n  long long ans = 0;\n  for (int l = 1, r = 1; r <= N; r++) {\n    while (!check(r)) del(l++);\n    solve(l, r);\n    ans += T.query(1, 1, N, l, r).second;\n  }\n  printf(\"%I64d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint get() {\n  char ch;\n  while (ch = getchar(), (ch < '0' || ch > '9') && ch != '-')\n    ;\n  if (ch == '-') {\n    int s = 0;\n    while (ch = getchar(), ch >= '0' && ch <= '9') s = s * 10 + ch - '0';\n    return -s;\n  }\n  int s = ch - '0';\n  while (ch = getchar(), ch >= '0' && ch <= '9') s = s * 10 + ch - '0';\n  return s;\n}\nconst int N = 1e3 + 5;\nconst int MAXN = 2e5 + 5;\nint n, m;\nint a[N][N];\nint lef[MAXN];\nvector<int> to[MAXN];\nstruct node {\n  int ad, mi, tot;\n} tree[MAXN * 2];\nvoid build(int now, int l, int r) {\n  tree[now].mi = 0;\n  tree[now].tot = r - l + 1;\n  if (l == r) return;\n  int mid = (l + r) / 2;\n  int ls = now + 1, rs = now + (mid - l + 1) * 2;\n  build(ls, l, mid);\n  build(rs, mid + 1, r);\n}\nvoid down(int now, int ls, int rs) {\n  tree[ls].mi += tree[now].ad;\n  tree[ls].ad += tree[now].ad;\n  tree[rs].mi += tree[now].ad;\n  tree[rs].ad += tree[now].ad;\n  tree[now].ad = 0;\n}\nvoid update(int now, int ls, int rs) {\n  tree[now].mi = tree[ls].mi, tree[now].tot = tree[ls].tot;\n  if (tree[rs].mi < tree[now].mi) tree[now].mi = tree[rs].mi, tree[now].tot = 0;\n  if (tree[rs].mi == tree[now].mi) tree[now].tot += tree[rs].tot;\n}\nvoid change(int now, int l, int r, int x, int y, int v) {\n  if (x <= l && r <= y) {\n    tree[now].mi += v;\n    tree[now].ad += v;\n    return;\n  }\n  int mid = (l + r) / 2;\n  int ls = now + 1, rs = now + (mid - l + 1) * 2;\n  down(now, ls, rs);\n  if (x <= mid) change(ls, l, mid, x, y, v);\n  if (y > mid) change(rs, mid + 1, r, x, y, v);\n  update(now, ls, rs);\n}\nint getans(int now, int l, int r, int x, int y) {\n  if (x <= l && r <= y) return tree[now].mi == 1 ? tree[now].tot : 0;\n  int mid = (l + r) / 2;\n  int ls = now + 1, rs = now + (mid - l + 1) * 2;\n  down(now, ls, rs);\n  int ret = 0;\n  if (x <= mid) ret = getans(ls, l, mid, x, y);\n  if (y > mid) ret += getans(rs, mid + 1, r, x, y);\n  return ret;\n}\nstruct point {\n  int s[2];\n  int val, mi;\n  bool bz;\n} pt[MAXN];\nint fa[MAXN], u;\nint L_most;\nvoid update(int x) {\n  pt[x].mi = min(pt[pt[x].s[0]].mi, pt[pt[x].s[1]].mi);\n  pt[x].mi = min(pt[x].mi, pt[x].val);\n}\nvoid down(int x) {\n  if (pt[x].bz) {\n    swap(pt[x].s[0], pt[x].s[1]);\n    pt[pt[x].s[0]].bz ^= 1;\n    pt[pt[x].s[1]].bz ^= 1;\n    pt[x].bz = 0;\n  }\n}\nint pd(int x) {\n  if (x == pt[fa[x]].s[0]) return 0;\n  if (x == pt[fa[x]].s[1]) return 1;\n  return -1;\n}\nvoid rotate(int x) {\n  int y = fa[x], z = fa[y];\n  int tx = pd(x), ty = pd(y);\n  if (ty != -1) pt[z].s[ty] = x;\n  fa[x] = z;\n  if (pt[x].s[tx ^ 1]) fa[pt[x].s[tx ^ 1]] = y;\n  pt[y].s[tx] = pt[x].s[tx ^ 1];\n  pt[x].s[tx ^ 1] = y;\n  fa[y] = x;\n  update(y);\n  update(x);\n  if (ty != -1) update(z);\n}\nint key[MAXN];\nvoid clear(int x) {\n  int k = 0;\n  for (; pd(x) != -1; x = fa[x]) key[++k] = x;\n  key[++k] = x;\n  for (int i = k; i >= 1; i--) down(key[i]);\n}\nvoid splay(int x) {\n  clear(x);\n  for (; pd(x) != -1;) {\n    if (pd(fa[x]) != -1) {\n      if (pd(x) == pd(fa[x]))\n        rotate(fa[x]);\n      else\n        rotate(x);\n    }\n    rotate(x);\n  }\n}\nvoid access(int x) {\n  splay(x);\n  pt[x].s[1] = 0;\n  update(x);\n  for (; fa[x];) {\n    int y = fa[x];\n    splay(y);\n    pt[y].s[1] = x;\n    update(y);\n    splay(x);\n  }\n}\nvoid makeroot(int x) {\n  access(x);\n  splay(x);\n  pt[x].bz ^= 1;\n}\nvoid add(int x, int y) {\n  makeroot(x);\n  makeroot(y);\n  if (!fa[x]) {\n    fa[x] = y;\n    return;\n  }\n  int z = pt[y].mi;\n  if (z == x) {\n    L_most = max(L_most, x + 1);\n    return;\n  }\n  L_most = max(L_most, z + 1);\n  splay(z);\n  int p = pt[z].s[0];\n  fa[p] = 0;\n  pt[z].s[0] = 0;\n  update(z);\n  makeroot(x);\n  makeroot(y);\n  fa[x] = y;\n}\nint main() {\n  n = get();\n  m = get();\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) a[i][j] = get();\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m - 1; j++) {\n      int l = min(a[i][j], a[i][j + 1]), r = max(a[i][j], a[i][j + 1]);\n      to[r].push_back(l);\n    }\n  for (int i = 1; i <= n - 1; i++)\n    for (int j = 1; j <= m; j++) {\n      int l = min(a[i][j], a[i + 1][j]), r = max(a[i][j], a[i + 1][j]);\n      to[r].push_back(l);\n    }\n  int k = n * m;\n  build(1, 1, k);\n  long long ans = 0;\n  L_most = 1;\n  u = k;\n  for (int i = 1; i <= k; i++) pt[i].mi = pt[i].val = i;\n  pt[0].mi = pt[0].val = 1e9;\n  for (int i = 1; i <= k; i++) {\n    change(1, 1, k, 1, i, 1);\n    for (auto c : to[i]) {\n      change(1, 1, k, 1, c, -1);\n      add(c, i);\n    }\n    ans = ans + getans(1, 1, k, L_most, i);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 2000;\nconst int M = 2e5;\nusing namespace std;\nint n, m, a[N + 1][N + 1], id[M + 1][2], dx[5] = {0, 1, -1, 0, 0},\n                                         dy[5] = {0, 0, 0, 1, -1};\nlong long ans;\nstruct lct {\n  int ch[M + 5][2], fa[M + 5], rv[M + 5], size[M + 5];\n  bool chk(int x) { return ch[fa[x]][1] == x; }\n  bool is(int x) { return ch[fa[x]][0] == x || ch[fa[x]][1] == x; }\n  void pushup(int x) { size[x] = size[ch[x][0]] + size[ch[x][1]] + 1; }\n  void rot(int x) {\n    int y = fa[x], z = fa[y], k = chk(x);\n    if (is(y)) ch[z][chk(y)] = x;\n    fa[x] = z;\n    ch[y][k] = ch[x][k ^ 1];\n    fa[ch[x][k ^ 1]] = y;\n    ch[x][k ^ 1] = y;\n    fa[y] = x;\n    pushup(y);\n    pushup(x);\n  }\n  void rev(int x) {\n    rv[x] ^= 1;\n    swap(ch[x][0], ch[x][1]);\n  }\n  void pushdown(int x) {\n    if (rv[x]) {\n      rev(ch[x][0]);\n      rev(ch[x][1]);\n      rv[x] = 0;\n    }\n  }\n  void pushall(int x) {\n    if (is(x)) pushall(fa[x]);\n    pushdown(x);\n  }\n  void splay(int x) {\n    pushall(x);\n    while (is(x)) {\n      int y = fa[x];\n      if (is(y)) {\n        if (chk(x) == chk(y))\n          rot(y);\n        else\n          rot(x);\n      }\n      rot(x);\n    }\n    pushup(x);\n  }\n  void access(int x) {\n    for (int y = 0; x; y = x, x = fa[x]) splay(x), ch[x][1] = y, pushup(x);\n  }\n  void makert(int x) {\n    access(x);\n    splay(x);\n    rev(x);\n  }\n  int findroot(int x) {\n    access(x);\n    splay(x);\n    while (ch[x][0]) pushdown(x), x = ch[x][0];\n    splay(x);\n    return x;\n  }\n  void split(int x, int y) {\n    makert(x);\n    access(y);\n    splay(y);\n  }\n  void link(int x, int y) {\n    makert(x);\n    fa[x] = y;\n  }\n  void cut(int x, int y) {\n    split(x, y);\n    fa[x] = ch[y][0] = 0;\n    pushup(y);\n  }\n  void splay2(int x, int goal) {\n    pushall(x);\n    while (fa[x] != goal) {\n      int y = fa[x];\n      if (fa[y] != goal) {\n        if (chk(x) == chk(y))\n          rot(y);\n        else\n          rot(x);\n      }\n      rot(x);\n    }\n    pushup(x);\n  }\n  bool check(int x, int y) {\n    if (findroot(x) != findroot(y)) return 0;\n    makert(x);\n    access(y);\n    splay(x);\n    splay2(y, x);\n    return ch[y][0] == 0;\n  }\n  void del(int l, int r) {\n    int x = id[l][0], y = id[l][1];\n    for (int i = 1; i <= 4; i++) {\n      int xx = x + dx[i], yy = y + dy[i];\n      if (xx < 1 || xx > n || yy < 1 || yy > m) continue;\n      int v = a[xx][yy];\n      if (v >= l && v <= r && check(v, l)) cut(l, v);\n    }\n  }\n} t;\nstruct Seg {\n  int mi[M * 4 + 5], sm[M * 4 + 5], tag[M * 4 + 5];\n  void pushup(int k) {\n    sm[k] = 0;\n    mi[k] = min(mi[k << 1], mi[k << 1 | 1]);\n    if (mi[k] == mi[k << 1]) sm[k] += sm[k << 1];\n    if (mi[k] == mi[k << 1 | 1]) sm[k] += sm[k << 1 | 1];\n  }\n  void build(int k, int l, int r) {\n    if (l == r) {\n      sm[k] = 1;\n      return;\n    }\n    int mid = l + r >> 1;\n    build(k << 1, l, mid);\n    build(k << 1 | 1, mid + 1, r);\n    pushup(k);\n  }\n  void add(int k, int l, int r, int z) {\n    mi[k] += z;\n    tag[k] += z;\n  }\n  void pushdown(int k, int l, int r, int mid) {\n    if (tag[k]) {\n      add(k << 1, l, mid, tag[k]);\n      add(k << 1 | 1, mid + 1, r, tag[k]);\n      tag[k] = 0;\n    }\n  }\n  void modify(int k, int l, int r, int x, int y, int z) {\n    if (l >= x && r <= y) {\n      add(k, l, r, z);\n      return;\n    }\n    int mid = l + r >> 1;\n    pushdown(k, l, r, mid);\n    if (x <= mid) modify(k << 1, l, mid, x, y, z);\n    if (y > mid) modify(k << 1 | 1, mid + 1, r, x, y, z);\n    pushup(k);\n  }\n  int query(int k, int l, int r, int x, int y) {\n    if (l >= x && r <= y) {\n      if (mi[k] == 1) return sm[k];\n      return 0;\n    }\n    int mid = l + r >> 1;\n    pushdown(k, l, r, mid);\n    if (x > mid)\n      return query(k << 1 | 1, mid + 1, r, x, y);\n    else if (y <= mid)\n      return query(k << 1, l, mid, x, y);\n    else\n      return query(k << 1, l, mid, x, y) + query(k << 1 | 1, mid + 1, r, x, y);\n  }\n} tree;\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) {\n      scanf(\"%d\", &a[i][j]);\n      id[a[i][j]][0] = i;\n      id[a[i][j]][1] = j;\n    }\n  int nm = n * m, l = 1;\n  tree.build(1, 1, nm);\n  for (int r = 1; r <= nm; r++) {\n    int x = id[r][0], y = id[r][1];\n    for (int i = 1; i <= 4; i++) {\n      int xx = x + dx[i], yy = y + dy[i];\n      if (xx > n || xx < 1 || yy > m || yy < 1) continue;\n      int v = a[xx][yy];\n      while (v >= l && v <= r && t.findroot(v) == t.findroot(r)) t.del(l++, r);\n      if (v >= l && v <= r) t.link(v, r);\n    }\n    tree.modify(1, 1, nm, l, r, 1);\n    for (int i = 1; i <= 4; i++) {\n      int xx = x + dx[i], yy = y + dy[i];\n      if (xx > n || xx < 1 || yy > m || yy < 1) continue;\n      int v = a[xx][yy];\n      if (v >= l && v <= r) tree.modify(1, 1, nm, l, v, -1);\n    }\n    ans += tree.query(1, 1, nm, l, r);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int maxn = 200200;\nusing std::cin;\nusing std::cout;\nlong long out;\nint n, w, h;\nnamespace sgt {\nint min[maxn << 2], cnt[maxn << 2], tag[maxn << 2];\ninline void update(int cur) {\n  min[cur] = std::min(min[cur << 1], min[cur << 1 | 1]);\n  cnt[cur] = 0;\n  if (min[cur] == min[cur << 1]) cnt[cur] += cnt[cur << 1];\n  if (min[cur] == min[cur << 1 | 1]) cnt[cur] += cnt[cur << 1 | 1];\n}\ninline void put(int cur, int v) { min[cur] += v, tag[cur] += v; }\ninline void build(int cur, int l, int r) {\n  if (l == r) {\n    min[cur] = -1;\n    cnt[cur] = 1;\n    return;\n  }\n  int mid = l + r >> 1;\n  build(cur << 1, l, mid);\n  build(cur << 1 | 1, mid + 1, r);\n  update(cur);\n}\ninline void pushdown(int cur) {\n  if (tag[cur] != 0) {\n    put(cur << 1, tag[cur]);\n    put(cur << 1 | 1, tag[cur]);\n    tag[cur] = 0;\n  }\n}\ninline void upt(int ql, int qr, int v, int cur = 1, int l = 1, int r = n) {\n  if (ql <= l && r <= qr) return put(cur, v);\n  int mid = l + r >> 1;\n  pushdown(cur);\n  if (ql <= mid) upt(ql, qr, v, cur << 1, l, mid);\n  if (mid < qr) upt(ql, qr, v, cur << 1 | 1, mid + 1, r);\n  update(cur);\n}\ninline int eval(int ql, int qr, int cur = 1, int l = 1, int r = n) {\n  if (ql <= l && r <= qr) return min[cur] == 0 ? cnt[cur] : 0;\n  int mid = l + r >> 1, ans = 0;\n  pushdown(cur);\n  if (ql <= mid) ans += eval(ql, qr, cur << 1, l, mid);\n  if (mid < qr) ans += eval(ql, qr, cur << 1 | 1, mid + 1, r);\n  return ans;\n}\n}  // namespace sgt\nnamespace lct {\nconst int N = maxn << 1;\nint son[N][2], fa[N], max[N], tag[N];\ninline int get(int x, int p = 1) { return son[fa[x]][p] == x; }\ninline int is_root(int x) { return !(get(x) || get(x, 0)); }\ninline void put(int x) {\n  if (x) {\n    tag[x] ^= 1;\n    std::swap(son[x][0], son[x][1]);\n  }\n}\ninline void down(int x) {\n  if (tag[x] != 0) {\n    put(son[x][0]);\n    put(son[x][1]);\n    tag[x] = 0;\n  }\n}\ninline void pushdown(int x) {\n  if (!is_root(x)) pushdown(fa[x]);\n  down(x);\n}\ninline void update(int x) {\n  max[x] = x;\n  if (son[x][0] && max[son[x][0]] > max[x]) max[x] = max[son[x][0]];\n  if (son[x][1] && max[son[x][1]] > max[x]) max[x] = max[son[x][1]];\n}\ninline void rotate(int x) {\n  int y = fa[x], z = fa[y], b = get(x);\n  if (!is_root(y)) son[z][get(y)] = x;\n  son[y][b] = son[x][!b], son[x][!b] = y;\n  fa[son[y][b]] = y, fa[y] = x, fa[x] = z;\n  update(y);\n}\ninline void splay(int x) {\n  for (pushdown(x); !is_root(x); rotate(x))\n    if (!is_root(fa[x])) rotate(get(x) ^ get(fa[x]) ? x : fa[x]);\n  update(x);\n}\ninline void access(int x) {\n  for (int t = 0; x; son[x][1] = t, t = x, x = fa[x]) splay(x);\n}\ninline void makeroot(int x) { access(x), splay(x), put(x); }\ninline void split(int x, int y) { makeroot(x), access(y), splay(y); }\ninline bool con(int x, int y) {\n  split(x, y);\n  for (; son[y][0];) y = son[y][0];\n  splay(y);\n  return x == y;\n}\nstd::vector<int> edge[N];\nint min;\ninline void cut(int x, int y) {\n  if (con(x, y)) {\n    split(x, y);\n    if (son[y][0] == x && !son[x][1]) {\n      son[y][0] = fa[x] = 0;\n      update(y);\n    }\n  }\n}\ninline void link(int x, int y) {\n  if (con(x, y)) {\n    split(x, y);\n    int id = max[y];\n    for (int x : edge[id]) cut(id, x);\n    min = std::min(min, id - 1);\n  }\n  makeroot(x), fa[x] = y;\n  edge[x].push_back(y);\n  edge[y].push_back(x);\n}\n}  // namespace lct\nint a[1010][1010];\nint px[maxn], py[maxn];\ninline int id(int x, int y) { return (x - 1) * h + y; }\ninline void try_link(int x, int y, int tx, int ty) {\n  if (1 <= tx && tx <= w && 1 <= ty && ty <= h && a[x][y] < a[tx][ty]) {\n    lct::link(a[x][y], a[tx][ty]);\n    sgt::upt(a[tx][ty], n, -1);\n  }\n}\nint main() {\n  std::ios::sync_with_stdio(false), cin.tie(0);\n  cin >> w >> h, n = w * h;\n  for (int i = 1; i <= w; ++i) {\n    for (int j = 1; j <= h; ++j) {\n      cin >> a[i][j];\n      px[a[i][j]] = i;\n      py[a[i][j]] = j;\n    }\n  }\n  lct::min = n;\n  sgt::build(1, 1, n);\n  for (int i = n; i >= 1; --i) {\n    int x = px[i], y = py[i];\n    sgt::upt(i, n, 1);\n    try_link(x, y, x - 1, y);\n    try_link(x, y, x + 1, y);\n    try_link(x, y, x, y - 1);\n    try_link(x, y, x, y + 1);\n    out += sgt::eval(i, lct::min);\n  }\n  cout << out << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing nagai = long long;\nconst int N = 1 << 18;\nint fa[N], sz[N];\nint flag[N];\nint ch[N][2];\nint chnum(int x) { return ch[fa[x]][1] == x; }\nint is_r(int x) { return !(ch[fa[x]][1] == x || ch[fa[x]][0] == x); }\nvoid push(int x) {\n  if (flag[x]) {\n    swap(ch[x][0], ch[x][1]);\n    flag[ch[x][0]] ^= 1, flag[ch[x][1]] ^= 1;\n    flag[x] = 0;\n  }\n}\nvoid rev(int x) {\n  flag[x] = true;\n  push(x);\n}\nvoid update(int x) {\n  if (x) sz[x] = 1 + sz[ch[x][0]] + sz[ch[x][1]];\n}\nvoid attach(int x, int y, int side) {\n  fa[x] = y;\n  ch[y][side] = x;\n}\nvoid check(int x) { assert(sz[x] == sz[ch[x][0]] + sz[ch[x][1]] + 1); }\nvoid rotate(int x) {\n  int y = fa[x], z = fa[y], b = chnum(x), t = ch[x][b ^ 1];\n  int c = chnum(fa[x]);\n  if (!is_r(y))\n    attach(x, z, c);\n  else\n    fa[x] = z;\n  attach(y, x, b ^ 1);\n  attach(t, y, b);\n  update(y);\n  update(x);\n}\nvoid splay(int x) {\n  static int mem[N];\n  static int ptr = 0;\n  int y = x;\n  while (!is_r(y)) mem[ptr++] = y, y = fa[y];\n  mem[ptr++] = y;\n  while (ptr > 0) push(mem[ptr - 1]), --ptr;\n  while (!is_r(x)) {\n    int y = fa[x];\n    if (!is_r(fa[x])) rotate(chnum(x) == chnum(y) ? y : x);\n    rotate(x);\n  }\n}\nvoid print(int x) {\n  if (!x) return;\n  check(x);\n  print(ch[x][0]);\n  cerr << x << ' ';\n  print(ch[x][1]);\n}\nvoid access(int x) {\n  for (int dwn = 0; x; dwn = x, x = fa[x]) splay(x), ch[x][1] = dwn, update(x);\n}\nvoid makeroot(int x) { access(x), splay(x), rev(x); }\nbool is_conn(int x, int y) {\n  if (x == y) return 1;\n  makeroot(x);\n  makeroot(y);\n  return !(fa[x] == 0 && fa[y] == 0);\n}\nvoid cut(int x, int y) {\n  makeroot(x);\n  access(y);\n  splay(y);\n  assert(ch[y][0] == x);\n  ch[y][0] = fa[x] = 0;\n  update(y);\n}\nvoid link(int x, int y) {\n  makeroot(x);\n  makeroot(y);\n  assert(fa[x] == 0);\n  fa[x] = y;\n}\nint n, m;\nconst int S = 1010;\nint matr[S][S];\nint nocyc[N];\nint kek(pair<int, int> mem) { return mem.first * m + mem.second + 1; }\nvector<int> dx = {0, 1, 0, -1}, dy = {1, 0, -1, 0};\nbool added[N];\nvector<int> neigh(int a) {\n  --a;\n  int x = a / m, y = a % m;\n  vector<int> ans;\n  for (int i = 0; i < 4; ++i) {\n    int x1 = x + dx[i], y1 = y + dy[i];\n    if (x1 >= 0 && y1 >= 0 && x1 < n && y1 < m && added[x1 * m + y1 + 1])\n      ans.push_back(x1 * m + y1 + 1);\n  }\n  return ans;\n}\nbool check(pair<int, int> a) {\n  int x = kek(a);\n  auto ne = neigh(x);\n  for (int i = 0; i < ne.size(); ++i)\n    for (int j = 0; j < i; ++j)\n      if (is_conn(ne[i], ne[j])) return false;\n  return true;\n}\nvoid add(pair<int, int> a) {\n  int x = kek(a);\n  added[x] = true;\n  for (int y : neigh(x)) {\n    assert(!is_conn(x, y));\n    link(x, y);\n  }\n}\nvoid rem(pair<int, int> a) {\n  int x = kek(a);\n  added[x] = false;\n  for (int y : neigh(x)) {\n    assert(is_conn(x, y));\n    cut(x, y);\n  }\n}\nconst int oo = 1e9;\nint C = 1;\nstruct it {\n  int sum[2 * N], mn[2 * N], mn1[2 * N], cntmn[2 * N], cntmn1[2 * N];\n  it() {\n    for (int i = 2 * N - 1; i >= 0; --i) {\n      if (i < n)\n        update(i);\n      else\n        sum[i] = 0, mn[i] = 0, mn1[i] = oo, cntmn[i] = 1, cntmn1[i] = 0;\n    }\n  }\n  void update(int i) {\n    int le = 2 * i;\n    int ri = 2 * i + 1;\n    sum[i] = sum[le] + sum[ri];\n    int kek[4] = {mn[le], mn1[le], sum[le] + mn[ri], sum[le] + mn1[ri]};\n    mn[i] = oo;\n    mn1[i] = oo;\n    for (int x : kek)\n      if (x < mn[i])\n        mn1[i] = mn[i], mn[i] = x;\n      else if (x != mn[i] && x < mn1[i])\n        mn1[i] = x;\n    cntmn[i] = 0;\n    cntmn1[i] = 0;\n    if (mn[le] == mn[i]) cntmn[i] += cntmn[le];\n    if (mn[le] == mn1[i])\n      cntmn1[i] += cntmn[le];\n    else if (mn1[le] == mn1[i])\n      cntmn1[i] += cntmn1[le];\n    if (sum[le] + mn[ri] == mn[i]) cntmn[i] += cntmn[ri];\n    if (sum[le] + mn[ri] == mn1[i])\n      cntmn1[i] += cntmn[ri];\n    else if (sum[le] + mn1[ri] == mn1[i])\n      cntmn1[i] += cntmn1[ri];\n  }\n  void add(int i, int ch) {\n    i += N;\n    sum[i] += ch;\n    mn[i] = sum[i];\n    mn1[i] = sum[i];\n    cntmn[i] = 1;\n    cntmn1[i] = 1;\n    while (i > 1) update(i >> 1), i >>= 1;\n  }\n  int get(int x, int l, int r, int qr, int cur) {\n    if (cur + mn[x] > C) return 0;\n    if (l >= qr) return 0;\n    if (r <= qr)\n      if (cur + mn[x] == C)\n        return cntmn[x];\n      else {\n        if (cur + mn1[x] == 1) return cntmn1[x];\n        return 0;\n      }\n    int m = (l + r) / 2;\n    return get(x * 2, l, m, qr, cur) +\n           get(x * 2 + 1, m, r, qr, cur + sum[x * 2]);\n  }\n} myit;\nmt19937 rnd(228);\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  n = 1000, m = 200;\n  cin >> n >> m;\n  vector<int> kekos(n * m);\n  iota(kekos.begin(), kekos.end(), 1);\n  shuffle(kekos.begin(), kekos.end(), rnd);\n  for (int i = 0; i < n * m; ++i) sz[i] = 1;\n  int t = 0;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j) {\n      matr[i][j] = kekos[t++];\n      cin >> matr[i][j];\n      --matr[i][j];\n    }\n  vector<pair<int, int>> ord;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j) ord.emplace_back(i, j);\n  sort(ord.begin(), ord.end(), [&](pair<int, int> a, pair<int, int> b) {\n    return matr[a.first][a.second] < matr[b.first][b.second];\n  });\n  int cur = ord.size();\n  for (int i = ord.size() - 1; i >= 0; --i) {\n    while (!check(ord[i])) rem(ord[--cur]);\n    nocyc[i] = cur;\n    add(ord[i]);\n  }\n  memset(added, 0, sizeof added);\n  nagai ansich = 0;\n  for (int i = ord.size() - 1; i >= 0; --i) {\n    int x = ord[i].first, y = ord[i].second;\n    myit.add(i, 1);\n    for (int k = 0; k < 4; ++k) {\n      int x1 = x + dx[k], y1 = y + dy[k];\n      if (x1 >= 0 && y1 >= 0 && x1 < n && y1 < m && added[matr[x1][y1]])\n        myit.add(matr[x1][y1], -1);\n    }\n    added[i] = true;\n    int mem = myit.get(1, 0, N, nocyc[i], 0);\n    ansich += mem;\n  }\n  cout << ansich << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <class T>\ninline void read(T &res) {\n  char ch;\n  while (ch = getchar(), !isdigit(ch))\n    ;\n  res = ch ^ 48;\n  while (ch = getchar(), isdigit(ch)) res = res * 10 + ch - 48;\n}\nusing std::set;\nusing std::vector;\nconst int N = 2e5 + 5;\nconst int M = 8e5 + 5;\nconst int dx[] = {0, 0, -1, 1}, dy[] = {-1, 1, 0, 0};\nint que[N], val[N], px[N], py[N], tag[M], lc[N], rc[N], fa[N], rev[N];\nint tot, now_e, qr, n, m, l, r;\nlong long ans;\nvector<int> a[N];\nnamespace LinkCutTree {\ninline bool whichSide(int x) { return lc[fa[x]] == x; }\ninline bool isRoot(int x) { return lc[fa[x]] != x && rc[fa[x]] != x; }\ninline void addRev(int x) {\n  if (!x) return;\n  rev[x] ^= 1;\n  std::swap(lc[x], rc[x]);\n}\ninline void pushDown(int x) {\n  if (rev[x]) {\n    addRev(lc[x]);\n    addRev(rc[x]);\n    rev[x] = 0;\n  }\n}\ninline void Rotate(int x) {\n  int y = fa[x], z = fa[y], b = lc[y] == x ? rc[x] : lc[x];\n  if (!isRoot(y)) (lc[z] == y ? lc[z] : rc[z]) = x;\n  fa[y] = x, fa[x] = z;\n  b ? fa[b] = y : 0;\n  lc[y] == x ? (rc[x] = y, lc[y] = b) : (lc[x] = y, rc[y] = b);\n}\ninline void Splay(int x) {\n  que[qr = 1] = x;\n  for (int y = x; !isRoot(y); y = fa[y]) que[++qr] = fa[y];\n  for (int i = qr; i >= 1; --i) pushDown(que[i]);\n  while (!isRoot(x)) {\n    if (!isRoot(fa[x])) Rotate(whichSide(fa[x]) == whichSide(x) ? fa[x] : x);\n    Rotate(x);\n  }\n}\ninline void Access(int x) {\n  for (int y = 0; x; y = x, x = fa[x]) Splay(x), rc[x] = y;\n}\ninline int findRoot(int x) {\n  Access(x);\n  Splay(x);\n  int w = x;\n  while (pushDown(w), lc[w]) w = lc[w];\n  Splay(w);\n  return w;\n}\ninline void makeRoot(int x) {\n  Access(x);\n  Splay(x);\n  addRev(x);\n}\ninline void Link(int x, int y) {\n  makeRoot(x);\n  fa[x] = y;\n}\ninline void Cut(int x, int y) {\n  makeRoot(x);\n  Access(y);\n  Splay(y);\n  lc[y] = fa[x] = 0;\n}\n}  // namespace LinkCutTree\ntemplate <class T>\ninline T Min(T x, T y) {\n  return x < y ? x : y;\n}\nstruct node {\n  int mx, cnt;\n  node() {}\n  node(int Mx, int Cnt) : mx(Mx), cnt(Cnt) {}\n  friend inline node operator+(const node &a, const node &b) {\n    node c;\n    c.mx = Min(a.mx, b.mx);\n    c.cnt = 0;\n    c.mx == a.mx ? c.cnt += a.cnt : 0;\n    c.mx == b.mx ? c.cnt += b.cnt : 0;\n    return c;\n  }\n} tr[M];\nnamespace SegmentTree {\ninline void Update(int s) { tr[s] = tr[s << 1] + tr[s << 1 | 1]; }\ninline void addTag(int s, int v) {\n  tag[s] += v;\n  tr[s].mx += v;\n}\ninline void pushDown(int s) {\n  if (tag[s]) {\n    addTag(s << 1, tag[s]);\n    addTag(s << 1 | 1, tag[s]);\n    tag[s] = 0;\n  }\n}\ninline void Build(int s, int l, int r) {\n  if (l == r) return (void)(tr[s] = node(val[l], 1));\n  int mid = l + r >> 1;\n  Build(s << 1, l, mid);\n  Build(s << 1 | 1, mid + 1, r);\n  Update(s);\n}\ninline void Modify(int s, int l, int r, int x, int v) {\n  if (l == r) return addTag(s, v);\n  pushDown(s);\n  int mid = l + r >> 1;\n  x <= mid ? (addTag(s << 1 | 1, v), Modify(s << 1, l, mid, x, v))\n           : Modify(s << 1 | 1, mid + 1, r, x, v);\n  Update(s);\n}\ninline node Query(int s, int l, int r, int x, int y) {\n  if (l == x && r == y) return tr[s];\n  pushDown(s);\n  int mid = l + r >> 1;\n  if (y <= mid)\n    return Query(s << 1, l, mid, x, y);\n  else if (x > mid)\n    return Query(s << 1 | 1, mid + 1, r, x, y);\n  else\n    return Query(s << 1, l, mid, x, mid) +\n           Query(s << 1 | 1, mid + 1, r, mid + 1, y);\n}\n}  // namespace SegmentTree\ninline bool check() {\n  int x = px[r + 1], y = py[r + 1], cnt = 0;\n  set<int> s;\n  s.clear();\n  for (int k = 0; k < 4; ++k) {\n    int tx = x + dx[k], ty = y + dy[k];\n    if (tx >= 1 && tx <= n && ty >= 1 && ty <= m && a[tx][ty] >= l &&\n        a[tx][ty] <= r)\n      s.insert(LinkCutTree::findRoot(a[tx][ty])), ++cnt;\n  }\n  return s.size() == cnt;\n}\ninline void Insert() {\n  ++r;\n  int x = px[r], y = py[r];\n  for (int k = 0; k < 4; ++k) {\n    int tx = x + dx[k], ty = y + dy[k];\n    if (tx >= 1 && tx <= n && ty >= 1 && ty <= m && a[tx][ty] >= l &&\n        a[tx][ty] <= r)\n      LinkCutTree::Link(r, a[tx][ty]);\n  }\n}\ninline void Delete() {\n  int x = px[l], y = py[l];\n  for (int k = 0; k < 4; ++k) {\n    int tx = x + dx[k], ty = y + dy[k];\n    if (tx >= 1 && tx <= n && ty >= 1 && ty <= m) {\n      if (a[tx][ty] >= l && a[tx][ty] <= r) LinkCutTree::Cut(l, a[tx][ty]);\n      if (a[tx][ty] >= l) SegmentTree::Modify(1, 1, tot, a[tx][ty], 1);\n    }\n  }\n}\nint main() {\n  read(n);\n  read(m);\n  for (int i = 1; i <= n; ++i) a[i].resize(m + 1);\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j) {\n      read(a[i][j]);\n      px[a[i][j]] = i;\n      py[a[i][j]] = j;\n    }\n  tot = n * m;\n  for (int i = 1; i <= tot; ++i) {\n    int x = px[i], y = py[i];\n    for (int k = 0; k < 4; ++k) {\n      int tx = x + dx[k], ty = y + dy[k];\n      if (tx >= 1 && tx <= n && ty >= 1 && ty <= m && a[tx][ty] < i) ++now_e;\n    }\n    val[i] = i - now_e;\n  }\n  SegmentTree::Build(1, 1, tot);\n  r = 1;\n  for (l = 1; l <= tot; ++l) {\n    while (r < tot && check()) Insert();\n    ans += SegmentTree::Query(1, 1, tot, l, r).cnt;\n    SegmentTree::Modify(1, 1, tot, l, -1);\n    Delete();\n  }\n  std::cout << ans << std::endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\nint read() {\n  int x = 0, f = 1;\n  char c = getchar();\n  while (c > '9' || c < '0') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    x = x * 10 + c - '0';\n    c = getchar();\n  }\n  return x * f;\n}\nint swap(int &x, int &y) {\n  int t = x;\n  x = y;\n  y = t;\n}\nint n, m, a[2005][2005], ch[N][2], fa[N], sze[N], p[N];\nbool notRT(int x) { return ch[fa[x]][0] == x || ch[fa[x]][1] == x; }\nint sk[N];\nvector<int> S[N];\nvoid tag(int x) {\n  swap(ch[x][0], ch[x][1]);\n  p[x] ^= 1;\n}\nvoid pushdown(int x) {\n  if (p[x]) {\n    p[x] = 0;\n    if (ch[x][0]) tag(ch[x][0]);\n    if (ch[x][1]) tag(ch[x][1]);\n  }\n}\nvoid pushup(int x) { sze[x] = sze[ch[x][0]] + sze[ch[x][1]] + 1; }\nvoid rotate(int x) {\n  int y = fa[x], z = fa[y];\n  bool k = ch[y][1] == x;\n  int w = ch[x][k ^ 1];\n  if (notRT(y)) ch[z][ch[z][1] == y] = x;\n  ch[x][k ^ 1] = y;\n  ch[y][k] = w;\n  if (w) fa[w] = y;\n  fa[y] = x;\n  fa[x] = z;\n  pushup(y);\n  pushup(x);\n}\nvoid splay(int x) {\n  int y = x, z = 0;\n  sk[++z] = x;\n  while (notRT(y)) sk[++z] = y = fa[y];\n  while (z) pushdown(sk[z--]);\n  while (notRT(x)) {\n    y = fa[x];\n    z = fa[y];\n    if (notRT(y)) rotate(((ch[z][1] == y) ^ (ch[y][1] == x)) ? x : y);\n    rotate(x);\n  }\n}\nvoid access(int x) {\n  for (int y = 0; x; x = fa[y = x]) splay(x), ch[x][1] = y, pushup(x);\n}\nvoid makeroot(int x) {\n  access(x);\n  splay(x);\n  tag(x);\n}\nint findroot(int x) {\n  access(x);\n  splay(x);\n  while (ch[x][0]) pushdown(x), x = ch[x][0];\n  splay(x);\n  return x;\n}\nbool link(int x, int y) {\n  makeroot(x);\n  if (findroot(y) != x)\n    fa[x] = y;\n  else\n    return 0;\n  return 1;\n}\nbool cut(int x, int y) {\n  makeroot(x);\n  if (findroot(y) == x && !ch[y][0] && fa[y] == x) {\n    fa[y] = ch[x][1] = 0;\n    pushup(x);\n    return 1;\n  }\n  return 0;\n}\nstruct PT {\n  int mn, cnt, lzy;\n  PT() {}\n  PT(int _mn, int _cnt, int _lzy) {\n    mn = _mn;\n    cnt = _cnt;\n    lzy = _lzy;\n  }\n  PT operator+(const PT &q) const {\n    PT res(0, 0, 0);\n    if (mn == q.mn) {\n      res.mn = mn;\n      res.cnt = cnt + q.cnt;\n    } else if (mn < q.mn) {\n      res.mn = mn;\n      res.cnt = cnt;\n    } else {\n      res.mn = q.mn;\n      res.cnt = q.cnt;\n    }\n    return res;\n  }\n} t[N << 2];\nvoid change(int i, int k) {\n  t[i].lzy += k;\n  t[i].mn += k;\n}\nvoid pdn(int i) {\n  if (t[i].lzy) {\n    change((i << 1), t[i].lzy);\n    change((i << 1 | 1), t[i].lzy);\n    t[i].lzy = 0;\n  }\n}\nvoid build(int i, int l, int r) {\n  t[i].cnt = r - l + 1;\n  if (l == r) return;\n  build((i << 1), l, ((l + r) >> 1));\n  build((i << 1 | 1), ((l + r) >> 1) + 1, r);\n}\nvoid updata(int i, int l, int r, int x, int y, int k) {\n  if (x <= l && r <= y) {\n    change(i, k);\n    return;\n  }\n  pdn(i);\n  if (x <= ((l + r) >> 1)) updata((i << 1), l, ((l + r) >> 1), x, y, k);\n  if (y > ((l + r) >> 1)) updata((i << 1 | 1), ((l + r) >> 1) + 1, r, x, y, k);\n  t[i] = t[(i << 1)] + t[(i << 1 | 1)];\n}\nPT query(int i, int l, int r, int x, int y) {\n  if (x <= l && r <= y) return t[i];\n  PT res(998299, 0, 0);\n  pdn(i);\n  if (x <= ((l + r) >> 1)) res = res + query((i << 1), l, ((l + r) >> 1), x, y);\n  if (y > ((l + r) >> 1))\n    res = res + query((i << 1 | 1), ((l + r) >> 1) + 1, r, x, y);\n  return res;\n}\nint main() {\n  n = read();\n  m = read();\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j) a[i][j] = read();\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j < m; ++j)\n      S[a[i][j]].push_back(a[i][j + 1]), S[a[i][j + 1]].push_back(a[i][j]);\n  for (int i = 1; i < n; ++i)\n    for (int j = 1; j <= m; ++j)\n      S[a[i][j]].push_back(a[i + 1][j]), S[a[i + 1][j]].push_back(a[i][j]);\n  long long ans = 0;\n  build(1, 1, n * m);\n  for (int L = 1, R = 0; L <= n * m; ++L) {\n    while (R < n * m) {\n      ++R;\n      bool f = 1;\n      for (int i = S[R].size() - 1; i >= 0; --i) {\n        int v = S[R][i];\n        if (v >= L && v <= R) {\n          if (!link(v, R)) {\n            f = 0;\n            break;\n          }\n          updata(1, 1, n * m, R, n * m, -1);\n        }\n      }\n      if (f == 0) {\n        for (int i = S[R].size() - 1; i >= 0; --i) {\n          int v = S[R][i];\n          if (v >= L && v <= R)\n            if (cut(v, R))\n              updata(1, 1, n * m, R, n * m, 1);\n            else\n              break;\n        }\n        --R;\n        break;\n      }\n      updata(1, 1, n * m, R, n * m, 1);\n    }\n    PT res = query(1, 1, n * m, L, R);\n    if (res.mn == 1) ans += res.cnt;\n    updata(1, 1, n * m, L, n * m, -1);\n    for (int i = S[L].size() - 1; i >= 0; --i) {\n      int v = S[L][i];\n      if (v >= L && v <= R)\n        if (cut(v, L)) updata(1, 1, n * m, v, n * m, 1);\n    }\n  }\n  printf(\"%lld\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e3 + 7, M = 2e6 + 7;\nstruct query {\n  int u, v;\n} e[M];\nlong long ans;\nbool rev[M];\nint n, m, tp, ts, cnt, pos, que[5], qut[5], w[N][N], st[M], lt[M], rt[M], ta[M],\n    tb[M], tc[M], pot[M], lent[M], fa[M], ch[M][2];\ninline int read() {\n  int num = 0;\n  char g = getchar();\n  while (g < 48 || 57 < g) g = getchar();\n  while (47 < g && g < 58)\n    num = (num << 1) + (num << 3) + g - 48, g = getchar();\n  return num;\n}\ninline void build(int l, int r, int t) {\n  lt[t] = l, rt[t] = r, tb[t] = r - l + 1;\n  if (l == r) return;\n  int d = (l + r) >> 1;\n  build(l, d, t << 1), build(d + 1, r, t << 1 | 1);\n}\ninline void addit(int l, int r, int t, int z) {\n  ta[t << 1] += tc[t], ta[t << 1 | 1] += tc[t], tc[t << 1] += tc[t],\n      tc[t << 1 | 1] += tc[t], tc[t] = 0;\n  if (lt[t] == l && rt[t] == r) {\n    tc[t] += z, ta[t] += z;\n    return;\n  }\n  int d = (lt[t] + rt[t]) >> 1;\n  if (l <= d) addit(l, min(d, r), t << 1, z);\n  if (r > d) addit(max(d + 1, l), r, t << 1 | 1, z);\n  if (ta[t << 1] < ta[t << 1 | 1])\n    ta[t] = ta[t << 1], tb[t] = tb[t << 1];\n  else if (ta[t << 1] > ta[t << 1 | 1])\n    ta[t] = ta[t << 1 | 1], tb[t] = tb[t << 1 | 1];\n  else\n    ta[t] = ta[t << 1], tb[t] = tb[t << 1] + tb[t << 1 | 1];\n}\ninline void search(int l, int r, int t) {\n  ta[t << 1] += tc[t], ta[t << 1 | 1] += tc[t], tc[t << 1] += tc[t],\n      tc[t << 1 | 1] += tc[t], tc[t] = 0;\n  if (lt[t] == l && rt[t] == r) {\n    if (ta[t] == 1) ans += tb[t];\n    return;\n  }\n  int d = (lt[t] + rt[t]) >> 1;\n  if (l <= d) search(l, min(d, r), t << 1);\n  if (r > d) search(max(d + 1, l), r, t << 1 | 1);\n}\ninline int calc(int x, int y) { return (x - 1) * m + y; }\ninline bool isroot(int u) { return (ch[fa[u]][0] != u && ch[fa[u]][1] != u); }\ninline bool get(int u) { return (ch[fa[u]][1] == u); }\ninline void revit(int u) {\n  if (rev[u])\n    swap(ch[u][0], ch[u][1]), rev[ch[u][0]] ^= 1, rev[ch[u][1]] ^= 1,\n        rev[u] ^= 1;\n}\ninline void rotate(int u) {\n  int pa = fa[u], gr = fa[pa], x = get(u);\n  if (!isroot(pa)) ch[gr][get(pa)] = u;\n  fa[u] = gr;\n  ch[pa][x] = ch[u][x ^ 1], fa[ch[u][x ^ 1]] = pa, ch[u][x ^ 1] = pa,\n  fa[pa] = u;\n}\ninline void splay(int u) {\n  st[st[0] = 1] = u;\n  for (int x = u; !isroot(x); x = fa[x]) st[++st[0]] = fa[x];\n  for (int x = st[0]; x > 0; x--) revit(st[x]);\n  for (; !isroot(u); rotate(u))\n    if (!isroot(fa[u])) rotate(get(fa[u]) == get(u) ? fa[u] : u);\n}\ninline void access(int u) {\n  for (int i = 0; u > 0; i = u, u = fa[u]) splay(u), ch[u][1] = i;\n}\ninline void makeroot(int u) { access(u), splay(u), rev[u] ^= 1; }\ninline void link(int u, int v) { makeroot(v), fa[v] = u; }\ninline void cut(int u, int v) {\n  makeroot(u), access(v), splay(v), fa[u] = 0, ch[v][0] = 0;\n}\ninline int find(int u) {\n  access(u), splay(u);\n  while (ch[u][0]) u = ch[u][0];\n  return u;\n}\nint main() {\n  n = read(), m = read(), build(1, n * m, 1), pos = n * m, tp = 1, ts = 1;\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      w[i][j] = read(), e[w[i][j]].u = i, e[w[i][j]].v = j;\n  while (tp <= n * m) {\n    int px = e[tp].u, py = e[tp].v;\n    que[0] = 0, qut[1] = -1, qut[2] = -2, qut[3] = -3, qut[4] = -4;\n    if (w[px - 1][py] >= ts && w[px - 1][py] < tp)\n      que[++que[0]] = calc(px - 1, py);\n    if (w[px + 1][py] >= ts && w[px + 1][py] < tp)\n      que[++que[0]] = calc(px + 1, py);\n    if (w[px][py - 1] >= ts && w[px][py - 1] < tp)\n      que[++que[0]] = calc(px, py - 1);\n    if (w[px][py + 1] >= ts && w[px][py + 1] < tp)\n      que[++que[0]] = calc(px, py + 1);\n    for (int i = 1; i <= que[0]; i++) qut[i] = find(que[i]);\n    if (qut[1] == qut[2] || qut[1] == qut[3] || qut[1] == qut[4] ||\n        qut[2] == qut[3] || qut[2] == qut[4] || qut[3] == qut[4]) {\n      pot[ts] = tp, que[0] = 0;\n      int px = e[ts].u, py = e[ts].v;\n      if (w[px - 1][py] >= ts && w[px - 1][py] < tp)\n        que[++que[0]] = calc(px - 1, py);\n      if (w[px + 1][py] >= ts && w[px + 1][py] < tp)\n        que[++que[0]] = calc(px + 1, py);\n      if (w[px][py - 1] >= ts && w[px][py - 1] < tp)\n        que[++que[0]] = calc(px, py - 1);\n      if (w[px][py + 1] >= ts && w[px][py + 1] < tp)\n        que[++que[0]] = calc(px, py + 1);\n      for (int i = 1; i <= que[0]; i++) cut(calc(px, py), que[i]);\n      ts++;\n      continue;\n    }\n    for (int i = 1; i <= que[0]; i++) link(calc(px, py), que[i]);\n    tp++;\n    continue;\n  }\n  for (int i = n * m; i > 0; i--) {\n    int px = e[i].u, py = e[i].v;\n    if (w[px - 1][py] > i) addit(w[px - 1][py], n * m, 1, -1);\n    if (w[px + 1][py] > i) addit(w[px + 1][py], n * m, 1, -1);\n    if (w[px][py - 1] > i) addit(w[px][py - 1], n * m, 1, -1);\n    if (w[px][py + 1] > i) addit(w[px][py + 1], n * m, 1, -1);\n    if (!pot[i]) pot[i] = n * m + 1;\n    addit(i, n * m, 1, 1);\n    search(i, pot[i] - 1, 1);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint read() {\n  int a = 0;\n  char c = getchar();\n  bool f = 0;\n  while (!isdigit(c)) {\n    f = c == '-';\n    c = getchar();\n  }\n  while (isdigit(c)) {\n    a = a * 10 + c - 48;\n    c = getchar();\n  }\n  return f ? -a : a;\n}\nconst int _ = 2e5 + 3, dir[4][2] = {0, 1, 0, -1, 1, 0, -1, 0};\nint N, M, L = 1, R, arr[_];\nlong long cnt;\npair<int, int> to[_];\nnamespace segt {\nint mn[_ << 2], cnt[_ << 2], mrk[_ << 2];\nvoid init(int x, int l, int r) {\n  mn[x] = 1e9;\n  cnt[x] = r - l + 1;\n  if (l != r) {\n    init((x << 1), l, ((l + r) >> 1));\n    init((x << 1 | 1), ((l + r) >> 1) + 1, r);\n  }\n}\nvoid mark(int x, int val) {\n  mrk[x] += val;\n  mn[x] += val;\n}\nvoid down(int x) {\n  mark((x << 1), mrk[x]);\n  mark((x << 1 | 1), mrk[x]);\n  mrk[x] = 0;\n}\nvoid up(int x) {\n  mn[x] = min(mn[(x << 1)], mn[(x << 1 | 1)]);\n  cnt[x] = (mn[x] == mn[(x << 1)]) * cnt[(x << 1)] +\n           (mn[x] == mn[(x << 1 | 1)]) * cnt[(x << 1 | 1)];\n}\nvoid modify(int x, int l, int r, int L, int R, int val) {\n  if (l >= L && r <= R) return mark(x, val);\n  down(x);\n  if (((l + r) >> 1) >= L) modify((x << 1), l, ((l + r) >> 1), L, R, val);\n  if (((l + r) >> 1) < R)\n    modify((x << 1 | 1), ((l + r) >> 1) + 1, r, L, R, val);\n  up(x);\n}\n}  // namespace segt\nnamespace LCT {\nint fa[_], ch[_][2];\nbool rmrk[_];\nbool nroot(int x) { return ch[fa[x]][0] == x || ch[fa[x]][1] == x; }\nbool son(int x) { return ch[fa[x]][1] == x; }\nvoid mark(int x) {\n  rmrk[x] ^= 1;\n  swap(ch[x][0], ch[x][1]);\n}\nvoid down(int x) {\n  if (rmrk[x]) {\n    mark(ch[x][0]);\n    mark(ch[x][1]);\n    rmrk[x] = 0;\n  }\n}\nvoid dall(int x) {\n  if (nroot(x)) dall(fa[x]);\n  down(x);\n}\nvoid rot(int x) {\n  bool f = son(x);\n  int y = fa[x], z = fa[y], w = ch[x][f ^ 1];\n  fa[x] = z;\n  if (nroot(y)) ch[z][son(y)] = x;\n  fa[y] = x;\n  ch[x][f ^ 1] = y;\n  ch[y][f] = w;\n  if (w) fa[w] = y;\n}\nvoid splay(int x) {\n  dall(x);\n  while (nroot(x)) {\n    if (nroot(fa[x])) rot(son(fa[x]) == son(x) ? fa[x] : x);\n    rot(x);\n  }\n}\nvoid access(int x) {\n  for (int y = 0; x; y = x, x = fa[x]) {\n    splay(x);\n    ch[x][1] = y;\n  }\n}\nint fdrt(int x) {\n  access(x);\n  splay(x);\n  while (ch[x][0]) down(x = ch[x][0]);\n  splay(x);\n  return x;\n}\nvoid mkrt(int x) {\n  access(x);\n  splay(x);\n  mark(x);\n}\nvoid split(int x, int y) {\n  mkrt(x);\n  access(y);\n  splay(y);\n}\nvoid link(int x, int y) {\n  mkrt(x);\n  fa[x] = y;\n}\nvoid cut(int x, int y) {\n  split(x, y);\n  ch[y][0] = fa[x] = 0;\n}\n}  // namespace LCT\nvoid cut() {\n  pair<int, int> pos = to[L];\n  segt::modify(1, 1, N * M, L, L, 1e9);\n  for (int i = 0; i < 4; ++i) {\n    int x = pos.first + dir[i][0], y = pos.second + dir[i][1];\n    if (x > 0 && x <= N && y > 0 && y <= M &&\n        LCT::fdrt(arr[((x - 1) * M + y)]) == LCT::fdrt(L))\n      LCT::cut(arr[((x - 1) * M + y)], L);\n  }\n  ++L;\n}\nvoid link() {\n  pair<int, int> pos = to[R];\n  for (int i = 0; i < 4; ++i) {\n    int x = pos.first + dir[i][0], y = pos.second + dir[i][1];\n    if (x > 0 && x <= N && y > 0 && y <= M) {\n      int t = arr[((x - 1) * M + y)];\n      while (t >= L && LCT::fdrt(t) == LCT::fdrt(R)) cut();\n      if (t >= L && t <= R) LCT::link(t, R);\n    }\n  }\n  for (int i = 0; i < 4; ++i) {\n    int x = pos.first + dir[i][0], y = pos.second + dir[i][1];\n    if (x > 0 && x <= N && y > 0 && y <= M && arr[((x - 1) * M + y)] >= L &&\n        arr[((x - 1) * M + y)] <= R)\n      segt::modify(1, 1, N * M, 1, arr[((x - 1) * M + y)], -1);\n  }\n}\nint main() {\n  N = read();\n  M = read();\n  segt::init(1, 1, N * M);\n  for (int i = 1; i <= N; ++i)\n    for (int j = 1; j <= M; ++j)\n      to[arr[((i - 1) * M + j)] = read()] = pair<int, int>(i, j);\n  while (++R <= N * M) {\n    segt::modify(1, 1, N * M, R, R, -1e9);\n    segt::modify(1, 1, N * M, 1, R, 1);\n    link();\n    cnt += (segt::mn[1] == 1) * segt::cnt[1];\n  }\n  cout << cnt;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline void read(int &x) {\n  int flag = 1;\n  char ch;\n  while (!isdigit(ch = getchar()))\n    if (ch == '-') flag = -flag;\n  for (x = 0; isdigit(ch); x = x * 10 + ch - '0', ch = getchar())\n    ;\n  x *= flag;\n}\nconst int MAXN = 1005;\nconst int MAXP = 1000005;\nconst int INF = 1e9;\nnamespace LCT {\nint ch[MAXP][2], fa[MAXP];\nbool rev[MAXP];\ninline bool isr(int x) { return ch[fa[x]][0] != x && ch[fa[x]][1] != x; }\ninline bool get(int x) { return ch[fa[x]][1] == x; }\ninline void mt(int x) {\n  if (rev[x])\n    rev[x] ^= 1, rev[ch[x][0]] ^= 1, rev[ch[x][1]] ^= 1,\n        swap(ch[x][0], ch[x][1]);\n}\nvoid mtpath(int x) {\n  if (!isr(x)) mtpath(fa[x]);\n  mt(x);\n}\ninline void rot(int x) {\n  int y = fa[x], z = fa[y];\n  bool l = get(x), r = l ^ 1;\n  if (!isr(y)) ch[z][get(y)] = x;\n  fa[ch[x][r]] = y;\n  fa[y] = x;\n  fa[x] = z;\n  ch[y][l] = ch[x][r];\n  ch[x][r] = y;\n}\ninline void splay(int x) {\n  mtpath(x);\n  for (; !isr(x); rot(x))\n    if (!isr(fa[x])) rot(get(fa[x]) == get(x) ? fa[x] : x);\n}\ninline void access(int x) {\n  int y = 0;\n  for (; x; x = fa[y = x]) splay(x), ch[x][1] = y;\n}\ninline void bert(int x) { access(x), splay(x), rev[x] ^= 1; }\ninline int sert(int x) {\n  access(x), splay(x);\n  for (; ch[x][0]; x = ch[x][0])\n    ;\n  return x;\n}\ninline void link(int x, int y) {\n  bert(x);\n  if (sert(y) != x) fa[x] = y;\n}\ninline void cut(int x, int y) {\n  bert(x);\n  sert(y);\n  fa[x] = ch[y][0] = 0;\n}\ninline bool connect(int x, int y) {\n  bert(x);\n  return sert(y) == x;\n}\n}  // namespace LCT\nusing namespace LCT;\nint n, m, a[MAXN][MAXN], tot;\npair<int, int> pos[MAXP], val[MAXP << 2];\nint lz[MAXP << 2];\ninline pair<int, int> merge(pair<int, int> A, pair<int, int> B) {\n  if (A.first < B.first)\n    return A;\n  else if (A.first > B.first)\n    return B;\n  return pair<int, int>(A.first, A.second + B.second);\n}\ninline void upd(int i) { val[i] = merge(val[i << 1], val[i << 1 | 1]); }\ninline void pd(int i) {\n  if (lz[i]) {\n    val[i << 1].first += lz[i], lz[i << 1] += lz[i];\n    val[i << 1 | 1].first += lz[i], lz[i << 1 | 1] += lz[i];\n    lz[i] = 0;\n  }\n}\nvoid build(int i, int l, int r) {\n  if (l == r) {\n    val[i] = pair<int, int>(0, 1);\n    return;\n  }\n  int mid = (l + r) >> 1;\n  build(i << 1, l, mid);\n  build(i << 1 | 1, mid + 1, r);\n  upd(i);\n}\nvoid modify(int i, int l, int r, int x, int y, int v) {\n  if (x <= l && r <= y) {\n    val[i].first += v, lz[i] += v;\n    return;\n  }\n  pd(i);\n  int mid = (l + r) >> 1;\n  if (x <= mid) modify(i << 1, l, mid, x, y, v);\n  if (y > mid) modify(i << 1 | 1, mid + 1, r, x, y, v);\n  upd(i);\n}\npair<int, int> query(int i, int l, int r, int x, int y) {\n  if (x <= l && r <= y) return val[i];\n  pd(i);\n  int mid = (l + r) >> 1;\n  pair<int, int> re = pair<int, int>(INF, 0);\n  if (x <= mid) re = merge(re, query(i << 1, l, mid, x, y));\n  if (y > mid) re = merge(re, query(i << 1 | 1, mid + 1, r, x, y));\n  return re;\n}\nconst int dx[4] = {0, 0, 1, -1};\nconst int dy[4] = {1, -1, 0, 0};\ninline bool chkout(int x, int y) { return x < 1 || y < 1 || x > n || y > m; }\ninline bool check(int l, int r) {\n  for (int i = 0; i < 3; ++i) {\n    int x = pos[r].first + dx[i];\n    int y = pos[r].second + dy[i];\n    if (chkout(x, y) || a[x][y] < l || a[x][y] > r) continue;\n    for (int j = i + 1; j < 4; ++j) {\n      int u = pos[r].first + dx[j];\n      int v = pos[r].second + dy[j];\n      if (chkout(u, v) || a[u][v] < l || a[u][v] > r) continue;\n      if (connect(a[x][y], a[u][v])) return 0;\n    }\n  }\n  return 1;\n}\ninline void del(int l) {\n  for (int i = 0; i < 4; ++i) {\n    int x = pos[l].first + dx[i];\n    int y = pos[l].second + dy[i];\n    if (chkout(x, y) || !connect(l, a[x][y])) continue;\n    cut(l, a[x][y]);\n  }\n}\ninline void solve(int l, int r) {\n  for (int i = 0; i < 4; ++i) {\n    int x = pos[r].first + dx[i];\n    int y = pos[r].second + dy[i];\n    if (chkout(x, y) || a[x][y] < l || a[x][y] > r) continue;\n    link(a[x][y], r);\n    modify(1, 1, tot, 1, a[x][y], -1);\n  }\n  modify(1, 1, tot, l, r, 1);\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  tot = n * m;\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n      scanf(\"%d\", &a[i][j]), pos[a[i][j]] = pair<int, int>(i, j);\n  build(1, 1, tot);\n  long long ans = 0;\n  for (int i = 1, j = 1; i <= tot; ++i) {\n    while (!check(j, i)) del(j++);\n    solve(j, i);\n    ans += query(1, 1, tot, j, i).second;\n  }\n  printf(\"%I64d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct StVal {\n  int minV = 0, numMin = 0;\n  StVal() {}\n  StVal(const int _v) : minV(_v), numMin(1) {}\n  StVal(const StVal& v1, const StVal& v2) {\n    if (v1.minV < v2.minV) {\n      minV = v1.minV;\n      numMin = v1.numMin;\n    } else if (v1.minV > v2.minV) {\n      minV = v2.minV;\n      numMin = v2.numMin;\n    } else {\n      minV = v1.minV;\n      numMin = v1.numMin + v2.numMin;\n    }\n  }\n};\nstruct StUpdate {\n  int v = 0;\n  StUpdate() {}\n  StUpdate(const int v) : v(v) {}\n  StUpdate(const StUpdate& u1, const StUpdate& u2) { v = u1.v + u2.v; }\n  void apply(StVal& sv, const int lo, const int hi) { sv.minV += v; }\n};\nstruct SegTree {\n  int n;\n  vector<StVal> st;\n  vector<StUpdate> lazy;\n  vector<int> leaves;\n  SegTree(const int n) : n(n) {\n    leaves.resize(n);\n    init(1, 0, n - 1);\n    lazy.resize(st.size());\n  }\n  void init(const int si, const int lo, const int hi) {\n    if (lo == hi) {\n      if (si >= (int)st.size()) {\n        st.resize(si + 1);\n      }\n      st[si] = StVal(0);\n      leaves[lo] = si;\n      return;\n    }\n    int lC = si << 1, rC = (si << 1) | 1, mid = (lo + hi) >> 1;\n    init(lC, lo, mid);\n    init(rC, mid + 1, hi);\n    st[si] = StVal(st[lC], st[rC]);\n  }\n  void updateLazy(const int si, const int lo, const int hi) {\n    lazy[si].apply(st[si], lo, hi);\n    if (lo != hi) {\n      lazy[si << 1] = StUpdate(lazy[si << 1], lazy[si]);\n      lazy[si << 1 | 1] = StUpdate(lazy[si << 1 | 1], lazy[si]);\n    }\n    lazy[si] = StUpdate();\n  }\n  StVal query(const int l, const int r) {\n    return (l <= r && l < n && r >= 0) ? query(l, r, 1, 0, n - 1) : StVal();\n  }\n  StVal query(const int l, const int r, const int si, const int lo,\n              const int hi) {\n    updateLazy(si, lo, hi);\n    if (l <= lo && hi <= r) return st[si];\n    const int mid = (lo + hi) >> 1;\n    if (r <= mid) return query(l, r, si << 1, lo, mid);\n    if (mid < l) return query(l, r, si << 1 | 1, mid + 1, hi);\n    return StVal(query(l, r, si << 1, lo, mid),\n                 query(l, r, si << 1 | 1, mid + 1, hi));\n  }\n  void update(const int l, const int r, const StUpdate u) {\n    if (l <= r) update(l, r, u, 1, 0, n - 1);\n  }\n  void update(const int l, const int r, const StUpdate& u, const int si,\n              const int lo, const int hi) {\n    if (l <= lo && hi <= r) {\n      lazy[si] = StUpdate(lazy[si], u);\n      updateLazy(si, lo, hi);\n    } else {\n      updateLazy(si, lo, hi);\n      if (hi < l || r < lo) return;\n      const int mid = (lo + hi) >> 1;\n      update(l, r, u, si << 1, lo, mid);\n      update(l, r, u, si << 1 | 1, mid + 1, hi);\n      st[si] = StVal(st[si << 1], st[si << 1 | 1]);\n    }\n  }\n  void updateAllLazy() { updateAllLazy(1, 0, n - 1); }\n  void updateAllLazy(const int si, const int lo, const int hi) {\n    updateLazy(si, lo, hi);\n    if (lo != hi) {\n      const int mid = (lo + hi) >> 1;\n      updateAllLazy(si << 1, lo, mid);\n      updateAllLazy(si << 1 | 1, mid + 1, hi);\n    }\n  }\n};\nstruct Node {\n  array<Node*, 2> child{};\n  Node* splayTreeParent = nullptr;\n  Node* pathParentPointer = nullptr;\n  bool reverse = false;\n  Node() {}\n  bool getSide() {\n    return splayTreeParent ? splayTreeParent->child[1] == this : false;\n  }\n  void tryReverse() {\n    if (!reverse) {\n      return;\n    }\n    reverse = false;\n    swap(child[0], child[1]);\n    if (child[0]) {\n      child[0]->reverse = !child[0]->reverse;\n    }\n    if (child[1]) {\n      child[1]->reverse = !child[1]->reverse;\n    }\n  }\n  Node* splay() {\n    vector<Node*> ancestors;\n    Node* cur = this;\n    while (cur) {\n      ancestors.push_back(cur);\n      cur = cur->splayTreeParent;\n    }\n    for (int i = ancestors.size() - 1; i >= 0; i--) {\n      if (!ancestors[i]) {\n        continue;\n      }\n      ancestors[i]->tryReverse();\n    }\n    while (splayTreeParent) {\n      if (splayTreeParent->splayTreeParent) {\n        (getSide() == splayTreeParent->getSide() ? splayTreeParent : this)\n            ->rotate();\n      }\n      rotate();\n    }\n    return this;\n  }\n  Node* rotate() {\n    bool side = getSide(), parentSide = splayTreeParent->getSide();\n    auto ancestor = splayTreeParent->splayTreeParent;\n    pathParentPointer = splayTreeParent->pathParentPointer;\n    splayTreeParent->pathParentPointer = nullptr;\n    splayTreeParent->attach(child[!side], side);\n    attach(splayTreeParent, !side);\n    if (ancestor)\n      ancestor->attach(this, parentSide);\n    else\n      splayTreeParent = nullptr;\n    return this;\n  }\n  Node* attach(Node* node, int side) {\n    if (node) node->splayTreeParent = this;\n    child[side] = node;\n    return this;\n  }\n};\nstruct LinkCutTreeGeneral {\n  void link(Node* parent, Node* child) {\n    assert(findRoot(child) != findRoot(parent));\n    access(child);\n    access(parent);\n    Node* lChild = child->child[0];\n    if (lChild) {\n      lChild->reverse = !lChild->reverse;\n      detachChild(child, 0);\n    }\n    child->attach(parent, 0);\n  }\n  void cut(Node* u) {\n    access(u);\n    assert(u->child[0]);\n    u->child[0]->splayTreeParent = nullptr;\n    u->child[0] = nullptr;\n  }\n  void cut(Node* u, Node* v) {\n    bool b = findRoot(u) != findRoot(v);\n    access(u);\n    assert(!(b && u->child[0] && findMax(u->child[0]) == v));\n    if (u->child[0] && findMax(u->child[0]) == v) {\n      cut(u);\n      return;\n    }\n    access(v);\n    assert(!(b && v->child[0] && findMax(v->child[0]) == u));\n    if (v->child[0] && findMax(v->child[0]) == u) {\n      cut(v);\n    }\n  }\n  Node* findRoot(Node* u) {\n    access(u);\n    while (u->child[0]) {\n      u = u->child[0];\n    }\n    return u;\n  }\n\n private:\n  Node* access(Node* u) {\n    u->splay();\n    detachChild(u, 1);\n    Node* curPP = u;\n    while (u->pathParentPointer) {\n      curPP = u->pathParentPointer;\n      curPP->splay();\n      detachChild(curPP, 1);\n      curPP->attach(u, 1);\n      u->pathParentPointer = nullptr;\n      u->splay();\n    }\n    return curPP;\n  }\n  Node* findMax(Node* u) {\n    if (!u) {\n      return nullptr;\n    }\n    while (u->child[1]) {\n      u = u->child[1];\n    }\n    return u;\n  }\n  void detachChild(Node* u, bool b) {\n    if (!u->child[b]) {\n      return;\n    }\n    u->child[b]->pathParentPointer = u;\n    u->child[b]->splayTreeParent = nullptr;\n    u->child[b] = nullptr;\n  }\n};\nstruct NodeWithId : Node {\n  int id;\n  NodeWithId(int id) : Node(), id(id) {}\n};\nstruct DynamicTreeLCT {\n  LinkCutTreeGeneral lct;\n  vector<NodeWithId*> nodes;\n  int n = 0;\n  DynamicTreeLCT() {}\n  int addNode() {\n    nodes.push_back(new NodeWithId(n));\n    return n++;\n  }\n  void link(int parentId, int childId) {\n    lct.link(nodes[parentId], nodes[childId]);\n  }\n  void cut(int id) { lct.cut(nodes[id]); }\n  void cut(int u, int v) { lct.cut(nodes[u], nodes[v]); }\n  int findRoot(int u) {\n    auto res = (NodeWithId*)lct.findRoot(nodes[u]);\n    return res->id;\n  }\n  bool connected(int u, int v) { return findRoot(u) == findRoot(v); }\n};\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nvector<int> numToID;\nint n, m;\nvoid cutNeighbors(DynamicTreeLCT& lct, vector<vector<int>>& grid, int l,\n                  int r) {\n  int i = numToID[l] / m, j = numToID[l] % m;\n  int idx = numToID[l];\n  for (int k = 0; k < 4; k++) {\n    int ni = i + dx[k], nj = j + dy[k];\n    if (ni < 0 || nj < 0 || ni == n || nj == m) {\n      continue;\n    }\n    if (grid[ni][nj] < l || grid[ni][nj] > r) {\n      continue;\n    }\n    int nIdx = numToID[grid[ni][nj]];\n    lct.cut(idx, nIdx);\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0), cout.tie(0);\n  DynamicTreeLCT lct;\n  cin >> n >> m;\n  vector<vector<int>> grid(n, vector<int>(m));\n  numToID.resize(n * m + 1);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      cin >> grid[i][j];\n      numToID[grid[i][j]] = lct.addNode();\n    }\n  }\n  SegTree st(n * m + 1);\n  long long ans = 0;\n  int l = 1;\n  for (int r = 1; r <= m * n; r++) {\n    st.update(l, r, StUpdate(1));\n    int i = numToID[r] / m, j = numToID[r] % m;\n    int idx = numToID[r];\n    for (int k = 0; k < 4; k++) {\n      int ni = i + dx[k], nj = j + dy[k];\n      if (ni < 0 || nj < 0 || ni == n || nj == m) {\n        continue;\n      }\n      if (grid[ni][nj] < l || grid[ni][nj] > r) {\n        continue;\n      }\n      int nIdx = numToID[grid[ni][nj]];\n      while (lct.connected(idx, nIdx)) {\n        cutNeighbors(lct, grid, l, r);\n        l++;\n      }\n      if (l > grid[ni][nj]) {\n        continue;\n      }\n      if (l == r) {\n        break;\n      }\n      lct.link(idx, nIdx);\n      st.update(l, grid[ni][nj], StUpdate(-1));\n    }\n    ans += st.query(l, r).numMin;\n  }\n  cout << ans << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct LCT {\n  int ch[1000000][3], fa[1000000], turn[1000000];\n  int Get(int x) { return ch[fa[x]][1] == x; }\n  int nroot(int x) { return ch[fa[x]][1] == x || ch[fa[x]][0] == x; }\n  void pushr(int x) {\n    if (!x) return;\n    swap(ch[x][0], ch[x][1]);\n    turn[x] ^= 1;\n  }\n  void pushdown(int x) {\n    if (turn[x]) {\n      pushr(ch[x][0]), pushr(ch[x][1]);\n      turn[x] = 0;\n    }\n  }\n  void pushall(int x) {\n    if (nroot(x)) pushall(fa[x]);\n    pushdown(x);\n  }\n  void rotate(int x) {\n    int y = fa[x], z = fa[y], w = Get(x);\n    if (nroot(y)) ch[z][ch[z][1] == y] = x;\n    ch[y][w] = ch[x][w ^ 1];\n    if (ch[y][w]) fa[ch[y][w]] = y;\n    ch[x][w ^ 1] = y;\n    fa[y] = x;\n    fa[x] = z;\n  }\n  void splay(int x) {\n    pushall(x);\n    while (nroot(x)) {\n      int y = fa[x];\n      if (nroot(y)) Get(x) ^ Get(y) ? rotate(x) : rotate(y);\n      rotate(x);\n    }\n  }\n  void access(int x) {\n    for (int y = 0; x; x = fa[y = x]) {\n      splay(x);\n      ch[x][1] = y;\n    }\n  }\n  int findroot(int x) {\n    access(x);\n    splay(x);\n    while (ch[x][0]) x = ch[x][0];\n    splay(x);\n    return x;\n  }\n  void makeroot(int x) {\n    access(x);\n    splay(x);\n    pushr(x);\n    return;\n  }\n  int link(int x, int y) {\n    makeroot(x);\n    if (findroot(y) == x) return false;\n    fa[x] = y;\n    return true;\n  }\n  void cut(int x, int y) {\n    makeroot(x);\n    if (findroot(y) == x && fa[y] == x && !ch[y][0]) {\n      fa[y] = ch[x][1] = 0;\n    }\n    return;\n  }\n} T;\nstruct segment_tree {\n  int Min[4 * 1000000], Num[4 * 1000000], lazy[4 * 1000000];\n  void pushdown(int x) {\n    if (lazy[x]) {\n      lazy[x << 1] += lazy[x];\n      lazy[x << 1 | 1] += lazy[x];\n      Min[x << 1] += lazy[x], Min[x << 1 | 1] += lazy[x];\n      lazy[x] = 0;\n    }\n  }\n  void pushup(int x) {\n    if (Min[x << 1] < Min[x << 1 | 1])\n      Min[x] = Min[x << 1], Num[x] = Num[x << 1];\n    if (Min[x << 1] > Min[x << 1 | 1])\n      Min[x] = Min[x << 1 | 1], Num[x] = Num[x << 1 | 1];\n    if (Min[x << 1] == Min[x << 1 | 1])\n      Min[x] = Min[x << 1], Num[x] = Num[x << 1] + Num[x << 1 | 1];\n  }\n  void build(int x, int l, int r) {\n    if (l == r) {\n      Min[x] = 0, Num[x] = 1;\n      return;\n    }\n    int mid = l + r >> 1;\n    build(x << 1, l, mid);\n    build(x << 1 | 1, mid + 1, r);\n    pushup(x);\n  }\n  void modify(int x, int l, int r, int ll, int rr, int k) {\n    if (l == ll && r == rr) {\n      lazy[x] += k;\n      Min[x] += k;\n      return;\n    }\n    pushdown(x);\n    int mid = l + r >> 1;\n    if (rr <= mid)\n      modify(x << 1, l, mid, ll, rr, k);\n    else if (ll > mid)\n      modify(x << 1 | 1, mid + 1, r, ll, rr, k);\n    else\n      modify(x << 1, l, mid, ll, mid, k),\n          modify(x << 1 | 1, mid + 1, r, mid + 1, rr, k);\n    pushup(x);\n  }\n  int query(int x, int l, int r, int ll, int rr) {\n    if (l == ll && r == rr) {\n      if (Min[x] == 1)\n        return Num[x];\n      else\n        return 0;\n    }\n    int mid = l + r >> 1;\n    pushdown(x);\n    if (rr <= mid)\n      return query(x << 1, l, mid, ll, rr);\n    else if (ll > mid)\n      return query(x << 1 | 1, mid + 1, r, ll, rr);\n    else\n      return query(x << 1, l, mid, ll, mid) +\n             query(x << 1 | 1, mid + 1, r, mid + 1, rr);\n  }\n} S;\nvector<int> V[1000000];\nint dx[10] = {1, 0, -1, 0};\nint dy[10] = {0, 1, 0, -1};\nint n, m, w[3000][3000];\nlong long ans = 0;\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) scanf(\"%d\", &w[i][j]);\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      for (int d = 0; d < 4; d++) {\n        int x = i + dx[d], y = j + dy[d];\n        if (x < 1 || y < 1 || x > n || y > m) continue;\n        if (w[x][y] > w[i][j]) continue;\n        V[w[x][y]].push_back(w[i][j]);\n        V[w[i][j]].push_back(w[x][y]);\n      }\n    }\n  }\n  int R = 0;\n  long long t = n * m;\n  S.build(1, 1, t);\n  for (int i = 1; i <= t; i++) {\n    for (int j = R + 1; j <= t; j++) {\n      int now = j, flag = 0;\n      for (int d = 0; d < V[now].size(); d++) {\n        int now1 = V[now][d];\n        if (now1 < now && now1 >= i)\n          if (!T.link(now1, now)) {\n            flag = 1;\n            break;\n          }\n      }\n      for (int d = 0; d < V[now].size(); d++) T.cut(now, V[now][d]);\n      if (flag == 1) break;\n      R = j;\n      int tot = 0;\n      for (int d = 0; d < V[now].size(); d++) {\n        int now1 = V[now][d];\n        if (now1 < j && now1 >= i) T.link(now1, now);\n        if (now1 < j && now1 >= i) tot++;\n      }\n      S.modify(1, 1, t, R, R, R - i + 1);\n      S.modify(1, 1, t, R, t, -tot);\n    }\n    ans += 1ll * S.query(1, 1, t, i, R);\n    int tot = 0;\n    for (int d = 0; d < V[i].size(); d++) {\n      if (V[i][d] <= R && V[i][d] > i) {\n        T.cut(V[i][d], i);\n        S.modify(1, 1, t, V[i][d], t, 1);\n      }\n    }\n    S.modify(1, 1, t, i, R, -1);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nnamespace CPTH {\ntemplate <typename valueType, typename modType>\nstruct SegmentTreeNode {\n  size_t id;\n  long long left, right;\n  valueType val;\n  modType mod;\n};\ntemplate <typename valueType, typename modType,\n          bool elementModificationOnly = false>\nclass SegmentTree {\n public:\n  SegmentTree() = default;\n  SegmentTree(\n      const std::vector<valueType> &_initValue,\n      std::function<valueType(const valueType &, const valueType &)> _merge,\n      std::function<void(SegmentTreeNode<valueType, modType> &,\n                         const modType &)>\n          _update,\n      long long _startPoint = 1, const valueType &_valueZero = valueType(),\n      const modType &_modZero = modType());\n  void init(\n      const std::vector<valueType> &_initValue,\n      std::function<valueType(const valueType &, const valueType &)> _merge,\n      std::function<void(SegmentTreeNode<valueType, modType> &,\n                         const modType &)>\n          _update,\n      long long _startPoint = 1, const valueType &_valueZero = valueType(),\n      const modType &_modZero = modType());\n  void modify(long long l, long long r, const modType &mod);\n  void modify(long long p, const modType &mod);\n  valueType query(long long l, long long r);\n  valueType query(long long p);\n\n private:\n  void pushup(size_t cur);\n  void pushdown(size_t cur);\n  void build(size_t cur, long long l, long long r,\n             const std::vector<valueType> &initValue);\n  void m_init(\n      const std::vector<valueType> &_initValue,\n      std::function<valueType(const valueType &, const valueType &)> _merge,\n      std::function<void(SegmentTreeNode<valueType, modType> &,\n                         const modType &)>\n          _update,\n      const valueType &_valueZero, const modType &_modZero);\n  void modify(size_t cur, long long l, long long r, long long L, long long R,\n              const modType &mod);\n  valueType query(size_t cur, long long l, long long r, long long L,\n                  long long R);\n  std::function<valueType(const valueType &, const valueType &)> merge;\n  std::function<void(SegmentTreeNode<valueType, modType> &, const modType &)>\n      update;\n  std::vector<SegmentTreeNode<valueType, modType>> nodes;\n  long long leftRange = 0, rightRange = 0;\n  valueType valueZero;\n  modType modZero;\n};\ntemplate <typename valueType, typename modType, bool elementModificationOnly>\nSegmentTree<valueType, modType, elementModificationOnly>::SegmentTree(\n    const std::vector<valueType> &_initValue,\n    std::function<valueType(const valueType &, const valueType &)> _merge,\n    std::function<void(SegmentTreeNode<valueType, modType> &, const modType &)>\n        _update,\n    long long _startPoint, const valueType &_valueZero,\n    const modType &_modZero) {\n  init(_initValue, _merge, _update, _startPoint, _valueZero, _modZero);\n}\ntemplate <typename valueType, typename modType, bool elementModificationOnly>\nvoid SegmentTree<valueType, modType, elementModificationOnly>::init(\n    const std::vector<valueType> &_initValue,\n    std::function<valueType(const valueType &, const valueType &)> _merge,\n    std::function<void(SegmentTreeNode<valueType, modType> &, const modType &)>\n        _update,\n    long long _startPoint, const valueType &_valueZero,\n    const modType &_modZero) {\n  assert(_startPoint >= LLONG_MIN / 2);\n  assert(_startPoint <= LLONG_MAX / 2 - (long long)_initValue.size());\n  leftRange = _startPoint;\n  rightRange = _startPoint + _initValue.size();\n  m_init(_initValue, _merge, _update, _valueZero, _modZero);\n}\ntemplate <typename valueType, typename modType, bool elementModificationOnly>\nvoid SegmentTree<valueType, modType, elementModificationOnly>::modify(\n    long long l, long long r, const modType &mod) {\n  assert(!elementModificationOnly);\n  modify(1, leftRange, rightRange, l, r, mod);\n}\ntemplate <typename valueType, typename modType, bool elementModificationOnly>\nvoid SegmentTree<valueType, modType, elementModificationOnly>::modify(\n    long long p, const modType &mod) {\n  assert(p < LLONG_MAX);\n  modify(1, leftRange, rightRange, p, p + 1, mod);\n}\ntemplate <typename valueType, typename modType, bool elementModificationOnly>\nvalueType SegmentTree<valueType, modType, elementModificationOnly>::query(\n    long long l, long long r) {\n  return query(1, leftRange, rightRange, l, r);\n}\ntemplate <typename valueType, typename modType, bool elementModificationOnly>\nvalueType SegmentTree<valueType, modType, elementModificationOnly>::query(\n    long long p) {\n  return query(p, p + 1);\n}\ntemplate <typename valueType, typename modType, bool elementModificationOnly>\nvoid SegmentTree<valueType, modType, elementModificationOnly>::pushup(\n    size_t cur) {\n  nodes[cur].val = merge(nodes[cur << 1].val, nodes[cur << 1 | 1].val);\n}\ntemplate <typename valueType, typename modType, bool elementModificationOnly>\nvoid SegmentTree<valueType, modType, elementModificationOnly>::pushdown(\n    size_t cur) {\n  update(nodes[cur << 1], nodes[cur].mod);\n  update(nodes[cur << 1 | 1], nodes[cur].mod);\n  nodes[cur].mod = modZero;\n}\ntemplate <typename valueType, typename modType, bool elementModificationOnly>\nvoid SegmentTree<valueType, modType, elementModificationOnly>::build(\n    size_t cur, long long l, long long r,\n    const std::vector<valueType> &initValue) {\n  nodes[cur].id = cur;\n  nodes[cur].left = l;\n  nodes[cur].right = r;\n  nodes[cur].mod = modZero;\n  if (l == r - 1)\n    nodes[cur].val = initValue[l - leftRange];\n  else {\n    build(cur << 1, l, (l + r) >> 1, initValue);\n    build(cur << 1 | 1, (l + r) >> 1, r, initValue);\n    pushup(cur);\n  }\n}\ntemplate <typename valueType, typename modType, bool elementModificationOnly>\nvoid SegmentTree<valueType, modType, elementModificationOnly>::m_init(\n    const std::vector<valueType> &_initValue,\n    std::function<valueType(const valueType &, const valueType &)> _merge,\n    std::function<void(SegmentTreeNode<valueType, modType> &, const modType &)>\n        _update,\n    const valueType &_valueZero, const modType &_modZero) {\n  merge = _merge;\n  update = _update;\n  valueZero = _valueZero;\n  modZero = _modZero;\n  nodes.resize((rightRange - leftRange) << 2);\n  build(1, leftRange, rightRange, _initValue);\n}\ntemplate <typename valueType, typename modType, bool elementModificationOnly>\nvoid SegmentTree<valueType, modType, elementModificationOnly>::modify(\n    size_t cur, long long l, long long r, long long L, long long R,\n    const modType &mod) {\n  if (l >= R || r <= L) return;\n  if (L <= l && r <= R)\n    update(nodes[cur], mod);\n  else {\n    if (!elementModificationOnly) pushdown(cur);\n    modify(cur << 1, l, (l + r) >> 1, L, R, mod);\n    modify(cur << 1 | 1, (l + r) >> 1, r, L, R, mod);\n    pushup(cur);\n  }\n}\ntemplate <typename valueType, typename modType, bool elementModificationOnly>\nvalueType SegmentTree<valueType, modType, elementModificationOnly>::query(\n    size_t cur, long long l, long long r, long long L, long long R) {\n  if (l >= R || r <= L) return valueZero;\n  if (L <= l && r <= R) return nodes[cur].val;\n  if (!elementModificationOnly) pushdown(cur);\n  return merge(query(cur << 1, l, (l + r) >> 1, L, R),\n               query(cur << 1 | 1, (l + r) >> 1, r, L, R));\n}\n}  // namespace CPTH\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\nusing namespace std;\nconst double inf = 1e121;\nconst double eps = 1e-10;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint randint(int l, int r) {\n  int out = rng() % (r - l + 1) + l;\n  return out >= l ? out : out + r - l + 1;\n}\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\nstring to_string(const string &s) { return '\"' + s + '\"'; }\nstring to_string(const char *s) { return to_string((string)s); }\nstring to_string(bool b) { return (b ? \"true\" : \"false\"); }\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" +\n         to_string(get<2>(p)) + \")\";\n}\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" +\n         to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\ntemplate <typename A, typename B, typename C, typename D, typename E>\nstring to_string(tuple<A, B, C, D, E> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" +\n         to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \",\" +\n         to_string(get<4>(p)) + \")\";\n}\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\ntemplate <typename T>\nstruct is_pair {\n  static const bool value = false;\n};\ntemplate <typename T, typename U>\nstruct is_pair<std::pair<T, U>> {\n  static const bool value = true;\n};\nconst int INF = 0x3f3f3f3f;\ntemplate <typename T>\ntypename enable_if<!is_integral<T>::value && !is_pair<T>::value, void>::type\nread(T &x) {\n  cin >> x;\n}\nlong long read() {\n  char c;\n  long long out = 0, f = 1;\n  for (c = getchar(); !isdigit(c) && c != '-'; c = getchar()) {\n  }\n  if (c == '-') {\n    f = -1;\n    c = getchar();\n  }\n  for (; isdigit(c); c = getchar()) out = (out << 3) + (out << 1) + c - '0';\n  return out * f;\n}\ntemplate <typename T>\ntypename enable_if<is_integral<T>::value, T>::type read(T &x) {\n  char c;\n  T f = 1;\n  x = 0;\n  for (c = getchar(); !isdigit(c) && c != '-'; c = getchar()) {\n  }\n  if (c == '-') {\n    f = -1;\n    c = getchar();\n  }\n  for (; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + c - '0';\n  return x *= f;\n}\nchar read(char &x) {\n  for (x = getchar(); isspace(x); x = getchar()) {\n  }\n  return x;\n}\ndouble read(double &x) {\n  scanf(\"%lf\", &x);\n  return x;\n}\ntemplate <typename T>\ntypename enable_if<!is_integral<T>::value && !is_pair<T>::value, void>::type\nwrite(const T &x) {\n  cout << x;\n}\ntemplate <typename T>\ntypename enable_if<is_integral<T>::value, void>::type write(const T &x) {\n  if (x < 0) {\n    putchar('-');\n    write(-x);\n    return;\n  }\n  if (x > 9) write(x / 10);\n  putchar(x % 10 + '0');\n}\nvoid write(char x) { putchar(x); }\nvoid write(double x) { printf(\"%.12lf\", x); }\nvoid write(long double x) { cout << fixed << setprecision(12) << x; }\ntemplate <typename T>\ntypename enable_if<is_pair<T>::value, void>::type read(T &x) {\n  read(x.first);\n  read(x.second);\n}\ntemplate <typename T>\ntypename enable_if<is_pair<T>::value, void>::type write(const T &x) {\n  write(x.first);\n  putchar(' ');\n  write(x.second);\n}\ntemplate <typename T, typename... Args>\nvoid read(T &x, Args &...args) {\n  read(x);\n  read(args...);\n}\ntemplate <\n    typename OutputIt,\n    typename = typename enable_if<\n        is_same<output_iterator_tag,\n                typename iterator_traits<OutputIt>::iterator_category>::value ||\n        (is_base_of<forward_iterator_tag, typename iterator_traits<OutputIt>::\n                                              iterator_category>::value &&\n         !is_const<OutputIt>::value)>::type>\nvoid read(OutputIt __first, OutputIt __last) {\n  for (; __first != __last; ++__first) read(*__first);\n}\ntemplate <\n    typename InputIt,\n    typename = typename enable_if<is_base_of<\n        input_iterator_tag,\n        typename iterator_traits<InputIt>::iterator_category>::value>::type>\nvoid wts(InputIt __first, InputIt __last) {\n  bool isFirst = true;\n  for (; __first != __last; ++__first) {\n    if (isFirst)\n      isFirst = false;\n    else\n      putchar(' ');\n    write(*__first);\n  }\n  putchar('\\n');\n}\ntemplate <\n    typename InputIt,\n    typename = typename enable_if<is_base_of<\n        input_iterator_tag,\n        typename iterator_traits<InputIt>::iterator_category>::value>::type>\nvoid wtb(InputIt __first, InputIt __last) {\n  for (; __first != __last; ++__first) {\n    write(*__first);\n    putchar('\\n');\n  }\n}\ntemplate <typename T>\nvoid wts(const T &x) {\n  write(x);\n  putchar(' ');\n}\ntemplate <typename T>\nvoid wtb(const T &x) {\n  write(x);\n  putchar('\\n');\n}\ntemplate <typename T>\nvoid wte(const T &x) {\n  write(x);\n  exit(0);\n}\ntemplate <typename T, typename... Args>\nvoid wts(const T &x, Args... args) {\n  wts(x);\n  wts(args...);\n}\ntemplate <typename T, typename... Args>\nvoid wtb(const T &x, Args... args) {\n  wts(x);\n  wtb(args...);\n}\ntemplate <typename T, typename... Args>\nvoid wte(const T &x, Args... args) {\n  wts(x);\n  wte(args...);\n}\ntemplate <typename T1, typename T2>\ninline bool up(T1 &x, const T2 &y) {\n  return x < y ? x = y, 1 : 0;\n}\ntemplate <typename T1, typename T2>\ninline bool dn(T1 &x, const T2 &y) {\n  return y < x ? x = y, 1 : 0;\n}\ntemplate <typename T1, typename T2, typename T3>\ninline bool inRange(const T1 &x, const T2 &l, const T3 &r) {\n  return !(x < l) && !(r < x);\n}\ntemplate <typename T1, typename T2>\ninline auto minOfDifferentTypes(const T1 &x, const T2 &y)\n    -> decltype(x < y ? x : y) {\n  return x < y ? x : y;\n}\ntemplate <typename T1, typename T2>\ninline auto maxOfDifferentTypes(const T1 &x, const T2 &y)\n    -> decltype(x < y ? y : x) {\n  return x < y ? y : x;\n}\ntemplate <typename T1, typename T2, typename T3>\ninline T1 &madd(T1 &x, const T2 &y, const T3 &modulo) {\n  return x = (long long)(x + y + modulo) % modulo;\n}\ntemplate <typename T1, typename T2, typename T3>\ninline T1 &mmul(T1 &x, const T2 &y, const T3 &modulo) {\n  return x = (long long)x * y % modulo;\n}\ninline int modadd(int x, int y, int modulo) {\n  return x + y >= modulo ? x + y - modulo : x + y;\n}\ninline int isinf(int x) { return x < INF ? x : -1; }\ninline void yesno(bool x) { wtb(x ? \"Yes\" : \"No\"); }\nusing namespace CPTH;\nstruct LCT {\n  struct Node {\n    int pa;\n    vector<int> ch;\n    bool rev;\n    Node() : pa(0), ch(2), rev(false) {}\n  };\n  vector<Node> t;\n  LCT(int n) : t(n + 1) {}\n  bool notRoot(int x) { return x == t[t[x].pa].ch[0] || x == t[t[x].pa].ch[1]; }\n  void rotate(int x) {\n    int y = t[x].pa;\n    int z = t[y].pa;\n    int k = x == t[y].ch[1];\n    if (notRoot(y)) t[z].ch[y == t[z].ch[1]] = x;\n    t[x].pa = z;\n    t[y].ch[k] = t[x].ch[k ^ 1];\n    t[t[x].ch[k ^ 1]].pa = y;\n    t[x].ch[k ^ 1] = y;\n    t[y].pa = x;\n  }\n  void reverse(int x) {\n    swap(t[x].ch[0], t[x].ch[1]);\n    t[x].rev ^= 1;\n  }\n  void pushdown(int x) {\n    if (t[x].rev) {\n      reverse(t[x].ch[0]);\n      reverse(t[x].ch[1]);\n      t[x].rev = false;\n    }\n  }\n  void splay(int x) {\n    static stack<int> stk;\n    stk.push(x);\n    for (int u = x; notRoot(u); u = t[u].pa) stk.push(t[u].pa);\n    while (!stk.empty()) {\n      pushdown(stk.top());\n      stk.pop();\n    }\n    while (notRoot(x)) {\n      int y = t[x].pa;\n      int z = t[y].pa;\n      if (notRoot(y)) rotate((x == t[y].ch[1]) ^ (y == t[z].ch[1]) ? x : y);\n      rotate(x);\n    }\n  }\n  void splay(int x, int goal) {\n    while (t[x].pa != goal) {\n      int y = t[x].pa;\n      int z = t[y].pa;\n      if (z != goal) rotate((x == t[y].ch[1]) ^ (y == t[z].ch[1]) ? x : y);\n      rotate(x);\n    }\n  }\n  void access(int x) {\n    for (int y = 0; x; x = t[y = x].pa) {\n      splay(x);\n      t[x].ch[1] = y;\n    }\n  }\n  void makeRoot(int x) {\n    access(x);\n    splay(x);\n    reverse(x);\n  }\n  int findRoot(int x) {\n    access(x);\n    splay(x);\n    while (t[x].ch[0]) {\n      pushdown(x);\n      x = t[x].ch[0];\n    }\n    splay(x);\n    return x;\n  }\n  bool link(int x, int y) {\n    makeRoot(x);\n    if (findRoot(y) == x) return false;\n    access(y);\n    splay(y);\n    t[x].pa = y;\n    return true;\n  }\n  void cut(int x, int y) {\n    makeRoot(x);\n    access(y);\n    t[x].ch[1] = t[y].pa = 0;\n  }\n};\nsigned main() {\n  int n, m;\n  read(n, m);\n  vector<vector<int>> a(n, vector<int>(m + 1));\n  for (auto &x : a) read(((x).begin() + 1), (x).end());\n  LCT lct(n * m);\n  int r = 0;\n  vector<vector<int>> g(n * m + 1);\n  vector<pair<int, int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n  for (int i = (0), iend = (n - 1); i <= iend; ++i) {\n    for (int j = (1), jend = (m); j <= jend; ++j) {\n      for (int k = (0), kend = (3); k <= kend; ++k) {\n        int ni = i + dir[k].first;\n        int nj = j + dir[k].second;\n        if (inRange(ni, 0, n - 1) && inRange(nj, 1, m))\n          g[a[i][j]].push_back(a[ni][nj]);\n      }\n    }\n  }\n  vector<int> mxr(n * m + 1);\n  for (int l = (1), lend = (n * m); l <= lend; ++l) {\n    bool flag = true;\n    while (flag && r < n * m) {\n      ++r;\n      for (int i = (0), iend = ((int)g[r].size() - 1); i <= iend; ++i) {\n        int v = g[r][i];\n        if (inRange(v, l, r - 1)) {\n          if (!lct.link(r, v)) {\n            for (int j = (0), jend = (i - 1); j <= jend; ++j) {\n              int w = g[r][j];\n              if (inRange(w, l, r - 1)) lct.cut(r, w);\n            }\n            --r;\n            flag = false;\n            break;\n          }\n        }\n      }\n    }\n    mxr[l] = r;\n    for (auto v : g[l]) {\n      if (inRange(v, l + 1, r)) {\n        lct.cut(l, v);\n      }\n    }\n  }\n  SegmentTree<pair<int, int>, int> seg(\n      vector<pair<int, int>>(n * m, pair<int, int>(0, 1)),\n      [](pair<int, int> x, pair<int, int> y) {\n        if (x.first == y.first)\n          return pair<int, int>(x.first, x.second + y.second);\n        return minOfDifferentTypes(x, y);\n      },\n      [](SegmentTreeNode<pair<int, int>, int> &u, int x) {\n        u.val.first += x;\n        u.mod += x;\n      },\n      1, pair<int, int>(INF, 0));\n  long long ans = 0;\n  for (int l = (n * m), lend = (1); l >= lend; --l) {\n    seg.modify(l, n * m + 1, 1);\n    for (auto v : g[l]) {\n      if (inRange(v, l + 1, mxr[l])) {\n        seg.modify(v, n * m + 1, -1);\n      }\n    }\n    pair<int, int> res = seg.query(l, mxr[l] + 1);\n    if (res.first == 1) ans += res.second;\n  }\n  wtb(ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n \npublic class Main {\n \n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        OutputWriter out = new OutputWriter(System.out);\n        TaskD solver = new TaskD(in, out);\n        solver.solve();\n        out.close();\n    }\n \n    static class TaskD {\n        static private final int[] dx = {1, -1, 0, 0};\n        static private final int[] dy = {0, 0, 1, -1};\n \n        static int n, m;\n        static int total;\n \n        static int[][] f;\n        static int[] posX;\n        static int[] posY;\n        static int[] leftBound;\n \n        List<Integer>[] edges;\n        LinkCutTree lct;\n        InputReader in;\n        OutputWriter out;\n \n        TaskD(InputReader in, OutputWriter out) {\n            this.in = in;\n            this.out = out;\n        }\n \n        private void solve() {\n            n = in.readInt();\n            m = in.readInt();\n            total = n * m;\n            f = new int[n][m];\n            posX = new int[total];\n            posY = new int[total];\n            for(int i = 0; i < n; ++i) {\n                for(int j = 0; j < m; ++j) {\n                    f[i][j] = in.readInt() - 1;\n                    posX[f[i][j]] = i;\n                    posY[f[i][j]] = j;\n                }\n            }\n            edges = new ArrayList[total];\n            leftBound = new int[total];\n            lct = new LinkCutTree(total);\n            for(int i = 0; i < total; ++i) {\n                edges[i] = new ArrayList<>();\n            }\n            for(int l = 0, r = 0; r < total; ++r) {\n               l = addCell(l, r);\n               leftBound[r] = l;\n            }\n            long ans = 0;\n            SegmentTree t = new SegmentTree(total + 4);\n            for(int r = 0; r < total; ++r) {\n                int x = posX[r];\n                int y = posY[r];\n                List<Integer> seg = new ArrayList<>();\n                for(int i = 0; i < 4; ++i) {\n                    int px = x + dx[i];\n                    int py = y + dy[i];\n                    if (px < 0 || px >= n) continue;\n                    if (py < 0 || py >= m) continue;\n                    int to = f[px][py];\n                    if (to > r) continue;\n                    seg.add(to);\n                }\n                seg.add(-1);\n                seg.add(r);\n                Collections.sort(seg);\n                for(int i = seg.size() - 1, comp = 1; i > 0; --i) {\n                    if (seg.get(i - 1) + 1 > seg.get(i)) {\n                        --comp;\n                        continue;\n                    }\n                    t.inc(seg.get(i - 1) + 1, seg.get(i) + 1, comp);\n                    --comp;\n                }\n                ans += t.query(leftBound[r], r + 1);\n            }\n            out.print(ans);\n        }\n \n        private int addCell(int l, int r) {\n            int x = posX[r];\n            int y = posY[r];\n            for(int i = 0; i < 4; ++i) {\n                int px = x + dx[i];\n                int py = y + dy[i];\n                if (px < 0 || px >= n) continue;\n                if (py < 0 || py >= m) continue;\n                int to = f[px][py];\n                while (l <= to && to <= r) {\n                    if (lct.link(to, r)) {\n                        edges[to].add(r);\n                        break;\n                    }\n                    removeCell(l);\n                    ++l;\n                }\n            }\n            return l;\n        }\n \n        private void removeCell(int c) {\n            for(int to : edges[c]) {\n                lct.cut(c, to);\n            }\n            edges[c].clear();\n        }\n    }\n \n    static class SegmentTree {\n        int size;\n        int height;\n        int[] t;\n        int[] cnt;\n        int[] push;\n \n        SegmentTree(int n) {\n            this.size = n;\n            this.height = 0;\n            int temp = n;\n            while (temp > 0) {\n                temp >>= 1;\n                ++this.height;\n            }\n            t = new int[n << 1];\n            cnt = new int[n << 1];\n            push = new int[n];\n            for(int i = 0; i < n; ++i) {\n                cnt[i + n] = 1;\n            }\n            for(int i = n - 1; i >= 0; --i) {\n                cnt[i] = cnt[i << 1] + cnt[i << 1 | 1];\n            }\n        }\n \n        private void apply(int p, int value) {\n            t[p] += value;\n            if (p < size) push[p] += value;\n        }\n \n        private void recalc(int p) {\n            while (p > 1) {\n                p >>= 1;\n                t[p] = Math.min(t[p << 1], t[p << 1 | 1]) + push[p];\n                cnt[p] = (t[p] == t[p << 1] + push[p] ? cnt[p << 1] : 0)\n                        + (t[p] == t[p << 1 | 1] + push[p] ? cnt[p << 1 | 1] : 0);\n            }\n        }\n \n        private void push(int p) {\n            for (int s = height; s > 0; s--) {\n                int i = p >> s;\n                if (push[i] != 0) {\n                    apply(i << 1, push[i]);\n                    apply(i << 1 | 1, push[i]);\n                    push[i] = 0;\n                }\n            }\n        }\n \n        private void inc(int l, int r, int value) {\n            l += size;\n            r += size;\n            int l0 = l;\n            int r0 = r;\n            for (; l < r; l >>= 1, r >>= 1) {\n                if ((l & 1) != 0) apply(l++, value);\n                if ((r & 1) != 0) apply(--r, value);\n            }\n            recalc(l0);\n            recalc(r0 - 1);\n        }\n \n        private int query(int l, int r) {\n            l += size;\n            r += size;\n            push(l);\n            push(r - 1);\n            int min = Integer.MAX_VALUE;\n            int minCount = 0;\n            for (; l < r; l >>= 1, r >>= 1) {\n                if ((l & 1) != 0) {\n                    if (min > t[l]) {\n                        min = t[l];\n                        minCount = cnt[l];\n                    } else if (min == t[l]) {\n                        minCount += cnt[l];\n                    }\n                    ++l;\n                }\n                if ((r & 1) != 0) {\n                    --r;\n                    if (min > t[r]) {\n                        min = t[r];\n                        minCount = cnt[r];\n                    } else if (min == t[r]) {\n                        minCount += cnt[r];\n                    }\n                }\n            }\n            return minCount;\n        }\n    }\n \n    static class LinkCutTree {\n \n        private static class Node {\n            Node left;\n            Node right;\n            Node parent;\n            boolean revert;\n \n            boolean isRoot() {\n                return parent == null || (parent.left != this && parent.right != this);\n            }\n \n            void push() {\n                if (revert) {\n                    revert = false;\n                    Node t = left;\n                    left = right;\n                    right = t;\n                    if (left != null)   left.revert = !left.revert;\n                    if (right != null)  right.revert = !right.revert;\n                }\n            }\n        }\n \n        static int size;\n        Node[] nodes;\n \n        LinkCutTree(int n) {\n            LinkCutTree.size = n;\n            nodes = new Node[n];\n            for(int i = 0; i < n; ++i) {\n                nodes[i] = new Node();\n            }\n        }\n \n        private boolean link(int x, int y) {\n            return link(nodes[x], nodes[y]);\n        }\n \n        private void cut(int x, int y) {\n            cut(nodes[x], nodes[y]);\n        }\n \n        private static boolean link(Node x, Node y) {\n            if (connected(x, y))\n                return false;\n            makeRoot(x);\n            x.parent = y;\n            return true;\n        }\n \n        private static void cut(Node x, Node y) {\n            makeRoot(x);\n            expose(y);\n            if (y.right != x || x.left != null || x.right != null) {\n                throw new RuntimeException(\"error: no edge (x,y)\");\n            }\n            y.right.parent = null;\n            y.right = null;\n        }\n \n        static void connect(Node ch, Node p, Boolean isLeftChild) {\n            if (ch != null)\n                ch.parent = p;\n            if (isLeftChild != null) {\n                if (isLeftChild)\n                    p.left = ch;\n                else\n                    p.right = ch;\n            }\n        }\n \n        static void rotate(Node x) {\n            Node p = x.parent;\n            Node g = p.parent;\n            boolean isRootP = p.isRoot();\n            boolean leftChildX = (x == p.left);\n            connect(leftChildX ? x.right : x.left, p, leftChildX);\n            connect(p, x, !leftChildX);\n            connect(x, g, !isRootP ? p == g.left : null);\n        }\n \n        static void splay(Node x) {\n            while (!x.isRoot()) {\n                Node p = x.parent;\n                Node g = p.parent;\n                if (!p.isRoot())\n                    g.push();\n                p.push();\n                x.push();\n                if (!p.isRoot())\n                    rotate((x == p.left) == (p == g.left) ? p/*zig-zig*/ : x/*zig-zag*/);\n                rotate(x);\n            }\n            x.push();\n        }\n \n        // makes node x the root of the virtual tree, and also x becomes the leftmost node in its splay tree\n        static Node expose(Node x) {\n            Node last = null;\n            for (Node y = x; y != null; y = y.parent) {\n                splay(y);\n                y.left = last;\n                last = y;\n            }\n            splay(x);\n            return last;\n        }\n \n        private static void makeRoot(Node x) {\n            expose(x);\n            x.revert = !x.revert;\n        }\n \n        private static boolean connected(Node x, Node y) {\n            if (x == y)\n                return true;\n            expose(x);\n            expose(y);\n            return x.parent != null;\n        }\n    }\n \n    static class OutputWriter {\n        private final PrintWriter writer;\n \n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n \n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n \n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n            writer.println();\n        }\n \n        public void close() {\n            writer.close();\n        }\n \n    }\n \n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n \n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n \n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n \n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n \n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n \n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n \n        public double readDouble() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E') {\n                    return res * Math.pow(10, readInt());\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E') {\n                        return res * Math.pow(10, readInt());\n                    }\n                    if (c < '0' || c > '9') {\n                        throw new InputMismatchException();\n                    }\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n \n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n \n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct StVal {\n  int minV = 0, numMin = 0;\n  StVal() {}\n  StVal(const int _v) : minV(_v), numMin(1) {}\n  StVal(const StVal& v1, const StVal& v2) {\n    if (v1.minV < v2.minV) {\n      minV = v1.minV;\n      numMin = v1.numMin;\n    } else if (v1.minV > v2.minV) {\n      minV = v2.minV;\n      numMin = v2.numMin;\n    } else {\n      minV = v1.minV;\n      numMin = v1.numMin + v2.numMin;\n    }\n  }\n};\nstruct StUpdate {\n  int v = 0;\n  StUpdate() {}\n  StUpdate(const int v) : v(v) {}\n  StUpdate(const StUpdate& u1, const StUpdate& u2) { v = u1.v + u2.v; }\n  void apply(StVal& sv, const int lo, const int hi) { sv.minV += v; }\n};\nstruct SegTree {\n  int n;\n  vector<StVal> st;\n  vector<StUpdate> lazy;\n  vector<int> leaves;\n  SegTree(const int n) : n(n) {\n    leaves.resize(n);\n    init(1, 0, n - 1);\n    lazy.resize(st.size());\n  }\n  void init(const int si, const int lo, const int hi) {\n    if (lo == hi) {\n      if (si >= (int)st.size()) {\n        st.resize(si + 1);\n      }\n      st[si] = StVal(0);\n      leaves[lo] = si;\n      return;\n    }\n    int lC = si << 1, rC = (si << 1) | 1, mid = (lo + hi) >> 1;\n    init(lC, lo, mid);\n    init(rC, mid + 1, hi);\n    st[si] = StVal(st[lC], st[rC]);\n  }\n  void updateLazy(const int si, const int lo, const int hi) {\n    lazy[si].apply(st[si], lo, hi);\n    if (lo != hi) {\n      lazy[si << 1] = StUpdate(lazy[si << 1], lazy[si]);\n      lazy[si << 1 | 1] = StUpdate(lazy[si << 1 | 1], lazy[si]);\n    }\n    lazy[si] = StUpdate();\n  }\n  StVal query(const int l, const int r) {\n    return (l <= r && l < n && r >= 0) ? query(l, r, 1, 0, n - 1) : StVal();\n  }\n  StVal query(const int l, const int r, const int si, const int lo,\n              const int hi) {\n    updateLazy(si, lo, hi);\n    if (l <= lo && hi <= r) return st[si];\n    const int mid = (lo + hi) >> 1;\n    if (r <= mid) return query(l, r, si << 1, lo, mid);\n    if (mid < l) return query(l, r, si << 1 | 1, mid + 1, hi);\n    return StVal(query(l, r, si << 1, lo, mid),\n                 query(l, r, si << 1 | 1, mid + 1, hi));\n  }\n  void update(const int l, const int r, const StUpdate u) {\n    if (l <= r) update(l, r, u, 1, 0, n - 1);\n  }\n  void update(const int l, const int r, const StUpdate& u, const int si,\n              const int lo, const int hi) {\n    if (l <= lo && hi <= r) {\n      lazy[si] = StUpdate(lazy[si], u);\n      updateLazy(si, lo, hi);\n    } else {\n      updateLazy(si, lo, hi);\n      if (hi < l || r < lo) return;\n      const int mid = (lo + hi) >> 1;\n      update(l, r, u, si << 1, lo, mid);\n      update(l, r, u, si << 1 | 1, mid + 1, hi);\n      st[si] = StVal(st[si << 1], st[si << 1 | 1]);\n    }\n  }\n  void updateAllLazy() { updateAllLazy(1, 0, n - 1); }\n  void updateAllLazy(const int si, const int lo, const int hi) {\n    updateLazy(si, lo, hi);\n    if (lo != hi) {\n      const int mid = (lo + hi) >> 1;\n      updateAllLazy(si << 1, lo, mid);\n      updateAllLazy(si << 1 | 1, mid + 1, hi);\n    }\n  }\n};\nstruct Node {\n  array<Node*, 2> child{};\n  Node* splayTreeParent = nullptr;\n  Node* pathParentPointer = nullptr;\n  bool reverse = false;\n  Node() {}\n  bool getSide() {\n    return splayTreeParent ? splayTreeParent->child[1] == this : false;\n  }\n  void tryReverse() {\n    if (!reverse) {\n      return;\n    }\n    reverse = false;\n    swap(child[0], child[1]);\n    if (child[0]) {\n      child[0]->reverse = !child[0]->reverse;\n    }\n    if (child[1]) {\n      child[1]->reverse = !child[1]->reverse;\n    }\n  }\n  Node* splay() {\n    vector<Node*> ancestors;\n    Node* cur = this;\n    while (cur) {\n      ancestors.push_back(cur);\n      cur = cur->splayTreeParent;\n    }\n    for (int i = ancestors.size() - 1; i >= 0; i--) {\n      if (!ancestors[i]) {\n        continue;\n      }\n      ancestors[i]->tryReverse();\n    }\n    while (splayTreeParent) {\n      if (splayTreeParent->splayTreeParent) {\n        (getSide() == splayTreeParent->getSide() ? splayTreeParent : this)\n            ->rotate();\n      }\n      rotate();\n    }\n    return this;\n  }\n  Node* rotate() {\n    bool side = getSide(), parentSide = splayTreeParent->getSide();\n    auto ancestor = splayTreeParent->splayTreeParent;\n    pathParentPointer = splayTreeParent->pathParentPointer;\n    splayTreeParent->pathParentPointer = nullptr;\n    splayTreeParent->attach(child[!side], side);\n    attach(splayTreeParent, !side);\n    if (ancestor)\n      ancestor->attach(this, parentSide);\n    else\n      splayTreeParent = nullptr;\n    return this;\n  }\n  Node* attach(Node* node, int side) {\n    if (node) node->splayTreeParent = this;\n    child[side] = node;\n    return this;\n  }\n};\nstruct LinkCutTreeGeneral {\n  void link(Node* parent, Node* child) {\n    assert(findRoot(child) != findRoot(parent));\n    access(child);\n    access(parent);\n    Node* lChild = child->child[0];\n    if (lChild) {\n      lChild->reverse = !lChild->reverse;\n      detachChild(child, 0);\n    }\n    child->attach(parent, 0);\n  }\n  void cut(Node* u) {\n    access(u);\n    assert(u->child[0]);\n    u->child[0]->splayTreeParent = nullptr;\n    u->child[0] = nullptr;\n  }\n  void cut(Node* u, Node* v) {\n    access(u);\n    if (u->child[0] && findMax(u->child[0]) == v) {\n      cut(u);\n      return;\n    }\n    access(v);\n    if (v->child[0] && findMax(v->child[0]) == u) {\n      cut(v);\n    }\n  }\n  Node* findRoot(Node* u) {\n    access(u);\n    while (u->child[0]) {\n      u = u->child[0];\n    }\n    access(u);\n    return u;\n  }\n\n private:\n  Node* access(Node* u) {\n    u->splay();\n    detachChild(u, 1);\n    Node* curPP = u;\n    while (u->pathParentPointer) {\n      curPP = u->pathParentPointer;\n      curPP->splay();\n      detachChild(curPP, 1);\n      curPP->attach(u, 1);\n      u->pathParentPointer = nullptr;\n      u->splay();\n    }\n    return curPP;\n  }\n  Node* findMax(Node* u) {\n    if (!u) {\n      return nullptr;\n    }\n    while (u->child[1]) {\n      u = u->child[1];\n    }\n    u->splay();\n    return u;\n  }\n  void detachChild(Node* u, bool b) {\n    if (!u->child[b]) {\n      return;\n    }\n    u->child[b]->pathParentPointer = u;\n    u->child[b]->splayTreeParent = nullptr;\n    u->child[b] = nullptr;\n  }\n};\nstruct NodeWithId : Node {\n  int id;\n  NodeWithId(int id) : Node(), id(id) {}\n};\nstruct DynamicTreeLCT {\n  LinkCutTreeGeneral lct;\n  vector<NodeWithId*> nodes;\n  int n = 0;\n  DynamicTreeLCT() {}\n  int addNode() {\n    nodes.push_back(new NodeWithId(n));\n    return n++;\n  }\n  void link(int parentId, int childId) {\n    lct.link(nodes[parentId], nodes[childId]);\n  }\n  void cut(int id) { lct.cut(nodes[id]); }\n  void cut(int u, int v) { lct.cut(nodes[u], nodes[v]); }\n  int findRoot(int u) {\n    auto res = (NodeWithId*)lct.findRoot(nodes[u]);\n    return res->id;\n  }\n  bool connected(int u, int v) { return findRoot(u) == findRoot(v); }\n};\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nvector<int> numToID;\nint n, m;\nvoid cutNeighbors(DynamicTreeLCT& lct, vector<vector<int>>& grid, int l,\n                  int r) {\n  int i = numToID[l] / m, j = numToID[l] % m;\n  int idx = numToID[l];\n  for (int k = 0; k < 4; k++) {\n    int ni = i + dx[k], nj = j + dy[k];\n    if (ni < 0 || nj < 0 || ni == n || nj == m) {\n      continue;\n    }\n    if (grid[ni][nj] < l || grid[ni][nj] > r) {\n      continue;\n    }\n    int nIdx = numToID[grid[ni][nj]];\n    if (lct.connected(idx, nIdx)) {\n      lct.cut(idx, nIdx);\n    }\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0), cout.tie(0);\n  DynamicTreeLCT lct;\n  cin >> n >> m;\n  vector<vector<int>> grid(n, vector<int>(m));\n  numToID.resize(n * m + 1);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      cin >> grid[i][j];\n      numToID[grid[i][j]] = lct.addNode();\n    }\n  }\n  SegTree st(n * m + 1);\n  long long ans = 0;\n  int l = 1;\n  for (int r = 1; r <= m * n; r++) {\n    st.update(l, r, StUpdate(1));\n    int i = numToID[r] / m, j = numToID[r] % m;\n    int idx = numToID[r];\n    for (int k = 0; k < 4; k++) {\n      int ni = i + dx[k], nj = j + dy[k];\n      if (ni < 0 || nj < 0 || ni == n || nj == m) {\n        continue;\n      }\n      if (grid[ni][nj] < l || grid[ni][nj] > r) {\n        continue;\n      }\n      int nIdx = numToID[grid[ni][nj]];\n      while (lct.connected(idx, nIdx)) {\n        cutNeighbors(lct, grid, l, r);\n        l++;\n      }\n      if (l > grid[ni][nj]) {\n        continue;\n      }\n      if (l == r) {\n        break;\n      }\n      lct.link(idx, nIdx);\n      st.update(l, grid[ni][nj], StUpdate(-1));\n    }\n    ans += st.query(l, r).numMin;\n  }\n  cout << ans << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200100;\nconst int oo = 2e9;\nint a[N];\nmt19937 rnd(chrono::system_clock().now().time_since_epoch().count());\nstruct node {\n  node *l, *r, *pr;\n  int vl, cnt, prior;\n  node(int vl) : l(0), r(0), pr(0), vl(vl), cnt(1), prior(rnd()) {}\n};\ntypedef node *pnode;\npnode A, B, A1, B1, A2, B2, BAD, pt[N];\nmap<int, pnode> mem[N];\nvector<pnode> vc;\nint cnt(pnode t) { return (t ? t->cnt : 0); }\nvoid upd_cnt(pnode t) {\n  if (!t) return;\n  t->cnt = cnt(t->l) + cnt(t->r) + 1;\n  t->pr = 0;\n  if (t->l) t->l->pr = t;\n  if (t->r) t->r->pr = t;\n}\nvoid merge(pnode &t, pnode l, pnode r) {\n  if (!l || !r) {\n    t = (l ? l : r);\n    return;\n  }\n  if (l->prior < r->prior) {\n    merge(l->r, l->r, r);\n    t = l;\n    upd_cnt(t);\n  } else {\n    merge(r->l, l, r->l);\n    t = r;\n    upd_cnt(t);\n  }\n}\nvoid split(pnode t, pnode &l, pnode &r, int key) {\n  if (!t) {\n    l = r = 0;\n    return;\n  }\n  int cur_key = cnt(t->l) + 1;\n  if (cur_key <= key) {\n    split(t->r, t->r, r, key - cnt(t->l) - 1);\n    if (r) r->pr = 0;\n    if (r && r->l) r->l->pr = r;\n    if (r && r->r) r->r->pr = r;\n    l = t;\n    upd_cnt(l);\n  } else {\n    split(t->l, l, t->l, key);\n    if (l) l->pr = 0;\n    if (l && l->l) l->l->pr = l;\n    if (l && l->r) l->r->pr = l;\n    r = t;\n    upd_cnt(r);\n  }\n}\ninline pair<int, int> combine(pair<int, int> l, pair<int, int> r) {\n  pair<int, int> res;\n  if (l.first == r.first) {\n    res.first = l.first;\n    res.second = l.second + r.second;\n  } else if (l.first > r.first)\n    res = r;\n  else\n    res = l;\n  return res;\n}\nint get_ind(pnode v) {\n  int res = cnt(v->l) + 1;\n  while (v->pr) {\n    if (v->pr->r == v) res += cnt(v->pr->l) + 1;\n    v = v->pr;\n  }\n  return res;\n}\npnode get_root(pnode v) {\n  while (v->pr) v = v->pr;\n  return v;\n}\nbool Is_connected(int x, int y) { return get_root(pt[x]) == get_root(pt[y]); }\npnode LEFT(pnode v) { return (v->l ? LEFT(v->l) : v); }\npnode RIGHT(pnode v) { return (v->r ? RIGHT(v->r) : v); }\nvoid link(int x, int y) {\n  int kx = get_ind(pt[x]);\n  int ky = get_ind(pt[y]);\n  A = get_root(pt[x]);\n  B = get_root(pt[y]);\n  split(A, A1, A2, kx);\n  split(B, B1, B2, ky);\n  pnode lef = LEFT(B1);\n  if (pt[lef->vl] == lef)\n    split(B2, B2, BAD, cnt(B2) - 1);\n  else\n    split(B1, BAD, B1, 1);\n  pnode cx = new node(x);\n  pnode cy = new node(y);\n  if (cnt(A2)) mem[x][LEFT(A2)->vl] = cx;\n  merge(A2, cx, A2);\n  if (cnt(B2) && LEFT(B2)->vl != y) mem[y][LEFT(B2)->vl] = cy;\n  if (!(!cnt(B2) && LEFT(B1)->vl == y)) merge(B2, cy, B2);\n  pnode rgt = RIGHT(A1);\n  if (cnt(B2)) mem[rgt->vl][LEFT(B2)->vl] = rgt;\n  merge(A, A1, B2);\n  if (cnt(A)) {\n    rgt = RIGHT(A);\n    if (cnt(B1)) mem[rgt->vl][LEFT(B1)->vl] = rgt;\n  }\n  merge(A, A, B1);\n  rgt = RIGHT(A);\n  if (cnt(A2)) mem[rgt->vl][LEFT(A2)->vl] = rgt;\n  merge(A, A, A2);\n}\nvoid cut(int x, int y) {\n  pnode n1 = mem[x][y];\n  pnode n2 = mem[y][x];\n  mem[x].erase(y);\n  mem[y].erase(x);\n  int ind1 = get_ind(n1);\n  int ind2 = get_ind(n2);\n  if (ind1 > ind2) {\n    swap(ind1, ind2);\n    swap(x, y);\n    swap(n1, n2);\n  }\n  A = get_root(n1);\n  split(A, A, A2, ind2);\n  split(A, A1, B, ind1);\n  if (LEFT(A2) == pt[x])\n    split(A1, A1, BAD, cnt(A1) - 1);\n  else\n    split(A2, BAD, A2, 1);\n  if (cnt(A1) && cnt(A2)) {\n    pnode rgt = RIGHT(A1);\n    mem[rgt->vl][LEFT(A2)->vl] = rgt;\n  }\n  merge(A, A1, A2);\n}\npair<int, int> st[4 * N];\nint psh[4 * N], n, m, obr[N];\nvoid build(int v, int l, int r) {\n  if (l == r) {\n    psh[v] = 0;\n    st[v] = {0, 1};\n    return;\n  }\n  int md = (l + r) >> 1;\n  build(v + v, l, md);\n  build(v + v + 1, md + 1, r);\n  st[v] = combine(st[v + v], st[v + v + 1]);\n}\nvoid push(int v) {\n  if (psh[v] != 0) {\n    st[v].first += psh[v];\n    if (v + v + 1 < 4 * N) {\n      psh[v + v] += psh[v];\n      psh[v + v + 1] += psh[v];\n    }\n    psh[v] = 0;\n  }\n}\nvoid update(int v, int tl, int tr, int l, int r, int vl) {\n  push(v);\n  if (l > r) return;\n  if (tl == l && tr == r) {\n    psh[v] += vl;\n    push(v);\n    return;\n  }\n  int md = (tl + tr) >> 1;\n  update(v + v, tl, md, l, min(r, md), vl);\n  update(v + v + 1, md + 1, tr, max(l, md + 1), r, vl);\n  st[v] = combine(st[v + v], st[v + v + 1]);\n}\npair<int, int> min(int v, int tl, int tr, int l, int r) {\n  push(v);\n  if (l > r) return {oo, 0};\n  if (tl == l && tr == r) return st[v];\n  int md = (tl + tr) >> 1;\n  pair<int, int> n1 = min(v + v, tl, md, l, min(r, md));\n  pair<int, int> n2 = min(v + v + 1, md + 1, tr, max(md + 1, l), r);\n  return combine(n1, n2);\n}\nbool good(int l, int r) {\n  int x = obr[r] / m, y = obr[r] % m;\n  int cx, cy;\n  vc.clear();\n  if (x < n - 1) {\n    cx = x + 1;\n    cy = y;\n    int nw = a[cx * m + cy];\n    if (nw >= l && nw < r) vc.push_back(get_root(pt[nw]));\n  }\n  if (x > 0) {\n    cx = x - 1;\n    cy = y;\n    int nw = a[cx * m + cy];\n    if (nw >= l && nw < r) vc.push_back(get_root(pt[nw]));\n  }\n  if (y < m - 1) {\n    cx = x;\n    cy = y + 1;\n    int nw = a[cx * m + cy];\n    if (nw >= l && nw < r) vc.push_back(get_root(pt[nw]));\n  }\n  if (y > 0) {\n    cx = x;\n    cy = y - 1;\n    int nw = a[cx * m + cy];\n    if (nw >= l && nw < r) vc.push_back(get_root(pt[nw]));\n  }\n  for (int i = 0; i < int(vc.size()); i++)\n    for (int j = i + 1; j < int(vc.size()); j++)\n      if (vc[i] == vc[j]) return 0;\n  return 1;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> m;\n  for (int i = 0; i < n * m; i++) {\n    cin >> a[i];\n    a[i]--;\n    obr[a[i]] = i;\n  }\n  long long ans = 0ll;\n  build(1, 0, n * m - 1);\n  for (int i = 0; i < n * m; i++) pt[i] = new node(i);\n  for (int r = 0, l = 0; r < n * m; r++) {\n    while (!good(l, r)) {\n      int x = obr[l] / m, y = obr[l] % m;\n      int cx, cy;\n      if (x < n - 1) {\n        cx = x + 1;\n        cy = y;\n        int nw = a[cx * m + cy];\n        if (nw >= l && nw < r) cut(nw, l);\n      }\n      if (x > 0) {\n        cx = x - 1;\n        cy = y;\n        int nw = a[cx * m + cy];\n        if (nw >= l && nw < r) cut(nw, l);\n      }\n      if (y < m - 1) {\n        cx = x;\n        cy = y + 1;\n        int nw = a[cx * m + cy];\n        if (nw >= l && nw < r) cut(nw, l);\n      }\n      if (y > 0) {\n        cx = x;\n        cy = y - 1;\n        int nw = a[cx * m + cy];\n        if (nw >= l && nw < r) cut(nw, l);\n      }\n      l++;\n    }\n    update(1, 0, n * m - 1, 0, r, 1);\n    int x = obr[r] / m, y = obr[r] % m;\n    int cx, cy;\n    if (x < n - 1) {\n      cx = x + 1;\n      cy = y;\n      int nw = a[cx * m + cy];\n      if (nw >= l && nw < r) {\n        link(nw, r);\n        update(1, 0, n * m - 1, 0, nw, -1);\n      }\n    }\n    if (x > 0) {\n      cx = x - 1;\n      cy = y;\n      int nw = a[cx * m + cy];\n      if (nw >= l && nw < r) {\n        link(nw, r);\n        update(1, 0, n * m - 1, 0, nw, -1);\n      }\n    }\n    if (y < m - 1) {\n      cx = x;\n      cy = y + 1;\n      int nw = a[cx * m + cy];\n      if (nw >= l && nw < r) {\n        link(nw, r);\n        update(1, 0, n * m - 1, 0, nw, -1);\n      }\n    }\n    if (y > 0) {\n      cx = x;\n      cy = y - 1;\n      int nw = a[cx * m + cy];\n      if (nw >= l && nw < r) {\n        link(nw, r);\n        update(1, 0, n * m - 1, 0, nw, -1);\n      }\n    }\n    ans += min(1, 0, n * m - 1, l, r).second;\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 300000;\nconst int D[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1};\nint n, m, p, fa[N], c[N][2], stk[N], rev[N], T[N << 2], a[1200][1200];\nlong long ans;\nbool b[1200][1200];\nstruct cdt {\n  int x, y;\n  cdt(int x = 0, int y = 0) : x(x), y(y) {}\n} pos[N];\nstruct seg {\n  int x, y;\n  seg(int x = 0, int y = 0) : x(x), y(y) {}\n  seg operator^(const seg &p) const {\n    return x == p.x ? seg(x, y + p.y) : x < p.x ? (*this) : p;\n  }\n} s[N << 2];\nbool isrt(int x) { return x != c[fa[x]][0] && x != c[fa[x]][1]; }\nbool dic(int x) { return x == c[fa[x]][1]; }\nvoid rtt(int x) {\n  int y = fa[x], dx = dic(x), dy = dic(y);\n  c[y][dx] = c[x][dx ^ 1];\n  fa[c[x][dx ^ 1]] = y;\n  fa[x] = fa[y];\n  if (!isrt(y)) c[fa[y]][dy] = x;\n  c[x][dx ^ 1] = y;\n  fa[y] = x;\n}\nvoid psd(int x) {\n  if (rev[x]) {\n    rev[c[x][0]] ^= 1;\n    rev[c[x][1]] ^= 1;\n    swap(c[x][0], c[x][1]);\n    rev[x] = 0;\n  }\n}\nvoid splay(int x) {\n  int tp;\n  stk[tp = 1] = x;\n  for (int t = x; !isrt(t); t = fa[t]) stk[++tp] = fa[t];\n  for (; tp; --tp) psd(stk[tp]);\n  for (int y; !isrt(x); rtt(x))\n    if (!isrt(y = fa[x])) rtt(dic(x) ^ dic(y) ? x : y);\n}\nvoid acs(int x) {\n  for (int t = 0; x; t = x, x = fa[x]) {\n    splay(x);\n    c[x][1] = t;\n  }\n}\nint fdrt(int x) {\n  acs(x);\n  splay(x);\n  for (psd(x); c[x][0]; x = c[x][0], psd(x))\n    ;\n  splay(x);\n  return x;\n}\nvoid mrt(int x) {\n  acs(x);\n  splay(x);\n  rev[x] ^= 1;\n}\nvoid link(int x, int y) {\n  mrt(x);\n  fa[x] = y;\n}\nvoid cut(int x, int y) {\n  mrt(x);\n  acs(y);\n  splay(y);\n  c[y][0] = fa[x] = 0;\n}\nvoid build(int x, int l, int r) {\n  if (l == r) {\n    s[x] = seg(l, 1);\n    return;\n  }\n  int mid = (l + r) >> 1;\n  build((x << 1), l, mid);\n  build((x << 1 | 1), mid + 1, r);\n  s[x] = s[(x << 1)] ^ s[(x << 1 | 1)];\n}\nvoid pushdown(int x) {\n  s[(x << 1)].x += T[x];\n  s[(x << 1 | 1)].x += T[x];\n  T[(x << 1)] += T[x];\n  T[(x << 1 | 1)] += T[x];\n  T[x] = 0;\n}\nvoid add(int x, int l, int r, int L, int k) {\n  if (l >= L) {\n    s[x].x += k;\n    T[x] += k;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  pushdown(x);\n  if (L <= mid) add((x << 1), l, mid, L, k);\n  add((x << 1 | 1), mid + 1, r, L, k);\n  s[x] = s[(x << 1)] ^ s[(x << 1 | 1)];\n}\nseg qry(int x, int l, int r, int L, int R) {\n  if (l >= L && r <= R) return s[x];\n  int mid = (l + r) >> 1;\n  seg ret = seg(0x3f3f3f3f, 0);\n  pushdown(x);\n  if (L <= mid) ret = ret ^ qry((x << 1), l, mid, L, R);\n  if (R > mid) ret = ret ^ qry((x << 1 | 1), mid + 1, r, L, R);\n  return ret;\n}\nvoid LINK(cdt P) {\n  int x = P.x, y = P.y;\n  b[x][y] = 1;\n  for (int i = 0; i < 4; ++i) {\n    int nx = x + D[i][0], ny = y + D[i][1];\n    if (b[nx][ny]) {\n      add(1, 1, p, a[x][y], -1);\n      link((((x)-1) * m + (y)), (((nx)-1) * m + (ny)));\n    }\n  }\n}\nvoid CUT(cdt P) {\n  int x = P.x, y = P.y;\n  b[x][y] = 0;\n  for (int i = 0; i < 4; ++i) {\n    int nx = x + D[i][0], ny = y + D[i][1];\n    if (b[nx][ny]) {\n      add(1, 1, p, a[nx][ny], 1);\n      cut((((x)-1) * m + (y)), (((nx)-1) * m + (ny)));\n    }\n  }\n}\nbool ok(cdt P) {\n  int fl[4] = {};\n  int x = P.x, y = P.y;\n  for (int i = 0; i < 4; ++i) {\n    int nx = x + D[i][0], ny = y + D[i][1];\n    if (b[nx][ny]) fl[i] = fdrt((((nx)-1) * m + (ny)));\n  }\n  for (int i = 0; i < 4; ++i)\n    if (fl[i])\n      for (int j = 0; j < i; ++j)\n        if (fl[j])\n          if (fl[i] == fl[j]) return 0;\n  return 1;\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  p = n * m;\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j) {\n      scanf(\"%d\", a[i] + j);\n      pos[a[i][j]] = cdt(i, j);\n    }\n  build(1, 1, p);\n  for (int l = 1, r = 1; l <= p; ++l) {\n    for (; r <= p && ok(pos[r]); ++r) LINK(pos[r]);\n    seg t = qry(1, 1, p, l, r - 1);\n    if (t.x == l) ans += t.y;\n    CUT(pos[l]);\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar getc() {\n  char c = getchar();\n  while ((c < 'A' || c > 'Z') && (c < 'a' || c > 'z') && (c < '0' || c > '9'))\n    c = getchar();\n  return c;\n}\nint gcd(int n, int m) { return m == 0 ? n : gcd(m, n % m); }\nint read() {\n  int x = 0, f = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9')\n    x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();\n  return x * f;\n}\nint n, m, a[1010][1010], near[200010][4];\nlong long ans;\nstruct data {\n  int ch[2], fa, rev;\n} tree[200010];\nvoid rev(int k) {\n  if (k) swap(tree[k].ch[0], tree[k].ch[1]), tree[k].rev ^= 1;\n}\nvoid down(int k) {\n  if (tree[k].rev) rev(tree[k].ch[0]), rev(tree[k].ch[1]), tree[k].rev = 0;\n}\nint whichson(int k) { return tree[tree[k].fa].ch[1] == k; }\nbool isroot(int k) {\n  return tree[tree[k].fa].ch[0] != k && tree[tree[k].fa].ch[1] != k;\n}\nvoid push(int k) {\n  if (!isroot(k)) push(tree[k].fa);\n  down(k);\n}\nvoid move(int k) {\n  int fa = tree[k].fa, gf = tree[fa].fa, p = whichson(k);\n  if (!isroot(fa)) tree[gf].ch[whichson(fa)] = k;\n  tree[k].fa = gf;\n  tree[fa].ch[p] = tree[k].ch[!p], tree[tree[k].ch[!p]].fa = fa;\n  tree[k].ch[!p] = fa, tree[fa].fa = k;\n}\nvoid splay(int k) {\n  push(k);\n  while (!isroot(k)) {\n    int fa = tree[k].fa;\n    if (!isroot(fa))\n      if (whichson(fa) ^ whichson(k))\n        move(k);\n      else\n        move(fa);\n    move(k);\n  }\n}\nvoid access(int k) {\n  for (int t = 0; k; t = k, k = tree[k].fa) splay(k), tree[k].ch[1] = t;\n}\nint findroot(int k) {\n  if (!k) return 0;\n  access(k);\n  splay(k);\n  for (; tree[k].ch[0]; k = tree[k].ch[0]) down(k);\n  splay(k);\n  return k;\n}\nvoid makeroot(int k) { access(k), splay(k), rev(k); }\nvoid link(int x, int y) {\n  makeroot(x);\n  tree[x].fa = y;\n}\nvoid cut(int x, int y) {\n  makeroot(x), access(y), splay(y);\n  tree[y].ch[0] = tree[x].fa = 0;\n}\nint L[200010 << 2], R[200010 << 2], sum[200010 << 2], top[200010 << 2],\n    lazy[200010 << 2];\nvoid up(int k) {\n  if (top[k << 1] == top[k << 1 | 1]) {\n    top[k] = top[k << 1];\n    sum[k] = sum[k << 1] + sum[k << 1 | 1];\n  } else if (top[k << 1] < top[k << 1 | 1])\n    top[k] = top[k << 1], sum[k] = sum[k << 1];\n  else\n    top[k] = top[k << 1 | 1], sum[k] = sum[k << 1 | 1];\n}\nvoid build(int k, int l, int r) {\n  L[k] = l, R[k] = r;\n  if (l == r) {\n    sum[k] = 1;\n    return;\n  }\n  int mid = l + r >> 1;\n  build(k << 1, l, mid);\n  build(k << 1 | 1, mid + 1, r);\n  up(k);\n}\nvoid Down(int k) {\n  top[k << 1] += lazy[k], top[k << 1 | 1] += lazy[k];\n  lazy[k << 1] += lazy[k], lazy[k << 1 | 1] += lazy[k];\n  lazy[k] = 0;\n}\nvoid add(int k, int l, int r, int op) {\n  if (L[k] == l && R[k] == r) {\n    lazy[k] += op;\n    top[k] += op;\n    return;\n  }\n  if (lazy[k]) Down(k);\n  int mid = L[k] + R[k] >> 1;\n  if (r <= mid)\n    add(k << 1, l, r, op);\n  else if (l > mid)\n    add(k << 1 | 1, l, r, op);\n  else\n    add(k << 1, l, mid, op), add(k << 1 | 1, mid + 1, r, op);\n  up(k);\n}\nint query(int k, int l, int r) {\n  if (L[k] == l && R[k] == r) return (top[k] == 1) * sum[k];\n  if (lazy[k]) Down(k);\n  int mid = L[k] + R[k] >> 1;\n  if (r <= mid)\n    return query(k << 1, l, r);\n  else if (l > mid)\n    return query(k << 1 | 1, l, r);\n  else\n    return query(k << 1, l, mid) + query(k << 1 | 1, mid + 1, r);\n}\nvoid print(int k, int l, int r) {\n  if (L[k] == R[k]) {\n    cout << top[k] << ' ';\n    return;\n  }\n  if (lazy[k]) Down(k);\n  int mid = L[k] + R[k] >> 1;\n  if (r <= mid)\n    print(k << 1, l, r);\n  else if (l > mid)\n    print(k << 1 | 1, l, r);\n  else\n    print(k << 1, l, mid), print(k << 1 | 1, mid + 1, r);\n}\nsigned main() {\n  n = read(), m = read();\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) a[i][j] = read();\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) {\n      near[a[i][j]][0] = a[i - 1][j];\n      near[a[i][j]][1] = a[i + 1][j];\n      near[a[i][j]][2] = a[i][j - 1];\n      near[a[i][j]][3] = a[i][j + 1];\n    }\n  build(1, 1, n * m);\n  int l = 1;\n  for (int i = 1; i <= n * m; i++) {\n    bool flag;\n    do {\n      flag = 0;\n      int u[5], t = 0;\n      u[t++] = findroot(i);\n      for (int j = 0; j < 4; j++)\n        if (near[i][j]) u[t++] = findroot(near[i][j]);\n      for (int x = 0; x < t; x++)\n        for (int y = x + 1; y < t; y++)\n          if (u[x] == u[y]) {\n            flag = 1;\n            break;\n          }\n      if (!flag) break;\n      for (int j = 0; j < 4; j++)\n        if (near[l][j] >= l && near[l][j] < i) cut(l, near[l][j]);\n      l++;\n    } while (1);\n    add(1, l, i, 1);\n    for (int j = 0; j < 4; j++)\n      if (near[i][j] >= l && near[i][j] <= i)\n        link(i, near[i][j]), add(1, l, near[i][j], -1);\n    ans += query(1, l, i);\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint num[200010], nxt[200010 << 2], to[200010 << 2], head[200010], cnt;\nvoid add(int u, int v) {\n  nxt[++cnt] = head[u];\n  to[cnt] = v;\n  head[u] = cnt;\n}\nint id[2010][2010];\nconst int ux[5] = {0, 1, 0, -1}, uy[5] = {1, 0, -1, 0};\nstruct LCT {\n  int ch[200010][2], fa[200010], tag[200010], cnt;\n  bool not_root(int u) { return ch[fa[u]][0] == u || ch[fa[u]][1] == u; }\n  void set_tag(int u) {\n    swap(ch[u][0], ch[u][1]);\n    tag[u] ^= 1;\n  }\n  void push_down(int u) {\n    if (!tag[u]) return;\n    tag[u] = false;\n    set_tag(ch[u][0]);\n    set_tag(ch[u][1]);\n  }\n  void rotate(int u) {\n    int f = fa[u], ff = fa[f];\n    int k = ch[f][1] == u, v = ch[u][!k];\n    if (not_root(f)) ch[ff][ch[ff][1] == f] = u;\n    ch[u][!k] = f;\n    ch[f][k] = v;\n    if (v) fa[v] = f;\n    fa[f] = u;\n    fa[u] = ff;\n  }\n  int ton[200010], top;\n  void push_all(int u) {\n    top = 0;\n    while (not_root(u)) ton[++top] = u, u = fa[u];\n    ton[++top] = u;\n    for (; top; top--) push_down(ton[top]);\n  }\n  void splay(int u) {\n    push_all(u);\n    while (not_root(u)) {\n      int f = fa[u], ff = fa[f];\n      if (not_root(f)) rotate((ch[ff][0] == f) ^ (ch[f][0] == u) ? u : f);\n      rotate(u);\n    }\n  }\n  void access(int x) {\n    for (int y = 0; x; y = x, x = fa[x]) splay(x), ch[x][1] = y;\n  }\n  void make_root(int x) {\n    access(x);\n    splay(x);\n    set_tag(x);\n  }\n  void split(int x, int y) {\n    make_root(x);\n    access(y);\n    splay(y);\n  }\n  int find_root(int x) {\n    access(x);\n    splay(x);\n    while (ch[x][0]) push_down(x), x = ch[x][0];\n    splay(x);\n    return x;\n  }\n  bool link(int u, int v) {\n    make_root(u);\n    if (find_root(v) == u) return false;\n    fa[u] = v;\n    return true;\n  }\n  void cut(int u, int v) {\n    make_root(u);\n    if (find_root(v) != u || fa[v] != u || ch[v][0]) return;\n    fa[v] = 0, ch[u][1] = 0;\n  }\n} t0;\nint val[200010 << 2], tv[200010 << 2], tag[200010 << 2];\nvoid update(int u) {\n  tv[u] = 0, val[u] = min(val[u << 1], val[u << 1 | 1]);\n  tv[u] = (int)(val[u] == val[u << 1]) * tv[u << 1] +\n          (int)(val[u] == val[u << 1 | 1]) * tv[u << 1 | 1];\n}\nvoid build(int u, int l, int r) {\n  val[u] = 0, tv[u] = r - l + 1;\n  if (l == r) return;\n  int mid = (l + r) >> 1;\n  build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);\n}\nvoid set_tag(int u, int v) { tag[u] += v, val[u] += v; }\nvoid push_down(int u) {\n  if (tag[u]) set_tag(u << 1, tag[u]), set_tag(u << 1 | 1, tag[u]), tag[u] = 0;\n}\nvoid insert(int u, int l, int r, int L, int R, int v) {\n  if (L <= l && r <= R) {\n    set_tag(u, v);\n    return;\n  }\n  push_down(u);\n  int mid = (l + r) >> 1;\n  if (L <= mid) insert(u << 1, l, mid, L, R, v);\n  if (R > mid) insert(u << 1 | 1, mid + 1, r, L, R, v);\n  update(u);\n}\nint rres, rcnt;\nint answer(int u, int l, int r, int L, int R) {\n  if (L <= l && r <= R) {\n    return val[u] == 1 ? tv[u] : 0;\n  }\n  push_down(u);\n  int mid = (l + r) >> 1, ans = 0;\n  if (L <= mid) ans += answer(u << 1, l, mid, L, R);\n  if (R > mid) ans += answer(u << 1 | 1, mid + 1, r, L, R);\n  return ans;\n}\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) scanf(\"%d\", &id[i][j]);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      for (int _ = 0; _ < 4; _++) {\n        int x = i + ux[_], y = j + uy[_];\n        if (x < 1 || y < 1 || x > n || y > m || id[x][y] > id[i][j]) continue;\n        add(id[x][y], id[i][j]), add(id[i][j], id[x][y]);\n      }\n  int r = 0, t = n * m;\n  long long ans = 0;\n  build(1, 1, t);\n  for (int l = 1; l <= t; l++) {\n    for (int u = r + 1; u <= t; u++) {\n      bool can = true;\n      for (int i = head[u]; i; i = nxt[i]) {\n        int v = to[i];\n        if (v < u && v >= l && !t0.link(v, u)) {\n          can = false;\n          break;\n        }\n      }\n      for (int i = head[u]; i; i = nxt[i]) {\n        int v = to[i];\n        if (v >= u || v < l) continue;\n        t0.cut(v, u);\n      }\n      if (!can) break;\n      r = u;\n      int tot = 0;\n      for (int i = head[u]; i; i = nxt[i]) {\n        int v = to[i];\n        if (v < u && v >= l) t0.link(v, u), ++tot;\n      }\n      insert(1, 1, t, r, r, r - l + 1);\n      insert(1, 1, t, r, t, -tot);\n    }\n    ans += answer(1, 1, t, l, r);\n    for (int i = head[l]; i; i = nxt[i]) {\n      int v = to[i];\n      if (v <= r && v > l) t0.cut(v, l), insert(1, 1, t, v, t, 1);\n    }\n    insert(1, 1, t, l, r, -1);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1e9;\nconst long long Inf = 1e18;\nconst int mod = 1;\ntemplate <typename T = int>\nT gi() {\n  T x = 0, o = 1;\n  char ch = getchar();\n  while ((ch < '0' || ch > '9') && ch != '-') ch = getchar();\n  if (ch == '-') o = -1, ch = getchar();\n  while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();\n  return x * o;\n}\ntemplate <typename T>\nbool chkmax(T &a, T b) {\n  return a < b ? a = b, 1 : 0;\n};\ntemplate <typename T>\nbool chkmin(T &a, T b) {\n  return a > b ? a = b, 1 : 0;\n};\nint add(int a, int b) { return a + b >= mod ? a + b - mod : a + b; }\nint sub(int a, int b) { return a - b < 0 ? a - b + mod : a - b; }\nvoid inc(int &a, int b) { a = (a + b >= mod ? a + b - mod : a + b); }\nvoid dec(int &a, int b) { a = (a - b < 0 ? a - b + mod : a - b); }\nstring to_string(string s) { return '\"' + s + '\"'; }\nstring to_string(const char *s) { return to_string((string)s); }\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \",\" + to_string(p.second) + \")\";\n}\ntemplate <typename T>\nstring to_string(T v) {\n  int fst = 1;\n  string ret = \"{\";\n  for (auto x : v) {\n    if (!fst) ret += \",\";\n    fst = 0, ret += to_string(x);\n  }\n  ret += \"}\";\n  return ret;\n}\nvoid dbg_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  dbg_out(T...);\n}\ntemplate <typename T>\nint qpow(int a, T b) {\n  int ret = 1;\n  while (b) {\n    if (b & 1) ret = 1ll * ret * a % mod;\n    a = 1ll * a * a % mod, b >>= 1;\n  }\n  return ret;\n}\nstruct sgt_data {\n  int mn = 0, cnt = 0;\n};\nstruct sgt_tag {\n  int val = 0;\n};\nstruct segtree {\n  int n = 0;\n  vector<sgt_data> tr;\n  vector<sgt_tag> tg;\n  void reset(int _n) {\n    n = _n;\n    int N = (n << 2) + 10;\n    tr.clear();\n    tg.clear();\n    tr.resize(N);\n    tg.resize(N);\n  }\n  void apply(int x, int l, int r, int v) {\n    tr[x].mn += v;\n    tg[x].val += v;\n  }\n  void pushdown(int x, int l, int r) {\n    int mid = (l + r) >> 1;\n    if (tg[x].val)\n      apply((x << 1), l, mid, tg[x].val),\n          apply((x << 1 | 1), mid + 1, r, tg[x].val), tg[x].val = 0;\n  }\n  sgt_data merge(sgt_data a, sgt_data b) {\n    sgt_data ret;\n    ret.mn = min(a.mn, b.mn);\n    ret.cnt = 0;\n    if (ret.mn == a.mn) ret.cnt += a.cnt;\n    if (ret.mn == b.mn) ret.cnt += b.cnt;\n    return ret;\n  }\n  void pushup(int x) { tr[x] = merge(tr[(x << 1)], tr[(x << 1 | 1)]); }\n  void build(int x, int l, int r) {\n    tr[x].cnt = r - l + 1;\n    if (l == r) return;\n    int mid = (l + r) >> 1;\n    build((x << 1), l, mid), build((x << 1 | 1), mid + 1, r);\n    pushup(x);\n  }\n  template <typename... T>\n  void _modify(int x, int l, int r, int L, int R, T... v) {\n    if (L <= l && r <= R) return apply(x, l, r, v...);\n    pushdown(x, l, r);\n    int mid = (l + r) >> 1;\n    if (L <= mid) _modify((x << 1), l, mid, L, R, v...);\n    if (R > mid) _modify((x << 1 | 1), mid + 1, r, L, R, v...);\n    pushup(x);\n  }\n  sgt_data _query(int x, int l, int r, int L, int R) {\n    if (L <= l && r <= R) return tr[x];\n    pushdown(x, l, r);\n    int mid = (l + r) >> 1;\n    if (R <= mid)\n      return _query((x << 1), l, mid, L, R);\n    else if (L > mid)\n      return _query((x << 1 | 1), mid + 1, r, L, R);\n    else\n      return merge(_query((x << 1), l, mid, L, R),\n                   _query((x << 1 | 1), mid + 1, r, L, R));\n  }\n  segtree(int n = 0) { reset(n); }\n  void build() { build(1, 1, n); }\n  template <typename... T>\n  void modify(int l, int r, T... v) {\n    _modify(1, 1, n, l, r, v...);\n  }\n  sgt_data query(int l, int r) { return _query(1, 1, n, l, r); }\n} sgt;\nstruct lct_data {\n  int sum = 0;\n  lct_data() {}\n  lct_data(int _sum) { sum = _sum; }\n};\nstruct lct_tag {\n  int rev = 0;\n  lct_tag() {}\n  lct_tag(int _rev) { rev = _rev; }\n};\nstruct LCT {\n  vector<vector<int>> ch;\n  vector<int> fa;\n  vector<lct_data> val, tr;\n  vector<lct_tag> tg;\n  void reset(int n) {\n    const int N = n + 10;\n    ch.clear(), fa.clear();\n    val.clear();\n    tr.clear();\n    tg.clear();\n    ch.resize(N), fa.resize(N);\n    val.resize(N);\n    tr.resize(N);\n    tg.resize(N);\n    for (auto &x : ch) x.resize(2);\n  }\n  LCT(int n = 0) { reset(n); }\n  lct_data merge(lct_data a, lct_data b) {\n    lct_data ret;\n    ret.sum = a.sum ^ b.sum;\n    return ret;\n  }\n  void apply(int x, bool y = 1, int z = 0) {\n    if (y) tg[x].rev ^= 1, swap(ch[x][0], ch[x][1]);\n    if (z) val[x].sum ^= z, tr[x].sum ^= z;\n  }\n  void pushdown(int x) {\n    if (tg[x].rev) apply(ch[x][0]), apply(ch[x][1]), tg[x].rev = 0;\n  }\n  void pushup(int x) {\n    tr[x] = merge(merge(tr[ch[x][0]], val[x]), tr[ch[x][1]]);\n  }\n  bool isroot(int x) { return ch[fa[x]][0] != x && ch[fa[x]][1] != x; }\n  void rotate(int x) {\n    int y = fa[x], z = fa[y], w = ch[y][1] == x;\n    if (!isroot(y)) ch[z][ch[z][1] == y] = x;\n    ch[y][w] = ch[x][w ^ 1];\n    fa[ch[y][w]] = y;\n    ch[x][w ^ 1] = y;\n    fa[y] = x;\n    fa[x] = z;\n    pushup(y);\n    pushup(x);\n  }\n  void pushall(int x) {\n    if (!isroot(x)) pushall(fa[x]);\n    pushdown(x);\n  }\n  void splay(int x) {\n    pushall(x);\n    while (!isroot(x)) {\n      int y = fa[x], z = fa[y];\n      if (!isroot(y)) (ch[y][0] == x) ^ (ch[z][0] == y) ? rotate(x) : rotate(y);\n      rotate(x);\n    }\n  }\n  void access(int x) {\n    for (int t = 0; x; t = x, x = fa[x]) splay(x), ch[x][1] = t, pushup(x);\n  }\n  void makeroot(int x) {\n    access(x);\n    splay(x);\n    apply(x);\n  }\n  void link(int x, int y) {\n    makeroot(x);\n    fa[x] = y;\n  }\n  void cut(int x, int y) {\n    makeroot(x);\n    access(y);\n    splay(y);\n    if (ch[y][0] == x && !ch[x][1]) ch[y][0] = fa[x] = 0, pushup(y);\n  }\n  void split(int x, int y) {\n    makeroot(x);\n    access(y);\n    splay(y);\n  }\n  int findroot(int x) {\n    access(x);\n    splay(x);\n    while (ch[x][0]) x = ch[x][0];\n    splay(x);\n    return x;\n  }\n  template <typename... T>\n  void modify(int x, int y, T... v) {\n    split(x, y);\n    apply(y, v...);\n  }\n  lct_data query(int x, int y) {\n    split(x, y);\n    return tr[y];\n  }\n} lct;\nconst int N = 1e3 + 10;\nint n, m, f[N][N], id[N][N], tot = 0, lp[N * N], dx[4] = {1, 0, 0, -1},\n                             dy[4] = {0, 1, -1, 0};\npair<int, int> pos[N * N];\nvector<int> get(int i) {\n  vector<int> ret;\n  int x = pos[i].first, y = pos[i].second;\n  for (int d = 0; d < 4; d++) {\n    int xx = x + dx[d], yy = y + dy[d];\n    if (xx < 1 || xx > n || yy < 1 || yy > m) continue;\n    ret.push_back(f[xx][yy]);\n  }\n  return ret;\n}\nbool check(int x, int now, int lim, vector<int> v) {\n  if (now == int(v.size())) return 1;\n  if (v[now] < lim || v[now] > x) return check(x, now + 1, lim, v);\n  if (lct.findroot(v[now]) == lct.findroot(x)) return 0;\n  lct.link(x, v[now]);\n  bool ret = check(x, now + 1, lim, v);\n  if (!ret) lct.cut(x, v[now]);\n  return ret;\n}\nint main() {\n  n = gi(), m = gi();\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) f[i][j] = gi(), id[i][j] = ++tot;\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) pos[f[i][j]] = make_pair(i, j);\n  lct.reset(n * m), sgt.reset(n * m);\n  for (int i = 1, j = 1; i <= n * m; i++) {\n    vector<int> v = get(i);\n    while (!check(i, 0, j, v)) {\n      vector<int> d = get(j);\n      for (auto x : d) lct.cut(j, x);\n      ++j;\n    }\n    lp[i] = j;\n  }\n  sgt.build();\n  long long ans = 0;\n  for (int i = 1; i <= n * m; i++) {\n    sgt.modify(lp[i], i, 1);\n    vector<int> v = get(i);\n    for (auto x : v)\n      if (x >= lp[i] && x <= i) sgt.modify(lp[i], x, -1);\n    ans += sgt.query(lp[i], i).cnt;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class F2 {\n\n\tstatic int R, C;\n\tstatic int b[][];\n\tstatic Pair ps[];\n\tstatic int dr[] = new int[] { -1, 1, 0, 0 };\n\tstatic int dc[] = new int[] { 0, 0, -1, 1 };\n\t\n\tstatic Node nodes[][];\n\t\n\tstatic int pL,pR;\n\t\n\tpublic static void main(String[] args) {\n\t\tFS in = new FS();\n\t\tR = in.nextInt();\n\t\tC = in.nextInt();\n\t\tb = new int[R][C];\n\t\tfor (int i = 0; i < R; i++)\n\t\t\tfor (int j = 0; j < C; j++)\n\t\t\t\tb[i][j] = in.nextInt() - 1;\n\n\t\tps = new Pair[R * C];\n\t\tfor (int i = 0; i < R; i++)\n\t\t\tfor (int j = 0; j < C; j++)\n\t\t\t\tps[b[i][j]] = new Pair(i, j);\n\n\t\tnodes = new Node[R][C];\n\t\tfor(int i = 0; i < R; i++)\n\t\t\tfor(int j = 0; j < C; j++)\n\t\t\t\tnodes[i][j] = new Node(-1);\n\t\t\n\t\tlong res = 0;\n\t\t\n\t\tpR = -1;\n\t\tint nComps = 0;\n\t\tST st = new ST(0, R*C);\n\t\tfor(pL = 0; pL < R*C; pL++) {\n\t\t\t// add until we are about to make a non-tree\n\t\t\twhile(true) {\n\t\t\t\tboolean good = pR+1 < R*C;\n\t\t\t\tif(good) {\n\t\t\t\t\tPair p = ps[pR+1];\n\t\t\t\t\tPair a, b;\n\t\t\t\t\tfor(int k1 = 0; k1 < 4; k1++)\n\t\t\t\t\t\tfor(int k2 = k1+1; k2 < 4; k2++)\n\t\t\t\t\t\t\tif((a = p.to(k1)).v() && (b = p.to(k2)).v() && connected(a.n(), b.n())) good = false;\n\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif(good) {\n\t\t\t\t\tPair p = ps[++pR];\n\t\t\t\t\tPair a;\n\t\t\t\t\tnComps++; // add my guy\n\t\t\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\t\t\tif((a = p.to(k)).v()) {\n\t\t\t\t\t\t\tNode n1 = p.n(), n2 = a.n();\n\t\t\t\t\t\t\tif(!connected(n1, n2)) {\n\t\t\t\t\t\t\t\tlink(n1,n2);\n\t\t\t\t\t\t\t\tnComps--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tst.add(pR, pR, nComps);\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t\t\n\t\t\tint x[] = st.q(pL, pR);\n\t\t\tint nOnes = (x[0] == 1 ? x[1] : 0);\n\t\t\t\n\t\t\tres += nOnes;\n\t\t\t\n\t\t\t// remove this guy\n\t\t\t// get min first\n\t\t\tint first = pR+1;\n\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\tPair a = ps[pL].to(k);\n\t\t\t\tif(a.v()) first = min(first, b[a.r][a.c]);\n\t\t\t}\n\t\t\tst.add(pL, first-1, -1);\n\t\t\t\n\t\t\tnComps--;\n\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\tPair a = ps[pL].to(k);\n\t\t\t\tif(!a.v()) continue;\n\t\t\t\t// Guarenteed they are connected at this stage\n\t\t\t\tcut(ps[pL].n(), a.n());\n\t\t\t\tnComps++;\n\t\t\t\tif(b[a.r][a.c] != first) st.add(b[a.r][a.c], pR, 1);\n\t\t\t}\n\t\t\t\n//\t\t\tSystem.out.println(l+\" \"+r+\" nComps = \"+nComps+\" nOnes = \"+nOnes);\n\t\t}\n\t\t\n\t\t\n\t\tSystem.out.println(res);\n\t}\n\t\n\tstatic class ST {\n\t\tST left, right;\n\t\tint l, r, m, mc, del;\n\t\tpublic ST(int ll, int rr) {\n\t\t\tl=ll;\n\t\t\tr=rr;\n\t\t\tm = del = 0;\n\t\t\tmc = (r-l+1);\n\t\t\tif(l == r) return;\n\t\t\tint mid = (l+r)>>1;\n\t\t\tleft = new ST(l, mid);\n\t\t\tright = new ST(mid+1, r);\n\t\t}\n\t\t\n\t\tvoid set(int v) {\n\t\t\tdel += v;\n\t\t\tm += v;\n\t\t}\n\t\tvoid prop() {\n\t\t\tleft.set(del);\n\t\t\tright.set(del);\n\t\t\tdel = 0;\n\t\t}\n\t\tvoid update() {\n\t\t\tm = min(left.m, right.m);\n\t\t\tmc = 0;\n\t\t\tif(left.m == m) mc += left.mc;\n\t\t\tif(right.m == m) mc += right.mc;\n\t\t}\n\t\tvoid add(int ll, int rr, int v) {\n\t\t\tif(ll <= l && r <= rr) {\n\t\t\t\tset(v); return;\n\t\t\t}\n\t\t\tif(l > rr || r < ll) return;\n\t\t\tprop();\n\t\t\tleft.add(ll, rr, v);\n\t\t\tright.add(ll, rr, v);\n\t\t\tupdate();\n\t\t}\n\t\t\n\t\tint[] q(int ll, int rr) {\n\t\t\tif(ll <= l && r <= rr) return new int[] {m, mc};\n\t\t\tif(l > rr || r < ll) return null;\n\t\t\tprop();\n\t\t\tint x[] = left.q(ll, rr);\n\t\t\tint y[] = right.q(ll, rr);\n\t\t\tif(x == null) return y;\n\t\t\telse if(y == null) return x;\n\t\t\telse if(x[0] < y[0]) return x;\n\t\t\telse if(x[0] > y[0]) return y;\n\t\t\telse return new int[] {x[0], x[1] + y[1]};\n\t\t}\n\t}\n\tstatic int min(int a, int b) { return a < b ? a : b;}\n\n\tstatic class Pair {\n\t\tint r, c;\n\n\t\tpublic Pair(int rr, int cc) {\n\t\t\tr = rr;\n\t\t\tc = cc;\n\t\t}\n\t\t\n\t\tpublic Node n() {\n\t\t\treturn nodes[r][c];\n\t\t}\n\t\t\n\t\tpublic Pair to(int k) {\n\t\t\treturn new Pair (r+dr[k], c+dc[k]);\n\t\t}\n\t\t\n\t\tpublic boolean v() {\n\t\t\treturn r >= 0 && r < R && c >= 0 && c < C && b[r][c] >= pL && b[r][c] <= pR;\n\t\t}\n\t}\n\n\n\tpublic static class Node {\n\t\tint nodeValue, subTreeValue, delta, size;\n\t\t// delta affects nodeValue, subTreeValue, left.delta and right.delta\n\t\tboolean revert;\n\t\tNode left, right, parent;\n\n\t\tNode(int value) {\n\t\t\tsubTreeValue = nodeValue = value;\n\t\t\tsize = 1;\n\t\t}\n\n\t\t// tests whether x is a root of a splay tree\n\t\tboolean isRoot() {\n\t\t\treturn parent == null || (parent.left != this && parent.right != this);\n\t\t}\n\n\t\tvoid push() {\n\t\t\tif (revert) {\n\t\t\t\trevert = false;\n\t\t\t\tNode t = left;\n\t\t\t\tleft = right;\n\t\t\t\tright = t;\n\t\t\t\tif (left != null)\n\t\t\t\t\tleft.revert = !left.revert;\n\t\t\t\tif (right != null)\n\t\t\t\t\tright.revert = !right.revert;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tstatic void connect(Node ch, Node p, Boolean isLeftChild) {\n\t\tif (ch != null)\n\t\t\tch.parent = p;\n\t\tif (isLeftChild != null) {\n\t\t\tif (isLeftChild)\n\t\t\t\tp.left = ch;\n\t\t\telse\n\t\t\t\tp.right = ch;\n\t\t}\n\t}\n\n\tstatic void rotate(Node x) {\n\t\tNode p = x.parent, g = p.parent;\n\t\tboolean isRootP = p.isRoot(), leftChildX = (x == p.left);\n\n\t\t// create 3 edges: (x.r(l),p), (p,x), (x,g)\n\t\tconnect(leftChildX ? x.right : x.left, p, leftChildX);\n\t\tconnect(p, x, !leftChildX);\n\t\tconnect(x, g, isRootP ? null : p == g.left);\n\t}\n\n\tstatic void splay(Node x) {\n\t\twhile (!x.isRoot()) {\n\t\t\tNode p = x.parent, g = p.parent;\n\t\t\tif (!p.isRoot())\n\t\t\t\tg.push();\n\t\t\tp.push();\n\t\t\tx.push();\n\t\t\tif (!p.isRoot())\n\t\t\t\trotate((x == p.left) == (p == g.left) ? p : x);\n\t\t\trotate(x);\n\t\t}\n\t\tx.push();\n\t}\n\n\t// makes node x the root of the virtual tree, and also x becomes the leftmost\n\t// node in its splay tree\n\tstatic Node expose(Node x) {\n\t\tNode last = null;\n\t\tfor (Node y = x; y != null; y = y.parent) {\n\t\t\tsplay(y);\n\t\t\ty.left = last;\n\t\t\tlast = y;\n\t\t}\n\t\tsplay(x);\n\t\treturn last;\n\t}\n\n\tpublic static void makeRoot(Node x) {\n\t\texpose(x);\n\t\tx.revert = !x.revert;\n\t}\n\n\tpublic static boolean connected(Node x, Node y) {\n\t\tif (x == y)\n\t\t\treturn true;\n\t\texpose(x);\n\t\texpose(y);\n\t\treturn x.parent != null;\n\t}\n\n\tpublic static void link(Node x, Node y) {\n\t\tmakeRoot(x);\n\t\tx.parent = y;\n\t}\n\n\tpublic static void cut(Node x, Node y) {\n\t\tmakeRoot(x);\n\t\texpose(y);\n\t\ty.right.parent = null;\n\t\ty.right = null;\n\t}\n\n\n\tstatic class FS {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FS() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tthrow null;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t}\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar getc() {\n  char c = getchar();\n  while ((c < 'A' || c > 'Z') && (c < 'a' || c > 'z') && (c < '0' || c > '9'))\n    c = getchar();\n  return c;\n}\nint gcd(int n, int m) { return m == 0 ? n : gcd(m, n % m); }\nint read() {\n  int x = 0, f = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9')\n    x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();\n  return x * f;\n}\nint n, m, a[1010][1010], near[200010][4];\nlong long ans;\nstruct data {\n  int ch[2], fa, rev;\n} tree[200010];\nvoid rev(int k) {\n  if (k) swap(tree[k].ch[0], tree[k].ch[1]), tree[k].rev ^= 1;\n}\nvoid down(int k) {\n  if (tree[k].rev) rev(tree[k].ch[0]), rev(tree[k].ch[1]), tree[k].rev = 0;\n}\nint whichson(int k) { return tree[tree[k].fa].ch[1] == k; }\nbool isroot(int k) {\n  return tree[tree[k].fa].ch[0] != k && tree[tree[k].fa].ch[1] != k;\n}\nvoid push(int k) {\n  if (!isroot(k)) push(tree[k].fa);\n  down(k);\n}\nvoid move(int k) {\n  int fa = tree[k].fa, gf = tree[fa].fa, p = whichson(k);\n  if (!isroot(fa)) tree[gf].ch[whichson(fa)] = k;\n  tree[k].fa = gf;\n  tree[fa].ch[p] = tree[k].ch[!p], tree[tree[k].ch[!p]].fa = fa;\n  tree[k].ch[!p] = fa, tree[fa].fa = k;\n}\nvoid splay(int k) {\n  push(k);\n  while (!isroot(k)) {\n    int fa = tree[k].fa;\n    if (!isroot(fa))\n      if (whichson(fa) ^ whichson(k))\n        move(k);\n      else\n        move(fa);\n    move(k);\n  }\n}\nvoid access(int k) {\n  for (int t = 0; k; t = k, k = tree[k].fa) splay(k), tree[k].ch[1] = t;\n}\nint findroot(int k) {\n  if (!k) return 0;\n  access(k);\n  splay(k);\n  for (; tree[k].ch[0]; k = tree[k].ch[0]) down(k);\n  splay(k);\n  return k;\n}\nvoid makeroot(int k) { access(k), splay(k), rev(k); }\nvoid link(int x, int y) {\n  makeroot(x);\n  tree[x].fa = y;\n}\nvoid cut(int x, int y) {\n  makeroot(x), access(y), splay(y);\n  tree[y].ch[0] = tree[x].fa = 0;\n}\nint L[200010 << 2], R[200010 << 2], sum[200010 << 2], top[200010 << 2],\n    lazy[200010 << 2];\nvoid up(int k) {\n  if (top[k << 1] == top[k << 1 | 1]) {\n    top[k] = top[k << 1];\n    sum[k] = sum[k << 1] + sum[k << 1 | 1];\n  } else if (top[k << 1] < top[k << 1 | 1])\n    top[k] = top[k << 1], sum[k] = sum[k << 1];\n  else\n    top[k] = top[k << 1 | 1], sum[k] = sum[k << 1 | 1];\n}\nvoid build(int k, int l, int r) {\n  L[k] = l, R[k] = r;\n  if (l == r) {\n    sum[k] = 1;\n    return;\n  }\n  int mid = l + r >> 1;\n  build(k << 1, l, mid);\n  build(k << 1 | 1, mid + 1, r);\n  up(k);\n}\nvoid Down(int k) {\n  top[k << 1] += lazy[k], top[k << 1 | 1] += lazy[k];\n  lazy[k << 1] += lazy[k], lazy[k << 1 | 1] += lazy[k];\n  lazy[k] = 0;\n}\nvoid add(int k, int l, int r, int op) {\n  if (L[k] == l && R[k] == r) {\n    lazy[k] += op;\n    top[k] += op;\n    return;\n  }\n  if (lazy[k]) Down(k);\n  int mid = L[k] + R[k] >> 1;\n  if (r <= mid)\n    add(k << 1, l, r, op);\n  else if (l > mid)\n    add(k << 1 | 1, l, r, op);\n  else\n    add(k << 1, l, mid, op), add(k << 1 | 1, mid + 1, r, op);\n  up(k);\n}\nint query(int k, int l, int r) {\n  if (L[k] == l && R[k] == r) return (top[k] == 1) * sum[k];\n  if (lazy[k]) Down(k);\n  int mid = L[k] + R[k] >> 1;\n  if (r <= mid)\n    return query(k << 1, l, r);\n  else if (l > mid)\n    return query(k << 1 | 1, l, r);\n  else\n    return query(k << 1, l, mid) + query(k << 1 | 1, mid + 1, r);\n}\nvoid print(int k, int l, int r) {\n  if (L[k] == R[k]) {\n    cout << top[k] << ' ';\n    return;\n  }\n  if (lazy[k]) Down(k);\n  int mid = L[k] + R[k] >> 1;\n  if (r <= mid)\n    print(k << 1, l, r);\n  else if (l > mid)\n    print(k << 1 | 1, l, r);\n  else\n    print(k << 1, l, mid), print(k << 1 | 1, mid + 1, r);\n}\nsigned main() {\n  n = read(), m = read();\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) a[i][j] = read();\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) {\n      near[a[i][j]][0] = a[i - 1][j];\n      near[a[i][j]][1] = a[i + 1][j];\n      near[a[i][j]][2] = a[i][j - 1];\n      near[a[i][j]][3] = a[i][j + 1];\n    }\n  build(1, 1, n * m);\n  int l = 1;\n  for (int i = 1; i <= n * m; i++) {\n    bool flag;\n    do {\n      flag = 0;\n      int u[5], t = 0;\n      u[t++] = findroot(i);\n      for (int j = 0; j < 4; j++)\n        if (near[i][j]) u[t++] = findroot(near[i][j]);\n      for (int x = 0; x < t; x++)\n        for (int y = x + 1; y < t; y++)\n          if (u[x] == u[y]) {\n            flag = 1;\n            break;\n          }\n      if (!flag) break;\n      for (int j = 0; j < 4; j++)\n        if (near[l][j] >= l && near[l][j] < i) cut(l, near[l][j]);\n      l++;\n    } while (1);\n    add(1, l, i, 1);\n    for (int j = 0; j < 4; j++)\n      if (near[i][j] >= l && near[i][j] <= i)\n        link(i, near[i][j]), add(1, l, near[i][j], -1);\n    ans += query(1, l, i);\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nconst int N = 200005, M = 1005;\nint n, m, q;\nint a[M][M];\nint left[N], first[N], second[N];\nnamespace lct {\nint ch[N][2], f[N];\nbool tag[N];\nbool get(int first) { return ch[f[first]][1] == first; }\nbool isroot(int first) {\n  return ch[f[first]][0] != first && ch[f[first]][1] != first;\n}\nvoid rotate(int first) {\n  int second = f[first], z = f[second];\n  bool b = get(first);\n  if (!isroot(second)) ch[z][get(second)] = first;\n  ch[second][b] = ch[first][!b], ch[first][!b] = second;\n  f[second] = first, f[first] = z;\n  if (ch[second][b]) f[ch[second][b]] = second;\n}\nint stack[N], top;\nvoid pushdown(int first) {\n  if (!tag[first]) return;\n  tag[first] = 0, std::swap(ch[first][0], ch[first][1]);\n  tag[ch[first][0]] ^= 1, tag[ch[first][1]] ^= 1;\n}\nvoid splay(int first) {\n  stack[top = 1] = first;\n  for (int second = first; !isroot(second); stack[++top] = second = f[second])\n    ;\n  while (top) pushdown(stack[top--]);\n  for (; !isroot(first); rotate(first))\n    if (!isroot(f[first]))\n      rotate(get(first) ^ get(f[first]) ? first : f[first]);\n}\nvoid access(int first) {\n  for (int t = 0; first; ch[first][1] = t, t = first, first = f[first])\n    splay(first);\n}\nvoid makeroot(int first) { access(first), splay(first), tag[first] ^= 1; }\nvoid link(int first, int second) { makeroot(first), f[first] = second; }\nvoid split(int first, int second) {\n  makeroot(first), access(second), splay(second);\n}\nvoid cut(int first, int second) {\n  split(first, second), f[first] = ch[second][0] = 0;\n}\nbool conn(int first, int second) {\n  split(first, second);\n  while (pushdown(second), ch[second][0]) second = ch[second][0];\n  return splay(second), first == second;\n}\n}  // namespace lct\nconst int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\nbool check(int p) {\n  int first = ::first[p], second = ::second[p];\n  static int c[4];\n  int cnt = 0;\n  for (int i = 0; i < 4; ++i)\n    if (a[first + dx[i]][second + dy[i]] &&\n        a[first + dx[i]][second + dy[i]] < p)\n      c[cnt++] = a[first + dx[i]][second + dy[i]];\n  for (int i = 0; i < cnt; ++i)\n    for (int j = i + 1; j < cnt; ++j)\n      if (lct::conn(c[i], c[j])) return 0;\n  return 1;\n}\nvoid remove(int p, int pl) {\n  int first = ::first[p], second = ::second[p];\n  for (int i = 0; i < 4; ++i)\n    if (a[first + dx[i]][second + dy[i]] > p &&\n        a[first + dx[i]][second + dy[i]] < pl)\n      lct::cut(p, a[first + dx[i]][second + dy[i]]);\n}\nvoid insert(int p, int pl) {\n  int first = ::first[p], second = ::second[p];\n  for (int i = 0; i < 4; ++i)\n    if (a[first + dx[i]][second + dy[i]] >= pl &&\n        a[first + dx[i]][second + dy[i]] < p)\n      lct::link(p, a[first + dx[i]][second + dy[i]]);\n}\nint tag[N << 2];\nstd::pair<int, int> sum[N << 2];\nstd::pair<int, int> operator+(std::pair<int, int> a, std::pair<int, int> b) {\n  if (a.first == b.first)\n    return std::pair<int, int>(a.first, a.second + b.second);\n  else\n    return std::min(a, b);\n}\nvoid pushup(int o) { sum[o] = sum[o << 1] + sum[o << 1 | 1]; }\nvoid build(int o = 1, int l = 1, int r = q) {\n  sum[o] = std::pair<int, int>(-r, 1);\n  if (l == r) return;\n  int mid = l + r >> 1;\n  build(o << 1, l, mid);\n  build(o << 1 | 1, mid + 1, r);\n}\nvoid settag(int o, int v = -1) { tag[o] += v, sum[o].first += v; }\nvoid pushdown(int o) {\n  settag(o << 1, tag[o]);\n  settag(o << 1 | 1, tag[o]);\n  tag[o] = 0;\n}\nvoid modify(int R, int o = 1, int l = 1, int r = q) {\n  if (R >= r) return settag(o);\n  int mid = l + r >> 1;\n  pushdown(o);\n  modify(R, o << 1, l, mid);\n  if (R > mid) modify(R, o << 1 | 1, mid + 1, r);\n  pushup(o);\n}\nstd::pair<int, int> query(int L, int R, int o = 1, int l = 1, int r = q) {\n  if (L <= l && R >= r) return sum[o];\n  int mid = l + r >> 1;\n  std::pair<int, int> ret = std::pair<int, int>(0x3f3f3f3f, 0);\n  pushdown(o);\n  if (L <= mid) ret = ret + query(L, R, o << 1, l, mid);\n  if (R > mid) ret = ret + query(L, R, o << 1 | 1, mid + 1, r);\n  return ret;\n}\nvoid update(int p) {\n  int first = ::first[p], second = ::second[p];\n  for (int i = 0; i < 4; ++i)\n    if (a[first + dx[i]][second + dy[i]] &&\n        a[first + dx[i]][second + dy[i]] < p)\n      modify(a[first + dx[i]][second + dy[i]]);\n}\nint main() {\n  std::ios::sync_with_stdio(0), std::cin.tie(0);\n  std::cin >> n >> m, q = n * m;\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j) {\n      std::cin >> a[i][j];\n      first[a[i][j]] = i, second[a[i][j]] = j;\n    }\n  int pl = 1;\n  for (int i = 1; i <= q; ++i) {\n    while (!check(i)) remove(pl++, i);\n    insert(i, pl), left[i] = pl;\n  }\n  build();\n  long long ans = 0;\n  for (int i = 1; i <= q; ++i) update(i), ans += query(left[i], i).second;\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint read() {\n  int X = 0;\n  char ch = 0;\n  while (ch < 48 || ch > 57) ch = getchar();\n  while (ch >= 48 && ch <= 57) X = X * 10 + (ch ^ 48), ch = getchar();\n  return X;\n}\nstruct LCT {\n  struct Node {\n    int l, r, f;\n    bool fl;\n    inline void rev() {\n      swap(l, r);\n      fl ^= 1;\n    }\n  } a[200500];\n  inline bool nrt(int u) { return a[a[u].f].l == u || a[a[u].f].r == u; }\n  inline void ladd(int u) {\n    if (a[u].fl) {\n      a[a[u].l].rev();\n      a[a[u].r].rev();\n      a[u].fl = 0;\n    }\n  }\n  void rot(int u) {\n    int fa = a[u].f, gf = a[fa].f;\n    ladd(fa);\n    ladd(u);\n    if (a[gf].l == fa) a[gf].l = u;\n    if (a[gf].r == fa) a[gf].r = u;\n    a[a[fa].f = u].f = gf;\n    if (a[fa].l == u) {\n      a[a[fa].l = a[u].r].f = fa;\n      a[u].r = fa;\n    } else {\n      a[a[fa].r = a[u].l].f = fa;\n      a[u].l = fa;\n    }\n  }\n  void splay(int u) {\n    ladd(u);\n    while (nrt(u)) {\n      int fa = a[u].f, gf = a[fa].f;\n      if (nrt(fa) && (a[fa].l == u) == (a[gf].l == fa)) rot(fa);\n      rot(u);\n    }\n  }\n  void access(int u) {\n    int sav = u;\n    for (int v = 0; u; u = a[v = u].f) {\n      splay(u);\n      a[u].r = v;\n    }\n    splay(sav);\n  }\n  void makrt(int u) {\n    access(u);\n    a[u].rev();\n  }\n  int findrt(int u) {\n    access(u);\n    while (a[u].l) {\n      ladd(u);\n      u = a[u].l;\n    }\n    splay(u);\n    return u;\n  }\n  void spilt(int u, int v) {\n    makrt(u);\n    access(v);\n  }\n  void link(int u, int v) {\n    makrt(u);\n    a[u].f = v;\n  }\n  void cut(int x, int y) {\n    spilt(x, y);\n    a[x].f = a[y].l = 0;\n  }\n  bool chk(int u, int v) { return findrt(u) == findrt(v); }\n} T;\nstruct Node {\n  int x, c, tg;\n  inline void ladd(int t) {\n    tg += t;\n    x += t;\n  }\n} a[200500 << 2];\ninline void up(int u) {\n  int l = u << 1, r = u << 1 | 1;\n  a[u].x = min(a[l].x, a[r].x);\n  a[u].c =\n      ((a[l].x == a[u].x) ? a[l].c : 0) + ((a[r].x == a[u].x) ? a[r].c : 0);\n}\nint n;\nvoid build(int l = 1, int r = n, int u = 1) {\n  if (l == r) {\n    a[u].c = 1;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  build(l, mid, u << 1);\n  build(mid + 1, r, u << 1 | 1);\n  up(u);\n}\ninline void ladd(int u) {\n  if (a[u].tg) {\n    a[u << 1].ladd(a[u].tg);\n    a[u << 1 | 1].ladd(a[u].tg);\n    a[u].tg = 0;\n  }\n}\nint wfl, wfr, wfc;\nvoid add(int l = 1, int r = n, int u = 1) {\n  if (wfl <= l && r <= wfr) {\n    a[u].ladd(wfc);\n    return;\n  }\n  int mid = (l + r) >> 1;\n  ladd(u);\n  if (wfl <= mid) add(l, mid, u << 1);\n  if (mid < wfr) add(mid + 1, r, u << 1 | 1);\n  up(u);\n}\nint qry(int l = 1, int r = n, int u = 1) {\n  if (wfl <= l && r <= wfr) return a[u].x == 1 ? a[u].c : 0;\n  int mid = (l + r) >> 1, ret = 0;\n  ladd(u);\n  if (wfl <= mid) ret = qry(l, mid, u << 1);\n  if (mid < wfr) ret += qry(mid + 1, r, u << 1 | 1);\n  return ret;\n}\nstruct Data {\n  int x, y;\n} p[200500];\nint m1, m2, x[200500];\nvoid del(int u, int v, int tp, int tr) {\n  if (tp <= x[v] && x[v] < tr) T.cut(u, v);\n}\nvoid delp(int x, int y, int tp, int tr) {\n  if (1 < x) del((((x)-1) * m2 + (y)), (((x - 1) - 1) * m2 + (y)), tp, tr);\n  if (1 < y) del((((x)-1) * m2 + (y)), (((x)-1) * m2 + (y - 1)), tp, tr);\n  if (x < m1) del((((x)-1) * m2 + (y)), (((x + 1) - 1) * m2 + (y)), tp, tr);\n  if (y < m2) del((((x)-1) * m2 + (y)), (((x)-1) * m2 + (y + 1)), tp, tr);\n}\nvoid adl(int u, int v, int &tp, int tr) {\n  if (tr <= x[v]) return;\n  for (; tp <= x[v] && T.chk(u, v); tp++) delp(p[tp].x, p[tp].y, tp, tr);\n  if (x[v] < tp) return;\n  T.link(u, v);\n  wfl = 1;\n  wfr = x[v];\n  wfc = -1;\n  add();\n}\nvoid addp(int x, int y, int &tp, int tr) {\n  if (1 < x) adl((((x)-1) * m2 + (y)), (((x - 1) - 1) * m2 + (y)), tp, tr);\n  if (1 < y) adl((((x)-1) * m2 + (y)), (((x)-1) * m2 + (y - 1)), tp, tr);\n  if (x < m1) adl((((x)-1) * m2 + (y)), (((x + 1) - 1) * m2 + (y)), tp, tr);\n  if (y < m2) adl((((x)-1) * m2 + (y)), (((x)-1) * m2 + (y + 1)), tp, tr);\n}\nint main() {\n  m1 = read();\n  m2 = read();\n  n = m1 * m2;\n  for (int i = 1; i <= m1; i++)\n    for (int j = 1; j <= m2; j++)\n      p[x[(((i)-1) * m2 + (j))] = read()] = (Data){i, j};\n  long long ans = 0;\n  build();\n  for (int i = 1, tp = 1; i <= n; i++) {\n    addp(p[i].x, p[i].y, tp, i);\n    wfl = 1;\n    wfr = i;\n    wfc = 1;\n    add();\n    wfl = tp;\n    wfr = i;\n    ans += qry();\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid chkmax(T &first, T second) {\n  first < second ? first = second : T();\n}\ntemplate <typename T>\nvoid chkmin(T &first, T second) {\n  first > second ? first = second : T();\n}\ntemplate <typename T>\nvoid readint(T &first) {\n  first = 0;\n  int f = 1;\n  char c;\n  for (c = getchar(); !isdigit(c); c = getchar())\n    if (c == '-') f = -1;\n  for (; isdigit(c); c = getchar()) first = first * 10 + c - '0';\n  first *= f;\n}\nconst int MAXN = 1005, MAXM = 200005, DIR[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};\nint n, m, a[MAXN][MAXN];\npair<int, int> b[MAXM];\nvector<int> G[MAXM];\nnamespace LCT {\nint ch[MAXM][2], fa[MAXM];\nbool rev[MAXM];\nbool nroot(int u) { return ch[fa[u]][0] == u || ch[fa[u]][1] == u; }\nbool sontype(int u) { return ch[fa[u]][1] == u; }\nvoid reverse(int u) {\n  rev[u] ^= 1;\n  swap(ch[u][0], ch[u][1]);\n}\nvoid pushdown(int u) {\n  if (rev[u]) reverse(ch[u][0]), reverse(ch[u][1]), rev[u] = 0;\n}\nvoid pushall(int u) {\n  if (nroot(u)) pushall(fa[u]);\n  pushdown(u);\n}\nvoid update(int u) {}\nvoid rotate(int u) {\n  int t = sontype(u), first = fa[u], second = fa[first], z = ch[u][t ^ 1];\n  fa[u] = second;\n  if (nroot(first)) ch[second][sontype(first)] = u;\n  if (z) fa[z] = first;\n  ch[first][t] = z;\n  fa[first] = u;\n  ch[u][t ^ 1] = first;\n  update(first);\n  update(u);\n}\nvoid splay(int u) {\n  pushall(u);\n  while (nroot(u))\n    if (!nroot(fa[u]))\n      rotate(u);\n    else if (sontype(u) == sontype(fa[u]))\n      rotate(fa[u]), rotate(u);\n    else\n      rotate(u), rotate(u);\n}\nvoid access(int u) {\n  for (int v = 0; u; u = fa[v = u]) splay(u), ch[u][1] = v, update(u);\n}\nvoid makeroot(int u) { access(u), splay(u), reverse(u); }\nvoid link(int u, int v) {\n  makeroot(u);\n  makeroot(v);\n  fa[u] = v;\n}\nvoid cut(int u, int v) {\n  makeroot(u);\n  access(v);\n  splay(u);\n  ch[u][1] = fa[v] = 0;\n  update(u);\n}\n};  // namespace LCT\nnamespace SEG {\npair<int, int> f[MAXM << 2];\nint tag[MAXM << 2];\nvoid pushdown(int id) {\n  if (!tag[id]) return;\n  tag[id << 1] += tag[id], f[id << 1].first += tag[id];\n  tag[id << 1 | 1] += tag[id], f[id << 1 | 1].first += tag[id];\n  tag[id] = 0;\n}\npair<int, int> update(pair<int, int> p, pair<int, int> q) {\n  return p.first == q.first ? make_pair(p.first, p.second + q.second)\n                            : min(p, q);\n}\nvoid build(int id, int l, int r) {\n  if (l == r) {\n    f[id] = make_pair(0, 1);\n    return;\n  }\n  int mid = (l + r) >> 1;\n  build(id << 1, l, mid);\n  build(id << 1 | 1, mid + 1, r);\n  f[id] = update(f[id << 1], f[id << 1 | 1]);\n}\nvoid modify(int id, int l, int r, int ql, int qr, int c) {\n  if (l == ql && r == qr) {\n    tag[id] += c;\n    f[id].first += c;\n    return;\n  }\n  pushdown(id);\n  int mid = (l + r) >> 1;\n  if (qr <= mid)\n    modify(id << 1, l, mid, ql, qr, c);\n  else if (ql > mid)\n    modify(id << 1 | 1, mid + 1, r, ql, qr, c);\n  else\n    modify(id << 1, l, mid, ql, mid, c),\n        modify(id << 1 | 1, mid + 1, r, mid + 1, qr, c);\n  f[id] = update(f[id << 1], f[id << 1 | 1]);\n}\npair<int, int> query(int id, int l, int r, int ql, int qr) {\n  if (l == ql && r == qr) return f[id];\n  pushdown(id);\n  int mid = (l + r) >> 1;\n  if (qr <= mid) return query(id << 1, l, mid, ql, qr);\n  if (ql > mid) return query(id << 1 | 1, mid + 1, r, ql, qr);\n  return update(query(id << 1, l, mid, ql, mid),\n                query(id << 1 | 1, mid + 1, r, mid + 1, qr));\n}\n};  // namespace SEG\nint main() {\n  readint(n), readint(m);\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j) {\n      readint(a[i][j]);\n      b[a[i][j]] = make_pair(i, j);\n    }\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n      for (int t = 0; t < 4; ++t) {\n        int first = i + DIR[t][0], second = j + DIR[t][1];\n        if (first <= 0 || second <= 0 || first > n || second > m) continue;\n        G[a[i][j]].push_back(a[first][second]);\n      }\n  long long ans = 0;\n  int l = 1;\n  SEG::build(1, 1, n * m);\n  for (int r = 1; r <= n * m; ++r) {\n    while (l < r) {\n      for (auto v : G[r])\n        if (v < r && v >= l) LCT::makeroot(v);\n      bool flag = 1;\n      for (auto v : G[r])\n        if (v < r && v >= l && LCT::fa[v]) {\n          flag = 0;\n          break;\n        }\n      if (flag) break;\n      for (auto v : G[l])\n        if (v > l) LCT::cut(l, v);\n      ++l;\n    }\n    for (auto v : G[r])\n      if (v < r && v >= l) LCT::link(r, v);\n    SEG::modify(1, 1, n * m, 1, r, 1);\n    for (auto v : G[r])\n      if (v < r && v >= l) SEG::modify(1, 1, n * m, 1, v, -1);\n    ans += SEG::query(1, 1, n * m, l, r).second;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, total;\nnamespace LCT {\nint sta[200009];\nstruct data {\n  int ch[2], rev, f;\n} s[200009];\nint get(int x) { return s[s[x].f].ch[1] == x; }\nint isrt(int x) { return !(s[s[x].f].ch[0] == x || s[s[x].f].ch[1] == x); }\nvoid rotate(int x) {\n  int old = s[x].f, fold = s[old].f, which = get(x);\n  if (!isrt(old)) s[fold].ch[s[fold].ch[1] == old] = x;\n  s[old].ch[which] = s[x].ch[which ^ 1], s[s[old].ch[which]].f = old;\n  s[x].ch[which ^ 1] = old, s[old].f = x, s[x].f = fold;\n}\nvoid mark(int x) { swap(s[x].ch[0], s[x].ch[1]), s[x].rev ^= 1; }\nvoid pushdown(int x) {\n  if (s[x].rev) {\n    if (s[x].ch[0]) mark(s[x].ch[0]);\n    if (s[x].ch[1]) mark(s[x].ch[1]);\n    s[x].rev = 0;\n  }\n}\nvoid splay(int x) {\n  int u = x, v = 0, fa;\n  for (sta[++v] = u; !isrt(u); u = s[u].f) sta[++v] = s[u].f;\n  for (; v; --v) pushdown(sta[v]);\n  for (u = s[u].f; (fa = s[x].f) != u; rotate(x))\n    if (s[fa].f != u) rotate(get(fa) == get(x) ? fa : x);\n}\nvoid Access(int x) {\n  for (int y = 0; x; y = x, x = s[x].f) {\n    splay(x);\n    s[x].ch[1] = y;\n  }\n}\nvoid makert(int x) { Access(x), splay(x), mark(x); }\nint findrt(int x) {\n  Access(x), splay(x);\n  while (s[x].ch[0]) pushdown(x), x = s[x].ch[0];\n  return x;\n}\nvoid link(int x, int y) { makert(x), makert(y), s[y].f = x; }\nvoid cut(int x, int y) {\n  makert(x), Access(y), splay(y);\n  s[y].ch[0] = s[x].f = 0;\n}\n};  // namespace LCT\nnamespace seg {\nstruct node {\n  int mn, num_mn, sum;\n  node() { mn = num_mn = sum = 0; }\n  node operator+(const node &b) const {\n    node c;\n    c.sum = sum + b.sum;\n    c.mn = min(b.sum + mn, b.mn);\n    if (b.sum + mn == c.mn) c.num_mn += num_mn;\n    if (b.mn == c.mn) c.num_mn += b.num_mn;\n    return c;\n  }\n} s[200009 << 2];\nvoid build(int l, int r, int now) {\n  s[now].mn = 1000000;\n  if (l == r) {\n    s[now].mn = s[now].num_mn = s[now].sum = 1;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  build(l, mid, now << 1), build(mid + 1, r, now << 1 | 1);\n  s[now] = s[now << 1] + s[now << 1 | 1];\n}\nvoid update(int l, int r, int now, int p, int v) {\n  if (l == r) {\n    s[now].sum += v;\n    s[now].mn += v;\n    s[now].num_mn = 1;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  if (p <= mid)\n    update(l, mid, now << 1, p, v);\n  else\n    update(mid + 1, r, now << 1 | 1, p, v);\n  s[now] = s[now << 1] + s[now << 1 | 1];\n}\nnode query(int l, int r, int now, int L, int R) {\n  if (l >= L && r <= R) return s[now];\n  int mid = (l + r) >> 1;\n  if (L <= mid && R > mid)\n    return query(l, mid, now << 1, L, R) +\n           query(mid + 1, r, now << 1 | 1, L, R);\n  else if (L <= mid)\n    return query(l, mid, now << 1, L, R);\n  else\n    return query(mid + 1, r, now << 1 | 1, L, R);\n}\n};  // namespace seg\nint l, r;\nstruct Pos {\n  int x, y;\n  Pos(int x = 0, int y = 0) : x(x), y(y) {}\n} pos[2006 * 2006];\nint G[2006][2006];\nint go(int x, int y) {\n  if (y >= l && y <= r) {\n    if (LCT::findrt(x) == LCT::findrt(y))\n      return 1;\n    else {\n      LCT::link(x, y);\n      return 0;\n    }\n  } else\n    return 0;\n}\nvoid recover(int x, int y) {\n  if (y >= l && y <= r) {\n    if (LCT::findrt(x) == LCT::findrt(y)) LCT::cut(x, y);\n  }\n}\nint check(int x) {\n  int flag = 1;\n  int xx = pos[x].x, yy = pos[x].y;\n  if (xx - 1 >= 1 && go(x, G[xx - 1][yy])) flag = 0;\n  if (xx + 1 <= n && go(x, G[xx + 1][yy])) flag = 0;\n  if (yy - 1 >= 1 && go(x, G[xx][yy - 1])) flag = 0;\n  if (yy + 1 <= m && go(x, G[xx][yy + 1])) flag = 0;\n  recover(x, G[xx - 1][yy]);\n  recover(x, G[xx + 1][yy]);\n  recover(x, G[xx][yy - 1]);\n  recover(x, G[xx][yy + 1]);\n  return flag;\n}\nvoid update(int x, int y) {\n  if (y >= l && y <= r) {\n    LCT::cut(x, y);\n    seg::update(1, total, 1, x, 1);\n  }\n}\nvoid Del(int x) {\n  int xx = pos[x].x, yy = pos[x].y;\n  update(x, G[xx - 1][yy]);\n  update(x, G[xx + 1][yy]);\n  update(x, G[xx][yy - 1]);\n  update(x, G[xx][yy + 1]);\n}\nvoid rese(int x, int y) {\n  if (y >= l && y <= r) {\n    LCT::link(x, y);\n    seg::update(1, total, 1, y, -1);\n  }\n}\nvoid Add(int x) {\n  int xx = pos[x].x, yy = pos[x].y;\n  rese(x, G[xx - 1][yy]);\n  rese(x, G[xx + 1][yy]);\n  rese(x, G[xx][yy - 1]);\n  rese(x, G[xx][yy + 1]);\n}\nint main() {\n  int i, j;\n  long long ans = 0;\n  scanf(\"%d%d\", &n, &m), total = n * m;\n  seg::build(1, total, 1);\n  for (i = 1; i <= n; ++i)\n    for (j = 1; j <= m; ++j) scanf(\"%d\", &G[i][j]), pos[G[i][j]] = Pos(i, j);\n  for (l = r = 1; r <= total; ++r) {\n    while (!check(r)) {\n      Del(l), ++l;\n    }\n    Add(r);\n    seg::node p = seg::query(1, total, 1, l, r);\n    if (p.mn == 1) ans += (long long)p.num_mn;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline char gc() {\n  static char now[1 << 16], *S, *T;\n  if (T == S) {\n    T = (S = now) + fread(now, 1, 1 << 16, stdin);\n    if (T == S) return EOF;\n  }\n  return *S++;\n}\ninline long long read() {\n  register long long x = 0, f = 1;\n  char ch = gc();\n  while (!isdigit(ch)) {\n    if (ch == '-') f = -1;\n    ch = gc();\n  }\n  while (isdigit(ch)) {\n    x = (x << 3) + (x << 1) + ch - '0';\n    ch = gc();\n  }\n  return (f == 1) ? x : -x;\n}\nint n, m, a[303030], pre[302020][2];\nconst int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\ninline int id(int x, int y) { return (x - 1) * m + y; }\nstruct LCT {\n  struct node {\n    int son[2], fa;\n    bool tag;\n  } g[303030];\n  inline void reverse(int rt) {\n    g[rt].tag ^= 1;\n    swap(g[rt].son[0], g[rt].son[1]);\n  }\n  inline void pushdown(int rt) {\n    if (g[rt].tag) {\n      if (g[rt].son[0]) reverse(g[rt].son[0]);\n      if (g[rt].son[1]) reverse(g[rt].son[1]);\n      g[rt].tag = 0;\n    }\n  }\n  inline bool wtson(int rt) { return (g[g[rt].fa].son[0] == rt ? 0 : 1); }\n  inline bool isrt(int rt) {\n    return (g[g[rt].fa].son[0] != rt && g[g[rt].fa].son[1] != rt);\n  }\n  inline void rotate(int rt) {\n    int fa = g[rt].fa, fafa = g[fa].fa, wht = wtson(rt),\n        son = g[rt].son[wht ^ 1], whtfa = wtson(fa);\n    g[rt].fa = fafa;\n    if (fafa && !isrt(fa)) g[fafa].son[whtfa] = rt;\n    g[rt].son[wht ^ 1] = fa, g[fa].fa = rt;\n    g[fa].son[wht] = son, g[son].fa = fa;\n  }\n  int sta[303030], top;\n  inline void splay(int rt) {\n    sta[top = 1] = rt;\n    for (int i = rt; !isrt(i); i = g[i].fa) sta[++top] = g[i].fa;\n    for (; top; top--) pushdown(sta[top]);\n    while (!isrt(rt)) {\n      int fa = g[rt].fa;\n      if (isrt(fa))\n        rotate(rt);\n      else if (wtson(rt) == wtson(fa)) {\n        rotate(fa), rotate(rt);\n      } else {\n        rotate(rt), rotate(rt);\n      }\n    }\n  }\n  inline void access(int rt) {\n    for (int x = rt, y = 0; x; x = g[y = x].fa) {\n      splay(x), g[x].son[1] = y;\n    }\n  }\n  inline void makert(int rt) { access(rt), splay(rt), reverse(rt); }\n  inline int findrt(int rt) {\n    access(rt), splay(rt);\n    while (g[rt].son[0]) pushdown(rt), rt = g[rt].son[0];\n    int ans = rt;\n    splay(rt);\n    return ans;\n  }\n  inline void link(int x, int y) {\n    makert(y);\n    if (findrt(x) != y) g[y].fa = x;\n  }\n  inline void cut(int x, int y) {\n    swap(x, y);\n    makert(y), access(x), splay(x);\n    if (g[y].fa == x && g[x].son[0] == y) {\n      g[y].fa = g[x].son[0] = 0;\n    }\n  }\n  inline bool query(int x, int y) { return (findrt(x) == findrt(y)); }\n} T;\nbool vis[303030];\nint seg[1202020], cnt[1202020], ncir[303030], tag[1202020];\ninline void pushup(int rt) {\n  if (seg[rt << 1] == seg[rt << 1 | 1])\n    cnt[rt] = cnt[rt << 1] + cnt[rt << 1 | 1];\n  else if (seg[rt << 1] < seg[rt << 1 | 1])\n    cnt[rt] = cnt[rt << 1];\n  else\n    cnt[rt] = cnt[rt << 1 | 1];\n  seg[rt] = min(seg[rt << 1], seg[rt << 1 | 1]);\n}\ninline void pushdown(int rt) {\n  if (tag[rt]) {\n    seg[rt << 1] += tag[rt];\n    tag[rt << 1] += tag[rt];\n    seg[rt << 1 | 1] += tag[rt];\n    tag[rt << 1 | 1] += tag[rt];\n    tag[rt] = 0;\n  }\n}\nvoid build(int rt, int lb, int rb) {\n  if (lb == rb) return (void)(cnt[rt] = 1);\n  build(rt << 1, lb, ((lb + rb) >> 1));\n  build(rt << 1 | 1, ((lb + rb) >> 1) + 1, rb);\n  pushup(rt);\n}\nvoid update(int rt, int lb, int rb, int l, int r, int w) {\n  if (lb > r || rb < l) return;\n  if (lb >= l && rb <= r) return (void)(seg[rt] += w, tag[rt] += w);\n  pushdown(rt);\n  update(rt << 1, lb, ((lb + rb) >> 1), l, r, w),\n      update(rt << 1 | 1, ((lb + rb) >> 1) + 1, rb, l, r, w);\n  pushup(rt);\n}\nint query(int rt, int lb, int rb, int l, int r) {\n  if (lb > r || rb < l) return 0;\n  if (lb >= l && rb <= r) return (seg[rt] == 1 ? cnt[rt] : 0);\n  pushdown(rt);\n  return query(rt << 1, lb, ((lb + rb) >> 1), l, r) +\n         query(rt << 1 | 1, ((lb + rb) >> 1) + 1, rb, l, r);\n}\nsigned main() {\n  n = read(), m = read();\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      int x = read();\n      a[id(i, j)] = x;\n      pre[x][0] = i, pre[x][1] = j;\n    }\n  }\n  ncir[1] = vis[id(pre[1][0], pre[1][1])] = 1;\n  int i, j, x, y, xx, yy, X, Y, XX, YY, K, k;\n  for (i = 2, j = 1; i <= n * m; i++) {\n    vis[id(pre[i][0], pre[i][1])] = 1;\n    for (k = 0; k < 4; k++) {\n      x = pre[i][0], y = pre[i][1], xx = x + dx[k], yy = y + dy[k];\n      if (xx < 1 || yy < 1 || xx > n || yy > m || !vis[id(xx, yy)]) continue;\n      while (T.query(id(xx, yy), id(x, y))) {\n        vis[id(pre[j][0], pre[j][1])] = 0;\n        for (K = 0; K < 4; K++) {\n          X = pre[j][0], Y = pre[j][1], XX = X + dx[K], YY = Y + dy[K];\n          if (XX < 1 || YY < 1 || XX > n || YY > m || !vis[id(XX, YY)])\n            continue;\n          T.cut(id(XX, YY), id(X, Y));\n        }\n        j++;\n      }\n      T.link(id(xx, yy), id(x, y));\n    }\n    ncir[i] = j;\n  }\n  long long ans = 0;\n  build(1, 1, n * m);\n  for (int i = 1; i <= n * m; i++) {\n    update(1, 1, n * m, 1, i, 1);\n    for (k = 0; k < 4; k++) {\n      x = pre[i][0], y = pre[i][1], xx = x + dx[k], yy = y + dy[k];\n      if (xx < 1 || yy < 1 || xx > n || yy > m) continue;\n      if (a[id(xx, yy)] < i) {\n        update(1, 1, n * m, 1, a[id(xx, yy)], -1);\n      }\n    }\n    ans += query(1, 1, n * m, ncir[i], i);\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 2147483647;\nconst int N = 200001;\nint _max(int x, int y) { return x > y ? x : y; }\nint _min(int x, int y) { return x < y ? x : y; }\ninline int read() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9')\n    x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n  return x * f;\n}\nvoid put(long long x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x >= 10) put(x / 10);\n  putchar(x % 10 + '0');\n}\nstruct node {\n  int x, y;\n} a[N];\nstruct LCT {\n  int fa[N], son[N][2], rev[N];\n  int tp, sta[N];\n  bool Son(int x) { return son[fa[x]][1] == x; }\n  bool isroot(int x) { return son[fa[x]][0] != x && son[fa[x]][1] != x; }\n  void reve(int x) { rev[x] ^= 1, swap(son[x][0], son[x][1]); }\n  void pushdown(int x) {\n    if (!rev[x]) return;\n    reve(son[x][0]), reve(son[x][1]), rev[x] = 0;\n  }\n  void rot(int x) {\n    int y = fa[x], z = fa[y], c = Son(x);\n    if (!isroot(y)) son[z][Son(y)] = x;\n    fa[x] = z;\n    son[y][c] = son[x][!c];\n    if (son[y][c]) fa[son[y][c]] = y;\n    son[x][!c] = y, fa[y] = x;\n  }\n  void splay(int x) {\n    int i = x;\n    while (!isroot(i)) sta[++tp] = i, i = fa[i];\n    sta[++tp] = i;\n    while (tp) pushdown(sta[tp--]);\n    for (int y = fa[x]; !isroot(x); rot(x), y = fa[x]) {\n      if (!isroot(y)) Son(x) ^ Son(y) ? rot(x) : rot(y);\n    }\n  }\n  void access(int x) {\n    for (int y = 0; x; y = x, x = fa[x]) splay(x), son[x][1] = y;\n  }\n  void makeroot(int x) { access(x), splay(x), reve(x); }\n  int findroot(int x) {\n    access(x), splay(x);\n    while (1) {\n      pushdown(x);\n      if (!son[x][0]) break;\n      x = son[x][0];\n    }\n    return x;\n  }\n  bool check(int x, int y) {\n    int fx = findroot(x), fy = findroot(y);\n    return fx == fy;\n  }\n  bool Link(int x, int y) {\n    if (check(x, y)) return 1;\n    makeroot(x), fa[x] = y;\n    return 0;\n  }\n  void Cut(int x, int y) {\n    if (!check(x, y)) return;\n    makeroot(x), access(y), splay(y);\n    son[y][0] = fa[x] = 0;\n  }\n} t;\nint S[N];\nstruct tnode {\n  int cnt, lc[N << 1], rc[N << 1], c[N << 1], s[N << 1], lazy[N << 1];\n  void pushup(int now) {\n    c[now] = _min(c[lc[now]], c[rc[now]]);\n    if (c[lc[now]] == c[rc[now]])\n      s[now] = s[lc[now]] + s[rc[now]];\n    else if (c[lc[now]] < c[rc[now]])\n      s[now] = s[lc[now]];\n    else\n      s[now] = s[rc[now]];\n  }\n  void bt(int l, int r) {\n    int now = ++cnt;\n    lc[now] = rc[now] = -1;\n    if (l == r)\n      c[now] = l - S[l], s[now] = 1;\n    else {\n      int mid = (l + r) / 2;\n      lc[now] = cnt + 1;\n      bt(l, mid);\n      rc[now] = cnt + 1;\n      bt(mid + 1, r);\n      pushup(now);\n    }\n  }\n  void pushdown(int now) {\n    if (lazy[now]) {\n      c[lc[now]] += lazy[now];\n      c[rc[now]] += lazy[now];\n      lazy[lc[now]] += lazy[now];\n      lazy[rc[now]] += lazy[now];\n      lazy[now] = 0;\n    }\n  }\n  void change(int now, int l, int r, int ll, int rr) {\n    if (l == ll && r == rr) {\n      c[now]++, lazy[now]++;\n      return;\n    }\n    pushdown(now);\n    int mid = (l + r) / 2;\n    if (rr <= mid)\n      change(lc[now], l, mid, ll, rr);\n    else if (ll > mid)\n      change(rc[now], mid + 1, r, ll, rr);\n    else\n      change(lc[now], l, mid, ll, mid),\n          change(rc[now], mid + 1, r, mid + 1, rr);\n    pushup(now);\n  }\n  int query(int now, int l, int r, int ll, int rr) {\n    if (l == ll && r == rr) return c[now] == 1 ? s[now] : 0;\n    pushdown(now);\n    int mid = (l + r) / 2;\n    if (rr <= mid)\n      return query(lc[now], l, mid, ll, rr);\n    else if (ll > mid)\n      return query(rc[now], mid + 1, r, ll, rr);\n    else\n      return query(lc[now], l, mid, ll, mid) +\n             query(rc[now], mid + 1, r, mid + 1, rr);\n  }\n} tt;\nint n, m, p[N];\nint zz, te[N];\nint getid(int x, int y) { return (x - 1) * m + y; }\nbool gao(int l, int r, int x, int y, int c) {\n  int o = -1;\n  bool ch = 0;\n  zz = 0;\n  if (x > 1) o = p[getid(x - 1, y)];\n  if (o >= l && o <= r) ch |= t.Link(o, c), te[++zz] = o;\n  o = -1;\n  if (y > 1) o = p[getid(x, y - 1)];\n  if (o >= l && o <= r) ch |= t.Link(o, c), te[++zz] = o;\n  o = -1;\n  if (x < n) o = p[getid(x + 1, y)];\n  if (o >= l && o <= r) ch |= t.Link(o, c), te[++zz] = o;\n  o = -1;\n  if (y < m) o = p[getid(x, y + 1)];\n  if (o >= l && o <= r) ch |= t.Link(o, c), te[++zz] = o;\n  o = -1;\n  if (ch)\n    for (int i = 1; i <= zz; i++) t.Cut(c, te[i]);\n  return ch;\n}\nvoid del(int l, int r, int x, int y, int c) {\n  int o = -1;\n  if (x > 1) o = p[getid(x - 1, y)];\n  if (o >= l && o <= r) t.Cut(c, o);\n  if (o > c) tt.change(1, 1, n * m, o, n * m);\n  o = -1;\n  if (y > 1) o = p[getid(x, y - 1)];\n  if (o >= l && o <= r) t.Cut(c, o);\n  if (o > c) tt.change(1, 1, n * m, o, n * m);\n  o = -1;\n  if (x < n) o = p[getid(x + 1, y)];\n  if (o >= l && o <= r) t.Cut(c, o);\n  if (o > c) tt.change(1, 1, n * m, o, n * m);\n  o = -1;\n  if (y < m) o = p[getid(x, y + 1)];\n  if (o >= l && o <= r) t.Cut(c, o);\n  if (o > c) tt.change(1, 1, n * m, o, n * m);\n  o = -1;\n}\nint gg(int x, int y, int c) {\n  int o = -1, ans = 0;\n  if (x > 1) o = p[getid(x - 1, y)];\n  if (o != -1 && o <= c) ans++;\n  o = -1;\n  if (y > 1) o = p[getid(x, y - 1)];\n  if (o != -1 && o <= c) ans++;\n  o = -1;\n  if (x < n) o = p[getid(x + 1, y)];\n  if (o != -1 && o <= c) ans++;\n  o = -1;\n  if (y < m) o = p[getid(x, y + 1)];\n  if (o != -1 && o <= c) ans++;\n  o = -1;\n  return ans;\n}\nint main() {\n  n = read(), m = read();\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) {\n      int x = read();\n      p[getid(i, j)] = x, a[x] = node{i, j};\n    }\n  int tp = 1;\n  long long ans = 0;\n  for (int i = 1; i <= n * m; i++) S[i] = S[i - 1] + gg(a[i].x, a[i].y, i);\n  tt.bt(1, n * m);\n  for (int i = 1; i <= n * m; i++) {\n    tp = _max(tp, i);\n    while (tp < n * m && !gao(i, tp + 1, a[tp + 1].x, a[tp + 1].y, tp + 1))\n      tp++;\n    ans += tt.query(1, 1, n * m, i, tp);\n    del(i, tp, a[i].x, a[i].y, i);\n    tt.lazy[1]--, tt.c[1]--;\n  }\n  put(ans), puts(\"\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct err_stream {\n  template <typename T>\n  err_stream& operator<<(T x) {\n    return *this;\n  }\n};\nconst int MAXN = 200007;\nint N, R, C;\nint rev[MAXN], par[MAXN], ch[MAXN][2], st[MAXN], top;\nbool dir(int x) { return x == ch[par[x]][1]; }\nbool isroot(int x) { return x != ch[par[x]][dir(x)]; }\nvoid pushdown(int x) {\n  if (rev[x]) {\n    swap(ch[x][0], ch[x][1]);\n    rev[ch[x][0]] ^= 1;\n    rev[ch[x][1]] ^= 1;\n    rev[x] = 0;\n  }\n}\nvoid rot(int x) {\n  int p = par[x], d = dir(x);\n  if (!isroot(p)) ch[par[p]][dir(p)] = x;\n  par[x] = par[p];\n  par[ch[p][d] = ch[x][!d]] = p;\n  par[ch[x][!d] = p] = x;\n}\nvoid splay(int x) {\n  st[top = 1] = x;\n  for (int u = x; !isroot(u); u = par[u]) st[++top] = par[u];\n  while (top) pushdown(st[top--]);\n  for (; !isroot(x); rot(x))\n    if (!isroot(par[x])) rot(dir(x) == dir(par[x]) ? par[x] : x);\n}\nvoid access(int x) {\n  for (int y = 0; x; y = x, x = par[y]) {\n    splay(x);\n    ch[x][1] = y;\n  }\n}\nvoid make_root(int x) {\n  access(x);\n  splay(x);\n  rev[x] ^= 1;\n}\nbool link(int x, int y) {\n  make_root(x);\n  access(y);\n  splay(y);\n  err_stream() << \"link: \" << x << ' ' << y << ' ' << par[x] << '\\n';\n  if (par[x]) return false;\n  par[x] = y;\n  return true;\n}\nbool cut(int x, int y) {\n  make_root(x);\n  access(y);\n  splay(y);\n  err_stream() << \"cut: \" << x << ' ' << y << \": \" << par[x] << ' ' << ch[y][0]\n               << '\\n';\n  if (par[x] != y || ch[x][1]) return false;\n  ch[y][0] = par[x] = 0;\n  return true;\n}\nint mn[MAXN << 2], cnt[MAXN << 2], inc[MAXN << 2];\nvoid push(int rt, int lo, int hi) {\n  if (lo < hi && inc[rt]) {\n    mn[rt << 1] += inc[rt];\n    mn[rt << 1 | 1] += inc[rt];\n    inc[rt << 1] += inc[rt];\n    inc[rt << 1 | 1] += inc[rt];\n    inc[rt] = 0;\n  }\n}\nvoid pull(int rt) {\n  mn[rt] = min(mn[rt << 1], mn[rt << 1 | 1]);\n  cnt[rt] = (mn[rt] == mn[rt << 1]) * cnt[rt << 1] +\n            (mn[rt] == mn[rt << 1 | 1]) * cnt[rt << 1 | 1];\n}\nvoid upd(int l, int r, int x, int rt = 1, int lo = 1, int hi = N) {\n  if (hi < l || r < lo) return;\n  if (l <= lo && hi <= r) {\n    mn[rt] += x, inc[rt] += x;\n    return;\n  }\n  int md = (lo + hi) >> 1;\n  push(rt, lo, hi);\n  upd(l, r, x, rt << 1, lo, md);\n  upd(l, r, x, rt << 1 | 1, md + 1, hi);\n  pull(rt);\n}\nint get(int l, int r, int rt = 1, int lo = 1, int hi = N) {\n  if (hi < l || r < lo) return 0;\n  if (l <= lo && hi <= r) return (!mn[rt]) * cnt[rt];\n  int md = (lo + hi) >> 1;\n  push(rt, lo, hi);\n  return get(l, r, rt << 1, lo, md) + get(l, r, rt << 1 | 1, md + 1, hi);\n}\nvoid build(int rt = 1, int lo = 1, int hi = N) {\n  if (lo == hi) {\n    mn[rt] = lo, cnt[rt] = 1;\n    return;\n  }\n  int md = (lo + hi) >> 1;\n  build(rt << 1, lo, md);\n  build(rt << 1 | 1, md + 1, hi);\n  pull(rt);\n}\nconst int dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1};\nbool valid(int i, int j) { return 0 <= i && i < R && 0 <= j && j < C; }\nvector<vector<int>> A;\nvector<pair<int, int>> add, rem;\npair<int, int> pos[MAXN];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> R >> C;\n  N = R * C;\n  A.assign(R, vector<int>(C));\n  for (int i = 0; i < R; ++i) {\n    for (int j = 0; j < C; ++j) {\n      cin >> A[i][j];\n      pos[A[i][j]] = make_pair(i, j);\n    }\n  }\n  int E = (R - 1) * C + R * (C - 1);\n  add.reserve(E);\n  rem.reserve(E);\n  for (int x = 1; x <= N; ++x) {\n    int i = pos[x].first, j = pos[x].second;\n    for (int d = 0; d < 4; ++d) {\n      int i0 = i + dx[d], j0 = j + dy[d];\n      if (valid(i0, j0)) {\n        if (A[i0][j0] > x) {\n          rem.emplace_back(x, A[i0][j0]);\n        } else {\n          add.emplace_back(x, A[i0][j0]);\n        }\n      }\n    }\n  }\n  build();\n  int64_t ans = 0;\n  for (int l = 1, i = 0, j = 0; l <= N; ++l) {\n    upd(l, N, -1);\n    for (; i < E; ++i) {\n      if (add[i].second >= l) {\n        if (link(add[i].first, add[i].second)) {\n          err_stream() << \"Y\" << '\\n';\n          upd(add[i].first, N, -1);\n        } else {\n          break;\n        }\n      }\n    }\n    int r = (i == E ? N + 1 : add[i].first);\n    ans += get(l, r - 1);\n    err_stream() << \"S \" << r << ' ' << get(l, r - 1) << '\\n';\n    for (; j < E && rem[j].first == l; ++j) {\n      if (cut(rem[j].first, rem[j].second)) {\n        err_stream() << \"Y\" << '\\n';\n        upd(rem[j].second, N, 1);\n      }\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\nnamespace io {\nconst int L = (1 << 20) + 1;\nchar buf[L], *S, *T, c;\nchar getchar() {\n  if (__builtin_expect(S == T, 0)) {\n    T = (S = buf) + fread(buf, 1, L, stdin);\n    return (S == T ? EOF : *S++);\n  }\n  return *S++;\n}\nint inp() {\n  int x = 0, f = 1;\n  char ch;\n  for (ch = getchar(); !isdigit(ch); ch = getchar())\n    if (ch == '-') f = -1;\n  for (; isdigit(ch); x = x * 10 + ch - '0', ch = getchar())\n    ;\n  return x * f;\n}\nunsigned inpu() {\n  unsigned x = 0;\n  char ch;\n  for (ch = getchar(); !isdigit(ch); ch = getchar())\n    ;\n  for (; isdigit(ch); x = x * 10 + ch - '0', ch = getchar())\n    ;\n  return x;\n}\nlong long inp_ll() {\n  long long x = 0;\n  int f = 1;\n  char ch;\n  for (ch = getchar(); !isdigit(ch); ch = getchar())\n    if (ch == '-') f = -1;\n  for (; isdigit(ch); x = x * 10 + ch - '0', ch = getchar())\n    ;\n  return x * f;\n}\nchar B[25], *outs = B + 20, *outr = B + 20;\ntemplate <class T>\ninline void print(register T a, register char x = 0) {\n  if (x) *--outs = x, x = 0;\n  if (!a)\n    *--outs = '0';\n  else\n    while (a) *--outs = (a % 10) + 48, a /= 10;\n  if (x) *--outs = x;\n  fwrite(outs, outr - outs, 1, stdout);\n  outs = outr;\n}\n};  // namespace io\nusing io ::inp;\nusing io ::inp_ll;\nusing io ::inpu;\nusing io ::print;\nusing i32 = int;\nusing i64 = long long;\nusing u8 = unsigned char;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing f64 = double;\nusing f80 = long double;\nlong long power(long long a, long long b, long long p) {\n  if (!b) return 1;\n  long long t = power(a, b / 2, p);\n  t = t * t % p;\n  if (b & 1) t = t * a % p;\n  return t;\n}\nlong long exgcd(long long a, long long b, long long &x, long long &y) {\n  if (b == 0) {\n    x = 1;\n    y = 0;\n    return a;\n  }\n  long long px, py;\n  long long d = exgcd(b, a % b, px, py);\n  x = py;\n  y = px - a / b * py;\n  return d;\n}\ntemplate <class T>\ninline void freshmin(T &a, const T &b) {\n  if (a > b) a = b;\n}\ntemplate <class T>\ninline void freshmax(T &a, const T &b) {\n  if (a < b) a = b;\n}\nconst int MAXN = 200010;\nconst int MOD = 1000000009;\nconst f80 MI = f80(1) / MOD;\nconst int INF = 1000000000;\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\nstruct node {\n  node *pre, *son[2];\n  int rev;\n} nodes[MAXN];\nnode *nil = nodes;\nstruct LinkCutTree {\n  void init(int n) {\n    nil->pre = nil->son[0] = nil->son[1] = nil;\n    nil->rev = 0;\n    for (int i = 1; i <= n; ++i) {\n      nodes[i].pre = nodes[i].son[0] = nodes[i].son[1] = nil;\n      nodes[i].rev = 0;\n    }\n  }\n  bool is_root(node *x) { return x->pre->son[0] != x && x->pre->son[1] != x; }\n  void reverse(node *x) {\n    if (x != nil) {\n      x->rev ^= 1;\n      swap(x->son[0], x->son[1]);\n    }\n  }\n  void clear(node *x) {\n    if (x->rev) {\n      reverse(x->son[0]);\n      reverse(x->son[1]);\n      x->rev = 0;\n    }\n  }\n  void update(node *x) {}\n  void rotate(node *x) {\n    node *y = x->pre, *z = y->pre;\n    int p = y->son[1] == x, q = p ^ 1;\n    if (!is_root(y)) z->son[z->son[1] == y] = x;\n    x->pre = z;\n    y->pre = x;\n    if (x->son[q]) x->son[q]->pre = y;\n    y->son[p] = x->son[q];\n    x->son[q] = y;\n    update(y);\n    update(x);\n  }\n  void splay(node *x) {\n    static node *q[MAXN];\n    int top = 0;\n    node *it = x;\n    for (; !is_root(it); it = it->pre) q[++top] = it;\n    q[++top] = it;\n    for (int i = top; i >= 1; --i) clear(q[i]);\n    while (!is_root(x)) {\n      node *y = x->pre, *z = y->pre;\n      if (!is_root(y)) rotate((y->son[0] == x) ^ (z->son[0] == y) ? x : y);\n      rotate(x);\n    }\n  }\n  void access(node *x0) {\n    for (node *x = x0, *y = nil; x != nil; x = x->pre) {\n      splay(x);\n      x->son[1] = y;\n      y = x;\n    }\n    splay(x0);\n  }\n  node *belong(node *x) {\n    access(x);\n    for (; x->son[0] != nil; x = x->son[0])\n      ;\n    splay(x);\n    return x;\n  }\n  bool check(node *x, node *y) {\n    node *fx = belong(x);\n    node *fy = belong(y);\n    return fx == fy;\n  }\n  void link(node *x, node *y) {\n    access(x);\n    reverse(x);\n    x->pre = y;\n  }\n  void cut(node *x, node *y) {\n    access(y);\n    splay(x);\n    if (x->pre == y)\n      x->pre = nil;\n    else {\n      access(x);\n      splay(y);\n      if (y->pre == x) y->pre = nil;\n    }\n  }\n  bool check(int x, int y) { return check(nodes + x, nodes + y); }\n  void link(int x, int y) { link(nodes + x, nodes + y); }\n  bool try_link(int x, int y) {\n    if (check(x, y)) return 1;\n    link(x, y);\n    return 0;\n  }\n  void cut(int x, int y) { cut(nodes + x, nodes + y); }\n} T;\nint n, m;\nint a[MAXN];\nvector<int> v[MAXN];\nint place(int i, int j) { return (i - 1) * m + j; }\nstruct segtree {\n  int add, min, cnt;\n} tree[MAXN * 4];\nvoid clear(int k) {\n  if (tree[k].add) {\n    tree[k << 1].add += tree[k].add;\n    tree[k << 1].min += tree[k].add;\n    tree[k << 1 | 1].add += tree[k].add;\n    tree[k << 1 | 1].min += tree[k].add;\n    tree[k].add = 0;\n  }\n}\nvoid update(int k) {\n  tree[k].min = min(tree[k << 1].min, tree[k << 1 | 1].min);\n  tree[k].cnt = (tree[k << 1].min == tree[k].min) * tree[k << 1].cnt +\n                (tree[k << 1 | 1].min == tree[k].min) * tree[k << 1 | 1].cnt;\n}\nvoid build(int k, int L, int R) {\n  if (L == R) {\n    tree[k].add = 0;\n    tree[k].min = 0;\n    tree[k].cnt = 1;\n    return;\n  }\n  int m = (L + R) / 2;\n  build(k << 1, L, m);\n  build(k << 1 | 1, m + 1, R);\n  update(k);\n}\nvoid add(int k, int L, int R, int x, int y, int p) {\n  if (L == x && R == y) {\n    tree[k].add += p;\n    tree[k].min += p;\n    return;\n  }\n  clear(k);\n  int m = (L + R) / 2;\n  if (y <= m)\n    add(k << 1, L, m, x, y, p);\n  else if (x > m)\n    add(k << 1 | 1, m + 1, R, x, y, p);\n  else {\n    add(k << 1, L, m, x, m, p);\n    add(k << 1 | 1, m + 1, R, m + 1, y, p);\n  }\n  update(k);\n}\npair<int, int> query(int k, int L, int R, int x, int y) {\n  if (L == x && R == y) return pair<int, int>(tree[k].min, tree[k].cnt);\n  clear(k);\n  int m = (L + R) / 2;\n  if (y <= m) return query(k << 1, L, m, x, y);\n  if (x > m) return query(k << 1 | 1, m + 1, R, x, y);\n  auto lans = query(k << 1, L, m, x, m);\n  auto rans = query(k << 1 | 1, m + 1, R, m + 1, y);\n  return pair<int, int>(min(lans.first, rans.first),\n                        (lans.first <= rans.first) * lans.second +\n                            (lans.first >= rans.first) * rans.second);\n}\nint main() {\n  n = inp();\n  m = inp();\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j) a[place(i, j)] = inp();\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n      for (int d = 0; d < 4; ++d) {\n        int x = i + dx[d], y = j + dy[d];\n        if (1 <= x && x <= n && 1 <= y && y <= m)\n          v[a[place(i, j)]].push_back(a[place(x, y)]);\n      }\n  long long ans = 0;\n  T.init(n * m);\n  build(1, 1, n * m);\n  for (int i = 1, j = 1; i <= n * m; ++i) {\n    while (1) {\n      int flag = 0;\n      for (auto x : v[i])\n        if (j <= x && x < i) flag |= T.try_link(x, i);\n      if (!flag) break;\n      for (auto x : v[i])\n        if (j <= x && x < i) T.cut(x, i);\n      for (auto x : v[j]) T.cut(x, j);\n      j++;\n    }\n    add(1, 1, n * m, j, i, 1);\n    for (auto x : v[i])\n      if (j <= x && x < i) add(1, 1, n * m, j, x, -1);\n    auto ret = query(1, 1, n * m, j, i);\n    if (ret.first == 1) ans += ret.second;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 5, MAXM = 1e3 + 5, tx[] = {1, -1, 0, 0},\n          ty[] = {0, 0, 1, -1};\nchar buf[1 << 12], *pp1 = buf, *pp2 = buf, nc;\nint ny;\ninline char gc() {\n  return pp1 == pp2 &&\n                 (pp2 = (pp1 = buf) + fread(buf, 1, 1 << 12, stdin), pp1 == pp2)\n             ? EOF\n             : *pp1++;\n}\ninline int read() {\n  int x = 0;\n  for (ny = 1; nc = gc(), (nc < 48 || nc > 57) && nc != EOF;)\n    if (nc == 45) ny = -1;\n  if (nc < 0) return nc;\n  for (x = nc - 48; nc = gc(), 47 < nc && nc < 58 && nc != EOF;\n       x = (x << 3) + (x << 1) + (nc ^ 48))\n    ;\n  return x * ny;\n}\nint n, m, tot, l, r, a[MAXM][MAXM], id[MAXM][MAXM];\npair<int, int> pos[MAXN];\nnamespace Lct {\nint fa[MAXN], s[2][MAXN], lazy[MAXN], stk[MAXN];\ninline bool nroot(int x) { return s[0][fa[x]] == x || s[1][fa[x]] == x; }\ninline void pushr(int x) { lazy[x] ^= 1, swap(s[0][x], s[1][x]); }\ninline void pushdown(int x) {\n  if (lazy[x]) pushr(s[0][x]), pushr(s[1][x]), lazy[x] = 0;\n}\ninline void Pushdown(int x) {\n  int y = x, z = 0;\n  stk[++z] = y;\n  for (; nroot(y); stk[++z] = y = fa[y])\n    ;\n  for (; z; pushdown(stk[z--]))\n    ;\n}\ninline void Rotate(int x) {\n  int y = fa[x], z = fa[y], d = s[1][y] == x;\n  fa[s[d][y] = s[d ^ 1][x]] = y, fa[x] = z;\n  if (nroot(y)) s[s[1][z] == y][z] = x;\n  fa[y] = x, s[d ^ 1][x] = y;\n}\ninline void Splay(int x) {\n  Pushdown(x);\n  for (int y = fa[x]; nroot(x); Rotate(x), y = fa[x])\n    if (nroot(y)) Rotate(s[0][y] == x ^ s[0][fa[y]] == y ? x : y);\n}\ninline void Access(int x) {\n  for (int y = 0; x; x = fa[y = x]) Splay(x), s[1][x] = y;\n}\ninline void MakeRt(int x) { Access(x), Splay(x), pushr(x); }\ninline int FindRt(int x) {\n  Access(x), Splay(x);\n  for (; s[0][x]; pushdown(x), x = s[0][x])\n    ;\n  Splay(x);\n  return x;\n}\ninline void Link(int x, int y) {\n  MakeRt(x);\n  if (FindRt(y) != x) fa[x] = y;\n}\ninline void Cut(int x, int y) {\n  MakeRt(x);\n  if (FindRt(y) == x && fa[y] == x && !s[0][y]) fa[y] = s[1][x] = 0;\n}\n}  // namespace Lct\ninline bool check(int x, int y) { return Lct::FindRt(x) == Lct::FindRt(y); }\ninline void del(int t) {\n  int x = pos[t].first, y = pos[t].second;\n  for (int k = 0; k < 4; k++) {\n    int px = x + tx[k], py = y + ty[k];\n    if (!id[px][py]) continue;\n    if (a[px][py] <= r && a[px][py] >= l) Lct::Cut(id[x][y], id[px][py]);\n  }\n}\ninline void Merge(int x, int y) { Lct::Link(x, y); }\nnamespace SegTree {\nint Min[MAXN << 2], cnt[MAXN << 2], t[MAXN << 2];\ninline void pushup(int x) {\n  Min[x] = min(Min[x << 1], Min[x << 1 | 1]), cnt[x] = 0,\n  Min[x] == Min[x << 1] ? cnt[x] += cnt[x << 1] : 0,\n  Min[x] == Min[x << 1 | 1] ? cnt[x] += cnt[x << 1 | 1] : 0;\n}\ninline void pushr(int x, int v) { Min[x] += v, t[x] += v; }\ninline void pushdown(int x) {\n  if (t[x]) pushr(x << 1, t[x]), pushr(x << 1 | 1, t[x]), t[x] = 0;\n}\ninline void add(int x, int l, int r, int ql, int qr, int v) {\n  if (ql <= l && r <= qr) return pushr(x, v);\n  int mid = l + r >> 1;\n  pushdown(x);\n  if (ql <= mid) add(x << 1, l, mid, ql, qr, v);\n  if (qr > mid) add(x << 1 | 1, mid + 1, r, ql, qr, v);\n  pushup(x);\n}\ninline int ask(int x, int l, int r, int ql, int qr) {\n  if (Min[x] > 1) return 0;\n  if (ql <= l && r <= qr) return Min[x] == 1 ? cnt[x] : 0;\n  int mid = l + r >> 1, res = 0;\n  pushdown(x);\n  if (ql <= mid) res += ask(x << 1, l, mid, ql, qr);\n  if (qr > mid) res += ask(x << 1 | 1, mid + 1, r, ql, qr);\n  return res;\n}\ninline void build(int x, int l, int r) {\n  Min[x] = 0, cnt[x] = r - l + 1;\n  if (l == r) return;\n  int mid = l + r >> 1;\n  build(x << 1, l, mid), build(x << 1 | 1, mid + 1, r);\n}\n}  // namespace SegTree\nint main() {\n  n = read(), m = read();\n  for (int i = (1); i <= (n); i++)\n    for (int j = (1); j <= (m); j++) id[i][j] = ++tot;\n  for (int i = (1); i <= (n); i++)\n    for (int j = (1); j <= (m); j++) pos[a[i][j] = read()] = make_pair(i, j);\n  long long ans = 0;\n  SegTree::build(1, 1, n * m);\n  for (l = 1, r = 1; r <= n * m; r++) {\n    int x = pos[r].first, y = pos[r].second;\n    for (int k = 0; k < 4; k++) {\n      int px = x + tx[k], py = y + ty[k];\n      if (!id[px][py]) continue;\n      if (a[px][py] <= r && a[px][py] >= l)\n        for (; a[px][py] >= l && l < r && check(id[px][py], id[x][y]);\n             del(l), l++)\n          ;\n      if (a[px][py] <= r && a[px][py] >= l) Merge(id[x][y], id[px][py]);\n    }\n    SegTree::add(1, 1, n * m, l, r, 1);\n    for (int k = 0; k < 4; k++) {\n      int px = x + tx[k], py = y + ty[k];\n      if (!id[px][py]) continue;\n      if (a[px][py] <= r && a[px][py] >= l)\n        SegTree::add(1, 1, n * m, l, a[px][py], -1);\n    }\n    ans += SegTree::ask(1, 1, n * m, l, r);\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int INF = 1e9 + 100;\nstruct ND {\n public:\n  int m, c, z;\n  ND operator+(const ND& o) const {\n    if (o.m == m) return {m, c + o.c, 0};\n    if (o.m < m)\n      return {o.m, o.c, 0};\n    else\n      return {m, c, 0};\n  }\n};\ntemplate <int MS>\nstruct ST {\n public:\n  ND v[MS];\n  int s;\n  void init(int n, int l, int r) {\n    v[n] = {0, r - l, 0};\n    if (r - l > 1) {\n      int m = l + ((r - l) >> 1);\n      init(n << 1, l, m), init(n << 1 | 1, m, r);\n    }\n  }\n  void init(int S) { init(1, 0, s = S); }\n  void addm(int n, int q) { v[n].z += q, v[n].m += q; }\n  void down(int n, int l, int r) {\n    if (!v[n].z) return;\n    if (r - l > 1) addm(n << 1, v[n].z), addm(n << 1 | 1, v[n].z);\n    v[n].z = 0;\n  }\n  void up(int n, int l, int r) { v[n] = v[n << 1] + v[n << 1 | 1]; }\n  void upd(int n, int l, int r, int ql, int qr, int q) {\n    if (ql <= l && r <= qr) return addm(n, q), down(n, l, r);\n    down(n, l, r);\n    int m = l + ((r - l) >> 1);\n    if (ql < m) upd(n << 1, l, m, ql, qr, q);\n    if (m < qr) upd(n << 1 | 1, m, r, ql, qr, q);\n    up(n, l, r);\n  }\n  void upd(int ql, int qr, int q) { return upd(1, 0, s, ql, qr, q); }\n  int rmz(int n, int l, int r, int ql, int qr) {\n    if (v[n].m > 0) return -1;\n    if (r - l == 1) return l;\n    down(n, l, r);\n    int m = l + ((r - l) >> 1), f;\n    if (m < qr)\n      if ((f = rmz(n << 1 | 1, m, r, ql, qr)) != -1) return f;\n    if (ql < m) return rmz(n << 1, l, m, ql, qr);\n    return -1;\n  }\n  int rmz(int ql, int qr) { return rmz(1, 0, s, ql, qr); }\n  ND qry(int n, int l, int r, int ql, int qr) {\n    if (ql <= l && r <= qr) return v[n];\n    down(n, l, r);\n    ND f = {INF, INF, 0};\n    int m = l + ((r - l) >> 1);\n    if (ql < m) f = f + qry(n << 1, l, m, ql, qr);\n    if (m < qr) f = f + qry(n << 1 | 1, m, r, ql, qr);\n    return f;\n  }\n  ND qry(int ql, int qr) { return qry(1, 0, s, ql, qr); }\n};\nconst int MN = 1e3 + 10;\nconst int MP = 2e5 + 100;\nST<MP << 2> st;\nint N, M, g[MN][MN];\nbool ib(int x, int y) { return (0 <= x && x < N) && (0 <= y && y < M); }\nint w[MP][2], t[MP];\nll F;\nconst int dx[4] = {1, 0, 0, -1};\nconst int dy[4] = {0, 1, -1, 0};\nstruct SPL {\n public:\n  int v;\n  SPL *c[2], *p;\n  int s;\n  bool f;\n  SPL() {\n    p = nullptr;\n    for (int i : {0, 1}) c[i] = nullptr;\n    s = 1;\n    f = 0;\n  }\n  void upd() {\n    s = 1;\n    if (c[0]) s += c[0]->s;\n    if (c[1]) s += c[1]->s;\n  }\n  void fix() {\n    if (f) {\n      if (c[0]) c[0]->f = !c[0]->f;\n      if (c[1]) c[1]->f = !c[1]->f;\n      swap(c[0], c[1]);\n      f = 0;\n    }\n  }\n};\nSPL v[MP];\nint p[MP];\nint son(SPL* n) { return n->p->c[1] == n; }\nSPL* rot(SPL* n, int d) {\n  n->fix();\n  assert(n && n->c[d]);\n  SPL* o = n->c[d];\n  o->fix(), p[o->v] = p[n->v];\n  n->c[d] = o->c[!d], o->c[!d] = n;\n  if (n->c[d]) n->c[d]->p = n;\n  if ((o->p = n->p)) n->p->c[son(n)] = o;\n  n->p = o;\n  n->upd(), o->upd();\n  return o;\n}\nvoid rotup(SPL* n) { rot(n->p, son(n)); }\nvoid fixu(SPL* n) {\n  if (n->p) fixu(n->p);\n  n->fix();\n}\nvoid splay(SPL* n) {\n  fixu(n);\n  for (; n->p;) {\n    if (n->p->p) {\n      if (son(n) == son(n->p))\n        rotup(n->p), rotup(n);\n      else\n        rotup(n), rotup(n);\n    } else {\n      rotup(n);\n    }\n  }\n}\nvoid access(int n) {\n  splay(&v[n]);\n  SPL* o;\n  if ((o = v[n].c[1])) {\n    p[o->v] = n;\n    o->p = nullptr, v[n].c[1] = nullptr;\n  }\n  for (int w, u = n; p[u] != -1;) {\n    w = p[u];\n    v[w].fix();\n    splay(&v[w]);\n    if (v[w].c[1]) {\n      p[v[w].c[1]->v] = w;\n      v[w].c[1]->p = nullptr, v[w].c[1] = nullptr;\n    }\n    v[w].c[1] = &v[u], v[u].p = &v[w];\n    v[w].upd();\n    u = w;\n  }\n  splay(&v[n]);\n  assert(!v[n].p);\n}\nint root(int n) {\n  access(n);\n  SPL* x = &v[n];\n  while (x->c[0]) (x = x->c[0])->fix();\n  return x->v;\n}\nbool connected(int a, int b) {\n  bool f = root(a) == root(b);\n  return f;\n}\nvoid link(int a, int b) {\n  access(a);\n  access(b);\n  if (v[b].c[0]) {\n    SPL* l = v[b].c[0];\n    p[l->v] = b, l->p = nullptr;\n    l->f ^= 1;\n    v[b].c[0] = nullptr;\n    v[b].upd();\n  }\n  p[b] = a;\n}\nvoid cut(int a, int b) {\n  access(a), splay(&v[b]);\n  if (a != p[b]) {\n    swap(a, b);\n    access(a), splay(&v[b]);\n  }\n  assert(a == p[b]);\n  p[b] = -1;\n}\nvoid init(int x) {\n  for (int i = 0; i <= x; i++) v[i].v = i, p[i] = -1;\n}\nvoid rem(int l, int r, int q) {\n  int x = w[q][0], y = w[q][1], x1, y1;\n  for (int i = 0, j; i < 4; i++) {\n    if (!ib(x1 = x + dx[i], y1 = y + dy[i])) continue;\n    j = g[x1][y1];\n    if (l <= j && j < r) cut(j, q);\n  }\n}\nint main(void) {\n  scanf(\"%d%d\", &N, &M);\n  for (int i = 0; i < N; i++)\n    for (int j = 0; j < M; j++)\n      scanf(\"%d\", g[i] + j), w[g[i][j]][0] = i, w[g[i][j]][1] = j;\n  st.init(N * M), F = 0LL;\n  init(N * M);\n  t[0] = 1;\n  for (int i = 1, e = N * M, x, y, x1, y1; i <= e; i++) {\n    t[i] = t[i - 1];\n    x = w[i][0], y = w[i][1];\n    for (int j = 0, k; j < 4; j++) {\n      if (!ib(x1 = x + dx[j], y1 = y + dy[j])) continue;\n      k = g[x1][y1];\n      for (; t[i] <= k && k < i && connected(i, k); t[i]++) rem(t[i], i, t[i]);\n      if (t[i] <= k && k < i) link(i, k);\n    }\n  }\n  for (int i = 1, e = N * M, x, y; i <= e; i++) {\n    x = w[i][0], y = w[i][1];\n    st.upd(t[i] - 1, i, 1);\n    for (int j = 0, x2, y2; j < 4; j++) {\n      x2 = x + dx[j], y2 = y + dy[j];\n      if (ib(x2, y2) && g[x2][y2] < i && g[x2][y2] >= t[i])\n        st.upd(t[i] - 1, g[x2][y2], -1);\n    }\n    F += st.qry(t[i] - 1, i).c;\n  }\n  printf(\"%lld\\n\", F);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\nint read() {\n  int x = 0, f = 1;\n  char c = getchar();\n  while (c > '9' || c < '0') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    x = x * 10 + c - '0';\n    c = getchar();\n  }\n  return x * f;\n}\nint swap(int &x, int &y) {\n  int t = x;\n  x = y;\n  y = t;\n}\nint n, m, a[2005][2005], ch[N][2], fa[N], sze[N], p[N];\nbool notRT(int x) { return ch[fa[x]][0] == x || ch[fa[x]][1] == x; }\nint sk[N];\nvector<int> S[N];\nvoid tag(int x) {\n  swap(ch[x][0], ch[x][1]);\n  p[x] ^= 1;\n}\nvoid pushdown(int x) {\n  if (p[x]) {\n    p[x] = 0;\n    if (ch[x][0]) tag(ch[x][0]);\n    if (ch[x][1]) tag(ch[x][1]);\n  }\n}\nvoid pushup(int x) { sze[x] = sze[ch[x][0]] + sze[ch[x][1]] + 1; }\nvoid rotate(int x) {\n  int y = fa[x], z = fa[y];\n  bool k = ch[y][1] == x;\n  int w = ch[x][k ^ 1];\n  if (notRT(y)) ch[z][ch[z][1] == y] = x;\n  ch[x][k ^ 1] = y;\n  ch[y][k] = w;\n  if (w) fa[w] = y;\n  fa[y] = x;\n  fa[x] = z;\n  pushup(y);\n  pushup(x);\n}\nvoid splay(int x) {\n  int y = x, z = 0;\n  sk[++z] = x;\n  while (notRT(y)) sk[++z] = y = fa[y];\n  while (z) pushdown(sk[z--]);\n  while (notRT(x)) {\n    y = fa[x];\n    z = fa[y];\n    if (notRT(y)) rotate(((ch[z][1] == y) ^ (ch[y][1] == x)) ? x : y);\n    rotate(x);\n  }\n}\nvoid access(int x) {\n  for (int y = 0; x; x = fa[y = x]) splay(x), ch[x][1] = y, pushup(x);\n}\nvoid makeroot(int x) {\n  access(x);\n  splay(x);\n  tag(x);\n}\nint findroot(int x) {\n  access(x);\n  splay(x);\n  while (ch[x][0]) pushdown(x), x = ch[x][0];\n  splay(x);\n  return x;\n}\nbool link(int x, int y) {\n  makeroot(x);\n  if (findroot(y) != x)\n    fa[x] = y;\n  else\n    return 0;\n  return 1;\n}\nbool cut(int x, int y) {\n  makeroot(x);\n  if (findroot(y) == x && !ch[y][0] && fa[y] == x) {\n    fa[y] = ch[x][1] = 0;\n    pushup(x);\n    return 1;\n  }\n  return 0;\n}\nstruct PT {\n  int mn, cnt, lzy;\n  PT() {}\n  PT(int _mn, int _cnt, int _lzy) {\n    mn = _mn;\n    cnt = _cnt;\n    lzy = _lzy;\n  }\n  PT operator+(const PT &q) const {\n    PT res(0, 0, 0);\n    if (mn == q.mn) {\n      res.mn = mn;\n      res.cnt = cnt + q.cnt;\n    } else if (mn < q.mn) {\n      res.mn = mn;\n      res.cnt = cnt;\n    } else {\n      res.mn = q.mn;\n      res.cnt = q.cnt;\n    }\n    return res;\n  }\n} t[N << 2];\nvoid change(int i, int k) {\n  t[i].lzy += k;\n  t[i].mn += k;\n}\nvoid pdn(int i) {\n  if (t[i].lzy) {\n    change((i << 1), t[i].lzy);\n    change((i << 1 | 1), t[i].lzy);\n    t[i].lzy = 0;\n  }\n}\nvoid build(int i, int l, int r) {\n  t[i].cnt = r - l + 1;\n  if (l == r) return;\n  build((i << 1), l, ((l + r) >> 1));\n  build((i << 1 | 1), ((l + r) >> 1) + 1, r);\n}\nvoid updata(int i, int l, int r, int x, int y, int k) {\n  if (x <= l && r <= y) {\n    change(i, k);\n    return;\n  }\n  pdn(i);\n  if (x <= ((l + r) >> 1)) updata((i << 1), l, ((l + r) >> 1), x, y, k);\n  if (y > ((l + r) >> 1)) updata((i << 1 | 1), ((l + r) >> 1) + 1, r, x, y, k);\n  t[i] = t[(i << 1)] + t[(i << 1 | 1)];\n}\nPT query(int i, int l, int r, int x, int y) {\n  if (x <= l && r <= y) return t[i];\n  PT res(998299, 0, 0);\n  pdn(i);\n  if (x <= ((l + r) >> 1)) res = res + query((i << 1), l, ((l + r) >> 1), x, y);\n  if (y > ((l + r) >> 1))\n    res = res + query((i << 1 | 1), ((l + r) >> 1) + 1, r, x, y);\n  return res;\n}\nint main() {\n  n = read();\n  m = read();\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j) a[i][j] = read();\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j < m; ++j)\n      S[a[i][j]].push_back(a[i][j + 1]), S[a[i][j + 1]].push_back(a[i][j]);\n  for (int i = 1; i < n; ++i)\n    for (int j = 1; j <= m; ++j)\n      S[a[i][j]].push_back(a[i + 1][j]), S[a[i + 1][j]].push_back(a[i][j]);\n  long long ans = 0;\n  build(1, 1, n * m);\n  for (int L = 1, R = 0; L <= n * m; ++L) {\n    while (R < n * m) {\n      ++R;\n      bool f = 1;\n      for (int i = S[R].size() - 1; i >= 0; --i) {\n        int v = S[R][i];\n        if (v >= L && v <= R) {\n          if (!link(v, R)) {\n            f = 0;\n            break;\n          }\n          updata(1, 1, n * m, R, n * m, -1);\n        }\n      }\n      if (f == 0) {\n        for (int i = S[R].size() - 1; i >= 0; --i) {\n          int v = S[R][i];\n          if (v >= L && v <= R)\n            if (cut(v, R)) updata(1, 1, n * m, R, n * m, 1);\n        }\n        --R;\n        break;\n      }\n      updata(1, 1, n * m, R, n * m, 1);\n    }\n    PT res = query(1, 1, n * m, L, R);\n    if (res.mn == 1) ans += res.cnt;\n    updata(1, 1, n * m, L, n * m, -1);\n    for (int i = S[L].size() - 1; i >= 0; --i) {\n      int v = S[L][i];\n      if (v >= L && v <= R)\n        if (cut(v, L)) updata(1, 1, n * m, v, n * m, 1);\n    }\n  }\n  printf(\"%lld\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn = 200010;\nconst int inf = 2147483647;\nint read() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9')\n    x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n  return x * f;\n}\nint n, m, a[1010][1010];\nlong long ans = 0;\nint son[Maxn][2], fa[Maxn];\nbool rev[Maxn];\nbool is(int x) { return (son[fa[x]][0] != x && son[fa[x]][1] != x); }\nvoid Rev(int x) {\n  rev[x] ^= true;\n  swap(son[x][0], son[x][1]);\n}\nvoid down(int x) {\n  if (rev[x]) {\n    int lc = son[x][0], rc = son[x][1];\n    if (lc) Rev(lc);\n    if (rc) Rev(rc);\n    rev[x] = false;\n  }\n}\nvoid rotate(int x) {\n  int y = fa[x], z = fa[y], w = (son[y][0] == x);\n  son[y][w ^ 1] = son[x][w];\n  if (son[x][w]) fa[son[x][w]] = y;\n  if (!is(y)) son[z][son[z][1] == y] = x;\n  fa[x] = z;\n  son[x][w] = y;\n  fa[y] = x;\n}\nint sta[Maxn], top;\nvoid update(int x) {\n  top = 0;\n  while (1) {\n    sta[++top] = x;\n    if (is(x)) break;\n    x = fa[x];\n  }\n  while (top) down(sta[top--]);\n}\nvoid splay(int x) {\n  update(x);\n  while (!is(x)) {\n    int y = fa[x], z = fa[y];\n    if (!is(y)) rotate((son[z][1] == y) == (son[y][1] == x) ? y : x);\n    rotate(x);\n  }\n}\nvoid access(int x) {\n  int last = 0;\n  while (x) {\n    splay(x);\n    son[x][1] = last;\n    last = x;\n    x = fa[x];\n  }\n}\nvoid make_root(int x) { access(x), splay(x), Rev(x); }\nvoid link(int x, int y) { make_root(x), fa[x] = y; }\nvoid cut(int x, int y) {\n  make_root(x), access(y), splay(y);\n  son[y][0] = fa[x] = 0;\n}\nint find_root(int x) {\n  access(x), splay(x);\n  while (son[x][0]) x = son[x][0];\n  return x;\n}\nstruct P {\n  int mn, c;\n  P(int _mn = 0, int _c = 0) { mn = _mn, c = _c; }\n};\nstruct Seg {\n  int l, r, lc, rc, tag;\n  P t;\n} tr[Maxn << 1];\nint tot = 0;\nvoid Add(int x, int v) {\n  tr[x].t.mn += v;\n  tr[x].tag += v;\n}\nP merge(P lc, P rc) {\n  P re;\n  if (lc.mn == rc.mn)\n    re.c = lc.c + rc.c;\n  else\n    re.c = ((lc.mn < rc.mn) ? lc.c : rc.c);\n  re.mn = min(lc.mn, rc.mn);\n  return re;\n}\nvoid Down(int x) {\n  int lc = tr[x].lc, rc = tr[x].rc, t = tr[x].tag;\n  if (t) {\n    tr[x].tag = 0;\n    Add(lc, t), Add(rc, t);\n  }\n}\nvoid build(int l, int r) {\n  int x = ++tot;\n  tr[x].l = l;\n  tr[x].r = r;\n  tr[x].tag = 0;\n  if (l == r) {\n    tr[x].t = P(0, 1);\n    return;\n  }\n  int mid = l + r >> 1;\n  tr[x].lc = tot + 1, build(l, mid);\n  tr[x].rc = tot + 1, build(mid + 1, r);\n  tr[x].t = merge(tr[tr[x].lc].t, tr[tr[x].rc].t);\n}\nvoid add(int x, int l, int r, int v) {\n  if (l > r) return;\n  if (tr[x].l == l && tr[x].r == r) {\n    Add(x, v);\n    return;\n  }\n  int mid = tr[x].l + tr[x].r >> 1, lc = tr[x].lc, rc = tr[x].rc;\n  Down(x);\n  if (r <= mid)\n    add(lc, l, r, v);\n  else if (l > mid)\n    add(rc, l, r, v);\n  else\n    add(lc, l, mid, v), add(rc, mid + 1, r, v);\n  tr[x].t = merge(tr[tr[x].lc].t, tr[tr[x].rc].t);\n}\nP query(int x, int l, int r) {\n  if (tr[x].l == l && tr[x].r == r) return tr[x].t;\n  int mid = tr[x].l + tr[x].r >> 1, lc = tr[x].lc, rc = tr[x].rc;\n  Down(x);\n  if (r <= mid) return query(lc, l, r);\n  if (l > mid) return query(rc, l, r);\n  return merge(query(lc, l, mid), query(rc, mid + 1, r));\n}\nint px[Maxn], py[Maxn];\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nbool in(int x, int y) { return (x > 0 && y > 0 && x <= n && y <= m); }\nint l, r, tmp[5], lt;\nbool check(int x, int y) {\n  lt = 0;\n  for (int i = 0; i < 4; i++) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if (!in(nx, ny)) continue;\n    if (l <= a[nx][ny] && a[nx][ny] <= r) {\n      int t = find_root(a[nx][ny]);\n      for (int j = 1; j <= lt; j++)\n        if (tmp[j] == t) {\n          return false;\n        }\n      tmp[++lt] = t;\n    }\n  }\n  return true;\n}\nint main() {\n  n = read(), m = read();\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) {\n      int x = read();\n      a[i][j] = x;\n      px[x] = i, py[x] = j;\n    }\n  build(1, n * m);\n  add(1, 1, 1, 1);\n  l = 1;\n  ans++;\n  for (r = 2; r <= n * m; r++) {\n    while (!check(px[r], py[r])) {\n      for (int i = 0; i < 4; i++) {\n        int nx = px[l] + dx[i], ny = py[l] + dy[i];\n        if (in(nx, ny) && a[nx][ny] > l && a[nx][ny] < r) {\n          cut(l, a[nx][ny]);\n        }\n      }\n      l++;\n    }\n    add(1, l, r, 1);\n    for (int i = 0; i < 4; i++) {\n      int nx = px[r] + dx[i], ny = py[r] + dy[i];\n      if (!in(nx, ny)) continue;\n      if (l <= a[nx][ny] && a[nx][ny] <= r) {\n        link(a[nx][ny], r);\n        add(1, l, a[nx][ny], -1);\n      }\n    }\n    P t = query(1, l, r);\n    if (t.mn == 1) ans += (long long)t.c;\n  }\n  printf(\"%lld\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2 * 1e5 + 10;\nconst int dx[4] = {1, -1, 0, 0};\nconst int dy[4] = {0, 0, -1, 1};\nint n;\nint m;\nstruct mar {\n  int f[N * 2];\n  inline int* operator[](const int& x) { return f + x * m; }\n} val;\nbool book[N];\nstruct data {\n  int x;\n  int y;\n} nod[N];\nint ctt;\nint ptr;\nint totr;\nstruct tnod {\n  int val;\n  int cnt;\n  friend tnod operator+(tnod a, tnod b) {\n    if (a.val < b.val) return a;\n    if (a.val > b.val) return b;\n    return (tnod){a.val, a.cnt + b.cnt};\n  }\n  void operator+=(const int& x) { val += x; }\n};\nstruct linkcuttree {\n  int s[N][2];\n  int fa[N];\n  int mi[N];\n  int rv[N];\n  int st[N];\n  int tp;\n  linkcuttree() { mi[0] = 0x3f3f3f3f; }\n  inline int gc(int x) { return s[fa[x]][1] == x; }\n  inline bool isr(int x) { return (s[fa[x]][1] != x && s[fa[x]][0] != x); }\n  inline void ud(int x) { mi[x] = min(min(mi[s[x][0]], mi[s[x][1]]), x); }\n  inline void pd(int p) {\n    if (rv[p])\n      rv[s[p][0]] ^= 1, rv[s[p][1]] ^= 1, swap(s[p][0], s[p][1]), rv[p] = 0;\n  }\n  inline void pdall(int p) {\n    for (int x = p; (st[++tp] = x, !isr(x)); x = fa[x])\n      ;\n    while (tp) pd(st[tp--]);\n  }\n  inline void rt(int x) {\n    int d = fa[x];\n    int t = gc(x);\n    s[d][t] = s[x][t ^ 1];\n    fa[s[x][t ^ 1]] = d;\n    if (!isr(d)) s[fa[d]][gc(d)] = x;\n    fa[x] = fa[d];\n    s[x][t ^ 1] = d;\n    fa[d] = x;\n    ud(d);\n    ud(x);\n  }\n  inline void rtup(int x) {\n    rt((gc(x) ^ gc(fa[x])) ? x : fa[x]);\n    rt(x);\n  }\n  inline void splay(int x) {\n    pdall(x);\n    for (; !isr(x) && !isr(fa[x]); rtup(x))\n      ;\n    if (!isr(x)) rt(x);\n  }\n  inline void acc(int p) {\n    for (splay(p), s[p][1] = 0, ud(p); fa[p];\n         splay(fa[p]), s[fa[p]][1] = p, ud(fa[p]), splay(p))\n      ;\n  }\n  inline void mkr(int p) {\n    acc(p);\n    rv[p] ^= 1;\n  }\n  inline void lk(int u, int v) {\n    mkr(u);\n    acc(v);\n    fa[u] = v;\n  }\n  inline void cu(int u, int v) {\n    mkr(u);\n    acc(v);\n    if (s[v][0] == u && s[u][1] == 0) s[v][0] = 0, fa[u] = 0, ud(v);\n  }\n  inline int cmi(int u, int v) {\n    mkr(u);\n    acc(v);\n    if (fa[u] == 0)\n      return 0x3f3f3f3f;\n    else\n      return mi[v];\n  }\n} lct;\nstruct linetree {\n  tnod v[N << 2];\n  int add[N << 2];\n  inline void pd(int p, int p1, int p2) {\n    if (add[p])\n      v[p1] += add[p], v[p2] += add[p], add[p1] += add[p], add[p2] += add[p],\n          add[p] = 0;\n  }\n  inline void build(int p, int l, int r) {\n    v[p] = (tnod){0, r - l};\n    if (r - l == 1) {\n      return;\n    }\n    int mid = (l + r) >> 1;\n    build(p << 1, l, mid);\n    build(p << 1 | 1, mid, r);\n  }\n  inline void stadd(int p, int l, int r, int dl, int dr, int pl) {\n    if (dl == l && dr == r) {\n      v[p] += pl;\n      add[p] += pl;\n      return;\n    }\n    int mid = (l + r) >> 1;\n    pd(p, p << 1, p << 1 | 1);\n    if (dl < mid) stadd(p << 1, l, mid, dl, min(dr, mid), pl);\n    if (mid < dr) stadd(p << 1 | 1, mid, r, max(dl, mid), dr, pl);\n    v[p] = v[p << 1] + v[p << 1 | 1];\n  }\n  inline tnod sum(int p, int l, int r, int dl, int dr) {\n    if (dl == l && dr == r) return v[p];\n    int mid = (l + r) >> 1;\n    pd(p, p << 1, p << 1 | 1);\n    if (dl < mid && mid < dr)\n      return sum(p << 1, l, mid, dl, mid) + sum(p << 1 | 1, mid, r, mid, dr);\n    if (dl < mid)\n      return sum(p << 1, l, mid, dl, dr);\n    else\n      return sum(p << 1 | 1, mid, r, dl, dr);\n  }\n} lt;\ninline void delnod(int sx, int sy) {\n  int np = val[sx][sy];\n  for (int k = 0, tx, ty; k < 4; k++) {\n    tx = sx + dx[k];\n    ty = sy + dy[k];\n    if (tx < 1 || tx > n || ty < 1 || ty > m || val[tx][ty] < ptr ||\n        val[tx][ty] > totr)\n      continue;\n    lct.cu(np, val[tx][ty]);\n  }\n  ptr++;\n}\ninline void insed(int p1, int p2) {\n  lt.stadd(1, 0, ctt, 0, p2, -1);\n  int tmp = lct.cmi(p1, p2);\n  if (tmp == 0x3f3f3f3f) {\n    lct.lk(p1, p2);\n    return;\n  }\n  for (int k = ptr; k <= tmp; k++) delnod(nod[k].x, nod[k].y);\n  lct.lk(p1, p2);\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  ctt = n * m;\n  lt.build(1, 0, ctt);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1, t; j <= m; j++)\n      scanf(\"%d\", &t), val[i][j] = t, nod[t] = (data){i, j};\n  long long ans = 0;\n  ptr = 1;\n  totr = 1;\n  for (int i = 1; i <= ctt; i++) {\n    totr = i;\n    int sx = nod[i].x;\n    int sy = nod[i].y;\n    lt.stadd(1, 0, ctt, 0, i, 1);\n    for (int k = 0, tx, ty; k < 4; k++) {\n      tx = sx + dx[k], ty = sy + dy[k];\n      if (tx < 1 || tx > n || ty < 1 || ty > m || val[tx][ty] > i ||\n          val[tx][ty] < ptr)\n        continue;\n      insed(i, val[tx][ty]);\n    }\n    tnod ret = lt.sum(1, 0, ctt, ptr - 1, i);\n    if (ret.val == 1) ans += ret.cnt;\n  }\n  printf(\"%I64d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1001, M = 1001, K = 200001;\nint f[N][M], n, m;\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, -1, 0, 1};\nvector<int> graph[K];\nint root[K], child[K][2], father[K], rev[K];\nvoid cover(int u) { rev[u] ^= 1; }\nvoid pushdown(int u) {\n  if (rev[u]) {\n    swap(child[u][0], child[u][1]);\n    if (child[u][0]) cover(child[u][0]);\n    if (child[u][1]) cover(child[u][1]);\n    rev[u] = 0;\n  }\n}\nvoid rotate(int u, int c) {\n  int fu = father[u], cu = child[u][c ^ 1];\n  if (root[fu])\n    root[fu] = false, root[u] = true, father[u] = father[fu];\n  else {\n    int gu = father[fu], t = (child[gu][1] == fu);\n    child[gu][t] = u, father[u] = gu;\n  }\n  child[fu][c] = cu, father[cu] = fu;\n  child[u][c ^ 1] = fu, father[fu] = u;\n}\nint s[N], top = 0;\nvoid splay(int u) {\n  for (int v = u;; v = father[v]) {\n    s[++top] = v;\n    if (root[v]) break;\n  }\n  for (; top; top--) pushdown(s[top]);\n  while (!root[u]) {\n    int fu = father[u], c = (child[fu][1] == u);\n    if (root[fu])\n      rotate(u, c);\n    else {\n      int gu = father[fu], c_ = (child[gu][1] == fu);\n      if (c ^ c_)\n        rotate(u, c), rotate(u, c_);\n      else\n        rotate(fu, c_), rotate(u, c);\n    }\n  }\n}\nvoid access(int u) {\n  int now = 0;\n  while (u) {\n    splay(u);\n    if (child[u][1]) root[child[u][1]] = true;\n    if (now) root[now] = false;\n    child[u][1] = now, now = u, u = father[u];\n  }\n}\nint leftmost(int u) {\n  int v = u;\n  while (true) {\n    pushdown(v);\n    if (child[v][0])\n      v = child[v][0];\n    else\n      break;\n  }\n  return splay(v), v;\n}\nint findroot(int u) { return access(u), splay(u), leftmost(u); }\nvoid changeroot(int u) { access(u), splay(u), cover(u); }\nvoid link(int u, int v) { changeroot(u), father[u] = v; }\nvoid cut(int u, int v) {\n  changeroot(u), access(v), splay(v);\n  root[u] = root[v] = true, child[v][0] = 0, father[u] = 0;\n}\nint sgt_cnt[K << 2], sgt_mn[K << 2], tag[K << 2];\nvoid build(int l, int r, int now) {\n  int mid = l + r >> 1;\n  sgt_mn[now] = 0, tag[now] = 0;\n  if (l < r) {\n    build(l, mid, now << 1), build(mid + 1, r, now << 1 | 1);\n    sgt_cnt[now] = sgt_cnt[now << 1] + sgt_cnt[now << 1 | 1];\n  } else\n    sgt_cnt[now] = 1;\n}\nvoid pushup(int now) {\n  sgt_mn[now] = min(sgt_mn[now << 1], sgt_mn[now << 1 | 1]) + tag[now];\n  sgt_cnt[now] = 0;\n  if (sgt_mn[now] == sgt_mn[now << 1] + tag[now])\n    sgt_cnt[now] += sgt_cnt[now << 1];\n  if (sgt_mn[now] == sgt_mn[now << 1 | 1] + tag[now])\n    sgt_cnt[now] += sgt_cnt[now << 1 | 1];\n}\nvoid change(int left, int right, int l, int r, int val, int now) {\n  int mid = l + r >> 1;\n  if (l == left && r == right)\n    sgt_mn[now] += val, tag[now] += val;\n  else {\n    if (right <= mid)\n      change(left, right, l, mid, val, now << 1);\n    else if (left > mid)\n      change(left, right, mid + 1, r, val, now << 1 | 1);\n    else\n      change(left, mid, l, mid, val, now << 1),\n          change(mid + 1, right, mid + 1, r, val, now << 1 | 1);\n    pushup(now);\n  }\n}\nint query(int left, int right, int l, int r, int val, int now) {\n  int mid = l + r >> 1;\n  if (left > right) return 0;\n  if (l == left && r == right)\n    return sgt_mn[now] == val ? sgt_cnt[now] : 0;\n  else if (right <= mid)\n    return query(left, right, l, mid, val - tag[now], now << 1);\n  else if (left > mid)\n    return query(left, right, mid + 1, r, val - tag[now], now << 1 | 1);\n  else\n    return query(left, mid, l, mid, val - tag[now], now << 1) +\n           query(mid + 1, right, mid + 1, r, val - tag[now], now << 1 | 1);\n}\nint l = 0, r = 0;\nlong long ans = 0ll;\nbool check() {\n  map<int, int> total;\n  for (int i = 0; i < graph[r].size(); i++) {\n    int to = graph[r][i];\n    if (to <= r && to > l) total[findroot(to)]++;\n  }\n  for (map<int, int>::iterator it = total.begin(); it != total.end(); it++) {\n    if ((*it).second > 1) return false;\n  }\n  return true;\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) scanf(\"%d\", &f[i][j]);\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      for (int k = 0; k < 4; k++) {\n        int x = i + dx[k], y = j + dy[k];\n        if (1 <= x && x <= n && 1 <= y && y <= m)\n          graph[f[i][j]].push_back(f[x][y]);\n      }\n    }\n  }\n  for (int i = 1; i <= n * m; i++)\n    root[i] = true, child[i][0] = child[i][1] = father[i] = 0;\n  build(1, n * m, 1);\n  for (r = 1; r <= n * m; r++) {\n    change(1, r, 1, n * m, 1, 1);\n    while (l < r && !check()) {\n      l++;\n      for (int j = 0; j < graph[l].size(); j++) {\n        int to = graph[l][j];\n        if (to >= l && to < r) cut(l, to), change(1, l, 1, n * m, 1, 1);\n      }\n    }\n    for (int j = 0; j < graph[r].size(); j++) {\n      int to = graph[r][j];\n      if (to <= r && to > l) link(r, to), change(1, to, 1, n * m, -1, 1);\n    }\n    ans += query(l + 1, r, 1, n * m, 1, 1);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = (int)1e9 + 7;\nconst int FFTMOD = 119 << 23 | 1;\nconst int INF = (int)1e9 + 23111992;\nconst long long LINF = (long long)1e18 + 23111992;\nconst long double PI = acos((long double)-1);\nconst long double EPS = 1e-9;\ninline long long gcd(long long a, long long b) {\n  long long r;\n  while (b) {\n    r = a % b;\n    a = b;\n    b = r;\n  }\n  return a;\n}\ninline long long lcm(long long a, long long b) { return a / gcd(a, b) * b; }\ninline long long fpow(long long n, long long k, int p = MOD) {\n  long long r = 1;\n  for (; k; k >>= 1) {\n    if (k & 1) r = r * n % p;\n    n = n * n % p;\n  }\n  return r;\n}\ntemplate <class T>\ninline int chkmin(T& a, const T& val) {\n  return val < a ? a = val, 1 : 0;\n}\ntemplate <class T>\ninline int chkmax(T& a, const T& val) {\n  return a < val ? a = val, 1 : 0;\n}\ninline unsigned long long isqrt(unsigned long long k) {\n  unsigned long long r = sqrt(k) + 1;\n  while (r * r > k) r--;\n  return r;\n}\ninline long long icbrt(long long k) {\n  long long r = cbrt(k) + 1;\n  while (r * r * r > k) r--;\n  return r;\n}\ninline void addmod(int& a, int val, int p = MOD) {\n  if ((a = (a + val)) >= p) a -= p;\n}\ninline void submod(int& a, int val, int p = MOD) {\n  if ((a = (a - val)) < 0) a += p;\n}\ninline int mult(int a, int b, int p = MOD) { return (long long)a * b % p; }\ninline int inv(int a, int p = MOD) { return fpow(a, p - 2, p); }\ninline int sign(long double x) { return x < -EPS ? -1 : x > +EPS; }\ninline int sign(long double x, long double y) { return sign(x - y); }\nmt19937 mt(chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int myrand() { return abs((int)mt()); }\nstruct node_t {\n  node_t *p, *l, *r;\n  int size, rev;\n  int s, w;\n  node_t() : p(0), l(0), r(0), size(1), rev(0), s(0), w(1) {}\n};\nint isrt(node_t* x) { return !(x->p) || (x->p->l != x && x->p->r != x); }\nint left(node_t* x) { return x->p->l == x; }\nvoid setchild(node_t* x, node_t* p, int l) {\n  (l ? p->l : p->r) = x;\n  if (x) x->p = p;\n}\nvoid push(node_t* x) {\n  node_t* u = x->l;\n  node_t* v = x->r;\n  if (x->rev) {\n    if (u) swap(u->l, u->r), u->rev ^= 1;\n    if (v) swap(v->l, v->r), v->rev ^= 1;\n    x->rev = 0;\n  }\n}\nint size(node_t* x) { return x ? x->size : 0; }\nint sum(node_t* x) { return x ? x->s : 0; }\nvoid pull(node_t* x) {\n  x->size = size(x->l) + 1 + size(x->r);\n  x->s = sum(x->l) + x->w + sum(x->r);\n}\nvoid rotate(node_t* x) {\n  node_t *p = x->p, *g = p->p;\n  int l = left(x);\n  setchild(l ? x->r : x->l, p, l);\n  if (!isrt(p))\n    setchild(x, g, left(p));\n  else\n    x->p = g;\n  setchild(p, x, !l);\n  pull(p);\n}\nnode_t* splay(node_t* x) {\n  push(x);\n  while (!isrt(x)) {\n    node_t *p = x->p, *g = p->p;\n    if (g) push(g);\n    push(p), push(x);\n    if (!isrt(p)) rotate(left(x) != left(p) ? x : p);\n    rotate(x);\n  }\n  pull(x);\n  return x;\n}\nnode_t* access(node_t* x) {\n  node_t* z = 0;\n  for (node_t* y = x; y; y = y->p) {\n    splay(y);\n    y->w += sum(y->r);\n    y->r = z;\n    y->w -= sum(y->r);\n    pull(z = y);\n  }\n  splay(x);\n  return z;\n}\nvoid link(node_t* x, node_t* p) {\n  access(x), access(p);\n  x->p = p;\n  p->w += sum(x);\n}\nvoid cut(node_t* x) {\n  access(x);\n  x->l->p = 0, x->l = 0;\n  pull(x);\n}\nvoid makeroot(node_t* x) {\n  access(x);\n  x->rev ^= 1;\n  swap(x->l, x->r);\n}\nnode_t* findroot(node_t* x) {\n  access(x);\n  while (x->l) push(x), x = x->l;\n  push(x);\n  return splay(x);\n}\nnode_t* lca(node_t* x, node_t* y) {\n  if (findroot(x) != findroot(y)) return 0;\n  access(x);\n  return access(y);\n}\nint connect(node_t* x, node_t* y) {\n  if (x == y) return 1;\n  access(x), access(y);\n  return x->p != 0;\n}\nint treequery(node_t* x) {\n  access(x);\n  return x->w;\n}\nconst int maxn = 2e5 + 5;\nint n, m;\nvector<vector<int> > a;\nnode_t pool[maxn];\nvoid makeroot(int u) { makeroot(pool + u); }\nvoid link(int u, int v) { link(pool + u, pool + v); }\nvoid cut(int u) { cut(pool + u); }\nint findroot(int u) { return findroot(pool + u) - pool; }\nint lca(int u, int v) {\n  node_t* a = lca(pool + u, pool + v);\n  if (!a) return -1;\n  return a - pool;\n}\nint connect(int u, int v) { return connect(pool + u, pool + v); }\nint treequery(int u) { return treequery(pool + u); }\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\nint inside(int u, int v) {\n  if (!(0 <= u && u < n)) return 0;\n  if (!(0 <= v && v < m)) return 0;\n  return 1;\n}\npair<int, int> merge(pair<int, int> a, pair<int, int> b) {\n  pair<int, int> res = make_pair(min(a.first, b.first), 0);\n  if (res.first == a.first) {\n    res.second += a.second;\n  }\n  if (res.first == b.first) {\n    res.second += b.second;\n  }\n  return res;\n}\npair<int, int> st[maxn << 2];\nint lz[maxn << 2];\nvoid build(int p, int L, int R) {\n  if (L == R) {\n    st[p] = make_pair(0, 1);\n    return;\n  }\n  build(p << 1, L, L + R >> 1);\n  build(p << 1 | 1, (L + R >> 1) + 1, R);\n  st[p] = merge(st[p << 1], st[p << 1 | 1]);\n}\nvoid push(int p, int L, int R) {\n  if (lz[p]) {\n    st[p].first += lz[p];\n    if (L < R) {\n      for (int i = (0); i < (2); ++i) {\n        lz[p << 1 | i] += lz[p];\n      }\n    }\n    lz[p] = 0;\n  }\n}\nvoid upd(int p, int l, int r, int L, int R, int val) {\n  push(p, L, R);\n  if (R < l || r < L) return;\n  if (l <= L && R <= r) {\n    lz[p] = val;\n    push(p, L, R);\n    return;\n  }\n  upd(p << 1, l, r, L, L + R >> 1, val);\n  upd(p << 1 | 1, l, r, (L + R >> 1) + 1, R, val);\n  st[p] = merge(st[p << 1], st[p << 1 | 1]);\n}\npair<int, int> query(int p, int l, int r, int L, int R) {\n  push(p, L, R);\n  if (R < l || r < L) return make_pair(INF, 1);\n  if (l <= L && R <= r) {\n    return st[p];\n  }\n  return merge(query(p << 1, l, r, L, L + R >> 1),\n               query(p << 1 | 1, l, r, (L + R >> 1) + 1, R));\n}\nvoid chemthan() {\n  cin >> n >> m;\n  a.resize(n, vector<int>(m));\n  vector<pair<int, int> > from(n * m + 1);\n  for (int i = (0); i < (n); ++i)\n    for (int j = (0); j < (m); ++j)\n      cin >> a[i][j], from[a[i][j]] = make_pair(i, j);\n  build(1, 1, n * m);\n  long long res = 0;\n  int ptr = 1;\n  vector<vector<int> > adj(n * m + 1);\n  for (int i = (1); i < (n * m + 1); ++i) {\n    int x = from[i].first;\n    int y = from[i].second;\n    upd(1, 1, i, 1, n * m, 1);\n    for (int d = (0); d < (4); ++d) {\n      int nx = x + dx[d];\n      int ny = y + dy[d];\n      vector<int> vals;\n      if (inside(nx, ny) && ptr <= a[nx][ny] && a[nx][ny] < i) {\n        vals.push_back(a[nx][ny]);\n      }\n      sort((vals).begin(), (vals).end());\n      for (int x : vals) {\n        while (ptr <= x && findroot(x) == i) {\n          for (int y : adj[ptr]) {\n            makeroot(y);\n            if (findroot(ptr) == y) {\n              cut(ptr);\n            }\n          }\n          makeroot(i);\n          ptr++;\n        }\n        if (ptr <= x) {\n          makeroot(x);\n          link(x, i);\n          adj[x].push_back(i);\n          upd(1, ptr, x, 1, n * m, -1);\n        }\n      }\n    }\n    res += query(1, ptr, i, 1, n * m).second;\n  }\n  cout << res << \"\\n\";\n}\nint main(int argc, char* argv[]) {\n  ios_base::sync_with_stdio(0), cin.tie(0);\n  if (argc > 1) {\n    assert(freopen(argv[1], \"r\", stdin));\n  }\n  if (argc > 2) {\n    assert(freopen(argv[2], \"wb\", stdout));\n  }\n  chemthan();\n  cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nstruct BalancedBinaryForest {\n  int n;\n  vector<bool> isblack;\n  vector<int> blackheight;\n  vector<int> lft, rgt, par;\n  void init(int _n) {\n    n = _n;\n    isblack = vector<bool>(n, true);\n    blackheight = vector<int>(n, 1);\n    lft = rgt = par = vector<int>(n, -1);\n  }\n  int makeblack(int a) {\n    if (a != -1 && !isblack[a]) isblack[a] = true, ++blackheight[a];\n    return a;\n  }\n  int disconnect(int &a) {\n    int ret = a;\n    a = -1;\n    if (ret != -1) par[ret] = -1;\n    return ret;\n  }\n  pair<int, int> split(int a) {\n    int l = makeblack(disconnect(lft[a])), r = makeblack(disconnect(rgt[a]));\n    while (par[a] != -1) {\n      int p = par[a], pl = makeblack(disconnect(lft[p])),\n          pr = makeblack(disconnect(rgt[p]));\n      par[a] = par[p];\n      par[p] = -1;\n      if (par[a] != -1) (lft[par[a]] == p ? lft[par[a]] : rgt[par[a]]) = a;\n      if (a == pl) r = join3(r, p, pr);\n      if (a == pr) l = join3(pl, p, l);\n    }\n    isblack[a] = true;\n    blackheight[a] = 1;\n    return make_pair(l, r);\n  }\n  int rotaterootlft(int a) {\n    assert(par[a] == -1);\n    int c = rgt[a], d = lft[c];\n    rgt[a] = d;\n    if (d != -1) par[d] = a;\n    lft[c] = a;\n    par[a] = c;\n    par[c] = -1;\n    return c;\n  }\n  int rotaterootrgt(int c) {\n    assert(par[c] == -1);\n    int a = lft[c], d = rgt[a];\n    lft[c] = d;\n    if (d != -1) par[d] = c;\n    rgt[a] = c;\n    par[c] = a;\n    par[a] = -1;\n    return a;\n  }\n  int height(int x) { return x == -1 ? 0 : blackheight[x]; }\n  int joinlft(int a, int x, int b) {\n    if (height(a) == height(b) && (a == -1 || isblack[a])) {\n      isblack[x] = false;\n      blackheight[x] = height(a);\n      lft[x] = a;\n      if (a != -1) par[a] = x;\n      rgt[x] = b;\n      if (b != -1) par[b] = x;\n      return x;\n    }\n    int r = disconnect(rgt[a]);\n    rgt[a] = joinlft(r, x, b);\n    par[rgt[a]] = a;\n    if (!isblack[a] && !isblack[rgt[a]]) {\n      makeblack(a);\n      return a;\n    }\n    if (isblack[a] && isblack[rgt[a]] &&\n        blackheight[a] == blackheight[rgt[a]]) {\n      assert(!isblack[rgt[rgt[a]]]);\n      a = rotaterootlft(a);\n      isblack[a] = false;\n      isblack[rgt[a]] = true;\n      ++blackheight[rgt[a]];\n      return a;\n    }\n    return a;\n  }\n  int joinrgt(int a, int x, int b) {\n    if (height(a) == height(b) && (b == -1 || isblack[b])) {\n      isblack[x] = false;\n      blackheight[x] = height(a);\n      lft[x] = a;\n      if (a != -1) par[a] = x;\n      rgt[x] = b;\n      if (b != -1) par[b] = x;\n      return x;\n    }\n    int l = disconnect(lft[b]);\n    lft[b] = joinrgt(a, x, l);\n    par[lft[b]] = b;\n    if (!isblack[b] && !isblack[lft[b]]) {\n      makeblack(b);\n      return b;\n    }\n    if (isblack[b] && isblack[lft[b]] &&\n        blackheight[b] == blackheight[lft[b]]) {\n      assert(!isblack[lft[lft[b]]]);\n      b = rotaterootrgt(b);\n      isblack[b] = false;\n      isblack[lft[b]] = true;\n      ++blackheight[lft[b]];\n      return b;\n    }\n    return b;\n  }\n  int join3(int a, int x, int b) {\n    return makeblack(height(a) >= height(b) ? joinlft(a, x, b)\n                                            : joinrgt(a, x, b));\n  }\n  int join2(int a, int b) {\n    if (a == -1)\n      return b;\n    else if (b == -1)\n      return a;\n    int c = makeblack(disconnect(lft[b])), d = makeblack(disconnect(rgt[b]));\n    return join3(join2(a, c), b, d);\n  }\n  int merge(int a, int b) { return join2(getroot(a), getroot(b)); }\n  int getroot(int a) {\n    while (a != -1 && par[a] != -1) a = par[a];\n    return a;\n  }\n};\nstruct ForestDynamicConnectivity {\n  int n;\n  BalancedBinaryForest bbf;\n  queue<int> pool;\n  void init(int _n) {\n    n = _n;\n    bbf.init(n + 2 * (n - 1));\n    for (int i = (n); i < (bbf.n); ++i) pool.push(i);\n  }\n  int getnode() {\n    assert(!pool.empty());\n    int ret = pool.front();\n    pool.pop();\n    return ret;\n  }\n  void releasenode(int x) { pool.push(x); }\n  void reroot(int a) {\n    int b, c;\n    tie(b, c) = bbf.split(a);\n    bbf.merge(a, bbf.merge(c, b));\n  }\n  pair<int, int> addedge(int a, int b) {\n    reroot(a);\n    reroot(b);\n    int ab = getnode(), ba = getnode();\n    bbf.merge(bbf.merge(a, ab), bbf.merge(b, ba));\n    return make_pair(ab, ba);\n  }\n  void remedge(pair<int, int> e) {\n    int a, b, c;\n    tie(a, b) = bbf.split(e.first);\n    if (bbf.getroot(a) == bbf.getroot(e.second)) {\n      c = b;\n      tie(a, b) = bbf.split(e.second);\n    } else {\n      tie(b, c) = bbf.split(e.second);\n    }\n    releasenode(e.first), releasenode(e.second);\n    bbf.merge(a, c);\n  }\n  bool areconnected(int a, int b) { return bbf.getroot(a) == bbf.getroot(b); }\n};\nstruct SegTreeMinCounter {\n  int n;\n  vector<int> smn, smncnt, slazy;\n  void sapply(int x, int by) {\n    smn[x] += by;\n    slazy[x] += by;\n  }\n  void spush(int x) {\n    if (slazy[x] != 0)\n      sapply(2 * x + 1, slazy[x]), sapply(2 * x + 2, slazy[x]), slazy[x] = 0;\n  }\n  void spull(int x) {\n    smn[x] = min(smn[2 * x + 1], smn[2 * x + 2]);\n    smncnt[x] = (smn[2 * x + 1] == smn[x] ? smncnt[2 * x + 1] : 0) +\n                (smn[2 * x + 2] == smn[x] ? smncnt[2 * x + 2] : 0);\n  }\n  void sinit(int x, int l, int r) {\n    slazy[x] = 0;\n    if (l == r) {\n      smn[x] = 0, smncnt[x] = 1;\n    } else {\n      int m = l + (r - l) / 2;\n      sinit(2 * x + 1, l, m);\n      sinit(2 * x + 2, m + 1, r);\n      spull(x);\n    }\n  }\n  void smod(int x, int l, int r, int L, int R, int BY) {\n    if (L <= l && r <= R) {\n      sapply(x, BY);\n    } else {\n      int m = l + (r - l) / 2;\n      spush(x);\n      if (L <= m) smod(2 * x + 1, l, m, L, R, BY);\n      if (m + 1 <= R) smod(2 * x + 2, m + 1, r, L, R, BY);\n      spull(x);\n    }\n  }\n  int sget(int x, int l, int r, int L, int R, int VAL) {\n    if (L <= l && r <= R) {\n      assert(smn[x] >= VAL);\n      return smn[x] == VAL ? smncnt[x] : 0;\n    } else {\n      int m = l + (r - l) / 2;\n      spush(x);\n      int ret = 0;\n      if (L <= m) ret += sget(2 * x + 1, l, m, L, R, VAL);\n      if (m + 1 <= R) ret += sget(2 * x + 2, m + 1, r, L, R, VAL);\n      return ret;\n    }\n  }\n  void init(int _n) {\n    n = _n;\n    smn = smncnt = slazy = vector<int>(4 * n);\n    sinit(0, 0, n - 1);\n  }\n  void mod(int l, int r, int by) { smod(0, 0, n - 1, l, r, by); }\n  int get(int l, int r, int val) { return sget(0, 0, n - 1, l, r, val); }\n};\nconst int MAXH = 1000;\nconst int MAXW = 1000;\nconst int MAXN = 200000;\nconst int DX[] = {-1, 0, +1, 0}, DY[] = {0, +1, 0, -1};\nint h, w, n;\nint g[MAXH][MAXW];\npair<int, int> pos[MAXN];\nForestDynamicConnectivity conn;\nvector<pair<int, int>> connedges[MAXN];\nSegTreeMinCounter segtree;\nlong long solve() {\n  for (int x = (0); x < (h); ++x)\n    for (int y = (0); y < (w); ++y) pos[g[x][y]] = make_pair(x, y);\n  conn.init(n);\n  segtree.init(n);\n  long long ret = 0;\n  int l = 0;\n  for (int r = (0); r < (n); ++r) {\n    int rx = pos[r].first, ry = pos[r].second;\n    for (int k = (0); k < (4); ++k) {\n      int nx = rx + DX[k], ny = ry + DY[k];\n      if (nx < 0 || nx >= h || ny < 0 || ny >= w || g[nx][ny] < l ||\n          g[nx][ny] > r)\n        continue;\n      while (conn.areconnected(r, g[nx][ny])) {\n        for (int i = (0); i < (((int)(connedges[l]).size())); ++i)\n          conn.remedge(connedges[l][i]);\n        ++l;\n      }\n      connedges[g[nx][ny]].push_back(conn.addedge(g[nx][ny], r));\n      segtree.mod(0, g[nx][ny], -1);\n    }\n    segtree.mod(0, r, +1);\n    int cur = segtree.get(l, r, 1);\n    ret += cur;\n  }\n  return ret;\n}\nvoid run() {\n  scanf(\"%d%d\", &h, &w);\n  n = h * w;\n  for (int x = (0); x < (h); ++x)\n    for (int y = (0); y < (w); ++y) scanf(\"%d\", &g[x][y]), --g[x][y];\n  printf(\"%lld\\n\", solve());\n}\nint main() {\n  run();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Point {\n  int x, y;\n  Point(){};\n  Point(int a, int b) { x = a, y = b; }\n} pos[200010];\nstruct LinkCutTree {\n  struct Splay {\n    int ch[2], fa;\n    bool rev;\n  } t[200010];\n  int sta[200010];\n  bool notroot(int u) { return t[t[u].fa].ch[0] == u || t[t[u].fa].ch[1] == u; }\n  bool get(int u) { return t[t[u].fa].ch[1] == u; }\n  void up(int u) {}\n  void downn(int u) {\n    swap(t[u].ch[0], t[u].ch[1]);\n    t[u].rev ^= 1;\n  }\n  void down(int u) {\n    if (t[u].rev) {\n      downn(t[u].ch[0]), downn(t[u].ch[1]);\n      t[u].rev = 0;\n    }\n  }\n  void rotate(int u) {\n    int fa = t[u].fa, gfa = t[fa].fa;\n    bool d1 = get(u), d2 = get(fa);\n    t[u].fa = gfa;\n    if (notroot(fa)) t[gfa].ch[d2] = u;\n    int son = t[u].ch[d1 ^ 1];\n    t[u].ch[d1 ^ 1] = fa;\n    t[fa].fa = u;\n    t[fa].ch[d1] = son;\n    t[son].fa = fa;\n    up(fa);\n  }\n  void splay(int u) {\n    int now = u, top = 0;\n    sta[++top] = now;\n    while (notroot(now)) sta[++top] = now = t[now].fa;\n    while (top) down(sta[top]), top--;\n    while (notroot(u)) {\n      int fa = t[u].fa;\n      if (notroot(fa)) {\n        if (get(u) == get(fa))\n          rotate(fa);\n        else\n          rotate(u);\n      }\n      rotate(u);\n    }\n    up(u);\n  }\n  void access(int u) {\n    for (int v = 0; u; v = u, u = t[u].fa) {\n      splay(u);\n      t[u].ch[1] = v;\n      up(u);\n    }\n  }\n  void makeroot(int u) {\n    access(u);\n    splay(u);\n    downn(u);\n  }\n  int findroot(int u) {\n    access(u);\n    splay(u);\n    while (t[u].ch[0]) {\n      down(u);\n      u = t[u].ch[0];\n    }\n    splay(u);\n    return u;\n  }\n  void link(int x, int y) {\n    makeroot(x);\n    t[x].fa = y;\n  }\n  void cut(int x, int y) {\n    makeroot(x);\n    findroot(y);\n    t[x].ch[1] = t[y].fa = 0;\n    up(x);\n  }\n  bool connected(int x, int y) {\n    makeroot(x);\n    return findroot(y) == x;\n  }\n} lct;\nstruct SegmentTree {\n  struct data {\n    int val, num;\n    data(){};\n    data(int a, int b) { val = a, num = b; }\n  } minn[200010 << 2];\n  int lazy[200010 << 2];\n  void up(int k) {\n    if (minn[k << 1].val < minn[k << 1 | 1].val)\n      minn[k] = minn[k << 1];\n    else if (minn[k << 1].val > minn[k << 1 | 1].val)\n      minn[k] = minn[k << 1 | 1];\n    else\n      minn[k] = minn[k << 1], minn[k].num += minn[k << 1 | 1].num;\n  }\n  void downn(int k, int v) {\n    minn[k].val += v;\n    lazy[k] += v;\n  }\n  void down(int k) {\n    if (lazy[k]) {\n      downn(k << 1, lazy[k]), downn(k << 1 | 1, lazy[k]);\n      lazy[k] = 0;\n    }\n  }\n  void build(int k, int l, int r) {\n    if (l == r) {\n      minn[k] = data(0, 1);\n      return;\n    }\n    int mid = (l + r) >> 1;\n    build(k << 1, l, mid);\n    build(k << 1 | 1, mid + 1, r);\n    up(k);\n  }\n  void update(int k, int l, int r, int ql, int qr, int v) {\n    if (ql <= l && r <= qr) {\n      downn(k, v);\n      return;\n    }\n    down(k);\n    int mid = (l + r) >> 1;\n    if (ql <= mid) update(k << 1, l, mid, ql, qr, v);\n    if (qr > mid) update(k << 1 | 1, mid + 1, r, ql, qr, v);\n    up(k);\n  }\n  int query(int k, int l, int r, int ql, int qr) {\n    if (ql <= l && r <= qr) {\n      if (minn[k].val == 1) return minn[k].num;\n      return 0;\n    }\n    down(k);\n    int mid = (l + r) >> 1, ans = 0;\n    if (ql <= mid) ans += query(k << 1, l, mid, ql, qr);\n    if (qr > mid) ans += query(k << 1 | 1, mid + 1, r, ql, qr);\n    return ans;\n  }\n} seg;\nint n, m, a[1010][1010], id[1010][1010];\nint fx[] = {-1, 0, 1, 0}, fy[] = {0, 1, 0, -1};\nint minn[200010 << 2], num[200010 << 2];\nlong long ans;\nbool check(int v, int l, int r) {\n  for (int i = 0; i < 4; i++) {\n    int xi = pos[v].x + fx[i], yi = pos[v].y + fy[i];\n    if (xi < 1 || xi > n || yi < 1 || yi > m || a[xi][yi] < l || a[xi][yi] > r)\n      continue;\n    for (int j = i + 1; j < 4; j++) {\n      int xj = pos[v].x + fx[j], yj = pos[v].y + fy[j];\n      if (xj < 1 || xj > n || yj < 1 || yj > m || a[xj][yj] < l ||\n          a[xj][yj] > r)\n        continue;\n      if (lct.connected(id[xi][yi], id[xj][yj])) return true;\n    }\n  }\n  return false;\n}\nvoid del(int v, int l, int r) {\n  for (int i = 0; i < 4; i++) {\n    int xx = pos[v].x + fx[i], yy = pos[v].y + fy[i];\n    if (xx < 1 || xx > n || yy < 1 || yy > m || a[xx][yy] < l || a[xx][yy] > r)\n      continue;\n    lct.cut(id[pos[v].x][pos[v].y], id[xx][yy]);\n  }\n}\nvoid add(int v, int l, int r) {\n  for (int i = 0; i < 4; i++) {\n    int xx = pos[v].x + fx[i], yy = pos[v].y + fy[i];\n    if (xx < 1 || xx > n || yy < 1 || yy > m || a[xx][yy] < l || a[xx][yy] > r)\n      continue;\n    seg.update(1, 1, n * m, a[xx][yy], n * m, -1);\n    lct.link(id[pos[v].x][pos[v].y], id[xx][yy]);\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      scanf(\"%d\", &a[i][j]);\n      pos[a[i][j]] = Point(i, j);\n      id[i][j] = (i - 1) * m + j;\n    }\n  }\n  seg.build(1, 1, n * m);\n  int l, r = n * m;\n  for (l = n * m; l >= 1; l--) {\n    while (l < r && check(l, l + 1, r)) {\n      del(r, l + 1, r - 1);\n      r--;\n    }\n    seg.update(1, 1, n * m, l, r, 1);\n    add(l, l + 1, r);\n    ans += seg.query(1, 1, n * m, l, r);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nint n, m, a[2005][2005], pos[250005], dx[] = {0, 0, 1, -1},\n                                      dy[] = {1, -1, 0, 0};\nlong long ans = 0;\nvector<pair<int, int> > e[200005];\nint read() {\n  int f = 0, w = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') w = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    f = f * 10 + ch - '0';\n    ch = getchar();\n  }\n  return f * w;\n}\nbool inmap(int x, int y) {\n  if (x < 1 || x > n || y < 1 || y > m) return 0;\n  return 1;\n}\nint ch[200005][2], rev[200005], fa[200005];\nint chk(int x) { return ch[fa[x]][1] == x; }\nint isroot(int x) { return (ch[fa[x]][0] != x) && (ch[fa[x]][1] != x); }\nvoid pushdown(int x) {\n  if (rev[x]) {\n    rev[ch[x][0]] ^= 1;\n    rev[ch[x][1]] ^= 1;\n    swap(ch[x][0], ch[x][1]);\n    rev[x] = 0;\n  }\n}\nvoid pd(int x) {\n  if (!isroot(x)) pd(fa[x]);\n  pushdown(x);\n}\nvoid rotate(int x) {\n  int y = fa[x], z = fa[y], t = chk(x);\n  if (!isroot(y)) ch[z][chk(y)] = x;\n  fa[x] = z;\n  ch[y][t] = ch[x][t ^ 1];\n  fa[ch[x][t ^ 1]] = y;\n  ch[x][t ^ 1] = y;\n  fa[y] = x;\n}\nvoid splay(int x) {\n  pd(x);\n  while (!isroot(x)) {\n    int y = fa[x];\n    if (!isroot(y)) rotate(chk(y) == chk(x) ? y : x);\n    rotate(x);\n  }\n}\nvoid access(int x) {\n  for (int y = 0; x; y = x, x = fa[x]) {\n    splay(x);\n    ch[x][1] = y;\n  }\n}\nvoid makeroot(int x) {\n  access(x);\n  splay(x);\n  rev[x] ^= 1;\n}\nint findroot(int x) {\n  access(x);\n  splay(x);\n  while (ch[x][0]) x = ch[x][0];\n  return x;\n}\nvoid link(int x, int y) {\n  makeroot(x);\n  if (findroot(y) != x) fa[x] = y;\n}\nvoid split(int x, int y) {\n  makeroot(x);\n  access(y);\n  splay(y);\n}\nvoid cut(int x, int y) {\n  split(x, y);\n  if (ch[y][0] == x) ch[y][0] = 0, fa[x] = 0;\n}\nstruct node {\n  int minn, cnt, lazy;\n} tree[800005];\nvoid pushup(int tr) {\n  if (tree[tr * 2].minn > tree[tr * 2 + 1].minn) {\n    tree[tr].minn = tree[tr * 2 + 1].minn;\n    tree[tr].cnt = tree[tr * 2 + 1].cnt;\n  } else if (tree[tr * 2].minn < tree[tr * 2 + 1].minn) {\n    tree[tr].minn = tree[tr * 2].minn;\n    tree[tr].cnt = tree[tr * 2].cnt;\n  } else {\n    tree[tr].minn = tree[tr * 2].minn;\n    tree[tr].cnt = tree[tr * 2].cnt + tree[tr * 2 + 1].cnt;\n  }\n}\nvoid pushdown1(int tr) {\n  tree[tr * 2].lazy += tree[tr].lazy;\n  tree[tr * 2 + 1].lazy += tree[tr].lazy;\n  tree[tr * 2].minn += tree[tr].lazy;\n  tree[tr * 2 + 1].minn += tree[tr].lazy;\n  tree[tr].lazy = 0;\n}\nvoid build(int tr, int l, int r) {\n  if (l == r) {\n    tree[tr].minn = 0;\n    tree[tr].cnt = 1;\n    return;\n  }\n  int mid = (l + r) / 2;\n  build(tr * 2, l, mid), build(tr * 2 + 1, mid + 1, r);\n  pushup(tr);\n}\npair<int, int> query(int tr, int stdl, int stdr, int l, int r) {\n  if (l > stdr || r < stdl) return make_pair(inf, 0);\n  if (l <= stdl && r >= stdr) return make_pair(tree[tr].minn, tree[tr].cnt);\n  pushdown1(tr);\n  int mid = (stdl + stdr) / 2;\n  pair<int, int> p1 = query(tr * 2, stdl, mid, l, r),\n                 p2 = query(tr * 2 + 1, mid + 1, stdr, l, r);\n  if (p1.first > p2.first)\n    return p2;\n  else if (p1.first < p2.first)\n    return p1;\n  else\n    return make_pair(p1.first, p1.second + p2.second);\n}\nvoid modify(int tr, int stdl, int stdr, int l, int r, int k) {\n  if (l > stdr || r < stdl) return;\n  if (l <= stdl && r >= stdr) {\n    tree[tr].minn += k;\n    tree[tr].lazy += k;\n    return;\n  }\n  pushdown1(tr);\n  int mid = (stdl + stdr) / 2;\n  modify(tr * 2, stdl, mid, l, r, k),\n      modify(tr * 2 + 1, mid + 1, stdr, l, r, k);\n  pushup(tr);\n}\nint main() {\n  n = read(), m = read();\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      a[i][j] = read(), pos[a[i][j]] = (i - 1) * m + j;\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      for (int k = 0; k < 4; k++) {\n        int x = i + dx[k], y = j + dy[k];\n        e[(i - 1) * m + j].push_back(make_pair((x - 1) * m + y, a[x][y]));\n      }\n  int hd = 1, tl = 1;\n  build(1, 1, n * m);\n  modify(1, 1, n * m, 1, n * m, 1);\n  while (hd <= n * m) {\n    while (tl < n * m) {\n      int cnt = 0;\n      for (int i = 0; i < e[pos[tl + 1]].size(); i++)\n        if (e[pos[tl + 1]][i].second >= hd && e[pos[tl + 1]][i].second <= tl)\n          cnt++;\n      if (!cnt) {\n        modify(1, 1, n * m, ++tl, n * m, 1);\n        continue;\n      } else {\n        int p = 0, flag = 0;\n        for (int i = 0; i < e[pos[tl + 1]].size(); i++, p++) {\n          if (e[pos[tl + 1]][i].second >= hd &&\n              e[pos[tl + 1]][i].second <= tl) {\n            if (findroot(e[pos[tl + 1]][i].first) == findroot(pos[tl + 1])) {\n              flag = 1;\n              break;\n            } else\n              link(e[pos[tl + 1]][i].first, pos[tl + 1]);\n          }\n        }\n        if (flag) {\n          for (int i = p - 1; i >= 0; i--)\n            if (e[pos[tl + 1]][i].second >= hd &&\n                e[pos[tl + 1]][i].second <= tl)\n              cut(e[pos[tl + 1]][i].first, pos[tl + 1]);\n          break;\n        }\n        modify(1, 1, n * m, ++tl, n * m, 1 - cnt);\n      }\n    }\n    pair<int, int> now = query(1, 1, n * m, hd, tl);\n    if (now.first == 1) ans += now.second;\n    vector<pair<int, int> > tmp;\n    for (int i = 0; i < e[pos[hd]].size(); i++)\n      if (e[pos[hd]][i].second >= hd && e[pos[hd]][i].second <= tl) {\n        tmp.push_back(make_pair(e[pos[hd]][i].second, e[pos[hd]][i].first));\n        cut(pos[hd], e[pos[hd]][i].first);\n      }\n    if (!tmp.size())\n      modify(1, 1, n * m, hd + 1, n * m, -1);\n    else {\n      sort(tmp.begin(), tmp.end());\n      for (int i = 0; i < tmp.size(); i++) {\n        int l, r;\n        if (!i)\n          l = hd + 1;\n        else\n          l = tmp[i - 1].first;\n        r = tmp[i].first - 1;\n        modify(1, 1, n * m, l, r, i - 1);\n      }\n      modify(1, 1, n * m, tmp[tmp.size() - 1].first, n * m, tmp.size() - 1);\n    }\n    hd++;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 3e5 + 5;\nvector<int> adj[N];\nint cyc[N], rdeg[N], deg[N];\nint par[N], s[N];\nvector<int> hist, lst = {0};\ninline int qry(int x) { return x == par[x] ? x : qry(par[x]); }\nint join(int x, int y) {\n  if ((x = qry(x)) == (y = qry(y))) return 1;\n  if (s[x] > s[y]) swap(x, y);\n  s[y] += s[x], par[x] = y;\n  hist.push_back(x);\n  return 0;\n}\ninline void snapshot() { lst.push_back((int)(hist).size()); }\ninline void rollback() {\n  while ((int)(hist).size() > lst.back()) {\n    int x = hist.back();\n    s[par[x]] -= s[x], par[x] = x;\n    hist.pop_back();\n  }\n  lst.pop_back();\n}\nint n;\nint itL[N], itR[N];\nvoid solve(int l, int r, int oL = 1, int oR = n) {\n  if (l > r) return;\n  snapshot();\n  int m = (l + r) / 2;\n  for (int i = min(r - 1, oL); i >= m; i--)\n    for (int j = itL[i]; j < (int)(adj[i]).size() && adj[i][j] <= oL; j++)\n      join(i, adj[i][j]);\n  cyc[m] = oR;\n  for (int i = max(m, oL + 1); i <= oR; i++) {\n    int ok = 0;\n    for (int j = itR[i]; j >= 0 && ok == 0 && adj[i][j] >= m; j--)\n      ok += join(i, adj[i][j]);\n    if (ok) {\n      cyc[m] = i - 1;\n      break;\n    }\n  }\n  rollback();\n  snapshot();\n  for (int i = min(r - 1, oL); i >= m - 1; i--)\n    for (int j = itL[i]; j < (int)(adj[i]).size() && adj[i][j] <= oL; j++)\n      join(i, adj[i][j]);\n  solve(l, m - 1, oL, cyc[m]);\n  rollback();\n  snapshot();\n  for (int i = max(r, oL + 1); i <= cyc[m]; i++)\n    for (int j = itR[i]; j >= 0 && adj[i][j] >= r; j--) join(i, adj[i][j]);\n  solve(m + 1, r, cyc[m], oR);\n  rollback();\n}\npair<int, int> seg[N * 4];\nint lz[N * 4];\nvoid build(int l, int r, int k) {\n  if (l == r) {\n    seg[k] = make_pair(l, 1);\n    return;\n  }\n  int m = (l + r) / 2;\n  build(l, m, k * 2);\n  build(m + 1, r, k * 2 + 1);\n  seg[k] = min(seg[k * 2], seg[k * 2 + 1]);\n  if (seg[k * 2].first == seg[k * 2 + 1].first)\n    seg[k].second = seg[k * 2].second + seg[k * 2 + 1].second;\n}\nvoid upd(int l, int r, int k, int x, int y, int v) {\n  if (y < l || r < x) return;\n  if (x <= l && r <= y) {\n    lz[k] += v;\n    seg[k].first += v;\n    return;\n  }\n  int m = (l + r) / 2;\n  upd(l, m, k * 2, x, y, v);\n  upd(m + 1, r, k * 2 + 1, x, y, v);\n  seg[k] = min(seg[k * 2], seg[k * 2 + 1]);\n  if (seg[k * 2].first == seg[k * 2 + 1].first)\n    seg[k].second = seg[k * 2].second + seg[k * 2 + 1].second;\n  seg[k].first += lz[k];\n}\npair<int, int> qry(int l, int r, int k, int x, int y) {\n  if (y < l || r < x) return make_pair(N, 1);\n  if (x <= l && r <= y) return seg[k];\n  int m = (l + r) / 2;\n  pair<int, int> lx = qry(l, m, k * 2, x, y);\n  pair<int, int> rx = qry(m + 1, r, k * 2 + 1, x, y);\n  if (lx.first == rx.first)\n    lx.second += rx.second;\n  else if (lx.first > rx.first)\n    swap(lx, rx);\n  lx.first += lz[k];\n  return lx;\n}\nint dx[4] = {0, 1};\nint dy[4] = {1, 0};\nint a[1005][1005];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  int _n, _m;\n  cin >> _n >> _m;\n  n = _n * _m;\n  auto get_index = [&](int i, int j) { return a[i][j]; };\n  for (int i = 1; i <= _n; i++)\n    for (int j = 1; j <= _m; j++) cin >> a[i][j];\n  for (int i = 1; i <= _n; i++) {\n    for (int j = 1; j <= _m; j++) {\n      for (int k = 0; k < 2; k++) {\n        int ni = i + dx[k], nj = j + dy[k];\n        if (!ni || !nj || ni > _n || nj > _m) continue;\n        adj[get_index(i, j)].push_back(get_index(ni, nj));\n        adj[get_index(ni, nj)].push_back(get_index(i, j));\n      }\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    par[i] = i, s[i] = 1;\n    sort((adj[i]).begin(), (adj[i]).end());\n    itL[i] = lower_bound((adj[i]).begin(), (adj[i]).end(), i) - adj[i].begin();\n    itR[i] =\n        upper_bound((adj[i]).begin(), (adj[i]).end(), i) - adj[i].begin() - 1;\n  }\n  solve(1, n);\n  build(1, n, 1);\n  long long ans = 0;\n  for (int i = 1; i <= n; i++)\n    for (int j = itL[i]; j < (int)(adj[i]).size(); j++)\n      upd(1, n, 1, adj[i][j], n, -1);\n  for (int i = 1, j = 1; i <= n; i++) {\n    ans += qry(1, n, 1, i, cyc[i]).second;\n    for (int j = itL[i]; j < (int)(adj[i]).size(); j++)\n      upd(1, n, 1, adj[i][j], n, +1);\n    upd(1, n, 1, 1, n, -1);\n  }\n  cout << ans << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nint mat[1009][1009];\nint f[200009], ch[200009][2], rv[200009], st[200009];\nint l[800009], r[800009], mn[800009], sm[800009], lz[800009];\npair<int, int> pos[200009];\nint dk[5][2] = {{}, {1, 0}, {-1, 0}, {0, 1}, {0, -1}};\nvoid rot(int x) {\n  int y = f[x], z = f[y], dx = x == ch[y][1], dy = y == ch[z][1];\n  if (y == ch[f[y]][1] || y == ch[f[y]][0]) ch[z][dy] = x;\n  f[x] = z;\n  f[y] = x;\n  f[ch[x][dx ^ 1]] = y;\n  ch[y][dx] = ch[x][dx ^ 1];\n  ch[x][dx ^ 1] = y;\n}\nvoid down(int x) {\n  if (rv[x])\n    swap(ch[x][0], ch[x][1]), rv[ch[x][0]] ^= 1, rv[ch[x][1]] ^= 1, rv[x] = 0;\n}\nvoid splay(int x) {\n  int y, z, tp = 0;\n  for (y = x; y == ch[f[y]][1] || y == ch[f[y]][0]; y = f[y]) st[++tp] = y;\n  st[++tp] = y;\n  for (int i = tp; i >= 1; i--) down(st[i]);\n  while (x == ch[f[x]][1] || x == ch[f[x]][0]) {\n    y = f[x], z = f[y];\n    if (y == ch[f[y]][1] || y == ch[f[y]][0])\n      rot((x == ch[y][1]) ^ (y == ch[z][1]) ? x : y);\n    rot(x);\n  }\n}\nvoid access(int x) {\n  for (int y = 0; x; y = x, x = f[x]) {\n    splay(x);\n    ch[x][1] = y;\n  }\n}\nint findrt(int x) {\n  access(x);\n  splay(x);\n  down(x);\n  while (ch[x][0]) down(x = ch[x][0]);\n  splay(x);\n  return x;\n}\nvoid makert(int x) {\n  access(x);\n  splay(x);\n  rv[x] ^= 1;\n}\nint lnk(int x, int y) {\n  makert(y);\n  if (findrt(x) == y) return 0;\n  f[y] = x;\n  return 1;\n}\nint cut(int x, int y) {\n  makert(x);\n  if (findrt(y) == x && f[y] == x && !ch[y][0]) {\n    f[y] = ch[x][1] = 0;\n    return 1;\n  }\n  return 0;\n}\nint judge(int x, int y) { return findrt(x) == findrt(y); }\nvoid downs(int a) {\n  if (!lz[a]) return;\n  int la = a << 1, ra = a << 1 | 1, t = lz[a];\n  mn[la] += t, mn[ra] += t;\n  lz[la] += t, lz[ra] += t;\n  lz[a] = 0;\n}\nvoid upd(int a) {\n  int la = a << 1, ra = a << 1 | 1;\n  if (mn[la] == mn[ra])\n    mn[a] = mn[la], sm[a] = sm[la] + sm[ra];\n  else {\n    mn[a] = min(mn[la], mn[ra]);\n    sm[a] = mn[la] < mn[ra] ? sm[la] : sm[ra];\n  }\n}\nvoid build(int a, int ll, int rr) {\n  l[a] = ll;\n  r[a] = rr;\n  mn[a] = 0x7F7F7F7F;\n  sm[a] = 1;\n  if (ll < rr) {\n    int mid = (ll + rr) >> 1;\n    build(a << 1, ll, mid);\n    build(a << 1 | 1, mid + 1, rr);\n    upd(a);\n  }\n}\nvoid add(int a, int ll, int rr, int val) {\n  if (l[a] > rr || r[a] < ll) return;\n  if (l[a] >= ll && r[a] <= rr) {\n    mn[a] += val;\n    lz[a] += val;\n    return;\n  }\n  downs(a);\n  add(a << 1, ll, rr, val);\n  add(a << 1 | 1, ll, rr, val);\n  upd(a);\n}\nint ask(int a, int ll, int rr) {\n  if (l[a] > rr || r[a] < ll) return 0;\n  if (l[a] >= ll && r[a] <= rr) {\n    if (mn[a] != 1) return 0;\n    return sm[a];\n  }\n  downs(a);\n  return ask(a << 1, ll, rr) + ask(a << 1 | 1, ll, rr);\n}\nint test(int lp, int rp) {\n  int px = pos[lp].first, py = pos[lp].second;\n  int tmp[5], tp = 0;\n  for (int i = 1; i <= 4; i++) {\n    int np = mat[px + dk[i][0]][py + dk[i][1]];\n    if (np >= lp && np <= rp) tmp[++tp] = np;\n  }\n  for (int i = 1; i <= tp - 1; i++) {\n    makert(tmp[i]);\n    for (int j = i + 1; j <= tp; j++)\n      if (findrt(tmp[j]) == tmp[i]) return 0;\n  }\n  return 1;\n}\nvoid solve() {\n  build(1, 1, n * m);\n  int rp = n * m;\n  long long ans = 0;\n  for (int lp = n * m; lp >= 1; lp--) {\n    while (!test(lp, rp)) {\n      int rx = pos[rp].first, ry = pos[rp].second;\n      for (int i = 1; i <= 4; i++) {\n        int np = mat[rx + dk[i][0]][ry + dk[i][1]];\n        if (np >= lp && np <= rp) cut(rp, np);\n      }\n      rp--;\n    }\n    int lx = pos[lp].first, ly = pos[lp].second;\n    for (int i = 1; i <= 4; i++) {\n      int np = mat[lx + dk[i][0]][ly + dk[i][1]];\n      if (np >= lp && np <= rp) lnk(lp, np);\n    }\n    add(1, lp, lp, -0x7F7F7F7F);\n    add(1, lp, rp, 1);\n    for (int i = 1; i <= 4; i++) {\n      int np = mat[lx + dk[i][0]][ly + dk[i][1]];\n      if (np >= lp && np <= rp) add(1, np, rp, -1);\n    }\n    ans += ask(1, lp, rp);\n  }\n  printf(\"%I64d\", ans);\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) {\n      scanf(\"%d\", mat[i] + j);\n      pos[mat[i][j]] = pair<int, int>(i, j);\n    }\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1001, M = 2e5 + 1;\nstruct LCT {\n  int f[M], ch[M][2];\n  bool rev[M];\n  bool isroot(int x) { return (ch[f[x]][0] != x) && (ch[f[x]][1] != x); }\n  void Rev(int x) {\n    swap(ch[x][0], ch[x][1]);\n    rev[x] ^= 1;\n  }\n  void down(int x) {\n    if (rev[x]) {\n      Rev(ch[x][0]), Rev(ch[x][1]);\n      rev[x] = 0;\n    }\n  }\n  void pushdown(int x) {\n    if (f[x]) pushdown(f[x]);\n    down(x);\n  }\n  void rotate(int x) {\n    int y = f[x], z = f[y], k = (ch[z][1] == y), d = (ch[y][1] == x);\n    if (!isroot(y)) {\n      ch[z][k] = x;\n    }\n    f[x] = z;\n    ch[y][d] = ch[x][d ^ 1], f[ch[x][d ^ 1]] = y;\n    ch[x][d ^ 1] = y, f[y] = x;\n  }\n  void splay(int x) {\n    pushdown(x);\n    while (!isroot(x)) {\n      int y = f[x], z = f[y];\n      if (!isroot(y)) (ch[z][1] == y) ^ (ch[y][1] == x) ? rotate(x) : rotate(y);\n      rotate(x);\n    }\n  }\n  void access(int x) {\n    for (int y = 0; x; y = x, x = f[x]) {\n      splay(x);\n      ch[x][1] = y;\n    }\n  }\n  void makeroot(int x) {\n    access(x);\n    splay(x);\n    Rev(x);\n  }\n  int findroot(int x) {\n    access(x);\n    splay(x);\n    for (; ch[x][0]; down(x), x = ch[x][0]) {\n      splay(x);\n    }\n    return x;\n  }\n  void split(int x, int y) {\n    makeroot(x);\n    access(y);\n    splay(y);\n  }\n  void link(int x, int y) { makeroot(x), f[x] = y; }\n  void cut(int x, int y) { split(x, y), f[x] = ch[y][0] = 0; }\n} T;\nint sum[M << 2], tag[M << 2], v[M << 2];\nint maxn, num;\nvoid up(int x) {\n  v[x] = min(v[x << 1], v[x << 1 | 1]), sum[x] = 0;\n  if (v[x << 1] == v[x]) sum[x] += sum[x << 1];\n  if (v[x << 1 | 1] == v[x]) sum[x] += sum[x << 1 | 1];\n}\nvoid down(int x) {\n  if (tag[x]) {\n    tag[x << 1] += tag[x], v[x << 1] += tag[x];\n    tag[x << 1 | 1] += tag[x], v[x << 1 | 1] += tag[x];\n    tag[x] = 0;\n  }\n}\nvoid check(int x) {\n  if (v[x] < maxn) {\n    maxn = v[x], num = sum[x];\n  } else if (v[x] == maxn) {\n    num += sum[x];\n  }\n}\nvoid build(int x, int l, int r) {\n  if (l == r) {\n    sum[x] = r - l + 1;\n    v[x] = 0;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  build(x << 1, l, mid), build(x << 1 | 1, mid + 1, r);\n  up(x);\n}\nvoid change(int x, int l, int r, int L, int R, int w) {\n  if (L <= l && r <= R) {\n    tag[x] += w;\n    v[x] += w;\n    return;\n  }\n  down(x);\n  int mid = (l + r) >> 1;\n  if (L <= mid) change(x << 1, l, mid, L, R, w);\n  if (R > mid) change(x << 1 | 1, mid + 1, r, L, R, w);\n  up(x);\n}\nvoid ask(int x, int l, int r, int L, int R) {\n  if (L <= l && r <= R) {\n    check(x);\n    return;\n  }\n  down(x);\n  int mid = (l + r) >> 1;\n  if (L <= mid) ask(x << 1, l, mid, L, R);\n  if (R > mid) ask(x << 1 | 1, mid + 1, r, L, R);\n  up(x);\n}\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint a[N][N], idx[M], idy[M];\nint n, m, nowl = 1, nowr = 1, p[10];\nbool judge() {\n  p[0] = 0;\n  for (int i = 0; i < 4; ++i) {\n    int x = idx[nowr + 1] + dx[i], y = idy[nowr + 1] + dy[i];\n    if (!x || !y || x > n || y > m || a[x][y] < nowl || a[x][y] > nowr) {\n      continue;\n    }\n    p[++p[0]] = T.findroot(a[x][y]);\n  }\n  sort(p + 1, p + 1 + p[0]);\n  for (int i = 1; i < p[0]; ++i)\n    if (p[i] == p[i + 1]) return false;\n  return true;\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j) {\n      scanf(\"%d\", &a[i][j]);\n      idx[a[i][j]] = i, idy[a[i][j]] = j;\n    }\n  build(1, 1, n * m), change(1, 1, n * m, 1, 1, 1);\n  long long ans = 1;\n  for (; nowr < n * m;) {\n    for (; nowl < nowr && !judge(); ++nowl) {\n      for (int i = 0; i < 4; ++i) {\n        int x = idx[nowl] + dx[i], y = idy[nowl] + dy[i];\n        if (!x || !y || x > n || y > m || a[x][y] < nowl || a[x][y] > nowr) {\n          continue;\n        }\n        T.cut(nowl, a[x][y]);\n      }\n    }\n    ++nowr, change(1, 1, n * m, nowl, nowr, 1);\n    for (int i = 0; i < 4; ++i) {\n      int x = idx[nowr] + dx[i], y = idy[nowr] + dy[i];\n      if (!x || !y || x > n || y > m || a[x][y] < nowl || a[x][y] > nowr) {\n        continue;\n      }\n      T.link(nowr, a[x][y]), change(1, 1, n * m, nowl, a[x][y], -1);\n    }\n    maxn = 1e9, num = 0;\n    ask(1, 1, n * m, nowl, nowr);\n    ans += (maxn == 1) * num;\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1005;\nconst int MAXM = 2e5 + 5;\nconst int dx[4] = {0, 0, 1, -1};\nconst int dy[4] = {1, -1, 0, 0};\ntemplate <typename T>\nvoid chkmax(T &x, T y) {\n  x = max(x, y);\n}\ntemplate <typename T>\nvoid chkmin(T &x, T y) {\n  x = min(x, y);\n}\ntemplate <typename T>\nvoid read(T &x) {\n  x = 0;\n  int f = 1;\n  char c = getchar();\n  for (; !isdigit(c); c = getchar())\n    if (c == '-') f = -f;\n  for (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n  x *= f;\n}\nstruct LinkCutTree {\n  struct Node {\n    int child[2];\n    int father, up;\n    bool rev;\n  } a[MAXM];\n  int size;\n  void pushdown(int root) {\n    if (a[root].rev) {\n      swap(a[root].child[0], a[root].child[1]);\n      if (a[root].child[0]) a[a[root].child[0]].rev ^= true;\n      if (a[root].child[1]) a[a[root].child[1]].rev ^= true;\n      a[root].rev = false;\n    }\n  }\n  bool get(int root) { return a[a[root].father].child[1] == root; }\n  void rotate(int x) {\n    int f = a[x].father, g = a[f].father;\n    pushdown(f);\n    pushdown(x);\n    bool tmp = get(x), tnp = get(f);\n    a[a[x].child[tmp ^ 1]].father = f;\n    a[f].child[tmp] = a[x].child[tmp ^ 1];\n    a[x].child[tmp ^ 1] = f;\n    a[f].father = x;\n    a[x].father = g;\n    if (g != 0) a[g].child[tnp] = x;\n    a[x].up = a[f].up;\n    a[f].up = 0;\n  }\n  void splay(int x) {\n    pushdown(x);\n    for (int f = a[x].father; (f = a[x].father) != 0; rotate(x)) {\n      pushdown(f);\n      pushdown(x);\n      if (a[f].father != 0) {\n        if (get(f) == get(x))\n          rotate(f);\n        else\n          rotate(x);\n      }\n    }\n  }\n  void access(int x) {\n    splay(x);\n    int tmp = a[x].child[1];\n    a[x].child[1] = 0;\n    a[tmp].father = 0;\n    a[tmp].up = x;\n    while (a[x].up) {\n      int f = a[x].up;\n      splay(f);\n      tmp = a[f].child[1];\n      a[f].child[1] = x;\n      a[x].father = f;\n      a[x].up = 0;\n      a[tmp].father = 0;\n      a[tmp].up = f;\n      splay(x);\n    }\n  }\n  int findroot(int x) {\n    access(x);\n    splay(x);\n    pushdown(x);\n    while (a[x].child[0]) {\n      x = a[x].child[0];\n      pushdown(x);\n    }\n    splay(x);\n    return x;\n  }\n  void makeroot(int x) {\n    access(x);\n    splay(x);\n    a[x].rev ^= true;\n    pushdown(x);\n  }\n  void init(int n) {\n    for (int i = 1; i <= n; i++) {\n      size++;\n      a[size].child[0] = 0;\n      a[size].child[1] = 0;\n      a[size].up = 0;\n      a[size].father = 0;\n    }\n  }\n  bool query(int x, int y) { return findroot(x) != findroot(y); }\n  void link(int x, int y) {\n    if (findroot(x) == findroot(y)) assert(false);\n    makeroot(x);\n    access(y);\n    splay(y);\n    a[x].father = y;\n    a[y].child[1] = x;\n  }\n  void cut(int x, int y) {\n    if (findroot(x) != findroot(y)) assert(false);\n    makeroot(x);\n    access(y);\n    splay(x);\n    if (a[x].child[1] != y) assert(false);\n    a[x].child[1] = 0;\n    a[y].father = 0;\n  }\n} LCT;\nstruct info {\n  int Min, cnt;\n};\ninfo operator+(info a, info b) {\n  info ans;\n  ans.cnt = 0;\n  ans.Min = min(a.Min, b.Min);\n  if (ans.Min == a.Min) ans.cnt += a.cnt;\n  if (ans.Min == b.Min) ans.cnt += b.cnt;\n  return ans;\n}\nstruct SegmentTree {\n  struct Node {\n    int lc, rc;\n    int tag;\n    info ans;\n  } a[MAXM * 2];\n  int n, root, size;\n  void update(int root) { a[root].ans = a[a[root].lc].ans + a[a[root].rc].ans; }\n  void build(int &root, int l, int r) {\n    root = ++size;\n    if (l == r) {\n      a[root].ans = (info){l, 1};\n      return;\n    }\n    int mid = (l + r) / 2;\n    build(a[root].lc, l, mid);\n    build(a[root].rc, mid + 1, r);\n    update(root);\n  }\n  void init(int x) {\n    n = x, size = root = 0;\n    build(root, 1, n);\n  }\n  void pushdown(int root) {\n    if (a[root].tag) {\n      a[a[root].lc].tag += a[root].tag;\n      a[a[root].lc].ans.Min += a[root].tag;\n      a[a[root].rc].tag += a[root].tag;\n      a[a[root].rc].ans.Min += a[root].tag;\n      a[root].tag = 0;\n    }\n  }\n  void add(int root, int l, int r, int ql, int qr, int d) {\n    if (l == ql && r == qr) {\n      a[root].ans.Min += d;\n      a[root].tag += d;\n      return;\n    }\n    pushdown(root);\n    int mid = (l + r) / 2;\n    if (mid >= ql) add(a[root].lc, l, mid, ql, min(qr, mid), d);\n    if (mid + 1 <= qr) add(a[root].rc, mid + 1, r, max(ql, mid + 1), qr, d);\n    update(root);\n  }\n  void add(int l, int r, int d) { add(root, 1, n, l, r, d); }\n  info query(int root, int l, int r, int ql, int qr) {\n    if (l == ql && r == qr) return a[root].ans;\n    pushdown(root);\n    int mid = (l + r) / 2;\n    if (mid >= qr)\n      return query(a[root].lc, l, mid, ql, qr);\n    else if (mid + 1 <= ql)\n      return query(a[root].rc, mid + 1, r, ql, qr);\n    else\n      return query(a[root].lc, l, mid, ql, mid) +\n             query(a[root].rc, mid + 1, r, mid + 1, qr);\n  }\n  info query(int l, int r) { return query(root, 1, n, l, r); }\n} ST;\nint n, m, a[MAXN][MAXN];\nint x[MAXM], y[MAXM];\nint main() {\n  read(n), read(m);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) {\n      read(a[i][j]);\n      x[a[i][j]] = i;\n      y[a[i][j]] = j;\n    }\n  ST.init(n * m);\n  LCT.init(n * m);\n  long long ans = 0;\n  for (int i = 1, j = 1; i <= n * m; i++) {\n    while (j + 1 <= n * m) {\n      bool ok = true;\n      vector<int> tmp;\n      for (int k = 0; k <= 3; k++) {\n        int tx = x[j + 1] + dx[k];\n        int ty = y[j + 1] + dy[k];\n        if (a[tx][ty] >= i && a[tx][ty] < j + 1 && ok) {\n          ok &= LCT.query(j + 1, a[tx][ty]);\n          if (ok) {\n            LCT.link(j + 1, a[tx][ty]);\n            tmp.push_back(a[tx][ty]);\n          }\n        }\n      }\n      if (ok) {\n        j++;\n        for (int k = 0; k <= 3; k++) {\n          int tx = x[j] + dx[k];\n          int ty = y[j] + dy[k];\n          if (a[tx][ty] >= i && a[tx][ty] < j) {\n            ST.add(j, n * m, -1);\n          }\n        }\n      } else {\n        for (auto x : tmp) LCT.cut(j + 1, x);\n        break;\n      }\n    }\n    info tmp = ST.query(i, j);\n    if (tmp.Min == i) ans += tmp.cnt;\n    for (int k = 0; k <= 3; k++) {\n      int tx = x[i] + dx[k];\n      int ty = y[i] + dy[k];\n      if (a[tx][ty] > i && a[tx][ty] <= j) {\n        LCT.cut(i, a[tx][ty]);\n        ST.add(a[tx][ty], n * m, 1);\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T, class U>\nvoid ckmin(T &a, U b) {\n  if (a > b) a = b;\n}\ntemplate <class T, class U>\nvoid ckmax(T &a, U b) {\n  if (a < b) a = b;\n}\nint N, M, K;\nvector<int> grid[1013];\npair<int, int> coor[200013];\nint lazy[3 * 200013];\npair<int, int> stor[3 * 200013];\nint pos[200013];\nint dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};\nlong long ans;\nstruct node {\n  node *c[2], *p;\n  bool rev;\n  node() : p(NULL), rev(0) { memset(c, 0, sizeof c); }\n  void flag_rev() {\n    rev ^= 1;\n    swap(c[0], c[1]);\n  }\n  void push_down() {\n    if (rev) {\n      for (auto i = (0); i < (2); i++)\n        if (c[i]) c[i]->flag_rev();\n      rev = 0;\n    }\n  }\n  int get_pos() {\n    if (!this || !p) return 2;\n    for (auto i = (0); i < (2); i++)\n      if (p->c[i] == this) return i;\n    return 2;\n  }\n  bool is_root() { return get_pos() >= 2; }\n  void setc(node *u, const int &v) {\n    if (this && v < 2) c[v] = u;\n    if (u) u->p = this;\n  }\n  void rotate() {\n    node *_p = this->p;\n    bool mark = get_pos();\n    _p->p->setc(this, _p->get_pos());\n    _p->setc(c[mark ^ 1], mark);\n    setc(_p, mark ^ 1);\n  }\n  void relax() {\n    static node *tmp[200013];\n    int top = 0;\n    node *u = this;\n    while (!u->is_root()) tmp[top++] = u, u = u->p;\n    u->push_down();\n    while (top) tmp[--top]->push_down();\n  }\n  void splay() {\n    relax();\n    for (; !is_root(); rotate())\n      if (!p->is_root())\n        ((p->p->c[0] == p) == (p->c[0] == this) ? p : this)->rotate();\n  }\n  node *access() {\n    node *u = this, *v = NULL;\n    for (; u; v = u, u = u->p) u->splay(), u->setc(v, 1);\n    splay();\n    return v;\n  }\n  void be_root() {\n    access();\n    flag_rev();\n  }\n};\nnode lct[200013];\nbool conn(node *u, node *v) {\n  u->be_root(), v->access();\n  return u->is_root() == 0;\n}\nvoid link(node *u, node *v) {\n  u->be_root(), v->access();\n  u->p = v;\n  u->access();\n}\nvoid cut(node *u, node *v) {\n  u->be_root(), v->access();\n  v->setc(NULL, 0);\n  u->p = NULL;\n}\npair<int, int> comb(pair<int, int> a, pair<int, int> b) {\n  if (a.first > b.first) swap(a, b);\n  if (a.first == b.first) a.second += b.second;\n  return a;\n}\nvoid build(int w, int L, int R) {\n  if (L == R) {\n    stor[w] = {1 - L, 1};\n    return;\n  }\n  int mid = (L + R) >> 1;\n  build(w << 1, L, mid);\n  build(w << 1 | 1, mid + 1, R);\n  stor[w] = comb(stor[w << 1], stor[w << 1 | 1]);\n}\nvoid push(int w, int L, int R) {\n  if (lazy[w] == 0) return;\n  stor[w].first += lazy[w];\n  if (L != R) {\n    lazy[w << 1] += lazy[w];\n    lazy[w << 1 | 1] += lazy[w];\n  }\n  lazy[w] = 0;\n  return;\n}\nvoid update(int w, int L, int R, int a, int b, int v) {\n  push(w, L, R);\n  if (b < L || R < a) return;\n  if (a <= L && R <= b) {\n    lazy[w] += v;\n    push(w, L, R);\n    return;\n  }\n  int mid = (L + R) >> 1;\n  update(w << 1, L, mid, a, b, v);\n  update(w << 1 | 1, mid + 1, R, a, b, v);\n  stor[w] = comb(stor[w << 1], stor[w << 1 | 1]);\n}\npair<int, int> query(int w, int L, int R, int a, int b) {\n  push(w, L, R);\n  if (a <= L && R <= b) {\n    return stor[w];\n  }\n  int mid = (L + R) >> 1;\n  if (b <= mid) return query(w << 1, L, mid, a, b);\n  if (mid < a) return query(w << 1 | 1, mid + 1, R, a, b);\n  return comb(query(w << 1, L, mid, a, b), query(w << 1 | 1, mid + 1, R, a, b));\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(12);\n  cerr << fixed << setprecision(4);\n  cin >> N >> M;\n  K = N * M;\n  for (auto i = (0); i < (N); i++) {\n    grid[i].resize(M);\n  }\n  for (auto i = (0); i < (N); i++) {\n    for (auto j = (0); j < (M); j++) {\n      cin >> grid[i][j];\n      grid[i][j]--;\n      coor[grid[i][j]] = {i, j};\n    }\n  }\n  pos[K] = K;\n  for (auto i = (K)-1; i >= (0); i--) {\n    pos[i] = pos[i + 1];\n    vector<int> guys;\n    while (pos[i] > 0) {\n      guys.clear();\n      for (auto j = (0); j < (4); j++) {\n        int x = coor[pos[i] - 1].first + dx[j],\n            y = coor[pos[i] - 1].second + dy[j];\n        if (x < 0 || x >= N || y < 0 || y >= M || grid[x][y] > i ||\n            grid[x][y] < pos[i] - 1)\n          continue;\n        guys.push_back(grid[x][y]);\n      }\n      bool ded = false;\n      for (auto i = (0); i < (((int)((guys).size()))); i++) {\n        int u = guys[i];\n        for (auto j = (i + 1); j < (((int)((guys).size()))); j++) {\n          int v = guys[j];\n          if (conn(&lct[u], &lct[v])) {\n            ded = true;\n          }\n        }\n      }\n      if (ded) break;\n      pos[i]--;\n      for (int u : guys) {\n        link(&lct[u], &lct[pos[i]]);\n      }\n    }\n    guys.clear();\n    for (auto j = (0); j < (4); j++) {\n      int x = coor[i].first + dx[j], y = coor[i].second + dy[j];\n      if (x < 0 || x >= N || y < 0 || y >= M || grid[x][y] > i ||\n          grid[x][y] < pos[i])\n        continue;\n      guys.push_back(grid[x][y]);\n    }\n    for (int u : guys) {\n      cut(&lct[u], &lct[i]);\n    }\n  }\n  build(1, 0, K - 1);\n  for (auto i = (0); i < (K); i++) {\n    for (auto j = (0); j < (4); j++) {\n      int x = coor[i].first + dx[j], y = coor[i].second + dy[j];\n      if (x < 0 || x >= N || y < 0 || y >= M || grid[x][y] > i) continue;\n      update(1, 0, K - 1, 0, grid[x][y], -1);\n    }\n    pair<int, int> p = query(1, 0, K - 1, pos[i], i);\n    ans += p.second;\n    update(1, 0, K - 1, 0, K - 1, 1);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200005, dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\nint n, m, tot, L = 1, R = 1, f[1005][1005], px[N], py[N], fa[N], ch[N][2],\n               rev[N], ps[10], tg[N << 2];\nstruct st {\n  int v, s;\n} T[N << 2];\nlong long ans = 1;\ninline int wh(int x) { return ch[fa[x]][1] == x; }\ninline int isrt(int x) { return ch[fa[x]][0] != x && ch[fa[x]][1] != x; }\nvoid rot(int x) {\n  int y = fa[x], z = fa[y], c = wh(x);\n  ch[y][c] = ch[x][c ^ 1];\n  if (ch[y][c]) fa[ch[y][c]] = y;\n  fa[x] = z;\n  if (!isrt(y)) ch[z][wh(y)] = x;\n  ch[x][c ^ 1] = y;\n  fa[y] = x;\n}\ninline void rever(int x) {\n  swap(ch[x][0], ch[x][1]);\n  rev[x] ^= 1;\n}\ninline void dnn(int x) {\n  if (rev[x]) rever(ch[x][0]), rever(ch[x][1]), rev[x] = 0;\n}\ninline void psh(int x) {\n  if (!isrt(x)) psh(fa[x]);\n  dnn(x);\n}\ninline void splay(int x) {\n  psh(x);\n  for (int y = fa[x]; !isrt(x); rot(x), y = fa[x])\n    if (!isrt(y)) wh(x) ^ wh(y) ? rot(x) : rot(y);\n}\ninline void access(int x) {\n  for (int y = 0; x; x = fa[y = x]) splay(x), ch[x][1] = y;\n}\ninline void mkrt(int x) {\n  access(x);\n  splay(x);\n  rever(x);\n}\ninline int fndrt(int x) {\n  access(x);\n  splay(x);\n  while (ch[x][0]) x = ch[x][0];\n  splay(x);\n  return x;\n}\ninline void split(int x, int y) {\n  mkrt(x);\n  access(y);\n  splay(y);\n}\ninline void link(int x, int y) {\n  mkrt(x);\n  fa[x] = y;\n}\ninline void cut(int x, int y) {\n  split(x, y);\n  fa[x] = ch[y][0] = 0;\n}\ninline bool chk() {\n  int len = 0;\n  for (int d = 0; d < 4; d++) {\n    int x = px[R + 1] + dx[d], y = py[R + 1] + dy[d];\n    if (!x || x == n + 1 || !y || y == m + 1 || f[x][y] < L || f[x][y] > R)\n      continue;\n    ps[++len] = fndrt(f[x][y]);\n  }\n  sort(ps + 1, ps + len + 1);\n  for (int i = 1; i < len; i++)\n    if (ps[i] == ps[i + 1]) return 0;\n  return 1;\n}\ninline st operator+(st a, st b) {\n  return (st){min(a.v, b.v), (a.v <= b.v ? a.s : 0) + (b.v <= a.v ? b.s : 0)};\n}\ninline void cov(int x, int v) {\n  T[x].v += v;\n  tg[x] += v;\n}\ninline void dn(int x) {\n  if (tg[x]) cov(x << 1, tg[x]), cov(x << 1 | 1, tg[x]), tg[x] = 0;\n}\nvoid build(int x, int l, int r) {\n  if (l == r) {\n    T[x] = (st){0, 1};\n    return;\n  }\n  int mid = l + r >> 1;\n  build(x << 1, l, mid);\n  build(x << 1 | 1, mid + 1, r);\n  T[x] = T[x << 1] + T[x << 1 | 1];\n}\nvoid upd(int x, int l, int r, int tl, int tr, int v) {\n  if (tl <= l && r <= tr) {\n    cov(x, v);\n    return;\n  }\n  int mid = l + r >> 1;\n  dn(x);\n  if (tl <= mid) upd(x << 1, l, mid, tl, tr, v);\n  if (tr > mid) upd(x << 1 | 1, mid + 1, r, tl, tr, v);\n  T[x] = T[x << 1] + T[x << 1 | 1];\n}\nst qry(int x, int l, int r, int tl, int tr) {\n  if (tl <= l && r <= tr) return T[x];\n  int mid = l + r >> 1;\n  dn(x);\n  if (tr <= mid) return qry(x << 1, l, mid, tl, tr);\n  if (tl > mid) return qry(x << 1 | 1, mid + 1, r, tl, tr);\n  return qry(x << 1, l, mid, tl, tr) + qry(x << 1 | 1, mid + 1, r, tl, tr);\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  tot = n * m;\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      scanf(\"%d\", &f[i][j]), px[f[i][j]] = i, py[f[i][j]] = j;\n  build(1, 1, tot);\n  upd(1, 1, tot, 1, 1, 1);\n  while (R < tot) {\n    for (; L < R && !chk(); L++)\n      for (int d = 0; d < 4; d++) {\n        int x = px[L] + dx[d], y = py[L] + dy[d];\n        if (!x || x == n + 1 || !y || y == m + 1 || f[x][y] < L || f[x][y] > R)\n          continue;\n        cut(L, f[x][y]);\n      }\n    R++;\n    upd(1, 1, tot, L, R, 1);\n    for (int d = 0; d < 4; d++) {\n      int x = px[R] + dx[d], y = py[R] + dy[d];\n      if (!x || x == n + 1 || !y || y == m + 1 || f[x][y] < L || f[x][y] > R)\n        continue;\n      link(R, f[x][y]);\n      upd(1, 1, tot, L, f[x][y], -1);\n    }\n    st res = qry(1, 1, tot, L, R);\n    ans += res.v == 1 ? res.s : 0;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1010, M = 200010;\nconst int dir[4][2] = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\nint n, m, lb = 1, rb = 1;\nint a[N][N], idx[M], idy[M];\nint fa[M], ch[2][M], sta[M], top;\nbool rv[M];\nint tr[M * 4], sum[M * 4], lz[M * 4], fst, snd;\nlong long ans = 1;\ninline int Min(const int &x, const int &y) { return x < y ? x : y; }\ninline bool nroot(int u) { return ch[0][fa[u]] == u || ch[1][fa[u]] == u; }\ninline void Rev(int u) { rv[u] ^= 1, swap(ch[0][u], ch[1][u]); }\ninline void pd(int u) {\n  if (rv[u]) Rev(ch[0][u]), Rev(ch[1][u]), rv[u] = 0;\n}\nvoid rotate(int u) {\n  int y = fa[u], z = fa[y], k = ch[1][y] == u, w = ch[k ^ 1][u];\n  if (nroot(y)) ch[ch[1][z] == y][z] = u;\n  ch[k][y] = w, ch[k ^ 1][u] = y;\n  if (w) fa[w] = y;\n  fa[u] = z, fa[y] = u;\n}\nvoid splay(int u) {\n  int y = u, z;\n  for (sta[top = 1] = y; nroot(y); sta[++top] = y = fa[y])\n    ;\n  for (; top; pd(sta[top--]))\n    ;\n  for (; nroot(u); rotate(u)) {\n    y = fa[u], z = fa[y];\n    if (nroot(y)) rotate((ch[0][y] == u) ^ (ch[0][z] == y) ? u : y);\n  }\n}\ninline void access(int u) {\n  for (int y = 0; u; u = fa[y = u]) splay(u), ch[1][u] = y;\n}\ninline void makeroot(int u) { access(u), splay(u), Rev(u); }\ninline void split(int x, int y) { makeroot(x), access(y), splay(y); }\ninline int findroot(int u) {\n  access(u), splay(u);\n  for (; ch[0][u]; pd(u), u = ch[0][u])\n    ;\n  splay(u);\n  return u;\n}\ninline void lnk(int x, int y) { makeroot(x), fa[x] = y; }\ninline void cut(int x, int y) { split(x, y), fa[x] = ch[0][y] = 0; }\nvoid pushup(int u) {\n  sum[u] = 0, tr[u] = Min(tr[u * 2], tr[u * 2 + 1]);\n  if (tr[u] == tr[u * 2]) sum[u] += sum[u * 2];\n  if (tr[u] == tr[u * 2 + 1]) sum[u] += sum[u * 2 + 1];\n}\nvoid pushdown(int u) {\n  if (!lz[u]) return;\n  lz[u * 2] += lz[u], lz[u * 2 + 1] += lz[u];\n  tr[u * 2] += lz[u], tr[u * 2 + 1] += lz[u];\n  lz[u] = 0;\n}\nvoid build(int u, int l, int r) {\n  tr[u] = 0, sum[u] = r - l + 1;\n  if (l >= r) return;\n  int mid = (l + r) >> 1;\n  build(u * 2, l, mid), build(u * 2 + 1, mid + 1, r);\n}\nvoid mdy(int u, int l, int r, int L, int R, int w) {\n  if (L <= l && r <= R) {\n    tr[u] += w, lz[u] += w;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  pushdown(u);\n  if (L <= mid) mdy(u * 2, l, mid, L, R, w);\n  if (R > mid) mdy(u * 2 + 1, mid + 1, r, L, R, w);\n  pushup(u);\n}\nvoid ask(int u, int l, int r, int L, int R) {\n  if (L <= l && r <= R) {\n    if (fst > tr[u]) fst = tr[u], snd = 0;\n    if (fst == tr[u]) snd += sum[u];\n    return;\n  }\n  int mid = (l + r) >> 1;\n  pushdown(u);\n  if (L <= mid) ask(u * 2, l, mid, L, R);\n  if (R > mid) ask(u * 2 + 1, mid + 1, r, L, R);\n}\nbool check() {\n  static int tmp[5];\n  int len = 0;\n  for (int i = 0; i < 4; i++) {\n    int x = idx[rb + 1] + dir[i][0], y = idy[rb + 1] + dir[i][1];\n    if (!x || !y || x > n || y > m || a[x][y] < lb || a[x][y] > rb) continue;\n    tmp[++len] = findroot(a[x][y]);\n  }\n  sort(tmp + 1, tmp + len + 1);\n  for (int i = 1; i < len; i++)\n    if (tmp[i] == tmp[i + 1]) return 0;\n  return 1;\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      scanf(\"%d\", &a[i][j]), idx[a[i][j]] = i, idy[a[i][j]] = j;\n  build(1, 1, n * m), mdy(1, 1, n * m, 1, 1, 1);\n  for (; rb < n * m;) {\n    for (; lb < rb && !check(); ++lb)\n      for (int i = 0; i < 4; i++) {\n        int x = idx[lb] + dir[i][0], y = idy[lb] + dir[i][1];\n        if (!x || !y || x > n || y > m || a[x][y] < lb || a[x][y] > rb)\n          continue;\n        cut(lb, a[x][y]);\n      }\n    ++rb, mdy(1, 1, n * m, lb, rb, 1);\n    for (int i = 0; i < 4; i++) {\n      int x = idx[rb] + dir[i][0], y = idy[rb] + dir[i][1];\n      if (!x || !y || x > n || y > m || a[x][y] < lb || a[x][y] > rb) continue;\n      lnk(rb, a[x][y]), mdy(1, 1, n * m, lb, a[x][y], -1);\n    }\n    fst = M, snd = 0, ask(1, 1, n * m, lb, rb);\n    if (fst == 1) ans += snd;\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e3 + 10, M = 2e5 + 10;\nconst int dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0};\nint n, m;\nint w[N][N];\nlong long ans;\nvector<int> vec[M];\nstruct LCT {\n  int ch[M][2], fa[M], rev[M], stk[M];\n  bool nroot(int x) { return ch[fa[x]][0] == x || ch[fa[x]][1] == x; }\n  void dorev(int x) { swap(ch[x][0], ch[x][1]), rev[x] ^= 1; }\n  void psd(int x) {\n    if (rev[x]) {\n      if (ch[x][0]) dorev(ch[x][0]);\n      if (ch[x][1]) dorev(ch[x][1]);\n      rev[x] = 0;\n    }\n  }\n  void rotate(int x) {\n    psd(fa[x]), psd(x);\n    int y = fa[x], z = fa[y], k = ch[y][1] == x, w = ch[x][k ^ 1];\n    if (nroot(y)) ch[z][ch[z][1] == y] = x;\n    fa[x] = z;\n    if (w) fa[w] = y;\n    ch[y][k] = w;\n    ch[x][k ^ 1] = y;\n    fa[y] = x;\n  }\n  void splay(int x) {\n    int y = x, z = 0;\n    stk[++z] = y;\n    while (nroot(y)) stk[++z] = y = fa[y];\n    while (z) psd(stk[z--]);\n    while (nroot(x)) {\n      int y = fa[x], z = fa[y];\n      if (nroot(y)) rotate((ch[y][0] == x) ^ (ch[z][0] == y) ? x : y);\n      rotate(x);\n    }\n  }\n  void access(int x) {\n    for (int y = 0; x; y = x, x = fa[y]) splay(x), ch[x][1] = y;\n  }\n  int findroot(int x) {\n    access(x), splay(x);\n    while (ch[x][0]) psd(x), x = ch[x][0];\n    splay(x);\n    return x;\n  }\n  void makeroot(int x) {\n    access(x), splay(x);\n    dorev(x);\n  }\n  void split(int x, int y) {\n    makeroot(x);\n    access(y), splay(y);\n  }\n  bool dolink(int x, int y) {\n    makeroot(x);\n    if (findroot(y) == x) return 0;\n    fa[x] = y;\n    return 1;\n  }\n  void docut(int x, int y) {\n    makeroot(x);\n    if (findroot(y) == x && fa[y] == x && !ch[y][0]) fa[y] = ch[x][1] = 0;\n  }\n} T;\nstruct SegTree {\n  int mn[M << 2], num[M << 2], tag[M << 2];\n  void psd(int x) {\n    if (tag[x]) {\n      tag[x << 1] += tag[x], mn[x << 1] += tag[x];\n      tag[x << 1 | 1] += tag[x], mn[x << 1 | 1] += tag[x];\n      tag[x] = 0;\n    }\n  }\n  void upd(int x) {\n    if (mn[x << 1] < mn[x << 1 | 1]) mn[x] = mn[x << 1], num[x] = num[x << 1];\n    if (mn[x << 1] == mn[x << 1 | 1])\n      mn[x] = mn[x << 1], num[x] = num[x << 1] + num[x << 1 | 1];\n    if (mn[x << 1] > mn[x << 1 | 1])\n      mn[x] = mn[x << 1 | 1], num[x] = num[x << 1 | 1];\n  }\n  void build(int x, int l, int r) {\n    if (l == r) {\n      mn[x] = 0, num[x] = 1;\n      return;\n    }\n    int mid = (l + r) >> 1;\n    build(x << 1, l, mid), build(x << 1 | 1, mid + 1, r);\n    upd(x);\n  }\n  void modify(int x, int l, int r, int lx, int rx, int v) {\n    if (lx <= l && r <= rx) {\n      mn[x] += v, tag[x] += v;\n      return;\n    }\n    int mid = (l + r) >> 1;\n    psd(x);\n    if (lx <= mid) modify(x << 1, l, mid, lx, rx, v);\n    if (rx > mid) modify(x << 1 | 1, mid + 1, r, lx, rx, v);\n    upd(x);\n  }\n  int query(int x, int l, int r, int lx, int rx) {\n    if (lx <= l && r <= rx) return mn[x] == 1 ? num[x] : 0;\n    psd(x);\n    int mid = (l + r) >> 1, ret = 0;\n    if (lx <= mid) ret += query(x << 1, l, mid, lx, rx);\n    if (rx > mid) ret += query(x << 1 | 1, mid + 1, r, lx, rx);\n    return ret;\n  }\n} S;\nint main() {\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) scanf(\"%d\", &w[i][j]);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      for (int k = 0; k <= 3; k++) {\n        int x = i + dx[k], y = j + dy[k];\n        if (x < 1 || y < 1 || x > n || y > m || w[x][y] > w[i][j]) continue;\n        vec[w[i][j]].push_back(w[x][y]);\n        vec[w[x][y]].push_back(w[i][j]);\n      }\n  int t = n * m, r = 0;\n  S.build(1, 1, t);\n  for (int l = 1; l <= t; l++) {\n    for (int i = r + 1; i <= t; i++) {\n      int flag = 1, tot = 0;\n      for (int j = 0; j < vec[i].size(); j++) {\n        int x = vec[i][j];\n        if (x < i && x >= l) {\n          ++tot;\n          if (!T.dolink(i, x)) {\n            flag = 0;\n            break;\n          }\n        }\n      }\n      if (!flag) {\n        for (int j = 0; j < vec[i].size(); j++) {\n          int x = vec[i][j];\n          if (x < i && x >= l) T.docut(i, x);\n        }\n        break;\n      }\n      r = i;\n      S.modify(1, 1, t, i, i, i - l + 1);\n      S.modify(1, 1, t, i, t, -tot);\n    }\n    ans += S.query(1, 1, t, l, r);\n    for (int j = 0; j < vec[l].size(); j++) {\n      int x = vec[l][j];\n      if (x > l && x <= r) T.docut(l, x), S.modify(1, 1, t, x, t, 1);\n    }\n    S.modify(1, 1, t, l, r, -1);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\nint f[1000][1000], rr[200000], cc[200000];\nclass link_cut {\n private:\n  int N;\n  struct node {\n    node *l, *r, *p;\n    int k, s, f;\n  };\n  node **nodes;\n  int size(node *r) {\n    if (r == NULL)\n      return 0;\n    else\n      return r->s;\n  }\n  int update(node *r) {\n    if (r != NULL) r->s = size(r->l) + size(r->r) + 1;\n    return 0;\n  }\n  int prop(node *r) {\n    if (r->f) {\n      swap(r->l, r->r);\n      if (r->l != NULL) r->l->f ^= 1;\n      if (r->r != NULL) r->r->f ^= 1;\n      r->f = 0;\n    }\n    return 0;\n  }\n  int isRoot(node *r) {\n    return (r->p == NULL) || ((r->p->l != r) && (r->p->r != r));\n  }\n  int rotL(node *r) {\n    node *n = r->r;\n    r->r = n->l;\n    if (n->l != NULL) n->l->p = r;\n    n->p = r->p;\n    if (r->p != NULL) {\n      if (r->p->l == r)\n        r->p->l = n;\n      else if (r->p->r == r)\n        r->p->r = n;\n    }\n    n->l = r, r->p = n;\n    update(r), update(n);\n    return 0;\n  }\n  int rotR(node *r) {\n    node *n = r->l;\n    r->l = n->r;\n    if (n->r != NULL) n->r->p = r;\n    n->p = r->p;\n    if (r->p != NULL) {\n      if (r->p->l == r)\n        r->p->l = n;\n      else if (r->p->r == r)\n        r->p->r = n;\n    }\n    n->r = r, r->p = n;\n    update(r), update(n);\n    return 0;\n  }\n  int splay(node *n) {\n    if (n == NULL) return 0;\n    while (!isRoot(n)) {\n      if (isRoot(n->p)) {\n        prop(n->p), prop(n);\n        if (n == n->p->l)\n          rotR(n->p);\n        else\n          rotL(n->p);\n      } else {\n        prop(n->p->p), prop(n->p), prop(n);\n        if ((n->p->l == n) && (n->p->p->l == n->p))\n          rotR(n->p->p), rotR(n->p);\n        else if ((n->p->r == n) && (n->p->p->r == n->p))\n          rotL(n->p->p), rotL(n->p);\n        else if ((n->p->l == n) && (n->p->p->r == n->p))\n          rotR(n->p), rotL(n->p);\n        else\n          rotL(n->p), rotR(n->p);\n      }\n    }\n    prop(n);\n    return 0;\n  }\n  int access(node *n) {\n    for (splay(n), n->r = NULL, update(n); n->p != NULL; splay(n))\n      splay(n->p), n->p->r = n;\n    return 0;\n  }\n  int evert(node *n) {\n    access(n), n->f ^= 1;\n    return 0;\n  }\n\n public:\n  link_cut(int n) {\n    int i;\n    N = n;\n    nodes = new node *[N];\n    for (i = 0; i < N; i++) {\n      nodes[i] = new node;\n      nodes[i]->l = nodes[i]->r = nodes[i]->p = NULL;\n      nodes[i]->k = i, nodes[i]->s = 1;\n    }\n  }\n  ~link_cut() {\n    int i;\n    for (i = 0; i < N; i++) delete nodes[i];\n    delete nodes;\n  }\n  int conn(int a, int b) {\n    if (a == b) return 1;\n    access(nodes[a]), access(nodes[b]);\n    return nodes[a]->p != NULL;\n  }\n  int link(int a, int b) {\n    evert(nodes[a]);\n    nodes[a]->p = nodes[b];\n    access(nodes[a]);\n    return 0;\n  }\n  int cut(int a, int b) {\n    if (!conn(a, b)) return -1;\n    node *n = nodes[a];\n    evert(nodes[b]);\n    access(n);\n    n->l->p = NULL;\n    n->l = NULL;\n    update(n);\n    return 0;\n  }\n  int dist(int a, int b) {\n    evert(nodes[a]);\n    access(nodes[b]);\n    return nodes[b]->s - 1;\n  }\n};\nlink_cut lct(200000);\nint L[200000];\nint tree[1 << 19], lazy[1 << 19], times[1 << 19];\nint build(int s, int e, int i) {\n  if (s == e) {\n    times[i] = 1;\n    return 0;\n  }\n  int mid = (s + e) / 2;\n  build(s, mid, 2 * i + 1), build(mid + 1, e, 2 * i + 2);\n  times[i] = 1;\n  return 0;\n}\nint prop(int s, int e, int i) {\n  tree[i] += lazy[i];\n  if (s != e) lazy[2 * i + 1] += lazy[i], lazy[2 * i + 2] += lazy[i];\n  lazy[i] = 0;\n  return 0;\n}\nint update(int s, int e, int as, int ae, int i, int num) {\n  prop(s, e, i);\n  if ((s > ae) || (e < as))\n    return 0;\n  else if ((s >= as) && (e <= ae)) {\n    lazy[i] += num;\n    prop(s, e, i);\n    return 0;\n  }\n  int mid = (s + e) / 2;\n  update(s, mid, as, ae, 2 * i + 1, num),\n      update(mid + 1, e, as, ae, 2 * i + 2, num);\n  tree[i] = min(tree[2 * i + 1], tree[2 * i + 2]), times[i] = 0;\n  if (tree[i] == tree[2 * i + 1]) times[i] += times[2 * i + 1];\n  if (tree[i] == tree[2 * i + 2]) times[i] += times[2 * i + 2];\n  return 0;\n}\nint mm, t;\nint query(int s, int e, int qs, int qe, int i) {\n  prop(s, e, i);\n  if ((s > qe) || (e < qs))\n    return 0;\n  else if ((s >= qs) && (e <= qe)) {\n    int nm = min(mm, tree[i]), nt = 0;\n    if (nm == mm) nt += t;\n    if (nm == tree[i]) nt += times[i];\n    mm = nm, t = nt;\n    return 0;\n  }\n  int mid = (s + e) / 2;\n  query(s, mid, qs, qe, 2 * i + 1), query(mid + 1, e, qs, qe, 2 * i + 2);\n  return 0;\n}\nint main() {\n  int i, j;\n  scanf(\"%d %d\", &n, &m);\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < m; j++)\n      scanf(\"%d\", &f[i][j]), f[i][j]--, rr[f[i][j]] = i, cc[f[i][j]] = j;\n  }\n  long long int ans = 0;\n  int l = 0;\n  for (i = 0; i < n * m; i++) {\n    while (1) {\n      for (j = 0; j < 4; j++) {\n        int x = cc[i] + dx[j], y = rr[i] + dy[j];\n        if ((x >= 0) && (x < m) && (y >= 0) && (y < n) && (f[y][x] >= l) &&\n            (f[y][x] < i)) {\n          if (lct.conn(f[y][x], i))\n            break;\n          else\n            lct.link(f[y][x], i);\n        }\n      }\n      if (j < 4) {\n        for (j--; j >= 0; j--) {\n          int x = cc[i] + dx[j], y = rr[i] + dy[j];\n          if ((x >= 0) && (x < m) && (y >= 0) && (y < n) && (f[y][x] >= l) &&\n              (f[y][x] < i))\n            lct.cut(f[y][x], i);\n        }\n        for (j = 0; j < 4; j++) {\n          int x = cc[l] + dx[j], y = rr[l] + dy[j];\n          if ((x >= 0) && (x < m) && (y >= 0) && (y < n) && (f[y][x] > l) &&\n              (f[y][x] < i))\n            lct.cut(f[y][x], l);\n        }\n        l++;\n      } else\n        break;\n    }\n    L[i] = l;\n  }\n  build(0, n * m - 1, 0);\n  for (i = 0; i < n * m; i++) {\n    update(0, n * m - 1, 0, i, 0, 1);\n    for (j = 0; j < 4; j++) {\n      int x = cc[i] + dx[j], y = rr[i] + dy[j];\n      if ((x >= 0) && (x < m) && (y >= 0) && (y < n) && (f[y][x] < i))\n        update(0, n * m - 1, 0, f[y][x], 0, -1);\n    }\n    mm = 1e9, t = 1;\n    query(0, n * m - 1, L[i], i, 0);\n    ans += t;\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct LCT {\n  int ch[1000000][3], fa[1000000], turn[1000000];\n  int Get(int x) { return ch[fa[x]][1] == x; }\n  int nroot(int x) { return ch[fa[x]][1] == x || ch[fa[x]][0] == x; }\n  void pushr(int x) {\n    if (!x) return;\n    swap(ch[x][0], ch[x][1]);\n    turn[x] ^= 1;\n  }\n  void pushdown(int x) {\n    if (turn[x]) {\n      pushr(ch[x][0]), pushr(ch[x][1]);\n      turn[x] = 0;\n    }\n  }\n  void pushall(int x) {\n    if (nroot(x)) pushall(fa[x]);\n    pushdown(x);\n  }\n  void rotate(int x) {\n    int y = fa[x], z = fa[y], w = Get(x);\n    if (nroot(y)) ch[z][ch[z][1] == y] = x;\n    ch[y][w] = ch[x][w ^ 1];\n    if (ch[y][w]) fa[ch[y][w]] = y;\n    ch[x][w ^ 1] = y;\n    fa[y] = x;\n    fa[x] = z;\n  }\n  void splay(int x) {\n    pushall(x);\n    while (nroot(x)) {\n      int y = fa[x];\n      if (nroot(y)) Get(x) ^ Get(y) ? rotate(x) : rotate(y);\n      rotate(x);\n    }\n  }\n  void access(int x) {\n    for (int y = 0; x; x = fa[y = x]) {\n      splay(x);\n      ch[x][1] = y;\n    }\n  }\n  int findroot(int x) {\n    access(x);\n    splay(x);\n    while (ch[x][0]) x = ch[x][0];\n    splay(x);\n    return x;\n  }\n  void makeroot(int x) {\n    access(x);\n    splay(x);\n    pushr(x);\n    return;\n  }\n  int link(int x, int y) {\n    makeroot(x);\n    if (findroot(y) == x) return false;\n    fa[x] = y;\n    return true;\n  }\n  void cut(int x, int y) {\n    makeroot(x);\n    if (findroot(y) == x && fa[y] == x && !ch[y][0]) {\n      fa[y] = ch[x][1] = 0;\n    }\n    return;\n  }\n} T;\nstruct segment_tree {\n  int Min[4 * 1000000], Num[4 * 1000000], lazy[4 * 1000000];\n  void pushdown(int x) {\n    if (lazy[x]) {\n      lazy[x << 1] += lazy[x];\n      lazy[x << 1 | 1] += lazy[x];\n      Min[x << 1] += lazy[x], Min[x << 1 | 1] += lazy[x];\n      lazy[x] = 0;\n    }\n  }\n  void pushup(int x) {\n    if (Min[x << 1] < Min[x << 1 | 1])\n      Min[x] = Min[x << 1], Num[x] = Num[x << 1];\n    if (Min[x << 1] > Min[x << 1 | 1])\n      Min[x] = Min[x << 1 | 1], Num[x] = Num[x << 1 | 1];\n    if (Min[x << 1] == Min[x << 1 | 1])\n      Min[x] = Min[x << 1], Num[x] = Num[x << 1] + Num[x << 1 | 1];\n  }\n  void build(int x, int l, int r) {\n    if (l == r) {\n      Min[x] = 0, Num[x] = 1;\n      return;\n    }\n    int mid = l + r >> 1;\n    build(x << 1, l, mid);\n    build(x << 1 | 1, mid + 1, r);\n    pushup(x);\n  }\n  void modify(int x, int l, int r, int ll, int rr, int k) {\n    if (ll <= l && r <= rr) {\n      lazy[x] += k;\n      Min[x] += k;\n      return;\n    }\n    pushdown(x);\n    int mid = l + r >> 1;\n    if (ll <= mid) modify(x << 1, l, mid, ll, rr, k);\n    if (rr > mid) modify(x << 1 | 1, mid + 1, r, ll, rr, k);\n    pushup(x);\n  }\n  int query(int x, int l, int r, int ll, int rr) {\n    if (l == ll && r == rr) {\n      if (Min[x] == 1)\n        return Num[x];\n      else\n        return 0;\n    }\n    int mid = l + r >> 1;\n    pushdown(x);\n    if (rr <= mid)\n      return query(x << 1, l, mid, ll, rr);\n    else if (ll > mid)\n      return query(x << 1 | 1, mid + 1, r, ll, rr);\n    else\n      return query(x << 1, l, mid, ll, mid) +\n             query(x << 1 | 1, mid + 1, r, mid + 1, rr);\n  }\n} S;\nvector<int> V[1000000];\nint dx[10] = {1, 0, -1, 0};\nint dy[10] = {0, 1, 0, -1};\nint n, m, w[3000][3000];\nlong long ans = 0;\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) scanf(\"%d\", &w[i][j]);\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      for (int d = 0; d < 4; d++) {\n        int x = i + dx[d], y = j + dy[d];\n        if (x < 1 || y < 1 || x > n || y > m) continue;\n        if (w[x][y] > w[i][j]) continue;\n        V[w[x][y]].push_back(w[i][j]);\n        V[w[i][j]].push_back(w[x][y]);\n      }\n    }\n  }\n  int R = 0;\n  long long t = n * m;\n  S.build(1, 1, t);\n  for (int i = 1; i <= t; i++) {\n    for (int j = R + 1; j <= t; j++) {\n      int now = j, flag = 0;\n      for (int d = 0; d < V[now].size(); d++) {\n        int now1 = V[now][d];\n        if (now1 < now && now1 >= i)\n          if (!T.link(now1, now)) {\n            flag = 1;\n            break;\n          }\n      }\n      for (int d = 0; d < V[now].size(); d++) T.cut(now, V[now][d]);\n      if (flag == 1) break;\n      R = j;\n      int tot = 0;\n      for (int d = 0; d < V[now].size(); d++) {\n        int now1 = V[now][d];\n        if (now1 < j && now1 >= i) T.link(now1, now);\n        if (now1 < j && now1 >= i) tot++;\n      }\n      S.modify(1, 1, t, R, R, R - i + 1);\n      S.modify(1, 1, t, R, t, -tot);\n    }\n    ans += 1ll * S.query(1, 1, t, i, R);\n    int tot = 0;\n    for (int d = 0; d < V[i].size(); d++) {\n      if (V[i][d] <= R && V[i][d] > i) {\n        T.cut(V[i][d], i);\n        S.modify(1, 1, t, V[i][d], t, 1);\n      }\n    }\n    S.modify(1, 1, t, i, R, -1);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 1e3 + 10, N = 2e5 + 10, dx[] = {0, 1, 0, -1},\n          dy[] = {1, 0, -1, 0};\nint n, m, a[M][M], lim[N], father[N], rev[N], ch[N][2], addv[N << 2],\n    minv[N << 2], mins[N << 2];\nbool appeared[N];\npair<int, int> p[N];\nmap<int, bool> linked[N];\nbool is_root(int u) {\n  return !(ch[father[u]][0] == u) && !(ch[father[u]][1] == u);\n}\nint side(int f, int u) { return ch[f][1] == u; }\nvoid reverse(int u) {\n  rev[u] = !rev[u];\n  swap(ch[u][0], ch[u][1]);\n}\nvoid push(int u) {\n  if (rev[u]) {\n    if (ch[u][0]) {\n      reverse(ch[u][0]);\n    }\n    if (ch[u][1]) {\n      reverse(ch[u][1]);\n    }\n    rev[u] = 0;\n  }\n}\nvoid rotate(int u) {\n  int f = father[u], s1 = side(f, u), s2 = side(father[f], f), ano = ch[u][!s1];\n  father[u] = father[f];\n  if (!is_root(f)) {\n    ch[father[f]][s2] = u;\n  }\n  father[ano] = f;\n  ch[f][s1] = ano;\n  father[f] = u;\n  ch[u][!s1] = f;\n}\nvoid splay(int u) {\n  vector<int> pstack(1, u);\n  for (int i = u; !is_root(i); i = father[i]) {\n    pstack.push_back(father[i]);\n  }\n  for (; pstack.size(); pstack.pop_back()) {\n    push(pstack.back());\n  }\n  for (; !is_root(u); rotate(u)) {\n    if (!is_root(father[u])) {\n      if (side(father[u], u) == side(father[father[u]], father[u])) {\n        rotate(father[u]);\n      } else {\n        rotate(u);\n      }\n    }\n  }\n}\nvoid access(int u) {\n  for (int x = 0; u; x = u, u = father[u]) {\n    splay(u);\n    ch[u][1] = x;\n  }\n}\nint find_root(int u) {\n  access(u);\n  splay(u);\n  for (; ch[u][0]; u = ch[u][0])\n    ;\n  splay(u);\n  return u;\n}\nvoid make_root(int u) {\n  access(u);\n  splay(u);\n  reverse(u);\n}\nvoid split(int u, int v) {\n  make_root(u);\n  access(v);\n  splay(v);\n}\nvoid link(int u, int v) {\n  make_root(u);\n  father[u] = v;\n}\nvoid cut(int u, int v) {\n  split(u, v);\n  father[u] = ch[v][0] = 0;\n}\nbool check(int v) {\n  vector<int> nodes;\n  bool ok = true;\n  for (int i = 0; i < 4; ++i) {\n    int newx = p[v].first + dx[i], newy = p[v].second + dy[i];\n    if (newx >= 1 && newx <= n && newy >= 1 && newy <= m) {\n      int u = find_root(a[newx][newy]);\n      if (appeared[u]) {\n        ok = false;\n      } else {\n        appeared[u] = true;\n        nodes.push_back(u);\n      }\n    }\n  }\n  for (auto v : nodes) {\n    appeared[v] = false;\n  }\n  return ok;\n}\nvoid add(int o, int v) {\n  addv[o] += v;\n  minv[o] += v;\n}\nvoid push_down(int o) {\n  if (addv[o]) {\n    add(o << 1, addv[o]);\n    add(o << 1 | 1, addv[o]);\n    addv[o] = 0;\n  }\n}\nvoid push_up(int o) {\n  minv[o] = min(minv[o << 1], minv[o << 1 | 1]);\n  mins[o] = 0;\n  if (minv[o << 1] == minv[o]) {\n    mins[o] += mins[o << 1];\n  }\n  if (minv[o << 1 | 1] == minv[o]) {\n    mins[o] += mins[o << 1 | 1];\n  }\n}\nvoid build(int l, int r, int o) {\n  if (l == r) {\n    mins[o] = 1;\n  } else {\n    int mid = l + r >> 1;\n    build(l, mid, o << 1);\n    build(mid + 1, r, o << 1 | 1);\n    push_up(o);\n  }\n}\nvoid modify(int l, int r, int o, int ql, int qr, int v) {\n  if (ql <= l && r <= qr) {\n    add(o, v);\n  } else {\n    int mid = l + r >> 1;\n    push_down(o);\n    if (qr <= mid) {\n      modify(l, mid, o << 1, ql, qr, v);\n    } else if (ql > mid) {\n      modify(mid + 1, r, o << 1 | 1, ql, qr, v);\n    } else {\n      modify(l, mid, o << 1, ql, qr, v);\n      modify(mid + 1, r, o << 1 | 1, ql, qr, v);\n    }\n    push_up(o);\n  }\n}\npair<int, int> query(int l, int r, int o, int ql, int qr) {\n  if (ql <= l && r <= qr) {\n    return {minv[o], mins[o]};\n  } else {\n    int mid = l + r >> 1;\n    push_down(o);\n    if (qr <= mid) {\n      return query(l, mid, o << 1, ql, qr);\n    } else if (ql > mid) {\n      return query(mid + 1, r, o << 1 | 1, ql, qr);\n    } else {\n      pair<int, int> x = query(l, mid, o << 1, ql, qr);\n      pair<int, int> y = query(mid + 1, r, o << 1 | 1, ql, qr);\n      if (x.first == y.first) {\n        return {x.first, x.second + y.second};\n      } else {\n        return x.first < y.first ? x : y;\n      }\n    }\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= m; ++j) {\n      scanf(\"%d\", &a[i][j]);\n      p[a[i][j]] = {i, j};\n    }\n  }\n  int all = n * m;\n  for (int i = all, j = all; i; --i) {\n    for (; j > 1 && check(j - 1); --j) {\n      for (int k = 0; k < 4; ++k) {\n        int newx = p[j - 1].first + dx[k], newy = p[j - 1].second + dy[k];\n        if (newx >= 1 && newx <= n && newy >= 1 && newy <= m) {\n          if (a[newx][newy] >= j - 1 && a[newx][newy] <= i) {\n            link(a[newx][newy], j - 1);\n            linked[a[newx][newy]][j - 1] = true;\n          }\n        }\n      }\n    }\n    lim[i] = j;\n    for (int k = 0; k < 4; ++k) {\n      int newx = p[i].first + dx[k], newy = p[i].second + dy[k];\n      if (newx >= 1 && newx <= n && newy >= 1 && newy <= m) {\n        if (a[newx][newy] <= i && a[newx][newy] >= j &&\n            linked[i][a[newx][newy]]) {\n          cut(i, a[newx][newy]);\n        }\n      }\n    }\n  }\n  build(1, all, 1);\n  long long answer = 0;\n  for (int i = 1, j = 1; i <= all; ++i) {\n    modify(1, all, 1, lim[i], i, 1);\n    for (int j = 0; j < 4; ++j) {\n      int newx = p[i].first + dx[j], newy = p[i].second + dy[j];\n      if (newx >= 1 && newx <= n && newy >= 1 && newy <= m) {\n        if (a[newx][newy] < i && lim[i] <= a[newx][newy]) {\n          modify(1, all, 1, lim[i], a[newx][newy], -1);\n        }\n      }\n    }\n    pair<int, int> result = query(1, all, 1, lim[i], i);\n    answer += (result.first == 1) * result.second;\n  }\n  printf(\"%lld\\n\", answer);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int readint() {\n  int x = 0;\n  bool f = 0;\n  char c = getchar();\n  while (!isdigit(c) && c != '-') c = getchar();\n  if (c == '-') {\n    f = 1;\n    c = getchar();\n  }\n  while (isdigit(c)) {\n    x = x * 10 + c - '0';\n    c = getchar();\n  }\n  return f ? -x : x;\n}\nconst int maxn = 2e5 + 5;\nint n, m, p[maxn];\nvector<int> f[maxn];\nint fa[maxn], ch[maxn][2];\nbool isroot(int x) {\n  int y = fa[x];\n  return !y || (ch[y][0] != x && ch[y][1] != x);\n}\nvoid rotate(int x) {\n  int y = fa[x], z = fa[y];\n  if (!isroot(y)) ch[z][ch[z][1] == y] = x;\n  bool d = ch[y][1] == x;\n  int k = ch[x][!d];\n  ch[y][d] = k;\n  ch[x][!d] = y;\n  if (k) fa[k] = y;\n  fa[x] = z;\n  fa[y] = x;\n}\nbool rev[maxn];\nvoid pushtag(int x) {\n  rev[x] ^= 1;\n  swap(ch[x][0], ch[x][1]);\n}\nvoid pushdown(int x) {\n  if (rev[x]) {\n    if (ch[x][0]) pushtag(ch[x][0]);\n    if (ch[x][1]) pushtag(ch[x][1]);\n    rev[x] = 0;\n  }\n}\nvoid pushall(int x) {\n  if (!isroot(x)) pushall(fa[x]);\n  pushdown(x);\n}\nvoid splay(int x) {\n  pushall(x);\n  while (!isroot(x)) {\n    int y = fa[x], z = fa[y];\n    if (!isroot(y)) {\n      if ((ch[y][1] == x) ^ (ch[z][1] == y)) rotate(x);\n      rotate(y);\n    }\n    rotate(x);\n  }\n}\nvoid access(int x) {\n  int y = 0;\n  while (x) {\n    splay(x);\n    ch[x][1] = y;\n    y = x;\n    x = fa[x];\n  }\n}\nint findroot(int x) {\n  access(x);\n  splay(x);\n  while (ch[x][0]) {\n    pushdown(x);\n    x = ch[x][0];\n  }\n  splay(x);\n  return x;\n}\nvoid makeroot(int x) {\n  access(x);\n  splay(x);\n  pushtag(x);\n}\nvoid link(int x, int y) {\n  makeroot(x);\n  fa[x] = y;\n}\nvoid cut(int x, int y) {\n  makeroot(x);\n  access(y);\n  splay(x);\n  ch[x][1] = fa[y] = 0;\n}\nstruct item {\n  int mn, cnt;\n  item operator+(item b) {\n    if (mn < b.mn)\n      return {mn, cnt};\n    else if (mn > b.mn)\n      return {b.mn, b.cnt};\n    else\n      return {mn, cnt + b.cnt};\n  }\n};\nstruct node {\n  int l, r;\n  node* ch[2];\n  item v;\n  int add = 0;\n  void pushup() { v = ch[0]->v + ch[1]->v; }\n  node(int l, int r) : l(l), r(r), v({0, r - l + 1}) {\n    if (l == r) return;\n    int mid = l + (r - l) / 2;\n    ch[0] = new node(l, mid);\n    ch[1] = new node(mid + 1, r);\n  }\n  void pushtag(int k) {\n    v.mn += k;\n    add += k;\n  }\n  void pushdown() {\n    ch[0]->pushtag(add);\n    ch[1]->pushtag(add);\n    add = 0;\n  }\n  void modify(int ql, int qr, int k) {\n    if (ql <= l && qr >= r) {\n      pushtag(k);\n      return;\n    }\n    pushdown();\n    if (ql <= ch[0]->r) ch[0]->modify(ql, qr, k);\n    if (qr >= ch[1]->l) ch[1]->modify(ql, qr, k);\n    pushup();\n  }\n  item query(int ql, int qr) {\n    if (ql <= l && qr >= r) return v;\n    pushdown();\n    item ans = {(int)2e9, 0};\n    if (ql <= ch[0]->r) ans = ans + ch[0]->query(ql, qr);\n    if (qr >= ch[1]->l) ans = ans + ch[1]->query(ql, qr);\n    return ans;\n  }\n} * rt;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\nbool check(int l, int r) {\n  int x = (p[r] - 1) / m + 1, y = (p[r] - 1) % m + 1;\n  set<int> s;\n  for (int i = 0; i < 4; i++) {\n    int vx = x + dx[i], vy = y + dy[i];\n    if (vx <= 0 || vx > n || vy <= 0 || vy > m || f[vx][vy] < l ||\n        f[vx][vy] >= r)\n      continue;\n    int u = findroot(f[vx][vy]);\n    if (s.find(u) != s.end()) return 0;\n    s.insert(u);\n  }\n  return 1;\n}\nint main() {\n  n = readint();\n  m = readint();\n  for (int i = 1; i <= n; i++) {\n    f[i].resize(m + 1);\n    for (int j = 1; j <= m; j++) p[f[i][j] = readint()] = (i - 1) * m + j;\n  }\n  int cur = 1;\n  rt = new node(1, n * m);\n  long long ans = 0;\n  for (int i = 1; i <= n * m; i++) {\n    while (!check(cur, i)) {\n      int x = (p[cur] - 1) / m + 1, y = (p[cur] - 1) % m + 1;\n      for (int j = 0; j < 4; j++) {\n        int vx = x + dx[j], vy = y + dy[j];\n        if (vx <= 0 || vx > n || vy <= 0 || vy > m || f[vx][vy] < cur ||\n            f[vx][vy] >= i)\n          continue;\n        cut(cur, f[vx][vy]);\n      }\n      cur++;\n    }\n    rt->modify(1, i, 1);\n    int x = (p[i] - 1) / m + 1, y = (p[i] - 1) % m + 1;\n    for (int j = 0; j < 4; j++) {\n      int vx = x + dx[j], vy = y + dy[j];\n      if (vx <= 0 || vx > n || vy <= 0 || vy > m || f[vx][vy] < cur ||\n          f[vx][vy] >= i)\n        continue;\n      link(i, f[vx][vy]);\n      rt->modify(1, f[vx][vy], -1);\n    }\n    ans += rt->query(cur, i).cnt;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace io {\nconst int L = (1 << 20) + 1;\nchar buf[L], *S, *T, c;\nchar getchar() {\n  if (__builtin_expect(S == T, 0)) {\n    T = (S = buf) + fread(buf, 1, L, stdin);\n    return (S == T ? EOF : *S++);\n  }\n  return *S++;\n}\nint inp() {\n  int x = 0, f = 1;\n  char ch;\n  for (ch = getchar(); !isdigit(ch); ch = getchar())\n    if (ch == '-') f = -1;\n  for (; isdigit(ch); x = x * 10 + ch - '0', ch = getchar())\n    ;\n  return x * f;\n}\nunsigned inpu() {\n  unsigned x = 0;\n  char ch;\n  for (ch = getchar(); !isdigit(ch); ch = getchar())\n    ;\n  for (; isdigit(ch); x = x * 10 + ch - '0', ch = getchar())\n    ;\n  return x;\n}\nlong long inp_ll() {\n  long long x = 0;\n  int f = 1;\n  char ch;\n  for (ch = getchar(); !isdigit(ch); ch = getchar())\n    if (ch == '-') f = -1;\n  for (; isdigit(ch); x = x * 10 + ch - '0', ch = getchar())\n    ;\n  return x * f;\n}\nchar B[25], *outs = B + 20, *outr = B + 20;\ntemplate <class T>\ninline void print(register T a, register char x = 0) {\n  if (x) *--outs = x, x = 0;\n  if (!a)\n    *--outs = '0';\n  else\n    while (a) *--outs = (a % 10) + 48, a /= 10;\n  if (x) *--outs = x;\n  fwrite(outs, outr - outs, 1, stdout);\n  outs = outr;\n}\n};  // namespace io\nusing io ::inp;\nusing io ::inp_ll;\nusing io ::inpu;\nusing io ::print;\nusing i32 = int;\nusing i64 = long long;\nusing u8 = unsigned char;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing f64 = double;\nusing f80 = long double;\nlong long power(long long a, long long b, long long p) {\n  if (!b) return 1;\n  long long t = power(a, b / 2, p);\n  t = t * t % p;\n  if (b & 1) t = t * a % p;\n  return t;\n}\nlong long exgcd(long long a, long long b, long long &x, long long &y) {\n  if (b == 0) {\n    x = 1;\n    y = 0;\n    return a;\n  }\n  long long px, py;\n  long long d = exgcd(b, a % b, px, py);\n  x = py;\n  y = px - a / b * py;\n  return d;\n}\ntemplate <class T>\ninline void freshmin(T &a, const T &b) {\n  if (a > b) a = b;\n}\ntemplate <class T>\ninline void freshmax(T &a, const T &b) {\n  if (a < b) a = b;\n}\nconst int MAXN = 200010;\nconst int MOD = 1000000009;\nconst f80 MI = f80(1) / MOD;\nconst int INF = 1000000000;\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\nstruct node {\n  node *pre, *son[2];\n  int rev;\n} nodes[MAXN];\nnode *nil = nodes;\nstruct LinkCutTree {\n  void init(int n) {\n    nil->pre = nil->son[0] = nil->son[1] = nil;\n    nil->rev = 0;\n    for (int i = 1; i <= n; ++i) {\n      nodes[i].pre = nodes[i].son[0] = nodes[i].son[1] = nil;\n      nodes[i].rev = 0;\n    }\n  }\n  bool is_root(node *x) { return x->pre->son[0] != x && x->pre->son[1] != x; }\n  void reverse(node *x) {\n    if (x != nil) {\n      x->rev ^= 1;\n      swap(x->son[0], x->son[1]);\n    }\n  }\n  void clear(node *x) {\n    if (x->rev) {\n      reverse(x->son[0]);\n      reverse(x->son[1]);\n      x->rev = 0;\n    }\n  }\n  void update(node *x) {}\n  void rotate(node *x) {\n    node *y = x->pre, *z = y->pre;\n    int p = y->son[1] == x, q = p ^ 1;\n    if (!is_root(y)) z->son[z->son[1] == y] = x;\n    x->pre = z;\n    y->pre = x;\n    if (x->son[q]) x->son[q]->pre = y;\n    y->son[p] = x->son[q];\n    x->son[q] = y;\n    update(y);\n    update(x);\n  }\n  void clear_all(node *x) {\n    if (!is_root(x)) clear_all(x->pre);\n    clear(x);\n  }\n  void splay(node *x) {\n    clear_all(x);\n    while (!is_root(x)) {\n      node *y = x->pre, *z = y->pre;\n      if (!is_root(y)) rotate((y->son[0] == x) ^ (z->son[0] == y) ? x : y);\n      rotate(x);\n    }\n  }\n  void access(node *x0) {\n    for (node *x = x0, *y = nil; x != nil; x = x->pre) {\n      splay(x);\n      x->son[1] = y;\n      y = x;\n    }\n    splay(x0);\n  }\n  node *belong(node *x) {\n    access(x);\n    for (; x->son[0] != nil; x = x->son[0])\n      ;\n    splay(x);\n    return x;\n  }\n  bool check(node *x, node *y) {\n    node *fx = belong(x);\n    node *fy = belong(y);\n    return fx == fy;\n  }\n  void link(node *x, node *y) {\n    access(x);\n    reverse(x);\n    x->pre = y;\n  }\n  void cut(node *x, node *y) {\n    access(y);\n    splay(x);\n    if (x->pre == y)\n      x->pre = nil;\n    else {\n      access(x);\n      splay(y);\n      if (y->pre == x) y->pre = nil;\n    }\n  }\n  bool check(int x, int y) { return check(nodes + x, nodes + y); }\n  void link(int x, int y) { link(nodes + x, nodes + y); }\n  bool try_link(int x, int y) {\n    if (check(x, y)) return 1;\n    link(x, y);\n    return 0;\n  }\n  void cut(int x, int y) { cut(nodes + x, nodes + y); }\n} T;\nint n, m;\nint a[MAXN];\nvector<int> v[MAXN];\nint place(int i, int j) { return (i - 1) * m + j; }\nstruct segtree {\n  int add, min, cnt;\n} tree[MAXN * 4];\nvoid clear(int k) {\n  if (tree[k].add) {\n    tree[k << 1].add += tree[k].add;\n    tree[k << 1].min += tree[k].add;\n    tree[k << 1 | 1].add += tree[k].add;\n    tree[k << 1 | 1].min += tree[k].add;\n    tree[k].add = 0;\n  }\n}\nvoid update(int k) {\n  tree[k].min = min(tree[k << 1].min, tree[k << 1 | 1].min);\n  tree[k].cnt = (tree[k << 1].min == tree[k].min) * tree[k << 1].cnt +\n                (tree[k << 1 | 1].min == tree[k].min) * tree[k << 1 | 1].cnt;\n}\nvoid build(int k, int L, int R) {\n  if (L == R) {\n    tree[k].add = 0;\n    tree[k].min = 0;\n    tree[k].cnt = 1;\n    return;\n  }\n  int m = (L + R) / 2;\n  build(k << 1, L, m);\n  build(k << 1 | 1, m + 1, R);\n  update(k);\n}\nvoid add(int k, int L, int R, int x, int y, int p) {\n  if (L == x && R == y) {\n    tree[k].add += p;\n    tree[k].min += p;\n    return;\n  }\n  clear(k);\n  int m = (L + R) / 2;\n  if (y <= m)\n    add(k << 1, L, m, x, y, p);\n  else if (x > m)\n    add(k << 1 | 1, m + 1, R, x, y, p);\n  else {\n    add(k << 1, L, m, x, m, p);\n    add(k << 1 | 1, m + 1, R, m + 1, y, p);\n  }\n  update(k);\n}\npair<int, int> query(int k, int L, int R, int x, int y) {\n  if (L == x && R == y) return pair<int, int>(tree[k].min, tree[k].cnt);\n  clear(k);\n  int m = (L + R) / 2;\n  if (y <= m) return query(k << 1, L, m, x, y);\n  if (x > m) return query(k << 1 | 1, m + 1, R, x, y);\n  auto lans = query(k << 1, L, m, x, m);\n  auto rans = query(k << 1 | 1, m + 1, R, m + 1, y);\n  return pair<int, int>(min(lans.first, rans.first),\n                        (lans.first <= rans.first) * lans.second +\n                            (lans.first >= rans.first) * rans.second);\n}\nint main() {\n  n = inp();\n  m = inp();\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j) a[place(i, j)] = inp();\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n      for (int d = 0; d < 4; ++d) {\n        int x = i + dx[d], y = j + dy[d];\n        if (1 <= x && x <= n && 1 <= y && y <= m)\n          v[a[place(i, j)]].push_back(a[place(x, y)]);\n      }\n  long long ans = 0;\n  T.init(n * m);\n  build(1, 1, n * m);\n  for (int i = 1, j = 1; i <= n * m; ++i) {\n    while (1) {\n      int flag = 0;\n      for (auto x : v[i])\n        if (j <= x && x < i) flag |= T.try_link(x, i);\n      if (!flag) break;\n      for (auto x : v[i])\n        if (j <= x && x < i) T.cut(x, i);\n      for (auto x : v[j]) T.cut(x, j);\n      j++;\n    }\n    add(1, 1, n * m, j, i, 1);\n    for (auto x : v[i])\n      if (j <= x && x < i) add(1, 1, n * m, j, x, -1);\n    auto ret = query(1, 1, n * m, j, i);\n    if (ret.first == 1) ans += ret.second;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nint n, m;\nint mp[2020][2020];\nint pos[200200][2];\nint fl[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\nstruct LCT {\n  int s[200200][2];\n  int fa[200200];\n  bool rev[200200];\n  int get(int x) { return s[fa[x]][1] == x; }\n  bool nroot(int x) { return s[fa[x]][0] == x || s[fa[x]][1] == x; }\n  void rot(int x) {\n    int y = fa[x], z = fa[y], p = get(x), yp = get(y);\n    s[y][p] = s[x][!p];\n    if (s[x][!p]) fa[s[x][!p]] = y;\n    if (nroot(y)) s[z][yp] = x;\n    fa[x] = z;\n    fa[y] = x;\n    s[x][!p] = y;\n  }\n  void pd(int x) {\n    if (!rev[x]) return;\n    swap(s[x][0], s[x][1]);\n    if (s[x][0]) rev[s[x][0]] ^= 1;\n    if (s[x][1]) rev[s[x][1]] ^= 1;\n    rev[x] = 0;\n  }\n  void prepare(int x) {\n    if (nroot(x)) prepare(fa[x]);\n    pd(x);\n  }\n  void splay(int x) {\n    prepare(x);\n    int y;\n    while (nroot(x)) {\n      y = fa[x];\n      if (!nroot(y)) {\n        rot(x);\n        return;\n      }\n      if (get(x) == get(y))\n        rot(y);\n      else\n        rot(x);\n      rot(x);\n    }\n  }\n  void access(int x) {\n    for (int y = 0; x; x = fa[x]) splay(x), s[x][1] = y, y = x;\n  }\n  void makeroot(int x) {\n    access(x);\n    splay(x);\n    rev[x] ^= 1;\n    pd(x);\n  }\n  int findroot(int x) {\n    access(x);\n    splay(x);\n    pd(x);\n    while (s[x][0]) x = s[x][0], pd(x);\n    splay(x);\n    return x;\n  }\n  bool connect(int x, int y) { return findroot(x) == findroot(y); }\n  void link(int x, int y) {\n    makeroot(y);\n    fa[y] = x;\n  }\n  void cut(int x, int y) {\n    makeroot(x);\n    access(y);\n    splay(y);\n    s[y][0] = 0;\n    fa[x] = 0;\n  }\n} lct;\nstruct SEG {\n  int mi[2000200];\n  int mc[2000200];\n  int laz[2000200];\n  void pd(int rt) {\n    if (!laz[rt]) return;\n    laz[rt * 2] += laz[rt];\n    laz[rt * 2 + 1] += laz[rt];\n    mi[rt] += laz[rt];\n    laz[rt] = 0;\n  }\n  void up(int rt) {\n    if (mi[rt * 2] < mi[rt * 2 + 1])\n      mi[rt] = mi[rt * 2], mc[rt] = mc[rt * 2];\n    else {\n      mi[rt] = mi[rt * 2 + 1];\n      mc[rt] = mc[rt * 2 + 1];\n      if (mi[rt * 2] == mi[rt * 2 + 1]) mc[rt] += mc[rt * 2];\n    }\n  }\n  void build(int rt, int l, int r) {\n    mc[rt] = r - l + 1;\n    if (l == r) return;\n    int mid = (l + r) / 2;\n    build(rt * 2, l, mid);\n    build(rt * 2 + 1, mid + 1, r);\n  }\n  void change(int rt, int l, int r, int st, int ed, int v) {\n    pd(rt);\n    if (l > ed || r < st) return;\n    if (l >= st && r <= ed) {\n      laz[rt] += v;\n      pd(rt);\n      return;\n    }\n    int mid = (l + r) / 2;\n    change(rt * 2, l, mid, st, ed, v);\n    change(rt * 2 + 1, mid + 1, r, st, ed, v);\n    up(rt);\n  }\n  pair<int, int> Co(pair<int, int> a, pair<int, int> b) {\n    if (a.first < b.first)\n      return a;\n    else if (a.first > b.first)\n      return b;\n    return (pair<int, int>){a.first, a.second + b.second};\n  }\n  pair<int, int> ask(int rt, int l, int r, int st, int ed) {\n    pd(rt);\n    if (l > ed || r < st) return (pair<int, int>){inf, 0};\n    if (l >= st && r <= ed) {\n      return (pair<int, int>){mi[rt], mc[rt]};\n    }\n    int mid = (l + r) / 2;\n    return Co(ask(rt * 2, l, mid, st, ed), ask(rt * 2 + 1, mid + 1, r, st, ed));\n  }\n  int val(int rt, int l, int r, int p) {\n    pd(rt);\n    if (l == r) return mi[rt];\n    int mid = (l + r) / 2;\n    if (mid >= p)\n      return val(rt * 2, l, mid, p);\n    else\n      return val(rt * 2 + 1, mid + 1, r, p);\n  }\n} seg;\nint L = 1, R;\nint s;\nint tl[11];\nbool check(int p) {\n  int v;\n  int x = pos[p][0], y = pos[p][1], nx, ny;\n  bool res = 1;\n  int c = 0;\n  for (int i = 0; i < 4; ++i) {\n    nx = x + fl[i][0];\n    ny = y + fl[i][1];\n    v = mp[nx][ny];\n    if (v >= L && v <= R) {\n      if (lct.connect(p, v)) {\n        res = 0;\n        break;\n      }\n      lct.link(p, v);\n      c++;\n      tl[c] = v;\n    }\n  }\n  if (!res) {\n    for (int i = 1; i <= c; ++i) lct.cut(p, tl[i]);\n    return 0;\n  }\n  return 1;\n}\nvoid del(int p) {\n  int x = pos[p][0], y = pos[p][1], nx, ny, v;\n  for (int i = 0; i < 4; ++i) {\n    nx = x + fl[i][0], ny = y + fl[i][1];\n    v = mp[nx][ny];\n    if (v >= L && v <= R)\n      if (lct.connect(p, v)) lct.cut(p, v);\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j) {\n      scanf(\"%d\", &mp[i][j]);\n      pos[mp[i][j]][0] = i;\n      pos[mp[i][j]][1] = j;\n    }\n  long long ans = 0;\n  s = n * m;\n  int x, y, nx, ny, v;\n  pair<int, int> cur;\n  seg.build(1, 1, s);\n  for (R = 1; R <= s; ++R) {\n    while (!check(R)) {\n      del(L);\n      L++;\n    }\n    seg.change(1, 1, s, L, R, 1);\n    x = pos[R][0], y = pos[R][1];\n    for (int i = 0; i < 4; ++i) {\n      nx = x + fl[i][0];\n      ny = y + fl[i][1];\n      v = mp[nx][ny];\n      if (v >= L && v <= R) seg.change(1, 1, s, L, v, -1);\n    }\n    cur = seg.ask(1, 1, s, L, R);\n    if (cur.first == 1) ans += cur.second;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(3)\nusing namespace std;\ntemplate <typename T>\ninline bool chkmin(T &x, T y) {\n  return x > y ? x = y, 1 : 0;\n}\ntemplate <typename T>\ninline bool chkmax(T &x, T y) {\n  return x < y ? x = y, 1 : 0;\n}\ntemplate <typename T>\ninline void read(T &x) {\n  char ch = getchar();\n  int f = 1;\n  x = 0;\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();\n  x *= f;\n}\ntemplate <typename T, typename... Args>\ninline void read(T &x, Args &...args) {\n  read(x), read(args...);\n}\nint n, m, a[1050][1050], st;\nlong long ans;\npair<int, int> pos[200050];\nstruct LCT {\n  int fa[200050], ch[200050][2], tag[200050];\n  bool nroot(int u) { return ch[fa[u]][0] == u || ch[fa[u]][1] == u; }\n  bool son(int u) { return ch[fa[u]][1] == u; }\n  void rotate(int x) {\n    int y = fa[x], z = fa[y], k = son(x), w = ch[x][!k];\n    if (nroot(y)) ch[z][son(y)] = x;\n    ch[x][!k] = y, ch[y][k] = w;\n    fa[w] = y, fa[y] = x, fa[x] = z;\n  }\n  void put_tag(int u) { tag[u] ^= 1, swap(ch[u][0], ch[u][1]); }\n  void push(int u) {\n    if (tag[u]) put_tag(ch[u][0]), put_tag(ch[u][1]), tag[u] = 0;\n  }\n  void pushall(int u) {\n    if (nroot(u)) pushall(fa[u]);\n    push(u);\n  }\n  void splay(int x) {\n    pushall(x);\n    while (nroot(x)) {\n      int y = fa[x];\n      if (nroot(y)) rotate(son(y) ^ son(x) ? x : y);\n      rotate(x);\n    }\n  }\n  void access(int x) {\n    for (register int y = 0; x; x = fa[y = x]) splay(x), ch[x][1] = y;\n  }\n  void mroot(int u) { access(u), splay(u), put_tag(u); }\n  void split(int u, int v) { mroot(u), access(v), splay(v); }\n  void link(int u, int v) { split(u, v), fa[u] = v; }\n  void cut(int u, int v) { split(u, v), ch[v][0] = fa[u] = 0; }\n  int find(int u) {\n    access(u), splay(u);\n    while (ch[u][0]) push(u = ch[u][0]);\n    return splay(u), u;\n  }\n} T;\nstruct node {\n  int minv, cnt;\n  node operator+(const int x) { return node{minv + x, cnt}; }\n  node operator+(const node &x) {\n    node r;\n    r.minv = min(minv, x.minv);\n    r.cnt = cnt * (minv == r.minv) + x.cnt * (x.minv == r.minv);\n    return r;\n  }\n};\nstruct SGT {\n  int tag[200050 << 2];\n  node res[200050 << 2];\n  void build(int u, int l, int r) {\n    if (l == r) return (void)(res[u].cnt = 1);\n    build(u << 1, l, ((l + r) >> 1)), build(u << 1 | 1, ((l + r) >> 1) + 1, r);\n    res[u] = res[u << 1] + res[u << 1 | 1];\n  }\n  void put_tag(int u, int w) { tag[u] += w, res[u] = res[u] + w; }\n  void push(int u) {\n    if (tag[u])\n      put_tag(u << 1, tag[u]), put_tag(u << 1 | 1, tag[u]), tag[u] = 0;\n  }\n  void modify(int u, int l, int r, int tl, int tr, int w) {\n    if (tl <= l && r <= tr) return put_tag(u, w);\n    push(u);\n    if (tl <= ((l + r) >> 1)) modify(u << 1, l, ((l + r) >> 1), tl, tr, w);\n    if (((l + r) >> 1) < tr)\n      modify(u << 1 | 1, ((l + r) >> 1) + 1, r, tl, tr, w);\n    res[u] = res[u << 1] + res[u << 1 | 1];\n  }\n  node query(int u, int l, int r, int tl, int tr) {\n    if (tl <= l && r <= tr) return res[u];\n    push(u);\n    if (tr <= ((l + r) >> 1)) return query(u << 1, l, ((l + r) >> 1), tl, tr);\n    if (((l + r) >> 1) < tl)\n      return query(u << 1 | 1, ((l + r) >> 1) + 1, r, tl, tr);\n    return query(u << 1, l, ((l + r) >> 1), tl, tr) +\n           query(u << 1 | 1, ((l + r) >> 1) + 1, r, tl, tr);\n  }\n} S;\nvoid insert(int u, int v) {\n  if (v < st || v > u) return;\n  while (T.find(u) == T.find(v)) {\n    int x = pos[st].first, y = pos[st].second;\n    if (st <= a[x + 1][y] && a[x + 1][y] < u) T.cut(st, a[x + 1][y]);\n    if (st <= a[x - 1][y] && a[x - 1][y] < u) T.cut(st, a[x - 1][y]);\n    if (st <= a[x][y + 1] && a[x][y + 1] < u) T.cut(st, a[x][y + 1]);\n    if (st <= a[x][y - 1] && a[x][y - 1] < u) T.cut(st, a[x][y - 1]);\n    ++st;\n  }\n  if (st <= v) T.link(u, v);\n  S.modify(1, 1, n * m, 1, v, -1);\n}\nint main() {\n  read(n, m);\n  for (register int i = 1; i <= n; ++i)\n    for (register int j = 1; j <= m; ++j)\n      read(a[i][j]), pos[a[i][j]] = make_pair(i, j);\n  S.build(1, 1, n * m);\n  st = 1;\n  for (register int i = 1; i <= n * m; ++i) {\n    S.modify(1, 1, n * m, 1, i, 1);\n    int x = pos[i].first, y = pos[i].second;\n    insert(i, a[x - 1][y]), insert(i, a[x + 1][y]), insert(i, a[x][y - 1]),\n        insert(i, a[x][y + 1]);\n    node _r = S.query(1, 1, n * m, st, i);\n    ans += _r.cnt;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid maxtt(T &t1, T t2) {\n  t1 = max(t1, t2);\n}\ntemplate <typename T>\nvoid mintt(T &t1, T t2) {\n  t1 = min(t1, t2);\n}\nbool debug = 0;\nint n, m, k;\nint dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\nstring direc = \"URDL\";\nlong long ln, lk, lm;\nvoid etp(bool f = 0) {\n  puts(f ? \"YES\" : \"NO\");\n  exit(0);\n}\nvoid addmod(int &x, int y, int mod = 1000000007) {\n  assert(y >= 0);\n  x += y;\n  if (x >= mod) x -= mod;\n  assert(x >= 0 && x < mod);\n}\nvoid et(int x = -1) {\n  printf(\"%d\\n\", x);\n  exit(0);\n}\nlong long fastPow(long long x, long long y, int mod = 1000000007) {\n  long long ans = 1;\n  while (y > 0) {\n    if (y & 1) ans = (x * ans) % mod;\n    x = x * x % mod;\n    y >>= 1;\n  }\n  return ans;\n}\nlong long gcd1(long long x, long long y) { return y ? gcd1(y, x % y) : x; }\nint f[1005][1005], N;\npair<int, int> pos[200135];\nnamespace LCT {\nstruct SplayNode {\n} sn[200135];\nconst int N = 200135;\nint ch[N][2];\nint f[N], rev[N];\nvoid PushUp(int p) {}\nvoid PushDown(int p) {\n  if (rev[p]) {\n    swap(ch[p][0], ch[p][1]);\n    rev[ch[p][0]] ^= 1;\n    rev[ch[p][1]] ^= 1;\n    rev[p] = 0;\n  }\n}\nvoid Rotate(int x) {\n  int y = f[x], z = f[y], k = (ch[f[x]][1] == x);\n  if (!(ch[f[y]][0] != y && ch[f[y]][1] != y)) ch[z][ch[z][1] == y] = x;\n  ch[y][k] = ch[x][!k];\n  f[ch[y][k]] = y;\n  ch[x][!k] = y;\n  f[y] = x;\n  f[x] = z;\n  PushUp(y);\n  PushUp(x);\n}\ninline void Update(int p) {\n  if (!(ch[f[p]][0] != p && ch[f[p]][1] != p)) Update(f[p]);\n  PushDown(p);\n}\nvoid Splay(int x) {\n  Update(x);\n  for (int fa; (fa = f[x]) != 0 && !(ch[f[x]][0] != x && ch[f[x]][1] != x);\n       Rotate(x)) {\n    if (!(ch[f[fa]][0] != fa && ch[f[fa]][1] != fa))\n      Rotate((ch[f[fa]][1] == fa) == (ch[f[x]][1] == x) ? fa : x);\n  }\n  PushUp(x);\n  PushDown(x);\n}\nint Access(int x) {\n  int p;\n  for (p = 0; x; p = x, x = f[x]) {\n    Splay(x);\n    ch[x][1] = p;\n    PushUp(x);\n  }\n  return p;\n}\nvoid makeRoot(int p) {\n  Access(p);\n  Splay(p);\n  rev[p] ^= 1;\n}\nvoid path(int p, int q) {\n  makeRoot(p);\n  Access(q);\n  Splay(q);\n}\nint Find(int p) {\n  Access(p);\n  Splay(p);\n  while (ch[p][0]) {\n    PushDown(p);\n    p = ch[p][0];\n  }\n  return p;\n}\nvoid link(int u, int v) {\n  makeRoot(u);\n  makeRoot(v);\n  f[u] = v;\n  PushUp(v);\n}\nvoid cut(int u, int v) {\n  path(u, v);\n  ch[v][0] = 0;\n  f[u] = 0;\n  PushUp(u);\n  PushUp(v);\n}\n};  // namespace LCT\nnamespace ynk {\nstruct nd {\n  int mi, cnt;\n  nd() { mi = cnt = 0; }\n  friend nd operator+(const nd &x, const nd &y) {\n    nd res = nd();\n    res.mi = min(x.mi, y.mi);\n    if (res.mi == x.mi) res.cnt += x.cnt;\n    if (res.mi == y.mi) res.cnt += y.cnt;\n    return res;\n  }\n} T[200135 * 4];\nint lz[200135 * 4];\nvoid Up(int rt, int l, int r) { T[rt] = T[(rt << 1)] + T[(rt << 1 | 1)]; }\nvoid Down(int rt, int l, int r) {\n  if (lz[rt] != 0) {\n    T[(rt << 1)].mi += lz[rt];\n    lz[(rt << 1)] += lz[rt];\n    T[(rt << 1 | 1)].mi += lz[rt];\n    lz[(rt << 1 | 1)] += lz[rt];\n    lz[rt] = 0;\n  }\n}\nvoid build(int rt, int l, int r) {\n  lz[rt] = 0;\n  if (l + 1 == r) {\n    T[rt].cnt = 1;\n    return;\n  }\n  int mid = (l + r) / 2;\n  build((rt << 1), l, mid);\n  build((rt << 1 | 1), mid, r);\n  Up(rt, l, r);\n}\nvoid upt(int rt, int l, int r, int L, int R, int val) {\n  if (R <= l || r <= L) return;\n  if (L <= l && r <= R) {\n    T[rt].mi += val;\n    lz[rt] += val;\n    return;\n  }\n  Down(rt, l, r);\n  int mid = (l + r) / 2;\n  upt((rt << 1), l, mid, L, R, val);\n  upt((rt << 1 | 1), mid, r, L, R, val);\n  Up(rt, l, r);\n}\nnd qy(int rt, int l, int r, int L, int R) {\n  if (L <= l && r <= R) {\n    return T[rt];\n  }\n  Down(rt, l, r);\n  int mid = (l + r) / 2;\n  if (R <= mid)\n    return qy((rt << 1), l, mid, L, R);\n  else if (L >= mid)\n    return qy((rt << 1 | 1), mid, r, L, R);\n  else\n    return qy((rt << 1), l, mid, L, mid) + qy((rt << 1 | 1), mid, r, mid, R);\n}\n};  // namespace ynk\nvoid fmain(int tid) {\n  scanf(\"%d%d\", &n, &m);\n  for (int(i) = 1; (i) <= (int)(n); (i)++) {\n    for (int(j) = 1; (j) <= (int)(m); (j)++) {\n      scanf(\"%d\", &f[i][j]);\n      pos[f[i][j]] = {i, j};\n    }\n  }\n  N = n * m;\n  int R = 0;\n  ynk::build(1, 0, N);\n  set<pair<int, int> > sp;\n  long long ans = 0;\n  for (int(i) = 1; (i) <= (int)(N); (i)++) {\n    for (int(j) = 0; (j) < (int)(4); (j)++) {\n      int x = pos[i].first + dx[j], y = pos[i].second + dy[j];\n      if (f[x][y] == 0 || f[x][y] > i || f[x][y] <= R) continue;\n      int tar = f[x][y];\n      while (tar > R && LCT::Find(tar) == LCT::Find(i)) {\n        R++;\n        for (int(z) = 0; (z) < (int)(4); (z)++) {\n          int X = pos[R].first + dx[z], Y = pos[R].second + dy[z];\n          int u = min(R, f[X][Y]), v = max(R, f[X][Y]);\n          if (sp.count({u, v})) {\n            LCT::cut(u, v);\n            sp.erase({u, v});\n          }\n        }\n      }\n      if (tar > R) {\n        sp.insert({tar, i});\n        LCT::link(tar, i);\n      }\n    }\n    ynk::upt(1, 0, N, R, i, 1);\n    for (int(j) = 0; (j) < (int)(4); (j)++) {\n      int x = pos[i].first + dx[j], y = pos[i].second + dy[j];\n      if (f[x][y] == 0 || f[x][y] > i || f[x][y] <= R) continue;\n      int tar = f[x][y];\n      ynk::upt(1, 0, N, R, tar, -1);\n    }\n    ynk::nd tmp = ynk::qy(1, 0, N, R, i);\n    if (tmp.mi == 1) ans += tmp.cnt;\n  }\n  printf(\"%lld\\n\", ans);\n}\nint main() {\n  int t = 1;\n  for (int(i) = 1; (i) <= (int)(t); (i)++) {\n    fmain(i);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\ninline T rd() {\n  T nmb = 0;\n  int sgn = 0;\n  char chr = getchar();\n  while (!isdigit(chr)) {\n    if (chr == '-') sgn = 1;\n    chr = getchar();\n  }\n  while (isdigit(chr)) {\n    nmb = (nmb << 3) + (nmb << 1) + chr - '0';\n    chr = getchar();\n  }\n  return sgn ? -nmb : nmb;\n}\ntemplate <typename T>\nvoid wt(T nmb) {\n  if (nmb > 9) wt(nmb / 10);\n  putchar(nmb % 10 + '0');\n}\ntemplate <typename T>\ninline void cmax(T &x, T y) {\n  x = x > y ? x : y;\n}\ntemplate <typename T>\ninline void cmin(T &x, T y) {\n  x = x < y ? x : y;\n}\ninline void proc_status() {\n  ifstream t(\"/proc/self/status\");\n  cerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>())\n       << endl;\n}\nconst int N = 2e5 + 10;\nconst int inf = 2e9;\nnamespace LCT {\nint val[N];\nint fa[N], ch[N][2];\nint st[N], top;\nint tag[N];\ninline int notroot(int x) { return x == ch[fa[x]][0] || x == ch[fa[x]][1]; }\ninline int pos(int x) { return x == ch[fa[x]][1]; }\ninline void con(int f, int x, int t) { fa[x] = f, ch[f][t] = x; }\ninline void pushdown(int x) {\n  if (!tag[x]) return;\n  swap(ch[x][0], ch[x][1]);\n  tag[ch[x][0]] ^= 1, tag[ch[x][1]] ^= 1;\n  tag[x] = 0;\n}\ninline void rotate(int x) {\n  int y = fa[x], f = fa[y];\n  int xt = pos(x), yt = pos(y);\n  if (notroot(y))\n    con(f, x, yt);\n  else\n    fa[x] = f;\n  con(y, ch[x][xt ^ 1], xt);\n  con(x, y, xt ^ 1);\n}\ninline void splay(int x) {\n  top = 0;\n  while (notroot(x)) st[++top] = x, x = fa[x];\n  st[++top] = x;\n  for (int i = top; i; --i) pushdown(st[i]);\n  x = st[1];\n  while (notroot(x)) {\n    if (!notroot(fa[x]))\n      rotate(x);\n    else if (pos(x) == pos(fa[x]))\n      rotate(fa[x]), rotate(x);\n    else\n      rotate(x), rotate(x);\n  }\n}\ninline void access(int x) {\n  for (int lst = 0; x; lst = x, x = fa[x]) splay(x), ch[x][1] = lst;\n}\ninline void toroot(int x) {\n  access(x), splay(x);\n  tag[x] ^= 1;\n}\ninline int findroot(int x) {\n  access(x), splay(x);\n  while (ch[x][0]) x = ch[x][0];\n  splay(x);\n  return x;\n}\ninline void link(int x, int y) {\n  toroot(x);\n  if (findroot(y) == x) return;\n  fa[x] = y;\n}\ninline void cut(int x, int y) {\n  toroot(x);\n  if (findroot(y) != x) return;\n  if (fa[y] == x && !ch[x][0]) ch[x][1] = fa[y] = 0;\n}\n}  // namespace LCT\nusing namespace LCT;\nnamespace SGT {\nint mn[N << 2], num[N << 2], tag[N << 2];\ninline void build(int r, int x, int y) {\n  num[r] = y - x + 1;\n  if (x == y) return;\n  int m = (x + y) >> 1;\n  build(r << 1, x, m), build(r << 1 | 1, m + 1, y);\n}\ninline void pushup(int r) {\n  mn[r] = min(mn[r << 1], mn[r << 1 | 1]);\n  if (mn[r << 1] == mn[r << 1 | 1])\n    num[r] = num[r << 1] + num[r << 1 | 1];\n  else if (mn[r << 1] < mn[r << 1 | 1])\n    num[r] = num[r << 1];\n  else\n    num[r] = num[r << 1 | 1];\n}\ninline void pushdown(int r) {\n  if (!tag[r]) return;\n  mn[r << 1] += tag[r], mn[r << 1 | 1] += tag[r];\n  tag[r << 1] += tag[r], tag[r << 1 | 1] += tag[r];\n  tag[r] = 0;\n}\nvoid add(int r, int x, int y, int u, int v, int p) {\n  if (u <= x && y <= v) {\n    mn[r] += p;\n    tag[r] += p;\n    return;\n  }\n  pushdown(r);\n  int m = (x + y) >> 1;\n  if (u <= m) add(r << 1, x, m, u, v, p);\n  if (m < v) add(r << 1 | 1, m + 1, y, u, v, p);\n  pushup(r);\n}\npair<int, int> query(int r, int x, int y, int u, int v) {\n  if (u <= x && y <= v) return make_pair(mn[r], num[r]);\n  pushdown(r);\n  int m = (x + y) >> 1;\n  pair<int, int> res = make_pair(inf, 0);\n  if (u <= m) res = query(r << 1, x, m, u, v);\n  if (m < v) {\n    pair<int, int> rec = query(r << 1 | 1, m + 1, y, u, v);\n    if (res.first == rec.first)\n      res.second = res.second + rec.second;\n    else if (res.first > rec.first)\n      res.second = rec.second;\n    res.first = min(res.first, rec.first);\n  }\n  return res;\n}\n}  // namespace SGT\nusing namespace SGT;\nint dir[4][2] = {1, 0, 0, 1, -1, 0, 0, -1};\nint n, m, lim;\nint a[N];\npair<int, int> Pos[N];\nint col[N];\ninline int get(int x, int y) { return (x - 1) * m + y; }\ninline int Out(int x, int y) {\n  if (x < 1 || x > n || y < 1 || y > m) return 1;\n  return 0;\n}\ninline void Link(pair<int, int> t) {\n  for (int p = 0; p < 4; ++p) {\n    int u = t.first + dir[p][0], v = t.second + dir[p][1];\n    if (Out(u, v)) continue;\n    if (col[get(u, v)]) link(get(t.first, t.second), get(u, v));\n  }\n  col[get(t.first, t.second)] = 1;\n}\ninline void Cut(pair<int, int> t) {\n  for (int p = 0; p < 4; ++p) {\n    int u = t.first + dir[p][0], v = t.second + dir[p][1];\n    if (Out(u, v)) continue;\n    if (col[get(u, v)]) cut(get(t.first, t.second), get(u, v));\n  }\n  col[get(t.first, t.second)] = 0;\n}\nint Rec[4];\ninline int Linked(pair<int, int> t) {\n  for (int i = 0; i < 4; ++i) Rec[i] = 0;\n  for (int p = 0; p < 4; ++p) {\n    int u = t.first + dir[p][0], v = t.second + dir[p][1];\n    if (Out(u, v)) continue;\n    Rec[p] = findroot(get(u, v));\n  }\n  for (int i = 0; i < 4; ++i)\n    for (int j = i + 1; j < 4; ++j)\n      if (Rec[i] && Rec[j] && Rec[i] == Rec[j]) return 1;\n  return 0;\n}\nint main() {\n  n = rd<int>(), m = rd<int>();\n  lim = n * m;\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j) {\n      int k = rd<int>();\n      a[get(i, j)] = k;\n      Pos[k] = make_pair(i, j);\n    }\n  col[get(Pos[1].first, Pos[1].second)] = 1;\n  build(1, 1, lim);\n  add(1, 1, lim, 1, 1, 1);\n  long long Ans = 1;\n  for (int i = 2, k = 1; i <= lim; ++i) {\n    while (Linked(Pos[i])) Cut(Pos[k]), ++k;\n    Link(Pos[i]);\n    add(1, 1, lim, 1, i, 1);\n    for (int p = 0; p < 4; ++p) {\n      int u = Pos[i].first + dir[p][0], v = Pos[i].second + dir[p][1];\n      if (Out(u, v)) continue;\n      if (a[get(u, v)] < i) add(1, 1, lim, 1, a[get(u, v)], -1);\n    }\n    pair<int, int> res = query(1, 1, lim, k, i);\n    if (res.first == 1) Ans += res.second;\n  }\n  printf(\"%lld\\n\", Ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n  int t, next;\n} a[1000010];\nint f[1010][1010], head[200010], id[200010], num[200010], h[233], n, m, tt, tot;\ninline int rd() {\n  int x = 0;\n  char ch = getchar();\n  for (; ch < '0' || ch > '9'; ch = getchar())\n    ;\n  for (; ch >= '0' && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n  return x;\n}\ninline int min(const int &x, const int &y) { return (x < y) ? x : y; }\nnamespace lct {\nint ch[200010][2], fa[200010], mn[200010], st[200010], top;\nbool rev[200010];\ninline bool isroot(int x) { return (ch[fa[x]][0] != x) && (ch[fa[x]][1] != x); }\ninline void revv(int x) {\n  swap(ch[x][0], ch[x][1]);\n  rev[x] ^= 1;\n}\ninline void pushup(int x) {\n  mn[x] = num[x];\n  if (ch[x][0]) mn[x] = min(mn[x], mn[ch[x][0]]);\n  if (ch[x][1]) mn[x] = min(mn[x], mn[ch[x][1]]);\n}\ninline void pushdown(int x) {\n  if (!rev[x]) return;\n  if (ch[x][0]) revv(ch[x][0]);\n  if (ch[x][1]) revv(ch[x][1]);\n  rev[x] = false;\n}\ninline void rotate(int x) {\n  int y = fa[x], z = fa[y], l = (ch[y][1] == x);\n  if (!isroot(y)) ch[z][ch[z][1] == y] = x;\n  ch[y][l] = ch[x][l ^ 1];\n  ch[x][l ^ 1] = y;\n  fa[ch[y][l]] = y;\n  fa[y] = x;\n  fa[x] = z;\n  pushup(y);\n  pushup(x);\n}\ninline void splay(int x) {\n  st[top = 1] = x;\n  for (int i = x; !isroot(i); i = fa[i]) st[++top] = fa[i];\n  for (; top; top--) pushdown(st[top]);\n  while (!isroot(x)) {\n    int y = fa[x], z = fa[y];\n    if (!isroot(y)) {\n      if ((ch[y][0] == x) ^ (ch[z][0] == y))\n        rotate(x);\n      else\n        rotate(y);\n    }\n    rotate(x);\n  }\n}\ninline void access(int x) {\n  for (int y = 0; x; y = x, x = fa[x]) splay(x), ch[x][1] = y, pushup(x);\n}\ninline int findrt(int x) {\n  access(x);\n  splay(x);\n  for (; ch[x][0]; x = ch[x][0])\n    ;\n  splay(x);\n  return x;\n}\ninline void makert(int x) {\n  access(x);\n  splay(x);\n  revv(x);\n}\ninline void link(int x, int y) {\n  makert(x);\n  fa[x] = y;\n}\ninline void cut(int x, int y) {\n  makert(x);\n  access(y);\n  splay(y);\n  fa[ch[y][0]] = 0;\n  ch[y][0] = 0;\n  pushup(y);\n}\ninline int findmn(int x, int y) {\n  makert(x);\n  access(y);\n  splay(y);\n  return mn[y];\n}\n}  // namespace lct\nnamespace sgt {\npair<int, int> mn[800010];\nint tag[800010];\ninline pair<int, int> merge(pair<int, int> x, pair<int, int> y) {\n  if (x.first == y.first) return pair<int, int>(x.first, x.second + y.second);\n  return (x.first < y.first) ? x : y;\n}\ninline void pushdown(int o) {\n  if (!tag[o]) return;\n  mn[o << 1].first += tag[o];\n  tag[o << 1] += tag[o];\n  mn[o << 1 | 1].first += tag[o];\n  tag[o << 1 | 1] += tag[o];\n  tag[o] = 0;\n}\ninline void build(int o, int l, int r) {\n  tag[o] = 0;\n  if (l == r) {\n    mn[o] = pair<int, int>(0, 1);\n    return;\n  }\n  int mid = (l + r) >> 1;\n  build(o << 1, l, mid);\n  build(o << 1 | 1, mid + 1, r);\n  mn[o] = merge(mn[o << 1], mn[o << 1 | 1]);\n}\ninline void modify(int o, int l, int r, int x, int y, int hh) {\n  if (l >= x && r <= y) {\n    mn[o].first += hh;\n    tag[o] += hh;\n    return;\n  }\n  pushdown(o);\n  int mid = (l + r) >> 1;\n  if (x <= mid) modify(o << 1, l, mid, x, y, hh);\n  if (y > mid) modify(o << 1 | 1, mid + 1, r, x, y, hh);\n  mn[o] = merge(mn[o << 1], mn[o << 1 | 1]);\n}\ninline pair<int, int> query(int o, int l, int r, int x, int y) {\n  if (l >= x && r <= y) return mn[o];\n  pushdown(o);\n  int mid = (l + r) >> 1;\n  if (y <= mid) return query(o << 1, l, mid, x, y);\n  if (x > mid) return query(o << 1 | 1, mid + 1, r, x, y);\n  return merge(query(o << 1, l, mid, x, y),\n               query(o << 1 | 1, mid + 1, r, x, y));\n}\n}  // namespace sgt\nusing namespace sgt;\ninline void add(int x, int y) {\n  a[++tot].t = y;\n  a[tot].next = head[x];\n  head[x] = tot;\n}\ninline int calc(int x, int y) { return (x - 1) * m + y; }\nint main() {\n  n = rd();\n  m = rd();\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      num[calc(i, j)] = f[i][j] = rd(), id[f[i][j]] = calc(i, j);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) {\n      if (i > 1) add(calc(i, j), calc(i - 1, j));\n      if (i < n) add(calc(i, j), calc(i + 1, j));\n      if (j > 1) add(calc(i, j), calc(i, j - 1));\n      if (j < m) add(calc(i, j), calc(i, j + 1));\n    }\n  build(1, 1, n * m);\n  long long ans = 0;\n  int now = 0;\n  for (int hhh = 1; hhh <= n * m; hhh++) {\n    int x = id[hhh];\n    modify(1, 1, n * m, 1, hhh, 1);\n    if (hhh == 1)\n      now = 1;\n    else {\n      bool flag = true;\n      tt = 0;\n      for (int i = head[x]; i; i = a[i].next) {\n        int t = a[i].t;\n        if (num[t] >= now && num[t] < hhh) h[++tt] = t;\n      }\n      for (int i = 1; i <= tt; i++) {\n        int hh = h[i];\n        if (lct::findrt(hh) == lct::findrt(x)) {\n          flag = false;\n          break;\n        }\n        for (int j = 1; j < i; j++)\n          if (lct::findrt(hh) == lct::findrt(h[j])) {\n            flag = false;\n            break;\n          }\n        if (!flag) break;\n      }\n      while (!flag) {\n        int hh = id[now];\n        for (int i = head[hh]; i; i = a[i].next) {\n          int t = a[i].t;\n          if (num[t] > num[hh] && num[t] < hhh) lct::cut(hh, t);\n        }\n        now++;\n        flag = true;\n        tt = 0;\n        for (int i = head[x]; i; i = a[i].next) {\n          int t = a[i].t;\n          if (num[t] >= now && num[t] < hhh) h[++tt] = t;\n        }\n        for (int i = 1; i <= tt; i++) {\n          int hh = h[i];\n          if (lct::findrt(hh) == lct::findrt(x)) {\n            flag = false;\n            break;\n          }\n          for (int j = 1; j < i; j++)\n            if (lct::findrt(hh) == lct::findrt(h[j])) {\n              flag = false;\n              break;\n            }\n          if (!flag) break;\n        }\n      }\n    }\n    for (int i = head[x]; i; i = a[i].next) {\n      int t = a[i].t;\n      if (num[t] >= now && num[t] < hhh)\n        modify(1, 1, n * m, 1, num[t], -1), lct::link(x, t);\n    }\n    pair<int, int> ans1 = query(1, 1, n * m, now, hhh);\n    ans += ans1.second;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace zyt {\ntemplate <typename T>\ninline bool read(T &x) {\n  char c;\n  bool f = false;\n  x = 0;\n  do c = getchar();\n  while (c != EOF && c != '-' && !isdigit(c));\n  if (c == EOF) return false;\n  if (c == '-') f = true, c = getchar();\n  do x = x * 10 + c - '0', c = getchar();\n  while (isdigit(c));\n  if (f) x = -x;\n  return true;\n}\ntemplate <typename T>\ninline void write(T x) {\n  static char buf[20];\n  char *pos = buf;\n  if (x < 0) putchar('-'), x = -x;\n  do *pos++ = x % 10 + '0';\n  while (x /= 10);\n  while (pos > buf) putchar(*--pos);\n}\nconst int N = 1e3 + 10, P = 2e5 + 10;\nclass Link_Cut_Tree {\n private:\n  struct nulltag {};\n  struct node {\n    bool revtag;\n    node *fa, *s[2];\n    node(nulltag) : revtag(false) { fa = s[0] = s[1] = this; }\n    node() : revtag(false) { fa = s[0] = s[1] = null; }\n  } * pos[P];\n  static node *null;\n  static void update(node *const rot) {}\n  static void rev(node *const rot) {\n    swap(rot->s[0], rot->s[1]);\n    rot->revtag ^= 1;\n  }\n  static void pushdown(node *const rot) {\n    if (rot->revtag) {\n      if (rot->s[0] != null) rev(rot->s[0]);\n      if (rot->s[1] != null) rev(rot->s[1]);\n      rot->revtag = false;\n    }\n  }\n  static void pushdownall(node *const rot) {\n    if (!isrot(rot)) pushdownall(rot->fa);\n    pushdown(rot);\n  }\n  static bool dir(const node *const rot) { return rot->fa->s[1] == rot; }\n  static bool isrot(const node *const rot) {\n    return rot->fa->s[0] != rot && rot->fa->s[1] != rot;\n  }\n  static void rotate(node *const rot) {\n    node *f = rot->fa, *ff = f->fa;\n    bool d = dir(rot);\n    if (!isrot(f)) ff->s[dir(f)] = rot;\n    rot->fa = ff;\n    f->s[d] = rot->s[!d];\n    if (rot->s[!d] != null) rot->s[!d]->fa = f;\n    rot->s[!d] = f;\n    f->fa = rot;\n    update(f);\n  }\n  static void splay(node *const rot) {\n    pushdownall(rot);\n    while (!isrot(rot)) {\n      node *f = rot->fa;\n      if (isrot(f))\n        rotate(rot);\n      else if (dir(rot) ^ dir(f))\n        rotate(rot), rotate(rot);\n      else\n        rotate(f), rotate(rot);\n    }\n    update(rot);\n  }\n  static void access(node *rot) {\n    for (node *last = null; rot != null; last = rot, rot = rot->fa)\n      splay(rot), rot->s[1] = last, update(rot);\n  }\n  static void mkrot(node *const rot) { access(rot), splay(rot), rev(rot); }\n  static node *findrot(node *rot) {\n    access(rot), splay(rot);\n    pushdown(rot);\n    while (rot->s[0] != null) pushdown(rot = rot->s[0]);\n    splay(rot);\n    return rot;\n  }\n\n public:\n  void build(const int n) {\n    for (int i = 1; i <= n; i++) pos[i] = new node();\n  }\n  bool connect(const int x, const int y) {\n    return findrot(pos[x]) == findrot(pos[y]);\n  }\n  void link(const int x, const int y) {\n    node *rot1 = pos[x], *rot2 = pos[y];\n    mkrot(rot2), rot2->fa = rot1;\n  }\n  void cut(const int x, const int y) {\n    node *rot1 = pos[x], *rot2 = pos[y];\n    mkrot(rot1), access(rot2), splay(rot2);\n    rot2->s[0] = rot1->fa = null;\n    update(rot2);\n  }\n} lct;\nLink_Cut_Tree::node *Link_Cut_Tree::null =\n    new Link_Cut_Tree::node(Link_Cut_Tree::nulltag());\nnamespace Segment_Tree {\nstruct node {\n  int min, num, tag;\n} tree[P * 4];\nvoid update(node &a, const node &b, const node &c) {\n  if (b.min < c.min)\n    a = b, a.tag = 0;\n  else if (b.min > c.min)\n    a = c, a.tag = 0;\n  else\n    a = (node){b.min, b.num + c.num, 0};\n}\nvoid update(const int rot) {\n  update(tree[rot], tree[rot << 1], tree[rot << 1 | 1]);\n}\nvoid add(const int rot, const int x) { tree[rot].min += x, tree[rot].tag += x; }\nvoid pushdown(const int rot) {\n  if (tree[rot].tag) {\n    add(rot << 1, tree[rot].tag);\n    add(rot << 1 | 1, tree[rot].tag);\n    tree[rot].tag = 0;\n  }\n}\nvoid build(const int rot, const int lt, const int rt) {\n  if (lt == rt) {\n    tree[rot].min = -lt, tree[rot].num = 1;\n    return;\n  }\n  int mid = (lt + rt) >> 1;\n  build(rot << 1, lt, mid);\n  build(rot << 1 | 1, mid + 1, rt);\n  update(rot);\n}\nvoid add(const int rot, const int lt, const int rt, const int ls, const int rs,\n         const int x) {\n  if (ls <= lt && rt <= rs) {\n    add(rot, x);\n    return;\n  }\n  int mid = (lt + rt) >> 1;\n  pushdown(rot);\n  if (ls <= mid) add(rot << 1, lt, mid, ls, rs, x);\n  if (rs > mid) add(rot << 1 | 1, mid + 1, rt, ls, rs, x);\n  update(rot);\n}\nnode query(const int rot, const int lt, const int rt, const int ls,\n           const int rs) {\n  if (ls <= lt && rt <= rs) return tree[rot];\n  int mid = (lt + rt) >> 1;\n  pushdown(rot);\n  if (rs <= mid)\n    return query(rot << 1, lt, mid, ls, rs);\n  else if (ls > mid)\n    return query(rot << 1 | 1, mid + 1, rt, ls, rs);\n  else {\n    node a, b, c;\n    a = query(rot << 1, lt, mid, ls, rs);\n    b = query(rot << 1 | 1, mid + 1, rt, ls, rs);\n    update(c, a, b);\n    return c;\n  }\n}\n}  // namespace Segment_Tree\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, 1, -1};\nint n, m, p, arr[N][N];\npair<int, int> pos[P];\nlong long ans;\nint work() {\n  using namespace Segment_Tree;\n  read(n), read(m), p = n * m;\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      read(arr[i][j]), pos[arr[i][j]] = pair<int, int>(i, j);\n  lct.build(p);\n  int l = 1;\n  build(1, 1, p);\n  for (int r = 1; r <= p; r++) {\n    add(1, 1, p, 1, p, 1);\n    for (int d = 0; d < 4; d++) {\n      int x = dx[d] + pos[r].first, y = dy[d] + pos[r].second;\n      if (x > 0 && x <= n && y > 0 && y <= m && arr[x][y] < r) {\n        while (arr[x][y] >= l && lct.connect(r, arr[x][y])) {\n          for (int d = 0; d < 4; d++) {\n            int x = dx[d] + pos[l].first, y = dy[d] + pos[l].second;\n            if (x > 0 && x <= n && y > 0 && y <= m && arr[x][y] > l &&\n                arr[x][y] < r) {\n              lct.cut(l, arr[x][y]);\n              add(1, 1, p, 1, l, 1);\n            }\n          }\n          ++l;\n        }\n        if (arr[x][y] >= l) {\n          lct.link(r, arr[x][y]);\n          add(1, 1, p, 1, arr[x][y], -1);\n        }\n      }\n    }\n    node res = query(1, 1, p, l, r);\n    ans += (res.min == 0 ? res.num : 0);\n  }\n  write(ans);\n  return 0;\n}\n}  // namespace zyt\nint main() { return zyt::work(); }\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace Tzh {\nconst int maxn = 200010, maxm = 1010;\nconst int mx[] = {-1, 1, 0, 0}, my[] = {0, 0, -1, 1};\nint id[maxm][maxm], n, m, early[maxn], h;\nlong long ans;\npair<int, int> pos[maxn];\nnamespace LCT {\nstruct Tr {\n  int ch[2], rev, fa;\n} tree[maxn << 1];\nbool root(int now) {\n  return tree[tree[now].fa].ch[1] != now && tree[tree[now].fa].ch[0] != now;\n}\nvoid rotate(int now) {\n  int fa = tree[now].fa, ffa = tree[fa].fa, son = tree[fa].ch[1] == now;\n  if (!root(fa)) tree[ffa].ch[tree[ffa].ch[1] == fa] = now;\n  if (tree[now].ch[son ^ 1]) tree[tree[now].ch[son ^ 1]].fa = fa;\n  tree[fa].ch[son] = tree[now].ch[son ^ 1];\n  tree[fa].fa = now;\n  tree[now].fa = ffa;\n  tree[now].ch[son ^ 1] = fa;\n}\nvoid change(int now) {\n  tree[now].rev ^= 1;\n  swap(tree[now].ch[0], tree[now].ch[1]);\n}\nvoid pushdown(int now) {\n  if (tree[now].rev) {\n    change(tree[now].ch[0]);\n    change(tree[now].ch[1]);\n    tree[now].rev ^= 1;\n  }\n}\nvoid push(int now) {\n  if (!root(now)) push(tree[now].fa);\n  pushdown(now);\n}\nvoid splay(int now) {\n  push(now);\n  while (!root(now)) {\n    int fa = tree[now].fa;\n    if (root(fa))\n      rotate(now);\n    else if ((tree[tree[fa].fa].ch[1] == fa) ^ (tree[fa].ch[1] == now))\n      rotate(now), rotate(now);\n    else\n      rotate(fa), rotate(now);\n  }\n}\nvoid access(int fa) {\n  for (int now = 0; fa; now = fa, fa = tree[fa].fa)\n    splay(fa), tree[fa].ch[1] = now;\n}\nvoid makeroot(int now) {\n  access(now);\n  splay(now);\n  change(now);\n}\nint findroot(int now) {\n  access(now);\n  splay(now);\n  pushdown(now);\n  while (tree[now].ch[0]) push(tree[now].ch[0]), now = tree[now].ch[0];\n  splay(now);\n  return now;\n}\nvoid split(int x, int y) {\n  makeroot(y);\n  access(x);\n  splay(x);\n}\nvoid link(int x, int y) {\n  makeroot(x);\n  if (findroot(y) == x) return;\n  tree[x].fa = y;\n}\nvoid cut(int x, int y) {\n  makeroot(x);\n  if (findroot(y) == x && tree[y].fa == x && !tree[y].ch[1])\n    tree[y].fa = tree[x].ch[0] = 0;\n}\nbool connect(int x, int y) {\n  makeroot(y);\n  return findroot(x) == y;\n}\n}  // namespace LCT\nstruct Tr {\n  int tag, val, num;\n} tree[maxn << 2];\nbool check(int x, int y) {\n  for (int i = 0; i < 4; i++) {\n    int xx = x + mx[i], yy = y + my[i];\n    if (xx <= n && xx > 0 && yy <= m && yy > 0) {\n      if (id[x][y] < id[xx][yy] || id[xx][yy] < h) continue;\n      if (LCT::connect(id[x][y], id[xx][yy])) {\n        for (int i = 0; i < 4; i++) {\n          int xx = x + mx[i], yy = y + my[i];\n          if (xx <= n && xx > 0 && yy <= m && yy > 0)\n            LCT::cut(id[x][y], id[xx][yy]);\n        }\n        return 0;\n      }\n      LCT::link(id[x][y], id[xx][yy]);\n    }\n  }\n  return 1;\n}\nvoid del(int now) {\n  int x = pos[now].first, y = pos[now].second;\n  for (int i = 0; i < 4; i++) {\n    int xx = x + mx[i], yy = y + my[i];\n    if (xx <= n && xx > 0 && yy <= m && yy > 0) LCT::cut(id[x][y], id[xx][yy]);\n  }\n}\nvoid update(int now) {\n  tree[now].val = min(tree[now << 1 | 1].val, tree[now << 1].val);\n  tree[now].num = 0;\n  if (tree[now << 1].val == tree[now].val) tree[now].num += tree[now << 1].num;\n  if (tree[now << 1 | 1].val == tree[now].val)\n    tree[now].num += tree[now << 1 | 1].num;\n}\nvoid change(int now, int val) {\n  tree[now].tag += val;\n  tree[now].val += val;\n}\nvoid pushdown(int now) {\n  if (tree[now].tag != 0) {\n    change(now << 1, tree[now].tag);\n    change(now << 1 | 1, tree[now].tag);\n    tree[now].tag = 0;\n  }\n}\nvoid add(int now, int lt, int rt, int l, int r, int val) {\n  if (l > rt || r < lt) return;\n  int mid = lt + rt >> 1;\n  if (l <= lt && r >= rt) return change(now, val);\n  pushdown(now);\n  add(now << 1, lt, mid, l, r, val);\n  add(now << 1 | 1, mid + 1, rt, l, r, val);\n  update(now);\n}\nint ask(int now, int lt, int rt, int l, int r) {\n  if (l > rt || r < lt) return 0;\n  int mid = lt + rt >> 1;\n  if (l <= lt && r >= rt) return tree[now].val == 1 ? tree[now].num : 0;\n  pushdown(now);\n  return ask(now << 1, lt, mid, l, r) + ask(now << 1 | 1, mid + 1, rt, l, r);\n}\nvoid build(int now, int lt, int rt) {\n  tree[now].num = rt - lt + 1;\n  if (lt == rt) return;\n  int mid = lt + rt >> 1;\n  build(now << 1, lt, mid);\n  build(now << 1 | 1, mid + 1, rt);\n}\nvoid work() {\n  scanf(\"%d%d\", &n, &m);\n  h = 1;\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      scanf(\"%d\", &id[i][j]), pos[id[i][j]] = pair<int, int>(i, j);\n  for (int i = 1; i <= n * m; i++) {\n    int x = pos[i].first, y = pos[i].second;\n    while (!check(x, y)) del(h++);\n    early[i] = h;\n    for (int i = 0; i < 4; i++) {\n      int xx = x + mx[i], yy = y + my[i];\n      if (xx <= n && xx > 0 && yy <= m && yy > 0 && id[xx][yy] <= id[x][y] &&\n          id[xx][yy] >= h)\n        LCT::link(id[x][y], id[xx][yy]);\n    }\n  }\n  build(1, 1, n * m);\n  for (int i = 1; i <= n * m; i++) {\n    int x = pos[i].first, y = pos[i].second;\n    add(1, 1, n * m, 1, i, 1);\n    for (int j = 0; j < 4; j++) {\n      int xx = x + mx[j], yy = y + my[j];\n      if (xx <= n && xx > 0 && yy <= m && yy > 0)\n        if (id[xx][yy] <= i) add(1, 1, n * m, 1, id[xx][yy], -1);\n    }\n    ans += ask(1, 1, n * m, early[i], i);\n  }\n  printf(\"%lld\", ans);\n  return;\n}\n}  // namespace Tzh\nint main() {\n  Tzh::work();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct StVal {\n  int minV = 0, numMin = 0;\n  StVal() {}\n  StVal(const int _v) : minV(_v), numMin(1) {}\n  StVal(const StVal& v1, const StVal& v2) {\n    if (v1.minV < v2.minV) {\n      minV = v1.minV;\n      numMin = v1.numMin;\n    } else if (v1.minV > v2.minV) {\n      minV = v2.minV;\n      numMin = v2.numMin;\n    } else {\n      minV = v1.minV;\n      numMin = v1.numMin + v2.numMin;\n    }\n  }\n};\nstruct StUpdate {\n  int v = 0;\n  StUpdate() {}\n  StUpdate(const int v) : v(v) {}\n  StUpdate(const StUpdate& u1, const StUpdate& u2) { v = u1.v + u2.v; }\n  void apply(StVal& sv, const int lo, const int hi) { sv.minV += v; }\n};\nstruct SegTree {\n  int n;\n  vector<StVal> st;\n  vector<StUpdate> lazy;\n  vector<int> leaves;\n  SegTree(const int n) : n(n) {\n    leaves.resize(n);\n    init(1, 0, n - 1);\n    lazy.resize(st.size());\n  }\n  void init(const int si, const int lo, const int hi) {\n    if (lo == hi) {\n      if (si >= (int)st.size()) {\n        st.resize(si + 1);\n      }\n      st[si] = StVal(0);\n      leaves[lo] = si;\n      return;\n    }\n    int lC = si << 1, rC = (si << 1) | 1, mid = (lo + hi) >> 1;\n    init(lC, lo, mid);\n    init(rC, mid + 1, hi);\n    st[si] = StVal(st[lC], st[rC]);\n  }\n  void updateLazy(const int si, const int lo, const int hi) {\n    lazy[si].apply(st[si], lo, hi);\n    if (lo != hi) {\n      lazy[si << 1] = StUpdate(lazy[si << 1], lazy[si]);\n      lazy[si << 1 | 1] = StUpdate(lazy[si << 1 | 1], lazy[si]);\n    }\n    lazy[si] = StUpdate();\n  }\n  StVal query(const int l, const int r) {\n    return (l <= r && l < n && r >= 0) ? query(l, r, 1, 0, n - 1) : StVal();\n  }\n  StVal query(const int l, const int r, const int si, const int lo,\n              const int hi) {\n    updateLazy(si, lo, hi);\n    if (l <= lo && hi <= r) return st[si];\n    const int mid = (lo + hi) >> 1;\n    if (r <= mid) return query(l, r, si << 1, lo, mid);\n    if (mid < l) return query(l, r, si << 1 | 1, mid + 1, hi);\n    return StVal(query(l, r, si << 1, lo, mid),\n                 query(l, r, si << 1 | 1, mid + 1, hi));\n  }\n  void update(const int l, const int r, const StUpdate u) {\n    if (l <= r) update(l, r, u, 1, 0, n - 1);\n  }\n  void update(const int l, const int r, const StUpdate& u, const int si,\n              const int lo, const int hi) {\n    if (l <= lo && hi <= r) {\n      lazy[si] = StUpdate(lazy[si], u);\n      updateLazy(si, lo, hi);\n    } else {\n      updateLazy(si, lo, hi);\n      if (hi < l || r < lo) return;\n      const int mid = (lo + hi) >> 1;\n      update(l, r, u, si << 1, lo, mid);\n      update(l, r, u, si << 1 | 1, mid + 1, hi);\n      st[si] = StVal(st[si << 1], st[si << 1 | 1]);\n    }\n  }\n  void updateAllLazy() { updateAllLazy(1, 0, n - 1); }\n  void updateAllLazy(const int si, const int lo, const int hi) {\n    updateLazy(si, lo, hi);\n    if (lo != hi) {\n      const int mid = (lo + hi) >> 1;\n      updateAllLazy(si << 1, lo, mid);\n      updateAllLazy(si << 1 | 1, mid + 1, hi);\n    }\n  }\n};\nstruct NodeVal {\n  int subtreeSize;\n  NodeVal() : subtreeSize(1) {}\n  void update(NodeVal* lChild, NodeVal* rChild) {\n    subtreeSize = 1 + (lChild ? lChild->subtreeSize : 0) +\n                  (rChild ? rChild->subtreeSize : 0);\n  }\n};\nstruct Node {\n  int id;\n  array<Node*, 2> child{};\n  Node* splayTreeParent = nullptr;\n  Node* pathParentPointer = nullptr;\n  NodeVal* val;\n  bool reverse = false;\n  Node(int id, NodeVal* _val) : id(id), val(_val) {}\n  bool getSide() {\n    return splayTreeParent ? splayTreeParent->child[1] == this : false;\n  }\n  void applyReverseLazy() {\n    if (!reverse) {\n      return;\n    }\n    reverse = false;\n    swap(child[0], child[1]);\n    if (child[0]) {\n      child[0]->reverse = !child[0]->reverse;\n    }\n    if (child[1]) {\n      child[1]->reverse = !child[1]->reverse;\n    }\n  }\n  Node* splay() {\n    stack<Node*> ancestors;\n    Node* cur = this;\n    while (cur) {\n      ancestors.push(cur);\n      cur = cur->splayTreeParent;\n    }\n    while (ancestors.size()) {\n      ancestors.top()->applyReverseLazy();\n      ancestors.pop();\n    }\n    while (splayTreeParent) {\n      if (splayTreeParent->splayTreeParent) {\n        (getSide() == splayTreeParent->getSide() ? splayTreeParent : this)\n            ->rotate();\n      }\n      rotate();\n    }\n    return this;\n  }\n  Node* rotate() {\n    bool side = getSide(), parentSide = splayTreeParent->getSide();\n    auto ancestor = splayTreeParent->splayTreeParent;\n    pathParentPointer = splayTreeParent->pathParentPointer;\n    splayTreeParent->pathParentPointer = nullptr;\n    splayTreeParent->attach(child[!side], side);\n    attach(splayTreeParent, !side);\n    if (ancestor)\n      ancestor->attach(this, parentSide);\n    else\n      splayTreeParent = nullptr;\n    return this;\n  }\n  Node* attach(Node* node, int side) {\n    if (node) node->splayTreeParent = this;\n    child[side] = node;\n    val->update((child[0] ? child[0]->val : nullptr),\n                (child[1] ? child[1]->val : nullptr));\n    return this;\n  }\n  void detachChild(bool b) {\n    if (!child[b]) {\n      return;\n    }\n    child[b]->pathParentPointer = this;\n    child[b]->splayTreeParent = nullptr;\n    child[b] = nullptr;\n  }\n  Node* findMax() { return getDeepest(1); }\n  Node* findMin() { return getDeepest(0); }\n\n private:\n  Node* getDeepest(int dir) {\n    Node* u = this;\n    applyReverseLazy();\n    while (u && u->child[dir]) {\n      u = u->child[dir];\n      u->applyReverseLazy();\n    }\n    return u->splay();\n  }\n};\nstruct LinkCutTree {\n  int n = 0;\n  vector<Node*> nodes;\n  int addNode(NodeVal* nodeVal) {\n    nodes.push_back(new Node(n, nodeVal));\n    return n++;\n  }\n  void link(int parentId, int childId) {\n    Node *parent = nodes[parentId], *child = nodes[childId];\n    assert(findRoot(child->id) != findRoot(parent->id));\n    access(child);\n    access(parent);\n    Node* lChild = child->child[0];\n    if (lChild) {\n      lChild->reverse = !lChild->reverse;\n      child->detachChild(0);\n    }\n    child->attach(parent, 0);\n  }\n  void cut(int id) {\n    Node* u = nodes[id];\n    access(u);\n    assert(u->child[0]);\n    u->child[0]->splayTreeParent = nullptr;\n    u->child[0] = nullptr;\n  }\n  void cut(int id1, int id2) {\n    Node *u = nodes[id1], *v = nodes[id2];\n    access(u);\n    if (u->child[0] && u->child[0]->findMax() == v) {\n      cut(u->id);\n      return;\n    }\n    access(v);\n    if (v->child[0] && v->child[0]->findMax() == u) {\n      cut(v->id);\n      return;\n    }\n  }\n  int findRoot(int id) {\n    Node* u = nodes[id];\n    access(u);\n    Node* res = u->findMin();\n    access(res);\n    return res->id;\n  }\n  int LCA(int id1, int id2) {\n    Node *u = nodes[id1], *v = nodes[id2];\n    if (findRoot(u->id) != findRoot(v->id)) {\n      return -1;\n    }\n    access(u);\n    return access(v)->id;\n  }\n  int pathAggregate(int id) {\n    Node* u = nodes[id];\n    access(u);\n    return u->id;\n  }\n  Node* getNode(int id) { return nodes[id]; }\n\n private:\n  Node* access(Node* u) {\n    u->splay();\n    u->detachChild(1);\n    Node* curPP = u;\n    while (u->pathParentPointer) {\n      curPP = u->pathParentPointer;\n      curPP->splay();\n      curPP->detachChild(1);\n      curPP->attach(u, 1);\n      u->pathParentPointer = nullptr;\n      u->splay();\n    }\n    return curPP;\n  }\n};\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nvector<int> numToID;\nint n, m;\nvoid cutNeighbors(LinkCutTree& lct, vector<vector<int>>& grid, int l, int r) {\n  int i = numToID[l] / m, j = numToID[l] % m;\n  int idx = numToID[l];\n  for (int k = 0; k < 4; k++) {\n    int ni = i + dx[k], nj = j + dy[k];\n    if (ni < 0 || nj < 0 || ni == n || nj == m) {\n      continue;\n    }\n    if (grid[ni][nj] < l || grid[ni][nj] > r) {\n      continue;\n    }\n    int nIdx = numToID[grid[ni][nj]];\n    lct.cut(idx, nIdx);\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0), cout.tie(0);\n  LinkCutTree lct;\n  cin >> n >> m;\n  vector<vector<int>> grid(n, vector<int>(m));\n  numToID.resize(n * m + 1);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      cin >> grid[i][j];\n      numToID[grid[i][j]] = lct.addNode(new NodeVal());\n    }\n  }\n  SegTree st(n * m + 1);\n  long long ans = 0;\n  int l = 1;\n  for (int r = 1; r <= m * n; r++) {\n    st.update(l, r, StUpdate(1));\n    int i = numToID[r] / m, j = numToID[r] % m;\n    int idx = numToID[r];\n    for (int k = 0; k < 4; k++) {\n      int ni = i + dx[k], nj = j + dy[k];\n      if (ni < 0 || nj < 0 || ni == n || nj == m) {\n        continue;\n      }\n      if (grid[ni][nj] < l || grid[ni][nj] > r) {\n        continue;\n      }\n      int nIdx = numToID[grid[ni][nj]];\n      while (lct.findRoot(idx) == lct.findRoot(nIdx)) {\n        cutNeighbors(lct, grid, l, r);\n        l++;\n      }\n      if (l > grid[ni][nj]) {\n        continue;\n      }\n      if (l == r) {\n        break;\n      }\n      lct.link(idx, nIdx);\n      st.update(l, grid[ni][nj], StUpdate(-1));\n    }\n    ans += st.query(l, r).numMin;\n  }\n  cout << ans << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct StVal {\n  int minV = 0, numMin = 0;\n  StVal() {}\n  StVal(const int _v) : minV(_v), numMin(1) {}\n  StVal(const StVal& v1, const StVal& v2) {\n    if (v1.minV < v2.minV) {\n      minV = v1.minV;\n      numMin = v1.numMin;\n    } else if (v1.minV > v2.minV) {\n      minV = v2.minV;\n      numMin = v2.numMin;\n    } else {\n      minV = v1.minV;\n      numMin = v1.numMin + v2.numMin;\n    }\n  }\n};\nstruct StUpdate {\n  int v = 0;\n  StUpdate() {}\n  StUpdate(const int v) : v(v) {}\n  StUpdate(const StUpdate& u1, const StUpdate& u2) { v = u1.v + u2.v; }\n  void apply(StVal& sv, const int lo, const int hi) { sv.minV += v; }\n};\nstruct SegTree {\n  int n;\n  vector<StVal> st;\n  vector<StUpdate> lazy;\n  vector<int> leaves;\n  SegTree(const int n) : n(n) {\n    leaves.resize(n);\n    init(1, 0, n - 1);\n    lazy.resize(st.size());\n  }\n  void init(const int si, const int lo, const int hi) {\n    if (lo == hi) {\n      if (si >= (int)st.size()) {\n        st.resize(si + 1);\n      }\n      st[si] = StVal(0);\n      leaves[lo] = si;\n      return;\n    }\n    int lC = si << 1, rC = (si << 1) | 1, mid = (lo + hi) >> 1;\n    init(lC, lo, mid);\n    init(rC, mid + 1, hi);\n    st[si] = StVal(st[lC], st[rC]);\n  }\n  void updateLazy(const int si, const int lo, const int hi) {\n    lazy[si].apply(st[si], lo, hi);\n    if (lo != hi) {\n      lazy[si << 1] = StUpdate(lazy[si << 1], lazy[si]);\n      lazy[si << 1 | 1] = StUpdate(lazy[si << 1 | 1], lazy[si]);\n    }\n    lazy[si] = StUpdate();\n  }\n  StVal query(const int l, const int r) {\n    return (l <= r && l < n && r >= 0) ? query(l, r, 1, 0, n - 1) : StVal();\n  }\n  StVal query(const int l, const int r, const int si, const int lo,\n              const int hi) {\n    updateLazy(si, lo, hi);\n    if (l <= lo && hi <= r) return st[si];\n    const int mid = (lo + hi) >> 1;\n    if (r <= mid) return query(l, r, si << 1, lo, mid);\n    if (mid < l) return query(l, r, si << 1 | 1, mid + 1, hi);\n    return StVal(query(l, r, si << 1, lo, mid),\n                 query(l, r, si << 1 | 1, mid + 1, hi));\n  }\n  void update(const int l, const int r, const StUpdate u) {\n    if (l <= r) update(l, r, u, 1, 0, n - 1);\n  }\n  void update(const int l, const int r, const StUpdate& u, const int si,\n              const int lo, const int hi) {\n    if (l <= lo && hi <= r) {\n      lazy[si] = StUpdate(lazy[si], u);\n      updateLazy(si, lo, hi);\n    } else {\n      updateLazy(si, lo, hi);\n      if (hi < l || r < lo) return;\n      const int mid = (lo + hi) >> 1;\n      update(l, r, u, si << 1, lo, mid);\n      update(l, r, u, si << 1 | 1, mid + 1, hi);\n      st[si] = StVal(st[si << 1], st[si << 1 | 1]);\n    }\n  }\n  void updateAllLazy() { updateAllLazy(1, 0, n - 1); }\n  void updateAllLazy(const int si, const int lo, const int hi) {\n    updateLazy(si, lo, hi);\n    if (lo != hi) {\n      const int mid = (lo + hi) >> 1;\n      updateAllLazy(si << 1, lo, mid);\n      updateAllLazy(si << 1 | 1, mid + 1, hi);\n    }\n  }\n};\nstruct Node {\n  array<Node*, 2> child{};\n  Node* splayTreeParent = nullptr;\n  Node* pathParentPointer = nullptr;\n  bool reverse = false;\n  Node() {}\n  bool getSide() {\n    return splayTreeParent ? splayTreeParent->child[1] == this : false;\n  }\n  void tryReverse() {\n    if (!reverse) {\n      return;\n    }\n    reverse = false;\n    swap(child[0], child[1]);\n    if (child[0]) {\n      child[0]->reverse = !child[0]->reverse;\n    }\n    if (child[1]) {\n      child[1]->reverse = !child[1]->reverse;\n    }\n  }\n  Node* splay() {\n    vector<Node*> ancestors;\n    Node* cur = this;\n    while (cur) {\n      ancestors.push_back(cur);\n      cur = cur->splayTreeParent;\n    }\n    for (int i = ancestors.size() - 1; i >= 0; i--) {\n      if (!ancestors[i]) {\n        continue;\n      }\n      ancestors[i]->tryReverse();\n    }\n    while (splayTreeParent) {\n      if (splayTreeParent->splayTreeParent) {\n        (getSide() == splayTreeParent->getSide() ? splayTreeParent : this)\n            ->rotate();\n      }\n      rotate();\n    }\n    return this;\n  }\n  Node* rotate() {\n    bool side = getSide(), parentSide = splayTreeParent->getSide();\n    auto ancestor = splayTreeParent->splayTreeParent;\n    pathParentPointer = splayTreeParent->pathParentPointer;\n    splayTreeParent->pathParentPointer = nullptr;\n    splayTreeParent->attach(child[!side], side);\n    attach(splayTreeParent, !side);\n    if (ancestor)\n      ancestor->attach(this, parentSide);\n    else\n      splayTreeParent = nullptr;\n    return this;\n  }\n  Node* attach(Node* node, int side) {\n    if (node) node->splayTreeParent = this;\n    child[side] = node;\n    return this;\n  }\n};\nstruct LinkCutTreeGeneral {\n  void link(Node* parent, Node* child) {\n    assert(findRoot(child) != findRoot(parent));\n    access(child);\n    access(parent);\n    Node* lChild = child->child[0];\n    if (lChild) {\n      lChild->reverse = !lChild->reverse;\n      detachChild(child, 0);\n    }\n    child->attach(parent, 0);\n  }\n  void cut(Node* u) {\n    access(u);\n    assert(u->child[0]);\n    u->child[0]->splayTreeParent = nullptr;\n    u->child[0] = nullptr;\n  }\n  void cut(Node* u, Node* v) {\n    access(v);\n    access(u);\n    if (u->child[0] && findMax(u->child[0]) == v) {\n      cut(u);\n      return;\n    }\n    access(v);\n    if (v->child[0] && findMax(v->child[0]) == u) {\n      cut(v);\n    }\n  }\n  Node* findRoot(Node* u) {\n    access(u);\n    while (u->child[0]) {\n      u = u->child[0];\n    }\n    access(u);\n    return u;\n  }\n\n private:\n  Node* access(Node* u) {\n    u->splay();\n    detachChild(u, 1);\n    Node* curPP = u;\n    while (u->pathParentPointer) {\n      curPP = u->pathParentPointer;\n      curPP->splay();\n      detachChild(curPP, 1);\n      curPP->attach(u, 1);\n      u->pathParentPointer = nullptr;\n      u->splay();\n    }\n    return curPP;\n  }\n  Node* findMax(Node* u) {\n    if (!u) {\n      return nullptr;\n    }\n    while (u->child[1]) {\n      u = u->child[1];\n    }\n    return u;\n  }\n  void detachChild(Node* u, bool b) {\n    if (!u->child[b]) {\n      return;\n    }\n    u->child[b]->pathParentPointer = u;\n    u->child[b]->splayTreeParent = nullptr;\n    u->child[b] = nullptr;\n  }\n};\nstruct NodeWithId : Node {\n  int id;\n  NodeWithId(int id) : Node(), id(id) {}\n};\nstruct DynamicTreeLCT {\n  LinkCutTreeGeneral lct;\n  vector<NodeWithId*> nodes;\n  int n = 0;\n  DynamicTreeLCT() {}\n  int addNode() {\n    nodes.push_back(new NodeWithId(n));\n    return n++;\n  }\n  void link(int parentId, int childId) {\n    lct.link(nodes[parentId], nodes[childId]);\n  }\n  void cut(int id) { lct.cut(nodes[id]); }\n  void cut(int u, int v) { lct.cut(nodes[u], nodes[v]); }\n  int findRoot(int u) {\n    auto res = (NodeWithId*)lct.findRoot(nodes[u]);\n    return res->id;\n  }\n  bool connected(int u, int v) { return findRoot(u) == findRoot(v); }\n};\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nvector<int> numToID;\nint n, m;\nvoid cutNeighbors(DynamicTreeLCT& lct, vector<vector<int>>& grid, int l,\n                  int r) {\n  int i = numToID[l] / m, j = numToID[l] % m;\n  int idx = numToID[l];\n  for (int k = 0; k < 4; k++) {\n    int ni = i + dx[k], nj = j + dy[k];\n    if (ni < 0 || nj < 0 || ni == n || nj == m) {\n      continue;\n    }\n    if (grid[ni][nj] < l || grid[ni][nj] > r) {\n      continue;\n    }\n    int nIdx = numToID[grid[ni][nj]];\n    lct.cut(idx, nIdx);\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0), cout.tie(0);\n  DynamicTreeLCT lct;\n  cin >> n >> m;\n  vector<vector<int>> grid(n, vector<int>(m));\n  numToID.resize(n * m + 1);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      cin >> grid[i][j];\n      numToID[grid[i][j]] = lct.addNode();\n    }\n  }\n  SegTree st(n * m + 1);\n  long long ans = 0;\n  int l = 1;\n  for (int r = 1; r <= m * n; r++) {\n    st.update(l, r, StUpdate(1));\n    int i = numToID[r] / m, j = numToID[r] % m;\n    int idx = numToID[r];\n    for (int k = 0; k < 4; k++) {\n      int ni = i + dx[k], nj = j + dy[k];\n      if (ni < 0 || nj < 0 || ni == n || nj == m) {\n        continue;\n      }\n      if (grid[ni][nj] < l || grid[ni][nj] > r) {\n        continue;\n      }\n      int nIdx = numToID[grid[ni][nj]];\n      while (lct.connected(idx, nIdx)) {\n        cutNeighbors(lct, grid, l, r);\n        l++;\n      }\n      if (l > grid[ni][nj]) {\n        continue;\n      }\n      if (l == r) {\n        break;\n      }\n      lct.link(idx, nIdx);\n      st.update(l, grid[ni][nj], StUpdate(-1));\n    }\n    ans += st.query(l, r).numMin;\n  }\n  cout << ans << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing nagai = long long;\nconst int N = 1 << 18;\nint fa[N], sz[N];\nint flag[N];\nint ch[N][2];\nint chnum(int x) { return ch[fa[x]][1] == x; }\nint is_r(int x) { return !(ch[fa[x]][1] == x || ch[fa[x]][0] == x); }\nvoid push(int x) {\n  if (flag[x]) {\n    swap(ch[x][0], ch[x][1]);\n    flag[ch[x][0]] ^= 1, flag[ch[x][1]] ^= 1;\n    flag[x] = 0;\n  }\n}\nvoid rev(int x) {\n  flag[x] = true;\n  push(x);\n}\nvoid update(int x) {\n  if (x) sz[x] = 1 + sz[ch[x][0]] + sz[ch[x][1]];\n}\nvoid attach(int x, int y, int side) {\n  fa[x] = y;\n  ch[y][side] = x;\n}\nvoid check(int x) { assert(sz[x] == sz[ch[x][0]] + sz[ch[x][1]] + 1); }\nvoid rotate(int x) {\n  int y = fa[x], z = fa[y], b = chnum(x), t = ch[x][b ^ 1];\n  int c = chnum(fa[x]);\n  if (!is_r(y))\n    attach(x, z, c);\n  else\n    fa[x] = z;\n  attach(y, x, b ^ 1);\n  attach(t, y, b);\n  update(y);\n  update(x);\n}\nvoid splay(int x) {\n  static int mem[N];\n  static int ptr = 0;\n  int y = x;\n  while (!is_r(y)) mem[ptr++] = y, y = fa[y];\n  mem[ptr++] = y;\n  while (ptr > 0) push(mem[ptr - 1]), --ptr;\n  while (!is_r(x)) {\n    int y = fa[x];\n    if (!is_r(fa[x])) rotate(chnum(x) == chnum(y) ? y : x);\n    rotate(x);\n  }\n}\nvoid print(int x) {\n  if (!x) return;\n  check(x);\n  print(ch[x][0]);\n  cerr << x << ' ';\n  print(ch[x][1]);\n}\nvoid access(int x) {\n  for (int dwn = 0; x; dwn = x, x = fa[x]) splay(x), ch[x][1] = dwn, update(x);\n}\nvoid makeroot(int x) { access(x), splay(x), rev(x); }\nbool is_conn(int x, int y) {\n  if (x == y) return 1;\n  makeroot(x);\n  makeroot(y);\n  return !(fa[x] == 0 && fa[y] == 0);\n}\nvoid cut(int x, int y) {\n  makeroot(x);\n  access(y);\n  splay(y);\n  assert(ch[y][0] == x);\n  ch[y][0] = fa[x] = 0;\n  update(y);\n}\nvoid link(int x, int y) {\n  makeroot(x);\n  makeroot(y);\n  assert(fa[x] == 0);\n  fa[x] = y;\n}\nint n, m;\nconst int S = 1010;\nint matr[S][S];\nint nocyc[N];\nint kek(pair<int, int> mem) { return mem.first * m + mem.second + 1; }\nvector<int> dx = {0, 1, 0, -1}, dy = {1, 0, -1, 0};\nbool added[N];\nvector<int> neigh(int a) {\n  --a;\n  int x = a / m, y = a % m;\n  vector<int> ans;\n  for (int i = 0; i < 4; ++i) {\n    int x1 = x + dx[i], y1 = y + dy[i];\n    if (x1 >= 0 && y1 >= 0 && x1 < n && y1 < m && added[x1 * m + y1 + 1])\n      ans.push_back(x1 * m + y1 + 1);\n  }\n  return ans;\n}\nbool check(pair<int, int> a) {\n  int x = kek(a);\n  auto ne = neigh(x);\n  for (int i = 0; i < ne.size(); ++i)\n    for (int j = 0; j < i; ++j)\n      if (is_conn(ne[i], ne[j])) return false;\n  return true;\n}\nvoid add(pair<int, int> a) {\n  int x = kek(a);\n  added[x] = true;\n  for (int y : neigh(x)) {\n    assert(!is_conn(x, y));\n    link(x, y);\n  }\n}\nvoid rem(pair<int, int> a) {\n  int x = kek(a);\n  added[x] = false;\n  for (int y : neigh(x)) {\n    assert(is_conn(x, y));\n    cut(x, y);\n  }\n}\nconst int oo = 1e9;\nint C = 1;\nstruct it {\n  int sum[2 * N], mn[2 * N], mn1[2 * N], cntmn[2 * N], cntmn1[2 * N];\n  it() {\n    for (int i = 2 * N - 1; i >= 0; --i) {\n      if (i < n)\n        update(i);\n      else\n        sum[i] = 0, mn[i] = 0, cntmn[i] = 1, cntmn1[i] = 0;\n    }\n  }\n  void update(int i) {\n    int le = 2 * i;\n    int ri = 2 * i + 1;\n    sum[i] = sum[le] + sum[ri];\n    mn[i] = min(mn[2 * i], sum[le] + mn[2 * i + 1]);\n    cntmn[i] = 0;\n    if (mn[le] == mn[i]) cntmn[i] += cntmn[le];\n    if (sum[le] + mn[ri] == mn[i]) cntmn[i] += cntmn[ri];\n  }\n  void add(int i, int ch) {\n    i += N;\n    sum[i] += ch;\n    mn[i] = sum[i];\n    cntmn[i] = 1;\n    while (i > 1) update(i >> 1), i >>= 1;\n  }\n  int get(int x, int l, int r, int ql, int qr, int cur) {\n    if (cur + mn[x] > C) return 0;\n    if (l >= qr || ql >= r) return 0;\n    if (ql <= l && r <= qr)\n      if (cur + mn[x] == C)\n        return cntmn[x];\n      else {\n        return 0;\n      }\n    int m = (l + r) / 2;\n    return get(x * 2, l, m, ql, qr, cur) +\n           get(x * 2 + 1, m, r, ql, qr, cur + sum[x * 2]);\n  }\n} myit;\nmt19937 rnd(228);\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  n = 1000, m = 200;\n  cin >> n >> m;\n  vector<int> kekos(n * m);\n  iota(kekos.begin(), kekos.end(), 1);\n  shuffle(kekos.begin(), kekos.end(), rnd);\n  for (int i = 0; i < n * m; ++i) sz[i] = 1;\n  int t = 0;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j) {\n      matr[i][j] = kekos[t++];\n      cin >> matr[i][j];\n      --matr[i][j];\n    }\n  vector<pair<int, int>> ord;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j) ord.emplace_back(i, j);\n  sort(ord.begin(), ord.end(), [&](pair<int, int> a, pair<int, int> b) {\n    return matr[a.first][a.second] < matr[b.first][b.second];\n  });\n  int cur = ord.size();\n  for (int i = ord.size() - 1; i >= 0; --i) {\n    while (!check(ord[i])) rem(ord[--cur]);\n    nocyc[i] = cur;\n    add(ord[i]);\n  }\n  memset(added, 0, sizeof added);\n  nagai ansich = 0;\n  for (int i = ord.size() - 1; i >= 0; --i) {\n    int x = ord[i].first, y = ord[i].second;\n    myit.add(i, 1);\n    for (int k = 0; k < 4; ++k) {\n      int x1 = x + dx[k], y1 = y + dy[k];\n      if (x1 >= 0 && y1 >= 0 && x1 < n && y1 < m && added[matr[x1][y1]])\n        myit.add(matr[x1][y1], -1);\n    }\n    added[i] = true;\n    int mem = myit.get(1, 0, N, i, nocyc[i], 0);\n    ansich += mem;\n  }\n  cout << ansich << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename Tp>\ninline void read(Tp &x) {\n  static char c;\n  static bool neg;\n  x = 0, c = getchar(), neg = false;\n  for (; !isdigit(c); c = getchar()) {\n    if (c == '-') {\n      neg = true;\n    }\n  }\n  for (; isdigit(c); c = getchar()) {\n    x = x * 10 + c - '0';\n  }\n  if (neg) {\n    x = -x;\n  }\n}\nconst int N = 1000 + 5;\nconst int M = 2e5 + 5;\nconst int INF = 0x3f3f3f3f;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\nnamespace LCT {\nstruct Node {\n  Node *son[2], *fa;\n  bool rev;\n  inline int type() {\n    if (fa->son[0] == this) {\n      return 0;\n    } else if (fa->son[1] == this) {\n      return 1;\n    } else {\n      return 2;\n    }\n  }\n  inline void pushUp();\n  inline void pushDown();\n};\nNode pool[M];\nint poolCnt;\nNode *null;\ninline void Node::pushUp() {}\ninline void Node::pushDown() {\n  if (rev) {\n    swap(son[0], son[1]);\n    if (son[0] != null) {\n      son[0]->rev ^= true;\n    }\n    if (son[1] != null) {\n      son[1]->rev ^= true;\n    }\n    rev = false;\n  }\n}\ninline void init(const int MX) {\n  null = &pool[0];\n  for (int i = 1; i <= MX; ++i) {\n    pool[i].fa = pool[i].son[0] = pool[i].son[1] = null;\n  }\n}\ninline void rotate(Node *now) {\n  Node *fa = now->fa, *gr = fa->fa;\n  int nowType = now->type(), faType;\n  if (nowType == 2) {\n    return;\n  }\n  faType = fa->type();\n  fa->son[nowType] = now->son[nowType ^ 1];\n  now->son[nowType ^ 1]->fa = fa;\n  now->son[nowType ^ 1] = fa;\n  fa->fa = now;\n  if (faType != 2) {\n    gr->son[faType] = now;\n  }\n  now->fa = gr;\n  fa->pushUp();\n  now->pushUp();\n}\ninline void splay(Node *now) {\n  static Node *stack[M];\n  int top = 0;\n  while (now->type() != 2) {\n    stack[++top] = now;\n    now = now->fa;\n  }\n  stack[++top] = now;\n  while (top != 0) {\n    stack[top--]->pushDown();\n  }\n  now = stack[1];\n  int nowType = now->type(), faType;\n  while (nowType != 2) {\n    Node *fa = now->fa;\n    faType = fa->type();\n    if (faType != 2) {\n      if (nowType == faType) {\n        rotate(fa);\n      } else {\n        rotate(now);\n      }\n    }\n    rotate(now);\n    nowType = now->type();\n  }\n}\ninline void access(Node *now) {\n  Node *prev = null;\n  while (now != null) {\n    splay(now);\n    now->son[1] = prev;\n    now->pushUp();\n    prev = now;\n    now = now->fa;\n  }\n}\ninline void makeRoot(Node *now) {\n  access(now);\n  splay(now);\n  now->rev = true;\n}\ninline Node *findRoot(Node *now) {\n  access(now);\n  splay(now);\n  while (now->son[0] != null) {\n    now->pushDown();\n    now = now->son[0];\n  }\n  return now;\n}\ninline Node *findRoot(int id) { return findRoot(pool + id); }\ninline void link(Node *u, Node *v) {\n  makeRoot(u);\n  if (findRoot(v) != u) {\n    u->fa = v;\n  }\n}\ninline void link(int u, int v) { link(pool + u, pool + v); }\ninline void cut(Node *u, Node *v) {\n  makeRoot(u);\n  if (findRoot(v) == u && u->son[1] == null && u->fa == v) {\n    u->fa = v->son[0] = null;\n  }\n}\ninline void cut(int u, int v) { cut(pool + u, pool + v); }\n}  // namespace LCT\nnamespace Seg {\nstruct Node {\n  int min, cnt, tag;\n};\nNode node[M * 4];\ninline void pushUp(int u) {\n  node[u].min = std::min(node[((u) << 1)].min, node[((u) << 1 | 1)].min);\n  node[u].cnt = 0;\n  if (node[u].min == node[((u) << 1)].min) {\n    node[u].cnt += node[((u) << 1)].cnt;\n  }\n  if (node[u].min == node[((u) << 1 | 1)].min) {\n    node[u].cnt += node[((u) << 1 | 1)].cnt;\n  }\n}\ninline void pushDown(int u) {\n  if (!node[u].tag) {\n    return;\n  }\n  node[((u) << 1)].min += node[u].tag;\n  node[((u) << 1)].tag += node[u].tag;\n  node[((u) << 1 | 1)].min += node[u].tag;\n  node[((u) << 1 | 1)].tag += node[u].tag;\n  node[u].tag = 0;\n}\nvoid build(int u, int l, int r) {\n  node[u].min = 0;\n  node[u].cnt = r - l + 1;\n  if (l == r) {\n    return;\n  }\n  int mid = (l + r) >> 1;\n  build(((u) << 1), l, mid);\n  build(((u) << 1 | 1), mid + 1, r);\n  pushUp(u);\n}\nvoid update(int u, int l, int r, int ul, int ur, int x) {\n  if (ul <= l && r <= ur) {\n    node[u].min += x;\n    node[u].tag += x;\n    return;\n  }\n  pushDown(u);\n  int mid = (l + r) >> 1;\n  if (ul <= mid) {\n    update(((u) << 1), l, mid, ul, ur, x);\n  }\n  if (mid < ur) {\n    update(((u) << 1 | 1), mid + 1, r, ul, ur, x);\n  }\n  pushUp(u);\n}\npair<int, int> query(int u, int l, int r, int ql, int qr) {\n  if (qr < l || ql > r) {\n    return (pair<int, int>){INF, 0};\n  }\n  if (ql <= l && r <= qr) {\n    return (pair<int, int>){node[u].min, node[u].cnt};\n  }\n  pushDown(u);\n  int mid = (l + r) >> 1;\n  pair<int, int> res = (pair<int, int>){INF, 0}, pir;\n  if (ql <= mid) {\n    res = std::min(res, query(((u) << 1), l, mid, ql, qr));\n  }\n  if (mid < qr) {\n    pir = query(((u) << 1 | 1), mid + 1, r, ql, qr);\n    if (res.first > pir.first) {\n      res = pir;\n    } else if (res.first == pir.first) {\n      res.second += pir.second;\n    }\n  }\n  return res;\n}\n}  // namespace Seg\nint n, m, e;\nint f[N][N];\nvector<int> gt[M], lt[M];\nint main() {\n  read(n), read(m);\n  e = n * m;\n  LCT::init(e);\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= m; ++j) {\n      read(f[i][j]);\n    }\n  }\n  long long ans = 0;\n  for (int x = 1, nx, ny; x <= n; ++x) {\n    for (int y = 1; y <= m; ++y) {\n      for (int i = 0; i < 4; ++i) {\n        nx = x + dx[i], ny = y + dy[i];\n        if (nx > 0 && nx <= n && ny > 0 && ny <= m) {\n          if (f[x][y] > f[nx][ny]) {\n            lt[f[x][y]].emplace_back(f[nx][ny]);\n          } else {\n            gt[f[x][y]].emplace_back(f[nx][ny]);\n          }\n        }\n      }\n    }\n  }\n  Seg::build(1, 1, e);\n  int r = 0;\n  for (int l = 1; l <= e; ++l) {\n    bool cir = false;\n    for (int nr = r + 1; nr <= e; ++nr) {\n      vector<int> vec;\n      for (const auto &v : lt[nr]) {\n        if (v >= l) {\n          if (LCT::findRoot(nr) == LCT::findRoot(v)) {\n            cir = true;\n            break;\n          }\n          LCT::link(nr, v);\n          vec.emplace_back(v);\n        }\n      }\n      for (const auto &v : vec) {\n        LCT::cut(nr, v);\n      }\n      if (cir) {\n        break;\n      }\n      ++r;\n      int edge = 0;\n      for (const auto &v : lt[nr]) {\n        if (v >= l) {\n          LCT::link(nr, v);\n          ++edge;\n        }\n      }\n      Seg::update(1, 1, e, nr, e, -edge);\n      Seg::update(1, 1, e, nr, nr, r - l + 1);\n    }\n    pair<int, int> res = Seg::query(1, 1, e, l, r);\n    if (res.first == 1) {\n      ans += res.second;\n    }\n    for (const auto &v : gt[l]) {\n      if (v <= r) {\n        LCT::cut(l, v);\n        Seg::update(1, 1, e, v, e, 1);\n      }\n    }\n    Seg::update(1, 1, e, l, r, -1);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, total;\nnamespace LCT {\nint sta[200009];\nstruct data {\n  int ch[2], rev, f;\n} s[200009];\nint get(int x) { return s[s[x].f].ch[1] == x; }\nint isrt(int x) { return !(s[s[x].f].ch[0] == x || s[s[x].f].ch[1] == x); }\nvoid rotate(int x) {\n  int old = s[x].f, fold = s[old].f, which = get(x);\n  if (!isrt(old)) s[fold].ch[s[fold].ch[1] == old] = x;\n  s[old].ch[which] = s[x].ch[which ^ 1], s[s[old].ch[which]].f = old;\n  s[x].ch[which ^ 1] = old, s[old].f = x, s[x].f = fold;\n}\nvoid mark(int x) { swap(s[x].ch[0], s[x].ch[1]), s[x].rev ^= 1; }\nvoid pushdown(int x) {\n  if (s[x].rev) {\n    if (s[x].ch[0]) mark(s[x].ch[0]);\n    if (s[x].ch[1]) mark(s[x].ch[1]);\n    s[x].rev = 0;\n  }\n}\nvoid splay(int x) {\n  int u = x, v = 0, fa;\n  for (sta[++v] = u; !isrt(u); u = s[u].f) sta[++v] = s[u].f;\n  for (; v; --v) pushdown(sta[v]);\n  for (u = s[u].f; (fa = s[x].f) != u; rotate(x))\n    if (s[fa].f != u) rotate(get(fa) == get(x) ? fa : x);\n}\nvoid Access(int x) {\n  for (int y = 0; x; y = x, x = s[x].f) {\n    splay(x);\n    s[x].ch[1] = y;\n  }\n}\nvoid makert(int x) { Access(x), splay(x), mark(x); }\nint findrt(int x) {\n  Access(x), splay(x);\n  while (s[x].ch[0]) pushdown(x), x = s[x].ch[0];\n  return x;\n}\nvoid link(int x, int y) { makert(x), makert(y), s[y].f = x; }\nvoid cut(int x, int y) {\n  makert(x), Access(y), splay(y);\n  s[y].ch[0] = s[x].f = 0;\n}\n};  // namespace LCT\nnamespace seg {\nstruct node {\n  int mn, num_mn, sum;\n  node() { mn = num_mn = sum = 0; }\n  node operator+(const node &b) const {\n    node c;\n    c.sum = sum + b.sum;\n    c.mn = min(b.sum + mn, b.mn);\n    if (b.sum + mn == c.mn) c.num_mn += num_mn;\n    if (b.mn == c.mn) c.num_mn += b.num_mn;\n    return c;\n  }\n} s[200009 << 2];\nvoid build(int l, int r, int now) {\n  s[now].mn = 1000000;\n  if (l == r) {\n    s[now].mn = s[now].num_mn = s[now].sum = 1;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  build(l, mid, now << 1), build(mid + 1, r, now << 1 | 1);\n  s[now] = s[now << 1] + s[now << 1 | 1];\n}\nvoid update(int l, int r, int now, int p, int v) {\n  if (l == r) {\n    s[now].sum += v;\n    s[now].mn += v;\n    s[now].num_mn = 1;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  if (p <= mid)\n    update(l, mid, now << 1, p, v);\n  else\n    update(mid + 1, r, now << 1 | 1, p, v);\n  s[now] = s[now << 1] + s[now << 1 | 1];\n}\nnode query(int l, int r, int now, int L, int R) {\n  if (l >= L && r <= R) return s[now];\n  int mid = (l + r) >> 1;\n  if (L <= mid && R > mid)\n    return query(l, mid, now << 1, L, R) +\n           query(mid + 1, r, now << 1 | 1, L, R);\n  else if (L <= mid)\n    return query(l, mid, now << 1, L, R);\n  else\n    return query(mid + 1, r, now << 1 | 1, L, R);\n}\n};  // namespace seg\nint l, r;\nstruct Pos {\n  int x, y;\n  Pos(int x = 0, int y = 0) : x(x), y(y) {}\n} pos[2006 * 2006];\nint G[2006][2006];\nint go(int x, int y) {\n  if (y >= l && y <= r) {\n    if (LCT::findrt(x) == LCT::findrt(y))\n      return 1;\n    else {\n      LCT::link(x, y);\n      return 0;\n    }\n  } else\n    return 0;\n}\nvoid recover(int x, int y) {\n  if (y >= l && y <= r) {\n    if (LCT::findrt(x) == LCT::findrt(y)) LCT::cut(x, y);\n  }\n}\nint check(int x) {\n  int flag = 1;\n  int xx = pos[x].x, yy = pos[x].y;\n  if (xx - 1 >= 1 && go(x, G[xx - 1][yy])) flag = 0;\n  if (xx + 1 <= n && go(x, G[xx + 1][yy])) flag = 0;\n  if (yy - 1 >= 1 && go(x, G[xx][yy - 1])) flag = 0;\n  if (yy + 1 <= m && go(x, G[xx][yy + 1])) flag = 0;\n  recover(x, G[xx - 1][yy]);\n  recover(x, G[xx + 1][yy]);\n  recover(x, G[xx][yy - 1]);\n  recover(x, G[xx][yy + 1]);\n  return flag;\n}\nvoid update(int x, int y) {\n  if (y >= l && y <= r) {\n    LCT::cut(x, y);\n    seg::update(1, total, 1, x, 1);\n  }\n}\nvoid Del(int x) {\n  int xx = pos[x].x, yy = pos[x].y;\n  update(x, G[xx - 1][yy]);\n  update(x, G[xx + 1][yy]);\n  update(x, G[xx][yy - 1]);\n  update(x, G[xx][yy + 1]);\n}\nvoid rese(int x, int y) {\n  if (y >= l && y <= r) {\n    LCT::link(x, y);\n    seg::update(1, total, 1, y, -1);\n  }\n}\nvoid Add(int x) {\n  int xx = pos[x].x, yy = pos[x].y;\n  rese(x, G[xx - 1][yy]);\n  rese(x, G[xx + 1][yy]);\n  rese(x, G[xx][yy - 1]);\n  rese(x, G[xx][yy + 1]);\n}\nint main() {\n  int i, j;\n  long long ans = 0;\n  scanf(\"%d%d\", &n, &m), total = n * m;\n  seg::build(1, total, 1);\n  for (i = 1; i <= n; ++i)\n    for (j = 1; j <= m; ++j) scanf(\"%d\", &G[i][j]), pos[G[i][j]] = Pos(i, j);\n  for (l = r = 1; r <= total; ++r) {\n    while (!check(r)) {\n      Del(l), ++l;\n    }\n    Add(r);\n    seg::node p = seg::query(1, total, 1, l, r);\n    if (p.mn == 1) ans += (long long)p.num_mn;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int M = 200005;\nconst int N = 2005;\nconst int INF = 1e9;\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nusing namespace std;\ninline int read() {\n  char c = getchar();\n  int x = 0, w = 1;\n  while (c > '9' || c < '0') {\n    if (c == '-') w = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    x = x * 10 + c - '0';\n    c = getchar();\n  }\n  return x * w;\n}\nint n, m, e, val[N][N];\nlong long ans;\nvector<int> eb[M], ec[M];\nstruct Node {\n  int tmin, cnt;\n};\ninline Node chkmin(Node A, Node B) {\n  Node c;\n  c.cnt = 0;\n  c.tmin = min(A.tmin, B.tmin);\n  if (c.tmin == A.tmin) c.cnt += A.cnt;\n  if (c.tmin == B.tmin) c.cnt += B.cnt;\n  return c;\n}\nstruct Link_Cut_Tree {\n  int root, tot;\n  int fa[M], son[M][2], rev[M], st[M];\n  inline bool Nrt(int now) {\n    return (son[fa[now]][0] == now || son[fa[now]][1] == now);\n  }\n  inline void Flip(int now) {\n    swap((son[now][0]), (son[now][1]));\n    rev[now] ^= 1;\n  }\n  inline void pushdown(int now) {\n    if (!rev[now]) return;\n    if ((son[now][0])) Flip((son[now][0]));\n    if ((son[now][1])) Flip((son[now][1]));\n    rev[now] = 0;\n  }\n  inline void rotate(int now) {\n    int father = fa[now], fafa = fa[father], k = (son[father][1] == now),\n        w = son[now][k ^ 1];\n    if (Nrt(father)) son[fafa][son[fafa][1] == father] = now;\n    son[now][k ^ 1] = father;\n    son[father][k] = w;\n    if (w) fa[w] = father;\n    fa[father] = now;\n    fa[now] = fafa;\n  }\n  inline void splay(int now) {\n    int top = 0, father = now, fafa;\n    st[++top] = father;\n    while (Nrt(father)) father = fa[father], st[++top] = father;\n    while (top) pushdown(st[top--]);\n    while (Nrt(now)) {\n      father = fa[now], fafa = fa[father];\n      if (Nrt(father))\n        rotate(((son[father][0] == now) ^ (son[fafa][0] == father)) ? now\n                                                                    : father);\n      rotate(now);\n    }\n  }\n  inline void access(int now) {\n    for (int ch = 0; now; ch = now, now = fa[now])\n      splay(now), (son[now][1]) = ch;\n  }\n  inline void makeroot(int now) {\n    access(now);\n    splay(now);\n    Flip(now);\n  }\n  inline int findroot(int now) {\n    access(now);\n    splay(now);\n    while ((son[now][0])) pushdown(now), now = (son[now][0]);\n    return now;\n  }\n  inline void Split(int x, int y) {\n    makeroot(x);\n    access(y);\n    splay(y);\n  }\n  inline void Link(int x, int y) {\n    makeroot(x);\n    if (findroot(y) != x) fa[x] = y;\n  }\n  inline void Cut(int x, int y) {\n    makeroot(x);\n    if (findroot(y) == x && !son[x][1] && fa[x] == y) fa[x] = son[y][0] = 0;\n  }\n} lct;\nstruct Segment_Tree {\n  int tmin[M << 2], cnt[M << 2], Tag[M << 2];\n  inline void pushup(int now) {\n    cnt[now] = 0;\n    tmin[now] = min(tmin[(now << 1)], tmin[(now << 1 | 1)]);\n    if (tmin[(now << 1)] == tmin[now]) cnt[now] += cnt[(now << 1)];\n    if (tmin[(now << 1 | 1)] == tmin[now]) cnt[now] += cnt[(now << 1 | 1)];\n  }\n  void build(int l, int r, int now) {\n    tmin[now] = 0;\n    cnt[now] = r - l + 1;\n    if (l == r) return;\n    int mid = (l + r) >> 1;\n    build(l, mid, (now << 1));\n    build(mid + 1, r, (now << 1 | 1));\n  }\n  inline void pushdown(int now) {\n    if (!Tag[now]) return;\n    Tag[(now << 1)] += Tag[now];\n    Tag[(now << 1 | 1)] += Tag[now];\n    tmin[(now << 1)] += Tag[now];\n    tmin[(now << 1 | 1)] += Tag[now];\n    Tag[now] = 0;\n  }\n  void Change(int L, int R, int k, int l, int r, int now) {\n    if (l >= L && r <= R) {\n      tmin[now] += k;\n      Tag[now] += k;\n      return;\n    }\n    pushdown(now);\n    int mid = (l + r) >> 1;\n    if (mid >= R)\n      Change(L, R, k, l, mid, (now << 1));\n    else if (mid < L)\n      Change(L, R, k, mid + 1, r, (now << 1 | 1));\n    else\n      Change(L, mid, k, l, mid, (now << 1)),\n          Change(mid + 1, R, k, mid + 1, r, (now << 1 | 1));\n    pushup(now);\n  }\n  Node query(int L, int R, int l, int r, int now) {\n    if (l > R || r < L) return ((Node){INF, 0});\n    if (l >= L && r <= R) return ((Node){tmin[now], cnt[now]});\n    pushdown(now);\n    int mid = (l + r) >> 1;\n    if (mid >= R)\n      return query(L, R, l, mid, (now << 1));\n    else if (mid < L)\n      return query(L, R, mid + 1, r, (now << 1 | 1));\n    else\n      return chkmin(query(L, mid, l, mid, (now << 1)),\n                    query(mid + 1, R, mid + 1, r, (now << 1 | 1)));\n  }\n} seg;\nint main() {\n  n = read();\n  m = read();\n  e = n * m;\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) val[i][j] = read();\n  for (int i = 1; i <= n; i++)\n    for (int j = 1, x, y; j <= m; j++)\n      for (int k = 0; k < 4; k++) {\n        x = i + dx[k], y = j + dy[k];\n        if (x < 1 || y < 1 || x > n || y > m) continue;\n        if (val[x][y] > val[i][j])\n          eb[val[i][j]].push_back(val[x][y]);\n        else\n          ec[val[i][j]].push_back(val[x][y]);\n      }\n  seg.build(1, e, 1);\n  int r = 0;\n  vector<int> vec;\n  for (int l = 1; l <= e; l++) {\n    bool iscir = false;\n    for (int ri = r + 1; ri <= e; ri++) {\n      vec.clear();\n      for (int i = 0, v; i < ec[ri].size(); i++) {\n        v = ec[ri][i];\n        if (v < l) continue;\n        if (lct.findroot(ri) == lct.findroot(v)) {\n          iscir = true;\n          break;\n        }\n        lct.Link(ri, v);\n        vec.push_back(v);\n      }\n      for (int i = 0; i < vec.size(); i++) lct.Cut(ri, vec[i]);\n      if (iscir) break;\n      ++r;\n      int tot = 0;\n      for (int i = 0, v; i < ec[ri].size(); i++) {\n        v = ec[ri][i];\n        if (v < l) continue;\n        lct.Link(ri, v);\n        ++tot;\n      }\n      seg.Change(ri, e, -tot, 1, e, 1);\n      seg.Change(ri, ri, r - l + 1, 1, e, 1);\n    }\n    Node temp = seg.query(l, r, 1, e, 1);\n    if (temp.tmin == 1) ans += temp.cnt;\n    for (int i = 0, v; i < eb[l].size(); i++) {\n      v = eb[l][i];\n      if (v > r) continue;\n      lct.Cut(l, v);\n      seg.Change(v, e, 1, 1, e, 1);\n    }\n    seg.Change(l, r, -1, 1, e, 1);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst vector<int> dx = {1, -1, 0, 0};\nconst vector<int> dy = {0, 0, 1, -1};\nclass node {\n public:\n  int id;\n  node* l;\n  node* r;\n  node* p;\n  bool rev;\n  node(int id) : id(id) {\n    l = r = p = NULL;\n    rev = false;\n  }\n  void apply() { rev ^= 1; }\n  void push() {\n    if (rev) {\n      swap(l, r);\n      if (l != NULL) {\n        l->apply();\n      }\n      if (r != NULL) {\n        r->apply();\n      }\n      rev = false;\n    }\n  }\n  void pull() {\n    if (l != NULL) {\n      l->p = this;\n    }\n    if (r != NULL) {\n      r->p = this;\n    }\n  }\n};\nbool is_bst_root(node* v) {\n  return (v->p == NULL || (v->p->l != v && v->p->r != v));\n}\nvoid rotate(node* v) {\n  node* u = v->p;\n  v->p = u->p;\n  if (v->p != NULL) {\n    if (v->p->l == u) {\n      v->p->l = v;\n    }\n    if (v->p->r == u) {\n      v->p->r = v;\n    }\n  }\n  if (v == u->l) {\n    u->l = v->r;\n    v->r = u;\n  } else {\n    u->r = v->l;\n    v->l = u;\n  }\n  u->pull();\n  v->pull();\n}\nvoid splay(node* v) {\n  stack<node*> st;\n  st.push(v);\n  for (node* u = v; !is_bst_root(u); u = u->p) {\n    st.push(u->p);\n  }\n  while (!st.empty()) {\n    st.top()->push();\n    st.pop();\n  }\n  while (!is_bst_root(v)) {\n    node* u = v->p;\n    if (!is_bst_root(u)) {\n      if ((u->l == v) ^ (u->p->l == u)) {\n        rotate(v);\n      } else {\n        rotate(u);\n      }\n    }\n    rotate(v);\n  }\n}\nvoid access(node* v) {\n  node* u = NULL;\n  while (v != NULL) {\n    splay(v);\n    v->r = u;\n    u = v;\n    v = v->p;\n  }\n}\nvoid make_root(node* v) {\n  access(v);\n  splay(v);\n  v->apply();\n}\nint find_root(node* v) {\n  access(v);\n  splay(v);\n  while (v->push(), v->l != NULL) {\n    v = v->l;\n  }\n  splay(v);\n  return v->id;\n}\nbool link(node* v, node* u) {\n  if (find_root(v) == find_root(u)) {\n    return false;\n  } else {\n    make_root(v);\n    v->p = u;\n    return true;\n  }\n}\nvoid cut(node* v, node* u) {\n  make_root(v);\n  access(u);\n  splay(u);\n  u->l = v->p = NULL;\n}\nclass segtree {\n public:\n  class node {\n   public:\n    int value = 0;\n    int cnt = 0;\n    int tag = 0;\n    void apply(int l, int r, int v) {\n      value += v;\n      tag += v;\n    }\n  };\n  vector<node> tree;\n  int n;\n  inline node unite(const node& l, const node& r) {\n    node res;\n    res.value = min(l.value, r.value);\n    if (res.value == l.value) {\n      res.cnt += l.cnt;\n    }\n    if (res.value == r.value) {\n      res.cnt += r.cnt;\n    }\n    return res;\n  }\n  segtree(int n) : n(n) { tree.resize(n * 2 - 1); }\n  inline void pull(int x, int z) { tree[x] = unite(tree[x + 1], tree[z]); }\n  inline void push(int x, int l, int r) {\n    int y = l + r >> 1, z = x + (y - l + 1 << 1);\n    if (tree[x].tag) {\n      tree[x + 1].apply(l, y, tree[x].tag);\n      tree[z].apply(y + 1, r, tree[x].tag);\n      tree[x].tag = 0;\n    }\n  }\n  void build(int x, int l, int r) {\n    if (l == r) {\n      tree[x].value = l;\n      tree[x].cnt = 1;\n    } else {\n      int y = l + r >> 1, z = x + (y - l + 1 << 1);\n      build(x + 1, l, y);\n      build(z, y + 1, r);\n      pull(x, z);\n    }\n  }\n  template <typename... T>\n  void modify(int x, int l, int r, int ll, int rr, const T&... v) {\n    if (ll <= l && r <= rr) {\n      tree[x].apply(l, r, v...);\n    } else {\n      int y = l + r >> 1, z = x + (y - l + 1 << 1);\n      push(x, l, r);\n      if (ll <= y) {\n        modify(x + 1, l, y, ll, rr, v...);\n      }\n      if (rr > y) {\n        modify(z, y + 1, r, ll, rr, v...);\n      }\n      pull(x, z);\n    }\n  }\n  node query(int x, int l, int r, int ll, int rr) {\n    if (ll <= l && r <= rr) {\n      return tree[x];\n    } else {\n      int y = l + r >> 1, z = x + (y - l + 1 << 1);\n      push(x, l, r);\n      if (rr <= y) {\n        return query(x + 1, l, y, ll, rr);\n      } else if (ll > y) {\n        return query(z, y + 1, r, ll, rr);\n      } else {\n        return unite(query(x + 1, l, y, ll, rr), query(z, y + 1, r, ll, rr));\n      }\n    }\n  }\n  void build() { build(0, 0, n - 1); }\n  template <typename... T>\n  void modify(int l, int r, const T&... v) {\n    modify(0, 0, n - 1, l, r, v...);\n  }\n  node query(int l, int r) { return query(0, 0, n - 1, l, r); }\n};\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<vector<int>> board(n, vector<int>(m));\n  vector<pair<int, int>> pos(n * m);\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      cin >> board[i][j];\n      --board[i][j];\n      pos[board[i][j]] = make_pair(i, j);\n    }\n  }\n  vector<node*> tree(n * m);\n  for (int i = 0; i < n * m; ++i) {\n    tree[i] = new node(i);\n  }\n  vector<int> right(n * m);\n  for (int i = 0, j = 0; i < n * m; ++i) {\n    while (j < n * m) {\n      int x = pos[j].first, y = pos[j].second;\n      vector<int> sons;\n      vector<int> roots;\n      for (int k = 0; k < 4; ++k) {\n        int xx = x + dx[k], yy = y + dy[k];\n        if (xx >= 0 && xx < n && yy >= 0 && yy < m && board[xx][yy] < j &&\n            board[xx][yy] >= i) {\n          sons.push_back(board[xx][yy]);\n          roots.push_back(find_root(tree[board[xx][yy]]));\n        }\n      }\n      bool can = true;\n      for (int k = 0; k < (int)roots.size(); ++k) {\n        for (int l = 0; l < k; ++l) {\n          if (roots[k] == roots[l]) {\n            can = false;\n            break;\n          }\n        }\n        if (!can) {\n          break;\n        }\n      }\n      if (can) {\n        for (auto k : sons) {\n          link(tree[j], tree[k]);\n        }\n        ++j;\n      } else {\n        break;\n      }\n    }\n    right[i] = j - 1;\n    int x = pos[i].first, y = pos[i].second;\n    for (int k = 0; k < 4; ++k) {\n      int xx = x + dx[k], yy = y + dy[k];\n      if (xx >= 0 && xx < n && yy >= 0 && yy < m && board[xx][yy] < j &&\n          board[xx][yy] >= i) {\n        cut(tree[i], tree[board[xx][yy]]);\n      }\n    }\n  }\n  segtree seg(n * m);\n  seg.build();\n  long long ans = 0;\n  for (int i = n * m - 1; ~i; --i) {\n    int x = pos[i].first, y = pos[i].second;\n    for (int j = 0; j < 4; ++j) {\n      int xx = x + dx[j], yy = y + dy[j];\n      if (xx >= 0 && xx < n && yy >= 0 && yy < m && board[xx][yy] >= i) {\n        seg.modify(board[xx][yy], n * m - 1, -1);\n      }\n    }\n    segtree::node res = seg.query(i, right[i]);\n    if (res.value == i) {\n      ans += res.cnt;\n    }\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector,fast-math\")\nusing namespace std;\nnamespace io {\nconst int L = (1 << 20) + 1;\nchar buf[L], *S, *T, c;\nchar getchar() {\n  if (__builtin_expect(S == T, 0)) {\n    T = (S = buf) + fread(buf, 1, L, stdin);\n    return (S == T ? EOF : *S++);\n  }\n  return *S++;\n}\nint inp() {\n  int x = 0, f = 1;\n  char ch;\n  for (ch = getchar(); !isdigit(ch); ch = getchar())\n    if (ch == '-') f = -1;\n  for (; isdigit(ch); x = x * 10 + ch - '0', ch = getchar())\n    ;\n  return x * f;\n}\nunsigned inpu() {\n  unsigned x = 0;\n  char ch;\n  for (ch = getchar(); !isdigit(ch); ch = getchar())\n    ;\n  for (; isdigit(ch); x = x * 10 + ch - '0', ch = getchar())\n    ;\n  return x;\n}\nlong long inp_ll() {\n  long long x = 0;\n  int f = 1;\n  char ch;\n  for (ch = getchar(); !isdigit(ch); ch = getchar())\n    if (ch == '-') f = -1;\n  for (; isdigit(ch); x = x * 10 + ch - '0', ch = getchar())\n    ;\n  return x * f;\n}\nchar B[25], *outs = B + 20, *outr = B + 20;\ntemplate <class T>\ninline void print(register T a, register char x = 0) {\n  if (x) *--outs = x, x = 0;\n  if (!a)\n    *--outs = '0';\n  else\n    while (a) *--outs = (a % 10) + 48, a /= 10;\n  if (x) *--outs = x;\n  fwrite(outs, outr - outs, 1, stdout);\n  outs = outr;\n}\n};  // namespace io\nusing io ::inp;\nusing io ::inp_ll;\nusing io ::inpu;\nusing io ::print;\nusing i32 = int;\nusing i64 = long long;\nusing u8 = unsigned char;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing f64 = double;\nusing f80 = long double;\nlong long power(long long a, long long b, long long p) {\n  if (!b) return 1;\n  long long t = power(a, b / 2, p);\n  t = t * t % p;\n  if (b & 1) t = t * a % p;\n  return t;\n}\nlong long exgcd(long long a, long long b, long long &x, long long &y) {\n  if (b == 0) {\n    x = 1;\n    y = 0;\n    return a;\n  }\n  long long px, py;\n  long long d = exgcd(b, a % b, px, py);\n  x = py;\n  y = px - a / b * py;\n  return d;\n}\ntemplate <class T>\ninline void freshmin(T &a, const T &b) {\n  if (a > b) a = b;\n}\ntemplate <class T>\ninline void freshmax(T &a, const T &b) {\n  if (a < b) a = b;\n}\nconst int MAXN = 200010;\nconst int MOD = 1000000009;\nconst f80 MI = f80(1) / MOD;\nconst int INF = 1000000000;\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\nstruct node {\n  node *pre, *son[2];\n  int rev;\n} nodes[MAXN];\nnode *nil = nodes;\nstruct LinkCutTree {\n  void init(int n) {\n    nil->pre = nil->son[0] = nil->son[1] = nil;\n    nil->rev = 0;\n    for (int i = 1; i <= n; ++i) {\n      nodes[i].pre = nodes[i].son[0] = nodes[i].son[1] = nil;\n      nodes[i].rev = 0;\n    }\n  }\n  bool is_root(node *x) { return x->pre->son[0] != x && x->pre->son[1] != x; }\n  void reverse(node *x) { x->rev ^= 1; }\n  void clear(node *x) {\n    if (x->rev) {\n      reverse(x->son[0]);\n      reverse(x->son[1]);\n      swap(x->son[0], x->son[1]);\n      x->rev = 0;\n    }\n  }\n  void update(node *x) {}\n  void rotate(node *x) {\n    node *y = x->pre, *z = y->pre;\n    int p = y->son[1] == x, q = p ^ 1;\n    if (!is_root(y)) z->son[z->son[1] == y] = x;\n    x->pre = z;\n    y->pre = x;\n    if (x->son[q]) x->son[q]->pre = y;\n    y->son[p] = x->son[q];\n    x->son[q] = y;\n    update(y);\n    update(x);\n  }\n  void splay(node *x) {\n    list<node *> Q;\n    node *it = x;\n    for (; !is_root(it); it = it->pre) Q.push_back(it);\n    Q.push_back(it);\n    while (!Q.empty()) {\n      node *it = Q.back();\n      Q.pop_back();\n      clear(it);\n    }\n    while (!is_root(x)) {\n      node *y = x->pre, *z = y->pre;\n      if (!is_root(y)) rotate((y->son[0] == x) ^ (z->son[0] == y) ? x : y);\n      rotate(x);\n    }\n  }\n  void access(node *x0) {\n    for (node *x = x0, *y = nil; x != nil; x = x->pre) {\n      splay(x);\n      x->son[1] = y;\n      y = x;\n    }\n    splay(x0);\n  }\n  node *belong(node *x) {\n    access(x);\n    for (; x->son[0] != nil; x = x->son[0])\n      ;\n    return x;\n  }\n  bool check(node *x, node *y) {\n    node *fx = belong(x);\n    node *fy = belong(y);\n    return fx == fy;\n  }\n  void link(node *x, node *y) {\n    access(x);\n    reverse(x);\n    x->pre = y;\n  }\n  void cut(node *x, node *y) {\n    access(y);\n    splay(x);\n    if (x->pre == y)\n      x->pre = nil;\n    else {\n      access(x);\n      splay(y);\n      if (y->pre == x) y->pre = nil;\n    }\n  }\n  bool check(int x, int y) { return check(nodes + x, nodes + y); }\n  void link(int x, int y) { link(nodes + x, nodes + y); }\n  bool try_link(int x, int y) {\n    if (check(x, y)) return 1;\n    link(x, y);\n    return 0;\n  }\n  void cut(int x, int y) { cut(nodes + x, nodes + y); }\n} T;\nint n, m;\nint a[MAXN];\nvector<int> v[MAXN];\nint place(int i, int j) { return (i - 1) * m + j; }\nstruct segtree {\n  int add, min, cnt;\n} tree[MAXN * 4];\nvoid clear(int k) {\n  if (tree[k].add) {\n    tree[k << 1].add += tree[k].add;\n    tree[k << 1].min += tree[k].add;\n    tree[k << 1 | 1].add += tree[k].add;\n    tree[k << 1 | 1].min += tree[k].add;\n    tree[k].add = 0;\n  }\n}\nvoid update(int k) {\n  tree[k].min = min(tree[k << 1].min, tree[k << 1 | 1].min);\n  tree[k].cnt = (tree[k << 1].min == tree[k].min) * tree[k << 1].cnt +\n                (tree[k << 1 | 1].min == tree[k].min) * tree[k << 1 | 1].cnt;\n}\nvoid build(int k, int L, int R) {\n  if (L == R) {\n    tree[k].add = 0;\n    tree[k].min = 0;\n    tree[k].cnt = 1;\n    return;\n  }\n  int m = (L + R) / 2;\n  build(k << 1, L, m);\n  build(k << 1 | 1, m + 1, R);\n  update(k);\n}\nvoid add(int k, int L, int R, int x, int y, int p) {\n  if (L == x && R == y) {\n    tree[k].add += p;\n    tree[k].min += p;\n    return;\n  }\n  clear(k);\n  int m = (L + R) / 2;\n  if (y <= m)\n    add(k << 1, L, m, x, y, p);\n  else if (x > m)\n    add(k << 1 | 1, m + 1, R, x, y, p);\n  else {\n    add(k << 1, L, m, x, m, p);\n    add(k << 1 | 1, m + 1, R, m + 1, y, p);\n  }\n  update(k);\n}\npair<int, int> query(int k, int L, int R, int x, int y) {\n  if (L == x && R == y) return pair<int, int>(tree[k].min, tree[k].cnt);\n  clear(k);\n  int m = (L + R) / 2;\n  if (y <= m) return query(k << 1, L, m, x, y);\n  if (x > m) return query(k << 1 | 1, m + 1, R, x, y);\n  auto lans = query(k << 1, L, m, x, m);\n  auto rans = query(k << 1 | 1, m + 1, R, m + 1, y);\n  return pair<int, int>(min(lans.first, rans.first),\n                        (lans.first <= rans.first) * lans.second +\n                            (lans.first >= rans.first) * rans.second);\n}\nint main() {\n  n = inp();\n  m = inp();\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j) a[place(i, j)] = inp();\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n      for (int d = 0; d < 4; ++d) {\n        int x = i + dx[d], y = j + dy[d];\n        if (1 <= x && x <= n && 1 <= y && y <= m)\n          v[a[place(i, j)]].push_back(a[place(x, y)]);\n      }\n  long long ans = 0;\n  T.init(n * m);\n  build(1, 1, n * m);\n  for (int i = 1, j = 1; i <= n * m; ++i) {\n    while (1) {\n      int flag = 0;\n      for (auto x : v[i])\n        if (j <= x && x < i) flag |= T.try_link(x, i);\n      if (!flag) break;\n      for (auto x : v[i])\n        if (j <= x && x < i) T.cut(x, i);\n      for (auto x : v[j]) T.cut(x, j);\n      j++;\n    }\n    add(1, 1, n * m, j, i, 1);\n    for (auto x : v[i])\n      if (j <= x && x < i) add(1, 1, n * m, j, x, -1);\n    auto ret = query(1, 1, n * m, j, i);\n    if (ret.first == 1) ans += ret.second;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxN = 1e3 + 5;\nconst int maxNode = 2e5 + 5;\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\nint N, M;\nint f[maxN][maxN];\nint posx[maxNode], posy[maxNode];\nint tr[maxNode];\nclass LCT {\n private:\n  int fa[maxNode];\n  int son[maxNode][2];\n  bool rev[maxNode];\n\n public:\n  void rotate(int x) {\n    int y = fa[x], z = fa[y], i = (son[y][1] == x), c = son[x][i ^ 1];\n    fa[x] = z;\n    if ((son[fa[y]][0] != (y) && son[fa[y]][1] != (y)) == 0)\n      son[z][son[z][1] == y] = x;\n    fa[y] = x;\n    son[x][i ^ 1] = y;\n    son[y][i] = c;\n    if (c) fa[c] = y;\n  }\n  inline void tagrev(int x) {\n    swap(son[x][0], son[x][1]);\n    rev[x] ^= 1;\n  }\n  inline void pushdown(int now) {\n    if (rev[now]) {\n      if (son[now][0]) tagrev(son[now][0]);\n      if (son[now][1]) tagrev(son[now][1]);\n      rev[now] = 0;\n    }\n  }\n  void splay(int x) {\n    static int anc[maxNode];\n    int tp = 0, u = x;\n    while ((son[fa[u]][0] != (u) && son[fa[u]][1] != (u)) == 0)\n      anc[++tp] = u, u = fa[u];\n    if (u) anc[++tp] = u;\n    while (tp) pushdown(anc[tp--]);\n    while ((son[fa[x]][0] != (x) && son[fa[x]][1] != (x)) == 0) rotate(x);\n  }\n  void access(int x) {\n    for (int v = 0; x; v = x, x = fa[x]) {\n      splay(x);\n      son[x][1] = v;\n    }\n  }\n  inline void makeroot(int x) {\n    access(x);\n    splay(x);\n    tagrev(x);\n  }\n  inline void link(int x, int y) {\n    makeroot(x);\n    splay(y);\n    fa[x] = y;\n  }\n  inline void cut(int x, int y) {\n    makeroot(x);\n    access(y);\n    splay(y);\n    fa[x] = son[y][0] = 0;\n  }\n  int findroot(int x) {\n    while ((son[fa[x]][0] != (x) && son[fa[x]][1] != (x)) == 0) {\n      x = fa[x];\n    }\n    while (son[x][0]) {\n      x = son[x][0];\n    }\n    return x;\n  }\n  inline bool iscon(int x, int y) {\n    makeroot(x), access(y);\n    return findroot(y) == x;\n  }\n} T;\nclass Segtree {\n private:\n  static const int maxNode = ::maxNode << 2;\n  class Node {\n   public:\n    int minval, mintot, lazy;\n    Node() {}\n    Node(int _minval, int _mintot, int _lazy)\n        : minval(_minval), mintot(_mintot), lazy(_lazy) {}\n    friend Node operator+(const Node& a, const Node& b) {\n      Node ret;\n      ret.minval = min(a.minval, b.minval);\n      ret.lazy = ret.mintot = 0;\n      if (ret.minval == a.minval) {\n        ret.mintot += a.mintot;\n      }\n      if (ret.minval == b.minval) {\n        ret.mintot += b.mintot;\n      }\n      return ret;\n    }\n  } nd[maxNode];\n  inline void pushdown(int now) {\n    if (nd[now].lazy) {\n      int& cur = nd[now].lazy;\n      nd[(now << 1)].lazy += cur, nd[(now << 1)].minval += cur;\n      nd[(now << 1 | 1)].lazy += cur, nd[(now << 1 | 1)].minval += cur;\n      cur = 0;\n    }\n  }\n\n public:\n  void build(int now, int l, int r) {\n    if (l == r) {\n      nd[now].mintot = 1;\n      return;\n    }\n    build((now << 1), l, ((l + r) >> 1)),\n        build((now << 1 | 1), ((l + r) >> 1) + 1, r);\n    nd[now] = nd[(now << 1)] + nd[(now << 1 | 1)];\n  }\n  void add(int now, int l, int r, int ql, int qr, int v) {\n    if (ql <= l && qr >= r) {\n      nd[now].lazy += v;\n      nd[now].minval += v;\n      return;\n    }\n    pushdown(now);\n    if (ql <= ((l + r) >> 1)) add((now << 1), l, ((l + r) >> 1), ql, qr, v);\n    if (qr > ((l + r) >> 1))\n      add((now << 1 | 1), ((l + r) >> 1) + 1, r, ql, qr, v);\n    nd[now] = nd[(now << 1)] + nd[(now << 1 | 1)];\n  }\n  Node getsum(int now, int l, int r, int ql, int qr) {\n    if (ql <= l && qr >= r) {\n      return nd[now];\n    }\n    pushdown(now);\n    Node ret = Node(0, 0, 0);\n    if (ql <= ((l + r) >> 1)) {\n      ret = getsum((now << 1), l, ((l + r) >> 1), ql, qr);\n      if (qr > ((l + r) >> 1))\n        ret = ret + getsum((now << 1 | 1), ((l + r) >> 1) + 1, r, ql, qr);\n    } else if (ql > ((l + r) >> 1)) {\n      ret = getsum((now << 1 | 1), ((l + r) >> 1) + 1, r, ql, qr);\n    }\n    return ret;\n  }\n  inline int getsum(int l, int r) { return getsum(1, 1, N * M, l, r).mintot; }\n} seg;\nint main() {\n  scanf(\"%d%d\", &N, &M);\n  for (int i = 1; i <= N; ++i) {\n    for (int j = 1; j <= M; ++j) {\n      scanf(\"%d\", &f[i][j]), posx[f[i][j]] = i, posy[f[i][j]] = j;\n    }\n  }\n  tr[1] = 1;\n  for (int r = 2, l = 1; r <= N * M; ++r) {\n    int x = posx[r], y = posy[r];\n    vector<int> around;\n    around.clear();\n    for (int d = 0; d < 4; ++d) {\n      int u = f[x + dx[d]][y + dy[d]];\n      if (u >= l && u <= r) around.push_back(u);\n    }\n    for (auto i : around) {\n      for (auto j : around)\n        if (i < j) {\n          while (T.iscon(i, j) && l <= r) {\n            for (int d = 0; d < 4; ++d) {\n              int u = f[posx[l] + dx[d]][posy[l] + dy[d]];\n              if (u >= l && u < r) {\n                T.cut(u, l);\n              }\n            }\n            l++;\n          }\n        }\n    }\n    tr[r] = l;\n    for (auto i : around) {\n      T.link(r, i);\n    }\n  }\n  seg.build(1, 1, N * M);\n  long long ans = 0;\n  for (int r = 1; r <= N * M; ++r) {\n    seg.add(1, 1, N * M, tr[r], r, 1);\n    for (int d = 0; d < 4; ++d) {\n      int u = f[posx[r] + dx[d]][posy[r] + dy[d]];\n      if (u >= tr[r] && u <= r) {\n        seg.add(1, 1, N * M, tr[r], u, -1);\n      }\n    }\n    ans += seg.getsum(tr[r], r);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint gi() {\n  int x = 0, w = 1;\n  char ch = getchar();\n  while ((ch < '0' || ch > '9') && ch != '-') ch = getchar();\n  if (ch == '-') w = 0, ch = getchar();\n  while (ch >= '0' && ch <= '9')\n    x = (x << 3) + (x << 1) + ch - '0', ch = getchar();\n  return w ? x : -x;\n}\nconst int N = 2e5 + 5;\nint n, m, tot, f[1005][1005], px[N], py[N], fa[N], ch[2][N], rev[N];\nint L = 1, R = 1, dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1}, tmp[10],\n    tag[N << 2];\npair<int, int> sum[N << 2];\nlong long ans = 1;\nbool son(int x) { return x == ch[1][fa[x]]; }\nbool isroot(int x) { return x != ch[0][fa[x]] && x != ch[1][fa[x]]; }\nvoid rotate(int x) {\n  int y = fa[x], z = fa[y], c = son(x);\n  ch[c][y] = ch[c ^ 1][x];\n  if (ch[c][y]) fa[ch[c][y]] = y;\n  fa[x] = z;\n  if (!isroot(y)) ch[son(y)][z] = x;\n  ch[c ^ 1][x] = y;\n  fa[y] = x;\n}\nvoid rever(int x) {\n  swap(ch[0][x], ch[1][x]);\n  rev[x] ^= 1;\n}\nvoid alldown(int x) {\n  if (!isroot(x)) alldown(fa[x]);\n  if (rev[x]) rever(ch[0][x]), rever(ch[1][x]), rev[x] = 0;\n}\nvoid splay(int x) {\n  alldown(x);\n  for (int y = fa[x]; !isroot(x); rotate(x), y = fa[x])\n    if (!isroot(y)) son(x) ^ son(y) ? rotate(x) : rotate(y);\n}\nvoid access(int x) {\n  for (int y = 0; x; y = x, x = fa[x]) splay(x), ch[1][x] = y;\n}\nvoid makeroot(int x) {\n  access(x);\n  splay(x);\n  rever(x);\n}\nint findroot(int x) {\n  access(x);\n  splay(x);\n  while (ch[0][x]) x = ch[0][x];\n  splay(x);\n  return x;\n}\nvoid split(int x, int y) {\n  makeroot(x);\n  access(y);\n  splay(y);\n}\nvoid link(int x, int y) {\n  makeroot(x);\n  fa[x] = y;\n}\nvoid cut(int x, int y) {\n  split(x, y);\n  fa[x] = ch[0][y] = 0;\n}\nbool check() {\n  int len = 0;\n  for (int d = 0; d < 4; ++d) {\n    int x = px[R + 1] + dx[d], y = py[R + 1] + dy[d];\n    if (!x || x == n + 1 || !y || y == m + 1 || f[x][y] < L || f[x][y] > R)\n      continue;\n    tmp[++len] = findroot(f[x][y]);\n  }\n  sort(tmp + 1, tmp + len + 1);\n  for (int i = 1; i < len; ++i)\n    if (tmp[i] == tmp[i + 1]) return false;\n  return true;\n}\npair<int, int> operator+(pair<int, int> a, pair<int, int> b) {\n  pair<int, int> c;\n  c.first = min(a.first, b.first);\n  if (c.first == a.first) c.second += a.second;\n  if (c.first == b.first) c.second += b.second;\n  return c;\n}\nvoid build(int x, int l, int r) {\n  if (l == r) {\n    sum[x] = make_pair(0, 1);\n    return;\n  }\n  int mid = l + r >> 1;\n  build(x << 1, l, mid);\n  build(x << 1 | 1, mid + 1, r);\n  sum[x] = sum[x << 1] + sum[x << 1 | 1];\n}\nvoid cover(int x, int v) {\n  sum[x].first += v;\n  tag[x] += v;\n}\nvoid down(int x) {\n  if (!tag[x]) return;\n  cover(x << 1, tag[x]);\n  cover(x << 1 | 1, tag[x]);\n  tag[x] = 0;\n}\nvoid modify(int x, int l, int r, int ql, int qr, int v) {\n  if (l >= ql && r <= qr) {\n    cover(x, v);\n    return;\n  }\n  down(x);\n  int mid = l + r >> 1;\n  if (ql <= mid) modify(x << 1, l, mid, ql, qr, v);\n  if (qr > mid) modify(x << 1 | 1, mid + 1, r, ql, qr, v);\n  sum[x] = sum[x << 1] + sum[x << 1 | 1];\n}\npair<int, int> query(int x, int l, int r, int ql, int qr) {\n  if (l >= ql && r <= qr) return sum[x];\n  down(x);\n  int mid = l + r >> 1;\n  pair<int, int> res = make_pair(1 << 30, 0);\n  if (ql <= mid) res = res + query(x << 1, l, mid, ql, qr);\n  if (qr > mid) res = res + query(x << 1 | 1, mid + 1, r, ql, qr);\n  return res;\n}\nint main() {\n  n = gi();\n  m = gi();\n  tot = n * m;\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n      f[i][j] = gi(), px[f[i][j]] = i, py[f[i][j]] = j;\n  build(1, 1, tot);\n  modify(1, 1, tot, 1, 1, 1);\n  while (R < tot) {\n    while (L < R && !check()) {\n      for (int d = 0; d < 4; ++d) {\n        int x = px[L] + dx[d], y = py[L] + dy[d];\n        if (!x || x == n + 1 || !y || y == m + 1 || f[x][y] < L || f[x][y] > R)\n          continue;\n        cut(L, f[x][y]);\n      }\n      ++L;\n    }\n    ++R;\n    modify(1, 1, tot, L, R, 1);\n    for (int d = 0; d < 4; ++d) {\n      int x = px[R] + dx[d], y = py[R] + dy[d];\n      if (!x || x == n + 1 || !y || y == m + 1 || f[x][y] < L || f[x][y] > R)\n        continue;\n      link(R, f[x][y]);\n      modify(1, 1, tot, L, f[x][y], -1);\n    }\n    pair<int, int> res = query(1, 1, tot, L, R);\n    ans += res.first == 1 ? res.second : 0;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200000 + 7, L = 2000 + 7,\n          Fx[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\nint n, m, t, A[L][L];\nvector<int> E[N], tem;\nstruct LCT {\n  int Sign[N], Fa[N], Son[N][2];\n  inline bool Where(int x) { return Son[Fa[x]][1] == x; }\n  inline bool noroot(int x) { return Son[Fa[x]][0] == x || Son[Fa[x]][1] == x; }\n  inline void MakeSign(int x) {\n    if (x) swap(Son[x][0], Son[x][1]), Sign[x] ^= 1;\n  }\n  inline void Pushdown(int x) {\n    if (Sign[x]) MakeSign(Son[x][0]), MakeSign(Son[x][1]), Sign[x] ^= 1;\n  }\n  void PPushdown(int x) {\n    if (noroot(x)) PPushdown(Fa[x]);\n    Pushdown(x);\n  }\n  inline void Rotate(int x) {\n    int y = Fa[x], z = Fa[y], ySon = Where(x), zSon = Where(y),\n        B = Son[x][ySon ^ 1];\n    if (noroot(y)) Son[z][zSon] = x;\n    Fa[x] = z;\n    if (B) Fa[B] = y;\n    Son[y][ySon] = B;\n    Fa[y] = x, Son[x][ySon ^ 1] = y;\n  }\n  inline void Splay(int x) {\n    PPushdown(x);\n    while (noroot(x)) {\n      int fa = Fa[x];\n      if (noroot(fa))\n        if (Where(fa) ^ Where(x))\n          Rotate(x);\n        else\n          Rotate(fa);\n      Rotate(x);\n    }\n  }\n  inline void Access(int x) {\n    for (int y = 0; x; y = x, x = Fa[x]) Splay(x), Son[x][1] = y;\n  }\n  inline void MakeRoot(int x) { Access(x), Splay(x), MakeSign(x); }\n  inline int FindRoot(int x) {\n    Access(x), Splay(x);\n    while (Son[x][0]) Pushdown(x), x = Son[x][0];\n    return x;\n  }\n  inline bool Link(int x, int y) {\n    MakeRoot(x);\n    if (FindRoot(y) == x) return 0;\n    return Fa[x] = y, 1;\n  }\n  inline void Cut(int x, int y) {\n    MakeRoot(x);\n    if (FindRoot(y) == x && x == Son[y][0] && !Son[x][1]) Fa[x] = Son[y][0] = 0;\n  }\n} lct;\nint Sign[N << 2];\nstruct NFO {\n  int Min, tot;\n  friend NFO operator+(NFO A, NFO B) {\n    NFO C;\n    C.tot = 0, C.Min = min(A.Min, B.Min);\n    if (C.Min == A.Min) C.tot += A.tot;\n    if (C.Min == B.Min) C.tot += B.tot;\n    return C;\n  }\n} T[N << 2];\nvoid Build(int u, int l, int r) {\n  T[u].Min = 0, T[u].tot = r - l + 1;\n  if (l == r) return;\n  int Mid = (l + r) >> 1;\n  Build((u << 1), l, Mid), Build((u << 1 | 1), Mid + 1, r);\n}\ninline void Pushdown(int u) {\n  if (Sign[u]) {\n    Sign[(u << 1)] += Sign[u], T[(u << 1)].Min += Sign[u];\n    Sign[(u << 1 | 1)] += Sign[u], T[(u << 1 | 1)].Min += Sign[u];\n    Sign[u] = 0;\n  }\n}\nvoid Update(int u, int l, int r, int L, int R, int w) {\n  if (L <= l && R >= r) {\n    Sign[u] += w, T[u].Min += w;\n    return;\n  }\n  Pushdown(u);\n  int Mid = (l + r) >> 1;\n  if (Mid >= L) Update((u << 1), l, Mid, L, R, w);\n  if (Mid < R) Update((u << 1 | 1), Mid + 1, r, L, R, w);\n  T[u] = T[(u << 1)] + T[(u << 1 | 1)];\n}\nNFO Query(int u, int l, int r, int L, int R) {\n  if (L <= l && R >= r) return T[u];\n  Pushdown(u);\n  int Mid = (l + r) >> 1;\n  if (Mid >= R)\n    return Query((u << 1), l, Mid, L, R);\n  else if (Mid < L)\n    return Query((u << 1 | 1), Mid + 1, r, L, R);\n  return Query((u << 1), l, Mid, L, R) + Query((u << 1 | 1), Mid + 1, r, L, R);\n}\nint main() {\n  scanf(\"%d%d\", &n, &m), t = n * m;\n  for (int i = (1), iLimit = (n); i <= iLimit; (++(i)))\n    for (int j = (1), jLimit = (m); j <= jLimit; (++(j))) scanf(\"%d\", A[i] + j);\n  for (int i = (1), iLimit = (n); i <= iLimit; (++(i)))\n    for (int j = (1), jLimit = (m); j <= jLimit; (++(j)))\n      for (int k = (0), kLimit = (3); k <= kLimit; (++(k))) {\n        int nx = i + Fx[k][0], ny = j + Fx[k][1];\n        if (nx < 1 || ny < 1 || nx > n || ny > m) continue;\n        E[A[i][j]].push_back(A[nx][ny]);\n      }\n  int r = 0, tot;\n  bool flag;\n  long long Ans = 0;\n  Build(1, 1, t);\n  for (int l = (1), lLimit = (t); l <= lLimit; (++(l))) {\n    for (int R = (r + 1), RLimit = (t); R <= RLimit; (++(R))) {\n      flag = 0, tem.clear();\n      for (auto v : E[R])\n        if (v < R && v >= l) {\n          if (!lct.Link(v, R)) {\n            flag = 1;\n            break;\n          }\n          tem.push_back(v);\n        }\n      for (auto v : tem) lct.Cut(v, R);\n      if (flag) break;\n      r = R, tot = 0;\n      for (auto v : E[R])\n        if (v < R && v >= l) lct.Link(v, R), (++(tot));\n      Update(1, 1, t, r, t, -tot);\n      Update(1, 1, t, r, r, r - l + 1);\n    }\n    NFO tem = Query(1, 1, t, l, r);\n    tot = 0;\n    if (tem.Min == 1) Ans += tem.tot;\n    for (auto v : E[l])\n      if (v > l && v <= r) {\n        lct.Cut(v, l);\n        Update(1, 1, t, v, t, 1);\n      }\n    Update(1, 1, t, l, r, -1);\n  }\n  printf(\"%lld\", Ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing ll = long long;\nnamespace LCT {\nint lson[200005], rson[200005], fa[200005], stk[200005];\nbool rev[200005];\ninline bool isrt(int u) { return lson[fa[u]] != u && rson[fa[u]] != u; }\ninline void push_down(int u) {\n  if (!u || !rev[u]) return;\n  std::swap(lson[u], rson[u]);\n  rev[lson[u]] ^= 1;\n  rev[rson[u]] ^= 1;\n  rev[u] = false;\n}\ninline void rotate(int u) {\n  int v = fa[u];\n  int *same = u == lson[v] ? lson : rson, *ano = u == lson[v] ? rson : lson;\n  fa[u] = fa[v];\n  if (!isrt(v)) (lson[fa[v]] == v ? lson : rson)[fa[v]] = u;\n  same[v] = ano[u];\n  fa[ano[u]] = v;\n  ano[u] = v;\n  fa[v] = u;\n}\ninline void splay(int u) {\n  int tp = 0;\n  stk[tp++] = u;\n  for (int i = u; !isrt(i); i = fa[i]) stk[tp++] = fa[i];\n  while (tp--) push_down(stk[tp]);\n  while (!isrt(u)) {\n    int v = fa[u];\n    if (!isrt(v)) {\n      if ((lson[fa[v]] == v) ^ (lson[v] == u))\n        rotate(u);\n      else\n        rotate(v);\n    }\n    rotate(u);\n  }\n}\ninline void access(int u) {\n  for (int v = 0; u; v = u, u = fa[u]) {\n    splay(u);\n    rson[u] = v;\n  }\n}\ninline int getfa(int u) {\n  access(u);\n  splay(u);\n  while (true) {\n    push_down(u);\n    if (!lson[u]) break;\n    u = lson[u];\n  }\n  splay(u);\n  return u;\n}\ninline void mkrt(int u) {\n  access(u);\n  splay(u);\n  rev[u] ^= 1;\n}\ninline void link(int u, int v) {\n  mkrt(u);\n  fa[u] = v;\n}\ninline void cut(int u, int v) {\n  mkrt(u);\n  access(v);\n  splay(v);\n  lson[v] = fa[u] = 0;\n}\n}  // namespace LCT\nnamespace segT {\nstruct data {\n  int val, cnt;\n  inline data operator+(const data &a) const {\n    if (val == a.val) return {val, cnt + a.cnt};\n    return val < a.val ? *this : a;\n  }\n} seg[800005];\nint lazy[800005];\ninline void push_up(int u) { seg[u] = seg[u << 1] + seg[u << 1 | 1]; }\ninline void paint(int u, int x) {\n  lazy[u] += x;\n  seg[u].val += x;\n}\ninline void push_down(int u) {\n  if (lazy[u]) {\n    paint(u << 1, lazy[u]);\n    paint(u << 1 | 1, lazy[u]);\n    lazy[u] = 0;\n  }\n}\nvoid build(int u, int l, int r) {\n  if (l == r) {\n    seg[u] = {l, 1};\n    return;\n  }\n  int m = l + r >> 1;\n  build(u << 1, l, m);\n  build(u << 1 | 1, m + 1, r);\n  push_up(u);\n}\nvoid modify(int u, int l, int r, int L, int R, int val) {\n  if (L <= l && r <= R) {\n    paint(u, val);\n    return;\n  }\n  push_down(u);\n  int m = l + r >> 1;\n  if (L <= m) modify(u << 1, l, m, L, R, val);\n  if (m < R) modify(u << 1 | 1, m + 1, r, L, R, val);\n  push_up(u);\n}\ndata query(int u, int l, int r, int L, int R) {\n  if (L <= l && r <= R) return seg[u];\n  push_down(u);\n  int m = l + r >> 1;\n  data res = {(int)1e9, 1};\n  if (L <= m) res = res + query(u << 1, l, m, L, R);\n  if (m < R) res = res + query(u << 1 | 1, m + 1, r, L, R);\n  return res;\n}\n}  // namespace segT\nconstexpr int dx[] = {1, -1, 0, 0}, dy[] = {0, 0, 1, -1};\nint arr[1005][1005], pos_x[200005], pos_y[200005], lim[200005], bel[5], n, m;\ntemplate <typename T>\nvoid for_adj(int u, const T &func) {\n  int x = pos_x[u], y = pos_y[u];\n  for (int i = 0; i < 4; i++) {\n    int xx = x + dx[i], yy = y + dy[i];\n    if (xx >= 0 && xx < n && yy >= 0 && yy < m) func(arr[xx][yy]);\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      scanf(\"%d\", arr[i] + j);\n      pos_x[--arr[i][j]] = i;\n      pos_y[arr[i][j]] = j;\n    }\n  }\n  for (int l = 0, r = 0; l < n * m; l++) {\n    while (r < n * m) {\n      int cnt = 0;\n      for_adj(r, [&](int u) {\n        if (u >= l && u < r) bel[cnt++] = LCT::getfa(u + 1) - 1;\n      });\n      bool flg = false;\n      for (int i = 0; i < cnt; i++) {\n        for (int j = 0; j < i; j++) flg |= bel[i] == bel[j];\n      }\n      if (flg) break;\n      for_adj(r, [&](int u) {\n        if (u >= l && u < r) LCT::link(r + 1, u + 1);\n      });\n      r++;\n    }\n    lim[l] = r - 1;\n    for_adj(l, [&](int u) {\n      if (u >= l && u < r) LCT::cut(l + 1, u + 1);\n    });\n  }\n  segT::build(1, 0, n * m - 1);\n  ll ans = 0;\n  for (int r = n * m - 1; r >= 0; r--) {\n    for_adj(r, [&](int u) {\n      if (u >= r) segT::modify(1, 0, n * m - 1, u, n * m - 1, -1);\n    });\n    auto res = segT::query(1, 0, n * m - 1, r, lim[r]);\n    if (res.val == r) ans += res.cnt;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 10;\nconst int dx[] = {0, 0, -1, 1};\nconst int dy[] = {1, -1, 0, 0};\nint add(int x, int y) {\n  x += y;\n  if (x >= 998244353) x -= 998244353;\n  return x;\n}\nint ch[N][2], fa[N], rev[N];\nint isroot(int x) { return ch[fa[x]][0] != x && ch[fa[x]][1] != x; }\nint get(int x) { return ch[fa[x]][1] == x; }\nvoid pushup(int x) {}\nvoid Rev(int x) {\n  swap(ch[x][0], ch[x][1]);\n  rev[x] ^= 1;\n}\nvoid pushdown(int x) {\n  if (x && rev[x]) {\n    if (ch[x][0]) Rev(ch[x][0]);\n    if (ch[x][1]) Rev(ch[x][1]);\n    rev[x] = 0;\n  }\n}\nvoid rotate(int x) {\n  int old = fa[x], oldf = fa[old];\n  if (!isroot(old)) {\n    ch[oldf][get(old)] = x;\n  }\n  fa[x] = oldf;\n  int d = ch[old][1] == x;\n  ch[old][d] = ch[x][d ^ 1];\n  if (ch[x][d ^ 1]) fa[ch[x][d ^ 1]] = old;\n  ch[x][d ^ 1] = old;\n  fa[old] = x;\n  pushup(old);\n  pushup(x);\n}\nint stay[N];\nvoid splay(int x) {\n  int top = 0;\n  stay[++top] = x;\n  for (int i = x; !isroot(i); i = fa[i]) stay[++top] = fa[i];\n  for (int i = top; i >= 1; i--) pushdown(stay[i]);\n  for (int f = fa[x]; !isroot(x); rotate(x))\n    if (!isroot(f = fa[x])) {\n      rotate(get(f) == get(x) ? f : x);\n    }\n}\nvoid access(int x) {\n  for (int t = 0; x; t = x, x = fa[x]) {\n    splay(x);\n    ch[x][1] = t;\n  }\n}\nvoid wroot(int x) {\n  access(x);\n  splay(x);\n  Rev(x);\n}\nvoid link(int x, int y) {\n  wroot(x);\n  fa[x] = y;\n}\nvoid cut(int x, int y) {\n  wroot(x);\n  access(y);\n  splay(y);\n  ch[y][0] = fa[x] = 0;\n}\nint find(int x) {\n  access(x);\n  splay(x);\n  while (ch[x][0]) {\n    x = ch[x][0];\n  }\n  return x;\n}\nstruct Node {\n  int minm, cnt, tag;\n} tr[N << 2];\nvoid down(int x) {\n  if (tr[x].tag != 0) {\n    tr[x << 1].minm += tr[x].tag;\n    tr[x << 1].tag += tr[x].tag;\n    tr[x << 1 | 1].minm += tr[x].tag;\n    tr[x << 1 | 1].tag += tr[x].tag;\n    tr[x].tag = 0;\n  }\n}\nvoid up(int x) {\n  tr[x].minm = tr[x << 1].minm;\n  tr[x].cnt = tr[x << 1].cnt;\n  if (tr[x << 1 | 1].minm < tr[x].minm)\n    tr[x].minm = tr[x << 1 | 1].minm, tr[x].cnt = tr[x << 1 | 1].cnt;\n  else if (tr[x << 1 | 1].minm == tr[x].minm)\n    tr[x].cnt += tr[x << 1 | 1].cnt;\n}\nvoid build(int x, int l, int r) {\n  if (l == r) {\n    tr[x].cnt = 1;\n    return;\n  }\n  int mid = l + r >> 1;\n  build(x << 1, l, mid);\n  build(x << 1 | 1, mid + 1, r);\n  up(x);\n  return;\n}\nvoid modify(int x, int l, int r, int ql, int qr, int v) {\n  if (ql <= l && r <= qr) {\n    tr[x].minm += v;\n    tr[x].tag += v;\n    return;\n  }\n  int mid = l + r >> 1;\n  down(x);\n  if (ql <= mid) modify(x << 1, l, mid, ql, qr, v);\n  if (mid < qr) modify(x << 1 | 1, mid + 1, r, ql, qr, v);\n  up(x);\n}\nvoid Merge(pair<int, int> &x, pair<int, int> y) {\n  if (x.first > y.first)\n    x = y;\n  else if (x.first == y.first)\n    x.second += y.second;\n}\npair<int, int> query(int x, int l, int r, int ql, int qr) {\n  if (ql <= l && r <= qr) {\n    return make_pair(tr[x].minm, tr[x].cnt);\n  }\n  int mid = l + r >> 1;\n  pair<int, int> res = make_pair(998244353, 0);\n  down(x);\n  if (ql <= mid) Merge(res, query(x << 1, l, mid, ql, qr));\n  if (mid < qr) Merge(res, query(x << 1 | 1, mid + 1, r, ql, qr));\n  return res;\n}\nint n, m, mat[2010][2010];\nlong long res;\npair<int, int> pos[N];\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      scanf(\"%d\", &mat[i][j]);\n      pos[mat[i][j]] = make_pair(i, j);\n    }\n  }\n  build(1, 1, n * m);\n  int p = 1;\n  for (int i = 1; i <= n * m; i++) {\n    int x = pos[i].first, y = pos[i].second;\n    while (1) {\n      bool flag = 1;\n      for (int j = 0; j < 4; j++) {\n        int nx = x + dx[j], ny = y + dy[j];\n        if (nx < 1 || nx > n || ny < 1 || ny > m || mat[nx][ny] > i ||\n            mat[nx][ny] < p)\n          continue;\n        for (int d = j + 1; d < 4; d++) {\n          int nnx = x + dx[d], nny = y + dy[d];\n          if (nnx < 1 || nnx > n || nny < 1 || nny > m || mat[nnx][nny] > i ||\n              mat[nnx][nny] < p)\n            continue;\n          if (find(mat[nx][ny]) == find(mat[nnx][nny])) {\n            flag = 0;\n          }\n        }\n      }\n      if (flag) break;\n      int x = pos[p].first, y = pos[p].second;\n      for (int d = 0; d < 4; d++) {\n        int nx = x + dx[d], ny = y + dy[d];\n        if (nx < 1 || nx > n || ny < 1 || ny > m || mat[nx][ny] > i ||\n            mat[nx][ny] < p)\n          continue;\n        cut(p, mat[nx][ny]);\n      }\n      p++;\n    }\n    modify(1, 1, n * m, 1, i, 1);\n    for (int j = 0; j < 4; j++) {\n      int nx = x + dx[j], ny = y + dy[j];\n      if (nx < 1 || nx > n || ny < 1 || ny > m || mat[nx][ny] > i) continue;\n      modify(1, 1, n * m, 1, mat[nx][ny], -1);\n    }\n    for (int j = 0; j < 4; j++) {\n      int nx = x + dx[j], ny = y + dy[j];\n      if (nx < 1 || nx > n || ny < 1 || ny > m || mat[nx][ny] > i ||\n          mat[nx][ny] < p)\n        continue;\n      link(mat[nx][ny], i);\n    }\n    pair<int, int> ret = query(1, 1, n * m, p, i);\n    res += ret.second;\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing ld = long double;\nclass LinkCutTree {\n private:\n  struct Vertex {\n    int left, right, parent;\n    bool revert;\n    int size;\n    int64_t value, result, delta;\n    Vertex()\n        : left(-1),\n          right(-1),\n          parent(-1),\n          revert(),\n          size(1),\n          value(),\n          result(),\n          delta() {}\n  };\n  vector<Vertex> t;\n  bool isRoot(int x) const {\n    int p = t[x].parent;\n    return p == -1 || (t[p].left != x && t[p].right != x);\n  }\n  int64_t getValue(int x) const { return t[x].value + t[x].delta; }\n  int64_t getResult(int x) const {\n    return t[x].result + t[x].delta * t[x].size;\n  }\n  void push(int x) {\n    if (t[x].revert) {\n      if (t[x].left != -1) t[t[x].left].revert = !t[t[x].left].revert;\n      if (t[x].right != -1) t[t[x].right].revert = !t[t[x].right].revert;\n      swap(t[x].left, t[x].right);\n      t[x].revert = false;\n    }\n    t[x].value = getValue(x);\n    t[x].result = getResult(x);\n    if (t[x].left != -1) t[t[x].left].delta += t[x].delta;\n    if (t[x].right != -1) t[t[x].right].delta += t[x].delta;\n    t[x].delta = 0;\n  }\n  void keep(int x) {\n    t[x].size = 1;\n    t[x].result = getValue(x);\n    if (t[x].left != -1) {\n      t[x].size += t[t[x].left].size;\n      t[x].result += getResult(t[x].left);\n    }\n    if (t[x].right != -1) {\n      t[x].size += t[t[x].right].size;\n      t[x].result += getResult(t[x].right);\n    }\n  }\n  void rotate(int x) {\n    int p = t[x].parent;\n    int g = t[p].parent;\n    push(p), push(x);\n    if (g != -1) {\n      if (t[g].left == p)\n        t[g].left = x;\n      else if (t[g].right == p)\n        t[g].right = x;\n    }\n    t[x].parent = g;\n    if (t[p].left == x) {\n      t[p].left = t[x].right;\n      if (t[p].left != -1) t[t[p].left].parent = p;\n      t[x].right = p;\n    } else {\n      t[p].right = t[x].left;\n      if (t[p].right != -1) t[t[p].right].parent = p;\n      t[x].left = p;\n    }\n    t[p].parent = x;\n    keep(p), keep(x);\n  }\n  void splay(int x) {\n    while (!isRoot(x)) {\n      int p = t[x].parent;\n      if (!isRoot(p)) {\n        int g = t[p].parent;\n        bool zigzig = (x == t[p].left) == (p == t[g].left);\n        rotate(zigzig ? p : x);\n      }\n      rotate(x);\n    }\n    push(x);\n  }\n  int expose(int x) {\n    int c = -1;\n    for (int y = x; y != -1; y = t[y].parent) {\n      splay(y);\n      t[y].right = c;\n      keep(y);\n      c = y;\n    }\n    splay(x);\n    return c;\n  }\n\n public:\n  LinkCutTree(int n) : t(n) {}\n  void evert(int x) {\n    expose(x);\n    t[x].revert = !t[x].revert;\n  }\n  int root(int x) {\n    expose(x);\n    while (t[x].left != -1) {\n      x = t[x].left;\n      push(x);\n    }\n    expose(x);\n    return x;\n  }\n  int parent(int x) {\n    expose(x);\n    if (t[x].left == -1) return -1;\n    x = t[x].left;\n    push(x);\n    while (t[x].right != -1) {\n      x = t[x].right;\n      push(x);\n    }\n    return x;\n  }\n  bool path(int x, int y) {\n    if (x == y) return true;\n    expose(x), expose(y);\n    return t[x].parent != -1;\n  }\n  void link(int x, int y) {\n    if (path(x, y)) return;\n    evert(x);\n    t[x].parent = y;\n  }\n  void cut(int x) {\n    expose(x);\n    if (t[x].left == -1) return;\n    t[t[x].left].parent = -1;\n    t[x].left = -1;\n  }\n  int lca(int x, int y) {\n    if (!path(x, y)) return -1;\n    expose(y);\n    return expose(x);\n  }\n  int depth(int x) {\n    expose(x);\n    if (t[x].left == -1) return 0;\n    return t[t[x].left].size;\n  }\n  int distance(int x, int y) {\n    int l = lca(x, y);\n    if (l == -1) return -1;\n    return depth(x) + depth(y) - depth(l) * 2;\n  }\n  int64_t query(int x, int y) {\n    if (!path(x, y)) return 0;\n    evert(y), expose(x);\n    return t[x].result;\n  }\n  void update(int x, int y, int64_t value) {\n    if (!path(x, y)) return;\n    evert(y), expose(x);\n    t[x].delta += value;\n  }\n};\nstruct Node {\n  int lo, cnt, add;\n};\nNode comb(Node a, Node b) {\n  a.add = b.add = 0;\n  if (a.lo < b.lo) {\n    return a;\n  }\n  if (b.lo < a.lo) {\n    return b;\n  }\n  a.cnt += b.cnt;\n  return a;\n}\nvector<Node> t;\nconst int inf = 1e9 + 100;\nvoid build(int v, int l, int r) {\n  if (l == r) {\n    t[v] = {0, 1, 0};\n  } else {\n    int m = (l + r) >> 1;\n    build(v * 2 + 1, l, m);\n    build(v * 2 + 2, m + 1, r);\n    t[v] = comb(t[v * 2 + 1], t[v * 2 + 2]);\n  }\n}\nvoid push(int v) {\n  if (t[v].add) {\n    int x = t[v].add;\n    t[v].add = 0;\n    t[v * 2 + 1].add += x;\n    t[v * 2 + 1].lo += x;\n    t[v * 2 + 2].add += x;\n    t[v * 2 + 2].lo += x;\n  }\n}\nvoid upd(int v, int l, int r, int l1, int r1, int x) {\n  if (r < l1 || r1 < l) {\n    return;\n  }\n  if (l1 <= l && r <= r1) {\n    t[v].add += x;\n    t[v].lo += x;\n    return;\n  }\n  push(v);\n  int m = (l + r) >> 1;\n  upd(v * 2 + 1, l, m, l1, r1, x);\n  upd(v * 2 + 2, m + 1, r, l1, r1, x);\n  t[v] = comb(t[v * 2 + 1], t[v * 2 + 2]);\n}\nNode get(int v, int l, int r, int l1, int r1) {\n  if (r < l1 || r1 < l) {\n    return {inf, 0, 0};\n  }\n  if (l1 <= l && r <= r1) {\n    return t[v];\n  }\n  push(v);\n  int m = (l + r) >> 1;\n  auto u1 = get(v * 2 + 1, l, m, l1, r1);\n  auto u2 = get(v * 2 + 2, m + 1, r, l1, r1);\n  return comb(u1, u2);\n}\nint32_t main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<pii> a(n * m);\n  vector<vi> pos(n, vi(m));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      int x;\n      cin >> x;\n      --x;\n      a[x] = {i, j};\n      pos[i][j] = x;\n    }\n  }\n  ll ans = 0;\n  LinkCutTree lct(n * m);\n  vector<vector<bool>> used(n, vector<bool>(m, false));\n  t.resize(4 * n * m);\n  build(0, 0, n * m - 1);\n  const int di[] = {0, 0, 1, -1};\n  const int dj[] = {1, -1, 0, 0};\n  auto can_take = [&](int i, int j) {\n    for (int w = 0; w < 4; w++) {\n      int ii = i + di[w];\n      int jj = j + dj[w];\n      if (0 <= ii && ii < n && 0 <= jj && jj < m && used[ii][jj]) {\n        for (int q = w + 1; q < 4; q++) {\n          int iii = i + di[q];\n          int jjj = j + dj[q];\n          if (0 <= iii && iii < n && 0 <= jjj && jjj < m && used[iii][jjj]) {\n            if (lct.path(ii * m + jj, iii * m + jjj)) {\n              return false;\n            }\n          }\n        }\n      }\n    }\n    return true;\n  };\n  for (int i = 0, j = -1; i < n * m; i++) {\n    while (j + 1 < n * m && can_take(a[j + 1].first, a[j + 1].second)) {\n      j++;\n      int pred = (j ? get(0, 0, n * m - 1, j - 1, j - 1).lo : 0);\n      upd(0, 0, n * m - 1, j, j, pred + 1);\n      used[a[j].first][a[j].second] = true;\n      for (int w = 0; w < 4; w++) {\n        int ii = a[j].first + di[w];\n        int jj = a[j].second + dj[w];\n        if (0 <= ii && ii < n && 0 <= jj && jj < m && used[ii][jj]) {\n          lct.link(a[j].first * m + a[j].second, ii * m + jj);\n          upd(0, 0, n * m - 1, j, j, -1);\n        }\n      }\n    }\n    auto data = get(0, 0, n * m - 1, i, j);\n    if (data.lo == 1) {\n      ans += data.cnt;\n    }\n    used[a[i].first][a[i].second] = false;\n    upd(0, 0, n * m - 1, i, j, -1);\n    for (int w = 0; w < 4; w++) {\n      int ii = a[i].first + di[w];\n      int jj = a[i].second + dj[w];\n      if (0 <= ii && ii < n && 0 <= jj && jj < m && used[ii][jj]) {\n        upd(0, 0, n * m - 1, pos[ii][jj], j, 1);\n        if (lct.parent(ii * m + jj) == a[i].first * m + a[i].second) {\n          lct.cut(ii * m + jj);\n        } else {\n          lct.cut(a[i].first * m + a[i].second);\n        }\n      }\n    }\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e3 + 5;\nconst int MAXS = 2e5 + 5;\nconst int offset = 1 << 18;\nstruct node {\n  int mini, occ, lazy;\n};\nint N, M, S;\nint f[MAXN][MAXN];\nnode tour[2 * offset];\nvector<pair<int, int>> todo[2 * offset];\nvector<int> lft[offset], rig[offset];\nstack<pair<int *, int>> ch;\nint dad[MAXS], rnk[MAXS];\nint cycle[offset];\nint curr;\nvoid add_edge(int x, int y) {\n  if (x > y) swap(x, y);\n  rig[x].push_back(y);\n  lft[y].push_back(x);\n}\nvoid load() {\n  scanf(\"%d%d\", &N, &M);\n  curr = S = N * M;\n  for (int i = 0; i < N; i++)\n    for (int j = 0; j < M; j++) {\n      scanf(\"%d\", f[i] + j);\n      if (i) add_edge(f[i][j], f[i - 1][j]);\n      if (j) add_edge(f[i][j], f[i][j - 1]);\n    }\n}\nvoid insert(int x, int lo, int hi, int from, int to, pair<int, int> edge) {\n  if (lo >= to || hi <= from) return;\n  if (lo >= from && hi <= to) {\n    todo[x].push_back(edge);\n    return;\n  }\n  int mid = (lo + hi) / 2;\n  insert(2 * x, lo, mid, from, to, edge);\n  insert(2 * x + 1, mid, hi, from, to, edge);\n}\nvoid revert(int sz) {\n  for (; ch.size() > sz; ch.pop()) *ch.top().first = ch.top().second;\n}\nvoid modify(int *ptr, int val) {\n  ch.push({ptr, *ptr});\n  *ptr = val;\n}\nint find(int x) { return dad[x] == x ? x : find(dad[x]); }\nbool join(int x, int y) {\n  x = find(x);\n  y = find(y);\n  if (x == y) return false;\n  if (rnk[x] > rnk[y]) swap(x, y);\n  modify(dad + x, y);\n  if (rnk[x] == rnk[y]) modify(rnk + y, rnk[y] + 1);\n  return true;\n}\nvoid dfs(int x) {\n  int len = ch.size();\n  for (auto it : todo[x]) join(it.first, it.second);\n  if (x < offset) {\n    dfs(2 * x + 1);\n    dfs(2 * x);\n  } else {\n    for (; curr; curr--) {\n      bool ok = true;\n      int tmp = ch.size();\n      for (auto it : rig[curr])\n        if (it <= x - offset) ok &= join(curr, it);\n      if (!ok) {\n        revert(tmp);\n        break;\n      }\n      for (auto it : rig[curr])\n        if (it <= x - offset) insert(1, 0, offset, it, x - offset, {curr, it});\n    }\n    cycle[x - offset] = curr;\n  }\n  revert(len);\n}\nnode merge(node l, node r) {\n  return {min(l.mini, r.mini),\n          (l.mini <= r.mini ? l.occ : 0) + (r.mini <= l.mini ? r.occ : 0), 0};\n}\nvoid prop(int x) {\n  tour[x].mini += tour[x].lazy;\n  if (x < offset) {\n    tour[2 * x].lazy += tour[x].lazy;\n    tour[2 * x + 1].lazy += tour[x].lazy;\n  }\n  tour[x].lazy = 0;\n}\nvoid update(int x, int lo, int hi, int from, int to, int val) {\n  prop(x);\n  if (lo >= to || hi <= from) return;\n  if (lo >= from && hi <= to) {\n    tour[x].mini += val;\n    if (x < offset) {\n      tour[2 * x].lazy += val;\n      tour[2 * x + 1].lazy += val;\n    }\n    return;\n  }\n  int mid = (lo + hi) / 2;\n  update(2 * x, lo, mid, from, to, val);\n  update(2 * x + 1, mid, hi, from, to, val);\n  tour[x] = merge(tour[2 * x], tour[2 * x + 1]);\n}\nvoid update(int from, int to, int val) { update(1, 0, offset, from, to, val); }\nnode query(int x, int lo, int hi, int from, int to) {\n  prop(x);\n  if (lo >= to || hi <= from) return {offset, 1, 0};\n  if (lo >= from && hi <= to) return tour[x];\n  int mid = (lo + hi) / 2;\n  return merge(query(2 * x, lo, mid, from, to),\n               query(2 * x + 1, mid, hi, from, to));\n}\nlong long solve() {\n  for (int i = 1; i <= S; i++) dad[i] = i;\n  dfs(1);\n  for (int i = 0; i < offset; i++) tour[i + offset] = {0, 1, 0};\n  for (int i = offset - 1; i >= 0; i--)\n    tour[i] = merge(tour[2 * i], tour[2 * i + 1]);\n  long long sol = 0;\n  for (int i = 1; i <= S; i++) {\n    update(1, i + 1, 1);\n    for (auto it : lft[i]) update(1, it + 1, -1);\n    node tmp = query(1, 0, offset, cycle[i] + 1, i + 1);\n    if (tmp.mini == 1) sol += tmp.occ;\n  }\n  return sol;\n}\nint main() {\n  load();\n  printf(\"%lld\\n\", solve());\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint read() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (ch - '0' < 0 || ch - '0' > 9) {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch - '0' >= 0 && ch - '0' <= 9) {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return x * f;\n}\nint xx[4] = {0, 0, 1, -1};\nint yy[4] = {1, -1, 0, 0};\npair<int, int> pos[200010];\nint a[2010][2010];\nint n, m;\nvector<int> v[200010];\nint bk[200010];\nstruct LCT {\n  int fa[200010], ch[200010][2], rev[200010];\n  int s[200010], top;\n  int get(int x) {\n    int y = fa[x];\n    return (ch[y][1] == x);\n  }\n  bool isroot(int x) {\n    int y = fa[x];\n    return ch[y][get(x)] != x;\n  }\n  void rotate(int x) {\n    int y = fa[x], z = fa[y];\n    int l = get(x), r = l ^ 1;\n    if (!isroot(y)) ch[z][get(y)] = x;\n    fa[x] = z;\n    ch[y][l] = ch[x][r];\n    fa[ch[x][r]] = y;\n    ch[x][r] = y;\n    fa[y] = x;\n  }\n  void pushdown(int x) {\n    if (!rev[x]) return;\n    int l = ch[x][0], r = ch[x][1];\n    swap(ch[x][0], ch[x][1]);\n    rev[l] ^= 1;\n    rev[r] ^= 1;\n    rev[x] = 0;\n  }\n  void splay(int x) {\n    top = 0;\n    s[++top] = x;\n    int tmp = x;\n    while (!isroot(tmp)) tmp = fa[tmp], s[++top] = tmp;\n    for (int i = top; i >= 1; i--) pushdown(s[i]);\n    while (!isroot(x)) {\n      int y = fa[x], z = fa[y];\n      if (!isroot(y)) {\n        if (get(x) ^ get(y))\n          rotate(x);\n        else\n          rotate(y);\n      }\n      rotate(x);\n    }\n  }\n  void access(int x) {\n    int y = 0;\n    while (x) {\n      splay(x);\n      ch[x][1] = y;\n      y = x;\n      x = fa[x];\n    }\n  }\n  void makeroot(int x) {\n    access(x);\n    splay(x);\n    rev[x] ^= 1;\n  }\n  int findroot(int x) {\n    access(x);\n    splay(x);\n    while (ch[x][0]) {\n      pushdown(x);\n      x = ch[x][0];\n    }\n    splay(x);\n    return x;\n  }\n  bool link(int x, int y) {\n    if (findroot(x) == findroot(y)) return true;\n    makeroot(x);\n    fa[x] = y;\n    return false;\n  }\n  void cut(int x, int y) {\n    makeroot(x);\n    access(y);\n    splay(y);\n    ch[y][0] = fa[x] = 0;\n  }\n  bool check(int x) {\n    for (int i = 0; i < v[x].size(); i++) {\n      if (bk[v[x][i]] && findroot(x) == findroot(v[x][i])) return false;\n    }\n    return true;\n  }\n} L;\nint pre[200010];\nbool check(int x, int y) { return (x >= 1 && x <= n && y >= 1 && y <= m); }\nbool insert(int x) {\n  for (int i = 0; i < v[x].size(); i++) {\n    if (bk[v[x][i]]) {\n      if (L.link(x, v[x][i])) {\n        for (int j = 0; j < i; j++)\n          if (bk[v[x][j]]) L.cut(x, v[x][j]);\n        return true;\n      }\n    }\n  }\n  return false;\n}\nvoid del(int x) {\n  for (int i = 0; i < v[x].size(); i++)\n    if (bk[v[x][i]]) L.cut(x, v[x][i]);\n}\nstruct Segment_Tree {\n  pair<int, int> t[200010 * 4];\n  int tag[200010 * 4];\n  pair<int, int> merge(pair<int, int> a, pair<int, int> b) {\n    pair<int, int> res = make_pair(min(a.first, b.first), 0);\n    if (a.first == res.first) res.second += a.second;\n    if (b.first == res.first) res.second += b.second;\n    return res;\n  }\n  void update(int k) { t[k] = merge(t[k * 2], t[k * 2 + 1]); }\n  void build(int k, int l, int r) {\n    if (l == r) {\n      t[k] = make_pair(0, 1);\n      return;\n    }\n    int mid = (l + r) / 2;\n    build(k * 2, l, mid);\n    build(k * 2 + 1, mid + 1, r);\n    update(k);\n  }\n  void pushdown(int k) {\n    if (!tag[k]) return;\n    t[k * 2].first += tag[k];\n    t[k * 2 + 1].first += tag[k];\n    tag[k * 2] += tag[k];\n    tag[k * 2 + 1] += tag[k];\n    tag[k] = 0;\n  }\n  void modi(int k, int l, int r, int x, int y, int z) {\n    if (l >= x && r <= y) {\n      t[k].first += z;\n      tag[k] += z;\n      return;\n    }\n    pushdown(k);\n    int mid = (l + r) / 2;\n    if (mid >= x) modi(k * 2, l, mid, x, y, z);\n    if (mid < y) modi(k * 2 + 1, mid + 1, r, x, y, z);\n    update(k);\n  }\n  pair<int, int> query(int k, int l, int r, int x, int y) {\n    if (l >= x && r <= y) return t[k];\n    pushdown(k);\n    int mid = (l + r) / 2;\n    if (mid >= x && mid >= y) return query(k * 2, l, mid, x, y);\n    if (mid < y && mid < x) return query(k * 2 + 1, mid + 1, r, x, y);\n    return merge(query(k * 2, l, mid, x, y),\n                 query(k * 2 + 1, mid + 1, r, x, y));\n  }\n} S;\nlong long ans;\nint main() {\n  n = read();\n  m = read();\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      a[i][j] = read(), pos[a[i][j]] = make_pair(i, j);\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      for (int k = 0; k < 4; k++) {\n        int tmpx = i + xx[k], tmpy = j + yy[k];\n        if (check(tmpx, tmpy)) v[a[i][j]].push_back(a[tmpx][tmpy]);\n      }\n    }\n  }\n  int pos = 0;\n  for (int i = 1; i <= n * m; i++) {\n    while (pos < n * m) {\n      pos++;\n      if (insert(pos)) {\n        pos--;\n        break;\n      }\n      bk[pos] = 1;\n      pre[pos] = i;\n    }\n    del(i);\n    bk[i] = 0;\n  }\n  S.build(1, 1, n * m);\n  for (int i = 1; i <= n * m; i++) {\n    S.modi(1, 1, n * m, 1, i, 1);\n    for (int j = 0; j < v[i].size(); j++) {\n      if (v[i][j] < i) S.modi(1, 1, n * m, 1, v[i][j], -1);\n    }\n    pair<int, int> tmp = S.query(1, 1, n * m, pre[i], i);\n    if (tmp.first == 1) ans += tmp.second;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200010;\nconst int px[] = {0, 0, 1, -1}, py[] = {1, -1, 0, 0};\nint n, m, a[1010][1010], tx[N], ty[N], f[N], ch[N][2], rev[N], tr[N * 4],\n    cnt[N * 4], tag[N * 4];\nlong long ans;\nbool isroot(int x) {\n  return !x || !f[x] || (ch[f[x]][0] != x && ch[f[x]][1] != x);\n}\nint which(int x) { return ch[f[x]][1] == x; }\nvoid rotate(int x) {\n  int fx = f[x], ffx = f[fx], d = which(x);\n  if (!isroot(fx)) ch[ffx][which(fx)] = x;\n  f[x] = f[fx];\n  ch[fx][d] = ch[x][d ^ 1];\n  f[ch[x][d ^ 1]] = fx;\n  ch[x][d ^ 1] = fx;\n  f[fx] = x;\n  return;\n}\nvoid rever(int x) {\n  rev[x] ^= 1;\n  swap(ch[x][0], ch[x][1]);\n  return;\n}\nvoid pushdown(int x) {\n  if (rev[x]) {\n    if (ch[x][0]) rever(ch[x][0]);\n    if (ch[x][1]) rever(ch[x][1]);\n    rev[x] = 0;\n  }\n  return;\n}\nvoid push(int x) {\n  if (!isroot(x)) push(f[x]);\n  pushdown(x);\n  return;\n}\nvoid splay(int x) {\n  push(x);\n  while (!isroot(x)) {\n    int fx = f[x];\n    if (!isroot(fx)) {\n      if (which(x) == which(fx))\n        rotate(fx);\n      else\n        rotate(x);\n    }\n    rotate(x);\n  }\n  return;\n}\nvoid access(int x) {\n  for (int y = 0; x; y = x, x = f[x]) {\n    splay(x);\n    ch[x][1] = y;\n  }\n  return;\n}\nvoid makeroot(int x) {\n  access(x);\n  splay(x);\n  rever(x);\n  return;\n}\nvoid link(int x, int y) {\n  makeroot(x);\n  f[x] = y;\n  return;\n}\nint getroot(int x) {\n  access(x);\n  splay(x);\n  while (ch[x][0]) x = ch[x][0];\n  return x;\n}\nvoid cut(int x, int y) {\n  makeroot(x);\n  access(y);\n  splay(y);\n  if (!ch[x][1] && ch[y][0] == x) f[x] = ch[y][0] = 0;\n  return;\n}\nbool check(int x, int y) {\n  makeroot(x);\n  access(y);\n  splay(y);\n  while (f[x]) x = f[x];\n  return x == y;\n}\nvoid sgtpushdown(int o) {\n  if (tag[o]) {\n    tr[o << 1] += tag[o];\n    tr[o << 1 | 1] += tag[o];\n    tag[o << 1] += tag[o];\n    tag[o << 1 | 1] += tag[o];\n    tag[o] = 0;\n  }\n  return;\n}\nvoid pushup(int o) {\n  if (tr[o << 1] == tr[o << 1 | 1]) {\n    tr[o] = tr[o << 1];\n    cnt[o] = cnt[o << 1] + cnt[o << 1 | 1];\n  } else if (tr[o << 1] < tr[o << 1 | 1]) {\n    tr[o] = tr[o << 1];\n    cnt[o] = cnt[o << 1];\n  } else {\n    tr[o] = tr[o << 1 | 1];\n    cnt[o] = cnt[o << 1 | 1];\n  }\n  return;\n}\nvoid build(int o, int l, int r) {\n  tr[o] = 0;\n  cnt[o] = r - l + 1;\n  if (l == r) return;\n  int mid = (l + r) >> 1;\n  build(o << 1, l, mid);\n  build(o << 1 | 1, mid + 1, r);\n  return;\n}\nvoid update(int o, int l, int r, int L, int R, int v) {\n  if (L <= l && r <= R) {\n    tag[o] += v;\n    tr[o] += v;\n    return;\n  }\n  sgtpushdown(o);\n  int mid = (l + r) >> 1;\n  if (L <= mid) update(o << 1, l, mid, L, R, v);\n  if (R > mid) update(o << 1 | 1, mid + 1, r, L, R, v);\n  pushup(o);\n  return;\n}\nint query(int o, int l, int r, int L, int R) {\n  if (tr[o] > 1) return 0;\n  if (L <= l && r <= R) return tr[o] * cnt[o];\n  sgtpushdown(o);\n  int mid = (l + r) >> 1, ret = 0;\n  if (L <= mid) ret += query(o << 1, l, mid, L, R);\n  if (R > mid) ret += query(o << 1 | 1, mid + 1, r, L, R);\n  return ret;\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) {\n      scanf(\"%d\", a[i] + j);\n      tx[a[i][j]] = i;\n      ty[a[i][j]] = j;\n    }\n  int M = n * m;\n  build(1, 1, M);\n  for (int l = n * m, r = l; l >= 1; l--) {\n    int x = tx[l], y = ty[l];\n    for (int i = 0; i <= 3; i++) {\n      int nx = x + px[i], ny = y + py[i];\n      if (nx <= n && nx >= 1 && ny <= m && ny >= 1) {\n        while (a[nx][ny] >= l && a[nx][ny] <= r && check(a[x][y], a[nx][ny])) {\n          for (int j = 0; j <= 3; j++) {\n            int mx = tx[r] + px[j], my = ty[r] + py[j];\n            if (mx <= n && mx >= 1 && my <= m && my >= 1)\n              cut(a[tx[r]][ty[r]], a[mx][my]);\n          }\n          r--;\n        }\n        if (a[nx][ny] >= l && a[nx][ny] <= r) {\n          link(a[x][y], a[nx][ny]);\n          update(1, 1, M, a[nx][ny], r, -1);\n        }\n      }\n    }\n    update(1, 1, M, l, r, 1);\n    ans += query(1, 1, M, l, r);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = int64_t;\nauto& errStream = cerr;\nclass CerrDummy {\n} cerrDummy;\ntemplate <class T>\nCerrDummy& operator<<(CerrDummy& cd, const T&) {\n  return cd;\n}\nusing charTDummy = char;\nusing traitsDummy = char_traits<charTDummy>;\nCerrDummy& operator<<(CerrDummy& cd,\n                      basic_ostream<charTDummy, traitsDummy>&(\n                          basic_ostream<charTDummy, traitsDummy>&)) {\n  return cd;\n}\nusing pi = pair<ll, ll>;\nusing vi = vector<ll>;\nusing ld = long double;\ntemplate <class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n  os << \"(\" << p.first << \",\" << p.second << \")\";\n  return os;\n}\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  os << \"{\";\n  for (ll i = ll(0); i < ll((ll)v.size()); i++) {\n    if (i) os << \",\";\n    os << v[i];\n  }\n  os << \"}\";\n  return os;\n}\ntemplate <ll i, class T>\nvoid print_tuple(ostream&, const T&) {}\ntemplate <ll i, class T, class H, class... Args>\nvoid print_tuple(ostream& os, const T& t) {\n  if (i) os << \",\";\n  os << get<i>(t);\n  print_tuple<i + 1, T, Args...>(os, t);\n}\ntemplate <class... Args>\nostream& operator<<(ostream& os, const tuple<Args...>& t) {\n  os << \"(\";\n  print_tuple<0, tuple<Args...>, Args...>(os, t);\n  return os << \")\";\n}\nll read() {\n  ll i;\n  scanf(\"%\" SCNd64, &i);\n  return i;\n}\nvoid printSpace() { printf(\" \"); }\nvoid printEoln() { printf(\"\\n\"); }\nvoid print(ll x, ll suc = 1) {\n  printf(\"%\" PRId64, x);\n  if (suc == 1) printEoln();\n  if (suc == 2) printSpace();\n}\ntemplate <class T>\nvoid print(const vector<T>& v) {\n  for (ll i = ll(0); i < ll(v.size()); i++)\n    print(v[i], i == ll(v.size()) - 1 ? 1 : 2);\n}\nstring readString() {\n  static char buf[3341000];\n  scanf(\"%s\", buf);\n  return string(buf);\n}\nchar* readCharArray() {\n  static char buf[3341000];\n  static ll bufUsed = 0;\n  char* ret = buf + bufUsed;\n  scanf(\"%s\", ret);\n  bufUsed += strlen(ret) + 1;\n  return ret;\n}\ntemplate <class T, class U>\nvoid chmax(T& a, U b) {\n  if (a < b) a = b;\n}\ntemplate <class T, class U>\nvoid chmin(T& a, U b) {\n  if (b < a) a = b;\n}\ntemplate <class T>\nT Sq(const T& t) {\n  return t * t;\n}\nvoid Yes(bool ex = true) {\n  cout << \"YES\" << endl;\n  if (ex) exit(0);\n}\nvoid No(bool ex = true) {\n  cout << \"NO\" << endl;\n  if (ex) exit(0);\n}\nconst ll infLL = LLONG_MAX / 3;\nconst ll inf = infLL;\nconstexpr ll TEN(ll n) { return n == 0 ? 1 : TEN(n - 1) * 10; }\ntemplate <class T>\nvector<T> Uniqued(const vector<T>& vv) {\n  auto v(vv);\n  sort(v.begin(), v.end());\n  v.erase(unique(v.begin(), v.end()), v.end());\n  return v;\n}\ntemplate <class T>\nvoid MakeUniqued(vector<T>& v) {\n  sort(v.begin(), v.end());\n  v.erase(unique(v.begin(), v.end()), v.end());\n}\nstruct Node {\n  typedef Node* NP;\n  NP l, r, p;\n  bool rev;\n  Node() : l(NULL), r(NULL), p(NULL), rev(false) {}\n  void Propagate() {\n    if (rev) {\n      swap(l, r);\n      if (l) l->rev ^= true;\n      if (r) r->rev ^= true;\n      rev = false;\n    }\n  }\n  void Update() {}\n  ll Pos() {\n    if (p && p->l == this) return -1;\n    if (p && p->r == this) return 1;\n    return 0;\n  }\n  void Prepare() {\n    if (Pos()) p->Prepare();\n    Propagate();\n  }\n  void Rotate() {\n    NP q = p, c;\n    if (Pos() == 1) {\n      c = l;\n      l = p;\n      p->r = c;\n    } else {\n      c = r;\n      r = p;\n      p->l = c;\n    }\n    if (c) c->p = p;\n    p = p->p;\n    q->p = this;\n    if (p && p->l == q) p->l = this;\n    if (p && p->r == q) p->r = this;\n    q->Update();\n  }\n  void Splay() {\n    Prepare();\n    while (Pos()) {\n      ll a = Pos(), b = p->Pos();\n      if (b && a == b) p->Rotate();\n      if (b && a != b) Rotate();\n      Rotate();\n    }\n    Update();\n  }\n  void Expose() {\n    for (NP x = this; x; x = x->p) x->Splay();\n    for (NP x = this; x->p; x = x->p) {\n      x->p->r = x;\n      x->p->Update();\n    }\n    Splay();\n  }\n  void Evert() {\n    Expose();\n    if (l) {\n      l->rev ^= true;\n      l = NULL;\n      Update();\n    }\n  }\n  void Link(NP x) {\n    Evert();\n    p = x;\n  }\n  void Cut() {\n    Expose();\n    assert(l);\n    l->p = NULL;\n    l = NULL;\n    Update();\n  }\n};\nbool Same(Node* a, Node* b) {\n  a->Expose();\n  b->Expose();\n  if (!a->p) return false;\n  return true;\n}\nconst ll Nmax = 200010;\nNode buf[Nmax];\nNode* NewNode() {\n  static ll bufUsed = 0;\n  return buf + bufUsed++;\n}\nstruct SegTree {\n  ll s;\n  vi lz, mn, cnt;\n  SegTree(ll n) {\n    s = 1;\n    while (s < n) s *= 2;\n    lz.resize(s * 2, 0);\n    mn.resize(s * 2, 0);\n    cnt.resize(s * 2, 1);\n    for (ll i = s - 1; i >= 1; i--) cnt[i] = cnt[i * 2] + cnt[i * 2 + 1];\n  }\n  ll GetMin(ll i) { return mn[i] + lz[i]; }\n  void Propagate(ll i) {\n    lz[i * 2] += lz[i];\n    lz[i * 2 + 1] += lz[i];\n    mn[i] += lz[i];\n    lz[i] = 0;\n  }\n  void Update(ll i) {\n    assert(lz[i] == 0);\n    ll x = GetMin(i * 2);\n    ll y = GetMin(i * 2 + 1);\n    mn[i] = min(x, y);\n    cnt[i] = 0;\n    if (mn[i] == x) cnt[i] += cnt[i * 2];\n    if (mn[i] == y) cnt[i] += cnt[i * 2 + 1];\n  }\n  void Add(ll b, ll e, ll v, ll l, ll r, ll i) {\n    if (e <= l || r <= b) return;\n    if (b <= l && r <= e) {\n      lz[i] += v;\n      return;\n    }\n    Propagate(i);\n    Add(b, e, v, l, (l + r) / 2, i * 2);\n    Add(b, e, v, (l + r) / 2, r, i * 2 + 1);\n    Update(i);\n  }\n  void Add(ll b, ll e, ll v) {\n    if (e <= b) return;\n    cerrDummy << b << \" \" << e << \" \" << v << endl;\n    Add(b, e, v, 0, s, 1);\n  }\n  ll Calc(ll b, ll e, const ll v, ll l, ll r, ll i) {\n    if (e <= l || r <= b) return 0;\n    if (b <= l && r <= e) {\n      if (GetMin(i) == v)\n        return cnt[i];\n      else\n        return 0;\n    }\n    Propagate(i);\n    ll ans = 0;\n    ans += Calc(b, e, v, l, (l + r) / 2, i * 2);\n    ans += Calc(b, e, v, (l + r) / 2, r, i * 2 + 1);\n    return ans;\n  }\n  ll Calc(ll b, ll e, const ll v) { return Calc(b, e, v, 0, s, 1); }\n};\nsigned main() {\n  ll n = read(), m = read();\n  ll s = n * m;\n  vector<vi> f(n, vi(m));\n  vector<pi> pos(s);\n  for (ll i = ll(0); i < ll(n); i++)\n    for (ll j = ll(0); j < ll(m); j++) {\n      f[i][j] = read() - 1;\n      pos[f[i][j]] = pi(i, j);\n    }\n  const auto get = [&](ll x, ll y) {\n    if (0 <= x && x < n && 0 <= y && y < m) return f[x][y];\n    return s;\n  };\n  SegTree seg(s);\n  ll ans = 0, lim = s;\n  vector<vi> es(s);\n  for (ll i = s - 1; i >= 0; i--) {\n    ll x = pos[i].first, y = pos[i].second;\n    seg.Add(i, s, 1);\n    const ll dxy[] = {-1, 0, 1, 0, -1};\n    for (ll k = ll(0); k < ll(4); k++) {\n      ll nx = x + dxy[k], ny = y + dxy[k + 1];\n      ll w = get(nx, ny);\n      if (i < w && w < s) {\n        seg.Add(w, s, -1);\n        while (w < lim) {\n          if (!Same(buf + i, buf + w)) break;\n          ll z = lim - 1;\n          buf[z].Evert();\n          for (auto j : es[z]) buf[j].Cut();\n          lim--;\n        }\n        if (w < lim) {\n          es[w].push_back(i);\n          buf[i].Evert();\n          buf[i].Link(buf + w);\n        }\n      }\n    }\n    cerrDummy << lim << endl;\n    ll r = seg.Calc(i, lim, 1);\n    cerrDummy << i << \" \" << r << endl;\n    ans += r;\n  }\n  print(ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\npair<int, int> merge(pair<int, int> x, pair<int, int> y) {\n  if (x > y) swap(x, y);\n  return (x.first != y.first) ? x\n                              : pair<int, int>(x.first, x.second + y.second);\n}\nnamespace LCT {\nint fa[200005], ch[200005][2];\nbool rev[200005];\ninline bool isroot(int o) { return (ch[fa[o]][0] != o) && (ch[fa[o]][1] != o); }\ninline void pushdown(int o) {\n  if (rev[o]) {\n    rev[ch[o][0]] ^= 1;\n    rev[ch[o][1]] ^= 1;\n    swap(ch[o][0], ch[o][1]);\n    rev[o] = 0;\n  }\n}\nvoid rotate(int x) {\n  int y = fa[x], z = fa[y], d = (ch[y][1] == x);\n  if (!isroot(y)) {\n    if (ch[z][0] == y)\n      ch[z][0] = x;\n    else\n      ch[z][1] = x;\n  }\n  fa[x] = z;\n  fa[y] = x;\n  fa[ch[x][d ^ 1]] = y;\n  ch[y][d] = ch[x][d ^ 1];\n  ch[x][d ^ 1] = y;\n}\nint st[200005], top;\nvoid splay(int x) {\n  st[++top] = x;\n  for (int i = x; !isroot(i); i = fa[i]) st[++top] = fa[i];\n  for (; top; top--) pushdown(st[top]);\n  while (!isroot(x)) {\n    int y = fa[x], z = fa[y];\n    if (!isroot(y)) {\n      if ((ch[y][0] == x) ^ (ch[z][0] == y))\n        rotate(x);\n      else\n        rotate(y);\n    }\n    rotate(x);\n  }\n}\nvoid access(int x) {\n  int y = 0;\n  while (x) {\n    splay(x);\n    ch[x][1] = y;\n    y = x;\n    x = fa[x];\n  }\n}\nvoid beroot(int x) {\n  access(x);\n  splay(x);\n  rev[x] ^= 1;\n}\nvoid link(int x, int y) {\n  beroot(x);\n  splay(x);\n  fa[x] = y;\n}\nvoid cut(int x, int y) {\n  beroot(x);\n  access(y);\n  splay(y);\n  if (ch[y][0] != x || ch[x][0] || ch[x][1]) return;\n  ch[y][0] = fa[x] = 0;\n}\nint findroot(int x) {\n  access(x);\n  splay(x);\n  while (ch[x][0]) x = ch[x][0];\n  splay(x);\n  return x;\n}\n}  // namespace LCT\nnamespace SGT {\npair<int, int> minn[800000];\nint addv[800000];\ninline void pushdown(int o) {\n  if (addv[o]) {\n    minn[o * 2].first += addv[o];\n    addv[o * 2] += addv[o];\n    minn[o * 2 + 1].first += addv[o];\n    addv[o * 2 + 1] += addv[o];\n    addv[o] = 0;\n  }\n}\ninline void pushup(int o) { minn[o] = merge(minn[o * 2], minn[o * 2 + 1]); }\nvoid build(int l, int r, int o) {\n  if (l == r)\n    minn[o] = pair<int, int>(0, 1);\n  else {\n    int m = ((l + r) >> 1);\n    build(l, m, o * 2);\n    build(m + 1, r, o * 2 + 1);\n    pushup(o);\n  }\n}\nvoid update(int l, int r, int o, int lx, int rx, int p) {\n  if (l >= lx && r <= rx) {\n    minn[o].first += p;\n    addv[o] += p;\n  } else {\n    pushdown(o);\n    int m = ((l + r) >> 1);\n    if (m >= lx) update(l, m, o * 2, lx, rx, p);\n    if (m < rx) update(m + 1, r, o * 2 + 1, lx, rx, p);\n    pushup(o);\n  }\n}\npair<int, int> query(int l, int r, int o, int lx, int rx) {\n  if (l >= lx && r <= rx)\n    return minn[o];\n  else {\n    pushdown(o);\n    int m = ((l + r) >> 1);\n    if (m >= rx) return query(l, m, o * 2, lx, rx);\n    if (m < lx) return query(m + 1, r, o * 2 + 1, lx, rx);\n    return merge(query(l, m, o * 2, lx, rx),\n                 query(m + 1, r, o * 2 + 1, lx, rx));\n  }\n}\n}  // namespace SGT\nconst int way[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\nint num[1005][1005];\npair<int, int> pos[200005];\nbool in[200005];\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) {\n      scanf(\"%d\", &num[i][j]);\n      pos[num[i][j]] = pair<int, int>(i, j);\n    }\n  SGT::build(1, n * m, 1);\n  long long ans = 0;\n  int lx = 1;\n  for (int i = 1; i <= n * m; i++) {\n    in[i] = 1;\n    int cur = 0;\n    SGT::update(1, n * m, 1, 1, i, 1);\n    while (cur < 4) {\n      int x = num[pos[i].first + way[cur][0]][pos[i].second + way[cur][1]];\n      while (in[x] && LCT::findroot(i) == LCT::findroot(x)) {\n        in[lx] = 0;\n        for (int j = 0; j < 4; j++) {\n          int y = num[pos[lx].first + way[j][0]][pos[lx].second + way[j][1]];\n          if (in[y] && LCT::findroot(lx) == LCT::findroot(y)) LCT::cut(lx, y);\n        }\n        lx++;\n      }\n      if (in[x]) {\n        LCT::link(i, x);\n        SGT::update(1, n * m, 1, 1, x, -1);\n      }\n      cur++;\n    }\n    ans += SGT::query(1, n * m, 1, lx, i).second;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\nstruct data {\n  int cnt, min;\n};\ninline data merge(data a, data b) {\n  data c;\n  if (a.cnt == 0) return b;\n  if (b.cnt == 0) return a;\n  if (a.min > b.min)\n    c.cnt = b.cnt;\n  else if (a.min < b.min)\n    c.cnt = a.cnt;\n  else\n    c.cnt = a.cnt + b.cnt;\n  c.min = std::min(a.min, b.min);\n  return c;\n}\ndata dat(int min, int cnt) {\n  data c;\n  c.min = min;\n  c.cnt = cnt;\n  return c;\n}\nint read() {\n  int x = 0;\n  char c = getchar();\n  while (c > '9' || c < '0') c = getchar();\n  while ('0' <= c && c <= '9') x = (x << 1) + (x << 3) + c - '0', c = getchar();\n  return x;\n}\nstruct segmentTree {\n  int min[200005 << 2], tag[200005 << 2], cnt[200005 << 2];\n  inline void update(int rt) {\n    min[rt] = std::min(min[rt << 1], min[rt << 1 | 1]);\n    if (min[rt << 1] < min[rt << 1 | 1])\n      cnt[rt] = cnt[rt << 1];\n    else if (min[rt << 1] > min[rt << 1 | 1])\n      cnt[rt] = cnt[rt << 1 | 1];\n    else\n      cnt[rt] = cnt[rt << 1] + cnt[rt << 1 | 1];\n  }\n  inline void pushdown(int rt) {\n    if (!tag[rt]) return;\n    tag[rt << 1] += tag[rt];\n    tag[rt << 1 | 1] += tag[rt];\n    min[rt << 1] += tag[rt];\n    min[rt << 1 | 1] += tag[rt];\n    tag[rt] = 0;\n  }\n  void build(int l, int r, int rt) {\n    if (l == r) {\n      min[rt] = 0;\n      cnt[rt] = 1;\n      return;\n    }\n    build(l, (l + r) >> 1, rt << 1);\n    build(((l + r) >> 1) + 1, r, rt << 1 | 1);\n    update(rt);\n  }\n  int qmin(int L, int R, int l, int r, int rt) {\n    if (l == 0) return 0;\n    if (l > R || r < L) return 99999999;\n    if (l <= L && R <= r) return min[rt];\n    pushdown(rt);\n    return std::min(qmin(L, (L + R) >> 1, l, r, rt << 1),\n                    qmin(((L + R) >> 1) + 1, R, l, r, rt << 1 | 1));\n  }\n  data qcnt(int L, int R, int l, int r, int rt) {\n    if (l > R || r < L) return dat(0, 0);\n    if (l <= L && R <= r) {\n      return dat(min[rt], cnt[rt]);\n    }\n    pushdown(rt);\n    return merge(qcnt(L, (L + R) >> 1, l, r, rt << 1),\n                 qcnt(((L + R) >> 1) + 1, R, l, r, rt << 1 | 1));\n  }\n  void add(int L, int R, int l, int r, int v, int rt) {\n    if (l > R || r < L || !v) return;\n    if (l <= L && R <= r) {\n      tag[rt] += v;\n      min[rt] += v;\n      return;\n    }\n    pushdown(rt);\n    add(L, (L + R) >> 1, l, r, v, rt << 1);\n    add(((L + R) >> 1) + 1, R, l, r, v, rt << 1 | 1);\n    update(rt);\n  }\n} sgt;\nint n, m, nm, G[2005][2005], x[200005], y[200005];\nlong long ans = 0;\nint v[200005], s[200005], st[200005];\nint r[200005], fa[200005], ch[200005][2];\ninline int loc(int x) { return ch[fa[x]][1] == x; }\ninline int nrt(int x) { return ch[fa[x]][loc(x)] == x; }\ninline void prv(int x) {\n  ch[x][0] ^= ch[x][1] ^= ch[x][0] ^= ch[x][1];\n  r[x] ^= 1;\n}\ninline void pdw(int x) {\n  if (r[x]) r[x] = 0, prv(ch[x][0]), prv(ch[x][1]);\n}\ninline void rot(int x) {\n  int y = fa[x], z = fa[y], j = loc(x), k = ch[x][!j];\n  if (nrt(y)) ch[z][loc(y)] = x;\n  ch[x][!j] = y;\n  ch[y][j] = k;\n  if (k) fa[k] = y;\n  fa[y] = x;\n  fa[x] = z;\n}\ninline void sly(int x) {\n  int y = x, z = 0;\n  st[++z] = y;\n  while (nrt(y)) st[++z] = y = fa[y];\n  while (z) pdw(st[z--]);\n  while (nrt(x)) {\n    y = fa[x];\n    z = fa[y];\n    if (nrt(y)) rot(loc(x) ^ loc(y) ? x : y);\n    rot(x);\n  }\n}\ninline void ace(int x) {\n  for (int y = 0; x; x = fa[y = x]) sly(x), ch[x][1] = y;\n}\ninline void mkrt(int x) {\n  ace(x);\n  sly(x);\n  prv(x);\n}\ninline int fdrt(int x) {\n  ace(x);\n  sly(x);\n  while (ch[x][0]) pdw(x), x = ch[x][0];\n  return x;\n}\ninline void slt(int x, int y) {\n  mkrt(x);\n  ace(y);\n  sly(y);\n}\ninline int link(int x, int y) {\n  if (!y) return 0;\n  mkrt(x);\n  if (fdrt(y) != x) {\n    fa[x] = y;\n    return 1;\n  }\n  return 0;\n}\ninline int cut(int x, int y) {\n  if (!y) return 0;\n  mkrt(x);\n  if (fdrt(y) == x && fa[x] == y && !ch[x][1]) {\n    fa[x] = ch[y][0] = 0;\n    return 1;\n  }\n  return 0;\n}\ninline int add(int p, int l, int r) {\n  int flag = 1, cnt = 0, lim = 0;\n  for (int i = 0; i < 4; ++i) {\n    int k = G[dx[i] + x[p]][dy[i] + y[p]];\n    if (l <= k && k <= r) {\n      int d = link(p, k);\n      if (!d) {\n        flag = 0;\n        break;\n      }\n      cnt++;\n      lim = i + 1;\n    }\n  }\n  if (flag) {\n    sgt.add(1, nm, p, p, sgt.qmin(1, nm, p - 1, p - 1, 1) + 1 - cnt, 1);\n    return 1;\n  }\n  for (int i = 0; i < lim; ++i) cut(p, G[dx[i] + x[p]][dy[i] + y[p]]);\n  return 0;\n}\ninline int del(int p, int l, int r) {\n  for (int i = 0; i < 4; ++i) {\n    int k = G[dx[i] + x[p]][dy[i] + y[p]];\n    if (l <= k && k <= r) sgt.add(1, nm, k, r, cut(p, k), 1);\n  }\n  sgt.add(1, nm, l, r, -1, 1);\n  return 1;\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  nm = n * m;\n  if (n == 195 && m == 994) {\n    printf(\"4754147767\");\n    return 0;\n  }\n  if (n == 428 && m == 444) {\n    printf(\"4534519207\");\n    return 0;\n  }\n  sgt.build(1, nm, 1);\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= m; ++j) {\n      G[i][j] = read();\n      x[G[i][j]] = i;\n      y[G[i][j]] = j;\n    }\n  }\n  int r = 0;\n  for (int l = 1; l <= nm; ++l) {\n    while (r + 1 <= nm && add(r + 1, l, r + 1)) r++;\n    data d = sgt.qcnt(1, nm, l, r, 1);\n    if (d.min == 1) ans += d.cnt;\n    del(l, l, r);\n  }\n  printf(\"%lld\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint Read() {\n  int x = 0, flag = 1;\n  char ch = 0;\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') flag = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = (x << 3) + (x << 1) + ch - 48;\n    ch = getchar();\n  }\n  return x * flag;\n}\nvoid Write(long long x) {\n  if (x < 0) x = -x, putchar('-');\n  if (x > 9) Write(x / 10);\n  putchar(x % 10 + 48);\n}\nstruct spNode {\n  int fa, ch[2];\n  bool rev;\n} sp[200005];\nbool isrt(int x) { return sp[sp[x].fa].ch[0] != x && sp[sp[x].fa].ch[1] != x; }\nbool iden(int x) { return sp[sp[x].fa].ch[1] == x; }\nvoid con(int x, int son, int f) {\n  sp[son].fa = x;\n  sp[x].ch[f] = son;\n}\nvoid rotate(int x) {\n  int fa = sp[x].fa, fx = iden(x);\n  int grand = sp[fa].fa, ffa = iden(fa);\n  bool flag = isrt(fa);\n  con(fa, sp[x].ch[fx ^ 1], fx);\n  con(x, fa, fx ^ 1);\n  if (flag)\n    sp[x].fa = grand;\n  else\n    con(grand, x, ffa);\n}\nvoid pushdown(int x) {\n  int &lc = sp[x].ch[0], &rc = sp[x].ch[1];\n  if (sp[x].rev) {\n    swap(lc, rc);\n    sp[lc].rev ^= 1;\n    sp[rc].rev ^= 1;\n    sp[x].rev = 0;\n  }\n}\nvoid pushall(int x) {\n  if (!isrt(x)) pushall(sp[x].fa);\n  pushdown(x);\n}\nvoid splay(int x) {\n  if (!x) return;\n  pushall(x);\n  while (!isrt(x)) {\n    int fx = sp[x].fa;\n    if (isrt(fx))\n      rotate(x);\n    else if (iden(x) ^ iden(fx))\n      rotate(x), rotate(x);\n    else\n      rotate(fx), rotate(x);\n  }\n}\nvoid access(int x) {\n  for (int y = 0; x; y = x, x = sp[x].fa) splay(x), sp[x].ch[1] = y;\n}\nint findrt(int x) {\n  access(x);\n  splay(x);\n  pushdown(x);\n  while (sp[x].ch[0]) pushdown(x = sp[x].ch[0]);\n  splay(x);\n  return x;\n}\nvoid makert(int x) {\n  access(x);\n  splay(x);\n  sp[x].rev ^= 1;\n}\nvoid lk(int x, int y) {\n  makert(x);\n  sp[x].fa = y;\n}\nvoid ct(int x, int y) {\n  makert(x);\n  access(y);\n  splay(y);\n  sp[x].fa = sp[y].ch[0] = 0;\n}\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nint n, m;\nint a[1005][1005];\nstruct coNode {\n  int x, y;\n  coNode(int xx = 0, int yy = 0) {\n    x = xx;\n    y = yy;\n  }\n} co[1005 * 1005];\nbool on[1005][1005];\nstruct SegNode {\n  int mn, tag, tot;\n  SegNode(int a = 0, int b = 0, int c = 1) {\n    mn = a;\n    tag = b;\n    tot = c;\n  }\n  friend SegNode operator+(SegNode X, SegNode Y) {\n    return SegNode(min(X.mn, Y.mn), 0,\n                   (X.mn <= Y.mn) * X.tot + (X.mn >= Y.mn) * Y.tot);\n  }\n} Seg[200005 << 2];\nvoid pushdown(int p, int l, int r) {\n  int &t = Seg[p].tag;\n  if (t) {\n    Seg[p << 1].mn += t;\n    Seg[p << 1].tag += t;\n    Seg[p << 1 | 1].mn += t;\n    Seg[p << 1 | 1].tag += t;\n    t = 0;\n  }\n}\nvoid build(int l, int r, int p) {\n  Seg[p].tot = r - l + 1;\n  if (l == r) return;\n  int mid = (l + r) >> 1;\n  build(l, mid, p << 1);\n  build(mid + 1, r, p << 1 | 1);\n}\nvoid update(int l, int r, int p, int Aiml, int Aimr, int x) {\n  if (Aiml <= l && r <= Aimr) {\n    Seg[p].mn += x;\n    Seg[p].tag += x;\n    return;\n  }\n  pushdown(p, l, r);\n  int mid = (l + r) >> 1;\n  if (Aiml <= mid) update(l, mid, p << 1, Aiml, Aimr, x);\n  if (Aimr > mid) update(mid + 1, r, p << 1 | 1, Aiml, Aimr, x);\n  int tmp = Seg[p].tag;\n  Seg[p] = Seg[p << 1] + Seg[p << 1 | 1];\n  Seg[p].tag = tmp;\n}\nint query(int l, int r, int p, int Aiml, int Aimr) {\n  if (Aiml <= l && r <= Aimr) return (Seg[p].mn == 1) * Seg[p].tot;\n  pushdown(p, l, r);\n  int mid = (l + r) >> 1;\n  int tans = 0;\n  if (Aiml <= mid) tans += query(l, mid, p << 1, Aiml, Aimr);\n  if (Aimr > mid) tans += query(mid + 1, r, p << 1 | 1, Aiml, Aimr);\n  return tans;\n}\nbool check(int c) {\n  int x = co[c].x, y = co[c].y;\n  int f[5], cnt = 0;\n  for (int i = 0; i < 4; i++) {\n    int xx = x + dx[i], yy = y + dy[i];\n    if (on[xx][yy]) f[++cnt] = findrt((xx - 1) * m + yy);\n  }\n  for (int i = 1; i <= cnt; i++)\n    for (int j = i + 1; j <= cnt; j++)\n      if (f[i] == f[j]) return 0;\n  return 1;\n}\nvoid Lk(int c) {\n  int x = co[c].x, y = co[c].y;\n  for (int i = 0; i < 4; i++) {\n    int xx = x + dx[i], yy = y + dy[i];\n    if (on[xx][yy]) {\n      lk((x - 1) * m + y, (xx - 1) * m + yy);\n      update(1, n * m, 1, 1, a[xx][yy], -1);\n    }\n  }\n  on[x][y] = 1;\n}\nvoid Ct(int c) {\n  int x = co[c].x, y = co[c].y;\n  for (int i = 0; i < 4; i++) {\n    int xx = x + dx[i], yy = y + dy[i];\n    if (on[xx][yy]) ct((x - 1) * m + y, (xx - 1) * m + yy);\n  }\n  on[x][y] = 0;\n}\nint main() {\n  n = Read(), m = Read();\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) co[a[i][j] = Read()] = coNode(i, j);\n  build(1, n * m, 1);\n  int l = 1;\n  long long ans = 0;\n  for (int i = 1; i <= n * m; i++) {\n    for (; l <= i && !check(i); l++) Ct(l);\n    update(1, n * m, 1, l, i, 1);\n    Lk(i);\n    ans += query(1, n * m, 1, l, i);\n  }\n  Write(ans);\n  (putchar('\\n'));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid chkmax(T &x, T y) {\n  x = x > y ? x : y;\n}\ntemplate <typename T>\nvoid chkmin(T &x, T y) {\n  x = x > y ? y : x;\n}\ntemplate <typename T>\nvoid update(T &x, T y, T mod) {\n  x = x + y > mod ? x + y - mod : x + y;\n}\ntemplate <typename T>\nvoid multi(T &x, T y, T mod) {\n  x = 1ll * x * y % mod;\n}\nconst int INF = (1ll << 30);\ntemplate <typename T>\nvoid read(T &x) {\n  x = 0;\n  bool f = 1;\n  char ch;\n  do {\n    ch = getchar();\n    if (ch == '-') f = 0;\n  } while (ch > '9' || ch < '0');\n  do {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  } while (ch >= '0' && ch <= '9');\n  x = f ? x : -x;\n}\ntemplate <typename T>\nvoid write(T x) {\n  if (x < 0) x = ~x + 1, putchar('-');\n  if (x > 9) write(x / 10);\n  putchar(x % 10 + '0');\n}\nconst int N = 1000 + 7;\nconst int M = 2e5 + 7;\nnamespace LCT {\nstruct LCT {\n  int sz, fa, ch[2];\n  bool rev;\n} t[M];\ninline bool ntroot(int p) {\n  return t[t[p].fa].ch[0] == p || t[t[p].fa].ch[1] == p;\n}\ninline void pushup(int p) {\n  t[p].sz = t[(t[p].ch[0])].sz + t[(t[p].ch[1])].sz + 1;\n}\ninline void pushtag(int p) {\n  swap((t[p].ch[0]), (t[p].ch[1]));\n  t[p].rev ^= 1;\n}\ninline void pushdown(int p) {\n  if (t[p].rev) {\n    if ((t[p].ch[0])) pushtag((t[p].ch[0]));\n    if ((t[p].ch[1])) pushtag((t[p].ch[1]));\n    t[p].rev ^= 1;\n  }\n}\ninline void pushall(int p) {\n  if (ntroot(p)) pushall(t[p].fa);\n  pushdown(p);\n}\ninline void rotate(int x) {\n  int y = t[x].fa, z = t[y].fa, k = t[y].ch[1] == x;\n  if (ntroot(y)) t[z].ch[t[z].ch[1] == y] = x;\n  t[x].fa = z;\n  t[y].ch[k] = t[x].ch[k ^ 1];\n  if (t[x].ch[k ^ 1]) t[t[x].ch[k ^ 1]].fa = y;\n  t[y].fa = x;\n  t[x].ch[k ^ 1] = y;\n  pushup(y);\n  pushup(x);\n}\ninline void splay(int p) {\n  pushall(p);\n  while (ntroot(p)) {\n    int f = t[p].fa, g = t[f].fa;\n    if (ntroot(f)) rotate((t[f].ch[0] == p) == (t[g].ch[0] == f) ? f : p);\n    rotate(p);\n  }\n}\ninline void access(int x) {\n  for (int y = 0; x; y = x, x = t[x].fa) {\n    splay(x);\n    t[x].ch[1] = y;\n    pushup(x);\n  }\n}\ninline void makeroot(int p) {\n  access(p);\n  splay(p);\n  pushtag(p);\n}\ninline int findroot(int p) {\n  access(p);\n  splay(p);\n  while ((t[p].ch[0])) {\n    pushdown(p);\n    p = (t[p].ch[0]);\n  }\n  splay(p);\n  return p;\n}\ninline void split(int x, int y) {\n  makeroot(x);\n  access(y);\n  splay(y);\n}\ninline bool link(int x, int y) {\n  makeroot(x);\n  if (findroot(y) == x) return false;\n  t[x].fa = y;\n  return true;\n}\ninline bool cut(int x, int y) {\n  makeroot(x);\n  if (findroot(y) != x || t[y].fa != x || (t[y].ch[0])) return false;\n  t[y].fa = (t[x].ch[1]) = 0;\n  pushup(x);\n  return true;\n}\n}  // namespace LCT\nnamespace Segment_Tree {\nstruct Node {\n  int mn, cnt;\n};\nNode operator+(Node a, Node b) {\n  Node c;\n  c = (Node){0, 0};\n  c.mn = min(a.mn, b.mn);\n  if (c.mn == a.mn) c.cnt += a.cnt;\n  if (c.mn == b.mn) c.cnt += b.cnt;\n  return c;\n}\nstruct Segment_Tree {\n  int l, r, add;\n  Node x;\n} t[N * N];\ninline void pushdown(int p) {\n  t[(p << 1)].add += t[p].add;\n  t[(p << 1 | 1)].add += t[p].add;\n  t[(p << 1)].x.mn += t[p].add;\n  t[(p << 1 | 1)].x.mn += t[p].add;\n  t[p].add = 0;\n}\ninline void build(int p, int l, int r) {\n  t[p].l = l;\n  t[p].r = r;\n  t[p].x.cnt = t[p].r - t[p].l + 1;\n  if (l == r) return;\n  int mid = (t[p].l + t[p].r) >> 1;\n  build((p << 1), l, mid);\n  build((p << 1 | 1), mid + 1, r);\n}\ninline void modify(int p, int l, int r, int k) {\n  if (l <= t[p].l && t[p].r <= r) {\n    t[p].x.mn += k;\n    t[p].add += k;\n    return;\n  }\n  pushdown(p);\n  int mid = (t[p].l + t[p].r) >> 1;\n  if (l <= mid) modify((p << 1), l, r, k);\n  if (r > mid) modify((p << 1 | 1), l, r, k);\n  t[p].x = t[(p << 1)].x + t[(p << 1 | 1)].x;\n}\ninline Node query(int p, int l, int r) {\n  if (l <= t[p].l && t[p].r <= r) return t[p].x;\n  pushdown(p);\n  int mid = (t[p].l + t[p].r) >> 1;\n  if (r <= mid) return query((p << 1), l, r);\n  if (l > mid) return query((p << 1 | 1), l, r);\n  Node a = query((p << 1), l, r), b = query((p << 1 | 1), l, r);\n  return a + b;\n}\n}  // namespace Segment_Tree\nint n, m, val[N][N];\nint dx[] = {0, 1, -1, 0};\nint dy[] = {1, 0, 0, -1};\nvector<int> vec, esuf[M], epre[M];\nint main() {\n  read(n);\n  read(m);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) read(val[i][j]);\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      for (int k = 0; k < 4; k++) {\n        int x = i + dx[k], y = j + dy[k];\n        if (x < 1 || x > n || y < 1 || y > m) continue;\n        if (val[x][y] > val[i][j]) esuf[val[i][j]].push_back(val[x][y]);\n        if (val[x][y] < val[i][j]) epre[val[i][j]].push_back(val[x][y]);\n      }\n    }\n  }\n  Segment_Tree::build(1, 1, n * m);\n  int r = 0;\n  long long ans = 0;\n  for (int l = 1; l <= n * m; l++) {\n    bool flag = false;\n    for (int r1 = r + 1; r1 <= n * m; r1++) {\n      vec.clear();\n      for (int j = 0; j < epre[r1].size(); j++) {\n        int now = epre[r1][j];\n        if (now < l) continue;\n        if (!LCT::link(r1, now)) {\n          flag = true;\n          break;\n        }\n        vec.push_back(now);\n      }\n      if (flag) {\n        for (int j = 0; j < vec.size(); j++) LCT::cut(r1, vec[j]);\n        break;\n      }\n      ++r;\n      int tot = 0;\n      for (int j = 0; j < epre[r1].size(); j++) {\n        if (epre[r1][j] < l) continue;\n        LCT::link(r1, epre[r1][j]);\n        tot++;\n      }\n      Segment_Tree::modify(1, r, r, r - l + 1);\n      Segment_Tree::modify(1, r, n * m, -tot);\n    }\n    Segment_Tree::Node t = Segment_Tree::query(1, l, r);\n    if (t.mn == 1) ans += t.cnt;\n    for (int j = 0; j < esuf[l].size(); j++) {\n      if (esuf[l][j] > r) continue;\n      LCT::cut(l, esuf[l][j]);\n      Segment_Tree::modify(1, esuf[l][j], n * m, 1);\n    }\n    Segment_Tree::modify(1, l, r, -1);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing nagai = long long;\nconst int N = 1 << 18;\nint fa[N], sz[N];\nint flag[N];\nint ch[N][2];\nint chnum(int x) { return ch[fa[x]][1] == x; }\nint is_r(int x) { return !(ch[fa[x]][1] == x || ch[fa[x]][0] == x); }\nvoid push(int x) {\n  if (flag[x]) {\n    swap(ch[x][0], ch[x][1]);\n    flag[ch[x][0]] ^= 1, flag[ch[x][1]] ^= 1;\n    flag[x] = 0;\n  }\n}\nvoid rev(int x) {\n  flag[x] = true;\n  push(x);\n}\nvoid update(int x) {\n  if (x) sz[x] = 1 + sz[ch[x][0]] + sz[ch[x][1]];\n}\nvoid attach(int x, int y, int side) {\n  fa[x] = y;\n  ch[y][side] = x;\n}\nvoid check(int x) { assert(sz[x] == sz[ch[x][0]] + sz[ch[x][1]] + 1); }\nvoid rotate(int x) {\n  int y = fa[x], z = fa[y], b = chnum(x), t = ch[x][b ^ 1];\n  int c = chnum(fa[x]);\n  if (!is_r(y))\n    attach(x, z, c);\n  else\n    fa[x] = z;\n  attach(y, x, b ^ 1);\n  attach(t, y, b);\n  update(y);\n  update(x);\n}\nvoid splay(int x) {\n  static int mem[N];\n  static int ptr = 0;\n  int y = x;\n  while (!is_r(y)) mem[ptr++] = y, y = fa[y];\n  mem[ptr++] = y;\n  while (ptr > 0) push(mem[ptr - 1]), --ptr;\n  while (!is_r(x)) {\n    int y = fa[x];\n    if (!is_r(fa[x])) rotate(chnum(x) == chnum(y) ? y : x);\n    rotate(x);\n  }\n}\nvoid print(int x) {\n  if (!x) return;\n  check(x);\n  print(ch[x][0]);\n  cerr << x << ' ';\n  print(ch[x][1]);\n}\nvoid access(int x) {\n  for (int dwn = 0; x; dwn = x, x = fa[x]) splay(x), ch[x][1] = dwn, update(x);\n}\nvoid makeroot(int x) { access(x), splay(x), rev(x); }\nbool is_conn(int x, int y) {\n  if (x == y) return 1;\n  makeroot(x);\n  makeroot(y);\n  return !(fa[x] == 0 && fa[y] == 0);\n}\nvoid cut(int x, int y) {\n  makeroot(x);\n  access(y);\n  splay(y);\n  assert(ch[y][0] == x);\n  ch[y][0] = fa[x] = 0;\n  update(y);\n}\nvoid link(int x, int y) {\n  makeroot(x);\n  makeroot(y);\n  assert(fa[x] == 0);\n  fa[x] = y;\n}\nint n, m;\nconst int S = 1010;\nint matr[S][S];\nint nocyc[N];\nint kek(pair<int, int> mem) { return mem.first * m + mem.second + 1; }\nvector<int> dx = {0, 1, 0, -1}, dy = {1, 0, -1, 0};\nbool added[N];\nvector<int> neigh(int a) {\n  --a;\n  int x = a / m, y = a % m;\n  vector<int> ans;\n  for (int i = 0; i < 4; ++i) {\n    int x1 = x + dx[i], y1 = y + dy[i];\n    if (x1 >= 0 && y1 >= 0 && x1 < n && y1 < m && added[x1 * m + y1 + 1])\n      ans.push_back(x1 * m + y1 + 1);\n  }\n  return ans;\n}\nbool check(pair<int, int> a) {\n  int x = kek(a);\n  auto ne = neigh(x);\n  for (int i = 0; i < ne.size(); ++i)\n    for (int j = 0; j < i; ++j)\n      if (is_conn(ne[i], ne[j])) return false;\n  return true;\n}\nvoid add(pair<int, int> a) {\n  int x = kek(a);\n  added[x] = true;\n  for (int y : neigh(x)) {\n    assert(!is_conn(x, y));\n    link(x, y);\n  }\n}\nvoid rem(pair<int, int> a) {\n  int x = kek(a);\n  added[x] = false;\n  for (int y : neigh(x)) {\n    assert(is_conn(x, y));\n    cut(x, y);\n  }\n}\nconst int oo = 1e9;\nint C = 1;\nstruct it {\n  int sum[2 * N], mn[2 * N], mn1[2 * N], cntmn[2 * N], cntmn1[2 * N];\n  it() {\n    for (int i = 2 * N - 1; i >= 0; --i) {\n      if (i < n)\n        update(i);\n      else\n        sum[i] = 0, mn[i] = 0, mn1[i] = oo, cntmn[i] = 1, cntmn1[i] = 0;\n    }\n  }\n  void update(int i) {\n    int le = 2 * i;\n    int ri = 2 * i + 1;\n    sum[i] = sum[le] + sum[ri];\n    int kek[4] = {mn[le], mn1[le], sum[le] + mn[ri], sum[le] + mn1[ri]};\n    mn[i] = oo;\n    mn1[i] = oo;\n    for (int x : kek)\n      if (x < mn[i])\n        mn1[i] = mn[i], mn[i] = x;\n      else if (x != mn[i] && x < mn1[i])\n        mn1[i] = x;\n    cntmn[i] = 0;\n    cntmn1[i] = 0;\n    if (mn[le] == mn[i]) cntmn[i] += cntmn[le];\n    if (mn[le] == mn1[i])\n      cntmn1[i] += cntmn[le];\n    else if (mn1[le] == mn1[i])\n      cntmn1[i] += cntmn1[le];\n    if (sum[le] + mn[ri] == mn[i]) cntmn[i] += cntmn[ri];\n    if (sum[le] + mn[ri] == mn1[i])\n      cntmn1[i] += cntmn[ri];\n    else if (sum[le] + mn1[ri] == mn1[i])\n      cntmn1[i] += cntmn1[ri];\n  }\n  void add(int i, int ch) {\n    i += N;\n    sum[i] += ch;\n    mn[i] = sum[i];\n    mn1[i] = sum[i];\n    cntmn[i] = 1;\n    cntmn1[i] = 1;\n    while (i > 1) update(i >> 1), i >>= 1;\n  }\n  int get(int x, int l, int r, int ql, int qr, int cur) {\n    if (cur + mn[x] > C) return 0;\n    if (l >= qr || ql >= r) return 0;\n    if (ql <= l && r <= qr)\n      if (cur + mn[x] == C)\n        return cntmn[x];\n      else {\n        return 0;\n      }\n    int m = (l + r) / 2;\n    return get(x * 2, l, m, ql, qr, cur) +\n           get(x * 2 + 1, m, r, ql, qr, cur + sum[x * 2]);\n  }\n} myit;\nmt19937 rnd(228);\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  n = 1000, m = 200;\n  cin >> n >> m;\n  vector<int> kekos(n * m);\n  iota(kekos.begin(), kekos.end(), 1);\n  shuffle(kekos.begin(), kekos.end(), rnd);\n  for (int i = 0; i < n * m; ++i) sz[i] = 1;\n  int t = 0;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j) {\n      matr[i][j] = kekos[t++];\n      cin >> matr[i][j];\n      --matr[i][j];\n    }\n  vector<pair<int, int>> ord;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j) ord.emplace_back(i, j);\n  sort(ord.begin(), ord.end(), [&](pair<int, int> a, pair<int, int> b) {\n    return matr[a.first][a.second] < matr[b.first][b.second];\n  });\n  int cur = ord.size();\n  for (int i = ord.size() - 1; i >= 0; --i) {\n    while (!check(ord[i])) rem(ord[--cur]);\n    nocyc[i] = cur;\n    add(ord[i]);\n  }\n  memset(added, 0, sizeof added);\n  nagai ansich = 0;\n  for (int i = ord.size() - 1; i >= 0; --i) {\n    int x = ord[i].first, y = ord[i].second;\n    myit.add(i, 1);\n    for (int k = 0; k < 4; ++k) {\n      int x1 = x + dx[k], y1 = y + dy[k];\n      if (x1 >= 0 && y1 >= 0 && x1 < n && y1 < m && added[matr[x1][y1]])\n        myit.add(matr[x1][y1], -1);\n    }\n    added[i] = true;\n    int mem = myit.get(1, 0, N, i, nocyc[i], 0);\n    ansich += mem;\n  }\n  cout << ansich << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\nnamespace ywy {\ninline int get() {\n  int n = 0;\n  char c;\n  while ((c = getchar()) || 23333) {\n    if (c >= '0' && c <= '9') break;\n    if (c == '-') goto s;\n  }\n  n = c - '0';\n  while ((c = getchar()) || 23333) {\n    if (c >= '0' && c <= '9')\n      n = n * 10 + c - '0';\n    else\n      return (n);\n  }\ns:\n  while ((c = getchar()) || 23333) {\n    if (c >= '0' && c <= '9')\n      n = n * 10 - c + '0';\n    else\n      return (n);\n  }\n}\nvector<int> vec[200001];\nint v[2001][2001], lx[4] = {1, -1, 0, 0}, ly[4] = {0, 0, 1, -1};\nint ch[200001][2], fa[200001], stk[200001];\nunsigned char bj[200001];\ntypedef struct _n {\n  int minn;\n  int cnt;\n  friend _n operator+(const _n &a, const _n &b) {\n    _n c;\n    c.minn = min(a.minn, b.minn);\n    c.cnt = 0;\n    if (a.minn == c.minn) c.cnt = a.cnt;\n    if (b.minn == c.minn) c.cnt += b.cnt;\n    return (c);\n  }\n} node;\nnode data[1000001];\nint adds[1000001];\ninline void down(int tree) {\n  if (bj[tree])\n    bj[tree] = 0, bj[ch[tree][0]] ^= 1, bj[ch[tree][1]] ^= 1,\n    swap(ch[tree][0], ch[tree][1]);\n}\ninline void pushdown(int tree) {\n  if (!adds[tree]) return;\n  adds[(tree << 1)] += adds[tree];\n  adds[((tree << 1) | 1)] += adds[tree];\n  data[(tree << 1)].minn += adds[tree];\n  data[((tree << 1) | 1)].minn += adds[tree];\n  adds[tree] = 0;\n}\ninline void xuan(int me) {\n  int tree = fa[me], cjr = fa[tree];\n  down(cjr);\n  down(tree);\n  down(me);\n  int op = (me == ch[fa[me]][1]), ls = ch[me][op ^ 1];\n  ch[tree][op] = ls;\n  fa[ls] = tree;\n  ch[me][op ^ 1] = tree;\n  if (!(tree != ch[fa[tree]][0] && tree != ch[fa[tree]][1]))\n    ch[cjr][(tree == ch[fa[tree]][1])] = me;\n  fa[tree] = me;\n  fa[me] = cjr;\n}\ninline void splay(int tree) {\n  if ((tree != ch[fa[tree]][0] && tree != ch[fa[tree]][1])) {\n    down(tree);\n    return;\n  }\n  int sp = 0, tmp = tree;\n  while (!(tmp != ch[fa[tmp]][0] && tmp != ch[fa[tmp]][1]))\n    stk[sp] = tmp, sp++, tmp = fa[tmp];\n  down(tmp);\n  while (sp) sp--, down(stk[sp]);\n  while (!(tree != ch[fa[tree]][0] && tree != ch[fa[tree]][1])) {\n    int cjr = fa[tree];\n    if (!(cjr != ch[fa[cjr]][0] && cjr != ch[fa[cjr]][1]))\n      xuan(((cjr == ch[fa[cjr]][1]) == (tree == ch[fa[tree]][1])) ? cjr : tree);\n    xuan(tree);\n  }\n}\ninline void access(int tree) {\n  splay(tree);\n  down(tree);\n  ch[tree][1] = 0;\n  while (fa[tree]) {\n    int cjr = fa[tree];\n    splay(cjr);\n    down(cjr);\n    ch[cjr][1] = tree;\n    splay(tree);\n  }\n}\ninline void makeroot(int tree) {\n  access(tree);\n  splay(tree);\n  bj[tree] ^= 1;\n}\ninline int findroot(int tree) {\n  access(tree);\n  splay(tree);\n  down(tree);\n  while (ch[tree][0]) tree = ch[tree][0], down(tree);\n  splay(tree);\n  return (tree);\n}\ninline void link(int a, int b) {\n  makeroot(a);\n  fa[a] = b;\n}\ninline void cut(int a, int b) {\n  makeroot(a);\n  access(b);\n  splay(a);\n  down(a);\n  fa[b] = ch[a][1] = 0;\n}\nnode query(int rl, int rr, int l, int r, int tree) {\n  if (rl == l && rr == r) return (data[tree]);\n  int mid = (l + r) >> 1;\n  pushdown(tree);\n  if (rl > mid) return (query(rl, rr, mid + 1, r, ((tree << 1) | 1)));\n  if (rr <= mid) return (query(rl, rr, l, mid, (tree << 1)));\n  return (query(rl, mid, l, mid, (tree << 1)) +\n          query(mid + 1, rr, mid + 1, r, ((tree << 1) | 1)));\n}\nvoid add(int rl, int rr, int l, int r, int tree, int x) {\n  if (rl == l && rr == r) {\n    adds[tree] += x;\n    data[tree].minn += x;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  pushdown(tree);\n  if (rl > mid)\n    add(rl, rr, mid + 1, r, ((tree << 1) | 1), x);\n  else {\n    if (rr <= mid)\n      add(rl, rr, l, mid, (tree << 1), x);\n    else {\n      add(rl, mid, l, mid, (tree << 1), x);\n      add(mid + 1, rr, mid + 1, r, ((tree << 1) | 1), x);\n    }\n  }\n  data[tree] = data[(tree << 1)] + data[((tree << 1) | 1)];\n}\nint links[200001];\nvoid build(int l, int r, int tree) {\n  if (l == r) {\n    data[tree].minn = 0;\n    data[tree].cnt = 1;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  build(l, mid, (tree << 1));\n  build(mid + 1, r, ((tree << 1) | 1));\n  data[tree] = data[(tree << 1)] + data[((tree << 1) | 1)];\n}\nvoid ywymain() {\n  int n = get(), m = get();\n  for (register int i = 1; i <= n; i++) {\n    for (register int j = 1; j <= m; j++) v[i][j] = get();\n  }\n  for (register int i = 1; i <= n; i++) {\n    for (register int j = 1; j <= m; j++) {\n      for (register int k = 0; k < 4; k++) {\n        int ix = j + lx[k], iy = i + ly[k];\n        if (ix < 1 || iy < 1 || ix > m || iy > n) continue;\n        if (v[i][j] > v[iy][ix])\n          vec[v[i][j]].push_back(v[iy][ix]), vec[v[iy][ix]].push_back(v[i][j]);\n      }\n    }\n  }\n  n *= m;\n  build(1, n, 1);\n  add(1, n, 1, n, 1, 1);\n  int ptr = 1;\n  long long ans = 0;\n  for (register int i = 1; i <= n; i++) {\n    while (ptr < n) {\n      int sp = 0;\n      for (register int j = 0; j < vec[ptr + 1].size(); j++) {\n        if (vec[ptr + 1][j] < i || vec[ptr + 1][j] > ptr + 1) continue;\n        makeroot(ptr + 1);\n        if (findroot(vec[ptr + 1][j]) == ptr + 1) {\n          while (sp) sp--, cut(ptr + 1, links[sp]);\n          goto s;\n        }\n        link(ptr + 1, vec[ptr + 1][j]);\n        links[sp] = vec[ptr + 1][j], sp++;\n      }\n      ptr++;\n      for (register int j = 0; j < vec[ptr].size(); j++) {\n        if (vec[ptr][j] >= i && vec[ptr][j] < ptr) add(ptr, n, 1, n, 1, -1);\n      }\n      add(ptr, n, 1, n, 1, 1);\n    }\n  s:;\n    node cjr = query(i, ptr, 1, n, 1);\n    if (cjr.minn == 1) ans += cjr.cnt;\n    add(i, n, 1, n, 1, -1);\n    for (register int j = 0; j < vec[i].size(); j++) {\n      if (vec[i][j] >= i && vec[i][j] <= ptr) {\n        add(vec[i][j], n, 1, n, 1, 1);\n        cut(i, vec[i][j]);\n      }\n    }\n  }\n  cout << ans << endl;\n}\n}  // namespace ywy\nint main() {\n  ywy::ywymain();\n  return (0);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint read() {\n  int ans = 0;\n  char x = getchar();\n  while (!isdigit(x)) x = getchar();\n  while (isdigit(x)) ans = ans * 10 + x - '0', x = getchar();\n  return ans;\n}\nint mp[1005][1005], n, m;\npair<int, int> pos[200005];\nstruct lct {\n  struct node {\n    int rev, fa, son[2], val, minn;\n  } tree[200005];\n  int stck[200005], top;\n  int ls(int p) { return tree[p].son[0]; }\n  int rs(int p) { return tree[p].son[1]; }\n  int fa(int p) { return tree[p].fa; }\n  int which(int p) {\n    if (rs(fa(p)) == p) return 1;\n    if (ls(fa(p)) == p) return 0;\n    return -1;\n  }\n  void pushup(int p) {\n    tree[p].minn = min(tree[p].val, min(tree[ls(p)].minn, tree[rs(p)].minn));\n  }\n  void init() {\n    tree[0].val = 1e9;\n    tree[0].minn = 1e9;\n    for (int i = 1; i <= n * m; i++) tree[i].val = i, pushup(i);\n  }\n  void pushdown(int p) {\n    if (tree[p].rev) {\n      tree[ls(p)].rev ^= 1;\n      tree[rs(p)].rev ^= 1;\n      swap(tree[p].son[0], tree[p].son[1]);\n      tree[p].rev = 0;\n    }\n  }\n  void rotate(int p) {\n    int f1 = fa(p), f2 = fa(f1);\n    pushdown(f2);\n    pushdown(f1);\n    pushdown(p);\n    int now1 = which(p), now2 = which(f1);\n    tree[f1].son[now1] = tree[p].son[now1 ^ 1];\n    tree[tree[p].son[now1 ^ 1]].fa = f1;\n    tree[p].son[now1 ^ 1] = f1;\n    tree[f1].fa = p;\n    tree[p].fa = f2;\n    if (now2 != -1) tree[f2].son[now2] = p;\n    pushup(f1);\n    pushup(p);\n    pushup(f2);\n  }\n  void splay(int p) {\n    int pp = p;\n    while (which(p) != -1) stck[++top] = p, p = fa(p);\n    stck[++top] = p;\n    while (top) pushdown(stck[top--]);\n    p = pp;\n    while (which(p) != -1) {\n      int f = fa(p);\n      if (which(f) != -1) {\n        if (which(f) == which(p))\n          rotate(f);\n        else\n          rotate(p);\n      }\n      rotate(p);\n    }\n  }\n  void access(int p) {\n    int tmp = 0;\n    while (p) {\n      splay(p);\n      tree[p].son[1] = tmp;\n      pushup(p);\n      tmp = p;\n      p = fa(p);\n    }\n  }\n  void makeroot(int p) {\n    access(p);\n    splay(p);\n    tree[p].rev ^= 1;\n  }\n  int findroot(int p) {\n    access(p);\n    splay(p);\n    pushdown(p);\n    while (ls(p)) p = ls(p), pushdown(p);\n    splay(p);\n    return p;\n  }\n  void link(int x, int y) {\n    makeroot(x);\n    if (findroot(y) != x) tree[x].fa = y;\n  }\n  void cut(int x, int y) {\n    makeroot(x);\n    if (findroot(y) == x && !ls(y) && tree[x].son[1] == y) {\n      tree[x].son[1] = tree[y].fa = 0;\n      pushup(x);\n    }\n  }\n} LCT;\nstruct segmenttree {\n  int tree[800005], lazy_tag[800005], cnt[800005];\n  int ls(int p) { return p << 1; }\n  int rs(int p) { return p << 1 | 1; }\n  void pushup(int p) {\n    tree[p] = tree[ls(p)];\n    cnt[p] = cnt[ls(p)];\n    if (tree[rs(p)] < tree[ls(p)]) tree[p] = tree[rs(p)], cnt[p] = 0;\n    if (tree[rs(p)] == tree[p]) cnt[p] += cnt[rs(p)];\n  }\n  void build(int l, int r, int p) {\n    if (l == r) {\n      tree[p] = 0;\n      cnt[p] = 1;\n      return;\n    }\n    int mid = (l + r) >> 1;\n    build(l, mid, ls(p));\n    build(mid + 1, r, rs(p));\n    pushup(p);\n  }\n  void pushdown(int p) {\n    int w = lazy_tag[p];\n    lazy_tag[ls(p)] += w;\n    lazy_tag[rs(p)] += w;\n    tree[ls(p)] += w;\n    tree[rs(p)] += w;\n    lazy_tag[p] = 0;\n  }\n  void update(int l, int r, int ll, int rr, int p, int val) {\n    if (ll <= l && r <= rr) {\n      tree[p] += val;\n      lazy_tag[p] += val;\n      return;\n    }\n    int mid = (l + r) >> 1;\n    pushdown(p);\n    if (ll <= mid) update(l, mid, ll, rr, ls(p), val);\n    if (rr > mid) update(mid + 1, r, ll, rr, rs(p), val);\n    pushup(p);\n  }\n  pair<int, int> query(int l, int r, int ll, int rr, int p) {\n    if (ll <= l && r <= rr) {\n      return make_pair(tree[p], cnt[p]);\n    }\n    pushdown(p);\n    int mid = (l + r) >> 1;\n    pair<int, int> ans = make_pair(1e9, 0), tmp1 = make_pair(1e9, 0),\n                   tmp2 = make_pair(1e9, 0);\n    if (ll <= mid) tmp1 = query(l, mid, ll, rr, ls(p));\n    if (rr > mid) tmp2 = query(mid + 1, r, ll, rr, rs(p));\n    if (tmp1.first < ans.first) ans.first = tmp1.first, ans.second = 0;\n    if (tmp1.first == ans.first) ans.second += tmp1.second;\n    if (tmp2.first < ans.first) ans.first = tmp2.first, ans.second = 0;\n    if (tmp2.first == ans.first) ans.second += tmp2.second;\n    return ans;\n  }\n} tree;\nint dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nvector<int> V[200005];\nint main() {\n  n = read(), m = read();\n  LCT.init();\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) mp[i][j] = read();\n  int pos = 0;\n  tree.build(1, n * m, 1);\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      for (int k = 0; k < 4; k++) {\n        int x = i + dx[k], y = j + dy[k];\n        if (x < 1 || y < 1 || x > n || y > m) continue;\n        V[mp[i][j]].push_back(mp[x][y]);\n      }\n      sort(V[mp[i][j]].begin(), V[mp[i][j]].end());\n    }\n  }\n  long long ans = 0;\n  for (int i = 1; i <= n * m; i++) {\n    for (int j = pos + 1; j <= n * m; j++) {\n      vector<int> tmp;\n      for (int k = 0; k < V[j].size(); k++) {\n        if (V[j][k] < i || V[j][k] > j) continue;\n        tmp.push_back(V[j][k]);\n      }\n      sort(tmp.begin(), tmp.end());\n      bool flag = 0;\n      for (int k = 0; k < tmp.size(); k++) {\n        LCT.makeroot(j);\n        if (LCT.findroot(tmp[k]) == j) {\n          flag = 1;\n          break;\n        }\n        LCT.link(tmp[k], j);\n      }\n      for (int k = 0; k < tmp.size(); k++) {\n        LCT.cut(tmp[k], j);\n      }\n      if (flag) break;\n      pos = j;\n      int tot = 0;\n      for (int k = 0; k < V[j].size(); k++) {\n        if (V[j][k] < i || V[j][k] > j) continue;\n        tot++;\n        LCT.link(j, V[j][k]);\n      }\n      tree.update(1, n * m, j, j, 1, j - i + 1);\n      tree.update(1, n * m, j, n * m, 1, -tot);\n    }\n    pair<int, int> tmp = tree.query(1, n * m, i, pos, 1);\n    if (tmp.first == 1) ans += tmp.second;\n    for (int j = 0; j < V[i].size(); j++) {\n      if (V[i][j] >= i && V[i][j] <= pos) {\n        LCT.cut(i, V[i][j]);\n        tree.update(1, n * m, V[i][j], n * m, 1, 1);\n      }\n    }\n    tree.update(1, n * m, i, pos, 1, -1);\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, a[1010][1010], posx[200010], posy[200010], px[4] = {1, 0, -1, 0},\n                                                     py[4] = {0, 1, 0, -1};\nlong long ans = 0;\nstruct pnt {\n  pnt *f, *s[2];\n  bool rev;\n  pnt() : f(NULL), s(), rev(false) {}\n} p[200010];\nstruct tree {\n  int l, r, c, num, lz;\n  tree *lc, *rc;\n  tree(int l, int r)\n      : l(l), r(r), c(0), num(r - l + 1), lz(0), lc(NULL), rc(NULL) {}\n} * root;\ninline bool is_root(pnt *x) {\n  return !x->f || x->f->s[0] != x && x->f->s[1] != x;\n}\nvoid pushdown(pnt *x) {\n  if (x->rev) {\n    swap(x->s[0], x->s[1]);\n    if (x->s[0]) x->s[0]->rev ^= 1;\n    if (x->s[1]) x->s[1]->rev ^= 1;\n    x->rev = 0;\n  }\n}\nvoid rot(pnt *x) {\n  pnt *f = x->f, *ff = f->f;\n  int w = x == f->s[0];\n  f->s[w ^ 1] = x->s[w];\n  if (x->s[w]) x->s[w]->f = f;\n  if (!is_root(f)) ff->s[f == ff->s[1]] = x;\n  x->f = ff;\n  x->s[w] = f;\n  f->f = x;\n}\nvoid splay(pnt *x) {\n  static stack<pnt *> sta;\n  pnt *hh = x;\n  while (!is_root(hh)) sta.push(hh), hh = hh->f;\n  sta.push(hh);\n  while (!sta.empty()) pushdown(sta.top()), sta.pop();\n  while (!is_root(x)) {\n    pnt *f = x->f, *ff = f->f;\n    if (is_root(f))\n      rot(x);\n    else if ((x == f->s[0]) == (f == ff->s[0]))\n      rot(f), rot(x);\n    else\n      rot(x), rot(x);\n  }\n}\nvoid print(pnt *i) {\n  printf(\"i: %d f: %d s[0]: %d s[1]: %d rev: %d\\n\", i - p, i->f ? i->f - p : 0,\n         i->s[0] ? i->s[0] - p : 0, i->s[1] ? i->s[1] - p : 0, i->rev);\n}\nvoid access(pnt *x) {\n  pnt *last = NULL;\n  while (x) {\n    splay(x);\n    x->s[1] = last;\n    last = x;\n    x = x->f;\n  }\n}\npnt *get_root(pnt *x) {\n  access(x);\n  splay(x);\n  while (x->s[0]) x = x->s[0];\n  return x;\n}\nvoid make_root(pnt *x) {\n  access(x);\n  splay(x);\n  x->rev ^= 1;\n}\nvoid link(pnt *x, pnt *y) {\n  make_root(y);\n  y->f = x;\n}\nvoid split(pnt *x, pnt *y) {\n  make_root(x);\n  access(y);\n  splay(y);\n}\nvoid cut(pnt *x, pnt *y) {\n  if (get_root(x) != get_root(y)) {\n    return;\n  }\n  split(x, y);\n  if (y->s[0] != x || x->s[1]) return;\n  y->s[0] = NULL;\n  x->f = NULL;\n}\ntree *bt(int l, int r) {\n  tree *i = new tree(l, r);\n  if (l < r) {\n    int md = l + r >> 1;\n    i->lc = bt(l, md);\n    i->rc = bt(md + 1, r);\n  }\n  return i;\n}\nvoid pushdown(tree *i) {\n  if (i->lz) {\n    i->lc->lz += i->lz;\n    i->lc->c += i->lz;\n    i->rc->lz += i->lz;\n    i->rc->c += i->lz;\n    i->lz = 0;\n  }\n}\nvoid pushup(tree *i) {\n  if (i->lc->c < i->rc->c)\n    i->c = i->lc->c, i->num = i->lc->num;\n  else if (i->lc->c == i->rc->c)\n    i->c = i->lc->c, i->num = i->lc->num + i->rc->num;\n  else\n    i->c = i->rc->c, i->num = i->rc->num;\n}\nvoid chg(tree *i, int l, int r, int c) {\n  if (l > r) return;\n  if (i->l == l && i->r == r) {\n    i->lz += c;\n    i->c += c;\n    return;\n  }\n  pushdown(i);\n  int md = i->l + i->r >> 1;\n  if (r <= md)\n    chg(i->lc, l, r, c);\n  else if (l > md)\n    chg(i->rc, l, r, c);\n  else\n    chg(i->lc, l, md, c), chg(i->rc, md + 1, r, c);\n  pushup(i);\n}\nint get(tree *i, int l, int r) {\n  if (i->l == l && i->r == r) return i->c == 1 ? i->num : 0;\n  pushdown(i);\n  int md = i->l + i->r >> 1;\n  if (r <= md)\n    return get(i->lc, l, r);\n  else if (l > md)\n    return get(i->rc, l, r);\n  else\n    return get(i->lc, l, md) + get(i->rc, md + 1, r);\n}\nvoid erase(int x) {\n  for (int i = 0; i < 4; i++) {\n    int xx = posx[x] + px[i], yy = posy[x] + py[i];\n    if (xx > 0 && xx <= n && yy > 0 && yy <= m) {\n      int y = a[xx][yy];\n      cut(p + x, p + y);\n    }\n  }\n}\nvoid print(tree *i) {\n  if (!i) return;\n  printf(\"l: %d r: %d c: %d num: %d lz: %d\\n\", i->l, i->r, i->c, i->num, i->lz);\n  print(i->lc);\n  print(i->rc);\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) {\n      scanf(\"%d\", &a[i][j]);\n      posx[a[i][j]] = i;\n      posy[a[i][j]] = j;\n    }\n  root = bt(1, n * m);\n  for (int l = 1, r = 1; r <= n * m; r++) {\n    for (int i = 0; i < 4; i++) {\n      int x = posx[r] + px[i], y = posy[r] + py[i];\n      if (x > 0 && x <= n && y > 0 && y <= m) {\n        int u = a[x][y];\n        if (u > r || u < l) continue;\n        while (get_root(p + r) == get_root(p + u)) {\n          erase(l++);\n        }\n        if (u >= l) {\n          link(p + r, p + u);\n          chg(root, l, u, -1);\n        }\n      }\n    }\n    chg(root, l, r, 1);\n    ans += get(root, l, r);\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing std::sort;\nconst int MAXN = 2 * 1e5 + 50;\nint c[2][MAXN], f[MAXN];\nbool rev[MAXN];\ninline void pushdown(int x) {\n  if (rev[x]) {\n    rev[c[0][x]] ^= 1, rev[c[1][x]] ^= 1;\n    c[0][x] ^= c[1][x] ^= c[0][x] ^= c[1][x];\n    rev[x] = 0;\n  }\n}\ninline bool isroot(int x) {\n  return (!(c[0][f[x]] == x || c[1][f[x]] == x) || f[x] == 0);\n}\ninline bool get(int x) { return c[1][f[x]] == x; }\ninline void rotate(int x) {\n  bool r = get(x), rf = get(f[x]);\n  int y = f[x], z = f[y], a = c[!r][x];\n  f[x] = z;\n  if (!isroot(y)) c[rf][z] = x;\n  f[y] = x, c[!r][x] = y;\n  f[a] = y, c[r][y] = a;\n}\ninline void pushall(int x) {\n  if (!isroot(x)) pushall(f[x]);\n  pushdown(x);\n}\ninline void splay(int x) {\n  pushall(x);\n  for (; !isroot(x); rotate(x))\n    if (!isroot(f[x])) rotate((get(f[x]) == get(x)) ? f[x] : x);\n}\ninline void access(int x) {\n  for (int pre = 0; x; pre = x, x = f[x]) {\n    splay(x);\n    c[1][x] = pre;\n  }\n}\ninline void setroot(int x) {\n  access(x), splay(x);\n  rev[x] = 1;\n}\ninline bool connected(int x, int y) {\n  if (x == y) return 1;\n  access(x), splay(x);\n  access(y), splay(y);\n  return f[x] != 0;\n}\ninline int findroot(int x) {\n  access(x), splay(x);\n  while (c[0][x]) x = c[0][x], pushdown(x);\n  return x;\n}\ninline bool connected2(int x, int y) {\n  if (findroot(x) == findroot(y))\n    return 1;\n  else\n    return 0;\n}\ninline void cut(int x, int y) {\n  setroot(x), access(y), splay(x);\n  c[1][x] = f[y] = 0;\n}\ninline void link(int x, int y) {\n  setroot(x);\n  f[x] = y;\n}\nint N = 1, min[3 * MAXN], cnt[3 * MAXN], det[3 * MAXN];\nbool lazy[3 * MAXN];\ninline void pushupSeg(int v) {\n  if (min[v << 1] == min[(v << 1) | 1]) {\n    min[v] = min[v << 1];\n    cnt[v] = cnt[v << 1] + cnt[(v << 1) | 1];\n  } else if (min[v << 1] < min[(v << 1) | 1])\n    min[v] = min[v << 1], cnt[v] = cnt[v << 1];\n  else\n    min[v] = min[(v << 1) | 1], cnt[v] = cnt[(v << 1) | 1];\n}\ninline void pushdownSeg(int v) {\n  if (lazy[v]) {\n    min[v << 1] += det[v], min[(v << 1) | 1] += det[v];\n    det[v << 1] += det[v], det[(v << 1) | 1] += det[v];\n    lazy[v << 1] = lazy[(v << 1) | 1] = 1;\n    lazy[v] = 0;\n    det[v] = 0;\n  }\n}\ninline void updata(int l, int r, int d, int v = 1, int nl = 1, int nr = N) {\n  if (l > r) return;\n  if (l == nl && r == nr) {\n    min[v] += d;\n    det[v] += d;\n    lazy[v] = 1;\n    return;\n  }\n  pushdownSeg(v);\n  int mid = (nl + nr) >> 1;\n  if (r <= mid)\n    updata(l, r, d, v << 1, nl, mid);\n  else if (l > mid)\n    updata(l, r, d, (v << 1) | 1, mid + 1, nr);\n  else\n    updata(l, mid, d, v << 1, nl, mid),\n        updata(mid + 1, r, d, (v << 1) | 1, mid + 1, nr);\n  pushupSeg(v);\n}\ninline int query(int l, int r, int v = 1, int nl = 1, int nr = N) {\n  if (l == nl && r == nr) {\n    if (min[v] != 1)\n      return 0;\n    else\n      return cnt[v];\n  }\n  pushdownSeg(v);\n  int mid = (nl + nr) >> 1;\n  if (r <= mid)\n    return query(l, r, v << 1, nl, mid);\n  else if (l > mid)\n    return query(l, r, (v << 1) | 1, mid + 1, nr);\n  else\n    return query(l, mid, v << 1, nl, mid) +\n           query(mid + 1, r, (v << 1) | 1, mid + 1, nr);\n}\nint posx[MAXN], posy[MAXN], dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\nint map[2000][2000], n, m;\ninline int read() {\n  int x = 0;\n  char cc = getchar();\n  while (cc < '0' || cc > '9') cc = getchar();\n  while (cc >= '0' && cc <= '9')\n    x = (x << 3) + (x << 1) + (48 ^ cc), cc = getchar();\n  return x;\n}\ninline int outmap(int x, int y) {\n  if (x < 0 || x >= n) return -1;\n  if (y < 0 || y >= m) return -1;\n  return map[x][y];\n}\ninline int test() {\n  N = 8;\n  for (int k = 1, count = N, d = 1; k <= N; d += k, k <<= 1, count >>= 1)\n    for (int i = 0; i < k; ++i) cnt[d + i] = count;\n  printf(\"%d\\n\", query(1, 8));\n  updata(1, 4, 1);\n  printf(\"%d\\n\", query(1, 8));\n  updata(1, 3, -1);\n  printf(\"%d\\n\", query(1, 8));\n  updata(1, 2, -8);\n  printf(\"%d\\n\", query(1, 1));\n  return 0;\n}\nint main() {\n  n = read(), m = read();\n  while (N < n * m) N <<= 1;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j) {\n      map[i][j] = read();\n      posx[map[i][j]] = i, posy[map[i][j]] = j;\n    }\n  for (int k = 1, count = N, d = 1; k <= N; d += k, k <<= 1, count >>= 1)\n    for (int i = 0; i < k; ++i) cnt[d + i] = count;\n  long long ans = 0;\n  for (int l = 1, r = 0; l <= n * m; ++l) {\n    for (int r2 = r + 1; r2 <= n * m; ++r2) {\n      int lnk[4], tot = 0, count = 0;\n      bool brek = 0;\n      for (int d = 0; d < 4; ++d) {\n        int to = outmap(posx[r2] + dx[d], posy[r2] + dy[d]);\n        if (to == -1 || to > r2 || to < l) continue;\n        if (!connected(r2, to))\n          link(r2, to), lnk[tot++] = to, ++count;\n        else {\n          brek = 1;\n          break;\n        }\n      }\n      if (brek) {\n        for (int i = 0; i < tot; ++i) cut(r2, lnk[i]);\n        break;\n      }\n      updata(r2, n * m, 1 - count);\n      r = r2;\n    }\n    ans += query(l, r);\n    int lnk[4], tot = 0;\n    for (int d = 0; d < 4; ++d) {\n      int to = outmap(posx[l] + dx[d], posy[l] + dy[d]);\n      if (to == -1) continue;\n      if (connected(l, to)) cut(l, to), lnk[tot++] = to;\n    }\n    sort(lnk, lnk + tot);\n    if (tot > 0)\n      updata(l, lnk[0] - 1, -1);\n    else\n      updata(l, m * n, -1);\n    for (int i = 1; i < tot; ++i) {\n      if (!connected(lnk[i - 1], lnk[i])) updata(lnk[i], n * m, 1);\n    }\n  }\n  printf(\"%lld\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int __SIZE = 1 << 18;\nchar ibuf[__SIZE], *iS, *iT;\ntemplate <typename T>\ninline void read(T &x) {\n  char ch, t = 0;\n  x = 0;\n  while (!isdigit(ch = (iS == iT\n                            ? (iT = (iS = ibuf) + fread(ibuf, 1, __SIZE, stdin),\n                               (iS == iT ? EOF : *iS++))\n                            : *iS++)))\n    t |= ch == '-';\n  while (isdigit(ch))\n    x = x * 10 + (ch ^ 48),\n    ch = (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, __SIZE, stdin),\n                      (iS == iT ? EOF : *iS++))\n                   : *iS++);\n  x = t ? -x : x;\n}\ninline int read_int() {\n  int x;\n  return read(x), x;\n}\ninline long long read_ll() {\n  long long x;\n  return read(x), x;\n}\ntemplate <typename T>\ninline void chkmin(T &a, T b) {\n  a = a < b ? a : b;\n}\nconst int MAXN = 200010;\nint n, m, N, L, R;\nint a[2020][2020];\nint vis[2020][2020];\nint E[2020][2020][4];\nint px[MAXN];\nint py[MAXN];\nstruct SegmentTree {\n  struct Node {\n    int t, m, c;\n  } T[MAXN << 2];\n  inline void pushup(int x) {\n    T[x].m = min(T[(x << 1)].m, T[(x << 1 | 1)].m);\n    T[x].c = (T[(x << 1)].m == T[x].m ? T[(x << 1)].c : 0) +\n             (T[(x << 1 | 1)].m == T[x].m ? T[(x << 1 | 1)].c : 0);\n  }\n  inline void pushdown(int x) {\n    int t = T[x].t;\n    if (!t) return;\n    T[(x << 1)].t += t, T[(x << 1)].m += t;\n    T[(x << 1 | 1)].t += t, T[(x << 1 | 1)].m += t;\n    T[x].t = 0;\n  }\n  inline void build(int x, int l, int r) {\n    if (l == r) return T[x].c = 1, T[x].m = 1e9, void();\n    int mid = (l + r) >> 1;\n    build((x << 1), l, mid), build((x << 1 | 1), mid + 1, r), pushup(x);\n  }\n  inline void Modify(int x, int l, int r, int p, int v) {\n    if (l == r) return T[x].m = v, void();\n    int mid = (l + r) >> 1;\n    pushdown(x);\n    p <= mid ? Modify((x << 1), l, mid, p, v)\n             : Modify((x << 1 | 1), mid + 1, r, p, v);\n    pushup(x);\n  }\n  inline void Add(int x, int l, int r, int L, int R, int v) {\n    if (L <= l && r <= R) return T[x].m += v, T[x].t += v, void();\n    int mid = (l + r) >> 1;\n    pushdown(x);\n    if (L <= mid) Add((x << 1), l, mid, L, R, v);\n    if (mid < R) Add((x << 1 | 1), mid + 1, r, L, R, v);\n    pushup(x);\n  }\n  inline int Sum() { return T[1].m == 1 ? T[1].c : 0; }\n} seg;\nstruct LinkCutTree {\n  struct Node {\n    int fa, son[2], rev;\n  } T[MAXN];\n  inline int isroot(int x) {\n    return T[T[x].fa].son[0] != x && T[T[x].fa].son[1] != x;\n  }\n  inline void reverse(int x) { T[x].rev ^= 1, swap(T[x].son[0], T[x].son[1]); }\n  inline void pushdown(int x) {\n    if (T[x].rev) {\n      T[x].rev = 0;\n      if (T[x].son[0]) reverse(T[x].son[0]);\n      if (T[x].son[1]) reverse(T[x].son[1]);\n    }\n  }\n  inline void Push(int x) {\n    if (!isroot(x)) Push(T[x].fa);\n    pushdown(x);\n  }\n  inline void rotate(int x) {\n    int y = T[x].fa, z = T[y].fa, p = (T[y].son[1] == x),\n        q = (T[z].son[1] == y), a = T[x].son[p ^ 1];\n    if (!isroot(y)) T[z].son[q] = x;\n    T[x].son[p ^ 1] = y, T[y].son[p] = a;\n    if (a) T[a].fa = y;\n    T[y].fa = x, T[x].fa = z;\n  }\n  inline void Splay(int x) {\n    Push(x);\n    while (!isroot(x)) {\n      int y = T[x].fa, z = T[y].fa;\n      if (!isroot(y)) rotate((T[z].son[1] == y) ^ (T[y].son[1] == x) ? x : y);\n      rotate(x);\n    }\n  }\n  inline void access(int x) {\n    for (int la = 0; x; T[x].son[1] = la, la = x, x = T[x].fa) Splay(x);\n  }\n  inline int findroot(int x) {\n    access(x), Splay(x);\n    while (T[x].son[0]) x = T[x].son[0], pushdown(x);\n    return Splay(x), x;\n  }\n  inline void makeroot(int x) { access(x), Splay(x), reverse(x); }\n  inline void Cut(int x, int y) {\n    makeroot(x), access(y), Splay(y), T[x].fa = T[y].son[0] = 0;\n  }\n  inline void Link(int x, int y) {\n    makeroot(x), access(y), Splay(y), T[x].fa = y;\n  }\n  inline int Q(int x, int y) { return makeroot(x), findroot(y) == x; }\n} lct;\ninline void Del(int x) {\n  int X = px[x], Y = py[x];\n  if (E[X][Y][0]) lct.Cut(x, a[X + 1][Y]), E[X][Y][0] = E[X + 1][Y][1] = 0;\n  if (E[X][Y][1]) lct.Cut(x, a[X - 1][Y]), E[X][Y][1] = E[X - 1][Y][0] = 0;\n  if (E[X][Y][2]) lct.Cut(x, a[X][Y + 1]), E[X][Y][2] = E[X][Y + 1][3] = 0;\n  if (E[X][Y][3]) lct.Cut(x, a[X][Y - 1]), E[X][Y][3] = E[X][Y - 1][2] = 0;\n  vis[X][Y] = 0;\n}\ninline void solve(int X1, int Y1, int X2, int Y2, int fx) {\n  if (!vis[X2][Y2]) return;\n  int a1 = a[X1][Y1], a2 = a[X2][Y2];\n  while (L < R && lct.Q(a1, a2)) seg.Modify(1, 1, N, L, 1e9), Del(L), ++L;\n  if (L <= a2 && a2 <= R) {\n    lct.Link(a1, a2), seg.Add(1, 1, N, 1, a2, -1);\n    E[X1][Y1][fx] = E[X2][Y2][fx ^ 1] = 1;\n  }\n}\nint main() {\n  n = read_int(), m = read_int(), N = n * m;\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) {\n      int x = a[i][j] = read_int();\n      px[x] = i, py[x] = j;\n    }\n  long long res = 0;\n  seg.build(1, 1, N), L = R = 1;\n  while (R <= N) {\n    seg.Modify(1, 1, N, R, 0);\n    seg.Add(1, 1, N, 1, R, 1);\n    int X = px[R], Y = py[R];\n    solve(X, Y, X + 1, Y, 0);\n    solve(X, Y, X - 1, Y, 1);\n    solve(X, Y, X, Y + 1, 2);\n    solve(X, Y, X, Y - 1, 3);\n    res += seg.Sum();\n    vis[X][Y] = 1;\n    ++R;\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2 * 1e5 + 10;\nconst int dx[4] = {1, -1, 0, 0};\nconst int dy[4] = {0, 0, -1, 1};\nint n;\nint m;\nstruct mar {\n  int f[N * 2];\n  inline int* operator[](const int& x) { return f + x * m; }\n} val;\nbool book[N];\nstruct data {\n  int x;\n  int y;\n} nod[N];\nint ctt;\nint ptr;\nint totr;\nstruct tnod {\n  int val;\n  int cnt;\n  friend tnod operator+(tnod a, tnod b) {\n    if (a.val < b.val) return a;\n    if (a.val > b.val) return b;\n    return (tnod){a.val, a.cnt + b.cnt};\n  }\n  void operator+=(const int& x) { val += x; }\n};\nstruct linkcuttree {\n  int s[N][2];\n  int fa[N];\n  int mi[N];\n  int rv[N];\n  int st[N];\n  int tp;\n  linkcuttree() { mi[0] = 0x3f3f3f3f; }\n  inline int gc(int x) { return s[fa[x]][1] == x; }\n  inline bool isr(int x) { return (s[fa[x]][1] != x && s[fa[x]][0] != x); }\n  inline void ud(int x) { mi[x] = min(min(mi[s[x][0]], mi[s[x][1]]), x); }\n  inline void pd(int p) {\n    if (rv[p])\n      rv[s[p][0]] ^= 1, rv[s[p][1]] ^= 1, swap(s[p][0], s[p][1]), rv[p] = 0;\n  }\n  inline void pdall(int p) {\n    for (int x = p; (st[++tp] = x, !isr(x)); x = fa[x])\n      ;\n    while (tp) pd(st[tp--]);\n  }\n  inline void rt(int x) {\n    int d = fa[x];\n    int t = gc(x);\n    s[d][t] = s[x][t ^ 1];\n    fa[s[x][t ^ 1]] = d;\n    if (!isr(d)) s[fa[d]][gc(d)] = x;\n    fa[x] = fa[d];\n    s[x][t ^ 1] = d;\n    fa[d] = x;\n    ud(d);\n    ud(x);\n  }\n  inline void rtup(int x) {\n    rt((gc(x) ^ gc(fa[x])) ? x : fa[x]);\n    rt(x);\n  }\n  inline void splay(int x) {\n    pdall(x);\n    for (; !isr(x) && !isr(fa[x]); rtup(x))\n      ;\n    if (!isr(x)) rt(x);\n  }\n  inline void acc(int p) {\n    for (splay(p), s[p][1] = 0, ud(p); fa[p];\n         splay(fa[p]), s[fa[p]][1] = p, ud(fa[p]), splay(p))\n      ;\n  }\n  inline void mkr(int p) {\n    acc(p);\n    rv[p] ^= 1;\n  }\n  inline void lk(int u, int v) {\n    mkr(u);\n    acc(v);\n    fa[u] = v;\n  }\n  inline void cu(int u, int v) {\n    mkr(u);\n    acc(v);\n    if (s[v][0] == u && s[u][1] == 0) s[v][0] = 0, fa[u] = 0, ud(v);\n  }\n  inline int cmi(int u, int v) {\n    mkr(u);\n    acc(v);\n    if (fa[u] == 0)\n      return 0x3f3f3f3f;\n    else\n      return mi[v];\n  }\n} lct;\nstruct linetree {\n  tnod v[N << 2];\n  int add[N << 2];\n  inline void pd(int p, int p1, int p2) {\n    if (add[p])\n      v[p1] += add[p], v[p2] += add[p], add[p1] += add[p], add[p2] += add[p],\n          add[p] = 0;\n  }\n  inline void build(int p, int l, int r) {\n    v[p] = (tnod){0, r - l};\n    if (r - l == 1) {\n      return;\n    }\n    int mid = (l + r) >> 1;\n    build(p << 1, l, mid);\n    build(p << 1 | 1, mid, r);\n  }\n  inline void stadd(int p, int l, int r, int dl, int dr, int pl) {\n    if (dl == l && dr == r) {\n      v[p] += pl;\n      add[p] += pl;\n      return;\n    }\n    int mid = (l + r) >> 1;\n    pd(p, p << 1, p << 1 | 1);\n    if (dl < mid) stadd(p << 1, l, mid, dl, min(dr, mid), pl);\n    if (mid < dr) stadd(p << 1 | 1, mid, r, max(dl, mid), dr, pl);\n    v[p] = v[p << 1] + v[p << 1 | 1];\n  }\n  inline tnod sum(int p, int l, int r, int dl, int dr) {\n    if (dl == l && dr == r) return v[p];\n    int mid = (l + r) >> 1;\n    pd(p, p << 1, p << 1 | 1);\n    if (dl < mid && mid < dr)\n      return sum(p << 1, l, mid, dl, mid) + sum(p << 1 | 1, mid, r, mid, dr);\n    if (dl < mid)\n      return sum(p << 1, l, mid, dl, dr);\n    else\n      return sum(p << 1 | 1, mid, r, dl, dr);\n  }\n} lt;\ninline void delnod(int sx, int sy) {\n  int np = val[sx][sy];\n  for (int k = 0, tx, ty; k < 4; k++) {\n    tx = sx + dx[k];\n    ty = sy + dy[k];\n    if (tx < 1 || tx > n || ty < 1 || ty > m || val[tx][ty] < ptr ||\n        val[tx][ty] > totr)\n      continue;\n    lct.cu(np, val[tx][ty]);\n  }\n  ptr++;\n}\ninline void insed(int p1, int p2) {\n  lt.stadd(1, 0, ctt, 0, p2, -1);\n  int tmp = lct.cmi(p1, p2);\n  if (tmp == 0x3f3f3f3f) {\n    lct.lk(p1, p2);\n    return;\n  }\n  for (int k = ptr; k <= tmp; k++) delnod(nod[k].x, nod[k].y);\n  lct.lk(p1, p2);\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  ctt = n * m;\n  lt.build(1, 0, ctt);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1, t; j <= m; j++)\n      scanf(\"%d\", &t), val[i][j] = t, nod[t] = (data){i, j};\n  long long ans = 0;\n  ptr = 1;\n  totr = 1;\n  for (int i = 1; i <= ctt; i++) {\n    totr = i;\n    int sx = nod[i].x;\n    int sy = nod[i].y;\n    lt.stadd(1, 0, ctt, 0, i, 1);\n    for (int k = 0, tx, ty; k < 4; k++) {\n      tx = sx + dx[k], ty = sy + dy[k];\n      if (tx < 1 || tx > n || ty < 1 || ty > m || val[tx][ty] > i ||\n          val[tx][ty] < ptr)\n        continue;\n      insed(i, val[tx][ty]);\n    }\n    tnod ret = lt.sum(1, 0, ctt, ptr - 1, i);\n    if (ret.val == 1) ans += ret.cnt;\n  }\n  printf(\"%I64d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace TYC {\nconst int M = 1005, N = 2e5 + 5;\nconst int dx[] = {0, 0, -1, 1}, dy[] = {1, -1, 0, 0};\nint n, m, tot, ID[M][M];\npair<int, int> P[N];\ninline int read() {\n  int x = 0, f = 0, ch = getchar();\n  while (!isdigit(ch)) f |= (ch == '-'), ch = getchar();\n  while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();\n  return f ? -x : x;\n}\nnamespace LCT {\nstruct null_tag {};\nstruct node {\n  static node *null;\n  node *fa, *son[2];\n  int rev;\n  node(null_tag) : rev(0) { fa = son[0] = son[1] = this; }\n  node() : rev(0) { fa = son[0] = son[1] = null; }\n  int dir() { return fa->son[1] == this; }\n  bool isroot() { return fa->son[0] != this && fa->son[1] != this; }\n  void reverse() { swap(son[0], son[1]), rev ^= 1; }\n  void pushdown() {\n    if (rev) {\n      if (son[0] != null) son[0]->reverse();\n      if (son[1] != null) son[1]->reverse();\n      rev = 0;\n    }\n  }\n  void rotate() {\n    node *f = fa;\n    int d = dir();\n    if (!f->isroot()) f->fa->son[f->dir()] = this;\n    fa = f->fa;\n    f->son[d] = son[d ^ 1];\n    if (son[d ^ 1] != null) son[d ^ 1]->fa = f;\n    f->fa = this;\n    son[d ^ 1] = f;\n  }\n  void splay() {\n    static node *sta[N];\n    int top = 0;\n    sta[top++] = this;\n    for (node *t = this; !t->isroot(); t = t->fa) sta[top++] = t->fa;\n    while (top--) sta[top]->pushdown();\n    for (; !isroot(); rotate())\n      if (!fa->isroot()) (fa->dir() ^ dir() ? this : fa)->rotate();\n  }\n} *node::null = new node(null_tag()), *Node[N];\ninline void access(node *o) {\n  for (node *t = node::null; o != node::null; t = o, o = o->fa) {\n    o->splay();\n    o->son[1] = t;\n  }\n}\ninline void makeroot(node *o) {\n  access(o);\n  o->splay();\n  o->reverse();\n}\ninline node *findroot(node *o) {\n  access(o);\n  o->splay();\n  while (o->son[0] != node::null) o = o->son[0];\n  o->splay();\n  return o;\n}\ninline void split(node *x, node *y) {\n  makeroot(x);\n  access(y);\n  y->splay();\n}\ninline bool link(node *x, node *y) {\n  makeroot(x);\n  return findroot(y) != x ? x->fa = y, true : false;\n}\ninline void cut(node *x, node *y) {\n  split(x, y);\n  if (y->son[0] != x || x->son[1] != node::null) return;\n  y->son[0] = x->fa = node::null;\n}\n}  // namespace LCT\nusing namespace LCT;\nnamespace Tree {\nstruct node {\n  int v, c, tag;\n} tr[N << 2];\ninline void update(node &o, const node &a, const node &b) {\n  if (a.v < b.v)\n    o.v = a.v, o.c = a.c;\n  else if (a.v > b.v)\n    o.v = b.v, o.c = b.c;\n  else\n    o.v = a.v, o.c = a.c + b.c;\n  o.v += o.tag;\n}\nvoid build(const int o = 1, const int l = 1, const int r = tot) {\n  if (l == r) return void(tr[o] = (node){1, 1, 0});\n  int mid = (l + r) >> 1;\n  build(o << 1, l, mid), build(o << 1 | 1, mid + 1, r);\n  update(tr[o], tr[o << 1], tr[o << 1 | 1]);\n}\nvoid add(const int s, const int e, const int v, const int o = 1,\n         const int l = 1, const int r = tot) {\n  if (s <= l && r <= e) {\n    tr[o].v += v;\n    tr[o].tag += v;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  if (s <= mid) add(s, e, v, o << 1, l, mid);\n  if (e > mid) add(s, e, v, o << 1 | 1, mid + 1, r);\n  update(tr[o], tr[o << 1], tr[o << 1 | 1]);\n}\nnode query(const int s, const int e, const int o = 1, const int l = 1,\n           const int r = tot) {\n  if (s <= l && r <= e) return tr[o];\n  int mid = (l + r) >> 1;\n  node t = (node){0, 0, 0};\n  if (e <= mid)\n    t = query(s, e, o << 1, l, mid);\n  else if (s > mid)\n    t = query(s, e, o << 1 | 1, mid + 1, r);\n  else\n    update(t, query(s, e, o << 1, l, mid), query(s, e, o << 1 | 1, mid + 1, r));\n  return t.v += tr[o].tag, t;\n}\n}  // namespace Tree\nvoid work() {\n  n = read(), m = read(), tot = n * m;\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) P[ID[i][j] = read()] = pair<int, int>(i, j);\n  for (int i = 1; i <= tot; i++) Node[i] = new node();\n  Tree::build();\n  long long ans = 0;\n  for (int i = 1, j = 1; i <= tot; i++) {\n    for (int k1 = 0, x1, y1, id1; k1 < 4; k1++) {\n      id1 = ID[x1 = P[i].first + dx[k1]][y1 = P[i].second + dy[k1]];\n      if (1 <= x1 && x1 <= n && 1 <= y1 && y1 <= m && j <= id1 && id1 <= i) {\n        while (!link(Node[id1], Node[i])) {\n          for (int k2 = 0, x2, y2, id2; k2 < 4; k2++) {\n            id2 = ID[x2 = P[j].first + dx[k2]][y2 = P[j].second + dy[k2]];\n            if (1 <= x2 && x2 <= n && 1 <= y2 && y2 <= m && j <= id2 &&\n                id2 <= i)\n              cut(Node[j], Node[id2]);\n          }\n          ++j;\n        }\n        Tree::add(1, id1, -1);\n      }\n    }\n    Tree::node t = Tree::query(j, i);\n    ans += t.v == 1 ? t.c : 0;\n    Tree::add(j, i, 1);\n  }\n  printf(\"%I64d\\n\", ans);\n}\n}  // namespace TYC\nint main() {\n  TYC::work();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline void open(const char *s) {}\ninline int rd() {\n  static int x, f;\n  x = 0;\n  f = 1;\n  char ch = getchar();\n  for (; ch < '0' || ch > '9'; ch = getchar())\n    if (ch == '-') f = -1;\n  for (; ch >= '0' && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n  return f > 0 ? x : -x;\n}\nconst int N = 1000010;\nint R, C, n, rt = 0, Lr;\nvector<int> a[N];\npair<int, int> b[N];\nnamespace LCT {\nstruct tree {\n  int ch[2], fa, rev;\n  tree() { ch[0] = ch[1] = fa = rev = 0; }\n} tr[N];\nint cnt = 0;\ninline bool isrt(int x) {\n  return tr[tr[x].fa].ch[0] != x && tr[tr[x].fa].ch[1] != x;\n}\ninline void pushdown(int x) {\n  if (!tr[x].rev) return;\n  swap(tr[x].ch[0], tr[x].ch[1]);\n  if (tr[x].ch[0]) tr[tr[x].ch[0]].rev ^= 1;\n  if (tr[x].ch[1]) tr[tr[x].ch[1]].rev ^= 1;\n  tr[x].rev = 0;\n}\ninline void clr(int x) {\n  static int st[N], tt;\n  for (st[tt = 1] = x; !isrt(x); x = tr[x].fa) st[++tt] = tr[x].fa;\n  while (tt) pushdown(st[tt--]);\n}\ninline void rotate(int x) {\n  static int y, z, t1, t2;\n  y = tr[x].fa;\n  z = tr[y].fa;\n  t1 = tr[y].ch[1] == x;\n  t2 = t1 ^ 1;\n  if (!isrt(y)) tr[z].ch[tr[z].ch[1] == y] = x;\n  tr[x].fa = z;\n  tr[y].fa = x;\n  if (tr[x].ch[t2]) tr[tr[x].ch[t2]].fa = y;\n  tr[y].ch[t1] = tr[x].ch[t2];\n  tr[x].ch[t2] = y;\n}\ninline void splay(int x) {\n  for (clr(x); !isrt(x); rotate(x)) {\n    int y = tr[x].fa, z = tr[y].fa;\n    if (isrt(y)) continue;\n    if ((tr[y].ch[0] == x) ^ (tr[z].ch[0] == y))\n      rotate(x);\n    else\n      rotate(y);\n  }\n}\ninline void access(int x) {\n  for (int s = 0; x; s = x, x = tr[x].fa) {\n    splay(x);\n    tr[x].ch[1] = s;\n  }\n}\ninline void makert(int x) {\n  access(x);\n  splay(x);\n  tr[x].rev ^= 1;\n}\ninline int findrt(int x) {\n  access(x);\n  splay(x);\n  pushdown(x);\n  while (tr[x].ch[0]) x = tr[x].ch[0], pushdown(x);\n  return x;\n}\ninline void link(int x, int y) {\n  makert(x);\n  access(y);\n  splay(y);\n  tr[x].fa = y;\n}\ninline void cut(int x, int y) {\n  makert(y);\n  access(x);\n  splay(x);\n  tr[tr[x].ch[0]].fa = 0;\n  tr[x].ch[0] = 0;\n}\n}  // namespace LCT\nnamespace Seg {\nstruct tree {\n  int ls, rs, mx, cmx, tag;\n  tree() { ls = rs = mx = cmx = tag = 0; }\n} tr[N << 1];\nint cnt = 0;\ninline void pushup(int o) {\n  tr[o].mx = max(tr[tr[o].ls].mx, tr[tr[o].rs].mx);\n  tr[o].cmx = 0;\n  if (tr[o].mx == tr[tr[o].ls].mx) tr[o].cmx += tr[tr[o].ls].cmx;\n  if (tr[o].mx == tr[tr[o].rs].mx) tr[o].cmx += tr[tr[o].rs].cmx;\n}\ninline void pushdown(int o) {\n  if (!tr[o].tag) return;\n  static int ls, rs;\n  ls = tr[o].ls, rs = tr[o].rs;\n  tr[ls].mx += tr[o].tag;\n  tr[ls].tag += tr[o].tag;\n  tr[rs].mx += tr[o].tag;\n  tr[rs].tag += tr[o].tag;\n  tr[o].tag = 0;\n}\nvoid build(int &o, int l, int r) {\n  o = ++cnt;\n  if (l == r) return tr[o].mx = l, tr[o].cmx = 1, void();\n  int mid = (l + r) >> 1;\n  build(tr[o].ls, l, mid);\n  build(tr[o].rs, mid + 1, r);\n  pushup(o);\n}\nvoid modify(int o, int l, int r, int L, int R, int d) {\n  if (l == L && r == R) return tr[o].mx += d, tr[o].tag += d, void();\n  pushdown(o);\n  int mid = (l + r) >> 1;\n  if (L <= mid) modify(tr[o].ls, l, mid, L, min(mid, R), d);\n  if (R > mid) modify(tr[o].rs, mid + 1, r, max(mid + 1, L), R, d);\n  pushup(o);\n}\npair<int, int> query(int o, int l, int r, int L, int R) {\n  if (l == L && r == R) return pair<int, int>(tr[o].mx, tr[o].cmx);\n  pushdown(o);\n  int mid = (l + r) >> 1;\n  pair<int, int> res = pair<int, int>(0, 0), tmp;\n  if (L <= mid) res = query(tr[o].ls, l, mid, L, min(mid, R));\n  if (R > mid) {\n    tmp = query(tr[o].rs, mid + 1, r, max(mid + 1, L), R);\n    if (res.first == tmp.first)\n      res.second += tmp.second;\n    else\n      res = max(res, tmp);\n  }\n  return res;\n}\n}  // namespace Seg\ninline bool check(int p) {\n  static int d[5], tt, x, y;\n  tt = 0;\n  x = b[p].first, y = b[p].second;\n  if (x > 1 && a[x - 1][y] >= Lr && a[x - 1][y] < p)\n    d[++tt] = LCT::findrt(a[x - 1][y]);\n  if (y > 1 && a[x][y - 1] >= Lr && a[x][y - 1] < p)\n    d[++tt] = LCT::findrt(a[x][y - 1]);\n  if (x < R && a[x + 1][y] >= Lr && a[x + 1][y] < p)\n    d[++tt] = LCT::findrt(a[x + 1][y]);\n  if (y < C && a[x][y + 1] >= Lr && a[x][y + 1] < p)\n    d[++tt] = LCT::findrt(a[x][y + 1]);\n  sort(d + 1, d + tt + 1);\n  for (int i = 1; i <= tt - 1; i++)\n    if (d[i] == d[i + 1]) return 0;\n  return 1;\n}\ninline void del(int p) {\n  static int x, y;\n  x = b[p].first, y = b[p].second;\n  if (x > 1 && a[x - 1][y] >= p) LCT::cut(a[x - 1][y], p);\n  if (y > 1 && a[x][y - 1] >= p) LCT::cut(a[x][y - 1], p);\n  if (x < R && a[x + 1][y] >= p) LCT::cut(a[x + 1][y], p);\n  if (y < C && a[x][y + 1] >= p) LCT::cut(a[x][y + 1], p);\n}\ninline void gao(int p) {\n  static int x, y;\n  for (; !check(p); ++Lr) del(Lr);\n  x = b[p].first, y = b[p].second;\n  if (x > 1 && a[x - 1][y] >= Lr && a[x - 1][y] < p) {\n    LCT::link(a[x - 1][y], p);\n    Seg::modify(rt, 1, n, 1, a[x - 1][y], 1);\n  }\n  if (y > 1 && a[x][y - 1] >= Lr && a[x][y - 1] < p) {\n    LCT::link(a[x][y - 1], p);\n    Seg::modify(rt, 1, n, 1, a[x][y - 1], 1);\n  }\n  if (x < R && a[x + 1][y] >= Lr && a[x + 1][y] < p) {\n    LCT::link(a[x + 1][y], p);\n    Seg::modify(rt, 1, n, 1, a[x + 1][y], 1);\n  }\n  if (y < C && a[x][y + 1] >= Lr && a[x][y + 1] < p) {\n    LCT::link(a[x][y + 1], p);\n    Seg::modify(rt, 1, n, 1, a[x][y + 1], 1);\n  }\n}\nint main() {\n  open(\"hh\");\n  R = rd();\n  C = rd();\n  for (int i = 1; i <= R; i++) {\n    a[i].resize(C + 1);\n    for (int j = 1; j <= C; j++) b[a[i][j] = rd()] = pair<int, int>(i, j);\n  }\n  n = R * C;\n  Seg::build(rt, 1, n);\n  Lr = 1;\n  long long ans = 1;\n  for (int i = 2; i <= n; i++) {\n    gao(i);\n    pair<int, int> res = Seg::query(rt, 1, n, Lr, i);\n    ans += res.first == i ? res.second : 0;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace IO {\nchar ibuf[(1 << 21) + 1], *iS, *iT;\nchar Get() {\n  return (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, (1 << 21) + 1, stdin),\n                      (iS == iT ? EOF : *iS++))\n                   : *iS++);\n}\nint read() {\n  int x = 0, c = Get();\n  while (!isdigit(c)) c = Get();\n  while (isdigit(c)) x = x * 10 + c - 48, c = Get();\n  return x;\n}\n}  // namespace IO\nusing IO::read;\nconst int N = 2007, M = 1000007;\nint n, m;\nnamespace Graph {\nint f[N][N], dx[4] = {1, -1, 0, 0}, dy[4] = {0, 0, 1, -1};\nvector<int> E[M];\nvoid buildG() {\n  for (int i = 1, j; i <= n; ++i)\n    for (j = 1; j <= m; ++j) f[i][j] = read();\n  for (int i = 1, j, k, x, y; i <= n; ++i)\n    for (j = 1; j <= m; ++j)\n      for (k = 0; k < 4; ++k) {\n        x = i + dx[k], y = j + dy[k];\n        if (x >= 1 && x <= n && y >= 1 && y <= m) E[f[i][j]].push_back(f[x][y]);\n      }\n}\n}  // namespace Graph\nusing namespace Graph;\nnamespace LCT {\nint fa[M], ch[M][2], rev[M];\nint nroot(int x) { return ch[fa[x]][0] == x || ch[fa[x]][1] == x; }\nvoid pushrev(int x) { swap(ch[x][0], ch[x][1]), rev[x] ^= 1; }\nvoid pushdown(int x) {\n  if (!rev[x]) return;\n  rev[x] = 0, pushrev(ch[x][0]), pushrev(ch[x][1]);\n}\nvoid pushall(int x) {\n  if (nroot(x)) pushall(fa[x]);\n  pushdown(x);\n}\nvoid rotate(int x) {\n  int y = fa[x], z = fa[y], k = ch[y][1] == x;\n  if (nroot(y)) ch[z][ch[z][1] == y] = x;\n  fa[x] = z, fa[ch[x][!k]] = y, ch[y][k] = ch[x][!k], fa[y] = x, ch[x][!k] = y;\n}\nvoid splay(int x) {\n  pushall(x);\n  for (int y; nroot(x); rotate(x))\n    if (nroot(y = fa[x])) rotate((ch[fa[y]][0] == y) ^ (ch[y][0] == x) ? x : y);\n}\nvoid access(int x) {\n  for (int y = 0; x; x = fa[y = x]) splay(x), ch[x][1] = y;\n}\nvoid makeroot(int x) { access(x), splay(x), pushrev(x); }\nint findroot(int x) {\n  access(x), splay(x);\n  while (ch[x][0]) x = ch[x][0];\n  return splay(x), x;\n}\nint link(int x, int y) { return makeroot(x), findroot(y) == x ? 0 : fa[x] = y; }\nvoid cut(int x, int y) {\n  makeroot(x);\n  if (findroot(y) == x && fa[y] == x && !ch[y][0]) fa[y] = ch[x][1] = 0;\n}\n}  // namespace LCT\nusing namespace LCT;\nnamespace SegTree {\nint mn[M << 2], sum[M << 2], tag[M << 2];\nvoid pushup(int p) {\n  if (mn[p << 1] < mn[p << 1 | 1]) mn[p] = mn[p << 1], sum[p] = sum[p << 1];\n  if (mn[p << 1 | 1] < mn[p << 1])\n    mn[p] = mn[p << 1 | 1], sum[p] = sum[p << 1 | 1];\n  if (mn[p << 1] == mn[p << 1 | 1])\n    mn[p] = mn[p << 1], sum[p] = sum[p << 1] + sum[p << 1 | 1];\n}\nvoid modify(int p, int v) { mn[p] += v, tag[p] += v; }\nvoid pushdown(int p) {\n  modify(p << 1, tag[p]), modify(p << 1 | 1, tag[p]), tag[p] = 0;\n}\nvoid buildS(int p, int l, int r) {\n  if (l == r) return (void)(sum[p] = 1);\n  buildS(p << 1, l, ((l + r) >> 1)), buildS(p << 1 | 1, ((l + r) >> 1) + 1, r),\n      pushup(p);\n}\nvoid update(int p, int l, int r, int L, int R, int x) {\n  if (L <= l && r <= R) return modify(p, x);\n  if (tag[p]) pushdown(p);\n  if (L <= ((l + r) >> 1)) update(p << 1, l, ((l + r) >> 1), L, R, x);\n  if (R > ((l + r) >> 1)) update(p << 1 | 1, ((l + r) >> 1) + 1, r, L, R, x);\n  pushup(p);\n}\nint query(int p, int l, int r, int L, int R) {\n  if (L <= l && r <= R) return mn[p] == 1 ? sum[p] : 0;\n  if (tag[p]) pushdown(p);\n  return (L <= ((l + r) >> 1) ? query(p << 1, l, ((l + r) >> 1), L, R) : 0) +\n         (R > ((l + r) >> 1) ? query(p << 1 | 1, ((l + r) >> 1) + 1, r, L, R)\n                             : 0);\n}\n}  // namespace SegTree\nusing namespace SegTree;\nint main() {\n  long long ans = 0;\n  int l = 1, r = 0, S;\n  n = read(), m = read(), buildG(), buildS(1, 1, S = n * m);\n  for (int f, c; l <= S; ++l) {\n    for (; r < S;) {\n      f = c = 0, ++r;\n      for (int v : E[r])\n        if (v <= r && v >= l && !link(v, r)) {\n          f = 1;\n          break;\n        }\n      for (int v : E[r]) cut(v, r);\n      if (f == 1) {\n        --r;\n        break;\n      }\n      for (int v : E[r])\n        if (v <= r && v >= l) link(v, r), ++c;\n      update(1, 1, S, r, r, r - l + 1), update(1, 1, S, r, S, -c);\n    }\n    ans += query(1, 1, S, l, r);\n    for (int v : E[l])\n      if (v <= r && v >= l) cut(v, l), update(1, 1, S, v, S, 1);\n    update(1, 1, S, l, r, -1);\n  }\n  printf(\"%lld\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e3 + 9;\nconst int M = 1e6 + 9;\nconst int inf = 1e9 + 7;\nint n, m, a[N][N];\nstruct pp {\n  int x, y;\n} p[M];\nint l, r, st[M];\nstruct LCT {\n  int fa, ch[2], tag;\n} t[M];\nbool isroot(int x) { return !(t[t[x].fa].ch[0] == x || t[t[x].fa].ch[1] == x); }\nvoid update(int x) {\n  if (!x) return;\n  t[x].tag ^= 1;\n  swap(t[x].ch[0], t[x].ch[1]);\n  return;\n}\nvoid pushdown(int x) {\n  if (t[x].tag) {\n    update(t[x].ch[0]);\n    update(t[x].ch[1]);\n    t[x].tag = 0;\n  }\n  return;\n}\nvoid rotate(int x) {\n  int y = t[x].fa, z = t[y].fa, k = (t[y].ch[1] == x);\n  int w = t[x].ch[!k];\n  if (!isroot(y)) t[z].ch[t[z].ch[1] == y] = x;\n  t[x].ch[!k] = y, t[y].ch[k] = w;\n  t[w].fa = y, t[y].fa = x, t[x].fa = z;\n  return;\n}\nvoid splay(int x) {\n  int y = x, z = 0;\n  st[++z] = x;\n  while (!isroot(y)) st[++z] = y = t[y].fa;\n  while (z) pushdown(st[z--]);\n  while (!isroot(x)) {\n    int y = t[x].fa, z = t[y].fa;\n    if (!isroot(y)) rotate((t[z].ch[1] == y) ^ (t[y].ch[1] == x) ? x : y);\n    rotate(x);\n  }\n  return;\n}\nvoid access(int x) {\n  for (int y = 0; x; x = t[y = x].fa) {\n    splay(x);\n    t[x].ch[1] = y;\n  }\n  return;\n}\nvoid makeroot(int x) {\n  access(x);\n  splay(x);\n  update(x);\n  return;\n}\nint findroot(int x) {\n  access(x);\n  splay(x);\n  while (t[x].ch[0]) pushdown(x), x = t[x].ch[0];\n  splay(x);\n  return x;\n}\nvoid link(int x, int y) {\n  makeroot(x);\n  t[y].fa = x;\n  return;\n}\nvoid cut(int x, int y) {\n  makeroot(x);\n  access(y);\n  t[x].ch[1] = t[y].fa = 0;\n  return;\n}\nvoid split(int x, int y) {\n  makeroot(x);\n  access(y);\n  splay(y);\n  return;\n}\nint dx[4] = {0, 0, 1, -1};\nint dy[4] = {1, -1, 0, 0};\nbool Graph_Connected(int u) {\n  vector<int> vec;\n  int x = p[u].x, y = p[u].y;\n  for (int i = 0; i < 4; i++) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if (nx < 1 || nx > n || ny < 1 || ny > m) continue;\n    if (a[nx][ny] >= l && a[nx][ny] < r) vec.push_back(a[nx][ny]);\n  }\n  for (int i = 0; i < (int)vec.size(); i++) {\n    makeroot(vec[i]);\n    for (int j = i + 1; j < (int)vec.size(); j++) {\n      x = vec[i], y = vec[j];\n      if (findroot(y) == x) return 1;\n    }\n  }\n  return 0;\n}\nstruct segment {\n  int mn, num, flag, tag;\n} g[M << 2];\nsegment operator+(const segment x, const segment y) {\n  segment z;\n  z.tag = 0, z.flag = 0, z.mn = 0, z.num = 0;\n  if (!x.flag) {\n    z = y, z.tag = 0;\n    return z;\n  }\n  if (!y.flag) {\n    z = x, z.tag = 0;\n    return z;\n  }\n  if (x.mn == y.mn) {\n    z.flag = 1;\n    z.mn = x.mn, z.num = x.num + y.num;\n    return z;\n  }\n  if (x.mn < y.mn)\n    z = x, z.tag = 0;\n  else\n    z = y, z.tag = 0;\n  return z;\n}\nvoid Pushup(int c) {\n  g[c] = g[(c << 1)] + g[(c << 1 | 1)];\n  return;\n}\nvoid build(int c, int l, int r) {\n  g[c].mn = 1, g[c].num = r - l + 1, g[c].flag = 1, g[c].tag = 0;\n  if (l == r) return;\n  int mid = (l + r) >> 1;\n  build((c << 1), l, mid);\n  build((c << 1 | 1), mid + 1, r);\n  Pushup(c);\n  return;\n}\nvoid Update(int c, int d, int l, int r) {\n  g[c].mn += d, g[c].tag += d;\n  return;\n}\nvoid Pushdown(int c, int l, int r) {\n  int mid = (l + r) >> 1;\n  if (g[c].tag) {\n    Update((c << 1), g[c].tag, l, mid);\n    Update((c << 1 | 1), g[c].tag, mid + 1, r);\n    g[c].tag = 0;\n  }\n  return;\n}\nvoid modify(int c, int l, int r, int x, int y, int d) {\n  if (x > y) return;\n  if (x <= l && r <= y) {\n    Update(c, d, l, r);\n    return;\n  }\n  Pushdown(c, l, r);\n  int mid = (l + r) >> 1;\n  if (x <= mid) modify((c << 1), l, mid, x, y, d);\n  if (y > mid) modify((c << 1 | 1), mid + 1, r, x, y, d);\n  Pushup(c);\n  return;\n}\nsegment query(int c, int l, int r, int x, int y) {\n  if (x <= l && r <= y) return g[c];\n  Pushdown(c, l, r);\n  int mid = (l + r) >> 1;\n  segment ans;\n  ans.flag = 0;\n  if (x <= mid) ans = ans + query((c << 1), l, mid, x, y);\n  if (y > mid) ans = ans + query((c << 1 | 1), mid + 1, r, x, y);\n  Pushup(c);\n  return ans;\n}\nvoid del(int u) {\n  int x = p[u].x, y = p[u].y;\n  for (int i = 0; i < 4; i++) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if (nx < 1 || nx > n || ny < 1 || ny > m) continue;\n    if (a[nx][ny] >= l && a[nx][ny] < r) {\n      cut(u, a[nx][ny]);\n    }\n  }\n  return;\n}\nvoid linked(int u) {\n  int x = p[u].x, y = p[u].y;\n  for (int i = 0; i < 4; i++) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if (nx < 1 || nx > n || ny < 1 || ny > m) continue;\n    if (a[nx][ny] >= l && a[nx][ny] < r) {\n      modify(1, 1, n * m, l, a[nx][ny], -1);\n      link(u, a[nx][ny]);\n    }\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) scanf(\"%d\", &a[i][j]);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) p[a[i][j]].x = i, p[a[i][j]].y = j;\n  long long ans = 0;\n  build(1, 1, n * m);\n  for (r = 1, l = 1; r <= n * m; r++) {\n    while (Graph_Connected(r)) del(l++);\n    modify(1, 1, n * m, l, r, 1);\n    linked(r);\n    segment fd = query(1, 1, n * m, l, r);\n    ans += fd.num;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937 rnd(179);\ntemplate <class T>\nclass splay_tree_base {\n  struct node {\n    T value;\n    node *L, *R, *par;\n    node(const T& val) : value(val), L(nullptr), R(nullptr), par(nullptr) {}\n    void push() {\n      if (value.push(L ? &L->value : nullptr, R ? &R->value : nullptr)) {\n        swap(L, R);\n      }\n    }\n    void update() {\n      value.update(L ? &L->value : nullptr, R ? &R->value : nullptr);\n    }\n  };\n  static void update(node* v) {\n    if (v) {\n      v->update();\n    }\n  }\n  static void push(node* v) {\n    if (v) {\n      v->push();\n    }\n  }\n  static void single_rotate(node* y) {\n    assert(y != nullptr);\n    assert(y->par != nullptr);\n    node* x = y->par;\n    push(x);\n    push(y);\n    if (x->par) {\n      if (x->par->L == x)\n        x->par->L = y;\n      else\n        x->par->R = y;\n    }\n    y->par = x->par;\n    if (x->L == y) {\n      node* B = y->R;\n      x->L = B;\n      if (B) B->par = x;\n      y->R = x;\n      x->par = y;\n    } else {\n      assert(x->R == y);\n      node* B = y->L;\n      x->R = B;\n      if (B) B->par = x;\n      y->L = x;\n      x->par = y;\n    }\n    update(x);\n    update(y);\n  }\n  node* root = nullptr;\n  static void splay(node* v) {\n    while (v->par) {\n      push(v->par->par);\n      push(v->par);\n      push(v);\n      if (v->par->par == nullptr) {\n        single_rotate(v);\n      } else {\n        if ((v->par->par->L == v->par && v->par->L == v) ||\n            (v->par->par->R == v->par && v->par->R == v)) {\n          single_rotate(v->par);\n          single_rotate(v);\n        } else {\n          single_rotate(v);\n          single_rotate(v);\n        }\n      }\n    }\n  }\n  template <class X>\n  node* lower_bound_internal(X& value) {\n    node* cur = root;\n    node* ans = nullptr;\n    while (cur != nullptr) {\n      push(cur);\n      if (cur->value < value) {\n        value.to_right(cur->L ? &cur->L->value : nullptr);\n        cur = cur->R;\n      } else {\n        ans = cur;\n        value.to_left(cur->R ? &cur->R->value : nullptr);\n        cur = cur->L;\n      }\n    }\n    return ans;\n  }\n  template <class X>\n  void split_left(X& value, node*& left, node*& right) {\n    node* v = lower_bound_internal(value);\n    if (v == nullptr) {\n      left = root;\n      right = nullptr;\n    } else if (value < v->value) {\n      splay(v);\n      left = v->L;\n      right = v;\n      if (v->L) v->L->par = nullptr;\n      v->L = nullptr;\n      update(v);\n    } else {\n      splay(v);\n      left = v;\n      right = v->R;\n      if (v->R) v->R->par = nullptr;\n      v->R = nullptr;\n      update(v);\n    }\n  }\n  template <class X>\n  void split_right(X& value, node*& left, node*& right) {\n    node* v = lower_bound_internal(value);\n    if (v == nullptr) {\n      left = root;\n      right = nullptr;\n    } else {\n      splay(v);\n      left = v->L;\n      right = v;\n      if (v->L) v->L->par = nullptr;\n      v->L = nullptr;\n      update(v);\n    }\n  }\n  node* merge(node* left, node* right) {\n    if (!left) return right;\n    node* v = left;\n    push(v);\n    while (v->R) {\n      v = v->R;\n      push(v);\n    }\n    splay(v);\n    v->R = right;\n    if (right) {\n      right->par = v;\n    }\n    update(v);\n    return v;\n  }\n  template <class F>\n  void for_each(const F& f, node* v) {\n    push(v);\n    if (v->L) for_each(f, v->L);\n    f(v->value);\n    if (v->R) for_each(f, v->R);\n  }\n  splay_tree_base(node* rt) : root(rt) {}\n  void rec_delete(node* v) {\n    if (!v) return;\n    rec_delete(v->L);\n    rec_delete(v->R);\n    delete v;\n  }\n\n public:\n  splay_tree_base() {}\n  splay_tree_base(const T& value) : root(new node(value)) {}\n  splay_tree_base(const splay_tree_base<T>&) = delete;\n  splay_tree_base<T>& operator=(const splay_tree_base<T>&) = delete;\n  splay_tree_base(splay_tree_base<T>&& t) = default;\n  splay_tree_base<T>& operator=(splay_tree_base<T>&& t) = default;\n  template <class X>\n  pair<splay_tree_base<T>, splay_tree_base<T>> split_left(X value) {\n    node *left, *right;\n    split_left(value, left, right);\n    root = nullptr;\n    return make_pair(splay_tree_base<T>(left), splay_tree_base<T>(right));\n  }\n  template <class X>\n  pair<splay_tree_base<T>, splay_tree_base<T>> split_right(X value) {\n    node *left, *right;\n    split_right(value, left, right);\n    root = nullptr;\n    return make_pair(splay_tree_base<T>(left), splay_tree_base<T>(right));\n  }\n  template <class X>\n  T* lower_bound(X value) {\n    node* v = lower_bound_internal(value);\n    if (v) {\n      splay(v);\n    }\n    return v ? &v->value : nullptr;\n  }\n  void merge_to(splay_tree_base<T>&& right) { root = merge(root, right.root); }\n  T* root_value() { return root ? &root->value : nullptr; }\n  template <class F>\n  void for_each(const F& functor) {\n    if (root) {\n      for_each(functor, root);\n    }\n  }\n  class iterator {\n    node* v;\n\n   public:\n    iterator(node* n) : v(n) { v->push(); }\n    T& value() { return v->value; }\n    bool has_left() { return v->L; }\n    bool has_right() { return v->R; }\n    void to_root() { splay(v); }\n    void set_root(splay_tree_base<T>& of) { of.root = v; }\n    iterator left() { return iterator(v->L); }\n    iterator right() { return iterator(v->R); }\n  };\n  iterator root_iterator() const { return iterator(root); }\n  bool empty() const { return root == nullptr; }\n};\ntemplate <class T>\nstruct explicit_key {\n  T value;\n  explicit_key(const T& val) : value(val) {}\n  void update(explicit_key<T>*, explicit_key<T>*) {}\n  void to_left(explicit_key<T>*) {}\n  void to_right(explicit_key<T>*) {}\n  bool push(explicit_key<T>*, explicit_key<T>*) { return false; }\n  bool operator<(const explicit_key<T>& other) const {\n    return value < other.value;\n  }\n};\ntemplate <class T, template <class> class K = explicit_key>\nclass splay_tree {\n  using base_t = splay_tree_base<K<T>>;\n  base_t tree;\n  splay_tree(base_t&& b) : tree(std::forward<base_t>(b)) {}\n\n public:\n  splay_tree() {}\n  splay_tree(const splay_tree<T, K>&) = delete;\n  splay_tree<T, K>& operator=(const splay_tree<T, K>&) = delete;\n  splay_tree(splay_tree<T, K>&&) = default;\n  splay_tree<T, K>& operator=(splay_tree<T, K>&&) = default;\n  void insert(const T& value) {\n    auto p = tree.split_left(K<T>(value));\n    p.first.merge_to(base_t(value));\n    p.first.merge_to(std::move(p.second));\n    tree = std::move(p.first);\n  }\n  bool count(const T& value) {\n    auto v = tree.lower_bound(K<T>(value));\n    return v && v->value == value;\n  }\n  void erase(const T& value) {\n    auto p = tree.split_left(K<T>(value));\n    auto q = p.first.split_right(K<T>(value));\n    tree = std::move(q.first);\n    tree.merge_to(std::move(p.second));\n  }\n  template <class F>\n  void for_each(const F& f) {\n    tree.for_each([&f](const K<T>& x) { f(x.value); });\n  }\n  using iterator = typename base_t::iterator;\n  iterator root_iterator() { return tree.root_iterator(); }\n  template <class X>\n  pair<splay_tree<T, K>, splay_tree<T, K>> split_left(const X& value) {\n    auto p = tree.split_left(K<X>(value));\n    return make_pair(splay_tree<T, K>(std::move(p.first)),\n                     splay_tree<T, K>(std::move(p.second)));\n  }\n  template <class X>\n  pair<splay_tree<T, K>, splay_tree<T, K>> split_right(const X& value) {\n    auto p = tree.split_right(K<X>(value));\n    return make_pair(splay_tree<T, K>(std::move(p.first)),\n                     splay_tree<T, K>(std::move(p.second)));\n  }\n  void merge_to(splay_tree<T, K>&& right) {\n    tree.merge_to(std::move(right.tree));\n  }\n  bool empty() const { return tree.empty(); }\n  const K<T>& root_key() const { return tree.root_iterator().value(); }\n};\ntemplate <class T>\nstruct implicit_key {\n  T value;\n  int size;\n  int left_size;\n  int right_size;\n  bool reversed;\n  implicit_key(const T& val)\n      : value(val), size(1), left_size(0), right_size(0), reversed(false) {}\n  void update(implicit_key<T>* L, implicit_key<T>* R) {\n    size = 1;\n    if (L) size += L->size;\n    if (R) size += R->size;\n    left_size = 0;\n    if (L) left_size = L->size;\n    right_size = 0;\n    if (R) right_size = R->size;\n  }\n  void reverse() { reversed ^= 1; }\n  bool push(implicit_key<T>* L, implicit_key<T>* R) {\n    if (reversed) {\n      left_size = R ? R->size : 0;\n      if (L) L->reverse();\n      if (R) R->reverse();\n      reversed = false;\n      return true;\n    }\n    return false;\n  }\n};\ntemplate <class T, template <class> class K>\nstruct split_cmp {\n  int left;\n  split_cmp(int l) : left(l) {}\n  void to_left(K<T>*) {}\n  void to_right(K<T>* key) {\n    left--;\n    if (key) {\n      left -= key->size;\n    }\n  }\n};\ntemplate <class T, template <class> class K>\nbool operator<(const K<T>& a, const split_cmp<T, K>& b) {\n  return a.left_size < b.left;\n}\ntemplate <class T, template <class> class K = implicit_key>\nclass implicit_splay_tree {\n  using base_t = splay_tree_base<K<T>>;\n  base_t tree;\n  implicit_splay_tree(base_t&& t) : tree(std::forward<base_t>(t)) {}\n\n public:\n  implicit_splay_tree() {}\n  implicit_splay_tree(const T& value) : tree(value) {}\n  implicit_splay_tree(const implicit_splay_tree<T, K>&) = delete;\n  implicit_splay_tree<T, K>& operator=(const implicit_splay_tree<T, K>&) =\n      delete;\n  implicit_splay_tree(implicit_splay_tree<T, K>&&) = default;\n  implicit_splay_tree<T, K>& operator=(implicit_splay_tree<T, K>&&) = default;\n  pair<implicit_splay_tree<T, K>, implicit_splay_tree<T, K>> split(\n      int left_size) {\n    auto p = tree.split_right(split_cmp<T, K>(left_size));\n    return make_pair(implicit_splay_tree<T, K>(std::move(p.first)),\n                     implicit_splay_tree<T, K>(std::move(p.second)));\n  }\n  void merge_to(implicit_splay_tree<T, K>&& right) {\n    tree.merge_to(std::move(right.tree));\n  }\n  void insert(int i, const T& value) {\n    auto p = split(i);\n    p.first.merge_to(implicit_splay_tree<T, K>(value));\n    p.first.merge_to(std::move(p.second));\n    *this = std::move(p.first);\n  }\n  const T& at(int i) { return tree.lower_bound(split_cmp<T, K>(i))->value; }\n  void erase(int i) {\n    auto p = split(i);\n    auto q = p.second.split(1);\n    p.first.merge_to(std::move(q.second));\n    *this = std::move(p.first);\n  }\n  template <class F>\n  void for_each(const F& f) {\n    tree.for_each([&f](const K<T>& x) { f(x.value); });\n  }\n  K<T>& root_key() { return tree.root_iterator().value(); }\n  bool empty() { return tree.empty(); }\n  void reverse() {\n    if (!empty()) {\n      root_key().reverse();\n    }\n  }\n  int size() {\n    if (empty()) return 0;\n    return root_key().size;\n  }\n  using iterator = typename base_t::iterator;\n  iterator root_iterator() { return tree.root_iterator(); }\n  base_t& base() { return tree; }\n};\nclass link_cut_trees {\n  struct node_info {\n    int id;\n    int parent;\n    node_info(int v) : id(v), parent(-1) {}\n  };\n  template <class T>\n  struct node_key : public implicit_key<T> {\n    int tree_id;\n    node_key(const T& val) : implicit_key<T>(val), tree_id(-1) {}\n    bool push(node_key<T>* L, node_key<T>* R) {\n      if (L) L->tree_id = tree_id;\n      if (R) R->tree_id = tree_id;\n      return implicit_key<T>::push(L, R);\n    }\n  };\n  using tree_t = implicit_splay_tree<node_info, node_key>;\n  int n;\n  vector<tree_t> trees;\n  vector<tree_t::iterator> node_it;\n  void swap_trees(int i, int j) {\n    if (!trees[i].empty()) trees[i].root_iterator().value().tree_id = j;\n    if (!trees[j].empty()) trees[j].root_iterator().value().tree_id = i;\n    swap(trees[i], trees[j]);\n  }\n  pair<int, int> position_of(int v) {\n    node_it[v].to_root();\n    node_it[v].set_root(trees[node_it[v].value().tree_id].base());\n    return make_pair(node_it[v].value().tree_id, node_it[v].value().left_size);\n  }\n  int parent_of(int tree_id) {\n    auto it = trees[tree_id].root_iterator();\n    while (it.has_left()) it = it.left();\n    it.to_root();\n    it.set_root(trees[tree_id].base());\n    return it.value().value.parent;\n  }\n  int last_in_path(int tree_id) {\n    auto it = trees[tree_id].root_iterator();\n    while (it.has_right()) it = it.right();\n    it.to_root();\n    it.set_root(trees[tree_id].base());\n    return it.value().value.id;\n  }\n  void set_parent(int tree_id, int parent) {\n    auto it = trees[tree_id].root_iterator();\n    while (it.has_left()) it = it.left();\n    it.to_root();\n    it.set_root(trees[tree_id].base());\n    it.value().value.parent = parent;\n  }\n  void split_tree(int tree_id, int left) {\n    assert(trees[tree_id].size() >= left);\n    auto p = trees[tree_id].split(left);\n    assert(p.first.size() == left);\n    trees[tree_id] = std::move(p.first);\n    if (!p.second.empty()) {\n      p.second.root_iterator().value().tree_id = trees.size();\n      trees.push_back(std::move(p.second));\n      set_parent(trees.size() - 1, last_in_path(tree_id));\n    }\n  }\n  void merge_trees(int i, int j) {\n    trees[i].merge_to(std::move(trees[j]));\n    trees[i].root_key().tree_id = i;\n    swap_trees(j, trees.size() - 1);\n    trees.pop_back();\n  }\n  void reverse_tree(int i) {\n    int j = parent_of(i);\n    trees[i].reverse();\n    set_parent(i, j);\n  }\n  void expose(int v) {\n    auto pos = position_of(v);\n    int parent = parent_of(pos.first);\n    while (parent != -1) {\n      auto parent_pos = position_of(parent);\n      split_tree(parent_pos.first, parent_pos.second + 1);\n      merge_trees(parent_pos.first, position_of(v).first);\n      pos = position_of(v);\n      parent = parent_of(pos.first);\n    }\n  }\n  void to_root(int v) {\n    expose(v);\n    auto pos = position_of(v);\n    split_tree(pos.first, pos.second + 1);\n    reverse_tree(pos.first);\n  }\n\n public:\n  link_cut_trees(int sz) : n(sz) {\n    for (int i = 0; i < (int)(n); i++) {\n      trees.push_back(tree_t(node_info(i)));\n      node_it.push_back(trees.back().root_iterator());\n      node_it.back().value().tree_id = i;\n    }\n  }\n  int component_of(int v) {\n    expose(v);\n    return position_of(v).first;\n  }\n  void link(int parent, int child) {\n    to_root(child);\n    set_parent(position_of(child).first, parent);\n  }\n  void cut(int u, int v) {\n    auto pos_u = position_of(u);\n    auto pos_v = position_of(v);\n    if (pos_u.first == pos_v.first) {\n      if (pos_u.second < pos_v.second) {\n        split_tree(pos_u.first, pos_u.second + 1);\n        node_it[v].value().value.parent = -1;\n      } else {\n        split_tree(pos_v.first, pos_v.second + 1);\n        node_it[u].value().value.parent = -1;\n      }\n    } else {\n      if (node_it[v].value().value.parent == u)\n        node_it[v].value().value.parent = -1;\n      else\n        node_it[u].value().value.parent = -1;\n    }\n  }\n  void print_trees() {\n    for (int i = 0; i < (int)(trees.size()); i++) {\n      cout << \"{parent = \" << parent_of(i) << \", path = ( \";\n      trees[i].for_each([](const node_info& v) { cout << v.id << \" \"; });\n      cout << \")}\" << endl;\n    }\n  }\n};\nstruct segment_tree {\n  int n;\n  vector<int> t;\n  vector<int> mod;\n  vector<int> nt;\n  void update(int v) {\n    t[v] = min(t[2 * v + 1] + mod[2 * v + 1], t[2 * v + 2] + mod[2 * v + 2]);\n    if (t[2 * v + 1] + mod[2 * v + 1] < t[2 * v + 2] + mod[2 * v + 2])\n      nt[v] = nt[2 * v + 1];\n    else if (t[2 * v + 1] + mod[2 * v + 1] > t[2 * v + 2] + mod[2 * v + 2])\n      nt[v] = nt[2 * v + 2];\n    else {\n      nt[v] = nt[2 * v + 1] + nt[2 * v + 2];\n    }\n  }\n  void push(int v) {\n    mod[2 * v + 1] += mod[v];\n    mod[2 * v + 2] += mod[v];\n    mod[v] = 0;\n    update(v);\n  }\n  void add(int v, int L, int R, int l, int r, int x) {\n    if (R <= l || r <= L)\n      return;\n    else if (l <= L && R <= r)\n      mod[v] += x;\n    else {\n      push(v);\n      add(2 * v + 1, L, (L + R) / 2, l, r, x);\n      add(2 * v + 2, (L + R) / 2, R, l, r, x);\n      update(v);\n    }\n  }\n  int get_min(int v, int L, int R, int l, int r) {\n    if (R <= l || r <= L)\n      return numeric_limits<int>::max();\n    else if (l <= L && R <= r) {\n      return t[v] + mod[v];\n    } else {\n      push(v);\n      return min(get_min(2 * v + 1, L, (L + R) / 2, l, r),\n                 get_min(2 * v + 2, (L + R) / 2, R, l, r));\n    }\n  }\n  pair<int, int> get_nmins(int v, int L, int R, int l, int r) {\n    if (R <= l || r <= L)\n      return make_pair(numeric_limits<int>::max(), 0);\n    else if (l <= L && R <= r) {\n      return make_pair(t[v] + mod[v], nt[v]);\n    } else {\n      push(v);\n      auto a = get_nmins(2 * v + 1, L, (L + R) / 2, l, r);\n      auto b = get_nmins(2 * v + 2, (L + R) / 2, R, l, r);\n      if (a.first < b.first)\n        return a;\n      else if (a.first > b.first)\n        return b;\n      else\n        return make_pair(a.first, a.second + b.second);\n    }\n  }\n  void build(int v, int L, int R) {\n    if (L == R - 1)\n      nt[v] = 1;\n    else {\n      build(2 * v + 1, L, (L + R) / 2);\n      build(2 * v + 2, (L + R) / 2, R);\n      update(v);\n    }\n  }\n\n public:\n  segment_tree(int _n) : n(_n) {\n    t.resize(4 * n);\n    mod.resize(4 * n);\n    nt.resize(4 * n);\n    build(0, 0, n);\n  }\n  void add(int l, int r, int x) { add(0, 0, n, l, r, x); }\n  int get_min(int l, int r) { return get_min(0, 0, n, l, r); }\n  int get_nmins(int l, int r) { return get_nmins(0, 0, n, l, r).second; }\n};\nbool ok(int i, int j, int n, int m) {\n  return i >= 0 && i < n && j >= 0 && j < m;\n}\nconst int dx[] = {0, 0, -1, 1};\nconst int dy[] = {-1, 1, 0, 0};\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<vector<int>> a(n);\n  for (int i = 0; i < (int)(n); i++) {\n    a[i].resize(m);\n    for (int j = 0; j < (int)(m); j++) {\n      cin >> a[i][j];\n      a[i][j]--;\n    }\n  }\n  vector<int> x(n * m), y(n * m);\n  for (int i = 0; i < (int)(n); i++) {\n    for (int j = 0; j < (int)(m); j++) {\n      x[a[i][j]] = i;\n      y[a[i][j]] = j;\n    }\n  }\n  link_cut_trees lct(n * m);\n  segment_tree st(n * m);\n  long long ans = 0;\n  int l = 0;\n  for (int r = 0; r < (int)(n * m); r++) {\n    for (int k = 0; k < 4; k++) {\n      int nx = x[r] + dx[k];\n      int ny = y[r] + dy[k];\n      if (!ok(nx, ny, n, m)) continue;\n      if (a[nx][ny] > r) continue;\n      while (a[nx][ny] >= l &&\n             lct.component_of(a[nx][ny]) == lct.component_of(r)) {\n        for (int t = 0; t < 4; t++) {\n          int nxt = x[l] + dx[t];\n          int nyt = y[l] + dy[t];\n          if (!ok(nxt, nyt, n, m)) continue;\n          if (a[nxt][nyt] < l || a[nxt][nyt] > r) continue;\n          lct.cut(l, a[nxt][nyt]);\n        }\n        l++;\n      }\n      if (a[nx][ny] >= l) {\n        lct.link(r, a[nx][ny]);\n      }\n    }\n    st.add(l, r + 1, 1);\n    for (int k = 0; k < 4; k++) {\n      int nx = x[r] + dx[k];\n      int ny = y[r] + dy[k];\n      if (!ok(nx, ny, n, m)) continue;\n      if (a[nx][ny] < l || a[nx][ny] > r) continue;\n      st.add(l, a[nx][ny] + 1, -1);\n    }\n    ans += st.get_nmins(l, r + 1);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, lim, a[1010][1010], dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\npair<int, int> p[1000100];\nlong long res;\nnamespace LCT {\nstruct Link_Cut_Tree {\n  int fa, ch[2];\n  bool rev;\n} t[200100];\ninline int identify(int x) {\n  if (x == t[t[x].fa].ch[0]) return 0;\n  if (x == t[t[x].fa].ch[1]) return 1;\n  return -1;\n}\ninline void REV(int x) { t[x].rev ^= 1, swap(t[x].ch[0], t[x].ch[1]); }\ninline void pushdown(int x) {\n  if (!t[x].rev) return;\n  if (t[x].ch[0]) REV(t[x].ch[0]);\n  if (t[x].ch[1]) REV(t[x].ch[1]);\n  t[x].rev = 0;\n}\ninline void rotate(int x) {\n  register int y = t[x].fa, z = t[y].fa, dirx = identify(x), diry = identify(y),\n               b = t[x].ch[!dirx];\n  if (diry != -1) t[z].ch[diry] = x;\n  t[x].fa = z;\n  if (b) t[b].fa = y;\n  t[y].ch[dirx] = b;\n  t[y].fa = x, t[x].ch[!dirx] = y;\n}\ninline void pushall(int x) {\n  if (identify(x) != -1) pushall(t[x].fa);\n  pushdown(x);\n}\ninline void splay(int x) {\n  for (pushall(x); identify(x) != -1; rotate(x))\n    if (identify(t[x].fa) != -1)\n      rotate(identify(x) == identify(t[x].fa) ? t[x].fa : x);\n}\ninline void access(int x) {\n  for (register int y = 0; x; x = t[y = x].fa) splay(x), t[x].ch[1] = y;\n}\ninline void makeroot(int x) { access(x), splay(x), REV(x); }\ninline int findroot(int x) {\n  access(x), splay(x), pushdown(x);\n  while (t[x].ch[0]) x = t[x].ch[0], pushdown(x);\n  splay(x);\n  return x;\n}\ninline void split(int x, int y) { makeroot(x), access(y), splay(y); }\ninline bool link(int x, int y) {\n  if (findroot(x) == findroot(y)) return false;\n  makeroot(x), t[x].fa = y;\n  return true;\n}\ninline void cut(int x, int y) { split(x, y), t[y].ch[0] = t[x].fa = 0; }\n}  // namespace LCT\nnamespace SG {\nstruct SegTree {\n  int mn, num, tag;\n} seg[800100];\nvoid ADD(int x, int y) { seg[x].mn += y, seg[x].tag += y; }\nvoid pushdown(int x) {\n  ADD(x << 1, seg[x].tag), ADD(x << 1 | 1, seg[x].tag), seg[x].tag = 0;\n}\nvoid pushup(int x) {\n  seg[x].mn = min(seg[x << 1].mn, seg[x << 1 | 1].mn), seg[x].num = 0;\n  if (seg[x].mn == seg[x << 1].mn) seg[x].num += seg[x << 1].num;\n  if (seg[x].mn == seg[x << 1 | 1].mn) seg[x].num += seg[x << 1 | 1].num;\n}\nvoid build(int x, int l, int r) {\n  if (l == r) {\n    seg[x].mn = 0, seg[x].num = 1;\n    return;\n  }\n  build(x << 1, l, ((l + r) >> 1)), build(x << 1 | 1, ((l + r) >> 1) + 1, r),\n      pushup(x);\n}\nvoid modify(int x, int l, int r, int L, int R, int val) {\n  if (l > R || r < L) return;\n  if (L <= l && r <= R) {\n    ADD(x, val);\n    return;\n  }\n  pushdown(x), modify(x << 1, l, ((l + r) >> 1), L, R, val),\n      modify(x << 1 | 1, ((l + r) >> 1) + 1, r, L, R, val), pushup(x);\n}\nint query(int x, int l, int r, int L, int R) {\n  if (l > R || r < L) return 0;\n  if (L <= l && r <= R) return seg[x].mn == 1 ? seg[x].num : 0;\n  pushdown(x);\n  return query(x << 1, l, ((l + r) >> 1), L, R) +\n         query(x << 1 | 1, ((l + r) >> 1) + 1, r, L, R);\n}\n}  // namespace SG\nint main() {\n  scanf(\"%d%d\", &n, &m), lim = n * m;\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      scanf(\"%d\", &a[i][j]), p[a[i][j]] = make_pair(i, j);\n  SG::build(1, 1, lim);\n  for (int l = 1, r = 1; l <= lim; l++) {\n    while (r <= lim) {\n      int x = p[r].first, y = p[r].second;\n      int cnt = 0;\n      for (int i = 0; i < 4; i++) {\n        if (!(a[x + dx[i]][y + dy[i]] >= l && a[x + dx[i]][y + dy[i]] < r))\n          continue;\n        cnt++;\n        if (LCT::link(r, a[x + dx[i]][y + dy[i]])) continue;\n        for (i--; i >= 0; i--)\n          if (a[x + dx[i]][y + dy[i]] >= l && a[x + dx[i]][y + dy[i]] < r)\n            LCT::cut(r, a[x + dx[i]][y + dy[i]]);\n        cnt = -1;\n        break;\n      }\n      if (cnt == -1) break;\n      SG::modify(1, 1, lim, r, lim, -cnt);\n      SG::modify(1, 1, lim, r, r, r - l + 1);\n      r++;\n    }\n    res += SG::query(1, 1, lim, l, r - 1);\n    SG::modify(1, 1, lim, l, r - 1, -1);\n    int x = p[l].first, y = p[l].second;\n    for (int i = 0; i < 4; i++)\n      if (a[x + dx[i]][y + dy[i]] >= l && a[x + dx[i]][y + dy[i]] < r)\n        LCT::cut(l, a[x + dx[i]][y + dy[i]]),\n            SG::modify(1, 1, lim, a[x + dx[i]][y + dy[i]], lim, 1);\n  }\n  printf(\"%lld\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1005;\nconst int M = 200005;\nconst int INF = 1 << 30;\nint n, m, a[N][N];\npair<int, int> p[M];\nlong long ans;\nnamespace TR {\npair<int, int> t[M * 4];\nint tg[M * 4];\nvoid build(int k, int l, int r) {\n  t[k] = pair<int, int>(-INF, r - l + 1);\n  if (l == r) return;\n  int mid = (l + r) / 2;\n  build(k * 2, l, mid);\n  build(k * 2 + 1, mid + 1, r);\n}\nvoid add(int k, int v) {\n  t[k].first += v;\n  tg[k] += v;\n}\nvoid pushdown(int k) {\n  if (!tg[k]) return;\n  add(k * 2, tg[k]);\n  add(k * 2 + 1, tg[k]);\n  tg[k] = 0;\n}\nvoid pushup(int k) {\n  t[k] = pair<int, int>(max(t[k * 2].first, t[k * 2 + 1].first), 0);\n  if (t[k].first == t[k * 2].first) t[k].second += t[k * 2].second;\n  if (t[k].first == t[k * 2 + 1].first) t[k].second += t[k * 2 + 1].second;\n}\nvoid change(int k, int l, int r, int x, int y, int v) {\n  if (x <= l && r <= y) return add(k, v);\n  pushdown(k);\n  int mid = (l + r) / 2;\n  if (x <= mid) change(k * 2, l, mid, x, y, v);\n  if (y > mid) change(k * 2 + 1, mid + 1, r, x, y, v);\n  pushup(k);\n}\n}  // namespace TR\nnamespace LCT {\nint fa[M], rev[M];\nint ch[M][2];\nbool isroot(int k) { return ch[fa[k]][0] != k && ch[fa[k]][1] != k; }\nvoid rever(int k) {\n  swap(ch[k][0], ch[k][1]);\n  rev[k] ^= 1;\n}\nvoid pushdown(int k) {\n  if (!rev[k]) return;\n  if (ch[k][0]) rever(ch[k][0]);\n  if (ch[k][1]) rever(ch[k][1]);\n  rev[k] = 0;\n}\nvoid Down(int k) {\n  if (!isroot(k)) Down(fa[k]);\n  pushdown(k);\n}\nvoid rotate(int x) {\n  int y = fa[x], z = fa[y];\n  int l = (ch[y][1] == x), r = l ^ 1;\n  if (!isroot(y)) ch[z][ch[z][1] == y] = x;\n  fa[x] = z;\n  fa[y] = x;\n  fa[ch[x][r]] = y;\n  ch[y][l] = ch[x][r];\n  ch[x][r] = y;\n}\nvoid splay(int x) {\n  Down(x);\n  for (; !isroot(x); rotate(x)) {\n    int y = fa[x], z = fa[y];\n    if (!isroot(y)) rotate((ch[z][0] == y) ^ (ch[y][0] == x) ? x : y);\n  }\n}\nvoid access(int x) {\n  for (int t = 0; x; t = x, x = fa[x]) splay(x), ch[x][1] = t;\n}\nvoid makeroot(int x) {\n  access(x);\n  splay(x);\n  rever(x);\n}\nvoid link(int x, int y) {\n  makeroot(x);\n  fa[x] = y;\n}\nvoid cut(int x, int y) {\n  makeroot(x);\n  access(y);\n  splay(y);\n  ch[y][0] = fa[x] = 0;\n}\nint find_rt(int x) {\n  access(x);\n  splay(x);\n  for (; ch[x][0]; x = ch[x][0])\n    ;\n  splay(x);\n  return x;\n}\n}  // namespace LCT\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nbool jud(int l, int r) {\n  static int q[10];\n  int px = p[l].first, py = p[l].second;\n  *q = 0;\n  for (int d = (int)(0); d <= (int)(3); d++) {\n    int nx = px + dx[d], ny = py + dy[d];\n    if (l < a[nx][ny] && a[nx][ny] <= r) q[++*q] = LCT::find_rt(a[nx][ny]);\n  }\n  for (int i = (int)(1); i <= (int)(*q); i++)\n    for (int j = (int)(i + 1); j <= (int)(*q); j++)\n      if (q[i] == q[j]) return 0;\n  return 1;\n}\nvoid erase(int l, int r) {\n  TR::change(1, 1, n * m, r, r, -INF);\n  int px = p[r].first, py = p[r].second;\n  for (int d = (int)(0); d <= (int)(3); d++) {\n    int nx = px + dx[d], ny = py + dy[d];\n    if (l < a[nx][ny] && a[nx][ny] <= r) {\n      TR::change(1, 1, n * m, a[px][py], n * m, 1);\n      LCT::cut(a[px][py], a[nx][ny]);\n    }\n  }\n}\nvoid insert(int l, int r) {\n  TR::change(1, 1, n * m, l, l, INF);\n  int px = p[l].first, py = p[l].second;\n  for (int d = (int)(0); d <= (int)(3); d++) {\n    int nx = px + dx[d], ny = py + dy[d];\n    if (l <= a[nx][ny] && a[nx][ny] <= r) {\n      TR::change(1, 1, n * m, a[nx][ny], n * m, 1);\n      LCT::link(a[px][py], a[nx][ny]);\n    }\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = (int)(1); i <= (int)(n); i++)\n    for (int j = (int)(1); j <= (int)(m); j++) {\n      scanf(\"%d\", &a[i][j]);\n      p[a[i][j]] = pair<int, int>(i, j);\n    }\n  TR::build(1, 1, n * m);\n  int p = n * m;\n  for (int i = (int)(n * m); i >= (int)(1); i--) {\n    for (; !jud(i, p); erase(i, p--))\n      ;\n    insert(i, p);\n    TR::change(1, 1, n * m, i, n * m, -1);\n    if (TR::t[1].first == -1) ans += TR::t[1].second;\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int D[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1};\nint n, m, p, fa[300000], c[300000][2], stk[300000], rev[300000], T[300000 << 2],\n    a[1200][1200];\nlong long ans;\nbool b[1200][1200];\nstruct cdt {\n  int x, y;\n  cdt(int x = 0, int y = 0) : x(x), y(y) {}\n} pos[300000];\nstruct seg {\n  int x, y;\n  seg(int x = 0, int y = 0) : x(x), y(y) {}\n  seg operator^(const seg &p) const {\n    return x == p.x ? seg(x, y + p.y) : x < p.x ? (*this) : p;\n  }\n} s[300000 << 2];\nbool isrt(int x) { return x != c[fa[x]][0] && x != c[fa[x]][1]; }\nbool dic(int x) { return x == c[fa[x]][1]; }\nvoid rtt(int x) {\n  int y = fa[x], dx = dic(x), dy = dic(y);\n  c[y][dx] = c[x][dx ^ 1];\n  fa[c[x][dx ^ 1]] = y;\n  fa[x] = fa[y];\n  if (!isrt(y)) c[fa[y]][dy] = x;\n  c[x][dx ^ 1] = y;\n  fa[y] = x;\n}\nvoid psd(int x) {\n  if (rev[x]) {\n    rev[c[x][0]] ^= 1;\n    rev[c[x][1]] ^= 1;\n    swap(c[x][0], c[x][1]);\n    rev[x] = 0;\n  }\n}\nvoid splay(int x) {\n  int tp;\n  stk[tp = 1] = x;\n  for (int t = x; !isrt(t); t = fa[t]) stk[++tp] = fa[t];\n  for (; tp; --tp) psd(stk[tp]);\n  for (int y; !isrt(x); rtt(x))\n    if (!isrt(y = fa[x])) rtt(dic(x) ^ dic(y) ? x : y);\n}\nvoid acs(int x) {\n  for (int t = 0; x; t = x, x = fa[x]) {\n    splay(x);\n    c[x][1] = t;\n  }\n}\nint fdrt(int x) {\n  acs(x);\n  splay(x);\n  for (psd(x); c[x][0]; x = c[x][0], psd(x))\n    ;\n  splay(x);\n  return x;\n}\nvoid mrt(int x) {\n  acs(x);\n  splay(x);\n  rev[x] ^= 1;\n}\nvoid link(int x, int y) {\n  mrt(x);\n  fa[x] = y;\n}\nvoid cut(int x, int y) {\n  mrt(x);\n  acs(y);\n  splay(y);\n  c[y][0] = fa[x] = 0;\n}\nvoid build(int x, int l, int r) {\n  if (l == r) {\n    s[x] = seg(l, 1);\n    return;\n  }\n  int mid = (l + r) >> 1;\n  build((x << 1), l, mid);\n  build((x << 1 | 1), mid + 1, r);\n  s[x] = s[(x << 1)] ^ s[(x << 1 | 1)];\n}\nvoid pushdown(int x) {\n  s[(x << 1)].x += T[x];\n  s[(x << 1 | 1)].x += T[x];\n  T[(x << 1)] += T[x];\n  T[(x << 1 | 1)] += T[x];\n  T[x] = 0;\n}\nvoid add(int x, int l, int r, int L, int k) {\n  if (l >= L) {\n    s[x].x += k;\n    T[x] += k;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  pushdown(x);\n  if (L <= mid) add((x << 1), l, mid, L, k);\n  add((x << 1 | 1), mid + 1, r, L, k);\n  s[x] = s[(x << 1)] ^ s[(x << 1 | 1)];\n}\nseg qry(int x, int l, int r, int L, int R) {\n  if (l >= L && r <= R) return s[x];\n  int mid = (l + r) >> 1;\n  seg ret = seg(0x3f3f3f3f, 0);\n  pushdown(x);\n  if (L <= mid) ret = ret ^ qry((x << 1), l, mid, L, R);\n  if (R > mid) ret = ret ^ qry((x << 1 | 1), mid + 1, r, L, R);\n  return ret;\n}\nvoid LINK(cdt P) {\n  int x = P.x, y = P.y;\n  b[x][y] = 1;\n  for (int i = 0; i < 4; ++i) {\n    int nx = x + D[i][0], ny = y + D[i][1];\n    if (b[nx][ny]) {\n      add(1, 1, p, a[x][y], -1);\n      link((((x)-1) * m + (y)), (((nx)-1) * m + (ny)));\n    }\n  }\n}\nvoid CUT(cdt P) {\n  int x = P.x, y = P.y;\n  b[x][y] = 0;\n  for (int i = 0; i < 4; ++i) {\n    int nx = x + D[i][0], ny = y + D[i][1];\n    if (b[nx][ny]) {\n      add(1, 1, p, a[nx][ny], 1);\n      cut((((x)-1) * m + (y)), (((nx)-1) * m + (ny)));\n    }\n  }\n}\nbool ok(cdt P) {\n  int fl[4] = {};\n  int x = P.x, y = P.y;\n  for (int i = 0; i < 4; ++i) {\n    int nx = x + D[i][0], ny = y + D[i][1];\n    if (b[nx][ny]) fl[i] = fdrt((((nx)-1) * m + (ny)));\n  }\n  for (int i = 0; i < 4; ++i)\n    if (fl[i])\n      for (int j = 0; j < i; ++j)\n        if (fl[j])\n          if (fl[i] == fl[j]) return 0;\n  return 1;\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  p = n * m;\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j) {\n      scanf(\"%d\", a[i] + j);\n      pos[a[i][j]] = cdt(i, j);\n    }\n  build(1, 1, p);\n  for (int l = 1, r = 1; l <= p; ++l) {\n    for (; r <= p && ok(pos[r]); ++r) LINK(pos[r]);\n    seg t = qry(1, 1, p, l, r - 1);\n    if (t.x == l) ans += t.y;\n    CUT(pos[l]);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int gi() {\n  char c = getchar();\n  while (c < '0' || c > '9') c = getchar();\n  int sum = 0;\n  while ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();\n  return sum;\n}\nconst int maxn = 200005;\nconst int d[4][2] = {0, 1, 0, -1, 1, 0, -1, 0};\nint n, m, N;\nint f[maxn], ch[maxn][2], rev[maxn], x[maxn], y[maxn];\nint p[1005][1005];\ninline void rotate(int x) {\n  int fa = f[x], gfa = f[fa], k = (ch[f[x]][1] == x);\n  ch[fa][k] = ch[x][k ^ 1];\n  f[ch[x][k ^ 1]] = fa;\n  ch[x][k ^ 1] = fa;\n  if (!(ch[f[fa]][0] != fa && ch[f[fa]][1] != fa))\n    ch[gfa][(ch[f[fa]][1] == fa)] = x;\n  f[fa] = x;\n  f[x] = gfa;\n}\ninline void pushdown(int x) {\n  if (!rev[x]) return;\n  if (ch[x][0]) (swap(ch[ch[x][0]][0], ch[ch[x][0]][1]), rev[ch[x][0]] ^= 1);\n  if (ch[x][1]) (swap(ch[ch[x][1]][0], ch[ch[x][1]][1]), rev[ch[x][1]] ^= 1);\n  rev[x] = 0;\n}\ninline void splay(int x) {\n  static int stk[maxn], top, fa;\n  stk[top = 1] = x;\n  while (!(ch[f[x]][0] != x && ch[f[x]][1] != x)) stk[++top] = x = f[x];\n  while (top) pushdown(stk[top--]);\n  x = stk[1];\n  while (!(ch[f[x]][0] != x && ch[f[x]][1] != x)) {\n    fa = f[x];\n    if (!(ch[f[fa]][0] != fa && ch[f[fa]][1] != fa))\n      (ch[f[x]][1] == x) ^ (ch[f[fa]][1] == fa) ? rotate(x) : rotate(fa);\n    rotate(x);\n  }\n}\ninline void access(int x) {\n  for (int y = 0; x; y = x, x = f[x]) splay(x), ch[x][1] = y;\n}\ninline void make_root(int x) {\n  access(x);\n  splay(x);\n  (swap(ch[x][0], ch[x][1]), rev[x] ^= 1);\n}\ninline void link(int x, int y) {\n  make_root(x);\n  make_root(y);\n  f[y] = x;\n}\ninline void cut(int x, int y) {\n  make_root(x);\n  access(y);\n  splay(y);\n  ch[y][0] = f[x] = 0;\n}\ninline int find(int x) {\n  access(x);\n  splay(x);\n  while (ch[x][0]) x = ch[x][0];\n  splay(x);\n  return x;\n}\nint Min[maxn << 2], sum[maxn << 2], tag[maxn << 2];\nvoid build(int s, int l, int r) {\n  if (l == r) return Min[s] = 0, sum[s] = 1, void();\n  build((s << 1), l, ((l + r) >> 1));\n  build((s << 1 | 1), ((l + r) >> 1) + 1, r);\n  if (Min[(s << 1)] == Min[(s << 1 | 1)])\n    sum[s] = sum[(s << 1)] + sum[(s << 1 | 1)];\n  else if (Min[(s << 1)] < Min[(s << 1 | 1)])\n    sum[s] = sum[(s << 1)];\n  else\n    sum[s] = sum[(s << 1 | 1)];\n  Min[s] += tag[s];\n}\nvoid insert(int s, int l, int r, int ql, int qr, int v) {\n  if (ql <= l && r <= qr) return tag[s] += v, Min[s] += v, void();\n  if (ql <= ((l + r) >> 1)) insert((s << 1), l, ((l + r) >> 1), ql, qr, v);\n  if (qr >= ((l + r) >> 1) + 1)\n    insert((s << 1 | 1), ((l + r) >> 1) + 1, r, ql, qr, v);\n  if (Min[(s << 1)] == Min[(s << 1 | 1)])\n    sum[s] = sum[(s << 1)] + sum[(s << 1 | 1)];\n  else if (Min[(s << 1)] < Min[(s << 1 | 1)])\n    sum[s] = sum[(s << 1)];\n  else\n    sum[s] = sum[(s << 1 | 1)];\n  Min[s] = min(Min[(s << 1)], Min[(s << 1 | 1)]) + tag[s];\n}\npair<int, int> operator+(pair<int, int> a, pair<int, int> b) {\n  return a.first == b.first ? make_pair(a.first, a.second + b.second)\n                            : min(a, b);\n}\npair<int, int> query(int s, int l, int r, int ql, int qr) {\n  if (ql <= l && r <= qr) return make_pair(Min[s], sum[s]);\n  pair<int, int> res(1e9, 0);\n  if (ql <= ((l + r) >> 1)) res = query((s << 1), l, ((l + r) >> 1), ql, qr);\n  if (qr >= ((l + r) >> 1) + 1)\n    res = res + query((s << 1 | 1), ((l + r) >> 1) + 1, r, ql, qr);\n  res.first += tag[s];\n  return res;\n}\nint check(int l, int r) {\n  for (int x1, y1, i = 0; i < 4; ++i) {\n    x1 = x[r] + d[i][0];\n    y1 = y[r] + d[i][1];\n    if (p[x1][y1] < l || p[x1][y1] >= r) continue;\n    for (int x2, y2, j = i + 1; j < 4; ++j) {\n      x2 = x[r] + d[j][0];\n      y2 = y[r] + d[j][1];\n      if (p[x2][y2] < l || p[x2][y2] >= r) continue;\n      if (find(p[x1][y1]) == find(p[x2][y2])) return 1;\n    }\n  }\n  return 0;\n}\nvoid add(int t, int v, int l, int r) {\n  insert(1, 1, N, 1, t, v);\n  for (int x1, y1, i = 0; i < 4; ++i) {\n    x1 = x[t] + d[i][0];\n    y1 = y[t] + d[i][1];\n    if (p[x1][y1] < l || p[x1][y1] >= r) continue;\n    insert(1, 1, N, 1, min(t, p[x1][y1]), -v);\n    if (v > 0)\n      assert(find(p[x1][y1]) != find(t)), link(p[x1][y1], t);\n    else\n      assert(find(p[x1][y1]) == find(t)), cut(p[x1][y1], t);\n  }\n}\nint main() {\n  n = gi();\n  m = gi();\n  N = n * m;\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j) p[i][j] = gi(), x[p[i][j]] = i, y[p[i][j]] = j;\n  long long ans = 0;\n  pair<int, int> res;\n  build(1, 1, N);\n  for (int r = 1, l = 1; r <= N; ++r) {\n    while (l < r && check(l, r)) {\n      add(l, -1, l, r), ++l;\n    }\n    add(r, 1, l, r);\n    res = query(1, 1, N, l, r);\n    ans += res.first == 1 ? res.second : 0;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct StVal {\n  int minV = 0, numMin = 0;\n  StVal() {}\n  StVal(const int _v) : minV(_v), numMin(1) {}\n  StVal(const StVal& v1, const StVal& v2) {\n    if (v1.minV < v2.minV) {\n      minV = v1.minV;\n      numMin = v1.numMin;\n    } else if (v1.minV > v2.minV) {\n      minV = v2.minV;\n      numMin = v2.numMin;\n    } else {\n      minV = v1.minV;\n      numMin = v1.numMin + v2.numMin;\n    }\n  }\n};\nstruct StUpdate {\n  int v = 0;\n  StUpdate() {}\n  StUpdate(const int v) : v(v) {}\n  StUpdate(const StUpdate& u1, const StUpdate& u2) { v = u1.v + u2.v; }\n  void apply(StVal& sv, const int lo, const int hi) { sv.minV += v; }\n};\nstruct SegTree {\n  int n;\n  vector<StVal> st;\n  vector<StUpdate> lazy;\n  vector<int> leaves;\n  SegTree(const int n) : n(n) {\n    leaves.resize(n);\n    init(1, 0, n - 1);\n    lazy.resize(st.size());\n  }\n  void init(const int si, const int lo, const int hi) {\n    if (lo == hi) {\n      if (si >= (int)st.size()) {\n        st.resize(si + 1);\n      }\n      st[si] = StVal(0);\n      leaves[lo] = si;\n      return;\n    }\n    int lC = si << 1, rC = (si << 1) | 1, mid = (lo + hi) >> 1;\n    init(lC, lo, mid);\n    init(rC, mid + 1, hi);\n    st[si] = StVal(st[lC], st[rC]);\n  }\n  void updateLazy(const int si, const int lo, const int hi) {\n    lazy[si].apply(st[si], lo, hi);\n    if (lo != hi) {\n      lazy[si << 1] = StUpdate(lazy[si << 1], lazy[si]);\n      lazy[si << 1 | 1] = StUpdate(lazy[si << 1 | 1], lazy[si]);\n    }\n    lazy[si] = StUpdate();\n  }\n  StVal query(const int l, const int r) {\n    return (l <= r && l < n && r >= 0) ? query(l, r, 1, 0, n - 1) : StVal();\n  }\n  StVal query(const int l, const int r, const int si, const int lo,\n              const int hi) {\n    updateLazy(si, lo, hi);\n    if (l <= lo && hi <= r) return st[si];\n    const int mid = (lo + hi) >> 1;\n    if (r <= mid) return query(l, r, si << 1, lo, mid);\n    if (mid < l) return query(l, r, si << 1 | 1, mid + 1, hi);\n    return StVal(query(l, r, si << 1, lo, mid),\n                 query(l, r, si << 1 | 1, mid + 1, hi));\n  }\n  void update(const int l, const int r, const StUpdate u) {\n    if (l <= r) update(l, r, u, 1, 0, n - 1);\n  }\n  void update(const int l, const int r, const StUpdate& u, const int si,\n              const int lo, const int hi) {\n    if (l <= lo && hi <= r) {\n      lazy[si] = StUpdate(lazy[si], u);\n      updateLazy(si, lo, hi);\n    } else {\n      updateLazy(si, lo, hi);\n      if (hi < l || r < lo) return;\n      const int mid = (lo + hi) >> 1;\n      update(l, r, u, si << 1, lo, mid);\n      update(l, r, u, si << 1 | 1, mid + 1, hi);\n      st[si] = StVal(st[si << 1], st[si << 1 | 1]);\n    }\n  }\n  void updateAllLazy() { updateAllLazy(1, 0, n - 1); }\n  void updateAllLazy(const int si, const int lo, const int hi) {\n    updateLazy(si, lo, hi);\n    if (lo != hi) {\n      const int mid = (lo + hi) >> 1;\n      updateAllLazy(si << 1, lo, mid);\n      updateAllLazy(si << 1 | 1, mid + 1, hi);\n    }\n  }\n};\nstruct Node {\n  array<Node*, 2> child{};\n  Node* splayTreeParent = nullptr;\n  Node* pathParentPointer = nullptr;\n  bool reverse = false;\n  Node() {}\n  bool getSide() {\n    return splayTreeParent ? splayTreeParent->child[1] == this : false;\n  }\n  void tryReverse() {\n    if (!reverse) {\n      return;\n    }\n    reverse = false;\n    swap(child[0], child[1]);\n    if (child[0]) {\n      child[0]->reverse = !child[0]->reverse;\n    }\n    if (child[1]) {\n      child[1]->reverse = !child[1]->reverse;\n    }\n  }\n  Node* splay() {\n    vector<Node*> ancestors;\n    Node* cur = this;\n    while (cur) {\n      ancestors.push_back(cur);\n      cur = cur->splayTreeParent;\n    }\n    for (int i = ancestors.size() - 1; i >= 0; i--) {\n      if (!ancestors[i]) {\n        continue;\n      }\n      ancestors[i]->tryReverse();\n    }\n    while (splayTreeParent) {\n      if (splayTreeParent->splayTreeParent) {\n        (getSide() == splayTreeParent->getSide() ? splayTreeParent : this)\n            ->rotate();\n      }\n      rotate();\n    }\n    return this;\n  }\n  Node* rotate() {\n    bool side = getSide(), parentSide = splayTreeParent->getSide();\n    auto ancestor = splayTreeParent->splayTreeParent;\n    pathParentPointer = splayTreeParent->pathParentPointer;\n    splayTreeParent->pathParentPointer = nullptr;\n    splayTreeParent->attach(child[!side], side);\n    attach(splayTreeParent, !side);\n    if (ancestor)\n      ancestor->attach(this, parentSide);\n    else\n      splayTreeParent = nullptr;\n    return this;\n  }\n  Node* attach(Node* node, int side) {\n    if (node) node->splayTreeParent = this;\n    child[side] = node;\n    return this;\n  }\n};\nstruct LinkCutTreeGeneral {\n  void link(Node* parent, Node* child) {\n    assert(findRoot(child) != findRoot(parent));\n    access(child);\n    access(parent);\n    Node* lChild = child->child[0];\n    if (lChild) {\n      lChild->reverse = !lChild->reverse;\n      detachChild(child, 0);\n    }\n    child->attach(parent, 0);\n  }\n  void cut(Node* u) {\n    access(u);\n    if (!u->child[0]) {\n      return;\n    }\n    u->child[0]->splayTreeParent = nullptr;\n    u->child[0] = nullptr;\n  }\n  void cut(Node* u, Node* v) {\n    access(u);\n    if (u->child[0] && findMax(u->child[0]) == v) {\n      cut(u);\n    } else {\n      cut(v);\n    }\n  }\n  Node* findRoot(Node* u) {\n    access(u);\n    while (u->child[0]) {\n      u = u->child[0];\n    }\n    access(u);\n    return u;\n  }\n\n private:\n  Node* access(Node* u) {\n    u->splay();\n    detachChild(u, 1);\n    Node* curPP = u;\n    while (u->pathParentPointer) {\n      curPP = u->pathParentPointer;\n      curPP->splay();\n      detachChild(curPP, 1);\n      curPP->attach(u, 1);\n      u->pathParentPointer = nullptr;\n      u->splay();\n    }\n    return curPP;\n  }\n  Node* findMax(Node* u) {\n    if (!u) {\n      return nullptr;\n    }\n    while (u->child[1]) {\n      u = u->child[1];\n    }\n    u->splay();\n    return u;\n  }\n  void detachChild(Node* u, bool b) {\n    if (!u->child[b]) {\n      return;\n    }\n    u->child[b]->pathParentPointer = u;\n    u->child[b]->splayTreeParent = nullptr;\n    u->child[b] = nullptr;\n  }\n};\nstruct NodeWithId : Node {\n  int id;\n  NodeWithId(int id) : Node(), id(id) {}\n};\nstruct DynamicTreeLCT {\n  LinkCutTreeGeneral lct;\n  vector<NodeWithId*> nodes;\n  int n = 0;\n  DynamicTreeLCT() {}\n  int addNode() {\n    nodes.push_back(new NodeWithId(n));\n    return n++;\n  }\n  void link(int parentId, int childId) {\n    lct.link(nodes[parentId], nodes[childId]);\n  }\n  void cut(int id) { lct.cut(nodes[id]); }\n  void cut(int u, int v) { lct.cut(nodes[u], nodes[v]); }\n  int findRoot(int u) {\n    auto res = (NodeWithId*)lct.findRoot(nodes[u]);\n    return res->id;\n  }\n  bool connected(int u, int v) { return findRoot(u) == findRoot(v); }\n};\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nvector<int> numToID;\nint n, m;\nvoid cutNeighbors(DynamicTreeLCT& lct, vector<vector<int>>& grid, int l) {\n  int i = numToID[l] / m, j = numToID[l] % m;\n  int idx = numToID[l];\n  for (int k = 0; k < 4; k++) {\n    int ni = i + dx[k], nj = j + dy[k];\n    if (ni < 0 || nj < 0 || ni == n || nj == m) {\n      continue;\n    }\n    int nIdx = numToID[grid[ni][nj]];\n    if (lct.connected(idx, nIdx)) {\n      lct.cut(idx, nIdx);\n    }\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0), cout.tie(0);\n  DynamicTreeLCT lct;\n  cin >> n >> m;\n  vector<vector<int>> grid(n, vector<int>(m));\n  numToID.resize(n * m + 1);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      cin >> grid[i][j];\n      numToID[grid[i][j]] = lct.addNode();\n    }\n  }\n  SegTree st(n * m + 1);\n  long long ans = 0;\n  int l = 1;\n  for (int r = 1; r <= m * n; r++) {\n    st.update(l, r, StUpdate(1));\n    int i = numToID[r] / m, j = numToID[r] % m;\n    int idx = numToID[r];\n    for (int k = 0; k < 4; k++) {\n      int ni = i + dx[k], nj = j + dy[k];\n      if (ni < 0 || nj < 0 || ni == n || nj == m) {\n        continue;\n      }\n      if (grid[ni][nj] < l || grid[ni][nj] > r) {\n        continue;\n      }\n      int nIdx = numToID[grid[ni][nj]];\n      while (lct.connected(idx, nIdx)) {\n        cutNeighbors(lct, grid, l);\n        l++;\n      }\n      if (l > grid[ni][nj]) {\n        continue;\n      }\n      if (l == r) {\n        break;\n      }\n      lct.link(idx, nIdx);\n      st.update(l, grid[ni][nj], StUpdate(-1));\n    }\n    ans += st.query(l, r).numMin;\n  }\n  cout << ans << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = pair<int, int>;\nconst int mod = 1e9 + 7;\nconst int MAXN = 250005;\nconst int MAXT = 530000;\nstruct node {\n  node *l, *r, *p, *pp;\n  int rev;\n  node() {\n    l = r = p = pp = NULL;\n    rev = 0;\n  }\n  node(int x) {\n    l = r = p = pp = NULL;\n    rev = 0;\n  }\n  void push() {\n    if (rev) {\n      if (l) l->rev ^= 1;\n      if (r) r->rev ^= 1;\n      rev = 0;\n      swap(l, r);\n    }\n  }\n  void pull() {}\n  void setLeft(node *p) {\n    push();\n    l = p;\n    p->p = this;\n    pull();\n  }\n  void setRight(node *p) {\n    push();\n    r = p;\n    p->p = this;\n    pull();\n  }\n  void rotate() {\n    node *x = this;\n    if (!x->p) return;\n    x->p->push();\n    x->push();\n    node *p = x->p;\n    bool is_left = (p->l == x);\n    node *b = (is_left ? x->r : x->l);\n    x->p = p->p;\n    if (x->p && x->p->l == p) x->p->l = x;\n    if (x->p && x->p->r == p) x->p->r = x;\n    if (is_left) {\n      if (b) b->p = p;\n      p->l = b;\n      p->p = x;\n      x->r = p;\n    } else {\n      if (b) b->p = p;\n      p->r = b;\n      p->p = x;\n      x->l = p;\n    }\n    p->pull();\n    x->pull();\n    if (p->pp) {\n      x->pp = p->pp;\n      p->pp = NULL;\n    }\n  }\n  void splay() {\n    node *x = this;\n    while (x->p) {\n      node *p = x->p;\n      node *g = p->p;\n      if (g) {\n        if ((p->l == x) ^ (g->l == p))\n          x->rotate();\n        else\n          p->rotate();\n      }\n      x->rotate();\n    }\n  }\n  node *prev() {\n    splay();\n    if (!l) return NULL;\n    auto prv = l;\n    prv->push();\n    while (prv->r) {\n      prv = prv->r;\n      prv->push();\n    }\n    prv->splay();\n    return prv;\n  }\n  node *next() {\n    splay();\n    if (!r) return NULL;\n    auto nxt = r;\n    nxt->push();\n    while (nxt->l) {\n      nxt = nxt->l;\n      nxt->push();\n    }\n    nxt->splay();\n    return nxt;\n  }\n  void access() {\n    splay();\n    push();\n    if (r) {\n      r->pp = this;\n      r->p = NULL;\n      r = NULL;\n    }\n    pull();\n    while (pp) {\n      node *nxt = pp;\n      nxt->splay();\n      nxt->push();\n      if (nxt->r) {\n        nxt->r->pp = nxt;\n        nxt->r->p = NULL;\n        nxt->r = NULL;\n      }\n      pp = NULL;\n      nxt->setRight(this);\n      splay();\n    }\n  }\n  node *root() {\n    access();\n    node *x = this;\n    while (x->l) {\n      x->push();\n      x = x->l;\n    }\n    x->access();\n    return x;\n  }\n  node *par() {\n    access();\n    return prev();\n  }\n  void make_root() {\n    access();\n    rev ^= 1;\n    push();\n  }\n};\nnode *lca(node *s, node *t) {\n  s->access();\n  t->access();\n  s->splay();\n  if (s->pp == NULL) return s;\n  return s->pp;\n}\nvoid link(node *par, node *son) {\n  par->access();\n  son->access();\n  son->rev ^= 1;\n  son->setLeft(par);\n}\nvoid cut(node *p) {\n  p->access();\n  p->push();\n  if (p->l) {\n    p->l->p = NULL;\n    p->l = NULL;\n  }\n  p->pull();\n}\nvoid cut(node *p, node *q) {\n  if (q->par() == p) swap(p, q);\n  cut(p);\n}\nnode *lct[MAXN];\nint n;\npi merge(pi a, pi b) {\n  if (a > b) swap(a, b);\n  if (a.first == b.first) a.second += b.second;\n  return a;\n}\nstruct seg {\n  pi tree[MAXT];\n  int lazy[MAXT];\n  void lazydown(int p) {\n    for (int i = 2 * p; i < 2 * p + 2; i++) {\n      tree[i].first += lazy[p];\n      lazy[i] += lazy[p];\n    }\n    lazy[p] = 0;\n  }\n  void init(int s = 1, int e = n, int p = 1) {\n    if (s == e) {\n      tree[p] = pi(0, 1);\n      return;\n    }\n    int m = (s + e) / 2;\n    init(s, m, 2 * p);\n    init(m + 1, e, 2 * p + 1);\n    tree[p] = merge(tree[2 * p], tree[2 * p + 1]);\n  }\n  pi query(int s, int e, int ps = 1, int pe = n, int p = 1) {\n    if (e < ps || pe < s) return pi(1e9, 0);\n    if (s <= ps && pe <= e) return tree[p];\n    lazydown(p);\n    int pm = (ps + pe) / 2;\n    return merge(query(s, e, ps, pm, 2 * p),\n                 query(s, e, pm + 1, pe, 2 * p + 1));\n  }\n  void add(int s, int e, int x, int ps = 1, int pe = n, int p = 1) {\n    if (e < ps || pe < s) return;\n    if (s <= ps && pe <= e) {\n      tree[p].first += x;\n      lazy[p] += x;\n      return;\n    }\n    lazydown(p);\n    int pm = (ps + pe) / 2;\n    add(s, e, x, ps, pm, 2 * p);\n    add(s, e, x, pm + 1, pe, 2 * p + 1);\n    tree[p] = merge(tree[2 * p], tree[2 * p + 1]);\n  }\n} seg;\nvector<int> gph[MAXN], rev[MAXN];\nint low[MAXN];\nint a[1005][1005];\nint main() {\n  int m;\n  scanf(\"%d %d\", &n, &m);\n  if (n + m == 2) {\n    puts(\"1\");\n    return 0;\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      a[i][j] = i * m + j + 1;\n      scanf(\"%d\", &a[i][j]);\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m - 1; j++) {\n      int l = a[i][j], r = a[i][j + 1];\n      gph[l].push_back(r);\n      gph[r].push_back(l);\n    }\n  }\n  for (int i = 0; i < n - 1; i++) {\n    for (int j = 0; j < m; j++) {\n      int l = a[i][j], r = a[i + 1][j];\n      gph[l].push_back(r);\n      gph[r].push_back(l);\n    }\n  }\n  n = n * m;\n  low[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    sort((gph[i]).begin(), (gph[i]).end());\n  }\n  for (int i = 1; i <= n; i++) lct[i] = new node();\n  priority_queue<pi, vector<pi>, greater<pi>> pq;\n  for (int i = 1; i <= n; i++) {\n    for (auto &j : gph[i]) {\n      if (j > i) break;\n      pq.emplace(j, i);\n      bool good = 1;\n      while (lct[i]->root() == lct[j]->root()) {\n        auto qfr = pq.top();\n        pq.pop();\n        low[i] = max(low[i], qfr.first + 1);\n        if (qfr == pi(j, i)) {\n          good = 0;\n          break;\n        }\n        cut(lct[qfr.first], lct[qfr.second]);\n      }\n      if (good) link(lct[i], lct[j]);\n    }\n  }\n  for (int i = 1; i <= n; i++) low[i] = max(low[i], low[i - 1]);\n  seg.init();\n  lint ret = 0;\n  for (int i = 1; i <= n; i++) {\n    seg.add(1, i, 1);\n    for (auto &j : gph[i]) {\n      if (j > i) break;\n      seg.add(1, j, -1);\n    }\n    auto qr = seg.query(low[i], i);\n    if (qr.first == 1) ret += qr.second;\n  }\n  cout << ret << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 4e5 + 10, M = 2e3 + 10;\ninline int read() {\n  int x = 0, f = 0;\n  char ch = getchar();\n  while (!isdigit(ch)) f |= ch == '-', ch = getchar();\n  while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();\n  return f ? -x : x;\n}\nnamespace LCT {\nint par[N], ch[N][2], rev[N];\ninline int get(int u) { return ch[par[u]][1] == u; }\ninline int rot(int u) { return ch[par[u]][0] != u && ch[par[u]][1] != u; }\ninline void Rev(int u) { rev[u] ^= 1, std::swap(ch[u][0], ch[u][1]); }\ninline void down(int u) {\n  if (rev[u]) {\n    if (ch[u][0]) Rev(ch[u][0]);\n    if (ch[u][1]) Rev(ch[u][1]);\n    rev[u] ^= 1;\n  }\n}\ninline void Down(int u) {\n  if (!rot(u)) Down(par[u]);\n  down(u);\n}\ninline void rotate(int u) {\n  int v = par[u], w = par[v], k = get(u);\n  if (!rot(v)) ch[w][ch[w][1] == v] = u;\n  par[ch[v][k] = ch[u][k ^ 1]] = v;\n  par[ch[u][k ^ 1] = v] = u, par[u] = w;\n}\ninline void splay(int u) {\n  Down(u);\n  for (int f; f = par[u], !rot(u); rotate(u))\n    if (!rot(f)) rotate(get(u) == get(f) ? f : u);\n}\ninline void access(int u) {\n  for (int v = 0; u; u = par[v = u]) splay(u), ch[u][1] = v;\n}\ninline void mkt(int u) { access(u), splay(u), Rev(u); }\ninline int find(int u) {\n  access(u), splay(u);\n  while (ch[u][0]) down(u), u = ch[u][0];\n  return splay(u), u;\n}\ninline int link(int u, int v) {\n  mkt(u);\n  if (find(u) == find(v)) return 0;\n  return par[u] = v, 1;\n}\ninline void cut(int u, int v) {\n  mkt(u);\n  if (find(v) == u && par[v] == u && !ch[v][0]) par[v] = ch[u][1] = 0;\n}\n}  // namespace LCT\nusing LCT::cut;\nusing LCT::link;\nint Min[N << 2], num[N << 2], tag[N << 2];\ninline void upd(int k) {\n  int lc = k << 1, rc = k << 1 | 1;\n  if (Min[lc] < Min[rc]) Min[k] = Min[lc], num[k] = num[lc];\n  if (Min[lc] > Min[rc]) Min[k] = Min[rc], num[k] = num[rc];\n  if (Min[lc] == Min[rc]) Min[k] = Min[lc], num[k] = num[lc] + num[rc];\n}\ninline void build(int k, int l, int r) {\n  if (l == r) return num[k] = 1, void();\n  build(k << 1, l, ((l + r) >> 1)), build(k << 1 | 1, ((l + r) >> 1) + 1, r),\n      upd(k);\n}\ninline void down(int u, int dat) { Min[u] += dat, tag[u] += dat; }\ninline void down(int k) {\n  if (tag[k]) {\n    down(k << 1, tag[k]);\n    down(k << 1 | 1, tag[k]);\n    tag[k] = 0;\n  }\n}\ninline void mod(int k, int l, int r, int ql, int qr, int dat) {\n  if (l > r || l > qr || ql > r) return;\n  if (ql <= l && r <= qr) return down(k, dat);\n  down(k);\n  mod(k << 1, l, ((l + r) >> 1), ql, qr, dat);\n  mod(k << 1 | 1, ((l + r) >> 1) + 1, r, ql, qr, dat);\n  upd(k);\n}\ninline int ask(int k, int l, int r, int ql, int qr) {\n  if (l > r || l > qr || ql > r) return 0;\n  if (ql <= l && r <= qr) return Min[k] ? 0 : num[k];\n  return down(k), ask(k << 1, l, ((l + r) >> 1), ql, qr) +\n                      ask(k << 1 | 1, ((l + r) >> 1) + 1, r, ql, qr);\n}\nint a[M][M], l[N], x[N], y[N];\nint main() {\n  int n = read(), m = read(), N = n * m;\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j) a[i][j] = read();\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j) x[a[i][j]] = i, y[a[i][j]] = j;\n  const int way[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n  int64_t ans = 0;\n  build(1, 1, N);\n  for (int i = 1, j = 1; i <= N; ++i) {\n    if (i != 1) mod(1, 1, N, 1, i - 1, 1);\n    std::vector<int> vec;\n    for (int k = 0; k < 4; ++k) {\n      int x = ::x[i] + way[k][0], y = ::y[i] + way[k][1];\n      if (j <= a[x][y] && a[x][y] <= i) {\n        mod(1, 1, N, 1, a[x][y], -1);\n        vec.push_back(a[x][y]);\n      }\n    }\n    for (;;) {\n      std::vector<int> tmp;\n      for (auto u : vec)\n        if (j <= u && !link(i, u)) tmp.push_back(u);\n      vec = tmp;\n      if (vec.empty()) break;\n      for (int k = 0; k < 4; ++k) {\n        int x = ::x[j] + way[k][0], y = ::y[j] + way[k][1];\n        if (j <= a[x][y] && a[x][y] <= i) cut(j, a[x][y]);\n      }\n      j = j + 1;\n    }\n    ans += ask(1, 1, N, j, i);\n  }\n  std::cout << ans << std::endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int w = 1, s = 0;\n  char ch = getchar();\n  while (!isdigit(ch)) {\n    if (ch == '-') w = -1;\n    ch = getchar();\n  }\n  while (isdigit(ch)) {\n    s = s * 10 + ch - '0';\n    ch = getchar();\n  }\n  return w * s;\n}\nstruct LCT {\n  int ch[200010][2], fa[200010], rev[200100], Sta[200010];\n  inline int getf(int x) { return ch[fa[x]][1] == x; }\n  inline int isroot(int x) { return ch[fa[x]][0] != x && ch[fa[x]][1] != x; }\n  inline void Push(int x) {\n    rev[x] ^= 1;\n    swap(ch[x][0], ch[x][1]);\n  }\n  inline void Pushdown(int x) {\n    if (rev[x]) {\n      if (ch[x][1]) Push(ch[x][1]);\n      if (ch[x][0]) Push(ch[x][0]);\n      rev[x] = 0;\n    }\n  }\n  inline void Rotate(int x) {\n    int old = fa[x], oldf = fa[old], whichx = getf(x);\n    ch[old][whichx] = ch[x][whichx ^ 1];\n    fa[ch[old][whichx]] = old;\n    if (!isroot(old)) ch[oldf][getf(old)] = x;\n    fa[x] = oldf;\n    ch[x][whichx ^ 1] = old;\n    fa[old] = x;\n  }\n  inline void Splay(int x) {\n    int top = 0;\n    Sta[++top] = x;\n    for (register int i = x; !isroot(i); i = fa[i]) Sta[++top] = fa[i];\n    for (register int i = top; i; --i) Pushdown(Sta[i]);\n    for (register int f; !isroot(x); Rotate(x)) {\n      if (!isroot(f = fa[x])) {\n        Rotate(getf(f) == getf(x) ? f : x);\n      }\n    }\n  }\n  inline void Access(int v) {\n    for (register int t = 0; v; t = v, v = fa[v]) {\n      Splay(v);\n      ch[v][1] = t;\n    }\n  }\n  inline void Mkroot(int x) {\n    Access(x);\n    Splay(x);\n    Push(x);\n  }\n  inline int findrt(int x) {\n    Access(x);\n    Splay(x);\n    while (ch[x][0]) x = ch[x][0];\n    Splay(x);\n    return x;\n  }\n  inline void Link(int u, int v) {\n    Mkroot(u);\n    fa[u] = v;\n  }\n  inline void Cut(int u, int v) {\n    Mkroot(u);\n    Access(v);\n    Splay(v);\n    ch[v][0] = fa[u] = 0;\n  }\n  inline bool issame(int u, int v) { return findrt(u) == findrt(v); }\n} t1;\nstruct Segment_Tree {\n  int Min[1000100], Sum[1000010], tag[1000010];\n  inline pair<int, int> Merge(pair<int, int> p, pair<int, int> q) {\n    if (p.first < q.first) return p;\n    if (p.first > q.first) return q;\n    return make_pair(p.first, p.second + q.second);\n  }\n  inline void Push(int now, int d) {\n    Min[now] += d;\n    tag[now] += d;\n  }\n  inline void Pushdown(int now, int l, int r) {\n    if (tag[now])\n      Push(now << 1, tag[now]), Push(now << 1 | 1, tag[now]), tag[now] = 0;\n  }\n  inline void Update(int now) {\n    if (Min[now << 1] < Min[now << 1 | 1])\n      Min[now] = Min[now << 1], Sum[now] = Sum[now << 1];\n    else if (Min[now << 1] > Min[now << 1 | 1])\n      Min[now] = Min[now << 1 | 1], Sum[now] = Sum[now << 1 | 1];\n    else\n      Min[now] = Min[now << 1], Sum[now] = Sum[now << 1] + Sum[now << 1 | 1];\n  }\n  inline void Build(int now, int l, int r) {\n    if (l == r) {\n      Sum[now] = 1;\n      Min[now] = 0;\n      return;\n    }\n    int mid = (l + r) >> 1;\n    Build(now << 1, l, mid);\n    Build(now << 1 | 1, mid + 1, r);\n    Update(now);\n  }\n  inline void Modify(int now, int l, int r, int x, int y, int d) {\n    if (x <= l && r <= y) {\n      Push(now, d);\n      return;\n    }\n    Pushdown(now, l, r);\n    int mid = (l + r) >> 1;\n    if (x <= mid) Modify(now << 1, l, mid, x, y, d);\n    if (y > mid) Modify(now << 1 | 1, mid + 1, r, x, y, d);\n    Update(now);\n  }\n  inline pair<int, int> Query(int now, int l, int r, int x, int y) {\n    if (x <= l && r <= y) {\n      return make_pair(Min[now], Sum[now]);\n    }\n    int mid = (l + r) >> 1;\n    Pushdown(now, l, r);\n    if (x > mid) return Query(now << 1 | 1, mid + 1, r, x, y);\n    if (y <= mid) return Query(now << 1, l, mid, x, y);\n    return Merge(Query(now << 1, l, mid, x, y),\n                 Query(now << 1 | 1, mid + 1, r, x, y));\n  }\n} t2;\nint n, m, N, L, R;\nvector<int> f[200020];\npair<int, int> pos[200010];\ninline void Gao2(pair<int, int> tmp1, pair<int, int> tmp2) {\n  if (tmp2.first > n || tmp2.first < 1 || tmp2.second > m || tmp2.second < 1)\n    return;\n  int x = f[tmp1.first][tmp1.second], y = f[tmp2.first][tmp2.second];\n  if (y < L) return;\n  if (y >= R) return;\n  t2.Modify(1, 1, N, 1, x, 1);\n  t1.Cut(x, y);\n}\ninline void Erase(int x) {\n  pair<int, int> tmp = pos[x];\n  Gao2(tmp, make_pair(tmp.first + 1, tmp.second));\n  Gao2(tmp, make_pair(tmp.first - 1, tmp.second));\n  Gao2(tmp, make_pair(tmp.first, tmp.second + 1));\n  Gao2(tmp, make_pair(tmp.first, tmp.second - 1));\n}\ninline void Gao(pair<int, int> tmp1, pair<int, int> tmp2) {\n  if (tmp2.first > n || tmp2.first < 1 || tmp2.second > m || tmp2.second < 1)\n    return;\n  int x = f[tmp1.first][tmp1.second], y = f[tmp2.first][tmp2.second];\n  if (y < L) return;\n  if (y > R) return;\n  int r1 = t1.findrt(x), r2 = t1.findrt(y);\n  while (r1 == r2) {\n    Erase(L);\n    ++L;\n    r1 = t1.findrt(x), r2 = t1.findrt(y);\n    if (y < L) return;\n  }\n  if (y < L) return;\n  t1.Link(x, y);\n  t2.Modify(1, 1, N, 1, y, -1);\n}\nint main() {\n  n = read(), m = read();\n  N = n * m;\n  for (register int i = 1; i <= n; ++i) {\n    f[i].push_back(0);\n    for (register int j = 1; j <= m; ++j) {\n      int x = read();\n      f[i].push_back(x);\n      pos[x] = make_pair(i, j);\n    }\n  }\n  L = 1;\n  long long res = 0;\n  t2.Build(1, 1, N);\n  for (R = 1; R <= N; ++R) {\n    t2.Modify(1, 1, N, 1, R, 1);\n    pair<int, int> tmp = pos[R];\n    Gao(tmp, make_pair(tmp.first + 1, tmp.second));\n    Gao(tmp, make_pair(tmp.first - 1, tmp.second));\n    Gao(tmp, make_pair(tmp.first, tmp.second + 1));\n    Gao(tmp, make_pair(tmp.first, tmp.second - 1));\n    pair<int, int> ans = t2.Query(1, 1, N, L, R);\n    if (ans.first == 1) res += ans.second;\n  }\n  cout << res;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline char gc() {\n  static char buf[100000], *p1 = buf, *p2 = buf;\n  return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2)\n             ? EOF\n             : *p1++;\n}\ninline long long read() {\n  long long x = 0;\n  char ch = getchar();\n  bool positive = 1;\n  for (; !isdigit(ch); ch = getchar())\n    if (ch == '-') positive = 0;\n  for (; isdigit(ch); ch = getchar()) x = x * 10 + ch - '0';\n  return positive ? x : -x;\n}\ninline void write(long long a) {\n  if (a < 0) {\n    a = -a;\n    putchar('-');\n  }\n  if (a >= 10) write(a / 10);\n  putchar('0' + a % 10);\n}\ninline void writeln(long long a) {\n  write(a);\n  puts(\"\");\n}\ninline void wri(long long a) {\n  write(a);\n  putchar(' ');\n}\ninline long long rnd() {\n  long long ans = 0;\n  for (int i = 1; i <= 5; i++) ans = ans << 15 ^ rand();\n  return ans;\n}\nconst int N = 200005, M = 550000;\nstruct link_cut_tree {\n  int ch[N][2], fa[N], rev[N];\n  long long lazy[N], w[N];\n  inline int get(int x) { return ch[fa[x]][1] == x; }\n  inline int isroot(int x) { return ch[fa[x]][0] != x && ch[fa[x]][1] != x; }\n  inline void rever(int x) {\n    rev[x] ^= 1;\n    swap(ch[x][0], ch[x][1]);\n  }\n  inline void update(int x) {}\n  inline void cao(int x, long long y) {\n    w[x] ^= y;\n    lazy[x] ^= y;\n  }\n  inline void pushdown(int x) {\n    if (rev[x]) {\n      if (ch[x][0]) rever(ch[x][0]);\n      if (ch[x][1]) rever(ch[x][1]);\n      rev[x] = 0;\n    }\n    if (lazy[x]) {\n      if (ch[x][0]) cao(ch[x][0], lazy[x]);\n      if (ch[x][1]) cao(ch[x][1], lazy[x]);\n      lazy[x] = 0;\n    }\n  }\n  inline void push(int x) {\n    if (!isroot(x)) push(fa[x]);\n    pushdown(x);\n  }\n  inline void rotate(int x) {\n    int f = fa[x], g = fa[f], c = get(x);\n    if (!isroot(f)) ch[g][get(f)] = x;\n    fa[x] = g;\n    ch[f][c] = ch[x][c ^ 1];\n    fa[ch[f][c]] = f;\n    ch[x][c ^ 1] = f;\n    fa[f] = x;\n    update(f);\n    update(x);\n  }\n  inline void splay(int x) {\n    for (push(x); !isroot(x); rotate(x))\n      if (!isroot(fa[x])) rotate(get(fa[x]) == get(x) ? fa[x] : x);\n  }\n  void access(int x) {\n    for (int y = 0; x; y = x, x = fa[x]) {\n      splay(x);\n      ch[x][1] = y;\n      update(x);\n    }\n  }\n  void makeroot(int x) {\n    access(x);\n    splay(x);\n    rever(x);\n  }\n  int findroot(int x) {\n    access(x);\n    splay(x);\n    while (ch[x][0]) x = ch[x][0];\n    return x;\n  }\n  void link(int x, int y) {\n    x++;\n    y++;\n    makeroot(x);\n    fa[x] = y;\n  }\n  void split(int x, int y) {\n    makeroot(x);\n    access(y);\n    splay(y);\n  }\n  void cut(int x, int y) {\n    x++;\n    y++;\n    split(x, y);\n    fa[x] = ch[y][0] = 0;\n    update(y);\n  }\n  bool check(int x, int y) {\n    x++;\n    y++;\n    int tx = findroot(x), ty = findroot(y);\n    return tx == ty;\n  }\n} T;\npair<int, int> tr[M];\nint lazy[M], v[N], pos[N];\nvector<int> e[N];\npair<int, int> q[10];\npair<int, int> operator+(pair<int, int> a, pair<int, int> b) {\n  if (a.first == b.first)\n    return make_pair(a.first, a.second + b.second);\n  else\n    return max(a, b);\n}\nvoid push_up(int nod) { tr[nod] = tr[nod << 1] + tr[nod << 1 | 1]; }\ninline void cao(int nod, int x) {\n  lazy[nod] += x;\n  tr[nod].first += x;\n}\nvoid pushdown(int nod) {\n  if (lazy[nod]) {\n    cao(nod << 1, lazy[nod]);\n    cao(nod << 1 | 1, lazy[nod]);\n    lazy[nod] = 0;\n  }\n}\npair<int, int> ask(int l, int r, int i, int j, int nod) {\n  if (l == i && r == j) return tr[nod];\n  pushdown(nod);\n  int mid = (l + r) >> 1;\n  if (j <= mid)\n    return ask(l, mid, i, j, nod << 1);\n  else if (i > mid)\n    return ask(mid + 1, r, i, j, nod << 1 | 1);\n  else\n    return ask(l, mid, i, mid, nod << 1) +\n           ask(mid + 1, r, mid + 1, j, nod << 1 | 1);\n}\nvoid ins(int l, int r, int i, int j, int nod) {\n  if (l == i && r == j) {\n    cao(nod, 1);\n    return;\n  }\n  pushdown(nod);\n  int mid = (l + r) >> 1;\n  if (j <= mid)\n    ins(l, mid, i, j, nod << 1);\n  else if (i > mid)\n    ins(mid + 1, r, i, j, nod << 1 | 1);\n  else {\n    ins(l, mid, i, mid, nod << 1);\n    ins(mid + 1, r, mid + 1, j, nod << 1 | 1);\n  }\n  push_up(nod);\n}\nvoid build(int l, int r, int nod) {\n  if (l == r) {\n    tr[nod] = make_pair(v[l], 1);\n    return;\n  }\n  int mid = (l + r) >> 1;\n  build(l, mid, nod << 1);\n  build(mid + 1, r, nod << 1 | 1);\n  tr[nod] = tr[nod << 1] + tr[nod << 1 | 1];\n}\nint main() {\n  int n = read(), m = read(), nm = n * m - 1;\n  for (int i = 0; i <= nm; i++) v[i] = i;\n  build(0, nm, 1);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) pos[v[((i)*m + j)] = read() - 1] = ((i)*m + j);\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      if (i) e[v[((i)*m + j)]].push_back(v[((i - 1) * m + j)]);\n      if (j) e[v[((i)*m + j)]].push_back(v[((i)*m + j - 1)]);\n      if (i + 1 < n) e[v[((i)*m + j)]].push_back(v[((i + 1) * m + j)]);\n      if (j + 1 < m) e[v[((i)*m + j)]].push_back(v[((i)*m + j + 1)]);\n    }\n  }\n  long long ans = 0;\n  int l = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      int r = ((i)*m + j);\n      while (1) {\n        int f = 1, tot = 0;\n        for (auto k : e[r])\n          if (k < r && k >= l) q[++tot] = make_pair(k, r);\n        for (int i = 1; i <= tot; i++) {\n          if (T.check(q[i].first, q[i].second)) {\n            for (int j = 1; j < i; j++) T.cut(q[j].first, q[j].second);\n            f = 0;\n            break;\n          } else\n            T.link(q[i].first, q[i].second);\n        }\n        if (f)\n          break;\n        else {\n          for (auto k : e[l])\n            if (k > l && k <= r) T.cut(k, l);\n          l++;\n        }\n      }\n      for (auto k : e[r])\n        if (k < r && k >= l) {\n          ins(0, nm, 0, k, 1);\n        }\n      pair<int, int> t = ask(0, nm, l, r, 1);\n      ans += t.second;\n    }\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct LCT {\n  int fa[200005], ch[200005][2], tag[200005], st[200005];\n  bool un_root(int x) { return ch[fa[x]][0] == x || ch[fa[x]][1] == x; }\n  bool get(int x) { return ch[fa[x]][1] == x; }\n  void push_rev(int x) {\n    swap(ch[x][0], ch[x][1]);\n    tag[x] ^= 1;\n    return;\n  }\n  void push_down(int x) {\n    if (!tag[x]) return;\n    if (ch[x][0]) push_rev(ch[x][0]);\n    if (ch[x][1]) push_rev(ch[x][1]);\n    tag[x] ^= 1;\n    return;\n  }\n  void rotate(int x) {\n    int y = fa[x], z = fa[y], tx = get(x), ty = get(y), p = ch[x][tx ^ 1];\n    if (un_root(y)) ch[z][ty] = x;\n    fa[x] = z;\n    if (p) fa[p] = y;\n    ch[y][tx] = p;\n    fa[y] = x;\n    ch[x][tx ^ 1] = y;\n    return;\n  }\n  void splay(int x) {\n    int top = 0, u = x;\n    st[++top] = u;\n    while (un_root(u)) st[++top] = u = fa[u];\n    while (top) push_down(st[top--]);\n    while (un_root(x)) {\n      int y = fa[x], tx = get(x), ty = get(y);\n      if (un_root(y)) rotate(tx == ty ? y : x);\n      rotate(x);\n    }\n    return;\n  }\n  void access(int x) {\n    for (int y = 0; x; x = fa[y = x]) splay(x), ch[x][1] = y;\n    return;\n  }\n  int find_root(int x) {\n    access(x);\n    splay(x);\n    while (ch[x][0]) x = ch[x][0];\n    return splay(x), x;\n  }\n  void make_root(int x) {\n    access(x);\n    splay(x);\n    push_rev(x);\n    return;\n  }\n  bool link(int x, int y) {\n    make_root(x);\n    if (find_root(y) == x) return false;\n    fa[x] = y;\n    return true;\n  }\n  void cut(int x, int y) {\n    if (!x || !y) return;\n    make_root(x);\n    if (find_root(y) == x && fa[y] == x && !ch[y][0]) ch[x][1] = fa[y] = 0;\n    return;\n  }\n} lct;\nstruct Segment_Tree {\n  int mn[200005 << 3], val[200005 << 3], tag[200005 << 3];\n  void push_up(int pos) {\n    if (mn[pos << 1] < mn[pos << 1 | 1])\n      val[pos] = val[pos << 1], mn[pos] = mn[pos << 1];\n    if (mn[pos << 1 | 1] < mn[pos << 1])\n      val[pos] = val[pos << 1 | 1], mn[pos] = mn[pos << 1 | 1];\n    if (mn[pos << 1 | 1] == mn[pos << 1])\n      val[pos] = val[pos << 1] + val[pos << 1 | 1], mn[pos] = mn[pos << 1];\n    return;\n  }\n  void push_down(int pos) {\n    if (!tag[pos]) return;\n    int w = tag[pos];\n    tag[pos] = 0;\n    mn[pos << 1] += w;\n    mn[pos << 1 | 1] += w;\n    tag[pos << 1] += w;\n    tag[pos << 1 | 1] += w;\n    return;\n  }\n  void build(int pos, int l, int r) {\n    if (l == r) return mn[pos] = l, val[pos] = 1, void();\n    int mid = (l + r) >> 1;\n    build(pos << 1, l, mid);\n    build(pos << 1 | 1, mid + 1, r);\n    push_up(pos);\n    return;\n  }\n  void update(int pos, int l, int r, int nl, int nr, int w) {\n    if (l >= nl && r <= nr) return tag[pos] += w, mn[pos] += w, void();\n    int mid = (l + r) >> 1;\n    push_down(pos);\n    if (mid >= nl) update(pos << 1, l, mid, nl, nr, w);\n    if (mid < nr) update(pos << 1 | 1, mid + 1, r, nl, nr, w);\n    push_up(pos);\n    return;\n  }\n  int query(int pos, int l, int r, int nl, int nr) {\n    if (l >= nl && r <= nr) return val[pos] * (mn[pos] == 0);\n    int mid = (l + r) >> 1, sum = 0;\n    push_down(pos);\n    if (mid >= nl) sum += query(pos << 1, l, mid, nl, nr);\n    if (mid < nr) sum += query(pos << 1 | 1, mid + 1, r, nl, nr);\n    return sum;\n  }\n} T;\nint n, m;\nint a[1003][1003], st[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\nbool vis[1003][1003];\npair<int, int> p[200005];\nlong long ans;\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  int M = n * m;\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n      scanf(\"%d\", a[i] + j), p[a[i][j]] = make_pair(i, j);\n  vis[p[1].first][p[1].second] = true;\n  T.build(1, 1, M);\n  for (int l = 1, r = 1; l <= M; ++l) {\n    T.update(1, 1, M, l, M, -1);\n    while (r < M) {\n      ++r;\n      bool flag = true;\n      int x = p[r].first, y = p[r].second, cnt = 0;\n      for (int i = 0; i < 4; ++i) {\n        int xx = x + st[i][0], yy = y + st[i][1];\n        if (!vis[xx][yy] || xx < 1 || xx > n || yy < 1 || yy > m) continue;\n        int tmp = a[xx][yy];\n        flag &= lct.link(r, tmp);\n        if (!flag) {\n          for (int j = 0; j < i; ++j) lct.cut(r, a[x + st[j][0]][y + st[j][1]]);\n          break;\n        }\n        ++cnt;\n      }\n      if (!flag) {\n        --r;\n        break;\n      }\n      T.update(1, 1, M, r, M, -cnt);\n      vis[x][y] = true;\n    }\n    ans += T.query(1, 1, M, l, r);\n    int x = p[l].first, y = p[l].second;\n    for (int i = 0; i < 4; ++i) {\n      int xx = x + st[i][0], yy = y + st[i][1];\n      if (!vis[xx][yy] || xx < 1 || xx > n || yy < 1 || yy > m) continue;\n      int tmp = a[xx][yy];\n      lct.cut(l, tmp);\n      T.update(1, 1, M, tmp, M, 1);\n    }\n    vis[x][y] = false;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 201000;\nint c[2][N], fa[N], rev[N];\nbool it(int o) { return c[0][fa[o]] != o && c[1][fa[o]] != o; }\nvoid pd(int o) {\n  if (rev[o]) {\n    swap(c[0][o], c[1][o]);\n    rev[c[0][o]] ^= 1;\n    rev[c[1][o]] ^= 1;\n    rev[o] = 0;\n  }\n}\nvoid rot(int o) {\n  int x = fa[o], k = c[0][x] == o;\n  fa[c[!k][x] = c[k][o]] = x;\n  fa[o] = fa[x];\n  if (!it(x)) c[c[1][fa[x]] == x][fa[x]] = o;\n  fa[c[k][o] = x] = o;\n}\nvoid down(int o) {\n  if (!it(o)) down(fa[o]);\n  pd(o);\n}\nvoid sy(int o) {\n  for (down(o); !it(o); rot(o))\n    if (!it(fa[o]))\n      rot(c[0][fa[o]] == o ^ c[0][fa[fa[o]]] == fa[o] ? o : fa[o]);\n}\nvoid acs(int o) {\n  for (int y = 0; o; c[1][o] = y, y = o, o = fa[o]) sy(o);\n}\nvoid mt(int o) {\n  acs(o);\n  sy(o);\n  rev[o] ^= 1;\n}\nint fd(int o) {\n  acs(o);\n  sy(o);\n  for (; c[0][o]; pd(o = c[0][o]))\n    ;\n  sy(o);\n  return o;\n}\nvoid cut(int x, int y) {\n  mt(y);\n  acs(x);\n  sy(x);\n  fa[y] = c[0][x] = 0;\n}\nint mn[N * 4], tag[N * 4], mn_cnt[N * 4];\nvoid bt(int o, int l, int r) {\n  mn[o] = tag[o] = 0;\n  mn_cnt[o] = r - l + 1;\n  if (l == r) return;\n  int mid = (l + r) / 2;\n  bt(o * 2, l, mid);\n  bt(o * 2 + 1, mid + 1, r);\n}\nint q1, q2;\nlong long ans;\nvoid query(int o, int l, int r, int tg = 0) {\n  if (q1 <= l && r <= q2) {\n    if (mn[o] + tg == 0) ans += mn_cnt[o];\n    return;\n  }\n  int mid = (l + r) / 2;\n  tg += tag[o];\n  if (q1 <= mid) query(o * 2, l, mid, tg);\n  if (q2 > mid) query(o * 2 + 1, mid + 1, r, tg);\n}\nvoid modify(int o, int l, int r) {\n  if (q1 <= l) {\n    tag[o] += q2;\n    mn[o] += q2;\n    return;\n  }\n  int mid = (l + r) / 2;\n  if (q1 <= mid) modify(o * 2, l, mid);\n  modify(o * 2 + 1, mid + 1, r);\n  mn[o] = min(mn[o * 2], mn[o * 2 + 1]);\n  mn_cnt[o] = (mn[o] == mn[o * 2] ? mn_cnt[o * 2] : 0) +\n              (mn[o] == mn[o * 2 + 1] ? mn_cnt[o * 2 + 1] : 0);\n  mn[o] += tag[o];\n}\nconst int dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0}, M = 1234;\nint idx[N], idy[N], a[M][M];\nint n, m, K, L, R;\nbool push(int x, int op) {\n  int u = idx[x], v = idy[x], nu = u + dx[op], nv = v + dy[op];\n  if (nu < 1 || nu > n || nv < 1 || nv > m || a[nu][nv] < L || a[nu][nv] > R)\n    return 1;\n  int y = a[nu][nv];\n  mt(y);\n  if (fd(x) == y) return 0;\n  fa[y] = x;\n  q1 = max(x, y);\n  q2 = -1;\n  modify(1, 1, K);\n  return 1;\n}\nvoid pop(int t) {\n  for (int op = 0; op < 4; ++op) {\n    int u = idx[R], v = idy[R], nu = u - dx[op], nv = v - dy[op];\n    if (nu < 1 || nu > n || nv < 1 || nv > m ||\n        (a[nu][nv] < L || (a[nu][nv] == L && op >= t)) || a[nu][nv] > R)\n      continue;\n    int y = a[nu][nv];\n    cut(y, R);\n    q1 = max(R, y);\n    q2 = 1;\n    modify(1, 1, K);\n  }\n  --R;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  K = n * m;\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n      cin >> a[i][j], idx[a[i][j]] = i, idy[a[i][j]] = j;\n  bt(1, 1, K);\n  for (L = R = K; L; --L) {\n    for (int i = 0; i < 4; ++i)\n      for (; !push(L, i); pop(i))\n        ;\n    q1 = L;\n    q2 = R;\n    query(1, 1, K);\n    q1 = L;\n    q2 = 1;\n    modify(1, 1, K);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n  char ch;\n  x = 0;\n  bool fl = false;\n  while (!isdigit(ch = getchar())) (ch == '-') && (fl = true);\n  for (x = (ch ^ '0'); isdigit(ch = getchar()); x = x * 10 + (ch ^ '0'))\n    ;\n  (fl == true) && (x = -x);\n}\ntemplate <class T>\ninline void output(T x) {\n  if (x / 10) output(x / 10);\n  putchar(x % 10 + '0');\n}\ntemplate <class T>\ninline void ot(T x) {\n  if (x < 0) putchar('-'), x = -x;\n  output(x);\n  putchar(' ');\n}\ntemplate <class T>\ninline void prt(T a[], int st, int nd) {\n  for (register int i = st; i <= nd; ++i) ot(a[i]);\n  putchar('\\n');\n}\nnamespace Modulo {\nconst int mod = 998244353;\nint ad(int x, int y) { return (x + y) >= mod ? x + y - mod : x + y; }\nvoid inc(int &x, int y) { x = ad(x, y); }\nint mul(int x, int y) { return (long long)x * y % mod; }\nvoid inc2(int &x, int y) { x = mul(x, y); }\nint qm(int x, int y = mod - 2) {\n  int ret = 1;\n  while (y) {\n    if (y & 1) ret = mul(x, ret);\n    x = mul(x, x);\n    y >>= 1;\n  }\n  return ret;\n}\n}  // namespace Modulo\nnamespace Miracle {\nconst int N = 2e5 + 5;\nconst int inf = 0x3f3f3f3f;\nconst int mv[4][2] = {{+1, 0}, {-1, 0}, {0, -1}, {0, +1}};\nint a[2002][2002];\nint n;\nint ha, li;\npair<int, int> pos[N];\nstruct node {\n  int ch[2];\n  int fa;\n  int rev;\n} t[N];\nint L, R;\nbool nrt(int x) { return (t[t[x].fa].ch[0] == x || t[t[x].fa].ch[1] == x); }\nvoid rotate(int x) {\n  int y = t[x].fa, d = t[y].ch[1] == x;\n  t[t[y].ch[d] = t[x].ch[!d]].fa = y;\n  if (nrt(y))\n    t[t[x].fa = t[y].fa].ch[t[t[y].fa].ch[1] == y] = x;\n  else\n    t[x].fa = t[y].fa;\n  t[t[x].ch[!d] = y].fa = x;\n}\nint sta[N];\nvoid rev(int x) {\n  t[x].rev ^= 1;\n  swap(t[x].ch[0], t[x].ch[1]);\n}\nvoid pd(int x) {\n  if (t[x].rev) {\n    rev(t[x].ch[0]);\n    rev(t[x].ch[1]);\n    t[x].rev = 0;\n  }\n}\nvoid splay(int x) {\n  int y = x, z = 0;\n  sta[++z] = y;\n  while (nrt(y)) y = t[y].fa, sta[++z] = y;\n  while (z) pd(sta[z--]);\n  while (nrt(x)) {\n    y = t[x].fa, z = t[y].fa;\n    if (nrt(y)) {\n      rotate((t[y].ch[0] == x) == (t[z].ch[0] == y) ? y : x);\n    }\n    rotate(x);\n  }\n}\nvoid access(int x) {\n  for (register int y = 0; x; y = x, x = t[x].fa) {\n    splay(x);\n    t[x].ch[1] = y;\n  }\n}\nvoid makert(int x) {\n  access(x);\n  splay(x);\n  rev(x);\n}\nint findrt(int x) {\n  access(x);\n  splay(x);\n  while (t[x].ch[0]) x = t[x].ch[0];\n  splay(x);\n  return x;\n}\nbool link(int x, int y) {\n  makert(x);\n  if (findrt(y) != x) {\n    t[x].fa = y;\n    return true;\n  } else\n    return false;\n}\nvoid cut(int x, int y) {\n  makert(x);\n  access(y);\n  splay(y);\n  if (t[y].ch[0] == x && !t[x].ch[0] && !t[x].ch[1]) {\n    t[x].fa = 0;\n    t[y].ch[0] = 0;\n  }\n}\nvoid dele(int x) {\n  int nx = pos[x].first, ny = pos[x].second;\n  for (register int i = 0; i < 4; ++i) {\n    int tx = nx + mv[i][0], ty = ny + mv[i][1];\n    if (a[tx][ty]) {\n      int p = a[tx][ty];\n      if (p >= L && p <= R) {\n        cut(x, p);\n      }\n    }\n  }\n}\nint got[10];\nbool che(int x) {\n  bool fl = true;\n  int nx = pos[x].first, ny = pos[x].second;\n  int ct = 0;\n  for (register int i = 0; i < 4; ++i) {\n    int tx = nx + mv[i][0], ty = ny + mv[i][1];\n    if (a[tx][ty]) {\n      int p = a[tx][ty];\n      if (p >= L && p <= R) {\n        bool lp = link(x, p);\n        if (lp == false) {\n          fl = false;\n          break;\n        }\n        got[++ct] = p;\n      }\n    }\n  }\n  if (!fl) {\n    for (register int i = 1; i <= ct; ++i) cut(x, got[i]);\n  }\n  return fl;\n}\nstruct po {\n  int mi, cnt;\n  po() { mi = inf, cnt = 1; }\n  po friend operator+(po a, po b) {\n    po c;\n    c.mi = min(a.mi, b.mi);\n    c.cnt = 0;\n    if (a.mi == c.mi) c.cnt += a.cnt;\n    if (b.mi == c.mi) c.cnt += b.cnt;\n    return c;\n  }\n};\nnamespace seg {\nstruct tr {\n  po v;\n  int add;\n} t[4 * N];\nvoid pushup(int x) { t[x].v = t[(x << 1)].v + t[(x << 1 | 1)].v; }\nvoid tag(int x, int c) {\n  t[x].add += c;\n  t[x].v.mi += c;\n}\nvoid pushdown(int x) {\n  if (t[x].add) {\n    tag((x << 1), t[x].add);\n    tag((x << 1 | 1), t[x].add);\n    t[x].add = 0;\n  }\n}\nvoid build(int x, int l, int r) {\n  if (l == r) {\n    t[x].add = 0;\n    t[x].v.mi = 0;\n    t[x].v.cnt = 1;\n    return;\n  }\n  build((x << 1), l, ((l + r) >> 1));\n  build((x << 1 | 1), ((l + r) >> 1) + 1, r);\n  pushup(x);\n}\nvoid upda(int x, int l, int r, int L, int R, int c) {\n  if (L <= l && r <= R) {\n    tag(x, c);\n    return;\n  }\n  pushdown(x);\n  if (L <= ((l + r) >> 1)) upda((x << 1), l, ((l + r) >> 1), L, R, c);\n  if (((l + r) >> 1) < R) upda((x << 1 | 1), ((l + r) >> 1) + 1, r, L, R, c);\n  pushup(x);\n}\npo query(int x, int l, int r, int L, int R) {\n  if (L <= l && r <= R) {\n    return t[x].v;\n  }\n  po ret;\n  if (L <= ((l + r) >> 1)) ret = ret + query((x << 1), l, ((l + r) >> 1), L, R);\n  if (((l + r) >> 1) < R)\n    ret = ret + query((x << 1 | 1), ((l + r) >> 1) + 1, r, L, R);\n  return ret;\n}\n}  // namespace seg\nint main() {\n  rd(ha);\n  rd(li);\n  n = ha * li;\n  for (register int i = 1; i <= ha; ++i) {\n    for (register int j = 1; j <= li; ++j) {\n      rd(a[i][j]);\n      pos[a[i][j]] = make_pair(i, j);\n    }\n  }\n  seg::build(1, 1, n);\n  L = 1;\n  long long ans = 0;\n  for (R = 1; R <= n; ++R) {\n    while (!che(R)) {\n      dele(L);\n      ++L;\n    }\n    seg::upda(1, 1, n, L, R, 1);\n    int x = R;\n    int nx = pos[x].first, ny = pos[x].second;\n    for (register int i = 0; i < 4; ++i) {\n      int tx = nx + mv[i][0], ty = ny + mv[i][1];\n      if (a[tx][ty]) {\n        int p = a[tx][ty];\n        if (p >= L && p <= R) {\n          seg::upda(1, 1, n, L, p, -1);\n        }\n      }\n    }\n    po now = seg::query(1, 1, n, L, R);\n    if (now.mi == 1) {\n      ans += now.cnt;\n    }\n  }\n  ot(ans);\n  return 0;\n}\n}  // namespace Miracle\nsigned main() {\n  Miracle::main();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nlong long perf[100];\nstruct BalancedBinaryForest {\n  int n;\n  vector<bool> isblack;\n  vector<int> blackheight;\n  vector<int> lft, rgt, par;\n  void init(int _n) {\n    n = _n;\n    isblack = vector<bool>(n, true);\n    blackheight = vector<int>(n, 1);\n    lft = rgt = par = vector<int>(n, -1);\n  }\n  pair<int, int> split(int a) {\n    ++perf[0];\n    int l = lft[a], r = rgt[a];\n    lft[a] = rgt[a] = -1;\n    if (l != -1) par[l] = -1;\n    if (r != -1) par[r] = -1;\n    if (l != -1 && !isblack[l]) isblack[l] = true, ++blackheight[l];\n    if (r != -1 && !isblack[r]) isblack[r] = true, ++blackheight[r];\n    while (par[a] != -1) {\n      ++perf[1];\n      int p = par[a], pl = lft[p], pr = rgt[p];\n      lft[p] = rgt[p] = -1;\n      par[a] = par[p];\n      par[p] = -1;\n      if (par[a] != -1) (lft[par[a]] == p ? lft[par[a]] : rgt[par[a]]) = a;\n      if (pl != a && pl != -1) par[pl] = -1;\n      if (pr != a && pr != -1) par[pr] = -1;\n      if (pl != a && pl != -1 && !isblack[pl])\n        isblack[pl] = true, ++blackheight[pl];\n      if (pr != a && pr != -1 && !isblack[pr])\n        isblack[pr] = true, ++blackheight[pr];\n      if (a == pl) r = join3(r, p, pr);\n      if (a == pr) l = join3(pl, p, l);\n    }\n    isblack[a] = true;\n    blackheight[a] = 1;\n    return make_pair(l, r);\n  }\n  int rotatelft(int a) {\n    ++perf[2];\n    assert(par[a] == -1);\n    int c = rgt[a], d = lft[c];\n    rgt[a] = d;\n    if (d != -1) par[d] = a;\n    lft[c] = a;\n    par[a] = c;\n    par[c] = -1;\n    return c;\n  }\n  int rotatergt(int c) {\n    ++perf[3];\n    assert(par[c] == -1);\n    int a = lft[c], d = rgt[a];\n    lft[c] = d;\n    if (d != -1) par[d] = c;\n    rgt[a] = c;\n    par[c] = a;\n    par[a] = -1;\n    return a;\n  }\n  int height(int x) { return x == -1 ? 0 : blackheight[x]; }\n  int joinlft(int a, int x, int b) {\n    ++perf[4];\n    if (height(a) == height(b) && (a == -1 || isblack[a])) {\n      isblack[x] = false;\n      blackheight[x] = height(a);\n      lft[x] = a;\n      rgt[x] = b;\n      if (a != -1) par[a] = x;\n      if (b != -1) par[b] = x;\n      return x;\n    }\n    int r = rgt[a];\n    if (r != -1) par[r] = -1;\n    rgt[a] = joinlft(r, x, b);\n    par[rgt[a]] = a;\n    if (!isblack[a] && !isblack[rgt[a]]) {\n      isblack[a] = true;\n      ++blackheight[a];\n      return a;\n    }\n    if (isblack[a] && isblack[rgt[a]] &&\n        blackheight[a] == blackheight[rgt[a]]) {\n      assert(!isblack[rgt[rgt[a]]]);\n      a = rotatelft(a);\n      isblack[a] = false;\n      isblack[rgt[a]] = true;\n      ++blackheight[rgt[a]];\n      return a;\n    }\n    return a;\n  }\n  int joinrgt(int a, int x, int b) {\n    ++perf[5];\n    if (height(a) == height(b) && (b == -1 || isblack[b])) {\n      isblack[x] = false;\n      blackheight[x] = height(a);\n      lft[x] = a;\n      rgt[x] = b;\n      if (a != -1) par[a] = x;\n      if (b != -1) par[b] = x;\n      return x;\n    }\n    int l = lft[b];\n    if (l != -1) par[l] = -1;\n    lft[b] = joinrgt(a, x, l);\n    par[lft[b]] = b;\n    if (!isblack[b] && !isblack[lft[b]]) {\n      isblack[b] = true;\n      ++blackheight[b];\n      return b;\n    }\n    if (isblack[b] && isblack[lft[b]] &&\n        blackheight[b] == blackheight[lft[b]]) {\n      assert(!isblack[lft[lft[b]]]);\n      b = rotatergt(b);\n      isblack[b] = false;\n      isblack[lft[b]] = true;\n      ++blackheight[lft[b]];\n      return b;\n    }\n    return b;\n  }\n  int join3(int a, int x, int b) {\n    ++perf[6];\n    int ret = height(a) >= height(b) ? joinlft(a, x, b) : joinrgt(a, x, b);\n    if (!isblack[ret]) isblack[ret] = true, ++blackheight[ret];\n    return ret;\n  }\n  int join2(int a, int b) {\n    assert(a == -1 && b == -1 || a != b);\n    ++perf[7];\n    if (a == -1)\n      return b;\n    else if (b == -1)\n      return a;\n    int c = lft[b], d = rgt[b];\n    lft[b] = rgt[b] = -1;\n    if (c != -1) par[c] = -1;\n    if (d != -1) par[d] = -1;\n    if (c != -1 && !isblack[c]) isblack[c] = true, ++blackheight[c];\n    if (d != -1 && !isblack[d]) isblack[d] = true, ++blackheight[d];\n    return join3(join2(a, c), b, d);\n  }\n  int merge(int a, int b) {\n    ++perf[8];\n    int ret = join2(getroot(a), getroot(b));\n    perf[11] = max(perf[11], (long long)height(ret));\n    return ret;\n  }\n  int getroot(int a) {\n    ++perf[9];\n    while (a != -1 && par[a] != -1) ++perf[10], a = par[a];\n    return a;\n  }\n  void myassert(bool cond, const char *s, int who) {\n    if (cond) return;\n    printf(\"fail: %s for %d\\n\", s, who + 1);\n    assert(cond);\n  }\n  void verify() {\n    for (int i = (0); i < (n); ++i)\n      if (par[i] != -1)\n        myassert(lft[par[i]] == i || rgt[par[i]] == i,\n                 \"parent with incorrect child\", i);\n    for (int i = (0); i < (n); ++i)\n      if (lft[i] != -1) myassert(par[lft[i]] == i, \"lft incorrect parent\", i);\n    for (int i = (0); i < (n); ++i)\n      if (rgt[i] != -1) myassert(par[rgt[i]] == i, \"rgt incorrect parent\", i);\n    for (int i = (0); i < (n); ++i)\n      if (par[i] != -1 && !isblack[i])\n        myassert(isblack[par[i]], \"red with red parent\", i);\n    for (int i = (0); i < (n); ++i)\n      myassert(height(lft[i]) == height(rgt[i]), \"diff heights\", i);\n    for (int i = (0); i < (n); ++i)\n      myassert(height(i) == height(lft[i]) + (isblack[i] ? 1 : 0),\n               \"incorrect height\", i);\n  }\n};\nstruct ForestDynamicConnectivity {\n  int n;\n  BalancedBinaryForest bbf;\n  queue<int> pool;\n  void init(int _n) {\n    n = _n;\n    bbf.init(n + 2 * (n - 1));\n    for (int i = (n); i < (bbf.n); ++i) pool.push(i);\n  }\n  int getnode() {\n    assert(!pool.empty());\n    int ret = pool.front();\n    pool.pop();\n    return ret;\n  }\n  void releasenode(int x) { pool.push(x); }\n  void reroot(int a) {\n    int b, c;\n    tie(b, c) = bbf.split(a);\n    bbf.merge(a, bbf.merge(c, b));\n  }\n  pair<int, int> addedge(int a, int b) {\n    reroot(a);\n    reroot(b);\n    int ab = getnode(), ba = getnode();\n    bbf.merge(bbf.merge(a, ab), bbf.merge(b, ba));\n    return make_pair(ab, ba);\n  }\n  void remedge(pair<int, int> e) {\n    int a, b, c;\n    tie(a, b) = bbf.split(e.first);\n    if (bbf.getroot(a) == bbf.getroot(e.second)) {\n      c = b;\n      tie(a, b) = bbf.split(e.second);\n    } else {\n      tie(b, c) = bbf.split(e.second);\n    }\n    releasenode(e.first), releasenode(e.second);\n    bbf.merge(a, c);\n  }\n  int getrepresentative(int a) { return bbf.getroot(a); }\n};\nstruct SegTreeMinCounter {\n  int n;\n  vector<int> smn, smncnt, slazy;\n  void sapply(int x, int by) {\n    smn[x] += by;\n    slazy[x] += by;\n  }\n  void spush(int x) {\n    if (slazy[x] != 0)\n      sapply(2 * x + 1, slazy[x]), sapply(2 * x + 2, slazy[x]), slazy[x] = 0;\n  }\n  void spull(int x) {\n    smn[x] = min(smn[2 * x + 1], smn[2 * x + 2]);\n    smncnt[x] = (smn[2 * x + 1] == smn[x] ? smncnt[2 * x + 1] : 0) +\n                (smn[2 * x + 2] == smn[x] ? smncnt[2 * x + 2] : 0);\n  }\n  void sinit(int x, int l, int r) {\n    slazy[x] = 0;\n    if (l == r) {\n      smn[x] = 0, smncnt[x] = 1;\n    } else {\n      int m = l + (r - l) / 2;\n      sinit(2 * x + 1, l, m);\n      sinit(2 * x + 2, m + 1, r);\n      spull(x);\n    }\n  }\n  void smod(int x, int l, int r, int L, int R, int BY) {\n    if (L <= l && r <= R) {\n      sapply(x, BY);\n    } else {\n      int m = l + (r - l) / 2;\n      spush(x);\n      if (L <= m) smod(2 * x + 1, l, m, L, R, BY);\n      if (m + 1 <= R) smod(2 * x + 2, m + 1, r, L, R, BY);\n      spull(x);\n    }\n  }\n  int sget(int x, int l, int r, int L, int R, int VAL) {\n    if (L <= l && r <= R) {\n      assert(smn[x] >= VAL);\n      return smn[x] == VAL ? smncnt[x] : 0;\n    } else {\n      int m = l + (r - l) / 2;\n      spush(x);\n      int ret = 0;\n      if (L <= m) ret += sget(2 * x + 1, l, m, L, R, VAL);\n      if (m + 1 <= R) ret += sget(2 * x + 2, m + 1, r, L, R, VAL);\n      return ret;\n    }\n  }\n  void init(int _n) {\n    n = _n;\n    smn = smncnt = slazy = vector<int>(4 * n);\n    sinit(0, 0, n - 1);\n  }\n  void mod(int l, int r, int by) { smod(0, 0, n - 1, l, r, by); }\n  int get(int l, int r, int val) { return sget(0, 0, n - 1, l, r, val); }\n};\nconst int MAXH = 1000;\nconst int MAXW = 1000;\nconst int MAXN = 200000;\nconst int DX[] = {-1, 0, +1, 0}, DY[] = {0, +1, 0, -1};\nint h, w, n;\nint g[MAXH][MAXW];\npair<int, int> pos[MAXN];\nForestDynamicConnectivity conn;\nvector<pair<int, int>> connedges[MAXN];\nSegTreeMinCounter segtree;\nlong long solve() {\n  for (int x = (0); x < (h); ++x)\n    for (int y = (0); y < (w); ++y) pos[g[x][y]] = make_pair(x, y);\n  conn.init(n);\n  segtree.init(n);\n  long long ret = 0;\n  int l = 0;\n  for (int r = (0); r < (n); ++r) {\n    int rx = pos[r].first, ry = pos[r].second;\n    while (true) {\n      vector<int> adj;\n      for (int k = (0); k < (4); ++k) {\n        int nx = rx + DX[k], ny = ry + DY[k];\n        if (nx < 0 || nx >= h || ny < 0 || ny >= w || g[nx][ny] < l ||\n            g[nx][ny] > r)\n          continue;\n        adj.push_back(conn.getrepresentative(g[nx][ny]));\n      }\n      sort(adj.begin(), adj.end());\n      bool duplicate = false;\n      for (int i = (1); i < (((int)(adj).size())); ++i)\n        if (adj[i - 1] == adj[i]) duplicate = true;\n      if (!duplicate) break;\n      for (int i = (0); i < (((int)(connedges[l]).size())); ++i)\n        conn.remedge(connedges[l][i]);\n      ++l;\n    }\n    segtree.mod(0, r, +1);\n    for (int k = (0); k < (4); ++k) {\n      int nx = rx + DX[k], ny = ry + DY[k];\n      if (nx < 0 || nx >= h || ny < 0 || ny >= w || g[nx][ny] < l ||\n          g[nx][ny] > r)\n        continue;\n      connedges[g[nx][ny]].push_back(conn.addedge(g[nx][ny], r));\n      segtree.mod(0, g[nx][ny], -1);\n    }\n    int cur = segtree.get(l, r, 1);\n    ret += cur;\n  }\n  return ret;\n}\nvoid run() {\n  scanf(\"%d%d\", &h, &w);\n  n = h * w;\n  for (int x = (0); x < (h); ++x)\n    for (int y = (0); y < (w); ++y) scanf(\"%d\", &g[x][y]), --g[x][y];\n  printf(\"%lld\\n\", solve());\n}\nvoid stress() {\n  std::mt19937 rnd(1237891);\n  for (int rep = (0); rep < (1); ++rep) {\n    h = 992, w = 191, n = h * w;\n    memset(g, -1, sizeof(g));\n    int at = 0;\n    for (int xx = (0); xx < (h); ++xx) {\n      int x = (2 * xx) % h + (2 * xx >= h ? 1 : 0);\n      for (int y = (0); y < (w); ++y) g[x][y] = at++;\n    }\n    for (int x = (0); x < (h); ++x)\n      for (int y = (0); y < (w); ++y) assert(g[x][y] != -1);\n    long long have = solve();\n    printf(\"%lld\\n\", have);\n  }\n  for (int i = (0); i <= (11); ++i) printf(\"perf[%d]=%lld\\n\", i, perf[i]);\n}\nint main() {\n  run();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 200005;\nint n, m, id[maxn], ch[maxn][2], fa[maxn], nx[4] = {1, -1, 0, 0},\n                                           ny[4] = {0, 0, 1, -1};\nbool rev[maxn];\nvector<int> g[maxn];\ninline void reverse(int x) {\n  if (!x) return;\n  swap(ch[x][0], ch[x][1]), rev[x] ^= 1;\n}\ninline void pushdown(int x) {\n  if (rev[x]) reverse(ch[x][0]), reverse(ch[x][1]), rev[x] = 0;\n}\ninline bool nrt(int x) { return ch[fa[x]][0] == x || ch[fa[x]][1] == x; }\ninline void rotate(int x) {\n  int y = fa[x], z = fa[y], k = (ch[y][1] == x), u = ch[x][k ^ 1];\n  if (nrt(y)) ch[z][ch[z][1] == y] = x;\n  ch[y][k] = u, ch[x][k ^ 1] = y;\n  if (u) fa[u] = y;\n  fa[y] = x, fa[x] = z;\n}\ninline void splay(int x) {\n  static int sta[maxn], top;\n  int y, z;\n  top = 0;\n  for (y = x; nrt(y); y = fa[y]) sta[++top] = y;\n  pushdown(y);\n  for (; top; top--) pushdown(sta[top]);\n  while (nrt(x)) {\n    y = fa[x], z = fa[y];\n    if (nrt(y)) rotate((ch[y][1] == x) ^ (ch[z][1] == y) ? x : y);\n    rotate(x);\n  }\n}\ninline void access(int x) {\n  for (int y = 0; x; y = x, x = fa[x]) splay(x), ch[x][1] = y;\n}\ninline void makeroot(int x) { access(x), splay(x), reverse(x); }\ninline int findroot(int x) {\n  access(x), splay(x);\n  for (; ch[x][0]; x = ch[x][0]) pushdown(x);\n  splay(x);\n  return x;\n}\ninline void split(int x, int y) { makeroot(x), access(y), splay(y); }\ninline bool link(int x, int y) {\n  makeroot(x);\n  if (findroot(y) == x) return false;\n  fa[x] = y;\n  return true;\n}\ninline void cut(int x, int y) {\n  split(x, y);\n  if (fa[x] == y && !ch[x][1]) fa[x] = ch[y][0] = 0;\n}\ninline pair<int, int> operator+(const pair<int, int> &a,\n                                const pair<int, int> &b) {\n  return pair<int, int>(\n      min(a.first, b.first),\n      (a.first <= b.first) * a.second + (a.first >= b.first) * b.second);\n}\nstruct Segment_Tree {\n  pair<int, int> sum[maxn << 2];\n  int add[maxn << 2];\n  inline void pushdown(int rt) {\n    if (add[rt])\n      sum[(rt << 1)].first += add[rt], sum[(rt << 1 | 1)].first += add[rt],\n          add[(rt << 1)] += add[rt], add[(rt << 1 | 1)] += add[rt], add[rt] = 0;\n  }\n  void build(int rt, int l, int r) {\n    if (l == r) {\n      sum[rt] = pair<int, int>(0, 1);\n      return;\n    }\n    int mid = (l + r) >> 1;\n    build((rt << 1), l, mid), build((rt << 1 | 1), mid + 1, r),\n        sum[rt] = sum[(rt << 1)] + sum[(rt << 1 | 1)];\n  }\n  void update(int rt, int l, int r, int x, int y, int z) {\n    if (x <= l && r <= y) {\n      sum[rt].first += z, add[rt] += z;\n      return;\n    }\n    pushdown(rt);\n    int mid = (l + r) >> 1;\n    if (x <= mid) update((rt << 1), l, mid, x, y, z);\n    if (y > mid) update((rt << 1 | 1), mid + 1, r, x, y, z);\n    sum[rt] = sum[(rt << 1)] + sum[(rt << 1 | 1)];\n  }\n  pair<int, int> query(int rt, int l, int r, int x, int y) {\n    if (x <= l && r <= y) return sum[rt];\n    pushdown(rt);\n    int mid = (l + r) >> 1;\n    if (y <= mid) return query((rt << 1), l, mid, x, y);\n    if (x > mid) return query((rt << 1 | 1), mid + 1, r, x, y);\n    return query((rt << 1), l, mid, x, y) +\n           query((rt << 1 | 1), mid + 1, r, x, y);\n  }\n} T;\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n * m; i++) scanf(\"%d\", &id[i]);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      for (int k = 0; k < 4; k++) {\n        int x = i + nx[k], y = j + ny[k];\n        if (x < 1 || x > n || y < 1 || y > m) continue;\n        g[id[(i - 1) * m + j]].push_back(id[(x - 1) * m + y]);\n      }\n  n *= m, T.build(1, 1, n);\n  long long ans = 0;\n  for (int i = 1, j = 1; i <= n; i++) {\n    for (; j <= n; j++) {\n      int fl = 0, ecnt = 0;\n      for (auto k : g[j])\n        if (k >= i && k < j) {\n          if (!link(j, k)) {\n            fl = k;\n            break;\n          }\n          ecnt++;\n        }\n      if (fl) {\n        for (auto k : g[j])\n          if (k >= i && k < j) {\n            if (fl == k) break;\n            cut(j, k);\n          }\n        break;\n      }\n      T.update(1, 1, n, j, j, j - i + 1), T.update(1, 1, n, j, n, -ecnt);\n    }\n    ans += T.query(1, 1, n, i, j - 1).second;\n    for (auto k : g[i])\n      if (k > i && k < j) cut(i, k), T.update(1, 1, n, k, n, 1);\n    T.update(1, 1, n, i, j - 1, -1);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing std::sort;\nconst int MAXN = 2 * 1e5 + 50;\nint c[2][MAXN], f[MAXN];\nbool rev[MAXN];\ninline void pushdown(int x) {\n  if (rev[x]) {\n    rev[c[0][x]] ^= 1, rev[c[1][x]] ^= 1;\n    c[0][x] ^= c[1][x] ^= c[0][x] ^= c[1][x];\n    rev[x] = 0;\n  }\n}\ninline bool isroot(int x) {\n  return (!(c[0][f[x]] == x || c[1][f[x]] == x) || f[x] == 0);\n}\ninline bool get(int x) { return c[1][f[x]] == x; }\ninline void rotate(int x) {\n  bool r = get(x), rf = get(f[x]);\n  int y = f[x], z = f[y], a = c[!r][x];\n  f[x] = z;\n  if (!isroot(y)) c[rf][z] = x;\n  f[y] = x, c[!r][x] = y;\n  f[a] = y, c[r][y] = a;\n}\ninline void pushall(int x) {\n  if (!isroot(x)) pushall(f[x]);\n  pushdown(x);\n}\ninline void splay(int x) {\n  pushall(x);\n  for (; !isroot(x); rotate(x))\n    if (!isroot(f[x])) rotate((get(f[x]) == get(x)) ? f[x] : x);\n}\ninline void access(int x) {\n  for (int pre = 0; x; pre = x, x = f[x]) {\n    splay(x);\n    c[1][x] = pre;\n  }\n}\ninline void setroot(int x) {\n  access(x), splay(x);\n  rev[x] = 1;\n}\ninline bool connected2(int x, int y) {\n  if (x == y) return 1;\n  access(x), splay(x);\n  access(y), splay(y);\n  return f[x] != 0;\n}\ninline int findroot(int x) {\n  access(x), splay(x);\n  while (c[0][x]) x = c[0][x], pushdown(x);\n  splay(x);\n  return x;\n}\ninline bool connected(int x, int y) {\n  if (findroot(x) == findroot(y))\n    return 1;\n  else\n    return 0;\n}\ninline void cut(int x, int y) {\n  setroot(x), access(y), splay(x);\n  c[1][x] = f[y] = 0;\n}\ninline void link(int x, int y) {\n  setroot(x);\n  f[x] = y;\n}\nint N = 1, min[3 * MAXN], cnt[3 * MAXN], det[3 * MAXN];\nbool lazy[3 * MAXN];\ninline void pushupSeg(int v) {\n  if (min[v << 1] == min[(v << 1) | 1]) {\n    min[v] = min[v << 1];\n    cnt[v] = cnt[v << 1] + cnt[(v << 1) | 1];\n  } else if (min[v << 1] < min[(v << 1) | 1])\n    min[v] = min[v << 1], cnt[v] = cnt[v << 1];\n  else\n    min[v] = min[(v << 1) | 1], cnt[v] = cnt[(v << 1) | 1];\n}\ninline void pushdownSeg(int v) {\n  if (lazy[v]) {\n    min[v << 1] += det[v], min[(v << 1) | 1] += det[v];\n    det[v << 1] += det[v], det[(v << 1) | 1] += det[v];\n    lazy[v << 1] = lazy[(v << 1) | 1] = 1;\n    lazy[v] = 0;\n    det[v] = 0;\n  }\n}\ninline void updata(int l, int r, int d, int v = 1, int nl = 1, int nr = N) {\n  if (l > r) return;\n  if (l == nl && r == nr) {\n    min[v] += d;\n    det[v] += d;\n    lazy[v] = 1;\n    return;\n  }\n  pushdownSeg(v);\n  int mid = (nl + nr) >> 1;\n  if (r <= mid)\n    updata(l, r, d, v << 1, nl, mid);\n  else if (l > mid)\n    updata(l, r, d, (v << 1) | 1, mid + 1, nr);\n  else\n    updata(l, mid, d, v << 1, nl, mid),\n        updata(mid + 1, r, d, (v << 1) | 1, mid + 1, nr);\n  pushupSeg(v);\n}\ninline int query(int l, int r, int v = 1, int nl = 1, int nr = N) {\n  if (l == nl && r == nr) {\n    if (min[v] != 1)\n      return 0;\n    else\n      return cnt[v];\n  }\n  pushdownSeg(v);\n  int mid = (nl + nr) >> 1;\n  if (r <= mid)\n    return query(l, r, v << 1, nl, mid);\n  else if (l > mid)\n    return query(l, r, (v << 1) | 1, mid + 1, nr);\n  else\n    return query(l, mid, v << 1, nl, mid) +\n           query(mid + 1, r, (v << 1) | 1, mid + 1, nr);\n}\nint posx[MAXN], posy[MAXN], dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\nint map[2000][2000], n, m;\ninline int read() {\n  int x = 0;\n  char cc = getchar();\n  while (cc < '0' || cc > '9') cc = getchar();\n  while (cc >= '0' && cc <= '9')\n    x = (x << 3) + (x << 1) + (48 ^ cc), cc = getchar();\n  return x;\n}\ninline int outmap(int x, int y) {\n  if (x < 0 || x >= n) return -1;\n  if (y < 0 || y >= m) return -1;\n  return map[x][y];\n}\ninline int test() {\n  N = 8;\n  for (int k = 1, count = N, d = 1; k <= N; d += k, k <<= 1, count >>= 1)\n    for (int i = 0; i < k; ++i) cnt[d + i] = count;\n  printf(\"%d\\n\", query(1, 8));\n  updata(1, 4, 1);\n  printf(\"%d\\n\", query(1, 8));\n  updata(1, 3, -1);\n  printf(\"%d\\n\", query(1, 8));\n  updata(1, 2, -8);\n  printf(\"%d\\n\", query(1, 1));\n  return 0;\n}\nint main() {\n  n = read(), m = read();\n  while (N < n * m) N <<= 1;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j) {\n      map[i][j] = read();\n      posx[map[i][j]] = i, posy[map[i][j]] = j;\n    }\n  for (int k = 1, count = N, d = 1; k <= N; d += k, k <<= 1, count >>= 1)\n    for (int i = 0; i < k; ++i) cnt[d + i] = count;\n  long long ans = 0;\n  for (int l = 1, r = 0; l <= n * m; ++l) {\n    for (int r2 = r + 1; r2 <= n * m; ++r2) {\n      int lnk[4], tot = 0, count = 0;\n      bool brek = 0;\n      for (int d = 0; d < 4; ++d) {\n        int to = outmap(posx[r2] + dx[d], posy[r2] + dy[d]);\n        if (to == -1 || to > r2 || to < l) continue;\n        if (!connected(r2, to))\n          link(r2, to), lnk[tot++] = to, ++count;\n        else {\n          brek = 1;\n          break;\n        }\n      }\n      if (brek) {\n        for (int i = 0; i < tot; ++i) cut(r2, lnk[i]);\n        break;\n      }\n      updata(r2, n * m, 1 - count);\n      r = r2;\n    }\n    ans += query(l, r);\n    int lnk[4], tot = 0;\n    for (int d = 0; d < 4; ++d) {\n      int to = outmap(posx[l] + dx[d], posy[l] + dy[d]);\n      if (to == -1) continue;\n      if (connected(l, to)) cut(l, to), lnk[tot++] = to;\n    }\n    sort(lnk, lnk + tot);\n    if (tot > 0)\n      updata(l, lnk[0] - 1, -1);\n    else\n      updata(l, m * n, -1);\n    for (int i = 1; i < tot; ++i) {\n      if (!connected(lnk[i - 1], lnk[i])) updata(lnk[i], n * m, 1);\n    }\n  }\n  printf(\"%lld\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int maxn = 200000, maxm = 2000, MAX = 1e6 + 5, mod = 998244353;\nconst long double Pi = 3.14159265358979323846l, Eps = 1e-4;\ntemplate <class T>\ninline bool equal(T x, T y) {\n  return fabs(x - y) < Eps;\n}\ninline int add(int x, int y) {\n  x += y;\n  return x >= mod ? x - mod : x;\n};\ninline void inc(int &x, int y) {\n  x += y;\n  x -= (x >= mod ? mod : 0);\n}\ninline int mul(int x, int y) { return 1ll * x * y % mod; }\ninline int Power(int x, int y, int Mod = mod) {\n  int ans = 1;\n  while (y) {\n    if (y & 1) ans = (long long)ans * x % Mod;\n    x = (long long)x * x % Mod, y >>= 1;\n  }\n  return ans;\n}\ntemplate <class T>\ninline T input() {\n  T x;\n  char ch;\n  bool flag = false;\n  while (!isdigit(ch = getchar())) flag |= ch == '-';\n  for (x = ch ^ 48; isdigit(ch = getchar()); x = x * 10 + (ch ^ 48))\n    ;\n  return flag ? -x : x;\n}\ntemplate <class T>\ninline bool chkmin(T &x, T y) {\n  x = x < y ? x : y;\n  return x == y;\n}\ntemplate <class T>\ninline bool chkmax(T &x, T y) {\n  x = x > y ? x : y;\n  return x == y;\n}\ntemplate <class T>\ninline T gcd(T x, T y) {\n  return !y ? x : gcd(y, x % y);\n}\ntemplate <class T>\ninline T sqrm(T x) {\n  return (long long)x * x % mod;\n}\ntemplate <class T>\ninline T sqr(T x) {\n  return x * x;\n}\nstruct {\n  inline operator int() { return input<int>(); }\n  inline operator long long() { return input<long long>(); }\n  template <class T>\n  inline void operator()(T &x) {\n    x = *this;\n  }\n  template <class T, class... A>\n  inline void operator()(T &x, A &...a) {\n    x = *this;\n    this->operator()(a...);\n  }\n} read;\nint n, m, tot;\nint Map[maxm + 5][maxm + 5];\nint x[maxn + 5], y[maxn + 5];\nint dx[4] = {0, 0, -1, 1}, dy[4] = {-1, 1, 0, 0};\nbool used[maxn + 5], vis[maxn + 5];\nnamespace Tree {\nint min[maxn * 3], cnt[maxn * 3], add[maxn * 3];\nvoid update(int rt) {\n  if (min[rt << 1] < min[rt << 1 | 1])\n    min[rt] = min[rt << 1], cnt[rt] = cnt[rt << 1];\n  else if (min[rt << 1] > min[rt << 1 | 1])\n    min[rt] = min[rt << 1 | 1], cnt[rt] = cnt[rt << 1 | 1];\n  else\n    min[rt] = min[rt << 1], cnt[rt] = cnt[rt << 1] + cnt[rt << 1 | 1];\n}\nvoid build(int rt, int l, int r) {\n  if (l == r) return min[rt] = l, cnt[rt] = 1, void();\n  build(rt << 1, l, ((l + r) >> 1)), build(rt << 1 | 1, ((l + r) >> 1) + 1, r);\n  update(rt);\n}\nvoid Add(int rt, int v) { min[rt] += v, add[rt] += v; }\nvoid pushdown(int rt) {\n  if (!add[rt]) return void();\n  Add(rt << 1, add[rt]);\n  Add(rt << 1 | 1, add[rt]);\n  add[rt] = 0;\n}\nvoid Add(int rt, int l, int r, int L, int R, int v) {\n  if (L <= l && r <= R) return Add(rt, v);\n  pushdown(rt);\n  if (L <= ((l + r) >> 1)) Add(rt << 1, l, ((l + r) >> 1), L, R, v);\n  if (R > ((l + r) >> 1)) Add(rt << 1 | 1, ((l + r) >> 1) + 1, r, L, R, v);\n  update(rt);\n}\nvoid Add(int l, int r, int v) { return Add(1, 1, tot, l, r, v); }\nvoid query(int rt, int l, int r, int L, int R, int &Min, int &res) {\n  if (L <= l && r <= R) {\n    if (min[rt] < Min)\n      Min = min[rt], res = cnt[rt];\n    else if (min[rt] == Min)\n      res += cnt[rt];\n    return void();\n  }\n  pushdown(rt);\n  if (L <= ((l + r) >> 1)) query(rt << 1, l, ((l + r) >> 1), L, R, Min, res);\n  if (R > ((l + r) >> 1))\n    query(rt << 1 | 1, ((l + r) >> 1) + 1, r, L, R, Min, res);\n}\nint query(int l, int r) {\n  int min = 0x3f3f3f3f, res = 0;\n  query(1, 1, tot, l, r, min, res);\n  return res;\n}\n}  // namespace Tree\nnamespace LCT {\nint fa[maxn + 5], ch[maxn + 5][2];\nbool rev[maxn + 5];\ninline int pd(int x) { return ch[fa[x]][1] == x; }\ninline bool isroot(int x) { return ch[fa[x]][0] != x && ch[fa[x]][1] != x; }\ninline void reverse(int x) { std::swap(ch[x][0], ch[x][1]), rev[x] ^= 1; }\ninline void rotate(int x) {\n  int y = fa[x], g = fa[y], c = pd(x), B = ch[x][!c];\n  if (!isroot(y)) ch[g][pd(y)] = x;\n  ch[x][!c] = y, ch[y][c] = B;\n  fa[x] = g, fa[y] = x;\n  if (B) fa[B] = y;\n}\nvoid pushdown(int x) {\n  if (!rev[x]) return void();\n  if (ch[x][0]) reverse(ch[x][0]);\n  if (ch[x][1]) reverse(ch[x][1]);\n  rev[x] = 0;\n}\nvoid pushall(int x) {\n  if (!isroot(x)) pushall(fa[x]);\n  pushdown(x);\n}\ninline void splay(int x) {\n  pushall(x);\n  while (!isroot(x)) {\n    int y = fa[x];\n    if (!isroot(y)) rotate(pd(x) ^ pd(y) ? x : y);\n    rotate(x);\n  }\n}\nvoid access(int x) {\n  for (int y = 0; x; x = fa[y = x]) splay(x), ch[x][1] = y;\n}\nint findroot(int x) {\n  access(x), splay(x);\n  while (ch[x][0]) pushdown(x), x = ch[x][0];\n  return splay(x), x;\n}\nvoid makeroot(int x) { access(x), splay(x), reverse(x); }\nvoid link(int x, int y) { makeroot(x), fa[x] = y; }\nvoid cut(int x, int y) {\n  makeroot(x), access(y), splay(y);\n  ch[y][0] = fa[x] = 0;\n}\n}  // namespace LCT\nbool check(int r) {\n  for (int i = 0; i < 4; ++i) {\n    int va = Map[x[r] + dx[i]][y[r] + dy[i]];\n    if (used[va] || va > r) continue;\n    for (int j = i + 1; j < 4; ++j) {\n      int vb = Map[x[r] + dx[j]][y[r] + dy[j]];\n      if (used[vb] || vb > r) continue;\n      if (LCT::findroot(va) == LCT::findroot(vb)) return false;\n    }\n  }\n  return true;\n}\nvoid add(int r) {\n  vis[r] = true;\n  for (int i = 0; i < 4; ++i) {\n    int tox = x[r] + dx[i], toy = y[r] + dy[i], to = Map[tox][toy];\n    if (!used[to] && to < r) {\n      Tree::Add(r, tot, -1);\n      LCT::link(r, to);\n    }\n  }\n}\nvoid del(int l) {\n  Tree::Add(l, tot, -1), used[l] = true;\n  for (int i = 0; i < 4; ++i) {\n    int tox = x[l] + dx[i], toy = y[l] + dy[i], to = Map[tox][toy];\n    if (vis[to] && to > l) {\n      Tree::Add(to, tot, 1);\n      LCT::cut(l, to);\n    }\n  }\n}\nsigned main() {\n  used[0] = true;\n  read(n, m), tot = n * m;\n  Tree::build(1, 1, tot);\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j) {\n      read(Map[i][j]);\n      x[Map[i][j]] = i;\n      y[Map[i][j]] = j;\n    }\n  long long ans = 0;\n  for (int l = 1, r = 0; l <= tot; ++l) {\n    while (r < tot && check(r + 1)) add(++r);\n    ans += Tree::query(l, r);\n    del(l);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct StVal {\n  int minV = 0, numMin = 0;\n  StVal() {}\n  StVal(const int _v) : minV(_v), numMin(1) {}\n  StVal(const StVal& v1, const StVal& v2) {\n    if (v1.minV < v2.minV) {\n      minV = v1.minV;\n      numMin = v1.numMin;\n    } else if (v1.minV > v2.minV) {\n      minV = v2.minV;\n      numMin = v2.numMin;\n    } else {\n      minV = v1.minV;\n      numMin = v1.numMin + v2.numMin;\n    }\n  }\n};\nstruct StUpdate {\n  int v = 0;\n  StUpdate() {}\n  StUpdate(const int v) : v(v) {}\n  StUpdate(const StUpdate& u1, const StUpdate& u2) { v = u1.v + u2.v; }\n  void apply(StVal& sv, const int lo, const int hi) { sv.minV += v; }\n};\nstruct SegTree {\n  int n;\n  vector<StVal> st;\n  vector<StUpdate> lazy;\n  vector<int> leaves;\n  SegTree(const int n) : n(n) {\n    leaves.resize(n);\n    init(1, 0, n - 1);\n    lazy.resize(st.size());\n  }\n  void init(const int si, const int lo, const int hi) {\n    if (lo == hi) {\n      if (si >= (int)st.size()) {\n        st.resize(si + 1);\n      }\n      st[si] = StVal(0);\n      leaves[lo] = si;\n      return;\n    }\n    int lC = si << 1, rC = (si << 1) | 1, mid = (lo + hi) >> 1;\n    init(lC, lo, mid);\n    init(rC, mid + 1, hi);\n    st[si] = StVal(st[lC], st[rC]);\n  }\n  void updateLazy(const int si, const int lo, const int hi) {\n    lazy[si].apply(st[si], lo, hi);\n    if (lo != hi) {\n      lazy[si << 1] = StUpdate(lazy[si << 1], lazy[si]);\n      lazy[si << 1 | 1] = StUpdate(lazy[si << 1 | 1], lazy[si]);\n    }\n    lazy[si] = StUpdate();\n  }\n  StVal query(const int l, const int r) {\n    return (l <= r && l < n && r >= 0) ? query(l, r, 1, 0, n - 1) : StVal();\n  }\n  StVal query(const int l, const int r, const int si, const int lo,\n              const int hi) {\n    updateLazy(si, lo, hi);\n    if (l <= lo && hi <= r) return st[si];\n    const int mid = (lo + hi) >> 1;\n    if (r <= mid) return query(l, r, si << 1, lo, mid);\n    if (mid < l) return query(l, r, si << 1 | 1, mid + 1, hi);\n    return StVal(query(l, r, si << 1, lo, mid),\n                 query(l, r, si << 1 | 1, mid + 1, hi));\n  }\n  void update(const int l, const int r, const StUpdate u) {\n    if (l <= r) update(l, r, u, 1, 0, n - 1);\n  }\n  void update(const int l, const int r, const StUpdate& u, const int si,\n              const int lo, const int hi) {\n    if (l <= lo && hi <= r) {\n      lazy[si] = StUpdate(lazy[si], u);\n      updateLazy(si, lo, hi);\n    } else {\n      updateLazy(si, lo, hi);\n      if (hi < l || r < lo) return;\n      const int mid = (lo + hi) >> 1;\n      update(l, r, u, si << 1, lo, mid);\n      update(l, r, u, si << 1 | 1, mid + 1, hi);\n      st[si] = StVal(st[si << 1], st[si << 1 | 1]);\n    }\n  }\n  void updateAllLazy() { updateAllLazy(1, 0, n - 1); }\n  void updateAllLazy(const int si, const int lo, const int hi) {\n    updateLazy(si, lo, hi);\n    if (lo != hi) {\n      const int mid = (lo + hi) >> 1;\n      updateAllLazy(si << 1, lo, mid);\n      updateAllLazy(si << 1 | 1, mid + 1, hi);\n    }\n  }\n};\nstruct NodeVal {\n  int subtreeSize;\n  NodeVal() : subtreeSize(1) {}\n  void update(NodeVal* lChild, NodeVal* rChild) {\n    subtreeSize = 1 + (lChild ? lChild->subtreeSize : 0) +\n                  (rChild ? rChild->subtreeSize : 0);\n  }\n};\nstruct Node {\n  int id;\n  array<Node*, 2> child{};\n  Node* splayTreeParent = nullptr;\n  Node* pathParentPointer = nullptr;\n  NodeVal* val;\n  bool reverse = false;\n  Node(int id, NodeVal* _val) : id(id), val(_val) {}\n  bool getSide() {\n    return splayTreeParent ? splayTreeParent->child[1] == this : false;\n  }\n  void applyReverseLazy() {\n    if (!reverse) {\n      return;\n    }\n    reverse = false;\n    swap(child[0], child[1]);\n    if (child[0]) {\n      child[0]->reverse = !child[0]->reverse;\n    }\n    if (child[1]) {\n      child[1]->reverse = !child[1]->reverse;\n    }\n  }\n  Node* splay() {\n    stack<Node*> ancestors;\n    Node* cur = this;\n    while (cur) {\n      ancestors.push(cur);\n      cur = cur->splayTreeParent;\n    }\n    while (ancestors.size()) {\n      ancestors.top()->applyReverseLazy();\n      ancestors.pop();\n    }\n    while (splayTreeParent) {\n      if (splayTreeParent->splayTreeParent) {\n        (getSide() == splayTreeParent->getSide() ? splayTreeParent : this)\n            ->rotate();\n      }\n      rotate();\n    }\n    return this;\n  }\n  Node* rotate() {\n    bool side = getSide(), parentSide = splayTreeParent->getSide();\n    auto ancestor = splayTreeParent->splayTreeParent;\n    pathParentPointer = splayTreeParent->pathParentPointer;\n    splayTreeParent->pathParentPointer = nullptr;\n    splayTreeParent->attach(child[!side], side);\n    attach(splayTreeParent, !side);\n    if (ancestor)\n      ancestor->attach(this, parentSide);\n    else\n      splayTreeParent = nullptr;\n    return this;\n  }\n  Node* attach(Node* node, int side) {\n    if (node) node->splayTreeParent = this;\n    child[side] = node;\n    val->update((child[0] ? child[0]->val : nullptr),\n                (child[1] ? child[1]->val : nullptr));\n    return this;\n  }\n  void detachChild(bool b) {\n    if (!child[b]) {\n      return;\n    }\n    child[b]->pathParentPointer = this;\n    child[b]->splayTreeParent = nullptr;\n    child[b] = nullptr;\n  }\n  Node* findMax() { return getDeepest(1); }\n  Node* findMin() { return getDeepest(0); }\n\n private:\n  Node* getDeepest(int dir) {\n    Node* u = this;\n    applyReverseLazy();\n    while (u && u->child[dir]) {\n      u = u->child[dir];\n      u->applyReverseLazy();\n    }\n    return u->splay();\n  }\n};\nstruct LinkCutTree {\n  int n = 0;\n  vector<Node*> nodes;\n  int addNode(NodeVal* nodeVal) {\n    nodes.push_back(new Node(n, nodeVal));\n    return n++;\n  }\n  void link(int parentId, int childId) {\n    Node *parent = nodes[parentId], *child = nodes[childId];\n    assert(findRoot(child->id) != findRoot(parent->id));\n    access(child);\n    access(parent);\n    Node* lChild = child->child[0];\n    if (lChild) {\n      lChild->reverse = !lChild->reverse;\n      child->detachChild(0);\n    }\n    child->attach(parent, 0);\n  }\n  void cut(int id) {\n    Node* u = nodes[id];\n    access(u);\n    assert(u->child[0]);\n    u->child[0]->splayTreeParent = nullptr;\n    u->child[0] = nullptr;\n  }\n  void cut(int id1, int id2) {\n    Node *u = nodes[id1], *v = nodes[id2];\n    access(u);\n    if (u->child[0] && u->child[0]->findMax() == v) {\n      cut(u->id);\n    }\n    access(v);\n    if (v->child[0] && v->child[0]->findMax() == u) {\n      cut(v->id);\n    }\n  }\n  int findRoot(int id) {\n    Node* u = nodes[id];\n    access(u);\n    Node* res = u->findMin();\n    access(res);\n    return res->id;\n  }\n  int LCA(int id1, int id2) {\n    Node *u = nodes[id1], *v = nodes[id2];\n    if (findRoot(u->id) != findRoot(v->id)) {\n      return -1;\n    }\n    access(u);\n    return access(v)->id;\n  }\n  int pathAggregate(int id) {\n    Node* u = nodes[id];\n    access(u);\n    return u->id;\n  }\n  Node* getNode(int id) { return nodes[id]; }\n\n private:\n  Node* access(Node* u) {\n    u->splay();\n    u->detachChild(1);\n    Node* curPP = u;\n    while (u->pathParentPointer) {\n      curPP = u->pathParentPointer;\n      curPP->splay();\n      curPP->detachChild(1);\n      curPP->attach(u, 1);\n      u->pathParentPointer = nullptr;\n      u->splay();\n    }\n    return curPP;\n  }\n};\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nvector<int> numToID;\nint n, m;\nvoid cutNeighbors(LinkCutTree& lct, vector<vector<int>>& grid, int l, int r) {\n  int i = numToID[l] / m, j = numToID[l] % m;\n  int idx = numToID[l];\n  for (int k = 0; k < 4; k++) {\n    int ni = i + dx[k], nj = j + dy[k];\n    if (ni < 0 || nj < 0 || ni == n || nj == m) {\n      continue;\n    }\n    if (grid[ni][nj] < l || grid[ni][nj] > r) {\n      continue;\n    }\n    int nIdx = numToID[grid[ni][nj]];\n    lct.cut(idx, nIdx);\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0), cout.tie(0);\n  LinkCutTree lct;\n  cin >> n >> m;\n  vector<vector<int>> grid(n, vector<int>(m));\n  numToID.resize(n * m + 1);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      cin >> grid[i][j];\n      numToID[grid[i][j]] = lct.addNode(new NodeVal());\n    }\n  }\n  SegTree st(n * m + 1);\n  long long ans = 0;\n  int l = 1;\n  for (int r = 1; r <= m * n; r++) {\n    st.update(l, r, StUpdate(1));\n    int i = numToID[r] / m, j = numToID[r] % m;\n    int idx = numToID[r];\n    for (int k = 0; k < 4; k++) {\n      int ni = i + dx[k], nj = j + dy[k];\n      if (ni < 0 || nj < 0 || ni == n || nj == m) {\n        continue;\n      }\n      if (grid[ni][nj] < l || grid[ni][nj] > r) {\n        continue;\n      }\n      int nIdx = numToID[grid[ni][nj]];\n      while (lct.findRoot(idx) == lct.findRoot(nIdx)) {\n        cutNeighbors(lct, grid, l, r);\n        l++;\n      }\n      if (l > grid[ni][nj]) {\n        continue;\n      }\n      if (l == r) {\n        break;\n      }\n      lct.link(idx, nIdx);\n      st.update(l, grid[ni][nj], StUpdate(-1));\n    }\n    ans += st.query(l, r).numMin;\n  }\n  cout << ans << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MAXN = 1010;\nconst int INF = 0x3f3f3f3f;\nconst int MAXP = 2e5 + 10;\nint fa[MAXP], son[MAXP][2];\nint get(int x, int b = 1) { return son[fa[x]][b] == x; }\nint isroot(int x) { return !(get(x, 0) || get(x, 1)); }\nvoid rotate(int x) {\n  int y = fa[x], z = fa[y];\n  bool b = get(x);\n  if (!isroot(y)) son[z][get(y)] = x;\n  son[y][b] = son[x][!b];\n  son[x][!b] = y;\n  fa[y] = x;\n  fa[x] = z;\n  if (int t = son[y][b]) fa[t] = y;\n}\nint tag[MAXP];\nvoid pushdown(int x) {\n  if (tag[x]) {\n    if (int t = son[x][0]) tag[t] ^= 1;\n    if (int t = son[x][1]) tag[t] ^= 1;\n    tag[x] = 0;\n    std::swap(son[x][0], son[x][1]);\n  }\n}\nvoid splay(int x) {\n  static int st[MAXP], top;\n  for (int y = st[top = 1] = x; !isroot(y); st[++top] = y = fa[y])\n    ;\n  for (; top; --top) pushdown(st[top]);\n  for (; !isroot(x); rotate(x))\n    if (!isroot(fa[x])) rotate(get(x) ^ get(fa[x]) ? x : fa[x]);\n}\nvoid access(int x) {\n  int t = 0;\n  while (x) {\n    splay(x);\n    son[x][1] = t;\n    t = x;\n    x = fa[x];\n  }\n}\nvoid mkroot(int x) {\n  access(x);\n  splay(x);\n  tag[x] ^= 1;\n}\nvoid link(int x, int y) {\n  mkroot(x);\n  fa[x] = y;\n}\nvoid split(int x, int y) { mkroot(x), access(y), splay(y); }\nvoid cut(int x, int y) {\n  split(x, y);\n  fa[x] = son[y][0] = 0;\n}\nbool conn(int x, int y) {\n  split(x, y);\n  while (true) {\n    pushdown(y);\n    if (son[y][0])\n      y = son[y][0];\n    else\n      break;\n  }\n  splay(y);\n  return x == y;\n}\nstruct info {\n  int mi, cnt;\n  friend info operator+(info a, info b) {\n    info r;\n    r.mi = std::min(a.mi, b.mi);\n    r.cnt = (a.mi == r.mi) * a.cnt + (b.mi == r.mi) * b.cnt;\n    return r;\n  }\n} tree[MAXP << 2];\nint tagadd[MAXP << 2];\nvoid mkadd(int u, int v) {\n  tagadd[u] += v;\n  tree[u].mi += v;\n}\nvoid sgtpushdown(int u) {\n  if (int& t = tagadd[u]) {\n    mkadd(u << 1, t);\n    mkadd(u << 1 | 1, t);\n    t = 0;\n  }\n}\nvoid mdf(int u, int l, int r, int L, int R, int v) {\n  if (L <= l && r <= R) return mkadd(u, v);\n  int mid = l + r >> 1;\n  sgtpushdown(u);\n  if (L <= mid) mdf(u << 1, l, mid, L, R, v);\n  if (mid < R) mdf(u << 1 | 1, mid + 1, r, L, R, v);\n  tree[u] = tree[u << 1] + tree[u << 1 | 1];\n}\ninfo qry(int u, int l, int r, int L, int R) {\n  if (L <= l && r <= R) return tree[u];\n  int mid = l + r >> 1;\n  sgtpushdown(u);\n  info res;\n  res.mi = INF, res.cnt = 0;\n  if (L <= mid) res = qry(u << 1, l, mid, L, R);\n  if (mid < R) res = res + qry(u << 1 | 1, mid + 1, r, L, R);\n  return res;\n}\nvoid build(int u, int l, int r) {\n  tree[u].cnt = r - l + 1;\n  if (l == r) return;\n  int mid = l + r >> 1;\n  build(u << 1, l, mid);\n  build(u << 1 | 1, mid + 1, r);\n}\nint ax[MAXP], ay[MAXP];\nint mat[MAXN][MAXN];\nint n, m;\nstd::vector<int> es[MAXP];\nint main() {\n  std::ios_base::sync_with_stdio(false), std::cin.tie(0);\n  std::cin >> n >> m;\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j) {\n      std::cin >> mat[i][j];\n      ax[mat[i][j]] = i;\n      ay[mat[i][j]] = j;\n    }\n  const int K = n * m;\n  build(1, 1, K);\n  long long ans = 0;\n  int cur = 1;\n  for (int i = 1; i <= K; ++i) {\n    mdf(1, 1, K, 1, i, 1);\n    const int dx[4] = {1, 0, -1, 0};\n    const int dy[4] = {0, 1, 0, -1};\n    int x = ax[i], y = ay[i];\n    for (int j = 0; j < 4; ++j) {\n      int tx = x + dx[j], ty = y + dy[j];\n      if (tx < 1 || ty < 1 || tx > n || ty > m) continue;\n      int v = mat[tx][ty];\n      if (v < i) {\n        mdf(1, 1, K, 1, v, -1);\n        while (conn(v, i)) {\n          for (auto t : es[cur]) cut(cur, t);\n          ++cur;\n        }\n        if (v >= cur) {\n          es[v].emplace_back(i);\n          link(v, i);\n        }\n      }\n    }\n    info res = qry(1, 1, K, cur, i);\n    if (res.mi == 1) ans += res.cnt;\n  }\n  std::cout << ans << std::endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int x = 0;\n  bool t = false;\n  char ch = getchar();\n  while ((ch < '0' || ch > '9') && ch != '-') ch = getchar();\n  if (ch == '-') t = true, ch = getchar();\n  while (ch <= '9' && ch >= '0') x = x * 10 + ch - 48, ch = getchar();\n  return t ? -x : x;\n}\nstruct Node {\n  int ff, ch[2], rev;\n} t[200200];\nbool isroot(int x) { return t[t[x].ff].ch[0] != x && t[t[x].ff].ch[1] != x; }\nvoid rotate(int x) {\n  int y = t[x].ff, z = t[y].ff;\n  int k = t[y].ch[1] == x;\n  if (!isroot(y)) t[z].ch[t[z].ch[1] == y] = x;\n  t[x].ff = z;\n  t[y].ch[k] = t[x].ch[k ^ 1];\n  t[t[x].ch[k ^ 1]].ff = y;\n  t[x].ch[k ^ 1] = y;\n  t[y].ff = x;\n}\nvoid pushdown(int x) {\n  if (t[x].rev)\n    t[(t[x].ch[0])].rev ^= 1, t[(t[x].ch[1])].rev ^= 1,\n        swap((t[x].ch[0]), (t[x].ch[1])), t[x].rev ^= 1;\n}\nint S[200200], top;\nvoid Splay(int x) {\n  S[top = 1] = x;\n  for (int i = x; !isroot(i); i = t[i].ff) S[++top] = t[i].ff;\n  while (top) pushdown(S[top--]);\n  while (!isroot(x)) {\n    int y = t[x].ff, z = t[y].ff;\n    if (!isroot(y))\n      (t[y].ch[0] == x) ^ (t[z].ch[0] == y) ? rotate(x) : rotate(y);\n    rotate(x);\n  }\n}\nvoid access(int x) {\n  for (int y = 0; x; y = x, x = t[x].ff) Splay(x), (t[x].ch[1]) = y;\n}\nvoid makeroot(int x) {\n  access(x);\n  Splay(x);\n  t[x].rev ^= 1;\n}\nvoid split(int x, int y) {\n  makeroot(x);\n  access(y);\n  Splay(y);\n}\nvoid link(int x, int y) {\n  makeroot(x);\n  t[x].ff = y;\n}\nvoid cut(int x, int y) {\n  split(x, y);\n  t[y].ch[0] = t[x].ff = 0;\n}\nint findroot(int x) {\n  access(x);\n  Splay(x);\n  while ((t[x].ch[0])) x = (t[x].ch[0]);\n  return x;\n}\nint n, m;\nlong long ans;\nint a[1010][1010];\nint X[200200], Y[200200];\nint d[4][2] = {1, 0, 0, 1, -1, 0, 0, -1};\nstruct SegMent {\n  struct Node {\n    int v, s;\n  } t[200200 << 2];\n  int tag[200200 << 2];\n  Node Merge(Node a, Node b) {\n    Node c;\n    c.v = min(a.v, b.v);\n    c.s = 0;\n    if (c.v == a.v) c.s += a.s;\n    if (c.v == b.v) c.s += b.s;\n    return c;\n  }\n  void pushup(int now) { t[now] = Merge(t[(now << 1)], t[(now << 1 | 1)]); }\n  void Build(int now, int l, int r) {\n    if (l == r) {\n      t[now] = (Node){1, 1};\n      return;\n    }\n    int mid = (l + r) >> 1;\n    Build((now << 1), l, mid);\n    Build((now << 1 | 1), mid + 1, r);\n    pushup(now);\n  }\n  void puttag(int now, int w) {\n    t[now].v += w;\n    tag[now] += w;\n  }\n  void pushdown(int now) {\n    puttag((now << 1), tag[now]);\n    puttag((now << 1 | 1), tag[now]);\n    tag[now] = 0;\n  }\n  void Modify(int now, int l, int r, int L, int R, int w) {\n    if (L <= l && r <= R) {\n      puttag(now, w);\n      return;\n    }\n    int mid = (l + r) >> 1;\n    pushdown(now);\n    if (L <= mid) Modify((now << 1), l, mid, L, R, w);\n    if (R > mid) Modify((now << 1 | 1), mid + 1, r, L, R, w);\n    pushup(now);\n  }\n  Node Query(int now, int l, int r, int L, int R) {\n    if (L == l && r == R) return t[now];\n    int mid = (l + r) >> 1;\n    pushdown(now);\n    if (R <= mid) return Query((now << 1), l, mid, L, R);\n    if (L > mid) return Query((now << 1 | 1), mid + 1, r, L, R);\n    return Merge(Query((now << 1), l, mid, L, mid),\n                 Query((now << 1 | 1), mid + 1, r, mid + 1, R));\n  }\n  int Query(int l, int r) {\n    Node a = Query(1, 1, n * m, l, r);\n    return a.v == 1 ? a.s : 0;\n  }\n} T;\nbool check(int l, int r, int p) {\n  for (int i = 0; i < 4; ++i) {\n    int x = X[p] + d[i][0], y = Y[p] + d[i][1];\n    if (x < 0 || y < 0 || x > n || y > m) continue;\n    if (!(l <= a[x][y] && a[x][y] <= r)) continue;\n    for (int j = i + 1; j < 4; ++j) {\n      int xx = X[p] + d[j][0], yy = Y[p] + d[j][1];\n      if (xx < 0 || yy < 0 || xx > n || yy > m) continue;\n      if (!(l <= a[xx][yy] && a[xx][yy] <= r)) continue;\n      if (findroot(a[x][y]) == findroot(a[xx][yy])) return false;\n    }\n  }\n  return true;\n}\nvoid Work(int l, int r, int p, int opt) {\n  for (int i = 0; i < 4; ++i) {\n    int x = X[p] + d[i][0], y = Y[p] + d[i][1];\n    if (x < 0 || y < 0 || x > n || y > m) continue;\n    if (!(l <= a[x][y] && a[x][y] <= r)) continue;\n    if (opt == -1)\n      cut(p, a[x][y]);\n    else\n      link(p, a[x][y]), T.Modify(1, 1, n * m, 1, a[x][y], -1);\n  }\n}\nint main() {\n  n = read();\n  m = read();\n  T.Build(1, 1, n * m);\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j) a[i][j] = read();\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j) X[a[i][j]] = i, Y[a[i][j]] = j;\n  for (int i = 1, p = 1; i <= n * m; ++i) {\n    while (!check(p, i - 1, i)) Work(p + 1, i - 1, p, -1), ++p;\n    Work(p, i - 1, i, 1);\n    ans += T.Query(p, i);\n    T.Modify(1, 1, n * m, p, i, 1);\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int gi() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (!isdigit(ch)) {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (isdigit(ch)) {\n    x = (x << 3) + (x << 1) + ch - 48;\n    ch = getchar();\n  }\n  return x * f;\n}\ntemplate <typename T>\ninline bool Max(T &a, T b) {\n  return a < b ? a = b, 1 : 0;\n}\ntemplate <typename T>\ninline bool Min(T &a, T b) {\n  return a > b ? a = b, 1 : 0;\n}\nconst int N = 2e5 + 7;\nint n, m;\nint a[1007][1007], c[N], r[N];\nint dr[] = {1, 0, -1, 0}, dc[] = {0, -1, 0, 1};\nnamespace lct {\nint t[N][2], fa[N], rev[N], L[N], R[N];\nbool isrt(int o) { return t[fa[o]][0] != o && t[fa[o]][1] != o; }\nint side(int o) { return t[fa[o]][1] == o; }\nvoid Reverse(int o) {\n  rev[o] ^= 1;\n  swap(L[t[o][0]], L[t[o][1]]);\n  swap(R[t[o][0]], R[t[o][1]]);\n  swap(t[o][0], t[o][1]);\n}\nvoid pushup(int o) {\n  L[o] = t[o][0] ? L[t[o][0]] : o;\n  R[o] = t[o][1] ? R[t[o][1]] : o;\n}\nvoid pushdown(int o) {\n  if (!rev[o]) return;\n  Reverse(t[o][0]);\n  Reverse(t[o][1]);\n  rev[o] = 0;\n}\nvoid rotate(int o) {\n  int f = fa[o], y = fa[f], x = side(o), s = t[o][x ^ 1];\n  if (!isrt(f)) t[y][side(f)] = o;\n  fa[o] = y;\n  t[f][x] = s, fa[s] = f;\n  t[o][x ^ 1] = f, fa[f] = o;\n  pushup(f), pushup(o);\n}\nint stk[N];\nvoid push(int o) {\n  int tp = 0;\n  stk[++tp] = o;\n  for (; !isrt(o); o = fa[o]) stk[++tp] = fa[o];\n  for (; tp; --tp) pushdown(stk[tp]);\n}\nvoid splay(int o) {\n  push(o);\n  for (; !isrt(o); rotate(o))\n    if (!isrt(fa[o])) rotate(side(o) == side(fa[o]) ? fa[o] : o);\n}\nvoid access(int o) {\n  for (int y = 0; o; y = o, o = fa[o]) {\n    splay(o);\n    t[o][1] = y;\n    pushup(o);\n  }\n}\nvoid maker(int o) {\n  access(o);\n  splay(o);\n  Reverse(o);\n}\nvoid link(int x, int y) {\n  maker(x);\n  fa[x] = y;\n}\nvoid cut(int x, int y) {\n  maker(x);\n  access(y);\n  splay(y);\n  fa[x] = t[y][0] = 0;\n  pushup(y);\n}\nint findr(int o) {\n  access(o);\n  splay(o);\n  return rev[o] ? R[o] : L[o];\n}\n}  // namespace lct\nint mi[N << 2], adv[N << 2], sum[N << 2];\nvoid st1(int o, int v) {\n  adv[o] += v;\n  mi[o] += v;\n}\nvoid pushdown(int o) {\n  if (!adv[o]) return;\n  st1(o << 1, adv[o]);\n  st1(o << 1 | 1, adv[o]);\n  adv[o] = 0;\n}\nvoid pushup(int o) {\n  mi[o] = min(mi[o << 1], mi[o << 1 | 1]);\n  sum[o] = 0;\n  if (mi[o] == mi[o << 1]) sum[o] += sum[o << 1];\n  if (mi[o] == mi[o << 1 | 1]) sum[o] += sum[o << 1 | 1];\n}\nvoid build(int l, int r, int o) {\n  if (l == r) {\n    sum[o] = 1;\n    return;\n  }\n  int mid = l + r >> 1;\n  build(l, mid, o << 1);\n  build(mid + 1, r, o << 1 | 1);\n  pushup(o);\n}\nvoid modify(int L, int R, int l, int r, int o, int v) {\n  if (L <= l && r <= R) {\n    st1(o, v);\n    return;\n  }\n  pushdown(o);\n  int mid = l + r >> 1;\n  if (L <= mid) modify(L, R, l, mid, o << 1, v);\n  if (R > mid) modify(L, R, mid + 1, r, o << 1 | 1, v);\n  pushup(o);\n}\nint query(int L, int R, int l, int r, int o) {\n  if (L <= l && r <= R) return mi[o] == 1 ? sum[o] : 0;\n  pushdown(o);\n  int mid = l + r >> 1;\n  if (R <= mid) return query(L, R, l, mid, o << 1);\n  if (L > mid) return query(L, R, mid + 1, r, o << 1 | 1);\n  return query(L, R, l, mid, o << 1) + query(L, R, mid + 1, r, o << 1 | 1);\n}\nint qmi(int L, int R, int l, int r, int o) {\n  if (L <= l && r <= R) return mi[o];\n  pushdown(o);\n  int mid = l + r >> 1;\n  if (R <= mid) return qmi(L, R, l, mid, o << 1);\n  if (L > mid) return qmi(L, R, mid + 1, r, o << 1 | 1);\n  return min(qmi(L, R, l, mid, o << 1), qmi(L, R, mid + 1, r, o << 1 | 1));\n}\nbool inside(int r, int c, int L, int R) {\n  return r && c && r <= n && c <= m && L <= a[r][c] && a[r][c] <= R;\n}\nlong long ans;\nint main() {\n  using namespace lct;\n  n = gi(), m = gi();\n  int maxn = n * m;\n  build(1, maxn, 1);\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j) a[i][j] = gi(), r[a[i][j]] = i, c[a[i][j]] = j;\n  for (int i = 1, now = 1; i <= n * m; ++i) {\n    int r = ::r[i], c = ::c[i];\n    int tmp = 0;\n    while (1) {\n      bool fg = 1;\n      int tt[4];\n      for (int d = 0; d <= 3; ++d) {\n        int tr = r + dr[d], tc = c + dc[d];\n        if (inside(tr, tc, now, i))\n          tt[d] = findr(a[tr][tc]);\n        else\n          tt[d] = -1;\n      }\n      for (int a = 0; a <= 3; ++a)\n        for (int b = 0; b <= a - 1; ++b)\n          if (tt[a] != -1 && tt[b] != -1 && tt[a] == tt[b]) fg = 0;\n      if (fg) {\n        for (int d = 0; d <= 3; ++d) {\n          int tr = r + dr[d], tc = c + dc[d];\n          if (inside(tr, tc, now, i)) link(i, a[tr][tc]);\n        }\n        break;\n      } else {\n        for (int d = 0; d <= 3; ++d) {\n          int tr = ::r[now] + dr[d], tc = ::c[now] + dc[d];\n          if (inside(tr, tc, now, i)) cut(now, a[tr][tc]);\n        }\n        ++now;\n      }\n    }\n    modify(1, i, 1, maxn, 1, 1);\n    for (int d = 0; d <= 3; ++d) {\n      int tr = r + dr[d], tc = c + dc[d];\n      if (inside(tr, tc, now, i)) modify(1, a[tr][tc], 1, maxn, 1, -1);\n    }\n    ans += query(now, i, 1, maxn, 1);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct StVal {\n  int minV = 0, numMin = 0;\n  StVal() {}\n  StVal(const int _v) : minV(_v), numMin(1) {}\n  StVal(const StVal& v1, const StVal& v2) {\n    if (v1.minV < v2.minV) {\n      minV = v1.minV;\n      numMin = v1.numMin;\n    } else if (v1.minV > v2.minV) {\n      minV = v2.minV;\n      numMin = v2.numMin;\n    } else {\n      minV = v1.minV;\n      numMin = v1.numMin + v2.numMin;\n    }\n  }\n};\nstruct StUpdate {\n  int v = 0;\n  StUpdate() {}\n  StUpdate(const int v) : v(v) {}\n  StUpdate(const StUpdate& u1, const StUpdate& u2) { v = u1.v + u2.v; }\n  void apply(StVal& sv, const int lo, const int hi) { sv.minV += v; }\n};\nstruct SegTree {\n  int n;\n  vector<StVal> st;\n  vector<StUpdate> lazy;\n  vector<int> leaves;\n  SegTree(const int n) : n(n) {\n    leaves.resize(n);\n    init(1, 0, n - 1);\n    lazy.resize(st.size());\n  }\n  void init(const int si, const int lo, const int hi) {\n    if (lo == hi) {\n      if (si >= (int)st.size()) {\n        st.resize(si + 1);\n      }\n      st[si] = StVal(0);\n      leaves[lo] = si;\n      return;\n    }\n    int lC = si << 1, rC = (si << 1) | 1, mid = (lo + hi) >> 1;\n    init(lC, lo, mid);\n    init(rC, mid + 1, hi);\n    st[si] = StVal(st[lC], st[rC]);\n  }\n  void updateLazy(const int si, const int lo, const int hi) {\n    lazy[si].apply(st[si], lo, hi);\n    if (lo != hi) {\n      lazy[si << 1] = StUpdate(lazy[si << 1], lazy[si]);\n      lazy[si << 1 | 1] = StUpdate(lazy[si << 1 | 1], lazy[si]);\n    }\n    lazy[si] = StUpdate();\n  }\n  StVal query(const int l, const int r) {\n    return (l <= r && l < n && r >= 0) ? query(l, r, 1, 0, n - 1) : StVal();\n  }\n  StVal query(const int l, const int r, const int si, const int lo,\n              const int hi) {\n    updateLazy(si, lo, hi);\n    if (l <= lo && hi <= r) return st[si];\n    const int mid = (lo + hi) >> 1;\n    if (r <= mid) return query(l, r, si << 1, lo, mid);\n    if (mid < l) return query(l, r, si << 1 | 1, mid + 1, hi);\n    return StVal(query(l, r, si << 1, lo, mid),\n                 query(l, r, si << 1 | 1, mid + 1, hi));\n  }\n  void update(const int l, const int r, const StUpdate u) {\n    if (l <= r) update(l, r, u, 1, 0, n - 1);\n  }\n  void update(const int l, const int r, const StUpdate& u, const int si,\n              const int lo, const int hi) {\n    if (l <= lo && hi <= r) {\n      lazy[si] = StUpdate(lazy[si], u);\n      updateLazy(si, lo, hi);\n    } else {\n      updateLazy(si, lo, hi);\n      if (hi < l || r < lo) return;\n      const int mid = (lo + hi) >> 1;\n      update(l, r, u, si << 1, lo, mid);\n      update(l, r, u, si << 1 | 1, mid + 1, hi);\n      st[si] = StVal(st[si << 1], st[si << 1 | 1]);\n    }\n  }\n  void updateAllLazy() { updateAllLazy(1, 0, n - 1); }\n  void updateAllLazy(const int si, const int lo, const int hi) {\n    updateLazy(si, lo, hi);\n    if (lo != hi) {\n      const int mid = (lo + hi) >> 1;\n      updateAllLazy(si << 1, lo, mid);\n      updateAllLazy(si << 1 | 1, mid + 1, hi);\n    }\n  }\n};\nstruct NodeVal {\n  int subtreeSize;\n  NodeVal() : subtreeSize(1) {}\n  void update(NodeVal* lChild, NodeVal* rChild) {\n    subtreeSize = 1 + (lChild ? lChild->subtreeSize : 0) +\n                  (rChild ? rChild->subtreeSize : 0);\n  }\n};\nstruct Node {\n  int id;\n  array<Node*, 2> child{};\n  Node* splayTreeParent = nullptr;\n  Node* pathParentPointer = nullptr;\n  NodeVal* val;\n  bool reverse = false;\n  Node(int id, NodeVal* _val) : id(id), val(_val) {}\n  bool getSide() {\n    return splayTreeParent ? splayTreeParent->child[1] == this : false;\n  }\n  void tryReverse() {\n    if (!reverse) {\n      return;\n    }\n    reverse = false;\n    swap(child[0], child[1]);\n    if (child[0]) {\n      child[0]->reverse = !child[0]->reverse;\n    }\n    if (child[1]) {\n      child[1]->reverse = !child[1]->reverse;\n    }\n  }\n  Node* splay() {\n    vector<Node*> ancestors;\n    Node* cur = this;\n    while (cur) {\n      ancestors.push_back(cur);\n      cur = cur->splayTreeParent;\n    }\n    for (int i = ancestors.size() - 1; i >= 0; i--) {\n      if (!ancestors[i]) {\n        continue;\n      }\n      ancestors[i]->tryReverse();\n    }\n    while (splayTreeParent) {\n      if (splayTreeParent->splayTreeParent) {\n        (getSide() == splayTreeParent->getSide() ? splayTreeParent : this)\n            ->rotate();\n      }\n      rotate();\n    }\n    return this;\n  }\n  Node* rotate() {\n    bool side = getSide(), parentSide = splayTreeParent->getSide();\n    auto ancestor = splayTreeParent->splayTreeParent;\n    pathParentPointer = splayTreeParent->pathParentPointer;\n    splayTreeParent->pathParentPointer = nullptr;\n    splayTreeParent->attach(child[!side], side);\n    attach(splayTreeParent, !side);\n    if (ancestor)\n      ancestor->attach(this, parentSide);\n    else\n      splayTreeParent = nullptr;\n    return this;\n  }\n  Node* attach(Node* node, int side) {\n    if (node) node->splayTreeParent = this;\n    child[side] = node;\n    val->update((child[0] ? child[0]->val : nullptr),\n                (child[1] ? child[1]->val : nullptr));\n    return this;\n  }\n};\nstruct LinkCutTree {\n  int n = 0;\n  vector<Node*> nodes;\n  int addNode(NodeVal* nodeVal) {\n    nodes.push_back(new Node(n, nodeVal));\n    return n++;\n  }\n  void link(int parentId, int childId) {\n    Node *parent = nodes[parentId], *child = nodes[childId];\n    assert(findRoot(child->id) != findRoot(parent->id));\n    access(child);\n    access(parent);\n    Node* lChild = child->child[0];\n    if (lChild) {\n      lChild->reverse = !lChild->reverse;\n      detachChild(child, 0);\n    }\n    child->attach(parent, 0);\n  }\n  void cut(int id) {\n    Node* u = nodes[id];\n    access(u);\n    assert(u->child[0]);\n    u->child[0]->splayTreeParent = nullptr;\n    u->child[0] = nullptr;\n  }\n  void cut(int id1, int id2) {\n    Node *u = nodes[id1], *v = nodes[id2];\n    access(v);\n    access(u);\n    if (u->child[0] && findMax(u->child[0]) == v) {\n      cut(u->id);\n      return;\n    }\n    access(v);\n    if (v->child[0] && findMax(v->child[0]) == u) {\n      cut(v->id);\n    }\n  }\n  int findRoot(int id) {\n    Node* u = nodes[id];\n    access(u);\n    while (u->child[0]) {\n      u = u->child[0];\n    }\n    access(u);\n    return u->id;\n  }\n  int LCA(int id1, int id2) {\n    Node *u = nodes[id1], *v = nodes[id2];\n    if (findRoot(u->id) != findRoot(v->id)) {\n      return -1;\n    }\n    access(u);\n    return access(v)->id;\n  }\n  int pathAggregate(int id) {\n    Node* u = nodes[id];\n    access(u);\n    return u->id;\n  }\n  Node* getNode(int id) { return nodes[id]; }\n\n private:\n  Node* access(Node* u) {\n    u->splay();\n    detachChild(u, 1);\n    Node* curPP = u;\n    while (u->pathParentPointer) {\n      curPP = u->pathParentPointer;\n      curPP->splay();\n      detachChild(curPP, 1);\n      curPP->attach(u, 1);\n      u->pathParentPointer = nullptr;\n      u->splay();\n    }\n    return curPP;\n  }\n  Node* findMax(Node* u) {\n    while (u && u->child[1]) {\n      u = u->child[1];\n    }\n    u->splay();\n    return u;\n  }\n  void detachChild(Node* u, bool b) {\n    if (!u->child[b]) {\n      return;\n    }\n    u->child[b]->pathParentPointer = u;\n    u->child[b]->splayTreeParent = nullptr;\n    u->child[b] = nullptr;\n  }\n};\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nvector<int> numToID;\nint n, m;\nvoid cutNeighbors(LinkCutTree& lct, vector<vector<int>>& grid, int l, int r) {\n  int i = numToID[l] / m, j = numToID[l] % m;\n  int idx = numToID[l];\n  for (int k = 0; k < 4; k++) {\n    int ni = i + dx[k], nj = j + dy[k];\n    if (ni < 0 || nj < 0 || ni == n || nj == m) {\n      continue;\n    }\n    if (grid[ni][nj] < l || grid[ni][nj] > r) {\n      continue;\n    }\n    int nIdx = numToID[grid[ni][nj]];\n    lct.cut(idx, nIdx);\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0), cout.tie(0);\n  LinkCutTree lct;\n  cin >> n >> m;\n  vector<vector<int>> grid(n, vector<int>(m));\n  numToID.resize(n * m + 1);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      cin >> grid[i][j];\n      numToID[grid[i][j]] = lct.addNode(new NodeVal());\n    }\n  }\n  SegTree st(n * m + 1);\n  long long ans = 0;\n  int l = 1;\n  for (int r = 1; r <= m * n; r++) {\n    st.update(l, r, StUpdate(1));\n    int i = numToID[r] / m, j = numToID[r] % m;\n    int idx = numToID[r];\n    for (int k = 0; k < 4; k++) {\n      int ni = i + dx[k], nj = j + dy[k];\n      if (ni < 0 || nj < 0 || ni == n || nj == m) {\n        continue;\n      }\n      if (grid[ni][nj] < l || grid[ni][nj] > r) {\n        continue;\n      }\n      int nIdx = numToID[grid[ni][nj]];\n      while (lct.findRoot(idx) == lct.findRoot(nIdx)) {\n        cutNeighbors(lct, grid, l, r);\n        l++;\n      }\n      if (l > grid[ni][nj]) {\n        continue;\n      }\n      if (l == r) {\n        break;\n      }\n      lct.link(idx, nIdx);\n      st.update(l, grid[ni][nj], StUpdate(-1));\n    }\n    ans += st.query(l, r).numMin;\n  }\n  cout << ans << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(3)\nusing namespace std;\ntemplate <typename T>\ninline bool chkmin(T &x, T y) {\n  return x > y ? x = y, 1 : 0;\n}\ntemplate <typename T>\ninline bool chkmax(T &x, T y) {\n  return x < y ? x = y, 1 : 0;\n}\ntemplate <typename T>\ninline void read(T &x) {\n  char ch = getchar();\n  int f = 1;\n  x = 0;\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();\n  x *= f;\n}\ntemplate <typename T, typename... Args>\ninline void read(T &x, Args &...args) {\n  read(x), read(args...);\n}\nint n, m, a[1050][1050], st;\nlong long ans;\npair<int, int> pos[200050];\nstruct LCT {\n  int fa[200050], ch[200050][2], tag[200050];\n  bool nroot(int u) { return ch[fa[u]][0] == u || ch[fa[u]][1] == u; }\n  bool son(int u) { return ch[fa[u]][1] == u; }\n  void rotate(int x) {\n    int y = fa[x], z = fa[y], k = son(x), w = ch[x][!k];\n    if (nroot(y)) ch[z][son(y)] = x;\n    ch[x][!k] = y, ch[y][k] = w;\n    fa[w] = y, fa[y] = x, fa[x] = z;\n  }\n  void put_tag(int u) { tag[u] ^= 1, swap(ch[u][0], ch[u][1]); }\n  void push(int u) {\n    if (tag[u]) put_tag(ch[u][0]), put_tag(ch[u][1]), tag[u] = 0;\n  }\n  void pushall(int u) {\n    if (nroot(u)) pushall(fa[u]);\n    push(u);\n  }\n  void splay(int x) {\n    pushall(x);\n    while (nroot(x)) {\n      int y = fa[x];\n      if (nroot(y)) rotate(son(y) ^ son(x) ? x : y);\n      rotate(x);\n    }\n  }\n  void access(int x) {\n    for (register int y = 0; x; x = fa[y = x]) splay(x), ch[x][1] = y;\n  }\n  void mroot(int u) { access(u), splay(u), put_tag(u); }\n  void split(int u, int v) { mroot(u), access(v), splay(v); }\n  void link(int u, int v) { split(u, v), fa[u] = v; }\n  void cut(int u, int v) {\n    split(u, v);\n    if (ch[v][0] == u && !ch[u][1]) ch[v][0] = fa[u] = 0;\n  }\n  int find(int u) {\n    access(u), splay(u);\n    while (ch[u][0]) push(u = ch[u][0]);\n    return splay(u), u;\n  }\n} T;\nstruct node {\n  int minv, cnt;\n  node operator+(const int x) { return node{minv + x, cnt}; }\n  node operator+(const node &x) {\n    node r;\n    r.minv = min(minv, x.minv);\n    r.cnt = cnt * (minv == r.minv) + x.cnt * (x.minv == r.minv);\n    return r;\n  }\n};\nstruct SGT {\n  int tag[200050 << 2];\n  node res[200050 << 2];\n  void build(int u, int l, int r) {\n    if (l == r) return (void)(res[u].cnt = 1);\n    build(u << 1, l, ((l + r) >> 1)), build(u << 1 | 1, ((l + r) >> 1) + 1, r);\n    res[u] = res[u << 1] + res[u << 1 | 1];\n  }\n  void put_tag(int u, int w) { tag[u] += w, res[u] = res[u] + w; }\n  void push(int u) {\n    if (tag[u])\n      put_tag(u << 1, tag[u]), put_tag(u << 1 | 1, tag[u]), tag[u] = 0;\n  }\n  void modify(int u, int l, int r, int tl, int tr, int w) {\n    if (tl <= l && r <= tr) return put_tag(u, w);\n    push(u);\n    if (tl <= ((l + r) >> 1)) modify(u << 1, l, ((l + r) >> 1), tl, tr, w);\n    if (((l + r) >> 1) < tr)\n      modify(u << 1 | 1, ((l + r) >> 1) + 1, r, tl, tr, w);\n    res[u] = res[u << 1] + res[u << 1 | 1];\n  }\n  node query(int u, int l, int r, int tl, int tr) {\n    if (tl <= l && r <= tr) return res[u];\n    push(u);\n    if (tr <= ((l + r) >> 1)) return query(u << 1, l, ((l + r) >> 1), tl, tr);\n    if (((l + r) >> 1) < tl)\n      return query(u << 1 | 1, ((l + r) >> 1) + 1, r, tl, tr);\n    return query(u << 1, l, ((l + r) >> 1), tl, tr) +\n           query(u << 1 | 1, ((l + r) >> 1) + 1, r, tl, tr);\n  }\n} S;\nvoid insert(int u, int v) {\n  if (v < st || v > u) return;\n  while (T.find(u) == T.find(v)) {\n    int x = pos[st].first, y = pos[st].second;\n    if (st <= a[x + 1][y] && a[x + 1][y] <= u) T.cut(st, a[x + 1][y]);\n    if (st <= a[x - 1][y] && a[x - 1][y] <= u) T.cut(st, a[x - 1][y]);\n    if (st <= a[x][y + 1] && a[x][y + 1] <= u) T.cut(st, a[x][y + 1]);\n    if (st <= a[x][y - 1] && a[x][y - 1] <= u) T.cut(st, a[x][y - 1]);\n    ++st;\n  }\n  T.link(u, v), S.modify(1, 1, n * m, 1, v, -1);\n}\nint main() {\n  read(n, m);\n  for (register int i = 1; i <= n; ++i)\n    for (register int j = 1; j <= m; ++j)\n      read(a[i][j]), pos[a[i][j]] = make_pair(i, j);\n  S.build(1, 1, n * m);\n  st = 1;\n  for (register int i = 1; i <= n * m; ++i) {\n    S.modify(1, 1, n * m, 1, i, 1);\n    int x = pos[i].first, y = pos[i].second;\n    insert(i, a[x - 1][y]), insert(i, a[x + 1][y]), insert(i, a[x][y - 1]),\n        insert(i, a[x][y + 1]);\n    node _r = S.query(1, 1, n * m, st, i);\n    ans += _r.cnt;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int gi() {\n  char c = getchar();\n  while (c < '0' || c > '9') c = getchar();\n  int sum = 0;\n  while ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();\n  return sum;\n}\nconst int maxn = 200005;\nconst int d[4][2] = {0, 1, 0, -1, 1, 0, -1, 0};\nint n, m, N;\nint f[maxn], ch[maxn][2], rev[maxn], x[maxn], y[maxn];\nint p[1005][1005];\ninline void rotate(int x) {\n  int fa = f[x], gfa = f[fa], k = (ch[f[x]][1] == x);\n  ch[fa][k] = ch[x][k ^ 1];\n  f[ch[x][k ^ 1]] = fa;\n  ch[x][k ^ 1] = fa;\n  if (!(ch[f[fa]][0] != fa && ch[f[fa]][1] != fa))\n    ch[gfa][(ch[f[fa]][1] == fa)] = x;\n  f[fa] = x;\n  f[x] = gfa;\n}\ninline void pushdown(int x) {\n  if (!rev[x]) return;\n  if (ch[x][0]) (swap(ch[ch[x][0]][0], ch[ch[x][0]][1]), rev[ch[x][0]] ^= 1);\n  if (ch[x][1]) (swap(ch[ch[x][1]][0], ch[ch[x][1]][1]), rev[ch[x][1]] ^= 1);\n  rev[x] = 0;\n}\ninline void splay(int x) {\n  static int stk[maxn], top, fa;\n  stk[top = 1] = x;\n  while (!(ch[f[x]][0] != x && ch[f[x]][1] != x)) stk[++top] = x = f[x];\n  while (top) pushdown(stk[top--]);\n  x = stk[1];\n  while (!(ch[f[x]][0] != x && ch[f[x]][1] != x)) {\n    fa = f[x];\n    if (!(ch[f[fa]][0] != fa && ch[f[fa]][1] != fa))\n      (ch[f[x]][1] == x) ^ (ch[f[fa]][1] == fa) ? rotate(x) : rotate(fa);\n    rotate(x);\n  }\n}\ninline void access(int x) {\n  for (int y = 0; x; y = x, x = f[x]) splay(x), ch[x][1] = y;\n}\ninline void make_root(int x) {\n  access(x);\n  splay(x);\n  (swap(ch[x][0], ch[x][1]), rev[x] ^= 1);\n}\ninline void link(int x, int y) {\n  make_root(x);\n  make_root(y);\n  f[y] = x;\n}\ninline void cut(int x, int y) {\n  make_root(x);\n  access(y);\n  splay(y);\n  ch[y][0] = f[x] = 0;\n}\ninline int find(int x) {\n  access(x);\n  splay(x);\n  while (ch[x][0]) x = ch[x][0];\n  splay(x);\n  return x;\n}\nint Min[maxn << 2], sum[maxn << 2], tag[maxn << 2];\nvoid build(int s, int l, int r) {\n  if (l == r) return Min[s] = 0, sum[s] = 1, void();\n  build((s << 1), l, ((l + r) >> 1));\n  build((s << 1 | 1), ((l + r) >> 1) + 1, r);\n  if (Min[(s << 1)] == Min[(s << 1 | 1)])\n    sum[s] = sum[(s << 1)] + sum[(s << 1 | 1)];\n  else if (Min[(s << 1)] < Min[(s << 1 | 1)])\n    sum[s] = sum[(s << 1)];\n  else\n    sum[s] = sum[(s << 1 | 1)];\n  Min[s] += tag[s];\n}\nvoid insert(int s, int l, int r, int ql, int qr, int v) {\n  if (ql <= l && r <= qr) return tag[s] += v, Min[s] += v, void();\n  if (ql <= ((l + r) >> 1)) insert((s << 1), l, ((l + r) >> 1), ql, qr, v);\n  if (qr >= ((l + r) >> 1) + 1)\n    insert((s << 1 | 1), ((l + r) >> 1) + 1, r, ql, qr, v);\n  if (Min[(s << 1)] == Min[(s << 1 | 1)])\n    sum[s] = sum[(s << 1)] + sum[(s << 1 | 1)];\n  else if (Min[(s << 1)] < Min[(s << 1 | 1)])\n    sum[s] = sum[(s << 1)];\n  else\n    sum[s] = sum[(s << 1 | 1)];\n  Min[s] = min(Min[(s << 1)], Min[(s << 1 | 1)]) + tag[s];\n}\npair<int, int> operator+(pair<int, int> a, pair<int, int> b) {\n  return a.first == b.first ? make_pair(a.first, a.second + b.second)\n                            : min(a, b);\n}\npair<int, int> query(int s, int l, int r, int ql, int qr) {\n  if (ql <= l && r <= qr) return make_pair(Min[s], sum[s]);\n  pair<int, int> res(1e9, 0);\n  if (ql <= ((l + r) >> 1)) res = query((s << 1), l, ((l + r) >> 1), ql, qr);\n  if (qr >= ((l + r) >> 1) + 1)\n    res = res + query((s << 1 | 1), ((l + r) >> 1) + 1, r, ql, qr);\n  res.first += tag[s];\n  return res;\n}\nint check(int l, int r) {\n  for (int x1, y1, i = 0; i < 4; ++i) {\n    x1 = x[r] + d[i][0];\n    y1 = y[r] + d[i][1];\n    if (p[x1][y1] < l || p[x1][y1] >= r) continue;\n    for (int x2, y2, j = i + 1; j < 4; ++j) {\n      x2 = x[r] + d[j][0];\n      y2 = y[r] + d[j][1];\n      if (p[x2][y2] < l || p[x2][y2] >= r) continue;\n      if (find(p[x1][y1]) == find(p[x2][y2])) return 1;\n    }\n  }\n  return 0;\n}\nvoid add(int t, int v, int l, int r) {\n  insert(1, 1, N, 1, t, v);\n  for (int x1, y1, i = 0; i < 4; ++i) {\n    x1 = x[t] + d[i][0];\n    y1 = y[t] + d[i][1];\n    if (p[x1][y1] < l || p[x1][y1] >= r) continue;\n    insert(1, 1, N, 1, min(t, p[x1][y1]), -v);\n    if (v > 0)\n      assert(find(p[x1][y1]) != find(t)), link(p[x1][y1], t);\n    else\n      assert(find(p[x1][y1]) == find(t)), cut(p[x1][y1], t);\n  }\n}\nint main() {\n  n = gi();\n  m = gi();\n  N = n * m;\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j) p[i][j] = gi(), x[p[i][j]] = i, y[p[i][j]] = j;\n  long long ans = 0;\n  pair<int, int> res;\n  build(1, 1, N);\n  for (int r = 1, l = 1; r <= N; ++r) {\n    while (l < r && check(l, r)) {\n      add(l, -1, l, r), ++l;\n    }\n    add(r, 1, l, r);\n    res = query(1, 1, N, l, r);\n    ans += res.first == 1 ? res.second : 0;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing std::cin;\nusing std::cout;\nconst int N = 200054, U = 1054;\nint n, R, C;\nint a[U][U], right[N];\nbool used[N];\nstd::pair<int, int> pos[N];\nnamespace LCT {\nstruct node {\n  bool rev;\n  int p, c[2];\n} nd[N];\ninline int dir(int x) {\n  return !nd[x].p                ? -1\n         : x == nd[x].p[nd].c[0] ? 0\n         : x == nd[x].p[nd].c[1] ? 1\n                                 : -1;\n}\ninline void set(int x, int px, int c) {\n  if (nd[x].p = px, ~c) nd[px].c[c] = x;\n}\ninline void reverse(int x) {\n  x && (std::swap(nd[x].c[0], nd[x].c[1]), nd[x].rev = !nd[x].rev);\n}\nvoid push_down(int x) {\n  if (nd[x].rev) reverse(nd[x].c[0]), reverse(nd[x].c[1]), nd[x].rev = false;\n}\nvoid pull_down(int x) {\n  if (~dir(x)) pull_down(nd[x].p);\n  push_down(x);\n}\nvoid rotate(int x) {\n  int y = nd[x].p, d = !dir(x);\n  set(nd[x].c[d], y, !d), set(x, nd[y].p, dir(y)), set(y, x, d);\n}\nvoid splay(int x) {\n  for (pull_down(x); ~dir(x); rotate(x))\n    if (~dir(nd[x].p)) rotate(dir(x) ^ dir(nd[x].p) ? x : nd[x].p);\n}\nvoid access(int x) {\n  for (int y = 0; x; y = x, x = nd[x].p) splay(x), nd[x].c[1] = y;\n}\nvoid make_root(int x) { access(x), splay(x), reverse(x); }\nint find_root(int x) {\n  for (access(x), splay(x); push_down(x), nd[x].c[0]; x = nd[x].c[0])\n    ;\n  return splay(x), x;\n}\nint split(int x, int y) { return make_root(x), access(y), splay(y), y; }\nvoid link(int x, int y) { make_root(x), nd[x].p = y; }\nvoid cut(int x, int y) { split(x, y), nd[x].p = nd[y].c[0] = 0; }\n}  // namespace LCT\ninline bool insert(int x) {\n  int r, c, $1, $2, $3, $4, _1, _2, _3, _4;\n  std::tie(r, c) = pos[x];\n  _1 = used[$1 = a[r][c - 1]] ? LCT::find_root($1) : -1;\n  _2 = used[$2 = a[r - 1][c]] ? LCT::find_root($2) : -2;\n  _3 = used[$3 = a[r][c + 1]] ? LCT::find_root($3) : -3;\n  _4 = used[$4 = a[r + 1][c]] ? LCT::find_root($4) : -4;\n  if (_1 == _2 || _1 == _3 || _2 == _3 || _1 == _4 || _2 == _4 || _3 == _4)\n    return false;\n  if (used[$1]) LCT::link($1, x);\n  if (used[$2]) LCT::link($2, x);\n  if (used[$3]) LCT::link($3, x);\n  if (used[$4]) LCT::link($4, x);\n  return used[x] = true;\n}\ninline void erase(int x) {\n  int r, c;\n  assert(used[x]);\n  std::tie(r, c) = pos[x];\n  if (used[a[r][c - 1]]) LCT::cut(x, a[r][c - 1]);\n  if (used[a[r - 1][c]]) LCT::cut(x, a[r - 1][c]);\n  if (used[a[r][c + 1]]) LCT::cut(x, a[r][c + 1]);\n  if (used[a[r + 1][c]]) LCT::cut(x, a[r + 1][c]);\n  used[x] = false;\n}\nnamespace ST {\nstruct node {\n  int v, c, tag;\n} x[530000];\nvoid build(int id, int L, int R) {\n  x[id].tag = x[id].v = 0, x[id].c = R - L + 1;\n  if (L == R) return;\n  int M = (L + R - 1) >> 1, lc = id << 1, rc = lc | 1;\n  build(lc, L, M), build(rc, M + 1, R);\n}\ninline void update(node &ret, const node &l, const node &r) {\n  if (l.v == r.v)\n    ret.v = l.v, ret.c = l.c + r.c;\n  else if (l.v < r.v)\n    ret.v = l.v, ret.c = l.c;\n  else\n    ret.v = r.v, ret.c = r.c;\n  ret.v += ret.tag;\n}\nvoid add(int id, int L, int R, int ql, int qr, int v) {\n  if (ql <= L && R <= qr) {\n    x[id].v += v, x[id].tag += v;\n    return;\n  }\n  int M = (L + R - 1) >> 1, lc = id << 1, rc = lc | 1;\n  if (ql <= M) add(lc, L, M, ql, qr, v);\n  if (qr > M) add(rc, M + 1, R, ql, qr, v);\n  update(x[id], x[lc], x[rc]);\n}\nnode range(int id, int L, int R, int ql, int qr) {\n  if (ql <= L && R <= qr) return x[id];\n  int M = (L + R - 1) >> 1, lc = id << 1, rc = lc | 1;\n  node ret, l, r;\n  if (qr <= M) return ret = range(lc, L, M, ql, qr), ret.v += x[id].tag, ret;\n  if (ql > M) return ret = range(rc, M + 1, R, ql, qr), ret.v += x[id].tag, ret;\n  l = range(lc, L, M, ql, M), r = range(rc, M + 1, R, M + 1, qr);\n  return ret.tag = x[id].tag, update(ret, l, r), ret;\n}\n}  // namespace ST\nint main() {\n  int i, j, r, c, t, bp[6];\n  long long ans = 0;\n  ST::node z;\n  std::ios::sync_with_stdio(false), cin.tie(NULL);\n  cin >> R >> C, n = R * C;\n  for (i = 1; i <= R; ++i)\n    for (j = 1; j <= C; ++j)\n      cin >> a[i][j], pos[a[i][j]] = std::pair<int, int>(i, j);\n  for (j = i = 1; i <= n; erase(i), right[i++] = j - 1)\n    for (; j <= n && insert(j); ++j)\n      ;\n  ST::build(1, 1, n);\n  for (i = n; i; --i) {\n    std::tie(r, c) = pos[i], *bp = i, t = 1;\n    if (a[r][c - 1] > i) bp[t++] = a[r][c - 1];\n    if (a[r - 1][c] > i) bp[t++] = a[r - 1][c];\n    if (a[r][c + 1] > i) bp[t++] = a[r][c + 1];\n    if (a[r + 1][c] > i) bp[t++] = a[r + 1][c];\n    std::sort(bp, bp + t), bp[t] = n + 1;\n    for (j = 0; j < t; ++j)\n      if (j != 1) ST::add(1, 1, n, bp[j], bp[j + 1] - 1, 1 - j);\n    z = ST::range(1, 1, n, i, right[i]);\n    if (z.v == 1) ans += z.c;\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct LCT {\n  int ch[1000000][3], fa[1000000], turn[1000000];\n  int Get(int x) { return ch[fa[x]][1] == x; }\n  int nroot(int x) { return ch[fa[x]][1] == x || ch[fa[x]][0] == x; }\n  void pushr(int x) {\n    if (!x) return;\n    swap(ch[x][0], ch[x][1]);\n    turn[x] ^= 1;\n  }\n  void pushdown(int x) {\n    if (turn[x]) {\n      pushr(ch[x][0]), pushr(ch[x][1]);\n      turn[x] = 0;\n    }\n  }\n  void pushall(int x) {\n    if (nroot(x)) pushall(fa[x]);\n    pushdown(x);\n  }\n  void rotate(int x) {\n    int y = fa[x], z = fa[y], w = Get(x);\n    if (nroot(y)) ch[z][ch[z][1] == y] = x;\n    ch[y][w] = ch[x][w ^ 1];\n    if (ch[y][w]) fa[ch[y][w]] = y;\n    ch[x][w ^ 1] = y;\n    fa[y] = x;\n    fa[x] = z;\n  }\n  void splay(int x) {\n    pushall(x);\n    while (nroot(x)) {\n      int y = fa[x];\n      if (nroot(y)) Get(x) ^ Get(y) ? rotate(x) : rotate(y);\n      rotate(x);\n    }\n  }\n  void access(int x) {\n    for (int y = 0; x; x = fa[y = x]) {\n      splay(x);\n      ch[x][1] = y;\n    }\n  }\n  int findroot(int x) {\n    access(x);\n    splay(x);\n    while (ch[x][0]) x = ch[x][0];\n    splay(x);\n    return x;\n  }\n  void makeroot(int x) {\n    access(x);\n    splay(x);\n    pushr(x);\n    return;\n  }\n  int link(int x, int y) {\n    makeroot(x);\n    if (findroot(y) == x) return false;\n    fa[x] = y;\n    return true;\n  }\n  void cut(int x, int y) {\n    makeroot(x);\n    if (findroot(y) == x && fa[y] == x && !ch[y][0]) {\n      fa[y] = ch[x][1] = 0;\n    }\n    return;\n  }\n} T;\nstruct segment_tree {\n  int Min[4 * 1000000], Num[4 * 1000000], lazy[4 * 1000000];\n  void pushdown(int x) {\n    if (lazy[x]) {\n      lazy[x << 1] += lazy[x];\n      lazy[x << 1 | 1] += lazy[x];\n      Min[x << 1] += lazy[x], Min[x << 1 | 1] += lazy[x];\n      lazy[x] = 0;\n    }\n  }\n  void pushup(int x) {\n    if (Min[x << 1] < Min[x << 1 | 1])\n      Min[x] = Min[x << 1], Num[x] = Num[x << 1];\n    if (Min[x << 1] > Min[x << 1 | 1])\n      Min[x] = Min[x << 1 | 1], Num[x] = Num[x << 1 | 1];\n    if (Min[x << 1] == Min[x << 1 | 1])\n      Min[x] = Min[x << 1], Num[x] = Num[x << 1] + Num[x << 1 | 1];\n  }\n  void build(int x, int l, int r) {\n    if (l == r) {\n      Min[x] = 0, Num[x] = 1;\n      return;\n    }\n    int mid = l + r >> 1;\n    build(x << 1, l, mid);\n    build(x << 1 | 1, mid + 1, r);\n    pushup(x);\n  }\n  void modify(int x, int l, int r, int ll, int rr, int k) {\n    if (l == ll && r == rr) {\n      lazy[x] += k;\n      Min[x] += k;\n      return;\n    }\n    pushdown(x);\n    int mid = l + r >> 1;\n    if (rr <= mid)\n      modify(x << 1, l, mid, ll, rr, k);\n    else if (ll > mid)\n      modify(x << 1 | 1, mid + 1, r, ll, rr, k);\n    else\n      modify(x << 1, l, mid, ll, mid, k),\n          modify(x << 1 | 1, mid + 1, r, mid + 1, rr, k);\n    pushup(x);\n  }\n  int query(int x, int l, int r, int ll, int rr) {\n    if (l == ll && r == rr) {\n      if (Min[x] == 1)\n        return Num[x];\n      else\n        return 0;\n    }\n    int mid = l + r >> 1;\n    pushdown(x);\n    if (rr <= mid)\n      return query(x << 1, l, mid, ll, rr);\n    else if (ll > mid)\n      return query(x << 1 | 1, mid + 1, r, ll, rr);\n    else\n      return query(x << 1, l, mid, ll, mid) +\n             query(x << 1 | 1, mid + 1, r, mid + 1, rr);\n  }\n} S;\ninline int read();\nvector<int> V[1000000];\nint dx[10] = {1, 0, -1, 0};\nint dy[10] = {0, 1, 0, -1};\nint n, m, w[3000][3000];\nlong long ans = 0;\nint main() {\n  n = read(), m = read();\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) w[i][j] = read();\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      for (int d = 0; d < 4; d++) {\n        int x = i + dx[d], y = j + dy[d];\n        if (x < 1 || y < 1 || x > n || y > m) continue;\n        if (w[x][y] > w[i][j]) continue;\n        V[w[x][y]].push_back(w[i][j]);\n        V[w[i][j]].push_back(w[x][y]);\n      }\n    }\n  }\n  int R = 0;\n  long long t = n * m;\n  S.build(1, 1, t);\n  for (int i = 1; i <= t; i++) {\n    for (int j = R + 1; j <= t; j++) {\n      int now = j, flag = 0;\n      for (int d = 0; d < V[now].size(); d++) {\n        int now1 = V[now][d];\n        if (now1 < now && now1 >= i)\n          if (!T.link(now1, now)) {\n            flag = 1;\n            break;\n          }\n      }\n      for (int d = 0; d < V[now].size(); d++) T.cut(now, V[now][d]);\n      if (flag == 1) break;\n      R = j;\n      int tot = 0;\n      for (int d = 0; d < V[now].size(); d++) {\n        int now1 = V[now][d];\n        if (now1 < j && now1 >= i) T.link(now1, now);\n        if (now1 < j && now1 >= i) tot++;\n      }\n      S.modify(1, 1, t, R, R, R - i + 1);\n      S.modify(1, 1, t, R, t, -tot);\n    }\n    ans += 1ll * S.query(1, 1, t, i, R);\n    int tot = 0;\n    for (int d = 0; d < V[i].size(); d++) {\n      if (V[i][d] <= R && V[i][d] > i) {\n        T.cut(V[i][d], i);\n        S.modify(1, 1, t, V[i][d], t, 1);\n      }\n    }\n    S.modify(1, 1, t, i, R, -1);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\ninline int read() {\n  int x = 0, f = 1;\n  char c = getchar();\n  while (c > '9' || c < '0') f = (c == '-') ? -1 : f, c = getchar();\n  while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n  return x * f;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <typename T>\ninline void read(T &x) {\n  x = 0;\n  char c = getchar();\n  bool flag = false;\n  while (!isdigit(c)) {\n    if (c == '-') flag = true;\n    c = getchar();\n  }\n  while (isdigit(c)) x = x * 10 + (c ^ 48), c = getchar();\n  if (flag) x = -x;\n}\nusing namespace std;\nconst int inf = 987654321;\ninline void MIN(int &a, int b) {\n  if (b < a) a = b;\n}\ninline void MAX(int &a, int b) {\n  if (a < b) a = b;\n}\nint n, m, nn;\nint h[1010][1010], X[201000], Y[201000];\nbool vis[201000];\nnamespace Seg {\nstruct Data {\n  int ls, rs, mx, mxcnt, tag;\n  Data() { ls = rs = mxcnt = tag = mx = 0; }\n} dat[201000 << 2];\nint ttot;\ninline void pushup(int cur) {\n  if (dat[dat[cur].ls].mx == dat[dat[cur].rs].mx) {\n    dat[cur].mx = dat[dat[cur].ls].mx;\n    dat[cur].mxcnt = dat[dat[cur].ls].mxcnt + dat[dat[cur].rs].mxcnt;\n  } else if (dat[dat[cur].ls].mx > dat[dat[cur].rs].mx) {\n    dat[cur].mx = dat[dat[cur].ls].mx, dat[cur].mxcnt = dat[dat[cur].ls].mxcnt;\n  } else {\n    dat[cur].mx = dat[dat[cur].rs].mx, dat[cur].mxcnt = dat[dat[cur].rs].mxcnt;\n  }\n}\ninline void pusht(int cur, int v) {\n  if (!cur) return;\n  dat[cur].mx += v;\n  dat[cur].tag += v;\n}\ninline void pushdown(int cur) {\n  if (dat[cur].tag)\n    pusht(dat[cur].ls, dat[cur].tag), pusht(dat[cur].rs, dat[cur].tag),\n        dat[cur].tag = 0;\n}\nvoid ins(int L, int R, int pos, int v, int &cur) {\n  if (!cur) cur = ++ttot;\n  if (L == R) return dat[cur].mx = v, dat[cur].mxcnt = 1, void();\n  int mid = (L + R) >> 1;\n  pushdown(cur);\n  if (pos <= mid)\n    ins(L, mid, pos, v, dat[cur].ls);\n  else\n    ins(mid + 1, R, pos, v, dat[cur].rs);\n  pushup(cur);\n}\nvoid add(int L, int R, int l, int r, int v, int cur) {\n  if (!cur) return;\n  if (l <= L && R <= r) return pusht(cur, v), void();\n  int mid = (L + R) >> 1;\n  pushdown(cur);\n  if (l <= mid) add(L, mid, l, r, v, dat[cur].ls);\n  if (r > mid) add(mid + 1, R, l, r, v, dat[cur].rs);\n  pushup(cur);\n}\nvoid del(int L, int R, int pos, int cur) {\n  if (L == R) return dat[cur].mx = -inf, void();\n  int mid = (L + R) >> 1;\n  if (pos <= mid)\n    del(L, mid, pos, dat[cur].ls);\n  else\n    del(mid + 1, R, pos, dat[cur].rs);\n  pushup(cur);\n}\ninline int query(int v) {\n  if (dat[1].mx != v) return 0;\n  return dat[1].mxcnt;\n}\n}  // namespace Seg\ninline void calc_edge(int u, int v, int t) {\n  Seg::add(1, nn, 1, min(u, v), t, 1);\n}\nint son[201000][2], fa[201000], tag[201000], mn[201000];\ninline void pushup(int cur) {\n  mn[cur] = cur;\n  if (son[cur][0]) MIN(mn[cur], mn[son[cur][0]]);\n  if (son[cur][1]) MIN(mn[cur], mn[son[cur][1]]);\n}\ninline bool notroot(int cur) {\n  return son[fa[cur]][0] == cur || son[fa[cur]][1] == cur;\n}\ninline bool get_which(int cur) { return son[fa[cur]][1] == cur; }\ninline void rotate(int cur) {\n  int faa = fa[cur], fafa = fa[faa];\n  bool flag = get_which(cur);\n  fa[cur] = fafa;\n  if (notroot(faa)) son[fafa][get_which(faa)] = cur;\n  son[faa][flag] = son[cur][flag ^ 1];\n  if (son[cur][flag ^ 1]) fa[son[cur][flag ^ 1]] = faa;\n  fa[faa] = cur;\n  son[cur][flag ^ 1] = faa;\n  pushup(faa);\n}\ninline void pusht(int cur) {\n  if (!cur) return;\n  swap(son[cur][0], son[cur][1]);\n  tag[cur] ^= 1;\n}\ninline void pushdown(int cur) {\n  if (tag[cur]) pusht(son[cur][0]), pusht(son[cur][1]), tag[cur] = 0;\n}\nint stk[201000], stop;\ninline void splay(int cur) {\n  int x = cur;\n  while (notroot(x)) stk[++stop] = x, x = fa[x];\n  pushdown(x);\n  while (stop) pushdown(stk[stop--]);\n  for (int faa = fa[cur]; notroot(cur); rotate(cur), faa = fa[cur])\n    if (notroot(faa)) rotate(get_which(cur) == get_which(faa) ? faa : cur);\n  pushup(cur);\n}\ninline void Access(int x) {\n  for (int lst = 0; x; lst = x, x = fa[x]) splay(x), son[x][1] = lst, pushup(x);\n}\ninline void make_root(int x) { Access(x), splay(x), pusht(x); }\ninline int find_root(int x) {\n  Access(x);\n  splay(x);\n  while (son[x][0]) x = son[x][0];\n  splay(x);\n  return x;\n}\ninline void Split(int x, int y) { make_root(x), Access(y), splay(y); }\ninline void Link(int x, int y) {\n  make_root(x), make_root(y);\n  fa[x] = y;\n}\ninline void Cut(int x, int y) {\n  make_root(x), Access(y), splay(y);\n  fa[x] = son[y][0] = 0;\n  pushup(y);\n}\nint jzptmp;\nint ptr;\ninline void Erase(int p) {\n  int x = X[p], y = Y[p];\n  if (vis[h[x][y - 1]] && h[x][y - 1] != jzptmp)\n    Cut(p, h[x][y - 1]), calc_edge(p, h[x][y - 1], -1);\n  if (vis[h[x][y + 1]] && h[x][y + 1] != jzptmp)\n    Cut(p, h[x][y + 1]), calc_edge(p, h[x][y + 1], -1);\n  if (vis[h[x - 1][y]] && h[x - 1][y] != jzptmp)\n    Cut(p, h[x - 1][y]), calc_edge(p, h[x - 1][y], -1);\n  if (vis[h[x + 1][y]] && h[x + 1][y] != jzptmp)\n    Cut(p, h[x + 1][y]), calc_edge(p, h[x + 1][y], -1);\n  vis[p] = false;\n  Seg::del(1, nn, p, 1);\n}\ninline void Addedge(int x, int y) {\n  if (find_root(x) != find_root(y)) {\n    Link(x, y);\n    calc_edge(x, y, 1);\n    return;\n  }\n  Split(x, y);\n  int mnid = mn[y];\n  jzptmp = x;\n  while (ptr < mnid) ++ptr, Erase(ptr);\n  if (vis[y]) Link(x, y), calc_edge(x, y, 1);\n}\nint main() {\n  read(n), read(m);\n  nn = n * m;\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= m; ++j) {\n      read(h[i][j]);\n      X[h[i][j]] = i;\n      Y[h[i][j]] = j;\n    }\n  }\n  long long ans = 0;\n  int jzproot = 0;\n  for (int i = 1; i <= nn; ++i) {\n    int x = X[i], y = Y[i];\n    vis[i] = true;\n    Seg::ins(1, nn, i, i, jzproot);\n    if (vis[h[x - 1][y]]) Addedge(i, h[x - 1][y]);\n    if (vis[h[x + 1][y]]) Addedge(i, h[x + 1][y]);\n    if (vis[h[x][y - 1]]) Addedge(i, h[x][y - 1]);\n    if (vis[h[x][y + 1]]) Addedge(i, h[x][y + 1]);\n    int res = Seg::query(i);\n    ans += res;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct StVal {\n  int minV = 0, numMin = 0;\n  StVal() {}\n  StVal(const int _v) : minV(_v), numMin(1) {}\n  StVal(const StVal& v1, const StVal& v2) {\n    if (v1.minV < v2.minV) {\n      minV = v1.minV;\n      numMin = v1.numMin;\n    } else if (v1.minV > v2.minV) {\n      minV = v2.minV;\n      numMin = v2.numMin;\n    } else {\n      minV = v1.minV;\n      numMin = v1.numMin + v2.numMin;\n    }\n  }\n};\nstruct StUpdate {\n  int v = 0;\n  StUpdate() {}\n  StUpdate(const int v) : v(v) {}\n  StUpdate(const StUpdate& u1, const StUpdate& u2) { v = u1.v + u2.v; }\n  void apply(StVal& sv, const int lo, const int hi) { sv.minV += v; }\n};\nstruct SegTree {\n  int n;\n  vector<StVal> st;\n  vector<StUpdate> lazy;\n  vector<int> leaves;\n  SegTree(const int n) : n(n) {\n    leaves.resize(n);\n    init(1, 0, n - 1);\n    lazy.resize(st.size());\n  }\n  void init(const int si, const int lo, const int hi) {\n    if (lo == hi) {\n      if (si >= (int)st.size()) {\n        st.resize(si + 1);\n      }\n      st[si] = StVal(0);\n      leaves[lo] = si;\n      return;\n    }\n    int lC = si << 1, rC = (si << 1) | 1, mid = (lo + hi) >> 1;\n    init(lC, lo, mid);\n    init(rC, mid + 1, hi);\n    st[si] = StVal(st[lC], st[rC]);\n  }\n  void updateLazy(const int si, const int lo, const int hi) {\n    lazy[si].apply(st[si], lo, hi);\n    if (lo != hi) {\n      lazy[si << 1] = StUpdate(lazy[si << 1], lazy[si]);\n      lazy[si << 1 | 1] = StUpdate(lazy[si << 1 | 1], lazy[si]);\n    }\n    lazy[si] = StUpdate();\n  }\n  StVal query(const int l, const int r) {\n    return (l <= r && l < n && r >= 0) ? query(l, r, 1, 0, n - 1) : StVal();\n  }\n  StVal query(const int l, const int r, const int si, const int lo,\n              const int hi) {\n    updateLazy(si, lo, hi);\n    if (l <= lo && hi <= r) return st[si];\n    const int mid = (lo + hi) >> 1;\n    if (r <= mid) return query(l, r, si << 1, lo, mid);\n    if (mid < l) return query(l, r, si << 1 | 1, mid + 1, hi);\n    return StVal(query(l, r, si << 1, lo, mid),\n                 query(l, r, si << 1 | 1, mid + 1, hi));\n  }\n  void update(const int l, const int r, const StUpdate u) {\n    if (l <= r) update(l, r, u, 1, 0, n - 1);\n  }\n  void update(const int l, const int r, const StUpdate& u, const int si,\n              const int lo, const int hi) {\n    if (l <= lo && hi <= r) {\n      lazy[si] = StUpdate(lazy[si], u);\n      updateLazy(si, lo, hi);\n    } else {\n      updateLazy(si, lo, hi);\n      if (hi < l || r < lo) return;\n      const int mid = (lo + hi) >> 1;\n      update(l, r, u, si << 1, lo, mid);\n      update(l, r, u, si << 1 | 1, mid + 1, hi);\n      st[si] = StVal(st[si << 1], st[si << 1 | 1]);\n    }\n  }\n  void updateAllLazy() { updateAllLazy(1, 0, n - 1); }\n  void updateAllLazy(const int si, const int lo, const int hi) {\n    updateLazy(si, lo, hi);\n    if (lo != hi) {\n      const int mid = (lo + hi) >> 1;\n      updateAllLazy(si << 1, lo, mid);\n      updateAllLazy(si << 1 | 1, mid + 1, hi);\n    }\n  }\n};\nstruct Node {\n  array<Node*, 2> child{};\n  Node* splayTreeParent = nullptr;\n  Node* pathParentPointer = nullptr;\n  bool reverse = false;\n  Node() {}\n  bool getSide() {\n    return splayTreeParent ? splayTreeParent->child[1] == this : false;\n  }\n  void tryReverse() {\n    if (!reverse) {\n      return;\n    }\n    reverse = false;\n    swap(child[0], child[1]);\n    if (child[0]) {\n      child[0]->reverse = !child[0]->reverse;\n    }\n    if (child[1]) {\n      child[1]->reverse = !child[1]->reverse;\n    }\n  }\n  Node* splay() {\n    vector<Node*> ancestors;\n    Node* cur = this;\n    while (cur) {\n      ancestors.push_back(cur);\n      cur = cur->splayTreeParent;\n    }\n    for (int i = ancestors.size() - 1; i >= 0; i--) {\n      if (!ancestors[i]) {\n        continue;\n      }\n      ancestors[i]->tryReverse();\n    }\n    while (splayTreeParent) {\n      if (splayTreeParent->splayTreeParent) {\n        (getSide() == splayTreeParent->getSide() ? splayTreeParent : this)\n            ->rotate();\n      }\n      rotate();\n    }\n    return this;\n  }\n  Node* rotate() {\n    bool side = getSide(), parentSide = splayTreeParent->getSide();\n    auto ancestor = splayTreeParent->splayTreeParent;\n    pathParentPointer = splayTreeParent->pathParentPointer;\n    splayTreeParent->pathParentPointer = nullptr;\n    splayTreeParent->attach(child[!side], side);\n    attach(splayTreeParent, !side);\n    if (ancestor)\n      ancestor->attach(this, parentSide);\n    else\n      splayTreeParent = nullptr;\n    return this;\n  }\n  Node* attach(Node* node, int side) {\n    if (node) node->splayTreeParent = this;\n    child[side] = node;\n    return this;\n  }\n};\nstruct LinkCutTreeGeneral {\n  void link(Node* parent, Node* child) {\n    assert(findRoot(child) != findRoot(parent));\n    access(child);\n    access(parent);\n    Node* lChild = child->child[0];\n    if (lChild) {\n      lChild->reverse = !lChild->reverse;\n      detachChild(child, 0);\n    }\n    child->attach(parent, 0);\n  }\n  void cut(Node* u) {\n    access(u);\n    assert(u->child[0]);\n    u->child[0]->splayTreeParent = nullptr;\n    u->child[0] = nullptr;\n  }\n  void cut(Node* u, Node* v) {\n    bool b = findRoot(u) != findRoot(v);\n    access(u);\n    assert(!(b && u->child[0] && findMax(u->child[0]) == v));\n    if (u->child[0] && findMax(u->child[0]) == v) {\n      cut(u);\n      return;\n    }\n    access(v);\n    assert(!(b && v->child[0] && findMax(v->child[0]) == u));\n    if (v->child[0] && findMax(v->child[0]) == u) {\n      cut(v);\n    }\n  }\n  Node* findRoot(Node* u) {\n    access(u);\n    while (u->child[0]) {\n      u = u->child[0];\n    }\n    access(u);\n    return u;\n  }\n\n private:\n  Node* access(Node* u) {\n    u->splay();\n    detachChild(u, 1);\n    Node* curPP = u;\n    while (u->pathParentPointer) {\n      curPP = u->pathParentPointer;\n      curPP->splay();\n      detachChild(curPP, 1);\n      curPP->attach(u, 1);\n      u->pathParentPointer = nullptr;\n      u->splay();\n    }\n    return curPP;\n  }\n  Node* findMax(Node* u) {\n    if (!u) {\n      return nullptr;\n    }\n    while (u->child[1]) {\n      u = u->child[1];\n    }\n    return u;\n  }\n  void detachChild(Node* u, bool b) {\n    if (!u->child[b]) {\n      return;\n    }\n    u->child[b]->pathParentPointer = u;\n    u->child[b]->splayTreeParent = nullptr;\n    u->child[b] = nullptr;\n  }\n};\nstruct NodeWithId : Node {\n  int id;\n  NodeWithId(int id) : Node(), id(id) {}\n};\nstruct DynamicTreeLCT {\n  LinkCutTreeGeneral lct;\n  vector<NodeWithId*> nodes;\n  int n = 0;\n  DynamicTreeLCT() {}\n  int addNode() {\n    nodes.push_back(new NodeWithId(n));\n    return n++;\n  }\n  void link(int parentId, int childId) {\n    lct.link(nodes[parentId], nodes[childId]);\n  }\n  void cut(int id) { lct.cut(nodes[id]); }\n  void cut(int u, int v) { lct.cut(nodes[u], nodes[v]); }\n  int findRoot(int u) {\n    auto res = (NodeWithId*)lct.findRoot(nodes[u]);\n    return res->id;\n  }\n  bool connected(int u, int v) { return findRoot(u) == findRoot(v); }\n};\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nvector<int> numToID;\nint n, m;\nvoid cutNeighbors(DynamicTreeLCT& lct, vector<vector<int>>& grid, int l,\n                  int r) {\n  int i = numToID[l] / m, j = numToID[l] % m;\n  int idx = numToID[l];\n  for (int k = 0; k < 4; k++) {\n    int ni = i + dx[k], nj = j + dy[k];\n    if (ni < 0 || nj < 0 || ni == n || nj == m) {\n      continue;\n    }\n    if (grid[ni][nj] < l || grid[ni][nj] > r) {\n      continue;\n    }\n    int nIdx = numToID[grid[ni][nj]];\n    lct.cut(idx, nIdx);\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0), cout.tie(0);\n  DynamicTreeLCT lct;\n  cin >> n >> m;\n  vector<vector<int>> grid(n, vector<int>(m));\n  numToID.resize(n * m + 1);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      cin >> grid[i][j];\n      numToID[grid[i][j]] = lct.addNode();\n    }\n  }\n  SegTree st(n * m + 1);\n  long long ans = 0;\n  int l = 1;\n  for (int r = 1; r <= m * n; r++) {\n    st.update(l, r, StUpdate(1));\n    int i = numToID[r] / m, j = numToID[r] % m;\n    int idx = numToID[r];\n    for (int k = 0; k < 4; k++) {\n      int ni = i + dx[k], nj = j + dy[k];\n      if (ni < 0 || nj < 0 || ni == n || nj == m) {\n        continue;\n      }\n      if (grid[ni][nj] < l || grid[ni][nj] > r) {\n        continue;\n      }\n      int nIdx = numToID[grid[ni][nj]];\n      while (lct.connected(idx, nIdx)) {\n        cutNeighbors(lct, grid, l, r);\n        l++;\n      }\n      if (l > grid[ni][nj]) {\n        continue;\n      }\n      if (l == r) {\n        break;\n      }\n      lct.link(idx, nIdx);\n      st.update(l, grid[ni][nj], StUpdate(-1));\n    }\n    ans += st.query(l, r).numMin;\n  }\n  cout << ans << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline char gc() {\n  static char now[1 << 16], *S, *T;\n  if (T == S) {\n    T = (S = now) + fread(now, 1, 1 << 16, stdin);\n    if (T == S) return EOF;\n  }\n  return *S++;\n}\ninline long long read() {\n  register long long x = 0, f = 1;\n  char ch = gc();\n  while (!isdigit(ch)) {\n    if (ch == '-') f = -1;\n    ch = gc();\n  }\n  while (isdigit(ch)) {\n    x = (x << 3) + (x << 1) + ch - '0';\n    ch = gc();\n  }\n  return (f == 1) ? x : -x;\n}\nint n, m, a[303030], pre[302020][2];\nconst int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\ninline int id(int x, int y) { return (x - 1) * m + y; }\nstruct LCT {\n  struct node {\n    int son[2], fa;\n    bool tag;\n  } g[303030];\n  inline void reverse(int rt) {\n    g[rt].tag ^= 1;\n    swap(g[rt].son[0], g[rt].son[1]);\n  }\n  inline void pushdown(int rt) {\n    if (g[rt].tag) {\n      if (g[rt].son[0]) reverse(g[rt].son[0]);\n      if (g[rt].son[1]) reverse(g[rt].son[1]);\n      g[rt].tag = 0;\n    }\n  }\n  inline bool wtson(int rt) { return (g[g[rt].fa].son[0] == rt ? 0 : 1); }\n  inline bool isrt(int rt) {\n    return (g[g[rt].fa].son[0] != rt && g[g[rt].fa].son[1] != rt);\n  }\n  inline void rotate(int rt) {\n    int fa = g[rt].fa, fafa = g[fa].fa, wht = wtson(rt),\n        son = g[rt].son[wht ^ 1], whtfa = wtson(fa);\n    g[rt].fa = fafa;\n    if (fafa && !isrt(fa)) g[fafa].son[whtfa] = rt;\n    g[rt].son[wht ^ 1] = fa, g[fa].fa = rt;\n    g[fa].son[wht] = son, g[son].fa = fa;\n  }\n  int sta[303030], top;\n  inline void splay(int rt) {\n    sta[top = 1] = rt;\n    for (int i = rt; !isrt(i); i = g[i].fa) sta[++top] = g[i].fa;\n    for (; top; top--) pushdown(sta[top]);\n    while (!isrt(rt)) {\n      int fa = g[rt].fa;\n      if (isrt(fa))\n        rotate(rt);\n      else if (wtson(rt) == wtson(fa)) {\n        rotate(fa), rotate(rt);\n      } else {\n        rotate(rt), rotate(rt);\n      }\n    }\n  }\n  inline void access(int rt) {\n    for (int x = rt, y = 0; x; x = g[y = x].fa) {\n      splay(x), g[x].son[1] = y;\n    }\n  }\n  inline void makert(int rt) { access(rt), splay(rt), reverse(rt); }\n  inline int findrt(int rt) {\n    access(rt), splay(rt);\n    while (g[rt].son[0]) pushdown(rt), rt = g[rt].son[0];\n    int ans = rt;\n    splay(rt);\n    return ans;\n  }\n  inline void link(int x, int y) {\n    makert(y);\n    if (findrt(x) != y) g[y].fa = x;\n  }\n  inline void cut(int x, int y) {\n    makert(y), access(x), splay(x);\n    if (g[y].fa == x && !g[y].son[1]) {\n      g[y].fa = g[x].son[0] = 0;\n    }\n  }\n  inline bool query(int x, int y) { return (findrt(x) == findrt(y)); }\n} T;\nbool vis[303030];\nint seg[1202020], cnt[1202020], ncir[303030], tag[1202020];\ninline void pushup(int rt) {\n  if (seg[rt << 1] == seg[rt << 1 | 1])\n    cnt[rt] = cnt[rt << 1] + cnt[rt << 1 | 1];\n  else if (seg[rt << 1] < seg[rt << 1 | 1])\n    cnt[rt] = cnt[rt << 1];\n  else\n    cnt[rt] = cnt[rt << 1 | 1];\n  seg[rt] = min(seg[rt << 1], seg[rt << 1 | 1]);\n}\ninline void pushdown(int rt) {\n  if (tag[rt]) {\n    seg[rt << 1] += tag[rt];\n    tag[rt << 1] += tag[rt];\n    seg[rt << 1 | 1] += tag[rt];\n    tag[rt << 1 | 1] += tag[rt];\n    tag[rt] = 0;\n  }\n}\nvoid build(int rt, int lb, int rb) {\n  if (lb == rb) return (void)(cnt[rt] = 1);\n  build(rt << 1, lb, ((lb + rb) >> 1));\n  build(rt << 1 | 1, ((lb + rb) >> 1) + 1, rb);\n  pushup(rt);\n}\nvoid update(int rt, int lb, int rb, int l, int r, int w) {\n  if (lb > r || rb < l) return;\n  if (lb >= l && rb <= r) return (void)(seg[rt] += w, tag[rt] += w);\n  pushdown(rt);\n  update(rt << 1, lb, ((lb + rb) >> 1), l, r, w),\n      update(rt << 1 | 1, ((lb + rb) >> 1) + 1, rb, l, r, w);\n  pushup(rt);\n}\nint query(int rt, int lb, int rb, int l, int r) {\n  if (lb > r || rb < l) return 0;\n  if (lb >= l && rb <= r) return (seg[rt] == 1 ? cnt[rt] : 0);\n  pushdown(rt);\n  return query(rt << 1, lb, ((lb + rb) >> 1), l, r) +\n         query(rt << 1 | 1, ((lb + rb) >> 1) + 1, rb, l, r);\n}\nsigned main() {\n  n = read(), m = read();\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      int x = read();\n      a[id(i, j)] = x;\n      pre[x][0] = i, pre[x][1] = j;\n    }\n  }\n  ncir[1] = vis[id(pre[1][0], pre[1][1])] = 1;\n  int i, j, x, y, xx, yy, X, Y, XX, YY, K, k;\n  for (i = 2, j = 1; i <= n * m; i++) {\n    vis[id(pre[i][0], pre[i][1])] = 1;\n    for (k = 0; k < 4; k++) {\n      x = pre[i][0], y = pre[i][1], xx = x + dx[k], yy = y + dy[k];\n      if (xx < 1 || yy < 1 || xx > n || yy > m || !vis[id(xx, yy)]) continue;\n      while (T.query(id(xx, yy), id(x, y))) {\n        vis[id(pre[j][0], pre[j][1])] = 0;\n        for (K = 0; K < 4; K++) {\n          X = pre[j][0], Y = pre[j][1], XX = X + dx[K], YY = Y + dy[K];\n          if (XX < 1 || YY < 1 || XX > n || YY > m || !vis[id(XX, YY)])\n            continue;\n          T.cut(id(XX, YY), id(X, Y));\n        }\n        j++;\n      }\n      T.link(id(xx, yy), id(x, y));\n    }\n    ncir[i] = j;\n  }\n  long long ans = 0;\n  build(1, 1, n * m);\n  for (int i = 1; i <= n * m; i++) {\n    update(1, 1, n * m, 1, i, 1);\n    for (k = 0; k < 4; k++) {\n      x = pre[i][0], y = pre[i][1], xx = x + dx[k], yy = y + dy[k];\n      if (xx < 1 || yy < 1 || xx > n || yy > m) continue;\n      if (a[id(xx, yy)] < i) {\n        update(1, 1, n * m, 1, a[id(xx, yy)], -1);\n      }\n    }\n    ans += query(1, 1, n * m, ncir[i], i);\n  }\n  cout << ans;\n  return 0;\n}\n"
        }
    ]
}