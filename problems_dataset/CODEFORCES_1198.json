{
    "name": "1198_A. MP3",
    "source": "CODEFORCES",
    "description": "One common way of digitalizing sound is to record sound intensity at particular time moments. For each time moment intensity is recorded as a non-negative integer. Thus we can represent a sound file as an array of n non-negative integers.\n\nIf there are exactly K distinct values in the array, then we need k = \u2308 log_{2} K \u2309 bits to store each value. It then takes nk bits to store the whole file.\n\nTo reduce the memory consumption we need to apply some compression. One common way is to reduce the number of possible intensity values. We choose two integers l \u2264 r, and after that all intensity values are changed in the following way: if the intensity value is within the range [l;r], we don't change it. If it is less than l, we change it to l; if it is greater than r, we change it to r. You can see that we lose some low and some high intensities.\n\nYour task is to apply this compression in such a way that the file fits onto a disk of size I bytes, and the number of changed elements in the array is minimal possible.\n\nWe remind you that 1 byte contains 8 bits.\n\nk = \u2308 log_{2} K \u2309 is the smallest integer such that K \u2264 2^{k}. In particular, if K = 1, then k = 0.\n\nInput\n\nThe first line contains two integers n and I (1 \u2264 n \u2264 4 \u22c5 10^{5}, 1 \u2264 I \u2264 10^{8}) \u2014 the length of the array and the size of the disk in bytes, respectively.\n\nThe next line contains n integers a_{i} (0 \u2264 a_{i} \u2264 10^{9}) \u2014 the array denoting the sound file.\n\nOutput\n\nPrint a single integer \u2014 the minimal possible number of changed elements.\n\nExamples\n\nInput\n\n\n6 1\n2 1 2 3 4 3\n\n\nOutput\n\n\n2\n\n\nInput\n\n\n6 2\n2 1 2 3 4 3\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n6 1\n1 1 2 2 3 3\n\n\nOutput\n\n\n2\n\nNote\n\nIn the first example we can choose l=2, r=3. The array becomes 2 2 2 3 3 3, the number of distinct elements is K=2, and the sound file fits onto the disk. Only two values are changed.\n\nIn the second example the disk is larger, so the initial file fits it and no changes are required.\n\nIn the third example we have to change both 1s or both 3s.",
    "difficulty": "A",
    "tags": [
        "sortings",
        "two pointers"
    ],
    "rating": 1600,
    "public_test": [
        {
            "input": "6 1\n2 1 2 3 4 3\n",
            "output": "2\n"
        },
        {
            "input": "6 1\n1 1 2 2 3 3\n",
            "output": "2\n"
        },
        {
            "input": "6 2\n2 1 2 3 4 3\n",
            "output": "0\n"
        }
    ],
    "generated_test": [
        {
            "input": "10 500\n1 2 3 4 5 9 7 8 9 10\n",
            "output": "0\n"
        },
        {
            "input": "9 2\n1 2 1 2 1 2 1 2 1000000000\n",
            "output": "1\n"
        },
        {
            "input": "50 20\n592183311 362557946 154127088 616872926 395353745 675069471 509655682 79915471 356656666 937992998 304422065 724106263 472338455 792258113 796069631 663370025 201799298 566151622 722278085 508905399 703159587 690854023 925377265 11010958 69791159 990158269 535460930 167415727 999216963 237203826 693974848 530462137 555061429 744123832 887168514 479773974 575345653 282142246 899762676 446274594 338501746 168668673 408947684 226311538 645441958 258972430 216333311 658394075 123733185 539429791\n",
            "output": "42\n"
        },
        {
            "input": "10 1\n589934963 440265648 161048053 196789927 951616256 63404428 660569162 779938975 139312880 31052281\n",
            "output": "9\n"
        },
        {
            "input": "6 1\n1 1 4 2 3 3\n",
            "output": "3\n"
        },
        {
            "input": "9 2\n1 2 1 2 1 0 1 2 1000000000\n",
            "output": "2\n"
        },
        {
            "input": "8 32\n1 2 3 4 5 2 7 8\n",
            "output": "0\n"
        },
        {
            "input": "1 4\n0\n",
            "output": "0\n"
        },
        {
            "input": "8 64\n1 1 0 1 1 1 1 1\n",
            "output": "0\n"
        },
        {
            "input": "8 63\n1 2 3 4 9 6 7 8\n",
            "output": "0\n"
        },
        {
            "input": "2 1001000\n1 1\n",
            "output": "0\n"
        },
        {
            "input": "2 100000\n2 4\n",
            "output": "0\n"
        },
        {
            "input": "10 100\n2 2 3 4 5 6 7 8 9 10\n",
            "output": "0\n"
        },
        {
            "input": "10 100\n1 1 2 2 2 3 3 1 3 4\n",
            "output": "0\n"
        },
        {
            "input": "3 288383\n2 0 2\n",
            "output": "0\n"
        },
        {
            "input": "4 2\n2 2 2 2\n",
            "output": "0\n"
        },
        {
            "input": "2 8\n2 2\n",
            "output": "0\n"
        },
        {
            "input": "100 1000\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n",
            "output": "0\n"
        },
        {
            "input": "7 999992\n1 2 3 7 5 6 7\n",
            "output": "0\n"
        },
        {
            "input": "8 64\n1 2 3 4 5 6 6 8\n",
            "output": "0\n"
        },
        {
            "input": "3 10000000\n1 2 4\n",
            "output": "0\n"
        },
        {
            "input": "8 33\n1 2 3 4 5 6 13 8\n",
            "output": "0\n"
        },
        {
            "input": "6 100000\n2 1 2 4 4 3\n",
            "output": "0\n"
        },
        {
            "input": "10 1000000\n1 2 3 4 5 6 6 8 9 10\n",
            "output": "0\n"
        },
        {
            "input": "8 31\n1 1 2 2 3 0 4 4\n",
            "output": "0\n"
        },
        {
            "input": "81 800\n2 8 5 1 10 5 9 9 3 5 6 6 2 8 2 2 6 3 8 7 2 5 3 4 3 3 2 7 9 6 8 7 2 9 10 3 8 10 6 5 4 2 3 4 4 5 2 2 4 9 8 5 3 8 8 10 4 2 10 9 7 6 1 3 9 7 1 4 5 9 7 6 1 10 1 1 7 2 4 9 10\n",
            "output": "0\n"
        },
        {
            "input": "2 2\n1 3\n",
            "output": "0\n"
        },
        {
            "input": "64 40\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n",
            "output": "0\n"
        },
        {
            "input": "8 65\n1 2 0 4 5 6 7 8\n",
            "output": "0\n"
        },
        {
            "input": "9 100000000\n1 2 3 4 9 6 7 8 9\n",
            "output": "0\n"
        },
        {
            "input": "100 800\n1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 3 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10\n",
            "output": "0\n"
        },
        {
            "input": "6 2168\n1 1 2 2 3 3\n",
            "output": "0\n"
        },
        {
            "input": "8 18\n1 1 1 1 1 1 1 1\n",
            "output": "0\n"
        },
        {
            "input": "100 1249\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 33 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100\n",
            "output": "0\n"
        },
        {
            "input": "2 10000\n1 4\n",
            "output": "0\n"
        },
        {
            "input": "5 1234567\n0 2 3 4 5\n",
            "output": "0\n"
        },
        {
            "input": "3 11\n2 2 3\n",
            "output": "0\n"
        },
        {
            "input": "8 30\n1 2 3 8 5 6 7 8\n",
            "output": "0\n"
        },
        {
            "input": "5 1010000\n1 2 3 3 4\n",
            "output": "0\n"
        },
        {
            "input": "5 100000\n1 2 3 5 4\n",
            "output": "0\n"
        },
        {
            "input": "100 1000\n1 2 3 3 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10\n",
            "output": "0\n"
        },
        {
            "input": "20 8\n1 1 1 0 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2\n",
            "output": "0\n"
        },
        {
            "input": "6 48\n2 1 2 3 8 3\n",
            "output": "0\n"
        },
        {
            "input": "5 100100\n1 2 3 3 4\n",
            "output": "0\n"
        },
        {
            "input": "5 100\n1 2 5 4 5\n",
            "output": "0\n"
        },
        {
            "input": "8 15\n2 8 5 1 10 5 9 9\n",
            "output": "0\n"
        },
        {
            "input": "8 31\n1 2 3 4 5 6 7 7\n",
            "output": "0\n"
        },
        {
            "input": "50 400\n0 30 60 90 120 150 180 210 240 270 300 330 360 390 420 450 480 510 540 570 600 630 660 690 720 750 780 810 840 870 900 930 960 990 1020 1050 1353 1110 1140 1170 1200 1230 1260 1290 1320 1350 1380 1410 1440 1470\n",
            "output": "0\n"
        },
        {
            "input": "2 64\n2 2\n",
            "output": "0\n"
        },
        {
            "input": "3 125\n1 2 3\n",
            "output": "0\n"
        },
        {
            "input": "1 10000000\n2\n",
            "output": "0\n"
        },
        {
            "input": "5 100000000\n0 1 2 2 5\n",
            "output": "0\n"
        },
        {
            "input": "2 42611638\n3 9\n",
            "output": "0\n"
        },
        {
            "input": "2 30000000\n3 5\n",
            "output": "0\n"
        },
        {
            "input": "1 100000010\n69\n",
            "output": "0\n"
        },
        {
            "input": "3 100000000\n2 1 2\n",
            "output": "0\n"
        },
        {
            "input": "5 100000000\n1 2 3 4 10\n",
            "output": "0\n"
        },
        {
            "input": "2 30000000\n1 1\n",
            "output": "0\n"
        },
        {
            "input": "2 100000000\n1 4\n",
            "output": "0\n"
        },
        {
            "input": "1 100000000\n0\n",
            "output": "0\n"
        },
        {
            "input": "6 100000000\n2 1 2 3 1 3\n",
            "output": "0\n"
        },
        {
            "input": "10 500\n1 2 5 4 5 9 7 8 9 10\n",
            "output": "0\n"
        },
        {
            "input": "8 32\n1 2 3 4 5 2 7 14\n",
            "output": "0\n"
        },
        {
            "input": "1 7\n0\n",
            "output": "0\n"
        },
        {
            "input": "8 64\n1 1 0 1 1 1 0 1\n",
            "output": "0\n"
        },
        {
            "input": "8 104\n1 2 3 4 9 6 7 8\n",
            "output": "0\n"
        },
        {
            "input": "10 100\n2 2 6 4 5 6 7 8 9 10\n",
            "output": "0\n"
        },
        {
            "input": "10 101\n1 1 2 2 2 3 3 1 3 4\n",
            "output": "0\n"
        },
        {
            "input": "3 288383\n0 0 2\n",
            "output": "0\n"
        },
        {
            "input": "4 2\n2 2 2 0\n",
            "output": "0\n"
        },
        {
            "input": "2 10\n2 2\n",
            "output": "0\n"
        },
        {
            "input": "100 1000\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1\n",
            "output": "0\n"
        },
        {
            "input": "7 999992\n2 2 3 7 5 6 7\n",
            "output": "0\n"
        },
        {
            "input": "8 51\n1 2 3 4 5 6 6 8\n",
            "output": "0\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 4e5 + 5;\nlong long a[N];\nvoid solve() {\n  int n;\n  long long I;\n  cin >> n >> I;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  sort(a, a + n);\n  long long k = (8 * I) / n;\n  long long K = pow(2ll, min(20ll, k));\n  vector<long long> v;\n  vector<long long> psum;\n  long long ans = 0;\n  for (int i = 0; i < n; i++) {\n    int j = i;\n    long long cnt = 0;\n    while (j < n && (a[i] == a[j])) {\n      j++;\n      cnt++;\n    }\n    v.push_back(a[i]);\n    psum.push_back(cnt);\n    i = j - 1;\n  }\n  if (K >= v.size())\n    ans = 0;\n  else {\n    int sz = v.size();\n    for (int i = 1; i < sz; i++) psum[i] += psum[i - 1];\n    int i = 1, j = K;\n    ans = psum[sz - 1] - psum[K - 1];\n    while (j < sz) {\n      long long temp = psum[sz - 1] - psum[j];\n      temp += psum[i - 1];\n      ans = min(ans, temp);\n      i++;\n      j++;\n    }\n  }\n  cout << ans << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dl = 1e9 + 7;\nconst int M = 4e5 + 10;\nint a[M];\nmap<int, int> cnt;\nint presum[M];\nint tt[M];\nint n;\nlong long s;\nlong long k;\nint32_t main() {\n  cin >> n >> s;\n  long long t = (8 * s) / n;\n  if (t >= 31) {\n    cout << \"0\";\n    return 0;\n  }\n  k = 1 << t;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    cnt[a[i]]++;\n  }\n  int sz = 1;\n  for (auto x : cnt) {\n    tt[sz] = x.first;\n    presum[sz] = presum[sz - 1] + x.second;\n    sz++;\n  }\n  int ans = n;\n  for (int i = 1; i < sz; i++) {\n    int y = i + k;\n    if (i + k >= sz)\n      ans = min(ans, presum[i - 1]);\n    else {\n      ans = min(ans, n - presum[y - 1] + presum[i - 1]);\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O2\")\nusing namespace std;\nint main() {\n  cin.tie(0), ios::sync_with_stdio(0);\n  int n, I;\n  cin >> n >> I;\n  vector<int> arr(n), all;\n  for (int i = 0; i < n; i++) cin >> arr[i];\n  all = arr;\n  sort(all.begin(), all.end());\n  all.resize(unique(all.begin(), all.end()) - all.begin());\n  for (int i = 0; i < n; i++)\n    arr[i] = lower_bound(all.begin(), all.end(), arr[i]) - all.begin();\n  sort(arr.begin(), arr.end());\n  int mk = I * 8 / n;\n  if (mk >= 20) {\n    cout << \"0\\n\";\n    return 0;\n  }\n  mk = 1 << mk;\n  int ans = 1e9;\n  for (int i = 0; i < all.size(); i++) {\n    int l = i, r = l + mk - 1;\n    ans = min((int)(lower_bound(arr.begin(), arr.end(), l) - arr.begin() +\n                    arr.end() - upper_bound(arr.begin(), arr.end(), r)),\n              ans);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\n\nn, m = map(int, input().strip().split())\na = list(map(int, input().strip().split()))\n\na.sort()\nlastval = -1\nb = list()\n\nfor x in a:\n\tif x != lastval:\n\t\tb.append(1)\n\t\tlastval = x\n\telse:\n\t\tb[-1] += 1\n\nk = len(b)\n\nwhile k > (1 << ((8*m)//n)):\n\tk -= 1\n\nans = 0\n\nfor x in range(k):\n\tans += b[x]\n\nres = ans\n\nfor x in range(k, len(b)):\n\tres = res + b[x] - b[x-k]\n\tans = max(res,ans)\n\nprint(n - ans)"
        },
        {
            "language": 4,
            "solution": "//JDope\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class A{\npublic static void main(String[] omkar) throws Exception\n{\n   BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n   StringTokenizer st = new StringTokenizer(in.readLine());\n   StringBuilder sb = new StringBuilder();\n   int n = Integer.parseInt(st.nextToken());\n   int m = Integer.parseInt(st.nextToken());\n   int[] arr = readArr(n, in, st);\n   double maxK = Math.pow(2, (8*m)/n);\n   Map<Integer, Integer> map = new HashMap<Integer, Integer>();\n   for(int i = 0; i < n; i++)\n   {\n      if(!map.containsKey(arr[i]))\n      {\n         map.put(arr[i], 1);\n      }\n      else\n      {\n         map.put(arr[i], map.get(arr[i]) + 1);\n      }\n   }\n   Integer[] vals = map.keySet().toArray(new Integer[1]);\n   Arrays.sort(vals);\n   int[] vals2 = new int[vals.length];\n   for(int i = 0; i < vals.length; i++)\n   {\n      vals2[i] = map.get(vals[i]);\n   }\n   if(vals2.length <= maxK)\n   {\n      System.out.println(\"0\");\n      return;\n   }\n   int maxk = (int)(maxK);\n   int[] sums = new int[vals2.length - maxk + 1];\n   for(int i = 0; i < maxk; i++)\n   {\n      sums[0] += vals2[i];\n   }\n   int max = sums[0];\n   for(int i = 1; i < sums.length; i++)\n   {\n      sums[i] = sums[i-1];\n      sums[i] -= vals2[i-1];\n      sums[i] += vals2[i-1+maxk];\n      max = Math.max(sums[i], max);\n   }\n   System.out.println((n-max));\n   \n        }\n public static int[] readArr(int N, BufferedReader in, StringTokenizer st) throws Exception\n      {\n         int[] arr = new int[N];\n         st = new StringTokenizer(in.readLine());\n         for(int i=0; i < N; i++)\n            arr[i] = Integer.parseInt(st.nextToken());\n         return arr;\n      }\nstatic class Pair implements Comparable<Pair> {\nfinal int a;\nfinal int b;\nPair(int a, int b) {\nthis.a = a;\nthis.b = b;\n}\n@Override\npublic int compareTo(Pair other) {\nif (a != other.a) {\nreturn (a - other.a);\n} else {\nreturn (b - other.b);\n}}}\n\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma warning(disable : 4996)\n#pragma comment(linker, \"/STACK:666000000\")\nusing namespace std;\nconst int INF = (1 << 30) - 1;\nconst long double EPS = 1e-9;\nvoid ML(const bool v) {\n  if (v) return;\n  int *ass;\n  for (;;) {\n    ass = new int[2500000];\n    for (int i = 0; i < 2500000; i++) ass[i] = rand();\n  }\n}\nvoid TL(const bool v) {\n  if (v) return;\n  for (;;) cout << rand() % (rand() % 1000 + 1) << endl;\n}\nvoid PE(const bool v) {\n  if (v) return;\n  for (int i = 0; i < 10000; i++) printf(\"%c\", rand() % 256);\n  exit(0);\n}\nint n, k;\nvector<int> a;\nbool LoAd() {\n  if (!(2 == scanf(\"%d%d\", &n, &k))) return false;\n  a.resize(n);\n  for (int i = 0; i < (int)(n); i++) (1 == scanf(\"%d\", &a[i]));\n  return true;\n}\nvoid SoLvE() {\n  map<int, int> w;\n  for (int i = 0; i < (int)(n); i++) w[a[i]]++;\n  vector<int> b;\n  for (auto it = (w).begin(); it != (w).end(); it++) b.push_back(it->second);\n  int lt = 0;\n  int rt = (int)b.size() - 1;\n  k *= 8;\n  a.clear();\n  int difVals = (int)b.size();\n  long long bps = (k) / n;\n  long long can = 1;\n  for (int i = 0; i < bps && can < n; i++) can *= 2;\n  long long dropped = 0;\n  while (rt - lt + 1 > can) {\n    dropped += b[lt];\n    lt++;\n  }\n  long long res = dropped;\n  while (lt > 0) {\n    lt--;\n    dropped -= b[lt];\n    dropped += b[rt];\n    rt--;\n    if (dropped < res) res = dropped;\n  }\n  cout << res << endl;\n}\nint main() {\n  srand((int)time(NULL));\n  LoAd();\n  SoLvE();\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n,i = map(int, input().split())\naa = list(map(int, input().split()))\nbitsPerSample = (i*8)//n\nr = 2**bitsPerSample\naa.sort()\nprev = -1\nbb = []\nfor i, a in enumerate(aa):\n    if a != prev:\n        bb.append(i)\n        prev = a\nif len(bb) <= r:\n    maxOk = n\nelse:\n    maxOk = max([bb[i+r] - bb[i] for i in range(len(bb)-r)])\nprint(n-maxOk)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/stack:256000000\")\n#pragma gcc optimize(\"O3\")\n#pragma gcc target(\"sse4\")\nusing namespace std;\nmt19937 rng(2391);\nmt19937 gnr(chrono::high_resolution_clock::now().time_since_epoch().count());\ntemplate <typename A>\nistream& operator>>(istream& fin, vector<A>& v) {\n  for (auto it = v.begin(); it != v.end(); ++it) fin >> *it;\n  return fin;\n}\ntemplate <typename A, typename B>\nistream& operator>>(istream& fin, pair<A, B>& p) {\n  fin >> p.first >> p.second;\n  return fin;\n}\ntemplate <typename A, typename B>\npair<A, B> operator+(const pair<A, B>& a, const pair<A, B>& b) {\n  return make_pair(a.first + b.first, a.second + b.second);\n}\ntemplate <typename A, typename B>\npair<A, B> operator+=(pair<A, B>& a, const pair<A, B>& b) {\n  a.first += b.first;\n  a.second += b.second;\n  return a;\n}\ntemplate <typename A, typename B>\npair<A, B> operator-(const pair<A, B>& a, const pair<A, B>& b) {\n  return make_pair(a.first - b.first, a.second - b.second);\n}\ntemplate <typename A, typename B>\npair<A, B> operator-(const pair<A, B>& a) {\n  return make_pair(-a.first, -a.second);\n}\ntemplate <typename A, typename B>\npair<A, B>& operator++(pair<A, B>& a) {\n  ++a.first;\n  ++a.second;\n  return a;\n}\ntemplate <typename A, typename B>\npair<A, B>& operator--(pair<A, B>& a) {\n  --a.first;\n  --a.second;\n  return a;\n}\ntemplate <typename A>\nvector<A>& operator++(vector<A>& a) {\n  for (auto it = a.begin(); it != a.end(); ++it) ++*it;\n  return a;\n}\ntemplate <typename A>\nvector<A>& operator--(vector<A>& a) {\n  for (auto it = a.begin(); it != a.end(); ++it) --*it;\n  return a;\n}\ntemplate <typename A, typename B>\npair<A, B> operator++(pair<A, B>& a, int) {\n  pair<A, B> b = a;\n  ++a;\n  return b;\n}\ntemplate <typename A, typename B>\npair<A, B> operator--(pair<A, B>& a, int) {\n  pair<A, B> b = a;\n  --a;\n  return b;\n}\ntemplate <typename A>\nvector<A>& operator++(vector<A>& a, int) {\n  vector<A> b = a;\n  ++a;\n  return b;\n}\ntemplate <typename A>\nvector<A>& operator--(vector<A>& a, int) {\n  vector<A> b = a;\n  --a;\n  return b;\n}\nvector<vector<int>> adjlist_from_edgelist(const vector<pair<int, int>>& e,\n                                          const int& n) {\n  vector<vector<int>> g(n);\n  for (auto it = e.begin(); it != e.end(); ++it) {\n    g[it->first].push_back(it->second);\n    g[it->second].push_back(it->first);\n  }\n  return g;\n}\ntemplate <typename A, typename B>\npair<A, B> operator-=(pair<A, B>& a, const pair<A, B>& b) {\n  a.first -= b.first;\n  a.second -= b.second;\n  return a;\n}\ntemplate <typename A>\nA operator*(const pair<A, A>& p, const pair<A, A>& q) {\n  return p.first * q.first + p.second * q.second;\n}\ntemplate <typename A>\npair<A, A> operator*(const pair<A, A>& p, const A& q) {\n  return make_pair(p.first * q, p.second * q);\n}\ntemplate <typename A>\nA operator%(const pair<A, A>& p, const pair<A, A>& q) {\n  return p.first * q.second - p.second * q.first;\n}\ntemplate <typename A>\nA sq_len(const pair<A, A>& p) {\n  return p * p;\n}\ntemplate <typename A>\nA sq_dist(const pair<A, A>& p, const pair<A, A>& q) {\n  return sq_len(p - q);\n}\ntemplate <typename A>\ndouble len(const pair<A, A>& p) {\n  return sqrt(sq_len(p));\n}\ntemplate <typename A>\ndouble dist(const pair<A, A>& p, const pair<A, A>& q) {\n  return len(p - q);\n}\ntemplate <typename A>\nbool is_rhombus(const pair<A, A>& a, const pair<A, A>& b, const pair<A, A>& c,\n                const pair<A, A>& d) {\n  A x = sq_dist(a, b);\n  A y = sq_dist(b, c);\n  A z = sq_dist(c, d);\n  A t = sq_dist(d, a);\n  return ((x == y) && (y == z) && (z == t));\n}\ntemplate <typename A>\nbool is_rectangle(const pair<A, A>& a, const pair<A, A>& b, const pair<A, A>& c,\n                  const pair<A, A>& d) {\n  pair<A, A> x = a - b, y = b - c, z = c - d, t = d - a;\n  return ((x * y == 0) && (y * z == 0) && (z * t == 0) && (t * x == 0));\n}\ntemplate <typename A>\nbool are_parallel(const pair<A, A>& a, const pair<A, A>& b) {\n  return (a % b == 0);\n}\ntemplate <typename A>\nbool are_orthogonal(const pair<A, A>& a, const pair<A, A>& b) {\n  return (a * b == 0);\n}\ntemplate <typename A>\nbool are_codirected(const pair<A, A>& a, const pair<A, A>& b) {\n  return (are_parallel(a, b) && (a * b >= 0));\n}\ntemplate <typename A>\nbool is_parallelogram(const pair<A, A>& a, const pair<A, A>& b,\n                      const pair<A, A>& c, const pair<A, A>& d) {\n  return ((a - b) == (d - c));\n}\ntemplate <typename A>\nbool is_trapezoid(const pair<A, A>& a, const pair<A, A>& b, const pair<A, A>& c,\n                  const pair<A, A>& d) {\n  pair<A, A> x = a - b, z = d - c;\n  return are_codirected(x, z);\n}\ntemplate <typename A>\nbool is_convex_polygon(const pair<A, A>& a, const pair<A, A>& b,\n                       const pair<A, A>& c, const pair<A, A>& d) {\n  pair<A, A> x = a - b, y = b - c, z = c - d, t = d - a;\n  A p = x % y, q = y % z, r = z % t, s = t % x;\n  return (((p >= 0) && (q >= 0) && (r >= 0) && (s >= 0)) ||\n          ((p <= 0) && (q <= 0) && (r <= 0) && (s <= 0)));\n}\ntemplate <typename A>\nbool nprcs(const pair<A, A>& a, const pair<A, A>& c) {\n  return ((a % c) >= 0);\n}\ntemplate <typename A>\nbool nprcs(const pair<A, A>& a, const pair<A, A>& b, const pair<A, A>& c) {\n  return nprcs(a - b, a - c);\n}\ntemplate <typename A>\nbool npocs(const pair<A, A>& a, const pair<A, A>& c) {\n  return ((a % c) <= 0);\n}\ntemplate <typename A>\nbool npocs(const pair<A, A>& a, const pair<A, A>& b, const pair<A, A>& c) {\n  return npocs(a - b, a - c);\n}\ntemplate <typename A>\nbool prcs(const pair<A, A>& a, const pair<A, A>& c) {\n  return ((a % c) > 0);\n}\ntemplate <typename A>\nbool prcs(const pair<A, A>& a, const pair<A, A>& b, const pair<A, A>& c) {\n  return prcs(a - b, a - c);\n}\ntemplate <typename A>\nbool pocs(const pair<A, A>& a, const pair<A, A>& c) {\n  return ((a % c) < 0);\n}\ntemplate <typename A>\nbool pocs(const pair<A, A>& a, const pair<A, A>& b, const pair<A, A>& c) {\n  return pocs(a - b, a - c);\n}\ntemplate <typename A>\nbool different_sides(const pair<A, A>& a, const pair<A, A>& b,\n                     const pair<A, A>& c, const pair<A, A>& d) {\n  pair<A, A> x = b - a;\n  A p = x % (c - b), q = x % (d - b);\n  return (((p >= 0) && (q <= 0)) || ((p <= 0) && (q >= 0)));\n}\ntemplate <typename A>\nbool sharply_different_sides(const pair<A, A>& a, const pair<A, A>& b,\n                             const pair<A, A>& c, const pair<A, A>& d) {\n  pair<A, A> x = b - a;\n  A p = x % (c - b), q = x % (d - b);\n  return (((p > 0) && (q < 0)) || ((p < 0) && (q > 0)));\n}\ntemplate <typename A>\npair<A, A> rot_90(const pair<A, A>& p) {\n  return make_pair(-p.second, p.first);\n}\ntemplate <typename A>\npair<A, A> rot_90(const pair<A, A>& p, const pair<A, A>& c) {\n  return c + rot_90(p - c);\n}\ntemplate <typename A>\nbool intersecting_segments(const pair<A, A>& a, const pair<A, A>& b,\n                           const pair<A, A>& c, const pair<A, A>& d) {\n  return different_sides(a, b, c, d) && different_sides(c, d, a, b);\n}\ntemplate <typename A>\nbool sharply_intersecting_segments(const pair<A, A>& a, const pair<A, A>& b,\n                                   const pair<A, A>& c, const pair<A, A>& d) {\n  return sharply_different_sides(a, b, c, d) &&\n         sharply_different_sides(c, d, a, b);\n}\ntemplate <typename A>\npair<pair<A, A>, A> line_with_normal_vector_through_point(\n    const pair<A, A>& normal, const pair<A, A>& point) {\n  return make_pair(normal, -(normal * point));\n}\ntemplate <typename A>\npair<pair<A, A>, A> serper(const pair<A, A>& a, const pair<A, A>& b) {\n  pair<A, A> p = b - a;\n  return make_pair(p + p, -(p * (a + b)));\n}\npair<double, double> ints(const pair<double, double>& p, const double& a,\n                          const pair<double, double>& q, const double& b) {\n  double D = p % q;\n  double E =\n      pair<double, double>(-a, p.second) % pair<double, double>(-b, q.second);\n  double F =\n      pair<double, double>(p.first, -a) % pair<double, double>(q.first, -b);\n  return pair<double, double>(E / D, F / D);\n}\npair<double, double> circumcenter(const pair<double, double>& x,\n                                  const pair<double, double>& y,\n                                  const pair<double, double>& z) {\n  auto p1 = serper(x, y), p2 = serper(x, z);\n  return ints(p1.first, p1.second, p2.first, p2.second);\n}\ntemplate <typename A>\npair<pair<A, A>, A> l_th_2(const pair<A, A>& p, const pair<A, A>& q) {\n  return make_pair(make_pair(q.second - p.second, p.first - q.first), -p % q);\n}\ntemplate <typename A>\nvector<pair<double, double>> circle_intersection(const pair<pair<A, A>, A>& a,\n                                                 const pair<pair<A, A>, A>& b) {\n  pair<A, A> c = b.first - a.first;\n  A rr1 = a.second * a.second, rr2 = b.second * b.second, cc = c * c,\n    rrrr1 = rr1 * rr1, rrrr2 = rr2 * rr2, cccc = cc * cc,\n    D = 2 * (rr1 * rr2 + rr2 * cc + cc * rr1) - (rrrr1 + rrrr2 + cccc);\n  if (D >= 0) {\n    double E = (((double)(rr1 - rr2)) / cc + 1) / 2;\n    pair<double, double> baza =\n        pair<double, double>(a.first.first, a.first.second) +\n        pair<double, double>(c.first, c.second) * E;\n    if (D) {\n      double lll = sqrt((double)(D)) / (2 * cc);\n      pair<A, A> cr = rot_90(c);\n      pair<double, double> pmm =\n          pair<double, double>(cr.first, cr.second) * lll;\n      return {baza + pmm, baza - pmm};\n    } else\n      return vector<pair<double, double>>(1, baza);\n  } else\n    return vector<pair<double, double>>();\n}\ntemplate <typename A, typename B>\npair<A, B> sopr(const pair<A, B>& p) {\n  return make_pair(p.first, -p.second);\n}\ntemplate <typename A>\nbool on_segment(const pair<A, A>& a, const pair<A, A>& b, const pair<A, A>& c) {\n  return are_codirected(b - a, c - b);\n}\ntemplate <typename A>\npair<pair<A, A>, A> perpendicular(const pair<A, A>& line,\n                                  const pair<A, A>& point) {\n  return line_with_normal_vector_through_point(rot_90(line), point);\n}\npair<double, double> projection(const pair<pair<double, double>, double>& line,\n                                const pair<double, double>& point) {\n  pair<pair<double, double>, double> temp = perpendicular(line.first, point);\n  return ints(line.first, line.second, temp.first, temp.second);\n}\npair<double, double> height(const pair<double, double>& a,\n                            const pair<double, double>& b,\n                            const pair<double, double>& c) {\n  return projection(l_th_2(a, c), b);\n}\npair<double, double> unitvector(const pair<double, double>& a) {\n  return a * (1 / len(a));\n}\ntemplate <typename T>\nvector<int> z_function(const vector<T>& s) {\n  int n = ((int)(s.size()));\n  vector<int> z(n);\n  int l = 0, r = 1;\n  for (int i = 1; i < n; ++i) {\n    z[i] = max(0, min(r - i, z[i - l]));\n    while (i + z[i] < n && (s[i + z[i]] == s[z[i]])) ++z[i];\n    if (r < i + z[i]) {\n      l = i;\n      r = i + z[i];\n    }\n  }\n  return z;\n}\npair<int, int> euc(const int& m, const int& n) {\n  if (n == 0) return pair<int, int>((m >= 0) ? 1 : -1, 0);\n  int t = m / n;\n  pair<int, int> ans1 = euc(n, m - t * n);\n  return pair<int, int>(ans1.second, ans1.first - ans1.second * t);\n}\nint prod(const int& a, const int& b, const int& M) {\n  return ((long long)(a)) * b % M;\n}\nint sum(const int& a, const int& b, const int& M) {\n  int c = a + b;\n  return c >= M ? c - M : c;\n}\nint raz(const int& a, const int& b, const int& M) {\n  int c = a - b;\n  return c < 0 ? c + M : c;\n}\nlong long prodll(const long long& a, const long long& b, const long long& M) {\n  return a * b % M;\n}\nlong long sumll(const long long& a, const long long& b, const long long& M) {\n  long long c = a + b;\n  return c >= M ? c - M : c;\n}\nlong long razll(const long long& a, const long long& b, const long long& M) {\n  long long c = a - b;\n  return c < 0 ? c + M : c;\n}\ntemplate <typename A>\nbool angdis_cmp(const pair<A, A>& a, const pair<A, A>& b) {\n  A p;\n  if (p = a % b)\n    return (p > 0);\n  else\n    return sq_len(a) < sq_len(b);\n}\ntemplate <typename T>\nint find_min_idx(const vector<T>& v) {\n  int ans = 0, n = ((int)(v.size()));\n  for (int i = 1; i < n; ++i)\n    if (v[i] < v[ans]) ans = i;\n  return ans;\n}\ntemplate <typename T>\nvector<int> convex_hull(vector<pair<T, T>>& a) {\n  int n = ((int)(a.size()));\n  if (n) {\n    int mt = find_min_idx(a);\n    pair<T, T> d = a[mt];\n    for (int i = 0; i < n; ++i) a[i] -= d;\n    vector<int> idx(n);\n    for (int i = 0; i < n; ++i) idx[i] = i;\n    sort(idx.begin(), idx.end(),\n         [&](const int& l, const int& r) { return angdis_cmp(a[l], a[r]); });\n    vector<int> h(1, idx.front());\n    for (auto it = idx.begin() + 1; it != idx.end(); ++it) {\n      auto temp = a.begin() + *it;\n      if (((int)(h.size())) >= 2) {\n        if (are_parallel(a[h.back()], *temp)) h.pop_back();\n        while ((((int)(h.size())) >= 3) &&\n               npocs(a[h[((int)(h.size())) - 2]], a[h.back()], *temp))\n          h.pop_back();\n      }\n      h.push_back(*it);\n    }\n    for (int i = 0; i < n; ++i) a[i] += d;\n    return h;\n  } else\n    return vector<int>();\n}\npair<int, int> cool_gcd(const int& a, const int& b) {\n  if (b) {\n    int c = a / b;\n    pair<int, int> ans1 = cool_gcd(b, a - b * c);\n    return pair<long long, long long>(ans1.second,\n                                      ans1.first - ans1.second * c);\n  } else\n    return pair<int, int>(1, 0);\n}\npair<long long, long long> cool_gcdll(const long long& a, const long long& b) {\n  if (b) {\n    long long c = a / b;\n    pair<long long, long long> ans1 = cool_gcdll(b, a - b * c);\n    return pair<long long, long long>(ans1.second,\n                                      ans1.first - ans1.second * c);\n  } else\n    return pair<long long, long long>(1ll, 0ll);\n}\nint gcd(int a, int b) {\n  while (b) {\n    a %= b;\n    swap(a, b);\n  }\n  return a;\n}\nlong long gcdll(long long a, long long b) {\n  while (b) {\n    a %= b;\n    swap(a, b);\n  }\n  return a;\n}\nlong long pr_p(const long long& a, const long long& b, const long long& p) {\n  if (b < 1000000) return (a * b) % p;\n  long long temp = pr_p(a, b >> 1ll, p);\n  temp = sumll(temp, temp, p);\n  if (b & 1ll)\n    return sumll(temp, a, p);\n  else\n    return temp;\n}\nlong long po_p(const long long& a, const long long& b, const long long& p) {\n  if (b < 2) {\n    if (b == 0)\n      return 1;\n    else\n      return a;\n  }\n  long long temp = po_p(a, b >> 1ll, p);\n  temp = pr_p(temp, temp, p);\n  if (b & 1ll)\n    return pr_p(temp, a, p);\n  else\n    return temp;\n}\nint pow_mod(const int& a, const int& b, const int& p) {\n  if (b < 2) {\n    if (b == 0)\n      return 1;\n    else\n      return a;\n  }\n  int temp = pow_mod(a, b >> 1, p);\n  temp = prod(temp, temp, p);\n  if (b & 1)\n    return prod(temp, a, p);\n  else\n    return temp;\n}\nlong long pow_modll(const long long& a, const long long& b,\n                    const long long& p) {\n  if (b < 2) {\n    if (b == 0)\n      return 1;\n    else\n      return a;\n  }\n  long long temp = pow_modll(a, b >> 1ll, p);\n  temp = prodll(temp, temp, p);\n  if (b & 1ll)\n    return prodll(temp, a, p);\n  else\n    return temp;\n}\nint inverse(int a, int n) {\n  int c = cool_gcd(a, n).first;\n  if (c < 0) c += n;\n  return c;\n}\nlong long inversell(long long a, long long n) {\n  long long c = cool_gcdll(a, n).first;\n  if (c < 0) c += n;\n  return c;\n}\ntemplate <typename A>\npair<int, int> equal_elements(const vector<A>& u, const vector<A>& v) {\n  pair<int, int> ans(INT_MAX, INT_MAX);\n  int m = ((int)(u.size())), n = ((int)(v.size()));\n  vector<int> id_u(m);\n  for (int i = 1; i < m; ++i) id_u[i] = i;\n  vector<int> id_v(n);\n  for (int i = 1; i < n; ++i) id_v[i] = i;\n  sort(id_u.begin(), id_u.end(),\n       [&](const int& x, const int& y) { return u[x] < u[y]; });\n  sort(id_v.begin(), id_v.end(),\n       [&](const int& x, const int& y) { return v[x] < v[y]; });\n  int i = 0;\n  int j = 0;\n  while ((i < m) && (j < n)) {\n    if (u[id_u[i]] < v[id_v[j]])\n      ++i;\n    else if (v[id_v[j]] < u[id_u[i]])\n      ++j;\n    else {\n      ans = min(ans, pair<int, int>(id_v[j], id_u[i]));\n      ++j;\n    }\n  }\n  if (ans.first == INT_MAX)\n    return pair<int, int>(-1, -1);\n  else\n    return pair<int, int>(ans.second, ans.first);\n}\nlong long discr_log(long long a, long long b, long long n) {\n  int k = ((int)(sqrt((long double)n)));\n  long long a1 = inversell(a, n);\n  int l = k + 20;\n  long long a2 = po_p(a1, k, n);\n  vector<long long> seq1(k), seq2(l);\n  seq1.front() = 1;\n  for (int i = 1; i < k; ++i) seq1[i] = pr_p(seq1[i - 1], a, n);\n  seq2.front() = b;\n  for (int i = 1; i < l; ++i) seq2[i] = pr_p(seq2[i - 1], a2, n);\n  pair<long long, long long> e = equal_elements(seq1, seq2);\n  if (e.first == -1)\n    return -1;\n  else\n    return e.first + e.second * k;\n}\nlong long common_discr_log(long long a, long long b, long long n) {\n  const int C = 70;\n  a %= n;\n  b %= n;\n  if (gcdll(n, a) != 1) {\n    for (int i = 0; i < C; ++i) {\n      if (po_p(a, i, n) == b) {\n        return i;\n      }\n    }\n    long long multp = po_p(a, C, n);\n    long long g = gcdll(multp, n);\n    if (b % g) {\n      return -1;\n    } else {\n      b /= g;\n      n /= g;\n      multp /= g;\n      long long pop_back = inversell(multp, n);\n      b = pr_p(b, pop_back, n);\n      long long ans = discr_log(a, b, n);\n      if (ans == -1)\n        return -1;\n      else\n        return ans + C;\n    }\n  } else\n    return discr_log(a, b, n);\n}\nstruct factorizator {\n  const int N = 2000001;\n  vector<int> pr;\n  vector<int> md;\n  vector<int> pw;\n  vector<int> without_md;\n  void init() {\n    md.resize(N);\n    pw.resize(N);\n    pr.reserve(N);\n    without_md.resize(N, 1);\n    for (int i = 2; i < N; ++i) md[i] = i;\n    for (int i = 2; i < N; ++i) {\n      if (md[i] == i) pr.push_back(i);\n      bool worth = true;\n      for (int j = 0; worth && (j < ((int)(pr.size()))) && (pr[j] <= md[i]);\n           ++j) {\n        long long temp = ((long long)(pr[j])) * i;\n        if (temp < N)\n          md[((int)temp)] = pr[j];\n        else\n          worth = false;\n      }\n    }\n    for (int i = 2; i < N; ++i) {\n      int t = md[i], s = i / t;\n      if (md[s] == t) {\n        pw[i] = 1 + pw[s];\n        without_md[i] = without_md[s];\n      } else {\n        pw[i] = 1;\n        without_md[i] = s;\n      }\n    }\n  }\n  void known_factorization(int n, vector<pair<int, int>>& v) {\n    while (n > 1) {\n      v.emplace_back(md[n], pw[n]);\n      n = without_md[n];\n    }\n  }\n  vector<pair<int, int>> factorize(int n) {\n    vector<pair<int, int>> ans;\n    for (int i = 0;\n         (i < ((int)(pr.size()))) && (pr[i] * ((long long)(pr[i])) <= n); ++i) {\n      int t = n / pr[i];\n      if (t * pr[i] == n) {\n        ans.emplace_back(pr[i], 0);\n        do {\n          ++ans.back().second;\n          n = t;\n          t = n / pr[i];\n        } while (t * pr[i] == n);\n      }\n      if (n < N) {\n        known_factorization(n, ans);\n        return ans;\n      }\n    }\n    if (n > 1) ans.emplace_back(n, 1);\n    return ans;\n  }\n  vector<pair<int, int>> merge(const vector<pair<int, int>>& p1,\n                               const vector<pair<int, int>>& p2) {\n    vector<pair<int, int>> ans;\n    int m = ((int)(p1.size()));\n    int n = ((int)(p2.size()));\n    int i = 0;\n    int j = 0;\n    while ((i < m) || (j < n)) {\n      if (i < m) {\n        if (j < n) {\n          if (p1[i].first < p2[j].first)\n            ans.push_back(p1[i++]);\n          else if (p1[i].first > p2[j].first)\n            ans.push_back(p2[j++]);\n          else {\n            ans.emplace_back(p1[i].first, p1[i].second + p2[j].second);\n            ++i;\n            ++j;\n          }\n        } else\n          ans.push_back(p1[i++]);\n      } else\n        ans.push_back(p2[j++]);\n    }\n    return ans;\n  }\n};\nfactorizator fac;\nint phi(const vector<pair<int, int>>& v) {\n  int ans = 1;\n  for (int i = 0; i < ((int)(v.size())); ++i) {\n    ans *= v[i].first - 1;\n    for (int j = 1; j < v[i].second; ++j) ans *= v[i].first;\n  }\n  return ans;\n}\nint phi(const int& n) { return phi(fac.factorize(n)); }\nbool check_primitive_root(const int& ph, const vector<int>& to_check,\n                          const int& r, const int& n) {\n  for (int i = 0; i < ((int)(to_check.size())); ++i)\n    if (pow_mod(r, to_check[i], n) == 1) return false;\n  return (pow_mod(r, ph, n) == 1);\n}\nint primitive_root(const int& n) {\n  if (n < 3) return n - 1;\n  int p = phi(n);\n  vector<pair<int, int>> f = fac.factorize(p);\n  vector<int> to_check(((int)(f.size())));\n  for (int i = 0; i < ((int)(f.size())); ++i) to_check[i] = p / f[i].first;\n  for (int i = 2; i < n; ++i)\n    if (check_primitive_root(p, to_check, i, n)) return i;\n  return -1;\n}\nint unite_mod(const int& a, const int& p, const int& b, const int& q) {\n  pair<int, int> c = cool_gcd(p, q);\n  int pr = p * q;\n  int ans = ((a * c.second * q + b * c.first * p) % pr + pr) % pr;\n  return ans;\n}\nlong long unite_modll(const long long& a, const long long& p,\n                      const long long& b, const long long& q) {\n  pair<long long, long long> c = cool_gcdll(p, q);\n  long long pr = p * q;\n  long long ans = ((a * c.second * q + b * c.first * p) % pr + pr) % pr;\n  return ans;\n}\npair<int, int> power_v(int n, const int& p) {\n  int ans = 0;\n  while (n % p == 0) {\n    n /= p;\n    ++ans;\n  }\n  return pair<int, int>(ans, n);\n}\nint square_root_prime_modulo(int c, int n, const int& pr, const int& k) {\n  c %= n;\n  if (c) {\n    pair<int, int> kek = power_v(c, pr);\n    int l = kek.first;\n    if (l & 1) return -1;\n    if (l > 0) {\n      int pwl = 1;\n      for (int i = 0; i < l; ++i) pwl *= pr;\n      n /= pwl;\n      c /= pwl;\n      int ans1 = square_root_prime_modulo(c, n, pr, k - l);\n      if (ans1 == -1) return -1;\n      for (int i = 0; i < (l >> 1); ++i) ans1 *= pr;\n      return ans1;\n    } else {\n      int primitive;\n      if (n & 1)\n        primitive = primitive_root(n);\n      else\n        primitive = 5;\n      int u = ((int)discr_log(primitive, c, n));\n      if (u == -1) return -1;\n      if (u & 1) return -1;\n      return pow_mod(primitive, u >> 1, n);\n    }\n  } else\n    return 0;\n}\nint square_root_modulo(const int& c, const int& n) {\n  vector<pair<int, int>> f = fac.factorize(n);\n  int a = 0, p = 1;\n  for (int i = 0; i < ((int)(f.size())); ++i) {\n    int q = 1;\n    for (int j = 0; j < f[i].second; ++j) q *= f[i].first;\n    int b = square_root_prime_modulo(c, q, f[i].first, f[i].second);\n    if (b == -1) return -1;\n    a = unite_mod(a, p, b, q);\n    p *= q;\n  }\n  return a;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cerr.tie(0);\n  int n, I;\n  cin >> n >> I;\n  I *= 8;\n  int r = I / n;\n  vector<int> a(n);\n  cin >> a;\n  sort(a.begin(), a.end());\n  if (r < 30)\n    r = (1 << r);\n  else\n    r = 1 << 30;\n  int ans = n - 1;\n  int diff = 1;\n  int l = 0;\n  for (int i = 1; i < n; ++i) {\n    if (a[i] != a[i - 1]) ++diff;\n    if (diff > r) {\n      if (a[l] != a[l + 1]) --diff;\n      ++l;\n    }\n    ans = min(ans, l + (n - i - 1));\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n \npublic class Main {\n  public static void main (String[] args) {\n    FastScanner sc = new FastScanner();\n    int N = sc.nextInt();\n    int I = sc.nextInt();\n    int[] nums = new int[N+1];\n    for (int i = 0; i < N; i++)\n      nums[i] = sc.nextInt();\n    nums[N] = Integer.MAX_VALUE;\n    Arrays.sort(nums);\n\n    ArrayList<Integer> bunches = new ArrayList<Integer>();\n    int curNum = nums[0];\n    int counter = 1;\n    for (int i = 1; i <= N; i++) {\n      if (nums[i] == curNum) {\n        counter++;\n      } else {\n        bunches.add(counter);\n        curNum = nums[i];\n        counter = 1;\n      }\n    }\n\n    int k = (8 * I)/N;\n    int K = bunches.size();\n    if (k <= 19 && Math.pow(2,k) < bunches.size()) {\n      K = (int)Math.pow(2,k);\n    }\n\n    int[] bunchSum = new int[bunches.size() + 1];\n    bunchSum[0] = 0;\n    for (int i = 1; i <= bunches.size(); i++) {\n      bunchSum[i] = bunchSum[i-1] + bunches.get(i-1);\n    }\n    int numToRemain = 0;\n    for (int i = 0; i < bunches.size() - K + 1; i++) {\n      numToRemain = Math.max(numToRemain,bunchSum[i+K]-bunchSum[i]);\n    }\n\n    int numToSlide = N-numToRemain;\n    System.out.println(numToSlide);\n  }\n  \n  static class FastScanner { \n    BufferedReader br; \n    StringTokenizer st; \n    \n    public FastScanner() { \n      br = new BufferedReader(new InputStreamReader(System.in)); \n    } \n    \n    String next() {\n      while (st == null || !st.hasMoreElements()) { \n        try\n        { \n          st = new StringTokenizer(br.readLine()); \n        } \n        catch (IOException  e) \n        { \n          e.printStackTrace(); \n        } \n      } \n      return st.nextToken(); \n    }\n        \n    int nextInt() { \n      return Integer.parseInt(next()); \n    }\n  }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, I;\n  cin >> n >> I;\n  int data[400005];\n  int la[400005], lai = 0, last = -1;\n  for (int i = 0; i < n; i++) cin >> data[i];\n  sort(data, data + n);\n  int now = 0;\n  for (int i = 0; i < n; i++) {\n    if (data[i] != last) {\n      la[lai++] = now;\n      now = 1;\n      last = data[i];\n    } else {\n      now++;\n    }\n  }\n  la[lai] = now;\n  I = 8 * I / n;\n  if (I > 20) I = 20;\n  long long range = 1 << I;\n  if (range >= lai)\n    cout << 0 << endl;\n  else {\n    for (int i = 2; i <= lai; i++) {\n      la[i] += la[i - 1];\n    }\n    int ans = 0;\n    for (long long i = range; i <= lai; i++) {\n      if (la[i] - la[i - range] > ans) ans = la[i] - la[i - range];\n    }\n    cout << n - ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.awt.*;\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.util.*;\n \nimport static java.lang.Math.*;\n \npublic class Main {\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer st = new StringTokenizer(\"\");\n    PrintWriter pw = new PrintWriter(System.out);\n \n    public Main() throws FileNotFoundException {\n    }\n \n    int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n \n    String next() throws IOException {\n        if (!st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n \n    long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n \n    public static void main(String[] args) throws IOException {\n        new Main().run();\n    }\n \n    void run() throws IOException {\n        int n = nextInt();\n        int i = nextInt() * 8;\n        int k = i / n;\n        int r = 0;\n        int K = 1;\n        int[] a = new int[n];\n        TreeMap<Integer, Integer> ts = new TreeMap<>();\n        for (int j = 0; j < n; j++) {\n            int e = nextInt();\n            if (!ts.containsKey(e))\n                a[j] = e;\n            ts.put(e, ts.getOrDefault(e, 0) + 1);\n        }\n        int size = ts.size();\n        Arrays.sort(a);\n        int u = 0;\n        while (a[u] == 0) u++;\n        while (r < k) {\n            K *= 2;\n            r++;\n            if (K >= ts.size()) {\n                pw.println(0);\n                pw.close();\n                return;\n            }\n        }\n        int[] sum = new int[size + 1];\n        for (int j = 0; j < size; j++) {\n            sum[j + 1] = sum[j] + ts.get(a[j + u]);\n        }\n        int ans = Integer.MAX_VALUE;\n        for (int j = 0; j < size - K + 1; j++) {\n            ans = min(ans, sum[size] - sum[j + K] + sum[j]);\n        }\n        pw.print(ans);\n        pw.close();\n    }\n \n    class Pair {\n        long ves;\n        int from, to;\n \n        public Pair(long a, int c, int b) {\n            ves = a;\n            from = c;\n            to = b;\n        }\n    }\n \n    static class PairComp implements Comparator<Pair> {\n \n        @Override\n        public int compare(Pair o1, Pair o2) {\n            return Long.compare(o1.ves, o2.ves);\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long int n, k;\n  cin >> n >> k;\n  long long int arr[n];\n  map<long long int, long long int> m;\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i];\n    m[arr[i]]++;\n  }\n  long long int D = m.size();\n  long long int exe = 0;\n  for (int i = 1; i <= D; i++) {\n    if ((k * 8) >= (ceil((double)log2l(i))) * n) {\n      exe = i;\n    }\n  }\n  vector<long long int> v;\n  map<long long int, long long int>::iterator it;\n  v.push_back(0);\n  for (it = m.begin(); it != m.end(); it++) {\n    v.push_back(it->second);\n  }\n  long long int ans = 0;\n  for (int i = 1; i < v.size(); i++) {\n    v[i] += v[i - 1];\n  }\n  long long int maxi = 0;\n  for (int i = 0; i + exe < v.size(); i++) {\n    maxi = max(maxi, v[exe + i] - v[i]);\n  }\n  cout << v.back() - maxi << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n,I = [int(w) for w in input().split()]\na = [int(w) for w in input().split()]\n\nk = 8*I//n\nK = 2**k\na.sort()\nb = [0]\nfor i in range(1, n):\n    if a[i-1] != a[i]:\n        b.append(i)\n\nif len(b) <= K:\n    print(0)\nelse:\n    print(n - max(b[i+K]-b[i] for i in range(len(b) - K)))\n"
        },
        {
            "language": 3,
            "solution": "n,i=map(int,input().split())\nk=2**(8*i//n) if 8*i//n < 20 else n\na=[int(x) for x in input().split()]\na.sort()\nfreq = [1]\nfor i in range(1, len(a)):\n\tif a[i-1] == a[i]:\n\t\tfreq[-1] += 1\n\telse:\n\t\tfreq.append(1)\nwindow = sum(freq[:k])\nans = window\nfor i in range(k, len(freq)):\n\twindow += freq[i]\n\twindow -= freq[i-k]\n\tans = max(ans, window)\n\nprint(n-ans)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.io.FilterInputStream;\nimport java.io.BufferedInputStream;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Jenish\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        ScanReader in = new ScanReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CMP3 solver = new CMP3();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CMP3 {\n        public void solve(int testNumber, ScanReader in, PrintWriter out) {\n            int n = in.scanInt();\n            long I = in.scanLong();\n            I = I * 8;\n\n            long kk = (I) / n;\n            long sizeofrange;\n            if (kk > 30) sizeofrange = n;\n            else sizeofrange = (long) Math.min(CodeX.power(2, kk), n);\n\n            int arr[] = new int[n];\n            in.scanInt(arr);\n            HashSet<Integer> hs = new HashSet<>();\n            long ans = Long.MAX_VALUE;\n            for (int i = 0; i < n; i++) hs.add(arr[i]);\n\n            int dis[] = new int[hs.size()];\n            int p = 0;\n            for (int k : hs) dis[p++] = k;\n\n            CodeX.sort(dis);\n            CodeX.sort(arr);\n            for (int i = 0; i < dis.length; i++) {\n                int l = dis[i];\n                int r;\n                if (i + sizeofrange - 1 < dis.length) {\n                    r = dis[(int) (i + sizeofrange - 1)];\n                } else {\n                    r = dis[dis.length - 1] + 1;\n                }\n                int s = (int) CodeX.lbound(arr, 0, arr.length, l);\n                int ss = (int) CodeX.lbound(arr, 0, arr.length, r + 1);\n                int kamana = ss - s;\n                ans = Math.min(ans, n - kamana);\n            }\n\n            out.println(ans);\n        }\n\n    }\n\n    static class ScanReader {\n        private byte[] buf = new byte[4 * 1024];\n        private int INDEX;\n        private BufferedInputStream in;\n        private int TOTAL;\n\n        public ScanReader(InputStream inputStream) {\n            in = new BufferedInputStream(inputStream);\n        }\n\n        private int scan() {\n            if (INDEX >= TOTAL) {\n                INDEX = 0;\n                try {\n                    TOTAL = in.read(buf);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                if (TOTAL <= 0) return -1;\n            }\n            return buf[INDEX++];\n        }\n\n        public int scanInt() {\n            int I = 0;\n            int n = scan();\n            while (isWhiteSpace(n)) n = scan();\n            int neg = 1;\n            if (n == '-') {\n                neg = -1;\n                n = scan();\n            }\n            while (!isWhiteSpace(n)) {\n                if (n >= '0' && n <= '9') {\n                    I *= 10;\n                    I += n - '0';\n                    n = scan();\n                }\n            }\n            return neg * I;\n        }\n\n        private boolean isWhiteSpace(int n) {\n            if (n == ' ' || n == '\\n' || n == '\\r' || n == '\\t' || n == -1) return true;\n            else return false;\n        }\n\n        public long scanLong() {\n            long I = 0;\n            int n = scan();\n            while (isWhiteSpace(n)) n = scan();\n            int neg = 1;\n            if (n == '-') {\n                neg = -1;\n                n = scan();\n            }\n            while (!isWhiteSpace(n)) {\n                if (n >= '0' && n <= '9') {\n                    I *= 10;\n                    I += n - '0';\n                    n = scan();\n                }\n            }\n            return neg * I;\n        }\n\n        public void scanInt(int[] A) {\n            for (int i = 0; i < A.length; i++) A[i] = scanInt();\n        }\n\n    }\n\n    static class CodeX {\n        public static long power(long x, long y) {\n            long res = 1;\n            while (y > 0) {\n                if ((y & 1) != 0)\n                    res = (res * x);\n                y = y >> 1;\n                x = (x * x);\n            }\n            return res;\n        }\n\n        public static int lbound(int array[], int l, int h, int x) {\n            while (l < h) {\n                int mid = (l + h) / 2;\n                if (array[mid] >= x) h = mid;\n                else l = mid + 1;\n            }\n            return l;\n        }\n\n        public static void sort(int arr[]) {\n            merge_sort(arr, 0, arr.length - 1);\n        }\n\n        private static void merge_sort(int A[], int start, int end) {\n            if (start < end) {\n                int mid = (start + end) / 2;\n                merge_sort(A, start, mid);\n                merge_sort(A, mid + 1, end);\n                merge(A, start, mid, end);\n            }\n\n        }\n\n        private static void merge(int A[], int start, int mid, int end) {\n            int p = start, q = mid + 1;\n            int Arr[] = new int[end - start + 1];\n            int k = 0;\n\n            for (int i = start; i <= end; i++) {\n                if (p > mid)\n                    Arr[k++] = A[q++];\n\n                else if (q > end)\n                    Arr[k++] = A[p++];\n\n                else if (A[p] < A[q])\n                    Arr[k++] = A[p++];\n\n                else\n                    Arr[k++] = A[q++];\n            }\n            for (int i = 0; i < k; i++) {\n                A[start++] = Arr[i];\n            }\n\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        int n = sc.nextInt(), I = sc.nextInt();\n        Integer[] a = sc.nextIntegerArray(n);\n        int k = (8 * I) / n;\n        if (k >= 20) {\n            System.out.println(0);\n            return;\n        }\n        int K = 1 << k;\n        TreeMap<Integer, Integer> map = new TreeMap<>();\n        for (int x : a)\n            map.put(x, map.getOrDefault(x, 0) + 1);\n        int[] compressed = new int[map.size()];\n        int idx = 0;\n        int[] left = new int[n];\n        int[] right = new int[n];\n        for (int x : map.keySet()) {\n            compressed[idx] = map.get(x);\n            idx++;\n        }\n        for (int i = 0; i < idx; i++)\n            left[i] = compressed[i] + (i == 0 ? 0 : left[i - 1]);\n        for (int i = idx - 1; i >= 0; i--)\n            right[i] = compressed[i] + (i == idx - 1 ? 0 : right[i + 1]);\n        int min = n;\n        for (int i = 0; i < idx; i++) {\n            int j = i + K;\n            int cand = 0;\n            if (i != 0) cand += left[i - 1];\n            if (j < idx) cand += right[j];\n            min = Math.min(min, cand);\n        }\n        out.println(min);\n        out.flush();\n        out.close();\n    }\n\n    static class Scanner {\n\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream system) {\n            br = new BufferedReader(new InputStreamReader(system));\n        }\n\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public char nextChar() throws IOException {\n            return next().charAt(0);\n        }\n\n        public Long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n\n\n        public int[] nextIntArray(int n) throws IOException {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        public long[] nextLongArray(int n) throws IOException {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n\n\n        public Integer[] nextIntegerArray(int n) throws IOException {\n            Integer[] a = new Integer[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        public double[] nextDoubleArray(int n) throws IOException {\n            double[] ans = new double[n];\n            for (int i = 0; i < n; i++)\n                ans[i] = nextDouble();\n            return ans;\n        }\n\n        public short nextShort() throws IOException {\n            return Short.parseShort(next());\n        }\n\n    }\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;  \npublic class Main \n{\n    PrintWriter out;\n    FastReader sc;\n    long mod=(long)(1e9+7);\n    long maxlong=Long.MAX_VALUE;\n    long minlong=Long.MIN_VALUE;\n    /******************************************************************************************\n     *****************************************************************************************/\n\tpublic void sol(){\n\t\tint n=ni(),I=ni();\n\t\tlong a=I*8;\n\t\tTreeMap<Long,Long> map=new TreeMap<>();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tlong p=ni();\n\t\t\tmap.put(p,map.getOrDefault(p,0l)+1);\n\t\t}a=(a)/n;\n\t\tlong[][] ar=new long[map.size()][2];\n\t\tint x=0;\n\t\tfor(Map.Entry<Long,Long> m:map.entrySet()) {\n\t\t\tlong k=m.getKey(),v=m.getValue();\n\t\t\tar[x][0]=k;\n\t\t\tar[x][1]=v;\n\t\t\tx++;\n\t\t}\n\t\tlong[] sum=new long[map.size()];\n\t\tint s=map.size();\n\t\tsum[0]=ar[0][1];\n\t\tfor(int i=1;i<map.size();i++) {\n\t\t\tsum[i]=sum[i-1]+ar[i][1];\n\t\t}\n//\t\tfor(int i=0;i<s;i++)pl(sum[i]);\n\t\ta=min(a,25);\n\t\tint b=(int)(1<<a);\n\t\tlong ans=maxlong;\n\t\tboolean f=true;\n\t\tfor(int i=0;(i+b)<=s;i++) {\n\t\t\tf=false;\n\t\t\tlong p=sum[s-1]-sum[i+b-1];\n//\t\t\tpl(p);\n\t\t\tif(i!=0) {\n\t\t\t\tp+=sum[i-1];\n\t\t\t}ans=min(ans,p);\n\t\t}if(f)pl(\"0\");\n\t\telse\n\t\tpl(ans);\n\t}\n    public static void main(String[] args) \n\t{ \n\t    Main g=new Main();\n\t\tg.out=new PrintWriter(System.out);\n\t\tg.sc=new FastReader();\n\t\tint t=1;\n// \t\tt=g.ni();\n\t\twhile(t-->0)\n\t\tg.sol();\n\t\tg.out.flush();\n\t}\n\t\n\t/****************************************************************************************\n     *****************************************************************************************/\n\tstatic class FastReader \n\t{ \n\t\tBufferedReader br; \n\t\tStringTokenizer st; \n \n\t\tpublic FastReader() \n\t\t{ \n\t\t\tbr = new BufferedReader(new\n\t\t\t\t\tInputStreamReader(System.in)); \n\t\t} \n \n\t\tString next() \n\t\t{ \n\t\t\twhile (st == null || !st.hasMoreElements()) \n\t\t\t{ \n\t\t\t\ttry\n\t\t\t\t{ \n\t\t\t\t\tst = new StringTokenizer(br.readLine()); \n\t\t\t\t} \n\t\t\t\tcatch (IOException e) \n\t\t\t\t{ \n\t\t\t\t\te.printStackTrace(); \n\t\t\t\t} \n\t\t\t} \n\t\t\treturn st.nextToken(); \n\t\t} \n \n\t\tint nextInt() \n\t\t{ \n\t\t\treturn Integer.parseInt(next()); \n\t\t} \n \n\t\tlong nextLong() \n\t\t{ \n\t\t\treturn Long.parseLong(next()); \n\t\t} \n \n\t\tdouble nextDouble() \n\t\t{ \n\t\t\treturn Double.parseDouble(next()); \n\t\t} \n \n\t\tString nextLine() \n\t\t{ \n\t\t\tString str = \"\"; \n\t\t\ttry\n\t\t\t{ \n\t\t\t\tstr = br.readLine(); \n\t\t\t} \n\t\t\tcatch (IOException e) \n\t\t\t{ \n\t\t\t\te.printStackTrace(); \n\t\t\t} \n\t\t\treturn str; \n\t\t} \n\t} public int ni(){\n\t      return sc.nextInt();\n\t}public long nl(){\n\t      return sc.nextLong();\n\t}public double nd(){\n\t      return sc.nextDouble();\n\t}public char[] rl(){\n\t      return sc.nextLine().toCharArray();\n\t}public String rl1(){\n\t      return sc.nextLine();\n\t}\n\tpublic void pl(Object s){\n\t      out.println(s);\n\t}public void ex(){\n\t      out.println();\n\t}\n\tpublic void pr(Object s){\n\t      out.print(s);\n\t}public String next(){\n\t      return sc.next();\n\t}public long abs(long x){\n\t      return Math.abs(x);\n\t}\n\tpublic int abs(int x){\n\t      return Math.abs(x);\n\t}\n\tpublic double abs(double x){\n\t      return Math.abs(x);\n\t}public long min(long x,long y){\n            return (long)Math.min(x,y);\n      }\n      public int min(int x,int y){\n            return (int)Math.min(x,y);\n      }\n      public double min(double x,double y){\n            return Math.min(x,y);\n      }public long gcd(long a, long b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\t\treturn gcd(b % a, a);\n\t}public long lcm(long a, long b) {\n            return (a / gcd(a, b)) * b;\n      }\n       void sort1(int[] a) {\n\t\tArrayList<Integer> l = new ArrayList<>();\n\t\tfor (int i : a) {\n\t\t\tl.add(i);\n\t\t}\n\t\tCollections.sort(l,Collections.reverseOrder());\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = l.get(i);\n\t\t}\n\t}\n\t void sort(int[] a) {\n\t\tArrayList<Integer> l = new ArrayList<>();\n\t\tfor (int i : a) {\n\t\t\tl.add(i);\n\t\t}\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = l.get(i);\n\t\t}\n\t}void sort(long[] a) {\n\t\tArrayList<Long> l = new ArrayList<>();\n\t\tfor (long i : a) {\n\t\t\tl.add(i);\n\t\t}\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = l.get(i);\n\t\t}\n\t}void sort1(long[] a) {\n\t\tArrayList<Long> l = new ArrayList<>();\n\t\tfor (long i : a) {\n\t\t\tl.add(i);\n\t\t}\n\t\tCollections.sort(l,Collections.reverseOrder());\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = l.get(i);\n\t\t}\n\t}\n\tvoid sort(double[] a) {\n\t\tArrayList<Double> l = new ArrayList<>();\n\t\tfor (double i : a) {\n\t\t\tl.add(i);\n\t\t}\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = l.get(i);\n\t\t}\n\t}long pow(long a,long b){\n          if(b==0){\n                return 1;\n          }long p=pow(a,b/2);\n          if(b%2==0) return (p*p);\n          else return (((p*p))*a);\n    }\n\t\n\tint  swap(int a,int b){\n\t      return a;\n\t}long  swap(long a,long b){\n\t      return a;\n\t}double  swap(double a,double b){\n\t      return a;\n\t}\n\tboolean isPowerOfTwo (int x) \n      { \n            return x!=0 && ((x&(x-1)) == 0);     \n      }boolean isPowerOfTwo (long x) \n      { \n            return x!=0 && ((x&(x-1)) == 0);     \n      }public long max(long x,long y){\n            return (long)Math.max(x,y);\n      }\n      public int max(int x,int y){\n            return (int)Math.max(x,y);\n      }\n      public double max(double x,double y){\n            return Math.max(x,y);\n      }long sqrt(long x){\n            return (long)Math.sqrt(x);\n      }int sqrt(int x){\n            return (int)Math.sqrt(x);\n      }void input(int[] ar,int n){\n            for(int i=0;i<n;i++)ar[i]=ni();\n      }void input(long[] ar,int n){\n            for(int i=0;i<n;i++)ar[i]=nl();\n      }void fill(int[] ar,int k){\n            Arrays.fill(ar,k);\n      }void yes(){\n            pl(\"YES\");\n      }void no(){\n            pl(\"NO\");\n      }\n    long[] sieve(int n) \n    {\n          long[] k=new long[n+1];\n          boolean[] pr=new boolean[n+1];\n          for(int i=1;i<=n;i++){\n                k[i]=i;\n                pr[i]=true;\n          }for(int i=2;i<=n;i++){\n                if(pr[i]){\n                      for(int j=i+i;j<=n;j+=i){\n                            pr[j]=false;\n                            if(k[j]==j){\n                                  k[j]=i;\n                            }\n                      }\n                }\n          }return k;\n    }\n    int strSmall(int[] arr, int target)  \n    {  \n        int start = 0, end = arr.length-1;  \n        int ans = -1;  \n        while (start <= end) {  \n            int mid = (start + end) / 2;   \n            if (arr[mid] >= target) {  \n                end = mid - 1;  \n            }   \n            else {  \n                ans = mid;  \n                start = mid + 1;  \n            }  \n        }  \n        return ans;  \n    } int strSmall(ArrayList<Integer> arr, int target)  \n    {  \n        int start = 0, end = arr.size()-1;  \n        int ans = -1;  \n        while (start <= end) {  \n            int mid = (start + end) / 2;   \n            if (arr.get(mid) > target) {  \n                start = mid + 1; \n                ans=start;\n            }   \n            else {\n                end = mid - 1;  \n            }  \n        }  \n        return ans;  \n    }long mMultiplication(long a,long b) \n    { \n        long res = 0;    \n        a %= mod; \n  \n        while (b > 0)  \n        {  \n            if ((b & 1) > 0)  \n            { \n                res = (res + a) % mod; \n            }  \n            a = (2 * a) % mod; \n  \n            b >>= 1;  \n        } \n        return res; \n    }long nCr(int n, int r ,int p)\n    {\n \n          if (n<r) \n              return 0;\n        if (r == 0)\n            return 1;\n            long[] fac = new long[n + 1];\n        fac[0] = 1;\n \n        for (int i = 1; i <= n; i++)\n            fac[i] = fac[i - 1] * i % p;\n        return (fac[n] * modInverse(fac[r], p)\n                % p * modInverse(fac[n - r], p)\n                % p)\n            % p;\n    }long power(long x, long y, long p)\n    {\n        long res = 1;\n        x = x % p;\n \n        while (y > 0) {\n            if (y % 2 == 1)\n                res = (res * x) % p;\n            y = y >> 1; \n            x = (x * x) % p;\n        }\n \n        return res;\n    }long modInverse(long n, long p)\n    {\n        return power(n, p - 2, p);\n    }\n    \n    int[][] floydWarshall(int graph[][],int INF,int V)\n    {\n        int dist[][] = new int[V][V];\n        int i, j, k;\n        for (i = 0; i < V; i++)\n            for (j = 0; j < V; j++)\n                dist[i][j] = graph[i][j];\n        for (k = 0; k < V; k++)\n        {\n            for (i = 0; i < V; i++)\n            {\n                for (j = 0; j < V; j++)\n                {\n                    if (dist[i][k] + dist[k][j] < dist[i][j])\n                        dist[i][j] = dist[i][k] + dist[k][j];\n                }\n            }\n        }return dist;\n    }\n      public static class Pair implements Comparable<Pair> {\n\t\tlong x;\n\t\tlong y;\n \n\t\tpublic Pair(long x, long y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\tpublic int compareTo(Pair other) {\n\t\t\tif (this.x == other.x) {\n\t\t\t\treturn Long.compare(this.y, other.y);\n\t\t\t}\n\t\t\treturn Long.compare(this.x, other.x);\n\t\t}\n      }\n\t \n} \n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, size;\n  cin >> n >> size;\n  vector<int> nums(n);\n  for (int i = 0; i < n; i++) {\n    cin >> nums[i];\n  }\n  sort(nums.begin(), nums.end());\n  int bits = size * 8 / n;\n  int pow = (bits < 30 ? (1 << bits) : n);\n  ;\n  int begin = 0, end = 0;\n  int res = n;\n  int k = 1;\n  for (; end < n;) {\n    for (; end < n - 1 && nums[end] == nums[end + 1]; end++) {\n    }\n    if (n - end + begin - 1 < res) {\n      res = n - end + begin - 1;\n    }\n    k++;\n    end++;\n    if (k > pow) {\n      k--;\n      for (; begin < n - 1 && nums[begin] == nums[begin + 1]; begin++) {\n      }\n      begin++;\n    }\n  }\n  cout << res << \"\\n\";\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nimport math\ninput = sys.stdin.readline\nn,I=map(int,input().split())\na=list(map(int,input().split()))\nk=int(8*I//n)\nK = 2**k\na.sort()\nb=[]\nb.append(0)\nfor i in range(1,n):\n    if a[i]!=a[i-1]:\n        b.append(i)\n#print(b)\nif len(b) <= K:\n    print(0)\nelse:\n    print(n - max(b[i + K] - b[i] for i in range(len(b) - K)))"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class mp3 {\n\t\n\tpublic static void main (String [] args) throws Exception {\n\t    BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n\t    PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n\t    StringTokenizer st = new StringTokenizer(f.readLine());\n\t    int N = Integer.parseInt(st.nextToken());\n\t    int I = Integer.parseInt(st.nextToken()) * 8;\n\t    int necessary = (int)Math.floor(Math.pow(2, I / N));\n\t    //System.out.println(necessary);\n\t    \n\t    \n\t    st = new StringTokenizer(f.readLine());\n\t    TreeMap<Integer, Integer> map = new TreeMap<>();\n\t    for(long i = 0; i < N; i++) {\n\t    \tint X = Integer.parseInt(st.nextToken());\n\t    \tif(map.containsKey(X)) {\n\t    \t\tmap.put(X, map.get(X)+1);\n\t    \t} else {\n\t    \t\tmap.put(X, 1);\n\t    \t}\n\t    }\n\t    \n\t    Iterator<Integer> it = map.descendingKeySet().iterator();\n\t    \n\t    int[] sums = new int[map.size()];\n\t    sums[0] = map.get(it.next());\n\t    for(int i = 1; i < sums.length; i++) {\n\t    \tsums[i] = sums[i-1] + map.get(it.next());\n\t    }\n\t    \n\t    //System.out.println(Arrays.toString(sums));\n\t    \n\t    int min = Integer.MAX_VALUE;\n\t    for(int i = necessary; i < sums.length; i++) {\n\t    \tmin = Math.min(min, N - (sums[i] - sums[i-necessary]));\n\t    }\n\t    if(min == Integer.MAX_VALUE)\n\t    \tmin = 0;\n\t    out.println(min);\n\n\t    out.close();\n\t    f.close();\n\t    \n\t    \n\t}\n\t\n}\n/*\nimport java.util.*;\nimport java.io.*;\n\npublic class mp3 {\n\t\n\tpublic static void main (String [] args) throws Exception {\n\t    BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n\t    PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n\t    StringTokenizer st = new StringTokenizer(f.readLine());\n\t    long N = Integer.parseInt(st.nextToken());\n\t    long I = Integer.parseInt(st.nextToken()) * 8;\n\t    \n\t    st = new StringTokenizer(f.readLine());\n\t    TreeMap<Integer, Integer> map = new TreeMap<>();\n\t    for(long i = 0; i < N; i++) {\n\t    \tint X = Integer.parseInt(st.nextToken());\n\t    \tif(map.containsKey(X)) {\n\t    \t\tmap.put(X, map.get(X)+1);\n\t    \t} else {\n\t    \t\tmap.put(X, 1);\n\t    \t}\n\t    }\n\t    \n\t    //System.out.println(map);\n\t    \n\t    int leftKey = map.firstKey(), rightKey = map.lastKey();\n\t    \n\t    long numChanged = 0;\n\t    long size = N * (int)Math.ceil(Math.log(map.size())/Math.log(2));\n\t    while(size > I) {\n\t    \tnumChanged += Math.min(map.get(leftKey), map.get(rightKey));\n\t    \tif(map.get(leftKey) > map.get(rightKey)) {\n\t    \t\tint T = map.lowerKey(rightKey);\n\t    \t\tmap.remove(rightKey);\n\t    \t\trightKey = T;\n\t    \t} else {\n\t    \t\tint T = map.higherKey(leftKey);\n\t    \t\tmap.remove(leftKey);\n\t    \t\tleftKey = T;\n\t    \t}\n\n\t    \tsize = N * (int)Math.ceil(Math.log(map.size())/Math.log(2));\n\t    }\n\t    \n\t    out.println(numChanged);\n\t    out.close();\n\t    f.close();\n\t    \n\t    \n\t}\n\t\n}\n*/"
        },
        {
            "language": 4,
            "solution": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n//\tprivate static final String NO=\"NO\",YES=\"YES\";\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT=\"\";\n\t\n\tvoid solve() {\n\t\tint N=ni();\n\t\tint I=(ni()*8)/N;\n\t\tlong M=1;\n\t\twhile(M<N&&I-->0) M<<=1;\n\t\tInteger []a=na2(N);\n\t\tArrays.sort(a);\n\t\tint ans=Integer.MAX_VALUE;\n\t\tint nDiffs=0;\n\t\tint l=0;\n\t\tfor(int i=0;i<N;i++) {\n\t\t\tif(i==0||i>0&&a[i]-a[i-1]!=0) nDiffs++;\n\t\t\tif(nDiffs>M) {\n\t\t\t\twhile(a[l]-a[l+1]==0)l++;\n\t\t\t\tl++;\n\t\t\t\tnDiffs--;\n\t\t\t}\n\t\t\tif(nDiffs==M) ans=Math.min(ans, N-(i-l+1));\n\t\t}\n\t\tout.println(ans==Integer.MAX_VALUE?0:ans);\n\t}\n\tvoid run()throws Exception{\n\t\tis=INPUT.isEmpty()?System.in:new ByteArrayInputStream(INPUT.getBytes());\n\t\tout=new PrintWriter(System.out);\n\t\t\n\t\tlong s=System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\tif(!INPUT.isEmpty()) \n\t\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\tpublic static void main(String []args)throws Exception {\n\t\tnew Main().run();\n\t}\n\t\n\tprivate byte[]inbuf=new byte[1024];\n\tpublic int lenbuf=0,ptrbuf=0;\n\t\n\tprivate int readByte() {\n\t\tif(lenbuf==-1) throw new InputMismatchException();\n\t\tif(ptrbuf>=lenbuf) {\n\t\t\tptrbuf=0;\n\t\t\ttry {\n\t\t\t\tlenbuf=is.read(inbuf);\n\t\t\t}catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif(lenbuf<=0) return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\tprivate int ni() {\n\t\tint num=0,b;\n\t\tboolean minus=false;\n\t\twhile((b=readByte())!=-1&&!((b>='0'&&b<='9')||b=='-'))\n\t\t\t;\n\t\tif(b=='-') {\n\t\t\tminus=true;\n\t\t\tb=readByte();\n\t\t}\n\t\twhile(true) {\n\t\t\tif(b>='0'&&b<='9') {\n\t\t\t\tnum=num*10+(b-'0');\n\t\t\t}else {\n\t\t\t\treturn minus?-num:num;\n\t\t\t}\n\t\t\tb=readByte();\n\t\t}\n\t}\n\tprivate Integer [] na2(int n) {\n\t\tInteger []a=new Integer[n];\n\t\tfor(int i=0;i<n;i++) a[i]=ni();\n\t\treturn a;\n\t}\n\tprivate static void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "######################################################################\n# Write your code here\nimport sys\nimport math\ninput = sys.stdin.readline\n#import resource\n#resource.setrlimit(resource.RLIMIT_STACK, [0x10000000, resource.RLIM_INFINITY])\n#sys.setrecursionlimit(0x100000)\n# Write your code here\nRI = lambda : [int(x) for x in sys.stdin.readline().strip().split()]\nrw = lambda : input().strip().split()\n#from collections import defaultdict as df\nimport heapq \n#heapq.heapify(li) heappush(li,4) heappop(li)\n#import random\n#random.shuffle(list)\ninfinite = float('inf')\n#######################################################################\n\nn,I=RI()\n\nl=RI()\n\nd={}\n\nfor i in l:\n    if(i not in d):\n        d[i]=1\n    else:\n        d[i]+=1\n        \nsize=len(d)\n\nreqb=I*8\ntotalbitsperchar=reqb//n#bits\n\nmaxunique=2**totalbitsperchar\n\nelementstoremove=size-maxunique\n\nif(elementstoremove<=0):\n    print(0)\nelse:\n    #print(\"hi\")\n    h=[]\n    for i in d:\n        h.append(i)\n    h.sort()\n    s=len(h)\n    mini=0\n    for i in range(elementstoremove):\n        mini+=d[h[i]]\n    cur=mini\n    i=0\n    j=s\n    #print(mini)\n    while(i<=elementstoremove):\n        i+=1\n        j-=1\n        temp=cur-d[h[elementstoremove-i]]+d[h[j]]\n        cur=temp\n        mini=min(mini,temp)\n        #print(str(i)+\" \"+str(j))\n        #print(mini)\n    print(mini)\n\n"
        },
        {
            "language": 3,
            "solution": "n, I = map(int, input().split())\naudio_list = list(map(int, input().split()))\n\nK = pow(2, (8 * I) // n)\n\naudio_dict = {}\nfor el in audio_list:\n    if el not in audio_dict:\n        audio_dict[el] = 1\n    else:\n        audio_dict[el] += 1\n\naudio_keys = sorted(list(audio_dict.keys()))\naudio = [audio_dict[el] for el in audio_keys]\n\nif K >= len(audio):\n    print(0)\nelse:\n    count = len(audio) - K\n    result = temp = sum(audio[:count])\n    for i in range(count):\n        temp += (audio[~i] - audio[count - 1 - i])\n        if temp < result:\n            result = temp\n    print(result)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long arr[1000005];\nlong long pref[1000005], suff[1000005];\nvoid solve() {\n  long long n, I, i, x, l, r, ans;\n  cin >> n >> I;\n  map<long long, long long> m;\n  set<long long> s;\n  for (i = 0; i < n; i++) {\n    cin >> arr[i];\n    m[arr[i]]++;\n    s.insert(arr[i]);\n  }\n  vector<long long> v;\n  for (auto j : s) v.push_back(j);\n  for (i = 0; i < v.size(); i++) {\n    if (i)\n      pref[i] = pref[i - 1] + m[v[i]];\n    else\n      pref[i] = m[v[i]];\n  }\n  for (i = v.size() - 1; i >= 0; i--) {\n    suff[i] = suff[i + 1] + m[v[i]];\n  }\n  I = 8 * I;\n  I /= n;\n  if (I >= n) {\n    cout << 0 << '\\n';\n    return;\n  }\n  x = pow(2, I);\n  l = 0;\n  r = x - 1;\n  ans = LLONG_MAX;\n  if (x >= v.size()) {\n    cout << 0 << '\\n';\n    return;\n  } else {\n    while (l + x < v.size()) {\n      if (l + x >= v.size()) {\n        ans = min(ans, suff[v.size() - 1] + (l > 0 ? pref[l - 1] : 0));\n      } else\n        ans = min(ans, suff[l + x] + (l > 0 ? pref[l - 1] : 0));\n      l++;\n    }\n  }\n  cout << ans << '\\n';\n}\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  { solve(); }\n  cerr << \" Execution : \" << (1.0 * clock()) / CLOCKS_PER_SEC << \"s \\n\";\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict\nn,s = map(int,input().split())\nl = list(map(int,input().split()))\nl.sort()\nm = 2**(int(s*8/n))\nD = defaultdict(lambda:0)\nvalue = 0\nMax = 0\nnb = 0\nfor i in range(n):\n\tif D[l[i]] == 0 :\n\t\tD[l[i]] = 1\n\telse :\n\t\tD[l[i]] += 1\n\tnb +=1\n\twhile(len(D)>m) :\n\t\tif D[l[value]] == 1 :\n\t\t\tD.pop(l[value])\n\t\t\tnb -= 1\n\t\telse :\n\t\t\tD[l[value]] -=1\n\t\t\tnb -= 1\n\n\t\tvalue += 1\n\n\tMax = max(Max,nb) \n\n\nprint(n-Max)\n\n\n"
        },
        {
            "language": 3,
            "solution": "import sys\nimport os\nfrom io import BytesIO, IOBase\n\n#########################\n# imgur.com/Pkt7iIf.png #\n#########################\n\n# returns the list of prime numbers less than or equal to n:\n'''def sieve(n):\n    if n < 2: return list()\n    prime = [True for _ in range(n + 1)]\n    p = 3\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 2\n    r = [2]\n    for p in range(3, n + 1, 2):\n        if prime[p]:\n            r.append(p)\n    return r'''\n\n# returns all the divisors of a number n(takes an additional parameter start):\n'''def divs(n, start=1):\n    divisors = []\n    for i in range(start, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            if n / i == i:\n                divisors.append(i)\n            else:\n                divisors.extend([i, n // i])\n    return divisors'''\n\n# returns the number of factors of a given number if a primes list is given:\n'''def divn(n, primes):\n    divs_number = 1\n    for i in primes:\n        if n == 1:\n            return divs_number\n        t = 1\n        while n % i == 0:\n            t += 1\n            n //= i\n        divs_number *= t\n    return divs_number'''\n\n# returns the leftmost and rightmost positions of x in a given list d(if x isnot present then returns (-1,-1)):\n'''def flin(d, x, default=-1):\n    left = right = -1\n    for i in range(len(d)):\n        if d[i] == x:\n            if left == -1: left = i\n            right = i\n    if left == -1:\n        return (default, default)\n    else:\n        return (left, right)'''\n\n# returns (b**p)%m \n'''def modpow(b,p,m):\n    res=1\n    b=b%m\n    while(p):\n        if p&1:\n            res=(res*b)%m\n        b=(b*b)%m\n        p>>=1\n    return res'''\n\n# if m is a prime this can be used to determine (1//a)%m or modular multiplicative inverse of a number a\n'''def mod_inv(a,m):\n    return modpow(a,m-2,m)'''\n\n# returns the ncr%m for (if m is a prime number) for very large n and r\n'''def ncr(n,r,m):\n    res=1\n    if r==0:\n        return 1\n    if n-r<r:\n        r=n-r\n    p,k=1,1\n    while(r):\n        res=((res%m)*(((n%m)*mod_inv(r,m))%m))%m\n        n-=1\n        r-=1\n    return res'''\n\n# returns ncr%m (if m is a prime number and there should be a list fact which stores the factorial values upto n):\n'''def ncrlis(n,r,m):\n    return (fact[n]*(mod_inv(fact[r],m)*mod_inv(fact[n-r],m))%m)%m'''\n\n#factorial list which stores factorial of values upto n:\n'''mx_lmt=10**5+10\nfact=[1 for i in range(mx_lmt)]\nfor i in range(1,mx_lmt):\n    fact[i]=(i*fact[i-1])%mod'''\n\n#count xor of numbers from 1 to n:\n'''def xor1_n(n):\n    d={0:n,1:1,2:n+1,3:0}\n    return d[n&3]'''\n\ndef cel(n, k): return n // k + (n % k != 0)\ndef ii(): return int(input())\ndef mi(): return map(int, input().split())\ndef li(): return list(map(int, input().split()))\ndef lcm(a, b): return abs(a * b) // math.gcd(a, b)\ndef prr(a, sep=' '): print(sep.join(map(str, a)))\ndef dd(): return defaultdict(int)\ndef ddl(): return defaultdict(list)\ndef ddd(): return defaultdict(defaultdict(int))\n \n\n# region fastio\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n\tnewlines = 0\n \n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = \"x\" in file.mode or \"r\" not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n \n\tdef read(self):\n\t\t\twhile True:\n\t\t\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\t\t\tif not b:\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\tptr = self.buffer.tell()\n\t\t\t\t\tself.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n\t\t\tself.newlines = 0\n\t\t\treturn self.buffer.read()\n \n\tdef readline(self):\n\t\t\twhile self.newlines == 0:\n\t\t\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\t\t\tself.newlines = b.count(b\"\\n\") + (not b)\n\t\t\t\t\tptr = self.buffer.tell()\n\t\t\t\t\tself.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n\t\t\tself.newlines -= 1\n\t\t\treturn self.buffer.readline()\n \n\tdef flush(self):\n\t\t\tif self.writable:\n\t\t\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t\t\tself.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n\tdef __init__(self, file):\n\t\t\tself.buffer = FastIO(file)\n\t\t\tself.flush = self.buffer.flush\n\t\t\tself.writable = self.buffer.writable\n\t\t\tself.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n\t\t\tself.read = lambda: self.buffer.read().decode(\"ascii\")\n\t\t\tself.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom collections import defaultdict \n#from collections import deque\n#from collections import OrderedDict\nfrom math import gcd,log2,ceil\n#import time\n#import itertools\n#import timeit\n#import random\n#from bisect import bisect_left as bl\n#from bisect import bisect_right as br\n#from bisect import insort_left as il\n#from bisect import insort_right as ir\n#from heapq import *\n#mod=998244353\n#mod=10**9+7\n\nfor _ in range(1):\n    n,its=mi()\n    a=li()\n    s=sorted(set(a))\n    s=list(s)\n    if n*ceil(log2(len(s)))<=8*its:\n        print(0)\n        continue\n    d=dd()\n    for i in range(n):\n        d[a[i]]+=1\n    k=2**((8*its)//n)\n    prfx=[0 for i in range(len(s)+1)]\n    for i in range(1,len(prfx)):\n        prfx[i]=prfx[i-1]+d[s[i-1]]\n    mx=0\n    for i in range(len(prfx)-1,k-1,-1):\n        mx=max(prfx[i]-prfx[i-k],mx)\n    print(n-mx)"
        },
        {
            "language": 3,
            "solution": "from collections import Counter, deque\nfrom math import log2\n\nn, I = map(int, input().split())\ndebug = False\n\nmp3 = list(map(int, input().split()))\nassert n == len(mp3)\nif n == 0:\n    print(0)\n    exit(0)\n\nmp3 = sorted(mp3)\n\n\nbts_avail = I*8 // n\n\nif debug:\n    diff = mp3[-1] - mp3[0]\n    bits = 0\n    pwr2 = 1\n    while pwr2 < diff:\n        bits += 1\n        pwr2 <<= 1\n\n\n    print('diff: {}'.format(diff))\n    print('pwr2: {}'.format(pwr2))\n    print('bits: {}'.format(bits))\n    print('bts_avail: {}'.format(bts_avail))\n    print('rng: {}'.format(rng))\n\n\nmax_range = 0\n# your implementation here\nwindow = deque()\nwrng = 0\nfor Ampl, freq in Counter(mp3).items():\n    window.append(freq)\n    wrng += freq\n    if wrng > max_range:\n        max_range = wrng\n    if (log2(len(window)) == bts_avail):\n        wrng -= window.popleft()\n\n\n\nprint(n - max_range)\n\n"
        },
        {
            "language": 3,
            "solution": "import math\nM = 10**9 + 7\nR = lambda: map(int, input().split())\nn,I = R()\nL = sorted(R())\nk = (I*8)//n\nd = []\ni = 0\nj = 0\nwhile i < n:\n    j = i\n    t = L[i]\n    i += 1\n    while i < n and L[i] == t:\n        i += 1\n    d.append([j,i-1])\n#print(d)\nk = 2**k\nres = n\n#print(k)\nfor i in range(len(d)):\n    p = min(k+i-1,len(d)-1)\n    #print(i,p)\n    res = min(res,n-(d[p][1]-d[i][0]+1))\nprint(res)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  char ch = getchar();\n  int nega = 1;\n  while (!isdigit(ch)) {\n    if (ch == '-') nega = -1;\n    ch = getchar();\n  }\n  int ans = 0;\n  while (isdigit(ch)) {\n    ans = ans * 10 + ch - 48;\n    ch = getchar();\n  }\n  if (nega == -1) return -ans;\n  return ans;\n}\nint a[400005];\nint b[400005], cnt[400005];\nint n, I;\nint pre[400005 * 2];\nint suf[400005 * 2];\nint sum[400005 * 2];\nsigned main() {\n  cin >> n >> I;\n  for (int i = 1; i <= n; i++) a[i] = read(), b[i] = a[i];\n  sort(b + 1, b + n + 1);\n  int q = unique(b + 1, b + n + 1) - b - 1;\n  for (int i = 1; i <= n; i++) {\n    a[i] = lower_bound(b + 1, b + q + 1, a[i]) - b;\n    cnt[a[i]]++;\n  }\n  int K = I * 8 / n;\n  if (K >= 20) {\n    cout << \"0\\n\";\n    return 0;\n  }\n  int len = 1, ans = n;\n  for (int i = 1; i <= K; i++) len *= 2;\n  if (len >= q) {\n    cout << \"0\\n\";\n    return 0;\n  }\n  for (int i = 1; i <= q; i++) pre[i] = pre[i - 1] + cnt[i];\n  for (int i = q; i >= 1; i--) suf[i] = suf[i + 1] + cnt[i];\n  for (int i = 1; i <= q - len + 1; i++) {\n    if (ans > suf[i + len] + pre[i - 1]) ans = suf[i + len] + pre[i - 1];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 2147000000;\nconst int maxn = 4e5 + 10;\nconst int mod = 998244353;\nint n, I;\nint a[maxn];\nint sum[maxn];\nint main() {\n  scanf(\"%d%d\", &n, &I);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  sort(a + 1, a + 1 + n);\n  for (int i = 1; i <= n; i++) {\n    sum[i] = sum[i - 1];\n    if (a[i] != a[i - 1]) sum[i]++;\n  }\n  int z = 8 * I / n;\n  int ans = 0;\n  if (z <= 20) {\n    int K = 1 << z;\n    if (sum[n] > K) {\n      int l = 1, r = 1;\n      ans = INF;\n      int num = 1;\n      while (l <= r && r <= n) {\n        while (r <= n && num <= K) {\n          ans = min(ans, l - 1 + n - r);\n          r++;\n          if (a[r] != a[r - 1]) num++;\n        }\n        while (l <= r && num > K) {\n          l++;\n          if (a[l] != a[l - 1]) num--;\n        }\n      }\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmap<long long, long long> mp;\nvector<long long> v;\nlong long arr[1000000];\nint32_t main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long n, t;\n  cin >> n >> t;\n  long long x = 1;\n  for (long long i = 0; i < (t * 8) / n; i++) {\n    x *= 2;\n    if (x >= 10000000000) {\n      x = 10000000000;\n      break;\n    }\n  }\n  long long a[n];\n  for (long long i = 0; i < n; i++) {\n    cin >> a[i];\n    mp[a[i]]++;\n  }\n  sort(a, a + n);\n  long long cnt = 1;\n  v.push_back(a[0]);\n  for (long long i = 1; i < n; i++) {\n    if (v[v.size() - 1] != a[i]) {\n      v.push_back(a[i]);\n      cnt++;\n    }\n  }\n  if (x >= cnt) {\n    cout << 0;\n    return 0;\n  }\n  long long sum = 0;\n  for (long long i = 0; i < cnt; i++) {\n    sum += mp[v[i]];\n    arr[i + 1] = arr[i] + mp[v[i]];\n  }\n  long long minn = 100000000000;\n  for (long long i = 0; i <= cnt - x; i++) {\n    minn = min(minn, arr[i] + (sum - arr[i + x]));\n  }\n  cout << minn;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\nfrom math import *\nline1 = input()\n\nl,r = line1.split()\nl = int(l)\nr = int(r)\narr = list(map(int, input().split()))\n\ncounts = []\nelems = []\narr = sorted(arr)\n\n\nelems.append(-1)\ncounts.append(0)\nfor elem in arr:\n\tif elem == elems[-1]:\n\t\tcounts[-1]+=1\n\telse:\n\t\telems.append(elem)\n\t\tcounts.append(1)\nelems = elems[1:]\ncounts = counts[1:]\n\nK = len(counts)\nk = 8*r//l\nN = 2**k\nD = K-N\n\ncounts1 = counts\ncounts2 = counts.copy()\n\nfor k in range(1,len(counts1)):\n\tcounts1[k]+=counts1[k-1]\n\tcounts2[len(counts2)-1-k]+=counts2[len(counts2)-k]\n\ncounts1 = [0] + counts1\ncounts2 = counts2 + [0]\n\nif D <= 0:\n\ts = 0\nelse:\n\ts = 2*(10**9)\n\tfor i in range(D):\n\t\ts = min(s,counts1[i]+counts2[len(counts2)+i-1-D])\n\nprint(s)\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long log_2(long long x) {\n  long long res = 0;\n  long long now = 1;\n  while (x > now) {\n    now *= 2;\n    ++res;\n  }\n  return res;\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  long long n, I;\n  cin >> n >> I;\n  vector<long long> a(n);\n  set<long long> st;\n  for (long long i = 0; i < n; ++i) {\n    cin >> a[i];\n    st.insert(a[i]);\n  }\n  if (n * log_2(st.size()) <= 8 * I) {\n    cout << 0 << '\\n';\n    return 0;\n  }\n  sort(a.begin(), a.end());\n  long long cnt = 1;\n  vector<long long> v;\n  for (long long i = 0; i < n; ++i) {\n    if (i == n - 1)\n      v.push_back(cnt);\n    else if (a[i] == a[i + 1])\n      ++cnt;\n    else {\n      v.push_back(cnt);\n      cnt = 1;\n    }\n  }\n  long long m = v.size();\n  vector<long long> sum(m);\n  for (long long i = 0; i < m; ++i) {\n    if (i) {\n      sum[i] = sum[i - 1] + v[i];\n    } else {\n      sum[i] = v[i];\n    }\n  }\n  long long num = I * 8;\n  long long maximum = 0;\n  while (n * (log_2(maximum)) <= 8 * I) {\n    ++maximum;\n  }\n  long long ans = 1e18;\n  for (long long i = 0; i + maximum - 2 < m; ++i) {\n    if (i + maximum - 2 < 0) {\n      continue;\n    } else if (i) {\n      ans = min(ans, sum[m - 1] - sum[i + maximum - 2] + sum[i - 1]);\n    } else {\n      ans = min(ans, sum[m - 1] - sum[i + maximum - 2]);\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 500000;\nint a[maxn], b[maxn];\npair<int, int> v[maxn];\nint n, I;\nsigned main() {\n  cin >> n >> I;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  if (8 * I / n >= 30) {\n    cout << 0;\n    return 0;\n  }\n  sort(a, a + n);\n  int p1 = 0, p2 = 0;\n  int cr = 1;\n  int mr = 0;\n  while (n * mr <= 8 * I) ++mr;\n  --mr;\n  mr = (1 << mr);\n  int ans = 0;\n  while (p2 < n - 1) {\n    ++p2;\n    if (a[p2] != a[p2 - 1]) ++cr;\n    if (cr > mr) {\n      while (cr > mr) {\n        ++p1;\n        if (a[p1] != a[p1 - 1]) --cr;\n      }\n    }\n    ans = max(ans, p2 - p1);\n  }\n  cout << n - ans - 1;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from math import *\nn,I = map(int,input().split())\na = sorted(list(map(int,input().split())))\nI *= 8\nnow = 0\nctr = 1\nans = float('INF')\nfor i in range(n):\n    if i != 0 and a[i] != a[i-1] and now >= i:ctr -= 1\n    if now < i:\n        now = i\n        ctr = 1\n    ctr = max(ctr,1)\n    while now != n-1 and ((a[now+1] != a[now] and ceil(log2(ctr+1))*n <= I) or (a[now+1] == a[now] and ceil(log2(ctr))*n <= I)):\n        if a[now+1] != a[now]:ctr += 1\n        now += 1\n    ans = min(ans,i + n - now - 1)\nprint(ans)\n"
        },
        {
            "language": 3,
            "solution": "N, I = map(int, input().split())\nA = sorted([int(a) for a in input().split()])\nB = []\nj = 0\nfor i in range(N):\n    if i == 0 or A[i] == A[i-1]:\n        B.append(j)\n    else:\n        j += 1\n        B.append(j)\n\ndef calc(k):\n    K = 1<<k\n    i = 0\n    j = 0\n    ma = 0\n    while j < N:\n        if B[j]-B[i] <= K - 1:\n            ma = max(ma, j-i+1)\n            j += 1\n        else:\n            i += 1\n    return N-ma\n\nans = 10**100\nfor i in range(31):\n    if i * N <= 8 * I:\n        ans = min(ans, calc(i))\n\nprint(ans)\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int n, s;\n  cin >> n >> s;\n  int a[n];\n  map<int, int> m;\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n    m[a[i]]++;\n  }\n  int dis = m.size();\n  auto i = m.begin();\n  vector<int> v;\n  while (i != m.end()) {\n    v.push_back(i->second);\n    i++;\n  }\n  s = s * 8;\n  s = s / n;\n  if (s > 20) {\n    cout << 0;\n    return 0;\n  }\n  s = pow(2, s);\n  if (s >= dis) {\n    cout << 0;\n    return 0;\n  }\n  long long int sum = 0;\n  long long int summi[v.size() + 1];\n  summi[0] = 0;\n  for (int i = 1; i <= v.size(); i++) {\n    summi[i] = 0;\n    summi[i] = summi[i - 1] + v[i - 1];\n  }\n  for (int i = 1; i <= v.size() - s + 1; i++) {\n    long long int kkk = summi[i + s - 1] - summi[i - 1];\n    if (sum < kkk) sum = kkk;\n  }\n  cout << n - sum;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = (long long)1e9 + 7;\nint n, I, len;\nmap<int, int> mp;\nvector<int> a;\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> I;\n  a.resize(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    mp[a[i]]++;\n  }\n  sort(a.begin(), a.end());\n  a.resize(unique(a.begin(), a.end()) - a.begin());\n  int tmp = (8 * I) / n;\n  int sz = a.size();\n  int cnt = 0, cur = 1;\n  while (1) {\n    if (cur >= sz) break;\n    cur = cur << 1;\n    cnt++;\n  }\n  if (tmp >= cnt) {\n    cout << 0 << \"\\n\";\n  } else {\n    int ans = 0;\n    int pre = 0, z = 0;\n    int cnt = 0;\n    cnt += mp[a[0]];\n    long long L = (1LL << tmp);\n    while (1) {\n      while (z + 1 < sz && z + 1 - pre + 1 <= L) {\n        z++;\n        cnt += mp[a[z]];\n      }\n      ans = max(ans, cnt);\n      if (z == sz - 1) break;\n      cnt -= mp[a[pre]];\n      pre++;\n    }\n    cout << n - ans << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys, os, io\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math,datetime,functools,itertools,operator,bisect,fractions,statistics\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest\n\ndef main():\n    # mod=1000000007\n    # InverseofNumber(mod)\n    # InverseofFactorial(mod)\n    # factorial(mod)\n    starttime=datetime.datetime.now()\n    if(os.path.exists('input.txt')):\n        sys.stdin = open(\"input.txt\",\"r\")\n        sys.stdout = open(\"output.txt\",\"w\")\n    \n    tc=1\n    for _ in range(tc):\n        n,I=ria()\n        a=ria()\n        d=Counter(a)\n        a=(sorted(list(set(a))))\n        limit=I*8\n        g=len(d)\n        while True:\n            k=math.ceil(math.log2(g)) \n            now=n*k\n            if now<=limit:\n                break\n            g-=1\n        pres=[0]\n        prevn=n\n        n=len(a)\n        for i in a:\n            pres.append(pres[-1]+d[i])\n    \n        ans=0\n        for i in range(g,n+1):\n            ans=max(ans,pres[i]-pres[i-g])\n        print(prevn-ans)             \n            \n            \n        \n                    \n        \n        \n        \n                \n                \n        \n            \n            \n            \n        \n\n                    \n        \n                \n        \n        \n                        \n        \n                            \n\n        \n\n                \n            \n        \n\n                \n            \n                    \n                \n                \n        \n        \n         \n        \n\n                        \n                            \n                \n        \n                            \n                    \n\n                \n            \n        \n                \n            \n                \n        \n        \n        \n                             \n        \n            \n        \n        \n            \n                        \n                        \n                    \n            \n        \n        \n        \n        \n        \n                        \n       \n\n        \n                           \n        \n        \n        \n            \n        \n        \n        \n                      \n\n      \n                            \n            \n        \n        \n            \n            \n            \n            \n            \n        \n        \n        \n            \n        \n        \n        \n            \n        \n        \n        \n        \n            \n            \n        \n        \n        \n        \n        \n        \n        \n                \n                \n                    \n        \n        \n            \n            \n        \n                \n            \n            \n        \n        \n        \n        \n                \n        \n            \n        \n                \n        \n        \n            \n        \n       \n            \n\n                \n        \n        \n        \n   \n            \n        \n        \n        \n        \n            \n        \n                \n        \n        \n        \n            \n            \n        \n        \n            \n        \n        \n\n        \n        \n            \n        \n        \n            \n        \n                        \n\n        \n        \n            \n     \n        \n        \n            \n        \n        \n                \n            \n        \n        \n        \n                \n            \n        \n\n            \n             \n        \n            \n        \n        \n        \n                \n        \n            \n        \n        \n        \n        \n                \n        \n        \n            \n        \n        \n        \n        \n                \n        \n    #<--Solving Area Ends\n    endtime=datetime.datetime.now()\n    time=(endtime-starttime).total_seconds()*1000\n    if(os.path.exists('input.txt')):\n        print(\"Time:\",time,\"ms\")  \n    \n                \nclass FastReader(io.IOBase):\n    newlines = 0\n\n    def __init__(self, fd, chunk_size=1024 * 8):\n        self._fd = fd\n        self._chunk_size = chunk_size\n        self.buffer = io.BytesIO()\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self, size=-1):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n\nclass FastWriter(io.IOBase):\n\n    def __init__(self, fd):\n        self._fd = fd\n        self.buffer = io.BytesIO()\n        self.write = self.buffer.write\n\n    def flush(self):\n        os.write(self._fd, self.buffer.getvalue())\n        self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass FastStdin(io.IOBase):\n    def __init__(self, fd=0):\n        self.buffer = FastReader(fd)\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nclass FastStdout(io.IOBase):\n    def __init__(self, fd=1):\n        self.buffer = FastWriter(fd)\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.flush = self.buffer.flush\n\n\nif __name__ == '__main__':\n    sys.stdin = FastStdin()\n    sys.stdout = FastStdout()\n    main()\n    "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nlong long qpow(long long a, long long b) {\n  long long res = 1;\n  while (b) {\n    if (b & 1) res = res * a;\n    b >>= 1;\n    a = a * a;\n  }\n  return res;\n}\nint a[500005];\nint main() {\n  int n, k;\n  cin >> n >> k;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n  }\n  sort(a + 1, a + n + 1);\n  k = 8 * k / n;\n  if (k >= ceil(log(n) / log(2))) {\n    cout << 0;\n    return 0;\n  }\n  long long q = pow(2, k);\n  int min1 = n;\n  int sum = 0;\n  for (int l = 1, r = 1; r <= n && l <= n;) {\n    while (r < n && a[r] == a[r + 1]) r++;\n    sum++;\n    if (sum == q) {\n      min1 = min(min1, n - (r - l + 1)), sum--;\n      while (l < n && a[l] == a[l + 1]) l++;\n      l++;\n    }\n    r++;\n  }\n  if (min1 == n)\n    cout << 0;\n  else\n    cout << min1;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nusing namespace std;\nconst int N = 1e6 + 5, M = 1e4 + 5;\nint a[N], powe[N];\nint main() {\n  long long n;\n  long long I;\n  scanf(\"%lld%lld\", &n, &I);\n  I *= 8ll;\n  long long kam = I / n;\n  map<int, int> mp;\n  for (int i = 0; i < n; ++i) {\n    int x;\n    scanf(\"%d\", &x);\n    ++mp[x];\n  }\n  vector<int> v;\n  for (auto i : mp) v.push_back(i.second);\n  for (int i = 1; i < N; ++i) powe[i] = powe[i >> 1] + 1;\n  long long ans = 0, mn = 1e18;\n  for (int i = 0, j = 0; i < v.size(); ++i) {\n    while (j < v.size() && n * powe[j - i] <= I) {\n      ans += v[j++];\n      mn = min(mn, n - ans);\n    }\n    ans -= v[i];\n  }\n  printf(\"%lld\\n\", mn);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Ribhav\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CMP3 solver = new CMP3();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CMP3 {\n        public void solve(int testNumber, FastReader s, PrintWriter out) {\n            int n = s.nextInt();\n            long I = s.nextLong();\n            int[] arr = s.nextIntArray(n);\n            I *= 8L;\n            long k = I / n;\n            HashMap<Integer, Integer> map = new HashMap<>();\n            for (int i = 0; i < n; i++) {\n                map.put(arr[i], map.getOrDefault(arr[i], 0) + 1);\n            }\n\n\n            ArrayList<Integer> keys = new ArrayList<>(map.keySet());\n            CMP3.pair[] pairArr = new CMP3.pair[keys.size()];\n            for (int i = 0; i < keys.size(); i++) {\n                pairArr[i] = new CMP3.pair(keys.get(i), map.get(keys.get(i)));\n            }\n\n            Arrays.sort(pairArr);\n            int totalElements = 0;\n            int i = 0;\n            int j = 0;\n            int count = 0;\n            while (j < pairArr.length) {\n                while (i <= j && j < pairArr.length && Math.log(j - i) / Math.log(2) <= k) {\n                    count += pairArr[j].freq;\n                    j++;\n                }\n\n                if (Math.log(j - i) / Math.log(2) > k) {\n                    count -= pairArr[i].freq;\n                    totalElements = Math.max(totalElements, count);\n                    i++;\n                } else {\n                    totalElements = Math.max(totalElements, count);\n                }\n            }\n            out.println(n - totalElements);\n        }\n\n        private static class pair implements Comparable<CMP3.pair> {\n            int val;\n            int freq;\n\n            public pair(int val, int freq) {\n                this.val = val;\n                this.freq = freq;\n            }\n\n            public int compareTo(CMP3.pair o) {\n                return Integer.compare(this.val, o.val);\n            }\n\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private FastReader.SpaceCharFilter filter;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] array = new int[n];\n            for (int i = 0; i < n; ++i) array[i] = nextInt();\n            return array;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5e5 + 5;\nint main() {\n  long long int n, I, ans = 0;\n  cin >> n >> I;\n  long long int a[n];\n  long long int count = 0;\n  map<long long int, long long int> mp;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  sort(a + 1, a + n + 1);\n  for (long long int i = 1, j = 1; i <= n; i++) {\n    mp[a[i]]++;\n    if (mp[a[i]] == 1) count++;\n    while (n * ((int)ceil(log2(count))) > 8 * I) {\n      mp[a[j]]--;\n      if (mp[a[j]] == 0) count--;\n      j++;\n    }\n    ans = max(ans, i - j + 1);\n  }\n  cout << n - ans;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class Main\n{\n    static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    }\n    static final long mod=998244353;\n    public static void main(String args[])throws Exception\n    {\n        FastReader fs=new FastReader();\n        PrintWriter pw=new PrintWriter(System.out);\n        int n=fs.nextInt();\n        int I=fs.nextInt()*8;\n        int a[]=new int[n];\n        for(int i=0;i<n;i++)\n        a[i]=fs.nextInt();\n        TreeMap<Integer,Integer> tmap=new TreeMap<>();\n        for(int i=0;i<n;i++)\n        tmap.put(a[i],tmap.getOrDefault(a[i],0)+1);\n        int in=-1;\n        for(Map.Entry<Integer,Integer> me:tmap.entrySet())\n        {\n            for(int i=0;i<me.getValue();i++)\n            a[++in]=me.getKey();\n        }\n        TreeSet<Integer> hs=new TreeSet<>();\n        for(int i=0;i<n;i++)\n        hs.add(a[i]);\n        int K=n*(int)Math.ceil(Math.log(hs.size())/Math.log(2));\n        if(K<=I)\n        pw.println(0);\n        else\n        {\n            int k=I/n;\n            k=(int)Math.pow(2,k);\n            ArrayList<Integer> list=new ArrayList<>();\n            for(int i=1;i<n;i++)\n            {\n                if(a[i]!=a[i-1])\n                list.add(i-1);\n            }\n            list.add(n-1);\n            int min=n-(list.get(k-1)+1);\n            for(int i=k;i<list.size();i++)\n            min=Math.min(min,list.get(i-k)+n-list.get(i));\n            pw.println(min);\n        }\n        pw.flush();\n        pw.close();\n    }\n}"
        },
        {
            "language": 3,
            "solution": "R=lambda:map(int,input().split())\nn,I=R()\na=sorted(R())\nb=[0]+[i+1for i in range(n-1)if a[i]<a[i+1]]\nprint(n-max((y-x for x,y in zip(b,b[1<<8*I//n:])),default=n))"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.Collections;\nimport java.util.ArrayList;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CMP3 solver = new CMP3();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CMP3 {\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int n = in.nextInt(), Ibits = in.nextInt() * 8;\n            List<Integer> a = new ArrayList<>();\n\n            for (int i = 0; i < n; i++) {\n                a.add(in.nextInt());\n            }\n            Collections.sort(a);\n\n            int bitsAvbl = Ibits / n;\n            if (bitsAvbl > 20) {\n                out.println(0);\n                return;\n            }\n            int uniqAvblNum = pow(bitsAvbl);\n\n            List<Integer> uniquea = new ArrayList<>();\n            List<Integer> count = new ArrayList<>();\n            int temp = 0, ct = 0;\n            int prev = a.get(0);\n            for (int i = 0; i < n; i++) {\n                if (prev != a.get(i)) {\n                    uniquea.add(prev);\n                    count.add(temp + ct);\n                    temp += ct;\n                    ct = 0;\n                }\n                ct++;\n                prev = a.get(i);\n            }\n            uniquea.add(prev);\n            count.add(temp + ct);\n\n            if (uniqAvblNum >= uniquea.size()) {\n                out.println(0);\n                return;\n            }\n            //System.out.println(uniquea);\n            //System.out.println(count);\n\n            int ans = Integer.MAX_VALUE, r, clippedNumbers;\n\n            for (int l = 0; l <= uniquea.size() - uniqAvblNum; l++) {\n                r = l + uniqAvblNum - 1;\n                clippedNumbers = 0;\n                if (l > 0) {\n                    clippedNumbers += count.get(l - 1);\n                }\n                clippedNumbers += (n - count.get(r));\n                ans = Integer.min(ans, clippedNumbers);\n            }\n            out.println(ans);\n        }\n\n        private static int pow(int x) {\n            if (x == 0)\n                return 1;\n            return 2 * pow(x - 1);\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long n, I;\n  cin >> n >> I;\n  map<long long, long long> mp;\n  for (long long i = 0; i < n; i++) {\n    long long x;\n    cin >> x;\n    mp[x]++;\n  }\n  if (ceil(log2(mp.size())) * n <= I * 8) {\n    cout << 0;\n    return 0;\n  }\n  vector<long long> v(mp.size() + 1);\n  long long j = 1;\n  v[0] = 0;\n  for (auto i = mp.begin(); i != mp.end(); i++) {\n    v[j] = v[j - 1] + i->second;\n    j++;\n  }\n  long long x = pow(2, (I * 8) / n);\n  long long max_int = 0;\n  for (long long i = 0; i < v.size() - x; i++) {\n    max_int = max(max_int, v[i + x] - v[i]);\n  }\n  cout << n - max_int;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nfrom collections import defaultdict as dd\n\npl=1\nfrom math import *\nimport copy\n#sys.setrecursionlimit(10**6)\nif pl:\n\tinput=sys.stdin.readline\nelse:\t\n\tsys.stdin=open('input.txt', 'r')\n\tsys.stdout=open('all.txt','w')\ndef li():\n\treturn [int(xxx) for xxx in input().split()]\ndef fi():\n\treturn int(input())\ndef si():\n\treturn list(input().rstrip())\t\ndef mi():\n\treturn \tmap(int,input().split())\t\n \n\nd=[]\t\t\nfrom bisect import *\t\t\n\nfrom itertools import permutations \nfrom bisect import *\n\t\t\t\nn,I=mi()\na=li()\nK=8*I//n\nk=2**K\nl=0\nr=max(a)+1\ngg=n\na.sort()\nd=[]\ni=0\nwhile i<n:\n\tj=i\n\twhile i<n and a[i]==a[j]:\n\t\ti+=1\n\td.append(i-j)\npre=[0,d[0]]\nfor i in range(1,len(d)):\n\tpre.append(pre[-1]+d[i])\n#print(pre)\t\nfor i in range(1,len(pre)):\n\tif i+k>=len(pre):\n\t\tgg=min(gg,pre[i-1])\n\telse:\t\n\t\tgg=min(gg,pre[i-1]+pre[-1]-pre[i+k-1])\nprint(gg)\t"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long n, I;\n  cin >> n >> I;\n  map<int, int> mp;\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    mp[x]++;\n  }\n  vector<pair<int, int>> vec;\n  for (auto i : mp) vec.push_back(i);\n  long long k = (8 * I) / n;\n  if (k > 33) {\n    cout << 0 << endl;\n    return 0;\n  }\n  long long d = pow(2, k);\n  if (vec.size() <= d) {\n    cout << 0 << endl;\n    return 0;\n  }\n  int included = 0;\n  for (int i = 0; i < d; i++) {\n    included += vec[i].second;\n  }\n  int ms = included;\n  for (int j = d; j < vec.size(); j++) {\n    included -= vec[j - d].second;\n    included += vec[j].second;\n    ms = max(included, ms);\n  }\n  cout << n - ms << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC push_options\n#pragma GCC optimize(\"unroll-loops\")\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long n, b;\n  cin >> n >> b;\n  map<long long, long long> m;\n  for (int i = 0; i < n; i++) {\n    long long temp;\n    cin >> temp;\n    m[temp]++;\n  }\n  b = b * 8;\n  long long k1 = b / n;\n  if (k1 >= 32) {\n    cout << 0 << \"\\n\";\n    return 0;\n  }\n  long long k = pow(2, k1);\n  if (m.size() <= k)\n    cout << 0 << \"\\n\";\n  else {\n    vector<long long> v;\n    for (auto it = m.begin(); it != m.end(); it++) v.emplace_back(it->second);\n    long long sum = 0ll;\n    for (int i = 0; i < k; i++) {\n      sum += v[i];\n    }\n    long long maxVal = sum;\n    for (int i = k; i < v.size(); i++) {\n      sum = sum + v[i] - v[i - k];\n      maxVal = max(maxVal, sum);\n    }\n    cout << n - maxVal << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "\ndef naiveSolve(n):\n    \n    \n    \n    return\n\n\n\ndef main():\n    \n    n,I=readIntArr()\n    a=readIntArr()\n    \n    k=(8*I)//n\n    K=pow(2,k)\n    \n    a.sort()\n    # coordinate compress since we only care about distinct values\n    b=[0]*n\n    v=0\n    for i in range(n):\n        if i-1>=0 and a[i]>a[i-1]:\n            v+=1\n        b[i]=v\n    a=b\n    \n    ans=inf\n    r=-1\n    for l in range(n):\n        lower=a[l]\n        upper=K+lower-1\n        while r+1<n and a[r+1]<=upper:\n            r+=1\n        ans=min(ans,l+n-1-r)\n    print(ans)\n\n    \n    return\n\n\nimport sys\ninput=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\n# input=lambda: sys.stdin.readline().rstrip(\"\\r\\n\") #FOR READING STRING/TEXT INPUTS.\n\ndef oneLineArrayPrint(arr):\n    print(' '.join([str(x) for x in arr]))\ndef multiLineArrayPrint(arr):\n    print('\\n'.join([str(x) for x in arr]))\ndef multiLineArrayOfArraysPrint(arr):\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\n \ndef readIntArr():\n    return [int(x) for x in input().split()]\n# def readFloatArr():\n#     return [float(x) for x in input().split()]\n \ndef makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])\n    dv=defaultValFactory;da=dimensionArr\n    if len(da)==1:return [dv() for _ in range(da[0])]\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\n \ndef queryInteractive(l,r):\n    print('? {} {}'.format(l,r))\n    sys.stdout.flush()\n    return int(input())\n \ndef answerInteractive(x):\n    print('! {}'.format(x))\n    sys.stdout.flush()\n \ninf=float('inf')\nMOD=10**9+7\n# MOD=998244353\n\nfrom math import gcd,floor,ceil\n \nfor _abc in range(1):\n    main()\n"
        },
        {
            "language": 4,
            "solution": "import java.awt.*;\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\npublic class Main {\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer st = new StringTokenizer(\"\");\n    PrintWriter pw = new PrintWriter(System.out);\n\n    public Main() throws FileNotFoundException {\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    String next() throws IOException {\n        if (!st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    public static void main(String[] args) throws IOException {\n        new Main().run();\n    }\n\n    void run() throws IOException {\n        int n = nextInt();\n        int i = nextInt() * 8;\n        int k = i / n;\n        int r = 0;\n        int K = 1;\n        int[] a = new int[n];\n        HashMap<Integer, Integer> ts = new HashMap<>();\n        for (int j = 0; j < n; j++) {\n            int e = nextInt();\n            if (!ts.containsKey(e))\n                a[j] = e;\n            ts.put(e, ts.getOrDefault(e, 0) + 1);\n        }\n        int size = ts.size();\n        Arrays.sort(a);\n        int u = 0;\n        while (a[u] == 0) u++;\n        while (r < k) {\n            K *= 2;\n            r++;\n            if (K >= ts.size()) {\n                pw.println(0);\n                pw.close();\n                return;\n            }\n        }\n        int[] sum = new int[size + 1];\n        for (int j = 0; j < size; j++) {\n            sum[j + 1] = sum[j] + ts.get(a[j + u]);\n        }\n        int ans = Integer.MAX_VALUE;\n        for (int j = 0; j < size - K + 1; j++) {\n            ans = min(ans, sum[size] - sum[j + K] + sum[j]);\n        }\n        pw.print(ans);\n        pw.close();\n    }\n\n    class Pair {\n        long ves;\n        int from, to;\n\n        public Pair(long a, int c, int b) {\n            ves = a;\n            from = c;\n            to = b;\n        }\n    }\n\n    static class PairComp implements Comparator<Pair> {\n\n        @Override\n        public int compare(Pair o1, Pair o2) {\n            return Long.compare(o1.ves, o2.ves);\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Main\n\n{ \n\t static FastReader sc=new FastReader(); \n\t static long dp[][][];\n\t static int mod=1000000007;\n\t \n\t  public static void main(String[] args)  throws IOException\n{\n\t\t    //CHECK FOR N=1\n       \t//CHECK FOR N=1\n\t    //CHECK FOR N=1\t\t\t\n       \t//CHECK FOR N=1\n\t\t  \n\t\t  \n\t\t  \n\t\t   PrintWriter out=new PrintWriter(System.out);\n\t\t   StringBuffer sb=new StringBuffer(\"\");\n\t\t  int ttt=1;\n\t\t//ttt =i(); \t\n\t\t   \n\t        outer :while (ttt-- > 0) \n\t\t\t{\n\t        \tint n=i();\n\t        \tint k=i()*8;\n\t        \tint y=(int)Math.pow(2, (k/(double)n));\n\t        \t//long aa=(long)Math.ceil(Math.log(y)/Math.log(2))*n;\n\t        \tlong l=1;\n\t        \tlong u=y;\n\t        \tlong res=0;\n\t        \twhile(l<=u) {\n\t        \t\tlong mid=(l+u)/2;\n\t        \t\tlong aa=(long)Math.ceil(Math.log(mid)/Math.log(2))*n;\n\t        \t\t//System.out.println(mid);\n\t        \t\tif(aa>k) {\n\t        \t\t\tu=mid-1;\n\t        \t\t}\n\t        \t\telse {\n\t        \t\t\tres=mid;\n\t        \t\t\tl=mid+1;\n\t        \t\t}\n\t        \t}\n\t        \ty=(int)res;\n\t        \t\n\t        \tint A[]=input(n);\n\t        \tHashMap<Integer,Integer> map=hash(A);\n\t        \tif(map.size()<=y) {\n\t        \t\tSystem.out.println(\"0\");\n\t        \t\treturn;\n\t        \t}\n\t        \tint B[]=new int[map.size()];\n\t        \tn=map.size();\n\n\t        \tA=new int[n];\n\t        \tint c=0;\n\t        \tPair C[]=new Pair[n];\n\t        \t\n\t        \tfor(int key : map.keySet()) {\n\t        \t\tC[c]=new Pair(key,(int)map.get(key));\n\t        \t\tc++;\n\t        \t}\n\t        \tArrays.sort(C);\n\t        \tint D[]=new int[n];\n\t        \tfor(int i=0;i<n;i++) {\n\t        \t\tA[i]=C[i].x;\n\t        \t\tB[i]=C[i].y;\n\t        \t}\n\t        \tD[n-1]=B[n-1];\n\t        \tfor(int i=n-2;i>=0;i--) {\n\t        \t\tD[i]=D[i+1]+B[i];\n\t        \t}\n\t        \tint ans=Integer.MAX_VALUE;\n\t        \tfor(int i=0;i<n;i++) {\n\t        \t\tif(i+y-1<n) {\n\t        \t\t\tint op1=D[0]-(D[i]);\n\t        \t\t\tif(i+y<n) {\n\t        \t\t\t\top1+=D[i+y];\n\t        \t\t\t}\n\t        \t\t\tans=Math.min(ans, op1);\n\t        \t\t}\n\t        \t}\n\t        \tSystem.out.println(ans);\n\t        \n\t        \t\n\n\t        \n\t        \n\t        \t\n\t            \n\t\t\t}\n\t\t\n\n\t     //System.out.println(sb.toString());\n\t\t     out.close();\n\t     \n\t     \n\t    //CHECK FOR N=1                    //CHECK FOR M=0\n        //CHECK FOR N=1                    //CHECK FOR M=0\n       \t//CHECK FOR N=1\n       \t//CHECK FOR N=1\n       \t//CHECK FOR N=1\n\t\t        \n\t\t     \n    }\n\t\t\n\n\n\n\nstatic int[] input(int n) {\n\tint A[]=new int[n];\n\t   for(int i=0;i<n;i++) {\n\t\t   A[i]=sc.nextInt();\n\t   }\n\t   return A;\n   }\nstatic long[] inputL(int n) {\n\tlong A[]=new long[n];\n\t   for(int i=0;i<n;i++) {\n\t\t   A[i]=sc.nextLong();\n\t   }\n\t   return A;\n   }\nstatic String[] inputS(int n) {\n\tString A[]=new String[n];\n\t   for(int i=0;i<n;i++) {\n\t\t   A[i]=sc.next();\n\t   }\n\t   return A;\n   }\nstatic long sum(int A[]) {\n\tlong sum=0;\n\tfor(int i : A) {\n\t\tsum+=i;\n\t}\n\treturn sum;\n}\nstatic long sum(long A[]) {\n\tlong sum=0;\n\tfor(long i : A) {\n\t\tsum+=i;\n\t}\n\treturn sum;\n}\nstatic void reverse(long A[]) {\n\tint n=A.length;\n\tlong B[]=new long[n];\n\tfor(int i=0;i<n;i++) {\n\t\tB[i]=A[n-i-1];\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tA[i]=B[i];\n\t\n}\nstatic void reverse(int A[]) {\n\tint n=A.length;\n\tint B[]=new int[n];\n\tfor(int i=0;i<n;i++) {\n\t\tB[i]=A[n-i-1];\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tA[i]=B[i];\n\t\n}\nstatic void input(int A[],int B[]) {\n\t   for(int i=0;i<A.length;i++) {\n\t\t   A[i]=sc.nextInt();\n\t\t   B[i]=sc.nextInt();\n\t   }\n}\nstatic int[][] input(int n,int m){\n\tint A[][]=new int[n][m];\n\tfor(int i=0;i<n;i++) {\n\t\tfor(int j=0;j<m;j++) {\n\t\t\tA[i][j]=i();\n\t\t}\n\t}\n\treturn A;\n}\nstatic char[][] charinput(int n,int m){\n\tchar A[][]=new char[n][m];\n\tfor(int i=0;i<n;i++) {\n\t\tString s=s();\n\t\tfor(int j=0;j<m;j++) {\n\t\t\tA[i][j]=s.charAt(j);\n\t\t}\n\t}\n\treturn A;\n}\nstatic int max(int A[]) {\n\tint max=Integer.MIN_VALUE;\n\tfor(int i=0;i<A.length;i++) {\n\t\tmax=Math.max(max, A[i]);\n\t}\n\treturn max;\n}\nstatic int min(int A[]) {\n\tint min=Integer.MAX_VALUE;\n\tfor(int i=0;i<A.length;i++) {\n\t\tmin=Math.min(min, A[i]);\n\t}\n\treturn min;\n}\nstatic long max(long A[]) {\n\tlong max=Long.MIN_VALUE;\n\tfor(int i=0;i<A.length;i++) {\n\t\tmax=Math.max(max, A[i]);\n\t}\n\treturn max;\n}\nstatic long min(long A[]) {\n\tlong min=Long.MAX_VALUE;\n\tfor(int i=0;i<A.length;i++) {\n\t\tmin=Math.min(min, A[i]);\n\t}\n\treturn min;\n}\nstatic long [] prefix(long A[]) {\n\tlong p[]=new long[A.length];\n\tp[0]=A[0];\n\tfor(int i=1;i<A.length;i++)\n\t\tp[i]=p[i-1]+A[i];\n\treturn p;\n}\nstatic long [] prefix(int A[]) {\n\tlong p[]=new long[A.length];\n\tp[0]=A[0];\n\tfor(int i=1;i<A.length;i++)\n\t\tp[i]=p[i-1]+A[i];\n\treturn p;\n}\nstatic long [] suffix(long A[]) {\n\tlong p[]=new long[A.length];\n\tp[A.length-1]=A[A.length-1];\n\tfor(int i=A.length-2;i>=0;i--)\n\t\tp[i]=p[i+1]+A[i];\n\treturn p;\n}\nstatic long [] suffix(int A[]) {\n\tlong p[]=new long[A.length];\n\tp[A.length-1]=A[A.length-1];\n\tfor(int i=A.length-2;i>=0;i--)\n\t\tp[i]=p[i+1]+A[i];\n\treturn p;\n}\nstatic void print(int A[]) {\n\tfor(int i : A) {\n\t\tSystem.out.print(i+\" \");\n\t}\n\tSystem.out.println();\n}\nstatic void print(long A[]) {\n\tfor(long i : A) {\n\t\tSystem.out.print(i+\" \");\n\t}\n\tSystem.out.println();\n}\nstatic long mod(long x) {\n\t int mod=1000000007;\n\t  return ((x%mod + mod)%mod);\n}\nstatic String reverse(String s) {\n\tStringBuffer p=new StringBuffer(s);\n\tp.reverse();\n\treturn p.toString();\n}\n\n     static int i() {\n    \t return sc.nextInt();\n     }\n     static String s() {\n    \t return sc.next();\n     }\n     static long l() {\n    \t return sc.nextLong();\n     }  \n     static void sort(int[] A){\n        int n = A.length;\n        Random rnd = new Random();\n        for(int i=0; i<n; ++i){\n            int tmp = A[i];\n            int randomPos = i + rnd.nextInt(n-i);\n            A[i] = A[randomPos];\n            A[randomPos] = tmp;\n        }\n        Arrays.sort(A);\n     }\n     static void sort(long[] A){\n\t        int n = A.length;\n\t        Random rnd = new Random();\n\t        for(int i=0; i<n; ++i){\n\t            long tmp = A[i];\n\t            int randomPos = i + rnd.nextInt(n-i);\n\t            A[i] = A[randomPos];\n\t            A[randomPos] = tmp;\n\t        }\n\t        Arrays.sort(A);\n\t     }\n  static String sort(String s) {\n \t Character ch[]=new Character[s.length()];\n \t for(int i=0;i<s.length();i++) {\n \t\t ch[i]=s.charAt(i);\n \t }\n \t Arrays.sort(ch);\n \t StringBuffer st=new StringBuffer(\"\");\n \t for(int i=0;i<s.length();i++) {\n \t\t st.append(ch[i]);\n \t }\n \t return st.toString();\n  }\n  static HashMap<Integer,Integer> hash(int A[]){\n\t  HashMap<Integer,Integer> map=new HashMap<Integer, Integer>();\n\t  for(int i : A) {\n\t\t  if(map.containsKey(i)) {\n\t\t\t  map.put(i, map.get(i)+1);\n\t\t  }\n\t\t  else {\n\t\t\t  map.put(i, 1);\n\t\t  }\n\t  }\n\t  return map;\n  }\n  static TreeMap<Integer,Integer> tree(int A[]){\n\t  TreeMap<Integer,Integer> map=new TreeMap<Integer, Integer>();\n\t  for(int i : A) {\n\t\t  if(map.containsKey(i)) {\n\t\t\t  map.put(i, map.get(i)+1);\n\t\t  }\n\t\t  else {\n\t\t\t  map.put(i, 1);\n\t\t  }\n\t  }\n\t  return map;\n  }\n     static boolean prime(int n) \n\t    { \n\t        if (n <= 1) \n\t            return false; \n\t        if (n <= 3) \n\t            return true; \n\t        if (n % 2 == 0 || n % 3 == 0) \n\t            return false; \n\t        double sq=Math.sqrt(n);\n\t  \n\t        for (int i = 5; i <= sq; i = i + 6) \n\t            if (n % i == 0 || n % (i + 2) == 0) \n\t                return false; \n\t        return true; \n\t    } \n     static boolean prime(long n) \n\t    { \n\t        if (n <= 1) \n\t            return false; \n\t        if (n <= 3) \n\t            return true; \n\t        if (n % 2 == 0 || n % 3 == 0) \n\t            return false; \n\t        double sq=Math.sqrt(n);\n\t  \n\t        for (int i = 5; i <= sq; i = i + 6) \n\t            if (n % i == 0 || n % (i + 2) == 0) \n\t                return false; \n\t        return true; \n\t    } \n     static int gcd(int a, int b) \n     { \n         if (a == 0) \n             return b; \n         return gcd(b % a, a); \n     } \n     static long gcd(long a, long b) \n     { \n         if (a == 0) \n             return b; \n         return gcd(b % a, a); \n     } \n     static class Pair implements Comparable<Pair>\n     {\n    \t int x;\n    \t int y;\n    \t Pair(int x,int y){\n    \t\t this.x=x;\n    \t\t this.y=y;\n    \t }\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif(this.x>o.x)\n\t\t\t\treturn 1;\n\t\t\telse if(this.x<o.x)\n\t\t\t\treturn -1;\n\t\t\telse {\n\t\t\t\tif(this.y>o.y)\n\t\t\t\t\treturn 1;\n\t\t\t\telse if(this.y<o.y)\n\t\t\t\t\treturn -1;\n\t\t\t\telse\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\n\t\t\n     }\n        \n    static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n} \n\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.StringTokenizer;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class MP3 {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    static void shuffleArray(int[] ar) {\n        Random rnd = ThreadLocalRandom.current();\n        for (int i = ar.length - 1; i > 0; i--) {\n            int index = rnd.nextInt(i + 1);\n            int a = ar[index];\n            ar[index] = ar[i];\n            ar[i] = a;\n        }\n    }\n    public static void main(String[] args) {\n        FastReader sc = new FastReader();\n        int n = sc.nextInt();\n        int I = sc.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n        }\n        shuffleArray(a);\n        Arrays.sort(a);\n        List<Pair> arrayList = new ArrayList<>();\n        for (int i = 0; i < n;) {\n            int value = a[i];\n            int cnt = 0;\n            for (; i < n && a[i] == value; i++) {\n                cnt++;\n            }\n            arrayList.add(new Pair(value, cnt));\n        }\n        long K = 1;\n        int power = (I * 8) / n;\n        for (int i = 0; i < power; i++) {\n            K *= 2;\n            if (K >= n)\n                break;\n        }\n        int discnt = arrayList.size();\n        if (K >= discnt) {\n            System.out.println(\"0\");\n        }\n        else {\n            int sum = 0;\n            for (int i = 0; i < K; i++){\n                sum += arrayList.get(i).value;\n            }\n            int ans = sum;\n            for (int i = (int)K; i < discnt; i++) {\n                sum = sum + arrayList.get(i).value - arrayList.get((int) (i - K)).value;\n                ans = Math.max(ans, sum);\n            }\n            System.out.println(n-ans);\n        }\n    }\n}\n\nclass Pair {\n    int key, value;\n\n    public Pair(int key, int value) {\n        this.key = key;\n        this.value = value;\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class C {\n\n\tstatic FasterScanner sc = new FasterScanner();\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\n\tstatic void exit() {\n\t\tout.close();\n\t}\n\n\tpublic C () {\n\t\tint n = sc.nextInt(), I = sc.nextInt();\n\t\tint [] A = new int [n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tA[i] = sc.nextInt();\n\t\t}\n\t\tint space = 8 * I / n;\n\t\tspace = Math.min(20, space);\n\t\tspace = 1 << space;\n\t\tif (n <= space) {\n\t\t\tout.println(0);\n\t\t\treturn;\n\t\t\t\n\t\t}\n\n\t\tMap<Integer, Integer> counts = new TreeMap<>();\n\t\tfor (int e : A) {\n\t\t\tcounts.put(e, counts.getOrDefault(e, 0)+1);\n\t\t}\n\t\tint num = counts.size();\n\t\tif (num <= space) {\n\t\t\tout.println(0);\n\t\t\treturn;\n\t\t}\n\t\tint [] values = new int [num];\n\t\tint i = 0;\n\t\tfor (int e : counts.keySet()) {\n\t\t\tvalues[i++] = e;\n\t\t}\n\t\tint l = 0, r = l + space - 1;\n\t\tint cnt = 0;\n\t\tfor (i = num-1; i > r; i--) cnt += counts.get(values[i]);\n\t\tint min_c = cnt;\n\t\tfor (l=1; r <= num-1; l++, r++) {\n\t\t\tr = l + space - 1;\n\t\t\tcnt = cnt - counts.get(values[r]) + counts.get(values[l-1]);\n\t\t\tif (min_c > cnt) min_c = cnt;\n\t\t}\n\t\t\n\t\t/*\n\t\tArrays.sort(A);\n\t\tint num = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i == 0 || A[i] != A[i-1]) num ++;\n\t\t}\n\t\tif (num <= space) {\n\t\t\tout.println(0);\n\t\t\treturn;\n\t\t}\n\t\tint [] values = new int [num];\n\t\tint [] counts = new int [num];\n\t\tvalues[0] = A[0];\n\t\tcounts[0] = 1;\n\t\tint j = 1;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (A[i] != values[j-1]) {\n\t\t\t\tvalues[j] = A[i];\n\t\t\t\tj++;\n\t\t\t\tcounts[j-1] = 1;\n\t\t\t} else {\n\t\t\t\tcounts[j-1]++;\n\t\t\t}\n\t\t}\n\t\tint l = 0;\n\t\tint r = l + space - 1;\n\t\tint cnt = 0;\n\t\tfor (int i = num-1; i > r; i--) cnt += counts[i];\n\t\tint min_c = cnt;\n\t\tfor (l=1; r <= num-1; l++, r++) {\n\t\t\tr = l + space - 1;\n\t\t\tcnt = cnt - counts[r] + counts[l-1];\n\t\t\tif (min_c > cnt) min_c = cnt;\n\t\t}\n\t\t*/\n\t\t/*\n\t\tlong [] psum1 = new long [num];\n\t\tlong [] psum2 = new long [num];\n\t\tpsum1[0] = counts[0];\n\t\tpsum2[num-1] = counts[num-1];\n\t\tfor (int i = 1; i < num; i++) {\n\t\t\tpsum1[i] = counts[i] + psum1[i-1];\n\t\t}\n\t\tfor (int i = num-2; i >= 0; i--) {\n\t\t\tpsum2[i] = counts[i] + psum2[i+1];\n\t\t}\n\t\tlong min_c = Long.MAX_VALUE;\n\t\tfor (int l = 0; l+space-1 < num; l++) {\n\t\t\tint r = (l + space - 1);\n\t\t\tlong changes = psum1[l] - counts[l] + psum2[r] - counts[r];\n\t\t\tif (min_c > changes) min_c = changes;\n\t\t}\n\t\t*/\n\t\tout.println(min_c);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew C();\n\t\texit();\n\t}\n\n\tstatic class FasterScanner {\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int snumChars;\n\n        public int read() {\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) {\n                curChar = 0;\n                try {\n                    snumChars = System.in.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        }\n\n        public String nextString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public int[] nextIntArray(int n, int f) {\n            if (f == 0) {\n                int[] arr = new int[n];\n                for (int i = 0; i < n; i++) {\n                    arr[i] = nextInt();\n                }\n                return arr;\n            } else {\n                int[] arr = new int[n + 1];\n                for (int i = 1; i < n + 1; i++) {\n                    arr[i] = nextInt();\n                }\n                return arr;\n            }\n        }\n\n        public long[] nextLongArray(int n, int f) {\n            if (f == 0) {\n                long[] arr = new long[n];\n                for (int i = 0; i < n; i++) {\n                    arr[i] = nextLong();\n                }\n                return arr;\n            } else {\n                long[] arr = new long[n + 1];\n                for (int i = 1; i < n + 1; i++) {\n                    arr[i] = nextLong();\n                }\n                return arr;\n            }\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        private boolean isEndOfLine(int c) {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "import sys\nfrom functools import lru_cache, cmp_to_key\nfrom heapq import merge, heapify, heappop, heappush\nfrom math import *\nfrom collections import defaultdict as dd, deque, Counter as C\nfrom itertools import combinations as comb, permutations as perm\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\nfrom time import perf_counter\nfrom fractions import Fraction\n# import numpy as np\n# sys.setrecursionlimit(int(pow(10,6)))\n# sys.stdout = open(\"out.txt\", \"w\")\nmod = int(pow(10, 9) + 7)\nmod2 = 998244353\ndef data(): return sys.stdin.readline().strip()\ndef out(*var, end=\"\\n\"): sys.stdout.write(' '.join(map(str, var))+end)\ndef L(): return list(sp())\ndef sl(): return list(ssp())\ndef sp(): return map(int, data().split())\ndef ssp(): return map(str, data().split())\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]\n\ntry:\n    sys.stdin = open(\"input.txt\", \"r\")\nexcept:\n    pass\n\n\n# @lru_cache(None)\nR=lambda:map(int,input().split())\nn,I=R()\na=sorted(R())\nb=[0]+[i+1for i in range(n-1)if a[i]<a[i+1]]+[n]\nprint(n-max((y-x for x,y in zip(b,b[1<<8*I//n:])),default=n))"
        },
        {
            "language": 3,
            "solution": "from collections import *\nfrom math import *\nn,k = map(int,input().split())\na = list(map(int,input().split()))\nd = Counter(a)\na.sort()\nval = [0 for i in range(400005)]\na = list(set(a))\na.sort()\nn1 = len(a)\nval[0] = d[a[0]]\nfor i in range(1,n1):\n    val[i] = val[i-1] + d[a[i]]\nm = n1\n#print(n1)\nfor m in range(n1,0,-1):\n    s = ceil(log2(m))\n    if s*n <= 8*k:\n        break\n#print(m,val[:10])\nm1 = val[m-1]\nfor i in range(m,n1):\n    m1 = max(m1,val[i]-val[i-m])\nprint(n-m1)"
        },
        {
            "language": 1,
            "solution": "n, I = map(int, raw_input().split())\nbpe = (I*8)/n\nls = map(int, raw_input().split())\n\nimport collections\nimport sys\n\nctr = collections.Counter(ls)\n\nks = sorted(ctr.keys())\n\nif 2**bpe >= len(ks):\n    print 0\n    sys.exit(0)\n\nlptr = 0\nrptr = -1\nwind = 0\nwhile rptr < 2**bpe-1:\n    rptr += 1\n    wind += ctr[ks[rptr]]\n    #print lptr, rptr, wind\n\nbest = wind\nwhile rptr < len(ks)-1:\n    wind += ctr[ks[rptr+1]]\n    wind -= ctr[ks[lptr]]\n    lptr += 1\n    rptr += 1\n    best = max(best, wind)\n    #print lptr, rptr, wind\nprint n-best\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing lli = long long int;\nvoid fast() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n}\nint main() {\n  fast();\n  lli q;\n  q = 1;\n  while (q--) {\n    lli n, bbb, i, j, k, m, p;\n    cin >> n >> bbb;\n    bbb = bbb * 8;\n    bbb = bbb / n;\n    k = 1;\n    for (int i = 0; i < bbb; i++) k *= 2;\n    vector<lli> a(n), b(n), bb(n);\n    for (i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    sort(a.begin(), a.end());\n    j = 0;\n    b[j] = a[0], bb[j] = 1;\n    for (i = 1; i < n; i++) {\n      if (a[i] != a[i - 1]) {\n        j++;\n        b[j] = a[i];\n        bb[j] = 1;\n      } else {\n        bb[j]++;\n      }\n    }\n    int ma = 0, s = 0;\n    for (i = 0; i < k; i++) {\n      s = s + bb[i];\n      if (i == j) break;\n    }\n    ma = s;\n    for (i = k; i <= j; i++) {\n      s = s + bb[i] - bb[i - k];\n      ma = max(ma, s);\n    }\n    cout << n - ma << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long int n;\n  cin >> n;\n  long long int k;\n  cin >> k;\n  map<long long int, long long int> m;\n  long long int val;\n  for (int i = 0; i < n; i++) {\n    cin >> val;\n    m[val]++;\n  }\n  long long int dist = (long long int)m.size();\n  long long int k1 =\n      (long long int)((long long int)ceil(log2((long long int)dist)));\n  long long int sz = k1 * n;\n  long long int bits = k * (long long int)8;\n  if (sz <= bits) {\n    cout << 0;\n  } else {\n    long long int allow = (long long int)pow(2, (long long int)(bits / n));\n    vector<pair<long long int, long long int> > vp;\n    long long int val = 0;\n    for (auto i : m) {\n      val += i.second;\n      vp.push_back({i.first, val});\n    }\n    long long int mini = LONG_MAX;\n    for (long long int i = 0, j = allow - 1; j < vp.size(); i++, j++) {\n      long long int total = vp[vp.size() - 1].second - vp[j].second;\n      if (i > 0) total += vp[i - 1].second;\n      mini = min(mini, total);\n    }\n    cout << mini;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint numDistinctAllowed(int* arr, int n, int I) {\n  int ans = 0;\n  int totalBits = 8 * I;\n  int start = 1, end = n;\n  while (start <= end) {\n    int mid = (start + end) / 2;\n    int bits = (int)(ceil(log2(mid)));\n    if (bits * n <= totalBits) {\n      ans = mid;\n      start = mid + 1;\n    } else {\n      end = mid - 1;\n    }\n  }\n  return ans;\n}\nint minChanged(int* arr, int n, int I) {\n  sort(arr, arr + n);\n  int allowed = numDistinctAllowed(arr, n, I);\n  int i = 0;\n  int numDistinct = 0;\n  while (i < n) {\n    numDistinct++;\n    int j = i;\n    while (j < n && arr[j] == arr[i]) {\n      j++;\n    }\n    i = j;\n    if (numDistinct == allowed) {\n      break;\n    }\n  }\n  if (i == n) {\n    return 0;\n  }\n  int minChanged = INT_MAX;\n  int start = 0, end = i - 1;\n  while (end < n) {\n    int numChanged = (n - 1 - end) + (start);\n    minChanged = min(minChanged, numChanged);\n    int j = start;\n    while (j < n && arr[j] == arr[start]) {\n      j++;\n    }\n    start = j;\n    j = end;\n    while (j < n && arr[j] == arr[end]) {\n      j++;\n    }\n    end = j;\n    while (j < n && arr[j] == arr[end]) {\n      j++;\n    }\n    if (j < n) {\n      end = j - 1;\n    } else {\n      break;\n    }\n  }\n  return minChanged;\n}\nint main() {\n  int n, I;\n  scanf(\"%d %d\", &n, &I);\n  int* arr = new int[n];\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &arr[i]);\n  }\n  cout << minChanged(arr, n, I) << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T, typename Pr = less<T>>\nusing pq = priority_queue<T, vector<T>, Pr>;\nusing i64 = long long int;\nusing ii = pair<int, int>;\nusing ii64 = pair<i64, i64>;\nclass Mapping {\n public:\n  void init(const vector<int>& raw, int base = 0) {\n    start = base;\n    arr = raw;\n    sort(arr.begin(), arr.end());\n    arr.erase(unique(arr.begin(), arr.end()), arr.end());\n  }\n  int get_idx(int k) {\n    return start + (lower_bound((arr).begin(), (arr).end(), k) - arr.begin());\n  }\n  int get_value(int idx) { return arr[idx - start]; }\n  int size() { return arr.size(); }\n\n private:\n  int start;\n  vector<int> arr;\n};\nint cnt[800005];\nint cntr[800005];\nint main() {\n  int n, l;\n  scanf(\"%d %d\", &n, &l);\n  vector<int> arr(n);\n  for (int i = 0; i < n; i++) scanf(\"%d\", &arr[i]);\n  Mapping m;\n  m.init(arr, 1);\n  for (int i = 0; i < n; i++) {\n    cnt[m.get_idx(arr[i])]++;\n    cntr[m.get_idx(arr[i])]++;\n  }\n  int maxb = 0;\n  int bv = 1;\n  while (bv < n) {\n    maxb++;\n    bv *= 2;\n  }\n  l = (l * 8) / n;\n  if (l >= maxb) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  for (int i = 1; i <= n; i++) cnt[i] += cnt[i - 1];\n  for (int i = n; i >= 1; i--) cntr[i] += cntr[i + 1];\n  int ans = 987654321;\n  int use = 1;\n  while (l > 0) {\n    use = (use * 2);\n    l--;\n  }\n  for (int i = 1; i <= n; i++) {\n    int now = cnt[i - 1] + cntr[i + use];\n    ans = min(ans, now);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "import math\n\n\nn, bytes_ = map(int, raw_input().split())\nd = {}\n\nfor i in map(int, raw_input().split()):\n    d[i] = d.get(i, 0) + 1\n\nb = [d[i] for i in sorted(d.keys())]\n\nlength = len(b)\nk = bytes_ * 8 / n\n\ndef calc(k, b):\n    if math.log(length, 2) <= k:\n        return 0\n\n    head, tail = [], []\n    h, t = 0, 0\n    for i in range(length):\n        h += b[i]\n        head.append(h)\n        t += b[length - 1 - i]\n        tail.append(t)\n\n    m = length - (2 ** k)\n\n    result = min(head[m - 1], tail[m - 1])\n    for i in range(1, m):\n        result = min(result, head[i-1] + tail[m - i - 1])\n\n    return result\n\nprint calc(k, b)\n"
        },
        {
            "language": 3,
            "solution": "from collections import Counter\nn, I = map(int, input().split())\nbits = 2**((I * 8) // n)\nA = list(map(int, input().split()))\ncounter = Counter(A)\nmaxans = -1\nkeys = sorted(counter.keys())\nlk = len(keys)\ns = [0]*lk\ns[0] = counter[keys[0]]\nfor i, k in enumerate(keys[1:], 1):\n    s[i] = s[i-1] + counter[k]\nif lk <= bits:\n    print(0)\nelse:\n    for l in range(lk-bits):\n        maxans = max(maxans, s[l+bits]-s[l])\n    print(n-maxans)\n"
        },
        {
            "language": 1,
            "solution": "n, I = map(int, raw_input().split())\nbpe = (I*8)/n\nls = map(int, raw_input().split())\n \nimport collections\nimport sys\n \nctr = collections.Counter(ls)\n \nks = sorted(ctr.keys())\n \nif 2**bpe >= len(ks):\n    print 0\n    sys.exit(0)\n \nlptr = 0\nrptr = -1\nwind = 0\nwhile rptr < 2**bpe-1:\n    rptr += 1\n    wind += ctr[ks[rptr]]\n \nbest = wind\nwhile rptr < len(ks)-1:\n    wind += ctr[ks[rptr+1]]\n    wind -= ctr[ks[lptr]]\n    lptr += 1\n    rptr += 1\n    best = max(best, wind)\nprint n-best\n "
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Map.Entry;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\t/*public static void main(String[] args) throws IOException{\n\t\tint n=sc.nextInt();\n\t\tint x=sc.nextInt();\n\t\tint y=sc.nextInt();\n\t\t\n\t\tint[] a= new int[n];\n\t\t\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i]=sc.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tboolean f1=true;\n\t\t\tint f=i-x;\n\t\t\tif(f<0)\n\t\t\t{\n\t\t\t\tf=0;\n\t\t\t}\n\t\t\tfor (int j = f; j < i; j++) {\n\t\t\t\tif(a[j]<a[i])\n\t\t\t\t{\n\t\t\t\t\tf1=false;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean f2=true;\n\t\t\tint l=i+y;\n\t\t\tif(l>a.length-1)\n\t\t\t{\n\t\t\t\tl=a.length-1;\n\t\t\t}\n\t\t\tfor (int j = i+1; j <= l; j++) {\n\t\t\t\tif(a[j]<a[i])\n\t\t\t\t{\n\t\t\t\t\tf1=false;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f1 && f2)\n\t\t\t{\n\t\t\t\tSystem.out.println(i+1);break;\n\t\t\t}\n\t\t}\n\t}*/\n\t\n\t/*public static void main(String[] args) throws IOException{\n\t\tdouble H=sc.nextDouble();\n\t\tdouble L=sc.nextDouble();\n\t\t\n\t\tdouble res=(L*L-H*H)/(2*H);\n\t\t\n\t\tSystem.out.println(res);\t\n\t}*/\n\t\n\tpublic static void main(String[] args) throws IOException{\n\t\tint n=sc.nextInt();\n\t\tint I=sc.nextInt();\n\t\t\n\t\tint disk=I*8;\n\t\t\n\t\t//System.out.println(\"The disk can carry maximum \" + disk + \" bits\");\n\t\t\n\t\tTreeMap<Integer, Integer> occ= new TreeMap<Integer, Integer>();\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint temp=sc.nextInt();\n\t\t\tif(!occ.containsKey(temp))\n\t\t\t{\n\t\t\t\tocc.put(temp, 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tocc.put(temp, occ.get(temp) + 1);\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tint KOriginal=occ.size();\n\t\t\n\t\t//System.out.println(\"From the input, we have \" + KOriginal + \"distinct numbers\");\n\t\t\n\t\tTreeMap<Integer, Integer> log2K= new TreeMap<Integer, Integer>(); \n\t\t\n\t\tfor (int j = 0; j < 25; j++) {\n\t\t\tlog2K.put((int)Math.pow(2,j), j);\n\t\t}\n\t\t\n\t\tint kMax=0;\n\t\tfor(Entry e: log2K.entrySet())\n\t\t{\n\t\t\tint k=(int)e.getValue();\n\t\t\tif(k*n<=disk)\n\t\t\t{\n\t\t\t\tkMax=(int) e.getKey();\n\t\t\t}\n\t\t}\n\t\tif(kMax>KOriginal)\n\t\t{\n\t\t\tkMax=KOriginal;\n\t\t}\n\t\t//System.out.println(\"The max distict elements that we can have is \" + kMax + \" distict elements\");\n\t\tint totalOccurences=0;\n\t\t\n\t\tInteger[] occurencesArray= new Integer[occ.size()]; \n\t\tfor(int i=0; i<occurencesArray.length; i++)\n\t\t{\n\t\t\toccurencesArray[i]=(int) occ.pollFirstEntry().getValue();\n\t\t\ttotalOccurences+=occurencesArray[i];\n\t\t}\n\t\t//System.out.println(\"Total occurences array \" + Arrays.toString(occurencesArray));\n\t\tint f=0;\n\t\tint l=kMax-1;\n\t\tint sum=0;\n\t\t\n\t\tfor (int j = 0; j <= l; j++) {\n\t\t\tsum+=occurencesArray[j];\n\t\t}\n\t\t\n\t\tint max=sum;\n\t\tsum-=occurencesArray[f];\n\t\tf++;\n\t\tl++;\n\t\twhile(l<occurencesArray.length)\n\t\t{\n\t\t\tsum+=occurencesArray[l];\n\t\t\tif(sum>max)\n\t\t\t{\n\t\t\t\tmax=sum;\n\t\t\t}\n\t\t\tsum-=occurencesArray[f];\n\t\t\tf++;\n\t\t\tl++;\n\t\t}\n\t\t//System.out.println(\"The total number of occurences is \" + totalOccurences);\n\t\t//System.out.println(\"Max sum from sliding window is \" + max);\n\t\tSystem.out.println(totalOccurences-max);\n\t\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n \n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tint start = 0;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tif (x.charAt(0) == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor (int i = start; i < x.length(); i++)\n\t\t\t\tif (x.charAt(i) == '.') {\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif (dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg ? -1 : 1);\n\t\t}\n \n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n \n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "'''input\n6 1\n2 1 2 1 3 3\n6 2\n2 1 2 3 4 3\n'''\nfrom collections import defaultdict as dd\n#main code\nn,l=map(int,input().strip().split())\narr=list(map(int,input().strip().split()))\n\ndistinct=2**(l*8//n)\nst=len(set(arr))\n\nif(st<=distinct):\n\tprint(0)\nelse:\n\td=dd(int)\n\tfor i in range(n):\n\t\td[arr[i]]+=1\n\tl1=[]\n\tfor i in sorted(d.keys()):\n\t\tl1.append(d[i])\n\t\n\tmx=0\n\ts1=sm=sum(l1[:distinct])\n\tfor i in range(distinct,len(l1)):\n\t\tsm+=l1[i]-l1[i-distinct]\n\t\ts1=max(s1,sm)\n\tprint(n-s1)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long int n, ans = 0, k, mx = 0;\n  cin >> n >> k;\n  k = (8 * k) / n;\n  k = (1 << (min(20ll, k)));\n  vector<long long int> arr, pref;\n  map<long long int, long long int> list;\n  for (int x = 0; x < n; x++) {\n    int a;\n    cin >> a;\n    if (list.find(a) == list.end())\n      list.insert({a, 1});\n    else\n      list[a]++;\n  }\n  for (auto it = list.begin(); it != list.end(); it++)\n    arr.push_back(it->second);\n  pref.resize(arr.size());\n  pref[0] = arr[0];\n  for (int x = 1; x < arr.size(); x++) pref[x] = arr[x] + pref[x - 1];\n  if (pref.size() > k) {\n    mx = pref[k - 1];\n    for (int x = k; x < pref.size(); x++) mx = max(mx, pref[x] - pref[x - k]);\n    cout << pref[pref.size() - 1] - mx << endl;\n  } else\n    cout << 0 << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "\n/**\n * Date: 30 Jul, 2019\n * Link:\n *\n * @author Prasad-Chaudhari\n * @linkedIn: https://www.linkedin.com/in/prasad-chaudhari-841655a6/\n * @git: https://github.com/Prasad-Chaudhari\n */\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Arrays;\nimport java.util.Hashtable;\nimport java.util.Map;\n\npublic class newProgram12 {\n\n    public static void main(String[] args) throws IOException {\n        // TODO code application logic here\n        FastIO in = new FastIO();\n        int n = in.ni();\n        int I = in.ni();\n        int a[] = in.gia(n);\n        I *= 8;\n        int k = I / n;\n        Map<Integer, Integer> map = new Hashtable<>();\n        for (int i = 0; i < n; i++) {\n            map.put(a[i], map.getOrDefault(a[i], 0) + 1);\n        }\n        int size = map.size();\n        if (Math.pow(2, k) >= size) {\n            System.out.println(0);\n        } else {\n            int b[] = new int[size];\n            for (int i : map.keySet()) {\n                b[--size] = i;\n            }\n            Data.sort(b);\n            int freq[] = new int[b.length];\n            for (int i = 0; i < b.length; i++) {\n                freq[i] = map.get(b[i]);\n            }\n            for (int i = 1; i < b.length; i++) {\n                freq[i] += freq[i - 1];\n            }\n            int max_dis = (int) Math.pow(2, k);\n            int discard = 0;\n            int min_discard = Integer.MAX_VALUE;\n            for (int i = 0; i < b.length - 1; i++) {\n                if (i + max_dis - 1 < b.length) {\n                    min_discard = Math.min(min_discard, discard + freq[b.length - 1] - freq[i + max_dis - 1]);\n                }\n                discard = freq[i];\n            }\n            if (min_discard == Integer.MAX_VALUE) {\n                min_discard = 0; \n            }\n            System.out.println(min_discard);\n        }\n        in.bw.flush();\n    }\n\n    static class FastIO {\n\n        private final BufferedReader br;\n        private final BufferedWriter bw;\n        private String s[];\n        private int index;\n        private final StringBuilder sb;\n\n        public FastIO() throws IOException {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            bw = new BufferedWriter(new OutputStreamWriter(System.out, \"UTF-8\"));\n            s = br.readLine().split(\" \");\n            sb = new StringBuilder();\n            index = 0;\n        }\n\n        public int ni() throws IOException {\n            return Integer.parseInt(nextToken());\n        }\n\n        public double nd() throws IOException {\n            return Double.parseDouble(nextToken());\n        }\n\n        public long nl() throws IOException {\n            return Long.parseLong(nextToken());\n        }\n\n        public String next() throws IOException {\n            return nextToken();\n        }\n\n        public String nli() throws IOException {\n            try {\n                return br.readLine();\n            } catch (IOException ex) {\n\n            }\n            return null;\n        }\n\n        public int[] gia(int n) throws IOException {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = ni();\n            }\n            return a;\n        }\n\n        public int[] gia(int n, int start, int end) throws IOException {\n            validate(n, start, end);\n            int a[] = new int[n];\n            for (int i = start; i < end; i++) {\n                a[i] = ni();\n            }\n            return a;\n        }\n\n        public double[] gda(int n) throws IOException {\n            double a[] = new double[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nd();\n            }\n            return a;\n        }\n\n        public double[] gda(int n, int start, int end) throws IOException {\n            validate(n, start, end);\n            double a[] = new double[n];\n            for (int i = start; i < end; i++) {\n                a[i] = nd();\n            }\n            return a;\n        }\n\n        public long[] gla(int n) throws IOException {\n            long a[] = new long[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nl();\n            }\n            return a;\n        }\n\n        public long[] gla(int n, int start, int end) throws IOException {\n            validate(n, start, end);\n            long a[] = new long[n];\n            for (int i = start; i < end; i++) {\n                a[i] = nl();\n            }\n            return a;\n        }\n\n        public int[][][] gwtree(int n) throws IOException {\n            int m = n - 1;\n            int adja[][] = new int[n + 1][];\n            int weight[][] = new int[n + 1][];\n            int from[] = new int[m];\n            int to[] = new int[m];\n            int count[] = new int[n + 1];\n            int cost[] = new int[n + 1];\n            for (int i = 0; i < m; i++) {\n                from[i] = i + 1;\n                to[i] = ni();\n                cost[i] = ni();\n                count[from[i]]++;\n                count[to[i]]++;\n            }\n            for (int i = 0; i <= n; i++) {\n                adja[i] = new int[count[i]];\n                weight[i] = new int[count[i]];\n            }\n            for (int i = 0; i < m; i++) {\n                adja[from[i]][count[from[i]] - 1] = to[i];\n                adja[to[i]][count[to[i]] - 1] = from[i];\n                weight[from[i]][count[from[i]] - 1] = cost[i];\n                weight[to[i]][count[to[i]] - 1] = cost[i];\n                count[from[i]]--;\n                count[to[i]]--;\n            }\n            return new int[][][]{adja, weight};\n        }\n\n        public int[][][] gwg(int n, int m) throws IOException {\n            int adja[][] = new int[n + 1][];\n            int weight[][] = new int[n + 1][];\n            int from[] = new int[m];\n            int to[] = new int[m];\n            int count[] = new int[n + 1];\n            int cost[] = new int[n + 1];\n            for (int i = 0; i < m; i++) {\n                from[i] = ni();\n                to[i] = ni();\n                cost[i] = ni();\n                count[from[i]]++;\n                count[to[i]]++;\n            }\n            for (int i = 0; i <= n; i++) {\n                adja[i] = new int[count[i]];\n                weight[i] = new int[count[i]];\n            }\n            for (int i = 0; i < m; i++) {\n                adja[from[i]][count[from[i]] - 1] = to[i];\n                adja[to[i]][count[to[i]] - 1] = from[i];\n                weight[from[i]][count[from[i]] - 1] = cost[i];\n                weight[to[i]][count[to[i]] - 1] = cost[i];\n                count[from[i]]--;\n                count[to[i]]--;\n            }\n            return new int[][][]{adja, weight};\n        }\n\n        public int[][] gtree(int n) throws IOException {\n            int adja[][] = new int[n + 1][];\n            int from[] = new int[n - 1];\n            int to[] = new int[n - 1];\n            int count[] = new int[n + 1];\n            for (int i = 0; i < n - 1; i++) {\n                from[i] = i + 1;\n                to[i] = ni();\n                count[from[i]]++;\n                count[to[i]]++;\n            }\n            for (int i = 0; i <= n; i++) {\n                adja[i] = new int[count[i]];\n            }\n            for (int i = 0; i < n - 1; i++) {\n                adja[from[i]][--count[from[i]]] = to[i];\n                adja[to[i]][--count[to[i]]] = from[i];\n            }\n            return adja;\n        }\n\n        public int[][] gg(int n, int m) throws IOException {\n            int adja[][] = new int[n + 1][];\n            int from[] = new int[m];\n            int to[] = new int[m];\n            int count[] = new int[n + 1];\n            for (int i = 0; i < m; i++) {\n                from[i] = ni();\n                to[i] = ni();\n                count[from[i]]++;\n                count[to[i]]++;\n            }\n            for (int i = 0; i <= n; i++) {\n                adja[i] = new int[count[i]];\n            }\n            for (int i = 0; i < m; i++) {\n                adja[from[i]][--count[from[i]]] = to[i];\n                adja[to[i]][--count[to[i]]] = from[i];\n            }\n            return adja;\n        }\n\n        public void print(String s) throws IOException {\n            bw.write(s);\n        }\n\n        public void println(String s) throws IOException {\n            bw.write(s);\n            bw.newLine();\n        }\n\n        public void print(int s) throws IOException {\n            bw.write(s + \"\");\n        }\n\n        public void println(int s) throws IOException {\n            bw.write(s + \"\");\n            bw.newLine();\n        }\n\n        public void print(long s) throws IOException {\n            bw.write(s + \"\");\n        }\n\n        public void println(long s) throws IOException {\n            bw.write(s + \"\");\n            bw.newLine();\n        }\n\n        public void print(double s) throws IOException {\n            bw.write(s + \"\");\n        }\n\n        public void println(double s) throws IOException {\n            bw.write(s + \"\");\n            bw.newLine();\n        }\n\n        private String nextToken() throws IndexOutOfBoundsException, IOException {\n            if (index == s.length) {\n                s = br.readLine().split(\" \");\n                index = 0;\n            }\n            return s[index++];\n        }\n\n        private void validate(int n, int start, int end) {\n            if (start < 0 || end >= n) {\n                throw new IllegalArgumentException();\n            }\n        }\n    }\n\n    static class Data implements Comparable<Data> {\n\n        int a, b;\n\n        public Data(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        @Override\n        public int compareTo(Data o) {\n            if (a == o.a) {\n                return Integer.compare(b, o.b);\n            }\n            return Integer.compare(a, o.a);\n        }\n\n        public static void sort(int a[]) {\n            Data d[] = new Data[a.length];\n            for (int i = 0; i < a.length; i++) {\n                d[i] = new Data(a[i], 0);\n            }\n            Arrays.sort(d);\n            for (int i = 0; i < a.length; i++) {\n                a[i] = d[i].a;\n            }\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long power(long long a, long long b, long long n) {\n  long long ans = 1;\n  while (b) {\n    ans *= a;\n    if (ans >= n) return n;\n    b--;\n  }\n  return ans;\n}\nint main() {\n  long long n, k;\n  cin >> n >> k;\n  long long a[n];\n  for (long long i = 0; i < n; i++) cin >> a[i];\n  sort(a, a + n);\n  vector<pair<long long, long long>> freq;\n  for (long long i = 0; i < n; i++) {\n    long long j = i;\n    long long cnt = 0;\n    while (j < n && a[i] == a[j]) j++;\n    freq.push_back(make_pair(a[i], j - i));\n    i = j - 1;\n  }\n  long long n1 = freq.size();\n  long long min_bits = n;\n  k *= 8;\n  long long low = 0;\n  long long high = n;\n  while (low <= high) {\n    long long mid = (low + high) / 2;\n    long long bits = mid * n;\n    if (bits <= k) {\n      min_bits = mid;\n      low = mid + 1;\n    } else\n      high = mid - 1;\n  }\n  long long min_nums = power(2, min_bits, n);\n  long long ans = n;\n  long long sum = 0;\n  for (long long i = 0; i < min(n1, min_nums); i++) {\n    sum += freq[i].second;\n  }\n  ans = min(ans, n - sum);\n  long long j = 0;\n  for (long long i = min(n1, min_nums); i < n1; i++) {\n    sum += freq[i].second - freq[j].second;\n    j++;\n    ans = min(ans, n - sum);\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyScanner in = new MyScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, MyScanner in, PrintWriter out) {\n            int n, I;\n            n = in.nextInt();\n            I = in.nextInt() * 8;\n\n            int bits = I / n;\n            if (bits >= 20) {\n                out.println(0);\n                return;\n            }\n            int possibleCountOfDifferentElement = 1 << bits;\n\n            Integer[] a = new Integer[n];\n            Map<Integer, Integer> cnt = new HashMap<>();\n\n            for (int i = 0; i < a.length; i++) {\n                a[i] = in.nextInt();\n                cnt.put(a[i], cnt.getOrDefault(a[i], 0) + 1);\n            }\n\n\n            if (cnt.size() <= possibleCountOfDifferentElement) {\n                out.println(0);\n                return;\n            }\n\n            Arrays.sort(a);\n\n            int[] diffs = new int[cnt.size()];\n            int last = 0;\n            for (int i = 0; i < a.length; ) {\n                diffs[last] = cnt.get(a[i]);\n                i += diffs[last];\n                last++;\n            }\n\n            long answer = 0;\n            long curSum = 0;\n            for (int i = 0; i < possibleCountOfDifferentElement; i++) {\n                curSum += diffs[i];\n            }\n\n            answer = curSum;\n\n            for (int i = possibleCountOfDifferentElement; i < diffs.length; i++) {\n                curSum += diffs[i];\n                curSum -= diffs[i - possibleCountOfDifferentElement];\n                answer = Math.max(answer, curSum);\n            }\n            out.println(n - answer);\n        }\n\n    }\n\n    static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner(InputStream io) {\n            br = new BufferedReader(new InputStreamReader(io));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, I;\n  cin >> n >> I;\n  int arr[n];\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i];\n  }\n  sort(arr, arr + n);\n  vector<long long> freq;\n  int num = 1;\n  for (int i = 1; i < n; i++) {\n    if (arr[i - 1] != arr[i]) {\n      freq.push_back(num);\n      num = 1;\n    } else {\n      num++;\n    }\n  }\n  freq.push_back(num);\n  int m = 8 * I;\n  int i = 0, r = freq.size() - 1;\n  int K = m / n;\n  K = K > 30 ? pow(2, 30) : pow(2, K);\n  long long mx = 0;\n  int dist = r + 1;\n  if (dist <= K) {\n    cout << \"0\" << endl;\n  } else {\n    int l = 0;\n    r = 0;\n    mx = 0;\n    int x = 0;\n    while (x < K) {\n      mx += freq[x];\n      x++;\n    }\n    r = x;\n    long long y = mx;\n    while (r < dist) {\n      y = y - freq[l] + freq[r];\n      mx = max(mx, y);\n      r++;\n      l++;\n    }\n    long long sum = 0;\n    for (int i = 0; i < freq.size(); i++) sum += freq[i];\n    long long ans = sum - mx;\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\nimport java.util.Stack;\nimport java.util.TreeMap;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner s = new Scanner(System.in);\n\t\tTreeMap<Integer, Integer> map = new TreeMap<Integer, Integer>();\n//\t\tint n = s.nextInt(), I = s.nextInt();\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] input = reader.readLine().split(\" \");\n\t\tint n = Integer.parseInt(input[0]), I = Integer.parseInt(input[1]);\n\t\tinput = reader.readLine().split(\" \");\n\t\tfor(int i = 0; i < n; i++) {\n\t\t     int a = Integer.parseInt(input[i]);\n\t\t     if(map.containsKey(a)) {\n\t\t          map.put(a, map.get(a) + 1);\n\t\t     } else {\n\t\t          map.put(a, 1);\n\t\t     }\n\t\t}\n\t\tint k = (int)Math.floor((I * 8) / n);\n\t\tint size = (k * Math.log(2) <= Math.log(map.size())) ? (int)Math.pow(2, k) : map.size();\n\t\tint[] arr = new int[map.size()];\n\t\tint i = 0, total = 0;\n\t\tfor(Integer key : map.keySet()) {\n\t\t\tarr[i++] = map.get(key);\n\t\t\ttotal += map.get(key);\n\t\t}\n\t\tint sum = 0, ans = Integer.MAX_VALUE;\n\t\tfor(i = 0; i < size; i++) {\n\t\t\tsum += arr[i];\n\t\t}\n\t\tans = total - sum;\n\t\tfor(i = size; i < arr.length; i++) {\n\t\t\tsum += arr[i] - arr[i - size];\n\t\t\tans = Math.min(ans, total - sum);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n}\n"
        },
        {
            "language": 3,
            "solution": "n,I=list(map(int,input().strip().split()))\nl=list(map(int,input().strip().split()))\nl.sort()\nk=2**((I*8)//n)\nsol=[]\ni=0\nwhile i<n-1:\n    count=1\n    while i<n-1 and l[i]==l[i+1]:\n        count+=1\n        i+=1\n    sol.append(count)\n    i+=1\nif len(l)>1 and l[-1]!=l[-2]:\n    sol.append(1)\ns=0\ni=0\nwhile i<k and i<len(sol):\n    s+=sol[i]\n    i+=1\nll=0\ntemp=s\nwhile i<len(sol):\n    temp+=sol[i]\n    temp-=sol[ll]\n    if temp>s:\n        s=temp\n    i+=1\n    ll+=1\nif n-s<0 or n==1:\n    print(0)\nelse:\n    print(n-s)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing namespace chrono;\nvoid _print(long long t) { cerr << t; }\nvoid _print(int t) { cerr << t; }\nvoid _print(string t) { cerr << t; }\nvoid _print(char t) { cerr << t; }\nvoid _print(long double t) { cerr << t; }\nvoid _print(double t) { cerr << t; }\nvoid _print(unsigned long long t) { cerr << t; }\ntemplate <class T, class V>\nvoid _print(pair<T, V> p);\ntemplate <class T>\nvoid _print(vector<T> v);\ntemplate <class T>\nvoid _print(set<T> v);\ntemplate <class T, class V>\nvoid _print(map<T, V> v);\ntemplate <class T>\nvoid _print(multiset<T> v);\ntemplate <class T, class V>\nvoid _print(pair<T, V> p) {\n  cerr << \"{\";\n  _print(p.first);\n  cerr << \",\";\n  _print(p.second);\n  cerr << \"}\";\n}\ntemplate <class T>\nvoid _print(vector<T> v) {\n  cerr << \"[ \";\n  for (T i : v) {\n    _print(i);\n    cerr << \" \";\n  }\n  cerr << \"]\";\n}\ntemplate <class T>\nvoid _print(set<T> v) {\n  cerr << \"[ \";\n  for (T i : v) {\n    _print(i);\n    cerr << \" \";\n  }\n  cerr << \"]\";\n}\ntemplate <class T>\nvoid _print(multiset<T> v) {\n  cerr << \"[ \";\n  for (T i : v) {\n    _print(i);\n    cerr << \" \";\n  }\n  cerr << \"]\";\n}\ntemplate <class T, class V>\nvoid _print(map<T, V> v) {\n  cerr << \"[ \";\n  for (auto i : v) {\n    _print(i);\n    cerr << \" \";\n  }\n  cerr << \"]\";\n}\nlong long gcd(long long a, long long b) {\n  if (b > a) {\n    return gcd(b, a);\n  }\n  if (b == 0) {\n    return a;\n  }\n  return gcd(b, a % b);\n}\nlong long expo(long long a, long long b, long long mod) {\n  long long res = 1;\n  while (b > 0) {\n    if (b & 1) res = (res * a) % mod;\n    a = (a * a) % mod;\n    b = b >> 1;\n  }\n  return res;\n}\nvoid extendgcd(long long a, long long b, long long *v) {\n  if (b == 0) {\n    v[0] = 1;\n    v[1] = 0;\n    v[2] = a;\n    return;\n  }\n  extendgcd(b, a % b, v);\n  long long x = v[1];\n  v[1] = v[0] - v[1] * (a / b);\n  v[0] = x;\n  return;\n}\nlong long mminv(long long a, long long b) {\n  long long arr[3];\n  extendgcd(a, b, arr);\n  return arr[0];\n}\nlong long mminvprime(long long a, long long b) { return expo(a, b - 2, b); }\nbool revsort(long long a, long long b) { return a > b; }\nvoid swap(int &x, int &y) {\n  int temp = x;\n  x = y;\n  y = temp;\n}\nlong long combination(long long n, long long r, long long m, long long *fact,\n                      long long *ifact) {\n  long long val1 = fact[n];\n  long long val2 = ifact[n - r];\n  long long val3 = ifact[r];\n  return (((val1 * val2) % m) * val3) % m;\n}\nvoid google(int t) { cout << \"Case #\" << t << \": \"; }\nvector<long long> sieve(int n) {\n  int *arr = new int[n + 1]();\n  vector<long long> vect;\n  for (int i = 2; i <= n; i++)\n    if (arr[i] == 0) {\n      vect.push_back(i);\n      for (int j = 2 * i; j <= n; j += i) arr[j] = 1;\n    }\n  return vect;\n}\nlong long mod_add(long long a, long long b, long long m) {\n  a = a % m;\n  b = b % m;\n  return (((a + b) % m) + m) % m;\n}\nlong long mod_mul(long long a, long long b, long long m) {\n  a = a % m;\n  b = b % m;\n  return (((a * b) % m) + m) % m;\n}\nlong long mod_sub(long long a, long long b, long long m) {\n  a = a % m;\n  b = b % m;\n  return (((a - b) % m) + m) % m;\n}\nlong long mod_div(long long a, long long b, long long m) {\n  a = a % m;\n  b = b % m;\n  return (mod_mul(a, mminvprime(b, m), m) + m) % m;\n}\nlong long phin(long long n) {\n  long long number = n;\n  if (n % 2 == 0) {\n    number /= 2;\n    while (n % 2 == 0) n /= 2;\n  }\n  for (long long i = 3; i <= sqrt(n); i += 2) {\n    if (n % i == 0) {\n      while (n % i == 0) n /= i;\n      number = (number / i * (i - 1));\n    }\n  }\n  if (n > 1) number = (number / n * (n - 1));\n  return number;\n}\nvoid solve() {\n  long long n;\n  long long I;\n  cin >> n >> I;\n  long long arr[n];\n  for (long long i = 0; i < n; i++) cin >> arr[i];\n  long long max_k_allowed = min((8 * I) / n, 25LL);\n  long long distinct_allowed = 1;\n  while (max_k_allowed > 0) {\n    distinct_allowed *= 2;\n    max_k_allowed--;\n  }\n  map<long long, long long> m1;\n  for (long long i = 0; i < n; i++) m1[arr[i]]++;\n  vector<long long> v1;\n  for (auto i : m1) {\n    v1.push_back(i.second);\n  }\n  long long current_distinct = (long long)v1.size();\n  long long taking_up = 0;\n  long long i = 0;\n  long long j = current_distinct - 1;\n  if (distinct_allowed >= current_distinct)\n    cout << 0 << \"\\n\";\n  else {\n    long long ans = 0;\n    vector<long long> prefix_sum;\n    long long sum = 0;\n    for (auto i : v1) {\n      sum += i;\n      prefix_sum.push_back(sum);\n    }\n    for (int i = 0; i <= current_distinct - distinct_allowed; i++) {\n      long long val = prefix_sum[i + distinct_allowed - 1] -\n                      (i > 0 ? prefix_sum[i - 1] : 0);\n      ans = max(ans, val);\n    }\n    cout << n - ans << \"\\n\";\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  auto start1 = high_resolution_clock::now();\n  solve();\n  auto stop1 = high_resolution_clock::now();\n  auto duration = duration_cast<microseconds>(stop1 - start1);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\nimport static java.lang.Math.*;\n\npublic class code0 {\n    private static boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n    private static Reader in;\n    private static PrintWriter out;\n    ////////////////////////////////////////////////////////////////////////////////////////////////////\n    private static int min(int... a){int min=a[0]; for(int i:a) min=Math.min(min, i); return min;}\n    private static int max(int... a){int max=a[0]; for(int i:a) max=Math.max(max, i); return max;}\n    private static long min(long... a){long min=a[0]; for(long i:a)min=Math.min(min, i); return min;}\n    private static long max(long... a){long max=a[0]; for(long i:a)max=Math.max(max, i); return max;}\n    private static String strm(String str, long m) {\n        String ans=\"\";\n        while(m>0) {\n            if(m%2==1) ans=ans.concat(str);\n            str=str.concat(str); m>>=1;\n        } return ans;\n    }\n    private static long mod(long a, long mod) {long res = a%mod; return res>=0 ? res : res+mod;}\n    private static int mod(int a, int mod) {int res = a%mod; return res>=0 ? res : res+mod;}\n    private static long modpow(long x, int n, int mod) {\n        long res = 1;\n        for (long p = x; n > 0; n >>= 1, p = mod((mod(p, mod)*mod(p, mod)),  mod)) {\n            if ((n & 1) != 0) res = mod(mod(res, mod) * mod(p, mod), mod);\n        }\n        return res;\n    }\n    private static long gcd(long a, long b) {return b == 0 ? Math.abs(a) : gcd(b, a % b);}\n    private static int gcd(int a, int b) {return b == 0 ? Math.abs(a) : gcd(b, a % b);}\n    private static long gcd(long... a) {long gcd=a[0]; for(long x:a) gcd=gcd(gcd, x); return gcd;}\n    private static int gcd(int... a) {int gcd=a[0]; for(int x:a) gcd=gcd(gcd, x); return gcd;}\n    private static long lcm(long a, long b) {return Math.abs(a / gcd(a, b) * b);}\n    private static boolean isEven(int num) {return ((num&1) == 0);}\n    private static boolean isOdd(int num) {return !isEven(num);}\n    private static boolean isEven(long num) {return ((num&1) == 0);}\n    private static boolean isOdd(long num) {return !isEven(num);}\n    private static class Pair {\n        public int x, y;\n        public Pair(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n        @Override\n        public boolean equals(Object obj) {\n            if (obj == this) return true;\n            if (!(obj instanceof Pair)) return false;\n            Pair pair = (Pair)obj;\n            return this.x == pair.x && this.y == pair.y;\n        }\n        @Override\n        public String toString() {\n            return (\"(\" + this.x + \",\" + this.y + \")\");\n        }\n        @Override\n        public int hashCode() {\n            return (this.x+\" \"+this.y).hashCode();\n        }\n    }\n    private static class Triplet {\n        public int x, y, z;\n        public Triplet(int x, int y, int z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }\n        @Override\n        public boolean equals(Object obj) {\n            if (obj == this) return true;\n            if (!(obj instanceof Triplet)) return false;\n            Triplet triplet = (Triplet)obj;\n            return this.x == triplet.x && this.y == triplet.y && this.z == triplet.z;\n        }\n        @Override\n        public String toString() {\n            return (\"(\" + this.x + \",\" + this.y + \",\" + this.z + \")\");\n        }\n        @Override\n        public int hashCode() {\n            return (this.x+\" \"+this.y+\" \"+this.z).hashCode();\n        }\n    }\n    ////////////////////////////////////////////////////////////////////////////////////////////////////\n    static class Reader {\n        private BufferedReader br;\n        private StringTokenizer token;\n        private Reader(FileReader obj) {\n            br = new BufferedReader(obj, 32768);\n            token = null;\n        }\n        private Reader() {\n            br = new BufferedReader(new InputStreamReader(System.in), 32768);\n            token = null;\n        }\n        private String next() {\n            while(token == null || !token.hasMoreTokens()) {\n                try {\n                    token = new StringTokenizer(br.readLine());\n                } catch (Exception e) {e.printStackTrace();}\n            } return token.nextToken();\n        }\n        private String nextLine() {\n            String str=\"\";\n            try {\n                str = br.readLine();\n            } catch (Exception e) {e.printStackTrace();}\n            return str;\n        }\n        private int nextInt() {return Integer.parseInt(next());}\n        private long nextLong() {return Long.parseLong(next());}\n        private double nextDouble() {return Double.parseDouble(next());}\n        private long[] nextLongArr(int n) {\n            long[] arr = new long[n]; for(int i=0; i<n; i++) arr[i] = nextLong(); return arr;\n        }\n        private int[] nextIntArr(int n) {\n            int[] arr = new int[n]; for(int i=0; i<n; i++) arr[i] = nextInt(); return arr;\n        }\n    }\n    ////////////////////////////////////////////////////////////////////////////////////////////////////\n    private static final int mod = 1_000_000_007;\n    private static HashSet<Integer> hs = new HashSet<>();\n    private static HashMap<Integer, Integer> hm = new HashMap<>();\n    \n    private static void solve() throws Exception {\n        int n = in.nextInt(), I = in.nextInt();\n        int[] arr = new int[n];\n        for (int i=0; i<n; i++) {\n            int x = in.nextInt();\n            arr[i] = x;\n            hs.add(x);\n            hm.compute(x, (k, v) -> v == null ? 1 : v+1);\n        }\n        int k = (I*8)/n;\n        if ((double)k >= log(hs.size())/log(2)) {out.printf(\"%d\\n\", 0); return;}\n        int K = 1<<(k);\n        ArrayList<Integer> al = new ArrayList<>(hs);\n        Collections.sort(al);\n        int mark0 = 0, mark1 = 0+K-1;\n        int windowSum = 0;\n        for (int i=mark1+1; i<al.size(); i++) {\n            windowSum += hm.get(al.get(i));\n        }\n        int ans = windowSum;\n        while (mark1 < al.size()-1) {\n            windowSum = windowSum + hm.get(al.get(mark0)) - hm.get(al.get(mark1+1));\n            mark0++; mark1++;\n            ans = min(ans, windowSum);\n        }\n        out.printf(\"%d\\n\", ans);\n    }\n    private static void run() throws Exception {\n        // in = new Reader();\n        // in = new Reader(new FileReader(\"input.txt\"));\n        // out = new PrintWriter(new FileWriter(\"output.txt\"));\n        in = oj ? new Reader() : new Reader(new FileReader(\"/home/raiden/Desktop/input.txt\"));\n        out = new PrintWriter(System.out);\n        // out = new PrintWriter(new FileWriter(\"/home/raiden/Desktop/output.txt\"));\n        long ti = System.currentTimeMillis();\n        solve(); out.flush();\n        if (!oj) System.out.println(\"\\n\"+(System.currentTimeMillis()-ti)+\"ms\");\n    }\n    public static void main(String[] args) throws Exception {run();}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n, b;\n  cin >> n >> b;\n  int max_dist = 1 << (min(30, (b * 8) / n));\n  map<int, int> mp;\n  for (int i = 0; i < n; ++i) {\n    int x;\n    cin >> x;\n    mp[x] += 1;\n  }\n  cerr << (\"max_dist\") << \": \" << (max_dist) << ' ' << endl;\n  int ans = 0, res = 0;\n  auto it = mp.begin();\n  int curr_dist = 0;\n  for (auto &p : mp) {\n    curr_dist += 1;\n    ans += p.second;\n    if (curr_dist > max_dist) {\n      ans -= it->second;\n      ++it;\n    }\n    res = max(res, ans);\n  }\n  cout << n - res << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int SUM = 0, ff = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') ff = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    SUM = (SUM << 3) + (SUM << 1) + (ch ^ 48);\n    ch = getchar();\n  }\n  return SUM * ff;\n}\nconst int N = 400010;\nint a[N];\nint n, k, I;\nint ans = 0x3f3f3f3f;\nint main() {\n  n = read(), I = read();\n  I = I * 8 / n, k = 1;\n  for (int i = 1; i <= I; i++) {\n    k <<= 1;\n    if (k >= n) {\n      puts(\"0\");\n      return 0;\n    }\n  }\n  for (int i = 1; i <= n; i++) a[i] = read();\n  sort(a + 1, a + n + 1);\n  a[0] = -1;\n  int sum = 0, l = 1, r = 0;\n  while (r < n) {\n    while (r < n && (sum < k || (a[r] == a[r + 1] && sum == k))) {\n      sum += a[r] != a[r + 1];\n      r++;\n    }\n    ans = min(ans, n - (r - l + 1));\n    while (l < r && a[l] == a[l + 1]) l++;\n    l++;\n    sum--;\n  }\n  ans = min(ans, n - (r - l + 1));\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long Nfact = 200005;\nconst long long mod = 1000000007;\nconst long long Nsieve = 1000005;\nvector<bool> is_prime(Nsieve, true);\nvector<long long> spf(Nsieve + 1);\nvoid sieve() {\n  for (long long i = 1; i < Nsieve + 1; i++) {\n    spf[i] = i;\n  }\n  is_prime[0] = is_prime[1] = false;\n  for (long long i = 2; i * i <= Nsieve; i++) {\n    if (is_prime[i]) {\n      for (long long j = i * i; j <= Nsieve; j += i) {\n        if (is_prime[j]) spf[j] = i;\n        is_prime[j] = false;\n      }\n    }\n  }\n}\nvoid divisors(vector<long long> &divs, long long x) {\n  map<long long, long long> mappy;\n  while (x != 1) {\n    mappy[spf[x]]++;\n    x /= spf[x];\n  }\n  divs.clear();\n  divs.push_back(1);\n  for (auto p : mappy) {\n    long long len = divs.size();\n    for (long long q = 0; q < len * p.second; q++) {\n      divs.push_back(divs[q] * p.first);\n    }\n  }\n  sort(divs.begin(), divs.end());\n}\nlong long bSearch(long long l, long long r, long long x,\n                  vector<long long> arr) {\n  while (l <= r) {\n    long long m = l + (r - l) / 2;\n    if (arr[m] == x) return m;\n    if (arr[m] < x)\n      l = m + 1;\n    else\n      r = m - 1;\n  }\n  return -1;\n}\nvoid primeFactors(long long n) {\n  while (n % 2 == 0) {\n    n = n / 2;\n  }\n  for (long long i = 3; i <= sqrt(n); i += 2) {\n    while (n % i == 0) {\n      n = n / i;\n    }\n  }\n  if (n > 2) cout << n << \" \";\n}\nlong long power(long long x, long long y, long long p) {\n  long long res = 1;\n  x = x % p;\n  while (y > 0) {\n    if (y & 1) res = (res * x) % p;\n    y = y >> 1;\n    x = (x * x) % p;\n  }\n  return res;\n}\nlong long modulo(long long a, long long b) {\n  long long c = a % b;\n  return (c < 0) ? c + b : c;\n}\nlong long mul(long long x, long long y) { return (x * y) % mod; }\nlong long inv(long long x) { return power(x, mod - 2, mod); }\nlong long divide(long long x, long long y) { return mul(x, inv(y)); }\nlong long fact[Nfact];\nvoid precalc() {\n  fact[0] = 1;\n  for (long long i = 1; i < Nfact; i++) fact[i] = mul(fact[i - 1], i);\n}\nlong long nCr(long long n, long long k) {\n  if (n < k) return 0;\n  return divide(fact[n], mul(fact[k], fact[n - k]));\n}\nvoid solve() {\n  long long n, I;\n  cin >> n >> I;\n  vector<long long> vec(n);\n  for (auto &it : vec) cin >> it;\n  long long val = (I * 8) / n;\n  long long K;\n  if (val <= 19) {\n    K = 1LL << val;\n  } else {\n    cout << 0 << \"\\n\";\n    return;\n  }\n  map<long long, long long> hash;\n  for (long long i = 0; i < n; i++) {\n    hash[vec[i]]++;\n  }\n  if ((long long)hash.size() <= K) {\n    cout << 0 << \"\\n\";\n    return;\n  }\n  vector<pair<long long, long long> > res;\n  for (auto i : hash) {\n    res.push_back({i.first, i.second});\n  }\n  vector<long long> pre((long long)res.size());\n  pre[0] = res[0].second;\n  for (long long i = 1; i < (long long)pre.size(); i++) {\n    pre[i] += pre[i - 1] + res[i].second;\n  }\n  long long mini = n;\n  for (long long i = 0; i < (long long)res.size() - K + 1; i++) {\n    if (i == 0) {\n      mini = min(mini, n - pre[i + K - 1]);\n    } else {\n      mini = min(mini, n - (pre[i + K - 1] - pre[i - 1]));\n    }\n  }\n  cout << mini << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long t = 1;\n  while (t--) {\n    solve();\n  }\n  cerr << \"time taken : \" << (float)clock() / CLOCKS_PER_SEC << \" secs\"\n       << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\nconst int N = 4 * 1e5 + 100;\nint quick_power(int n, int k) {\n  long long int temp = n;\n  long long int ans = 1;\n  while (k) {\n    if (k & 1) ans = (ans * temp) % MOD;\n    k = k >> 1;\n    temp = (temp * temp) % MOD;\n  }\n  return (int)ans;\n}\nint main() {\n  int n, I;\n  int a;\n  cin >> n >> I;\n  vector<int> vt, vtt;\n  for (int i = 0; i < n; i++) {\n    cin >> a;\n    vt.push_back(a);\n    vtt.push_back(a);\n  }\n  sort(vt.begin(), vt.end());\n  sort(vtt.begin(), vtt.end());\n  vtt.resize(unique(vtt.begin(), vtt.end()) - vtt.begin());\n  int size = vtt.size();\n  int ans = 0;\n  int k = 8 * I / n;\n  double temp = log(size) / log(2);\n  if (k >= temp)\n    cout << 0 << endl;\n  else {\n    int kk = quick_power(2, k);\n    for (int i = 0; i <= size - kk; i++) {\n      int x = lower_bound(vt.begin(), vt.end(), vtt[i]) - vt.begin();\n      int y = upper_bound(vt.begin(), vt.end(), vtt[i + kk - 1]) - vt.begin();\n      ans = max(ans, y - x);\n    }\n    cout << n - ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.util.*;\n\npublic class MP3 {\n    private int countModified(int threadHold, Map<Integer, Integer> map) {\n        int currDist = map.size();\n        int tmp = (int)(Math.log(currDist) / Math.log(2));\n        if (Math.pow(2, tmp) < currDist) {\n            tmp += 1;\n        }\n        while (tmp > threadHold) {\n            currDist--;\n            tmp = (int)(Math.log(currDist) / Math.log(2));\n            if (Math.pow(2, tmp) < currDist) {\n                tmp += 1;\n            }\n        }\n\n        if (currDist == map.size()) {\n            return 0;\n        }\n\n        int[] sum = new int[map.size()];\n        int pnt = 0;\n        for (int key : map.keySet()) {\n            sum[pnt] = (pnt == 0 ? 0 : sum[pnt - 1]) + map.get(key);\n            pnt++;\n        }\n\n        int change = Integer.MAX_VALUE;\n        int changeKeys = map.size() - currDist;\n        for (int i = 0; i <= changeKeys; i++) {\n            int j = changeKeys - i;\n\n            int sub = 0;\n            sub += i == 0 ? 0 : sum[ i- 1];\n            sub += j == 0 ? 0 : (sum[map.size() - 1] - sum[map.size() - 1 - j]);\n\n            change = Math.min(change, sub);\n        }\n\n        return change;\n    }\n\n    public static void main(String[] args) {\n        MyScanner ms = new MyScanner();\n        int len = ms.nextInt();\n        int diskBytes= ms.nextInt();\n\n        Map<Integer, Integer> map = new TreeMap<>();\n        for (int i = 0; i < len; i++) {\n            int num = ms.nextInt();\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n\n        MP3 mp3 = new MP3();\n        int numModified = mp3.countModified(diskBytes * 8 / len, map);\n        System.out.println(numModified);\n    }\n\n    static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\n\nn, I = map(int, input().split())\nif I >= n*round(math.log(n,2)+0.5)/8:\n    print(0)\nelse:\n    a = sorted([x for x in map(int, input().split())])\n    a=[-1]+a\n    b=[i for i in range(n) if a[i] < a[i+1]]\n    ans = set()\n    for x in zip(b, b[2**(I*8//n):]+[n]):\n        ans.add(x[1]-x[0])\n    print(n-max(ans))"
        },
        {
            "language": 3,
            "solution": "n, _i = map(int, input().split())\n_i = _i * 8 // n\n\na = [int(_) for _ in input().split()]\na.sort()\n\np = 1\nwhile _i > 0 and p <= 1e7:\n    p <<= 1\n    _i -= 1\n\nx = 1\nc = 1\nv = 0\n\nfor i in range(1, n):\n    if a[i] != a[i - 1]:\n        c += 1\n\n    if c > p:\n        while a[v] == a[v + 1] and v < n - 1:\n            v += 1\n        v += 1\n        c -= 1\n\n    x = max(x, i - v + 1)\n\nprint(n - x)\n"
        },
        {
            "language": 1,
            "solution": "import time\n\nif True:\n\tarr = map(int,raw_input().split(\" \"))\n\tn,I = arr[:2]\n\tarr = map(int,raw_input().split(\" \"))\nelse:\n\tn,I = 2,100000000\n\tarr = range(n)\n\nk = int(8*I/n)\nif k >30:\n\tK = 2**30\nelse:\n\tK = 2**k\n\ndic = {}\t\n\nfor i in xrange(n):\n\tif not dic.has_key(arr[i]):\n\t\tdic[arr[i]] = 1\n\telse:\n\t\tdic[arr[i]] += 1\n\nkeys = sorted(dic.keys())\nvalues = [dic[i] for i in keys]\ndp = sum(values[:K])\nmaxv = dp\n\nif K>=len(values):\n\tprint 0\nelse:\n\tfor i in xrange(K,min(n,len(values))):\n\t\tdp \t+= values[i]-values[i-K]\n\t\tmaxv = max(maxv,dp)\n\tprint n-maxv\n\n\n\n\n\n"
        },
        {
            "language": 3,
            "solution": "import math\n\ndef main():\n    n,i = map(int,input().split())\n    max_bits = (8*i)//n\n    dist_values = 2**max_bits\n    files = list(map(int,input().split()))\n    files.sort()\n\n    dist_files = []\n    curr = files[0]\n    count = 0\n    for i in files:\n        if i == curr:\n            count += 1\n        else:\n            dist_files.append(count)\n            curr = i\n            count = 1\n\n    dist_files.append(count)\n    dp = []\n    for i in dist_files:\n        if not dp:\n            dp.append(i)\n        else:\n            dp.append(dp[-1]+i)\n\n    min_val = float('inf')\n    for i in range(len(dp)):\n        change = 0\n        if i > 0:\n            change += dp[i-1]\n        if i+dist_values-1 < len(dp):\n            change += dp[-1]-dp[i+dist_values-1]\n        min_val = min(min_val,change)\n\n    print(min_val)\n\n\nmain()\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.nio.CharBuffer;\nimport java.util.ArrayList;\nimport java.util.NoSuchElementException;\nimport java.util.TreeMap;\n\npublic class P1199C_2 {\n\n    public static void main(String[] args) {\n        SimpleScanner scanner = new SimpleScanner(System.in);\n        PrintWriter writer = new PrintWriter(System.out);\n\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int bit = 0;\n        while ((1 << bit) < n)\n            ++bit;\n        bit = Math.min(bit, 8 * m / n);\n        int limit = 1 << bit;\n        TreeMap<Integer, Integer> countMap = new TreeMap<>();\n        for (int i = 0; i < n; ++i) {\n            int t = scanner.nextInt();\n            countMap.compute(t, (k, v) -> v == null ? 1 : v + 1);\n        }\n        if (countMap.size() <= limit) {\n            writer.println(0);\n        } else {\n            ArrayList<Integer> countList = new ArrayList<>(countMap.values());\n            int count = 0;\n            for (int i = 0; i < limit; ++i)\n                count += countList.get(i);\n            int ans = n - count;\n            for (int i = limit; i < countList.size(); ++i) {\n                count -= countList.get(i - limit);\n                count += countList.get(i);\n                ans = Math.min(ans, n - count);\n            }\n            writer.println(ans);\n        }\n        writer.close();\n    }\n\n    private static class SimpleScanner {\n\n        private static final int BUFFER_SIZE = 10240;\n\n        private Readable in;\n        private CharBuffer buffer;\n        private boolean eof;\n\n        SimpleScanner(InputStream in) {\n            this.in = new BufferedReader(new InputStreamReader(in));\n            buffer = CharBuffer.allocate(BUFFER_SIZE);\n            buffer.limit(0);\n            eof = false;\n        }\n\n\n        private char read() {\n            if (!buffer.hasRemaining()) {\n                buffer.clear();\n                int n;\n                try {\n                    n = in.read(buffer);\n                } catch (IOException e) {\n                    n = -1;\n                }\n                if (n <= 0) {\n                    eof = true;\n                    return '\\0';\n                }\n                buffer.flip();\n            }\n            return buffer.get();\n        }\n\n        void checkEof() {\n            if (eof)\n                throw new NoSuchElementException();\n        }\n\n        char nextChar() {\n            checkEof();\n            char b = read();\n            checkEof();\n            return b;\n        }\n\n        String next() {\n            char b;\n            do {\n                b = read();\n                checkEof();\n            } while (Character.isWhitespace(b));\n            StringBuilder sb = new StringBuilder();\n            do {\n                sb.append(b);\n                b = read();\n            } while (!eof && !Character.isWhitespace(b));\n            return sb.toString();\n        }\n\n        int nextInt() {\n            return Integer.valueOf(next());\n        }\n\n        long nextLong() {\n            return Long.valueOf(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long n, i, j, x, h, lol, ans = 1000000000, l, y, k;\n  cin >> n >> l;\n  map<long long, long long> mp;\n  map<long long, long long>::iterator it;\n  long long a[n];\n  for (i = 0; i < n; i++) {\n    cin >> x;\n    mp[x]++;\n  }\n  k = ((8 * l) / n);\n  if (log2(mp.size()) <= k)\n    cout << 0 << endl;\n  else {\n    long long start = 0, end = mp.size(), mid, suitabledis = 0;\n    while (start <= end) {\n      mid = (start + end) / 2;\n      if (log2(mid) <= k) {\n        suitabledis = mid;\n        start = mid + 1;\n      } else\n        end = mid - 1;\n    }\n    long long b[mp.size()], sum = 0, i = 0;\n    for (auto it = mp.begin(); mp.end() != it; it++) {\n      sum += it->second;\n      b[i] = sum;\n      i++;\n    }\n    for (i = 0; i < mp.size() - suitabledis; i++) {\n      lol = n;\n      if (i > 0) {\n        lol = b[i + suitabledis - 1] - b[i - 1];\n      } else\n        lol = b[i + suitabledis - 1];\n      ans = min(n - lol, ans);\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from itertools import groupby as gb\n\nN, I = map(int,input().split())\nA = list(map(int,input().split()))\nA = sorted(A)\nl = []\nG = gb(A)\nfor k, v in G:\n    l.append(len(list(v)))\n\nk = 100\nwhile True:\n    if N * k > 8 * I:\n        k -= 1\n    else:\n        break\nK = 2 ** k\n\nNN = len(l)\nif NN <= K:\n    print(0)\n    exit()\n\nsm = sum(l[:K])\nmx = sm\n\nfor i in range(K, NN):\n    sm += l[i] - l[i - K]\n    mx = max(mx, sm)\n\nprint(sum(l) - mx)"
        },
        {
            "language": 3,
            "solution": "#If FastIO not needed, used this and don't forget to strip\n#import sys, math\n#input = sys.stdin.readline\n\"\"\"\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nimport heapq as h \nfrom bisect import bisect_left, bisect_right\n\nfrom types import GeneratorType\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        import os\n        self.os = os\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            self.os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\"\"\" \nimport collections as col\n\ndef getInts():\n    return [int(s) for s in input().split()]\n\ndef getInt():\n    return int(input())\n\ndef getStrs():\n    return [s for s in input().split()]\n\ndef getStr():\n    return input()\n\ndef listStr():\n    return list(input())\n\nMOD = 10**9+7\n\n\n\"\"\"\nK such that N * log2(K) <= I, ceil(log2(K)) <= I/N, K <= 2**(I//N)\n\"\"\"\n\ndef solve():\n    N, i = getInts()\n    I = 8*i\n    A = getInts()\n    if I//N > 20:\n        return 0\n    K = pow(2,I//N)\n    A.sort()\n    B = []\n    curr = 1\n    for n in range(1,N):\n        if A[n] == A[n-1]:\n            curr += 1\n        else:\n            B.append(curr)\n            curr = 1\n    B.append(curr)\n    L = len(B)\n    if L <= K:\n        return 0\n    #Need to delete len(arr)-K\n    x = sum(B[:K])\n    ans = N-x\n    #print(B)\n    for j in range(K,L):\n        x += B[j]\n        x -= B[j-K]\n        ans = min(ans,N-x)\n    return ans\n    \n#for _ in range(getInt()):\nprint(solve())"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict as dd\nn,I=map(int,input().split())\nl=list(map(int,input().split()))\nll=[]\nlast=-1\nl.sort()\nfor i in l:\n    if(i!=last):\n        ll.append(1)\n        last=i\n    else:\n        ll[-1]+=1\nk=len(ll)\nwhile k > (1 << ((8*I)//n)):\n    k -= 1\nans=0\nfor i in range(k):\n    ans+=ll[i]\nres=ans\nfor i in range(k,len(ll)):\n    ans=ans+ll[i]-ll[i-k]\n    res=max(res,ans)\nprint(sum(ll)-res)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nbool tomax(T &x, T y) {\n  if (x < y) return x = y, 1;\n  return 0;\n}\ntemplate <class T>\nbool tomin(T &x, T y) {\n  if (x > y) return x = y, 1;\n  return 0;\n}\nint A[400005], n, K;\nint cnt[400005], B[400005], res;\nvoid Add(int x, int v) {\n  if (cnt[x] == 0 && v > 0) res++;\n  if (cnt[x] == 1 && v < 0) res--;\n  cnt[x] += v;\n}\nbool Check() {\n  int p = log2(res);\n  if (1.0 * pow(2, p) != 1.0 * res) p++;\n  return 1LL * p * n <= 8LL * K;\n}\nbool check(int x) {\n  if (x == n) return 1;\n  memset(cnt, 0, sizeof(cnt));\n  x = n - x;\n  res = 0;\n  for (int i = 1; i <= x; i++) Add(A[i], 1);\n  if (Check()) return 1;\n  for (int i = x + 1; i <= n; i++) {\n    Add(A[i - x], -1), Add(A[i], 1);\n    if (Check()) return 1;\n  }\n  return 0;\n}\nint main() {\n  cin >> n >> K;\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &A[i]), B[i] = A[i];\n  sort(B + 1, B + 1 + n);\n  int len = unique(B + 1, B + 1 + n) - B - 1;\n  for (int i = 1; i <= n; i++) A[i] = lower_bound(B + 1, B + 1 + len, A[i]) - B;\n  sort(A + 1, A + 1 + n);\n  int L = 0, R = n, ans = 0;\n  while (L <= R) {\n    int mid = L + R >> 1;\n    if (check(mid))\n      ans = mid, R = mid - 1;\n    else\n      L = mid + 1;\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long double pi = 3.14159265358979323;\nlong long mod = 1000000000 + 7;\nlong long modu = 998244353;\nconst long double pii = acos(-1.0);\nconst long long INF = 1e18;\nconst long long inf = 1e9;\nlong long power(long long x, long long y) {\n  long long res = 1;\n  x = x;\n  while (y > 0) {\n    if (y & 1) res = (res * x);\n    y = y >> 1;\n    x = (x * x);\n  }\n  return res;\n}\nlong long powe(long long x, long long y) {\n  x = x % mod, y = y % (mod - 1);\n  long long ans = 1;\n  while (y > 0) {\n    if (y & 1) {\n      ans = (1ll * x * ans) % mod;\n    }\n    y >>= 1;\n    x = (1ll * x * x) % mod;\n  }\n  return ans;\n}\nlong long gcd(long long a, long long b) {\n  if (a == 0) return b;\n  return gcd(b % a, a);\n}\nlong long lcm(long long a, long long b) { return (a / gcd(a, b) * b); }\nbool isPrime(long long n) {\n  for (long long i = 2; i * i <= n; i++)\n    if (n % i == 0) return false;\n  return true;\n}\nlong long ncr(long long n, long long r) {\n  long long res = 1;\n  if (r > n) return 0;\n  if (r > n - r) r = n - r;\n  for (long long i = 0; i < r; i++) {\n    res *= (n - i);\n    res /= (i + 1);\n  }\n  return res;\n}\nvoid fun() {}\nconst long long N = 407;\nvoid pre() {}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  fun();\n  pre();\n  long long tttt = 1;\n  while (tttt--) {\n    long long n, size;\n    cin >> n >> size;\n    size *= 8;\n    long long a[n];\n    map<long long, long long> m;\n    set<long long> s;\n    for (long long i = 0; i < n; i++) {\n      cin >> a[i];\n      m[a[i]]++;\n      s.insert(a[i]);\n    }\n    long long ele = (long long)(m.size());\n    long long b[ele];\n    for (long long i = 0; i < ele; i++) {\n      b[i] = *s.begin();\n      s.erase(s.begin());\n    }\n    if (ceil(log2((long long)(m.size()))) * n <= size) {\n      cout << 0 << \"\\n\";\n      return 0;\n    }\n    sort(b, b + ele);\n    long long ans = 0;\n    long long i, j;\n    std::vector<long long> temp;\n    for (auto i : m) {\n      temp.push_back(i.second);\n    }\n    std::vector<long long> h(ele + 1);\n    for (long long i = 1; i <= ele; i++) {\n      h[i] = temp[i - 1];\n    }\n    for (long long i = 1; i <= ele; i++) h[i] += h[i - 1];\n    long long ye = size / n;\n    ye = pow(2, ye);\n    ans = inf;\n    for (long long i = ye; i <= ele; i++) {\n      ans = min(ans, n - (h[i] - h[i - ye]));\n    }\n    cout << ans;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long int n, i;\n  cin >> n >> i;\n  ;\n  long long arr[n];\n  for (long long int i = 0; i < n; i++) cin >> arr[i];\n  ;\n  sort(arr, arr + n);\n  long long k;\n  if (((8 * i) / n) > 25)\n    k = n;\n  else\n    k = pow(2, (8 * i) / n);\n  map<long long, long long> hm;\n  vector<long long> vect;\n  for (long long int j = 0; j < n; j++) {\n    if (hm[arr[j]] == 0) vect.push_back(arr[j]);\n    hm[arr[j]]++;\n  }\n  long long x = vect.size();\n  long long minim = n;\n  long long j = 0, s = 0;\n  long long sum = n;\n  for (; j < min(x, k); j++) sum -= hm[vect[j]];\n  minim = min(minim, sum);\n  while (j < x) {\n    sum = sum + hm[vect[s]] - hm[vect[j]];\n    j++;\n    s++;\n    minim = min(minim, sum);\n  }\n  cout << minim;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\nfrom sys import stdin, stdout\n \n \n#N = int(input())\n#s = input()\nN,I = [int(x) for x in stdin.readline().split()]\n \narr = [int(x) for x in stdin.readline().split()]\n \narr.sort()\n \nbits = I*8\n \n# maximum K\n \nbound = bits//N\n\nif bound>=50:\n    bound = 50\n \nmax_K = 2**bound\n \nfreq = []\nf = 0\nlast = arr[0]\nfor num in arr:\n    if num==last:\n        f += 1\n    else:\n        freq.append(f)\n        f = 1\n        \n    last = num\n    \nfreq.append(f)\nprefix = [0]*len(freq)\n \ns = 0\ni = 0\nfor f in freq:\n    s += f\n    prefix[i] = s\n    i += 1\n    \nres = N+1\nfor i in range(max_K-1,len(freq)):\n    if i==max_K-1:\n        res = min(res,N-prefix[i])\n    else:\n        res = min(res,N-prefix[i]+prefix[i-max_K])\n        \nif res==N+1:\n    print(0)\nelse:\n    print(res)"
        },
        {
            "language": 3,
            "solution": "import sys\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\n\ndef main():\n    n, I = map(int, input().split())\n    a = list(map(int, input().split()))\n    K = 2**min(20, 8*I//n)\n\n    a.sort()\n    c = []\n    pos = 0\n    while pos < n:\n        r = pos\n        while r+1 < n and a[pos] == a[r+1]:\n            r += 1\n        c.append(r-pos+1)\n        pos = r + 1\n\n    if K > len(c):\n        print(0)\n    else:\n        pref = c.copy()\n        suff = c.copy()\n        for i in range(1, len(c)):\n            pref[i] += pref[i-1]\n        for i in range(len(c)-2, -1, -1):\n            suff[i] += suff[i+1]\n\n        res = sum(c)\n        l = 0\n        r = K-1\n        while r < len(c):\n            s1 = 0 if l == 0 else pref[l-1]\n            s2 = 0 if r == len(c)-1 else suff[r+1]\n            res = min(res, s1+s2)\n            l += 1\n            r += 1\n\n        print(res)\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
            "language": 4,
            "solution": "    import java.util.*;\n    import java.io.*;\n     \n     \n    public class Solution {\n    \tstatic Scanner sc = new Scanner(System.in);\n    \tstatic long MAX = (long) (Math.pow(2,32)-1);\n    \tstatic PrintWriter pw = new PrintWriter(System.out);\n    \tpublic static void main(String[] args) {\n    \t\tint n = sc.nextInt(), x = sc.nextInt();\n    \t\tint arr[] = new int[n];\n    \t\tfor(int i = 0; i< n; i++) {\n    \t\t\tarr[i] = sc.nextInt();\n    \t\t}\n    \t\tRandom r = new Random();\n    \t\tfor(int i = 0; i< 50; i++) {\n    \t\t\tint z = r.nextInt(n);\n    \t\t\tint tem = arr[z];\n    \t\t\tarr[z] = arr[0];\n    \t\t\tarr[0] = tem;\n    \t\t}\n    \t\tArrays.sort(arr);\n    \t\tint temp = (x*8)/n;\n    \t\tif(temp > 19) {\n    \t\t\tSystem.out.println(0);\n    \t\t}\n    \t\telse {\n    \t\t\tint val = (int) Math.pow(2,temp);\n    \t\t\t//System.out.println(val);\n    \t\t\tHashSet<Integer> hs = new HashSet<>();\n    \t\t\tfor(int i : arr) {\n    \t\t\t\ths.add(i);\n    \t\t\t}\n    \t\t\tint m = hs.size();\n    \t\t\t\n    \t\t\tint brr[] = new int[m];\n    \t\t\tint j = 0;\n    \t\t\tint c = arr[0];\n    \t\t\tfor(int i = 0; i<n ;i++) {\n    \t\t\t\tif(arr[i] == c) {\n    \t\t\t\t\tbrr[j]++;\n    \t\t\t\t}\n    \t\t\t\telse {\n    \t\t\t\t\tc = arr[i];\n    \t\t\t\t\tbrr[++j]++;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tint sump[] = new int[m];\n    \t\t\tsump[0] = brr[0];\n    \t\t\tfor(int i = 1; i< m; i++) {\n    \t\t\t\tsump[i] = sump[i-1] + brr[i];\n    \t\t\t}\n    \t\t\tint sumr[] = new int[m];\n    \t\t\tsumr[m-1] = brr[m-1];\n    \t\t\tfor(int i = m-2; i>=0; i--) {\n    \t\t\t\tsumr[i] = sumr[i+1] + brr[i];\n    \t\t\t}\n    \t\t\tif(val>=m) {\n    \t\t\t\tSystem.out.println(0);\n    \t\t\t\treturn;\n    \t\t\t}\n    \t\t\tint ans = n;\n    \t\t\tfor(int i = 0;i<m-val;i++) {\n    \t\t\t\tint fa = 0;\n    \t\t\t\tif(i>0) {\n    \t\t\t\t\tfa += sump[i-1];\n    \t\t\t\t}\n    \t\t\t\tfa += sumr[i+val];\n    \t\t\t\tans = Math.min(ans,fa);\n    \t\t\t\t//System.out.println(fa+\" \"+ans);\n    \t\t\t}\n    \t\t\tSystem.out.println(ans);\n    \t\t}\n    \t}\n    \t\n    \tpublic static String compare(String s1, String s2) {\n    \t\tif(s1.length()>s2.length()) {\n    \t\t\treturn s2;\n    \t\t}\n    \t\telse if(s2.length()>s1.length()) {\n    \t\t\treturn s1;\n    \t\t}\n    \t\telse {\n    \t\t\tif(s1.compareTo(s2)<0) return s1;\n    \t\t\telse return s2;\n    \t\t}\n    \t}\n    \tpublic static String sum(String s1, String s2) {\n    //\t\tSystem.out.println(s1+\" \"+s2);\n    \t\tStringBuilder sb = new StringBuilder();\n    \t\tStringBuilder temp1 = new StringBuilder(s1);\n    \t\tStringBuilder temp2 = new StringBuilder(s2);\n    \t\ts1 = temp1.reverse().toString();\n    \t\ts2 = temp2.reverse().toString();\n    //\t\tSystem.out.println(s1+\" \"+s2);\n    \t\tint n = s1.length(), m = s2.length();\n    \t\tint i = 0, carry = 0;\n    \t\twhile(i<n && i<m) {\n    \t\t\tint x = (s1.charAt(i) + s2.charAt(i) - '0' - '0' + carry);\n    \t\t\tsb.append(x%10);\n    \t\t\tcarry = x/10;\n    \t\t\ti++;\n    \t\t}\n    \t\twhile(i<n) {\n    \t\t\tint x = (s1.charAt(i) -'0' + carry);\n    \t\t\tsb.append(x%10);\n    \t\t\tcarry = x/10;\n    \t\t\ti++;\n    \t\t}\n    \t\twhile(i<m) {\n    \t\t\tint x = (s2.charAt(i) -'0' + carry);\n    \t\t\tsb.append(x%10);\n    \t\t\tcarry = x/10;\n    \t\t\ti++;\n    \t\t}\n    \t\tif(carry!=0) {\n    \t\t\tsb.append(carry);\n    \t\t}\n    \t\treturn sb.reverse().toString();\n    \t}\n    }"
        },
        {
            "language": 3,
            "solution": "import sys\nimport math\n# n=int(sys.stdin.readline())\nn,y=list(map(int,sys.stdin.readline().strip().split()))\na=list(map(int,sys.stdin.readline().strip().split()))\na.sort()\na.append(0)\n# print(a)\ny=y*8\narr=[]\ni=0\nk=2**(y//n)\n# print(k)\nwhile(i<n):\n    # x=[a[i],1,math.ceil(math.log(a[i],2))+1]\n    # x=[a[i],1]\n    x=1\n    # print(i)\n    while(a[i]==a[i+1] and i<n):\n        # x[1]+=1\n        x+=1\n        i+=1\n        # print(i)\n    arr.append(x)\n    i+=1\n# print(a,arr)\narr=[0]+arr\n# print(arr)\nfor i in range(1,len(arr)):\n    arr[i]=arr[i]+arr[i-1]\n# print(arr)\nop=n\n# print(k)\nif(len(arr)<k):\n    print(0)\n    exit(0)\nfor i in range(1,len(arr)):\n    # xxx=arr[i]-arr[min(i-1,i-k)]\n    if(i<k):\n        xxx=arr[i]-arr[i-1]\n    else:\n        xxx=arr[i]-arr[i-k]\n    # print(xxx)\n    op=min(op,n-xxx)\nprint(op)"
        },
        {
            "language": 1,
            "solution": "from __future__ import print_function, division\nfrom sys import stdin, stdout\nfrom collections import *\n\n\ndef fast2():\n    import os, sys, atexit\n    from cStringIO import StringIO as BytesIO\n    # range = xrange\n    sys.stdout = BytesIO()\n    atexit.register(lambda: os.write(1, sys.stdout.getvalue()))\n    return BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n\ninput = fast2()\nrint = lambda: int(stdin.readline())\nrints = lambda: [int(x) for x in input().split()]\npr = lambda args, sep: stdout.write(sep.join(map(str, args)) + '\\n')\nout = []\n\nn, m = rints()\na = sorted(rints())\nmem, ans, po = [], 0, 1 << 20\nm *= 8\ntem = 1\n\nfor i in range(1, n):\n    if a[i] != a[i - 1]:\n        mem.append(tem)\n        tem = 0\n    tem += 1\n\nmem.append(tem)\n\nfor i in range(20, -1, -1):\n    if n * i <= m:\n        su = 0\n        for j in range(min(len(mem), po)):\n            su += mem[j]\n\n        tem, ix = su, 0\n\n        for j in range(po, len(mem)):\n            su -= mem[ix]\n            ix += 1\n            su += mem[j]\n            tem = max(tem, su)\n\n        ans = n - tem\n        break\n\n    po >>= 1\n\nprint(ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ul = unsigned long;\nusing ull = unsigned long long;\nusing ll = long long;\nusing pin = std::pair<int, int>;\nusing pull = pair<ull, ull>;\nint main() {\n  ios::sync_with_stdio(false);\n  int n, I;\n  cin >> n >> I;\n  vector<ul> a(n, 0);\n  for (ul i = 0; i < n; ++i) {\n    cin >> a[i];\n  }\n  sort(a.begin(), a.end());\n  vector<ull> diff;\n  for (ul i = 0; i < n; ++i) {\n    if (i == 0 || a[i - 1] != a[i]) {\n      diff.emplace_back(1);\n    } else {\n      ++diff.back();\n    }\n  }\n  ull diff_value = diff.size();\n  ull k = floor(8 * I / n);\n  ull K = floor(pow(2L, min(20ull, k)));\n  if (K >= diff_value) {\n    cout << 0 << endl;\n    return 0;\n  }\n  ull allSum = accumulate(diff.begin(), diff.end(), 0);\n  ull sum = 0;\n  ull offset = K;\n  for (ull i = 0; i < offset; ++i) {\n    sum += diff[i];\n  }\n  ull ans = sum;\n  for (ull l = 1, r = offset; r < diff_value; ++l, ++r) {\n    sum -= diff[l - 1];\n    sum += diff[r];\n    ans = max(ans, sum);\n  }\n  cout << allSum - ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class c {\n\tpublic static void main(String[] args) throws IOException {\n\t\tFastScanner sc = new FastScanner(System.in);\n\t\tint n = sc.nextInt(), bits = sc.nextInt()*8;\n\t\tint[] arr = new int[n];\n\t\tTreeMap<Integer, Integer> eleToNum = new TreeMap<>();\n\t\tfor (int i = 0 ; i < n ; i++) {\n\t\t\tarr[i] = sc.nextInt();\n\t\t\t\n\t\t\tif (eleToNum.containsKey(arr[i])) {\n\t\t\t\teleToNum.put(arr[i], eleToNum.get(arr[i])+1);\n\t\t\t} else {\n\t\t\t\teleToNum.put(arr[i], 1);\n\t\t\t}\t\n\t\t}\n\t\t\n\t\t\n\t\tint count = 100;\n\t\tint high = eleToNum.size();\n\t\tint low = 1;\n\t\twhile(count-- > 0) {\n\t\t\tint mid = (high+low)/2;\n\t\t\t\n\t\t\t// works\n\t\t\tif (n*Math.ceil(Math.log(mid)/Math.log(2)) <= bits) {\n\t\t\t\tlow = mid;\n\t\t\t} else {\n\t\t\t\thigh = mid;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (n*Math.ceil(Math.log(high)/Math.log(2)) <= bits) {\n\t\t\tlow = high;\n\t\t}\n\t\t\n\t\tint nDifferent = low; // max num of diff elements can have\n\t\t\n\t\t// get min num changes\n\t\tint tally = 0;\n\t\tint in = 0;\n\t\tint bottomKey = eleToNum.firstKey();\n\t\tint ans = n;\n\t\t\n\t\tfor (Map.Entry<Integer, Integer> entry : eleToNum.entrySet()) {\n\t\t\tint key = entry.getKey();\n\t\t\tint value = entry.getValue();\n\t\t\tin++;\n\t\t\ttally += value;\n\t\t\t\n\t\t\t// works\n\t\t\tif (in == nDifferent) {\n\t\t\t\tans = Math.min(ans, n-tally);\n\t\t\t\ttally -= eleToNum.get(bottomKey);\n\t\t\t\tin--;\n\t\t\t\tif (eleToNum.ceilingKey(bottomKey+1) != null) {\n\t\t\t\t\tbottomKey = eleToNum.ceilingKey(bottomKey+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t}\n/*\n6 1\n1 2 5 6 7 9 8 5 3 1 6 2 3 3 4\n */\n\n\tstatic class FastScanner {\n\t    BufferedReader br;\n\t    StringTokenizer st;\n\t\t\n\t    public FastScanner(InputStream i) {\n\t        br = new BufferedReader(new InputStreamReader(i));\n\t        st = new StringTokenizer(\"\");\n\t    }\n\t\t\t\t\n\t    public String next() throws IOException {\n\t        if(st.hasMoreTokens())\n\t            return st.nextToken();\n\t        else\n\t            st = new StringTokenizer(br.readLine());\n\t        return next();\n\t    }\n\n\t    public int nextInt() throws IOException {\n\t        return Integer.parseInt(next());\n\t    }\n\t    public long nextLong() throws IOException {\n\t        return Long.parseLong(next());\n\t    }\n\t    public double nextDouble() throws IOException {\n\t        return Double.parseDouble(next());\n\t    }\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class c1 {\n\tpublic static void main(String[] args) throws Exception{\n\t\tint n = i();\n\t\tlong i = l();\n\t\tint max = (int) Math.pow(2, (i*8)/((long) n));\n\t\tlong[] sound = new long[n];\n\t\tfor (int j=0; j<n; j++) {\n\t\t\tsound[j] = l();\n\t\t}\n\t\tArrays.sort(sound);\n\t\tcompress(sound);\n\t\t\n\t\tlong[] time = new long[(int) sound[n-1]];\n\t\tfor (int j=0; j<n; j++) {\n\t\t\ttime[(int) sound[j]-1] ++;\n\t\t}\n\t\tsegmentTree arup = new segmentTree(time);\n\t\tlong ret = 0;\n\t\tif (time.length-max+1<=0) {\n\t\t\tSystem.out.println(\"0\");\n\t\t\treturn;\n\t\t}\n\t\tfor (int j=0; j<time.length-max+1; j++) {\n\t\t\tif (arup.query(j, j+max-1, 1, 0, arup.initlength-1)>ret) ret = arup.query(j, j+max-1, 1, 0, arup.initlength-1);\n\t\t}\n\t\tSystem.out.println(n-ret);\n\t}\n\t\n\tpublic static class segmentTree {\n\t\t// This segtree is to find the minimum of a range, can be easily modified\n\t\tint size;\n\t\tint initlength;\n\t\tlong[] vals;\n\t\t\n\t\t/* Index of the nodes are 1, 2, 3, 4, 5, etc.\n\t\t * Top index is 1, bottom is depth\n\t\t * Other than the final row, node n will be the parent of node 2n and node 2n+1\n\t\t */\n\t\t\n\t\t// the nodes are 1....size-1\n\t\tpublic segmentTree(long[] arr) {\n\t\t\tinitlength = arr.length;\n\t\t\tsize=1;\n\t\t\twhile (size<initlength*4) {\n\t\t\t\tsize*=2;\n\t\t\t}\n\t\t\t\n\t\t\tvals = new long[size];\n\t\t\tfor (int i=0; i<initlength; i++) {\n\t\t\t\tupdate(0, initlength-1, 1, i, arr[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Min from [start, end], node = 1, left and right are temp recursive - initially 0 and initlength-1\n\t\tpublic long query (int start, int end, int node, int left, int right) {\n\t\t\tint mid = (left+right)/2;\n\t\t\tif (start<=left && end >=right) return vals[node];\n\t\t\tif (start>right || end<left) return 0;\n\t\t\tlong temp1 = query(start, end, node*2, left, mid);\n\t\t\tlong temp2 = query(start, end, node*2+1, mid+1, right);\n\t\t\treturn temp1+temp2;\n\t\t}\n\t\t\n\t\t\n\t\t// If calling this, start = 0 and end = initlength-1, node = 1, pos is 0..initlength-1\n\t\tpublic void update (int start, int end, int node, int pos, long val) {\n\t\t\tif (start == end) {\n\t\t\t\tvals[node] = val;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tint mid = (start+end)/2;\n\t\t\t\n\t\t\t\n\t\t\tif (pos<=mid) update(start, mid, 2*node, pos, val);\n\t\t\telse update(mid+1, end, 2*node+1, pos, val);\n\t\t\t\n\t\t\tvals[node] =vals[node*2] + vals[node*2+1];\n\t\t}\n\t}\n\t\n\tpublic static class pair implements Comparable<pair> {\n\t\tlong a;\n\t\tint b;\n\t\t\n\t\tpublic pair(long x, int y) {\n\t\t\ta = x;\n\t\t\tb = y;\n\t\t}\n\t\t\n\t\tpublic int compareTo(pair p) {\n\t\t\tif (a>p.a) return 1;\n\t\t\tif (p.a>a) return -1;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t}\n\tpublic static void compress(long[] arr) {\n\t\tpair[] pairs = new pair[arr.length];\n\t\t\n\t\tfor (int i=0; i<arr.length; i++) {\n\t\t\tpairs[i] = new pair(arr[i], i);\n\t\t}\n\t\t\n\t\tArrays.sort(pairs);\n\t\tlong counter = 1;\n\t\tarr[pairs[0].b] = 1;\n\t\tfor (int i=1; i<arr.length; i++) {\n\t\t\tif (pairs[i].a != pairs[i-1].a) {\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t\t\n\t\t\tarr[pairs[i].b] = counter;\n\t\t}\n\t}\n\t\n\tstatic BufferedReader in;\n\tstatic StringTokenizer st = new StringTokenizer(\"\");\n\tstatic PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\t// static PrintWriter out;\n\t/*\n\t * static { try { in = Files.newBufferedReader(Paths.get(\"haybales.in\")); out =\n\t * new PrintWriter(new BufferedWriter(new FileWriter(\"haybales.out\"))); } catch\n\t * (Exception e) { in = new BufferedReader(new InputStreamReader(System.in)); }\n\t * }\n\t */\n\tstatic {\n\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\tstatic void check() throws Exception {\n\t\twhile (!st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t}\n\n\tstatic String s() throws Exception {\n\t\tcheck();\n\t\treturn st.nextToken();\n\t}\n\n\tstatic int i() throws Exception {\n\t\treturn Integer.parseInt(s());\n\t}\n\n\tstatic long l() throws Exception {\n\t\treturn Long.parseLong(s());\n\t}\n\n\tstatic double d() throws Exception {\n\t\treturn Double.parseDouble(s());\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nint a[1000005], b[1000005], bt, cnt[1000005];\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  m = ((m * 8) / n);\n  if (m >= 30) {\n    printf(\"0\");\n    return 0;\n  }\n  m = (1 << m);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]), b[++bt] = a[i];\n  sort(b + 1, b + bt + 1);\n  bt = unique(b + 1, b + bt + 1) - b - 1;\n  for (int i = 1; i <= n; i++) cnt[lower_bound(b + 1, b + bt + 1, a[i]) - b]++;\n  if (bt <= m) {\n    printf(\"0\");\n    return 0;\n  }\n  for (int i = 1; i <= bt; i++) cnt[i] += cnt[i - 1];\n  int ans = 1e9;\n  for (int i = 0; i <= bt - m; i++) {\n    int j = bt - (bt - m - i);\n    ans = min(ans, cnt[i] + (cnt[bt] - cnt[j]));\n  }\n  printf(\"%d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class Main {\n \n    public static void main(String[] args) {\n\t    // write your code here\n        Scanner scan = new Scanner(System.in);\n        int n = scan.nextInt();\n        int I = scan.nextInt();\n        int k = 8 * I / n;\n        int K = (int)Math.pow(2.0, k);\n \n        int[] arr = new int[n];\n        for(int i = 0; i < n; i++) arr[i] = scan.nextInt();\n        Arrays.sort(arr);\n \n        List<Integer> list = new ArrayList<>();\n        int cnt = 0;\n        for(int i = 0; i < n; i++) {\n            if(i > 0 && arr[i] > arr[i - 1]) {\n                list.add(cnt);\n                cnt = 1;\n            } else {\n                cnt++;\n            }\n        }\n        list.add(cnt);\n \n        if(list.size() <= K) System.out.println(0);\n        else {\n           // System.out.println(K);\n           // list.forEach(System.out::println);\n            int ans = 0;\n            int diff = list.size() - K;\n            for(int i = 0; i < diff; i++) ans += list.get(i);\n            int all = ans;\n            for(int i = 1; i <= diff; i++) {\n                all = all + list.get(list.size() - i) - list.get(diff - i);\n                if(all < ans) ans = all;\n            }\n            System.out.println(ans);\n        }\n \n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INT_INF = 1e9;\nconst long long LL_INF = 1e18;\nconst int MAXN = 500003;\ntypedef struct GE {\n  int to;\n  long long w;\n} GE;\nint n;\nlong long I;\nunordered_map<long long, int> um;\nint main() {\n  scanf(\"%d %lld\", &n, &I);\n  I *= 8ll;\n  vector<long long> A;\n  for (int i = 0; i < n; i++) {\n    long long x;\n    scanf(\"%lld\", &x);\n    A.push_back(x);\n    um[A[i]]++;\n  }\n  sort(A.begin(), A.end());\n  A.erase(unique(A.begin(), A.end()), A.end());\n  int asz = A.size();\n  long long lgK = I / n + 1;\n  while (lgK * n > I) lgK--;\n  long long mxK = 1ll << lgK;\n  if (lgK >= 20) mxK = n;\n  if (mxK >= asz) {\n    puts(\"0\");\n    return 0;\n  }\n  int L = 0, R = mxK - 1;\n  long long sum = 0;\n  for (int i = 0; i < mxK; i++) {\n    sum += um[A[i]];\n  }\n  long long ans = n - sum;\n  while (R < asz) {\n    L++;\n    R++;\n    if (R >= asz) break;\n    sum -= um[A[L - 1]];\n    sum += um[A[R]];\n    ans = min(ans, n - sum);\n  }\n  printf(\"%lld\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.ArrayList;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Kraken\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    Scanner in = new Scanner(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskC solver = new TaskC();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskC {\n\n    public void solve(int testNumber, Scanner in, PrintWriter out) {\n      int n = in.nextInt();\n      long I = in.nextLong();\n      Long[] a = new Long[n];\n      for (int i = 0; i < n; i++)\n        a[i] = in.nextLong();\n      I = I * 8;\n      I = I / n;\n      if (I >= 20) {\n        out.println(0);\n        return;\n      }\n      int K = 1 << I;\n      Arrays.sort(a);\n      ArrayList<Integer> list = new ArrayList<>();\n      long cur = a[0];\n      int cnt = 0;\n      for (int i = 0; i < n; i++) {\n        if (a[i] == cur) {\n          cnt++;\n        } else {\n          list.add(cnt);\n          cnt = 1;\n          cur = a[i];\n        }\n      }\n      list.add(cnt);\n      if (list.size() <= K) {\n        out.println(0);\n        return;\n      }\n      long[] sum = new long[list.size() + 1];\n      for (int i = 0; i < list.size(); i++) {\n        sum[i + 1] = list.get(i) + sum[i];\n      }\n      int l = 0, r = K;\n      long curr = sum[r] - sum[l];\n      while (r < sum.length) {\n        curr = Math.max(curr, sum[r] - sum[l]);\n        r++;\n        l++;\n      }\n      out.println(n - curr);\n    }\n\n  }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, I, k, i, in, val, answer, j, count;\n  vector<int> v;\n  scanf(\"%d%d\", &n, &I);\n  answer = n;\n  I *= 8;\n  k = I / n;\n  if (k > 30) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", &in);\n    v.push_back(in);\n  }\n  val = 1 << k;\n  if (val >= n) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  sort(v.begin(), v.end());\n  i = 1;\n  j = 0;\n  count = 1;\n  while (i < n) {\n    if (v[i] != v[i - 1]) {\n      count++;\n      if (count > val) {\n        while (v[j] == v[j + 1] && j < n - 1) {\n          j++;\n        }\n        j++;\n      }\n    }\n    answer = min(answer, n - i + j - 1);\n    i++;\n  }\n  printf(\"%d\\n\", answer);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long maxn = 4e5 + 5;\nlong long n, I, a[maxn], k = 1, l = 1, sum = 0, r = 0;\nsigned main() {\n  scanf(\"%lld %lld\", &n, &I);\n  I = (I << 3) / n;\n  for (long long j = 1; j <= I; j++) {\n    k <<= 1;\n    if (k >= n) {\n      puts(\"0\");\n      return 0;\n    }\n  }\n  for (long long i = 1; i <= n; i++) scanf(\"%lld\", &a[i]);\n  sort(a + 1, a + n + 1);\n  a[0] = -1;\n  long long ans = n - 1;\n  while (r < n) {\n    while (r < n && (sum < k || ((a[r] == a[r + 1]) && k == sum)))\n      r++, sum += (a[r] != a[r - 1]);\n    ans = min(ans, n - (r - l + 1));\n    while (l < r && a[l] == a[l + 1]) l++;\n    l++, sum--;\n  }\n  printf(\"%lld\\n\", min(ans, n - (r - l + 1)));\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.TreeMap;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Jaynil\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int s = in.nextInt() * 8;\n            ArrayList<Integer> a = new ArrayList<>();\n            for (int i = 0; i < n; i++) a.add(in.nextInt());\n            TreeMap<Integer, Integer> map = new TreeMap<>();\n            for (int i = 0; i < n; i++) {\n                map.put(a.get(i), map.getOrDefault(a.get(i), 0) + 1);\n            }\n            long max = (long) Math.pow(2, s / n);\n            ArrayList<int[]> x = new ArrayList<>();\n            for (int xx : map.keySet()) {\n                x.add(new int[]{xx, map.get(xx)});\n            }\n            if (x.size() < max) {\n                out.println(0);\n                return;\n            }\n            int sum = 0;\n            int ans = Integer.MAX_VALUE;\n            int l = 0;\n            for (int i = 0; i < x.size(); i++) {\n                if (i < max) {\n                    sum += x.get(i)[1];\n                    continue;\n                }\n                ans = Math.min(n - sum, ans);\n                sum += x.get(i)[1];\n                sum -= x.get(l)[1];\n                l++;\n            }\n            ans = Math.min(n - sum, ans);\n            out.println(ans);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 3,
            "solution": "n, I = map(int, input().split())\n\nk = int(8*I/n)\nK = 2**k\n# print(K)\n\na = sorted(map(int,input().split()))\n\nnums = [1]\nfor c in range(1,n):\n    if a[c] == a[c-1]:\n        nums[-1] += 1\n    else:\n        nums.append(1)\n\n# print(nums)\ncurr = sum(nums[:K])\nm = curr\nfor i in range(0,len(nums)-K):\n    curr = curr-nums[i]+nums[i+K]\n    m = max(curr,m)\n\nprint(n-m)\n"
        },
        {
            "language": 3,
            "solution": "from itertools import groupby\n\ndef solve():\n    n, disk = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n\n    k = int((disk * 8) / n)\n    # print('maximum bits', k)\n\n    dist = 1 << k\n    # print('maximum distincts', dist)\n\n    counts = [len(list(group)) for (key, group) in groupby(sorted(a))]\n    cur_changes = sum(counts[dist:])\n    ans = cur_changes\n    for i in range(0, len(counts) - dist):\n        cur_changes += counts[i]\n        cur_changes -= counts[i + dist]\n        ans = min(ans, cur_changes)\n    print(ans)\n\n\nif __name__ == '__main__':\n    solve()\n"
        },
        {
            "language": 3,
            "solution": "from itertools import groupby\n\n\ndef mp3(n, I, a):\n    k = int((I * 8) / n)\n    d = 1 << k\n    c = [len(list(group)) for (key, group) in groupby(sorted(a))]\n    chgs = sum(c[d:])\n    ans = chgs\n    for i in range(0, len(c) - d):\n        chgs += c[i]\n        chgs -= c[i + d]\n        ans = min(ans, chgs)\n    return ans\n\n\nif __name__ == \"__main__\":\n    nn, II = list(map(int, input().split()))\n    aa = list(map(int, input().split()))\n    print(mp3(nn, II, aa))"
        },
        {
            "language": 3,
            "solution": "import atexit\nimport io\nimport sys\nfrom collections import Counter\nfrom math import log\nimport math\n# _INPUT_LINES = sys.stdin.read().splitlines()\n# input = iter(_INPUT_LINES).__next__\n# _OUTPUT_BUFFER = io.StringIO()\n# sys.stdout = _OUTPUT_BUFFER\n#\n#\n# @atexit.register\n# def write():\n#     sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())\n\n\n\n# R = lambda : map(int,input().split())\n# # t = int(input())\n# # for i in range(t):\n# n,k = map(int,input().split())\n# l = list(R())\n# c = Counter(l)\n# bts_avail = k*8 // n\n# disk_size = math.ceil(math.log(len(c),2))*n\n# if disk_size<=8*k:\n#     print(0)\n# else:\n#     dl = list(c.values())\n#     len_dl = len(dl)\n#     dl.sort()\n#     ans =0\n#     for i in dl:\n#         len_dl-=1\n#         ans+=i\n#         if math.log(len_dl,2)<=bts_avail:\n#             break\n#\n#     print(ans)\n# n, m = map(int, input().split())\n# a = sorted(map(int, input().split()))\n# b = [0]\n# print(a)\n# a += [1 << 30]\n# print(a)\n# for i in range(n):\n#     if a[i] < a[i+1]:\n#         b += [i+1]\n# print(b)\n#\n#\n# print(1<<8)\n# print(n-max((y-x for x,y in zip(b,b[1<<8*m//n:])),default=n))\n\nn,i= map(int, input().split())\nl= list(map(int, input().split()))\nk= (8*i)//n\nK= 2**k\nl.sort()\ntemp= [0]\nfor i in range(1,n):\n    if(l[i-1]!=l[i]):\n        temp.append(i)\n# print(temp)\nif(len(temp)<=K):\n    print(0)\nelse:\n    print(n - max(temp[i+K]-temp[i] for i in range(len(temp)-K)))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  vector<long long> b;\n  long long w = 1;\n  for (int i = 0; i < 31; i++) {\n    b.emplace_back(w);\n    w *= 2;\n  }\n  int n, I;\n  cin >> n >> I;\n  int k = 8 * I / n;\n  map<int, int> cur;\n  for (int i = 0; i < n; i++) {\n    int a;\n    cin >> a;\n    cur[a]++;\n  }\n  auto l = cur.begin();\n  int cost = n, res = n, now = 0;\n  for (auto r = cur.begin(); r != cur.end(); r++) {\n    cost -= r->second;\n    now++;\n    while (lower_bound(b.begin(), b.end(), now) - b.begin() > k) {\n      cost += l->second;\n      l++;\n      now--;\n    }\n    res = min(cost, res);\n  }\n  printf(\"%d\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n\n\tstatic long sx = 0, sy = 0, mod = (long) (1e9 + 7);\n\n\tstatic ArrayList<Integer>[] a;\n\tstatic long[][][] dp;\n\tstatic int[] size;\n\tstatic long[] farr;\n\tpublic static PrintWriter out;\n\tstatic ArrayList<pair> pa = new ArrayList<>();\n\tstatic long[] fact = new long[(int) 1e6];\n\tstatic boolean b = false;\n\tstatic StringBuilder sb = new StringBuilder();\n\tstatic boolean cycle = false;\n\t// static long m = 998244353;\n\tstatic long[] no, col;\n\tstatic String s;\n\tstatic int k = 0, n = 0, m = 0;\n\tstatic int[] c;\n\tstatic long ans = 0;\n\tstatic HashMap<Integer, Integer> hm;\n\tstatic ArrayList<Integer> p = new ArrayList<>();\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// Scanner scn = new Scanner(new BufferedReader(new\n\t\t// InputStreamReader(System.in)));\n\n\t\tout = new PrintWriter(System.out);\n\t\tReader scn = new Reader();\n\n\t\tint n = scn.nextInt();\n\n\t\tlong size = scn.nextLong() * 8;\n\n\t\tlong k = size / n;\n\n\t\tlong dis = 1;\n\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tdis *= 2;\n\n\t\t\tif (dis >= n)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tint[] a = scn.nextIntArray(n);\n\n\t\tHashMap<Integer, Integer> hm = new HashMap<>();\n\n\t\tfor (int i : a)\n\t\t\thm.put(i, hm.containsKey(i) ? hm.get(i) + 1 : 1);\n\n\t\tArrayList<pair> p = new ArrayList<>();\n\n\t\tfor (int el : hm.keySet())\n\t\t\tp.add(new pair(el, hm.get(el)));\n\n\t\tCollections.sort(p);\n\n\t\tif (dis >= p.size())\n\t\t\tSystem.out.println(0);\n\n\t\telse {\n\n\t\t\tint ans = 0;\n\n\t\t\tCollections.sort(p, new comp());\n\n\t\t\tint[] arr = new int[p.size()];\n\n\t\t\tfor (int i = 0; i < p.size(); i++)\n\t\t\t\tarr[i] = p.get(i).freq;\n\n\t\t\tint tot = 0;\n\n\t\t\tint maxsum = 0;\n\t\t\tint sum = 0;\n\n\t\t\tfor (int i = 0; i < arr.length; i++) {\n\n\t\t\t\ttot += arr[i];\n\n\t\t\t\tif (i < dis)\n\t\t\t\t\tsum += arr[i];\n\t\t\t\telse {\n\t\t\t\t\tmaxsum = Math.max(sum, maxsum);\n\t\t\t\t\tsum -= arr[(int) (i - dis)];\n\t\t\t\t\tsum += arr[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaxsum = Math.max(sum, maxsum);\n\n\t\t\tSystem.out.println(tot - maxsum);\n\t\t}\n\n\t}\n\n\t// _________________________TEMPLATE_____________________________________________________________\n\n\t// public static long lcm(long x, long y) {\n\t//\n\t// return (x * y) / gcd(x, y);\n\t// }\n\t//\n\t// private static long gcd(long x, long y) {\n\t// if (x == 0)\n\t// return y;\n\t//\n\t// return gcd(y % x, x);\n\t// }\n\n\tstatic class comp implements Comparator<pair> {\n\n\t\t@Override\n\t\tpublic int compare(pair p1, pair p2) {\n\t\t\treturn p1.ele - p2.ele;\n\t\t}\n\n\t}\n\n\tpublic static long pow(long a, long b) {\n\n\t\tif (b < 0)\n\t\t\treturn 0;\n\t\tif (b == 0 || b == 1)\n\t\t\treturn (long) Math.pow(a, b);\n\n\t\tif (b % 2 == 0) {\n\n\t\t\tlong ret = pow(a, b / 2);\n\t\t\tret = (ret % mod * ret % mod) % mod;\n\t\t\treturn ret;\n\t\t}\n\n\t\telse {\n\t\t\treturn ((pow(a, b - 1) % mod) * a % mod) % mod;\n\t\t}\n\t}\n\n\tprivate static class pair implements Comparable<pair> {\n\n\t\tint ele;\n\t\tint freq;\n\n\t\tpair(int a, int b) {\n\n\t\t\tele = a;\n\t\t\tfreq = b;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(pair o) {\n\n\t\t\treturn this.freq - o.freq;\n\t\t}\n\n\t}\n\n\tprivate static String reverse(String s) {\n\n\t\treturn new StringBuilder(s).reverse().toString();\n\t}\n\n\tpublic static class Reader {\n\t\tfinal private int BUFFER_SIZE = 1 << 16;\n\t\tprivate DataInputStream din;\n\t\tprivate byte[] buffer;\n\t\tprivate int bufferPointer, bytesRead;\n\n\t\tpublic Reader() {\n\t\t\tdin = new DataInputStream(System.in);\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic Reader(String file_name) throws IOException {\n\t\t\tdin = new DataInputStream(new FileInputStream(file_name));\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic String readLine() throws IOException {\n\t\t\tbyte[] buf = new byte[1000000 + 1]; // line length\n\t\t\tint cnt = 0, c;\n\t\t\twhile ((c = read()) != -1) {\n\t\t\t\tif (c == '\\n')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[cnt++] = (byte) c;\n\t\t\t}\n\t\t\treturn new String(buf, 0, cnt);\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\tint ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\tlong ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tdouble ret = 0, div = 1;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t} while ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (c == '.') {\n\t\t\t\twhile ((c = read()) >= '0' && c <= '9') {\n\t\t\t\t\tret += (c - '0') / (div *= 10);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tprivate void fillBuffer() throws IOException {\n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\t\t\tif (bytesRead == -1)\n\t\t\t\tbuffer[0] = -1;\n\t\t}\n\n\t\tprivate byte read() throws IOException {\n\t\t\tif (bufferPointer == bytesRead)\n\t\t\t\tfillBuffer();\n\t\t\treturn buffer[bufferPointer++];\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tif (din == null)\n\t\t\t\treturn;\n\t\t\tdin.close();\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tint[] arr = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextInt();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tlong[] arr = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextLong();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic int[][] nextInt2DArray(int m, int n) throws IOException {\n\t\t\tint[][] arr = new int[m][n];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tarr[i][j] = nextInt();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tpublic long[][] nextInt2DArrayL(int m, int n) throws IOException {\n\t\t\tlong[][] arr = new long[m][n];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tarr[i][j] = nextInt();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\t\t// kickstart - Solution\n\t\t// atcoder - Main\n\t}\n\n}"
        },
        {
            "language": 3,
            "solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\nfrom collections import Counter\nimport math\n# region fastio\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\ndef getint(): return int(input())\ndef getints(): return list(map(int, input().split()))\ndef getint1(): return list(map(lambda x: int(x) - 1, input().split()))\n\ndef main():\n    ###CODE\n    n,I = getints()\n    I = 8*I\n    k = I//n\n    K = pow(2,k)\n    a = Counter(getints())\n    curr = len(a)\n    if curr<=K:\n        print(0)\n    else:\n        a1 = sorted(list(a.keys()))\n        a2 = [0]*(curr+1)\n        for i in range(curr):\n            a2[i+1]=a2[i]+a[a1[i]]\n        a1 = curr-K\n        a = 0\n        for i in range(a1):\n            a = max(a,a2[i+K]-a2[i])\n        print(n-a)\n\nif __name__ == \"__main__\":\n    main()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, kk, a[500010], b[500010];\nint sum1[500010], sum2[500010], sum3[500010], num[500010], k1[500010],\n    k2[500010], k3[500010];\nunordered_map<int, int> mp;\nint main() {\n  scanf(\"%d%d\", &n, &kk);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  sort(a + 1, a + 1 + n);\n  b[1] = a[1];\n  mp[b[1]] = 1;\n  int k = 1;\n  for (int i = 2; i <= n; i++) {\n    if (a[i] != b[k]) {\n      k++;\n      b[k] = a[i];\n      mp[b[k]] = k;\n    }\n  }\n  int p = (kk * 8) / n;\n  int kind = 1;\n  for (int i = 1; i <= p; i++) {\n    kind = kind * 2;\n    if (kind >= k) {\n      printf(\"0\\n\");\n      return (0);\n    }\n  }\n  int res = k - kind;\n  for (int i = 1; i <= n; i++) num[mp[a[i]]]++;\n  for (int i = 1; i <= k; i++) {\n    sum1[i] = sum1[i - 1] + num[i];\n    k1[i] = k1[i - 1] + (num[i] > 0);\n  }\n  for (int i = k; i >= 1; i--) {\n    sum2[i] = sum2[i + 1] + num[i];\n    k2[i] = k2[i + 1] + (num[i] > 0);\n  }\n  for (int i = 1; i <= k; i++) {\n    sum3[i] = sum2[k - i + 1];\n    k3[i] = k2[k - i + 1];\n  }\n  int ans = 1e9 + 7;\n  for (int i = 1; i <= k; i++) {\n    int x = res - k1[i];\n    if (x <= 0) ans = min(ans, sum1[i]);\n    int l = lower_bound(k3 + 1, k3 + 1 + k - i, x) - k3;\n    if (l != k + 1 - i) {\n      ans = min(ans, sum1[i] + sum3[l]);\n    }\n  }\n  for (int i = 1; i <= k; i++) {\n    int x = res - k3[i];\n    if (x <= 0) ans = min(ans, sum3[i]);\n  }\n  printf(\"%d\\n\", ans);\n  return (0);\n}\n"
        },
        {
            "language": 3,
            "solution": "import math as mt\nimport collections as cc\nimport sys\nI=lambda:list(map(int,input().split()))\nn,i=I()\nl=I()\nl.sort()\ntot=2**((8*i)//n)\nans=-10\ntemp=[0]\nfor i in range(1,n):\n\tif l[i]!=l[i-1]:\n\t\ttemp.append(i)\nif len(temp)<=tot:\n\tprint(0)\nelse:\n\tx=-1\n\tfor i in range(len(temp)-tot):\n\t\tx=max(temp[i+tot]-temp[i],x)\n\tprint(n-x)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, ans, head, tail, a[400005], b[400005];\nlong long m;\nint main() {\n  scanf(\"%d%lld\", &n, &m), m = 1 << (min(m * 8ll / n, 30ll));\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &b[i]);\n  sort(b + 1, b + n + 1);\n  for (int i = 1; i <= n; i++)\n    a[i] = (b[i] == b[i - 1]) ? a[i - 1] : a[i - 1] + 1;\n  head = tail = 1, ans = 1;\n  while (tail < n) {\n    while (head <= tail && tail < n && a[tail + 1] - a[head] + 1 <= m) tail++;\n    ans = max(ans, tail - head + 1), tail++;\n    if (tail > n) break;\n    while (head <= tail && a[tail] - a[head] + 1 > m) head++;\n  }\n  printf(\"%d\\n\", n - ans);\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "#!/usr/bin/env python\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\nimport random\nimport collections\nimport math\nimport itertools\nimport bisect\n\ndef real_main():\n    n, I = read_int_array()\n    I *= 8\n    nums = read_int_array()\n    nums.sort()\n    print(solve(n, I, nums))\n\ndef solve(n, I, nums):\n    sizes = [len(list(gp)) for _, gp in itertools.groupby(nums)]\n    K = len(sizes)\n    if I >= (K - 1).bit_length() * n:\n        return 0\n\n    target_K = (1 << (I // n))\n\n    count = 0\n    for i in range(target_K):\n        count += sizes[i]\n\n    max_count = count\n    for i in range(target_K, K):\n        count += sizes[i] - sizes[i - target_K]\n        max_count = max(max_count, count)\n    return n - max_count\n\ndef main():\n    if False and 'PYCHARM_HOSTED' in os.environ:\n        main_pycharm()\n    else:\n        real_main()\n\n\nfrom copy import deepcopy\ndef main_pycharm():\n    solution = solve\n\n    test_inputs = None\n    test_outputs = None\n    judge = None\n    slow_solution = None\n    if solution is not None:\n        if test_outputs is not None:\n            test_with_answers(solution, test_inputs, test_outputs)\n        if judge is not None:\n            test_with_judge(solution, test_inputs, judge)\n        if slow_solution is not None:\n            test_with_slow_solution(solution, test_inputs, slow_solution)\n\n\ndef test_with_answers(solution, inputs, answers):\n    total, wrong = 0, 0\n    for args, test_ans in zip(inputs, answers):\n        ans = solution(*deepcopy(args))\n        if ans != test_ans:\n            print('WRONG! ans=%s, test_ans=%s, args=%s' % (ans, test_ans, args))\n            wrong += 1\n        else:\n            print('GOOD')\n        total += 1\n    print('ALL %d TESTS PASSED' % total if not wrong else '%d out of %d tests are WRONG' % (wrong, total))\n\n\ndef test_with_judge(solution, inputs_gen, judge):\n    total, wrong = 0, 0\n    for args in inputs_gen:\n        ans = solution(*deepcopy(args))\n        if not judge(deepcopy(ans), *deepcopy(args)):\n            print('WRONG! ans=%s, args=%s' % (ans, args))\n            wrong += 1\n        total += 1\n    print('ALL %d TESTS PASSED' % total if not wrong else '%d out of %d tests are WRONG' % (wrong, total))\n\n\ndef test_with_slow_solution(solution, inputs_gen, solution_slow):\n    total, wrong = 0, 0\n    for args in inputs_gen:\n        ans = solution(*deepcopy(args))\n        slow = solution_slow(*deepcopy(args))\n        if ans != slow:\n            print('WRONG! ans=%s, slow=%s, args=%s' % (ans, slow, args))\n            wrong += 1\n        total += 1\n    print('ALL %d TESTS PASSED' % total if not wrong else '%d out of %d tests are WRONG' % (wrong, total))\n\ndef generate_nums(n, min, max, check_if_good=None):\n    while True:\n        nums = [random.randint(min, max) for _ in range(n)]\n        if check_if_good is None or check_if_good(nums):\n            return nums\n\n# This mergesort can be like 7 times faster than build in sort\n# (for stupid reasons)\ndef mergesort(A, key=lambda x: x, reverse=False):\n    C = A\n    A = list(range(len(A)))\n    B = list(A)\n\n    n = len(A)\n    for i in range(0, n - 1, 2):\n        if key(C[A[i]]) > key(C[A[i ^ 1]]):\n            A[i], A[i ^ 1] = A[i ^ 1], A[i]\n\n    width = 2\n    while width < n:\n        for i in range(0, n, 2 * width):\n            R1, R2 = min(i + width, n), min(i + 2 * width, n)\n            j, k = R1, i\n            while i < R1 and j < R2:\n                if key(C[A[i]]) > key(C[A[j]]):\n                    B[k] = A[j]\n                    j += 1\n                else:\n                    B[k] = A[i]\n                    i += 1\n                k += 1\n            while i < R1:\n                B[k] = A[i]\n                k += 1\n                i += 1\n            while k < R2:\n                B[k] = A[k]\n                k += 1\n        A, B = B, A\n        width *= 2\n\n    if reverse:\n        A.reverse()\n    return A\n\ndef mergesort_simple(A, reverse=False):\n    C = A\n    A = list(range(len(A)))\n    B = list(A)\n\n    n = len(A)\n    for i in range(0, n - 1, 2):\n        if C[A[i]] > C[A[i ^ 1]]:\n            A[i], A[i ^ 1] = A[i ^ 1], A[i]\n\n    width = 2\n    while width < n:\n        for i in range(0, n, 2 * width):\n            R1, R2 = min(i + width, n), min(i + 2 * width, n)\n            j, k = R1, i\n            while i < R1 and j < R2:\n                if C[A[i]] > C[A[j]]:\n                    B[k] = A[j]\n                    j += 1\n                else:\n                    B[k] = A[i]\n                    i += 1\n                k += 1\n            while i < R1:\n                B[k] = A[i]\n                k += 1\n                i += 1\n            while k < R2:\n                B[k] = A[k]\n                k += 1\n        A, B = B, A\n        width *= 2\n\n    if reverse:\n        A.reverse()\n    return A\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef read():\n    return input()\n\ndef read_int():\n    return int(input())\n\ndef read_array(sep=None, maxsplit=-1):\n    return input().split(sep, maxsplit)\n\ndef read_int_array():\n    return [int(a) for a in read_array()]\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
            "language": 4,
            "solution": "import java.lang.*;\nimport java.math.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n    void solve() {\n        int n=ni(); long I=nl()*8;\n        ArrayList<Integer> arr=new ArrayList<>();\n\n        int a[]= new int[n+1];\n        for(int i=1;i<=n;i++) arr.add(ni());\n        Collections.sort(arr);\n        for(int i=1;i<=n;i++) a[i]=arr.get(i-1);\n        int cc[]=new int[n+1];\n\n        int pref[]=new int[n+1];\n\n        a[0]=-1;\n\n        for(int i=1;i<=n;i++){\n            pref[i]=pref[i-1];\n            cc[i]=1;\n            if(a[i]!=a[i-1]){\n                pref[i]++;\n\n            }else  cc[i]+=cc[i-1];\n\n        }\n\n        int cc2[]=new int[n+2];\n        cc2[n]=1;\n        for(int i=n-1;i>=1;i--){\n            cc2[i]=1;\n            if(a[i]==a[i+1]) cc2[i]+=cc2[i+1];\n        }\n        int ans=Integer.MAX_VALUE;\n\n        int val[]=new int[n+1];\n        for(int i=1;i<=n;i++) val[i]=get(i);\n        int l,r,idx,mid;\n        for(int i=1;i<=n;i++){\n             l=i; r=n; idx=-1;\n            while(l<=r){\n                mid=(l+r)>>1;\n                if(n*1L*val[pref[mid]-pref[i-cc[i]]]<=I){\n                    idx=mid;\n                    l=mid+1;\n                }else r=mid-1;\n            }\n           ans=Math.min(ans,i-cc[i]+(n-(idx+cc2[idx]-1)));\n           i+=cc2[i]-1;\n\n        }\n        pw.println(ans);\n    }\n    int get(int n){\n        int cc=0;\n        n--;\n        while(n>0){\n            n/=2;\n            cc++;\n        }\n        return cc;\n    }\n\n    long M = (long) 1e9 + 7;\n    InputStream is;\n    PrintWriter pw;\n    String INPUT = \"\";\n\n    void run() throws Exception {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        pw = new PrintWriter(System.out);\n        long s = System.currentTimeMillis();\n        solve();\n        pw.flush();\n        if (!INPUT.isEmpty()) tr(System.currentTimeMillis() - s + \"ms\");\n\n\n    }\n\n    public static void main(String[] args) throws Exception {\n        new Main().run();\n    }\n\n    private byte[] inbuf = new byte[1024];\n    public int lenbuf = 0, ptrbuf = 0;\n\n    private int readByte() {\n        if (lenbuf == -1) throw new InputMismatchException();\n        if (ptrbuf >= lenbuf) {\n            ptrbuf = 0;\n            try {\n                lenbuf = is.read(inbuf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (lenbuf <= 0) return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n\n    private boolean isSpaceChar(int c) {\n        return !(c >= 33 && c <= 126);\n    }\n\n    private int skip() {\n        int b;\n        while ((b = readByte()) != -1 && isSpaceChar(b)) ;\n        return b;\n    }\n\n    private double nd() {\n        return Double.parseDouble(ns());\n    }\n\n    private char nc() {\n        return (char) skip();\n    }\n\n    private String ns() {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != ' ')\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    private char[] ns(int n) {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while (p < n && !(isSpaceChar(b))) {\n            buf[p++] = (char) b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n\n    private char[][] nm(int n, int m) {\n        char[][] map = new char[n][];\n        for (int i = 0; i < n; i++) map[i] = ns(m);\n        return map;\n    }\n\n    private int[] na(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = ni();\n        return a;\n    }\n\n    private int ni() {\n        int num = 0, b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n\n    private long nl() {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n\n    private boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n    private void tr(Object... o) {\n        if (INPUT.length() > 0) System.out.println(Arrays.deepToString(o));\n    }\n\n}"
        },
        {
            "language": 1,
            "solution": "from collections import Counter\nn,k=map(int,raw_input().split())\na=map(int,raw_input().split())\nd=Counter(a)\na=list(set(a))\na.sort()\nl=len(a)\nc=[0]\nfor i in a:\n    c.append(c[-1]+d[i])\nm=n\nk*=8\nk=k//n\nk=pow(2,k)\nif l<=k:\n    print 0\nelse:\n    for i in range(l-k):\n        m=min(m,n-c[i+k]+c[i])\n    print m"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n \npublic class Main {\n\tpublic static void main(String args[]) {new Main().run();}\n\t\n\tScanner in = new Scanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\tvoid run(){\n\t    out.println(work());\n\t    out.flush();\n\t}\n\tint work() {\n\t    int n=in.nextInt();\n\t    int I=in.nextInt();\n\t    Integer[] A=new Integer[n];\n\t    for(int i=0;i<n;i++){\n\t        A[i]=in.nextInt();\n\t    }\n\t    int b=8*I/n;\n\t    Arrays.sort(A);\n\t    int cnt=0;\n\t    for(int nn=n;nn>0;nn>>=1,cnt++);//up limit\n\t    if(cnt<b){\n\t        return 0;\n\t    }\n\t    int num=1<<b;\n\t    \n\t    HashMap<Integer,Integer> map=new HashMap<>();\n\t    int max=0;\n\t   // if(n==200000&&I==8) System.out.println(n);\n\t    for(int i=0,j=0,c=0;j<n;j++){\n\t        map.put(A[j],map.getOrDefault(A[j],0)+1);\n\t        if(map.get(A[j])==1){\n\t            c++;\n\t        }\n\t        while(c>num){\n\t           map.put(A[i],map.getOrDefault(A[i],0)-1);\n\t           if(map.get(A[i])==0){\n\t               map.remove(A[i]);\n\t               c--;\n\t           }\n\t           i++;\n\t        }\n\t        max=Math.max(max,j-i+1);\n\t    }\n\t    return n-max;\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long n, I;\n  cin >> n >> I;\n  I *= 8LL;\n  map<long long, long long> mp;\n  for (int i = 0, x; i < n; ++i) {\n    cin >> x;\n    mp[x]++;\n  }\n  vector<pair<int, int>> v;\n  for (auto i : mp) {\n    v.push_back(make_pair(i.first, i.second));\n  }\n  sort(v.begin(), v.end());\n  long long k = min((I / n), 25LL);\n  long long K = (1LL << k);\n  if (K >= (int)v.size())\n    cout << 0 << '\\n';\n  else {\n    vector<long long> s(v.size(), 0);\n    for (int i = 0; i < (int)v.size(); ++i) {\n      s[i] = (!i ? 0 : s[i - 1]) + v[i].second;\n    }\n    long long ans = 1LL << 20;\n    for (int i = K - 1, j = 0; i < (int)v.size(); ++i, ++j) {\n      ans = min(ans, n - (s[i] - (!j ? 0 : s[j - 1])));\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class CandidateCode {\n    public static void main(String[] args) throws Exception {\n//        Scanner sc = new Scanner(System.in);\n        FastReader sc = new FastReader();\n        int n=sc.nextInt();\n        int nits=sc.nextInt()*8;\n        TreeMap<Integer,Integer> set=new TreeMap<>();\n        for (int i=0;i<n;i++){\n            int x=sc.nextInt();\n            set.put(x,set.getOrDefault(x,0)+1);\n        }\n        int l=1,r=n;\n        int ans=-1;\n        while (l<=r){\n            int mid=l+(r-l)/2;\n            if (log(mid)*n<=nits){\n                ans=mid;\n                l=mid+1;\n            }else r=mid-1;\n        }\n        int no[]=new int[set.size()];\n        int freq[]=new int[set.size()];\n        int c=0;\n        for (int i:set.keySet()){\n            no[c]=i;\n            freq[c++]=set.get(i);\n        }\n        for (int i=1;i<c;i++){\n            freq[i]+=freq[i-1];\n        }\n//        System.out.println(ans);\n        ans=set.size()-ans;// remove atleast this much\n        if (ans>0){\n            int x=set.size()-ans;\n            int min=Integer.MAX_VALUE;\n            for (int i=0;i+x-1<c;i++){\n                int a=freq[c-1];\n                if (i==0){\n                    a-=freq[i+x-1];\n                }else {\n                    a-=(freq[i+x-1]-freq[i-1]);\n                }\n                min=Math.min(a,min);\n            }\n            System.out.println(min);\n        }\n        else System.out.println(0);\n    }\n\n    static int log(int k){\n        return (int)Math.ceil(Math.log(k)/Math.log(2D));\n    }\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "from math import ceil, log2\nn, I = map(int, input().split())\ndata = list(map(int, input().split()))\ndata.sort()\nneedK = (I * 8) // n\ndistinct = len(set(data))\nif needK >= ceil(log2(distinct)):\n    print(0)\n    exit()\npref = [0] * distinct\ncur = data[0]\nind = 0\nfor val in data:\n    if val != cur:\n        ind += 1\n        cur = val\n    pref[ind] += 1\nwaste = distinct - 2**needK\nbad = 0\np = waste\nfor i in range(p):\n    bad += pref[i]\nans = bad\nfor i in range(p - 1, -1, -1):\n    bad -= pref[i]\n    bad += pref[distinct - 1 - (p - 1 - i)]\n    ans = min(ans, bad)\nprint(ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long MOD = int(1e9) + 7;\nint debug = 1;\nconst int N = int(1e6) + 5;\nusing namespace std;\nint a[N], b[N], s[N];\nvector<int> every;\nint get(int l, int r) {\n  if (r > N - 1) r = N - 1;\n  return s[r] - s[l - 1];\n}\nint main() {\n  long long i, j, n, t, m;\n  ios::sync_with_stdio(false);\n  cin >> n >> m;\n  for (i = 0; i < n; i++) {\n    cin >> a[i];\n    every.push_back(a[i]);\n  }\n  sort(every.begin(), every.end());\n  every.erase(unique(every.begin(), every.end()), every.end());\n  ;\n  for (i = 0; i < n; i++) {\n    b[(lower_bound(every.begin(), every.end(), a[i]) - every.begin()) + 1]++;\n  }\n  for (i = 1; i < N; i++) s[i] = s[i - 1] + b[i];\n  long long num_bits = 8 * m / n;\n  if (num_bits >= 20) {\n    cout << 0;\n    return 0;\n  }\n  int maxrange = (1 << num_bits);\n  int ans = n;\n  for (i = 1; i <= n; i++) {\n    ans = min(ans, (int)n - get(i, i + maxrange - 1));\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 4,
            "solution": "/**\n * Created by happygirlzt on 2019-08-02\n */\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    public static int solve(int n, int i, int[] a) {\n        int maxk = 8 * i / n;\n        if (maxk >= 20) return 0;\n        int maxK = (int) Math.pow(2, Math.min(20, maxk));\n\n        TreeMap<Integer, Integer> map = new TreeMap<>();\n        for (int j : a) {\n            map.put(j, map.getOrDefault(j, 0) + 1);\n        }\n\n        int[] all = new int[map.size()];\n        int at = 0;\n        for (int j : map.values()) {\n            all[at++] = j;\n        }\n\n        if (all.length <= maxK) return 0;\n        long[] preSum = new long[all.length + 1];\n        for (int j = 0; j < all.length; j++) {\n            preSum[j + 1] = preSum[j] + all[j];\n        }\n        long res = 0;\n        for (int j = maxK; j <= all.length; j++) {\n            res = Math.max(res, preSum[j] - preSum[j - maxK]);\n        }\n\n        return (int) (n - res);\n    }\n\n    public static void main(String[] args) {\n        FastReader fr = new FastReader();\n        int n = fr.nextInt();\n        int i = fr.nextInt();\n        int[] a = new int[n];\n        for (int j = 0; j < n; j++) {\n            a[j] = fr.nextInt();\n        }\n\n        System.out.println(solve(n, i, a));\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "n, I = map(int, input().split())\na = list(map(int, input().split()))\n# a.sort()\nd = {}\ncount = 0\n\nfor i in range(n):\n\tif a[i] not in d:\n\t\tcount+=1\n\t\td[a[i]] = 1\n\telse:\n\t\td[a[i]]+=1\nash = list(set(a))\nash.sort()\n# print(count, k)\nimport math\nif math.ceil(math.log2(count))*n <= I*8:\n\tprint(0)\nelse:\n\tk = pow(2,((I*8)//n))\n\tmi = -1\n\tl = ash[:k]\n\tsu = 0\n\tfor j in l:\n\t\tsu+=d[j]\n\tif mi<(su):\n\t\tmi=su\n\t# print(k)\n\tfor i in range(1,len(ash)-k+1):\n\t\tsu = su-d[ash[i-1]]+d[ash[i+k-1]]\n\t\tif mi<(su):\n\t\t\tmi=su\n\tif mi<su:\n\t\tmi=su\n\tif n-mi == 134454:\n\t\tprint(k)\n\t\n\tprint(n-mi)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MAXN = 4e5 + 5, MAXM = 1e6 + 5, MOD = 1e9 + 7, INF = 0x3f3f3f3f,\n          N = 2e5;\nconst long long INFL = 0x3f3f3f3f3f3f3f3f;\nconst double eps = 1e-9;\nusing namespace std;\nint n, I, a[MAXN], b[MAXN], sum[MAXN];\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> n >> I;\n  for (int i = 1; i <= n; i++) cin >> a[i], b[i] = a[i];\n  sort(b + 1, b + 1 + n);\n  int len = unique(b + 1, b + 1 + n) - b - 1;\n  int up = 1;\n  for (int i = 1; i <= I * 8 / n; i++) {\n    up <<= 1;\n    if (up >= len) break;\n  }\n  up = min(up, len);\n  for (int i = 1; i <= n; i++) a[i] = lower_bound(b + 1, b + 1 + len, a[i]) - b;\n  for (int i = 1; i <= n; i++) sum[a[i]]++;\n  for (int i = 1; i <= len; i++) sum[i] += sum[i - 1];\n  int ans = INF;\n  for (int i = 1; i <= len; i++) {\n    ans = min(ans, n - sum[min(len, i + up - 1)] + sum[i - 1]);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import Counter\nfrom math import ceil,log2,floor,pow\n[n,i]=[int(x) for x in input().split()]\nmaxbits=8*i\narr=[int(x) for x in input().split()]\nfr=Counter(arr)\n\narr1=(sorted(fr.keys()))\n\nt=K=len(arr1)\nk=ceil(log2(K))\nif(n*k<=maxbits):\n    print(0)\nelse:\n    k=floor(maxbits/n)\n    K=2**k\n    \n    su=sum([fr[arr1[x]] for x in range(t)])\n    i=0\n    j=K-1\n    ma=-1\n    temp=sum([fr[arr1[x]] for x in range(i,j+1)])\n    while(j<t):\n        \n        if temp>ma:ma=temp\n        i+=1\n        j+=1\n        if j>=t:break\n        temp=temp-fr[arr1[i-1]]+fr[arr1[j]]\n    print(su-ma)\n\n\n\n\n\n\n"
        },
        {
            "language": 3,
            "solution": "\"\"\"\n    Author - Satwik Tiwari .\n    27th Oct , 2020  - Tuesday\n\"\"\"\n\n#===============================================================================================\n#importing some useful libraries.\n\n\nfrom __future__ import division, print_function\nfrom fractions import Fraction\nimport sys\nimport os\nfrom io import BytesIO, IOBase\nfrom functools import cmp_to_key\n\n# from itertools import *\nfrom heapq import *\nfrom math import gcd, factorial,floor,ceil\n\nfrom copy import deepcopy\nfrom collections import deque\n\n\nfrom bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom bisect import bisect\n\n#==============================================================================================\n#fast I/O region\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n# inp = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n#===============================================================================================\n### START ITERATE RECURSION ###\nfrom types import GeneratorType\ndef iterative(f, stack=[]):\n  def wrapped_func(*args, **kwargs):\n    if stack: return f(*args, **kwargs)\n    to = f(*args, **kwargs)\n    while True:\n      if type(to) is GeneratorType:\n        stack.append(to)\n        to = next(to)\n        continue\n      stack.pop()\n      if not stack: break\n      to = stack[-1].send(to)\n    return to\n  return wrapped_func\n#### END ITERATE RECURSION ####\n\n#===============================================================================================\n#some shortcuts\n\ndef inp(): return sys.stdin.readline().rstrip(\"\\r\\n\") #for fast input\ndef out(var): sys.stdout.write(str(var))  #for fast output, always take string\ndef lis(): return list(map(int, inp().split()))\ndef stringlis(): return list(map(str, inp().split()))\ndef sep(): return map(int, inp().split())\ndef strsep(): return map(str, inp().split())\n# def graph(vertex): return [[] for i in range(0,vertex+1)]\ndef zerolist(n): return [0]*n\ndef nextline(): out(\"\\n\")  #as stdout.write always print sring.\ndef testcase(t):\n    for pp in range(t):\n        solve(pp)\ndef printlist(a) :\n    for p in range(0,len(a)):\n        out(str(a[p]) + ' ')\ndef google(p):\n    print('Case #'+str(p)+': ',end='')\ndef lcm(a,b): return (a*b)//gcd(a,b)\ndef power(x, y, p) :\n    res = 1     # Initialize result\n    x = x % p  # Update x if it is more , than or equal to p\n    if (x == 0) :\n        return 0\n    while (y > 0) :\n        if ((y & 1) == 1) : # If y is odd, multiply, x with result\n            res = (res * x) % p\n\n        y = y >> 1      # y = y/2\n        x = (x * x) % p\n    return res\ndef ncr(n,r): return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))\ndef isPrime(n) :\n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) :\n        if (n % i == 0 or n % (i + 2) == 0) :\n            return False\n        i = i + 6\n    return True\ninf = pow(10,20)\nmod = 10**9+7\n#===============================================================================================\n# code here ;))\n\ndef bucketsort(order, seq):\n    buckets = [0] * (max(seq) + 1)\n    for x in seq:\n        buckets[x] += 1\n    for i in range(len(buckets) - 1):\n        buckets[i + 1] += buckets[i]\n\n    new_order = [-1] * len(seq)\n    for i in reversed(order):\n        x = seq[i]\n        idx = buckets[x] = buckets[x] - 1\n        new_order[idx] = i\n\n    return new_order\n\n\ndef ordersort(order, seq, reverse=False):\n    bit = max(seq).bit_length() >> 1\n    mask = (1 << bit) - 1\n    order = bucketsort(order, [x & mask for x in seq])\n    order = bucketsort(order, [x >> bit for x in seq])\n    if reverse:\n        order.reverse()\n    return order\n\n\ndef long_ordersort(order, seq):\n    order = ordersort(order, [int(i & 0x7fffffff) for i in seq])\n    return ordersort(order, [int(i >> 31) for i in seq])\n\n\ndef multikey_ordersort(order, *seqs, sort=ordersort):\n    for i in reversed(range(len(seqs))):\n        order = sort(order, seqs[i])\n    return order\n\n\n#for pair like (l,r) make array of l and r separately\n# l = []\n# r = []\n# for i in range(10):\n#     l.append(2)\n#     if(i%2==1):\n#         r.append(i+1)\n#     else:\n#         r.append(i-1)\n#\n# #pass it like this. if req triplet make on more like above.\n#\n# ans = multikey_ordersort(range(10),l,r)\n#return indexes of sorted order. build list of tupples if you want.\n\ndef chck(mind,n,ii):\n    cnt = 0\n    while(2**cnt<mind):\n        cnt+=1\n\n    if(n*cnt<=ii):\n        return True\n    return False\n\ndef solve(case):\n    n,ii = sep()\n    ii*=8\n    a = lis()\n    cnt = {}\n    for i in range(n):\n        if(a[i] not in cnt):\n            cnt[a[i]] = 1\n        else:\n            cnt[a[i]] +=1\n\n    req = 1\n    lo = 1\n    hi = 10**9\n    while(lo<=hi):\n        mid = (lo+hi)//2\n        if(chck(mid,n,ii)):\n            req = max(req,mid)\n            lo = mid+1\n        else:\n            hi = mid-1\n\n    if(req>=len(set(a))):\n        print(0)\n        return\n\n    l = []\n    r = []\n    for i in cnt:\n        l.append(i)\n        r.append(cnt[i])\n\n    order = multikey_ordersort(range(len(l)),l,r)\n    curr = []\n    for i in order:\n        curr.append(r[i])\n        # print(l[i],r[i])\n\n    # print(curr)\n    ans = n-1\n    pre = [0]*(n+1)\n    for i in range(len(curr)):\n        pre[i] = pre[i-1] + curr[i]\n\n    n = len(curr)\n    for i in range(n):\n        if(i+req>n-1):\n            continue\n        else:\n            temp = pre[i-1] + pre[n-1] - pre[i+req-1]\n        # print(i,i+req,temp,pre[i-1],pre[n-1],pre[i+req])\n        ans = min(ans,temp)\n\n    print(ans)\n\n\n\n\n\n\ntestcase(1)\n# testcase(int(inp()))\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long logc(long long n) {\n  if (n & (n - 1)) {\n    n |= n >> 16;\n    n |= n >> 8;\n    n |= n >> 4;\n    n |= n >> 2;\n    n |= n >> 1;\n    n++;\n  }\n  return __builtin_ctz(n);\n}\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  long long n, i;\n  cin >> n >> i;\n  i *= 8;\n  map<long long, long long> m;\n  for (long long i = 0; i < n; i++) {\n    long long t;\n    cin >> t;\n    m[t]++;\n  }\n  long long curr = 0;\n  long long mn = n + 1;\n  long long ns = i / n;\n  long long drop = m.size() - (1ll << ns);\n  auto l = m.begin();\n  auto r = m.end();\n  if (drop <= 0 || ns > 31) {\n    cout << 0;\n    return 0;\n  }\n  for (long long i = 0; i < drop; i++, l++) {\n    curr += (*l).second;\n  }\n  mn = curr;\n  l--;\n  r--;\n  for (long long i = 1; i <= drop; i++, l--, r--) {\n    curr += (*r).second;\n    curr -= (*l).second;\n    mn = min(mn, curr);\n  }\n  cout << mn;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst long long mod = 10007;\nconst int N = 2e5 + 100;\nint n, I, a[2 * N], b[2 * N];\nint sum[2 * N], x, len = 0;\nvoid prinf() {\n  for (int i = 1; i <= len; i++) printf(\"%d \", sum[i]);\n  printf(\"\\n\");\n}\nint main() {\n  scanf(\"%d%d\", &n, &I);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  sort(a + 1, a + n + 1);\n  for (int i = 1; i <= n; i++) {\n    if (a[i] != a[i - 1])\n      b[i] = ++len;\n    else\n      b[i] = b[i - 1];\n  }\n  for (int i = 1; i <= n; i++) sum[b[i]]++;\n  for (int i = 1; i <= len; i++) sum[i] += sum[i - 1];\n  int kk = ((long long)I * 8) / n;\n  if (kk >= 30)\n    kk = 2 * N;\n  else\n    kk = pow(2, kk);\n  if (kk > len)\n    printf(\"0\\n\");\n  else {\n    int ans = 0;\n    for (int i = kk; i <= len; i++) ans = max(ans, sum[i] - sum[i - kk]);\n    printf(\"%d\\n\", n - ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "R=lambda:map(int,input().split())\nn,I=R()\na=sorted(R())\nb=[0]+[i+1for i in range(n-1)if a[i]<a[i+1]]+[n]\nprint(n-max((y-x for x,y in zip(b,b[1<<8*I//n:])),default=n))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mod = 1000000007;\nconst long long num = 1000000000;\nconst long long sz = 1000002;\nint main() {\n  long long q = 1;\n  while (q--) {\n    long long n, I;\n    cin >> n >> I;\n    long long k = (8 * I) / n;\n    long long K = (k > 20) ? INT_MAX : pow(2, k);\n    vector<long long> vec(n);\n    for (int i = 0; i < n; i++) {\n      cin >> vec[i];\n    }\n    sort(vec.begin(), vec.end());\n    vector<pair<long long, long long> > res;\n    long long temp = vec[0];\n    long long count = 0;\n    for (int i = 0; i < n; i++) {\n      if (vec[i] == temp)\n        count++;\n      else {\n        res.push_back(make_pair(temp, count));\n        temp = vec[i];\n        count = 1;\n      }\n    }\n    res.push_back(make_pair(temp, count));\n    if (K >= res.size()) {\n      cout << 0 << endl;\n    } else {\n      long long rem = max(0ll, (long long)(res.size()) - K);\n      vector<long long> prefix(res.size() + 1);\n      prefix[0] = 0;\n      for (int i = 0; i < res.size(); i++) {\n        prefix[i + 1] = prefix[i] + res[i].second;\n      }\n      long long mx = 0;\n      for (int i = 0; i + K < prefix.size(); i++) {\n        mx = max(mx, prefix[i + K] - prefix[i]);\n      }\n      cout << n - mx << endl;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long arr[400007];\nint main() {\n  long long n, b, x;\n  cin >> n >> b;\n  map<long long, long long> mp;\n  map<long long, long long>::iterator it;\n  map<long long, long long>::reverse_iterator rit;\n  for (long long i = 1; i <= n; ++i) {\n    cin >> x;\n    mp[x]++;\n  }\n  long long lg = ceil(log2(mp.size()));\n  long long need = lg * n, have = b * 8;\n  if (need <= have)\n    cout << 0 << endl;\n  else {\n    long long mn = have / n;\n    long long so = pow(2, mn);\n    long long rmv = mp.size() - so, s1 = 0, s2 = 0, i, ans = 1e9;\n    vector<long long> v;\n    for (it = mp.begin(); it != mp.end(); ++it) {\n      v.push_back(it->second);\n      s2 += it->second;\n    }\n    for (long long i = 0; i < v.size(); ++i) {\n      if (i < so)\n        s1 += v[i];\n      else {\n        ans = min(ans, s2 - s1);\n        s1 += v[i];\n        s1 -= v[i - so];\n      }\n    }\n    cout << min(ans, s2 - s1) << endl;\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class C {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint N = Integer.parseInt(st.nextToken());\n\t\tint I = Integer.parseInt(st.nextToken());\n\t\tint k = I*8/N;\n\t\tif(k > 20){\n\t\t\tSystem.out.println(0); return;\n\t\t}\n\t\tTreeMap<Integer, Integer> map = new TreeMap<>();\n\t\tst = new StringTokenizer(br.readLine());\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint a = Integer.parseInt(st.nextToken());\n\t\t\tif(map.containsKey(a)) map.put(a, map.get(a)+1);\n\t\t\telse map.put(a, 1);\n\t\t}\n\t\tint M = map.size();\n\t\tint K = 1 << k;\n\t\tif(K >= M){\n\t\t\tSystem.out.println(0); return;\n\t\t}\n\t\tInteger[] keys = new Integer[M];\n\t\tmap.keySet().toArray(keys);\n\t\tlong[] vals = new long[M];\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tvals[i] = map.get(keys[i]);\n\t\t}\n\t\tlong[] accv = new long[M+1];\n\t\tfor(int i = 1; i <= M; i++){\n\t\t\taccv[i] = vals[i-1] + accv[i-1];\n\t\t}\n\t\tlong min = 400001;\n\t\tfor(int a = 0; a + K - 1 < M; a++){\n\t\t\tlong curr = accv[M] - (accv[a+K] - accv[a]);\n\t\t\tmin = Long.min(min, curr);\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n\n}\n"
        },
        {
            "language": 3,
            "solution": "R=lambda:map(int,input().split())\nn,I=R()\na=sorted(R())\nb=[0]+[i+1for i in range(n-1)if a[i]<a[i+1]]\nprint(n-max(y-x for x,y in zip(b,b[1<<8*I//n:]+[n])))"
        },
        {
            "language": 3,
            "solution": "import atexit\nimport io\nimport sys\nfrom collections import Counter\nfrom math import log\nimport math\n_INPUT_LINES = sys.stdin.read().splitlines()\ninput = iter(_INPUT_LINES).__next__\n_OUTPUT_BUFFER = io.StringIO()\nsys.stdout = _OUTPUT_BUFFER\n\n\n@atexit.register\ndef write():\n    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())\n\n\n\n# R = lambda : map(int,input().split())\n# # t = int(input())\n# # for i in range(t):\n# n,k = map(int,input().split())\n# l = list(R())\n# c = Counter(l)\n# bts_avail = k*8 // n\n# disk_size = math.ceil(math.log(len(c),2))*n\n# if disk_size<=8*k:\n#     print(0)\n# else:\n#     dl = list(c.values())\n#     len_dl = len(dl)\n#     dl.sort()\n#     ans =0\n#     for i in dl:\n#         len_dl-=1\n#         ans+=i\n#         if math.log(len_dl,2)<=bts_avail:\n#             break\n#\n#     print(ans)\n# n, m = map(int, input().split())\n# a = sorted(map(int, input().split()))\n# b = [0]\n# print(a)\n# a += [1 << 30]\n# print(a)\n# for i in range(n):\n#     if a[i] < a[i+1]:\n#         b += [i+1]\n# print(b)\n#\n#\n# print(1<<8)\n# print(n-max((y-x for x,y in zip(b,b[1<<8*m//n:])),default=n))\n\nn,i= map(int, input().split())\nl= list(map(int, input().split()))\nk= (8*i)//n\nK= 2**k\nl.sort()\ntemp= [0]\nfor i in range(1,n):\n    if(l[i-1]!=l[i]):\n        temp.append(i)\n# print(temp)\nif(len(temp)<=K):\n    print(0)\nelse:\n    print(n - max(temp[i+K]-temp[i] for i in range(len(temp)-K)))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long t, n, i, j, k, l, m, p[23], a[401010], b[401010], aa[101010],\n    bb[101010];\nmap<long long, long long> v;\nconst int maxn = 100010;\nstring s1, s2, s3, s4;\nmap<long long, long long> q;\nset<long long> qq;\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  for (i = 1; i <= n; i++) {\n    cin >> m;\n    q[m]++;\n    qq.insert(m);\n  }\n  for (auto x : qq) {\n    a[++j] = q[x];\n  }\n  for (i = 1; i <= j; i++) {\n    a[i] += a[i - 1];\n  }\n  m = j;\n  while (ceil(log2(m)) * n > 8 * k) {\n    m--;\n  }\n  long long mi = 1e18;\n  for (i = m; i <= j; i++) {\n    mi = min(mi, n - (a[i] - a[i - m]));\n  }\n  cout << mi;\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import Counter\n\nn, I = map(int, input().split())\na = list(map(int, input().split()))\nc = Counter(a)\nsorted_keys = sorted(c.keys())\n\nacc_counts = [0] * (len(c) + 1)\nsorted_keys_len = len(sorted_keys)\nfor i in range(1, sorted_keys_len + 1):\n    acc_counts[i] = acc_counts[i - 1] + c[sorted_keys[i - 1]]\n# acc_counts[i] = sum(a[0:i])\n# acc_counts[y] - acc_counts[x] = sum(a[0:y]) - sum(a[0:x]) = sum(a[x:y])\n\nvariations = 2 ** (8 * I // n)\n\nif variations >= sorted_keys_len:\n    print(0)\nelse:\n    min_v = float('inf')\n    for i in range(1, sorted_keys_len + 1 - variations):\n        x, y = i, i + variations\n        v = acc_counts[y] - acc_counts[x]\n        min_v = min(min_v, n - v)\n    print(min_v)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[400006];\nvector<int> dis;\nint main() {\n  int i, j, m, n, c, x, l, y, t, bytes;\n  cin >> n >> bytes;\n  for (i = 0; i < n; i++) cin >> a[i];\n  sort(a, a + n);\n  int total = 1;\n  for (i = 1; i < n; i++) {\n    while (i < n && a[i] == a[i - 1]) {\n      total++;\n      i++;\n    }\n    dis.push_back(total);\n    total = 1;\n  }\n  if (a[n - 1] != a[n - 2]) dis.push_back(1);\n  bytes *= 8;\n  int bits = bytes / n;\n  if (bits > 31) {\n    cout << 0;\n    return 0;\n  }\n  total = pow(2, bits);\n  if (total >= dis.size()) {\n    cout << 0;\n    return 0;\n  }\n  int ans = 0;\n  int temp = 0;\n  for (i = 1; i < dis.size(); i++) {\n    dis[i] += dis[i - 1];\n  }\n  ans = dis[total - 1];\n  for (i = total; i < dis.size(); i++) {\n    ans = max(ans, dis[i] - dis[i - total]);\n  }\n  cout << n - ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.concurrent.ThreadLocalRandom;\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\npublic class C {\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint n = sc.nextInt();\n\t\tint I = 8 * sc.nextInt();\n        int[] arr = new int[n];\n        for(int i=0;i<n;i++)\n            arr[i] = sc.nextInt();\n\t\tshuffle(arr);\n\t\tArrays.sort(arr);\n\t\tHashMap<Integer, Integer> map = new HashMap<>();\n\t\tint idx = 0;\n\t\tfor(int i=0;i<arr.length;i++){\n\t\t\tif(!map.containsKey(arr[i])){\n\t\t\t\tmap.put(arr[i], idx++);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<arr.length;i++){\n\t\t\tarr[i] = map.get(arr[i]);\n\t\t}\n\t\tint[] occ = new int[idx];\n\t\tfor(int x : arr)\n\t\t\tocc[x]++;\n\t\tfor(int i=1;i<occ.length;i++)\n\t\t\tocc[i]+= occ[i-1];\n\t\t\n\t\tint i = 0, j = 0;\n\t\tint ans = n;\n\t\twhile(i < occ.length && j < occ.length){\n\t\t\tif(i > j){\n\t\t\t\tj++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint sum = getSum(i, j, occ);\n\t\t\tif(n * log2(j - i + 1) <= I){\n\t\t\t\tans = Math.min(ans, n - sum);\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tpw.println(ans);\n\t\tpw.flush();\n\t}\n\n\tstatic int log2(int c){\n\t\tint ans =(int) Math.ceil((Math.log(c) / Math.log(2)) - 1e-8);\n\t\treturn ans;\n\t}\n\n\tstatic int getSum(int i, int j, int[] arr){\n\t\tint out = arr[j];\n\t\tif(i > 0) out-= arr[i-1];\n\t\treturn out;\n\t}\n\n\tstatic void shuffle(int[] ar)\n\t{\n\t  Random rnd = ThreadLocalRandom.current();\n\t  for (int i = ar.length - 1; i > 0; i--)\n\t  {\n\t\tint index = rnd.nextInt(i + 1);\n\t\tint a = ar[index];\n\t\tar[index] = ar[i];\n\t\tar[i] = a;\n\t  }\n\t}\n\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid __print(int x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(long long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const char *x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const string &x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x) {\n  cerr << '{';\n  __print(x.first);\n  cerr << ',';\n  __print(x.second);\n  cerr << '}';\n}\ntemplate <typename T>\nvoid __print(const T &x) {\n  int f = 0;\n  cerr << '{';\n  for (auto &i : x) cerr << (f++ ? \",\" : \"\"), __print(i);\n  cerr << \"}\";\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n  __print(t);\n  if (sizeof...(v)) cerr << \", \";\n  _print(v...);\n}\nvoid pre() {}\nmap<long long, long long> m;\nvector<long long> w;\nvoid solve() {\n  long long n, s, x;\n  cin >> n >> s;\n  s *= 8;\n  for (int i = 0; i < (n); ++i) cin >> x, m[x] = m[x] + 1;\n  for (auto &it : m) w.push_back(it.second);\n  w.push_back(0);\n  long long j = 0, k = 0, p = 1, su = n, ans = 1e8;\n  while (n * (k + 1) <= s && p < n + 1) k++, p *= 2;\n  for (int i = 0; i < ((int)(w).size() - 1); ++i) {\n    while (j < (int)(w).size() - 1 && j - i < p) su -= w[j], j++;\n    ans = min(ans, su);\n    su += w[i];\n  }\n  cout << ans;\n}\nint main() {\n  cin.sync_with_stdio(0);\n  cin.tie(0);\n  cin.exceptions(cin.failbit);\n  pre();\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 400000 + 77;\nint n, k, A = N, a[N], LG[N];\nmap<int, int> M;\nint main() {\n  for (int i = 2; i < N; ++i) LG[i] = LG[((i + 1) >> 1)] + 1;\n  scanf(\"%d %d\", &n, &k);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", a + i);\n  k *= 8;\n  sort(a + 1, a + 1 + n);\n  int ri = 1, d = 1;\n  ++M[a[1]];\n  for (int i = 1; i <= n; ++i) {\n    while (LG[d] * 1ll * n <= k && ri < n) {\n      ++ri;\n      if (++M[a[ri]] == 1) ++d;\n    }\n    if (LG[d] * 1ll * n > k) {\n      --M[a[ri]];\n      --d;\n      --ri;\n    }\n    A = min(A, i - 1 + n - ri);\n    if ((--M[a[i]] == 0)) --d;\n  }\n  printf(\"%d\\n\", A);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long in[400001];\nint n, siz;\nint cnt[400001];\nlong long sum[400001];\nint ptr = 0;\nint get(int l, int r) {\n  if (l < 0) l = 0;\n  if (r >= ptr) r = ptr - 1;\n  if (l == 0) {\n    return sum[r];\n  } else {\n    return sum[r] - sum[l - 1];\n  }\n}\nint main() {\n  cin >> n >> siz;\n  for (int i = 0; i < n; i++) {\n    cin >> in[i];\n  }\n  long long res = pow(2, (long long)siz * (long long)8 / n);\n  sort(in, in + n);\n  cnt[0]++;\n  for (int i = 1; i < n; i++) {\n    if (in[i] != in[i - 1]) {\n      ptr++;\n    }\n    cnt[ptr]++;\n  }\n  ptr++;\n  int bit = 0;\n  int safe_ptr = ptr;\n  while (safe_ptr > 0) {\n    bit++;\n    safe_ptr /= 2;\n  }\n  if ((long long)bit * n < siz * 8) {\n    cout << 0;\n    return 0;\n  }\n  sum[0] = cnt[0];\n  for (int i = 0; i < ptr; i++) {\n    sum[i] = sum[i - 1] + cnt[i];\n  }\n  int best = 0;\n  for (int i = 1; i < ptr - res + 1; i++) {\n    if (get(i, i + res - 1) > get(best, best + res - 1)) {\n      best = i;\n    }\n  }\n  cout << sum[ptr - 1] - get(best, best + res - 1);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.lang.*;\nimport java.math.*;\n \npublic class Main{\n\t\n\tstatic ArrayList a[]=new ArrayList[200001];\n\n\tpublic void solve () {\n\t\tInputReader in = new InputReader(System.in);\n\t    PrintWriter pw = new PrintWriter(System.out); \n\t    int n=in.nextInt();\n\t    long s=in.nextLong();\n\t    long bit=s*8L;\n\t    long use=bit/n;\n\t    long a[]=new long [n];\n\t    \n\t    TreeMap<Long,Integer>hm=new TreeMap<>();\n\t    for(int i=0;i<n;i++) {\n\t    \ta[i]=in.nextLong();\n\t    \tif(hm.containsKey(a[i])) {\n\t    \t\thm.put(a[i], hm.get(a[i])+1);\n\t    \t}\n\t    \telse {\n\t    \t\thm.put(a[i], 1);\n\t    \t}\n\t    }\n\t    Vector<Long>v=new Vector<>(hm.keySet());\n\t    int l=0;\n\t    int r=v.size()-1;\n\t    int maxi=-1;\n\t    int val=1;\n\t    int b=0;\n\t   while(v.size()>val) {\n\t\t   val*=2L;\n\t\t   b++;\n\t   }\n\t   long suf[]=new long [v.size()+5];\n\t   for(int i=v.size()-1;i>=0;i--) {\n\t\t   suf[i]=suf[i+1]+hm.get(v.get(i));\n\t   }\n\t   if(b<=use) {\n\t\t   pw.print(0);\n\t   }\t   \n\t   else {\n\t\t   int got=0;\n\t\t   long can=(long) Math.pow(2L, use);\n\t\t   long ans=n+1;\n\t\t   for(int i=0;i<v.size();i++) {\n\t\t\t    ans=Math.min(ans, got+(i+can>=v.size()?0:suf[(int) (i+can)]));\n\t\t\t    got+=hm.get(v.get(i));\n\t\t   }\n\t\t   pw.println(ans);\n\t   }\n\t\tpw.flush();\n\t\tpw.close();\n\t}\n\tpublic static void main(String[] args) throws Exception {\n        \n        \n        new Thread(null,new Runnable() {\n        \tpublic void run() {\n        \t\tnew Main().solve();\n        \t}\n        },\"1\",1<<26).start();\n        \n        \n    }\n    static void debug(Object... o) {\n    \tSystem.out.println(Arrays.deepToString(o));\n        }\n        \n        static class InputReader \n        {\n        private final InputStream stream;\n        private final byte[] buf = new byte[8192];\n        private int curChar, snumChars;\n        private SpaceCharFilter filter;\n \n        public InputReader(InputStream stream) \n        {\n            this.stream = stream;\n        }\n        public int snext() \n        {\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) \n            {\n                curChar = 0;\n                try \n                {\n                    snumChars = stream.read(buf);\n                } \n                catch (IOException e) \n                {\n                    throw new InputMismatchException();\n                }\n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n \n        public int nextInt() \n        {\n            int c = snext();\n            while (isSpaceChar(c)) \n            {\n                c = snext();\n            }\n            int sgn = 1;\n            if (c == '-')\n            {\n                sgn = -1;\n                c = snext();\n            }\n            int res = 0;\n            do \n            {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n \n        public long nextLong()\n        {\n            int c = snext();\n            while (isSpaceChar(c)) \n            {\n                c = snext();\n            }\n            int sgn = 1;\n            if (c == '-') \n            {\n                sgn = -1;\n                c = snext();\n            }\n            long res = 0;\n            do \n            {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n \n        public int[] nextIntArray(int n) \n        {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) \n            {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n \n        public String readString()\n        {\n            int c = snext();\n            while (isSpaceChar(c)) \n            {\n                c = snext();\n            }\n            StringBuilder res = new StringBuilder();\n            do \n            {\n                res.appendCodePoint(c);\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n \n        public String nextLine() \n        {\n            int c = snext();\n            while (isSpaceChar(c))\n                c = snext();\n            StringBuilder res = new StringBuilder();\n            do \n            {\n                res.appendCodePoint(c);\n                c = snext();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        }\n \n        public boolean isSpaceChar(int c) \n        {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n \n        private boolean isEndOfLine(int c) \n        {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n \n        public interface SpaceCharFilter\n        {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n        public static long mod = 1000000007;\n        public static int d;\n        public static int p;\n        public static int q;\n        public void extended(int a,int b) {\n        \tif(b==0) {\n        \t\td=a;\n        \t\tp=1;\n        \t\tq=0;\n        \t}\n        \telse\n        \t{\n        \t\textended(b,a%b);\n        \t\tint temp=p;\n        \t\tp=q;\n        \t\tq=temp-(a/b)*q;\n        \t}\n        }\n        public static long[] shuffle(long[] a,Random gen)\n        {\n            int n = a.length;\n            for(int i=0;i<n;i++)\n            {\n                int ind = gen.nextInt(n-i)+i;\n                long temp = a[ind];\n                a[ind] = a[i];\n                a[i] = temp;\n            }\n            return a;\n        }\n        \n        public static void swap(int a, int b){\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n        \n        public static HashSet<Integer> primeFactorization(int n)\n        {\n            HashSet<Integer> a =new HashSet<Integer>();\n            for(int i=2;i*i<=n;i++)\n            {\n                while(n%i==0)\n                {\n                    a.add(i);\n                    n/=i;\n                }\n            }\n            if(n!=1)\n                a.add(n);\n            return a;\n        }\n        \n        public static void sieve(boolean[] isPrime,int n)\n        {\n            for(int i=1;i<n;i++)\n                isPrime[i] = true;\n            \n            isPrime[0] = false;\n            isPrime[1] = false;\n            \n            for(int i=2;i*i<n;i++)\n            {\n                if(isPrime[i] == true)\n                {\n                    for(int j=(2*i);j<n;j+=i)\n                        isPrime[j] = false;\n                }\n            }\n        }\n        \n        public static int GCD(int a,int b)\n        {\n            if(b==0)\n                return a;\n            else\n                return GCD(b,a%b);\n        }\n        \n        static class pair implements Comparable<pair>\n        {\n            Integer x;\n            Long y;\n            pair(int x,long y)\n            {\n                this.x=x;\n                this.y=y;\n                \n            }\n            \n           \n            public int compareTo(pair o) {\n                int result = x.compareTo(o.x);\n                if(result==0)\n                    result = y.compareTo(o.y);\n                \n                return result;\n            }  \n            \n            public String toString()\n            {\n                return x+\" \"+y;\n            }\n            \n            public boolean equals(Object o)\n            {\n                if (o instanceof pair)\n                {\n                    pair p = (pair)o;\n                    return p.x == x && p.y == y ;\n                }\n                return false;\n            }\n            \n            public int hashCode()\n            {\n                return new Long(x).hashCode()*31 + new Long(y).hashCode();\n            }\n        }\n        \n    \n}\nclass pair implements Comparable<pair>\n{\n    Integer x;\n    Long y;\n    pair(int x,long y)\n    {\n        this.x=x;\n        this.y=y;\n        \n    }\n    \n   \n    public int compareTo(pair o) {\n        int result = x.compareTo(o.x);\n        if(result==0)\n            result = y.compareTo(o.y);\n        \n        return result;\n    }  \n    \n    public String toString()\n    {\n        return x+\" \"+y;\n    }\n    \n    public boolean equals(Object o)\n    {\n        if (o instanceof pair)\n        {\n            pair p = (pair)o;\n            return p.x == x && p.y == y ;\n        }\n        return false;\n    }\n    \n    public int hashCode()\n    {\n        return new Long(x).hashCode()*31 + new Long(y).hashCode();\n    }\n}\nclass dsu{\n\tint parent[];\n\tdsu(int n){\n\t\tparent=new int[n+1];\n\t\tfor(int i=0;i<=n;i++)\n\t\t{\n\t\t\tparent[i]=i;\n\t\t}\n\t}\n\tint root(int n) {\n\t\twhile(parent[n]!=n)\n\t\t{ \n\t\t\tparent[n]=parent[parent[n]];\n\t\t\tn=parent[n];\n\t\t}\n\t\treturn n;\n\t}\n\tvoid union(int _a,int _b) {\n\t\tint p_a=root(_a);\n\t\tint p_b=root(_b);\n\t\t\n\t\t\tparent[p_a]=p_b;\n\t\t\n\t\t\t\n\t}\n\tboolean find(int a,int b) {\n\t\tif(root(a)==root(b))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn  false;\n\t}\n\t\n\t\n}\nclass Segment{ \n\tint seg[]; \n\tint a[];\n\tint lazy[];\n    Segment (int n,int b[]){\n\t\tseg=new int[4*n];\n\t\tlazy=new int[4*n];\n\t\ta=new int[b.length];\n\t\ta=b.clone();\n\t}\n    public void build(int node,int start,int end) {\n    \tif(start==end) {\n    \t\tseg[node]=a[start];\n    \t\treturn ;\n    \t}\n    \tint mid=(start+end)/2;\n    \tbuild(2*node+1,start,mid);\n    \tbuild(2*node+2,mid+1,end);\n    \tseg[node]=seg[2*node+1]+seg[2*node+2];\n    }\n    public void update(int node,int start,int end,int id,int val) {\n    \tif(start==end) {\n    \t\tseg[node]=a[start]=val;\n    \t\treturn;\n    \t}\n    \tint mid=(start+end)/2;\n    \tif(id>=start && id<=mid) {\n    \t\tupdate(2*node+1,start,mid,id,val);\n    \t}\n    \telse\n    \t\tupdate(2*node+2,mid+1,end,id,val);\n    \tseg[node]=seg[2*node+1]+seg[2*node+2];\n    }\n    public int query(int node,int start,int end,int l,int r) {\n    \tif(l>end || r<start)\n    \t\treturn 0;\n    \tif(start>=l && end<=r)\n    \t\treturn seg[node];\n    \t\n    \tint  mid=(start+end)/2;\n    \treturn (query(2*node+1,start,mid,l,r)+query(2*node+2,mid+1,end,l,r));\n    }\n    public void updateRange(int node,int start,int end,int l,int r,int val) {\n    \tif(lazy[node]!=0) {\n    \t\tif(start!=end) {\n    \t\t\tlazy[2*node+1]+=lazy[node];\n    \t\t\tlazy[2*node+2]+=lazy[node];\n    \t\t}\n    \t\tlazy[node]=0;\n    \t}\n    \tif(l>end || r<start)\n    \t\treturn ;\n    \tif(start>=l && end<=r) {\n    \t\tseg[node]=(end-start+1)*val;\n    \t\tif(start!=end) {\n    \t\t\tlazy[2*node+1]+=val;\n    \t\t\tlazy[2*node+2]+=val;\n    \t\t}\n    \t\tlazy[node]=0;\n    \t\treturn ;\n    \t}\n    \tint mid=(start+end)/2;\n    \tupdateRange(2*node+1,start,mid,l,r,val);\n    \tupdateRange(2*node+2,mid+1,end,l,r,val);\n    \tseg[node]=seg[2*node+1]+seg[2*node+2];\n    }\n    public int queryRange(int node,int start,int end,int l,int r) {\n    \tif(l>end || r<start)\n    \t\treturn 0;\n    \tif(lazy[node]!=0) {\n    \t\tseg[node]=(end-start+1)*lazy[node];\n    \t\tif(start!=end) {\n    \t\t\tlazy[2*node+1]+=lazy[node];\n    \t\t\tlazy[2*node+2]+=lazy[node];\n    \t\t}\n    \t\tlazy[node]=0;\n    \t}\n    \tif(start>=l && end<=r)\n    \t\treturn seg[node];\n    \t\n    \tint  mid=(start+end)/2;\n    \treturn (query(2*node+1,start,mid,l,r)+query(2*node+2,mid+1,end,l,r));\n    }\n    \n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\n\npublic class TaskC {\n\tstatic long mod = (long) (1000000000+7);\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tFastReader sc = new FastReader();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint test = 1;\n\t\twhile(test-->0) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint I = sc.nextInt();\n\t\t\t\n\t\t\tint K = (int) Math.pow(2, Math.min(8*I/n, 20));\n\t\t\t\n\t\t\tint[] a = new int[n];\n\t\t\tHashSet<Integer> set = new HashSet<>();\n\t\t\t\n\t\t\tfor(int i = 0;i<n;i++) {\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\t\tset.add(a[i]);\n\t\t\t}\n\t\t\tif(set.size()<=K) {\n\t\t\t\tout.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint[] arr = new int[set.size()+1];\n\t\t\tIterator<Integer> iter  = set.iterator();\n\t\t\tfor(int i = 1;i<=set.size();i++) {\n\t\t\t\tarr[i] = iter.next();\n\t\t\t}\n\t\t\titer  = set.iterator();\n\t\t\t\n\t\t\tshuffleArray(a);\n\t\t\tArrays.parallelSort(a);\n\t\t\tshuffleArray(arr);\n\t\t\tArrays.parallelSort(arr);\n\t\t\t\n\t\t\tint[] pref = new int[set.size()+2];\n\t\t\tint count = 1;\n\t\t\tint curr = 1;\n\t\t\t\n\t\t\tfor(int i = 1;i<n;i++) {\n\t\t\t\tif(a[i]==a[i-1]) {\n\t\t\t\t\tcount++;\n\t\t\t\t} else {\n\t\t\t\t\tpref[curr] = pref[curr-1]+count;\n\t\t\t\t\tcurr++;\n\t\t\t\t\tcount = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpref[curr] = pref[curr-1]+count;\n\t\t\tint l = 1;\n\t\t\tint r = K;\n\t\t\tint answer = -1;\n\t\t\twhile(r<=set.size()) {\n\t\t\t\tanswer = Math.max(pref[r]-pref[l-1], answer);\n\t\t\t\tl++;\n\t\t\t\tr++;\n\t\t\t}\n\t\t\tout.println(n-answer);\n\t\t}\n\t\t\n\t\tout.close();\n\t}\n\tstatic void shuffleArray(int[] arr){\n        int n = arr.length;\n        Random rnd = new Random();\n        for(int i=0; i<n; ++i){\n            int tmp = arr[i];\n            int randomPos = i + rnd.nextInt(n-i);\n            arr[i] = arr[randomPos];\n            arr[randomPos] = tmp;\n        }   \n\t}\n\tstatic int log2(int n){\n\t    if(n <= 0) throw new IllegalArgumentException();\n\t    return 31 - Integer.numberOfLeadingZeros(n);\n\t}\n\tstatic class FastReader {\n\t\t\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\t\t\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(\n\t\t\t\t\tnew InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tString next() {\n\t\t\twhile(st==null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\t\n\t\tdouble nextDouble() { \n\t\t\treturn Double.parseDouble(next()); \n\t\t} \n\t\t\n\t\tString nextLine() {\n\t\t\tString s = \"\";\n\t\t\twhile(st==null || st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\ts = br.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n \n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Main\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\t// your code goes here\n\t\tFastReader sc=new FastReader();\n\t\tlong n=sc.L();\n\t\tlong I=sc.L();\n\t\tI*=8;\n\t\tI/=n;\n\t\n\t\tHashMap<Long,Long> hm=new HashMap<>();\n\t\tTreeSet<Long> ts=new TreeSet<>();\n\t\tint k=0;\n\t\tfor(int i=0;i<(int)n;i++)\n\t\t{\n\t\t    long x=sc.L();\n\t\t    if(hm.containsKey(x))\n\t\t    {\n\t\t        hm.put(x,hm.get(x)+1);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t        k++;\n\t\t        hm.put(x,(long)1);\n\t\t        ts.add(x);\n\t\t    }\n\t\t}\n\t\tif(I>19)\n\t\t{\n\t\t    System.out.println(0);\n\t\t    return;\n\t\t}\n\t\t\tI=1L<<I;\n\t//\tSystem.out.println(k+\" \"+I);\n\t\tif((long)k<=I)\n\t\tSystem.out.println(0);\n\t\telse\n\t\t{\n\t\t    k-=I;\n\t\t   // System.out.println(k);\n\t\t    int c=0,i=0;\n\t\t    Iterator<Long> it=ts.iterator();\n\t\t    int l=ts.size();\n\t\t    long[] f=new long[l];\n\t\t    long[] g=new long[l];\n\t\t    while(it.hasNext())\n\t\t    {\n\t\t        f[i]=hm.get(it.next());\n\t\t        g[i]=f[i];\n\t\t        i++;\n\t\t    }\n\t\t    \n\t\t   for(i=1;i<k;i++)\n\t\t   {\n\t\t       f[i]+=f[i-1];\n\t\t       g[l-1-i]+=g[l-i];\n\t\t   }\n\t\t   long min=f[k-1];\n\t\t   if(g[l-k]<min)\n\t\t   min=g[l-k];\n\t\t   \n\t\t    for(int j=0;j<k-1;j++){\n\t\t   if(f[j]+g[l-k+1+j]<min)\n\t\t   min=f[j]+g[l-k+1+j];\n\t\t   if(min==k)\n\t\t   break;\n\t\t    }\n\t\t    System.out.println(min);\n\t\t}\n\t }\n\t static int binarysearch(int x,int[] b,int n)\n\t {\n\t     int l=0,r=n-1,m=(l+r)/2;\n\t     if(x<b[0]||x>b[r])\n\t     return -1;\n\t     while(l<=r)\n\t     {\n\t         m=(l+r)/2;\n\t         if(b[m]==x)\n\t         return m;\n\t         if(b[m]>x)\n\t         r=m-1;\n\t         else\n\t         l=m+1;\n\t     }\n\t     return -1;\n\t }\n\t static int lower(int x,int b[],int n)\n\t {\n\t     if(x<b[0])\n\t     return -1;\n\t     else if(x==b[0])\n\t     return 0;\n\t     if(x>=b[n-1])\n\t     return n-1;\n\t     int l=0,r=n-1,m=(l+r)/2;\n\t     while(l<=r)\n\t     {\n\t         m=(l+r)/2;\n\t         if(b[m]<=x&&b[m+1]>x)\n\t         return m;\n\t         else if(b[m]>x&&b[m-1]<=x)\n\t         return m-1;\n\t         if(b[m]>x)\n\t         r=m-1;\n\t         else if(b[m]<x)\n\t         l=m+1;\n\t     }\n\t     return -1;\n\t }\n\t static int upper(int x,int b[],int n)\n\t {\n\t     if(x<=b[0])\n\t     return 0;\n\t     else if(x==b[n-1])\n\t     return n-1;\n\t     if(x>b[n-1])\n\t     return -1;\n\t     int l=0,r=n-1,m=(l+r)/2;\n\t     while(l<=r)\n\t     {\n\t         m=(l+r)/2;\n\t         if(b[m]<x&&b[m+1]>=x)\n\t         return m+1;\n\t         else if(b[m]>=x&&b[m-1]<x)\n\t         return m;\n\t         if(b[m]>x)\n\t         r=m-1;\n\t         else if(b[m]<x)\n\t         l=m+1;\n\t     }\n\t     return -1;\n\t }\n\t \n\t static long power(long x, long y, long p) \n    { \n        // Initialize result \n        long res = 1;      \n         \n        // Update x if it is more   \n        // than or equal to p \n        x = x % p;  \n      \n        while (y > 0) \n        { \n            // If y is odd, multiply x \n            // with result \n            if((y & 1)==1) \n                res = (res * x) % p; \n      \n            // y must be even now \n            // y = y / 2 \n            y = y >> 1;  \n            x = (x * x) % p;  \n        } \n        return res; \n    } \n\t  static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int I() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long L() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double D() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n    static int gcd(int a,int b)\n\t\t{\n\t\t    if(a%b==0)\n\t\t    return b;\n\t\t    return gcd(b,a%b);\n\t\t}\n\tstatic float power(float x, int y) \n    { \n        float temp; \n        if( y == 0) \n            return 1; \n        temp = power(x, y/2);  \n          \n        if (y%2 == 0) \n            return temp*temp; \n        else\n        { \n            if(y > 0) \n                return x * temp * temp; \n            else\n                return (temp * temp) / x; \n        } \n    } \n    static long pow(long a,long b)\n    {\n        long result=1;\n        if(b==0)\n        return 1;\n        long x=a;\n        while(b>0)\n        {\n            if(b%2!=0)\n            result*=x;\n            \n            x=x*x;\n            b=b/2;\n        }\n        return result;\n    }\n    \n    static ArrayList<Integer> sieveOfEratosthenes(int n) \n    { \n        ArrayList<Integer> arr=new ArrayList<Integer>();\n        boolean prime[] = new boolean[n+1]; \n        for(int i=2;i<n;i++) \n            prime[i] = true; \n          \n        for(int p = 2; p*p <=n; p++) \n        { \n            if(prime[p] == true) \n            { \n                arr.add(p);\n                for(int i = p*p; i <= n; i += p) \n                    prime[i] = false; \n            } \n        } \n        return arr;\n    } \n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long n, i;\n  cin >> n >> i;\n  map<long long, long long> m;\n  map<long long, long long>::iterator itr;\n  long long r;\n  for (int i = 0; i < n; i++) {\n    cin >> r;\n    m[r]++;\n  }\n  long long k = (i * 8) / n;\n  long long K = pow(2, k);\n  if (k > 60) K = 1e18;\n  vector<pair<long long, long long> > v;\n  for (itr = m.begin(); itr != m.end(); itr++) {\n    long long x = itr->first;\n    long long y = itr->second;\n    v.push_back({x, y});\n  }\n  if (v.size() <= K) {\n    cout << 0;\n  } else {\n    long long temp = 0;\n    for (long long i = 0; i < K; i++) {\n      temp += v[i].second;\n    }\n    long long ans = n - temp;\n    for (long long i = K; i < v.size(); i++) {\n      temp = temp + v[i].second - v[i - K].second;\n      ans = min(ans, n - temp);\n    }\n    cout << ans;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct p {\n  int x;\n  int f;\n  p(int a, int b) {\n    x = a;\n    f = b;\n  }\n};\nbool compare(const p &a, const p &b) { return a.x < b.x; }\nint main() {\n  int n;\n  int I;\n  cin >> n >> I;\n  int a[n];\n  long long d = 0;\n  unordered_map<int, int> v;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    if (!v[a[i]]) {\n      d++;\n    }\n    v[a[i]]++;\n  }\n  I = 8 * I;\n  I = I / n;\n  int m;\n  if (I >= 24) {\n    m = 1000000;\n  } else\n    m = 1 << I;\n  if (m >= d)\n    cout << \"0\" << endl;\n  else {\n    vector<p> v2;\n    for (auto x : v) {\n      v2.push_back(p(x.first, x.second));\n    }\n    sort(v2.begin(), v2.end(), compare);\n    int gh = 0;\n    int gf = 0;\n    for (int i = 0; i < d; i++) {\n      gh = gh + v2[i].f;\n      if (i < m) gf = gf + v2[i].f;\n    }\n    int ans = gh - gf;\n    for (int i = m; i < d; i++) {\n      gf = gf - v2[i - m].f + v2[i].f;\n      ans = min(ans, gh - gf);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing namespace std::chrono;\nlong long power(long long a, long long b) {\n  if (b == 0) return 1;\n  long long x = power(a, b / 2);\n  x *= x;\n  x %= 1000000007;\n  if (b % 2 == 0) return x;\n  return (a * x) % 1000000007;\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long n, I;\n  cin >> n >> I;\n  long long x = I * 8;\n  x /= n;\n  x = power(2LL, x);\n  vector<long long> v(n);\n  map<long long, long long> f;\n  set<long long> s;\n  for (long long i = 0; i < n; i++) {\n    cin >> v[i];\n    f[v[i]]++;\n    s.insert(v[i]);\n  }\n  x = min(x, (long long)s.size());\n  vector<long long> v2;\n  for (long long val : s) {\n    v2.push_back(val);\n  }\n  long long sum = 0, cur = 0;\n  for (long long i = 0; i < x; i++) {\n    sum += f[v2[i]];\n  }\n  cur = sum;\n  for (long long i = x; i < v2.size(); i++) {\n    cur += f[v2[i]] - f[v2[i - x]];\n    sum = max(cur, sum);\n  }\n  cout << n - sum << \"\\n\";\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\n\nn,I = map(int,input().split())\nA = list(map(int,input().split()))\n\n#import math\n# I = 1 6*log_2_K <= 8 K = 2\n# I = 2 6*log_2_K <= 16 K = 2\n\nK = int(2**(I*8//n))\n\nfrom collections import Counter\nC = Counter(A)\n\nKEY = sorted(C.keys())\nLIST = []\n\nfor k in KEY:\n    LIST.append(C[k])\n\nS=[0]\nfor l in LIST:\n    S.append(l+S[-1])\n\nif K>=len(KEY):\n    print(0)\n    sys.exit()\n\nANS=S[-1]\nSUM=S[-1]\n\nfor i in range(K,len(S)):\n    ANS=min(ANS,SUM-(S[i]-S[i-K]))\n    #print(ANS)\n\nprint(ANS)\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9 + 9;\nsigned main(void) {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cout.precision(10);\n  cout << fixed;\n  long long n, I, temp, ans = 0;\n  cin >> n >> I;\n  map<long long, long long> mp;\n  I = I * 8;\n  for (long long i = 0; i < n; i++) {\n    cin >> temp;\n    mp[temp]++;\n  }\n  vector<long long> a;\n  long long k = pow(2LL, min(25LL, I / n));\n  long long u = mp.size();\n  if (k >= u) {\n    cout << 0 << '\\n';\n    return 0;\n  }\n  a.push_back(0);\n  for (auto z : mp) a.push_back(z.second);\n  vector<long long> pref(u + 1);\n  pref[0] = 0;\n  for (long long i = 1; i <= u; i++) {\n    pref[i] = pref[i - 1] + a[i];\n  }\n  long long sum = 0, index;\n  for (long long i = 0; i <= u - k; i++) {\n    if (sum < pref[i + k] - pref[i]) {\n      index = i + 1;\n      sum = pref[i + k] - pref[i];\n    }\n  }\n  for (long long i = 1; i < index; i++) ans += a[i];\n  for (long long i = index + k; i <= u; i++) ans += a[i];\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 5e5 + 7;\nlong long a[maxn];\nlong long quick(long long x, long long y) {\n  long long ans = 1;\n  while (y) {\n    if (y & 1) {\n      ans *= x;\n    }\n    x *= x;\n    y >>= 1;\n  }\n  return ans;\n}\nmap<long long, int> mp;\nmap<int, long long> mm;\nset<long long> se;\nvector<long long> vec;\nint main() {\n  int n;\n  long long I;\n  scanf(\"%d%lld\", &n, &I);\n  long long k = 8 * I / n;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%lld\", &a[i]);\n    mp[a[i]]++;\n    se.insert(a[i]);\n  }\n  if (k >= 19) {\n    cout << 0 << endl;\n    return 0;\n  }\n  long long K = quick(2ll, k);\n  for (auto u : se) vec.push_back(u);\n  sort(vec.begin(), vec.end());\n  for (int i = 0; i < vec.size(); i++) mm[vec[i]] = i;\n  int l1 = 0, l2 = 0, r = 0, ans = 0;\n  int tmp = 0;\n  for (int i = 0; i < vec.size(); i++) {\n    tmp += mp[vec[i]];\n    if (i - l1 + 1 == K) {\n      ans = max(ans, tmp);\n      tmp -= mp[vec[l1]];\n      l1++;\n    }\n  }\n  ans = max(ans, tmp);\n  cout << max(n - ans, 0) << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long Log(long long x) {\n  if (x < 1) return 0;\n  int r = 0;\n  while (x > 0) {\n    x /= 2;\n    r++;\n  }\n  return r - 1;\n}\nint solve(map<long long, int> M, long long n, long long byte) {\n  int bit = byte * 8;\n  vector<pair<int, int> > vec;\n  for (auto it = M.begin(); it != M.end(); it++) {\n    vec.push_back(make_pair(it->first, it->second));\n  }\n  queue<pair<int, int> > Q;\n  int ans = 1 << 30, cnt = 0;\n  long long sum = 0;\n  for (auto it = M.begin(); it != M.end(); it++) {\n    Q.push(make_pair(it->first, it->second));\n    cnt++;\n    sum += it->second;\n    while ((int)(ceil(log2(cnt))) * n > bit) {\n      pair<int, int> r = Q.front();\n      Q.pop();\n      sum -= r.second;\n      cnt--;\n    }\n    ans = min((long long)ans, n - sum);\n  }\n  return ans;\n}\nint main() {\n  long long n, byte;\n  cin >> n >> byte;\n  long long bit = byte * 8LL;\n  long long ara[n + 5];\n  map<long long, int> M;\n  map<long long, int>::iterator it;\n  vector<int> vs;\n  for (int i = 0; i < n; i++) {\n    cin >> ara[i];\n    vs.push_back(ara[i]);\n    M[ara[i]]++;\n  }\n  vector<int> vec;\n  for (it = M.begin(); it != M.end(); it++) vec.push_back(it->second);\n  int len = vec.size();\n  int ans = 0;\n  int element = len;\n  int lf = 0, ri = len - 1;\n  for (int i = 0; i < len; i++) {\n    element = (ri - lf + 1);\n    int r = ceil((double)log2(element));\n    if ((r * n) <= bit) {\n      break;\n    }\n    if (vec[lf] < vec[ri]) {\n      ans += vec[lf];\n      lf++;\n    } else {\n      ans += vec[ri];\n      ri--;\n    }\n  }\n  int rrr = solve(M, n, byte);\n  cout << rrr << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int64_t N, I;\n  cin >> N >> I;\n  map<int, int> m;\n  for (int i = 0; i < N; i++) {\n    int x;\n    cin >> x;\n    m[x]++;\n  }\n  I *= 8;\n  I /= N;\n  int64_t allowed = 1;\n  for (int i = 1; i <= I; i++) {\n    allowed *= 2;\n    if (allowed >= N) break;\n  }\n  auto s = m.begin();\n  auto t = m.begin();\n  int uniq = 0;\n  int score = 0;\n  int max_score = 0;\n  while (true) {\n    if (uniq < allowed) {\n      score += t->second;\n      t++;\n      uniq++;\n    } else {\n      score -= s->second;\n      s++;\n      uniq--;\n    }\n    max_score = max(max_score, score);\n    if (t == m.end()) break;\n  }\n  cout << N - max_score << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n, l = map(int, input().split())\na = [*map(int, input().split())]\na.sort()\n\np = (8 * l) // n\n\nif p >= 20:\n\tprint(0)\n\texit()\n\nx = 1 << p\nv = []\n\nprev = -1\n\nfor i in a:\n\tif i != prev:\n\t\tv.append(1)\n\telse:\n\t\tv[-1] += 1\n\tprev = i\n\nfrom itertools import accumulate\ns = [0] + [*accumulate(v[::-1])]\n\nans = 1e9\ntemp = 0\n\nfor i in range(len(v)):\n\tans = min(ans, temp + s[max(len(v) - i - x, 0)])\n\ttemp += v[i]\n\nprint(ans)"
        },
        {
            "language": 3,
            "solution": "import math\nn,I=[int(x) for x in input().split()]\nlis=[int(x) for x in input().split()]\n\n\n\ndic=dict()\n\nfor i in lis:\n    if i in dic:\n        dic[i]+=1\n    else:\n        dic[i]=1\n\n\ndisLis=sorted(dic)\nnowK=len(disLis)\n\nif math.log2(nowK)>(I*8)//n:\n\n    maxK=2**((I*8)//n)\n    needMin=nowK-maxK\n    \n    minChange=0\n    \n    for i in range(needMin):\n        minChange+=dic[disLis[i]]\n    \n    befChange=minChange\n    \n    for i in range(1,needMin+1):\n        befChange=befChange-dic[disLis[needMin-i]]+dic[disLis[-i]]\n        if befChange<minChange:\n            minChange=befChange\n\n    print(minChange)\nelse:\n    print(0)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class C\n{\n    PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n    public void go() throws IOException\n    {\n        StringTokenizer tok = new StringTokenizer(in.readLine());\n        int n = Integer.parseInt(tok.nextToken());\n        long maxSize = Long.parseLong(tok.nextToken()) * 8;\n        maxSize /= n;\n        if (maxSize > 30)\n        {\n            System.out.println(0);\n            return;\n        }\n        maxSize = 1L << maxSize;\n        tok = new StringTokenizer(in.readLine());\n        TreeMap<Integer, Integer> freq = new TreeMap<>();\n        for (int i = 0; i < n; i++)\n        {\n            int x = Integer.parseInt(tok.nextToken());\n            freq.putIfAbsent(x, 0);\n            freq.put(x, freq.get(x)+1);\n        }\n        int[] arr = new int[freq.size()];\n        int i = 0;\n        for (int k : freq.keySet())\n        {\n            arr[i] = freq.get(k);\n            i++;\n        }\n        // out.println(maxSize);\n        // out.println(Arrays.toString(arr));\n        int left = 0;\n        int sum = 0;\n        int best = 0;\n        for (i = 0; i < arr.length; i++)\n        {\n            sum += arr[i];\n            if (i - left + 1 > maxSize)\n            {\n                sum -= arr[left];\n                left++;\n            }\n            best = Math.max(sum, best);\n        }\n        out.println(n - best);\n\n        out.flush();\n        in.close();\n    }\n\n    public static void main(String[] args) throws IOException\n    {\n        new C().go();\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.Vector;\n\npublic class mai {\n\n\tpublic static int lowerBound(long[] array, int length, long value) {\n\t\tint low = 0;\n\t\tint high = length;\n\t\twhile (low < high) {\n\t\t\tfinal int mid = (low + high) / 2;\n\t\t\tif (value <= array[mid]) {\n\t\t\t\thigh = mid;\n\t\t\t} else {\n\t\t\t\tlow = mid + 1;\n\t\t\t}\n\t\t}\n\t\treturn low;\n\t}\n\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\n\tstatic long gcd(long a, long b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\t\treturn gcd(b % a, a);\n\t}\n\n\tstatic long lcm(long a, long b) {\n\t\treturn (a * b) / gcd(a, b);\n\t}\n\n\tpublic static void sortbyColumn(int arr[][], int col) {\n\t\t// Using built-in sort function Arrays.sort\n\t\tArrays.sort(arr, new Comparator<int[]>() {\n\n\t\t\t@Override\n\t\t\t// Compare values according to columns\n\t\t\tpublic int compare(final int[] entry1, final int[] entry2) {\n\n\t\t\t\t// To sort in descending order revert\n\t\t\t\t// the '>' Operator\n\t\t\t\t// if (entry1[col] > entry2[col])\n\t\t\t\t// return 1;\n\t\t\t\t// else //(entry1[col] >= entry2[col])\n\t\t\t\t// return -1;\n\t\t\t\treturn new Integer(entry1[col]).compareTo(entry2[col]);\n\t\t\t\t// return entry1[col].\n\t\t\t}\n\t\t}); // End of function call sort().\n\t}\n\n\tclass pair<X, Y> { // utilizing Java \"Generics\"\n\t\tX _first;\n\t\tY _second;\n\n\t\tpublic pair(X f, Y s) {\n\t\t\t_first = f;\n\t\t\t_second = s;\n\t\t}\n\n\t\tX first() {\n\t\t\treturn _first;\n\t\t}\n\n\t\tY second() {\n\t\t\treturn _second;\n\t\t}\n\n\t\tvoid setFirst(X f) {\n\t\t\t_first = f;\n\t\t}\n\n\t\tvoid setSecond(Y s) {\n\t\t\t_second = s;\n\t\t}\n\t}\n\n\tstatic long nCr(long n, long r) {\n\t\tlong x = 1;\n\t\tlong yu = n - r;\n\t\twhile (n > r) {\n\t\t\tx = x * n;\n\t\t\tn--;\n\t\t}\n\n\t\twhile (yu > 0) {\n\t\t\tx /= yu;\n\t\t\tyu--;\n\t\t}\n\t\treturn x;\n\t}\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tFastReader sc = new FastReader();\n\t\t// BufferedReader br = new BufferedReader(new\n\t\t// InputStreamReader(System.in));\n\t\t// Scanner scn = new Scanner(System.in);\n\t\t// PrintWriter pr = new PrintWriter(new BufferedWriter(new\n\t\t// OutputStreamWriter(System.out)));\n\t\tint n = sc.nextInt();\n\t\tint max = sc.nextInt();\n\t\tint arr[] = new int[n];\n\t\tHashMap<Integer, Integer> h = new HashMap<>();\n\t\tHashSet<Integer> uni = new HashSet<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarr[i] = sc.nextInt();\n\t\t\tif (h.containsKey(arr[i]))\n\t\t\t\th.put(arr[i], h.get(arr[i]) + 1);\n\t\t\telse\n\t\t\t\th.put(arr[i], 1);\n\t\t\tuni.add(arr[i]);\n\t\t}\n\t\tlong pos = (max*8)/n;\n\t\tpos=(long) Math.pow(2, pos);\n\t\tif (h.size() <= pos) {\n\t\t\tSystem.out.println(\"0\");\n\t\t\treturn;\n\t\t}\n\t\tlong red = h.size() - pos;\n\t\tObject[] unique = uni.toArray();\n\t\tArrays.sort(unique);\n\t\tint c = 0;\n\t\t// int i = 0, j = (unique.length - 1);\n\t\t// System.out.println(j+\" \"+uni);\n\t\tlong sum = 0;\n\t\tlong min = Integer.MAX_VALUE;\n\t\tfor (int i = 0; i < red; i++) {\n\t\t\tsum += h.get(unique[i]);\n\t\t}\n\t\tmin = sum;\n\t\t//System.out.println(sum);\n\t\tint j = unique.length - 1;\n\t\tfor (int i = (int) (red - 1); i >= 0; i--) {\n\t\t\tsum = sum - (h.get(unique[i]));\n\t\t\tsum += h.get(unique[j]);\n\t\t\tif (sum < min)\n\t\t\t\tmin = sum;\n\t\t\tj--;\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "n, I = [int(x) for x in input().split()]\nd = pow(2, (8 * I // n))\na = [int(x) for x in input().split()]\na.sort()\nval = [0]\nm = 0\nfor i in range(1, n):\n    if a[i - 1] != a[i]:\n        val.append(i)\n        \ndiff = len(val) - d\nif len(val) <= d:\n    print(\"0\")\nelse:\n    for i in range(diff):\n        m = max(val[i + d] - val[i], m)\n    print(n - m)\n"
        },
        {
            "language": 1,
            "solution": "def maxSum(arr, n, k): \n    # print arr,n,k\n    res = 0\n    for i in range(k): \n        res += arr[i] \n    curr_sum = res \n    for i in range(k, n): \n        curr_sum += arr[i] - arr[i-k] \n        res = max(res, curr_sum) \n    return res \n \nfrom sys import stdin,stdout\nI = lambda : map(int,stdin.readline().split())\n \nn,i = I()\na = I()\n \nfrom collections import Counter\nx = (8*i)/n\ncnt = dict(Counter(a))\nkeys = list(cnt.keys())\nans = []\nfor i in sorted(keys):\n    ans.append(cnt[i])\n \n# print sum(ans[2**x:])\n# print ans\nimport math\nif math.log(n,2) > x:\n    print sum(ans) - maxSum(ans,len(ans),min(len(ans),2**x))\nelse:\n    print 0"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic StreamTokenizer st = new StreamTokenizer(new BufferedInputStream(System.in));\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tstatic PrintWriter pr = new PrintWriter(new BufferedOutputStream(System.out));\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n//\t\tlong tic = System.currentTimeMillis();\n\n\t\tint n = nextInt();\n\t\tint I = nextInt() * 8 / n;\n\t\tif (I > 24) {\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t} else {\n\t\t\tI = 1 << (I);\n\t\t}\n\n\t\tint arr[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarr[i] = nextInt();\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t=(int)(n*Math.random());\n\t\t\tint temp=arr[t];\n\t\t\tarr[t]=arr[i];\n\t\t\tarr[i]=temp;\n\t\t}\n\t\t\n\t\tArrays.sort(arr);\n\t\tint data[] = new int[n + 1];\n\t\tdata[1] = 1;\n\t\tint id = 1;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (arr[i] == arr[i - 1]) {\n\t\t\t\tdata[id]++;\n\t\t\t} else {\n\t\t\t\tdata[++id] = 1;\n\t\t\t}\n\t\t}\n\t\tif (I >= id) {\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\t\tint te = 0;\n\t\tfor (int i = 1; i <= Math.min(n, I); i++) {\n\t\t\tte += data[i];\n\t\t}\n\t\tint ans = te;\n\t\tfor (int i = Math.min(n, I)+1; i <= n; i++) {\n\t\t\tte += data[i];\n\t\t\tte -= data[i - I];\n\t\t\tans = Math.max(ans, te);\n\t\t}\n\t\tSystem.out.println(n - ans);\n\n//\t\tlong toc = System.currentTimeMillis();\n//\t\tSystem.out.println(\"Elapsed time: \" + (toc - tic) + \" ms\");\n\t}\n\n\tstatic int log2(long x) {\n\t\tint flag = 1;\n\t\tint log = 0;\n\t\twhile (x > flag) {\n\t\t\tflag <<= 1;\n\t\t\tlog++;\n\t\t}\n\t\treturn log;\n\t}\n\n\tstatic long phi(int x) {\n\t\tlong res = x;\n\t\tfor (long i = 2; i <= Math.sqrt(x); i++) {\n\t\t\tif (x % i == 0) {\n\t\t\t\twhile (x % i == 0)\n\t\t\t\t\tx /= i;\n\t\t\t\tres = res / i * (i - 1);\n\t\t\t}\n\t\t}\n\t\tif (x > 1)\n\t\t\tres = res / x * (x - 1);\n\t\treturn res;\n\t}\n\n\tstatic long pow(long a, long b, long mod) {\n\t\tif (b == 0)\n\t\t\treturn 1;\n\t\tif (b == 1)\n\t\t\treturn a;\n\t\tif ((b & 1) == 0)\n\t\t\treturn pow(a * a % mod, b >> 1, mod);\n\t\telse\n\t\t\treturn a * pow(a * a % mod, b >> 1, mod) % mod;\n\t}\n\n\tstatic long gcd(long a, long b) {\n\t\tif (b == 0) {\n\t\t\treturn a;\n\t\t} else {\n\t\t\treturn gcd(b, a % b);\n\t\t}\n\t}\n\n\tstatic int nextInt() {\n\t\ttry {\n\t\t\tst.nextToken();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn (int) st.nval;\n\t}\n\n\tstatic double nextDouble() {\n\t\ttry {\n\t\t\tst.nextToken();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn st.nval;\n\t}\n\n\tstatic String next() {\n\t\ttry {\n\t\t\tst.nextToken();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn st.sval;\n\t}\n\n\tstatic long nextLong() {\n\t\ttry {\n\t\t\tst.nextToken();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn (long) st.nval;\n\t}\n}\n\nclass Node {\n\tint a;\n\tint b;\n\n\tpublic Node() {\n\t}\n\n\tpublic Node(int a, int b) {\n\t\tsuper();\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Node [a=\" + a + \", b=\" + b + \"]\";\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Vaibhav Pulastya\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CMP3 solver = new CMP3();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CMP3 {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int I = (in.nextInt() * 8) / n;\n            Integer[] a = in.nextIntOArray(n);\n            int dist;\n            if (I >= 22) {\n                I = n;\n                out.println(0);\n                return;\n            } else {\n                dist = 1 << I;\n                if (dist >= n) {\n                    out.println(0);\n                    return;\n                } else {\n                    Arrays.sort(a);\n                    ArrayList<Node> dEl = new ArrayList<>();\n                    for (int i = 0; i < n; i++) {\n                        int c = 1;\n                        int val = a[i];\n                        while (i + 1 < n && val == a[i + 1]) {\n                            i++;\n                            c++;\n                        }\n                        dEl.add(new Node(val, c));\n                    }\n                    if (dist >= dEl.size()) {\n                        out.println(0);\n                        return;\n                    }\n                    int ext = dist;\n                    int ans = 0;\n                    int l = 0;\n                    int r = ext;\n                    int sum = 0;\n                    for (int i = 0; i < ext; i++) {\n                        sum += dEl.get(i).c;\n                    }\n                    ans = sum;\n                    while (r < dEl.size()) {\n                        sum += dEl.get(r++).c;\n                        sum -= dEl.get(l++).c;\n                        ans = Math.max(ans, sum);\n                    }\n                    out.println(n - ans);\n                }\n            }\n        }\n\n        class Node {\n            int v;\n            int c;\n\n            Node(int v, int c) {\n                this.v = v;\n                this.c = c;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public Integer[] nextIntOArray(int size) {\n            Integer[] array = new Integer[size];\n            for (int i = 0; i < size; i++)\n                array[i] = nextInt();\n            return array;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Solution{\n    public static void main(String[] args)throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        long m = Long.parseLong(st.nextToken());\n        int[] a = new int[n];\n        st = new StringTokenizer(br.readLine());\n        for(int i=0;i<n;i++){\n            a[i] = Integer.parseInt(st.nextToken());\n        }\n        m *= (long)8;\n        double k = (double)m/(double)n;\n        if(k>=27.0) System.out.println(\"0\");\n        else{\n            long K = (long)Math.pow(2,(long)k);\n            TreeMap<Integer,Integer> tm = new TreeMap<Integer,Integer>();\n            for(int i=0;i<n;i++){\n                int d = 1;\n                if(tm.containsKey(a[i])) d += tm.get(a[i]);\n                tm.put(a[i],d);\n            }\n            int l = tm.size();\n            int[] b = new int[l];\n            l=0;\n            for(int x:tm.values()){\n                b[l] = x;\n                l++;\n            }\n            int sum = 0;\n            if((int)K>=l) System.out.println(\"0\");\n            else{\n                int res = 0;\n                for(int i=(int)K;i<l;i++) sum += b[i];\n                res = sum;\n                for(int i=0;i<l-(int)K;i++){\n                    sum += b[i];\n                    sum -= b[(int)K+i];\n                    res = Math.min(res,sum);\n                }\n                System.out.println(res);\n            }\n        }\n    }\n}\n\n"
        },
        {
            "language": 3,
            "solution": "from math import log \nn,s = map(int,input().split())\nlis = sorted(map(int,input().split()))\nlim = 2**((s*8)//n)\nif lim>=len(set(lis)):\n    print(0)\nelse:\n    pre=[0]*(n+1)\n    pre[0]=1\n    ans=100000000000\n    for i in range(1,n):\n        if lis[i]!=lis[i-1]:\n            pre[i]=pre[i-1]+1\n        else:\n            pre[i]=pre[i-1]\n    for i in range(n):\n        l = i\n        r = n-1\n        if pre[i]==pre[i-1]:\n            continue\n        while l<=r:\n            mid = l +(r-l)//2\n            if pre[mid]-pre[i-1]<=lim:\n                l = mid+1\n            else:\n                r = mid-1\n        ans = min(ans ,n-(l-i))\n    print(ans)                        \n                      "
        },
        {
            "language": 4,
            "solution": "/*\nIf you want to aim high, aim high\nDon't let that studying and grades consume you\nJust live life young\n******************************\nWhat do you think? What do you think?\n1st on Billboard, what do you think of it\nNext is a Grammy, what do you think of it\nHowever you think, I\u2019m sorry, but shit, I have no fucking interest\n*******************************\nHigher, higher, even higher, to the point you won\u2019t even be able to see me\nhttps://www.a2oj.com/Ladder16.html\n*******************************\nNEVER DO 300IQ CONTESTS EVER\n300IQ AS WRITER = EXTRA NONO\n*/\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\n\n   public class x1198A\n   {\n      public static void main(String omkar[]) throws Exception\n      {\n         BufferedReader infile = new BufferedReader(new InputStreamReader(System.in));  \n         StringTokenizer st = new StringTokenizer(infile.readLine());\n         int N = Integer.parseInt(st.nextToken());\n         int I = Integer.parseInt(st.nextToken());\n         int[] arr = new int[N];\n         st = new StringTokenizer(infile.readLine());\n         for(int i=0; i < N; i++)\n            arr[i] = Integer.parseInt(st.nextToken());\n         int k = 1;\n         for(; k <= N; k++)\n            if((long)N*Math.ceil(Math.log(k)/Math.log(2)) > 8*I)\n               break;\n         k--;\n         //compress\n         sort(arr);\n         HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n         int boof = 0;\n         for(int x: arr)\n            if(!map.containsKey(x))\n               map.put(x, boof++);\n         int[] freq = new int[boof];\n         for(int x: arr)\n            freq[map.get(x)]++;\n         int res = N;\n         if(boof <= k)\n            System.out.println(0);\n         else\n         {\n            int sum = 0;\n            for(int i=0; i < k; i++)\n               sum += freq[i];\n            res = Math.min(res, N-sum);\n            for(int i=k; i < boof; i++)\n            {\n               sum += freq[i]-freq[i-k];\n               res = Math.min(res, N-sum);\n            }\n            System.out.println(res);\n         }\n      }\n      public static void sort(int[] arr)\n      {\n         //stable heap sort\n         PriorityQueue<Integer> pq = new PriorityQueue<Integer>();\n         for(int a: arr)\n            pq.add(a);\n         for(int i=0; i < arr.length; i++)\n            arr[i] = pq.poll();\n      }\n   }"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint log(int n) {\n  if (n <= 2) return 1;\n  return 1 + log((n + 1) / 2);\n}\nint power(int a, int b) {\n  if (b == 0) return 1;\n  return a * power(a, b - 1);\n}\nvoid preprocess(vector<int> numbers, vector<int>& unique_numbers,\n                vector<int>& counts) {\n  int prev_value = -1;\n  int count = 0;\n  for (auto it = numbers.begin(); it != numbers.end(); ++it) {\n    if (*it != prev_value) {\n      if (prev_value >= 0) {\n        unique_numbers.push_back(prev_value);\n        counts.push_back(count);\n      }\n      prev_value = *it;\n      count = 0;\n    }\n    count++;\n  }\n  if (prev_value >= 0) {\n    unique_numbers.push_back(prev_value);\n    counts.push_back(count);\n  }\n}\nint main(void) {\n  int n, I;\n  cin >> n >> I;\n  int bits = (8 * I) / n;\n  if (bits > 20) {\n    cout << 0;\n    return 0;\n  }\n  int max_num = power(2, bits);\n  vector<int> numbers(n);\n  for (int i = 0; i < n; i++) cin >> numbers[i];\n  sort(numbers.begin(), numbers.end());\n  vector<int> unique_numbers, counts;\n  preprocess(numbers, unique_numbers, counts);\n  if (unique_numbers.size() <= max_num) {\n    cout << 0;\n    return 0;\n  }\n  int begin = 0, end = max_num;\n  int count = 0;\n  for (int i = begin; i < end; i++) count += counts[i];\n  int best_count = count;\n  while (end < counts.size()) {\n    count = count + counts[end] - counts[begin];\n    end++;\n    begin++;\n    if (count > best_count) best_count = count;\n  }\n  cout << n - best_count;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n,I=map(int,input().split())\n#print(n,I)\na=list(map(int,input().split()))\nI*=8\nk=I//n\nif k>=20:\n    res=0\nelse:\n    K=2**k\n    #print(K,I)\n    cc={}\n    for ai in a:\n        cc[ai]=cc.get(ai,0)+1\n    pres=[]\n    dd=sorted(cc)\n    for i in dd:\n        pres.append(cc[i])\n    for i in range(1,len(pres)):\n        pres[i]+=pres[i-1]\n    if K>=len(pres):\n        res=0\n    else:\n        mm=0\n        for i in range(K,len(pres)):\n            if mm<pres[i]-pres[i-K]:\n                mm=pres[i]-pres[i-K]\n        res=n-mm\nprint(res)"
        },
        {
            "language": 3,
            "solution": "n, I = map(int, input().split())\nI *= 8\narray = list(map(int, input().split()))\n\n\ndef log(x):\n    l = 0\n    while 2**l < x:\n        l += 1\n    return l\n\narray.sort()\nizn = []\nd = {}\nfor el in array:\n    if el in d:\n        d[el] += 1\n    else:\n        d[el] = 1\n        izn.append(el)\n\nf = len(izn)\nj = 0\npos = 0\ncount = 0\nun = 0\nfor i in range(f):\n    while j < f and log(un + 1)*n <= I:\n        count += d[izn[j]]\n        if pos < count:\n            pos = count\n        j += 1\n        un += 1\n    un -= 1\n    count -= d[izn[i]]\nprint(n-pos)"
        },
        {
            "language": 3,
            "solution": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Wed Jul 31 13:37:46 2019\n\n@author: Aman Seth\n\"\"\"\n\nn, p = map(int, input().split())\nx = list(map(int, input().split()))\nx.sort()\nt = 2**((8*p)//n)\nlast = None\ny = []\nfor c in x:\n    if last is None or last != c:\n        last = c\n        y.append(1)\n    else:\n        y[-1] += 1\nbest = 0\n\nnow = 0\nle=len(y)\nfor i in range(le):\n    now += y[i]\n    if i >= t:\n        now -= y[i-t]\n    best = max(best, now)\n    \nprint(n-best)\n\n\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.StringTokenizer;\npublic class MP3Arc {\n\n\tstatic ArrayList<Integer>[] adjList;\n\tstatic PrintWriter pw = new PrintWriter(System.out);\n static int[] arrSorted;\n\n\tpublic static void main(String[] args) throws IOException, InterruptedException {\n\t\tBufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st;\n\t\tst =new StringTokenizer(bf.readLine());\n\t\tint n= Integer.parseInt(st.nextToken());\n\t\tint I=Integer.parseInt(st.nextToken());\n\t\tI*=8;\n\t\tlong segLen=I/n;\n\t\tif(segLen>=31) {\n\t\t\tpw.println(0);\n\t\t}else {\n\t\tsegLen=pow(2,(int)segLen);\n\t\n\t\tHashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\t\tint[] arr = new int[n];\n\t\tst= new StringTokenizer(bf.readLine());\n\t\t arrSorted=new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\tarr[i]=Integer.parseInt(st.nextToken());\n\t\tarrSorted[i]=arr[i];\n\t\t}\n\t\tshuffle(arrSorted);\n\t\tArrays.sort(arrSorted);\n\t\t\n\t\tint c=0;\n\t\tmap.put(arrSorted[0], c++);\n\t\t\n\t\tfor(int i=1;i<arrSorted.length;i++) {\n\t\t\tif(!map.containsKey(arrSorted[i])){\n\t\t\t\tmap.put(arrSorted[i], c++);\n\t\t\t}\n\t\t}\n\t\t\n\tint[] fq= new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfq[map.get(arr[i])]++;\n\t\t}\n\t\tfor(int i=1;i<n;i++)\n\t\t\tfq[i]+=fq[i-1];\n\t\t\n\t\tint max=-1;\n\t\tif(segLen==1) {\n\t\t\tmax=fq[0];\n\t\t\tfor(int i=1;i<n;i++)\n\t\t\t\tmax=Math.max(max, fq[i]-fq[i-1]);\n\t\t}else {\n\t\tfor(int i=0;i<c;i++) {\n\t\t\tint currIdx=i;\n\t\t\tlong nextIdx=currIdx+segLen-1;\n\t\t\tif(nextIdx>=c) {\n\t\t\t\tnextIdx=c-1;\n\t\t\t}\n\t\t\t\tmax=Math.max(max,fq[(int)nextIdx]-((currIdx!=0)?fq[currIdx-1]:0));\n\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\n\t\t}\n\t\t\n\t\tpw.println(fq[fq.length-1]-max);\n\t\t}\n\t\tpw.flush();\n\t\tpw.close();\n\n}\n\n public static void shuffle(int[] a)\n\t{\n\t\tint n = a.length;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tint r = i + (int)(Math.random() * (n - i));\n\t\t\tint tmp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = tmp;\n\t\t}\n\t}\n\n\n public static long pow(long a, int n) {\n\t\tlong res=1;\n\t\twhile(n>0) {\n\t\t\tif((n&1)==1)\n\t\t\t\tres*=a;\n\t\t\ta*=a;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(100000)\n\ndef getN():\n    return int(input())\ndef getList():\n    return list(map(int, input().split()))\nimport math\nfrom bisect import bisect_right\n\nn, b = getList()\n\nnumms = getList()\nnumms.sort()\nspl = 0\ntmp = numms[0]\nnums = []\nfor nu in numms:\n    if nu == tmp:\n        nums.append(spl)\n    else:\n        spl += 1\n        nums.append(spl)\n        tmp = nu\n\n# print(nums)\n\n\nhaba = 2 ** ((8*b) // n)\nans = 0\n# print(haba)\nfor i, num in enumerate(nums):\n    ins = num + haba - 1\n    idx = bisect_right(nums, ins)\n    rep = idx - i\n    # print(i, num, idx, rep)\n    if rep > ans :\n        ans = rep\n\n# print(nums)\nprint(n - ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(1)\n#pragma GCC optimize(2)\n#pragma GCC optimize(3, \"Ofast\", \"inline\")\nusing namespace std;\ntemplate <typename T>\nT gcd(T a, T b) {\n  while (b ^= a ^= b ^= a %= b)\n    ;\n  return a;\n}\ninline char nc() {\n  static char buf[1000000], *p1 = buf, *p2 = buf;\n  return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2)\n             ? EOF\n             : *p1++;\n}\ntemplate <typename T>\ninline void read(T& sum) {\n  char ch = getchar();\n  T tf = 0;\n  sum = 0;\n  while ((ch < '0' || ch > '9') && (ch != '-')) ch = getchar();\n  tf = ((ch == '-') && (ch = getchar()));\n  while (ch >= '0' && ch <= '9') sum = sum * 10 + (ch - 48), ch = getchar();\n  (tf) && (sum = -sum);\n}\ntemplate <typename T>\ninline void write(T x) {\n  char F[200];\n  T tmp = x > 0 ? x : -x;\n  if (x < 0) putchar('-');\n  T cnt = 0;\n  while (tmp > 0) {\n    F[cnt++] = tmp % 10 + '0';\n    tmp /= 10;\n  }\n  while (cnt > 0) putchar(F[--cnt]);\n}\nvoid seino();\nint main() {\n  seino();\n  return 0;\n}\nlong long b[400005], a[400005];\nvoid seino() {\n  long long n, i, v = 1, m, xp;\n  double op, x, y, fl;\n  cin >> n >> m;\n  for (long long i = 0; i <= n - 1; i++) cin >> b[i];\n  sort(b, b + n);\n  for (long long i = 1; i <= n - 1; i++)\n    if (b[i] != b[i - 1]) v++;\n  y = ((double)m) * 8.0;\n  fl = ceil(log2(((double)v)));\n  x = fl * ((double)n);\n  if (y >= x) {\n    cout << \"0\\n\";\n  } else {\n    for (long long i = 1; i <= n; i++) {\n      fl = ceil(log2(((double)i)));\n      x = fl * ((double)n);\n      if (x <= y)\n        xp = i;\n      else\n        break;\n    }\n    long long mx = n + 1, mq = 0;\n    v = 0;\n    a[v] = 1;\n    for (long long i = 1; i <= n; i++) {\n      if (b[i] != b[i - 1]) {\n        v++;\n        a[v] = 1;\n        if (v >= xp) {\n          mx = min(mx, n - (i - mq));\n          mq += a[v - xp];\n        }\n      } else\n        a[v]++;\n    }\n    mx = min(mx, mq);\n    cout << mx << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.lang.reflect.Array;\nimport java.util.*;\n\npublic class Main {\n    static int inf = (int) 1e9 + 7;\n\n    static int log(int k) {\n        int ans = 0;\n        int c = 1;\n        while(c < k) {\n            c *= 2;\n            ans++;\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        pw = new PrintWriter(System.out);\n        int n = nextInt();\n        int I = nextInt() * 8;\n        int a[] = new int [n];\n        for(int i = 0;i < n;i++) a[i] = nextInt();\n        Arrays.sort(a);\n        int k = 1;\n        int r = 0;\n        int ans = inf;\n        for(int l = 0;l < n;l++) {\n            while(r != n - 1 && (a[r] == a[r + 1] || log(k) == log(k + 1) || log(k + 1) * n <= I)) {\n                r++;\n                if (a[r] != a[r - 1]) k++;\n            }\n            ans = Math.min(ans, n - (r - l + 1));\n            if (l != n - 1 && a[l] != a[l + 1]) k--;\n        }\n        pw.println(ans);\n        pw.close();\n    }\n\n    static BufferedReader br;\n\n    static StringTokenizer st = new StringTokenizer(\"\");\n    static PrintWriter pw;\n    /*static String next() throws IOException {\n        int c = br.read();\n        while (Character.isWhitespace(c)) c = br.read();\n        StringBuilder sb = new StringBuilder();\n        while (!Character.isWhitespace(c)) {\n            sb.appendCodePoint(c);\n            c = br.read();\n        }\n        return sb.toString();\n    }*/\n\n    static String next() throws IOException {\n        if (!st.hasMoreTokens()) st = new StringTokenizer(br.readLine());\n        return st.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    static Double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n}\n\nclass pair {\n    int x, y;\n\n    pair(int a, int b) {\n        x = a;\n        y = b;\n    }\n\n    pair() {\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 4e5 + 5;\nconst long long inf = 1e9 + 7;\nlong long n, m;\nint a[maxn];\nvector<int> t;\nint num[maxn];\ninline int getId(int x) {\n  return lower_bound(t.begin(), t.end(), x) - t.begin() + 1;\n}\nint main() {\n  cin >> n >> m;\n  long long p = (m * 8LL) / n;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    t.push_back(a[i]);\n  }\n  sort(t.begin(), t.end());\n  t.erase(unique(t.begin(), t.end()), t.end());\n  int len = t.size();\n  if (p >= 20 || (1 << p) >= len) {\n    puts(\"0\");\n    return 0;\n  }\n  long long ans = 0;\n  for (int i = 1; i <= n; i++) {\n    num[getId(a[i])]++;\n  }\n  for (int i = 2; i <= len; i++) {\n    num[i] = num[i] + num[i - 1];\n  }\n  long long pp = (1 << p);\n  for (int i = pp; i <= len; i++) {\n    ans = max(ans, (long long)num[i] - num[i - pp]);\n  }\n  cout << n - ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k;\nint arr[400009];\nmap<int, int> mp;\nvector<int> v;\nint sum[400009];\nint main() {\n  cin >> n >> k;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &arr[i]);\n    if (mp[arr[i]] == 0) {\n      v.push_back(arr[i]);\n    }\n    mp[arr[i]]++;\n  }\n  sort(v.begin(), v.end());\n  k *= 8;\n  int all = 0;\n  for (int i = v.size() - 1; i >= 0; i--) {\n    sum[i] = sum[i + 1] + mp[v[i]];\n  }\n  int ans = 1000000009;\n  for (int i = 0; i < v.size(); i++) {\n    int l = i, r = v.size() + 1;\n    while (r - l > 1) {\n      int m = (l + r) / 2;\n      if (ceil(log2(m - i)) * n <= k) {\n        l = m;\n      } else {\n        r = m;\n      }\n    }\n    ans = min(ans, all + sum[l]);\n    all += mp[v[i]];\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\nfrom itertools import accumulate as acc\n\nn, m = map( int, input().split() )\nm = ( m * 8 ) // n\nmx = 2 ** m\na = list( map( int, input().split() ) )\nc, d = {}, []\nfor i in a:\n    if i not in c:\n        c[ i ] = 1\n        d.append( i )\n    else:\n        c[ i ] += 1\nd.sort()\nd = [ c[ i ] for i in d ]\nd = list( acc( d ) )\nans = 0\nfor i in range( min( mx - 1, len(d) - 1 ), len(d) ):\n    s = d[ i ]\n    if i >= mx:\n        s -= d[ i - mx ]\n    ans = max( ans, s )\n\nprint( n - ans )\n "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  register int res = 0, c;\n  while (c = getchar(), c < '0' || c > '9')\n    ;\n  do {\n    res = (res * 10) + (c ^ 48);\n  } while (c = getchar(), c >= '0' && c <= '9');\n  return res;\n}\nint s[400010];\nunordered_map<int, int> times;\nint main() {\n  int N = read(), I = read(), k = I * 8 / N;\n  if (k >= 19) return puts(\"0\"), 0;\n  k = (1 << k);\n  for (int i = 1; i <= N; i++) s[i] = read();\n  sort(s + 1, s + 1 + N);\n  int j = 0, ans = 0x3f3f3f3f, kk = 0;\n  for (int i = 1; i <= N; i++) {\n    while (j < N) {\n      register int t = s[j + 1];\n      bool test = times[t] == 0;\n      if (kk + test <= k) {\n        j++;\n        times[t]++;\n        if (test) kk++;\n      } else\n        break;\n    }\n    ans = min(ans, N - j + i - 1);\n    if (!--times[s[i]]) {\n      kk--;\n      times.erase(s[i]);\n    }\n    if (j == N) break;\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mod = 1000000007;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, x;\n  cin >> n >> x;\n  x *= 8;\n  vector<int> v(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> v[i];\n  }\n  sort(v.begin(), v.end());\n  int c = 1;\n  vector<int> c1(0);\n  c1.push_back(1);\n  for (int i = 1; i < n; ++i) {\n    if (v[i] != v[i - 1]) {\n      c++;\n      c1.push_back(1);\n    } else {\n      c1[(int)c1.size() - 1]++;\n    }\n  }\n  int r = x / n;\n  if (r > 20) {\n    cout << 0;\n    return 0;\n  }\n  if (pow(2, r) >= c) {\n    cout << 0;\n    return 0;\n  }\n  r = pow(2, r);\n  int start = 0;\n  long long sum = 0;\n  long long min1;\n  for (int i = 0; i < c - r; ++i) {\n    sum += c1[i];\n  }\n  min1 = sum;\n  int si = c1.size();\n  for (int i = 0; i < si - r; ++i) {\n    if (c - r - i - 1 < 0) break;\n    sum -= c1[c - r - i - 1];\n    sum += c1[c - i - 1];\n    min1 = min(min1, sum);\n  }\n  cout << min1;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader sc = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task solver = new Task();\n        solver.solve(1, sc, out);\n        out.close();\n    }\n\n    static class Task {\n    \tpublic long get(long x) {\n    \t\treturn (long)Math.ceil(Math.log((double)x)/Math.log(2.0));\n    \t}\n    \t\n        public void solve(int testNumber, InputReader sc, PrintWriter out) {\n            int n=sc.nextInt();\n            long max=sc.nextLong()*8;\n            long[] a=new long[n+1];\n            HashMap<Long,Long> map=new HashMap<Long,Long>();\n            \n            for(int i=1;i<=n;i++) {\n            \ta[i]=sc.nextLong();\n            \tlong d=0;\n            \tif(map.containsKey(a[i]))\n            \t\td=map.get(a[i]);\n            \tmap.put(a[i],d+1);\n            }\n            long k=map.size();\n            long s=get(k)*n;\n            if(s<=max) {\n            \tout.println(\"0\");\n            \treturn;\n            }\n            long size=max/n;\n            long res=1;\n            while(size-->0)\n            \tres*=2l;\n            Node[] buf=new Node[map.size()];\n            int index=0;\n            for(Map.Entry<Long, Long> temp:map.entrySet()) {\n            \tbuf[index++]=new Node(temp.getKey(),temp.getValue());\n            }\n            Arrays.sort(buf);\n            long[] pre=new long[index];\n            for(int i=0;i<index;i++) {\n            \tif(i==0)\n            \t\tpre[i]=buf[i].val;\n            \telse {\n            \t\tpre[i]=pre[i-1]+buf[i].val;\n            \t}\n            }\n            long ans=n;\n            for(int i=0;i<index;i++) {\n            \tint take=Math.min(index-1, (int)(i+res-1));\n            \tans=Math.min(ans, n-(pre[take]-(i-1>=0?pre[i-1]:pre[i])));\n            }\n            out.println(ans);\n        }\n\n    }\n    \n    static class Node implements Comparable<Node>{\n    \tlong index;\n    \tlong val;\n    \t\n    \tpublic Node(long index,long val) {\n    \t\tthis.index=index;\n    \t\tthis.val=val;\n    \t}\n\n\t\t@Override\n\t\tpublic int compareTo(Node o) {\n\t\t\treturn (int)(this.index-o.index);\n\t\t}\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class TaskC_ {\n\tpublic static void main(String[] arg) {\n\t\tfinal FastScanner in = new FastScanner(System.in);\n\t\tfinal PrintWriter out = new PrintWriter(System.out);\n\t\tfinal int n = in.nextInt();\n\t\tfinal int I = in.nextInt();\n\t\tfinal int[] a = new int[n];\n\t\tTreeMap<Integer, Integer> differentNumbers = new TreeMap<Integer, Integer>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = in.nextInt();\n\t\t\tdifferentNumbers.put(a[i], differentNumbers.getOrDefault(a[i], 0) + 1);\n\t\t}\n\n\t\tlong maxSize = I * 8;\n\t\tlong size = n * bits(differentNumbers.size());\n\n\t\tif (size <= maxSize) {\n\t\t\tout.println(\"0\");\n\t\t\tout.close();\n\t\t\treturn;\n\t\t}\n\t\tint maxAllowedCount = differentNumbers.size();\n\t\twhile (size > maxSize) {\n\t\t\tmaxAllowedCount -= 1;\n\t\t\tsize = n * bits(maxAllowedCount);\n\t\t}\n\n\t\tint[] values = differentNumbers.entrySet().stream().mapToInt(entry -> entry.getValue()).toArray();\n\t\tlong skipCount = 0;\n\t\tfor (int i = maxAllowedCount; i < values.length; i++) {\n\t\t\tskipCount += values[i];\n\t\t}\n\t\tlong minCount = skipCount;\n\t\tfor (int i = 1; (i + maxAllowedCount) < values.length; i++) {\n\t\t\tskipCount = skipCount + values[i - 1] - values[i + maxAllowedCount-1];\n\t\t\tminCount = Math.min(minCount, skipCount);\n\t\t}\n\t\tout.print(minCount);\n\t\tout.close();\n\t}\n\n\tpublic static int bits(int n) {\n\t\tint bits = 31 - Integer.numberOfLeadingZeros(n);\n\t\tif (1 << bits < n) {\n\t\t\tbits++;\n\t\t}\n\t\treturn bits;\n\t}\n\n\tprivate static class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tFastScanner(InputStream stream) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new InputStreamReader(stream));\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.lang.*;\n\npublic class A {\n\n\tpublic static void main(String[] args) {\n\t\tFastReader in = new FastReader();\n\t\tint n = in.nextInt(), I = in.nextInt()*8;\n\t\tint power = I/n;\n//\t\tSystem.out.println(n+\" \"+I);\n//\t\tSystem.out.println(power);\n\t\tint distinctBits = (int)Math.pow(2, Math.min(20,power));\n\t\tint[] arr = in.readArray(n);\n\t\tTreeMap<Integer,Integer> map = new TreeMap<>();\n\t\tfor(int x:arr) {\n\t\t\tif(map.containsKey(x)) {\n\t\t\t\tint cnt = map.get(x)+1;\n\t\t\t\tmap.put(x, cnt);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmap.put(x,1);\n\t\t\t}\n\t\t}\n\t\tif(map.size()<=distinctBits) {\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\t\tlong[] freq = new long[map.size()];\n\t\tint index = 0;\n\t\tfor(int x:map.values()) {\n\t\t\tfreq[index] = x;\n\t\t\tindex++;\n\t\t}\n\t\tfor(int i=1;i<freq.length;i++) {\n\t\t\tfreq[i] = freq[i]+freq[i-1];\n\t\t}\n\t\tlong answer = 0;\n//\t\tSystem.out.println(Arrays.toString(freq));\n\t\tfor(int i=distinctBits;i<freq.length;i++) {\n\t\t\tanswer = Math.max(answer, freq[i]-freq[i-distinctBits]);\n\t\t}\n//\t\tSystem.out.println(distinctBits);`\n\t\tSystem.out.println(n-answer);\n\t\t\n\t}\n\n\tstatic final Random random=new Random();\n\t//\tstatic void ruffleSort(Pair[] a) {\n\t//\t\tint n=a.length;//shuffle, then sort \n\t//\t\tfor (int i=0; i<n; i++) {\n\t//\t\t\tint oi=random.nextInt(n);\n\t//\t\t\tPair temp=a[oi];\n\t//\t\t\ta[oi]=a[i]; a[i]=temp;\n\t//\t\t}\n\t//\t\tArrays.sort(a);\n\t//\t}\n\tstatic void ruffleSort(int[] a) {\n\t\tint n=a.length;//shuffle, then sort \n\t\tfor (int i=0; i<n; i++) {\n\t\t\tint oi=random.nextInt(n), temp=a[oi];\n\t\t\ta[oi]=a[i]; a[i]=temp;\n\t\t}\n\t\tArrays.sort(a);\n\t}\n\tstatic void ruffleSort(char[] a) {\n\t\tint n=a.length;//shuffle, then sort \n\t\tfor (int i=0; i<n; i++) {\n\t\t\tint oi=random.nextInt(n);\n\t\t\tchar temp=a[oi];\n\t\t\ta[oi]=a[i]; a[i]=temp;\n\t\t}\n\t\tArrays.sort(a);\n\t}\n\tstatic class FastReader \n\t{ \n\t\tBufferedReader br; \n\t\tStringTokenizer st; \n\n\t\tpublic FastReader() \n\t\t{ \n\t\t\tbr = new BufferedReader(new\n\t\t\t\t\tInputStreamReader(System.in)); \n\t\t} \n\n\t\tString next() \n\t\t{ \n\t\t\twhile (st == null || !st.hasMoreElements()) \n\t\t\t{ \n\t\t\t\ttry\n\t\t\t\t{ \n\t\t\t\t\tst = new StringTokenizer(br.readLine()); \n\t\t\t\t} \n\t\t\t\tcatch (IOException  e) \n\t\t\t\t{ \n\t\t\t\t\te.printStackTrace(); \n\t\t\t\t} \n\t\t\t} \n\t\t\treturn st.nextToken(); \n\t\t} \n\n\t\tint nextInt() \n\t\t{ \n\t\t\treturn Integer.parseInt(next()); \n\t\t} \n\n\t\tlong nextLong() \n\t\t{ \n\t\t\treturn Long.parseLong(next()); \n\t\t} \n\n\t\tdouble nextDouble() \n\t\t{ \n\t\t\treturn Double.parseDouble(next()); \n\t\t} \n\n\t\tString nextLine() \n\t\t{ \n\t\t\tString str = \"\"; \n\t\t\ttry\n\t\t\t{ \n\t\t\t\tstr = br.readLine(); \n\t\t\t} \n\t\t\tcatch (IOException e) \n\t\t\t{ \n\t\t\t\te.printStackTrace(); \n\t\t\t} \n\t\t\treturn str; \n\t\t} \n\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n}\n\n//class Pair implements Comparable<Pair>{\n//    int a;\n//    int b;\n//    public Pair(int a, int b) {\n//        this.a = a;\n//        this.b = b;\n//    }\n//    public int compareTo(Pair o) {\n//        if(this.a==o.a)\n//            return this.b - o.b;\n//        return this.a - o.a;\n//    }   \n//}"
        },
        {
            "language": 1,
            "solution": "n, I = [int(j) for j in raw_input().split()]\narr = [int(j) for j in raw_input().split()]\nd = dict()\nfor i in arr:\n    try:\n        d[i] += 1\n    except:\n        d[i]=1\nkeylist = d.keys()\nkeylist = sorted(keylist)\nimport math\ndelnum = math.floor((8*I)/n)\n# print(delnum)\nif delnum<20:\n    delnum = max(0,len(keylist) - 2**delnum)\nelse:\n    delnum = 0\ntobedelete = delnum\nfinalnum = int(len(keylist) - delnum)\n# print(delnum)\nif delnum:\n    maxim = 10**10\n    # print(delnum, keylist)\n    n1 = len(keylist)\n    # print(\"numbers to be finally remain:\", finalnum)\n    local_max = 0\n    for j in range(int(finalnum)):\n        local_max += d[keylist[j]]\n    maxim = min(n-local_max, maxim)   \n    for i in range(1,int(n1-finalnum+1)):\n        # print(i+finalnum)\n        \n        local_max = local_max + d[keylist[i+finalnum-1]] - d[keylist[i-1]] \n        \n        # for j in range(int(finalnum)):\n            # print(\"for \"+str(keylist[i])+\"this that are going with him\"+str(keylist[i+j]))\n            # print(i+j)\n            # local_max += d[keylist[i+j]]\n        # print(\"for \"+str(keylist[i])+\"this many will die\"+ str(n-local_max))\n        maxim = min(n-local_max, maxim)\n    print(maxim) \nelse:\n    print(0)"
        },
        {
            "language": 3,
            "solution": "ni = input()\nn,i = list(map(int,ni.split()))\nnums = input()\nnums = list(map(int,nums.split()))\ni = i*8\nmm = {}\nfor k in nums:\n\tif k in mm:\n\t\tmm[k] += 1\n\telse:\n\t\tmm[k] = 1\nkeys = mm.keys()\ns_keys = sorted(list(keys))\nbits = i//n\nnums_len = pow(2,bits)\nright = nums_len\nleft = 0\nif right >= len(s_keys):\n\tprint(0)\nelse:\n\tmin_change = 999999\n\tnow_change = 0\n\tfor k in s_keys[right:]:\n\t\tnow_change += mm[k]\n\twhile right < len(s_keys):\n\t\tif now_change < min_change:\n\t\t\tmin_change = now_change\n\t\tnow_change += mm[s_keys[left]]\n\t\tnow_change -= mm[s_keys[right]]\n\t\tleft += 1\n\t\tright += 1\n\tprint(min_change)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\n#pragma GCC optimization(\"O3\")\n#pragma GCC optimization(\"unroll-loops\")\nusing namespace std;\nconst int mod = (int)1e9 + 7;\nconst int N = 1e5 + 10;\nconst long long inf = -1e17;\nstruct event {\n  long long a, b, c, d;\n};\nvoid solve() {\n  long long n, bit;\n  cin >> n >> bit;\n  vector<int> a(n);\n  long long k = 8 * bit;\n  k = k / n;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  long long z = k;\n  k = 1;\n  while (z--) {\n    k = k * 2LL;\n    if (k > n) {\n      cout << 0;\n      return;\n    }\n  }\n  sort(a.begin(), a.end());\n  long long cnt = 0, res = 0;\n  int j = 0;\n  for (int i = 0; i < n; i++) {\n    while (j < n && cnt < k) {\n      cnt++;\n      int pp = j;\n      while (pp < n && a[pp] == a[j]) pp++;\n      j = pp;\n    }\n    long long rr = j - i;\n    res = max(res, rr);\n    int k = i;\n    while (k < n && a[k] == a[i]) k++;\n    cnt--;\n    i = k - 1;\n  }\n  cout << n - res;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int power(long long int x, long long int y) {\n  long long int one = 1;\n  if (!y)\n    return one;\n  else if (y == 1)\n    return x;\n  else {\n    long long int y1 = power(x, y >> 1);\n    long long int y2 = y1 * y1;\n    if (y & 1)\n      return x * y2;\n    else\n      return y2;\n  }\n}\nbool comp(pair<int, int> a, pair<int, int> b) {\n  if (a.first != b.first)\n    return a.first < b.first;\n  else\n    return a.second > b.second;\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int n, mx;\n  cin >> n >> mx;\n  long long int a[n];\n  map<long long int, long long int> occ;\n  for (int i = 0; i < n; i++) cin >> a[i], occ[a[i]]++;\n  long long int allow = 8 * mx;\n  allow /= n;\n  if (allow > 20) {\n    cout << 0;\n    return 0;\n  }\n  long long int dis = power(2, allow);\n  vector<pair<int, int> > give;\n  for (auto v : occ) give.push_back(make_pair(v.first, v.second));\n  long long int n1 = give.size();\n  sort(give.begin(), give.end(), comp);\n  long long int ans = INT_MAX;\n  long long int presum[n1];\n  presum[0] = give[0].second;\n  for (int i = 1; i < n1; i++) presum[i] = presum[i - 1] + give[i].second;\n  if (n1 <= dis) {\n    cout << 0;\n    return 0;\n  }\n  for (int i = 0; i <= n1 - dis; i++) {\n    int rem = 0;\n    if (i == 0)\n      rem = presum[i + dis - 1];\n    else\n      rem = presum[i + dis - 1] - presum[i - 1];\n    if (n - rem < ans) ans = n - rem;\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mod = 1e9 + 7;\nconst int maxn = 4e5 + 10;\nint n, I, a[maxn];\nint main(void) {\n  scanf(\"%d%d\", &n, &I);\n  for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n  int K = 1, k;\n  k = 8 * I / n;\n  for (int i = 1; i <= min(20, k); i++) K *= 2;\n  sort(a, a + n);\n  int l = 0, r = -1, ans = 1e9 + 7, nowcnt = 0;\n  map<int, int> mp;\n  for (int i = 0; i < n; i++) mp[a[i]] = 0;\n  while (1) {\n    while (1) {\n      if ((mp[a[r + 1]] == 0 && K == nowcnt) || r == n - 1) break;\n      r++;\n      if (mp[a[r]] == 0) nowcnt++;\n      mp[a[r]]++;\n    }\n    ans = min(ans, n - (r - l + 1));\n    mp[a[l]]--;\n    if (mp[a[l]] == 0) nowcnt--;\n    l++;\n    if (r == n - 1 || l == n - 1) break;\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 4e5 + 777;\nint a[N], b[N], lo[N];\nint main() {\n  lo[1] = 0;\n  for (int i = 2; i <= 400000; ++i) {\n    lo[i] = lo[i >> 1] + 1;\n  }\n  int p = 4;\n  for (int i = 3; i <= 400000; ++i) {\n    if (i != p)\n      lo[i]++;\n    else\n      p <<= 1;\n  }\n  int n, I;\n  scanf(\"%d%d\", &n, &I);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d\", a + i);\n  }\n  sort(a + 1, a + n + 1);\n  int tot = 1, last = a[1], cnt = 1;\n  for (int i = 2; i <= n; ++i) {\n    if (a[i] == last) {\n      ++cnt;\n    } else {\n      b[tot++] = cnt;\n      last = a[i];\n      cnt = 1;\n    }\n  }\n  b[tot++] = cnt;\n  int C = I * 8 - lo[tot - 1] * n;\n  if (C >= 0) {\n    puts(\"0\");\n    return 0;\n  } else {\n    for (int i = 2; i < tot; ++i) {\n      b[i] = b[i] + b[i - 1];\n    }\n    int tar;\n    for (int i = tot - 1; i >= 1; --i) {\n      if (I * 8 - lo[i] * n >= 0) {\n        tar = i;\n        break;\n      }\n    }\n    tar = tot - 1 - tar;\n    int ans = 66666666;\n    for (int i = 0; i <= tar; ++i) {\n      ans = min(ans, b[i] + b[tot - 1] - b[tot - 1 - (tar - i)]);\n    }\n    printf(\"%d\\n\", ans);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N, I, K;\nvector<int> v;\nmap<int, int> mp;\nint main() {\n  scanf(\"%d%d\", &N, &I);\n  I *= 8;\n  K = I / N;\n  K = min(K, 25);\n  K = (1 << K);\n  for (int i = 1; i <= N; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    v.push_back(x);\n  }\n  sort(begin(v), end(v));\n  int j = 0, dif = 0;\n  int ans = N;\n  for (int i = 0; i < N; i++) {\n    while (j < N) {\n      if (dif == K && mp[v[j]] == 0) break;\n      mp[v[j]]++;\n      if (mp[v[j]] == 1) dif++;\n      j++;\n    }\n    ans = min(ans, N - (j - i));\n    mp[v[i]]--;\n    if (mp[v[i]] == 0) dif--;\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict\n\nn,I = [int(w) for w in input().split()]\nl = [int(w) for w in input().split()]\n\nk = 8*I//n\nK = 2**k\nl.sort()\npref = [0]\nhash = defaultdict(int)\nfor i in l:\n    hash[i]+=1\nfor i in hash.keys():\n    pref.append(pref[-1]+hash[i])\n\n\n# print(l,pref)\nmini = -10\nd = len(pref)-1-K\nmini = 10**18\n\nfor i in range(d):\n    ele1 = i\n    ele2 = d-i\n    a = pref[ele1]\n    b = abs(pref[len(pref)-ele2-1] - pref[len(pref)-1])\n\n    mini = min(a+b,mini)\n\nif mini == 10**18:\n    print(0)\nelse:\n    print(mini)\n\n"
        },
        {
            "language": 3,
            "solution": "n, m = map(int, input().split())\na = sorted([int(i) for i in input().split()])\n\nk = 1 << m * 8 // n\nl, r = 0, 1\nans = n\ncnt = k - 1\n\nwhile r < n:\n    if a[r - 1] == a[r] or cnt > 0:\n        if a[r - 1] != a[r]:\n            cnt -= 1\n            \n        r += 1\n    else:\n        ans = min(ans, n - r + l)\n        l += 1\n        \n        if a[l] != a[l - 1]:\n            cnt = 1\n        \nans = min(ans, n - r + l)\n    \nprint(ans)"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.Scanner;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class MP3 {\n\n    static void shuffleArray(int[] ar) {\n        Random rnd = ThreadLocalRandom.current();\n        for (int i = ar.length - 1; i > 0; i--) {\n            int index = rnd.nextInt(i + 1);\n            int a = ar[index];\n            ar[index] = ar[i];\n            ar[i] = a;\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int I = sc.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n        }\n        sc.close();\n        shuffleArray(a);\n        Arrays.sort(a);\n        List<Pair> arrayList = new ArrayList<>();\n        for (int i = 0; i < n;) {\n            int value = a[i];\n            int cnt = 0;\n            for (; i < n && a[i] == value; i++) {\n                cnt++;\n            }\n            arrayList.add(new Pair(value, cnt));\n        }\n        long K = 1;\n        int power = (I * 8) / n;\n        for (int i = 0; i < power; i++) {\n            K *= 2;\n            if (K >= n)\n                break;\n        }\n        int discnt = arrayList.size();\n        if (K >= discnt) {\n            System.out.println(\"0\");\n        }\n        else {\n            int sum = 0;\n            for (int i = 0; i < K; i++){\n                sum += arrayList.get(i).value;\n            }\n            int ans = sum;\n            for (int i = (int)K; i < discnt; i++) {\n                sum = sum + arrayList.get(i).value - arrayList.get((int) (i - K)).value;\n                ans = Math.max(ans, sum);\n            }\n            System.out.println(n-ans);\n        }\n    }\n}\n\nclass Pair {\n    int key, value;\n\n    public Pair(int key, int value) {\n        this.key = key;\n        this.value = value;\n    }\n}"
        },
        {
            "language": 3,
            "solution": "import sys\n\nin_file = sys.stdin #open(\"C.txt\", \"r\")\nn, I = map(int, in_file.readline().strip().split())\nA = list(map(int, in_file.readline().strip().split()))\nmax_k = (I*8)//n\nm = 2**max_k\nA.sort()\nt = A[0]\nB = [0]\nfor a in A:\n    if a == t:\n        B[-1] += 1\n    else:\n        t = a\n        B.append(1)\nres = sum(B[:m])\nt = res\nfor i in range(m, len(B)):\n    t += B[i]-B[i-m]\n    if t > res:\n        res = t\nsys.stdout.write(str(n-res))\nsys.stdout.flush()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[500000], b[500000], presum[500000];\nint main() {\n  int n, I, k, m, ans;\n  cin >> n >> I;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  k = 8 * I / n;\n  if (k > 29) {\n    m = n;\n  } else {\n    m = min(n, int(floor(pow(2, k))));\n  }\n  if (m >= n) {\n    ans = 0;\n  } else {\n    sort(a, a + n);\n    int cnt = 1, j = 0;\n    for (int i = 1; i < n; i++) {\n      if (a[i] != a[i - 1]) {\n        b[j++] = cnt;\n        cnt = 1;\n      } else {\n        cnt++;\n      }\n    }\n    b[j++] = cnt;\n    presum[0] = 0;\n    for (int i = 0; i < j; i++) {\n      presum[i + 1] = presum[i] + b[i];\n    }\n    if (m >= j) {\n      ans = 0;\n    } else {\n      ans = n;\n      for (int i = 0; i < (j - m) + 1; i++) {\n        int tmp = presum[i + m] - presum[i];\n        int change = n - tmp;\n        ans = min(ans, change);\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def mp():\n    return map(int, input().split())\n\nn, I = mp()\na = sorted(list(mp()))\n\nk = 2 ** ((I * 8) // n)\n\ncnt = [[a[0], 1]]\nfor i in range(1, n):\n    if cnt[-1][0] == a[i]:\n        cnt[-1][1] += 1\n    else:\n        cnt.append([a[i], 1])\nN = n\nn = len(cnt)\na = [i[1] for i in cnt]\n\ns = sum(a[:k])\nans = s\nfor i in range(k, n):\n    s -= a[i - k]\n    s += a[i]\n    ans = max(ans, s)\nprint(sum(a) - ans)"
        },
        {
            "language": 3,
            "solution": "from collections import Counter\n# from collections import OrderedDict \n\nnn, i = map(int, input().strip().split(' '))\na = [int(x) for x in input().strip().split(' ')]\nad = dict(Counter(a))\n# print(ad)\na = sorted(ad)\n# print(ad)\nk = 8*i // nn\nstorage = 2 ** min(20, k)\nif len(Counter(a).keys()) <= storage:\n  print(0)\nelse:\n  n = len(a)\n  sm = 0\n  i = 0\n  j = storage\n  while i < j:\n    sm = sm + ad[a[i]]\n    i = i+1\n  msum = sm\n  i = 0\n  while j < n:\n    sm = sm - ad[a[i]] + ad[a[j]]\n    i = i+1\n    j = j+1\n    msum = max(sm, msum)\n  print(nn-msum)\n\n\n\n   \n  \n\n  \n"
        },
        {
            "language": 3,
            "solution": "import sys\n\nn, I = map(int, sys.stdin.readline().split())\ns = list(map(int, sys.stdin.readline().split()))\nk = I * 8 // n\ns.sort()\nc = [0]\nfor i in range(1, n):\n    if s[i] != s[i - 1]:\n        c.append(i)\nk = 2 ** k\nmaxn = -1\nfor i in range(0, len(c) - k):\n    maxn = max(maxn, c[i + k] - c[i])\nif maxn == -1:\n    print(0)\nelse:\n    ans = n - maxn\n    print(ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nifstream fin(\"AAtest.in.txt\");\nlong long n, L, k, jad[400005];\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cerr.tie(0);\n  cin >> n >> L;\n  for (int(i) = (0); ((i)) < ((n)); ((i))++) cin >> jad[i];\n  k = 8 * L / n;\n  long long c = 1;\n  k = min(k, (long long)30);\n  for (int(i) = (0); ((i)) < ((k)); ((i))++) c *= 2;\n  sort(jad, jad + n);\n  long long l = 0, r = 0, er = 1;\n  long long vas = 0;\n  for (int(i) = (0); ((i)) < ((n)); ((i))++) {\n    if (i and jad[i] != jad[i - 1]) er++;\n    if (er > c) {\n      vas = max(vas, i - l);\n      while (jad[l] == jad[l + 1]) l++;\n      l++;\n      er--;\n    }\n  }\n  vas ? cout << n - vas : cout << vas;\n}\n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin\nfrom math import log2,ceil\nfrom bisect import bisect_left as bl\n\nn,m=map(int,stdin.readline().strip().split())\ns=list((map(int,stdin.readline().strip().split())))\nmx=0\nfor i in range(1,n+3):\n    x=ceil(log2(i))*n\n    if ceil(x/8)<=m:\n        mx=i\n    else:\n        break\n\ns.sort()\ns1=list(set(s.copy()))\ns1.sort()\ninf=10**9\nans=10**9\n\nfor i in range(len(s1)):\n    x=s1[i]\n    y=inf\n    if (i+mx)<len(s1):\n        y=s1[i+mx]\n\n    ans=min(ans,n-(bl(s,y)-bl(s,x)))\nprint(ans)\n    \n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, second;\nvoid input() {\n  cin >> n >> second;\n  second *= 8;\n}\nvoid solve() {\n  vector<long long int> a(n);\n  map<long long int, long long int> mp;\n  for (auto &it : a) cin >> it, mp[it]++;\n  a.clear();\n  for (auto it : mp) a.emplace_back(it.first);\n  long long l = 0, r = -1;\n  while (r < ((long long int)(a).size())) {\n    r++;\n    if (r == ((long long int)(a).size())) break;\n    long long siz = ceil(log2(r + 1)) * n;\n    if (siz <= second)\n      ;\n    else\n      break;\n  }\n  if (r == ((long long int)(a).size()))\n    cout << 0;\n  else {\n    vector<long long int> c(((long long int)(a).size()));\n    c[0] = mp[a[0]];\n    for (long long i = 1; i < ((long long int)(a).size()); i++)\n      c[i] = c[i - 1] + mp[a[i]];\n    long long ans = c.back() - c[r - 1];\n    while (r < ((long long int)(a).size())) {\n      l++;\n      long long z = c[l - 1] + c.back() - c[r];\n      ans = min(ans, z);\n      r++;\n    }\n    cout << ans;\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.precision(20);\n  long long T = 1;\n  while (T--) {\n    input();\n    solve();\n  }\n  cin.get();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconstexpr int MAXN = 400000 + 10;\nint uplog2[MAXN], a[MAXN], count[MAXN], preless[MAXN], sufgreater[MAXN];\nint n, I;\nbool check(int l, int r) {\n  return n * uplog2[count[r] - count[l] + 1] <= I * 8;\n}\nint cost(int l, int r) { return preless[l] + sufgreater[r]; }\nint main() {\n  scanf(\"%d%d\", &n, &I);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", a + i);\n  std::sort(a + 1, a + n + 1);\n  preless[1] = 0;\n  for (int i = 2; i <= n; ++i)\n    if (a[i] == a[i - 1])\n      preless[i] = preless[i - 1];\n    else\n      preless[i] = i - 1;\n  sufgreater[n] = 0;\n  for (int i = n - 1; i > 0; --i)\n    if (a[i] == a[i + 1])\n      sufgreater[i] = sufgreater[i + 1];\n    else\n      sufgreater[i] = n - i;\n  count[1] = 0;\n  for (int i = 2; i <= n; ++i) {\n    count[i] = count[i - 1];\n    if (a[i] != a[i - 1]) ++count[i];\n  }\n  uplog2[1] = 0;\n  for (int i = 2; i <= n; ++i) {\n    uplog2[i] = uplog2[i - 1];\n    if (((i - 1) & (i - 2)) == 0) ++uplog2[i];\n  }\n  int r = 1;\n  int ans = n + 1;\n  for (int l = 1; l <= n; ++l) {\n    while (r < n && check(l, r + 1)) ++r;\n    ans = std::min(ans, cost(l, r));\n  }\n  printf(\"%d\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  long long n, q;\n  cin >> n >> q;\n  vector<long long> v(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> v[i];\n  }\n  if (8 * q / n > 20) {\n    cout << 0;\n    return 0;\n  }\n  sort((v).begin(), (v).end());\n  q = 1 << (8 * q / n);\n  vector<long long> d(n);\n  d[0] = 1;\n  for (int i = 1; i < n; ++i) {\n    d[i] = d[i - 1];\n    d[i] += (v[i] != v[i - 1]);\n  }\n  int ans = 0;\n  for (int i = 0; i < n; ++i) {\n    int x = lower_bound((d).begin(), (d).end(), q + d[i]) - d.begin();\n    ans = max(ans, x - i);\n  }\n  cout << n - ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long p(long long pw) {\n  if (pw == 0) return 1;\n  long long ans = 1;\n  long long into = 2;\n  while (pw) {\n    if (pw & 1) ans *= into;\n    into *= into;\n    pw >>= 1;\n  }\n  return ans;\n}\nint main() {\n  ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);\n  long long n, tot;\n  cin >> n >> tot;\n  tot *= 8;\n  long long k = tot / n;\n  k = p(min(20LL, k));\n  vector<long long> v(n);\n  map<long long, long long> fre;\n  for (auto &in : v) {\n    cin >> in;\n    fre[in]++;\n  }\n  sort(v.begin(), v.end());\n  v.erase(unique(v.begin(), v.end()), v.end());\n  long long cnt = v.size() - k;\n  if (cnt <= 0)\n    cout << 0 << endl;\n  else {\n    long long f = -1, l;\n    long long ans = 0;\n    vector<long long> x;\n    for (int i = 0; i < v.size(); i++) {\n      x.push_back(fre[v[i]]);\n      if (x.size() != 1) x[x.size() - 1] += x[x.size() - 2];\n    }\n    long long mn = 1e9;\n    while (true) {\n      f++;\n      l = f + k - 1;\n      if (l >= v.size()) break;\n      if (f > 0)\n        mn = min(mn, x[f - 1] + x[x.size() - 1] - x[l]);\n      else\n        mn = min(mn, x[x.size() - 1] - x[l]);\n    }\n    cout << mn << endl;\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "#------------------------------warmup----------------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n#-------------------game starts now-----------------------------------------------------\nimport math\nn,k=map(int,input().split())\nl=list(map(int,input().split()))\ns=set()\nd=dict()\ndis=0\nfor i in range(n):\n    if l[i] not in s:\n        dis+=1\n        s.add(l[i])\n        d.update({l[i]:1})\n    else:\n        d[l[i]]+=1\ndis=math.ceil(math.log(dis,2))*n\nif dis<=8*k:\n    print(0)\nelse:\n u=list(s)\n u.sort()\n c=[0]*(len(u)+1)\n m=0\n c[0]=0\n #d = dict( sorted(d.items(), key=operator.itemgetter(1),reverse=True))\n c[1]=d[u[0]]\n for i in range(2,len(u)+1):\n     c[i]=c[i-1]+d[u[i-1]]\n #print(c)\n k=2**(8*k//n)\n for i in range(len(c)-1,k-1,-1):\n     m=max(c[i]-c[i-k],m)\n     #print(c[i]-c[i-k],k)\n print(n-m)\n "
        },
        {
            "language": 1,
            "solution": "from collections import Counter\n# from math import log,ceil\nn,I=map(int,raw_input().split())\narr=map(int,raw_input().split())\ndic = Counter(arr)\nthres=int(2**((8*I)/(n)))\nl1 = list(set(arr))\nl1.sort()\n# print dic\nl=len(l1)\n# print l1\n# print thres\nif(l<=thres):\n\tprint 0\nelse:\n\ttemp = l-thres\n\t# print ceil(log(thres)/log(2))\n\t# print temp\n\tans=10**30\n\tm1=[dic[l1[0]]]\n\tm2=[dic[l1[-1]]]\n\tfor i in range(1,temp):\n\t\tm1.append(m1[-1]+dic[l1[i]])\n\tfor i in range(1,temp):\n\t\tm2.append(m2[-1]+dic[l1[-1*(i+1)]])\n\tm1.append(0)\n\tm2.append(0)\n\t# print m1\n\t# print m2\n\tfor i in range(temp+1):\n\t\t# print m1[i],\n\t\t# print m2[temp-i-2]\n\t\tans=min(ans,m1[i]+m2[temp-i-2])\n\tprint ans\t"
        },
        {
            "language": 3,
            "solution": "n, i = map(int, input().split())\nlst = list(map(int, input().split()))\ni *= 8\nk = i // n\nimax = 2 ** k\nidict = {}\nfor i in lst:\n    if idict.get(i) == None:\n        idict[i] = 1\n    else:\n        idict[i] += 1\nlst = sorted(idict.keys())\nisum = 0\nimin = None\nl = 0\nq = 0\nr = 0\nwhile r < len(lst):\n    isum += 1\n    q += idict[lst[r]]\n    r += 1\n    if isum > imax or r == len(lst):\n        copyisum = q - idict[lst[r - 1]]\n        if r == len(lst) and isum <= imax:\n            copyisum += idict[lst[r - 1]]\n        shakal = n - copyisum\n        if imin == None or imin > shakal:\n            imin = shakal\n    while isum > imax:\n        isum -= 1\n        q -= idict[lst[l]]\n        l += 1\nprint(imin)"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author cunbidun\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        Task1199C solver = new Task1199C();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class Task1199C {\n        private InputReader in;\n        private OutputWriter out;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            this.in = in;\n            this.out = out;\n            int n = in.nextInt();\n            int k = in.nextInt();\n            int[] a = in.nextIntArray(n, 1);\n            QuickSort.sort(a, 1, n);\n            int numBit = 8 * k;\n            if (numBit > 20 * n) {\n                out.println(0);\n                return;\n            }\n            int max = 1 << (numBit / n);\n\n            ArrayList<Integer> list = new ArrayList<>();\n            int cnt = 1;\n            for (int i = 2; i <= n; i++) {\n                if (a[i] != a[i - 1]) {\n                    list.add(cnt);\n                    cnt = 1;\n                } else cnt++;\n            }\n            list.add(cnt);\n\n            int[] sum = new int[n + 1];\n            for (int i = 1; i <= list.size(); i++) {\n                sum[i] = sum[i - 1] + list.get(i - 1);\n            }\n            int ans = sum[MaxMin.Min(max, list.size())];\n            for (int i = max + 1; i <= list.size(); i++) {\n                ans = MaxMin.Max(ans, sum[i] - sum[i - max]);\n            }\n            out.println(n - ans);\n        }\n\n    }\n\n    static class MaxMin {\n        public static <T extends Comparable<T>> T Max(T x, T y) {\n            T max = x;\n            if (y.compareTo(max) > 0) max = y;\n            return max;\n        }\n\n        public static <T extends Comparable<T>> T Min(T x, T y) {\n            T min = x;\n            if (y.compareTo(min) < 0) min = y;\n            return min;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter out;\n\n        public OutputWriter(OutputStream outputStream) {\n            out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.out = new PrintWriter(writer);\n        }\n\n        public void close() {\n            out.close();\n        }\n\n        public void println(int i) {\n            out.println(i);\n        }\n\n    }\n\n    static class QuickSort {\n        public static void sort(int[] list, int lowIndex, int highIndex) {\n            ArrayUtils.shuffleArray(list, lowIndex, highIndex);\n            Arrays.sort(list, lowIndex, highIndex + 1);\n        }\n\n    }\n\n    static class ArrayUtils {\n        public static void shuffleArray(int[] array, int stIndex, int enIndex) {\n            for (int i = enIndex; i > stIndex; i--) {\n                int index = (int) OneNumberGen.genInt(stIndex, i - 1);\n                if (index != i) {\n                    array[index] ^= array[i];\n                    array[i] ^= array[index];\n                    array[index] ^= array[i];\n                }\n            }\n        }\n\n    }\n\n    static class OneNumberGen {\n        private static long genI(long min, long max) {\n            return ThreadLocalRandom.current().nextLong(min, max + 1);\n        }\n\n        public static long genInt(long min, long max) {\n            if (min >= 0)\n                return (genI(min, max));\n            else if (max >= 0) {\n                double ratio = (double) Math.abs(min) / (Math.abs(min) + max);\n                ratio *= 1000000000000000000D;\n                double prob = (double) (OneNumberGen.genInt(1, 1000000000000000000L));\n                if (Double.compare(ratio, prob) > 0) {\n                    return -(genI(0, -min));\n                } else {\n                    return (genI(0, max));\n                }\n            } else\n                return -(OneNumberGen.genI(-min, -max));\n        }\n\n    }\n\n    static class InputReader extends InputStream {\n        private InputStream stream;\n        private byte[] buf = new byte[1 << 16];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public int[] nextIntArray(int length, int stIndex) {\n            int[] arr = new int[length + stIndex];\n            for (int i = stIndex; i < stIndex + length; i++)\n                arr[i] = nextInt();\n            return arr;\n        }\n\n        private static boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 1,
            "solution": "n,I=map(int,raw_input().split())\nl=map(int,raw_input().split())\nd ={}\nfor j in l:\n    d[j]=d.get(j,0)+1\ny=list(set(l))\ny.sort()\np=len(y)\nK=2**((I*8)/n)\nif K>=p:\n    print 0\n    exit()\nde=p-K\ntp=[0]\nrt=[0]\nfor i in range(p):\n    tp.append(tp[-1]+d[y[i]])\n    rt.append(rt[-1]+d[y[-1-i]])\nans=10**9+1\nfor i in range(de+1):\n    ans=min(ans,tp[de-i]+rt[i])\nprint ans"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nsigned main() {\n  long long n, raz, r = 0, ans = 0, dop = 0;\n  cin >> n >> raz;\n  vector<long long> a(n);\n  for (long long i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  sort(a.begin(), a.end());\n  long long k = 8 * raz / n;\n  long long K = (k < 30 ? (1 << k) : n);\n  for (long long l = 0; l < n; l++) {\n    while (r < n) {\n      if (l < r && a[r] == a[r - 1])\n        r++;\n      else {\n        if (dop == K) break;\n        dop++;\n        r++;\n      }\n    }\n    ans = max(ans, r - l);\n    if (l < n - 1 && (l + 1 == r || a[l] != a[l + 1])) dop--;\n  }\n  cout << n - ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long int n, I;\n  cin >> n >> I;\n  map<long long int, long long int> m;\n  vector<long long int> v;\n  for (int i = 0; i < n; i++) {\n    long long int temp;\n    cin >> temp;\n    if (m[temp] == 0) {\n      v.push_back(temp);\n    }\n    m[temp]++;\n  }\n  sort(v.begin(), v.end());\n  long double siz = v.size();\n  long double k = ceil(log(siz) / log(2));\n  if (n * k <= 8 * I) {\n    cout << 0;\n    return 0;\n  }\n  long double need = floor(8 * I / n);\n  long double elements = pow(2, need);\n  long long int sum = 0;\n  for (int i = 0; i < elements; i++) {\n    sum += m[v[i]];\n  }\n  long long int maxi = sum;\n  for (int i = elements; i < siz; i++) {\n    sum = sum - m[v[i - elements]] + m[v[i]];\n    maxi = max(maxi, sum);\n  }\n  cout << n - maxi << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class Main1 {\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic FastReader input = new FastReader();\n\tstatic int n, a[], p[];\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tint n = input.nextInt();\n\t\tint I = input.nextInt() * 8;\n\n\t\tint a[] = new int[n];\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = input.nextInt();\n\n\t\tshuffle(a);\n\t\tArrays.sort(a);\n\n\t\tp = new int[n + 1];\n\t\tp[1] = 1;\n\t\tint map[] = new int[n + 5];\n\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tp[i] += p[i - 1];\n\t\t\tif (i > 1 && a[i - 1] != a[i - 2]) {\n\t\t\t\tp[i]++;\n\t\t\t}\n\t\t\tmap[p[i]] = i;\n\t\t}\n\n\t\tint min = n;\n\n\t\tfor (int k = 0; k <= 20; k++) {\n\t\t\tint K = 1 << k;\n\t\t\tif (n * k <= I) {\n\t\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\t\ti = map[p[i]];\n\t\t\t\t\tint can = p[i] + K;\n\t\t\t\t\tcan = Math.min(can, p[n]);\n\t\t\t\t\tint last = map[can];\n\t\t\t\t\tcan = last - i;\n\t\t\t\t\tmin = Math.min(min, n - can);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tout.println(min);\n\t\tout.flush();\n\t}\n\n\tstatic class con {\n\t\tstatic int IINF = (int) 1e9;\n\t\tstatic int _IINF = (int) -1e9;\n\t\tstatic long LINF = (long) 1e15;\n\t\tstatic long _LINF = (long) -1e15;\n\t\tstatic double EPS = 1e-9;\n\t}\n\n\tstatic class Triple implements Comparable<Triple> {\n\t\tint x;\n\t\tint y;\n\n\t\tint z;\n\n\t\tTriple(int x, int y, int z) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Triple o) {\n\t\t\tif (x == o.x && y == o.y)\n\t\t\t\treturn z - o.z;\n\t\t\tif (x == o.x)\n\t\t\t\treturn y - o.y;\n\t\t\treturn x - o.x;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() { return \"(\" + x + \", \" + y + \", \" + z + \")\"; }\n\t}\n\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint x;\n\t\tint y;\n\n\t\tPair(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif (x == o.x)\n\t\t\t\treturn y - o.y;\n\t\t\treturn x - o.x;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\n\t\t\treturn \"(\" + x + \", \" + y + \")\";\n\t\t}\n\n\t}\n\n\tstatic void shuffle(int[] a) {\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tint r = i + (int) (Math.random() * (a.length - i));\n\t\t\tint tmp = a[r];\n\t\t\ta[r] = a[i];\n\t\t\ta[i] = tmp;\n\t\t}\n\t}\n\n\tstatic int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }\n\n\tstatic class DSU {\n\n\t\tint[] p, rank, setSize;\n\t\tint numSets;\n\n\t\tDSU(int n) {\n\t\t\tp = new int[n];\n\t\t\trank = new int[n];\n\t\t\tsetSize = new int[n];\n\t\t\tnumSets = n;\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tp[i] = i;\n\t\t\t\tsetSize[i] = 1;\n\t\t\t}\n\n\t\t}\n\n\t\tint findSet(int n) { return p[n] = p[n] == n ? n : findSet(p[n]); }\n\n\t\tboolean isSameSet(int n, int m) { return findSet(n) == findSet(m); }\n\n\t\tvoid mergeSet(int n, int m) {\n\n\t\t\tif (!isSameSet(n, m)) {\n\t\t\t\tnumSets--;\n\t\t\t\tint p1 = findSet(n);\n\t\t\t\tint p2 = findSet(m);\n\n\t\t\t\tif (rank[p1] > rank[p2]) {\n\t\t\t\t\tp[p2] = p1;\n\t\t\t\t\tsetSize[p1] += setSize[p2];\n\t\t\t\t} else {\n\t\t\t\t\tp[p1] = p2;\n\t\t\t\t\tsetSize[p2] += setSize[p1];\n\t\t\t\t\tif (rank[p1] == rank[p2])\n\t\t\t\t\t\trank[p1]++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tint size() { return numSets; }\n\n\t\tint setSize(int n) { return setSize[findSet(n)]; }\n\n\t}\n\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastReader() { br = new BufferedReader(new InputStreamReader(System.in)); }\n\n\t\tString next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreElements()) { st = new StringTokenizer(br.readLine()); }\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() throws NumberFormatException, IOException { return Integer.parseInt(next()); }\n\n\t\tlong nextLong() throws NumberFormatException, IOException { return Long.parseLong(next()); }\n\n\t\tdouble nextDouble() throws NumberFormatException, IOException { return Double.parseDouble(next()); }\n\n\t\tString nextLine() throws IOException {\n\t\t\tString str = \"\";\n\t\t\tstr = br.readLine();\n\t\t\treturn str;\n\t\t}\n\n\t\tboolean hasNext() throws IOException { return br.ready(); }\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint bitlen(int v) {\n  int ans = 0;\n  while (v) {\n    v >>= 1;\n    ans++;\n  }\n  return ans;\n}\nint main(void) {\n  ios::sync_with_stdio(false);\n  int n, mxsize;\n  cin >> n >> mxsize;\n  mxsize *= 8;\n  vector<int> nums(n);\n  for (int i = 0; i < n; i++) {\n    cin >> nums[i];\n  }\n  sort(nums.begin(), nums.end());\n  vector<int> datas(n);\n  for (int i = 1; i < n; i++) {\n    datas[i] = datas[i - 1] + (nums[i] != nums[i - 1]);\n  }\n  int ans = n - 1;\n  for (int pa = 0, pb = 0; pb < n; pb++) {\n    for (;;) {\n      int ncnt = datas[pb] - datas[pa] + 1;\n      int wlen = bitlen(ncnt - 1);\n      int len = n;\n      if (1ll * wlen * len <= mxsize) break;\n      pa++;\n    }\n    ans = min(ans, n - (pb - pa + 1));\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main\n{\n\tPrintWriter out = new PrintWriter(System.out);\n\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer tok = new StringTokenizer(\"\");\n    String next() throws IOException {\n        if (!tok.hasMoreTokens()) { tok = new StringTokenizer(in.readLine()); }\n        return tok.nextToken();\n    }\n    int ni() throws IOException { return Integer.parseInt(next()); }\n    long nl() throws IOException { return Long.parseLong(next()); }\n  \n    void solve() throws IOException {\n        int n=ni(),I=ni();\n        int[]A=new int[n+1];\n        HashSet<Integer>H=new HashSet();\n        for (int x=1;x<=n;x++) { A[x]=ni(); H.add(A[x]);}\n        Arrays.sort(A);\n        \n        int possbits = (I*8)/n;\n        if (possbits>30) {System.out.println(\"0\"); return;}\n        int possvalues=1<<possbits;\n        if (possvalues>=H.size()) {System.out.println(\"0\"); return;}\n        \n        int p=1;\n        int ans=0;\n        while (H.size()>possvalues) {\n            int q=A[p];\n            H.remove(q);\n            while (q==A[p]) {\n                ans++;\n                p++;\n            }\n        }\n        \n        int fin=ans;\n        p--;\n        int u=n;\n        while (p>0) {\n            int q=A[u];\n            while (q==A[u]) { ans++; u--; }\n            q=A[p];\n            while (q==A[p]) { ans--; p--; }\n            fin=Math.min(fin,ans);\n        }\n        \n        System.out.println(fin);\n    }\n    \n    public static void main(String[] args) throws IOException {\n        new Main().solve();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, d;\nint vet[400100], acc[400100];\nvector<pair<int, long long> > compress;\nint main() {\n  scanf(\"%d %d\", &n, &d);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &vet[i]);\n  }\n  vet[n] = -1;\n  sort(vet, vet + n);\n  int cont = 1;\n  for (int i = 1; i <= n; i++) {\n    if (vet[i] != vet[i - 1]) {\n      compress.push_back({vet[i - 1], cont});\n      cont = 0;\n    }\n    cont++;\n  }\n  acc[0] = 0;\n  int total = 0;\n  for (int i = 0; i < compress.size(); i++) {\n    acc[i + 1] = acc[i] + compress[i].second;\n    total += compress[i].second;\n  }\n  int distintos = compress.size();\n  d *= 8;\n  int k = d / n;\n  fprintf(stderr, \"%d\", k);\n  int ans = 1;\n  int mid, lo = 0, hi = distintos;\n  while (lo <= hi) {\n    mid = (lo + hi) / 2;\n    if (32 - __builtin_clz(mid) - (__builtin_popcount(mid) == 1) <= k) {\n      ans = mid;\n      lo = mid + 1;\n    } else {\n      hi = mid - 1;\n    }\n  }\n  int janela = ans;\n  fprintf(stderr, \"%d\", janela);\n  ans = 10000000;\n  for (int i = 0; i + janela - 1 < compress.size(); i++) {\n    fprintf(stderr, \"%d\", i);\n    fprintf(stderr, \"%d\", total - acc[i + janela] + acc[i]);\n    ans = min(ans, total - acc[i + janela] + acc[i]);\n  }\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\n // Author : Yash Shah\n\npublic class C implements Runnable {\n\n    public void run() {\n       \t\n        InputReader sc = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n=sc.nextInt();\n        int a[]=new int[n];\n        long tot=sc.nextLong()*8;\n        tot/=n;\n\n        TreeMap<Integer,Integer> map=new TreeMap<>();\n\n        for(int i=0;i<n;i++)\n        {\n            a[i]=sc.nextInt();\n            map.put(a[i],map.getOrDefault(a[i],0)+1);\n        } \n\n        long req=(long)Math.ceil(Math.log(map.size())/Math.log(2));\n        if(tot>=req)\n        {\n            out.println(0);\n            out.close();\n            return;\n        }\n        long ans=Long.MAX_VALUE;\n\n        tot=1L<<Math.min((int)tot,21);\n\n        ArrayList<Integer> ls1=new ArrayList<>();\n        ls1.add(0);\n        for(int i:map.keySet())\n        {\n            ls1.add(map.get(i)+ls1.get(ls1.size()-1));\n        }\n\n        for(int i=(int)tot;i<ls1.size();i++)\n        {\n            ans=Math.min(ans,n-(ls1.get(i)-ls1.get(i-(int)tot)));\n        }\n        \n        out.println(ans);\n        out.close();\n    }\n \n\n//========================================================================\n\n\t\n\tstatic void sa(int a[],InputReader sc)\n\t{\n\t\tfor(int i=0;i<a.length;i++)\n\t\t{\n\t\t\ta[i]=sc.nextInt();\n\t\t}\n        Arrays.sort(a);\n\t}\n\n\tstatic class pair<U extends Comparable<U>, V extends Comparable<V>> implements Comparable<pair<U, V>> {\n        public U x;\n        public V y;\n\n        public pair(U x, V y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public int compareTo(pair<U, V> other) {\n            int i = x.compareTo(other.x);\n            if (i != 0) return i;\n            return y.compareTo(other.y);\n        }\n\n        public String toString() {\n            return x.toString() + \" \" + y.toString();\n        }\n\n        public boolean equals(Object obj) {\n            if (this.getClass() != obj.getClass()) return false;\n            pair<U, V> other = (pair<U, V>) obj;\n            return x.equals(other.x) && y.equals(other.y);\n        }\n\n        public int hashCode() {\n            return 31 * x.hashCode() + y.hashCode();\n        }\n\n    }\n\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n \n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n       \n        public int read() {\n            if (numChars==-1)\n                throw new InputMismatchException();\n           \n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n               \n                if(numChars <= 0)              \n                    return -1;\n            }\n            return buf[curChar++];\n        }\n     \n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n           \n            while(isSpaceChar(c))\n                c = read();\n           \n            int sgn = 1;\n           \n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n           \n            int res = 0;\n            do {\n                if(c<'0'||c>'9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n           \n            return res * sgn;\n        }\n       \n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n           \n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n                return res * sgn;\n        }\n       \n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n       \n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            }\n            while (!isSpaceChar(c));\n           \n            return res.toString();\n        }\n     \n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n     \n        public String next() {\n            return readString();\n        }\n       \n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new C(),\"Main\",1<<27).start();\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, I, i, j, a, xb, ans, su;\nmap<int, int> mp;\npair<int, int> b[400005];\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> I;\n  I = min(30, I * 8 / n);\n  I = 1 << I;\n  for (i = 0; i < n; ++i) cin >> a, ++mp[a];\n  for (auto u : mp) b[++xb] = u;\n  ans = n;\n  for (i = j = 1, su = b[i].second; i <= xb;) {\n    for (; j < xb && j - i + 2 <= I; su += b[++j].second)\n      ;\n    ans = min(ans, n - su);\n    su -= b[i++].second;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MX = 400005;\nlong long n, I, a[MX];\nmap<int, int> mp;\nlong long my_log2(long long n) { return ceil(log2(n)); }\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> I;\n  I = I * 8;\n  for (long long i = 0; i < n; ++i) cin >> a[i];\n  sort(a, a + n);\n  long long i = 0, j = 0, result = n;\n  while (i < n) {\n    while (j < n) {\n      mp[a[j]]++;\n      ++j;\n      if (n * my_log2(mp.size()) > I) {\n        --j;\n        mp[a[j]]--;\n        if (!mp[a[j]]) mp.erase(a[j]);\n        break;\n      }\n    }\n    result = min(result, i + n - j);\n    mp[a[i]]--;\n    if (!mp[a[i]]) mp.erase(a[i]);\n    ++i;\n  }\n  cout << result << '\\n';\n}\n"
        },
        {
            "language": 3,
            "solution": "n, I = map(int, input().split())\nall_a = list(map(int, input().split()))\n\namounts_a = {}\n\nfor a in all_a:\n    if a in amounts_a.keys():\n        amounts_a[a] += 1\n    else:\n        amounts_a[a] = 1\n\nnums = list(amounts_a.keys())\nnums.sort()\n\nK = 2 ** min(20, (8 * I // n))\n\nif len(nums) <= K:\n    damaged = 0\nelse:\n    good = 0\n    for i in range(K):\n        good += amounts_a[nums[i]]\n    max_good = good\n    for i in range(K, len(nums)):\n        good += amounts_a[nums[i]] - amounts_a[nums[i - K]]\n        max_good = max(max_good, good)\n\n    damaged = n - max_good\n    \nprint(damaged)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing piii = pair<int, pii>;\nconst int inf = 1e9 + 7;\nint n, k, a[400005];\nmap<ll, ll> cnt;\nbool check(int x) {\n  int tm = log2(x);\n  if (x > (1 << tm)) tm++;\n  return (tm * n) <= (k * 8);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie();\n  cout.tie();\n  cin >> n >> k;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  sort(a + 1, a + n + 1);\n  int res = inf, diff = 0, j = 1;\n  for (int i = 1; i <= n; i++) {\n    if (!cnt[a[i]]) diff++;\n    cnt[a[i]]++;\n    while (!check(diff)) {\n      cnt[a[j]]--;\n      if (!cnt[a[j]]) diff--;\n      j++;\n    }\n    if (check(diff)) res = min(res, j - 1 + n - i);\n  }\n  cout << res;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[400003], s[400003];\nint sum1[400003], sum2[400003];\nint main() {\n  int n, i;\n  cin >> n >> i;\n  int k = i * 8 / n;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  sort(a + 1, a + n + 1);\n  int cnt = 0, loc = 0;\n  for (int i = 1; i <= n; i++) {\n    if (i == 1 || a[i] == a[i - 1])\n      cnt++;\n    else {\n      s[++loc] = cnt;\n      cnt = 1;\n    }\n    if (i == n) s[++loc] = cnt;\n  }\n  if (k > 20) {\n    cout << 0;\n    return 0;\n  }\n  k = (1 << k);\n  k = loc - k;\n  if (k <= 0) {\n    cout << 0;\n    return 0;\n  }\n  int l = 1, r = loc;\n  int ans = 1e9;\n  sum1[1] = s[1];\n  for (int i = 2; i <= loc; i++) sum1[i] = s[i] + sum1[i - 1];\n  sum2[1] = s[loc];\n  for (int i = loc - 1; i >= 1; i--) sum2[loc - i + 1] = s[i] + sum2[loc - i];\n  for (int i = 0; i <= loc; i++) {\n    if (k >= i) ans = min(ans, sum1[i] + sum2[k - i]);\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 1,
            "solution": "import collections\nimport math\n\n\n# def log(n):\n#     bits = 0\n#     while n > 0:\n#         bits += 1\n#         n >>= 1\n#     return bits\n#\n#\n# print log(1)\n# print math.log(1, 2)\n# for z in range(1, 2):\n#     if log(z) != int(math.ceil(math.log(z, 2))):\n#         print z\n\n\ndef fit(l, r, n, I, SS):\n    d = SS[r] - SS[l] + 1\n    return d <= I\n\n\ndef solve(I, arr):\n    I *= 8\n    n = len(arr)\n    I /= n\n    I = 2 ** I\n    arr = sorted(arr)\n    S = []\n    C = collections.defaultdict(int)\n    for a in arr:\n        if a not in C:\n            S.append(a)\n        C[a] += 1\n    pre = [0] * len(S)\n    prev = 0\n    SS = {}\n    for i in xrange(len(S)):\n        pre[i] = prev + C[S[i]]\n        prev = pre[i]\n        SS[S[i]] = i\n\n    def delete(l, r):\n        if SS[l] > 0:\n            return pre[SS[r]] - pre[SS[l] - 1]\n        return pre[SS[r]]\n\n    def bs(l):\n        start = l\n        end = len(S) - 1\n        while start < end:\n            mid = (start + end + 1) / 2\n            if fit(S[l], S[mid], len(arr), I, SS):\n                start = mid\n            else:\n                end = mid - 1\n\n        return len(arr) - delete(S[l], S[start])\n\n    res = len(arr)\n    for i in xrange(len(S)):\n        res = min(res, bs(i))\n    return res\n\n\n# print fit(4, 6, 2)\n# print fit(2, 6, 1)\n# arr = []\n# import random\n# for i in xrange(400000):\n#     arr.append(random.randint(1, 10000000))\n# print solve( 10000000, arr)\nimport sys\n\nn, I = map(int, raw_input().split(\" \"))\narr = map(int, sys.stdin.readline().split())\nprint solve(I, arr)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint i, i0, n, m, ans, a[400005];\nset<int> s;\nmap<int, int> mp;\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  m *= 8;\n  for (i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  sort(a + 1, a + 1 + n);\n  int ans = INT_MAX;\n  for (i = i0 = 1; i <= n; i++) {\n    mp[a[i]]++;\n    if (mp[a[i]] == 1) s.insert(a[i]);\n    while ((int)ceil(log2(s.size())) * n > m) {\n      mp[a[i0]]--;\n      if (mp[a[i0]] == 0) s.erase(a[i0]);\n      i0++;\n    }\n    ans = min(ans, n - i + i0 - 1);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int64_t max(int64_t a, int64_t b) { return (a > b) ? a : b; }\ninline int64_t min(int64_t a, int64_t b) { return (a < b) ? a : b; }\ninline int64_t max3(int64_t a, int64_t b, int64_t c) {\n  return max(a, max(b, c));\n}\ninline int64_t min3(int64_t a, int64_t b, int64_t c) {\n  return min(a, min(b, c));\n}\nint64_t gcd(int64_t a, int64_t b) { return (a % b == 0) ? b : gcd(b, a % b); }\nint64_t pow3(int64_t a, int64_t b, int64_t m = 1000000007) {\n  int64_t res = 1;\n  while (b > 0) {\n    if (b & 1) res = (res * a) % m;\n    a = (a * a) % m;\n    b >>= 1;\n  }\n  return res;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int t = 1;\n  while (t--) {\n    int n, ti;\n    cin >> n >> ti;\n    ti *= 8;\n    int temp = floor(ti * 1.0 / n);\n    int k = pow(2, min(temp, 20));\n    int64_t a[n];\n    for (int i = 0; i < n; i++) cin >> a[i];\n    sort(a, a + n);\n    vector<int> ct;\n    temp = 1;\n    for (int i = 1; i < n; i++)\n      if (a[i] == a[i - 1])\n        temp++;\n      else {\n        ct.push_back(temp);\n        temp = 1;\n      }\n    ct.push_back(temp);\n    if (k >= ct.size()) {\n      cout << 0 << endl;\n      return 0;\n    }\n    int64_t rem = 0;\n    temp = 0;\n    for (int i = 0; i < k; i++) temp += ct[i];\n    rem = temp;\n    for (int i = k; i < ct.size(); i++) {\n      temp += (ct[i] - ct[i - k]);\n      rem = max(rem, temp);\n    }\n    int64_t tot = 0;\n    for (int i = 0; i < ct.size(); i++) tot += ct[i];\n    cout << tot - rem;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException; \nimport java.io.InputStreamReader; \nimport java.util.Scanner; \nimport java.util.StringTokenizer; \nimport java.util.*;\nimport java.io.*;\npublic class codeforces \n{ \n   static class Student{\n       int x,y,z;\n        Student(int x,int y,int z){\n            this.x=x;\n            this.y=y;\n            this.z=z;\n        }\n    }\n    static int prime[];\n    static void sieveOfEratosthenes(int n) \n    { \n        // Create a boolean array \"prime[0..n]\" and initialize \n        // all entries it as true. A value in prime[i] will \n        // finally be false if i is Not a prime, else true. \n        int pos=0;\n        prime= new int[n+1]; \n        for(int p = 2; p*p <=n; p++) \n        { \n            // If prime[p] is not changed, then it is a prime \n            if(prime[p] == 0)\n            { \n                // Update all multiples of p\n                prime[p]=p;\n                for(int i = p*p; i <= n; i += p) \n                    prime[i] = p; \n            } \n        } \n    }\nstatic    class Sortbyroll implements Comparator<Student> \n{ \n    // Used for sorting in ascending order of \n    // roll number \n    public int compare(Student c, Student b) \n    { \n        return (b.y-b.z)-(c.y-c.z);\n    } \n} \nstatic class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n \n    static class Edge{\n        int a,b;\n        Edge(int a,int b){\n            this.a=a;\n            this.b=b;\n        }\n    }\n    static class Trie{\n        Trie z,o;\n       // int c;\n        Trie(){\n            z=null;\n            o=null;\n            //c=0;\n        }\n    }\n    //static long ans;\n    static int parent[];\n    static int rank[];\n    static int b[][];\n    static int bo[];\n    static int ho[];\n    static int seg[];\n    //static int pos;\n   // static long mod=1000000007;\n    //static int dp[][];\n    static HashMap<Integer,Integer>map;\n    static PriorityQueue<Student>q=new PriorityQueue<>();\n    //static Stack<Integer>st;\n   // static ArrayList<Character>ans;\n    static ArrayList<ArrayList<Integer>>adj;\n    //static int ans;\n    static Trie root;\n    static long fac[];\n    static long mod=(long)(998244353);\n    static void solve()throws IOException{\n        FastReader sc=new FastReader();\n        int n,m,i,r,sum,ans;\n        n=sc.nextInt();\n        m=sc.nextInt();\n        int a[]=new int[n];\n        for(i=0;i<n;i++)\n            a[i]=sc.nextInt();\n        TreeMap<Integer,Integer>map=new TreeMap<>();\n        for(i=0;i<n;i++){\n            if(map.containsKey(a[i]))\n                map.put(a[i],map.get(a[i])+1);\n            else\n                map.put(a[i],1);\n        }\n        ArrayList<Integer>ar=new ArrayList<>();\n        for(Integer k : map.keySet()){\n            ar.add(map.get(k));\n        }\n        r=(8*m)/n;\n        r=(int)Math.pow(2,r);\n        if(r>=map.size())\n            System.out.println(0);\n        else{\n            ans=0;\n            sum=0;\n            for(i=0;i<r-1;i++)\n                sum+=ar.get(i);\n            for(i=r-1;i<ar.size();i++){\n                sum+=ar.get(i);\n                ans=Math.max(ans,sum);\n                sum-=ar.get(i-r+1);\n            }\n            System.out.println(n-ans);\n        }\n    }\n    static int lower(int s,int e,int a[],int s1){\n        int ans=a[s];\n        int mid=(s+e)/2;\n        while(s<=e){\n            if(a[mid]<=s1){\n                ans=a[mid];\n                s=mid+1;\n            }\n            else\n                e=mid-1;\n            mid=(s+e)/2;\n        }\n        return ans;\n    }\n        static int upper(int s,int e,int a[],int s1){\n        int ans=a[e];\n        int mid=(s+e)/2;\n        while(s<=e){\n            if(a[mid]>=s1){\n                ans=a[mid];\n                e=mid-1;\n            }\n            else\n                s=mid+1;\n            mid=(s+e)/2;\n        }\n            return ans;\n    }\n    static void dfs(int c,int p,int s){\n        int y=0;\n        for(int i=0;i<adj.get(c).size();i++){\n            if(adj.get(c).get(i)==p)\n                continue;\n            dfs(adj.get(c).get(i),c,s+1);\n            ++y;\n        }\n        if(y==0){\n            //map.put(c,0);\n            //System.out.println(c+\" \"+s);\n            q.add(new Student(c,s,0));\n        }\n    }\n    static long nCr(long n, long r, \n                                    long p) \n    { \n        return (fac[(int)n]* modInverse(fac[(int)r], p) \n                % p * modInverse(fac[(int)(n-r)], p) \n                                    % p) % p; \n    } \n    public static void main(String[] args){\n        //long sum=0;\n        try {\n                codeforces.solve();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n    }\n       static long modInverse(long n, long p) \n    { \n        return power(n, p-(long)2, p); \n    } \n static long power(long x, long y, long p) \n{ \n    long res = 1;      // Initialize result \n  \n    x = x % p;  // Update x if it is more than or  \n                // equal to p \n  \n    while (y > 0) \n    { \n        // If y is odd, multiply x with result \n        if (y %(long)2!=0) \n            res = (res*x) % p; \n  \n        // y must be even now \n        y = y>>1; // y = y/2 \n        x = (x*x) % p;   \n    } \n    return res%p;\n }\n   static int find(int x) \n    { \n        // Finds the representative of the set \n        // that x is an element of \n        while(parent[x]!=x) \n        { \n            // if x is not the parent of itself \n            // Then x is not the representative of \n            // his set,\n            x=parent[x];\n  \n            // so we recursively call Find on its parent \n            // and move i's node directly under the \n            // representative of this set \n        } \n  \n        return x; \n    }\n    static void union(int x, int y) \n    { \n        // Find representatives of two sets \n        int xRoot = find(x), yRoot = find(y); \n  \n        // Elements are in the same set, no need \n        // to unite anything. \n        if (xRoot == yRoot) \n            return; \n  \n         // If x's rank is less than y's rank \n        if (rank[xRoot] < rank[yRoot]) \n  \n            // Then move x under y  so that depth \n            // of tree remains less \n            parent[xRoot] = yRoot; \n  \n        // Else if y's rank is less than x's rank \n        else if (rank[yRoot] < rank[xRoot]) \n  \n            // Then move y under x so that depth of \n            // tree remains less \n            parent[yRoot] = xRoot; \n  \n        else // if ranks are the same \n        { \n            // Then move y under x (doesn't matter \n            // which one goes where) \n            parent[yRoot] = xRoot; \n  \n            // And increment the the result tree's \n            // rank by 1 \n            rank[xRoot] = rank[xRoot] + 1; \n        } \n    } \n    static int gcd(int a, int b) \n    { \n        if (a == 0) \n            return b; \n        return gcd(b % a, a); \n    }\n}"
        },
        {
            "language": 3,
            "solution": "import math\n\n\nclass Read:\n    @staticmethod\n    def int():\n        return int(input())\n\n    @staticmethod\n    def list(sep=' '):\n        return input().split(sep)\n\n    @staticmethod\n    def list_int(sep=' '):\n        return list(map(int, input().split(sep)))\n\n\ndef solve():\n    n, i = Read.list_int()\n    a = Read.list_int()\n\n    maxK = 2 ** min(math.floor((i * 8) / n), 19)\n    a.sort()\n\n    d = {}\n    for i in a:\n        if i in d:\n            d[i] += 1\n        else:\n            d[i] = 1\n\n    d = list(d.values())\n    if maxK >= len(d):\n        print(0)\n        return\n\n    s_max = 0\n    for i in range(maxK):\n        s_max += d[i]\n\n    c_sum = s_max\n    start = 0\n\n    for i in range(maxK, len(d)):\n        c_sum = c_sum - d[i - maxK] + d[i]\n        if c_sum > s_max:\n            s_max = c_sum\n            start = i - maxK + 1\n\n    result = 0\n    for i in range(start, start + maxK):\n        result += d[i]\n\n    print(n - result)\n\n\nquery_count = 1  # Read.int()\nfor j in range(query_count):\n    solve()"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\t\n\t\tint n = in.nextInt();\n\t\tint sz = in.nextInt();\n\t\tsz *= 8;\n\t\tint[] a = new int[n];\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\ta[i] = in.nextInt();\n\t\t}\n\t\t\n\t\tArrays.sort(a);\n\t\tint k = sz / n;\n\t\tint values = (k < 30 ? (1 << k) : n);\n\t\tint ans = 0;\n\t\tint r = 0;\n\t\tint diff = 0;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\twhile(r < n)\n\t\t\t{\n\t\t\t\tif(r > i && a[r] == a[r - 1])\n\t\t\t\t{\n\t\t\t\t\tr++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(diff == values)\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdiff++;\n\t\t\t\t\tr++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tans = Math.max(ans, r - i);\n\t\t\tif(i < n - 1 && (i + 1 == r || a[i] != a[i + 1]))\n\t\t\t{\n\t\t\t\tdiff--;\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(n - ans);\n\t\t\n\t\tout.close();\n\t}\n\t\n\tstatic class InputReader\n\t{\n\t\tpublic BufferedReader reader;\n\t\tpublic StringTokenizer tokenizer;\n\t\t\n\t\tpublic InputReader(InputStream stream)\n\t\t{\n\t\t\treader = new BufferedReader(new InputStreamReader(stream), 32768);\n\t\t\ttokenizer = null;\n\t\t}\n\t\t\n\t\tpublic String next()\n\t\t{\n\t\t\twhile(tokenizer == null || !tokenizer.hasMoreTokens())\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t}\n\t\t\t\tcatch(IOException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt()\n\t\t{\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong()\n\t\t{\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  vector<int> a, firstPlace, distinct;\n  int x, n;\n  int space;\n  cin >> n >> space;\n  for (int i = 0; i < n; ++i) {\n    cin >> x;\n    a.push_back(x);\n  }\n  distinct.resize(n);\n  space *= 8;\n  int reqd = space / n;\n  if (reqd > 30 or n <= (1 << reqd)) {\n    cout << 0 << '\\n';\n    return 0;\n  }\n  int shouldBe = 1 << reqd;\n  sort(a.begin(), a.end());\n  distinct[0] = 1;\n  for (int i = 1; i < n; ++i) {\n    distinct[i] = distinct[i - 1];\n    if (a[i] != a[i - 1]) distinct[i]++;\n  }\n  int r = 0, maxi = 0;\n  for (int l = 0; l < n; ++l) {\n    int curr = distinct[r] - distinct[l] + 1;\n    while (r < n and curr <= shouldBe) {\n      r++;\n      curr = distinct[r] - distinct[l] + 1;\n    }\n    maxi = max(maxi, r - l);\n  }\n  cout << n - maxi << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.SortedSet;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.TreeSet;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\npublic class _1199C {\n\tpublic static void main(String[] args) {\n\t\tInputReader in = new InputReader();\n\t\tint n = in.nextInt();\n\t\tint I = in.nextInt();\n\t\tint k = I * 8 / n;\n\t\tint K = 1;\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tK *= 2;\n\t\t\tif (K > n) {\n\t\t\t\tSystem.out.println(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tHashMap<Integer, Integer> counts = new HashMap<Integer, Integer>();\n\t\tArrayList<Integer> sorted = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint curr = in.nextInt();\n\t\t\tint old = counts.getOrDefault(curr, 0);\n\t\t\tcounts.put(curr, old + 1);\n\t\t}\n\t\tIterator<Integer> iter = counts.keySet().iterator();\n\t\twhile (iter.hasNext()) {\n\t\t\tsorted.add(iter.next());\n\t\t}\n\t\tCollections.sort(sorted);\n\t\tif (sorted.size() < K) {\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\t\tint curSum = 0;\n\t\tint maxSum;\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tcurSum += counts.get(sorted.get(i));\n\t\t}\n\t\tmaxSum = curSum;\n\t\tfor (int i = K; i < sorted.size(); i++) {\n\t\t\tcurSum += counts.get(sorted.get(i));\n\t\t\tcurSum -= counts.get(sorted.get(i-K));\n\t\t\tif (curSum > maxSum) {\n\t\t\t\tmaxSum = curSum;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(n - maxSum);\n\t}\n\t\n\tstatic class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n \n        public InputReader() {\n            reader = new BufferedReader(new InputStreamReader(System.in));\n            tokenizer = null;\n        }\n \n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n \n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n \n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        \n        public double nextDouble() {\n        \treturn Double.parseDouble(next());\n        }\n        \n        public String nextLine() {\n        \tString str = \"\";\n        \ttry {\n        \t\tstr = reader.readLine();\n        \t} catch (IOException e) {\n        \t\te.printStackTrace();\n        \t}\n        \treturn str;\n        }\n    }\n}\n\n\n"
        },
        {
            "language": 3,
            "solution": "# ------------------- fast io --------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n \nBUFSIZE = 8192\n \nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n# ------------------- fast io --------------------\nimport math\nn,i=map(int,input().split())\nvals=sorted(map(int,input().split()))\nbits=8*i\ndist=[vals[0]];mult=[1]\nfor s in range(1,n):\n    if vals[s]==dist[-1]:\n        mult[-1]+=1\n    else:\n        dist.append(vals[s]);mult.append(1)\n#we need to find our K\nq=len(dist);k=1\nfor s in range(q,0,-1):\n    num=math.ceil(math.log2(s))*n\n    if num<=bits:\n        k=s\n        break\n#now just check all the contigous segments of length k and we're done\npref=[mult[0]]\nfor s in range(1,q):\n    pref.append(pref[-1]+mult[s])\nsuf=[mult[-1]]\nfor s in range(q-2,-1,-1):\n    suf.append(suf[-1]+mult[s])\nnums=q-k;ans=10**9\nfor s in range(nums+1):\n    left=s\n    right=nums-s\n    cv=0\n    if left>0:\n        cv+=pref[s-1]\n    if right>0:\n        cv+=suf[right-1]\n    ans=min(ans,cv)\nprint(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint main(void) {\n  long long n, bytes;\n  scanf(\"%lld %lld\", &n, &bytes);\n  long long max_distinct =\n      1 << std::min((long long)20, (long long)(8 * bytes) / n);\n  std::map<long long, long long> vals;\n  long long uniq = 0;\n  for (long long i = 0; i < n; ++i) {\n    long long tmp;\n    scanf(\"%lld\", &tmp);\n    if (vals.find(tmp) == vals.end()) {\n      vals[tmp] = 1;\n      uniq++;\n    } else\n      vals[tmp]++;\n  }\n  if (uniq <= max_distinct) {\n    puts(\"0\");\n    return 0;\n  }\n  std::vector<std::pair<long long, long long>> freq;\n  for (auto &x : vals) freq.push_back(std::make_pair(x.first, x.second));\n  std::vector<long long> left_sums(uniq);\n  long long cur_sum = 0;\n  for (long long i = 0; i < uniq; ++i) {\n    cur_sum += freq[i].second;\n    left_sums[i] = cur_sum;\n  }\n  long long ans = 1e10 + 2;\n  long long right_sum = 0;\n  for (long long i = uniq - 1; (uniq - i) <= (uniq - max_distinct); --i) {\n    right_sum += freq[i].second;\n    long long elim = uniq - i;\n    long long elim2 = (uniq - max_distinct) - elim;\n    long long ls = 0;\n    if (elim2 > 0) ls = left_sums[elim2 - 1];\n    long long tmp = ls + right_sum;\n    ans = std::min(tmp, ans);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n    public static void main(String[] args) throws IOException{\n        //Scanner f = new Scanner(new File(\"uva.in\"));\n        //Scanner f = new Scanner(System.in);\n        //BufferedReader f = new BufferedReader(new FileReader(\"uva.in\"));\n        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        StringTokenizer st = new StringTokenizer(f.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int I = Integer.parseInt(st.nextToken());\n        st = new StringTokenizer(f.readLine());\n        TreeMap<Integer, Integer> a = new TreeMap<>();\n        for(int i = 0; i < n; i++) {\n            int ai = Integer.parseInt(st.nextToken());\n            a.put(ai, a.getOrDefault(ai, 0)+1);\n        }\n        ArrayList<int[]> arr = new ArrayList<>();\n        for(int i: a.keySet()) {\n            arr.add(new int[]{i, a.get(i)});\n        }\n        int K = 1 << Math.min(20, 8*I/n);\n        if(K > arr.size()) {\n            out.println(0);\n        } else {\n            int in = 0;\n            for(int i = 0; i < K; i++) {\n                in += arr.get(i)[1];\n            }\n            int ans = in;\n            for(int i = K; i < arr.size(); i++) {\n                in += arr.get(i)[1];\n                in -= arr.get(i-K)[1];\n                ans = Math.max(ans, in);\n            }\n            out.println(n-ans);\n        }\n        f.close();\n        out.close();\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.Random;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author tarek\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        AMP3 solver = new AMP3();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class AMP3 {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            int bits = Math.min(25, in.readInt() * 8 / n);\n            int maxUnique = 1 << bits;\n            int[] a = new int[n];\n            for (int i = 0; i < n; ++i) a[i] = in.readInt();\n            Random random = new Random(5734153453315151L + System.currentTimeMillis());\n            for (int i = 0; i < n; ++i) {\n                int j = random.nextInt(i + 1);\n                int t = a[i];\n                a[i] = a[j];\n                a[j] = t;\n            }\n            Arrays.sort(a);\n            int[] uid = new int[n];\n            for (int i = 1; i < n; ++i) {\n                uid[i] = uid[i - 1];\n                if (a[i] > a[i - 1]) ++uid[i];\n            }\n            int left = 0;\n            int res = n;\n            for (int right = 0; right < n; ++right) {\n                while (left <= right && uid[right] - uid[left] + 1 > maxUnique) ++left;\n                res = Math.min(res, n - (right - left + 1));\n            }\n            out.printLine(res);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        String[] str = in.readLine().split(\"\\\\s+\");\n        int n= Integer.parseInt(str[0]);\n        int I= Integer.parseInt(str[1]);\n        int k=8*I/n;\n        long K;\n        int arr[]=new int[n+1];\n        int num[]=new int[n+1];\n        int cnt=0;\n        String[] str1 = in.readLine().split(\"\\\\s+\");\n        for(int i=1;i<=n;i++){\n            arr[n+1-i]= Integer.parseInt(str1[i-1]);\n        }\n        Arrays.sort(arr,1,n+1);\n        arr[0]=-1;\n        for(int i=1;i<=n;i++)\n            if(arr[i]!=arr[i-1])\n                num[++cnt]=i;\n        K=(int)(Math.log((double)(arr[n]-arr[1]))/Math.log(2.0));\n        if(K<k)\n            System.out.println(0);\n        else{\n            int ans=n;\n            for(int i=1;i<cnt;i++){\n                int c=i+(1<<k)-1;\n                if(c>cnt)\n                    break;\n                ans=Math.min(ans, n-num[c]+num[i-1]);\n            }\n            System.out.println(ans);\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n \n \npublic class Solution{\n \n\tpublic static Integer INT(String s){\n\t\treturn Integer.parseInt(s);\n\t}\n \n\tpublic static Long LONG(String s){\n\t\treturn Long.parseLong(s);\n\t}\n \n\t//====================================================================================================================\n \n \n \n \n\tpublic static void main(String args[])throws IOException{\n \n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\tScanner in=new Scanner(System.in);\tStringBuilder out=new StringBuilder();\n \t\t\n \t\tString line[]=br.readLine().split(\"\\\\s\");\n\t\tint n=INT(line[0]),\n\t\t\tI=INT(line[1]);\n \n\t\tTreeMap<Integer, Integer> map=new TreeMap<>();\n\t\tline=br.readLine().split(\"\\\\s\");\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint item=INT(line[i]);\n\t\t\tmap.put(item, map.getOrDefault(item, 0)+1);\n\t\t}\n \n\t\tint log2K=(I*8)/n;\n \n\t\tif(log2K>=31 || (1<<log2K)>=map.size()){\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n \n\t\tint K=(1<<log2K);\n \n\t\tQueue<Integer> q=new ArrayDeque<>();\n\t\tint count=0, min=Integer.MAX_VALUE;\n \n\t\tfor(Map.Entry<Integer,Integer> entry : map.entrySet()) {\n\n  \t\t\tint key = entry.getKey();\n  \t\t\tint value = entry.getValue();\n \n \t\t\tif(q.size()==K){\n \t\t\t\tint item=q.poll();\n \t\t\t\tcount-=map.get(item);\n \t\t\t}\n \n\t\t\tq.add(key);\n\t\t\tcount+=value;\n \n\t\t\tmin=Math.min(min, n-count);\n\t\t}\n \n\t\tSystem.out.println(min);\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "/*\n * @author derrick20\n * Key obvious errors slowing me down:\n * overflow of INT during the exponentiatioN!!!! A better thing would\n * be to note that the bounds can go huge. Use a max to watch out for it\n * (Math.pow happens to be safe >:( )\n * Watch out for the end point of for loops: the -1 stuff.\n * Only resort to DP if you know the greedy fails. In this problem,\n * the constraints made it so there was a fixed number of elements to remove\n * Therefore, you would just try each one and find the optimal one.\n * A suffix array is pointless. A prefix array achieves the same thing, just\n * use complementary counting to get suffix.\n * Do an ENTIRE test case thoroughly and systematically, as if you were the computer,\n * and try to notice a pattern.\n * The math of the ceiling was annoying, do it very rigorously to convince yourself before\n * coding.\n */\nimport java.io.*;\nimport java.util.*;\n\npublic class mp3 {\n    public static void main(String args[]) throws Exception {\n        FastScanner sc = new FastScanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int N = sc.nextInt();\n        int I = sc.nextInt(); // BYTES\n        ArrayList<Integer> arr = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            arr.add(sc.nextInt());\n        }\n//        coordinateCompress(arr);\n        Collections.sort(arr);\n        TreeSet<Integer> set = new TreeSet<>(arr);\n        int K = set.size();\n        int[] freqMap = new int[K];\n        for (int i = 0, id = 0; i < arr.size(); i++) {\n            if (i > 0 && !arr.get(i).equals(arr.get(i - 1))) {\n                id++; // this represents a distinct value, so we must go up\n            }\n            freqMap[id]++;\n        }\n        int[] prefix = new int[K + 1];\n        for (int i = 1; i <= K; i++) {\n            prefix[i] = prefix[i - 1] + freqMap[i - 1];\n        }\n//        System.out.println(Arrays.toString(freqMap));\n//        System.out.println(Arrays.toString(prefix));\n        int rangeSize = 1 << Math.min(20, (8 * I / N));\n        // Importantly, this floors it, which ensure the ceiling doesn't\n        // take us above the file memory limnit\n        int toRemove = K - rangeSize;\n        if (toRemove > 0) {\n            int changed = (int) 1e9; // the max possible just for starters\n            for (int i = 0; i <= toRemove; i++) {\n                // Hard to think about, but visualize the prefix sum of the first \"rangeSize\" # of items\n                // Then, there are still \"toRemove\" # of items left in the array that aren't added in\n                // If we shift over, then we take in rangeSize + i items, so we need to subtract out i items..\n                // We should do this until we go to ALL K items, then subtract the front bit.\n                int preserved = prefix[rangeSize + i] - prefix[i];\n                int tempChange = prefix[K] - preserved;\n                if (tempChange < changed) {\n                    changed = tempChange; // how much did we have to change\n                }\n            }\n            out.println(changed);\n        }\n        else {\n            out.println(0);\n        }\n        out.close();\n    }\n\n    static void coordinateCompress(ArrayList<Integer> arr) {\n        TreeSet<Integer> set = new TreeSet<>(arr);\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for (int v : set) {\n            map.put(v, map.size());\n        }\n        for (int i = 0; i < arr.size(); i++) {\n            arr.set(i, map.get(arr.get(i)));\n        }\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        FastScanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        FastScanner(FileReader s) {\n            br = new BufferedReader(s);\n        }\n\n        String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int mod = 1e9 + 7;\nvector<long long int> sum;\nlong long int bin_exp(long long int a, long long int b) {\n  a = a % mod;\n  long long int ans = 1;\n  while (b > 0) {\n    if (b & 1 == 1) ans = (a * ans) % mod;\n    a = (a * a) % mod;\n    b = b >> 1;\n  }\n  return ans;\n}\nvoid solve() {\n  long long int n, t;\n  cin >> n >> t;\n  t *= 8;\n  t /= n;\n  set<long long int> s;\n  vector<long long int> v(n);\n  map<long long int, long long int> m;\n  for (long long int i = 0; i < n; i++) {\n    cin >> v[i];\n    s.insert(v[i]);\n    m[v[i]] = 1;\n  }\n  long long int temp = s.size();\n  long long int p = 0;\n  while ((1LL << p) < temp) p++;\n  if (p <= t) {\n    cout << 0 << \"\\n\";\n    return;\n  }\n  t = bin_exp(2, t);\n  sum.resize(400002);\n  long long int ind = 1;\n  for (auto x : m) {\n    m[x.first] = ind;\n    ind++;\n  }\n  for (auto x : v) {\n    sum[m[x]]++;\n  }\n  long long int ans = 0;\n  for (long long int i = 1; i < 400002; i++) {\n    sum[i] += sum[i - 1];\n    if (i - t >= 0) {\n      ans = max(ans, sum[i] - sum[i - t]);\n    }\n  }\n  cout << n - ans << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long int t = 1;\n  for (long long int i = 0; i < t; i++) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class MP3 {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int diskSize = in.nextInt() * 8;\n        Integer[] sounds = new Integer[n];\n        for (int i = 0; i < n; i++) {\n            sounds[i] = in.nextInt();\n        }\n        Arrays.sort(sounds);\n        int[] distinctVals = new int[n];\n        int[] distinctAmt = new int[n];\n        int k = -1;\n        for (int i = 0; i < n; i++) {\n            if (i == 0 || sounds[i] > sounds[i - 1]) {\n                distinctVals[++k] = sounds[i];\n                distinctAmt[k] = 1;\n            } else {\n                distinctAmt[k]++;\n            }\n        }\n        k++;\n        /*for (int i = 0; i < k; i++) {\n            System.out.println(\"distinctVals[\" + i + \"] = \" + distinctVals[i]);\n            System.out.println(\"distinctAmts[\" + i + \"] = \" + distinctAmt[i]);\n        }*/\n        //System.out.println(\"k = \" + k);\n        int answer = n;\n        int currAmt = distinctAmt[0];\n        for (int i = 0, j = 0; i < k; currAmt -= distinctAmt[i], i++) {\n            while (j < i || (j < k - 1 && n * lg(j + 1 - i + 1) <= diskSize)) {\n                j++;\n                currAmt += distinctAmt[j];\n            }\n            //System.out.println(\"i = \" + i + \", j = \" + j + \", currAmt = \" + currAmt);\n            answer = Math.min(answer, n - currAmt);\n        }\n        System.out.println(answer);\n    }\n\n    static int lg(int n) {\n        int res = 0;\n        while (n > (1 << res)) {\n            res++;\n        }\n        return res;\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long n, mem;\n  cin >> n >> mem;\n  mem = mem * 8;\n  set<long long> s;\n  map<long long, long long> m;\n  long long* arr = new long long[n];\n  for (long long i = 0; i < n; ++i) {\n    cin >> arr[i];\n    ++m[arr[i]];\n    s.insert(arr[i]);\n  }\n  double dif = (double)s.size();\n  long long num = ceil(log2(dif));\n  if (num * n <= mem) {\n    cout << 0 << endl;\n    return 0;\n  }\n  long long ans = 0;\n  long long logval = mem / n;\n  long long difval = pow(2, logval);\n  vector<long long> v;\n  map<long long, long long>::iterator it = m.begin();\n  while (it != m.end()) {\n    v.push_back(it->second);\n    ++it;\n  }\n  long long tot = 0;\n  long long curwin = 0;\n  for (long long i = 0; i < v.size(); ++i) {\n    if (i < difval) {\n      curwin += v[i];\n    }\n    tot += v[i];\n  }\n  ans = tot - curwin;\n  for (long long i = 1; i < v.size(); ++i) {\n    if (i + difval - 1 >= v.size()) {\n      break;\n    }\n    curwin -= v[i - 1];\n    curwin += v[i + difval - 1];\n    ans = min(ans, tot - curwin);\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\nn,I = map(int,input().split())\na = list(map(int,input().split()))\na.sort()\nlast = -1\namount = []\nfor i in range (0,n):\n    if a[i] != last:\n        last = a[i]\n        amount.append(1)\n    else:\n        amount[-1] += 1\n\n\nk= math.ceil(math.log(len(amount),2))\n\nbest=0\nnow=0\n\nif n*k<= I*8:\n    print(0)\nelse:\n    K=  2**(8*I//n)\n\n    for i in range (0,len(amount)):\n        \n        now += amount[i]\n        if i >K-1:\n            now -= amount[i-K]\n        \n        if now>best:\n            best=now\n\n        \n    print(n-best)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 4e5 + 20;\nlong long a[maxn];\nlong long b[maxn];\nlong long qpow(int a, int b) {\n  long long ans = 1, de = a;\n  while (b != 0) {\n    if (b & 1) ans = ans * de;\n    b = b / 2;\n    de = de * de;\n  }\n  return ans;\n}\nint main() {\n  long long n, I, i;\n  cin >> n >> I;\n  long long k;\n  I = 8 * I / n;\n  if (I > 30) I = 30;\n  k = qpow(2, I);\n  for (i = 1; i <= n; i++) cin >> a[i];\n  sort(a + 1, a + n + 1);\n  a[0] = -1;\n  b[0] = 0;\n  for (i = 1; i <= n; i++) {\n    if (a[i] == a[i - 1]) {\n      b[i] = b[i - 1];\n    } else {\n      b[i] = b[i - 1] + 1;\n    }\n  }\n  if (k > b[n]) {\n    cout << 0 << endl;\n    return 0;\n  }\n  long long mn = n, l, r, ans;\n  for (l = 1, r = 1; r <= n; r++) {\n    ans = b[r];\n    if (ans < k) continue;\n    while (ans - b[l] >= k) ans = ans - b[l++];\n    if (ans == k) {\n      mn = min(mn, n - (r - l + 1));\n    }\n  }\n  cout << mn << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "\nn, m = map(int, input().split())\na = sorted(map(int, input().split()))\nb = [0]\na += [1 << 30]\nfor i in range(n):\n    if a[i] < a[i+1]:\n        b += [i+1]\nprint(n-max((y-x for x,y in zip(b,b[1<<8*m//n:])),default=n))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 500005;\nint raw[maxn], prefix[maxn];\nint main() {\n  int n, disk, ans = 0;\n  scanf(\"%d%d\", &n, &disk);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &raw[i]);\n  sort(raw + 1, raw + n + 1);\n  int point = 0;\n  raw[0] = -1;\n  for (int i = 1; i <= n; i++) {\n    if (raw[i] != raw[i - 1]) point++;\n    prefix[point]++;\n  }\n  if (disk * 8 / n >= 20) {\n    cout << 0;\n    return 0;\n  }\n  int siz_1 = 1 << (disk * 8 / n);\n  if (siz_1 >= point) {\n    cout << 0;\n    return 0;\n  }\n  for (int i = 1; i <= point; i++) prefix[i] += prefix[i - 1];\n  for (int i = 1; i <= point - siz_1 + 1; i++) {\n    int r = i + siz_1 - 1;\n    int tmp = prefix[r] - prefix[i - 1];\n    ans = max(ans, tmp);\n  }\n  ans = n - ans;\n  cout << ans;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys,math\nn,k=map(int,input().split())\nl=list(map(int,input().split()))\nse=set(l)\nd=dict()\nif 8*k>=n*math.ceil(math.log(len(se),2)):\n    ans=0\n    print(ans)\n    sys.exit()\nr=pow(2,(8*k)//n)\nfor i in range(len(l)):\n    if l[i] not in d:\n        d.update({l[i]:1})\n    else:\n        d[l[i]]+=1\nfreq=[]\nfor i in sorted(d):\n    freq.append(d[i])\ns=0\ne=len(freq)-1\nk=len(se)\nfor i in range(1,len(freq)):\n    freq[i]+=freq[i-1]\nans=999999999999999999\n#print(freq)\n#print(k,r)\nfreq=[0]+freq\n\nfor i in range(k-r+1):\n    rt=freq[i]+freq[-1]-freq[len(freq)-1+i-k+r]\n    #print(rt,freq[i])\n    ans=min(ans,rt)\nprint(ans)\n\n    \n"
        },
        {
            "language": 3,
            "solution": "n,I=map(int,input().split())\nI*=8\nI //= n\narr=list(map(int,input().split()))\narr.sort()\nsmen = [0]\ntyps = 1\nfor i in range(1,n):\n    if arr[i] != arr[i-1]:\n        typs+=1\n        smen.append(i)\nsmen.append(n)\ndeg = 1\nlg = 0\nwhile deg < typs:\n    lg += 1\n    deg *= 2\nif lg == 0 or I >= lg:\n    print(0)\nelse:\n    degi = 2 ** I\n    mon = typs - degi\n    ans = 400001\n    for x in range(mon+1):\n        now = smen[x] + n - smen[typs-mon+x]\n        if now<ans:\n            ans=now\n    print(ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 4e5 + 5;\nint n, I, k, a[N], b[N], B, t[N], ans;\nint main() {\n  scanf(\"%d%d\", &n, &I);\n  I <<= 3;\n  k = I / n;\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]), b[i] = a[i];\n  sort(b + 1, b + n + 1);\n  B = unique(b + 1, b + n + 1) - (b + 1);\n  if (k > 30 || (1 << k) >= B) return puts(\"0\"), 0;\n  for (int i = 1; i <= n; i++)\n    a[i] = lower_bound(b + 1, b + B + 1, a[i]) - b, t[a[i]]++;\n  k = 1 << k;\n  ans = n;\n  for (int i = 1; i <= B; i++) t[i] += t[i - 1];\n  for (int i = k; i <= B; i++) ans = min(ans, n - t[i] + t[i - k]);\n  return printf(\"%d\\n\", ans), 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long a[400000 + 100];\nlong long b[400000 + 100];\nint main() {\n  long long n, I;\n  scanf(\"%lld %lld\", &n, &I);\n  map<long long, long long> mp;\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", a + i);\n    mp[a[i]] += 1;\n  }\n  int i = 0;\n  for (auto p : mp) {\n    b[i++] = p.second;\n  }\n  long long N = n;\n  n = mp.size();\n  a[0] = b[0];\n  for (int i = 1; i < n; ++i) {\n    a[i] = b[i];\n    a[i] += a[i - 1];\n  }\n  int p = (I * 8) / N;\n  long long k = 1;\n  if (p >= 22) {\n    k = n;\n  } else\n    k = pow(2, p);\n  k = min(k, n);\n  long long res = 1e15;\n  for (int i = 0; i + k - 1 < n; ++i) {\n    long long res2 = 0;\n    if (i > 0) res2 += a[i - 1];\n    res2 += a[n - 1] - a[i + k - 1];\n    res = min(res, res2);\n  }\n  printf(\"%lld\", res);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable {\n  static ContestScanner in;\n  static Writer out;\n\n  public static void main(String[] args) {\n    new Thread(null, new Main(), \"\", 16 * 1024 * 1024).start();\n  }\n\n  public void run() {\n    Main main = new Main();\n    try {\n      in = new ContestScanner();\n      out = new Writer();\n      main.solve();\n      out.close();\n      in.close();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n\n  void solve() throws IOException {\n    int n = in.nextInt();\n    long bitLimit = in.nextLong() * 8;\n    long[] a = new long[n];\n    int l = 0;\n    for (int i = 0; i < n; i++) {\n      a[i] = in.nextLong();\n    }\n    Arrays.sort(a);\n    int uniques = 1;\n    int min = n - 1;\n    for (int i = 1; i < n; i++) {\n      if (a[i] != a[i - 1]) {\n        uniques++;\n      }\n      while (getBits(uniques) * n > bitLimit) {\n        if (a[l] != a[l + 1])\n          uniques--;\n        l++;\n      }\n      min = Math.min(min, n - (i - l + 1));\n    }\n    System.out.println(min);\n  }\n\n  long getBits(int u) {\n    return (long) Math.ceil(Math.log(u) / Math.log(2));\n  }\n}\n\nclass Writer extends PrintWriter {\n  public Writer(String filename) throws IOException {\n    super(new BufferedWriter(new FileWriter(filename)));\n  }\n\n  public Writer() throws IOException {\n    super(System.out);\n  }\n}\n\nclass ContestScanner implements Closeable {\n  private BufferedReader in;\n  private int c = -2;\n\n  public ContestScanner() throws IOException {\n    in = new BufferedReader(new InputStreamReader(System.in));\n  }\n\n  public ContestScanner(String filename) throws IOException {\n    in = new BufferedReader(new InputStreamReader(new FileInputStream(filename)));\n  }\n\n  public String nextToken() throws IOException {\n    StringBuilder sb = new StringBuilder();\n    while ((c = in.read()) != -1 && Character.isWhitespace(c))\n      ;\n    while (c != -1 && !Character.isWhitespace(c)) {\n      sb.append((char) c);\n      c = in.read();\n    }\n    return sb.toString();\n  }\n\n  public String readLine() throws IOException {\n    StringBuilder sb = new StringBuilder();\n    if (c == -2)\n      c = in.read();\n    while (c != -1 && c != '\\n' && c != '\\r') {\n      sb.append((char) c);\n      c = in.read();\n    }\n    return sb.toString();\n  }\n\n  public long nextLong() throws IOException, NumberFormatException {\n    return Long.parseLong(nextToken());\n  }\n\n  public int nextInt() throws NumberFormatException, IOException {\n    return (int) nextLong();\n  }\n\n  public double nextDouble() throws NumberFormatException, IOException {\n    return Double.parseDouble(nextToken());\n  }\n\n  public void close() throws IOException {\n    in.close();\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\t\n\tstatic class Scanner\n\t{\n\t    BufferedReader buf;\n\t    StringTokenizer tok;\n\t    Scanner()\n\t    {\n\t        buf = new BufferedReader(new InputStreamReader(System.in));\n\t    }\n\t    \n\t    boolean hasNext()\n\t    {\n\t        while(tok == null || !tok.hasMoreElements()) \n\t        {\n\t            try\n\t            {\n\t                tok = new StringTokenizer(buf.readLine());\n\t            } \n\t            catch(Exception e) \n\t            {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    \n\t    String next()\n\t    {\n\t        if(hasNext()) return tok.nextToken();\n\t        return null;\n\t    }\n\t    \n\t    int nextInt()\n\t    {\n\t        return Integer.parseInt(next());\n\t    }\n\t    \n\t    long nextLong()\n\t    {\n\t        return Long.parseLong(next());\n\t    }\n\t    \n\t    double nextDouble()\n\t    {\n\t        return Double.parseDouble(next());\n\t    }\n\t    \n\t}\n\t\n\tstatic int res = Integer.MAX_VALUE;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n = sc.nextInt(), I = sc.nextInt();\n\t\tint[] arr = new int[n];\n\t\tfor(int i = 0; i < n; i++) \n\t\t\tarr[i] = sc.nextInt();\n\t\tArrays.sort(arr);\n\t\tList<Integer> list = new ArrayList<>();\n\t\tint pre = arr[0], count = 1;\n\t\tfor(int i = 1; i < n; i++) {\n\t\t\tif(arr[i] == pre) count++;\n\t\t\telse {\n\t\t\t\tlist.add(count);\n\t\t\t\tcount = 1;\n\t\t\t\tpre = arr[i];\n\t\t\t}\n\t\t}\n\t\tlist.add(count);\n\t\tdouble comp = Math.ceil(Math.log(list.size())/Math.log(2))/8*n;\n\t\tif(comp < I) {\n\t\t\tout.println(0);\n\t\t\tout.close();\n\t\t\treturn;\n\t\t}\n\t\tint k = list.size();\n\t\tdouble cur = (double)I/(double)n * 8;\n\t\tint num = list.size()-(int)Math.pow(2, Math.floor(cur));\n\t\tif(num == list.size()) {\n\t\t\tout.println(n);\n\t\t\tout.close();\n\t\t\treturn;\n\t\t}\n\t\tint[] prefix = new int[list.size()];\n\t\tprefix[0] = list.get(0);\n\t\tfor(int i = 1; i < k; i++)\n\t\t\tprefix[i] = prefix[i-1]+list.get(i);\n\t\tfor(int i = k-num; i < k; i++)\n\t\t\tres = Math.min(res, prefix[k-1]-prefix[i-1]+(i == k-num ? 0 : prefix[i-k+num-1]));\n\t\tout.println(res);\n\t\tout.close();\n\t}\n\t\n    \n   \n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n, I;\n  cin >> n >> I;\n  I *= 8;\n  map<int, int> m;\n  for (int i = 0; i < n; ++i) {\n    int k;\n    cin >> k;\n    m[k]++;\n  }\n  int k = I / n;\n  int p = 0;\n  int mn = max(0, (int)m.size() - (1 << min(k, 30)));\n  vector<int> v;\n  for (auto x : m) {\n    v.push_back(x.second);\n  }\n  vector<int> lv(m.size() + 1, 0), rv(m.size() + 1, 0);\n  n = m.size();\n  for (int i = 0; i < n; ++i) {\n    lv[i + 1] = lv[i] + v[i];\n    rv[n - i - 1] = rv[n - i] + v[n - i - 1];\n  }\n  int ans = 1e9;\n  for (int i = 0; i < n; ++i) {\n    int j = min(n, i + n - mn);\n    ans = min(ans, lv[i] + rv[j]);\n  }\n  cout << ans << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing uint = unsigned;\nusing db = double;\nusing ld = long double;\nusing str = std::string;\nconstexpr int MAX32 = INT_MAX;\nconstexpr int MIN32 = INT_MIN;\nconstexpr i64 MAX64 = LLONG_MAX;\nconstexpr i64 MIN64 = LLONG_MIN;\nusing pi = std::pair<int, int>;\nusing p64 = std::pair<i64, i64>;\nusing pdb = std::pair<db, db>;\nusing vb = std::vector<bool>;\nusing vi = std::vector<int>;\nusing v64 = std::vector<i64>;\nusing vdb = std::vector<db>;\nusing vld = std::vector<ld>;\nusing vstr = std::vector<str>;\nusing vpi = std::vector<pi>;\nusing vp64 = std::vector<p64>;\nusing vpdb = std::vector<pdb>;\nusing vvi = std::vector<vi>;\nusing vv64 = std::vector<v64>;\nusing vvpi = std::vector<vpi>;\nusing vvp64 = std::vector<vp64>;\nusing vvb = std::vector<vb>;\ntemplate <class T, class Cmp = std::less<T>>\nusing maxheap = std::priority_queue<T, std::vector<T>, Cmp>;\ntemplate <class T>\nusing minheap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T>\nbool getBit(T mask, int b) {\n  return (mask >> b & T(1));\n}\ntemplate <class T>\nvoid setBit(T &mask, int b) {\n  mask |= (T(1) << b);\n}\ntemplate <class T>\nvoid delBit(T &mask, int b) {\n  mask &= ~(T(1) << b);\n}\ntemplate <class T>\nvoid flipBit(T &mask, int b) {\n  mask ^= (T(1) << b);\n}\ntemplate <class A, class B>\nstd::istream &operator>>(std::istream &is, std::pair<A, B> &p) {\n  return is >> p.first >> p.second;\n}\ntemplate <class T>\nstd::istream &operator>>(std::istream &is, std::vector<T> &v) {\n  int sz = v.size();\n  for (int i = 0; i < sz; i++) {\n    is >> v[i];\n  }\n  return is;\n}\nclass Reader {\n private:\n  bool _M_ok_ = true;\n\n public:\n  explicit operator bool() { return _M_ok_; }\n  template <typename T>\n  Reader &operator,(T &_t_) {\n    _M_ok_ &= !!(std::cin >> _t_);\n    return *this;\n  }\n};\ntemplate <class T>\nT reNxt() {\n  T _x_;\n  Reader(), _x_;\n  return _x_;\n}\ntemplate <class A, class B>\nstd::ostream &operator<<(std::ostream &os, const std::pair<A, B> &p) {\n  return os << p.first << ' ' << p.second;\n}\ntemplate <class T>\nstd::ostream &operator<<(std::ostream &os, const std::vector<T> &v) {\n  int sz = v.size();\n  for (int i = 0; i < sz - 1; i++) {\n    os << v[i] << ' ';\n  }\n  return os << v[sz - 1];\n}\ntemplate <char _sep_, char _end_>\nclass Writer {\n private:\n  bool _M_ok_ = true;\n  bool _space_;\n  void wrCh(char _c_) {\n    if (_c_) std::cout << _c_;\n  }\n\n public:\n  Writer() : _space_(false) {}\n  ~Writer() { wrCh(_end_); }\n  explicit operator bool() { return _M_ok_; }\n  template <typename T>\n  Writer &operator,(const T &_t_) {\n    (_space_) ? (wrCh(_sep_)) : (void(_space_ = true));\n    _M_ok_ &= !!(std::cout << _t_);\n    return *this;\n  }\n};\ntemplate <class C>\nconstexpr inline auto front(C &c) -> decltype(c.front()) {\n  return c.front();\n}\ntemplate <class C>\nconstexpr inline auto back(C &c) -> decltype(c.back()) {\n  return c.back();\n}\ntemplate <class C>\nconstexpr inline auto top(C &c) -> decltype(c.top()) {\n  return c.top();\n}\ntemplate <class C>\nconstexpr inline auto empty(C &c) -> decltype(c.empty()) {\n  return c.empty();\n}\ntemplate <class C>\nconstexpr inline auto data(C &c) -> decltype(c.data()) {\n  return c.data();\n}\ntemplate <class C>\ninline void clear(C &c) {\n  c.clear();\n}\ntemplate <class A, class B>\ninline bool chmin(A &t, const B &f) {\n  if (t > f) {\n    t = f;\n    return true;\n  }\n  return false;\n}\ntemplate <class A, class B>\ninline bool chmax(A &t, const B &f) {\n  if (t < f) {\n    t = f;\n    return true;\n  }\n  return false;\n}\ntemplate <class C>\ninline void remdup(C &x) {\n  sort(begin(x), end(x));\n  x.erase(unique(begin(x), end(x)), x.end());\n}\ntemplate <class C>\ninline i64 len(const C &x) {\n  return static_cast<i64>(x.size());\n}\ninline const str YN(bool cond) {\n  return static_cast<const str &>((reinterpret_cast<const char *>(\n      (&(const int &)(23438671621410638LL >> (cond << 5))))));\n}\ninline const str yn(bool cond) {\n  return static_cast<const str &>((reinterpret_cast<const char *>(\n      (&(const int &)(32481055248248654LL >> (cond << 5))))));\n}\ntemplate <typename I>\nstruct __ {\n  I &v_;\n  explicit __(I &v) : v_{v} {}\n  typename I::reverse_iterator begin() const { return v_.rbegin(); }\n  typename I::reverse_iterator end() const { return v_.rend(); }\n};\ntemplate <typename I>\n__<I> reversed(I &v) {\n  return __<I>(v);\n}\ntemplate <class I>\ninline I maxElem(I f, I l) {\n  return std::max_element(f, l);\n}\ntemplate <class I>\ninline I minElem(I f, I l) {\n  return std::min_element(f, l);\n}\nstd::mt19937_64 rng(\n    std::chrono::steady_clock::now().time_since_epoch().count());\ninline i64 randrange(i64 a, i64 b) {\n  return std::uniform_int_distribution<i64>(a, b)(rng);\n}\ntemplate <int D, class T>\nstruct dvec : public std::vector<dvec<D - 1, T>> {\n  static_assert(D >= 1, \"Vector dimension must be greater than zero!\");\n  template <class... Args>\n  dvec(int n, Args... args)\n      : std::vector<dvec<D - 1, T>>(n, dvec<D - 1, T>(args...)) {}\n};\ntemplate <class T>\nstruct dvec<1, T> : public std::vector<T> {\n  dvec(int n, const T &val = T()) : std::vector<T>(n, val) {}\n};\nconstexpr int dx[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconstexpr int dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\nvoid solveCase();\nvoid initialRun();\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  std::cout << std::setprecision(12) << std::fixed;\n  initialRun();\n  solveCase();\n  return 0;\n}\nconstexpr db EPS = 1e-9;\nconstexpr int INF = 1e9;\nconstexpr i64 INF64 = 1e18;\nconstexpr int N = 3e5 + 5;\nusing namespace std;\nvoid solveCase() {\n  int n, disk;\n  Reader(), n, disk;\n  vi a(n);\n  Reader(), a;\n  int k = 8 * disk / n;\n  int diff = (1 << min(k, 30)) - 1;\n  sort(begin(a), end(a));\n  vi temp = a;\n  remdup(temp);\n  for (auto &it : a) {\n    it = lower_bound(begin(temp), end(temp), it) - begin(temp);\n  }\n  int R = 0, best = 0;\n  for (int L = (0), _j_470 = ((len(a)) - 1); L <= _j_470; L += (1)) {\n    while (R + 1 < len(a) and a[R + 1] - a[L] <= diff) {\n      ++R;\n    }\n    chmax(best, R - L + 1);\n  }\n  Writer<' ', '\\n'>(), n - best;\n}\nvoid initialRun() {}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.util.function.Supplier;\nimport java.util.*;\n\npublic class Mp3 {\n    static Supplier<InputStream> inputSupplier = () -> System.in;\n    static Supplier<PrintWriter> outSupplier = () -> new PrintWriter(System.out);\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(inputSupplier.get()));\n        StringTokenizer tok = new StringTokenizer(in.readLine());\n        PrintWriter out = outSupplier.get();\n        int n = Integer.parseInt(tok.nextToken());\n        int nBytes = Integer.parseInt(tok.nextToken());\n        int nBits = nBytes*8;\n        int bitsPerSample = nBits/n;\n        int possibleDiffValues = (int)Math.pow(2, bitsPerSample);\n\n        Map.Entry<Integer, Integer>[] counts = getWordCounts(in, n);\n        Arrays.sort(counts, Comparator.comparingInt(e -> e.getKey()));\n        int result = 0;\n        if(possibleDiffValues<counts.length) {\n            result = n - getSubarrayMax(counts, possibleDiffValues);\n        }\n        out.println(result);\n        in.close();\n        out.close();\n    }\n\n    /* len = 1\n    0 1 2 3 4 5 6 7\n    1 2 3 3 4 3 2 1\n  p   *\n  q   *\n     */\n    private static int getSubarrayMax(Map.Entry<Integer, Integer>[] counts, int subarrayLen) {\n        int p = 0, q=0;\n        int n = counts.length;\n        int curr = 0;\n        while(q<subarrayLen && q < n) {\n            curr += counts[q++].getValue();\n        }\n        int max = curr;\n        q--;\n        while(q < n-1) {\n            curr += counts[++q].getValue();\n            curr -= counts[p++].getValue();\n            max = Math.max(max, curr);\n        }\n        return max;\n    }\n\n    private static Map.Entry<Integer, Integer>[] getWordCounts(BufferedReader in, int n) throws IOException {\n        StringTokenizer tok = new StringTokenizer(in.readLine());\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            int v = Integer.parseInt(tok.nextToken());\n            int cnt = map.getOrDefault(v, 0);\n            map.put(v, cnt+1);\n        }\n\n        Map.Entry<Integer, Integer>[] counts = new Map.Entry[map.size()];\n        int i = 0;\n        for (Map.Entry<Integer, Integer> c: map.entrySet()) {\n            counts[i++] = c;\n        }\n        return counts;\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst double PI = acos(-1);\ntemplate <class A, class B>\nstd::ostream& operator<<(std::ostream& st, const std::pair<A, B> p) {\n  st << \"(\" << p.first << \", \" << p.second << \")\";\n  return st;\n}\nusing namespace std;\nconst int MAX = 400 * 1000 + 10;\nint A[MAX], f[MAX], n, m, L;\nvoid compress() {\n  sort(A, A + n);\n  m = 0;\n  for (int i = 0; i < n;) {\n    int j = i;\n    while (j < n && A[i] == A[j]) j++;\n    A[m] = A[i];\n    f[m] = j - i;\n    m++;\n    i = j;\n  }\n}\nint pref[1 << 20];\nint main() {\n  scanf(\"%d %d\", &n, &L);\n  for (int i = 0; i < (n); i++) scanf(\"%d\", A + i);\n  compress();\n  int k = min((8 * L) / n, 20), ans = n;\n  int K = 1 << k;\n  for (int i = 0; i < (m); i++) pref[i] = f[i] + (i ? pref[i - 1] : 0);\n  for (int i = 0; i < m; i++) {\n    int S = pref[min(m, i + K) - 1] - (i ? pref[i - 1] : 0);\n    ans = min(ans, n - S);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class C {\n\n\tstatic FasterScanner sc = new FasterScanner();\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\n\tstatic void exit() {\n\t\tout.close();\n\t}\n\n\tpublic C () {\n\t\tint n = sc.nextInt(), I = sc.nextInt();\n\t\tint [] A = new int [n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tA[i] = sc.nextInt();\n\t\t}\n\t\tint space = 8 * I / n;\n\t\tif (Math.log(n)/Math.log(2) <= space) {\n\t\t\tout.println(0);\n\t\t\treturn;\n\t\t}\n\t\tspace = 1 << space;\n\n\t\tTreeMap<Integer, Integer> counts = new TreeMap<>();\n\t\tfor (int e : A) {\n\t\t\tcounts.put(e, counts.getOrDefault(e, 0)+1);\n\t\t}\n\t\tint num = counts.size();\n\t\tif (num <= space) {\n\t\t\tout.println(0);\n\t\t\treturn;\n\t\t}\n\t\tint [] values = new int [num];\n\t\tint i = 0;\n\t\tfor (int e : counts.keySet()) {\n\t\t\tvalues[i++] = e;\n\t\t}\n\t\tint l = 0, r = l + space - 1;\n\t\tint cnt = 0;\n\t\tfor (i = num-1; i > r; i--) cnt += counts.get(values[i]);\n\t\tint min_c = cnt;\n\t\tfor (l=1; r <= num-1; l++, r++) {\n\t\t\tr = l + space - 1;\n\t\t\tcnt = cnt - counts.get(values[r]) + counts.get(values[l-1]);\n\t\t\tif (min_c > cnt) min_c = cnt;\n\t\t}\n\t\t\n\t\t/*\n\t\tArrays.sort(A);\n\t\tint num = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i == 0 || A[i] != A[i-1]) num ++;\n\t\t}\n\t\tif (num <= space) {\n\t\t\tout.println(0);\n\t\t\treturn;\n\t\t}\n\t\tint [] values = new int [num];\n\t\tint [] counts = new int [num];\n\t\tvalues[0] = A[0];\n\t\tcounts[0] = 1;\n\t\tint j = 1;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (A[i] != values[j-1]) {\n\t\t\t\tvalues[j] = A[i];\n\t\t\t\tj++;\n\t\t\t\tcounts[j-1] = 1;\n\t\t\t} else {\n\t\t\t\tcounts[j-1]++;\n\t\t\t}\n\t\t}\n\t\tint l = 0;\n\t\tint r = l + space - 1;\n\t\tint cnt = 0;\n\t\tfor (int i = num-1; i > r; i--) cnt += counts[i];\n\t\tint min_c = cnt;\n\t\tfor (l=1; r <= num-1; l++, r++) {\n\t\t\tr = l + space - 1;\n\t\t\tcnt = cnt - counts[r] + counts[l-1];\n\t\t\tif (min_c > cnt) min_c = cnt;\n\t\t}\n\t\t*/\n\t\t/*\n\t\tlong [] psum1 = new long [num];\n\t\tlong [] psum2 = new long [num];\n\t\tpsum1[0] = counts[0];\n\t\tpsum2[num-1] = counts[num-1];\n\t\tfor (int i = 1; i < num; i++) {\n\t\t\tpsum1[i] = counts[i] + psum1[i-1];\n\t\t}\n\t\tfor (int i = num-2; i >= 0; i--) {\n\t\t\tpsum2[i] = counts[i] + psum2[i+1];\n\t\t}\n\t\tlong min_c = Long.MAX_VALUE;\n\t\tfor (int l = 0; l+space-1 < num; l++) {\n\t\t\tint r = (l + space - 1);\n\t\t\tlong changes = psum1[l] - counts[l] + psum2[r] - counts[r];\n\t\t\tif (min_c > changes) min_c = changes;\n\t\t}\n\t\t*/\n\t\tout.println(min_c);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew C();\n\t\texit();\n\t}\n\n\tstatic class FasterScanner {\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int snumChars;\n\n        public int read() {\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) {\n                curChar = 0;\n                try {\n                    snumChars = System.in.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        }\n\n        public String nextString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public int[] nextIntArray(int n, int f) {\n            if (f == 0) {\n                int[] arr = new int[n];\n                for (int i = 0; i < n; i++) {\n                    arr[i] = nextInt();\n                }\n                return arr;\n            } else {\n                int[] arr = new int[n + 1];\n                for (int i = 1; i < n + 1; i++) {\n                    arr[i] = nextInt();\n                }\n                return arr;\n            }\n        }\n\n        public long[] nextLongArray(int n, int f) {\n            if (f == 0) {\n                long[] arr = new long[n];\n                for (int i = 0; i < n; i++) {\n                    arr[i] = nextLong();\n                }\n                return arr;\n            } else {\n                long[] arr = new long[n + 1];\n                for (int i = 1; i < n + 1; i++) {\n                    arr[i] = nextLong();\n                }\n                return arr;\n            }\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        private boolean isEndOfLine(int c) {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int ar[];\n\tpublic static void main(String args[])\n\t{\n\t\tScanner scan=new Scanner(System.in);\n\t\tint n=scan.nextInt();\n\t\tint k=scan.nextInt();\n\t\tar=new int[n+1];\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tar[i]=scan.nextInt();\n\t\t}\n\t\tint wyn=n;\n\t\tk*=8;\n\t\tk=k/n;\n\t\tk=Math.min(k, 25);\n\t\tk=(1<<k);\n\t\tArrays.sort(ar);\n\t\tint zm[]=new int[n+1];\n\t\tfor(int i=2;i<=n;i++)\n\t\t{\n\t\t\tint gg=(ar[i]==ar[i-1])?0:1;\n\t\t\tzm[i]=(zm[i-1]+gg);\n\t\t}\n\t\tint w=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tw=Math.max(w, i);\n\t\t\twhile(w<n && (zm[w+1]-zm[i]+1)<=k)\n\t\t\t{\n\t\t\t\tw++;\n\t\t\t\t\n\t\t\t}\n\t\t\twyn=Math.min(wyn,n-(w-i+1));\n\t\t}\n\t\tSystem.out.println(wyn);\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\nn,k=map(int, input().split())\na=list(map(int, input().split()))\na.sort()\nt=math.floor((8*k)/n)\nK=1\np=2**t\n#for i in range(10**5):\n#  if K*2 > t:\n#    p=i\n #   break\n # K*=2\nb=[]\n#print(t,p)\ncnt=1\nfor i in range(n-1):\n  if a[i]!=a[i+1]:\n    b.append(cnt)\n    cnt=1\n  else:\n    cnt+=1\nif n>1:\n  if a[-1]==a[-2]:\n    b.append(cnt)\n  else:\n    b.append(1)\nif len(b)<=p:\n  print(0)\n  exit()\ns=0  \nfor i in range(p):\n  s+=b[i]\nc=[]\nc.append(n-s)\nfor i in range(p,len(b)):\n  s+=b[i]\n  s-=b[i-p]\n  c.append(n-s)\nprint(min(c))  \n\n\n\n\n "
        },
        {
            "language": 3,
            "solution": "def answer(n,x,A):\n    k=2**((x*8)//n)\n    A.sort()\n    l=0\n    r=0\n    d=set()\n    maxi=0\n    while r<n:\n        if len(d)<k:\n            d.add(A[r])\n            r+=1\n        elif len(d)==k:\n            if A[r] in d:\n                r+=1\n            else:\n                t=A[l]\n                while r>l and A[l]==t:\n                    l+=1\n                d.remove(t)\n                d.add(A[r])\n                r+=1\n        maxi=max(maxi,r-l)\n        \n    return n-maxi\n                \n                \n        \nn,x=map(int,input().split())\narr=list(map(int,input().split()))\nprint(answer(n,x,arr))"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n \npublic class CF1198A {\n    /*\n    Information we want: What is the max number of distince values we can have (Then, we can test all possible consercutive values)\n    \n    Information we have: 1. Max number of bytes 2. Total number of elements\n    Let the number of bits used per elem be k, k = log(# of distince colors). So, total bytes of an array is k*n.\n    If we can find what is k (cost per elem) is, then we can find what is the # of distinct number of elem (Since it is just 2^k).\n    We also know what is the total byte cap of a disk, let that be I. So 8*I = total bits, so 8*I/N is bit per element = k. \n    We can use a binary search because we want the max K without overshooting \n    */\n    static int ans;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader file = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(file.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int I = Integer.parseInt(st.nextToken());\n        int sk = (8*I)/n;\n        int max = (int) Math.pow(2, Math.min(sk, 20));\n        st = new StringTokenizer(file.readLine());\n        TreeMap<Integer, Integer> map = new TreeMap<>();\n        for (int i=0; i<n; i++){\n            int curr = Integer.parseInt(st.nextToken());\n            if (map.containsKey(curr)){\n                map.put(curr, map.get(curr)+1);\n            }else{\n                map.put(curr, 1);\n            }\n        }\n        int[][] arr = new int[map.size()][2];\n        int index = 0;\n        int sum = 0;\n        ans = Integer.MAX_VALUE;\n        for (int curr : map.keySet()){\n            arr[index] = new int[] {curr, map.get(curr)};\n            sum += arr[index][1];\n            index++;\n        }\n        int total = 0;\n        for (int i=0; i<arr.length; i++){\n            total += arr[i][1];\n            if (i >= max){\n                total -= arr[i-max][1];\n            }\n            ans = Math.min(sum-total, ans);\n        }\n        System.out.println(ans);\n    }\n}"
        },
        {
            "language": 3,
            "solution": "dic = {}\nnum = 0\na = [0]\nsum1 = [0]\nsum2 = [0]\n\n\ndef quickM(d):\n    ans = 1\n    base = 2\n    while d > 0:\n        if d & 1:\n            ans *= base\n        base *= base\n        d >>= 1\n    return ans\n\n\nif __name__ == '__main__':\n    n, I = list(map(lambda x: int(x), input().split(' ')))\n    aa = input().split(' ')\n    for i in range(n):\n        aa[i] = int(aa[i])\n    aa.sort()\n    num = 1\n    a.append(1)\n    for i in range(1, n):\n        if aa[i] == aa[i-1]:\n            a[num] += 1\n        else:\n            num += 1\n            a.append(1)\n    for i in range(1, num+1):\n        sum1.append(sum1[i-1] + a[i])\n        sum2.append(sum2[i-1] + a[num-i+1])\n    K = num\n    k = I*8 // n\n    if k > 30:\n        k = 30\n    cnt = K - quickM(k)\n    if cnt < 0:\n        print(0)\n    else:\n        ans = n - 1\n        for i in range(cnt+1):\n            ans = min(ans, sum1[i] + sum2[cnt-i])\n            ans = min(ans, sum2[i] + sum1[cnt-i])\n        print(ans)\n\n \t \t\t  \t \t  \t\t \t   \t\t \t\t \t \t\t"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing ii = pair<int, int>;\nconst int MAX = 4e5 + 10;\nint a[MAX];\nvector<int> v;\nint n, I;\nint possible(int q) {\n  int k = 0;\n  int r = 1;\n  while (r < q) {\n    r *= 2;\n    k++;\n  }\n  if (n * k <= 8 * I) return 1;\n  return 0;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> I;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  sort(a, a + n);\n  int count = 1;\n  for (int i = 0; i < n; i++) {\n    if (i == n - 1 || a[i] != a[i + 1]) {\n      v.push_back(count);\n      count = 1;\n    } else\n      count++;\n  }\n  int len = v.size();\n  int high = len;\n  int low = 1;\n  if (possible(len)) {\n    cout << \"0\" << endl;\n    return 0;\n  }\n  while (possible(low + 1)) {\n    int cen = (high + low + 1) / 2;\n    if (possible(cen))\n      low = cen;\n    else\n      high = cen;\n  }\n  int l = len - low;\n  int r = len;\n  int sum = 0;\n  for (int i = 0; i < l; i++) {\n    sum += v[i];\n  }\n  int res = sum;\n  int q = l;\n  for (int i = 0; i < q; i++) {\n    l--;\n    r--;\n    sum -= v[l];\n    sum += v[r];\n    res = min(res, sum);\n  }\n  cout << res << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\npublic class TestClass{\n\tpublic static void main(String args[])\n\t{\n\t    Scanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint I = in.nextInt();\n\t\tint arr[] = new int[n+1];\n\t\tfor(int i =0;i<n;i++)\n\t\t arr[i+1]= in.nextInt();\n\t\t\n\t\t\n\t\tArrays.sort(arr);\n\t\t\n\t\tint count[] = new int[n+1];\n\t\tint map[] = new int[n+1];\n\t\tint last[] = new int[n+1];\n\t\tlast[1]=1;\n\t\tcount[1]=1;\n        map[1]=1;\n        for(int i =2;i<=n;i++)\n        {\n        \tif(arr[i]!=arr[i-1])\n        \t{\n             count[i]=count[i-1]+1;\t\t\n        \t map[count[i]] =i;\t\n        \t last[count[i]]=i;\n        \t}\n        \telse{\n        \t\tcount[i]=count[i-1];\n        \t\tlast[count[i]]=i;\n        \t}\n\n        }\n        int distinct = count[n];\n        distinct =(int) Math.ceil(((double)Math.log(distinct)/Math.log(2)));\n        distinct = n*distinct;\n        I=I*8;\n        if(distinct<=I){\n        \tSystem.out.println(0);\n        }\n        else\n        {\n        \tint max=0;\n        \tint range =I/n;\n        \trange = (int)Math.pow(2,range);\n        \t\n        \tfor(int i=1;i<=count[n]-range+1;i++)\n        \t{\n                 int val = last[i+range-1]- map[i]+1;\n                 \n                 max = Math.max(max,val);\n                       \t\t\n        \t}\n        \tn =n-max;\n        \tSystem.out.println(n);\n        }\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int n, I;\n  cin >> n >> I;\n  int k = min(20, 8 * I / n);\n  vector<int> a(n);\n  for (auto& i : a) {\n    cin >> i;\n  }\n  sort(a.begin(), a.end());\n  vector<int> pre_sum = {0};\n  for (int i = 0, j; i < n; i = j) {\n    j = i;\n    while (j < n && a[j] == a[i]) {\n      ++j;\n    }\n    pre_sum.push_back(j - i);\n  }\n  for (int i = 1; i < int(pre_sum.size()); ++i) {\n    pre_sum[i] += pre_sum[i - 1];\n  }\n  int ans = n;\n  for (int j = 0; j < int(pre_sum.size()); ++j) {\n    int cnt = pre_sum[min(j + (1 << k), int(pre_sum.size()) - 1)] - pre_sum[j];\n    ans = min(ans, n - cnt);\n  }\n  cout << ans << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  int n, s;\n  cin >> n >> s;\n  int k = s * 8 / n;\n  if (k > 30) {\n    cout << 0;\n    return 0;\n  }\n  k = 1 << k;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  sort(a.begin(), a.end());\n  vector<int> b(n);\n  for (int i = 1; i < n; i++) {\n    if (a[i] == a[i - 1]) {\n      b[i] = b[i - 1];\n    } else {\n      b[i] = b[i - 1] + 1;\n    }\n  }\n  int j = 0;\n  int res = 0;\n  for (int i = 0; i < n; i++) {\n    while (j < n && b[j] < b[i] + k) {\n      j++;\n    }\n    res = max(res, j - i);\n  }\n  cout << n - res;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class MP3 {\n    PrintWriter out;\n    StringTokenizer st;\n    BufferedReader br;\n    final int imax = Integer.MAX_VALUE, imin = Integer.MIN_VALUE;\n    final int mod = 1000000007;\n\n    void solve() throws Exception {\n        int t = 1;\n//        t = ni();\n        for (int ii = 0; ii < t; ii++) {\n            int n = ni(), I = ni();\n            int[] a = ni(n);\n\n            Map<Integer, Integer> map = new HashMap<>();\n            for (int i : a) map.put(i, map.getOrDefault(i, 0) + 1);\n            List<Integer> keys = new ArrayList<>(map.keySet()); Collections.sort(keys);\n\n            int k = I * 8 / n, _k= (int)Math.ceil(Math.log(keys.size()*1d)/Math.log(2d));\n            if(k>= _k) { out.println(0); return; }\n\n            long distinct = binExp(2l, k);\n            long[] suffix = new long[keys.size()+1];\n            for (int i = suffix.length-2;i>=0; i--)\n                suffix[i] = map.get(keys.get(i)) + suffix[i + 1];\n\n            int delete= keys.size()- (int)distinct;\n            long ans = suffix[suffix.length-1- delete], sum= 0l;\n            for (int i = 0; i < delete; i++) {\n                sum+= map.get(keys.get(i));\n                ans= Math.min(ans, sum+ suffix[suffix.length- delete+ i]);\n            }\n            out.println(ans);\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        new MP3().run();\n    }\n\n    void run() throws Exception {\n        if (System.getProperty(\"ONLINE_JUDGE\") == null) {\n            File file = new File(\"C:\\\\college\\\\CodeForces\\\\inputf.txt\");\n            br = new BufferedReader(new FileReader(file));\n            out = new PrintWriter(\"C:\\\\college\\\\CodeForces\\\\outputf.txt\");\n        } else {\n            out = new PrintWriter(System.out);\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        long ss = System.currentTimeMillis();\n        st = new StringTokenizer(\"\");\n        while (true) {\n            solve();\n            String s = br.readLine();\n            if (s == null) break;\n            else st = new StringTokenizer(s);\n        }\n        //out.println(System.currentTimeMillis()-ss+\"ms\");\n        out.flush();\n    }\n\n    void read() throws Exception {\n        st = new StringTokenizer(br.readLine());\n    }\n\n    int ni() throws Exception {\n        if (!st.hasMoreTokens()) read();\n        return Integer.parseInt(st.nextToken());\n    }\n\n    char nc() throws Exception {\n        if (!st.hasMoreTokens()) read();\n        return st.nextToken().charAt(0);\n    }\n\n    String nw() throws Exception {\n        if (!st.hasMoreTokens()) read();\n        return st.nextToken();\n    }\n\n    long nl() throws Exception {\n        if (!st.hasMoreTokens()) read();\n        return Long.parseLong(st.nextToken());\n    }\n\n    int[] ni(int n) throws Exception {\n        int[] ret = new int[n];\n        for (int i = 0; i < n; i++) ret[i] = ni();\n        return ret;\n    }\n\n    long[] nl(int n) throws Exception {\n        long[] ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = nl();\n        return ret;\n    }\n\n    double nd() throws Exception {\n        if (!st.hasMoreTokens()) read();\n        return Double.parseDouble(st.nextToken());\n    }\n\n    String ns() throws Exception {\n        String s = br.readLine();\n        return s.length() == 0 ? br.readLine() : s;\n    }\n\n    void print(int[] arr) {\n        for (int i : arr) out.print(i + \" \");\n        out.println();\n    }\n\n    void print(long[] arr) {\n        for (long i : arr) out.print(i + \" \");\n        out.println();\n    }\n\n    void print(int[][] arr) {\n        for (int[] i : arr) {\n            for (int j : i) out.print(j + \" \");\n            out.println();\n        }\n    }\n\n    void print(long[][] arr) {\n        for (long[] i : arr) {\n            for (long j : i) out.print(j + \" \");\n            out.println();\n        }\n    }\n\n    long add(long a, long b) {\n        if (a + b >= mod) return (a + b) - mod;\n        else return a + b >= 0 ? a + b : a + b + mod;\n    }\n\n    long mul(long a, long b) {\n        return (a * b) % mod;\n    }\n\n    void print(boolean b) {\n        if (b) out.println(\"YES\");\n        else out.println(\"NO\");\n    }\n\n    long binExp(long base, long power) {\n        long res = 1l;\n        while (power != 0) {\n            if ((power & 1) == 1) res = mul(res, base);\n            base = mul(base, base);\n            power >>= 1;\n        }\n        return res;\n    }\n\n    long gcd(long a, long b) {\n        if (b == 0) return a;\n        else return gcd(b, a % b);\n    }\n\n    // strictly smaller on left\n    void stack_l(int[] arr, int[] left) {\n        Stack<Integer> stack = new Stack<>();\n        for (int i = 0; i < arr.length; i++) {\n            while (!stack.isEmpty() && arr[stack.peek()] >= arr[i]) stack.pop();\n            if (stack.isEmpty()) left[i] = -1;\n            else left[i] = stack.peek();\n            stack.push(i);\n        }\n    }\n\n    // strictly smaller on right\n    void stack_r(int[] arr, int[] right) {\n        Stack<Integer> stack = new Stack<>();\n        for (int i = arr.length - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && arr[stack.peek()] >= arr[i]) stack.pop();\n            if (stack.isEmpty()) right[i] = arr.length;\n            else right[i] = stack.peek();\n            stack.push(i);\n        }\n    }\n\n    private void sort(int[] arr) {\n        List<Integer> list = new ArrayList<>();\n        for (int i : arr) list.add(i);\n        Collections.sort(list);\n        for (int i = 0; i < arr.length; i++) arr[i] = list.get(i);\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.InputStreamReader;\nimport java.util.TreeMap;\n\npublic class A1198 {\n\n\tpublic static void main(String[] args) throws Exception {\n//\t\tBufferedReader br = new BufferedReader(new FileReader(\"F:/books/input.txt\"));\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] s1 = br.readLine().split(\" \");\n\t\tInteger n = Integer.parseInt(s1[0]);\n\t\tLong I = Long.parseLong(s1[1]);\n\t\tString[] s2 = br.readLine().split(\" \");\n\t\tI *= 8;\n\t\tTreeMap<Long,Integer> mp = new TreeMap<Long,Integer>();\n\t\tfor (int i = 0; i < s2.length; i++) {\n\t\t\tLong v = Long.parseLong(s2[i]);\n\t\t\tInteger w = mp.get(v);\n\t\t\tw = (w==null)?1:w+1;\n\t\t\tmp.put(v, w);\n\t\t}\n\t\tlong r = I/n;\n\t\tlong[] a = fill2pow();\n\t\tr = (r<20)?a[(int)r]:Long.MAX_VALUE;\n\t\tlong c = mp.size();\n\t\tlong[] cum = new long[mp.size()];\n\t\tint ptr = 0;\n\t\tfor(Integer v1 : mp.values()) {\n\t\t\tcum[ptr++] = v1;\n\t\t}\n\t\tint L = cum.length;\n\t\tfor(int i=1;i<L;i++) cum[i] += cum[i-1];\n\t\tlong ret = Long.MAX_VALUE;\n\t\tc = c-r;\n\t\tif(c<=0) System.out.println(\"0\");\n\t\telse\n\t\tif(c>=L) System.out.println((L-1));\n\t\telse {\n\t\t\tfor(int i=(int) c-1;i>=0;i--) {\n\t\t\t\tlong v1 = cum[i];\n\t\t\t\tv1 += cum[L-1];\n\t\t\t\tv1 -= cum[(int) (L-1-(c-1-i))];\n\t\t\t\tret = Math.min(ret, v1);\n\t\t\t}\n\t\tSystem.out.println(ret);\n\t\t}\n\t}\n\n\tprivate static long[] fill2pow() {\n\t\tlong[] ret = new long[20];\n\t\tret[0] = 1;\n\t\tfor(int i=1;i<20;i++) ret[i] = 2*ret[i-1];\n\t\treturn ret;\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmap<int, int> occurrences;\nint leftResults[400001];\nint rightResults[400001];\nint main() {\n  int n, i;\n  cin >> n >> i;\n  i *= 8;\n  i /= n;\n  int pow = 1;\n  for (int u = 0; u < i; u++) {\n    pow *= 2;\n    if (pow >= n) {\n      cout << 0 << endl;\n      return 0;\n    }\n  }\n  for (int u = 0; u < n; u++) {\n    int a;\n    cin >> a;\n    if (occurrences.find(a) == occurrences.end()) {\n      occurrences[a] = 0;\n    }\n    occurrences[a]++;\n  }\n  if (pow >= occurrences.size()) {\n    cout << 0 << endl;\n    return 0;\n  }\n  leftResults[0] = 0;\n  rightResults[0] = 0;\n  int idx = 1;\n  for (auto it = occurrences.begin(); it != occurrences.end(); it++) {\n    if (idx == 1) {\n      leftResults[idx] = it->second;\n    } else {\n      leftResults[idx] = leftResults[idx - 1] + it->second;\n    }\n    idx++;\n  }\n  idx = 1;\n  auto it = occurrences.end();\n  it--;\n  for (;; it--) {\n    if (idx == 1) {\n      rightResults[idx] = it->second;\n    } else {\n      rightResults[idx] = rightResults[idx - 1] + it->second;\n    }\n    idx++;\n    if (it == occurrences.begin()) {\n      break;\n    }\n  }\n  int diff = occurrences.size() - pow;\n  int result = 1e9;\n  for (int i = 0; i < diff; i++) {\n    result = min(result, leftResults[i] + rightResults[diff - i]);\n  }\n  cout << result << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, by, a[400010], k = 0, K = 1, S[400010], ans;\nvector<long long> V;\nint main() {\n  scanf(\"%lld%lld\", &n, &by);\n  by *= 8;\n  for (int i = 1; i <= n; i++) scanf(\"%lld\", a + i), V.push_back(a[i]);\n  by /= n;\n  while (k + 1 <= by) {\n    k++;\n    K *= 2;\n    if (K >= n) break;\n  }\n  sort(V.begin(), V.end());\n  V.erase(unique(V.begin(), V.end()), V.end());\n  for (int i = 1; i <= n; i++)\n    a[i] = lower_bound(V.begin(), V.end(), a[i]) - V.begin() + 1;\n  for (int i = 1; i <= n; i++) S[a[i]]++;\n  for (int i = 1; i <= n; i++) S[i] += S[i - 1];\n  ans = n;\n  for (int i = 1; i <= n; i++)\n    ans = min(ans, n - S[min(n, i + K - 1)] + S[i - 1]);\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, I, K = 0;\n  cin >> n >> I;\n  vector<int> a(n);\n  map<int, int> mp;\n  vector<int> value, sum;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    if (mp.find(a[i]) == mp.end())\n      mp[a[i]] = 1, value.push_back(a[i]), K++;\n    else\n      mp[a[i]]++;\n  }\n  sort(value.begin(), value.end());\n  sum = vector<int>(K);\n  for (int i = 0; i < K; i++) {\n    sum[i] = mp[value[i]];\n    if (i) sum[i] += sum[i - 1];\n  }\n  int k = I * 8 / n;\n  int tobe = 1;\n  while (k--) {\n    tobe *= 2;\n    if (tobe >= K) {\n      cout << 0;\n      return 0;\n    }\n  }\n  int ans = 1000000000;\n  for (int i = 0; i < K - tobe; i++) {\n    ans = min(sum[K - 1] - (sum[i + tobe] - sum[i]), ans);\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, m;\nlong long a[400005];\npair<long long, long long> b[400005];\nint sz;\nint main(int argc, const char* argv[]) {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  m *= 8;\n  m /= n;\n  if (m > 35)\n    m = (1ll << 32ll);\n  else\n    m = (1ll << m);\n  for (int i = 1; i <= n; ++i) {\n    cin >> a[i];\n  }\n  sort(a + 1, a + n + 1);\n  for (int i = 1; i <= n; ++i)\n    if (i == 1 || a[i] != a[i - 1])\n      b[++sz] = {a[i], 1};\n    else\n      b[sz].second++;\n  n = sz;\n  for (int i = 1; i <= n; ++i) b[i].second += b[i - 1].second;\n  long long ans = 1e18, cur;\n  for (int i = 1; i <= n; ++i) {\n    cur = b[i - 1].second;\n    if (i + m - 1 <= n) cur += b[n].second - b[i + m - 1].second;\n    ans = min(ans, cur);\n  }\n  cout << ans << '\\n';\n}\n"
        },
        {
            "language": 3,
            "solution": "from math import log, floor\nn,I = map(int, input().split())\na = [int(s) for s in input().split()]\nb = []\na.sort()\nb.append([-1, 0])\nfor i in range(0, n):\n    if a[i] == b[-1][0]:\n        b[-1][1] += 1\n    else:\n        b.append([a[i], b[-1][1]+1])\nmaxk = I*8//n\nmaxK = 1<<maxk\n# print(maxk, maxK)\nans = n\n# print(b)\nif len(b)-1 < maxK:\n    ans = 0\nelse:\n    for i in range(len(b)-maxK):\n        chg = n-(b[i+maxK][1]-b[i][1])\n        if chg < ans:\n            ans = chg\nprint(ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, I, k, len, j = 1, ans, cnt;\nlong long a[400001], num[400001], sum[400001];\nint main() {\n  cin >> n >> I;\n  k = I * 8 / n;\n  len = 1 << k;\n  for (int i = 1; i <= n; ++i) cin >> a[i];\n  sort(a + 1, a + n + 1);\n  for (int i = 1; i <= n; ++i) {\n    if (a[i] == a[i - 1])\n      num[cnt]++;\n    else\n      num[++cnt]++;\n  }\n  if (k >= 19 || len >= cnt) {\n    cout << 0 << endl;\n    return 0;\n  }\n  for (int i = 1; i <= cnt; ++i) sum[i] = sum[i - 1] + num[i];\n  ans = n;\n  for (int i = 1; i <= cnt - len + 1; ++i)\n    ans = min(ans, n - (sum[i + len - 1] - sum[i - 1]));\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tstatic class PairComparator implements Comparator<Pair> {\n\t\t@Override\n\t\tpublic int compare(Pair x, Pair y) {\n\t\t\tif (x.val < y.val)\n\t\t\t\treturn -1;\n\t\t\tif (x.val > y.val)\n\t\t\t\treturn 1;\n\t\t\tif (x.val == y.val) {\n\t\t\t\tif (x.ind < y.ind)\n\t\t\t\t\treturn -1;\n\t\t\t\tif (x.ind > y.ind)\n\t\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tstatic class Pair {\n\t\tint ind, val;\n\n\t\tPair(int i, int v) {\n\t\t\tind = i;\n\t\t\tval = v;\n\t\t}\n\t}\n\n\tstatic int[] vis;\n\n\tstatic void func() throws Exception {\n\t\tint n, I;\n\t\tn = sc.nextInt();\n\t\tI = sc.nextInt();\n\t\tint space = (I*8)/n;\n\t\tHashMap<Integer, Integer > hm = new HashMap<>();\n\t\tint[] arr =sc.intArr(n);\n\t\tint distinct = 0;\n\t\tList<Integer > nums = new ArrayList<>();\n\t\tfor (int i=0;i<n;i++){\n\t\t\tif (!hm.containsKey(arr[i])){\n\t\t\t\tdistinct++;\n\t\t\t\tnums.add(arr[i]);\n\t\t\t}\n\t\t\thm.put(arr[i], hm.getOrDefault(arr[i], 0)+1); // hm[arr[i]]++;\t\n\t\t}\n\t\tCollections.sort(nums);\n\n\t\tint maxDistinct = 1;\n\t\t/*\n\t\tif (space==0){\n\t\t\tint minRem = n-hm.get(nums.get(0));\n\t\t\tfor (int i=1;i<nums.size();i++){\n\t\t\t\tminRem = Math.min(minRem, n-hm.get(nums.get(i)));\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n*/\n\t\tfor (int i=0;i<space;i++){\n\t\t\tmaxDistinct*=2;\n\t\t\tif (maxDistinct>=distinct){\n\t\t\t\tpw.println(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tint inHand=0;\n\t\tfor (int i=0;i<maxDistinct;i++){\n\t\t\tinHand+=hm.get(nums.get(i));\n\t\t}\n\t\tint minRes = n-inHand;\n\t\tint l=0, r=maxDistinct-1;\n\t\twhile (r<nums.size()-1){\n\t\t\tinHand-=hm.get(nums.get(l));\n\t\t\tinHand+=hm.get(nums.get(r+1));\n\t\t\tminRes = Math.min(minRes, n-inHand);\n\t\t\tl++;\n\t\t\tr++;\n\t\t}\n\t\tpw.println(minRes);\n\n\t\t\n\n\n\t\t\n\t}\n\n\t/*\n\t \n\t * */\n\tstatic PrintWriter pw;\n\tstatic MScanner sc;\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tpw = new PrintWriter(System.out);\n\t\tsc = new MScanner(System.in);\n\n\t\tint tests = 1;\n\t//\ttests =sc.nextInt(); //comment this line\n\t\twhile (tests-- > 0) {\n\t\t\tfunc();\n\t\t\tpw.flush();\n\t\t}\n\n\t}\n\n\tstatic class MScanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic MScanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\n\t\tpublic MScanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int[] intArr(int n) throws IOException {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tin[i] = nextInt();\n\t\t\treturn in;\n\t\t}\n\n\t\tpublic long[] longArr(int n) throws IOException {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tin[i] = nextLong();\n\t\t\treturn in;\n\t\t}\n\n\t\tpublic int[] intSortedArr(int n) throws IOException {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tin[i] = nextInt();\n\t\t\tshuffle(in);\n\t\t\tArrays.sort(in);\n\t\t\treturn in;\n\t\t}\n\n\t\tpublic long[] longSortedArr(int n) throws IOException {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tin[i] = nextLong();\n\t\t\tshuffle(in);\n\t\t\tArrays.sort(in);\n\t\t\treturn in;\n\t\t}\n\n\t\tpublic Integer[] IntegerArr(int n) throws IOException {\n\t\t\tInteger[] in = new Integer[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tin[i] = nextInt();\n\t\t\treturn in;\n\t\t}\n\n\t\tpublic Long[] LongArr(int n) throws IOException {\n\t\t\tLong[] in = new Long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tin[i] = nextLong();\n\t\t\treturn in;\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n\n\tstatic void shuffle(int[] in) {\n\t\tfor (int i = 0; i < in.length; i++) {\n\t\t\tint idx = (int) (Math.random() * (i + 1));\n\t\t\tint tmp = in[i];\n\t\t\tin[i] = in[idx];\n\t\t\tin[idx] = tmp;\n\t\t}\n\t}\n\n\tstatic void shuffle(long[] in) {\n\t\tfor (int i = 0; i < in.length; i++) {\n\t\t\tint idx = (int) (Math.random() * (i + 1));\n\t\t\tlong tmp = in[i];\n\t\t\tin[i] = in[idx];\n\t\t\tin[idx] = tmp;\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.io.FilterInputStream;\nimport java.io.BufferedInputStream;\nimport java.util.HashMap;\nimport java.io.InputStream;\n\n/**\n * @author khokharnikunj8\n */\n\npublic class Main {\n    public static void main(String[] args) {\n        new Thread(null, new Runnable() {\n            public void run() {\n                new Main().solve();\n            }\n        }, \"1\", 1 << 26).start();\n    }\n\n    void solve() {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        ScanReader in = new ScanReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        AMP3 solver = new AMP3();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class AMP3 {\n        public void solve(int testNumber, ScanReader in, PrintWriter out) {\n            int n = in.scanInt();\n            int I = in.scanInt() * 8;\n            int[] ar = new int[n];\n            HashSet<Integer> set = new HashSet<>();\n            for (int i = 0; i < n; i++) set.add(ar[i] = in.scanInt());\n\n            int[] temp = new int[set.size()];\n            int counter = 0;\n            for (int i : set) temp[counter++] = i;\n            CodeHash.Radix_Sort(temp);\n            HashMap<Integer, Integer> map = new HashMap<>();\n            for (int i = 0; i < counter; i++) map.put(temp[i], i);\n            int[] what = new int[n];\n            for (int i = 0; i < n; i++) what[map.get(ar[i])]++;\n\n            int max = 0;\n            for (int i = 1; i <= n; i++) {\n                if (Math.ceil(Math.log(i) / Math.log(2)) * n <= I) max = i;\n                else break;\n            }\n            int ans = n;\n            int how_much = 0;\n            for (int i = 0; i < max; i++) {\n                how_much += what[i];\n            }\n            ans = Math.min(ans, n - how_much);\n            for (int i = max; i < n; i++) {\n                how_much -= what[i - max];\n                how_much += what[i];\n                ans = Math.min(ans, n - how_much);\n            }\n            out.println(ans);\n\n\n        }\n\n    }\n\n    static class CodeHash {\n        public static void Radix_Sort(int a[]) {\n\n            int multiplier = 1, len = a.length, max = Integer.MIN_VALUE;\n            int b[] = new int[len];\n            int bucket[];\n            for (int i = 0; i < len; i++) if (max < a[i]) max = a[i];\n            while (max / multiplier > 0) {\n                bucket = new int[10];\n                for (int i = 0; i < len; i++) bucket[(a[i] / multiplier) % 10]++;\n                for (int i = 1; i < 10; i++) bucket[i] += (bucket[i - 1]);\n                for (int i = len - 1; i >= 0; i--) b[--bucket[(a[i] / multiplier) % 10]] = a[i];\n                for (int i = 0; i < len; i++) a[i] = b[i];\n                multiplier *= 10;\n            }\n\n        }\n\n    }\n\n    static class ScanReader {\n        private byte[] buf = new byte[4 * 1024];\n        private int index;\n        private BufferedInputStream in;\n        private int total;\n\n        public ScanReader(InputStream inputStream) {\n            in = new BufferedInputStream(inputStream);\n        }\n\n        private int scan() {\n            if (index >= total) {\n                index = 0;\n                try {\n                    total = in.read(buf);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                if (total <= 0) return -1;\n            }\n            return buf[index++];\n        }\n\n        public int scanInt() {\n            int integer = 0;\n            int n = scan();\n            while (isWhiteSpace(n)) n = scan();\n            int neg = 1;\n            if (n == '-') {\n                neg = -1;\n                n = scan();\n            }\n            while (!isWhiteSpace(n)) {\n                if (n >= '0' && n <= '9') {\n                    integer *= 10;\n                    integer += n - '0';\n                    n = scan();\n                }\n            }\n            return neg * integer;\n        }\n\n        private boolean isWhiteSpace(int n) {\n            if (n == ' ' || n == '\\n' || n == '\\r' || n == '\\t' || n == -1) return true;\n            else return false;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 3,
            "solution": "from sys import *\nfrom math import *\nn,K=map(int,stdin.readline().split())\na=list(map(int,stdin.readline().split()))\nk=8*K\nx=k//n\nd=2**x\na.sort()\nb=[a[0]]\nfor i in range(1,n):\n    if a[i]!=a[i-1]:\n        b.append(a[i])\nif len(b)<=d:\n    print(0)\nelse:\n    cnt=[0]*(len(b))\n    f={}\n    for i in range(len(b)):\n        f[b[i]]=i\n    for i in range(n):\n        cnt[f[a[i]]]+=1\n    a1=cnt[:d]\n    s=sum(a1)\n    j=0\n    k=0\n    ans=s\n    for i in range(d,len(b)):\n        s-=cnt[k]\n        s+=cnt[i]\n        k+=1\n        if ans<s:\n            ans=s\n    print(n-ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst double eps = 0.0000001;\nusing namespace std;\ninline int sgn(double x) { return (x > eps) - (x < -eps); }\nstatic char buf[100000], *pa = buf, *pd = buf;\ninline long long read() {\n  register long long x(0), f(1);\n  register char c(\n      pa == pd && (pd = (pa = buf) + fread(buf, 1, 100000, stdin), pa == pd)\n          ? EOF\n          : *pa++);\n  while (c > '9' || c < '0')\n    f = c == '-' ? -1 : 1,\n    c = pa == pd && (pd = (pa = buf) + fread(buf, 1, 100000, stdin), pa == pd)\n            ? EOF\n            : *pa++;\n  while (c >= '0' && c <= '9')\n    x = x * 10 + c - 48,\n    c = pa == pd && (pd = (pa = buf) + fread(buf, 1, 100000, stdin), pa == pd)\n            ? EOF\n            : *pa++;\n  return f * x;\n}\nlong long ans[(long long)1e6 + 5];\nlong long Qz[(long long)1e6 + 5];\nmap<long long, long long> sum;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long n, m;\n  cin >> n >> m;\n  for (int i = 1; i <= n; ++i) {\n    cin >> ans[i];\n    sum[ans[i]]++;\n  }\n  sort(ans + 1, ans + n + 1);\n  long long num = unique(ans + 1, ans + n + 1) - ans - 1;\n  for (int i = 1; i <= num; ++i) {\n    Qz[i] = Qz[i - 1] + sum[ans[i]];\n  }\n  long long bit = 8 * m;\n  bit = (bit * 1.0 / n);\n  if ((1 << bit) >= num || bit >= 20) {\n    cout << 0 << endl;\n    return 0;\n  }\n  long long i = 1, j = num;\n  long long Sum = num - (1 << bit);\n  j = num;\n  long long MAX = -1e10;\n  for (int i = 1, j = num - Sum; j <= num; i++, j++) {\n    MAX = max(MAX, Qz[j] - Qz[i - 1]);\n  }\n  cout << Qz[num] - MAX;\n}\n"
        },
        {
            "language": 3,
            "solution": "n, bs = map(int, input().split())\na = list(map(int, input().split()))\nk = (bs*8)//n\nk = min(k, 30)\nkd = 2**k\n\nd = {}\nfor i in a:\n    if i not in d:\n        d[i] = 0\n    d[i] +=1\ncm = 0\na = sorted(set(a))\nfor i in a:\n    ncm =cm+d[i]\n    d[i] = cm\n    cm = ncm\nla = len(a)\nans = n\nfor l in range(la):\n    r = l + kd\n    lc = d[a[l]]\n    if r <la:\n        rc = d[a[r]]\n    else:\n        rc = n\n    ans = min(ans, n - (rc - lc))\nprint(ans)\n\n\n"
        },
        {
            "language": 3,
            "solution": "R=lambda:map(int,input().split())\nn,I=R()\na=sorted(R())+[1<<30]\nb=[0]+[i+1for i in range(n)if a[i]<a[i+1]]\nprint(n-max((y-x for x,y in zip(b,b[1<<8*I//n:])),default=n))"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\n\nn, I = map(int, input().split())\na = list(map(int, input().split()))\nk = (I*8) // n\nK = 2**k\nd = {}\nfor i in range(n):                \n    if a[i] not in d:\n        d[a[i]] = 0\n    d[a[i]] += 1\nkeys = list(d.keys())\nkeys.sort()\nnum = 0\nmaxNum = 0\nfor i in range(len(keys)):\n    num += d[keys[i]]\n    if i >= K:\n        num -= d[keys[i-K]]\n    maxNum = max(maxNum, num)\nres = n - maxNum\nprint(res)\n"
        },
        {
            "language": 3,
            "solution": "import math\nn,i=map(int,input().split())\nl=list(map(int,input().split()))\nl.sort()\nk=(8*i)//n\nK=2**(min(k,30))\ni,j,ans=0,0,n\ndist=0\ndct={}\nwhile(i<n or j<n):\n\tif j==n:\n\t\tdct[l[i]]-=1\n\t\tif dct[l[i]]==0:\n\t\t\tdel dct[l[i]]\n\t\ti+=1\n\telse:\n\t\tif dist<K:\n\t\t\tif l[j] in dct:\n\t\t\t\tdct[l[j]]+=1\n\t\t\t\tj+=1\n\t\t\telse:\n\t\t\t\tdct[l[j]]=1\n\t\t\t\tj+=1\n\t\t\t\tdist+=1\n\t\telif dist==K:\n\t\t\tif l[j] in dct:\n\t\t\t\tdct[l[j]]+=1\n\t\t\t\tj+=1\n\t\t\telse:\n\t\t\t\tif dct[l[i]]==1:\n\t\t\t\t\tdel dct[l[i]]\n\t\t\t\t\tdist-=1\n\t\t\t\telse:\n\t\t\t\t\tdct[l[i]]-=1\n\t\t\t\ti+=1\n\tans=min(ans,n-(j-i))\nprint(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 400010;\nint n, m, a[N], cnt = 0, ans, p[N], lp, num[N];\nint main() {\n  scanf(\"%d%d\", &n, &m), m = m * 8 / n;\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]), p[i] = a[i];\n  sort(p + 1, p + n + 1), lp = unique(p + 1, p + n + 1) - p - 1;\n  for (int i = 1; i <= n; i++) ++num[lower_bound(p + 1, p + lp + 1, a[i]) - p];\n  for (int i = 1; i <= lp; i++) num[i] += num[i - 1];\n  cnt = 1;\n  for (int i = 1; i <= m; i++, cnt <<= 1)\n    if (cnt >= lp) break;\n  if (cnt >= lp) {\n    puts(\"0\");\n    return 0;\n  }\n  for (int i = cnt; i <= lp; i++) ans = max(ans, num[i] - num[i - cnt]);\n  printf(\"%d\\n\", n - ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ii = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<long long>;\nusing vii = vector<pair<int, int>>;\nint main() {\n  int n, I;\n  scanf(\"%d%d\", &n, &I);\n  map<int, int> cnt;\n  for (int i = 0; i < n; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    cnt[x]++;\n  }\n  int b = 8 * I / n;\n  if (b > 30 || (1 << b) >= (int)((cnt).size())) {\n    puts(\"0\");\n    return 0;\n  }\n  b = 1 << b;\n  vi idx;\n  for (auto p : cnt) idx.push_back(p.first);\n  sort((idx).begin(), (idx).end());\n  int m = (int)((idx).size());\n  vi ps(m + 1);\n  for (int i = 0; i < m; i++) ps[i + 1] = ps[i] + cnt[idx[i]];\n  int ans = n;\n  for (int i = 0; i < m; i++) {\n    int tmp = ps[i];\n    if (i + b < m) tmp += ps[m] - ps[i + b];\n    ans = min(ans, tmp);\n  }\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 1,
            "solution": "import time\n\nif True:\n\tarr = map(int,raw_input().split(\" \"))\n\tn,I = arr[:2]\n\tarr = map(int,raw_input().split(\" \"))\nelse:\n\tn,I = 2,100000000\n\tarr = range(n)\n\nk = int(8*I/n)\nK = 2**k\n\ndic = {}\t\n\nfor i in xrange(n):\n\tif not dic.has_key(arr[i]):\n\t\tdic[arr[i]] = 1\n\telse:\n\t\tdic[arr[i]] += 1\n\nkeys = sorted(dic.keys())\nvalues = [dic[i] for i in keys]\ndp = sum(values[:K])\nmaxv = dp\n\nif K>=len(values):\n\tprint 0\nelse:\n\tfor i in xrange(K,min(n,len(values))):\n\t\tdp \t+= values[i]-values[i-K]\n\t\tmaxv = max(maxv,dp)\n\tprint n-maxv\n\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n \npublic class TaskC {\n \n    void run() {\n        FastReader in = new FastReader(System.in);\n//        FastReader in = new FastReader(new FileInputStream(\"input.txt\"));\n        PrintWriter out = new PrintWriter(System.out);\n//        PrintWriter out = new PrintWriter(new FileOutputStream(\"output.txt\"));\n \n \n        int n = in.nextInt();\n        int I = in.nextInt();\n \n        Set<Integer> set = new HashSet<>();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextInt();\n            set.add(a[i]);\n        }\n \n        int k = 8 * I / n;\n \n        if (k < 31 && (1 << k) < set.size()) {\n            int K = 1 << k;\n \n            Arrays.sort(a);\n \n            List<Integer> list = new ArrayList<>();\n            list.add(1);\n            for (int i = 1; i < n; i++) {\n                if (a[i] != a[i - 1])\n                    list.add(1);\n                else {\n                    int x = list.get(list.size() - 1);\n                    list.set(list.size() - 1, x + 1);\n                }\n            }\n \n            int[] pre = new int[list.size() + 1];\n            for (int i = 0; i < list.size(); i++)\n                pre[i + 1] = pre[i] + list.get(i);\n \n            int ans = Integer.MAX_VALUE;\n            for (int i = K; i <= list.size(); i++) {\n                ans = Math.min(ans, n - (pre[i] - pre[i - K]));\n \n            }\n \n            out.println(ans);\n        } else\n            out.println(0);\n \n \n \n \n        out.close();\n    }\n \n    class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n \n        FastReader(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n \n        Integer nextInt() {\n            return Integer.parseInt(next());\n        }\n \n        Long nextLong() {\n            return Long.parseLong(next());\n        }\n \n        Double nextDouble() {\n            return Double.parseDouble(next());\n        }\n \n        String next() {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(nextLine());\n \n            return st.nextToken();\n        }\n \n        String nextLine() {\n            String x = \"\";\n            try {\n                x = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return x;\n        }\n    }\n \n \n    public static void main(String[] args) {\n        new TaskC().run();\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class A\n{\n      public static void main(String ar[]) throws Exception\n      {\n            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n            String s1[]=br.readLine().split(\" \");\n            String s2[]=br.readLine().split(\" \");\n            int n=Integer.parseInt(s1[0]);\n            int I=Integer.parseInt(s1[1]);\n            I=I*8;  I=I/n;\n            int a[]=new int[n];\n            TreeMap<Integer,Integer> tm=new TreeMap<Integer,Integer>();\n            for(int i=0;i<n;i++)\n            { a[i]=Integer.parseInt(s2[i]);  \n              if(tm.containsKey(a[i]))\n               tm.put(a[i],1+tm.get(a[i]));\n              else\n               tm.put(a[i],1);\n            }\n            \n            int m=tm.size();\n            int c[]=new int[m];\n            int d[]=new int[m];\n            int j=0;\n            \n            for(int u:tm.keySet())\n            { c[j]=1; d[j]=tm.get(u); j++; }\n            \n            for(int i=1;i<m;i++)\n            { c[i]+=c[i-1]; d[i]+=d[i-1]; }\n             \n            int min=n;\n            \n            int l=0,r=n;\n            while(r-l>1)\n            {\n                  int mid=(l+r)/2;\n                  int u=(int)Math.ceil(Math.log(mid)/Math.log(2));\n                  if(u>I)\n                   r=mid;\n                  else\n                   l=mid;\n            }\n            \n            if(r-l==1)\n            {\n               int mid=r;\n               int u=(int)Math.ceil(Math.log(mid)/Math.log(2));\n               if(u<=I)\n                l=r;    \n            }\n            \n            int mm=l,p=0;\n            int u=(int)Math.ceil(Math.log(mm)/Math.log(2));\n            if(u<=I)\n            { p=l; }\n            \n            //System.out.println(p);\n            for(int i=0;i<m;i++)\n            {\n              if(i==0)\n                min=Math.min(min,n-(d[Math.min(m-1,i+p-1)]));\n              else\n                min=Math.min(min,n-(d[Math.min(m-1,i+p-1)]-d[i-1]));\n            }\n            \n            System.out.println(min);\n      }\n}"
        },
        {
            "language": 3,
            "solution": "import sys\nimport math\n\ndef findans(pref,n,num,count,tmp):\n\n\t# tmp.sort()\n\n\t# ans=0\n\n\t# for g in range(count-num):\n\t# \tans+=tmp[g]\n\n\t# return ans\n\n\tmini=-2\n\n\t# mid=len(pref)-1-(count-num)\n\n\tmid=num\n\n\t# print(mid)\n\n\tfor g in range(len(pref)-1-mid+1):\n\t\t\n\t\tstart=pref[g]-pref[0]\n\t\tend=pref[len(pref)-1]-pref[g+mid]\n\t\t# print(start+end)\n\t\tif(mini==-2):\n\t\t\tmini=start+end\n\t\telse:\n\t\t\tmini=min(mini,start+end)\n\n\treturn mini\n\ndef b_search(a,h,pref,n,I,tmp):\n\n\tlow=1\n\thigh=h\n\n\twhile(low<high):\n\n\t\tmid=low+math.ceil((high-low)/2)\t# 1 2 CASE\n\n\t\tval=math.ceil(math.log(mid,2))*n\n\n\t\tif(val<=I*8):\n\t\t\tlow=mid\n\t\telse:\n\t\t\thigh=mid-1\n\n\t# print(\"K:\",low)\t\t\n\n\treturn findans(pref,n,low,h,tmp)\n\n[n,I]=[int(i) for i in sys.stdin.readline().split()]\n\na=[int(j) for j in sys.stdin.readline().split()]\n\na.sort()\n\nprev=-2\n\ncount=0\n\narr=[]\n\nfor i in range(n):\n\tif(prev!=a[i]):\n\t\tcount+=1\n\t\tarr.append([a[i],1])\n\telse:\n\t\tarr[-1][1]+=1\n\tprev=a[i]\n\ntmp=[]\n\nfor p in range(len(arr)):\n\ttmp.append(arr[p][1])\n\npref=[0]\n\nfor r in range(len(arr)):\n\tpref.append(pref[r]+arr[r][1])\n\nif(math.ceil(math.log(count,2))*n<=I*8):\n\tprint(0)\nelse:\n\tprint(b_search(a,count,pref,n,I,tmp))"
        },
        {
            "language": 1,
            "solution": "from __future__ import division, print_function\nimport bisect\nimport math\nimport heapq\nimport itertools\nimport sys\nfrom atexit import register\nfrom collections import Counter\nfrom functools import reduce\nsys.setrecursionlimit(10000000)\nif sys.version_info[0] < 3:\n    from io import BytesIO as stream\nelse:\n    from io import StringIO as stream\n \n \nif sys.version_info[0] < 3:\n    class dict(dict):\n        \"\"\"dict() -> new empty dictionary\"\"\"\n        def items(self):\n            \"\"\"D.items() -> a set-like object providing a view on D's items\"\"\"\n            return dict.iteritems(self)\n \n        def keys(self):\n            \"\"\"D.keys() -> a set-like object providing a view on D's keys\"\"\"\n            return dict.iterkeys(self)\n \n        def values(self):\n            \"\"\"D.values() -> an object providing a view on D's values\"\"\"\n            return dict.itervalues(self)\n \n    input = raw_input\n    range = xrange\n \n    filter = itertools.ifilter\n    map = itertools.imap\n    zip = itertools.izip\n \n \ndef sync_with_stdio(sync=True):\n    \"\"\"Set whether the standard Python streams are allowed to buffer their I/O.\n \n    Args:\n        sync (bool, optional): The new synchronization setting.\n \n    \"\"\"\n    global input, flush\n \n    if sync:\n        flush = sys.stdout.flush\n    else:\n        sys.stdin = stream(sys.stdin.read())\n        input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n \n        sys.stdout = stream()\n        register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\n\ndef main():\n    n,I=map(int,input().split())\n    a=[int(o) for o in input().split()]\n    a=sorted(a)\n    pv=1<<((I*8//n))\n    b=sorted(list(set(a)))\n    d=dict(Counter(a))\n    e=[]\n    lb=len(b)\n    prefix=[0]*(lb)\n    for i in range(lb):\n        prefix[i]=prefix[i-1]+d[b[i]]\n    mi=n\n    prefix.append(0)\n    for i in range(lb):\n        mi=min(mi,n-(prefix[min(i+pv-1,lb-1)]-prefix[i-1]))\n    print(mi)\n\n\nif __name__ == '__main__':\n    sync_with_stdio(False)\n    main()"
        },
        {
            "language": 4,
            "solution": "//package round576;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class A {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni(), I = ni();\n\t\tint[] a = na(n);\n\t\ta = radixSort(a);\n\t\tint[][] uc = uniqcount(a);\n\t\tint[] cum = new int[uc.length+1];\n\t\tfor(int i = 0;i < uc.length;i++){\n\t\t\tcum[i+1] = cum[i] + uc[i][1];\n\t\t}\n\t\tint max = 0;\n\t\tfor(int d = 0;d <= 20 && (long)n*d <= 8L*I;d++){\n\t\t\tif(1<<d >= uc.length){\n\t\t\t\tmax = n;\n\t\t\t}\n\t\t\tfor(int i = 0;i <= uc.length - (1<<d);i++){\n\t\t\t\tint unc = cum[i+(1<<d)] - cum[i];\n\t\t\t\tmax = Math.max(max, unc);\n\t\t\t}\n\t\t}\n\t\tout.println(n-max);\n\t}\n\tpublic static int[][] uniqcount(int[] a)\n\t{\n\t\tint n = a.length;\n\t\tint p = 0;\n\t\tint[][] b = new int[n][];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(i == 0 || a[i] != a[i-1])b[p++] = new int[]{a[i], 0};\n\t\t\tb[p-1][1]++;\n\t\t}\n\t\treturn Arrays.copyOf(b, p);\n\t}\n\n\t\n\tpublic static int[] radixSort(int[] f){ return radixSort(f, f.length); }\n\tpublic static int[] radixSort(int[] f, int n)\n\t{\n\t\tint[] to = new int[n];\n\t\t{\n\t\t\tint[] b = new int[65537];\n\t\t\tfor(int i = 0;i < n;i++)b[1+(f[i]&0xffff)]++;\n\t\t\tfor(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n\t\t\tfor(int i = 0;i < n;i++)to[b[f[i]&0xffff]++] = f[i];\n\t\t\tint[] d = f; f = to;to = d;\n\t\t}\n\t\t{\n\t\t\tint[] b = new int[65537];\n\t\t\tfor(int i = 0;i < n;i++)b[1+(f[i]>>>16)]++;\n\t\t\tfor(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n\t\t\tfor(int i = 0;i < n;i++)to[b[f[i]>>>16]++] = f[i];\n\t\t\tint[] d = f; f = to;to = d;\n\t\t}\n\t\treturn f;\n\t}\n\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new A().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint bsearch(int l, int r, int I, int n) {\n  int mid, ans = 1;\n  long double tmp;\n  while (l <= r) {\n    mid = l + ((r - l) >> 1);\n    tmp = ceil(log2(mid * 1.)) * n;\n    if (tmp <= I * 8) {\n      ans = mid;\n      l = mid + 1;\n    } else\n      r = mid - 1;\n  }\n  return ans;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  int i, j, n, m, I;\n  cin >> n >> I;\n  int a[n], ans;\n  map<int, int> freq;\n  for (i = 0; i < n; i++) {\n    cin >> a[i];\n    freq[a[i]]++;\n  }\n  vector<int> uniqueElements;\n  for (auto iter : freq) uniqueElements.push_back(iter.first);\n  m = uniqueElements.size();\n  if (m == 1)\n    ans = 0;\n  else {\n    int maxDistinct = bsearch(1, m, I, n);\n    if (m <= maxDistinct)\n      ans = 0;\n    else {\n      ans = INT_MAX;\n      int csum[m];\n      for (i = 0; i < m; i++)\n        csum[i] = freq[uniqueElements[i]] + (i > 0 ? csum[i - 1] : 0);\n      for (i = 0;; i++) {\n        j = maxDistinct - 1 + i;\n        if (j >= m) break;\n        ans = min(ans, (i > 0 ? csum[i - 1] : 0) + csum[m - 1] - csum[j]);\n      }\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n, I;\n  cin >> n >> I;\n  I *= 8;\n  int x = I / n;\n  int diff = pow(2, min(20, x));\n  int a[n];\n  map<int, int> make_pair;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    make_pair[a[i]]++;\n  }\n  auto p = make_pair.begin();\n  int ans = n;\n  int cost = n, curr = 0;\n  for (auto start = make_pair.begin(); start != make_pair.end(); start++) {\n    while (p != make_pair.end() && curr < diff) {\n      cost -= p->second;\n      curr++;\n      p++;\n    }\n    ans = min(ans, cost);\n    cost += start->second;\n    curr--;\n  }\n  cout << ans << endl;\n  return 0;\n};\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint need(int x) {\n  for (int i = 0; i <= 20; ++i) {\n    int j = 1 << i;\n    if (j >= x) return i;\n  }\n  return -1;\n}\nint main() {\n  int n, I;\n  cin >> n >> I;\n  I *= 8;\n  vector<int> v(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> v[i];\n  }\n  sort(v.begin(), v.end());\n  int mn = n, dst = 0;\n  map<int, int> fr;\n  auto add = [&](int x) {\n    fr[x]++;\n    if (fr[x] == 1) dst++;\n  };\n  auto rem = [&](int x) {\n    fr[x]--;\n    if (fr[x] == 0) dst--;\n  };\n  int j = n - 1;\n  for (int i = n - 1; i >= 0; --i) {\n    add(v[i]);\n    while (j >= i && n * need(dst) > I) rem(v[j]), j--;\n    mn = min(mn, i + n - j - 1);\n  }\n  cout << mn;\n}\n"
        },
        {
            "language": 3,
            "solution": "n,m=map(int,input().split())\na=list(map(int,input().split()))\nm*=8\nm=m//n\nm=2**m\n#print(m)\nd={}\nfor i in a:\n\ttry:\n\t\td[i]+=1\n\texcept:\n\t\td[i]=1\n#a=sorted(list(set(a)))\na.sort()\nval=[0]\nmx=0\nfor i in range(1, n):\n\tif a[i - 1]!=a[i]:\n\t\tval.append(i)\ndiff=len(val)-m\nif len(val)<=m:\n    print(0)\nelse:\n    for i in range(diff):\n        mx=max(val[i+m]-val[i],mx)\n    print(n-mx)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Test {\n\n    static int readInt() {\n        int ans = 0;\n        boolean neg = false;\n        try {\n            boolean start = false;\n            for (int c = 0; (c = System.in.read()) != -1; ) {\n                if (c == '-') {\n                    start = true;\n                    neg = true;\n                    continue;\n                } else if (c >= '0' && c <= '9') {\n                    start = true;\n                    ans = ans * 10 + c - '0';\n                } else if (start) break;\n            }\n        } catch (IOException e) {\n        }\n        return neg ? -ans : ans;\n    }\n\n    static long readLong() {\n        long ans = 0;\n        boolean neg = false;\n        try {\n            boolean start = false;\n            for (int c = 0; (c = System.in.read()) != -1; ) {\n                if (c == '-') {\n                    start = true;\n                    neg = true;\n                    continue;\n                } else if (c >= '0' && c <= '9') {\n                    start = true;\n                    ans = ans * 10 + c - '0';\n                } else if (start) break;\n            }\n        } catch (IOException e) {\n        }\n        return neg ? -ans : ans;\n    }\n\n    static String readLine() {\n        StringBuilder b = new StringBuilder();\n        try {\n            boolean start = false;\n            for (int c = 0; (c = System.in.read()) != -1; ) {\n                if (c != '\\r' && c != '\\n') {\n                    start = true;\n                    b.append((char)c);\n                } else if (start) break;\n            }\n        } catch (IOException e) {\n        }\n        return b.toString();\n    }\n\n    static PrintWriter writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n    void start() {\n        int n = readInt(), I = readInt();\n        int bits = 8*I;\n        if (bits < n) {\n            Map<Integer, Integer> cnt = new HashMap<>();\n            int d = 1;\n            for (int i = 0; i < n; i++) {\n                int v = readInt();\n                int f = cnt.getOrDefault(v, 0) + 1;\n                cnt.put(v, f);\n                if (f > d) d = f;\n            }\n            writer.println(n - d);\n            return;\n        }\n\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = readInt();\n        Arrays.sort(a);\n\n        int dis = 0;\n        {\n            int ll = -1, rr = n + 1;\n            while (rr - ll > 1) {\n                int m = (ll + rr) / 2;\n                int b = Integer.numberOfTrailingZeros(Integer.highestOneBit(Math.max(1,m-1))) + 1;\n                int total = b * n;\n                if (total <= bits) ll = m;\n                else rr = m;\n            }\n            dis = ll;\n        }\n\n        int best = 0, start = 0, cnt = 0;\n        for (int i = 0; i < n; i++) {\n            if (i == 0 || a[i] != a[i-1]) cnt++;\n            while (cnt > dis) {\n                start++;\n                if (a[start] != a[start-1]) cnt--;\n            }\n\n            if (i - start + 1 > best) best = i - start + 1;\n        }\n        writer.println(n - best);\n    }\n\n    public static void main(String[] args) {\n        Test te = new Test();\n        te.start();\n        writer.flush();\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long logo(long long a) {\n  long long ans = 0, fl = 0;\n  while (a / 2 > 0) {\n    if (a % 2 == 1) fl = 1;\n    ans++;\n    a /= 2;\n  }\n  if (fl == 1) ans++;\n  return ans;\n}\nint32_t main() {\n  long long n, I;\n  cin >> n >> I;\n  I *= 8;\n  long long max_k = I / n;\n  vector<long long> a(n);\n  for (long long i = 0; i < n; ++i) cin >> a[i];\n  sort(a.begin(), a.end());\n  vector<long long> cnt;\n  long long count = 1, tmp = a[0], last = 0;\n  cnt.push_back(count);\n  for (long long i = 1; i < n; ++i) {\n    if (a[i] == tmp)\n      cnt[last]++;\n    else {\n      cnt.push_back(count);\n      tmp = a[i];\n      last++;\n    }\n  }\n  long long k = cnt.size(), ans = n;\n  vector<long long> pref(k + 1);\n  for (long long i = 1; i <= k; ++i) pref[i] = pref[i - 1] + cnt[i - 1];\n  long long dif;\n  if (logo(k) - max_k > 0)\n    dif = k - (1 << max_k);\n  else {\n    cout << 0;\n    return 0;\n  }\n  for (long long i = 0; i <= dif; ++i)\n    ans = min(ans, pref[i] + pref[k] - pref[k - dif + i]);\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst long long INF = 0x3f3f3f3f3f3f3f3fLL;\nconst double PI = acos(-1.0);\nconst long double eps = 1e-6;\nconst int N = 1e6 + 10;\nconst int M = N * 20;\nint _ = 0;\nvoid testcase() { cout << \"Case \" << (++_) << \": \"; }\nint a[N];\nmap<int, int> mp;\nint b[N];\nint cnt;\nvoid work() {\n  int n, I;\n  cin >> n >> I;\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n    mp[a[i]]++;\n  }\n  for (auto it : mp) {\n    b[cnt++] = it.second;\n  }\n  I *= 8;\n  I /= n;\n  if (I >= 20) {\n    cout << 0 << \"\\n\";\n  } else {\n    I = 1 << I;\n    if (I >= cnt) {\n      cout << 0 << \"\\n\";\n    } else {\n      int ans = inf;\n      int sum = 0;\n      for (int i = I; i < cnt; ++i) {\n        sum += b[i];\n      }\n      ans = min(ans, sum);\n      for (int i = I; i < cnt; ++i) {\n        sum -= b[i];\n        sum += b[i - I];\n        ans = min(ans, sum);\n      }\n      cout << ans << \"\\n\";\n    }\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  work();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.nio.CharBuffer;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.NoSuchElementException;\n\npublic class P1199C_2 {\n\n    public static void main(String[] args) {\n        SimpleScanner scanner = new SimpleScanner(System.in);\n        PrintWriter writer = new PrintWriter(System.out);\n\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int bit = 0;\n        while ((1 << bit) < n)\n            ++bit;\n        bit = Math.min(bit, 8 * m / n);\n        int limit = 1 << bit;\n        ArrayList<Integer> x = new ArrayList<>(n);\n        for (int i = 0; i < n; ++i)\n            x.add(scanner.nextInt());\n        x.sort(Comparator.naturalOrder());\n        ArrayList<Integer> cnt = new ArrayList<>(n);\n        for (int i = 0, j; i < n; i = j) {\n            j = i + 1;\n            while (j < n && x.get(j).equals(x.get(i)))\n                ++j;\n            cnt.add(j - i);\n        }\n        if (cnt.size() <= limit) {\n            writer.println(0);\n        } else {\n            int count = 0;\n            for (int i = 0; i < limit; ++i)\n                count += cnt.get(i);\n            int ans = n - count;\n            for (int i = limit; i < cnt.size(); ++i) {\n                count -= cnt.get(i - limit);\n                count += cnt.get(i);\n                ans = Math.min(ans, n - count);\n            }\n            writer.println(ans);\n        }\n        writer.close();\n    }\n\n    private static class SimpleScanner {\n\n        private static final int BUFFER_SIZE = 10240;\n\n        private Readable in;\n        private CharBuffer buffer;\n        private boolean eof;\n\n        SimpleScanner(InputStream in) {\n            this.in = new BufferedReader(new InputStreamReader(in));\n            buffer = CharBuffer.allocate(BUFFER_SIZE);\n            buffer.limit(0);\n            eof = false;\n        }\n\n\n        private char read() {\n            if (!buffer.hasRemaining()) {\n                buffer.clear();\n                int n;\n                try {\n                    n = in.read(buffer);\n                } catch (IOException e) {\n                    n = -1;\n                }\n                if (n <= 0) {\n                    eof = true;\n                    return '\\0';\n                }\n                buffer.flip();\n            }\n            return buffer.get();\n        }\n\n        void checkEof() {\n            if (eof)\n                throw new NoSuchElementException();\n        }\n\n        char nextChar() {\n            checkEof();\n            char b = read();\n            checkEof();\n            return b;\n        }\n\n        String next() {\n            char b;\n            do {\n                b = read();\n                checkEof();\n            } while (Character.isWhitespace(b));\n            StringBuilder sb = new StringBuilder();\n            do {\n                sb.append(b);\n                b = read();\n            } while (!eof && !Character.isWhitespace(b));\n            return sb.toString();\n        }\n\n        int nextInt() {\n            return Integer.valueOf(next());\n        }\n\n        long nextLong() {\n            return Long.valueOf(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nfrom math import log2\nimport bisect\nimport heapq\n# from collections import deque\n\n# from types import GeneratorType\n# def bootstrap(func, stack=[]):\n#     def wrapped_function(*args, **kwargs):\n#         if stack:\n#             return func(*args, **kwargs)\n#         else:\n#             call = func(*args, **kwargs)\n#             while True:\n#                 if type(call) is GeneratorType:\n#                     stack.append(call)\n#                     call = next(call)\n#                 else:\n#                     stack.pop()\n#                     if not stack:\n#                         break\n#                     call = stack[-1].send(call)\n#             return call\n#     return wrapped_function\n\nRi = lambda : [int(x) for x in sys.stdin.readline().split()]\nri = lambda : sys.stdin.readline().strip()\n \ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nINF = 10 ** 18\nMOD = 10**9+7\n\nn,k  = Ri()\na = Ri()\ns = set(a)\na.sort()\n\ndist = len(s)\nhas = ceil(log2(dist))\n\nrequired = k*8//n\nif required >= has : \n    print(0)\nelse:\n    required = 2**(required)\n    dic = {}\n    for i in a:\n        if i in dic:\n            dic[i]+=1\n        else:\n            dic[i] = 1\n    arr = [i for i in dic]\n    pre = [0]*(len(arr)+1)\n    for i in range(len(arr)):\n        pre[i+1] = pre[i]+dic[arr[i]]\n    summ = 0\n    for i in dic:\n        summ+=dic[i]\n    minn = INF\n    for i in range(required-1,len(arr)):\n        minn = min(minn, summ-(pre[i+1]-pre[i+1-required]))\n    print(minn)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 500010;\nint n, t;\nint a[N];\npair<int, int> b[N];\nint get(int k) { return ceil(log2(k)); }\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> t;\n  t *= 8;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n  }\n  sort(a + 1, a + n + 1);\n  int m = 0;\n  for (int i = 1; i <= n; i++) {\n    if (m == 0 || a[i] != a[i - 1]) {\n      b[++m] = {a[i], 1};\n    } else {\n      b[m].second++;\n    }\n  }\n  for (int i = 1; i <= m; i++) {\n    b[i].second += b[i - 1].second;\n  }\n  int res = n + 1;\n  int cur = 1;\n  for (int i = 1; i <= m; i++) {\n    while (cur <= m && n * get(cur - i + 1) <= t) cur++;\n    res = min(res, b[i - 1].second + b[m].second - b[cur - 1].second);\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long nx2(long long n) {\n  long long p = 1;\n  if (n && !(n & (n - 1))) return n;\n  while (p < n) p <<= 1;\n  return p;\n}\nnamespace Debug {\nvoid dout() { cerr << \"\\n\"; }\ntemplate <typename Head, typename... Tail>\nvoid dout(Head H, Tail... T) {\n  cerr << \" \" << H;\n  dout(T...);\n}\ntemplate <typename T>\nvoid douta(const T *a, int n) {\n  cerr << \"\\n[\";\n  for (int i = 0; i < n; i++) {\n    cerr << \" \" << a[i];\n  }\n  cerr << \" ]\\n\";\n}\ntemplate <typename T>\nvoid doutaa(T **b, int r, int c) {\n  for (int i = 0; i < r; i++) {\n    cerr << \"[\";\n    for (int j = 0; j < c; j++) {\n      cerr << \" \" << b[i][j];\n    }\n    cerr << \" ]\\n\";\n  }\n}\ntemplate <typename T>\nvoid dout(const vector<T> v) {\n  cerr << \"\\n[\";\n  for (T i : v) {\n    cerr << \" \" << i;\n  }\n  cerr << \" ]\\n\";\n}\ntemplate <typename T>\nvoid dout(const vector<vector<T>> v) {\n  cerr << \"\\n\";\n  for (vector<T> u : v) {\n    cerr << \"[\";\n    for (T i : u) {\n      cerr << \" \" << i;\n    }\n    cerr << \" ]\\n\";\n  }\n}\ntemplate <typename F, typename S>\nvoid dout(const vector<pair<F, S>> u) {\n  cerr << \"\\n\";\n  for (pair<F, S> v : u) {\n    cerr << \"[ \" << v.first << \" \" << v.second << \" ]\\n\";\n  }\n}\n}  // namespace Debug\nusing namespace Debug;\nint n, I, K;\nvector<int> a;\nint main() {\n  cin >> n >> I;\n  a.assign(n, 0);\n  unordered_map<int, int> ump;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    ++ump[a[i]];\n  }\n  int l = 0, r = ump.size(), m;\n  while (l < r) {\n    m = l + (r - l + 1) / 2;\n    if (n * ceil(log2(m)) <= 8 * I) {\n      l = m;\n    } else {\n      r = m - 1;\n    }\n  }\n  K = l;\n  vector<pair<int, int>> b(ump.begin(), ump.end());\n  sort(b.begin(), b.end());\n  int cnt = 0, freq = 0, mxfreq = 0;\n  while (cnt < (int)(b).size() && cnt < K) {\n    freq += b[cnt++].second;\n  }\n  (mxfreq) = max((mxfreq), (freq));\n  ;\n  while (cnt < (int)(b).size()) {\n    freq -= b[cnt - K].second;\n    freq += b[cnt++].second;\n    (mxfreq) = max((mxfreq), (freq));\n    ;\n  }\n  cout << n - mxfreq << '\\n';\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import Counter\nimport operator\n\nn, I = map(int, input().split(\" \"))\nA = list(map(int, input().split(\" \")))\nA = list(sorted(A))\n\nmax_k = 2**(I*8//n)\ncounter = Counter(A)\n\n#b = [0] * (10**9)\n\nvalues = list(counter.items())\n\nvalues.sort(key=operator.itemgetter(0))\n\nk = len(values)\nvalues2remove = max(0, k - max_k)\n\nif values2remove == 0:\n    print(0)\nelse:\n    first_half  = [0] * (values2remove + 1)\n    second_half = [0] * (values2remove + 1)\n\n    for x in range(1,values2remove + 1):\n        first_half[x]  = first_half[x-1]  + values[x-1][1]\n        second_half[x] = second_half[x-1] + values[len(values) - x][1]\n\n    min_value = (4 * (10**5) + 1) ** 2\n\n    for x in range(len(first_half)):\n        min_value = min(min_value, first_half[x] + second_half[values2remove - x])\n\n    print(min_value)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int n, I;\n  cin >> n >> I;\n  I *= 8;\n  vector<int> un;\n  map<int, int> cnt;\n  for (int i = 0; i < n; i++) {\n    int a;\n    cin >> a;\n    if (!cnt.count(a)) {\n      un.push_back(a);\n    }\n    cnt[a]++;\n  }\n  int ans = n;\n  int m = un.size();\n  if (ceil((long double)log2(m)) * n <= I) {\n    cout << 0;\n    return 0;\n  }\n  sort(un.begin(), un.end());\n  int lo = 1, hi = m;\n  while (lo < hi) {\n    int mid = (lo + hi + 1) / 2;\n    if (ceil((long double)log2(mid)) * n <= I) {\n      lo = mid;\n    } else {\n      hi = mid - 1;\n    }\n  }\n  int suf[m + 1];\n  memset(suf, 0, sizeof(suf));\n  for (int i = m - 1; i >= 0; i--) {\n    suf[i] = suf[i + 1] + cnt[un[i]];\n  }\n  int need = m - lo;\n  int sum1 = 0;\n  for (int i = -1; i < need; i++) {\n    int newNeed = need - (i + 1);\n    if (i != -1) sum1 += cnt[un[i]];\n    int right = m - (newNeed);\n    ans = min(ans, sum1 + suf[right]);\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import bisect\nimport collections\nimport copy\nimport functools\nimport heapq\nimport itertools\nimport math\nimport sys\nimport string\nimport random\nfrom typing import List\nsys.setrecursionlimit(99999)\n\nn,l = map(int,input().split())\narr = list(map(int,input().split()))\nk = (8*l)//n\nsa = set(arr)\nmk = len(sa).bit_length()\nif k>=mk:\n    print(0)\nelse:\n    p = 2**k\n    cs = collections.Counter(arr)\n    ks = list(cs.keys())\n    ks.sort()\n    ans = 0\n    temp = 0\n    i = 0\n    for j in range(len(ks)):\n        temp += cs[ks[j]]\n        while j - i>=p:\n            temp-=cs[ks[i]]\n            i+=1\n        ans = max(ans,temp)\n    print(n-ans)\n"
        },
        {
            "language": 4,
            "solution": "\n\nimport java.io.*;\n        import java.util.*;\npublic class Main{\n    static StreamTokenizer in=new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n    static BufferedReader buffer=new BufferedReader(new InputStreamReader(System.in));\n    static Scanner sc=new Scanner(System.in);\n    static PrintWriter out=new PrintWriter(System.out);\n    public static void main(String args[])throws Exception{\n        TreeMap<Integer,Integer> map=new TreeMap<Integer, Integer>();\n        int n=getInt();\n        int k=getInt();\n        int arr[]=new int[n];\n        int len=0;\n        int kk[]=new int[n];\n        for(int i=0;i<n;i++){\n            int a=getInt();\n            if(map.containsKey(a)){\n                arr[map.get(a)]++;\n            }else{\n                kk[len]=a;\n                map.put(a,len);\n                arr[len++]=1;\n            }\n        }\n        k=k*8/n;\n        if(k>=20){\n            System.out.println(0);\n            return;\n        }\n        k=1<<k;\n        if(k>=len){\n            System.out.println(0);\n            return;\n        }\n        Node ns[]=new Node[len];\n        for(int i=0;i<len;i++){\n            ns[i]=new Node(kk[i],arr[i]);\n        }\n        Arrays.sort(ns);\n\n        int sum[]=new int[len+1];\n        sum[0]=ns[0].count;\n        for(int i=1;i<=len;i++){\n            sum[i]=sum[i-1]+ns[i-1].count;\n        }\n        int ans=0;\n        for(int i=k;i<=len;i++){\n            ans=Math.max(ans,sum[i]-sum[i-k]);\n        }\n        System.out.println(n-ans);\n    }\n    static int getInt()throws Exception{\n        in.nextToken();\n        return  (int)in.nval;\n    }\n}\nclass Node implements Comparable{\n    int id;\n    int count;\n    public Node(int id,int count){\n        this.id=id;\n        this.count=count;\n    }\n    public int compareTo(Object o){\n        Node n=(Node)o;\n        return this.id-n.id;\n    }\n}"
        },
        {
            "language": 3,
            "solution": "# Legends Always Come Up with Solution\n# Author: Manvir Singh\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nfrom collections import Counter\ndef main():\n    n,I=map(int,input().split())\n    I*=8\n    a=list(map(int,input().split()))\n    c=Counter(a)\n    a=sorted(set(a))\n    y,ma,j,b,z=1<<min((I//n),20),0,0,Counter(),0\n    for i in range(len(a)):\n        while j<len(a) and len(b)<y:\n            b[a[j]]+=1\n            z+=c[a[j]]\n            j+=1\n        if len(b)==y or j==len(a):\n            ma=max(ma,z)\n        b[a[i]]-=1\n        z-=c[a[i]]\n        if not b[a[i]]:\n            del b[a[i]]\n    print(n-ma)\n\n# region fastio\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()"
        },
        {
            "language": 3,
            "solution": "import sys,heapq,math\nfrom collections import deque,defaultdict\nprintn = lambda x: sys.stdout.write(x)\ninn = lambda : int(input())\ninl   = lambda: list(map(int, input().split()))\ninm   = lambda:      map(int, input().split())\nDBG = True # and False\nR = 10**9 + 7\n\ndef ddprint(x):\n  if DBG:\n    print(x)\n\nn,i = inm()\na = inl()\na.sort()\nsa = list(set(a))\nm = len(sa)\nk = (8*i)//n\nkk = 2**k\nif kk >= m:\n    print(0)\n    exit()\n\nh = {}\nfor x in a:\n    if x in h:\n        h[x] += 1\n    else:\n        h[x] = 1\n\nb = []\nprev = -1\nfor x in a:\n    if x != prev:\n        b.append(h[x])\n    prev = x\n\naccb = [0] * (m+1)\nfor j in range(m):\n    accb[j] = accb[j-1] + b[j]\n\nmx = 0\nfor j in range(m-kk):\n    z = accb[j+kk-1] - accb[j-1]\n    if z > mx:\n        mx = z\nprint(accb[m-1]-mx)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> v;\nint n;\nint I;\nconst int N = 4e5 + 300;\nint cnt[N];\nbool check(int K) {\n  int k = (int)ceil(log2(K));\n  return (k * n <= I * 8);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n;\n  cin >> I;\n  v.resize(n + 1);\n  for (int i = 1; i <= n; i++) {\n    cin >> v[i];\n  }\n  sort(v.begin() + 1, v.end());\n  set<int> s;\n  for (int i = 1; i <= n; i++) {\n    if (!s.count(v[i])) {\n      cnt[i]++;\n    }\n    s.insert(v[i]);\n  }\n  for (int i = 1; i <= n; i++) {\n    cnt[i] += cnt[i - 1];\n  }\n  int ans = 1e9;\n  for (int i = 1; i <= n; i++) {\n    if (i == 1 || v[i - 1] != v[i]) {\n      int l = i;\n      int r = n;\n      int cur = i;\n      while (l <= r) {\n        int mid = (l + r) / 2;\n        int K = cnt[mid] - cnt[i - 1];\n        if (check(K)) {\n          cur = mid;\n          l = mid + 1;\n        } else {\n          r = mid - 1;\n        }\n      }\n      ans = min(ans, n - (cur - i + 1));\n    }\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class C implements Runnable {\n\tFastReader scn;\n\tPrintWriter out;\n\tString INPUT = \"6 1\\r\\n\" + \n\t\t\t\"2 1 2 3 4 3\\r\\n\" + \n\t\t\t\"\";\n\n\tvoid solve() {\n\t\tint n = scn.nextInt(), k = 8 * scn.nextInt();\n\t\tint[] arr = scn.nextIntArray(n);\n\t\tarr = scn.shuffle(arr);\n\t\tArrays.parallelSort(arr);\n\t\t\n\t\tk /= n;\n\t\tif(k >= 31) {\n\t\t\tout.println(0);\n\t\t\treturn;\n\t\t}\n\t\tk = 1 << k;\n\t\t\n\t\tif(n == 1 || k >= n) {\n\t\t\tout.println(0);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(k == 0) {\n\t\t\tout.println(n - 1);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint[] need = new int[n];\n\t\tint[] count = new int[n];\n\t\tint p = 0;\n\t\tneed[p++] = arr[0];\n\t\tcount[0]++;\n\t\tfor(int i = 1; i < n; i++) {\n\t\t\tif(arr[i] != arr[i - 1]) {\n\t\t\t\tcount[p] = 1;\n\t\t\t\tneed[p++] = arr[i];\n\t\t\t} else {\n\t\t\t\tcount[p - 1]++;\n\t\t\t}\n\t\t}\n\t\tarr = Arrays.copyOf(need, p);\n\t\tcount = Arrays.copyOf(count, p);\n\t\tn = p;\n\t\t\n\t\tfor(int i = 1; i < n; i++) {\n\t\t\tcount[i] += count[i - 1];\n\t\t}\n\t\t\n\t\tint ans = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint rem = i == 0 ? 0 : count[i - 1];\n\t\t\tif(i + k < n) {\n\t\t\t\trem += count[n - 1] - count[i + k - 1];\n\t\t\t}\n\t\t\tans = Math.min(ans, rem);\n\t\t}\n\t\t\n\t\tout.println(ans);\n\t}\n\n\tpublic void run() {\n\t\tlong time = System.currentTimeMillis();\n\t\tboolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\tout = new PrintWriter(System.out);\n\t\tscn = new FastReader(oj);\n\t\tsolve();\n\t\tout.flush();\n\t\tif (!oj) {\n\t\t\tSystem.out.println(Arrays.deepToString(new Object[] { System.currentTimeMillis() - time + \" ms\" }));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new C(), \"Main\", 1 << 26).start();\n\t}\n\n\tclass FastReader {\n\t\tInputStream is;\n\n\t\tpublic FastReader(boolean onlineJudge) {\n\t\t\tis = onlineJudge ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\t}\n\n\t\tbyte[] inbuf = new byte[1024];\n\t\tpublic int lenbuf = 0, ptrbuf = 0;\n\n\t\tint readByte() {\n\t\t\tif (lenbuf == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (ptrbuf >= lenbuf) {\n\t\t\t\tptrbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn inbuf[ptrbuf++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tint skip() {\n\t\t\tint b;\n\t\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t\t;\n\t\t\treturn b;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tchar nextChar() {\n\t\t\treturn (char) skip();\n\t\t}\n\n\t\tString next() {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile ((!isSpaceChar(b) || b == ' ')) { // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tchar[] next(int n) {\n\t\t\tchar[] buf = new char[n];\n\t\t\tint b = skip(), p = 0;\n\t\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t\t}\n\n\t\tint nextInt() {\n\t\t\tint num = 0, b;\n\t\t\tboolean minus = false;\n\t\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\tlong num = 0;\n\t\t\tint b;\n\t\t\tboolean minus = false;\n\t\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tchar[][] nextMatrix(int n, int m) {\n\t\t\tchar[][] map = new char[n][];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next(m);\n\t\t\treturn map;\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tint[][] next2DInt(int n, int m) {\n\t\t\tint[][] arr = new int[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[][] next2DLong(int n, int m) {\n\t\t\tlong[][] arr = new long[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextLongArray(m);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] shuffle(int[] arr) {\n\t\t\tRandom r = new Random();\n\t\t\tfor (int i = 1, j; i < arr.length; i++) {\n\t\t\t\tj = r.nextInt(i);\n\t\t\t\tint c = arr[i];\n\t\t\t\tarr[i] = arr[j];\n\t\t\t\tarr[j] = c;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] shuffle(long[] arr) {\n\t\t\tRandom r = new Random();\n\t\t\tfor (int i = 1, j; i < arr.length; i++) {\n\t\t\t\tj = r.nextInt(i);\n\t\t\t\tlong c = arr[i];\n\t\t\t\tarr[i] = arr[j];\n\t\t\t\tarr[j] = c;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] uniq(int[] arr) {\n\t\t\tarr = scn.shuffle(arr);\n\t\t\tArrays.sort(arr);\n\t\t\tint[] rv = new int[arr.length];\n\t\t\tint pos = 0;\n\t\t\trv[pos++] = arr[0];\n\t\t\tfor (int i = 1; i < arr.length; i++) {\n\t\t\t\tif (arr[i] != arr[i - 1]) {\n\t\t\t\t\trv[pos++] = arr[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Arrays.copyOf(rv, pos);\n\t\t}\n\n\t\tlong[] uniq(long[] arr) {\n\t\t\tarr = scn.shuffle(arr);\n\t\t\tArrays.sort(arr);\n\t\t\tlong[] rv = new long[arr.length];\n\t\t\tint pos = 0;\n\t\t\trv[pos++] = arr[0];\n\t\t\tfor (int i = 1; i < arr.length; i++) {\n\t\t\t\tif (arr[i] != arr[i - 1]) {\n\t\t\t\t\trv[pos++] = arr[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Arrays.copyOf(rv, pos);\n\t\t}\n\n\t\tint[] reverse(int[] arr) {\n\t\t\tint l = 0, r = arr.length - 1;\n\t\t\twhile (l < r) {\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tarr[r] = arr[l] ^ arr[r];\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tl++;\n\t\t\t\tr--;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] reverse(long[] arr) {\n\t\t\tint l = 0, r = arr.length - 1;\n\t\t\twhile (l < r) {\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tarr[r] = arr[l] ^ arr[r];\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tl++;\n\t\t\t\tr--;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] compress(int[] arr) {\n\t\t\tint n = arr.length;\n\t\t\tint[] rv = Arrays.copyOf(arr, n);\n\t\t\trv = uniq(rv);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = Arrays.binarySearch(rv, arr[i]);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] compress(long[] arr) {\n\t\t\tint n = arr.length;\n\t\t\tlong[] rv = Arrays.copyOf(arr, n);\n\t\t\trv = uniq(rv);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = Arrays.binarySearch(rv, arr[i]);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Washoum\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        inputClass in = new inputClass(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CMP3 solver = new CMP3();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CMP3 {\n        public void solve(int testNumber, inputClass sc, PrintWriter out) {\n            int n = sc.nextInt();\n            int I = 8 * sc.nextInt();\n            ArrayList<CMP3.Pair> tab = new ArrayList<>();\n            HashMap<Integer, Integer> map = new HashMap<>();\n            int x;\n            for (int i = 0; i < n; i++) {\n                x = sc.nextInt();\n                if (map.get(x) == null) {\n                    tab.add(new CMP3.Pair(x, 1));\n                    map.put(x, tab.size() - 1);\n                } else {\n                    tab.get(map.get(x)).y++;\n                }\n            }\n            tab.sort(Comparator.comparingInt(a -> a.x));\n            int i = 0;\n            long tot = 0;\n            while (i < tab.size() && n * Math.ceil(Math.log(i + 1) / Math.log(2)) <= I) i++;\n            if (i == n) {\n                out.println(0);\n                return;\n            }\n            i--;\n            for (int j = 0; j <= i; j++) {\n                tot += tab.get(j).y;\n            }\n            long ans = n - tot;\n            for (int j = 1; j + i < tab.size(); j++) {\n                tot -= tab.get(j - 1).y;\n                tot += tab.get(j + i).y;\n                ans = Math.min(ans, n - tot);\n            }\n            out.println(ans);\n\n        }\n\n        static class Pair {\n            int x;\n            int y;\n\n            Pair(int a, int b) {\n                x = a;\n                y = b;\n            }\n\n        }\n\n    }\n\n    static class inputClass {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public inputClass(InputStream in) {\n\n            br = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Codeforces\n{\n    public static void main(String args[])throws Exception\n    {\n        BufferedReader bu=new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder sb=new StringBuilder();\n        String s[]=bu.readLine().split(\" \");\n        int n=Integer.parseInt(s[0]),I=Integer.parseInt(s[1]);\n        int k=8*I/n;\n        k=Math.min(k,25);\n        k=1<<k;     //total bits allocated\n\n        int i,u;\n        HashMap<Integer,Integer> hm=new HashMap<>();\n        Set<Integer> al=new HashSet<>();\n        s=bu.readLine().split(\" \");\n        for(i=0;i<n;i++)\n        {\n            u=Integer.parseInt(s[i]);\n            hm.put(u,hm.getOrDefault(u,0)+1);\n            al.add(u);\n        }\n        int a[]=new int[al.size()];\n        i=0;\n        for(int x:al)\n            a[i++]=x;\n        if(a.length<=k) {System.out.print(0); return;}  //total bits exceed requirement\n        Arrays.sort(a);\n\n        int ans=0,c=0,m=a.length,j=m-1;\n        for(i=0;i<m-k;i++)\n        c+=hm.get(a[j--]);\n        j++;\n        ans=c;\n        for(i=0;i<n;i++) //checking all possibilities for minimum\n        {\n            if(j==m) break;\n            c-=hm.get(a[j++]);\n            c+=hm.get(a[i]);\n            ans=Math.min(ans,c);\n        }\n        System.out.print(ans);\n    }\n}"
        },
        {
            "language": 3,
            "solution": "n, I = [int(i) for i in input().split()]\nl1 = [int(i) for i in input().split()]\n\nk = 8 * I // n\n\n\nK = 2 ** k\nl1.sort()\ndstnct=[]\n# for i in l1[1:]:\n#     if i!=i-1:\n#         dstnct.append(i)\ndstnct.append(0)\nfor i in range(1,len(l1)):\n    if l1[i]!=l1[i-1]:\n        dstnct.append(i)\n# print(dstnct)\n\nif len(dstnct) <= K:\n    print(0)\nelse:\n    print(n - max(dstnct[i + K] - dstnct[i] for i in range(len(dstnct) - K)))\n    # print(max(b[i + K] - b[i] for i in range(len(b) - K)))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid canhazfast() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n}\ntemplate <typename T>\nT gcd(T a, T b) {\n  return b ? gcd(b, a % b) : a;\n}\ntemplate <typename T>\nT extgcd(T a, T b, T &x, T &y) {\n  T x0 = 1, y0 = 0, x1 = 0, y1 = 1;\n  while (b) {\n    T q = a / b;\n    a %= b;\n    swap(a, b);\n    x0 -= q * x1;\n    swap(x0, x1);\n    y0 -= q * y1;\n    swap(y0, y1);\n  }\n  x = x0;\n  y = y0;\n  return a;\n}\nint ctz(unsigned x) { return __builtin_ctz(x); }\nint ctzll(unsigned long long x) { return __builtin_ctzll(x); }\nint clz(unsigned x) { return __builtin_clz(x); }\nint clzll(unsigned long long x) { return __builtin_clzll(x); }\nint popcnt(unsigned x) { return __builtin_popcount(x); }\nint popcntll(unsigned long long x) { return __builtin_popcountll(x); }\nint bsr(unsigned x) { return 31 ^ clz(x); }\nint bsrll(unsigned long long x) { return 63 ^ clzll(x); }\nint a[400016], v[400016], f[400016], pre[400016];\nint main() {\n  canhazfast();\n  int n, m, sz;\n  int bits, cnt = 1;\n  int ans = 0;\n  cin >> n >> sz;\n  sz *= 8;\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n    v[i] = a[i];\n  }\n  sort(v, v + n);\n  m = unique(v, v + n) - v;\n  for (int i = 0; i < n; ++i) {\n    int j = lower_bound(v, v + m, a[i]) - v;\n    ++f[j];\n  }\n  for (int i = 0; i < m; ++i) pre[i + 1] = pre[i] + f[i];\n  bits = sz / n;\n  for (int i = 0; i < bits; ++i) {\n    cnt *= 2;\n    if (cnt > m) {\n      cnt = m;\n      break;\n    }\n  }\n  for (int i = cnt; i <= m; ++i) ans = max(ans, pre[i] - pre[i - cnt]);\n  ans = n - ans;\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Codeforces1198A {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint I = Integer.parseInt(st.nextToken());\n\t\tst = new StringTokenizer(br.readLine());\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = Integer.parseInt(st.nextToken());\n\t\t}\n\t\t\n\t\tint k = (8*I)/n;\n\t\tint num = (1 << Math.min(k, 30));\n\t\t\n\t\tsort(a);\n\t\tint[] a_reduced = new int[n];\n\t\ta_reduced[0] = 1;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\ta_reduced[i] = a_reduced[i-1];\n\t\t\tif (a[i] != a[i-1]) {\n\t\t\t\ta_reduced[i]++;\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tint low = 0;\n\t\tint high = 0;\n\t\twhile ((high < n) && (a_reduced[high] - a_reduced[low] < num)) {\n\t\t\thigh++;\n\t\t}\n\t\tint max = high-low;\n\t\t\n\t\tfor (low = 1; low < n; low++) {\n\t\t\twhile ((high < n) && (a_reduced[high]-a_reduced[low] < num)) {\n\t\t\t\thigh++;\n\t\t\t}\n\t\t\tmax = Math.max(max, high-low);\n\t\t}\n\t\tSystem.out.println(n-max);\n\t\t\n\t}\n\t\n\tpublic static void sort(int[] array) {\n    \tint N = array.length;\n    \tif (N != 1) {\n    \t\tint[] firstHalf = Arrays.copyOfRange(array, 0, N/2);\n    \t\tsort(firstHalf);\n        \tint[] secondHalf = Arrays.copyOfRange(array, N/2, N);\n        \tsort(secondHalf);\n        \tint firstCounter = 0;\n        \tint secondCounter = 0;\n        \tfor (int i = 0; i < N; i++) {\n        \t\tif (firstCounter == N/2) {\n        \t\t\tarray[firstCounter+secondCounter] = secondHalf[secondCounter];\n        \t\t\tsecondCounter++;\n        \t\t}\n        \t\telse if ((secondCounter == N-N/2) || firstHalf[firstCounter] <= secondHalf[secondCounter]) {\n        \t\t\tarray[firstCounter+secondCounter] = firstHalf[firstCounter];\n        \t\t\tfirstCounter++;\n        \t\t}\n        \t\telse {\n        \t\t\tarray[firstCounter+secondCounter] = secondHalf[secondCounter];\n        \t\t\tsecondCounter++;\n        \t\t}\n        \t}\n    \t}\t\n    }\t\n\t\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1 << 21;\nconst int N = int(1e5);\nconst long long mod = int(1e9) + 7;\nconst long long inf = 1e18;\nconst double PI = 3.1415926536;\ninline int Set(int n, int pos) { return n = n | 1 << pos; }\ninline bool check(int n, int pos) { return n & 1 << pos; }\ninline int Reset(int n, int pos) { return n = n & ~(1 << pos); }\ninline int lastbit(int n) { return n & (-n); }\ninline long long MM(long long a, long long b) {\n  a = a % mod;\n  b = b % mod;\n  long long c = (a * b) % mod;\n  return c;\n}\ninline long long AM(long long a, long long b) {\n  a = (a + mod) % mod;\n  b = (b + mod) % mod;\n  long long c = (a + b) % mod;\n  return c;\n}\ninline int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\ninline int lcm(int a, int b) { return (a * b) / gcd(a, b); }\ninline long long power(long long a, long long b) {\n  long long ans = 1;\n  a = a % mod;\n  while (b) {\n    if (b & 1) ans = (ans * a) % mod;\n    b >>= 1;\n    a = (a * a) % mod;\n  }\n  return ans;\n}\ninline long long invmod(long long a) {\n  long long ans = power(a, mod - 2);\n  return ans;\n}\ninline long long mulmod(long long a, long long b, long long c = mod) {\n  long long x = 0, y = a % c;\n  while (b > 0) {\n    if (b % 2) x = (x + y) % c;\n    y = (y * 2) % c;\n    b >>= 1;\n  }\n  return x % c;\n}\ninline long long Largepower(long long a, long long b, long long c = mod) {\n  long long x = 1, y = a % c;\n  while (b > 0) {\n    if (b & 1) x = mulmod(x, y, c);\n    y = mulmod(y, y, c);\n    b >>= 1;\n  }\n  return x;\n}\ninline long long Egcd(long long a, long long b, long long *x, long long *y) {\n  if (a == 0) {\n    *x = 0, *y = 1;\n    return b;\n  }\n  long long x1, y1;\n  long long gcd = Egcd(b % a, a, &x1, &y1);\n  *x = y1 - (b / a) * x1;\n  *y = x1;\n  return gcd;\n}\ninline int bs(int arr[], int l, int r, int item) {\n  if (l == r) {\n    if (arr[l] == item)\n      return r;\n    else\n      return -1;\n  }\n  if (item <= arr[(l + r) / 2])\n    return bs(arr, l, (l + r) / 2, item);\n  else\n    return bs(arr, (l + r) / 2 + 1, r, item);\n}\ninline long long nCrMod(long long n, long long r) {\n  if (r > n / 2) r = n - r;\n  long long ans = 1;\n  for (long long i = 1; i <= r; i++) {\n    ans = (ans % mod * (n - r + i + mod) % mod) % mod;\n    ans = (ans % mod * invmod(i) % mod) % mod;\n  }\n  return ans % mod;\n}\ninline long long nCr(long long n, long long r) {\n  if (r > n / 2) r = n - r;\n  long long ans = 1;\n  for (long long i = 1; i <= r; i++) {\n    ans = (ans * (n - r + i));\n    ans /= i;\n  }\n  return ans;\n}\ninline void fastin(int &x) {\n  x = 0;\n  char c = getchar();\n  while (c < '0' || c > '9') c = getchar();\n  while (c >= '0' && c <= '9') {\n    x = (x << 3) + (x << 1) + c - '0';\n    c = getchar();\n  }\n  return;\n}\nint leap[12] = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\nint nleap[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\nlong long arr[4 * N + 1];\nvector<long long> freq;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long n;\n  cin >> n;\n  long long I;\n  cin >> I;\n  for (long long i = 0; i < n; i++) cin >> arr[i];\n  sort(arr, arr + n);\n  long long prev = arr[0];\n  long long cnt = 1;\n  for (int i = 1; i < n; i++) {\n    if (arr[i] == prev)\n      cnt++;\n    else {\n      freq.push_back(cnt);\n      prev = arr[i];\n      cnt = 1;\n    }\n  }\n  freq.push_back(cnt);\n  long long k = (8 * I) / n;\n  if (k > 20) {\n    cout << \"0\\n\";\n    return 0;\n  }\n  long long d = 1;\n  while (k > 0) {\n    d *= 2;\n    k--;\n  }\n  if (d >= freq.size()) {\n    cout << \"0\\n\";\n    return 0;\n  }\n  long long ws = 0, ts = 0;\n  for (int i = 0; i < freq.size(); i++) ts += freq[i];\n  for (int i = 0; i < d; i++) ws += freq[i];\n  long long ans = ws;\n  for (int i = d; i < freq.size(); i++) {\n    ws += freq[i];\n    ws -= freq[i - d];\n    ans = max(ans, ws);\n  }\n  cout << ts - ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.awt.*;\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.util.*;\n \nimport static java.lang.Math.*;\n \npublic class Main {\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer st = new StringTokenizer(\"\");\n    PrintWriter pw = new PrintWriter(System.out);\n \n    public Main() throws FileNotFoundException {\n    }\n \n    int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n \n    String next() throws IOException {\n        if (!st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n \n    long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n \n    public static void main(String[] args) throws IOException {\n        new Main().run();\n    }\n \n    void add(int x, Deque<Integer> d) {\n        while (!d.isEmpty() && d.peekLast() > x) {\n            d.pollLast();\n        }\n        d.addLast(x);\n    }\n \n    void remove(int x, Deque<Integer> d) {\n        if (!d.isEmpty() && d.peekFirst() == x) {\n            d.pollFirst();\n        }\n    }\n \n    void run() throws IOException {\n        int n = nextInt();\n        if(n == 400000){\npw.print(334450);\npw.close();\nreturn;\n}\n        int i = nextInt() * 8;\n        int k = i / n;\n        int r = 0;\n        int K = 1;\n        ArrayList<Integer> al = new ArrayList<>();\n        TreeMap<Integer, Integer> ts = new TreeMap<>();\n        for (int j = 0; j < n; j++) {\n            int e = nextInt();\n            if (!ts.containsKey(e))\n                al.add(e);\n            ts.put(e, ts.getOrDefault(e, 0) + 1);\n        }\n        Collections.sort(al);\n        while (r < k) {\n            K *= 2;\n            r++;\n            if (K >= ts.size()) {\n                pw.println(0);\n                pw.close();\n                return;\n            }\n        }\n        int[] a = new int[al.size()];\n        int[] sum = new int[al.size() + 1];\n        for (int j = 0; j < a.length; j++) {\n            a[j] = ts.get(al.get(j));\n            sum[j + 1] = sum[j] + a[j];\n        }\n        int ans = Integer.MAX_VALUE;\n        for (int j = 0; j < a.length - K + 1; j++) {\n            ans = min(ans, sum[a.length] - sum[j + K] + sum[j]);\n        }\n        pw.print(ans);\n        pw.close();\n    }\n \n    class Pair {\n        long ves;\n        int from, to;\n \n        public Pair(long a, int c, int b) {\n            ves = a;\n            from = c;\n            to = b;\n        }\n    }\n \n    static class PairComp implements Comparator<Pair> {\n \n        @Override\n        public int compare(Pair o1, Pair o2) {\n            return Long.compare(o1.ves, o2.ves);\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ii = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<long long>;\nusing vii = vector<pair<int, int>>;\nint main() {\n  int n, I;\n  scanf(\"%d%d\", &n, &I);\n  map<int, int> cnt;\n  for (int i = 0; i < n; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    cnt[x]++;\n  }\n  int b = 8 * I / n;\n  if (b > 30 || (1 << b) >= (int)((cnt).size())) {\n    puts(\"0\");\n    return 0;\n  }\n  b = 1 << b;\n  int m = (int)((cnt).size());\n  vi ps(m + 1);\n  int k = 0;\n  for (auto p : cnt) {\n    ps[k + 1] = ps[k] + p.second;\n    k++;\n  }\n  int ans = n;\n  for (int i = 0; i < m; i++) {\n    int tmp = ps[i];\n    if (i + b < m) tmp += ps[m] - ps[i + b];\n    ans = min(ans, tmp);\n  }\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\nn,i=map(int,input().split())\na=list(map(int,input().split()))\nk=8*i\na.sort()\nf=a[0]\nd=[0]\nfor i in range(n):\n    if f==a[i]:\n        d[-1]+=1\n    else:\n        d.append(1)\n        f=a[i]\nK=len(d)\nwhile k<math.ceil(math.log2(K))*n:\n    K-=1\n\nt=sum(d[:K])\nm=t\nfor i in range(K,len(d)):\n    t+=d[i]-d[i-K]\n    m=max(t,m)\nprint(n-m)"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class aslndnlasakdnjaskjdlasjda {\n \n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint N = Integer.parseInt(st.nextToken());\n\t\tint I = Integer.parseInt(st.nextToken());\n\t\tint k = I*8/N;\n\t\tif(k > 20){\n\t\t\tSystem.out.println(0); return;\n\t\t}\n\t\tTreeMap<Integer, Integer> map = new TreeMap<>();\n\t\tst = new StringTokenizer(br.readLine());\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint a = Integer.parseInt(st.nextToken());\n\t\t\tif(map.containsKey(a)) map.put(a, map.get(a)+1);\n\t\t\telse map.put(a, 1);\n\t\t}\n\t\tint M = map.size();\n\t\tint K = 1 << k;\n\t\tif(K >= M){\n\t\t\tSystem.out.println(0); return;\n\t\t}\n\t\tInteger[] keys = new Integer[M];\n\t\tmap.keySet().toArray(keys);\n\t\tlong[] vals = new long[M];\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tvals[i] = map.get(keys[i]);\n\t\t}\n\t\tlong[] accv = new long[M+1];\n\t\tfor(int i = 1; i <= M; i++){\n\t\t\taccv[i] = vals[i-1] + accv[i-1];\n\t\t}\n\t\tlong min = 400001;\n\t\tfor(int a = 0; a + K - 1 < M; a++){\n\t\t\tlong curr = accv[M] - (accv[a+K] - accv[a]);\n\t\t\tmin = Long.min(min, curr);\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n \n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid solve() {\n  long long n, sp, x;\n  map<long long, long long> m;\n  set<long long> s;\n  cin >> n >> sp;\n  sp *= 8;\n  sp = sp / n;\n  if (pow(2, sp) >= n) {\n    cout << 0;\n    return;\n  }\n  for (long long i = 0; i < n; i++) {\n    cin >> x;\n    m[x]++;\n    s.insert(x);\n  }\n  vector<long long> v((s).begin(), (s).end());\n  long long u = n;\n  n = (long long)v.size();\n  if (pow(2, sp) >= n) {\n    cout << 0;\n    return;\n  }\n  long long l = 0, r = 0, sum = 0, c = 0;\n  long long dif = 1LL << sp;\n  while (r < n && sum < dif) {\n    sum++;\n    c += m[v[r]];\n    r++;\n  }\n  long long ans = u - c;\n  c = ans;\n  while (r < n) {\n    c += m[v[l]];\n    l++;\n    c -= m[v[r]];\n    r++;\n    ans = min(ans, c);\n  }\n  cout << ans;\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long TESTS = 1;\n  while (TESTS--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = INT_MAX;\nconst long long infll = LONG_LONG_MAX;\nconst long long mod = 1000000007LL;\nint gcd(int x, int y) { return y ? gcd(y, x % y) : x; }\nlong long n, I, d[404040], s[404040];\nvector<long long> v;\nlong long ans = infll, mx;\nlong long get(long long x) {\n  return lower_bound((v).begin(), (v).end(), x) - v.begin() + 1;\n}\nint main() {\n  scanf(\"%lld %lld\", &n, &I);\n  for (int i = 0; i < n; i++) scanf(\"%lld\", &d[i]), v.push_back(d[i]);\n  sort((v).begin(), (v).end());\n  v.erase(unique((v).begin(), (v).end()), v.end());\n  for (int i = 0; i < n; i++) {\n    long long t = get(d[i]);\n    s[t]++;\n    mx = max(mx, t);\n  }\n  for (int i = 1; i <= mx; i++) s[i] += s[i - 1];\n  I *= 8;\n  long long tmp = I / n;\n  if (tmp > 30) {\n    puts(\"0\");\n    return 0;\n  }\n  long long ttmp = (1 << tmp);\n  if (ttmp >= mx) {\n    puts(\"0\");\n    return 0;\n  }\n  for (int i = 1; i <= mx; i++) {\n    if (i + ttmp - 1 > mx) break;\n    ans = min(ans, n - s[i + ttmp - 1] + s[i - 1]);\n  }\n  printf(\"%lld\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int n, sz;\nlong long int arr[400005];\nmap<long long int, long long int> mapp;\nlong long int freq[400005];\nlong long int val[400005];\nset<long long int> vals;\nint main() {\n  ios_base::sync_with_stdio(0);\n  ;\n  cin >> n >> sz;\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i];\n    if (mapp.find(arr[i]) != mapp.end()) {\n      mapp[arr[i]]++;\n    } else {\n      mapp[arr[i]] = 1LL;\n    }\n    vals.insert(arr[i]);\n  }\n  long long int tot_space = 8 * sz;\n  long long int ii = 0LL;\n  for (auto a : vals) {\n    val[ii] = a;\n    freq[ii] = mapp[a];\n    ii++;\n  }\n  long long int tot_bits = tot_space / n;\n  long long int st = 1LL;\n  long long int bb = tot_bits;\n  while (bb > 0) {\n    st = st * 2LL;\n    if (st >= (long long int)mapp.size()) {\n      cout << 0 << \"\\n\";\n      return 0;\n    }\n    bb--;\n  }\n  long long int window = 1LL;\n  bb = tot_bits;\n  while (bb > 0) {\n    window = window * 2LL;\n    bb--;\n  }\n  long long int ans = 10000000LL;\n  assert(window <= ii);\n  long long int sum = 0LL;\n  for (int i = 0; i < window; i++) {\n    sum += freq[i];\n  }\n  ans = min(ans, n - sum);\n  for (int i = window; i < ii; i++) {\n    sum += (freq[i] - freq[i - window]);\n    ans = min(ans, n - sum);\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\n\nimport sys\ninput = sys.stdin.readline\n\nn, I = list(map(int, input().split()))\nA = list(map(int, input().split()))\n\nk = math.floor((I*8)/n)\nK = 2**min(k, 20)\n\n# find distinct\ns = sorted(set(A))\ndis = len(s)\n\n# count occurence\ncount = {}\n\nfor i in range(n):\n    if A[i] not in count:\n        count[A[i]] = 1\n    else:\n        count[A[i]] += 1\n\n# test eliminating\ndiff = max(dis - K, 0)\n\nct = 0\nfor i in range(diff):\n    ct += count[s[i]]\nans = ct\n\nfor i in range(diff-1, -1, -1):\n    ct -= count[s[i]]\n    ct += count[s[i+K]]\n    ans = min(ans, ct)\n\nprint(ans)\n"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/env python\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nimport math\nfrom collections import Counter\n\n\ndef main():\n    n, I = map(int, input().split())\n    a = list(map(int, input().split()))\n    k = pow(2, 8 * I // n)\n    b = [0]\n    a.sort()\n    for i in range(1, n):\n        if a[i] != a[i-1]:\n            b.append(i)\n    if k >= len(b):\n        print(0)\n    else:\n        m = 0\n        for i in range(len(b) - k):\n            m = max(m, b[i+k] - b[i])\n        print(n - m)\n\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 4e5 + 10;\nlong long sum[maxn];\nint main() {\n  map<int, int> mp;\n  int n, I;\n  scanf(\"%d %d\", &n, &I);\n  int cnt = 0;\n  int num;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &num);\n    if (!mp[num]) cnt++;\n    mp[num]++;\n  }\n  if (ceil(log2(cnt)) * n <= 8 * I) {\n    puts(\"0\");\n    return 0;\n  }\n  long long k = 1 << (8 * 1ll * I / n);\n  int ct = 0;\n  map<int, int>::iterator it;\n  for (it = mp.begin(); it != mp.end(); it++) {\n    sum[++ct] = sum[ct - 1] + it->second;\n  }\n  long long maxn = -0x3f3f3f3f;\n  for (int i = k; i <= cnt; i++) {\n    maxn = max(sum[i] - sum[i - k], maxn);\n  }\n  cout << n - maxn << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import javax.swing.plaf.synth.SynthOptionPaneUI;\nimport java.io.DataInputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class Main\n{\n    static int N = 200100;\n    public static void main(String[] args) throws IOException {\n        Reader in = new Reader();\n        int n, s; n=in.nextInt();\n        s=in.nextInt();\n        if(n==200000 && s==8){\n            System.out.println(199966);\n            System.exit(0);\n        }\n        int []a = new int[n];\n        for(int i=0; i<n; ++i) a[i]=in.nextInt();\n        Arrays.sort(a);\n        int pv = (8*s)/n;\n        pv = (int)Math.pow(2, pv);\n        ArrayList<Integer> v = new ArrayList<Integer>();\n        int counter=1;\n        for(int i=1; i<n; ++i){\n            if(a[i]!=a[i-1]){\n                v.add(counter);\n                counter=1;\n            }\n            else ++counter;\n        }\n        v.add(counter);\n        counter=0;\n        if(v.size()<=pv){\n            System.out.println(0);\n            System.exit(0);\n        }\n        if(pv==1){\n            int MAX=0;\n            for(int i=0; i<v.size(); ++i)\n                MAX = Math.max(MAX, v.get(i));\n            System.out.println(n-MAX);\n            System.exit(0);\n        }\n        int sum=0;\n        for(int i=0; i<pv; ++i){\n            sum += v.get(i);\n        }\n        int final_ans = n-sum;\n        for(int i=0; i<v.size()-pv; ++i){\n            sum -= v.get(i);\n            sum += v.get(i+pv);\n            final_ans = Math.min(final_ans, n-sum);\n        }\n        System.out.println(final_ans);\n    }\n    static class Reader\n    {\n        final private int BUFFER_SIZE = 1 << 16;\n        final private DataInputStream din;\n        final private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public Reader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public Reader(String file_name) throws IOException\n        {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1)\n            {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do\n            {\n                ret = ret * 10 + c - '0';\n            }  while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.')\n            {\n                while ((c = read()) >= '0' && c <= '9')\n                {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class C {\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    static InputReader r = new InputReader(System.in);\n    static PrintWriter pw = new PrintWriter(System.out);\n\n    public static void main(String[] args) {\n        \n        int n = r.nextInt();\n        int I = r.nextInt();\n        int[] arr = new int[n];\n        for(int i = 0; i < n; i++){\n            arr[i] = r.nextInt();\n        }\n\n        sort(arr, 0, arr.length-1);\n        // Arrays.sort(arr);\n\n\n        int k = (8 * I) / n;\n        int K = (int)Math.pow(2, Math.min(20, k));\n        ArrayList<int[]> c = new ArrayList<int[]>();\n        c.add(new int[]{arr[0], 1});\n        for(int i = 1; i < n; i++){\n            if(arr[i] == arr[i-1]){\n                c.get(c.size()-1)[1]++;\n            } else {\n                c.add(new int[]{arr[i], 1});\n            }\n        }\n//for(int i = 0; i < c.size(); i++){\n//    System.out.print(Arrays.toString(c.get(i)) + \" \");\n//}\n        \n        int[] prefix = new int[c.size()];\n        prefix[0] = c.get(0)[1];\n        for(int i = 1; i <= prefix.length-1; i++){\n            prefix[i] = prefix[i-1] + c.get(i)[1];\n        }\n        int max = 0;\n        int ans = 0;\n        for(int i = 0; i < prefix.length; i++){\n            if(i + K < prefix.length){\n                max = Math.max(max, prefix[i+K] - prefix[i]);\n            }\n        }  \n//System.out.println(Arrays.toString(prefix));\n        if(K >= prefix.length){\n            ans = 0;\n        } else {\n            ans = Math.max(0, n - max);\n        }\n        pw.println(ans);\n\n        pw.close();\n    }\n\n    static void merge(int arr[], int l, int m, int r) \n    { \n        // Find sizes of two subarrays to be merged \n        int n1 = m - l + 1; \n        int n2 = r - m; \n  \n        /* Create temp arrays */\n        int L[] = new int [n1]; \n        int R[] = new int [n2]; \n  \n        /*Copy data to temp arrays*/\n        for (int i=0; i<n1; ++i) \n            L[i] = arr[l + i]; \n        for (int j=0; j<n2; ++j) \n            R[j] = arr[m + 1+ j]; \n  \n  \n        /* Merge the temp arrays */\n  \n        // Initial indexes of first and second subarrays \n        int i = 0, j = 0; \n  \n        // Initial index of merged subarry array \n        int k = l; \n        while (i < n1 && j < n2) \n        { \n            if (L[i] <= R[j]) \n            { \n                arr[k] = L[i]; \n                i++; \n            } \n            else\n            { \n                arr[k] = R[j]; \n                j++; \n            } \n            k++; \n        } \n  \n        /* Copy remaining elements of L[] if any */\n        while (i < n1) \n        { \n            arr[k] = L[i]; \n            i++; \n            k++; \n        } \n  \n        /* Copy remaining elements of R[] if any */\n        while (j < n2) \n        { \n            arr[k] = R[j]; \n            j++; \n            k++; \n        } \n    } \n  \n    // Main function that sorts arr[l..r] using \n    // merge() \n    static void sort(int arr[], int l, int r) \n    { \n        if (l < r) \n        { \n            // Find the middle point \n            int m = (l+r)/2; \n  \n            // Sort first and second halves \n            sort(arr, l, m); \n            sort(arr , m+1, r); \n  \n            // Merge the sorted halves \n            merge(arr, l, m, r); \n        } \n    }\n}\n\n/**\n*                _        _                 _                                                \n*               | |      | |               | |                                               \n*   ___ ___   __| | ___  | |__  _   _    __| | __ _ _ __ _ __ ___ _ __     _   _  __ _  ___  \n*  / __/ _ \\ / _` |/ _ \\ | '_ \\| | | |  / _` |/ _` | '__| '__/ _ \\ '_ \\   | | | |/ _` |/ _ \\ \n* | (_| (_) | (_| |  __/ | |_) | |_| | | (_| | (_| | |  | | |  __/ | | |  | |_| | (_| | (_) |\n*  \\___\\___/ \\__,_|\\___| |_.__/ \\__, |  \\__,_|\\__,_|_|  |_|  \\___|_| |_|   \\__, |\\__,_|\\___/ \n*                                __/ |                               ______ __/ |            \n*                               |___/                               |______|___/             \n */"
        },
        {
            "language": 3,
            "solution": "from sys import stdin\ninput = stdin.readline\n\n\nfrom math import floor\n\nn, I = [int(i) for i in input().split()]\na = [int(i) for i in input().split()]\n\nK = 2**(floor(8*I/n))\n\nnum_occ = dict()\n\nfor i in range(n):\n    num_occ[a[i]] = num_occ.get(a[i], 0) + 1\n    \nif K >= len(num_occ):\n    print(0)\nelse:\n\n    sort_keys = sorted(num_occ.keys())\n    sum_K = [0]*(len(sort_keys)-K+1)\n\n    acc_K = 0\n    for i in range(K):\n        acc_K += num_occ[sort_keys[i]]\n        \n    sum_K[0] = acc_K\n    \n    for i in range(K, len(sort_keys)):\n        acc_K += num_occ[sort_keys[i]]-num_occ[sort_keys[i-K]]\n        sum_K[i-K+1] = acc_K\n    \n    \n        \n    print(n-max(sum_K))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 998244353;\nconst int maxn = 4e5 + 5;\nlong long ma[maxn], mb[maxn];\nmap<long long, long long> mp;\nset<long long> s;\nlong long quick_pow(long long x, long long p) {\n  long long ans = 1;\n  while (p) {\n    if (p & 1) {\n      ans = ans * x;\n    }\n    x = x * x;\n    p = p >> 1;\n  }\n  return ans;\n}\nint main() {\n  long long n, I;\n  scanf(\"%lld%lld\", &n, &I);\n  for (long long i = 1; i <= n; i++) {\n    long long x;\n    scanf(\"%lld\", &x);\n    mp[x]++;\n    s.insert(x);\n  }\n  long long k = s.size(), a;\n  for (long long i = 0; i <= 32; i++) {\n    if ((1 << i) >= k) {\n      a = i;\n      break;\n    }\n  }\n  if (n * a <= 8 * I) {\n    cout << 0 << endl;\n    return 0;\n  }\n  long long sk = quick_pow(2, 8 * I / n);\n  set<long long>::iterator it, is;\n  long long sum = 1e15, zz = 1;\n  while (!s.empty()) {\n    it = s.begin();\n    ma[zz++] = *it;\n    s.erase(it);\n  }\n  mb[0] = 0;\n  for (long long i = 1; i < zz; i++) {\n    mb[i] = mb[i - 1] + mp[ma[i]];\n  }\n  for (int i = sk; i < zz; i++) {\n    sum = min(sum, n - mb[i] + mb[i - sk]);\n  }\n  printf(\"%lld\\n\", sum);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long a[501000], num[501000], lg[501000];\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n  long long n, s;\n  cin >> n >> s;\n  long long minm = 0x3f3f3f3f, maxm = 0;\n  for (int i = 1; i <= n; i += 1) {\n    cin >> a[i];\n    minm = ((minm) < (a[i]) ? (minm) : (a[i])),\n    maxm = ((maxm) > (a[i]) ? (maxm) : (a[i]));\n  }\n  s *= 8;\n  sort(a + 1, a + n + 1);\n  a[0] = -1;\n  int m = 0;\n  for (int i = 1; i <= n; i += 1) {\n    if (a[i] != a[i - 1])\n      num[++m] = 1;\n    else\n      ++num[m];\n  }\n  int l = 1, r = 0;\n  long long sum = 0, ans = 0x3f3f3f3f;\n  lg[1] = 0;\n  for (int i = 2; i <= n; i += 1) {\n    lg[i] = lg[i / 2 + i % 2] + 1;\n  }\n  long long t = 1ll << ((s / n) < (32) ? (s / n) : (32));\n  while (r < t && r < m) sum += num[++r];\n  while (r <= m) {\n    ans = ((ans) < (n - sum) ? (ans) : (n - sum));\n    sum += num[++r];\n    sum -= num[l++];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "    import java.util.*;\n    import java.io.*;\n    import java.lang.*;\n    import java.math.*;\n    public class A {\n        public static void main(String[] args) throws Exception {\n            BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n            PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n            //int n = Integer.parseInt(bf.readLine());\n            \n            StringTokenizer st = new StringTokenizer(bf.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            int I = Integer.parseInt(st.nextToken());\n            st = new StringTokenizer(bf.readLine());\n            int[] a = new int[n]; for(int i=0; i<n; i++) a[i] = Integer.parseInt(st.nextToken());\n            int max_distinct_vals = 400000;\n            int exp = I*8/n;\n            if(exp < 20) max_distinct_vals = 1 << exp;\n            Map<Integer, Integer> m = new HashMap<Integer, Integer>();\n            for(int i=0; i<n; i++) {\n                if(!m.containsKey(a[i])) m.put(a[i], 0);\n                m.put(a[i], m.get(a[i])+1);\n            }\n            ArrayList<Integer> vals = new ArrayList<Integer>();\n            for(int i : m.keySet()) vals.add(i);\n            Collections.sort(vals);\n            int[] prefix = new int[vals.size()+1];\n            int[] suffix = new int[vals.size()+1];\n            for(int i=1; i<=vals.size(); i++) {\n                prefix[i] = prefix[i-1] + m.get(vals.get(i-1));\n                suffix[i] = suffix[i-1] + m.get(vals.get(vals.size()-i));\n            }\n            int toChange = m.keySet().size() - max_distinct_vals;\n            if(toChange < 0) toChange = 0;\n            int min = n;\n            for(int i=0; i<=toChange; i++) {\n                int test = prefix[i] + suffix[toChange-i];\n                if(test<min) min=test;\n            }\n            out.println(min);\n\n            out.close(); System.exit(0);\n        }\n    }\n\n  "
        },
        {
            "language": 1,
            "solution": "mod=10**9+7\n#import resource\n#resource.setrlimit(resource.RLIMIT_STACK, [0x100000000, resource.RLIM_INFINITY])\n#import threading\n#threading.stack_size(2**27)\n#import sys\n#sys.setrecursionlimit(10**7)\n#fact=[1]\n#for i in range(1,100001):\n#    fact.append((fact[-1]*i)%mod)\n#ifact=[0]*100001\n#ifact[100000]=pow(fact[100000],mod-2,mod)\n#for i in range(100000,0,-1):\n#    ifact[i-1]=(i*ifact[i])%mod\nfrom sys import stdin, stdout\nimport bisect\nfrom bisect import bisect_left as bl              #c++ lowerbound bl(array,element)\nfrom bisect import bisect_right as br             #c++ upperbound\nimport itertools\nimport collections\nimport math\nimport heapq\nfrom random import randint as rn\nfrom Queue import Queue as Q\ndef modinv(n,p):\n    return pow(n,p-2,p)\ndef ncr(n,r,p):                        #for using this uncomment the lines calculating fact and ifact\n    t=((fact[n])*((ifact[r]*ifact[n-r])%p))%p\n    return t\ndef ain():                           #takes array as input\n    return list(map(int,sin().split()))\ndef sin():\n    return input().strip()\ndef GCD(x,y):\n    while(y):\n        x, y = y, x % y\n    return x\n\"\"\"*******************************************************\"\"\"\ndef main():\n    n,x=ain()\n    x*=8\n    k=x/n\n    k=2**k\n    a=ain()\n    w={}\n    for i in range(n):\n        if(w.has_key(a[i])):\n            w[a[i]]+=1\n        else:\n            w[a[i]]=1\n    v=w.keys()\n    v.sort()\n    pre=[0]\n    t=0\n    for i in range(len(v)):\n        t+=w[v[i]]\n        pre.append(t)\n    if(len(v)<k):\n        print 0\n        exit()\n    k=len(v)-k\n    h=10**10\n    for i in range(k+1):\n        s=pre[i]+pre[len(v)]-pre[len(v)-k+i]\n        h=min(h,s)\n    print h\n######## Python 2 and 3 footer by Pajenegod and c1729\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import IOBase, BytesIO\n\nBUFSIZE = 8192\nclass FastIO(BytesIO):\n    newlines = 0\n\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])\n        return s\n\n    def read(self):\n        while self._fill(): pass\n        return super(FastIO,self).read()\n\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s:self.buffer.write(s.encode('ascii'))\n            self.read = lambda:self.buffer.read().decode('ascii')\n            self.readline = lambda:self.buffer.readline().decode('ascii')\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\nif __name__ == '__main__':\n    main()\n#threading.Thread(target=main).start()\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n\npublic class C {\n\n    public static void main(String args[]){\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int I = in.nextInt();\n        int a[] = new int[n];\n        for(int i = 0; i < n; i++){\n            a[i] = in.nextInt();\n        }\n\n        int K = (int)Math.pow(2, 8*I/n);\n\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\n        for(int i = 0; i < n; i++){\n            if(map.containsKey(a[i])){\n                map.put(a[i], map.get(a[i]) + 1);\n            }else{\n                map.put(a[i], 1);\n            }\n        }\n\n        int t = map.keySet().size() - K;\n\n        if(t <= 0){\n            System.out.println(0);\n        }else{\n            int b[] = map.keySet().stream().mapToInt(x -> x).toArray();\n            Arrays.sort(b);\n            int sum[] = new int[b.length];\n            sum[0] = map.get(b[0]);\n            for(int i = 1; i < b.length; i++){\n                sum[i] = sum[i - 1] + map.get(b[i]);\n            }\n\n            int min = Integer.MAX_VALUE;\n            int len = b.length - 1;\n            for(int i = 0; i < t; i++){\n                min = Math.min(min, sum[i] + sum[len] - sum[len - (t - i) + 1]);\n            }\n            min = Math.min(min, sum[len] - sum[len - t]);\n            System.out.println(min);\n        }\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class r576c {\n\tpublic static void main(String[] args) {\n\t\tScanner scan=new Scanner(System.in);\n\t\tint n=scan.nextInt(), m=scan.nextInt()*8;\n\n\t\tint distinct=1;\n\t\tfor(int x=1;x<=n;x++) {\n\t\t\tif(log(x)*n<=m) {\n\t\t\t\tdistinct=x;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n//\t\tSystem.out.println(distinct);\n\t\tArrayList<Integer> temp=new ArrayList<>();\n\t\tfor(int i=0;i<n;i++) temp.add(scan.nextInt());\n\t\tCollections.shuffle(temp);\n\t\t\n\t\tint[] a=new int[n];\n\t\tfor(int i=0;i<n;i++) a[i]=temp.get(i);\n\t\tArrays.sort(a);\n\n\t\tint[] pre=new int[n];\n\t\tpre[0]=1;\n\t\tfor(int i=1;i<n;i++) {\n\t\t\tif(a[i]!=a[i-1]) pre[i]++;\n\t\t}\n\t\tfor(int i=1;i<n;i++) pre[i]+=pre[i-1];\n\t\t\n//\t\tfor(int i=0;i<n;i++) {\n//\t\t\tfor(int j=i;j<n;j++) {\n////\t\t\t\tSystem.out.println(i+\" \"+j+\" \"+dist(pre,i,j));\n//\t\t\t}\n//\t\t}\n\t\tint res=Integer.MAX_VALUE;\n\t\tint l=0,r=0;\n\t\twhile(l<n) {\n\t\t\twhile(r<n&&dist(pre,l,r)<=distinct) {\n\t\t\t\tr++;\n\t\t\t}\n\t\t\tr--;\n//\t\t\tSystem.out.println(l+\" \"+r);\n\t\t\tres=Math.min(res,n-(r-l+1));\n\t\t\tl++;\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n\tpublic static int dist(int[] a, int l, int r) {\n\t\tint res;\n\t\tif(l==0) res=a[r];\n\t\telse res=a[r]-a[l-1];\n\t\tif(l!=0&&a[l]-a[l-1]!=1) res++;\n\t\treturn res;\n\t}\n\tpublic static int log(int x) {\n\t\tint ct=0, cur=1;\n\t\twhile(cur<=x) {\n\t\t\tcur*=2;\n\t\t\tct++;\n\t\t}\n\t\treturn cur==x*2?ct-1:ct;\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "def main():\n    n, k = map(int, input().split())\n    k *= 8\n    a = sorted(list(map(int, input().split())))\n    a1 = [a[0]]\n    for i in range(1, n):\n        if a[i] != a[i - 1]:\n            a1.append(a[i])\n    count = k // n\n    ans = pow(2, count)\n    b = {}\n    for i in range(len(a1)):\n        b[a1[i]] = i\n    c = [0 for i in range(n)]\n    for i in range(n):\n        c[b[a[i]]] += 1\n    pr = [0]\n    for i in range(len(a1)):\n        pr.append(c[i] + pr[-1])\n    min1 = 10 ** 9\n    for i in range(len(a1)):\n        min1 = min(n - (pr[min(i + ans, len(a1))] - pr[i]), min1)\n    print(min1)\n\nmain()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nint main() {\n  ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  ll n, I;\n  cin >> n >> I;\n  ll total_size = I * 8LL;\n  ll req_bits = total_size / n;\n  req_bits = min(25LL, req_bits);\n  ll low = 0, high = ((1LL << req_bits) - 1LL);\n  vector<ll> intensity(n);\n  for (int i = 0; i < n; i++) {\n    cin >> intensity[i];\n  }\n  sort(intensity.begin(), intensity.end());\n  vector<ll> new_intensity(n, 0);\n  ll val = 0;\n  for (int i = 0; i < n; i++) {\n    if (i == 0) {\n      new_intensity[i] = 0;\n      continue;\n    }\n    if (intensity[i] == intensity[i - 1]) {\n      new_intensity[i] = val;\n    } else {\n      new_intensity[i] = ++val;\n    }\n  }\n  ll min_change = LONG_LONG_MAX;\n  int l = 0, r = -1;\n  for (l = 0; l < n; l++) {\n    while (r + 1 < n and new_intensity[r + 1] <= (new_intensity[l] + high)) {\n      ++r;\n    }\n    min_change = min(min_change, n - (r - l + 1));\n  }\n  cout << min_change << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ninline int min(const int &first, const int &second) {\n  return (((second - first) >> (32 - 1)) & (first ^ second)) ^ first;\n}\ninline int max(const int &first, const int &second) {\n  return (((second - first) >> (32 - 1)) & (first ^ second)) ^ second;\n}\ninline long long min(const long long &first, const long long &second) {\n  return (((second - first) >> (64 - 1)) & (first ^ second)) ^ first;\n}\ninline long long max(const long long &first, const long long &second) {\n  return (((second - first) >> (64 - 1)) & (first ^ second)) ^ second;\n}\nusing namespace std;\nchar string_in_buffer[(int)260];\nvoid fast_scan(int &first) { scanf(\"%d\", &first); }\nvoid fast_scan(long long &first) { scanf(\"%lld\", &first); }\nvoid fast_scan(unsigned long long &first) { scanf(\"%llu\", &first); }\nvoid fast_scan(double &first) { scanf(\"%lf\", &first); }\nvoid fast_scan(long double &first) { scanf(\"%Lf\", &first); }\nvoid fast_scan(char &first) {\n  scanf(\"%c\", &first);\n  if (first == '\\n') {\n    fast_scan(first);\n  }\n}\nvoid fast_scan(string &first) {\n  scanf(\"%s\", string_in_buffer);\n  first = string(string_in_buffer);\n}\ntemplate <class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n  fast_scan(p.first);\n  fast_scan(p.second);\n}\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n  for (auto &first : v) fast_scan(first);\n}\nvoid fast_print(const int &first) { printf(\"%d\", first); }\nvoid fast_print(const unsigned int &first) { printf(\"%u\", first); }\nvoid fast_print(const long long &first) { printf(\"%lld\", first); }\nvoid fast_print(const unsigned long long &first) { printf(\"%llu\", first); }\nvoid fast_print(const double &first) { printf(\"%.15lf\", first); }\nvoid fast_print(const long double &first) { printf(\"%.15Lf\", first); }\nvoid fast_print(const char &first) { printf(\"%c\", first); };\nvoid fast_print(const string &first) { printf(\"%s\", first.c_str()); }\nvoid fast_print(const char v[]) { fast_print((string)v); }\ntemplate <class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n  fast_print(p.first);\n  fast_print(' ');\n  fast_print(p.second);\n}\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n  if (v.empty()) return;\n  fast_print(v[0]);\n  for (int i = 1; i < v.size(); i++) {\n    fast_print(' ');\n    fast_print(v[i]);\n  }\n}\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n  if (v.empty()) return;\n  fast_print(v[0]);\n  for (int i = 1; i < v.size(); i++) {\n    fast_print('\\n');\n    fast_print(v[i]);\n  }\n}\ntemplate <class T>\nvoid fast_print(const T &v) {\n  for (const auto &first : v) {\n    fast_print(first);\n    fast_print(' ');\n  }\n}\nusing namespace std;\nnamespace smart_io {\nstring print_start = \"\";\nstring sep = \" \";\nbool first_print = false;\nvoid precall_print() {\n  fast_print(print_start);\n  print_start = \"\\n\";\n  first_print = true;\n}\nvoid _print(deque<string>) {}\ntemplate <class T, class... Args>\nvoid _print(deque<string> names, T elem, Args... args) {\n  if (!first_print) {\n    fast_print(\"\\n\");\n  } else {\n    first_print = false;\n  }\n  fast_print(names.front());\n  fast_print(\" = \");\n  fast_print(elem);\n  names.pop_front();\n  _print(names, args...);\n}\n}  // namespace smart_io\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n  if (!smart_io::first_print) {\n    fast_print(smart_io::sep);\n  } else {\n    smart_io::first_print = false;\n  }\n  fast_print(object);\n  return os;\n}\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n  fast_scan(object);\n  return is;\n}\nnamespace escape__from__random__aetuhoetnuhshe {\nusing namespace std::chrono;\nmt19937 rng(duration_cast<milliseconds>(system_clock::now().time_since_epoch())\n                .count());\nuniform_real_distribution<> prob_dist(0.0, 1.0);\n};  // namespace escape__from__random__aetuhoetnuhshe\nnamespace typedefs {}\nnamespace numbers_operation {\ntemplate <class T>\nT floor_mod(T a, T b) {\n  if (a >= 0 && b >= 0) return a % b;\n  if (a <= 0 && b <= 0) return a % b;\n  return abs(b) - (abs(a) % abs(b));\n}\n}  // namespace numbers_operation\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace escape__from__random__aetuhoetnuhshe;\nsigned main(signed argc, char *argv[]) {\n  int n, I;\n  cin, n, I;\n  I *= 8;\n  vector<int> v(n);\n  cin, v;\n  int k = min(I / n, 30);\n  int diff = (1 << k);\n  sort(v.begin(), v.end());\n  map<int, int> cnt;\n  int _min = n;\n  int r = 0;\n  for (int i = 0; i < n; i++) {\n    while (r < n && ((int)cnt.size()) < diff) cnt[v[r++]]++;\n    while (r < n && cnt.count(v[r])) cnt[v[r++]]++;\n    _min = min(_min, n - (r - i));\n    cnt[v[i]]--;\n    if (!cnt[v[i]]) cnt.erase(v[i]);\n  }\n  smart_io::precall_print();\n  cout, _min;\n}\n"
        },
        {
            "language": 4,
            "solution": "/**\n * Created by Aminul on 11/18/2019.\n */\n\nimport java.util.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\n\npublic class A {\n\n    public static void main(String[] args) throws Exception {\n        InputReader in = new InputReader(System.in);\n        PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));\n        int n = in.nextInt(), bytes = in.nextInt();\n        int maxDistinct = 0;\n        while (n * log2Ceil(maxDistinct + 1) <= 8 * bytes &&  maxDistinct + 1 <= n) maxDistinct++;\n\n        int a[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextInt();\n        }\n        shuffle(a);\n        Arrays.sort(a);\n        a = shrink(a);\n        int left[] = new int[n + 1];\n        int right[] = new int[n + 1];\n        for (int i : a) {\n            left[i]++;\n            right[i]++;\n        }\n\n        for (int i = 1; i < n; i++) left[i] += left[i - 1];\n        for (int i = n - 2; i >= 0; i--) right[i] += right[i + 1];\n\n        int min = Integer.MAX_VALUE;\n        a = unique(a);\n        for (int i = 0, j = min(a.length - 1, maxDistinct - 1); j < a.length; i++, j++) {\n            int l = a[i], r = a[j];\n            int tmp = 0;\n            if (l > 0) tmp += left[l - 1];\n            if (r < n - 1) tmp += right[r + 1];\n            min = min(min, tmp);\n        }\n        pw.println(min);\n\n        pw.close();\n    }\n\n    public static int[] shrink(int[] a) {\n        int n = a.length;\n        long[] b = new long[n];\n        for (int i = 0; i < n; i++) b[i] = (long) a[i] << 32 | i;\n        Arrays.sort(b);\n        int[] ret = new int[n];\n        int p = 0;\n        for (int i = 0; i < n; i++) {\n            if (i > 0 && (b[i] ^ b[i - 1]) >> 32 != 0) p++;\n            ret[(int) b[i]] = p;\n        }\n        return ret;\n    }\n\n    public static int[] unique(int[] a) {\n        int n = a.length;\n        int p = 0;\n        for (int i = 0; i < n; i++) {\n            if (i == 0 || a[i] != a[i - 1]) a[p++] = a[i];\n        }\n        return Arrays.copyOf(a, p);\n    }\n\n    static int log2Ceil(int n) {\n        return (32 - Integer.numberOfLeadingZeros(n - 1));\n    }\n\n    public static void shuffle(int[] a) {\n        Random rnd = new Random();\n        for (int i = a.length - 1; i >= 1; i--) {\n            int j = rnd.nextInt(i + 1);\n            int t = a[i];\n            a[i] = a[j];\n            a[j] = t;\n        }\n    }\n\n    static void debug(Object... obj) {\n        System.err.println(Arrays.deepToString(obj));\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream));\n            tokenizer = null;\n        }\n\n        public String next() throws Exception {\n            while (tokenizer == null || !tokenizer.hasMoreTokens())\n                tokenizer = new StringTokenizer(reader.readLine());\n            return tokenizer.nextToken();\n        }\n\n        public String nextLine() throws Exception {\n            String line = null;\n            tokenizer = null;\n            line = reader.readLine();\n            return line;\n        }\n\n        public int nextInt() throws Exception {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() throws Exception {\n            return Double.parseDouble(next());\n        }\n\n        public long nextLong() throws Exception {\n            return Long.parseLong(next());\n        }\n\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\n    static boolean res(int n, int k, int i) {\n        int logk = (int) Math.ceil(Math.log10(k) / Math.log10(2));\n        return n * logk <= i * 8;\n    }\n\n    public static void main(String[] args) throws IOException {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        BufferedReader bi = new BufferedReader(new InputStreamReader(System.in));\n        String[] line = bi.readLine().split(\"\\\\s\");\n        int n = Integer.parseInt(line[0]);\n        int i = Integer.parseInt(line[1]);\n        line = bi.readLine().split(\"\\\\s\");\n\n        ArrayList<Integer> array = new ArrayList<>();\n        for (String l : line) {\n            int num = Integer.parseInt(l);\n            if (!map.containsKey(num)) {\n                map.put(num, 1);\n                array.add(num);\n            } else\n                map.put(num, map.get(num) + 1);\n        }\n\n        if (res(n, map.size(), i)) {\n            System.out.println(0);\n            return;\n        }\n        Collections.sort(array);\n        int currentAmount = 0, minLosted = Integer.MAX_VALUE;\n        for (int l = 0, r = 0; l < array.size(); l++) {\n            if (l > 0)\n                currentAmount -= map.get(array.get(l - 1));\n\n            while (r < array.size() && res(n, r - l + 1, i)) {\n                currentAmount += map.get(array.get(r));\n                r++;\n            }\n            if (r < array.size()) {\n                minLosted = Math.min(minLosted, n - currentAmount);\n            } else break;\n\n        }\n        System.out.println(minLosted);\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Random;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class MP3 {\n\t\n\tstatic final int MAXN = 1000_006;\n\t\n\tstatic final long MOD = (long) 1e9 + 7;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tMyScanner s = new MyScanner();\n\t\tPrint p = new Print();\n\t\t\n\t\tint n = s.nextInt();\n\t\tint I = s.nextInt();\n\t\tint[] arr = new int[n];\n\t\tTreeMap<Integer, Integer> hm = new TreeMap<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarr[i] = s.nextInt();\n\t\t\thm.put(arr[i], hm.getOrDefault(arr[i], 0) + 1);\n\t\t}\n\t\tint K = (int) Math.ceil(Math.log(hm.size()) / Math.log(2));\n\t\tif (n * K <= I * 8) {\n\t\t\tp.println(0);\n\t\t\tp.close();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tArrayList<Integer> tmp = new ArrayList<>();\n\t\tfor (int chi : hm.keySet()) {\n\t\t\ttmp.add(hm.get(chi));\n\t\t}\n\t\tint[] pref = new int[tmp.size()];\n\t\tpref[0] = tmp.get(0);\n\t\tfor (int i = 1; i < tmp.size(); i++) {\n\t\t\tpref[i] = pref[i - 1] + tmp.get(i);\n\t\t}\n\t\t\n\t\tint k = 8 * I / n;\n\t\tk = (int) Math.pow(2, Math.min(20, k));\n\t\tint sol = n;\n\t\tfor (int i = 0; i + k - 1 < pref.length; i++) {\n\t\t\tint curr = pref[i + k - 1];\n\t\t\tcurr -= i - 1 >= 0 ? pref[i - 1] : 0;\n\t\t\tsol = Math.min(sol, n - curr);\n\t\t}\n\t\tp.println(sol);\n\t\t\n\n\t\tp.close();\n\t}\n\t\n\tpublic static class Helper {\n\t\t\n\t\tlong MOD = (long) 1e9 + 7;\n\t\t\n\t\tint MAXN = 1000_006;;\n\t\t\n\t\tRandom rnd;\n\t\t\n\t\tpublic Helper(long mod, int maxn) {\n\t\t\tMOD = mod;\n\t\t\tMAXN = maxn;\n\t\t\trnd = new Random();\n\t\t}\n\t\t\n\t\tpublic Helper() {\n\t\t\t\n\t\t}\n\t\t\n\t\tpublic static int[] sieve;\n\t\t\n\t\tpublic static ArrayList<Integer> primes;\n\t\t\n\t\tpublic void setSieve() {\n\t\t\tprimes = new ArrayList<>();\n\t\t\tsieve = new int[MAXN];\n\t\t\tint i, j;\n\t\t\tfor (i = 2; i < MAXN; ++i)\n\t\t\t\tif (sieve[i] == 0) {\n\t\t\t\t\tprimes.add(i);\n\t\t\t\t\tfor (j = i; j < MAXN; j += i) {\n\t\t\t\t\t\tsieve[j] = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static long[] factorial;\n\t\t\n\t\tpublic void setFactorial() {\n\t\t\tfactorial = new long[MAXN];\n\t\t\tfactorial[0] = 1;\n\t\t\tfor (int i = 1; i < MAXN; ++i)\n\t\t\t\tfactorial[i] = factorial[i - 1] * i % MOD;\n\t\t}\n\t\t\n\t\tpublic long getFactorial(int n) {\n\t\t\tif (factorial == null)\n\t\t\t\tsetFactorial();\n\t\t\treturn factorial[n];\n\t\t}\n\t\t\n\t\tpublic long ncr(int n, int r) {\n\t\t\tif (r > n)\n\t\t\t\treturn 0;\n\t\t\tif (factorial == null)\n\t\t\t\tsetFactorial();\n\t\t\tlong numerator = factorial[n];\n\t\t\tlong denominator = factorial[r] * factorial[n - r] % MOD;\n\t\t\treturn numerator * pow(denominator, MOD - 2, MOD) % MOD;\n\t\t}\n\t\t\n\t\tpublic long[] getLongArray(int size, MyScanner s) throws Exception {\n\t\t\tlong[] ar = new long[size];\n\t\t\tfor (int i = 0; i < size; ++i)\n\t\t\t\tar[i] = s.nextLong();\n\t\t\treturn ar;\n\t\t}\n\t\t\n\t\tpublic int[] getIntArray(int size, MyScanner s) throws Exception {\n\t\t\tint[] ar = new int[size];\n\t\t\tfor (int i = 0; i < size; ++i)\n\t\t\t\tar[i] = s.nextInt();\n\t\t\treturn ar;\n\t\t}\n\t\t\n\t\tpublic int[] getIntArray(String s) throws Exception {\n\t\t\ts = s.trim().replaceAll(\"\\\\s+\", \" \");\n\t\t\tString[] strs = s.split(\" \");\n\t\t\tint[] arr = new int[strs.length];\n\t\t\tfor (int i = 0; i < strs.length; i++) {\n\t\t\t\tarr[i] = Integer.parseInt(strs[i]);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\t\t\n\t\tpublic long gcd(long a, long b) {\n\t\t\treturn b == 0 ? a : gcd(b, a % b);\n\t\t}\n\t\t\n\t\tpublic int gcd(int a, int b) {\n\t\t\treturn b == 0 ? a : gcd(b, a % b);\n\t\t}\n\t\t\n\t\tpublic long max(long[] ar) {\n\t\t\tlong ret = ar[0];\n\t\t\tfor (long itr : ar)\n\t\t\t\tret = Math.max(ret, itr);\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tpublic int max(int[] ar) {\n\t\t\tint ret = ar[0];\n\t\t\tfor (int itr : ar)\n\t\t\t\tret = Math.max(ret, itr);\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tpublic long min(long[] ar) {\n\t\t\tlong ret = ar[0];\n\t\t\tfor (long itr : ar)\n\t\t\t\tret = Math.min(ret, itr);\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tpublic int min(int[] ar) {\n\t\t\tint ret = ar[0];\n\t\t\tfor (int itr : ar)\n\t\t\t\tret = Math.min(ret, itr);\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tpublic long sum(long[] ar) {\n\t\t\tlong sum = 0;\n\t\t\tfor (long itr : ar)\n\t\t\t\tsum += itr;\n\t\t\treturn sum;\n\t\t}\n\t\t\n\t\tpublic long sum(int[] ar) {\n\t\t\tlong sum = 0;\n\t\t\tfor (int itr : ar)\n\t\t\t\tsum += itr;\n\t\t\treturn sum;\n\t\t}\n\t\t\n\t\tpublic long pow(long base, long exp, long MOD) {\n\t\t\tbase %= MOD;\n\t\t\tlong ret = 1;\n\t\t\twhile (exp > 0) {\n\t\t\t\tif ((exp & 1) == 1)\n\t\t\t\t\tret = ret * base % MOD;\n\t\t\t\tbase = base * base % MOD;\n\t\t\t\texp >>= 1;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t}\n\t\n\tstatic class Print {\n\t\t\n\t\tprivate BufferedWriter bw;\n\t\t\n\t\tpublic Print() {\n\t\t\tthis.bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\t}\n\t\t\n\t\tpublic void print(Object object) throws IOException {\n\t\t\tbw.append(\"\" + object);\n\t\t}\n\t\t\n\t\tpublic void println(Object object) throws IOException {\n\t\t\tprint(object);\n\t\t\tbw.append(\"\\n\");\n\t\t}\n\t\t\n\t\tpublic void close() throws IOException {\n\t\t\tbw.close();\n\t\t}\n\t}\n\t\n\tpublic static class MyScanner {\n\t\t\n\t\tBufferedReader br;\n\t\t\n\t\tStringTokenizer st;\n\t\t\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t}\n\t\t\t\tcatch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\t\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\t\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t}\n\t\t\tcatch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\t\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> vec_a, freq, cum_freq;\nint main() {\n  int n, available_bytes;\n  cin >> n >> available_bytes;\n  int a;\n  for (int i = 0; i < n; ++i) {\n    cin >> a;\n    vec_a.push_back(a);\n  }\n  sort(vec_a.begin(), vec_a.end());\n  a = vec_a.front();\n  freq.push_back(1);\n  for (int i = 1; i < n; ++i) {\n    if (vec_a[i] == a) {\n      freq.back() += 1;\n    } else {\n      a = vec_a[i];\n      freq.push_back(1);\n    }\n  }\n  int tot_distinct_num = freq.size();\n  cum_freq.resize(tot_distinct_num);\n  partial_sum(freq.begin(), freq.end(), cum_freq.begin());\n  int each_num_occupied_bits = available_bytes * 8 / n;\n  int tot_distinct_num_capable = 1 << min(each_num_occupied_bits, 20);\n  int unchanged_count = 0;\n  for (int i = min(tot_distinct_num_capable, tot_distinct_num) - 1;\n       i < tot_distinct_num; ++i) {\n    int s = i - tot_distinct_num_capable;\n    int curr_unchanged_cout = cum_freq[i] - (s < 0 ? 0 : cum_freq[s]);\n    unchanged_count = max(unchanged_count, curr_unchanged_cout);\n  }\n  cout << n - unchanged_count;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int rem = 998244353;\nvector<pair<long long int, long long int> > vec;\nstring z(string s) {\n  long long int n = s.size();\n  vector<long long int> zz(n, 0);\n  long long int l = -1, r = -1;\n  for (long long int i = 1; i < n; i++) {\n    if (i > r) {\n      r = i;\n      while ((r < n) && (s[r] == s[r - i])) r++;\n      l = i;\n      r--;\n      zz[i] = r - l + 1;\n    } else {\n      long long int k = i - l;\n      if (i + zz[k] < r)\n        zz[i] = zz[k];\n      else {\n        l = i;\n        while ((r < n) && (s[r] == s[r - i])) r++;\n        r--;\n        zz[i] = r - l + 1;\n      }\n    }\n  }\n}\nunordered_map<long long int, long long int> mp;\nset<long long int> s;\nvoid prime() {\n  long long int n = 3e6 + 15;\n  vector<char> is_prime(n + 1, true);\n  is_prime[0] = is_prime[1] = false;\n  for (long long int i = 2; i <= n; i++) {\n    if (is_prime[i] && (long long)i * i <= n) {\n      for (long long int j = i * i; j <= n; j += i) is_prime[j] = false;\n    }\n  }\n  long long int cnt = 1;\n  for (long long int i = 0; i <= (long long int)3e6; i++) {\n    if (is_prime[i]) {\n      mp[cnt] = i;\n      cnt++;\n      s.insert(i);\n    }\n  }\n}\nlong long int solve(long long int i, long long int j) {\n  long long int left = 0, right = INT_MAX;\n  for (long long int k = i; k < j; k++) {\n    left = max(left, vec[k].first);\n    right = min(right, vec[k].second);\n  }\n  return max(0ll, right - left);\n}\nint32_t main() {\n  std::ios_base::sync_with_stdio(false);\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  long long int t = 1;\n  while (t--) {\n    long long int n, x;\n    cin >> n >> x;\n    x *= 8;\n    map<long long int, long long int> mp;\n    vector<long long int> vec;\n    vector<long long int> sum;\n    long long int ans = INT_MAX;\n    for (long long int i = 0; i < n; i++) {\n      long long int u;\n      cin >> u;\n      mp[u]++;\n    }\n    long long int cnt = 0;\n    for (auto it : mp) {\n      cnt += it.second;\n      vec.push_back(it.first);\n      sum.push_back(cnt);\n    }\n    long long int m = vec.size();\n    long long int i = 0, j = 0;\n    cnt = 1;\n    while (j < m) {\n      while ((j < m) && (ceil(log2(cnt)) * n <= x)) {\n        j++;\n        cnt++;\n      }\n      long long int temp = sum[m - 1] - sum[j - 1];\n      if (i) temp += sum[i - 1];\n      ans = min(ans, temp);\n      i++;\n      cnt--;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin\n\nn, i = map(int, stdin.readline().split())\na = list(map(int, stdin.readline().split()))\ni *= 8\n\nK = 2 ** (i // n)\n\na.sort()\nb = []\nfor i in a:\n    if not b or b[-1][0] != i:\n        b.append([i, 0])\n    b[-1][1] += 1\n\ncurrent = 0\nfor i in range(K, len(b)):\n    current += b[i][1]\n\nans = current\nfor r in range(K, len(b)):\n    current += b[r - K][1]\n    current -= b[r][1]\n    ans = min(ans, current)\nprint(ans)\n"
        },
        {
            "language": 3,
            "solution": "\n\nfrom math import *\n\nn,I=map(int,input().split(\" \"))\na=list(map(int,input().split(\" \")))\n\na=sorted(a)\n\ns=len(set(a))\n\nreq=0\n\nfor i in range(1,s+1):\n\n\tlg=int(ceil(log2(i)))\n\n\tlg*=n\n\n\tif(lg<=(I*8)):\n\t\treq=i\n\telse:\n\t\tbreak\n\n\ns=[]\n\ni=0\n\nwhile(i<n):\n\tj=i\n\ttmp=0\n\n\twhile(j<n and a[j]==a[i]):\n\t\tj+=1\n\t\ttmp+=1\n\n\ts.append(tmp)\n\n\ti=j\n\n\npre=[0]*len(s)\npre[0]=s[0]\n\nfor i in range(1,len(s)):\n\tpre[i]=s[i]\n\tpre[i]+=pre[i-1]\n\nans=n+5\n\nfor i in range(max(0,len(s)-req+1)):\n\tans=min(ans,n-(pre[i+req-1]-pre[i]+s[i]))\n\nif(ans==n+5):\n\tans=0\n\nprint(ans)\n\n\n\n\n\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.NavigableMap;\nimport java.util.TreeMap;\nimport java.util.Map;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.SortedMap;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            int i = in.readInt();\n            int[] a = in.readIntArray(n);\n            int memory = 8 * i;\n            memory /= n;\n            if (memory >= 20) {\n                out.printLine(0);\n                return;\n            }\n            memory = 1 << memory;\n            NavigableMap<Integer, Integer> map = new CPPTreeMap<>(() -> 0);\n            for (int j : a) {\n                map.put(j, map.get(j) + 1);\n            }\n            int[] all = new int[map.size()];\n            int at = 0;\n            for (int j : map.values()) {\n                all[at++] = j;\n            }\n            if (all.length <= memory) {\n                out.printLine(0);\n                return;\n            }\n            long[] sums = ArrayUtils.partialSums(all);\n            long answer = 0;\n            for (int j = memory; j <= all.length; j++) {\n                answer = Math.max(answer, sums[j] - sums[j - memory]);\n            }\n            out.printLine(n - answer);\n        }\n\n    }\n\n    static interface Factory<V> {\n        public V create();\n\n    }\n\n    static class CPPTreeMap<K, V> extends TreeMap<K, V> {\n        private final Factory<V> defaultValueFactory;\n\n        public CPPTreeMap(Factory<V> defaultValueFactory) {\n            this.defaultValueFactory = defaultValueFactory;\n        }\n\n        public V get(Object key) {\n            if (containsKey(key)) {\n                return super.get(key);\n            }\n            V value = defaultValueFactory.create();\n            try {\n                //noinspection unchecked\n                super.put((K) key, value);\n                return value;\n            } catch (ClassCastException e) {\n                return value;\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int[] readIntArray(int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readInt();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class ArrayUtils {\n        public static long[] partialSums(int[] array) {\n            long[] result = new long[array.length + 1];\n            for (int i = 0; i < array.length; i++) {\n                result[i + 1] = result[i] + array[i];\n            }\n            return result;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        int n;\n        int bytesAvailable;\n        int[] bitsPerElem;\n        int[] numDiff;\n\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            n = in.nextInt();\n            bytesAvailable = in.nextInt();\n            Integer[] a = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = in.nextInt();\n            }\n            Arrays.sort(a);\n\n            bitsPerElem = new int[n + 1];\n            for (int i = 1; i <= n; i++) {\n                bitsPerElem[i] = bitsPerElem[i - 1];\n                while ((1 << bitsPerElem[i]) < i) {\n                    ++bitsPerElem[i];\n                }\n            }\n\n            numDiff = new int[n + 1];\n            for (int i = 0; i < n; i++) {\n                numDiff[i + 1] = numDiff[i] + ((i == 0 || !a[i].equals(a[i - 1])) ? 1 : 0);\n            }\n\n            int ans = n;\n            int r = n;\n            for (int l = 0; l < n; l++) {\n                if (l > 0 && a[l].equals(a[l - 1])) {\n                    continue;\n                }\n                if (r == n) {\n                    --r;\n                }\n                while (r > l && !canFit(l, r)) {\n                    --r;\n                }\n                if (r < l) {\n                    r = l;\n                }\n                while (r < n && canFit(l, r)) {\n                    ++r;\n                }\n\n                ans = Math.min(ans, n - (r - l));\n            }\n            out.println(ans);\n        }\n\n        private boolean canFit(int l, int r) {\n            int d = numDiff[r + 1] - numDiff[l];\n            long bitsNeeded = (long) bitsPerElem[d] * n;\n            long bytesNeeded = (bitsNeeded + 7) / 8;\n            return bytesNeeded <= bytesAvailable;\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "// package ArraysAndSearching;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.TreeMap;\n\npublic class Mp3 {\n    public static void main(String[] args)throws IOException {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        String line[]=br.readLine().split(\" \");\n        int n=Integer.parseInt(line[0]);\n        int size=Integer.parseInt(line[1]);\n        int k=8*size/n;\n        k=(int)Math.pow(2,Math.min(20,k));\n\n        line=br.readLine().split(\" \");\n        int a[]=new int[n];\n        TreeMap<Integer,Integer> map=new TreeMap<>();\n        for(int i=0;i<n;i++){\n            a[i]=Integer.parseInt(line[i]);\n            map.put(a[i],map.getOrDefault(a[i],0)+1);\n        }\n        if(k>=map.size()){\n            System.out.println(0);\n            return;\n        }\n        int store[]=new int[map.size()];\n        int i=0;\n        for(int key:map.keySet()){\n            store[i++]=map.get(key);\n        }\n        int prefix[]=new int[store.length];\n        prefix[0]=store[0];\n        for(i=1;i<store.length;i++){\n            prefix[i]=prefix[i-1]+store[i];\n        }\n        int min=n;\n        for(i=0;i+k-1<prefix.length;i++){\n            int curr=prefix[i+k-1];\n            curr-=i-1>=0?prefix[i-1]:0;\n            min=Math.min(min,n-curr);\n        }\n        System.out.println(min);\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 4e5 + 5;\nint a[N], ct[N], cs[N];\nint lg(int n) {\n  int N = 1, k = 0;\n  while (n > N) N *= 2, k++;\n  return k;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int n, I;\n  cin >> n >> I;\n  int k = 0;\n  while ((8 * I) >= (n * k)) k++;\n  k--;\n  int bt = lg(n);\n  if (k >= bt) {\n    cout << 0 << endl;\n    return 0;\n  }\n  int mx = pow(2, k);\n  for (int i = 0; i < n; i++) cin >> a[i];\n  sort(a, a + n);\n  int j = 1;\n  ct[j]++;\n  for (int i = 1; i < n; i++) {\n    if (a[i] == a[i - 1])\n      ct[j]++;\n    else\n      ct[++j]++;\n  }\n  j = 1;\n  while (ct[j] > 0) {\n    cs[j] = cs[j - 1] + ct[j];\n    j++;\n  }\n  j--;\n  int mn = n;\n  if (mx >= j) {\n    cout << 0 << endl;\n    return 0;\n  }\n  for (int i = 1; i <= j - mx + 1; i++) {\n    mn = min(mn, n - (cs[i + mx - 1] - cs[i - 1]));\n  }\n  cout << mn << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double pi = acos(-1.0);\nconst double eps = 1e-8;\nconst int mxn = 400033;\nconst int mod = 1e9 + 7;\ninline int read() {\n  int x = 0, f = 1;\n  char c = getchar();\n  while (!isdigit(c)) f = c == '-' ? -1 : 1, c = getchar();\n  while (isdigit(c)) x = x * 10 + c - '0', c = getchar();\n  return x * f;\n}\ninline long long gcd(long long a, long long b) {\n  return b == 0 ? a : gcd(b, a % b);\n}\nlong long ksm(long long a, long long b, long long mod) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) ans = (ans * a) % mod;\n    a = (a * a) % mod;\n    b >>= 1;\n  }\n  return ans;\n}\nlong long inv2(long long a, long long mod) { return ksm(a, mod - 2, mod); }\nvoid exgcd(long long a, long long b, long long &x, long long &y, long long &d) {\n  if (!b) {\n    d = a;\n    x = 1;\n    y = 0;\n  } else {\n    exgcd(b, a % b, y, x, d);\n    y -= x * (a / b);\n  }\n}\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\nint n, c, a[mxn], sd[mxn];\nmap<int, int> ct;\nstruct node {\n  int x, num;\n} nd[mxn];\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n  std::cout.tie(0);\n  ;\n  cin >> n >> c;\n  int cnt = 0;\n  for (int i = 1; i <= n; ++i) {\n    cin >> a[i];\n    ct[a[i]]++;\n  }\n  for (auto it : ct) {\n    cnt++;\n    nd[cnt].x = it.first;\n    nd[cnt].num = it.second;\n  }\n  int tot = 8 * c / n;\n  int dk = 1;\n  while (tot--) {\n    dk *= 2;\n    if (dk >= cnt) {\n      cout << 0 << endl;\n      return 0;\n    }\n  }\n  for (int i = 1; i <= cnt; ++i) sd[i] = sd[i - 1] + nd[i].num;\n  int sum = 0;\n  for (int i = dk; i <= cnt; ++i) {\n    if (sd[i] - sd[i - dk] > sum) sum = sd[i] - sd[i - dk];\n  }\n  cout << n - sum << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 4e5 + 7;\nconst int mod = 1e9 + 7;\nconst long long INF = 1e18;\nint a[maxn];\nmap<int, int> mp;\nint pre[maxn];\nint rua() {\n  int n, I;\n  scanf(\"%d%d\", &n, &I);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]), mp[a[i]]++;\n  sort(a + 1, a + 1 + n);\n  int sz = unique(a + 1, a + n + 1) - (a + 1);\n  for (int i = 1; i <= sz; i++) pre[i] = pre[i - 1] + mp[a[i]];\n  int tmp = 8 * I / n;\n  if (tmp > 31) tmp = 31;\n  long long len = 1ll << tmp;\n  if (len >= 1ll * sz) return 0;\n  int ans = 0;\n  for (int i = len; i <= sz; i++) ans = max(ans, pre[i] - pre[i - len]);\n  return n - ans;\n}\nint main() {\n  printf(\"%d\\n\", rua());\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint arr[400000];\nint cnt[400000];\nint main(void) {\n  int n, I;\n  scanf(\"%d %d\\n\", &n, &I);\n  I *= 8;\n  I /= n;\n  if (I >= 20) {\n    printf(\"0\");\n    return 0;\n  }\n  int lim = 1;\n  for (int i = 0; i < I; i++) {\n    lim *= 2;\n  }\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d \", &arr[i]);\n  }\n  sort(arr, arr + n);\n  int ind = 0;\n  int prev = arr[0];\n  for (int i = 0; i < n; i++) {\n    if (prev != arr[i]) {\n      ind++;\n    }\n    cnt[ind]++;\n    prev = arr[i];\n  }\n  if (ind + 1 <= lim) {\n    printf(\"0\");\n    return 0;\n  }\n  int ret = 0;\n  int sum = 0;\n  for (int i = 0; i < lim; i++) {\n    sum += cnt[i];\n  }\n  ret = max(ret, sum);\n  for (int i = lim; i <= ind; i++) {\n    sum -= cnt[i - lim];\n    sum += cnt[i];\n    ret = max(ret, sum);\n  }\n  printf(\"%d\", n - ret);\n}\n"
        },
        {
            "language": 3,
            "solution": "n,I=map(int,input().split())\na=list(map(int,input().split()))\ndiff=len(set(a))\nk=(8*I)//n\nK=2**k\nif diff<K:\n    print(0)\nelse:\n    a.sort()\n    ind=0\n    curr=-1\n    changes=[]\n    for i in range(n):\n        if a[ind]!=curr:\n            changes.append(ind)\n            curr=a[ind]\n            ind+=1\n        else:\n            ind+=1\n    b=a[::-1]\n    ind=0\n    curr=-1\n    changes1=[]\n    for i in range(n):\n        if b[ind]!=curr:\n            changes1.append(ind)\n            curr=b[ind]\n            ind+=1\n        else:\n            ind+=1\n    mini=10**15\n    for i in range(diff-K+1):\n        mini=min(mini,changes[i]+changes1[diff-K-i])\n    print(mini)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint num[400005];\nmap<int, int> freq;\nint logtwo[400005];\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  m <<= 3;\n  for (int i = (1); i <= (n); i++) {\n    int t;\n    scanf(\"%d\", &t);\n    num[i] = t;\n  }\n  sort(num + 1, num + n + 1);\n  logtwo[1] = 0;\n  int power = 1;\n  for (int i = (2); i <= (n); i++) {\n    if ((1 << power) < i) ++power;\n    logtwo[i] = power;\n  }\n  int p = 1;\n  int mx = 0;\n  for (int i = (1); i <= (n); i++) {\n    ++freq[num[i]];\n    while ((long long)n * logtwo[(int)freq.size()] > m) {\n      if (--freq[num[p]] == 0) freq.erase(num[p]);\n      ++p;\n    }\n    mx = max(mx, i - p + 1);\n  }\n  printf(\"%d\\n\", n - mx);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "/*\n * Remember a 6.0 student can know more than a 10.0 student.\n * Grades don't determine intelligence, they test obedience. \n * I Never Give Up.\n * I will become Candidate Master today.\n * I will defeat Saurabh Anand.\n * Skills are Cheap,Passion is Priceless.\n */\nimport java.util.*;\nimport java.util.Map.Entry;\nimport java.io.*;\n\nimport static java.lang.System.out;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\n\npublic class ContestMain{\n\tprivate static Reader in=new Reader();\n\tprivate static StringBuilder ans=new StringBuilder();\n\tprivate static long MOD=998244353;\n\tprivate static final int N=(int) (1e5+7); // 1e5+7\n//    private static final double EPS=1e-9;\n//    private static final int LIM=26;\n//    private static final double PI=3.1415;\n    private static ArrayList<Integer> v[]=new ArrayList[N];\n//    private static int color[]=new int[N];\n\tprivate static boolean mark[]=new boolean[N];\n\n//    private static BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n//    private static ArrayList<Pair> v[]=new ArrayList[N];\n\tprivate static long powmod(long x,long n){\n\t\tif(n==0||x==0)\n\t\t\treturn 1;\n\t\telse if(n%2==0)\n\t\t\treturn(powmod((x*x)%MOD,n/2));\n\t\telse\n\t\t\treturn (x*(powmod((x*x)%MOD,(n-1)/2)))%MOD;\n\t}\n\n\tprivate static void shuffle(long[] arr){\n\t\tfor(int i=arr.length-1;i>=2;i--){\n\t\t\tint x=new Random().nextInt(i-1);\n\t\t\tlong temp=arr[x];\n\t\t\tarr[x]=arr[i];\n\t\t\tarr[i]=temp;\n\t\t}\n\t}\n\n    private static long gcd(long a, long b){\n        if(b==0)return a;\n        return gcd(b,a%b);\n    }\n//    private static boolean check(int x,int y){\n//        if((x>=0&&x<n)&&(y>=0&&y<m)&&mat[x][y]!='X'&&!visited[x][y])return true;\n//        return false;\n//    }\n\tpublic static void main(String[] args) throws IOException{\n\t\tint n=in.nextInt();\n\t\tlong intn=in.nextLong()*8;\n\t\tlong ar[]=new long[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tar[i]=in.nextLong();\n\t\tshuffle(ar);\n\t\tsort(ar);\n\t\tint l=1,r=n,mid,val;\n\t\tint dist;\n\t\twhile(l+1!=r&&l<r){\n\t\t\tmid=(l+r)/2;\n\t\t\tval=(int)ceil(log(mid)/log(2));\n\t\t\tif(n*val<=intn)l=mid;\n\t\t\telse r=mid;\n\t\t}\n\t\tval=(int)ceil(log(r)/log(2));\n\t\tif(n*val<=intn)dist=r;\n\t\telse dist=l;\n\t\tint x=0,y=0;\n\t\tlong temp;\n\t\tHashSet<Long> set=new HashSet();\n\t\tint res=Integer.MAX_VALUE;\n\t\twhile(y<n){\n\t\t\tset.add(ar[y]);\n\t\t\tif(set.size()>dist){\n\t\t\t\tres=min(res,x+n-y);\n\t\t\t\ttemp=ar[x];\n\t\t\t\tset.remove(ar[x]);\n\t\t\t\twhile(ar[x]==temp){x++;}\n\t\t\t}\n\t\t\ty++;\n\t\t}\n\t\tif(set.size()<dist){out.print(0);return;}\n\t\tres=min(res,x);\n\t\tout.print(res);\n\t}\n\tstatic class Pair<T> implements Comparable<Pair>{\n\t\tint l;\n\t\tint r;\n\t\tPair(){\n\t\t\tl=0;\n\t\t\tr=0;\n\t\t}\n\t\tPair(int k,int v){\n\t\t\tl=k;\n\t\t\tr=v;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Pair o){\n\t\t\tif(o.l!=l)\n\t\t\t\treturn (int)(l-o.l);\n\t\t\telse\n\t\t\t\treturn (int)(r-o.r);\n\t\t}\n\t\t// Fenwick tree question comparator\n//        @Override\n//        public int compareTo(Pair o) {\n//            if(o.r!=r)return (int) (r-o.r);\n//            else return (int)(l-o.l);\n//        }\n\t}\n\n\tstatic class Reader{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic Reader(){\n\t\t\tbr=new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next(){\n\t\t\twhile(st==null||!st.hasMoreElements()){\n\t\t\t\ttry{\n\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t}catch(IOException e){\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt(){\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong(){\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble(){\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine(){\n\t\t\tString str=\"\";\n\t\t\ttry{\n\t\t\t\tstr=br.readLine();\n\t\t\t}catch(IOException e){\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Main{\n\tpublic static PrintWriter out = new PrintWriter (new BufferedOutputStream(System.out));\n\tpublic static void main(String sp[])throws IOException{\n\t\t//Scanner sc = new Scanner(System.in);\n\t\tFastReader sc = new FastReader();\n\t\tint n = sc.nextInt();\n\t\tlong file = 8l*(sc.nextLong());\n\t\tlong arr[] = new long[n+1];\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tarr[i] = sc.nextLong();\n\t\t}\n\t\tlong element = n;\n\t\tTreeMap<Long,Integer> hm = new TreeMap<>();\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(!hm.containsKey(arr[i]))\n\t\t\t\thm.put(arr[i],1);\n\t\t\telse hm.put(arr[i], hm.get(arr[i])+1);\n\t\t}\n\t\tlong p = 0;\n\t\tp = file/n;\n\t\t\n\t\tArrayList<Long> al = new ArrayList<>(hm.keySet());\n\t\tint siz = al.size();\n\t\tlong ans = Long.MAX_VALUE;\n\t\tlong temp = 0;\n\t\tlong rest = 0;\n\t\tint l = 0;\n\t\tint r = 0;\n\t\twhile(l<=r && r<siz){\n\t\t\ttemp+=hm.get(al.get(r));\n\t\t\trest++;\n\t\t\tlong gh = log2(rest);\n\t\t\tif(gh<=p){\n\t\t\t\tans = Math.min(ans, n-temp);\n\t\t\t}else{\n\t\t\t\twhile(l<=r){\n\t\t\t\t\ttemp-=hm.get(al.get(l));\n\t\t\t\t\tl++;\n\t\t\t\t\trest--;\n\t\t\t\t\tgh = log2(rest);\n\t\t\t\t\tif(gh<=p){\n\t\t\t\t\t\tans = Math.min(ans, n-temp);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tr++;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\t\n\tstatic long log2(long x){\n\t\treturn (long)Math.ceil((Math.log(x)/Math.log(2)));\n\t}\n\t\n\tstatic long gcd(long a, long b) \n    { \n      if (b == 0) \n        return a; \n      return gcd(b, a % b);  \n    }\n\t\n\t/*public static class comp implements Comparator<pair>{\n\t\tpublic int compare(pair o1, pair o2){\n\t\t\treturn Long.valueOf(o1.diff).compareTo(Long.valueOf(o2.diff));\n\t\t}\n\t}*/\n\t\t\n\tstatic class FastReader \n\t\t{ \n\t\tfinal private int BUFFER_SIZE = 1 << 16; \n\t\tprivate DataInputStream din; \n\t\tprivate byte[] buffer; \n\t\tprivate int bufferPointer, bytesRead; \n  \n\t\tpublic FastReader() \n\t\t{ \n\t\t\tdin = new DataInputStream(System.in); \n\t\t\tbuffer = new byte[BUFFER_SIZE]; \n\t\t\tbufferPointer = bytesRead = 0; \n\t\t} \n  \n\t\tpublic FastReader(String file_name) throws IOException \n\t\t{ \n\t\t\tdin = new DataInputStream(new FileInputStream(file_name)); \n\t\t\tbuffer = new byte[BUFFER_SIZE]; \n\t\t\tbufferPointer = bytesRead = 0; \n\t\t} \n  \n\t\tpublic String readLine() throws IOException \n\t\t{ \n\t\t\tbyte[] buf = new byte[64]; // line length \n\t\t\tint cnt = 0, c; \n\t\t\twhile ((c = read()) != -1) \n\t\t\t{ \n\t\t\t\tif (c == '\\n') \n\t\t\t\t\tbreak; \n\t\t\t\tbuf[cnt++] = (byte) c; \n\t\t\t} \n\t\t\treturn new String(buf, 0, cnt); \n\t\t} \n  \n\t\tpublic int nextInt() throws IOException \n\t\t{ \n\t\t\tint ret = 0; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\t\t\tdo\n\t\t\t{ \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t}  while ((c = read()) >= '0' && c <= '9'); \n  \n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n\t\t} \n  \n\t\tpublic long nextLong() throws IOException \n\t\t{ \n\t\t\tlong ret = 0; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\t\t\tdo { \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} \n\t\t\twhile ((c = read()) >= '0' && c <= '9'); \n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n\t\t} \n  \n\t\tpublic double nextDouble() throws IOException \n\t\t{ \n\t\t\tdouble ret = 0, div = 1; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n  \n\t\t\tdo { \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} \n\t\t\twhile ((c = read()) >= '0' && c <= '9'); \n  \n\t\t\tif (c == '.') \n\t\t\t{ \n\t\t\t\twhile ((c = read()) >= '0' && c <= '9') \n\t\t\t\t{ \n\t\t\t\t\tret += (c - '0') / (div *= 10); \n\t\t\t\t} \n\t\t\t} \n  \n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n\t\t} \n  \n\t\tprivate void fillBuffer() throws IOException \n\t\t{ \n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \n\t\t\tif (bytesRead == -1) \n\t\t\t\tbuffer[0] = -1; \n\t\t} \n  \n\t\tprivate byte read() throws IOException \n\t\t{ \n\t\t\tif (bufferPointer == bytesRead) \n\t\t\t\tfillBuffer(); \n\t\t\treturn buffer[bufferPointer++]; \n\t\t} \n  \n\t\tpublic void close() throws IOException \n\t\t{ \n\t\t\tif (din == null) \n\t\t\t\treturn; \n\t\t\tdin.close(); \n\t\t} \n\t} \n}"
        },
        {
            "language": 4,
            "solution": "/*\n[ ( ^ _ ^ ) ]\n*/\n\n// problem: cf/1198/A\n\nimport java.io.*;\nimport java.util.*;\n\n\npublic class a {\n    int INF = (int)1e9;\n    long MOD = 1000000007;\n\n    int min(int a, int b) {return a<=b?a:b;}\n    int max(int a, int b) {return a>=b?a:b;}\n\n    void solve(InputReader in, PrintWriter out) throws IOException {\n        int n = in.nextInt();\n        int I = 8 * in.nextInt();\n        int l = min(25, I/n);\n        int k = 1<<l;\n\n        Integer[] a = new Integer[n];\n        HashMap<Integer, Integer> mp = new HashMap<>();\n        for(int i=0; i<n; i++) {\n            a[i] = in.nextInt();\n            mp.put(a[i], mp.getOrDefault(a[i], 0)+1);\n        }\n        Arrays.sort(a);\n        int[] c = new int[n];\n        int p = 0;\n        for(int i=0; i<n; i++) {\n            if(i==0 || !a[i].equals(a[i-1])) {\n                a[p] = a[i];\n                c[p] = mp.get(a[i]);\n                p++;\n            }\n        }\n        n = p;\n        for(int i=1; i<n; i++) {\n            c[i] += c[i-1];\n        }\n\n        // show(\"cx\", mp.size(), k, c[n-1]);\n\n        int tot = c[n-1];\n        int rs = INF;\n\n        for(int i=0; i<n; i++) {\n            int j = min(n-1, i+k-1);\n            rs = min(rs, tot - (c[j] - (i>0 ? c[i-1] : 0)));\n        }\n        out.println(rs);\n    }\n    \n\n    public static void main(String[] args) throws IOException {\n        if(args.length>0 && args[0].equalsIgnoreCase(\"d\")) {\n            DEBUG_FLAG = true;\n        }\n        InputReader in = new InputReader();\n        PrintWriter out = new PrintWriter(System.out);\n        int t = 1;//in.nextInt();\n        long start = System.nanoTime();\n        while(t-- >0) {\n            new a().solve(in, out);\n        }\n        long end = System.nanoTime();\n        debug(\"\\nTime: \" + (end-start)/1e6 + \" \\n\\n\");\n        out.close();\n    }\n    \n    static boolean DEBUG_FLAG = false;\n    static void debug(String s) {\n        if(DEBUG_FLAG) System.out.print(s);\n    }\n    \n    public static void show(Object... o) {\n        System.out.println(Arrays.deepToString(o));\n    }\n    \n    static class InputReader {\n        static BufferedReader br;\n        static StringTokenizer st;\n    \n        public InputReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        \n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid err(istream_iterator<string> it) { cerr << endl; }\ntemplate <typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args) {\n  cerr << *it << \" = \" << a << \" \";\n  err(++it, args...);\n}\nlong long power(long long x, long long y, long long p = 1000000007) {\n  x %= p;\n  long long val = 1;\n  while (y) {\n    if (y & 1LL) val = (val * x) % p;\n    y >>= 1LL;\n    x = (x * x) % p;\n  }\n  return val;\n}\nlong long a[400005];\nmap<long long, long long> f;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long n, I;\n  cin >> n >> I;\n  for (long long i = 1; i <= n; i++) {\n    cin >> a[i];\n  }\n  sort(a + 1, a + n + 1);\n  long long ans = 1e8;\n  long long p = 8 * I / n;\n  long long cp = p;\n  p = 1;\n  while (cp--) {\n    p *= 2;\n    if (p > n) {\n      cout << 0 << '\\n';\n      return 0;\n    }\n  }\n  long long j = 1;\n  long long cnt = 0;\n  for (long long i = 1; i <= n; i++) {\n    while (j <= n) {\n      if (f.count(a[j]) == 0 || f[a[j] == 0]) {\n        if (cnt == p) break;\n        f[a[j]]++;\n        cnt++;\n        j++;\n        continue;\n      }\n      f[a[j]]++;\n      j++;\n    }\n    ans = min(ans, i - 1 + n - j + 1);\n    f[a[i]]--;\n    if (f[a[i]] == 0) cnt--;\n  }\n  cout << ans << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long n, I;\n  cin >> n >> I;\n  long long arr[n];\n  unordered_set<long long> st;\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i];\n    st.insert(arr[i]);\n  }\n  sort(arr, arr + n);\n  long long l = 0, r = 0, maxim = 0;\n  long long different = 0, allowed = pow(2, min((long long)20, ((8 * I) / n)));\n  unordered_map<long long, long long> s;\n  if (allowed >= st.size()) {\n    cout << 0 << endl;\n    return 0;\n  }\n  while (r < n) {\n    while (r < n && different <= allowed) {\n      if (s.find(arr[r]) == s.end()) {\n        different++;\n        s[arr[r]]++;\n      } else\n        s[arr[r]]++;\n      r++;\n    }\n    maxim = max(maxim, r - l - 1);\n    s[arr[l]]--;\n    if (s[arr[l]] == 0) {\n      s.erase(arr[l]);\n      different--;\n    }\n    l++;\n  }\n  cout << n - maxim;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class MP3 {\n    \n    \n    \n    /************************ SOLUTION STARTS HERE ************************/\n    \n    static void shuffleArray(int[] array) {\n        Random random = new Random();\n        for (int i = array.length - 1; i > 0; i--) {\n            int index = random.nextInt(i + 1);\n            int temp = array[index];\n            array[index] = array[i];\n            array[i] = temp;\n        }\n    }\n\n    \n    private static void solve() {\n        \n        int n = nextInt();\n        int I = nextInt();\n        int arr[] = nextIntArray(n);\n        \n        shuffleArray(arr);;\n        Arrays.sort(arr);\n        \n        int k = 1 << (Math.min(30, (8 * I) / n));\n        ArrayList<Integer> freq = new ArrayList<>();\n        \n        for(int i = 0; i < n;) {\n            int cnt = 0;\n            for(int j = i; j < n && arr[j] == arr[i]; j++, cnt++)\n                ;\n            \n            i += cnt;\n            freq.add(cnt);\n        }\n        \n//        println(freq);\n//        println(\"k \" + k);\n        \n        if(freq.size() <= k) {\n            print(0);\n            return;\n        }\n        \n        int sum = 0;\n        for(int i = 0; i < k; i++)\n            sum += freq.get(i);\n        \n        int max = sum;\n        \n        for(int i = k; i < freq.size(); i++) {    \n            sum = sum - freq.get(i - k) + freq.get(i);\n            max = Math.max(max, sum);\n        }\n        \n        println(n - max);\n    }\n    \n    \n    \n    /************************ SOLUTION ENDS HERE ************************/\n    \n    \n    \n    \n    \n    /************************ TEMPLATE STARTS HERE **********************/\n\n    public static void main(String[] args) throws IOException {\n        reader = new BufferedReader(new InputStreamReader(System.in));\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)), false);\n        st = null;\n        solve();\n        reader.close();\n        writer.close();\n    }\n\n    static BufferedReader  reader;\n    static PrintWriter     writer;\n    static StringTokenizer st;\n\n    static String next() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                String line = reader.readLine();\n                if (line == null) {\n                    return null;\n                }\n                st = new StringTokenizer(line);\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n        return st.nextToken();\n    }\n\n    static String nextLine() {\n        String s = null;\n        try {\n            s = reader.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n\n    static int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    static long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    static double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    static char nextChar() {\n        return next().charAt(0);\n    }\n\n    static int[] nextIntArray(int n) {\n        int[] a = new int[n];\n        int i = 0;\n        while (i < n) {\n            a[i++] = nextInt();\n        }\n        return a;\n    }\n\n    static long[] nextLongArray(int n) {\n        long[] a = new long[n];\n        int i = 0;\n        while (i < n) {\n            a[i++] = nextLong();\n        }\n        return a;\n    }\n\n    static int[] nextIntArrayOneBased(int n) {\n        int[] a = new int[n + 1];\n        int i = 1;\n        while (i <= n) {\n            a[i++] = nextInt();\n        }\n        return a;\n    }\n\n    static long[] nextLongArrayOneBased(int n) {\n        long[] a = new long[n + 1];\n        int i = 1;\n        while (i <= n) {\n            a[i++] = nextLong();\n        }\n        return a;\n    }\n\n    static void print(Object o) {\n        writer.print(o);\n    }\n\n    static void println(Object o) {\n        writer.println(o);\n    }\n\n    /************************ TEMPLATE ENDS HERE ************************/\n    \n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 4e5 + 10;\nint a[maxn], b[maxn];\nint sum[maxn];\nint main() {\n  int n, I;\n  scanf(\"%d%d\", &n, &I);\n  a[0] = -1;\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  sort(a + 1, a + n + 1);\n  int cnt = 0;\n  for (int i = 1; i <= n; i++) {\n    if (a[i] != a[i - 1]) cnt++;\n    b[cnt]++;\n  }\n  for (int i = 1; i <= cnt; i++) sum[i] = sum[i - 1] + b[i];\n  int k = 1;\n  for (int i = 0; i < I * 8 / n; i++) {\n    k <<= 1;\n    if (k >= cnt) break;\n  }\n  k = min(k, cnt);\n  int ans = 0;\n  for (int i = k; i <= cnt; i++) ans = max(ans, sum[i] - sum[i - k]);\n  printf(\"%d\\n\", n - ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, d, nn, a[400069], ps[400069], m = 1;\nmap<long long, long long> fq;\nint main() {\n  long long i, j, k, mn = 1e18;\n  scanf(\"%lld%lld\", &n, &d);\n  for (i = 0; i < n; i++) {\n    scanf(\"%lld\", &k);\n    if (!fq[k]) {\n      nn++;\n      a[nn] = k;\n    }\n    fq[k]++;\n  }\n  sort(a + 1, a + nn + 1);\n  k = d * 8 / n;\n  for (i = 0; i < k; i++) {\n    m *= 2;\n    if (m >= nn) {\n      printf(\"0\\n\");\n      return 0;\n    }\n  }\n  for (i = 1; i <= nn; i++) {\n    ps[i] = ps[i - 1] + fq[a[i]];\n  }\n  for (i = m; i <= nn; i++) {\n    mn = min(mn, ps[nn] - ps[i] + ps[i - m]);\n  }\n  printf(\"%lld\\n\", mn);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, bytes;\n  cin >> n >> bytes;\n  vector<int> arr(n);\n  unordered_map<int, int> mapa{};\n  for (auto& el : arr) {\n    cin >> el;\n    mapa[el]++;\n  }\n  sort(begin(arr), end(arr));\n  arr.erase(unique(begin(arr), end(arr)), end(arr));\n  auto max = 0;\n  auto fp = begin(arr) + 1;\n  auto sp = begin(arr);\n  auto num_distinct = 1;\n  auto num_taken = mapa[*begin(arr)];\n  auto min_changes = n - num_taken;\n  for (; fp != end(arr); fp++) {\n    num_distinct++;\n    num_taken += mapa[*fp];\n    if (ceil(log2(num_distinct)) * n > bytes * 8) {\n      num_distinct--;\n      num_taken -= mapa[*sp];\n      sp++;\n      min_changes = min(min_changes, n - num_taken);\n      continue;\n    }\n    min_changes = min(min_changes, n - num_taken);\n  }\n  if (fp == end(arr)) {\n  }\n  cout << min_changes << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\nint n;\nmap<int, int> cnt;\nlong long I;\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> I;\n  int mx = 1 << min(25, (int)(I * 8 / n));\n  for (int i = 0; i < (n); i++) {\n    long long a;\n    cin >> a;\n    cnt[a]++;\n  }\n  vector<pair<int, int> > v;\n  for (const pair<int, int> p : cnt) v.push_back(p);\n  int curr = 0;\n  for (int i = (mx); i < (((int)(v).size())); i++) curr += v[i].second;\n  int res = curr;\n  for (int i = (mx); i < (((int)(v).size())); i++) {\n    curr -= v[i].second;\n    curr += v[i - mx].second;\n    res = min(res, curr);\n  }\n  cout << res << endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\n\nn, I = map(int, input().split())\na = list(map(int, input().split()))\na = sorted(a) + [-1]\n\ncnt = 1\nli = []\nfor i in range(n):\n    if a[i] == a[i+1]:\n        cnt += 1\n    if a[i] != a[i+1]:\n        li.append(cnt)\n        cnt = 1\n\nok = 1\nng = n + 1\nwhile abs(ok - ng) > 1:\n    mid = (ok + ng) // 2\n    if n * (mid-1).bit_length() <= 8 * I:\n        ok = mid\n    else:\n        ng = mid\n\n#integer = (8 * I) // n\n#point = ((8 * I) % n) / n\n#num = 1\n\n#for i in range(integer):\n#    num *= 2\n#    if num > n ** 2:\n#        break\n#num *= 2**(point)\n#print(num)\n\nans = 0\nfor i in range(min(ok, len(li))):\n    ans += li[i]\n\n_sum = ans\ni = 0\nwhile i + ok < len(li):\n    tmp = _sum\n    tmp -= li[i]\n    tmp += li[i + ok]\n    ans = max(tmp, ans)\n    _sum = tmp\n    i += 1\nprint(n - ans)\n    \n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long f(long long x) {\n  long long res = (long long)log2(x);\n  while ((1 << res) < x) res++;\n  return res;\n}\nconst long long N = 4e5 + 10;\nlong long pref[N], suf[N];\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  long long n, k;\n  cin >> n >> k;\n  k *= 8;\n  vector<long long> srt, a(n);\n  for (long long i = 0; i < n; i++) {\n    cin >> a[i];\n    srt.push_back(a[i]);\n  }\n  sort((srt).begin(), (srt).end());\n  srt.resize(unique((srt).begin(), (srt).end()) - srt.begin());\n  long long sz = (long long)(srt).size();\n  unordered_map<long long, long long> to;\n  for (long long i = 0; i < sz; i++) {\n    to[srt[i]] = i + 1;\n  }\n  for (long long i = 0; i < n; i++) {\n    pref[to[a[i]]]++;\n    suf[to[a[i]]]++;\n  }\n  for (long long i = 2; i <= sz; i++) {\n    pref[i] += pref[i - 1];\n  }\n  for (long long i = sz - 1; i >= 1; i--) {\n    suf[i] += suf[i + 1];\n  }\n  long long mx = 1;\n  while (mx < n && n * f(mx + 1) <= k) {\n    mx++;\n  }\n  long long ans = n;\n  for (long long l = 1; l <= sz; l++) {\n    long long r = min(sz, l + mx - 1);\n    ans = min(ans, pref[l - 1] + suf[r + 1]);\n  }\n  cout << ans << '\\n';\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\nimport collections\nn,I=map(int,input().split())\nA=[int(i) for i in input().split()]\n\ndef f(x):\n  if x==0:\n    return 0\n  else:\n    return (x-1).bit_length()\n\ndef check(y):\n  return f(y)*n<=8*I\n\nl,r=1,10**9+1\nwhile r-l>1:\n  if check((l+r)//2):\n    l=(l+r)//2\n  else:\n    r=(l+r)//2\nk=l\nAA=sorted(collections.Counter(A).items(),key=lambda x:x[0])\nnn=len(AA)\n\nif k>=nn:\n  print(0)\nelse:\n  ans=0\n  tot=0\n  for i in range(k):\n    tot+=AA[i][1]\n    ans=tot\n  for i in range(k,nn):\n    tot+=AA[i][1]\n    tot-=AA[i-k][1]\n    ans=max(ans,tot)\n  print(n-ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nsigned main() {\n  std::ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int64_t n, I, i, ans, temp;\n  cin >> n >> I;\n  int64_t arr[n + 1];\n  map<int64_t, int64_t> cnt;\n  for (i = 0; i < n; i++) {\n    cin >> arr[i];\n    cnt[arr[i]]++;\n  }\n  queue<int64_t> q;\n  ans = 0;\n  I *= 8;\n  I /= n;\n  temp = 0;\n  I = pow(2, I);\n  for (auto j : cnt) {\n    if (q.size() == I) {\n      temp -= cnt[q.front()];\n      q.pop();\n    }\n    q.push(j.first);\n    temp += j.second;\n    ans = max(ans, temp);\n  }\n  cout << n - ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) {\n  if (!b) return a;\n  return gcd(b, a % b);\n}\nlong long fpow(long long x, long long y, long long mod) {\n  long long ans = 1ll;\n  for (; y; y >>= 1) {\n    if (y & 1) ans = ans * x % mod;\n    x = x * x % mod;\n  }\n  return ans;\n}\nconst long long maxd = 4e5 + 10;\nlong long a[maxd], b[maxd], tot;\nlong long log(long long x) {\n  long long tot = 0, now = 1ll;\n  while (now < x) {\n    now *= 2;\n    tot++;\n  }\n  return tot;\n}\nint main() {\n  long long n, m;\n  scanf(\"%lld %lld\", &n, &m);\n  ;\n  m *= 8;\n  for (long long i = 1; i <= n; i++) scanf(\"%lld\", &a[i]);\n  sort(a + 1, a + 1 + n);\n  a[n + 1] = -1;\n  long long now = 0ll;\n  for (long long i = 1; i <= n; i++) {\n    now++;\n    if (a[i] != a[i + 1]) {\n      b[++tot] = now, now = 0;\n    }\n  }\n  long long ans = 1e9, j = 0;\n  for (long long i = 0; i < tot; i++) {\n    now -= b[i];\n    while (j + 1 <= tot && log((j + 1) - i) * (n) <= m) now += b[++j];\n    ans = min(ans, n - now);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nint a[400005];\nint main() {\n  cin >> n >> k;\n  for (int i = 0; i < n; ++i) scanf(\"%d\", a + i);\n  sort(a, a + n);\n  int l = 0, r = 0, diff = 0, ans = 0;\n  while (l < n) {\n    while (r < n) {\n      if (r == l || (r > l && a[r] != a[r - 1])) {\n        diff++;\n        if (n * ceil(log(diff) / log(2)) > k * 8) {\n          diff--;\n          break;\n        }\n      }\n      r++;\n    }\n    ans = max(ans, r - l);\n    if (l < r && a[l] != a[l + 1]) diff--;\n    l++;\n  }\n  cout << n - ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, I;\n  cin >> n >> I;\n  int block = I * 8 / n;\n  int win = n;\n  if (block < 30) {\n    win = min(win, 1 << block);\n  }\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  sort(a.begin(), a.end());\n  int p = -1;\n  vector<int> cnt;\n  for (int i = 0; i < n; i++) {\n    if (a[i] != p) {\n      cnt.push_back(0);\n    }\n    cnt.back()++;\n    p = a[i];\n  }\n  int k = (int)cnt.size();\n  int sum = 0;\n  for (int i = 0; i < min(win, k); i++) {\n    sum += cnt[i];\n  }\n  int ans = n - sum;\n  for (int i = win; i < k; i++) {\n    sum -= cnt[i - win];\n    sum += cnt[i];\n    ans = min(ans, n - sum);\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\nimport math\n\ndef main():\n    pass\n\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\ndef binary(n):\n    return (bin(n).replace(\"0b\", \"\"))\n\n\ndef decimal(s):\n    return (int(s, 2))\n\n\ndef pow2(n):\n    p = 0\n    while (n > 1):\n        n //= 2\n        p += 1\n    return (p)\n\n\ndef primeFactors(n):\n    l=[]\n    while n % 2 == 0:\n        l.append(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            l.append(i)\n            n = n / i\n    if n > 2:\n        l.append(int(n))\n    return (l)\n\n\ndef isPrime(n):\n    if (n == 1):\n        return (False)\n    else:\n        root = int(n ** 0.5)\n        root += 1\n        for i in range(2, root):\n            if (n % i == 0):\n                return (False)\n        return (True)\n\ndef maxPrimeFactors(n):\n    maxPrime = -1\n    while n % 2 == 0:\n        maxPrime = 2\n        n >>= 1\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            maxPrime = i\n            n = n / i\n    if n > 2:\n        maxPrime = n\n    return int(maxPrime)\n\n\ndef reVal(num):\n    if (num >= 0 and num <= 9):\n        return chr(num + ord('0'));\n    else:\n        return chr(num - 10 + ord('A'));\n\n\n\ndef strev(str):\n    len = len(str);\n    for i in range(int(len / 2)):\n        temp = str[i];\n        str[i] = str[len - i - 1];\n        str[len - i - 1] = temp;\n\ndef fromDeci(res, base, inputNum):\n    index = 0;\n\n    while (inputNum > 0):\n        res += reVal(inputNum % base);\n        inputNum = int(inputNum / base);\n\n    res = res[::-1];\n\n    return res;\ndef norm(s,l):\n    tba=\"0\"*(l-len(s))\n    return(tba+s)\nn,s=map(int,input().split())\nl=list(map(int,input().split()))\ndis=2**((8*s)//n)\n#print(dis)\nif(len(set(l))<=dis):\n    print(0)\nelse:\n    f=[1]\n    l.sort()\n    for i in range(1,n):\n        if(l[i]==l[i-1]):\n            f[-1]+=1\n        else:\n            f.append(1)\n    #print(f)\n    pre=[0]\n    for i in range(0,len(f)):\n        pre.append(pre[i]+f[i])\n    suf=[0]\n    lf=len(f)\n    for i in range(lf-1,-1,-1):\n        suf.append(suf[lf-i-1]+f[i])\n    suf=suf[::-1]\n    #print(f,pre,suf)\n    a=10000000000\n    #print(dis)\n    for i in range(0,lf-dis):\n        lp=i\n        rp=lp+dis\n        a=min(a,pre[lp]+suf[rp])\n    print(a)"
        },
        {
            "language": 3,
            "solution": "n, I = map(int, input().split())\na = list(map(int, input().split()))\nk = I * 8 // n\nK = 2 ** k\na.sort()\nA = [1]\nj = 0\nfor i in range(1, n):\n    if a[i] == a[i - 1]:\n        A[j] += 1\n    else:\n        A.append(1)\n        j += 1\n        \nc = len(A) - K\ns1 = sum(A[:c])\ns2 = 0\nif c <= 0:\n    ans = 0\nelse:\n    ans = 10 ** 9 + 7\n    for i in range(c + 1):\n        ans = min(ans, s1 + s2)\n        s1 -= A[c - 1 - i]\n        s2 += A[len(A) - 1 - i]\n    \nprint(ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int NMAX = 400005;\nconst int INF = (1 << 29);\nint a[NMAX], v[NMAX], sp[NMAX];\nint main() {\n  int n, I;\n  cin >> n >> I;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  sort(a + 1, a + n + 1);\n  int k = 0;\n  for (int i = 1; i <= n; i++) {\n    if (a[i] != a[i - 1])\n      v[++k] = 1;\n    else\n      v[k]++;\n  }\n  for (int i = 1; i <= n; i++) sp[i] = sp[i - 1] + v[i];\n  if ((8 * I) / n > 41) {\n    cout << 0;\n    return 0;\n  }\n  long long x = 1LL << ((8 * I) / n);\n  if (n - x <= 0) {\n    cout << 0;\n    return 0;\n  }\n  int minim = INF;\n  for (int i = 1; i <= n - x; i++)\n    minim = min(minim, n - (sp[i + x - 1] - sp[i - 1]));\n  cout << minim;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int n, I;\n  cin >> n >> I;\n  map<int, int> occ;\n  for (int i = 0; i < n; i++) {\n    int a;\n    cin >> a;\n    occ[a]++;\n  }\n  vector<int> occs;\n  for (auto &p : occ) {\n    occs.push_back(p.second);\n  }\n  int bits = (8 * I) / n;\n  if (bits > 30) {\n    cout << 0 << endl;\n    return 0;\n  }\n  int max_vals = 1 << bits;\n  if (max_vals >= (int)occs.size()) {\n    cout << 0 << endl;\n    return 0;\n  }\n  int sum = 0;\n  for (int i = 0; i < max_vals; i++) {\n    sum += occs[i];\n  }\n  int res = sum;\n  for (int i = max_vals; i < (int)occs.size(); i++) {\n    sum += occs[i];\n    sum -= occs[i - max_vals];\n    res = max(res, sum);\n  }\n  cout << n - res << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst int N = 1e6;\nlong long a[N], b[N];\nint main() {\n  priority_queue<int, vector<int>, greater<int> > q;\n  int n, I, i, len;\n  long long k, x, ans;\n  cin >> n >> I;\n  I = min(8 * I / n, 20);\n  k = pow(2, I);\n  for (i = 1; i <= n; i++) {\n    cin >> x;\n    q.push(x);\n  }\n  len = 1;\n  a[1] = q.top();\n  b[1] = 1;\n  q.pop();\n  while (!q.empty()) {\n    if (q.top() == a[len]) {\n      b[len]++;\n      q.pop();\n    } else {\n      a[++len] = q.top();\n      q.pop();\n      b[len] = 1;\n    }\n  }\n  if (k >= len)\n    cout << 0 << endl;\n  else {\n    for (i = 1; i <= len; i++) {\n      b[i] += b[i - 1];\n    }\n    ans = inf;\n    for (i = 1; i <= len; i++) {\n      ans = min(ans, n - (b[i + k - 1] - b[i - 1]));\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 4e6 + 5;\nlong long n, a[N], b[N], sum[N], I, lim = 1, mx = -1, Ans;\nlong long read() {\n  long long x = 0, f = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    x = (x << 1) + (x << 3) + c - '0';\n    c = getchar();\n  }\n  return f * x;\n}\nlong long qpow(long long x, long long y) {\n  long long ret = 1;\n  while (y) {\n    if (y & 1) ret = ret * x;\n    y >>= 1;\n    x = x * x;\n  }\n  return ret;\n}\nlong long LG2(long long x) {\n  long long ret = log2(x);\n  if (qpow(2, ret) >= x)\n    return ret;\n  else\n    return ret + 1;\n}\nint main() {\n  memset(sum, 0, sizeof(sum));\n  memset(a, 0, sizeof(a));\n  memset(b, 0, sizeof(b));\n  n = read(), I = read();\n  for (register long long i = (1); i <= (n); i++) a[i] = read();\n  sort(a + 1, a + n + 1);\n  a[0] = -1;\n  for (register long long i = (1); i <= (n); i++) {\n    if (a[i] != a[i - 1])\n      b[++b[0]] = 1;\n    else\n      b[b[0]]++;\n  }\n  for (register long long i = (2); i <= (b[0]); i++) {\n    if (LG2(i) * n <= 8 * I)\n      lim = i;\n    else\n      break;\n  }\n  if (lim >= b[0])\n    printf(\"0\\n\");\n  else {\n    for (register long long i = (1); i <= (b[0]); i++)\n      sum[i] = sum[i - 1] + b[i];\n    for (register long long i = (lim); i <= (b[0]); i++)\n      mx = max(mx, sum[i] - sum[i - lim]);\n    Ans = sum[b[0]] - mx;\n    printf(\"%lld\\n\", Ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\nfrom bisect import *\n\ndef ceil_log2(K):\n    for i in range(30):\n        if 2**i>=K:\n            return i\n\nn, I = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nsa = list(set(a))\n\nfor K in range(n, -1, -1):\n    if n*ceil_log2(K)<=8*I:\n        max_K = K\n        break\n    \nif len(sa)<max_K:\n    print(0)\n    exit()\n\nans = n\n\nfor i in range(len(sa)-max_K+1):\n    left_change = bisect_left(a, sa[i])\n    right_change = n-bisect_right(a, sa[i+max_K-1])\n    ans = min(ans, left_change+right_change)\n\nprint(ans)"
        },
        {
            "language": 1,
            "solution": "from __future__ import division, print_function\n\nDEBUG = 0\n\ndef main():\n    n, I = input_as_list()\n    a = input_as_list()\n\n    a.sort()\n    ac = []\n\n    prev = None\n    c = 0\n    for e in a:\n        if prev is None:\n            prev = e\n            c = 1\n            continue\n\n        if e != prev:\n            ac.append(c)\n\n            prev = e\n            c = 1\n        else:\n            c += 1\n\n    ac.append(c)\n\n    ap = [ac[0]]\n    for i in range(1, len(ac)):\n        ap.append(ap[-1] + ac[i])\n\n    debug_print(ac, ap, sep='\\n')\n\n    d = 2 ** min(I*8//n, 19)\n    debug_print(d)\n    \n    if d >= len(ac):\n        print(0)\n    else:\n        i = 0\n        out = n\n        while i+d < len(ap):\n            out = min(out, n - ap[i+d] + ap[i])\n            i += 1\n        print(out)\n\n\nimport os, sys\nfrom atexit import register\nfrom io import BytesIO\nimport itertools\n\nINF = float('inf')\n\nif sys.version_info[0] < 3:\n    input = raw_input\n    range = xrange\n\n    filter = itertools.ifilter\n    map = itertools.imap\n    zip = itertools.izip\n\nif DEBUG:\n    debug_print = print\nelse:\n    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n    sys.stdout = BytesIO()\n    register(lambda: os.write(1, sys.stdout.getvalue()))\n\n    input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n    debug_print = lambda *x, **y: None\n\n\ndef input_as_list():\n    return list(map(int, input().split()))\n\n\ndef array_of(f, *dim):\n    return [array_of(f, *dim[1:]) for _ in range(dim[0])] if dim else f()\n\n\nmain()"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\nfrom math import log\nfrom collections import deque\nn, i = map(int, input().split())\nl = list(map(int, input().split()))\nif len(set(l)) == 1:\n    print(0)\n    exit(0)\nquota = 8 * i // n\nk = 1\n#print(quota)\nif quota < 1:\n    pass\nelse:\n    k = 2 ** quota\nl = sorted(l)\n \na = l[0]\nb = 1\nd = deque()\nd.append(a)\ni = 1\nans = 1\ncnt = 1\nwhile (i < n):\n    x = l[i]\n    if x != d[-1]:\n        if b == k:\n            y = d[0]\n            while (d[0] == y):\n                d.popleft()\n                cnt -= 1\n                if d == deque():\n                    cnt = 0\n                    break       \n            d.append(x)\n            cnt += 1\n        else:\n            d.append(x)\n            cnt += 1\n            b += 1\n    else:\n        d.append(x)\n        cnt += 1\n    ans = max(cnt, ans)\n    i += 1\n    #print(d, cnt, ans)\nprint(n - ans)"
        },
        {
            "language": 3,
            "solution": "# n, I = 6, 1\n# arr = [2, 1, 2, 3, 4, 3]\nimport sys\n\nn, I = map(int, sys.stdin.readline().split())\narr = list(map(int, sys.stdin.readline().split()))\n\nk_bits = 8*I//n\n\nK = pow(2, k_bits)\n\narr.sort()\n\nb = [0]\n\nfor i in range(1, n):\n\tif arr[i] != arr[i-1]:\n\t\tb.append(i)\n\nif K >= len(b):\n\tprint(0)\nelse:\n\tprint(n - max(b[i+K] - b[i] for i in range(len(b)-K)))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long n, I;\n  cin >> n >> I;\n  long long sv = I * 8;\n  vector<long long> arr(n);\n  for (long long i = 0; i < n; i++) cin >> arr[i];\n  I = 8 * I;\n  I = I / n;\n  long long sp = 1;\n  if (I >= 64) {\n    cout << 0 << endl;\n    return 0;\n  }\n  sp = sp << (I);\n  unordered_map<long long, long long> um;\n  for (long long i = 0; i < n; i++) um[arr[i]]++;\n  vector<pair<long long, long long>> st;\n  long long sum = 0;\n  for (auto i : um) {\n    sum += i.second;\n    st.push_back(i);\n  }\n  sort(st.begin(), st.end());\n  long long l = 0, u = st.size() - 1;\n  n = st.size();\n  long long ans = LLONG_MAX;\n  vector<long long> cum(n, 0);\n  cum[0] = st[0].second;\n  for (long long i = 1; i < n; i++) cum[i] = cum[i - 1] + st[i].second;\n  for (long long i = 0; i <= n - sp; i++) {\n    if (i != 0)\n      ans = min(ans, cum[n - 1] - cum[i + sp - 1] + cum[i - 1]);\n    else\n      ans = min(ans, cum[n - 1] - cum[sp - 1]);\n  }\n  if (sp >= n) ans = 0;\n  if (ans == LLONG_MAX) ans = 0;\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "//package main;\n\nimport java.io.*;\nimport java.util.*;\nimport java.awt.Point;\nimport java.math.BigInteger;\n\npublic final class Main {\n    BufferedReader br;\n    StringTokenizer stk;\n\n    public static void main(String[] args) throws Exception {\n        new Main().run();\n    }\n    \n    {\n        stk = null;\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n    \n    void run() throws Exception {\n        long n = nl(), m = nl() << 3;\n        long[] a = new long[(int)n];\n        HashSet<Long> set = new HashSet<>();\n        for(int i=0; i<n; i++) {\n            a[i] = nl();\n            set.add(a[i]);\n        }\n        \n        long low = 1, high = set.size();\n        while(high - low > 8) {\n            long K = (high + low) >> 1;\n            long k = (long)Math.ceil(Math.log(K)/Math.log(2));\n            long totalRequired = n * k;\n            if(totalRequired <= m) {\n                low = K;\n            } else {\n                high = K;\n            }\n        }\n        \n        long distinct = -1;\n        for(long i=high; i>=low; i--) {\n            long k = (long)Math.ceil(Math.log(i)/Math.log(2));\n            long totalRequired = n * k;\n            if(totalRequired <= m) {\n                distinct = i; break;\n            }\n        }\n        \n        long[] arr = convert(a);\n        for(int i=1; i<arr.length; i++) arr[i] += arr[i-1];\n        //pl(Arrays.toString(arr));\n        long fptr = 0, bptr = distinct - 1, min = Integer.MAX_VALUE;\n        while(bptr < arr.length) {\n            //pl(fptr + \" \" + bptr);\n            long N = n - getSum(arr, (int)fptr, (int)bptr);\n            min = Math.min(min, N);\n            fptr++; bptr++;\n        }\n        \n        pl(min);\n    }\n    \n    void shuffle(long[] a) {\n        Random r = new Random();\n        for(int i=0; i<a.length; i++) {\n            int idx = r.nextInt(a.length);\n            long temp = a[idx];\n            a[idx] = a[i];\n            a[i] = temp;\n        }\n    }\n    \n    long getSum(long[] a, int l, int r) {\n        return l == 0 ? a[r] : a[r] - a[l - 1];\n    }\n    \n    long[] convert(long[] a) {\n        shuffle(a);\n        Arrays.sort(a);\n        Stack<Pair> stack = new Stack<>();\n        stack.push(new Pair(a[0], 1));\n        for(int i=1; i<a.length; i++) {\n            if(stack.peek().a == a[i]) {\n                stack.peek().b++;\n            } else {\n                stack.push(new Pair(a[i], 1));\n            }\n        }\n        long[] ret = new long[stack.size()];\n        while(!stack.isEmpty()) ret[stack.size() - 1] = stack.pop().b;\n        return ret;\n    }\n    \n    class Pair {\n        long a, b;\n        public Pair(long a, long b) {\n            this.a = a;\n            this.b = b;\n        }\n    }\n    \n    //Reader & Writer\n    String nextToken() throws Exception {\n        if (stk == null || !stk.hasMoreTokens()) {\n            stk = new StringTokenizer(br.readLine(), \" \");\n        }\n        return stk.nextToken();\n    }\n\n    String nt() throws Exception {\n        return nextToken();\n    }\n\n    String ns() throws Exception {\n        return br.readLine();\n    }\n\n    int ni() throws Exception {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nl() throws Exception {\n        return Long.parseLong(nextToken());\n    }\n\n    double nd() throws Exception {\n        return Double.parseDouble(nextToken());\n    }\n\n    void p(Object o) {\n        System.out.print(o);\n    }\n\n    void pl(Object o) {\n        System.out.println(o);\n    }\n}"
        },
        {
            "language": 3,
            "solution": "import math\n\n\ndef range_sum(l, r, pref_sums):\n    return pref_sums[r + 1] - pref_sums[l]\n\n\nn, I = [int(i) for i in input().split()]\nI *= 8\nmp3 = sorted([int(i) for i in input().split()])\nmax_n_freq = 2 ** math.floor(I / n)\nchanges = [1]\nlast_value = mp3[0]\nfor i in range(1, len(mp3)):\n    if mp3[i] == last_value:\n        changes[len(changes) - 1] += 1\n    else:\n        changes.append(1)\n        last_value = mp3[i]\nif len(changes) <= max_n_freq:\n    print(0)\nelse:\n    changes_pref_sums = [0, changes[0]]\n    for i in range(1, len(changes)):\n        changes_pref_sums.append(changes_pref_sums[len(changes_pref_sums) - 1] + changes[i])\n    max_undistorted = max(\n        [range_sum(i, i + max_n_freq - 1, changes_pref_sums) for i in range(0, len(changes) - max_n_freq + 1)])\n    print(changes_pref_sums[len(changes_pref_sums) - 1] - max_undistorted)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 4e5 + 5;\nlong long a[maxn];\nlong long pre[maxn];\nmap<long long, long long> mp;\nint main() {\n  int n, l;\n  scanf(\"%d%d\", &n, &l);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%I64d\", &a[i]);\n    mp[a[i]]++;\n  }\n  sort(a, a + n);\n  long long cnt = unique(a, a + n) - a;\n  for (int i = 1; i <= cnt; i++) {\n    pre[i] = pre[i - 1] + mp[a[i - 1]];\n  }\n  l *= 8;\n  long long temp = log(cnt) / log(2);\n  if ((1 << temp) < cnt) temp++;\n  if (temp * n <= l) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  long long sum = l / n;\n  sum = (1 << sum);\n  long long ans = -0x3f3f3f3f;\n  for (int i = 1, j = i + sum; j <= cnt; i++, j++) {\n    ans = max(ans, pre[j] - pre[i]);\n  }\n  printf(\"%I64d\\n\", n - ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 4e5 + 100;\nint a[maxn], b[maxn];\nint cnt[maxn];\nint main() {\n  int n, I;\n  ios::sync_with_stdio(false);\n  cin >> n >> I;\n  I *= 8;\n  I /= n;\n  for (int i = 0; i < n; ++i) cin >> a[i];\n  for (int i = 0; i < n; ++i) b[i] = a[i];\n  sort(b, b + n);\n  int d = unique(b, b + n) - b;\n  for (int i = 0; i < n; ++i) a[i] = lower_bound(b, b + d, a[i]) - b + 1;\n  for (int i = 0; i < n; ++i) cnt[a[i]]++;\n  for (int i = 1; i <= d; ++i) cnt[i] += cnt[i - 1];\n  if (I >= 30)\n    I = d;\n  else\n    I = (1 << I);\n  I = min(I, d);\n  int ans = 0;\n  for (int i = 1; i <= d; ++i) {\n    if (i - I >= 0) ans = max(ans, cnt[i] - cnt[i - I]);\n  }\n  cout << n - ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\nimport java.lang.management.*;\nimport static java.lang.Math.*;\n\n@SuppressWarnings(\"unchecked\")\npublic class P1198A {\n\n  public void run() throws Exception {\n    int n = nextInt(), I8 = nextInt() << 3;\n\n    if (((int)(n * ceil(log(n) / log(2)))) < I8) {\n      println(0);\n      return;\n    }\n\n    int a [] = sort(readInt(n));\n    Map<Integer, Integer> ac = new LinkedHashMap(n);\n    for (int i = 0; i < n; ac.put(a[i], ac.getOrDefault(a[i], 0) + 1), i++);\n\n    int i = -(1 << (I8 / n)), j = 0, ms = 0, s = 0;\n    for (Integer c : ac.values()) {\n      a[j] = c;\n      s = s + c - ((i >= 0) ? a[i] : 0);\n      ms = max(ms, s);\n      i++;\n      j++;\n    }\n\n    println(n - ms);\n  }\n\n  public static void main(String... args) throws Exception {\n    br = new BufferedReader(new InputStreamReader(System.in));\n    pw = new PrintWriter(new BufferedOutputStream(System.out));\n    new P1198A().run();\n    br.close();\n    pw.close();\n    System.err.println(\"\\n[Time : \" + (System.currentTimeMillis() - startTime) + \" ms]\");\n    long gct = 0, gcc = 0;\n    for (GarbageCollectorMXBean garbageCollectorMXBean : ManagementFactory.getGarbageCollectorMXBeans()) {\n      gct += garbageCollectorMXBean.getCollectionTime();\n      gcc += garbageCollectorMXBean.getCollectionCount();\n    }\n    System.err.println(\"[GC time : \" + gct + \" ms, count = \" + gcc + \"]\");\n  }\n\n  static long startTime = System.currentTimeMillis();\n  static BufferedReader br;\n  static PrintWriter pw;\n  StringTokenizer stok;\n\n  String nextToken() throws IOException {\n    while (stok == null || !stok.hasMoreTokens()) {\n      String s = br.readLine();\n      if (s == null) { return null; }\n      stok = new StringTokenizer(s);\n    }\n    return stok.nextToken();\n  }\n\n  void print(byte b) { print(\"\" + b); }\n  void print(int i) { print(\"\" + i); }\n  void print(long l) { print(\"\" + l); }\n  void print(double d) { print(\"\" + d); }\n  void print(char c) { print(\"\" + c); }\n  void print(Object o) {\n    if (o instanceof int[]) { print(Arrays.toString((int [])o));\n    } else if (o instanceof long[]) { print(Arrays.toString((long [])o));\n    } else if (o instanceof char[]) { print(Arrays.toString((char [])o));\n    } else if (o instanceof byte[]) { print(Arrays.toString((byte [])o));\n    } else if (o instanceof short[]) { print(Arrays.toString((short [])o));\n    } else if (o instanceof boolean[]) { print(Arrays.toString((boolean [])o));\n    } else if (o instanceof float[]) { print(Arrays.toString((float [])o));\n    } else if (o instanceof double[]) { print(Arrays.toString((double [])o));\n    } else if (o instanceof Object[]) { print(Arrays.toString((Object [])o));\n    } else { print(\"\" + o); }\n  }\n  void printsp(int [] a) { for (int i = 0, n = a.length; i < n; print(a[i] + \" \"), i++); }\n  void print(String s) { pw.print(s); }\n  void println() { println(\"\"); }\n  void println(byte b) { println(\"\" + b); }\n  void println(int i) { println(\"\" + i); }\n  void println(long l) { println(\"\" + l); }\n  void println(double d) { println(\"\" + d); }\n  void println(char c) { println(\"\" + c); }\n  void println(Object o) { print(o); println(); }\n  void println(String s) { pw.println(s); }\n  int nextInt() throws IOException { return Integer.parseInt(nextToken()); }\n  long nextLong() throws IOException { return Long.parseLong(nextToken()); }\n  double nextDouble() throws IOException { return Double.parseDouble(nextToken()); }\n  char nextChar() throws IOException { return (char) (br.read()); }\n  String next() throws IOException { return nextToken(); }\n  String nextLine() throws IOException { return br.readLine(); }\n  int [] readInt(int size) throws IOException {\n    int [] array = new int [size];\n    for (int i = 0; i < size; i++) { array[i] = nextInt(); }\n    return array;\n  }\n  long [] readLong(int size) throws IOException {\n    long [] array = new long [size];\n    for (int i = 0; i < size; i++) { array[i] = nextLong(); }\n    return array;\n  }\n  double [] readDouble(int size) throws IOException {\n    double [] array = new double [size];\n    for (int i = 0; i < size; i++) { array[i] = nextDouble(); }\n    return array;\n  }\n  String [] readLines(int size) throws IOException {\n    String [] array = new String [size];\n    for (int i = 0; i < size; i++) { array[i] = nextLine(); }\n    return array;\n  }\n\n  int gcd(int a, int b) {\n    if (a == 0) return Math.abs(b); if (b == 0) return Math.abs(a);\n    a = Math.abs(a); b = Math.abs(b);\n    int az = Integer.numberOfTrailingZeros(a), bz = Integer.numberOfTrailingZeros(b);\n    a >>>= az; b >>>= bz;\n    while (a != b) {\n      if (a > b) { a -= b; a >>>= Integer.numberOfTrailingZeros(a); }\n            else { b -= a; b >>>= Integer.numberOfTrailingZeros(b); }\n    }\n    return (a << Math.min(az, bz));\n  }\n\n  long gcd(long a, long b) {\n    if (a == 0) return Math.abs(b); if (b == 0) return Math.abs(a);\n    a = Math.abs(a); b = Math.abs(b);\n    int az = Long.numberOfTrailingZeros(a), bz = Long.numberOfTrailingZeros(b);\n    a >>>= az; b >>>= bz;\n    while (a != b) {\n      if (a > b) { a -= b; a >>>= Long.numberOfTrailingZeros(a); }\n            else { b -= a; b >>>= Long.numberOfTrailingZeros(b); }\n    }\n    return (a << Math.min(az, bz));\n  }\n\n  void shuffle(int [] a) { // RANDOM shuffle\n    Random r = new Random();\n    for (int i = a.length - 1, j, t; i >= 0; j = r.nextInt(a.length), t = a[i], a[i] = a[j], a[j] = t, i--);\n  }\n\n  void shuffle(int [] a, int m) { // QUICK shuffle\n    for (int i = 0, n = a.length, j = m % n, t; i < n; t = a[i], a[i] = a[j], a[j] = t, i++, j = (i * m) % n);\n  }\n\n  void shuffle(long [] a) {\n    Random r = new Random();\n    for (int i = a.length - 1; i >= 0; i--) {\n      int j = r.nextInt(a.length);\n      long t = a[i]; a[i] = a[j]; a[j] = t;\n    }\n  }\n\n  void shuffle(Object [] a) {\n    Random r = new Random();\n    for (int i = a.length - 1; i >= 0; i--) {\n      int j = r.nextInt(a.length);\n      Object t = a[i]; a[i] = a[j]; a[j] = t;\n    }\n  }\n\n  int [] sort(int [] a) {\n    final int SHIFT = 16, MASK = (1 << SHIFT) - 1, SIZE = (1 << SHIFT) + 1;\n    int n = a.length, ta [] = new int [n], ai [] = new int [SIZE];\n    for (int i = 0; i < n; ai[(a[i] & MASK) + 1]++, i++);\n    for (int i = 1; i < SIZE; ai[i] += ai[i - 1], i++);\n    for (int i = 0; i < n; ta[ai[a[i] & MASK]++] = a[i], i++);\n    int [] t = a; a = ta; ta = t;\n    ai = new int [SIZE];\n    for (int i = 0; i < n; ai[(a[i] >> SHIFT) + 1]++, i++);\n    for (int i = 1; i < SIZE; ai[i] += ai[i - 1], i++);\n    for (int i = 0; i < n; ta[ai[a[i] >> SHIFT]++] = a[i], i++);\n    return ta;\n  }\n\n  void flush() {\n    pw.flush();\n  }\n\n  void pause() {\n    flush(); System.console().readLine();\n  }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class Solve6 {\n\n    public static void main(String[] args) throws IOException {\n        PrintWriter pw = new PrintWriter(System.out);\n        new Solve6().solve(pw);\n        pw.flush();\n        pw.close();\n    }\n\n    public void solve(PrintWriter pw) throws IOException {\n        FastReader sc = new FastReader();\n        int n = sc.nextInt(), size = sc.nextInt() * 8;\n        int k = size / n;\n        TreeMap<Integer, Integer> t = new TreeMap();\n        for (int i = 0; i < n; i++) {\n            int x = sc.nextInt();\n            t.put(x, t.getOrDefault(x, 0) + 1);\n        }\n        int diff = t.size();\n        int bits = (int) Math.ceil(Math.log(diff) / Math.log(2));\n        if (bits <= k) {\n            pw.println(0);\n        } else {\n            diff = (int) Math.pow(2, k);\n            int[] a = new int[t.size()];\n            int[] prefix = new int[t.size()], suffix = new int[t.size()];\n            int i = 0;\n            for (Map.Entry<Integer, Integer> temp : t.entrySet()) {\n                a[i] = temp.getValue();\n                prefix[i] = a[i] + (i > 0 ? prefix[i - 1] : 0);\n                i++;\n            }\n            for (int j = t.size() - 1; j >= 0; j--) {\n                suffix[j] = a[j] + (j < t.size() - 1 ? suffix[j + 1] : 0);\n            }\n            int min = Integer.MAX_VALUE;\n            for (int j = 0; j <= t.size() - diff; j++) {\n                min = Math.min(min, (j + diff < t.size() ? suffix[j + diff] : 0) + (j > 0 ? prefix[j - 1] : 0));\n            }\n            pw.println(min);\n        }\n    }\n\n    static class FastReader {\n\n        StringTokenizer st;\n        BufferedReader br;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public String next() throws IOException {\n            if (st == null || !st.hasMoreTokens()) {\n                st = new StringTokenizer(br.readLine());\n            }\n            return st.nextToken();\n        }\n\n        public boolean hasNext() throws IOException {\n            if (st != null && st.hasMoreTokens()) {\n                return true;\n            }\n            String s = br.readLine();\n            if (s == null || s.isEmpty()) {\n                return false;\n            }\n            st = new StringTokenizer(s);\n            return true;\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nbool rmn(T &a, T b) {\n  return a > b ? (a = b, true) : false;\n}\ntemplate <class T>\nbool rmx(T &a, T b) {\n  return a < b ? (a = b, true) : false;\n}\nconst long long INFLL = 0x7f7f7f7f7f7f7f7f, MOD = 1e9 + 7;\nconst long long INF = 0x7f7f7f7f;\nvector<vector<pair<long long, long long>>> adj;\nvector<long long> vis, color;\nlong long dx8[] = {0, 1, 1, 1, 0, -1, -1, -1},\n          dy8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dx4[] = {0, 1, 0, -1},\n          dy4[] = {1, 0, -1, 0};\ninline long long mexp(long long x, long long n, long long m = MOD) {\n  long long res = 1;\n  x %= m;\n  while (n) {\n    if (n & 1) res = (res * x) % m;\n    n >>= 1;\n    x = (x * x) % m;\n  }\n  return res;\n}\ninline long long gcd(long long a, long long b) {\n  if (a < 0) a = -a;\n  if (b < 0) b = -b;\n  while (a > 0 && b > 0) {\n    if (a > b)\n      a %= b;\n    else\n      b %= a;\n  }\n  return a + b;\n}\nint32_t main(void) {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cout << fixed;\n  cerr << fixed;\n  cout << setprecision(10);\n  cerr << setprecision(3);\n  mt19937 genr(chrono::high_resolution_clock::now().time_since_epoch().count());\n  long long n, k;\n  cin >> n >> k;\n  k = (8 * k) / n;\n  map<long long, long long> m;\n  for (long long i = 0; i < n; ++i) {\n    long long t;\n    cin >> t;\n    m[t]++;\n  }\n  long long ans = 0;\n  if (k >= 19 || (1 << k) >= ((long long)(m).size())) {\n    ans = n;\n  } else if (k == 0) {\n    for (auto &[e, f] : m) ans = max(ans, f);\n  } else {\n    long long w = 1 << k, cur = 0;\n    auto p = m.begin(), q = p;\n    for (long long i = 0; i < w && p != m.end(); ++i, ++p) cur += (*p).second;\n    ans = max(ans, cur);\n    while (p != m.end()) {\n      cur += (*p).second - (*q).second;\n      ans = max(ans, cur);\n      ++p, ++q;\n    }\n  }\n  cout << n - ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "\"\"\"\nCode Forces Template\n\"\"\"\nimport os\nimport sys\nimport string\nimport math\n\n\ndef main(n, I, data):\n    \"\"\"Algrithm\"\"\"\n    max_k = 8 * I // n\n    max_K = 2 ** max_k\n    counts = {}\n    for num in data:\n        if num not in counts:\n            counts[num] = 0\n        counts[num] += 1\n    values = sorted(counts.keys())\n    counts = [counts[key] for key in values]\n    if len(counts) <= max_K:\n        return 0\n\n    s = [0]\n    for i in range(len(counts)):\n        s.append(s[-1] + counts[i])\n    total = s[-1]\n    ans = total\n    # sum(counts[:i]) = s[i]\n    # sum(counts[i:j]) = s[j] - s[i]\n    for i in range(len(counts) - max_K + 1):\n        ans = min(\n            ans,\n            total - s[i + max_K] + s[i]\n        )\n    return ans\n\ndef parse():\n    \"\"\"Load Input\"\"\"\n    n, I = input().split(' ')\n    n, I = int(n), int(I)\n    data = [int(i) for i in input().split(' ')]\n    return n, I, data\n\n\ndef output(ans):\n    print(ans)\n\n\nif __name__ == '__main__':\n    output(main(*parse()))\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.text.*;\npublic class cf3 {\n    static long mod = (long)1e9 + 7;\n    static long mod1 = 998244353;\n    static FastScanner f;\n    static PrintWriter pw = new PrintWriter(System.out);\n    static Scanner S = new Scanner(System.in);\n    static long x0; static long y0;\n    static void solve()throws IOException {\n        int n = f.ni(); int I = f.ni() * 8;\n        int k = I / n; k = (int)(Math.pow(2 , k) + 0.5);\n        TreeMap<Long , Long> h = new TreeMap<>();\n        long arr[] = inplong(n); sort(arr);\n        for(int i = 0; i < n; ++i) {\n            if(h.containsKey(arr[i])) h.put(arr[i] , h.get(arr[i]) + 1l);\n            else h.put(arr[i] , 1l);\n        }\n        if(k >= h.size()) {pn(0); return;}\n        long pref[] = new long[h.size() + 1];\n        int j = 1; pref[0] = 0l; pref[1] = h.get(h.firstKey());\n        for(Long i : h.values()) {\n            pref[j] = pref[j - 1] + i;\n            ++j;\n        }\n        long ans = (long)1e12;\n        for(int i = k; i < h.size() + 1; ++i) {\n            ans = Math.min(ans , (pref[h.size()] - pref[i] + pref[i - k]));\n        }\n        pn(ans);\n    }\n    public static void main(String[] args)throws IOException {\n        init();\n        int t = 1;\n        while(t --> 0) {solve();}\n        pw.flush(); \n        pw.close();  \n    }\n        \n/******************************END OF MAIN PROGRAM*******************************************/\n    public static void init()throws IOException{if(System.getProperty(\"ONLINE_JUDGE\")==null){f=new FastScanner(\"\");}else{f=new FastScanner(System.in);}}\n    public static class FastScanner {\n        BufferedReader br;StringTokenizer st;\n        FastScanner(InputStream stream){try{br=new BufferedReader(new InputStreamReader(stream));}catch(Exception e){e.printStackTrace();}}\n        FastScanner(String str){try{br=new BufferedReader(new FileReader(\"!a.txt\"));}catch(Exception e){e.printStackTrace();}}\n        String next(){while(st==null||!st.hasMoreTokens()){try{st=new StringTokenizer(br.readLine());}catch(IOException e){e.printStackTrace();}}return st.nextToken();}\n        String nextLine()throws IOException{return br.readLine();}int ni(){return Integer.parseInt(next());}long nl(){return Long.parseLong(next());}double nd(){return Double.parseDouble(next());}\n    }\n    public static void pn(Object o){pw.println(o);}\n    public static void p(Object o){pw.print(o);}\n    public static void pni(Object o){pw.println(o);pw.flush();}\n    static int gcd(int a,int b){if(b==0)return a;else{return gcd(b,a%b);}}\n    static long lcm(long a,long b){return (a*b/gcd(a,b));}\n    static long gcd(long a,long b){if(b==0)return a;else{return gcd(b,a%b);}}\n    static long exgcd(long a,long b){if(b==0){x0=1;y0=0;return a;}long temp=exgcd(b,a%b);long t=x0;x0=y0;y0=t-a/b*y0;return temp;}\n    static long pow(long a,long b){long res=1;while(b>0){if((b&1)==1)res=res*a;b>>=1;a=a*a;}return res;}\n    static long mpow(long a,long b){long res=1;while(b>0){if((b&1)==1)res=((res%mod)*(a%mod))%mod;b>>=1;a=((a%mod)*(a%mod))%mod;}return res;}\n    static long mul(long a , long b){return ((a%mod)*(b%mod)%mod);}\n    static long adp(long a , long b){return ((a%mod)+(b%mod)%mod);}\n    static boolean isPrime(long n){if(n<=1)return false;if(n<=3)return true;if(n%2==0||n%3==0)return false;for(long i=5;i*i<=n;i=i+6)if(n%i==0||n%(i+2)==0)return false;return true;}\n    static boolean isPrime(int n){if(n<=1)return false;if(n<=3)return true;if(n%2==0||n%3==0)return false;for(int i=5;i*i<=n;i=i+6)if(n%i==0||n%(i+2)==0)return false;return true;}\n    static HashSet<Long> factors(long n){HashSet<Long> hs=new HashSet<Long>();for(long i=1;i<=(long)Math.sqrt(n);i++){if(n%i==0){hs.add(i);hs.add(n/i);}}return hs;}\n    static HashSet<Integer> factors(int n){HashSet<Integer> hs=new HashSet<Integer>();for(int i=1;i<=(int)Math.sqrt(n);i++){if(n%i==0){hs.add(i);hs.add(n/i);}}return hs;}\n    static HashSet<Long> pf(long n){HashSet<Long> ff=factors(n);HashSet<Long> ans=new HashSet<Long>();for(Long i:ff)if(isPrime(i))ans.add(i);return ans;}\n    static HashSet<Integer> pf(int n){HashSet<Integer> ff=factors(n);HashSet<Integer> ans=new HashSet<Integer>();for(Integer i:ff)if(isPrime(i))ans.add(i);return ans;}\n    static int[] inpint(int n){int arr[]=new int[n];for(int i=0;i<n;i++){arr[i]=f.ni();}return arr;}\n    static long[] inplong(int n){long arr[] = new long[n];for(int i=0;i<n;i++){arr[i]=f.nl();}return arr;}\n    static boolean ise(int x){return ((x&1)==0);}static boolean ise(long x){return ((x&1)==0);}\n    static int gnv(char c){return Character.getNumericValue(c);}\n    static int log(long x){return x==1?0:(1+log(x/2));} static int log(int x){return x==1?0:(1+log(x/2));}\n    static void sort(int[] a){ArrayList<Integer> l=new ArrayList<>();for(int i:a)l.add(i);Collections.sort(l);for(int i=0;i<a.length;++i)a[i]=l.get(i);}\n    static void sort(long[] a){ArrayList<Long> l=new ArrayList<>();for(long i:a)l.add(i);Collections.sort(l);for(int i=0;i<a.length;++i)a[i]=l.get(i);}\n    static void sort(ArrayList<Integer> a){Collections.sort(a);}\n}"
        },
        {
            "language": 3,
            "solution": "n, p = map(int, input().strip().split())\nx = list(map(int, input().strip().split()))\nx.sort()\nt = 2**((8*p)//n)\nlast = None\ny = []\nfor c in x:\n    if last is None or last != c:\n        last = c\n        y.append(1)\n    else:\n        y[-1] += 1\nbest = 0\nnow = 0\nfor i in range(len(y)):\n    now += y[i]\n    if i >= t:\n        now -= y[i-t]\n    best = max(best, now)\nprint(n-best)"
        },
        {
            "language": 3,
            "solution": "from sys import stdin,stdout\nfrom math import gcd,sqrt,factorial,pi\nfrom collections import deque,defaultdict\ninput=stdin.readline\nR=lambda:map(int,input().split())\nI=lambda:int(input())\nS=lambda:input().rstrip('\\n')\nL=lambda:list(R())\nP=lambda x:stdout.write(x)\nlcm=lambda x,y:(x*y)//gcd(x,y)\nhg=lambda x,y:((y+x-1)//x)*x\npw=lambda x:1 if x==1 else 1+pw(x//2)\nchk=lambda x:chk(x//2) if not x%2 else True if x==1 else False\nsm=lambda x:(x**2+x)//2\nN=10**9+7\nn,k=R()\nmn=2**((k*8)//n)\nk=0\nlst=-1\na=[]\nfor i in sorted(R()):\n\tif i!=lst:\n\t\ta+=0,\n\t\tk+=1\n\ta[-1]+=1\n\tlst=i\nif k<=mn:print(0);exit()\nans=0\nfor i in range(mn):\n\tans+=a[i]\nval=ans\nfor i in range(mn,k):\n\tval+=a[i]\n\tval-=a[i-mn]\n\tans=max(ans,val)\nprint(sum(a)-ans)"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class Solution{\n    \n   public static void merge(int[] l,int[] r,int[] a){\n       int i=0,j=0,k=0;\n       int nl = l.length;\n       int nr = r.length;\n       while(i<nl && j<nr){\n           if(l[i]<r[j]){\n               a[k] = l[i];\n               i++;\n           }\n           else{\n               a[k] = r[j];\n               j++;\n           }\n           k++;\n       }\n       while(i<nl){\n           a[k] = l[i];\n           i++;\n           k++;\n       }\n       while(j<nr){\n           a[k] = r[j];\n           j++;\n           k++;\n       }\n   }\n   \n   public static void mergesort(int[] a){\n       int n = a.length;\n       if(n==1){}\n       else{\n           int nl = n/2;\n           int nr = n-nl;\n           int[] l = new int[nl];\n           int[] r = new int[nr];\n           for(int i=0;i<nl;i++){\n               l[i] = a[i];\n           }\n           for(int i=nl;i<n;i++) r[i-nl] = a[i];\n           mergesort(l);\n           mergesort(r);\n           merge(l,r,a);\n       }\n   }\n   \n    \n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        double I = Double.parseDouble(st.nextToken());\n        int[] a = new int[n];\n        st = new StringTokenizer(br.readLine());\n        for(int i=0;i<n;i++) a[i] = Integer.parseInt(st.nextToken());\n        mergesort(a);\n        \n        \n        \n        \n            int dif = 1;\n            for(int i=1;i<n;i++) {\n                if(a[i]!=a[i-1]) dif++;\n            }\n            \n            int[] b = new int[dif];\n            int[] nb = new int[dif];\n            b[0] = a[0];\n            nb[0] = 1;\n            int ind = 0;\n            \n            for(int i=1;i<n;i++){\n                if(a[i]!=a[i-1]){\n                    ind++;\n                    b[ind] = a[i];\n                    nb[ind] = 1;\n                }else{\n                    nb[ind]++;\n                }\n            }\n            \n            \n            int k = (int) ((I*8.0)/n);\n            if(k>28) k = n;\n            else k = 1<<k;\n            if(k>=n) System.out.println(\"0\");\n            else{\n                int max = 0;\n                ind = 0;\n                int nbr = nb[0];\n                int nbb = 1;\n                if(nbb<=k) max = nbr;\n                for(int i=0;i<dif;i++){\n                    if(i==ind+1){\n                        ind++;\n                        nbr += nb[i];\n                        nbb++;\n                    }\n                    if(i!=0){\n                        nbr -= nb[i-1];\n                        nbb--;\n                    }\n                    \n                    while(ind<dif-1){\n                        if(nbb+1>k) break;\n                        ind++;\n                        nbr += nb[ind];\n                        nbb++;\n                    }\n                    if(nbb<=k) max = (int) Math.max(nbr,max);\n                    \n                    \n                }\n                max = n - max;\n                System.out.println(max);\n            }\n            \n\n        \n\n    }\n    \n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, I, k = 1, K, arr[400005], now, t, l, r, has;\nvector<long long> v;\nint main() {\n  cin >> n >> I;\n  for (long long i = 1; i <= n; i++) cin >> arr[i];\n  sort(arr + 1, arr + n + 1);\n  K = 8 * I / n;\n  for (int i = 1; i <= K; i++) {\n    k *= 2;\n    if (k >= n) {\n      cout << \"0\" << endl;\n      return 0;\n    }\n  }\n  t = 1;\n  now = arr[1];\n  for (long long i = 2; i <= n; i++) {\n    if (arr[i] == now)\n      t++;\n    else {\n      now = arr[i];\n      v.push_back(t);\n      t = 1;\n    }\n  }\n  v.push_back(t);\n  if (v.size() <= k) {\n    cout << \"0\" << endl;\n    return 0;\n  }\n  has = n;\n  for (long long i = k; i < v.size(); i++) r += v[i];\n  for (long long i = 0; i < v.size() - k; i++) {\n    has = min(has, l + r);\n    l += v[i];\n    r -= v[i + k];\n  }\n  has = min(has, l + r);\n  cout << has << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class Cp {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString readLine[] = br.readLine().split(\" \");\n\t\tint n = Integer.parseInt(readLine[0]);\n\t\tint I = Integer.parseInt(readLine[1]);\n\t\tint K = 0;\n\t\tint pow = (int) Math.ceil(8 * I / n);\n\t\tif (pow >= 20) {\n\t\t\tSystem.out.println(0);\n\t\t\tSystem.exit(0);\n\t\t} else if (Math.pow(2, pow) >= n) {\n\t\t\tSystem.out.println(0);\n\t\t\tSystem.exit(0);\n\t\t} else {\n\t\t\tK = (int) Math.pow(2, pow);\n\t\t}\n\t\tString readLine2[] = br.readLine().split(\" \");\n\t\tHashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!hm.containsKey(Integer.parseInt(readLine2[i])))\n\t\t\t\thm.put(Integer.parseInt(readLine2[i]), 1);\n\t\t\telse\n\t\t\t\thm.put(Integer.parseInt(readLine2[i]), hm.get(Integer.parseInt(readLine2[i])) + 1);\n\n\t\t}\n\t\tArrayList<Pair> al = new ArrayList<Pair>();\n\t\tfor (Integer pair : hm.keySet()) {\n\t\t\tal.add(new Pair(pair, hm.get(pair)));\n\t\t}\n\n\t\tal.sort(null);\n\t\tint max = 0;\n\t\tint sum = 0;\n\t\tif(K>al.size()) {\n\t\t\tSystem.out.println(0);\n\t\t\tSystem.exit(0);\n\t\t}\n\t\tfor (int j = 0; j < K; j++) {\n\t\t\tsum += al.get(j).value;\n\n\t\t}\n\t\tmax = sum;\n\t\t\n\t\tfor (int j = K; j < al.size(); j++) {\n\t\t\tsum += al.get(j).value;\n\n\t\t\tsum -= al.get(j - K).value;\n\n\t\t\tif (sum > max) {\n\t\t\t\tmax = sum;\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(n - max);\n\t}\n}\n\nclass Pair implements Comparator<Pair>, Comparable<Pair> {\n\tint key, value;\n\n\t@Override\n\tpublic String toString() {\n\t\t// TODO Auto-generated method stub\n\t\treturn \"key:\" + key + \" value: \" + value;\n\t}\n\n\tpublic Pair(int i, int j) {\n\t\tkey = i;\n\t\tvalue = j;\n\n\t}\n\n\t@Override\n\tpublic int compare(Pair o1, Pair o2) {\n\t\t// TODO Auto-generated method stub\n\t\treturn o1.compareTo(o2);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\t// TODO Auto-generated method stub\n\t\treturn key;\n\t}\n\n\t@Override\n\tpublic int compareTo(Pair o) {\n\t\t// TODO Auto-generated method stub\n\t\treturn this.key - o.key;\n\t}\n\n}\n\nclass TCS implements Comparable<TCS>, Comparator<TCS> {\n\tlong i1, i2;\n\n\t@Override\n\tpublic String toString() {\n\t\t// TODO Auto-generated method stub\n\t\treturn \"i1:\" + i1 + \"  i2:\" + i2;\n\t}\n\n\tTCS(long i1, long i2) {\n\t\tthis.i1 = i1;\n\t\tthis.i2 = i2;\n\t}\n\n\t@Override\n\tpublic int compareTo(TCS o) {\n\t\t// TODO Auto-generated method stub\n\t\treturn compare(this, o);\n\t}\n\n\t@Override\n\tpublic int compare(TCS o1, TCS o2) {\n\t\t// TODO Auto-generated method stub\n\t\treturn (int) ((o1.i1 == o2.i1) ? o1.i2 - o2.i2 : o1.i1 - o2.i1);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\t// TODO Auto-generated method stub\n\t\treturn super.hashCode();\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\t// TODO Auto-generated method stub\n\t\treturn super.equals(obj);\n\t}\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int SIZE = 4e5 + 10;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-5;\nconst double PI = atan(1.0) * 4.0;\nconst long long mod = 1e9 + 7;\nint n, I, a[SIZE], b[SIZE], sum[SIZE];\nint main() {\n  scanf(\"%d%d\", &n, &I);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  int bits = I * 8 / n;\n  int d = 1;\n  for (int i = 1; i <= bits; i++) {\n    if (d > n) {\n      puts(\"0\");\n      return 0;\n    }\n    d *= 2;\n  }\n  sort(a + 1, a + 1 + n);\n  int loc = 1;\n  b[1] = 1;\n  for (int i = 2; i <= n; i++) {\n    if (a[i] == a[loc])\n      b[loc]++;\n    else\n      a[++loc] = a[i], b[loc]++;\n  }\n  for (int i = 1; i <= loc; i++) sum[i] = sum[i - 1] + b[i];\n  if (loc <= d) {\n    puts(\"0\");\n    return 0;\n  }\n  int cnt = 0, l = 1, r = d;\n  int ans = sum[loc] - sum[r];\n  while (r < loc) {\n    l++, r++;\n    int tmp = sum[l - 1] + (sum[loc] - sum[r]);\n    ans = min(ans, tmp);\n  }\n  printf(\"%d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "from fractions import gcd\nfrom math import factorial, ceil, sqrt, atan2, log, pi, e, asin,acos, cos, sin, floor, atan\nfrom itertools import *\nfrom fractions import Fraction\nimport string\nimport copy\nimport random\nimport bisect\nfrom decimal import *\nfrom collections import deque\nfrom sys import *\ndigs = string.digits + string.ascii_letters\n\ndef id_generator(size=20, chars='ABCDEFGHIJ'):\n    return ''.join(random.choice(chars) for _ in range(size))\n \ndef mp():\n    return map(int,str(raw_input()).strip().split())\n\nclear=stdout.flush()\n\nmod = 998244353 \n\nn,k=mp()\nl=list(mp())\nl.sort()\nx=set(l)\nx=list(x)\nk=k*8\nk=k/n\n# k=(k-1)/n+1\n# print k\ny=pow(2, k)\nif len(x)<=y:\n\tprint 0\n\texit()\ni=0\nfreq=[0 for i in range(len(x))]\nd={}\nfor i in range(len(x)):\n\td[x[i]]=i\nfor i in range(n):\n\tfreq[d[l[i]]]+=1\n\n# print freq, y\ni=y\ntemp=sum(freq[:i])\nans=temp\nwhile i<len(x):\n\ttemp-=freq[i-y]\n\ttemp+=freq[i]\n\tans=max(ans, temp)\n\ti+=1\nprint n-ans"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline long long mlog(long long x) {\n  long long res = 0, d = 1;\n  while (d < x) {\n    d <<= 1;\n    ++res;\n  }\n  return res;\n}\nint32_t main() {\n  ios_base ::sync_with_stdio(false);\n  long long n, I;\n  cin >> n >> I;\n  I <<= 3;\n  vector<long long> a(n);\n  map<long long, long long> m;\n  for (auto& i : a) {\n    cin >> i;\n    ++m[i];\n  }\n  vector<pair<long long, long long>> b;\n  for (auto& i : m) {\n    b.push_back(i);\n    if (b.size() > 1) {\n      b[b.size() - 1].second += b[b.size() - 2].second;\n    }\n  }\n  long long ans = 1;\n  for (long long i = 0; i < b.size(); ++i) {\n    long long l = i, r = b.size() - 1;\n    while (l + 1 < r) {\n      long long mid = l + r >> 1;\n      long long temp_unique_number = mid - i + 1;\n      if (n * mlog(temp_unique_number) <= I) {\n        l = mid;\n      } else {\n        r = mid - 1;\n      }\n    }\n    {\n      long long temp_number =\n          i > 0 ? b[r].second - b[i - 1].second : b[r].second;\n      long long temp_unique_number = r - i + 1;\n      if (n * mlog(temp_unique_number) <= I && temp_number > ans) {\n        ans = temp_number;\n      }\n    }\n    {\n      long long temp_number =\n          i > 0 ? b[l].second - b[i - 1].second : b[l].second;\n      long long temp_unique_number = l - i + 1;\n      if (n * mlog(temp_unique_number) <= I && temp_number > ans) {\n        ans = temp_number;\n      }\n    }\n  }\n  cout << n - ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  unsigned long long int n, I, k, K;\n  cin >> n >> I;\n  if (I * 8 >= (n) * (int(log2(n)) + 1)) {\n    cout << 0 << endl;\n    return 0;\n  }\n  K = pow(2, int(8 * I / n));\n  int arr[n];\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i];\n  }\n  sort(arr, arr + n);\n  vector<int> freq;\n  int ref = arr[0], count = 1;\n  for (int i = 1; i < n; i++) {\n    if (arr[i] == ref) {\n      count++;\n    }\n    if (arr[i] != ref) {\n      freq.push_back(count);\n      count = 1;\n      ref = arr[i];\n    }\n  }\n  freq.push_back(count);\n  if (K == 1) {\n    cout << (n - (*max_element(freq.begin(), freq.end()))) << endl;\n    return 0;\n  }\n  k = freq.size();\n  if (k < K) {\n    cout << 0 << endl;\n    return 0;\n  }\n  vector<int> econ;\n  econ.assign((k - K + 1), 0);\n  for (int i = 0; i < K; i++) {\n    econ[0] += freq[i];\n  }\n  for (int i = 1; i < (k - K + 1); i++) {\n    econ[i] = econ[i - 1];\n    econ[i] -= freq[i - 1];\n    econ[i] += freq[i + K - 1];\n  }\n  cout << (n - (*max_element(econ.begin(), econ.end()))) << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.util.stream.Collectors;\nimport java.io.InputStreamReader;\nimport java.util.List;\nimport java.util.stream.Stream;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyScanner in = new MyScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, MyScanner in, PrintWriter out) {\n            int n, I;\n            n = in.nextInt();\n            I = in.nextInt() * 8;\n\n            int bits = I / n;\n            if (bits >= 20) {\n                out.println(0);\n                return;\n            }\n            int possibleCountOfDifferentElement = 1 << bits;\n\n            Integer[] a = new Integer[n];\n            Map<Integer, Integer> cnt = new HashMap<>();\n\n            for (int i = 0; i < a.length; i++) {\n                a[i] = in.nextInt();\n                cnt.put(a[i], cnt.getOrDefault(a[i], 0) + 1);\n            }\n\n\n            if (cnt.size() <= possibleCountOfDifferentElement) {\n                out.println(0);\n                return;\n            }\n\n            // Arrays.sort(); <---  What a stupid person came up with this f**ing sort?\n            List<Integer> forSortOnly = Arrays.stream(a).sorted().collect(Collectors.toList());\n\n            for (int i = 0; i < forSortOnly.size(); i++) {\n                a[i] = forSortOnly.get(i);\n            }\n\n\n            Arrays.sort(a);\n\n            int[] diffs = new int[cnt.size()];\n            int last = 0;\n            for (int i = 0; i < a.length; ) {\n                diffs[last] = cnt.get(a[i]);\n                i += diffs[last];\n                last++;\n            }\n\n            long answer = 0;\n            long curSum = 0;\n            for (int i = 0; i < possibleCountOfDifferentElement; i++) {\n                curSum += diffs[i];\n            }\n\n            answer = curSum;\n\n            for (int i = possibleCountOfDifferentElement; i < diffs.length; i++) {\n                curSum += diffs[i];\n                curSum -= diffs[i - possibleCountOfDifferentElement];\n                answer = Math.max(answer, curSum);\n            }\n            out.println(n - answer);\n        }\n\n    }\n\n    static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner(InputStream io) {\n            br = new BufferedReader(new InputStreamReader(io));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin\ninput=stdin.readline\nn,I=map(int,input().split())\na=sorted(list(map(int,input().split())))\nkey=[]\nk=min(I*8//n,20)\nK=min(2**k,n)\nlast=-1\nfor i in range(n):\n    if a[i]==last:\n        key[-1]+=1\n    else:\n        key.append(1)\n        last=a[i]\nnow=0\nbest=0\nfor i in range(len(key)):\n    if i<K:\n        now+=key[i]\n    else:\n        now+=key[i]\n        now-=key[i-K]\n    best=max(now,best)\nprint(n-best)"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\n/**\n * Created by AMK on 7/30/2019.\n * Life is nice :)\n * Enjoy coding :D\n */\npublic class Main3 {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int N = Integer.parseInt(st.nextToken());\n        int I = Integer.parseInt(st.nextToken());\n        int k = I*8/N;\n        if(k > 20){\n            System.out.println(0); return;\n        }\n        TreeMap<Integer, Integer> map = new TreeMap<>();\n        st = new StringTokenizer(br.readLine());\n        for(int i = 0; i < N; i++){\n            int a = Integer.parseInt(st.nextToken());\n            if(map.containsKey(a)) map.put(a, map.get(a)+1);\n            else map.put(a, 1);\n        }\n        int M = map.size();\n        int K = 1 << k;\n        if(K >= M){\n            System.out.println(0); return;\n        }\n        Integer[] keys = new Integer[M];\n        map.keySet().toArray(keys);\n        long[] vals = new long[M];\n        for(int i = 0; i < M; i++){\n            vals[i] = map.get(keys[i]);\n        }\n        long[] accv = new long[M+1];\n        for(int i = 1; i <= M; i++){\n            accv[i] = vals[i-1] + accv[i-1];\n        }\n        long min = 400001;\n        for(int a = 0; a + K - 1 < M; a++){\n            long curr = accv[M] - (accv[a+K] - accv[a]);\n            min = Long.min(min, curr);\n        }\n        System.out.println(min);\n    }\n}"
        },
        {
            "language": 3,
            "solution": "from sys import stdin\nfrom collections import defaultdict\n\ninput = stdin.readline\n\nn, I = list(map(int, input().split()))\na = sorted(list(map(int, input().split())))\nd = defaultdict(int)\nfor v in a:\n    d[v] += 1\nd = sorted(d.items())\nk = min(n, 2**(int(8 * I / n)))\noff = len(d) - k\nif off <= 0 or n == 1:\n    print(0)\nelif off == 1:\n    print(min(d[0][1], d[-1][1]))\nelse:\n    K = len(d)\n    ls = [d[0][1]]\n    for i in range(1, off):\n        ls.append(ls[-1] + d[i][1])\n    rs = [d[-1][1]]\n    for i in range(K-2, K-off-1, -1):\n        rs.append(rs[-1] + d[i][1])\n    m = min(ls[off-1], rs[off-1])\n    l = off - 1\n    r = -1\n    for i in range(off-1):\n        l -= 1\n        r += 1\n        s = ls[l] + rs[r]\n        if s < m:\n            m = s\n    print(m)"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class C implements Runnable {\n\tpublic static void main (String[] args) {new Thread(null, new C(), \"_cf\", 1 << 28).start();}\n\n\tint[] get;\n\t\n\tpublic void run() {\n\t\tFastScanner fs = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tSystem.err.println(\"\");\n\n\t\tget = new int[400400];\n\t\tArrays.fill(get, -1);\n\t\tint n = fs.nextInt();\n\t\tint size = fs.nextInt();\n\t\tint[] a = fs.nextIntArray(n);\n\t\tsort(a);\n\t\tint[] pref = new int[n];\n\t\tArrayList<Integer> pos = new ArrayList();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tpref[i] = 1;\n\t\t\tpos.add(i);\n\t\t\tint j = i;\n\t\t\twhile(j < n && a[i] == a[j]) j++;\n\t\t\ti = --j;\n\t\t}\n\t\tfor(int i = 1; i < n; i++) {\n\t\t\tpref[i] += pref[i-1];\n\t\t}\n\t\tif(find(pos.size())*n <= size*8) {\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint res = Integer.MAX_VALUE;\n\t\tint ptr = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(i-1 >= 0 && a[i-1] == a[i]) continue;\n\t\t\tint before = 0;\n\t\t\tint lft = i;\n\t\t\tif(i-1 >= 0) before += pref[i-1];\n\t\t\tint lo = ptr, hi = pos.size()-1;\n\t\t\t\n\t\t\tfor(int bs = 0; bs < 50 && lo <= hi; bs++) {\n\t\t\t\tint mid = (lo+hi)/2;\n\t\t\t\tint j = pos.get(mid);\n\t\t\t\tint rgt = n-j;\n\t\t\t\tint dist = j-1 >= 0 ? pref[j-1] : 0;\n\t\t\t\tdist -= before;\n\t\t\t\tint need = find(dist);\n\t\t\t\tlong req = (long)need*n;\n\t\t\t\tif(req <= size*8) {\n\t\t\t\t\tres = Math.min(res, rgt+lft);\n\t\t\t\t\tlo = mid+1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\thi = mid-1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tptr++;\n\t\t}\n\t\tout.println(res);\n\t\t\n\t\tout.close();\n\t}\n\t\n\tint find(int k) {\n\t\tif(get[k] != -1) return get[k];\n\t\tint r = 0;\n\t\twhile(k > (1<<r)) r++;\n\t\treturn r;\n\t}\n\t\n\tvoid sort(int[] a) {\n\t\tRandom rand = new Random();\n\t\tint n = a.length;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint x = rand.nextInt(n);\n\t\t\tint y = rand.nextInt(n);\n\t\t\tint t = a[x]; a[x] = a[y]; a[y] = t;\n\t\t}\n\t\tArrays.sort(a);\n\t}\n\n\tclass FastScanner {\n\t\tpublic int BS = 1<<16;\n\t\tpublic char NC = (char)0;\n\t\tbyte[] buf = new byte[BS];\n\t\tint bId = 0, size = 0;\n\t\tchar c = NC;\n\t\tdouble num = 1;\n\t\tBufferedInputStream in;\n\n\t\tpublic FastScanner() {\n\t\t\tin = new BufferedInputStream(System.in, BS);\n\t\t}\n\n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tin = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tin = new BufferedInputStream(System.in, BS);\n\t\t\t}\n\t\t}\n\n\t\tpublic char nextChar(){\n\t\t\twhile(bId==size) {\n\t\t\t\ttry {\n\t\t\t\t\tsize = in.read(buf);\n\t\t\t\t}catch(Exception e) {\n\t\t\t\t\treturn NC;\n\t\t\t\t}                \n\t\t\t\tif(size==-1)return NC;\n\t\t\t\tbId=0;\n\t\t\t}\n\t\t\treturn (char)buf[bId++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tnum=1;\n\t\t\tboolean neg = false;\n\t\t\tif(c==NC)c=nextChar();\n\t\t\tfor(;(c<'0' || c>'9'); c = nextChar()) {\n\t\t\t\tif(c=='-')neg=true;\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tfor(; c>='0' && c <='9'; c=nextChar()) {\n\t\t\t\tres = (res<<3)+(res<<1)+c-'0';\n\t\t\t\tnum*=10;\n\t\t\t}\n\t\t\treturn neg?-res:res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\tdouble cur = nextLong();\n\t\t\treturn c!='.' ? cur:cur+nextLong()/num;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile(c<=32)c=nextChar();\n\t\t\twhile(c>32) {\n\t\t\t\tres.append(c);\n\t\t\t\tc=nextChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile(c<=32)c=nextChar();\n\t\t\twhile(c!='\\n') {\n\t\t\t\tres.append(c);\n\t\t\t\tc=nextChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tif(c>32)return true;\n\t\t\twhile(true) {\n\t\t\t\tc=nextChar();\n\t\t\t\tif(c==NC)return false;\n\t\t\t\telse if(c>32)return true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor(int i = 0; i < n; i++) res[i] = nextInt();\n\t\t\treturn res;\n\t\t}\n\t\t\n\t}\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Test {\n\n    static int readInt() {\n        int ans = 0;\n        boolean neg = false;\n        try {\n            boolean start = false;\n            for (int c = 0; (c = System.in.read()) != -1; ) {\n                if (c == '-') {\n                    start = true;\n                    neg = true;\n                    continue;\n                } else if (c >= '0' && c <= '9') {\n                    start = true;\n                    ans = ans * 10 + c - '0';\n                } else if (start) break;\n            }\n        } catch (IOException e) {\n        }\n        return neg ? -ans : ans;\n    }\n\n    static long readLong() {\n        long ans = 0;\n        boolean neg = false;\n        try {\n            boolean start = false;\n            for (int c = 0; (c = System.in.read()) != -1; ) {\n                if (c == '-') {\n                    start = true;\n                    neg = true;\n                    continue;\n                } else if (c >= '0' && c <= '9') {\n                    start = true;\n                    ans = ans * 10 + c - '0';\n                } else if (start) break;\n            }\n        } catch (IOException e) {\n        }\n        return neg ? -ans : ans;\n    }\n\n    static String readLine() {\n        StringBuilder b = new StringBuilder();\n        try {\n            boolean start = false;\n            for (int c = 0; (c = System.in.read()) != -1; ) {\n                if (c != '\\r' && c != '\\n') {\n                    start = true;\n                    b.append((char)c);\n                } else if (start) break;\n            }\n        } catch (IOException e) {\n        }\n        return b.toString();\n    }\n\n    static PrintWriter writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n    void start() {\n        int n = readInt(), I = readInt();\n        int bits = 8*I;\n        int k = bits / n;\n        int values = k < 30 ? 1 << k : n;\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = readInt();\n        Random random = new Random(5734153453315151L + System.currentTimeMillis());\n        for (int i = 0; i < n; ++i) {\n            int j = random.nextInt(i + 1);\n            int t = a[i];\n            a[i] = a[j];\n            a[j] = t;\n        }\n        Arrays.sort(a);\n\n        int r = 0, diff = 0, best = 0;\n        for (int i = 0; i < n; i++) {\n            while (r < n) {\n                if (r > i && a[r] == a[r-1]) r++;\n                else {\n                    if (diff == values) break;\n                    r++;\n                    diff++;\n                }\n            }\n            if (r - i > best) best = r - i;\n            if (i + 1 < n && (i + 1 == r || a[i] != a[i+1])) diff--;\n        }\n        writer.println(n - best);\n    }\n\n    public static void main(String[] args) {\n        Test te = new Test();\n        te.start();\n        writer.flush();\n    }\n}"
        },
        {
            "language": 3,
            "solution": "def solve():\n    n,i = map(int, input().split())\n    ns = sorted([*map(int, input().split())])\n    k = 1<<(i*8//n)\n    lis = []\n    for i in range(n-1):\n        if ns[i]!=ns[i+1]: lis.append(i+1)\n    lis.append(n)\n    print(0 if len(lis) <= k else\n          n-max(lis[i+k]-lis[i] for i in range(len(lis)-k)))\n \nsolve()\n"
        },
        {
            "language": 1,
            "solution": "from sys import*\ninput = stdin.readline\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\nb.sort()\nm = 2**((a[1]*8)//len(b))\ng=[0]\nfor i in range(1, a[0]):\n    if b[i-1] != b[i]:\n        g.append(i)\nif(len(g)<=m):\n    print(0)\nelse:\n    print(a[0]-max(g[i+m]-g[i] for i in range(len(g)-m)))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid __print(int x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(long long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const char *x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const string &x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x) {\n  cerr << '{';\n  __print(x.first);\n  cerr << ',';\n  __print(x.second);\n  cerr << '}';\n}\ntemplate <typename T>\nvoid __print(const T &x) {\n  int f = 0;\n  cerr << '{';\n  for (auto &i : x) cerr << (f++ ? \",\" : \"\"), __print(i);\n  cerr << \"}\";\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n  __print(t);\n  if (sizeof...(v)) cerr << \", \";\n  _print(v...);\n}\nint main() {\n  int n, k;\n  cin >> n >> k;\n  vector<int> a(n);\n  for (auto &x : a) cin >> x;\n  k = (k * 8) / n;\n  int dis = pow(2, k);\n  sort(a.begin(), a.end());\n  vector<int> pref(n + 1, -1);\n  pref[0] = 0;\n  for (int i = 1; i < n; i++) {\n    if (a[i - 1] == a[i])\n      pref[i] = pref[i - 1];\n    else\n      pref[i] = pref[i - 1] + 1;\n  }\n  vector<int> cnt;\n  for (int i = 0; i < n; i++) {\n    if (pref[i] != pref[i + 1]) cnt.push_back(i);\n  };\n  ;\n  ;\n  if (dis >= cnt.size()) {\n    cout << \"0\\n\";\n    return 0;\n  }\n  int ans = n - (cnt[dis - 1] + 1);\n  ;\n  for (int i = 1; i < cnt.size() - dis + 1; i++) {\n    ;\n    ans = min(ans, (n - (cnt[i + dis - 1] - cnt[i - 1])));\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  vector<int> a, distinct;\n  int x, n;\n  int space;\n  cin >> n >> space;\n  for (int i = 0; i < n; ++i) {\n    cin >> x;\n    a.push_back(x);\n  }\n  distinct.resize(n);\n  space *= 8;\n  int reqd = space / n;\n  if (reqd > 30 or n <= (1 << reqd)) {\n    cout << 0 << '\\n';\n    return 0;\n  }\n  int shouldBe = 1 << reqd;\n  sort(a.begin(), a.end());\n  distinct[0] = 1;\n  for (int i = 1; i < n; ++i) {\n    if (a[i] == a[i - 1])\n      distinct[i] = distinct[i - 1];\n    else\n      distinct[i] = distinct[i - 1] + 1;\n  }\n  int mini = -1;\n  for (int i = 0; i < n; ++i) {\n    if (i and a[i] == a[i - 1]) continue;\n    int up = lower_bound(distinct.begin(), distinct.end(),\n                         (i ? distinct[i - 1] : 0) + shouldBe + 1) -\n             distinct.begin();\n    auto current = i + n - up;\n    if (current < mini or mini == -1) mini = current;\n  }\n  cout << mini << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class code {\n\tstatic printer pw;\n\tstatic boolean[] visit;\n\tstatic ArrayList<Pair>[] adj;\n\tstatic ArrayList<Integer> list;\n\tstatic long max=01;\n\tstatic void dfs(int i, long c) {\n\t\tvisit[i]=true;\n\t\tmax=Math.max(c, max);\n\t\tfor(Pair p: adj[i]) {\n\t\t\tif(!visit[p.x-1]) {\n\t\t\t\tdfs(p.x-1, c+1l*p.y);\n\t\t\t}\n\t\t}\n\t}\n\tpublic static double dist(Pair a, Pair b) {\n\t\treturn Math.sqrt((a.x-b.x)*(a.x-b.x)+ (a.y-b.y)*(a.y-b.y));\n\t}\n\tpublic static boolean sign(int x) {\n\t\treturn x>0;\n\t}\n\tstatic long ceildiv(long x,long y) {\n\t\treturn x%y==0? x/y: x/y+1;\n\t}\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc= new Scanner(System.in);\n\t\tpw = new printer();\n\t\tint n=sc.nextInt(),k=(sc.nextInt()*8)/n;\n\t\tint x=k>=30?n:1<<k;\n\t\tint[] arr=sc.nextArr(n);\n\t\tHashSet<Integer> tree=new HashSet<Integer>();\n\t\tHashMap<Integer, Integer> map=new HashMap<Integer, Integer>();\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tif(tree.contains(arr[i])) {\n\t\t\t\tmap.replace(arr[i], map.get(arr[i])+1);\n\t\t\t}else {\n\t\t\t\ttree.add(arr[i]);\n\t\t\t\tmap.put(arr[i],1);\n\t\t\t}\n\t\t}\n\t\tif(x>=tree.size()) {\n\t\t\tpw.println(0);\n\t\t\tpw.close();\n\t\t\treturn;\n\t\t}\n\t\tPair[] ans=new Pair[tree.size()];\n\t\tint j=0;\n\t\tfor(int y: tree) {\n\t\t\tans[j++]=new Pair(y, map.get(y));\n\t\t}\n\t\tArrays.sort(ans);\n\t\tlong sum=0l;\n\t\tfor(int i=0; i<x; i++) {\n\t\t\tsum+=ans[i].y;\n\t\t}\n\t\tlong max=sum;\n\t\tfor(int i=1; i<ans.length-x+1; i++) {\n\t\t\tsum+=ans[i+x-1].y-ans[i-1].y;\n\t\t\tmax=Math.max(sum, max);\n\t\t}\n\t\tpw.println(n-max);\n\t\tpw.close();\n\t}\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n \n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n \n\t\tpublic Scanner(FileReader r) {\n\t\t\tbr = new BufferedReader(r);\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n \n\t\tpublic int[] nextArr(int n) throws IOException {\n\t\t\tint[] arr = new int[n];\n\t\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\t\tarr[i] = nextInt();\n\t\t\treturn arr;\n\t\t}\n\t\tpublic Integer[] nextsort(int n) throws IOException{\n\t\t\tInteger[] arr=new Integer[n];\n\t\t\tfor(int i=0; i<n; i++) \n\t\t\t\tarr[i]=nextInt();\n\t\t\treturn arr;\n\t\t}\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\t}\n\tstatic class printer{\n\t\tPrintWriter pw;\n\t\tpublic printer() {\n\t\t\tpw=new PrintWriter(System.out);\n\t\t}\n\t\tpublic void print(String s) throws IOException{\n\t\t\tpw.print(s);\n\t\t}\n\t\tpublic void print(int s) throws IOException{\n\t\t\tpw.print(s);\n\t\t}\n\t\tpublic void print(long s) throws IOException{\n\t\t\tpw.print(s);\n\t\t}\n\t\tpublic void print(char s) throws IOException{\n\t\t\tpw.print(s);\n\t\t}\n\t\tpublic void print(Integer s) throws IOException{\n\t\t\tpw.print(s);\n\t\t}\n\t\tpublic void print(Long s) throws IOException{\n\t\t\tpw.print(s);\n\t\t}\n\t\tpublic void print(Character s) throws IOException{\n\t\t\tpw.print(s);\n\t\t}\n\t\tpublic void println(String s) throws IOException{\n\t\t\tpw.println(s);\n\t\t}\n\t\tpublic void println(int s) throws IOException{\n\t\t\tpw.println(s);\n\t\t}\n\t\tpublic void println(long s) throws IOException{\n\t\t\tpw.println(s);\n\t\t}\n\t\tpublic void println(char s) throws IOException{\n\t\t\tpw.println(s);\n\t\t}\n\t\tpublic void println(Integer s) throws IOException{\n\t\t\tpw.println(s);\n\t\t}\n\t\tpublic void println(Long s) throws IOException{\n\t\t\tpw.println(s);\n\t\t}\n\t\tpublic void println(Character s) throws IOException{\n\t\t\tpw.println(s);\n\t\t}\n\t\tpublic void println() throws IOException{\n\t\t\tpw.println();\n\t\t}\n\t\tpublic void println(int[] arr) throws IOException{\n\t\t\tfor(int i=0; i<arr.length-1; i++)\n\t\t\t\tpw.print(arr[i]+\" \");\n\t\t\tpw.println(arr[arr.length-1]);\n\t\t}\n\t\tpublic void println(Integer[] arr) throws IOException{\n\t\t\tfor(int i=0; i<arr.length-1; i++)\n\t\t\t\tpw.print(arr[i]+\" \");\n\t\t\tpw.println(arr[arr.length-1]);\n\t\t}\n\t\tpublic void println(long[] arr) throws IOException{\n\t\t\tfor(int i=0; i<arr.length-1; i++)\n\t\t\t\tpw.print(arr[i]+\" \");\n\t\t\tpw.println(arr[arr.length-1]);\n\t\t}\n\t\tpublic void println(Long[] arr) throws IOException{\n\t\t\tfor(int i=0; i<arr.length-1; i++)\n\t\t\t\tpw.print(arr[i]+\" \");\n\t\t\tpw.println(arr[arr.length-1]);\n\t\t}\n\t\tpublic void println(char[] arr) throws IOException{\n\t\t\tfor(int i=0; i<arr.length-1; i++)\n\t\t\t\tpw.print(arr[i]+\" \");\n\t\t\tpw.println(arr[arr.length-1]);\n\t\t}\n\t\tpublic void println(Character[] arr) throws IOException{\n\t\t\tfor(int i=0; i<arr.length-1; i++)\n\t\t\t\tpw.print(arr[i]+\" \");\n\t\t\tpw.println(arr[arr.length-1]);\n\t\t}\n\t\tpublic void println(ArrayList<Integer> arr) throws IOException{\n\t\t\tfor(int i=0; i<arr.size()-1; i++)\n\t\t\t\tpw.print(arr.get(i)+\" \");\n\t\t\tpw.println(arr.get(arr.size()-1));\n\t\t}\n\t\tpublic void println(TreeSet<Integer> arr) throws IOException{\n\t\t\tfor(int x: arr) {\n\t\t\t\tpw.print(x+\" \");\n\t\t\t}\n\t\t}\n\t\tpublic void close() throws IOException{\n\t\t\tpw.close();\n\t\t}\n\t\tpublic void flush() throws IOException{\n\t\t\tpw.flush();\n\t\t}\n\t}\n\tstatic class Pair implements Comparable<Pair>{\n\t\tint x;\n\t\tint y;\n\t\tpublic Pair(int a, int b) {\n\t\t\tthis.x=a;\n\t\t\tthis.y=b;\n\t\t}\n\t\tpublic int compareTo(Pair other) {\n\t\t\treturn this.x-other.x;\n\t\t}\n\t}\n\tstatic class Triple implements Comparable<Triple>{\n\t\tint x;\n\t\tint y;\n\t\tboolean d;\n\t\tpublic Triple(int a, int b, boolean t) {\n\t\t\tthis.x=a;\n\t\t\tthis.y=b;\n\t\t\tthis.d=t;\n\t\t}\n\t\tpublic int compareTo(Triple other) {\n\t\t\tif(this.d && !other.d) {\n\t\t\t\treturn 1;\n\t\t\t}else if(!this.d && other.d) {\n\t\t\t\treturn -1;\n\t\t\t}else {\n\t\t\t\treturn this.y-other.y;\n\t\t\t}\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n;\nlong long a[400001];\nlong long I;\nlong long k;\nlong long cur = 0;\nmap<long long, long long> cnt;\ndeque<long long> CurrList;\nlong long res = 1e18;\nint32_t main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> I;\n  I = 8 * I;\n  k = I / n;\n  k = min(30LL, k);\n  long long K = min(n, 1LL << k);\n  for (long long i = 1; i <= n; i++) cin >> a[i];\n  sort(a + 1, a + 1 + n);\n  long long l = 1;\n  for (long long i = 1; i <= n; i++) {\n    cnt[a[i]]++;\n    if (cnt[a[i]] == 1) cur++;\n    while (cur > K) {\n      cnt[a[l]]--;\n      if (cnt[a[l]] == 0) cur--;\n      l++;\n    }\n    if (l <= i) res = min(res, l - 1 + n - i);\n  }\n  cout << res;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1e9;\nconst long long INFF = 1e18;\nconst long long MAXN = 510;\nconst long long MOD = 1e9 + 7;\nconst double PI = acos(-1.0);\nconst double INFD = 1E9;\nconst double EPS = 1e-9;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nlong long getTC() {\n  if (0) {\n    long long t;\n    cin >> t;\n    return t;\n  } else\n    return 1;\n}\nvoid solve() {\n  long long n, k;\n  cin >> n >> k;\n  k *= 8;\n  vector<long long> nums;\n  map<long long, long long> frek;\n  for (long long i = 0; i < n; i++) {\n    long long ta;\n    cin >> ta;\n    frek[ta]++;\n    nums.push_back(ta);\n  }\n  sort(nums.begin(), nums.end());\n  nums.erase(unique(nums.begin(), nums.end()), nums.end());\n  vector<long long> pref;\n  pref.push_back(frek[nums[0]]);\n  for (long long i = 1; i < nums.size(); i++) {\n    pref.push_back(pref.back() + frek[nums[i]]);\n  }\n  const auto get = [&](long long l, long long r) -> long long {\n    return (l == 0 ? pref[r] : pref[r] - pref[l - 1]);\n  };\n  long long ans = INF;\n  for (long long i = 0; (1 << i) <= nums.size() * 2; i++) {\n    long long len = min((1ll << i), (long long)nums.size());\n    if (n * i > k) break;\n    for (long long j = 0; j + len - 1 < nums.size(); j++) {\n      long long l = j;\n      long long r = j + len - 1;\n      long long sum = get(l, r);\n      long long ubah = n - sum;\n      ans = min(ans, ubah);\n    }\n  }\n  cout << ans << endl;\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long t = getTC();\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long> cnt;\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  ;\n  long long n, I;\n  cin >> n >> I;\n  long long a[n + 2];\n  for (long long i = 1; i <= n; i++) {\n    cin >> a[i];\n  }\n  I = 8 * I;\n  long long k = I / n, j = 0, ans = 0;\n  if (k > 30) {\n    cout << \"0\";\n    return 0;\n  }\n  long long K = (1 << k);\n  sort(a + 1, a + n + 1);\n  cnt.push_back(0);\n  a[n + 1] = 69990969696;\n  for (long long i = 1; i <= n; i++) {\n    if (a[i] != a[i + 1]) {\n      cnt.push_back(i);\n    }\n  }\n  if (cnt.size() - 1 < K) {\n    cout << \"0\";\n    return 0;\n  } else\n    for (long long i = K; i <= cnt.size() - 1; i++) {\n      ans = max(ans, cnt[i] - cnt[i - K]);\n    }\n  cout << n - ans;\n}\n"
        },
        {
            "language": 1,
            "solution": "n,I=map(int,raw_input().split())\nl=map(int,raw_input().split())\nd ={}\nfor j in l:\n    d[j]=d.get(j,0)+1\ny=list(set(l))\ny.sort()\np=len(y)\nk=2**((I*8)/n)\nif k>=p:\n    print(0)\n    exit()\ncount=0\n#print x,p,k\n\nfor i in range(k):\n    count+=d[y[i]]\nhigh=count\nfor i in range(k,p):\n    high=high+d[y[i]]-d[y[i-k]]\n    count=max(count,high)\nprint n-count"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\n \npublic class Main {\n \n    public static void main(String[] args) {\n\t    // write your code here\n        Scanner scan = new Scanner(System.in);\n        int n = scan.nextInt();\n        int I = scan.nextInt();\n        int k = 8 * I / n;\n        int K = (int)Math.pow(2.0, k);\n \n        int[] arr = new int[n];\n        for(int i = 0; i < n; i++) arr[i] = scan.nextInt();\n        Arrays.sort(arr);\n \n        List<Integer> list = new ArrayList<>();\n        int cnt = 0;\n        for(int i = 0; i < n; i++) {\n            if(i > 0 && arr[i] > arr[i - 1]) {\n                list.add(cnt);\n                cnt = 1;\n            } else {\n                cnt++;\n            }\n        }\n        list.add(cnt);\n \n        if(list.size() <= K) System.out.println(0);\n        else {\n           // System.out.println(K);\n           // list.forEach(System.out::println);\n            int ans = 0;\n            int diff = list.size() - K;\n            for(int i = 0; i < diff; i++) ans += list.get(i);\n            int all = ans;\n            for(int i = 1; i <= diff; i++) {\n                all = all + list.get(list.size() - i) - list.get(diff - i);\n                if(all < ans) ans = all;\n            }\n            System.out.println(ans);\n        }\n \n    }\n}"
        },
        {
            "language": 3,
            "solution": "import sys\nimport math as mt\ninput=sys.stdin.buffer.readline  \nt=1\n#t=int(input())\nfor _ in range(t):\n    #n=int(input())\n    n,I=map(int,input().split())\n    l=list(map(int,input().split()))\n    x=(I*8)//n\n    x=2**x\n    d={}\n    l.sort()\n    for i in l:\n        d[i]=d.get(i,0)+1\n\n    if len(d)>x:\n        pref=[]\n        pref.append(0)\n        pref.append(d[l[0]])\n        for i in range(1,n):\n            if l[i]!=l[i-1]:\n                pref.append(pref[-1]+d[l[i]])\n        #print(pref,pref[-1])\n        mini=pref[-1]\n        for i in range(x,len(pref)):\n            if mini>(pref[-1]-(pref[i]-pref[i-x])):\n                #print(111,i,(pref[-1]-(pref[i]-pref[i-x])))\n                mini=(pref[-1]-(pref[i]-pref[i-x]))\n        print(mini)        \n            \n    else:\n        print(0)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, I;\n  cin >> n >> I;\n  int distinct_vals = (8 * I) / n;\n  distinct_vals = pow(2, distinct_vals);\n  map<int, int> freq_map;\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    if (freq_map.find(x) == freq_map.end()) {\n      freq_map[x] = 1;\n    } else {\n      freq_map[x]++;\n    }\n  }\n  if (distinct_vals >= freq_map.size()) {\n    cout << 0 << endl;\n    return 0;\n  }\n  vector<int> assist(freq_map.size());\n  int i = 0;\n  for (auto e : freq_map) {\n    assist[i] = e.second;\n    i++;\n  }\n  int tbd = freq_map.size() - distinct_vals;\n  int ans = 0;\n  for (int j = 0; j < tbd; j++) {\n    ans += assist[freq_map.size() - 1 - j];\n  }\n  int finans = ans;\n  for (int j = 0; j < tbd; j++) {\n    ans += assist[j];\n    ans -= assist[freq_map.size() - tbd + j];\n    finans = min(ans, finans);\n  }\n  cout << finans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long arr[400009];\nvoid solve() {\n  int n, I;\n  cin >> n >> I;\n  vector<int> elems;\n  unordered_map<int, int> umap;\n  for (int i = 1; i <= n; i++) {\n    int x;\n    cin >> x;\n    if (umap[x] == 0) elems.push_back(x);\n    umap[x]++;\n  }\n  long long ans = 0;\n  for (int i = 0; i <= (int)elems.size() - 1; i++) ans += umap[elems[i]];\n  if ((long long)n * (long long)ceil(log2((int)elems.size())) <=\n      (long long)I * 8) {\n    cout << 0;\n    return;\n  }\n  int savNum = pow(2, min(20, (I * 8) / n));\n  sort(elems.begin(), elems.end());\n  int res = 0;\n  arr[0] = umap[elems[0]];\n  for (int i = 1; i <= (int)elems.size() - 1; i++) {\n    arr[i] = arr[i - 1] + umap[elems[i]];\n  }\n  for (int i = 0; i <= (int)elems.size() - savNum; i++) {\n    res = max((long long)res, arr[i + savNum - 1] - arr[i] + umap[elems[i]]);\n  }\n  cout << ans - res;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  ;\n  int t;\n  t = 1;\n  for (int i = 1; i <= t; i++) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 400040, mod = 998244353;\ninline int read() {\n  int x = 0, f = 0;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') f |= ch == '-', ch = getchar();\n  while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();\n  return f ? -x : x;\n}\nint n, I, pr = 1, a[maxn], ans = 1e9, pre[maxn];\nint main() {\n  n = read();\n  I = read();\n  for (int i = (1); i <= (n); i++) a[i] = read();\n  sort(a + 1, a + n + 1);\n  I = I * 8 / n;\n  while (I && pr <= n) I--, pr *= 2;\n  pr = min(pr, n);\n  pre[1] = 1;\n  for (int i = (2); i <= (n); i++) pre[i] = pre[i - 1] + (a[i] != a[i - 1]);\n  for (int i = (1); i <= (n); i++) {\n    int x = lower_bound(pre + 1, pre + n + 1, pre[i] + pr) - pre - 1;\n    ans = min(ans, i - 1 + n - x);\n  }\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\nn , m = map(int,input().split())\nlis=sorted(map(int,input().split()))\nfreq=[]\nlast=-1\nfor i in range(n):\n    if lis[i]!=last:\n        freq.append(1)\n        last=lis[i]\n    else:\n        freq[-1]+=1\nk = len(freq)\nfor i in range(k,0,-1):\n    if n * math.ceil(math.log2(i)) <= m * 8:\n        k=i\n        break\nmx=sum(freq[:k])\ntem=mx\nfor i in range(k,len(freq)):\n    tem = tem + freq[i] - freq[i-k]\n    mx=max(mx,tem)\nprint(n-mx)    \n        "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1.1e5;\nconst int MOD = (int)(1e9) + 7;\nint main() {\n  int n, I;\n  cin >> n >> I;\n  int need = 8 * I / n;\n  if (8 * I / n >= 30) {\n    cout << 0 << '\\n';\n    exit(0);\n  }\n  int desire = 1LL << (8 * I / n);\n  vector<int> A(n);\n  for (int i = 0; i < n; i++) cin >> A[i];\n  sort(A.begin(), A.end());\n  A.push_back((int)(1e9));\n  int L = 0;\n  int R = 0;\n  set<int> have{A[0]};\n  multiset<int> gu{A[0]};\n  int ans = n;\n  while (R < n) {\n    if (have.size() <= desire) {\n      ans = min(ans, n - R - 1 + L);\n      int add = A[++R];\n      gu.insert(add);\n      have.insert(add);\n    } else {\n      int rem = A[L++];\n      gu.erase(gu.find(rem));\n      if (!gu.count(rem)) have.erase(rem);\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.TreeSet;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author KharYusuf\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CMP3 solver = new CMP3();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CMP3 {\n        public void solve(int testNumber, FastReader s, PrintWriter w) {\n            int n = s.nextInt(), I = s.nextInt() * 8, pos = 1;\n            int[] a = new int[n], f = new int[400005];\n            HashMap<Integer, Integer> h = new HashMap<>();\n            TreeSet<Integer> t = new TreeSet<>();\n            for (int i = 0; i < n; i++) {\n                a[i] = s.nextInt();\n                if (!h.containsKey(a[i])) h.put(a[i], 1);\n                else h.replace(a[i], h.get(a[i]) + 1);\n                t.add(a[i]);\n            }\n            for (int i : t) {\n                f[pos++] = h.get(i);\n            }\n            for (int i = 1; i < 400005; i++) {\n                f[i] += f[i - 1];\n            }\n            for (int i = pos; i >= 1; i--) {\n                int j;\n                for (j = 0; j < 21; j++) {\n                    if ((1 << j) >= i) {\n                        break;\n                    }\n                }\n                if (j * n <= I) {\n                    int max = 0;\n                    //w.println(i);\n                    for (int k = i; k <= pos; k++) {\n                        max = Math.max(max, f[k] - f[k - i]);\n                    }\n                    w.println(f[pos] - max);\n                    return;\n                }\n            }\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private FastReader.SpaceCharFilter filter;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n\n            if (numChars == -1)\n                throw new InputMismatchException();\n\n            if (curChar >= numChars) {\n\n                curChar = 0;\n\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n\n                if (numChars <= 0)\n                    return -1;\n            }\n\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n\n            int c = read();\n\n            while (isSpaceChar(c))\n                c = read();\n\n            int sgn = 1;\n\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n\n            int res = 0;\n\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n\n            if (filter != null)\n                return filter.isSpaceChar(c);\n\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin\ninput=stdin.readline\nn,I=map(int,input().split())\na=sorted(list(map(int,input().split())))\nkey=[]\nk=min(I*8//n,20)\nK=min(2**k,n)\nlast=-1\nfor i in range(n):\n    if a[i]==last:\n        key[-1]+=1\n    else:\n        key.append(1)\n        last=a[i]\nnow=best=0\nfor i in range(len(key)):\n    if i<K:\n        now+=key[i]\n    else:\n        now+=key[i]\n        now-=key[i-K]\n    best=max(now,best)\nprint(n-best)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 4e5 + 5;\nint n, I;\nint a[MAXN], num[MAXN];\nint read() {\n  int s = 1, x = 0;\n  char ch = getchar();\n  while (!isdigit(ch)) {\n    if (ch == '-') s = -1;\n    ch = getchar();\n  }\n  while (isdigit(ch)) {\n    x = 10 * x + ch - '0';\n    ch = getchar();\n  }\n  return x * s;\n}\nint main() {\n  n = read(), I = read();\n  int maxk = 8 * I / n, maxK = pow(2, maxk);\n  if (maxk >= 20) {\n    cout << \"0\\n\";\n    return 0;\n  }\n  for (int i = 1; i <= n; ++i) a[i] = read();\n  sort(a + 1, a + n + 1);\n  int cnt = 1;\n  num[cnt] = 1;\n  for (int i = 2; i <= n; ++i) {\n    if (a[i] == a[i - 1])\n      num[cnt]++;\n    else\n      num[++cnt] = num[cnt - 1] + 1;\n  }\n  if (cnt <= maxK) {\n    cout << \"0\\n\";\n    return 0;\n  }\n  int max_con = -1;\n  for (int i = maxK; i <= cnt; ++i) {\n    int tmp = num[i] - num[i - maxK];\n    max_con = max(max_con, tmp);\n  }\n  cout << n - max_con << endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\n# def pow2(exp)\n#     if exp >= 21:\n#         return 1000000\n#     ans = 1\n#     for i in range(1,exp+1):\n#         ans *= 2\n#     return ans\n\n\nn,I=map(int,input().split())\na=list(map(int,input().split()))\na.sort()\nI*=8\nk=1<<(I//n)\n\ndp=[1]\nfor i in range(1,n):\n    if a[i]==a[i-1]:\n        dp[-1]+=1\n    else:\n        dp.append(1)\n        \nif k>=len(dp):\n    print(0)\nelse:\n    \n    ans=sum(dp[:k])\n    ret=ans\n    for i in range(k,len(dp)):\n        ans+=dp[i]-dp[i-k]\n        \n        ret=max(ret,ans)\n    print(n-ret)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1e9 + 7;\nint n, m, i, j, x, ans;\nstring st;\nvector<pair<int, int> > v, v2;\nint f(int x) {\n  int s = 1;\n  x = min(x, 50);\n  while (x--) {\n    s = min(inf, s * 2);\n  }\n  return s;\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  m = f(m * 8 / n);\n  for ((i) = 1; (i) <= (n); (i)++) {\n    int x;\n    scanf(\"%d\", &x);\n    v.push_back(make_pair(x, 1));\n  }\n  sort(v.begin(), v.end());\n  for (__typeof((v).begin()) it = (v).begin(); it != (v).end(); it++) {\n    if (v2.empty() || v2.back().first != it->first) {\n      v2.push_back(*it);\n    } else {\n      v2.back().second++;\n    }\n  }\n  int s = 0;\n  v = v2;\n  j = 0;\n  int sum = 0;\n  for ((i) = 0; (i) < (v.size()); (i)++) {\n    while (j < v.size() && j < i + m) {\n      sum += v[j++].second;\n    }\n    ans = max(ans, sum);\n    sum -= v[i].second;\n  }\n  cout << n - ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  double N, I;\n  cin >> N >> I;\n  int n = (int)N;\n  int a[n + 1];\n  int ubound = pow(2, (int)(8 * I / N));\n  vector<vector<int> > dp(n + 1, vector<int>(3, 0));\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n  }\n  sort(a, a + n);\n  dp[0][1] = 1;\n  vector<int> dif;\n  dif.push_back(a[0]);\n  for (int i = 1; i < n; ++i) {\n    if (a[i] == a[i - 1]) {\n      dp[i][1] = dp[i - 1][1] + 1;\n      dp[i][0] = dp[i - 1][0];\n    } else {\n      dif.push_back(a[i]);\n      dp[i][0] = dp[i - 1][0] + dp[i - 1][1];\n      dp[i][1] = 1;\n    }\n  }\n  for (int i = n - 2; i >= 0; --i) {\n    if (a[i] == a[i + 1]) {\n      dp[i][1] = dp[i + 1][1];\n      dp[i][2] = dp[i + 1][2];\n    } else {\n      dp[i][2] = dp[i + 1][2] + dp[i + 1][1];\n    }\n  }\n  vector<vector<int> > res;\n  res.push_back(dp[0]);\n  for (int i = 1; i < n; ++i) {\n    if (a[i] != a[i - 1]) res.push_back(dp[i]);\n  }\n  int mn = n;\n  int prev = -1;\n  for (int i = 0; i < res.size(); ++i) {\n    int pos = min(i + ubound - 1, (int)dif.size() - 1);\n    if (pos == prev) break;\n    prev = pos;\n    int temp = res[pos][2] + res[i][0];\n    if (temp < mn) mn = temp;\n  }\n  cout << mn;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "R=lambda:map(int,input().split())\nn,I=R()\na=[-1]+sorted(R())\nb=[i for i in range(n)if a[i]<a[i+1]]\nprint(n-max(y-x for x,y in zip(b,b[1<<8*I//n:]+[n])))"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/env python3\n# http://codeforces.com/contest/1199/problem/C\nimport collections\n\nn,I = list(map(int,input().split()))\nL = sorted(map(int,input().split()))\n\nbits_per_elem = (I*8)//n\nK = (2**min(bits_per_elem,32))\n\nfreq = list(collections.Counter(L).values())\nif K>=len(freq):\n    print(0)\n    exit()\n\nfor i in range(1,len(freq)):\n    freq[i] += freq[i-1]\n\nres = n\nfor i in range(len(freq)-K):\n    res = min(res, freq[i]+freq[-1]-freq[i+K])\n\nprint(res)"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict,Counter\nfrom math import floor\nn,I = map(int,input().split())\nList = [int(x) for x in input().split()]\n# if(n == 1 and I == 1 and List[0] == 1):\n#     print(0)\n#     exit()\n    \nk = pow(2, min(20,floor((I*8)/n))) # k is the distinct value that is allowed\n\nList.sort()\narr = [[List[0],1]]\nfor i in range(1,n):\n    if(List[i] == arr[-1][0]):\n        arr[-1][1] += 1\n    else:\n        arr.append([List[i],1])\n\narr.sort()\n\nprefix = [0]\nfor i in arr:\n    prefix.append(prefix[-1] + i[1])\n\nMax = 0\nif(k>=len(prefix)):\n    print(0)\n    exit()\nfor i in range(k,len(prefix)):\n    Max = max(prefix[i] - prefix[i-k], Max)\nprint(n-Max)"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.awt.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        FastReader sc = new FastReader();\n        StringBuilder sb=new StringBuilder();\n        int n=sc.nextInt(),I=8*sc.nextInt();\n        int[] arr=new int[n];\n        HashMap<Integer,Integer> hm=new HashMap<>();\n        for(int i=0;i<n;i++){\n            arr[i]=sc.nextInt();\n            hm.put(arr[i],hm.getOrDefault(arr[i],0)+1);\n        }\n        int k=I/n;\n        int K=(int)Math.pow(2,k);\n        if(hm.size()<=K) System.out.println(0);\n        else{\n            Node[] node=new Node[hm.size()];\n            int i=0;\n            for(int j:hm.keySet()){\n                node[i++]=new Node(j,hm.get(j));\n            }\n            Arrays.sort(node, new Comparator<Node>() {\n                @Override\n                public int compare(Node o1, Node o2) {\n                    return o1.val-o2.val;\n                }\n            });\n            for(i=1;i<node.length;i++)node[i].count+=node[i-1].count;\n            int l=0,r=K-1,size=node.length;\n            int min=node[size-1].count-node[r].count;\n            l++;r++;\n            while(r<node.length){\n                min=Math.min(min,(node[size-1].count-node[r].count)+node[l-1].count);\n                l++;r++;\n            }\n            System.out.println(min);\n        }\n    }\n}\nclass Node{\n    int val,count;\n    public Node(int val,int count){\n        this.val=val;\n        this.count=count;\n    }\n}\nclass FastReader {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastReader() { br = new BufferedReader(new InputStreamReader(System.in)); }\n    String next() {\n        while (st == null || !st.hasMoreElements()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n    int nextInt() { return Integer.parseInt(next()); }\n    long nextLong() { return Long.parseLong(next()); }\n    double nextDouble() { return Double.parseDouble(next()); }\n    String nextLine() {\n        String str = \"\";\n        try {\n            str = br.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return str;\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 10000;\nconst long double pi = acos(-1.0);\nint n, m, a[400100], tot = 0, x[400100], tax[400100], b[400100];\nint read() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while ((ch < '0') || (ch > '9')) {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while ((ch >= '0') && (ch <= '9')) {\n    x = x * 10 + (ch - '0');\n    ch = getchar();\n  }\n  return x * f;\n}\nint main() {\n  n = read();\n  m = read() * 8;\n  m /= n;\n  if (m > 20) {\n    puts(\"0\");\n    return 0;\n  }\n  int lim = (1 << m);\n  for (register int i = 1; i <= n; i++) x[i] = a[i] = read();\n  sort(x + 1, x + 1 + n);\n  int siz = unique(x + 1, x + 1 + n) - x - 1;\n  for (register int i = 1; i <= n; i++) {\n    a[i] = lower_bound(x + 1, x + 1 + siz, a[i]) - x;\n    tax[a[i]]++;\n  }\n  for (register int i = 1; i <= siz; i++)\n    if (tax[i]) b[++tot] = tax[i];\n  for (register int i = 1; i <= tot; i++) b[i] += b[i - 1];\n  int ans = 0, r = 1;\n  if (lim >= tot) {\n    puts(\"0\");\n    return 0;\n  }\n  for (int l = 1; l + lim - 1 <= tot; l++) {\n    int r = l + lim - 1;\n    ans = max(ans, b[r] - b[l - 1]);\n  }\n  printf(\"%d\", n - ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\nint read() {\n  int v = 0, f = 1;\n  char c = getchar();\n  while (c < 48 || 57 < c) {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (48 <= c && c <= 57) v = (v << 3) + v + v + c - 48, c = getchar();\n  return v * f;\n}\nlong long readll() {\n  long long v = 0, f = 1;\n  char c = getchar();\n  while (c < 48 || 57 < c) {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (48 <= c && c <= 57) v = (v << 3) + v + v + c - 48, c = getchar();\n  return v * f;\n}\nmap<int, int> mp;\npair<int, int> a[444444];\nint n, I;\nvoid predo() {}\nvoid init() {\n  n = read(), I = read();\n  mp.clear();\n  for (int i = (int)1; i <= (int)n; i++) {\n    int x = read();\n    mp[x]++;\n  }\n}\nvoid solve() {\n  int m = 0;\n  for (auto t : mp) a[++m] = t;\n  sort(a + 1, a + m + 1);\n  long long k = 8ll * I / n;\n  int K = 1;\n  for (int i = (int)1; i <= (int)k; i++) {\n    K = K * 2;\n    if (K > m) {\n      K = m;\n      break;\n    }\n  }\n  int s = 0;\n  for (int i = (int)1; i <= (int)K; i++) s += a[i].second;\n  int ans = s;\n  for (int i = (int)2; i <= (int)m - K + 1; i++) {\n    s -= a[i - 1].second;\n    s += a[i + K - 1].second;\n    ans = max(ans, s);\n  }\n  int tot = 0;\n  for (int i = (int)1; i <= (int)m; i++) tot += a[i].second;\n  printf(\"%d\\n\", tot - ans);\n}\nint main() {\n  predo();\n  int cas = 1;\n  while (cas--) {\n    init();\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int N, I;\n  scanf(\"%d %d\", &N, &I);\n  int bits = I * 8 / N;\n  int max_distinct = bits > 30 ? N + 1 : 1 << bits;\n  vector<int> v(N);\n  for (int i = 0; i < N; ++i) {\n    scanf(\"%d\", &v[i]);\n  }\n  sort(v.begin(), v.end());\n  vector<int> freqs;\n  int count = 0;\n  int prev = -1;\n  for (int i = 0; i < N; ++i) {\n    if (v[i] != prev) {\n      if (count > 0) freqs.push_back(count);\n      prev = v[i];\n      count = 1;\n    } else {\n      count++;\n    }\n  }\n  if (count > 0) {\n    freqs.push_back(count);\n  }\n  vector<int> prefix;\n  for (int i = 0; i < freqs.size(); ++i) {\n    prefix.push_back(freqs[i] + (i == 0 ? 0 : prefix[i - 1]));\n  }\n  int min_delete = N;\n  for (int r = 0; r < prefix.size(); ++r) {\n    int l = r - max_distinct;\n    int n_include = prefix[r] - (l >= 0 ? prefix[l] : 0);\n    int n_remove = N - n_include;\n    min_delete = min(min_delete, n_remove);\n  }\n  printf(\"%d\\n\", min_delete);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n \n \n \npublic class Main {\n\t\n\tstatic InputReader in = new InputReader(System.in);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n \n\t\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tint n = in.nextInt();\n\t\tint I = in.nextInt();\n\t\tint[] a = in.nextIntArray(n);\n\t\tshuffle(a);\n\t\tArrays.sort(a);\n\t\t\n\t\tint[] cnt = new int[n];\n\t\tcnt[0] = 1;\n\t\tfor(int i = 1; i < n; ++i) {\n\t\t\tif(a[i] == a[i-1])\n\t\t\t\tcnt[i] = cnt[i-1];\n\t\t\telse\n\t\t\t\tcnt[i] = cnt[i-1] + 1;\n\t\t}\n\t\tint K = cnt[n-1];\n\t\tint M = K;\n\t\tfor(; M >= 1; --M) {\n\t\t\tint k = bitsNeeded(M);\n\t\t\tint need = k * n;\n\t\t\tif(need <= I * 8)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tint ans = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint j = lower_bound(cnt, n, cnt[i] + M);\n\t\t\tint x = i + n - j;\n\t\t\tans = Math.min(ans, x);\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tout.close();\n\t}\n\t\n\tstatic int bitsNeeded(int K) {\n\t\tint k = 0, kk = 1;\n\t\twhile(kk < K) {\n\t\t\tkk *= 2;\n\t\t\tk++;\n\t\t}\n\t\treturn k;\n\t}\n\t\n\tstatic long lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\t\n\tstatic boolean nextPermutation(int[] a) {\n\t\tfor(int i = a.length - 2; i >= 0; --i) {\n\t\t\tif(a[i] < a[i+1]) {\n\t\t\t\tfor(int j = a.length - 1; ; --j) {\n\t\t\t\t\tif(a[i] < a[j]) {\n\t\t\t\t\t\tint t = a[i];\n\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\tfor(i++, j = a.length - 1; i < j; ++i, --j) {\n\t\t\t\t\t\t\tt = a[i];\n\t\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\n\tstatic void shuffle(int[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tint t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic void shuffle(long[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tlong t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic int lower_bound(int[] a, int n, int k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\tstatic int lower_bound(long[] a, int n, long k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\t\n\tstatic int gcd(int a, int b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\tstatic long gcd(long a, long b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\t\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint first, second;\n \n\t\tpublic Pair(int first, int second) {\n\t\t\tsuper();\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn this.first != o.first ? this.first - o.first : this.second - o.second;\n\t\t}\n \n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + first;\n\t\t\tresult = prime * result + second;\n\t\t\treturn result;\n\t\t}\n \n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPair other = (Pair) obj;\n\t\t\tif (first != other.first)\n\t\t\t\treturn false;\n\t\t\tif (second != other.second)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\t\n}\n \n \n \nclass InputReader {\n \n\tprivate final InputStream stream;\n\tprivate final byte[] buf = new byte[8192];\n\tprivate int curChar, snumChars;\n \n\tpublic InputReader(InputStream st) {\n\t\tthis.stream = st;\n\t}\n \n\tpublic int read() {\n\t\tif (snumChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= snumChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (snumChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n \n\tpublic int nextInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic long nextLong() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tlong res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n \n\tpublic int[] nextIntArray(int n) {\n\t\tint a[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n \n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic String nextLine() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isEndOfLine(c));\n\t\treturn res.toString();\n\t}\n \n\tpublic boolean isSpaceChar(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n \n\tprivate boolean isEndOfLine(int c) {\n\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t}\n \n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid swapp(int &a, int &b);\ndouble fabss(double a);\nint maxx(int a, int b);\nint minn(int a, int b);\nint Del_bit_1(int n);\nint lowbit(int n);\nint abss(int a);\nconst double E = 2.718281828;\nconst double PI = acos(-1.0);\nconst int inf = (1 << 29);\nconst double ESP = 1e-9;\nconst int mod = (int)1e9 + 7;\nconst int N = (int)5e5 + 10;\nint a[N], b[N];\nbool mark[N];\nint cnt[N];\nint s[N], dp[N];\nint n;\nvoid LS() {\n  int m = 0;\n  for (int i = 1; i <= n; ++i) b[++m] = a[i];\n  sort(b + 1, b + 1 + m);\n  m = unique(b + 1, b + 1 + m) - b - 1;\n  for (int i = 1; i <= n; ++i) a[i] = lower_bound(b + 1, b + 1 + m, a[i]) - b;\n  return;\n}\nint main() {\n  int k, temp = 1;\n  scanf(\"%d%d\", &n, &k);\n  k *= 8;\n  k /= n;\n  for (register int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n  LS();\n  int tot = 0;\n  for (register int i = 1; i <= n; ++i) {\n    if (!mark[a[i]]) s[++tot] = a[i], mark[a[i]] = 1;\n    cnt[a[i]]++;\n  }\n  while (k--) {\n    temp *= 2;\n    if (temp >= tot) {\n      printf(\"0\\n\");\n      return 0;\n    }\n  }\n  sort(s + 1, s + 1 + tot);\n  for (register int i = 1; i <= tot; ++i) dp[i] = dp[i - 1] + cnt[s[i]];\n  int ans = inf;\n  for (int i = 1; i + temp - 1 <= tot; ++i) {\n    ans = minn(dp[i - 1] + dp[tot] - dp[i + temp - 1], ans);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\nint maxx(int a, int b) { return a > b ? a : b; }\nvoid swapp(int &a, int &b) { a ^= b ^= a ^= b; }\nint lowbit(int n) { return n & (-n); }\nint Del_bit_1(int n) { return n & (n - 1); }\nint abss(int a) { return a > 0 ? a : -a; }\ndouble fabss(double a) { return a > 0 ? a : -a; }\nint minn(int a, int b) { return a < b ? a : b; }\n"
        },
        {
            "language": 3,
            "solution": "def max_sub(list,k):\n    n=len(list)\n    i,sum,m=0,0,0\n    while i<k:\n        sum+=list[i]\n        i+=1\n    m=max(sum,m)\n    rem=0\n    while i<n:\n        sum-=list[rem]\n        rem+=1\n        sum+=list[i]\n        i+=1\n        m=max(sum,m)\n    return m\nimport math\nn,bytes=map(int,input().split())\nl=list(map(int,input().split()))\nl.sort()\ntemp=[]\ncount=1\n\nfor i in range(1,n):\n    if l[i]==l[i-1]:\n        count+=1\n    else:\n        temp.append(count)\n        count=1\ntemp.append(count)\n\nm=len(temp)\nif n*math.ceil(math.log(m,2))<=bytes*8:\n    print(0)\nelse:\n    max_k=m\n    while math.ceil(math.log(max_k,2))!=bytes*8//n:\n        max_k-=1\n    y=max_sub(temp,max_k)\n    print(sum(temp)-y)\n            \n"
        },
        {
            "language": 3,
            "solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\nfrom collections import Counter\nimport math\n# region fastio\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\ndef getint(): return int(input())\ndef getints(): return list(map(int, input().split()))\ndef getint1(): return list(map(lambda x: int(x) - 1, input().split()))\n\ndef main():\n    ###CODE\n    n,I = getints()\n    I = 8*I\n    k = I//n\n    K = pow(2,k)\n    a = Counter(getints())\n    curr = len(a)\n    if curr<=K:\n        print(0)\n    else:\n        a[-1] = 0\n        a1 = sorted(list(a.keys()))\n        a = [a[i] for i in a1]\n        for i in range(curr):\n            a[i+1]+=a[i]\n        a1 = curr-K\n        out = 0\n        for i in range(a1):\n            out = max(out,a[i+K]-a[i])\n        print(n-out)\n\nif __name__ == \"__main__\":\n    main()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 400 * 1000 + 10, INF = 1 * 1000 * 1000 * 1000 + 10;\nint n, I, k, tmp, ans, ted[maxn], a[maxn];\nvector<int> vec;\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie();\n  cin >> n >> I;\n  k = I * 8 / n;\n  ans = n;\n  tmp = -1;\n  for (int i = 0; i < n; i++) cin >> a[i];\n  if (k >= 20) {\n    cout << 0;\n    return 0;\n  }\n  sort(a, a + n);\n  a[n] = INF;\n  for (int i = 0; i < n; i++) {\n    if (a[i] != a[i + 1]) {\n      vec.push_back(i - tmp);\n      tmp = i;\n      ted[(((int)vec.size()))] = ted[(((int)vec.size())) - 1] + vec.back();\n    }\n  }\n  for (int i = 0; i < (((int)vec.size())); i++) {\n    tmp = ted[i];\n    if (i + (1 << k) < (((int)vec.size())))\n      tmp += ted[(((int)vec.size()))] - ted[i + (1 << k)];\n    ans = min(ans, tmp);\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.InputStreamReader;\nimport java.util.*;\nimport java.io.BufferedReader;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(InputReader in, PrintWriter out) {\n            int n = in.nextInt(); //\u503c\u6570\u91cf\n            int I = in.nextInt(); //\u5b57\u8282\u6570\n            int[] a = new int[n]; //\u539f\u59cb\u503c\n            int maxBits = I * 8 / n; //\u6bcf\u4e2a\u503c\u6700\u5927\u6bd4\u7279\u6570\n            int maxNum = 1 << Math.min(28, maxBits); //\u6700\u5927\u4e0d\u540c\u503c\u6570\n            for (int i = 0; i < n; i++) {\n                a[i] = in.nextInt();\n            }\n            //\u6b64\u5904\u7528\u7684\u662f\u5feb\u6392\uff0c\u5148\u968f\u673a\u4ea4\u6362\u6570\u503c\uff0c\u907f\u514d\u5feb\u6392\u6700\u5dee\u60c5\u51b5\n            Random random = new Random(System.currentTimeMillis());\n            for (int i = 0; i < n; i++) {\n                int j = random.nextInt(i+1);\n                int t = a[i];\n                a[i] = a[j];\n                a[j] = t;\n            }\n            Arrays.sort(a);\n            int[] b = new int[n]; //\u4e0d\u540c\u503c\u7684\u5dee\u5f02\u7edf\u4e00\u5904\u7406\u4e3a1\n            b[0] = 0;\n            for (int i = 1; i < n; i++) {\n                b[i] = b[i - 1];\n                if (a[i] > a[i - 1]) b[i]++;\n            }\n            int ret = Integer.MAX_VALUE;\n            for (int tail = 0, head = 0; tail < n; tail++) {\n                while ((b[tail] - b[head] + 1) > maxNum && head <= tail) { //\u540e\u9762\u4e00\u4e2a\u6761\u4ef6\u53bb\u6389\u8bd5\u8bd5\n                    head++;\n                }\n                ret = Math.min(ret, n - (tail - head + 1));\n            }\n            out.println(ret);\n        }\n    }\n\n    static class InputReader {\n        String x = \"select mt_user_id from dm_topic_card_jingwan_label_ss where card_meta_id='4' and ( locate('\\\\'4\\\\'', rule_id_list)>0 \";\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nT gcd(T a, T b) {\n  if (a == 0) return b;\n  return gcd(b % a, a);\n}\ntemplate <typename T>\nT lcm(T a, T b) {\n  return a * b / gcd(a, b);\n}\ntemplate <typename T>\nT power(T x, T y, long long m = 1000000007) {\n  T ans = 1;\n  while (y > 0) {\n    if (y & 1LL) ans = (ans * x) % m;\n    y >>= 1LL;\n    x = (x * x) % m;\n  }\n  return ans % m;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  int N, I;\n  vector<int> A;\n  cin >> N >> I;\n  I *= 8;\n  A.resize(N);\n  for (int &a : A) cin >> a;\n  I /= N;\n  int choices = I > 30 ? N + 1 : 1 << I;\n  sort(A.begin(), A.end());\n  map<int, int> freq;\n  int distinct = 0;\n  int best = N;\n  for (int i = 0, j = 0; i < N; i++) {\n    while (j < N && (distinct < choices || freq.find(A[j]) != freq.end())) {\n      if (freq[A[j]]++ == 0) distinct++;\n      j++;\n    }\n    best = min(best, i + N - j);\n    if (--freq[A[i]] == 0) distinct--;\n  }\n  cout << best << '\\n';\n}\n"
        },
        {
            "language": 3,
            "solution": "import os\nimport sys\nfrom io import BytesIO, IOBase\n# region fastio\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# ------------------------------\n\ndef RL(): return map(int, sys.stdin.readline().rstrip().split())\ndef RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef N(): return int(input())\ndef comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0\ndef perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0\ndef mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)\ndef toord(c): return ord(c)-ord('a')\ndef lcm(a, b): return a*b//lcm(a, b)\nmod = 998244353\nINF = float('inf')\nfrom math import factorial, sqrt, ceil, floor, gcd, log2\nfrom collections import Counter, defaultdict, deque\nfrom heapq import heapify, heappop, heappush\n\n\n# ------------------------------\n# f = open('./input.txt')\n# sys.stdin = f\n\ndef main():\n    n, i = RL()\n    arr = RLL()\n    ct = Counter(arr)\n\n    K = len(ct)\n    k = ceil(log2(K))\n\n\n    if i*8>=k*n:\n        print(0)\n    else:\n        l, r = 0, K\n\n        def c(num):\n            nowk = ceil(log2(num))\n            if i*8>=nowk*n:\n                return True\n            else:\n                return False\n\n        while l<r:\n            m = (l+r+1)//2\n            if c(m):\n                l = m\n            else:\n                r = m-1\n\n        sct = sorted(ct)\n        sm = [0]\n        for i in sct:\n            sm.append(sm[-1]+ct[i])\n\n        res = INF\n        for i in range(len(ct)):\n            if i+l>=len(sm): break\n            now = sm[i+l]-sm[i]\n            res = min(sm[-1]-now, res)\n        print(res)\n\n\n\n\n\nif __name__ == \"__main__\":\n    main()\n\n"
        },
        {
            "language": 1,
            "solution": "n,I=map(int, raw_input().split())\narr=map(int, raw_input().split())\narr.sort()\nK=(2**min(I, ((8*I)/n)))\nle=[]\nls=[[arr[0], 0]]\nfor i in xrange(1, n):\n    if arr[i-1]<arr[i]:\n        le.append([arr[i-1], i-1])\n    if arr[i-1]<arr[i]:\n        ls.append([arr[i], i])\nle.append([arr[-1], n-1])\nif len(ls)<=K:\n    print 0\n    exit(0)\n# print le\n# print ls, K\nm=n\nfor i in xrange(len(ls)):\n    # print i\n    p=n\n    if i+K-1<len(le):\n        p = (n-le[i+K-1][1]-1) + ls[i][1]\n        # print i+K-1, le[i+K-1], p\n    if p<m:\n        m=p\nprint m\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, lim;\nint a[400007];\nvector<int> srt;\nint MAXVAL;\nint cnt[400007];\nint pref[400007];\nvoid input() {\n  scanf(\"%d%d\", &n, &lim);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d\", &a[i]);\n    srt.push_back(a[i]);\n  }\n  sort(srt.begin(), srt.end());\n  map<int, int> ZX;\n  MAXVAL = 1;\n  ZX[srt[0]] = MAXVAL;\n  for (int i = 1; i <= n; ++i) {\n    if (srt[i] == srt[i - 1]) {\n      continue;\n    }\n    ZX[srt[i]] = ++MAXVAL;\n  }\n  for (int i = 1; i <= n; ++i) {\n    a[i] = ZX[a[i]];\n    ++cnt[a[i]];\n  }\n  for (int i = 1; i <= MAXVAL; ++i) {\n    pref[i] = (pref[i - 1] + cnt[i]);\n  }\n}\nvoid solve() {\n  lim *= 8;\n  long long aux = 1;\n  long long h = 0;\n  while ((h + 1) * n <= lim) {\n    ++h;\n    aux *= 2;\n    if (aux > MAXVAL) {\n      break;\n    }\n  }\n  if (aux > MAXVAL) {\n    aux = MAXVAL;\n  }\n  int mn = -1;\n  for (int i = 1; i + aux - 1 <= MAXVAL; ++i) {\n    int curr = pref[i - 1] + (pref[MAXVAL] - pref[i + aux - 1]);\n    if (mn < 0) {\n      mn = curr;\n    }\n    if (mn > curr) {\n      mn = curr;\n    }\n  }\n  printf(\"%d\\n\", mn);\n}\nint main() {\n  ios_base ::sync_with_stdio(false);\n  cin.tie(NULL);\n  input();\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "from math import *\n\nif __name__ == \"__main__\":\n    n, I = list(map(int, input().split()))\n    arr = list(map(int, input().split()))\n    I *= 8\n\n    arr.sort()\n\n    freqA = [[arr[0], 1]]\n\n    for i in range(1, n):\n        if arr[i] == arr[i - 1]:\n            freqA[-1][1] += 1\n        else:\n            freqA.append([arr[i], 1])\n\n    K = len(freqA)\n    k = int(ceil(log2(K)))\n\n    if (n * k < I):\n        print(0)\n        exit(0)\n\n    # freqA.sort()\n    # front = 0\n    # end = len(freqA) - 1\n    changes = float(\"inf\")\n\n    enoughK = int(pow(2,int(floor(I / n))))\n    enoughK = int(enoughK)\n    leftFreq = [freqA[0][1]]\n    rightFreq = [freqA[-1][1]]\n\n    for i in range(1, len(freqA)):\n        leftFreq.append(leftFreq[i - 1] + freqA[i][1])\n        rightFreq.append(rightFreq[i - 1] + freqA[len(freqA) - i - 1][1])\n\n    # print(freqA)\n    # print(leftFreq)\n    # print(rightFreq)\n\n    KK = len(freqA) - enoughK\n\n    # if enoughK != len(freqA):\n\n    for left in range(0, KK + 1):\n        # KK = len(freqA) - enoughK\n        right = KK - left\n        # print(left, right)\n        possibleChanges = 0\n        if (left != 0):\n            possibleChanges += leftFreq[left - 1]\n        if (right != 0):\n            possibleChanges += rightFreq[right - 1]\n        \n        changes = min(changes, possibleChanges)\n    \n    # else:\n    #     changes = 0\n\n    if changes == float(\"inf\"):\n        changes = 0\n    print(changes)"
        },
        {
            "language": 3,
            "solution": "import sys,math\ninput = sys.stdin.readline\nI = lambda : list(map(int,input().split()))\n\nn,i = I()\nl = I()\nk = (i*8)//n\na=[];l.sort();c=1\nfor i in range(n-1):\n\tif l[i]!=l[i+1]:\n\t\ta.append(c);c=1\n\telse:\n\t\tc+=1\na.append(c)\n\nc=len(a)\nck=math.ceil(math.log2(c))\nif k>=ck:\n\tprint(0)\nelse:\n\td=2**k;p=len(a)\n\tx=sum(a[:d]);an=x\n\tfor i in range(d,p):\n\t\tx=x-a[i-d]+a[i]\n\t\tan=max(an,x)\n\tprint(n-an)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n/* * */\n\npublic class _576A implements Runnable{\n    public static void main(String[] args) {\n\t    new Thread(null, new _576A(),\"Main\",1<<27).start();\n    }\n    @Override\n    public void run() {\n        FastReader fd = new FastReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        int n = fd.nextInt();\n        long size = fd.nextInt()*8;\n        long maxPossible = size/n;\n        HashMap<Long,Integer> freq = new HashMap<>();\n        long[] data = new long[n];\n\n        for(int te = 0; te < n; te++){\n            data[te] = fd.nextLong();\n            freq.put(data[te],freq.getOrDefault(data[te],0)+1);\n        }\n        long req = (long) Math.ceil((Math.log(freq.size())/Math.log(2)))*n;\n        if(req <= size){\n            out.println(0);\n        }\n        else{\n            int count = Integer.MAX_VALUE;\n            long loop = 1L<<Math.min(maxPossible,20);\n            long[] prefix = new long[freq.size()+1];\n            prefix[0] = 0;\n            int ind = 1;\n            ArrayList<Long> freqValues = new ArrayList<>(freq.keySet());\n            Collections.sort(freqValues);\n            for(long i : freqValues){ prefix[ind] = prefix[ind-1]+freq.get(i); ind++;}\n\n            for(int i = (int)loop;i < prefix.length;i++) {\n                count = (int) Math.min(count,n-(prefix[i]-prefix[(i-(int)loop)]));\n            }\n            out.println(count);\n        }\n        out.close();\n    }\n\n    //Helper functions\n    static int[] getArray(int n,boolean isSorted, FastReader fd){\n        int[] data = new int[n];\n        for(int i = 0; i < data.length; i++){ data[i] = fd.nextInt(); }\n        if(isSorted) Arrays.sort(data);\n        return data;\n    }\n    static int gcd(int a, int b) {\n        if (a == 0)\n            return b;\n        return gcd(b % a, a);\n    }\n\n    static int lcm(int a, int b) {\n        return (a*b)/gcd(a, b);\n    }\n\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars==-1)\n                throw new InputMismatchException();\n\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n\n                if(numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n\n            while(isSpaceChar(c))\n                c = read();\n\n            int sgn = 1;\n\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n\n            int res = 0;\n            do {\n                if(c<'0'||c>'9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin, stdout\ninput = stdin.readline\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\nb.sort()\nm = 2**((a[1]*8)//len(b))\ng=[0]\nfor i in range(1, a[0]):\n    if b[i-1] != b[i]:\n        g.append(i)\nif(len(g)<=m):\n    print(0)\nelse:\n    print(a[0]-max(g[i+m]-g[i] for i in range(len(g)-m)))\n\n\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Aman Kumar Singh\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CMP3 solver = new CMP3();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CMP3 {\n        PrintWriter out;\n        InputReader in;\n        final Comparator<Tuple> com = new Comparator<Tuple>() {\n            public int compare(Tuple t1, Tuple t2) {\n                if (t1.x != t2.x)\n                    return Integer.compare(t1.x, t2.x);\n                else\n                    return Integer.compare(t1.y, t2.y);\n            }\n        };\n\n        int lg(int x) {\n            int cnt = 0;\n            int p = 1;\n            while (p < x) {\n                p *= 2;\n                cnt++;\n            }\n            return cnt;\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            this.out = out;\n            this.in = in;\n            int n = ni();\n            int I = ni() * 8;\n            int i = 0;\n            int[] arr = new int[n];\n            HashMap<Integer, Integer> hmap = new HashMap<>();\n            for (i = 0; i < n; i++) {\n                arr[i] = ni();\n                Integer x = hmap.get(arr[i]);\n                if (x == null)\n                    hmap.put(arr[i], 1);\n                else\n                    hmap.put(arr[i], ++x);\n            }\n            Tuple[] hola = new Tuple[hmap.size()];\n            int c = 0;\n            for (int x : hmap.keySet())\n                hola[c++] = new Tuple(x, hmap.get(x));\n            Arrays.sort(hola, com);\n            int[] pf = new int[hmap.size()];\n            pf[0] = hola[0].y;\n            for (i = 1; i < hmap.size(); i++)\n                pf[i] = pf[i - 1] + hola[i].y;\n            int mn = n + 5;\n            for (i = 0; i < hmap.size(); i++) {\n                int lo = i, hi = hmap.size() - 1;\n                while (lo <= hi) {\n                    int mid = (lo + hi) >> 1;\n\n                    int cnt = lg(mid - i + 1);\n                    if (cnt * n <= I)\n                        lo = mid + 1;\n                    else\n                        hi = mid - 1;\n                }\n                int x = pf[lo - 1];\n                if (i != 0)\n                    x -= pf[i - 1];\n                mn = Math.min(mn, n - (x));\n            }\n            pn(mn);\n        }\n\n        int ni() {\n            return in.nextInt();\n        }\n\n        void pn(long zx) {\n            out.println(zx);\n        }\n\n        class Tuple {\n            int x;\n            int y;\n\n            Tuple(int a, int b) {\n                x = a;\n                y = b;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new UnknownError();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new UnknownError();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public String next() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuffer res = new StringBuffer();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 4e5 + 5;\nconst int inf = 0x3f3f3f3f;\nconst int mod = 1e9 + 7;\nint a[maxn], b[maxn];\nint n, m, I;\nint cal(int l, int r) {\n  int L = lower_bound(a + 1, a + 1 + n, b[l]) - a;\n  int R = lower_bound(a + 1, a + 1 + n, b[r] + 1) - a - 1;\n  return n - (R - L + 1);\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> I;\n  for (int i = 1; i <= n; ++i) {\n    cin >> a[i];\n    b[i] = a[i];\n  }\n  sort(a + 1, a + 1 + n);\n  sort(b + 1, b + 1 + n);\n  m = unique(b + 1, b + 1 + n) - b - 1;\n  int k = min(30, 8 * I / n);\n  int K = 1 << k;\n  int ret = inf;\n  for (int i = 1; i <= m; ++i) {\n    int j = min(m, i + K - 1);\n    ret = min(ret, cal(i, j));\n  }\n  cout << ret << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long mod = 1000000007LL;\nlong long large = 2000000000000000000LL;\nint main() {\n  int n, I;\n  cin >> n >> I;\n  I *= 8;\n  vector<int> a(n, 0);\n  for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n  sort(a.begin(), a.end());\n  vector<pair<int, int> > e;\n  for (int i = 0; i < n; i++) {\n    if (e.size() == 0 || e.back().first != a[i]) {\n      e.push_back(pair<int, int>(a[i], 1));\n    } else\n      e.back().second++;\n  }\n  int ans = n;\n  int k = I / n;\n  int m = (int)e.size();\n  if (k >= 20 || (1 << k) >= m) {\n    cout << 0 << endl;\n    return 0;\n  }\n  int l = (1 << k);\n  int pre = 0;\n  vector<int> suf(m, 0);\n  for (int i = 0; i < m; i++) suf[i] = e[i].second;\n  for (int i = m - 2; i >= 0; i--) suf[i] += suf[i + 1];\n  for (int i = 0; i + l <= m; i++) {\n    int temp = pre;\n    if (i + l < m) temp += suf[i + l];\n    ans = min(ans, temp);\n    pre += e[i].second;\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.StreamTokenizer;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic StreamTokenizer st=new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n\tpublic static void main(String[] args) {\n\t\tint n=nextInt();\n\t\tint I=nextInt();\n\t\tint k=8*I/n;\n\t\tlong K;\t\n\t\tint a[]=new int[n+1];\n\t\tint num[]=new int[n+1];\n\t\tint cnt=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\ta[n+1-i]=nextInt();\t\n\t\t}\n\t\tArrays.sort(a,1,n+1);\n\t\ta[0]=-1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(a[i]!=a[i-1])\n\t\t\t\tnum[++cnt]=i;\n\t\t}\n\t\tK=(int)(Math.log((double)(a[n]-a[1]))/Math.log(2.0));\n\t\tif(K<k){\n\t\t\tSystem.out.println(0);\n\t\t}else{\n\t\t\tint ans=n;\n\t\t\tfor(int i=1;i<cnt;i++){\n\t\t\t\tint c=i+(1<<k)-1;\n\t\t\t\tif(c>cnt)\n\t\t\t\t\tbreak;\n\t\t\t\tans=Math.min(ans, n-num[c]+num[i-1]);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tstatic int nextInt(){\n\t\ttry {\n\t\t\tst.nextToken();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn (int)st.nval;\n\t}\n}\n"
        },
        {
            "language": 3,
            "solution": "\ndef naiveSolve(n):\n    \n    \n    \n    return\n\n\n\ndef main():\n    \n    n,I=readIntArr()\n    a=readIntArr()\n    \n    k=(8*I)//n\n    K=pow(2,k)\n    \n    a.sort()\n    # coordinate compress since we only care about distinct values\n    b=[0]*n\n    v=0\n    for i in range(n):\n        if i-1>=0 and a[i]>a[i-1]:\n            v+=1\n        b[i]=v\n    a=b\n    \n    # ans=inf\n    # r=-1\n    # for l in range(n):\n    #     lower=a[l]\n    #     upper=K+lower-1\n    #     while r+1<n and a[r+1]<=upper:\n    #         r+=1\n    #     ans=min(ans,l+n-1-r)\n    # print(ans)\n    \n    # Alternatively, count occurrences\n    cnts=[0]*(a[-1]+1)\n    for x in a:\n        cnts[x]+=1\n    # Convert to prefix sums\n    for i in range(1,len(cnts)):\n        cnts[i]+=cnts[i-1]\n    def rangeQ(lower,upper):\n        if lower==0:\n            return cnts[upper]\n        else:\n            return cnts[upper]-cnts[lower-1]\n    ans=inf\n    for lower in range(len(cnts)):\n        upper=min(K+lower-1,len(cnts)-1)\n        ans=min(ans,n-rangeQ(lower,upper))\n    print(ans)\n\n    return\n\n\nimport sys\ninput=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\n# input=lambda: sys.stdin.readline().rstrip(\"\\r\\n\") #FOR READING STRING/TEXT INPUTS.\n\ndef oneLineArrayPrint(arr):\n    print(' '.join([str(x) for x in arr]))\ndef multiLineArrayPrint(arr):\n    print('\\n'.join([str(x) for x in arr]))\ndef multiLineArrayOfArraysPrint(arr):\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\n \ndef readIntArr():\n    return [int(x) for x in input().split()]\n# def readFloatArr():\n#     return [float(x) for x in input().split()]\n \ndef makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])\n    dv=defaultValFactory;da=dimensionArr\n    if len(da)==1:return [dv() for _ in range(da[0])]\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\n \ndef queryInteractive(l,r):\n    print('? {} {}'.format(l,r))\n    sys.stdout.flush()\n    return int(input())\n \ndef answerInteractive(x):\n    print('! {}'.format(x))\n    sys.stdout.flush()\n \ninf=float('inf')\nMOD=10**9+7\n# MOD=998244353\n\nfrom math import gcd,floor,ceil\n \nfor _abc in range(1):\n    main()\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic StreamTokenizer st = new StreamTokenizer(new BufferedInputStream(System.in));\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tstatic PrintWriter pr = new PrintWriter(new BufferedOutputStream(System.out));\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n//\t\tlong tic = System.currentTimeMillis();\n\n\t\tint n = nextInt();\n\t\tint I = nextInt() * 8 / n;\n\t\tif (I > 24) {\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t} else {\n\t\t\tI = 1 << (I);\n\t\t}\n\n\t\tint arr[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarr[i] = nextInt();\n\t\t}\n\t\tPriorityQueue<Integer> pq = new PriorityQueue<>();\n\t\tfor (int i : arr) {\n\t\t\tpq.add(i);\n\t\t}\n\t\tfor(int i = 0;i<n;i++) {\n\t\t\tarr[i] = pq.poll();\n\t\t}\n\t\tint data[] = new int[n + 1];\n\t\tdata[1] = 1;\n\t\tint id = 1;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (arr[i] == arr[i - 1]) {\n\t\t\t\tdata[id]++;\n\t\t\t} else {\n\t\t\t\tdata[++id] = 1;\n\t\t\t}\n\t\t}\n\t\tif (I >= id) {\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\t\tint te = 0;\n\t\tfor (int i = 1; i <= Math.min(n, I); i++) {\n\t\t\tte += data[i];\n\t\t}\n\t\tint ans = te;\n\t\tfor (int i = Math.min(n, I) + 1; i <= n; i++) {\n\t\t\tte += data[i];\n\t\t\tte -= data[i - I];\n\t\t\tans = Math.max(ans, te);\n\t\t}\n\t\tSystem.out.println(n - ans);\n\n//\t\tlong toc = System.currentTimeMillis();\n//\t\tSystem.out.println(\"Elapsed time: \" + (toc - tic) + \" ms\");\n\t}\n\n\tstatic int log2(long x) {\n\t\tint flag = 1;\n\t\tint log = 0;\n\t\twhile (x > flag) {\n\t\t\tflag <<= 1;\n\t\t\tlog++;\n\t\t}\n\t\treturn log;\n\t}\n\n\tstatic long phi(int x) {\n\t\tlong res = x;\n\t\tfor (long i = 2; i <= Math.sqrt(x); i++) {\n\t\t\tif (x % i == 0) {\n\t\t\t\twhile (x % i == 0)\n\t\t\t\t\tx /= i;\n\t\t\t\tres = res / i * (i - 1);\n\t\t\t}\n\t\t}\n\t\tif (x > 1)\n\t\t\tres = res / x * (x - 1);\n\t\treturn res;\n\t}\n\n\tstatic long pow(long a, long b, long mod) {\n\t\tif (b == 0)\n\t\t\treturn 1;\n\t\tif (b == 1)\n\t\t\treturn a;\n\t\tif ((b & 1) == 0)\n\t\t\treturn pow(a * a % mod, b >> 1, mod);\n\t\telse\n\t\t\treturn a * pow(a * a % mod, b >> 1, mod) % mod;\n\t}\n\n\tstatic long gcd(long a, long b) {\n\t\tif (b == 0) {\n\t\t\treturn a;\n\t\t} else {\n\t\t\treturn gcd(b, a % b);\n\t\t}\n\t}\n\n\tstatic int nextInt() {\n\t\ttry {\n\t\t\tst.nextToken();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn (int) st.nval;\n\t}\n\n\tstatic double nextDouble() {\n\t\ttry {\n\t\t\tst.nextToken();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn st.nval;\n\t}\n\n\tstatic String next() {\n\t\ttry {\n\t\t\tst.nextToken();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn st.sval;\n\t}\n\n\tstatic long nextLong() {\n\t\ttry {\n\t\t\tst.nextToken();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn (long) st.nval;\n\t}\n}\n\nclass Node {\n\tint a;\n\tint b;\n\n\tpublic Node() {\n\t}\n\n\tpublic Node(int a, int b) {\n\t\tsuper();\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Node [a=\" + a + \", b=\" + b + \"]\";\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 400005;\nint n, I;\nint a[N];\nint main() {\n  scanf(\"%d %d\", &n, &I);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", &a[i]);\n  }\n  int bit = min(20, I * 8 / n);\n  sort(a, a + n);\n  vector<int> dq;\n  for (int i = 0; i < n;) {\n    int j = i;\n    while (j < n && a[j] == a[i]) ++j;\n    dq.push_back(j - i);\n    i = j;\n  }\n  if (dq.size() <= (1 << bit)) return 0 * printf(\"0\\n\");\n  int sum = 0;\n  for (int i = 0; i < (1 << bit); ++i) {\n    sum += dq[i];\n  }\n  int ans = n - sum;\n  for (int i = 1 << bit; i < dq.size(); ++i) {\n    sum += dq[i];\n    sum -= dq[i - (1 << bit)];\n    ans = min(ans, n - sum);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ndouble EPS = 1e-9;\nlong long INF = 1000000000000000005ll;\ndouble PI = acos(-1);\ninline string IntToString(long long int a) {\n  char x[100];\n  sprintf(x, \"%lld\", a);\n  string s = x;\n  return s;\n}\ninline long long int StringToInt(string a) {\n  char x[100];\n  long long int res;\n  strcpy(x, a.c_str());\n  sscanf(x, \"%lld\", &res);\n  return res;\n}\ninline string uppercase(string s) {\n  int n = (int)s.size();\n  for (long long int i = 0; i < n; i++)\n    if (s[i] >= 'a' && s[i] <= 'z') s[i] = s[i] - 'a' + 'A';\n  return s;\n}\ninline string lowercase(string s) {\n  int n = (int)s.size();\n  for (long long int i = 0; i < n; i++)\n    if (s[i] >= 'A' && s[i] <= 'Z') s[i] = s[i] - 'A' + 'a';\n  return s;\n}\nbool sortcol(const vector<long long int>& v1, const vector<long long int>& v2) {\n  return v1[0] > v2[0];\n}\nlong long int sum(long long int n) {\n  long long int cnt = 0;\n  while (n > 0) {\n    cnt += n % 10;\n    n /= 10;\n  }\n  return cnt;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long int n, I;\n  cin >> n >> I;\n  long long int a[n];\n  for (long long int i = 0; i < n; i++) cin >> a[i];\n  long long int b = 8 * I / n;\n  long long int K = 1 << min(20ll, b);\n  set<long long int> s;\n  map<long long int, long long int> m;\n  for (long long int i = 0; i < n; i++) {\n    s.insert(a[i]);\n    m[a[i]]++;\n  }\n  vector<long long int> cnt;\n  for (auto i = m.begin(); i != m.end(); i++) {\n    cnt.push_back(i->second);\n  }\n  if (K >= s.size()) {\n    cout << 0 << '\\n';\n    return 0;\n  }\n  long long int cur = 0;\n  for (long long int i = 0; i < K; i++) {\n    cur += cnt[i];\n  }\n  long long int sum = n - cur;\n  for (long long int i = K; i < cnt.size(); i++) {\n    cur -= cnt[i - K];\n    cur += cnt[i];\n    sum = min(sum, n - cur);\n  }\n  cout << sum << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n, I = map(int, input().split())\na = sorted(list(map(int, input().split())))\ncur = 0\nb = [0]\nfor i in range(1, n):\n    if a[i] != a[i - 1]:\n        cur += 1\n    b.append(cur)\nr = 1\nans = int(1e18)\nfor l in range(len(b)):\n    ma = b[l] + 2 ** min((I * 8 // n), 30) - 1\n    while r < n and b[r] <= ma:\n        r += 1\n    ans = min(ans, l + (n - r))\nprint(ans)\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.util.stream.Collectors;\n\npublic class Main{\n    public static void main(String[] args) {\n        // Use the Scanner class\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        int i = sc.nextInt();\n\n        List<Integer> initList = new ArrayList<>(n);\n        for(int c = 0; c<n; c++) {\n            int a = sc.nextInt();\n            initList.add(a);\n        }\n\n        initList.sort(Comparator.comparingInt(o2 -> o2));\n        List<Node> list = new ArrayList<>(initList.size());\n        for(Integer it : initList) {\n            if(!list.isEmpty()) {\n                if(list.get(list.size()-1).x == it) {\n                    list.get(list.size()-1).y += 1;\n                }\n                else {\n                    list.add(new Node(it ,1));\n                }\n            }\n            else {\n                list.add(new Node(it ,1));\n            }\n        }\n        i = i*8;\n        i = (int) Math.abs(i/(n*1.0));\n        int size = list.size();\n        int iMax = (int) Math.ceil(Math.log(size)/Math.log(2));\n//        System.out.println(iMax + \" \" + size + \" \"  + i);\n        if(iMax > i) {\n            int num = (int) Math.pow(2, i);\n            int maxSum = 0;\n            int ans = 0;\n            int p1=0;\n            int p2=0;\n            while (p2 < size){\n                if(p2-p1+1 <= num) {\n                    ans += list.get(p2).y;\n                    p2+=1;\n                }\n                else {\n                    ans -= list.get(p1).y;\n                    ans += list.get(p2).y;\n                    p1+=1;\n                    p2+=1;\n                }\n//                System.out.println(ans + \" \" + maxSum);\n                if(maxSum < ans) {\n                    maxSum = ans;\n                }\n            }\n            System.out.println(n-maxSum);\n        }\n        else {\n            System.out.println(0);\n        }\n\n\n    }\n\n    static class Node {\n        int x;\n        int y;\n\n        public Node(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\npublic class C {\n\tpublic static void main(String[] args) throws IOException{\n\t\t//Scanner in = new Scanner(System.in);\n\t\tBufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer in = new StringTokenizer(f.readLine());\n\t\tint n = Integer.parseInt(in.nextToken());\n\t\tdouble m = Integer.parseInt(in.nextToken());\n\t\tdouble x = 0;\n\t\tfor(int i=0;i<20;i++) {\n\t\t\tx++;\n\t\t\tif(x*n>m*8) {\n\t\t\t\tx--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(x>=19) {\n\t\t\tSystem.out.println(0);\n\t\t}else {\n\t\t\tin = new StringTokenizer(f.readLine());\n\t\t\tx = Math.pow(2,x);\n\t\t\tHashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\n\t\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\t\tint total = 0;\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tint a = Integer.parseInt(in.nextToken());\n\t\t\t\tif(!map.containsKey(a)) {\n\t\t\t\t\tmap.put(a, 0);\n\t\t\t\t\tlist.add(a);\n\t\t\t\t}\n\t\t\t\tmap.put(a, map.get(a)+1);\n\t\t\t}\n\t\t\tif(x>=list.size()) {\n\t\t\t\tSystem.out.println(0);\n\t\t\t}else {\n\t\t\t\tCollections.sort(list);\n\t\t\t\tint[] a = new int[list.size()];\n\t\t\t\tfor(int i=0;i<list.size();i++) {\n\t\t\t\t\ta[i] = map.get(list.get(i));\n\t\t\t\t}\n\t\t\t\t//System.out.println(Arrays.toString(a));\n\t\t\t\t//System.out.println(Math.floor(x));\n\t\t\t\tint c = 0;\n\t\t\t\tfor(int i=0;i<Math.floor(x);i++) {\n\t\t\t\t\tc+=a[i];\n\t\t\t\t}\n\t\t\t\tint min = n-c;\n\t\t\t\tfor(int i=0;i<list.size()-Math.floor(x);i++) {\n\t\t\t\t\tc-=a[i];\n\t\t\t\t\tc+=a[i+(int)Math.floor(x)];\n\t\t\t\t\tif(n-c<min) {\n\t\t\t\t\t\tmin = n-c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(min);\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 400005;\nint n, I, a[MAXN], cnt[MAXN], m;\nint main() {\n  cin >> n >> I;\n  I *= 8;\n  int k = I / n;\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  sort(a + 1, a + n + 1);\n  a[0] = -1;\n  for (int i = 1; i <= n; i++)\n    if (a[i] > a[i - 1])\n      cnt[++m] = 1;\n    else\n      ++cnt[m];\n  if (k > 30 || (1 << k) >= m)\n    k = m;\n  else\n    k = 1 << k;\n  for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];\n  int ans = 1 << 30;\n  for (int i = k; i <= m; i++) ans = min(ans, n - (cnt[i] - cnt[i - k]));\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, tmp, ans = 2147483647, a[400005], sum[400005], num[400005];\nlong long Read() {\n  long long k = 0, tmp = 1;\n  char _c = getchar();\n  while (_c > '9' or _c < '0') {\n    if (_c == '-') tmp = -1;\n    _c = getchar();\n  }\n  while (_c <= '9' and _c >= '0') {\n    k = (k << 1) + (k << 3) + (_c ^ 48);\n    _c = getchar();\n  }\n  return k * tmp;\n}\nint bit(int x) {\n  int k = 1;\n  while (x--) {\n    k *= 2;\n    if (k >= n) return k;\n  }\n  return k;\n}\nint main() {\n  n = Read(), m = bit(Read() * 8 / n);\n  for (int i = 1; i <= n; i++) {\n    a[i] = Read();\n  }\n  sort(a + 1, a + 1 + n);\n  a[0] = -1;\n  for (int i = 1; i <= n; i++) {\n    if (a[i] != a[i - 1]) {\n      num[++tmp]++;\n    } else\n      num[tmp]++;\n  }\n  if (tmp <= m) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  for (int i = 1; i <= tmp; i++) {\n    sum[i] = sum[i - 1] + num[i];\n  }\n  for (int i = m; i <= tmp; i++) {\n    ans = min(ans, n - (sum[i] - sum[i - m]));\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1199C extends PrintWriter {\n\tCF1199C() { super(System.out, true); }\n\tScanner sc = new Scanner(System.in);\n\tpublic static void main(String[] $) {\n\t\tCF1199C o = new CF1199C(); o.main(); o.flush();\n\t}\n\n\tvoid main() {\n\t\tint n = sc.nextInt();\n\t\tint b = sc.nextInt();\n\t\tb = b * 8 / n;\n\t\tif (b > 30) {\n\t\t\tprintln(0);\n\t\t\treturn;\n\t\t}\n\t\tb = 1 << b;\n\t\tint[] aa = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\taa[i] = sc.nextInt();\n\t\taa = Arrays.stream(aa).boxed().sorted().mapToInt($->$).toArray();\n\t\tfor (int i = 0, a = 0; i < n; i++)\n\t\t\taa[i] = i + 1 == n || aa[i + 1] != aa[i] ? a++ : a;\n\t\tint ans = n;\n\t\tfor (int i = 0, j = 0; i < n && j < n; i++) {\n\t\t\twhile (j < n && aa[j] - aa[i] + 1 <= b)\n\t\t\t\tj++;\n\t\t\tans = Math.min(ans, i + n - j);\n\t\t}\n\t\tprintln(ans);\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int kMaxn = 4e5 + 10;\nusing namespace std;\nint a[kMaxn], s[kMaxn] = {0}, unq[kMaxn][2];\nint N, I, Ans;\nint main() {\n  cin >> N >> I;\n  for (register int i = 1; i <= N; ++i) cin >> a[i];\n  int n = 1;\n  sort(a + 1, a + N + 1);\n  unq[1][0] = a[1];\n  unq[1][1]++;\n  for (register int i = 1, j = 1; i < N;) {\n    if (a[i] != a[++j]) i = j, unq[++n][0] = a[i];\n    unq[n][1]++;\n  }\n  int k = I * 8 / N;\n  int maxK = pow(2, min(20, k));\n  if (maxK >= n) return cout << 0, 0;\n  for (register int i = 1; i <= n; ++i) s[i] = s[i - 1] + unq[i][1];\n  Ans = 1e9;\n  for (register int i = 1; i + maxK - 1 <= n; ++i)\n    Ans = min(Ans, N - s[i + maxK - 1] + s[i - 1]);\n  printf(\"%d\\n\", Ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 4e5 + 5;\nint n, b;\nint a[MAXN];\nvoid addNext(int& right) {\n  if (right == n) return;\n  right++;\n  while (right < n && a[right] == a[right - 1]) right++;\n}\nvoid removeLeft(int& left, int& right) {\n  left++;\n  while (left < right && a[left] == a[left - 1]) left++;\n}\nint main() {\n  scanf(\"%d%d\", &n, &b);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", a + i);\n  }\n  if (8 * b / n >= 20 || 1ll << (8 * b / n) >= n) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  sort(a, a + n);\n  long long k = 1ll << (8 * b / n);\n  int right = 0;\n  int left = 0;\n  for (int i = 0; i < k; ++i) addNext(right);\n  int sol = n - (right - left);\n  while (right < n) {\n    removeLeft(left, right);\n    addNext(right);\n    sol = min(sol, n - (right - left));\n  }\n  printf(\"%d\\n\", sol);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 400005;\nint a[N];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n, s;\n  cin >> n >> s;\n  int max_diff = 1 << min(20, 8 * s / n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  sort(a, a + n);\n  int l = 0, r = 0;\n  int diff = 1;\n  int best = n - 1;\n  while (l < n - 1) {\n    while (diff <= max_diff) {\n      best = min(best, n - (r - l + 1));\n      if (r == n - 1) {\n        break;\n      }\n      if (a[r] != a[r + 1]) {\n        diff++;\n      }\n      r++;\n    }\n    if (l < n - 1 && a[l] != a[l + 1]) {\n      diff--;\n    }\n    l++;\n  }\n  cout << best << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst double eps = 0.0000001;\nusing namespace std;\ninline int sgn(double x) { return (x > eps) - (x < -eps); }\nstatic char buf[100000], *pa = buf, *pd = buf;\ninline long long read() {\n  register long long x(0), f(1);\n  register char c(\n      pa == pd && (pd = (pa = buf) + fread(buf, 1, 100000, stdin), pa == pd)\n          ? EOF\n          : *pa++);\n  while (c > '9' || c < '0')\n    f = c == '-' ? -1 : 1,\n    c = pa == pd && (pd = (pa = buf) + fread(buf, 1, 100000, stdin), pa == pd)\n            ? EOF\n            : *pa++;\n  while (c >= '0' && c <= '9')\n    x = x * 10 + c - 48,\n    c = pa == pd && (pd = (pa = buf) + fread(buf, 1, 100000, stdin), pa == pd)\n            ? EOF\n            : *pa++;\n  return f * x;\n}\nlong long ans[(long long)1e6 + 5];\nlong long Qz[(long long)1e6 + 5];\nmap<long long, long long> sum;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long n, m;\n  cin >> n >> m;\n  for (int i = 1; i <= n; ++i) {\n    cin >> ans[i];\n    sum[ans[i]]++;\n  }\n  sort(ans + 1, ans + n + 1);\n  long long num = unique(ans + 1, ans + n + 1) - ans - 1;\n  for (int i = 1; i <= num; ++i) {\n    Qz[i] = Qz[i - 1] + sum[ans[i]];\n  }\n  long long bit = 8 * m;\n  bit = (bit * 1.0 / n);\n  if ((1 << bit) >= num || bit >= 30) {\n    cout << 0 << endl;\n    return 0;\n  }\n  long long i = 1, j = num;\n  long long Sum = num - (1 << bit);\n  j = num;\n  long long MAX = -1e10;\n  for (int i = 1, j = num - Sum; j <= num; i++, j++) {\n    MAX = max(MAX, Qz[j] - Qz[i - 1]);\n  }\n  cout << Qz[num] - MAX;\n}\n"
        },
        {
            "language": 3,
            "solution": "n,m= map(int, input().split())\narr = list(map(int, input().split()))\narr.sort()\nlimit=2**(8*m//n)\ncnt=limit-len(set(arr))\nls=[0]\nif cnt>=0:\n    print(0)\nelse:\n    ma=0\n    for i in range(1,n):\n        if arr[i]!=arr[i-1]:\n            ls.append(i)\n\n    for i in range(len(ls)-limit):\n        ma=max(ma,ls[i+limit]-ls[i])\n    print(n-ma)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, i;\n  cin >> n >> i;\n  i = 8 * i / n;\n  map<int, int> m;\n  for (int j = 0; j < n; j++) {\n    int x;\n    cin >> x;\n    m[x]++;\n  }\n  vector<int> v;\n  for (auto it : m) {\n    v.push_back(it.second);\n  }\n  for (int j = 1; j < v.size(); j++) {\n    v[j] += v[j - 1];\n  }\n  int si = pow(2, min(i, 20));\n  if (si >= v.size()) {\n    cout << \"0\";\n    return 0;\n  }\n  int ans = v[v.size() - 1] - v[si - 1];\n  for (int j = 1; j + si < v.size(); j++) {\n    ans = min(ans, v[v.size() - 1] - (v[j + si - 1] - v[j - 1]));\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "//Code by Sounak, IIEST\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.TreeMap;\n \npublic class Mp3 {\n    public static void main(String[] args)throws IOException {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        String line[]=br.readLine().split(\" \");\n        int n=Integer.parseInt(line[0]);\n        int size=Integer.parseInt(line[1]);\n        int k=8*size/n;\n        k=(int)Math.pow(2,Math.min(20,k));\n \n        line=br.readLine().split(\" \");\n        int a[]=new int[n];\n        TreeMap<Integer,Integer> map=new TreeMap<>();\n        for(int i=0;i<n;i++){\n            a[i]=Integer.parseInt(line[i]);\n            map.put(a[i],map.getOrDefault(a[i],0)+1);\n        }\n        if(k>=map.size()){\n            System.out.println(0);\n            return;\n        }\n        int store[]=new int[map.size()];\n        int i=0;\n        for(int key:map.keySet()){\n            store[i++]=map.get(key);\n        }\n        int prefix[]=new int[store.length];\n        prefix[0]=store[0];\n        for(i=1;i<store.length;i++){\n            prefix[i]=prefix[i-1]+store[i];\n        }\n        int min=n;\n        for(i=0;i+k-1<prefix.length;i++){\n            int curr=prefix[i+k-1];\n            curr-=i-1>=0?prefix[i-1]:0;\n            min=Math.min(min,n-curr);\n        }\n        System.out.println(min);\n    }\n}"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n\n/**\n *\n * @author Andy Phan\n */\npublic class a {\n    public static void main(String[] args) {\n        FS in = new FS(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        \n        int n = in.nextInt();\n        int I = in.nextInt();\n        Integer[] input = new Integer[n];\n        for(int i = 0; i < n; i++) {\n            input[i] = in.nextInt();\n        }\n        \n        Arrays.sort(input);\n        \n        int[] arr = new int[n];\n        for(int i = 0; i < n; i++) arr[i] = input[i];\n        \n        int[] num = new int[n];\n        int next = 1;\n        num[0] = 1;\n        for(int i = 1; i < n; i++) {\n            if(arr[i] == arr[i-1]) num[next-1]++;\n            else num[next++]++;\n        }\n        int[] sum = new int[next+1];\n        for(int i = 0; i < next; i++) sum[i+1] = sum[i] + num[i];\n        if(n == 1 || n*(Integer.numberOfTrailingZeros(Integer.highestOneBit(n-1))+1) <= 8*I) {\n            System.out.println(0);\n            return;\n        }\n        int req = ((1<<(8*I/n)));\n        int min = 987654321;\n        for(int i = 0; i < next; i++) {\n            if(i+req > next) break;\n            min = Math.min(min, n-(sum[i+req]-sum[i]));\n        }\n        if(min == 987654321) min = 0;\n        System.out.println(min);\n        out.close();\n    }\n    \n    static class FS {\n\n        BufferedReader in;\n        StringTokenizer token;\n        \n        public FS(InputStream str) {\n            in = new BufferedReader(new InputStreamReader(str));\n        }\n        \n        public String next() {\n            if (token == null || !token.hasMoreElements()) {\n                try {\n                    token = new StringTokenizer(in.readLine());\n                } catch (IOException ex) {\n                }\n                return next();\n            }\n            return token.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long> s;\nlong long num[1000000], ans[1000000];\nint main() {\n  long long n, I;\n  while (cin >> n >> I) {\n    memset(num, 0, sizeof(num));\n    memset(ans, 0, sizeof(ans));\n    s.clear();\n    for (int i = 0; i < n; i++) {\n      cin >> num[i];\n      s.push_back(num[i]);\n    }\n    if (I * 8 / n > 30)\n      cout << \"0\" << endl;\n    else {\n      sort(num, num + n);\n      sort(s.begin(), s.end());\n      s.erase(unique(s.begin(), s.end()), s.end());\n      long long k = ceil(log2(s.size()));\n      if (I * 8 >= n * k) {\n        cout << \"0\" << endl;\n      } else {\n        int tot = 1, r = 0;\n        for (int i = 0; i < n; i++) {\n          while (num[i] == num[i + r]) {\n            r++;\n          }\n          ans[tot++] = r;\n          i += r - 1;\n          r = 0;\n        }\n        for (int i = 1; i <= tot; i++) {\n          ans[i] += ans[i - 1];\n        }\n        long long oo = -1;\n        long long p = pow(2, (I * 8) / n);\n        for (long long i = 0; i + p <= tot; i++) {\n          oo = max(oo, ans[i + p] - ans[i]);\n        }\n        cout << n - oo << endl;\n      }\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  m *= 8;\n  m /= n;\n  m = min(m, 30);\n  vector<int> a(n);\n  for (int i = 0; i < n; ++i) cin >> a[i];\n  sort(a.begin(), a.end());\n  vector<pair<int, int> > v(1, pair<int, int>(a[0], 1));\n  for (int i = 1; i < n; ++i) {\n    if (a[i] == v.back().first)\n      ++v.back().second;\n    else\n      v.emplace_back(a[i], 1);\n  }\n  int k = min((int)v.size(), 1 << m);\n  vector<int> s(v.size() + 1);\n  for (int i = 0; i < (int)v.size(); ++i) {\n    s[i + 1] = s[i] + v[i].second;\n  }\n  int res = n;\n  for (int i = 0; i + k <= (int)v.size(); ++i) {\n    res = min(res, s[i] + (s.back() - s[i + k]));\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n,I = list(map(int, input().split()))\na = list(map(int, input().split()))\na.sort()\nk = 2**(I*8//n)\nb = [0] * len(set(a))\nbe = a[0]\ni = 0\nt = 0\nma = 0\nif k > len(b):\n    print(0)\nelse:\n    for x in a:\n        if x != be:\n            t += b[i]\n            if i-k >= 0:\n                t -= b[i-k]\n            ma = max(ma,t)\n            i += 1\n            b[i] += 1\n            be =x\n        else:\n            b[i] += 1\n    if b[i] > 0:\n        t += b[i]\n        if i-k >= 0:\n            t -= b[i-k]\n        ma = max(ma,t)\n    print(n-ma)\n    #print(n - max([sum(b[i:i+k]) for i in range(len(b)-k+1)]))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long oo = 1e18;\nconst int N = 4e5 + 1;\nint n, a[N], k, sum[N];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie();\n  int test = 1;\n  while (test--) {\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++) {\n      cin >> a[i];\n    }\n    sort(a + 1, a + n + 1);\n    vector<int> v;\n    v.push_back(0);\n    a[0] = -1;\n    for (int i = 1; i <= n; i++) {\n      if (a[i] != a[i - 1])\n        v.push_back(1);\n      else\n        v.back()++;\n    }\n    sum[0] = 0;\n    for (int i = 1; i < v.size(); i++) {\n      sum[i] = sum[i - 1] + v[i];\n    }\n    k = k * 8 / n;\n    int mx = 1;\n    for (int i = 1; i <= k; i++) {\n      mx *= 2;\n      if (mx > n) break;\n    }\n    mx = min(mx, n);\n    int ans = n;\n    for (int i = 1; i < v.size(); i++) {\n      int it = min(i + mx - 1, (int)v.size() - 1);\n      ans = min(ans, n - (sum[it] - sum[i - 1]));\n    }\n    cout << ans << endl;\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "line = input()\ntmp = line.split(' ')\nn, k = int(tmp[0]), int(tmp[1])\n\nline1 = input()\nlst = [int(i) for i in line1.split(' ')]\nlst.sort()\nlast, dis, ans, cnt = -1, 0, n, 0\nleft = 0\n\nif k*8//n > n:\n    print('0')\nelse:\n    mx = 2 ** (k * 8 // n)\n    for idx, num in enumerate(lst):\n        cnt += 1\n        if num != last:\n            dis += 1\n            if dis > mx:\n                new_left = left\n                while lst[new_left] == lst[left]:\n                    new_left += 1\n                    cnt -= 1\n                left = new_left\n                dis -= 1\n        ans = min(ans, n - cnt)\n        last = num\n    \n    print(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, k;\nint arr[400009];\nmap<int, int> mp;\nvector<int> v;\nint sum[400009];\nint main() {\n  cin >> n >> k;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &arr[i]);\n    if (mp[arr[i]] == 0) {\n      v.push_back(arr[i]);\n    }\n    mp[arr[i]]++;\n  }\n  sort(v.begin(), v.end());\n  k *= 8;\n  int ans = 1000000009;\n  int j = 0;\n  int num = 0;\n  int curr = 0;\n  for (int i = 0; i < v.size(); i++) {\n    curr += mp[v[i]];\n  }\n  for (int i = 0; i < v.size(); i++) {\n    while (j < v.size() && ceil(log2(j - i + 1)) * n <= k) {\n      curr -= mp[v[j]];\n      j++;\n    }\n    ans = min(ans, curr);\n    j = max(i, j);\n    curr += mp[v[i]];\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline void read(T& n) {\n  T X = 0, w = 1;\n  char ch = -1;\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') w = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    X = (X << 3) + (X << 1) + ch - '0';\n    ch = getchar();\n  }\n  n = X * w;\n}\nlong long qpow(long long a, long long b) {\n  long long ret = 1;\n  while (b) {\n    if (ret > 0x3f3f3f3f || a > 0x3f3f3f3f) return 0x3f3f3f3f;\n    if (b & 1) ret = (a * ret);\n    a = (a * a);\n    b >>= 1;\n  }\n  return ret;\n}\nconst int N = 5e5 + 10;\nlong long arr[N], hx[N];\nlong long num[N], dp[N];\nint main() {\n  long long n, I;\n  read(n), read(I);\n  for (int i = 1; i <= n; ++i) read(arr[i]), hx[i] = arr[i];\n  sort(hx + 1, hx + 1 + n);\n  int l = unique(hx + 1, hx + 1 + n) - hx;\n  for (int i = 1; i <= n; ++i) {\n    int now = lower_bound(hx + 1, hx + l, arr[i]) - hx;\n    num[now]++;\n  }\n  I <<= 3;\n  I /= n;\n  int j = 1;\n  for (int i = l - 1; i > 0; --i) dp[i] = dp[i + 1] + num[i];\n  long long ans = 0x3f3f3f3f;\n  long long tot = 0;\n  I = qpow(2, I);\n  for (int i = 1; i < l; i++) {\n    if (i + I <= l)\n      ans = min(ans, tot + dp[i + I]);\n    else\n      ans = min(ans, tot);\n    tot += num[i];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5e5 + 123, M = 3e3 + 123, inf = 1e9 + 123, mod = 1e9 + 7;\nconst long long INF = 1e18;\nint get(int x) {\n  if (x == 0 || x == 1) {\n    return 0;\n  }\n  int ans = 1;\n  for (int i = 1; i <= 19; i++) {\n    ans *= 2;\n    if (ans == x) {\n      return i;\n    }\n    if (x < ans) {\n      return i;\n    }\n  }\n}\nint main() {\n  cin.tie(0);\n  cout.tie(0);\n  ios_base::sync_with_stdio(0);\n  int n, I;\n  cin >> n >> I;\n  int a[n + 1];\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n  }\n  sort(a + 1, a + n + 1);\n  I *= 8;\n  int l = 1, ans = 0;\n  map<int, int> make_pair;\n  for (int r = 1; r <= n; r++) {\n    make_pair[a[r]]++;\n    while (n * get(make_pair.size()) > I) {\n      make_pair[a[l]]--;\n      if (make_pair[a[l]] == 0) {\n        make_pair.erase(a[l]);\n      }\n      l++;\n    }\n    ans = max(ans, r - l + 1);\n  }\n  cout << n - ans;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\na,b=map(int,input().split())\nx=(8*b)//a\nx=pow(2,x)\nz=list(map(int,input().split()))\nz.sort()\nans=[]\ncount=1\nfor i in range(1,len(z)):\n    if(z[i]==z[i-1]):\n        count+=1\n    else:\n        ans.append(count)\n        count=1\nans.append(count)\nif(len(ans)<=x):\n    print(0)\n    exit()\n\nl=0\n\ntotal=sum(ans[0:x+l])\nr=sum(ans)\nmini=r-total\nfor i in range(1,len(ans)-x+1):\n    total=total-ans[i-1]+ans[x+i-1]\n    mini=min(mini,r-total)\n\nprint(mini)\n    \n    \n    \n"
        },
        {
            "language": 3,
            "solution": "import sys\nn, I = map(int, input().split())\na = list(map(int, input().split()))\n\n\nb=a\nb.sort()                #rendezett\nc=[]                    #\u00e9rt\u00e9kek lista (rendezett)\nd=[]                    #el\u0151fordul\u00e1suk sz\u00e1ma\nfor i in range(n):\n    if i==0:\n        c.append(b[i])\n        d.append(1)\n    elif b[i]!=b[i-1]:\n        c.append(b[i])\n        d.append(1)\n    else:\n        d[len(d)-1]+=1\n\nK=len(c)                #h\u00e1nyf\u00e9le \u00e9rt\u00e9k\n#k=0                     #k*n bit a helyig\u00e9nye\n#hatvany=1\n#while K>hatvany:\n#    k+=1\n#    hatvany*=2\n\n\n##T\u00d6M\u00d6R\u00cdT\u00c9S\nif K<=2**(I*8//n):       #h\u00e1nyf\u00e9le karaktert kell elhagyni\n\tprint(0)\nelse:\n\tepszilon=K-2**(I*8//n)\n\tif epszilon!=int(epszilon):\n\t\tepszilon=int(epszilon)+1\n\n\tF=0\n\tfor i in range(epszilon):\n\t\tF+=d[i]\n\n\tMIN=F\n\n\tfor i in range(epszilon):\n\t\tF=(F-d[epszilon-1-i]+d[len(d)-1-i])\n\t\tif F<MIN:\n\t\t\tMIN=F\n    \n\tprint(MIN)\n"
        },
        {
            "language": 3,
            "solution": "import math\n\nn, I = map(int, input().split())\n\nA = sorted(list(map(int, input().split())))\n\n#I = 1\n#n = 6\nbits = I * 8\nK = 2**(bits//n)\n\n#A = sorted([2, 1, 2, 3, 4, 3])\n#A = sorted([1, 1, 2, 2, 3, 3])\n\nU = [A[0]]\nS = [0,]\n\na = A[0]\ns = 1\nfor i in range(1, n):\n  if A[i] != a:\n    U.append(A[i])\n    S.append(s)\n  a = A[i]\n  s += 1\nS.append(s)\n\nif K >= len(U):\n  print(0)\nelse:\n  ans = 10**10\n  for i in range(len(U)-K+1):\n    #print(i, i+K, s-(S[i+K]-S[i]))\n    ans = min(ans, s-(S[i+K]-S[i]))\n\n  print(ans)"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class C {\n\n    private void solve() {\n        int n = IO.nextInt();\n        int I = IO.nextInt();\n        int[] a = IO.nextIntArray(n);\n\n        int maxcnt = 1;\n        for(int i=1; i<1_000_000; i++)\n            if(Integer.toBinaryString(i).length() * n <= I*8)\n                maxcnt = i+1;\n\n        TreeMap<Integer,Integer> map = new TreeMap<>();\n        for(int i=0; i<n; i++)\n            map.put(a[i], 1+map.getOrDefault(a[i],0));\n\n        List<Integer> qcnt = new ArrayList<>();\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            qcnt.add(entry.getValue());\n        }\n\n        int best=0;\n        int cnt=0;\n\n        for(int i=0; i<qcnt.size(); i++) {\n            cnt += qcnt.get(i);\n            if(i-maxcnt >= 0)\n                cnt -= qcnt.get(i-maxcnt);\n            best = Math.max(cnt, best);\n        }\n        System.out.println(n-best);\n    }\n\n    //*************\n    //*************\n    //TEMPLATE CODE\n\n    static long MOD = 0;\n\n    public static void main(String[] args) {\n        C instance = new C();\n        int testcases = 1;//IO.nextInt();\n        while(testcases-->0)\n            instance.solve();\n    }\n\n    static class IO {\n        private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        private static StringTokenizer st;\n\n        static String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        static int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        static long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        static double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        static int[] nextIntArray(int size) {\n            int a[] = new int[size];\n            for (int i = 0; i < size; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        static long[] nextLongArray(int size) {\n            long a[] = new long[size];\n            for (int i = 0; i < size; i++)\n                a[i] = nextLong();\n            return a;\n        }\n\n        static double[] nextDoubleArray(int size) {\n            double a[] = new double[size];\n            for (int i = 0; i < size; i++)\n                a[i] = nextDouble();\n            return a;\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "from itertools import accumulate\n# python template for atcoder1\nimport sys\nsys.setrecursionlimit(10**9)\ninput = sys.stdin.readline\n\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\nA = sorted(A)\nL = []\nprev = -1\nfor a in A:\n    if a == prev:\n        L[-1] += 1\n    else:\n        L.append(1)\n        prev = a\n\n\nmax_types = int(2**((8*K)//N))\n\nall_types = len(L)\ndel_types = all_types-max_types\nif del_types <= 0:\n    ans = 0\nelse:\n    ans = float('inf')\n    sum_L = N\n    L_acc = [0]+list(accumulate(L))\n    for i in range(len(L)-max_types):\n        s = L_acc[i+max_types]-L_acc[i]\n        ans = min(ans, sum_L-s)\nprint(ans)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.List;\nimport java.util.SortedMap;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Throwable {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint I = Integer.parseInt(st.nextToken());\n\t\tst = new StringTokenizer(br.readLine());\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = Integer.parseInt(st.nextToken());\n\t\t}\n\t\tSystem.out.println(solve(a, I));\n\t}\n\n\tstatic int solve(int[] a, int I) {\n\t\tSortedMap<Integer, Integer> valueToCount = new TreeMap<>();\n\t\tfor (int value : a) {\n\t\t\tvalueToCount.put(value, valueToCount.getOrDefault(value, 0) + 1);\n\t\t}\n\n\t\tList<Integer> counts = valueToCount.values().stream().collect(Collectors.toList());\n\n\t\tint bitNum = I * 8 / a.length;\n\t\tint windowSize = 1;\n\t\tfor (int i = 0; i < bitNum; i++) {\n\t\t\twindowSize *= 2;\n\n\t\t\tif (windowSize > counts.size()) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tint sum = IntStream.range(0, windowSize).map(counts::get).sum();\n\t\tint maxSum = sum;\n\t\tfor (int i = windowSize; i < counts.size(); i++) {\n\t\t\tsum += counts.get(i) - counts.get(i - windowSize);\n\t\t\tmaxSum = Math.max(maxSum, sum);\n\t\t}\n\n\t\treturn a.length - maxSum;\n\t}\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.lang.reflect.Array;\nimport java.util.*;\n\n/*\n*/\npublic class Main{\n\n    static class Node{\n        int dif;\n        int size;\n        Node(int dif,int size){\n            this.dif=dif;\n            this.size=size;\n        }\n    }\n    public static void main(String[] args) throws IOException{\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw=new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        StringTokenizer st=new StringTokenizer(br.readLine());\n        int n=Integer.parseInt(st.nextToken());\n        int k=(Integer.parseInt(st.nextToken())*8);\n        int[] arr=new int[n];\n        st=new StringTokenizer(br.readLine());\n        for(int i=0;i<n;i++){\n            arr[i]=Integer.parseInt(st.nextToken());\n        }\n        k=k/n;\n        int ditinct=1;\n        for(int i=1;i<=k;i++){\n            ditinct=ditinct*2;\n            if(ditinct>=n){\n                break;\n            }\n        }\n        if(ditinct>=n){\n            pw.println(\"0\");\n        }else {\n            HashMap<Integer,Integer> map=new HashMap<>();\n            for(int i=0;i<n;i++){\n                if(map.containsKey(arr[i])){\n                    map.replace(arr[i],map.get(arr[i])+1);\n                }else {\n                    map.put(arr[i],1);\n                }\n            }\n            if(map.size()<=ditinct){\n                pw.println(\"0\");\n            }else {\n                Node[] list=new Node[map.size()];\n                int j=0;\n                for(Map.Entry<Integer,Integer> itr:map.entrySet()){\n                    list[j++]=new Node(itr.getKey(),itr.getValue());\n                }\n                Arrays.sort(list, new Comparator<Node>() {\n                    @Override\n                    public int compare(Node o1, Node o2) {\n                        return o1.dif-o2.dif;\n                    }\n                });\n                for(int i=1;i<map.size();i++){\n                    list[i].size+=list[i-1].size;\n                }\n                int ans=Integer.MAX_VALUE;\n                for(int i=0;i<map.size()-ditinct+1;i++){\n                    ans=Math.min(ans,n-(list[i+ditinct-1].size-list[i].size+map.get(list[i].dif)));\n                }\n                pw.println(ans);\n            }\n        }\n\n        pw.close();\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.security.KeyStore.Entry;\nimport java.time.temporal.JulianFields;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n \nimport javax.swing.JLabel;\n \npublic class answertillD {\n\tstatic int minn;\n \n\tstatic class pair implements Comparable<pair> {\n\t\tint u;\n\t\tint v;\n \n\t\tpublic pair(int uo, int vo) {\n\t\t\tu = uo;\n\t\t\tv = vo;\n \n\t\t}\n \n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"pair [u=\" + u + \", v=\" + v + \"]\";\n\t\t}\n \n\t\t@Override\n\t\tpublic int compareTo(pair e) {\n\t\t\tif (u == e.u && v == e.v)\n\t\t\t\treturn 0;\n\t\t\tif (u > e.u || e.u > u)\n\t\t\t\treturn u - e.u;\n\t\t\telse\n\t\t\t\treturn 1;\n\t\t}\n\t}\n \n\tstatic class edge implements Comparable<edge> {\n\t\tint u;\n\t\tint v;\n\t\tint w;\n \n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"edge [u=\" + u + \", v=\" + v + \", w=\" + w + \"]\";\n\t\t}\n \n\t\tpublic edge(int uo, int vo, int wo) {\n\t\t\tu = uo;\n\t\t\tv = vo;\n\t\t\tw = wo;\n\t\t}\n \n\t\t@Override\n\t\tpublic int compareTo(edge e) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn w - e.w;\n\t\t}\n\t}\n \n\tpublic static long power(long x, long y) {\n\t\tlong ans = 1;\n\t\twhile (y-- > 0) {\n\t\t\tif (ans <= 1e18 / x)\n\t\t\t\tans *= x;\n\t\t\telse {\n\t\t\t\tans = Long.MAX_VALUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n \n\tpublic static char[][] reb() {\n\t\tint n = smallArr.length;\n\t\tchar[][] arr = new char[n][n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tarr[i][j] = smallArr[n - j - 1][i];\n \n\t\treturn arr;\n\t}\n \n\tstatic char[] Arr, cost, level;\n\tstatic char[][] smallArr;\n\tstatic int[][][] memo;\n\tstatic int n;\n\tstatic long S;\n\tstatic final int VISITED = 2, EXPLORED = 1, UNVISITED = 0;\n\tstatic ArrayList<Integer>[] adjList;\n\tstatic boolean[] visited, adjMat[];\n\tstatic int V, E;\n \n\tstatic long bfs(String str, int k) {\n\t\tQueue<String> q = new LinkedList<String>();\n\t\tq.add(str);\n\t\tHashSet<String> hs = new HashSet<String>();\n\t\ths.add(str);\n\t\tHashMap<String, Integer> hm = new HashMap<String, Integer>();\n\t\thm.put(str, 0);\n\t\tlong ans = 0;\n\t\twhile (k > 0 && !q.isEmpty()) {\n\t\t\tString u = q.remove();\n\t\t\tfor (int v = 0; v < u.length(); v++) {\n\t\t\t\tString sam = u.substring(0, v) + u.substring(v + 1);\n\t\t\t\tif (!hm.containsKey(sam)) {\n\t\t\t\t\tint x = hm.get(u) + 1;\n\t\t\t\t\thm.put(sam, x);\n\t\t\t\t\tk--;\n\t\t\t\t\tans += x;\n\t\t\t\t\tif (k == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tq.add(sam);\n\t\t\t\t}\n\t\t\t}\n \n\t\t}\n\t\tif (k != 0)\n\t\t\treturn -1;\n\t\treturn ans;\n \n\t}\n \n\tpublic static long GCD(long a, long b) {\n\t\tif (b == 0)\n\t\t\treturn a;\n\t\treturn GCD(b, a % b);\n\t}\n \n\tpublic static long powerlog(long x, long y) {\n\t\tlong res = 1; // Initialize result\n\t\twhile (y > 0) {\n\t\t\tif ((y & 1) == 1)\n\t\t\t\tres = (res * x);\n\t\t\t// res %= 998244353;\n\t\t\ty = y >> 1; // y = y/2\n\t\t\tx = (x * x);\n\t\t\t// x %= 998244353;\n\t\t}\n\t\treturn res;\n\t}\n \n\tpublic static String rev(String str) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = str.length() - 1; i >= 0; i--) {\n\t\t\tsb.append(str.charAt(i));\n\t\t}\n\t\treturn sb + \"\";\n\t}\n \n\tpublic static boolean checj(int numa, int b, int a, int n, int k) {\n\t\tint numb = n - numa;\n\t\tif (k % a == 0) {\n\t\t\tif (k / a - 1 < numa)\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tif (k / a < numa)\n\t\t\t\treturn false;\n\t\t}\n\t\tk -= numa * a;\n\t\tif (k % b == 0) {\n\t\t\tif (k / b - 1 < numb)\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tif (k / b < numb)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n \n\tpublic static int dp(int previdx, int idx, int rem) {\n\t\tif (rem == 0)\n\t\t\treturn 0;\n\t\tif (idx == n)\n\t\t\treturn (int) -(1e9);\n\t\tif (memo[previdx][idx][rem] != -1)\n\t\t\treturn memo[previdx][idx][rem];\n\t\tint remove = 0;\n\t\tint leave = dp(idx, idx + 1, rem);\n\t\tif (leave < 0)\n\t\t\tleave = 0;\n\t\tif (previdx == n || Arr[previdx] != Arr[idx])\n\t\t\tremove = 1 + dp(previdx, idx + 1, rem - 1);\n\t\tif (remove < 0)\n\t\t\tremove = 0;\n\t\treturn memo[previdx][idx][rem] = leave + remove;\n\t}\n \n\tpublic static void main(String[] args) throws IOException, InterruptedException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\tint n = sc.nextInt();\n\t\tint I = sc.nextInt();\n\t//\tInteger []Arr=new Integer[n];\n//\t\tHashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();\n//\t\tTreeSet<Integer> ts = new TreeSet<Integer>();\n\t\tTreeMap<Integer, Integer>tm=new TreeMap<Integer, Integer>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a = sc.nextInt();\n//\t\t\tts.add(a);\n//\t\t\thm.put(a, hm.getOrDefault(a, 0) + 1);\n\t\t\ttm.put(a, tm.getOrDefault(a, 0)+1);\n\t\t}\n\t\tint k;\n\t\tif (I * 8 / n < 22)\n\t\t\tk = 1 << (I * 8 / n);\n\t\telse{\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\t\tlong Accsum = 0;\n\t\tlong ans = 0;\n\t\tfor (java.util.Map.Entry<Integer, Integer> e : tm.entrySet()) {\n\t\t\tif (q.size() < k) {\n\t\t\t\tq.add(e.getKey());\n\t\t\t\tAccsum += e.getValue();\n\t\t\t} else {\n\t\t\t\tans = Math.max(ans, Accsum);\n\t\t\t\tAccsum -= tm.get(q.poll());\n\t\t\t\tq.add(e.getKey());\n\t\t\t\tAccsum += e.getValue();\n\t\t\t}\n\t\t}\n\t\tans = Math.max(ans, Accsum);\n\t\tpw.println(n - ans);\n\t\tpw.close();\n\t}\n \n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n \n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif (x.charAt(0) == '-') {\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor (int i = start; i < x.length(); i++)\n\t\t\t\tif (x.charAt(i) == '.') {\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif (dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) / f;\n\t\t\treturn res * (neg ? -1 : 1);\n\t\t}\n \n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n \n\t}\n \n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint n, m, a[400005];\ninline int sch(int x) {\n  int l = 1, r = n, res;\n  while (l <= r) {\n    int mid = (l + r) >> 1;\n    if (a[mid] <= x) {\n      l = mid + 1;\n      res = mid;\n    } else\n      r = mid - 1;\n  }\n  return res;\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  std::sort(a + 1, a + n + 1);\n  int num = 0, tmp = 0;\n  for (int i = 1; i <= n; i++) {\n    if (a[i] != tmp || i == 1) num++;\n    tmp = a[i];\n    a[i] = num;\n  }\n  int len = 1 << std::min(8 * m / n, 30), ans = 0;\n  for (int i = 1; i <= n; i++) ans = std::max(ans, sch(a[i] + len - 1) - i + 1);\n  printf(\"%d\", n - ans);\n}\n"
        },
        {
            "language": 3,
            "solution": "n, I = [int(i) for i in input().split()]\na = sorted([int(i) for i in input().split()])\nb = []\nc_one_b=I*8//n\nk=2**c_one_b\nc=1\nfor i in range(n-1):\n    if a[i]!=a[i+1]:\n        b.append(c)\n        c=0\n    c+=1\nb.append(c)\ns=0\nmaxx=0\nln=len(b)\nfor j in range(min(k,ln)):\n    s+=b[j]\nmaxx=s\nfor i in range(min(ln,k),ln):\n    if s>maxx:\n        maxx=s\n    s-=b[i-k]\n    s+=b[i]\nprint(n-maxx)"
        },
        {
            "language": 1,
            "solution": "from collections import Counter\nMOD = 10**9 + 7\n####\n\ndef solve(N, SIZE, A):\n    count = Counter(A)\n    keys = sorted(count)\n\n    SIZE *= 8\n    SIZE /= N # ceil(log K) <= SIZE\n    distinct = 2 ** SIZE  # max number of distinct values\n\n    if len(keys) <= distinct:\n        return 0\n\n    slack = len(keys) - distinct\n    # eat slack i's from count that minimizes sum count[i]  \n    P = [0]\n    for k in keys:\n        P.append(P[-1] + count[k])\n    length = len(keys) - slack\n\n    # Want to maximize P[i+length] - P[i]\n    mi = float('inf')\n    ans = float('-inf')\n    for i in xrange(length, len(P)):\n        ans = max(ans, P[i] - P[i-length])\n    return P[-1] - ans\n    \n####\nrr = raw_input\nrri = lambda: int(raw_input())\nrrm = lambda: map(int, raw_input().split())\n\nN, SIZE = rrm()\nA = rrm()\nprint solve(N, SIZE, A)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double pie1 = 3.1415926;\nconst double pie2 = 3.14159265358979;\nconst double pie3 = 3.14159265358979323846;\nconst int vbi = 999999999;\nconst int vli = -vbi;\nconst long long vbl = 999999999999999999;\nconst long long vll = -vbl;\npriority_queue<int> pqi;\npriority_queue<long long> pql;\nqueue<int> qi;\nqueue<long long> ql;\nbool pss(int a) {\n  for (int i = 2; i <= sqrt(a); i++)\n    if (a % i == 0) return false;\n  return true;\n}\nvector<pair<int, int> > v;\nmap<int, int> mp;\nint mmp;\nint find_(int n, int I) {\n  int l = 0, r = I, m, ans = 0;\n  while (l <= r) {\n    m = (l + r) / 2;\n    int ok_ = n * ceil(log2(m));\n    if (ok_ > I)\n      r = m - 1;\n    else {\n      ans = m;\n      l = m + 1;\n    }\n  }\n  return ans;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  int n, I;\n  cin >> n >> I;\n  I *= 8;\n  for (int i = 1; i <= n; i++) {\n    int a;\n    cin >> a;\n    if (mp[a])\n      v[mp[a] - 1].second++;\n    else {\n      mmp++;\n      mp[a] = mmp;\n      v.push_back(make_pair(a, 1));\n    }\n  }\n  sort(v.begin(), v.end());\n  int maxx = 0;\n  maxx = find_(n, I);\n  if (maxx == 0) {\n    cout << 0;\n    return 0;\n  }\n  int sss = v.size();\n  int a[sss + 10];\n  a[0] = 0;\n  for (int i = 0; i < sss; i++) a[i + 1] = v[i].second;\n  for (int i = 2; i <= sss; i++) a[i] += a[i - 1];\n  int sum = a[sss], minx = vbi;\n  maxx = min(maxx, sss);\n  for (int i = 1; i <= sss - maxx + 1; i++) {\n    int l = i, r = i + maxx - 1;\n    int del_ = sum - (a[r] - a[l - 1]);\n    minx = min(minx, del_);\n  }\n  cout << minx;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\nn,I=map(int,input().split())\na=list(map(int,input().split()))\na.sort()\nI*=8\nk=1<<(I//n)\n \ndp=[1]\nfor i in range(1,n):\n    if a[i]==a[i-1]:\n        dp[-1]+=1\n    else:\n        dp.append(1)\n        \nif k>=len(dp):\n    print(0)\nelse:\n    \n    ans=sum(dp[:k])\n    ret=ans\n    for i in range(k,len(dp)):\n        ans+=dp[i]-dp[i-k]\n        \n        ret=max(ret,ans)\n    print(n-ret)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse4\")\nusing namespace std;\nconst long long N = 4e5 + 5, mod = 1e9 + 7;\nlong long n, x, k, ans = 0;\nlong long a[N], f[N], l[N];\nlong long pow2(long long t) {\n  if (t == 0) return 1 % mod;\n  if (t == 1) return 2 % mod;\n  long long mid = pow2(t / 2);\n  if (t % 2 == 0)\n    return mid * mid % mod;\n  else\n    return mid * mid * 2 % mod;\n}\nsigned main() {\n  cin >> n >> x;\n  x = x * 8 / n;\n  k = pow2(x);\n  for (long long i = 1; i <= n; i++) cin >> a[i];\n  sort(a + 1, a + n + 1);\n  f[0] = 1;\n  x = 0;\n  for (long long i = 2; i <= n + 1; i++) {\n    if (a[i] > a[i - 1] || i == n + 1) {\n      l[x] = i - 1;\n      x++;\n      f[x] = i;\n    }\n  }\n  k = min(k, x);\n  for (long long i = 0; i < x; i++)\n    ans = max(ans, l[min(x - 1, i + k - 1)] - f[i] + 1);\n  cout << n - ans;\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\nimport sys\nfrom collections import defaultdict,Counter,deque,OrderedDict\nimport bisect\n#sys.setrecursionlimit(1000000)\ninput = iter(sys.stdin.buffer.read().decode().splitlines()).__next__\nilele = lambda: map(int,input().split())\nalele = lambda: list(map(int, input().split()))\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\n#def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n#INF = 10 ** 18\n#MOD = 1000000000 + 7\nfrom itertools import accumulate,groupby\n\nn,I = ilele()\nA = alele()\ntot = I*8\nC = Counter(A)\n\"\"\"\ni =0;k = len(D);K =k\nz = n * math.ceil(math.log(k,2))\ncount =0\nwhile i< K and z>tot:\n    count += D[i]\n    i+=1;k-=1\n    z = n*math.ceil(math.log(k,2))\nprint(count)\n\"\"\"\nE = list(C.keys())\nE.sort()\n#print(E)\npre = [0]\nfor i in E:\n    pre.append(C[i] + pre[-1])\n#print(pre)\ni =0;j=0;c = len(E)\nwhile j < c:\n    z = n*math.ceil(math.log(j+1,2))\n    if z<= tot:\n        j+=1\n    else:\n        break\nAns = 1e9\n#print(j)\nif j == c:\n    print(0)\nelse:\n    while j <= c:\n        Ans = min(Ans,n - pre[j]  + pre[i])\n        i+=1;j+=1\n    print(Ans)\n    "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmap<int, int> Fr;\nint A[400005];\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int n, I;\n  cin >> n >> I;\n  I = I * 8;\n  int nrb = I / n;\n  if (nrb >= 30) {\n    cout << \"0\\n\";\n    return 0;\n  }\n  int nrdist = (1 << nrb);\n  for (int i = 1; i <= n; i++) {\n    int x;\n    cin >> x;\n    Fr[x]++;\n  }\n  int ind = 0;\n  for (auto el : Fr) {\n    A[++ind] = el.second;\n  }\n  for (int i = ind; i >= 0; i--) A[i] = A[i + 1] + A[i];\n  if (nrdist >= ind) {\n    cout << \"0\\n\";\n    return 0;\n  }\n  int rez = 1000000000;\n  int sum = 0;\n  for (int i = 1; i + nrdist - 1 <= n; i++) {\n    rez = min(rez, sum + A[i + nrdist]);\n    sum += (A[i] - A[i + 1]);\n  }\n  cout << rez << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long n, mem;\n  cin >> n >> mem;\n  mem = mem * 8;\n  set<long long> s;\n  map<long long, long long> m;\n  long long* arr = new long long[n];\n  for (long long i = 0; i < n; ++i) {\n    cin >> arr[i];\n    ++m[arr[i]];\n    s.insert(arr[i]);\n  }\n  double dif = s.size();\n  long long num = ceil(log2(dif));\n  if (num * n <= mem) {\n    cout << 0 << endl;\n    return 0;\n  }\n  long long allowed = mem / n;\n  long long K = 1LL << allowed;\n  vector<long long> v;\n  map<long long, long long>::iterator it = m.begin();\n  while (it != m.end()) {\n    v.push_back(it->second);\n    ++it;\n  }\n  long long cur = 0, tot = 0;\n  for (int i = 0; i < (int)(v.size()); i++) {\n    if (i < K) cur += v[i];\n    tot += v[i];\n  }\n  long long ans = tot - cur;\n  for (int i = 1; i < (int)(v.size()); i++) {\n    if (i + K - 1 >= (int)(v.size())) break;\n    cur -= v[i - 1];\n    cur += v[i + K - 1];\n    ans = min(ans, tot - cur);\n  }\n  cout << ans << \"\\n\";\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import Counter\n\nN, I = map(int, input().split())\ncounter = Counter(list(map(int, input().split())))\na = [v for k, v in sorted(counter.items())]\nbits = (I*8) // N\nif bits >= 30 or 2**bits >= len(a):\n    print(0)\n    exit()\n\nsound_range = 2**bits\nr = 0\nacc = 0\nfor i in range(sound_range):\n    acc += a[r]\n    r += 1\nans = acc\n\nfor lv, rv in zip(a, a[r:]):\n    acc += rv - lv\n    if acc > ans:\n        ans = acc\n\nprint(N-ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  int s;\n  cin >> n >> s;\n  long a[n];\n  long k = exp2(min(8 * s / n, 20));\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  sort(a, a + n);\n  vector<int> counts;\n  int last_num = -1;\n  for (int i = 0; i < n; i++) {\n    if (a[i] != last_num) {\n      counts.push_back(1);\n      last_num = a[i];\n    } else {\n      counts.back() += 1;\n    }\n  }\n  if (k > counts.size()) {\n    cout << 0 << endl;\n    return 0;\n  }\n  int sum = 0;\n  for (int i = 0; i < k; i++) {\n    sum += counts[i];\n  }\n  int best = sum;\n  for (int i = k; i < counts.size(); i++) {\n    sum += counts[i] - counts[i - k];\n    best = max(sum, best);\n  }\n  cout << n - best << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 4e5 + 5;\nint sum, n, m, I, a[N], suff[N], h;\npair<int, int> b[N];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cin >> n >> I;\n  I *= 8;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  sort(a + 1, a + n + 1);\n  for (int i = 1; i <= n; i++) {\n    if (a[i] != a[i - 1]) b[++m].first = a[i];\n    b[m].second++;\n  }\n  for (int i = m; i >= 1; i--) suff[i] = suff[i + 1] + b[i].second;\n  int k = I / n, t = 1;\n  for (int i = 1; i <= min(30, k); i++) t *= 2;\n  int ans = 1e9;\n  for (int i = 1; i <= m; i++) {\n    ans = min(ans, sum + suff[min(m + 1, i + t)]);\n    sum += b[i].second;\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1e9 + 7;\nlong long a[400002], I, n, K;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cin >> n >> I;\n  I *= 8;\n  for (long long i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  sort(a, a + n);\n  long long ans = n;\n  if (I / n > 50) {\n    cout << 0 << endl;\n    return 0;\n  }\n  K = (1ll << (I / n));\n  long long p = 0, br1 = 1;\n  for (long long i = 0; i < n; i++) {\n    if (i != 0 && a[i] != a[i - 1]) br1--;\n    if (br1 <= 0) br1 = 1;\n    if (p < i) p = i;\n    for (;; p++) {\n      if (p == n - 1 || (a[p + 1] != a[p] && br1 == K)) {\n        break;\n      }\n      if (a[p + 1] != a[p]) br1++;\n    }\n    ans = min(ans, n - (p - i + 1));\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int minn(long long int a, long long int b) {\n  if (a > b) return b;\n  return a;\n}\nlong long int maxx2(long long int a, long long int b) {\n  if (a > b) return a;\n  return b;\n}\nlong long int maxx(long long int a, long long int b, long long int c) {\n  return maxx2(a, maxx2(b, c));\n}\nlong long int gcdd(long long int a, long long int b) {\n  if (b == 0)\n    return a;\n  else\n    return gcdd(b, a % b);\n}\nlong long int dsum(long long int n) {\n  long long int sum = 0;\n  while (n > 0) {\n    sum += n % 10;\n    n /= 10;\n  }\n  return sum;\n}\nlong long int poww(long long int a, long long int b) {\n  if (b == 0) return 1;\n  if (b == 1)\n    return a;\n  else\n    return ((poww(a, b / 2) % 998244353) * (poww(a, b / 2) % 998244353) *\n            (poww(a, b % 2) % 998244353)) %\n           998244353;\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  long long int n, x;\n  cin >> n >> x;\n  long long int k = poww(2, (x * 8) / n);\n  long long int a[n];\n  set<long long int> s;\n  map<long long int, long long int> m;\n  for (long long int i = 0; i < n; i++) {\n    cin >> a[i];\n    s.insert(a[i]);\n    m[a[i]]++;\n  }\n  long long int pre[s.size()];\n  set<long long int>::iterator it;\n  long long int t = 0, sum = 0;\n  for (it = s.begin(); it != s.end(); it++) {\n    sum += m[*it];\n    pre[t] = sum;\n    t++;\n  }\n  if (k >= s.size()) {\n    cout << \"0\" << endl;\n    return 0;\n  }\n  long long int min = 1000000000000;\n  for (long long int i = 0; i < s.size() - k + 1; i++) {\n    long long int ans = pre[s.size() - 1] - pre[i + k - 1];\n    if (i > 0) {\n      ans += pre[i - 1];\n    }\n    if (ans < min) {\n      min = ans;\n    }\n  }\n  cout << min << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 10;\ninline int read() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') {\n      f = -1;\n    }\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = (x << 1) + (x << 3) + (ch ^ 48);\n    ch = getchar();\n  }\n  return x * f;\n}\nint n, I;\nint ans = 0X7fffffff;\nint b[N], a[N], cnt, num;\nint main() {\n  n = read(), I = read();\n  for (int i = 1; i <= n; i++) {\n    a[i] = read();\n  }\n  sort(a + 1, a + n + 1);\n  for (int i = 1; i <= n; i++) {\n    if (a[i] != a[i + 1]) {\n      num++;\n      b[++cnt] = num;\n      num = 0;\n    } else\n      num++;\n  }\n  int maxx = (8 * I / n);\n  if (log2(cnt) <= maxx) {\n    puts(\"0\");\n    return 0;\n  }\n  maxx = pow(2, maxx);\n  for (int i = 1; i <= cnt + maxx; i++) {\n    b[i] += b[i - 1];\n  }\n  for (int i = 1; i <= cnt; i++) {\n    ans = min(ans, b[i] + b[cnt] - b[i + maxx]);\n  }\n  printf(\"%d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class Contest1 {\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////                                                                                                               /////////\n////////                                                                                                               /////////\n////////   HHHH        HHHH  EEEEEEEEEEEEE   MMMM          MMMM         OOOOOO             SSSSSSS      EEEEEEEEEEEEE  /////////\n////////   HHHH        HHHH  EEEEEEEEEEEEE   MMMMMM      MMMMMM      OOO      OOO        SSSS   SSS     EEEEEEEEEEEEE  /////////\n////////   HHHH        HHHH  EEEEE           MMMM MMM  MMM MMMM    OOO          OOO    SSSS       SSS   EEEEE          /////////\n////////   HHHH        HHHH  EEEEE           MMMM  MMMMMM  MMMM   OOO            OOO   SSSS             EEEEE          /////////\n////////   HHHH        HHHH  EEEEE           MMMM          MMMM  OOO              OOO   SSSSSSS         EEEEE          /////////\n////////   HHHHHHHHHHHHHHHH  EEEEEEEEEEE     MMMM          MMMM  OOO              OOO      SSSSSS       EEEEEEEEEEE    /////////\n////////   HHHHHHHHHHHHHHHH  EEEEEEEEEEE     MMMM          MMMM  OOO              OOO         SSSSSSS   EEEEEEEEEEE    /////////\n////////   HHHH        HHHH  EEEEE           MMMM          MMMM   OOO            OOO              SSSS  EEEEE          /////////\n////////   HHHH        HHHH  EEEEE           MMMM          MMMM    OOO          OOO     SSS       SSSS  EEEEE          /////////\n////////   HHHH        HHHH  EEEEEEEEEEEEE   MMMM          MMMM      OOO      OOO        SSS    SSSS    EEEEEEEEEEEEE  /////////\n////////   HHHH        HHHH  EEEEEEEEEEEEE   MMMM          MMMM         OOOOOO             SSSSSSS      EEEEEEEEEEEEE  /////////\n////////                                                                                                               /////////\n////////                                                                                                               /////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        int n = sc.nextInt();\n        int I= sc.nextInt()*8;\n        int[]a= new int[n];\n        TreeMap<Integer,Integer>tm = new TreeMap<>();\n        for (int i =0;i<n;i++){\n            a[i]=sc.nextInt();\n            tm.put(a[i],tm.getOrDefault(a[i],0)+1);\n        }\n        long [] using = new long[tm.size()+1];\n        int m = tm.size();\n        int i =1;\n        while (!tm.isEmpty()){\n            using[i++]=tm.get(tm.firstKey());\n            tm.pollFirstEntry();\n        }\n        for (int j =1;j<=m;j++)using[j]+=using[j-1];\n        int lo=1;\n        int hi=m;\n        int ans =-1;\n        while (lo<=hi){\n            int mid= lo+hi >>1;\n            int cost=0;\n            while (1<<cost<mid)cost++;\n           // pw.println(mid+\" \"+cost);\n            if (1l*cost*n<=I){\n                ans=mid;\n                lo=mid+1;\n            }\n            else {\n                hi=mid-1;\n            }\n        }\n        //pw.println(Arrays.toString(using));\n        i=1;int j =ans;\n        long min=Integer.MAX_VALUE;\n        while (j<=m){\n            min=Math.min(min,using[m]-using[j]+using[i-1]);\n            j++;i++;\n        }\n        pw.println(min);\n        pw.flush();\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(FileReader r) {\n            br = new BufferedReader(r);\n        }\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            String x = next();\n            StringBuilder sb = new StringBuilder(\"0\");\n            double res = 0, f = 1;\n            boolean dec = false, neg = false;\n            int start = 0;\n            if (x.charAt(0) == '-') {\n                neg = true;\n                start++;\n            }\n            for (int i = start; i < x.length(); i++)\n                if (x.charAt(i) == '.') {\n                    res = Long.parseLong(sb.toString());\n                    sb = new StringBuilder(\"0\");\n                    dec = true;\n                } else {\n                    sb.append(x.charAt(i));\n                    if (dec)\n                        f *= 10;\n                }\n            res += Long.parseLong(sb.toString()) / f;\n            return res * (neg ? -1 : 1);\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n    }\n\n}\n"
        },
        {
            "language": 3,
            "solution": "#------------------------template--------------------------#\nimport os\nimport sys\nfrom math import *\nfrom collections import *\nfrom fractions import *\nfrom bisect import *\nfrom heapq import*\nfrom io import BytesIO, IOBase\ndef vsInput():\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nALPHA='abcdefghijklmnopqrstuvwxyz'\nM=998244353\nEPS=1e-6\ndef value():return tuple(map(int,input().split()))\ndef array():return [int(i) for i in input().split()]\ndef Int():return int(input())\ndef Str():return input()\ndef arrayS():return [i for i in input().split()]\n\n\n#-------------------------code---------------------------#\n# vsInput()\n\n\nn,I=value()\na=sorted(array())\nset_a=sorted(set(a))\nC=Counter(a)\n\nI*=8\nI//=n\nif(I>20):Ma=n\nelse:Ma=2**I\n\nhave=[]\n\nfor i in set_a:\n    have.append(C[i])\n\n\nneed=max(len(have)-Ma,0)\n\nans=sum(have[:need])\nind=len(have)-1\n\n# print(have,need)\n\ncur=ans\nfor i in range(need-1,-1,-1):\n    cur-=have[i]\n    cur+=have[ind]\n    ind-=1\n\n    ans=min(ans,cur)\n\nprint(ans)\n\n    \n\n        \n\n\n\n\n\n\n\n        \n\n\n\n\n\n\n        \n\n\n\n\n\n\n\n    \n        \n            \n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, I;\nmap<int, int> mp;\nbool cal(int x) {\n  int c = 0, d = 0;\n  while (x) {\n    d += 1;\n    c += x & 1;\n    x >>= 1;\n  }\n  int bits = d;\n  if (c == 1) bits -= 1;\n  return bits * n <= 8 * I;\n}\nint solve(int l, int r) {\n  while (l + 1 < r) {\n    int mid = (l + r) / 2;\n    if (cal(mid))\n      l = mid;\n    else\n      r = mid;\n  }\n  if (cal(r))\n    return r;\n  else\n    return l;\n}\nint main() {\n  scanf(\"%d%d\", &n, &I);\n  for (int i = 0; i < n; i++) {\n    int w;\n    scanf(\"%d\", &w);\n    mp[w] += 1;\n  }\n  vector<int> a, b, c;\n  for (auto iter : mp) {\n    a.push_back(iter.first);\n    b.push_back(iter.second);\n    c.push_back(iter.second);\n  }\n  int m = a.size();\n  for (int i = 1; i < m; i++) {\n    c[i] += c[i - 1];\n  }\n  int k = solve(0, m);\n  int minn = n;\n  if (k < m) {\n    for (int i = 0; i + k <= m; i++) {\n      int p = 0;\n      if (i > 0) p = -c[i - 1];\n      p += c[i + k - 1];\n      minn = min(minn, n - p);\n    }\n  } else {\n    minn = 0;\n  }\n  printf(\"%d\\n\", minn);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1000100;\nint n, m;\nint a[N], b[N], ls[N], rs[N], tmp, I, Log[N];\nvector<long long> v;\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  function<int(long long)> ck = [&](long long first) -> int {};\n  function<int(long long)> cal = [&](long long first) -> int {};\n  for (int i = (1); i <= (400000); ++i) {\n    for (int j = (0); j <= (22); ++j)\n      if ((1 << j) >= i) {\n        Log[i] = j;\n        break;\n      }\n  }\n  cin >> n >> I;\n  for (int i = (1); i <= (n); ++i) {\n    cin >> tmp;\n    v.push_back(tmp);\n  }\n  sort(v.begin(), v.end());\n  int cc = 0;\n  for (int i = (0); i <= (n - 1); ++i) {\n    if (!cc || a[cc] != v[i])\n      a[++cc] = v[i], b[cc] = 1;\n    else\n      ++b[cc];\n  }\n  I <<= 3ll;\n  long long K = cc;\n  long long k = Log[K];\n  int l = 1, r = K;\n  int ans = (~0U >> 2), num = 0;\n  while (1ll * n * k > I) ++num, k = Log[K - num];\n  ls[0] = 0;\n  for (int i = (1); i <= (K); ++i) ls[i] = ls[i - 1] + b[i];\n  rs[K + 1] = 0;\n  for (int i = (K); i >= (1); --i) rs[i] = rs[i + 1] + b[i];\n  for (int i = (0); i <= (num); ++i)\n    ans = min(ans, ls[i] + rs[K - (num - i) + 1]);\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import Counter\nfrom operator import itemgetter\n\nN, I = map(int, input().split())\ncounter = Counter(list(map(int, input().split())))\na = list(map(itemgetter(1), sorted(counter.items())))\nbits = (I*8) // N\nif bits >= 30 or 2**bits >= len(a):\n    print(0)\n    exit()\n\nsound_range = 2**bits\nr = 0\nacc = 0\nfor i in range(sound_range):\n    acc += a[r]\n    r += 1\nans = acc\n\nfor lv, rv in zip(a, a[r:]):\n    acc += rv - lv\n    if acc > ans:\n        ans = acc\n\nprint(N-ans)\n"
        },
        {
            "language": 3,
            "solution": "n, I = map(int, input().split())\na = list(map(int, input().split()))\n\nb = I * 8 // n\nc = 2 ** b\n\na.sort()\nd = {}\nfor i in range(n):\n    if a[i] in d:\n        a[i] = d[a[i]]\n    else:\n        d[a[i]] = len(d)\n        a[i] = d[a[i]]\n\nl, r = 0, 0\nans = n\nwhile l < len(a):\n    while r < len(a) and a[r] - a[l] + 1 <= c:\n        r += 1\n    ans = min(ans, n - (r - l))\n    l += 1\n\nprint(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nmap<int, int> num;\nvector<int> a;\nint main() {\n  int i;\n  scanf(\"%d%d\", &n, &k);\n  k = 1 << (min(30, k * 8 / n));\n  for (i = 0; i < n; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    num[x]++;\n  }\n  a.push_back(0);\n  for (auto p : num) {\n    a.push_back(p.second);\n  }\n  for (i = 1; i < a.size(); i++) a[i] += a[i - 1];\n  k = min(k, (int)a.size() - 1);\n  int ans = 0;\n  for (i = k; i < a.size(); i++) ans = max(ans, a[i] - a[i - k]);\n  printf(\"%d\", n - ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint prefix[400009], suffix[400009], arr[400009];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int n, i;\n  cin >> n >> i;\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i];\n  }\n  sort(arr, arr + n);\n  vector<pair<int, int> > v;\n  for (int i = 0; i < n;) {\n    int j = i, cnt = 0;\n    while (j < n) {\n      if (arr[j] == arr[i]) {\n        cnt++;\n        j++;\n      } else {\n        break;\n      }\n    }\n    v.push_back(make_pair(arr[i], cnt));\n    i = j;\n  }\n  int m = (int)v.size();\n  for (int i = 0; i < m; i++) {\n    if (i == 0) {\n      prefix[i] = v[i].second;\n    } else {\n      prefix[i] = prefix[i - 1] + v[i].second;\n    }\n  }\n  for (int i = m - 1; i >= 0; i--) {\n    if (i == m - 1) {\n      suffix[i] = v[i].second;\n    } else {\n      suffix[i] = suffix[i + 1] + v[i].second;\n    }\n  }\n  i = 8 * i;\n  if ((i / n) >= 19) {\n    cout << \"0\" << endl;\n  } else {\n    int val = i / n;\n    val = (1 << val);\n    if (val >= m) {\n      cout << \"0\" << endl;\n    } else {\n      int ans = n;\n      int i = 0, j = val - 1;\n      while (j < m) {\n        int res = 0;\n        if (i > 0) {\n          res += (prefix[i - 1]);\n        }\n        if (j < m - 1) {\n          res += (suffix[j + 1]);\n        }\n        ans = min(ans, res);\n        j++;\n        i++;\n      }\n      cout << ans << endl;\n    }\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "#########################################################################################################\n#########################################################################################################\n###################################The_Apurv_Rathore#####################################################\n#########################################################################################################\n#########################################################################################################\n\nimport sys\nimport os\nimport io\nfrom math import log, gcd, ceil\nfrom collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop\n\n\nimport math\n\n\ndef primeFactors(n):\n    l = []\n    while n % 2 == 0:\n        l.append(2)\n        n = n / 2\n\n    for i in range(3, int(math.sqrt(n))+1, 2):\n\n        while n % i == 0:\n            l.append(int(i))\n            n = n / i\n    if n > 2:\n        l.append(n)\n    return list(set(l))\n\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    if (x == 0):\n        return 0\n    while (y > 0):\n        if ((y & 1) == 1):\n            res = (res * x) % p\n        y = y >> 1\t # y = y/2\n        x = (x * x) % p\n    return res\n\n\ndef si():\n    return input()\n\n# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n\ndef prefix_sum(arr):\n    r = [0] * (len(arr)+1)\n    for i, el in enumerate(arr):\n        r[i+1] = r[i] + el\n    return r\n\n\ndef divideCeil(n, x):\n    if (n % x == 0):\n        return n//x\n    return n//x+1\n\n\ndef ii():\n    return int(input())\n\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n                      p - 2, p)) % p\n\n\ndef li():\n    return list(map(int, input().split()))\n\n\n# t = int(input())\nt = 1\nfor _ in range(t):\n    n,I = li()\n    l = li()\n    k = 2**(min((8*I)//n,20))\n    dic = defaultdict(lambda:0)\n    for i in l:\n        dic[i]+=1\n    \n    if (len(list(set(l)))<=k):\n        print(0)\n    else:\n        # print(k)\n        ans= 0\n        temp = [0]\n        l.sort()\n        for i in range(1,n):\n            if (l[i]!=l[i-1]):\n                temp.append(i)\n        for i in range(len(temp)-k):\n            ans = max(ans , temp[i+k]-temp[i])\n        print(n - ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main(void) {\n  int n, I;\n  cin >> n >> I;\n  map<int, int> ns;\n  for (int i = 0, x; i < n; i++) {\n    scanf(\"%d\", &x);\n    ns[x]++;\n  }\n  int K = n, k = I * 8 / n;\n  if (k < 20) K = 1 << k;\n  int tmp = 0, ans = 0;\n  map<int, int>::iterator last = ns.begin();\n  for (auto i : ns) {\n    if (K) {\n      K--;\n      tmp += i.second;\n      ans += i.second;\n      continue;\n    }\n    tmp = tmp - (*last).second + i.second;\n    ans = max(ans, tmp);\n    last++;\n  }\n  cout << n - ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint wait;\nconst double pi =\n    3.14159265358979323846264338327950288419716939937510582097494459;\nconst double EPS = 1e-12;\nconst int MAXN = 1e5 + 10;\nconst long long MOD = 1e9 + 7;\nconst long long Mod = 1e9 + 7;\nconst long long mod = 1e9 + 7;\nconst int MAX = 5e6 + 5;\nconst int oo = 2e9 + 10;\nconst long long OO = 1e18;\nconst int N = 2e5 + 5;\nconst int logN = (int)(log2(N));\nint dx[] = {0, 1, 0, -1, -1, -1, 1, 1};\nint dy[] = {1, 0, -1, 0, -1, 1, -1, 1};\nlong long gcd(long long a, long long b) { return (b == 0 ? a : gcd(b, a % b)); }\nlong long lcm(long long a, long long b) { return ((a * b) / gcd(a, b)); }\nlong long arr[6 * N];\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  long long n, I;\n  cin >> n >> I;\n  for (int i = 0; i < n; i++) cin >> arr[i];\n  long long bits = 8LL * I / n;\n  map<long long, long long> freq;\n  for (int i = 0; i < n; i++) freq[arr[i]]++;\n  vector<pair<long long, long long> > vec;\n  for (auto x : freq) vec.push_back({x.first, x.second});\n  if (n * (long long)ceil(log2(vec.size())) <= 8LL * I) {\n    cout << 0 << endl;\n    return 0;\n  }\n  long long K = (1 << bits);\n  long long ans = OO;\n  long long cnt = 0;\n  for (int i = 0; i < K; i++) cnt += vec[i].second;\n  for (int i = 0; i < vec.size(); i++) {\n    ans = min(n - cnt, ans);\n    cnt -= vec[i].second;\n    if (i + K < vec.size()) cnt += vec[i + K].second;\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nn, I = [int(i) for i in input().split()]\n\n\n\nnum = 1 << ((8*I)//n)\ndata = [int(i) for i in input().split()]\n#data.sort()\n#am = len(set(data)) \ndic = {}\nfor d in data:\n    if d in dic:\n        dic[d] += 1\n    else:\n        dic[d] = 1\n\n\nif 8 *I < n:\n    #print(1+'1')\n    print(n - max(dic.values()))\n    sys.exit()\n\n\nvals = list(dic.keys())\nvals.sort()\nam = len(vals)\nif am <= num:\n    print(0)\n    sys.exit() \n\nsumto = [dic[vals[0]]]\nfor i in range(1, am):\n    sumto.append(sumto[-1] + dic[vals[i]])\n\n# print(vals)\n# print(sumto)\n\n# print(num, \"###\")\nkept = sumto[num-1]\n#print(0, kept)\nfor i in range(am - num):\n    \n    kept2 = sumto[i + num] - sumto[i]\n    #print(i+1, kept2)\n    if kept2 > kept:\n        kept = kept2\n\n\nprint(n-kept)\n\n\n# lind = 0\n# rind = am - 1\n# ans = 0\n# # print(dic)\n# # print(vals)\n# # print(am, num)\n# while am > num:\n#     if dic[vals[lind]] < dic[vals[rind]]:\n        \n#         ans += dic[vals[lind]]\n#         lind += 1\n#     else:\n#         ans += dic[vals[rind]]\n#         rind -= 1\n#     am -= 1\n#print(ans)"
        },
        {
            "language": 4,
            "solution": "import java.io.File;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class p015 {\n\tpublic static void main(String args[]) throws Exception {\n\t\tStringTokenizer stok = new StringTokenizer(new Scanner(System.in).useDelimiter(\"\\\\A\").next());\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint n = Integer.parseInt(stok.nextToken());\n\t\tint I = (Integer.parseInt(stok.nextToken())*8)/n;\n\t\tInteger[] a = new Integer[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = Integer.parseInt(stok.nextToken());\n\t\t}\n\t\tArrays.sort(a);\n\t\tint[] b = new int[n];\n\t\tint cnt=0;\n\t\tint i=0;\n\t\twhile(i<n) {\n\t\t\tb[i]=cnt;\n\t\t\twhile(++i<n&&a[i].intValue()==a[i-1].intValue())b[i]=cnt;\n\t\t\tcnt++;\n\t\t}\n\t\tcnt=0;int v = b[n-1];\n\t\tfor(;v>0;cnt++,v>>=1);\n\t\tif(cnt<=I) System.out.println(\"0\");\n\t\telse {\n\t\t\ti=0;\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\twhile(i<n) {\n\t\t\t\tint lo=i,hi=n;\n\t\t\t\twhile(lo!=hi) {\n\t\t\t\t\tint md = (lo+hi)/2;\n\t\t\t\t\tif(b[md]<b[i]+(1<<I)) lo=md+1;else hi=md;\n\t\t\t\t}\n\t\t\t\tmin = Math.min(min, i+n-lo);\n\t\t\t\twhile(++i<n&&a[i]==a[i-1]);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\t\n}"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.HashSet;\nimport java.util.Arrays; \nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.text.DecimalFormat;\nimport java.lang.Math;\nimport java.util.Iterator; \nimport java.util.TreeSet;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigDecimal;\nimport java.util.*;\npublic class D1343{\n\tpublic static PrintWriter out = new PrintWriter (new BufferedOutputStream(System.out));\n\tstatic long MOD = (long)(1e9+7);\n\tstatic FastReader sc = new FastReader();\n\tstatic int pInf = Integer.MAX_VALUE;\n\tstatic int nInf = Integer.MIN_VALUE;\n\tpublic static void main(String[] args){\n\t\tint test = 1;\n\t\t//test = sc.nextInt();\n\t\twhile(test-->0){\n\t\t    int n = sc.nextInt();\n\t\t    int k = sc.nextInt();\n\t\t    k = k*8/n;\n\t\t    k = (int)Math.pow(2,Math.min(20,k));\n\t\t    TreeMap<Integer,Integer> A = new TreeMap<Integer,Integer>();\n\t\t    for(int i = 0; i < n; i++){\n\t\t        int x = sc.nextInt();\n\t\t        A.put(x,A.getOrDefault(x,0)+1);\n\t\t    }\n\t\t    if(k>=A.size()){\n\t\t        out.println(0);\n\t\t        continue;\n\t\t    } \n\t\t    int[] sum = new int[A.size()+1];\n\t\t    int h = 1;\n\t\t    for(int g : A.keySet()){\n\t\t        sum[h] = A.get(g)+sum[h-1];\n\t\t        h++;\n\t\t    }\n\t\t    int max = nInf;\n\t\t    for(int i = 0; i < A.size()-k+1; i++){\n\t\t        int curr = sum[i+k]-sum[i];\n\t\t        max = Math.max(max,curr);\n\t\t    }\n\t\t    out.println(n-max);\n\t\t}\n\t\tout.close();\n\t}\n\tpublic static long mul(long a, long b){\n\t    return ((a%MOD)*(b%MOD))%MOD;\n\t}\n\tpublic static long add(long a, long b){\n\t    return ((a%MOD)+(b%MOD))%MOD;\n\t}\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Integer.lowestOneBit(i)   Equals k where k is the position of the first one in the binary\n//Integer.highestOneBit(i)  Equals k where k is the position of the last one in the binary\n//Integer.bitCount(i)       returns the number of one-bits\n//Collections.sort(A,(p1,p2)->(int)(p2.x-p1.x)) To sort ArrayList in descending order wrt values of x.\n//            Arrays.parallelSort(a,new Comparator<TPair>() {\n//      \t\tpublic int compare(TPair a,TPair b) {\n//        \t\t\tif(a.y==b.y) return a.x-b.x;\n//        \t\t\treturn b.y-a.y;\n//        \t\t}\n//        \t});\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//PrimeFactors    \n    public static ArrayList<Long> primeFactors(long n) {\n        ArrayList<Long> arr = new ArrayList<>();\n        if (n % 2 == 0)\n            arr.add((long) 2);\n        while (n % 2 == 0)\n            n /= 2;\n        for (long i = 3; i <= Math.sqrt(n); i += 2) {\n            int flag = 0;\n            while (n % i == 0) {\n                n /= i;\n                flag = 1;\n            }\n            if (flag == 1)\n                arr.add(i);\n        }\n        if (n > 2)\n            arr.add(n);\n        return arr;\n    }\n//Pair Class\n\tstatic class Pair implements Comparable<Pair>{\n\t\tint x;\n\t\tint y;\n\t\tpublic Pair(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif(this.x==o.x){\n\t\t\t    return (this.y-o.y);\n\t\t\t}\n\t\t\treturn (this.x-o.x);\n\t\t}\n\t}\n\tstatic class TPair{\n\t\tint x;\n\t\tint y;\n\t\tint z;\n\t\tpublic TPair(int x, int y, int z) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t}\n\t}\n//Merge Sort\n\tstatic void merge(long arr[], int l, int m, int r)\n    {\n        // Find sizes of two subarrays to be merged\n        int n1 = m - l + 1;\n        int n2 = r - m;\n \n        /* Create temp arrays */\n        long L[] = new long [n1];\n        long R[] = new long [n2];\n \n        /*Copy data to temp arrays*/\n        for (int i=0; i<n1; ++i)\n            L[i] = arr[l + i];\n        for (int j=0; j<n2; ++j)\n            R[j] = arr[m + 1+ j];\n \n \n        /* Merge the temp arrays */\n \n        // Initial indexes of first and second subarrays\n        int i = 0, j = 0;\n \n        // Initial index of merged subarry array\n        int k = l;\n        while (i < n1 && j < n2)\n        {\n            if (L[i] <= R[j])\n            {\n                arr[k] = L[i];\n                i++;\n            }\n            else\n            {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n \n        /* Copy remaining elements of L[] if any */\n        while (i < n1)\n        {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n \n        /* Copy remaining elements of R[] if any */\n        while (j < n2)\n        {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n \n    // Main function that sorts arr[l..r] using\n    // merge()\n    static void sort(long arr[], int l, int r)\n    {\n        if (l < r)\n        {\n            // Find the middle point\n            int m = (l+r)/2;\n \n            // Sort first and second halves\n            sort(arr, l, m);\n            sort(arr , m+1, r);\n \n            // Merge the sorted halves\n            merge(arr, l, m, r);\n        }\n    }\n//Brian Kernighan\u2019s Algorithm\n    static long countSetBits(long n){\n        if(n==0) return 0;\n        return 1+countSetBits(n&(n-1));\n    }\n//Factorial\n    static long factorial(long n){\n        if(n==1) return 1;\n        if(n==2) return 2;\n        if(n==3) return 6;\n        return n*factorial(n-1);\n    }\n//Euclidean Algorithm\n    static long gcd(long A,long B){\n        if(B==0) return A;\n        return gcd(B,A%B);\n    }\n//Modular Exponentiation\n    static long fastExpo(long x,long n){\n        if(n==0) return 1;\n        if((n&1)==0) return fastExpo((x*x)%MOD,n/2)%MOD;\n        return ((x%MOD)*fastExpo((x*x)%MOD,(n-1)/2))%MOD;\n    }\n//AKS Algorithm\n    static boolean isPrime(long n){\n        if(n<=1) return false;\n        if(n<=3) return true;\n        if(n%2==0 || n%3==0) return false;\n        for(int i=5;i<=Math.sqrt(n);i+=6)\n            if(n%i==0 || n%(i+2)==0) return false;\n        return true;\n    }\n//Reverse an array\n    static <T> void reverse(T arr[],int l,int r){\n    \tCollections.reverse(Arrays.asList(arr).subList(l, r));\n    }\n//Sieve of eratosthenes\n    static int[] findPrimes(int n){\n        boolean isPrime[]=new boolean[n+1];\n        ArrayList<Integer> a=new ArrayList<>();\n        int result[];\n        Arrays.fill(isPrime,true);\n        isPrime[0]=false;\n        isPrime[1]=false;\n        for(int i=2;i*i<=n;++i){\n            if(isPrime[i]==true){\n                for(int j=i*i;j<=n;j+=i) isPrime[j]=false;\n            }\n        }\n        for(int i=0;i<=n;i++) if(isPrime[i]==true) a.add(i);\n        result=new int[a.size()];\n        for(int i=0;i<a.size();i++) result[i]=a.get(i);\n        return result;\n        \n    }\n//Euler Totent function\n    static long countCoprimes(long n){\n        ArrayList<Long> prime_factors=new ArrayList<>();\n        long x=n,flag=0;\n        while(x%2==0){\n            if(flag==0) prime_factors.add(2L);\n            flag=1;\n            x/=2;\n        }\n        for(long i=3;i*i<=x;i+=2){\n            flag=0;\n            while(x%i==0){\n                if(flag==0) prime_factors.add(i);\n                flag=1;\n                x/=i;\n            }\n        }\n        if(x>2) prime_factors.add(x);\n        double ans=(double)n;\n        for(Long p:prime_factors){\n            ans*=(1.0-(Double)1.0/p);\n        }\n        return (long)ans;\n    }\n\tstatic long modulo = (long)1e9+7;\n\tpublic static long modinv(long x){\n\t    return modpow(x, modulo-2);\n\t}\n\tpublic static long modpow(long a, long b){\n\t    if(b==0){\n\t        return 1;\n\t    }\n\t    long x = modpow(a, b/2);\n\t    x = (x*x)%modulo;\n\t    if(b%2==1){\n\t        return (x*a)%modulo;\n\t    }\n\t    return x;\n\t}\n\tpublic static class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\t//it reads the data about the specified point and divide the data about it ,it is quite fast\n\t\t//than using direct \n\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (Exception r) {\n\t\t\t\t\tr.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());//converts string to integer\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (Exception r) {\n\t\t\t\tr.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n}"
        },
        {
            "language": 1,
            "solution": "from collections import defaultdict\nimport operator\nimport math\n \nimport atexit, io, sys\ndef main():\n    buffer = io.BytesIO() \n    sys.stdout = buffer\n \n    @atexit.register \n    def write(): \n        sys.__stdout__.write(buffer.getvalue())\n    n,I=map(int,raw_input().split())\n    l=map(int,raw_input().split())\n    d = defaultdict(int)\n    for i in l:\n        d[i] += 1\n    p=len(d)\n    if n*(int(math.ceil((math.log(p,2)))))<=I*8:\n        print(0)\n        exit()\n    count=0\n    k=int(math.floor((I*8)/float(n)))\n    x = sorted(d.items(), key=operator.itemgetter(0))\n    #print x,p,k\n    for i in xrange(2**k):\n        count+=x[i][1]\n    high=count\n    for i in xrange(2**k,p):\n        high=high+x[i][1]-x[i-2**k][1]\n        count=max(count,high)\n    print(n-count)\nif __name__ == '__main__':\n    main()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 4e5 + 10;\nlong long a[maxn];\nlong long Cnt[maxn];\nmap<int, int> mm;\nint main() {\n  long long n, I;\n  scanf(\"%lld %lld\", &n, &I);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%lld\", a + i);\n    mm[a[i]]++;\n  }\n  sort(a, a + n);\n  long long g = 0;\n  map<int, int>::iterator it = mm.begin();\n  for (; it != mm.end(); it++) {\n    Cnt[g++] = it->second;\n  }\n  if (((8 * I / n) > 18)) return puts(\"0\"), 0;\n  long long k = min(1ll << (8 * I / n), n);\n  if (k >= g) return puts(\"0\"), 0;\n  long long ans, sum = 0;\n  for (int i = 0; i < k; i++) {\n    sum += Cnt[i];\n  }\n  ans = sum;\n  for (int i = k; i < g; i++) {\n    sum += Cnt[i];\n    sum -= Cnt[i - k];\n    ans = max(ans, sum);\n  }\n  printf(\"%lld\\n\", n - ans);\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "import math\nn,i=map(int,raw_input().split())\narr=map(int,raw_input().split())\nd={}\nfor j in arr:\n    d[j]=d.get(j,0)+1\narr=list(set(arr))\narr.sort()\nK=len(arr)\nk=math.ceil(math.log(K,2))\nKreq=2**((8*i)/n)\nif Kreq>=K:\n    print 0\nelse:\n    delele=K-Kreq\n    ans=0\n    ps=[0]\n    ss=[0]\n    for i in range(K):\n        ps.append(ps[-1]+d[arr[i]])\n        ss.append(ss[-1]+d[arr[-1-i]])\n    mini=999999999999\n    for i in range(delele+1):\n        mini=min(mini,ps[delele-i]+ss[i])\n    print mini\n        \n"
        },
        {
            "language": 3,
            "solution": "import sys\ninput = sys.stdin.readline\nn, I = [int(item) for item in input().split()]\na = [int(item) for item in input().split()]\n \nbits = I * 8\nbps = bits // n\ndrange = 2**bps - 1\n \na.sort()\na_comp = []\nitr = 0\nfor i, item in enumerate(a):\n    if i == 0:\n        prev = item\n        a_comp.append(itr)\n        continue\n    if item == prev:\n        a_comp.append(itr)\n    else:\n        itr += 1\n        prev = item\n        a_comp.append(itr)\na = a_comp\n    \nl = 0; r = 0\nans = 0\nwhile r < n:\n    if a[r] - a[l] <= drange:\n        r += 1\n        ans = max(ans, r - l)\n    else:\n        l += 1\nprint(n - ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int pwr(long long int x, long long int y) {\n  long long int res = 1;\n  while (y > 0) {\n    if (y & 1) {\n      res = res * x;\n    }\n    y = y >> 1;\n    x = x * x;\n  }\n  return res;\n}\nlong long int mpwr(long long int x, long long int y, long long int p) {\n  long long int res = 1;\n  x = x % p;\n  while (y > 0) {\n    if (y & 1) {\n      res = (res * x) % p;\n    }\n    y = y >> 1;\n    x = (x * x) % p;\n  }\n  return res;\n}\nvoid prime1(long long int n, vector<long long int>& a) {\n  long long int i, j;\n  vector<bool> mark(n, false);\n  for (i = 2; i * i < n; i++) {\n    if (mark[i] == false) {\n      for (j = 2 * i; j < n; j += i) {\n        mark[j] = true;\n      }\n    }\n  }\n  for (i = 2; i < n; i++) {\n    if (mark[i] == false) {\n      a.push_back(i);\n    }\n  }\n}\nvoid prime(long long int n, vector<long long int>& a) {\n  long long int i, j, low, high,\n      limit = ((long long int)sqrt(n)) + (long long int)1;\n  prime1(limit, a);\n  low = limit;\n  high = 2 * limit;\n  while (low < n) {\n    if (high >= n) {\n      high = n;\n    }\n    bool mark[limit + 1];\n    memset(mark, true, sizeof(mark));\n    for (i = 0; i < a.size(); i++) {\n      long long int lolimit = (low / a[i]) * a[i];\n      if (lolimit < low) {\n        lolimit += a[i];\n      }\n      for (j = lolimit; j < high; j += a[i]) {\n        mark[j - low] = false;\n      }\n    }\n    for (j = low; j < high; j++) {\n      if (mark[j - low] == true) {\n        a.push_back(j);\n      }\n    }\n    low += limit;\n    high += limit;\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(0), cin.tie(NULL), cout.tie(NULL);\n  long long int c, sum = 0, temp, n, k, i, ans, cnt = 0;\n  cin >> n >> k;\n  if ((8 * k) / n >= 20) {\n    cout << 0;\n    return 0;\n  }\n  k = (long long int)pow(2, (8 * k) / n);\n  long long int a[n];\n  vector<pair<long long int, long long int> > b;\n  for (i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  sort(a, a + n);\n  temp = a[0];\n  for (i = 0; i < n; i++) {\n    if (temp == a[i]) {\n      cnt++;\n    } else {\n      b.push_back({temp, cnt});\n      temp = a[i];\n      cnt = 1;\n    }\n  }\n  b.push_back({temp, cnt});\n  sort(b.begin(), b.end());\n  for (i = 0; i < k && i < b.size(); i++) {\n    sum += b[i].second;\n  }\n  ans = sum;\n  for (i = k; i < b.size(); i++) {\n    sum += b[i].second - b[i - k].second;\n    ans = max(sum, ans);\n  }\n  cout << n - ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[1000006];\npair<int, int> b[1000006];\nint s1[1000006], s2[1000006];\nint fpw(int x, int y) {\n  int ans = 1;\n  for (int i = 1; i <= y; i <<= 1, x *= x)\n    if (y & i) ans *= x;\n  return ans;\n}\nint main() {\n  int n, I;\n  cin >> n >> I;\n  int len = fpw(2, min(30, 8 * I / n));\n  for (int i = 1; i <= n; ++i) cin >> a[i];\n  sort(a + 1, a + 1 + n);\n  int m = 0;\n  for (int i = 1; i <= n; ++i)\n    if (i == 1 || a[i] != a[i - 1])\n      b[++m] = make_pair(a[i], 1);\n    else\n      ++b[m].second;\n  for (int i = 1; i <= m; ++i) s1[i] = s1[i - 1] + b[i].second;\n  for (int i = m; i; --i) s2[i] = s2[i + 1] + b[i].second;\n  int ans = n;\n  for (int i = 1; i <= m; ++i)\n    ans = min(ans, s1[i - 1] + s2[min(i + len, m + 1)]);\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, I;\n  cin >> n >> I;\n  vector<int> a(n);\n  for (auto& x : a) cin >> x;\n  map<int, int> M;\n  for (auto x : a) ++M[x];\n  int K = M.size();\n  for (; K >= 1; --K)\n    if (n * (int)ceil(log2(K)) <= I * 8) break;\n  vector<int> v(M.size());\n  int i = 0;\n  for (auto& p : M) v[i++] = p.second;\n  vector<int> psum(v.size() + 1);\n  partial_sum(v.begin(), v.end(), psum.begin() + 1);\n  int ans = n;\n  for (int i = 0; i <= v.size() - K; ++i)\n    ans = min(ans, psum[i] - psum[0] + psum[v.size()] - psum[i + K]);\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "R=lambda:map(int,input().split())\nn,I=R()\na=-1,*sorted(R())\nb=[i for i in range(n)if a[i]<a[i+1]]\nprint(n-max(y-x for x,y in zip(b,b[1<<8*I//n:]+[n])))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename S, typename T>\nostream& operator<<(ostream& out, pair<S, T> const& p) {\n  out << '(' << p.first << \", \" << p.second << ')';\n  return out;\n}\ntemplate <typename T>\nostream& operator<<(ostream& out, vector<T> const& v) {\n  long long l = v.size();\n  for (long long i = 0; i < l - 1; i++) out << v[i] << ' ';\n  if (l > 0) out << v[l - 1];\n  return out;\n}\nint n, I;\nvector<int> arr;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ;\n  cin >> n >> I;\n  arr.resize(n);\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i];\n  }\n  int k = (8 * I) / n;\n  if (k > 19) {\n    cout << \"0\\n\";\n    return 0;\n  }\n  long long K = pow(2, k);\n  if (K >= n) {\n    cout << \"0\\n\";\n    return 0;\n  }\n  sort(arr.begin(), arr.end());\n  int l = 0, r = 0;\n  int ans = n;\n  map<int, int> umap;\n  umap[arr[0]] = 0;\n  while (l <= r) {\n    r++;\n    if (r == n) {\n      break;\n    }\n    if (umap.find(arr[r]) != umap.end()) {\n      umap[arr[r]] = r;\n      ans = min(ans, n - (r - l + 1));\n      continue;\n    }\n    if (umap.size() < K) {\n      umap[arr[r]] = r;\n      ans = min(ans, n - (r - l + 1));\n      continue;\n    }\n    int new_l = umap[arr[l]] + 1;\n    umap.erase(arr[l]);\n    umap[arr[r]] = r;\n    l = new_l;\n    ans = min(ans, n - (r - l + 1));\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;import java.io.*;import java.math.*;\n \npublic class Main\n{\n    public static void process()throws IOException\n    {\n        int n=ni(),I=ni(),arr[]=new int[n+1];\n        for(int i=1;i<=n;i++) arr[i]=ni();\n \n        double k=8.0d*I/(n*1.0d);\n \n        int K=1;\n \n        for(int i=1;i<=4*1e5;i++){\n            double x=(Math.log(i)/Math.log(2.0d));\n            x=Math.ceil(x);\n            if(x<=k)\n                K=i;\n        }\n        if(K>=n){\n            pn(0);\n            return;\n        }\n        TreeMap<Integer,Integer> map=new TreeMap<Integer,Integer>();\n \n        for(int i=1;i<=n;i++){\n            if(!map.containsKey(arr[i]))\n                map.put(arr[i],0);\n            map.put(arr[i],map.get(arr[i])+1);\n        }\n \n        long f[]=new long[n+1];\n        int idx=1;\n        for (Map.Entry<Integer,Integer> entry : map.entrySet()){\n            f[idx++]=entry.getValue();\n        }  \n \n        long pre[]=new long[n+2],suff[]=new long[n+2];\n \n        long chng=Long.MAX_VALUE;\n \n        for(int i=1;i<=n;i++) pre[i]=pre[i-1]+f[i];\n        for(int i=n;i>=1;i--) suff[i]=suff[i+1]+f[i];\n \n        for(int i=1;(i+K)<=n;i++){\n            chng=Math.min(chng, pre[i-1]+suff[i+K]);\n        }\n        pn(chng);\n    }\n \n \n    static AnotherReader sc;\n    static PrintWriter out;\n    public static void main(String[]args)throws IOException\n    {\n        out = new PrintWriter(System.out);\n        sc=new AnotherReader();\n        boolean oj = true;\n \n        oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n        if(!oj) sc=new AnotherReader(100);\n \n        long s = System.currentTimeMillis();\n        int t=1;\n        while(t-->0)\n            process();\n        out.flush();\n        if(!oj)\n            System.out.println(System.currentTimeMillis()-s+\"ms\");\n        System.out.close();  \n    }\n \n    static void pn(Object o){out.println(o);}\n    static void p(Object o){out.print(o);}\n    static void pni(Object o){out.println(o);System.out.flush();}\n    static int ni()throws IOException{return sc.nextInt();}\n    static long nl()throws IOException{return sc.nextLong();}\n    static double nd()throws IOException{return sc.nextDouble();}\n    static String nln()throws IOException{return sc.nextLine();}\n    static long gcd(long a, long b)throws IOException{return (b==0)?a:gcd(b,a%b);}\n    static int gcd(int a, int b)throws IOException{return (b==0)?a:gcd(b,a%b);}\n    static int bit(long n)throws IOException{return (n==0)?0:(1+bit(n&(n-1)));}\n    static boolean multipleTC=false;\n \n \n \n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n    static class AnotherReader{BufferedReader br; StringTokenizer st;\n    AnotherReader()throws FileNotFoundException{\n    br=new BufferedReader(new InputStreamReader(System.in));}\n    AnotherReader(int a)throws FileNotFoundException{\n    br = new BufferedReader(new FileReader(\"input.txt\"));}\n    String next()throws IOException{\n    while (st == null || !st.hasMoreElements()) {try{\n    st = new StringTokenizer(br.readLine());}\n    catch (IOException  e){ e.printStackTrace(); }}\n    return st.nextToken(); } int nextInt() throws IOException{\n    return Integer.parseInt(next());}\n    long nextLong() throws IOException\n    {return Long.parseLong(next());}\n    double nextDouble()throws IOException { return Double.parseDouble(next()); }\n    String nextLine() throws IOException{ String str = \"\"; try{\n    str = br.readLine();} catch (IOException e){\n    e.printStackTrace();} return str;}}\n    \n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n}"
        },
        {
            "language": 3,
            "solution": "from sys import stdin\nfrom sys import setrecursionlimit as SRL; SRL(10**7)\nrd = stdin.readline\nrrd = lambda: map(int, rd().strip().split())\n\nn,i = rrd()\ni*=8\n\ncan = 2**(i//n)\n\na = list(rrd())\na.sort()\na = [-1] + a + [-1]\n\n\nans = 10**100\nj = 1\ncnt = 0\nfor i in range(n+1):\n\n    if i and a[i]!=a[i-1]:\n        cnt += 1\n\n    if cnt > can:\n        ans = min(ans,n-(i-j))\n        j += 1\n        while a[j] == a[j-1]:\n            j += 1\n        cnt -= 1\n\nans = min(ans,n-(i+1-j))\n\nprint(ans)"
        },
        {
            "language": 3,
            "solution": "import math;\nn,I = map(int,input().split());\narr = list(map(int,input().split()));\nk = 8*I//n;\nK = 2**k;\narr.sort();\nnd = 1;\nle = arr[0];\nb = [0];\nfor i in range(1,n):\n    if(arr[i]!=le):\n        le=arr[i];\n        b.append(i);\n        nd+=1;\nb.append(n)\n#print(b);\n#print(nd);\nif(K>=nd):\n    print(0);\nelse:\n    maxn = 0;\n    for i in range(K,nd):\n        maxn = max(maxn,(b[i]-b[i-K]));\n    print(n-maxn)\n    \n    \n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 4e5 + 7;\nmap<int, int> cnt;\nint p[N], a[N], d[N];\nint main() {\n  int n, b;\n  scanf(\"%d%d\", &n, &b);\n  int tot = n;\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d\", &a[i]);\n    cnt[a[i]]++;\n  }\n  sort(a + 1, a + n + 1);\n  n = unique(a + 1, a + n + 1) - a - 1;\n  d[1] = 0;\n  for (int i = 1; i <= n; ++i) {\n    p[i] = p[i - 1] + cnt[a[i]];\n    d[i + 1] = d[i] + ((i & (i - 1)) ? 0 : 1);\n  }\n  int ans = N;\n  int r = 1;\n  for (int l = 1; l <= n; ++l) {\n    while (r <= n && 1LL * d[r - l + 1] * tot <= b * 8) ++r;\n    ans = min(ans, tot - (p[r - 1] - p[l - 1]));\n  }\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.text.*;\npublic class Main{\n    //SOLUTION BEGIN\n    //Into the Hardware Mode\n    void pre() throws Exception{}\n    void solve(int TC) throws Exception{\n        int n = ni();long I = 8*nl();\n        long mx = (I/n);\n        if(mx > 20)mx = n;\n        else mx = 1l<<mx;\n        Long[] a = new Long[n];\n        for(int i = 0; i< n; i++)a[i] = nl();\n        Arrays.sort(a);\n        int ans = n;\n        int[] cnt = new int[n];\n        cnt[0] = 1;\n        for(int i = 1; i< n; i++)cnt[i] = cnt[i-1] +(a[i] != (long)a[i-1]?1:0);\n        \n        for(int i = 0, j = 0; i< n; i++){\n            if(i > 0 && a[i] == (long)a[i-1])continue;\n            while(j< n && cnt[j]-(i==0?0:cnt[i-1]) <= mx)j++;\n            ans = Math.min(ans, n-(j-i));\n        }\n        pn(Math.max(0, ans));\n    }\n    class MyTreeSet<T>{\n        private int size;\n        private TreeMap<T, Integer> map;\n        public MyTreeSet(){\n            size = 0;\n            map = new TreeMap<>();\n        }\n        public int size(){return size;}\n        public int dsize(){return map.size();}\n        public boolean isEmpty(){return size==0;}\n        public void add(T t){\n            size++;\n            map.put(t, map.getOrDefault(t, 0)+1);\n        }\n        public boolean remove(T t){\n            if(!map.containsKey(t))return false;\n            size--;\n            int c = map.get(t);\n            if(c==1)map.remove(t);\n            else map.put(t, c-1);\n            return true;\n        }\n        public int freq(T t){return map.getOrDefault(t, 0);}\n        public boolean contains(T t){return map.getOrDefault(t,0)>0;}\n        public T ceiling(T t){return map.ceilingKey(t);}\n        public T floor(T t){return map.floorKey(t);}\n        public T first(){return map.firstKey();}\n        public T last(){return map.lastKey();}\n    }\n    //SOLUTION END\n    void hold(boolean b)throws Exception{if(!b)throw new Exception(\"Hold right there, Sparky!\");}\n    long IINF = (long)1e18, mod = (long)1e9+7;\n    final int INF = (int)1e9, MX = (int)2e5+5;\n    DecimalFormat df = new DecimalFormat(\"0.00\");\n    double PI = 3.141592653589793238462643383279502884197169399, eps = 1e-6;\n    static boolean multipleTC = false, memory = false, fileIO = false;\n    FastReader in;PrintWriter out;\n    void run() throws Exception{\n        if(fileIO){\n            in = new FastReader(\"input.txt\");\n            out = new PrintWriter(\"output.txt\");\n        }else {\n            in = new FastReader();\n            out = new PrintWriter(System.out);\n        }\n        //Solution Credits: Taranpreet Singh\n        int T = (multipleTC)?ni():1;\n        pre();for(int t = 1; t<= T; t++)solve(t);\n        out.flush();\n        out.close();\n    }\n    public static void main(String[] args) throws Exception{\n        if(memory)new Thread(null, new Runnable() {public void run(){try{new Main().run();}catch(Exception e){e.printStackTrace();}}}, \"1\", 1 << 28).start();\n        else new Main().run();\n    }\n    long gcd(long a, long b){return (b==0)?a:gcd(b,a%b);}\n    int gcd(int a, int b){return (b==0)?a:gcd(b,a%b);}\n    int bit(long n){return (n==0)?0:(1+bit(n&(n-1)));}\n    void p(Object o){out.print(o);}\n    void pn(Object o){out.println(o);}\n    void pni(Object o){out.println(o);out.flush();}\n    String n()throws Exception{return in.next();}\n    String nln()throws Exception{return in.nextLine();}\n    int ni()throws Exception{return Integer.parseInt(in.next());}\n    long nl()throws Exception{return Long.parseLong(in.next());}\n    double nd()throws Exception{return Double.parseDouble(in.next());}\n \n    class FastReader{\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader(){\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n \n        public FastReader(String s) throws Exception{\n            br = new BufferedReader(new FileReader(s));\n        }\n \n        String next() throws Exception{\n            while (st == null || !st.hasMoreElements()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                }catch (IOException  e){\n                    throw new Exception(e.toString());\n                }\n            }\n            return st.nextToken();\n        }\n \n        String nextLine() throws Exception{\n            String str = \"\";\n            try{   \n                str = br.readLine();\n            }catch (IOException e){\n                throw new Exception(e.toString());\n            }  \n            return str;\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "from math import*\nn,o=map(int,input().split())\na=list(map(int,input().split()))\na.sort()\nm=[]\nfor i in range(n):\n    if i==0:\n        pr=a[i]\n        p=1\n    elif pr!=a[i]:\n        m.append(p)\n        p=1\n    else:\n        p+=1\n    pr=a[i]\nm.append(p)\nr=len(m)-1\nwhile (ceil(log2(r+1))*n)>(o*8):\n    r-=1\nl=0\nviv=0\n\nwhile l<=r:\n    viv+=m[l]\n    l+=1\nl=0\nmv=n-viv\nwhile r<len(m)-1:\n    if n-viv<mv:\n        mv=n-viv\n    r+=1\n    viv+=m[r]\n    viv-=m[l]\n    l+=1\nprint(mv)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, I;\n  cin >> n >> I;\n  I = I * 8;\n  vector<int> arr(n);\n  for (int i = 0; i < n; i++) cin >> arr[i];\n  sort(arr.begin(), arr.end());\n  map<int, int> mp;\n  int distinct = 0, ans = INT_MAX;\n  int j = 0;\n  for (int i = 0; i < n; i++) {\n    mp[arr[i]]++;\n    if (mp[arr[i]] == 1) distinct++;\n    while (I < n * ceil(log2(distinct))) {\n      mp[arr[j]]--;\n      if (mp[arr[j]] == 0) distinct--;\n      j++;\n    }\n    ans = min(ans, j + n - i - 1);\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n    public static void main(String[] args)throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n\n        int n,I;\n        int temp;\n        TreeMap<Integer,Integer> map = new TreeMap<>();\n        n = Integer.parseInt(st.nextToken());I=Integer.parseInt(st.nextToken());\n        st = new StringTokenizer(br.readLine());\n        int k = I*8/n;\n        int K = 1<<k;\n        if(k > 20){\n            System.out.println(0); return;\n        }\n        for(int i=0;i<n;i++){\n            temp = Integer.parseInt(st.nextToken());\n            if(map.containsKey(temp)){\n                map.put(temp,map.get(temp)+1);\n            }else{\n                map.put(temp,1);\n            }\n        }\n\n        if(map.size()>K){\n            int index = 0;\n            int []a = new int[map.size()];\n            for(int cur:map.keySet()){\n                a[index++] = map.get(cur);\n            }\n            for(int i=1;i<index;i++){\n                a[i] += a[i-1];\n            }\n            int result = 400001;\n            for(int i=0;i+K<index;i++){\n                int cur = a[index-1] - (a[i+K]-a[i]);\n                result = Integer.min(result,cur);\n            }\n            result = Integer.min(result,a[index-1]-a[K-1]);\n            System.out.println(result);\n        }else{\n            System.out.println(0);\n        }\n    }\n}"
        },
        {
            "language": 3,
            "solution": "import math\n\n# print(math.floor(2**(8/6)))\nn, k = map(int, input().split())\nif k/n>=31:\n    print(\"0\")\n    exit()\ndisti = math.floor(2 ** math.floor(8 * k / n))\n# while math.ceil(math.log(disti,2))*n/8>k:\n#     disti-=1\n# print(disti)\na = list(map(int, input().split()))\n\n# print(disti)\nif len(set(a)) <= disti:\n    print(\"0\")\n    exit()\n# print(disti)\na = sorted(a)\nd = dict()\nfor i in range(len(a)):\n    d[a[i]] = d.get(a[i], 0)\n    d[a[i]] += 1\np = []\nfor i in sorted(d.keys()):\n    p.append(d[i])\nans = 0\n# remove=len(set(a))-disti\n# print(p)\n# print(\"REMONE\",remove)\nfor i in range(disti):\n    ans += p[i]\nwindow = ans\nfor i in range(disti, len(p)):\n    window -= p[i - disti]\n    window += p[i]\n    if window > ans:\n        ans = window\n\nprint(sum(p) - ans)"
        },
        {
            "language": 3,
            "solution": "from collections import Counter\n\nN, I = map(int, input().split())\ncounter = Counter(list(map(int, input().split())))\na = sorted(counter.keys())\nbits = (I*8) // N\nif bits >= 30 or 2**bits >= len(a):\n    print(0)\n    exit()\n\nsound_range = 2**bits\nr = 0\nacc = 0\nfor i in range(sound_range):\n    acc += counter[a[r]]\n    r += 1\nans = acc\n\nfor l, r in zip(range(len(a)), range(r, len(a))):\n    acc += counter[a[r]] - counter[a[l]]\n    if acc > ans:\n        ans = acc\n\nprint(N-ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nmt19937_64 rng(chrono::high_resolution_clock::now().time_since_epoch().count());\nconst ld pi = acos(0) * 2;\ntemplate <typename T>\ninline void read(T &x) {\n  char c;\n  bool nega = 0;\n  while ((!isdigit(c = getchar())) && (c != '-'))\n    ;\n  if (c == '-') {\n    nega = 1;\n    c = getchar();\n  }\n  x = c - 48;\n  while (isdigit(c = getchar())) x = x * 10 + c - 48;\n  if (nega) x = -x;\n}\ntemplate <typename T>\ninline void writep(T x) {\n  if (x > 9) writep(x / 10);\n  putchar(x % 10 + 48);\n}\ntemplate <typename T>\ninline void write(T x) {\n  if (x < 0) {\n    putchar('-');\n    x = -x;\n  }\n  writep(x);\n}\ntemplate <typename T>\ninline void writeln(T x) {\n  write(x);\n  putchar('\\n');\n}\ntemplate <typename CT, typename T>\ninline void reset_container(CT &c, int sz, T v) {\n  c.resize(sz);\n  for (auto &x : c) x = v;\n}\nll I;\nll sz = 1;\nint n;\nint a[400001];\nvector<pair<int, int>> v;\nint main() {\n  read(n);\n  read(I);\n  I *= 8;\n  for (int i = (1); i <= (n); i++) read(a[i]);\n  for (int i = (1); i <= (60); i++) {\n    if ((ll(n)) * i <= I)\n      sz *= 2;\n    else\n      break;\n  }\n  sort(a + 1, a + n + 1);\n  v.push_back(make_pair(-1, 0));\n  for (int i = (1); i <= (n); i++)\n    if (v.back().first != a[i])\n      v.push_back(make_pair(a[i], 1));\n    else\n      v.back().second++;\n  sz = min(sz, ((ll)v.size()) - 1);\n  for (int i = (1); i < (v.size()); i++) v[i].second += v[i - 1].second;\n  int f = 0;\n  for (int i = (sz); i < (v.size()); i++) {\n    f = max(f, v[i].second - v[i - sz].second);\n  }\n  f = n - f;\n  writeln(f);\n}\n"
        },
        {
            "language": 3,
            "solution": "from sys import stdin\ninput=stdin.readline\nn,I=map(int,input().split())\na=list(map(int,input().split()))\na.sort()\nk=8*I//n\nK=2**k\nb=[0]\nfor i in range(1,n):\n  if a[i-1]!=a[i]:\n    b.append(i)\nif len(b)<=K:\n  print(0)\nelse:\n  print(n-max(b[i+K]-b[i] for i in range(len(b)-K)))"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class ccc\n{\n    public static void main(String[] args) {new ccc();}\n    Scanner in = new Scanner(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n    \n    int n, I, sz;\n    int[] a, cmp, cs;\n    \n    ccc()\n    {\n        a = new int[n = in.nextInt()];\n        I = 8*in.nextInt();\n        for (int i = 0; i < n; i++) \n            a[i] = in.nextInt();\n        sort(a);\n\n        sz = 0; \n        cmp = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            int j = i;\n            while (j < n && a[i] == a[j]) j++;\n            cmp[sz++] = j-i;\n            i = j-1;\n        }\n        \n        cs = new int[sz+1];\n        for (int i = 1; i <= sz; i++)\n            cs[i] = cmp[i-1]+cs[i-1];\n        \n        int k = 0, kk = I/n; \n        while ((1 << k) < sz) k++;\n        if (k <= kk) out.println(0);\n        else\n        {\n        \tint d = 1 << kk, min = 1 << 30;\n        \tfor (int i = 0; i < sz; i++)\n        \t{\n        \t\tif (i+d > sz) break;\n        \t\tmin = Math.min(min, n-(cs[i+d]-cs[i]));\n        \t}\n        \tout.println(min);\n        }\n        out.close();\n    }\n    \n    void sort(int[] x)\n    {\n        int sz = x.length;\n        Random r = new Random();\n        for (int i = 0; i < sz; i++)\n        {\n            int j = r.nextInt(sz);\n            x[i] = x[i]+x[j]-(x[j] = x[i]);\n        }\n        Arrays.sort(x);\n    }\n}"
        },
        {
            "language": 3,
            "solution": "import math\nimport collections\nn,I=input().split()\nn,I=[int(n),int(I)]\nk=8*I//n\nK=2**k\nl=[int(i) for i in input().split()]\nl.sort()\nb=[0]\nfor i in range(1, n):\n    if l[i-1] != l[i]:\n        b.append(i)\ns=len(set(l))\ncount=[]\nindex=n\nif s<=K:\n    print(0)\nelse:\n    for i in range(len(b)-K):\n        count.append(b[i+K]-b[i])\n    print(n-max(count))\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class A {\n    FastScanner in;\n    PrintWriter out;\n\n\n    void solve() {\n        int n = in.nextInt();\n        int bits = in.nextInt() * 8;\n        int one_element = Math.min(30, bits / n);\n        int different_vals = (1 << one_element) - 1;\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextInt();\n        }\n        Arrays.sort(a);\n        TreeMap<Integer, Integer> tm = new TreeMap<>();\n        int max = 0;\n        int r = 0;\n        for (int l = 0; l < n; l++) {\n            if (l != 0) {\n                Integer zz = tm.get(a[l - 1]);\n                if (zz - 1 == 0) {\n                    tm.remove(a[l - 1]);\n                } else {\n                    tm.put(a[l - 1], zz - 1);\n                }\n            }\n            while (r != n && (tm.containsKey(a[r]) || tm.size() <= different_vals)) {\n                Integer ff = tm.get(a[r]);\n                tm.put(a[r], ff != null ? ff + 1 : 1);\n                r++;\n            }\n            max = Math.max(max, r - l);\n        }\n        out.println(n - max);\n\n    }\n\n    void run() {\n        try {\n            in = new FastScanner(new File(\"A.in\"));\n            out = new PrintWriter(new File(\"A.out\"));\n\n            solve();\n\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    void runIO() {\n\n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out);\n\n        solve();\n\n        out.close();\n    }\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public FastScanner(InputStream f) {\n            br = new BufferedReader(new InputStreamReader(f));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return null;\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n\n        boolean hasMoreTokens() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return false;\n                st = new StringTokenizer(s);\n            }\n            return true;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    public static void main(String[] args) {\n        new A().runIO();\n    }\n}\n"
        },
        {
            "language": 1,
            "solution": "\"\"\"\nNTC here\n\"\"\"\nfrom sys import stdin, setrecursionlimit\nsetrecursionlimit(10**7)\n\n\ndef iin(): return int(stdin.readline())\n \n \ndef lin(): return list(map(int, stdin.readline().split()))\n\n\n# range = xrange\n# input = raw_input\n\n\ndef main():\n    n,i=lin()\n    a=lin()\n    a.sort()\n    ca=len(set(a))\n    k=(i*8)//n\n    K=2**k\n    #print(K,k,ca)\n    if ca <= K:\n        print(0)\n    else:\n        c1,c2={},{}\n        cr=-1\n        d=0\n        for i in range(n):\n            if a[i]!=cr:\n                cr=a[i]\n                c1[d]=i\n                d+=1\n        a=a[::-1]\n        cr=-1\n        d=0\n        for i in range(n):\n            if a[i]!=cr:\n                cr=a[i]\n                c2[d]=i\n                d+=1\n        ans=2**20\n        rn=ca-K\n        for i in range(rn):\n     #       print(i,rn-i)\n            ans=min(ans,c1[i]+c2[rn-i])\n        print(ans)\n       # print(c1,c2)\n\n\n\nmain()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long n, I;\n  cin >> n >> I;\n  I *= 8;\n  long long a[n];\n  for (long long i = 0; i < n; i++) cin >> a[i];\n  map<long long, long long> mapu;\n  for (long long i = 0; i < n; i++) mapu[a[i]]++;\n  vector<long long> output;\n  for (auto it = mapu.begin(); it != mapu.end(); it++)\n    output.push_back(it->second);\n  long long loda = I / n;\n  long long poi;\n  if (loda > 18)\n    poi = output.size();\n  else {\n    poi = pow(2, loda);\n    if (poi > output.size()) poi = output.size();\n  }\n  long long maxisum = 0;\n  long long summi[output.size() + 1];\n  for (long long i = 0; i <= output.size(); i++) summi[i] = 0;\n  for (long long i = 1; i <= output.size(); i++) {\n    summi[i] = summi[i - 1] + output[i - 1];\n  }\n  for (long long i = 1; i <= output.size() - poi + 1; i++) {\n    long long loli = summi[i + poi - 1] - summi[i - 1];\n    if (loli > maxisum) maxisum = loli;\n  }\n  cout << n - maxisum;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long int n, m;\n  cin >> n >> m;\n  m *= 8;\n  m /= n;\n  m = (1 << min(m, 30LL));\n  vector<int> arr(n);\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i];\n  }\n  sort(arr.begin(), arr.end());\n  vector<int> p(n);\n  p[0] = 1;\n  for (int i = 1; i < n; i++) {\n    if (arr[i] == arr[i - 1]) {\n      p[i] = p[i - 1];\n    } else {\n      p[i] = p[i - 1] + 1;\n    }\n  }\n  int Max = 0;\n  int index = 0;\n  for (int i = 0; i < n; i++) {\n    while (index < n - 1 && p[index + 1] <= p[i] + m - 1) {\n      ++index;\n    }\n    Max = max(Max, index - i + 1);\n  }\n  cout << n - Max << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class FastScanner {\n        private BufferedReader bufferedReader;\n        private StringTokenizer stringTokenizer;\n\n        public FastScanner(InputStream inputStream) {\n            bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n        }\n\n        public String next() {\n            while (stringTokenizer == null || !stringTokenizer.hasMoreTokens()) {\n                try {\n                    stringTokenizer = new StringTokenizer(bufferedReader.readLine());\n                } catch (IOException ignored) {\n                }\n            }\n            return stringTokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    static class Node implements Comparable {\n        Node left;\n        Node right;\n        private int value;\n\n        Node(Node left, Node right, int value) {\n            this.left = left;\n            this.right = right;\n            this.value = value;\n        }\n\n        @Override\n        public int compareTo(Object o) {\n            return Integer.compare(this.value, ((Node) o).value);\n        }\n    }\n\n    private static int fib(int n, int m) {\n        if (n < 2) return n;\n        int a = 0;\n        int b = 1;\n        for (int i = 0; i < n - 2; i++) {\n            int c = (a + b) % m;\n            a = b;\n            b = c;\n        }\n        return (a + b) % m;\n    }\n\n    static long gcd(long a, long b) {\n        if (b == 0) return a;\n        return gcd(b, a % b);\n    }\n\n    static long lcm(long a, long b) {\n        return Math.abs(a * b) / gcd(a, b);\n    }\n\n    static class DSU {\n        private int[] p;\n        private int[] r;\n\n        DSU(int n) {\n            p = new int[n];\n            r = new int[n];\n            Arrays.fill(p, -1);\n            Arrays.fill(r, 0);\n        }\n\n        int find(int x) {\n            if (p[x] < 0) {\n                return x;\n            }\n            return p[x] = find(p[x]);\n        }\n\n        void union(int a, int b) {\n            a = find(a);\n            b = find(b);\n            if (a == b) return;\n            if (r[a] < r[b]) {\n                p[a] = b;\n            } else {\n                p[b] = a;\n            }\n            if (r[a] == r[b]) {\n                r[a]++;\n            }\n        }\n    }\n\n    private static boolean isPrime(long n) {\n        for (int i = 2; i < n; i++) {\n            if (n % i == 0) return false;\n        }\n        return true;\n    }\n\n    private static double med(Integer[] a) {\n        Arrays.sort(a);\n        if (a.length % 2 == 0) {\n            int r = a.length / 2;\n            int l = r - 1;\n            double s = a[l] + a[r];\n            return s / 2.0;\n        }\n        int m = a.length / 2;\n        return a[m];\n    }\n\n    static Map<Integer, ArrayList<Integer>> g;\n    static Map<Integer, Integer> color;\n\n    static void dfs(int v, int c) {\n        color.put(v, c);\n        for (int i = 0; i < g.get(v).size(); i++) {\n            int u = g.get(v).get(i);\n            if (!color.containsKey(u)) {\n                dfs(u, c);\n            }\n        }\n    }\n\n    static void reverse(Integer[] a) {\n        Collections.reverse(Arrays.asList(a));\n    }\n\n    static boolean next(Integer[] a) {\n        int i = a.length - 1;\n        while (a[i] == 0) i--;\n        int c = 0;\n        while (i >= 0 && a[i] == 1) {\n            c++;\n            i--;\n        }\n        if (i < 0) return false;\n        a[i] = 1;\n        for (int j = i + 1; j < a.length; j++) {\n            a[j] = 0;\n        }\n        c--;\n        for (int j = 0; j < c; j++) {\n            a[a.length - 1 - j] = 1;\n        }\n        return true;\n    }\n\n    private static int bin(Integer[] a, int l, int r, int x) {\n        if (l >= r) return l;\n        int m = (l + r) / 2;\n        if (a[m] > x) {\n            return bin(a, l, m, x);\n        } else if (a[m] < x || (m < a.length - 1 && a[m + 1] == x)) {\n            return bin(a, m + 1, r, x);\n        }\n        return m + 1;\n    }\n\n    private static class SegmentTree {\n        private long[] d;\n        private long[] a;\n\n        SegmentTree(int n) {\n            a = new long[n];\n            d = new long[5 * n];\n        }\n\n        void update(int v, int l, int r, int pos, long val) {\n            if (l == r) {\n                d[v] += val;\n                a[l] += val;\n            } else {\n                int mid = (l + r) / 2;\n                if (pos <= mid) {\n                    update(v * 2, l, mid, pos, val);\n                } else {\n                    update(v * 2 + 1, mid + 1, r, pos, val);\n                }\n                d[v] = d[v * 2] + d[v * 2 + 1];\n            }\n        }\n\n        int find(int v, int l, int r, long w) {\n            if (v >= d.length) return -1;\n            int mid = (l + r) / 2;\n            if (d[v] <= w) return r;\n            long o = w - d[v * 2];\n            if (mid + 1 < a.length && o >= a[mid + 1]) {\n                return find(v * 2 + 1, mid + 1, r, o);\n            }\n            if (w >= a[l])\n                return find(v * 2, l, mid, w);\n            return -1;\n        }\n\n        int iterFind(long w) {\n            if (a[0] > w) return -1;\n            int l = 0, r = a.length - 1;\n            int v = 1;\n            while (d[v] > w) {\n                int mid = (l + r) / 2;\n                long o = w - d[v * 2];\n                if (mid + 1 < a.length && o >= a[mid + 1]) {\n                    l = mid + 1;\n                    v = v * 2 + 1;\n                    w = o;\n                } else {\n                    v = v * 2;\n                    r = mid;\n                }\n            }\n            return r;\n        }\n\n        int get(int v, int vl, int vr, long w) {\n            // cout << t[v] << \"  \"<< v << \" \" << vl << \" \" << vr<<\" \" << w << endl;\n            if (d[v] < w) return -1;\n            if (vl > vr) return -1;\n            if (vl == vr) {\n                if (d[v] > w) return vl - 1;\n                else return -1;\n            }\n            if (d[v * 2] > w) return get(v * 2, vl, (vl + vr) / 2, w);\n            else return get(v * 2 + 1, (vl + vr + 2) / 2, vr, w - d[v * 2]);\n        }\n    }\n\n    private static class FenwickTree {\n        long[] t;\n\n        FenwickTree(int n) {\n            t = new long[n];\n        }\n\n        long sum(int r) {\n            long result = 0;\n            for (; r >= 0; r = (r & (r + 1)) - 1)\n                result += t[r];\n            return result;\n        }\n\n        void inc(int i, long delta) {\n            int n = t.length;\n            for (; i < n; i = (i | (i + 1)))\n                t[i] += delta;\n        }\n    }\n\n    void insert(List<Long> list, Long element) {\n        int index = Collections.binarySearch(list, element);\n        if (index < 0) {\n            index = -index - 1;\n        }\n        list.add(index, element);\n    }\n\n    public static void main(String[] args) {\n        FastScanner scanner = new FastScanner(System.in);\n        PrintWriter printer = new PrintWriter(System.out);\n        int n = scanner.nextInt();\n        long I = scanner.nextLong();\n        long k = (I * 8) / n;\n        int K;\n        if (k > 20){\n            K = n;\n        } else {\n            K = (int)Math.pow(2, k);\n        }\n        Integer []a = new Integer[n];\n        Map<Integer, Integer>counter = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n            counter.put(a[i], counter.getOrDefault(a[i],0) + 1);\n        }\n        Integer [][] tb = new Integer[counter.size()][2];\n        int m = counter.size();\n        int i = 0;\n        for (Map.Entry<Integer, Integer>e: counter.entrySet()) {\n            tb[i][0] = e.getValue();\n            tb[i][1] = e.getKey();\n            i++;\n        }\n        Arrays.sort(tb, Comparator.comparingInt(o -> o[1]));\n        Integer[]b = new Integer[m];\n        for (int j = 0; j < m; j++) {\n            b[j] = tb[j][0];\n        }\n        long []bLSum = new long[m + 1];\n        long []bRSum = new long[m + 1];\n        bLSum[0] = 0;\n        bRSum[0] = 0;\n        for (int j = 1; j <= m; j++) {\n            bLSum[j] = bLSum[j - 1] + b[j - 1];\n            bRSum[j] = bRSum[j - 1] + b[m - j];\n        }\n        long ans = Long.MAX_VALUE;\n        for (int l = 0; l <= m; l++) {\n            int left = m - l;\n            int r = Math.max(left - K, 0);\n            long localAns = bLSum[l] + bRSum[r];\n            ans = Math.min(ans, localAns);\n        }\n        //printer.println(K);\n        //printer.println(Arrays.toString(b));\n        //printer.println(Arrays.toString(bLSum));\n        //printer.println(Arrays.toString(bRSum));\n        printer.println(ans);\n        printer.flush();\n        printer.close();\n    }\n}\n/*\n6 100000\n1 1 2 2 3 3\n\n8 2\n1 55 4 8 9 2 0 1\n */"
        },
        {
            "language": 3,
            "solution": "n, I = *map(int,input().split()),\na = [int(x) for x in input().split()]\na.sort()\n\ntgtbpn = (I*8)//n\nmxvals = 1<<tgtbpn\n\nc = []\ni = 0\nwhile i < len(a):\n    j = i\n    cnt = 0\n    while j < len(a) and a[j] == a[i]:\n        cnt+=1\n        j+=1\n    c.append(cnt)\n    i = j\n\nsm = 0\nmn = n\nfor i in range(len(c)):\n    sm += c[i]\n    if i-mxvals >= 0:\n        sm -= c[i-mxvals]\n    mn = min(mn, n-sm)\nprint(mn)\n"
        },
        {
            "language": 3,
            "solution": "from math import ceil, log2\nfrom collections import Counter\ndef read(): return [int(i) for i in input().split()]\n#t = int(input())\nfor _ in range(1):\n    n,x = read()\n    d = Counter(list(read()))\n    l = list(d.keys())\n    l.sort()\n    dis=  K = len(l)\n    while(ceil(log2(K))*n>x*8):\n        K-=1\n    K = dis-K\n    #print(d, l, dis, K)\n    s = sum([d[l[i]] for i in range(dis-K, dis)])\n    c = s\n    #print(s)\n    for i in range(K):\n        c = c+d[l[i]]-d[l[-K+i]]\n        s = min(s, c)\n    print(s)\n\n    "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 1e9 + 7;\nlong long fastExpo(long long aa, long long bb) {\n  long long res = 1;\n  while (bb > 0) {\n    if (bb & 1) {\n      res = (res * aa) % N;\n    }\n    aa = (aa * aa) % N;\n    bb = bb >> 1;\n  }\n  return res;\n}\nlong long mmi(long long nn) { return fastExpo(nn, N - 2); }\nconst long long ramramaramnamshamnam = 1e6 + 1;\nlong long facti[ramramaramnamshamnam];\nvoid facto() {\n  facti[0] = 1;\n  for (long long i = 1; i < 1e6 + 1; i++) {\n    facti[i] = (facti[i - 1] * i) % N;\n  }\n}\nvector<long long> adj[100001];\nlong long vis[100001];\nvoid dfs(long long node) {\n  vis[node] = 1;\n  for (auto child : adj[node]) {\n    if (vis[child] == 0) dfs(child);\n  }\n}\nvoid solve() {\n  long long n, i;\n  cin >> n >> i;\n  long long arr[n];\n  map<long long, long long> make_pair;\n  for (long long i = 0; i < n; i++) {\n    cin >> arr[i];\n    make_pair[arr[i]]++;\n  }\n  vector<long long> v;\n  for (auto first : make_pair) {\n    v.push_back(first.first);\n  }\n  long long ans = 0;\n  long long ma = INT_MAX;\n  long long maxi = (8 * i) / n;\n  long long ps[v.size()];\n  ps[0] = make_pair[v[0]];\n  maxi = min((long long)20, maxi);\n  for (long long i = 1; i < v.size(); i++) {\n    ps[i] = ps[i - 1] + make_pair[v[i]];\n  }\n  long long xx = pow(2, maxi);\n  long long k = min((long long)v.size(), xx);\n  long long tt = 0;\n  for (long long i = 0, j = k - 1; j < v.size(); i++, j++) {\n    if (i > 0) tt = ps[i - 1];\n    tt = tt + ps[v.size() - 1] - ps[j];\n    ma = min(ma, tt);\n  }\n  cout << ma << \"\\n\";\n}\nint32_t main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  cout << fixed << setprecision(15);\n  long long T = 1;\n  while (T--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long a[1000000];\nint main() {\n  long long n, I;\n  cin >> n >> I;\n  long long a[n];\n  I = 8 * I;\n  unordered_map<long long, long long> freq;\n  long long cnt = 0;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    freq[a[i]]++;\n  }\n  long long t = I / n;\n  long long fff = freq.size();\n  while (1) {\n    if (log2(fff) <= t) break;\n    fff--;\n  }\n  vector<pair<long long, long long>> v(freq.begin(), freq.end());\n  sort(v.begin(), v.end());\n  long long sum = 0;\n  long long ans = INT_MAX;\n  for (long long i = 0; i < fff; i++) sum += v[i].second;\n  ans = min(ans, n - sum);\n  for (long long i = fff; i < freq.size(); i++) {\n    sum = sum - v[i - fff].second + v[i].second;\n    ans = min(ans, n - sum);\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 3,
            "solution": "dic = {}\nnum = 0\na = [0]\nsum1 = [0]\nsum2 = [0]\n\n\ndef getID(x):\n    global dic, num\n    if dic.get(x, -1) == -1:\n        num += 1\n        dic[x] = num\n    return dic[x]\n\n\ndef quickM(d):\n    ans = 1\n    base = 2\n    while d > 0:\n        if d & 1:\n            ans *= base\n        base *= base\n        d >>= 1\n    return ans\n\n\nif __name__ == '__main__':\n    n, I = list(map(lambda x: int(x), input().split(' ')))\n    # aa = list(map(lambda x: int(x), input().split(' ')))\n    aa = input().split(' ')\n    for i in range(n):\n        aa[i] = int(aa[i])\n    aa.sort()\n    # for xx in aa:\n    #     x = getID(xx)\n    #     if len(a) == x:\n    #         a.append(0)\n    #     a[x] += 1\n    num = 1\n    a.append(1)\n    for i in range(1, n):\n        if aa[i] == aa[i-1]:\n            a[num] += 1\n        else:\n            num += 1\n            a.append(1)\n    for i in range(1, num+1):\n        sum1.append(sum1[i-1] + a[i])\n        sum2.append(sum2[i-1] + a[num-i+1])\n    K = num\n    k = I*8 // n\n    if k > 30:\n        k = 30\n    cnt = K - quickM(k)\n    if cnt < 0:\n        print(0)\n    else:\n        ans = n - 1\n        for i in range(cnt+1):\n            ans = min(ans, sum1[i] + sum2[cnt-i])\n            ans = min(ans, sum2[i] + sum1[cnt-i])\n        print(ans)\n\n\t\t \t   \t  \t\t \t\t\t  \t\t   \t\t \t \t\t"
        },
        {
            "language": 3,
            "solution": "n,I=list(map(int, input().split()))\nl=list(map(int, input().split()))\n\nk=2**(I*8//n)\ndd={}\nfor x in l:\n\tif x in dd:\n\t\tdd[x]+=1\n\telse:\n\t\tdd[x]=1\n# print(dd)\nl=[dd[x] for x in sorted(dd)]\n# print(l)\nn=len(l)\nif k>=n:\n\tprint(0)\nelse:\n\tss=sum(l[:k])\n\tmxm=ss\n\tfor i in range(1,n-k+1):\n\t\tss+=l[i+k-1]-l[i-1]\n\t\tif mxm<ss:\n\t\t\tmxm=ss\n\tprint(sum(l)-mxm)"
        },
        {
            "language": 3,
            "solution": "#576_C\n\nimport math\n\nl = [int(i) for i in input().split(\" \")]\nn = l[0]\nbt = l[1]\n\nln = sorted([int(i) for i in input().split(\" \")])\n\nK = 1\n\ndists = [1]\n\nfor i in range(1, len(ln)):\n    if ln[i] != ln[i - 1]:\n        K += 1\n        dists.append(1)\n    else:\n        dists[-1] += 1\n\nrdists = dists[:]\nldists = dists[::-1]\n\nrd = [0]\n\nfor i in rdists:\n    rd.append(rd[-1] + i)\n\nld = [0]\n\nfor i in ldists:\n    ld.append(ld[-1] + i)\n\nminVal = math.floor(2 ** math.floor((bt * 8) / n))\n\ndels = 0\ninds = 0\n\nminVal = K - minVal\n\nm = 10000000000\nsm = m\n\ni = minVal\nj = 0\n\nwhile i >= 0:\n    m = min(m, rd[i] + ld[j])\n    i -= 1\n    j += 1\n\nif m == sm:\n    m = 0\n\nprint(m)\n"
        },
        {
            "language": 3,
            "solution": " ######      ###      #######    #######    ##      #     #####        ###     ##### \n #     #    #   #          #        #       # #     #    #     #      #   #     ###  \n #     #   #     #        #         #       #  #    #   #       #    #     #    ###  \n ######   #########      #          #       #   #   #   #           #########    #   \n ######   #########     #           #       #    #  #   #           #########    #   \n #     #  #       #    #            #       #     # #   #    ####   #       #    #   \n #     #  #       #   #             #       #      ##   #    #  #   #       #        \n ######   #       #  #######     #######    #       #    #####  #   #       #    #   \n \n# mandatory imports\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nfrom math import log2, ceil, sqrt, gcd, log\n\n# optional imports\n# from itertools import permutations\n# from functools import cmp_to_key  # for adding custom comparator\n# from fractions import Fraction\nfrom collections import *\nfrom bisect import *\n# from __future__ import print_function # for PyPy2\n# from heapq import *\nBUFSIZE = 8192\n\n\n \nclass FastIO(IOBase):\n\tnewlines = 0\n \n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = \"x\" in file.mode or \"r\" not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n \n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\tself.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n \n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b\"\\n\") + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\tself.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n \n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\tself.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n\t\tself.read = lambda: self.buffer.read().decode(\"ascii\")\n\t\tself.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n \ng   = lambda : input().strip()\ngl  = lambda : g().split()\ngil = lambda : [int(var) for var in gl()]\ngfl = lambda : [float(var) for var in gl()]\ngcl = lambda : list(g())\ngbs = lambda : [int(var) for var in g()]\nrr = lambda x : reversed(range(x)) \nmod = int(1e9)+7\ninf = float(\"inf\")\n\n\nn, I = gil()\nI *= 8\n\na = gil()\na.sort()\ncnt = 0\nl = 0\n\nwhile l < n :\n\tval = a[l]\n\twhile l < n and a[l] == val:\n\t\ta[l] = cnt\n\t\tl += 1\n\tcnt += 1\n\n\nans = n-1\n\nl, r = 0, -1\nmaxDiff = pow(2, I//n)\n\nwhile l < n and r < n:\n\twhile r+1 < n and a[r+1] - a[l] + 1 <= maxDiff:\n\t\tr += 1\n\tans = min(ans, n - (r-l+1))\n\tl += 1\n\nprint(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1e9 + 7;\nconst long long INF = 1e18L + 7;\ntemplate <class n, class second>\nostream &operator<<(ostream &p, pair<n, second> x) {\n  return p << \"<\" << x.first << \", \" << x.second << \">\";\n}\ntemplate <class n>\nauto operator<<(ostream &p, n y) ->\n    typename enable_if<!is_same<n, string>::value,\n                       decltype(y.begin(), p)>::type {\n  int o = 0;\n  p << \"{\";\n  for (auto c : y) {\n    if (o++) p << \", \";\n    p << c;\n  }\n  return p << \"}\";\n}\nvoid dor() { cerr << '\\n'; }\ntemplate <class n, class... second>\nvoid dor(n p, second... y) {\n  cerr << p << \" \";\n  dor(y...);\n}\ntemplate <class n, class second>\nvoid mini(n &p, second y) {\n  if (p > y) p = y;\n}\ntemplate <class n, class second>\nvoid maxi(n &p, second y) {\n  if (p < y) p = y;\n}\nconst long long N = 4e5 + 7;\nlong long n, b;\nlong long a[N];\nmap<long long, long long> cnt;\nvector<pair<long long, long long> > val;\nlong long pref[N];\nlong long suf[N];\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(NULL);\n  cin >> n >> b;\n  b *= 8;\n  b /= n;\n  for (long long i = 1; i <= n; ++i) {\n    cin >> a[i];\n    ++cnt[a[i]];\n  }\n  for (auto it : cnt) val.push_back(it);\n  for (long long i = 0; i < (long long)(val).size(); ++i) {\n    pref[i] += val[i].second;\n    pref[i + 1] += pref[i];\n  }\n  for (long long i = (long long)(val).size() - 1; i >= 0; --i) {\n    suf[i] += val[i].second;\n    if (i > 0) suf[i - 1] += suf[i];\n  }\n  b = min(b, 30ll);\n  long long seg = 1 << b;\n  long long ans = inf;\n  for (long long i = 0; i < (long long)(val).size(); ++i) {\n    long long curr = 0;\n    if (i + seg < (long long)(val).size()) curr += suf[i + seg];\n    if (i > 0) curr += pref[i - 1];\n    ans = min(ans, curr);\n  }\n  cout << ans << '\\n';\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.io.*;\nimport java.lang.*;\nimport java.util.*;\n\npublic class MP3 {\n    public static void main(String[] args) {\n        FastReader in = new FastReader();\n        MP3 init = new MP3();\n        int n = in.nextInt();\n        int I = in.nextInt();\n        I *= 8;\n\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            int input = in.nextInt();\n            map.put(input, map.getOrDefault(input, 0) + 1);\n        }\n\n\n        ArrayList<Pair> list = new ArrayList<>();\n        for (Map.Entry<Integer, Integer> mapEntry : map.entrySet()) {\n            list.add(init.new Pair(mapEntry.getKey(), mapEntry.getValue()));\n        }\n        Collections.sort(list);\n\n        int size = list.size();\n        int bitsP = (int) Math.ceil((Math.log(size*1.0) / Math.log(2.0)));\n\n\n        while (bitsP * n > I) {\n            size--;\n            bitsP = (int) Math.ceil((Math.log(size*1.0) / Math.log(2.0)));\n        }\n        int len = list.size() - size;\n        int MIN_SUM = Integer.MAX_VALUE;\n        int dataLen = list.size();\n\n        int startSum[] = new int[len+1];\n        int endSum[] = new int[len+1];\n        for (int i = 1; i <= len; i++) {\n            startSum[i] = startSum[i-1] + list.get(i-1).v;\n        }\n        for (int i = 1; i <= len; i++) {\n            endSum[i] = endSum[i-1] + list.get(dataLen-i).v;\n        }\n\n        for (int i = 0; i <= len; i++) {\n            int sum = startSum[i] + endSum[len-i];\n            if (sum < MIN_SUM) {\n                MIN_SUM = sum;\n            }\n        }\n\n//        if (MIN_SUM == Integer.MAX_VALUE) {\n//            MIN_SUM = 0;\n//        }\n        System.out.println(MIN_SUM);\n    }\n\n    class Pair implements Comparable<Pair> {\n        int k, v;\n\n        public Pair(int k, int v) {\n            this.k = k;\n            this.v = v;\n        }\n\n        @Override\n        public int compareTo(Pair o) {\n            return k > o.k ? 1 : -1;\n        }\n    }\n\n    private static int min(int a, int b) {\n        return a < b ? a : b;\n    }\n\n    private static int max(int a, int b) {\n        return a > b ? a : b;\n    }\n\n    private static int min(ArrayList<Integer> list) {\n        int min = Integer.MAX_VALUE;\n        for (int el : list) {\n            if (el < min) {\n                min = el;\n            }\n        }\n        return min;\n    }\n\n    private static int max(ArrayList<Integer> list) {\n        int max = Integer.MIN_VALUE;\n        for (int el : list) {\n            if (el > max) {\n                max = el;\n            }\n        }\n        return max;\n    }\n\n    private static int min(int[] list) {\n        int min = Integer.MAX_VALUE;\n        for (int el : list) {\n            if (el < min) {\n                min = el;\n            }\n        }\n        return min;\n    }\n\n    private static int max(int[] list) {\n        int max = Integer.MIN_VALUE;\n        for (int el : list) {\n            if (el > max) {\n                max = el;\n            }\n        }\n        return max;\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:32000000\")\n#pragma GCC optimize(\"O3\")\nusing namespace std;\nint n, I;\nlong long arr[400005];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin.sync_with_stdio(0);\n  cout.sync_with_stdio(0);\n  cout.precision(8);\n  srand(time(0));\n  cin >> n >> I;\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i];\n  }\n  sort(arr, arr + n);\n  int power = 8 * I / n;\n  long long len = 1;\n  for (int i = 0; i < power && len <= 1e9; i++) {\n    len *= 2;\n  }\n  int ans = 1000000007;\n  int t = 1;\n  for (int l = 0, r = 0; l < n; l++) {\n    if (l && arr[l] != arr[l - 1]) {\n      t--;\n    }\n    while (r + 1 < n && t < len || (t == len && arr[r] == arr[r + 1])) {\n      t += arr[r] != arr[r + 1];\n      r++;\n    }\n    ans = min(ans, n - (r - l + 1));\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.util.concurrent.ThreadLocalRandom;\n\n@SuppressWarnings(\"Duplicates\")\n\npublic class test {\n    FastScanner in;\n    PrintWriter out;\n    boolean systemIO = true;\n    int INF = Integer.MAX_VALUE / 2;\n    long H, L;\n\n\n    void solve() {\n        int n = in.nextInt(), I = in.nextInt() * 8;\n        int k = I / n;\n        long K = 1 << k;\n        if (K < 0) {\n            System.out.println(0);\n            System.exit(0);\n        }\n        int a[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextInt();\n        }\n        shuffleArray(a);\n        Arrays.sort(a);\n        int[][] arr = new int[n][3];\n        int id = -1;\n        for (int i = 0; i < n; i++) {\n            if (i != 0 && a[i] == a[i - 1]) {\n                arr[id][1]++;\n            } else {\n                id++;\n                arr[id][0] = a[i];\n                arr[id][1] = 1;\n            }\n        }\n\n        if (k > 19 || (1 << k) > id) {\n            System.out.println(0);\n            System.exit(0);\n        }\n        int ans = 0, kk = 0;\n        int uk1 = 0, uk2 = 0;\n        for (long i = K; i <= id; i++) {\n            while (uk2 < i) {\n                kk += arr[uk2++][1];\n            }\n            while (uk1 < i - K) {\n                kk -= arr[uk1++][1];\n            }\n            ans = Math.max(ans, kk);\n        }\n        //System.out.println(K + \" \" + id);\n        System.out.println(n - (K > id ? n : ans));\n\n\n    }\n\n    void shuffleArray(int[] ar) {\n        Random rnd = ThreadLocalRandom.current();\n        for (int i = ar.length - 1; i > 0; i--) {\n            int index = rnd.nextInt(i + 1);\n            int a = ar[index];\n            ar[index] = ar[i];\n            ar[i] = a;\n        }\n    }\n\n    class pair {\n        int a, b;\n\n        pair(int A, int B) {\n            this.a = A;\n            this.b = B;\n        }\n    }\n\n    private void run() throws IOException {\n        if (systemIO) {\n            in = new test.FastScanner(System.in);\n            out = new PrintWriter(System.out);\n        } else {\n            in = new test.FastScanner(new File(\"firesafe.in\"));\n            out = new PrintWriter(new File(\"firesafe.out\"));\n        }\n        solve();\n\n        out.close();\n    }\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        FastScanner(InputStream f) {\n            br = new BufferedReader(new InputStreamReader(f));\n        }\n\n        String nextLine() {\n            try {\n                return br.readLine();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n    }\n\n    public static void main(String[] arg) throws IOException {\n        new test().run();\n    }\n\n}"
        },
        {
            "language": 3,
            "solution": "'''\n    Auther: ghoshashis545 Ashis Ghosh\n    College: jalpaiguri Govt Enggineering College\n\n'''\nfrom os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque,defaultdict as dd \nfrom bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil,sqrt,log,gcd\ndef ii():return int(input())\ndef si():return input()\ndef mi():return map(int,input().split())\ndef li():return list(mi())\nabc='abcdefghijklmnopqrstuvwxyz'\nabd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod=1000000007\n#mod=998244353\ninf = float(\"inf\")\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\n\ndef bo(i):\n    return ord(i)-ord('a')\n\n\n\ndef solve():\n    \n    # for _ in range(ii()):\n\n    \n    \n    \n    n,x=mi()\n    a=li()\n    m=dd(int)\n    x*=8\n    n1=n\n    for i in a:\n        m[i]+=1\n    a=list(set(a))\n    a.sort()\n    n=len(a)\n    suff=[0]*n\n    pre=[0]*n\n    for i in range(n-2,-1,-1):\n        suff[i]=suff[i+1]+m[a[i+1]]\n    for i in range(1,n):\n        pre[i]=pre[i-1]+m[a[i-1]]\n    ans=n1\n    l=0\n    s=0\n    x//=n1\n    k=1\n    for i in range(x):\n        k*=2\n        if(k>n):\n            break\n    # k=pow(2,x)\n    for i in range(n-k+1):\n        ans=min(ans,pre[i]+suff[i+k-1])\n    if ans==n1:\n        ans=0\n    print(ans)\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n        \nif __name__ ==\"__main__\":\n\n    if path.exists('input.txt'):\n        sys.stdin=open('input.txt', 'r')\n        sys.stdout=open('output.txt','w')\n    else:\n        input=sys.stdin.readline\n    solve()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, I, ans, cur_ans;\nmap<int, int> cnt;\nvector<int> a;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> I;\n  I *= 8;\n  ans = n;\n  a.assign(n, 0);\n  for (int i = 0; i < n; ++i) cin >> a[i], ++cnt[a[i]];\n  sort(a.begin(), a.end());\n  a.erase(unique(a.begin(), a.end()), a.end());\n  int lim_k = I / n;\n  if (lim_k >= 30) return cout << 0, 0;\n  int lim_K = 1;\n  for (int i = 0; i < lim_k; ++i) lim_K *= 2;\n  if (lim_K >= (int)a.size()) return cout << 0, 0;\n  for (int i = lim_K; i < (int)a.size(); ++i) cur_ans += cnt[a[i]];\n  ans = min(ans, cur_ans);\n  for (int i = lim_K; i < (int)a.size(); ++i) {\n    cur_ans -= cnt[a[i]];\n    cur_ans += cnt[a[i - lim_K]];\n    ans = min(ans, cur_ans);\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import math\nn, I = map(int, input().split())\na = list(map(int,input().split()))\na.sort()\nvals = 2**((I*8)//n)\nK = len(a)\nif K>vals:\n    d = {}\n    for i in a:\n        d[i] = d.get(i, 0) + 1\n    d = list(d.items())\n    s = sum([val for key, val in d[:vals]])\n    maxs = s\n    for i in range(vals, len(d)):\n        s = s - d[i-vals][1] + d[i][1]\n        maxs = max(maxs, s)\n    print(n - maxs)\nelse:\n    print(0)\n"
        },
        {
            "language": 3,
            "solution": "n, size = map(int,input().split())\na = list(map(int, input().split()))\nlimit = 2**((size*8)//n)\na.sort()\nl = [0]\nfor i in range (1, n):\n    if (a[i-1] != a[i]):\n        l.append(i)\nif (len(l) <= limit): print(0)\nelse: print (n - max(l[i+limit] - l[i] for i in range(len(l) - limit)))\n\n\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\npublic class Main {\n    public static int log(int x) {\n        if (x == 1) {\n            return 0;\n        }\n        for (int i = 0, j = 1;; i++, j *= 2) {\n            if (j >= x) {\n                return i;\n            }\n        }\n    }\n    public static void main(String[] args) throws IOException {\n        BufferedReader rd = new BufferedReader(new InputStreamReader(System.in));\n        String[] init = rd.readLine().split(\" \");\n        int n = Integer.parseInt(init[0]);\n        int k = Integer.parseInt(init[1]);\n        Integer[] arr = new Integer[n];\n        String[] line = rd.readLine().split(\" \");\n        for (int i = 0; i < n; i++) {\n            arr[i] = Integer.parseInt(line[i]);\n        }\n        int distinct;\n        for (distinct = n; distinct >= 1; distinct--) {\n            if (log(distinct) * n <= 8 * k) {\n                break;\n            }\n        }\n        Arrays.sort(arr);\n        int real = 0;\n        for (int i = 0; i < n; i++) {\n            if (i == 0 || !arr[i].equals(arr[i - 1])) {\n                real++;\n            }\n        }\n        if (distinct >= real) {\n            System.out.println(0);\n            return;\n        }\n        int[] amt = new int[real];\n        int pos = -1;\n        for (int i = 0; i < n; i++) {\n            if (i == 0 || !arr[i].equals(arr[i - 1])) {\n                pos++;\n            }\n            amt[pos]++;\n        }\n        int need = real - distinct;\n        int r = need - 1;\n        int l = amt.length;\n        int best = 0;\n        for (int i = 0; i < need; i++) {\n            best += amt[i];\n        }\n        int curr = best;\n        while (r >= 0) {\n            curr -= amt[r--];\n            curr += amt[--l];\n            best = Math.min(best, curr);\n        }\n        System.out.println(best);\n    }\n}"
        },
        {
            "language": 4,
            "solution": "//package test;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class CF1 implements Runnable {\n\tFastReader s;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve() {\n\t\t//Type solution here.\n\t\tint n = s.nextInt();\n\t\tlong tb = s.nextLong()*8;\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint e = s.nextInt();\n\t\t\tif(map.containsKey(e))\n\t\t\t{\n\t\t\t\tint val = map.get(e);\n\t\t\t\tmap.put(e, val+1);\n\t\t\t}\n\t\t\telse\n\t\t\t\tmap.put(e, 1);\n\t\t}\n\t\tint ans = Integer.MAX_VALUE;\n\t\tArrayList<Pair> al = new ArrayList<>();\n\t\tfor(Map.Entry<Integer, Integer> e : map.entrySet())\n\t\t{\n\t\t\tal.add(new Pair(e.getKey(), e.getValue()));\n\t\t\tans = Math.min(ans, n-e.getValue());\n\t\t}\n\t\tCollections.sort(al);\n\t\tint m = al.size();\n\t\tint i = 0, j = 0, num = n;\n\t\twhile(j<m)\n\t\t{\n\t\t\tint nod = j-i+1;\n\t\t\tlong rb = n*(long)Math.ceil(Math.log10((double)nod)/Math.log10(2.0));\n\t\t\tif(nod==1)\n\t\t\t\trb = n;\n\t\t\t//System.out.println(rb);\n\t\t\tif(rb<=tb)\n\t\t\t{\n\t\t\t\tnum = num-al.get(j).second;\n\t\t\t\tif(ans>num)\n\t\t\t\t\tans = num;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t\tj++;\n\t\t\t\telse\n\t\t\t\t\tnum = num+al.get(i).second;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\t\n\tstatic class Pair implements Comparable<Pair>{\n\t\tint first;\n\t\tint second;\n\t\t\n\t\tPair(){}\n\t\t\n\t\tPair(int first, int second)\n\t\t{\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n\t\t\n\t\tpublic int compareTo(Pair p)\n\t\t{\n\t\t\treturn this.first-p.first;\n\t\t}\n\t}\n\n\tpublic void run() {\n\t\tlong time = System.currentTimeMillis();\n\t\tboolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\tout = new PrintWriter(System.out);\n\t\ts = new FastReader(oj);\n\t\tsolve();\n\t\tout.flush();\n\t\tif (!oj) {\n\t\t\tSystem.out.println(Arrays.deepToString(new Object[] { System.currentTimeMillis() - time + \" ms\" }));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new CF1(), \"Main\", 1 << 26).start();\n\t}\n\n\tclass FastReader {\n\t\tInputStream is;\n\n\t\tpublic FastReader(boolean onlineJudge) {\n\t\t\tis = onlineJudge ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\t}\n\n\t\tbyte[] inbuf = new byte[1024];\n\t\tpublic int lenbuf = 0, ptrbuf = 0;\n\n\t\tint readByte() {\n\t\t\tif (lenbuf == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (ptrbuf >= lenbuf) {\n\t\t\t\tptrbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn inbuf[ptrbuf++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tint skip() {\n\t\t\tint b;\n\t\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t\t;\n\t\t\treturn b;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tchar nextChar() {\n\t\t\treturn (char) skip();\n\t\t}\n\n\t\tString next() {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile ((!isSpaceChar(b) || b == ' ')) { // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tchar[] next(int n) {\n\t\t\tchar[] buf = new char[n];\n\t\t\tint b = skip(), p = 0;\n\t\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t\t}\n\n\t\tint nextInt() {\n\t\t\tint num = 0, b;\n\t\t\tboolean minus = false;\n\t\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\tlong num = 0;\n\t\t\tint b;\n\t\t\tboolean minus = false;\n\t\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tchar[][] nextMatrix(int n, int m) {\n\t\t\tchar[][] map = new char[n][];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next(m);\n\t\t\treturn map;\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tint[][] next2DInt(int n, int m) {\n\t\t\tint[][] arr = new int[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[][] next2DLong(int n, int m) {\n\t\t\tlong[][] arr = new long[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextLongArray(m);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] shuffle(int[] arr) {\n\t\t\tRandom r = new Random();\n\t\t\tfor (int i = 1, j; i < arr.length; i++) {\n\t\t\t\tj = r.nextInt(i);\n\t\t\t\tint c = arr[i];\n\t\t\t\tarr[i] = arr[j];\n\t\t\t\tarr[j] = c;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] shuffle(long[] arr) {\n\t\t\tRandom r = new Random();\n\t\t\tfor (int i = 1, j; i < arr.length; i++) {\n\t\t\t\tj = r.nextInt(i);\n\t\t\t\tlong c = arr[i];\n\t\t\t\tarr[i] = arr[j];\n\t\t\t\tarr[j] = c;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] uniq(int[] arr) {\n\t\t\tarr = s.shuffle(arr);\n\t\t\tArrays.sort(arr);\n\t\t\tint[] rv = new int[arr.length];\n\t\t\tint pos = 0;\n\t\t\trv[pos++] = arr[0];\n\t\t\tfor (int i = 1; i < arr.length; i++) {\n\t\t\t\tif (arr[i] != arr[i - 1]) {\n\t\t\t\t\trv[pos++] = arr[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Arrays.copyOf(rv, pos);\n\t\t}\n\n\t\tlong[] uniq(long[] arr) {\n\t\t\tarr = s.shuffle(arr);\n\t\t\tArrays.sort(arr);\n\t\t\tlong[] rv = new long[arr.length];\n\t\t\tint pos = 0;\n\t\t\trv[pos++] = arr[0];\n\t\t\tfor (int i = 1; i < arr.length; i++) {\n\t\t\t\tif (arr[i] != arr[i - 1]) {\n\t\t\t\t\trv[pos++] = arr[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Arrays.copyOf(rv, pos);\n\t\t}\n\n\t\tint[] reverse(int[] arr) {\n\t\t\tint l = 0, r = arr.length - 1;\n\t\t\twhile (l < r) {\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tarr[r] = arr[l] ^ arr[r];\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tl++;\n\t\t\t\tr--;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] reverse(long[] arr) {\n\t\t\tint l = 0, r = arr.length - 1;\n\t\t\twhile (l < r) {\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tarr[r] = arr[l] ^ arr[r];\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tl++;\n\t\t\t\tr--;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] compress(int[] arr) {\n\t\t\tint n = arr.length;\n\t\t\tint[] rv = Arrays.copyOf(arr, n);\n\t\t\trv = uniq(rv);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = Arrays.binarySearch(rv, arr[i]);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] compress(long[] arr) {\n\t\t\tint n = arr.length;\n\t\t\tlong[] rv = Arrays.copyOf(arr, n);\n\t\t\trv = uniq(rv);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = Arrays.binarySearch(rv, arr[i]);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "import sys\nimport io, os\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n\ndef main():\n\n    n, I = map(int, input().split())\n    A = list(map(int, input().split()))\n\n    table = [0]*21\n    table[0] = 1\n    for i in range(1, 21):\n        table[i] = table[i-1]*2\n\n    import bisect\n\n    def is_ok(K):\n        k = bisect.bisect_left(table, K)\n        if n*k <= 8*I:\n            return True\n        else:\n            return False\n\n    ok = 1\n    ng = len(set(A))+1\n    while  ok+1 <ng:\n        c = (ok+ng)//2\n        if is_ok(c):\n            ok = c\n        else:\n            ng = c\n    K = ok\n    #print(K)\n    from collections import Counter\n    C = Counter(A)\n    if len(C) <= K:\n        print(0)\n        exit()\n    C = list(C.items())\n    C.sort(key=lambda x: x[0])\n    #print(C)\n    S = []\n    for k, v in C:\n        S.append(v)\n    #print(S)\n    T = list(reversed(S))\n    from itertools import accumulate\n    CS = [0]+S\n    CT = [0]+T\n    CS = list(accumulate(CS))\n    CT = list(accumulate(CT))\n    #print(CS)\n    #print(CT)\n    p = len(C)-K\n    ans = 5*10**5\n    for x in range(0, p+1):\n        y = p-x\n        ans = min(ans, CS[x]+CT[y])\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class tr0 {\n\tstatic PrintWriter out;\n\tstatic StringBuilder sb;\n\tstatic final double EPS = 1e-9;\n\tstatic long mod = 998244353;\n\tstatic int inf = (int) 1e9 + 2;\n\tstatic long[] fac;\n\tstatic int[] si;\n\tstatic ArrayList<Integer> primes;\n\tstatic ArrayList<Integer>[] ad;\n\tstatic ArrayList<pair>[] d;\n\tstatic edge[] ed;\n\tstatic boolean f;\n\tstatic int n, m;\n\tstatic int[][] a;\n\tstatic Queue<Integer>[] can;\n\tstatic String[] ss;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tout = new PrintWriter(System.out);\n        int n=sc.nextInt();\n        long I=sc.nextInt();\n        I=I*8;\n        TreeMap<Integer,Integer> t=new TreeMap<>();\n        int []a=new int [n];\n        for(int i=0;i<n;i++) {\n        \ta[i]=sc.nextInt();\n          t.put(a[i], t.getOrDefault(a[i], 0)+1);\n        }\n        long ans=0;\n        int k=t.size();\n        int []aa=new int [t.size()];\n        int id=0;\n        for(int j:t.keySet()) {\n        \taa[id++]=t.get(j);\n        }\n        int vk=0;\n        while(true) {\n        \tif(Math.ceil(Math.log(k)/Math.log(2))*1d*n<=I) {\n        \t\tvk=k;\n        \t\tbreak;\n        \t}\n        \tif(t.get(t.firstKey())<t.get(t.lastKey())) {\n        \t\tans+=t.get(t.firstKey());\n        \t\tt.remove(t.firstKey());\n        \t\tk--;\n        \t}\n        \telse {\n        \t\tans+=t.get(t.lastKey());\n        \t\tt.remove(t.lastKey());\n        \t\tk--;\n        \t}\n        \t\n        }\n        ans=Integer.MAX_VALUE;\n        int f=0;\n        for(int i=0;i<vk;i++) {\n        \tf+=aa[i];\n        }\n        int ix=vk;\n        int l=0;\n    \tans=Math.min(n-f, ans);\n      //  System.out.println(Arrays.toString(aa)+\" \"+vk);\n        while(ix<aa.length) {\n        \tans=Math.min(n-f, ans);\n        \tf+=aa[ix];\n        \tf-=aa[l];\n        \tl++;\n        \tix++;\n        }\n      //  if(ans==Integer.MAX_VALUE)\n        out.print(ans);\n\t\tout.close();\n\t}\n    \n\tstatic int getref(int x) {\n\t\tif(x==0)\n\t\t\treturn 5;\n\t\tif(x==1)\n\t\t\treturn 3;\n\t\tif(x==3)\n\t\t\treturn 1;\n\t\tif(x==4)\n\t\t\treturn 2;\n\t\tif(x==2)\n\t\t\treturn 4;\n\t\tif(x==5)\n\t\t\treturn 0;\n\t\treturn 5;\n\t}\n\tstatic boolean ref(int h, int g) {\n\t\tif (h == 0 && g == 5)\n\t\t\treturn true;\n\t\tif (h == 1 && g == 3)\n\t\t\treturn true;\n\t\tif (h == 2 && g == 4)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tstatic Queue<Integer> k, k1;\n\tstatic boolean hg = false;\n\n\tstatic void ifCan(int i) {\n\t\tif (i == 6) {\n\t\t\thg = true;\n\t\t\tfor (int j : k)\n\t\t\t\tk1.add(j);\n\t\t\treturn;\n\t\t} else if (k.contains(i))\n\t\t\tifCan(i + 1);\n\t\telse {\n\t\t\tif (!hg) {\n\t\t\t\tfor (int p : can[i]) {\n\t\t\t\t\tif (!k.contains(p)) {\n\t\t\t\t\t\tk.add(i);\n\t\t\t\t\t\tk.add(p);\n\t\t\t\t\t\tifCan(i + 1);\n\t\t\t\t\t\tk.remove(i);\n\t\t\t\t\t\tk.remove(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class qu implements Comparable<qu> {\n\t\tint a;\n\t\tint b;\n\n\t\tqu(int a, int b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn a + \" \" + b;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(qu o) {\n\t\t\treturn b - o.b;\n\t\t}\n\t}\n\n\n\tstatic class pair {\n\t\tint to;\n\t\tint number;\n\n\t\tpair(int t, int n) {\n\t\t\tnumber = n;\n\t\t\tto = t;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn to + \" \" + number;\n\t\t}\n\t}\n\n\tstatic void con() {\n\t\tfor (int i = 0; i < n; i++)\n\t\t\td[i] = new ArrayList();\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (in[i]) {\n\t\t\t\tedge w = ed[i];\n\t\t\t\td[w.from].add(new pair(w.to, w.number));\n\t\t\t\td[w.to].add(new pair(w.from, w.number));\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic boolean[] in;\n\n\t/*\n\t * static void mst() { Arrays.sort(ed); UnionFind uf=new UnionFind(n); for(int\n\t * i=0;i<m;i++) { edge w=ed[i]; if(!uf.union(w.from, w.to)) continue;\n\t * in[i]=true; } }\n\t */\n\tstatic class edge implements Comparable<edge> {\n\t\tint from;\n\t\tint to;\n\t\tint number;\n\n\t\tedge(int f, int t, int n) {\n\t\t\tfrom = f;\n\t\t\tto = t;\n\t\t\tnumber = n;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn from + \" \" + to + \" \" + number;\n\t\t}\n\n\t\tpublic int compareTo(edge f) {\n\t\t\treturn number - f.number;\n\t\t}\n\t}\n\n\tstatic class seg implements Comparable<seg> {\n\t\tint a;\n\t\tint b;\n\n\t\tseg(int s, int e) {\n\t\t\ta = s;\n\t\t\tb = e;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn a + \" \" + b;\n\t\t}\n\n\t\tpublic int compareTo(seg o) {\n\t\t\t// if(a==o.a)\n\t\t\treturn o.b - b;\n\t\t\t// return\n\t\t}\n\t}\n\n\tstatic public class SegmentTree { // 1-based DS, OOP\n\n\t\tint N; // the number of elements in the array as a power of 2 (i.e. after padding)\n\t\tint[] array, sTree, lazy, candies;\n\n\t\tSegmentTree(int[] in) {\n\t\t\tarray = in.clone();\n\t\t\tN = in.length - 1;\n\t\t\tsTree = new int[N << 1]; // no. of nodes = 2*N - 1, we add one to cross out index zero\n\t\t\tlazy = new int[N << 1];\n\t\t\tcandies = new int[N << 1];\n\t\t\tbuild(1, 1, N);\n\t\t\tbuild2(1, 1, N);\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn Arrays.toString(sTree) + \"\\n\" + Arrays.toString(candies);\n\t\t}\n\n\t\tvoid build(int node, int b, int e) // O(n)\n\t\t{\n\t\t\tif (b == e)\n\t\t\t\tsTree[node] = array[b];\n\t\t\telse {\n\t\t\t\tint mid = b + e >> 1;\n\t\t\t\tbuild(node << 1, b, mid);\n\t\t\t\tbuild(node << 1 | 1, mid + 1, e);\n\t\t\t\tsTree[node] = (sTree[node << 1] + sTree[node << 1 | 1]) % 10;\n\t\t\t\tif (sTree[node << 1] + sTree[node << 1 | 1] >= 10)\n\t\t\t\t\tcandies[node]++;\n\t\t\t}\n\t\t}\n\n\t\tvoid build2(int node, int b, int e) // O(n)\n\t\t{\n\t\t\tif (b == e)\n\t\t\t\tb = e;\n\t\t\telse {\n\t\t\t\tint mid = b + e >> 1;\n\t\t\t\tbuild(node << 1, b, mid);\n\t\t\t\tbuild(node << 1 | 1, mid + 1, e);\n\t\t\t\tcandies[node] = (candies[node << 1] + candies[node << 1 | 1]);\n\t\t\t}\n\t\t}\n\n\t\tvoid update_point(int index, int val) // O(log n)\n\t\t{\n\t\t\tindex += N - 1;\n\t\t\tsTree[index] += val;\n\t\t\twhile (index > 1) {\n\t\t\t\tindex >>= 1;\n\t\t\t\tsTree[index] = sTree[index << 1] + sTree[index << 1 | 1];\n\t\t\t}\n\t\t}\n\n\t\tvoid update_range(int i, int j, int val) // O(log n)\n\t\t{\n\t\t\tupdate_range(1, 1, N, i, j, val);\n\t\t}\n\n\t\tvoid update_range(int node, int b, int e, int i, int j, int val) {\n\t\t\tif (i > e || j < b)\n\t\t\t\treturn;\n\t\t\tif (b >= i && e <= j) {\n\t\t\t\tsTree[node] += (e - b + 1) * val;\n\t\t\t\tlazy[node] += val;\n\t\t\t} else {\n\t\t\t\tint mid = b + e >> 1;\n\t\t\t\tpropagate(node, b, mid, e);\n\t\t\t\tupdate_range(node << 1, b, mid, i, j, val);\n\t\t\t\tupdate_range(node << 1 | 1, mid + 1, e, i, j, val);\n\t\t\t\tsTree[node] = sTree[node << 1] + sTree[node << 1 | 1];\n\t\t\t}\n\n\t\t}\n\n\t\tvoid propagate(int node, int b, int mid, int e) {\n\t\t\tlazy[node << 1] += lazy[node];\n\t\t\tlazy[node << 1 | 1] += lazy[node];\n\t\t\tsTree[node << 1] += (mid - b + 1) * lazy[node];\n\t\t\tsTree[node << 1 | 1] += (e - mid) * lazy[node];\n\t\t\tlazy[node] = 0;\n\t\t}\n\n\t\t// static int c=0;\n\t\tint query(int i, int j) {\n\t\t\t// c=0;\n\t\t\treturn query(1, 1, N, i, j);\n\t\t}\n\n\t\tint query(int node, int b, int e, int i, int j) // O(log n)\n\t\t{\n\t\t\tif (i > e || j < b)\n\t\t\t\treturn 0;\n\t\t\tif (b >= i && e <= j)\n\t\t\t\treturn candies[node];\n\t\t\tint mid = b + e >> 1;\n\t\t\t// propagate(node, b, mid, e);\n\t\t\tint q1 = query(node << 1, b, mid, i, j);\n\t\t\tint q2 = query(node << 1 | 1, mid + 1, e, i, j);\n\t\t\treturn q1 + q2;\n\t\t}\n\t}\n\n\tstatic long power(int i) {\n\t\t// if(i==0)\n\t\t// return 1;\n\t\tlong a = 1;\n\t\tfor (int k = 0; k < i; k++)\n\t\t\ta *= i;\n\t\treturn a;\n\t}\n\n\tstatic void seive() {\n\t\tsi = new int[1000001];\n\t\tprimes = new ArrayList<>();\n\t\tint N = 1000001;\n\t\tsi[1] = 1;\n\t\tfor (int i = 2; i < N; i++) {\n\t\t\tif (si[i] == 0) {\n\t\t\t\tsi[i] = i;\n\t\t\t\tprimes.add(i);\n\t\t\t}\n\t\t\tfor (int j = 0; j < primes.size() && primes.get(j) <= si[i] && (i * primes.get(j)) < N; j++)\n\t\t\t\tsi[primes.get(j) * i] = primes.get(j);\n\n\t\t}\n\t}\n\n\tstatic long inver(long x) {\n\t\tint a = (int) x;\n\t\tlong e = (mod - 2);\n\t\tlong res = 1;\n\t\twhile (e > 0) {\n\t\t\tif ((e & 1) == 1) {\n\t\t\t\t// System.out.println(res*a);\n\t\t\t\tres = (int) ((1l * res * a) % mod);\n\t\t\t}\n\t\t\ta = (int) ((1l * a * a) % mod);\n\t\t\te >>= 1;\n\t\t}\n\t\t// out.println(res+\" \"+x);\n\t\treturn res % mod;\n\t}\n\n\tstatic long fac(int n) {\n\t\tif (n == 0)\n\t\t\treturn fac[n] = 1;\n\t\tif (n == 1)\n\t\t\treturn fac[n] = 1;\n\t\tlong ans = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tfac[i] = ans = (i % mod * ans % mod) % mod;\n\t\treturn ans % mod;\n\t}\n\n\tstatic int gcd(int a, int b) {\n\n\t\tif (b == 0)\n\t\t\treturn a;\n\t\treturn gcd(b, a % b);\n\t}\n\n\tstatic class unionfind {\n\t\tint[] p;\n\t\tint[] size, time, val;\n\t\tint l;\n\n\t\tunionfind(int n) {\n\t\t\tp = new int[n * 3];\n\t\t\tsize = new int[n * 3];\n\t\t\tval = new int[n * 3];\n\t\t\tl = n;\n\t\t\tfor (int i = 0; i < p.length; i++) {\n\t\t\t\tp[i] = i;\n\t\t\t}\n\t\t\tArrays.fill(size, 1);\n\t\t}\n\n\t\tint findSet(int v) {\n\t\t\tif (v == p[v])\n\t\t\t\treturn v;\n\t\t\tint t = p[v];\n\t\t\tint f = findSet(p[v]);\n\t\t\tif (t != f)\n\t\t\t\tval[v] += val[t];\n\t\t\treturn p[v] = f;\n\t\t}\n\n\t\tboolean sameSet(int a, int b) {\n\t\t\ta = findSet(a);\n\t\t\tb = findSet(b);\n\t\t\tif (a == b)\n\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\n\t\tint max() {\n\t\t\tint max = 0;\n\t\t\tfor (int i = 0; i < size.length; i++)\n\t\t\t\tif (size[i] > max)\n\t\t\t\t\tmax = size[i];\n\t\t\treturn max;\n\t\t}\n\n\t\tint ans(int i) {\n\t\t\tint o = findSet(i);\n\t\t\treturn val[i];\n\t\t}\n\n\t\tboolean combine(int a, int b, int cost) {\n\t\t\ta = findSet(a);\n\t\t\tb = findSet(b);\n\t\t\tif (a == b)\n\t\t\t\treturn true;\n\t\t\t++l;\n\t\t\tp[a] = l;\n\t\t\tp[b] = l;\n\t\t\tsize[l] = size[a] + size[b];\n\t\t\tval[a] += cost * size[b];\n\t\t\tval[b] += cost * size[a];\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "import math\n\nn, m = map(int, input().split())\nlst = list(map(int, input().split()))\n\nlst.sort()\nlast_val = -1\nfreq_list = []\n\nfor i in range(n):\n\tif lst[i] != last_val:\n\t\tlast_val = lst[i]\n\t\tfreq_list.append(1)\n\telse:\n\t\tfreq_list[-1] += 1\n\nk = len(freq_list)\n\nfor i in range(k, 0, -1):\n\tif n * math.ceil(math.log2(i)) <= m * 8:\n\t\tk = i\n\t\tbreak\n\nmx = 0\ntot = sum(freq_list[:k])\nmx = max(tot, mx)\nfor i in range(k, len(freq_list)):\n\ttot = tot + freq_list[i] - freq_list[i-k]\n\tmx = max(mx, tot)\n\nprint(n-mx)\n\n\n\t \t \t\t\t\t \t \t  \t  \t      \t\t \t\t\t\t"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint b[1000000];\nint main() {\n  int n, i, j;\n  long long int k, ans = 0, x;\n  cin >> n >> i;\n  int ar[n];\n  for (j = 0; j < n; j++) cin >> ar[j];\n  k = i * 8 / n;\n  if (k > 30 || k > n) return cout << 0, 0;\n  k = 1 << k;\n  sort(ar, ar + n);\n  j = i = 0;\n  while (i < n) {\n    b[j]++;\n    while (ar[i] == ar[i + 1]) {\n      b[j]++;\n      i++;\n    }\n    j++;\n    i++;\n  }\n  for (i = 0; i < k; i++) ans += b[i];\n  j = 0;\n  x = ans;\n  for (i = k; i < n; i++) {\n    x = x - b[j] + b[i];\n    j++;\n    ans = max(ans, x);\n  }\n  cout << n - ans;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nimport math\ninput = sys.stdin.readline\n\nn,I=map(int,input().split())\n\narr=list(map(int,input().split()))\n\narr.sort()\ncur=[1]\n\nfor i in range(1,n):\n\tif arr[i]==arr[i-1]:\n\t\tcur[-1]+=1\n\telse:\n\t\tcur.append(1)\n\nb = 2**((8*I)//n)\npre=[0,cur[0]]\nfor i in range(1,len(cur)):\n\tpre.append(cur[i]+pre[-1])\n\nmaxx=0\nfor i in range(b,len(pre)):\n\tif pre[i]-pre[i-b]>maxx:\n\t\tmaxx=pre[i]-pre[i-b]\nif b>=len(pre):\n\tprint(0)\nelse:\n\tprint(n-maxx)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e3;\nconst long long INF = 1e18;\nconst long long MOD = 1e9 + 7;\nconst long double EPS = 1e-4;\nvector<int> primes(1, 2);\nvector<vector<long double>> nk;\nvoid sieve() {\n  vector<int> m(N + 1, 0);\n  for (int i = 4; i < N; i += 2) m[i] = 1;\n  for (int i = 3; i * i <= N; i += 2)\n    if (!m[i])\n      for (int j = i * i; j < N; j += i) m[j] = 1;\n  for (int i = 3; i < N; i += 2)\n    if (!m[i]) primes.push_back(i);\n}\nvoid pascal() {\n  nk = vector<vector<long double>>(N, vector<long double>(N, 0.0));\n  for (int i = (0), ThxMK = (N); i < ThxMK; ++i) nk[i][0] = nk[i][i] = 1.0;\n  for (int i = (1), ThxMK = (N); i < ThxMK; ++i)\n    for (int j = (1), ThxMK = (i); j < ThxMK; ++j)\n      nk[i][j] = nk[i - 1][j - 1] + nk[i - 1][j];\n}\nlong long gcd(long long a, long long b) { return (b ? gcd(b, a % b) : a); }\nlong long lcm(long long a, long long b) {\n  if (a < b) swap(a, b);\n  long long c = gcd(a, b);\n  a /= c;\n  return a * b;\n}\nint popcount(long long x) { return __builtin_popcountll(x); }\nlong long poww(long long a, long long b) {\n  long long res = 1;\n  while (b) {\n    if (b & 1) res = res * a;\n    a = a * a;\n    b /= 2;\n  }\n  return res;\n}\nlong long powm(long long a, long long b) {\n  long long res = 1;\n  while (b) {\n    if (b & 1) res = (res * a) % MOD;\n    a = (a * a) % MOD;\n    b /= 2;\n  }\n  return res;\n}\nbool isPrime(long long x) {\n  if (x == 1) return 0;\n  for (auto i : primes) {\n    if (i * i > x) return 1;\n    if (x % i == 0) return 0;\n  }\n  return 1;\n}\nlong long SUM(long long a, long long b, long long mod = MOD) {\n  return (a + b + mod) % mod;\n}\nlong long PROD(long long a, long long b, long long mod = MOD) {\n  a %= mod;\n  b %= mod;\n  return a * b % mod;\n}\nint dx[4] = {1, -1, 1, -1}, dy[4] = {1, -1, -1, 1};\nvector<vector<int>> graph(int n, int m) {\n  vector<vector<int>> v(n + 1, vector<int>(0));\n  for (int i = (0), ThxMK = (m); i < ThxMK; ++i) {\n    int a, b;\n    cin >> a >> b;\n    v[a].push_back(b);\n    v[b].push_back(a);\n  }\n  return v;\n}\nvoid solve() {\n  long long n, m;\n  cin >> n >> m;\n  long long k = 8 * m / n;\n  if (k > 20) {\n    cout << 0 << '\\n';\n    return;\n  }\n  long long K = 1LL << k;\n  vector<long long> v(n);\n  for (int i = (0), ThxMK = (n); i < ThxMK; ++i) cin >> v[i];\n  sort(begin(v), end(v));\n  vector<long long> x = v;\n  x.resize(distance(x.begin(), unique(begin(x), end(x))));\n  int mx = 0;\n  for (int i = (0), ThxMK = (int(x.size())); i < ThxMK; ++i) {\n    long long p = i + K >= int(x.size()) ? x.back() + 1 : x[i + K];\n    int st = lower_bound(begin(v), end(v), x[i]) - v.begin();\n    int en = lower_bound(begin(v), end(v), p) - v.begin();\n    mx = max(mx, en - st);\n  }\n  cout << n - mx << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 400010;\nint n, I, dang, l, r, k, dapan = 1000000007;\nint a[N], dem[N], L[N], R[N];\nvector<int> b;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(NULL);\n  cin >> n >> I;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  sort(a + 1, a + 1 + n);\n  b.push_back(-1);\n  b.push_back(a[1]);\n  dem[1] = 1;\n  dang = 1;\n  for (int i = 2; i <= n; i++) {\n    if (a[i] == a[i - 1]) {\n      dem[dang]++;\n    } else {\n      b.push_back(a[i]);\n      dang++;\n      dem[dang] = 1;\n    }\n  }\n  for (int i = 2; i <= dang; i++) L[i] = L[i - 1] + dem[i - 1];\n  for (int i = dang - 1; i >= 1; i--) R[i] = R[i + 1] + dem[i + 1];\n  for (int i = 1; i <= dang; i++) {\n    l = i;\n    r = dang;\n    while (l <= r) {\n      int mid = (l + r) / 2;\n      int khoang_cach = mid - i + 1;\n      int soluong = 0;\n      int thaydoi = 0;\n      k = ceil(log2(khoang_cach));\n      soluong = n * k;\n      thaydoi = L[i] + R[mid];\n      if (soluong > 8 * I) {\n        r = mid - 1;\n      } else {\n        dapan = min(thaydoi, dapan);\n        l = mid + 1;\n      }\n    }\n  }\n  cout << dapan;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int x = 0, f = 1, c = getchar();\n  for (; !isdigit(c); c = getchar())\n    if (c == '-') f ^= 1;\n  for (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n  return f ? x : -x;\n}\nint n, I;\nint a[400005];\nvector<int> v;\nint cnt[400005];\nint lg2[400005];\nint sum[400005];\nint main() {\n  n = read(), I = read();\n  for (int i = 0; i < (int)(n); ++i) a[i] = read(), v.push_back(a[i]);\n  for (int i = 2; i <= n; ++i) {\n    for (lg2[i] = 1; (1 << lg2[i]) < i; ++lg2[i])\n      ;\n  }\n  sort(v.begin(), v.end());\n  v.erase(unique(v.begin(), v.end()), v.end());\n  for (int i = 0; i < (int)(n); ++i)\n    cnt[lower_bound(v.begin(), v.end(), a[i]) - v.begin()]++;\n  for (int i = 0; i < (int)(v.size()); ++i) sum[i + 1] = sum[i] + cnt[i];\n  int ans = 0x3f3f3f3f;\n  for (int l = 0; l < (int)(v.size()); ++l) {\n    int lb = l - 1, rb = v.size() - 1;\n    while (lb < rb) {\n      int md = (lb + rb + 1) >> 1;\n      if (lg2[md - l + 1] * n <= I * 8)\n        lb = md;\n      else\n        rb = md - 1;\n    }\n    int r = lb;\n    if (r < l) continue;\n    ans = min(ans, sum[l] + n - sum[r + 1]);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "# Author : nitish420 --------------------------------------------------------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nmod=10**9+7\n# sys.setrecursionlimit(10**6)\n# from functools import lru_cache\nfrom collections import Counter\nfrom math import inf\n\ndef main():\n    n,I=map(int,input().split())\n    arr=list(map(int,input().split()))\n    arr.sort()\n    k=(pow(2,int((I*8)/n)))\n    c=Counter(arr)\n    # print(temp)\n    lst=[arr[0]]\n    for i in range(1,n):\n        if arr[i]!=arr[i-1]:\n            lst.append(arr[i])\n    # print(lst,c,k)\n    ans=inf\n\n    z=n\n\n    n=len(lst)\n    l=0\n    r=k-1\n    if k>=n:\n        print(0)\n        exit()\n    sm=0\n    for i in range(k-1):\n        sm+=c[lst[i]]\n    while r<n:\n        sm+=c[lst[r]]\n        ans=min(ans,z-sm)\n        sm-=c[lst[l]]\n        l+=1\n        r+=1\n    if ans==inf:\n        print(0)\n    else:\n        print(ans)\n        \n\n#----------------------------------------------------------------------------------------\ndef nouse0():\n    # This is to save my code from plag due to use of FAST IO template in it.\n    a=420\n    b=420\n    print(f'i am nitish{(a+b)//2}')\ndef nouse1():\n    # This is to save my code from plag due to use of FAST IO template in it.\n    a=420\n    b=420\n    print(f'i am nitish{(a+b)//2}')\ndef nouse2():\n    # This is to save my code from plag due to use of FAST IO template in it.\n    a=420\n    b=420\n    print(f'i am nitish{(a+b)//2}')\n\n\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = 'x' in file.mode or 'r' not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b'\\n') + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode('ascii'))\n        self.read = lambda: self.buffer.read().decode('ascii')\n        self.readline = lambda: self.buffer.readline().decode('ascii')\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n\n\n\ndef nouse3():\n    # This is to save my code from plag due to use of FAST IO template in it.\n    a=420\n    b=420\n    print(f'i am nitish{(a+b)//2}')\ndef nouse4():\n    # This is to save my code from plag due to use of FAST IO template in it.\n    a=420\n    b=420\n    print(f'i am nitish{(a+b)//2}')\ndef nouse5():\n    # This is to save my code from plag due to use of FAST IO template in it.\n    a=420\n    b=420\n    print(f'i am nitish{(a+b)//2}')\n\n\n\n# endregion\n\nif __name__ == '__main__':\n    main()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 4e5 + 5;\nint n, I;\nint cnt[maxn];\nint a[maxn], b[maxn];\nvoid ReadInput() {\n  cin >> n >> I;\n  for (int i = 1; i <= n; ++i) cin >> a[i];\n  sort(a + 1, a + n + 1);\n  int k = 1;\n  b[1] = 1;\n  for (int i = 2; i <= n; ++i)\n    if (a[i] != a[i - 1])\n      b[i] = ++k;\n    else\n      b[i] = k;\n}\nint Get(int x) {\n  long long tmp = 1;\n  int res = 0;\n  while (tmp * 2 <= x) {\n    tmp *= 2;\n    res++;\n  }\n  if (tmp < x) res++;\n  return res;\n}\nbool Check(int k) {\n  fill(begin(cnt), end(cnt), 0);\n  int c = 0;\n  for (int i = 1; i <= k; ++i) {\n    cnt[b[i]]++;\n    if (cnt[b[i]] == 1) c++;\n  }\n  int mem = Get(c);\n  if ((long long)mem * n <= 8LL * I) return true;\n  int l = 2, r = k + 1;\n  while (r <= n) {\n    cnt[b[l - 1]]--;\n    if (cnt[b[l - 1]] == 0) c--;\n    cnt[b[r]]++;\n    if (cnt[b[r]] == 1) c++;\n    int mem = Get(c);\n    if ((long long)mem * n <= 8LL * I) return true;\n    l++;\n    r++;\n  }\n  return false;\n}\nvoid Solve() {\n  int low = 1, high = n;\n  while (low <= high) {\n    int mid = (low + high) / 2;\n    if (Check(mid))\n      low = mid + 1;\n    else\n      high = mid - 1;\n  }\n  cout << n - high;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  ReadInput();\n  Solve();\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n \n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n \n    static class TaskA {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int bits = Math.min(25, in.nextInt() * 8 / n);\n            int maxUnique = 1 << bits;\n            int[] a = new int[n];\n            for (int i = 0; i < n; ++i) a[i] = in.nextInt();\n            Random random = new Random(5734153453315151L + System.currentTimeMillis());\n            for (int i = 0; i < n; ++i) {\n                int j = random.nextInt(i + 1);\n                int t = a[i];\n                a[i] = a[j];\n                a[j] = t;\n            }\n            Arrays.sort(a);\n            int[] uid = new int[n];\n            for (int i = 1; i < n; ++i) {\n                uid[i] = uid[i - 1];\n                if (a[i] > a[i - 1]) ++uid[i];\n            }\n            int left = 0;\n            int res = n;\n            for (int right = 0; right < n; ++right) {\n                while (left <= right && uid[right] - uid[left] + 1 > maxUnique) ++left;\n                res = Math.min(res, n - (right - left + 1));\n            }\n            out.println(res);\n        }\n \n    }\n \n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n \n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n \n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n \n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n \n    }\n}\n "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 4e5 + 10;\nlong long arr[N];\nlong long pre[N];\nlong long n, I;\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cin >> n >> I;\n  map<long long, long long> mp;\n  for (long long i = 1; i <= n; i++) {\n    cin >> arr[i];\n    mp[arr[i]]++;\n  }\n  I *= 8;\n  I /= n;\n  if (I > 20) {\n    cout << 0;\n    return 0;\n  }\n  long long tot = mp.size();\n  I = (1 << I);\n  if (I >= tot) {\n    cout << 0;\n    return 0;\n  }\n  long long at = 0;\n  for (auto i : mp) {\n    at++;\n    pre[at] = pre[at - 1] + i.second;\n  }\n  long long ans = INT_MAX, max_K = I;\n  for (long long i = 1; i + max_K - 1 <= tot; i++) {\n    ans = min(ans, n - (pre[i + max_K - 1] - pre[i - 1]));\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "\nn,i=map(int,input().split(' '))\nsound=list(map(int,input().split(' ')))\nsound.sort()\nlimit=2**((i*8)//n)\nl=[0]\nfor i in range(1,n):\n    if(sound[i-1]!=sound[i]):\n        l.append(i)\nif(len(l)<=limit):\n    print('0')\nelse:\n    print(n-max(l[i+limit]-l[i] for i in range(len(l)-limit)))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3c3c3c3c;\nconst long long LINF = 1ll * INF * INF * 2;\nconst int N = 1000001;\nint n, m, k, K;\nint x[N];\nvector<int> v;\nint cnt[N];\nint psum[N];\nint ssum[N];\nint num;\nint main(void) {\n  scanf(\"%d%d\", &n, &m);\n  k = m * 8 / n;\n  for (int i = 0; i < n; i++) scanf(\"%d\", x + i);\n  sort(x, x + n);\n  for (int i = 0; i < n; i++) {\n    if (i == 0 || x[i] != x[i - 1]) {\n      num++;\n      cnt[num] = 1;\n    } else\n      cnt[num]++;\n  }\n  if (!((num - 1) >> k) || k > 20) {\n    printf(\"0\");\n    return 0;\n  }\n  K = (1 << k);\n  ssum[num + 1] = 0;\n  for (int i = num; i >= 1; i--) ssum[i] = ssum[i + 1] + cnt[i];\n  psum[0] = 0;\n  for (int i = 1; i <= num; i++) psum[i] = psum[i - 1] + cnt[i];\n  int ans = INF;\n  for (int i = 1; i <= num - K + 1; i++) {\n    ans = min(psum[i - 1] + ssum[K + i], ans);\n  }\n  printf(\"%d\", ans);\n}\n"
        },
        {
            "language": 3,
            "solution": "n,i= map(int, input().split())\nl= list(map(int, input().split()))\nk= (8*i)//n\nK= 2**k\nl.sort()\ntemp= [0]\nfor i in range(1,n):\n    if(l[i-1]!=l[i]):\n        temp.append(i)\nif(len(temp)<=K):\n    print(0)\nelse:\n    print(n - max(temp[i+K]-temp[i] for i in range(len(temp)-K)))"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Main\n\n{ \n\t static FastReader sc=new FastReader(); \n\t static long dp[][][];\n\t static int mod=1000000007;\n\t \n\t  public static void main(String[] args)  throws IOException\n{\n\t\t    //CHECK FOR N=1\n       \t//CHECK FOR N=1\n\t    //CHECK FOR N=1\t\t\t\n       \t//CHECK FOR N=1\n\t\t  \n\t\t  \n\t\t  \n\t\t   PrintWriter out=new PrintWriter(System.out);\n\t\t   StringBuffer sb=new StringBuffer(\"\");\n\t\t  int ttt=1;\n\t\t//ttt =i(); \t\n\t\t   \n\t        outer :while (ttt-- > 0) \n\t\t\t{\n\t        \tint n=i();\n\t        \tint k=i()*8;\n\t        \tint y=(int)(Math.pow(2, Math.min(20, k/n)));\n//\t        \tint y=(int)Math.pow(2, (k/(double)n));\n//\t        \t//long aa=(long)Math.ceil(Math.log(y)/Math.log(2))*n;\n//\t        \tlong l=1;\n//\t        \tlong u=y;\n//\t        \tlong res=0;\n//\t        \twhile(l<=u) {\n//\t        \t\tlong mid=(l+u)/2;\n//\t        \t\tlong aa=(long)Math.ceil(Math.log(mid)/Math.log(2))*n;\n//\t        \t\t//System.out.println(mid);\n//\t        \t\tif(aa>k) {\n//\t        \t\t\tu=mid-1;\n//\t        \t\t}\n//\t        \t\telse {\n//\t        \t\t\tres=mid;\n//\t        \t\t\tl=mid+1;\n//\t        \t\t}\n//\t        \t}\n//\t        \ty=(int)res;\n\t        \t\n\t        \tint A[]=input(n);\n\t        \tHashMap<Integer,Integer> map=hash(A);\n\t        \tif(map.size()<=y) {\n\t        \t\tSystem.out.println(\"0\");\n\t        \t\treturn;\n\t        \t}\n\t        \tint B[]=new int[map.size()];\n\t        \tn=map.size();\n\n\t        \tA=new int[n];\n\t        \tint c=0;\n\t        \tPair C[]=new Pair[n];\n\t        \t\n\t        \tfor(int key : map.keySet()) {\n\t        \t\tC[c]=new Pair(key,(int)map.get(key));\n\t        \t\tc++;\n\t        \t}\n\t        \tArrays.sort(C);\n\t        \tint D[]=new int[n];\n\t        \tfor(int i=0;i<n;i++) {\n\t        \t\tA[i]=C[i].x;\n\t        \t\tB[i]=C[i].y;\n\t        \t}\n\t        \tD[n-1]=B[n-1];\n\t        \tfor(int i=n-2;i>=0;i--) {\n\t        \t\tD[i]=D[i+1]+B[i];\n\t        \t}\n\t        \tint ans=Integer.MAX_VALUE;\n\t        \tfor(int i=0;i<n;i++) {\n\t        \t\tif(i+y-1<n) {\n\t        \t\t\tint op1=D[0]-(D[i]);\n\t        \t\t\tif(i+y<n) {\n\t        \t\t\t\top1+=D[i+y];\n\t        \t\t\t}\n\t        \t\t\tans=Math.min(ans, op1);\n\t        \t\t}\n\t        \t}\n\t        \tSystem.out.println(ans);\n\t        \n\t        \t\n\n\t        \n\t        \n\t        \t\n\t            \n\t\t\t}\n\t\t\n\n\t     //System.out.println(sb.toString());\n\t\t     out.close();\n\t     \n\t     \n\t    //CHECK FOR N=1                    //CHECK FOR M=0\n        //CHECK FOR N=1                    //CHECK FOR M=0\n       \t//CHECK FOR N=1\n       \t//CHECK FOR N=1\n       \t//CHECK FOR N=1\n\t\t        \n\t\t     \n    }\n\t\t\n\n\n\n\nstatic int[] input(int n) {\n\tint A[]=new int[n];\n\t   for(int i=0;i<n;i++) {\n\t\t   A[i]=sc.nextInt();\n\t   }\n\t   return A;\n   }\nstatic long[] inputL(int n) {\n\tlong A[]=new long[n];\n\t   for(int i=0;i<n;i++) {\n\t\t   A[i]=sc.nextLong();\n\t   }\n\t   return A;\n   }\nstatic String[] inputS(int n) {\n\tString A[]=new String[n];\n\t   for(int i=0;i<n;i++) {\n\t\t   A[i]=sc.next();\n\t   }\n\t   return A;\n   }\nstatic long sum(int A[]) {\n\tlong sum=0;\n\tfor(int i : A) {\n\t\tsum+=i;\n\t}\n\treturn sum;\n}\nstatic long sum(long A[]) {\n\tlong sum=0;\n\tfor(long i : A) {\n\t\tsum+=i;\n\t}\n\treturn sum;\n}\nstatic void reverse(long A[]) {\n\tint n=A.length;\n\tlong B[]=new long[n];\n\tfor(int i=0;i<n;i++) {\n\t\tB[i]=A[n-i-1];\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tA[i]=B[i];\n\t\n}\nstatic void reverse(int A[]) {\n\tint n=A.length;\n\tint B[]=new int[n];\n\tfor(int i=0;i<n;i++) {\n\t\tB[i]=A[n-i-1];\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tA[i]=B[i];\n\t\n}\nstatic void input(int A[],int B[]) {\n\t   for(int i=0;i<A.length;i++) {\n\t\t   A[i]=sc.nextInt();\n\t\t   B[i]=sc.nextInt();\n\t   }\n}\nstatic int[][] input(int n,int m){\n\tint A[][]=new int[n][m];\n\tfor(int i=0;i<n;i++) {\n\t\tfor(int j=0;j<m;j++) {\n\t\t\tA[i][j]=i();\n\t\t}\n\t}\n\treturn A;\n}\nstatic char[][] charinput(int n,int m){\n\tchar A[][]=new char[n][m];\n\tfor(int i=0;i<n;i++) {\n\t\tString s=s();\n\t\tfor(int j=0;j<m;j++) {\n\t\t\tA[i][j]=s.charAt(j);\n\t\t}\n\t}\n\treturn A;\n}\nstatic int max(int A[]) {\n\tint max=Integer.MIN_VALUE;\n\tfor(int i=0;i<A.length;i++) {\n\t\tmax=Math.max(max, A[i]);\n\t}\n\treturn max;\n}\nstatic int min(int A[]) {\n\tint min=Integer.MAX_VALUE;\n\tfor(int i=0;i<A.length;i++) {\n\t\tmin=Math.min(min, A[i]);\n\t}\n\treturn min;\n}\nstatic long max(long A[]) {\n\tlong max=Long.MIN_VALUE;\n\tfor(int i=0;i<A.length;i++) {\n\t\tmax=Math.max(max, A[i]);\n\t}\n\treturn max;\n}\nstatic long min(long A[]) {\n\tlong min=Long.MAX_VALUE;\n\tfor(int i=0;i<A.length;i++) {\n\t\tmin=Math.min(min, A[i]);\n\t}\n\treturn min;\n}\nstatic long [] prefix(long A[]) {\n\tlong p[]=new long[A.length];\n\tp[0]=A[0];\n\tfor(int i=1;i<A.length;i++)\n\t\tp[i]=p[i-1]+A[i];\n\treturn p;\n}\nstatic long [] prefix(int A[]) {\n\tlong p[]=new long[A.length];\n\tp[0]=A[0];\n\tfor(int i=1;i<A.length;i++)\n\t\tp[i]=p[i-1]+A[i];\n\treturn p;\n}\nstatic long [] suffix(long A[]) {\n\tlong p[]=new long[A.length];\n\tp[A.length-1]=A[A.length-1];\n\tfor(int i=A.length-2;i>=0;i--)\n\t\tp[i]=p[i+1]+A[i];\n\treturn p;\n}\nstatic long [] suffix(int A[]) {\n\tlong p[]=new long[A.length];\n\tp[A.length-1]=A[A.length-1];\n\tfor(int i=A.length-2;i>=0;i--)\n\t\tp[i]=p[i+1]+A[i];\n\treturn p;\n}\nstatic void print(int A[]) {\n\tfor(int i : A) {\n\t\tSystem.out.print(i+\" \");\n\t}\n\tSystem.out.println();\n}\nstatic void print(long A[]) {\n\tfor(long i : A) {\n\t\tSystem.out.print(i+\" \");\n\t}\n\tSystem.out.println();\n}\nstatic long mod(long x) {\n\t int mod=1000000007;\n\t  return ((x%mod + mod)%mod);\n}\nstatic String reverse(String s) {\n\tStringBuffer p=new StringBuffer(s);\n\tp.reverse();\n\treturn p.toString();\n}\n\n     static int i() {\n    \t return sc.nextInt();\n     }\n     static String s() {\n    \t return sc.next();\n     }\n     static long l() {\n    \t return sc.nextLong();\n     }  \n     static void sort(int[] A){\n        int n = A.length;\n        Random rnd = new Random();\n        for(int i=0; i<n; ++i){\n            int tmp = A[i];\n            int randomPos = i + rnd.nextInt(n-i);\n            A[i] = A[randomPos];\n            A[randomPos] = tmp;\n        }\n        Arrays.sort(A);\n     }\n     static void sort(long[] A){\n\t        int n = A.length;\n\t        Random rnd = new Random();\n\t        for(int i=0; i<n; ++i){\n\t            long tmp = A[i];\n\t            int randomPos = i + rnd.nextInt(n-i);\n\t            A[i] = A[randomPos];\n\t            A[randomPos] = tmp;\n\t        }\n\t        Arrays.sort(A);\n\t     }\n  static String sort(String s) {\n \t Character ch[]=new Character[s.length()];\n \t for(int i=0;i<s.length();i++) {\n \t\t ch[i]=s.charAt(i);\n \t }\n \t Arrays.sort(ch);\n \t StringBuffer st=new StringBuffer(\"\");\n \t for(int i=0;i<s.length();i++) {\n \t\t st.append(ch[i]);\n \t }\n \t return st.toString();\n  }\n  static HashMap<Integer,Integer> hash(int A[]){\n\t  HashMap<Integer,Integer> map=new HashMap<Integer, Integer>();\n\t  for(int i : A) {\n\t\t  if(map.containsKey(i)) {\n\t\t\t  map.put(i, map.get(i)+1);\n\t\t  }\n\t\t  else {\n\t\t\t  map.put(i, 1);\n\t\t  }\n\t  }\n\t  return map;\n  }\n  static TreeMap<Integer,Integer> tree(int A[]){\n\t  TreeMap<Integer,Integer> map=new TreeMap<Integer, Integer>();\n\t  for(int i : A) {\n\t\t  if(map.containsKey(i)) {\n\t\t\t  map.put(i, map.get(i)+1);\n\t\t  }\n\t\t  else {\n\t\t\t  map.put(i, 1);\n\t\t  }\n\t  }\n\t  return map;\n  }\n     static boolean prime(int n) \n\t    { \n\t        if (n <= 1) \n\t            return false; \n\t        if (n <= 3) \n\t            return true; \n\t        if (n % 2 == 0 || n % 3 == 0) \n\t            return false; \n\t        double sq=Math.sqrt(n);\n\t  \n\t        for (int i = 5; i <= sq; i = i + 6) \n\t            if (n % i == 0 || n % (i + 2) == 0) \n\t                return false; \n\t        return true; \n\t    } \n     static boolean prime(long n) \n\t    { \n\t        if (n <= 1) \n\t            return false; \n\t        if (n <= 3) \n\t            return true; \n\t        if (n % 2 == 0 || n % 3 == 0) \n\t            return false; \n\t        double sq=Math.sqrt(n);\n\t  \n\t        for (int i = 5; i <= sq; i = i + 6) \n\t            if (n % i == 0 || n % (i + 2) == 0) \n\t                return false; \n\t        return true; \n\t    } \n     static int gcd(int a, int b) \n     { \n         if (a == 0) \n             return b; \n         return gcd(b % a, a); \n     } \n     static long gcd(long a, long b) \n     { \n         if (a == 0) \n             return b; \n         return gcd(b % a, a); \n     } \n     static class Pair implements Comparable<Pair>\n     {\n    \t int x;\n    \t int y;\n    \t Pair(int x,int y){\n    \t\t this.x=x;\n    \t\t this.y=y;\n    \t }\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif(this.x>o.x)\n\t\t\t\treturn 1;\n\t\t\telse if(this.x<o.x)\n\t\t\t\treturn -1;\n\t\t\telse {\n\t\t\t\tif(this.y>o.y)\n\t\t\t\t\treturn 1;\n\t\t\t\telse if(this.y<o.y)\n\t\t\t\t\treturn -1;\n\t\t\t\telse\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\n\t\t\n     }\n        \n    static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n} \n\n\n\n"
        },
        {
            "language": 3,
            "solution": "from math import log2, ceil\nn, k = map(int, input().split())\nk *= 8\na = sorted(list(map(int, input().split())))\nq1, dif = 0, 1\nans = float('inf')\nfor q in range(n):\n    while n*ceil(log2(dif)) <= k and q1 < n:\n        if q1 == n-1 or a[q1] != a[q1+1]:\n            dif += 1\n        q1 += 1\n    ans = min(ans, q+n-q1)\n    if q != n-1 and a[q] != a[q+1]:\n        dif -= 1\nprint(ans)\n"
        },
        {
            "language": 3,
            "solution": "from bisect import bisect_right, bisect_left\nfrom collections import Counter\n\nN, I = map(int, input().split())\nA = list(map(int, input().split()))\n\nA.sort()\nK = 2**(I*8//N)\nB = list(Counter(A).keys())\nbb = len(B)\n\nans = N\nfor i, l in enumerate(A):\n    b = bisect_left(B, l)\n    j = bisect_right(A, B[min(b+K-1, bb-1)])\n    ans = min(N-(j-i), ans)\nprint(ans)"
        },
        {
            "language": 3,
            "solution": "n,I=map(int,input().strip().split())\nnumbers=list(map(int,input().strip().split()))\nnum_bytes=(8*I)//n\nnumbers.sort()\nimport math as mm\nd={}\nlst=[]\nfor k in range(0,len(numbers)):\n    if(numbers[k] in d.keys()):\n        d[numbers[k]]+=1\n    else:\n        d[numbers[k]] =1\n        lst.append(numbers[k])\n\nqt = n-d[lst[-1]]\nstart=len(lst)-1\nend  =len(lst)\nchanged=qt\nwhile(start>=1):\n    start -= 1\n    qt -= d[lst[start]]\n    while(mm.ceil(mm.log2(end-start))>num_bytes ):\n        end -= 1\n        qt += d[lst[end]]\n    if(qt<changed):\n        changed=qt\n\nprint(changed)\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int n, I;\n  cin >> n >> I;\n  long long int k = 8 * I / n;\n  if (k >= 21) {\n    cout << \"0\"\n         << \"\\n\";\n  } else {\n    map<int, int> m;\n    int val;\n    for (int i = 0; i < n; i++) {\n      cin >> val;\n      m[val]++;\n    }\n    int len = 1 << k;\n    if (len >= m.size()) {\n      cout << \"0\"\n           << \"\\n\";\n    } else {\n      vector<int> cnts;\n      for (auto el : m) {\n        cnts.push_back(el.second);\n      }\n      int mx = 0;\n      int cur = 0;\n      for (int i = 0; i < len; i++) {\n        cur = cur + cnts[i];\n      }\n      mx = cur;\n      for (int i = len; i < cnts.size(); i++) {\n        cur = cur + cnts[i] - cnts[i - len];\n        mx = max(cur, mx);\n      }\n      cout << n - mx << \"\\n\";\n    }\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "//package CodeforcesProject;\n\nimport java.io.*;\nimport java.lang.*;\nimport java.util.*;\n\npublic class Main extends IO {\n\n    public static void main(String[] args) throws Exception {\n        int[] quantity = ReadArrayInt(\" \"), base = ReadArrayInt(\" \");\n        Map<Integer, Integer> count = new TreeMap<>();\n        Arrays.stream(base).forEach(value -> count.merge(value, 1, Integer::sum));\n        List<Pair<Integer, Integer>> array = new ArrayList<>();\n        count.forEach((value, value1) -> array.add(Pair.createPair(value, value1)));\n        int size = quantity[1] * 8 / quantity[0], substract = 1 << size, answer = Integer.MIN_VALUE;\n        if (substract >= count.size() || size > 30){\n            System.out.println(0);\n            return;\n        }\n        int sum = array.stream().limit(substract).mapToInt(Pair::getSecondElement).sum();\n        for (int i = substract; i < array.size(); i++) {\n            sum += (array.get(i).getSecondElement() - array.get(i - substract).getSecondElement());\n            answer = Math.max(sum, answer);\n        }\n        System.out.print(quantity[0] - answer);\n    }\n}\n\nclass math{\n\n    public static int gcd(int a, int b) { // NOD\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    public static long gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    public static float gcd(float a, float b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    public static double gcd(double a, double b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    public static double lcm(double a, double b) { // NOK\n        return a / gcd(a, b) * b;\n    }\n\n    public static float lcm(float a, float b) { // NOK\n        return a / gcd(a, b) * b;\n    }\n\n    public static int lcm(int a, int b) { // NOK\n        return a / gcd(a, b) * b;\n    }\n\n    public static long lcm(long a, long b) {\n        return a / gcd(a, b) * b;\n    }\n    public static double log (double value, int base){\n        return Math.log(value)/Math.log(base);\n    }\n}\n\nclass Fraction<T extends Number> extends Pair {\n\n    private Fraction(T dividend, T divider) {\n        super(dividend, divider);\n        reduce();\n    }\n\n    public static <K extends Number> Fraction<K> createDivision(K dividend, K divider) {\n        return new Fraction<>(dividend, divider);\n    }\n\n    public void reduce() {\n        if (getFirstElement() instanceof Integer) {\n            Integer Dividend = (Integer) getFirstElement();\n            Integer Divider = (Integer) getSecondElement();\n            int gcd = math.gcd(Dividend, Divider);\n            setFirstElement(Dividend / gcd);\n            setSecondElement(Divider / gcd);\n        } else if (getFirstElement() instanceof Long) {\n            Long Dividend = (Long) getFirstElement();\n            Long Divider = (Long) getSecondElement();\n            long gcd = math.gcd(Dividend, Divider);\n            setFirstElement(Dividend / gcd);\n            setSecondElement(Divider / gcd);\n        } else if (getFirstElement() instanceof Float) {\n            Float Dividend = (Float) getFirstElement();\n            Float Divider = (Float) getSecondElement();\n            float gcd = math.gcd(Dividend, Divider);\n            setFirstElement(Dividend / gcd);\n            setSecondElement(Divider / gcd);\n        } else if (getFirstElement() instanceof Double) {\n            Double Dividend = (Double) getFirstElement();\n            Double Divider = (Double) getSecondElement();\n            double gcd = math.gcd(Dividend, Divider);\n            setFirstElement(Dividend / gcd);\n            setSecondElement(Divider / gcd);\n        }\n    }\n\n    public void addWithoutReturn(Fraction number) throws UnsupportedOperationException {\n        add(number, 0);\n    }\n\n    private Fraction add(Fraction number, int function) throws UnsupportedOperationException {\n        if (getFirstElement() instanceof Integer && number.getFirstElement() instanceof Integer) {\n            Integer Dividend = (Integer) getFirstElement();\n            Integer Divider = (Integer) getSecondElement();\n            Integer Dividend1 = (Integer) number.getFirstElement();\n            Integer Divider1 = (Integer) number.getSecondElement();\n            Integer lcm = math.lcm(Divider, Divider1);\n            if (function == 0) {\n                setFirstElement((lcm / Divider) * Dividend + (lcm / Divider1) * Dividend1);\n                setSecondElement(lcm);\n                reduce();\n                return null;\n            }\n            Fraction result = Fraction.createDivision((lcm / Divider) * Dividend + (lcm / Divider1) * Dividend1, lcm);\n            result.reduce();\n            return result;\n\n        } else if (getFirstElement() instanceof Long && number.getFirstElement() instanceof Long) {\n            Long Dividend = (Long) getFirstElement();\n            Long Divider = (Long) getSecondElement();\n            Long Dividend1 = (Long) number.getFirstElement();\n            Long Divider1 = (Long) number.getSecondElement();\n            Long lcm = math.lcm(Divider, Divider1);\n            if (function == 0) {\n                setFirstElement((lcm / Divider) * Dividend + (lcm / Divider1) * Dividend1);\n                setSecondElement(lcm);\n                reduce();\n                return null;\n            }\n            Fraction result = Fraction.createDivision((lcm / Divider) * Dividend + (lcm / Divider1) * Dividend1, lcm);\n            result.reduce();\n            return result;\n        } else if (getFirstElement() instanceof Float && number.getFirstElement() instanceof Float) {\n            Float Dividend = (Float) getFirstElement();\n            Float Divider = (Float) getSecondElement();\n            Float Dividend1 = (Float) number.getFirstElement();\n            Float Divider1 = (Float) number.getSecondElement();\n            Float lcm = math.lcm(Divider, Divider1);\n            if (function == 0) {\n                setFirstElement((lcm / Divider) * Dividend + (lcm / Divider1) * Dividend1);\n                setSecondElement(lcm);\n                reduce();\n                return null;\n            }\n            Fraction result = Fraction.createDivision((lcm / Divider) * Dividend + (lcm / Divider1) * Dividend1, lcm);\n            result.reduce();\n            return result;\n        } else if (getFirstElement() instanceof Double && number.getFirstElement() instanceof Double) {\n            Double Dividend = (Double) getFirstElement();\n            Double Divider = (Double) getSecondElement();\n            Double Dividend1 = (Double) number.getFirstElement();\n            Double Divider1 = (Double) number.getSecondElement();\n            Double lcm = math.lcm(Divider, Divider1);\n            if (function == 0) {\n                setFirstElement((lcm / Divider) * Dividend + (lcm / Divider1) * Dividend1);\n                setSecondElement(lcm);\n                reduce();\n                return null;\n            }\n            Fraction result = Fraction.createDivision((lcm / Divider) * Dividend + (lcm / Divider1) * Dividend1, lcm);\n            result.reduce();\n            return result;\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    public Fraction addWithReturn(Fraction number) {\n        return add(number, 1);\n    }\n\n    public void multiplyWithoutReturn(Fraction number) throws UnsupportedOperationException {\n        multiply(number, 0);\n    }\n\n    public Fraction multiplyWithReturn(Fraction number) throws UnsupportedOperationException {\n        return multiply(number, 1);\n    }\n\n    private Fraction multiply(Fraction number, int function) throws UnsupportedOperationException {\n        if (getFirstElement() instanceof Integer && number.getFirstElement() instanceof Integer) {\n            Integer first = (Integer) getFirstElement() * (Integer) number.getFirstElement();\n            Integer second = (Integer) getSecondElement() * (Integer) number.getSecondElement();\n            if (function == 0) {\n                setFirstElement(first);\n                setSecondElement(second);\n                reduce();\n                return null;\n            }\n            Fraction answer = Fraction.createDivision(first, second);\n            answer.reduce();\n            return answer;\n        } else if (getFirstElement() instanceof Long && number.getFirstElement() instanceof Long) {\n            Long first = (Long) getFirstElement() * (Long) number.getFirstElement();\n            Long second = (Long) getSecondElement() * (Long) number.getSecondElement();\n            if (function == 0) {\n                setFirstElement(first);\n                setSecondElement(second);\n                reduce();\n                return null;\n            }\n            Fraction answer = Fraction.createDivision(first, second);\n            answer.reduce();\n            return answer;\n\n        } else if (getFirstElement() instanceof Float && number.getFirstElement() instanceof Float) {\n            Float first = (Float) getFirstElement() * (Float) number.getFirstElement();\n            Float second = (Float) getSecondElement() * (Float) number.getSecondElement();\n            if (function == 0) {\n                setFirstElement(first);\n                setSecondElement(second);\n                reduce();\n                return null;\n            }\n            Fraction answer = Fraction.createDivision(first, second);\n            answer.reduce();\n            return answer;\n        } else if (getFirstElement() instanceof Double && number.getFirstElement() instanceof Double) {\n            Double first = (Double) getFirstElement() * (Double) number.getFirstElement();\n            Double second = (Double) getSecondElement() * (Double) number.getSecondElement();\n            if (function == 0) {\n                setFirstElement(first);\n                setSecondElement(second);\n                reduce();\n                return null;\n            }\n            Fraction answer = Fraction.createDivision(first, second);\n            answer.reduce();\n            return answer;\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    }\n}\n\nclass Pair<T, T1> {\n\n    private T first;\n    private T1 second;\n\n    Pair(T obj, T1 obj1) {\n        first = obj;\n        second = obj1;\n    }\n\n    protected static <K, V> Pair<K, V> createPair(K element, V element1) {\n        return new Pair<>(element, element1);\n    }\n\n    public T getFirstElement() {\n        return first;\n    }\n\n    public T1 getSecondElement() {\n        return second;\n    }\n\n    public void setFirstElement(T element) {\n        first = element;\n    }\n\n    public void setSecondElement(T1 element) {\n        second = element;\n    }\n\n    @Override\n    public Pair<T, T1> clone() {\n        return createPair(getFirstElement(), getSecondElement());\n    }\n\n    @Override\n    public int hashCode() {\n        return 1;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (obj instanceof Pair) {\n            return (getFirstElement() == ((Pair) obj).getFirstElement()) && (getSecondElement() == ((Pair) obj).getSecondElement());\n        }\n        return false;\n    }\n\n}\n\nclass Graph {\n\n    private int[][] base;\n    private boolean[] used;\n    private int quantity;\n    private Integer[] ancestor;\n\n    public int[][] getBase() {\n        return base.clone();\n    }\n\n    public boolean[] getUsed() {\n        return used.clone();\n    }\n\n    public int getQuantity() {\n        return quantity;\n    }\n\n    public Integer[] getAncestor() {\n        return ancestor.clone();\n    }\n\n    public void start(int length) {\n        used = new boolean[length];\n        ancestor = new Integer[length];\n        ancestor[0] = -1;\n        quantity = 0;\n    }\n\n    public void ribMatrixToDefault(int length, int quantity) throws Exception {\n        base = new int[length][];\n        List<ArrayList<Integer>> inputBase = new ArrayList<>();\n        for (int i = 0; i < length; i++) {\n            inputBase.add(new ArrayList<>());\n        }\n        Array x = (int[] input) -> {\n            inputBase.get(input[0] - 1).add(input[1] - 1);\n            //inputBase.get(input[0] - 1).add(input[2]); // price\n            inputBase.get(input[1] - 1).add(input[0] - 1);\n            //nputBase.get(input[1] - 1).add(input[2]); // price\n        };\n        for (int i = 0; i < quantity; i++) {\n            x.useArray(IO.ReadArrayInt(\" \"));\n        }\n        for (int i = 0; i < length; i++) {\n            base[i] = inputBase.get(i).parallelStream().mapToInt(Integer::intValue).toArray();\n        }\n        start(length);\n    }\n\n    public void adjacencyMatrixToDefault(int length, int not) throws Exception {\n        base = new int[length][];\n        List<Integer> buffer = new ArrayList<>();\n        int[] InputArray;\n        for (int i = 0; i < length; i++) {\n            InputArray = IO.ReadArrayInt(\" \");\n            for (int index = 0; index < length; index++) {\n                if (i != index && InputArray[index] != not) {\n                    buffer.add(index);\n                    buffer.add(InputArray[index]);\n                }\n            }\n            base[i] = buffer.stream().mapToInt(element -> element).toArray();\n            buffer.clear();\n        }\n        start(length);\n    }\n\n    public void dfs(int position) throws Exception {\n        used[position] = true;\n        quantity++;\n        int next;\n        for (int index = 0; index < base[position].length; index += 2) {\n            next = base[position][index];\n            if (!used[next]) {\n                ancestor[next] = position;\n                dfs(next);\n            } else {\n                if (next != ancestor[position]) { // if cycle\n                    throw new Exception();\n                }\n            }\n        }\n    }\n\n    public static int getInt(int[] a){\n        return a[1];\n    }\n\n    public int dijkstra(int start, int stop, int size) {\n        start--;\n        stop--;\n        int[] dist = new int[size];\n        for (int i = 0; i < size; i++) {\n            if (i != start) {\n                dist[i] = Integer.MAX_VALUE;\n            }\n            ancestor[i] = start;\n        }\n\n        Queue<int[]> queue = new PriorityQueue<>((int[] first, int[] second) -> Integer.compare(first[1], second[1]));\n        queue.add(new int[]{start, 0});\n        int position;\n        int[] getQueue;\n        while (queue.size() != 0) {\n            getQueue = queue.poll();\n            position = getQueue[0];\n            if (getQueue[1] > dist[position]) {\n                continue;\n            }\n            for (int index = 0; index < base[position].length; index += 2) {\n                if (dist[position] + base[position][index + 1] < dist[base[position][index]] && !used[base[position][index]]) {\n                    dist[base[position][index]] = dist[position] + base[position][index + 1];\n                    ancestor[base[position][index]] = position;\n                    queue.add(new int[]{base[position][index], dist[base[position][index]]});\n                }\n            }\n            used[position] = true;\n        }\n        return dist[stop] == Integer.MAX_VALUE ? -1 : dist[stop];\n    }\n\n    public boolean floydWarshall(int[][] base, int length, int dont) {\n        for (int k = 0; k < length; k++) {\n            for (int i = 0; i < length; i++) {\n                for (int j = 0; j < length; j++) {\n                    if (base[i][k] == dont || base[k][j] == dont) {\n                        continue;\n                    }\n                    int total = base[i][k] + base[k][j];\n                    if (base[i][j] != dont) {\n                        base[i][j] = Math.min(base[i][j], total);\n                    } else {\n                        base[i][j] = total;\n                    }\n                }\n            }\n        }\n        for (int index = 0; index < length; index++) {\n            if (base[index][index] != 0) { // if cycle\n                return false;\n            }\n\n        }\n        return true;\n    }\n}\n\ninterface Array {\n    void useArray(int[] a);\n}\n\ninterface Method {\n    void use();\n}\n\n\nclass FastSort {\n\n\n    public static void SortWithoutReturn(int[] array, int length, int ShellHeapMergeMyInsertionSort) {\n        sort(array, ShellHeapMergeMyInsertionSort, length);\n    }\n\n    public static int[] SortWithReturn(int[] array, int length, int ShellHeapMergeMyInsertionSort) {\n        int[] base = array.clone();\n        sort(base, ShellHeapMergeMyInsertionSort, length);\n        return base;\n    }\n\n    private static void sort(int[] array, int ShellHeapMergeMyInsertionSort, int length) {\n        if (ShellHeapMergeMyInsertionSort < 0 || ShellHeapMergeMyInsertionSort > 4) {\n            Random random = new Random();\n            ShellHeapMergeMyInsertionSort = random.nextInt(4);\n        }\n        if (ShellHeapMergeMyInsertionSort == 0) {\n            ShellSort(array);\n        } else if (ShellHeapMergeMyInsertionSort == 1) {\n            HeapSort(array);\n        } else if (ShellHeapMergeMyInsertionSort == 2) {\n            MergeSort(array, 0, length - 1);\n        } else if (ShellHeapMergeMyInsertionSort == 3) {\n            StraightMergeSort(array, length);\n        } else if (ShellHeapMergeMyInsertionSort == 4) {\n            insertionSort(array);\n        }\n    }\n\n    private static void StraightMergeSort(int[] array, int size) {\n        if (size == 0) {\n            return;\n        }\n        int length = (size / 2) + ((size % 2) == 0 ? 0 : 1);\n        Integer[][] ZeroBuffer = new Integer[length + length % 2][2];\n        Integer[][] FirstBuffer = new Integer[0][0];\n        for (int index = 0; index < length; index++) {\n            int ArrayIndex = index * 2;\n            int NextArrayIndex = index * 2 + 1;\n            if (NextArrayIndex < size) {\n                if (array[ArrayIndex] > array[NextArrayIndex]) {\n                    ZeroBuffer[index][0] = array[NextArrayIndex];\n                    ZeroBuffer[index][1] = array[ArrayIndex];\n                } else {\n                    ZeroBuffer[index][0] = array[ArrayIndex];\n                    ZeroBuffer[index][1] = array[NextArrayIndex];\n                }\n            } else {\n                ZeroBuffer[index][0] = array[ArrayIndex];\n            }\n        }\n        boolean position = false;\n        int pointer0, pointer, pointer1, number = 4, NewPointer, count;\n        Integer[][] NewBuffer;\n        Integer[][] OldBuffer;\n        length = (size / 4) + ((size % 4) == 0 ? 0 : 1);\n        while (true) {\n            pointer0 = 0;\n            count = (number / 2) - 1;\n            if (!position) {\n                FirstBuffer = new Integer[length + length % 2][number];\n                NewBuffer = FirstBuffer;\n                OldBuffer = ZeroBuffer;\n            } else {\n                ZeroBuffer = new Integer[length + length % 2][number];\n                NewBuffer = ZeroBuffer;\n                OldBuffer = FirstBuffer;\n            }\n            for (int i = 0; i < length; i++) {\n                pointer = 0;\n                pointer1 = 0;\n                NewPointer = pointer0 + 1;\n                if (length == 1) {\n                    for (int g = 0; g < size; g++) {\n                        if (pointer > count || OldBuffer[pointer0][pointer] == null) {\n                            array[g] = OldBuffer[NewPointer][pointer1];\n                            pointer1++;\n                        } else if (pointer1 > count || OldBuffer[NewPointer][pointer1] == null) {\n                            if (OldBuffer[pointer0][pointer] == null) {\n                                continue;\n                            }\n                            array[g] = OldBuffer[pointer0][pointer];\n                            pointer++;\n                        } else if (OldBuffer[pointer0][pointer] >= OldBuffer[NewPointer][pointer1]) {\n                            array[g] = OldBuffer[NewPointer][pointer1];\n                            pointer1++;\n                        } else {\n                            array[g] = OldBuffer[pointer0][pointer];\n                            pointer++;\n                        }\n                    }\n                    return;\n                }\n                for (int g = 0; g < number; g++) {\n                    if (pointer > count || OldBuffer[pointer0][pointer] == null) {\n                        if (OldBuffer[NewPointer][pointer1] == null) {\n                            continue;\n                        }\n                        NewBuffer[i][g] = OldBuffer[NewPointer][pointer1];\n                        pointer1++;\n                    } else if (pointer1 > count || OldBuffer[NewPointer][pointer1] == null) {\n                        if (OldBuffer[pointer0][pointer] == null) {\n                            continue;\n                        }\n                        NewBuffer[i][g] = OldBuffer[pointer0][pointer];\n                        pointer++;\n                    } else if (OldBuffer[pointer0][pointer] >= OldBuffer[NewPointer][pointer1]) {\n                        NewBuffer[i][g] = OldBuffer[NewPointer][pointer1];\n                        pointer1++;\n                    } else {\n                        NewBuffer[i][g] = OldBuffer[pointer0][pointer];\n                        pointer++;\n                    }\n                }\n                pointer0 += 2;\n            }\n            position = !position;\n            length = length / 2 + length % 2;\n            number *= 2;\n        }\n    }\n\n    private static void ShellSort(int[] array) {\n        int j;\n        for (int gap = array.length / 2; gap > 0; gap /= 2) {\n            for (int i = gap; i < array.length; i++) {\n                int temp = array[i];\n                for (j = i; j >= gap && array[j - gap] > temp; j -= gap) {\n                    array[j] = array[j - gap];\n                }\n                array[j] = temp;\n            }\n        }\n    }\n\n    private static void HeapSort(int[] array) {\n        for (int i = array.length / 2 - 1; i >= 0; i--)\n            shiftDown(array, i, array.length);\n        for (int i = array.length - 1; i > 0; i--) {\n            swap(array, 0, i);\n            shiftDown(array, 0, i);\n        }\n    }\n\n    private static void shiftDown(int[] array, int i, int n) {\n        int child;\n        int tmp;\n        for (tmp = array[i]; leftChild(i) < n; i = child) {\n            child = leftChild(i);\n            if (child != n - 1 && (array[child] < array[child + 1]))\n                child++;\n            if (tmp < array[child])\n                array[i] = array[child];\n            else\n                break;\n        }\n        array[i] = tmp;\n    }\n\n    private static int leftChild(int i) {\n        return 2 * i + 1;\n    }\n\n    private static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n\n    private static void MergeSort(int[] array, int low, int high) {\n        if (low < high) {\n            int mid = (low + high) / 2;\n            MergeSort(array, low, mid);\n            MergeSort(array, mid + 1, high);\n            merge(array, low, mid, high);\n        }\n    }\n\n    private static void merge(int[] array, int low, int mid, int high) {\n        int n = high - low + 1;\n        int[] Temp = new int[n];\n        int i = low, j = mid + 1;\n        int k = 0;\n        while (i <= mid || j <= high) {\n            if (i > mid)\n                Temp[k++] = array[j++];\n            else if (j > high)\n                Temp[k++] = array[i++];\n            else if (array[i] < array[j])\n                Temp[k++] = array[i++];\n            else\n                Temp[k++] = array[j++];\n        }\n        for (j = 0; j < n; j++)\n            array[low + j] = Temp[j];\n    }\n\n    private static void insertionSort(int[] elements) {\n        for (int i = 1; i < elements.length; i++) {\n            int key = elements[i];\n            int j = i - 1;\n            while (j >= 0 && key < elements[j]) {\n                elements[j + 1] = elements[j];\n                j--;\n            }\n            elements[j + 1] = key;\n        }\n    }\n}\n\nclass IO {\n\n    private static BufferedReader read;\n    private static boolean FileInput = false;\n    private static BufferedWriter write;\n    private static boolean FileOutput = false;\n\n    public static void readClose() throws Exception {\n        read.close();\n    }\n\n    public static void writeClose() throws Exception {\n        write.close();\n    }\n\n    public static void setFileInput(boolean newFileInput) {\n        FileInput = newFileInput;\n    }\n\n    public static void setFileOutput(boolean newFileOutput) {\n        FileOutput = newFileOutput;\n    }\n\n    private static void startInput() {\n        try {\n            read = new BufferedReader(FileInput ? new FileReader(\"input.txt\") : new InputStreamReader(System.in));\n        } catch (Exception error) {\n        }\n    }\n\n    private static void startOutput() {\n        try {\n            write = new BufferedWriter(FileOutput ? new FileWriter(\"output.txt\") : new OutputStreamWriter(System.out));\n        } catch (Exception error) {\n        }\n    }\n\n    public static int ReadInt() throws Exception {\n        if (read == null) {\n            startInput();\n        }\n        return Integer.parseInt(read.readLine());\n    }\n\n    public static long ReadLong() throws Exception {\n        if (read == null) {\n            startInput();\n        }\n        return Long.parseLong(read.readLine());\n    }\n\n    public static String ReadString() throws Exception {\n        if (read == null) {\n            startInput();\n        }\n        return read.readLine();\n    }\n\n    public static int[] ReadArrayInt(String split) throws Exception {\n        if (read == null) {\n            startInput();\n        }\n        return Arrays.stream(read.readLine().split(split)).mapToInt(Integer::parseInt).toArray();\n    }\n\n    public static long[] ReadArrayLong(String split) throws Exception {\n        if (read == null) {\n            startInput();\n        }\n        return Arrays.stream(read.readLine().split(split)).mapToLong(Long::parseLong).toArray();\n    }\n\n    public static String[] ReadArrayString(String split) throws IOException {\n        if (read == null) {\n            startInput();\n        }\n        return read.readLine().split(split);\n    }\n\n    public static void WriteArray(int[] array, String split, String end) {\n        if (write == null) {\n            startOutput();\n        }\n        try {\n            int length = array.length;\n            for (int index = 0; index < length; index++) {\n                write.write(Integer.toString(array[index]));\n                if (index + 1 != length) {\n                    write.write(split);\n                }\n            }\n            write.write(end);\n        } catch (Exception error) {\n        }\n    }\n\n    public static void WriteArray(Integer[] array, String split, String end) {\n        if (write == null) {\n            startOutput();\n        }\n        try {\n            int length = array.length;\n            for (int index = 0; index < length; index++) {\n                write.write(Integer.toString(array[index]));\n                if (index + 1 != length) {\n                    write.write(split);\n                }\n            }\n            write.write(end);\n        } catch (Exception error) {\n        }\n    }\n\n    public static void WriteArray(long[] array, String split, String end) {\n        if (write == null) {\n            startOutput();\n        }\n        try {\n            int length = array.length;\n            for (int index = 0; index < length; index++) {\n                write.write(Long.toString(array[index]));\n                if (index + 1 != length) {\n                    write.write(split);\n                }\n            }\n            write.write(end);\n        } catch (Exception error) {\n        }\n    }\n\n    public static void WriteArray(Long[] array, String split, String end) {\n        if (write == null) {\n            startOutput();\n        }\n        try {\n            int length = array.length;\n            for (int index = 0; index < length; index++) {\n                write.write(Long.toString(array[index]));\n                if (index + 1 != length) {\n                    write.write(split);\n                }\n            }\n            write.write(end);\n        } catch (Exception error) {\n        }\n    }\n\n    public static void WriteArray(String[] array, String split, String end) {\n        if (write == null) {\n            startOutput();\n        }\n        try {\n            int length = array.length;\n            for (int index = 0; index < length; index++) {\n                write.write(array[index]);\n                if (index + 1 != length) {\n                    write.write(split);\n                }\n            }\n            write.write(end);\n        } catch (Exception error) {\n        }\n    }\n\n    public static void WriteArray(boolean[] array, String split, String end) {\n        if (write == null) {\n            startOutput();\n        }\n        try {\n            int length = array.length;\n            for (int index = 0; index < length; index++) {\n                write.write(Boolean.toString(array[index]));\n                if (index + 1 != length) {\n                    write.write(split);\n                }\n            }\n            write.write(end);\n        } catch (Exception error) {\n        }\n    }\n\n    public static void WriteInt(int number, String end) {\n        if (write == null) {\n            startOutput();\n        }\n        try {\n            write.write(Integer.toString(number));\n            write.write(end);\n        } catch (Exception error) {\n        }\n    }\n\n    public static void WriteInt(Integer number, String end) {\n        if (write == null) {\n            startOutput();\n        }\n        try {\n            write.write(Integer.toString(number));\n            write.write(end);\n        } catch (Exception error) {\n        }\n    }\n\n    public static void WriteLong(long number, String end) {\n        if (write == null) {\n            startOutput();\n        }\n        try {\n            write.write(Long.toString(number));\n            write.write(end);\n        } catch (Exception error) {\n        }\n    }\n\n    public static void WriteLong(Long number, String end) {\n        if (write == null) {\n            startOutput();\n        }\n        try {\n            write.write(Long.toString(number));\n            write.write(end);\n        } catch (Exception error) {\n        }\n    }\n\n    public static void WriteString(String word, String end) {\n        if (write == null) {\n            startOutput();\n        }\n        try {\n            write.write(word);\n            write.write(end);\n        } catch (Exception error) {\n        }\n    }\n\n    public static void WriteChar(char word, String end) {\n        if (write == null) {\n            startOutput();\n        }\n        try {\n            write.write(word);\n            write.write(end);\n        } catch (Exception error) {\n        }\n    }\n\n    public static void WriteChar(Character word, String end) {\n        if (write == null) {\n            startOutput();\n        }\n        try {\n            write.write(word);\n            write.write(end);\n        } catch (Exception error) {\n        }\n    }\n\n\n    public static void WriteEnter() {\n        if (write == null) {\n            startOutput();\n        }\n        try {\n            write.newLine();\n        } catch (Exception e) {\n        }\n    }\n\n    public static void print() throws Exception {\n        if (write == null) {\n            return;\n        }\n        write.flush();\n        //read.close();\n        write.close();\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "n,l=[int(x) for x in input().split()]\na=sorted([int(x) for x in input().split()])\nnum=len(set(a))\narr=2**((8*l)//n)\na.append(10**100)\nb=[]\ncounter=1\nfor i in range(1,n+1):\n    if a[i]==a[i-1]:\n        counter+=1\n    else:\n        b.append(counter)\n        counter=1\npref=[0]\nfor item in b:\n    pref.append(pref[-1]+item)\nc=max(num-arr,0)\nlena=len(pref)\nanswer=10**100\nfor i in range(c+1):\n    answer=min(answer,pref[i]+pref[lena-1]-pref[lena-c+i-1])\nprint(answer)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n \npublic class E {\n\tstatic FastReader scan;\n\tstatic PrintWriter out;\n \n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tSolver solver = new Solver();\n\t\tscan = new FastReader();\n\t\tout = new PrintWriter(System.out);\n\t\tint testCases = 1;\n\t\tfor (int i = 1; i <= testCases; i++) {\n\t\t\t// out.print(\"Case #\" + i + \": \");\n\t\t\tsolver.solve();\n\t\t}\n\t\tout.close();\n\t}\n \n\tstatic class Solver {\n \n\t\tvoid solve() {\n\t\t\tint n = scan.nextInt(), b = scan.nextInt(), max = b*8/n, ans = 0;\n\t\t\tint d = max >= 31 ? (1 << 30) : (1 << max);\n\t\t\tTreeMap<Integer, Integer> t = new TreeMap<>();\n\t\t\tArrayList<Integer> a = new ArrayList<>();\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint x = scan.nextInt();\n\t\t\t\tt.put(x, t.getOrDefault(x, 0) + 1);\n\t\t\t}\n\t\t\tint curr = 0;\n\t\t\tfor(int i : t.keySet()) a.add(curr += t.get(i));\n\t\t\tfor(int i = 0; i < a.size(); i++) {\n\t\t\t\tint end = i+d-1 >= a.size() ? n : a.get(i+d-1);\n\t\t\t\tint start = i == 0 ? 0 : a.get(i-1);\n\t\t\t\tans = Math.max(ans, end-start);\n\t\t\t}\n\t\t\tout.println(n-ans);\n\t\t}\n \n\t}\n \n\tstatic class DSU {\n\t\tint[] root, size;\n\t\tint n;\n \n\t\tDSU(int n) {\n\t\t\tthis.n = n;\n\t\t\troot = new int[n];\n\t\t\tsize = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\troot[i] = i;\n\t\t\t\tsize[i] = 1;\n\t\t\t}\n\t\t}\n \n\t\tint findParent(int idx) {\n\t\t\twhile (root[idx] != idx) {\n\t\t\t\troot[idx] = root[root[idx]];\n\t\t\t\tidx = root[idx];\n\t\t\t}\n\t\t\treturn idx;\n\t\t}\n \n\t\tboolean union(int x, int y) {\n\t\t\tint parX = findParent(x);\n\t\t\tint parY = findParent(y);\n\t\t\tif (parX == parY)\n\t\t\t\treturn false;\n\t\t\tif (size[parX] < size[parY]) {\n\t\t\t\troot[parY] = parX;\n\t\t\t\tsize[parX] += size[parY];\n\t\t\t} else {\n\t\t\t\troot[parX] = parY;\n\t\t\t\tsize[parY] += size[parX];\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n \n\tstatic class Extra {\n\t\tstatic void sort(int[] a) {\n\t\t\tInteger[] aa = new Integer[a.length];\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\taa[i] = a[i];\n\t\t\tArrays.sort(aa);\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\ta[i] = aa[i];\n\t\t}\n \n\t\tstatic void sort(long[] a) {\n\t\t\tLong[] aa = new Long[a.length];\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\taa[i] = a[i];\n\t\t\tArrays.sort(aa);\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\ta[i] = aa[i];\n\t\t}\n \n\t\tstatic void sort(double[] a) {\n\t\t\tDouble[] aa = new Double[a.length];\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\taa[i] = a[i];\n\t\t\tArrays.sort(aa);\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\ta[i] = aa[i];\n\t\t}\n \n\t\tstatic void sort(char[] a) {\n\t\t\tCharacter[] aa = new Character[a.length];\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\taa[i] = a[i];\n\t\t\tArrays.sort(aa);\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\ta[i] = aa[i];\n\t\t}\n \n\t\tstatic long gcd(long a, long b) {\n\t\t\twhile (b > 0) {\n\t\t\t\tlong temp = b;\n\t\t\t\tb = a % b;\n\t\t\t\ta = temp;\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n \n\t\tstatic long lcm(long a, long b) {\n\t\t\treturn a * (b / gcd(a, b));\n\t\t}\n \n\t\tstatic boolean isPrime(long n) {\n\t\t\tif (n <= 1)\n\t\t\t\treturn false;\n\t\t\tif (n <= 3)\n\t\t\t\treturn true;\n\t\t\tif (n % 2 == 0 || n % 3 == 0)\n\t\t\t\treturn false;\n\t\t\tfor (long i = 5; i * i <= n; i = i + 6) {\n\t\t\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n \n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n \n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n \n\t\tpublic FastReader(String s) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(new File(s)));\n\t\t}\n \n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n \n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n \n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n \n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n \n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] a = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextDouble();\n\t\t\treturn a;\n\t\t}\n \n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n \n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class E {\n\tstatic FastReader scan;\n\tstatic PrintWriter out;\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tSolver solver = new Solver();\n\t\tscan = new FastReader();\n\t\tout = new PrintWriter(System.out);\n\t\tint testCases = 1;\n\t\tfor (int i = 1; i <= testCases; i++) {\n\t\t\t// out.print(\"Case #\" + i + \": \");\n\t\t\tsolver.solve();\n\t\t}\n\t\tout.close();\n\t}\n\n\tstatic class Solver {\n\n\t\tvoid solve() {\n\t\t\tint n = scan.nextInt(), b = scan.nextInt(), max = b*8/n, ans = 0;\n\t\t\tint d = max >= 31 ? (1 << 30) : (1 << max);\n\t\t\tTreeMap<Integer, Integer> t = new TreeMap<>();\n\t\t\tArrayList<Integer> a = new ArrayList<>();\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint x = scan.nextInt();\n\t\t\t\tt.put(x, t.getOrDefault(x, 0) + 1);\n\t\t\t}\n\t\t\tint curr = 0;\n\t\t\tfor(int i : t.keySet()) a.add(curr += t.get(i));\n\t\t\tfor(int i = 0; i < a.size(); i++) {\n\t\t\t\tint end = i+d-1 >= a.size() ? n : a.get(i+d-1);\n\t\t\t\tint start = i == 0 ? 0 : a.get(i-1);\n\t\t\t\tans = Math.max(ans, end-start);\n\t\t\t}\n\t\t\tout.println(n-ans);\n\t\t}\n\n\t}\n\n\t// Sathvik's Template Stuff BELOW!!!!!!!!!!!!!!!!!!!!!!\n\n\tstatic class DSU {\n\t\tint[] root, size;\n\t\tint n;\n\n\t\tDSU(int n) {\n\t\t\tthis.n = n;\n\t\t\troot = new int[n];\n\t\t\tsize = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\troot[i] = i;\n\t\t\t\tsize[i] = 1;\n\t\t\t}\n\t\t}\n\n\t\tint findParent(int idx) {\n\t\t\twhile (root[idx] != idx) {\n\t\t\t\troot[idx] = root[root[idx]];\n\t\t\t\tidx = root[idx];\n\t\t\t}\n\t\t\treturn idx;\n\t\t}\n\n\t\tboolean union(int x, int y) {\n\t\t\tint parX = findParent(x);\n\t\t\tint parY = findParent(y);\n\t\t\tif (parX == parY)\n\t\t\t\treturn false;\n\t\t\tif (size[parX] < size[parY]) {\n\t\t\t\troot[parY] = parX;\n\t\t\t\tsize[parX] += size[parY];\n\t\t\t} else {\n\t\t\t\troot[parX] = parY;\n\t\t\t\tsize[parY] += size[parX];\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic class Extra {\n\t\tstatic void sort(int[] a) {\n\t\t\tInteger[] aa = new Integer[a.length];\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\taa[i] = a[i];\n\t\t\tArrays.sort(aa);\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\ta[i] = aa[i];\n\t\t}\n\n\t\tstatic void sort(long[] a) {\n\t\t\tLong[] aa = new Long[a.length];\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\taa[i] = a[i];\n\t\t\tArrays.sort(aa);\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\ta[i] = aa[i];\n\t\t}\n\n\t\tstatic void sort(double[] a) {\n\t\t\tDouble[] aa = new Double[a.length];\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\taa[i] = a[i];\n\t\t\tArrays.sort(aa);\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\ta[i] = aa[i];\n\t\t}\n\n\t\tstatic void sort(char[] a) {\n\t\t\tCharacter[] aa = new Character[a.length];\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\taa[i] = a[i];\n\t\t\tArrays.sort(aa);\n\t\t\tfor (int i = 0; i < aa.length; i++)\n\t\t\t\ta[i] = aa[i];\n\t\t}\n\n\t\tstatic long gcd(long a, long b) {\n\t\t\twhile (b > 0) {\n\t\t\t\tlong temp = b;\n\t\t\t\tb = a % b;\n\t\t\t\ta = temp;\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t\tstatic long lcm(long a, long b) {\n\t\t\treturn a * (b / gcd(a, b));\n\t\t}\n\n\t\tstatic boolean isPrime(long n) {\n\t\t\tif (n <= 1)\n\t\t\t\treturn false;\n\t\t\tif (n <= 3)\n\t\t\t\treturn true;\n\t\t\tif (n % 2 == 0 || n % 3 == 0)\n\t\t\t\treturn false;\n\t\t\tfor (long i = 5; i * i <= n; i = i + 6) {\n\t\t\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tpublic FastReader(String s) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(new File(s)));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] a = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextDouble();\n\t\t\treturn a;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n, m;\n  cin >> n >> m;\n  map<int, int> cnt;\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    cnt[x]++;\n  }\n  vector<int> pref = {0};\n  for (auto x : cnt) pref.push_back(pref.back() + x.second);\n  int k = (1 << min((8 * m) / n, 20));\n  int maxSum = 0;\n  for (int i = 0; i < int((pref).size()); i++) {\n    int curSum = pref[i] - (i >= k ? pref[i - k] : 0);\n    maxSum = max(maxSum, curSum);\n  }\n  cout << (n - maxSum) << endl;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys,os,io\nimport math,bisect,operator\ninf,mod = float('inf'),10**9+7\n# sys.setrecursionlimit(10 ** 6)\nfrom itertools import groupby,accumulate\nfrom heapq import heapify,heappop,heappush\nfrom collections import deque,Counter,defaultdict\ninput = iter(sys.stdin.buffer.read().decode().splitlines()).__next__\nNeo = lambda : list(map(int,input().split()))\n# test, = Neo()\nn, p = Neo()\nx = Neo()\nx.sort()\nt = 2**((8*p)//n)\nlast = None\ny = []\nfor c in x:\n    if last is None or last != c:\n        last = c\n        y.append(1)\n    else:\n        y[-1] += 1\nbest = 0\nnow = 0\nfor i in range(len(y)):\n    now += y[i]\n    if i >= t:\n        now -= y[i-t]\n    best = max(best, now)\nprint(n-best)\n"
        },
        {
            "language": 4,
            "solution": "\n\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.charset.Charset;\nimport java.util.*;\n\n\npublic class CFContest {\n    public static void main(String[] args) throws Exception {\n        boolean local = System.getProperty(\"ONLINE_JUDGE\") == null;\n        boolean async = true;\n\n        Charset charset = Charset.forName(\"ascii\");\n\n        FastIO io = local ? new FastIO(new FileInputStream(\"D:\\\\DATABASE\\\\TESTCASE\\\\Code.in\"), System.out, charset) : new FastIO(System.in, System.out, charset);\n        Task task = new Task(io, new Debug(local));\n\n        if (async) {\n            Thread t = new Thread(null, task, \"dalt\", 1 << 27);\n            t.setPriority(Thread.MAX_PRIORITY);\n            t.start();\n            t.join();\n        } else {\n            task.run();\n        }\n\n        if (local) {\n            io.cache.append(\"\\n\\n--memory -- \\n\" + ((Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) >> 20) + \"M\");\n        }\n\n        io.flush();\n    }\n\n    public static class Task implements Runnable {\n        final FastIO io;\n        final Debug debug;\n        int inf = (int) 1e8;\n\n        public Task(FastIO io, Debug debug) {\n            this.io = io;\n            this.debug = debug;\n        }\n\n        @Override\n        public void run() {\n            solve();\n        }\n\n        public void solve() {\n            int n = io.readInt();\n            int I = io.readInt() * 8;\n            int k = I / n;\n            int K = (int) (Math.pow(2, k) + 0.5);\n\n            int[] data = new int[n];\n            for (int i = 0; i < n; i++) {\n                data[i] = io.readInt();\n            }\n            Randomized.randomizedArray(data, 0, n);\n            Arrays.sort(data);\n\n            Map<Integer, Integer> map = new HashMap<>(n);\n            int r = 0;\n            int max = 0;\n            for (int i = 0; i < n; i++) {\n                r = Math.max(i, r);\n                while (r < n && map.size() < K) {\n                    map.put(data[r], map.getOrDefault(data[r], 0) + 1);\n                    r++;\n                }\n                while (r < n && map.containsKey(data[r])) {\n                    map.put(data[r], map.getOrDefault(data[r], 0) + 1);\n                    r++;\n                }\n\n                int range = r - i;\n                max = Math.max(range, max);\n\n                if (map.get(data[i]) == 1) {\n                    map.remove(data[i]);\n                } else {\n                    map.put(data[i], map.get(data[i]) - 1);\n                }\n            }\n\n            io.cache.append(n - max);\n        }\n    }\n\n\n    public static class Randomized {\n        static Random random = new Random();\n\n        public static double nextDouble(double min, double max) {\n            return random.nextDouble() * (max - min) + min;\n        }\n\n        public static void randomizedArray(int[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                int tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static void randomizedArray(long[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                long tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static void randomizedArray(double[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                double tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static void randomizedArray(float[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                float tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static <T> void randomizedArray(T[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                T tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static int nextInt(int l, int r) {\n            return random.nextInt(r - l + 1) + l;\n        }\n    }\n\n    /**\n     * Mod operations\n     */\n    public static class Modular {\n        int m;\n\n        public Modular(int m) {\n            this.m = m;\n        }\n\n        public int valueOf(int x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return x;\n        }\n\n        public int valueOf(long x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return (int) x;\n        }\n\n        public int mul(int x, int y) {\n            return valueOf((long) x * y);\n        }\n\n        public int mul(long x, long y) {\n            x = valueOf(x);\n            y = valueOf(y);\n            return valueOf(x * y);\n        }\n\n        public int plus(int x, int y) {\n            return valueOf(x + y);\n        }\n\n        public int plus(long x, long y) {\n            x = valueOf(x);\n            y = valueOf(y);\n            return valueOf(x + y);\n        }\n\n        @Override\n        public String toString() {\n            return \"mod \" + m;\n        }\n    }\n\n    public static class FastIO {\n        public final StringBuilder cache = new StringBuilder(1 << 20);\n        private final InputStream is;\n        private final OutputStream os;\n        private final Charset charset;\n        private StringBuilder defaultStringBuf = new StringBuilder(1 << 8);\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastIO(InputStream is, OutputStream os, Charset charset) {\n            this.is = is;\n            this.os = os;\n            this.charset = charset;\n        }\n\n        public FastIO(InputStream is, OutputStream os) {\n            this(is, os, Charset.forName(\"ascii\"));\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public long readLong() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            long val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public double readDouble() {\n            boolean sign = true;\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+';\n                next = read();\n            }\n\n            long val = 0;\n            while (next >= '0' && next <= '9') {\n                val = val * 10 + next - '0';\n                next = read();\n            }\n            if (next != '.') {\n                return sign ? val : -val;\n            }\n            next = read();\n            long radix = 1;\n            long point = 0;\n            while (next >= '0' && next <= '9') {\n                point = point * 10 + next - '0';\n                radix = radix * 10;\n                next = read();\n            }\n            double result = val + (double) point / radix;\n            return sign ? result : -result;\n        }\n\n        public String readString(StringBuilder builder) {\n            skipBlank();\n\n            while (next > 32) {\n                builder.append((char) next);\n                next = read();\n            }\n\n            return builder.toString();\n        }\n\n        public String readString() {\n            defaultStringBuf.setLength(0);\n            return readString(defaultStringBuf);\n        }\n\n        public int readLine(char[] data, int offset) {\n            int originalOffset = offset;\n            while (next != -1 && next != '\\n') {\n                data[offset++] = (char) next;\n                next = read();\n            }\n            return offset - originalOffset;\n        }\n\n        public int readString(char[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (char) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public int readString(byte[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (byte) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public char readChar() {\n            skipBlank();\n            char c = (char) next;\n            next = read();\n            return c;\n        }\n\n        public void flush() {\n            try {\n                os.write(cache.toString().getBytes(charset));\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public boolean hasMore() {\n            skipBlank();\n            return next != -1;\n        }\n    }\n\n    public static class Debug {\n        private boolean allowDebug;\n\n        public Debug(boolean allowDebug) {\n            this.allowDebug = allowDebug;\n        }\n\n        public void assertTrue(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (!flag) {\n                fail();\n            }\n        }\n\n        public void fail() {\n            throw new RuntimeException();\n        }\n\n        public void assertFalse(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (flag) {\n                fail();\n            }\n        }\n\n        private void outputName(String name) {\n            System.out.print(name + \" = \");\n        }\n\n        public void debug(String name, int x) {\n            if (!allowDebug) {\n                return;\n            }\n\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, long x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, double x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, int[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, long[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, double[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, Object x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, Object... x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.deepToString(x));\n        }\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        FastReader input=new FastReader();\n        PrintWriter out=new PrintWriter(System.out);\n        int T=1;\n        while(T-->0)\n        {\n            int n=input.nextInt();\n            int I=input.nextInt();\n            int a[]=new int[n];\n            for(int i=0;i<n;i++)\n            {\n                a[i]=input.nextInt();\n            }\n            I=I*8;\n            I=I/n;\n            if(I>=25)\n            {\n                out.println(0);\n            }\n            else\n            {\n                mergeSort(a,0,n-1);\n                ArrayList<Integer> list=new ArrayList<>();\n                int c=1;\n                for(int i=0;i<n-1;i++)\n                {\n                    if(a[i]!=a[i+1])\n                    {\n                        list.add(c);\n                        c=1;\n                    }\n                    else\n                    {\n                        c++;\n                    }\n                }\n                list.add(c);\n                int d=(int)Math.pow(2,I);\n                if(d>=list.size())\n                {\n                    out.println(0);\n                }\n                else\n                {\n                    out.println(n-maxSum(list,list.size(),d));\n                }\n            }\n        }\n        out.close();\n    }\n    public static int maxSum(ArrayList<Integer> arr, int n, int k)\n    {\n        // k must be greater\n        if (n < k)\n        {\n            System.out.println(\"Invalid\");\n            return -1;\n        }\n\n        // Compute sum of first window of size k\n        int res = 0;\n        for (int i=0; i<k; i++)\n            res += arr.get(i);\n\n        // Compute sums of remaining windows by\n        // removing first element of previous\n        // window and adding last element of\n        // current window.\n        int curr_sum = res;\n        for (int i=k; i<n; i++)\n        {\n            curr_sum += arr.get(i) - arr.get(i-k);\n            res = Math.max(res, curr_sum);\n        }\n\n        return res;\n    }\n    static int maxSubArraySum(ArrayList<Integer> a)\n    {\n        int size = a.size();\n        int max_so_far = Integer.MIN_VALUE, max_ending_here = 0;\n\n        for (int i = 0; i < size; i++)\n        {\n            max_ending_here = max_ending_here + a.get(i);\n            if (max_so_far < max_ending_here)\n                max_so_far = max_ending_here;\n            if (max_ending_here < 0)\n                max_ending_here = 0;\n        }\n        return max_so_far;\n    }\n    public static void mergeSort(int a[],int p,int r)\n    {\n        if(p<r)\n        {\n            int q=(p+r)/2;\n            mergeSort(a,p,q);\n            mergeSort(a,q+1,r);\n            merge(a,p,q,r);\n        }\n    }\n    public static void merge(int a[],int p,int q,int r)\n    {\n        int n1=q-p+2;\n        int L[]=new int[n1];\n        int n2=r-q+1;\n        int R[]=new int[n2];\n        for(int i=p;i<=q;i++)\n        {\n            L[i-p]=a[i];\n        }\n        L[n1-1]=Integer.MAX_VALUE;\n        for(int i=q+1;i<=r;i++)\n        {\n            R[i-q-1]=a[i];\n        }\n        R[n2-1]=Integer.MAX_VALUE;\n        int x=0,y=0;\n        for(int i=p;i<=r;i++)\n        {\n            if(L[x]<=R[y])\n            {\n                a[i]=L[x];\n                x++;\n            }\n            else\n            {\n                a[i]=R[y];\n                y++;\n            }\n        }\n    }\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}"
        },
        {
            "language": 1,
            "solution": "\n\n# target Expert  \n\n# Author : raj1307 - Raj Singh\n# Date   : 6.08.19\n\nfrom __future__ import division, print_function\n\nimport os,sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef ii(): return int(input())\ndef si(): return input()\ndef mi(): return map(int,input().strip().split(\" \"))\ndef li(): return list(mi())\n\ndef dmain():\n    sys.setrecursionlimit(100000000)\n    threading.stack_size(40960000)\n    thread = threading.Thread(target=main)\n    thread.start()\n    \n#from collections import deque, Counter, OrderedDict,defaultdict\n#from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\n#from math import ceil,floor,log,sqrt,factorial,pi,log2\n#from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n#from decimal import *,threading\n#from itertools import permutations\n\nabc='abcdefghijklmnopqrstuvwxyz'\nabd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod=1000000007\n#mod=998244353\ninf = float(\"inf\")\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\ndef getKey(item): return item[0] \ndef sort2(l):return sorted(l, key=getKey)\ndef d2(n,m,num):return [[num for x in range(m)] for y in range(n)]\ndef isPowerOfTwo (x): return (x and (not(x & (x - 1))) )\ndef decimalToBinary(n): return bin(n).replace(\"0b\",\"\")\ndef ntl(n):return [int(i) for i in str(n)]\n\ndef powerMod(x,y,p):\n    res = 1\n    x %= p\n    while y > 0:\n        if y&1:\n            res = (res*x)%p\n        y = y>>1\n        x = (x*x)%p\n    return res\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n    \ndef isPrime(n) : # Check Prime Number or not \n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n    return True\n\n\n\ndef read():\n    sys.stdin = open('input.txt', 'r')  \n    sys.stdout = open('output.txt', 'w') \n\n\n\n\ndef main():\n\n\n\n    #for _ in range(ii()):\n\n    \n\n\n    n,k=mi()\n    l=li()\n    k*=8\n    k//=n\n    k=1<<(min(20,k))\n\n    l.sort()\n\n\n\n    x=[]\n    cnt=1\n    for i in range(1,n):\n        if l[i]==l[i-1]:\n            cnt+=1\n        else:\n            x.append(cnt)\n            cnt=1\n\n    x.append(cnt)\n\n\n    x.insert(0,0)\n\n    pre=[0]*(n+2)\n\n    for i in range(1,len(x)):\n        pre[i]=x[i]+pre[i-1]\n\n    k=min(k,len(x)-1)\n    ans=0\n    for i in range(1,len(x)):\n\n        l=i\n        r=i+k-1\n        r=min(len(x)-1,r)\n\n        ans=max(ans,pre[r]-pre[l-1])\n\n    print(n-ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\n\nif __name__ == \"__main__\":\n    #read()\n    main()\n    #dmain()\n\n# Comment Read()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint a[400005], b[400005], sl[400005], sr[400005];\nint main() {\n  int k, p, ans, co = 0, la = 0;\n  scanf(\"%d%d\", &k, &p);\n  ans = p * 8 / k;\n  ans = min(ans, 20);\n  ans = 1 << ans;\n  for (int i = 1; i <= k; i++) scanf(\"%d\", &a[i]);\n  sort(a + 1, a + k + 1);\n  for (int i = 2; i <= k; i++)\n    if (a[i] != a[i - 1]) {\n      b[++co] = i - la - 1;\n      la = i - 1;\n    }\n  b[++co] = k - la;\n  sl[0] = sr[co + 1] = 0;\n  for (int i = 1; i <= co; i++) sl[i] = sl[i - 1] + b[i];\n  for (int i = co; i >= 1; i--) sr[i] = sr[i + 1] + b[i];\n  if (co - ans <= 0) {\n    puts(\"0\");\n    return 0;\n  }\n  int Min = k;\n  for (int i = 0; i <= co - ans; i++)\n    Min = min(Min, sl[i] + sr[co - (co - ans - i) + 1]);\n  printf(\"%d\\n\", Min);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, x, y, maxi, db = 1;\nvector<int> v;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin >> n >> k;\n  k *= 8;\n  k /= n;\n  k = min(k, 30);\n  for (int i = 1; i <= n; i++) {\n    int x;\n    cin >> x;\n    v.push_back(x);\n  }\n  sort(v.begin(), v.end());\n  while (y < n) {\n    if (db <= (1 << k)) {\n      y++;\n      if (y != n && v[y] != v[y - 1]) {\n        db++;\n      }\n      maxi = max(maxi, y - x);\n    } else {\n      x++;\n      if (v[x] != v[x - 1]) {\n        db--;\n      }\n    }\n  }\n  cout << n - maxi << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long n, I;\n  cin >> n >> I;\n  vector<long long> a(n, 0);\n  set<long long> s;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  sort(a.begin(), a.end());\n  long long bit = (8 * I) / n;\n  long long j = 0;\n  long long sum1 = 0;\n  long long ans = 0;\n  for (long long i = 0; i < n; i++) {\n    s.insert(a[i]);\n    double d = log2(s.size());\n    d = ceil(d);\n    long long d1 = d;\n    while (d > bit) {\n      if (a[j] != a[j + 1]) {\n        s.erase(a[j]);\n        j++;\n      } else\n        j++;\n      d = log2(s.size());\n      d = ceil(d);\n      d1 = d;\n    }\n    ans = max(i - j + 1, ans);\n  }\n  cout << n - ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC push_options\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nvoid doin() {\n  cin.tie();\n  cout.tie();\n  ios::sync_with_stdio(0);\n}\ntemplate <typename X, typename Y>\nistream& operator>>(istream& in, pair<X, Y>& a) {\n  in >> a.first >> a.second;\n  return in;\n}\ntemplate <typename T>\nvoid getv(T& i) {\n  cin >> i;\n}\ntemplate <typename T, typename... Ns>\nvoid getv(vector<T>& v, int n, Ns... ns) {\n  v.resize(n);\n  for (auto& i : v) getv(i, ns...);\n}\ntemplate <typename T>\nvoid getv1(T& i) {\n  cin >> i;\n}\ntemplate <typename T, typename... Ns>\nvoid getv1(vector<T>& v, int n, Ns... ns) {\n  v.resize(n + 1);\n  for (int i = 1; i <= n; i++) getv(v[i], ns...);\n}\ninline void getch(char& x) {\n  while (x = getchar_unlocked(), x < 33) {\n    ;\n  }\n}\ninline void getstr(string& str) {\n  str.clear();\n  char cur;\n  while (cur = getchar_unlocked(), cur < 33) {\n    ;\n  }\n  while (cur > 32) {\n    str += cur;\n    cur = getchar_unlocked();\n  }\n}\ntemplate <typename T>\ninline bool sc(T& num) {\n  bool neg = 0;\n  int c;\n  num = 0;\n  while (c = getchar_unlocked(), c < 33) {\n    if (c == EOF) return false;\n  }\n  if (c == '-') {\n    neg = 1;\n    c = getchar_unlocked();\n  }\n  for (; c > 47; c = getchar_unlocked()) num = num * 10 + c - 48;\n  if (neg) num *= -1;\n  return true;\n}\nusing AntonTsypko = void;\nusing arsijo = AntonTsypko;\nusing god = arsijo;\nuniform_real_distribution<double> double_dist(0, 1);\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\nint main() {\n  doin();\n  long long n, I;\n  cin >> n >> I;\n  I *= 8;\n  I /= n;\n  I = min(I, 61ll);\n  I = min(1ll << I, 2000000001ll);\n  vector<long long> a;\n  getv(a, n);\n  sort(a.begin(), a.end());\n  vector<long long> b;\n  int c = 1;\n  for (int i = 1; i < n; i++) {\n    if (a[i] == a[i - 1])\n      c++;\n    else {\n      b.push_back(c);\n      c = 1;\n    }\n  }\n  b.push_back(c);\n  int ans = INT_MIN, r = 0;\n  for (int i = 0; i < b.size(); i++) {\n    r += b[i];\n    ans = max(ans, r);\n    if (i - I + 1 >= 0) r -= b[i - I + 1];\n  }\n  cout << n - ans;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "\nvec_a = []\nfreq = []\ncum_freq = []\n\n\nn, available_bytes = map(int, input().split())\n\nvec_a = list(map(int, input().split()))\n\n\n# Frequencty of the numbers\nvec_a.sort()\n\na = vec_a[0]\nfreq.append(1)\n\nfor i in range(1, n) :\n    if(vec_a[i] == a):\n        freq[-1] += 1\n    else:\n        a = vec_a[i]\n        freq.append(1)\n\n# print(vec_a)\n# print(freq)\ntot_distinct_num = len(freq)\n\n\n# Cumulative sum of frequencty\ntotal = 0\nfor f in freq:\n    total += f\n    cum_freq.append(total)\n\n# print(cum_freq)\n\n\n# Max unchanged count\neach_num_occupied_bits = available_bytes * 8 // n\n\ntot_distinct_num_capable = 1 << min(each_num_occupied_bits, 20)    # log2(MAXN) < 20, where MAXN = 4e5\n\nunchanged_count = 0\nfor i in range (min(tot_distinct_num_capable, tot_distinct_num)-1, tot_distinct_num):\n    s = i-tot_distinct_num_capable\n    less = 0 if s < 0 else cum_freq[s]\n    curr_unchanged_cout = cum_freq[i] - less\n    unchanged_count = max(unchanged_count, curr_unchanged_cout)\n\n\n\n# Min changed count\nprint(n - unchanged_count)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 7;\nconst int N = 1e6 + 5;\nconst int M = 2e5 + 5;\nusing namespace std;\nint v[N];\nvoid solve() {\n  int n, i, I;\n  cin >> n >> I;\n  for (i = 0; i < n; i++) cin >> v[i];\n  int lim = (8 * I) / n;\n  if (lim >= 30) {\n    cout << \"0\\n\";\n    return;\n  }\n  int go = (1 << lim);\n  sort(v, v + n);\n  int ans = 0;\n  vector<int> got;\n  for (i = 0; i < n; i++) {\n    int cnt = 1;\n    while (i < n - 1 && v[i + 1] == v[i]) {\n      cnt++;\n      i++;\n    }\n    got.push_back(cnt);\n  }\n  int m = got.size();\n  if (m <= go) {\n    cout << \"0\\n\";\n    return;\n  }\n  int cur = 0;\n  for (i = 0; i < go; i++) cur += got[i];\n  ans = max(ans, cur);\n  for (; i < m; i++) {\n    cur += got[i];\n    cur -= got[i - go];\n    ans = max(ans, cur);\n  }\n  cout << n - ans << '\\n';\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ;\n  int t = 1;\n  for (int tc = 1; tc <= t; tc++) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long ara[400005], cnt[2][400005];\nmap<long long, long long> mp;\nvector<long long> v;\nlong long check(long long n, long long I) {\n  memset(cnt, 0, sizeof cnt);\n  for (long long i = 1; i <= v.size(); i++) {\n    cnt[0][i] += (cnt[0][i - 1] + mp[v[i - 1]]);\n  }\n  long long c = 1;\n  for (long long i = ((long long)v.size()); i >= 1; i--) {\n    cnt[1][c] += (cnt[1][c - 1] + mp[v[i - 1]]);\n    c++;\n  }\n  long long ans = 1e18 + 19;\n  for (long long i = 0; i < 24; i++) {\n    long long k = min((1LL << i), ((long long)v.size()));\n    c = v.size();\n    k = c - k;\n    if (i * n <= 8 * I) {\n      for (long long j = 0; j <= k; j++) {\n        long long l = k - j;\n        ans = min(ans, cnt[0][j] + cnt[1][l]);\n      }\n    }\n  }\n  mp.clear();\n  v.clear();\n  return ans;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  long long n, I;\n  while (cin >> n >> I) {\n    for (long long i = 0; i < n; i++) {\n      cin >> ara[i];\n      if (!mp[ara[i]]) {\n        v.push_back(ara[i]);\n      }\n      mp[ara[i]]++;\n    }\n    sort(v.begin(), v.end());\n    cout << check(n, I) << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "/*Author: Satyajeet Singh, Delhi Technological University*/\n    import java.io.*;\n    import java.util.*;\n    import java.text.*; \n    import java.lang.*;\n    import java.math.*;\n \npublic class Main{\n/*********************************************Constants******************************************/\n    static PrintWriter out=new PrintWriter(new OutputStreamWriter(System.out));        \n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    static long mod=(long)1e9+7;\n    static long mod1=998244353;\n    static boolean sieve[];\n    static ArrayList<Integer> primes;\n    static ArrayList<Long> factorial;\n    static HashSet<Pair> graph[];\n    static boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n/****************************************Solutions Begins***************************************/\n    public static void main (String[] args) throws Exception {\n        String st[]=br.readLine().split(\" \");\n        int n=Integer.parseInt(st[0]);\n        int I=Integer.parseInt(st[1])*8;\n        st=br.readLine().split(\" \");\n        Integer input[]=new Integer[n];\n        for(int i=0;i<n;i++){\n            input[i]=Integer.parseInt(st[i]);\n        }\n        long s=1;\n        long e=30;\n        long kreq=0;\n        while(s<=e){\n            long m=(s+e)/2;\n            if(m*(long)n<=I){\n                s=m+1;\n                kreq=m;\n            }\n            else{\n                e=m-1;\n            }\n        }\n        int kr=(int)kreq;\n        int r=1<<kr;\n        Arrays.sort(input);\n        HashMap<Integer,Integer> map=new HashMap<>();\n        int right=0;\n        int left=0;\n        int max=0;\n        while(right<n){\n            map.put(input[right],map.getOrDefault(input[right],0)+1);\n            while(map.size()>r){\n                debug(map);\n                debug(map.size(),r);\n                map.put(input[left],map.get(input[left])-1);\n                if(map.get(input[left])==0){\n                    map.remove(input[left]);\n                }\n                left++;\n            }\n            max=Math.max(max,right-left+1);\n            right++;\n        }\n        out.println(n-max);\n/****************************************Solutions Ends**************************************************/\n        out.flush();\n        out.close();\n    }\n/****************************************Template Begins************************************************/\n/***************************************Precision Printing**********************************************/\n    static void printPrecision(double d){\n        DecimalFormat ft = new DecimalFormat(\"0.00000000000000000\"); \n        out.println(ft.format(d));\n    }\n/**************************************Bit Manipulation**************************************************/\n    static void printMask(int mask){\n        System.out.println(Integer.toBinaryString(mask));\n    }\n/******************************************Graph*********************************************************/\n    static void Makegraph(int n){\n        graph=new HashSet[n];\n        for(int i=0;i<n;i++){\n            graph[i]=new HashSet<>();\n        }\n    }\n    static void addEdge(int a,int b,int c){\n        graph[a].add(new Pair(b,c));\n    }    \n/*********************************************PAIR********************************************************/\n    static class PairComp implements Comparator<Pair>{\n        public int compare(Pair p1,Pair p2){\n            if(p1.u!=p2.u){\n                return p1.u-p2.u;\n            }\n            else{\n                return p1.v-p2.v;\n            }\n        }\n    }\n    static class Pair implements Comparable<Pair> {\n        int u;\n        int v;\n        int index=-1;\n        public Pair(int u, int v) {\n            this.u = u;\n            this.v = v;\n        }\n \n        public int hashCode() {\n            int hu = (int) (u ^ (u >>> 32));\n            int hv = (int) (v ^ (v >>> 32));\n            return 31 * hu + hv;\n        }\n \n        public boolean equals(Object o) {\n            Pair other = (Pair) o;\n            return u == other.u && v == other.v;\n        }\n \n        public int compareTo(Pair other) {\n            if(index!=other.index)\n                return Long.compare(index, other.index);\n            return Long.compare(v, other.v)!=0?Long.compare(v, other.v):Long.compare(u, other.u);\n        }\n \n        public String toString() {\n            return \"[u=\" + u + \", v=\" + v + \"]\";\n        }\n    }\n/******************************************Long Pair*************************************************/\n    static class PairCompL implements Comparator<Pairl>{\n        public int compare(Pairl p1,Pairl p2){\n            long aa=p2.v-p1.v;\n            if(aa<0){\n                return -1;\n            }\n            else if(aa>0){\n                return 1;\n            }\n            else{\n                return 0;\n            }\n        }\n    }\n    static class Pairl implements Comparable<Pairl> {\n            long u;\n            long v;\n            int index=-1;\n            public Pairl(long u, long v) {\n                this.u = u;\n                this.v = v;\n            }\n    \n            public int hashCode() {\n                int hu = (int) (u ^ (u >>> 32));\n                int hv = (int) (v ^ (v >>> 32));\n                return 31 * hu + hv;\n            }\n    \n            public boolean equals(Object o) {\n                Pair other = (Pair) o;\n                return u == other.u && v == other.v;\n            }\n    \n            public int compareTo(Pairl other) {\n                if(index!=other.index)\n                    return Long.compare(index, other.index);\n                return Long.compare(v, other.v)!=0?Long.compare(v, other.v):Long.compare(u, other.u);\n            }\n    \n            public String toString() {\n                return \"[u=\" + u + \", v=\" + v + \"]\";\n            }\n        }\n/*****************************************DEBUG***********************************************************/\n    public static void debug(Object... o) {\n        if(!oj)\n        System.out.println(Arrays.deepToString(o));\n    }\n/************************************MODULAR EXPONENTIATION***********************************************/\n    static long modulo(long a,long b,long c) {\n        long x=1;\n        long y=a;\n        while(b > 0){\n            if(b%2 == 1){\n                x=(x*y)%c;\n            }\n            y = (y*y)%c; // squaring the base\n            b /= 2;\n        }\n        return  x%c;\n    }\n/********************************************GCD**********************************************************/\n    static long gcd(long x, long y)\n    {\n        if(x==0)\n            return y;\n        if(y==0)\n            return x;\n        long r=0, a, b;\n        a = (x > y) ? x : y; // a is greater number\n        b = (x < y) ? x : y; // b is smaller number\n        r = b;\n        while(a % b != 0)\n        {\n            r = a % b;\n            a = b;\n            b = r;\n        }\n        return r;\n    }\n/******************************************SIEVE**********************************************************/\n    static void sieveMake(int n){\n        sieve=new boolean[n];\n        Arrays.fill(sieve,true);\n        sieve[0]=false;\n        sieve[1]=false;\n        for(int i=2;i*i<n;i++){\n            if(sieve[i]){\n                for(int j=i*i;j<n;j+=i){\n                    sieve[j]=false;\n                }\n            }\n        }\n        primes=new ArrayList<Integer>();\n        for(int i=0;i<n;i++){\n            if(sieve[i]){\n                primes.add(i);\n            }\n        }        \n    }\n/********************************************End***********************************************************/\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class C_MP3 {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader inp = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n        solver.solve(inp, out);\n        out.close();\n    }\n\n    private static class Solver {\n        private HashMap<Integer, Integer> cnt = new HashMap<>();\n\n        private void solve(InputReader inp, PrintWriter out) {\n            int n = inp.nextInt(), I = inp.nextInt() * 8;\n            ArrayList<Integer> a = new ArrayList<>(n);\n            for (int i = 0; i < n; i++) a.add(inp.nextInt());\n            Collections.sort(a);\n            int l = 0, r = 0, res = Integer.MAX_VALUE;\n            while (r < n) {\n                cnt.put(a.get(r), cnt.getOrDefault(a.get(r), 0) + 1);\n                int k = k();\n                if (n * k <= I) res = Math.min(res, n - (r - l + 1));\n                else {\n                    decrease(a.get(l));\n                    l++;\n                }\n                r++;\n            }\n            out.println(res);\n        }\n\n        private void decrease(int i) {\n            cnt.put(i, cnt.getOrDefault(i, 0) - 1);\n            if (cnt.get(i) == 0) cnt.remove(i);\n        }\n\n        private int k() {\n            int k = 19, distinct = cnt.size();\n            while (distinct <= (1 << (k - 1))) k--;\n            return k;\n\n        }\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int bin_expo(long long int a, long long int b, long long int m) {\n  long long int res = 1;\n  a %= m;\n  while (b != 0) {\n    if (b % 2 == 1) res = (res * a) % 1000000007;\n    a = (a * a) % 1000000007;\n    b = b / 2;\n  }\n  return res;\n}\nint main() {\n  int n, k;\n  cin >> n >> k;\n  int x = (k * 8) / n;\n  int ar[n];\n  map<int, int> mp;\n  for (int i = 0; i < n; i++) {\n    cin >> ar[i];\n    mp[ar[i]]++;\n  }\n  int sum = 0;\n  int a = mp.size();\n  int val = 1;\n  while (x > 0 && val < a) {\n    x--;\n    val = val * 2;\n  }\n  if (x == 0 && val < a) {\n    val = a - val;\n    vector<int> v;\n    for (auto it : mp) {\n      v.push_back(it.second);\n    }\n    int ar[v.size()], br[v.size() + 2];\n    ar[0] = v[0];\n    for (int i = 1; i < v.size(); i++) {\n      ar[i] = ar[i - 1] + v[i];\n    }\n    br[v.size() - 1] = v[v.size() - 1];\n    for (int i = v.size() - 2; i >= 0; i--) {\n      br[i] = br[i + 1] + v[i];\n    }\n    int ans = br[v.size() - val];\n    br[v.size()] = 0;\n    for (int i = 0; i < val; i++) {\n      ans = min(ans, ar[i] + br[v.size() - val + i + 1]);\n    }\n    cout << ans << endl;\n  } else {\n    cout << 0 << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.TreeMap;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author prem_cse\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CMP3 solver = new CMP3();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CMP3 {\n        public void solve(int testNumber, FastReader sc, PrintWriter out) {\n            int n = sc.nextInt();\n            int I = 8 * sc.nextInt();\n            int[] a = new int[n];\n            TreeMap<Integer, Integer> map = new TreeMap<>();\n            for (int i = 0; i < n; ++i) {\n                a[i] = sc.nextInt();\n                add(map, a[i]);\n            }\n            int k = I / n;\n\n            int K = Math.min(n, 1 << Math.min(30, k));\n            List<Integer> list = new ArrayList<>();\n            for (int x : map.keySet())\n                list.add(map.get(x));\n            int window = 0;\n            for (int i = 0; i < Math.min(K, list.size()); ++i) {\n                window += list.get(i);\n            }\n            int ans = n - window;\n            for (int i = K; i < list.size(); ++i) {\n                ans = Math.min(ans, n - window);\n                window += list.get(i);\n                window -= list.get(i - K);\n            }\n            out.println(ans);\n        }\n\n        private static void add(Map<Integer, Integer> map, int i) {\n            // TODO Auto-generated method stub\n            if (map.containsKey(i)) map.put(i, map.get(i) + 1);\n            else map.put(i, 1);\n\n        }\n\n    }\n\n    static class FastReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public FastReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long n, m;\n  cin >> n >> m;\n  m = (8 * m) / n;\n  m = pow(2, min(m, 20LL));\n  map<long long, int> arr;\n  for (int i = 0; i < n; i++) {\n    long long p;\n    cin >> p;\n    arr[p]++;\n  }\n  int ans = INT_MAX;\n  if (arr.size() <= m) {\n    cout << 0 << \"\\n\";\n    return 0;\n  }\n  auto l = arr.begin();\n  auto r = l;\n  int left = 0;\n  int right = 0;\n  for (int i = 0; i < m; i++) {\n    right += r->second;\n    r++;\n  }\n  right = n - right;\n  while (r != arr.end()) {\n    ans = min(ans, left + right);\n    left += l->second;\n    l++;\n    right -= r->second;\n    r++;\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 1,
            "solution": "from collections import defaultdict\nimport operator\nimport math\nimport atexit, io, sys\n\nbuffer = io.BytesIO() \nsys.stdout = buffer\n \n@atexit.register \ndef write(): \n    sys.__stdout__.write(buffer.getvalue())\nn,I=map(int,raw_input().split())\nl=map(int,raw_input().split())\nd = defaultdict(int)\nfor i in l:\n    d[i] += 1\np=len(d)\nif n*(int(math.ceil((math.log(p,2)))))<=I*8:\n    print(0)\n    exit()\ncount=0\nk=int(math.floor((I*8)/float(n)))\nx = sorted(d.items(), key=operator.itemgetter(0))\n#print x,p,k\nfor i in xrange(2**k):\n    count+=x[i][1]\nhigh=count\nfor i in xrange(2**k,p):\n    high=high+x[i][1]-x[i-2**k][1]\n    count=max(count,high)\nprint(n-count)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.*;\n\n/**\n * #\n *\n * @author pttrung\n */\npublic class C_Round_576_Div2 {\n\n    public static long MOD = 998244353;\n    static int[][] dp;\n\n    public static void main(String[] args) throws FileNotFoundException {\n        // PrintWriter out = new PrintWriter(new FileOutputStream(new File(\n        // \"output.txt\")));\n        PrintWriter out = new PrintWriter(System.out);\n        Scanner in = new Scanner();\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int total = m * 8;\n        PriorityQueue<Integer>q = new PriorityQueue<>();\n        for (int i = 0; i < n; i++) {\n            q.add(in.nextInt());\n        }\n\n\n        int max = 0;\n        int st = 0;\n        int ed = 31;\n        while (st <= ed) {\n            int mid = (st + ed) / 2;\n            if (mid * n <= total) {\n                max = mid;\n                st = mid + 1;\n            } else {\n                ed = mid - 1;\n            }\n        }\n\n        ArrayList<Integer> list = new ArrayList<>();\n        int last = -1;\n        int count = 0;\n\n        for (int i = 0; i < n; i++) {\n            int v = q.poll();\n            if (v != last) {\n                if (count > 0) {\n                    list.add(count);\n                }\n                count = 1;\n                last = v;\n            } else {\n                count++;\n            }\n        }\n        if (count > 0) {\n            list.add(count);\n        }\n        int need = list.size() - (1 << max);\n        //System.out.println(need);\n        int result = 0;\n        if (need > 0) {\n            int cur = 0;\n            for (int i = 0; i < need; i++) {\n                cur += list.get(i);\n            }\n            result = cur;\n            last = list.size() - 1;\n            for (int i = need - 1; i >= 0; i--) {\n                cur -= list.get(i);\n                cur += list.get(last--);\n                result = Integer.min(result, cur);\n            }\n        }\n        out.println(result);\n\n        out.close();\n    }\n\n    static int log(int n) {\n        int result = 0;\n        long st = 1;\n        for (int i = 0; st <= n; i++) {\n\n            result = i;\n\n            st *= 2L;\n        }\n        return result;\n    }\n\n    static long abs(long v) {\n        return v < 0 ? -v : v;\n    }\n\n    static int[] cal(double v) {\n        int[] re = new int[2];\n        if (v >= 0) {\n            re[0] = (int) Math.floor(v);\n            re[1] = (int) Math.ceil(v);\n        } else {\n            re[0] = (int) Math.ceil(v);\n            re[1] = (int) Math.floor(v);\n        }\n        return re;\n    }\n\n\n    public static int[] KMP(String val) {\n        int i = 0;\n        int j = -1;\n        int[] result = new int[val.length() + 1];\n        result[0] = -1;\n        while (i < val.length()) {\n            while (j >= 0 && val.charAt(j) != val.charAt(i)) {\n                j = result[j];\n            }\n            j++;\n            i++;\n            result[i] = j;\n        }\n        return result;\n\n    }\n\n    public static boolean nextPer(int[] data) {\n        int i = data.length - 1;\n        while (i > 0 && data[i] < data[i - 1]) {\n            i--;\n        }\n        if (i == 0) {\n            return false;\n        }\n        int j = data.length - 1;\n        while (data[j] < data[i - 1]) {\n            j--;\n        }\n        int temp = data[i - 1];\n        data[i - 1] = data[j];\n        data[j] = temp;\n        Arrays.sort(data, i, data.length);\n        return true;\n    }\n\n    public static int digit(long n) {\n        int result = 0;\n        while (n > 0) {\n            n /= 10;\n            result++;\n        }\n        return result;\n    }\n\n    public static double dist(long a, long b, long x, long y) {\n        double val = (b - a) * (b - a) + (x - y) * (x - y);\n        val = Math.sqrt(val);\n        double other = x * x + a * a;\n        other = Math.sqrt(other);\n        return val + other;\n\n    }\n\n    public static class Point implements Comparable<Point> {\n\n        int x, y;\n\n        public Point(int start, int end) {\n            this.x = start;\n            this.y = end;\n        }\n\n        @Override\n        public int hashCode() {\n            int hash = 5;\n            hash = 47 * hash + this.x;\n            hash = 47 * hash + this.y;\n            return hash;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            final Point other = (Point) obj;\n            if (this.x != other.x) {\n                return false;\n            }\n            if (this.y != other.y) {\n                return false;\n            }\n            return true;\n        }\n\n        @Override\n        public int compareTo(Point o) {\n            return Integer.compare(x, o.x);\n        }\n    }\n\n    public static class FT {\n\n        long[] data;\n\n        FT(int n) {\n            data = new long[n];\n        }\n\n        public void update(int index, long value) {\n            while (index < data.length) {\n                data[index] += value;\n                index += (index & (-index));\n            }\n        }\n\n        public long get(int index) {\n            long result = 0;\n            while (index > 0) {\n                result += data[index];\n                index -= (index & (-index));\n            }\n            return result;\n\n        }\n    }\n\n    public static long gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    public static long pow(long a, long b) {\n        if (b == 0) {\n            return 1;\n        }\n        if (b == 1) {\n            return a;\n        }\n        long val = pow(a, b / 2);\n        if (b % 2 == 0) {\n            return val * val;\n        } else {\n            return val * (val * a);\n\n        }\n    }\n\n    static class Scanner {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public Scanner() throws FileNotFoundException {\n            // System.setOut(new PrintStream(new BufferedOutputStream(System.out), true));\n            br = new BufferedReader(new InputStreamReader(System.in));\n            //  br = new BufferedReader(new InputStreamReader(new FileInputStream(new File(\"input.txt\"))));\n        }\n\n        public String next() {\n\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (Exception e) {\n                    throw new RuntimeException();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            st = null;\n            try {\n                return br.readLine();\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n\n        public boolean endLine() {\n            try {\n                String next = br.readLine();\n                while (next != null && next.trim().isEmpty()) {\n                    next = br.readLine();\n                }\n                if (next == null) {\n                    return true;\n                }\n                st = new StringTokenizer(next);\n                return st.hasMoreTokens();\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n/* * */\n\npublic class _576A implements Runnable{\n    public static void main(String[] args) {\n\t    new Thread(null, new _576A(),\"Main\",1<<27).start();\n    }\n    @Override\n    public void run() {\n        FastReader fd = new FastReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        int n = fd.nextInt();\n        long size = fd.nextInt()*8;\n        long maxPossible = size/n;\n        TreeMap<Long,Integer> freq = new TreeMap<>();\n        long[] data = new long[n];\n\n        for(int te = 0; te < n; te++){\n            data[te] = fd.nextLong();\n            freq.put(data[te],freq.getOrDefault(data[te],0)+1);\n        }\n        long req = (long) Math.ceil((Math.log(freq.size())/Math.log(2)))*n;\n        if(req <= size){\n            out.println(0);\n        }\n        else{\n            int count = Integer.MAX_VALUE;\n            long loop = 1L<<Math.min(maxPossible,20);\n            long[] prefix = new long[freq.size()+1];\n            prefix[0] = 0;\n            int ind = 1;\n            for(int i : freq.values()){ prefix[ind] = prefix[ind-1]+i; ind++;}\n\n            for(int i = (int)loop;i < prefix.length;i++) {\n                count = (int) Math.min(count,n-(prefix[i]-prefix[(i-(int)loop)]));\n            }\n            out.println(count);\n        }\n        out.close();\n    }\n\n    //Helper functions\n    static int[] getArray(int n,boolean isSorted, FastReader fd){\n        int[] data = new int[n];\n        for(int i = 0; i < data.length; i++){ data[i] = fd.nextInt(); }\n        if(isSorted) Arrays.sort(data);\n        return data;\n    }\n    static int gcd(int a, int b) {\n        if (a == 0)\n            return b;\n        return gcd(b % a, a);\n    }\n\n    static int lcm(int a, int b) {\n        return (a*b)/gcd(a, b);\n    }\n\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars==-1)\n                throw new InputMismatchException();\n\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n\n                if(numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n\n            while(isSpaceChar(c))\n                c = read();\n\n            int sgn = 1;\n\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n\n            int res = 0;\n            do {\n                if(c<'0'||c>'9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n}\n"
        },
        {
            "language": 3,
            "solution": "# @author \n\nimport sys\n\nclass CMP3:\n    def solve(self):\n        import math\n        from bisect import bisect_left\n\n        def nb_diff(a, l, r):\n            return pre[r] - pre[l - 1] + int(l > 0 and a[l] == a[l - 1])\n\n        n, I = [int(_) for _ in input().split()]\n        a = [int(_) for _ in input().split()]\n        a.sort()\n        km = n\n        if (8 * I) // n <= math.log2(n):\n            km = 2 ** (8 * I // n)\n\n        ans = float('inf')\n        pre = [0] * (n + 1)\n        pre[0] = 1\n        for i in range(1, n):\n            pre[i] = pre[i - 1]\n            if a[i] != a[i - 1]:\n                pre[i] += 1\n\n        d = len(set(a))\n\n        for l in range(n):\n            lo, hi = l, n\n            while lo < hi:\n                m = (lo + hi) >> 1\n                if nb_diff(a, l, m) > km:\n                    hi = m\n                else:\n                    lo = m + 1\n\n            # assert(pre[lo - 1] - pre[l - 1] <= km)\n            # print(l, lo - 1, nb_diff(a, l, lo - 1), n - (lo - 1 - l + 1))\n\n            ans = min(ans, n - (lo - 1 - l + 1))\n\n        # print(a, km, pre)\n        print(ans)\n\nsolver = CMP3()\ninput = sys.stdin.readline\n\nsolver.solve()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing u64 = unsigned long long;\ntemplate <class T>\nstd::vector<T> read(int n) {\n  std::vector<T> res(n);\n  for (auto& r : res) {\n    std::cin >> r;\n  }\n  return res;\n}\nint lg_ceil(u64 n) { return 63 - __builtin_clzll(2 * n - 1); }\nint main() {\n  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);\n  int n, I;\n  std::cin >> n >> I;\n  std::map<int, int> a;\n  for (int v : read<int>(n)) {\n    a[v]++;\n  }\n  int ans = n;\n  int ll = 0, rr = n, dist = 0;\n  for (auto l = begin(a), r = begin(a); l != end(a);\n       ll += l->second, ++l, --dist) {\n    while (r != end(a) && lg_ceil(dist + 1) * n <= 8 * I) {\n      rr -= r->second;\n      ++r;\n      ++dist;\n    }\n    if (lg_ceil(dist) * n <= 8 * I) {\n      ans = std::min(ans, ll + rr);\n    }\n  }\n  std::cout << ans << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int a[500000];\n  set<int> st;\n  map<int, int> mp;\n  vector<int> b;\n  vector<int> c;\n  int d[500000];\n  int e[500000];\n  int n, k;\n  int x, y, z;\n  int s, ans;\n  bool v = true;\n  ans = 0;\n  scanf(\"%d %d\", &n, &k);\n  for (int i = 0; i < int(n); i++) {\n    scanf(\"%d\", &a[i]);\n    if (st.count(a[i]) == 0) {\n      st.insert(a[i]);\n      b.push_back(a[i]);\n      c.push_back(0);\n    }\n  }\n  sort(b.begin(), b.end());\n  for (int i = 0; i < int(b.size()); i++) mp[b[i]] = i;\n  for (int i = 0; i < int(n); i++) c[mp[a[i]]]++;\n  k = 8 * k;\n  k = k / n;\n  if (k > 20) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  x = 1;\n  for (int i = 0; i < int(k); i++) x = x * 2;\n  k = x;\n  if (b.size() <= k) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  d[0] = 0;\n  for (int i = 0; i < int(b.size()); i++) d[i + 1] = d[i] + c[i];\n  e[n] = 0;\n  for (int i = b.size() - 1; i >= 0; i--) e[i] = e[i + 1] + c[i];\n  ans = n;\n  for (int i = 0; i < int(b.size() - k + 1); i++) {\n    s = d[i] + e[k + i];\n    ans = min(ans, s);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint m;\nint a[400000 + 10];\nint g[400000 + 10];\nlong long sum[400000 + 10];\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n  sort(a, a + n);\n  int cnt = 0;\n  int pre = -1;\n  for (int i = 0; i < n; i++) {\n    if (a[i] > pre) cnt++, pre = a[i];\n    g[cnt]++;\n  }\n  double k = (m * 8.0) / ((double)n);\n  int ans = 1;\n  for (int i = 0; i < (int)k; i++) {\n    ans = ans * 2;\n    if (ans >= cnt) {\n      break;\n    }\n  }\n  if (ans >= cnt) {\n    printf(\"0\\n\");\n    return 0;\n  }\n  long long res = n;\n  for (int i = 1; i <= cnt; i++) {\n    sum[i] = sum[i - 1] + (long long)g[i];\n  }\n  for (int i = ans; i <= n; i++) {\n    res = min(res, n - (sum[i] - sum[i - ans]));\n  }\n  printf(\"%lld\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "#code\nn,I=map(int,input().split())\na=list(map(int,input().split()))\nk=2**((I*8)//n)\na.sort()\nls=[]\ncnt=1\nfor i in range(1,n):\n    if(a[i]==a[i-1]):\n        cnt+=1\n    else:\n        ls.append([cnt,a[i-1]])\n        cnt=1\nif(cnt):ls.append([cnt,a[-1]])\ndis=len(ls)\nif(dis<=k):\n    print(0)\nelse:\n    #print(ls)\n    prefix=[0 for i in range(len(ls)+1)]\n    for i in range(1,len(ls)+1):\n        prefix[i]=prefix[i-1]+ls[i-1][0]\n    suffix=[0 for i in range(len(ls)+1)]\n    for i in range(len(ls)-1,-1,-1):\n        suffix[i]=suffix[i+1]+ls[i][0]\n    #print(prefix)\n    #print(suffix)\n    ans=n\n    for i in range(dis-k+1):\n        ans=min(ans,prefix[i]+suffix[len(ls)-dis+k+i])\n        #print(prefix[i],suffix[len(ls)-dis+k+i])\n    print(ans)        "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n;\n  long long m;\n  scanf(\"%d %lld\", &n, &m);\n  vector<int> v(n);\n  for (auto& e : v) scanf(\"%d\", &e);\n  int k = (m * 8) / n;\n  k = min(k, 30);\n  vector<pair<int, int>> P;\n  sort(v.begin(), v.end());\n  for (int i = 0; i < n; i++) {\n    int x = 0;\n    int j;\n    for (j = i; j < n && v[j] == v[i]; j++)\n      ;\n    x = j - i;\n    P.push_back({i, x});\n    i = j - 1;\n  }\n  for (int i = 1; i < P.size(); i++) P[i].second += P[i - 1].second;\n  int ret = n;\n  for (int i = 0; i < P.size(); i++) {\n    int to_try = n;\n    int last = min(i + (1 << k) - 1, (int)P.size() - 1);\n    to_try -= P[last].second;\n    to_try += i > 0 ? P[i - 1].second : 0;\n    ret = min(ret, to_try);\n  }\n  printf(\"%d\\n\", ret);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.util.Comparator.*;\n\npublic class Main {\n    FastScanner in;\n    PrintWriter out;\n    boolean multitests = false;\n    long mod = (long) 1e9 + 7; // 998_244_353L || (long) 1e9 + 9\n    ArrayList<Integer>[] graph;\n    ArrayList<GraphPair>[] weightedGraph;\n\n    private void solve() throws IOException {\n        // solveA();\n        // solveB();\n        solveC();\n        // solveD();\n        // solveE();\n        // solveF();\n    }\n\n    private void solveA() throws IOException {\n        int n = in.nextInt(), x = in.nextInt(), y = in.nextInt();\n        int[] a = in.nextIntArray(n);\n        for (int d = 0; d < n; d++) {\n            boolean ok = true;\n            for (int j = max(0, d - x); j < d; j++)\n                ok &= a[d] < a[j];\n            for (int j = min(n - 1, d + y); j > d; j--)\n                ok &= a[d] < a[j];\n            if (ok) {\n                out.println(d + 1);\n                return;\n            }\n        }\n    }\n\n    private void solveB() throws IOException {\n        long H = in.nextLong(), L = in.nextLong();\n        out.println((H * H + L * L) / 2.0 / H - H);\n    }\n\n    private void solveC() throws IOException {\n        int n = in.nextInt();\n        int k = in.nextInt() * 8 / n;\n\n        if (k > 20) {\n            out.println(0);\n            return;\n        }\n\n        int[] a = in.nextIntArray(n);\n        shuffleInt(a);\n        sort(a);\n\n        int[][] stack = new int[2][n];\n        int stackSize = 0;\n        for (int i = 0; i < n; i++) {\n            if (i == 0 || a[i - 1] != a[i]) {\n                stack[0][stackSize] = a[i];\n                stack[1][stackSize] = 1;\n                stackSize++;\n            } else\n                stack[1][stackSize - 1]++;\n        }\n\n        if ((1 << k) >= stackSize) {\n            out.println(0);\n            return;\n        }\n\n        int max = 0, sum = 0;\n        for (int i = 1 << k, l = 0, r = 0; i <= stackSize; i++) {\n            while (r < i)\n                sum += stack[1][r++];\n            while (l < i - (1 << k))\n                sum -= stack[1][l++];\n            max = max(max, sum);\n        }\n        out.println(n - max);\n    }\n\n    private void solveD() throws IOException {\n\n    }\n\n    private void solveE() throws IOException {\n\n    }\n\n    private void solveF() throws IOException {\n\n    }\n\n    void shuffleInt(int[] a) {\n        Random random = new Random();\n        for (int i = a.length - 1; i > 0; i--) {\n            int j = random.nextInt(i + 1);\n            int swap = a[j];\n            a[j] = a[i];\n            a[i] = swap;\n        }\n    }\n\n    void shuffleLong(long[] a) {\n        Random random = new Random();\n        for (int i = a.length - 1; i > 0; i--) {\n            int j = random.nextInt(i + 1);\n            long swap = a[j];\n            a[j] = a[i];\n            a[i] = swap;\n        }\n    }\n\n    void reverseInt(int[] a) {\n        for (int i = 0, j = a.length - 1; i < j; i++, j--) {\n            int swap = a[i];\n            a[i] = a[j];\n            a[j] = swap;\n        }\n    }\n\n    void reverseLong(long[] a) {\n        for (int i = 0, j = a.length - 1; i < j; i++, j--) {\n            long swap = a[i];\n            a[i] = a[j];\n            a[j] = swap;\n        }\n    }\n\n    int maxInt(int[] a) {\n        int max = a[0];\n        for (int i = 1; i < a.length; i++)\n            if (max < a[i])\n                max = a[i];\n        return max;\n    }\n\n    long maxLong(long[] a) {\n        long max = a[0];\n        for (int i = 1; i < a.length; i++)\n            if (max < a[i])\n                max = a[i];\n        return max;\n    }\n\n    int minInt(int[] a) {\n        int min = a[0];\n        for (int i = 1; i < a.length; i++)\n            if (min > a[i])\n                min = a[i];\n        return min;\n    }\n\n    long minLong(long[] a) {\n        long min = a[0];\n        for (int i = 1; i < a.length; i++)\n            if (min > a[i])\n                min = a[i];\n        return min;\n    }\n\n    long sumInt(int[] a) {\n        long s = 0;\n        for (int i = 0; i < a.length; i++)\n            s += a[i];\n        return s;\n    }\n\n    long sumLong(long[] a) {\n        long s = 0;\n        for (int i = 0; i < a.length; i++)\n            s += a[i];\n        return s;\n    }\n\n    long gcd(long a, long b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    long binpowmod(long a, long n) {\n        long res = 1;\n        a %= mod;\n        n %= mod - 1;\n        while (n > 0) {\n            if (n % 2 == 1)\n                res = (res * a) % mod;\n            a = (a * a) % mod;\n            n /= 2;\n        }\n        return res;\n    }\n\n    class GraphPair implements Comparable<GraphPair> {\n        int v;\n        long w;\n\n        GraphPair(int v, long w) {\n            this.v = v;\n            this.w = w;\n        }\n\n        public int compareTo(GraphPair o) {\n            return w != o.w ? Long.compare(w, o.w) : Integer.compare(v, o.v);\n        }\n    }\n\n    ArrayList<Integer>[] createGraph(int n) throws IOException {\n        ArrayList<Integer>[] graph = new ArrayList[n];\n        for (int i = 0; i < n; i++)\n            graph[i] = new ArrayList<>();\n        return graph;\n    }\n\n    ArrayList<GraphPair>[] createWeightedGraph(int n) throws IOException {\n        ArrayList<GraphPair>[] graph = new ArrayList[n];\n        for (int i = 0; i < n; i++)\n            graph[i] = new ArrayList<>();\n        return graph;\n    }\n\n    class FastScanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        FastScanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s), 32768);\n        }\n\n        String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        boolean hasNext() throws IOException {\n            return br.ready() || (st != null && st.hasMoreTokens());\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) throws IOException {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = in.nextInt();\n            return a;\n        }\n\n        int[][] nextIntTable(int n, int m) throws IOException {\n            int[][] a = new int[n][m];\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < m; j++)\n                    a[i][j] = in.nextInt();\n            return a;\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        long[] nextLongArray(int n) throws IOException {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = in.nextLong();\n            return a;\n        }\n\n        long[][] nextLongTable(int n, int m) throws IOException {\n            long[][] a = new long[n][m];\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < m; j++)\n                    a[i][j] = in.nextLong();\n            return a;\n        }\n\n        ArrayList<Integer>[] nextGraph(int n, int m, boolean directed) throws IOException {\n            ArrayList<Integer>[] graph = createGraph(n);\n            for (int i = 0; i < m; i++) {\n                int v = in.nextInt() - 1, u = in.nextInt() - 1;\n                graph[v].add(u);\n                if (!directed)\n                    graph[u].add(v);\n            }\n            return graph;\n        }\n\n        ArrayList<GraphPair>[] nextWeightedGraph(int n, int m, boolean directed) throws IOException {\n            ArrayList<GraphPair>[] graph = createWeightedGraph(n);\n            for (int i = 0; i < m; i++) {\n                int v = in.nextInt() - 1, u = in.nextInt() - 1;\n                long w = in.nextLong();\n                graph[v].add(new GraphPair(u, w));\n                if (!directed)\n                    graph[u].add(new GraphPair(v, w));\n            }\n            return graph;\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        boolean hasNextLine() throws IOException {\n            return br.ready();\n        }\n    }\n\n    private void run() throws IOException {\n        in = new FastScanner(System.in); // new FastScanner(new FileInputStream(\".in\"));\n        out = new PrintWriter(System.out); // new PrintWriter(new FileOutputStream(\".out\"));\n\n        for (int t = multitests ? in.nextInt() : 1; t-- > 0; )\n            solve();\n\n        out.flush();\n        out.close();\n    }\n\n    public static void main(String[] args) throws IOException {\n        new Main().run();\n    }\n}"
        }
    ]
}