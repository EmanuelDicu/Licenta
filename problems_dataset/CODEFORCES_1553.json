{
    "name": "1553_I. Stairs",
    "source": "CODEFORCES",
    "description": "For a permutation p of numbers 1 through n, we define a stair array a as follows: a_i is length of the longest segment of permutation which contains position i and is made of consecutive values in sorted order: [x, x+1, \u2026, y-1, y] or [y, y-1, \u2026, x+1, x] for some x \u2264 y. For example, for permutation p = [4, 1, 2, 3, 7, 6, 5] we have a = [1, 3, 3, 3, 3, 3, 3]. \n\nYou are given the stair array a. Your task is to calculate the number of permutations which have stair array equal to a. Since the number can be big, compute it modulo 998 244 353. Note that this number can be equal to zero.\n\nInput\n\nThe first line of input contains integer n (1 \u2264 n \u2264 10^5) \u2014 the length of a stair array a.\n\nThe second line of input contains n integers a_1, a_2, \u2026, a_n (1 \u2264 a_i \u2264 n).\n\nOutput\n\nPrint the number of permutations which have stair array equal to a. Since the number can be big, compute it modulo 998 244 353.\n\nExamples\n\nInput\n\n\n6\n3 3 3 1 1 1\n\n\nOutput\n\n\n6\n\n\nInput\n\n\n7\n4 4 4 4 3 3 3\n\n\nOutput\n\n\n6\n\n\nInput\n\n\n1\n1\n\n\nOutput\n\n\n1\n\n\nInput\n\n\n8\n2 2 2 2 2 2 1 1\n\n\nOutput\n\n\n370\n\n\nInput\n\n\n4\n3 2 3 1\n\n\nOutput\n\n\n0",
    "difficulty": "I",
    "tags": [
        "combinatorics",
        "divide and conquer",
        "dp",
        "fft",
        "math"
    ],
    "rating": 3400,
    "public_test": [
        {
            "input": "1\n1\n",
            "output": "1\n"
        },
        {
            "input": "4\n3 2 3 1\n",
            "output": "0\n"
        },
        {
            "input": "8\n2 2 2 2 2 2 1 1\n",
            "output": "370\n"
        },
        {
            "input": "6\n3 3 3 1 1 1\n",
            "output": "6\n"
        },
        {
            "input": "7\n4 4 4 4 3 3 3\n",
            "output": "6\n"
        }
    ],
    "generated_test": [
        {
            "input": "4\n5 2 3 1\n",
            "output": "0\n"
        },
        {
            "input": "4\n3 3 3 1\n",
            "output": "2\n"
        },
        {
            "input": "7\n4 4 4 5 3 3 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 2 3 2\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 4 2 5 3 3 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 3 3 2\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 3 0 2\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 3 -1 2\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 0 -1 2\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 0 -2 2\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 4 4 8 3 3 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n6 2 3 1\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 4 3 5 3 3 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 2 3 4\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 4 2 5 5 3 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 3 -1 4\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 0 0 2\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 5 -1 2\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 0 -1 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 0 -2 3\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 3 4 8 3 3 3\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 4 5 5 3 3 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n6 2 3 4\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 4 1 5 5 3 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 3 -1 6\n",
            "output": "0\n"
        },
        {
            "input": "4\n10 0 0 2\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 1 -1 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 0 -4 3\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 3 4 8 3 2 3\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 4 5 3 3 3 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n10 2 3 4\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 4 0 5 5 3 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 3 -1 7\n",
            "output": "0\n"
        },
        {
            "input": "4\n19 0 0 2\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 1 -4 3\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 3 4 8 4 2 3\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 4 5 3 3 4 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n10 2 6 4\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 4 0 6 5 3 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 3 0 7\n",
            "output": "0\n"
        },
        {
            "input": "4\n19 1 0 2\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 0 -4 5\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 3 7 8 4 2 3\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 7 5 3 3 4 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n10 3 6 4\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 4 0 6 10 3 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 3 1 7\n",
            "output": "0\n"
        },
        {
            "input": "4\n19 1 1 2\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 1 -4 5\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 3 7 8 1 2 3\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 7 1 3 3 4 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n10 0 6 4\n",
            "output": "0\n"
        },
        {
            "input": "4\n1 3 1 7\n",
            "output": "0\n"
        },
        {
            "input": "4\n19 0 1 2\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 1 -4 10\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 3 7 2 1 2 3\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 7 1 3 1 4 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n10 1 6 4\n",
            "output": "0\n"
        },
        {
            "input": "4\n1 3 2 7\n",
            "output": "0\n"
        },
        {
            "input": "4\n19 -1 1 2\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 1 -2 10\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 3 0 2 1 2 3\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 7 1 5 1 4 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n2 2 6 4\n",
            "output": "0\n"
        },
        {
            "input": "4\n1 3 2 6\n",
            "output": "0\n"
        },
        {
            "input": "4\n19 -2 1 2\n",
            "output": "0\n"
        },
        {
            "input": "4\n6 1 -2 10\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 3 0 2 1 2 6\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 7 1 6 1 4 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n2 2 6 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n1 4 2 6\n",
            "output": "0\n"
        },
        {
            "input": "4\n19 -2 1 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n4 1 -2 10\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 3 0 2 1 2 12\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 7 2 6 1 4 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n1 4 2 2\n",
            "output": "0\n"
        },
        {
            "input": "4\n19 -2 1 1\n",
            "output": "0\n"
        },
        {
            "input": "4\n4 1 -2 3\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 0 0 2 1 2 12\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 9 2 6 1 4 3\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 9 3 6 1 4 3\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 4 3 6 1 4 3\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 7 3 6 1 4 3\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 2 3 6 1 4 3\n",
            "output": "0\n"
        },
        {
            "input": "8\n2 2 2 3 2 2 1 1\n",
            "output": "0\n"
        },
        {
            "input": "6\n6 3 3 1 1 1\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 4 4 4 3 3 5\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 1 3 1\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 4 0 5 3 3 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 2 0 2\n",
            "output": "0\n"
        },
        {
            "input": "7\n3 4 2 5 3 3 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n8 3 3 2\n",
            "output": "0\n"
        },
        {
            "input": "4\n9 3 0 2\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 4 -1 2\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 0 -1 1\n",
            "output": "0\n"
        },
        {
            "input": "4\n10 0 -2 2\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 4 4 13 3 3 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n6 3 3 1\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 6 3 5 3 3 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 2 0 4\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 4 2 5 5 3 1\n",
            "output": "0\n"
        },
        {
            "input": "4\n8 3 -1 4\n",
            "output": "0\n"
        },
        {
            "input": "4\n10 0 1 2\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 5 0 2\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 -1 -2 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 -1 -2 2\n",
            "output": "0\n"
        },
        {
            "input": "7\n5 3 4 8 3 3 3\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 4 5 5 3 1 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n7 2 3 4\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 7 1 5 5 3 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 3 0 6\n",
            "output": "0\n"
        },
        {
            "input": "4\n10 1 -1 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 -1 -4 3\n",
            "output": "0\n"
        },
        {
            "input": "7\n8 3 4 8 3 3 3\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 3 5 3 3 3 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n1 2 3 4\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 4 0 5 5 3 4\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 4 -1 7\n",
            "output": "0\n"
        },
        {
            "input": "4\n19 1 2 2\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 1 -4 4\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 3 4 1 4 2 3\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 4 5 4 3 4 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n10 4 6 4\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 3 0 6 5 3 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 3 0 13\n",
            "output": "0\n"
        },
        {
            "input": "4\n11 1 2 2\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 0 -2 5\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 3 7 7 4 2 3\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 14 5 3 3 4 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n10 3 6 1\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 4 -1 6 10 3 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n36 1 1 2\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 1 -4 7\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 3 7 12 1 2 3\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 7 1 6 3 4 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n10 0 5 4\n",
            "output": "0\n"
        },
        {
            "input": "4\n29 -1 1 2\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 1 -6 10\n",
            "output": "0\n"
        },
        {
            "input": "7\n2 3 7 2 1 2 3\n",
            "output": "0\n"
        },
        {
            "input": "7\n7 7 1 3 1 4 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n15 1 6 4\n",
            "output": "0\n"
        },
        {
            "input": "4\n1 4 2 7\n",
            "output": "0\n"
        },
        {
            "input": "4\n19 -1 2 2\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 1 -2 20\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 3 0 1 1 2 3\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 1 1 5 1 4 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n4 2 6 4\n",
            "output": "0\n"
        },
        {
            "input": "4\n1 3 2 11\n",
            "output": "0\n"
        },
        {
            "input": "4\n2 -2 1 2\n",
            "output": "0\n"
        },
        {
            "input": "4\n6 2 -2 10\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 3 -1 2 1 2 6\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 7 1 6 1 8 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n1 4 2 9\n",
            "output": "0\n"
        },
        {
            "input": "4\n19 -2 0 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n4 1 -2 13\n",
            "output": "0\n"
        },
        {
            "input": "7\n6 3 0 2 1 2 12\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 7 2 11 1 4 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n1 4 0 2\n",
            "output": "0\n"
        },
        {
            "input": "4\n19 -4 1 1\n",
            "output": "0\n"
        },
        {
            "input": "4\n4 1 0 3\n",
            "output": "0\n"
        },
        {
            "input": "7\n2 9 2 6 1 4 3\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 9 3 6 1 4 4\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 4 3 11 1 4 3\n",
            "output": "0\n"
        },
        {
            "input": "7\n8 7 3 6 1 4 3\n",
            "output": "0\n"
        },
        {
            "input": "7\n7 2 3 6 1 4 3\n",
            "output": "0\n"
        },
        {
            "input": "8\n2 2 2 3 4 2 1 1\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 4 4 4 3 2 5\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 1 1 1\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 6 0 5 3 3 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 0 0 4\n",
            "output": "0\n"
        },
        {
            "input": "7\n3 6 2 5 3 3 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n8 5 3 2\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 2 -1 2\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 1 -1 1\n",
            "output": "0\n"
        },
        {
            "input": "4\n10 -1 -2 2\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 4 3 13 3 3 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n1 3 3 1\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 6 3 5 3 3 6\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 3 0 4\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 0 2 5 5 3 1\n",
            "output": "0\n"
        },
        {
            "input": "4\n10 3 -1 4\n",
            "output": "0\n"
        },
        {
            "input": "4\n23 0 1 2\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 9 0 2\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 -2 -2 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n6 -1 -2 2\n",
            "output": "0\n"
        },
        {
            "input": "7\n5 3 4 8 5 3 3\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 4 2 5 3 1 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n7 2 1 4\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 7 1 1 5 3 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n1 3 0 6\n",
            "output": "0\n"
        },
        {
            "input": "4\n10 0 -1 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 -2 -4 3\n",
            "output": "0\n"
        },
        {
            "input": "7\n8 6 4 8 3 3 3\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 3 2 3 3 3 3\n",
            "output": "0\n"
        },
        {
            "input": "4\n2 2 3 4\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 4 0 5 5 3 2\n",
            "output": "0\n"
        },
        {
            "input": "4\n3 4 -1 7\n",
            "output": "0\n"
        },
        {
            "input": "4\n19 2 2 2\n",
            "output": "0\n"
        },
        {
            "input": "4\n5 1 0 4\n",
            "output": "0\n"
        },
        {
            "input": "7\n4 3 4 2 4 2 3\n",
            "output": "0\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid rd(T& x) {\n  int f = 0, c;\n  while (!isdigit(c = getchar())) f ^= !(c ^ 45);\n  x = (c & 15);\n  while (isdigit(c = getchar())) x = x * 10 + (c & 15);\n  if (f) x = -x;\n}\ntemplate <typename T>\nvoid pt(T x, int c = -1) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x > 9) pt(x / 10);\n  putchar(x % 10 + 48);\n  if (c != -1) putchar(c);\n}\nconst int P = 998244353;\nint ad(int k1, int k2) { return k1 += k2 - P, k1 += k1 >> 31 & P; }\nint su(int k1, int k2) { return k1 -= k2, k1 += k1 >> 31 & P; }\nint mu(int k1, int k2) { return 1LL * k1 * k2 % P; }\nvoid uad(int& k1, int k2) { k1 += k2 - P, k1 += k1 >> 31 & P; }\nvoid usu(int& k1, int k2) { k1 -= k2, k1 += k1 >> 31 & P; }\ntemplate <typename... T>\nint ad(int k1, T... k2) {\n  return ad(k1, ad(k2...));\n}\ntemplate <typename... T>\nvoid uad(int& k1, T... k2) {\n  return uad(k1, ad(k2...));\n}\ntemplate <typename... T>\nvoid usu(int& k1, T... k2) {\n  return usu(k1, ad(k2...));\n}\ntemplate <typename... T>\nint mu(int k1, T... k2) {\n  return mu(k1, mu(k2...));\n}\nint po(int k1, int k2) {\n  int k3 = 1;\n  for (; k2; k2 >>= 1, k1 = mu(k1, k1))\n    if (k2 & 1) k3 = mu(k3, k1);\n  return k3;\n}\nnamespace ntt {\nint base = 1, root = -1, maxbase = -1;\nstd::vector<int> roots = {0, 1}, rev = {0, 1};\nvoid init() {\n  int tmp = P - 1;\n  maxbase = 0;\n  while (!(tmp & 1)) tmp >>= 1, maxbase++;\n  root = 2;\n  while (1) {\n    if (po(root, 1 << maxbase) == 1 && po(root, 1 << (maxbase - 1)) != 1) break;\n    root++;\n  }\n}\nvoid ensure_base(int nbase) {\n  if (maxbase == -1) init();\n  if (nbase <= base) return;\n  rev.resize(1 << nbase);\n  for (int i = 1; i < (1 << nbase); ++i)\n    rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (nbase - 1));\n  roots.resize(1 << nbase);\n  while (base < nbase) {\n    int z = po(root, 1 << (maxbase - base - 1));\n    for (int i = (1 << (base - 1)); i < (1 << base); ++i)\n      roots[i << 1] = roots[i], roots[i << 1 | 1] = mu(roots[i], z);\n    base++;\n  }\n}\nvoid dft(std::vector<int>& a) {\n  int n = a.size(), zeros = __builtin_ctz(n);\n  ensure_base(zeros);\n  int shift = base - zeros;\n  for (int i = 0; i < n; ++i)\n    if (i < (rev[i] >> shift)) std::swap(a[i], a[rev[i] >> shift]);\n  for (int mid = 1; mid < n; mid <<= 1)\n    for (int i = 0; i < n; i += (mid << 1))\n      for (int j = 0; j < mid; ++j) {\n        int x = a[i + j], y = mu(a[i + j + mid], roots[mid + j]);\n        a[i + j] = ad(x, y);\n        a[i + j + mid] = su(x, y);\n      }\n}\nstd::vector<int> operator*(std::vector<int> a, std::vector<int> b) {\n  if (((int)(a).size()) <= 50 && ((int)(b).size()) <= 50) {\n    vector<int> c(((int)(a).size()) + ((int)(b).size()) - 1);\n    for (int i = (0); i <= (((int)(a).size()) - 1); ++i)\n      for (int j = (0); j <= (((int)(b).size()) - 1); ++j)\n        uad(c[i + j], mu(a[i], b[j]));\n    return c;\n  }\n  int need = a.size() + b.size() - 1, nbase = 0;\n  while ((1 << nbase) < need) nbase++;\n  ensure_base(nbase);\n  int size = 1 << nbase;\n  a.resize(size);\n  b.resize(size);\n  dft(a);\n  dft(b);\n  int inv = po(size, P - 2);\n  for (int i = 0; i < size; ++i) a[i] = mu(a[i], mu(b[i], inv));\n  std::reverse(a.begin() + 1, a.end());\n  dft(a);\n  a.resize(need);\n  return a;\n}\n}  // namespace ntt\nusing ntt::operator*;\nvector<int> operator+(vector<int> a, vector<int> b) {\n  if (a.size() < b.size()) a.resize(b.size());\n  for (int i = 0; i < (int)b.size(); i++) uad(a[i], b[i]);\n  return a;\n}\nconst int N = 1e5 + 5;\nvector<int> poly[N];\nint a[N], b[N], fac[N], inv[N];\nint n, m, tot;\nvector<int> solve(int l, int r) {\n  if (l == r) return poly[l];\n  int mid = (l + r) >> 1;\n  return solve(l, mid) * solve(mid + 1, r);\n}\nvector<int> f[N][2][2];\nint vis[N][2][2];\nvector<int> calc(int len, int l, int r) {\n  if (len == 0) {\n    vector<int> ans(1);\n    ans[0] = 1;\n    return ans;\n  }\n  if (len == 1) {\n    vector<int> ans(2);\n    ans[0] = 1;\n    ans[1] = mu((P + 1) / 2, po(2, 2 - l - r));\n    return ans;\n  }\n  if (len == 2) {\n    vector<int> ans(3);\n    ans[0] = 1;\n    ans[1] = 4 - l - r;\n    ans[2] = mu((P + 1) / 2, po(2, 2 - l - r));\n    return ans;\n  }\n  if (vis[len][l][r]) return f[len][l][r];\n  vis[len][l][r] = 1;\n  for (int i = 0; i <= 1; i++) {\n    vector<int> L = calc((len - 1) >> 1, l, i);\n    vector<int> R = calc(len >> 1, i, r);\n    L = L * R;\n    if (i == 1) {\n      L.push_back(0);\n      for (int i = (int)L.size() - 1; i >= 1; i--) L[i] = mu(L[i - 1], 2);\n      L[0] = 0;\n    }\n    f[len][l][r] = f[len][l][r] + L;\n  }\n  return f[len][l][r];\n}\nint main() {\n  fac[0] = 1;\n  for (int i = 1; i <= 100000; i++) fac[i] = mu(fac[i - 1], i);\n  inv[100000] = po(fac[100000], P - 2);\n  for (int i = 100000; i >= 1; i--) inv[i - 1] = mu(inv[i], i);\n  rd(n);\n  for (int i = 1; i <= n; i++) rd(a[i]);\n  for (int l = 1, r; l <= n; l = r + 1) {\n    int len = a[l];\n    r = l + len - 1;\n    if (r > n) {\n      pt(0, '\\n');\n      return 0;\n    }\n    for (int i = l; i <= r; i++) {\n      if (a[i] != len) {\n        pt(0, '\\n');\n        return 0;\n      }\n    }\n    b[++m] = len;\n  }\n  for (int l = 1, r; l <= m; l = r + 1) {\n    r = l;\n    if (b[l] != 1) continue;\n    while (r < m && b[r + 1] == 1) ++r;\n    poly[++tot] = calc(r - l + (l != 1) + (r != m), l != 1, r != m);\n  }\n  for (int i = 1; i < m; i++) {\n    if (b[i] != 1 && b[i + 1] != 1) {\n      ++tot;\n      poly[tot].resize(2);\n      poly[tot][0] = 1;\n      poly[tot][1] = (P + 1) / 2;\n    }\n  }\n  int coef = 1;\n  for (int i = 1; i <= m; i++) {\n    if (b[i] != 1) {\n      coef = mu(coef, 2);\n    }\n  }\n  vector<int> res(1, 1);\n  if (tot) res = solve(1, tot);\n  int ans = 0;\n  for (int i = 0; i < m; i++) {\n    int now = mu(res[i], fac[m - i]);\n    if (i & 1)\n      ans = su(ans, now);\n    else\n      ans = ad(ans, now);\n  }\n  pt(mu(ans, coef), '\\n');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <typename T>\nbool chkmax(T &x, T y) {\n  return x < y ? x = y, true : false;\n}\ntemplate <typename T>\nbool chkmin(T &x, T y) {\n  return x > y ? x = y, true : false;\n}\nusing namespace std;\nlong long ksm(long long a, long long b) {\n  if (!b) return 1;\n  long long ns = ksm(a, b >> 1);\n  ns = ns * ns % 998244353;\n  if (b & 1) ns = ns * a % 998244353;\n  return ns;\n}\nconst int md = 998244353;\ninline void add(int &x, int y) {\n  x += y;\n  if (x >= md) {\n    x -= md;\n  }\n}\ninline void sub(int &x, int y) {\n  x -= y;\n  if (x < 0) {\n    x += md;\n  }\n}\ninline int mul(int x, int y) { return (long long)x * y % md; }\ninline int power(int x, int y) {\n  int res = 1;\n  for (; y; y >>= 1, x = mul(x, x)) {\n    if (y & 1) {\n      res = mul(res, x);\n    }\n  }\n  return res;\n}\ninline int inv(int a) {\n  a %= md;\n  if (a < 0) {\n    a += md;\n  }\n  int b = md, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= t * a;\n    swap(a, b);\n    u -= t * v;\n    swap(u, v);\n  }\n  if (u < 0) {\n    u += md;\n  }\n  return u;\n}\nnamespace ntt {\nint base = 1, root = -1, max_base = -1;\nvector<int> rev = {0, 1}, roots = {0, 1};\nvoid init() {\n  int temp = md - 1;\n  max_base = 0;\n  while (temp % 2 == 0) {\n    temp >>= 1;\n    ++max_base;\n  }\n  root = 2;\n  while (true) {\n    if (power(root, 1 << max_base) == 1 &&\n        power(root, 1 << max_base - 1) != 1) {\n      break;\n    }\n    ++root;\n  }\n}\nvoid ensure_base(int nbase) {\n  if (max_base == -1) {\n    init();\n  }\n  if (nbase <= base) {\n    return;\n  }\n  assert(nbase <= max_base);\n  rev.resize(1 << nbase);\n  for (int i = 0; i < 1 << nbase; ++i) {\n    rev[i] = rev[i >> 1] >> 1 | (i & 1) << nbase - 1;\n  }\n  roots.resize(1 << nbase);\n  while (base < nbase) {\n    int z = power(root, 1 << max_base - 1 - base);\n    for (int i = 1 << base - 1; i < 1 << base; ++i) {\n      roots[i << 1] = roots[i];\n      roots[i << 1 | 1] = mul(roots[i], z);\n    }\n    ++base;\n  }\n}\nvoid dft(vector<int> &a) {\n  int n = a.size(), zeros = __builtin_ctz(n);\n  ensure_base(zeros);\n  int shift = base - zeros;\n  for (int i = 0; i < n; ++i) {\n    if (i < rev[i] >> shift) {\n      swap(a[i], a[rev[i] >> shift]);\n    }\n  }\n  for (int i = 1; i < n; i <<= 1) {\n    for (int j = 0; j < n; j += i << 1) {\n      for (int k = 0; k < i; ++k) {\n        int x = a[j + k], y = mul(a[j + k + i], roots[i + k]);\n        a[j + k] = (x + y) % md;\n        a[j + k + i] = (x + md - y) % md;\n      }\n    }\n  }\n}\nvector<int> multiply(vector<int> a, vector<int> b) {\n  int need = a.size() + b.size() - 1, nbase = 0;\n  while (1 << nbase < need) {\n    ++nbase;\n  }\n  ensure_base(nbase);\n  int sz = 1 << nbase;\n  a.resize(sz);\n  b.resize(sz);\n  bool equal = a == b;\n  dft(a);\n  if (equal) {\n    b = a;\n  } else {\n    dft(b);\n  }\n  int inv_sz = inv(sz);\n  for (int i = 0; i < sz; ++i) {\n    a[i] = mul(mul(a[i], b[i]), inv_sz);\n  }\n  reverse(a.begin() + 1, a.end());\n  dft(a);\n  a.resize(need);\n  return a;\n}\nvector<int> inverse(vector<int> a) {\n  int n = a.size(), m = n + 1 >> 1;\n  if (n == 1) {\n    return vector<int>(1, inv(a[0]));\n  } else {\n    vector<int> b = inverse(vector<int>(a.begin(), a.begin() + m));\n    int need = n << 1, nbase = 0;\n    while (1 << nbase < need) {\n      ++nbase;\n    }\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz);\n    b.resize(sz);\n    dft(a);\n    dft(b);\n    int inv_sz = inv(sz);\n    for (int i = 0; i < sz; ++i) {\n      a[i] = mul(mul(md + 2 - mul(a[i], b[i]), b[i]), inv_sz);\n    }\n    reverse(a.begin() + 1, a.end());\n    dft(a);\n    a.resize(n);\n    return a;\n  }\n}\n}  // namespace ntt\nusing ntt::inverse;\nusing ntt::multiply;\nvector<int> &operator+=(vector<int> &a, const vector<int> &b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < b.size(); ++i) {\n    add(a[i], b[i]);\n  }\n  return a;\n}\nvector<int> operator+(const vector<int> &a, const vector<int> &b) {\n  vector<int> c = a;\n  return c += b;\n}\nvector<int> &operator-=(vector<int> &a, const vector<int> &b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < b.size(); ++i) {\n    sub(a[i], b[i]);\n  }\n  return a;\n}\nvector<int> operator-(const vector<int> &a, const vector<int> &b) {\n  vector<int> c = a;\n  return c -= b;\n}\nvector<int> &operator*=(vector<int> &a, const vector<int> &b) {\n  if (min(a.size(), b.size()) < 128) {\n    vector<int> c = a;\n    a.assign(a.size() + b.size() - 1, 0);\n    for (int i = 0; i < c.size(); ++i) {\n      for (int j = 0; j < b.size(); ++j) {\n        add(a[i + j], mul(c[i], b[j]));\n      }\n    }\n  } else {\n    a = multiply(a, b);\n  }\n  return a;\n}\nvector<int> operator*(const vector<int> &a, const vector<int> &b) {\n  vector<int> c = a;\n  return c *= b;\n}\nvector<int> &operator/=(vector<int> &a, const vector<int> &b) {\n  int n = a.size(), m = b.size();\n  if (n < m) {\n    a.clear();\n  } else {\n    vector<int> c = b;\n    reverse(a.begin(), a.end());\n    reverse(c.begin(), c.end());\n    c.resize(n - m + 1);\n    a *= inverse(c);\n    a.erase(a.begin() + n - m + 1, a.end());\n    reverse(a.begin(), a.end());\n  }\n  return a;\n}\nvector<int> operator/(const vector<int> &a, const vector<int> &b) {\n  vector<int> c = a;\n  return c /= b;\n}\nvector<int> &operator%=(vector<int> &a, const vector<int> &b) {\n  int n = a.size(), m = b.size();\n  if (n >= m) {\n    vector<int> c = (a / b) * b;\n    a.resize(m - 1);\n    for (int i = 0; i < m - 1; ++i) {\n      sub(a[i], c[i]);\n    }\n  }\n  return a;\n}\nvector<int> operator%(const vector<int> &a, const vector<int> &b) {\n  vector<int> c = a;\n  return c %= b;\n}\nvector<int> derivative(const vector<int> &a) {\n  int n = a.size();\n  vector<int> b(n - 1);\n  for (int i = 1; i < n; ++i) {\n    b[i - 1] = mul(a[i], i);\n  }\n  return b;\n}\nvector<int> primitive(const vector<int> &a) {\n  int n = a.size();\n  vector<int> b(n + 1), invs(n + 1);\n  for (int i = 1; i <= n; ++i) {\n    invs[i] = i == 1 ? 1 : mul(md - md / i, invs[md % i]);\n    b[i] = mul(a[i - 1], invs[i]);\n  }\n  return b;\n}\nvector<int> logarithm(const vector<int> &a) {\n  vector<int> b = primitive(derivative(a) * inverse(a));\n  b.resize(a.size());\n  return b;\n}\nvector<int> exponent(const vector<int> &a) {\n  vector<int> b(1, 1);\n  while (b.size() < a.size()) {\n    vector<int> c(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    add(c[0], 1);\n    vector<int> old_b = b;\n    b.resize(b.size() << 1);\n    c -= logarithm(b);\n    c *= old_b;\n    for (int i = b.size() >> 1; i < b.size(); ++i) {\n      b[i] = c[i];\n    }\n  }\n  b.resize(a.size());\n  return b;\n}\nvector<int> power(const vector<int> &a, int m) {\n  int n = a.size(), p = -1;\n  vector<int> b(n);\n  for (int i = 0; i < n; ++i) {\n    if (a[i]) {\n      p = i;\n      break;\n    }\n  }\n  if (p == -1) {\n    b[0] = !m;\n    return b;\n  }\n  if ((long long)m * p >= n) {\n    return b;\n  }\n  int mu = power(a[p], m), di = inv(a[p]);\n  vector<int> c(n - m * p);\n  for (int i = 0; i < n - m * p; ++i) {\n    c[i] = mul(a[i + p], di);\n  }\n  c = logarithm(c);\n  for (int i = 0; i < n - m * p; ++i) {\n    c[i] = mul(c[i], m);\n  }\n  c = exponent(c);\n  for (int i = 0; i < n - m * p; ++i) {\n    b[i + m * p] = mul(c[i], mu);\n  }\n  return b;\n}\nvector<int> sqrt(const vector<int> &a) {\n  vector<int> b(1, 1);\n  while (b.size() < a.size()) {\n    vector<int> c(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    vector<int> old_b = b;\n    b.resize(b.size() << 1);\n    c *= inverse(b);\n    for (int i = b.size() >> 1; i < b.size(); ++i) {\n      b[i] = mul(c[i], md + 1 >> 1);\n    }\n  }\n  b.resize(a.size());\n  return b;\n}\nvector<int> multiply_all(int l, int r, vector<vector<int>> &all) {\n  if (l > r) {\n    return vector<int>();\n  } else if (l == r) {\n    return all[l];\n  } else {\n    int y = l + r >> 1;\n    return multiply_all(l, y, all) * multiply_all(y + 1, r, all);\n  }\n}\nvector<int> evaluate(const vector<int> &f, const vector<int> &x) {\n  int n = x.size();\n  if (!n) {\n    return vector<int>();\n  }\n  vector<vector<int>> up(n * 2);\n  for (int i = 0; i < n; ++i) {\n    up[i + n] = vector<int>{(md - x[i]) % md, 1};\n  }\n  for (int i = n - 1; i; --i) {\n    up[i] = up[i << 1] * up[i << 1 | 1];\n  }\n  vector<vector<int>> down(n * 2);\n  down[1] = f % up[1];\n  for (int i = 2; i < n * 2; ++i) {\n    down[i] = down[i >> 1] % up[i];\n  }\n  vector<int> y(n);\n  for (int i = 0; i < n; ++i) {\n    y[i] = down[i + n][0];\n  }\n  return y;\n}\nvector<int> interpolate(const vector<int> &x, const vector<int> &y) {\n  int n = x.size();\n  vector<vector<int>> up(n * 2);\n  for (int i = 0; i < n; ++i) {\n    up[i + n] = vector<int>{(md - x[i]) % md, 1};\n  }\n  for (int i = n - 1; i; --i) {\n    up[i] = up[i << 1] * up[i << 1 | 1];\n  }\n  vector<int> a = evaluate(derivative(up[1]), x);\n  for (int i = 0; i < n; ++i) {\n    a[i] = mul(y[i], inv(a[i]));\n  }\n  vector<vector<int>> down(n * 2);\n  for (int i = 0; i < n; ++i) {\n    down[i + n] = vector<int>(1, a[i]);\n  }\n  for (int i = n - 1; i; --i) {\n    down[i] = down[i << 1] * up[i << 1 | 1] + down[i << 1 | 1] * up[i << 1];\n  }\n  return down[1];\n}\nint n, m, a[600005];\nvector<int> v;\nvector<vector<vector<int>>> solve(int l, int r) {\n  if (l == r) {\n    return {\n        {{1, 2}, (v[l] == 1) ? vector<int>{0, 998244353 - 1} : vector<int>{0}},\n        {{0, 2}, (v[l] == 1) ? vector<int>{0, 998244353 - 1} : vector<int>{0}}};\n  } else {\n    int mid = (l + r) >> 1;\n    auto L = solve(l, mid), R = solve(mid + 1, r);\n    vector<vector<vector<int>>> M(2, vector<vector<int>>(2));\n    for (int i = 0; i < 2; i++)\n      for (int j = 0; j < 2; j++)\n        for (int k = 0; k < 2; k++) M[i][j] = M[i][j] + L[i][k] * R[k][j];\n    return M;\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", a + i);\n  }\n  int c = 0, len = 0;\n  for (int i = 0; i < n; i++) {\n    if (len == 0) {\n      c = a[i];\n      len = a[i];\n      v.push_back(a[i]);\n    }\n    if (a[i] != c) {\n      puts(\"0\");\n      return 0;\n    }\n    len--;\n  }\n  if (len != 0) {\n    puts(\"0\");\n    return 0;\n  }\n  m = v.size();\n  auto Mans = solve(0, m - 1);\n  auto ans = Mans[1][0] + Mans[1][1];\n  long long w = (m % 2 == 0) ? 1 : 998244353 - 1, d = 0;\n  for (int i = 1; i < ans.size(); i++) {\n    w = w * (998244353 - i) % 998244353;\n    d = (d + w * ans[i]) % 998244353;\n  }\n  printf(\"%lld\\n\", d);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint ksm(int a, int b) {\n  int jg = 1;\n  while (b > 0) {\n    if (b & 1) jg = 1ll * jg * a % 998244353;\n    a = 1ll * a * a % 998244353;\n    b >>= 1;\n  }\n  return jg;\n}\nint w0[2097152 << 1], w1[2097152 << 1];\nvoid getww(int n) {\n  for (int h = 2; h <= n; h <<= 1) {\n    int wn = ksm(3, (998244353 - 1) / h);\n    for (int i = 0, w = 1; i < (h >> 1); i++, w = 1ll * w * wn % 998244353)\n      w0[i + (h >> 1)] = w;\n    wn = ksm(332748118, (998244353 - 1) / h);\n    for (int i = 0, w = 1; i < (h >> 1); i++, w = 1ll * w * wn % 998244353)\n      w1[i + (h >> 1)] = w;\n  }\n}\nvoid NTT(int sz[2097152], int n, int lx) {\n  for (int i = 0, t = 0; i < n; i++) {\n    if (i < t) {\n      int o = sz[i];\n      sz[i] = sz[t];\n      sz[t] = o;\n    }\n    for (int j = (n >> 1); (t ^= j) < j; j >>= 1)\n      ;\n  }\n  for (int h = 2; h <= n; h <<= 1) {\n    for (int i = 0; i < n; i += h) {\n      for (int j = 0; j < (h >> 1); j++) {\n        int w = (lx == 0 ? w0[j + (h >> 1)] : w1[j + (h >> 1)]);\n        int z = 1ll * w * sz[i + j + (h >> 1)] % 998244353;\n        sz[i + j + (h >> 1)] = (sz[i + j] - z + 998244353) % 998244353;\n        sz[i + j] = (sz[i + j] + z) % 998244353;\n      }\n    }\n  }\n  if (lx == 1) {\n    int nn = ksm(n, 998244353 - 2);\n    for (int i = 0; i < n; i++) sz[i] = 1ll * sz[i] * nn % 998244353;\n  }\n}\nint F[2097152], G[2097152];\nvector<int> mul(const vector<int>& a, const vector<int>& b) {\n  vector<int> rt;\n  int le = 1, na = a.size(), nb = b.size();\n  while (le < na + nb) le <<= 1;\n  for (int i = 0; i < le; i++) F[i] = G[i] = 0;\n  for (int i = 0; i < na; i++) F[i] = a[i];\n  for (int i = 0; i < nb; i++) G[i] = b[i];\n  NTT(F, le, 0);\n  NTT(G, le, 0);\n  for (int i = 0; i < le; i++) F[i] = 1ll * F[i] * G[i] % 998244353;\n  NTT(F, le, 1);\n  for (int i = 0; i < na + nb - 1; i++) rt.push_back(F[i]);\n  return rt;\n}\nvector<int> add(const vector<int>& a, const vector<int>& b) {\n  vector<int> rt;\n  int na = a.size(), nb = b.size();\n  rt.resize(na > nb ? na : nb);\n  for (int i = 0; i < na; i++) rt[i] = a[i];\n  for (int i = 0; i < nb; i++) rt[i] = (rt[i] + b[i]) % 998244353;\n  return rt;\n}\nstruct SJd {\n  vector<int> sz[2][2];\n};\nSJd operator*(const SJd& a, const SJd& b) {\n  SJd rt;\n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < 2; j++) {\n      for (int k = 0; k < 2; k++)\n        rt.sz[i][j] = add(rt.sz[i][j], mul(a.sz[i][k], b.sz[k][j]));\n    }\n  }\n  return rt;\n}\nSJd zt[100010];\nSJd fzntt(int l, int r) {\n  if (l == r) return zt[l];\n  int m = (l + r) >> 1;\n  return fzntt(l, m) * fzntt(m + 1, r);\n}\nint sz[100010], ss[100010], jc[100010], mi[100010];\nSJd caljz(int z) {\n  SJd rt;\n  rt.sz[0][0].push_back((z == 0 ? 499122177 : 1));\n  rt.sz[1][0].push_back(1);\n  rt.sz[0][1].push_back(0);\n  rt.sz[0][1].push_back(1);\n  rt.sz[1][1].push_back(0);\n  rt.sz[1][1].push_back(1);\n  return rt;\n}\nint main() {\n  int n, m = 0;\n  getww(2097152);\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) scanf(\"%d\", &sz[i]);\n  for (int i = 0; i < n; i += sz[i]) {\n    int t = sz[i];\n    if (i + t > n) {\n      printf(\"0\");\n      return 0;\n    }\n    for (int j = i + 1; j < i + t; j++) {\n      if (sz[j] != t) {\n        printf(\"0\");\n        return 0;\n      }\n    }\n    ss[m++] = (t > 1);\n  }\n  jc[0] = mi[0] = 1;\n  for (int i = 1; i <= m; i++) {\n    jc[i] = 1ll * i * jc[i - 1] % 998244353;\n    mi[i] = 2ll * mi[i - 1] % 998244353;\n  }\n  for (int i = 0; i < m; i++) zt[i] = caljz(ss[i]);\n  int ans = 0;\n  SJd rt = fzntt(0, m - 1);\n  vector<int> ve = rt.sz[0][0];\n  for (int i = 0; i < ve.size(); i++) {\n    int z = 1ll * jc[m - i] * mi[m - i] % 998244353;\n    if (i & 1) z = (998244353 - z) % 998244353;\n    ans = (ans + 1ll * z * ve[i]) % 998244353;\n  }\n  printf(\"%d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int readint() {\n  int x = 0;\n  bool f = 0;\n  char c = getchar();\n  while (!isdigit(c) && c != '-') c = getchar();\n  if (c == '-') {\n    f = 1;\n    c = getchar();\n  }\n  while (isdigit(c)) {\n    x = x * 10 + c - '0';\n    c = getchar();\n  }\n  return f ? -x : x;\n}\nconst int maxn = 1e5 + 5;\nint n, m = 0, a[maxn];\nconst long long mod = 998244353, g = 3, invg = 332748118, inv2 = 499122177;\nlong long ksm(long long a, long long b) {\n  long long ans = 1;\n  while (b) {\n    if (b % 2 == 1) ans = ans * a % mod;\n    a = a * a % mod;\n    b /= 2;\n  }\n  return ans;\n}\nint rev[maxn * 2];\nlong long w[maxn * 2], w2[maxn * 2], invn;\nvoid init(int n) {\n  for (int i = 1; i < n; i++)\n    rev[i] = rev[i >> 1] >> 1 | ((i & 1) ? n >> 1 : 0);\n  for (int i = 1; i < n; i *= 2) {\n    w[i] = 1;\n    long long wn = ksm(g, (mod - 1) / (i * 2));\n    for (int j = 1; j < i; j++) w[i + j] = w[i + j - 1] * wn % mod;\n  }\n  for (int i = 1; i < n; i *= 2) {\n    w2[i] = 1;\n    long long wn = ksm(invg, (mod - 1) / (i * 2));\n    for (int j = 1; j < i; j++) w2[i + j] = w2[i + j - 1] * wn % mod;\n  }\n  invn = ksm(n, mod - 2);\n}\nvector<long long> FFT(vector<long long> F, bool flag) {\n  int n = F.size();\n  for (int i = 0; i < n; i++)\n    if (i < rev[i]) swap(F[i], F[rev[i]]);\n  for (int i = 1; i < n; i *= 2)\n    for (int j = 0; j < n; j += i * 2)\n      for (int k = j; k < j + i; k++) {\n        long long t = F[k + i] * (flag ? w[i + k - j] : w2[i + k - j]) % mod;\n        F[k + i] = (F[k] - t + mod) % mod;\n        F[k] = (F[k] + t) % mod;\n      }\n  if (!flag)\n    for (int i = 0; i < n; i++) F[i] = F[i] * invn % mod;\n  return F;\n}\nvector<vector<vector<long long>>> solve(int l, int r) {\n  if (l == r) {\n    if (a[r] == 1)\n      return {{{0, 0}, {0, 0}}, {{0, 0}, {0, 1}}};\n    else\n      return {{{0, 2}, {0, 0}}, {{0, 0}, {0, 0}}};\n  }\n  int mid = l + (r - l) / 2;\n  vector<vector<vector<long long>>> F = solve(l, mid), G = solve(mid + 1, r),\n                                    H = {{{}, {}}, {{}, {}}}, A = F, B = G;\n  for (int i = 0; i < 2; i++) {\n    A[0][i][1] = (A[0][i][1] + A[1][i][1]) % mod;\n    A[1][i][1] = 0;\n    B[i][0][1] = (B[i][0][1] + B[i][1][1]) % mod;\n    B[i][1][1] = 0;\n  }\n  int len = 1;\n  while (len < r - l + 2) len *= 2;\n  init(len);\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 2; j++) {\n      F[i][j].resize(len);\n      G[i][j].resize(len);\n      F[i][j] = FFT(F[i][j], 1);\n      G[i][j] = FFT(G[i][j], 1);\n      if (r - l <= 2) {\n        A[i][j].resize(len);\n        B[i][j].resize(len);\n        A[i][j] = FFT(A[i][j], 1);\n        B[i][j] = FFT(B[i][j], 1);\n      }\n    }\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 2; j++) {\n      H[i][j].resize(r - l + 2);\n      for (int x = 0; x < 2; x++)\n        for (int y = 0; y < 2; y++) {\n          vector<long long> C(len);\n          for (int k = 0; k < len; k++) C[k] = F[i][x][k] * G[y][j][k] % mod;\n          C = FFT(C, 0);\n          for (int k = 1; k <= r - l + 1; k++)\n            H[i][j][k] = (H[i][j][k] + C[k]) % mod;\n          if (r - l <= 2) {\n            for (int k = 0; k < len; k++) C[k] = A[i][x][k] * B[y][j][k] % mod;\n            C = FFT(C, 0);\n          }\n          for (int k = 1; k <= r - l; k++) {\n            long long res = C[k + 1];\n            if (x && y) res = res * 2 % mod;\n            if (!x && !y) res = res * inv2 % mod;\n            H[i][j][k] = (H[i][j][k] + res) % mod;\n          }\n        }\n    }\n  return H;\n}\nlong long fac[maxn];\nint main() {\n  n = readint();\n  while (n) {\n    a[++m] = readint();\n    if (n < a[m]) {\n      printf(\"0\\n\");\n      return 0;\n    }\n    for (int i = 1; i < a[m]; i++)\n      if (readint() != a[m]) {\n        printf(\"0\\n\");\n        return 0;\n      }\n    n -= a[m];\n  }\n  fac[0] = 1;\n  for (int i = 1; i <= m; i++) fac[i] = fac[i - 1] * i % mod;\n  vector<vector<vector<long long>>> F = solve(1, m);\n  long long ans = 0;\n  for (int i = 1; i <= m; i++) {\n    long long res = 0;\n    for (int j = 0; j < 2; j++)\n      for (int k = 0; k < 2; k++) res = (res + F[j][k][i]) % mod;\n    ans = (ans + res * fac[i] % mod * ((m - i) % 2 == 0 ? 1 : mod - 1) % mod) %\n          mod;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int P = 998244353, R = 3;\nconst int BRUTE_N2_LIMIT = 50;\nint mpow(int x, int k, int p = P) {\n  int ret = 1;\n  while (k) {\n    if (k & 1) ret = ret * (long long)x % p;\n    x = x * (long long)x % p;\n    k >>= 1;\n  }\n  return ret;\n}\nint norm(int x) { return x >= P ? x - P : x; }\nvoid add(int &x, int y) {\n  if ((x += y) >= P) x -= P;\n}\nvoid sub(int &x, int y) {\n  if ((x -= y) < 0) x += P;\n}\nstruct NumberTheory {\n  mt19937 rng;\n  NumberTheory()\n      : rng(chrono::steady_clock::now().time_since_epoch().count()) {}\n  void _exGcd(int a, int b, int &x, int &y) {\n    if (!b) {\n      x = 1;\n      y = 0;\n      return;\n    }\n    _exGcd(b, a % b, y, x);\n    y -= a / b * x;\n  }\n  int inv(int a, int p = P) {\n    int x, y;\n    _exGcd(a, p, x, y);\n    if (x < 0) x += p;\n    return x;\n  }\n  template <class Integer>\n  bool quadRes(Integer a, Integer b) {\n    if (a <= 1) return true;\n    while (a % 4 == 0) a /= 4;\n    if (a % 2 == 0) return (b % 8 == 1 || b % 8 == 7) == quadRes(a / 2, b);\n    return ((a - 1) % 4 == 0 || (b - 1) % 4 == 0) == quadRes(b % a, a);\n  }\n  int sqrt(int x, int p = P) {\n    if (p == 2 || x <= 1) return x;\n    int w, v, k = (p + 1) / 2;\n    do {\n      w = rng() % p;\n    } while (quadRes(v = int((w * (long long)w - x + p) % p), p));\n    pair<int, int> res(1, 0), a(w, 1);\n    while (k) {\n      if (k & 1)\n        res = pair<int, int>((res.first * (long long)a.first +\n                              res.second * (long long)a.second % p * v) %\n                                 p,\n                             (res.first * (long long)a.second +\n                              res.second * (long long)a.first) %\n                                 p);\n      if (k >>= 1)\n        a = pair<int, int>((a.first * (long long)a.first +\n                            a.second * (long long)a.second % p * v) %\n                               p,\n                           (a.first * (long long)a.second << 1) % p);\n    }\n    return min(res.first, p - res.first);\n  }\n} nt;\ntemplate <class T, class Comp>\nstruct AdditionChain {\n  int k;\n  vector<T> prepare;\n  T t, unit;\n  Comp comp;\n  AdditionChain(const T &t, const Comp &comp, int k, const T &unit = 1)\n      : comp(comp), t(t), unit(unit), k(k), prepare(1U << k) {\n    prepare[0] = unit;\n    for (int i = 1; i < 1 << k; ++i) prepare[i] = comp(prepare[i - 1], t);\n  }\n  static AdditionChain fourRussians(const T &t, const Comp &comp, int lgn,\n                                    const T &unit = 1) {\n    lgn = max(lgn, 1);\n    int k = 1, lglgn = 1;\n    while (2 << lglgn <= lgn) ++lglgn;\n    int w = lglgn / lgn;\n    while (1 << k < w) ++k;\n    return AdditionChain(t, comp, k, unit);\n  }\n  T pow(int n) const {\n    if (n < 1 << k) return prepare[n];\n    int r = n & ((1 << k) - 1);\n    T step = pow(n >> k);\n    for (int rep = 0; rep < k; ++rep) step = comp(step, step);\n    return comp(step, prepare[r]);\n  }\n};\nstruct Simple {\n  int n;\n  vector<int> fac, ifac, inv;\n  void build(int n) {\n    this->n = n;\n    fac.resize(n + 1);\n    ifac.resize(n + 1);\n    inv.resize(n + 1);\n    fac[0] = 1;\n    for (int x = 1; x <= n; ++x) fac[x] = fac[x - 1] * (long long)x % P;\n    inv[1] = 1;\n    for (int x = 2; x <= n; ++x)\n      inv[x] = -(P / x) * (long long)inv[P % x] % P + P;\n    ifac[0] = 1;\n    for (int x = 1; x <= n; ++x) ifac[x] = ifac[x - 1] * (long long)inv[x] % P;\n  }\n  Simple() { build(1); }\n  void check(int k) {\n    int nn = n;\n    if (k > nn) {\n      while (k > nn) nn <<= 1;\n      build(nn);\n    }\n  }\n  int gfac(int k) {\n    check(k);\n    return fac[k];\n  }\n  int gifac(int k) {\n    check(k);\n    return ifac[k];\n  }\n  int ginv(int k) {\n    check(k);\n    return inv[k];\n  }\n  int binom(int n, int m) {\n    if (m < 0 || m > n) return 0;\n    return gfac(n) * (long long)gifac(m) % P * gifac(n - m) % P;\n  }\n} simp;\nconst int L2 = 11;\nstruct NTT {\n  int L;\n  int brev[1 << L2];\n  vector<int> root;\n  NTT() : L(-1) {\n    for (int i = 1; i < (1 << L2); ++i)\n      brev[i] = brev[i >> 1] >> 1 | ((i & 1) << (L2 - 1));\n  }\n  void prepRoot(int l) {\n    L = l;\n    root.resize(2 << L);\n    for (int i = 0; i <= L; ++i) {\n      int *w = root.data() + (1 << i);\n      w[0] = 1;\n      int omega = mpow(R, (P - 1) >> i);\n      for (int j = 1; j < 1 << i; ++j) w[j] = w[j - 1] * (long long)omega % P;\n    }\n  }\n  void fft(int *a, int lgn, int d = 1) {\n    if (L < lgn) prepRoot(lgn);\n    int n = 1 << lgn;\n    for (int i = 0; i < n; ++i) {\n      int rev = (brev[i >> L2] | (brev[i & ((1 << L2) - 1)] << L2)) >>\n                ((L2 << 1) - lgn);\n      if (i < rev) swap(a[i], a[rev]);\n    }\n    for (int i = 1; i < n; i <<= 1) {\n      int *w = root.data() + (i << 1);\n      for (int j = 0; j < n; j += i << 1) {\n        for (int k = 0; k < i; ++k) {\n          int aa = w[k] * (long long)a[i + j + k] % P;\n          a[i + j + k] = norm(a[j + k] + P - aa);\n          add(a[j + k], aa);\n        }\n      }\n    }\n    if (d == -1) {\n      reverse(a + 1, a + n);\n      int nv = mpow(n, P - 2);\n      for (int i = 0; i < n; ++i) a[i] = a[i] * (long long)nv % P;\n    }\n  }\n} ntt;\nstruct Poly {\n  vector<int> a;\n  Poly(int v = 0) : a(1) {\n    if ((v %= P) < 0) v += P;\n    a[0] = v;\n  }\n  Poly(const vector<int> &a) : a(a) {}\n  Poly(initializer_list<int> init) : a(init) {}\n  int operator[](int k) const { return k < a.size() ? a[k] : 0; }\n  int &operator[](int k) {\n    if (k >= a.size()) a.resize(k + 1);\n    return a[k];\n  }\n  int deg() const { return a.size() - 1; }\n  void redeg(int d) { a.resize(d + 1); }\n  Poly monic() const;\n  Poly sunic() const;\n  Poly slice(int d) const {\n    if (d < a.size()) return vector<int>(a.begin(), a.begin() + d + 1);\n    vector<int> res(a);\n    res.resize(d + 1);\n    return res;\n  }\n  int *base() { return a.data(); }\n  const int *base() const { return a.data(); }\n  Poly println(FILE *fp) const {\n    fprintf(fp, \"%d\", a[0]);\n    for (int i = 1; i < a.size(); ++i) fprintf(fp, \" %d\", a[i]);\n    fputc('\\n', fp);\n    return *this;\n  }\n  Poly operator+(const Poly &rhs) const {\n    vector<int> res(max(a.size(), rhs.a.size()));\n    for (int i = 0; i < res.size(); ++i)\n      if ((res[i] = operator[](i) + rhs[i]) >= P) res[i] -= P;\n    return res;\n  }\n  Poly operator-() const {\n    Poly ret(a);\n    for (int i = 0; i < a.size(); ++i)\n      if (ret[i]) ret[i] = P - ret[i];\n    return ret;\n  }\n  Poly operator-(const Poly &rhs) const { return operator+(-rhs); }\n  Poly operator*(const Poly &rhs) const;\n  Poly operator/(const Poly &rhs) const;\n  Poly operator%(const Poly &rhs) const;\n  Poly der() const;\n  Poly integ() const;\n  Poly inv() const;\n  Poly sqrt() const;\n  Poly ln() const;\n  Poly exp() const;\n  pair<Poly, Poly> sqrti() const;\n  pair<Poly, Poly> expi() const;\n  Poly quo(const Poly &rhs) const;\n  pair<Poly, Poly> iquo(const Poly &rhs) const;\n  pair<Poly, Poly> div(const Poly &rhs) const;\n  Poly taylor(int k) const;\n  Poly pow(int k) const;\n  Poly exp(int k) const;\n};\nPoly zeroes(int deg) { return vector<int>(deg + 1); }\nstruct Newton {\n  void inv(const Poly &f, const Poly &nttf, Poly &g, const Poly &nttg, int t) {\n    int n = 1 << t;\n    Poly prod = nttf;\n    for (int i = 0; i < (n << 1); ++i)\n      prod[i] = prod[i] * (long long)nttg[i] % P;\n    ntt.fft(prod.base(), t + 1, -1);\n    for (int i = 0; i < n; ++i) prod[i] = 0;\n    ntt.fft(prod.base(), t + 1, 1);\n    for (int i = 0; i < (n << 1); ++i)\n      prod[i] = prod[i] * (long long)nttg[i] % P;\n    ntt.fft(prod.base(), t + 1, -1);\n    for (int i = 0; i < n; ++i) prod[i] = 0;\n    g = g - prod;\n  }\n  void inv(const Poly &f, const Poly &nttf, Poly &g, int t) {\n    Poly nttg = g;\n    nttg.redeg((2 << t) - 1);\n    ntt.fft(nttg.base(), t + 1, 1);\n    inv(f, nttf, g, nttg, t);\n  }\n  void inv(const Poly &f, Poly &g, int t) {\n    Poly nttg = g;\n    nttg.redeg((2 << t) - 1);\n    ntt.fft(nttg.base(), t + 1, 1);\n    Poly nttf = f;\n    nttf.redeg((2 << t) - 1);\n    ntt.fft(nttf.base(), t + 1, 1);\n    inv(f, nttf, g, nttg, t);\n  }\n  void sqrt(const Poly &f, Poly &g, Poly &nttg, Poly &h, int t) {\n    for (int i = 0; i < (1 << t); ++i) nttg[i] = mpow(nttg[i], 2);\n    ntt.fft(nttg.base(), t, -1);\n    nttg = nttg - f;\n    for (int i = 0; i < (1 << t); ++i)\n      if ((nttg[i + (1 << t)] += nttg[i]) >= P) nttg[i + (1 << t)] -= P;\n    memset(nttg.base(), 0, sizeof(int) << t);\n    ntt.fft(nttg.base(), t + 1, 1);\n    Poly tmp = h;\n    tmp.redeg((2 << t) - 1);\n    ntt.fft(tmp.base(), t + 1, 1);\n    for (int i = 0; i < (2 << t); ++i) tmp[i] = tmp[i] * (long long)nttg[i] % P;\n    ntt.fft(tmp.base(), t + 1, -1);\n    memset(tmp.base(), 0, sizeof(int) << t);\n    g = g - tmp * nt.inv(2);\n  }\n  void exp(const Poly &f, Poly &g, Poly &nttg, Poly &h, int t) {\n    Poly ntth(h);\n    ntt.fft(ntth.base(), t, 1);\n    Poly dg = g.der().slice((1 << t) - 1);\n    ntt.fft(dg.base(), t, 1);\n    Poly tmp = zeroes((1 << t) - 1);\n    for (int i = 0; i < (1 << t); ++i) {\n      tmp[i] = nttg[i << 1] * (long long)ntth[i] % P;\n      dg[i] = dg[i] * (long long)ntth[i] % P;\n    }\n    ntt.fft(tmp.base(), t, -1);\n    ntt.fft(dg.base(), t, -1);\n    if (--tmp[0] < 0) tmp[0] = P - 1;\n    dg.redeg((2 << t) - 1);\n    Poly df0 = f.der().slice((1 << t) - 1);\n    df0[(1 << t) - 1] = 0;\n    for (int i = 0; i < (1 << t); ++i) {\n      if ((dg[i | 1 << t] = dg[i] - df0[i]) < 0) dg[i | 1 << t] += P;\n    }\n    memcpy(dg.base(), df0.base(), sizeof(int) * ((1 << t) - 1));\n    tmp.redeg((2 << t) - 1);\n    ntt.fft(tmp.base(), t + 1, 1);\n    df0.redeg((2 << t) - 1);\n    ntt.fft(df0.base(), t + 1, 1);\n    for (int i = 0; i < (2 << t); ++i) df0[i] = df0[i] * (long long)tmp[i] % P;\n    ntt.fft(df0.base(), t + 1, -1);\n    memcpy(df0.base() + (1 << t), df0.base(), sizeof(int) << t);\n    memset(df0.base(), 0, sizeof(int) << t);\n    dg = (dg - df0).integ().slice((2 << t) - 1) - f;\n    ntt.fft(dg.base(), t + 1, 1);\n    for (int i = 0; i < (2 << t); ++i) tmp[i] = dg[i] * (long long)nttg[i] % P;\n    ntt.fft(tmp.base(), t + 1, -1);\n    g.redeg((2 << t) - 1);\n    for (int i = 1 << t; i < (2 << t); ++i)\n      if (tmp[i]) g[i] = P - tmp[i];\n  }\n} nit;\nstruct SemiRelaxedConvolution {\n  template <class Function>\n  void run(const vector<int> &a, vector<int> &b, const Function &relax) {\n    int n = a.size() - 1;\n    function<void(int, int)> divideConquer = [&](int l, int r) {\n      if (r - l <= BRUTE_N2_LIMIT) {\n        for (int i = l; i <= r; ++i) {\n          for (int j = l; j < i; ++j)\n            b[i] = (b[i] + b[j] * (long long)a[i - j]) % P;\n          relax(i);\n        }\n        return;\n      }\n      int lg = 31 - __builtin_clz(r - l) + 1;\n      int d = (r - l) / lg + 1;\n      int lgd = 0;\n      while ((1 << lgd) < d) ++lgd;\n      ++lgd;\n      vector<int> top((lg << (lgd + 1)));\n      for (int i = 0; i < lg; ++i) {\n        copy(a.begin() + i * d, a.begin() + min((i + 2) * d, n + 1),\n             top.begin() + (i << lgd));\n        ntt.fft(top.data() + (i << lgd), lgd, 1);\n      }\n      for (int i = 0; i < lg; ++i) {\n        if (i) ntt.fft(top.data() + ((lg + i) << lgd), lgd, -1);\n        for (int j = 0; j < min(d, r - l - i * d + 1); ++j)\n          b[l + i * d + j] =\n              norm(b[l + i * d + j] + top[((lg + i) << lgd) + d + j]);\n        divideConquer(l + i * d, min(l + (i + 1) * d - 1, r));\n        if (i + 1 < lg) {\n          copy(b.begin() + l + i * d, b.begin() + min(l + (i + 1) * d, n + 1),\n               top.begin() + ((lg + i) << lgd));\n          fill(top.data() + ((lg + i) << lgd) + d,\n               top.data() + ((lg + i + 1) << lgd), 0);\n          ntt.fft(top.data() + ((lg + i) << lgd), lgd, 1);\n        }\n        for (int j = i + 1; j < lg; ++j) {\n          for (int k = 0; k < (1 << lgd); ++k)\n            top[((lg + j) << lgd) + k] =\n                (top[((lg + j) << lgd) + k] +\n                 top[((j - i - 1) << lgd) + k] *\n                     (long long)top[((lg + i) << lgd) + k]) %\n                P;\n        }\n      }\n    };\n    divideConquer(0, n);\n  }\n} src;\nstruct Transposition {\n  vector<int> _mul(int l, vector<int> res, const Poly &b) {\n    vector<int> tmp(1 << l);\n    memcpy(tmp.data(), b.a.data(), sizeof(int) * (b.deg() + 1));\n    reverse(tmp.begin() + 1, tmp.end());\n    ntt.fft(tmp.data(), l, 1);\n    for (int i = 0; i < (1 << l); ++i) res[i] = res[i] * (long long)tmp[i] % P;\n    ntt.fft(res.data(), l, -1);\n    return res;\n  }\n  Poly bfMul(const Poly &a, const Poly &b) {\n    int n = a.deg(), m = b.deg();\n    Poly ret = zeroes(n - m);\n    for (int i = 0; i <= n - m; ++i)\n      for (int j = 0; j <= m; ++j)\n        ret[i] = (ret[i] + a[i + j] * (long long)b[j]) % P;\n    return ret;\n  }\n  Poly mul(const Poly &a, const Poly &b) {\n    if (a.deg() < b.deg()) return 0;\n    if (a.deg() <= BRUTE_N2_LIMIT) return bfMul(a, b);\n    int l = 0;\n    while ((1 << l) <= a.deg()) ++l;\n    vector<int> res(1 << l);\n    memcpy(res.data(), a.a.data(), sizeof(int) * (a.deg() + 1));\n    ntt.fft(res.data(), l, 1);\n    res = _mul(l, res, b);\n    res.resize(a.deg() - b.deg() + 1);\n    return res;\n  }\n  pair<Poly, Poly> mul2(const Poly &a, const Poly &b1, const Poly &b2) {\n    if (a.deg() <= BRUTE_N2_LIMIT) return make_pair(bfMul(a, b1), bfMul(a, b2));\n    int l = 0;\n    while ((1 << l) <= a.deg()) ++l;\n    vector<int> fa(1 << l);\n    memcpy(fa.data(), a.a.data(), sizeof(int) * (a.deg() + 1));\n    ntt.fft(fa.data(), l, 1);\n    vector<int> res1 = _mul(l, fa, b1), res2 = _mul(l, fa, b2);\n    res1.resize(a.deg() - b1.deg() + 1);\n    res2.resize(a.deg() - b2.deg() + 1);\n    return make_pair(res1, res2);\n  }\n  vector<int> ls, rs, pos;\n  vector<Poly> p, q;\n  void _build(int n) {\n    ls.assign(n * 2 - 1, 0);\n    rs.assign(n * 2 - 1, 0);\n    p.assign(n * 2 - 1, 0);\n    q.assign(n * 2 - 1, 0);\n    pos.resize(n);\n    int cnt = 0;\n    function<int(int, int)> dfs = [&](int l, int r) {\n      if (l == r) {\n        pos[l] = cnt;\n        return cnt++;\n      }\n      int ret = cnt++;\n      int mid = (l + r) >> 1;\n      ls[ret] = dfs(l, mid);\n      rs[ret] = dfs(mid + 1, r);\n      return ret;\n    };\n    dfs(0, n - 1);\n  }\n  vector<int> _eval(vector<int> f, const vector<int> &x) {\n    int n = f.size();\n    _build(n);\n    for (int i = 0; i < n; ++i) q[pos[i]] = {1, norm(P - x[i])};\n    for (int i = n * 2 - 2; i >= 0; --i)\n      if (ls[i]) q[i] = q[ls[i]] * q[rs[i]];\n    f.resize(n * 2);\n    p[0] = mul(f, q[0].inv());\n    for (int i = 0; i < n * 2 - 1; ++i)\n      if (ls[i]) tie(p[ls[i]], p[rs[i]]) = mul2(p[i], q[rs[i]], q[ls[i]]);\n    vector<int> ret(n);\n    for (int i = 0; i < n; ++i) ret[i] = p[pos[i]][0];\n    return ret;\n  }\n  vector<int> eval(const Poly &f, const vector<int> &x) {\n    int n = f.deg() + 1, m = x.size();\n    vector<int> tmpf = f.a, tmpx = x;\n    tmpf.resize(max(n, m));\n    tmpx.resize(max(n, m));\n    vector<int> ret = _eval(tmpf, tmpx);\n    ret.resize(m);\n    return ret;\n  }\n  Poly inter(const vector<int> &x, const vector<int> &y) {\n    int n = x.size();\n    _build(n);\n    for (int i = 0; i < n; ++i) q[pos[i]] = {1, norm(P - x[i])};\n    for (int i = n * 2 - 2; i >= 0; --i)\n      if (ls[i]) q[i] = q[ls[i]] * q[rs[i]];\n    Poly tmp = q[0];\n    reverse(tmp.a.begin(), tmp.a.end());\n    vector<int> f = tmp.der().a;\n    f.resize(n * 2);\n    p[0] = mul(f, q[0].inv());\n    for (int i = 0; i < n * 2 - 1; ++i)\n      if (ls[i]) tie(p[ls[i]], p[rs[i]]) = mul2(p[i], q[rs[i]], q[ls[i]]);\n    for (int i = 0; i < n; ++i)\n      p[pos[i]] = nt.inv(p[pos[i]][0]) * (long long)y[i] % P;\n    for (int i = 0; i < n * 2 - 1; ++i) reverse(q[i].a.begin(), q[i].a.end());\n    for (int i = n * 2 - 2; i >= 0; --i)\n      if (ls[i]) p[i] = p[ls[i]] * q[rs[i]] + p[rs[i]] * q[ls[i]];\n    return p[0];\n  }\n} tp;\nPoly operator\"\" _z(unsigned long long a) { return {0, (int)a}; }\nPoly operator+(int v, const Poly &rhs) { return Poly(v) + rhs; }\nPoly Poly::operator*(const Poly &rhs) const {\n  int n = deg(), m = rhs.deg();\n  if (n <= 10 || m <= 10 || n + m <= BRUTE_N2_LIMIT) {\n    Poly ret = zeroes(n + m);\n    for (int i = 0; i <= n; ++i)\n      for (int j = 0; j <= m; ++j)\n        ret[i + j] = (ret[i + j] + a[i] * (long long)rhs[j]) % P;\n    return ret;\n  }\n  n += m;\n  int l = 0;\n  while ((1 << l) <= n) ++l;\n  vector<int> res(1 << l), tmp(1 << l);\n  memcpy(res.data(), base(), a.size() * sizeof(int));\n  ntt.fft(res.data(), l, 1);\n  memcpy(tmp.data(), rhs.base(), rhs.a.size() * sizeof(int));\n  ntt.fft(tmp.data(), l, 1);\n  for (int i = 0; i < (1 << l); ++i) res[i] = res[i] * (long long)tmp[i] % P;\n  ntt.fft(res.data(), l, -1);\n  res.resize(n + 1);\n  return res;\n}\nPoly Poly::inv() const {\n  Poly g = nt.inv(a[0]);\n  for (int t = 0; (1 << t) <= deg(); ++t) nit.inv(slice((2 << t) - 1), g, t);\n  g.redeg(deg());\n  return g;\n}\nPoly Poly::taylor(int k) const {\n  int n = deg();\n  Poly t = zeroes(n);\n  simp.check(n);\n  for (int i = 0; i <= n; ++i) t[n - i] = a[i] * (long long)simp.fac[i] % P;\n  int pw = 1;\n  Poly help = vector<int>(simp.ifac.begin(), simp.ifac.begin() + n + 1);\n  for (int i = 0; i <= n; ++i) {\n    help[i] = help[i] * (long long)pw % P;\n    pw = pw * (long long)k % P;\n  }\n  t = t * help;\n  for (int i = 0; i <= n; ++i) help[i] = t[n - i] * (long long)simp.ifac[i] % P;\n  return help;\n}\nPoly Poly::pow(int k) const {\n  if (k == 0) return 1;\n  if (k == 1) return *this;\n  int n = deg() * k;\n  int lgn = 0;\n  while ((1 << lgn) <= n) ++lgn;\n  vector<int> val = a;\n  val.resize(1 << lgn);\n  ntt.fft(val.data(), lgn, 1);\n  for (int i = 0; i < (1 << lgn); ++i) val[i] = mpow(val[i], k);\n  ntt.fft(val.data(), lgn, -1);\n  return val;\n}\nPoly Poly::der() const {\n  if (deg() == 0) return 0;\n  vector<int> res(deg());\n  for (int i = 0; i < deg(); ++i) res[i] = a[i + 1] * (long long)(i + 1) % P;\n  return res;\n}\nPoly Poly::integ() const {\n  vector<int> res(deg() + 2);\n  simp.check(deg() + 1);\n  for (int i = 0; i <= deg(); ++i)\n    res[i + 1] = a[i] * (long long)simp.inv[i + 1] % P;\n  return res;\n}\nPoly Poly::quo(const Poly &rhs) const {\n  if (rhs.deg() == 0) return a[0] * (long long)nt.inv(rhs[0]) % P;\n  Poly g = nt.inv(rhs[0]);\n  int t = 0, n;\n  for (n = 1; (n << 1) <= rhs.deg(); ++t, n <<= 1)\n    nit.inv(rhs.slice((n << 1) - 1), g, t);\n  Poly nttg = g;\n  nttg.redeg((n << 1) - 1);\n  ntt.fft(nttg.base(), t + 1, 1);\n  Poly eps1 = rhs.slice((n << 1) - 1);\n  ntt.fft(eps1.base(), t + 1, 1);\n  for (int i = 0; i < (n << 1); ++i) eps1[i] = eps1[i] * (long long)nttg[i] % P;\n  ntt.fft(eps1.base(), t + 1, -1);\n  memcpy(eps1.base(), eps1.base() + n, sizeof(int) << t);\n  memset(eps1.base() + n, 0, sizeof(int) << t);\n  ntt.fft(eps1.base(), t + 1, 1);\n  Poly h0 = slice(n - 1);\n  h0.redeg((n << 1) - 1);\n  ntt.fft(h0.base(), t + 1);\n  Poly h0g0 = zeroes((n << 1) - 1);\n  for (int i = 0; i < (n << 1); ++i) h0g0[i] = h0[i] * (long long)nttg[i] % P;\n  ntt.fft(h0g0.base(), t + 1, -1);\n  Poly h0eps1 = zeroes((n << 1) - 1);\n  for (int i = 0; i < (n << 1); ++i) h0eps1[i] = h0[i] * (long long)eps1[i] % P;\n  ntt.fft(h0eps1.base(), t + 1, -1);\n  for (int i = 0; i < n; ++i) {\n    h0eps1[i] = operator[](i + n) - h0eps1[i];\n    if (h0eps1[i] < 0) h0eps1[i] += P;\n  }\n  memset(h0eps1.base() + n, 0, sizeof(int) << t);\n  ntt.fft(h0eps1.base(), t + 1);\n  for (int i = 0; i < (n << 1); ++i)\n    h0eps1[i] = h0eps1[i] * (long long)nttg[i] % P;\n  ntt.fft(h0eps1.base(), t + 1, -1);\n  memcpy(h0eps1.base() + n, h0eps1.base(), sizeof(int) << t);\n  memset(h0eps1.base(), 0, sizeof(int) << t);\n  return (h0g0 + h0eps1).slice(rhs.deg());\n}\nPoly Poly::ln() const {\n  if (deg() == 0) return 0;\n  return der().quo(slice(deg() - 1)).integ();\n}\npair<Poly, Poly> Poly::sqrti() const {\n  Poly g = nt.sqrt(a[0]), h = nt.inv(g[0]), nttg = g;\n  for (int t = 0; (1 << t) <= deg(); ++t) {\n    nit.sqrt(slice((2 << t) - 1), g, nttg, h, t);\n    nttg = g;\n    ntt.fft(nttg.base(), t + 1, 1);\n    nit.inv(g, nttg, h, t);\n  }\n  return make_pair(g.slice(deg()), h.slice(deg()));\n}\nPoly Poly::sqrt() const {\n  Poly g = nt.sqrt(a[0]), h = nt.inv(g[0]), nttg = g;\n  for (int t = 0; (1 << t) <= deg(); ++t) {\n    nit.sqrt(slice((2 << t) - 1), g, nttg, h, t);\n    if ((2 << t) <= deg()) {\n      nttg = g;\n      ntt.fft(nttg.base(), t + 1, 1);\n      nit.inv(g, nttg, h, t);\n    }\n  }\n  return g.slice(deg());\n}\nPoly Poly::exp() const {\n  vector<int> der(a), ret(a.size());\n  for (int i = 0; i < a.size(); ++i) der[i] = der[i] * (long long)i % P;\n  src.run(der, ret, [&](int i) {\n    if (i == 0)\n      ret[0] = 1;\n    else\n      ret[i] = ret[i] * (long long)simp.ginv(i) % P;\n  });\n  return ret;\n}\npair<Poly, Poly> Poly::expi() const {\n  Poly g = 1, h = 1, nttg = {1, 1};\n  for (int t = 0; (1 << t) <= deg(); ++t) {\n    nit.exp(slice((2 << t) - 1), g, nttg, h, t);\n    nttg = g;\n    nttg.redeg((4 << t) - 1);\n    ntt.fft(nttg.base(), t + 2);\n    Poly f2n = zeroes((2 << t) - 1);\n    for (int i = 0; i < (2 << t); ++i) f2n[i] = nttg[i << 1];\n    nit.inv(g, f2n, h, t);\n  }\n  return make_pair(g.slice(deg()), h.slice(deg()));\n}\nPoly Poly::exp(int k) const {\n  int lead, lz = 0;\n  while (lz < deg() && !a[lz]) ++lz;\n  if (lz == deg() && !a[lz]) return *this;\n  lead = a[lz];\n  if (lz * (long long)k > deg()) return zeroes(deg());\n  Poly part =\n      Poly(vector<int>(a.begin() + lz, a.begin() + deg() - lz * (k - 1) + 1)) *\n      nt.inv(lead);\n  part = (part.ln() * k).exp() * mpow(lead, k);\n  vector<int> ret(deg() + 1);\n  memcpy(ret.data() + lz * k, part.base(), sizeof(int) * (deg() - lz * k + 1));\n  return ret;\n}\nPoly Poly::operator/(const Poly &rhs) const {\n  int n = deg(), m = rhs.deg();\n  if (n < m) return 0;\n  Poly ta(vector<int>(a.rbegin(), a.rend())),\n      tb(vector<int>(rhs.a.rbegin(), rhs.a.rend()));\n  ta.redeg(n - m);\n  tb.redeg(n - m);\n  Poly q = ta.quo(tb);\n  reverse(q.a.begin(), q.a.end());\n  return q;\n}\npair<Poly, Poly> Poly::div(const Poly &rhs) const {\n  if (deg() < rhs.deg()) return make_pair(0, *this);\n  int n = deg(), m = rhs.deg();\n  Poly q = operator/(rhs), r;\n  int lgn = 0;\n  while ((1 << lgn) < rhs.deg()) ++lgn;\n  int t = (1 << lgn) - 1;\n  r = zeroes(t);\n  Poly tmp = zeroes(t);\n  for (int i = 0; i <= m; ++i)\n    if ((r[i & t] += rhs[i]) >= P) r[i & t] -= P;\n  for (int i = 0; i <= n - m; ++i)\n    if ((tmp[i & t] += q[i]) >= P) tmp[i & t] -= P;\n  ntt.fft(r.base(), lgn, 1);\n  ntt.fft(tmp.base(), lgn, 1);\n  for (int i = 0; i <= t; ++i) tmp[i] = tmp[i] * (long long)r[i] % P;\n  ntt.fft(tmp.base(), lgn, -1);\n  memset(r.base(), 0, sizeof(int) << lgn);\n  for (int i = 0; i <= n; ++i)\n    if ((r[i & t] += a[i]) >= P) r[i & t] -= P;\n  for (int i = 0; i < m; ++i)\n    if ((r[i] -= tmp[i]) < 0) r[i] += P;\n  return make_pair(q, r.slice(m - 1));\n}\nPoly Poly::operator%(const Poly &rhs) const {\n  if (deg() < rhs.deg()) return *this;\n  return div(rhs).second;\n}\nusing namespace std;\ntemplate <class T>\nistream &operator>>(istream &is, vector<T> &v) {\n  for (T &x : v) is >> x;\n  return is;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i) os << ' ' << v[i];\n  }\n  return os;\n}\nconst int N = 100010;\nint a[N], b[N];\nvoid GG() {\n  cout << \"0\\n\";\n  exit(0);\n}\nvector<vector<Poly>> solve(int l, int r) {\n  if (l == r) {\n    if (b[l] == 1)\n      return {{Poly(nt.inv(2)), Poly(1)}, {1_z, 1_z}};\n    else\n      return {{Poly(1), Poly(1)}, {1_z, 1_z}};\n  }\n  int mid = (l + r) / 2;\n  auto X = solve(l, mid), Y = solve(mid + 1, r);\n  vector<vector<Poly>> ret(2, vector<Poly>(2, Poly(0)));\n  for (int i = 0; i != 2; ++i)\n    for (int j = 0; j != 2; ++j)\n      for (int k = 0; k != 2; ++k) ret[i][k] = ret[i][k] + X[i][j] * Y[j][k];\n  return ret;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n;\n  cin >> n;\n  int m = 0, m1 = 0;\n  for (int i = 1; i <= n; ++i) cin >> a[i];\n  {\n    int p = n;\n    while (p) {\n      int x = a[p];\n      if (x == 1)\n        b[++m] = 1;\n      else\n        b[++m] = 2;\n      for (int rep = 0; rep != x; ++rep) {\n        if (p == 0) GG();\n        if (a[p] != x) GG();\n        --p;\n      }\n    }\n  }\n  auto res = solve(1, m)[0][0];\n  int ans = 0;\n  for (int i = 0; i <= res.deg(); ++i) {\n    int v =\n        res[i] * (unsigned long long)mpow(2, m - i) % P * simp.gfac(m - i) % P;\n    if (i & 1)\n      sub(ans, v);\n    else\n      add(ans, v);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int x = 0, f = 0;\n  char ch = getchar();\n  while (!isdigit(ch)) f |= ch == '-', ch = getchar();\n  while (isdigit(ch)) x = 10 * x + ch - '0', ch = getchar();\n  return f ? -x : x;\n}\ntemplate <typename T>\nvoid print(T x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x >= 10) print(x / 10);\n  putchar(x % 10 + '0');\n}\ntemplate <typename T>\nvoid print(T x, char ch) {\n  print(x), putchar(ch);\n}\nconst int N = 100005;\nconst int mod = 998244353;\nconst int G = 3, Gi = 332748118;\nconst int inv2 = (mod + 1) / 2;\nint qpow(int a, int b = mod - 2) {\n  int res = 1;\n  while (b) {\n    if (b & 1) res = 1ll * res * a % mod;\n    a = 1ll * a * a % mod;\n    b >>= 1;\n  }\n  return res;\n}\nnamespace Poly {\nint rev[1 << 20], lim, L;\nvoid getR(int len) {\n  lim = 1, L = 0;\n  while (lim <= len) lim <<= 1, L++;\n  for (int i = 0; i < lim; i++)\n    rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << L - 1);\n}\nvoid NTT(vector<int> &a, int opt) {\n  for (int i = 0; i < lim; i++)\n    if (i < rev[i]) swap(a[i], a[rev[i]]);\n  for (int mid = 1; mid < lim; mid <<= 1) {\n    int Wn = qpow(opt == 1 ? G : Gi, (mod - 1) / (mid << 1));\n    for (int j = 0; j < lim; j += 2 * mid) {\n      int W = 1;\n      for (int k = 0; k < mid; k++, W = 1ll * W * Wn % mod) {\n        int x = a[j + k], y = 1ll * W * a[j + k + mid] % mod;\n        a[j + k] = (x + y) % mod;\n        a[j + k + mid] = (x + mod - y) % mod;\n      }\n    }\n  }\n  if (opt == -1) {\n    int linv = qpow(lim);\n    for (int i = 0; i < lim; i++) a[i] = 1ll * a[i] * linv % mod;\n  }\n}\nvoid operator+=(vector<int> &a, vector<int> b) {\n  if ((int(a.size())) < (int(b.size()))) a.resize((int(b.size())));\n  for (int i = 0; i < (int(b.size())); i++) a[i] = (a[i] + b[i]) % mod;\n}\nvector<int> operator>>(vector<int> a, int x) {\n  int len = (int(a.size()));\n  if (len - 1 < x) return {};\n  for (int i = x; i < len; i++) a[i - x] = a[i];\n  a.resize(len - x);\n  return a;\n}\nvector<int> operator*(vector<int> a, vector<int> b) {\n  int len = (int(a.size())) + (int(b.size())) - 1;\n  if (len <= 300) {\n    vector<int> c(len);\n    for (int i = 0; i < (int(a.size())); i++) {\n      for (int j = 0; j < (int(b.size())); j++) {\n        c[i + j] = (c[i + j] + 1ll * a[i] * b[j]) % mod;\n      }\n    }\n    return c;\n  }\n  getR(len);\n  a.resize(lim), b.resize(lim);\n  NTT(a, 1), NTT(b, 1);\n  for (int i = 0; i < lim; i++) a[i] = 1ll * a[i] * b[i] % mod;\n  NTT(a, -1);\n  a.resize(len);\n  return a;\n}\nvoid print_poly(vector<int> a) {\n  for (auto v : a) printf(\"%d \", v);\n  puts(\"\");\n}\n}  // namespace Poly\nusing namespace Poly;\nint zz[N], b[N], n, m;\nvoid WA() { puts(\"0\"), exit(0); }\nvector<int> a[N << 2][2][2];\nvoid solve(int u, int l, int r) {\n  if (l == r) {\n    a[u][0][0] = a[u][0][1] = a[u][1][0] = a[u][1][1] = {0, 1};\n    if (b[l] == 1) a[u][0][0] = {0, inv2};\n    return;\n  }\n  int mid = l + r >> 1;\n  solve((u << 1), l, mid), solve((u << 1 | 1), mid + 1, r);\n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < 2; j++) {\n      a[u][i][j] += (a[(u << 1)][i][1] * a[(u << 1 | 1)][1][j]) >> 1;\n      a[u][i][j] += a[(u << 1)][i][0] * a[(u << 1 | 1)][0][j];\n    }\n  }\n}\nint fac[N], ifac[N], pw[N];\nvoid init(int n) {\n  fac[0] = 1;\n  for (int i = 1; i <= n; i++) fac[i] = 1ll * fac[i - 1] * i % mod;\n  ifac[n] = qpow(fac[n]);\n  for (int i = n; i >= 1; i--) ifac[i - 1] = 1ll * ifac[i] * i % mod;\n  pw[0] = 1;\n  for (int i = 1; i <= n; i++) pw[i] = 2 * pw[i - 1] % mod;\n}\nint main() {\n  init(N - 1);\n  n = read();\n  for (int i = 1; i <= n; i++) zz[i] = read();\n  for (int i = 1; i <= n; i++) {\n    int x = zz[i];\n    if (i + x - 1 > n) WA();\n    for (int j = i; j <= i + x - 1; j++) {\n      if (zz[j] != x) WA();\n    }\n    b[++m] = x;\n    i += x - 1;\n  }\n  solve(1, 1, m);\n  int ans = 0;\n  assert((int(a[1][0][0].size())) == m + 1);\n  for (int i = 0; i <= m; i++) {\n    int coef = 1ll * fac[i] * qpow(2, i) % mod * a[1][0][0][i] % mod;\n    if ((m - i) & 1)\n      ans = (ans + mod - coef) % mod;\n    else\n      ans = (ans + coef) % mod;\n  }\n  print(ans, '\\n');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\nconst int mod = 998244353, gn = 3;\nconst int inf = 2147483647;\nlong long read() {\n  long long x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10ll + ch - '0';\n    ch = getchar();\n  }\n  return x * f;\n}\nvoid up(int& x, int y) {\n  x += y;\n  if (x >= mod) x -= mod;\n}\nint Pow(int x, int y) {\n  if (!y) return 1;\n  int t = Pow(x, y >> 1);\n  t = (long long)t * t % mod;\n  if (y & 1) t = (long long)t * x % mod;\n  return t;\n}\nint n, a[N], m = 0, b[N];\nstruct DP {\n  vector<int> f[2][2];\n  DP(vector<int> _f[2][2]) {\n    for (int i = 0; i < 2; i++)\n      for (int j = 0; j < 2; j++) f[i][j] = _f[i][j];\n  }\n};\nint rev[N << 2], pw[2][N << 2];\nvoid NTT(vector<int>& a, int n, int o) {\n  for (int i = 0; i < n; i++)\n    if (i < rev[i]) swap(a[i], a[rev[i]]);\n  for (int i = 1; i < n; i <<= 1) {\n    int wn;\n    if (o == 1)\n      wn = pw[0][i];\n    else\n      wn = pw[1][i];\n    for (int j = 0; j < n; j += (i << 1)) {\n      int w = 1;\n      for (int k = 0; k < i; k++) {\n        int t = (long long)w * a[i + j + k] % mod;\n        w = (long long)w * wn % mod;\n        a[i + j + k] = (a[j + k] - t + mod) % mod;\n        a[j + k] = (a[j + k] + t) % mod;\n      }\n    }\n  }\n}\nvector<int> E[2][2];\nint M, INV, len;\nvector<int> Mul(vector<int> a, vector<int> b) {\n  vector<int> c;\n  a.resize(M + 1), b.resize(M + 1), c.resize(M + 1);\n  NTT(a, M, 1), NTT(b, M, 1);\n  for (int i = 0; i <= M; i++) c[i] = (long long)a[i] * b[i] % mod;\n  NTT(c, M, -1);\n  for (int i = 0; i <= M; i++) c[i] = (long long)c[i] * INV % mod;\n  c[0] = 0;\n  while (c.size() > len) c.pop_back();\n  return c;\n}\nDP solve(int l, int r) {\n  if (l == r) {\n    vector<int> t[2][2];\n    for (int i = 0; i < 2; i++)\n      for (int j = 0; j < 2; j++) t[i][j].resize(2);\n    if (b[l] == 1)\n      t[1][1][1] = 1;\n    else\n      t[0][0][1] = 2;\n    return DP(t);\n  }\n  int mid = l + r >> 1;\n  DP L = solve(l, mid), R = solve(mid + 1, r);\n  DP res = DP(E);\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 2; j++) res.f[i][j].resize(r - l + 2);\n  int L1, R1, L2, R2;\n  L1 = (b[l] == 1);\n  R1 = (b[mid] == 1);\n  L2 = (b[mid + 1] == 1);\n  R2 = (b[r] == 1);\n  M = 1, len = r - l + 2;\n  while (M <= r - l + 1) M <<= 1;\n  rev[0] = 0;\n  for (int i = 1; i < M; i++)\n    rev[i] = ((rev[i >> 1] >> 1) | ((i & 1) * (M >> 1)));\n  INV = Pow(M, mod - 2);\n  for (int l1 = 0; l1 <= L1; l1++)\n    for (int r1 = 0; r1 <= R1; r1++)\n      for (int l2 = 0; l2 <= L2; l2++)\n        for (int r2 = 0; r2 <= R2; r2++) {\n          vector<int> tmp = Mul(L.f[l1][r1], R.f[l2][r2]);\n          for (int i = 2; i <= r - l + 1; i++) up(res.f[l1][r2][i], tmp[i]);\n          int ll = l1, rr = r2;\n          if (l == mid) ll = 0;\n          if (mid + 1 == r) rr = 0;\n          int v = 1;\n          if (!r1 && !l2)\n            v = (mod + 1) / 2;\n          else if (r1 && l2)\n            v = 2;\n          for (int i = 1; i <= r - l; i++)\n            up(res.f[ll][rr][i], (long long)tmp[i + 1] * v % mod);\n        }\n  return res;\n}\nint main() {\n  n = read();\n  for (int i = 1; i <= n; i++) a[i] = read();\n  int u = 1;\n  while (u <= 2 * n) u <<= 1;\n  for (int i = 1; i < u; i++) {\n    pw[0][i] = Pow(gn, (mod - 1) / (i << 1));\n    pw[1][i] = Pow(gn, mod - 1 - (mod - 1) / (i << 1));\n  }\n  int l = 1, cnt = 0;\n  while (l <= n) {\n    m++;\n    int r = l + a[l] - 1;\n    cnt += (l == r);\n    b[m] = r - l + 1;\n    for (int i = l + 1; i <= r; i++)\n      if (a[i] != a[i - 1]) {\n        cout << 0 << endl;\n        return 0;\n      }\n    l = r + 1;\n  }\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 2; j++) E[i][j].clear();\n  DP res = solve(1, m);\n  int ans = 0, fac = 1;\n  for (int i = 1; i <= m; i++) {\n    int t = 0;\n    fac = (long long)fac * i % mod;\n    for (int j = 0; j < 2; j++)\n      for (int k = 0; k < 2; k++) up(t, res.f[j][k][i]);\n    t = (long long)t * fac % mod;\n    if ((i & 1) == (m & 1))\n      up(ans, t);\n    else\n      up(ans, mod - t);\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\nint mult(int a, int b) { return ((long long int)a * b) % 998244353; }\nint modPow(int b, int e) {\n  int r = 1;\n  while (e > 0) {\n    if (e & 1) r = mult(r, b);\n    e >>= 1;\n    b = mult(b, b);\n  }\n  return r;\n}\nint inv(int b) { return modPow(b, 998244353 - 2); }\nint mbase, base;\nint root, w[1 << 19];\nint revb[1 << 19];\nint setBase(int nbase) {\n  int i, j;\n  mbase = 1;\n  while (!(998244353 & (1LL << mbase))) mbase++;\n  root = 2;\n  while ((modPow(root, 1LL << mbase) != 1) ||\n         (modPow(root, 1LL << (mbase - 1)) == 1))\n    root++;\n  base = nbase;\n  for (i = 0; i < (1 << base); i++)\n    revb[i] = (revb[i >> 1] >> 1) | ((i & 1) << (base - 1));\n  w[0] = 0, w[1] = 1;\n  for (i = 1; i < nbase; i++) {\n    int z = modPow(root, 1LL << (mbase - i - 1));\n    for (j = (1 << (i - 1)); j < (1 << i); j++)\n      w[j << 1] = w[j], w[(j << 1) | 1] = mult(w[j], z);\n  }\n  return 0;\n}\nint FFT(int *a, int n) {\n  int i, j, k, l = 0;\n  while ((1 << l) < n) l++;\n  int s = base - l;\n  for (i = 0; i < n; i++) {\n    if (i < (revb[i] >> s)) swap(a[i], a[revb[i] >> s]);\n  }\n  for (k = 1; k < n; k <<= 1) {\n    for (i = 0; i < n; i += (k << 1)) {\n      for (j = 0; j < k; j++) {\n        int z = mult(a[i + j + k], w[j + k]);\n        a[i + j + k] = a[i + j] - z, a[i + j] += z;\n        if (a[i + j + k] < 0) a[i + j + k] += 998244353;\n        if (a[i + j] >= 998244353) a[i + j] -= 998244353;\n      }\n    }\n  }\n  for (i = 0; i < n; i++) a[i] %= 998244353;\n  return 0;\n}\nint FFT(vector<int> &a) { return FFT(a.data(), a.size()); }\nvector<int> res(const vector<int> &A, int n) {\n  vector<int> B = A;\n  B.resize(n);\n  return B;\n}\nvector<int> mult(const vector<int> &A, const vector<int> &B) {\n  if ((long long int)A.size() * B.size() <= 10000) {\n    int i, j;\n    vector<int> C(A.size() + B.size() - 1, 0);\n    const int *a = A.data(), *b = B.data();\n    int *c = C.data();\n    for (i = 0; i < A.size(); i++) {\n      for (j = 0; j < B.size(); j++) {\n        c[i + j] += mult(a[i], b[j]);\n        if (c[i + j] >= 998244353) c[i + j] -= 998244353;\n      }\n    }\n    return C;\n  }\n  int i, n = 1, s = A.size() + B.size() - 1;\n  while (n < s) n <<= 1;\n  vector<int> A2 = res(A, n), B2 = res(B, n);\n  FFT(A2), FFT(B2);\n  int x = inv(n);\n  for (i = 0; i < n; i++) A2[i] = mult(mult(A2[i], B2[i]), x);\n  reverse(A2.begin() + 1, A2.end()), FFT(A2);\n  return res(A2, s);\n}\nvector<int> add(vector<int> a, vector<int> b) {\n  int i;\n  if (a.size() < b.size()) swap(a, b);\n  for (i = 0; i < b.size(); i++) {\n    a[i] += b[i];\n    if (a[i] >= 998244353) a[i] -= 998244353;\n  }\n  return a;\n}\nint a[100000], b[100000];\nint inv2[1000000], fact[1000000];\nset<pair<int, int> > S;\nvector<int> v;\nstruct info {\n  vector<int> p[2][2];\n};\ninfo seen0[100005], seen1[100005];\ninfo getAns(int s, int e) {\n  if (s == e) {\n    int i, j;\n    info f;\n    for (i = 0; i < 2; i++) {\n      for (j = 0; j < 2; j++) {\n        f.p[i][j] = vector<int>(3, 0);\n        if (i == j) f.p[i][j][i] = 1;\n      }\n    }\n    return f;\n  } else if (s == e - 1) {\n    int i, j;\n    info f;\n    for (i = 0; i < 2; i++) {\n      for (j = 0; j < 2; j++) {\n        f.p[i][j] = vector<int>(3, 0);\n        f.p[i][j][i + j] = (v[s + 1] && (i == 0) && (j == 0)) ? inv2[1] : 1;\n      }\n    }\n    return f;\n  }\n  int i, j, k;\n  int mid = (s + e) / 2;\n  int z = 0, o = 0;\n  for (i = s + 1; i <= e; i++) {\n    if (v[i] == 0)\n      z = 1;\n    else\n      o = 1;\n  }\n  if (!z) {\n    if (!seen1[e - s].p[0][0].empty()) return seen1[e - s];\n  } else if (!o) {\n    if (!seen0[e - s].p[0][0].empty()) return seen0[e - s];\n  }\n  info L = getAns(s, mid), R = getAns(mid, e), f;\n  for (i = 0; i < 2; i++) {\n    for (j = 0; j < 2; j++) {\n      for (k = 0; k < 2; k++) {\n        vector<int> P = mult(L.p[i][k], R.p[k][j]);\n        if (k) P.erase(P.begin());\n        f.p[i][j] = add(f.p[i][j], P);\n      }\n    }\n  }\n  if (!z)\n    seen1[e - s] = f;\n  else if (!o)\n    seen0[e - s] = f;\n  return f;\n}\nint pow2[1000000];\nint main() {\n  int i;\n  int n;\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) scanf(\"%d\", &a[i]), S.insert(make_pair(a[i], -i));\n  setBase(19);\n  int j, k;\n  fact[0] = pow2[0] = inv2[0] = 1;\n  for (i = 1; i < 1000000; i++) {\n    fact[i] = ((long long int)i * fact[i - 1]) % 998244353;\n    pow2[i] = (2 * pow2[i - 1]) % 998244353;\n    inv2[i] = ((long long int)((998244353 + 1) / 2) * inv2[i - 1]) % 998244353;\n  }\n  while (!S.empty()) {\n    pair<int, int> u = *S.rbegin();\n    for (i = -u.second; i < -u.second + u.first; i++) {\n      if ((i >= n) || (a[i] != u.first) || !S.count(make_pair(a[i], -i))) {\n        printf(\"0\\n\");\n        return 0;\n      } else {\n        S.erase(make_pair(a[i], -i));\n        if (i > -u.second) b[i - 1] = 1;\n      }\n    }\n  }\n  for (i = 0; i < n; i++) {\n    if (!b[i]) v.push_back(a[i] == 1);\n  }\n  if (v.size() == 1) {\n    if (n == 1)\n      printf(\"1\\n\");\n    else\n      printf(\"2\\n\");\n    return 0;\n  }\n  info f = getAns(0, (int)v.size() - 2);\n  long long int ans = 0;\n  for (i = 0; i < 2; i++) {\n    for (j = 0; j < 2; j++) {\n      for (k = 0; k < f.p[i][j].size(); k++) {\n        if (v[0] && (i == 0))\n          f.p[i][j][k] = ((long long int)f.p[i][j][k] * inv2[1]) % 998244353;\n        if (v.back() && (j == 0))\n          f.p[i][j][k] = ((long long int)f.p[i][j][k] * inv2[1]) % 998244353;\n        if (v.size() >= k) {\n          if (k & 1)\n            ans -= (((long long int)f.p[i][j][k] * fact[v.size() - k]) %\n                    998244353) *\n                   pow2[v.size() - k];\n          else\n            ans += (((long long int)f.p[i][j][k] * fact[v.size() - k]) %\n                    998244353) *\n                   pow2[v.size() - k];\n          ans %= 998244353;\n        }\n      }\n    }\n  }\n  ans %= 998244353;\n  if (ans < 0) ans += 998244353;\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 998244353;\nint qpow(int a, int b) {\n  int ret = 1;\n  while (b) {\n    if (b & 1) ret = (long long)ret * a % MOD;\n    a = (long long)a * a % MOD;\n    b >>= 1;\n  }\n  return ret;\n}\nnamespace NTT {\nconst int g = 3;\nconst int NN = 100010;\nint x[NN << 2], y[NN << 2], wn[NN << 2];\nvoid init() {\n  for (int i = 0; i <= 20; i++) wn[i] = qpow(g, (MOD - 1) / (1 << i));\n}\nvoid brc(int *F, int len) {\n  int j = len / 2;\n  for (int i = 1; i <= len - 2; i++) {\n    if (i < j) swap(F[i], F[j]);\n    int k = len / 2;\n    while (j >= k) j -= k, k >>= 1;\n    if (j < k) j += k;\n  }\n}\nvoid NTT(int *F, int len, int t) {\n  int id = 0;\n  brc(F, len);\n  for (int h = 2; h <= len; h <<= 1) {\n    id++;\n    for (int j = 0; j < len; j += h) {\n      int E = 1;\n      for (int k = j; k < j + h / 2; k++) {\n        int u = F[k], v = (long long)E * F[k + h / 2] % MOD;\n        F[k] = (u + v) % MOD, F[k + h / 2] = ((u - v) % MOD + MOD) % MOD;\n        E = (long long)E * wn[id] % MOD;\n      }\n    }\n  }\n  if (t == -1) {\n    for (int i = 1; i <= len / 2 - 1; i++) swap(F[i], F[len - i]);\n    long long inv = qpow(len, MOD - 2);\n    for (int i = 0; i <= len - 1; i++) F[i] = (long long)F[i] % MOD * inv % MOD;\n  }\n}\n};  // namespace NTT\nconst int N = 100010;\nint tmp1[2][2][N << 2], tmp2[2][2][N << 2], f1[2][2][N << 2], f2[2][2][N << 2],\n    f[2][2][N], a[N], p[N], n, cnt, fac[N];\nvoid work(int l, int r) {\n  if (l == r) {\n    if (p[l] == 1)\n      f[1][1][l] = 1;\n    else\n      f[0][0][l] = 2;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  work(l, mid);\n  work(mid + 1, r);\n  int len1 = mid - l + 1, len2 = r - mid, M = 1;\n  for (; M < len1 + len2; M <<= 1)\n    ;\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < M; j++) tmp1[0][i][j] = tmp2[0][i][j] = 0;\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 2; j++)\n      for (int k = 0; k < len1; k++) (tmp1[0][i][k] += f[i][j][l + k]) %= MOD;\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 2; j++)\n      for (int k = 0; k < len2; k++)\n        (tmp2[0][j][k] += f[i][j][mid + 1 + k]) %= MOD;\n  for (int i = 0; i < 2; i++)\n    NTT::NTT(tmp1[0][i], M, 1), NTT::NTT(tmp2[0][i], M, 1);\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 2; j++)\n      for (int k = 0; k < M; k++)\n        f1[i][j][k] = 1LL * tmp1[0][i][k] * tmp2[0][j][k] % MOD;\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 2; j++) NTT::NTT(f1[i][j], M, -1);\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 2; j++)\n      for (int k = 0; k < M; k++) tmp1[i][j][k] = tmp2[i][j][k] = 0;\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 2; j++)\n      for (int k = 0; k < len1; k++) {\n        if (k == len1 - 1 && i && j)\n          tmp1[0][0][k] = (tmp1[0][0][k] + 2ll * f[i][j][l + k]) % MOD;\n        else\n          (tmp1[i][j][k] += f[i][j][l + k]) %= MOD;\n      }\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 2; j++)\n      for (int k = 0; k < len2; k++) {\n        if (k == len2 - 1 && i && j)\n          tmp2[0][0][k] = (tmp2[0][0][k] + 2ll * f[i][j][mid + 1 + k]) % MOD;\n        else\n          (tmp2[i][j][k] += f[i][j][mid + 1 + k]) %= MOD;\n      }\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 2; j++)\n      NTT::NTT(tmp1[i][j], M, 1), NTT::NTT(tmp2[i][j], M, 1);\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 2; j++)\n      for (int k = 0; k < M; k++) {\n        f2[i][j][k] = 0;\n        for (int a = 0; a < 2; a++)\n          for (int b = 0; b < 2; b++) {\n            int C;\n            if (a && b)\n              C = 2;\n            else if (a || b)\n              C = 1;\n            else\n              C = (MOD + 1) / 2;\n            f2[i][j][k] = (f2[i][j][k] +\n                           (long long)C * tmp1[i][a][k] % MOD * tmp2[b][j][k]) %\n                          MOD;\n          }\n      }\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 2; j++) NTT::NTT(f2[i][j], M, -1);\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 2; j++) {\n      f[i][j][l] = f1[i][j][0];\n      for (int k = 1; k <= r - l; k++)\n        f[i][j][l + k] = (f1[i][j][k] + f2[i][j][k - 1]) % MOD;\n    }\n}\nint main() {\n  NTT::init();\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  for (int i = 1; i <= n; i += a[i]) {\n    int j = i + a[i] - 1;\n    for (int k = i; k <= j; k++)\n      if (k > n || a[k] != a[i]) {\n        puts(\"0\");\n        return 0;\n      }\n    p[++cnt] = a[i];\n  }\n  fac[0] = 1;\n  for (int i = 1; i <= cnt; i++) fac[i] = 1LL * fac[i - 1] * i % MOD;\n  work(1, cnt);\n  int ans = 0;\n  for (int j = 0; j < 2; j++)\n    for (int k = 0; k < 2; k++)\n      for (int i = 1; i <= cnt; i++)\n        ans = (ans + 1LL * ((i & 1) ? 1 : MOD - 1) * f[j][k][i] % MOD *\n                         fac[cnt - (i - 1)]) %\n              MOD;\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353, _G = 3, N = (1 << 19), inv2 = (mod + 1) / 2;\nint qpow(int x, int y = mod - 2) {\n  int res = 1;\n  for (; y; x = (long long)x * x % mod, y >>= 1)\n    if (y & 1) res = (long long)res * x % mod;\n  return res;\n}\nint n, fn, m, fac[N], ifac[N], inv[N];\nvoid init(int x) {\n  fac[0] = ifac[0] = inv[1] = 1;\n  for (int i = (2); i <= (x); ++i)\n    inv[i] = (long long)inv[mod % i] * (mod - mod / i) % mod;\n  for (int i = (1); i <= (x); ++i)\n    fac[i] = (long long)fac[i - 1] * i % mod,\n    ifac[i] = (long long)ifac[i - 1] * inv[i] % mod;\n}\nint rt[N], Lim;\nvoid Pinit(int x) {\n  for (Lim = 1; Lim <= x; Lim <<= 1)\n    ;\n  int sG = qpow(_G, (mod - 1) / Lim);\n  rt[0] = 1;\n  for (int i = (1); i <= (Lim); ++i) rt[i] = (long long)rt[i - 1] * sG % mod;\n}\nint C(int x, int y) {\n  return y < 0 || x < y ? 0\n                        : (long long)fac[x] * ifac[y] % mod * ifac[x - y] % mod;\n}\nint rev[N];\nvoid initrev(int n) {\n  for (int i = (0); i <= (n - 1); ++i)\n    rev[i] = ((rev[i >> 1] >> 1) | ((i & 1) * (n >> 1)));\n}\nstruct poly {\n  vector<int> a;\n  int size() { return ((int)a.size()); }\n  int &operator[](int x) { return a[x]; }\n  int v(int x) { return x < 0 || x >= ((int)a.size()) ? 0 : a[x]; }\n  void clear() { vector<int>().swap(a); }\n  void rs(int x = 0) { a.resize(x); }\n  poly(int n = 0) { rs(n); }\n  poly(vector<int> o) { a = o; }\n  poly(const poly &o) { a = o.a; }\n  poly Rs(int x = 0) {\n    vector<int> res = a;\n    res.resize(x);\n    return res;\n  }\n  inline void ntt(int op, int t = true) {\n    int n = ((int)a.size());\n    if (t) initrev(n);\n    for (int i = (0); i <= (n - 1); ++i)\n      if (rev[i] < i) swap(a[rev[i]], a[i]);\n    for (int i = 2; i <= n; i <<= 1)\n      for (int j = 0, l = (i >> 1), ch = Lim / i; j < n; j += i)\n        for (int k = j, now = 0; k < j + l; k++) {\n          int pa = a[k], pb = (long long)a[k + l] *\n                              (op == 1 ? rt[now] : rt[Lim - now]) % mod;\n          a[k] = (pa + pb >= mod ? pa + pb - mod : pa + pb),\n          a[k + l] = (pa < pb ? pa - pb + mod : pa - pb), now += ch;\n        }\n    if (op != 1)\n      for (int i = 0, iv = qpow(n); i < n; i++)\n        a[i] = (long long)a[i] * iv % mod;\n  }\n  poly Shift(int x) {\n    poly zm(max(((int)a.size()) + x, 0));\n    for (int i = (max(0, -x)); i <= (((int)a.size()) - 1); ++i)\n      zm[i + x] = a[i];\n    return zm;\n  }\n  friend poly operator*(poly aa, poly bb) {\n    if (!((int)aa.size()) || !((int)bb.size())) return {};\n    int lim, all = ((int)aa.size()) + ((int)bb.size()) - 1;\n    for (lim = 1; lim < all; lim <<= 1)\n      ;\n    initrev(lim), aa.rs(lim), bb.rs(lim), aa.ntt(1, false), bb.ntt(1, false);\n    for (int i = (0); i <= (lim - 1); ++i)\n      aa[i] = (long long)aa[i] * bb[i] % mod;\n    aa.ntt(-1, false), aa.a.resize(all);\n    return aa;\n  }\n  friend poly operator*(poly aa, int bb) {\n    poly res(((int)aa.size()));\n    for (int i = (0); i <= (((int)aa.size()) - 1); ++i)\n      res[i] = (long long)aa[i] * bb % mod;\n    return res;\n  }\n  friend poly operator+(poly aa, poly bb) {\n    vector<int> res(max(((int)aa.size()), ((int)bb.size())));\n    for (int i = (0); i <= (((int)res.size()) - 1); ++i)\n      res[i] = (aa.v(i) + bb.v(i) >= mod ? aa.v(i) + bb.v(i) - mod\n                                         : aa.v(i) + bb.v(i));\n    return poly(res);\n  }\n  friend poly operator-(poly aa, poly bb) {\n    vector<int> res(max(((int)aa.size()), ((int)bb.size())));\n    for (int i = (0); i <= (((int)res.size()) - 1); ++i)\n      res[i] =\n          (aa.v(i) < bb.v(i) ? aa.v(i) - bb.v(i) + mod : aa.v(i) - bb.v(i));\n    return poly(res);\n  }\n  poly &operator+=(poly o) {\n    rs(max(((int)a.size()), ((int)o.size())));\n    for (int i = (0); i <= (((int)a.size()) - 1); ++i) (a[i] += o.v(i)) %= mod;\n    return (*this);\n  }\n  poly &operator-=(poly o) {\n    rs(max(((int)a.size()), ((int)o.size())));\n    for (int i = (0); i <= (((int)a.size()) - 1); ++i)\n      (a[i] += mod - o.v(i)) %= mod;\n    return (*this);\n  }\n  poly &operator*=(poly o) { return (*this) = (*this) * o; }\n  poly Inv() {\n    poly res, f, g;\n    res.rs(1), res[0] = qpow(a[0]);\n    for (int m = 1, pn; m < ((int)a.size()); m <<= 1) {\n      pn = m << 1, f = res, g.rs(pn), f.rs(pn), initrev(pn);\n      for (int i = 0; i < pn; i++) g[i] = (*this).v(i);\n      f.ntt(1, false), g.ntt(1, false);\n      for (int i = 0; i < pn; i++) g[i] = (long long)f[i] * g[i] % mod;\n      g.ntt(-1, false);\n      for (int i = 0; i < m; i++) g[i] = 0;\n      g.ntt(1, false);\n      for (int i = 0; i < pn; i++) g[i] = (long long)f[i] * g[i] % mod;\n      g.ntt(-1, false), res.rs(pn);\n      for (int i = m; i < min(pn, ((int)a.size())); i++)\n        res[i] = (mod - g[i]) % mod;\n    }\n    return res;\n  }\n  poly Integ() {\n    if (!((int)a.size())) return poly();\n    poly res(((int)a.size()) + 1);\n    for (int i = (1); i <= (((int)a.size())); ++i)\n      res[i] = (long long)a[i - 1] * inv[i] % mod;\n    return res;\n  }\n  poly Deriv() {\n    if (!((int)a.size())) return poly();\n    poly res(((int)a.size()) - 1);\n    for (int i = (1); i <= (((int)a.size()) - 1); ++i)\n      res[i - 1] = (long long)a[i] * i % mod;\n    return res;\n  }\n  poly Ln() {\n    poly g = ((*this).Inv() * (*this).Deriv()).Integ();\n    return g.rs(((int)a.size())), g;\n  }\n  poly Exp() {\n    poly res(1), f;\n    res[0] = 1;\n    for (int m = 1, pn; m < ((int)a.size()); m <<= 1) {\n      pn = min(m << 1, ((int)a.size())), f.rs(pn), res.rs(pn);\n      for (int i = 0; i < pn; i++) f[i] = (*this).v(i);\n      f -= res.Ln(), (f[0] += 1) %= mod, res *= f, res.rs(pn);\n    }\n    return res.rs(((int)a.size())), res;\n  }\n  poly pow(int x) {\n    poly res = (*this).Ln();\n    for (int i = (0); i <= (((int)res.size()) - 1); ++i)\n      res[i] = (long long)res[i] * x % mod;\n    res = res.Exp();\n    return res;\n  }\n  poly sqrt(int rt = 1) {\n    poly res(1), f;\n    res[0] = rt;\n    for (int m = 1, pn; m < ((int)a.size()); m <<= 1) {\n      pn = min(m << 1, ((int)a.size())), f.rs(pn);\n      for (int i = 0; i < pn; i++) f[i] = (*this).v(i);\n      f += res * res, f.rs(pn), res.rs(pn), res = f * res.Inv(), res.rs(pn);\n      for (int i = 0; i < pn; i++) res[i] = (long long)res[i] * inv2 % mod;\n    }\n    return res;\n  }\n  void Rev() { reverse(a.begin(), a.end()); }\n};\nint W[N], f[N];\npoly s[N][2][2];\nvoid divide(int x, int l, int r) {\n  if (l == r) {\n    for (int i = (0); i <= (1); ++i)\n      for (int j = (0); j <= (1); ++j) s[x][i][j] = vector<int>{0, 1};\n    if (f[l] == 1) s[x][0][0] = vector<int>{0, inv2};\n    return;\n  }\n  int mid = (l + r) >> 1;\n  divide(x * 2, l, mid);\n  divide(x * 2 + 1, mid + 1, r);\n  for (int a = (0); a <= (1); ++a)\n    for (int b = (0); b <= (1); ++b)\n      s[x][a][b] += (s[x * 2][a][1] * s[x * 2 + 1][1][b]).Shift(-1);\n  for (int a = (0); a <= (1); ++a)\n    for (int b = (0); b <= (1); ++b)\n      s[x][a][b] += s[x * 2][a][0] * s[x * 2 + 1][0][b];\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n, init(n * 4), Pinit(n * 4);\n  for (int i = (1); i <= (n); ++i) cin >> W[i];\n  int cnt = 0;\n  for (int i = (1); i <= (n); ++i) {\n    ++cnt;\n    if (W[i] != W[i + 1]) {\n      if (cnt % W[i]) return cout << 0 << \"\\n\", 0;\n      for (int t = (1); t <= (cnt / W[i]); ++t) f[++m] = W[i];\n      cnt = 0;\n    }\n  }\n  divide(1, 1, m);\n  int res = 0;\n  for (int i = (0); i <= (((int)s[1][0][0].size()) - 1); ++i)\n    (res += (long long)s[1][0][0][i] * qpow(2, i) % mod * fac[i] % mod *\n            qpow(mod - 1, m - i) % mod) %= mod;\n  cout << res << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <typename _Tp>\nvoid read(_Tp &x) {\n  char ch(getchar());\n  bool f(false);\n  while (!isdigit(ch)) f |= ch == 45, ch = getchar();\n  x = ch & 15, ch = getchar();\n  while (isdigit(ch)) x = x * 10 + (ch & 15), ch = getchar();\n  if (f) x = -x;\n}\ntemplate <typename _Tp, typename... Args>\nvoid read(_Tp &t, Args &...args) {\n  read(t);\n  read(args...);\n}\nconst int max_len = 1 << 18, N = max_len + 5, mod = 998244353,\n          inv2 = (mod + 1) / 2;\ntemplate <typename _Tp1, typename _Tp2>\ninline void add(_Tp1 &a, _Tp2 b) {\n  (a += b) >= mod && (a -= mod);\n}\ntemplate <typename _Tp1, typename _Tp2>\ninline void sub(_Tp1 &a, _Tp2 b) {\n  (a -= b) < 0 && (a += mod);\n}\ntemplate <typename _Tp>\ninline _Tp _sub(_Tp a, const _Tp &b) {\n  (a += mod - b) >= mod && (a -= mod);\n  return a;\n}\nlong long ksm(long long a, long long b = mod - 2) {\n  long long res = 1;\n  while (b) {\n    if (b & 1) res = res * a % mod;\n    a = a * a % mod, b >>= 1;\n  }\n  return res;\n}\nvoid print(const std::vector<int> &a) {\n  for (auto it : a) printf(\"%d \", it);\n  printf(\"\\n\");\n}\ninline std::vector<int> operator<<(std::vector<int> a, unsigned int b) {\n  return a.insert(a.begin(), b, 0), a;\n}\ninline std::vector<int> operator<<=(std::vector<int> &a, unsigned int b) {\n  return a.insert(a.begin(), b, 0), a;\n}\ninline std::vector<int> operator>>(const std::vector<int> &a, unsigned int b) {\n  return b >= a.size() ? std::vector<int>()\n                       : std::vector<int>{a.begin() + b, a.end()};\n}\ninline std::vector<int> operator>>=(std::vector<int> &a, unsigned int b) {\n  return a = b >= a.size() ? std::vector<int>()\n                           : std::vector<int>{a.begin() + b, a.end()};\n}\nstd::vector<int> operator+=(std::vector<int> &a, const std::vector<int> &b) {\n  if (b.size() > a.size()) a.resize(b.size());\n  for (unsigned int i = 0; i < b.size(); ++i) add(a[i], b[i]);\n  return a;\n}\ninline std::vector<int> operator+(const std::vector<int> &a,\n                                  const std::vector<int> &b) {\n  std::vector<int> tmp(a);\n  tmp += b;\n  return tmp;\n}\nstd::vector<int> operator-=(std::vector<int> &a, const std::vector<int> &b) {\n  if (b.size() > a.size()) a.resize(b.size());\n  for (unsigned int i = 0; i < b.size(); ++i) sub(a[i], b[i]);\n  return a;\n}\ninline std::vector<int> operator-(const std::vector<int> &a,\n                                  const std::vector<int> &b) {\n  std::vector<int> tmp(a);\n  tmp -= b;\n  return tmp;\n}\nconst unsigned long long Omg = ksm(3, (mod - 1) / max_len);\nunsigned long long Omgs[N];\nvoid setup() {\n  Omgs[max_len / 2] = 1;\n  for (int i = max_len / 2 + 1; i < max_len; ++i)\n    Omgs[i] = Omgs[i - 1] * Omg % mod;\n  for (int i = max_len / 2 - 1; i > 0; --i) Omgs[i] = Omgs[i << 1];\n}\nunsigned int rev[N];\nunsigned int getlen(unsigned int len) {\n  unsigned int limit = 1;\n  while (limit < len) limit <<= 1;\n  for (unsigned int i = 0; i < limit; ++i)\n    rev[i] = (rev[i >> 1] >> 1) | (i & 1 ? limit >> 1 : 0);\n  return limit;\n}\nvoid dft(unsigned long long *A, unsigned int limit) {\n  for (unsigned int i = 0; i < limit; ++i)\n    if (i < rev[i]) std::swap(A[i], A[rev[i]]);\n  for (unsigned int len = 1; len < limit; len <<= 1) {\n    if (len == 262144u)\n      for (unsigned int i = 0; i < limit; ++i) A[i] %= mod;\n    for (unsigned int i = 0; i < limit; i += len << 1) {\n      unsigned long long *p = A + i, *q = A + i + len, *w = Omgs + len;\n      for (unsigned int j = 0; j < len; ++j, ++p, ++q, ++w) {\n        const unsigned long long tp = *q * *w % mod;\n        *q = *p + mod - tp, *p += tp;\n      }\n    }\n  }\n  for (unsigned int i = 0; i < limit; ++i) A[i] %= mod;\n}\nvoid idft(unsigned long long *A, unsigned int limit) {\n  std::reverse(A + 1, A + limit), dft(A, limit);\n  unsigned long long inv = mod - (mod - 1) / limit;\n  for (unsigned int i = 0; i < limit; ++i) A[i] = A[i] * inv % mod;\n}\nunsigned long long _f[N], _g[N], _tp[N];\nstd::vector<int> operator*(const std::vector<int> &a,\n                           const std::vector<int> &b) {\n  if (a.empty() || b.empty()) return {};\n  unsigned int len = a.size() + b.size() - 1;\n  if (a.size() <= 64u || b.size() <= 64u) {\n    memset(_tp, 0, len << 3);\n    unsigned int r = 0;\n    for (unsigned int i = 0; i < a.size(); ++i) {\n      for (unsigned int j = 0; j < b.size(); ++j)\n        _tp[i + j] += 1ULL * a[i] * b[j];\n      if (++r == 18) {\n        r = 0;\n        for (unsigned int j = i - 17; j < i + b.size(); ++j) _tp[j] %= mod;\n      }\n    }\n    if (r)\n      for (unsigned int j = 0; j < len; ++j) _tp[j] %= mod;\n    std::vector<int> c(len);\n    for (unsigned int i = 0; i < len; ++i) c[i] = _tp[i];\n    return c;\n  }\n  unsigned int limit = getlen(len);\n  memset(_f + a.size(), 0, (limit - a.size()) << 3);\n  for (unsigned int i = 0; i < a.size(); ++i) _f[i] = a[i];\n  memset(_g + b.size(), 0, (limit - b.size()) << 3);\n  for (unsigned int i = 0; i < b.size(); ++i) _g[i] = b[i];\n  dft(_f, limit), dft(_g, limit);\n  for (unsigned int i = 0; i < limit; ++i) _f[i] = _f[i] * _g[i] % mod;\n  idft(_f, limit);\n  std::vector<int> ans(len);\n  for (unsigned int i = 0; i < len; ++i) ans[i] = _f[i];\n  return ans;\n}\nstd::vector<int> mul(const std::vector<int> &a, const std::vector<int> &b,\n                     unsigned int len, bool need = true) {\n  if (a.size() <= 64u || b.size() <= 64u) {\n    memset(_tp, 0, len << 3);\n    unsigned int r = 0;\n    for (unsigned int i = 0; i < a.size(); ++i) {\n      for (unsigned int j = 0; j < b.size() && i + j < len; ++j)\n        _tp[i + j] += 1ULL * a[i] * b[j];\n      if (++r == 18) {\n        r = 0;\n        for (unsigned int j = i - 17; j < len && j < i + b.size(); ++j)\n          _tp[j] %= mod;\n      }\n    }\n    if (r)\n      for (unsigned int j = 0; j < len; ++j) _tp[j] %= mod;\n    std::vector<int> c(len);\n    for (unsigned int i = 0; i < len; ++i) c[i] = _tp[i];\n    return c;\n  }\n  int limit = getlen(len);\n  memset(_f + a.size(), 0, (limit - a.size()) << 3);\n  for (unsigned int i = 0; i < a.size(); ++i) _f[i] = a[i];\n  dft(_f, limit);\n  if (need) {\n    memset(_g + b.size(), 0, (limit - b.size()) << 3);\n    for (unsigned int i = 0; i < b.size(); ++i) _g[i] = b[i];\n    dft(_g, limit);\n  }\n  for (int i = 0; i < limit; ++i) _f[i] = 1ULL * _f[i] * _g[i] % mod;\n  idft(_f, limit);\n  std::vector<int> ans(len);\n  for (unsigned int i = 0; i < len; ++i) ans[i] = _f[i];\n  return ans;\n}\ninline std::vector<int> operator*=(std::vector<int> &a,\n                                   const std::vector<int> &b) {\n  return a = a * b;\n}\ntemplate <typename _Tp>\ninline std::vector<int> operator*=(std::vector<int> &a, const _Tp &b) {\n  for (auto &&it : a) it = 1ULL * it * b % mod;\n  return a;\n}\ntemplate <typename _Tp>\ninline std::vector<int> operator*(std::vector<int> a, const _Tp &b) {\n  return a *= b;\n}\ntemplate <typename _Tp>\ninline std::vector<int> operator*(const _Tp &b, std::vector<int> a) {\n  return a *= b;\n}\ntemplate <typename _Tp>\ninline std::vector<int> operator/=(std::vector<int> &a, const _Tp &b) {\n  unsigned long long inv = ksm(b);\n  for (auto &&it : a) it = 1ULL * it * inv % mod;\n  return a;\n}\ntemplate <typename _Tp>\ninline std::vector<int> operator/(std::vector<int> a, const _Tp &b) {\n  return a /= b;\n}\nint a[N], b[N], c[N];\nlong long fac[N];\nstruct mat {\n  std::vector<int> a[2][2];\n  mat operator*(const mat &o) const {\n    mat ans;\n    for (int i = 0; i < 2; ++i)\n      for (int j = 0; j < 2; ++j)\n        for (int k = 0; k < 2; ++k) ans.a[i][j] += a[i][k] * o.a[k][j];\n    return ans;\n  }\n} M[N];\nmat solve(int l, int r) {\n  if (l == r) return M[l];\n  int mid = (l + r) >> 1;\n  return solve(mid + 1, r) * solve(l, mid);\n}\nint main() {\n  fac[0] = 1;\n  for (int i = 1; i < N; ++i) fac[i] = fac[i - 1] * i % mod;\n  setup();\n  int n;\n  read(n);\n  for (int i = 1; i <= n; ++i) read(a[i]);\n  int m = 0;\n  for (int i = 1; i <= n; i += a[i]) {\n    for (int j = 0; j < a[i]; ++j)\n      if (a[i + j] != a[i]) return puts(\"0\"), 0;\n    b[m++] = a[i];\n  }\n  for (int i = 0; i < m; ++i) {\n    if (i) M[i].a[1][0] = {mod - 2}, M[i].a[1][1] = {mod - 1};\n    if (b[i] == 1)\n      M[i].a[0][0] = {0, 1}, M[i].a[0][1] = {0, 1};\n    else\n      M[i].a[1][0] += {0, 2}, M[i].a[1][1] += {0, 2};\n  }\n  mat ans = solve(0, m - 1);\n  int res = 0;\n  for (int a = 0; a < 2; ++a)\n    for (int i = 0; i < ((int)ans.a[a][1].size()); ++i)\n      add(res, 1LL * ans.a[a][1][i] * fac[i] % mod);\n  printf(\"%d\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= mod) a -= mod;\n  if (a < 0) a += mod;\n}\nint mult(int a, int b) { return a * (long long)b % mod; }\nint bp(int a, int b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) res = mult(res, a);\n    a = mult(a, a);\n    b >>= 1;\n  }\n  return res;\n}\nconst int N = 100007;\nint fact[N];\nstruct Ans {\n  vector<int> g[4];\n};\nclass NTT {\n public:\n  const static int mod = 998244353;\n  const static int root = 646;\n  const static int rev_root = 208611436;\n  const static int root_deg = 1 << 20;\n  const static int MAX_SIZE = 1 << 21;\n  void add(int &a, int b) {\n    a += b;\n    if (a < 0) a += mod;\n    if (a >= mod) a -= mod;\n  }\n  int sum(int a, int b) {\n    add(a, b);\n    return a;\n  }\n  int mult(int a, int b) { return a * (long long)b % mod; }\n  int bp(int a, int n) {\n    int res = 1;\n    while (n) {\n      if (n & 1) res = mult(res, a);\n      a = mult(a, a);\n      n >>= 1;\n    }\n    return res;\n  }\n  int rev(int a) { return bp(a, mod - 2); }\n  int n;\n  int a[MAX_SIZE * 2 + 7], b[MAX_SIZE * 2 + 7];\n  int getReverse(int a, int k) {\n    int ans = 0;\n    for (int i = 0; i < k; i++)\n      if ((a >> i) & 1) ans ^= (1 << (k - i - 1));\n    return ans;\n  }\n  void ntt(int *a, int type) {\n    int k = -1;\n    for (int i = 0; i < 25; i++)\n      if ((n >> i) & 1) {\n        k = i;\n        break;\n      }\n    for (int i = 0; i < n; i++) {\n      int j = getReverse(i, k);\n      if (i < j) swap(a[i], a[j]);\n    }\n    for (int len = 2; len <= n; len *= 2) {\n      int w = bp(root, root_deg / len);\n      if (type == -1) w = bp(rev_root, root_deg / len);\n      for (int i = 0; i < n; i += len) {\n        int g = 1;\n        for (int j = 0; j < len / 2; j++) {\n          int first = a[i + j];\n          int second = mult(a[i + j + len / 2], g);\n          a[i + j] = sum(first, second);\n          a[i + j + len / 2] = sum(first, mod - second);\n          g = mult(g, w);\n        }\n      }\n    }\n    if (type == -1) {\n      int rev_n = rev(n);\n      for (int i = 0; i < n; i++) a[i] = mult(a[i], rev_n);\n    }\n  }\n  vector<int> mult(vector<int> &w1, vector<int> &w2) {\n    n = 1;\n    while (n < w1.size() + w2.size()) n *= 2;\n    std::copy(w1.begin(), w1.end(), a);\n    std::copy(w2.begin(), w2.end(), b);\n    std::fill(a + w1.size(), a + n, 0);\n    std::fill(b + w2.size(), b + n, 0);\n    ntt(a, 1);\n    ntt(b, 1);\n    for (int i = 0; i < n; i++) a[i] = mult(a[i], b[i]);\n    ntt(a, -1);\n    vector<int> ans(n);\n    for (int i = 0; i < n; i++) ans[i] = a[i];\n    while (ans.size() && ans.back() == 0) ans.pop_back();\n    return ans;\n  }\n};\nvector<int> add(vector<int> a, vector<int> b) {\n  vector<int> c(max(a.size(), b.size()), 0);\n  for (int i = 0; i < a.size(); ++i) add(c[i], a[i]);\n  for (int i = 0; i < b.size(); ++i) add(c[i], b[i]);\n  return c;\n}\nNTT fft;\nAns solve(vector<int> &v, int l, int r) {\n  if (l == r) {\n    vector<int> a = {0, (v[l] > 1) + 1};\n    vector<int> b = {0, 2};\n    vector<int> c = {1};\n    vector<int> d = {1};\n    Ans ans;\n    ans.g[0] = a, ans.g[1] = b, ans.g[2] = c, ans.g[3] = d;\n    return ans;\n  }\n  int mid = (l + r) / 2;\n  auto A = solve(v, l, mid), B = solve(v, mid + 1, r);\n  Ans ans;\n  ans.g[0] = add(fft.mult(A.g[0], B.g[0]), fft.mult(A.g[1], B.g[2]));\n  ans.g[1] = add(fft.mult(A.g[0], B.g[1]), fft.mult(A.g[1], B.g[3]));\n  ans.g[2] = add(fft.mult(A.g[2], B.g[0]), fft.mult(A.g[3], B.g[2]));\n  ans.g[3] = add(fft.mult(A.g[2], B.g[1]), fft.mult(A.g[3], B.g[3]));\n  return ans;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  fact[0] = 1;\n  for (int i = 1; i < N; ++i) fact[i] = mult(i, fact[i - 1]);\n  int n;\n  cin >> n;\n  vector<int> v(n);\n  for (auto &first : v) cin >> first;\n  int start = 0;\n  vector<int> arr;\n  while (start < n) {\n    if (start + v[start] > n) {\n      cout << 0;\n      exit(0);\n    }\n    for (int i = 0; i < v[start]; ++i) {\n      if (v[i + start] != v[start]) {\n        cout << 0;\n        exit(0);\n      }\n    }\n    arr.push_back(v[start]);\n    start += v[start];\n  }\n  int ans = 0;\n  auto res = solve(arr, 0, arr.size() - 1).g[0];\n  for (int i = 0; i <= arr.size(); ++i) {\n    int viol = arr.size() - i;\n    if (viol % 2 == 0)\n      add(ans, mult(fact[i], res[i]));\n    else\n      add(ans, -mult(fact[i], res[i]));\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstd::mt19937 rnd(\n    (int)std::chrono::steady_clock::now().time_since_epoch().count());\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nconst int MOD = 998244353;\nconst int PRIMROOT = 3;\nvoid mlt(int& a, int b) { a = (long long)a * b % MOD; }\nint pw(int x, int n) {\n  int ret = 1;\n  while (true) {\n    if (n & 1) mlt(ret, x);\n    if ((n >>= 1) == 0) return ret;\n    mlt(x, x);\n  }\n}\nstruct NTT {\n  void _init(int n, int& nlog, int& g, vector<int>& w) {\n    assert((MOD - 1) % n == 0);\n    g = pw(PRIMROOT, (MOD - 1) / n);\n    nlog = 0;\n    while ((1 << nlog) < n) ++nlog;\n    if ((1 << nlog) != n) nlog = -1;\n    w = vector<int>(n);\n    w[0] = 1;\n    for (int i = (1); i < (n); ++i) w[i] = (long long)w[i - 1] * g % MOD;\n  }\n  int fftn, fftnlog;\n  int fftg;\n  vector<int> fftw;\n  void initfft(int n) {\n    fftn = n, _init(fftn, fftnlog, fftg, fftw);\n    assert(fftnlog != -1);\n  }\n  void fft(int* a, int n, bool inv) {\n    if (n != fftn) initfft(n);\n    for (int i = 1, j = n >> 1, k, l = j; i < n; j ^= k, ++i) {\n      if (i < j) swap(a[i], a[j]);\n      for (k = l; k & j; j ^= k, k >>= 1)\n        ;\n    }\n    int *l, *r, *w;\n    if (inv) reverse(fftw.begin() + 1, fftw.end());\n    for (int hlen = 1, step = n >> 1; hlen < n; hlen <<= 1, step >>= 1) {\n      for (int i = 0; i < n; i += (hlen << 1)) {\n        l = a + i, r = l + hlen, w = fftw.data();\n        for (int off = (0); off < (hlen); ++off) {\n          int v = (long long)(*r) * (*w) % MOD;\n          *r = (*l) - v;\n          if (*r < 0) *r += MOD;\n          *l = (*l) + v;\n          if (*l >= MOD) *l -= MOD;\n          ++l, ++r, w += step;\n        }\n      }\n    }\n    if (inv) reverse(fftw.begin() + 1, fftw.end());\n    if (inv) {\n      int mlt = pw(n, MOD - 2);\n      for (int i = (0); i < (n); ++i) a[i] = (long long)a[i] * mlt % MOD;\n    }\n  }\n  void mult(const int* a, int na, const int* b, int nb, int* c, int nc) {\n    int sz = 1;\n    while (sz < na + nb - 1 || sz < na || sz < nb) sz *= 2;\n    vector<int> A(sz, 0), B(sz, 0);\n    for (int i = (0); i < (na); ++i) A[i] = a[i];\n    for (int i = (0); i < (nb); ++i) B[i] = b[i];\n    fft(A.data(), sz, false);\n    fft(B.data(), sz, false);\n    for (int i = (0); i < (sz); ++i) A[i] = (long long)A[i] * B[i] % MOD;\n    fft(A.data(), sz, true);\n    for (int i = (0); i < (nc); ++i) c[i] = i < sz ? A[i] : 0;\n  }\n  vector<int> mult(const vector<int>& a, const vector<int>& b) {\n    vector<int> c(max(0, ((int)(a).size()) + ((int)(b).size()) - 1));\n    mult(a.data(), ((int)(a).size()), b.data(), ((int)(b).size()), c.data(),\n         ((int)(c).size()));\n    return c;\n  }\n};\nNTT ntt;\nconst int MAXN = 100000;\nvoid inc(int& a, int b) {\n  if ((a += b) >= MOD) a -= MOD;\n}\nvoid dec(int& a, int b) { inc(a, MOD - b); }\nint n;\nint a[MAXN];\nint b[MAXN], nb;\narray<array<vector<int>, 2>, 2> init[2];\narray<array<vector<int>, 2>, 2> trans[2];\nint fac[MAXN + 1];\nvector<int> mlt(const vector<int>& a, const vector<int>& b) {\n  vector<int> c = ntt.mult(a, b);\n  while (((int)(c).size()) >= 1 && c.back() == 0) c.pop_back();\n  return c;\n}\nvoid inc(vector<int>& a, const vector<int>& b) {\n  while (((int)(a).size()) < ((int)(b).size())) a.push_back(0);\n  for (int i = (0); i < (((int)(b).size())); ++i) inc(a[i], b[i]);\n  while (((int)(a).size()) >= 1 && a.back() == 0) a.pop_back();\n}\narray<array<vector<int>, 2>, 2> mlt(const array<array<vector<int>, 2>, 2>& a,\n                                    const array<array<vector<int>, 2>, 2>& b) {\n  array<array<vector<int>, 2>, 2> ret;\n  for (int i = (0); i < (2); ++i)\n    for (int j = (0); j < (2); ++j)\n      for (int k = (0); k < (2); ++k) inc(ret[i][j], mlt(a[i][k], b[k][j]));\n  return ret;\n}\narray<array<vector<int>, 2>, 2> rec(int l, int r) {\n  if (l == r) return trans[b[l]];\n  int m = l + (r - l) / 2;\n  array<array<vector<int>, 2>, 2> lres = rec(l, m);\n  array<array<vector<int>, 2>, 2> rres = rec(m + 1, r);\n  return mlt(lres, rres);\n}\nint solve() {\n  init[0][0][0] = {0, 2};\n  init[1][0][1] = {0, 1};\n  trans[0][0][0] = {1, 2};\n  trans[0][1][0] = {2, 2};\n  trans[1][0][0] = {1};\n  trans[1][0][1] = {0, 1};\n  trans[1][1][0] = {2};\n  trans[1][1][1] = {0, 1};\n  fac[0] = 1;\n  for (int i = (1); i <= (n); ++i) fac[i] = (long long)fac[i - 1] * i % MOD;\n  nb = 0;\n  int at = 0;\n  while (at < n) {\n    int to = at + a[at];\n    if (to > n) return 0;\n    for (int i = (at); i < (to); ++i)\n      if (a[i] != a[at]) return 0;\n    b[nb++] = a[at] != 1 ? 0 : 1;\n    at = to;\n  }\n  if (nb == 1) return b[0] == 0 ? 2 : 1;\n  array<array<vector<int>, 2>, 2> mat = mlt(init[b[0]], rec(1, nb - 1));\n  vector<int> pol;\n  inc(pol, mat[0][0]);\n  inc(pol, mat[0][1]);\n  int ret = 0;\n  for (int i = (0); i < (((int)(pol).size())); ++i) {\n    int sgn = i % 2 == nb % 2 ? +1 : -1;\n    int cur = (long long)fac[i] * pol[i] % MOD;\n    if (sgn == +1)\n      inc(ret, cur);\n    else\n      dec(ret, cur);\n  }\n  return ret;\n}\nvoid run() {\n  scanf(\"%d\", &n);\n  for (int i = (0); i < (n); ++i) scanf(\"%d\", &a[i]);\n  printf(\"%d\\n\", solve());\n}\nint main() {\n  run();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nlong long read() {\n  long long x = 0, f = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') x = x * 10 + (c - '0'), c = getchar();\n  return f * x;\n}\nconst int MAXN = 265011, mod = 998244353, inv2 = (mod + 1) >> 1;\nlong long Qpow(long long a, long long p) {\n  long long res = 1;\n  while (p) {\n    if (p & 1) res = res * a % mod;\n    a = a * a % mod, p >>= 1;\n  }\n  return res;\n}\nvoid Add(int& a, int t) {\n  a += t;\n  if (a >= mod) a -= mod;\n}\ninline int S(int x) { return x < mod ? x : x - mod; }\ninline int D(int x) { return x < 0 ? x + mod : x; }\nnamespace NTT {\nlong long RT[MAXN], invL[MAXN];\nvoid init() {\n  invL[1] = 1;\n  for (int i = 1; i < (1 << 18); i <<= 1) {\n    long long R = Qpow(3, (mod - 1) / (i << 1));\n    RT[i] = 1;\n    for (int j = 1; j < i; ++j) RT[i + j] = RT[i + j - 1] * R % mod;\n    invL[i << 1] = invL[i] * inv2 % mod;\n  }\n}\nint f[MAXN], g[MAXN], status[MAXN];\nvoid DFT(int* a, int len) {\n  for (int i = 0; i < len; ++i)\n    if (status[i] > i) std::swap(a[i], a[status[i]]);\n  for (int cur = 1; cur < len; cur <<= 1)\n    for (int j = 0; j < len; j += cur << 1)\n      for (int k = 0; k < cur; ++k) {\n        int x = a[j + k], y = RT[cur + k] * a[j + cur + k] % mod;\n        a[j + k] = S(x + y), a[j + cur + k] = D(x - y);\n      }\n}\nvoid IDFT(int* a, int len) {\n  std::reverse(a + 1, a + len);\n  DFT(a, len);\n  for (int i = 0; i < len; ++i) a[i] = a[i] * invL[len] % mod;\n}\nvoid Mul(int n) {\n  int len = 1;\n  while (len < n) len <<= 1;\n  for (int i = 0; i < len; ++i)\n    status[i] = (status[i >> 1] >> 1) | ((i & 1) ? len >> 1 : 0);\n  DFT(f, len), DFT(g, len);\n  for (int i = 0; i < len; ++i) f[i] = long long(f[i]) * g[i] % mod, g[i] = 0;\n  IDFT(f, len);\n}\n}  // namespace NTT\nstruct poly : std::vector<int> {\n  poly() { clear(); }\n  poly(int x) { resize(x); }\n  poly operator+(poly you) {\n    poly res = *this;\n    if (res.size() < you.size()) res.resize(you.size());\n    for (int i = 0; i < you.size(); ++i) Add(res[i], you[i]);\n    return res;\n  }\n  poly operator*(poly you) {\n    if (empty() || you.empty()) return poly();\n    int n = size() + you.size() - 1;\n    poly res(n);\n    for (int i = 0; i < size(); ++i) NTT::f[i] = (*this)[i];\n    for (int i = 0; i < you.size(); ++i) NTT::g[i] = you[i];\n    NTT::Mul(n);\n    for (int i = 0; i < n; ++i) res[i] = NTT::f[i], NTT::f[i] = 0;\n    return res;\n  }\n};\nstruct Matrix {\n  poly a[4];\n  Matrix() {}\n  Matrix(poly* b) { a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3]; }\n  Matrix operator*(Matrix you) {\n    poly tp[4];\n    tp[0] = (a[0] * you.a[0] + a[1] * you.a[2]);\n    tp[1] = (a[0] * you.a[1] + a[1] * you.a[3]);\n    tp[2] = (a[2] * you.a[0] + a[3] * you.a[2]);\n    tp[3] = (a[2] * you.a[1] + a[3] * you.a[3]);\n    return Matrix(tp);\n  }\n} mat[MAXN];\nint a[MAXN];\nlong long fac[MAXN];\nMatrix merge(int l, int r) {\n  if (l == r) return mat[l];\n  int mid = (l + r) >> 1;\n  return merge(l, mid) * merge(mid + 1, r);\n}\nint main() {\n  NTT::init();\n  int n = read();\n  fac[0] = 1;\n  for (int i = 1; i <= n; ++i) fac[i] = fac[i - 1] * i % mod;\n  for (int i = 1; i <= n; ++i) a[i] = read();\n  int cur = 0;\n  for (int i = 1, j; i <= n; i = j) {\n    j = i + 1;\n    while (j - i + 1 <= a[i] && a[j] == a[i]) ++j;\n    if (j - i < a[i]) {\n      puts(\"0\");\n      return 0;\n    }\n    ++cur;\n    if (cur == 1) {\n      if (a[i] == 1)\n        mat[1].a[0].push_back(0), mat[1].a[0].push_back(1);\n      else\n        mat[1].a[1].push_back(0), mat[1].a[1].push_back(2);\n    } else {\n      if (a[i] == 1) {\n        mat[cur].a[0].push_back(0), mat[cur].a[0].push_back(1);\n        mat[cur].a[1].push_back(2);\n        mat[cur].a[2] = mat[cur].a[0];\n        mat[cur].a[3].push_back(1);\n      } else {\n        mat[cur].a[1].push_back(2), mat[cur].a[1].push_back(2);\n        mat[cur].a[3].push_back(1), mat[cur].a[3].push_back(2);\n      }\n    }\n  }\n  if (cur > 1) mat[1] = mat[1] * merge(2, cur);\n  poly res = (mat[1].a[0] + mat[1].a[1]);\n  res.resize(cur + 1);\n  long long ans = 0;\n  for (int i = 1; i <= cur; ++i) {\n    if ((cur - i) & 1)\n      ans = (ans - fac[i] * (res[i])) % mod;\n    else\n      ans = (ans + fac[i] * (res[i])) % mod;\n  }\n  printf(\"%lld\\n\", (ans + mod) % mod);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 262144;\nconst int mod = 998244353, G = 3;\nconst int inv2 = mod + 1 >> 1;\nint min(const int a, const int b) { return a < b ? a : b; }\nint max(const int a, const int b) { return a > b ? a : b; }\nvoid bmod(int& x) { x += x >> 31 & mod; }\nint norm(const int x) { return x < 0 ? x + mod : x; }\nvoid swap(int& a, int& b) { a ^= b ^= a ^= b; }\nvoid reverse(int* st, int* ed) {\n  while (st < --ed) swap(*st++, *ed);\n}\nint inv(int x, int k = mod - 2) {\n  int r = 1;\n  while (k) {\n    if (k & 1) r = (long long)x * r % mod;\n    x = (long long)x * x % mod;\n    k >>= 1;\n  }\n  return r;\n}\nint f[N], g[N];\nint lim, last = -1, rev[N], rt[N];\nvoid prework(int n) {\n  if (n == last) return;\n  last = n, lim = 1;\n  while (lim <= n) lim <<= 1;\n  for (int i = 0; i < lim; ++i) {\n    rev[i] = rev[i >> 1] >> 1 | (i & 1 ? lim >> 1 : 0);\n  }\n  for (int k = 2, i; k <= lim; k <<= 1) {\n    rt[i = k >> 1] = 1;\n    long long v = inv(G, (mod - 1) / k);\n    for (int j = i + 1; j < k; ++j) {\n      rt[j] = rt[j - 1] * v % mod;\n    }\n  }\n}\nvoid NTT(int* f, bool flag = true) {\n  if (!flag) reverse(f + 1, f + lim);\n  int x, *bf, i, j, k, len;\n  for (i = 0; i < lim; ++i) {\n    if (i < rev[i]) {\n      swap(f[i], f[rev[i]]);\n    }\n  }\n  for (k = 2; k <= lim; k <<= 1) {\n    for (len = k >> 1, i = 0; i < lim; i += k) {\n      for (j = i, bf = rt + len; j < i + len; ++j, ++bf) {\n        x = (long long)f[len + j] * *bf % mod;\n        bmod(f[len + j] = f[j] - x);\n        bmod(f[j] += x - mod);\n      }\n    }\n  }\n  if (flag) return;\n  long long v = inv(lim);\n  for (i = 0; i < lim; ++i) {\n    f[i] = f[i] * v % mod;\n  }\n}\nstruct Poly : std::vector<int> {\n  Poly() { clear(); }\n  Poly(int sz) { resize(sz); }\n};\nPoly operator+(const Poly& a, const Poly& b) {\n  static Poly c;\n  c.resize(max(a.size(), b.size()));\n  for (int i = 0; i < a.size() || i < b.size(); ++i) {\n    bmod(c[i] = (i < a.size() ? a[i] : 0) + (i < b.size() ? b[i] : 0) - mod);\n  }\n  return c;\n}\nPoly operator*(const Poly& a, const Poly& b) {\n  static Poly c;\n  if (!a.size() || !b.size()) return Poly();\n  c.resize(a.size() + b.size() - 1);\n  for (int i = 0; i < a.size(); ++i) f[i] = a[i];\n  for (int i = 0; i < b.size(); ++i) g[i] = b[i];\n  prework(c.size());\n  NTT(f), NTT(g);\n  for (int i = 0; i < lim; ++i) {\n    f[i] = (long long)f[i] * g[i] % mod;\n  }\n  NTT(f, false);\n  for (int i = 0; i < c.size(); ++i) c[i] = f[i];\n  memset(f, 0, lim << 2);\n  memset(g, 0, lim << 2);\n  return c;\n}\nstruct Matrix {\n  Poly a[4];\n  Matrix(){};\n  Matrix(Poly b[]) {\n    a[0] = b[0];\n    a[1] = b[1];\n    a[2] = b[2];\n    a[3] = b[3];\n  }\n  Poly& operator[](const int x) { return a[x]; }\n  Poly operator[](const int x) const { return a[x]; }\n} mat[N];\nMatrix operator*(const Matrix& a, const Matrix& b) {\n  static Matrix c;\n  c[0] = a[0] * b[0] + a[1] * b[2];\n  c[1] = a[0] * b[1] + a[1] * b[3];\n  c[2] = a[2] * b[0] + a[3] * b[2];\n  c[3] = a[2] * b[1] + a[3] * b[3];\n  return c;\n}\nMatrix calc(int l, int r) {\n  if (l == r) return mat[r];\n  int mid = l + r >> 1;\n  return calc(l, mid) * calc(mid + 1, r);\n}\nint n, a[N];\nint fact[N];\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d\", a + i);\n  }\n  fact[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    fact[i] = (long long)fact[i - 1] * i % mod;\n  }\n  int k = 0;\n  for (int i = 1, j; i <= n;) {\n    j = i;\n    while (j - i + 1 <= a[i] && a[j] == a[i]) ++j;\n    if (j - i < a[i]) return puts(\"0\"), 0;\n    if (++k == 1) {\n      if (a[i] == 1) {\n        mat[1][0].push_back(0), mat[1][0].push_back(1);\n      } else {\n        mat[1][1].push_back(0), mat[1][1].push_back(2);\n      }\n    } else {\n      if (a[i] == 1) {\n        mat[k][0].push_back(0), mat[k][0].push_back(1);\n        mat[k][1].push_back(2);\n        mat[k][2] = mat[k][0];\n        mat[k][3].push_back(1);\n      } else {\n        mat[k][1].push_back(2), mat[k][1].push_back(2);\n        mat[k][3].push_back(1), mat[k][3].push_back(2);\n      }\n    }\n    i = j;\n  }\n  if (k > 1) mat[1] = mat[1] * calc(2, k);\n  Poly res = mat[1][0] + mat[1][1];\n  res.resize(k + 1);\n  int ans = 0;\n  for (int i = 1; i <= k; ++i) {\n    if (k - i & 1) {\n      ans = (ans - (long long)fact[i] * res[i]) % mod;\n    } else {\n      ans = (ans + (long long)fact[i] * res[i]) % mod;\n    }\n  }\n  printf(\"%d\\n\", norm(ans));\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline long long read() {\n  long long x = 0, f = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    x = (x << 1) + (x << 3) + c - '0';\n    c = getchar();\n  }\n  return x * f;\n}\nint n, a[266666], c[266666], dp[2][2][266666], fac[266666];\nconst int mod = 998244353;\nint qpow(int a, int b) {\n  int ans = 1;\n  while (b) {\n    if (b & 1) ans = 1LL * ans * a % mod;\n    a = 1LL * a * a % mod;\n    b >>= 1;\n  }\n  return ans;\n}\nnamespace Poly {\nconst int G = 3;\nconst int invG = qpow(G, mod - 2);\nint tr[266666], GG[2][21][266666], inv[266666];\nvoid Init(const int t) {\n  for (int p = 1; p <= t; ++p) {\n    int buf1 = qpow(G, (mod - 1) / (1 << p));\n    int buf0 = qpow(invG, (mod - 1) / (1 << p));\n    GG[0][p][0] = GG[1][p][0] = 1;\n    for (int i = 1; i < (1 << p); ++i) {\n      GG[0][p][i] = 1LL * GG[0][p][i - 1] * buf0 % mod;\n      GG[1][p][i] = 1LL * GG[1][p][i - 1] * buf1 % mod;\n    }\n  }\n  inv[1] = 1;\n  for (int i = 2; i <= (1 << t); ++i) {\n    inv[i] = 1LL * inv[mod % i] * (mod - mod / i) % mod;\n  }\n}\nint NTT_init(int n) {\n  int lim = 1;\n  while (lim < n) lim <<= 1;\n  for (int i = 0; i < lim; ++i) {\n    tr[i] = ((tr[i >> 1] >> 1) | (i & 1 ? lim >> 1 : 0));\n  }\n  return lim;\n}\nvoid NTT(vector<int> &f, int flag, int n) {\n  f.resize(n);\n  for (int i = 0; i < n; ++i) {\n    if (i < tr[i]) swap(f[i], f[tr[i]]);\n  }\n  for (int p = 2, j = 1; p <= n; p <<= 1, ++j) {\n    int len = p >> 1;\n    for (int k = 0; k < n; k += p) {\n      int *buf = GG[flag][j];\n      for (int i = k; i < k + len; ++i, ++buf) {\n        int tmp = 1LL * (*buf) * f[i + len] % mod;\n        f[i + len] = (f[i] - tmp + mod >= mod ? f[i] - tmp + mod - mod\n                                              : f[i] - tmp + mod);\n        f[i] = (f[i] + tmp >= mod ? f[i] + tmp - mod : f[i] + tmp);\n      }\n    }\n  }\n  if (!flag) {\n    for (int i = 0; i < n; ++i) {\n      f[i] = 1LL * f[i] * inv[n] % mod;\n    }\n  }\n}\nvector<int> Rshift(vector<int> A, int x) {\n  A.resize(A.size() + x);\n  for (int i = (int)A.size() - 1; i >= x; --i) {\n    A[i] = A[i - x];\n  }\n  for (int i = 0; i < x; ++i) A[i] = 0;\n  return A;\n}\nvector<int> Lshift(vector<int> A, int x) {\n  if ((int)A.size() <= x) return vector<int>(1, 0);\n  for (int i = 0; i < (int)A.size() - x; ++i) {\n    A[i] = A[i + x];\n  }\n  return A;\n}\nvector<int> Plus(vector<int> A, vector<int> B) {\n  int n = max(A.size(), B.size());\n  A.resize(n), B.resize(n);\n  for (int i = 0; i < n; ++i) {\n    A[i] = (A[i] + B[i]) % mod;\n  }\n  return A;\n}\nvector<int> Mul(vector<int> A, vector<int> B) {\n  int n = A.size() + B.size() - 1;\n  int lim = NTT_init(n);\n  vector<int> C(lim);\n  NTT(A, 1, lim), NTT(B, 1, lim);\n  for (int i = 0; i < lim; ++i) {\n    C[i] = 1LL * A[i] * B[i] % mod;\n  }\n  NTT(C, 0, lim);\n  C.resize(n);\n  return C;\n}\nvector<int> Inv(vector<int> &f, int m) {\n  if (m == 1) {\n    return vector<int>(1, qpow(f[0], mod - 2));\n  }\n  vector<int> A(f.begin(), f.begin() + m);\n  vector<int> B = Inv(f, (m + 1) >> 1);\n  int lim = NTT_init(m << 1);\n  NTT(A, 1, lim), NTT(B, 1, lim);\n  for (int i = 0; i < lim; ++i) {\n    A[i] = B[i] * (2 - 1LL * A[i] * B[i] % mod + mod) % mod;\n  }\n  NTT(A, 0, lim);\n  A.resize(m);\n  return A;\n}\nvector<int> WeiF(vector<int> f) {\n  int n = f.size();\n  if (n == 1) return f[0] = 0, f;\n  for (int i = 1; i < n; ++i) f[i - 1] = 1LL * f[i] * i % mod;\n  return f.resize(n - 1), f;\n}\nvector<int> JiF(vector<int> f) {\n  int n = f.size();\n  for (int i = n - 1; i; --i) f[i] = 1LL * f[i - 1] * inv[i] % mod;\n  return f[0] = 0, f;\n}\nvector<int> Ln(vector<int> f, int n) {\n  f.resize(n);\n  vector<int> A = JiF(Mul(WeiF(f), Inv(f, n)));\n  return A.resize(n), A;\n}\nvector<int> Exp(vector<int> &f, int m) {\n  if (m == 1) {\n    return vector<int>(1, 1);\n  }\n  vector<int> B = Exp(f, (m + 1) >> 1);\n  vector<int> lnB = Ln(B, m);\n  for (int i = 0; i < m; ++i) {\n    lnB[i] = (f[i] - lnB[i] + mod >= mod ? f[i] - lnB[i] + mod - mod\n                                         : f[i] - lnB[i] + mod);\n  }\n  int lim = NTT_init(m << 1);\n  NTT(B, 1, lim), NTT(lnB, 1, lim);\n  for (int i = 0; i < lim; ++i) {\n    B[i] = 1LL * B[i] * (1 + lnB[i]) % mod;\n  }\n  NTT(B, 0, lim);\n  B.resize(m);\n  return B;\n}\nvector<int> Sqrt(vector<int> &f, int m) {\n  if (m == 1) {\n    return vector<int>(1, 1);\n  }\n  vector<int> A(f.begin(), f.begin() + m);\n  vector<int> B = Sqrt(f, (m + 1) >> 1);\n  vector<int> iB = Inv(B, m);\n  int lim = NTT_init(m << 1);\n  NTT(A, 1, lim), NTT(iB, 1, lim);\n  for (int i = 0; i < lim; ++i) {\n    A[i] = 1LL * A[i] * iB[i] % mod;\n  }\n  NTT(A, 0, lim);\n  for (int i = 0; i < m; ++i) {\n    A[i] = 1LL * (A[i] + B[i]) * inv[2] % mod;\n  }\n  A.resize(m);\n  return A;\n}\nvector<int> Pow(vector<int> f, int k) {\n  f = Ln(f, f.size());\n  for (auto &x : f) x = 1LL * x * k % mod;\n  return Exp(f, f.size());\n}\nvector<int> MulT(vector<int> A, vector<int> &B, int n) {\n  int lim = A.size();\n  NTT_init(lim);\n  for (int i = 0; i < lim; ++i) {\n    A[i] = 1LL * A[i] * B[i] % mod;\n  }\n  NTT(A, 1, lim);\n  A.resize(n);\n  return A;\n}\nvector<int> nd[266666 << 2];\nvoid build(int u, int l, int r, vector<int> &f) {\n  if (l + 1 == r) {\n    nd[u] = vector<int>({1, mod - f[l]});\n    return;\n  }\n  int mid = (l + r + 1) >> 1;\n  build(u << 1, l, mid, f), build(u << 1 | 1, mid, r, f);\n  int lim = NTT_init(r - l + 1);\n  NTT(nd[u << 1], 1, lim), NTT(nd[u << 1 | 1], 1, lim);\n  nd[u].resize(lim);\n  for (int i = 0; i < lim; ++i) {\n    nd[u][i] = 1LL * nd[u << 1][i] * nd[u << 1 | 1][i] % mod;\n  }\n  NTT(nd[u], 0, lim);\n}\nvoid work(int u, int l, int r, vector<int> f, vector<int> &g) {\n  if (l + 1 == r) {\n    g[l] = f[0];\n    return;\n  }\n  int mid = (l + r + 1) >> 1;\n  int lim = NTT_init(r - l + 1);\n  NTT(f, 0, lim);\n  work(u << 1, l, mid, MulT(f, nd[u << 1 | 1], mid - l), g);\n  work(u << 1 | 1, mid, r, MulT(f, nd[u << 1], r - mid), g);\n}\nvector<int> Evaluate(vector<int> f, vector<int> x) {\n  int n = f.size(), m = x.size();\n  n = max(n, m);\n  f.resize(n), x.resize(n);\n  build(1, 0, n, x);\n  nd[1] = Inv(nd[1], n);\n  int lim = NTT_init(2 * n - 1);\n  NTT(nd[1], 1, lim);\n  NTT(f, 0, lim);\n  vector<int> g(n);\n  work(1, 0, n, MulT(f, nd[1], n), g);\n  g.resize(m);\n  return g;\n}\n}  // namespace Poly\nusing Poly::Mul;\nusing Poly::Plus;\nusing Poly::vector<int>;\nstruct Matrix {\n  vector<int> g[2][2];\n  friend Matrix operator*(const Matrix &a, const Matrix &b) {\n    Matrix c;\n    for (int i = 0; i < 2; ++i) {\n      for (int j = 0; j < 2; ++j) {\n        c.g[i][j] = Plus(Mul(a.g[i][0], b.g[0][j]), Mul(a.g[i][1], b.g[1][j]));\n      }\n    }\n    return c;\n  }\n};\nMatrix Solve(int L, int R) {\n  Matrix ans;\n  if (L == R) {\n    if (a[L] == 1) {\n      ans.g[0][0] = ans.g[1][0] = vector<int>({0, 1});\n      ans.g[0][1] = vector<int>({2}), ans.g[1][1] = vector<int>({1});\n    } else {\n      ans.g[0][0] = ans.g[1][0] = vector<int>({0});\n      ans.g[0][1] = vector<int>({2, 2}), ans.g[1][1] = vector<int>({1, 2});\n    }\n    return ans;\n  }\n  int mid = (L + R) >> 1;\n  ans = Solve(L, mid) * Solve(mid + 1, R);\n  return ans;\n}\nint main() {\n  Poly::Init(18);\n  n = read();\n  fac[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    c[i] = read();\n    fac[i] = 1LL * fac[i - 1] * i % mod;\n  }\n  int _n = 0;\n  for (int i = 1; i <= n;) {\n    a[++_n] = c[i];\n    if (i + c[i] > n + 1) {\n      return !printf(\"0\\n\");\n    }\n    int x = c[i], tmp = c[i];\n    while (x--) {\n      if (c[i++] ^ tmp) {\n        return !printf(\"0\\n\");\n      }\n    }\n  }\n  n = _n;\n  Matrix A;\n  if (a[1] == 1)\n    A.g[0][0] = vector<int>({0, 1});\n  else\n    A.g[0][1] = vector<int>({0, 2});\n  if (n > 1) A = A * Solve(2, n);\n  A.g[0][0].resize(n + 1);\n  A.g[0][1].resize(n + 1);\n  int ans = 0;\n  for (int i = 1; i <= n; ++i) {\n    ans = (ans + 1LL * ((n - i) & 1 ? mod - fac[i] : fac[i]) *\n                     (A.g[0][0][i] + A.g[0][1][i])) %\n          mod;\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\nstring to_string(const string& s) { return '\"' + s + '\"'; }\nstring to_string(const char* s) { return to_string((string)s); }\nstring to_string(bool b) { return (b ? \"true\" : \"false\"); }\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto& x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" +\n         to_string(get<2>(p)) + \")\";\n}\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" +\n         to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a;\n    swap(a, m);\n    u -= t * v;\n    swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod())\n      v = static_cast<Type>(x);\n    else\n      v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const {\n    return static_cast<U>(value);\n  }\n  constexpr static Type mod() { return T::value; }\n  Modular& operator+=(const Modular& other) {\n    if ((value += other.value) >= mod()) value -= mod();\n    return *this;\n  }\n  Modular& operator-=(const Modular& other) {\n    if ((value -= other.value) < 0) value += mod();\n    return *this;\n  }\n  template <typename U>\n  Modular& operator+=(const U& other) {\n    return *this += Modular(other);\n  }\n  template <typename U>\n  Modular& operator-=(const U& other) {\n    return *this -= Modular(other);\n  }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) {\n    Modular result(*this);\n    *this += 1;\n    return result;\n  }\n  Modular operator--(int) {\n    Modular result(*this);\n    *this -= 1;\n    return result;\n  }\n  Modular operator-() const { return Modular(-value); }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value,\n                     Modular>::type&\n  operator*=(const Modular& rhs) {\n    value = normalize(static_cast<int64_t>(value) *\n                      static_cast<int64_t>(rhs.value));\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value,\n                     Modular>::type&\n  operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) *\n                                         rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value,\n                     Modular>::type&\n  operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n  Modular& operator/=(const Modular& other) {\n    return *this *= Modular(inverse(other.value, mod()));\n  }\n  friend const Type& abs(const Modular& x) { return x.value; }\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\ntemplate <typename T>\nbool operator==(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return lhs.value == rhs.value;\n}\ntemplate <typename T, typename U>\nbool operator==(const Modular<T>& lhs, U rhs) {\n  return lhs == Modular<T>(rhs);\n}\ntemplate <typename T, typename U>\nbool operator==(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) == rhs;\n}\ntemplate <typename T>\nbool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T, typename U>\nbool operator!=(const Modular<T>& lhs, U rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T, typename U>\nbool operator!=(U lhs, const Modular<T>& rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T>\nbool operator<(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return lhs.value < rhs.value;\n}\ntemplate <typename T>\nModular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator+(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator+(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T>\nModular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator-(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator-(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T>\nModular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator*(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator*(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T>\nModular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator/(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator/(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\nvector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int)fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int)fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}\ntemplate <typename T>\nclass NTT {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n  static Type md;\n  static Modular<T> root;\n  static int base;\n  static int max_base;\n  static vector<Modular<T>> roots;\n  static vector<int> rev;\n  static void clear() {\n    root = 0;\n    base = 0;\n    max_base = 0;\n    roots.clear();\n    rev.clear();\n  }\n  static void init() {\n    md = T::value;\n    assert(md >= 3 && md % 2 == 1);\n    auto tmp = md - 1;\n    max_base = 0;\n    while (tmp % 2 == 0) {\n      tmp /= 2;\n      max_base++;\n    }\n    root = 2;\n    while (power(root, (md - 1) >> 1) == 1) {\n      root++;\n    }\n    assert(power(root, md - 1) == 1);\n    root = power(root, (md - 1) >> max_base);\n    base = 1;\n    rev = {0, 1};\n    roots = {0, 1};\n  }\n  static void ensure_base(int nbase) {\n    if (md != T::value) {\n      clear();\n    }\n    if (roots.empty()) {\n      init();\n    }\n    if (nbase <= base) {\n      return;\n    }\n    assert(nbase <= max_base);\n    rev.resize(1 << nbase);\n    for (int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    roots.resize(1 << nbase);\n    while (base < nbase) {\n      Modular<T> z = power(root, 1 << (max_base - 1 - base));\n      for (int i = 1 << (base - 1); i < (1 << base); i++) {\n        roots[i << 1] = roots[i];\n        roots[(i << 1) + 1] = roots[i] * z;\n      }\n      base++;\n    }\n  }\n  static void fft(vector<Modular<T>>& a) {\n    int n = (int)a.size();\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for (int i = 0; i < n; i++) {\n      if (i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for (int k = 1; k < n; k <<= 1) {\n      for (int i = 0; i < n; i += 2 * k) {\n        for (int j = 0; j < k; j++) {\n          Modular<T> x = a[i + j];\n          Modular<T> y = a[i + j + k] * roots[j + k];\n          a[i + j] = x + y;\n          a[i + j + k] = x - y;\n        }\n      }\n    }\n  }\n  static vector<Modular<T>> multiply(vector<Modular<T>> a,\n                                     vector<Modular<T>> b) {\n    if (a.empty() || b.empty()) {\n      return {};\n    }\n    int eq = (a == b);\n    int need = (int)a.size() + (int)b.size() - 1;\n    int nbase = 0;\n    while ((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz);\n    b.resize(sz);\n    fft(a);\n    if (eq)\n      b = a;\n    else\n      fft(b);\n    Modular<T> inv_sz = 1 / static_cast<Modular<T>>(sz);\n    for (int i = 0; i < sz; i++) {\n      a[i] *= b[i] * inv_sz;\n    }\n    reverse(a.begin() + 1, a.end());\n    fft(a);\n    a.resize(need);\n    return a;\n  }\n};\ntemplate <typename T>\ntypename NTT<T>::Type NTT<T>::md;\ntemplate <typename T>\nModular<T> NTT<T>::root;\ntemplate <typename T>\nint NTT<T>::base;\ntemplate <typename T>\nint NTT<T>::max_base;\ntemplate <typename T>\nvector<Modular<T>> NTT<T>::roots;\ntemplate <typename T>\nvector<int> NTT<T>::rev;\ntemplate <typename T>\nvector<Modular<T>> inverse(const vector<Modular<T>>& a) {\n  assert(!a.empty());\n  int n = (int)a.size();\n  vector<Modular<T>> b = {1 / a[0]};\n  while ((int)b.size() < n) {\n    vector<Modular<T>> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    x.resize(b.size() << 1);\n    b.resize(b.size() << 1);\n    vector<Modular<T>> c = b;\n    NTT<T>::fft(c);\n    NTT<T>::fft(x);\n    Modular<T> inv = 1 / static_cast<Modular<T>>((int)x.size());\n    for (int i = 0; i < (int)x.size(); i++) {\n      x[i] *= c[i] * inv;\n    }\n    reverse(x.begin() + 1, x.end());\n    NTT<T>::fft(x);\n    rotate(x.begin(), x.begin() + (x.size() >> 1), x.end());\n    fill(x.begin() + (x.size() >> 1), x.end(), 0);\n    NTT<T>::fft(x);\n    for (int i = 0; i < (int)x.size(); i++) {\n      x[i] *= c[i] * inv;\n    }\n    reverse(x.begin() + 1, x.end());\n    NTT<T>::fft(x);\n    for (int i = 0; i < ((int)x.size() >> 1); i++) {\n      b[i + ((int)x.size() >> 1)] = -x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\ntemplate <typename T>\nvector<Modular<T>> inverse_old(vector<Modular<T>> a) {\n  assert(!a.empty());\n  int n = (int)a.size();\n  if (n == 1) {\n    return {1 / a[0]};\n  }\n  int m = (n + 1) >> 1;\n  vector<Modular<T>> b = inverse(vector<Modular<T>>(a.begin(), a.begin() + m));\n  int need = n << 1;\n  int nbase = 0;\n  while ((1 << nbase) < need) {\n    ++nbase;\n  }\n  NTT<T>::ensure_base(nbase);\n  int size = 1 << nbase;\n  a.resize(size);\n  b.resize(size);\n  NTT<T>::fft(a);\n  NTT<T>::fft(b);\n  Modular<T> inv = 1 / static_cast<Modular<T>>(size);\n  for (int i = 0; i < size; ++i) {\n    a[i] = (2 - a[i] * b[i]) * b[i] * inv;\n  }\n  reverse(a.begin() + 1, a.end());\n  NTT<T>::fft(a);\n  a.resize(n);\n  return a;\n}\ntemplate <typename T>\nvector<Modular<T>> operator*(const vector<Modular<T>>& a,\n                             const vector<Modular<T>>& b) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  if (min(a.size(), b.size()) < 150) {\n    vector<Modular<T>> c(a.size() + b.size() - 1, 0);\n    for (int i = 0; i < (int)a.size(); i++) {\n      for (int j = 0; j < (int)b.size(); j++) {\n        c[i + j] += a[i] * b[j];\n      }\n    }\n    return c;\n  }\n  return NTT<T>::multiply(a, b);\n}\ntemplate <typename T>\nvector<Modular<T>>& operator*=(vector<Modular<T>>& a,\n                               const vector<Modular<T>>& b) {\n  return a = a * b;\n}\ntemplate <typename T>\nvector<T>& operator+=(vector<T>& a, const vector<T>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int)b.size(); i++) {\n    a[i] += b[i];\n  }\n  return a;\n}\ntemplate <typename T>\nvector<T> operator+(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c += b;\n}\ntemplate <typename T>\nvector<T>& operator-=(vector<T>& a, const vector<T>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int)b.size(); i++) {\n    a[i] -= b[i];\n  }\n  return a;\n}\ntemplate <typename T>\nvector<T> operator-(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c -= b;\n}\ntemplate <typename T>\nvector<T> operator-(const vector<T>& a) {\n  vector<T> c = a;\n  for (int i = 0; i < (int)c.size(); i++) {\n    c[i] = -c[i];\n  }\n  return c;\n}\ntemplate <typename T>\nvector<T> operator*(const vector<T>& a, const vector<T>& b) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  vector<T> c(a.size() + b.size() - 1, 0);\n  for (int i = 0; i < (int)a.size(); i++) {\n    for (int j = 0; j < (int)b.size(); j++) {\n      c[i + j] += a[i] * b[j];\n    }\n  }\n  return c;\n}\ntemplate <typename T>\nvector<T>& operator*=(vector<T>& a, const vector<T>& b) {\n  return a = a * b;\n}\ntemplate <typename T>\nvector<T> inverse(const vector<T>& a) {\n  assert(!a.empty());\n  int n = (int)a.size();\n  vector<T> b = {1 / a[0]};\n  while ((int)b.size() < n) {\n    vector<T> a_cut(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    vector<T> x = b * b * a_cut;\n    b.resize(b.size() << 1);\n    for (int i = (int)b.size() >> 1; i < (int)min(x.size(), b.size()); i++) {\n      b[i] = -x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\ntemplate <typename T>\nvector<T>& operator/=(vector<T>& a, const vector<T>& b) {\n  int n = (int)a.size();\n  int m = (int)b.size();\n  if (n < m) {\n    a.clear();\n  } else {\n    vector<T> d = b;\n    reverse(a.begin(), a.end());\n    reverse(d.begin(), d.end());\n    d.resize(n - m + 1);\n    a *= inverse(d);\n    a.erase(a.begin() + n - m + 1, a.end());\n    reverse(a.begin(), a.end());\n  }\n  return a;\n}\ntemplate <typename T>\nvector<T> operator/(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c /= b;\n}\ntemplate <typename T>\nvector<T>& operator%=(vector<T>& a, const vector<T>& b) {\n  int n = (int)a.size();\n  int m = (int)b.size();\n  if (n >= m) {\n    vector<T> c = (a / b) * b;\n    a.resize(m - 1);\n    for (int i = 0; i < m - 1; i++) {\n      a[i] -= c[i];\n    }\n  }\n  return a;\n}\ntemplate <typename T>\nvector<T> operator%(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c %= b;\n}\ntemplate <typename T, typename U>\nvector<T> power(const vector<T>& a, const U& b, const vector<T>& c) {\n  assert(b >= 0);\n  vector<U> binary;\n  U bb = b;\n  while (bb > 0) {\n    binary.push_back(bb & 1);\n    bb >>= 1;\n  }\n  vector<T> res = vector<T>{1} % c;\n  for (int j = (int)binary.size() - 1; j >= 0; j--) {\n    res = res * res % c;\n    if (binary[j] == 1) {\n      res = res * a % c;\n    }\n  }\n  return res;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> init(n);\n  for (int i = 0; i < n; i++) {\n    cin >> init[i];\n  }\n  vector<int> a;\n  int beg = 0;\n  while (beg < n) {\n    int len = init[beg];\n    if (beg + len > n) {\n      cout << 0 << '\\n';\n      return 0;\n    }\n    for (int i = beg; i < beg + len; i++) {\n      if (init[i] != len) {\n        cout << 0 << '\\n';\n        return 0;\n      }\n    }\n    a.push_back(len);\n    beg += len;\n  }\n  function<vector<vector<Mint>>(int, int)> Solve = [&](int L, int R) {\n    if (R - L == 1) {\n      vector<vector<Mint>> ret(4);\n      if (a[L] > 1) {\n        ret[0] = vector<Mint>{1};\n        ret[1] = vector<Mint>{0, 2};\n        ret[2] = vector<Mint>{1};\n        ret[3] = vector<Mint>{0, 2};\n      } else {\n        ret[0] = vector<Mint>{1};\n        ret[1] = vector<Mint>{0, 2};\n        ret[2] = vector<Mint>{1};\n        ret[3] = vector<Mint>{0, 1};\n      }\n      return ret;\n    }\n    int M = (L + R) >> 1;\n    auto x = Solve(L, M);\n    auto y = Solve(M, R);\n    vector<vector<Mint>> ret(4);\n    ret[0] = x[0] * y[0] + x[1] * y[2];\n    ret[1] = x[0] * y[1] + x[1] * y[3];\n    ret[2] = x[2] * y[0] + x[3] * y[2];\n    ret[3] = x[3] * y[3] + x[2] * y[1];\n    return ret;\n  };\n  auto ret = Solve(0, (int)a.size());\n  auto p1 = ret[3];\n  C(n, 0);\n  Mint ans = 0;\n  for (int k = 1; k < (int)p1.size(); k++) {\n    ans += p1[k] * fact[k] * (k % 2 == (int)p1.size() % 2 ? -1 : 1);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nbool chkmax(T &x, T y) {\n  return x < y ? x = y, true : false;\n}\ntemplate <typename T>\nbool chkmin(T &x, T y) {\n  return x > y ? x = y, true : false;\n}\nint readint() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return x * f;\n}\nconst int cys = 998244353;\nint n, m;\nint a[100005], b[100005], d[2][100005];\nint mod(int x) { return x >= cys ? x - cys : x; }\nvoid add(int &x, int y) { x = mod(x + y); }\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  bool fl = 0;\n  for (int i = 1; i <= n; i++) {\n    for (int j = i; j <= i + a[i] - 1; j++)\n      if (a[j] != a[i]) fl = 1;\n    i += a[i] - 1;\n    b[++m] = a[i] > 1;\n  }\n  if (fl) return printf(\"0\\n\"), 0;\n  d[b[1]][0] = 1;\n  for (int i = 1; i < m; i++) {\n    if (b[i + 1]) {\n      for (int j = i - 1; j >= 0; j--) {\n        add(d[1][j + 1], mod(d[1][j] << 1));\n        add(d[1][j + 1], d[0][j]);\n        add(d[1][j], d[0][j]);\n        d[0][j] = 0;\n      }\n    } else {\n      for (int j = i - 1; j >= 0; j--) {\n        add(d[0][j + 1], mod(d[1][j] << 1));\n        add(d[0][j + 1], d[0][j]);\n        add(d[1][j], d[0][j]);\n        d[0][j] = 0;\n      }\n    }\n  }\n  long long ans = 0, now = 1;\n  for (int i = 1; i <= m; i++) {\n    now = now * i % cys;\n    long long tmp = (d[0][i - 1] + 2ll * d[1][i - 1]) % cys * now % cys;\n    if ((m - i) & 1)\n      ans = mod(ans + cys - tmp);\n    else\n      ans = mod(ans + tmp);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int FFTN = 1 << 17;\nconst int N = 1 << 17 | 5;\nconst int mo = 998244353;\nint power(int x, int y) {\n  int s = 1;\n  for (; y; y /= 2, x = 1ll * x * x % mo)\n    if (y & 1) s = 1ll * s * x % mo;\n  return s;\n}\nint W[N], w[N], R[N];\nint A[16][N];\nvoid FFTinit() {\n  W[0] = 1;\n  W[1] = power(3, (mo - 1) / FFTN);\n  for (int i = 2; i < N; i++) W[i] = 1ll * W[i - 1] * W[1] % mo;\n}\nint FFTinit(int n) {\n  int L = 1;\n  for (; L <= n; L <<= 1)\n    ;\n  for (int i = 0; i < L; i++)\n    R[i] = (R[i >> 1] >> 1) | ((i & 1) ? (L >> 1) : 0);\n  return L;\n}\nunsigned long long p[N];\nvoid DFT(int *a, int n) {\n  for (int i = 0; i < n; i++) p[R[i]] = a[i];\n  for (int d = 1; d < n; d <<= 1) {\n    int len = FFTN / (d << 1);\n    for (int i = 0, j = 0; i < d; i++, j += len) w[i] = W[j];\n    for (int i = 0; i < n; i += d << 1)\n      for (int j = 0; j < d; j++) {\n        int y = p[i + j + d] * w[j] % mo;\n        p[i + j + d] = p[i + j] + mo - y;\n        p[i + j] += y;\n      }\n  }\n  for (int i = 0; i < n; i++) a[i] = p[i] % mo;\n}\nvoid IDFT(int *a, int n) {\n  for (int i = 0; i < n; i++) p[R[i]] = a[i];\n  for (int d = 1; d < n; d <<= 1) {\n    int len = FFTN / (d << 1);\n    for (int i = 0, j = FFTN; i < d; i++, j -= len) w[i] = W[j];\n    for (int i = 0; i < n; i += d << 1)\n      for (int j = 0; j < d; j++) {\n        int y = p[i + j + d] * w[j] % mo;\n        p[i + j + d] = p[i + j] + mo - y;\n        p[i + j] += y;\n      }\n  }\n  int inv = power(n, mo - 2);\n  for (int i = 0; i < n; i++) a[i] = p[i] * inv % mo;\n}\nint a[N], q[N], n;\nstruct node {\n  vector<int> a[2][2];\n  node() {}\n  node(int l) {\n    for (int i = 0; i < 2; i++)\n      for (int j = 0; j < 2; j++) a[i][j].resize(l);\n  }\n};\nnode divide(int l, int r) {\n  node ans(r - l + 1);\n  if (r - l + 1 == 2) {\n    ans.a[q[l] == 1][q[r] == 1][1]++;\n    ans.a[0][0][0]++;\n    return ans;\n  }\n  if (r - l + 1 == 3) {\n    ans.a[q[l] == 1][q[r] == 1][2] += (q[l + 1] == 1 ? 1 : 2);\n    ans.a[0][q[r] == 1][1]++;\n    ans.a[q[l] == 1][0][1]++;\n    ans.a[0][0][0]++;\n    return ans;\n  }\n  int mid = (l + r) / 2;\n  node ansl = divide(l, mid);\n  node ansr = divide(mid + 1, r);\n  int L = FFTinit(r - l + 1);\n  for (int i = 0; i < 16; i++)\n    for (int j = 0; j < L; j++) A[i][j] = 0;\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 2; j++) {\n      int i1 = i * 2 + j, i2 = i * 2 + j + 4;\n      for (int p = 1; p < mid - l + 1; p++) A[i1][p] = ansl.a[i][j][p];\n      for (int p = 1; p < r - mid; p++) A[i2][p] = ansr.a[i][j][p];\n    }\n  for (int i = 0; i < 8; i++) DFT(A[i], L);\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 2; j++)\n      for (int k = 0; k < 2; k++)\n        for (int m = 0; m < 2; m++) {\n          int i1 = i * 2 + j, i2 = k * 2 + m + 4;\n          int i3 = i * 2 + m + 8, i4 = i * 2 + m + 12;\n          for (int p = 0; p < L; p++)\n            A[i3][p] = (A[i3][p] +\n                        1ll * A[i1][p] * A[i2][p] * (j ? 1 : 2) * (k ? 1 : 2)) %\n                       mo;\n          for (int p = 0; p < L; p++)\n            A[i4][p] = (A[i4][p] + 2ll * A[i1][p] * A[i2][p]) % mo;\n          for (int p = 1; p < mid - l + 1; p++) {\n            ans.a[i][m][p + 1] =\n                (ans.a[i][m][p + 1] +\n                 1ll * ansl.a[i][j][p] * ansr.a[k][m][0] * (j ? 1 : 2)) %\n                mo;\n            ans.a[i][m][p] =\n                (ans.a[i][m][p] + 1ll * ansl.a[i][j][p] * ansr.a[k][m][0]) % mo;\n          }\n          for (int p = 1; p < r - mid; p++) {\n            ans.a[i][m][p + 1] =\n                (ans.a[i][m][p + 1] +\n                 1ll * ansl.a[i][j][0] * ansr.a[k][m][p] * (k ? 1 : 2)) %\n                mo;\n            ans.a[i][m][p] =\n                (ans.a[i][m][p] + 1ll * ansl.a[i][j][0] * ansr.a[k][m][p]) % mo;\n          }\n          ans.a[i][m][1] =\n              (ans.a[i][m][1] + 1ll * ansl.a[i][j][0] * ansr.a[k][m][0]) % mo;\n          ans.a[i][m][0] =\n              (ans.a[i][m][0] + 1ll * ansl.a[i][j][0] * ansr.a[k][m][0]) % mo;\n        }\n  for (int i = 8; i < 16; i++) IDFT(A[i], L);\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 2; j++) {\n      int i1 = i * 2 + j + 8, i2 = i * 2 + j + 12;\n      for (int p = 1; p < r - l + 1; p++)\n        ans.a[i][j][p] = (ans.a[i][j][p] + A[i1][p - 1]) % mo;\n      for (int p = 0; p < r - l + 1; p++)\n        ans.a[i][j][p] = (ans.a[i][j][p] + A[i2][p]) % mo;\n    }\n  return ans;\n}\nint main() {\n  FFTinit();\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  for (int i = 1; i <= n;) {\n    if (i + a[i] - 1 > n) return puts(\"0\"), 0;\n    for (int j = i; j < i + a[i]; j++)\n      if (a[j] != a[i]) return puts(\"0\"), 0;\n    q[++*q] = a[i];\n    i += a[i];\n  }\n  if (*q == 1) {\n    printf(\"%d\\n\", n == 1 ? 1 : 2);\n    return 0;\n  }\n  node ans = divide(1, *q);\n  int tr = 1, res = 0;\n  for (int p = 0; p < *q; p++) {\n    int v;\n    if (p == 0)\n      v = (2ll * ans.a[0][0][p] + 1ll * ans.a[1][1][p]) % mo;\n    else\n      v = (4ll * ans.a[0][0][p] + 2ll * ans.a[0][1][p] + 2ll * ans.a[1][0][p] +\n           ans.a[1][1][p]) %\n          mo;\n    tr = 1ll * tr * (p + 1) % mo;\n    if (((*q) - (p + 1)) & 1)\n      res = (res + mo - 1ll * tr * v % mo) % mo;\n    else\n      res = (res + 1ll * tr * v) % mo;\n  }\n  cout << res << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint abc;\ninline int rd(int l, int r) { return rand() % (r - l + 1) + l; }\nconst int mxn = 2e5 + 3, mod = 998244353;\nlong long por(long long x, int y = mod - 2) {\n  long long r = 1;\n  for (; y; y >>= 1) {\n    if (y & 1) r = r * x % mod;\n    x = x * x % mod;\n  }\n  return r;\n}\nint n, a[mxn], m, R[mxn], N;\nlong long w[2][mxn];\nbool b[mxn];\nbool chk() {\n  for (int i = 1; i <= n;) {\n    int x = a[i], y = x;\n    b[++m] = x > 1;\n    while (y--) {\n      if (a[i] != x) return 0;\n      ++i;\n    }\n  }\n  return 1;\n}\nstruct VV {\n  vector<long long> a[2][2];\n  void ii(int s) {\n    a[0][0].resize(s), a[0][1].resize(s), a[1][0].resize(s), a[1][1].resize(s);\n  }\n};\nvoid ntt(vector<long long>& a, int n, bool tp = 0) {\n  for (int i = 1; i < n; ++i) R[i] = R[i >> 1] >> 1, R[i] |= (i & 1) * (n >> 1);\n  for (int i = 0; i < n; ++i) a[i] %= mod;\n  for (int i = 0; i < n; ++i)\n    if (i > R[i]) swap(a[i], a[R[i]]);\n  for (int d = 1, t = N >> 1; d < n; d *= 2, t >>= 1) {\n    for (int i = 0; i < n; i += d * 2)\n      for (int j = 0; j < d; ++j) {\n        long long x = a[i + j + d] * w[tp][t * j];\n        a[i + j + d] = (a[i + j] - x) % mod, a[i + j] = (a[i + j] + x) % mod;\n      }\n  }\n  if (tp) {\n    long long iv = por(n);\n    for (int i = 0; i < n; ++i) a[i] = a[i] * iv % mod;\n  }\n}\nvector<long long> d;\nvoid NTT(vector<long long>& a, vector<long long>& b, vector<long long>& c,\n         int t) {\n  for (int i = 0; i < n; ++i) d[i] = a[i] * b[i] % mod;\n  ntt(d, n, 1);\n  for (int i = 0; i < n; ++i)\n    if (d[i]) c[i] += d[i] * t, c[i - 1] += d[i] * 2;\n  for (int i = 0; i < n; ++i) c[i] %= mod;\n}\nVV sol(int L, int R) {\n  if (L == R) {\n    VV r;\n    r.ii(2);\n    r.a[b[L]][b[L]][1] = 1;\n    return r;\n  }\n  int md = (L + R) >> 1;\n  VV v1 = sol(L, md), v2 = sol(md + 1, R), re;\n  n = 1;\n  while (n <= R - L + 1) n *= 2;\n  v1.ii(n), v2.ii(n), re.ii(n), d.resize(n);\n  for (int i1 = 0; i1 <= 1; ++i1)\n    for (int i2 = 0; i2 <= 1; ++i2)\n      for (int i3 = 0; i3 <= 1; ++i3)\n        for (int i4 = 0; i4 <= 1; ++i4) {\n          vector<long long>&h1 = v1.a[i1][i2], &h2 = v2.a[i3][i4];\n          int b1 = h1[1] != 0, b2 = h2[1] != 0;\n          if (i1 == i2 && i3 == i4)\n            re.a[i1][i3][2] += b1 * b2, re.a[1][1][1] += b1 * b2;\n          if (i1 == i2) {\n            if (b1)\n              for (int i = 2; i < n; ++i) {\n                if (h2[i])\n                  re.a[i1][i4][i + 1] += (i3 + 1) * h2[i],\n                      re.a[1][i4][i] += h2[i];\n              }\n          }\n          if (i3 == i4) {\n            if (b2)\n              for (int i = 2; i < n; ++i) {\n                if (h1[i])\n                  re.a[i1][i4][i + 1] += (i2 + 1) * h1[i],\n                      re.a[i1][1][i] += h1[i];\n              }\n          }\n        }\n  for (int i = 0; i <= 1; ++i)\n    for (int j = 0; j <= 1; ++j) {\n      vector<long long>& v = v1.a[i][j];\n      v[1] = 0;\n      ntt(v, n);\n    }\n  for (int i = 0; i <= 1; ++i)\n    for (int j = 0; j <= 1; ++j) {\n      vector<long long>& v = v2.a[i][j];\n      v[1] = 0;\n      ntt(v, n);\n    }\n  for (int i1 = 0; i1 <= 1; ++i1)\n    for (int i2 = 0; i2 <= 1; ++i2)\n      for (int i3 = 0; i3 <= 1; ++i3)\n        for (int i4 = 0; i4 <= 1; ++i4)\n          NTT(v1.a[i1][i2], v2.a[i3][i4], re.a[i1][i4], (i2 + 1) * (i3 + 1));\n  return re;\n}\nint main() {\n  abc = scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) abc = scanf(\"%d\", a + i);\n  if (!chk()) return puts(\"0\"), 0;\n  N = 1;\n  while (N <= m) N *= 2;\n  w[0][0] = w[1][0] = 1, w[0][1] = por(3, (mod - 1) / N),\n  w[1][1] = por(w[0][1]);\n  for (int i = 2; i < N; ++i)\n    w[0][i] = w[0][i - 1] * w[0][1] % mod,\n    w[1][i] = w[1][i - 1] * w[1][1] % mod;\n  VV re = sol(1, m);\n  long long ans = 0;\n  for (int i1 = 0; i1 <= 1; ++i1)\n    for (int i2 = 0; i2 <= 1; ++i2) {\n      vector<long long>& v = re.a[i1][i2];\n      long long jc = (m & 1) ? -1 : 1;\n      for (int i = 1; i <= m; ++i) {\n        jc *= -i, jc %= mod;\n        if (i == 1)\n          ans += v[i] * (i1 + 1) * jc % mod;\n        else\n          ans += v[i] * (i1 + 1) * (i2 + 1) * jc % mod;\n      }\n      ans %= mod;\n    }\n  printf(\"%lld\\n\", (ans % mod + mod) % mod);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <typename T>\nvoid read(T &);\ntemplate <typename T>\nvoid write(const T &);\nconst int iinf = 2147483647;\nconst long long llinf = 9223372036854775807ll;\nconst int N = 270000;\nconst int Mod = 998244353, sgn[] = {1, Mod - 1};\nint pow(int a, int b, int ans = 1);\nnamespace Pol {\nint add(int a, int b) { return (a += b) >= Mod ? a -= Mod : a; }\nint sub(int a, int b) { return (a -= b) < 0 ? a += Mod : a; }\nvoid inc(int &a, int b) { (a += b) >= Mod ? a -= Mod : a; }\nvoid dec(int &a, int b) { (a -= b) < 0 ? a += Mod : a; }\nint &reduce(int &x) { return x += x >> 31 & Mod; }\nvoid init_Poly(int n = N);\nvoid DIT(int *A, int lim);\nvoid DIF(int *A, int lim);\nstd::vector<int> &operator+=(std::vector<int> &a, const std::vector<int> &b);\nstd::vector<int> mult(const std::vector<int> &A, int n,\n                      const std::vector<int> &B, int m);\nstd::vector<int> operator*(const std::vector<int> &a,\n                           const std::vector<int> &b);\nunsigned long long tmp[N];\nint gw[N];\n}  // namespace Pol\nclass Matrix {\n public:\n  std::vector<int> val[2][2];\n  friend Matrix operator*(const Matrix &a, const Matrix &b);\n};\nMatrix work(int l, int r);\nMatrix a[N];\nint fac[N];\nint seg[N], m;\nint tmp[N], n;\nint main() {\n  Pol::init_Poly();\n  read(n);\n  for (int i = 1; i <= n; ++i) read(tmp[i]);\n  for (int i = 1; i <= n;) {\n    int now = tmp[i];\n    for (int j = i; j <= i + now - 1; ++j) {\n      if (tmp[j] != now) {\n        puts(\"0\");\n        return 0;\n      }\n    }\n    seg[++m] = now;\n    i += now;\n  }\n  fac[0] = 1;\n  for (int i = 1; i <= m; ++i) {\n    fac[i] = 1ll * fac[i - 1] * i % Mod;\n    a[i].val[1][0] = {1};\n    a[i].val[0][1] = {0, 2};\n    a[i].val[1][1] = {0, 1};\n    if (seg[i] == 1) {\n      a[i].val[0][0] = {1};\n    } else {\n      a[i].val[0][0] = {2};\n    }\n  }\n  Matrix ans = work(1, m);\n  int res = 0;\n  for (size_t i = 0; i < ans.val[0][0].size(); ++i) {\n    res = (res + 1ll * fac[m - i] * ans.val[0][0][i] % Mod * sgn[i & 1]) % Mod;\n  }\n  write(res), putchar('\\n');\n  return 0;\n}\nMatrix work(int l, int r) {\n  if (l == r) return a[l];\n  int m = (l + r) >> 1;\n  return work(l, m) * work(m + 1, r);\n}\nMatrix operator*(const Matrix &a, const Matrix &b) {\n  Matrix ans;\n  using namespace Pol;\n  for (int i = 0; i < 2; ++i) {\n    for (int k = 0; k < 2; ++k) {\n      for (int j = 0; j < 2; ++j) {\n        ans.val[i][j] += a.val[i][k] * b.val[k][j];\n      }\n    }\n  }\n  return ans;\n}\nnamespace Pol {\nvoid DIT(int *A, int lim) {\n  for (int i = 0; i < lim; ++i) tmp[i] = A[i];\n  for (int l = 1; l < lim; l <<= 1) {\n    unsigned long long *k = tmp;\n    for (int *g = gw; k < tmp + lim; k += (l << 1), ++g) {\n      for (unsigned long long *x = k; x < k + l; ++x) {\n        int o = x[l] % Mod;\n        x[l] = 1ll * (*x + Mod - o) * *g % Mod, *x += o;\n      }\n    }\n  }\n  int iv = pow(lim, Mod - 2);\n  for (int i = 0; i < lim; ++i) A[i] = 1ll * tmp[i] % Mod * iv % Mod;\n  std::reverse(A + 1, A + lim);\n}\nvoid DIF(int *A, int lim) {\n  for (int i = 0; i < lim; ++i) tmp[i] = A[i];\n  for (int l = lim / 2; l >= 1; l >>= 1) {\n    unsigned long long *k = tmp;\n    for (int *g = gw; k < tmp + lim; k += (l << 1), ++g) {\n      for (unsigned long long *x = k; x < k + l; ++x) {\n        int o = 1ll * x[l] * *g % Mod;\n        x[l] = *x + Mod - o, *x += o;\n      }\n    }\n  }\n  for (int i = 0; i < lim; ++i) A[i] = tmp[i] % Mod;\n}\nstd::vector<int> &operator+=(std::vector<int> &a, const std::vector<int> &b) {\n  if (a.size() < b.size()) a.resize(b.size());\n  for (size_t i = 0; i < a.size() && i < b.size(); ++i) inc(a[i], b[i]);\n  return a;\n}\nstd::vector<int> mult(const std::vector<int> &A, int n,\n                      const std::vector<int> &B, int m) {\n  int lim = 1;\n  while (lim < (n + m - 1)) lim <<= 1;\n  static int tA[N], tB[N];\n  std::copy_n(A.begin(), n, tA), std::fill(tA + n, tA + lim, 0);\n  std::copy_n(B.begin(), m, tB), std::fill(tB + m, tB + lim, 0);\n  DIF(tA, lim), DIF(tB, lim);\n  for (int i = 0; i < lim; ++i) tA[i] = 1ll * tA[i] * tB[i] % Mod;\n  DIT(tA, lim);\n  std::vector<int> ans(n + m - 1);\n  std::copy_n(tA, n + m - 1, ans.begin());\n  return ans;\n}\nstd::vector<int> operator*(const std::vector<int> &a,\n                           const std::vector<int> &b) {\n  return mult(a, a.size(), b, b.size());\n}\nvoid init_Poly(int n) {\n  int t = 1;\n  while ((1 << t) < n) ++t;\n  t = std::min(t - 1, 21);\n  gw[0] = 1, gw[1 << t] = pow(pow(3, 119), 1 << (21 - t));\n  for (int i = t; i; --i)\n    gw[1 << (i - 1)] = 1ll * gw[1 << i] * gw[1 << i] % Mod;\n  for (int i = 1; i < (1 << t); ++i)\n    gw[i] = 1ll * gw[i & (i - 1)] * gw[i & -i] % Mod;\n}\n}  // namespace Pol\nint pow(int a, int b, int ans) {\n  while (b) {\n    if (b & 1) ans = 1ll * ans * a % Mod;\n    a = 1ll * a * a % Mod;\n    b >>= 1;\n  }\n  return ans;\n}\ntemplate <typename T>\nvoid read(T &Re) {\n  T k = 0;\n  char ch = getchar();\n  int flag = 1;\n  while (!std::isdigit(ch)) {\n    if (ch == '-') flag = -1;\n    ch = getchar();\n  }\n  while (std::isdigit(ch)) k = k * 10 + ch - '0', ch = getchar();\n  Re = flag * k;\n}\ntemplate <typename T>\nvoid write(const T &Wr) {\n  if (Wr < 0) {\n    putchar('-'), write(-Wr);\n  } else if (Wr < 10) {\n    putchar(Wr + '0');\n  } else {\n    write(Wr / 10), putchar((Wr % 10) + '0');\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar _c;\nbool _f;\ntemplate <class T>\ninline void IN(T &x) {\n  x = 0, _f = 0;\n  while (_c = getchar(), !isdigit(_c))\n    if (_c == '-') _f = 1;\n  while (isdigit(_c)) x = x * 10 + _c - '0', _c = getchar();\n  if (_f) x = -x;\n}\nconst int mod = 998244353;\ninline int mul(int x, int y) { return 1ll * x * y % mod; }\ninline void sub(int &x, int y) {\n  x -= y;\n  if (x < 0) x += mod;\n}\ninline void pls(int &x, int y) {\n  x += y;\n  if (x >= mod) x -= mod;\n}\ninline int dec(int x, int y) {\n  x -= y;\n  if (x < 0) x += mod;\n  return x;\n}\ninline int add(int x, int y) {\n  x += y;\n  if (x >= mod) x -= mod;\n  return x;\n}\ninline int modpow(int x, long long y, int res = 1) {\n  for (y = (y + mod - 1) % (mod - 1); y; y >>= 1, x = mul(x, x))\n    if (y & 1) res = mul(x, res);\n  return res;\n}\ntemplate <class T>\ninline void chkmin(T &x, T y) {\n  if (x > y) x = y;\n}\ntemplate <class T>\ninline void chkmax(T &x, T y) {\n  if (x < y) x = y;\n}\nconst int LogN = 20;\nint lim, tim, inv[LogN];\nvector<int> w[LogN], rev[LogN];\ninline void init_w(int len = 1 << 19) {\n  w[19].resize(len), w[19][0] = 1, w[19][1] = modpow(3, (mod - 1) >> 20);\n  for (int i = 2; i < len; ++i) w[19][i] = mul(w[19][i - 1], w[19][1]);\n  for (int i = 18; i >= 0; --i) {\n    w[i].resize(len >>= 1);\n    for (int j = 0; j < len; ++j) w[i][j] = w[i + 1][j << 1];\n  }\n}\ninline void init_r(int len) {\n  for (lim = 1, tim = 0; lim < len; lim <<= 1, ++tim)\n    ;\n  if (rev[tim].size()) return;\n  rev[tim].resize(lim), inv[tim] = modpow(lim, -1);\n  for (int i = 0; i < lim; ++i)\n    rev[tim][i] = (rev[tim][i >> 1] >> 1) | ((i & 1) << (tim - 1));\n}\ninline void ntt(vector<int> &f, short typ) {\n  static unsigned long long g[1 << 20 | 5];\n  for (int i = 0; i < lim; ++i) g[rev[tim][i]] = f[i];\n  for (int p = 1, s = 0, t = 0; p < lim; p <<= 1, ++t)\n    for (int k = 0; k < lim; k += p << 1)\n      for (int l = k; l < k + p; ++l)\n        s = mul(g[l + p] % mod, w[t][l - k]), g[l + p] = g[l] + mod - s,\n        g[l] += s;\n  for (int i = 0; i < lim; ++i) f[i] = g[i] % mod;\n  if (~typ) return;\n  std ::reverse(++f.begin(), f.end());\n  for (int i = 0; i < lim; ++i) f[i] = mul(f[i], inv[tim]);\n}\nconst int N = 1e5 + 5;\nconst int inv2 = modpow(2, -1);\nint n, m, a[N], b[N], fac[N];\nvector<int> f[N << 2][4], g[2][4];\nvoid solve(int x, int l, int r, bool typ) {\n  const int len = r - l + 2;\n  for (int o = 0; o < 4; ++o) f[x][o].resize(len);\n  if (l == r) return f[x][(b[l] == 1) * 3][1] = 1 + (b[l] != 1), void();\n  const int mid = l + r >> 1, lc = x << 1, rc = x << 1 | 1;\n  solve(lc, l, mid, 0), solve(rc, mid + 1, r, 1);\n  const int ln = mid - l + 2, rn = r - mid + 1;\n  for (int o0 = 0; o0 < 4; ++o0)\n    for (int o1 = 0; o1 < 4; ++o1) {\n      int t0 = (o0 & 1) | (o1 & 2), t2 = (o0 & 2) | (o1 & 1),\n          val = (t2 == 3) ? 2 : (t2 == 0 ? inv2 : 1);\n      pls(f[x][t0][2], mul(f[lc][o0][1], f[rc][o1][1]));\n      pls(f[x][0][1], mul(mul(f[lc][o0][1], f[rc][o1][1]), val));\n      for (int i = 3; i <= ln; ++i)\n        pls(f[x][t0][i], mul(f[lc][o0][i - 1], f[rc][o1][1]));\n      for (int j = 3; j <= rn; ++j)\n        pls(f[x][t0][j], mul(f[lc][o0][1], f[rc][o1][j - 1]));\n      for (int i = 2; i < ln; ++i)\n        pls(f[x][o0 & 1][i], mul(mul(f[lc][o0][i], f[rc][o1][1]), val));\n      for (int j = 2; j < rn; ++j)\n        pls(f[x][o1 & 2][j], mul(mul(f[lc][o0][1], f[rc][o1][j]), val));\n    }\n  init_r(len);\n  for (int t0 = 0; t0 < 4; ++t0) g[0][t0].resize(lim), g[1][t0].resize(lim);\n  for (int o0 = 0; o0 < 4; ++o0)\n    f[lc][o0][0] = f[lc][o0][1] = 0, f[lc][o0].resize(lim), ntt(f[lc][o0], 1);\n  for (int o1 = 0; o1 < 4; ++o1)\n    f[rc][o1][0] = f[rc][o1][1] = 0, f[rc][o1].resize(lim), ntt(f[rc][o1], 1);\n  for (int o0 = 0; o0 < 4; ++o0)\n    for (int o1 = 0; o1 < 4; ++o1) {\n      int t0 = (o0 & 1) | (o1 & 2), t2 = (o0 & 2) | (o1 & 1),\n          val = (t2 == 3) ? 2 : (t2 == 0 ? inv2 : 1);\n      for (int i = 0; i < lim; ++i)\n        g[0][t0][i] = mul(f[lc][o0][i], f[rc][o1][i]);\n      for (int i = 0; i < lim; ++i)\n        g[1][t0][i] = mul(mul(f[lc][o0][i], f[rc][o1][i]), val);\n      ntt(g[0][t0], -1), ntt(g[1][t0], -1);\n      for (int i = 4; i < len; ++i) pls(f[x][t0][i], g[0][t0][i]);\n      for (int i = 4; i < len; ++i) pls(f[x][t0][i - 1], g[1][t0][i]);\n    }\n}\nint main() {\n  init_w();\n  IN(n);\n  for (int i = 1; i <= n; ++i) IN(a[i]);\n  fac[0] = 1;\n  for (int i = 1; i <= n; ++i) fac[i] = mul(fac[i - 1], i);\n  bool flag = false;\n  for (int l = 1, r; l <= n; l = r + 1) {\n    if (r = l + a[l] - 1, r > n) {\n      flag = true;\n      break;\n    }\n    for (int i = l; i <= r; ++i)\n      if (a[i] != a[l]) flag = true;\n    b[++m] = a[l];\n  }\n  if (flag) return puts(\"0\"), 0;\n  solve(1, 1, m, 0);\n  int ans = 0;\n  for (int i = 1; i <= m; ++i)\n    for (int o = 0; o < 4; ++o)\n      pls(ans, mul(f[1][o][i], mul(fac[i], ((m - i) & 1) ? mod - 1 : 1)));\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <int MOD, int RT>\nstruct Mint {\n  static const int mod = MOD;\n  static constexpr Mint rt() { return RT; }\n  int v;\n  explicit operator int() const { return v; }\n  Mint() { v = 0; }\n  Mint(long long _v) {\n    v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);\n    if (v < 0) v += MOD;\n  }\n  friend bool operator==(const Mint& a, const Mint& b) { return a.v == b.v; }\n  friend bool operator!=(const Mint& a, const Mint& b) { return !(a == b); }\n  friend bool operator<(const Mint& a, const Mint& b) { return a.v < b.v; }\n  friend bool operator>(const Mint& a, const Mint& b) { return a.v > b.v; }\n  friend bool operator<=(const Mint& a, const Mint& b) { return a.v <= b.v; }\n  friend bool operator>=(const Mint& a, const Mint& b) { return a.v >= b.v; }\n  friend istream& operator>>(istream& in, Mint& a) {\n    long long x;\n    cin >> x;\n    a = Mint(x);\n    return in;\n  }\n  friend ostream& operator<<(ostream& os, const Mint& a) { return os << a.v; }\n  Mint& operator+=(const Mint& m) {\n    if ((v += m.v) >= MOD) v -= MOD;\n    return *this;\n  }\n  Mint& operator-=(const Mint& m) {\n    if ((v -= m.v) < 0) v += MOD;\n    return *this;\n  }\n  Mint& operator*=(const Mint& m) {\n    v = (long long)v * m.v % MOD;\n    return *this;\n  }\n  Mint& operator/=(const Mint& m) { return (*this) *= inv(m); }\n  friend Mint pow(Mint a, long long p) {\n    Mint ans = 1;\n    assert(p >= 0);\n    for (; p; p /= 2, a *= a)\n      if (p & 1) ans *= a;\n    return ans;\n  }\n  friend Mint inv(const Mint& a) {\n    assert(a.v != 0);\n    return pow(a, MOD - 2);\n  }\n  Mint operator-() const { return Mint(-v); }\n  Mint& operator++() { return *this += 1; }\n  Mint& operator--() { return *this -= 1; }\n  friend Mint operator+(Mint a, const Mint& b) { return a += b; }\n  friend Mint operator-(Mint a, const Mint& b) { return a -= b; }\n  friend Mint operator*(Mint a, const Mint& b) { return a *= b; }\n  friend Mint operator/(Mint a, const Mint& b) { return a /= b; }\n};\nnamespace FFT {\ntemplate <class T>\nvoid fft(vector<T>& A, bool inv = 0) {\n  int n = (int)A.size();\n  assert((T::mod - 1) % n == 0);\n  vector<T> B(n);\n  for (int b = n / 2; b; b /= 2, A.swap(B)) {\n    T w = pow(T::rt(), (T::mod - 1) / n * b);\n    T m = 1;\n    for (int i = 0; i < n; i += b * 2, m *= w)\n      for (int j = 0; j < b; j++) {\n        T u = A[i + j];\n        T v = A[i + j + b] * m;\n        B[i / 2 + j] = u + v;\n        B[i / 2 + j + n / 2] = u - v;\n      }\n  }\n  if (inv) {\n    reverse(1 + A.begin(), A.end());\n    T z = T(1) / T(n);\n    for (auto& t : A) t *= z;\n  }\n}\ntemplate <class T>\nvector<T> multiply(vector<T> A, vector<T> B) {\n  int sa = (int)A.size();\n  int sb = (int)B.size();\n  if (!min(sa, sb)) return {};\n  int s = sa + sb - 1;\n  int n = 1;\n  for (; n < s; n *= 2)\n    ;\n  bool eq = A == B;\n  A.resize(n);\n  fft(A);\n  if (eq)\n    B = A;\n  else\n    B.resize(n), fft(B);\n  for (int i = 0; i < n; i++) A[i] *= B[i];\n  fft(A, 1);\n  A.resize(s);\n  return A;\n}\ntemplate <class T>\nvector<T> operator*(const vector<T>& a, const vector<T>& b) {\n  auto c = multiply(a, b);\n  return c;\n}\ntemplate <class T>\nvector<T> operator+(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  c.resize(max(a.size(), b.size()));\n  for (int i = 0; i < b.size(); ++i) {\n    c[i] += b[i];\n  }\n  return c;\n}\ntemplate <class M, class T>\nvector<M> multiply_mod(vector<T> x, vector<T> y) {\n  auto convert = [](const vector<T>& v) {\n    vector<M> w((int)v.size());\n    for (int i = 0; i < (int)v.size(); i++) w[i] = (int)v[i];\n    return w;\n  };\n  return multiply(convert(x), convert(y));\n}\ntemplate <class T>\nvector<T> general_multiply(const vector<T>& A, const vector<T>& B) {\n  using m0 = Mint<(119 << 23) + 1, 62>;\n  using m1 = Mint<(5 << 25) + 1, 62>;\n  using m2 = Mint<(7 << 26) + 1, 62>;\n  auto c0 = multiply_mod<m0>(A, B);\n  auto c1 = multiply_mod<m1>(A, B);\n  auto c2 = multiply_mod<m2>(A, B);\n  int n = (int)c0.size();\n  vector<T> res(n);\n  m1 r01 = 1 / m1(m0::mod);\n  m2 r02 = 1 / m2(m0::mod);\n  m2 r12 = 1 / m2(m1::mod);\n  for (int i = 0; i < n; i++) {\n    int a = c0[i].v;\n    int b = ((c1[i] - a) * r01).v;\n    int c = (((c2[i] - a) * r02 - b) * r12).v;\n    res[i] = (T(c) * m1::mod + b) * m0::mod + a;\n  }\n  return res;\n}\n}  // namespace FFT\nusing namespace FFT;\nusing mi = Mint<998244353, 5>;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  auto fail = []() {\n    cout << 0 << '\\n';\n    exit(0);\n  };\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n  }\n  vector<int> blocks;\n  while (!a.empty()) {\n    int x = a.back();\n    if (a.size() < x) {\n      fail();\n    }\n    blocks.push_back(x == 1);\n    for (int i = 0; i < x; ++i) {\n      if (a.back() != x) {\n        fail();\n      }\n      a.pop_back();\n    }\n  }\n  reverse(blocks.begin(), blocks.end());\n  int sz = blocks.size();\n  function<vector<vector<mi>>(int, int)> solve = [&](int l, int r) {\n    vector<vector<mi>> res(4);\n    if (r - l + 1 == 1) {\n      res[0] = vector<mi>{1};\n      res[1] = vector<mi>{0, 2};\n      res[2] = vector<mi>{1};\n      if (blocks[l]) {\n        res[3] = vector<mi>{0, 1};\n      } else {\n        res[3] = vector<mi>{0, 2};\n      }\n      return res;\n    }\n    int m = (l + r) >> 1;\n    auto x = solve(l, m);\n    auto y = solve(m + 1, r);\n    res[0] = x[0] * y[0] + x[1] * y[2];\n    res[1] = x[0] * y[1] + x[1] * y[3];\n    res[2] = x[2] * y[0] + x[3] * y[2];\n    res[3] = x[3] * y[3] + x[2] * y[1];\n    return res;\n  };\n  auto res = solve(0, sz - 1)[3];\n  mi ans = 0;\n  mi run = 1;\n  for (int i = 1; i < res.size(); ++i) {\n    run *= i;\n    ans += res[i] * run * (i % 2 == res.size() % 2 ? -1 : 1);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <int MOD, int RT>\nstruct Mint {\n  static const int mod = MOD;\n  static constexpr Mint rt() { return RT; }\n  int v;\n  explicit operator int() const { return v; }\n  Mint() { v = 0; }\n  Mint(long long _v) {\n    v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);\n    if (v < 0) v += MOD;\n  }\n  friend bool operator==(const Mint& a, const Mint& b) { return a.v == b.v; }\n  friend bool operator!=(const Mint& a, const Mint& b) { return !(a == b); }\n  friend bool operator<(const Mint& a, const Mint& b) { return a.v < b.v; }\n  friend bool operator>(const Mint& a, const Mint& b) { return a.v > b.v; }\n  friend bool operator<=(const Mint& a, const Mint& b) { return a.v <= b.v; }\n  friend bool operator>=(const Mint& a, const Mint& b) { return a.v >= b.v; }\n  friend istream& operator>>(istream& in, Mint& a) {\n    long long x;\n    cin >> x;\n    a = Mint(x);\n    return in;\n  }\n  friend ostream& operator<<(ostream& os, const Mint& a) { return os << a.v; }\n  Mint& operator+=(const Mint& m) {\n    if ((v += m.v) >= MOD) v -= MOD;\n    return *this;\n  }\n  Mint& operator-=(const Mint& m) {\n    if ((v -= m.v) < 0) v += MOD;\n    return *this;\n  }\n  Mint& operator*=(const Mint& m) {\n    v = (long long)v * m.v % MOD;\n    return *this;\n  }\n  Mint& operator/=(const Mint& m) { return (*this) *= inv(m); }\n  friend Mint pow(Mint a, long long p) {\n    Mint ans = 1;\n    assert(p >= 0);\n    for (; p; p /= 2, a *= a)\n      if (p & 1) ans *= a;\n    return ans;\n  }\n  friend Mint inv(const Mint& a) {\n    assert(a.v != 0);\n    return pow(a, MOD - 2);\n  }\n  Mint operator-() const { return Mint(-v); }\n  Mint& operator++() { return *this += 1; }\n  Mint& operator--() { return *this -= 1; }\n  friend Mint operator+(Mint a, const Mint& b) { return a += b; }\n  friend Mint operator-(Mint a, const Mint& b) { return a -= b; }\n  friend Mint operator*(Mint a, const Mint& b) { return a *= b; }\n  friend Mint operator/(Mint a, const Mint& b) { return a /= b; }\n};\nnamespace FFT {\ntemplate <class T>\nvoid fft(vector<T>& A, bool inv = 0) {\n  int n = (int)A.size();\n  assert((T::mod - 1) % n == 0);\n  vector<T> B(n);\n  for (int b = n / 2; b; b /= 2, A.swap(B)) {\n    T w = pow(T::rt(), (T::mod - 1) / n * b);\n    T m = 1;\n    for (int i = 0; i < n; i += b * 2, m *= w)\n      for (int j = 0; j < b; j++) {\n        T u = A[i + j];\n        T v = A[i + j + b] * m;\n        B[i / 2 + j] = u + v;\n        B[i / 2 + j + n / 2] = u - v;\n      }\n  }\n  if (inv) {\n    reverse(1 + A.begin(), A.end());\n    T z = T(1) / T(n);\n    for (auto& t : A) t *= z;\n  }\n}\ntemplate <class T>\nvector<T> multiply(vector<T> A, vector<T> B) {\n  int sa = (int)A.size();\n  int sb = (int)B.size();\n  if (!min(sa, sb)) return {};\n  int s = sa + sb - 1;\n  int n = 1;\n  for (; n < s; n *= 2)\n    ;\n  bool eq = A == B;\n  A.resize(n);\n  fft(A);\n  if (eq)\n    B = A;\n  else\n    B.resize(n), fft(B);\n  for (int i = 0; i < n; i++) A[i] *= B[i];\n  fft(A, 1);\n  A.resize(s);\n  return A;\n}\ntemplate <class T>\nvector<T> operator*(const vector<T>& a, const vector<T>& b) {\n  auto c = multiply(a, b);\n  return c;\n}\ntemplate <class T>\nvector<T> operator+(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  c.resize(max(a.size(), b.size()));\n  for (int i = 0; i < b.size(); ++i) {\n    c[i] += b[i];\n  }\n  return c;\n}\ntemplate <class M, class T>\nvector<M> multiply_mod(vector<T> x, vector<T> y) {\n  auto convert = [](const vector<T>& v) {\n    vector<M> w((int)v.size());\n    for (int i = 0; i < (int)v.size(); i++) w[i] = (int)v[i];\n    return w;\n  };\n  return multiply(convert(x), convert(y));\n}\ntemplate <class T>\nvector<T> general_multiply(const vector<T>& A, const vector<T>& B) {\n  using m0 = Mint<(119 << 23) + 1, 62>;\n  using m1 = Mint<(5 << 25) + 1, 62>;\n  using m2 = Mint<(7 << 26) + 1, 62>;\n  auto c0 = multiply_mod<m0>(A, B);\n  auto c1 = multiply_mod<m1>(A, B);\n  auto c2 = multiply_mod<m2>(A, B);\n  int n = (int)c0.size();\n  vector<T> res(n);\n  m1 r01 = 1 / m1(m0::mod);\n  m2 r02 = 1 / m2(m0::mod);\n  m2 r12 = 1 / m2(m1::mod);\n  for (int i = 0; i < n; i++) {\n    int a = c0[i].v;\n    int b = ((c1[i] - a) * r01).v;\n    int c = (((c2[i] - a) * r02 - b) * r12).v;\n    res[i] = (T(c) * m1::mod + b) * m0::mod + a;\n  }\n  return res;\n}\n}  // namespace FFT\nusing namespace FFT;\nusing mi = Mint<998244353, 5>;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  auto fail = []() {\n    cout << 0 << '\\n';\n    exit(0);\n  };\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n  }\n  vector<int> blocks;\n  while (!a.empty()) {\n    int x = a.back();\n    if (a.size() < x) {\n      fail();\n    }\n    blocks.push_back(x == 1);\n    for (int i = 0; i < x; ++i) {\n      if (a.back() != x) {\n        fail();\n      }\n      a.pop_back();\n    }\n  }\n  reverse(blocks.begin(), blocks.end());\n  int sz = blocks.size();\n  const mi HALF = 1 / mi(2);\n  function<vector<vector<mi>>(int, int)> solve = [&](int l, int r) {\n    vector<vector<mi>> res(4);\n    if (r - l + 1 == 1) {\n      res[0] = vector<mi>{1};\n      res[1] = vector<mi>{0, 2};\n      res[2] = vector<mi>{1};\n      if (blocks[l]) {\n        res[3] = vector<mi>{0, 1};\n      } else {\n        res[3] = vector<mi>{0, 2};\n      }\n      return res;\n    }\n    int m = (l + r) >> 1;\n    auto x = solve(l, m);\n    auto y = solve(m + 1, r);\n    res[0] = x[0] * y[0] + x[1] * y[2];\n    res[1] = x[0] * y[1] + x[1] * y[3];\n    res[2] = x[2] * y[0] + x[3] * y[2];\n    res[3] = x[3] * y[3] + x[2] * y[1];\n    return res;\n  };\n  auto res = solve(0, sz - 1)[3];\n  vector<mi> fact(n + 1);\n  fact[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    fact[i] = fact[i - 1] * i;\n  }\n  mi ans = 0;\n  for (int i = 1; i < res.size(); ++i) {\n    ans += res[i] * fact[i] * (i % 2 == res.size() % 2 ? -1 : 1);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MOD = 998244353;\nconst int HALF = (MOD + 1) / 2;\nconst int RT23 = 15311432;\nint root[24];\nvoid ntt(std::vector<int>& v, bool inv = false) {\n  int K = 0;\n  while ((1 << K) < v.size()) K++;\n  v.resize(1 << K);\n  if (inv) std::reverse(v.begin() + 1, v.end());\n  int rev = 0;\n  for (int i = 0; i < (1 << K); i++) {\n    if (i < rev) std::swap(v[i], v[rev]);\n    if (i == (1 << K) - 1) break;\n    int k = K - 1;\n    while (rev & (1 << k)) {\n      rev ^= (1 << k);\n      k--;\n    }\n    rev |= (1 << k);\n  }\n  for (int k = 0; k < K; k++) {\n    int opow = 1;\n    for (int i = 0; i < (1 << K); i++) {\n      if (i & (1 << k)) {\n        opow = 1;\n        continue;\n      }\n      int j = i | (1 << k);\n      int x = v[i], y = v[j];\n      v[i] = (x + 1LL * y * opow) % MOD;\n      v[j] = (x + (MOD - 1LL) * y % MOD * opow) % MOD;\n      opow = (1LL * opow * root[k + 1]) % MOD;\n    }\n  }\n  if (inv) {\n    int invN = 1;\n    for (int i = 0; i < K; i++) {\n      invN = (1LL * invN * HALF) % MOD;\n    }\n    for (int i = 0; i < (1 << K); i++) {\n      v[i] = (1LL * v[i] * invN) % MOD;\n    }\n  }\n}\nstd::vector<int> mul(std::vector<int> a, std::vector<int> b) {\n  if (a.empty() || b.empty()) return {};\n  int size = 1;\n  while (size < a.size() || size < b.size()) size *= 2;\n  size *= 2;\n  a.resize(size);\n  b.resize(size);\n  ntt(a);\n  ntt(b);\n  for (int i = 0; i < a.size(); i++) {\n    a[i] = (1LL * a[i] * b[i]) % MOD;\n  }\n  ntt(a, true);\n  while (a.size() > 0 && a.back() == 0) {\n    a.pop_back();\n  }\n  return a;\n}\nstd::vector<int> mul(std::vector<int> a, int b) {\n  for (int i = 0; i < a.size(); i++) {\n    a[i] = (1LL * a[i] * b) % MOD;\n  }\n  return a;\n}\nstd::vector<int> add(std::vector<int> a, const std::vector<int>& b) {\n  if (b.size() > a.size()) a.resize(b.size());\n  for (int i = 0; i < b.size(); i++) {\n    a[i] = (a[i] + b[i]) % MOD;\n  }\n  while (a.size() > 0 && a.back() == 0) {\n    a.pop_back();\n  }\n  return a;\n}\nstruct Mat {\n  std::array<std::array<std::vector<int>, 2>, 2> mat;\n  Mat() {\n    mat[0][0].push_back(1);\n    mat[1][1].push_back(1);\n  }\n  Mat(Mat a, Mat b) {\n    for (int i = 0; i < 2; i++) {\n      for (int j = 0; j < 2; j++) {\n        for (int k = 0; k < 2; k++) {\n          mat[i][k] = add(mat[i][k], mul(a.mat[i][j], b.mat[j][k]));\n        }\n      }\n    }\n  }\n} base[2];\nint as[100005];\nint bs[100005];\nMat solve(int l, int r) {\n  if (l == r) return Mat();\n  if (r - l == 1) {\n    return base[bs[l]];\n  } else {\n    int m = (l + r) / 2;\n    return Mat(solve(m, r), solve(l, m));\n  }\n}\nint fact[100005];\nint main() {\n  root[23] = RT23;\n  for (int i = 22; i >= 0; i--) {\n    root[i] = 1LL * root[i + 1] * root[i + 1] % MOD;\n  }\n  int N, M = 0;\n  scanf(\"%d\", &N);\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d\", &as[i]);\n  }\n  for (int i = 0; i < N; i += as[i]) {\n    if (std::count(as + i, as + i + as[i], as[i]) != as[i]) {\n      printf(\"0\\n\");\n      return 0;\n    }\n    bs[M++] = (as[i] > 1);\n  }\n  base[0].mat[0][0] = std::vector<int>({1});\n  base[0].mat[0][1] = std::vector<int>({1});\n  base[0].mat[1][0] = std::vector<int>({0, 2});\n  base[0].mat[1][1] = std::vector<int>({0, 1});\n  base[1].mat[0][0] = std::vector<int>();\n  base[1].mat[0][1] = std::vector<int>();\n  base[1].mat[1][0] = std::vector<int>({2, 2});\n  base[1].mat[1][1] = std::vector<int>({2, 1});\n  fact[0] = 1;\n  for (int i = 1; i <= M; i++) {\n    fact[i] = 1LL * i * fact[i - 1] % MOD;\n  }\n  Mat res = solve(1, M);\n  std::vector<int> poly =\n      mul(add(res.mat[0][bs[0]], res.mat[1][bs[0]]), bs[0] ? 2 : 1);\n  int ans = 0;\n  for (int i = 0; i < poly.size(); i++) {\n    ans = (ans + (i % 2 == 0 ? 1LL : MOD - 1LL) * poly[i] % MOD * fact[M - i]) %\n          MOD;\n  }\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst int MOD = 998244353;\nstruct Mint {\n  int val;\n  Mint() { val = 0; }\n  Mint(const ll& x) {\n    val = (-MOD <= x && x < MOD) ? x : x % MOD;\n    if (val < 0) val += MOD;\n  }\n  template <typename U>\n  explicit operator U() const {\n    return (U)val;\n  }\n  friend bool operator==(const Mint& a, const Mint& b) {\n    return a.val == b.val;\n  }\n  friend bool operator!=(const Mint& a, const Mint& b) { return !(a == b); }\n  friend bool operator<(const Mint& a, const Mint& b) { return a.val < b.val; }\n  Mint& operator+=(const Mint& m) {\n    if ((val += m.val) >= MOD) val -= MOD;\n    return *this;\n  }\n  Mint& operator-=(const Mint& m) {\n    if ((val -= m.val) < 0) val += MOD;\n    return *this;\n  }\n  Mint& operator*=(const Mint& m) {\n    val = (ll)val * m.val % MOD;\n    return *this;\n  }\n  friend Mint modex(Mint a, ll p) {\n    assert(p >= 0);\n    Mint ans = 1;\n    for (; p; p >>= 1, a *= a)\n      if (p & 1) ans *= a;\n    return ans;\n  }\n  Mint& operator/=(const Mint& m) { return *this *= modex(m, MOD - 2); }\n  Mint& operator++() { return *this += 1; }\n  Mint& operator--() { return *this -= 1; }\n  Mint operator++(int) {\n    Mint result(*this);\n    *this += 1;\n    return result;\n  }\n  Mint operator--(int) {\n    Mint result(*this);\n    *this -= 1;\n    return result;\n  }\n  Mint operator-() const { return Mint(-val); }\n  friend Mint operator+(Mint a, const Mint& b) { return a += b; }\n  friend Mint operator-(Mint a, const Mint& b) { return a -= b; }\n  friend Mint operator*(Mint a, const Mint& b) { return a *= b; }\n  friend Mint operator/(Mint a, const Mint& b) { return a /= b; }\n  friend ostream& operator<<(ostream& os, const Mint& x) { return os << x.val; }\n  friend string to_string(const Mint& b) { return to_string(b.val); }\n};\nnamespace fft {\nconst Mint gen = 3;\nvector<int> rev(1, 0);\nvector<Mint> roots;\nint base = 0;\nvoid precompute(int nbase) {\n  if (nbase <= base) return;\n  rev.resize(1 << nbase);\n  for (int i = 0; i < (1 << nbase); ++i) {\n    rev[i] = rev[i >> 1] >> 1 | ((i & 1) << (nbase - 1));\n  }\n  roots.resize(1 << nbase);\n  for (; base < nbase; ++base) {\n    int len = 1 << base;\n    Mint root = modex(gen, (MOD - 1) >> (base + 1));\n    roots[len] = 1;\n    for (int i = 1; i < len; ++i) roots[len + i] = roots[len + i - 1] * root;\n  }\n}\nvoid fft(vector<Mint>& a) {\n  int n = a.size();\n  assert((n & (n - 1)) == 0);\n  int zeros = __builtin_ctz(n);\n  precompute(zeros);\n  int shift = base - zeros;\n  for (int i = 0; i < n; ++i) {\n    if (i < (rev[i] >> shift)) swap(a[i], a[rev[i] >> shift]);\n  }\n  for (int len = 1; len < n; len <<= 1)\n    for (int i = 0; i < n; i += 2 * len)\n      for (int j = 0; j < len; ++j) {\n        Mint u = a[i + j], v = a[i + j + len] * roots[len + j];\n        a[i + j] = u + v;\n        a[i + j + len] = u - v;\n      }\n}\nvector<Mint> multiply(vector<Mint> a, vector<Mint> b) {\n  if (a.empty() || b.empty()) return {};\n  int sz = a.size() + b.size() - 1;\n  int n = sz == 1 ? 1 : 1 << (32 - __builtin_clz(sz - 1));\n  bool eq = (a == b);\n  a.resize(n);\n  fft(a);\n  if (eq)\n    b = a;\n  else {\n    b.resize(n);\n    fft(b);\n  }\n  Mint inv = Mint(1) / n;\n  for (int i = 0; i < n; ++i) a[i] *= b[i] * inv;\n  fft(a);\n  reverse(a.begin() + 1, a.end());\n  a.resize(sz);\n  return a;\n}\nvector<Mint> multiply(const vector<Mint>& a, const vector<Mint>& b, int m) {\n  assert(m == MOD);\n  return multiply(a, b);\n}\n};  // namespace fft\nnamespace polynomial {\nvector<Mint> subtract(vector<Mint> a, const vector<Mint>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < b.size(); ++i) {\n    a[i] -= b[i];\n  }\n  while (!a.empty() && a.back() == 0) a.pop_back();\n  return a;\n}\nvector<Mint> add(vector<Mint> a, const vector<Mint>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < b.size(); ++i) {\n    a[i] += b[i];\n  }\n  while (!a.empty() && a.back() == 0) a.pop_back();\n  return a;\n}\nvector<Mint> inverse(const vector<Mint>& a) {\n  assert(!a.empty() && a[0] != 0);\n  int n = a.size();\n  vector<Mint> b = {1 / a[0]};\n  for (int m = 2; b.size() < n; m <<= 1) {\n    vector<Mint> aCut(a.begin(), a.begin() + min((int)a.size(), m));\n    aCut.resize(2 * m);\n    b.resize(2 * m);\n    fft::fft(aCut);\n    fft::fft(b);\n    for (int i = 0; i < 2 * m; ++i) {\n      b[i] *= 2 - aCut[i] * b[i];\n    }\n    fft::fft(b);\n    reverse(b.begin() + 1, b.end());\n    b.resize(m);\n    Mint inv = Mint(1) / (2 * m);\n    for (int i = 0; i < m; ++i) b[i] *= inv;\n  }\n  b.resize(n);\n  return b;\n}\nvector<Mint> divide(vector<Mint> a, vector<Mint> b) {\n  assert(!b.empty() && b.back() != 0);\n  int n = a.size();\n  int m = b.size();\n  if (n < m) return {};\n  reverse(a.begin(), a.end());\n  reverse(b.begin(), b.end());\n  b.resize(n - m + 1);\n  a = fft::multiply(a, inverse(b), MOD);\n  a.erase(a.begin() + n - m + 1, a.end());\n  reverse(a.begin(), a.end());\n  return a;\n}\nvector<Mint> remainder(const vector<Mint>& a, const vector<Mint>& b) {\n  return subtract(a, fft::multiply(b, divide(a, b), MOD));\n}\nvector<Mint> integral(const vector<Mint>& a) {\n  vector<Mint> ret(a.size() + 1);\n  for (int i = 1; i < ret.size(); ++i) {\n    ret[i] = a[i - 1] / i;\n  }\n  return ret;\n}\nvector<Mint> derivative(const vector<Mint>& a) {\n  if (a.empty()) return a;\n  vector<Mint> ret(a.size() - 1);\n  for (int i = 0; i + 1 < a.size(); ++i) ret[i] = a[i + 1] * (i + 1);\n  return ret;\n}\nvector<Mint> logarithm(const vector<Mint>& a) {\n  assert(!a.empty() && a[0] == 1);\n  auto ret = integral(fft::multiply(derivative(a), inverse(a), MOD));\n  ret.resize(a.size());\n  return ret;\n}\nvector<Mint> exponent(const vector<Mint>& a) {\n  assert(!a.empty() && a[0] == 0);\n  int n = a.size();\n  vector<Mint> b = {1};\n  for (int m = 2; b.size() < n; m <<= 1) {\n    vector<Mint> x(a.begin(), a.begin() + min((int)a.size(), m));\n    ++x[0];\n    auto oldB = b;\n    b.resize(m);\n    b = fft::multiply(oldB, subtract(x, logarithm(b)), MOD);\n    b.resize(m);\n  }\n  b.resize(n);\n  return b;\n}\nvector<Mint> multipoint(const vector<Mint>& a, vector<Mint> xs) {\n  int n = xs.size();\n  vector<vector<Mint>> prods(2 * n - 1);\n  function<void(int, int, int)> getProds = [&](int sn, int s, int e) {\n    if (s == e) {\n      prods[sn] = {-xs[s], 1};\n      return;\n    }\n    int m = (s + e) >> 1, lsn = sn + 1, rsn = sn + ((m - s + 1) << 1);\n    getProds(lsn, s, m);\n    getProds(rsn, m + 1, e);\n    prods[sn] = fft::multiply(prods[lsn], prods[rsn], MOD);\n  };\n  getProds(0, 0, n - 1);\n  function<void(int, int, int, vector<Mint>)> calc = [&](int sn, int s, int e,\n                                                         vector<Mint> f) {\n    if (s == e) {\n      xs[s] = f.empty() ? 0 : f[0];\n      return;\n    }\n    int m = (s + e) >> 1, lsn = sn + 1, rsn = sn + ((m - s + 1) << 1);\n    calc(lsn, s, m, remainder(f, prods[lsn]));\n    calc(rsn, m + 1, e, remainder(f, prods[rsn]));\n  };\n  calc(0, 0, n - 1, a);\n  return xs;\n}\nvector<Mint> chirpz(vector<Mint> a, Mint g, int n) {\n  int d = a.size();\n  int phi = MOD - 1;\n  vector<Mint> pw(phi + 1);\n  pw[0] = 1;\n  for (int i = 1; i <= phi; ++i) pw[i] = pw[i - 1] * g;\n  auto chirpzEven = [&](const vector<Mint>& b, int m) {\n    vector<Mint> u(d), v(m + d - 1);\n    for (int i = 0; i < d; ++i) {\n      u[i] = b[i] * pw[(ll)i * i % phi];\n    }\n    for (int i = -(d - 1); i < m; ++i) {\n      v[d - 1 + i] = pw[phi - (ll)i * i % phi];\n    }\n    auto z = fft::multiply(u, v, MOD);\n    vector<Mint> ret(m);\n    for (int i = 0; i < m; ++i) {\n      ret[i] = pw[(ll)i * i % phi] * z[d - 1 + i];\n    }\n    return ret;\n  };\n  auto even = chirpzEven(a, (n + 1) >> 1);\n  for (int i = 0; i < d; ++i) a[i] *= pw[i % phi];\n  auto odd = chirpzEven(a, n >> 1);\n  vector<Mint> ret(n);\n  for (int i = 0; i < n; ++i) {\n    ret[i] = (i & 1) ? odd[i >> 1] : even[i >> 1];\n  }\n  return ret;\n}\nvector<Mint> powerMod(const vector<Mint>& a, ll p, const vector<Mint>& b) {\n  if (!p) return {1};\n  vector<Mint> c;\n  if (p & 1) {\n    c = fft::multiply(powerMod(a, p - 1, b), a, MOD);\n  } else {\n    c = powerMod(a, p >> 1, b);\n    c = fft::multiply(c, c, MOD);\n  }\n  return remainder(c, b);\n}\nvector<Mint> power(vector<Mint> a, ll p, int n) {\n  if (!p) return {1};\n  assert(a.size() <= n);\n  int m = 0;\n  while (m < a.size() && a[m] == 0) ++m;\n  if (m * p >= n) return {};\n  a.erase(a.begin(), a.begin() + m);\n  Mint inv = 1 / a[0];\n  Mint c = modex(a[0], p);\n  for (Mint& x : a) x *= inv;\n  a = logarithm(a);\n  Mint q = p;\n  for (Mint& x : a) x *= q;\n  a = exponent(a);\n  a.insert(a.begin(), m * p, 0);\n  a.resize(n);\n  for (Mint& x : a) x *= c;\n  return a;\n}\nvector<Mint> multiplyAll(const vector<vector<Mint>>& polys, int s, int e) {\n  if (s == e) return polys[s];\n  int m = (s + e) >> 1;\n  auto a = multiplyAll(polys, s, m);\n  auto b = multiplyAll(polys, m + 1, e);\n  return fft::multiply(a, b, MOD);\n}\nvector<Mint> multiplyAll(const vector<vector<Mint>>& polys) {\n  return polys.empty() ? vector<Mint>{1}\n                       : multiplyAll(polys, 0, polys.size() - 1);\n}\ntemplate <typename T>\nvector<T>& operator+=(vector<T>& a, const vector<T>& b) {\n  a.resize(max(a.size(), b.size()));\n  for (int i = 0; i < b.size(); ++i) a[i] += b[i];\n  return a;\n}\ntemplate <typename T>\nvector<T> operator+(vector<T> a, const vector<T>& b) {\n  return a += b;\n}\ntemplate <typename T>\nvector<T>& operator-=(vector<T>& a, const vector<T>& b) {\n  a.resize(max(a.size(), b.size()));\n  for (int i = 0; i < b.size(); ++i) a[i] -= b[i];\n  return a;\n}\ntemplate <typename T>\nvector<T> operator-(vector<T> a, const vector<T>& b) {\n  return a -= b;\n}\ntemplate <typename T>\nvector<T> operator-(vector<T> a) {\n  for (int i = 0; i < a.size(); ++i) a[i] = -a[i];\n  return a;\n}\ntemplate <typename T>\nvector<T> operator+=(vector<T>& a, const T& b) {\n  for (int i = 0; i < a.size(); ++i) a[i] += b;\n  return a;\n}\ntemplate <typename T>\nvector<T> operator-=(vector<T>& a, const T& b) {\n  for (int i = 0; i < a.size(); ++i) a[i] -= b;\n  return a;\n}\ntemplate <typename T>\nvector<T> operator*=(vector<T>& a, const T& b) {\n  for (int i = 0; i < a.size(); ++i) a[i] *= b;\n  return a;\n}\ntemplate <typename T>\nvector<T> operator/=(vector<T>& a, const T& b) {\n  for (int i = 0; i < a.size(); ++i) a[i] /= b;\n  return a;\n}\ntemplate <typename T>\nvector<T> operator+(vector<T> a, const T& b) {\n  return a += b;\n}\ntemplate <typename T>\nvector<T> operator-(vector<T> a, const T& b) {\n  return a -= b;\n}\ntemplate <typename T>\nvector<T> operator*(vector<T> a, const T& b) {\n  return a *= b;\n}\ntemplate <typename T>\nvector<T> operator/(vector<T> a, const T& b) {\n  return a /= b;\n}\ntemplate <typename T>\nvector<T>& operator*=(vector<T>& a, const vector<T>& b) {\n  return a = fft::multiply(a, b);\n}\ntemplate <typename T>\nvector<T> operator*(vector<T> a, const vector<T>& b) {\n  return a *= b;\n}\n};  // namespace polynomial\nusing namespace polynomial;\nvector<Mint> fac(1, 1), invfac(1, 1);\nMint binom(int n, int k) {\n  if (k < 0 || k > n) return 0;\n  while (fac.size() <= n) {\n    fac.push_back(fac.back() * fac.size());\n    invfac.push_back(1 / fac.back());\n  }\n  return fac[n] * invfac[k] * invfac[n - k];\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vector<int> A(n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", &A[i]);\n  }\n  int las = 0;\n  vector<int> R = {A[0]};\n  for (int i = 1; i < n; ++i) {\n    if (i - las == A[las]) {\n      R.push_back(A[i]);\n      las = i;\n    }\n    if (A[i] != A[las]) {\n      printf(\"0\\n\");\n      return 0;\n    }\n  }\n  assert(accumulate(R.begin(), R.end(), 0) == n);\n  Mint inv2 = Mint(1) / 2;\n  function<array<array<vector<Mint>, 2>, 2>(int, int)> solve = [&](int l,\n                                                                   int r) {\n    array<array<vector<Mint>, 2>, 2> ret;\n    if (l == r) {\n      if (R[l] == 1) {\n        ret[0][0] = {0, 1};\n      } else {\n        ret[1][1] = {0, 2};\n      }\n      return ret;\n    }\n    int m = (l + r) >> 1;\n    auto a = solve(l, m);\n    auto b = solve(m + 1, r);\n    for (int i = 0; i < 2; ++i)\n      for (int j = 0; j < 2; ++j) {\n        vector<Mint> merged = (a[i][0] + a[i][1]) * (b[0][j] + b[1][j]);\n        ret[i][j] += merged;\n        merged += a[i][0] * b[0][j];\n        merged -= a[i][1] * b[1][j] * inv2;\n        if (!merged.empty()) merged.erase(merged.begin());\n        int ii = i, jj = j;\n        if (l == m && R[l] == 1) ii = 1;\n        if (m + 1 == r && R[r] == 1) jj = 1;\n        ret[ii][jj] += merged;\n      }\n    42;\n    return ret;\n  };\n  int r = R.size();\n  auto v = solve(0, r - 1);\n  vector<Mint> ret;\n  for (int i = 0; i < 2; ++i)\n    for (int j = 0; j < 2; ++j) ret += v[i][j];\n  ret.resize(r + 1);\n  42;\n  Mint ans = 0;\n  binom(r, 0);\n  for (int i = 1; i <= r; ++i) {\n    int sgn = (r - i) % 2 == 0 ? 1 : -1;\n    ans += ret[i] * fac[i] * sgn;\n  }\n  printf(\"%d\\n\", ans.val);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MOD = 998244353;\nconst int HALF = (MOD + 1) / 2;\nconst int RT23 = 15311432;\nint root[24];\nvoid ntt(std::vector<int>& v, bool inv = false) {\n  int K = 0;\n  while ((1 << K) < v.size()) K++;\n  v.resize(1 << K);\n  if (inv) std::reverse(v.begin() + 1, v.end());\n  int rev = 0;\n  for (int i = 0; i < (1 << K); i++) {\n    if (i < rev) std::swap(v[i], v[rev]);\n    if (i == (1 << K) - 1) break;\n    int k = K - 1;\n    while (rev & (1 << k)) {\n      rev ^= (1 << k);\n      k--;\n    }\n    rev |= (1 << k);\n  }\n  for (int k = 0; k < K; k++) {\n    int opow = 1;\n    for (int i = 0; i < (1 << K); i++) {\n      if (i & (1 << k)) {\n        opow = 1;\n        continue;\n      }\n      int j = i | (1 << k);\n      int x = v[i], y = v[j];\n      v[i] = (x + 1LL * y * opow) % MOD;\n      v[j] = (x + (MOD - 1LL) * y % MOD * opow) % MOD;\n      opow = (1LL * opow * root[k + 1]) % MOD;\n    }\n  }\n  if (inv) {\n    int invN = 1;\n    for (int i = 0; i < K; i++) {\n      invN = (1LL * invN * HALF) % MOD;\n    }\n    for (int i = 0; i < (1 << K); i++) {\n      v[i] = (1LL * v[i] * invN) % MOD;\n    }\n  }\n}\nstd::vector<int> mul(std::vector<int> a, std::vector<int> b) {\n  if (a.empty() || b.empty()) return {};\n  int size = 1;\n  while (size < a.size() || size < b.size()) size *= 2;\n  size *= 2;\n  a.resize(size);\n  b.resize(size);\n  ntt(a);\n  ntt(b);\n  for (int i = 0; i < a.size(); i++) {\n    a[i] = (1LL * a[i] * b[i]) % MOD;\n  }\n  ntt(a, true);\n  while (a.size() > 0 && a.back() == 0) {\n    a.pop_back();\n  }\n  return a;\n}\nstd::vector<int> mul(std::vector<int> a, int b) {\n  for (int i = 0; i < a.size(); i++) {\n    a[i] = (1LL * a[i] * b) % MOD;\n  }\n  return a;\n}\nstd::vector<int> add(std::vector<int> a, const std::vector<int>& b) {\n  if (b.size() > a.size()) a.resize(b.size());\n  for (int i = 0; i < b.size(); i++) {\n    a[i] = (a[i] + b[i]) % MOD;\n  }\n  return a;\n}\nstruct Mat {\n  std::array<std::array<std::vector<int>, 2>, 2> mat;\n  Mat() {\n    mat[0][0].push_back(1);\n    mat[1][1].push_back(1);\n  }\n  Mat(Mat a, Mat b) {\n    for (int i = 0; i < 2; i++) {\n      for (int j = 0; j < 2; j++) {\n        for (int k = 0; k < 2; k++) {\n          mat[i][k] = add(mat[i][k], mul(a.mat[i][j], b.mat[j][k]));\n        }\n      }\n    }\n  }\n  void dump() {\n    for (int s = 0; s < 2; s++) {\n      for (int t = 0; t < 2; t++) {\n        printf(\"M[%d][%d]:\", s, t);\n        for (int i = 0; i < mat[s][t].size(); i++) {\n          printf(\" +%dx^%d\", mat[s][t][i], i);\n        }\n        printf(\"\\n\");\n      }\n    }\n  }\n} base[2];\nint as[100005];\nint bs[100005];\nMat solve(int l, int r) {\n  if (l == r) return Mat();\n  if (r - l == 1) {\n    return base[bs[l]];\n  } else {\n    int m = (l + r) / 2;\n    return Mat(solve(m, r), solve(l, m));\n  }\n}\nint fact[100005];\nint main() {\n  root[23] = RT23;\n  for (int i = 22; i >= 0; i--) {\n    root[i] = 1LL * root[i + 1] * root[i + 1] % MOD;\n  }\n  int N, M = 0;\n  scanf(\"%d\", &N);\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d\", &as[i]);\n  }\n  for (int i = 0; i < N; i += as[i]) {\n    if (std::count(as + i, as + i + as[i], as[i]) != as[i]) {\n      printf(\"0\\n\");\n      return 0;\n    }\n    bs[M++] = (as[i] > 1);\n  }\n  base[0].mat[0][0] = std::vector<int>({1});\n  base[0].mat[0][1] = std::vector<int>({1});\n  base[0].mat[1][0] = std::vector<int>({0, 2});\n  base[0].mat[1][1] = std::vector<int>({0, 1});\n  base[1].mat[0][0] = std::vector<int>();\n  base[1].mat[0][1] = std::vector<int>();\n  base[1].mat[1][0] = std::vector<int>({2, 2});\n  base[1].mat[1][1] = std::vector<int>({2, 1});\n  fact[0] = 1;\n  for (int i = 1; i <= M; i++) {\n    fact[i] = 1LL * i * fact[i - 1] % MOD;\n  }\n  Mat res = solve(1, M);\n  std::vector<int> poly =\n      mul(add(res.mat[0][bs[0]], res.mat[1][bs[0]]), bs[0] ? 2 : 1);\n  int ans = 0;\n  for (int i = 0; i < poly.size(); i++) {\n    ans = (ans + (i % 2 == 0 ? 1LL : MOD - 1LL) * poly[i] % MOD * fact[M - i]) %\n          MOD;\n  }\n  printf(\"%d\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 131072, P = 998244353;\nint n, m, ans, a[maxn], b[maxn], fact[maxn], finv[maxn];\nint lim, l, r[maxn], w[maxn];\nvector<int> V;\nvector<int> f[maxn << 2][2][2];\nint qp(int x, int y) {\n  int z = 1;\n  for (; y; y >>= 1, x = 1LL * x * x % P) {\n    if (y & 1) z = 1LL * z * x % P;\n  }\n  return z;\n}\nvoid init() {\n  for (int i = 0; i < lim; i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << (l - 1));\n  w[lim >> 1] = 1;\n  int t = qp(3, (P - 1) / lim);\n  for (int i = (lim >> 1) + 1; i < lim; i++) w[i] = 1LL * t * w[i - 1] % P;\n  for (int i = (lim >> 1) - 1; i > 0; i--) w[i] = w[i << 1];\n}\nvoid DFT(int *a, int type) {\n  static unsigned long long c[maxn];\n  copy(a, a + lim, c);\n  for (int i = 0; i < lim; i++)\n    if (i < r[i]) swap(c[i], c[r[i]]);\n  for (int i = 1; i < lim; i <<= 1) {\n    for (int j = 0; j < lim; j += i << 1) {\n      for (int k = 0; k < i; k++) {\n        unsigned long long t = c[i + j + k] * w[i + k] % P;\n        c[i + j + k] = c[j + k] + P - t, c[j + k] += t;\n      }\n    }\n  }\n  if (!~type) {\n    reverse(c + 1, c + lim);\n    for (int i = 0, t = qp(lim, P - 2); i < lim; i++) c[i] = c[i] % P * t % P;\n  }\n  for (int i = 0; i < lim; i++) a[i] = c[i] % P;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = fact[0] = finv[0] = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    fact[i] = 1LL * i * fact[i - 1] % P;\n    finv[i] = qp(fact[i], P - 2);\n  }\n  for (int i = 1; i <= n; i += a[i]) {\n    b[++m] = a[i];\n    for (int j = i; j < i + a[i]; j++) {\n      if (a[i] ^ a[j]) puts(\"0\"), exit(0);\n    }\n  }\n  function<void(int, int, int)> solve = [&](int k, int l, int r) {\n    if (l == r) {\n      f[k][0][0] = {0, b[l] == 1 ? (P + 1) / 2 : 1};\n      f[k][0][1] = f[k][1][0] = f[k][1][1] = {0, 1};\n      return;\n    }\n    int mid = (l + r) / 2, ls = k << 1, rs = k << 1 | 1;\n    solve(ls, l, mid), solve(rs, mid + 1, r);\n    for (lim = 1, ::l = 0; lim <= r - l + 1; lim <<= 1) ::l++;\n    init();\n    for (int p : {0, 1})\n      for (int q : {0, 1}) {\n        f[k][p][q].resize(lim);\n        if (q) f[ls][p][q].erase(f[ls][p][q].begin());\n        f[ls][p][q].resize(lim), f[rs][p][q].resize(lim);\n        DFT(f[ls][p][q].data(), 1), DFT(f[rs][p][q].data(), 1);\n      }\n    for (int a : {0, 1})\n      for (int b : {0, 1})\n        for (int c : {0, 1}) {\n          for (int i = 0; i < lim; i++) {\n            f[k][a][c][i] =\n                (f[k][a][c][i] + 1LL * f[ls][a][b][i] * f[rs][b][c][i]) % P;\n          }\n        }\n    for (int p : {0, 1})\n      for (int q : {0, 1}) {\n        DFT(f[k][p][q].data(), -1), f[k][p][q].resize(r - l + 2);\n      }\n  };\n  solve(1, 1, m);\n  for (int i = 1; i <= m; i++) {\n    ans = (ans + 1LL * fact[i] * f[1][0][0][i] % P * qp(2, i) % P *\n                     ((m - i) & 1 ? P - 1 : 1)) %\n          P;\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100005, mod = 998244353, o = 17, len = 1 << o,\n          i2 = (mod + 1) >> 1;\nint n, a[N], cnt, ans, tot, f[N], fac[N];\nbool op[N];\ninline int add(int x, int y) { return x + y < mod ? x + y : x + y - mod; }\ninline int sub(int x, int y) { return x < y ? x + mod - y : x - y; }\ninline int power(int a, int n) {\n  int tp = 1;\n  while (n) {\n    if (n & 1) tp = 1ll * tp * a % mod;\n    a = 1ll * a * a % mod, n >>= 1;\n  }\n  return tp;\n}\nnamespace poly {\nint w[len], r[len], up, l;\nvoid init() {\n  const int w0 = power(3, (mod - 1) >> o);\n  w[len >> 1] = 1;\n  for (int i = (len >> 1) + 1; i < len; i++) w[i] = 1ll * w[i - 1] * w0 % mod;\n  for (int i = (len >> 1) - 1; i; i--) w[i] = w[i << 1];\n}\ninline void pre(int n) {\n  up = 2, l = 1;\n  while (up <= n) up <<= 1, l++;\n  for (int i = 0; i < up; i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << (l - 1));\n}\nvoid ntt(int *a, int n, bool op) {\n  static unsigned long long t[len], x, y;\n  for (int i = 0; i < n; i++) t[i] = a[r[i]];\n  for (int l = 1; l < n; l <<= 1) {\n    int *k = w + l;\n    for (unsigned long long *f = t; f != t + n; f += l)\n      for (int *j = k; j != k + l; j++, f++) {\n        x = *f, y = f[l] * *j % mod;\n        f[l] = x + mod - y, *f += y;\n      }\n  }\n  if (op) {\n    for (int i = 0, x = mod - ((mod - 1) >> l); i < n; i++)\n      a[i] = t[i] * x % mod;\n    reverse(a + 1, a + n);\n  } else\n    for (int i = 0; i < n; i++) a[i] = t[i] % mod;\n}\n}  // namespace poly\nnamespace cdq {\nusing namespace poly;\nint tot, vf[2][2][len << 5];\nint *f[len << 1][2][2];\nvoid solve(int i, int l, int r) {\n  static int a[8][len], b[len], c[len];\n  for (int o1 = 0; o1 < 2; o1++)\n    for (int o2 = 0; o2 < 2; o2++) f[i][o1][o2] = vf[o1][o2] + tot;\n  tot += r - l + 1;\n  if (r - l == 1) {\n    if (op[l]) {\n      if (op[r])\n        f[i][0][0][0] = 1, f[i][1][1][1] = 4;\n      else\n        f[i][0][1][0] = 1, f[i][1][1][1] = 2;\n    } else {\n      if (op[r])\n        f[i][1][0][0] = 1, f[i][1][1][1] = 2;\n      else\n        f[i][1][1][0] = f[i][1][1][1] = 1;\n    }\n    return;\n  }\n  if (r - l == 2) {\n    if (op[l]) {\n      if (op[r]) {\n        if (op[l + 1])\n          f[i][0][0][0] = 1, f[i][1][0][1] = f[i][0][1][1] = 4,\n          f[i][1][1][2] = 8;\n        else\n          f[i][0][0][0] = 1, f[i][1][0][1] = f[i][0][1][1] = 2,\n          f[i][1][1][2] = 4;\n      } else {\n        if (op[l + 1])\n          f[i][0][1][0] = 1, f[i][1][1][1] = 4, f[i][0][1][1] = 2,\n          f[i][1][1][2] = 4;\n        else\n          f[i][0][1][0] = 1, f[i][1][1][1] = 2, f[i][0][1][1] = 1,\n          f[i][1][1][2] = 2;\n      }\n    } else {\n      if (op[r]) {\n        if (op[l + 1])\n          f[i][1][0][0] = 1, f[i][1][0][1] = 2, f[i][1][1][1] = 4,\n          f[i][1][1][2] = 4;\n        else\n          f[i][1][0][0] = 1, f[i][1][0][1] = 1, f[i][1][1][1] = 2,\n          f[i][1][1][2] = 2;\n      } else {\n        if (op[l + 1])\n          f[i][1][1][0] = 1, f[i][1][1][1] = 4, f[i][1][1][2] = 2;\n        else\n          f[i][1][1][0] = 1, f[i][1][1][1] = 2, f[i][1][1][2] = 1;\n      }\n    }\n    return;\n  }\n  int mid = (l + r) >> 1, l1 = mid - l, l2 = r - mid - 1;\n  solve(i << 1, l, mid), solve(i << 1 | 1, mid + 1, r);\n  pre(r - l - 1);\n  memcpy(a[0], f[i << 1][0][0], (l1 + 1) << 2);\n  memcpy(a[1], f[i << 1][0][1], (l1 + 1) << 2);\n  memcpy(a[2], f[i << 1][1][0], (l1 + 1) << 2);\n  memcpy(a[3], f[i << 1][1][1], (l1 + 1) << 2);\n  memcpy(a[4], f[i << 1 | 1][0][0], (l2 + 1) << 2);\n  memcpy(a[5], f[i << 1 | 1][0][1], (l2 + 1) << 2);\n  memcpy(a[6], f[i << 1 | 1][1][0], (l2 + 1) << 2);\n  memcpy(a[7], f[i << 1 | 1][1][1], (l2 + 1) << 2);\n  for (int j = 0; j < 8; j++) ntt(a[j], up, 0);\n  for (int o1 = 0; o1 < 2; o1++)\n    for (int o2 = 0; o2 < 2; o2++) {\n      for (int j = 0; j < up; j++) {\n        b[j] = (b[j] + 1ll * a[o1 * 2][j] * a[4 + o2][j] +\n                1ll * a[o1 * 2][j] * a[6 + o2][j] +\n                1ll * a[o1 * 2 + 1][j] * a[4 + o2][j] +\n                1ll * a[o1 * 2 + 1][j] * a[6 + o2][j]) %\n               mod;\n        c[j] = (c[j] + 4ll * a[o1 * 2][j] * a[4 + o2][j] +\n                2ll * a[o1 * 2][j] * a[6 + o2][j] +\n                2ll * a[o1 * 2 + 1][j] * a[4 + o2][j] +\n                1ll * a[o1 * 2 + 1][j] * a[6 + o2][j]) %\n               mod;\n      }\n      ntt(b, up, 1), ntt(c, up, 1);\n      memcpy(f[i][o1][o2], b, (r - l) << 2);\n      for (int j = 1; j <= r - l; j++)\n        f[i][o1][o2][j] = add(f[i][o1][o2][j], c[j - 1]);\n      memset(b, 0, up << 2), memset(c, 0, up << 2);\n    }\n  for (int j = 0; j < 8; j++) memset(a[j], 0, up << 2);\n}\n}  // namespace cdq\nint main() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) scanf(\"%d\", a + i);\n  for (int i = 1; i <= n; i += a[i]) {\n    for (int k = i; k < i + a[i]; k++)\n      if (a[k] != a[i]) {\n        cout << 0;\n        return 0;\n      }\n    cnt++;\n    if (a[i] == 1) op[cnt] = 1, tot++;\n  }\n  if (cnt == 1) {\n    cout << 2 - op[1];\n    return 0;\n  }\n  fac[0] = 1;\n  for (int i = 1; i <= cnt; i++) fac[i] = 1ll * fac[i - 1] * i % mod;\n  poly::init(), cdq::solve(1, 1, cnt);\n  for (int i = 0, x = power(2, cnt - tot); i < cnt;\n       i++, x = 1ll * x * i2 % mod) {\n    int s = 0;\n    for (int o1 = 0; o1 < 2; o1++)\n      for (int o2 = 0; o2 < 2; o2++) s = add(s, cdq::f[1][o1][o2][i]);\n    if (i & 1)\n      ans = sub(ans, 1ll * x * s % mod * fac[cnt - i] % mod);\n    else\n      ans = (ans + 1ll * x * s % mod * fac[cnt - i]) % mod;\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(3)\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(2)\nusing namespace std;\nconst long long mod = 998244353, g = 3, ginv = 332748118, N = 4e5 + 10,\n                inv2 = 499122177;\nlong long qpow(long long x, long long y) {\n  long long ans = 1;\n  while (y) {\n    if (y & 1) (ans *= x) %= mod;\n    (x *= x) %= mod;\n    y >>= 1;\n  }\n  return ans;\n}\nlong long rr[N];\nlong long gg[N], gginv[N], lim[N];\nlong long cnt;\nvector<long long> NTT(vector<long long> a, long long limit, long long type) {\n  for (long long i = 0; i < limit; i++)\n    if (rr[i] < i) swap(a[rr[i]], a[i]);\n  for (long long mid = 1; mid < limit; mid <<= 1) {\n    long long wn = type == 1 ? gg[mid << 1] : gginv[mid << 1];\n    for (long long j = 0; j < limit; j += (mid << 1)) {\n      long long w = 1;\n      for (long long k = 0; k < mid; k++, (w *= wn) %= mod) {\n        cnt++;\n        long long x = a[j + k], y = w * a[j + k + mid] % mod;\n        a[j + k] = (x + y) % mod;\n        a[j + k + mid] = (x - y + mod) % mod;\n      }\n    }\n  }\n  if (~type) return a;\n  for (long long i = 0; i < limit; i++) (a[i] *= lim[limit]) %= mod;\n  return a;\n}\nvector<long long> add(vector<long long> a, vector<long long> b) {\n  long long n = a.size(), m = b.size();\n  while (n < m) a.push_back(0), n++;\n  while (n > m) b.push_back(0), m++;\n  for (long long i = 0; i < n; i++) (a[i] += b[i]) %= mod;\n  return a;\n}\nvector<long long> add_(vector<long long> a, vector<long long> b) {\n  long long n = a.size(), m = b.size();\n  while (n < m) a.push_back(0), n++;\n  while (n > m) b.push_back(0), m++;\n  for (long long i = 0; i < n - 1; i++) (a[i] += b[i + 1]) %= mod;\n  return a;\n}\nvector<long long> div(vector<long long> a) {\n  long long n = a.size();\n  for (long long i = 0; i < n; i++) (a[i] *= inv2) %= mod;\n  return a;\n}\nvector<long long> mul(vector<long long> a, long long x) {\n  long long n = a.size();\n  for (long long i = 0; i < n; i++) (a[i] *= x) %= mod;\n  return a;\n}\nstruct zj {\n  vector<long long> a[2][2];\n  zj() {\n    a[0][0].push_back(0), a[0][1].push_back(0), a[1][0].push_back(0),\n        a[1][1].push_back(0);\n  }\n};\nlong long n, a[N], b[N], m;\nvector<long long> mul(vector<long long> a, vector<long long> b) {\n  long long limit = 1, l = 0, n = a.size(), m = b.size();\n  while (limit <= n + m) limit <<= 1, l++;\n  for (long long i = 0; i < limit; i++)\n    rr[i] = (rr[i >> 1] >> 1) | ((i & 1) << (l - 1));\n  while (n < limit) a.push_back(0), n++;\n  while (m < limit) b.push_back(0), m++;\n  a = NTT(a, limit, 1);\n  b = NTT(b, limit, 1);\n  for (long long i = 0; i < limit; i++) (a[i] *= b[i]) %= mod;\n  a = NTT(a, limit, -1);\n  while (a.size() > 1 && a[a.size() - 1] == 0) a.pop_back();\n  return a;\n}\nvector<long long> mul_(vector<long long> a, vector<long long> b) {\n  long long n = a.size(), m = b.size();\n  while (n < m) a.push_back(0), n++;\n  while (n > m) b.push_back(0), m++;\n  for (long long i = 0; i < n; i++) (a[i] *= b[i]) %= mod;\n  return a;\n}\nzj merge(long long l, long long r) {\n  if (l == r) {\n    zj x;\n    if (a[l] == 1)\n      x.a[0][0].push_back(1);\n    else\n      x.a[1][1].push_back(2);\n    return x;\n  }\n  long long mid = (l + r) >> 1;\n  zj x = merge(l, mid), y = merge(mid + 1, r);\n  zj tmp, tmpp;\n  if (l + 1 == r) {\n    for (long long i = 0; i < 2; i++)\n      for (long long j = 0; j < 2; j++)\n        for (long long ii = 0; ii < 2; ii++)\n          for (long long jj = 0; jj < 2; jj++)\n            tmp.a[i][j] = add(tmp.a[i][j], mul(x.a[i][ii], y.a[jj][j]));\n    for (long long i = 0; i < 2; i++)\n      for (long long j = 0; j < 2; j++)\n        for (long long ii = 0; ii < 2; ii++)\n          for (long long jj = 0; jj < 2; jj++)\n            if (ii != jj)\n              tmp.a[1][1] = add_(tmp.a[1][1], mul(x.a[i][ii], y.a[jj][j]));\n            else if (!ii)\n              tmp.a[1][1] =\n                  add_(tmp.a[1][1], mul(mul(x.a[i][ii], y.a[jj][j]), 2));\n            else\n              tmp.a[1][1] = add_(tmp.a[1][1], div(mul(x.a[i][ii], y.a[jj][j])));\n    return tmp;\n  } else if (l + 2 == r) {\n    for (long long i = 0; i < 2; i++)\n      for (long long j = 0; j < 2; j++)\n        for (long long ii = 0; ii < 2; ii++)\n          for (long long jj = 0; jj < 2; jj++)\n            tmp.a[i][j] = add(tmp.a[i][j], mul(x.a[i][ii], y.a[jj][j]));\n    for (long long i = 0; i < 2; i++)\n      for (long long j = 0; j < 2; j++)\n        for (long long ii = 0; ii < 2; ii++)\n          for (long long jj = 0; jj < 2; jj++)\n            if (ii != jj)\n              tmp.a[i][1] = add_(tmp.a[i][1], mul(x.a[i][ii], y.a[jj][j]));\n            else if (!ii)\n              tmp.a[i][1] =\n                  add_(tmp.a[i][1], mul(mul(x.a[i][ii], y.a[jj][j]), 2));\n            else\n              tmp.a[i][1] = add_(tmp.a[i][1], div(mul(x.a[i][ii], y.a[jj][j])));\n    return tmp;\n  }\n  long long limit = 1, llll = 0, lena = 0, lenb = 0;\n  for (long long i = 0; i < 2; i++)\n    for (long long j = 0; j < 2; j++)\n      lena = max(lena, (long long)x.a[i][j].size());\n  for (long long i = 0; i < 2; i++)\n    for (long long j = 0; j < 2; j++)\n      lenb = max(lenb, (long long)y.a[i][j].size());\n  while (limit <= lena + lenb) limit <<= 1, llll++;\n  for (long long i = 0; i < limit; i++)\n    rr[i] = (rr[i >> 1] >> 1) | ((i & 1) << (llll - 1));\n  for (long long i = 0; i < 2; i++)\n    for (long long j = 0; j < 2; j++)\n      while (x.a[i][j].size() < limit) x.a[i][j].push_back(0);\n  for (long long i = 0; i < 2; i++)\n    for (long long j = 0; j < 2; j++)\n      while (y.a[i][j].size() < limit) y.a[i][j].push_back(0);\n  for (long long i = 0; i < 2; i++)\n    for (long long j = 0; j < 2; j++)\n      while (tmp.a[i][j].size() < limit) tmp.a[i][j].push_back(0);\n  for (long long i = 0; i < 2; i++)\n    for (long long j = 0; j < 2; j++)\n      while (tmpp.a[i][j].size() < limit) tmpp.a[i][j].push_back(0);\n  for (long long i = 0; i < 2; i++)\n    for (long long j = 0; j < 2; j++) x.a[i][j] = NTT(x.a[i][j], limit, 1);\n  for (long long i = 0; i < 2; i++)\n    for (long long j = 0; j < 2; j++) y.a[i][j] = NTT(y.a[i][j], limit, 1);\n  for (long long i = 0; i < 2; i++)\n    for (long long j = 0; j < 2; j++)\n      for (long long ii = 0; ii < 2; ii++)\n        for (long long jj = 0; jj < 2; jj++)\n          tmp.a[i][j] = add(tmp.a[i][j], mul_(x.a[i][ii], y.a[jj][j]));\n  for (long long i = 0; i < 2; i++)\n    for (long long j = 0; j < 2; j++)\n      for (long long ii = 0; ii < 2; ii++)\n        for (long long jj = 0; jj < 2; jj++)\n          if (ii != jj)\n            tmpp.a[i][j] = add(tmpp.a[i][j], mul_(x.a[i][ii], y.a[jj][j]));\n          else if (!ii)\n            tmpp.a[i][j] =\n                add(tmpp.a[i][j], mul(mul_(x.a[i][ii], y.a[jj][j]), 2));\n          else\n            tmpp.a[i][j] = add(tmpp.a[i][j], div(mul_(x.a[i][ii], y.a[jj][j])));\n  for (long long i = 0; i < 2; i++)\n    for (long long j = 0; j < 2; j++) tmp.a[i][j] = NTT(tmp.a[i][j], limit, -1);\n  for (long long i = 0; i < 2; i++)\n    for (long long j = 0; j < 2; j++)\n      tmpp.a[i][j] = NTT(tmpp.a[i][j], limit, -1);\n  for (long long i = 0; i < 2; i++)\n    for (long long j = 0; j < 2; j++)\n      tmp.a[i][j] = add_(tmp.a[i][j], tmpp.a[i][j]);\n  for (long long i = 0; i < 2; i++)\n    for (long long j = 0; j < 2; j++)\n      while (tmp.a[i][j].size() > 1 && tmp.a[i][j][tmp.a[i][j].size() - 1] == 0)\n        tmp.a[i][j].pop_back();\n  return tmp;\n}\nsigned main() {\n  scanf(\"%lld\", &m);\n  for (long long mid = 1; mid < N; mid <<= 1)\n    gg[mid] = qpow(g, (mod - 1) / mid),\n    gginv[mid] = qpow(ginv, (mod - 1) / mid), lim[mid] = qpow(mid, mod - 2);\n  for (long long i = 1; i <= m; i++) scanf(\"%lld\", &b[i]);\n  for (long long i = 1; i <= m;) {\n    a[++n] = b[i];\n    for (long long j = 0; j < b[i]; j++) {\n      if (i + j > m) return printf(\"0\\n\"), 0;\n      if (b[i + j] != b[i]) return printf(\"0\\n\"), 0;\n    }\n    i = i + b[i];\n  }\n  zj ans = merge(1, n);\n  for (long long i = 0; i < 2; i++)\n    for (long long j = 0; j < 2; j++) {\n      while (ans.a[i][j].size() <= n + 1) ans.a[i][j].push_back(0);\n    }\n  for (long long i = 1; i <= n; i++)\n    (ans.a[0][0][i] += ans.a[0][1][i] + ans.a[1][0][i] + ans.a[1][1][i]) %= mod;\n  long long now = 1, ANS = 0;\n  for (long long i = 1; i <= n; i++) {\n    (now *= i) %= mod;\n    (ANS += ((n - i + 1) & 1 ? 1 : -1) * now * ans.a[0][0][i] % mod) %= mod;\n    (ANS += mod) %= mod;\n  }\n  return printf(\"%lld\", ANS), 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <typename _Tp>\nvoid read(_Tp &x) {\n  char ch(getchar());\n  bool f(false);\n  while (!isdigit(ch)) f |= ch == 45, ch = getchar();\n  x = ch & 15, ch = getchar();\n  while (isdigit(ch)) x = x * 10 + (ch & 15), ch = getchar();\n  if (f) x = -x;\n}\ntemplate <typename _Tp, typename... Args>\nvoid read(_Tp &t, Args &...args) {\n  read(t);\n  read(args...);\n}\nconst int max_len = 1 << 18, N = max_len + 5, mod = 998244353,\n          inv2 = (mod + 1) / 2;\ntemplate <typename _Tp1, typename _Tp2>\ninline void add(_Tp1 &a, _Tp2 b) {\n  (a += b) >= mod && (a -= mod);\n}\ntemplate <typename _Tp1, typename _Tp2>\ninline void sub(_Tp1 &a, _Tp2 b) {\n  (a -= b) < 0 && (a += mod);\n}\ntemplate <typename _Tp>\ninline _Tp _sub(_Tp a, const _Tp &b) {\n  (a += mod - b) >= mod && (a -= mod);\n  return a;\n}\nlong long ksm(long long a, long long b = mod - 2) {\n  long long res = 1;\n  while (b) {\n    if (b & 1) res = res * a % mod;\n    a = a * a % mod, b >>= 1;\n  }\n  return res;\n}\nvoid print(const std::vector<int> &a) {\n  for (auto it : a) printf(\"%d \", it);\n  printf(\"\\n\");\n}\ninline std::vector<int> operator<<(std::vector<int> a, unsigned int b) {\n  return a.insert(a.begin(), b, 0), a;\n}\ninline std::vector<int> operator<<=(std::vector<int> &a, unsigned int b) {\n  return a.insert(a.begin(), b, 0), a;\n}\ninline std::vector<int> operator>>(const std::vector<int> &a, unsigned int b) {\n  return b >= a.size() ? std::vector<int>()\n                       : std::vector<int>{a.begin() + b, a.end()};\n}\ninline std::vector<int> operator>>=(std::vector<int> &a, unsigned int b) {\n  return a = b >= a.size() ? std::vector<int>()\n                           : std::vector<int>{a.begin() + b, a.end()};\n}\nstd::vector<int> operator+=(std::vector<int> &a, const std::vector<int> &b) {\n  if (b.size() > a.size()) a.resize(b.size());\n  for (unsigned int i = 0; i < b.size(); ++i) add(a[i], b[i]);\n  return a;\n}\ninline std::vector<int> operator+(const std::vector<int> &a,\n                                  const std::vector<int> &b) {\n  std::vector<int> tmp(a);\n  tmp += b;\n  return tmp;\n}\nstd::vector<int> operator-=(std::vector<int> &a, const std::vector<int> &b) {\n  if (b.size() > a.size()) a.resize(b.size());\n  for (unsigned int i = 0; i < b.size(); ++i) sub(a[i], b[i]);\n  return a;\n}\ninline std::vector<int> operator-(const std::vector<int> &a,\n                                  const std::vector<int> &b) {\n  std::vector<int> tmp(a);\n  tmp -= b;\n  return tmp;\n}\nconst unsigned long long Omg = ksm(3, (mod - 1) / max_len);\nunsigned long long Omgs[N];\nvoid setup() {\n  Omgs[max_len / 2] = 1;\n  for (int i = max_len / 2 + 1; i < max_len; ++i)\n    Omgs[i] = Omgs[i - 1] * Omg % mod;\n  for (int i = max_len / 2 - 1; i > 0; --i) Omgs[i] = Omgs[i << 1];\n}\nunsigned int rev[N];\nunsigned int getlen(unsigned int len) {\n  unsigned int limit = 1;\n  while (limit < len) limit <<= 1;\n  for (unsigned int i = 0; i < limit; ++i)\n    rev[i] = (rev[i >> 1] >> 1) | (i & 1 ? limit >> 1 : 0);\n  return limit;\n}\nvoid dft(unsigned long long *A, unsigned int limit) {\n  for (unsigned int i = 0; i < limit; ++i)\n    if (i < rev[i]) std::swap(A[i], A[rev[i]]);\n  for (unsigned int len = 1; len < limit; len <<= 1) {\n    if (len == 262144u)\n      for (unsigned int i = 0; i < limit; ++i) A[i] %= mod;\n    for (unsigned int i = 0; i < limit; i += len << 1) {\n      unsigned long long *p = A + i, *q = A + i + len, *w = Omgs + len;\n      for (unsigned int j = 0; j < len; ++j, ++p, ++q, ++w) {\n        const unsigned long long tp = *q * *w % mod;\n        *q = *p + mod - tp, *p += tp;\n      }\n    }\n  }\n  for (unsigned int i = 0; i < limit; ++i) A[i] %= mod;\n}\nvoid idft(unsigned long long *A, unsigned int limit) {\n  std::reverse(A + 1, A + limit), dft(A, limit);\n  unsigned long long inv = mod - (mod - 1) / limit;\n  for (unsigned int i = 0; i < limit; ++i) A[i] = A[i] * inv % mod;\n}\nunsigned long long _f[N], _g[N], _tp[N];\nstd::vector<int> operator*(const std::vector<int> &a,\n                           const std::vector<int> &b) {\n  if (a.empty() || b.empty()) return {};\n  unsigned int len = a.size() + b.size() - 1;\n  if (a.size() <= 64u || b.size() <= 64u) {\n    memset(_tp, 0, len << 3);\n    unsigned int r = 0;\n    for (unsigned int i = 0; i < a.size(); ++i) {\n      for (unsigned int j = 0; j < b.size(); ++j)\n        _tp[i + j] += 1ULL * a[i] * b[j];\n      if (++r == 18) {\n        r = 0;\n        for (unsigned int j = i - 17; j < i + b.size(); ++j) _tp[j] %= mod;\n      }\n    }\n    if (r)\n      for (unsigned int j = 0; j < len; ++j) _tp[j] %= mod;\n    std::vector<int> c(len);\n    for (unsigned int i = 0; i < len; ++i) c[i] = _tp[i];\n    return c;\n  }\n  unsigned int limit = getlen(len);\n  memset(_f + a.size(), 0, (limit - a.size()) << 3);\n  for (unsigned int i = 0; i < a.size(); ++i) _f[i] = a[i];\n  memset(_g + b.size(), 0, (limit - b.size()) << 3);\n  for (unsigned int i = 0; i < b.size(); ++i) _g[i] = b[i];\n  dft(_f, limit), dft(_g, limit);\n  for (unsigned int i = 0; i < limit; ++i) _f[i] = _f[i] * _g[i] % mod;\n  idft(_f, limit);\n  std::vector<int> ans(len);\n  for (unsigned int i = 0; i < len; ++i) ans[i] = _f[i];\n  return ans;\n}\nstd::vector<int> mul(const std::vector<int> &a, const std::vector<int> &b,\n                     unsigned int len, bool need = true) {\n  if (a.size() <= 64u || b.size() <= 64u) {\n    memset(_tp, 0, len << 3);\n    unsigned int r = 0;\n    for (unsigned int i = 0; i < a.size(); ++i) {\n      for (unsigned int j = 0; j < b.size() && i + j < len; ++j)\n        _tp[i + j] += 1ULL * a[i] * b[j];\n      if (++r == 18) {\n        r = 0;\n        for (unsigned int j = i - 17; j < len && j < i + b.size(); ++j)\n          _tp[j] %= mod;\n      }\n    }\n    if (r)\n      for (unsigned int j = 0; j < len; ++j) _tp[j] %= mod;\n    std::vector<int> c(len);\n    for (unsigned int i = 0; i < len; ++i) c[i] = _tp[i];\n    return c;\n  }\n  int limit = getlen(len);\n  memset(_f + a.size(), 0, (limit - a.size()) << 3);\n  for (unsigned int i = 0; i < a.size(); ++i) _f[i] = a[i];\n  dft(_f, limit);\n  if (need) {\n    memset(_g + b.size(), 0, (limit - b.size()) << 3);\n    for (unsigned int i = 0; i < b.size(); ++i) _g[i] = b[i];\n    dft(_g, limit);\n  }\n  for (int i = 0; i < limit; ++i) _f[i] = 1ULL * _f[i] * _g[i] % mod;\n  idft(_f, limit);\n  std::vector<int> ans(len);\n  for (unsigned int i = 0; i < len; ++i) ans[i] = _f[i];\n  return ans;\n}\ninline std::vector<int> operator*=(std::vector<int> &a,\n                                   const std::vector<int> &b) {\n  return a = a * b;\n}\ntemplate <typename _Tp>\ninline std::vector<int> operator*=(std::vector<int> &a, const _Tp &b) {\n  for (auto &&it : a) it = 1ULL * it * b % mod;\n  return a;\n}\ntemplate <typename _Tp>\ninline std::vector<int> operator*(std::vector<int> a, const _Tp &b) {\n  return a *= b;\n}\ntemplate <typename _Tp>\ninline std::vector<int> operator*(const _Tp &b, std::vector<int> a) {\n  return a *= b;\n}\ntemplate <typename _Tp>\ninline std::vector<int> operator/=(std::vector<int> &a, const _Tp &b) {\n  unsigned long long inv = ksm(b);\n  for (auto &&it : a) it = 1ULL * it * inv % mod;\n  return a;\n}\ntemplate <typename _Tp>\ninline std::vector<int> operator/(std::vector<int> a, const _Tp &b) {\n  return a /= b;\n}\nint a[N], b[N], c[N];\nlong long fac[N];\nstruct mat {\n  std::vector<int> a[2][2];\n  inline mat() { a[0][0] = a[0][1] = a[1][0] = a[1][1] = {0}; }\n  mat operator*(const mat &o) const {\n    int len = 0;\n    for (int i = 0; i < 2; ++i)\n      for (int j = 0; j < 2; ++j)\n        for (int k = 0; k < 2; ++k)\n          len = std::max(len,\n                         ((int)a[i][k].size()) + ((int)o.a[k][j].size()) - 1);\n    unsigned int limit = getlen(len);\n    static unsigned long long F[2][2][N], G[2][2][N], H[N];\n    for (int i = 0; i < 2; ++i)\n      for (int j = 0; j < 2; ++j) {\n        for (int k = 0; k < ((int)a[i][j].size()); ++k) F[i][j][k] = a[i][j][k];\n        memset(F[i][j] + a[i][j].size(), 0, (limit - a[i][j].size()) << 3);\n      }\n    for (int i = 0; i < 2; ++i)\n      for (int j = 0; j < 2; ++j) dft(F[i][j], limit);\n    for (int i = 0; i < 2; ++i)\n      for (int j = 0; j < 2; ++j) {\n        for (int k = 0; k < ((int)o.a[i][j].size()); ++k)\n          G[i][j][k] = o.a[i][j][k];\n        memset(G[i][j] + o.a[i][j].size(), 0, (limit - o.a[i][j].size()) << 3);\n      }\n    for (int i = 0; i < 2; ++i)\n      for (int j = 0; j < 2; ++j) dft(G[i][j], limit);\n    mat ans;\n    for (int i = 0; i < 2; ++i)\n      for (int j = 0; j < 2; ++j) {\n        memset(H, 0, limit << 3);\n        int qwq = 0;\n        for (int k = 0; k < 2; ++k)\n          qwq = std::max(qwq,\n                         ((int)a[i][k].size()) + ((int)o.a[k][j].size()) - 1);\n        for (int k = 0; k < 2; ++k)\n          for (unsigned int t = 0; t < limit; ++t)\n            H[t] += 1ULL * F[i][k][t] * G[k][j][t];\n        for (unsigned int t = 0; t < limit; ++t) H[t] %= mod;\n        idft(H, limit), ans.a[i][j].resize(qwq);\n        for (int t = 0; t < qwq; ++t) ans.a[i][j][t] = H[t];\n      }\n    return ans;\n  }\n} M[N];\nmat solve(int l, int r) {\n  if (l == r) return M[l];\n  int mid = (l + r) >> 1;\n  return solve(mid + 1, r) * solve(l, mid);\n}\nint main() {\n  fac[0] = 1;\n  for (int i = 1; i < N; ++i) fac[i] = fac[i - 1] * i % mod;\n  setup();\n  int n;\n  read(n);\n  for (int i = 1; i <= n; ++i) read(a[i]);\n  int m = 0;\n  for (int i = 1; i <= n; i += a[i]) {\n    for (int j = 0; j < a[i]; ++j)\n      if (a[i + j] != a[i]) return puts(\"0\"), 0;\n    b[m++] = a[i];\n  }\n  for (int i = 0; i < m; ++i) {\n    if (i) M[i].a[1][0] = {mod - 2}, M[i].a[1][1] = {mod - 1};\n    if (b[i] == 1)\n      M[i].a[0][0] = {0, 1}, M[i].a[0][1] = {0, 1};\n    else\n      M[i].a[1][0] += {0, 2}, M[i].a[1][1] += {0, 2};\n  }\n  mat ans = solve(0, m - 1);\n  int res = 0;\n  for (int a = 0; a < 2; ++a)\n    for (int i = 0; i < ((int)ans.a[a][1].size()); ++i)\n      add(res, 1LL * ans.a[a][1][i] * fac[i] % mod);\n  printf(\"%d\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nconstexpr long long mod = 998244353;\nconst long long INF = mod * mod;\nconst long double eps = 1e-12;\nconst long double pi = acosl(-1.0);\nlong long mod_pow(long long x, long long n, long long m = mod) {\n  if (n < 0) {\n    long long res = mod_pow(x, -n, m);\n    return mod_pow(res, m - 2, m);\n  }\n  if (abs(x) >= m) x %= m;\n  if (x < 0) x += m;\n  long long res = 1;\n  while (n) {\n    if (n & 1) res = res * x % m;\n    x = x * x % m;\n    n >>= 1;\n  }\n  return res;\n}\nstruct modint {\n  long long n;\n  modint() : n(0) { ; }\n  modint(long long m) : n(m) {\n    if (n >= mod)\n      n %= mod;\n    else if (n < 0)\n      n = (n % mod + mod) % mod;\n  }\n  operator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) {\n  a.n += b.n;\n  if (a.n >= mod) a.n -= mod;\n  return a;\n}\nmodint operator-=(modint& a, modint b) {\n  a.n -= b.n;\n  if (a.n < 0) a.n += mod;\n  return a;\n}\nmodint operator*=(modint& a, modint b) {\n  a.n = ((long long)a.n * b.n) % mod;\n  return a;\n}\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, long long n) {\n  if (n == 0) return modint(1);\n  modint res = (a * a) ^ (n / 2);\n  if (n % 2) res = res * a;\n  return res;\n}\nlong long inv(long long a, long long p) {\n  return (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\nmodint operator/=(modint& a, modint b) {\n  a = a / b;\n  return a;\n}\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n  fact[0] = modint(1);\n  for (int i = 0; i < max_n - 1; i++) {\n    fact[i + 1] = fact[i] * modint(i + 1);\n  }\n  factinv[max_n - 1] = modint(1) / fact[max_n - 1];\n  for (int i = max_n - 2; i >= 0; i--) {\n    factinv[i] = factinv[i + 1] * modint(i + 1);\n  }\n}\nmodint comb(int a, int b) {\n  if (a < 0 || b < 0 || a < b) return 0;\n  return fact[a] * factinv[b] * factinv[a - b];\n}\nmodint combP(int a, int b) {\n  if (a < 0 || b < 0 || a < b) return 0;\n  return fact[a] * factinv[a - b];\n}\nint get_premitive_root() {\n  int primitive_root = 0;\n  if (!primitive_root) {\n    primitive_root = [&]() {\n      set<int> fac;\n      int v = mod - 1;\n      for (long long i = 2; i * i <= v; i++)\n        while (v % i == 0) fac.insert(i), v /= i;\n      if (v > 1) fac.insert(v);\n      for (int g = 1; g < mod; g++) {\n        bool ok = true;\n        for (auto i : fac)\n          if (mod_pow(g, (mod - 1) / i) == 1) {\n            ok = false;\n            break;\n          }\n        if (ok) return g;\n      }\n      return -1;\n    }();\n  }\n  return primitive_root;\n}\nconst int proot = get_premitive_root();\nvoid dft(vector<modint>& f, bool inverse = false) {\n  int n = f.size();\n  if (n == 1) return;\n  static vector<modint> w{1}, iw{1};\n  for (int m = w.size(); m < n / 2; m *= 2) {\n    modint dw = mod_pow(proot, (mod - 1) / (4 * m)), dwinv = (modint)1 / dw;\n    w.resize(m * 2);\n    iw.resize(m * 2);\n    for (int i = 0; i < m; i++) w[m + i] = w[i] * dw, iw[m + i] = iw[i] * dwinv;\n  }\n  if (!inverse) {\n    for (int m = n; m >>= 1;) {\n      for (int s = 0, k = 0; s < n; s += 2 * m, k++) {\n        for (int i = s; i < s + m; i++) {\n          modint x = f[i], y = f[i + m] * w[k];\n          f[i] = x + y, f[i + m] = x - y;\n        }\n      }\n    }\n  } else {\n    for (int m = 1; m < n; m *= 2) {\n      for (int s = 0, k = 0; s < n; s += 2 * m, k++) {\n        for (int i = s; i < s + m; i++) {\n          modint x = f[i], y = f[i + m];\n          f[i] = x + y, f[i + m] = (x - y) * iw[k];\n        }\n      }\n    }\n    modint n_inv = (modint)1 / (modint)n;\n    for (modint& v : f) v *= n_inv;\n  }\n}\nvector<modint> multiply(vector<modint> g, vector<modint> h) {\n  int n = 1;\n  int pi = 0, qi = 0;\n  for (int i = 0; i < g.size(); i++)\n    if (g[i]) pi = i;\n  for (int i = 0; i < h.size(); i++)\n    if (h[i]) qi = i;\n  int sz = pi + qi + 2;\n  while (n < sz) n *= 2;\n  g.resize(n);\n  h.resize(n);\n  dft(g);\n  dft(h);\n  for (int i = 0; i < n; i++) {\n    g[i] *= h[i];\n  }\n  dft(g, true);\n  return g;\n}\nmodint inv2 = (1 + mod) / 2;\nstruct Data {\n  vector<modint> p[2][2];\n};\nData merge(Data dl, Data dr, int isone) {\n  Data res;\n  for (int a1 = 0; a1 < 2; a1++)\n    for (int b1 = 0; b1 < 2; b1++)\n      for (int a2 = 0; a2 < 2; a2++)\n        for (int b2 = 0; b2 < 2; b2++) {\n          vector<modint> r = multiply(dl.p[a1][b1], dr.p[a2][b2]);\n          while (r.size() && r.back() == (modint)0) r.pop_back();\n          if (isone && b1 && a2) {\n            for (int i = 0; i < r.size(); i++) r[i] *= inv2;\n          }\n          int na = a1, nb = b2;\n          if (res.p[na][nb].size() < r.size()) {\n            res.p[na][nb].resize(r.size(), 0);\n          }\n          for (int i = 0; i < r.size(); i++) {\n            res.p[na][nb][i] += r[i];\n          }\n        }\n  return res;\n}\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) cin >> a[i];\n  vector<int> c;\n  int cur = 0;\n  while (cur < n) {\n    if (cur + a[cur] > n) {\n      cout << 0 << \"\\n\";\n      return;\n    }\n    for (int j = cur; j < cur + a[cur]; j++) {\n      if (a[cur] != a[j]) {\n        cout << 0 << \"\\n\";\n        return;\n      }\n    }\n    c.push_back(a[cur]);\n    cur += a[cur];\n  }\n  if (c.size() == 1) {\n    if (n == 1) {\n      cout << 1 << \"\\n\";\n    } else {\n      cout << 2 << \"\\n\";\n    }\n    return;\n  }\n  function<Data(int, int)> yaru = [&](int l, int r) -> Data {\n    if (r - l == 1) {\n      int cnt = 0;\n      if (c[l] == 1) cnt++;\n      if (c[r] == 1) cnt++;\n      Data res;\n      res.p[0][0] = {1};\n      res.p[1][1] = {0, (1 << cnt)};\n      return res;\n    }\n    int m = (l + r) / 2;\n    Data dl = yaru(l, m);\n    Data dr = yaru(m, r);\n    return merge(dl, dr, c[m] == 1);\n  };\n  Data d = yaru(0, c.size() - 1);\n  vector<modint> num;\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 2; j++) {\n      if (num.size() < d.p[i][j].size()) {\n        num.resize(d.p[i][j].size());\n      }\n      for (int k = 0; k < d.p[i][j].size(); k++) {\n        num[k] += d.p[i][j][k];\n      }\n    }\n  int c1 = 0;\n  for (int i = 0; i < c.size(); i++)\n    if (c[i] == 1) c1++;\n  modint coef = mod_pow(inv2, c1);\n  modint ans = 0;\n  for (int i = 0; i < num.size(); i++) {\n    if (i > c.size()) continue;\n    modint val = num[i];\n    if (i % 2) val *= -1;\n    val *= mod_pow(2, c.size() - i);\n    val *= fact[c.size() - i];\n    val *= coef;\n    ans += val;\n  }\n  cout << ans << \"\\n\";\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  init_f();\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\nint qp(int a, int b) {\n  int res = 1;\n  while (b) {\n    if (b & 1) res = 1ll * res * a % mod;\n    a = 1ll * a * a % mod;\n    b >>= 1;\n  }\n  return res;\n}\nusing Poly = vector<int>;\nnamespace NTT {\nconst int PN = 1 << 17;\nint W[2][PN + 5], rev[PN + 5], stk[PN + 5];\nstruct Initializer_t {\n  Initializer_t() {\n    int x = qp(3, (mod - 1) / PN), y = qp(x, mod - 2);\n    W[0][0] = W[1][0] = 1;\n    for (int i = 1; i < PN; i++) {\n      W[0][i] = 1ll * W[0][i - 1] * x % mod;\n      W[1][i] = 1ll * W[1][i - 1] * y % mod;\n    }\n    rev[0] = 0;\n  }\n} Initializer;\nvoid DFT(int n, int *a, int flag) {\n  for (int i = 0; i < n; i++)\n    if (rev[i] > i) swap(a[rev[i]], a[i]);\n  for (int i = 2; i <= n; i <<= 1) {\n    int i2 = i >> 1;\n    for (int j = 0; j < i2; j++) stk[j] = W[flag][PN / i * j];\n    for (int j = 0; j < n; j += i) {\n      int *p1 = a + j, *p2 = a + j + i2, *p3 = stk;\n      for (int k = 0; k < i2; k++, ++p1, ++p2, ++p3) {\n        int x = *p1, y = 1ll * *p2 * *p3 % mod;\n        *p1 = (x + y >= mod ? x + y - mod : x + y);\n        *p2 = (x - y < 0 ? x - y + mod : x - y);\n      }\n    }\n  }\n  if (flag) {\n    int t = qp(n, mod - 2);\n    for (int i = 0; i < n; i++) a[i] = 1ll * a[i] * t % mod;\n  }\n}\nPoly operator+(const Poly &a, const Poly &b) {\n  Poly ret(max(a.size(), b.size()));\n  for (int i = 0; i < (int)ret.size(); i++) {\n    ret[i] =\n        ((i < (int)a.size() ? a[i] : 0) + (i < (int)b.size() ? b[i] : 0)) % mod;\n  }\n  return ret;\n}\nint ta[PN + 5], tb[PN + 5];\nPoly operator*(const Poly &a, const Poly &b) {\n  int n = a.size(), m = b.size();\n  if (!n || !m) return {};\n  for (int i = 0; i < n; i++) ta[i] = a[i];\n  for (int i = 0; i < m; i++) tb[i] = b[i];\n  int len, cnt;\n  for (len = 1, cnt = 0; len < n + m - 1; len <<= 1, cnt++)\n    ;\n  for (int i = 1; i < len; i++)\n    rev[i] = ((rev[i >> 1] >> 1) | ((i & 1) << (cnt - 1)));\n  for (int i = n; i < len; i++) ta[i] = 0;\n  for (int i = m; i < len; i++) tb[i] = 0;\n  DFT(len, ta, 0);\n  DFT(len, tb, 0);\n  for (int i = 0; i < len; i++) ta[i] = 1ll * ta[i] * tb[i] % mod;\n  DFT(len, ta, 1);\n  return Poly(ta, ta + n + m - 1);\n}\n}  // namespace NTT\nusing NTT::operator+;\nusing NTT::operator*;\nconst int N = 100005;\nint n, m, a[N], b[N];\nvector<vector<Poly>> solve(int l, int r) {\n  if (l == r) {\n    if (b[l] == 1)\n      return {{{0, 1}, {0, 2}}, {{1}, {1}}};\n    else\n      return {{{0, 2}, {0, 2}}, {{1}, {1}}};\n  }\n  int mid = (l + r) >> 1;\n  vector<vector<Poly>> L = solve(l, mid), R = solve(mid + 1, r),\n                       res = {{{}, {}}, {{}, {}}};\n  for (int a = 0; a < 2; a++)\n    for (int b = 0; b < 2; b++)\n      for (int c = 0; c < 2; c++) {\n        res[a][c] = res[a][c] + L[a][b] * R[b][c];\n      }\n  return res;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  for (int i = 1; i <= n;) {\n    b[++m] = a[i];\n    for (int j = i; j < i + b[m]; j++) {\n      if (j > n || a[j] != b[m]) {\n        puts(\"0\");\n        return 0;\n      }\n    }\n    i += b[m];\n  }\n  Poly res = solve(1, m)[0][0];\n  int ans = 0;\n  for (int i = 1, fct = 1; i <= m; i++) {\n    fct = 1ll * fct * i % mod;\n    ans = (ans + 1ll * ((m - i) % 2 ? mod - fct : fct) * res[i]) % mod;\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"inline\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-fipa-sra\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-ffast-math\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fdevirtualize\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"inline-functions\")\n#pragma GCC optimize(\"-ftree-tail-merge\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fpartial-inlining\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-fhoist-adjacent-loads\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"inline-small-functions\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"inline-functions-called-once\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\nusing namespace std;\ntemplate <typename T>\nvoid r1(T &x) {\n  x = 0;\n  char c(getchar());\n  int f(1);\n  for (; c < '0' || c > '9'; c = getchar())\n    if (c == '-') f = -1;\n  for (; '0' <= c && c <= '9'; c = getchar()) x = (x * 10) + (c ^ 48);\n  x *= f;\n}\nconst int mod = 998244353;\ntemplate <typename T, typename... Args>\ninline void r1(T &t, Args &...args) {\n  r1(t);\n  r1(args...);\n}\nconst int maxn = 1e5 + 5;\nint n, a[maxn], s[maxn], tot(0);\nint f[2][maxn];\nint inc(int x, int y) { return x += y - mod, x + ((x >> 31) & mod); }\nvoid add(int &x, int y) { x = inc(x, y); }\nint Mod(int x) { return x -= mod, x + ((x >> 31) & mod); }\nsigned main() {\n  int i, j;\n  r1(n);\n  for (i = 1; i <= n; ++i) r1(a[i]);\n  for (i = 1; i <= n; i += a[i]) {\n    s[++tot] = (a[i] > 1);\n    for (j = i; j <= i + a[i] - 1; ++j)\n      if (a[i] != a[j]) return puts(\"0\"), 0;\n  }\n  f[s[1]][0] = 1;\n  for (i = 1; i < tot; ++i) {\n    if (s[i + 1]) {\n      for (j = i - 1; j >= 0; --j) {\n        add(f[1][j + 1], Mod(f[1][j] << 1));\n        add(f[1][j + 1], f[0][j]);\n        add(f[1][j], f[0][j]);\n        f[0][j] = 0;\n      }\n    } else {\n      for (j = i - 1; j >= 0; --j) {\n        add(f[0][j + 1], Mod(f[1][j] << 1));\n        add(f[0][j + 1], f[0][j]);\n        add(f[1][j], f[0][j]);\n        f[0][j] = 0;\n      }\n    }\n  }\n  long long ans(0), fac(1);\n  for (i = 1; i <= tot; ++i) {\n    fac = fac * i % mod;\n    long long tmp = (f[0][i - 1] + 2ll * f[1][i - 1]) % mod * fac % mod;\n    if ((tot - i) & 1)\n      ans = Mod(ans - tmp + mod);\n    else\n      ans = Mod(ans + tmp);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar _c;\nbool _f;\ntemplate <class T>\ninline void IN(T &x) {\n  x = 0, _f = 0;\n  while (_c = getchar(), !isdigit(_c))\n    if (_c == '-') _f = 1;\n  while (isdigit(_c)) x = x * 10 + _c - '0', _c = getchar();\n  if (_f) x = -x;\n}\nconst int mod = 998244353;\ninline int mul(int x, int y) { return 1ll * x * y % mod; }\ninline void sub(int &x, int y) {\n  x -= y;\n  if (x < 0) x += mod;\n}\ninline void pls(int &x, int y) {\n  x += y;\n  if (x >= mod) x -= mod;\n}\ninline int dec(int x, int y) {\n  x -= y;\n  if (x < 0) x += mod;\n  return x;\n}\ninline int add(int x, int y) {\n  x += y;\n  if (x >= mod) x -= mod;\n  return x;\n}\ninline int modpow(int x, long long y, int res = 1) {\n  for (y = (y + mod - 1) % (mod - 1); y; y >>= 1, x = mul(x, x))\n    if (y & 1) res = mul(x, res);\n  return res;\n}\ntemplate <class T>\ninline void chkmin(T &x, T y) {\n  if (x > y) x = y;\n}\ntemplate <class T>\ninline void chkmax(T &x, T y) {\n  if (x < y) x = y;\n}\nconst int LogN = 20;\nint lim, tim, inv[LogN];\nvector<int> w[LogN], rev[LogN];\ninline void init_w(int len = 1 << 19) {\n  w[19].resize(len), w[19][0] = 1, w[19][1] = modpow(3, (mod - 1) >> 20);\n  for (int i = 2; i < len; ++i) w[19][i] = mul(w[19][i - 1], w[19][1]);\n  for (int i = 18; i >= 0; --i) {\n    w[i].resize(len >>= 1);\n    for (int j = 0; j < len; ++j) w[i][j] = w[i + 1][j << 1];\n  }\n}\ninline void init_r(int len) {\n  for (lim = 1, tim = 0; lim < len; lim <<= 1, ++tim)\n    ;\n  if (rev[tim].size()) return;\n  rev[tim].resize(lim), inv[tim] = modpow(lim, -1);\n  for (int i = 0; i < lim; ++i)\n    rev[tim][i] = (rev[tim][i >> 1] >> 1) | ((i & 1) << (tim - 1));\n}\ninline void ntt(vector<int> &f, short typ) {\n  static unsigned long long g[1 << 20 | 5];\n  for (int i = 0; i < lim; ++i) g[rev[tim][i]] = f[i];\n  for (int p = 1, s = 0, t = 0; p < lim; p <<= 1, ++t)\n    for (int k = 0; k < lim; k += p << 1)\n      for (int l = k; l < k + p; ++l)\n        s = mul(g[l + p] % mod, w[t][l - k]), g[l + p] = g[l] + mod - s,\n        g[l] += s;\n  for (int i = 0; i < lim; ++i) f[i] = g[i] % mod;\n  if (~typ) return;\n  std ::reverse(++f.begin(), f.end());\n  for (int i = 0; i < lim; ++i) f[i] = mul(f[i], inv[tim]);\n}\nconst int N = 1e5 + 5;\nconst int inv2 = modpow(2, -1);\nint n, m, a[N], b[N], fac[N];\nvector<int> f[N << 2][4], g[2][4];\nvoid solve(int x, int l, int r, bool typ) {\n  const int len = r - l + 2;\n  for (int o = 0; o < 4; ++o) f[x][o].resize(len);\n  if (l == r) return f[x][(b[l] == 1) * 3][1] = 1 + (b[l] != 1), void();\n  const int mid = l + r >> 1, lc = x << 1, rc = x << 1 | 1;\n  solve(lc, l, mid, 0), solve(rc, mid + 1, r, 1);\n  const int ln = mid - l + 2, rn = r - mid + 1;\n  for (int o0 = 0; o0 < 4; ++o0)\n    for (int o1 = 0; o1 < 4; ++o1) {\n      int t0 = (o0 & 1) | (o1 & 2), t2 = (o0 & 2) | (o1 & 1),\n          val = (t2 == 3) ? 2 : (t2 == 0 ? inv2 : 1);\n      pls(f[x][t0][2], mul(f[lc][o0][1], f[rc][o1][1]));\n      pls(f[x][0][1], mul(mul(f[lc][o0][1], f[rc][o1][1]), val));\n      for (int i = 3; i <= ln; ++i)\n        pls(f[x][t0][i], mul(f[lc][o0][i - 1], f[rc][o1][1]));\n      for (int j = 3; j <= rn; ++j)\n        pls(f[x][t0][j], mul(f[lc][o0][1], f[rc][o1][j - 1]));\n      for (int i = 2; i < ln; ++i)\n        pls(f[x][o0 & 1][i], mul(mul(f[lc][o0][i], f[rc][o1][1]), val));\n      for (int j = 2; j < rn; ++j)\n        pls(f[x][o1 & 2][j], mul(mul(f[lc][o0][1], f[rc][o1][j]), val));\n    }\n  init_r(len);\n  for (int t0 = 0; t0 < 4; ++t0) g[0][t0].resize(lim), g[1][t0].resize(lim);\n  for (int o0 = 0; o0 < 4; ++o0)\n    f[lc][o0][0] = f[lc][o0][1] = 0, f[lc][o0].resize(lim), ntt(f[lc][o0], 1);\n  for (int o1 = 0; o1 < 4; ++o1)\n    f[rc][o1][0] = f[rc][o1][1] = 0, f[rc][o1].resize(lim), ntt(f[rc][o1], 1);\n  for (int o0 = 0; o0 < 4; ++o0)\n    for (int o1 = 0; o1 < 4; ++o1) {\n      int t0 = (o0 & 1) | (o1 & 2), t2 = (o0 & 2) | (o1 & 1),\n          val = (t2 == 3) ? 2 : (t2 == 0 ? inv2 : 1);\n      for (int i = 0; i < lim; ++i)\n        g[0][t0][i] = mul(f[lc][o0][i], f[rc][o1][i]);\n      ntt(g[0][t0], -1);\n      for (int i = 4; i < len; ++i) pls(f[x][t0][i], g[0][t0][i]);\n      for (int i = 4; i < len; ++i) pls(f[x][t0][i - 1], mul(g[0][t0][i], val));\n    }\n}\nint main() {\n  init_w();\n  IN(n);\n  for (int i = 1; i <= n; ++i) IN(a[i]);\n  fac[0] = 1;\n  for (int i = 1; i <= n; ++i) fac[i] = mul(fac[i - 1], i);\n  bool flag = false;\n  for (int l = 1, r; l <= n; l = r + 1) {\n    if (r = l + a[l] - 1, r > n) {\n      flag = true;\n      break;\n    }\n    for (int i = l; i <= r; ++i)\n      if (a[i] != a[l]) flag = true;\n    b[++m] = a[l];\n  }\n  if (flag) return puts(\"0\"), 0;\n  solve(1, 1, m, 0);\n  int ans = 0;\n  for (int i = 1; i <= m; ++i)\n    for (int o = 0; o < 4; ++o)\n      pls(ans, mul(f[1][o][i], mul(fac[i], ((m - i) & 1) ? mod - 1 : 1)));\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse4\")\nusing namespace std;\ntemplate <class T>\nusing pq = priority_queue<T>;\ntemplate <class T>\nusing pqg = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T>\nbool ckmin(T& a, const T& b) {\n  return b < a ? a = b, 1 : 0;\n}\ntemplate <class T>\nbool ckmax(T& a, const T& b) {\n  return a < b ? a = b, 1 : 0;\n}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nvoid __print(int x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(long long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << '\\'' << x << '\\''; }\nvoid __print(const char* x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(const string& x) { cerr << '\\\"' << x << '\\\"'; }\nvoid __print(bool x) { cerr << (x ? \"true\" : \"false\"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V>& x) {\n  cerr << '{';\n  __print(x.first);\n  cerr << \", \";\n  __print(x.second);\n  cerr << '}';\n}\ntemplate <typename T>\nvoid __print(const T& x) {\n  int first = 0;\n  cerr << '{';\n  for (auto& i : x) cerr << (first++ ? \", \" : \"\"), __print(i);\n  cerr << \"}\";\n}\nvoid _print() { cerr << \"]\\n\"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n  __print(t);\n  if (sizeof...(v)) cerr << \", \";\n  _print(v...);\n}\nconst int MOD = 998244353;\nconst char nl = '\\n';\nconst int MX = 200001;\nstruct mi {\n  long long v;\n  explicit operator long long() const { return v; }\n  mi() { v = 0; }\n  mi(long long _v) {\n    v = (-MOD < _v && _v < MOD) ? _v : _v % MOD;\n    if (v < 0) v += MOD;\n  }\n  friend bool operator==(const mi& a, const mi& b) { return a.v == b.v; }\n  friend bool operator!=(const mi& a, const mi& b) { return !(a == b); }\n  friend bool operator<(const mi& a, const mi& b) { return a.v < b.v; }\n  mi& operator+=(const mi& m) {\n    if ((v += m.v) >= MOD) v -= MOD;\n    return *this;\n  }\n  mi& operator-=(const mi& m) {\n    if ((v -= m.v) < 0) v += MOD;\n    return *this;\n  }\n  mi& operator*=(const mi& m) {\n    v = v * m.v % MOD;\n    return *this;\n  }\n  mi& operator/=(const mi& m) { return (*this) *= inv(m); }\n  friend mi pow(mi a, long long p) {\n    mi ans = 1;\n    assert(p >= 0);\n    for (; p; p /= 2, a *= a)\n      if (p & 1) ans *= a;\n    return ans;\n  }\n  friend mi inv(const mi& a) {\n    assert(a.v != 0);\n    return pow(a, MOD - 2);\n  }\n  mi operator-() const { return mi(-v); }\n  mi& operator++() { return *this += 1; }\n  mi& operator--() { return *this -= 1; }\n  mi operator++(int) {\n    mi temp;\n    temp.v = v++;\n    return temp;\n  }\n  mi operator--(int) {\n    mi temp;\n    temp.v = v--;\n    return temp;\n  }\n  friend mi operator+(mi a, const mi& b) { return a += b; }\n  friend mi operator-(mi a, const mi& b) { return a -= b; }\n  friend mi operator*(mi a, const mi& b) { return a *= b; }\n  friend mi operator/(mi a, const mi& b) { return a /= b; }\n  friend ostream& operator<<(ostream& os, const mi& m) {\n    os << m.v;\n    return os;\n  }\n  friend istream& operator>>(istream& is, mi& m) {\n    long long x;\n    is >> x;\n    m.v = x;\n    return is;\n  }\n};\nvoid __print(mi X) { cout << X.v; }\nmi facs[MX];\nmi facInvs[MX];\nmi choose(mi _a, mi _b) {\n  long long a = (long long)_a, b = (long long)_b;\n  if (b > a) return 0;\n  if (a < 0) return 0;\n  if (b < 0) return 0;\n  mi cur = facs[a];\n  cur = cur * facInvs[b];\n  cur = cur * facInvs[a - b];\n  return cur;\n}\nvoid initFacs() {\n  facs[0] = 1;\n  for (int i = 1; i < (MX); i++) {\n    facs[i] = (facs[i - 1] * i);\n  }\n  facInvs[MX - 1] = inv(facs[MX - 1]);\n  for (int i = (MX - 1) - 1; i >= 0; i--) {\n    facInvs[i] = facInvs[i + 1] * (i + 1);\n  }\n}\nlong long modExp(long long base, long long power) {\n  if (power == 0) {\n    return 1;\n  } else {\n    long long cur = modExp(base, power / 2);\n    cur = cur * cur;\n    cur = cur % MOD;\n    if (power % 2 == 1) cur = cur * base;\n    cur = cur % MOD;\n    return cur;\n  }\n}\nlong long inv(long long base) {\n  int g = MOD, r = base, x = 0, y = 1;\n  while (r != 0) {\n    int q = g / r;\n    g %= r;\n    swap(g, r);\n    x -= q * y;\n    swap(x, y);\n  }\n  return x < 0 ? x + MOD : x;\n}\nlong long mul(long long A, long long B) { return (A * B) % MOD; }\nlong long add(long long A, long long B) { return (A + B) % MOD; }\nlong long dvd(long long A, long long B) { return mul(A, inv(B)); }\nlong long sub(long long A, long long B) { return (A - B + MOD) % MOD; }\nnamespace NTT {\nvector<long long> roots = {0, 1};\nvector<int> bit_reverse;\nint max_size = -1;\nlong long root;\nbool is_power_of_two(int n) { return (n & (n - 1)) == 0; }\nint round_up_power_two(int n) {\n  while (n & (n - 1)) n = (n | (n - 1)) + 1;\n  return max(n, 1);\n}\nint get_length(int n) {\n  assert(is_power_of_two(n));\n  return __builtin_ctz(n);\n}\nvoid bit_reorder(int n, vector<long long>& values) {\n  if ((int)bit_reverse.size() != n) {\n    bit_reverse.assign(n, 0);\n    int length = get_length(n);\n    for (int i = 0; i < n; i++)\n      bit_reverse[i] = (bit_reverse[i >> 1] >> 1) + ((i & 1) << (length - 1));\n  }\n  for (int i = 0; i < n; i++)\n    if (i < bit_reverse[i]) swap(values[i], values[bit_reverse[i]]);\n}\nvoid find_root() {\n  max_size = 1 << __builtin_ctz(MOD - 1);\n  root = 2;\n  while (!(modExp(root, max_size) == 1 && modExp(root, max_size / 2) != 1))\n    root++;\n}\nvoid prepare_roots(int n) {\n  if (max_size < 0) find_root();\n  assert(n <= max_size);\n  if ((int)roots.size() >= n) return;\n  int length = get_length(roots.size());\n  roots.resize(n);\n  while (1 << length < n) {\n    long long z = modExp(root, max_size >> (length + 1));\n    for (int i = 1 << (length - 1); i < 1 << length; i++) {\n      roots[2 * i] = roots[i];\n      roots[2 * i + 1] = (roots[i] * z) % MOD;\n    }\n    length++;\n  }\n}\nvoid fft_iterative(int N, vector<long long>& values) {\n  assert(is_power_of_two(N));\n  prepare_roots(N);\n  bit_reorder(N, values);\n  for (int n = 1; n < N; n *= 2)\n    for (int start = 0; start < N; start += 2 * n)\n      for (int i = 0; i < n; i++) {\n        long long even = values[start + i];\n        long long odd = values[start + n + i] * roots[n + i];\n        odd %= MOD;\n        values[start + n + i] = even - odd + MOD;\n        values[start + i] = even + odd;\n        values[start + n + i] %= MOD;\n        values[start + i] %= MOD;\n      }\n}\nconst int FFT_CUTOFF = 150;\nvector<long long> mod_multiply(vector<long long> left,\n                               vector<long long> right) {\n  int n = left.size();\n  int m = right.size();\n  if (min(n, m) < FFT_CUTOFF) {\n    const uint64_t ULL_BOUND =\n        numeric_limits<uint64_t>::max() - (uint64_t)MOD * MOD;\n    vector<uint64_t> result(n + m - 1, 0);\n    for (int i = 0; i < n; i++)\n      for (int j = 0; j < m; j++) {\n        result[i + j] += (uint64_t)((int)left[i]) * ((int)right[j]);\n        if (result[i + j] > ULL_BOUND) result[i + j] %= MOD;\n      }\n    for (uint64_t& x : result)\n      if (x >= MOD) x %= MOD;\n    return vector<long long>(result.begin(), result.end());\n  }\n  int N = round_up_power_two(n + m - 1);\n  left.resize(N);\n  right.resize(N);\n  bool equal = left == right;\n  fft_iterative(N, left);\n  if (equal)\n    right = left;\n  else\n    fft_iterative(N, right);\n  long long inv_N = inv(N);\n  for (int i = 0; i < N; i++) {\n    left[i] *= (right[i] * inv_N) % MOD;\n    left[i] %= MOD;\n  }\n  reverse(left.begin() + 1, left.end());\n  fft_iterative(N, left);\n  left.resize(n + m - 1);\n  return left;\n}\nvector<long long> mod_power(const vector<long long>& v, int exponent) {\n  assert(exponent >= 0);\n  vector<long long> result = {1};\n  if (exponent == 0) return result;\n  for (int k = 31 - __builtin_clz(exponent); k >= 0; k--) {\n    result = mod_multiply(result, result);\n    if (exponent >> k & 1) result = mod_multiply(result, v);\n  }\n  return result;\n}\nvector<long long> mod_multiply_all(\n    const vector<vector<long long>>& polynomials) {\n  if (polynomials.empty()) return {1};\n  struct compare_size {\n    bool operator()(const vector<long long>& x, const vector<long long>& y) {\n      return x.size() > y.size();\n    }\n  };\n  priority_queue<vector<long long>, vector<vector<long long>>, compare_size> pq(\n      polynomials.begin(), polynomials.end());\n  while (pq.size() > 1) {\n    vector<long long> a = pq.top();\n    pq.pop();\n    vector<long long> b = pq.top();\n    pq.pop();\n    pq.push(mod_multiply(a, b));\n  }\n  return pq.top();\n}\n}  // namespace NTT\nusing namespace NTT;\nvector<int> comps;\nlong long half = 499122177;\nvector<vector<long long>> get(int L, int R) {\n  if (L == R) {\n    vector<vector<long long>> res(4, vector<long long>(1, 0));\n    if (comps[L] == 1) {\n      res[3][0] += half;\n    } else\n      res[0][0]++;\n    return res;\n  }\n  int M = (L + R) / 2;\n  vector<vector<long long>> A = get(L, M);\n  vector<vector<long long>> B = get(M + 1, R);\n  vector<vector<long long>> res(4, vector<long long>(R - L + 1, 0));\n  for (int ma = 0; ma < (4); ma++) {\n    for (int mb = 0; mb < (4); mb++) {\n      vector<long long> cur = mod_multiply(A[ma], B[mb]);\n      int X = ma % 2;\n      if (M == L) {\n        X = 0;\n      }\n      int Y = mb / 2;\n      if (M + 1 == R) {\n        Y = 0;\n      }\n      int pos = X + 2 * Y;\n      int mul = 0;\n      if (ma / 2) mul++;\n      if (mb % 2) mul++;\n      for (int i = 0; i < ((int)(cur).size()); i++) {\n        res[pos][i + 1] += cur[i] << mul;\n        res[pos][i + 1] %= MOD;\n      }\n      X = ma % 2;\n      Y = mb / 2;\n      pos = X + 2 * Y;\n      for (int i = 0; i < ((int)(cur).size()); i++) {\n        res[pos][i] += cur[i];\n        res[pos][i] %= MOD;\n      }\n    }\n  }\n  return res;\n}\nvoid solve() {\n  initFacs();\n  int N;\n  cin >> N;\n  int A[N];\n  for (int i = 0; i < (N); i++) cin >> A[i];\n  int cur = -1, rem = 0;\n  for (int i = 0; i < (N); i++) {\n    if (rem == 0) {\n      cur = A[i];\n      comps.push_back(A[i]);\n      rem = A[i] - 1;\n    } else {\n      rem--;\n      if (A[i] != cur) {\n        cout << 0 << nl;\n        return;\n      }\n    }\n  }\n  vector<vector<long long>> res = get(0, (int)(comps).size() - 1);\n  vector<mi> vals((int)(comps).size());\n  for (int i = 0; i < (4); i++) {\n    for (int j = 0; j < ((int)(comps).size()); j++) {\n      vals[j] += res[i][j];\n    }\n  }\n  mi ans = 0;\n  for (int i = 0; i < ((int)(comps).size()); i++) {\n    mi cur = pow(mi(2), (int)(comps).size() - i) *\n             facs[(int)(comps).size() - i] * vals[i];\n    if (i % 2) {\n      ans -= cur;\n    } else {\n      ans += cur;\n    }\n  }\n  cout << ans << nl;\n}\nint main() {\n  cin.tie(0)->sync_with_stdio(0);\n  cin.exceptions(cin.failbit);\n  int T = 1;\n  while (T--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"inline\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-fipa-sra\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-ffast-math\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fdevirtualize\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"inline-functions\")\n#pragma GCC optimize(\"-ftree-tail-merge\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fpartial-inlining\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-fhoist-adjacent-loads\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"inline-small-functions\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"inline-functions-called-once\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\nusing namespace std;\ntemplate <typename T>\nvoid r1(T &x) {\n  x = 0;\n  char c(getchar());\n  int f(1);\n  for (; c < '0' || c > '9'; c = getchar())\n    if (c == '-') f = -1;\n  for (; '0' <= c && c <= '9'; c = getchar()) x = (x * 10) + (c ^ 48);\n  x *= f;\n}\nconst int mod = 998244353;\ntemplate <typename T, typename... Args>\ninline void r1(T &t, Args &...args) {\n  r1(t);\n  r1(args...);\n}\nconst int maxn = 1e5 + 5;\nint n, a[maxn], s[maxn], tot(0);\nint d[2][maxn];\nint inc(int x, int y) { return x += y - mod, x + ((x >> 31) & mod); }\nvoid add(int &x, int y) { x = inc(x, y); }\nint Mod(int x) { return x -= mod, x + ((x >> 31) & mod); }\nsigned main() {\n  int i, j;\n  r1(n);\n  for (i = 1; i <= n; ++i) r1(a[i]);\n  for (i = 1; i <= n; i += a[i]) {\n    s[++tot] = (a[i] > 1);\n    for (j = i; j <= i + a[i] - 1; ++j)\n      if (a[i] != a[j]) return puts(\"0\"), 0;\n  }\n  d[s[1]][0] = 1;\n  for (i = 1; i < tot; ++i) {\n    if (s[i + 1]) {\n      for (j = i - 1; j >= 0; --j) {\n        add(d[1][j + 1], Mod(d[1][j] << 1));\n        add(d[1][j + 1], d[0][j]);\n        add(d[1][j], d[0][j]);\n        d[0][j] = 0;\n      }\n    } else {\n      for (j = i - 1; j >= 0; --j) {\n        add(d[0][j + 1], Mod(d[1][j] << 1));\n        add(d[0][j + 1], d[0][j]);\n        add(d[1][j], d[0][j]);\n        d[0][j] = 0;\n      }\n    }\n  }\n  long long ans(0), fac(1);\n  for (i = 1; i <= tot; ++i) {\n    fac = fac * i % mod;\n    long long tmp = (d[0][i - 1] + 2ll * d[1][i - 1]) % mod * fac % mod;\n    if ((tot - i) & 1)\n      ans = Mod(ans - tmp + mod);\n    else\n      ans = Mod(ans + tmp);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint *wwu[17 + 1], *wwv[17 + 1], vv[17 + 1];\nint ff[100000 + 1], pp2[100000 + 1];\nlong long power(long long a, int k) {\n  long long p = 1;\n  while (k) {\n    if (k & 1) p = p * a % 998244353;\n    a = a * a % 998244353;\n    k >>= 1;\n  }\n  return p;\n}\nvoid init() {\n  int i, l, u, v;\n  ff[0] = 1, pp2[0] = 1;\n  for (i = 1; i <= 100000; i++) {\n    ff[i] = (long long)ff[i - 1] * i % 998244353;\n    pp2[i] = pp2[i - 1] * 2 % 998244353;\n  }\n  u = power(3, 998244353 - 1 >> 17), v = power(u, 998244353 - 2);\n  for (l = 17; l > 0; l--) {\n    int n = 1 << l, m = n >> 1, i;\n    wwu[l] = (int *)malloc(m * sizeof *wwu[l]),\n    wwv[l] = (int *)malloc(m * sizeof *wwv[l]);\n    wwu[l][0] = wwv[l][0] = 1;\n    for (i = 1; i < m; i++) {\n      wwu[l][i] = (long long)wwu[l][i - 1] * u % 998244353;\n      wwv[l][i] = (long long)wwv[l][i - 1] * v % 998244353;\n    }\n    u = (long long)u * u % 998244353, v = (long long)v * v % 998244353;\n    vv[l] = power(1 << l, 998244353 - 2);\n  }\n}\nvoid ntt_(int *aa, int l_, int inverse) {\n  if (l_ > 0) {\n    int n = 1 << l_, m = n >> 1, *ww = inverse ? wwv[l_] : wwu[l_], i, j;\n    ntt_(aa, l_ - 1, inverse), ntt_(aa + m, l_ - 1, inverse);\n    for (i = 0; (j = i + m) < n; i++) {\n      int a = aa[i], b = (long long)aa[j] * ww[i] % 998244353;\n      if ((aa[i] = a + b) >= 998244353) aa[i] -= 998244353;\n      if ((aa[j] = a - b) < 0) aa[j] += 998244353;\n    }\n  }\n}\nvoid ntt(int *aa, int l_, int inverse) {\n  int n_ = 1 << l_, i, j;\n  for (i = 0, j = 1; j < n_; j++) {\n    int b = n_ >> 1, tmp;\n    while ((i ^= b) < b) b >>= 1;\n    if (i < j) tmp = aa[i], aa[i] = aa[j], aa[j] = tmp;\n  }\n  ntt_(aa, l_, inverse);\n}\nint ***alloc(int n) {\n  int ***dp = (int ***)malloc(2 * sizeof *dp);\n  int e, f;\n  for (e = 0; e < 2; e++) {\n    dp[e] = (int **)malloc(2 * sizeof *dp[e]);\n    for (f = 0; f < 2; f++) dp[e][f] = (int *)calloc(n, sizeof *dp[e][f]);\n  }\n  return dp;\n}\nchar single[100000];\nint aa[2][2][(1 << 17)], bb[2][2][(1 << 17)], cc[(1 << 17)];\nint ***solve(int l, int r) {\n  int ***dp = alloc(r - l + 3);\n  if (l > r)\n    dp[0][0][0] = dp[1][1][1] = 1;\n  else {\n    int m = (l + r) / 2, ***dpl = solve(l, m - 1), ***dpr = solve(m + 1, r), n_,\n        l_, e, f, g, h, i;\n    l_ = 0;\n    while (1 << l_ < r - l + 3) l_++;\n    n_ = 1 << l_;\n    for (e = 0; e < 2; e++)\n      for (f = 0; f < 2; f++) {\n        memset(aa[e][f], 0, n_ * sizeof *aa[e][f]);\n        memcpy(aa[e][f], dpl[e][f], (m - l + 2) * sizeof *dpl[e][f]);\n        ntt(aa[e][f], l_, 0);\n      }\n    for (g = 0; g < 2; g++)\n      for (h = 0; h < 2; h++) {\n        memset(bb[g][h], 0, n_ * sizeof *bb[g][h]);\n        memcpy(bb[g][h], dpr[g][h], (r - m + 2) * sizeof *dpr[g][h]);\n        ntt(bb[g][h], l_, 0);\n      }\n    for (e = 0; e < 2; e++)\n      for (h = 0; h < 2; h++) {\n        memset(cc, 0, n_ * sizeof *cc);\n        for (f = 0; f < 2; f++)\n          for (g = 0; g < 2; g++)\n            for (i = 0; i < n_; i++)\n              cc[i] =\n                  (cc[i] + (long long)aa[e][f][i] * bb[g][h][i] % 998244353 *\n                               (single[m] && f && g ? 499122177 : 1)) %\n                  998244353;\n        ntt(cc, l_, 1);\n        for (i = 0; i < n_; i++) cc[i] = (long long)cc[i] * vv[l_] % 998244353;\n        memcpy(dp[e][h], cc, (r - l + 3) * sizeof *cc);\n      }\n  }\n  return dp;\n}\nint main() {\n  static int aa[100000], ***dp;\n  int n, n_, h, i, j, k, ans;\n  init();\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) scanf(\"%d\", &aa[i]);\n  n_ = 0, i = 0;\n  for (i = 0; i < n; i += aa[i]) {\n    j = i + aa[i];\n    if (j > n) {\n      printf(\"0\\n\");\n      return 0;\n    }\n    for (h = i; h < j; h++)\n      if (aa[h] != aa[i]) {\n        printf(\"0\\n\");\n        return 0;\n      }\n    single[n_++] = aa[i] == 1;\n  }\n  n = n_;\n  dp = solve(0, n - 1);\n  ans = 0;\n  for (k = 1; k <= n; k++)\n    ans = (ans + (long long)((n - k) % 2 == 0 ? 1 : 998244353 - 1) * ff[k] %\n                     998244353 * pp2[k] % 998244353 * dp[1][1][k + 1]) %\n          998244353;\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <const int &MOD>\nstruct _m_int {\n  int val;\n  _m_int(int64_t v = 0) {\n    if (v < 0) v = v % MOD + MOD;\n    if (v >= MOD) v %= MOD;\n    val = int(v);\n  }\n  _m_int(uint64_t v) {\n    if (v >= MOD) v %= MOD;\n    val = int(v);\n  }\n  _m_int(int v) : _m_int(int64_t(v)) {}\n  _m_int(unsigned v) : _m_int(uint64_t(v)) {}\n  static int inv_mod(int a, int m = MOD) {\n    int g = m, r = a, x = 0, y = 1;\n    while (r != 0) {\n      int q = g / r;\n      g %= r;\n      swap(g, r);\n      x -= q * y;\n      swap(x, y);\n    }\n    return x < 0 ? x + m : x;\n  }\n  explicit operator int() const { return val; }\n  explicit operator unsigned() const { return val; }\n  explicit operator int64_t() const { return val; }\n  explicit operator uint64_t() const { return val; }\n  explicit operator double() const { return val; }\n  explicit operator long double() const { return val; }\n  _m_int &operator+=(const _m_int &other) {\n    val -= MOD - other.val;\n    if (val < 0) val += MOD;\n    return *this;\n  }\n  _m_int &operator-=(const _m_int &other) {\n    val -= other.val;\n    if (val < 0) val += MOD;\n    return *this;\n  }\n  static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n    return unsigned(x % m);\n    unsigned x_high = unsigned(x >> 32), x_low = unsigned(x);\n    unsigned quot, rem;\n    asm(\"divl %4\\n\" : \"=a\"(quot), \"=d\"(rem) : \"d\"(x_high), \"a\"(x_low), \"r\"(m));\n    return rem;\n  }\n  _m_int &operator*=(const _m_int &other) {\n    val = fast_mod(uint64_t(val) * other.val);\n    return *this;\n  }\n  _m_int &operator/=(const _m_int &other) { return *this *= other.inv(); }\n  friend _m_int operator+(const _m_int &a, const _m_int &b) {\n    return _m_int(a) += b;\n  }\n  friend _m_int operator-(const _m_int &a, const _m_int &b) {\n    return _m_int(a) -= b;\n  }\n  friend _m_int operator*(const _m_int &a, const _m_int &b) {\n    return _m_int(a) *= b;\n  }\n  friend _m_int operator/(const _m_int &a, const _m_int &b) {\n    return _m_int(a) /= b;\n  }\n  _m_int &operator++() {\n    val = val == MOD - 1 ? 0 : val + 1;\n    return *this;\n  }\n  _m_int &operator--() {\n    val = val == 0 ? MOD - 1 : val - 1;\n    return *this;\n  }\n  _m_int operator++(int) {\n    _m_int before = *this;\n    ++*this;\n    return before;\n  }\n  _m_int operator--(int) {\n    _m_int before = *this;\n    --*this;\n    return before;\n  }\n  _m_int operator-() const { return val == 0 ? 0 : MOD - val; }\n  friend bool operator==(const _m_int &a, const _m_int &b) {\n    return a.val == b.val;\n  }\n  friend bool operator!=(const _m_int &a, const _m_int &b) {\n    return a.val != b.val;\n  }\n  friend bool operator<(const _m_int &a, const _m_int &b) {\n    return a.val < b.val;\n  }\n  friend bool operator>(const _m_int &a, const _m_int &b) {\n    return a.val > b.val;\n  }\n  friend bool operator<=(const _m_int &a, const _m_int &b) {\n    return a.val <= b.val;\n  }\n  friend bool operator>=(const _m_int &a, const _m_int &b) {\n    return a.val >= b.val;\n  }\n  _m_int inv() const { return inv_mod(val); }\n  _m_int pow(int64_t p) const {\n    if (p < 0) return inv().pow(-p);\n    _m_int a = *this, result = 1;\n    while (p > 0) {\n      if (p & 1) result *= a;\n      a *= a;\n      p >>= 1;\n    }\n    return result;\n  }\n  friend ostream &operator<<(ostream &os, const _m_int &m) {\n    return os << m.val;\n  }\n};\nextern const int MOD = 998244353;\nusing Mint = _m_int<MOD>;\nconst int LOGN = 19;\nconst int N = (1 << LOGN);\nconst int T = 2;\nMint g = 3;\nvector<Mint> w[LOGN];\nvector<int> rv[LOGN];\nvoid precalc() {\n  Mint wb = Mint(g).pow((MOD - 1) / (1 << LOGN));\n  for (int st = 0; st < int(LOGN - 1); st++) {\n    w[st].assign(1 << st, 1);\n    Mint bw = wb.pow(1 << (LOGN - st - 1));\n    Mint cw = 1;\n    for (int k = 0; k < int(1 << st); k++) {\n      w[st][k] = cw;\n      cw *= bw;\n    }\n  }\n  for (int st = 0; st < int(LOGN); st++) {\n    rv[st].assign(1 << st, 0);\n    if (st == 0) {\n      rv[st][0] = 0;\n      continue;\n    }\n    int h = (1 << (st - 1));\n    for (int k = 0; k < int(1 << st); k++)\n      rv[st][k] = (rv[st - 1][k & (h - 1)] << 1) | (k >= h);\n  }\n}\nvoid ntt(vector<Mint> &a, bool inv) {\n  int n = ((int)((a).size()));\n  int ln = __builtin_ctz(n);\n  for (int i = 0; i < int(n); i++) {\n    int ni = rv[ln][i];\n    if (i < ni) swap(a[i], a[ni]);\n  }\n  for (int st = 0; st < int(ln); st++) {\n    int len = 1 << st;\n    for (int k = 0; k < n; k += (len << 1)) {\n      for (int pos = int(k); pos < int(k + len); pos++) {\n        Mint l = a[pos];\n        Mint r = a[pos + len] * w[st][pos - k];\n        a[pos] = l + r;\n        a[pos + len] = l - r;\n      }\n    }\n  }\n  if (inv) {\n    Mint rn = Mint(n).inv();\n    for (int i = 0; i < int(n); i++) a[i] *= rn;\n    reverse(a.begin() + 1, a.end());\n  }\n}\nvector<Mint> mul(vector<Mint> a, vector<Mint> b) {\n  int cnt =\n      1 << (32 - __builtin_clz(((int)((a).size())) + ((int)((b).size())) - 1));\n  a.resize(cnt);\n  b.resize(cnt);\n  ntt(a, false);\n  ntt(b, false);\n  vector<Mint> c(cnt);\n  for (int i = 0; i < int(cnt); i++) c[i] = a[i] * b[i];\n  ntt(c, true);\n  while (c.size() > 1 && c.back() == 0) c.pop_back();\n  return c;\n}\nstruct dp {\n  vector<Mint> val[T][T];\n  bool is_unit;\n  dp(){};\n  dp(int len) {\n    is_unit = len == 1;\n    for (int j = 0; j < T; j++)\n      for (int k = 0; k < T; k++) val[j][k] = {0};\n    if (len == 1)\n      val[0][0][0] = 1;\n    else\n      val[1][1][0] = 2;\n  }\n  dp(const dp &a, const dp &b) {\n    is_unit = false;\n    for (int l1 = 0; l1 < T; l1++)\n      for (int r1 = 0; r1 < T; r1++)\n        for (int l2 = 0; l2 < T; l2++)\n          for (int r2 = 0; r2 < T; r2++) {\n            vector<Mint> cur = mul(a.val[l1][r1], b.val[l2][r2]);\n            if (val[l1][r2].size() < cur.size()) val[l1][r2].resize(cur.size());\n            for (int i = 0; i < cur.size(); i++) val[l1][r2][i] += cur[i];\n            Mint merge_coeff = 2;\n            if (r1 == 1) merge_coeff /= 2;\n            if (l2 == 1) merge_coeff /= 2;\n            cur.insert(cur.begin(), 0);\n            for (int i = 0; i < cur.size(); i++) cur[i] *= merge_coeff;\n            int L1 = l1;\n            int R2 = r2;\n            if (a.is_unit) L1 = 1;\n            if (b.is_unit) R2 = 1;\n            if (val[L1][R2].size() < cur.size()) val[L1][R2].resize(cur.size());\n            for (int i = 0; i < cur.size(); i++) {\n              val[L1][R2][i] += cur[i];\n            }\n          }\n  }\n};\nostream &operator<<(ostream &out, const dp &a) {\n  for (int i = 0; i < T; i++)\n    for (int j = 0; j < T; j++) {\n      out << \"[\" << i << \"][\" << j << \"]\";\n      for (auto x : a.val[i][j]) out << \" \" << x;\n      out << endl;\n    }\n  return out;\n}\nint a[N];\nint len[N];\nMint fact[N];\nint n;\nint s;\ndp build(int l, int r) {\n  if (l == r - 1) {\n    dp res(len[l]);\n    return res;\n  } else {\n    int m = (l + r) / 2;\n    dp res(build(l, m), build(m, r));\n    return res;\n  }\n}\nint main() {\n  precalc();\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n  int cur = 0;\n  while (cur != n) {\n    if (cur + a[cur] > n) {\n      cout << 0 << endl;\n      return 0;\n    }\n    for (int l = cur; l < cur + a[cur]; l++)\n      if (a[l] != a[cur]) {\n        cout << 0 << endl;\n        return 0;\n      }\n    len[s++] = a[cur];\n    cur += a[cur];\n  }\n  fact[0] = 1;\n  for (int i = 1; i <= s; i++) fact[i] = i * fact[i - 1];\n  dp res = build(0, s);\n  Mint ans = 0;\n  for (int i = 0; i < s; i++)\n    for (int j = 0; j < T; j++)\n      for (int k = 0; k < T; k++)\n        if (res.val[j][k].size() > i)\n          ans += fact[s - i] * res.val[j][k][i] * (i % 2 == 0 ? 1 : MOD - 1);\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  char ch = getchar();\n  int nega = 1;\n  while (!isdigit(ch)) {\n    if (ch == '-') nega = -1;\n    ch = getchar();\n  }\n  int ans = 0;\n  while (isdigit(ch)) {\n    ans = ans * 10 + ch - 48;\n    ch = getchar();\n  }\n  if (nega == -1) return -ans;\n  return ans;\n}\nvoid print(vector<int> x) {\n  for (int i = 0; i < (int)x.size(); i++)\n    printf(\"%d%c\", x[i], \" \\n\"[i == (int)x.size() - 1]);\n}\ninline int add(int x, int y) {\n  return x + y >= 998244353 ? x + y - 998244353 : x + y;\n}\ninline int add(int x, int y, int z) { return add(add(x, y), z); }\ninline int sub(int x, int y) { return x - y < 0 ? x - y + 998244353 : x - y; }\ninline int mul(int x, int y) { return 1LL * x * y % 998244353; }\ninline int mul(int x, int y, int z) { return mul(mul(x, y), z); }\nint qpow(int x, int y) {\n  int ans = 1;\n  while (y) {\n    if (y & 1) ans = mul(ans, x);\n    x = mul(x, x);\n    y >>= 1;\n  }\n  return ans;\n}\nint Inv(int x) { return qpow(x, 998244353 - 2); }\nnamespace Poly {\nvector<int> rev, rt, one(1, 1);\nint __inv[2000005];\nconst int G = 3;\nvoid Init_Inv() {\n  __inv[0] = __inv[1] = 1;\n  for (int i = 2; i <= 2000000; i++)\n    __inv[i] = mul(998244353 - 998244353 / i, __inv[998244353 % i]);\n}\nvector<int> operator+(vector<int> a, vector<int> b) {\n  int n = max(a.size(), b.size());\n  a.resize(n), b.resize(n);\n  for (int i = 0; i < n; i++) a[i] = add(a[i], b[i]);\n  return a;\n}\nvector<int> operator-(vector<int> a, vector<int> b) {\n  int n = max(a.size(), b.size());\n  a.resize(n), b.resize(n);\n  for (int i = 0; i < n; i++) a[i] = sub(a[i], b[i]);\n  return a;\n}\nvoid init(int B) {\n  int n = 1 << B;\n  rev.resize(n), rt.resize(n);\n  for (int i = 1; i < n; i++)\n    rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (B - 1));\n  for (int mid = 1; mid < n; mid <<= 1) {\n    int w = qpow(G, (998244353 - 1) / (mid << 1));\n    rt[mid] = 1;\n    for (int i = 1; i < mid; i++) rt[mid + i] = mul(rt[mid + i - 1], w);\n  }\n}\nvoid ntt(vector<int> &a, int B) {\n  for (int i = 0; i < (int)a.size(); i++)\n    if (rev[i] > i) swap(a[rev[i]], a[i]);\n  for (int i = 1; i < 1 << B; i <<= 1) {\n    for (int j = 0; j < 1 << B; j += i << 1) {\n      for (int k = 0; k < i; k++) {\n        int x = a[j + k], y = mul(a[i + j + k], rt[i + k]);\n        a[j + k] = add(x, y), a[i + j + k] = sub(x, y);\n      }\n    }\n  }\n}\nvoid idft(vector<int> &a, int B) {\n  reverse(a.begin() + 1, a.end());\n  ntt(a, B);\n  int I = Inv(1 << B);\n  for (int i = 0; i < (int)a.size(); i++) a[i] = mul(a[i], I);\n}\nvector<int> operator*(vector<int> x, vector<int> y) {\n  int n = x.size() + y.size() - 1;\n  int B = 0;\n  while (1 << B < n) B++;\n  x.resize(1 << B), y.resize(1 << B);\n  init(B);\n  ntt(x, B), ntt(y, B);\n  for (int i = 0; i < 1 << B; i++) x[i] = mul(x[i], y[i]);\n  idft(x, B);\n  x.resize(n);\n  return x;\n}\n};  // namespace Poly\nusing namespace Poly;\nconst int i2 = (998244353 + 1) / 2;\nint fac[100005], inv[100005], ifac[100005];\nint norm(int x) { return ((x % 998244353) + 998244353) % 998244353; }\nvoid init() {\n  fac[0] = 1;\n  for (int i = 1; i < 100005; i++) fac[i] = mul(fac[i - 1], i);\n  inv[0] = inv[1] = 1;\n  for (int i = 2; i < 100005; i++)\n    inv[i] = mul(998244353 - 998244353 / i, inv[998244353 % i]);\n  ifac[0] = 1;\n  for (int i = 1; i < 100005; i++) ifac[i] = mul(ifac[i - 1], inv[i]);\n}\nint C(int x, int y) { return x >= y ? mul(fac[x], ifac[x - y], ifac[y]) : 0; }\nint a[100005], b[100005], n, m;\nstruct Node {\n  vector<int> a[2][2];\n  int coef;\n  Node() {\n    coef = 0;\n    for (int i = 0; i < 2; i++)\n      for (int j = 0; j < 2; j++) a[i][j].resize(1);\n  }\n};\nvector<int> shift(vector<int> a) {\n  int n = (int)a.size() + 1;\n  vector<int> ans(n);\n  for (int i = 0; i < (int)a.size(); i++) ans[i + 1] = a[i];\n  return ans;\n}\nvector<int> mul(vector<int> a, int b) {\n  b = norm(b);\n  for (int i = 0; i < (int)a.size(); i++) a[i] = mul(a[i], b);\n  return a;\n}\nint sgn(int x) {\n  if (x > 0)\n    return 1;\n  else if (x == 0)\n    return 0;\n  else\n    return -1;\n}\nNode solve(int l, int r) {\n  if (l == r) {\n    Node ans;\n    ans.coef = a[l] > 1 ? 2 : 1;\n    return ans;\n  }\n  int mid = (l + r) / 2;\n  Node A = solve(l, mid), B = solve(mid + 1, r);\n  Node ans;\n  ans.coef = sgn(A.coef) * sgn(B.coef) * -2;\n  int c = abs(A.coef), d = abs(B.coef);\n  int p = c > 1, q = d > 1;\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 2; j++) {\n      for (int c = 0; c < 2; c++)\n        for (int d = 0; d < 2; d++) {\n          vector<int> r = A.a[i][j] * B.a[c][d];\n          ans.a[i][d] = ans.a[i][d] + shift(r);\n          if (j == 1 && c == 1) r = mul(r, i2);\n          if (j == 0 && c == 0) r = mul(r, 2);\n          ans.a[i][d] = ans.a[i][d] - r;\n        }\n    }\n  for (int i = 0; i < 2; i++)\n    for (int j = 0; j < 2; j++) {\n      ans.a[i][q] = ans.a[i][q] + shift(mul(A.a[i][j], B.coef));\n      int qwq = (j == 0) ? 2 : 1;\n      qwq *= sgn(B.coef);\n      ans.a[i][1] = ans.a[i][1] - mul(A.a[i][j], qwq);\n    }\n  for (int c = 0; c < 2; c++)\n    for (int d = 0; d < 2; d++) {\n      ans.a[p][d] = ans.a[p][d] + shift(mul(B.a[c][d], A.coef));\n      int qwq = (c == 0) ? 2 : 1;\n      qwq *= sgn(A.coef);\n      ans.a[1][d] = ans.a[1][d] - mul(B.a[c][d], qwq);\n    }\n  c = c > 1, d = d > 1;\n  if (ans.a[c][d].size() < 2) ans.a[c][d].resize(2);\n  ans.a[c][d][1] = add(ans.a[c][d][1], norm(A.coef * B.coef));\n  return ans;\n}\nsigned main() {\n  init();\n  cin >> n;\n  for (int i = 1; i <= n; i++) b[i] = read();\n  for (int i = 1; i <= n;) {\n    a[++m] = b[i];\n    for (int j = 0; j < b[i]; j++)\n      if (b[i + j] != b[i]) return cout << \"0\\n\", 0;\n    i += b[i];\n  }\n  Node res = solve(1, m);\n  int Ans = 0;\n  vector<int> ans = res.a[0][0] + res.a[0][1] + res.a[1][0] + res.a[1][1];\n  ans[0] = add(ans[0], res.coef);\n  for (int i = 0; i < (int)ans.size(); i++)\n    Ans = add(Ans, mul(fac[i + 1], ans[i]));\n  cout << Ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nbool checkmax(T &a, T b) {\n  return b > a ? a = b, 1 : 0;\n}\ntemplate <class T>\nbool checkmin(T &a, T b) {\n  return b < a ? a = b, 1 : 0;\n}\nconst int N = 100005, mod = 998244353;\nvoid add(int &a, int b) {\n  a += b;\n  (a >= mod) && (a -= mod);\n}\nvoid mul(int &a, int b) { a = (long long)a * b % mod; }\nint Add(int a, int b) {\n  a += b;\n  return a >= mod ? a - mod : a;\n}\nint Sub(int a, int b) {\n  a -= b;\n  return a < 0 ? a + mod : a;\n}\nint Mul(int a, int b) { return (long long)a * b % mod; }\nint qpow(int a, int b) {\n  int ans = 1;\n  while (b) {\n    if (b & 1) mul(ans, a);\n    mul(a, a);\n    b >>= 1;\n  }\n  return ans;\n}\nint n, m = 0;\nint a[N], seq[N];\nint pw2[N], fac[N];\nvoid prepare(int n) {\n  fac[0] = 1;\n  for (int i = 1; i <= n; ++i) fac[i] = Mul(fac[i - 1], i);\n  pw2[0] = 1;\n  for (int i = 1; i <= n; ++i) pw2[i] = Mul(pw2[i - 1], 2);\n}\nvoid init() {\n  prepare(100000);\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n  for (int i = 1; i <= n;) {\n    if (i + a[i] - 1 > n) {\n      printf(\"0\\n\");\n      exit(0);\n    };\n    for (int j = i; j <= i + a[i] - 1; ++j) {\n      if (a[j] != a[i]) {\n        printf(\"0\\n\");\n        exit(0);\n      };\n    }\n    seq[++m] = a[i];\n    i += a[i];\n  }\n}\nnamespace fft {\nvector<int> w[22];\nint rev[1 << 18];\nvoid prepare(int n) {\n  for (int i = 1; i <= n; ++i) {\n    w[i].resize(1 << i);\n    w[i][0] = 1, w[i][1] = qpow(3, (mod - 1) >> i);\n    for (int j = 2; j < (1 << i); ++j) {\n      w[i][j] = Mul(w[i][j - 1], w[i][1]);\n    }\n  }\n}\nvoid init(int n) {\n  for (int i = 0; i < n; ++i)\n    rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? (n >> 1) : 0);\n}\nvoid dft(int *a, int n) {\n  for (int i = 0; i < n; ++i)\n    if (i < rev[i]) swap(a[i], a[rev[i]]);\n  for (int mid = 1, rnd = 1; mid < n; mid <<= 1, ++rnd) {\n    for (int i = 0; i < n; i += (mid << 1)) {\n      int *W = &w[rnd][0], *l = a + i, *r = a + i + mid, t;\n      for (int j = 0; j < mid; ++j, ++W, ++l, ++r) {\n        t = Mul(*W, *r);\n        *r = Sub(*l, t);\n        add(*l, t);\n      }\n    }\n  }\n}\nvoid idft(int *a, int n) {\n  dft(a, n);\n  reverse(a + 1, a + n);\n  int I = qpow(n, mod - 2);\n  for (int i = 0; i < n; ++i) mul(a[i], I);\n}\n}  // namespace fft\nusing fft::dft;\nusing fft::idft;\nstruct mat {\n  vector<int> a[2][2];\n} p[N];\nvector<int> operator+(vector<int> a, vector<int> b) {\n  a.resize(max((int)a.size(), (int)b.size()));\n  for (int i = 0; i < (int)b.size(); ++i) add(a[i], b[i]);\n  return a;\n}\nvector<int> operator*(vector<int> a, int b) {\n  for (int i = 0; i < (int)a.size(); ++i) mul(a[i], b);\n  return a;\n}\nvector<int> operator*(vector<int> a, vector<int> b) {\n  if (a.empty() || b.empty()) return vector<int>();\n  int rn = (int)a.size() + (int)b.size() - 1, n = 1;\n  while (n < rn) n <<= 1;\n  fft::init(n);\n  a.resize(n);\n  b.resize(n);\n  dft(&a[0], n);\n  dft(&b[0], n);\n  for (int i = 0; i < n; ++i) mul(a[i], b[i]);\n  idft(&a[0], n);\n  a.resize(rn);\n  return a;\n}\nmat operator*(mat a, mat b) {\n  mat c;\n  c.a[0][0] = a.a[0][0] * b.a[0][0] + a.a[0][1] * b.a[1][0];\n  c.a[0][1] = a.a[0][0] * b.a[0][1] + a.a[0][1] * b.a[1][1];\n  c.a[1][0] = a.a[1][0] * b.a[0][0] + a.a[1][1] * b.a[1][0];\n  c.a[1][1] = a.a[1][0] * b.a[0][1] + a.a[1][1] * b.a[1][1];\n  return c;\n}\nmat divi(int l, int r) {\n  if (l == r) return p[l];\n  int mid = (l + r) >> 1;\n  return divi(l, mid) * divi(mid + 1, r);\n}\nvoid solve() {\n  fft::prepare(18);\n  vector<int> ii = {0}, ia = {1}, ib = {2}, ic = {0, 1}, id = {2, 1},\n              ie = {1, 1};\n  if (seq[1] == 1)\n    p[1].a[0][1] = ia;\n  else\n    p[1].a[0][0] = ia;\n  for (int i = 2; i <= m; ++i) {\n    if (seq[i] == 1)\n      p[i] = (mat){ic, ib, ic, ia};\n    else\n      p[i] = (mat){id, ii, ie, ii};\n  }\n  mat o = divi(1, m);\n  vector<int> F = o.a[0][0] * 2 + o.a[0][1];\n  int ans = 0;\n  for (int i = 0; i < (int)F.size(); ++i) {\n    int p = Mul(fac[m - i], F[i]);\n    if (i & 1) p = (p == 0 ? 0 : mod - p);\n    add(ans, p);\n  }\n  printf(\"%d\\n\", ans);\n}\nint main() {\n  init();\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid chkmax(T &first, T second) {\n  first < second ? first = second : T();\n}\ntemplate <typename T>\nvoid chkmin(T &first, T second) {\n  second < first ? first = second : T();\n}\ntemplate <typename T>\nvoid readint(T &first) {\n  first = 0;\n  int f = 1;\n  char c;\n  for (c = getchar(); !isdigit(c); c = getchar())\n    if (c == '-') f = -1;\n  for (; isdigit(c); c = getchar()) first = first * 10 + (c - '0');\n  first *= f;\n}\nconst int MOD = 998244353;\ninline int dmy(int first) { return first >= MOD ? first - MOD : first; }\ninline void inc(int &first, int second) {\n  (first += second) >= MOD ? first -= MOD : 0;\n}\nint qmi(int first, int second) {\n  int ans = 1;\n  for (; second; second >>= 1, first = 1ll * first * first % MOD)\n    if (second & 1) ans = 1ll * ans * first % MOD;\n  return ans;\n}\nconst int MAXN = 100005;\nint n, a[MAXN], dp[2][MAXN];\nint m, b[MAXN], fac[MAXN];\nint main() {\n  readint(m);\n  for (int i = 1; i <= m; ++i) readint(b[i]);\n  for (int u = 1; u <= m; u += b[u]) {\n    if (u + b[u] - 1 > m) return 0 * printf(\"0\\n\");\n    for (int i = u; i <= u + b[u] - 1; ++i)\n      if (b[i] != b[u]) return 0 * printf(\"0\\n\");\n    a[++n] = (b[u] > 1);\n  }\n  dp[a[1]][1] = 1 + a[1];\n  for (int i = 2; i <= n; ++i)\n    if (!a[i]) {\n      for (int j = i - 1; j; --j)\n        inc(dp[0][j + 1], dp[0][j]), inc(dp[0][j + 1], dp[1][j]),\n            inc(dp[1][j], dmy(dp[0][j] << 1)), dp[0][j] = 0;\n    } else {\n      for (int j = i - 1, u; j; --j)\n        u = dmy(dp[0][j] << 1), inc(dp[1][j + 1], u),\n        inc(dp[1][j + 1], dmy(dp[1][j] << 1)), inc(dp[1][j], u), dp[0][j] = 0;\n    }\n  fac[0] = 1;\n  for (int i = 1; i <= n; ++i) fac[i] = 1ll * fac[i - 1] * i % MOD;\n  int res = 0;\n  for (int i = 1; i <= n; ++i) {\n    int t = 1ll * fac[i] * (dp[0][i] + dp[1][i]) % MOD;\n    if ((n - i) & 1)\n      inc(res, MOD - t);\n    else\n      inc(res, t);\n  }\n  printf(\"%d\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <const int &MOD>\nstruct _m_int {\n  int val;\n  _m_int(int64_t v = 0) {\n    if (v < 0) v = v % MOD + MOD;\n    if (v >= MOD) v %= MOD;\n    val = int(v);\n  }\n  _m_int(uint64_t v) {\n    if (v >= MOD) v %= MOD;\n    val = int(v);\n  }\n  _m_int(int v) : _m_int(int64_t(v)) {}\n  _m_int(unsigned v) : _m_int(uint64_t(v)) {}\n  static int inv_mod(int a, int m = MOD) {\n    int g = m, r = a, x = 0, y = 1;\n    while (r != 0) {\n      int q = g / r;\n      g %= r;\n      swap(g, r);\n      x -= q * y;\n      swap(x, y);\n    }\n    return x < 0 ? x + m : x;\n  }\n  explicit operator int() const { return val; }\n  explicit operator unsigned() const { return val; }\n  explicit operator int64_t() const { return val; }\n  explicit operator uint64_t() const { return val; }\n  explicit operator double() const { return val; }\n  explicit operator long double() const { return val; }\n  _m_int &operator+=(const _m_int &other) {\n    val -= MOD - other.val;\n    if (val < 0) val += MOD;\n    return *this;\n  }\n  _m_int &operator-=(const _m_int &other) {\n    val -= other.val;\n    if (val < 0) val += MOD;\n    return *this;\n  }\n  static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n    return unsigned(x % m);\n    unsigned x_high = unsigned(x >> 32), x_low = unsigned(x);\n    unsigned quot, rem;\n    asm(\"divl %4\\n\" : \"=a\"(quot), \"=d\"(rem) : \"d\"(x_high), \"a\"(x_low), \"r\"(m));\n    return rem;\n  }\n  _m_int &operator*=(const _m_int &other) {\n    val = fast_mod(uint64_t(val) * other.val);\n    return *this;\n  }\n  _m_int &operator/=(const _m_int &other) { return *this *= other.inv(); }\n  friend _m_int operator+(const _m_int &a, const _m_int &b) {\n    return _m_int(a) += b;\n  }\n  friend _m_int operator-(const _m_int &a, const _m_int &b) {\n    return _m_int(a) -= b;\n  }\n  friend _m_int operator*(const _m_int &a, const _m_int &b) {\n    return _m_int(a) *= b;\n  }\n  friend _m_int operator/(const _m_int &a, const _m_int &b) {\n    return _m_int(a) /= b;\n  }\n  _m_int &operator++() {\n    val = val == MOD - 1 ? 0 : val + 1;\n    return *this;\n  }\n  _m_int &operator--() {\n    val = val == 0 ? MOD - 1 : val - 1;\n    return *this;\n  }\n  _m_int operator++(int) {\n    _m_int before = *this;\n    ++*this;\n    return before;\n  }\n  _m_int operator--(int) {\n    _m_int before = *this;\n    --*this;\n    return before;\n  }\n  _m_int operator-() const { return val == 0 ? 0 : MOD - val; }\n  friend bool operator==(const _m_int &a, const _m_int &b) {\n    return a.val == b.val;\n  }\n  friend bool operator!=(const _m_int &a, const _m_int &b) {\n    return a.val != b.val;\n  }\n  friend bool operator<(const _m_int &a, const _m_int &b) {\n    return a.val < b.val;\n  }\n  friend bool operator>(const _m_int &a, const _m_int &b) {\n    return a.val > b.val;\n  }\n  friend bool operator<=(const _m_int &a, const _m_int &b) {\n    return a.val <= b.val;\n  }\n  friend bool operator>=(const _m_int &a, const _m_int &b) {\n    return a.val >= b.val;\n  }\n  _m_int inv() const { return inv_mod(val); }\n  _m_int pow(int64_t p) const {\n    if (p < 0) return inv().pow(-p);\n    _m_int a = *this, result = 1;\n    while (p > 0) {\n      if (p & 1) result *= a;\n      a *= a;\n      p >>= 1;\n    }\n    return result;\n  }\n  friend ostream &operator<<(ostream &os, const _m_int &m) {\n    return os << m.val;\n  }\n};\nextern const int MOD = 998244353;\nusing Mint = _m_int<MOD>;\nconst int LOGN = 19;\nconst int N = (1 << LOGN);\nconst int T = 2;\nMint g = 3;\nvector<Mint> w[LOGN];\nvector<int> rv[LOGN];\nvoid precalc() {\n  Mint wb = Mint(g).pow((MOD - 1) / (1 << LOGN));\n  for (int st = 0; st < int(LOGN - 1); st++) {\n    w[st].assign(1 << st, 1);\n    Mint bw = wb.pow(1 << (LOGN - st - 1));\n    Mint cw = 1;\n    for (int k = 0; k < int(1 << st); k++) {\n      w[st][k] = cw;\n      cw *= bw;\n    }\n  }\n  for (int st = 0; st < int(LOGN); st++) {\n    rv[st].assign(1 << st, 0);\n    if (st == 0) {\n      rv[st][0] = 0;\n      continue;\n    }\n    int h = (1 << (st - 1));\n    for (int k = 0; k < int(1 << st); k++)\n      rv[st][k] = (rv[st - 1][k & (h - 1)] << 1) | (k >= h);\n  }\n}\nvoid ntt(vector<Mint> &a, bool inv) {\n  int n = ((int)((a).size()));\n  int ln = __builtin_ctz(n);\n  for (int i = 0; i < int(n); i++) {\n    int ni = rv[ln][i];\n    if (i < ni) swap(a[i], a[ni]);\n  }\n  for (int st = 0; st < int(ln); st++) {\n    int len = 1 << st;\n    for (int k = 0; k < n; k += (len << 1)) {\n      for (int pos = int(k); pos < int(k + len); pos++) {\n        Mint l = a[pos];\n        Mint r = a[pos + len] * w[st][pos - k];\n        a[pos] = l + r;\n        a[pos + len] = l - r;\n      }\n    }\n  }\n  if (inv) {\n    Mint rn = Mint(n).inv();\n    for (int i = 0; i < int(n); i++) a[i] *= rn;\n    reverse(a.begin() + 1, a.end());\n  }\n}\nvector<Mint> mul(vector<Mint> a, vector<Mint> b) {\n  int cnt =\n      1 << (32 - __builtin_clz(((int)((a).size())) + ((int)((b).size())) - 1));\n  a.resize(cnt);\n  b.resize(cnt);\n  ntt(a, false);\n  ntt(b, false);\n  vector<Mint> c(cnt);\n  for (int i = 0; i < int(cnt); i++) c[i] = a[i] * b[i];\n  ntt(c, true);\n  while (c.size() > 1 && c.back() == 0) c.pop_back();\n  return c;\n}\nstruct dp {\n  vector<Mint> val[T][T];\n  bool is_unit;\n  dp(){};\n  dp(int len) {\n    is_unit = len == 1;\n    for (int j = 0; j < T; j++)\n      for (int k = 0; k < T; k++) val[j][k] = {0};\n    if (len == 1)\n      val[0][0][0] = 1;\n    else\n      val[1][1][0] = 2;\n  }\n  dp(const dp &a, const dp &b) {\n    is_unit = false;\n    for (int l1 = 0; l1 < T; l1++)\n      for (int r1 = 0; r1 < T; r1++)\n        for (int l2 = 0; l2 < T; l2++)\n          for (int r2 = 0; r2 < T; r2++) {\n            vector<Mint> cur = mul(a.val[l1][r1], b.val[l2][r2]);\n            if (val[l1][r2].size() < cur.size()) val[l1][r2].resize(cur.size());\n            for (int i = 0; i < cur.size(); i++) val[l1][r2][i] += cur[i];\n            Mint merge_coeff = 2;\n            if (r1 == 1) merge_coeff /= 2;\n            if (l2 == 1) merge_coeff /= 2;\n            cur.insert(cur.begin(), 0);\n            for (int i = 0; i < cur.size(); i++) cur[i] *= merge_coeff;\n            int L1 = l1;\n            int R2 = r2;\n            if (a.is_unit) L1 = 1;\n            if (b.is_unit) R2 = 1;\n            if (val[L1][R2].size() < cur.size()) val[L1][R2].resize(cur.size());\n            for (int i = 0; i < cur.size(); i++) {\n              val[L1][R2][i] += cur[i];\n            }\n          }\n  }\n};\nostream &operator<<(ostream &out, const dp &a) {\n  for (int i = 0; i < T; i++)\n    for (int j = 0; j < T; j++) {\n      out << \"[\" << i << \"][\" << j << \"]\";\n      for (auto x : a.val[i][j]) out << \" \" << x;\n      out << endl;\n    }\n  return out;\n}\nint a[N];\nint len[N];\nMint fact[N];\nint n;\nint s;\ndp build(int l, int r) {\n  if (l == r - 1) {\n    dp res(len[l]);\n    return res;\n  } else {\n    int m = (l + r) / 2;\n    dp res(build(l, m), build(m, r));\n    return res;\n  }\n}\nint main() {\n  precalc();\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n  int cur = 0;\n  while (cur != n) {\n    if (cur + a[cur] > n) {\n      cout << 0 << endl;\n      return 0;\n    }\n    for (int l = cur; l < cur + a[cur]; l++)\n      if (a[l] != a[cur]) {\n        cout << 0 << endl;\n        return 0;\n      }\n    len[s++] = a[cur];\n    cur += a[cur];\n  }\n  fact[0] = 1;\n  for (int i = 1; i <= s; i++) fact[i] = i * fact[i - 1];\n  dp res = build(0, s);\n  Mint ans = 0;\n  for (int i = 0; i < s; i++)\n    for (int j = 0; j < T; j++)\n      for (int k = 0; k < T; k++)\n        if (res.val[j][k].size() > i)\n          ans += fact[s - i] * res.val[j][k][i] * (i % 2 == 0 ? 1 : MOD - 1);\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint abc;\ninline int rd(int l, int r) { return rand() % (r - l + 1) + l; }\nconst int mxn = 2e5 + 3, mod = 998244353;\nlong long por(long long x, int y = mod - 2) {\n  long long r = 1;\n  for (; y; y >>= 1) {\n    if (y & 1) r = r * x % mod;\n    x = x * x % mod;\n  }\n  return r;\n}\nint n, a[mxn], m, R[mxn], N;\nlong long w[2][mxn];\nbool b[mxn];\nbool chk() {\n  for (int i = 1; i <= n;) {\n    int x = a[i], y = x;\n    b[++m] = x > 1;\n    while (y--) {\n      if (a[i] != x) return 0;\n      ++i;\n    }\n  }\n  return 1;\n}\nstruct VV {\n  vector<long long> a[2][2];\n  void ii(int s) {\n    a[0][0].resize(s), a[0][1].resize(s), a[1][0].resize(s), a[1][1].resize(s);\n  }\n};\nvoid ntt(vector<long long>& a, int n, bool tp = 0) {\n  for (int i = 1; i < n; ++i) R[i] = R[i >> 1] >> 1, R[i] |= (i & 1) * (n >> 1);\n  for (int i = 0; i < n; ++i) a[i] %= mod;\n  for (int i = 0; i < n; ++i)\n    if (i > R[i]) swap(a[i], a[R[i]]);\n  for (int d = 1, t = N >> 1; d < n; d *= 2, t >>= 1) {\n    for (int i = 0; i < n; i += d * 2)\n      for (int j = 0; j < d; ++j) {\n        long long x = a[i + j + d] * w[tp][t * j];\n        a[i + j + d] = (a[i + j] - x) % mod, a[i + j] = (a[i + j] + x) % mod;\n      }\n  }\n  if (tp) {\n    long long iv = por(n);\n    for (int i = 0; i < n; ++i) a[i] = a[i] * iv % mod;\n  }\n}\nvector<long long> d;\nvoid NTT(vector<long long>& a, vector<long long>& b, vector<long long>& c,\n         int t1, int t2) {\n  for (int i = 0; i < n; ++i) d[i] = a[i] * b[i] % mod;\n  ntt(d, n, 1);\n  for (int i = 0; i < n; ++i)\n    if (d[i]) c[i] += d[i] * (t1 + 1) * (t2 + 1), c[i - 1] += d[i] * 2;\n  for (int i = 0; i < n; ++i) c[i] %= mod;\n}\nVV sol(int L, int R) {\n  if (L == R) {\n    VV r;\n    r.ii(2);\n    r.a[b[L]][b[L]][1] = 1;\n    return r;\n  }\n  int md = (L + R) >> 1;\n  VV v1 = sol(L, md), v2 = sol(md + 1, R), re;\n  n = 1;\n  while (n <= R - L + 1) n *= 2;\n  v1.ii(n), v2.ii(n), re.ii(n), d.resize(n);\n  for (int i1 = 0; i1 <= 1; ++i1)\n    for (int i2 = 0; i2 <= 1; ++i2)\n      for (int i3 = 0; i3 <= 1; ++i3)\n        for (int i4 = 0; i4 <= 1; ++i4) {\n          vector<long long>&h1 = v1.a[i1][i2], &h2 = v2.a[i3][i4];\n          h1[1] = (h1[1] + mod) % mod, h2[1] = (h2[1] + mod) % mod;\n          assert(h1[0] == 0 && h2[0] == 0);\n          assert(h1[1] >= 0 && h1[1] <= 1 && h2[1] >= 0 && h2[1] <= 1);\n          if (i1 == i2 && i3 == i4)\n            re.a[i1][i3][2] += h1[1] * h2[1], re.a[1][1][1] += h1[1] * h2[1];\n          if (i1 == i2) {\n            if (h1[1])\n              for (int i = 2; i < n; ++i) {\n                if (h2[i])\n                  assert(i + 1 < n), re.a[i1][i4][i + 1] += (i3 + 1) * h2[i],\n                      re.a[1][i4][i] += h2[i];\n              }\n          }\n          if (i3 == i4) {\n            if (h2[1])\n              for (int i = 2; i < n; ++i) {\n                if (h1[i])\n                  assert(i + 1 < n), re.a[i1][i4][i + 1] += (i2 + 1) * h1[i],\n                      re.a[i1][1][i] += h1[i];\n              }\n          }\n        }\n  for (int i = 0; i <= 1; ++i)\n    for (int j = 0; j <= 1; ++j) {\n      vector<long long>& v = v1.a[i][j];\n      v[1] = 0;\n      ntt(v, n);\n    }\n  for (int i = 0; i <= 1; ++i)\n    for (int j = 0; j <= 1; ++j) {\n      vector<long long>& v = v2.a[i][j];\n      v[1] = 0;\n      ntt(v, n);\n    }\n  for (int i1 = 0; i1 <= 1; ++i1)\n    for (int i2 = 0; i2 <= 1; ++i2)\n      for (int i3 = 0; i3 <= 1; ++i3)\n        for (int i4 = 0; i4 <= 1; ++i4)\n          NTT(v1.a[i1][i2], v2.a[i3][i4], re.a[i1][i4], i2, i3);\n  return re;\n}\nint main() {\n  abc = scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) abc = scanf(\"%d\", a + i);\n  if (!chk()) return puts(\"0\"), 0;\n  N = 1;\n  while (N <= m) N *= 2;\n  assert(N < mxn && (mod - 1) % N == 0);\n  w[0][0] = w[1][0] = 1, w[0][1] = por(3, (mod - 1) / N),\n  w[1][1] = por(w[0][1]);\n  for (int i = 2; i < N; ++i)\n    w[0][i] = w[0][i - 1] * w[0][1] % mod,\n    w[1][i] = w[1][i - 1] * w[1][1] % mod;\n  VV re = sol(1, m);\n  long long ans = 0;\n  for (int i1 = 0; i1 <= 1; ++i1)\n    for (int i2 = 0; i2 <= 1; ++i2) {\n      vector<long long>& v = re.a[i1][i2];\n      long long jc = (m & 1) ? -1 : 1;\n      for (int i = 1; i <= m; ++i) {\n        jc *= -i, jc %= mod;\n        if (i == 1)\n          ans += v[i] * (i1 + 1) * jc % mod;\n        else\n          ans += v[i] * (i1 + 1) * (i2 + 1) * jc % mod;\n      }\n      ans %= mod;\n    }\n  printf(\"%lld\\n\", (ans % mod + mod) % mod);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nbool chkmax(T &x, T y) {\n  return x < y ? x = y, true : false;\n}\ntemplate <typename T>\nbool chkmin(T &x, T y) {\n  return x > y ? x = y, true : false;\n}\nint readint() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return x * f;\n}\nconst int cys = 998244353;\nint n, m;\nint a[100005], b[100005], d[2][100005];\nint mod(int x) { return x >= cys ? x - cys : x; }\nvoid add(int &x, int y) { x = mod(x + y); }\nint main() {\n  n = readint();\n  for (int i = 1; i <= n; i++) a[i] = readint();\n  bool fl = 0;\n  for (int i = 1; i <= n; i++) {\n    for (int j = i; j <= i + a[i] - 1; j++)\n      if (a[j] != a[i]) fl = 1;\n    i += a[i] - 1;\n    b[++m] = a[i] > 1;\n  }\n  if (fl) return printf(\"0\\n\"), 0;\n  d[b[1]][0] = 1;\n  for (int i = 1; i < m; i++) {\n    if (b[i + 1]) {\n      for (int j = i - 1; j >= 0; j--) {\n        add(d[1][j + 1], mod(d[1][j] << 1));\n        add(d[1][j + 1], d[0][j]);\n        add(d[1][j], d[0][j]);\n        d[0][j] = 0;\n      }\n    } else {\n      for (int j = i - 1; j >= 0; j--) {\n        add(d[0][j + 1], mod(d[1][j] << 1));\n        add(d[0][j + 1], d[0][j]);\n        add(d[1][j], d[0][j]);\n        d[0][j] = 0;\n      }\n    }\n  }\n  long long ans = 0, now = 1;\n  for (int i = 1; i <= m; i++) {\n    now = now * i % cys;\n    long long tmp = (d[0][i - 1] + 2ll * d[1][i - 1]) % cys * now % cys;\n    if ((m - i) & 1)\n      ans = mod(ans + cys - tmp);\n    else\n      ans = mod(ans + tmp);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\nusing ll = long long;\nusing vi = vector<int>;\ninline void add(int &x, int y) {\n  x += y;\n  if (x >= mod) x -= mod;\n}\ninline void sub(int &x, int y) {\n  x -= y;\n  if (x < 0) x += mod;\n}\ninline int mul(int x, int y) { return 1ll * x * y % mod; }\ninline int pow_mod(int q, int w) {\n  int ret = 1;\n  while (w) {\n    if (w & 1) ret = mul(ret, q);\n    q = mul(q, q);\n    w >>= 1;\n  }\n  return ret;\n}\nnamespace Polynomial {\nvector<int> rev = {0, 1};\ninline int getlen(int x) {\n  int len = 1;\n  while (len <= x) len <<= 1;\n  return len;\n}\nvoid dft(vi &a, int on) {\n  int cnt = 0, len = a.size();\n  while ((1 << cnt) < len) ++cnt;\n  rev.resize(len);\n  for (int i = 0; i < len; ++i) {\n    rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (cnt - 1));\n    if (i < rev[i]) swap(a[i], a[rev[i]]);\n  }\n  for (int h = 1; h < len; h <<= 1) {\n    int wn = pow_mod(3, (mod - 1) / (h << 1));\n    for (int j = 0; j < len; j += (h << 1)) {\n      int w = 1;\n      for (int k = j; k < j + h; k++) {\n        int u = a[k] % mod;\n        int t = 1ll * w * a[k + h] % mod;\n        a[k] = (u + t) % mod;\n        a[k + h] = (u + mod - t) % mod;\n        w = 1ll * w * wn % mod;\n      }\n    }\n  }\n  if (on == -1) {\n    for (int i = 1; i < len / 2; i++) swap(a[i], a[len - i]);\n    int inv = pow_mod(len, mod - 2);\n    for (int i = 0; i < len; i++) a[i] = (ll)a[i] * inv % mod;\n  }\n}\nvi mul(vi a, vi b) {\n  int n = a.size() - 1;\n  int m = b.size() - 1;\n  int len = getlen(n + m);\n  vi c(len);\n  a.resize(len);\n  b.resize(len);\n  dft(a, 1), dft(b, 1);\n  for (int i = 0; i < len; ++i) {\n    c[i] = (ll)a[i] * b[i] % mod;\n  }\n  dft(c, -1);\n  return c;\n}\n}  // namespace Polynomial\nvi &operator+=(vi &a, const vi &b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < b.size(); ++i) {\n    add(a[i], b[i]);\n  }\n  return a;\n}\nvi operator+(const vi &a, const vi &b) {\n  vi c = a;\n  return c += b;\n}\nvi &operator-=(vi &a, const vi &b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < b.size(); ++i) {\n    sub(a[i], b[i]);\n  }\n  return a;\n}\nvi operator-(const vi &a, const vi &b) {\n  vi c = a;\n  return c -= b;\n}\nvi &operator*=(vi &a, const vi &b) {\n  if (min(a.size(), b.size()) < 128) {\n    vi c = a;\n    a.assign(a.size() + b.size() - 1, 0);\n    for (int i = 0; i < c.size(); ++i) {\n      for (int j = 0; j < b.size(); ++j) {\n        add(a[i + j], mul(c[i], b[j]));\n      }\n    }\n  } else {\n    a = Polynomial::mul(a, b);\n  }\n  return a;\n}\nvi operator*(const vi &a, const vi &b) {\n  vi c = a;\n  return c *= b;\n}\nvi shift(vi a) {\n  reverse(a.begin(), a.end());\n  a.pop_back();\n  reverse(a.begin(), a.end());\n  for (int i = 0; i < a.size(); i += 1) {\n    a[i] = mul(a[i], mod + 1 >> 1);\n  }\n  return a;\n}\nconst int maxn = 1e5 + 233;\nvi poly[maxn << 2][2][2];\nint a[maxn];\nint b[maxn];\nint n;\nint fac[maxn];\nint inv[maxn];\nvoid solve(int o, int l, int r) {\n  if (l == r) {\n    poly[o][0][0] = vi{0, b[l] == 1 ? 1 : 2};\n    poly[o][0][1] = poly[o][1][0] = poly[o][1][1] = vi{0, 2};\n    return;\n  }\n  int mid = l + r >> 1;\n  solve(o << 1, l, mid);\n  solve(o << 1 | 1, mid + 1, r);\n  for (int i = 0; i < 2; i += 1) {\n    for (int j = 0; j < 2; j += 1) {\n      poly[o][i][j] += poly[o << 1][i][0] * poly[o << 1 | 1][0][j];\n      poly[o][i][j] += shift(poly[o << 1][i][1] * poly[o << 1 | 1][1][j]);\n    }\n  }\n}\nint choose(int x, int y) {\n  if (x < y || x < 0 || y < 0) return 0;\n  return 1ll * fac[x] * inv[y] % mod * inv[x - y] % mod;\n}\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n  fac[0] = inv[0] = 1;\n  cin >> n;\n  for (int i = 1; i <= n; i += 1) {\n    cin >> a[i];\n    fac[i] = 1ll * fac[i - 1] * i % mod;\n    inv[i] = pow_mod(fac[i], mod - 2);\n  }\n  int cnt = 0;\n  int res = 1;\n  for (int i = 1; i <= n; i += 1) {\n    int cur = a[i];\n    b[++cnt] = cur;\n    for (int j = 1; j <= cur; j += 1) {\n      if (a[j + i - 1] != a[i]) res = 0;\n    }\n    i += cur - 1;\n  }\n  if (res == 0) {\n    cout << \"0\\n\";\n    return 0;\n  }\n  res = 0;\n  solve(1, 1, cnt);\n  auto &c = poly[1][0][0];\n  for (int i = 1; i <= cnt; i += 1) {\n    c[i] = mul(c[i], fac[i]);\n    if (cnt - i & 1)\n      sub(res, c[i] % mod);\n    else\n      add(res, c[i]);\n  }\n  cout << res << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 131072, P = 998244353, inv2 = (P + 1) / 2;\nint n, m, ans, a[maxn], b[maxn], fact[maxn], finv[maxn];\nint lim, l, r[maxn], w[maxn];\nvector<int> V;\nvector<int> f[maxn << 2][2][2];\nint qp(int x, int y) {\n  int z = 1;\n  for (; y; y >>= 1, x = 1LL * x * x % P) {\n    if (y & 1) z = 1LL * z * x % P;\n  }\n  return z;\n}\nvoid init() {\n  for (int i = 0; i < lim; i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << (l - 1));\n  w[lim >> 1] = 1;\n  int t = qp(3, (P - 1) / lim);\n  for (int i = (lim >> 1) + 1; i < lim; i++) w[i] = 1LL * t * w[i - 1] % P;\n  for (int i = (lim >> 1) - 1; i > 0; i--) w[i] = w[i << 1];\n}\nvoid DFT(int *a, int type) {\n  static unsigned long long c[maxn];\n  copy(a, a + lim, c);\n  for (int i = 0; i < lim; i++)\n    if (i < r[i]) swap(c[i], c[r[i]]);\n  for (int i = 1; i < lim; i <<= 1) {\n    for (int j = 0; j < lim; j += i << 1) {\n      for (int k = 0; k < i; k++) {\n        unsigned long long t = c[i + j + k] * w[i + k] % P;\n        c[i + j + k] = c[j + k] + P - t, c[j + k] += t;\n      }\n    }\n  }\n  if (!~type) {\n    reverse(c + 1, c + lim);\n    for (int i = 0, t = qp(lim, P - 2); i < lim; i++) c[i] = c[i] % P * t % P;\n  }\n  for (int i = 0; i < lim; i++) a[i] = c[i] % P;\n}\nvector<int> operator*(vector<int> A, vector<int> B) {\n  int len = A.size() + B.size() - 1;\n  for (lim = 1, l = 0; lim < len; lim <<= 1) l++;\n  A.resize(lim), B.resize(lim);\n  init(), DFT(A.data(), 1), DFT(B.data(), 1);\n  for (int i = 0; i < lim; i++) A[i] = 1LL * A[i] * B[i] % P;\n  DFT(A.data(), -1), A.resize(len);\n  return A;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = fact[0] = finv[0] = 1; i <= n; i++) {\n    scanf(\"%d\", &a[i]);\n    fact[i] = 1LL * i * fact[i - 1] % P;\n    finv[i] = qp(fact[i], P - 2);\n  }\n  for (int i = 1; i <= n; i += a[i]) {\n    b[++m] = a[i];\n    for (int j = i; j < i + a[i]; j++) {\n      if (a[i] ^ a[j]) puts(\"0\"), exit(0);\n    }\n  }\n  function<void(int, int, int)> solve = [&](int k, int l, int r) {\n    if (l == r) {\n      f[k][0][0] = {0, b[l] == 1 ? inv2 : 1};\n      f[k][0][1] = f[k][1][0] = f[k][1][1] = {0, 1};\n      return;\n    }\n    int mid = (l + r) / 2, ls = k << 1, rs = k << 1 | 1;\n    solve(ls, l, mid), solve(rs, mid + 1, r);\n    for (int p : {0, 1})\n      for (int q : {0, 1}) {\n        f[k][p][q].resize(r - l + 2);\n      }\n    for (int a : {0, 1})\n      for (int b : {0, 1})\n        for (int c : {0, 1}) {\n          vector<int> g = f[ls][a][b] * f[rs][b][c];\n          for (int i = b; i < g.size(); i++) (f[k][a][c][i - b] += g[i]) %= P;\n        }\n  };\n  solve(1, 1, m);\n  for (int i = 1; i <= m; i++) {\n    ans = (ans + 1LL * fact[i] * f[1][0][0][i] % P * qp(2, i) % P *\n                     ((m - i) & 1 ? P - 1 : 1)) %\n          P;\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar _c;\nbool _f;\ntemplate <class T>\ninline void IN(T &x) {\n  x = 0, _f = 0;\n  while (_c = getchar(), !isdigit(_c))\n    if (_c == '-') _f = 1;\n  while (isdigit(_c)) x = x * 10 + _c - '0', _c = getchar();\n  if (_f) x = -x;\n}\nconst int mod = 998244353;\ninline int mul(int x, int y) { return 1ll * x * y % mod; }\ninline void sub(int &x, int y) {\n  x -= y;\n  if (x < 0) x += mod;\n}\ninline void pls(int &x, int y) {\n  x += y;\n  if (x >= mod) x -= mod;\n}\ninline int dec(int x, int y) {\n  x -= y;\n  if (x < 0) x += mod;\n  return x;\n}\ninline int add(int x, int y) {\n  x += y;\n  if (x >= mod) x -= mod;\n  return x;\n}\ninline int modpow(int x, long long y, int res = 1) {\n  for (y = (y + mod - 1) % (mod - 1); y; y >>= 1, x = mul(x, x))\n    if (y & 1) res = mul(x, res);\n  return res;\n}\ntemplate <class T>\ninline void chkmin(T &x, T y) {\n  if (x > y) x = y;\n}\ntemplate <class T>\ninline void chkmax(T &x, T y) {\n  if (x < y) x = y;\n}\nconst int LogN = 20;\nint lim, tim, inv[LogN];\nvector<int> w[LogN], rev[LogN];\ninline void init_w(int len = 1 << 19) {\n  w[19].resize(len), w[19][0] = 1, w[19][1] = modpow(3, (mod - 1) >> 20);\n  for (int i = 2; i < len; ++i) w[19][i] = mul(w[19][i - 1], w[19][1]);\n  for (int i = 18; i >= 0; --i) {\n    w[i].resize(len >>= 1);\n    for (int j = 0; j < len; ++j) w[i][j] = w[i + 1][j << 1];\n  }\n}\ninline void init_r(int len) {\n  for (lim = 1, tim = 0; lim < len; lim <<= 1, ++tim)\n    ;\n  if (rev[tim].size()) return;\n  rev[tim].resize(lim), inv[tim] = modpow(lim, -1);\n  for (int i = 0; i < lim; ++i)\n    rev[tim][i] = (rev[tim][i >> 1] >> 1) | ((i & 1) << (tim - 1));\n}\ninline void ntt(vector<int> &f, short typ) {\n  static unsigned long long g[1 << 20 | 5];\n  for (int i = 0; i < lim; ++i) g[rev[tim][i]] = f[i];\n  for (int p = 1, s = 0, t = 0; p < lim; p <<= 1, ++t)\n    for (int k = 0; k < lim; k += p << 1)\n      for (int l = k; l < k + p; ++l)\n        s = mul(g[l + p] % mod, w[t][l - k]), g[l + p] = g[l] + mod - s,\n        g[l] += s;\n  for (int i = 0; i < lim; ++i) f[i] = g[i] % mod;\n  if (~typ) return;\n  std ::reverse(++f.begin(), f.end());\n  for (int i = 0; i < lim; ++i) f[i] = mul(f[i], inv[tim]);\n}\nconst int N = 1e5 + 5;\nconst int inv2 = modpow(2, -1);\nint n, m, a[N], b[N], fac[N];\nvector<int> f[N << 2][4], g[2][4];\nvoid solve(int x, int l, int r, bool typ) {\n  const int len = r - l + 2;\n  for (int o = 0; o < 4; ++o) f[x][o].resize(len);\n  if (l == r) return f[x][(b[l] == 1) * 3][1] = 1 + (b[l] != 1), void();\n  const int mid = l + r >> 1, lc = x << 1, rc = x << 1 | 1;\n  solve(lc, l, mid, 0), solve(rc, mid + 1, r, 1);\n  const int ln = mid - l + 2, rn = r - mid + 1;\n  for (int o0 = 0; o0 < 4; ++o0)\n    for (int o1 = 0; o1 < 4; ++o1) {\n      int t0 = (o0 & 1) | (o1 & 2), t2 = (o0 & 2) | (o1 & 1),\n          val = (t2 == 3) ? 2 : (t2 == 0 ? inv2 : 1);\n      pls(f[x][t0][2], mul(f[lc][o0][1], f[rc][o1][1]));\n      pls(f[x][0][1], mul(mul(f[lc][o0][1], f[rc][o1][1]), val));\n      for (int i = 3; i <= ln; ++i)\n        pls(f[x][t0][i], mul(f[lc][o0][i - 1], f[rc][o1][1]));\n      for (int j = 3; j <= rn; ++j)\n        pls(f[x][t0][j], mul(f[lc][o0][1], f[rc][o1][j - 1]));\n      for (int i = 2; i < ln; ++i)\n        pls(f[x][o0 & 1][i], mul(mul(f[lc][o0][i], f[rc][o1][1]), val));\n      for (int j = 2; j < rn; ++j)\n        pls(f[x][o1 & 2][j], mul(mul(f[lc][o0][1], f[rc][o1][j]), val));\n    }\n  init_r(len);\n  for (int t0 = 0; t0 < 4; ++t0) g[0][t0].resize(lim), g[1][t0].resize(lim);\n  for (int o0 = 0; o0 < 4; ++o0)\n    f[lc][o0][0] = f[lc][o0][1] = 0, f[lc][o0].resize(lim), ntt(f[lc][o0], 1);\n  for (int o1 = 0; o1 < 4; ++o1)\n    f[rc][o1][0] = f[rc][o1][1] = 0, f[rc][o1].resize(lim), ntt(f[rc][o1], 1);\n  for (int o0 = 0; o0 < 4; ++o0)\n    for (int o1 = 0; o1 < 4; ++o1) {\n      int t0 = (o0 & 1) | (o1 & 2), t2 = (o0 & 2) | (o1 & 1),\n          val = (t2 == 3) ? 2 : (t2 == 0 ? inv2 : 1);\n      for (int i = 0; i < lim; ++i)\n        g[0][t0][i] = mul(f[lc][o0][i], f[rc][o1][i]);\n      ntt(g[0][t0], -1);\n      for (int i = 4; i < len; ++i) pls(f[x][t0][i], g[0][t0][i]);\n      for (int i = 4; i < len; ++i) pls(f[x][t0][i - 1], mul(g[0][t0][i], val));\n    }\n}\nint main() {\n  init_w();\n  IN(n);\n  for (int i = 1; i <= n; ++i) IN(a[i]);\n  fac[0] = 1;\n  for (int i = 1; i <= n; ++i) fac[i] = mul(fac[i - 1], i);\n  bool flag = false;\n  for (int l = 1, r; l <= n; l = r + 1) {\n    if (r = l + a[l] - 1, r > n) {\n      flag = true;\n      break;\n    }\n    for (int i = l; i <= r; ++i)\n      if (a[i] != a[l]) flag = true;\n    b[++m] = a[l];\n  }\n  if (flag) return puts(\"0\"), 0;\n  solve(1, 1, m, 0);\n  int ans = 0;\n  for (int i = 1; i <= m; ++i)\n    for (int o = 0; o < 4; ++o)\n      pls(ans, mul(f[1][o][i], mul(fac[i], ((m - i) & 1) ? mod - 1 : 1)));\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
        }
    ]
}