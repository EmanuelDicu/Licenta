{
    "name": "808_E. Selling Souvenirs",
    "source": "CODEFORCES",
    "description": "After several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.\n\nThis morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.\n\nHelp Petya to determine maximum possible total cost.\n\nInput\n\nThe first line contains two integers n and m (1 \u2264 n \u2264 100000, 1 \u2264 m \u2264 300000) \u2014 the number of Petya's souvenirs and total weight that he can carry to the market.\n\nThen n lines follow. ith line contains two integers wi and ci (1 \u2264 wi \u2264 3, 1 \u2264 ci \u2264 109) \u2014 the weight and the cost of ith souvenir.\n\nOutput\n\nPrint one number \u2014 maximum possible total cost of souvenirs that Petya can carry to the market.\n\nExamples\n\nInput\n\n1 1\n2 1\n\n\nOutput\n\n0\n\n\nInput\n\n2 2\n1 3\n2 2\n\n\nOutput\n\n3\n\n\nInput\n\n4 3\n3 10\n2 7\n2 8\n1 1\n\n\nOutput\n\n10",
    "difficulty": "E",
    "tags": [
        "binary search",
        "dp",
        "greedy",
        "ternary search"
    ],
    "rating": 2300,
    "public_test": [
        {
            "input": "4 3\n3 10\n2 7\n2 8\n1 1\n",
            "output": "10\n"
        },
        {
            "input": "2 2\n1 3\n2 2\n",
            "output": "3\n"
        },
        {
            "input": "1 1\n2 1\n",
            "output": "0\n"
        }
    ],
    "generated_test": [
        {
            "input": "4 28\n2 2\n2 1\n3 10\n1 9\n",
            "output": "22\n"
        },
        {
            "input": "1 13\n2 8\n",
            "output": "8\n"
        },
        {
            "input": "4 2\n3 4\n3 9\n1 1\n1 4\n",
            "output": "5\n"
        },
        {
            "input": "3 4\n2 10\n2 10\n3 4\n",
            "output": "20\n"
        },
        {
            "input": "6 7\n2 5\n2 4\n3 9\n3 2\n3 1\n3 7\n",
            "output": "18\n"
        },
        {
            "input": "9 29\n3 8\n1 2\n2 5\n1 5\n3 3\n1 7\n1 7\n2 7\n2 9\n",
            "output": "53\n"
        },
        {
            "input": "20 25\n2 13\n3 2\n1 32\n1 43\n3 85\n1 14\n2 57\n1 54\n1 38\n2 96\n2 89\n3 64\n1 79\n2 73\n1 73\n2 34\n1 52\n1 79\n1 42\n3 34\n",
            "output": "990\n"
        },
        {
            "input": "8 6\n1 9\n1 5\n1 3\n1 10\n3 8\n1 6\n1 5\n1 2\n",
            "output": "38\n"
        },
        {
            "input": "9 10\n3 6\n3 1\n2 4\n2 3\n3 6\n3 1\n1 8\n2 4\n3 3\n",
            "output": "25\n"
        },
        {
            "input": "8 21\n2 6\n3 3\n3 7\n3 8\n3 8\n3 7\n2 6\n3 9\n",
            "output": "51\n"
        },
        {
            "input": "5 9\n1 8\n3 7\n2 6\n1 4\n2 7\n",
            "output": "32\n"
        },
        {
            "input": "61 120\n3 5\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 2\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n2 3\n",
            "output": "179\n"
        },
        {
            "input": "10 12\n3 7\n3 6\n3 8\n3 4\n1 9\n2 5\n2 1\n2 5\n2 10\n2 9\n",
            "output": "46\n"
        },
        {
            "input": "5 5\n3 1\n2 6\n3 2\n1 1\n1 6\n",
            "output": "13\n"
        },
        {
            "input": "13 23\n3 17\n1 83\n1 81\n3 83\n3 59\n3 71\n2 61\n3 8\n3 64\n2 80\n3 47\n1 46\n1 82\n",
            "output": "757\n"
        },
        {
            "input": "10 6\n1 8\n1 10\n1 7\n2 9\n3 8\n1 8\n1 7\n1 4\n3 1\n3 6\n",
            "output": "44\n"
        },
        {
            "input": "10 5\n1 9\n1 8\n2 8\n3 4\n3 1\n2 2\n3 6\n1 1\n3 8\n2 2\n",
            "output": "26\n"
        },
        {
            "input": "1 2\n1 10\n",
            "output": "10\n"
        },
        {
            "input": "6 12\n1 7\n1 17\n2 8\n1 2\n2 9\n3 5\n",
            "output": "48\n"
        },
        {
            "input": "70 203\n1 105\n1 105\n1 105\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 491\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n",
            "output": "20501\n"
        },
        {
            "input": "4 3\n3 10\n2 7\n2 14\n1 1\n",
            "output": "15\n"
        },
        {
            "input": "1 2\n2 1\n",
            "output": "1\n"
        },
        {
            "input": "4 2\n3 4\n3 9\n1 1\n1 8\n",
            "output": "9\n"
        },
        {
            "input": "20 25\n2 13\n3 2\n1 32\n1 43\n3 85\n1 14\n2 57\n1 54\n1 38\n2 96\n2 89\n3 64\n1 79\n2 73\n1 73\n2 34\n1 52\n1 79\n1 44\n3 34\n",
            "output": "992\n"
        },
        {
            "input": "5 9\n1 8\n3 7\n2 6\n1 8\n2 7\n",
            "output": "36\n"
        },
        {
            "input": "10 12\n3 7\n3 6\n3 7\n3 4\n1 9\n2 5\n2 1\n2 5\n2 10\n2 9\n",
            "output": "45\n"
        },
        {
            "input": "13 23\n3 17\n1 83\n1 81\n3 83\n3 59\n3 71\n2 61\n3 8\n3 64\n2 80\n3 47\n1 46\n1 103\n",
            "output": "778\n"
        },
        {
            "input": "10 6\n1 3\n1 10\n1 7\n2 9\n3 8\n1 8\n1 7\n1 4\n3 1\n3 6\n",
            "output": "41\n"
        },
        {
            "input": "70 203\n1 105\n1 105\n1 105\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 404\n3 300\n3 300\n3 300\n3 491\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n3 300\n",
            "output": "20605\n"
        },
        {
            "input": "1 2\n3 1\n",
            "output": "0\n"
        },
        {
            "input": "4 2\n3 4\n3 9\n1 1\n1 3\n",
            "output": "4\n"
        },
        {
            "input": "20 25\n2 13\n3 2\n1 32\n1 43\n3 85\n1 14\n2 57\n1 54\n1 38\n2 96\n2 89\n3 64\n1 79\n2 73\n1 73\n2 47\n1 52\n1 79\n1 44\n3 34\n",
            "output": "1005\n"
        },
        {
            "input": "8 5\n1 9\n1 5\n1 3\n1 10\n3 8\n1 6\n1 5\n1 2\n",
            "output": "35\n"
        },
        {
            "input": "9 10\n3 6\n2 1\n2 7\n2 3\n3 6\n3 1\n1 8\n2 4\n3 4\n",
            "output": "28\n"
        },
        {
            "input": "8 21\n2 6\n3 3\n3 7\n3 16\n3 8\n3 7\n2 6\n3 6\n",
            "output": "56\n"
        },
        {
            "input": "13 23\n3 17\n1 83\n1 81\n3 83\n3 59\n3 71\n2 61\n3 8\n3 64\n2 13\n3 47\n1 46\n1 103\n",
            "output": "711\n"
        },
        {
            "input": "10 6\n1 3\n1 10\n1 7\n2 9\n3 8\n1 8\n1 7\n1 8\n3 1\n3 6\n",
            "output": "43\n"
        },
        {
            "input": "1 3\n1 19\n",
            "output": "19\n"
        },
        {
            "input": "2 1\n1 5\n3 11\n",
            "output": "5\n"
        },
        {
            "input": "6 6\n1 6\n1 4\n1 8\n3 2\n3 2\n2 2\n",
            "output": "20\n"
        },
        {
            "input": "2 3\n1 3\n2 2\n",
            "output": "5\n"
        },
        {
            "input": "1 25\n2 8\n",
            "output": "8\n"
        },
        {
            "input": "3 6\n2 10\n2 10\n3 4\n",
            "output": "20\n"
        },
        {
            "input": "6 7\n2 5\n2 4\n3 9\n3 2\n3 2\n3 7\n",
            "output": "18\n"
        },
        {
            "input": "8 11\n1 9\n1 5\n1 3\n1 10\n3 8\n1 6\n1 5\n1 2\n",
            "output": "48\n"
        },
        {
            "input": "9 10\n3 6\n2 1\n2 4\n2 3\n3 6\n3 1\n1 8\n2 4\n3 4\n",
            "output": "25\n"
        },
        {
            "input": "8 21\n2 6\n3 3\n3 7\n3 8\n3 8\n3 7\n2 6\n3 6\n",
            "output": "48\n"
        },
        {
            "input": "5 5\n3 1\n2 6\n3 2\n1 1\n2 6\n",
            "output": "13\n"
        },
        {
            "input": "1 3\n1 10\n",
            "output": "10\n"
        },
        {
            "input": "6 12\n1 7\n1 7\n2 8\n1 2\n2 9\n3 5\n",
            "output": "38\n"
        },
        {
            "input": "6 6\n2 6\n1 4\n1 8\n3 2\n3 2\n2 2\n",
            "output": "20\n"
        },
        {
            "input": "6 12\n1 1\n1 7\n2 8\n1 2\n2 9\n3 5\n",
            "output": "32\n"
        },
        {
            "input": "6 6\n2 6\n1 4\n1 14\n3 2\n3 2\n2 2\n",
            "output": "26\n"
        },
        {
            "input": "1 2\n3 2\n",
            "output": "0\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 1e5;\nlong long w[N];\nlong long c[N];\nstd::vector<std::pair<long long, int> > items;\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  std::cin.tie(0);\n  int n, m;\n  std::cin >> n >> m;\n  for (int i = 0; i < n; ++i) {\n    std::cin >> w[i] >> c[i];\n    items.push_back(std::make_pair(-6 * c[i] / w[i], i));\n  }\n  std::sort(items.begin(), items.end());\n  long long vals[10];\n  for (int i = 0; i < 10; ++i) {\n    vals[i] = 0;\n  }\n  int base = 0;\n  int high = 0;\n  for (int i = 0; i < (int)items.size(); ++i) {\n    int ind = items[i].second;\n    for (int j = 9 - w[ind]; j >= 0; --j) {\n      if (vals[j]) {\n        vals[j + w[ind]] = std::max(vals[j + w[ind]], vals[j] + c[ind]);\n      }\n    }\n    if (base == 0) {\n      vals[w[ind]] = std::max(vals[w[ind]], vals[0] + c[ind]);\n    }\n    high += w[ind];\n    if (high > 5) {\n      int dist = std::max(std::min(high - 5, m - base - 9), 0);\n      base += dist;\n      high -= dist;\n      for (int j = 0; j < dist; ++j) {\n        vals[j] = 0;\n      }\n      for (int j = dist; j < 10; ++j) {\n        long long tmp = vals[j];\n        vals[j] = 0;\n        vals[j - dist] = tmp;\n      }\n    }\n  }\n  long long max = 0;\n  for (int i = base; (i <= m) && (i < base + 10); ++i) {\n    if (vals[i - base] > max) {\n      max = vals[i - base];\n    }\n  }\n  std::cout << max << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nint tota = 0, totb = 0, totc = 0;\nlong long a[100005], b[100005], c[100005];\nlong long qa[100005], qb[100005], qc[100005];\nlong long ans = 0;\ninline bool cmp(long long x, long long y) { return x > y; }\ninline void make() {\n  sort(a + 1, a + tota + 1, cmp);\n  sort(b + 1, b + totb + 1, cmp);\n  sort(c + 1, c + totc + 1, cmp);\n  for (register int i = 1; i <= tota; ++i) qa[i] = qa[i - 1] + a[i];\n  for (register int i = 1; i <= totb; ++i) qb[i] = qb[i - 1] + b[i];\n  for (register int i = 1; i <= totc; ++i) qc[i] = qc[i - 1] + c[i];\n}\ninline long long val(int x, int y) {\n  return qc[x] + qb[y] + qa[min(tota, m - 3 * x - 2 * y)];\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (register int i = 1; i <= n; ++i) {\n    long long W, C;\n    scanf(\"%lld%lld\", &W, &C);\n    if (W == 1)\n      a[++tota] = C;\n    else if (W == 2)\n      b[++totb] = C;\n    else\n      c[++totc] = C;\n  }\n  make();\n  for (register int i = 0; i <= min(totc, m / 3); ++i) {\n    int l = 0, r = min(totb, (m - i * 3) >> 1);\n    while (l < r - 1) {\n      int lmid = (l + r) >> 1, rmid = (lmid + r) >> 1;\n      if (val(i, lmid) <= val(i, rmid))\n        l = lmid;\n      else\n        r = rmid;\n    }\n    ans = max(ans, max(val(i, l), val(i, r)));\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N, M;\nlong long dp[300005];\nvector<vector<long long> > cost(4);\nint one[300005], tow[300005];\nint T(int num) {\n  num -= one[num];\n  return num / 2;\n}\nint main() {\n  scanf(\"%d%d\", &N, &M);\n  long long s = 0, ww = 0;\n  for (int i = 0; i < N; i++) {\n    int w, c;\n    scanf(\"%d%d\", &w, &c);\n    cost[w].push_back(c);\n    s += c;\n    ww += w;\n  }\n  if (ww <= M) return cout << s, 0;\n  for (int i = 1; i < 4; i++)\n    sort(cost[i].begin(), cost[i].end(), greater<long long>());\n  dp[0] = 0;\n  int j = 1, k = 0;\n  for (int i = 2; i <= M; i++) one[i] = tow[i] = 1e9;\n  for (int i = 1; i <= M; i++) {\n    dp[i] = dp[i - 1];\n    if (i > 1) {\n      if (one[i - 1] < cost[1].size() && tow[i - 2] < cost[2].size()) {\n        if (dp[i - 1] + cost[1][one[i - 1]] > dp[i - 2] + cost[2][tow[i - 2]])\n          dp[i] = dp[i - 1] + cost[1][one[i - 1]], one[i] = one[i - 1] + 1,\n          tow[i] = tow[i - 1];\n        else\n          dp[i] = dp[i - 2] + cost[2][tow[i - 2]], one[i] = one[i - 2],\n          tow[i] = tow[i - 2] + 1;\n      } else if (one[i - 1] < cost[1].size())\n        dp[i] = dp[i - 1] + cost[1][one[i - 1]], one[i] = one[i - 1] + 1,\n        tow[i] = tow[i - 1];\n      else if (tow[i - 2] < cost[2].size())\n        dp[i] = dp[i - 2] + cost[2][tow[i - 2]], tow[i] = tow[i - 2] + 1,\n        one[i] = one[i - 2];\n    } else if (i == 1 && cost[1].size()) {\n      dp[i] = cost[1][0];\n      one[i] = 1;\n    }\n  }\n  long long best = 0, bestTake = 0;\n  for (int i = 1; i <= M; i++) {\n    if (dp[i] > bestTake) bestTake = dp[i], best = i;\n    dp[i] = max(dp[i], dp[i - 1]);\n  }\n  long long ans = dp[best];\n  for (int i = 1; i < cost[3].size(); i++) {\n    cost[3][i] += cost[3][i - 1];\n  }\n  for (int i = 0; i < cost[3].size(); i++) {\n    if (M - 3 * (i + 1) >= 0) ans = max(ans, cost[3][i] + dp[M - 3 * (i + 1)]);\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct ab {\n  int w, c;\n  double div;\n};\nbool operator<(ab a, ab b) { return a.div < b.div; }\nlong long int dp[300005];\nab a[100005];\nint main() {\n  int n, m;\n  cin >> n >> m;\n  int w, c;\n  double div[n];\n  for (int i = 0; i < n; i++) {\n    cin >> w >> c;\n    a[i].w = w;\n    a[i].c = c;\n    a[i].div = (double)c / (double)w;\n  }\n  sort(a, a + n);\n  int p = 0;\n  long long int k = 0;\n  dp[0] = 0;\n  for (int i = n - 1; i >= 0; i--) {\n    p = p + a[i].w;\n    if (p > m) {\n      p = m;\n    }\n    int l = max(a[i].w, p - 3);\n    for (int j = p; j >= l; j--) {\n      dp[j] = max(dp[j], dp[j - a[i].w] + a[i].c);\n      k = max(k, dp[j]);\n    }\n  }\n  cout << k << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dx[] = {0, 1, 0, -1, -1, -1, 1, 1};\nint dy[] = {1, 0, -1, 0, 1, -1, 1, -1};\nint n, m;\nvector<long long> w[4];\nlong long ans[300010];\nlong long c1[300010];\nlong long c2[300010];\nint main() {\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &m);\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    scanf(\"%d\", &x);\n    scanf(\"%d\", &y);\n    w[x].push_back(y);\n  }\n  for (int i = 1; i < 4; i++) {\n    sort(w[i].begin(), w[i].end());\n    reverse(w[i].begin(), w[i].end());\n  }\n  ans[0] = c1[0] = ans[1] = c1[1] = c2[1] = c2[0] = 0;\n  if (w[1].size() > 0) ans[1] = w[1][0], c1[1]++;\n  for (int i = 2; i <= m; i++) {\n    ans[i] = ans[i - 1];\n    c1[i] = c1[i - 1];\n    c2[i] = c2[i - 1];\n    if (c1[i] < w[1].size()) {\n      ans[i] += w[1][c1[i]];\n      c1[i]++;\n    }\n    long long r = ans[i - 2];\n    long long one = 0, o = 0;\n    if (c1[i - 2] < w[1].size()) one += w[1][c1[i - 2]], o++;\n    if (c1[i - 2] + 1 < w[1].size()) one += w[1][c1[i - 2] + 1], o++;\n    long long two = 0, t = 0;\n    if (c2[i - 2] < w[2].size()) two += w[2][c2[i - 2]], t++;\n    if (r + max(one, two) > ans[i]) {\n      ans[i] = r + max(one, two);\n      c1[i] = c1[i - 2];\n      c2[i] = c2[i - 2];\n      if (one > two)\n        c1[i] += o;\n      else\n        c2[i] += t;\n    }\n  }\n  long long res = ans[m];\n  for (int i = 0; i < w[3].size(); i++) {\n    if (i) w[3][i] += w[3][i - 1];\n    int rest = m - (i + 1) * 3;\n    if (rest < 0) break;\n    long long sum = 0;\n    sum = ans[rest];\n    res = max(res, w[3][i] + sum);\n  }\n  cout << res;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Node {\n  long long v, n1, n2;\n} dp[500000];\nlong long prefix3[500000], a1[500000], a2[500000], a3[500000], tot1, tot2, tot3,\n    ans, n, m;\ninline long long read() {\n  register long long s = 0, w = 1;\n  register char ch = getchar();\n  while (!isdigit(ch)) {\n    if (ch == '-') w = -1;\n    ch = getchar();\n  }\n  while (isdigit(ch)) {\n    s = (s << 3) + (s << 1) + (ch ^ 48);\n    ch = getchar();\n  }\n  return s * w;\n}\ninline bool cmp(long long x, long long y) { return x > y; }\nsigned main() {\n  n = read(), m = read();\n  for (register long long i = 1; i <= n; i++) {\n    long long x = read(), y = read();\n    if (x == 1) a1[++tot1] = y;\n    if (x == 2) a2[++tot2] = y;\n    if (x == 3) a3[++tot3] = y;\n  }\n  sort(a1 + 1, a1 + tot1 + 1, cmp);\n  sort(a2 + 1, a2 + tot2 + 1, cmp);\n  sort(a3 + 1, a3 + tot3 + 1, cmp);\n  for (register long long i = 1; i <= tot3; i++)\n    prefix3[i] = prefix3[i - 1] + a3[i];\n  for (register long long i = 1; i <= m; i++) {\n    dp[i] = dp[i - 1];\n    if (dp[i].v < dp[i - 1].v + a1[dp[i - 1].n1 + 1]) {\n      dp[i].v = dp[i - 1].v + a1[dp[i - 1].n1 + 1];\n      dp[i].n1 = dp[i - 1].n1 + 1, dp[i].n2 = dp[i - 1].n2;\n    }\n    if (i >= 2 && dp[i].v < dp[i - 2].v + a2[dp[i - 2].n2 + 1]) {\n      dp[i].v = dp[i - 2].v + a2[dp[i - 2].n2 + 1];\n      dp[i].n1 = dp[i - 2].n1, dp[i].n2 = dp[i - 2].n2 + 1;\n    }\n  }\n  for (register long long i = 0; i <= tot3 && i * 3 <= m; i++)\n    ans = max(ans, dp[m - i * 3].v + prefix3[i]);\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "def f():\n    n, m = map(int, input().split())\n    l = list(tuple(map(int, input().split())) for _ in range(n))\n    l.sort(key=lambda e: (0, 6, 3, 2)[e[0]] * e[1], reverse=True)\n    last, r = [0] * 4, 0\n    for i, (w, c) in enumerate(l):\n        if m < w:\n            break\n        m -= w\n        r += c\n        last[w] = c\n    else:\n        return r\n    if not m:\n        return r\n    res, tail = [r], (None, [], [], [])\n    for w, c in l[i:]:\n        tail[w].append(c)\n    for w in 1, 2, 3:\n        tail[w].append(0)\n    _, t1, t2, t3 = tail\n    if m == 1:\n        res.append(r + t1[0])\n        if last[1]:\n            res.append(r - last[1] + t2[0])\n        if last[2]:\n            res.append(r - last[2] + t3[0])\n        if last[3]:\n            r -= last[3]\n            res += (r + sum(t1[:4]), r + sum(t1[:2]) + t2[0], r + sum(t2[:2]))\n    else:  # m == 2\n        res += (r + sum(t1[:2]), r + t2[0])\n        if last[1]:\n            res.append(r - last[1] + t3[0])\n        if last[2]:\n            res.append(r - last[2] + t3[0] + t1[0])\n    return max(res)\n\n\ndef main():\n    print(f())\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nint dy[] = {1, -1, 0, 0, -1, 1, 1, -1};\nconst int mod = 1e9 + 7;\nint dcmp(long double x, long double y) {\n  return fabs(x - y) <= 1e-12 ? 0 : x < y ? -1 : 1;\n}\nvoid fast() {\n  std::ios_base::sync_with_stdio(0);\n  cin.tie(NULL);\n  cout.tie(NULL);\n}\nint n, m;\nvector<long long> pre[4];\nlong long dp[30 * 100 * 100 + 5];\nint cnt1[30 * 100 * 100 + 5], cnt2[30 * 100 * 100 + 5];\nint main() {\n  fast();\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    int x, y;\n    cin >> x >> y;\n    pre[x].push_back(y);\n  }\n  for (int i = 0; i < 4; i++) {\n    sort(pre[i].rbegin(), pre[i].rend());\n  }\n  if (pre[1].size()) {\n    dp[1] = pre[1][0];\n    cnt1[1] = 1;\n  }\n  for (int i = 2; i < 30 * 100 * 100 + 5; i++) {\n    int idxa = cnt1[i - 1], idxb = cnt2[i - 2];\n    if (idxa < pre[1].size()) {\n      if (dp[i] < dp[i - 1] + pre[1][idxa]) {\n        dp[i] = dp[i - 1] + pre[1][idxa];\n        cnt1[i] = 1 + idxa;\n        cnt2[i] = cnt2[i - 1];\n      }\n    }\n    if (idxb < pre[2].size()) {\n      if (dp[i] < dp[i - 2] + pre[2][idxb]) {\n        dp[i] = dp[i - 2] + pre[2][idxb];\n        cnt1[i] = cnt1[i - 2];\n        cnt2[i] = 1 + idxb;\n      }\n    }\n  }\n  for (int i = 1; i < 30 * 100 * 100 + 5; i++) dp[i] = max(dp[i - 1], dp[i]);\n  long long ans = dp[m], tot = 0, idxc = 0;\n  while (m >= 0) {\n    ans = max(ans, dp[m] + tot);\n    m -= 3;\n    if (idxc < pre[3].size()) tot += pre[3][idxc++];\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*; \nimport java.text.*;\n//Solution Credits: Taranpreet Singh\npublic class Main{\n    //SOLUTION BEGIN\n    void solve(int TC) throws Exception{\n        int n = ni(), m = ni();\n        long[][] a = new long[4][n+1];int[] sz = new int[4];\n        for(int i = 0; i< n;i++){\n            int w = ni();long c = nl();\n            a[w][++sz[w]] = c;\n        }\n        for(int i = 1; i<= 3; i++){\n            Arrays.sort(a[i]);\n            rev(a[i], 1, n);\n            for(int j = 1; j<= n; j++)a[i][j]+=a[i][j-1];\n        }\n        long ans = 0;\n        for(int i = 0; i<= sz[3] && i*3<=m; i++){\n            int rem = m-3*i;\n            int lo = 0, hi = rem/2;\n            while(lo+3<=hi){\n                int c1 = lo+(hi-lo)/3, c2 = hi- (hi-lo)/3;\n                long a1 = a[2][Math.min(n, c1)]+a[1][Math.min(rem-2*c1, n)];\n                long a2 = a[2][Math.min(n, c2)]+a[1][Math.min(rem-2*c2, n)];\n                if(a1>=a2)hi = c2;\n                else lo = c1;\n            }\n            for(int j = lo; j<= hi; j++)ans = Math.max(ans, a[3][i]+a[2][Math.min(n, j)]+a[1][Math.min(n,m-3*i-2*j)]);\n        }\n        pn(ans);\n    }\n   \n    void rev(long[] a, int l, int r){\n        for(int i = l, j = r; i< j; i++,j--){\n            long t = a[i];a[i] = a[j];a[j] = t;\n        }\n    }\n    //SOLUTION ENDS\n    long mod = (int)1e9+9, IINF = (long)1e16;\n    final int MAX = (int)1e5+1, INF = (int)1e9, root = 3;\n    DecimalFormat df = new DecimalFormat(\"0.00000000\");\n    double PI = 3.141592653589793238462643383279502884197169399375105820974944, eps = 1e-8;\n    static boolean multipleTC = false, memory = true;\n    FastReader in;PrintWriter out;\n    void run() throws Exception{\n        in = new FastReader();\n        out = new PrintWriter(System.out);\n        int T = (multipleTC)?ni():1;\n        //Solution Credits: Taranpreet Singh\n        for(int i = 1; i<= T; i++)solve(i);\n        out.flush();\n        out.close();\n    }\n    public static void main(String[] args) throws Exception{\n        if(memory)new Thread(null, new Runnable() {public void run(){try{new Main().run();}catch(Exception e){e.printStackTrace();}}}, \"1\", 1 << 28).start();\n        else new Main().run();\n    }\n    long gcd(long a, long b){return (b==0)?a:gcd(b,a%b);}\n    int gcd(int a, int b){return (b==0)?a:gcd(b,a%b);}\n    int bit(long n){return (n==0)?0:(1+bit(n&(n-1)));}\n    void p(Object o){out.print(o);}\n    void pn(Object o){out.println(o);}\n    void pni(Object o){out.println(o);out.flush();}\n    String n(){return in.next();}\n    String nln(){return in.nextLine();}\n    int ni(){return Integer.parseInt(in.next());}\n    long nl(){return Long.parseLong(in.next());}\n    double nd(){return Double.parseDouble(in.next());}\n\n    class FastReader{\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader(){\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public FastReader(String s) throws Exception{\n            br = new BufferedReader(new FileReader(s));\n        }\n\n        String next(){\n            while (st == null || !st.hasMoreElements()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                }catch (IOException  e){\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        String nextLine(){\n            String str = \"\";\n            try{    \n                str = br.readLine();\n            }catch (IOException e){\n                e.printStackTrace();\n            }   \n            return str;\n        }\n    }\n}   "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<long long> > vec(10);\nlong long w[123456], c[123456];\npair<long long, pair<int, int> > dp[312345];\nint main() {\n  std::ios::sync_with_stdio(false);\n  long long n, m, i, j, haha = 0;\n  cin >> n >> m;\n  for (i = 0; i < n; i++) {\n    cin >> w[i] >> c[i];\n    vec[w[i]].push_back(c[i]);\n  }\n  for (i = 0; i < 4; i++) {\n    sort(vec[i].begin(), vec[i].end());\n    reverse(vec[i].begin(), vec[i].end());\n  }\n  dp[0] = make_pair(0, make_pair(0, 0));\n  if (vec[1].empty()) {\n    dp[1] = make_pair(0, make_pair(0, 0));\n  } else {\n    dp[1] = make_pair(vec[1][0], make_pair(1, 0));\n  }\n  for (i = 2; i < m + 2; i++) {\n    dp[i] = dp[i - 1];\n    if (dp[i - 1].second.first < vec[1].size()) {\n      haha = dp[i - 1].second.first;\n      if (dp[i].first < dp[i - 1].first + vec[1][haha]) {\n        dp[i].first = dp[i - 1].first + vec[1][haha];\n        dp[i].second =\n            make_pair(dp[i - 1].second.first + 1, dp[i - 1].second.second);\n      }\n    }\n    if (dp[i - 2].second.second < vec[2].size()) {\n      haha = dp[i - 2].second.second;\n      if (dp[i].first < dp[i - 2].first + vec[2][haha]) {\n        dp[i].first = dp[i - 2].first + vec[2][haha];\n        dp[i].second =\n            make_pair(dp[i - 2].second.first, dp[i - 2].second.second + 1);\n      }\n    }\n  }\n  long long sumi = 0;\n  j = 0;\n  long long maxi = 0;\n  while (m >= 0) {\n    maxi = max(dp[m].first + sumi, maxi);\n    if (j == vec[3].size()) break;\n    sumi += vec[3][j];\n    j++;\n    m -= 3;\n  }\n  cout << maxi << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 1e5 + 5;\nvector<int> v[4];\nint n, m;\nlong long roll(const vector<int> &v2, const vector<int> &v3, int capacity) {\n  vector<long long> pref(v2.size());\n  for (int i = int(0); i < int(v2.size()); i++) {\n    pref[i] = i == 0 ? v2[i] : pref[i - 1] + v2[i];\n  }\n  long long best = 0;\n  long long total = 0;\n  for (int i = 0; i < (int)v3.size() + 1 && i * 3 <= capacity; i++) {\n    int has = min((int)v2.size(), (capacity - i * 3) / 2);\n    best = max(best, (has > 0 ? pref[has - 1] : 0) + total);\n    if (i < (int)v3.size()) {\n      total += v3[i];\n    }\n  }\n  return best;\n}\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  for (int i = int(1); i < int(n + 1); i++) {\n    int w, c;\n    scanf(\"%d %d\", &w, &c);\n    v[w].push_back(c);\n  }\n  for (int i = int(1); i < int(4); i++) {\n    sort(v[i].begin(), v[i].end(), greater<int>());\n  }\n  vector<int> v2 = v[2];\n  for (int i = 0; i + 1 < (int)v[1].size(); i += 2) {\n    v2.push_back(v[1][i] + v[1][i + 1]);\n  }\n  sort(v2.begin(), v2.end(), greater<int>());\n  long long ans = roll(v2, v[3], m);\n  if (!v[1].empty()) {\n    v2 = v[2];\n    long long best_one = v[1][0];\n    for (int i = 1; i + 1 < (int)v[1].size(); i += 2) {\n      v2.push_back(v[1][i] + v[1][i + 1]);\n    }\n    sort(v2.begin(), v2.end(), greater<int>());\n    ans = max(ans, roll(v2, v[3], m - 1) + best_one);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid read(int &x) {\n  char ch = getchar();\n  x = 0;\n  for (; ch == ' ' || ch == '\\n'; ch = getchar())\n    ;\n  for (; ch != ' ' && ch != '\\n'; x = x * 10 + ch - '0', ch = getchar())\n    ;\n}\nvoid write(long long x) {\n  if (x > 9) write(x / 10);\n  putchar(x % 10 + '0');\n}\nint cnt[4];\nlong long dat[4][100004];\nbool cmp(int a, int b) { return a > b; }\nlong long dp[300004], stane[300004];\nint main() {\n  int n, m;\n  read(n), read(m);\n  for (int i = 1; i <= n; i++) {\n    int w, c;\n    read(w), read(c);\n    dat[w][++cnt[w]] = c;\n  }\n  for (int i = 1; i <= 3; i++) sort(dat[i] + 1, dat[i] + 1 + cnt[i], cmp);\n  for (int i = 1; i < 100004; i++)\n    for (int j = 1; j <= 3; j++) dat[j][i] = dat[j][i - 1] + dat[j][i];\n  for (int i = 1; i < 300004; i++) {\n    if (i < 100004)\n      stane[i] = dat[1][i];\n    else\n      stane[i] = dat[1][100003];\n  }\n  for (int i = 1; i < 300004; i++) {\n    if (i <= 1 || stane[i] >= dat[2][1] + stane[i - 2]) {\n      dp[i] = stane[i];\n      continue;\n    }\n    int l = 0, r = min(cnt[2], i / 2) + 1;\n    while (r > l + 1) {\n      int mid = (l + r) / 2;\n      if (dat[2][mid] + stane[i - 2 * mid] >\n          dat[2][mid - 1] + stane[i - 2 * (mid - 1)])\n        l = mid;\n      else\n        r = mid;\n    }\n    dp[i] = dat[2][l] + stane[i - 2 * l];\n  }\n  long long ans = 0;\n  for (int i = 0; i * 3 <= m; i++) ans = max(ans, dp[m - i * 3] + dat[3][i]);\n  write(ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long dp[400005];\nlong long cost[5][400005];\nlong long cnt[3];\nlong long use[400005][3];\nbool cmp(long long a, long long b) { return a > b; }\nint main(int argc, char const *argv[]) {\n  int n, m;\n  cin >> n >> m;\n  int weight;\n  for (int i = 0; i < n; ++i) {\n    cin >> weight;\n    cin >> cost[weight][cnt[weight]++];\n  }\n  for (int i = 0; i <= 3; i++) {\n    sort(cost[i], cost[i] + cnt[i], cmp);\n  }\n  for (int i = 0; i <= m; ++i) {\n    for (int j = 1; j <= 3; j++) {\n      if (i - j >= 0) {\n        if (dp[i] < dp[i - j] + cost[j][use[i - j][j - 1]]) {\n          dp[i] = dp[i - j] + cost[j][use[i - j][j - 1]];\n          use[i][0] = use[i - j][0] + (j == 1);\n          use[i][1] = use[i - j][1] + (j == 2);\n          use[i][2] = use[i - j][2] + (j == 3);\n        }\n        if (j == 2) {\n          if (dp[i] <\n              dp[i - j] + cost[1][use[i - j][0]] + cost[1][use[i - j][0] + 1]) {\n            dp[i] =\n                dp[i - j] + cost[1][use[i - j][0]] + cost[1][use[i - j][0] + 1];\n            use[i][0] = use[i - j][0] + 2;\n            use[i][1] = use[i - j][1];\n            use[i][2] = use[i - j][2];\n          }\n        }\n        if (j == 3) {\n          if (dp[i] < dp[i - j] + cost[1][use[i - j][0]] +\n                          cost[1][use[i - j][0] + 1] +\n                          cost[1][use[i - j][0] + 2]) {\n            dp[i] = dp[i - j] + cost[1][use[i - j][0]] +\n                    cost[1][use[i - j][0] + 1] + cost[1][use[i - j][0] + 2];\n            use[i][0] = use[i - j][0] + 3;\n            use[i][1] = use[i - j][1];\n            use[i][2] = use[i - j][2];\n          }\n          if (dp[i] <\n              dp[i - j] + cost[1][use[i - j][0]] + cost[2][use[i - j][1]]) {\n            dp[i] = dp[i - j] + cost[1][use[i - j][0]] + cost[2][use[i - j][1]];\n            use[i][0] = use[i - j][0] + 1;\n            use[i][1] = use[i - j][1] + 1;\n            use[i][2] = use[i - j][2];\n          }\n        }\n      }\n    }\n  }\n  if (dp[m] == 24804061302924)\n    cout << 24804061310402 << endl;\n  else if (dp[m] == 42)\n    cout << 46 << endl;\n  else if (dp[m] == 2030182303827)\n    cout << 2030182334973 << endl;\n  else if (dp[m] == 2875487577750)\n    cout << 2875487613249 << endl;\n  else\n    cout << dp[m] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100005, M = 300005;\nint n, m, tot[4], w[4][N];\nlong long ans = 0;\nstruct S {\n  long long v, a, b, c;\n} f[M];\nvoid inline upd(S &x, S y) {\n  if (y.v > x.v) x = y;\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1, b, c; i <= n; i++) {\n    scanf(\"%d%d\", &b, &c);\n    w[b][++tot[b]] = c;\n  }\n  for (int i = 1; i <= 3; i++) {\n    sort(w[i] + 1, w[i] + 1 + tot[i]);\n    reverse(w[i] + 1, w[i] + 1 + tot[i]);\n  }\n  for (int i = 0; i <= m; i++) {\n    long long v = f[i].v, a = f[i].a, b = f[i].b, c = f[i].c;\n    long long vA = w[1][a + 1], vB = w[2][b + 1], vC = w[3][c + 1];\n    ans = max(ans, v);\n    if (i + 1 <= m && a < tot[1]) upd(f[i + 1], (S){v + vA, a + 1, b, c});\n    if (i + 2 <= m && b < tot[2]) upd(f[i + 2], (S){v + vB, a, b + 1, c});\n    if (i + 3 <= m && c < tot[3]) upd(f[i + 3], (S){v + vC, a, b, c + 1});\n    if (i + 2 <= m && a && c < tot[3])\n      upd(f[i + 2], (S){v - w[1][a] + vC, a - 1, b, c + 1});\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long num[4][300010], sum[4][300010], cnt[5];\nstruct node {\n  long long val, v1, v2;\n} dp[300010];\nbool cmp(int a, int b) { return a > b; }\nint main() {\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    long long w, c;\n    cin >> w >> c;\n    num[w][++cnt[w]] = c;\n  }\n  for (int i = 1; i <= 3; i++) {\n    sort(num[i] + 1, num[i] + 1 + cnt[i], cmp);\n    for (int j = 1; j <= cnt[i]; j++) {\n      sum[i][j] = sum[i][j - 1] + num[i][j];\n    }\n  }\n  dp[0].v1 = 0;\n  dp[0].v2 = 0;\n  dp[0].val = 0;\n  for (int i = 1; i <= m; i++) {\n    dp[i] = dp[i - 1];\n    if (dp[i - 1].val + num[1][dp[i - 1].v1 + 1] > dp[i].val) {\n      dp[i].val = dp[i - 1].val + num[1][dp[i - 1].v1 + 1];\n      dp[i].v1 = dp[i - 1].v1 + 1;\n      dp[i].v2 = dp[i - 1].v2;\n    }\n    if (i >= 2 && dp[i - 2].val + num[2][dp[i - 2].v2 + 1] > dp[i].val) {\n      dp[i].val = dp[i - 2].val + num[2][dp[i - 2].v2 + 1];\n      dp[i].v1 = dp[i - 2].v1;\n      dp[i].v2 = dp[i - 2].v2 + 1;\n    }\n  }\n  long long ans = 0;\n  for (int i = 0; i <= cnt[3]; i++) {\n    if (m >= i * 3) ans = max(ans, dp[m - i * 3].val + sum[3][i]);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\nconst long long MOD = 1000000007;\nconst int INF = 1000000007;\nconst long long LINF = 1LL * INF * INF;\nconst int MAXN = 100047;\nconst double EPS = 1e-6;\nvector<int> C[4];\nint main() {\n  ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  int n, m, p1 = 0, p2 = 0;\n  cin >> n >> m;\n  for (int i = (0); i < (n); ++i) {\n    int w, c;\n    cin >> w >> c;\n    C[w].push_back(c);\n  }\n  for (int i = (1); i < (4); ++i) sort(C[i].begin(), C[i].end());\n  reverse(C[3].begin(), C[3].end());\n  long long ans = 0, cur = 0;\n  int w = (int)((C[1]).size()) + 2 * (int)((C[2]).size());\n  for (int c : C[1]) cur += c;\n  for (int c : C[2]) cur += c;\n  for (int i = (0); i < ((int)((C[3]).size()) + 1); ++i) {\n    while (w > m) {\n      if (p2 == (int)((C[2]).size()) ||\n          p1 < (int)((C[1]).size()) &&\n              C[1][p1] < C[2][p2] - (p1 ? C[1][p1 - 1] : 0)) {\n        cur -= C[1][p1++];\n        w--;\n      } else {\n        cur -= C[2][p2++];\n        w -= 2;\n        if (p1) {\n          cur += C[1][--p1];\n          w++;\n        }\n      }\n    }\n    ans = max(ans, cur);\n    if (i < (int)((C[3]).size())) cur += C[3][i];\n    m -= 3;\n    if (m < 0) break;\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "#Bhargey Mehta (Sophomore)\n#DA-IICT, Gandhinagar\nimport sys, math, queue, bisect\n#sys.stdin = open(\"input.txt\", \"r\")\nMOD = 10**9+7\nsys.setrecursionlimit(1000000)\n\nn, m = map(int, input().split())\nc1, c2, c3 = [0], [0], [0]\nfor _ in range(n):\n    x, y = map(int, input().split())\n    if x == 3:\n        c3.append(y)\n    elif x == 2:\n        c2.append(y)\n    else:\n        c1.append(y)\nc1.sort(reverse=True)\nc2.sort(reverse=True)\nc3.sort(reverse=True)\n\ndp = [None for i in range(m+1)]\ndp[0] = (0, 0, 0)\ndp[1] = (c1[0], 1, 0)\nfor i in range(2, m+1):\n    if dp[i-1][1] == len(c1):\n        x1 = (dp[i-1][0], dp[i-1][1], dp[i-1][2])\n    else:\n        x1 = (dp[i-1][0]+c1[dp[i-1][1]], dp[i-1][1]+1, dp[i-1][2])\n    if dp[i-2][2] == len(c2):\n        x2 = (dp[i-2][0], dp[i-2][1], dp[i-2][2])\n    else:\n        x2 = (dp[i-2][0]+c2[dp[i-2][2]], dp[i-2][1], dp[i-2][2]+1)\n    if x1[0] > x2[0]:\n        dp[i] = x1\n    else:\n        dp[i] = x2\n\nans = 0\ncost3 = 0\nfor i in range(len(c3)):\n    cost3 += c3[i-1]\n    cap = m - 3*i\n    if cap < 0: break\n    ans = max(ans, cost3+dp[cap][0])\nprint(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> v[4];\nlong long _1[300300], sum[4][100100], total;\nint main() {\n  ios_base::sync_with_stdio(0);\n  long long n, m;\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    cin >> x >> y;\n    total += x;\n    v[x].push_back(y);\n  }\n  for (int i = 1; i <= 3; i++) sort(v[i].rbegin(), v[i].rend());\n  memset(_1, -1, sizeof _1);\n  _1[0] = 0;\n  if ((int)v[1].size() > 0) _1[1] = 1;\n  if ((int)v[1].size() > 1) _1[2] = 2;\n  for (int j = 1; j <= 3; j++)\n    for (int i = 1; i <= (int)v[j].size(); i++) {\n      sum[j][i] = sum[j][i - 1] + v[j][i - 1];\n    }\n  for (int i = 3; i <= m; i++)\n    if (_1[i - 3] != -1) {\n      if (_1[i - 3] + 3 <= (int)v[1].size()) _1[i] = _1[i - 3] + 3;\n      int _3 = (i - _1[i - 3]) / 3;\n      if (v[3].size() >= _3 && (v[1].size() < _1[i - 3] + 3 ||\n                                sum[1][_1[i - 3] + 3] - sum[1][_1[i - 3]] <\n                                    sum[3][_3] - sum[3][_3 - 1]))\n        _1[i] = _1[i - 3];\n    }\n  m = min(m, total);\n  long long ans = 0;\n  for (int i = 0; i <= (int)v[2].size(); i++)\n    if (2 * i <= m && _1[m - 2 * i] != -1)\n      ans = max(sum[2][i] + sum[1][_1[m - 2 * i]] +\n                    sum[3][(m - 2 * i - _1[m - 2 * i]) / 3],\n                ans);\n  m--;\n  for (int i = 0; i <= (int)v[2].size(); i++)\n    if (2 * i <= m && _1[m - 2 * i] != -1)\n      ans = max(sum[2][i] + sum[1][_1[m - 2 * i]] +\n                    sum[3][(m - 2 * i - _1[m - 2 * i]) / 3],\n                ans);\n  m--;\n  for (int i = 0; i <= (int)v[2].size(); i++)\n    if (2 * i <= m && _1[m - 2 * i] != -1)\n      ans = max(sum[2][i] + sum[1][_1[m - 2 * i]] +\n                    sum[3][(m - 2 * i - _1[m - 2 * i]) / 3],\n                ans);\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<pair<long long, long long>> p;\n  for (int i = 0; i < n; ++i) {\n    int w, c;\n    cin >> w >> c;\n    p.emplace_back(w, c);\n  }\n  sort(p.begin(), p.end(),\n       [](const pair<long long, long long> &p1,\n          const pair<long long, long long> &p2) {\n         return p1.first * p2.second < p1.second * p2.first;\n       });\n  vector<long long> dp(m + 1, 0);\n  int z = 0;\n  for (int i = 0; i < p.size(); ++i) {\n    int w = p[i].first;\n    int c = p[i].second;\n    z = min(z + w, m);\n    int y = max(z - 3, w);\n    for (int j = z; j >= y; --j) dp[j] = max(dp[j], dp[j - w] + c);\n  }\n  cout << *max_element(dp.begin(), dp.end()) << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long NR = 3e5 + 10, oo = 1e18 + 10, MOD = 1e9 + 7;\nconst long double pi = 2 * acos(0.0);\nvector<long long> v[5];\nlong long n, m, best, sum, sp_max[NR];\nstruct din {\n  long long cost, cnt1, cnt2;\n  din() {\n    cost = 0;\n    cnt2 = 0;\n    cnt1 = 0;\n  }\n} sol[NR];\nbool cmp(long long i, long long j) { return i > j; }\nsigned main() {\n  long long x, y, i;\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  for (i = 1; i <= n; ++i) {\n    cin >> x >> y;\n    v[x].push_back(y);\n  }\n  sort(v[1].begin(), v[1].end(), cmp);\n  sort(v[2].begin(), v[2].end(), cmp);\n  sort(v[3].begin(), v[3].end(), cmp);\n  for (i = 0; i <= m; ++i) {\n    if (sol[i].cnt1 < v[1].size() &&\n        sol[i + 1].cost < sol[i].cost + v[1][sol[i].cnt1]) {\n      sol[i + 1].cost = sol[i].cost + v[1][sol[i].cnt1];\n      sol[i + 1].cnt1 = sol[i].cnt1 + 1;\n      sol[i + 1].cnt2 = sol[i].cnt2;\n    }\n    if (sol[i].cnt2 < v[2].size() &&\n        sol[i + 2].cost < sol[i].cost + v[2][sol[i].cnt2]) {\n      sol[i + 2].cost = sol[i].cost + v[2][sol[i].cnt2];\n      sol[i + 2].cnt1 = sol[i].cnt1;\n      sol[i + 2].cnt2 = sol[i].cnt2 + 1;\n    }\n    best = max(best, sol[i].cost);\n  }\n  for (i = 1; i <= m; ++i) {\n    sp_max[i] = max(sp_max[i - 1], sol[i].cost);\n  }\n  for (i = 0; i < v[3].size(); ++i) {\n    sum += v[3][i];\n    if (m - 3 * (i + 1) >= 0) {\n      best = max(best, sp_max[m - 3 * (i + 1)] + sum);\n    }\n  }\n  cout << best << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long vs[5][100005];\nint vp[5];\nlong long sum1[100005], sum2[100005];\nint main() {\n  ios::sync_with_stdio(false);\n  int n, m;\n  cin >> n >> m;\n  sum1[0] = sum2[0] = 0;\n  for (int i = 1; i <= n; i++) {\n    int x;\n    long long y;\n    cin >> x >> y;\n    vs[x][++vp[x]] = y;\n  }\n  for (int i = 1; i <= 3; i++)\n    sort(vs[i] + 1, vs[i] + 1 + vp[i], greater<int>());\n  for (int i = 1; i <= vp[1]; i++) sum1[i] = sum1[i - 1] + vs[1][i];\n  for (int i = 1; i <= vp[2]; i++) sum2[i] = sum2[i - 1] + vs[2][i];\n  long long now = 0, ans = 0;\n  for (int i = 0; i <= vp[3] && m >= 0; ++i) {\n    int L = 0, R = std::min(vp[2], m / 2), M;\n    while (L < R) {\n      M = L + R >> 1;\n      int m2 = std::min(m - M * 2, vp[1]);\n      if (M * 2 + m2 < m - 1 || vs[2][M] > vs[1][m2] * 2)\n        L = M + 1;\n      else\n        R = M;\n    }\n    for (int x = std::max(0, M - 50); x <= std::min(vp[2], M + 50); ++x) {\n      if (x * 2 > m) continue;\n      int y = std::min(vp[1], m - x * 2);\n      long long a1 = now + sum1[y] + sum2[x];\n      if (a1 > ans) ans = a1;\n    }\n    m -= 3;\n    now += vs[3][i + 1];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint c[100010], w[100010];\nlong long p[100010], rk[100010], dp[300010];\nbool cmp(int i, int j) { return p[i] < p[j]; }\nint main() {\n  memset(dp, 0, sizeof(dp));\n  memset(c, 0, sizeof(c));\n  memset(w, 0, sizeof(w));\n  memset(rk, 0, sizeof(rk));\n  memset(p, 0, sizeof(p));\n  int n = 0, m = 0;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d%d\", &w[i], &c[i]);\n    p[i] = (6LL * (long long)c[i]) / (long long)w[i];\n    rk[i] = i;\n  }\n  sort(rk + 1, rk + n + 1, cmp);\n  long long total = 0;\n  for (int i = n; i >= 1; --i) {\n    int tmpW = w[rk[i]], tmpC = c[rk[i]];\n    total += tmpW;\n    for (int j = total; j >= max((long long)tmpW, total - 30); --j) {\n      dp[j] = max(dp[j], dp[j - tmpW] + (long long)tmpC);\n    }\n  }\n  for (int i = 1; i <= m; ++i) {\n    dp[i] = max(dp[i], dp[i - 1]);\n  }\n  printf(\"%I64d\", dp[m]);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\n@SuppressWarnings(\"unchecked\")\npublic class P808E {\n\n  final static int DIST = 30;\n\n  public void run() throws Exception {\n    int n = nextInt(), m = nextInt();\n    int [][] wca = new int [n][2];\n    int l1 = 0, l2 = 0, l3 = 0;\n    for (int i = 0; i < n; i++) {\n      wca[i] = readInt(2);\n      if (wca[i][0] == 1) {\n        l1++;\n      } else if (wca[i][0] == 2) {\n        l2++;\n      } else {\n        l3++;\n      }\n    }\n\n    Arrays.sort(wca, new Comparator<int []>() {\n      public int compare(int [] a, int [] b) {\n        return (b[1] - a[1]);\n      }\n    });\n\n    int [] c1 = new int [l1], c2 = new int [l2], c3 = new int [l3];\n    int i1 = 0, i2 = 0, i3 = 0;\n    for (int [] wc : wca) {\n      if (wc[0] == 1) {\n        c1[i1++] = wc[1];\n      } else if (wc[0] == 2) {\n        c2[i2++] = wc[1];\n      } else {\n        c3[i3++] = wc[1];\n      }\n    }\n\n    int mm = m;\n    i1 = i2 = i3 = 0;\n    while (true) {\n      int k1 = ((i1 < l1) && (mm >= 1)) ? c1[i1] : 0;\n      int k2 = ((i2 < l2) && (mm >= 2)) ? c2[i2] : 0;\n      int k3 = ((i3 < l3) && (mm >= 3)) ? c3[i3] : 0;\n\n      if ((k1 | k2 | k3) == 0) {\n        break;\n      } else if ((2.0 * k1 >= k2) && (3.0 * k1 >= k3)) {\n        i1++;\n        mm -= 1;\n      } else if ((k2 >= 2.0 * k1) && (3.0 * k2 >= 2.0 * k3)) {\n        i2++;\n        mm -= 2;\n      } else {\n        i3++;\n        mm -= 3;\n      }\n    }\n\n    long [] s1 = new long [l1 + 1], s2 = new long [l2 + 1], s3 = new long [l3 + 1];\n    for (int i = 0; i < l1; s1[i + 1] = c1[i] + s1[i], i++);\n    for (int i = 0; i < l2; s2[i + 1] = c2[i] + s2[i], i++);\n    for (int i = 0; i < l3; s3[i + 1] = c3[i] + s3[i], i++);\n\n    long s = 0;\n    for (int d1 = -DIST; d1 <= DIST; d1++) {\n      for (int d2 = -DIST; d2 <= DIST; d2++) {\n        for (int d3 = -DIST; d3 <= DIST; d3++) {\n          int j1 = i1 + d1, j2 = i2 + d2, j3 = i3 + d3;\n\n          if ((j1 >= 0) && (j2 >= 0) && (j3 >= 0) &&\n              (j1 <= l1) && (j2 <= l2) && (j3 <= l3) &&\n              ((j1 + 2 * j2 + 3 * j3) <= m)) {\n            s = Math.max(s, s1[j1] + s2[j2] + s3[j3]);\n          }\n        }\n      }\n    }\n\n    println(s);\n  }\n\n  public static void main(String... args) throws Exception {\n    br = new BufferedReader(new InputStreamReader(System.in));\n    pw = new PrintWriter(new BufferedOutputStream(System.out));\n    new P808E().run();\n    br.close();\n    pw.close();\n    System.err.println(\"\\n[Time : \" + (System.currentTimeMillis() - startTime) + \" ms]\");\n  }\n\n  static long startTime = System.currentTimeMillis();\n  static BufferedReader br;\n  static PrintWriter pw;\n  StringTokenizer stok;\n\n  String nextToken() throws IOException {\n    while (stok == null || !stok.hasMoreTokens()) {\n      String s = br.readLine();\n      if (s == null) { return null; }\n      stok = new StringTokenizer(s);\n    }\n    return stok.nextToken();\n  }\n\n  void print(byte b) { print(\"\" + b); }\n  void print(int i) { print(\"\" + i); }\n  void print(long l) { print(\"\" + l); }\n  void print(double d) { print(\"\" + d); }\n  void print(char c) { print(\"\" + c); }\n  void print(Object o) {\n    if (o instanceof int[]) { print(Arrays.toString((int [])o));\n    } else if (o instanceof long[]) { print(Arrays.toString((long [])o));\n    } else if (o instanceof char[]) { print(Arrays.toString((char [])o));\n    } else if (o instanceof byte[]) { print(Arrays.toString((byte [])o));\n    } else if (o instanceof short[]) { print(Arrays.toString((short [])o));\n    } else if (o instanceof boolean[]) { print(Arrays.toString((boolean [])o));\n    } else if (o instanceof float[]) { print(Arrays.toString((float [])o));\n    } else if (o instanceof double[]) { print(Arrays.toString((double [])o));\n    } else if (o instanceof Object[]) { print(Arrays.toString((Object [])o));\n    } else { print(\"\" + o); }\n  }\n  void print(String s) { pw.print(s); }\n  void println() { println(\"\"); }\n  void println(byte b) { println(\"\" + b); }\n  void println(int i) { println(\"\" + i); }\n  void println(long l) { println(\"\" + l); }\n  void println(double d) { println(\"\" + d); }\n  void println(char c) { println(\"\" + c); }\n  void println(Object o) { print(o); println(); }\n  void println(String s) { pw.println(s); }\n  int nextInt() throws IOException { return Integer.parseInt(nextToken()); }\n  long nextLong() throws IOException { return Long.parseLong(nextToken()); }\n  double nextDouble() throws IOException { return Double.parseDouble(nextToken()); }\n  char nextChar() throws IOException { return (char) (br.read()); }\n  String next() throws IOException { return nextToken(); }\n  String nextLine() throws IOException { return br.readLine(); }\n  int [] readInt(int size) throws IOException {\n    int [] array = new int [size];\n    for (int i = 0; i < size; i++) { array[i] = nextInt(); }\n    return array;\n  }\n  long [] readLong(int size) throws IOException {\n    long [] array = new long [size];\n    for (int i = 0; i < size; i++) { array[i] = nextLong(); }\n    return array;\n  }\n  double [] readDouble(int size) throws IOException {\n    double [] array = new double [size];\n    for (int i = 0; i < size; i++) { array[i] = nextDouble(); }\n    return array;\n  }\n  String [] readLines(int size) throws IOException {\n    String [] array = new String [size];\n    for (int i = 0; i < size; i++) { array[i] = nextLine(); }\n    return array;\n  }\n\n  int gcd(int a, int b) {\n    return ((b > 0) ? gcd(b, a % b) : a);\n  }\n  long gcd(long a, long b) {\n    return ((b > 0) ? gcd(b, a % b) : a);\n  }\n}"
        },
        {
            "language": 4,
            "solution": "// Arup Guha\n// 6/7/2016\n// Solution to 2016 NAIPC Problem H: Jewel Thief\n\nimport java.util.*;\nimport java.io.*;\n\npublic class E {\n\n\tpublic static int n;\n\tpublic static int k;\n\tpublic static long[] dp;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader stdin = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer tok = new StringTokenizer(stdin.readLine());\n\t\tn = Integer.parseInt(tok.nextToken());\n\t\tk = Integer.parseInt(tok.nextToken());\n\t\tArrayList[] jewels = new ArrayList[301];\n\t\tfor (int i=0; i<jewels.length; i++)\n\t\t\tjewels[i] = new ArrayList<Long>();\n\t\tfor (int i=0; i<n; i++) {\n\t\t\ttok = new StringTokenizer(stdin.readLine());\n\t\t\tint size = Integer.parseInt(tok.nextToken());\n\t\t\tlong val = Long.parseLong(tok.nextToken());\n\t\t\tjewels[size].add(val);\n\t\t}\n\t\tfor (int i=0; i<jewels.length; i++) {\n\t\t\tCollections.sort(jewels[i]);\n\t\t\tCollections.reverse(jewels[i]);\n\t\t}\n\t\tfor (int i=0; i<jewels.length; i++)\n\t\t\tfor (int j=1; j<jewels[i].size(); j++)\n\t\t\t\tjewels[i].set(j, ((ArrayList<Long>)jewels[i]).get(j-1)+((ArrayList<Long>)jewels[i]).get(j));\n\t\tdp = new long[k+1];\n\t\tfor (int i=1; i<jewels.length; i++) {\n\t\t\tif (jewels[i].size() == 0) continue;\n\t\t\tfor (int j=k; j>=i&&j>k-i; j--) {\n\t\t\t\tint rep = jewels[i].size();\n\t\t\t\tArrayDeque<range> deq = new ArrayDeque<range>();\n\t\t\t\tfor (int z=j-i,cnt=0; cnt<rep&&z>=0; z-=i,cnt++) {\n\t\t\t\t\tint maxBeat = z+i;\n\t\t\t\t\twhile (deq.size() > 0) {\n\t\t\t\t\t\trange cur = deq.peekLast();\n\t\t\t\t\t\tmaxBeat = getBeat(z, cur.index, i, jewels[i]);\n\t\t\t\t\t\tmaxBeat = Math.min(maxBeat, j);\n\t\t\t\t\t\tif (maxBeat < cur.high) break;\n\t\t\t\t\t\telse deq.pollLast();\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif (deq.size() > 0) deq.peekLast().low = maxBeat+i;\n\t\t\t\t\tdeq.offerLast(new range(z, z+i, maxBeat));\n\t\t\t\t}\n\t\t\t\trange front = deq.peekFirst();\n\t\t\t\tint bestI = front.index;\n\t\t\t\tdp[j] = Math.max(dp[j], dp[bestI] + ((ArrayList<Long>)jewels[i]).get((j-bestI)/i-1));\n\t\t\t\tif (front.low == j) deq.pollFirst();\n\t\t\t\tfor (int z=j-i; z>=i; z-=i) {\n\t\t\t\t\tif (z - rep*i >= 0) {\n\t\t\t\t\t\tint maxBeat = z - rep*i + i;\n\t\t\t\t\t\twhile (deq.size() > 0) {\n\t\t\t\t\t\t\trange cur = deq.peekLast();\n\t\t\t\t\t\t\tmaxBeat = getBeat(z-rep*i, cur.index, i, (ArrayList<Long>)jewels[i]);\n\t\t\t\t\t\t\tmaxBeat = Math.min(maxBeat, j);\n\t\t\t\t\t\t\tif (maxBeat < cur.high) break;\n\t\t\t\t\t\t\telse deq.pollLast();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (deq.size() > 0) {\n\t\t\t\t\t\t\tdeq.peekLast().low = maxBeat+i;\n\t\t\t\t\t\t\tif (maxBeat+i > z) deq.pollFirst();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdeq.offerLast(new range(z-rep*i, z-rep*i+i, maxBeat));\n\t\t\t\t\t}\n\t\t\t\t\tfront = deq.peekFirst();\n\t\t\t\t\tbestI = front.index;\n\t\t\t\t\tdp[z] = Math.max(dp[z], dp[bestI] + ((ArrayList<Long>)jewels[i]).get((z-bestI)/i-1));\n\t\t\t\t\tif (front.low >= z) deq.pollFirst();\n\t\t\t\t} \n\t\t\t} \n\t\t} \n\t\tSystem.out.println(dp[k]);\n\t}\n\n\tpublic static int getBeat(int lowI, int curI, int skip, ArrayList<Long> vals) {\n\t\tint rep = vals.size();\n\t\tint extra = (curI-lowI)/skip;\n\t\tif (dp[lowI] + vals.get(extra) <= dp[curI]+vals.get(0)) return curI;\n\t\tif (dp[lowI] + vals.get(rep-1) > dp[curI] + vals.get(rep-1-extra)) return lowI+rep*skip;\n\t\tint low = extra+1, high = rep-1;\n\t\twhile (low < high) {\n\t\t\tint mid = (low+high)/2+1;\n\t\t\tif (dp[lowI] + vals.get(mid-1) > dp[curI] + vals.get(mid-1-extra))\n\t\t\t\tlow = mid;\n\t\t\telse\n\t\t\t\thigh = mid-1;\n\t\t}\n\t\treturn lowI + skip*low;\n\t}\n}\n\nclass range {\n\n\tpublic int index;\n\tpublic int low;\n\tpublic int high;\n\n\tpublic range(int i, int mylow, int myhigh) {\n\t\tindex = i;\n\t\tlow = mylow;\n\t\thigh = myhigh;\n\t}\n\n\tpublic String toString() {\n\t\treturn index+\": \"+low+\",\"+high+\" \";\n\t}\n}"
        },
        {
            "language": 1,
            "solution": "n, m = map(int, raw_input().split())\nC = [None, [], [], []]\nfor _ in xrange(n):\n    wi, ci = map(int, raw_input().split())\n    if wi == 1:\n        C[1].append(ci)\n    elif wi == 2:\n        C[2].append(ci)\n    elif wi == 3:\n        C[3].append(ci)\nfor i in xrange(1, 4):\n    C[i].sort()\n    C[i][:] = C[i][::-1]\n\ndp = [None for _ in xrange(m+1)]\ndp[0] = (0, 0, 0)\nfor w in xrange(m+1):\n    if dp[w] is None:\n        continue\n    cost, n1, n2 = dp[w]\n    if n1 < len(C[1]) and w+1 <= m:\n        if dp[w+1] is None:\n            dp[w+1] = (cost+C[1][n1], n1+1, n2)\n        elif cost+C[1][n1] > dp[w+1][0]:\n            dp[w+1] = (cost+C[1][n1], n1+1, n2)\n    if n2 < len(C[2]) and w+2 <= m:\n        if dp[w+2] is None:\n            dp[w+2] = (cost+C[2][n2], n1, n2+1)\n        elif cost+C[2][n2] > dp[w+2][0]:\n            dp[w+2] = (cost+C[2][n2], n1, n2+1)\nbest = [0]\nfor w in xrange(1, m+1):\n    if dp[w] is None:\n        best.append(best[-1])\n    else:\n        best.append(max(best[-1], dp[w][0]))\n\nma = best[m]\ncost = 0\nfor i, c3 in enumerate(C[3]):\n    cost += c3\n    if (i+1)*3 > m:\n        break\n    ma = max(ma, cost+best[m-(i+1)*3])\nprint ma\n"
        },
        {
            "language": 4,
            "solution": "//created by Whiplash99\nimport java.io.*;\nimport java.util.*;\npublic class E\n{\n    static class Tuple\n    {\n        long val;\n        int f, s, t;\n    }\n    public static void main(String[] args) throws IOException\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\n        int i,N;\n\n        ArrayList<Long> cost[]=new ArrayList[3];\n        for(i=0;i<3;i++) cost[i]=new ArrayList<>();\n\n        String s[]=br.readLine().trim().split(\" \");\n        N=Integer.parseInt(s[0]);\n        int W=Integer.parseInt(s[1]);\n\n        Tuple T[]=new Tuple[W+5];\n        for(i=0;i<W+5;i++) T[i]=new Tuple();\n\n        for(i=0;i<N;i++)\n        {\n            s=br.readLine().trim().split(\" \");\n            int w=Integer.parseInt(s[0]);\n            long c=Long.parseLong(s[1]);\n\n            cost[w-1].add(c);\n        }\n        for(i=0;i<3;i++) Collections.sort(cost[i],Collections.reverseOrder());\n\n        long ans=0;\n        long dp[]=new long[W+5];\n        long sumOf3[]=new long[N];\n\n        if(cost[2].size()>0) sumOf3[0]=cost[2].get(0);\n        for(i=1;i<cost[2].size();i++) sumOf3[i]=sumOf3[i-1]+cost[2].get(i);\n\n        for(i=0;i<=W;i++)\n        {\n            if(T[i].f<cost[0].size()&&T[i+1].val<T[i].val+cost[0].get(T[i].f))\n            {\n                T[i+1].val=T[i].val+cost[0].get(T[i].f);\n                T[i+1].f=T[i].f+1;\n                T[i+1].s=T[i].s;\n                T[i+1].t=T[i].t;\n            }\n            if(T[i].s<cost[1].size()&&T[i+2].val<T[i].val+cost[1].get(T[i].s))\n            {\n                T[i+2].val=T[i].val+cost[1].get(T[i].s);\n                T[i+2].f=T[i].f;\n                T[i+2].s=T[i].s+1;\n                T[i+2].t=T[i].t;\n            }\n\n            ans=Math.max(ans,T[i].val);\n            if(i>0) dp[i]=Math.max(dp[i-1],ans);\n        }\n\n        for(i=1;i*3<=W&&i<=cost[2].size();i++) ans = Math.max(ans, dp[W - i * 3] + sumOf3[i-1]);\n\n        System.out.println(ans);\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 3e5;\nvector<int> g[4];\nint n, m;\nlong long ans = 0;\nlong long sum[4][maxn + 50];\nbool cmp(const int &a, const int &b) { return a > b; }\nlong long check(int x, int m) {\n  long long s = sum[2][x];\n  m = m - 2 * x;\n  if (m > g[1].size())\n    return s + sum[1][g[1].size()];\n  else\n    return s + sum[1][m];\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    g[x].push_back(y);\n  }\n  for (int i = 1; i <= 3; ++i) sort(g[i].begin(), g[i].end(), cmp);\n  for (int i = 1; i <= 3; ++i) {\n    if (g[i].size() == 0) continue;\n    sum[i][1] = g[i][0];\n    for (int j = 1; j < g[i].size(); ++j) sum[i][j + 1] = sum[i][j] + g[i][j];\n  }\n  long long s = 0;\n  for (int i = 0; i <= min(m / 3, (int)g[3].size()); ++i) {\n    s = sum[3][i];\n    int bag = m - 3 * i;\n    int l = 0, r = min((int)g[2].size(), bag / 2);\n    while (l + 1 < r) {\n      int lmid = (2 * l + r) / 3;\n      int rmid = (2 * r + l) / 3;\n      if (check(lmid, bag) > check(rmid, bag))\n        r = rmid - 1;\n      else\n        l = lmid + 1;\n    }\n    for (int i = l; i <= r; ++i) ans = max(ans, s + check(i, bag));\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws FileNotFoundException {\n        ConsoleIO io = new ConsoleIO(new InputStreamReader(System.in), new PrintWriter(System.out));\n        //String test = \"A-large-practice\";\n        //ConsoleIO io = new ConsoleIO(new FileReader(\"D:\\\\Dropbox\\\\code\\\\practice\\\\jb\\\\src\\\\\" + test + \".in\"), new PrintWriter(new File(\"D:\\\\Dropbox\\\\code\\\\practice\\\\jb\\\\src\\\\\" + test + \"-out.txt\")));\n\n        new Main(io).solve();\n        io.close();\n    }\n\n    ConsoleIO io;\n    Main(ConsoleIO io) {\n        this.io = io;\n    }\n\n    List<List<Integer>> gr = new ArrayList<>();\n    long MOD = 1_000_000_007;\n\n    public void solve() {\n        int n = io.ri();\n        int m = io.ri();\n        Pair[] all = new Pair[n];\n        int sum_wei = 0;\n        long sum_cost = 0;\n        List<Integer> nums1 = new ArrayList<>();\n        List<Integer> nums2 = new ArrayList<>();\n        List<Integer> nums3 = new ArrayList<>();\n        //int[] idx = new int[4];\n        for(int i =0;i<n;i++) {\n            int w = io.ri();\n            int c = io.ri();\n            sum_wei+=w;\n            sum_cost+=c;\n            if(w==1) nums1.add(c);\n            else if(w==2) nums2.add(c);\n            else nums3.add(c);\n            all[i] = new Pair(w, c);\n        }\n\n        if(sum_wei<=m) {\n            io.writeLine(sum_cost + \"\");\n            return;\n        }\n\n        nums1.sort(Comparator.reverseOrder());\n        nums2.sort(Comparator.reverseOrder());\n        nums3.sort(Comparator.reverseOrder());\n\n        long[] pre1 = new long[nums1.size()+1];\n        long[] pre2 = new long[nums2.size()+1];\n        for(int i =0;i<nums1.size();i++)\n            pre1[i+1] = pre1[i] + nums1.get(i);\n        for(int i =0;i<nums2.size();i++)\n            pre2[i+1] = pre2[i] + nums2.get(i);\n\n        long s3 = 0;\n        int w3 = 0;\n        long res = 0;\n        for(int i = 0;i<=nums3.size();i++){\n\n            int have = m - w3;\n\n            int left = 0, right = Math.min(nums2.size(), have/2);\n            while(left+5<right) {\n                int th = (right - left) / 3;\n                int a = left + th;\n                int b = a + th;\n\n                int xa = have - 2 * a;\n                xa = Math.min(xa, pre1.length - 1);\n                int xb = have - 2 * b;\n                xb = Math.min(xb, pre1.length - 1);\n\n                long va = pre2[a] + pre1[xa];\n                long vb = pre2[b] + pre1[xb];\n                if (va > vb) right = b;\n                else left = a;\n            }\n\n            long max = 0;\n            for(int a = left;a<=right;a++) {\n                int x = have - 2 * a;\n                long va = pre2[a];\n                x = Math.min(x, pre1.length - 1);\n                x = Math.max(x, 0);\n                va += pre1[x];\n                max = Math.max(max, va);\n            }\n\n            res = Math.max(res, max+s3);\n\n            if(i<nums3.size()) {\n                s3 += nums3.get(i);\n                w3+=3;\n            }\n            if(w3>m)\n                break;\n        }\n\n        io.writeLine(res+\"\");\n\n    }\n}\n\nclass ConsoleIO {\n    BufferedReader br;\n    PrintWriter out;\n    public ConsoleIO(Reader reader, PrintWriter writer){br = new BufferedReader(reader);out = writer;}\n    public void flush(){this.out.flush();}\n    public void close(){this.out.close();}\n    public void writeLine(String s) {this.out.println(s);}\n    public void writeInt(int a) {this.out.print(a);this.out.print(' ');}\n    public void writeWord(String s){\n        this.out.print(s);\n    }\n    public void writeIntArray(int[] a, int k, String separator) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < k; i++) {\n            if (i > 0) sb.append(separator);\n            sb.append(a[i]);\n        }\n        this.writeLine(sb.toString());\n    }\n    public int read(char[] buf, int len){try {return br.read(buf,0,len);}catch (Exception ex){ return -1; }}\n    public String readLine() {try {return br.readLine();}catch (Exception ex){ return \"\";}}\n    public long[] readLongArray() {\n        String[]n=this.readLine().trim().split(\"\\\\s+\");long[]r=new long[n.length];\n        for(int i=0;i<n.length;i++)r[i]=Long.parseLong(n[i]);\n        return r;\n    }\n    public int[] readIntArray() {\n        String[]n=this.readLine().trim().split(\"\\\\s+\");int[]r=new int[n.length];\n        for(int i=0;i<n.length;i++)r[i]=Integer.parseInt(n[i]);\n        return r;\n    }\n    public int[] readIntArray(int n) {\n        int[] res = new int[n];\n        char[] all = this.readLine().toCharArray();\n        int cur = 0;boolean have = false;\n        int k = 0;\n        boolean neg = false;\n        for(int i = 0;i<all.length;i++){\n            if(all[i]>='0' && all[i]<='9'){\n                cur = cur*10+all[i]-'0';\n                have = true;\n            }else if(all[i]=='-') {\n                neg = true;\n            }\n            else if(have){\n                res[k++] = neg?-cur:cur;\n                cur = 0;\n                have = false;\n                neg = false;\n            }\n        }\n        if(have)res[k++] = neg?-cur:cur;\n        return res;\n    }\n    public int ri() {\n        try {\n            int r = 0;\n            boolean start = false;\n            boolean neg = false;\n            while (true) {\n                int c = br.read();\n                if (c >= '0' && c <= '9') {\n                    r = r * 10 + c - '0';\n                    start = true;\n                } else if (!start && c == '-') {\n                    start = true;\n                    neg = true;\n                } else if (start || c == -1) return neg ? -r : r;\n            }\n        } catch (Exception ex) {\n            return -1;\n        }\n    }\n    public long readLong() {\n        try {\n            long r = 0;\n            boolean start = false;\n            boolean neg = false;\n            while (true) {\n                int c = br.read();\n                if (c >= '0' && c <= '9') {\n                    r = r * 10 + c - '0';\n                    start = true;\n                } else if (!start && c == '-') {\n                    start = true;\n                    neg = true;\n                } else if (start || c == -1) return neg ? -r : r;\n            }\n        } catch (Exception ex) {\n            return -1;\n        }\n    }\n    public String readWord() {\n        try {\n            boolean start = false;\n            StringBuilder sb = new StringBuilder();\n            while (true) {\n                int c = br.read();\n                if (c!= ' ' && c!= '\\r' && c!='\\n' && c!='\\t') {\n                    sb.append((char)c);\n                    start = true;\n                } else if (start || c == -1) return sb.toString();\n            }\n        } catch (Exception ex) {\n            return \"\";\n        }\n    }\n    public char readSymbol() {\n        try {\n            while (true) {\n                int c = br.read();\n                if (c != ' ' && c != '\\r' && c != '\\n' && c != '\\t') {\n                    return (char) c;\n                }\n            }\n        } catch (Exception ex) {\n            return 0;\n        }\n    }\n    //public char readChar(){try {return (char)br.read();}catch (Exception ex){ return 0; }}\n}\nclass Pair {\n    public Pair(int a, int b) {this.a = a;this.b = b;}\n    public int a;\n    public int b;\n}\nclass PairLL {\n    public PairLL(long a, long b) {this.a = a;this.b = b;}\n    public long a;\n    public long b;\n}\nclass Triple {\n    public Triple(int a, int b, int c) {this.a = a;this.b = b;this.c = c;}\n    public int a;\n    public int b;\n    public int c;\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1000000007;\ndouble PI = 4 * atan(1);\nvector<long long> k[4], cum[4];\nlong long ans = 0;\nint second;\nlong long get(int a, int b) { return cum[1][a] + cum[2][b]; }\nlong long solve(int w) {\n  int lo = max(0, (w - (int)k[1].size() + 1) / 2),\n      hi = min((int)k[2].size(), w / 2);\n  while (hi - lo > 2) {\n    int l1 = (2 * lo + hi) / 3, h1 = (lo + 2 * hi) / 3;\n    if (get(w - 2 * l1, l1) <= get(w - 2 * h1, h1))\n      lo = l1;\n    else\n      hi = h1;\n  }\n  if (lo > hi) return 0;\n  return max(max(get(w - 2 * lo, lo), get(w - 2 * hi, hi)),\n             get(w - 2 * ((lo + hi) / 2), (lo + hi) / 2));\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    int w, c;\n    cin >> w >> c;\n    k[w].push_back(c);\n  }\n  second = (int)k[1].size() + 2 * (int)k[2].size();\n  for (int i = 1; i < 4; i++) {\n    sort(k[i].begin(), k[i].end());\n    reverse(k[i].begin(), k[i].end());\n  }\n  for (int i = 1; i < 4; i++) {\n    cum[i].push_back(0);\n    for (int j : k[i]) {\n      long long cur = j + cum[i][cum[i].size() - 1];\n      cum[i].push_back(cur);\n    }\n  }\n  for (int i = 0; i < cum[3].size(); i++) {\n    int x = min(m - 3 * i, second);\n    if (x >= 0) ans = max(ans, cum[3][i] + solve(x));\n    if (x - 1 >= 0) ans = max(ans, cum[3][i] + solve(x - 1));\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, m;\nlong long a[300001], b[300001], c[300001];\nlong long p1[300001], p2[300001], p3[300001], dp[300001];\nsigned main() {\n  cin.tie(0);\n  cout.tie(0);\n  ios_base::sync_with_stdio(false);\n  cin >> n >> m;\n  long long p = 0, q = 0, r = 0;\n  for (long long i = 1; i <= n; i++) {\n    long long w, cost;\n    cin >> w >> cost;\n    if (w == 1)\n      a[++p] = cost;\n    else if (w == 2)\n      b[++q] = cost;\n    else\n      c[++r] = cost;\n  }\n  sort(a + 1, a + p + 1);\n  reverse(a + 1, a + p + 1);\n  sort(b + 1, b + q + 1);\n  reverse(b + 1, b + q + 1);\n  sort(c + 1, c + r + 1);\n  reverse(c + 1, c + r + 1);\n  for (long long i = 1; i < r + 1; i++) c[i] += c[i - 1];\n  p1[1] = 1;\n  dp[1] = a[1];\n  dp[2] = max(a[1] + a[2], b[1]);\n  if (dp[2] == a[1] + a[2]) {\n    p1[2] = 2;\n  } else\n    p2[2] = 1;\n  for (long long i = 3; i < m + 1; i++) {\n    long long x = p1[i - 1] + 1, y = p2[i - 1];\n    dp[i] = dp[i - 1] + a[p1[i - 1] + 1];\n    if (dp[i] < dp[i - 2] + a[p1[i - 2] + 1] + a[p1[i - 2] + 2]) {\n      x = p1[i - 2] + 2;\n      y = p2[i - 1];\n      dp[i] = dp[i - 2] + a[p1[i - 2] + 1] + a[p1[i - 2] + 2];\n    }\n    if (dp[i] < dp[i - 2] + b[p2[i - 2] + 1]) {\n      x = p1[i - 2], y = p2[i - 2] + 1;\n      dp[i] = dp[i - 2] + b[p2[i - 2] + 1];\n    }\n    p1[i] = x;\n    p2[i] = y;\n  }\n  long long ans = 0;\n  for (long long i = 1; i < m + 1; i++) {\n    dp[i] = max(dp[i - 1], dp[i]);\n  }\n  for (long long i = 0; i < r + 1; i++) {\n    long long rem = m - i * 3;\n    if (rem < 0) break;\n    ans = max(ans, c[i] + dp[rem]);\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long ans[300005], x[300005], y[300005];\nint n, m, a, b, c;\nvector<long long> v[4];\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0);\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    int w, cost;\n    cin >> w >> cost;\n    v[w].push_back(cost);\n    if (w == 1) a++;\n    if (w == 2) b++;\n    if (w == 3) c++;\n  }\n  for (int i = 1; i < 4; i++) {\n    sort((v[i]).begin(), (v[i]).end());\n    reverse((v[i]).begin(), (v[i]).end());\n  }\n  memset(ans, -1, sizeof(ans));\n  ans[0] = x[0] = y[0] = 0;\n  for (int i = 0; i < m; i++) {\n    if (ans[i] == -1) continue;\n    if (x[i] < a && ans[i + 1] < ans[i] + v[1][x[i]]) {\n      ans[i + 1] = ans[i] + v[1][x[i]];\n      x[i + 1] = x[i] + 1;\n      y[i + 1] = y[i];\n    }\n    if (y[i] < b && ans[i + 2] < ans[i] + v[2][y[i]]) {\n      ans[i + 2] = ans[i] + v[2][y[i]];\n      x[i + 2] = x[i];\n      y[i + 2] = y[i] + 1;\n    }\n  }\n  for (int i = 1; i < m + 1; i++) ans[i] = max(ans[i], ans[i - 1]);\n  long long sum = 0, resp = ans[m];\n  for (int i = 0; i < c; i++) {\n    sum += v[3][i];\n    if ((i + 1) * 3 <= m) {\n      resp = max(resp, sum + ans[m - 3 * (i + 1)]);\n    }\n  }\n  cout << resp << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\nlong long dp[300005];\npair<double, long long> p[100005];\nlong long a[100005], b[100005];\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  long long n, m;\n  cin >> n >> m;\n  for (long long i = 1; i <= n; i++) {\n    cin >> a[i] >> b[i];\n    p[i] = make_pair(1.0 * b[i] / a[i], i);\n  }\n  sort(p + 1, p + n + 1, greater<pair<double, long long> >());\n  long long tot = 0;\n  for (long long i = 1; i <= n; i++) {\n    long long now = p[i].second;\n    tot += a[now];\n    for (long long j = tot; j >= max(a[now], tot - 100); j--) {\n      dp[j] = max(dp[j], dp[j - a[now]] + b[now]);\n    }\n  }\n  long long ans = 0;\n  for (long long i = 1; i <= min(tot, m); i++) ans = max(ans, dp[i]);\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "import sys\nfrom itertools import accumulate\n\n\nn, m = map(int, sys.stdin.buffer.readline().decode('utf-8').split())\nitems = [[], [], [], []]\nfor w, c in (map(int, line.decode('utf-8').split()) for line in sys.stdin.buffer):\n    items[w].append(c)\n\nfor i in range(1, 4):\n    items[i].sort(reverse=True)\n\nn_w1, n_w2 = len(items[1]), len(items[2])\ndp = [0]*(m+3)\ndp_w1, dp_w2 = [0]*(m+3), [0]*(m+3)\n\nfor i in range(m+1):\n    if i > 0 and dp[i-1] > dp[i]:\n        dp[i] = dp[i-1]\n        dp_w1[i], dp_w2[i] = dp_w1[i-1], dp_w2[i-1]\n\n    if dp_w1[i] < n_w1 and dp[i+1] < dp[i] + items[1][dp_w1[i]]:\n        dp[i+1] = dp[i] + items[1][dp_w1[i]]\n        dp_w1[i+1] = dp_w1[i] + 1\n        dp_w2[i+1] = dp_w2[i]\n\n    if dp_w2[i] < n_w2 and dp[i+2] < dp[i] + items[2][dp_w2[i]]:\n        dp[i+2] = dp[i] + items[2][dp_w2[i]]\n        dp_w1[i+2] = dp_w1[i]\n        dp_w2[i+2] = dp_w2[i] + 1\n\nitems[3] = [0] + list(accumulate(items[3]))\n\nans = 0\nfor i in range(len(items[3])):\n    if i*3 > m:\n        break\n    ans = max(ans, items[3][i] + dp[m - i*3])\n\nprint(ans)\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.concurrent.ArrayBlockingQueue;\n\n/*\n public class _808E {\n\n }\n\n */\n\npublic class _808E\n{\n\tpublic void solve() throws FileNotFoundException\n\t{\n\t\tInputStream inputStream = System.in;\n\n\t\tInputHelper inputHelper = new InputHelper(inputStream);\n\n\t\tPrintStream out = System.out;\n\n\t\t// actual solution\n\t\tint n = inputHelper.readInteger();\n\t\tint m = inputHelper.readInteger();\n\n\t\t// if(m == 46634)\n\t\t// {\n\t\t// System.out.println(\"24804061310402\");\n\t\t// return;\n\t\t// }\n\t\tList[] swc = new List[3];\n\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\tswc[i] = new ArrayList<Integer>();\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint w = inputHelper.readInteger();\n\t\t\tint c = inputHelper.readInteger();\n\n\t\t\tswc[w - 1].add(c);\n\t\t}\n\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\tswc[i].sort(Comparator.comparingInt(x -> (int) x).reversed());\n\n\t\tint[][] dp1 = new int[m + 1][3];\n\n\t\tlong[] dp2 = new long[m + 1];\n\n\t\tfor (int i = 0; i < 3; i++)\n\t\t{\n\t\t\tdp1[0][i] = 0;\n\t\t}\n\n\t\tdp2[0] = 0;\n\n\t\tfor (int i = 1; i <= m; i++)\n\t\t{\n\t\t\tdp2[i] = dp2[i - 1];\n\n\t\t\tdp1[i][0] = dp1[i - 1][0];\n\t\t\tdp1[i][1] = dp1[i - 1][1];\n\t\t\tdp1[i][2] = dp1[i - 1][2];\n\n\t\t\t// if (dp1[i - 1][0] < swc[0].size())\n\t\t\t// {\n\t\t\t// long c = dp2[i - 1] + (int) swc[0].get(dp1[i - 1][0]);\n\t\t\t//\n\t\t\t// if (c >= dp2[i])\n\t\t\t// {\n\t\t\t// dp2[i] = c;\n\t\t\t//\n\t\t\t// dp1[i][0] = dp1[i - 1][0] + 1;\n\t\t\t// dp1[i][1] = dp1[i - 1][1];\n\t\t\t// dp1[i][2] = dp1[i - 1][2];\n\t\t\t// }\n\t\t\t// }\n\t\t\t//\n\t\t\t// if (i >= 2 && dp1[i - 2][1] < swc[1].size())\n\t\t\t// {\n\t\t\t// long c = dp2[i - 2] + (int) swc[1].get(dp1[i - 2][1]);\n\t\t\t//\n\t\t\t// if (c >= dp2[i])\n\t\t\t// {\n\t\t\t// dp2[i] = c;\n\t\t\t//\n\t\t\t// dp1[i][0] = dp1[i - 2][0];\n\t\t\t// dp1[i][1] = dp1[i - 2][1] + 1;\n\t\t\t// dp1[i][2] = dp1[i - 2][2];\n\t\t\t// }\n\t\t\t// }\n\t\t\t//\n\t\t\t// if (i >= 3 && dp1[i - 3][2] < swc[2].size())\n\t\t\t// {\n\t\t\t// long c = dp2[i - 3] + (int) swc[2].get(dp1[i - 3][2]);\n\t\t\t//\n\t\t\t// if (c >= dp2[i])\n\t\t\t// {\n\t\t\t// dp2[i] = c;\n\t\t\t//\n\t\t\t// dp1[i][0] = dp1[i - 3][0];\n\t\t\t// dp1[i][1] = dp1[i - 3][1];\n\t\t\t// dp1[i][2] = dp1[i - 3][2] + 1;\n\t\t\t// }\n\t\t\t// }\n\n\t\t\tif (dp1[i - 1][0] < swc[0].size())\n\t\t\t{\n\t\t\t\tlong c = dp2[i - 1] + (int) swc[0].get(dp1[i - 1][0]);\n\n\t\t\t\tif (c >= dp2[i])\n\t\t\t\t{\n\t\t\t\t\tdp2[i] = c;\n\n\t\t\t\t\tdp1[i][0] = dp1[i - 1][0] + 1;\n\t\t\t\t\tdp1[i][1] = dp1[i - 1][1];\n\t\t\t\t\tdp1[i][2] = dp1[i - 1][2];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dp1[i - 1][0] > 0 && dp1[i - 1][1] < swc[1].size())\n\t\t\t{\n\t\t\t\tlong c = dp2[i - 1] + (int) swc[1].get(dp1[i - 1][1])\n\t\t\t\t\t\t- (int) swc[0].get(dp1[i - 1][0] - 1);\n\n\t\t\t\tif (c >= dp2[i])\n\t\t\t\t{\n\t\t\t\t\tdp2[i] = c;\n\n\t\t\t\t\tdp1[i][0] = dp1[i - 1][0] - 1;\n\t\t\t\t\tdp1[i][1] = dp1[i - 1][1] + 1;\n\t\t\t\t\tdp1[i][2] = dp1[i - 1][2];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dp1[i - 1][0] > 1 && dp1[i - 1][2] < swc[2].size())\n\t\t\t{\n\t\t\t\tlong c = dp2[i - 1] + (int) swc[2].get(dp1[i - 1][2])\n\t\t\t\t\t\t- (int) swc[0].get(dp1[i - 1][0] - 1)\n\t\t\t\t\t\t- (int) swc[0].get(dp1[i - 1][0] - 2);\n\n\t\t\t\tif (c >= dp2[i])\n\t\t\t\t{\n\t\t\t\t\tdp2[i] = c;\n\n\t\t\t\t\tdp1[i][0] = dp1[i - 1][0] - 2;\n\t\t\t\t\tdp1[i][1] = dp1[i - 1][1];\n\t\t\t\t\tdp1[i][2] = dp1[i - 1][2] + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dp1[i - 1][1] > 0 && dp1[i - 1][2] < swc[2].size())\n\t\t\t{\n\t\t\t\tlong c = dp2[i - 1] + (int) swc[2].get(dp1[i - 1][2])\n\t\t\t\t\t\t- (int) swc[1].get(dp1[i - 1][1] - 1);\n\n\t\t\t\tif (c >= dp2[i])\n\t\t\t\t{\n\t\t\t\t\tdp2[i] = c;\n\n\t\t\t\t\tdp1[i][0] = dp1[i - 1][0];\n\t\t\t\t\tdp1[i][1] = dp1[i - 1][1] - 1;\n\t\t\t\t\tdp1[i][2] = dp1[i - 1][2] + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i > 1)\n\t\t\t{\n\t\t\t\tif (dp1[i - 2][1] < swc[1].size())\n\t\t\t\t{\n\t\t\t\t\tlong c = dp2[i - 2] + (int) swc[1].get(dp1[i - 2][1]);\n\n\t\t\t\t\tif (c >= dp2[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tdp2[i] = c;\n\n\t\t\t\t\t\tdp1[i][0] = dp1[i - 2][0];\n\t\t\t\t\t\tdp1[i][1] = dp1[i - 2][1] + 1;\n\t\t\t\t\t\tdp1[i][2] = dp1[i - 2][2];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (dp1[i - 2][0] < swc[0].size() - 1)\n\t\t\t\t{\n\t\t\t\t\tlong c = dp2[i - 2] + (int) swc[0].get(dp1[i - 2][0])\n\t\t\t\t\t\t\t+ (int) swc[0].get(dp1[i - 2][0] + 1);\n\n\t\t\t\t\tif (c >= dp2[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tdp2[i] = c;\n\n\t\t\t\t\t\tdp1[i][0] = dp1[i - 2][0] + 2;\n\t\t\t\t\t\tdp1[i][1] = dp1[i - 2][1];\n\t\t\t\t\t\tdp1[i][2] = dp1[i - 2][2];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (dp1[i - 2][0] > 0 && dp1[i - 2][2] < swc[2].size() - 1)\n\t\t\t\t{\n\t\t\t\t\tlong c = dp2[i - 2] - (int) swc[0].get(dp1[i - 2][0] - 1)\n\t\t\t\t\t\t\t+ (int) swc[2].get(dp1[i - 2][2]);\n\n\t\t\t\t\tif (c >= dp2[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tdp2[i] = c;\n\n\t\t\t\t\t\tdp1[i][0] = dp1[i - 2][0] - 1;\n\t\t\t\t\t\tdp1[i][1] = dp1[i - 2][1];\n\t\t\t\t\t\tdp1[i][2] = dp1[i - 2][2] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i > 2)\n\t\t\t{\n\t\t\t\tif (dp1[i - 3][2] < swc[2].size())\n\t\t\t\t{\n\t\t\t\t\tlong c = dp2[i - 3] + (int) swc[2].get(dp1[i - 3][2]);\n\n\t\t\t\t\tif (c >= dp2[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tdp2[i] = c;\n\n\t\t\t\t\t\tdp1[i][0] = dp1[i - 3][0];\n\t\t\t\t\t\tdp1[i][1] = dp1[i - 3][1];\n\t\t\t\t\t\tdp1[i][2] = dp1[i - 3][2] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (dp1[i - 3][0] < swc[0].size() - 2)\n\t\t\t\t{\n\t\t\t\t\tlong c = dp2[i - 3] + (int) swc[0].get(dp1[i - 3][0])\n\t\t\t\t\t\t\t+ (int) swc[0].get(dp1[i - 3][0] + 1)\n\t\t\t\t\t\t\t+ (int) swc[0].get(dp1[i - 3][0] + 2);\n\n\t\t\t\t\tif (c >= dp2[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tdp2[i] = c;\n\n\t\t\t\t\t\tdp1[i][0] = dp1[i - 3][0] + 3;\n\t\t\t\t\t\tdp1[i][1] = dp1[i - 3][1];\n\t\t\t\t\t\tdp1[i][2] = dp1[i - 3][2];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (dp1[i - 3][0] < swc[0].size()\n\t\t\t\t\t\t&& dp1[i - 3][1] < swc[1].size())\n\t\t\t\t{\n\t\t\t\t\tlong c = dp2[i - 3] + (int) swc[0].get(dp1[i - 3][0])\n\t\t\t\t\t\t\t+ (int) swc[1].get(dp1[i - 3][1]);\n\n\t\t\t\t\tif (c >= dp2[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tdp2[i] = c;\n\n\t\t\t\t\t\tdp1[i][0] = dp1[i - 3][0] + 1;\n\t\t\t\t\t\tdp1[i][1] = dp1[i - 3][1] + 1;\n\t\t\t\t\t\tdp1[i][2] = dp1[i - 3][2];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(dp2[m]);\n\t\t// end here\n\t}\n\n\tpublic static void main(String[] args) throws FileNotFoundException\n\t{\n\t\t(new _808E()).solve();\n\t}\n\n\tclass InputHelper\n\t{\n\t\tStringTokenizer tokenizer = null;\n\t\tprivate BufferedReader bufferedReader;\n\n\t\tpublic InputHelper(InputStream inputStream)\n\t\t{\n\t\t\tInputStreamReader inputStreamReader = new InputStreamReader(\n\t\t\t\t\tinputStream);\n\t\t\tbufferedReader = new BufferedReader(inputStreamReader, 16384);\n\t\t}\n\n\t\tpublic String read()\n\t\t{\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens())\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tString line = bufferedReader.readLine();\n\t\t\t\t\tif (line == null)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\ttokenizer = new StringTokenizer(line);\n\t\t\t\t}\n\t\t\t\tcatch (IOException e)\n\t\t\t\t{\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tpublic Integer readInteger()\n\t\t{\n\t\t\treturn Integer.parseInt(read());\n\t\t}\n\n\t\tpublic Long readLong()\n\t\t{\n\t\t\treturn Long.parseLong(read());\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1000000007;\nvoid sync_stdio() {\n  cin.tie(NULL);\n  ios_base::sync_with_stdio(false);\n}\nstruct Sync_stdio {\n  Sync_stdio() {\n    cin.tie(NULL);\n    ios_base::sync_with_stdio(false);\n  }\n} _sync_stdio;\nstruct FAIL {\n  FAIL() {\n    cout << \"CHANGE!!!\"\n         << \"\\n\";\n  }\n};\nvector<long long> one_two_knapsack(const vector<long long> &ps1,\n                                   const vector<long long> &ps2, int m) {\n  int one = ps1.size() - 1;\n  int two = ps2.size() - 1;\n  int n = max(m, one + two * 2) + 1;\n  vector<pair<int, int>> opt(n);\n  vector<long long> dp(n);\n  if (one == 0) {\n    for (int i = (0); i < (ps2.size()); ++i) {\n      dp[i * 2] = ps2[i];\n    }\n    for (int i = (1); i < (n); ++i) {\n      dp[i] = max(dp[i - 1], dp[i]);\n    }\n    return dp;\n  }\n  opt[0] = {0, 0};\n  dp[0] = 0;\n  for (int i = (1); i < (one + two * 2 + 1); ++i) {\n    for (int j = (opt[i - 1].first - 3); j < (opt[i - 1].first + 4); ++j) {\n      for (int k = (opt[i - 1].second - 1); k < (opt[i - 1].second + 2); ++k) {\n        if (!(0 <= j && j < ps1.size())) {\n          continue;\n        }\n        if (!(0 <= k && k < ps2.size())) {\n          continue;\n        }\n        if (j + 2 * k != i) {\n          continue;\n        }\n        if (ps1[j] + ps2[k] > dp[i]) {\n          dp[i] = ps1[j] + ps2[k];\n          opt[i] = {j, k};\n        }\n      }\n    }\n  }\n  for (int i = (1); i < (n); ++i) {\n    dp[i] = max(dp[i - 1], dp[i]);\n  }\n  return dp;\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<vector<long long>> ps(3);\n  for (int i = (0); i < (n); ++i) {\n    int w, c;\n    cin >> w >> c;\n    --w;\n    ps[w].push_back(c);\n  }\n  for (int i = (0); i < (3); ++i) {\n    sort(ps[i].begin(), ps[i].end());\n    reverse(ps[i].begin(), ps[i].end());\n    ps[i].insert(ps[i].begin(), 0);\n  }\n  for (int i = (0); i < (3); ++i) {\n    for (int j = (1); j < (ps[i].size()); ++j) {\n      ps[i][j] += ps[i][j - 1];\n    }\n  }\n  vector<long long> one_two_best = one_two_knapsack(ps[0], ps[1], m);\n  long long res = 0;\n  for (int i = (0); i < (ps[2].size()); ++i) {\n    int t = m - 3 * i;\n    if (t < 0) {\n      continue;\n    }\n    res = max(res, ps[2][i] + one_two_best[t]);\n  }\n  cout << res;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n  long long w, s1, s2;\n} dp[300005];\nlong long a[4][300005];\nlong long s[4][300005];\nint num[4];\nbool cmp(int a, int b) { return a > b; }\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; i++) {\n    long long w, c;\n    scanf(\"%lld%lld\", &w, &c);\n    a[w][++num[w]] = c;\n  }\n  for (int i = 1; i <= 3; i++) {\n    sort(a[i] + 1, a[i] + num[i] + 1, cmp);\n    for (int j = 1; j <= num[i]; j++) {\n      s[i][j] = s[i][j - 1] + a[i][j];\n    }\n  }\n  dp[0].w = dp[0].s1 = dp[0].s2 = 0;\n  for (int i = 1; i <= m; i++) {\n    dp[i] = dp[i - 1];\n    if (dp[i - 1].w + a[1][dp[i - 1].s1 + 1] > dp[i].w) {\n      dp[i].w = dp[i - 1].w + a[1][dp[i - 1].s1 + 1];\n      dp[i].s1 = dp[i - 1].s1 + 1;\n      dp[i].s2 = dp[i - 1].s2;\n    }\n    if (i >= 2 && dp[i - 2].w + a[2][dp[i - 2].s2 + 1] > dp[i].w) {\n      dp[i].w = dp[i - 2].w + a[2][dp[i - 2].s2 + 1];\n      dp[i].s1 = dp[i - 2].s1;\n      dp[i].s2 = dp[i - 2].s2 + 1;\n    }\n  }\n  long long res = 0;\n  for (int i = 0; i <= num[3]; i++) {\n    if (m >= i * 3) res = max(res, s[3][i] + dp[m - 3 * i].w);\n  }\n  printf(\"%I64d\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 100005;\nusing namespace std;\nint n, m, sz[3];\nlong long d[3][N], f[N << 2];\nvoid solve() {\n  for (int i = 0; i <= 2; ++i) sort(d[i] + 1, d[i] + sz[i] + 1);\n  for (int i = 0; i <= 2; ++i) reverse(d[i] + 1, d[i] + sz[i] + 1);\n  for (int i = 0; i <= 2; ++i) {\n    for (int j = 2; j <= sz[i]; ++j) d[i][j] += d[i][j - 1];\n  }\n  int top0 = 2, top1 = 1;\n  for (int i = 2; i <= m; i += 2) {\n    f[i] = f[i - 2];\n    if (top0 <= sz[0] && (top1 > sz[1] || d[0][top0] - d[0][top0 - 2] >=\n                                              d[1][top1] - d[1][top1 - 1]))\n      f[i] = f[i - 2] + d[0][top0] - d[0][top0 - 2], top0 += 2;\n    else if (top1 <= sz[1])\n      f[i] = f[i - 2] + d[1][top1] - d[1][top1 - 1], ++top1;\n  }\n  f[1] = d[0][1];\n  top0 = 3, top1 = 1;\n  for (int i = 3; i <= m; i += 2) {\n    f[i] = f[i - 2];\n    if (top0 <= sz[0] && (top1 > sz[1] || d[0][top0] - d[0][top0 - 2] >=\n                                              d[1][top1] - d[1][top1 - 1]))\n      f[i] = f[i - 2] + d[0][top0] - d[0][top0 - 2], top0 += 2;\n    else if (top1 <= sz[1])\n      f[i] = f[i - 2] + d[1][top1] - d[1][top1 - 1], ++top1;\n  }\n  long long ans = 0;\n  for (int i = 0; i <= m; ++i) {\n    int x = (m - i) / 3;\n    x = min(x, sz[2]);\n    ans = max(ans, f[i] + d[2][x]);\n  }\n  printf(\"%I64d\\n\", ans);\n}\nint main() {\n  int x, y;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d%d\", &x, &y);\n    --x;\n    ++sz[x];\n    d[x][sz[x]] = y;\n  }\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nclass input {\n private:\n  bool fail;\n  istream* stream;\n\n public:\n  input(istream& stream_ = cin) { stream = &stream_; }\n  istream& getStream() { return *stream; }\n  template <typename T = int>\n  T read() {\n    T value;\n    if (*stream >> value) {\n      fail = false;\n    } else {\n      fail = true;\n    }\n    return value;\n  }\n  template <typename T = int>\n  vector<T> readArray() {\n    size_t size = read<size_t>();\n    return readArray<T>(size);\n  }\n  template <typename T = int>\n  vector<T> readArray(size_t size) {\n    vector<T> v(size);\n    for (size_t i = 0; i < size; i++) {\n      if (*stream >> v[i]) {\n        fail = false;\n      } else {\n        fail = true;\n      }\n    }\n    return v;\n  }\n  bool isFailed() { return fail; }\n  static input& getStdin() {\n    static input in(cin);\n    return in;\n  }\n};\nclass output {\n private:\n  ostream* stream;\n\n public:\n  output(ostream& stream_ = cout) { stream = &stream_; }\n  ostream& getStream() { return *stream; }\n  template <typename T>\n  output& put(T& value) {\n    *stream << value;\n    return *this;\n  }\n  template <typename T>\n  output& put(T& value, int precision) {\n    *stream << setprecision(precision) << value;\n    return *this;\n  }\n  template <typename T>\n  output& write(const T& value) {\n    *stream << value << endl;\n    return *this;\n  }\n  template <typename T>\n  output& write(T& value, int precision) {\n    *stream << setprecision(precision) << fixed << value << endl;\n    return *this;\n  }\n  template <typename T>\n  output& writeArray(const vector<T>& v, bool appendSize = true) {\n    if (appendSize) {\n      write(v.size());\n    }\n    for (auto& x : v) {\n      *stream << x << \" \";\n    }\n    *stream << endl;\n    return *this;\n  }\n  output& writeLine() {\n    *stream << endl;\n    return *this;\n  }\n  output& getStdout() {\n    output out(cout);\n    return out;\n  }\n  output getStderr() {\n    output err(cerr);\n    return err;\n  }\n};\ninput in(cin);\noutput out(cout);\noutput err(cerr);\nvoid solve() {\n  auto n = in.read();\n  auto m = in.read();\n  vector<pair<long long, long long>> items;\n  for (auto i = 0; i < n; i++) {\n    auto w = in.read<long long>();\n    auto c = in.read<long long>();\n    items.push_back(make_pair((c * 6) / w, w));\n  }\n  sort(items.begin(), items.end());\n  reverse(items.begin(), items.end());\n  vector<int> topCnt(3);\n  vector<int> allCnt(3);\n  int ws = 0;\n  for (auto p : items) {\n    if (p.second <= m - ws) {\n      topCnt[p.second - 1]++;\n      ws += p.second;\n    }\n    allCnt[p.second - 1]++;\n  }\n  auto t1 = topCnt[0];\n  auto t2 = topCnt[1];\n  auto t3 = topCnt[2];\n  auto tt = 3;\n  long long ans = 0;\n  vector<int> rtmp(3);\n  for (auto i1 = t1 - 3; i1 <= t1 + 3; i1++) {\n    for (auto i2 = t2 - 3; i2 <= t2 + 3; i2++) {\n      for (auto i3 = t3 - 3; i3 <= t3 + 3; i3++) {\n        rtmp[0] = i1;\n        rtmp[1] = i2;\n        rtmp[2] = i3;\n        auto w = m;\n        long long nans = 0;\n        for (auto& x : items) {\n          if (rtmp[x.second - 1] > 0 && x.second <= w) {\n            rtmp[x.second - 1]--;\n            w -= x.second;\n            nans += (x.first * x.second) / 6;\n          }\n        }\n        if (nans > ans) ans = nans;\n      }\n    }\n  }\n  out.write(ans);\n}\nint main() {\n  while (true) {\n    auto startT = clock();\n    solve();\n    auto endT = clock();\n    cerr << endl;\n    cerr << \"Working time: \" << (endT - startT) << \" ms\" << endl;\n    cerr << \"-------------------------\" << endl;\n    bool ok = false;\n    while (!in.isFailed() && !ok) {\n      ok = in.read<char>() == '$';\n    }\n    if (!ok) {\n      break;\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N, M;\nvector<long long> one, two, three;\nlong long dp[1000000];\nvector<long long> pre1, pre2, pre3;\nlong long ans;\nlong long score(int tot, int a2) { return pre2[a2] + pre1[tot - 2 * a2]; }\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin >> N >> M;\n  for (int i = 0; i < N; i++) {\n    int a, b;\n    cin >> a >> b;\n    if (a == 1) {\n      one.push_back(b);\n    }\n    if (a == 2) {\n      two.push_back(b);\n    }\n    if (a == 3) {\n      three.push_back(b);\n    }\n  }\n  sort(one.begin(), one.end());\n  reverse(one.begin(), one.end());\n  sort(two.begin(), two.end());\n  reverse(two.begin(), two.end());\n  sort(three.begin(), three.end());\n  reverse(three.begin(), three.end());\n  pre1.push_back(0);\n  for (int i = 0; i < one.size(); i++) {\n    pre1.push_back(pre1.back() + one[i]);\n  }\n  pre2.push_back(0);\n  for (int i = 0; i < two.size(); i++) {\n    pre2.push_back(pre2.back() + two[i]);\n  }\n  pre3.push_back(0);\n  for (int i = 0; i < three.size(); i++) {\n    pre3.push_back(pre3.back() + three[i]);\n  }\n  for (int i = 0; i <= one.size() + 2 * two.size(); i++) {\n    dp[i] = -1000000000000000001ll;\n    int small = max(0, ((int)(i - one.size() + 1) / 2));\n    int big = min(i / 2, (int)(two.size()));\n    while (big - small > 2) {\n      int lt = (2 * small + big) / 3;\n      int rt = (2 * big + small) / 3;\n      if (score(i, lt) > score(i, rt)) {\n        big = rt;\n      }\n      if (score(i, lt) < score(i, rt)) {\n        small = lt;\n      }\n      if (score(i, lt) == score(i, rt)) {\n        small = lt;\n        big = rt;\n      }\n    }\n    for (int j = small; j <= big; j++) {\n      dp[i] = max(dp[i], score(i, j));\n    }\n  }\n  for (int i = 1; i <= M; i++) {\n    dp[i] = max(dp[i], dp[i - 1]);\n  }\n  for (int i = 0; i <= three.size() && 3 * i <= M; i++) {\n    ans = max(ans, pre3[i] + dp[M - 3 * i]);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 9;\nconst int M = 3e5 + 9;\nstruct Triple {\n  long long cost;\n  int cnt1, cnt2, cnt3;\n} dp[M];\nint n, m;\nlong long sum3[N];\nvector<int> c[4];\nbool cmp(int x, int y) { return x > y; }\nint main() {\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    int weight, cost;\n    cin >> weight >> cost;\n    c[weight].push_back(cost);\n  }\n  sort(c[1].begin(), c[1].end(), cmp);\n  sort(c[2].begin(), c[2].end(), cmp);\n  sort(c[3].begin(), c[3].end(), cmp);\n  dp[0].cost = 0;\n  dp[0].cnt1 = 0;\n  dp[0].cnt2 = 0;\n  dp[0].cnt3 = 0;\n  for (int i = 0; i <= m; i++) {\n    dp[i].cost = 0;\n  }\n  for (int i = 1; i <= m; i++) {\n    if (dp[i - 1].cnt1 < c[1].size() &&\n        dp[i - 1].cost + c[1][dp[i - 1].cnt1] > dp[i].cost) {\n      dp[i].cost = dp[i - 1].cost + c[1][dp[i - 1].cnt1];\n      dp[i].cnt1 = dp[i - 1].cnt1 + 1;\n      dp[i].cnt2 = dp[i - 1].cnt2;\n      dp[i].cnt3 = dp[i - 1].cnt3;\n    }\n    if (i >= 2 && dp[i - 2].cnt2 < c[2].size() &&\n        dp[i - 2].cost + c[2][dp[i - 2].cnt2] > dp[i].cost) {\n      dp[i].cost = dp[i - 2].cost + c[2][dp[i - 2].cnt2];\n      dp[i].cnt1 = dp[i - 2].cnt1;\n      dp[i].cnt2 = dp[i - 2].cnt2 + 1;\n      dp[i].cnt3 = dp[i - 2].cnt3;\n    }\n    if (i >= 3 && dp[i - 3].cnt3 < c[3].size() &&\n        dp[i - 3].cost + c[3][dp[i - 3].cnt3] > dp[i].cost) {\n      dp[i].cost = dp[i - 3].cost + c[3][dp[i - 3].cnt3];\n      dp[i].cnt1 = dp[i - 3].cnt1;\n      dp[i].cnt2 = dp[i - 3].cnt2;\n      dp[i].cnt3 = dp[i - 3].cnt3 + 1;\n    }\n    if (dp[i - 2].cnt1 > 0 && dp[i - 2].cnt3 < c[3].size() &&\n        dp[i - 2].cost - c[1][dp[i - 2].cnt1 - 1] + c[3][dp[i - 2].cnt3] >\n            dp[i].cost) {\n      dp[i].cost =\n          dp[i - 2].cost - c[1][dp[i - 2].cnt1 - 1] + c[3][dp[i - 2].cnt3];\n      dp[i].cnt1 = dp[i - 2].cnt1 - 1;\n      dp[i].cnt2 = dp[i - 2].cnt2;\n      dp[i].cnt3 = dp[i - 2].cnt3 + 1;\n    }\n    if (i >= 1 && dp[i - 1].cost > dp[i].cost) dp[i] = dp[i - 1];\n    if (i >= 2 && dp[i - 2].cost > dp[i].cost) dp[i] = dp[i - 2];\n    if (i >= 3 && dp[i - 3].cost > dp[i].cost) dp[i] = dp[i - 3];\n  }\n  long long res = dp[m].cost;\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct str {\n  long long nrw1, nrw2;\n  long long val;\n};\nstr dp[300003];\nlong long n, m;\nlong long sol[300003];\nvector<long long> v[4];\nint main() {\n  cin >> n >> m;\n  v[1].push_back(-(1 << 30));\n  v[2].push_back(-(1 << 30));\n  v[3].push_back(-(1 << 30));\n  for (long long i = 1; i <= n; ++i) {\n    long long x, w;\n    cin >> w >> x;\n    v[w].push_back(x);\n  }\n  sort(v[1].begin(), v[1].end(), greater<long long>());\n  sort(v[2].begin(), v[2].end(), greater<long long>());\n  sort(v[3].begin(), v[3].end(), greater<long long>());\n  dp[1].val = v[1][0];\n  dp[1].nrw1 = 1;\n  dp[1].nrw2 = 0;\n  dp[2].val = v[2][0];\n  dp[2].nrw1 = 0;\n  dp[2].nrw2 = 1;\n  for (long long i = 1; i <= m; ++i) {\n    if (dp[i].nrw1 < v[1].size() &&\n        dp[i + 1].val < dp[i].val + v[1][dp[i].nrw1]) {\n      dp[i + 1] = dp[i];\n      dp[i + 1].val += v[1][dp[i].nrw1];\n      dp[i + 1].nrw1++;\n    }\n    if (dp[i].nrw2 < v[2].size() &&\n        dp[i + 2].val < dp[i].val + v[2][dp[i].nrw2]) {\n      dp[i + 2] = dp[i];\n      dp[i + 2].val += v[2][dp[i].nrw2];\n      dp[i + 2].nrw2++;\n    }\n    sol[i] = max(dp[i].val, sol[i - 1]);\n  }\n  long long ans = sol[m], sum = 0;\n  for (long long i = 0; i < v[3].size() && (i + 1) * 3 <= m; ++i) {\n    sum += v[3][i];\n    ans = max(ans, sol[m - (i + 1) * 3] + sum);\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nbool umin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\nbool umax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\nint n, m;\nlong long par[300009], dp[300009];\npair<int, int> pnt[300009];\nvector<int> adj[3];\nlong long solve(int x) {\n  if (m < x * 3) return 0;\n  return dp[m - x * 3] + par[x];\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < 3; i++) adj[i].push_back(1000000007);\n  while (n--) {\n    int w, c;\n    scanf(\"%d%d\", &w, &c);\n    adj[w - 1].push_back(c);\n  }\n  for (int i = 0; i < 3; i++) {\n    sort(adj[i].begin(), adj[i].end());\n    reverse(adj[i].begin(), adj[i].end());\n    adj[i][0] = 0;\n  }\n  for (int i = 1; i < (int)adj[2].size(); i++) par[i] = par[i - 1] + adj[2][i];\n  for (int i = 0; i < ((int)adj[0].size() + (int)adj[1].size() * 2 - 3); i++) {\n    int p0 = pnt[i].first, p1 = pnt[i].second;\n    if (!p0 and !p1 and i) continue;\n    if (p0 + 1 < int(adj[0].size()) and umax(dp[i + 1], dp[i] + adj[0][p0 + 1]))\n      pnt[i + 1] = make_pair(p0 + 1, p1);\n    if (p1 + 1 < int(adj[1].size()) and p0 + 2 < int(adj[0].size())) {\n      if (adj[1][p1 + 1] > adj[0][p0 + 1] + adj[0][p0 + 2])\n        dp[i + 2] = dp[i] + adj[1][p1 + 1], pnt[i + 2] = make_pair(p0, p1 + 1);\n      else\n        dp[i + 2] = dp[i] + adj[0][p0 + 1] + adj[0][p0 + 2],\n               pnt[i + 2] = make_pair(p0 + 2, p1);\n    } else if (p1 + 1 < int(adj[1].size()))\n      dp[i + 2] = dp[i] + adj[1][p1 + 1], pnt[i + 2] = make_pair(p0, p1 + 1);\n    else if (p0 + 2 < int(adj[0].size()))\n      dp[i + 2] = dp[i] + adj[0][p0 + 1] + adj[0][p0 + 2],\n             pnt[i + 2] = make_pair(p0 + 2, p1);\n  }\n  for (int i = 1; i < 300009; i++) umax(dp[i], dp[i - 1]);\n  long long ans = 0;\n  for (int i = 0; i < int(adj[2].size()); i++) umax(ans, solve(i));\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\n\npublic class Abood2D {\n\n\n\tpublic static void main(String[] args) throws Exception{\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tint n = sc.nextInt();\n\t\tint max = sc.nextInt();\n\t\tArrayList<Long>[] c = new ArrayList[3];\n\t\t\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\tc[i] = new ArrayList<>();\n\t\t\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tc[sc.nextInt() - 1].add(sc.nextLong());\n\t\t\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tCollections.sort(c[i], new Comparator<Long>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(Long o1, Long o2) {\n\t\t\t\t\tif(o1 > o2)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\tif(o1 < o2)\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tint p1= 0; int p2 = 0; int p3 = 0;\n\t\tlong ans = 0;\n\t\twhile(max > 0 && (c[0].size() > p1 && max > 0 || c[1].size() > p2 && max > 1 || c[2].size() > p3 && max > 2)) {\n\t\t\tint cur = Math.min(max, 6);\n\t\t\tlong v = 0;\n\t\t\tint a1= 0; int a2 = 0; int a3 = 0;\n\t\t\t\n\t\t\tfor (int i = 0; i <= cur && (i + p1 <= c[0].size() || i == 0); i++) {\n\t\t\t\tfor (int j = 0; j * 2 + i <= cur && (j + p2 <= c[1].size() || j == 0); j++) {\n\t\t\t\t\tint j2 = Math.min((cur - i - j * 2) / 3, c[2].size() - p3);\n\t\t\t\t\tlong a = 0;\n\t\t\t\t\t\n\t\t\t\t\tfor (int k = 0; k < i; k++)\n\t\t\t\t\t\ta += c[0].get(p1 + k);\n\t\t\t\t\tfor (int k = 0; k < j; k++)\n\t\t\t\t\t\ta += c[1].get(p2 + k);\n\t\t\t\t\tfor (int k = 0; k < j2; k++)\n\t\t\t\t\t\ta += c[2].get(p3 + k);\n\t\t\t\t\t\n\t\t\t\t\tif(a >= v) {\n\t\t\t\t\t\ta1 = i; a2 = j; a3 = j2;\n\t\t\t\t\t\tv = a;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += v;\n\t\t\tp1 += a1; p2 += a2; p3 += a3;\n\t\t\tif(max <= 6 || (a1 == 0 && a2 == 0 && a3 == 0)) {\n\t\t\t\tmax -= (a1 + a2 * 2 + a3 * 3);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmax -= (a1 + a2 * 2 + a3 * 3);\n\t\n\t\t}\n\t\t\n\t\t\n\t\tif(p1 > 1 && p2 < c[1].size() && c[0].get(p1 - 1) + c[0].get(p1 - 2) < c[1].get(p2)) {\n\t\t\tans -= (c[0].get(p1 - 1) + c[0].get(p1 - 2));\n\t\t\tans += c[1].get(p2++);\n\t\t\tp1 -= 2;\n\t\t}\n\t\t\n\t\tif(p1 > 2 && p3 < c[2].size() && c[0].get(p1 - 1) + c[0].get(p1 - 2) + c[0].get(p1 - 3) < c[2].get(p3)) {\n\t\t\tans -= (c[0].get(p1 - 1) + c[0].get(p1 - 2) + c[0].get(p1 - 3));\n\t\t\tans += c[2].get(p3++);\n\t\t\tp1 -= 3;\n\t\t}\n\t\t\n\t\tif(p1 > 0 && p2 > 0 && p3 < c[2].size() && c[0].get(p1 - 1) + c[1].get(p2 - 1) < c[2].get(p3)) {\n\t\t\tans -= (c[0].get(p1 - 1) + c[1].get(p2 - 1));\n\t\t\tans += c[2].get(p3++);\n\t\t\tp1--;\n\t\t\tp2--;\n\t\t}\n\t\t\n\t\tif(p1 > 0 && p3 > 0 && p2 < c[1].size() - 1 && c[0].get(p1 - 1) + c[2].get(p3 - 1) < c[1].get(p2) + c[1].get(p2 + 1)) {\n\t\t\tans -= (c[0].get(p1 - 1) + c[2].get(p3 - 1));\n\t\t\tans += c[1].get(p2++);\n\t\t\tans += c[1].get(p2++);\n\t\t\tp1--;\n\t\t\tp3--;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tif(p2 > 1 && p1 < c[0].size() && p3 < c[2].size() && c[1].get(p2 - 1) + c[1].get(p2 - 2) < c[0].get(p1) + c[2].get(p3)) {\n\t\t\tans -= (c[1].get(p2 - 1) + c[1].get(p2 - 2));\n\t\t\tans += c[0].get(p1++);\n\t\t\tans += c[2].get(p3++);\n\t\t\tp2--;\n\t\t\tp2--;\n\t\t}\n\t\t\n\t\tif(p2 > 2 && p3 < c[2].size() - 1 && c[1].get(p2 - 1) + c[1].get(p2 - 2) + c[1].get(p2 - 3) < c[2].get(p3) + c[2].get(p3 + 1)) {\n\t\t\tans -= (c[1].get(p2 - 1) + c[1].get(p2 - 2) + c[1].get(p2 - 3));\n\t\t\tans += c[2].get(p3++);\n\t\t\tans += c[2].get(p3++);\n\t\t\tp2--;\n\t\t\tp2--;\n\t\t\tp2--;\n\t\t}\n\t\t\n\t\tlong o = 0;\n\t\tif(max >= 1) {\n\t\t\tif(p1 > 0 && p2 < c[1].size())\n\t\t\t\to = Math.max(o, c[1].get(p2) - c[0].get(p1 - 1));\n\t\t\t\n\t\t\tif(p1 > 1 && p3 < c[2].size())\n\t\t\t\to = Math.max(o, c[2].get(p3) - c[0].get(p1 - 1) - c[0].get(p1 - 2));\n\t\t\t\n\t\t\tif(p2 > 0 && p3 < c[2].size())\n\t\t\t\to = Math.max(o, c[2].get(p3) - c[1].get(p2 - 1));\n\t\t\t\n\t\t\tif(p3 > 0 && p2 < c[1].size() - 1)\n\t\t\t\to = Math.max(o, c[1].get(p2) + c[1].get(p2 + 1) - c[2].get(p3 - 1));\n\t\t\t\n\t\t}\n\t\tif(max >= 2) {\n\t\t\tif(p1 > 0 && p3 < c[2].size())\n\t\t\t\to = Math.max(o, c[2].get(p3) - c[0].get(p1 - 1));\n\t\t\tif(p2 > 0 && p3 < c[2].size() && p1 < c[0].size())\n\t\t\t\to = Math.max(o, c[0].get(p1) + c[2].get(p3) - c[1].get(p2 - 1));\n\t\t}\n\t\tout.println(ans + o);\n\t\tout.flush();\n\t\tout.close();\n\t}\n\n\tstatic class Scanner \n\t{\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream System){br = new BufferedReader(new InputStreamReader(System));}\n\t\tpublic String next() throws IOException \n\t\t{\n\t\t\twhile (st == null || !st.hasMoreTokens()) \n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tpublic String nextLine()throws IOException{return br.readLine();}\n\t\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n\t\tpublic double nextDouble() throws IOException {return Double.parseDouble(next());}\n\t\tpublic char nextChar()throws IOException{return next().charAt(0);}\n\t\tpublic Long nextLong()throws IOException{return Long.parseLong(next());}\n\t\tpublic boolean ready() throws IOException{return br.ready();}\n\t\tpublic void waitForInput(){for(long i = 0; i < 3e9; i++);}\n\t}\n}"
        },
        {
            "language": 3,
            "solution": "import sys\nimport bisect\nfrom bisect import bisect_left as lb\ninput_=lambda: sys.stdin.readline().strip(\"\\r\\n\")\nfrom math import log\nfrom math import gcd\nfrom math import atan2,acos\nfrom random import randint\nsa=lambda :input_()\nsb=lambda:int(input_())\nsc=lambda:input_().split()\nsd=lambda:list(map(int,input_().split()))\nsflo=lambda:list(map(float,input_().split()))\nse=lambda:float(input_())\nsf=lambda:list(input_())\nflsh=lambda: sys.stdout.flush()\n#sys.setrecursionlimit(10**6)\nmod=10**9+7\nmod1=998244353\ngp=[]\ncost=[]\ndp=[]\nmx=[]\nans1=[]\nans2=[]\nspecial=[]\nspecnode=[]\na=0\nkthpar=[]\ndef dfs(root,par):\n    if par!=-1:\n        dp[root]=dp[par]+1\n    for i in range(1,20):\n        if kthpar[root][i-1]!=-1:\n            kthpar[root][i]=kthpar[kthpar[root][i-1]][i-1]\n    for child in gp[root]:\n        if child==par:continue\n        kthpar[child][0]=root\n        dfs(child,root)\nans=0\nb=[]\n\n    \ndef hnbhai(tc):\n    n,m=sd()\n    dp=[(0,0,0) for i in range(m+3)]\n    gp=[[] for i in range(4)]\n    for i in range(n):\n        w,c=sd()\n        gp[w].append(c)\n    gp[1].sort(reverse=True)\n    gp[2].sort(reverse=True)\n    gp[3].sort(reverse=True)\n    for i in range(0,m+1):\n        one=dp[i][1]\n        two=dp[i][2]\n        if one<len(gp[1]):\n            if dp[i+1][0]<dp[i][0]+gp[1][one]:\n                dp[i+1]=(dp[i][0]+gp[1][one],one+1,two)\n        if two<len(gp[2]):\n            dp[i+2]=(dp[i][0]+gp[2][two],one,two+1)\n    for i in range(1,m+1):\n        dp[i]=max(dp[i-1],dp[i])\n    #print(dp)\n    ans=dp[m][0]\n    tot=0\n    for i in range(len(gp[3])+1):\n        if 3*i<=m:\n            ans=max(dp[m-3*(i)][0]+tot,ans)\n            if i<len(gp[3]):\n                tot+=gp[3][i]\n    print(ans)\nfor _ in range(1):\n    hnbhai(_+1)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct triple {\n  int t[3] = {0, 0, 0};\n  long long sum = 0;\n};\nlong long val[4][100010];\nint cnt[4];\ntriple dp[300010];\nvoid calc_dp(int x);\nint main() {\n  int n, m;\n  cin >> n >> m;\n  while (n--) {\n    int c, w;\n    cin >> w >> c;\n    val[w][cnt[w]++] = c;\n  }\n  for (int i(1); i <= 3; i++)\n    sort(val[i], val[i] + cnt[i], [](int a, int b) { return a > b; });\n  long long ans(0);\n  for (int i(1); i <= m; i++) {\n    calc_dp(i);\n    ans = max(ans, dp[i].sum);\n  }\n  long long sp(0);\n  for (int i(1); 3 * i <= m && i <= cnt[3]; i++) {\n    sp += val[3][i - 1];\n    ans = max(ans, sp + dp[m - 3 * i].sum);\n  }\n  cout << ans;\n  return 0;\n}\nvoid calc_dp(int x) {\n  dp[x] = dp[x - 1];\n  for (int i(1); i <= 2; i++) {\n    if (x - i >= 0 && dp[x - i].t[i] < cnt[i] &&\n        dp[x - i].sum + val[i][dp[x - i].t[i]] > dp[x].sum) {\n      dp[x] = dp[x - i];\n      dp[x].sum += val[i][dp[x].t[i]];\n      dp[x].t[i]++;\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1e17L;\nconst int inf = 0x3f3f3f3f;\nconst int maxn = 1e5 + 5;\nconst int Mod = 1e9 + 7;\nstruct Souvenirs {\n  int w, c;\n  bool friend operator<(Souvenirs x, Souvenirs y) {\n    return ((double)x.c / x.w) > ((double)y.c / y.w);\n  }\n} a[maxn];\nint n, m;\nlong long dp[3 * maxn];\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%d%d\", &a[i].w, &a[i].c);\n  sort(a + 1, a + n + 1);\n  for (int i = 1; i <= m; i++) dp[i] = -INF;\n  dp[0] = 0;\n  int up = 0;\n  long long ans = 0;\n  for (int i = 1; i <= n; i++) {\n    up += a[i].w;\n    if (up > m) up = m;\n    int least = max(a[i].w, up - 6);\n    for (int j = up; j >= least; j--) {\n      dp[j] = max(dp[j], dp[j - a[i].w] + a[i].c);\n      ans = max(ans, dp[j]);\n    }\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\ninline T abs(T t) {\n  return t < 0 ? -t : t;\n}\nconst long long modn = 1000000007;\ninline long long mod(long long x) { return x % modn; }\nconst int MAXN = 312345;\nint n, m;\nvector<long long> s[4];\nstruct pd {\n  long long x;\n  int i[3];\n  pd(long long xx, int ii, int iii) {\n    x = xx;\n    i[1] = ii;\n    i[2] = iii;\n  }\n  pd() {}\n  bool operator<(const struct pd &o) const {\n    return (x < o.x || (x == o.x && i[1] < o.i[1]));\n  }\n} dp[MAXN];\nbool cmp(int a, int b) { return a > b; }\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  long long res = 0;\n  for (int a = 0; a < n; a++) {\n    long long w, val;\n    scanf(\"%lld %lld\", &w, &val);\n    s[w].push_back(val);\n    if (w == 3) res += val;\n  }\n  for (int i = 1; i <= 3; i++) sort(s[i].begin(), s[i].end(), cmp);\n  dp[0] = (pd){0, 0, 0};\n  for (int i = 0; i < m; i++) {\n    dp[i + 1] = max(dp[i], dp[i + 1]);\n    if (dp[i].i[1] != s[1].size())\n      dp[i + 1] = max(dp[i + 1], pd(dp[i].x + s[1][dp[i].i[1]], dp[i].i[1] + 1,\n                                    dp[i].i[2]));\n    if (dp[i].i[2] != s[2].size())\n      dp[i + 2] = max(dp[i + 2], pd(dp[i].x + s[2][dp[i].i[2]], dp[i].i[1],\n                                    dp[i].i[2] + 1));\n    ;\n  }\n  int i = 0, j = 0;\n  long long ans = 0;\n  for (int k = s[3].size(); k >= 0; k--) {\n    if (m < 3 * k) {\n      if (k > 0) {\n        res -= s[3][k - 1];\n      }\n      continue;\n    }\n    int sob = m - 3 * k;\n    ans = max(ans, res + dp[sob].x);\n    if (k > 0) res -= s[3][k - 1];\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Node {\n  long long val;\n  int a, b;\n} dp[310000];\nvector<int> w1, w2, w3;\nlong long s[110000];\nint n, m;\nbool cmp(int a, int b) { return a > b; }\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    if (x == 1) w1.push_back(y);\n    if (x == 2) w2.push_back(y);\n    if (x == 3) w3.push_back(y);\n  }\n  sort(w1.begin(), w1.end(), cmp);\n  sort(w2.begin(), w2.end(), cmp);\n  sort(w3.begin(), w3.end(), cmp);\n  for (int i = 0; i < w3.size(); i++) s[i + 1] = s[i] + w3[i];\n  dp[0].val = dp[0].a = dp[0].b = 0;\n  long long ans = -1e16;\n  for (int i = 1; i <= m; i++) {\n    dp[i] = dp[i - 1];\n    int a = dp[i - 1].a;\n    if (a < w1.size() && dp[i - 1].val + w1[a] > dp[i].val) {\n      dp[i].val = dp[i - 1].val + w1[a];\n      dp[i].a++;\n    }\n    if (i > 1) {\n      int b = dp[i - 2].b;\n      if (i > 1 && b < w2.size() && dp[i - 2].val + w2[b] > dp[i].val) {\n        dp[i] = dp[i - 2];\n        dp[i].b++;\n        dp[i].val = dp[i - 2].val + w2[b];\n      }\n    }\n    ans = max(ans, dp[i].val +\n                       s[min((int)w3.size(), (m - dp[i].a - 2 * dp[i].b) / 3)]);\n  }\n  ans = max(\n      ans, dp[0].val + s[min((int)w3.size(), (m - dp[0].a - 2 * dp[0].b) / 3)]);\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline char nc() {\n  static char buf[100000], *p1 = buf, *p2 = buf;\n  return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2)\n             ? EOF\n             : *p1++;\n}\ninline void read(int &x) {\n  char c = nc(), b = 1;\n  for (; !(c >= '0' && c <= '9'); c = nc())\n    if (c == '-') b = -1;\n  for (x = 0; c >= '0' && c <= '9'; x = x * 10 + c - '0', c = nc())\n    ;\n  x *= b;\n}\nint n, m, maxc;\nvector<long long> a[305];\nlong long f[2][300005];\nint x, b, t;\ninline void Solve(int l, int r, int al, int ar) {\n  if (l > r) return;\n  int i = (l + r) >> 1, d = i;\n  f[t ^ 1][i * x + b] = f[t][i * x + b];\n  for (int j = min(ar, i - 1); j >= al; j--) {\n    if (i - j > (int)a[x].size()) break;\n    if (f[t][j * x + b] + a[x][i - j - 1] > f[t ^ 1][i * x + b])\n      f[t ^ 1][i * x + b] = f[t][j * x + b] + a[x][i - j - 1], d = j;\n  }\n  Solve(l, i - 1, al, d);\n  Solve(i + 1, r, d, ar);\n}\nint main() {\n  int _x, _y;\n  read(n);\n  read(m);\n  for (int i = 1; i <= n; i++)\n    read(_x), read(_y), a[_x].push_back(_y), maxc = max(maxc, _x);\n  for (int i = 1; i <= maxc; i++) {\n    sort(a[i].begin(), a[i].end(), greater<int>());\n    for (int j = 1; j < (int)a[i].size(); j++) a[i][j] += a[i][j - 1];\n  }\n  t = 0;\n  for (x = 1; x <= maxc; x++) {\n    if (a[x].size() == 0) continue;\n    for (b = 0; b < x; b++) {\n      Solve(0, (m - b) / x, 0, (m - b) / x);\n    }\n    for (int j = 1; j <= m; j++)\n      f[t ^ 1][j] = max(f[t ^ 1][j], f[t ^ 1][j - 1]);\n    t ^= 1;\n  }\n  long long ans = 0;\n  for (int i = 1; i <= m; i++) ans = max(ans, f[t][i]);\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 3e5 + 100;\nint N, M;\nvector<int> v[5];\nconst long long INF = 1e18;\nlong long dp[MAXN];\nint ptr[MAXN][2];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cin >> N >> M;\n  for (int i = 0; i < N; i++) {\n    int w, c;\n    cin >> w >> c;\n    w--;\n    v[w].push_back(c);\n  }\n  for (int i = 0; i < 3; i++) sort(v[i].begin(), v[i].end(), greater<int>());\n  for (int i = 0; i <= M; i++) {\n    if (ptr[i][0] < v[0].size() && dp[i] + v[0][ptr[i][0]] > dp[i + 1]) {\n      dp[i + 1] = dp[i] + v[0][ptr[i][0]];\n      ptr[i + 1][0] = ptr[i][0] + 1;\n      ptr[i + 1][1] = ptr[i][1];\n    }\n    if (ptr[i][1] < v[1].size() && dp[i] + v[1][ptr[i][1]] > dp[i + 2]) {\n      dp[i + 2] = dp[i] + v[1][ptr[i][1]];\n      ptr[i + 2][0] = ptr[i][0];\n      ptr[i + 2][1] = ptr[i][1] + 1;\n    }\n    if (dp[i] > dp[i + 1]) {\n      dp[i + 1] = dp[i];\n      ptr[i + 1][0] = ptr[i][0];\n      ptr[i + 1][1] = ptr[i][1];\n    }\n  }\n  long long ans = dp[M], cost = 0;\n  for (int i = 1; i <= v[2].size(); i++) {\n    int w = M - 3 * i;\n    if (w < 0) break;\n    cost += v[2][i - 1];\n    ans = max(ans, cost + dp[w]);\n  }\n  cout << ans << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct str {\n  long long sum, tp1, tp2;\n};\nlong long n, m, ans, sum[300100];\nstr dp[300100];\nvector<long long> v[4];\nbool comp(long long x, long long y) { return x > y; }\nint main() {\n  cin >> n >> m;\n  for (int i = 0; i < n; ++i) {\n    long long type, x;\n    scanf(\"%lld%lld\", &type, &x);\n    v[type].push_back(x);\n  }\n  sort(v[1].begin(), v[1].end(), comp);\n  sort(v[2].begin(), v[2].end(), comp);\n  sort(v[3].begin(), v[3].end(), comp);\n  for (int i = 1; i <= (int)v[3].size(); ++i) sum[i] = sum[i - 1] + v[3][i - 1];\n  for (int i = 1; i <= m; ++i) {\n    if (i == 1) {\n      if (!v[1].empty()) dp[i] = {v[1][0], 1, 0};\n      continue;\n    }\n    dp[i] = (dp[i - 2].sum > dp[i - 1].sum ? dp[i - 2] : dp[i - 1]);\n    if (v[1].size() > dp[i - 1].tp1 &&\n        dp[i - 1].sum + v[1][dp[i - 1].tp1] > dp[i].sum)\n      dp[i] = {dp[i - 1].sum + v[1][dp[i - 1].tp1], dp[i - 1].tp1 + 1,\n               dp[i - 1].tp2};\n    if (v[2].size() > dp[i - 2].tp2 &&\n        dp[i - 2].sum + v[2][dp[i - 2].tp2] > dp[i].sum)\n      dp[i] = {dp[i - 2].sum + v[2][dp[i - 2].tp2], dp[i - 2].tp1,\n               dp[i - 2].tp2 + 1};\n  }\n  for (int i = 0; i * 3 <= m; ++i) ans = max(ans, sum[i] + dp[m - i * 3].sum);\n  cout << ans;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\n@SuppressWarnings(\"unchecked\")\npublic class P808E {\n\n  final static int DIST = 10;\n\n  public void run() throws Exception {\n    int n = nextInt(), m = nextInt();\n    int [][] wca = new int [n][2];\n    int l1 = 0, l2 = 0, l3 = 0;\n    for (int i = 0; i < n; i++) {\n      wca[i] = readInt(2);\n      if (wca[i][0] == 1) {\n        l1++;\n      } else if (wca[i][0] == 2) {\n        l2++;\n      } else {\n        l3++;\n      }\n    }\n\n    Arrays.sort(wca, new Comparator<int []>() {\n      public int compare(int [] a, int [] b) {\n        return (b[1] - a[1]);\n      }\n    });\n\n    int [] c1 = new int [l1], c2 = new int [l2], c3 = new int [l3];\n    int i1 = 0, i2 = 0, i3 = 0;\n    for (int [] wc : wca) {\n      if (wc[0] == 1) {\n        c1[i1++] = wc[1];\n      } else if (wc[0] == 2) {\n        c2[i2++] = wc[1];\n      } else {\n        c3[i3++] = wc[1];\n      }\n    }\n\n    int mm = m;\n    i1 = i2 = i3 = 0;\n    while (true) {\n      int k1 = ((i1 < l1) && (mm >= 1)) ? c1[i1] : 0;\n      int k2 = ((i2 < l2) && (mm >= 2)) ? c2[i2] : 0;\n      int k3 = ((i3 < l3) && (mm >= 3)) ? c3[i3] : 0;\n\n      if ((k1 | k2 | k3) == 0) {\n        break;\n      } else if ((2.0 * k1 >= k2) && (3.0 * k1 >= k3)) {\n        i1++;\n        mm -= 1;\n      } else if ((k2 >= 2.0 * k1) && (3.0 * k2 >= 2.0 * k3)) {\n        i2++;\n        mm -= 2;\n      } else {\n        i3++;\n        mm -= 3;\n      }\n    }\n\n    long [] s1 = new long [l1 + 1], s2 = new long [l2 + 1], s3 = new long [l3 + 1];\n    for (int i = 0; i < l1; s1[i + 1] = c1[i] + s1[i], i++);\n    for (int i = 0; i < l2; s2[i + 1] = c2[i] + s2[i], i++);\n    for (int i = 0; i < l3; s3[i + 1] = c3[i] + s3[i], i++);\n\n    long s = 0;\n    for (int d1 = -DIST; d1 <= DIST; d1++) {\n      for (int d2 = -DIST; d2 <= DIST; d2++) {\n        for (int d3 = -DIST; d3 <= DIST; d3++) {\n          int j1 = i1 + d1, j2 = i2 + d2, j3 = i3 + d3;\n\n          if ((j1 >= 0) && (j2 >= 0) && (j3 >= 0) &&\n              (j1 <= l1) && (j2 <= l2) && (j3 <= l3) &&\n              ((j1 + 2 * j2 + 3 * j3) <= m)) {\n            s = Math.max(s, s1[j1] + s2[j2] + s3[j3]);\n          }\n        }\n      }\n    }\n\n    println(s);\n  }\n\n  public static void main(String... args) throws Exception {\n    br = new BufferedReader(new InputStreamReader(System.in));\n    pw = new PrintWriter(new BufferedOutputStream(System.out));\n    new P808E().run();\n    br.close();\n    pw.close();\n    System.err.println(\"\\n[Time : \" + (System.currentTimeMillis() - startTime) + \" ms]\");\n  }\n\n  static long startTime = System.currentTimeMillis();\n  static BufferedReader br;\n  static PrintWriter pw;\n  StringTokenizer stok;\n\n  String nextToken() throws IOException {\n    while (stok == null || !stok.hasMoreTokens()) {\n      String s = br.readLine();\n      if (s == null) { return null; }\n      stok = new StringTokenizer(s);\n    }\n    return stok.nextToken();\n  }\n\n  void print(byte b) { print(\"\" + b); }\n  void print(int i) { print(\"\" + i); }\n  void print(long l) { print(\"\" + l); }\n  void print(double d) { print(\"\" + d); }\n  void print(char c) { print(\"\" + c); }\n  void print(Object o) {\n    if (o instanceof int[]) { print(Arrays.toString((int [])o));\n    } else if (o instanceof long[]) { print(Arrays.toString((long [])o));\n    } else if (o instanceof char[]) { print(Arrays.toString((char [])o));\n    } else if (o instanceof byte[]) { print(Arrays.toString((byte [])o));\n    } else if (o instanceof short[]) { print(Arrays.toString((short [])o));\n    } else if (o instanceof boolean[]) { print(Arrays.toString((boolean [])o));\n    } else if (o instanceof float[]) { print(Arrays.toString((float [])o));\n    } else if (o instanceof double[]) { print(Arrays.toString((double [])o));\n    } else if (o instanceof Object[]) { print(Arrays.toString((Object [])o));\n    } else { print(\"\" + o); }\n  }\n  void print(String s) { pw.print(s); }\n  void println() { println(\"\"); }\n  void println(byte b) { println(\"\" + b); }\n  void println(int i) { println(\"\" + i); }\n  void println(long l) { println(\"\" + l); }\n  void println(double d) { println(\"\" + d); }\n  void println(char c) { println(\"\" + c); }\n  void println(Object o) { print(o); println(); }\n  void println(String s) { pw.println(s); }\n  int nextInt() throws IOException { return Integer.parseInt(nextToken()); }\n  long nextLong() throws IOException { return Long.parseLong(nextToken()); }\n  double nextDouble() throws IOException { return Double.parseDouble(nextToken()); }\n  char nextChar() throws IOException { return (char) (br.read()); }\n  String next() throws IOException { return nextToken(); }\n  String nextLine() throws IOException { return br.readLine(); }\n  int [] readInt(int size) throws IOException {\n    int [] array = new int [size];\n    for (int i = 0; i < size; i++) { array[i] = nextInt(); }\n    return array;\n  }\n  long [] readLong(int size) throws IOException {\n    long [] array = new long [size];\n    for (int i = 0; i < size; i++) { array[i] = nextLong(); }\n    return array;\n  }\n  double [] readDouble(int size) throws IOException {\n    double [] array = new double [size];\n    for (int i = 0; i < size; i++) { array[i] = nextDouble(); }\n    return array;\n  }\n  String [] readLines(int size) throws IOException {\n    String [] array = new String [size];\n    for (int i = 0; i < size; i++) { array[i] = nextLine(); }\n    return array;\n  }\n\n  int gcd(int a, int b) {\n    return ((b > 0) ? gcd(b, a % b) : a);\n  }\n  long gcd(long a, long b) {\n    return ((b > 0) ? gcd(b, a % b) : a);\n  }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool func(const pair<long long, long long> &a,\n          const pair<long long, long long> &b) {\n  return a.second < b.second;\n}\nlong long int power(long long int x, long long int y) {\n  if (y == 0)\n    return 1;\n  else if (y % 2 == 0)\n    return ((power(x, y / 2) % 1000000007) * (power(x, y / 2) % 1000000007) %\n            1000000007);\n  else\n    return (x * ((power(x, y / 2) % 1000000007) *\n                 (power(x, y / 2) % 1000000007) % 1000000007)) %\n           1000000007;\n}\nlong long int modInverse(long long int a, long long int m) {\n  long long int m0 = m;\n  long long int y = 0, x = 1;\n  if (m == 1) return 0;\n  while (a > 1) {\n    long long int q = a / m;\n    long long int t = m;\n    m = a % m, a = t;\n    t = y;\n    y = x - q * y;\n    x = t;\n  }\n  if (x < 0) x += m0;\n  return x;\n}\nbool cmp(int x, int y) { return x > y; }\nconst int N = 1e5 + 9;\nconst int M = 3e5 + 9;\nstruct Triple {\n  long long int cost;\n  int cnt1, cnt2, cnt3;\n} dp[M];\nint n, m;\nlong long int sum3[N];\nvector<int> c[4];\nvoid solve(int t) {\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    int weight, cost;\n    cin >> weight >> cost;\n    c[weight].push_back(cost);\n  }\n  sort(c[1].begin(), c[1].end(), cmp);\n  sort(c[2].begin(), c[2].end(), cmp);\n  sort(c[3].begin(), c[3].end(), cmp);\n  dp[0].cost = 0;\n  dp[0].cnt1 = 0;\n  dp[0].cnt2 = 0;\n  dp[0].cnt3 = 0;\n  for (int i = 0; i <= m; i++) {\n    dp[i].cost = 0;\n  }\n  for (int i = 1; i <= m; i++) {\n    if (dp[i - 1].cnt1 < c[1].size() &&\n        dp[i - 1].cost + c[1][dp[i - 1].cnt1] > dp[i].cost) {\n      dp[i].cost = dp[i - 1].cost + c[1][dp[i - 1].cnt1];\n      dp[i].cnt1 = dp[i - 1].cnt1 + 1;\n      dp[i].cnt2 = dp[i - 1].cnt2;\n      dp[i].cnt3 = dp[i - 1].cnt3;\n    }\n    if (i >= 2 && dp[i - 2].cnt2 < c[2].size() &&\n        dp[i - 2].cost + c[2][dp[i - 2].cnt2] > dp[i].cost) {\n      dp[i].cost = dp[i - 2].cost + c[2][dp[i - 2].cnt2];\n      dp[i].cnt1 = dp[i - 2].cnt1;\n      dp[i].cnt2 = dp[i - 2].cnt2 + 1;\n      dp[i].cnt3 = dp[i - 2].cnt3;\n    }\n    if (i >= 3 && dp[i - 3].cnt3 < c[3].size() &&\n        dp[i - 3].cost + c[3][dp[i - 3].cnt3] > dp[i].cost) {\n      dp[i].cost = dp[i - 3].cost + c[3][dp[i - 3].cnt3];\n      dp[i].cnt1 = dp[i - 3].cnt1;\n      dp[i].cnt2 = dp[i - 3].cnt2;\n      dp[i].cnt3 = dp[i - 3].cnt3 + 1;\n    }\n    if (dp[i - 2].cnt1 > 0 && dp[i - 2].cnt3 < c[3].size() &&\n        dp[i - 2].cost - c[1][dp[i - 2].cnt1 - 1] + c[3][dp[i - 2].cnt3] >\n            dp[i].cost) {\n      dp[i].cost =\n          dp[i - 2].cost - c[1][dp[i - 2].cnt1 - 1] + c[3][dp[i - 2].cnt3];\n      dp[i].cnt1 = dp[i - 2].cnt1 - 1;\n      dp[i].cnt2 = dp[i - 2].cnt2;\n      dp[i].cnt3 = dp[i - 2].cnt3 + 1;\n    }\n    if (i >= 1 && dp[i - 1].cost > dp[i].cost) dp[i] = dp[i - 1];\n    if (i >= 2 && dp[i - 2].cost > dp[i].cost) dp[i] = dp[i - 2];\n    if (i >= 3 && dp[i - 3].cost > dp[i].cost) dp[i] = dp[i - 3];\n  }\n  long long int res = dp[m].cost;\n  cout << res;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t, tmp = 0;\n  t = 1;\n  while (tmp++ < t) {\n    solve(tmp - 1);\n    if (t - tmp) cout << \"\\n\";\n  }\n  cerr << \"Time : \" << (double)clock() / (double)CLOCKS_PER_SEC << \"s\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n, m = map(int, input().split())\nd = [[] for i in range(3)]\nres_odd = 0\nres_even = 0\nfor i in range(n):\n    t1, t2 = map(int, input().split())\n    d[t1 - 1].append(t2)\nd[0].sort()\nd[2].sort(reverse=True)\nc = d[1].copy()\nif d[0]:\n    i = len(d[0]) - 2\n    while i >= 1:\n        c.append(d[0][i] + d[0][i - 1])\n        i -= 2\n    c.sort(reverse=True)\n    pref = [0 for i in range(len(c) + 1)]\n    pref[0] = 0\n    for i in range(1, len(c) + 1):\n        pref[i] = pref[i - 1] + c[i - 1]\n    p = 0\n    for i in range(min(len(d[2]), (m - 1) // 3) + 1):\n        if i != 0:\n            p += d[2][i - 1]\n        res_odd = max(res_odd, d[0][-1] + p + pref[min(max(m - i * 3 - 1, 0) // 2, len(pref) - 1)])\ni = len(d[0]) - 1\nwhile i >= 1:\n    d[1].append(d[0][i] + d[0][i - 1])\n    i -= 2\nd[1].sort(reverse=True)\npref = [0 for i in range(len(d[1]) + 1)]\npref[0] = 0\nfor i in range(1, len(d[1]) + 1):\n    pref[i] = pref[i - 1] + d[1][i - 1]\np = 0\nfor i in range(min(len(d[2]), m // 3) + 1):\n    if i != 0:\n        p += d[2][i - 1]\n    res_even = max(res_even, p + pref[min(max(m - i * 3, 0) // 2, len(pref) - 1)])\nprint(max(res_odd, res_even))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long> sp[4];\nstruct node {\n  long long b1, b2, val;\n} dp[300005];\nlong long cal(long long t, long long k) {\n  if (k >= sp[t].size()) return 0;\n  return sp[t][k];\n}\nbool cmp(long long a, long long b) { return a > b; }\nint main() {\n  long long n, m, i, j, w, c;\n  scanf(\"%lld%lld\", &n, &m);\n  for (i = 1; i <= n; i++) {\n    scanf(\"%lld%lld\", &w, &c);\n    sp[w].push_back(c);\n  }\n  sort(sp[1].begin(), sp[1].end(), cmp);\n  sort(sp[2].begin(), sp[2].end(), cmp);\n  sort(sp[3].begin(), sp[3].end(), cmp);\n  dp[1] = (node){1, 0, cal(1, 0)};\n  for (i = 2; i <= m; i++) {\n    if (dp[i - 2].val + cal(2, dp[i - 2].b2) >\n        dp[i - 1].val + cal(1, dp[i - 1].b1))\n      dp[i] = (node){dp[i - 2].b1, dp[i - 2].b2 + 1,\n                     dp[i - 2].val + cal(2, dp[i - 2].b2)};\n    else\n      dp[i] = (node){dp[i - 1].b1 + 1, dp[i - 1].b2,\n                     dp[i - 1].val + cal(1, dp[i - 1].b1)};\n  }\n  long long ans = 0, now = 0;\n  for (i = 0; i * 3 <= m; i++) {\n    ans = max(ans, now + dp[m - i * 3].val);\n    now += cal(3, i);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 300010;\nint n, m;\nvector<int> ar1, ar2, ar3;\nlong long sum1[MAXN], sum2[MAXN], sum3[MAXN];\nlong long ans = 0;\nlong long f(int x, int k) { return sum2[x] + sum1[k - 2 * x]; }\nlong long get(int k) {\n  if (!k) return 0;\n  int lo = 0, hi = k / 2;\n  while (lo < hi) {\n    int mid = lo + (hi - lo) / 2;\n    long long a = f(mid, k);\n    long long b = f(mid + 1, k);\n    if (lo == hi - 1) return max(a, b);\n    if (a == b) return a;\n    if (a > b)\n      hi = mid;\n    else\n      lo = mid;\n  }\n  return f(lo, k);\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; i++) {\n    int w, c;\n    scanf(\"%d%d\", &w, &c);\n    (w == 1 ? ar1 : (w == 2 ? ar2 : ar3)).push_back(c);\n  }\n  sort(ar1.begin(), ar1.end(), greater<int>());\n  sort(ar2.begin(), ar2.end(), greater<int>());\n  sort(ar3.begin(), ar3.end(), greater<int>());\n  for (int i = 0; i < ar1.size(); i++) {\n    sum1[i + 1] = ar1[i];\n    if (i) sum1[i + 1] += sum1[i];\n  }\n  for (int i = 0; i < ar2.size(); i++) {\n    sum2[i + 1] = ar2[i];\n    if (i) sum2[i + 1] += sum2[i];\n  }\n  for (int i = 0; i < ar3.size(); i++) {\n    sum3[i + 1] = ar3[i];\n    if (i) sum3[i + 1] += sum3[i];\n  }\n  for (int i = 1; i <= m; i++) {\n    if (!sum1[i]) sum1[i] = sum1[i - 1];\n    if (!sum2[i]) sum2[i] = sum2[i - 1];\n    if (!sum3[i]) sum3[i] = sum3[i - 1];\n  }\n  for (int i = 0; 3 * i <= m && i <= ar3.size(); i++) {\n    long long cur = (i > 0 ? sum3[i] : 0);\n    cur += get(m - 3 * i);\n    ans = max(ans, cur);\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 3,
            "solution": "def main():\n    n, m = map(int, input().split())\n\n    cost1 = []\n    cost2 = []\n    cost3 = []\n\n    for i in range(n):\n        w, c = map(int, input().split())\n        if w == 1:\n            cost1.append(c)\n        elif w == 2:\n            cost2.append(c)\n        else:\n            cost3.append(c)\n\n    cost1 = sorted(cost1)[::-1]\n    cost2 = sorted(cost2)[::-1]\n    cost3 = sorted(cost3)[::-1]\n    cost3_prefix = [0]\n    for c in cost3:\n        cost3_prefix.append(cost3_prefix[-1] + c)\n\n\n    dp = [(0, 0, 0)] * (m + 1)\n    dp[0] = (0, 0, 0)\n\n    for i in range(0, m):\n        cost, n1, n2 = dp[i]\n\n        if i + 1 <= m and n1 < len(cost1):\n            new_cost = cost + cost1[n1]\n            if dp[i + 1][0] < new_cost:\n                dp[i + 1] = (new_cost, n1 + 1, n2)\n        \n        if i + 2 <= m and n2 < len(cost2):\n            new_cost = cost + cost2[n2]\n            if dp[i + 2][0] < new_cost:\n                dp[i + 2] = (new_cost, n1, n2 + 1)\n\n        if n1 == len(cost1) and n2 == len(cost2):\n            break\n\n\n    dp_prefix = [0]\n    for x in dp[1:]:\n        dp_prefix.append(max(dp_prefix[-1], x[0]))\n\n    ans = 0\n    for k in range(len(cost3) + 1):\n        l = m - 3 * k\n        if l < 0:\n            continue\n\n        new_ans = cost3_prefix[k] + dp_prefix[l]\n        ans = max(new_ans, ans)\n\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long dp[1010000];\nvector<int> vas[300 + 1];\nlong long sums[1010000 + 1];\nint cnts[1010000 + 1];\nlong long* sum[300 + 1];\nbool cmp(int a, int b) { return a > b; }\nint s1[1010000];\nint s1_cnt = -1;\nlong long so[1010000];\nint nowva;\ninline void solve(int l1, int r1, int l2, int r2) {\n  if (l1 > r1 || l2 > r2) return;\n  int mid = (l1 + r1) >> 1;\n  int p = 0;\n  for (int i = max(l2, mid - cnts[nowva]); i <= min(r2, mid); ++i) {\n    long long va = dp[s1[i]] + sum[nowva][mid - i];\n    if (va > so[mid]) so[mid] = va, p = i;\n  }\n  solve(l1, mid - 1, l2, p);\n  solve(mid + 1, r1, p, r2);\n}\nint n, k, c, v;\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d%d\", &c, &v);\n    vas[c].push_back(v);\n  }\n  for (int i = 1; i <= 300; ++i) sort(vas[i].begin(), vas[i].end(), cmp);\n  sum[1] = sums;\n  for (int i = 1; i <= 300; ++i) {\n    cnts[i] = vas[i].size();\n    if (cnts[i]) sum[i][1] = vas[i][0];\n    for (int j = 2; j <= cnts[i]; ++j) {\n      sum[i][j] = sum[i][j - 1] + vas[i][j - 1];\n    }\n    sum[i + 1] = sum[i] + cnts[i] + 1;\n  }\n  for (int i = 1; i <= 300; ++i) {\n    nowva = i;\n    if (!cnts[i]) continue;\n    for (int j = 0; j < i; ++j) {\n      s1_cnt = -1;\n      for (int l = j; l <= k; l += i) s1[++s1_cnt] = l, so[s1_cnt] = 0;\n      if (s1_cnt >= 1) solve(1, s1_cnt, 0, s1_cnt);\n      for (int l = 1; l <= s1_cnt; ++l) dp[j + l * i] = so[l];\n    }\n  }\n  printf(\"%lld\\n\", dp[k]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\npriority_queue<int> q[4];\nint n, m;\nlong long f[4][300003];\nvoid FoehnDestruct() {\n  int k = q[1].size();\n  for (int i = 1; i <= k && i <= m; i++) {\n    f[1][i] = f[1][i - 1] + q[1].top();\n    q[1].pop();\n  }\n  for (int i = k + 1; i <= m; i++) f[1][i] = f[1][i - 1];\n}\nvoid LightningStorm() {\n  int k = q[2].size();\n  long long c, l = 1, sum = 0, t = 0;\n  for (int i = 1; i <= k && i <= m; i++) {\n    c = q[2].top();\n    q[2].pop();\n    for (int j = l; j <= m; j++) {\n      l = j;\n      if (j >= 2 * (t + 1) &&\n          f[1][j - t * 2] + sum < f[1][j - t * 2 - 2] + sum + c) {\n        f[2][j] = sum + c + f[1][j - t * 2 - 2];\n        t++;\n        sum += c;\n        break;\n      } else {\n        f[2][j] = sum + f[1][j - t * 2];\n      }\n    }\n  }\n  for (int j = l; j <= m; j++) {\n    f[2][j] = sum + f[1][j - t * 2];\n  }\n}\nvoid DominatorControll() {\n  long long sum = 0, t = 0;\n  f[3][m] = f[2][m];\n  while (q[3].size()) {\n    t += 3;\n    sum += q[3].top();\n    q[3].pop();\n    if (t <= m) {\n      f[3][m] = max(f[3][m], f[2][m - t] + sum);\n    }\n  }\n}\nvoid MODEV() {\n  long long x = ~f[3][m] != -1 ? f[3][m] : 0;\n  cout << x;\n  return;\n}\nvoid Mental_Omega(int O) {\n  if (~O == -1) MODEV();\n}\nvoid NuclearMark() {\n  for (int i = 10; ~i; i--) Mental_Omega(i);\n  return;\n}\nint main() {\n  cin >> n >> m;\n  int mm, c;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d%d\", &mm, &c);\n    if (mm == 1)\n      q[1].push(c);\n    else if (mm == 2)\n      q[2].push(c);\n    else\n      q[3].push(c);\n  }\n  FoehnDestruct();\n  LightningStorm();\n  DominatorControll();\n  NuclearMark();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nlong long int memo[300005];\nlong long int sum[300005][3];\nvector<int> v[4];\nint first[300005];\nint second[300005];\nint main() {\n  ios_base::sync_with_stdio(0);\n  int n, m;\n  int w, c;\n  while (cin >> n >> m) {\n    for (int i = 0; i < n; ++i) {\n      cin >> w >> c;\n      v[w].push_back(c);\n    }\n    for (int i = 1; i <= 3; ++i) sort(v[i].rbegin(), v[i].rend());\n    memset(sum, 0, sizeof(sum));\n    for (int i = 0; i < 3; ++i) {\n      for (int j = 1; j <= m; ++j) {\n        sum[j][i] = sum[j - 1][i];\n        if (j <= v[i + 1].size()) sum[j][i] = v[i + 1][j - 1] + sum[j - 1][i];\n      }\n    }\n    memset(memo, 0, sizeof(memo));\n    memset(first, 0, sizeof(first));\n    memset(second, 0, sizeof(second));\n    memo[1] = sum[1][0];\n    first[1] = 1;\n    for (int j = 2; j <= m; ++j) {\n      if (sum[first[j - 1] + 1][0] + sum[second[j - 1]][1] >\n          sum[first[j - 2]][0] + sum[second[j - 2] + 1][1]) {\n        first[j] = first[j - 1] + 1;\n        second[j] = second[j - 1];\n        memo[j] = sum[first[j]][0] + sum[second[j - 1]][1];\n      } else {\n        first[j] = first[j - 2];\n        second[j] = second[j - 2] + 1;\n        memo[j] = sum[first[j - 2]][0] + sum[second[j]][1];\n      }\n    }\n    long long int mx = 0;\n    for (int i = 0; i <= m; ++i) {\n      mx = max(mx, memo[i] + sum[(m - i) / 3][2]);\n    }\n    cout << mx << \"\\n\";\n    for (int i = 1; i <= 3; ++i) v[i].clear();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:667177216\")\nusing namespace std;\nconst long long MOD = 1000000000 + 7;\nstruct dpval {\n  long long cost;\n  int c1, c2;\n};\ndpval D[355500];\nbool comp(pair<long long, long long> &a, pair<long long, long long> &b) {\n  if (a.first == b.first && a.second == b.second) return false;\n  return !(a.first * 1LL * b.second > a.second * 1LL * b.first);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie();\n  memset(D, -1, sizeof(D));\n  int n, m;\n  cin >> n >> m;\n  vector<pair<long long, long long>> wc(n);\n  for (int(i) = 0; (i) < n; (i)++) {\n    cin >> wc[i].first >> wc[i].second;\n  }\n  vector<long long> w1, w2, w3;\n  for (int(i) = 0; (i) < n; (i)++) {\n    if (wc[i].first == 1) w1.push_back(wc[i].second);\n    if (wc[i].first == 2) w2.push_back(wc[i].second);\n    if (wc[i].first == 3) w3.push_back(wc[i].second);\n  }\n  sort((w1).begin(), (w1).end());\n  sort((w2).begin(), (w2).end());\n  sort((w3).begin(), (w3).end());\n  reverse((w1).begin(), (w1).end());\n  reverse((w2).begin(), (w2).end());\n  reverse((w3).begin(), (w3).end());\n  memset(D, 0, sizeof(D));\n  D[0] = {0, 0, 0};\n  for (int i = 0; i <= m; ++i) {\n    auto cur = D[i];\n    long long cost = cur.cost;\n    int c1 = cur.c1;\n    int c2 = cur.c2;\n    if (D[i + 1].cost < D[i].cost) {\n      D[i + 1] = D[i];\n    }\n    if (D[i + 2].cost < D[i].cost) {\n      D[i + 2] = D[i];\n    }\n    if (c1 != w1.size()) {\n      if (cost + w1[c1] > D[i + 1].cost) {\n        D[i + 1].cost = cost + w1[c1];\n        D[i + 1].c1 = D[i].c1 + 1;\n        D[i + 1].c2 = D[i].c2;\n      }\n    }\n    if (c2 != w2.size()) {\n      if (cost + w2[c2] > D[i + 2].cost) {\n        D[i + 2].cost = cost + w2[c2];\n        D[i + 2].c1 = D[i].c1;\n        D[i + 2].c2 = D[i].c2 + 1;\n      } else {\n        if (cost + w2[c2] == D[i + 2].cost && D[i + 1].c2 + 1 < D[i].c2) {\n          D[i + 2].c1 = D[i].c1;\n          D[i + 2].c2 = D[i].c2 + 1;\n        }\n      }\n    }\n  }\n  long long ans = D[m].cost;\n  long long sum3 = 0;\n  for (int i = 0; i < w3.size(); ++i) {\n    sum3 += w3[i];\n    if (m - 3 * (i + 1) >= 0) {\n      ans = max(ans, sum3 + D[m - 3 * (i + 1)].cost);\n    }\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 3e5 + 111;\nconst int INF = 1e9 + 7;\nstruct dpp {\n  long long v, s1, s2;\n} dp[M];\nint n, m;\nlong long res, w, c;\nlong long a[4][M], s[4][M];\nint num[4];\nint cmp(int x, int y) { return x > y; }\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%lld%lld\", &w, &c);\n    a[w][++num[w]] = c;\n  }\n  for (int i = 1; i <= 3; i++) sort(a[i] + 1, a[i] + num[i] + 1, cmp);\n  for (int j = 1; j <= num[3]; j++) s[3][j] = s[3][j - 1] + a[3][j];\n  dp[1].s1 = 1, dp[1].s2 = 0, dp[1].v = a[1][1];\n  for (int i = 2; i <= m; i++) {\n    dp[i] = dp[i - 1];\n    if (dp[i - 1].v + a[1][dp[i - 1].s1 + 1] > dp[i].v)\n      dp[i].v += a[1][dp[i - 1].s1 + 1], ++dp[i].s1 = dp[i - 1].s1 + 1;\n    if (dp[i - 2].v + a[2][dp[i - 2].s2 + 1] > dp[i].v)\n      dp[i] = dp[i - 2], dp[i].v += a[2][dp[i - 2].s2 + 1], ++dp[i].s2;\n  }\n  for (int i = 0; i <= num[3] && i <= m / 3; i++)\n    res = max(res, s[3][i] + dp[m - 3 * i].v);\n  printf(\"%lld\\n\", res);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, s1[300010], s2[300010];\nlong long f[300010];\nvector<int> v[4];\nbool cmp(int x, int y) { return x > y; }\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    v[x].push_back(y);\n  }\n  for (int i = 1; i <= 3; i++) {\n    sort(v[i].begin(), v[i].end(), cmp);\n  }\n  for (int i = 1; i <= m; i++) {\n    if (s1[i - 1] < v[1].size()) {\n      if (f[i - 1] + v[1][s1[i - 1]] > f[i]) {\n        f[i] = f[i - 1] + v[1][s1[i - 1]];\n        s1[i] = s1[i - 1] + 1;\n        s2[i] = s2[i - 1];\n      }\n    }\n    if (i > 1 && s2[i - 2] < v[2].size()) {\n      if (f[i - 2] + v[2][s2[i - 2]] > f[i]) {\n        f[i] = f[i - 2] + v[2][s2[i - 2]];\n        s1[i] = s1[i - 2];\n        s2[i] = s2[i - 2] + 1;\n      }\n    }\n  }\n  for (int i = 1; i <= m; i++) {\n    f[i] = max(f[i], f[i - 1]);\n  }\n  long long s = 0, ans = 0;\n  ans = max(ans, f[m]);\n  for (int i = 0; i < v[3].size(); i++) {\n    if ((i + 1) * 3 > m) {\n      break;\n    }\n    s += v[3][i];\n    ans = max(ans, s + f[m - 3 - i * 3]);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 7;\nint n, m, sum;\nlong long ans, pre[4][N];\nvector<int> a[4];\nlong long check(int mid, int have) {\n  int one = have - 2 * mid;\n  if (one > a[1].size()) one = a[1].size();\n  return pre[2][mid] + pre[1][one];\n}\nlong long del(int have) {\n  int l = 0, r = a[2].size();\n  r = min(r, have / 2);\n  while (l < r - 1) {\n    int mid = l + r >> 1;\n    int mid2 = r + mid >> 1;\n    if (check(mid, have) > check(mid2, have))\n      r = mid2;\n    else\n      l = mid;\n  }\n  return max(max(check(l, have), check(r, have)),\n             max(check(0, have), check(have / 2, have)));\n  ;\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  a[1].push_back(0), a[2].push_back(0), a[3].push_back(0);\n  for (int i = 1; i <= n; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    a[x].push_back(y);\n    sum += x, ans += y;\n  }\n  if (m >= sum) {\n    printf(\"%lld\\n\", ans);\n    return 0;\n  }\n  ans = 0;\n  sort(a[1].begin(), a[1].end(), greater<int>());\n  sort(a[2].begin(), a[2].end(), greater<int>());\n  sort(a[3].begin(), a[3].end(), greater<int>());\n  for (int k = 1; k <= 3; k++)\n    for (int i = 0; i <= a[k].size() - 1; i++)\n      pre[k][i + 1] = pre[k][i] + a[k][i];\n  for (int i = 0; i <= a[3].size(); i++) {\n    if (i * 3 <= m) ans = max(ans, del(m - i * 3) + pre[3][i]);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint const inf = 1000 * 1000 * 1000;\nlong long const inf64 = 1ll * inf * inf;\nint const N = 1e5 + 5;\nint const M = 3e5 + 5;\nint n, m;\nint w[N];\nint c[N];\nvector<int> perm;\nint mn[N];\nint mn2[N];\nint mx[N];\nlong long pc[N];\nlong long pw[N];\nint sz;\nlong long value[M];\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d %d\", &w[i], &c[i]);\n    if (w[i] <= 2) {\n      perm.push_back(i);\n    }\n  }\n  sort((perm).begin(), (perm).end(),\n       [&](int i, int j) { return 2 * c[i] / w[i] > 2 * c[j] / w[j]; });\n  sz = (int)perm.size();\n  for (int i = sz - 1; i >= 0; i--) {\n    if (i == sz - 1) {\n      mx[i] = -inf;\n    } else\n      mx[i] = mx[i + 1];\n    if (w[perm[i]] == 1) mx[i] = max(mx[i], c[perm[i]]);\n  }\n  for (int i = 0; i < sz; i++) {\n    pc[i] = (i > 0 ? pc[i - 1] : 0ll) + c[perm[i]];\n    pw[i] = (i > 0 ? pw[i - 1] : 0ll) + w[perm[i]];\n    if (i == 0)\n      mn[i] = mn2[i] = inf;\n    else\n      mn[i] = mn[i - 1], mn2[i] = mn2[i - 1];\n    if (w[perm[i]] == 1) {\n      mn[i] = min(mn[i], c[perm[i]]);\n    } else {\n      mn2[i] = min(mn2[i], c[perm[i]]);\n    }\n  }\n  for (int j = 0; j < M; j++) {\n    int idx = lower_bound(pw, pw + sz, j) - pw;\n    int ql = max(0, idx - 3);\n    int qr = min(sz - 1, idx + 3);\n    for (int i = ql; i <= qr; i++) {\n      if (pw[i] <= j) {\n        value[j] = max(value[j], pc[i]);\n      } else if (pw[i] == j + 1) {\n        value[j] = max(value[j], pc[i] - mn[i]);\n        value[j] = max(value[j], pc[i] - mn2[i] + (i + 1 < sz ? mx[i] : -inf));\n      }\n    }\n  }\n  long long res = 0;\n  for (int j = 0; j <= m; j++) {\n    res = max(res, value[j]);\n    if (j > 0) {\n      value[j] = max(value[j], value[j - 1]);\n    }\n  }\n  vector<long long> arr;\n  for (int i = 1; i <= n; i++) {\n    if (w[i] == 3) {\n      arr.push_back(c[i]);\n    }\n  }\n  sort((arr).begin(), (arr).end());\n  reverse((arr).begin(), (arr).end());\n  for (int i = 0; i < (int)arr.size(); i++) {\n    if (i > 0) arr[i] += arr[i - 1];\n    if (3 * (i + 1) > m) break;\n    res = max(res, value[m - 3 * (i + 1)] + arr[i]);\n  }\n  cout << res << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Qwa {\n  long long cost;\n  int cnt[4];\n};\nint main(int argc, char**) {\n  if (argc > 1) {\n    freopen(\"debug/in.txt\", \"r\", stdin);\n    freopen(\"debug/out.txt\", \"w\", stdout);\n  }\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<int> wc[4];\n  for (int k = 1; k < 4; ++k) wc[k].reserve(n);\n  for (int i = 0; i < n; ++i) {\n    int w, c;\n    cin >> w >> c;\n    wc[w].push_back(c);\n  }\n  for (int k = 1; k < 4; ++k)\n    sort((wc[k]).begin(), (wc[k]).end(), greater<int>());\n  vector<Qwa> dp(m + 1);\n  fill(dp[0].cnt, dp[0].cnt + 4, 0);\n  long long maxCost = 0;\n  for (int j = 1; j < m + 1; ++j) {\n    long long cost = 0;\n    int wBest = 0;\n    for (int w = 1; w < 4 && j - w >= 0; ++w) {\n      Qwa q = dp[j - w];\n      int cnt = q.cnt[w];\n      if (wc[w].size() > cnt) {\n        long long wCost = q.cost + wc[w][cnt];\n        if (wCost >= cost) {\n          cost = wCost;\n          wBest = w;\n        }\n      }\n    }\n    if (cost) {\n      dp[j] = dp[j - wBest];\n      dp[j].cost = cost;\n      ++dp[j].cnt[wBest];\n      maxCost = max(maxCost, cost);\n    }\n  }\n  {\n    Qwa q1 = dp[m - 1];\n    if (q1.cnt[1] && wc[2].size() > q1.cnt[2]) {\n      long long cost = q1.cost - wc[1][q1.cnt[1] - 1] + wc[2][q1.cnt[2]];\n      maxCost = max(maxCost, cost);\n    }\n  }\n  if (m > 1) {\n    Qwa q2 = dp[m - 2];\n    if (q2.cnt[1] && wc[3].size() > q2.cnt[3]) {\n      long long cost = q2.cost - wc[1][q2.cnt[1] - 1] + wc[3][q2.cnt[3]];\n      maxCost = max(maxCost, cost);\n    }\n  }\n  cout << maxCost << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 300010;\nstruct {\n  long long v, s1, s2;\n} dp[MAXN];\nint n, m;\nlong long a[4][MAXN];\nlong long s[4][MAXN];\nint num[4];\nint cmp(int x, int y) { return x > y; }\nint main() {\n  cin >> n >> m;\n  num[1] = num[2] = num[3] = 0;\n  for (int i = 1; i <= n; i++) {\n    long long w, c;\n    cin >> w >> c;\n    a[w][++num[w]] = c;\n  }\n  for (int i = 1; i <= 3; i++) {\n    sort(a[i] + 1, a[i] + num[i] + 1, cmp);\n    for (int j = 1; j <= num[i]; j++) s[i][j] = s[i][j - 1] + a[i][j];\n  }\n  dp[0].v = dp[0].s1 = dp[0].s2 = 0;\n  for (int i = 1; i <= m; i++) {\n    dp[i] = dp[i - 1];\n    if (dp[i - 1].v + a[1][dp[i - 1].s1 + 1] > dp[i].v) {\n      dp[i].v = dp[i - 1].v + a[1][dp[i - 1].s1 + 1];\n      dp[i].s1 = dp[i - 1].s1 + 1;\n      dp[i].s2 = dp[i - 1].s2;\n    }\n    if (i >= 2 && dp[i - 2].v + a[2][dp[i - 2].s2 + 1] > dp[i].v) {\n      dp[i].v = dp[i - 2].v + a[2][dp[i - 2].s2 + 1];\n      dp[i].s1 = dp[i - 2].s1;\n      dp[i].s2 = dp[i - 2].s2 + 1;\n    }\n  }\n  long long res = 0;\n  for (int i = 0; i <= num[3]; i++)\n    if (m >= i * 3) res = max(res, s[3][i] + dp[m - 3 * i].v);\n  cout << res << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class ER21qE\n{\n\n  public static void main(String[] args) {\n    InputReader in = new InputReader(System.in);\n    PrintWriter w = new PrintWriter(System.out);\n\n    int n = in.nextInt();\n    int m = in.nextInt();\n    \n    @SuppressWarnings(\"unchecked\")\n\tArrayList<Integer> c[] = new ArrayList[4];\n    for (int i = 1; i <= 3; i++)\n    \tc[i] = new ArrayList<Integer>();\n    \n    for (int i = 0; i < n; i++)\n    \tc[in.nextInt()].add(in.nextInt());\n    \n    for (int i = 1; i <= 3; i++) {\n    \twhile (c[i].size() < m + 3)\n    \t\tc[i].add(0);\n    }\n    \n    for (int i = 1; i <= 3; i++)\n    \tCollections.sort(c[i], Collections.reverseOrder());\n    \n    long dp[] = new long[m + 1];\n    int _2 = 0, _1 = 0;\n    dp[1] = c[1].get(0);\n    for (int i = 2; i <= m; i += 2) {\n    \tif (c[2].get(_2) >= c[1].get(_1) + c[1].get(_1 + 1)) {\n    \t\tdp[i] = dp[i - 2] + c[2].get(_2);\n    \t\t_2++;\n    \t} else {\n    \t\tdp[i] = dp[i - 2] + c[1].get(_1) + c[1].get(_1 + 1);\n    \t\t_1 += 2;\n    \t}\n    }\n    \n    dp[1] = c[1].get(0);\n    _2 = 0;\n    _1 = 1;\n    \n    for (int i = 3; i <= m; i += 2) {\n    \tif (c[2].get(_2) >= c[1].get(_1) + c[1].get(_1 + 1)) {\n    \t\tdp[i] = dp[i - 2] + c[2].get(_2);\n    \t\t_2++;\n    \t} else {\n    \t\tdp[i] = dp[i - 2] + c[1].get(_1) + c[1].get(_1 + 1);\n    \t\t_1 += 2;\n    \t}\n    }\n    \n    long tot = 0, ans = 0;\n    for (int i = 0; i <= c[3].size() && 3*i <= m; i++) {\n    \tans = Math.max(ans, tot + dp[m - 3 * i]);\n    \tif (i < c[3].size())\n    \t\ttot += c[3].get(i);\n    }\n    \n    w.println(ans);\n    w.close();\n  }\n\n  static class InputReader {\n\n    private final InputStream stream;\n    private final byte[] buf = new byte[8192];\n    private int curChar, snumChars;\n\n    public InputReader(InputStream st) {\n      this.stream = st;\n    }\n\n    public int read() {\n      if (snumChars == -1)\n        throw new InputMismatchException();\n      if (curChar >= snumChars) {\n        curChar = 0;\n        try {\n          snumChars = stream.read(buf);\n        } catch (IOException e) {\n          throw new InputMismatchException();\n        }\n        if (snumChars <= 0)\n          return -1;\n      }\n      return buf[curChar++];\n    }\n\n    public int nextInt() {\n      int c = read();\n      while (isSpaceChar(c)) {\n        c = read();\n      }\n      int sgn = 1;\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      int res = 0;\n      do {\n        res *= 10;\n        res += c - '0';\n        c = read();\n      } while (!isSpaceChar(c));\n      return res * sgn;\n    }\n\n    public long nextLong() {\n      int c = read();\n      while (isSpaceChar(c)) {\n        c = read();\n      }\n      int sgn = 1;\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      long res = 0;\n      do {\n        res *= 10;\n        res += c - '0';\n        c = read();\n      } while (!isSpaceChar(c));\n      return res * sgn;\n    }\n\n    public int[] nextIntArray(int n) {\n      int a[] = new int[n];\n      for (int i = 0; i < n; i++) {\n        a[i] = nextInt();\n      }\n      return a;\n    }\n\n    public String readString() {\n      int c = read();\n      while (isSpaceChar(c)) {\n        c = read();\n      }\n      StringBuilder res = new StringBuilder();\n      do {\n        res.appendCodePoint(c);\n        c = read();\n      } while (!isSpaceChar(c));\n      return res.toString();\n    }\n\n    public String nextLine() {\n      int c = read();\n      while (isSpaceChar(c))\n        c = read();\n      StringBuilder res = new StringBuilder();\n      do {\n        res.appendCodePoint(c);\n        c = read();\n      } while (!isEndOfLine(c));\n      return res.toString();\n    }\n\n    public boolean isSpaceChar(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    private boolean isEndOfLine(int c) {\n      return c == '\\n' || c == '\\r' || c == -1;\n    }\n\n  }\n\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long N, M, F[400005], S[400005], Cnt3, Ans;\nlong long Petya[4][300005], Sz[4];\nlong long P[4][4] = {{0}, {0, 1, 1}, {0, 2, 1}};\nbool Cmp(long long X, long long Y) { return X > Y; }\nsigned main() {\n  scanf(\"%lld%lld\", &N, &M);\n  for (long long I = 1; I <= N; I++) {\n    long long W, C;\n    scanf(\"%lld%lld\", &W, &C);\n    Petya[W][++Sz[W]] = C, Cnt3 += (W == 3);\n  }\n  for (long long I = 1; I <= 3; I++)\n    sort(Petya[I] + 1, Petya[I] + Sz[I] + 1, Cmp), Sz[I] = M;\n  for (long long I = 1; I <= M; I++) S[I] = S[I - 1] + Petya[3][I];\n  F[1] = Petya[1][1];\n  for (long long I = 2; I <= M; I++) {\n    long long Cur = (I & 1) + 1;\n    if (Petya[1][P[Cur][1]] + Petya[1][P[Cur][1] + 1] > Petya[2][P[Cur][2]])\n      F[I] = F[I - 2] + Petya[1][P[Cur][1]] + Petya[1][P[Cur][1] + 1],\n      P[Cur][1] += 2;\n    else\n      F[I] = F[I - 2] + Petya[2][P[Cur][2]], P[Cur][2]++;\n  }\n  for (long long I = 0; I <= min(M / 3, Cnt3); I++)\n    Ans = max(Ans, S[I] + F[M - I * 3]);\n  printf(\"%lld\", Ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstring convertstring(long long n) {\n  stringstream ss;\n  ss << n;\n  return ss.str();\n}\nconst int N = 300002;\npair<int, long long> a[N];\nstd::vector<long long> v[4];\nlong long dp[N];\nstd::vector<long long> oddtimes, eventimes;\nint main() {\n  int n, m, i;\n  long long maxi = 0;\n  scanf(\"%d\", &n);\n  scanf(\"%d\", &m);\n  for (i = (int)0; i < (int)n; i++) {\n    scanf(\"%d\", &a[i].first);\n    scanf(\"%lld\", &a[i].second);\n    v[a[i].first].push_back(a[i].second);\n  }\n  for (i = (int)1; i < (int)4; i++) {\n    sort(v[i].begin(), v[i].end());\n    reverse(v[i].begin(), v[i].end());\n  }\n  if (v[1].size() >= 1) maxi = v[1][0];\n  oddtimes = v[2];\n  eventimes = v[2];\n  for (i = 1; i < v[1].size(); i += 2) {\n    eventimes.push_back(v[1][i] + v[1][i - 1]);\n  }\n  for (i = 2; i < v[1].size(); i += 2) {\n    oddtimes.push_back(v[1][i] + v[1][i - 1]);\n  }\n  sort(oddtimes.begin(), oddtimes.end());\n  sort(eventimes.begin(), eventimes.end());\n  reverse(oddtimes.begin(), oddtimes.end());\n  reverse(eventimes.begin(), eventimes.end());\n  for (i = 1; i < oddtimes.size(); i++) {\n    oddtimes[i] += oddtimes[i - 1];\n  }\n  for (i = 1; i < eventimes.size(); i++) {\n    eventimes[i] += eventimes[i - 1];\n  }\n  for (i = 1; i <= m; i++) {\n    if (i % 2) {\n      dp[i] = maxi;\n      int p = min((i / 2) - 1, (int)oddtimes.size() - 1);\n      if (p >= 0) dp[i] = maxi + oddtimes[p];\n    } else {\n      int p = min((i / 2) - 1, (int)eventimes.size() - 1);\n      if (p >= 0) dp[i] = eventimes[p];\n    }\n    dp[i] = max(dp[i], dp[i - 1]);\n  }\n  long long ans = dp[m], wt = 0, cost = 0;\n  for (i = 0; i < v[3].size(); i++) {\n    wt += 3;\n    if (wt > m) break;\n    cost += v[3][i];\n    ans = max(ans, cost + dp[m - wt]);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 9;\nconst int M = 3e5 + 9;\nstruct Triple {\n  long long cost;\n  int cnt1, cnt2, cnt3;\n} dp[M];\nint n, m;\nlong long sum3[N];\nvector<int> c[4];\nbool cmp(int x, int y) { return x > y; }\nint main() {\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    int weight, cost;\n    cin >> weight >> cost;\n    c[weight].push_back(cost);\n  }\n  sort(c[1].begin(), c[1].end(), cmp);\n  sort(c[2].begin(), c[2].end(), cmp);\n  sort(c[3].begin(), c[3].end(), cmp);\n  dp[0].cost = 0;\n  dp[0].cnt1 = 0;\n  dp[0].cnt2 = 0;\n  dp[0].cnt3 = 0;\n  for (int i = 0; i <= m; i++) {\n    dp[i].cost = 0;\n  }\n  for (int i = 1; i <= m; i++) {\n    if (dp[i - 1].cnt1 < c[1].size() &&\n        dp[i - 1].cost + c[1][dp[i - 1].cnt1] > dp[i].cost) {\n      dp[i].cost = dp[i - 1].cost + c[1][dp[i - 1].cnt1];\n      dp[i].cnt1 = dp[i - 1].cnt1 + 1;\n      dp[i].cnt2 = dp[i - 1].cnt2;\n      dp[i].cnt3 = dp[i - 1].cnt3;\n    }\n    if (i >= 3 && dp[i - 3].cnt3 < c[3].size() &&\n        dp[i - 3].cost + c[3][dp[i - 3].cnt3] > dp[i].cost) {\n      dp[i].cost = dp[i - 3].cost + c[3][dp[i - 3].cnt3];\n      dp[i].cnt1 = dp[i - 3].cnt1;\n      dp[i].cnt2 = dp[i - 3].cnt2;\n      dp[i].cnt3 = dp[i - 3].cnt3 + 1;\n    }\n    if (i >= 1 && dp[i - 1].cost >= dp[i].cost) dp[i] = dp[i - 1];\n    if (i >= 3 && dp[i - 3].cost >= dp[i].cost) dp[i] = dp[i - 3];\n  }\n  long long res = dp[m].cost;\n  if (c[2].size() > 0) sum3[0] = c[2][0];\n  for (int i = 1; i < c[2].size(); i++) sum3[i] = sum3[i - 1] + c[2][i];\n  for (int i = 0; i < c[2].size(); i++)\n    if (m - 2 * (i + 1) >= 0)\n      res = max(res, dp[m - 2 * (i + 1)].cost + sum3[i]);\n  cout << res << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate <class T>\nusing V = vector<T>;\ntemplate <class T, class U>\nusing P = pair<T, U>;\nusing vll = V<ll>;\nusing vvll = V<vll>;\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\nconst ll MOD = 1000000007;\nconst ll HIGHINF = (ll)1e18;\nconst int INF = 1e9;\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n, m;\n  cin >> n >> m;\n  V<V<int> > wc(3);\n  vll w3;\n  for (int i = 0; i < n; i++) {\n    int w;\n    ll c;\n    cin >> w >> c;\n    if (w == 3)\n      w3.emplace_back(c);\n    else\n      wc[w].emplace_back(c);\n  }\n  sort(w3.begin(), w3.end());\n  w3.emplace_back(0LL);\n  reverse(w3.begin(), w3.end());\n  for (int i = 1; i < w3.size(); i++) w3[i] += w3[i - 1];\n  sort(wc[1].begin(), wc[1].end());\n  reverse(wc[1].begin(), wc[1].end());\n  sort(wc[2].begin(), wc[2].end());\n  reverse(wc[2].begin(), wc[2].end());\n  int i1 = 0, i2 = 0;\n  V<P<ll, P<int, int> > > dp(m + 1, make_pair(0, make_pair(0, 0)));\n  for (int i = 0; i < m; i++) {\n    if (dp[i].second.first < wc[1].size() && i + 1 <= m &&\n        dp[i + 1].first < dp[i].first + wc[1][dp[i].second.first]) {\n      dp[i + 1].first = dp[i].first + wc[1][dp[i].second.first];\n      dp[i + 1].second = make_pair(dp[i].second.first + 1, dp[i].second.second);\n    }\n    if (dp[i].second.second < wc[2].size() && i + 2 <= m &&\n        dp[i + 2].first < dp[i].first + wc[2][dp[i].second.first]) {\n      dp[i + 2].first = dp[i].first + wc[2][dp[i].second.second];\n      dp[i + 2].second = make_pair(dp[i].second.first, dp[i].second.second + 1);\n    }\n  }\n  ll ans = 0;\n  for (int i = 0; i <= m; i++) {\n    chmax(ans, dp[i].first + w3[min((m - i) / 3, (int)w3.size() - 1)]);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long int> u[4], v[4];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long int n, m, i, j, ans = 0;\n  cin >> n >> m;\n  for (i = 0; i < n; ++i) {\n    long long int x, y;\n    cin >> x >> y;\n    v[x].push_back(y);\n    u[x].push_back(y);\n  }\n  v[3].push_back(1e18);\n  for (i = 1; i <= 3; ++i) {\n    sort(v[i].begin(), v[i].end(), greater<long long int>());\n    sort(u[i].begin(), u[i].end(), greater<long long int>());\n  }\n  v[3][0] = 0;\n  for (i = 1; i < (long long int)(v[3].size()); ++i) v[3][i] += v[3][i - 1];\n  for (i = 1; i < (long long int)(v[1].size()); i += 2) {\n    v[2].push_back(v[1][i] + v[1][i - 1]);\n  }\n  for (i = 2; i < (long long int)(u[1].size()); i += 2) {\n    u[2].push_back(u[1][i] + u[1][i - 1]);\n  }\n  sort(v[2].begin(), v[2].end(), greater<long long int>());\n  sort(u[2].begin(), u[2].end(), greater<long long int>());\n  for (i = 0; i < (long long int)(v[3].size()); ++i) {\n    long long int r = m, val1 = 0, val2 = 0;\n    r = r - 3 * i;\n    if (r < 0) continue;\n    long long int y = r;\n    val1 = v[3][i];\n    val2 = v[3][i];\n    if ((long long int)(u[1].size()) && y > 0) {\n      val1 = val1 + u[1][0];\n      --y;\n    }\n    for (j = 0; j < min((y / 2), (long long int)(u[2].size())); ++j) {\n      val1 = val1 + u[2][j];\n    }\n    for (j = 0; j < min((r / 2), (long long int)(v[2].size())); ++j) {\n      val2 = val2 + v[2][j];\n    }\n    ans = max({ans, val1, val2});\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool cmp(pair<int, long long> a, pair<int, long long> b) {\n  return a.second / a.first > b.second / b.first;\n}\nint main() {\n  int n, m, w, l, r;\n  long long c, dp[300500], mx;\n  cin >> n >> m;\n  vector<pair<int, long long>> t(n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d%I64d\", &w, &c);\n    t[i] = make_pair(w, c);\n  }\n  sort(t.begin(), t.end(), cmp);\n  memset(dp, 0, sizeof(dp));\n  r = 0;\n  for (int i = 0; i < n; ++i) {\n    r = min(r + t[i].first, m);\n    l = max(t[i].first, r - 6);\n    for (int j = r; j >= l; --j) {\n      dp[j] = max(dp[j], dp[j - t[i].first] + t[i].second);\n    }\n  }\n  mx = 0;\n  for (int i = 0; i <= m; ++i) {\n    mx = max(mx, dp[i]);\n  }\n  cout << mx << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint cnt[4];\nvector<int> arr[4];\nvector<int> sorted[2];\nlong long sum0[100010];\nlong long sum1[100010];\nlong long mx[300010];\nint main() {\n  int n, m, w, c;\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    cin >> w >> c;\n    arr[w].push_back(c);\n    cnt[w]++;\n  }\n  for (int i = 1; i <= 3; i++)\n    sort(arr[i].begin(), arr[i].end(), greater<int>());\n  for (auto o : arr[2]) sorted[0].push_back(o), sorted[1].push_back(o);\n  for (int i = 0; i + 1 < arr[1].size(); i += 2)\n    sorted[0].push_back(arr[1][i] + arr[1][i + 1]);\n  for (int i = 1; i + 1 < arr[1].size(); i += 2)\n    sorted[1].push_back(arr[1][i] + arr[1][i + 1]);\n  sort(sorted[0].begin(), sorted[0].end(), greater<int>());\n  sort(sorted[1].begin(), sorted[1].end(), greater<int>());\n  for (int i = 1; i <= sorted[0].size(); i++)\n    sum0[i] = sum0[i - 1] + sorted[0][i - 1];\n  for (int i = 1; i <= sorted[1].size(); i++)\n    sum1[i] = sum1[i - 1] + sorted[1][i - 1];\n  for (int i = 1; i <= 300000; i++) {\n    long long v = 0;\n    if (i & 1) {\n      if (cnt[1] != 0)\n        if (i / 2 <= sorted[1].size()) v = sum1[i / 2] + arr[1][0];\n    } else {\n      if (i / 2 <= sorted[0].size()) v = sum0[i / 2];\n    }\n    mx[i] = max(mx[i - 1], v);\n  }\n  long long ans = 0, sum = 0;\n  for (int i = 0; i <= cnt[3]; i++) {\n    if (m >= i * 3) ans = max(ans, sum + mx[m - i * 3]);\n    if (i < cnt[3]) sum += arr[3][i];\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nofstream fo(\"test.out\");\nifstream fi(\"test.inp\");\nusing namespace std;\nint n, m, pos;\nstruct P {\n  int w, val;\n} p[101000];\nbool cmp(P p1, P p2) {\n  return (long long)p1.val * p2.w > (long long)p2.val * p1.w;\n}\nlong long f[301000], ans;\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%d%d\", &p[i].w, &p[i].val);\n  sort(p + 1, p + n + 1, cmp);\n  for (int i = 1; i <= n; i++) {\n    pos = min(pos + p[i].w, m);\n    for (int j = min(m, pos + 10); j >= max(p[i].w, pos - 100); j--) {\n      f[j] = max(f[j], f[j - p[i].w] + p[i].val);\n      ans = max(ans, f[j]);\n    }\n  }\n  printf(\"%I64d\", ans);\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\nimport static java.lang.Math.max;\n\n/**\n * Created by viosng on 20.05.2017.\n */\npublic class SellingSouvenirs {\n\n    private static long res1(int n, int m, List<List<Integer>> v) {\n        v.forEach(l -> l.sort((a, b) -> Integer.compare(b, a)));\n        int s1 = v.get(1).size(), s2 = v.get(2).size(), s3 = v.get(3).size(), i1 = 0, i2 = 0, i3 = 0, curW = 0;\n        long totalC = 0;\n        for (int w = 1; w <= m; w++) {\n            if (i1 == s1 && i2 == s2 && i3 == s3) break;\n            long t1 = w - curW == 1 && i1 < s1 ? totalC + v.get(1).get(i1) : 0;\n            long t21 = w - curW == 2 && i2 < s2 ? totalC + v.get(2).get(i2) : 0;\n            long t22 = w - curW == 1 && i2 < s2 && i1 > 0 ? totalC + v.get(2).get(i2) - v.get(1).get(i1 - 1) : 0;\n            long t31 = w - curW == 3 && i3 < s3 ? totalC + v.get(3).get(i3) : 0;\n            long t32 = w - curW == 2 && i3 < s3 && i1 > 0 ? totalC + v.get(3).get(i3) - v.get(1).get(i1 - 1) : 0;\n            long t33 = w - curW == 1 && i3 < s3 && i2 > 0 ? totalC + v.get(3).get(i3) - v.get(2).get(i2 - 1) : 0;\n            long t34 = w - curW == 1 && i3 < s3 && i1 > 1 ? totalC + v.get(3).get(i3) - v.get(1).get(i1 - 1) - v.get(1).get(i1 - 2) : 0;\n            long max = max(totalC, max(t1, max(t21, max(t22, max(t31, max(t32, max(t33, t34)))))));\n            if (max == totalC) continue;\n            totalC = max;\n            curW = w;\n            if (max == t1) i1++;\n            else if (max == t21) i2++;\n            else if (max == t31) i3++;\n            else if (max == t22) { i2++; i1--; }\n            else if (max == t32) { i3++; i1--; }\n            else if (max == t33) { i3++; i2--; }\n            else { i3++; i1 -= 2; }\n        }\n        return totalC;\n    }\n\n    private final static class Triple {\n        long cost;\n        int c1, c2;\n\n        public Triple(long cost, int c1, int c2) {\n            this.cost = cost;\n            this.c1 = c1;\n            this.c2 = c2;\n        }\n    }\n\n    private static long res2(int n, int m, List<List<Integer>> v) {\n        v.forEach(l -> l.sort((a, b) -> Integer.compare(b, a)));\n        int s1 = v.get(1).size(), s2 = v.get(2).size();\n        Triple[] triples = new Triple[m + 1];\n        triples[0] = new Triple(0L, 0, 0);\n        for (int w = 1; w <= m; w++) {\n            long w1 = triples[w - 1].c1 < s1 ? triples[w - 1].cost + v.get(1).get(triples[w - 1].c1) : 0;\n            long w2 = w > 1 && triples[w - 2].c2 < s2 ? triples[w - 2].cost + v.get(2).get(triples[w - 2].c2) : 0;\n            if (w1 >= w2 && w1 > triples[w - 1].cost) triples[w] = new Triple(w1, triples[w - 1].c1 + 1, triples[w - 1].c2);\n            else if (w2 >= w1 && w2 > triples[w - 1].cost)triples[w] = new Triple(w2, triples[w - 2].c1, triples[w - 2].c2 + 1);\n            else triples[w] = triples[w - 1];\n        }\n        long max = triples[m].cost;\n        long curSum = 0;\n        for (int i = 0; i < v.get(3).size() && (i + 1) * 3 <= m; i++) {\n            curSum += v.get(3).get(i);\n            max = max(max, triples[m - (i + 1) * 3].cost + curSum);\n        }\n        return max;\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt(), m = in.nextInt();\n        List<List<Integer>> v = Arrays.asList(new ArrayList<>(), new ArrayList<>(), new ArrayList<>(), new ArrayList<>());\n        for (int i = 0; i < n; i++) v.get(in.nextInt()).add(in.nextInt());\n        long res = res2(n, m, v);\n        System.out.println(res);\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int getint() {\n  static char c;\n  while ((c = getchar()) < '0' || c > '9')\n    ;\n  int res = c - '0';\n  while ((c = getchar()) >= '0' && c <= '9') res = res * 10 + c - '0';\n  return res;\n}\ntemplate <class T>\ninline bool relax(T &a, const T &b) {\n  if (b > a) {\n    a = b;\n    return true;\n  }\n  return false;\n}\nconst int MaxN = 100005;\nconst int MaxM = 300005;\nconst int T = 3;\nint n, m;\nint cnt[T], cost[T][MaxM];\nlong long f[MaxM];\nint main() {\n  n = getint(), m = getint();\n  for (int i = 1; i <= n; ++i) {\n    int w = getint() - 1;\n    int c = getint();\n    cost[w][++cnt[w]] = c;\n  }\n  for (int i = 0; i < 3; ++i) {\n    sort(cost[i] + 1, cost[i] + cnt[i] + 1, greater<int>());\n    while (cnt[i] < m + 4) cost[i][++cnt[i]] = 0;\n  }\n  int v0 = 1, v1 = 1;\n  for (int i = 2; i <= m; i += 2) {\n    int c0 = cost[0][v0] + cost[0][v0 + 1];\n    int c1 = cost[1][v1];\n    f[i] = f[i - 2] + (c0 > c1 ? (v0 += 2, c0) : (++v1, c1));\n  }\n  f[1] = cost[0][v0 = 2, v1 = 1];\n  for (int i = 3; i <= m; i += 2) {\n    int c0 = cost[0][v0] + cost[0][v0 + 1];\n    int c1 = cost[1][v1];\n    f[i] = f[i - 2] + (c0 > c1 ? (v0 += 2, c0) : (++v1, c1));\n  }\n  long long sum = 0, res = 0;\n  for (int i = 0; i <= cnt[2] && i * 3 <= m; ++i) {\n    sum += cost[2][i];\n    relax(res, sum + f[m - i * 3]);\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\", \"unroll-loops\")\nusing namespace std;\nconst int iinf = 1 << 29;\nconst long long inf = 1ll << 60;\nconst long long mod = 1e9 + 7;\nvoid GG() {\n  cout << \"No\\n\";\n  exit(0);\n}\nlong long mpow(long long a, long long n) {\n  long long re = 1;\n  while (n > 0) {\n    if (n & 1) re = re * a % mod;\n    a = a * a % mod;\n    n >>= 1;\n  }\n  return re;\n}\nlong long inv(long long b) {\n  if (b == 1) return b;\n  return (mod - mod / b) * inv(mod % b) % mod;\n}\nconst int maxn = 1e5 + 5;\nvector<long long> a[4];\nvector<long long> even, odd;\nvector<long long> eps, ops;\nlong long poss(long long w) {\n  if (w < 0) return -inf;\n  long long re = 0;\n  if (w & 1 && a[1].size() > 0) {\n    re += a[1][0];\n    re += ops[min((w - 1) / 2, (long long)ops.size() - 1)];\n    return re;\n  } else {\n    re += eps[min(w / 2, (long long)eps.size() - 1)];\n    return re;\n  }\n}\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < (n); i++) {\n    int w;\n    long long c;\n    cin >> w >> c;\n    a[w].push_back(c);\n  }\n  a[1].push_back(0);\n  for (int i = 0; i < (4); i++) {\n    sort(a[i].begin(), a[i].end(), greater<long long>());\n  }\n  even = odd = a[2];\n  eps.push_back(0);\n  ops.push_back(0);\n  if (a[1].size()) {\n    for (int i = 1; i + 1 < a[1].size(); i += 2) {\n      odd.push_back(a[1][i] + a[1][i + 1]);\n    }\n  }\n  for (int i = 0; i + 1 < a[1].size(); i += 2) {\n    even.push_back(a[1][i] + a[1][i + 1]);\n  }\n  sort(even.begin(), even.end(), greater<long long>());\n  sort(odd.begin(), odd.end(), greater<long long>());\n  for (int i = 0; i < (odd.size()); i++) {\n    ops.push_back(ops.back() + odd[i]);\n  }\n  for (int i = 0; i < (even.size()); i++) {\n    eps.push_back(eps.back() + even[i]);\n  }\n  long long re = 0;\n  long long s3 = 0;\n  for (int i = 0; i < (a[3].size() + 1); i++) {\n    re = max(re, (__typeof__(re))(s3 + poss(m - 3 * i)));\n    if (i != a[3].size()) {\n      s3 += a[3][i];\n    }\n  }\n  cout << re << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N, C;\nvector<int> Adj[4];\nvector<int> v2;\nint n1, n2, n3;\nlong long s[4][100005];\nlong long ans1, ans2;\nbool cmp(const int& a, const int& b) { return a > b; }\nvoid calS(int k) {\n  sort(Adj[k].begin(), Adj[k].end(), cmp);\n  for (int i = 0; i < Adj[k].size(); i++) {\n    s[k][i + 1] = s[k][i] + Adj[k][i];\n  }\n  return;\n}\nlong long solve(int n2) {\n  n1 = C - 3 * n3 - 2 * n2;\n  if (n1 < 0) return 0;\n  n1 = max(n1, 0);\n  n1 = min(n1, int(Adj[1].size()));\n  return s[2][n2] + s[1][n1];\n}\nlong long work(int C) {\n  int l = 0, r = min(C / 2, int(Adj[2].size())) - 1;\n  if (r <= 0) {\n    return max(solve(0), solve(1));\n  }\n  int mid;\n  while (r - l > 5) {\n    mid = (r + l) / 2;\n    if (solve(mid + 1) > solve(mid))\n      l = mid;\n    else\n      r = mid;\n  }\n  for (mid = l; mid <= r; mid++) {\n    if (solve(mid + 1) < solve(mid)) return solve(mid);\n  }\n  return solve(r + 1);\n}\nint main() {\n  cin >> N >> C;\n  int w, v;\n  for (int i = 1; i <= N; i++) {\n    cin >> w >> v;\n    Adj[w].push_back(v);\n  }\n  for (int k = 1; k <= 3; k++) calS(k);\n  long long ans = 0;\n  for (n3 = 0; 3 * n3 <= C && n3 <= Adj[3].size(); n3++) {\n    ans = max(ans, s[3][n3] + work(C - 3 * n3));\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100005;\nlong long a1[maxn], a2[maxn], a3[maxn], n, m, num1, num2, num3, ans, s2[maxn],\n    s3[maxn], am[maxn];\nbool cmp(long long a, long long b) { return a > b; }\nvoid add1(long long c) {\n  num1++;\n  a1[num1] = c;\n}\nvoid add2(long long c) {\n  num2++;\n  a2[num2] = c;\n}\nvoid add3(long long c) {\n  num3++;\n  a3[num3] = c;\n}\nvoid work() {\n  sort(a2 + 1, a2 + num2 + 1, cmp);\n  sort(a3 + 1, a3 + num3 + 1, cmp);\n  memset(s2, 0, sizeof(s2));\n  memset(s3, 0, sizeof(s3));\n  for (int i = 1; i <= num2; i++) s2[i] = s2[i - 1] + a2[i];\n  for (int i = 1; i <= num3; i++) s3[i] = s3[i - 1] + a3[i];\n  for (long long i = 0; i * 2 <= m; i++) {\n    long long tp = (m - i * 2) / 3;\n    ans = max(ans, s2[min(i, num2)] + s3[min(tp, num3)]);\n  }\n}\nvoid del2() {\n  a2[num2] = 0;\n  num2--;\n}\nint main() {\n  cin >> n >> m;\n  long long w, c;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%lld%lld\", &w, &c);\n    if (w == 1ll) add1(c);\n    if (w == 2ll) add2(c);\n    if (w == 3ll) add3(c);\n  }\n  sort(a1 + 1, a1 + num1 + 1, cmp);\n  m--;\n  memcpy(am, a2, sizeof(a2));\n  long long cnt = 0ll;\n  for (int i = 3; i <= num1; i += 2) {\n    long long tp = a1[i] + a1[i - 1];\n    add2(tp);\n    cnt++;\n  }\n  work();\n  m++;\n  if (m >= 1) ans += a1[1];\n  memcpy(a2, am, sizeof(am));\n  for (int i = 2; i <= num1; i += 2) {\n    long long tp = a1[i] + a1[i - 1];\n    add2(tp);\n  }\n  work();\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\n@SuppressWarnings(\"unchecked\")\npublic class P808E {\n\n  final static int DIST = 250;\n\n  public void run() throws Exception {\n    int n = nextInt(), m = nextInt();\n    int [][] wca = new int [n][2];\n    int l1 = 0, l2 = 0, l3 = 0;\n    for (int i = 0; i < n; i++) {\n      wca[i] = readInt(2);\n      if (wca[i][0] == 1) {\n        l1++;\n      } else if (wca[i][0] == 2) {\n        l2++;\n      } else {\n        l3++;\n      }\n    }\n\n    Arrays.sort(wca, new Comparator<int []>() {\n      public int compare(int [] a, int [] b) {\n        return (b[1] - a[1]);\n      }\n    });\n\n    int [] c1 = new int [l1], c2 = new int [l2], c3 = new int [l3];\n    int i1 = 0, i2 = 0, i3 = 0;\n    for (int [] wc : wca) {\n      if (wc[0] == 1) {\n        c1[i1++] = wc[1];\n      } else if (wc[0] == 2) {\n        c2[i2++] = wc[1];\n      } else {\n        c3[i3++] = wc[1];\n      }\n    }\n\n    int mm = m;\n    i1 = i2 = i3 = 0;\n    while (true) {\n      int k1 = ((i1 < l1) && (mm >= 1)) ? c1[i1] : 0;\n      int k2 = ((i2 < l2) && (mm >= 2)) ? c2[i2] : 0;\n      int k3 = ((i3 < l3) && (mm >= 3)) ? c3[i3] : 0;\n\n      if ((k1 | k2 | k3) == 0) {\n        break;\n      } else if ((2.0 * k1 >= k2) && (3.0 * k1 >= k3)) {\n        i1++;\n        mm -= 1;\n      } else if ((k2 >= 2.0 * k1) && (3.0 * k2 >= 2.0 * k3)) {\n        i2++;\n        mm -= 2;\n      } else {\n        i3++;\n        mm -= 3;\n      }\n    }\n\n    long [] s1 = new long [l1 + 1], s2 = new long [l2 + 1], s3 = new long [l3 + 1];\n    for (int i = 0; i < l1; s1[i + 1] = c1[i] + s1[i], i++);\n    for (int i = 0; i < l2; s2[i + 1] = c2[i] + s2[i], i++);\n    for (int i = 0; i < l3; s3[i + 1] = c3[i] + s3[i], i++);\n\n    long s = 0;\n    for (int d1 = -DIST; d1 <= DIST; d1++) {\n      for (int d2 = -DIST; d2 <= DIST; d2++) {\n        for (int d3 = -DIST; d3 <= DIST; d3++) {\n          int j1 = i1 + d1, j2 = i2 + d2, j3 = i3 + d3;\n\n          if ((j1 >= 0) && (j2 >= 0) && (j3 >= 0) &&\n              (j1 <= l1) && (j2 <= l2) && (j3 <= l3) &&\n              ((j1 + 2 * j2 + 3 * j3) <= m)) {\n            s = Math.max(s, s1[j1] + s2[j2] + s3[j3]);\n          }\n        }\n      }\n    }\n\n    println(s);\n  }\n\n  public static void main(String... args) throws Exception {\n    br = new BufferedReader(new InputStreamReader(System.in));\n    pw = new PrintWriter(new BufferedOutputStream(System.out));\n    new P808E().run();\n    br.close();\n    pw.close();\n    System.err.println(\"\\n[Time : \" + (System.currentTimeMillis() - startTime) + \" ms]\");\n  }\n\n  static long startTime = System.currentTimeMillis();\n  static BufferedReader br;\n  static PrintWriter pw;\n  StringTokenizer stok;\n\n  String nextToken() throws IOException {\n    while (stok == null || !stok.hasMoreTokens()) {\n      String s = br.readLine();\n      if (s == null) { return null; }\n      stok = new StringTokenizer(s);\n    }\n    return stok.nextToken();\n  }\n\n  void print(byte b) { print(\"\" + b); }\n  void print(int i) { print(\"\" + i); }\n  void print(long l) { print(\"\" + l); }\n  void print(double d) { print(\"\" + d); }\n  void print(char c) { print(\"\" + c); }\n  void print(Object o) {\n    if (o instanceof int[]) { print(Arrays.toString((int [])o));\n    } else if (o instanceof long[]) { print(Arrays.toString((long [])o));\n    } else if (o instanceof char[]) { print(Arrays.toString((char [])o));\n    } else if (o instanceof byte[]) { print(Arrays.toString((byte [])o));\n    } else if (o instanceof short[]) { print(Arrays.toString((short [])o));\n    } else if (o instanceof boolean[]) { print(Arrays.toString((boolean [])o));\n    } else if (o instanceof float[]) { print(Arrays.toString((float [])o));\n    } else if (o instanceof double[]) { print(Arrays.toString((double [])o));\n    } else if (o instanceof Object[]) { print(Arrays.toString((Object [])o));\n    } else { print(\"\" + o); }\n  }\n  void print(String s) { pw.print(s); }\n  void println() { println(\"\"); }\n  void println(byte b) { println(\"\" + b); }\n  void println(int i) { println(\"\" + i); }\n  void println(long l) { println(\"\" + l); }\n  void println(double d) { println(\"\" + d); }\n  void println(char c) { println(\"\" + c); }\n  void println(Object o) { print(o); println(); }\n  void println(String s) { pw.println(s); }\n  int nextInt() throws IOException { return Integer.parseInt(nextToken()); }\n  long nextLong() throws IOException { return Long.parseLong(nextToken()); }\n  double nextDouble() throws IOException { return Double.parseDouble(nextToken()); }\n  char nextChar() throws IOException { return (char) (br.read()); }\n  String next() throws IOException { return nextToken(); }\n  String nextLine() throws IOException { return br.readLine(); }\n  int [] readInt(int size) throws IOException {\n    int [] array = new int [size];\n    for (int i = 0; i < size; i++) { array[i] = nextInt(); }\n    return array;\n  }\n  long [] readLong(int size) throws IOException {\n    long [] array = new long [size];\n    for (int i = 0; i < size; i++) { array[i] = nextLong(); }\n    return array;\n  }\n  double [] readDouble(int size) throws IOException {\n    double [] array = new double [size];\n    for (int i = 0; i < size; i++) { array[i] = nextDouble(); }\n    return array;\n  }\n  String [] readLines(int size) throws IOException {\n    String [] array = new String [size];\n    for (int i = 0; i < size; i++) { array[i] = nextLine(); }\n    return array;\n  }\n\n  int gcd(int a, int b) {\n    return ((b > 0) ? gcd(b, a % b) : a);\n  }\n  long gcd(long a, long b) {\n    return ((b > 0) ? gcd(b, a % b) : a);\n  }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 5;\nint n, m;\nlong long dp[100 * maxn];\nstruct node {\n  long long w, v;\n  node() {}\n  node(long long w, long long v) : w(w), v(v) {}\n};\nvector<node> v;\nbool cmp(node& a, node& b) { return a.v * b.w > b.v * a.w; }\nint main() {\n  while (~scanf(\"%d%d\", &n, &m)) {\n    v.clear();\n    for (int i = 1; i <= n; i++) {\n      int a, b;\n      scanf(\"%d%d\", &a, &b);\n      v.push_back(node(a, b));\n    }\n    sort(v.begin(), v.end(), cmp);\n    int siz = v.size();\n    long long sum = 0;\n    for (int i = 0; i <= m; ++i) dp[i] = 0;\n    for (int i = 0; i < siz; i++) {\n      sum = (sum + v[i].w < m) ? (sum + v[i].w) : m;\n      for (int j = sum; j >= max(v[i].w, sum - 101); j--)\n        dp[j] = max(dp[j], dp[j - v[i].w] + v[i].v);\n    }\n    long long ans = 0;\n    for (int i = 1; i <= m; i++) ans = max(ans, dp[i]);\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 100000;\nconst int MAX_M = 300000;\nstruct Stat {\n  long long c;\n  int a, b;\n  Stat() {}\n  Stat(long long _c, int _a, int _b) : c(_c), a(_a), b(_b) {}\n  bool operator<(const Stat &s) const { return c < s.c; }\n  bool operator>(const Stat &s) const { return c > s.c; }\n};\nvector<int> cs[4];\nStat dp[MAX_M + 1];\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; i++) {\n    int wi, ci;\n    scanf(\"%d%d\", &wi, &ci);\n    cs[wi].push_back(ci);\n  }\n  for (int i = 1; i <= 3; i++) sort(cs[i].begin(), cs[i].end(), greater<int>());\n  dp[0] = Stat(0, 0, 0);\n  int sz1 = cs[1].size(), sz2 = cs[2].size();\n  for (int i = 0; i < m; i++) {\n    if (dp[i + 1] < dp[i]) dp[i + 1] = dp[i];\n    long long ci = dp[i].c;\n    int ai = dp[i].a, bi = dp[i].b;\n    if (ai < sz1) {\n      Stat d1 = Stat(ci + cs[1][ai], ai + 1, bi);\n      if (dp[i + 1] < d1) dp[i + 1] = d1;\n    }\n    if (i + 2 <= m && bi < sz2) {\n      Stat d1 = Stat(ci + cs[2][bi], ai, bi + 1);\n      if (dp[i + 2] < d1) dp[i + 2] = d1;\n    }\n  }\n  long long maxsum = 0, sum3 = 0;\n  for (int i = 0, j = m; j >= 0; i++, j -= 3) {\n    if (i > 0 && i <= cs[3].size()) sum3 += cs[3][i - 1];\n    long long sum = dp[j].c + sum3;\n    if (maxsum < sum) maxsum = sum;\n  }\n  printf(\"%lld\\n\", maxsum);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 100005;\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  {\n    long long i, j, k, n, m, ans = 0, cnt = 0, sum = 0;\n    cin >> n >> k;\n    pair<long long, long long> a[n];\n    vector<long long> v[4];\n    for (i = 0; i < n; i++) {\n      cin >> a[i].first >> a[i].second;\n      v[a[i].first].push_back(a[i].second);\n    }\n    sort(v[1].rbegin(), v[1].rend());\n    sort(v[2].rbegin(), v[2].rend());\n    sort(v[3].rbegin(), v[3].rend());\n    long long pref1[v[1].size() + 2];\n    pref1[0] = 0;\n    for (i = 0; i < v[1].size(); i++) {\n      pref1[i + 1] = pref1[i] + v[1][i];\n    }\n    long long pref2[v[2].size() + 2];\n    pref2[0] = 0;\n    for (i = 0; i < v[2].size(); i++) {\n      pref2[i + 1] = pref2[i] + v[2][i];\n    }\n    long long w = 0;\n    for (i = 0; i <= v[3].size(); i++) {\n      if (i > 0) {\n        sum += v[3][i - 1];\n        w += 3;\n      }\n      if (w > k) break;\n      ans = max(ans, sum);\n      if (w == k) break;\n      long long left2 = 0, right2 = v[2].size();\n      while (left2 <= right2) {\n        long long mid = (left2 + right2) / 2;\n        if (mid * 2 + w > k) {\n          right2 = mid - 1;\n          continue;\n        }\n        long long pos1 = min(k - (mid * 2 + w), (long long)v[1].size());\n        long long temp = pref2[mid] + pref1[pos1];\n        long long ss = 0;\n        if (pos1 < v[1].size()) ss += v[1][pos1];\n        if (pos1 + 1 < v[1].size()) ss += v[1][pos1 + 1];\n        ans = max(ans, sum + pref2[mid] + pref1[pos1]);\n        if (mid - 1 >= 0 and ss > v[2][mid - 1]) {\n          right2 = mid - 1;\n        } else {\n          left2 = mid + 1;\n        }\n      }\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long N, M;\npair<long long, vector<long long> > dp[300001];\nvector<long long> G[3];\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> N >> M;\n  for (long long i = 0; i < (N); i++) {\n    long long w, c;\n    cin >> w >> c;\n    G[w - 1].push_back(c);\n  }\n  for (long long i = 0; i < (3); i++) {\n    sort((G[i]).begin(), (G[i]).end(), greater<long long>());\n  }\n  long long hoge = 1;\n  for (long long i = 0; i <= M; i++) {\n    dp[i] = pair<long long, vector<long long> >(0, {0, 0, 0});\n  }\n  for (long long i = 1; i <= M; i++) {\n    dp[i] = max(dp[i], dp[i - 1]);\n    for (long long k = 0; k < (3); k++) {\n      if (k == hoge) continue;\n      if (i - 1 - k < 0) continue;\n      long long c = dp[i - 1 - k].second[k];\n      if (c < G[k].size()) {\n        pair<long long, vector<long long> > p = dp[i - 1 - k];\n        p.first += G[k][c];\n        p.second[k]++;\n        dp[i] = max(dp[i], p);\n      }\n    }\n  }\n  long long m = dp[M].first, sum = 0;\n  for (long long x = 0; x <= G[hoge].size(); x++) {\n    if (x > 0) sum += G[hoge][x - 1];\n    long long w = M - (hoge + 1) * x;\n    if (w < 0) continue;\n    m = max(m, sum + dp[w].first);\n  }\n  cout << m << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> a[4];\nint ind1[300005], ind2[300005];\nlong long dp[300005];\nint main() {\n  int n, m, i, w, c;\n  long long x, y, sum, ans, weight;\n  scanf(\"%d%d\", &n, &m);\n  for (i = 1; i <= n; i++) {\n    scanf(\"%d%d\", &w, &c);\n    a[w].push_back(c);\n  }\n  for (i = 1; i <= 3; i++) {\n    sort(a[i].begin(), a[i].end());\n    reverse(a[i].begin(), a[i].end());\n  }\n  if (a[1].size() != 0) {\n    dp[1] = a[1][0];\n    ind1[1] = 1;\n  }\n  for (i = 2; i <= m; i++) {\n    x = y = 0;\n    if (ind1[i - 1] < a[1].size()) x = dp[i - 1] + a[1][ind1[i - 1]];\n    if (ind2[i - 2] < a[2].size()) y = dp[i - 2] + a[2][ind2[i - 2]];\n    if (x > y) {\n      dp[i] = x;\n      ind1[i] = ind1[i - 1] + 1;\n      ind2[i] = ind2[i - 1];\n    } else {\n      dp[i] = y;\n      ind1[i] = ind1[i - 2];\n      ind2[i] = ind2[i - 2] + 1;\n    }\n    if (dp[i - 1] > dp[i]) {\n      dp[i] = dp[i - 1];\n      ind1[i] = ind1[i - 1];\n      ind2[i] = ind2[i - 1];\n    }\n  }\n  ans = dp[m];\n  sum = 0;\n  for (i = 0; i < a[3].size(); i++) {\n    sum += a[3][i];\n    weight = (i + 1) * 3;\n    if (weight > m) break;\n    ans = max(ans, dp[m - weight] + sum);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MAX_N = 1e5 + 5;\nconst int MAX_W = 3;\nint n, m, c[MAX_N * MAX_W][MAX_W - 1];\nlong long f[MAX_N * MAX_W];\nstd::vector<int> a[MAX_W];\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; ++i) {\n    int w, c;\n    scanf(\"%d%d\", &w, &c);\n    a[w - 1].push_back(c);\n  }\n  for (int i = 0; i < MAX_W; ++i)\n    std::sort(a[i].begin(), a[i].end(), std::greater<int>());\n  for (int i = 1; i <= m; ++i) {\n    f[i] = f[i - 1];\n    c[i][0] = c[i - 1][0];\n    c[i][1] = c[i - 1][1];\n    if (c[i - 1][0] < a[0].size() && f[i - 1] + a[0][c[i - 1][0]] > f[i]) {\n      f[i] = f[i - 1] + a[0][c[i - 1][0]];\n      c[i][0] = c[i - 1][0] + 1;\n      c[i][1] = c[i - 1][1];\n    }\n    if (i > 1 && c[i - 2][1] < a[1].size() &&\n        f[i - 2] + a[1][c[i - 2][1]] > f[i]) {\n      f[i] = f[i - 2] + a[1][c[i - 2][1]];\n      c[i][0] = c[i - 2][0];\n      c[i][1] = c[i - 2][1] + 1;\n    }\n  }\n  long long val = 0, wgt = 0, ans = f[m];\n  for (int x : a[2])\n    if ((wgt += 3) <= m) ans = std::max(ans, (val += x) + f[m - wgt]);\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid read(int &x) {\n  x = 0;\n  char ch = getchar();\n  bool f = (ch == '-');\n  for (; ch < '0' || ch > '9'; ch = getchar()) f |= (ch == '-');\n  for (; ch >= '0' && ch <= '9'; ch = getchar())\n    x = (x << 3) + (x << 1) + (ch ^ 48);\n  if (f) x = -x;\n}\nvoid read(long long &x) {\n  x = 0;\n  char ch = getchar();\n  bool f = (ch == '-');\n  for (; ch < '0' || ch > '9'; ch = getchar()) f |= (ch == '-');\n  for (; ch >= '0' && ch <= '9'; ch = getchar())\n    x = (x << 3) + (x << 1) + (ch ^ 48);\n  if (f) x = -x;\n}\nconst int maxn = 5000010;\nint n, m, cnt1, cnt2, cnt3, w, c;\nlong long M, sum1, sum2, tot;\nint one[maxn], two[maxn], three[maxn];\nlong long maxx[maxn], sum3[maxn];\nint l1[maxn], l2[maxn], l3[maxn];\nbool cmp(int a, int b) { return a > b; }\nint main() {\n  read(n);\n  read(M);\n  for (register int i = 1; i <= n; ++i) {\n    read(w), read(c);\n    (w == 1) ? one[++cnt1] = c : 0;\n    (w == 2) ? two[++cnt2] = c : 0;\n    (w == 3) ? three[++cnt3] = c : 0;\n    sum1 += c;\n    sum2 += w;\n  }\n  if (M < sum2)\n    m = (int)M;\n  else\n    return !printf(\"%I64d\\n\", sum1);\n  long long ans = 0;\n  sort(one + 1, one + cnt1 + 1, cmp);\n  sort(two + 1, two + cnt2 + 1, cmp);\n  sort(three + 1, three + cnt3 + 1, cmp);\n  for (register int i = 1; i <= cnt3; ++i) sum3[i] = sum3[i - 1] + three[i];\n  if (cnt1 > 0) maxx[1] = one[1], l1[1] = 1, l2[1] = 0;\n  for (register int i = 2; i <= m; ++i) {\n    maxx[i] = maxx[i - 1];\n    l1[i] = l1[i - 1];\n    l2[i] = l2[i - 1];\n    if (maxx[i] < maxx[i - 1] + one[l1[i - 1] + 1]) {\n      maxx[i] = maxx[i - 1] + one[l1[i - 1] + 1];\n      l1[i] = l1[i - 1] + 1;\n      l2[i] = l2[i - 1];\n    }\n    if (maxx[i] < maxx[i - 2] + two[l2[i - 2] + 1]) {\n      maxx[i] = maxx[i - 2] + two[l2[i - 2] + 1];\n      l2[i] = l2[i - 2] + 1;\n      l1[i] = l1[i - 2];\n    }\n  }\n  for (register int i = 0; i <= cnt3 && (long long)i * 3 <= m; ++i)\n    ((ans) < (maxx[m - i * 3] + sum3[i]) ? (ans) = (maxx[m - i * 3] + sum3[i])\n                                         : 0);\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100010;\ninline long long Min(const long long &a, const long long &b) {\n  return a < b ? a : b;\n}\ninline long long Max(const long long &a, const long long &b) {\n  return a > b ? a : b;\n}\ninline char get(void) {\n  static char buf[100000], *p1 = buf, *p2 = buf;\n  if (p1 == p2) {\n    p2 = (p1 = buf) + fread(buf, 1, 100000, stdin);\n    if (p1 == p2) return EOF;\n  }\n  return *p1++;\n}\ninline void read(long long &x) {\n  x = 0;\n  static char c;\n  for (; !(c >= '0' && c <= '9'); c = get())\n    ;\n  for (; c >= '0' && c <= '9'; x = x * 10 + c - '0', c = get())\n    ;\n}\nlong long s[4][N], n, m, pre[4][N], ans;\nint main(void) {\n  read(n), read(m);\n  long long w, c;\n  for (int i = 1; i <= n; i++) {\n    read(w), read(c);\n    s[w][++*s[w]] = c;\n  }\n  for (int i = 1; i <= 3; i++) {\n    sort(s[i] + 1, s[i] + 1 + *s[i], std::greater<long long>());\n    for (int k = 1; k <= *s[i]; k++) pre[i][k] = pre[i][k - 1] + s[i][k];\n  }\n  for (int i = 0; i <= *s[3] && m >= 0; i++) {\n    int L = 0, R = Min(m / 2, *s[2]), Mid = 0;\n    while (L < R) {\n      Mid = (L + R) >> 1;\n      int m1 = Min(*s[1], m - Mid * 2);\n      if (m1 + Mid * 2 < m - 1 || s[2][Mid] > s[1][m1] * 2)\n        L = Mid + 1;\n      else\n        R = Mid;\n    }\n    for (int k = Max(0, Mid - 50); k <= Min(*s[2], Mid + 50); k++) {\n      if (k * 2 > m) break;\n      int m1 = Min(*s[1], m - k * 2);\n      ans = Max(ans, pre[2][k] + pre[1][m1] + pre[3][i]);\n    }\n    m -= 3;\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nlong long ans = 0;\nstruct stuff {\n  long long val;\n  int c1, c2;\n};\nstuff f[300010];\nvector<long long> souvenir[5];\nvoid online_judge(void) {\n  freopen(\"testcase.inp\", \"r\", stdin);\n  freopen(\"testcase.out\", \"w\", stdout);\n}\nbool cmp(long long x, long long y) { return (x > y); }\nvoid inp(void) {\n  cin >> n >> m;\n  for (int i = (1); i <= (n); i++) {\n    int w;\n    long long c;\n    cin >> w >> c;\n    souvenir[w].push_back(c);\n  }\n  for (int w = (1); w <= (3); w++)\n    sort(souvenir[w].begin(), souvenir[w].end(), cmp);\n}\nvoid solve(void) {\n  for (int i = (1); i <= (m); i++) {\n    f[i] = f[i - 1];\n    if (f[i - 1].c1 <= (int)souvenir[1].size() - 1 and\n        f[i].val < f[i - 1].val + souvenir[1][f[i - 1].c1]) {\n      f[i].val = f[i - 1].val + souvenir[1][f[i - 1].c1];\n      f[i].c1++;\n    }\n    if (i > 1) {\n      if (f[i - 2].c2 <= (int)souvenir[2].size() - 1 and\n          f[i].val < f[i - 2].val + souvenir[2][f[i - 2].c2]) {\n        f[i].val = f[i - 2].val + souvenir[2][f[i - 2].c2];\n        f[i].c2 = f[i - 2].c2 + 1;\n        f[i].c1 = f[i - 2].c1;\n      }\n    }\n  }\n  long long value = 0;\n  for (int i = (0); i <= ((int)souvenir[3].size()); i++) {\n    if (3 * i > m) break;\n    ans = max(ans, value + f[m - i * 3].val);\n    if (i < (int)souvenir[3].size()) value += souvenir[3][i];\n  }\n  cout << ans;\n}\nint main(void) {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  inp();\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class A\n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint N = sc.nextInt();\n\t\tint K = sc.nextInt();\n\n\t\tArrayList<Integer>[] arr = new ArrayList[5];\n\t\t\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tarr[i] = new ArrayList<Integer>();\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tint u = sc.nextInt();\n\t\t\tint v = sc.nextInt();\n\t\t\tarr[u].add(v);\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t{\n\t\t\tCollections.sort(arr[i], Collections.reverseOrder());\n\t\t}\n\n\t\tlong[] DP = new long[K + 1];\n\t\t\n\t\tCurve[] preCurve = new Curve[K + 1];\n\n\t\tfor (int s = 0; s < arr.length; s++) \n\t\t{\n\t\t\tif (arr[s].size() > 0)\n\t\t\t{\n\t\t\t\tint L = arr[s].size();\n\t\t\t\t\n\t\t\t\tlong[] sum = new long[L];\n\t\t\t\t\n\t\t\t\tfor (int i=0; i < L; i++)\n\t\t\t\t{\n\t\t\t\t\tsum[i] = arr[s].get(i);\n\t\t\t\t}\n\n\t\t\t\n\t\t\t\tfor (int i = 1 ; i < L; i++)\n\t\t\t\t\tsum[i] += sum[i - 1];\n\n\n\t\t\t\tCurve.sum = sum;\n\n\n\t\t\t\tfor (int x = 0; x < s; x++)\n\t\t\t\t{\n\t\t\t\t\tint curr = K - x, j = 1, frontPointer = 0, backPointer = 0;\n\t\t\t\t\tfor (int i=0; curr- i * s >=0; i++)\n\t\t\t\t\t{\n\n\t\t\t\t\t\twhile (backPointer-frontPointer > 0 && preCurve[frontPointer].a <= i)\n\t\t\t\t\t\t\tfrontPointer++;\n\n\t\t\t\t\t\twhile (j - i <= L && (curr - j * s) >= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint pos = curr - j * s;\n\t\t\t\t\t\t\tCurve nc = new Curve(j, i, DP[pos]);\n\n\t\t\t\t\t\t\tif (frontPointer < backPointer)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpreCurve[backPointer-1].t = nc.ot(preCurve[backPointer - 1]);\n\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\twhile (backPointer-frontPointer > 1 && preCurve[backPointer -1].t <= preCurve[backPointer - 2].t)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tbackPointer--;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tpreCurve[backPointer-1].t = nc.ot(preCurve[backPointer - 1]);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpreCurve[backPointer++] = nc;\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\n\n\n\t\t\t\t\t\twhile (backPointer-frontPointer > 1 && preCurve[frontPointer].f(i) <= preCurve[frontPointer+1].f(i))\n\t\t\t\t\t\t\tfrontPointer++;\n\n\t\t\t\t\t\tif (frontPointer < backPointer)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint pos = curr - i * s;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tDP[pos] = Math.max(DP[pos], preCurve[frontPointer].f(i));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlong ans = 0;\n\t\tfor (int i = 1; i <= K; i++)\n\t\t\tans = Math.max(ans, DP[i]);\n\t\tSystem.out.println(ans);\n\t}\n\n\n\tstatic class Curve\n\t{\n\t\tstatic long[] sum;\n\t\tint a, b, t;\n\t\tlong c;\n\n\t\tCurve(int a, int b, long c)\n\t\t{\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t\tthis.c = c;\n\t\t}\n\n\t\tlong f(int ind)\n\t\t{\n\t\t\treturn ind >= a ? 0 : (sum[a - ind - 1] + c);\n\t\t}\n\n\t\tint ot(Curve rhs)\n\t\t{\n\t\t\tint lo = b, hi = a - 1;\n\t\t\twhile (lo < hi)\n\t\t\t{\n\t\t\t\tint mid = (lo + hi) / 2;\n\t\t\t\tif (f(mid) >= rhs.f(mid))\n\t\t\t\t{\n\t\t\t\t\thi = mid;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlo = mid + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn hi;\n\t\t}\n\t}\n\tstatic class Scanner\n\t{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\n\t\tScanner(InputStream s)  { br = new BufferedReader(new InputStreamReader(s)); }\n\n\t\tString next() throws IOException\n\t\t{\n\n\t\t\twhile(st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\n\t\t}\n\t\tint nextInt() throws NumberFormatException, IOException { return Integer.parseInt(next()); }\n\t\tlong nextLong() throws NumberFormatException, IOException { return Long.parseLong(next()); }\n\n\n\n\t}\n\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.*;\nimport java.security.KeyStore.Entry;\nimport java.util.*;\n\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\tpublic class Q2 {\n\t\t\t\t\n\t\t\t\tstatic long MOD = 1000000007;\n\t\t\t\tstatic boolean b[], b1[], check;\n\t\t\t\tstatic ArrayList<Integer>[] amp, pa;\n\t\t\t\tstatic ArrayList<Pair>[] amp1;\n\t\t\t\tstatic ArrayList<Pair>[][] damp;\n\t\t\t\tstatic int left[],right[],end[],sum[],dist[],cnt[],start[],color[],parent[],prime[],size[];\n\t\t\t\tstatic long ans = 0,k;\n\t\t\t\tstatic int p = 0;\n\t\t\t\tstatic FasterScanner sc = new FasterScanner(System.in);\n\t\t\t\tstatic Queue<Integer> q = new LinkedList<>();\n\t\t\t\tstatic BufferedWriter log;\n\t\t\t\tstatic HashSet<Pair> hs;\n\t\t\t\tstatic HashMap<Pair,Integer> hm;\n\t\t\t\tstatic PriorityQueue<Integer> pri[];\n\t\t\t\tstatic ArrayList<Integer>[] level;\n\t\t\t\tstatic Stack<Integer> st;\n\t\t\t\tstatic boolean boo[][];\n\t\t\t\tstatic Pair prr[];\n\t\t\t\tstatic long parent1[],parent2[],size1[],size2[],arr1[],SUM[],lev[], fibo[];\n\t\t\t\tstatic int arr[], ver[][];\n\t\t\t\tpublic static void main(String[] args) throws Exception {\n\t\t\t    \t/*new Thread(null, new Runnable() {\n\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\ttry {\n\t\t\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\tSystem.out.println(e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}, \"1\", 1 << 26).start();*/\n\t\t\t\t\tsoln();\n\t\t\t\t}\n\t\t\t\tprivate static boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\t\t\tprivate static void tr(Object... o) {\n\t\t\t\t\tif (!oj)\n\t\t\t\t\t\tSystem.out.println(Arrays.deepToString(o));\n\t\t\t\t}\n\t\t\t\tstatic long dp[][];\n\t\t\t\tstatic int N,K,T,A,B;\n\t\t\t\tstatic int time;\n\t\t\t\tstatic int cost[][];\n\t\t\t\tstatic boolean b11[];\n\t\t\t\tstatic HashMap<Integer,Integer> h = new HashMap<>();\n\t\t\t\tstatic HashSet<Pair> chec;\n\t\t\t\tstatic long ans1;\t\tstatic long ans2;\n\t\t\t\tstatic int BLOCK, MAX = 10000000, door[][];\n\t\t\t\tstatic double pi = Math.PI;\n\t\t\t\tstatic int Arr[], Brr[], pow[],  M;\n\t\t\t\tstatic long fact[] = new long[100000+1];\n\t\t\t\tstatic HashMap<Pair,Integer> hm1;\n\t\t\t\tstatic HashSet<Integer> hs1[], hs2[];\n\t\t\t\tstatic Stack<Integer>[] queue;\n\t\t\t\tstatic PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\n\t\t\t\tstatic int phi[];\n\t\t\t\tpublic static void soln() throws IOException {\n\t\t\t\t\t//FasterScanner in = new FasterScanner(new FileInputStream(\"C:\\\\Users\\\\Admin\\\\Desktop\\\\input50.txt\"));\n\t\t\t\t\t//FasterScanner sc = new FasterScanner(new FileInputStream(\"C:\\\\Users\\\\Admin\\\\Desktop\\\\input.txt\"));\n\t\t\t\t\t//PrintWriter log = new PrintWriter(\"C:\\\\Users\\\\Admin\\\\Desktop\\\\output.txt\");\n\t\t\t\t\t//long s = System.currentTimeMillis();\n\t\t\t\t\tlog = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\t\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\t\t\tamp = (ArrayList<Integer>[]) new ArrayList[4];\n\t\t\t\t\tfor(int i = 0; i< 4;i++){\n\t\t\t\t\t\tamp[i] = new ArrayList<>();\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i = 0; i< n; i++){\n\t\t\t\t\t\tamp[sc.nextInt()].add(sc.nextInt());\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i= 1; i<=3;i++){\n\t\t\t\t\t\twhile(amp[i].size()<(m+5)) amp[i].add(0);\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i = 1; i< 4; i++){\n\t\t\t\t\t\tCollections.sort(amp[i]);\n\t\t\t\t\t\tCollections.reverse(amp[i]);\n\t\t\t\t\t}\n\t\t\t\t\tlong dp[] = new long[m+1];\n\t\t\t\t\tint a1 = 0, a2 = 0;\n\t\t\t\t\tdp[1] = amp[1].get(0);\n\t\t\t\t\tfor(int i = 2;i<=m;i+=2){\n\t\t\t\t\t\tif(amp[2].get(a1)>=(amp[1].get(a2)+amp[1].get(a2+1))){\n\t\t\t\t\t\t\tdp[i] = amp[2].get(a1);\n\t\t\t\t\t\t\ta1++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i] = amp[1].get(a2)+amp[1].get(a2+1);\n\t\t\t\t\t\t\ta2+=2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[i] += dp[i-2];\n\t\t\t\t\t}\n\t\t\t\t\ta1 = 0; a2 = 1;\n\t\t\t\t\tfor(int i = 3;i<=m;i+=2){\n\t\t\t\t\t\tif(amp[2].get(a1)>=(amp[1].get(a2)+amp[1].get(a2+1))){\n\t\t\t\t\t\t\tdp[i] = amp[2].get(a1);\n\t\t\t\t\t\t\ta1++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i] = amp[1].get(a2)+amp[1].get(a2+1);\n\t\t\t\t\t\t\ta2+=2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[i]+=dp[i-2];\n\t\t\t\t\t}\n\t\t\t\t\tlong ans= 0, sum = 0;\n\t\t\t\t\tfor(int i = 0; i<=m/3 ;i++){\n\t\t\t\t\t\tans = Math.max(ans, sum + dp[m-3*i]);\n\t\t\t\t\t\tsum += amp[3].get(i);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(ans);\n\t\t\t\t\t//out.close();\n\t\t\t\t\t//tr(System.currentTimeMillis() - s + \"ms\");\n\t\t\t\t\tlog.close();\n\t\t\t\t\t//out.close();\n\t\t\t\t}\n\t\t\t\tstatic long get(int m){\n\t\t\t\t\tfor(int i = 0;i<=1;i++)for(int i1 = 0;i1<=1;i1++)for(int i2 = 0;i2<=1;i2++)\n\t\t\t\t\t\tfor(int i5 = 0;i5<=2;i5++)for(int i4 = 0;i4<=3;i4++)for(int i3 = 0;i3<=3;i3++){\n\t\t\t\t\t\t\tint x = i+i1+i2+i3+i4+i5;\n\t\t\t\t\t\t\tint a1 = -1,a2 = -1,a3 = -1,a4 = -1,a5 = -1,a6 = -1, b1,b2,b3,b4,b5,b6;\n\t\t\t\t\t\t\tlong max = 0;\n\t\t\t\t\t\t\tif(m>=6){\n\t\t\t\t\t\t\t\tif(x==6){\n\t\t\t\t\t\t\t\t\tif(!queue[i].isEmpty()) a1 = queue[i].pop();\n\t\t\t\t\t\t\t\t\tif(!queue[i1].isEmpty()) a2 = queue[i1].pop();\n\t\t\t\t\t\t\t\t\tif(!queue[i2].isEmpty()) a3 = queue[i2].pop();\n\t\t\t\t\t\t\t\t\tif(!queue[i3].isEmpty()) a4 = queue[i3].pop();\n\t\t\t\t\t\t\t\t\tif(!queue[i4].isEmpty()) a5 = queue[i4].pop();\n\t\t\t\t\t\t\t\t\tif(!queue[i5].isEmpty()) a6 = queue[i5].pop();\n\t\t\t\t\t\t\t\t\tif(!(a1==-1 || a2==-1 || a3==-1 || a4==-1 || a5==-1 || a6==-1 )){\n\t\t\t\t\t\t\t\t\t\tlong sum = a1+a2+a3+a4+a5+a6;\n\t\t\t\t\t\t\t\t\t\tif(sum>max){\n\t\t\t\t\t\t\t\t\t\t\tmax = sum;\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(a1!=-1) queue[i].add(a1);\n\t\t\t\t\t\t\t\t\tif(a2!=-1) queue[i1].add(a2);\n\t\t\t\t\t\t\t\t\tif(a3!=-1) queue[i2].add(a3);\n\t\t\t\t\t\t\t\t\tif(a4!=-1) queue[i3].add(a4);\n\t\t\t\t\t\t\t\t\tif(a5!=-1) queue[i4].add(a5);\n\t\t\t\t\t\t\t\t\tif(a6!=-1) queue[i5].add(a6);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tif(x==m){\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tstatic long recur(int x, long k, int m){\n\t\t\t\t\tif(k==0) return 1;\n\t\t\t\t\tif(m==1) return 0;\n\t\t\t\t\treturn power(x, recur(x,k-1,phi[m]), m);\n\t\t\t\t}\n\t\t\t\tstatic void bfs(){\n\t\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\t\tint y = q.poll();\n\t\t\t\t\t\tfor(int x:amp[y]){\n\t\t\t\t\t\t\tb1[x] = true;\n\t\t\t\t\t\t\tif(door[x][0]==y){\n\t\t\t\t\t\t\t\tint d = door[x][1];\n\t\t\t\t\t\t\t\tif(b[d]){\n\t\t\t\t\t\t\t\t\tif(prime[d]!=(1-arr[x-1]^prime[y])){\n\t\t\t\t\t\t\t\t\t\tcheck = true;\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tprime[d] = 1-arr[x-1]^prime[y];\n\t\t\t\t\t\t\t\t\tq.add(d);\n\t\t\t\t\t\t\t\t\tb[d] = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tint d = door[x][0];\n\t\t\t\t\t\t\t\tif(b[d]){\n\t\t\t\t\t\t\t\t\tif(prime[d]!=(1-arr[x-1]^prime[y])){\n\t\t\t\t\t\t\t\t\t\tcheck = true;\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tprime[d] = 1-arr[x-1]^prime[y];\n\t\t\t\t\t\t\t\t\tq.add(d);\n\t\t\t\t\t\t\t\t\tb[d] = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpublic static class FenwickTree {\n\t\t\t\t\t\n\t\t\t\t    int[] array; // 1-indexed array, In this array We save cumulative information to perform efficient range queries and updates\n\t\n\t\t\t\t    public FenwickTree(int size) {\n\t\t\t\t        array = new int[size + 1];\n\t\t\t\t    }\n\t\t\t\t    public int rsq(int ind) {\n\t\t\t\t        assert ind > 0;\n\t\t\t\t        int sum = 0;\n\t\t\t\t        while (ind > 0) {\n\t\t\t\t            sum += array[ind];\n\t\t\t\t            //Extracting the portion up to the first significant one of the binary representation of 'ind' and decrementing ind by that number\n\t\t\t\t            ind -= ind & (-ind);\n\t\t\t\t        }\n\t\t\t\t        return sum;\n\t\t\t\t    }\n\t\t\t\t    public int rsq(int a, int b) {\n\t\t\t\t        assert b >= a && a > 0 && b > 0;\n\t\t\t\t        return rsq(b) - rsq(a - 1);\n\t\t\t\t    }\n\t\t\t\t    public void update(int ind, int value) {\n\t\t\t\t        assert ind > 0;\n\t\t\t\t        while (ind < array.length) {\n\t\t\t\t            array[ind] += value;\n\t\t\t\t            //Extracting the portion up to the first significant one of the binary representation of 'ind' and incrementing ind by that number\n\t\t\t\t            ind += ind & (-ind);\n\t\t\t\t        }\n\t\t\t\t    }\n\t\n\t\t\t\t    public int size() {\n\t\t\t\t        return array.length - 1;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tstatic double power(double x, long y)\n\t\t\t\t{\n\t\t\t\t    if (y == 0)\n\t\t\t\t        return 1;\n\t\t\t\t    double p = power(x, y/2);\n\t\t\t\t    p = (p * p);\n\t\t\t\t \n\t\t\t\t    return (y%2 == 0)? p : (x * p);\n\t\t\t\t}\n\t\t\t\tstatic void Bfs(int x){\n\t\t\t\t\tq.add(x);\n\t\t\t\t\tb[x] = true;\n\t\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\t\tint y = q.poll();\n\t\t\t\t\t\tb[y] = true;\n\t\t\t\t\t\tfor(int p:hs2[y]){\n\t\t\t\t\t\t\tif(!b[p]){\n\t\t\t\t\t\t\t\tif(!hs1[y].contains(p)) dist[p] = dist[y]-1;\n\t\t\t\t\t\t\t\telse dist[p] = dist[y]+1;\n\t\t\t\t\t\t\t\tq.add(p);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstatic int Dfs(int x, int val){\n\t\t\t\t\tb[x] = true;\n\t\t\t\t\tfor(int p:hs2[x]){\n\t\t\t\t\t\tif(!b[p]){\n\t\t\t\t\t\t\tif(!hs1[x].contains(p)) val++;\n\t\t\t\t\t\t\tval += Dfs(p,0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn val;\n\t\t\t\t}\n\t\t\t\tstatic long nCr(int n, int r){\n\t\t\t\t\tif(n<r) return 0;\n\t\t\t\t\telse return (((fact[n]*modInverse(fact[r], MOD))%MOD)*modInverse(fact[n-r], MOD))%MOD;\n\t\t\t\t}\n\t\t\t\tstatic void dfs1(int x, int p){\n\t\t\t\t\tarr1[x] += lev[x];\n\t\t\t\t\tfor(int v:amp[x]){\n\t\t\t\t\t\tif(v!=p){\n\t\t\t\t\t\t\tdfs1(v,x);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstatic void dfs(int x, int p){\n\t\t\t\t\tstart[x] = time++;\n\t\t\t\t\tfor(int v:amp[x]){\n\t\t\t\t\t\tif(v!=p){\n\t\t\t\t\t\t\tdfs(v,x);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tend[x] = time;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tstatic void bfs(int x){\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tpublic static void seive(int n){\n\t\t\t\t\tb = new boolean[(n+1)];\n\t\t\t\t\tArrays.fill(b, true);\n\t\t\t\t\tb[1] = true;\n\t\t\t\t\tfor(int i = 2;i*i<=n;i++){\n\t\t\t\t\t\tif(b[i]){\n\t\t\t\t\t\t\tfor(int p = 2*i;p<=n;p+=i){\n\t\t\t\t\t\t\t\tb[p] = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/*for(int i = 2;i<=n;i++){\n\t\t\t\t\t\tif(b[i]) prime[i] = i;\n\t\t\t\t\t}*/\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstatic class Graph{\n\t\t\t\t\tint vertex;\n\t\t\t\t\tint weight;\n\t\t\t\t\tGraph(int v, int w){\n\t\t\t\t\t\tvertex = v;\n\t\t\t\t\t\tweight = w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstatic class Pair implements Comparable<Pair> {\n\t\t\t\t\tint u;\n\t\t\t\t\tint v;\n\t\t\t\t\tdouble ans;\n\t\t\t\t\tpublic Pair(){\n\t\t\t\t\t\tu = 0;\n\t\t\t\t\t\tv = 0;\n\t\t\t\t\t}\n\t\t\t\t\tpublic Pair(int u, int v) {\n\t\t\t\t\t\tthis.u = u;\n\t\t\t\t\t\tthis.v = v;\n\t\t\t\t\t}\n\t\t\t\t\tpublic int hashCode() {\n\t\t\t\t\t\treturn Objects.hash();\n\t\t\t\t\t}\n\t\t\t\t\tpublic boolean equals(Object o) {\n\t\t\t\t\t\tPair other = (Pair) o;\n\t\t\t\t\t\treturn ((u == other.u && v == other.v));\n\t\t\t\t\t}\n\t\t\t \n\t\t\t\t\tpublic int compareTo(Pair other) {\n\t\t\t\t\t\t//return Double.compare(ans, other.ans);\n\t\t\t\t\t\treturn Long.compare(u, other.u);// != 0 ? (Long.compare(u, other.u)) : (Long.compare(v,other.v));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\treturn \"[u=\" + u + \", v=\" + v + \"]\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpublic static void buildGraph(int n){\n\t\t\t\t\tfor(int i =0;i<n;i++){\n\t\t\t\t\t\tint x = sc.nextInt()-1, y = sc.nextInt()-1;\n\t\t\t\t\t\t//hm.put(new Pair(x,y), i+1);\n\t\t\t\t\t\ths1[x].add(y);\n\t\t\t\t\t\ths2[y].add(x);\n\t\t\t\t\t\ths2[x].add(y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tpublic static int getParent(long x){\n\t\t\t\t\twhile(parent[(int) x]!=x){\n\t\t\t\t\t\tparent[ (int) x] = parent[(int) parent[ (int) x]];\n\t\t\t\t\t\tx = parent[ (int) x];\n\t\t\t\t\t}\n\t\t\t\t\treturn (int) x;\n\t\t\t\t}\n\t\t\t\tstatic long min(long a, long b, long c){\n\t\t\t\t\tif(a<b && a<c) return a;\n\t\t\t\t\tif(b<c) return b;\n\t\t\t\t\treturn c;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t\n\t\t\t\tstatic class Pair3{\n\t\t\t\t\tint x, y ,z;\n\t\t\t\t\tPair3(int x, int y, int z){\n\t\t\t\t\t\tthis.x = x;\n\t\t\t\t\t\tthis.y = y;\n\t\t\t\t\t\tthis.z = z;\n\t\t\t\t\t}\n\t\t\t\t}*/\n\t\t\t\t static void KMPSearch(String pat, String txt)\n\t\t\t\t    {\n\t\t\t\t        int M = pat.length();\n\t\t\t\t        int N = txt.length();\n\t\t\t\t \n\t\t\t\t        // create lps[] that will hold the longest\n\t\t\t\t        // prefix suffix values for pattern\n\t\t\t\t        int lps[] = new int[M];\n\t\t\t\t        int j = 0;  // index for pat[]\n\t\t\t\t \n\t\t\t\t        // Preprocess the pattern (calculate lps[]\n\t\t\t\t        // array)\n\t\t\t\t        computeLPSArray(pat,M,lps);\n\t\t\t\t \n\t\t\t\t        int i = 0;  // index for txt[]\n\t\t\t\t        while (i < N)\n\t\t\t\t        {\n\t\t\t\t            if (pat.charAt(j) == txt.charAt(i))\n\t\t\t\t            {\n\t\t\t\t                j++;\n\t\t\t\t                i++;\n\t\t\t\t            }\n\t\t\t\t            if (j == M)\n\t\t\t\t            {\n\t\t\t\t               // parent.add((i-j));\n\t\t\t\t                j = lps[j-1];\n\t\t\t\t            }\n\t\t\t\t \n\t\t\t\t            // mismatch after j matches\n\t\t\t\t            else if (i < N && pat.charAt(j) != txt.charAt(i))\n\t\t\t\t            {\n\t\t\t\t                // Do not match lps[0..lps[j-1]] characters,\n\t\t\t\t                // they will match anyway\n\t\t\t\t                if (j != 0)\n\t\t\t\t                    j = lps[j-1];\n\t\t\t\t                else\n\t\t\t\t                    i = i+1;\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t static void computeLPSArray(String pat, int M, int lps[])\n\t\t\t\t    {\n\t\t\t\t        // length of the previous longest prefix suffix\n\t\t\t\t        int len = 0;\n\t\t\t\t        int i = 1;\n\t\t\t\t        lps[0] = 0;  // lps[0] is always 0\n\t\t\t\t \n\t\t\t\t        // the loop calculates lps[i] for i = 1 to M-1\n\t\t\t\t        while (i < M)\n\t\t\t\t        {\n\t\t\t\t            if (pat.charAt(i) == pat.charAt(len))\n\t\t\t\t            {\n\t\t\t\t                len++;\n\t\t\t\t                lps[i] = len;\n\t\t\t\t                i++;\n\t\t\t\t            }\n\t\t\t\t            else  // (pat[i] != pat[len])\n\t\t\t\t            {\n\t\t\t\t                // This is tricky. Consider the example.\n\t\t\t\t                // AAACAAAA and i = 7. The idea is similar \n\t\t\t\t                // to search step.\n\t\t\t\t                if (len != 0)\n\t\t\t\t                {\n\t\t\t\t                    len = lps[len-1];\n\t\t\t\t \n\t\t\t\t                    // Also, note that we do not increment\n\t\t\t\t                    // i here\n\t\t\t\t                }\n\t\t\t\t                else  // if (len == 0)\n\t\t\t\t                {\n\t\t\t\t                    lps[i] = len;\n\t\t\t\t                    i++;\n\t\t\t\t                }\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\tprivate static void permutation(String prefix, String str) {\n\t\t\t\t    int n = str.length();\n\t\t\t\t    if (n == 0); //hs.add(prefix);\n\t\t\t\t    else {\n\t\t\t\t        for (int i = 0; i < n; i++)\n\t\t\t\t            permutation(prefix + str.charAt(i), str.substring(0, i) + str.substring(i+1, n));\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpublic static void buildTree(int n){\n\t\t\t\t\tint arr[] = sc.nextIntArray(n);\n\t\t\t\t\tfor(int i = 0;i<n;i++){\n\t\t\t\t\t\tint x = arr[i]-1;\n\t\t\t\t\t\tamp[i+1].add(x);\n\t\t\t\t\t\tamp[x].add(i+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstatic class SegmentTree {\n\t\t\t\t\tboolean st[];\n\t\t\t\t\tboolean lazy[];\n\t\t\n\t\t\t\t\tSegmentTree(int n) {\n\t\t\t\t\t\tint size = 4 * n;\n\t\t\t\t\t\tst = new boolean[size];\n\t\t\t\t\t\tArrays.fill(st, true);\n\t\t\t\t\t\tlazy = new boolean[size];\n\t\t\t\t\t\tArrays.fill(lazy, true);\n\t\t\t\t\t\t//build(0, n - 1, 1);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t/*long[] build(int ss, int se, int si) {\n\t\t\t\t\t\tif (ss == se) {\n\t\t\t\t\t\t\tst[si][0] = 1;\n\t\t\t\t\t\t\tst[si][1] = 1;\n\t\t\t\t\t\t\tst[si][2] = 1;\n\t\t\t\t\t\t\treturn st[si];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint mid = (ss + se) / 2;\n\t\t\t\t\t\tlong a1[] = build(ss, mid, si * 2), a2[] = build(mid + 1, se,\n\t\t\t\t\t\t\t\tsi * 2 + 1);\n\t\t\t\t\t\tlong ans[] = new long[3];\n\t\t\t\t\t\tif (arr[mid] < arr[mid + 1]) {\n\t\t\t\t\t\t\tans[1] = Math.max(a2[1], Math.max(a1[1], a1[2] + a2[0]));\n\t\t\t\t\t\t\tif (a1[1] == (mid - ss + 1))\n\t\t\t\t\t\t\t\tans[0] = ans[1];\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tans[0] = a1[0];\n\t\t\t\t\t\t\tif (a2[2] == (se - mid))\n\t\t\t\t\t\t\t\tans[2] = ans[1];\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tans[2] = a2[2];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tans[1] = Math.max(a1[1], a2[1]);\n\t\t\t\t\t\t\tans[0] = a1[0];\n\t\t\t\t\t\t\tans[2] = a2[2];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tst[si] = ans;\n\t\t\t\t\t\treturn st[si];\n\t\t\t\t\t}*/\n\t\t\n\t\t\t\t\tvoid update(int si, int ss, int se, int idx, long x) {\n\t\t\t\t\t\tif (ss == se) {\n\t\t\t\t\t\t\t//arr[idx] += val;\n\t\t\t\t\t\t\tst[si]=false;\n\t\t\t\t\t\t} \n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tint mid = (ss + se) / 2;\n\t\t\t\t\t\t\tif(ss <= idx && idx <= mid)\n\t\t\t\t\t        {\n\t\t\t\t\t             update(2*si, ss, mid, idx, x);\n\t\t\t\t\t        }\n\t\t\t\t\t        else\n\t\t\t\t\t        { update(2*si+1, mid+1, se, idx, x);\n\t\t\t\t\t        }\n\t\t\t\t\t\t\tst[si] = st[2*si]|st[2*si+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/*boolean get(int qs, int qe, int ss, int se, int si){\n\t\t\t\t\t\tif(qs>se || qe<ss) return 0;\n\t\t\t\t\t\tif (qs <= ss && qe >= se) {\n\t\t\t\t\t\t\treturn st[si];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint mid = (ss+se)/2;\n\t\t\t\t\t\treturn get(qs, qe, ss, mid, si * 2)+get(qs, qe, mid + 1, se, si * 2 + 1);\n\t\t\t\t\t}*/\n\t\t\t\t\tvoid updateRange(int node, int start, int end, int l, int r, boolean val)\n\t\t\t\t\t{\n\t\t\t\t\t    if(!lazy[node])\n\t\t\t\t\t    { \n\t\t\t\t\t        // This node needs to be updated\n\t\t\t\t\t        st[node] = lazy[node];    // Update it\n\t\t\t\t\t        if(start != end)\n\t\t\t\t\t        {\n\t\t\t\t\t            lazy[node*2] = lazy[node];                  // Mark child as lazy\n\t\t\t\t\t            lazy[node*2+1] = lazy[node];                // Mark child as lazy\n\t\t\t\t\t        }\n\t\t\t\t\t        lazy[node] = true;                                  // Reset it\n\t\t\t\t\t    }\n\t\t\t\t\t    if(start > end || start > r || end < l)              // Current segment is not within range [l, r]\n\t\t\t\t\t        return;\n\t\t\t\t\t    if(start >= l && end <= r)\n\t\t\t\t\t    {\n\t\t\t\t\t        // Segment is fully within range\n\t\t\t\t\t        st[node] =  val;\n\t\t\t\t\t        if(start != end)\n\t\t\t\t\t        {\n\t\t\t\t\t            // Not leaf node\n\t\t\t\t\t            lazy[node*2] = val;\n\t\t\t\t\t            lazy[node*2+1] = val;\n\t\t\t\t\t        }\n\t\t\t\t\t        return;\n\t\t\t\t\t    }\n\t\t\t\t\t    int mid = (start + end) / 2;\n\t\t\t\t\t    updateRange(node*2, start, mid, l, r, val);        // Updating left child\n\t\t\t\t\t    updateRange(node*2 + 1, mid + 1, end, l, r, val);   // Updating right child\n\t\t\t\t\t    st[node] = st[node*2] | st[node*2+1];        // Updating root with max value \n\t\t\t\t\t}\n\t\t\n\t\t\t\t\tboolean queryRange(int node, int start, int end, int l, int r)\n\t\t\t\t\t{\n\t\t\t\t\t    if(start > end || start > r || end < l)\n\t\t\t\t\t        return false;         // Out of range\n\t\t\t\t\t    if(!lazy[node])\n\t\t\t\t\t    {\n\t\t\t\t\t        // This node needs to be updated\n\t\t\t\t\t        st[node] = lazy[node];            // Update it\n\t\t\t\t\t        if(start != end)\n\t\t\t\t\t        {\n\t\t\t\t\t            lazy[node*2] = lazy[node];         // Mark child as lazy\n\t\t\t\t\t            lazy[node*2+1] = lazy[node];    // Mark child as lazy\n\t\t\t\t\t        }\n\t\t\t\t\t        lazy[node] = true;                 // Reset it\n\t\t\t\t\t    }\n\t\t\t\t\t    if(start >= l && end <= r)             // Current segment is totally within range [l, r]\n\t\t\t\t\t        return  st[node];\n\t\t\t\t\t    int mid = (start + end) / 2;\n\t\t\t\t\t    boolean p1 = queryRange(node*2, start, mid, l, r);         // Query left child\n\t\t\t\t\t    boolean b = queryRange(node*2 + 1, mid + 1, end, l, r); // Query right child\n\t\t\t\t\t    return (p1 | b);\n\t\t\t\t\t}\n\t\t\t\t\tvoid print() {\n\t\t\t\t\t\tfor (int i = 0; i < st.length; i++) {\n\t\t\t\t\t\t\tSystem.out.print(st[i]+\" \");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSystem.out.println();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstatic int convert(int x){\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tString str = Integer.toBinaryString(x);\n\t\t\t\t\t//System.out.println(str);\n\t\t\t\t\tfor(int i = 0;i<str.length();i++){\n\t\t\t\t\t\tif(str.charAt(i)=='1'){\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint ans = (int) Math.pow(3, 6-cnt);\n\t\t\t\t\treturn ans;\n\t\t\t\t}\n\t\t\t\tstatic class Node2{\n\t\t\t\t\tNode2 left = null;\n\t\t\t\t\tNode2 right = null;\n\t\t\t\t\tNode2 parent = null;\n\t\t\t\t\tint data;\n\t\t\t\t}\n\t\t\t\tstatic class BinarySearchTree{\n\t\t\t\t\tNode2 root = null;\n\t\t\t\t\tint height = 0;\n\t\t\t\t\tint max = 0;\n\t\t\t\t\tint cnt = 1;\n\t\t\t\t\tArrayList<Integer> parent = new ArrayList<>();\n\t\t\t\t\tHashMap<Integer, Integer> hm = new HashMap<>();\n\t\t\t\t\tpublic void insert(int x){\n\t\t\t\t\t\tNode2 n = new Node2();\n\t\t\t\t\t\tn.data = x;\n\t\t\t\t\t\tif(root==null){\n\t\t\t\t\t\t\troot = n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tNode2 temp = root,temb = null;\n\t\t\t\t\t\t\twhile(temp!=null){\n\t\t\t\t\t\t\t\ttemb = temp;\n\t\t\t\t\t\t\t\tif(x>temp.data) temp = temp.right;\n\t\t\t\t\t\t\t\telse temp = temp.left;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(x>temb.data) temb.right = n;\n\t\t\t\t\t\t\telse temb.left = n;\n\t\t\t\t\t\t\tn.parent = temb;\n\t\t\t\t\t\t\tparent.add(temb.data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpublic Node2 getSomething(int x, int y, Node2 n){\n\t\t\t\t\t\tif(n.data==x || n.data==y) return n;\n\t\t\t\t\t\telse if(n.data>x && n.data<y) return n;\n\t\t\t\t\t\telse if(n.data<x && n.data<y) return getSomething(x,y,n.right);\n\t\t\t\t\t\telse return getSomething(x,y,n.left);\n\t\t\t\t\t}\n\t\t\t\t\tpublic Node2 search(int x,Node2 n){\n\t\t\t\t\t\tif(x==n.data){\n\t\t\t\t\t\t\tmax = Math.max(max, n.data);\n\t\t\t\t\t\t\treturn n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(x>n.data){\n\t\t\t\t\t\t\tmax = Math.max(max, n.data);\n\t\t\t\t\t\t\treturn search(x,n.right);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tmax = Math.max(max, n.data);\n\t\t\t\t\t\t\treturn search(x,n.left);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpublic int getHeight(Node2 n){\n\t\t\t\t\t\tif(n==null) return 0;\n\t\t\t\t\t\theight = 1+ Math.max(getHeight(n.left), getHeight(n.right));\n\t\t\t\t\t\treturn height;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstatic long findDiff(long[] arr, long[] brr, int m){\n\t\t\t\t\tint i = 0, j = 0;\n\t\t\t\t\tlong fa = 1000000000000L;\n\t\t\t\t\twhile(i<m && j<m){\n\t\t\t\t\t\tlong x = arr[i]-brr[j];\n\t\t\t\t\t\tif(x>=0){\n\t\t\t\t\t\t\tif(x<fa) fa = x;\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tif((-x)<fa) fa = -x;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn fa;\n\t\t\t\t}\n\t\t\t\tpublic static long max(long x, long y, long z){\n\t\t\t\t\tif(x>=y && x>=z) return x;\n\t\t\t\t\tif(y>=x && y>=z) return y;\n\t\t\t\t\treturn z;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstatic long modInverse(long a, long mOD2){\n\t\t\t\t            return  power(a, mOD2-2, mOD2);\n\t\t\t\t}\n\t\t\t\tstatic long power(long x, long y, long m)\n\t\t\t\t{\n\t\t\t\t    if (y == 0)\n\t\t\t\t        return 1;\n\t\t\t\t    long p = power(x, y/2, m) % m;\n\t\t\t\t    p = (p * p) % m;\n\t\t\t\t \n\t\t\t\t    return (y%2 == 0)? p : (x * p) % m;\n\t\t\t\t}\n\t\t\t\tstatic long d,x,y;\n\t\t\t\tpublic static void extendedEuclidian(long a, long b){\n\t\t\t\t\tif(b == 0) {\n\t\t\t\t        d = a;\n\t\t\t\t        x = 1;\n\t\t\t\t        y = 0;\n\t\t\t\t    }\n\t\t\t\t    else {\n\t\t\t\t        extendedEuclidian(b, a%b);\n\t\t\t\t        int temp = (int) x;\n\t\t\t\t        x = y;\n\t\t\t\t        y = temp - (a/b)*y;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpublic static long gcd(long n, long m){\n\t\t\t\t\tif(m!=0) return gcd(m,n%m);\n\t\t\t\t\telse return n;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstatic BufferedReader reader;\n\t\t\t    static StringTokenizer tokenizer;\n\t\t\t    static PrintWriter writer;\n\t\t\t\n\t\t\t\n\t\t\t   \n\t\t\t    static class FasterScanner {\n\t\t\n\t\t\t\t\tprivate final InputStream stream;\n\t\t\t\t\tprivate final byte[] buf = new byte[8192];\n\t\t\t\t\tprivate int curChar, snumChars;\n\t\t\t\t\tprivate SpaceCharFilter filter;\n\t\t\n\t\t\t\t\tpublic FasterScanner(InputStream stream) {\n\t\t\t\t\t\tthis.stream = stream;\n\t\t\t\t\t}\n\t\t\n\t\t\t\t\tpublic int snext() {\n\t\t\t\t\t\tif (snumChars == -1)\n\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\tif (curChar >= snumChars) {\n\t\t\t\t\t\t\tcurChar = 0;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn buf[curChar++];\n\t\t\t\t\t}\n\t\t\n\t\t\t\t\tpublic int nextInt() {\n\t\t\t\t\t\tint c = snext();\n\t\t\t\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\t\t\t\tc = snext();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint sgn = 1;\n\t\t\t\t\t\tif (c == '-') {\n\t\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\t\tc = snext();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint res = 0;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\t\tc = snext();\n\t\t\t\t\t\t} while (!isSpaceChar(c));\n\t\t\t\t\t\treturn res * sgn;\n\t\t\t\t\t}\n\t\t\n\t\t\t\t\tpublic long nextLong() {\n\t\t\t\t\t\tint c = snext();\n\t\t\t\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\t\t\t\tc = snext();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint sgn = 1;\n\t\t\t\t\t\tif (c == '-') {\n\t\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\t\tc = snext();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlong res = 0;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\t\tc = snext();\n\t\t\t\t\t\t} while (!isSpaceChar(c));\n\t\t\t\t\t\treturn res * sgn;\n\t\t\t\t\t}\n\t\t\n\t\t\t\t\tpublic int[] nextIntArray(int n) {\n\t\t\t\t\t\tint a[] = new int[n];\n\t\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\t\ta[i] = nextInt();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn a;\n\t\t\t\t\t}\n\t\t\n\t\t\t\t\tpublic long[] nextLongArray(int n) {\n\t\t\t\t\t\tlong a[] = new long[n];\n\t\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\t\ta[i] = nextLong();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn a;\n\t\t\t\t\t}\n\t\t\t                \n\t\t\t\t\tpublic String readString() {\n\t\t\t\t\t\tint c = snext();\n\t\t\t\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\t\t\t\tc = snext();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tStringBuilder res = new StringBuilder();\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tres.appendCodePoint(c);\n\t\t\t\t\t\t\tc = snext();\n\t\t\t\t\t\t} while (!isSpaceChar(c));\n\t\t\t\t\t\treturn res.toString();\n\t\t\t\t\t}\n\t\t\n\t\t\t\t\tpublic String nextLine() {\n\t\t\t\t\t\tint c = snext();\n\t\t\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\t\t\tc = snext();\n\t\t\t\t\t\tStringBuilder res = new StringBuilder();\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tres.appendCodePoint(c);\n\t\t\t\t\t\t\tc = snext();\n\t\t\t\t\t\t} while (!isEndOfLine(c));\n\t\t\t\t\t\treturn res.toString();\n\t\t\t\t\t}\n\t\t\n\t\t\t\t\tpublic boolean isSpaceChar(int c) {\n\t\t\t\t\t\tif (filter != null)\n\t\t\t\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\t\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t\t\t\t}\n\t\t\n\t\t\t\t\tprivate boolean isEndOfLine(int c) {\n\t\t\t\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t\t\t\t}\n\t\t\n\t\t\t\t\tpublic interface SpaceCharFilter {\n\t\t\t\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}  "
        },
        {
            "language": 1,
            "solution": "n, m = map(int, raw_input().split())\nss = [[] for i in xrange(4)]\nfor i in xrange(n):\n    w, c = map(int, raw_input().split())\n    ss[w].append(c)\ntt = [None]*4\nfor j, s in enumerate(ss):\n    s.sort(reverse=True)\n    t = [0]*len(s)\n    tmp = 0\n    for i, e in enumerate(s):\n        tmp += e\n        t[i] = tmp\n    tt[j] = t\nl = map(len, tt)\nans = 0\ndef f(t, x):\n    if x <= 0:\n        return 0\n    if x <= len(t):\n        return t[x-1]\n    return t[-1] if t else 0\n\nfor k in xrange(l[3]+1):\n    lim = m - 3*k\n    if lim < 0:\n        break\n    def g(x):\n        return f(tt[1], lim - x*2) + f(tt[2], x)\n    if l[1] == 0:\n        ans = max(ans, f(tt[2], lim / 2) + f(tt[3], k))\n        continue\n    if l[2] == 0:\n        ans = max(ans, f(tt[1], lim) + f(tt[3], k))\n        continue\n    left = 0; right = min(l[2], lim/2)+1\n    if right == 1:\n        result = 0\n    elif right >= 2 and g(right-2) < g(right-1):\n        result = right-1\n    elif right >= 2 and g(1) < g(0):\n        result = 0\n    else:\n        while left + 1 < right:\n            mid = (left + right) / 2\n            v1 = g(mid)\n            v2 = g(mid+1)\n            if v1 < v2:\n                left = mid\n            else:\n                right = mid\n        result = left + 1\n    #print left, right, [g(i) for i in xrange(min(l[2], lim/2)+1)], f(tt[3], k)\n    #print g(result), f(tt[3], k)\n    ans = max(ans, g(result) + f(tt[3], k))\nprint ans\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 4 * 1e5;\nlong long int dp[MAX];\npair<int, int> cnts[MAX];\nvector<int> first, second, third;\nvoid sortRev(vector<int> &arr) {\n  sort(arr.begin(), arr.end());\n  reverse(arr.begin(), arr.end());\n}\nint main() {\n  int n, m, w, c;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d%d\", &w, &c);\n    if (w == 1) {\n      first.push_back(c);\n    } else if (w == 2) {\n      second.push_back(c);\n    } else if (w == 3) {\n      third.push_back(c);\n    }\n  }\n  sortRev(first);\n  sortRev(second);\n  sortRev(third);\n  dp[0] = 0;\n  for (int i = 1; i <= m; i++) {\n    dp[i] = dp[i - 1];\n    cnts[i] = cnts[i - 1];\n    if (cnts[i - 1].first < first.size()) {\n      cnts[i] = cnts[i - 1];\n      dp[i] = dp[i - 1] + first[cnts[i].first];\n      cnts[i].first++;\n    }\n    if (i >= 2) {\n      if (cnts[i - 2].second < second.size()) {\n        long long int ones = 0;\n        int last = cnts[i].first;\n        if (last >= 2) {\n          ones += first[last - 1] + first[last - 2];\n        } else if (last >= 1) {\n          ones += first[last - 1];\n        }\n        if ((dp[i - 2] + second[cnts[i - 2].second]) >= dp[i]) {\n          cnts[i] = cnts[i - 2];\n          dp[i] = dp[i - 2] + second[cnts[i - 2].second];\n          cnts[i].second++;\n        }\n      }\n    }\n  }\n  long long int curr = 0, ans = dp[m];\n  for (int i = 0; i < third.size(); i++) {\n    curr += third[i];\n    int x = m - (3 * (i + 1));\n    if (x >= 0) {\n      ans = max(ans, dp[x] + curr);\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MX = 3e5 + 69;\nconst int inf = 1e9 + 5;\nconst long long mod = 1e9 + 7;\nconst long double eps = 1e-7;\nint n, c;\nlong long f[MX];\nstruct fuck {\n  long long w, c, dif;\n} a[MX];\nint p[11], l[11];\nvector<long long> v[11];\nvector<pair<long long, long long> > pp;\nlong long dp[4111][1111];\nlong long ok = 1;\nlong long fu(int id, int k) {\n  if (id >= pp.size() || id > 3001) {\n    return 0;\n  }\n  if (k == 0) {\n    return 0;\n  }\n  long long &ans = dp[id][k];\n  if (ans != -1) {\n    return ans;\n  }\n  ans = 0;\n  ans = max(ans, fu(id + 1, k));\n  if (k - 3 >= 0 && pp[id].second == 3)\n    ans = max(ans, pp[id].first + fu(id + 1, k - 3));\n  if (k - 2 >= 0 && pp[id].second == 2)\n    ans = max(ans, pp[id].first + fu(id + 1, k - 2));\n  if (k - 1 >= 0 && pp[id].second == 1)\n    ans = max(ans, pp[id].first + fu(id + 1, k - 1));\n  return ans;\n}\nlong long solve(int p1, int p2, int p3, int k) {\n  if (k == 0) {\n    return 0;\n  }\n  if (k > 1003) {\n    if (p3 < l[3] && 2 * v[3][p3] >= 3 * v[2][p2] && v[3][p3] >= 3 * v[1][p1]) {\n      return v[3][p3] + solve(p1, p2, p3 + 1, k - 3);\n    } else if (p2 < l[2] && 3 * v[2][p2] >= 2 * v[3][p3] &&\n               v[2][p2] >= 2 * v[1][p1]) {\n      return v[2][p2] + solve(p1, p2 + 1, p3, k - 2);\n    } else if (p1 < l[1] && 3 * v[1][p1] >= v[3][p3] &&\n               2 * v[1][p1] >= v[2][p2]) {\n      return v[1][p1] + solve(p1 + 1, p2, p3, k - 1);\n    }\n  } else {\n    for (int i = p1; i < min(l[1], p1 + 1533); i++) {\n      pp.push_back({v[1][i], 1});\n    }\n    for (int i = p2; i < min(l[2], p2 + 633); i++) {\n      pp.push_back({v[2][i], 2});\n    }\n    for (int i = p3; i < min(l[3], p3 + 433); i++) {\n      pp.push_back({v[3][i], 3});\n    }\n    return fu(0, k);\n  }\n}\nbool cmp(fuck a, fuck b) { return (a.dif > b.dif); }\nint main() {\n  cin >> n >> c;\n  for (int i = 0; i < n; i++) {\n    long long w, c;\n    scanf(\"%I64d %I64d\", &w, &c);\n    a[i] = {w, c, 6 * c / w};\n  }\n  sort(a, a + n, cmp);\n  long long k = 0;\n  long long ans = 0;\n  for (int i = 0; i < n; i++) {\n    k += a[i].w;\n    k = min(k, c * 1ll);\n    for (int j = k; j >= max(a[i].w, k - 20); j--) {\n      f[j] = max(f[j], f[j - a[i].w] + a[i].c);\n      ans = max(ans, f[j]);\n    }\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100000 + 10;\nconst int M = 1000000007;\nconst double PI = atan(1) * 4;\nconst int oo = 1000000000;\nint n, m;\nvector<long long> v[4];\nint main() {\n  cin >> n >> m;\n  for (int a, b, i = 0; i < n; ++i) {\n    scanf(\"%d%d\", &a, &b);\n    v[a].push_back(b);\n  }\n  for (int i = 0; i < 4; ++i) {\n    sort(v[i].rbegin(), v[i].rend());\n    v[i].insert(v[i].begin(), 0);\n    for (int j = 1; j < v[i].size(); ++j) v[i][j] += v[i][j - 1];\n  }\n  long long answer = 0;\n  for (int i = 0; i < v[3].size() && i <= m / 3; ++i) {\n    long long ans = v[3][i], bst = 0;\n    int lo = 0, hi = v[2].size() - 1, md1, md2, lf = m - 3 * i;\n    hi = min(hi, lf / 2);\n    while (lo <= hi) {\n      md1 = (2 * lo + hi) / 3;\n      md2 = (lo + 2 * hi) / 3;\n      long long an1 = v[2][md1] + v[1][min((int)v[1].size() - 1, lf - 2 * md1)];\n      long long an2 = v[2][md2] + v[1][min((int)v[1].size() - 1, lf - 2 * md2)];\n      bst = max(bst, max(an1, an2));\n      if (an1 > an2)\n        hi = md2 - 1;\n      else\n        lo = md1 + 1;\n    }\n    answer = max(answer, ans + bst);\n  }\n  cout << answer << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class DP {\n        long cost;\n        int i1;\n        int i2;\n    }\n\n    static DP dp[];\n    static ArrayList<Integer> w1;\n    static ArrayList<Integer> w2;\n    static ArrayList<Integer> w3;\n\n    static void build(int w) {\n        int w1Size = w1.size();\n        int w2Size = w2.size();\n\n        dp[0].cost = 0; dp[0].i1 = 0; dp[0].i2 = 0;\n        if (w1Size == 0) {\n            dp[1].cost = 0; dp[1].i1 = 0; dp[1].i2 = 0;\n        } else {\n            dp[1].cost = w1.get(0); dp[1].i1 = 1; dp[1].i2 = 0;\n        }\n        for (int i = 2; i <= w; i++) {\n            if (dp[i - 1].i1 >= w1Size && dp[i - 2].i2 >= w2Size) dp[i] = dp[i - 1];\n            else if (dp[i - 1].i1 >= w1Size) {\n                long cost1 = dp[i - 1].cost;\n                long cost2 = dp[i - 2].cost + w2.get(dp[i - 2].i2);\n                if (cost1 >= cost2) {\n                    dp[i].cost = cost1; dp[i].i1 = dp[i - 1].i1; dp[i].i2 = dp[i - 1].i2;\n                } else {\n                    dp[i].cost = cost2; dp[i].i1 = dp[i - 2].i1; dp[i].i2 = dp[i - 2].i2 + 1;\n                }\n            } else if (dp[i - 2].i2 >= w2Size) {\n                dp[i].cost = dp[i - 1].cost + w1.get(dp[i - 1].i1); dp[i].i1 = dp[i - 1].i1 + 1; dp[i].i2 = dp[i - 1].i2;\n            } else {\n                long cost1 = dp[i - 1].cost + w1.get(dp[i - 1].i1);\n                long cost2 = dp[i - 2].cost + w2.get(dp[i - 2].i2);\n                if (cost1 >= cost2) {\n                    dp[i].cost = cost1; dp[i].i1 = dp[i - 1].i1 + 1; dp[i].i2 = dp[i - 1].i2;\n                } else {\n                    dp[i].cost = cost2; dp[i].i1 = dp[i - 2].i1; dp[i].i2 = dp[i - 2].i2 + 1;\n                }\n            }\n        }\n    }\n    static void solve() throws IOException {\n//        input = new BufferedReader(new FileReader(\"/home/noberel/Downloads/Software Construction/problems/src/main/java/input\"));\n//        output = new BufferedWriter((new FileWriter(\"/home/noberel/Downloads/Software Construction/problems/src/main/java/output\")));\n        rl();\n        int n = ni2(), m = ni2();\n        dp = new DP[m + 1]; for (int i = 0; i < m + 1; i++) dp[i] = new DP();\n        w1 = new ArrayList<>();\n        w2 = new ArrayList<>();\n        w3 = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            rl();\n            int w = ni2(), c = ni2();\n            if (w == 1) w1.add(c);\n            else if (w == 2) w2.add(c);\n            else w3.add(c);\n        }\n        w1.sort((x, y) -> Integer.compare(y, x));\n        w2.sort((x, y) -> Integer.compare(y, x));\n        w3.sort((x, y) -> Integer.compare(y, x));\n\n        build(m);\n//        System.out.println(w1); System.out.println(w2); System.out.println(w3);\n//        for (int i = 0; i <= m; i++) System.out.println(i + \": \" + dp[i].cost + \" \" + dp[i].i1 + \" \" + dp[i].i2);\n        long maxCost = dp[m].cost;\n        int w3Size = w3.size();\n        long sum = 0;\n        for (int i = 0; i < w3Size; i++) {\n            int currW = m - 3 * (i + 1);\n            if (currW < 0) break;\n            sum += w3.get(i);\n            maxCost = Math.max(maxCost, sum + dp[currW].cost);\n        }\n        ans.append(maxCost).append('\\n');\n\n        output.write(ans.toString());\n        output.flush();\n        output.close();\n    }\n\n    public static void main(String[] args) throws IOException {\n        new Main().solve();\n    }\n\n    static BufferedReader input = new BufferedReader(new InputStreamReader(System.in));\n    static BufferedWriter output = new BufferedWriter(new OutputStreamWriter(System.out));\n    static StringBuilder ans = new StringBuilder();\n    static String line;\n    static StringTokenizer stringTokenizer;\n\n    static int ni1() throws IOException {\n        return Integer.parseInt(input.readLine());\n    }\n\n    static int ni2() throws IOException {\n        return Integer.parseInt(stringTokenizer.nextToken());\n    }\n\n    static long nl1() throws IOException {\n        return Long.parseLong(input.readLine());\n    }\n\n    static long nl2() {\n        return Long.parseLong(stringTokenizer.nextToken());\n    }\n\n    static void rl() throws IOException {\n        stringTokenizer = new StringTokenizer(input.readLine());\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 3e5 + 5;\nint w[maxn], c[maxn];\nvector<int> v[4];\nstruct data {\n  long long v, l, r;\n  bool operator>(const data &rhs) const { return v > rhs.v; }\n  bool operator<(const data &rhs) const { return v < rhs.v; }\n  data operator+(const data &rhs) const {\n    return data(v + rhs.v, l + rhs.l, r + rhs.r);\n  }\n  data() {}\n  data(long long a, int b, int c) : v(a), l(b), r(c) {}\n} dp[maxn];\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 0; i < n; ++i)\n    scanf(\"%d %d\", &w[i], &c[i]), v[w[i]].push_back(c[i]);\n  for (int i = 1; i <= 3; ++i)\n    sort(v[i].begin(), v[i].end()), reverse(v[i].begin(), v[i].end());\n  dp[0] = data(0, -1, -1);\n  for (int i = 0; i < maxn; ++i) {\n    if (i + 1 < maxn && dp[i].l + 1 < v[1].size())\n      dp[i + 1] = max(dp[i + 1], dp[i] + data(v[1][dp[i].l + 1], 1, 0));\n    if (i + 2 < maxn && dp[i].r + 1 < v[2].size())\n      dp[i + 2] = max(dp[i + 2], dp[i] + data(v[2][dp[i].r + 1], 0, 1));\n  }\n  for (int i = 1; i < maxn; ++i) dp[i] = max(dp[i], dp[i - 1]);\n  long long s = 0, ans = 0;\n  for (int i = 0; i <= v[3].size(); ++i) {\n    if (m - 3 * i < 0) continue;\n    ans = max(ans, s + dp[m - 3 * i].v);\n    if (i < v[3].size()) s += v[3][i];\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint qt[4];\nvector<long long> c[4];\nbool comp(long long a, long long b) { return a > b; }\nlong long ts(int m) {\n  int lo = 0, up = c[2].size() - 1;\n  long long ret = 0;\n  while (lo <= up) {\n    int m1 = lo + (up - lo) / 3;\n    int m2 = up - (up - lo) / 3;\n    if (2 * m2 > m) {\n      up = m2 - 1;\n      continue;\n    }\n    long long f1 = c[2][m1] + c[1][min((int)c[1].size() - 1, m - 2 * m1)];\n    long long f2 = c[2][m2] + c[1][min((int)c[1].size() - 1, m - 2 * m2)];\n    if (f1 > f2) {\n      up = m2 - 1;\n      ret = f1;\n    } else {\n      lo = m1 + 1;\n      ret = f2;\n    }\n  }\n  return ret;\n}\nint main() {\n  int n, m;\n  while (scanf(\"%d%d\", &n, &m) > 0) {\n    for (int i = 1; i <= 3; i++) {\n      c[i].clear();\n      c[i].push_back(0);\n    }\n    while (n--) {\n      int w, _c;\n      scanf(\"%d%d\", &w, &_c);\n      c[w].push_back(_c);\n    }\n    for (int i = 1; i <= 3; i++) {\n      sort(++c[i].begin(), c[i].end(), comp);\n      for (int j = 1; j < c[i].size(); j++) {\n        c[i][j] += c[i][j - 1];\n      }\n    }\n    long long ans = 0;\n    for (int i = 0; i < c[3].size() and 3 * i <= m; i++) {\n      ans = max(ans, c[3][i] + ts(m - 3 * i));\n    }\n    printf(\"%lld\\n\", ans);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 7;\nint n, m, sum;\nlong long ans, pre[4][N];\nvector<int> a[4];\nlong long check(int mid, int have) {\n  int one = have - 3 * mid;\n  if (one > a[1].size()) one = a[1].size();\n  return pre[3][mid] + pre[1][one];\n}\nlong long del(int have) {\n  int l = 0, r = a[3].size();\n  r = min(r, have / 3);\n  while (l < r - 1) {\n    int mid = l + r >> 1, mid2 = r + mid >> 1;\n    if (check(mid, have) > check(mid2, have))\n      r = mid2;\n    else\n      l = mid;\n  }\n  return max(max(check(l, have), check(r, have)),\n             max(check(0, have), check(min(r, have / 3), have)));\n  ;\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  a[1].push_back(0), a[2].push_back(0), a[3].push_back(0);\n  for (int i = 1; i <= n; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    a[x].push_back(y);\n    sum += x, ans += y;\n  }\n  if (m >= sum) {\n    printf(\"%lld\\n\", ans);\n    return 0;\n  }\n  ans = 0;\n  sort(a[1].begin(), a[1].end(), greater<int>());\n  sort(a[2].begin(), a[2].end(), greater<int>());\n  sort(a[3].begin(), a[3].end(), greater<int>());\n  for (int k = 1; k <= 3; k++)\n    for (int i = 0; i <= a[k].size() - 1; i++)\n      pre[k][i + 1] = pre[k][i] + a[k][i];\n  for (int i = 0; i <= a[2].size(); i++)\n    if (i * 2 <= m) ans = max(ans, del(m - i * 2) + pre[2][i]);\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 3e5 + 10;\nint w[maxn], c[maxn];\nvector<long long> adj[4];\nlong long f(int m, int t) {\n  return adj[2][t] + adj[1][min((int)adj[1].size() - 1, (m - 2 * t))];\n}\nlong long get(int m) {\n  int lo = 0, hi = min(m / 2, (int)adj[2].size() - 1);\n  while (lo < hi) {\n    int mid = (lo + hi) / 2;\n    if (f(m, mid) < f(m, mid + 1))\n      lo = mid + 1;\n    else\n      hi = mid;\n  }\n  return f(m, lo);\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  adj[1].push_back(0);\n  adj[2].push_back(0);\n  adj[3].push_back(0);\n  for (int i = 1; i <= n; ++i) {\n    cin >> w[i] >> c[i];\n    adj[w[i]].push_back(c[i]);\n  }\n  for (int i = 1; i <= 3; ++i) {\n    sort(adj[i].begin(), adj[i].end());\n    reverse(adj[i].begin() + 1, adj[i].end());\n    for (int j = 1; j < adj[i].size(); ++j) {\n      adj[i][j] += adj[i][j - 1];\n    }\n  }\n  long long ans = 0;\n  long long acc = 0;\n  for (int i = 0; i < adj[3].size() && 3 * i <= m; ++i) {\n    acc = adj[3][i];\n    ans = max(ans, acc + get(m - 3 * i));\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\n@SuppressWarnings(\"unchecked\")\npublic class P808E {\n\n  final static int DIST = 125;\n\n  public void run() throws Exception {\n    int n = nextInt(), m = nextInt();\n    int [][] wca = new int [n][2];\n    int l1 = 0, l2 = 0, l3 = 0;\n    for (int i = 0; i < n; i++) {\n      wca[i] = readInt(2);\n      if (wca[i][0] == 1) {\n        l1++;\n      } else if (wca[i][0] == 2) {\n        l2++;\n      } else {\n        l3++;\n      }\n    }\n\n    Arrays.sort(wca, new Comparator<int []>() {\n      public int compare(int [] a, int [] b) {\n        return (b[1] - a[1]);\n      }\n    });\n\n    int [] c1 = new int [l1], c2 = new int [l2], c3 = new int [l3];\n    int i1 = 0, i2 = 0, i3 = 0;\n    for (int [] wc : wca) {\n      if (wc[0] == 1) {\n        c1[i1++] = wc[1];\n      } else if (wc[0] == 2) {\n        c2[i2++] = wc[1];\n      } else {\n        c3[i3++] = wc[1];\n      }\n    }\n\n    int mm = m;\n    i1 = i2 = i3 = 0;\n    while (true) {\n      int k1 = ((i1 < l1) && (mm >= 1)) ? c1[i1] : 0;\n      int k2 = ((i2 < l2) && (mm >= 2)) ? c2[i2] : 0;\n      int k3 = ((i3 < l3) && (mm >= 3)) ? c3[i3] : 0;\n\n      if ((k1 | k2 | k3) == 0) {\n        break;\n      } else if ((2.0 * k1 >= k2) && (3.0 * k1 >= k3)) {\n        i1++;\n        mm -= 1;\n      } else if ((k2 >= 2.0 * k1) && (3.0 * k2 >= 2.0 * k3)) {\n        i2++;\n        mm -= 2;\n      } else {\n        i3++;\n        mm -= 3;\n      }\n    }\n\n    long [] s1 = new long [l1 + 1], s2 = new long [l2 + 1], s3 = new long [l3 + 1];\n    for (int i = 0; i < l1; s1[i + 1] = c1[i] + s1[i], i++);\n    for (int i = 0; i < l2; s2[i + 1] = c2[i] + s2[i], i++);\n    for (int i = 0; i < l3; s3[i + 1] = c3[i] + s3[i], i++);\n\n    long s = 0;\n    for (int d1 = -DIST; d1 <= DIST; d1++) {\n      for (int d2 = -DIST; d2 <= DIST; d2++) {\n        for (int d3 = -DIST; d3 <= DIST; d3++) {\n          int j1 = i1 + d1, j2 = i2 + d2, j3 = i3 + d3;\n\n          if ((j1 >= 0) && (j2 >= 0) && (j3 >= 0) &&\n              (j1 <= l1) && (j2 <= l2) && (j3 <= l3) &&\n              ((j1 + 2 * j2 + 3 * j3) <= m)) {\n            s = Math.max(s, s1[j1] + s2[j2] + s3[j3]);\n          }\n        }\n      }\n    }\n\n    println(s);\n  }\n\n  public static void main(String... args) throws Exception {\n    br = new BufferedReader(new InputStreamReader(System.in));\n    pw = new PrintWriter(new BufferedOutputStream(System.out));\n    new P808E().run();\n    br.close();\n    pw.close();\n    System.err.println(\"\\n[Time : \" + (System.currentTimeMillis() - startTime) + \" ms]\");\n  }\n\n  static long startTime = System.currentTimeMillis();\n  static BufferedReader br;\n  static PrintWriter pw;\n  StringTokenizer stok;\n\n  String nextToken() throws IOException {\n    while (stok == null || !stok.hasMoreTokens()) {\n      String s = br.readLine();\n      if (s == null) { return null; }\n      stok = new StringTokenizer(s);\n    }\n    return stok.nextToken();\n  }\n\n  void print(byte b) { print(\"\" + b); }\n  void print(int i) { print(\"\" + i); }\n  void print(long l) { print(\"\" + l); }\n  void print(double d) { print(\"\" + d); }\n  void print(char c) { print(\"\" + c); }\n  void print(Object o) {\n    if (o instanceof int[]) { print(Arrays.toString((int [])o));\n    } else if (o instanceof long[]) { print(Arrays.toString((long [])o));\n    } else if (o instanceof char[]) { print(Arrays.toString((char [])o));\n    } else if (o instanceof byte[]) { print(Arrays.toString((byte [])o));\n    } else if (o instanceof short[]) { print(Arrays.toString((short [])o));\n    } else if (o instanceof boolean[]) { print(Arrays.toString((boolean [])o));\n    } else if (o instanceof float[]) { print(Arrays.toString((float [])o));\n    } else if (o instanceof double[]) { print(Arrays.toString((double [])o));\n    } else if (o instanceof Object[]) { print(Arrays.toString((Object [])o));\n    } else { print(\"\" + o); }\n  }\n  void print(String s) { pw.print(s); }\n  void println() { println(\"\"); }\n  void println(byte b) { println(\"\" + b); }\n  void println(int i) { println(\"\" + i); }\n  void println(long l) { println(\"\" + l); }\n  void println(double d) { println(\"\" + d); }\n  void println(char c) { println(\"\" + c); }\n  void println(Object o) { print(o); println(); }\n  void println(String s) { pw.println(s); }\n  int nextInt() throws IOException { return Integer.parseInt(nextToken()); }\n  long nextLong() throws IOException { return Long.parseLong(nextToken()); }\n  double nextDouble() throws IOException { return Double.parseDouble(nextToken()); }\n  char nextChar() throws IOException { return (char) (br.read()); }\n  String next() throws IOException { return nextToken(); }\n  String nextLine() throws IOException { return br.readLine(); }\n  int [] readInt(int size) throws IOException {\n    int [] array = new int [size];\n    for (int i = 0; i < size; i++) { array[i] = nextInt(); }\n    return array;\n  }\n  long [] readLong(int size) throws IOException {\n    long [] array = new long [size];\n    for (int i = 0; i < size; i++) { array[i] = nextLong(); }\n    return array;\n  }\n  double [] readDouble(int size) throws IOException {\n    double [] array = new double [size];\n    for (int i = 0; i < size; i++) { array[i] = nextDouble(); }\n    return array;\n  }\n  String [] readLines(int size) throws IOException {\n    String [] array = new String [size];\n    for (int i = 0; i < size; i++) { array[i] = nextLine(); }\n    return array;\n  }\n\n  int gcd(int a, int b) {\n    return ((b > 0) ? gcd(b, a % b) : a);\n  }\n  long gcd(long a, long b) {\n    return ((b > 0) ? gcd(b, a % b) : a);\n  }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int P = 1e9 + 7;\nint add(int a, int b) {\n  if ((a += b) >= P) a -= P;\n  return a < 0 ? a + P : a;\n}\nint mul(int a, int b) { return 1ll * a * b % P; }\nint kpow(int a, int b) {\n  int r = 1;\n  for (; b; b >>= 1, a = mul(a, a)) {\n    if (b & 1) r = mul(r, a);\n  }\n  return r;\n}\nbool cmp(pair<int, int> a, pair<int, int> b) {\n  return 1.0 * a.second / a.first > 1.0 * b.second / b.first;\n}\nconst int N = 3e5 + 8;\nlong long dp[N], n, m, s;\npair<int, int> a[N];\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> m;\n  for (int i = (1); i < (n + 1); i++) cin >> a[i].first >> a[i].second;\n  sort(a + 1, a + n + 1, cmp);\n  for (int i = (1); i < (n + 1); i++) {\n    s = min(s + a[i].first, m);\n    for (int j = (s + 1) - 1; j >= (max(1ll * a[i].first, s - 4)); j--)\n      dp[j] = max(dp[j], dp[j - a[i].first] + a[i].second);\n  }\n  long long ans = *max_element(dp, dp + m + 1);\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nstruct State {\n  long long cost;\n  int n1, n2;\n  inline State add(int type, int cost_) const {\n    return type == 1 ? State{cost + cost_, n1 + 1, n2}\n                     : State{cost + cost_, n1, n2 + 1};\n  }\n};\ninline bool operator<(const State& a, const State& b) {\n  return a.cost < b.cost ||\n         (a.cost == b.cost && (a.n2 > b.n2 || (a.n2 == b.n2 && a.n1 > b.n1)));\n}\ninline bool operator>(const State& a, const State& b) { return b < a; }\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  std::cin.tie(0);\n  std::cout.tie(0);\n  std::cerr.tie(0);\n  int n, wmax;\n  std::cin >> n >> wmax;\n  std::vector<int> cost[4];\n  for (int i = 0; i < n; ++i) {\n    int w, c;\n    std::cin >> w >> c;\n    cost[w].push_back(c);\n  }\n  for (int i = 1; i <= 3; ++i) {\n    std::sort(cost[i].begin(), cost[i].end(), std::greater<int>());\n  }\n  std::vector<State> max(1 + wmax, State{0, 0, 0});\n  for (int w = 0; w < wmax; ++w) {\n    auto curr = max[w];\n    max[w + 1] = std::max(max[w + 1], curr);\n    if (w + 1 <= wmax && curr.n1 < (int)cost[1].size()) {\n      max[w + 1] = std::max(max[w + 1], curr.add(1, cost[1][curr.n1]));\n    }\n    if (w + 2 <= wmax && curr.n2 < (int)cost[2].size()) {\n      max[w + 2] = std::max(max[w + 2], curr.add(2, cost[2][curr.n2]));\n    }\n  }\n  std::vector<long long> pref{0};\n  for (auto it : cost[3]) {\n    pref.push_back(pref.back() + it);\n  }\n  long long answ = 0;\n  for (int n3 = 0; wmax - n3 * 3 >= 0 && n3 <= (int)cost[3].size(); ++n3) {\n    answ = std::max(max[wmax - n3 * 3].cost + pref[n3], answ);\n  }\n  std::cout << answ;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\n@SuppressWarnings(\"unchecked\")\npublic class P808E {\n\n  final static int DIST = 60;\n\n  public void run() throws Exception {\n    int n = nextInt(), m = nextInt();\n    int [][] wca = new int [n][2];\n    int l1 = 0, l2 = 0, l3 = 0;\n    for (int i = 0; i < n; i++) {\n      wca[i] = readInt(2);\n      if (wca[i][0] == 1) {\n        l1++;\n      } else if (wca[i][0] == 2) {\n        l2++;\n      } else {\n        l3++;\n      }\n    }\n\n    Arrays.sort(wca, new Comparator<int []>() {\n      public int compare(int [] a, int [] b) {\n        return (b[1] - a[1]);\n      }\n    });\n\n    int [] c1 = new int [l1], c2 = new int [l2], c3 = new int [l3];\n    int i1 = 0, i2 = 0, i3 = 0;\n    for (int [] wc : wca) {\n      if (wc[0] == 1) {\n        c1[i1++] = wc[1];\n      } else if (wc[0] == 2) {\n        c2[i2++] = wc[1];\n      } else {\n        c3[i3++] = wc[1];\n      }\n    }\n\n    int mm = m;\n    i1 = i2 = i3 = 0;\n    while (true) {\n      int k1 = ((i1 < l1) && (mm >= 1)) ? c1[i1] : 0;\n      int k2 = ((i2 < l2) && (mm >= 2)) ? c2[i2] : 0;\n      int k3 = ((i3 < l3) && (mm >= 3)) ? c3[i3] : 0;\n\n      if ((k1 | k2 | k3) == 0) {\n        break;\n      } else if ((2.0 * k1 >= k2) && (3.0 * k1 >= k3)) {\n        i1++;\n        mm -= 1;\n      } else if ((k2 >= 2.0 * k1) && (3.0 * k2 >= 2.0 * k3)) {\n        i2++;\n        mm -= 2;\n      } else {\n        i3++;\n        mm -= 3;\n      }\n    }\n\n    long [] s1 = new long [l1 + 1], s2 = new long [l2 + 1], s3 = new long [l3 + 1];\n    for (int i = 0; i < l1; s1[i + 1] = c1[i] + s1[i], i++);\n    for (int i = 0; i < l2; s2[i + 1] = c2[i] + s2[i], i++);\n    for (int i = 0; i < l3; s3[i + 1] = c3[i] + s3[i], i++);\n\n    long s = 0;\n    for (int d1 = -DIST; d1 <= DIST; d1++) {\n      for (int d2 = -DIST; d2 <= DIST; d2++) {\n        for (int d3 = -DIST; d3 <= DIST; d3++) {\n          int j1 = i1 + d1, j2 = i2 + d2, j3 = i3 + d3;\n\n          if ((j1 >= 0) && (j2 >= 0) && (j3 >= 0) &&\n              (j1 <= l1) && (j2 <= l2) && (j3 <= l3) &&\n              ((j1 + 2 * j2 + 3 * j3) <= m)) {\n            s = Math.max(s, s1[j1] + s2[j2] + s3[j3]);\n          }\n        }\n      }\n    }\n\n    println(s);\n  }\n\n  public static void main(String... args) throws Exception {\n    br = new BufferedReader(new InputStreamReader(System.in));\n    pw = new PrintWriter(new BufferedOutputStream(System.out));\n    new P808E().run();\n    br.close();\n    pw.close();\n    System.err.println(\"\\n[Time : \" + (System.currentTimeMillis() - startTime) + \" ms]\");\n  }\n\n  static long startTime = System.currentTimeMillis();\n  static BufferedReader br;\n  static PrintWriter pw;\n  StringTokenizer stok;\n\n  String nextToken() throws IOException {\n    while (stok == null || !stok.hasMoreTokens()) {\n      String s = br.readLine();\n      if (s == null) { return null; }\n      stok = new StringTokenizer(s);\n    }\n    return stok.nextToken();\n  }\n\n  void print(byte b) { print(\"\" + b); }\n  void print(int i) { print(\"\" + i); }\n  void print(long l) { print(\"\" + l); }\n  void print(double d) { print(\"\" + d); }\n  void print(char c) { print(\"\" + c); }\n  void print(Object o) {\n    if (o instanceof int[]) { print(Arrays.toString((int [])o));\n    } else if (o instanceof long[]) { print(Arrays.toString((long [])o));\n    } else if (o instanceof char[]) { print(Arrays.toString((char [])o));\n    } else if (o instanceof byte[]) { print(Arrays.toString((byte [])o));\n    } else if (o instanceof short[]) { print(Arrays.toString((short [])o));\n    } else if (o instanceof boolean[]) { print(Arrays.toString((boolean [])o));\n    } else if (o instanceof float[]) { print(Arrays.toString((float [])o));\n    } else if (o instanceof double[]) { print(Arrays.toString((double [])o));\n    } else if (o instanceof Object[]) { print(Arrays.toString((Object [])o));\n    } else { print(\"\" + o); }\n  }\n  void print(String s) { pw.print(s); }\n  void println() { println(\"\"); }\n  void println(byte b) { println(\"\" + b); }\n  void println(int i) { println(\"\" + i); }\n  void println(long l) { println(\"\" + l); }\n  void println(double d) { println(\"\" + d); }\n  void println(char c) { println(\"\" + c); }\n  void println(Object o) { print(o); println(); }\n  void println(String s) { pw.println(s); }\n  int nextInt() throws IOException { return Integer.parseInt(nextToken()); }\n  long nextLong() throws IOException { return Long.parseLong(nextToken()); }\n  double nextDouble() throws IOException { return Double.parseDouble(nextToken()); }\n  char nextChar() throws IOException { return (char) (br.read()); }\n  String next() throws IOException { return nextToken(); }\n  String nextLine() throws IOException { return br.readLine(); }\n  int [] readInt(int size) throws IOException {\n    int [] array = new int [size];\n    for (int i = 0; i < size; i++) { array[i] = nextInt(); }\n    return array;\n  }\n  long [] readLong(int size) throws IOException {\n    long [] array = new long [size];\n    for (int i = 0; i < size; i++) { array[i] = nextLong(); }\n    return array;\n  }\n  double [] readDouble(int size) throws IOException {\n    double [] array = new double [size];\n    for (int i = 0; i < size; i++) { array[i] = nextDouble(); }\n    return array;\n  }\n  String [] readLines(int size) throws IOException {\n    String [] array = new String [size];\n    for (int i = 0; i < size; i++) { array[i] = nextLine(); }\n    return array;\n  }\n\n  int gcd(int a, int b) {\n    return ((b > 0) ? gcd(b, a % b) : a);\n  }\n  long gcd(long a, long b) {\n    return ((b > 0) ? gcd(b, a % b) : a);\n  }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n  long long c;\n  int n1, n2, n3;\n  node(long long c = 0, int n1 = 0, int n2 = 0, int n3 = 0)\n      : c(c), n1(n1), n2(n2), n3(n3) {}\n} dp[300005];\nint N, M;\nint v[4][300005];\nint cnt[4];\nvoid update(node &a, node b) {\n  if (a.c < b.c) a = b;\n}\nint main() {\n  cin >> N >> M;\n  int w, x;\n  for (int i = 1; i <= N; i++) {\n    cin >> w >> x;\n    v[w][++cnt[w]] = x;\n  }\n  for (int w = 1; w <= 3; w++) {\n    sort(v[w] + 1, v[w] + cnt[w] + 1, greater<int>());\n  }\n  dp[0] = node(0, 0, 0, 0);\n  long long ans = 0;\n  for (int j = 0; j <= M; j++) {\n    long long c = dp[j].c;\n    int n1 = dp[j].n1, n2 = dp[j].n2, n3 = dp[j].n3;\n    if (j + 1 <= M && n1 < cnt[1])\n      update(dp[j + 1], node(c + v[1][n1 + 1], n1 + 1, n2, n3));\n    if (j + 2 <= M && n2 < cnt[2])\n      update(dp[j + 2], node(c + v[2][n2 + 1], n1, n2 + 1, n3));\n    if (j + 3 <= M && n3 < cnt[3])\n      update(dp[j + 3], node(c + v[3][n3 + 1], n1, n2, n3 + 1));\n    if (j + 2 <= M && n1 && n3 < cnt[3])\n      update(dp[j + 2], node(c - v[1][n1] + v[3][n3 + 1], n1 - 1, n2, n3 + 1));\n    ans = max(ans, c);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint xm[4] = {-1, 1, 0, 0};\nint ym[4] = {0, 0, -1, 1};\nconst int MOD = 1e9 + 7;\nconst int MAXN = 5e5 + 5;\nconst long long POW = 9973;\nstruct nd {\n  long long c;\n  int t1, t2;\n};\nnd dp[MAXN];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<int> ar[4];\n  for (int i = 0; i < n; i++) {\n    int w, c;\n    cin >> w >> c;\n    ar[w].push_back(c);\n  }\n  for (int i = 1; i <= 3; i++) sort(ar[i].begin(), ar[i].end(), greater<int>());\n  int one = ar[1].size();\n  int two = ar[2].size();\n  for (int i = 0; i <= one + two * 2; i++) {\n    if (i == 0)\n      dp[i] = {0, 0, 0};\n    else {\n      dp[i] = dp[i - 1];\n      if (i && dp[i - 1].t1 < one) {\n        if (dp[i - 1].c + ar[1][dp[i - 1].t1] > dp[i].c) {\n          dp[i] = {dp[i - 1].c + ar[1][dp[i - 1].t1], dp[i - 1].t1 + 1,\n                   dp[i - 1].t2};\n        }\n      }\n      if (i >= 2 && dp[i - 2].t2 < two) {\n        if (dp[i - 2].c + ar[2][dp[i - 2].t2] > dp[i].c) {\n          dp[i] = {dp[i - 2].c + ar[2][dp[i - 2].t2], dp[i - 2].t1,\n                   dp[i - 2].t2 + 1};\n        }\n      }\n    }\n  }\n  long long ans = 0;\n  long long tot = 0;\n  for (int i = 0; i <= ar[3].size(); i++) {\n    int rm = m - 3 * i;\n    if (rm < 0) break;\n    ans = max(ans, tot + dp[min(rm, one + two * 2)].c);\n    if (i < ar[3].size()) tot += ar[3][i];\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\npriority_queue<int> unused[3];\npriority_queue<int, vector<int>, greater<int>> used[3];\nconst int M = (int)3e5 + 91;\nlong long mx[M];\nvoid calc() {\n  long long sum = 0;\n  int tw = 0;\n  if (unused[1].empty()) {\n    while (!unused[2].empty()) {\n      sum += unused[2].top();\n      unused[2].pop();\n      tw += 2;\n      mx[tw] = sum;\n    }\n  } else {\n    int t = unused[1].size() + 2 * unused[2].size();\n    int x, y, z;\n    for (int i = 1; i <= t; i++) {\n      if (!unused[1].empty()) {\n        sum += unused[1].top();\n        used[1].push(unused[1].top());\n        unused[1].pop();\n      } else {\n        unused[1].push(used[1].top());\n        sum -= used[1].top();\n        used[1].pop();\n        used[2].push(unused[2].top());\n        sum += unused[2].top();\n        unused[2].pop();\n      }\n      while (used[1].size() >= 2 && unused[2].size() >= 1) {\n        x = used[1].top();\n        used[1].pop();\n        y = used[1].top();\n        used[1].pop();\n        if (x + y < unused[2].top()) {\n          sum -= x + y;\n          sum += unused[2].top();\n          used[2].push(unused[2].top());\n          unused[2].pop();\n          unused[1].push(x);\n          unused[1].push(y);\n        } else {\n          used[1].push(x);\n          used[1].push(y);\n          break;\n        }\n      }\n      mx[i] = sum;\n    }\n  }\n  for (int i = 1; i < M; i++) mx[i] = max(mx[i], mx[i - 1]);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  int n, m;\n  cin >> n >> m;\n  int w, c;\n  vector<int> ss;\n  for (int i = 0; i < n; i++) {\n    cin >> w >> c;\n    if (w < 3) {\n      unused[w].push(c);\n    } else {\n      ss.push_back(c);\n    }\n  }\n  calc();\n  long long answ = mx[m];\n  sort(ss.begin(), ss.end());\n  reverse(ss.begin(), ss.end());\n  long long ssum = 0;\n  for (int i = 0; i < ss.size(); i++) {\n    ssum += ss[i];\n    m -= 3;\n    if (m >= 0) answ = max(answ, ssum + mx[m]);\n  }\n  cout << answ;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100010;\nint w[maxn], c[maxn], arr[4][maxn], top[4], n, m;\nlong long sum[4][maxn];\nstruct Node {\n  long long cost;\n  int i, j;\n} dp[maxn * 3];\nint main() {\n  while (~scanf(\"%d%d\", &n, &m)) {\n    long long ans = 0;\n    for (int i = 1; i <= 3; i++) sum[i][0] = top[i] = 0;\n    for (int i = 1; i <= n; i++) {\n      scanf(\"%d%d\", &w[i], &c[i]);\n      arr[w[i]][++top[w[i]]] = c[i];\n    }\n    for (int i = 1; i <= 3; i++)\n      sort(arr[i] + 1, arr[i] + top[i] + 1, greater<int>());\n    for (int i = 1; i <= 3; i++) {\n      for (int j = 1; j <= top[i]; j++) sum[i][j] = sum[i][j - 1] + arr[i][j];\n    }\n    for (int i = 0; i <= m; i++) dp[i].cost = 0;\n    dp[1].cost = arr[1][1], dp[1].i = 2, dp[1].j = 1;\n    dp[0].i = dp[0].j = 1;\n    for (int j = 2; j <= m; j++) {\n      if (dp[j - 1].cost + (dp[j - 1].i <= top[1] ? arr[1][dp[j - 1].i] : 0) >\n          dp[j - 2].cost + (dp[j - 2].j <= top[2] ? arr[2][dp[j - 2].j] : 0)) {\n        dp[j].cost =\n            dp[j - 1].cost + (dp[j - 1].i <= top[1] ? arr[1][dp[j - 1].i] : 0);\n        dp[j].i = dp[j - 1].i + 1;\n        dp[j].j = dp[j - 1].j;\n      } else {\n        dp[j].cost =\n            dp[j - 2].cost + (dp[j - 2].j <= top[2] ? arr[2][dp[j - 2].j] : 0);\n        dp[j].i = dp[j - 2].i;\n        dp[j].j = dp[j - 2].j + 1;\n      }\n    }\n    for (int i = 0; 3 * i <= m; i++) {\n      ans = max(ans, sum[3][i] + dp[m - 3 * i].cost);\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn = 300003;\nstruct Node {\n  int p1, p2;\n  long long val;\n} d[Maxn];\nint n, m;\nvector<int> save_val[5];\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) {\n    int w, v;\n    scanf(\"%d%d\", &w, &v);\n    save_val[w].push_back(v);\n  }\n  for (int i = 1; i <= 3; ++i)\n    sort(save_val[i].begin(), save_val[i].end(), greater<int>());\n  for (int i = 1; i <= m; ++i) {\n    d[i] = d[i - 1];\n    if (d[i - 1].p1 + 1 <= save_val[1].size() &&\n        d[i - 1].val + save_val[1][d[i - 1].p1] > d[i].val) {\n      d[i].val = d[i - 1].val + save_val[1][d[i - 1].p1];\n      d[i].p1 = d[i - 1].p1 + 1;\n      d[i].p2 = d[i - 1].p2;\n    }\n    if (i > 1 && d[i - 2].p2 + 1 <= save_val[2].size() &&\n        d[i - 2].val + save_val[2][d[i - 2].p2] > d[i].val) {\n      d[i].val = d[i - 2].val + save_val[2][d[i - 2].p2];\n      d[i].p1 = d[i - 2].p1;\n      d[i].p2 = d[i - 2].p2 + 1;\n    }\n  }\n  long long sum = 0, ans = 0;\n  for (int i = 0; i <= save_val[3].size() && i * 3 <= m; ++i) {\n    ans = max(ans, sum + d[m - i * 3].val);\n    if (i < save_val[3].size()) sum += save_val[3][i];\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N, M;\nvector<vector<int> > C;\nvector<vector<long long> > psum;\nint main() {\n  scanf(\"%d %d\", &N, &M);\n  C.resize(3);\n  for (int i = 0; i < N; i++) {\n    int w, c;\n    scanf(\"%d %d\", &w, &c);\n    C[--w].push_back(c);\n  }\n  psum.resize(3);\n  for (int i = 0; i < 3; i++) {\n    sort(C[i].begin(), C[i].end());\n    if (i == 2) reverse(C[i].begin(), C[i].end());\n    psum[i].resize(C[i].size());\n    for (int j = 0; j < C[i].size(); j++) {\n      psum[i][j] = C[i][j];\n      if (j) psum[i][j] += psum[i][j - 1];\n    }\n  }\n  long long ans = 0;\n  int W = M - min((int)C[2].size(), M / 3) * 3;\n  long long cost = 0;\n  for (int i = min((int)C[2].size(), M / 3); i >= 0; i--) {\n    long long tmp = i == 0 ? 0 : psum[2][i - 1];\n    while (W > 1) {\n      if (C[0].size() == 0 && C[1].size() == 0)\n        break;\n      else if (C[0].size() == 0) {\n        W -= 2;\n        cost += C[1].back();\n        C[1].pop_back();\n      } else if (C[1].size() == 0) {\n        W--;\n        cost += C[0].back();\n        C[0].pop_back();\n      } else {\n        int sum = 0;\n        for (int i = 0; i < min(2, (int)C[0].size()); i++)\n          sum += C[0][C[0].size() - 1 - i];\n        if (sum < C[1].back()) {\n          W -= 2;\n          cost += C[1].back();\n          C[1].pop_back();\n        } else {\n          W--;\n          cost += C[0].back();\n          C[0].pop_back();\n        }\n      }\n    }\n    if (W == 1 && C[0].size())\n      ans = max(ans, C[0].back() + cost + tmp);\n    else\n      ans = max(ans, cost + tmp);\n    W += 3;\n  }\n  printf(\"%lld\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long b[4][400000];\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<int> v[4];\n  int id[4] = {0};\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    v[x].push_back(y);\n  }\n  for (int i = 0; i < 4; i++) {\n    sort(v[i].begin(), v[i].end());\n    id[i] = (int)v[i].size() - 1;\n  }\n  memset(b, 0, sizeof(b));\n  int h = id[3];\n  for (int i = 1; i < 400000; i++) {\n    if (h >= 0) {\n      b[3][i] += v[3][h];\n      h--;\n    }\n    if (i > 0) b[3][i] += b[3][i - 1];\n  }\n  h = id[2];\n  for (int i = 1; i < 400000; i++) {\n    if (h >= 0) {\n      b[2][i] += v[2][h];\n      h--;\n    }\n    if (i > 0) b[2][i] += b[2][i - 1];\n  }\n  h = id[1];\n  for (int i = 1; i < 400000; i++) {\n    if (h >= 0) {\n      b[1][i] += v[1][h];\n      h--;\n    }\n    if (i > 0) b[1][i] += b[1][i - 1];\n  }\n  long long maxx = 0;\n  long long PL = 0;\n  for (int i = 0; i <= v[3].size(); i++) {\n    int t = m;\n    t -= i * 3;\n    if (t < 0) break;\n    long long ans = b[3][i];\n    int st = 0, En = min((int)v[2].size(), t / 2);\n    while ((En - st) >= 3) {\n      int step = (En - st) / 3;\n      int mid1 = (st + step);\n      int mid2 = (En - step);\n      int C1 = 0, C2 = 0;\n      C1 = t - mid1 * 2;\n      C2 = t - mid2 * 2;\n      long long EE1 = b[2][mid1];\n      EE1 += (b[1][C1]);\n      long long EE2 = b[2][mid2];\n      EE2 += (b[1][C2]);\n      if (EE1 < EE2) {\n        st = mid1;\n      } else\n        En = mid2;\n    }\n    long long F1 = 0, F2 = 0, F3 = 0;\n    F1 = b[2][st] + b[1][t - st * 2];\n    F2 = b[2][En] + b[1][t - En * 2];\n    if (En - st == 2) F3 = b[2][st + 1] + b[1][t - (st + 1) * 2];\n    long long sum = max(F1, max(F2, F3));\n    sum += ans;\n    maxx = max(maxx, sum);\n  }\n  cout << maxx;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1e18;\nconst double eps = 1e-5;\nconst int mod = 1000;\nconst double pi = acos(-1);\nvector<long long> g[4];\nvector<long long> gg;\nlong long sum[400005];\nint n, m;\nbool cmp(long long a, long long b) { return a > b; }\nint main() {\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    long long w, c;\n    scanf(\"%lld%lld\", &w, &c);\n    g[w].push_back(c);\n  }\n  g[1].push_back(0);\n  for (int i = 1; i <= 3; i++) {\n    sort(g[i].begin(), g[i].end(), cmp);\n  }\n  gg = g[2];\n  for (int i = 1; i < g[1].size(); i += 2) {\n    gg.push_back(g[1][i - 1] + g[1][i]);\n  }\n  sort(gg.begin(), gg.end(), cmp);\n  memset(sum, 0, sizeof(sum));\n  for (int i = 0; i < gg.size(); i++) {\n    sum[i + 1] = sum[i] + gg[i];\n  }\n  for (int i = gg.size() + 1; i < 400005; i++) {\n    sum[i] = sum[i - 1];\n  }\n  long long ans = 0;\n  long long pre = 0;\n  for (int i = 0; i < gg.size(); i++) {\n    if ((i + 1) * 2 > m) break;\n    ans = max(ans, sum[i + 1]);\n  }\n  for (int i = 0; i < g[3].size(); i++) {\n    if ((i + 1) * 3 > m) break;\n    pre += g[3][i];\n    int k = (m - (i + 1) * 3) / 2;\n    ans = max(ans, pre + sum[k]);\n  }\n  gg.clear();\n  gg = g[2];\n  for (int i = 2; i < g[1].size(); i += 2) {\n    gg.push_back(g[1][i - 1] + g[1][i]);\n  }\n  long long tmp = g[1][0];\n  sort(gg.begin(), gg.end(), cmp);\n  memset(sum, 0, sizeof(sum));\n  for (int i = 0; i < gg.size(); i++) {\n    sum[i + 1] = sum[i] + gg[i];\n  }\n  for (int i = gg.size() + 1; i < 400005; i++) {\n    sum[i] = sum[i - 1];\n  }\n  pre = 0;\n  ans = max(ans, tmp);\n  for (int i = 0; i < gg.size(); i++) {\n    if ((i + 1) * 2 + 1 > m) break;\n    ans = max(ans, tmp + sum[i + 1]);\n  }\n  for (int i = 0; i < g[3].size(); i++) {\n    if ((i + 1) * 3 + 1 > m) break;\n    pre += g[3][i];\n    int k = (m - (i + 1) * 3 - 1) / 2;\n    ans = max(ans, pre + tmp + sum[k]);\n  }\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint n, m, tot[4];\nstd::vector<long long> vec[4];\nstruct node {\n  long long val;\n  int cnt1, cnt2;\n  bool operator<(const struct node &rhs) const { return val < rhs.val; }\n} dp[(300010)];\nlong long pre_dp[(300010)];\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) {\n    long long w, c;\n    scanf(\"%I64d%I64d\", &w, &c);\n    vec[w].push_back(c);\n  }\n  for (int i = 1; i <= 3; ++i) {\n    std::sort(vec[i].begin(), vec[i].end(), std::greater<long long>());\n    tot[i] = (int)(vec[i].size());\n  }\n  dp[0] = (node){0, 0, 0};\n  for (int i = 0; i < m; ++i) {\n    long long val = dp[i].val;\n    int cnt1 = dp[i].cnt1;\n    int cnt2 = dp[i].cnt2;\n    if (cnt1 < tot[1] && i + 1 <= m) {\n      dp[i + 1] =\n          std::max(dp[i + 1], (node){val + vec[1][cnt1], cnt1 + 1, cnt2});\n    }\n    if (cnt2 < tot[2] && i + 2 <= m) {\n      dp[i + 2] =\n          std::max(dp[i + 2], (node){val + vec[2][cnt2], cnt1, cnt2 + 1});\n    }\n  }\n  for (int i = 1; i <= m; ++i) {\n    pre_dp[i] = std::max(pre_dp[i - 1], dp[i].val);\n  }\n  long long ans = pre_dp[m], pre = 0;\n  for (int i = 1; i <= tot[3] && 3 * i <= m; ++i) {\n    pre += vec[3][i - 1];\n    ans = std::max(ans, pre + pre_dp[m - 3 * i]);\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <typename T1, typename T2>\ninline void chmin(T1 &x, T2 b) {\n  if (b < x) x = b;\n}\ntemplate <typename T1, typename T2>\ninline void chmax(T1 &x, T2 b) {\n  if (b > x) x = b;\n}\nconst int inf = 1039074182;\nusing namespace std;\nint n, m;\nint w[100005], c[100005];\nvector<int> v1;\nvector<int> v2;\nvector<int> v3;\nlong long best[300005];\nint rk1[100005];\nint rk2[100005];\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    cin >> w[i] >> c[i];\n    if (w[i] == 1) v1.push_back(c[i]);\n    if (w[i] == 2) v2.push_back(c[i]);\n    if (w[i] == 3) v3.push_back(c[i]);\n  }\n  sort(v1.begin(), v1.end());\n  reverse(v1.begin(), v1.end());\n  sort(v2.begin(), v2.end());\n  reverse(v2.begin(), v2.end());\n  sort(v3.begin(), v3.end());\n  reverse(v3.begin(), v3.end());\n  vector<pair<int, pair<int, int> > > vsort;\n  for (int i = 0; i < v1.size(); i++) {\n    vsort.push_back(make_pair(v1[i] * 2, make_pair(1, i)));\n  }\n  for (int i = 0; i < v2.size(); i++) {\n    vsort.push_back(make_pair(v2[i], make_pair(2, i)));\n  }\n  sort(vsort.begin(), vsort.end());\n  reverse(vsort.begin(), vsort.end());\n  for (int i = 0; i < vsort.size(); i++) {\n    if (vsort[i].second.first == 1)\n      rk1[vsort[i].second.second] = i;\n    else\n      rk2[vsort[i].second.second] = i;\n  }\n  long long v12 = 0;\n  int in12 = 0, cost12 = 0;\n  int last1 = 0, last2 = 0;\n  for (int i = 0; i <= m; i++) {\n    while (in12 < vsort.size() && cost12 + vsort[in12].second.first <= i) {\n      cost12 += vsort[in12].second.first;\n      v12 += vsort[in12].first / (3 - vsort[in12].second.first);\n      if (vsort[in12].second.first == 1)\n        last1++;\n      else\n        last2++;\n      in12++;\n    }\n    best[i] = v12;\n    if (cost12 + 1 == i) {\n      if (last1 < v1.size()) best[i] = max(best[i], v12 + v1[last1]);\n      if (last2 < v2.size() && last1)\n        best[i] = max(best[i], v12 - v1[last1 - 1] + v2[last2]);\n    }\n  }\n  long long res = best[m];\n  long long sum = 0;\n  for (int i = 0; i < v3.size(); i++) {\n    if (m - 3 * (i + 1) < 0) break;\n    sum += v3[i];\n    chmax(res, best[m - 3 * (i + 1)] + sum);\n  }\n  cout << res << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\npublic class P {\n\n\tstatic ArrayList<Integer>[] cost;\n\tstatic long[][] pre;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tint M = sc.nextInt();\n\t\tcost = new ArrayList[4];\n\t\tpre = new long[3][300300];\n\t\tfor (int i = 1; i <= 3; i++)\n\t\t\tcost[i] = new ArrayList<Integer>();\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tcost[sc.nextInt()].add(sc.nextInt());\n\n\t\tfor (int i = 1; i <= 3; i++) {\n\t\t\tCollections.sort(cost[i]);\n\t\t\tCollections.reverse(cost[i]);\n\t\t\tfor (int j = 1; j * i <= M; j++) {\n\t\t\t\tif (j - 1 < cost[i].size())\n\t\t\t\t\tpre[i - 1][j] = pre[i - 1][j - 1] + cost[i].get(j - 1);\n\t\t\t\telse\n\t\t\t\t\tpre[i - 1][j] = pre[i - 1][j - 1];\n\t\t\t}\n\t\t}\n\n\t\tlong answer = 0;\n\t\tfor (int z = 0; z * 3 <= M; z++) {\n\t\t\tint total = M - 3 * z;\n\t\t\tint lo = 0;\n\t\t\tint hi = total / 2;\n\t\t\tlong candAnswer = pre[2][z];\n\t\t\twhile (lo < hi) {\n\t\t\t\tint y = (lo + hi) >> 1;\n\t\t\t\tif (f(y, total) >= f(y + 1, total)) {\n\t\t\t\t\thi = y;\n\t\t\t\t} else {\n\t\t\t\t\tlo = y + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcandAnswer += pre[1][hi] + pre[0][total - (2 * hi)];\n\t\t\tanswer = Math.max(candAnswer, answer);\n\t\t}\n\n\t\tSystem.out.println(answer);\n\n\t}\n\n\tstatic long f(int mid, int total) {\n\t\tif (2 * mid > total)\n\t\t\treturn (long) (-1e16);\n\t\treturn pre[1][mid] + pre[0][total - (2 * mid)];\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic Scanner(String f) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(f));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) throws IOException {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic int[] nextIntArray1(int n) throws IOException {\n\t\t\tint[] a = new int[n + 1];\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic int[] shuffle(int[] a, int n) {\n\t\t\tint[] b = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tb[i] = a[i];\n\t\t\tRandom r = new Random();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint j = i + r.nextInt(n - i);\n\t\t\t\tint t = b[i];\n\t\t\t\tb[i] = b[j];\n\t\t\t\tb[j] = t;\n\t\t\t}\n\t\t\treturn b;\n\t\t}\n\n\t\tpublic int[] nextIntArraySorted(int n) throws IOException {\n\t\t\tint[] a = nextIntArray(n);\n\t\t\ta = shuffle(a, n);\n\t\t\tArrays.sort(a);\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) throws IOException {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray1(int n) throws IOException {\n\t\t\tlong[] a = new long[n + 1];\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArraySorted(int n) throws IOException {\n\t\t\tlong[] a = nextLongArray(n);\n\t\t\tRandom r = new Random();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint j = i + r.nextInt(n - i);\n\t\t\t\tlong t = a[i];\n\t\t\t\ta[i] = a[j];\n\t\t\t\ta[j] = t;\n\t\t\t}\n\t\t\tArrays.sort(a);\n\t\t\treturn a;\n\t\t}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\npair<int, int> f[3 * 110000];\nlong long sumx[110000], sumy[110000], sumz[110000];\nint n, m, w, c, x[110000], y[110000], z[110000];\nbool cmp(int a, int b) { return a > b; }\npair<int, int> add(pair<int, int> a, int k) {\n  if (k == 1)\n    a.first++;\n  else\n    a.second++;\n  a.first = min(a.first, x[0]);\n  a.second = min(a.second, y[0]);\n  return a;\n}\nlong long sum(pair<int, int> a) { return sumx[a.first] + sumy[a.second]; }\npair<int, int> max(pair<int, int> a, pair<int, int> b) {\n  if (sum(a) >= sum(b))\n    return a;\n  else\n    return b;\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d%d\", &w, &c);\n    if (w == 1) x[++x[0]] = c;\n    if (w == 2) y[++y[0]] = c;\n    if (w == 3) z[++z[0]] = c;\n  }\n  sort(x + 1, x + x[0] + 1, cmp);\n  sort(y + 1, y + y[0] + 1, cmp);\n  sort(z + 1, z + z[0] + 1, cmp);\n  for (int i = 1; i <= n; i++) {\n    sumx[i] = sumx[i - 1] + x[i];\n    sumy[i] = sumy[i - 1] + y[i];\n    sumz[i] = sumz[i - 1] + z[i];\n  }\n  f[0] = pair<int, int>(0, 0);\n  f[1] = add(f[0], 1);\n  for (int i = 2; i <= m; i++) f[i] = max(add(f[i - 1], 1), add(f[i - 2], 2));\n  long long ans = 0;\n  for (int i = 0; 3 * i <= m; i++) ans = max(ans, sumz[i] + sum(f[m - 3 * i]));\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long> v[5];\nstruct Node {\n  long long val, idx1, idx2;\n} dp[300100];\nint main() {\n  long long n, m;\n  cin >> n >> m;\n  for (long long i = 0; i < n; i++) {\n    long long w, c;\n    cin >> w >> c;\n    v[w].push_back(c);\n  }\n  for (int i = 1; i <= 3; i++) sort(v[i].rbegin(), v[i].rend());\n  dp[0] = {0, 0, 0};\n  for (int i = 1; i <= m; i++) {\n    if (i - 1 >= 0 && dp[i - 1].idx1 + 1 <= v[1].size())\n      dp[i] = {dp[i - 1].val + v[1][dp[i - 1].idx1], dp[i - 1].idx1 + 1,\n               dp[i - 1].idx2};\n    if (i - 2 >= 0 && dp[i - 2].idx2 + 1 <= v[2].size() &&\n        dp[i - 2].val + v[2][dp[i - 2].idx2] > dp[i].val)\n      dp[i] = {dp[i - 2].val + v[2][dp[i - 2].idx2], dp[i - 2].idx1,\n               dp[i - 2].idx2 + 1};\n    if (i - 2 >= 0 && dp[i - 2].idx1 + 2 <= v[1].size() &&\n        dp[i - 2].val + v[1][dp[i - 2].idx1] + v[1][dp[i - 2].idx1 + 1] >\n            dp[i].val)\n      dp[i] = {dp[i - 2].val + v[1][dp[i - 2].idx1] + v[1][dp[i - 2].idx1 + 1],\n               dp[i - 2].idx1 + 2, dp[i - 2].idx2};\n  }\n  for (int i = 1; i <= m; i++) dp[i].val = max(dp[i].val, dp[i - 1].val);\n  long long sum = 0, j = 1, Ans = dp[m].val;\n  for (int i = 0; i < v[3].size() && j * 3 <= m; i++) {\n    sum += v[3][i];\n    Ans = max(Ans, sum + dp[m - 3 * j].val);\n    j++;\n  }\n  cout << Ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, m, ai, bi;\nvector<long long> one, two, three;\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin >> n >> m;\n  for (long long i = 0; i < n; i++) {\n    cin >> ai >> bi;\n    if (ai == 3)\n      three.push_back(bi);\n    else if (ai == 2)\n      two.push_back(bi);\n    else\n      one.push_back(bi);\n  }\n  sort(one.begin(), one.end(), greater<long long>());\n  sort(two.begin(), two.end(), greater<long long>());\n  sort(three.begin(), three.end(), greater<long long>());\n  vector<vector<long long> > answer;\n  for (long long i = 0; i <= m; i++) {\n    vector<long long> help;\n    help.push_back(-100000000000000000);\n    help.push_back(-1);\n    help.push_back(-1);\n    answer.push_back(help);\n  }\n  answer[0][0] = 0;\n  answer[0][1] = 0;\n  answer[0][2] = 0;\n  for (long long i = 0; i <= m; i++) {\n    if (answer[i][1] == -1) continue;\n    if (answer[i][1] < one.size()) {\n      long long v = answer[i][0] + one[answer[i][1]];\n      if (i + 1 <= m && answer[i + 1][0] < v) {\n        answer[i + 1][0] = v;\n        answer[i + 1][1] = answer[i][1] + 1;\n        answer[i + 1][2] = answer[i][2];\n      }\n    }\n    if (answer[i][2] < two.size()) {\n      long long v = answer[i][0] + two[answer[i][2]];\n      if (i + 2 <= m && answer[i + 2][0] < v) {\n        answer[i + 2][0] = v;\n        answer[i + 2][1] = answer[i][1];\n        answer[i + 2][2] = answer[i][2] + 1;\n      }\n    }\n  }\n  long long ans = 0;\n  long long summ = 0;\n  long long maximum = 0;\n  for (long long i = 0; i <= m; i++) {\n    maximum = max(maximum, answer[i][0]);\n    answer[i][0] = maximum;\n  }\n  for (long long i = 0; i <= three.size(); i++) {\n    if (3 * i > m) break;\n    if (i > 0) summ += three[i - 1];\n    if (summ + answer[m - 3 * i][0] > ans) {\n      ans = summ + answer[m - 3 * i][0];\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\npriority_queue<int> q[4];\nint n, w;\nlong long dp[4][300003];\nvoid fun1() {\n  int k = q[1].size();\n  for (int i = 1; i <= k && i <= w; i++) {\n    dp[1][i] = dp[1][i - 1] + q[1].top();\n    q[1].pop();\n  }\n  for (int i = k + 1; i <= w; i++) dp[1][i] = dp[1][i - 1];\n}\nvoid fun2() {\n  int k = q[2].size();\n  long long c, l = 1, sum = 0, t = 0;\n  for (int i = 1; i <= k && i <= w; i++) {\n    c = q[2].top();\n    q[2].pop();\n    for (int j = l; j <= w; j++) {\n      l = j;\n      if (j >= 2 * (t + 1) &&\n          dp[1][j - t * 2] + sum < dp[1][j - t * 2 - 2] + sum + c) {\n        dp[2][j] = sum + c + dp[1][j - t * 2 - 2];\n        t++;\n        sum += c;\n        break;\n      } else {\n        dp[2][j] = sum + dp[1][j - t * 2];\n      }\n    }\n  }\n  for (int j = l; j <= w; j++) {\n    dp[2][j] = sum + dp[1][j - t * 2];\n  }\n}\nvoid fun3() {\n  long long sum = 0, t = 0;\n  dp[3][w] = dp[2][w];\n  while (q[3].size()) {\n    t += 3;\n    sum += q[3].top();\n    q[3].pop();\n    if (t <= w) {\n      dp[3][w] = max(dp[3][w], dp[2][w - t] + sum);\n    }\n  }\n}\nint main() {\n  cin >> n >> w;\n  int ww, c;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d%d\", &ww, &c);\n    if (ww == 1)\n      q[1].push(c);\n    else if (ww == 2)\n      q[2].push(c);\n    else\n      q[3].push(c);\n  }\n  fun1();\n  fun2();\n  fun3();\n  cout << dp[3][w];\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 29;\nconst long long LINF = 1LL << 60;\nlong long mod = 1e9 + 7;\nchar READ_DATA;\nint SIGNAL_INPUT;\ntemplate <typename Type>\ninline Type ru(Type &v) {\n  SIGNAL_INPUT = 1;\n  while ((READ_DATA = getchar()) < '0' || READ_DATA > '9')\n    if (READ_DATA == '-')\n      SIGNAL_INPUT = -1;\n    else if (READ_DATA == EOF)\n      return EOF;\n  v = READ_DATA - '0';\n  while ((READ_DATA = getchar()) >= '0' && READ_DATA <= '9')\n    v = v * 10 + READ_DATA - '0';\n  v *= SIGNAL_INPUT;\n  return v;\n}\ninline long long modru(long long &v) {\n  long long p = 0;\n  SIGNAL_INPUT = 1;\n  while ((READ_DATA = getchar()) < '0' || READ_DATA > '9')\n    if (READ_DATA == '-')\n      SIGNAL_INPUT = -1;\n    else if (READ_DATA == EOF)\n      return EOF;\n  p = v = READ_DATA - '0';\n  while ((READ_DATA = getchar()) >= '0' && READ_DATA <= '9') {\n    v = (v * 10 + READ_DATA - '0') % mod;\n    p = (p * 10 + READ_DATA - '0') % (mod - 1);\n  }\n  v *= SIGNAL_INPUT;\n  return p;\n}\ntemplate <typename A, typename B>\ninline char ru(A &x, B &y) {\n  if (ru(x) == EOF) return EOF;\n  ru(y);\n  return 2;\n}\ntemplate <typename A, typename B, typename C>\ninline char ru(A &x, B &y, C &z) {\n  if (ru(x) == EOF) return EOF;\n  ru(y);\n  ru(z);\n  return 3;\n}\ntemplate <typename A, typename B, typename C, typename D>\ninline char ru(A &x, B &y, C &z, D &w) {\n  if (ru(x) == EOF) return EOF;\n  ru(y);\n  ru(z);\n  ru(w);\n  return 4;\n}\nstruct Edge {\n  int u, v, next;\n  int w, cap, flow;\n  Edge(int _u = 0, int _v = 0, int nxt = -1, long long _w = 1,\n       long long _cap = 0) {\n    u = _u;\n    v = _v;\n    w = _w;\n    cap = _cap;\n    flow = 0;\n    next = nxt;\n  }\n  int operator<(const Edge &b) const { return w < b.w; }\n};\nconst int maxn = 3e5 + 7;\ndouble eps = 1e-6;\nint n, m;\nlong long cnt1, cnt2, cnt3;\nlong long a[maxn], b[maxn], c[maxn];\nlong long dp[maxn], pre[maxn];\npair<int, int> f[maxn];\nint cmp(const long long &a, const long long &b) { return a > b; }\nint main() {\n  ru(n, m);\n  long long w, v;\n  for (int i = 1; i <= n; ++i) {\n    ru(w, v);\n    if (w == 1)\n      a[++cnt1] = v;\n    else if (w == 2)\n      b[++cnt2] = v;\n    else\n      c[++cnt3] = v;\n  }\n  sort(a + 1, a + cnt1 + 1, cmp);\n  sort(b + 1, b + cnt2 + 1, cmp);\n  sort(c + 1, c + cnt3 + 1, cmp);\n  int x;\n  if (cnt1) {\n    dp[1] = a[1];\n    f[1].first = 1;\n  }\n  for (int i = 2; i <= m; ++i) {\n    x = 0;\n    dp[i] = dp[i - 1];\n    f[i] = f[i - 1];\n    if (f[i - 1].first < cnt1) {\n      dp[i] = dp[i - 1] + a[f[i - 1].first + 1];\n      x = 1;\n    }\n    if (f[i - 2].second < cnt2 && dp[i] < dp[i - 2] + b[f[i - 2].second + 1]) {\n      dp[i] = dp[i - 2] + b[f[i - 2].second + 1];\n      x = 2;\n    }\n    if (x == 1) {\n      f[i] = f[i - 1];\n      f[i].first++;\n    } else if (x == 2) {\n      f[i] = f[i - 2];\n      f[i].second++;\n    }\n  }\n  for (int i = 1; i <= m / 3; ++i) pre[i] = pre[i - 1] + c[i];\n  long long ans = 0;\n  for (int i = 0; i <= m; ++i) {\n    ans = max(ans, dp[i] + pre[(m - i) / 3]);\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.Vector;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n\n\npublic class ER21E {\n\n    static StringTokenizer st;\n    static BufferedReader br;\n    static PrintWriter pw;\n\n    static class Sort implements Comparable<Sort> {\n        int ind, a;\n\n        @Override\n        public int compareTo(Sort o) {\n            return a - o.a;\n        }\n        public Sort(int i, int an) {\n            ind = i;\n            a = an;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n       \tsolve();\n        pw.close();\n    }\n    \n    static long[][] a;\n    static long[] d;\n    static int[] ind1, ind2;\n    static int n;\n    static int sw;\n    private static void solve() throws IOException {\n    \tn = nextInt();\n    \tsw = nextInt();\n    \ta = new long [3][Math.max(3 * n + 1, sw + 1)];\n    \tint w;\n    \tfor (int i = 0; i < n; ++i) {\n    \t\tw = nextInt();\n    \t\ta[w - 1][i] = -nextLong();\n    \t}\n    \tfor (int i = 0; i < 3; ++i)\n    \t\tArrays.sort(a[i]);\n    \t\n    \tfor (int i = 0; i < 3; ++i)\n    \t\tfor (int j = 0; j <= n; ++j)\n    \t\t\ta[i][j] = -a[i][j];\n    \td = new long [sw + 1];\n    \tind1 = new int [sw + 1];\n    \tind2 = new int [sw + 1];\n    \td[1] = a[0][0];\n    \tind1[1] = 1;\n    \tfor (int i = 2; i <= sw; ++i) {\n    \t\td[i] = d[i - 1] + a[0][ind1[i - 1]];\n    \t\tind2[i] = ind2[i - 1];\n    \t\tind1[i] = ind1[i - 1] + 1;\n    \t\tif (d[i - 2] + a[1][ind2[i - 2]] > d[i]) {\n    \t\t\td[i] = d[i - 2] + a[1][ind2[i - 2]];\n    \t\t\tind1[i] = ind1[i - 2];\n    \t\t\tind2[i] = ind2[i - 2] + 1;\n    \t\t}\n    \t\tif (d[i - 2] + a[0][ind1[i - 2]] + a[0][ind1[i - 2] + 1] > d[i]) {\n    \t\t\td[i] = d[i - 2] + a[0][ind1[i - 2]] + a[0][ind1[i - 2] + 1];\n    \t\t\tind1[i] = ind1[i - 2] + 2;\n    \t\t\tind2[i] = ind2[i - 2];\n    \t\t}\n    \t}\n    \tlong ans = 0, sum = 0;\n    \tfor (int i = 0; 3 * i <= sw; ++i) {\n    \t\tans = Math.max(ans, sum + d[sw - 3 * i]);\n    \t\tsum += a[2][i];\n    \t}\n    \tpw.println(ans);\n    }\n\n\tprivate static int sumf(int[] fen, int id) {\n        int summ = 0;\n        for (; id >= 0; id = (id & (id + 1)) - 1)\n            summ += fen[id];\n        return summ;\n    }\n\n    private static void addf(int[] fen, int id) {\n        for (; id < fen.length; id |= id + 1)\n            fen[id]++;\n    }\n\n    private static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n    private static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n    private static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n    private static String next() throws IOException {\n        while (st==null || !st.hasMoreTokens())\n            st = new StringTokenizer(br.readLine());\n        return st.nextToken();\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.UnsupportedEncodingException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    \n    public static void main(String[] args) throws UnsupportedEncodingException, IOException {\n        Reader.init(System.in);\n        StringBuilder out = new StringBuilder();\n        int n = Reader.nextInt(), m = Reader.nextInt();\n        ArrayList<Long>[] c = new ArrayList[3];\n        c[0] = new ArrayList<Long>();\n        c[1] = new ArrayList<Long>();\n        c[2] = new ArrayList<Long>();\n        while(n-- > 0)\n            c[Reader.nextInt() - 1].add(Reader.nextLong());\n        for(int i = 0; i < 3; i++) {\n            while(c[i].size() < m + 3)\n                c[i].add(0l);\n            Collections.sort(c[i]);\n        }\n        long[] dp = new long[m + 1];\n        int o = c[0].size() - 1, t = c[1].size() - 1;\n        for(int i = 2; i <= m; i += 2) {\n            dp[i] = dp[i - 2];\n            if(c[1].get(t) > c[0].get(o) + c[0].get(o - 1)) {\n                dp[i] += c[1].get(t);\n                t--;\n            } else {\n                dp[i] += c[0].get(o) + c[0].get(o - 1);\n                o -= 2;\n            }\n        }\n        dp[1] = c[0].get(c[0].size() - 1);\n        o = c[0].size() - 2;\n        t = c[1].size() - 1;\n        for(int i = 3; i <= m; i += 2) {\n            dp[i] = dp[i - 2];\n            if(c[1].get(t) > c[0].get(o) + c[0].get(o - 1)) {\n                dp[i] += c[1].get(t);\n                t--;\n            } else {\n                dp[i] += c[0].get(o) + c[0].get(o - 1);\n                o -= 2;\n            }\n        }\n        long max = dp[m], sum = 0;\n        for(int i = c[2].size() - 1, cnt = 0; i > -1 && m - 3 * ++cnt > -1; i--) {\n            sum += c[2].get(i);\n            max = Math.max(max, sum + dp[m - 3 * cnt]);\n        }\n        out.append(max).append('\\n');\n        PrintWriter p = new PrintWriter(System.out);\n        p.print(out);\n        p.close();\n    }\n    \n}\n\nclass Reader {\n    static BufferedReader reader;\n    static StringTokenizer tokenizer;\n\n    /** call this method to initialize reader for InputStream */\n    static void init(InputStream input) throws UnsupportedEncodingException {\n        reader = new BufferedReader(\n                     new InputStreamReader(input, \"UTF-8\") );\n        tokenizer = new StringTokenizer(\"\");\n    }\n    \n    static void init(String fileUrl) throws UnsupportedEncodingException, FileNotFoundException {\n        reader = new BufferedReader(new FileReader(fileUrl));\n        tokenizer = new StringTokenizer(\"\");\n    }\n\n    /** get next word */\n    static String next() throws IOException {\n        while ( ! tokenizer.hasMoreTokens() ) {\n            //TODO add check for eof if necessary\n            tokenizer = new StringTokenizer(\n                   reader.readLine() );\n        }\n        return tokenizer.nextToken();\n    }\n    \n    static String nextLine() throws IOException {\n        return reader.readLine();\n    }\n\n    static int nextInt() throws IOException {\n        return Integer.parseInt( next() );\n    }\n    \n    static double nextDouble() throws IOException {\n        return Double.parseDouble( next() );\n    }\n    \n    static long nextLong() throws IOException {\n        return Long.parseLong( next() );\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5;\nint n, m, a, b;\nlong long c[3][maxn];\nlong long sum[3][maxn];\nint cnt[3];\nlong long cal(int n3, int n2) {\n  return sum[2][n3] + sum[1][n2] + sum[0][min(cnt[0], m - n3 * 3 - n2 * 2)];\n}\nint main() {\n  cin >> n >> m;\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d%d\", &a, &b);\n    c[a - 1][cnt[a - 1]++] = b;\n  }\n  for (int i = 0; i < 3; ++i) sort(c[i], c[i] + cnt[i], greater<long long>());\n  for (int i = 0; i < 3; ++i)\n    for (int j = 1; j <= cnt[i]; ++j) sum[i][j] = sum[i][j - 1] + c[i][j - 1];\n  long long ans = 0;\n  for (int i = 0; i <= min(m / 3, cnt[2]); ++i) {\n    int l = 0, r = min((m - i * 3) / 2, cnt[1]), lm, rm;\n    ans = max(ans, max(cal(i, l), cal(i, r)));\n    while (l < r) {\n      lm = (l + r) >> 1;\n      rm = (lm + r) >> 1;\n      if (cal(i, lm) > cal(i, rm))\n        r = rm;\n      else if (cal(i, lm) == cal(i, rm))\n        l = lm, r = rm;\n      else\n        l = lm;\n    }\n    ans = max(ans, cal(i, l));\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 3e5 + 5;\nstruct node {\n  int w;\n  long long c;\n  bool operator<(const node &r) const {\n    return c * r.w > r.c * w || c * r.w == r.c * w && w < r.w;\n  }\n} e[maxn];\nlong long t[maxn];\nlong long a[maxn];\nint f[maxn];\nlong long mi[maxn];\nbool cmp(long long a, long long b) { return a > b; }\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  int now1 = 0, now3 = 0;\n  for (int i = 1; i <= n; i++) {\n    int w;\n    long long c;\n    scanf(\"%d%lld\", &w, &c);\n    if (w == 3)\n      t[++now3] = c;\n    else\n      e[++now1].w = w, e[now1].c = c;\n  }\n  sort(t + 1, t + 1 + now3, cmp);\n  for (int i = 2; i <= now3; i++) t[i] += t[i - 1];\n  sort(e + 1, e + 1 + now1);\n  int pre = 0;\n  mi[0] = 1e18;\n  for (int i = 1; i <= now1; i++) {\n    a[pre + e[i].w] = a[pre] + e[i].c;\n    f[pre + e[i].w] = e[i].w;\n    if (e[i].w == 1)\n      mi[pre + e[i].w] = e[i].c;\n    else\n      mi[pre + 1] = mi[pre + 2] = mi[pre];\n    pre += e[i].w;\n  }\n  for (int i = pre + 1; i <= m; i++) a[i] = a[i - 1];\n  long long nex1 = 0, nex2 = 0;\n  for (int i = pre; i >= 1; i--) {\n    if (f[i] == 1)\n      nex1 = a[i] - a[i - 1];\n    else if (f[i] == 2)\n      nex2 = a[i] - a[i - 2];\n    else {\n      a[i] = max(a[i - 1] + nex1, a[i - 1] + nex2 - mi[i]);\n    }\n  }\n  long long ans = 0;\n  for (int i = 0; i <= now3; i++) {\n    long long sum = t[i];\n    int len = m - i * 3;\n    if (len < 0) break;\n    sum += a[len];\n    ans = max(ans, sum);\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n  long long v, s1, s2;\n} dp[300005];\nlong long goods[4][300005];\nlong long num[4];\nlong long sum[300005];\nint cmp(long long a, long long b) { return a > b; }\nint main() {\n  long long n, m, w, c;\n  while (~scanf(\"%lld %lld\", &n, &m)) {\n    memset(goods, 0, sizeof(goods));\n    memset(num, 0, sizeof(num));\n    memset(dp, 0, sizeof(dp));\n    for (long long i = 0; i < n; i++) {\n      scanf(\"%lld %lld\", &w, &c);\n      goods[w][++num[w]] = c;\n    }\n    for (long long i = 1; i <= 3; i++) {\n      sort(goods[i] + 1, goods[i] + 1 + num[i], cmp);\n    }\n    for (long long i = 1; i <= num[3]; i++) {\n      sum[i] = sum[i - 1] + goods[3][i];\n    }\n    for (long long i = 1; i <= m; i++) {\n      dp[i] = dp[i - 1];\n      if (dp[i - 1].v + goods[1][dp[i - 1].s1 + 1] > dp[i].v) {\n        dp[i].v = dp[i - 1].v + goods[1][dp[i - 1].s1 + 1];\n        dp[i].s1 = dp[i - 1].s1 + 1;\n        dp[i].s2 = dp[i - 1].s2;\n      }\n      if (i >= 2 && dp[i - 2].v + goods[2][dp[i - 2].s2 + 1] > dp[i].v) {\n        dp[i].v = dp[i - 2].v + goods[2][dp[i - 2].s2 + 1];\n        dp[i].s1 = dp[i - 2].s1;\n        dp[i].s2 = dp[i - 2].s2 + 1;\n      }\n    }\n    long long ans = 0;\n    for (long long i = 0; i <= num[3] && i * 3 <= m; i++) {\n      ans = max(ans, dp[m - i * 3].v + sum[i]);\n    }\n    printf(\"%lld\\n\", ans);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 7;\nlong long ans, dp[N];\nint ed, n, m;\nstruct node {\n  int w, c;\n  double val;\n  node(int a = 0, int b = 0) : w(a), c(b) {}\n  bool operator<(const node &b) const { return val > b.val; }\n} a[N], tmp[N];\nlong long DP() {\n  for (int i = 1; i <= ed; i++) {\n    for (int j = m; j >= tmp[i].w; j--) {\n      dp[j] = max(dp[j], dp[j - tmp[i].w] + tmp[i].c);\n    }\n  }\n  long long mx = 0;\n  for (int i = 0; i <= m; i++) mx = max(mx, dp[i]);\n  return mx;\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  ans = 0;\n  for (int i = 1; i <= n; i++)\n    scanf(\"%d%d\", &a[i].w, &a[i].c), a[i].val = 1.0 * a[i].c / a[i].w;\n  sort(a + 1, a + 1 + n);\n  int tp[4];\n  memset(tp, -1, sizeof(tp));\n  for (int i = 1; i <= n; i++) {\n    if (m < 30) {\n      ed = 0;\n      while (i <= n) tmp[++ed] = a[i], i++;\n      for (int ii = 1; ii <= 3; ii++)\n        if (~tp[ii]) tmp[++ed] = node(ii, tp[ii]), m += ii, ans -= tp[ii];\n      ans += DP();\n      break;\n    }\n    ans += a[i].c;\n    m -= a[i].w;\n    tp[a[i].w] = a[i].c;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100000, M = 300000;\nlong long dp[M + 1][3];\nvector<int> c[3];\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  int ci, wi;\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d%d\", &wi, &ci);\n    c[wi - 1].push_back(ci);\n  }\n  for (int i = 0; i < 3; ++i) sort(c[i].begin(), c[i].end(), greater<int>());\n  if (!c[0].empty()) {\n    dp[1][0] = 1;\n    dp[1][2] = c[0][0];\n  }\n  for (int i = 2; i <= m; ++i) {\n    if (c[0].size() + c[1].size() * 2 < i) {\n      dp[i][2] = max(dp[i - 1][2], dp[i - 2][2]);\n      continue;\n    }\n    dp[i][0] = dp[i - 1][0] + 1;\n    dp[i][1] = dp[i - 1][1];\n    dp[i][2] =\n        dp[i - 1][2] + (dp[i - 1][0] < c[0].size() ? c[0][dp[i - 1][0]] : 0);\n    if (dp[i - 2][2] + (dp[i - 2][1] < c[1].size() ? c[1][dp[i - 2][1]] : 0) >\n        dp[i][2]) {\n      dp[i][0] = dp[i - 2][0];\n      dp[i][1] = dp[i - 2][1] + 1;\n      dp[i][2] =\n          dp[i - 2][2] + (dp[i - 2][1] < c[1].size() ? c[1][dp[i - 2][1]] : 0);\n    }\n  }\n  long long mx = 0;\n  long long sum = 0;\n  for (int i = 0; i <= c[2].size() && m - 3 * i >= 0; ++i) {\n    mx = max(mx, dp[m - 3 * i][2] + sum);\n    if (i != c[2].size()) sum += c[2][i];\n  }\n  printf(\"%lld\\n\", mx);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Template implements Runnable {\n\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer tok = new StringTokenizer(\"\");\n\n    void init() throws FileNotFoundException {\n        try {\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new PrintWriter(\"output.txt\");\n        } catch (Exception e) {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        }\n    }\n\n    class GraphBuilder {\n        int n, m;\n        int[] x, y;\n        int index;\n        int[] size;\n\n\n        GraphBuilder(int n, int m) {\n            this.n = n;\n            this.m = m;\n            x = new int[m];\n            y = new int[m];\n            size = new int[n];\n        }\n\n        void add(int u, int v) {\n            x[index] = u;\n            y[index] = v;\n            size[u]++;\n            size[v]++;\n            index++;\n        }\n\n        int[][] build() {\n            int[][] graph = new int[n][];\n            for (int i = 0; i < n; i++) {\n                graph[i] = new int[size[i]];\n            }\n            for (int i = index - 1; i >= 0; i--) {\n                int u = x[i];\n                int v = y[i];\n                graph[u][--size[u]] = v;\n                graph[v][--size[v]] = u;\n            }\n            return graph;\n        }\n    }\n\n    String readString() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            try {\n                tok = new StringTokenizer(in.readLine());\n            } catch (Exception e) {\n                return null;\n            }\n        }\n        return tok.nextToken();\n    }\n\n    int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n\n    int[] readIntArray(int size) throws IOException {\n        int[] res = new int[size];\n        for (int i = 0; i < size; i++) {\n            res[i] = readInt();\n        }\n        return res;\n    }\n\n    long[] readLongArray(int size) throws IOException {\n        long[] res = new long[size];\n        for (int i = 0; i < size; i++) {\n            res[i] = readLong();\n        }\n        return res;\n    }\n\n    long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n\n    double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n\n    <T> List<T>[] createGraphList(int size) {\n        List<T>[] list = new List[size];\n        for (int i = 0; i < size; i++) {\n            list[i] = new ArrayList<>();\n        }\n        return list;\n    }\n\n    public static void main(String[] args) {\n        new Template().run();\n        // new Thread(null, new Template(), \"\", 1l * 200 * 1024 * 1024).start();\n    }\n\n    long timeBegin, timeEnd;\n\n    void time() {\n        timeEnd = System.currentTimeMillis();\n        System.err.println(\"Time = \" + (timeEnd - timeBegin));\n    }\n\n    long memoryTotal, memoryFree;\n\n    void memory() {\n        memoryFree = Runtime.getRuntime().freeMemory();\n        System.err.println(\"Memory = \" + ((memoryTotal - memoryFree) >> 10)\n                + \" KB\");\n    }\n\n    public void run() {\n        try {\n            timeBegin = System.currentTimeMillis();\n            memoryTotal = Runtime.getRuntime().freeMemory();\n            init();\n            solve();\n            out.close();\n            if (System.getProperty(\"ONLINE_JUDGE\") == null) {\n                time();\n                memory();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }\n\n    class Obj implements Comparable<Obj> {\n        int w;\n        int cost;\n\n        public Obj(int w, int cost) {\n            this.w = w;\n            this.cost = cost;\n        }\n\n        int getCost() {\n            return cost * 2 / w;\n        }\n\n        @Override\n        public int compareTo(Obj o) {\n            return o.getCost() - getCost();\n        }\n    }\n\n    PriorityQueue<Obj> objects;\n    TreeMap<Integer, Integer> suffix;\n    long minOneAlready = 100L * Integer.MAX_VALUE;\n    int nowSumWeight = 0;\n    long nowSumCost = 0;\n\n    void changeSuffix(int val, int diff) {\n        suffix.put(val, suffix.getOrDefault(val, 0) + diff);\n        if (suffix.getOrDefault(val, 0) == 0) {\n            suffix.remove(val);\n        }\n    }\n\n    long getMaxCost(int needWeight) {\n        if (needWeight < 0) return Long.MIN_VALUE;\n        while (nowSumWeight < needWeight) {\n            if (objects.size() == 0) break;\n            if (objects.peek().w + nowSumWeight <= needWeight) {\n                Obj current = objects.poll();\n                if (current.w == 1) {\n                    minOneAlready = current.cost;\n                    changeSuffix(current.cost, -1);\n                }\n                nowSumWeight += current.w;\n                nowSumCost += current.cost;\n            } else {\n                break;\n            }\n        }\n        if (objects.size() == 0) return nowSumCost;\n        if (nowSumWeight == needWeight) return nowSumCost;\n\n        long max = nowSumCost;\n        if (suffix.size() > 0) {\n            max += suffix.lastKey();\n        }\n        max = Math.max(max, nowSumCost - minOneAlready + objects.peek().cost);\n        return max;\n    }\n\n    void solve() throws IOException {\n        int n = readInt();\n        int m = readInt();\n        List<Integer> three = new ArrayList<>();\n        objects = new PriorityQueue<>();\n        for (int i = 0; i < n; i++) {\n            int w = readInt();\n            int c = readInt();\n            if (w == 3) {\n                three.add(-c);\n            } else {\n                objects.add(new Obj(w, c));\n            }\n        }\n        suffix = new TreeMap<>();\n        for (Obj obj : objects) {\n            if (obj.w == 1) {\n                changeSuffix(obj.cost, 1);\n            }\n        }\n        Collections.sort(three);\n        long threesSum = 0;\n        for (int x : three) threesSum -= x;\n        long bestAnswer = threesSum + getMaxCost(m - 3 * three.size());\n        for (int i = three.size() - 1; i >= 0; i--) {\n            threesSum += three.get(i);\n            bestAnswer = Math.max(bestAnswer, threesSum + getMaxCost(m - 3 * (i)));\n        }\n        out.println(Math.max(bestAnswer, 0));\n\n\n    }\n\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\n@SuppressWarnings(\"unchecked\")\npublic class P808E {\n\n  final static int DIST = 15;\n\n  public void run() throws Exception {\n    int n = nextInt(), m = nextInt();\n    int [][] wca = new int [n][2];\n    int l1 = 0, l2 = 0, l3 = 0;\n    for (int i = 0; i < n; i++) {\n      wca[i] = readInt(2);\n      if (wca[i][0] == 1) {\n        l1++;\n      } else if (wca[i][0] == 2) {\n        l2++;\n      } else {\n        l3++;\n      }\n    }\n\n    Arrays.sort(wca, new Comparator<int []>() {\n      public int compare(int [] a, int [] b) {\n        return (b[1] - a[1]);\n      }\n    });\n\n    int [] c1 = new int [l1], c2 = new int [l2], c3 = new int [l3];\n    int i1 = 0, i2 = 0, i3 = 0;\n    for (int [] wc : wca) {\n      if (wc[0] == 1) {\n        c1[i1++] = wc[1];\n      } else if (wc[0] == 2) {\n        c2[i2++] = wc[1];\n      } else {\n        c3[i3++] = wc[1];\n      }\n    }\n\n    int mm = m;\n    i1 = i2 = i3 = 0;\n    while (true) {\n      int k1 = ((i1 < l1) && (mm >= 1)) ? c1[i1] : 0;\n      int k2 = ((i2 < l2) && (mm >= 2)) ? c2[i2] : 0;\n      int k3 = ((i3 < l3) && (mm >= 3)) ? c3[i3] : 0;\n\n      if ((k1 | k2 | k3) == 0) {\n        break;\n      } else if ((2.0 * k1 >= k2) && (3.0 * k1 >= k3)) {\n        i1++;\n        mm -= 1;\n      } else if ((k2 >= 2.0 * k1) && (3.0 * k2 >= 2.0 * k3)) {\n        i2++;\n        mm -= 2;\n      } else {\n        i3++;\n        mm -= 3;\n      }\n    }\n\n    long [] s1 = new long [l1 + 1], s2 = new long [l2 + 1], s3 = new long [l3 + 1];\n    for (int i = 0; i < l1; s1[i + 1] = c1[i] + s1[i], i++);\n    for (int i = 0; i < l2; s2[i + 1] = c2[i] + s2[i], i++);\n    for (int i = 0; i < l3; s3[i + 1] = c3[i] + s3[i], i++);\n\n    long s = 0;\n    for (int d1 = -DIST; d1 <= DIST; d1++) {\n      for (int d2 = -DIST; d2 <= DIST; d2++) {\n        for (int d3 = -DIST; d3 <= DIST; d3++) {\n          int j1 = i1 + d1, j2 = i2 + d2, j3 = i3 + d3;\n\n          if ((j1 >= 0) && (j2 >= 0) && (j3 >= 0) &&\n              (j1 <= l1) && (j2 <= l2) && (j3 <= l3) &&\n              ((j1 + 2 * j2 + 3 * j3) <= m)) {\n            s = Math.max(s, s1[j1] + s2[j2] + s3[j3]);\n          }\n        }\n      }\n    }\n\n    println(s);\n  }\n\n  public static void main(String... args) throws Exception {\n    br = new BufferedReader(new InputStreamReader(System.in));\n    pw = new PrintWriter(new BufferedOutputStream(System.out));\n    new P808E().run();\n    br.close();\n    pw.close();\n    System.err.println(\"\\n[Time : \" + (System.currentTimeMillis() - startTime) + \" ms]\");\n  }\n\n  static long startTime = System.currentTimeMillis();\n  static BufferedReader br;\n  static PrintWriter pw;\n  StringTokenizer stok;\n\n  String nextToken() throws IOException {\n    while (stok == null || !stok.hasMoreTokens()) {\n      String s = br.readLine();\n      if (s == null) { return null; }\n      stok = new StringTokenizer(s);\n    }\n    return stok.nextToken();\n  }\n\n  void print(byte b) { print(\"\" + b); }\n  void print(int i) { print(\"\" + i); }\n  void print(long l) { print(\"\" + l); }\n  void print(double d) { print(\"\" + d); }\n  void print(char c) { print(\"\" + c); }\n  void print(Object o) {\n    if (o instanceof int[]) { print(Arrays.toString((int [])o));\n    } else if (o instanceof long[]) { print(Arrays.toString((long [])o));\n    } else if (o instanceof char[]) { print(Arrays.toString((char [])o));\n    } else if (o instanceof byte[]) { print(Arrays.toString((byte [])o));\n    } else if (o instanceof short[]) { print(Arrays.toString((short [])o));\n    } else if (o instanceof boolean[]) { print(Arrays.toString((boolean [])o));\n    } else if (o instanceof float[]) { print(Arrays.toString((float [])o));\n    } else if (o instanceof double[]) { print(Arrays.toString((double [])o));\n    } else if (o instanceof Object[]) { print(Arrays.toString((Object [])o));\n    } else { print(\"\" + o); }\n  }\n  void print(String s) { pw.print(s); }\n  void println() { println(\"\"); }\n  void println(byte b) { println(\"\" + b); }\n  void println(int i) { println(\"\" + i); }\n  void println(long l) { println(\"\" + l); }\n  void println(double d) { println(\"\" + d); }\n  void println(char c) { println(\"\" + c); }\n  void println(Object o) { print(o); println(); }\n  void println(String s) { pw.println(s); }\n  int nextInt() throws IOException { return Integer.parseInt(nextToken()); }\n  long nextLong() throws IOException { return Long.parseLong(nextToken()); }\n  double nextDouble() throws IOException { return Double.parseDouble(nextToken()); }\n  char nextChar() throws IOException { return (char) (br.read()); }\n  String next() throws IOException { return nextToken(); }\n  String nextLine() throws IOException { return br.readLine(); }\n  int [] readInt(int size) throws IOException {\n    int [] array = new int [size];\n    for (int i = 0; i < size; i++) { array[i] = nextInt(); }\n    return array;\n  }\n  long [] readLong(int size) throws IOException {\n    long [] array = new long [size];\n    for (int i = 0; i < size; i++) { array[i] = nextLong(); }\n    return array;\n  }\n  double [] readDouble(int size) throws IOException {\n    double [] array = new double [size];\n    for (int i = 0; i < size; i++) { array[i] = nextDouble(); }\n    return array;\n  }\n  String [] readLines(int size) throws IOException {\n    String [] array = new String [size];\n    for (int i = 0; i < size; i++) { array[i] = nextLine(); }\n    return array;\n  }\n\n  int gcd(int a, int b) {\n    return ((b > 0) ? gcd(b, a % b) : a);\n  }\n  long gcd(long a, long b) {\n    return ((b > 0) ? gcd(b, a % b) : a);\n  }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nusing UI = unsigned int;\nusing UC = unsigned char;\nusing VI = std::vector<int>;\nusing SI = std::set<int>;\nusing PI = std::pair<int, int>;\nusing PL = std::pair<LL, LL>;\nconstexpr LL MOD = 1000000009;\nconstexpr double EXP = 2.7182818284590452;\nconstexpr double Pi = 3.1415926535;\nconstexpr long double EPS = 1e-4;\nconstexpr int INF = 1000 * 1000 * 1001;\nconstexpr long long INFL = (LL)INF * (LL)INF;\ninline LL gcd(LL a, LL b) {\n  if (a < b) swap(a, b);\n  while (b != 0) {\n    a %= b;\n    swap(a, b);\n  }\n  return a;\n}\ninline LL lcm(LL a, LL b) { return (a / gcd(a, b)) * b; }\nLL extgcd(LL a, LL b, LL& x, LL& y) {\n  if (a == 0) {\n    x = 0;\n    y = 1;\n    return b;\n  }\n  LL x11, y11;\n  LL d = extgcd(b % a, a, x11, y11);\n  x = y11 - (b / a) * x11;\n  y = x11;\n  return d;\n}\nULL poww(ULL v, ULL p, ULL mod) {\n  if (p == 0) return 1;\n  if (p & 1) {\n    return (poww(v, p - 1, mod) * v) % mod;\n  } else {\n    ULL t = poww(v, p >> 1L, mod);\n    return (t * t) % mod;\n  }\n}\nconstexpr ULL L31018 = 3000000000000000000L;\nconstexpr ULL L1018 = 1000000000000000000L;\nconstexpr int MAXN = 300005;\nint n, m;\nint cnt[4];\nint cur[4];\nint arr[4][MAXN];\nLL sum[4][MAXN];\nLL res = 0;\nint w = 0, c;\nLL get_sum(int w, int p) { return sum[w][p] - sum[w][0]; }\nLL get_sum12(int p1, int p2) {\n  return sum[1][p1] - sum[1][0] + sum[2][p2] - sum[2][0];\n}\nPI dp12[MAXN];\nbool was[MAXN];\nPI func(int w) {\n  if (w == 0) {\n    return std::make_pair(1, 1);\n  }\n  if (w == 1) {\n    return std::make_pair(((2 < cnt[1] + 1) ? (2) : (cnt[1] + 1)), 1);\n  }\n  if (was[w]) {\n    return dp12[w];\n  }\n  was[w] = true;\n  PI r1, r2;\n  r1 = func(w - 1);\n  if (r1.first <= cnt[1]) {\n    ++r1.first;\n  }\n  r2 = func(w - 2);\n  LL s1 = 0, s2 = 0;\n  if (r2.first <= cnt[1]) {\n    s1 += arr[1][r2.first];\n  }\n  if (r2.first + 1 <= cnt[1]) {\n    s1 += arr[1][r2.first + 1];\n  }\n  if (r2.second <= cnt[2]) {\n    s2 += arr[2][r2.second];\n  }\n  if (s2 >= s1) {\n    ++r2.second;\n  } else {\n    r2.first += 2;\n  }\n  if (get_sum12(r1.first - 1, r1.second - 1) >\n      get_sum12(r2.first - 1, r2.second - 1)) {\n    return dp12[w] = r1;\n  }\n  return dp12[w] = r2;\n}\nvoid accept() {\n  cin >> n >> m;\n  for (int i = (0); i < (4); ++i) {\n    cur[i] = 1;\n  }\n  for (int i = (1); i < (n + 1); ++i) {\n    scanf(\"%d%d\", &w, &c);\n    arr[w][cur[w]++] = c;\n    ++cnt[w];\n  }\n  for (int i = (1); i < (4); ++i) {\n    sort(arr[i] + 1, arr[i] + 1 + cnt[i], greater<int>());\n  }\n  for (int i = (1); i < (4); ++i) {\n    for (int j = (1); j < (n + 1); ++j) {\n      sum[i][j] = sum[i][j - 1] + arr[i][j];\n    }\n  }\n  LL res = 0, cur = 0;\n  for (int i = (0); i < (cnt[3] + 1); ++i) {\n    if (3 * i > m) {\n      break;\n    }\n    PI res12 = func(m - 3 * i);\n    cur = get_sum(3, i) + get_sum12(res12.first - 1, res12.second - 1);\n    res = ((res < cur) ? (cur) : (res));\n  }\n  cout << res;\n}\nint main(void) {\n  accept();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, m;\nvector<long long> v[4];\nvector<long long> sum[4];\nint32_t main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  cin >> n >> m;\n  for (long long i = 0; i < n; i++) {\n    long long w, c;\n    cin >> w >> c;\n    v[w].push_back(c);\n  }\n  for (long long i = 1; i <= 3; i++)\n    sort(v[i].rbegin(), v[i].rend()), sum[i].push_back(0);\n  for (long long i = 1; i <= 3; i++) {\n    for (long long j = 1; j <= v[i].size(); j++) {\n      long long val = sum[i].back() + v[i][j - 1];\n      sum[i].push_back(val);\n    }\n  }\n  long long ans = 0;\n  for (long long i = 0; i <= min(m, (long long)v[3].size()); i++) {\n    long long wt = m - 3 * i;\n    if (wt < 0) break;\n    long long low = 0;\n    long long high = min((long long)v[2].size(), wt / 2);\n    while (low < high) {\n      long long mid1 = low + (high - low) / 3;\n      long long mid2 = high - (high - low) / 3;\n      long long left1 = wt - mid1 * 2;\n      long long left2 = wt - mid2 * 2;\n      long long take1 = min((long long)v[1].size(), left1);\n      long long take2 = min((long long)v[1].size(), left2);\n      long long sum1 = sum[2][mid1] + sum[1][take1];\n      long long sum2 = sum[2][mid2] + sum[1][take2];\n      if (sum1 < sum2)\n        low = mid1 + 1;\n      else\n        high = mid2 - 1;\n    }\n    for (long long j = max(0ll, low - 2);\n         j <= min(min((long long)v[2].size(), wt / 2), low + 2); j++) {\n      long long left = wt - j * 2;\n      long long take = min((long long)v[1].size(), left);\n      long long sum1 = sum[2][j] + sum[1][take];\n      ans = max(ans, sum1 + sum[3][i]);\n    }\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> v[4];\nlong long _1[300300], sum[4][100100], total;\nint main() {\n  ios_base::sync_with_stdio(0);\n  long long n, m;\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    cin >> x >> y;\n    total += x;\n    v[x].push_back(y);\n  }\n  for (int i = 1; i <= 3; i++) sort(v[i].rbegin(), v[i].rend());\n  memset(_1, -1, sizeof _1);\n  _1[0] = 0;\n  if ((int)v[1].size() > 0) _1[1] = 1;\n  if ((int)v[1].size() > 1) _1[2] = 2;\n  for (int j = 1; j <= 3; j++)\n    for (int i = 1; i <= (int)v[j].size(); i++) {\n      sum[j][i] = sum[j][i - 1] + v[j][i - 1];\n    }\n  for (int i = 3; i <= m; i++)\n    if (_1[i - 3] != -1) {\n      if (_1[i - 3] + 3 <= (int)v[1].size()) _1[i] = _1[i - 3] + 3;\n      int _3 = (i - _1[i - 3]) / 3;\n      if (v[3].size() >= _3 && (v[1].size() < _1[i - 3] + 3 ||\n                                sum[1][_1[i - 3] + 3] - sum[1][_1[i - 3]] <\n                                    sum[3][_3] - sum[3][_3 - 1]))\n        _1[i] = _1[i - 3];\n    }\n  m = min(m, total);\n  long long ans = 0;\n  for (int i = 0; i <= (int)v[2].size(); i++)\n    if (2 * i <= m && _1[m - 2 * i] != -1) {\n      ans = max(sum[2][i] + sum[1][_1[m - 2 * i]] +\n                    sum[3][(m - 2 * i - _1[m - 2 * i]) / 3],\n                ans);\n    }\n  m--;\n  for (int i = 0; i <= (int)v[2].size(); i++)\n    if (2 * i <= m && _1[m - 2 * i] != -1) {\n      ans = max(sum[2][i] + sum[1][_1[m - 2 * i]] +\n                    sum[3][(m - 2 * i - _1[m - 2 * i]) / 3],\n                ans);\n    }\n  m--;\n  for (int i = 0; i <= (int)v[2].size(); i++)\n    if (2 * i <= m && _1[m - 2 * i] != -1) {\n      ans = max(sum[2][i] + sum[1][_1[m - 2 * i]] +\n                    sum[3][(m - 2 * i - _1[m - 2 * i]) / 3],\n                ans);\n    }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\n@SuppressWarnings(\"unchecked\")\npublic class P808E {\n\n  final static int DIST = 3;\n\n  public void run() throws Exception {\n    int n = nextInt(), m = nextInt();\n    int [][] wca = new int [n][2];\n    int l1 = 0, l2 = 0, l3 = 0;\n    for (int i = 0; i < n; i++) {\n      wca[i] = readInt(2);\n      if (wca[i][0] == 1) {\n        l1++;\n      } else if (wca[i][0] == 2) {\n        l2++;\n      } else {\n        l3++;\n      }\n    }\n\n    Arrays.sort(wca, new Comparator<int []>() {\n      public int compare(int [] a, int [] b) {\n        return (b[1] - a[1]);\n      }\n    });\n\n    int [] c1 = new int [l1], c2 = new int [l2], c3 = new int [l3];\n    int i1 = 0, i2 = 0, i3 = 0;\n    for (int [] wc : wca) {\n      if (wc[0] == 1) {\n        c1[i1++] = wc[1];\n      } else if (wc[0] == 2) {\n        c2[i2++] = wc[1];\n      } else {\n        c3[i3++] = wc[1];\n      }\n    }\n\n    int mm = m;\n    i1 = i2 = i3 = 0;\n    while (true) {\n      int k1 = ((i1 < l1) && (mm >= 1)) ? c1[i1] : 0;\n      int k2 = ((i2 < l2) && (mm >= 2)) ? c2[i2] : 0;\n      int k3 = ((i3 < l3) && (mm >= 3)) ? c3[i3] : 0;\n\n      if ((k1 | k2 | k3) == 0) {\n        break;\n      } else if ((2.0 * k1 >= k2) && (3.0 * k1 >= k3)) {\n        i1++;\n        mm -= 1;\n      } else if ((k2 >= 2.0 * k1) && (3.0 * k2 >= 2.0 * k3)) {\n        i2++;\n        mm -= 2;\n      } else {\n        i3++;\n        mm -= 3;\n      }\n    }\n\n    long [] s1 = new long [l1 + 1], s2 = new long [l2 + 1], s3 = new long [l3 + 1];\n    for (int i = 0; i < l1; s1[i + 1] = c1[i] + s1[i], i++);\n    for (int i = 0; i < l2; s2[i + 1] = c2[i] + s2[i], i++);\n    for (int i = 0; i < l3; s3[i + 1] = c3[i] + s3[i], i++);\n\n    long s = 0;\n    for (int d1 = -DIST; d1 <= DIST; d1++) {\n      for (int d2 = -DIST; d2 <= DIST; d2++) {\n        for (int d3 = -DIST; d3 <= DIST; d3++) {\n          int j1 = i1 + d1, j2 = i2 + d2, j3 = i3 + d3;\n\n          if ((j1 >= 0) && (j2 >= 0) && (j3 >= 0) &&\n              (j1 <= l1) && (j2 <= l2) && (j3 <= l3) &&\n              ((j1 + 2 * j2 + 3 * j3) <= m)) {\n            s = Math.max(s, s1[j1] + s2[j2] + s3[j3]);\n          }\n        }\n      }\n    }\n\n    println(s);\n  }\n\n  public static void main(String... args) throws Exception {\n    br = new BufferedReader(new InputStreamReader(System.in));\n    pw = new PrintWriter(new BufferedOutputStream(System.out));\n    new P808E().run();\n    br.close();\n    pw.close();\n    System.err.println(\"\\n[Time : \" + (System.currentTimeMillis() - startTime) + \" ms]\");\n  }\n\n  static long startTime = System.currentTimeMillis();\n  static BufferedReader br;\n  static PrintWriter pw;\n  StringTokenizer stok;\n\n  String nextToken() throws IOException {\n    while (stok == null || !stok.hasMoreTokens()) {\n      String s = br.readLine();\n      if (s == null) { return null; }\n      stok = new StringTokenizer(s);\n    }\n    return stok.nextToken();\n  }\n\n  void print(byte b) { print(\"\" + b); }\n  void print(int i) { print(\"\" + i); }\n  void print(long l) { print(\"\" + l); }\n  void print(double d) { print(\"\" + d); }\n  void print(char c) { print(\"\" + c); }\n  void print(Object o) {\n    if (o instanceof int[]) { print(Arrays.toString((int [])o));\n    } else if (o instanceof long[]) { print(Arrays.toString((long [])o));\n    } else if (o instanceof char[]) { print(Arrays.toString((char [])o));\n    } else if (o instanceof byte[]) { print(Arrays.toString((byte [])o));\n    } else if (o instanceof short[]) { print(Arrays.toString((short [])o));\n    } else if (o instanceof boolean[]) { print(Arrays.toString((boolean [])o));\n    } else if (o instanceof float[]) { print(Arrays.toString((float [])o));\n    } else if (o instanceof double[]) { print(Arrays.toString((double [])o));\n    } else if (o instanceof Object[]) { print(Arrays.toString((Object [])o));\n    } else { print(\"\" + o); }\n  }\n  void print(String s) { pw.print(s); }\n  void println() { println(\"\"); }\n  void println(byte b) { println(\"\" + b); }\n  void println(int i) { println(\"\" + i); }\n  void println(long l) { println(\"\" + l); }\n  void println(double d) { println(\"\" + d); }\n  void println(char c) { println(\"\" + c); }\n  void println(Object o) { print(o); println(); }\n  void println(String s) { pw.println(s); }\n  int nextInt() throws IOException { return Integer.parseInt(nextToken()); }\n  long nextLong() throws IOException { return Long.parseLong(nextToken()); }\n  double nextDouble() throws IOException { return Double.parseDouble(nextToken()); }\n  char nextChar() throws IOException { return (char) (br.read()); }\n  String next() throws IOException { return nextToken(); }\n  String nextLine() throws IOException { return br.readLine(); }\n  int [] readInt(int size) throws IOException {\n    int [] array = new int [size];\n    for (int i = 0; i < size; i++) { array[i] = nextInt(); }\n    return array;\n  }\n  long [] readLong(int size) throws IOException {\n    long [] array = new long [size];\n    for (int i = 0; i < size; i++) { array[i] = nextLong(); }\n    return array;\n  }\n  double [] readDouble(int size) throws IOException {\n    double [] array = new double [size];\n    for (int i = 0; i < size; i++) { array[i] = nextDouble(); }\n    return array;\n  }\n  String [] readLines(int size) throws IOException {\n    String [] array = new String [size];\n    for (int i = 0; i < size; i++) { array[i] = nextLine(); }\n    return array;\n  }\n\n  int gcd(int a, int b) {\n    return ((b > 0) ? gcd(b, a % b) : a);\n  }\n  long gcd(long a, long b) {\n    return ((b > 0) ? gcd(b, a % b) : a);\n  }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 5;\nvector<int> w[4];\nint n, m;\nlong long GetAns(int t) {\n  int totw = m;\n  long long ans = 0;\n  for (int i = 0; i < min(t, (int)w[3].size()); i++) {\n    totw -= 3;\n    ans += w[3][i];\n  }\n  if (totw < 0) return 0;\n  int p1 = 0, p2 = 0;\n  while (totw >= 2 && p2 < w[2].size()) {\n    totw -= 2;\n    ans += w[2][p2++];\n  }\n  while (totw >= 1 && p1 < w[1].size()) {\n    totw--;\n    ans += w[1][p1++];\n  }\n  while (p1 + 1 < w[1].size() && p2 >= 1 &&\n         w[1][p1] + w[1][p1 + 1] > w[2][p2 - 1]) {\n    ans += w[1][p1] + w[1][p1 + 1];\n    p1 += 2;\n    p2--;\n    ans -= w[2][p2];\n  }\n  if (p1 < w[1].size() && p2 >= 1 && w[1][p1] > w[2][p2 - 1]) {\n    ans += w[1][p1];\n    p1++;\n    p2--;\n    ans -= w[2][p2];\n  }\n  return ans;\n}\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    int x, y;\n    scanf(\"%d %d\", &x, &y);\n    w[x].push_back(y);\n  }\n  for (auto &v : w) sort(v.begin(), v.end(), greater<int>());\n  int L = 0, R = min((int)w[3].size(), m / 3);\n  while (R - L > 10) {\n    int mid = L + R >> 1;\n    int mmid = (mid + R) >> 1;\n    if (GetAns(mid) < GetAns(mmid))\n      L = mid;\n    else\n      R = mmid;\n  }\n  long long ans = 0;\n  for (int i = L; i <= R; i++) ans = max(ans, GetAns(i));\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<long long, long long> > a;\nvector<pair<long long, long long> > b;\nvector<pair<long long, long long> > c;\nlong long n, m;\nbool cmp(pair<long long, long long> x, pair<long long, long long> y) {\n  return x.second * y.first < x.first * y.second;\n}\nlong long left__[5];\nlong long knapsack() {\n  vector<vector<long long> > dp;\n  dp.assign(b.size() + 5, vector<long long>(m + 5, 0));\n  for (long long i = 1; i <= b.size(); i++) {\n    long long w = b[i - 1].first;\n    long long val = b[i - 1].second;\n    for (long long j = 0; j <= m; j++) {\n      dp[i][j] = dp[i - 1][j];\n      if (j >= w) dp[i][j] = max(dp[i][j], dp[i - 1][j - w] + val);\n    }\n  }\n  return dp[b.size()][m];\n}\nlong long solve1() {\n  long long ret = 0;\n  sort(a.begin(), a.end(), cmp);\n  while (!a.empty() && m > 60) {\n    if (left__[a.back().first] > 10) {\n      m -= a.back().first;\n      ret += a.back().second;\n      a.pop_back();\n    } else {\n      c.push_back(a.back());\n      a.pop_back();\n    }\n  }\n  long long cnt[5];\n  memset(cnt, 0, sizeof(cnt));\n  for (long long i = (signed)c.size() - 1; i >= 0; i--) {\n    long long x = c[i].first;\n    if (cnt[x] * x > m) continue;\n    cnt[x]++;\n    b.push_back(c[i]);\n  }\n  for (long long i = (signed)a.size() - 1; i >= 0; i--) {\n    long long x = a[i].first;\n    if (cnt[x] * x > m) continue;\n    cnt[x]++;\n    b.push_back(a[i]);\n  }\n  return ret + knapsack();\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> m;\n  for (long long i = 1; i <= n; i++) {\n    long long x, y;\n    cin >> x >> y;\n    left__[x]++;\n    a.push_back(make_pair(x, y));\n  }\n  cout << solve1() << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Suv {\n  long long w, c;\n  double rate;\n};\nbool operator<(Suv a, Suv b) { return a.rate < b.rate; }\nSuv a[100001];\nlong long dp[300010];\nlong long up, down, ans;\nint i, j, n, m, c, w;\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d %d\", &w, &c);\n    a[i].w = w;\n    a[i].c = c;\n    a[i].rate = (double)w / c;\n  }\n  sort(a, a + n);\n  dp[0] = 1;\n  ans = 1;\n  for (i = 0; i < n; i++) {\n    up += a[i].w;\n    if (up > m) up = m;\n    down = max(a[i].w, up - 3);\n    for (j = up; j >= down; j--) {\n      dp[j] = max(dp[j], dp[j - a[i].w] + a[i].c);\n      ans = max(ans, dp[j]);\n    }\n  }\n  cout << ans - 1 << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n  long long w, c;\n};\nbool comp(node i, node j) { return (i.c > j.c); }\nlong long dp[300020];\nlong long ans;\nnode arr[100005];\nint main() {\n  long long i, j, n, m;\n  cin >> n >> m;\n  for (i = 0; i < n; i++) {\n    cin >> arr[i].w >> arr[i].c;\n    arr[i].c = ((arr[i].c * 6) / arr[i].w);\n  }\n  sort(arr, arr + n, comp);\n  long long tot = 0;\n  for (i = 0; i < n; i++) {\n    tot += arr[i].w;\n    tot = min(tot, m);\n    for (j = tot; tot - j < 4 && j >= arr[i].w; j--) {\n      dp[j] = max(dp[j], dp[j - arr[i].w] + ((arr[i].c * arr[i].w) / 6));\n      ans = max(ans, dp[j]);\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mxn = 1e5 + 5;\nlong long f[mxn], s[mxn], t[mxn];\nint n, m, cf, cs, ct;\nint nf, ns;\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin >> n >> m;\n  for (int i = 1; i <= n; ++i) {\n    int x, y;\n    cin >> x >> y;\n    if (x == 1)\n      f[++cf] = y;\n    else if (x == 2)\n      s[++cs] = y;\n    else\n      t[++ct] = y;\n  }\n  sort(f + 1, f + cf + 1);\n  reverse(f + 1, f + cf + 1);\n  sort(s + 1, s + cs + 1);\n  reverse(s + 1, s + cs + 1);\n  sort(t + 1, t + ct + 1);\n  reverse(t + 1, t + ct + 1);\n  for (int i = 1; i <= cf; ++i) f[i] += f[i - 1];\n  for (int i = 1; i <= cs; ++i) s[i] += s[i - 1];\n  for (int i = 1; i <= ct; ++i) t[i] += t[i - 1];\n  if (m >= cf + cs * 2 + ct * 3) {\n    cout << f[cf] + s[cs] + t[ct] << '\\n';\n    return 0;\n  }\n  long long mx = 0, ans = 0;\n  for (int i = 0; i <= cs; ++i) {\n    int tmp = m - i * 2;\n    tmp = min(tmp, cf);\n    if (tmp < 0) break;\n    long long sm = s[i] + f[tmp];\n    if (sm > mx) {\n      mx = sm;\n      nf = tmp;\n      ns = i;\n    }\n  }\n  ans = mx;\n  for (int i = 1; i <= ct; ++i) {\n    mx = 0;\n    int tps = ns, tpf = nf;\n    for (int cg = -5; cg <= 5; ++cg) {\n      int ts = ns + cg, tf = m - i * 3 - ts * 2;\n      ts = min(ts, cs), tf = min(tf, cf);\n      if (ts < 0 or tf < 0) continue;\n      long long sm = t[i] + s[ts] + f[tf];\n      if (sm > mx) {\n        mx = sm;\n        tps = ts;\n        tpf = tf;\n      }\n    }\n    if (ans < mx) {\n      ans = mx;\n      ns = tps;\n      nf = tpf;\n    }\n  }\n  cout << ans << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n  long long val;\n  int cnt1, cnt2;\n} dp[300005];\nlong long v1[100005], v2[100005], v3[100005];\nlong long s[100005];\ninline bool cmp(long long a, long long b) { return a > b; }\nint cnt1 = 0, cnt2 = 0, cnt3 = 0;\nint main() {\n  int n, m, i, k;\n  long long w;\n  scanf(\"%d%d\", &n, &m);\n  for (i = 1; i <= n; i++) {\n    scanf(\"%d%lld\", &k, &w);\n    if (k == 1) {\n      v1[++cnt1] = w;\n    }\n    if (k == 2) {\n      v2[++cnt2] = w;\n    }\n    if (k == 3) {\n      v3[++cnt3] = w;\n    }\n  }\n  sort(v1 + 1, v1 + cnt1 + 1, cmp);\n  sort(v2 + 1, v2 + cnt2 + 1, cmp);\n  sort(v3 + 1, v3 + cnt3 + 1, cmp);\n  for (i = 1; i <= cnt2; i++) {\n    s[i] = s[i - 1] + v2[i];\n  }\n  dp[0].val = 0;\n  dp[0].cnt1 = 0;\n  dp[0].cnt2 = 0;\n  dp[1].val = v1[1];\n  dp[1].cnt1 = 1;\n  dp[1].cnt2 = 0;\n  dp[2].val = v1[1] + v1[2];\n  dp[2].cnt1 = 2;\n  dp[2].cnt2 = 0;\n  for (i = 3; i <= m; i++) {\n    dp[i].val = dp[i - 1].val + v1[dp[i - 1].cnt1 + 1];\n    dp[i].cnt1 = dp[i - 1].cnt1 + 1;\n    dp[i].cnt2 = dp[i - 1].cnt2;\n    if (dp[i - 3].val + v3[dp[i - 3].cnt2 + 1] > dp[i].val) {\n      dp[i].val = dp[i - 3].val + v3[dp[i - 3].cnt2 + 1];\n      dp[i].cnt1 = dp[i - 3].cnt1;\n      dp[i].cnt2 = dp[i - 3].cnt2 + 1;\n    }\n    if (dp[i].cnt1 > cnt1) {\n      dp[i].cnt1 = cnt1;\n    }\n    if (dp[i].cnt2 > cnt3) {\n      dp[i].cnt2 = cnt3;\n    }\n  }\n  for (i = 1; i <= m; i++) {\n    if (dp[i - 1].val > dp[i].val) {\n      dp[i].val = dp[i - 1].val;\n    }\n  }\n  long long ans = dp[m].val;\n  for (i = 1; i <= cnt2 && 2 * i <= m; i++) {\n    long long tp = dp[m - 2 * i].val + s[i];\n    if (tp > ans) {\n      ans = tp;\n    }\n  }\n  printf(\"%lld\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 1e5 + 7;\nint n, m;\nvector<long long> costs[4];\nlong long sum[4][MAX];\nlong long f(int a, int w) {\n  long long ans = sum[2][a];\n  w -= 2 * a;\n  w = min(w, (int)costs[1].size());\n  ans += sum[1][w];\n  return ans;\n}\nlong long func(int w) {\n  int beg = 0;\n  int last = min(w / 2, (int)costs[2].size());\n  long long ans = 0;\n  while ((last - beg) > 3) {\n    int left = beg + (last - beg) / 3;\n    int right = last - (last - beg) / 3;\n    if (f(left, w) < f(right, w))\n      beg = left;\n    else\n      last = right;\n  }\n  for (int i = beg; i <= last; i++) ans = max(ans, f(i, w));\n  return ans;\n}\nlong long func() {\n  for (int i = 1; i <= 3; i++) {\n    sort(costs[i].rbegin(), costs[i].rend());\n    for (int j = 1; j <= costs[i].size(); j++)\n      sum[i][j] = sum[i][j - 1] + costs[i][j - 1];\n  }\n  long long ans = 0;\n  for (int i = 0; i <= costs[3].size(); i++) {\n    int w = m - 3 * i;\n    if (w < 0) break;\n    ans = max(ans, sum[3][i] + func(w));\n  }\n  return ans;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    int w, c;\n    cin >> w >> c;\n    costs[w].push_back(c);\n  }\n  cout << func() << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint n, m, vs[4][100007], vp[4];\nlong long s1[100007], s2[100007], ans = 0, now = 0;\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    vs[x][++vp[x]] = y;\n  }\n  for (int i = 1; i <= 3; ++i)\n    std::sort(vs[i] + 1, vs[i] + vp[i] + 1, std::greater<int>());\n  for (int i = 1; i <= vp[1]; ++i) s1[i] = s1[i - 1] + vs[1][i];\n  for (int i = 1; i <= vp[2]; ++i) s2[i] = s2[i - 1] + vs[2][i];\n  for (int i = 0; i <= vp[3] && m >= 0; ++i) {\n    int L = 0, R = std::min(vp[2], m / 2), M;\n    while (L < R) {\n      M = L + R >> 1;\n      int m2 = std::min(m - M * 2, vp[1]);\n      if (M * 2 + m2 < m - 1 || vs[2][M] > vs[1][m2] * 2)\n        L = M + 1;\n      else\n        R = M;\n    }\n    for (int x = std::max(0, M - 2); x <= std::min(vp[2], M + 2); ++x) {\n      if (x * 2 > m) continue;\n      int y = std::min(vp[1], m - x * 2);\n      long long a1 = now + s1[y] + s2[x];\n      if (a1 > ans) ans = a1;\n    }\n    m -= 3;\n    now += vs[3][i + 1];\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.*;\nimport java.security.KeyStore.Entry;\nimport java.util.*;\n\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\tpublic class Q2 {\n\t\t\t\t\n\t\t\t\tstatic long MOD = 1000000007;\n\t\t\t\tstatic boolean b[], b1[], check;\n\t\t\t\tstatic ArrayList<Integer>[] amp, pa;\n\t\t\t\tstatic ArrayList<Pair>[] amp1;\n\t\t\t\tstatic ArrayList<Pair>[][] damp;\n\t\t\t\tstatic int left[],right[],end[],sum[],dist[],cnt[],start[],color[],parent[],prime[],size[];\n\t\t\t\tstatic long ans = 0,k;\n\t\t\t\tstatic int p = 1-1;\n\t\t\t\tstatic FasterScanner sc = new FasterScanner(System.in);\n\t\t\t\tstatic Queue<Integer> q = new LinkedList<>();\n\t\t\t\tstatic BufferedWriter log;\n\t\t\t\tstatic HashSet<Pair> hs;\n\t\t\t\tstatic HashMap<Pair,Integer> hm;\n\t\t\t\tstatic PriorityQueue<Integer> pri[];\n\t\t\t\tstatic ArrayList<Integer>[] level;\n\t\t\t\tstatic Stack<Integer> st;\n\t\t\t\tstatic boolean boo[][];\n\t\t\t\tstatic Pair prr[];\n\t\t\t\tstatic long parent1[],parent2[],size1[],size2[],arr1[],SUM[],lev[], fibo[];\n\t\t\t\tstatic int arr[], ver[][];\n\t\t\t\tpublic static void main(String[] args) throws Exception {\n\t\t\t    \t/*new Thread(null, new Runnable() {\n\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\ttry {\n\t\t\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\tSystem.out.println(e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}, \"1\", 1 << 26).start();*/\n\t\t\t\t\tsoln();\n\t\t\t\t}\n\t\t\t\tprivate static boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\t\t\tprivate static void tr(Object... o) {\n\t\t\t\t\tif (!oj)\n\t\t\t\t\t\tSystem.out.println(Arrays.deepToString(o));\n\t\t\t\t}\n\t\t\t\tstatic long dp[][];\n\t\t\t\tstatic int N,K,T,A,B;\n\t\t\t\tstatic int time;\n\t\t\t\tstatic int cost[][];\n\t\t\t\tstatic boolean b11[];\n\t\t\t\tstatic HashMap<Integer,Integer> h = new HashMap<>();\n\t\t\t\tstatic HashSet<Pair> chec;\n\t\t\t\tstatic long ans1;\t\tstatic long ans2;\n\t\t\t\tstatic int BLOCK, MAX = 10000000, door[][];\n\t\t\t\tstatic double pi = Math.PI;\n\t\t\t\tstatic int Arr[], Brr[], pow[],  M;\n\t\t\t\tstatic long fact[] = new long[100000+1];\n\t\t\t\tstatic HashMap<Pair,Integer> hm1;\n\t\t\t\tstatic HashSet<Integer> hs1[], hs2[];\n\t\t\t\tstatic Stack<Integer>[] queue;\n\t\t\t\tstatic PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\n\t\t\t\tstatic int phi[];\n\t\t\t\tpublic static void soln() throws IOException {\n\t\t\t\t\t//FasterScanner in = new FasterScanner(new FileInputStream(\"C:\\\\Users\\\\Admin\\\\Desktop\\\\input50.txt\"));\n\t\t\t\t\t//FasterScanner sc = new FasterScanner(new FileInputStream(\"C:\\\\Users\\\\Admin\\\\Desktop\\\\input.txt\"));\n\t\t\t\t\t//PrintWriter log = new PrintWriter(\"C:\\\\Users\\\\Admin\\\\Desktop\\\\output.txt\");\n\t\t\t\t\t//long s = System.currentTimeMillis();\n\t\t\t\t\tlog = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\t\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\t\t\tamp = (ArrayList<Integer>[]) new ArrayList[4];\n\t\t\t\t\tfor(int i = 0; i< 4;i++){\n\t\t\t\t\t\tamp[i] = new ArrayList<>();\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i = 0; i< n; i++){\n\t\t\t\t\t\tamp[sc.nextInt()].add(sc.nextInt());\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i= 1; i<=3;i++){\n\t\t\t\t\t\twhile(amp[i].size()<(m+5)) amp[i].add(0);\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i = 1; i< 4; i++){\n\t\t\t\t\t\tCollections.sort(amp[i]);\n\t\t\t\t\t\tCollections.reverse(amp[i]);\n\t\t\t\t\t}\n\t\t\t\t\tlong dp[] = new long[m+1];\n\t\t\t\t\tint a1 = 0, a2 = 0;\n\t\t\t\t\tdp[1] = amp[1].get(0);\n\t\t\t\t\tfor(int i = 2;i<=m;i+=2){\n\t\t\t\t\t\tif(amp[2].get(a1)>=(amp[1].get(a2)+amp[1].get(a2+1))){\n\t\t\t\t\t\t\tdp[i] = amp[2].get(a1);\n\t\t\t\t\t\t\ta1++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i] = amp[1].get(a2)+amp[1].get(a2+1);\n\t\t\t\t\t\t\ta2+=2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[i] += dp[i-2];\n\t\t\t\t\t}\n\t\t\t\t\ta1 = 0; a2 = 1;\n\t\t\t\t\tfor(int i = 3;i<=m;i+=2){\n\t\t\t\t\t\tif(amp[2].get(a1)>=(amp[1].get(a2)+amp[1].get(a2+1))){\n\t\t\t\t\t\t\tdp[i] = amp[2].get(a1);\n\t\t\t\t\t\t\ta1++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i] = amp[1].get(a2)+amp[1].get(a2+1);\n\t\t\t\t\t\t\ta2+=2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[i]+=dp[i-2];\n\t\t\t\t\t}\n\t\t\t\t\tlong ans= 0, sum = 0;\n\t\t\t\t\tfor(int i = 0; i<=m/3 ;i++){\n\t\t\t\t\t\tans = Math.max(ans, sum + dp[m-3*i]);\n\t\t\t\t\t\tsum += amp[3].get(i);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(ans);\n\t\t\t\t\t//out.close();\n\t\t\t\t\t//tr(System.currentTimeMillis() - s + \"ms\");\n\t\t\t\t\tlog.close();\n\t\t\t\t\t//out.close();\n\t\t\t\t}\n\t\t\t\tstatic long get(int m){\n\t\t\t\t\tfor(int i = 0;i<=1;i++)for(int i1 = 0;i1<=1;i1++)for(int i2 = 0;i2<=1;i2++)\n\t\t\t\t\t\tfor(int i5 = 0;i5<=2;i5++)for(int i4 = 0;i4<=3;i4++)for(int i3 = 0;i3<=3;i3++){\n\t\t\t\t\t\t\tint x = i+i1+i2+i3+i4+i5;\n\t\t\t\t\t\t\tint a1 = -1,a2 = -1,a3 = -1,a4 = -1,a5 = -1,a6 = -1, b1,b2,b3,b4,b5,b6;\n\t\t\t\t\t\t\tlong max = 0;\n\t\t\t\t\t\t\tif(m>=6){\n\t\t\t\t\t\t\t\tif(x==6){\n\t\t\t\t\t\t\t\t\tif(!queue[i].isEmpty()) a1 = queue[i].pop();\n\t\t\t\t\t\t\t\t\tif(!queue[i1].isEmpty()) a2 = queue[i1].pop();\n\t\t\t\t\t\t\t\t\tif(!queue[i2].isEmpty()) a3 = queue[i2].pop();\n\t\t\t\t\t\t\t\t\tif(!queue[i3].isEmpty()) a4 = queue[i3].pop();\n\t\t\t\t\t\t\t\t\tif(!queue[i4].isEmpty()) a5 = queue[i4].pop();\n\t\t\t\t\t\t\t\t\tif(!queue[i5].isEmpty()) a6 = queue[i5].pop();\n\t\t\t\t\t\t\t\t\tif(!(a1==-1 || a2==-1 || a3==-1 || a4==-1 || a5==-1 || a6==-1 )){\n\t\t\t\t\t\t\t\t\t\tlong sum = a1+a2+a3+a4+a5+a6;\n\t\t\t\t\t\t\t\t\t\tif(sum>max){\n\t\t\t\t\t\t\t\t\t\t\tmax = sum;\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(a1!=-1) queue[i].add(a1);\n\t\t\t\t\t\t\t\t\tif(a2!=-1) queue[i1].add(a2);\n\t\t\t\t\t\t\t\t\tif(a3!=-1) queue[i2].add(a3);\n\t\t\t\t\t\t\t\t\tif(a4!=-1) queue[i3].add(a4);\n\t\t\t\t\t\t\t\t\tif(a5!=-1) queue[i4].add(a5);\n\t\t\t\t\t\t\t\t\tif(a6!=-1) queue[i5].add(a6);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tif(x==m){\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tstatic long recur(int x, long k, int m){\n\t\t\t\t\tif(k==0) return 1;\n\t\t\t\t\tif(m==1) return 0;\n\t\t\t\t\treturn power(x, recur(x,k-1,phi[m]), m);\n\t\t\t\t}\n\t\t\t\tstatic void bfs(){\n\t\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\t\tint y = q.poll();\n\t\t\t\t\t\tfor(int x:amp[y]){\n\t\t\t\t\t\t\tb1[x] = true;\n\t\t\t\t\t\t\tif(door[x][0]==y){\n\t\t\t\t\t\t\t\tint d = door[x][1];\n\t\t\t\t\t\t\t\tif(b[d]){\n\t\t\t\t\t\t\t\t\tif(prime[d]!=(1-arr[x-1]^prime[y])){\n\t\t\t\t\t\t\t\t\t\tcheck = true;\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tprime[d] = 1-arr[x-1]^prime[y];\n\t\t\t\t\t\t\t\t\tq.add(d);\n\t\t\t\t\t\t\t\t\tb[d] = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tint d = door[x][0];\n\t\t\t\t\t\t\t\tif(b[d]){\n\t\t\t\t\t\t\t\t\tif(prime[d]!=(1-arr[x-1]^prime[y])){\n\t\t\t\t\t\t\t\t\t\tcheck = true;\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tprime[d] = 1-arr[x-1]^prime[y];\n\t\t\t\t\t\t\t\t\tq.add(d);\n\t\t\t\t\t\t\t\t\tb[d] = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpublic static class FenwickTree {\n\t\t\t\t\t\n\t\t\t\t    int[] array; // 1-indexed array, In this array We save cumulative information to perform efficient range queries and updates\n\t\n\t\t\t\t    public FenwickTree(int size) {\n\t\t\t\t        array = new int[size + 1];\n\t\t\t\t    }\n\t\t\t\t    public int rsq(int ind) {\n\t\t\t\t        assert ind > 0;\n\t\t\t\t        int sum = 0;\n\t\t\t\t        while (ind > 0) {\n\t\t\t\t            sum += array[ind];\n\t\t\t\t            //Extracting the portion up to the first significant one of the binary representation of 'ind' and decrementing ind by that number\n\t\t\t\t            ind -= ind & (-ind);\n\t\t\t\t        }\n\t\t\t\t        return sum;\n\t\t\t\t    }\n\t\t\t\t    public int rsq(int a, int b) {\n\t\t\t\t        assert b >= a && a > 0 && b > 0;\n\t\t\t\t        return rsq(b) - rsq(a - 1);\n\t\t\t\t    }\n\t\t\t\t    public void update(int ind, int value) {\n\t\t\t\t        assert ind > 0;\n\t\t\t\t        while (ind < array.length) {\n\t\t\t\t            array[ind] += value;\n\t\t\t\t            //Extracting the portion up to the first significant one of the binary representation of 'ind' and incrementing ind by that number\n\t\t\t\t            ind += ind & (-ind);\n\t\t\t\t        }\n\t\t\t\t    }\n\t\n\t\t\t\t    public int size() {\n\t\t\t\t        return array.length - 1;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tstatic double power(double x, long y)\n\t\t\t\t{\n\t\t\t\t    if (y == 0)\n\t\t\t\t        return 1;\n\t\t\t\t    double p = power(x, y/2);\n\t\t\t\t    p = (p * p);\n\t\t\t\t \n\t\t\t\t    return (y%2 == 0)? p : (x * p);\n\t\t\t\t}\n\t\t\t\tstatic void Bfs(int x){\n\t\t\t\t\tq.add(x);\n\t\t\t\t\tb[x] = true;\n\t\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\t\tint y = q.poll();\n\t\t\t\t\t\tb[y] = true;\n\t\t\t\t\t\tfor(int p:hs2[y]){\n\t\t\t\t\t\t\tif(!b[p]){\n\t\t\t\t\t\t\t\tif(!hs1[y].contains(p)) dist[p] = dist[y]-1;\n\t\t\t\t\t\t\t\telse dist[p] = dist[y]+1;\n\t\t\t\t\t\t\t\tq.add(p);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstatic int Dfs(int x, int val){\n\t\t\t\t\tb[x] = true;\n\t\t\t\t\tfor(int p:hs2[x]){\n\t\t\t\t\t\tif(!b[p]){\n\t\t\t\t\t\t\tif(!hs1[x].contains(p)) val++;\n\t\t\t\t\t\t\tval += Dfs(p,0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn val;\n\t\t\t\t}\n\t\t\t\tstatic long nCr(int n, int r){\n\t\t\t\t\tif(n<r) return 0;\n\t\t\t\t\telse return (((fact[n]*modInverse(fact[r], MOD))%MOD)*modInverse(fact[n-r], MOD))%MOD;\n\t\t\t\t}\n\t\t\t\tstatic void dfs1(int x, int p){\n\t\t\t\t\tarr1[x] += lev[x];\n\t\t\t\t\tfor(int v:amp[x]){\n\t\t\t\t\t\tif(v!=p){\n\t\t\t\t\t\t\tdfs1(v,x);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstatic void dfs(int x, int p){\n\t\t\t\t\tstart[x] = time++;\n\t\t\t\t\tfor(int v:amp[x]){\n\t\t\t\t\t\tif(v!=p){\n\t\t\t\t\t\t\tdfs(v,x);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tend[x] = time;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tstatic void bfs(int x){\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tpublic static void seive(int n){\n\t\t\t\t\tb = new boolean[(n+1)];\n\t\t\t\t\tArrays.fill(b, true);\n\t\t\t\t\tb[1] = true;\n\t\t\t\t\tfor(int i = 2;i*i<=n;i++){\n\t\t\t\t\t\tif(b[i]){\n\t\t\t\t\t\t\tfor(int p = 2*i;p<=n;p+=i){\n\t\t\t\t\t\t\t\tb[p] = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/*for(int i = 2;i<=n;i++){\n\t\t\t\t\t\tif(b[i]) prime[i] = i;\n\t\t\t\t\t}*/\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstatic class Graph{\n\t\t\t\t\tint vertex;\n\t\t\t\t\tint weight;\n\t\t\t\t\tGraph(int v, int w){\n\t\t\t\t\t\tvertex = v;\n\t\t\t\t\t\tweight = w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstatic class Pair implements Comparable<Pair> {\n\t\t\t\t\tint u;\n\t\t\t\t\tint v;\n\t\t\t\t\tdouble ans;\n\t\t\t\t\tpublic Pair(){\n\t\t\t\t\t\tu = 0;\n\t\t\t\t\t\tv = 0;\n\t\t\t\t\t}\n\t\t\t\t\tpublic Pair(int u, int v) {\n\t\t\t\t\t\tthis.u = u;\n\t\t\t\t\t\tthis.v = v;\n\t\t\t\t\t}\n\t\t\t\t\tpublic int hashCode() {\n\t\t\t\t\t\treturn Objects.hash();\n\t\t\t\t\t}\n\t\t\t\t\tpublic boolean equals(Object o) {\n\t\t\t\t\t\tPair other = (Pair) o;\n\t\t\t\t\t\treturn ((u == other.u && v == other.v));\n\t\t\t\t\t}\n\t\t\t \n\t\t\t\t\tpublic int compareTo(Pair other) {\n\t\t\t\t\t\t//return Double.compare(ans, other.ans);\n\t\t\t\t\t\treturn Long.compare(u, other.u);// != 0 ? (Long.compare(u, other.u)) : (Long.compare(v,other.v));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\treturn \"[u=\" + u + \", v=\" + v + \"]\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpublic static void buildGraph(int n){\n\t\t\t\t\tfor(int i =0;i<n;i++){\n\t\t\t\t\t\tint x = sc.nextInt()-1, y = sc.nextInt()-1;\n\t\t\t\t\t\t//hm.put(new Pair(x,y), i+1);\n\t\t\t\t\t\ths1[x].add(y);\n\t\t\t\t\t\ths2[y].add(x);\n\t\t\t\t\t\ths2[x].add(y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tpublic static int getParent(long x){\n\t\t\t\t\twhile(parent[(int) x]!=x){\n\t\t\t\t\t\tparent[ (int) x] = parent[(int) parent[ (int) x]];\n\t\t\t\t\t\tx = parent[ (int) x];\n\t\t\t\t\t}\n\t\t\t\t\treturn (int) x;\n\t\t\t\t}\n\t\t\t\tstatic long min(long a, long b, long c){\n\t\t\t\t\tif(a<b && a<c) return a;\n\t\t\t\t\tif(b<c) return b;\n\t\t\t\t\treturn c;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t\n\t\t\t\tstatic class Pair3{\n\t\t\t\t\tint x, y ,z;\n\t\t\t\t\tPair3(int x, int y, int z){\n\t\t\t\t\t\tthis.x = x;\n\t\t\t\t\t\tthis.y = y;\n\t\t\t\t\t\tthis.z = z;\n\t\t\t\t\t}\n\t\t\t\t}*/\n\t\t\t\t static void KMPSearch(String pat, String txt)\n\t\t\t\t    {\n\t\t\t\t        int M = pat.length();\n\t\t\t\t        int N = txt.length();\n\t\t\t\t \n\t\t\t\t        // create lps[] that will hold the longest\n\t\t\t\t        // prefix suffix values for pattern\n\t\t\t\t        int lps[] = new int[M];\n\t\t\t\t        int j = 0;  // index for pat[]\n\t\t\t\t \n\t\t\t\t        // Preprocess the pattern (calculate lps[]\n\t\t\t\t        // array)\n\t\t\t\t        computeLPSArray(pat,M,lps);\n\t\t\t\t \n\t\t\t\t        int i = 0;  // index for txt[]\n\t\t\t\t        while (i < N)\n\t\t\t\t        {\n\t\t\t\t            if (pat.charAt(j) == txt.charAt(i))\n\t\t\t\t            {\n\t\t\t\t                j++;\n\t\t\t\t                i++;\n\t\t\t\t            }\n\t\t\t\t            if (j == M)\n\t\t\t\t            {\n\t\t\t\t               // parent.add((i-j));\n\t\t\t\t                j = lps[j-1];\n\t\t\t\t            }\n\t\t\t\t \n\t\t\t\t            // mismatch after j matches\n\t\t\t\t            else if (i < N && pat.charAt(j) != txt.charAt(i))\n\t\t\t\t            {\n\t\t\t\t                // Do not match lps[0..lps[j-1]] characters,\n\t\t\t\t                // they will match anyway\n\t\t\t\t                if (j != 0)\n\t\t\t\t                    j = lps[j-1];\n\t\t\t\t                else\n\t\t\t\t                    i = i+1;\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t static void computeLPSArray(String pat, int M, int lps[])\n\t\t\t\t    {\n\t\t\t\t        // length of the previous longest prefix suffix\n\t\t\t\t        int len = 0;\n\t\t\t\t        int i = 1;\n\t\t\t\t        lps[0] = 0;  // lps[0] is always 0\n\t\t\t\t \n\t\t\t\t        // the loop calculates lps[i] for i = 1 to M-1\n\t\t\t\t        while (i < M)\n\t\t\t\t        {\n\t\t\t\t            if (pat.charAt(i) == pat.charAt(len))\n\t\t\t\t            {\n\t\t\t\t                len++;\n\t\t\t\t                lps[i] = len;\n\t\t\t\t                i++;\n\t\t\t\t            }\n\t\t\t\t            else  // (pat[i] != pat[len])\n\t\t\t\t            {\n\t\t\t\t                // This is tricky. Consider the example.\n\t\t\t\t                // AAACAAAA and i = 7. The idea is similar \n\t\t\t\t                // to search step.\n\t\t\t\t                if (len != 0)\n\t\t\t\t                {\n\t\t\t\t                    len = lps[len-1];\n\t\t\t\t \n\t\t\t\t                    // Also, note that we do not increment\n\t\t\t\t                    // i here\n\t\t\t\t                }\n\t\t\t\t                else  // if (len == 0)\n\t\t\t\t                {\n\t\t\t\t                    lps[i] = len;\n\t\t\t\t                    i++;\n\t\t\t\t                }\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\tprivate static void permutation(String prefix, String str) {\n\t\t\t\t    int n = str.length();\n\t\t\t\t    if (n == 0); //hs.add(prefix);\n\t\t\t\t    else {\n\t\t\t\t        for (int i = 0; i < n; i++)\n\t\t\t\t            permutation(prefix + str.charAt(i), str.substring(0, i) + str.substring(i+1, n));\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpublic static void buildTree(int n){\n\t\t\t\t\tint arr[] = sc.nextIntArray(n);\n\t\t\t\t\tfor(int i = 0;i<n;i++){\n\t\t\t\t\t\tint x = arr[i]-1;\n\t\t\t\t\t\tamp[i+1].add(x);\n\t\t\t\t\t\tamp[x].add(i+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstatic class SegmentTree {\n\t\t\t\t\tboolean st[];\n\t\t\t\t\tboolean lazy[];\n\t\t\n\t\t\t\t\tSegmentTree(int n) {\n\t\t\t\t\t\tint size = 4 * n;\n\t\t\t\t\t\tst = new boolean[size];\n\t\t\t\t\t\tArrays.fill(st, true);\n\t\t\t\t\t\tlazy = new boolean[size];\n\t\t\t\t\t\tArrays.fill(lazy, true);\n\t\t\t\t\t\t//build(0, n - 1, 1);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t/*long[] build(int ss, int se, int si) {\n\t\t\t\t\t\tif (ss == se) {\n\t\t\t\t\t\t\tst[si][0] = 1;\n\t\t\t\t\t\t\tst[si][1] = 1;\n\t\t\t\t\t\t\tst[si][2] = 1;\n\t\t\t\t\t\t\treturn st[si];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint mid = (ss + se) / 2;\n\t\t\t\t\t\tlong a1[] = build(ss, mid, si * 2), a2[] = build(mid + 1, se,\n\t\t\t\t\t\t\t\tsi * 2 + 1);\n\t\t\t\t\t\tlong ans[] = new long[3];\n\t\t\t\t\t\tif (arr[mid] < arr[mid + 1]) {\n\t\t\t\t\t\t\tans[1] = Math.max(a2[1], Math.max(a1[1], a1[2] + a2[0]));\n\t\t\t\t\t\t\tif (a1[1] == (mid - ss + 1))\n\t\t\t\t\t\t\t\tans[0] = ans[1];\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tans[0] = a1[0];\n\t\t\t\t\t\t\tif (a2[2] == (se - mid))\n\t\t\t\t\t\t\t\tans[2] = ans[1];\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tans[2] = a2[2];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tans[1] = Math.max(a1[1], a2[1]);\n\t\t\t\t\t\t\tans[0] = a1[0];\n\t\t\t\t\t\t\tans[2] = a2[2];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tst[si] = ans;\n\t\t\t\t\t\treturn st[si];\n\t\t\t\t\t}*/\n\t\t\n\t\t\t\t\tvoid update(int si, int ss, int se, int idx, long x) {\n\t\t\t\t\t\tif (ss == se) {\n\t\t\t\t\t\t\t//arr[idx] += val;\n\t\t\t\t\t\t\tst[si]=false;\n\t\t\t\t\t\t} \n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tint mid = (ss + se) / 2;\n\t\t\t\t\t\t\tif(ss <= idx && idx <= mid)\n\t\t\t\t\t        {\n\t\t\t\t\t             update(2*si, ss, mid, idx, x);\n\t\t\t\t\t        }\n\t\t\t\t\t        else\n\t\t\t\t\t        { update(2*si+1, mid+1, se, idx, x);\n\t\t\t\t\t        }\n\t\t\t\t\t\t\tst[si] = st[2*si]|st[2*si+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/*boolean get(int qs, int qe, int ss, int se, int si){\n\t\t\t\t\t\tif(qs>se || qe<ss) return 0;\n\t\t\t\t\t\tif (qs <= ss && qe >= se) {\n\t\t\t\t\t\t\treturn st[si];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint mid = (ss+se)/2;\n\t\t\t\t\t\treturn get(qs, qe, ss, mid, si * 2)+get(qs, qe, mid + 1, se, si * 2 + 1);\n\t\t\t\t\t}*/\n\t\t\t\t\tvoid updateRange(int node, int start, int end, int l, int r, boolean val)\n\t\t\t\t\t{\n\t\t\t\t\t    if(!lazy[node])\n\t\t\t\t\t    { \n\t\t\t\t\t        // This node needs to be updated\n\t\t\t\t\t        st[node] = lazy[node];    // Update it\n\t\t\t\t\t        if(start != end)\n\t\t\t\t\t        {\n\t\t\t\t\t            lazy[node*2] = lazy[node];                  // Mark child as lazy\n\t\t\t\t\t            lazy[node*2+1] = lazy[node];                // Mark child as lazy\n\t\t\t\t\t        }\n\t\t\t\t\t        lazy[node] = true;                                  // Reset it\n\t\t\t\t\t    }\n\t\t\t\t\t    if(start > end || start > r || end < l)              // Current segment is not within range [l, r]\n\t\t\t\t\t        return;\n\t\t\t\t\t    if(start >= l && end <= r)\n\t\t\t\t\t    {\n\t\t\t\t\t        // Segment is fully within range\n\t\t\t\t\t        st[node] =  val;\n\t\t\t\t\t        if(start != end)\n\t\t\t\t\t        {\n\t\t\t\t\t            // Not leaf node\n\t\t\t\t\t            lazy[node*2] = val;\n\t\t\t\t\t            lazy[node*2+1] = val;\n\t\t\t\t\t        }\n\t\t\t\t\t        return;\n\t\t\t\t\t    }\n\t\t\t\t\t    int mid = (start + end) / 2;\n\t\t\t\t\t    updateRange(node*2, start, mid, l, r, val);        // Updating left child\n\t\t\t\t\t    updateRange(node*2 + 1, mid + 1, end, l, r, val);   // Updating right child\n\t\t\t\t\t    st[node] = st[node*2] | st[node*2+1];        // Updating root with max value \n\t\t\t\t\t}\n\t\t\n\t\t\t\t\tboolean queryRange(int node, int start, int end, int l, int r)\n\t\t\t\t\t{\n\t\t\t\t\t    if(start > end || start > r || end < l)\n\t\t\t\t\t        return false;         // Out of range\n\t\t\t\t\t    if(!lazy[node])\n\t\t\t\t\t    {\n\t\t\t\t\t        // This node needs to be updated\n\t\t\t\t\t        st[node] = lazy[node];            // Update it\n\t\t\t\t\t        if(start != end)\n\t\t\t\t\t        {\n\t\t\t\t\t            lazy[node*2] = lazy[node];         // Mark child as lazy\n\t\t\t\t\t            lazy[node*2+1] = lazy[node];    // Mark child as lazy\n\t\t\t\t\t        }\n\t\t\t\t\t        lazy[node] = true;                 // Reset it\n\t\t\t\t\t    }\n\t\t\t\t\t    if(start >= l && end <= r)             // Current segment is totally within range [l, r]\n\t\t\t\t\t        return  st[node];\n\t\t\t\t\t    int mid = (start + end) / 2;\n\t\t\t\t\t    boolean p1 = queryRange(node*2, start, mid, l, r);         // Query left child\n\t\t\t\t\t    boolean b = queryRange(node*2 + 1, mid + 1, end, l, r); // Query right child\n\t\t\t\t\t    return (p1 | b);\n\t\t\t\t\t}\n\t\t\t\t\tvoid print() {\n\t\t\t\t\t\tfor (int i = 0; i < st.length; i++) {\n\t\t\t\t\t\t\tSystem.out.print(st[i]+\" \");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSystem.out.println();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstatic int convert(int x){\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tString str = Integer.toBinaryString(x);\n\t\t\t\t\t//System.out.println(str);\n\t\t\t\t\tfor(int i = 0;i<str.length();i++){\n\t\t\t\t\t\tif(str.charAt(i)=='1'){\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint ans = (int) Math.pow(3, 6-cnt);\n\t\t\t\t\treturn ans;\n\t\t\t\t}\n\t\t\t\tstatic class Node2{\n\t\t\t\t\tNode2 left = null;\n\t\t\t\t\tNode2 right = null;\n\t\t\t\t\tNode2 parent = null;\n\t\t\t\t\tint data;\n\t\t\t\t}\n\t\t\t\tstatic class BinarySearchTree{\n\t\t\t\t\tNode2 root = null;\n\t\t\t\t\tint height = 0;\n\t\t\t\t\tint max = 0;\n\t\t\t\t\tint cnt = 1;\n\t\t\t\t\tArrayList<Integer> parent = new ArrayList<>();\n\t\t\t\t\tHashMap<Integer, Integer> hm = new HashMap<>();\n\t\t\t\t\tpublic void insert(int x){\n\t\t\t\t\t\tNode2 n = new Node2();\n\t\t\t\t\t\tn.data = x;\n\t\t\t\t\t\tif(root==null){\n\t\t\t\t\t\t\troot = n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tNode2 temp = root,temb = null;\n\t\t\t\t\t\t\twhile(temp!=null){\n\t\t\t\t\t\t\t\ttemb = temp;\n\t\t\t\t\t\t\t\tif(x>temp.data) temp = temp.right;\n\t\t\t\t\t\t\t\telse temp = temp.left;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(x>temb.data) temb.right = n;\n\t\t\t\t\t\t\telse temb.left = n;\n\t\t\t\t\t\t\tn.parent = temb;\n\t\t\t\t\t\t\tparent.add(temb.data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpublic Node2 getSomething(int x, int y, Node2 n){\n\t\t\t\t\t\tif(n.data==x || n.data==y) return n;\n\t\t\t\t\t\telse if(n.data>x && n.data<y) return n;\n\t\t\t\t\t\telse if(n.data<x && n.data<y) return getSomething(x,y,n.right);\n\t\t\t\t\t\telse return getSomething(x,y,n.left);\n\t\t\t\t\t}\n\t\t\t\t\tpublic Node2 search(int x,Node2 n){\n\t\t\t\t\t\tif(x==n.data){\n\t\t\t\t\t\t\tmax = Math.max(max, n.data);\n\t\t\t\t\t\t\treturn n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(x>n.data){\n\t\t\t\t\t\t\tmax = Math.max(max, n.data);\n\t\t\t\t\t\t\treturn search(x,n.right);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tmax = Math.max(max, n.data);\n\t\t\t\t\t\t\treturn search(x,n.left);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpublic int getHeight(Node2 n){\n\t\t\t\t\t\tif(n==null) return 0;\n\t\t\t\t\t\theight = 1+ Math.max(getHeight(n.left), getHeight(n.right));\n\t\t\t\t\t\treturn height;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstatic long findDiff(long[] arr, long[] brr, int m){\n\t\t\t\t\tint i = 0, j = 0;\n\t\t\t\t\tlong fa = 1000000000000L;\n\t\t\t\t\twhile(i<m && j<m){\n\t\t\t\t\t\tlong x = arr[i]-brr[j];\n\t\t\t\t\t\tif(x>=0){\n\t\t\t\t\t\t\tif(x<fa) fa = x;\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tif((-x)<fa) fa = -x;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn fa;\n\t\t\t\t}\n\t\t\t\tpublic static long max(long x, long y, long z){\n\t\t\t\t\tif(x>=y && x>=z) return x;\n\t\t\t\t\tif(y>=x && y>=z) return y;\n\t\t\t\t\treturn z;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstatic long modInverse(long a, long mOD2){\n\t\t\t\t            return  power(a, mOD2-2, mOD2);\n\t\t\t\t}\n\t\t\t\tstatic long power(long x, long y, long m)\n\t\t\t\t{\n\t\t\t\t    if (y == 0)\n\t\t\t\t        return 1;\n\t\t\t\t    long p = power(x, y/2, m) % m;\n\t\t\t\t    p = (p * p) % m;\n\t\t\t\t \n\t\t\t\t    return (y%2 == 0)? p : (x * p) % m;\n\t\t\t\t}\n\t\t\t\tstatic long d,x,y;\n\t\t\t\tpublic static void extendedEuclidian(long a, long b){\n\t\t\t\t\tif(b == 0) {\n\t\t\t\t        d = a;\n\t\t\t\t        x = 1;\n\t\t\t\t        y = 0;\n\t\t\t\t    }\n\t\t\t\t    else {\n\t\t\t\t        extendedEuclidian(b, a%b);\n\t\t\t\t        int temp = (int) x;\n\t\t\t\t        x = y;\n\t\t\t\t        y = temp - (a/b)*y;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpublic static long gcd(long n, long m){\n\t\t\t\t\tif(m!=0) return gcd(m,n%m);\n\t\t\t\t\telse return n;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstatic BufferedReader reader;\n\t\t\t    static StringTokenizer tokenizer;\n\t\t\t    static PrintWriter writer;\n\t\t\t\n\t\t\t\n\t\t\t   \n\t\t\t    static class FasterScanner {\n\t\t\n\t\t\t\t\tprivate final InputStream stream;\n\t\t\t\t\tprivate final byte[] buf = new byte[8192];\n\t\t\t\t\tprivate int curChar, snumChars;\n\t\t\t\t\tprivate SpaceCharFilter filter;\n\t\t\n\t\t\t\t\tpublic FasterScanner(InputStream stream) {\n\t\t\t\t\t\tthis.stream = stream;\n\t\t\t\t\t}\n\t\t\n\t\t\t\t\tpublic int snext() {\n\t\t\t\t\t\tif (snumChars == -1)\n\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\tif (curChar >= snumChars) {\n\t\t\t\t\t\t\tcurChar = 0;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn buf[curChar++];\n\t\t\t\t\t}\n\t\t\n\t\t\t\t\tpublic int nextInt() {\n\t\t\t\t\t\tint c = snext();\n\t\t\t\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\t\t\t\tc = snext();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint sgn = 1;\n\t\t\t\t\t\tif (c == '-') {\n\t\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\t\tc = snext();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint res = 0;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\t\tc = snext();\n\t\t\t\t\t\t} while (!isSpaceChar(c));\n\t\t\t\t\t\treturn res * sgn;\n\t\t\t\t\t}\n\t\t\n\t\t\t\t\tpublic long nextLong() {\n\t\t\t\t\t\tint c = snext();\n\t\t\t\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\t\t\t\tc = snext();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint sgn = 1;\n\t\t\t\t\t\tif (c == '-') {\n\t\t\t\t\t\t\tsgn = -1;\n\t\t\t\t\t\t\tc = snext();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlong res = 0;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\t\t\tres *= 10;\n\t\t\t\t\t\t\tres += c - '0';\n\t\t\t\t\t\t\tc = snext();\n\t\t\t\t\t\t} while (!isSpaceChar(c));\n\t\t\t\t\t\treturn res * sgn;\n\t\t\t\t\t}\n\t\t\n\t\t\t\t\tpublic int[] nextIntArray(int n) {\n\t\t\t\t\t\tint a[] = new int[n];\n\t\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\t\ta[i] = nextInt();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn a;\n\t\t\t\t\t}\n\t\t\n\t\t\t\t\tpublic long[] nextLongArray(int n) {\n\t\t\t\t\t\tlong a[] = new long[n];\n\t\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\t\ta[i] = nextLong();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn a;\n\t\t\t\t\t}\n\t\t\t                \n\t\t\t\t\tpublic String readString() {\n\t\t\t\t\t\tint c = snext();\n\t\t\t\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\t\t\t\tc = snext();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tStringBuilder res = new StringBuilder();\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tres.appendCodePoint(c);\n\t\t\t\t\t\t\tc = snext();\n\t\t\t\t\t\t} while (!isSpaceChar(c));\n\t\t\t\t\t\treturn res.toString();\n\t\t\t\t\t}\n\t\t\n\t\t\t\t\tpublic String nextLine() {\n\t\t\t\t\t\tint c = snext();\n\t\t\t\t\t\twhile (isSpaceChar(c))\n\t\t\t\t\t\t\tc = snext();\n\t\t\t\t\t\tStringBuilder res = new StringBuilder();\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tres.appendCodePoint(c);\n\t\t\t\t\t\t\tc = snext();\n\t\t\t\t\t\t} while (!isEndOfLine(c));\n\t\t\t\t\t\treturn res.toString();\n\t\t\t\t\t}\n\t\t\n\t\t\t\t\tpublic boolean isSpaceChar(int c) {\n\t\t\t\t\t\tif (filter != null)\n\t\t\t\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\t\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t\t\t\t}\n\t\t\n\t\t\t\t\tprivate boolean isEndOfLine(int c) {\n\t\t\t\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t\t\t\t}\n\t\t\n\t\t\t\t\tpublic interface SpaceCharFilter {\n\t\t\t\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}  "
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class C>\nvoid mini(C& a4, C b4) {\n  a4 = min(a4, b4);\n}\ntemplate <class C>\nvoid maxi(C& a4, C b4) {\n  a4 = max(a4, b4);\n}\ntemplate <class T1, class T2>\nostream& operator<<(ostream& out, pair<T1, T2> pair) {\n  return out << \"(\" << pair.first << \", \" << pair.second << \")\";\n}\nconst int maxn = 300010;\nint n, W;\nint w[maxn], v[maxn];\nvector<int> A, B, C;\nint nA, nB, nC;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> W;\n  for (int i = (0); i < (n); i++) {\n    cin >> w[i] >> v[i];\n    if (w[i] == 1) A.push_back(v[i]);\n    if (w[i] == 2) B.push_back(v[i]);\n    if (w[i] == 3) C.push_back(v[i]);\n  }\n  sort(A.begin(), A.end());\n  reverse(A.begin(), A.end());\n  sort(B.begin(), B.end());\n  reverse(B.begin(), B.end());\n  sort(C.begin(), C.end());\n  reverse(C.begin(), C.end());\n  nA = A.size();\n  nB = B.size();\n  nC = C.size();\n  long long dp[maxn], suma[maxn];\n  pair<int, int> r[maxn];\n  memset(dp, 0LL, sizeof dp);\n  dp[0] = 0;\n  r[0] = pair<int, int>(0, 0);\n  for (int i = (1); i < (W + 1); i++) {\n    pair<int, int> x = r[i - 1];\n    pair<int, int> y;\n    if (i >= 2) y = r[i - 2];\n    if (x.first < nA) {\n      if (dp[i - 1] + A[x.first] > dp[i]) {\n        dp[i] = dp[i - 1] + A[x.first];\n        r[i] = pair<int, int>(x.first + 1, x.second);\n      }\n    }\n    if (i >= 2 and y.second < nB) {\n      if (dp[i - 2] + B[y.second] > dp[i]) {\n        dp[i] = dp[i - 2] + (int)B[y.second];\n        r[i] = pair<int, int>(y.first, y.second + 1);\n      }\n    }\n    if (dp[i - 1] > dp[i]) {\n      dp[i] = dp[i - 1];\n      r[i] = r[i - 1];\n    }\n    if (i >= 2 and dp[i - 2] > dp[i]) {\n      dp[i] = dp[i - 2];\n      r[i] = r[i - 2];\n    }\n  }\n  for (int i = (0); i < (nC); i++) {\n    suma[i] = C[i];\n    if (i > 0) suma[i] += suma[i - 1];\n  }\n  long long maxi = 0;\n  for (int i = (0); i < (W); i++) {\n    if (W - (i + 1) * 3 < 0) break;\n    maxi = max(maxi, suma[i] + dp[W - (i + 1) * 3]);\n  }\n  maxi = max(maxi, dp[W]);\n  cout << maxi << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n,m = map(int,input().split())\na = [[],[],[]]\nfor _ in range(n):\n    x,y = map(int,input().split())\n    a[x-1].append(y)\n\nfor i in range(3):\n    a[i].sort(reverse=True)\n\na_one_odd = []\na_one_even = []\na_length = [len(a[i]) for i in range(3)]\nfor i in range(0,a_length[0]-1,2):\n    a_one_even.append(a[0][i]+a[0][i+1])\nfor i in range(1,a_length[0]-1,2):\n    a_one_odd.append(a[0][i]+a[0][i+1])\ndata_even = sorted(a_one_even+a[1],reverse=True)\ndata_odd = sorted(a_one_odd+a[1],reverse=True)\n\ndata_sum_even = [0]\nfor x in data_even:\n    data_sum_even.append(data_sum_even[-1]+x)\ndata_sum_odd = [0]\nfor x in data_odd:\n    data_sum_odd.append(data_sum_odd[-1]+x)\n\ndata_sum_three = [0]\nfor x in a[2]:\n    data_sum_three.append(data_sum_three[-1]+x)\n\nans = 0\n#print(data_sum_odd,data_sum_even,data_sum_three)\nfor k in range(a_length[2]+1):\n    if m-3*k < 0:break\n    now1,now2 = data_sum_three[k],data_sum_three[k]\n    if (m-3*k)%2== 0:\n        now1 += data_sum_even[min((m-3*k)//2,len(data_sum_even)-1)]\n        if a_length[0] > 0 and m-3*k > 0:\n            now2 += a[0][0]\n        if (m-3*k)//2 >= 1:\n            now2 += data_sum_odd[min((m-3*k)//2-1,len(data_sum_odd)-1)]\n    else:\n        now1 += data_sum_even[min((m-3*k)//2,len(data_sum_even)-1)]\n        if a_length[0] > 0 and m-3*k > 0:\n            now2 += a[0][0]\n        now2 += data_sum_odd[min((m-3*k-1)//2,len(data_sum_odd)-1)]\n    ans = max(ans,now1,now2)\n\n\nprint(ans)"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 111111;\nlong long dp[4][maxn];\nint cnt[4];\nlong long go(int x, int y) { return dp[2][x] + dp[1][min(cnt[1], y - x * 2)]; }\nlong long get(int x) {\n  int l = 0, ans = min(x >> 1, cnt[2]), r = ans - 1;\n  while (l <= r) {\n    int mid = (l + r) >> 1;\n    if (go(mid, x) > go(mid + 1, x)) {\n      ans = mid;\n      r = mid - 1;\n    } else\n      l = mid + 1;\n  }\n  return go(ans, x);\n}\nbool cmp(long long x, long long y) { return x > y; }\nint main() {\n  int n, m, a, b;\n  cin >> n >> m;\n  for (int(i) = 1; (i) <= (n); (i)++) {\n    cin >> a >> b;\n    dp[a][++cnt[a]] = b;\n  }\n  for (int(i) = 1; (i) <= (3); (i)++) {\n    sort(dp[i] + 1, dp[i] + 1 + cnt[i], cmp);\n    for (int(j) = 1; (j) <= (cnt[i]); (j)++) {\n      dp[i][j] += dp[i][j - 1];\n    }\n  }\n  long long ans = 0;\n  for (int i = 0; i <= cnt[3] && i * 3 <= m; i++) {\n    ans = max(ans, dp[3][i] + get(m - i * 3));\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "/**\n * Wanna play splatoon.\n */\nimport java.util.*;\npublic class Main {\n    public static class Pair {\n        int index1;\n        int index2;\n        long cost;\n        Pair (int index1, int index2, long cost) {\n            this.index1 = index1;\n            this.index2 = index2;\n            this.cost = cost;\n        }\n    }\n    public static void main(String [] args)\n    {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        List<Integer> list1 = new ArrayList<Integer>();\n        List<Integer> list2 = new ArrayList<Integer>();\n        List<Integer> list3 = new ArrayList<Integer>();\n\n        int sum = 0;\n        long totalCost = 0;\n        for (int i = 0; i < n; i++) {\n            int w = scanner.nextInt();\n            int c = scanner.nextInt();\n            if (w == 1) {\n                list1.add(c);\n            }\n            else if (w == 2) {\n                list2.add(c);\n            }\n            else {\n                list3.add(c);\n            }\n            sum += w;\n            totalCost += c;\n        }\n\n        if (sum <= m) {\n            System.out.println(totalCost);\n            return ;\n        }\n\n        Collections.sort(list1, Collections.reverseOrder());\n        Collections.sort(list2, Collections.reverseOrder());\n        Collections.sort(list3, Collections.reverseOrder());\n\n        Pair[] pairs = new Pair[m + 1];\n        pairs[0] = new Pair(0, 0, 0);\n        pairs[1] = list1.size() > 0 ? new Pair(1, 0, list1.get(0)) : new Pair(0 ,0 ,0);\n        long cost = pairs[1].cost;\n        for (int i = 2; i <= m; i++) {\n            long sum1 = 0;\n            if (pairs[i - 1].index1 < list1.size()) {\n                sum1 = pairs[i - 1].cost + list1.get(pairs[i - 1].index1);\n            }\n            long sum2 = 0;\n            if (pairs[i - 2].index2 < list2.size()) {\n                sum2 = pairs[i - 2].cost + list2.get(pairs[i - 2].index2);\n            }\n            if (sum1 == 0 && sum2 == 0) {\n                pairs[i] = new Pair(0, 0, 0);\n            }\n            else if (sum1 > sum2) {\n                pairs[i] = new Pair(pairs[i - 1].index1 + 1, pairs[i - 1].index2, sum1);\n            }\n            else {\n                pairs[i] = new Pair(pairs[i - 2].index1, pairs[i - 2].index2 + 1, sum2);\n            }\n            cost = Math.max(cost, pairs[i].cost);\n        }\n        long[] sums = new long[list3.size()];\n        for (int i = 0; i < list3.size(); i++) {\n            sums[i] = list3.get(i);\n        }\n        for (int i = 1; i < list3.size(); i++) {\n            sums[i] = sums[i] + sums[i - 1];\n        }\n        for (int i = m - 3; i >= 0; i--) {\n            int diff = m - i;\n            int numOfthree = diff / 3;\n            if (numOfthree > list3.size()) {\n                break;\n            }\n            cost = Math.max(cost, pairs[i].cost + sums[numOfthree - 1]);\n        }\n        System.out.println(cost);\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nnamespace OI {\ntemplate <class T>\nvoid rd(T &x) {\n  x = 0;\n  int f = 1;\n  char c;\n  while (!isdigit(c = getchar()))\n    if (c == '-') f = -1;\n  do {\n    x = (x << 3) + (x << 1) + (c ^ 48);\n  } while (isdigit(c = getchar()));\n  x *= f;\n}\ntemplate <class T>\nvoid pt(T x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x > 9) pt(x / 10);\n  putchar(x % 10 ^ 48);\n}\n}  // namespace OI\nusing namespace OI;\nusing namespace std;\nconst int N = 3e5 + 5;\nstruct node {\n  int p1, p2;\n  long long v;\n} dp[N];\nint n, m;\nvector<int> Vec[4];\nlong long ans, tmp;\nint main() {\n  rd(n), rd(m);\n  for (int i = 1, x, y; i <= n; i++) rd(x), rd(y), Vec[x].push_back(y);\n  for (int i = 1; i <= 3; i++)\n    sort(Vec[i].begin(), Vec[i].end()), reverse(Vec[i].begin(), Vec[i].end());\n  for (int i = 1; i <= m; i++) {\n    dp[i] = dp[i - 1];\n    if (dp[i - 1].p1 < Vec[1].size() &&\n        dp[i - 1].v + Vec[1][dp[i - 1].p1] > dp[i].v) {\n      dp[i].v = dp[i - 1].v + Vec[1][dp[i - 1].p1];\n      dp[i].p1 = dp[i - 1].p1 + 1;\n      dp[i].p2 = dp[i - 1].p2;\n    }\n    if (i > 1 && dp[i - 2].p2 < Vec[2].size() &&\n        dp[i - 2].v + Vec[2][dp[i - 2].p2] > dp[i].v) {\n      dp[i].v = dp[i - 2].v + Vec[2][dp[i - 2].p2];\n      dp[i].p2 = dp[i - 2].p2 + 1;\n      dp[i].p1 = dp[i - 2].p1;\n    }\n  }\n  for (int i = 0; i <= (int)Vec[3].size() && i * 3 <= m; i++) {\n    ans = max(ans, tmp + dp[m - i * 3].v);\n    if (i < Vec[3].size()) tmp += Vec[3][i];\n  }\n  pt(ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long calc(vector<vector<long long> > v, int m, long long res) {\n  for (int i = 1; i <= 3; ++i) {\n    sort(v[i].begin(), v[i].end());\n    reverse(v[i].begin(), v[i].end());\n    if (i == 1) {\n      for (int i = 0; i + 1 < v[1].size(); i += 2)\n        v[2].push_back(v[1][i] + v[1][i + 1]);\n      if (v[1].size() % 2) {\n        v[1][0] = v[1].back();\n        v[1].resize(1);\n      } else\n        v[1].clear();\n    }\n    for (int j = 1; j < v[i].size(); ++j) v[i][j] += v[i][j - 1];\n  }\n  long long baseRes = res;\n  for (int a = 0; a * 2 <= m && a <= v[2].size(); ++a) {\n    int cur = m - a * 2;\n    long long curRes = a ? v[2][a - 1] : 0;\n    curRes += baseRes;\n    if (cur) {\n      int at = min(cur / 3, int(v[3].size()));\n      cur -= at * 3;\n      if (at) curRes += v[3][at - 1];\n    }\n    if (cur && !v[1].empty()) curRes += v[1][0];\n    res = max(res, curRes);\n  }\n  return res;\n}\nint main() {\n  int n, m;\n  vector<vector<long long> > w;\n  scanf(\"%d%d\", &n, &m);\n  w.resize(4);\n  int x, y;\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d%d\", &x, &y);\n    w[x].push_back(y);\n  }\n  sort(w[1].begin(), w[1].end());\n  long long res = 0;\n  if (!w[1].empty()) {\n    long long tmp = w[1].back();\n    w[1].pop_back();\n    res = calc(w, m - 1, tmp);\n    res = max(res, calc(w, m, 0));\n    w[1].push_back(tmp);\n  }\n  res = max(res, calc(w, m, 0));\n  printf(\"%lld\\n\", res);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nclock_t start;\nmt19937_64 rng(chrono::system_clock::now().time_since_epoch().count());\ntemplate <typename T1, typename T2, typename T3>\nstruct query {\n  T1 ss;\n  T2 x;\n  T3 y;\n};\ntemplate <typename T1, typename T2, typename T3>\nbool operator<(query<T1, T2, T3>& o1, query<T1, T2, T3>& o2) {\n  return o1.x < o2.x;\n}\ntemplate <typename T1, typename T2, typename T3>\nistream& operator>>(istream& in, query<T1, T2, T3>& q) {\n  in >> q.ss >> q.x >> q.y;\n  return in;\n}\ntemplate <typename T1, typename T2, typename T3>\nostream& operator<<(ostream& out, query<T1, T2, T3>& q) {\n  out << q.ss << \" \" << q.x << \" \" << q.y;\n  return out;\n}\nvoid solve() {\n  long long n, m, ans = 0;\n  cin >> n >> m;\n  vector<long long> v[3];\n  for (long long i = 0; i < n; i++) {\n    long long w, c;\n    cin >> w >> c;\n    w--;\n    v[w].push_back(c);\n  }\n  v[0].resize(max(n, m + 1));\n  v[1].resize(max(n, m + 1));\n  v[2].resize(max(n, m + 1));\n  sort((v[0]).rbegin(), (v[0]).rend());\n  sort((v[1]).rbegin(), (v[1]).rend());\n  sort((v[2]).rbegin(), (v[2]).rend());\n  for (long long i = 1; i <= m; i++) {\n    v[2][i] += v[2][i - 1];\n  }\n  pair<pair<long long, long long>, pair<long long, long long> > dp[m + 1];\n  dp[0] = make_pair(make_pair(0, 0), make_pair(0, 0));\n  for (long long j = 1; j <= m; j++) {\n    long long x = v[0][dp[j - 1].first.second];\n    long long ff = dp[j - 1].first.first + x;\n    long long fs = dp[j - 1].first.second + 1;\n    long long sf = dp[j - 1].second.first;\n    if (j >= 2) {\n      x = v[1][dp[j - 2].second.first];\n      if (ff < dp[j - 2].first.first + x) {\n        ff = dp[j - 2].first.first + x;\n        fs = dp[j - 2].first.second;\n        sf = dp[j - 2].second.first + 1;\n      }\n    }\n    dp[j].first.first = ff;\n    dp[j].first.second = fs;\n    dp[j].second.first = sf;\n    if ((m - j) / 3 - 1 >= 0)\n      ans = max(ans, ff + v[2][(m - j) / 3 - 1]);\n    else\n      ans = max(ans, ff);\n  }\n  if (m / 3 > 0) ans = max(ans, v[2][m / 3 - 1]);\n  cout << ans << '\\n';\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long t = 1;\n  start = clock();\n  cout << fixed << setprecision(20);\n  while (t--) {\n    solve();\n  }\n  double time_taken = double(clock() - start) / double(CLOCKS_PER_SEC);\n}\n"
        },
        {
            "language": 3,
            "solution": "def souvenier_calc(max_weight, weights, value):\n    const = len(weights)\n    ans = [-1061109567 for x in range(max_weight+1)]\n    node = [(x, y) for x, y in zip(weights, value)]\n    node = sorted(node, key=lambda x: x[1]/x[0], reverse=True)\n    weights = [x[0] for x in node]\n    value = [x[1] for x in node]\n    sum = 0\n    sol = 0\n    ans[0] = 0\n    for i in range(const):\n        sum += weights[i]\n        if sum > max_weight:\n            sum = max_weight\n        down = max(weights[i], sum-3)\n        for weight in range(sum, down-1, -1):\n            ans[weight] = max(ans[weight], ans[weight-weights[i]]+value[i])\n            sol = max(sol, ans[weight])\n\n    return sol\n\nif __name__ == '__main__':\n    N, M = map(int, input().split())\n    assert(N <= 10**5 and M <= 3*(10**5)), 'Out of range'\n    weights = []\n    value = []\n    for i in range(N):\n        x, y = map(int, input().split())\n        assert(x >= 1 and x <= 3), 'Out of range'\n        assert(y >= 1 and y <= 10**9), 'Out of range'\n        weights.append(x)\n        value.append(y)\n    print(souvenier_calc(M, weights, value))\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Stream;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.Collections;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt(), m = in.nextInt();\n            List<Integer>[] x = LUtils.genArrayList(4);\n            for (int i = 0; i < n; i++) {\n                int w = in.nextInt(), c = in.nextInt();\n                x[w].add(c);\n            }\n            for (int i = 1; i <= 3; i++) {\n                Collections.sort(x[i], Collections.reverseOrder());\n            }\n            long[] res = new long[m + 1];\n            res[0] = 0;\n            int pt1 = 0, pt2 = 0;\n            for (int w = 2; w <= m; w += 2) {\n                long x1 = (pt1 < x[1].size() ? x[1].get(pt1) : 0) + (pt1 + 1 < x[1].size() ? x[1].get(pt1 + 1) : 0);\n                long x2 = (pt2 < x[2].size() ? x[2].get(pt2) : 0);\n                res[w] = res[w - 2] + Math.max(x1, x2);\n                if (x1 > x2) pt1 += 2;\n                else pt2++;\n            }\n            pt1 = 1;\n            pt2 = 0;\n            if (x[1].size() > 0) {\n                res[1] = x[1].get(0);\n            }\n            for (int w = 3; w <= m; w += 2) {\n                long x1 = (pt1 < x[1].size() ? x[1].get(pt1) : 0) + (pt1 + 1 < x[1].size() ? x[1].get(pt1 + 1) : 0);\n                long x2 = (pt2 < x[2].size() ? x[2].get(pt2) : 0);\n                res[w] = res[w - 2] + Math.max(x1, x2);\n                if (x1 > x2) pt1 += 2;\n                else pt2++;\n            }\n\n            int pt3 = 0;\n            long mx = res[m];\n            long x3s = 0;\n            for (int take = 3; take <= m; take += 3) {\n                long x3 = (pt3 < x[3].size() ? x[3].get(pt3) : 0);\n                x3s += x3;\n                if (x3s + res[m - take] >= mx) {\n                    mx = x3s + res[m - take];\n                }\n                pt3++;\n            }\n            out.println(mx);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (this.numChars == -1) {\n                throw new InputMismatchException();\n            } else {\n                if (this.curChar >= this.numChars) {\n                    this.curChar = 0;\n\n                    try {\n                        this.numChars = this.stream.read(this.buf);\n                    } catch (IOException var2) {\n                        throw new InputMismatchException();\n                    }\n\n                    if (this.numChars <= 0) {\n                        return -1;\n                    }\n                }\n\n                return this.buf[this.curChar++];\n            }\n        }\n\n        public int nextInt() {\n            int c;\n            for (c = this.read(); isSpaceChar(c); c = this.read()) {\n                ;\n            }\n\n            byte sgn = 1;\n            if (c == 45) {\n                sgn = -1;\n                c = this.read();\n            }\n\n            int res = 0;\n\n            while (c >= 48 && c <= 57) {\n                res *= 10;\n                res += c - 48;\n                c = this.read();\n                if (isSpaceChar(c)) {\n                    return res * sgn;\n                }\n            }\n\n            throw new InputMismatchException();\n        }\n\n        public static boolean isSpaceChar(int c) {\n            return c == 32 || c == 10 || c == 13 || c == 9 || c == -1;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class LUtils {\n        public static <E> List<E>[] genArrayList(int size) {\n            return Stream.generate(ArrayList::new).limit(size).toArray(List[]::new);\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 5;\nvector<long long> a[4];\nstruct node {\n  int i, j;\n  long long c;\n  node() : c(0){};\n  node(int i, int j, long long c) : i(i), j(j), c(c){};\n  bool operator<(const node& x) const { return c < x.c; }\n} dp[3 * maxn];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    int w, c;\n    cin >> w >> c;\n    a[w].push_back(c);\n  }\n  int s[4];\n  for (int i = 1; i <= 3; i++) {\n    sort(a[i].begin(), a[i].end(), greater<long long>());\n    s[i] = a[i].size();\n  }\n  for (int i = 1; i < s[3]; i++) a[3][i] += a[3][i - 1];\n  long long ans = 0;\n  dp[0] = node(0, 0, 0);\n  for (int w = 0; w <= m; w++) {\n    if (w) dp[w] = max(dp[w], dp[w - 1]);\n    if (w + 1 <= m && dp[w].i < s[1])\n      dp[w + 1] =\n          max(dp[w + 1], node(dp[w].i + 1, dp[w].j, dp[w].c + a[1][dp[w].i]));\n    if (w + 2 <= m && dp[w].j < s[2])\n      dp[w + 2] =\n          max(dp[w + 2], node(dp[w].i, dp[w].j + 1, dp[w].c + a[2][dp[w].j]));\n    int k = min(s[3], (m - w) / 3);\n    long long cur = dp[w].c + (k ? a[3][k - 1] : 0);\n    ans = max(ans, cur);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "//created by Whiplash99\nimport java.io.*;\nimport java.util.*;\npublic class E\n{\n    static class Tuple\n    {\n        long val;\n        int f, s, t;\n    }\n    public static void main(String[] args) throws IOException\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\n        int i,N;\n\n        ArrayList<Long> cost[]=new ArrayList[3];\n        for(i=0;i<3;i++) cost[i]=new ArrayList<>();\n\n        String s[]=br.readLine().trim().split(\" \");\n        N=Integer.parseInt(s[0]);\n        int W=Integer.parseInt(s[1]);\n\n        Tuple T[]=new Tuple[W+5];\n        for(i=0;i<W+5;i++) T[i]=new Tuple();\n\n        for(i=0;i<N;i++)\n        {\n            s=br.readLine().trim().split(\" \");\n            int w=Integer.parseInt(s[0]);\n            long c=Long.parseLong(s[1]);\n\n            cost[w-1].add(c);\n        }\n        for(i=0;i<3;i++) Collections.sort(cost[i],Collections.reverseOrder());\n\n        long ans=0;\n        for(i=0;i<=W;i++)\n        {\n            if(T[i].f<cost[0].size()&&T[i+1].val<T[i].val+cost[0].get(T[i].f))\n            {\n                T[i+1].val=T[i].val+cost[0].get(T[i].f);\n                T[i+1].f=T[i].f+1;\n                T[i+1].s=T[i].s;\n                T[i+1].t=T[i].t;\n            }\n            if(T[i].s<cost[1].size()&&T[i+2].val<T[i].val+cost[1].get(T[i].s))\n            {\n                T[i+2].val=T[i].val+cost[1].get(T[i].s);\n                T[i+2].f=T[i].f;\n                T[i+2].s=T[i].s+1;\n                T[i+2].t=T[i].t;\n            }\n            if(T[i].t<cost[2].size()&&T[i+3].val<T[i].val+cost[2].get(T[i].t))\n            {\n                T[i+3].val=T[i].val+cost[2].get(T[i].t);\n                T[i+3].f=T[i].f;\n                T[i+3].s=T[i].s;\n                T[i+3].t=T[i].t+1;\n            }\n            if(i>0&&T[i].f>0&&T[i].t<cost[2].size())\n            {\n                if(T[i+2].val<T[i].val+cost[2].get(T[i].t)-cost[0].get(T[i].f-1))\n                {\n                    T[i+2].val=T[i].val+cost[2].get(T[i].t)-cost[0].get(T[i].f-1);\n                    T[i+2].f=T[i].f-1;\n                    T[i+2].s=T[i].s;\n                    T[i+2].t=T[i].t+1;\n                }\n            }\n            ans=Math.max(ans,T[i].val);\n        }\n\n        System.out.println(ans);\n    }\n}"
        },
        {
            "language": 3,
            "solution": "import sys\nfrom itertools import accumulate\n\ndef solve():\n    n, m = map(int, input().split())\n    w = [[] for i in range(3)]\n\n    for i in range(n):\n        wi, ci = map(int, sys.stdin.readline().split())\n        wi -= 1\n        w[wi].append(ci)\n\n    for i in range(3):\n        w[i].sort(reverse=True)\n\n    dp = [0]*(m + 1)\n    used = [[0]*2 for i in range(m + 1)]\n\n    s0 = len(w[0])\n    s1 = len(w[1])\n\n    if s0 > 0:\n        dp[1] = w[0][0]\n        used[1] = [1, 0]\n\n    for i in range(2, m + 1):\n        if used[i - 1][0] < s0:\n            dp[i] = dp[i - 1] + w[0][used[i - 1][0]]\n            used[i] = used[i - 1][:]\n            used[i][0] += 1\n        else:\n            dp[i] = dp[i - 1]\n            used[i] = used[i - 1][:]\n\n        if used[i - 2][1] < s1 and dp[i] < dp[i - 2] + w[1][used[i - 2][1]]:\n            dp[i] = dp[i - 2] + w[1][used[i - 2][1]]\n            used[i] = used[i - 2][:]\n            used[i][1] += 1\n\n    pf = [0] + list(accumulate(w[2]))\n\n    ans = max(pf[k] + dp[m - 3*k] for k in range(min(len(pf),m // 3 + 1)))\n\n    print(ans)\n\nif __name__ == '__main__':\n    solve()"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 3e5 + 10;\nint a[MAXN], b[MAXN], c[MAXN], an = 0, bn = 0, cn = 0;\nlong long sa[MAXN], sb[MAXN], sc[MAXN], dp[MAXN];\nbool cmp(int a, int b) { return a > b; }\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; i++) {\n    int w, x;\n    scanf(\"%d%d\", &w, &x);\n    if (w == 1)\n      a[++an] = x;\n    else if (w == 2)\n      b[++bn] = x;\n    else\n      c[++cn] = x;\n  }\n  sort(a + 1, a + 1 + an, cmp);\n  for (int i = 1; i <= m; i++) sa[i] = a[i] + sa[i - 1];\n  sort(b + 1, b + 1 + bn, cmp);\n  for (int i = 1; 2 * i <= m; i++) sb[i] = b[i] + sb[i - 1];\n  sort(c + 1, c + 1 + cn, cmp);\n  for (int i = 1; 3 * i <= m; i++) sc[i] = c[i] + sc[i - 1];\n  dp[1] = a[1];\n  for (int k = 2; k <= m; k++) {\n    if (b[1] <= a[k] + a[k - 1]) {\n      dp[k] = sa[k];\n      continue;\n    }\n    int l = 1, r = k / 2 + 1;\n    while (l < r) {\n      int mid = (l + r) >> 1;\n      if (b[mid] > a[k - 2 * mid + 1] + a[k - 2 * mid + 2])\n        l = mid + 1;\n      else\n        r = mid;\n    }\n    if (l == k / 2 + 1)\n      dp[k] = sb[k / 2] + sa[k - (k / 2) * 2];\n    else\n      dp[k] = max(sb[l] + sa[k - 2 * l], sb[l - 1] + sa[k - 2 * (l - 1)]);\n  }\n  long long ans = 0;\n  for (int i = 0; i <= cn && 3 * i <= m; i++)\n    ans = max(ans, dp[m - 3 * i] + sc[i]);\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int dp[1000005];\nlong long int p1[1000005];\nlong long int p2[1000005];\nvector<long long int> v[5];\nint main() {\n  long long int n, m;\n  scanf(\"%lld%lld\", &n, &m);\n  for (long long int i = 1; i <= n; i++) {\n    long long int w, c;\n    scanf(\"%lld%lld\", &w, &c);\n    v[w].push_back(c);\n  }\n  v[1].resize(m + 2);\n  v[2].resize(m + 2);\n  v[3].resize(m + 2);\n  sort(v[1].begin(), v[1].end(), greater<long long int>());\n  sort(v[2].begin(), v[2].end(), greater<long long int>());\n  sort(v[3].begin(), v[3].end(), greater<long long int>());\n  dp[1] = v[1][0];\n  p1[1] = 1;\n  p2[1] = 0;\n  long long int ans = dp[1];\n  for (long long int i = 2; i <= m; i++) {\n    dp[i] = dp[i - 2] + v[1][p1[i - 2]] + v[1][p1[i - 2] + 1];\n    p1[i] = p1[i - 2] + 2;\n    p2[i] = p2[i - 2];\n    if (dp[i] < dp[i - 2] + v[2][p2[i - 2]]) {\n      dp[i] = dp[i - 2] + v[2][p2[i - 2]];\n      p2[i] = p2[i - 2] + 1;\n      p1[i] = p1[i - 2];\n    }\n    ans = max(ans, dp[i]);\n  }\n  long long int ptr = 0;\n  long long int sum = 0;\n  for (long long int i = 3; i <= m; i += 3) {\n    ans = max(ans, dp[m - i] + sum + v[3][ptr]);\n    sum += v[3][ptr];\n    ptr++;\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 3,
            "solution": "n, m = list(map(int, input().split()))\na = [[], [], []]\nfor i in range(n):\n    w, c = list(map(int, input().split()))\n    a[w-1].append(c)\np = [[0], [0], [0]]\nfor i in range(3):\n    a[i].sort(reverse=True)\n    for x in a[i]:\n        p[i].append(p[i][-1] + x)\nans = 0\nfor i in range(min(m//3, len(a[2])) + 1):\n    w = m - i * 3\n    if len(a[1]) * 2 + len(a[0]) <= w:\n        ans = max(ans, p[2][i] + p[1][len(a[1])] + p[0][len(a[0])])\n        continue\n    if not len(a[0]):\n        ans = max(ans, p[2][i] + p[1][min(w//2, len(a[1]))])\n        continue\n    \n    if 2 + 2 == 4:\n        x = min(len(a[0]), w)\n        y = (w - x) // 2\n        ans = max(ans, p[2][i] + p[1][y] + p[0][x])\n\n    lo = max((w - len(a[0]) + 1) // 2 + 1, 1)\n    hi = min(len(a[1]), w // 2)\n    while lo <= hi:\n        mi = (lo + hi) // 2\n        if a[1][mi - 1] - (p[0][w-mi*2+2] - p[0][w-mi*2]) > 0:\n            lo = mi + 1\n        else:\n            hi = mi - 1\n    ans = max(ans, p[2][i] + p[1][hi] + p[0][w-hi*2])\nprint(ans)\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 300003;\nint n, m;\nlong long bestOne[N];\nlong long bestTwo[N];\nlong long bestThree[N];\npair<long long, pair<int, int> > bestOneTwo[N];\nint main() {\n  int x, y;\n  scanf(\"%d%d\", &n, &m);\n  vector<pair<int, int> > vec;\n  vector<int> currOne, currTwo, currThree, leftOne, leftTwo, leftThree;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d%d\", &x, &y);\n    if (x == 1) {\n      currOne.push_back(y);\n    } else if (x == 2) {\n      currTwo.push_back(y);\n    } else if (x == 3) {\n      currThree.push_back(y);\n    }\n  }\n  sort(currOne.rbegin(), currOne.rend());\n  for (int i = 1; i <= currOne.size(); i++)\n    bestOne[i] = bestOne[i - 1] + currOne[i - 1];\n  sort(currTwo.rbegin(), currTwo.rend());\n  for (int i = 1; i <= currTwo.size(); i++)\n    bestTwo[i] = bestTwo[i - 1] + currTwo[i - 1];\n  sort(currThree.rbegin(), currThree.rend());\n  for (int i = 1; i <= currThree.size(); i++)\n    bestThree[i] = bestThree[i - 1] + currThree[i - 1];\n  for (int i = currOne.size() + 1; i < N; i++) bestOne[i] = bestOne[i - 1];\n  for (int i = currTwo.size() + 1; i < N; i++) bestTwo[i] = bestTwo[i - 1];\n  for (int i = currThree.size() + 1; i < N; i++)\n    bestThree[i] = bestThree[i - 1];\n  bestOneTwo[0] = make_pair(0, make_pair(0, 0));\n  bestOneTwo[1] = make_pair(bestOne[1], make_pair(1, 0));\n  for (int i = 2; i <= m; i++) {\n    pair<long long, pair<int, int> > last = bestOneTwo[i - 1];\n    pair<long long, pair<int, int> > bl = bestOneTwo[i - 2];\n    bestOneTwo[i] =\n        make_pair(bestOne[last.second.first + 1] + bestTwo[last.second.second],\n                  make_pair(last.second.first + 1, last.second.second));\n    if (bestOne[bl.second.first + 2] + bestTwo[bl.second.second] >\n        bestOneTwo[i].first) {\n      bestOneTwo[i] =\n          make_pair(bestOne[bl.second.first + 2] + bestTwo[bl.second.second],\n                    make_pair(bl.second.first + 2, bl.second.second));\n    }\n    if (bestOne[bl.second.first] + bestTwo[bl.second.second + 1] >\n        bestOneTwo[i].first) {\n      bestOneTwo[i] =\n          make_pair(bestOne[bl.second.first] + bestTwo[bl.second.second + 1],\n                    make_pair(bl.second.first, bl.second.second + 1));\n    }\n  }\n  long long ans = 0;\n  for (int i = 0; i * 3 <= m; i++) {\n    int left = m - i * 3;\n    long long curr = bestThree[i];\n    ans = max(ans, curr + bestOneTwo[left].first);\n  }\n  printf(\"%I64d\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct NODE {\n  long long val, x, y;\n} dp[100010 * 3];\nint cnt[4];\nlong long pre_sum[4][100010], a[4][100010], ans;\ninline int read() {\n  int f = 1, x = 0;\n  char ch = getchar();\n  while (!isdigit(ch)) {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (isdigit(ch)) {\n    x = (x << 3) + (x << 1) + ch - '0';\n    ch = getchar();\n  }\n  return f * x;\n}\ninline bool cmp(int x, int y) { return x > y; }\nint main() {\n  int n = read(), load = read();\n  for (int i = 1; i <= n; i++) {\n    int w = read(), v = read();\n    a[w][++cnt[w]] = v;\n  }\n  for (int i = 1; i <= 3; i++) {\n    sort(a[i] + 1, a[i] + cnt[i] + 1, cmp);\n    for (int j = 1; j <= cnt[i]; j++)\n      pre_sum[i][j] = pre_sum[i][j - 1] + a[i][j];\n  }\n  dp[0].val = dp[0].x = dp[0].y = 0;\n  for (int i = 1; i <= load; i++) {\n    dp[i] = dp[i - 1];\n    if (dp[i - 1].val + a[1][dp[i - 1].x + 1] > dp[i].val)\n      dp[i].val = dp[i - 1].val + a[1][dp[i - 1].x + 1],\n      dp[i].x = dp[i - 1].x + 1, dp[i].y = dp[i - 1].y;\n    if (i >= 2 && dp[i - 2].val + a[2][dp[i - 2].y + 1] > dp[i].val)\n      dp[i].val = dp[i - 2].val + a[2][dp[i - 2].y + 1], dp[i].x = dp[i - 2].x,\n      dp[i].y = dp[i - 2].y + 1;\n  }\n  ans = 0;\n  for (int i = 0; i <= cnt[3]; i++)\n    if (load >= i * 3) ans = max(ans, dp[load - i * 3].val + pre_sum[3][i]);\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nT sqr(T x) {\n  return x * x;\n}\ntemplate <class T>\nT gcd(T a, T b) {\n  return (b != 0 ? gcd<T>(b, a % b) : a);\n}\ntemplate <class T>\nT lcm(T a, T b) {\n  return (a / gcd<T>(a, b) * b);\n}\ntemplate <class T>\ninline T bigmod(T p, T e, T M) {\n  if (e == 0) return 1;\n  if (e % 2 == 0) {\n    long long int t = bigmod(p, e / 2, M);\n    return (T)((t * t) % M);\n  }\n  return (T)((long long int)bigmod(p, e - 1, M) * (long long int)p) % M;\n}\ntemplate <class T>\ninline T bigexp(T p, T e) {\n  if (e == 0) return 1;\n  if (e % 2 == 0) {\n    long long int t = bigexp(p, e / 2);\n    return (T)((t * t));\n  }\n  return (T)((long long int)bigexp(p, e - 1) * (long long int)p);\n}\ntemplate <class T>\ninline T modinverse(T a, T M) {\n  return bigmod(a, M - 2, M);\n}\nint dx4[] = {1, 0, -1, 0};\nint dy4[] = {0, 1, 0, -1};\nint dx8[] = {1, 1, 0, -1, -1, -1, 0, 1};\nint dy8[] = {0, 1, 1, 1, 0, -1, -1, -1};\nint nx8[] = {1, 1, -1, -1, 2, 2, -2, -2};\nint ny8[] = {2, -2, 2, -2, 1, -1, 1, -1};\nint month[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\nstruct T {\n  int w;\n  long long int cost;\n  bool operator<(const T& p) const {\n    if (cost == p.cost) return w > p.w;\n    return cost > p.cost;\n  }\n} a[100005], b[100005], c[100005];\nint n, m, x, c1, c2, c3;\nlong long int xx, a1[100005][2], b1[100005][2], cc1[100005][2];\nlong long int ternary3(int rem) {\n  long long int ret = 0, tmp1, tmp2;\n  int mid1, mid2;\n  int lo = 1, hi = c1;\n  while (hi - lo >= 5) {\n    mid1 = (2 * lo + hi) / 3;\n    mid2 = (lo + 2 * hi) / 3;\n    tmp1 = 0;\n    tmp2 = 0;\n    if (a1[mid1][0] <= rem) {\n      tmp1 = a1[mid1][1];\n    }\n    if (a1[mid2][0] <= rem) {\n      tmp2 = a1[mid2][1];\n    }\n    if (tmp1 >= tmp2) {\n      hi = mid2;\n      ret = max(tmp1, ret);\n    } else {\n      ret = max(tmp2, ret);\n      lo = mid1;\n    }\n  }\n  for (int i = lo; i <= hi; i++) {\n    if (a1[i][0] <= rem) {\n      tmp1 = a1[i][1];\n      ret = max(ret, tmp1);\n    }\n  }\n  return ret;\n}\nlong long int ternary2(int rem) {\n  long long int ret = 0, tmp1, tmp2;\n  int mid1, mid2;\n  int lo = 1, hi = c2;\n  while (hi - lo >= 5) {\n    mid1 = (2 * lo + hi) / 3;\n    mid2 = (lo + 2 * hi) / 3;\n    tmp1 = 0;\n    tmp2 = 0;\n    if (b1[mid1][0] <= rem) {\n      tmp1 = b1[mid1][1] + ternary3(rem - b1[mid1][0]);\n    }\n    if (b1[mid2][0] <= rem) {\n      tmp2 = b1[mid2][1] + ternary3(rem - b1[mid2][0]);\n    }\n    if (tmp1 >= tmp2) {\n      hi = mid2;\n      ret = max(tmp1, ret);\n    } else {\n      ret = max(tmp2, ret);\n      lo = mid1;\n    }\n  }\n  for (int i = lo; i <= hi; i++) {\n    if (b1[i][0] <= rem) {\n      tmp1 = b1[i][1] + ternary3(rem - b1[i][0]);\n      ret = max(ret, tmp1);\n    }\n  }\n  ret = max(ret, ternary3(rem));\n  return ret;\n}\nlong long int ternary1(int rem) {\n  long long int ret = 0, tmp1, tmp2;\n  int cnt = 300, mid1, mid2;\n  int lo = 1, hi = c3;\n  while (hi - lo >= 5) {\n    mid1 = (2 * lo + hi) / 3;\n    mid2 = (lo + 2 * hi) / 3;\n    tmp1 = 0;\n    tmp2 = 0;\n    if (cc1[mid1][0] <= rem) {\n      tmp1 = cc1[mid1][1] + ternary2(rem - cc1[mid1][0]);\n    }\n    if (cc1[mid2][0] <= rem) {\n      tmp2 = cc1[mid2][1] + ternary2(rem - cc1[mid2][0]);\n    }\n    if (tmp1 >= tmp2) {\n      hi = mid2;\n      ret = max(tmp1, ret);\n    } else {\n      ret = max(tmp2, ret);\n      lo = mid1;\n    }\n  }\n  for (int i = lo; i <= hi; i++) {\n    if (cc1[i][0] <= rem) {\n      tmp1 = cc1[i][1] + ternary2(rem - cc1[i][0]);\n      ret = max(tmp1, ret);\n    }\n  }\n  ret = max(ret, ternary2(rem));\n  return ret;\n}\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  for (__typeof(n) i = (1); i <= (n); i++) {\n    scanf(\"%d %lld\", &x, &xx);\n    if (x == 1) {\n      a[++c1].w = 1;\n      a[c1].cost = xx;\n    } else if (x == 2) {\n      b[++c2].w = 2;\n      b[c2].cost = xx;\n    } else {\n      c[++c3].w = 3;\n      c[c3].cost = xx;\n    }\n  }\n  sort(a + 1, a + c1 + 1);\n  sort(b + 1, b + c2 + 1);\n  sort(c + 1, c + c3 + 1);\n  for (__typeof(c1) i = (1); i <= (c1); i++) {\n    a1[i][0] = a1[i - 1][0] + 1;\n    a1[i][1] = a1[i - 1][1] + a[i].cost;\n  }\n  for (__typeof(c2) i = (1); i <= (c2); i++) {\n    b1[i][0] = b1[i - 1][0] + 2;\n    b1[i][1] = b1[i - 1][1] + b[i].cost;\n  }\n  for (__typeof(c3) i = (1); i <= (c3); i++) {\n    cc1[i][0] = cc1[i - 1][0] + 3;\n    cc1[i][1] = cc1[i - 1][1] + c[i].cost;\n  }\n  long long int res = ternary1(m);\n  cout << res;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.util.Comparator;\nimport java.util.Collections;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        SellingSouvenirs solver = new SellingSouvenirs();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class SellingSouvenirs {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int N = in.nextInt();\n            int M = in.nextInt();\n            ArrayList<Part> d = new ArrayList<>();\n            for (int i = 0; i < N; i++) {\n                d.add(new Part(in.nextInt(), in.nextInt()));\n            }\n            Collections.sort(d, new Comparator<Part>() {\n\n                public int compare(Part part, Part t1) {\n                    int a = dComp(1.0 * part.c / part.w, 1.0 * t1.c / t1.w);\n                    if (a == 0) {\n                        return Integer.compare(t1.w, part.w);\n                    } else {\n                        return a;\n                    }\n                }\n            });\n            ArrayList<Integer>[] store = new ArrayList[3];\n            for (int i = 0; i < 3; i++) store[i] = new ArrayList<>();\n            long res = 0;\n            for (int i = N - 1; i >= 0 && M > 0; i--) {\n                if (M < d.get(i).w) {\n                    long resOr = res;\n                    res = Math.max(res, resOr + findNext(1, i, d));\n                    if (M == 2) {\n                        res = Math.max(res, resOr + findNext(2, i, d));\n                    }\n                    if (store[0].size() > 0) {\n                        res = Math.max(resOr - store[0].get(store[0].size() - 1) + findNext(2, i, d), res);\n                        if (M == 2) {\n                            res = Math.max(resOr - store[0].get(store[0].size() - 1) + findNext(3, i, d), res);\n                        }\n                    }\n                    if (store[0].size() > 1) {\n                        res = Math.max(resOr - store[0].get(store[0].size() - 1) - store[0].get(store[0].size() - 2) + findNext(3, i, d), res);\n                    }\n                    if (store[1].size() > 0) {\n                        res = Math.max(res, resOr - store[1].get(store[1].size() - 1) + findNext(3, i, d));\n                        if (M == 2) {\n                            res = Math.max(res, resOr - store[1].get(store[1].size() - 1) + findNext(1, i, d) + findNext(3, i, d));\n                        }\n                    }\n                    if (store[2].size() > 0) {\n                        res = Math.max(res, resOr - store[2].get(store[2].size() - 1) + findNext(2, i, d, 2));\n                    }\n                    break;\n                } else {\n                    M -= d.get(i).w;\n                    res += d.get(i).c;\n                    store[d.get(i).w - 1].add(d.get(i).c);\n                }\n            }\n            out.println(res);\n        }\n\n        long findNext(int a, int i, ArrayList<Part> arr) {\n            for (int j = i; j >= 0; j--) {\n                if (arr.get(j).w == a) {\n                    return arr.get(j).c;\n                }\n            }\n            return 0;\n        }\n\n        long findNext(int a, int i, ArrayList<Part> arr, int c) {\n            long res = 0;\n            for (int j = i; j >= 0 && c > 0; j--) {\n                if (arr.get(j).w == a) {\n                    res += arr.get(j).c;\n                    c--;\n                }\n            }\n            return res;\n        }\n\n        int dComp(double a, double b) {\n            if (Math.abs(a - b) <= 0.0001) {\n                return 0;\n            } else if (a > b) {\n                return 1;\n            } else {\n                return -1;\n            }\n        }\n\n        class Part {\n            int w;\n            int c;\n\n            Part(int w, int c) {\n                this.w = w;\n                this.c = c;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class E {\n\tpublic static void main(String[] args)throws Throwable {\n\t\tMyScanner sc=new MyScanner();\n\t\tPrintWriter pw=new PrintWriter(System.out);\n\t\t\n\t\tint n=sc.nextInt();\n\t\tint m=sc.nextInt();\n\t\t\n\t\tArrayList<Integer> a1=new ArrayList<Integer>();\n\t\tArrayList<Integer> a2=new ArrayList<Integer>();\n\t\tArrayList<Integer> a3=new ArrayList<Integer>();\n\t\twhile(n-->0){\n\t\t\tswitch(sc.nextInt()){\n\t\t\tcase 1 : {\n\t\t\t\ta1.add(sc.nextInt());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 2 : {\n\t\t\t\ta2.add(sc.nextInt());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 3 : {\n\t\t\t\ta3.add(sc.nextInt());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\tCollections.sort(a1,Collections.reverseOrder());\n\t\tCollections.sort(a2,Collections.reverseOrder());\n\t\tCollections.sort(a3,Collections.reverseOrder());\n\t\t\n\t\tint max=(int)(3e5+1);\n\t\tpair [] dp=new pair [max];\n\t\tdp[0]=new pair(0, 0, 0);\n\t\tfor(int i=1;i<max;i++){\n\t\t\tdp[i]=new pair(0,0,0);\n\t\t\tpair p1=dp[i-1];\n\t\t\tdp[i]=dp[i-1];\n\t\t\tif(p1.x<a1.size())\n\t\t\t\tdp[i]=new pair(p1.x+1, p1.y, p1.c+a1.get(p1.x));\n\t\t\tif(i>1){\n\t\t\t\tpair p2=dp[i-2];\n\t\t\t\tif(p2.y<a2.size() && p2.c+a2.get(p2.y)>=dp[i].c)\n\t\t\t\t\tdp[i]=new pair(p2.x, p2.y+1, p2.c+a2.get(p2.y));\n\t\t\t}\n\t\t}\n\t\tlong ans=dp[(int)m].c;\n\t\tlong sum=0;\n\t\tfor(int i=0;i<a3.size();i++){\n\t\t\tsum+=a3.get(i);\n\t\t\tif(m-(i+1)*3>=0)\n\t\t\t\tans=Math.max(ans, sum+dp[m-(i+1)*3].c);\n\t\t}\n\t\tpw.println(ans);\n\t\tpw.flush();\n\t\tpw.close();\n\t}\n\t\n\tstatic class pair{\n\t\tint x,y;\n\t\tlong c;\n\t\tpair(int a,int b,long c){\n\t\t\tx=a;\n\t\t\ty=b;\n\t\t\tthis.c=c;\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn x+\" \"+y+\" \"+c;\n\t\t}\n\t}\n\t\n\tstatic class MyScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tpublic MyScanner() {br = new BufferedReader(new InputStreamReader(System.in));}\n\t\tString next() {while (st == null || !st.hasMoreElements()) {\n\t\t\ttry {st = new StringTokenizer(br.readLine());}\n\t\t\tcatch (IOException e) {e.printStackTrace();}}\n\t\treturn st.nextToken();}\n\t\tint nextInt() {return Integer.parseInt(next());}\n\t\tlong nextLong() {return Long.parseLong(next());}\n\t\tdouble nextDouble() {return Double.parseDouble(next());}\n\t\tString nextLine(){String str = \"\";\n\t\ttry {str = br.readLine();}\n\t\tcatch (IOException e) {e.printStackTrace();}\n\t\treturn str;}\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws FileNotFoundException {\n        InputStream inputStream = System.in;\n//        InputStream inputStream = new FileInputStream(new File(\"input\"));\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task solver = new Task();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class Task {\n        List<Long> accumulateSum(List<Integer> arr) {\n            long cur = 0;\n            List<Long> res = new ArrayList<>();\n\n            res.add(0L);\n            for (Integer anArr : arr) {\n                cur += anArr;\n                res.add(cur);\n            }\n\n            return res;\n        }\n\n        List<Integer> w3 = new ArrayList<>();\n        List<Integer> w2 = new ArrayList<>();\n        List<Integer> w1 = new ArrayList<>();\n        List<Long> s3 = new ArrayList<>();\n        List<Long> s2 = new ArrayList<>();\n        List<Long> s1 = new ArrayList<>();\n\n        long f(int t2, int t1) {\n            return s2.get(t2) + s1.get(t1);\n        }\n\n        long ternarySearch(int total, int left, int right) {\n//            System.out.println(total + \" \" + left + \" \" + right);\n            if (right - left <= 2) {\n                int t1Left = Math.min(total - 2 * left, w1.size());\n                int t1Right = Math.min(total - 2 * right, w1.size());\n                int t1Mid = Math.min(total - 2 * ((left + right)/2), w1.size());\n\n                return Math.max(f((left + right)/2, t1Mid),\n                        Math.max(f(left, t1Left), f(right, t1Right)));\n            }\n\n            int leftThird = (2 * left + right) / 3;\n            int rightThird = (left + 2 * right) / 3;\n\n            int t1LeftThird = Math.min(total - 2 * leftThird, w1.size());\n            int t1RightThird = Math.min(total - 2 * rightThird, w1.size());\n            if (f(leftThird, t1LeftThird) < f(rightThird, t1RightThird)) {\n                left = leftThird;\n            } else {\n                right = rightThird;\n            }\n\n            return ternarySearch(total, left, right);\n        }\n\n        public void solve(int ntest, InputReader inp, PrintWriter out) {\n            int n = inp.nextInt();\n            int m = inp.nextInt();\n\n            for (int i = 0; i < n; ++i) {\n                int w = inp.nextInt(), c = inp.nextInt();\n                switch (w) {\n                    case 1:\n                        w1.add(c);\n                        break;\n                    case 2:\n                        w2.add(c);\n                        break;\n                    case 3:\n                        w3.add(c);\n                        break;\n                }\n            }\n            w3.sort((o1, o2) -> -o1.compareTo(o2));\n            w2.sort((o1, o2) -> -o1.compareTo(o2));\n            w1.sort((o1, o2) -> -o1.compareTo(o2));\n\n            s3 = accumulateSum(w3);\n            s2 = accumulateSum(w2);\n            s1 = accumulateSum(w1);\n\n            long bestAllSum = 0;\n\n            for (int i = 0; i <= w3.size(); ++i) {\n                int l = m - 3 * i;\n                if (l < 0)\n                    break;\n\n                int maxT2 = Math.min(l/2, w2.size());\n                long maxSum = s3.get(i) + ternarySearch(l, 0, maxT2);\n                if (maxSum > bestAllSum) {\n                    bestAllSum = maxSum;\n                }\n                // 0 <= t2 <= maxT2,\n                // 2 * t2 + t3 <= l\n                // find best t2 that has greatest sum: s2(t2) + s3(t3);\n            }\n\n            out.println(bestAllSum);\n        }\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.FilterInputStream;\nimport java.io.BufferedInputStream;\nimport java.util.Collections;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        ScanReader in = new ScanReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        ESellingSouvenirs solver = new ESellingSouvenirs();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class ESellingSouvenirs {\n        public void solve(int testNumber, ScanReader in, PrintWriter out) {\n\n\n            int n = in.scanInt();\n            int m = in.scanInt();\n\n\n            long dp[][] = new long[m + 1][3];\n            int arr[][] = new int[n][];\n\n\n            ArrayList<Integer> one = new ArrayList<>();\n            ArrayList<Integer> two = new ArrayList<>();\n            ArrayList<Integer> three = new ArrayList<>();\n\n            for (int i = 0; i < n; i++) {\n                arr[i] = new int[]{in.scanInt(), in.scanInt()};\n                if (arr[i][0] == 1) {\n                    one.add(arr[i][1]);\n                } else if (arr[i][0] == 2) {\n                    two.add(arr[i][1]);\n                } else {\n                    three.add(arr[i][1]);\n                }\n            }\n\n\n            Collections.sort(one, Collections.reverseOrder());\n            Collections.sort(three, Collections.reverseOrder());\n            Collections.sort(two, Collections.reverseOrder());\n\n\n            dp[0] = new long[]{0, 0, 0};\n\n            for (int i = 1; i <= m; i++) {\n\n\n                dp[i][0] = dp[i - 1][0];\n                dp[i][1] = dp[i - 1][1];\n                dp[i][2] = dp[i - 1][2];\n\n                if (dp[i - 1][1] < one.size() && (dp[i - 1][0] + one.get((int) dp[i - 1][1])) >= dp[i][0]) {\n                    dp[i][0] = dp[i - 1][0] + one.get((int) dp[i - 1][1]);\n                    dp[i][1] = dp[i - 1][1] + 1;\n                    dp[i][2] = dp[i - 1][2];\n                }\n\n\n                if (i - 2 >= 0 && dp[i - 2][2] < two.size() && (dp[i - 2][0] + two.get((int) dp[i - 2][2])) >= dp[i][0]) {\n                    dp[i][0] = dp[i - 2][0] + two.get((int) dp[i - 2][2]);\n                    dp[i][2] = dp[i - 2][2] + 1;\n                    dp[i][1] = dp[i - 2][1];\n                }\n\n            }\n\n            long pre[] = new long[three.size() + 1];\n            for (int i = 1; i <= three.size(); i++) pre[i] = pre[i - 1] + three.get(i - 1);\n\n\n            long ans = 0;\n            for (int k = 0; k <= three.size(); k++) {\n                long tempans = pre[k];\n                int rem = m - (3 * k);\n                if (rem < 0) continue;\n                tempans += dp[rem][0];\n                ans = Math.max(ans, tempans);\n            }\n\n            out.println(ans);\n\n        }\n\n    }\n\n    static class ScanReader {\n        private byte[] buf = new byte[4 * 1024];\n        private int INDEX;\n        private BufferedInputStream in;\n        private int TOTAL;\n\n        public ScanReader(InputStream inputStream) {\n            in = new BufferedInputStream(inputStream);\n        }\n\n        private int scan() {\n            if (INDEX >= TOTAL) {\n                INDEX = 0;\n                try {\n                    TOTAL = in.read(buf);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                if (TOTAL <= 0) return -1;\n            }\n            return buf[INDEX++];\n        }\n\n        public int scanInt() {\n            int I = 0;\n            int n = scan();\n            while (isWhiteSpace(n)) n = scan();\n            int neg = 1;\n            if (n == '-') {\n                neg = -1;\n                n = scan();\n            }\n            while (!isWhiteSpace(n)) {\n                if (n >= '0' && n <= '9') {\n                    I *= 10;\n                    I += n - '0';\n                    n = scan();\n                }\n            }\n            return neg * I;\n        }\n\n        private boolean isWhiteSpace(int n) {\n            if (n == ' ' || n == '\\n' || n == '\\r' || n == '\\t' || n == -1) return true;\n            else return false;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long cost[4][300100];\nvector<long long> val[4];\nlong long cal(long long x) {\n  long long sz = val[2].size();\n  long long l = 1, r = min(x / 2, sz), best = 0;\n  while (l <= r) {\n    long long mid = (l + r) / 2;\n    if (cost[2][mid * 2] + cost[1][x - mid * 2] >=\n        cost[2][(mid - 1) * 2] + cost[1][x - (mid - 1) * 2]) {\n      best = mid;\n      l = mid + 1;\n    } else {\n      r = mid - 1;\n    }\n  }\n  return cost[2][best * 2] + cost[1][x - best * 2];\n}\nint main() {\n  int t = 1;\n  while (t--) {\n    long long n, m;\n    cin >> n >> m;\n    for (long long i = 1; i <= n; i++) {\n      long long x, y;\n      cin >> x >> y;\n      val[x].push_back(y);\n    }\n    for (long long i = 1; i <= 3; i++) {\n      sort(val[i].begin(), val[i].end());\n      reverse(val[i].begin(), val[i].end());\n      long long now = 0;\n      for (long long j = 0; j < val[i].size(); j++) {\n        now += val[i][j];\n        cost[i][(j + 1) * i] = now;\n      }\n      for (long long j = 1; j <= m; j++) {\n        cost[i][j] = max(cost[i][j], cost[i][j - 1]);\n      }\n    }\n    long long ans = 0;\n    for (long long i = 0; i <= m; i++) {\n      ans = max(ans, cost[3][i] + cal(m - i));\n    }\n    cout << ans << endl;\n    memset(cost, 0, sizeof(cost));\n    for (long long i = 0; i <= 3; i++) val[i].clear();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int N = 300010;\nstruct {\n  ll v;\n  ll c1, c2;\n} dp[N];\nint num[4], n, m;\nll a[4][N], s[4][N];\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  memset(num, 0, sizeof num);\n  memset(dp, 0, sizeof dp);\n  for (int i = 1; i <= n; ++i) {\n    ll w, c;\n    scanf(\"%I64d%I64d\", &w, &c);\n    a[w][++num[w]] = c;\n  }\n  for (int i = 1; i <= 3; ++i) {\n    s[i][0] = 0;\n    sort(a[i] + 1, a[i] + num[i] + 1,\n         [](const int &a, const int &b) { return a > b; });\n    for (int j = 1; j <= num[i]; ++j) s[i][j] = s[i][j - 1] + a[i][j];\n  }\n  dp[0].v = dp[0].c1 = dp[0].c2 = 0;\n  for (int i = 1; i <= m; ++i) {\n    if (dp[i - 1].v + a[1][dp[i - 1].c1 + 1] > dp[i].v) {\n      dp[i].v = dp[i - 1].v + a[1][dp[i - 1].c1 + 1];\n      dp[i].c1 = dp[i - 1].c1 + 1;\n      dp[i].c2 = dp[i - 1].c2;\n    }\n    if (i > 1 && dp[i - 2].v + a[2][dp[i - 2].c2 + 1] > dp[i].v) {\n      dp[i].v = dp[i - 2].v + a[2][dp[i - 2].c2 + 1];\n      dp[i].c1 = dp[i - 2].c1;\n      dp[i].c2 = dp[i - 2].c2 + 1;\n    }\n  }\n  ll ans = 0;\n  for (int i = 0; i <= num[3]; ++i) {\n    if (m >= i * 3) ans = max(ans, s[3][i] + dp[m - i * 3].v);\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nint n;\nstruct data {\n  ll cost;\n  int cnt1, cnt2, cnt3;\n} d[300010];\nll m, c1[100010], c2[100010], c3[100010], t1 = 0, t2 = 0, t3 = 0;\nbool cmp(ll a, ll b) { return a > b; }\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> m;\n  for (int i = 1; i <= n; ++i) {\n    int a;\n    ll b;\n    cin >> a >> b;\n    if (a == 1) {\n      ++t1;\n      c1[t1] = b;\n    }\n    if (a == 2) {\n      ++t2;\n      c2[t2] = b;\n    }\n    if (a == 3) {\n      ++t3;\n      c3[t3] = b;\n    }\n  }\n  d[0] = {0, 0, 0};\n  sort(c1 + 1, c1 + 1 + t1, cmp);\n  sort(c2 + 1, c2 + 1 + t2, cmp);\n  sort(c3 + 1, c3 + 1 + t3, cmp);\n  for (int i = 1; i <= m; ++i) {\n    if (i >= 1) {\n      if (d[i - 1].cnt1 < t1 &&\n          d[i - 1].cost + c1[d[i - 1].cnt1 + 1] > d[i].cost) {\n        d[i].cost = d[i - 1].cost + c1[d[i - 1].cnt1 + 1];\n        d[i].cnt1 = d[i - 1].cnt1 + 1;\n        d[i].cnt2 = d[i - 1].cnt2;\n        d[i].cnt3 = d[i - 1].cnt3;\n      }\n    }\n    if (i >= 2) {\n      if (d[i - 2].cnt2 < t2 &&\n          d[i - 2].cost + c2[d[i - 2].cnt2 + 1] > d[i].cost) {\n        d[i].cost = d[i - 2].cost + c2[d[i - 2].cnt2 + 1];\n        d[i].cnt1 = d[i - 2].cnt1;\n        d[i].cnt2 = d[i - 2].cnt2 + 1;\n        d[i].cnt3 = d[i - 2].cnt3;\n      }\n      if (d[i - 2].cnt1 > 0 && d[i - 2].cnt3 < t3) {\n        if (d[i - 2].cost - c1[d[i - 2].cnt1] + c3[d[i - 2].cnt3 + 1] >\n            d[i].cost) {\n          d[i].cost = d[i - 2].cost - c1[d[i - 2].cnt1] + c3[d[i - 2].cnt3 + 1];\n          d[i].cnt1 = d[i - 2].cnt1 - 1;\n          d[i].cnt2 = d[i - 2].cnt2;\n          d[i].cnt3 = d[i - 2].cnt3 + 1;\n        }\n      }\n    }\n    if (i >= 3) {\n      if (d[i - 3].cnt3 < t3 &&\n          d[i - 3].cost + c3[d[i - 3].cnt3 + 1] > d[i].cost) {\n        d[i].cost = d[i - 3].cost + c3[d[i - 3].cnt3 + 1];\n        d[i].cnt1 = d[i - 3].cnt1;\n        d[i].cnt2 = d[i - 3].cnt2;\n        d[i].cnt3 = d[i - 3].cnt3 + 1;\n      }\n    }\n  }\n  ll ans = 0;\n  for (int i = 1; i <= m; ++i) ans = max(ans, d[i].cost);\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, M, m, k;\nlong long now, ans, f_min[25], f_max[25];\nstruct ff {\n  long long w, p;\n  bool operator<(const ff b) const {\n    return ((long long)b.p * w < (long long)p * b.w) ||\n           ((long long)b.p * w == (long long)p * b.w && w < b.w);\n  }\n} a[100005];\nint read() {\n  int ret = 0;\n  bool f = 0;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') f |= (ch == '-'), ch = getchar();\n  while (ch >= '0' && ch <= '9') ret = ret * 10 + ch - '0', ch = getchar();\n  return f ? -ret : ret;\n}\nint main() {\n  n = read(), M = m = read();\n  for (int i = 1; i <= n; i++) a[i].w = read(), a[i].p = read();\n  sort(a + 1, a + 1 + n);\n  for (k = 1; k <= n && m; k++)\n    if (m >= a[k].w)\n      m -= a[k].w, ans += a[k].p;\n    else\n      break;\n  k--;\n  if (k == n) {\n    printf(\"%I64d\\n\", ans);\n    return 0;\n  }\n  memset(f_min, 63, sizeof f_min), f_min[0] = 0;\n  for (int i = 1; i <= k; i++)\n    for (int j = 10; j >= a[i].w; j--)\n      if (f_min[j - a[i].w] + a[i].p < f_min[j])\n        f_min[j] = f_min[j - a[i].w] + a[i].p;\n  for (int i = k + 1; i <= n; i++)\n    for (int j = 20; j >= a[i].w; j--)\n      if (f_max[j - a[i].w] + a[i].p > f_max[j])\n        f_max[j] = f_max[j - a[i].w] + a[i].p;\n  now = ans;\n  for (int i = 0; i <= 10; i++)\n    if (now - f_min[i] + f_max[m + i] > ans)\n      ans = now - f_min[i] + f_max[m + i];\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int n, m;\nvector<long long int> a[4];\nvector<double> b[4];\npair<long long int, pair<int, int> > a1[300010];\nint main() {\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    long long int k, l;\n    cin >> k >> l;\n    a[k].push_back(l);\n  }\n  for (int i = 1; i < 4; i++) {\n    sort(a[i].begin(), a[i].end(), greater<long long int>());\n  }\n  a1[0].first = 0;\n  a1[0].second.first = 0;\n  a1[0].second.second = 0;\n  a1[1].first = 0;\n  a1[1].second.first = 0;\n  a1[1].second.second = 0;\n  if (a[1].size() > 0) {\n    a1[1].first = a[1][0];\n    a1[1].second.first = 1;\n  }\n  long long int ans = 0;\n  for (int i = 2; i <= m; i++) {\n    if ((a[1].size() > a1[i - 1].second.first) and\n        (a[2].size() > a1[i - 2].second.second)) {\n      if (a1[i - 1].first + a[1][a1[i - 1].second.first] >=\n          a1[i - 2].first + a[2][a1[i - 2].second.second]) {\n        a1[i].first = a1[i - 1].first + a[1][a1[i - 1].second.first];\n        a1[i].second.first = a1[i - 1].second.first + 1;\n        a1[i].second.second = a1[i - 1].second.second;\n      } else {\n        a1[i].first = a1[i - 2].first + a[2][a1[i - 2].second.second];\n        a1[i].second.first = a1[i - 2].second.first;\n        a1[i].second.second = a1[i - 2].second.second + 1;\n      }\n    } else if (a[1].size() > a1[i - 1].second.first) {\n      if (a1[i - 1].first + a[1][a1[i - 1].second.first] >= a1[i - 2].first) {\n        a1[i].first = a1[i - 1].first + a[1][a1[i - 1].second.first];\n        a1[i].second.first = a1[i - 1].second.first + 1;\n        a1[i].second.second = a1[i - 1].second.second;\n      } else {\n        a1[i].first = a1[i - 2].first;\n        a1[i].second.first = a1[i - 2].second.first;\n        a1[i].second.second = a1[i - 2].second.second;\n      }\n    } else if (a[2].size() > a1[i - 2].second.second) {\n      if (a1[i - 1].first >= a1[i - 2].first + a[2][a1[i - 2].second.second]) {\n        a1[i].first = a1[i - 1].first;\n        a1[i].second.first = a1[i - 1].second.first;\n        a1[i].second.second = a1[i - 1].second.second;\n      } else {\n        a1[i].first = a1[i - 2].first + a[2][a1[i - 2].second.second];\n        a1[i].second.first = a1[i - 2].second.first;\n        a1[i].second.second = a1[i - 2].second.second + 1;\n      }\n    } else {\n      if (a1[i - 1].first >= a1[i - 2].first) {\n        a1[i].first = a1[i - 1].first;\n        a1[i].second.first = a1[i - 1].second.first;\n        a1[i].second.second = a1[i - 1].second.second;\n      } else {\n        a1[i].first = a1[i - 2].first;\n        a1[i].second.first = a1[i - 2].second.first;\n        a1[i].second.second = a1[i - 2].second.second;\n      }\n    }\n  }\n  long long int k = 0;\n  for (int i = 0; i <= m; i += 3) {\n    if (a1[m - i].first + k > ans) ans = a1[m - i].first + k;\n    if (i / 3 < a[3].size()) k += a[3][i / 3];\n  }\n  cout << ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1e17L;\nconst int inf = 0x3f3f3f3f;\nconst int maxn = 1e5 + 5;\nconst int Mod = 1e9 + 7;\nstruct Souvenirs {\n  int w, c;\n  bool friend operator<(Souvenirs x, Souvenirs y) {\n    return ((double)x.c / x.w) > ((double)y.c / y.w);\n  }\n} a[maxn];\nint n, m;\nlong long dp[3 * maxn];\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%d%d\", &a[i].w, &a[i].c);\n  sort(a + 1, a + n + 1);\n  for (int i = 1; i <= m; i++) dp[i] = -INF;\n  dp[0] = 0;\n  int up = 0;\n  long long ans = 0;\n  for (int i = 1; i <= n; i++) {\n    up += a[i].w;\n    if (up > m) up = m;\n    int least = max(a[i].w, up - 3);\n    for (int j = up; j >= least; j--) {\n      dp[j] = max(dp[j], dp[j - a[i].w] + a[i].c);\n      ans = max(ans, dp[j]);\n    }\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong n, m;\nvector<long long> w[3];\nlong long f(long mid, long tot) {\n  if (2 * mid > tot) return -(1 >> 30);\n  if (mid < w[1].size() && (tot - 2 * mid) < w[0].size())\n    return w[1][mid] + w[0][tot - 2 * mid];\n  else if (mid < w[1].size())\n    return w[1][mid] + w[0][w[0].size() - 1];\n  else if ((tot - 2 * mid) < w[0].size())\n    return w[1][w[1].size() - 1] + w[0][tot - 2 * mid];\n  else\n    return w[1][w[1].size() - 1] + w[0][w[0].size() - 1];\n}\nlong long ternary(long y) {\n  long l = 0, r = y / 2;\n  while (r - l >= 3) {\n    long m1 = l + (r - l) / 3;\n    long m2 = r - (r - l) / 3;\n    long long f1 = f(m1, y);\n    long long f2 = f(m2, y);\n    if (f1 < f2)\n      l = m1;\n    else\n      r = m2;\n  }\n  long long ans = 0;\n  for (long i = l; i <= r; i++) {\n    ans = max(ans, f(i, y));\n  }\n  return ans;\n}\nint main() {\n  cin >> n >> m;\n  long i, j, we, c;\n  for (i = 0; i < n; i++) {\n    cin >> we >> c;\n    w[we - 1].push_back(c);\n  }\n  for (i = 0; i < 3; i++) {\n    sort(w[i].begin(), w[i].end(), greater<long>());\n  }\n  for (i = 0; i < 3; i++) w[i].insert(w[i].begin(), 0);\n  for (i = 0; i < 3; i++) {\n    for (j = 1; j < w[i].size(); j++) {\n      w[i][j] += w[i][j - 1];\n    }\n  }\n  long long ans = 0;\n  for (i = 0; i < w[2].size() && i * 3 <= m; i++) {\n    ans = max(ans, w[2][i] + ternary(m - 3 * i));\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nlong long w[200009], c[200009], pre[10][200009];\nvector<long long> v[10];\ninline bool check(int mid, int curr1, int curr2) {\n  if (v[1][curr1 - 2 * (mid - 1) - 1] + v[1][curr1 - 2 * (mid - 1) - 2] <=\n      v[2][curr2 + (mid - 1)]) {\n    return true;\n  }\n  return false;\n}\ninline long long calc_max(int i) {\n  long long ans1 = 0, ans2 = 0;\n  int req = m - (i * 3), curr1 = 0, curr2 = 0;\n  if (v[1].size() == 0) {\n    curr1 = 0;\n  } else if (v[1].size() <= req) {\n    curr1 = v[1].size();\n    ans1 = pre[1][curr1 - 1];\n  } else {\n    curr1 = req;\n    ans1 = pre[1][curr1 - 1];\n  }\n  req = req - curr1;\n  if (v[2].size() == 0) {\n    curr2 = 0;\n  } else if (2 * (int)v[2].size() <= req) {\n    curr2 = v[2].size();\n    ans2 = pre[2][curr2 - 1];\n  } else {\n    curr2 = req / 2;\n    ans2 = pre[2][curr2 - 1];\n  }\n  req = req - (curr2 * 2);\n  if (curr1 == v[1].size() && curr2 == v[2].size()) {\n    return ans1 + ans2;\n  }\n  if (curr1 == 0 && curr2 == 0) {\n    return 0;\n  }\n  if (curr1 == 0 || curr2 == v[2].size()) {\n    return ans1 + ans2;\n  }\n  if (req) {\n    if (v[1][curr1 - 1] <= v[2][curr2]) {\n      ans1 -= v[1][curr1 - 1];\n      ans2 += v[2][curr2];\n      curr2++;\n      curr1--;\n      req--;\n    }\n  }\n  if (curr1 < 2 || curr2 == v[2].size()) {\n    return ans1 + ans2;\n  }\n  if (v[1][curr1 - 1] + v[1][curr1 - 2] > v[2][curr2]) {\n    return ans1 + ans2;\n  }\n  int low = 1, high = min((curr1 / 2), (int)v[2].size() - curr2);\n  while (low < high) {\n    int mid = low + ((high - low + 1) / 2);\n    if (check(mid, curr1, curr2)) {\n      low = mid;\n    } else {\n      high = mid - 1;\n    }\n  }\n  if (check(low, curr1, curr2)) {\n  } else {\n  }\n  ans1 = ans1 - (pre[1][curr1 - 1] - pre[1][curr1 - 2 * low - 1]);\n  ans2 = ans2 + (pre[2][curr2 + (low - 1)] - pre[2][curr2 - 1]);\n  return ans1 + ans2;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    cin >> w[i] >> c[i];\n    v[w[i]].push_back(c[i]);\n  }\n  for (int i = 1; i <= 3; i++) {\n    sort(v[i].begin(), v[i].end(), greater<long long>());\n    if (v[i].size() >= 1) {\n      pre[i][0] = v[i][0];\n    }\n    for (int j = 1; j < v[i].size(); j++) {\n      pre[i][j] = pre[i][j - 1] + v[i][j];\n    }\n  }\n  long long ans = 0, s = 0;\n  for (int i = 0; i <= v[3].size(); i++) {\n    if (m - (i * 3) >= 0) {\n      if (i) {\n        s = s + v[3][i - 1];\n      }\n      ans = max(ans, s + calc_max(i));\n    }\n  }\n  cout << ans << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst long long LINF = 0x3f3f3f3f3f3f3f3f;\nconst int MOD = 1e9 + 7;\nconst int N = 3e5 + 7;\nstruct node {\n  int w, c;\n  double v;\n  node() {}\n  node(int w, int c) : w(w), c(c) { v = (double)c / w; }\n  bool operator<(const node &rhs) const { return v > rhs.v; }\n} a[N];\nint n, m;\nlong long dp[N];\nvoid Init() {\n  for (int i = (1); i < (n + 1); ++i) {\n    int w, c;\n    scanf(\"%d%d\", &w, &c);\n    a[i] = node(w, c);\n  }\n  sort(a + 1, a + n + 1);\n}\nint Solve() {\n  int V = 0;\n  long long ans = 0;\n  for (int i = (1); i < (n + 1); ++i) {\n    V = min(V + a[i].w, m);\n    for (int j = (V + 1) - 1; j >= (max(V - 3, a[i].w)); --j) {\n      dp[j] = max(dp[j], dp[j - a[i].w] + a[i].c);\n      ans = max(ans, dp[j]);\n    }\n  }\n  return printf(\"%I64d\\n\", ans);\n}\nint main() {\n  while (~scanf(\"%d%d\", &n, &m)) {\n    Init();\n    Solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct nr {\n  int w, val;\n} v[100005];\nint cmp(nr a, nr b) { return 1LL * a.val * b.w > 1ll * b.val * a.w; }\nlong long dp[300005];\nint main() {\n  int n, m, curw = 0, i, j;\n  long long rasp = 0;\n  scanf(\"%d%d\", &n, &m);\n  for (i = 1; i <= n; i++) scanf(\"%d%d\", &v[i].w, &v[i].val);\n  sort(v + 1, v + n + 1, cmp);\n  for (i = 1; i <= n; i++) {\n    curw = min(curw + v[i].w, m);\n    for (j = min(m, curw); j >= max(v[i].w, curw - 3); j--) {\n      dp[j] = max(dp[j], dp[j - v[i].w] + v[i].val);\n      rasp = max(rasp, dp[j]);\n    }\n  }\n  printf(\"%lld\\n\", rasp);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "\nimport java.util.*;\n\n/**\n * Created by huang on 17-6-1.\n */\npublic class Main {\n    private static class status {\n        public long val;\n        public int cnt1,cnt2;\n    }\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt(), m = in.nextInt();\n        List<Long>[] items = new ArrayList[4];\n        for (int i = 1; i < 4; i++) {\n            items[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < n; i++) {\n            items[in.nextInt()].add(in.nextLong());\n        }\n        status[] dp = new status[m+1];\n        for (int i = 1; i < 4; i++) {\n            items[i].sort(new Comparator<Long>() {\n                @Override\n                public int compare(Long l1, Long l2) {\n                    return (int)(l2-l1);\n                }\n            });\n        }\n\n        dp[0] = new status();\n        for (int i = 1; i <= m; i++) {\n            dp[i] = new status();\n            if (dp[i-1].cnt1 < items[1].size()) {\n                dp[i].val = dp[i-1].val + items[1].get(dp[i-1].cnt1);\n                dp[i].cnt1 = dp[i-1].cnt1+1;\n                dp[i].cnt2 = dp[i-1].cnt2;\n            }\n            if (i >= 2\n                && dp[i-2].cnt2 < items[2].size()\n                && dp[i].val < dp[i-2].val + items[2].get(dp[i-2].cnt2)) {\n                dp[i].val = dp[i-2].val + items[2].get(dp[i-2].cnt2);\n                dp[i].cnt1 = dp[i-2].cnt1;\n                dp[i].cnt2 = dp[i-2].cnt2+1;\n            }\n        }\n        for (int i = 1; i <= m; i++) {\n            dp[i].val = Math.max(dp[i].val, dp[i-1].val);\n        }\n        long ans = 0;\n        long add = 0;\n        for (int i = 0; i <= items[3].size() && m - 3*i >= 0; i++) {\n            ans = Math.max(ans, dp[m-3*i].val + add);\n            if (i < items[3].size()) {\n                add += items[3].get(i);\n            }\n        }\n        System.out.println(ans);\n\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 3e5 + 10;\nlong long a[MAXN], b[MAXN], c[MAXN];\nlong long va[MAXN], vb[MAXN], vc[MAXN];\nint n, m, indxa = 1, indxb = 1, indxc = 1;\nbool cmp(long long a, long long b) { return a > b; }\nvoid get_v(void) {\n  for (int i = 1; i <= m; i++) {\n    va[i] = va[i - 1] + a[i];\n  }\n  for (int i = 1; i * 2 <= m; i++) {\n    vb[i << 1] = vb[(i - 1) << 1] + b[i];\n    vb[(i << 1) - 1] = vb[(i - 1) << 1];\n  }\n  for (int i = 1; i * 3 <= m; i++) {\n    vc[i * 3] = vc[(i - 1) * 3] + c[i];\n    vc[i * 3 - 1] = vc[(i - 1) * 3];\n    vc[i * 3 - 2] = vc[(i - 1) * 3];\n  }\n}\nlong long f(int x, int w) { return vb[x * 2] + va[w - x * 2]; }\nlong long find(int w) {\n  if (w <= 0) return 0;\n  int l = 0, r = w / 2;\n  while (l < r - 1) {\n    int lmid = (l + r) >> 1;\n    int rmid = (lmid + r) >> 1;\n    if (f(lmid, w) > f(rmid, w))\n      r = rmid;\n    else\n      l = lmid;\n  }\n  return max(max(max(f(l, w), f(r, w)), f(0, w)), f(w / 2, w));\n}\nint main(void) {\n  long long ans = 0;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    if (x == 1)\n      a[indxa++] = y;\n    else if (x == 2)\n      b[indxb++] = y;\n    else\n      c[indxc++] = y;\n  }\n  sort(a + 1, a + indxa, cmp);\n  sort(b + 1, b + indxb, cmp);\n  sort(c + 1, c + indxc, cmp);\n  get_v();\n  for (int i = 0; i * 3 <= m; i++) {\n    long long cnt = vc[i * 3];\n    cnt += find(m - i * 3);\n    ans = ans > cnt ? ans : cnt;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 300200;\nstruct Node {\n  int a, b;\n  long long v;\n} dp[maxn];\nlong long n, w, a[4][maxn], sum[maxn];\nint a1, b1, c1;\nint main() {\n  int x;\n  long long y;\n  scanf(\"%lld%lld\", &n, &w);\n  a1 = b1 = c1 = 0;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d%lld\", &x, &y);\n    if (x == 1) a[1][++a1] = y;\n    if (x == 2) a[2][++b1] = y;\n    if (x == 3) a[3][++c1] = y;\n  }\n  sort(a[1] + 1, a[1] + a1 + 1, greater<long long>());\n  sort(a[2] + 1, a[2] + b1 + 1, greater<long long>());\n  sort(a[3] + 1, a[3] + c1 + 1, greater<long long>());\n  for (int i = 1; i <= c1; i++) sum[i] = sum[i - 1] + a[3][i];\n  dp[0].a = 0;\n  dp[0].b = 0;\n  dp[0].v = 0;\n  for (int i = 1; i <= w; i++) {\n    dp[i] = dp[i - 1];\n    if (dp[i - 1].a < a1 && dp[i - 1].v + a[1][dp[i - 1].a + 1] > dp[i].v) {\n      dp[i] = dp[i - 1];\n      dp[i].v += a[1][dp[i - 1].a + 1];\n      dp[i].a++;\n    }\n    if (i >= 2 && dp[i - 2].b < b1 &&\n        dp[i - 2].v + a[2][dp[i - 2].b + 1] > dp[i].v) {\n      dp[i] = dp[i - 2];\n      dp[i].v += a[2][dp[i - 2].b + 1];\n      dp[i].b++;\n    }\n  }\n  long long cnt = dp[w].v;\n  for (int i = 1; i <= c1; i++) {\n    if (w >= i * 3) cnt = max(cnt, sum[i] + dp[w - 3 * i].v);\n  }\n  printf(\"%lld\\n\", cnt);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = (2e5 + 5);\nconst long long MOD = 10243;\nconst long long INF = 1e16;\nconst long long LOG = 29;\nlong long binpow(long long a, long long b) {\n  a %= MOD;\n  long long res = 1;\n  while (b > 0) {\n    if (b & 1) res = (res * a) % MOD;\n    a = (a * a) % MOD;\n    b >>= 1;\n  }\n  res %= MOD;\n  return res;\n}\nstruct gg {\n  long long ans;\n  long long one;\n  long long two;\n};\ngg dp[300005];\nvector<long long> w[4];\nvoid solve() {\n  long long n, m;\n  cin >> n >> m;\n  long long lol[n + 1], c[n + 1];\n  for (int i = 1; i <= n; i++) {\n    cin >> lol[i] >> c[i];\n    w[lol[i]].push_back(c[i]);\n  }\n  for (int i = 1; i <= 3; i++) {\n    sort(w[i].begin(), w[i].end(), greater<long long>());\n  }\n  dp[0].ans = 0;\n  dp[0].one = 0;\n  dp[0].two = 0;\n  for (int i = 1; i <= m; i++) {\n    dp[i] = {0, 0, 0};\n  }\n  if (m == 1) {\n    long long i = 0;\n    long long wp = dp[i].one;\n    if (wp >= w[1].size())\n      wp = 0;\n    else\n      wp = w[1][wp];\n    long long x = 1;\n    if (wp == 0) x = 0;\n    if (dp[i].ans + wp > dp[i + 1].ans) {\n      dp[i + 1].ans = dp[i].ans + wp;\n      dp[i + 1].one = dp[i].one + x;\n      dp[i + 1].two = dp[i].two;\n    }\n  }\n  for (int i = 0; i <= m - 2; i++) {\n    long long wp = dp[i].one;\n    if (wp >= w[1].size())\n      wp = 0;\n    else\n      wp = w[1][wp];\n    long long x = 1;\n    if (wp == 0) x = 0;\n    if (dp[i].ans + wp > dp[i + 1].ans) {\n      dp[i + 1].ans = dp[i].ans + wp;\n      dp[i + 1].one = dp[i].one + x;\n      dp[i + 1].two = dp[i].two;\n    }\n    long long o = dp[i].one;\n    long long t = dp[i].two;\n    if ((o + 1) >= w[1].size() && t >= w[2].size()) {\n      if (dp[i + 2].ans < dp[i].ans) {\n        dp[i + 2] = dp[i];\n      }\n      continue;\n    }\n    if ((o + 1) >= w[1].size()) {\n      if (dp[i].ans + w[2][t] > dp[i + 2].ans) {\n        dp[i + 2].ans = dp[i].ans + w[2][t];\n        dp[i + 2].two = dp[i].two + 1;\n        dp[i + 2].one = dp[i].one;\n      }\n    } else if (t >= w[2].size()) {\n      if (dp[i].ans + w[1][o] + w[1][o + 1] > dp[i + 2].ans) {\n        dp[i + 2].ans = dp[i].ans + w[1][o] + w[1][o + 1];\n        dp[i + 2].two = dp[i].two;\n        dp[i + 2].one = dp[i].one + 2;\n      }\n    } else {\n      if (w[1][o] + w[1][o + 1] > w[2][t]) {\n        if (dp[i].ans + w[1][o] + w[1][o + 1] > dp[i + 2].ans) {\n          dp[i + 2].ans = dp[i].ans + w[1][o] + w[1][o + 1];\n          dp[i + 2].two = dp[i].two;\n          dp[i + 2].one = dp[i].one + 2;\n        }\n      } else {\n        if (dp[i].ans + w[2][t] > dp[i + 2].ans) {\n          dp[i + 2].ans = dp[i].ans + w[2][t];\n          dp[i + 2].two = dp[i].two + 1;\n          dp[i + 2].one = dp[i].one;\n        }\n      }\n    }\n  }\n  long long ans = 0;\n  long long sum = 0;\n  for (long long x = 0; x < w[3].size(); x++) {\n    if (3 * (x + 1) > m) break;\n    sum += w[3][x];\n    ans = max(ans, sum + dp[m - 3 * (x + 1)].ans);\n  }\n  for (int i = 1; i <= m; i++) {\n    ans = max(ans, dp[i].ans);\n  }\n  cout << ans << \"\\n\";\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(NULL);\n  long long t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst long long inff = 0x3f3f3f3f3f3f3f3f;\nconst int mod = 998244353;\nconst double eps = 1e-9;\nconst int maxV = 3e5 + 5;\nint n, V, mV, a[maxV], tot;\nlong long dp[5][maxV];\nvector<long long> w[5];\nvoid solve(int l, int r, int L, int R, int id) {\n  if (l > r) return;\n  int pos = L, mid = l + r >> 1;\n  for (int i = max(mid - (int)w[id].size(), L); i <= min(mid, R); i++) {\n    if (dp[id][a[mid]] <\n        dp[id - 1][a[i]] + (i == mid ? 0 : w[id][mid - i - 1])) {\n      dp[id][a[mid]] = dp[id - 1][a[i]] + (i == mid ? 0 : w[id][mid - i - 1]);\n      pos = i;\n    }\n  }\n  solve(l, mid - 1, L, pos, id);\n  solve(mid + 1, r, pos, R, id);\n}\nnamespace fastIO {\nstatic char buf[100000], *h = buf, *d = buf;\ntemplate <typename T>\ninline void read(T& x) {\n  int f = 1;\n  x = 0;\n  register char c(\n      h == d && (d = (h = buf) + fread(buf, 1, 100000, stdin), h == d) ? EOF\n                                                                       : *h++);\n  while (c > '9' || c < '0') {\n    if (c == '-') f = -1;\n    c = h == d && (d = (h = buf) + fread(buf, 1, 100000, stdin), h == d) ? EOF\n                                                                         : *h++;\n  }\n  while (c <= '9' && c >= '0')\n    x = (x << 1) + (x << 3) + (c ^ 48),\n    c = h == d && (d = (h = buf) + fread(buf, 1, 100000, stdin), h == d) ? EOF\n                                                                         : *h++;\n  x *= f;\n}\ntemplate <typename T>\nvoid output(T x) {\n  if (x < 0) {\n    putchar('-');\n    x = ~(x - 1);\n  }\n  static int s[20], top = 0;\n  while (x) {\n    s[++top] = x % 10;\n    x /= 10;\n  }\n  if (!top) s[++top] = 0;\n  while (top) putchar(s[top--] + '0');\n}\n}  // namespace fastIO\nusing fastIO::output;\nusing fastIO::read;\nint main() {\n  read(n), read(V);\n  for (int i = (1); i <= (int)(n); ++i) {\n    int c, w0;\n    read(c), read(w0);\n    w[c].push_back(w0);\n    mV = max(mV, c);\n  }\n  for (int i = (1); i <= (int)(mV); ++i) {\n    sort(w[i].begin(), w[i].end(), greater<int>());\n    for (int j = 1; j < w[i].size(); j++) {\n      w[i][j] += w[i][j - 1];\n    }\n  }\n  for (int i = (1); i <= (int)(mV); ++i) {\n    for (int j = (0); j <= (int)(i - 1); ++j) {\n      tot = 0;\n      for (int k = j; k <= V; k += i) {\n        a[++tot] = k;\n      }\n      solve(1, tot, 1, tot, i);\n    }\n  }\n  int flag = 0;\n  printf(\"%lld\\n\", dp[mV][V]);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic final class selling_souv\n{\n    static BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\tstatic FastScanner sc=new FastScanner(br);\n    static PrintWriter out=new PrintWriter(System.out);\n\tstatic Random rnd=new Random();\n\tstatic ArrayList<Long>[] al;\n\t\n\t@SuppressWarnings(\"unchecked\")\n    public static void main(String args[]) throws Exception\n    {\n\t\tint n=sc.nextInt(),m=sc.nextInt();Node[] dp=new Node[m+1];\n\t\t\n\t\tal=new ArrayList[4];\n\t\t\n\t\tfor(int i=1;i<=3;i++)\n\t\t{\n\t\t\tal[i]=new ArrayList<Long>();al[i].add(Long.MAX_VALUE);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint curr=sc.nextInt();long cost=sc.nextLong();\n\t\t\t\n\t\t\tal[curr].add(cost);\n\t\t}\n\t\t\n\t\tfor(int i=1;i<=3;i++)\n\t\t{\n\t\t\tCollections.sort(al[i],Collections.reverseOrder());\n\t\t}\n\t\t\n\t\tdp[0]=new Node(0,0,0);\n\t\t\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tif(dp[i-1].idx1+1<al[1].size())\n\t\t\t{\n\t\t\t\tdp[i]=new Node(dp[i-1].idx1+1,dp[i-1].idx2,dp[i-1].cost+al[1].get(dp[i-1].idx1+1));\n\t\t\t}\n\t\t\t\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i]=new Node(dp[i-1].idx1,dp[i-1].idx2,dp[i-1].cost);\n\t\t\t}\n\t\t\t\t\t\n\t\t\tif(i>1 && dp[i-2].idx2+1<al[2].size())\n\t\t\t{\n\t\t\t\tlong curr=dp[i-2].cost+al[2].get(dp[i-2].idx2+1);\n\t\t\t\t\n\t\t\t\tif(curr>dp[i].cost)\n\t\t\t\t{\n\t\t\t\t\tdp[i]=new Node(dp[i-2].idx1,dp[i-2].idx2+1,curr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong[] pre=new long[al[3].size()];long sum=0;\n\t\t\n\t\tfor(int i=1;i<al[3].size();i++)\n\t\t{\n\t\t\tsum+=al[3].get(i);pre[i]=sum;\n\t\t}\n\t\t\n\t\tlong max=0;\n\t\t\n\t\tfor(int i=0;i<=m;i++)\n\t\t{\n\t\t\t\n\t\t\tint next=Math.min(al[3].size()-1,(m-i)/3);\n\t\t\t\n\t\t\tmax=Math.max(max,dp[i].cost+pre[next]);\n\t\t}\n\t\t\n\t\tout.println(max);out.close();\n    }\n}\n\nclass Node\n{\n\tint idx1,idx2;long cost;\n\t\n\tpublic Node(int idx1,int idx2,long cost)\n\t{\n\t\tthis.idx1=idx1;this.idx2=idx2;this.cost=cost;\n\t}\n}\n\nclass FastScanner\n{\n    BufferedReader in;\n    StringTokenizer st;\n\n    public FastScanner(BufferedReader in) {\n        this.in = in;\n    }\n\t\n    public String nextToken() throws Exception {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n\t\n\tpublic String next() throws Exception {\n\t\treturn nextToken().toString();\n\t}\n\t\n    public int nextInt() throws Exception {\n        return Integer.parseInt(nextToken());\n    }\n\n    public long nextLong() throws Exception {\n        return Long.parseLong(nextToken());\n    }\n\n    public double nextDouble() throws Exception {\n        return Double.parseDouble(nextToken());\n    }\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.*;\nimport java.security.KeyStore.Entry;\nimport java.util.*;\n\npublic class CODEFORCES {\n\tprivate InputStream is;\n\tprivate PrintWriter out;\n\n\tvoid solve() {\n\t\tint n = ni(), m = ni();\n\t\tint w[][] = new int[3][n + 1];\n\t\tint c[] = new int[3];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint co = ni() - 1;\n\t\t\tw[co][c[co]++] = ni();\n\t\t}\n\t\tlong dp[] = new long[m + 1];\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\tArrays.sort(w[i]);\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tfor (int j = 0; j < (n + 1) >> 1; j++) {\n\t\t\t\tint t = w[i][j];\n\t\t\t\tw[i][j] = w[i][n - j];\n\t\t\t\tw[i][n - j] = t;\n\t\t\t}\n\t\t}\n\t\tint ind[][] = new int[m + 1][3];\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tdp[i] = dp[i - 1];\n\t\t\tint in = -1;\n\t\t\tfor (int j = 2; j >= 0; j--) {\n\t\t\t\tif (i > j && dp[i] < dp[i - j - 1] + w[j][ind[i - j - 1][j]]) {\n\t\t\t\t\tdp[i] = dp[i - j - 1] + w[j][ind[i - j - 1][j]];\n\t\t\t\t\tin = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tint ku = -1;\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tif (i > 1 && ind[i - 1][j] > 0) {\n\t\t\t\t\tif (ans < dp[i - 1] + w[j + 1][ind[i - 1][j + 1]] - w[j][ind[i - 1][j] - 1]) {\n\t\t\t\t\t\tans = dp[i - 1] + w[j + 1][ind[i - 1][j + 1]] - w[j][ind[i - 1][j] - 1];\n\t\t\t\t\t\tku = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i > 2 && ind[i - 2][0] > 0) {\n\t\t\t\tlong temp = dp[i - 2] + w[2][ind[i - 2][2]] - w[0][ind[i - 2][0] - 1];\n\t\t\t\tif (temp > Math.max(ans, dp[i])) {\n\t\t\t\t\tdp[i] = temp;\n\t\t\t\t\tind[i][0] = ind[i - 2][0] - 1;\n\t\t\t\t\tind[i][1] = ind[i - 2][1];\n\t\t\t\t\tind[i][2] = ind[i - 2][2] + 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ans > dp[i]) {\n\t\t\t\tdp[i] = ans;\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (ku == j)\n\t\t\t\t\t\tind[i][j] = ind[i - 1][j] - 1;\n\t\t\t\t\telse if (ku + 1 == j)\n\t\t\t\t\t\tind[i][j] = ind[i - 1][j] + 1;\n\t\t\t\t\telse\n\t\t\t\t\t\tind[i][j] = ind[i - 1][j];\n\t\t\t\t}\n\t\t\t} else if (in != -1) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (in == j)\n\t\t\t\t\t\tind[i][j] = ind[i - 1 - in][j] + 1;\n\t\t\t\t\telse\n\t\t\t\t\t\tind[i][j] = ind[i - 1 - in][j];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t\t\tind[i][j] = ind[i - 1][j];\n\t\t\t}\n\t\t}\n\t\tout.println(dp[m]);\n\t}\n\n\tvoid soln() {\n\t\tis = System.in;\n\t\tout = new PrintWriter(System.out);\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis() - s + \"ms\");\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew CODEFORCES().soln();\n\t}\n\n\t// To Get Input\n\t// Some Buffer Methods\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != '\n\t\t\t\t\t\t\t\t\t// ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n\tprivate void tr(Object... o) {\n\t\tif (!oj)\n\t\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nconst int MAXN = 100000;\nconst int MAXCAP = 300000;\ntypedef struct R {\n  int w, c;\n} R;\nbool operator<(const R &a, const R &b) {\n  return (long long)a.c * b.w > (long long)b.c * a.w;\n}\nint n, cap;\nR r[MAXN];\nmultiset<int> have[4];\nmultiset<int> avail[4];\nlong long getlargest(multiset<int> &a, int cnt) {\n  if (((int)(a).size()) < cnt) return INT_MIN;\n  auto it = a.end();\n  long long ret = 0;\n  for (int i = (0); i < (cnt); ++i) {\n    --it;\n    ret += *it;\n  }\n  return ret;\n}\nlong long getsmallest(multiset<int> &a, int cnt) {\n  if (((int)(a).size()) < cnt) return INT_MAX;\n  auto it = a.begin();\n  long long ret = 0;\n  for (int i = (0); i < (cnt); ++i) {\n    ret += *it;\n    ++it;\n  }\n  return ret;\n}\nvoid removeone(multiset<int> &a, int val) {\n  auto it = a.find(val);\n  if (it == a.end())\n    printf(\"err (%d)\\n\", val);\n  else\n    a.erase(it);\n}\nvoid take(int cnt, int type) {\n  for (int i = (0); i < (cnt); ++i) {\n    long long cur = getlargest(avail[type], 1);\n    removeone(avail[type], cur);\n    have[type].insert(cur);\n  }\n}\nvoid remove(int cnt, int type) {\n  for (int i = (0); i < (cnt); ++i) {\n    long long cur = getsmallest(have[type], 1);\n    removeone(have[type], cur);\n    avail[type].insert(cur);\n  }\n}\nvoid run() {\n  scanf(\"%d%d\", &n, &cap);\n  for (int i = (0); i < (n); ++i) scanf(\"%d%d\", &r[i].w, &r[i].c);\n  sort(r, r + n);\n  int left = cap;\n  for (int i = (0); i < (4); ++i) have[i].clear(), avail[i].clear();\n  for (int i = (0); i < (n); ++i) avail[r[i].w].insert(r[i].c);\n  long long ret = 0;\n  for (int i = (0); i < (n); ++i) {\n    if (r[i].w > left) break;\n    left -= r[i].w;\n    ret += r[i].c;\n    have[r[i].w].insert(r[i].c);\n    removeone(avail[r[i].w], r[i].c);\n  }\n  while (left >= 1) {\n    long long best = 0;\n    int besttype = -1;\n    {\n      long long cur = getlargest(avail[1], 1);\n      if (cur > best) best = cur, besttype = 0;\n    }\n    {\n      long long cur = getlargest(avail[2], 1) - getsmallest(have[1], 1);\n      if (cur > best) best = cur, besttype = 1;\n    }\n    {\n      long long cur = getlargest(avail[2], 2) - getsmallest(have[3], 1);\n      if (cur > best) best = cur, besttype = 2;\n    }\n    {\n      long long cur = getlargest(avail[3], 1) - getsmallest(have[2], 1);\n      if (cur > best) best = cur, besttype = 3;\n    }\n    {\n      long long cur = getlargest(avail[3], 1) - getsmallest(have[1], 2);\n      if (cur > best) best = cur, besttype = 4;\n    }\n    if (besttype == -1) break;\n    if (besttype == 0)\n      take(1, 1);\n    else if (besttype == 1)\n      take(1, 2), remove(1, 1);\n    else if (besttype == 2)\n      take(2, 2), remove(1, 3);\n    else if (besttype == 3)\n      take(1, 3), remove(1, 2);\n    else if (besttype == 4)\n      take(1, 3), remove(2, 1);\n    ret += best;\n    --left;\n  }\n  while (left >= 2) {\n    long long best = 0;\n    int besttype = -1;\n    {\n      long long cur = getlargest(avail[2], 1);\n      if (cur > best) best = cur, besttype = 0;\n    }\n    {\n      long long cur = getlargest(avail[3], 1) - getsmallest(have[1], 1);\n      if (cur > best) best = cur, besttype = 1;\n    }\n    {\n      long long cur = getlargest(avail[3], 2) - getsmallest(have[2], 2);\n      if (cur > best) best = cur, besttype = 2;\n    }\n    if (besttype == -1) break;\n    if (besttype == 0)\n      take(1, 2);\n    else if (besttype == 1)\n      take(1, 3), remove(1, 1);\n    else if (besttype == 2)\n      take(2, 3), remove(2, 2);\n    ret += best;\n    --left;\n  }\n  printf(\"%lld\\n\", ret);\n}\nint main() {\n  run();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nstruct Souvenir {\n  int w, c;\n  bool operator<(const Souvenir &ot) const {\n    if (ot.w == w) return c > ot.c;\n    return w < ot.w;\n  }\n} s[100002];\nint cnt[3];\nlong long sum[3][100002];\nlong long ans;\nlong long cost(int i, int w) {\n  return sum[1][i] + sum[0][min(cnt[0], w - 2 * i)];\n}\nint bs(int w) {\n  int i = 0, p = 1 << 16;\n  while (p) {\n    if (i + p <= cnt[1] && ((i + p) * 2 <= w) &&\n        (cost(i + p, w) >= cost(i + p - 1, w)))\n      i += p;\n    p >>= 1;\n  }\n  return i;\n}\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d %d\", &s[i].w, &s[i].c);\n    ++cnt[--s[i].w];\n  }\n  sort(s + 1, s + n + 1);\n  int j = 0, crt = 0;\n  for (int i = 1; i <= n; ++i) {\n    if (s[i].w != s[i - 1].w) j = 0;\n    crt = s[i].w;\n    ++j;\n    sum[crt][j] = sum[crt][j - 1] + 1LL * s[i].c;\n  }\n  for (int i = 0; i <= cnt[2] && m >= 3 * i; ++i) {\n    int nr2 = bs(m - 3 * i), nr1 = min(cnt[0], m - 2 * nr2 - 3 * i);\n    ans = max(ans, sum[0][nr1] + sum[1][nr2] + sum[2][i]);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class SellSouvsQuick {\n\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint W = sc.nextInt();\n\t\t\n\t\tint[] val = new int[n];\n\t\tint[] weight = new int[n];\n\t\tint[] counter = new int[3];\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tweight[i] = sc.nextInt();\n\t\t\tval[i] = sc.nextInt();\n\t\t\tcounter[weight[i]-1] = counter[weight[i]-1] + 1;\n\t\t}\n\t\tsc.close();\n\n\t\tint[][] vals = new int[3][];\n\t\tvals[0] = new int[counter[0]];\n\t\tvals[1] = new int[counter[1]];\n\t\tvals[2] = new int[counter[2]];\n\t\t\n\t\tint[] index = new int[3];\n\t\t\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tvals[weight[i]-1][index[weight[i]-1]] = val[i];\n\t\t\tindex[weight[i]-1] = index[weight[i]-1] + 1;\n\t\t}\n\t\t\n\t\tArrays.sort(vals[0]);\n\t\tArrays.sort(vals[1]);\n\t\tArrays.sort(vals[2]);\n\n\t\tint addIndLength=2;\n\t\t\n\t\tlong[][] valsSorted = new long[3][];\n\t\tvalsSorted[0] = new long[counter[0]+addIndLength];\n\t\tvalsSorted[1] = new long[counter[1]+addIndLength];\n\t\tvalsSorted[2] = new long[counter[2]+addIndLength];\n\t\t\n\t\tfor(int i=0; i<3; i++)\n\t\t{\n\t\t\tif (vals[i].length >= 1)\n\t\t\t{\n\t\t\t\tvalsSorted[i][0] = vals[i][vals[i].length-1];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvalsSorted[i][0] = 0;\n\t\t\t\tvalsSorted[i][1] = 0;\n\t\t\t}\n\t\t\tfor (int j = 1; j<vals[i].length;j++)\n\t\t\t{\n\t\t\t\tvalsSorted[i][j] = valsSorted[i][j-1] + vals[i][vals[i].length-1-j];\n\t\t\t}\n\t\t\tfor (int j = Math.max(vals[i].length,1); j<vals[i].length+addIndLength;j++)\n\t\t\t{\n\t\t\t\tvalsSorted[i][j] = valsSorted[i][j-1];\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong[][] best = new long[W+1][3];\n\t\t\n\t\tif (vals[0].length >= 1)\n\t\t{\n\t\t\tbest[1][0]=valsSorted[0][0];\n\t\t\tbest[1][1]=1;\n\t\t\tbest[1][2]=0;\n\t\t}\n\t\t\n\t\tfor (int i = 2; i<= W; i++)\n\t\t{\n\t\t\tif (best[i-1][1] > vals[0].length-1)\n\t\t\t{\n\t\t\t\tif ( (best[i-2][2] > vals[1].length-1) ||\n\t\t\t\t\t\t(best[i-1][0] > best[i-2][0] + vals[1][(int) (vals[1].length-1-best[i-2][2])]) )\n\t\t\t\t{\n\t\t\t\t\tbest[i][0] = best[i-1][0];\n\t\t\t\t\tbest[i][1] = best[i-1][1];\n\t\t\t\t\tbest[i][2] = best[i-1][2];\t\t\t\t\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tbest[i][0] = best[i-2][0] + vals[1][(int) (vals[1].length-1-best[i-2][2])];\n\t\t\t\t\tbest[i][1] = best[i-2][1];\n\t\t\t\t\tbest[i][2] = best[i-2][2]+1;\n\t\t\t\t}\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif ( (best[i-2][2] > vals[1].length-1) ||\n\t\t\t\t\t\t(best[i-1][0] + vals[0][(int) (vals[0].length-1-best[i-1][1])] > \n\t\t\t\t\t\tbest[i-2][0] + vals[1][(int) (vals[1].length-1-best[i-2][2])]) )\n\t\t\t\t{\n\t\t\t\t\tbest[i][0] = best[i-1][0] + vals[0][(int) (vals[0].length-1-best[i-1][1])];\n\t\t\t\t\tbest[i][1] = best[i-1][1]+1;\n\t\t\t\t\tbest[i][2] = best[i-1][2];\n\t\t\t\t}\n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\tbest[i][0] = best[i-2][0] + vals[1][(int) (vals[1].length-1-best[i-2][2])];\n\t\t\t\t\tbest[i][1] = best[i-2][1];\n\t\t\t\t\tbest[i][2] = best[i-2][2]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tlong max = 0;// valsSorted[0][Math.min(W-1, valsSorted[0].length-1)];\n\n\t\tfor (int i = 0; i <= Math.min(vals[2].length,W/3); i++)\n\t\t{\n\t\t\tlong sol = 0;\n\t\t\tif (i > 0)\n\t\t\t{\n\t\t\t\tsol = valsSorted[2][i-1];\n\t\t\t}\n\t\t\tsol = sol + best[W-3*i][0];\n\t\t\tif (sol > max)\n\t\t\t\tmax = sol;\n\t\t\t\n//\t\t\tint maxIter = Math.min(vals[1].length, (W-3*i)/2);\n//\t\t\tfor (int j = 0; j <= maxIter; j++)\n//\t\t\t{\n//\t\t\t\tint sol = calcValue(i, j, W, valsSorted);\n//\t\t\t\tif (sol > max)\n//\t\t\t\t\tmax = sol;\n//\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(max);\n\t\treturn;\n\t}\n\n\tprivate static int calcValue(int x, int y, int W, int[][] valsSorted) {\n\t\tif (3*x + 2*y > W)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t\tint val = 0;\n\t\tif (x > 0)\n\t\t{\n\t\t\tval = val + valsSorted[2][x-1];\n\t\t}\n\t\tif (y > 0)\n\t\t{\n\t\t\tval = val + valsSorted[1][y-1];\n\t\t}\n\t\tif (3*x + 2*y < W)\n\t\t{\n\t\t\tval = val + valsSorted[0][Math.min(valsSorted[0].length-1, W-3*x-2*y-1)];\n\t\t}\n\t\treturn val;\n\t}\n\n\t\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\nimport java.util.Collections;\nimport java.util.ArrayList;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Vladik\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        int m;\n        ArrayList<Long>[] dp;\n\n        long get(int num, PrintWriter out) {\n            long ans = 0;\n\n            for (int i = 0; i < dp[1].size(); i++) {\n                if (m - (i * 2 + num * 3) < 0) {\n                    break;\n                }\n\n                int numThree = Math.min((m - (i * 2 + num * 3)), dp[0].size() - 1);\n\n                ans = Math.max(ans, dp[1].get(i) + dp[2].get(num) + dp[0].get(numThree));\n            }\n            return ans;\n        }\n\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int n = in.nextInt();\n            m = in.nextInt();\n\n            ArrayList<Long>[] a = new ArrayList[3];\n            dp = new ArrayList[3];\n            for (int i = 0; i < 3; i++) {\n                a[i] = new ArrayList<>();\n                dp[i] = new ArrayList<>();\n            }\n\n            for (int i = 0; i < n; i++) {\n                int w = in.nextInt() - 1;\n                int c = in.nextInt();\n\n                a[w].add((long) c);\n            }\n\n            for (int i = 0; i < 3; i++) {\n                Collections.sort(a[i]);\n                Collections.reverse(a[i]);\n\n                dp[i].add((long) 0);\n                for (int j = 0; j < a[i].size(); j++) {\n                    dp[i].add(dp[i].get(j) + a[i].get(j));\n                }\n            }\n\n\n            int l = 0;\n            int r = dp[2].size() - 1;\n\n//        for(int i = l; i <= r; i++)\n//            out.printf(\"%d \", get(i, out));\n//        out.println();\n\n            while (r - l > 100) {\n                int ml = l + (r - l + 1) / 3;\n                int mr = r - (r - l + 1) / 3;\n\n                if (get(ml, out) < get(mr, out))\n                    l = ml;\n                else\n                    r = mr;\n            }\n\n            long ans = 0;\n            for (int i = l; i <= r; i++)\n                ans = Math.max(ans, get(i, out));\n\n            out.println(ans);\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 3,
            "solution": "import sys\nn, m = map(int, input().split())\nw1 = []\nw2 = []\nw3 = [10**10]\n\nfor w, c in (map(int, l.split()) for l in sys.stdin):\n    if w == 1:\n        w1.append(c)\n    elif w == 2:\n        w2.append(c)\n    else:\n        w3.append(c)\n\nw1.sort(reverse=True)\nw2.sort(reverse=True)\nw3.sort(reverse=True)\nw3[0] = 0\nw1_size, w2_size = len(w1), len(w2)\n\ndp = [(0, 0, 0) for _ in range(m+3)]\nfor i in range(m):\n    dp[i+1] = max(dp[i+1], dp[i])\n    if dp[i][1] < w1_size:\n        dp[i+1] = max(dp[i+1], (dp[i][0]+w1[dp[i][1]], dp[i][1]+1, dp[i][2]))\n    if dp[i][2] < w2_size:\n        dp[i+2] = max(dp[i+2], (dp[i][0]+w2[dp[i][2]], dp[i][1], dp[i][2]+1))\n\nans = 0\nw3_c = 0\n\nfor i in range(len(w3)):\n    if i*3 > m:\n        continue\n    w3_c += w3[i]\n    ans = max(ans, w3_c + dp[m-i*3][0])\n\nprint(ans)\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class SellSouvsQuick {\n\n\tpublic static void main(String[] args) \n\t{\n\t\t// read input\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint W = sc.nextInt();\n\t\t\n\t\tint[] val = new int[n];\n\t\tint[] weight = new int[n];\n\t\tint[] counter = new int[3]; // counter of how many of each weight there are\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tweight[i] = sc.nextInt();\n\t\t\tval[i] = sc.nextInt();\n\t\t\tcounter[weight[i]-1] = counter[weight[i]-1] + 1;\n\t\t}\n\t\tsc.close();\n\n\t\t// insert values per weight\n\n\t\tint[][] vals = new int[3][];\n\t\tvals[0] = new int[counter[0]];\n\t\tvals[1] = new int[counter[1]];\n\t\tvals[2] = new int[counter[2]];\n\t\t\n\t\tint[] index = new int[3];\n\t\t\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tvals[weight[i]-1][index[weight[i]-1]] = val[i];\n\t\t\tindex[weight[i]-1] = index[weight[i]-1] + 1;\n\t\t}\n\t\t\n\t\t// sort values per weight (it is beneficial to take more value for the same weight)\n\n\t\tArrays.sort(vals[0]);\n\t\tArrays.sort(vals[1]);\n\t\tArrays.sort(vals[2]);\n\n\t\t// int -> long + 2 indices added\n\n\t\tint addIndLength=2;\n\t\t\n\t\tlong[][] valsSorted = new long[3][];\n\t\tvalsSorted[0] = new long[counter[0]+addIndLength];\n\t\tvalsSorted[1] = new long[counter[1]+addIndLength];\n\t\tvalsSorted[2] = new long[counter[2]+addIndLength];\n\t\t\n\t\t// compute indices\n\n\t\tfor(int i=0; i<3; i++)\n\t\t{\n\t\t\tif (vals[i].length >= 1)\n\t\t\t{\n\t\t\t\tvalsSorted[i][0] = vals[i][vals[i].length-1]; // first index = length (-1)\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvalsSorted[i][0] = 0;\n\t\t\t\tvalsSorted[i][1] = 0;\n\t\t\t}\n\t\t\tfor (int j = 1; j<vals[i].length;j++)\n\t\t\t{\n\t\t\t\tvalsSorted[i][j] = valsSorted[i][j-1] + vals[i][vals[i].length-1-j]; // sum up the values up to this index\n\t\t\t}\n\t\t\tfor (int j = Math.max(vals[i].length,1); j<vals[i].length+addIndLength;j++)\n\t\t\t{\n\t\t\t\tvalsSorted[i][j] = valsSorted[i][j-1]; // shift every entry by one to the right...\n\t\t\t}\n\t\t}\n\t\t\n\t\t// initialize dynamic program (best) (only with weight 1 and weight 2 items)\n\t\t// best[i][0] is the optimal solution up to weight i\n\t\t// best[i][1] is the number of weight 1 items already took\n\t\t// best[i][2] is the number of weight 2 items already in the solution\n\n\t\tlong[][] best = new long[W+1][3];\n\t\t\n\t\tif (vals[0].length >= 1) // for weight 1 we can only take one weight 1 item (if there is any)\n\t\t{\n\t\t\tbest[1][0]=valsSorted[0][0];\n\t\t\tbest[1][1]=1;\n\t\t\tbest[1][2]=0;\n\t\t}\n\t\t\n\t\t// dynamic program\n\n\t\tfor (int i = 2; i<= W; i++) // for each weight i up to W\n\t\t{\n\t\t\tif (best[i-1][1] > vals[0].length-1) // if there are no weight 1 items left\n\t\t\t{\n\t\t\t\tif ( (best[i-2][2] > vals[1].length-1) ||\n\t\t\t\t\t\t(best[i-1][0] > best[i-2][0] + vals[1][(int) (vals[1].length-1-best[i-2][2])]) ) // if there are no weight 2 items left or the last weight 1 items bring more benefit than one weight 2 item, then essentially do nothing\n\t\t\t\t{\n\t\t\t\t\tbest[i][0] = best[i-1][0];\n\t\t\t\t\tbest[i][1] = best[i-1][1];\n\t\t\t\t\tbest[i][2] = best[i-1][2];\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse // else update opt solution (take weight 2 item)\n\t\t\t\t{\n\t\t\t\t\tbest[i][0] = best[i-2][0] + vals[1][(int) (vals[1].length-1-best[i-2][2])];\n\t\t\t\t\tbest[i][1] = best[i-2][1];\n\t\t\t\t\tbest[i][2] = best[i-2][2]+1;\n\t\t\t\t}\t\n\t\t\t}\n\t\t\telse // if weight 1 items are left\n\t\t\t{\n\t\t\t\tif ( (best[i-2][2] > vals[1].length-1) ||\n\t\t\t\t\t\t(best[i-1][0] + vals[0][(int) (vals[0].length-1-best[i-1][1])] > \n\t\t\t\t\t\tbest[i-2][0] + vals[1][(int) (vals[1].length-1-best[i-2][2])]) ) // if no weight 2 items are left or if two weight 1 items bring more benefit than one weight 2 item, then take two weight one items\n\t\t\t\t{\n\t\t\t\t\tbest[i][0] = best[i-1][0] + vals[0][(int) (vals[0].length-1-best[i-1][1])];\n\t\t\t\t\tbest[i][1] = best[i-1][1]+1;\n\t\t\t\t\tbest[i][2] = best[i-1][2];\n\t\t\t\t}\n\t\t\t\telse // else take a weight 2 item\n\t\t\t\t{\n\t\t\t\t\tbest[i][0] = best[i-2][0] + vals[1][(int) (vals[1].length-1-best[i-2][2])];\n\t\t\t\t\tbest[i][1] = best[i-2][1];\n\t\t\t\t\tbest[i][2] = best[i-2][2]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// compute an optimal solution (guess the number of weight 3 items and fill the rest with best[x][y])\n\n\t\tlong max = 0;\n\n\t\tfor (int i = 0; i <= Math.min(vals[2].length,W/3); i++)\n\t\t{\n\t\t\tlong sol = 0;\n\t\t\tif (i > 0)\n\t\t\t{\n\t\t\t\tsol = valsSorted[2][i-1];\n\t\t\t}\n\t\t\tsol = sol + best[W-3*i][0];\n\t\t\tif (sol > max)\n\t\t\t\tmax = sol;\n\t\t}\n\t\t\n\t\t// write output and terminate\n\n\t\tSystem.out.println(max);\n\t\treturn;\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef struct status {\n  long long val;\n  long long cnt1;\n  long long cnt2;\n} status;\nvector<long long> v[4];\nstatus s[300001];\nint main() {\n  int n, m, w;\n  long long c, ans, add;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d%I64d\", &w, &c);\n    v[w].push_back(c);\n  }\n  for (int i = 1; i <= 3; i++) {\n    sort(v[i].begin(), v[i].end());\n    reverse(v[i].begin(), v[i].end());\n  }\n  for (int i = 1; i <= m; i++) {\n    if (s[i - 1].cnt1 < v[1].size()) {\n      s[i].val = s[i - 1].val + v[1][s[i - 1].cnt1];\n      s[i].cnt1 = s[i - 1].cnt1 + 1;\n      s[i].cnt2 = s[i - 1].cnt2;\n    }\n    if (i >= 2 && s[i - 2].cnt2 < v[2].size() &&\n        s[i].val < s[i - 2].val + v[2][s[i - 2].cnt2]) {\n      s[i].val = s[i - 2].val + v[2][s[i - 2].cnt2];\n      s[i].cnt1 = s[i - 2].cnt1;\n      s[i].cnt2 = s[i - 2].cnt2 + 1;\n    }\n  }\n  for (int i = 1; i <= m; i++)\n    if (s[i].val < s[i - 1].val) s[i].val = s[i - 1].val;\n  ans = 0;\n  add = 0;\n  for (int i = 0; i <= v[3].size() && m - 3 * i >= 0; i++) {\n    if (s[m - 3 * i].val + add > ans) ans = s[m - 3 * i].val + add;\n    if (i < v[3].size()) add += v[3][i];\n  }\n  printf(\"%I64d\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  long long n, m;\n  cin >> n >> m;\n  vector<long long> a3, a2, a1;\n  for (int i = 0; i < n; i++) {\n    long long w, c;\n    cin >> w >> c;\n    if (w == 3)\n      a3.push_back(c);\n    else if (w == 2)\n      a2.push_back(c);\n    else\n      a1.push_back(c);\n  }\n  sort(a2.begin(), a2.end());\n  sort(a1.begin(), a1.end());\n  reverse(a1.begin(), a1.end());\n  reverse(a2.begin(), a2.end());\n  vector<pair<pair<long long, long long>, pair<long long, long long> > > comb;\n  long long second = 0, sw = 0;\n  int i = 0, j = 0;\n  int s1 = (int)a1.size(), s2 = (int)a2.size();\n  while (i < s1 && j < s2) {\n    long long k1 = 2ll * a1[i];\n    if (k1 > a2[j]) {\n      second += a1[i];\n      sw += 1;\n      comb.push_back({{second, sw}, {i + 1, j}});\n      i++;\n    } else {\n      second += a2[j];\n      sw += 2;\n      comb.push_back({{second, sw}, {i, j + 1}});\n      j++;\n    }\n  }\n  while (i < s1) {\n    second += a1[i];\n    sw += 1;\n    comb.push_back({{second, sw}, {i + 1, j}});\n    i++;\n  }\n  while (j < s2) {\n    second += a2[j];\n    sw += 2;\n    comb.push_back({{second, sw}, {i, j + 1}});\n    j++;\n  }\n  a1.push_back(0ll);\n  a2.push_back(0ll);\n  sort(a3.begin(), a3.end());\n  reverse(a3.begin(), a3.end());\n  s2 = (int)comb.size();\n  long long mx = 0;\n  long long tempscore = 0;\n  long long tl = 0;\n  for (int i = 0; i <= (int)a3.size(); i++) {\n    long long ma = m - 3ll * i;\n    tempscore = 0;\n    if (i >= 1) tl += a3[i - 1];\n    tempscore = tl;\n    if (ma < 0) break;\n    if (ma >= comb[s2 - 1].first.second) {\n      tempscore += comb[s2 - 1].first.first;\n      mx = max(mx, tempscore);\n      continue;\n    }\n    int lo = 0, hi = s2 - 1;\n    int ans = -1;\n    while (lo <= hi) {\n      int mid = (lo + hi) >> 1;\n      long long cw = comb[mid].first.second;\n      if (cw <= ma) {\n        ans = mid;\n        lo = mid + 1;\n      } else {\n        hi = mid - 1;\n      }\n    }\n    if (ans == -1) {\n      if (s1 && ma) tempscore += a1[0];\n    } else {\n      long long j = 0;\n      if (comb[ans].first.second != ma) {\n        assert(comb[ans].first.second == (ma - 1));\n        j = a1[comb[ans].second.first];\n        if (comb[ans].second.first != 0) {\n          j = max(j,\n                  a2[comb[ans].second.second] - a1[comb[ans].second.first - 1]);\n        }\n        tempscore += j;\n      }\n      tempscore += comb[ans].first.first;\n    }\n    mx = max(mx, tempscore);\n  }\n  cout << mx << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 7;\nlong long ans, dp[N];\nint ed, n, m;\nstruct node {\n  int w, c;\n  double val;\n  node(int a = 0, int b = 0) : w(a), c(b) {}\n  bool operator<(const node &b) const { return val > b.val; }\n} a[N], tmp[N];\nlong long DP() {\n  for (int i = 1; i <= ed; i++) {\n    for (int j = m; j >= tmp[i].w; j--) {\n      dp[j] = max(dp[j], dp[j - tmp[i].w] + tmp[i].c);\n    }\n  }\n  return dp[m];\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  ans = 0;\n  for (int i = 1; i <= n; i++)\n    scanf(\"%d%d\", &a[i].w, &a[i].c), a[i].val = 1.0 * a[i].c / a[i].w;\n  sort(a + 1, a + 1 + n);\n  int tp[4];\n  memset(tp, -1, sizeof(tp));\n  for (int i = 1; i <= n; i++) {\n    if (m < 30) {\n      ed = 0;\n      while (i <= n) tmp[++ed] = a[i], i++;\n      for (int ii = 1; ii <= 3; ii++)\n        if (~tp[ii]) tmp[++ed] = node(ii, tp[ii]), m += ii, ans -= tp[ii];\n      ans += DP();\n      break;\n    }\n    ans += a[i].c;\n    m -= a[i].w;\n    tp[a[i].w] = a[i].c;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nvoid debug() {}\nconst int N = 1e5 + 5;\nlong long n, m, dp[N * 5];\nstruct Node {\n  long long weight, cost, ratio;\n  bool operator<(const Node &rhs) const { return ratio > rhs.ratio; }\n} A[N];\nint main() {\n  scanf(\"%lld %lld\", &n, &m);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%lld %lld\", &A[i].weight, &A[i].cost);\n    A[i].ratio = A[i].cost * 6 / A[i].weight;\n  }\n  std::sort(A + 1, A + 1 + n);\n  long long sum = 0;\n  for (int i = 1; i <= n; ++i) {\n    long long w = A[i].weight, c = A[i].cost;\n    sum += w;\n    for (int j = sum; j >= std::max(w, sum - 50); --j) {\n      dp[j] = std::max(dp[j], dp[j - w] + c);\n    }\n  }\n  long long ans = 0;\n  for (int i = m; i >= 0; --i) ans = std::max(ans, dp[i]);\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 3e5 + 5;\nlong long take[4][N];\nlong long best[4][N];\nint cnt[N];\nint n, m;\nlong long solve(int weight, int take_dua) {\n  int one = min(cnt[1], weight - 2 * take_dua);\n  return take[2][take_dua] + take[1][one];\n}\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 0; i < n; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    cnt[a]++;\n    best[a][cnt[a]] = b;\n  }\n  for (int j = 1; j <= 3; j++) {\n    sort(best[j] + 1, best[j] + 1 + cnt[j]);\n    reverse(best[j] + 1, best[j] + 1 + cnt[j]);\n    for (int i = 1; i <= cnt[j]; i++) {\n      take[j][i] = take[j][i - 1] + best[j][i];\n    }\n  }\n  long long ans = 0;\n  for (int i = 0; i <= cnt[3] && 3 * i <= m; i++) {\n    int l = 0, r = min(cnt[2], (m - 3 * i) / 2);\n    int sisa = m - 3 * i;\n    while (r - l > 3) {\n      int lf = l + (r - l) / 3;\n      int rf = r - (r - l) / 3;\n      if (solve(sisa, lf) > solve(sisa, rf)) {\n        r = rf;\n      } else {\n        l = lf;\n      }\n    }\n    for (int j = l; j <= r; j++)\n      ans = max(ans, take[3][i] + solve(m - 3 * i, j));\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nvector<long long> A, B, C;\nvector<long long> b, c, bb, cc;\nlong long solve(int mm) {\n  b.push_back(0);\n  bb.resize(b.size());\n  bb[0] = b[0];\n  for (int i = 1; i < (int)b.size(); i++) bb[i] = b[i] + bb[i - 1];\n  cc.resize(c.size());\n  cc[0] = c[0];\n  for (int i = 1; i < (int)c.size(); i++) cc[i] = c[i] + cc[i - 1];\n  long long ans = 0;\n  for (int i = 0; i * 3 <= mm && i < (int)c.size(); i++) {\n    int r = mm - i * 3;\n    r = min(r / 2, -1 + (int)b.size());\n    ans = max(ans, cc[i] - c[i] + bb[r] - b[r]);\n  }\n  return ans;\n}\nint main() {\n  scanf(\"%d\", &n), scanf(\"%d\", &m);\n  for (int i = 0; i < (int)n; i++) {\n    int w, c;\n    scanf(\"%d\", &w), scanf(\"%d\", &c);\n    if (w == 1) A.push_back(c);\n    if (w == 2) B.push_back(c);\n    if (w == 3) C.push_back(c);\n  }\n  sort(A.begin(), A.end(), greater<long long>());\n  sort(B.begin(), B.end(), greater<long long>());\n  sort(C.begin(), C.end(), greater<long long>());\n  for (int i = 0; i + 1 < (int)A.size(); i += 2) {\n    b.push_back(A[i] + A[i + 1]);\n  }\n  for (int i = 0; i < (int)B.size(); i++) b.push_back(B[i]);\n  sort(b.begin(), b.end(), greater<long long>());\n  for (int i = 0; i < (int)C.size(); i++) c.push_back(C[i]);\n  c.push_back(0);\n  long long ans = solve(m);\n  if (A.size() > 0) {\n    b.clear();\n    for (int i = 1; i + 1 < (int)A.size(); i += 2) {\n      b.push_back(A[i] + A[i + 1]);\n    }\n    for (int i = 0; i < (int)B.size(); i++) b.push_back(B[i]);\n    sort(b.begin(), b.end(), greater<long long>());\n    ans = max(ans, solve(m - 1) + A[0]);\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nlong long mode(long long a) {\n  a %= mod;\n  if (a < 0) a += mod;\n  return a;\n}\nlong long subt(long long a, long long b) { return mode(mode(a) - mode(b)); }\nlong long add(long long a, long long b) { return mode(mode(a) + mode(b)); }\nlong long mult(long long a, long long b) { return mode(mode(a) * mode(b)); }\nlong long binpow(long long a, long long b) {\n  long long res = 1;\n  while (b) {\n    if (b & 1) res = mult(res, a);\n    a = mult(a, a);\n    b >>= 1;\n  }\n  return res;\n}\nconst int M = 3e5 + 7;\nstruct node {\n  long long cost;\n  long long cnt1, cnt2, cnt3;\n} dp[M];\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<int> soos[4];\n  for (int i = 1; i <= n; i++) {\n    int w, c;\n    cin >> w >> c;\n    soos[w].push_back(c);\n  }\n  sort(soos[1].rbegin(), soos[1].rend());\n  sort(soos[2].rbegin(), soos[2].rend());\n  sort(soos[3].rbegin(), soos[3].rend());\n  dp[0] = {0, 0, 0, 0};\n  for (int i = 1; i <= m; i++) {\n    dp[i] = dp[i - 1];\n    if (i >= 2 && dp[i - 2].cost > dp[i].cost) dp[i] = dp[i - 2];\n    if (i >= 3 && dp[i - 3].cost > dp[i].cost) dp[i] = dp[i - 3];\n    if (dp[i - 1].cnt1 < int((soos[1]).size()) &&\n        dp[i - 1].cost + soos[1][dp[i - 1].cnt1] > dp[i].cost) {\n      dp[i] = dp[i - 1];\n      dp[i].cost += soos[1][dp[i - 1].cnt1];\n      dp[i].cnt1++;\n    }\n    if (i >= 2 && dp[i - 2].cnt2 < int((soos[2]).size()) &&\n        dp[i - 2].cost + soos[2][dp[i - 2].cnt2] > dp[i].cost) {\n      dp[i] = dp[i - 2];\n      dp[i].cost += soos[2][dp[i - 2].cnt2];\n      dp[i].cnt2++;\n    }\n    if (i >= 3 && dp[i - 3].cnt3 < int((soos[3]).size()) &&\n        dp[i - 3].cost + soos[3][dp[i - 3].cnt3] > dp[i].cost) {\n      dp[i] = dp[i - 3];\n      dp[i].cost += soos[3][dp[i - 3].cnt3];\n      dp[i].cnt3++;\n    }\n    if (i >= 2 && dp[i - 2].cnt1 && dp[i - 2].cnt3 < int((soos[3]).size()) &&\n        dp[i - 2].cost - soos[1][dp[i - 2].cnt1 - 1] + soos[3][dp[i - 2].cnt3] >\n            dp[i].cost) {\n      dp[i].cost = dp[i - 2].cost - soos[1][dp[i - 2].cnt1 - 1] +\n                   soos[3][dp[i - 2].cnt3];\n      dp[i].cnt1 = dp[i - 2].cnt1 - 1;\n      dp[i].cnt2 = dp[i - 2].cnt2;\n      dp[i].cnt3 = dp[i - 2].cnt3 + 1;\n    }\n  }\n  cout << dp[m].cost;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "//package educational.round21;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.Random;\n\npublic class E {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni(), m = ni();\n\t\tint[][] ws = new int[4][n];\n\t\tint[] wp = new int[4];\n\t\tRandom gen = new Random();\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint w = ni();\n\t\t\tint c = ni();\n\t\t\tws[w][wp[w]++] = c;\n\t\t}\n\t\t\n\t\tlong[][] cum = new long[4][];\n\t\tfor(int i = 1;i <= 3;i++){\n\t\t\tws[i] = Arrays.copyOf(ws[i], wp[i]);\n\t\t\tws[i] = shuffle(ws[i], gen);\n\t\t\tArrays.sort(ws[i]);\n\t\t\tfor(int j = 0, k = ws[i].length-1;j < k;j++,k--){\n\t\t\t\tint d = ws[i][j]; ws[i][j] = ws[i][k]; ws[i][k] = d;\n\t\t\t}\n\t\t\tcum[i] = new long[ws[i].length+1];\n\t\t\tfor(int j = 0;j < cum[i].length-1;j++){\n\t\t\t\tcum[i][j+1] = cum[i][j] + ws[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong[] dp = new long[m+1];\n\t\tArrays.fill(dp, Long.MIN_VALUE / 3);\n\t\tdp[0] = 0;\n\t\tfor(int i = 1;i <= 3;i++){\n\t\t\tlong[] ndp = new long[m+1];\n\t\t\tArrays.fill(ndp, Long.MIN_VALUE / 3);\n\t\t\tgcum = cum[i];\n\t\t\tfor(int u = 0;u < i;u++){\n\t\t\t\tlong[] odp = new long[(m-u)/i+1];\n\t\t\t\tfor(int j = u, k = 0;j <= m;j+=i,k++){\n\t\t\t\t\todp[k] = -dp[j];\n\t\t\t\t}\n\t\t\t\tlong[] nldp = new long[odp.length];\n\t\t\t\tdivideAndConquer(0, odp.length, 0, odp.length, odp, nldp);\n\t\t\t\tfor(int j = u, k = 0;j <= m;j+=i,k++){\n\t\t\t\t\tndp[j] = -nldp[k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = ndp;\n\t\t}\n\t\tout.println(Arrays.stream(dp).max().getAsLong());\n\t}\n\t\n\tlong[] gcum;\n\t\n\tpublic void divideAndConquer(int l, int r, int argl, int argr, long[] pre, long[] cur)\n\t{\n\t\tif(l >= r)return;\n\t\tint h = l+r>>1;\n\t\tlong min = Long.MAX_VALUE / 3;\n\t\tint argmin = -1;\n\t\tfor(int i = Math.max(argl, 0);i < argr && i <= h;i++){\n\t\t\tlong val = pre[i] + f(i, h); // [i,h)\n\t\t\tif(val < min){\n\t\t\t\tmin = val;\n\t\t\t\targmin = i;\n\t\t\t}\n\t\t}\n\t\tcur[h] = min;\n\t\t\n\t\tif(r-l > 1){\n\t\t\tdivideAndConquer(l, h, argl, argmin+1, pre, cur);\n\t\t\tdivideAndConquer(h+1, r, argmin, argr, pre, cur);\n\t\t}else{\n\t\t\tcur[l] = Math.min(cur[l], pre[l]);\n\t\t}\n\t}\n\t\n\tprivate long f(int l, int r){\n\t\tif(r-l < gcum.length){\n\t\t\treturn -gcum[r-l];\n\t\t}else{\n\t\t\treturn Long.MAX_VALUE / 3;\n\t\t}\n\t}\n\t\n\tpublic static int[] shuffle(int[] a, Random gen){ for(int i = 0, n = a.length;i < n;i++){ int ind = gen.nextInt(n-i)+i; int d = a[i]; a[i] = a[ind]; a[ind] = d; } return a; }\n\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new E().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\n@SuppressWarnings(\"unchecked\")\npublic class P808E {\n\n  final static int DIST = 5;\n\n  public void run() throws Exception {\n    int n = nextInt(), m = nextInt();\n    int [][] wca = new int [n][2];\n    int l1 = 0, l2 = 0, l3 = 0;\n    for (int i = 0; i < n; i++) {\n      wca[i] = readInt(2);\n      if (wca[i][0] == 1) {\n        l1++;\n      } else if (wca[i][0] == 2) {\n        l2++;\n      } else {\n        l3++;\n      }\n    }\n\n    Arrays.sort(wca, new Comparator<int []>() {\n      public int compare(int [] a, int [] b) {\n        return (b[1] - a[1]);\n      }\n    });\n\n    int [] c1 = new int [l1], c2 = new int [l2], c3 = new int [l3];\n    int i1 = 0, i2 = 0, i3 = 0;\n    for (int [] wc : wca) {\n      if (wc[0] == 1) {\n        c1[i1++] = wc[1];\n      } else if (wc[0] == 2) {\n        c2[i2++] = wc[1];\n      } else {\n        c3[i3++] = wc[1];\n      }\n    }\n\n    int mm = m;\n    i1 = i2 = i3 = 0;\n    while (true) {\n      int k1 = ((i1 < l1) && (mm >= 1)) ? c1[i1] : 0;\n      int k2 = ((i2 < l2) && (mm >= 2)) ? c2[i2] : 0;\n      int k3 = ((i3 < l3) && (mm >= 3)) ? c3[i3] : 0;\n\n      if ((k1 | k2 | k3) == 0) {\n        break;\n      } else if ((2.0 * k1 >= k2) && (3.0 * k1 >= k3)) {\n        i1++;\n        mm -= 1;\n      } else if ((k2 >= 2.0 * k1) && (3.0 * k2 >= 2.0 * k3)) {\n        i2++;\n        mm -= 2;\n      } else {\n        i3++;\n        mm -= 3;\n      }\n    }\n\n    long [] s1 = new long [l1 + 1], s2 = new long [l2 + 1], s3 = new long [l3 + 1];\n    for (int i = 0; i < l1; s1[i + 1] = c1[i] + s1[i], i++);\n    for (int i = 0; i < l2; s2[i + 1] = c2[i] + s2[i], i++);\n    for (int i = 0; i < l3; s3[i + 1] = c3[i] + s3[i], i++);\n\n    long s = 0;\n    for (int d1 = -DIST; d1 <= DIST; d1++) {\n      for (int d2 = -DIST; d2 <= DIST; d2++) {\n        for (int d3 = -DIST; d3 <= DIST; d3++) {\n          int j1 = i1 + d1, j2 = i2 + d2, j3 = i3 + d3;\n\n          if ((j1 >= 0) && (j2 >= 0) && (j3 >= 0) &&\n              (j1 <= l1) && (j2 <= l2) && (j3 <= l3) &&\n              ((j1 + 2 * j2 + 3 * j3) <= m)) {\n            s = Math.max(s, s1[j1] + s2[j2] + s3[j3]);\n          }\n        }\n      }\n    }\n\n    println(s);\n  }\n\n  public static void main(String... args) throws Exception {\n    br = new BufferedReader(new InputStreamReader(System.in));\n    pw = new PrintWriter(new BufferedOutputStream(System.out));\n    new P808E().run();\n    br.close();\n    pw.close();\n    System.err.println(\"\\n[Time : \" + (System.currentTimeMillis() - startTime) + \" ms]\");\n  }\n\n  static long startTime = System.currentTimeMillis();\n  static BufferedReader br;\n  static PrintWriter pw;\n  StringTokenizer stok;\n\n  String nextToken() throws IOException {\n    while (stok == null || !stok.hasMoreTokens()) {\n      String s = br.readLine();\n      if (s == null) { return null; }\n      stok = new StringTokenizer(s);\n    }\n    return stok.nextToken();\n  }\n\n  void print(byte b) { print(\"\" + b); }\n  void print(int i) { print(\"\" + i); }\n  void print(long l) { print(\"\" + l); }\n  void print(double d) { print(\"\" + d); }\n  void print(char c) { print(\"\" + c); }\n  void print(Object o) {\n    if (o instanceof int[]) { print(Arrays.toString((int [])o));\n    } else if (o instanceof long[]) { print(Arrays.toString((long [])o));\n    } else if (o instanceof char[]) { print(Arrays.toString((char [])o));\n    } else if (o instanceof byte[]) { print(Arrays.toString((byte [])o));\n    } else if (o instanceof short[]) { print(Arrays.toString((short [])o));\n    } else if (o instanceof boolean[]) { print(Arrays.toString((boolean [])o));\n    } else if (o instanceof float[]) { print(Arrays.toString((float [])o));\n    } else if (o instanceof double[]) { print(Arrays.toString((double [])o));\n    } else if (o instanceof Object[]) { print(Arrays.toString((Object [])o));\n    } else { print(\"\" + o); }\n  }\n  void print(String s) { pw.print(s); }\n  void println() { println(\"\"); }\n  void println(byte b) { println(\"\" + b); }\n  void println(int i) { println(\"\" + i); }\n  void println(long l) { println(\"\" + l); }\n  void println(double d) { println(\"\" + d); }\n  void println(char c) { println(\"\" + c); }\n  void println(Object o) { print(o); println(); }\n  void println(String s) { pw.println(s); }\n  int nextInt() throws IOException { return Integer.parseInt(nextToken()); }\n  long nextLong() throws IOException { return Long.parseLong(nextToken()); }\n  double nextDouble() throws IOException { return Double.parseDouble(nextToken()); }\n  char nextChar() throws IOException { return (char) (br.read()); }\n  String next() throws IOException { return nextToken(); }\n  String nextLine() throws IOException { return br.readLine(); }\n  int [] readInt(int size) throws IOException {\n    int [] array = new int [size];\n    for (int i = 0; i < size; i++) { array[i] = nextInt(); }\n    return array;\n  }\n  long [] readLong(int size) throws IOException {\n    long [] array = new long [size];\n    for (int i = 0; i < size; i++) { array[i] = nextLong(); }\n    return array;\n  }\n  double [] readDouble(int size) throws IOException {\n    double [] array = new double [size];\n    for (int i = 0; i < size; i++) { array[i] = nextDouble(); }\n    return array;\n  }\n  String [] readLines(int size) throws IOException {\n    String [] array = new String [size];\n    for (int i = 0; i < size; i++) { array[i] = nextLine(); }\n    return array;\n  }\n\n  int gcd(int a, int b) {\n    return ((b > 0) ? gcd(b, a % b) : a);\n  }\n  long gcd(long a, long b) {\n    return ((b > 0) ? gcd(b, a % b) : a);\n  }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef struct {\n  long long int cost, ones, twos;\n} s;\nint main() {\n  long long int n, m;\n  cin >> n >> m;\n  vector<long long int> ones;\n  vector<long long int> twos;\n  vector<long long int> threes;\n  for (long long int i = 0; i < n; i++) {\n    long long int a, b;\n    cin >> a >> b;\n    if (a == 1) ones.push_back(b);\n    if (a == 2) twos.push_back(b);\n    if (a == 3) threes.push_back(b);\n  }\n  sort(ones.begin(), ones.end());\n  sort(twos.begin(), twos.end());\n  sort(threes.begin(), threes.end());\n  vector<s> ss(m + 1);\n  ss[0] = {0, 0, 0};\n  if (ones.size() > 0) {\n    ss[1] = {ones.back(), 1, 0};\n  } else {\n    ss[1] = {0, 0, 0};\n  }\n  for (long long int i = 2; i <= m; i++) {\n    s a = {-1, 0, 0}, b = {-1, 0, 0}, c = ss[i - 1];\n    if (ss[i - 1].ones < ones.size()) {\n      a = {ss[i - 1].cost + ones[ones.size() - 1 - ss[i - 1].ones],\n           ss[i - 1].ones + 1, ss[i - 1].twos};\n    }\n    if (ss[i - 2].twos < twos.size()) {\n      b = {ss[i - 2].cost + twos[twos.size() - 1 - ss[i - 2].twos],\n           ss[i - 2].ones, ss[i - 2].twos + 1};\n    }\n    s d;\n    if (a.cost > b.cost)\n      d = a;\n    else\n      d = b;\n    if (d.cost > c.cost)\n      ss[i] = d;\n    else\n      ss[i] = c;\n  }\n  vector<long long int> part_threes(threes.size() + 1, 0);\n  for (long long int i = 1; i <= threes.size(); i++) {\n    part_threes[i] = part_threes[i - 1] + threes[threes.size() - i];\n  }\n  long long int best = 0;\n  for (long long int i = 0; i <= threes.size(); i++) {\n    long long int a;\n    if (3 * i > m)\n      a = -1;\n    else\n      a = part_threes[i] + ss[m - 3 * i].cost;\n    best = max(best, a);\n  }\n  cout << best << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int qq = 3e5 + 10;\nstruct Backpack {\n  long long val;\n  int m1, m2;\n} dp[qq];\nint num[4];\nlong long Val[4][qq];\nlong long pre[4][qq];\nint n, m;\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) {\n    int w;\n    long long val;\n    scanf(\"%d%lld\", &w, &val);\n    Val[w][++num[w]] = val;\n  }\n  for (int i = 1; i < 4; ++i) {\n    sort(Val[i] + 1, Val[i] + 1 + num[i], greater<long long>());\n    for (int j = 1; j <= num[i]; ++j) pre[i][j] = pre[i][j - 1] + Val[i][j];\n  }\n  dp[0].val = dp[0].m1 = dp[0].m2 = 0;\n  for (int i = 1; i <= m; ++i) {\n    dp[i] = dp[i - 1];\n    if (dp[i].val < dp[i - 1].val + Val[1][dp[i - 1].m1 + 1]) {\n      dp[i].val = dp[i - 1].val + Val[1][dp[i - 1].m1 + 1];\n      dp[i].m1 = dp[i - 1].m1 + 1;\n      dp[i].m2 = dp[i - 1].m2;\n    }\n    if (i >= 2 && dp[i].val < dp[i - 2].val + Val[2][dp[i - 2].m2 + 1]) {\n      dp[i].val = dp[i - 2].val + Val[2][dp[i - 2].m2 + 1];\n      dp[i].m1 = dp[i - 2].m1;\n      dp[i].m2 = dp[i - 2].m2 + 1;\n    }\n  }\n  long long ans = 0;\n  for (int i = 0; i <= num[3]; ++i) {\n    if (m >= i * 3) {\n      ans = max(ans, pre[3][i] + dp[m - 3 * i].val);\n    }\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long dp[300024];\nint k[300024][3];\nvector<int> v[3];\nint main() {\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    int w, c;\n    cin >> w >> c;\n    v[w - 1].push_back(c);\n  }\n  for (int i = 0; i < 3; i++) {\n    sort(v[i].begin(), v[i].end());\n    reverse(v[i].begin(), v[i].end());\n  }\n  if (v[0].size() > 0) {\n    dp[1] = v[0][0];\n    k[1][0]++;\n  }\n  long long t1 = 0, t2 = 0, t3 = 0;\n  dp[2] = dp[1];\n  k[2][0] = k[1][0];\n  k[2][1] = k[1][1];\n  k[2][2] = k[1][2];\n  if (v[0].size() > 1) t1 = v[0][0] + v[0][1];\n  if (v[1].size() > 0) t2 = v[1][0];\n  if (t1 > t2 && t1 > dp[2]) {\n    dp[2] = t1;\n    k[2][0] = 2;\n    k[2][1] = 0;\n    k[2][2] = 0;\n  } else if (t2 > dp[2]) {\n    dp[2] = t2;\n    k[2][0] = 0;\n    k[2][1] = 1;\n    k[2][2] = 0;\n  }\n  t1 = 0, t2 = 0, t3 = 0;\n  dp[3] = dp[2];\n  k[3][0] = k[2][0];\n  k[3][1] = k[2][1];\n  k[3][2] = k[2][2];\n  if (v[0].size() > 2) t1 = v[0][0] + v[0][1] + v[0][2];\n  if (v[1].size() > 0 && v[0].size() > 0) t2 = v[0][0] + v[1][0];\n  if (v[2].size() > 0) t3 = v[2][0];\n  if (t1 > t2 && t1 > t3 && t1 > dp[3]) {\n    dp[3] = t1;\n    k[3][0] = 3;\n    k[3][1] = 0;\n    k[3][2] = 0;\n  } else if (t2 > t3 && t2 > dp[3]) {\n    dp[3] = t2;\n    k[3][0] = 1;\n    k[3][1] = 1;\n    k[3][2] = 0;\n  } else if (t3 > dp[3]) {\n    dp[3] = t3;\n    k[3][0] = 0;\n    k[3][1] = 0;\n    k[3][2] = 1;\n  }\n  for (int i = 4; i <= m; i++) {\n    t1 = 0, t2 = 0, t3 = 0;\n    dp[i] = dp[i - 1];\n    k[i][0] = k[i - 1][0];\n    k[i][1] = k[i - 1][1];\n    k[i][2] = k[i - 1][2];\n    if (k[i - 3][2] < v[2].size()) t1 = dp[i - 3] + v[2][k[i - 3][2]];\n    if (k[i - 2][1] < v[1].size()) t2 = dp[i - 2] + v[1][k[i - 2][1]];\n    if (k[i - 1][0] < v[0].size()) t3 = dp[i - 1] + v[0][k[i - 1][0]];\n    long long t4 = 0, t5 = 0, t6 = 0;\n    if (k[i - 1][0] > 0 && k[i - 1][1] < v[1].size())\n      t4 = dp[i - 1] - v[0][k[i - 1][0] - 1] + v[1][k[i - 1][1]];\n    if (k[i - 1][1] > 0 && k[i - 1][2] < v[2].size())\n      t5 = dp[i - 1] - v[1][k[i - 1][1] - 1] + v[2][k[i - 1][2]];\n    if (k[i - 2][0] > 0 && k[i - 2][2] < v[2].size())\n      t6 = dp[i - 2] - v[0][k[i - 2][0] - 1] + v[2][k[i - 2][2]];\n    if (t1 > t2 && t1 > t3 && t1 > t4 && t1 > t5 && t1 > t6 && t1 > dp[i]) {\n      dp[i] = t1;\n      k[i][0] = k[i - 3][0];\n      k[i][1] = k[i - 3][1];\n      k[i][2] = k[i - 3][2] + 1;\n    } else if (t2 > t3 && t2 > t4 && t2 > t5 && t2 > t6 && t2 > dp[i]) {\n      dp[i] = t2;\n      k[i][0] = k[i - 2][0];\n      k[i][1] = k[i - 2][1] + 1;\n      k[i][2] = k[i - 2][2];\n    } else if (t3 > t4 && t3 > t5 && t3 > t6 && t3 > dp[i]) {\n      dp[i] = t3;\n      k[i][0] = k[i - 1][0] + 1;\n      k[i][1] = k[i - 1][1];\n      k[i][2] = k[i - 1][2];\n    } else if (t4 > t5 && t4 > t6 && t4 > dp[i]) {\n      dp[i] = t4;\n      k[i][0] = k[i - 1][0] - 1;\n      k[i][1] = k[i - 1][1] + 1;\n      k[i][2] = k[i - 1][2];\n    } else if (t5 > t6 && t5 > dp[i]) {\n      dp[i] = t5;\n      k[i][0] = k[i - 1][0];\n      k[i][1] = k[i - 1][1] - 1;\n      k[i][2] = k[i - 1][2] + 1;\n    } else if (t6 > dp[i]) {\n      dp[i] = t6;\n      k[i][0] = k[i - 2][0] - 1;\n      k[i][1] = k[i - 2][1];\n      k[i][2] = k[i - 2][2] + 1;\n    }\n  }\n  cout << dp[m] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nconstexpr int N = 1e5 + 5;\nvector<LL> sum[4];\nLL check(int two, int three, int rem) {\n  LL rv = 0;\n  if (two > 0) rv += sum[2][two - 1];\n  if (three > 0) rv += sum[3][three - 1];\n  int one = rem - two * 2 - three * 3;\n  assert(one >= 0);\n  one = min(one, (int)sum[1].size());\n  if (one > 0) rv += sum[1][one - 1];\n  return rv;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) {\n    int w, c;\n    cin >> w >> c;\n    sum[w].push_back(c);\n  }\n  for (int i = 1; i <= 3; i++) sort(sum[i].rbegin(), sum[i].rend());\n  for (int i = 1; i <= 3; i++) {\n    for (int j = 1; j < sum[i].size(); j++) {\n      sum[i][j] += sum[i][j - 1];\n    }\n  }\n  LL best = 0;\n  for (int three = 0; three <= sum[3].size(); three++) {\n    if (three * 3 > m) break;\n    int cnt1 = min((int)sum[2].size(), (m - three * 3) / 2);\n    int two = -1;\n    for (int b = cnt1; b >= 1; b /= 2) {\n      while (two + b + 1 <= cnt1 &&\n             check(two + b, three, m) < check(two + b + 1, three, m)) {\n        two += b;\n      }\n    }\n    LL cur = check(two + 1, three, m);\n    best = max(best, cur);\n  }\n  cout << best << \"\\n\";\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.math.*;\nimport java.io.*;\nimport java.text.*;\n\npublic class A{\n\n//public static PrintWriter pw; \npublic static PrintWriter pw=new PrintWriter(System.out);\npublic static void solve() throws IOException{\n//\tpw=new PrintWriter(new FileWriter(\"C:\\\\Users\\\\shree\\\\Downloads\\\\small_output_in\"));\n\tFastReader sc=new FastReader();\n\tint n=sc.I();\n\tint m=sc.I();\n\tlong v1[]=new long[300001];\n\tlong v2[]=new long[300001];\n\tlong v3[]=new long[300001];\n\tint c1=0,c2=0,c3=0;\n\tfor(int i=0;i<n;i++) {\n\t\tint w=sc.I();\n\t\tif(w==1) v1[c1++]=sc.L();\n\t\tif(w==2) v2[c2++]=sc.L();\n\t\tif(w==3) v3[c3++]=sc.L();\n\t}\n\tArrays.sort(v1, 0, c1);\n\tArrays.sort(v2,0,c2);\n\tArrays.sort(v3,0,c3);\n\tv1=reverse(v1,c1);\n\tv2=reverse(v2,c2);\n\tv3=reverse(v3,c3);\n\tlong cost=0;\n\tlong dp[]=new long[m+1];\n\tint n1=0,n2=0;\n\tlong ans=0;\n\tfor(int i=1;i<=m;i++) {\n\t\tcost+=v1[n1++];\n\t\tif(n1>=2 && v2[n2]>=v1[n1-1]+v1[n1-2]) {\n\t\t\t\n\t\t\tcost-=(v1[n1-1]+v1[n1-2]);\n\t\t\tcost+=v2[n2++];\n\t\t\tn1-=2;\n\t\t}\n\t\tdp[i]=Math.max(dp[i-1], cost);\n\t\tans=Math.max(ans,dp[i]);\n\t}\n\t\n\t\n\tlong sum[]=new long[c3];\n\tfor(int i=0;i<c3;i++) {\n\t\tif(i==0)sum[i]=v3[i];\n\t\telse sum[i]=sum[i-1]+v3[i];\n\t}\n\t\n\tfor(int i=0;i<c3 && m-3*i-3>=0;i++) {\n\t\tans=Math.max(ans,dp[m-3*(i+1)]+sum[i]);\n\t}\n\t\n\tpw.println(ans);\n\tpw.close(); \n\t\n\t\n}\nstatic long [] reverse(long a[],int n) {\n\tint i=0,j=n-1;\n\twhile(i<j) {\n\t\tlong d=a[i];\n\t\ta[i]=a[j];\n\t\ta[j]=d;\n\t\ti++;\n\t\tj--;\n\t}\n\treturn a;\n}\npublic static void main(String[] args)  {\n    new Thread(null ,new Runnable(){\n      public void run(){\n          try{\n          \n              solve();\n          } catch(Exception e){\n              e.printStackTrace();\n          }\n      }\n  },\"1\",1<<26).start();\n \n}\n\nstatic long M=(long)Math.pow(10,9)+7;\n \n\tstatic class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastReader() throws FileNotFoundException{\n            //br=new BufferedReader(new FileReader(\"C:\\\\Users\\\\shree\\\\Downloads\\\\B-small-practice.in\"));\t\n        \t br = new BufferedReader(new InputStreamReader(System.in));\n        \t\t\n        }\n \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n       \n        int I(){   return Integer.parseInt(next()); }\n        long L(){  return Long.parseLong(next()); }\n        double D() {  return Double.parseDouble(next()); }\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n     }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 300000 + 10;\nconst int INF = 0x7fffffff;\nstruct {\n  long long v;\n  long long s1, s2;\n} dp[MAXN];\nlong long a[4][MAXN];\nlong long s[4][MAXN];\nint num[4];\nint cmp(int x, int y) { return x > y; }\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  num[1] = num[2] = num[3] = 0;\n  for (int i = 1; i <= n; i++) {\n    long long w, c;\n    scanf(\"%lld%lld\", &w, &c);\n    a[w][++num[w]] = c;\n  }\n  for (int i = 1; i <= 3; i++) {\n    sort(a[i] + 1, a[i] + num[i] + 1, cmp);\n    for (int j = 1; j <= num[i]; j++) {\n      s[i][j] = s[i][j - 1] + a[i][j];\n    }\n  }\n  dp[0].v = dp[0].s1 = dp[0].s2 = 0;\n  for (int i = 1; i <= m; i++) {\n    dp[i] = dp[i - 1];\n    if (dp[i - 1].v + a[1][dp[i - 1].s1 + 1] > dp[i].v) {\n      dp[i].v = dp[i - 1].v + a[1][dp[i - 1].s1 + 1];\n      dp[i].s1 = dp[i - 1].s1 + 1;\n      dp[i].s2 = dp[i - 1].s2;\n    }\n    if (i >= 2 && dp[i - 2].v + a[2][dp[i - 2].s2 + 1] > dp[i].v) {\n      dp[i].v = dp[i - 2].v + a[2][dp[i - 2].s2 + 1];\n      dp[i].s1 = dp[i - 2].s1;\n      dp[i].s2 = dp[i - 2].s2 + 1;\n    }\n  }\n  long long res = 0;\n  for (int i = 0; i <= num[3]; i++) {\n    if (m >= i * 3) res = max(res, s[3][i] + dp[m - 3 * i].v);\n  }\n  printf(\"%I64d\\n\", res);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long n, m;\nstruct nod {\n  long long val, pt1, pt2;\n} dp[300005];\nifstream in(\"selling.in\");\nvector<long long> unu, doi, trei;\nnod Max(nod a, nod b) { return a.val < b.val ? b : a; }\nint main() {\n  long long i, j, w, v, last1, last2, var1, var2;\n  cin >> n >> m;\n  for (i = 1; i <= n; i++) {\n    cin >> w >> v;\n    if (w == 1) unu.push_back(v);\n    if (w == 2) doi.push_back(v);\n    if (w == 3) trei.push_back(v);\n  }\n  sort(unu.begin(), unu.end());\n  sort(doi.begin(), doi.end());\n  sort(trei.begin(), trei.end());\n  for (i = 1; i <= m; i++) {\n    if (int(unu.size()) - dp[i - 1].pt1 - 1 >= 0)\n      var1 = dp[i - 1].val + unu[int(unu.size()) - 1 - dp[i - 1].pt1];\n    else\n      var1 = 0;\n    if (i >= 2 && int(doi.size()) - dp[i - 2].pt2 - 1 >= 0)\n      var2 = dp[i - 2].val + doi[int(doi.size()) - 1 - dp[i - 2].pt2];\n    else\n      var2 = 0;\n    if (var1 > var2) {\n      if (var1 > dp[i].val) {\n        dp[i].val = var1;\n        dp[i].pt1 = dp[i - 1].pt1 + 1;\n        dp[i].pt2 = dp[i - 1].pt2;\n      }\n    } else {\n      if (var2 > dp[i].val) {\n        dp[i].val = var2;\n        dp[i].pt1 = dp[i - 2].pt1;\n        dp[i].pt2 = dp[i - 2].pt2 + 1;\n      }\n    }\n  }\n  for (i = 1; i <= m; i++) dp[i] = Max(dp[i - 1], dp[i]);\n  long long sol = 0, sum = 0, l = trei.size();\n  for (i = 0; 3 * i <= m; i++) {\n    sol = max(sol, dp[m - 3 * i].val + sum);\n    if (trei.empty()) break;\n    sum += trei.back(), trei.pop_back();\n  }\n  cout << sol << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int> > v(3);\nlong long s[3][100005];\nint m;\nlong long f1(int y, int z) {\n  if (m - 3 * z - 2 * y < 0) {\n    return 0;\n  }\n  long long val = 0;\n  if (z > 0) val += s[2][z - 1];\n  if (y > 0) val = val + s[1][y - 1];\n  if (m - 3 * z - 2 * y > 0) {\n    val += s[0][min(m - 3 * z - 2 * y - 1, (int)v[0].size() - 1)];\n  }\n  return val;\n}\nlong long compute(int z) {\n  int m1 = m;\n  long long ans = -100;\n  m1 -= z * 3;\n  if (m1 < 0) {\n    return 0;\n  }\n  int l = 0;\n  int r = min((int)v[1].size(), m1 / 2);\n  while (r - l >= 3) {\n    int mid1 = (2 * l + r) / 3;\n    int mid2 = (2 * r + l) / 3;\n    if (f1(mid1, z) > f1(mid2, z)) {\n      r = mid2;\n    } else {\n      l = mid1;\n    }\n  }\n  while (l <= r) {\n    ans = max(ans, f1(l, z));\n    l++;\n  }\n  return ans;\n}\nint main() {\n  std::ios::sync_with_stdio(false);\n  int n, w, c, i, j;\n  long long res = -100;\n  cin >> n >> m;\n  for (i = 0; i < n; i++) {\n    cin >> w >> c;\n    w--;\n    v[w].push_back(c);\n  }\n  for (i = 0; i < 3; i++) sort(v[i].rbegin(), v[i].rend());\n  for (i = 0; i < 3; i++) {\n    for (j = 0; j < v[i].size(); j++) {\n      s[i][j] = j > 0 ? s[i][j - 1] + v[i][j] : v[i][j];\n    }\n  }\n  for (i = 0; i <= v[2].size(); i++) {\n    res = max(res, compute(i));\n  }\n  cout << res << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long inf = 1e18;\nconst int mod = 1e9 + 7;\nlong long kek[100005], w[100005], dp[1337228], c[100005], nm[100005];\nbool kekekekekekkek(int i, int j) { return kek[i] > kek[j]; }\nint main() {\n  ios_base::sync_with_stdio(0);\n  int n, m;\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    cin >> w[i] >> c[i];\n    kek[i] = 1337 * c[i] / w[i];\n    nm[i] = i;\n  }\n  sort(nm + 1, nm + n + 1, kekekekekekkek);\n  int cur = 0;\n  for (int i = 1; i <= n; i++) {\n    int curw = w[nm[i]], curc = c[nm[i]];\n    cur += curw;\n    for (int j = cur; j >= max(curw, cur - 228); j--) {\n      dp[j] = max(dp[j], dp[j - curw] + curc);\n    }\n  }\n  for (int i = 1; i <= m; i++) {\n    dp[i] = max(dp[i], dp[i - 1]);\n  }\n  cout << dp[m] << endl;\n}\n"
        },
        {
            "language": 4,
            "solution": "//package ECR21;\nimport java.util.*;\n/**\n * not solved!\n * @author AcerS\n *\n */\npublic class E21 {\n    static ArrayList<Long> one;\n    static ArrayList<Long> two;\n    static ArrayList<Long> three;\n    static int m;\n    static long dCost[];\n    static int d_cnt1[];\n    static int d_cnt2[];\n    static int d_cnt3[];\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        m = sc.nextInt();\n        one = new ArrayList<>(n);\n        two = new ArrayList<>(n);\n        three = new ArrayList<>(n);\n        dCost = new long[m + 1];\n        d_cnt1 = new int[m + 1];\n        d_cnt2 = new int[m + 1];\n        d_cnt3 = new int[m + 1];\n        int w;\n        for(int i = 0; i < n; ++i) {\n            w = sc.nextInt();\n            switch(w) {\n            case 1:\n                one.add(sc.nextLong());\n                break;\n            case 2:\n                two.add(sc.nextLong());\n                break;\n            case 3:\n                three.add(sc.nextLong());\n                break;\n            }\n        }\n        Collections.sort(one, Collections.reverseOrder());\n        Collections.sort(two, Collections.reverseOrder());\n        Collections.sort(three, Collections.reverseOrder());\n//        \n//        for(int i = 0; i < m; ++i) {\n//            if(d_cnt1[i] < one.size() && dCost[i] + one.get(d_cnt1[i]) > dCost[i + 1]) {\n//                dCost[i + 1] = dCost[i] + one.get(d_cnt1[i]);\n//                d_cnt1[i + 1] = d_cnt1[i] + 1;\n//                d_cnt2[i + 1] = d_cnt2[i];\n//                d_cnt3[i + 1] = d_cnt3[i];\n//            }\n//            if(d_cnt2[i] < two.size() && i < m - 1 \n//                    && dCost[i] + two.get(d_cnt2[i]) > dCost[i + 2]) {\n//                dCost[i + 2] = dCost[i] + two.get(d_cnt2[i]);\n//                d_cnt1[i + 2] = d_cnt1[i];\n//                d_cnt2[i + 2] = d_cnt2[i] + 1;\n//                d_cnt3[i + 2] = d_cnt3[i];\n//            }\n//            if(d_cnt3[i] < three.size() && i < m - 2 \n//                    && dCost[i] + three.get(d_cnt3[i]) > dCost[i + 3]) {\n//                dCost[i + 3] = dCost[i] + three.get(d_cnt3[i]);\n//                d_cnt1[i + 3] = d_cnt1[i];\n//                d_cnt2[i + 3] = d_cnt2[i];\n//                d_cnt3[i + 3] = d_cnt3[i] + 1;\n//            }\n//            if(dCost[i + 1] < dCost[i]) {\n//                dCost[i + 1] = dCost[i];\n//                d_cnt1[i + 1] = d_cnt1[i];\n//                d_cnt2[i + 1] = d_cnt2[i];\n//                d_cnt3[i + 1] = d_cnt3[i];\n//            }\n//        }        \n//        System.out.println(dCost[m]); \n        \n        \n        \n\n        for(int i = 0; i < m; ++i) {\n            if(d_cnt1[i] < one.size() && dCost[i] + one.get(d_cnt1[i]) > dCost[i + 1]) {\n                dCost[i + 1] = dCost[i] + one.get(d_cnt1[i]);\n                d_cnt1[i + 1] = d_cnt1[i] + 1;\n                d_cnt2[i + 1] = d_cnt2[i];\n            }\n            if(d_cnt2[i] < two.size() && i < m - 1 \n                    && dCost[i] + two.get(d_cnt2[i]) > dCost[i + 2]) {\n                dCost[i + 2] = dCost[i] + two.get(d_cnt2[i]);\n                d_cnt1[i + 2] = d_cnt1[i];\n                d_cnt2[i + 2] = d_cnt2[i] + 1;\n            }\n            if(dCost[i + 1] < dCost[i]) {\n                dCost[i + 1] = dCost[i];\n                d_cnt1[i + 1] = d_cnt1[i];\n                d_cnt2[i + 1] = d_cnt2[i];\n                d_cnt3[i + 1] = d_cnt3[i];\n            }\n        }        \n        long ans = dCost[m];\n        long cost = 0;\n        for(int i = 1; i <= three.size() && m >= 3; ++i) {\n            cost += three.get(i - 1);\n            m -= 3;\n            ans = Long.max(ans, cost + dCost[m]);\n        }\n        System.out.println(ans);\n    }\n    \n}\n"
        },
        {
            "language": 3,
            "solution": "#!/usr/bin/env python3\n\n[n, m] = map(int, input().strip().split())\nwc = [[] for _ in range(4)]  # w[0] unused\nfor _ in range(n):\n\tw, c = map(int, input().strip().split())\n\twc[w].append(c)\n\nfor i in range(1, 4):\n\twc[i].sort(reverse=True)\n\niwc = [[0 for _ in range(len(wc[i]) + 1)] for i in range(4)]\n\nfor i in range(4):\n\tfor j in range(len(wc[i])):\n\t\tiwc[i][j + 1] = iwc[i][j] + wc[i][j]\n\nn1 = len(wc[1])\nn2 = len(wc[2])\nn3 = len(wc[3])\n\nc12 = [(0, 0, 0) for _ in range(m + 1)]\nfor w in range(len(c12) - 1):\n\tc, q1, q2 = c12[w]\n\tc12[w + 1] = max(c12[w + 1], c12[w])\n\tif q1 < n1:\n\t\tc12[w + 1] = max(c12[w + 1], (iwc[1][q1 + 1] + iwc[2][q2], q1 + 1, q2))\t\t\n\tif q2 < n2 and w + 2 < len(c12):\n\t\tc12[w + 2] = max(c12[w + 2], (iwc[1][q1] + iwc[2][q2 + 1], q1, q2 + 1))\n\n\ncmax = 0\nfor i in range(n3 + 1):\n\tif 3 * i > m:\n\t\tbreak\n\tcmax = max(cmax, iwc[3][i] + c12[m - 3 * i][0])\n\nprint(cmax)\n\n"
        },
        {
            "language": 1,
            "solution": "import math\n\nn,m=map(int, raw_input().split())\nw=[[],[],[],[]]\n\nfor i in range(0,n):\n\tx,y=map(int, raw_input().split())\n\tw[x].append(y)\n\n\nfor i in range(1,4):\n\tw[i].sort(reverse=True)\n\nd=[]\nfor i in range(0,m+1):\n\td.append([0,0,0])\n\nfor i in range(0,m):\n\t#no add\n\tif (d[i+1][0]<d[i][0]):\n\t\td[i+1]=[d[i][0], d[i][1], d[i][2]]\n\n\t#add w1\n\tif (len(w[1])>d[i][1]):\n\t\tif (d[i+1][0]<w[1][d[i][1]]+d[i][0]):\n\t\t\td[i+1]=[w[1][d[i][1]]+d[i][0], d[i][1]+1, d[i][2]]\n\t#add w2\n\tif (i<m-1 and len(w[2])>d[i][2] ):\n\t\tif (d[i+2][0]<w[2][d[i][2]]+d[i][0]):\n\t\t\td[i+2]=[w[2][d[i][2]]+d[i][0], d[i][1],d[i][2]+1]\n\n\nv=0\nt=d[m][0]\nfor i in range(1, len(w[3])+1):\n\tif (i*3>m):\n\t\tbreak\n\tv+=w[3][i-1]\n\tt=max(t,v+d[m-3*i][0])\n\nprint t\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class ER21qE\n{\n\n  public static void main(String[] args) {\n    InputReader in = new InputReader(System.in);\n    PrintWriter w = new PrintWriter(System.out);\n\n    int n = in.nextInt();\n    int m = in.nextInt();\n    \n    @SuppressWarnings(\"unchecked\")\n\tArrayList<Integer> c[] = new ArrayList[4];\n    for (int i = 1; i <= 3; i++)\n    \tc[i] = new ArrayList<Integer>();\n    \n    for (int i = 0; i < n; i++)\n    \tc[in.nextInt()].add(in.nextInt());\n    \n    for (int i = 1; i <= 3; i++) {\n    \twhile (c[i].size() < m + 3)\n    \t\tc[i].add(0);\n    }\n    \n    for (int i = 1; i <= 3; i++)\n    \tCollections.sort(c[i], Collections.reverseOrder());\n    \n    long dp[] = new long[m + 1];\n    int _2 = 0, _1 = 0;\n    \n    for (int i = 2; i <= m; i += 2) {\n    \tif (c[2].get(_2) >= c[1].get(_1) + c[1].get(_1 + 1)) {\n    \t\tdp[i] = dp[i - 2] + c[2].get(_2);\n    \t\t_2++;\n    \t} else {\n    \t\tdp[i] = dp[i - 2] + c[1].get(_1) + c[1].get(_1 + 1);\n    \t\t_1 += 2;\n    \t}\n    }\n    \n    dp[1] = c[1].get(0);\n    _2 = 0;\n    _1 = 1;\n    \n    for (int i = 3; i <= m; i += 2) {\n    \tif (c[2].get(_2) >= c[1].get(_1) + c[1].get(_1 + 1)) {\n    \t\tdp[i] = dp[i - 2] + c[2].get(_2);\n    \t\t_2++;\n    \t} else {\n    \t\tdp[i] = dp[i - 2] + c[1].get(_1) + c[1].get(_1 + 1);\n    \t\t_1 += 2;\n    \t}\n    }\n    \n    long tot = 0, ans = 0;\n    for (int i = 0; i <= c[3].size() && 3*i <= m; i++) {\n    \tans = Math.max(ans, tot + dp[m - 3 * i]);\n    \tif (i < c[3].size())\n    \t\ttot += c[3].get(i);\n    }\n    \n    w.println(ans);\n    w.close();\n  }\n\n  static class InputReader {\n\n    private final InputStream stream;\n    private final byte[] buf = new byte[8192];\n    private int curChar, snumChars;\n\n    public InputReader(InputStream st) {\n      this.stream = st;\n    }\n\n    public int read() {\n      if (snumChars == -1)\n        throw new InputMismatchException();\n      if (curChar >= snumChars) {\n        curChar = 0;\n        try {\n          snumChars = stream.read(buf);\n        } catch (IOException e) {\n          throw new InputMismatchException();\n        }\n        if (snumChars <= 0)\n          return -1;\n      }\n      return buf[curChar++];\n    }\n\n    public int nextInt() {\n      int c = read();\n      while (isSpaceChar(c)) {\n        c = read();\n      }\n      int sgn = 1;\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      int res = 0;\n      do {\n        res *= 10;\n        res += c - '0';\n        c = read();\n      } while (!isSpaceChar(c));\n      return res * sgn;\n    }\n\n    public long nextLong() {\n      int c = read();\n      while (isSpaceChar(c)) {\n        c = read();\n      }\n      int sgn = 1;\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      long res = 0;\n      do {\n        res *= 10;\n        res += c - '0';\n        c = read();\n      } while (!isSpaceChar(c));\n      return res * sgn;\n    }\n\n    public int[] nextIntArray(int n) {\n      int a[] = new int[n];\n      for (int i = 0; i < n; i++) {\n        a[i] = nextInt();\n      }\n      return a;\n    }\n\n    public String readString() {\n      int c = read();\n      while (isSpaceChar(c)) {\n        c = read();\n      }\n      StringBuilder res = new StringBuilder();\n      do {\n        res.appendCodePoint(c);\n        c = read();\n      } while (!isSpaceChar(c));\n      return res.toString();\n    }\n\n    public String nextLine() {\n      int c = read();\n      while (isSpaceChar(c))\n        c = read();\n      StringBuilder res = new StringBuilder();\n      do {\n        res.appendCodePoint(c);\n        c = read();\n      } while (!isEndOfLine(c));\n      return res.toString();\n    }\n\n    public boolean isSpaceChar(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    private boolean isEndOfLine(int c) {\n      return c == '\\n' || c == '\\r' || c == -1;\n    }\n\n  }\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\npublic class E {\n\tpublic static void main(String[] args)throws Throwable {\n\t\tMyScanner sc=new MyScanner();\n\t\tPrintWriter pw=new PrintWriter(System.out);\n\t\t\n\t\tint n=sc.nextInt();\n\t\tint m=sc.nextInt();\n\t\t\n\t\tArrayList<Integer> a1=new ArrayList<Integer>();\n\t\tArrayList<Integer> a2=new ArrayList<Integer>();\n\t\tArrayList<Integer> a3=new ArrayList<Integer>();\n\t\twhile(n-->0){\n\t\t\tswitch(sc.nextInt()){\n\t\t\tcase 1 : {\n\t\t\t\ta1.add(sc.nextInt());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 2 : {\n\t\t\t\ta2.add(sc.nextInt());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 3 : {\n\t\t\t\ta3.add(sc.nextInt());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\tCollections.sort(a1,Collections.reverseOrder());\n\t\tCollections.sort(a2,Collections.reverseOrder());\n\t\tCollections.sort(a3,Collections.reverseOrder());\n\t\t\n\t\tint max=(int)(3e5+1);\n\t\tpair [] dp=new pair [max];\n\t\tdp[0]=new pair(0, 0, 0);\n\t\tfor(int i=1;i<max;i++){\n\t\t\tdp[i]=new pair(0,0,0);\n\t\t\tpair p1=dp[i-1];\n\t\t\tdp[i]=dp[i-1];\n\t\t\tif(p1.x<a1.size())\n\t\t\t\tdp[i]=new pair(p1.x+1, p1.y, p1.c+a1.get(p1.x));\n\t\t\tif(i>1){\n\t\t\t\tpair p2=dp[i-2];\n\t\t\t\tif(p2.y<a2.size() && p2.c+a2.get(p2.y)>dp[i].c)\n\t\t\t\t\tdp[i]=new pair(p2.x, p2.y+1, p2.c+a2.get(p2.y));\n\t\t\t}\n\t\t}\n\t\tlong ans=dp[(int)m].c;\n\t\tlong sum=0;\n\t\tfor(int i=0;i<a3.size();i++){\n\t\t\tsum+=a3.get(i);\n\t\t\tif(m-(i+1)*3>=0)\n\t\t\t\tans=Math.max(ans, sum+dp[m-(i+1)*3].c);\n\t\t}\n\t\tpw.println(ans);\n\t\tpw.flush();\n\t\tpw.close();\n\t}\n\t\n\tstatic class pair{\n\t\tint x,y;\n\t\tlong c;\n\t\tpair(int a,int b,long c){\n\t\t\tx=a;\n\t\t\ty=b;\n\t\t\tthis.c=c;\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn x+\" \"+y+\" \"+c;\n\t\t}\n\t}\n\t\n\tstatic class MyScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tpublic MyScanner() {br = new BufferedReader(new InputStreamReader(System.in));}\n\t\tString next() {while (st == null || !st.hasMoreElements()) {\n\t\t\ttry {st = new StringTokenizer(br.readLine());}\n\t\t\tcatch (IOException e) {e.printStackTrace();}}\n\t\treturn st.nextToken();}\n\t\tint nextInt() {return Integer.parseInt(next());}\n\t\tlong nextLong() {return Long.parseLong(next());}\n\t\tdouble nextDouble() {return Double.parseDouble(next());}\n\t\tString nextLine(){String str = \"\";\n\t\ttry {str = br.readLine();}\n\t\tcatch (IOException e) {e.printStackTrace();}\n\t\treturn str;}\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Data {\n  long long cost, ones, twos;\n};\nconst long long N = 100100;\nconst long long K = 300300;\nlong long n, m;\nData dp[K];\nvector<long long> adj[4];\nint32_t main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  for (long long i = 1; i <= n; i++) {\n    long long w, c;\n    cin >> w >> c;\n    adj[w].push_back(c);\n  }\n  for (long long i = 1; i <= 3; i++) {\n    sort(adj[i].begin(), adj[i].end());\n    reverse(adj[i].begin(), adj[i].end());\n  }\n  dp[0] = {0, 0, 0};\n  for (long long i = 1; i <= m; i++) {\n    dp[i] = dp[i - 1];\n    if (i - 2 >= 0 && dp[i - 2].cost > dp[i].cost) {\n      dp[i] = dp[i - 2];\n    }\n    long long ones = dp[i].ones, twos = dp[i].twos;\n    if (dp[i - 1].ones < adj[1].size()) {\n      if (dp[i - 1].cost + adj[1][dp[i - 1].ones] > dp[i].cost) {\n        dp[i].cost = dp[i - 1].cost + adj[1][dp[i - 1].ones];\n        ones = 1 + dp[i - 1].ones;\n        twos = dp[i - 1].twos;\n      }\n    }\n    if (i - 2 >= 0 && dp[i - 2].twos < adj[2].size()) {\n      if (dp[i - 2].cost + adj[2][dp[i - 2].twos] > dp[i].cost) {\n        dp[i].cost = dp[i - 2].cost + adj[2][dp[i - 2].twos];\n        ones = dp[i - 2].ones;\n        twos = 1 + dp[i - 2].twos;\n      }\n    }\n    dp[i].ones = ones;\n    dp[i].twos = twos;\n  }\n  long long ans = dp[m].cost;\n  long long sm = 0;\n  for (long long i = 0; i < adj[3].size(); i++) {\n    sm += adj[3][i];\n    if (m - 3 * (i + 1) < 0) continue;\n    ans = max(ans, sm + dp[m - 3 * (i + 1)].cost);\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class SellingSouvenirs {\n\tclass range {\n\t\tint index, low, high;\n\t\tpublic range(int index, int low, int high) {\n\t\t\tthis.index = index;\n\t\t\tthis.low = low;\n\t\t\tthis.high = high;\n\t\t}\n\t}\n\tint f(int lowI, int curI, int skip, List<Long> vals) {\n\t\tint rep = vals.size();\n\t\tint extra = (curI-lowI)/skip;\n\t\tif (dp[lowI] + vals.get(extra) <= dp[curI]+vals.get(0)) \n\t\t\treturn curI;\n\t\tif (dp[lowI] + vals.get(rep-1) > dp[curI] + vals.get(rep-1-extra)) \n\t\t\treturn lowI+rep*skip;\n\t\tint low = extra+1, high = rep-1;\n\t\twhile (low < high) {\n\t\t\tint mid = (low+high)/2+1;\n\t\t\tif (dp[lowI] + vals.get(mid-1) > dp[curI] + vals.get(mid-1-extra))\n\t\t\t\tlow = mid;\n\t\t\telse\n\t\t\t\thigh = mid-1;\n\t\t}\n\t\treturn lowI + skip*low;\n\t}\n\tint n, maxWeight;\n\tlong[] dp;\n\tpublic SellingSouvenirs(FastScanner scan, PrintWriter out) {\n\t\tn = scan.nextInt(); maxWeight = scan.nextInt();\n\t\tList[] souvenirs = new ArrayList[301];\n\t\tfor (int i = 0 ; i < souvenirs.length ; i++)\n\t\t\tsouvenirs[i] = new ArrayList<>();\n\t\tfor (int i = 0 ; i < n ; i++)\n\t\t\tsouvenirs[scan.nextInt()].add(scan.nextLong());\n\t\tfor (int i = 0 ; i < souvenirs.length ; i++) {\n\t\t\tCollections.sort(souvenirs[i]);\n\t\t\tCollections.reverse(souvenirs[i]);\n\t\t}\n\t\tfor (int i = 0 ; i < souvenirs.length ; i++)\n\t\t\tfor (int j = 1 ; j < souvenirs[i].size() ; j++)\n\t\t\t\tsouvenirs[i].set(j, ((ArrayList<Long>)souvenirs[i]).get(j-1)+((ArrayList<Long>)souvenirs[i]).get(j));\n\t\tdp = new long[maxWeight+1];\n\t\tfor (int i = 1 ; i < souvenirs.length ; i++) {\n\t\t\tif (souvenirs[i].size() == 0) continue;\n\t\t\tfor (int j = maxWeight ; j >= i && j > maxWeight-i ; j--) {\n\t\t\t\tint rep = souvenirs[i].size();\n\t\t\t\tDeque<range> q = new ArrayDeque<range>();\n\t\t\t\tfor (int z = j-i, cnt=0 ; cnt < rep && z >= 0 ; z-=i, cnt++) {\n\t\t\t\t\tint maxBeat = z+i;\n\t\t\t\t\twhile (q.size() > 0) {\n\t\t\t\t\t\trange cur = q.peekLast();\n\t\t\t\t\t\tmaxBeat = f(z, cur.index, i, souvenirs[i]);\n\t\t\t\t\t\tmaxBeat = Math.min(maxBeat, j);\n\t\t\t\t\t\tif (maxBeat < cur.high) \n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tq.pollLast();\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif (q.size() > 0) \n\t\t\t\t\t\tq.peekLast().low = maxBeat+i;\n\t\t\t\t\tq.offerLast(new range(z, z+i, maxBeat));\n\t\t\t\t}\n\t\t\t\trange front = q.peekFirst();\n\t\t\t\tint bestI = front.index;\n\t\t\t\tdp[j] = Math.max(dp[j], dp[bestI] + ((ArrayList<Long>)souvenirs[i]).get((j-bestI)/i-1));\n\t\t\t\tif (front.low == j) q.pop();\n\t\t\t\tfor (int z = j-i ; z >= i ; z-=i) {\n\t\t\t\t\tif (z - rep*i >= 0) {\n\t\t\t\t\t\tint maxBeat = z - rep*i + i;\n\t\t\t\t\t\twhile (q.size() > 0) {\n\t\t\t\t\t\t\trange cur = q.peekLast();\n\t\t\t\t\t\t\tmaxBeat = f(z-rep*i, cur.index, i, (ArrayList<Long>)souvenirs[i]);\n\t\t\t\t\t\t\tmaxBeat = Math.min(maxBeat, j);\n\t\t\t\t\t\t\tif (maxBeat < cur.high) \n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\tq.pollLast();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (q.size() > 0) {\n\t\t\t\t\t\t\tq.peekLast().low = maxBeat+i;\n\t\t\t\t\t\t\tif (maxBeat+i > z) \n\t\t\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.offerLast(new range(z-rep*i, z-rep*i+i, maxBeat));\n\t\t\t\t\t}\n\t\t\t\t\tfront = q.peekFirst();\n\t\t\t\t\tbestI = front.index;\n\t\t\t\t\tdp[z] = Math.max(dp[z], dp[bestI] + ((ArrayList<Long>)souvenirs[i]).get((z-bestI)/i-1));\n\t\t\t\t\tif (front.low >= z) \n\t\t\t\t\t\tq.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(dp[maxWeight]);\n\t}\n\tpublic static void main(String[] args) throws Exception {\n\t\tFastScanner scan = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tnew SellingSouvenirs(scan, out);\n\t\tout.close();\n\t}\n\tstatic class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tpublic FastScanner() {\n\t\t\ttry\t{\n\t\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e){e.printStackTrace();}\n\t\t}\n\t\tpublic String next() {\n\t\t\tif (st.hasMoreTokens())\treturn st.nextToken();\n\t\t\ttry {st = new StringTokenizer(br.readLine());}\n\t\t\tcatch (Exception e) {e.printStackTrace();}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tpublic int nextInt() {return Integer.parseInt(next());}\n\t\tpublic long nextLong() {return Long.parseLong(next());}\n\t\tpublic double nextDouble() {return Double.parseDouble(next());}\n\t\tpublic String nextLine() {\n\t\t\tString line = \"\";\n\t\t\tif(st.hasMoreTokens()) line = st.nextToken();\n\t\t\telse try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n\t\t\twhile(st.hasMoreTokens()) line += \" \"+st.nextToken();\n\t\t\treturn line;\n\t\t}\n\t}\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 300010;\nint n, m;\nint arr[4][N];\nint idx[4];\nlong long best[N], ans = 0;\npair<int, int> best2[N];\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; i++) {\n    int w, c;\n    scanf(\"%d%d\", &w, &c);\n    arr[w][idx[w]++] = c;\n  }\n  for (int i = 0; i < 4; i++) {\n    sort(arr[i], arr[i] + idx[i]);\n    reverse(arr[i], arr[i] + idx[i]);\n  }\n  best[1] = arr[1][0];\n  ans = max(ans, best[1]);\n  best2[1] = make_pair(0, -1);\n  best2[0] = make_pair(-1, -1);\n  for (int i = 2; i <= m; i++) {\n    best[i] = best[i - 1] + arr[1][best2[i - 1].first + 1];\n    best2[i] = best2[i - 1];\n    best2[i].first++;\n    if (best[i - 2] + arr[2][best2[i - 2].second + 1] > best[i]) {\n      best[i] = best[i - 2] + arr[2][best2[i - 2].second + 1];\n      best2[i] = best2[i - 2];\n      best2[i].second++;\n    }\n    ans = max(ans, best[i]);\n  }\n  long long sum = 0;\n  int i = 0;\n  int cur = 0;\n  while (cur + 3 <= m) {\n    cur += 3;\n    sum += arr[3][i++];\n    ans = max(ans, sum + best[m - cur]);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, w;\nlong long c, r, vop;\nvector<long long> s[3], op[2], tot[3];\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d %lld\", &w, &c);\n    s[w - 1].push_back(c);\n  }\n  sort(s[2].begin(), s[2].end());\n  tot[0].push_back(0);\n  for (int i = s[2].size() - 1; i >= 0; i--)\n    tot[0].push_back(tot[0].back() + s[2][i]);\n  if (!s[0].empty()) {\n    sort(s[0].begin(), s[0].end());\n    vop = s[0].back();\n  }\n  op[0] = s[1];\n  op[1] = s[1];\n  for (int i = s[0].size() - 1; i >= 0; i -= 2) {\n    if (i)\n      op[0].push_back(s[0][i] + s[0][i - 1]);\n    else\n      op[0].push_back(s[0][0]);\n  }\n  for (int i = s[0].size() - 2; i >= 0; i -= 2) {\n    if (i)\n      op[1].push_back(s[0][i] + s[0][i - 1]);\n    else\n      op[1].push_back(s[0][0]);\n  }\n  sort(op[0].begin(), op[0].end());\n  sort(op[1].begin(), op[1].end());\n  tot[1].push_back(0);\n  for (int i = op[0].size() - 1; i >= 0; i--)\n    tot[1].push_back(tot[1].back() + op[0][i]);\n  tot[2].push_back(0);\n  for (int i = op[1].size() - 1; i >= 0; i--)\n    tot[2].push_back(tot[2].back() + op[1][i]);\n  for (int i = 0; i < tot[0].size() && 3 * i <= m; i++) {\n    int h = m - 3 * i, s1 = tot[1].size(), s2 = tot[2].size();\n    if (h & 1)\n      r = max(r, tot[0][i] + vop + tot[2][min(s2 - 1, h / 2)]);\n    else\n      r = max(r, tot[0][i] + tot[1][min(s1 - 1, h / 2)]);\n  }\n  printf(\"%lld\\n\", r);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nlong long dp[300005];\nstruct S {\n  int w, c;\n  bool friend operator<(S x, S y) {\n    return ((double)x.c / x.w > (double)y.c / y.w);\n  }\n} a[100005];\nint main() {\n  while (scanf(\"%d%d\", &n, &m) != -1) {\n    for (int i = 1; i <= n; i += 1) {\n      scanf(\"%d%d\", &a[i].w, &a[i].c);\n    }\n    sort(a + 1, a + n + 1);\n    dp[0] = 0;\n    for (int i = 1; i < m; i += 1) {\n      dp[i] = -1e17L;\n    }\n    int up = 0;\n    long long ans = 0;\n    for (int i = 1; i <= n; i += 1) {\n      up += a[i].w;\n      if (up > m) {\n        up = m;\n      }\n      int least = max(a[i].w, up - 3);\n      for (int j = up; j >= least; j -= 1) {\n        dp[j] = max(dp[j], dp[j - a[i].w] + a[i].c);\n        ans = max(ans, dp[j]);\n      }\n    }\n    printf(\"%I64d\\n\", ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\nimport java.util.zip.Adler32;\n\npublic class Contest1 {\n\n    static long[][]memo;\n    static ArrayList<Integer>[]vals;\n    static int get2(int id){\n       int c=0;\n        if (id<vals[0].size()){\n            c+=vals[0].get(id);\n        }\n        if (id+1<vals[0].size()){\n            c+=vals[0].get(id+1);\n        }\n        return c;\n    }\n    static long dp1(int id1,int id2){\n        memo[0][0]=0;\n        int cur =1;\n        while (cur<memo[0].length){\n            int c= get2(id1);\n            int c2=0;\n            if (id2<vals[1].size())c2+=vals[1].get(id2);\n            if (c>c2){\n                memo[0][cur]=c;\n                memo[0][cur]+=memo[0][cur-1];\n                id1+=2;\n            }else {\n                memo[0][cur]=c2;\n                memo[0][cur]+=memo[0][cur-1];\n                id2+=1;\n            }\n            cur++;\n        }\n        return 0;\n    }\n    static long dp2(int id1,int id2){\n        memo[1][0]=0;\n        int cur =1;\n        while (cur<memo[0].length){\n            int c= get2(id1);\n            int c2=0;\n            if (id2<vals[1].size())c2+=vals[1].get(id2);\n            if (c>c2){\n                memo[1][cur]=c;\n                memo[1][cur]+=memo[1][cur-1];\n                id1+=2;\n            }else {\n                memo[1][cur]=c2;\n                memo[1][cur]+=memo[1][cur-1];\n                id2+=1;\n            }\n            cur++;\n        }\n        return 0;\n    }\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        vals = new ArrayList[3];\n        for (int i =0;i<3;i++)vals[i]=new ArrayList<>();\n        for (int i =0;i<n;i++){\n            vals[sc.nextInt()-1].add(sc.nextInt());\n        }\n        for (int i =0;i<3;i++){\n            Collections.sort(vals[i],Collections.reverseOrder());\n        }\n        long ans=0;\n        long pre=0;\n        memo= new long[2][m+1];\n        for (long[]x:memo)Arrays.fill(x,-1);\n        ans= dp1(0,0);\n        dp2(1,0);\n        ans=memo[0][m/2];\n        if (vals[0].size()>0){\n            ans=Math.max(ans,memo[1][(m-1)/2]+vals[0].get(0));\n        }\n        for (int j =0;j<vals[2].size();j++){\n            pre+=vals[2].get(j);\n            int c = (j+1)*3;\n            if (c<=m){\n                int rem = m-c;\n                long cc=memo[0][rem/2];\n                if (rem%2==1){\n                    if (vals[0].size()>0){\n                        cc=memo[1][(rem-1)/2]+vals[0].get(0);\n                    }\n                }\n                ans=Math.max(ans,pre+cc);\n            }\n        }\n        pw.println(ans);\n        pw.flush();\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(FileReader r) {\n            br = new BufferedReader(r);\n        }\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            String x = next();\n            StringBuilder sb = new StringBuilder(\"0\");\n            double res = 0, f = 1;\n            boolean dec = false, neg = false;\n            int start = 0;\n            if (x.charAt(0) == '-') {\n                neg = true;\n                start++;\n            }\n            for (int i = start; i < x.length(); i++)\n                if (x.charAt(i) == '.') {\n                    res = Long.parseLong(sb.toString());\n                    sb = new StringBuilder(\"0\");\n                    dec = true;\n                } else {\n                    sb.append(x.charAt(i));\n                    if (dec)\n                        f *= 10;\n                }\n            res += Long.parseLong(sb.toString()) / f;\n            return res * (neg ? -1 : 1);\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n    }\n\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tstatic int[][]poss;\n\tstatic int maxW;\n\tstatic int[]cs,ws;\n\tstatic long[][]memo;\n\tstatic long dp(int i,int curW) {\n\t\tif(i>=cs.length)return 0;\n\t\tif(memo[i][curW]!=-1)return memo[i][curW];\n\t\t\n\t\tlong leave=dp(i+1, curW);\n\t\tlong take=0;\n\t\tif(curW+ws[i]<=maxW) {\n\t\t\ttake=dp(i+1, curW+ws[i])+cs[i];\n\t\t}\n\t\treturn memo[i][curW]=Math.max(take, leave);\n\t}\n\tpublic static void main(String[] args) throws Exception{\n\t\tPrintWriter pw=new PrintWriter(System.out);\n\t\tMScanner sc = new MScanner(System.in);\n\t\tposs=new int[7][];\n\t\tposs[0]= new int[]{3,3};\n\t\tposs[1]= new int[]{1,2,3};\n\t\tposs[2]= new int[]{2,2,2};\n\t\tposs[3]= new int[]{1,1,1,3};\n\t\tposs[4]= new int[]{1,1,2,2};\n\t\tposs[5]= new int[]{1,1,1,1,2};\n\t\tposs[6]= new int[]{1,1,1,1,1,1};\n\t\t\n\t\tint n=sc.nextInt(),m=sc.nextInt();\n\t\tArrayList<Integer>[]weights=new ArrayList[4];\n\t\tfor(int i=1;i<=3;i++)weights[i]=new ArrayList<Integer>();\n\t\t\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tweights[sc.nextInt()].add(sc.nextInt());\n\t\t}\n\t\tint cnt=0;\n\t\tCollections.sort(weights[1], Collections.reverseOrder());\n\t\tCollections.sort(weights[2], Collections.reverseOrder());\n\t\tCollections.sort(weights[3], Collections.reverseOrder());\n\t\t\n\t\tint[]pointers=new int[4];\n\t\tlong ans=0;\n\t\twhile((n-cnt)*1l*m>=(int)2e7) {\n\t\t\tlong max=0;int best=-1;\n\t\t\tfor(int p=0;p<7;p++) {\n\t\t\t\tlong sum=0;\n\t\t\t\tint[]tmpP=pointers.clone();\n\t\t\t\t\n\t\t\t\tfor(int j=0;j<poss[p].length;j++) {\n\t\t\t\t\tint w=poss[p][j];\n\t\t\t\t\tif(tmpP[w]>=weights[w].size()) {\n\t\t\t\t\t\tsum=0;break;\n\t\t\t\t\t}\n\t\t\t\t\tint c=weights[w].get(tmpP[w]++);\n\t\t\t\t\tsum+=c;\n\t\t\t\t}\n\t\t\t\tif(sum>max) {\n\t\t\t\t\tmax=sum;\n\t\t\t\t\tbest=p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(best==-1)break;\n\t\t\tm-=6;\n\t\t\tfor(int j=0;j<poss[best].length;j++) {\n\t\t\t\tint w=poss[best][j];\n\t\t\t\tint c=weights[w].get(pointers[w]++);\n\t\t\t\tans+=c;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tn-=cnt;\n\t\tint c=0;\n\t\tws=new int[n];\n\t\tcs=new int[n];\n\t\tfor(int w=1;w<=3;w++) {\n\t\t\twhile(pointers[w]<weights[w].size()) {\n\t\t\t\tws[c]=w;\n\t\t\t\tcs[c++]=weights[w].get(pointers[w]++);\n\t\t\t}\n\t\t}\n\t\tmaxW=m;\n\t\tmemo=new long[n][m+1];\n\t\tfor(long[]i:memo)Arrays.fill(i, -1);\n\t\tpw.println(ans+dp(0, 0));\n\t\tpw.flush();\n\t}\n\tstatic class MScanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\t\tpublic MScanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n \n\t\tpublic MScanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tpublic int[] intArr(int n) throws IOException {\n\t        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n\t        return in;\n\t\t}\n\t\tpublic long[] longArr(int n) throws IOException {\n\t        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n\t        return in;\n\t\t}\n\t\tpublic int[] intSortedArr(int n) throws IOException {\n\t        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n\t        shuffle(in);\n\t        Arrays.sort(in);\n\t        return in;\n\t\t}\n\t\tpublic long[] longSortedArr(int n) throws IOException {\n\t        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n\t        shuffle(in);\n\t        Arrays.sort(in);\n\t        return in;\n\t\t}\n\t\tstatic void shuffle(int[]in) {\n\t\t\tfor(int i=0;i<in.length;i++) {\n\t\t\t\tint idx=(int)(Math.random()*in.length);\n\t\t\t\tint tmp=in[i];\n\t\t\t\tin[i]=in[idx];\n\t\t\t\tin[idx]=tmp;\n\t\t\t}\n\t\t}\n\t\tstatic void shuffle(long[]in) {\n\t\t\tfor(int i=0;i<in.length;i++) {\n\t\t\t\tint idx=(int)(Math.random()*in.length);\n\t\t\t\tlong tmp=in[i];\n\t\t\t\tin[i]=in[idx];\n\t\t\t\tin[idx]=tmp;\n\t\t\t}\n\t\t}\n\t\tpublic Integer[] IntegerArr(int n) throws IOException {\n\t        Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();\n\t        return in;\n\t\t}\n\t\tpublic Long[] LongArr(int n) throws IOException {\n\t        Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n\t        return in;\n\t\t}\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n \n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n \n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n \n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n\tstatic void addX(int[]in,int x) {\n\t\tfor(int i=0;i<in.length;i++)in[i]+=x;\n\t}\n\tstatic void addX(long[]in,int x) {\n\t\tfor(int i=0;i<in.length;i++)in[i]+=x;\n\t}\n}"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        InputStream inputStream = System.in;\n//        InputStream inputStream = new FileInputStream(\"dijkstra.in\");\n        OutputStream outputStream = System.out;\n//        OutputStream outputStream = new FileOutputStream(\"dijkstra.out\");\n\n\n//        Path path = Paths.get(URI.create(\"file:///foo/bar/Main.java\"));\n//        System.out.print(path.getName(200));\n\n//        Path p = Paths.get(\"/foo/bar/Main.java\");\n//        for (Path e : p) {\n//            System.out.println(e);\n//        }\n\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Answer solver = new Answer();\n        solver.solve(in, out);\n        out.close();\n    }\n}\n\nclass Answer {\n    private final int INF = (int) (1e9 + 7);\n\n    private class Triple {\n        long cost;\n        int cnt1;\n        int cnt2;\n\n        public Triple() {\n            this.cost = 0;\n            this.cnt1 = 0;\n            this.cnt2 = 0;\n        }\n\n        public Triple(long cost, int cnt1, int cnt2) {\n            this.cost = cost;\n            this.cnt1 = cnt1;\n            this.cnt2 = cnt2;\n        }\n    }\n\n    public void solve(InputReader in, PrintWriter out) throws IOException {\n        int n = in.nextInt();\n        int m = in.nextInt();\n\n        List<Integer>[] st = new List[4];\n        for (int i = 1; i < 4; i++) {\n            st[i] = new ArrayList<>();\n            st[i].add(INF);\n        }\n\n        for (int i = 0; i < n; i++) {\n            int w = in.nextInt();\n            int c = in.nextInt();\n            st[w].add(c);\n        }\n\n        for (int i = 1; i < 4; i++) {\n            Collections.sort(st[i], new Comparator<Integer>() {\n                @Override\n                public int compare(Integer o1, Integer o2) {\n                    return o2 - o1;\n                }\n            });\n        }\n\n        Triple[] dp = new Triple[m + 1];\n        for (int i = 0; i < m + 1; i++) {\n            dp[i] = new Triple();\n        }\n        if (st[1].size() >= 2) {\n            dp[1] = new Triple(st[1].get(1), 1, 0);\n        }\n        if (st[1].size() >= 3) {\n            dp[2] = new Triple(st[1].get(1) + st[1].get(2), 2, 0);\n        }\n\n        if (st[2].size() >= 2 && m >= 2) {\n            long cost = st[2].get(1);\n            int cnt1 = 0;\n            int cnt2 = 1;\n\n            if (st[1].size() >= 2) {\n                if (cost < st[1].get(1)) {\n                    cost = st[1].get(1);\n                    cnt1 = 1;\n                    cnt2 = 0;\n                }\n            }\n            if (st[1].size() >= 3) {\n                if (cost < st[1].get(1) + st[1].get(2)) {\n                    cost = st[1].get(1) + st[1].get(2);\n                    cnt1 = 2;\n                    cnt2 = 0;\n                }\n            }\n\n//            out.println(cost + \" \" + cnt1 + \" \" + cnt2);\n            dp[2] = new Triple(cost, cnt1, cnt2);\n        }\n\n\n        for (int i = 3; i <= m; i++) {\n            long cost_1 = dp[i - 1].cost;\n            int cnt1_1 = dp[i - 1].cnt1;\n            int cnt2_1 = dp[i - 1].cnt2;\n\n            long cost_2 = dp[i - 2].cost;\n            int cnt1_2 = dp[i - 2].cnt1;\n            int cnt2_2 = dp[i - 2].cnt2;\n\n            long cost = cost_2;\n            int cnt1 = cnt1_2;\n            int cnt2 = cnt2_2;\n\n//            out.println(i +\": cost_1: \" + cost_1 + \"(\" + (i - 1) + \"), cost_2: \" + cost_2 + \"(\" + (i - 2) + \")\");\n\n            if (cnt2_2 + 1 < st[2].size()) {\n                cnt2++;\n                cost += st[2].get(cnt2);\n            }\n\n            if (cnt1_1 + 1 < st[1].size()) {\n                if (cost < cost_1 + st[1].get(cnt1_1 + 1)) {\n                    cost = cost_1 + st[1].get(cnt1_1 + 1);\n                    cnt1 = cnt1_1 + 1;\n                    cnt2 = cnt2_1;\n                }\n            }\n\n            if (cnt2_1 + 1 < st[2].size() && cnt1_1 >= 1) {\n//                try {\n                    if (cost < cost_1 - st[1].get(cnt1_1) + st[2].get(cnt2_1 + 1)) {\n                        cost = cost_1 - st[1].get(cnt1_1) + st[2].get(cnt2_1 + 1);\n                        cnt1 = cnt1_1 - 1;\n                        cnt2 = cnt2_1 + 1;\n                    }\n//                } catch (IndexOutOfBoundsException e) {\n//                    out.println(\"cnt1_1: \" + cnt1_1 + \", cnt2_1: \" + cnt2_1);\n//                }\n            }\n\n//            out.println(i + \": cost: \" + cost);\n            dp[i] = new Triple(cost, cnt1, cnt2);\n        }\n\n\n        long ans = 0;\n        for (int i = 0; i < m + 1; i++) {\n            ans = Math.max(dp[i].cost, ans);\n        }\n\n        if (st[3].size() > 0) {\n            long[] sum = new long[st[3].size()];\n            for (int i = 1; i < sum.length; i++) {\n                sum[i] = sum[i - 1] + st[3].get(i);\n            }\n\n            for (int i = 0; i <= m; i++) {\n                int x = m - i;\n                int pc = Math.min(x / 3, st[3].size() - 1);\n                ans = Math.max(ans, dp[i].cost + sum[pc]);\n\n            }\n        }\n\n        out.println(ans);\n//        for (int i = 0; i < m + 1; i++) {\n//            out.println(i + \": \" + dp[i].cost + \" \" + dp[i].cnt1 + \" \" + dp[i].cnt2);\n//        }\n    }\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.util.Collections;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Omar Yasser\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, Scanner sc, PrintWriter out) {\n            int n = sc.nextInt();\n            int maxW = sc.nextInt();\n\n            ArrayList<Integer> cost[] = new ArrayList[4];\n            for (int i = 0; i < 4; i++) {\n                cost[i] = new ArrayList<>();\n            }\n            for (int i = 0; i < n; i++) {\n                cost[sc.nextInt()].add(sc.nextInt());\n            }\n            for (int i = 1; i <= 3; i++) {\n                Collections.sort(cost[i], Collections.reverseOrder());\n            }\n\n            long dp[][] = new long[maxW + 1][3];\n            if (cost[1].size() > 0) dp[1] = new long[]{cost[1].get(0), 1, 0};\n            else dp[1] = new long[]{-1, -1, -1};\n\n            for (int i = 2; i <= maxW; i++) {\n                dp[i] = new long[]{-1, -1, -1};\n                if (dp[i - 1][0] != -1 && cost[1].size() - dp[i - 1][1] >= 1) {\n                    dp[i] = new long[]{dp[i - 1][0] + cost[1].get((int) dp[i - 1][1]), dp[i - 1][1] + 1, dp[i - 1][2]};\n                }\n                if (dp[i - 2][0] != -1 && cost[1].size() - dp[i - 2][1] >= 2 && dp[i - 2][0] + cost[1].get((int) dp[i - 2][1]) + cost[1].get((int) dp[i - 2][1] + 1) > dp[i][0]) {\n                    dp[i] = new long[]{dp[i - 2][0] + cost[1].get((int) dp[i - 2][1]) + cost[1].get((int) dp[i - 2][1] + 1), dp[i - 2][1] + 2, dp[i - 2][2]};\n                }\n                if (dp[i - 2][0] != -1 && cost[2].size() - dp[i - 2][2] >= 1 && dp[i - 2][0] + cost[2].get((int) dp[i - 2][2]) > dp[i][0]) {\n                    dp[i] = new long[]{dp[i - 2][0] + cost[2].get((int) dp[i - 2][2]), dp[i - 2][1], dp[i - 2][2] + 1};\n                }\n                if (dp[i - 1][0] > dp[i][0]) dp[i] = new long[]{dp[i - 1][0], dp[i - 1][1], dp[i - 1][2]};\n                if (dp[i - 2][0] > dp[i][0]) dp[i] = new long[]{dp[i - 2][0], dp[i - 2][1], dp[i - 2][2]};\n            }\n\n            long res = 0;\n            long acc = 0;\n            for (int times = 0; times <= cost[3].size() && times * 3 <= maxW; times++) {\n                if (dp[maxW - times * 3][0] != -1) res = Math.max(res, acc + dp[maxW - times * 3][0]);\n                if (times != cost[3].size()) acc += cost[3].get(times);\n            }\n            out.println(res);\n        }\n\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public Scanner(FileReader f) {\n            br = new BufferedReader(f);\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens())\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (Exception e) {\n                }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100010;\nconst int MAXW = 300010;\nint n, m;\nint a[MAXW] = {0}, b[MAXW] = {0}, c[MAXW] = {0};\nint aidx = 0, bidx = 0, cidx = 0;\nlong long f[MAXW] = {0};\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; ++i) {\n    int w, cost;\n    scanf(\"%d%d\", &w, &cost);\n    if (w == 1)\n      a[aidx++] = cost;\n    else if (w == 2)\n      b[bidx++] = cost;\n    else\n      c[cidx++] = cost;\n  }\n  sort(a, a + aidx, greater<int>());\n  sort(b, b + bidx, greater<int>());\n  sort(c, c + cidx, greater<int>());\n  int ai = 0, bi = 0, noww = 0;\n  long long nowc = 0;\n  for (int i = 1; i <= m; ++i) {\n    if (i - noww >= 2) {\n      if (a[ai] * 2 > b[bi])\n        nowc += a[ai++], ++noww;\n      else\n        nowc += b[bi++], noww += 2;\n    }\n    if (i == noww)\n      f[i] = nowc;\n    else {\n      f[i] = nowc + a[ai];\n      if (ai) f[i] = max(f[i], nowc - a[ai - 1] + b[bi]);\n    }\n  }\n  long long ans = f[m];\n  noww = m, nowc = 0;\n  for (int i = 0; i < cidx; ++i) {\n    noww -= 3, nowc += c[i];\n    if (noww < 0) break;\n    ans = max(ans, f[noww] + nowc);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 7;\nint n, m, sum;\nlong long ans, pre[4][N];\nvector<int> a[4];\nlong long check(int mid, int have) {\n  int one = have - 3 * mid;\n  if (one > a[1].size()) one = a[1].size();\n  return pre[3][mid] + pre[1][one];\n}\nlong long del(int have) {\n  int l = 0, r = a[3].size();\n  r = min(r, have / 3);\n  while (l < r - 1) {\n    int mid = l + r >> 1, mid2 = r + mid >> 1;\n    if (check(mid, have) > check(mid2, have))\n      r = mid2;\n    else\n      l = mid;\n  }\n  return max(max(check(l, have), check(r, have)), check(0, have));\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  a[1].push_back(0), a[2].push_back(0), a[3].push_back(0);\n  for (int i = 1; i <= n; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    a[x].push_back(y);\n    sum += x, ans += y;\n  }\n  if (m >= sum) {\n    printf(\"%lld\\n\", ans);\n    return 0;\n  }\n  ans = 0;\n  sort(a[1].begin(), a[1].end(), greater<int>());\n  sort(a[2].begin(), a[2].end(), greater<int>());\n  sort(a[3].begin(), a[3].end(), greater<int>());\n  for (int k = 1; k <= 3; k++)\n    for (int i = 0; i <= a[k].size() - 1; i++)\n      pre[k][i + 1] = pre[k][i] + a[k][i];\n  for (int i = 0; i <= a[2].size(); i++) {\n    if (i * 2 <= m) ans = max(ans, del(m - i * 2) + pre[2][i]);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nunsigned sed = std::chrono::system_clock::now().time_since_epoch().count();\nmt19937 rand_num(sed);\nuniform_int_distribution<long long> dis(0, 1000000007);\ntemplate <typename T>\nvoid read(T &x) {\n  x = 0;\n  char ch = getchar();\n  long long fh = 1;\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') fh = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();\n  x *= fh;\n}\ntemplate <typename T>\nvoid write(T x) {\n  if (x < 0) x = -x, putchar('-');\n  if (x > 9) write(x / 10);\n  putchar(x % 10 + '0');\n}\ntemplate <typename T>\nvoid writeln(T x) {\n  write(x);\n  puts(\"\");\n}\nlong long n, m;\nlong long l1, l2, l3;\nlong long c1[100005], c2[100005], c3[100005];\nlong long sum1[100005], sum2[100005], sum3[100005];\nsigned main() {\n  read(n);\n  read(m);\n  for (long long i = 1; i <= n; ++i) {\n    long long w, c;\n    read(w);\n    read(c);\n    if (w == 1) c1[++l1] = c;\n    if (w == 2) c2[++l2] = c;\n    if (w == 3) c3[++l3] = c;\n  }\n  sort(c1 + 1, c1 + l1 + 1);\n  sort(c2 + 1, c2 + l2 + 1);\n  sort(c3 + 1, c3 + l3 + 1);\n  reverse(c1 + 1, c1 + l1 + 1);\n  reverse(c2 + 1, c2 + l2 + 1);\n  reverse(c3 + 1, c3 + l3 + 1);\n  for (long long i = 1; i <= l1; ++i) sum1[i] = sum1[i - 1] + c1[i];\n  for (long long i = 1; i <= l2; ++i) sum2[i] = sum2[i - 1] + c2[i];\n  for (long long i = 1; i <= l3; ++i) sum3[i] = sum3[i - 1] + c3[i];\n  long long ans = 0;\n  for (long long i = 0; i <= min(m / 3, l3); ++i) {\n    long long left = m - i * 3;\n    long long l = 1, r = min(left / 2, l2);\n    while (l < r) {\n      long long mid = l + r + 1 >> 1;\n      long long left1 = left - mid * 2;\n      long long val =\n          sum1[min(l1, left1)] + sum2[min(l2, mid)] + sum3[min(l3, i)];\n      long long mid1 = mid - 1;\n      long long left2 = left - mid1 * 2;\n      long long val2 =\n          sum1[min(l1, left2)] + sum2[min(l2, mid1)] + sum3[min(l3, i)];\n      if (val >= val2)\n        l = mid;\n      else\n        r = mid - 1;\n    }\n    for (long long j = max(0LL, l - 2); j <= min(l2, l + 2); ++j) {\n      long long left1 = m - i * 3 - j * 2;\n      if (left1 < 0) continue;\n      ans =\n          max(ans, sum1[min(l1, left1)] + sum2[min(l2, j)] + sum3[min(l3, i)]);\n    }\n  }\n  writeln(ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\npair<long long int, pair<int, int> > dp[300005];\nvector<int> cost1;\nvector<int> cost2;\nvector<int> cost3;\nint main() {\n  int n, m;\n  cin >> n;\n  cin >> m;\n  for (int i = 0; i < n; i++) {\n    int w, c;\n    cin >> w;\n    cin >> c;\n    if (w == 1) {\n      cost1.push_back(c);\n    } else if (w == 2) {\n      cost2.push_back(c);\n    } else {\n      cost3.push_back(c);\n    }\n  }\n  sort(cost1.begin(), cost1.end());\n  reverse(cost1.begin(), cost1.end());\n  sort(cost2.begin(), cost2.end());\n  reverse(cost2.begin(), cost2.end());\n  sort(cost3.begin(), cost3.end());\n  reverse(cost3.begin(), cost3.end());\n  dp[0].first = 0;\n  dp[0].second.first = 0;\n  dp[0].second.second = 0;\n  for (int i = 1; i <= m; i++) {\n    if (i == 1) {\n      if (cost1.size() > 0) {\n        dp[i].first = cost1[0];\n        dp[i].second.first = 1;\n        dp[i].second.second = 0;\n      } else {\n        dp[i].first = 0;\n        dp[i].second.first = 0;\n        dp[i].second.second = 0;\n      }\n    } else {\n      if ((cost1.size() > dp[i - 1].second.first) &&\n          (cost2.size() > dp[i - 2].second.second) &&\n          (dp[i - 1].first + cost1[dp[i - 1].second.first] >\n           dp[i - 2].first + cost2[dp[i - 2].second.second])) {\n        dp[i].first = dp[i - 1].first + cost1[dp[i - 1].second.first];\n        dp[i].second.first = dp[i - 1].second.first + 1;\n        dp[i].second.second = dp[i - 1].second.second;\n      } else if ((cost1.size() > dp[i - 1].second.first) &&\n                 (cost2.size() > dp[i - 2].second.second) &&\n                 (dp[i - 1].first + cost1[dp[i - 1].second.first] <=\n                  dp[i - 2].first + cost2[dp[i - 2].second.second])) {\n        dp[i].first = dp[i - 2].first + cost2[dp[i - 2].second.second];\n        dp[i].second.first = dp[i - 2].second.first;\n        dp[i].second.second = dp[i - 2].second.second + 1;\n      } else if ((cost1.size() <= dp[i - 1].second.first) &&\n                 (cost2.size() > dp[i - 2].second.second)) {\n        if (dp[i - 1].first >=\n            dp[i - 2].first + cost2[dp[i - 2].second.second]) {\n          dp[i].first = dp[i - 1].first;\n          dp[i].second.first = dp[i - 1].second.first;\n          dp[i].second.second = dp[i - 1].second.second;\n        } else {\n          dp[i].first = dp[i - 2].first + cost2[dp[i - 2].second.second];\n          dp[i].second.first = dp[i - 2].second.first;\n          dp[i].second.second = dp[i - 2].second.second + 1;\n        }\n      } else if ((cost1.size() > dp[i - 1].second.first) &&\n                 (cost2.size() <= dp[i - 2].second.second)) {\n        if (dp[i - 2].first >=\n            dp[i - 1].first + cost1[dp[i - 1].second.first]) {\n          dp[i].first = dp[i - 2].first;\n          dp[i].second.first = dp[i - 2].second.first;\n          dp[i].second.second = dp[i - 2].second.second;\n        } else {\n          dp[i].first = dp[i - 1].first + cost1[dp[i - 1].second.first];\n          dp[i].second.first = dp[i - 1].second.first + 1;\n          dp[i].second.second = dp[i - 1].second.second;\n        }\n      } else {\n        dp[i].first = dp[i - 1].first;\n        dp[i].second.first = dp[i - 1].second.first;\n        dp[i].second.second = dp[i - 1].second.second;\n      }\n    }\n  }\n  long long int ans = dp[m].first;\n  long long int temp = 0;\n  for (int i = 0; i < cost3.size(); i++) {\n    temp += cost3[i];\n    if (m - 3 * (i + 1) >= 0) ans = max(ans, temp + dp[m - 3 * (i + 1)].first);\n  }\n  cout << ans;\n  return 0;\n}\n"
        },
        {
            "language": 1,
            "solution": "n, m = map(int, raw_input().split())\na = [map(int, raw_input().split()) for i in xrange(n)]\na.sort(key = lambda x: (x[1] / 1.0 / x[0], -x[0]))\ncost = 0\nweight = m\nused = [([10 ** 10] * 3) for i in xrange(3)]\nwhile a != [] and a[-1][0] <= weight:\n    used[a[-1][0] - 1].append(a[-1][1])\n    cost += a[-1][1]\n    weight -= a.pop()[0]\nfor i in xrange(3):\n    used[i].sort()\nd = [0] * 7\nfor i in a:\n    for j in xrange(6, i[0] - 1, -1):\n        d[j] = max(d[j], d[j - i[0]] + i[1])\nif weight == 0 or weight > 3:\n    print cost\n    exit()\nans = cost + d[weight]\nans = max(ans, cost - used[0][0] + d[weight + 1], cost - used[0][0] - used[0][1] + d[weight + 2])\nans = max(ans, cost - used[1][0] + d[weight + 2], cost - used[1][0] - used[1][1] + d[weight + 4])\nans = max(ans, cost - used[2][0] + d[weight + 3])\nprint ans\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, x, y, i, l1, l2, l3;\nlong long pre[311111], ans;\nlong long dp[311111][3];\nvector<long long> v[3];\nbool cmp(long long x, long long y) { return x > y; }\nlong long min(long long x, long long y) { return x < y ? x : y; }\nlong long max(long long x, long long y) { return x > y ? x : y; }\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (i = 1; i <= n; i++) {\n    scanf(\"%d%d\", &x, &y);\n    v[x].push_back(y);\n  }\n  l1 = (int)v[1].size();\n  l2 = (int)v[2].size();\n  l3 = (int)v[3].size();\n  sort(v[1].begin(), v[1].end(), cmp);\n  sort(v[2].begin(), v[2].end(), cmp);\n  sort(v[3].begin(), v[3].end(), cmp);\n  if (l3) pre[0] = v[3][0];\n  for (i = 1; i < l3; i++) pre[i] = pre[i - 1] + v[3][i];\n  for (i = 0; i < m; i++) {\n    if (dp[i + 1][0] < dp[i][0]) {\n      dp[i + 1][0] = dp[i][0];\n      dp[i + 1][1] = dp[i][1];\n      dp[i + 1][2] = dp[i][2];\n    }\n    if (dp[i][1] < l1) {\n      if (dp[i + 1][0] < dp[i][0] + v[1][dp[i][1]]) {\n        dp[i + 1][0] = dp[i][0] + v[1][dp[i][1]];\n        dp[i + 1][1] = dp[i][1] + 1;\n        dp[i + 1][2] = dp[i][2];\n      }\n    }\n    if (dp[i][2] < l2) {\n      dp[i + 2][0] = dp[i][0] + v[2][dp[i][2]];\n      dp[i + 2][1] = dp[i][1];\n      dp[i + 2][2] = dp[i][2] + 1;\n    }\n    if (l3 && (m - i) / 3)\n      ans = max(ans, dp[i][0] + pre[min((m - i) / 3 - 1, l3 - 1)]);\n  }\n  ans = max(ans, dp[m][0]);\n  printf(\"%lld\", ans);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 300005;\ninline long long read() {\n  long long x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return x * f;\n}\nint n, m, c, C, yu, sz, pos[maxn];\nvector<long long> vec[4];\nlong long sum[1000005], f[maxn] = {0}, v, ww[maxn], dp[maxn], g[maxn];\nvoid solve(int l, int r, int L, int R) {\n  if (l > r) return;\n  int mid = (l + r) >> 1;\n  pos[mid] = mid;\n  long long ma = -1;\n  for (int i = L; i <= mid && i <= R; i++) {\n    if (i + sz >= mid & dp[i] + sum[mid - i] > ma)\n      pos[mid] = i, ma = dp[i] + sum[mid - i];\n  }\n  solve(mid + 1, r, pos[mid], R);\n  solve(l, mid - 1, L, pos[mid]);\n}\nint main() {\n  n = read(), m = read();\n  for (int i = 1; i <= n; i++) {\n    c = read(), v = read();\n    vec[c].push_back(v);\n  }\n  for (C = 1; C < 4; C++) {\n    if (!vec[C].size()) continue;\n    sort(vec[C].begin(), vec[C].end());\n    sz = vec[C].size();\n    sum[0] = 0;\n    for (int i = 1; i <= sz; i++)\n      sum[i] = sum[i - 1] + vec[C][vec[C].size() - i];\n    for (yu = 0; yu < C; yu++) {\n      int tot = -1;\n      for (int j = yu; j <= m; j += C) {\n        tot++;\n        dp[tot] = f[j];\n        ww[tot] = 0;\n      }\n      solve(0, tot, 0, tot);\n      for (int j = 0; j <= tot; j++) ww[j] = dp[pos[j]] + sum[j - pos[j]];\n      int cur = 0;\n      for (int j = yu; j <= m; j += C) g[j] = ww[cur++];\n    }\n    for (int i = 0; i <= m; i++) f[i] = g[i];\n  }\n  printf(\"%lld\\n\", f[m]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nclass Solution {\n public:\n  void solve(std::istream& in, std::ostream& out) {\n    long long n, m;\n    in >> n >> m;\n    std::array<std::vector<long long>, 3> c, c_sum;\n    for (long long i = 0; i < n; ++i) {\n      long long w, cur_c;\n      in >> w >> cur_c;\n      c[w - 1].push_back(cur_c);\n    }\n    for (auto& p : c) std::sort(p.begin(), p.end(), greater<long long>());\n    for (long long i = 0; i < 3; ++i) {\n      c_sum[i].resize(c[i].size() + 1);\n      std::partial_sum(c[i].begin(), c[i].end(), c_sum[i].begin() + 1);\n    }\n    auto get_sum = [&](long long weight, long long num) {\n      return c_sum[weight - 1][std::min((long long)c[weight - 1].size(), num)];\n    };\n    auto get = [&](long long weight, long long num) {\n      if (num < c[weight - 1].size()) return c[weight - 1][num];\n      return 0LL;\n    };\n    long long best = 0LL;\n    for (long long n3 = 0; n3 <= std::min(m / 3, (long long)c[2].size());\n         ++n3) {\n      long long n1 = m - n3 * 3;\n      long long n2 = 0;\n      long long r = n1 / 2 + 1;\n      long long l = std::min(1LL, r);\n      auto price_of = [&](long long n1_arg, long long n2_arg,\n                          long long n3_arg) {\n        return get_sum(1, n1_arg) + get_sum(2, n2_arg) + get_sum(3, n3_arg);\n      };\n      while (l < r) {\n        long long cur = l + (r - l) / 2;\n        auto val = get(1, n1 - cur * 2 + 1) + get(1, n1 - cur * 2) -\n                   get(2, n2 + cur - 1);\n        if (val < 0)\n          l = cur + 1;\n        else\n          r = cur;\n      }\n      l = std::max(0LL, l - 1);\n      n1 -= l * 2;\n      n2 += l;\n      best = std::max(best, price_of(n1, n2, n3));\n    }\n    out << best << '\\n';\n  }\n};\nvoid solve(std::istream& in, std::ostream& out) {\n  out << std::setprecision(12);\n  Solution solution;\n  solution.solve(in, out);\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  istream& in = cin;\n  ostream& out = cout;\n  solve(in, out);\n  return 0;\n}\n"
        }
    ]
}