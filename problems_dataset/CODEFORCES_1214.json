{
    "name": "1214_H. Tiles Placement",
    "source": "CODEFORCES",
    "description": "The new pedestrian zone in Moscow city center consists of n squares connected with each other by n - 1 footpaths. We define a simple path as a sequence of squares such that no square appears in this sequence twice and any two adjacent squares in this sequence are directly connected with a footpath. The size of a simple path is the number of squares in it. The footpaths are designed in a such a way that there is exactly one simple path between any pair of different squares.\n\nDuring preparations for Moscow City Day the city council decided to renew ground tiles on all n squares. There are k tile types of different colors, numbered from 1 to k. For each square exactly one tile type must be selected and then used to cover this square surface. To make walking through the city center more fascinating, it was decided to select tiles types for each square in such a way that any possible simple path of size exactly k contains squares with all k possible tile colors.\n\nYou need to find out whether it is possible to place the tiles this way or not.\n\nInput\n\nThe first line contains two integers n, k (2 \u2264 k \u2264 n \u2264 200 000) \u2014 the number of squares in the new pedestrian zone, the number of different tile colors.\n\nEach of the following n - 1 lines contains two integers v_i and u_i (1 \u2264 v_i, u_i \u2264 n) \u2014 numbers of the squares connected by the corresponding road.\n\nIt's guaranteed, that it's possible to go from any square to any other square, moreover there is exactly one such simple path.\n\nOutput\n\nPrint \"Yes\" if it is possible to assign tile colors this way and \"No\" otherwise.\n\nIn case your answer is \"Yes\", print n integers from 1 to k each, the color of the tile for every square.\n\nExamples\n\nInput\n\n\n7 4\n1 3\n2 3\n3 4\n4 5\n5 6\n5 7\n\n\nOutput\n\n\nYes\n1 1 2 3 4 1 1\n\n\nInput\n\n\n7 3\n1 3\n2 3\n3 4\n4 5\n5 6\n5 7\n\n\nOutput\n\n\nNo\n\nNote\n\nThe following pictures illustrate the pedestrian zone in first and second examples. The second picture also shows one possible distribution of colors among the squares for k = 4.\n\n<image>",
    "difficulty": "H",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "trees"
    ],
    "rating": 2800,
    "public_test": [
        {
            "input": "7 3\n1 3\n2 3\n3 4\n4 5\n5 6\n5 7\n",
            "output": "No\n"
        },
        {
            "input": "7 4\n1 3\n2 3\n3 4\n4 5\n5 6\n5 7\n",
            "output": "Yes\n1 1 2 3 4 1 1 \n"
        }
    ],
    "generated_test": [
        {
            "input": "5 2\n3 1\n1 4\n4 2\n3 5\n",
            "output": "Yes\n1 1 2 2 1 "
        },
        {
            "input": "7 3\n7 1\n7 2\n7 1\n7 5\n7 6\n7 4\n",
            "output": "No\n"
        },
        {
            "input": "64 45\n8 39\n8 42\n39 9\n8 37\n8 1\n42 12\n37 7\n7 5\n1 29\n9 40\n29 3\n8 50\n5 14\n14 6\n6 23\n23 25\n25 51\n25 34\n7 48\n1 35\n7 58\n58 57\n57 18\n40 54\n51 4\n5 53\n3 49\n29 33\n6 45\n26 24\n53 43\n43 62\n39 26\n8 52\n7 20\n25 27\n35 46\n18 13\n25 15\n53 56\n12 44\n8 38\n57 59\n5 32\n38 11\n46 47\n51 61\n56 63\n11 19\n56 10\n32 60\n19 22\n42 17\n42 2\n33 36\n11 30\n20 28\n14 31\n17 64\n54 16\n31 21\n2 41\n3 55\n",
            "output": "Yes\n11 12 13 1 7 5 8 10 12 4 12 12 12 6 2 15 12 11 13 9 4 14 4 13 3 12 2 10 12 13 5 6 13 2 12 14 9 11 11 13 13 11 5 13 4 13 14 9 14 11 2 11 6 14 14 5 10 9 11 5 1 4 4 13 "
        },
        {
            "input": "4 2\n3 2\n3 1\n1 4\n",
            "output": "Yes\n1 1 2 2 "
        },
        {
            "input": "7 4\n2 5\n3 5\n3 7\n7 4\n2 1\n4 6\n",
            "output": "Yes\n3 2 4 2 1 1 3 "
        },
        {
            "input": "5 2\n3 1\n1 4\n4 2\n1 5\n",
            "output": "Yes\n1 1 2 2 2 "
        },
        {
            "input": "64 45\n8 39\n8 42\n39 9\n8 37\n8 1\n42 12\n37 7\n7 5\n1 29\n9 40\n29 3\n8 50\n5 14\n14 6\n6 23\n23 25\n25 51\n25 34\n7 48\n1 35\n7 58\n58 57\n57 18\n40 54\n51 4\n5 53\n3 49\n29 33\n6 45\n51 24\n53 43\n43 62\n39 26\n8 52\n7 20\n25 27\n35 46\n18 13\n25 15\n53 56\n12 44\n8 38\n57 59\n5 32\n38 11\n46 47\n51 61\n56 63\n11 19\n56 10\n32 60\n19 22\n42 17\n42 2\n10 36\n11 30\n20 28\n14 31\n17 64\n54 16\n31 21\n2 41\n3 55\n",
            "output": "Yes\n11 12 13 1 7 5 8 10 12 4 12 12 12 6 2 15 12 11 13 9 4 14 4 1 3 12 2 10 12 13 5 6 13 2 12 3 9 11 11 13 13 11 5 13 4 13 14 9 14 11 2 11 6 14 14 5 10 9 11 5 1 4 4 13 "
        },
        {
            "input": "4 2\n3 2\n4 1\n3 4\n",
            "output": "Yes\n2 1 2 1 "
        },
        {
            "input": "7 5\n7 1\n1 4\n3 5\n4 2\n2 6\n2 3\n",
            "output": "Yes\n5 3 2 4 1 2 1 "
        },
        {
            "input": "64 45\n8 39\n8 42\n39 9\n8 37\n8 1\n42 12\n37 7\n7 5\n1 29\n9 40\n29 3\n1 50\n5 14\n14 6\n6 23\n23 25\n25 51\n25 34\n7 48\n1 35\n7 58\n58 57\n57 18\n40 54\n51 4\n5 53\n3 49\n29 33\n6 45\n26 24\n53 43\n43 62\n39 26\n8 52\n7 20\n25 27\n35 46\n18 13\n25 15\n53 56\n12 44\n8 38\n57 59\n5 32\n38 11\n46 47\n51 61\n56 63\n11 19\n56 10\n32 60\n19 22\n42 17\n42 2\n33 36\n11 30\n20 28\n14 31\n17 64\n54 16\n31 21\n2 41\n3 55\n",
            "output": "Yes\n11 12 13 1 7 5 8 10 12 4 12 12 12 6 2 15 12 11 13 9 4 14 4 13 3 12 2 10 12 13 5 6 13 2 12 14 9 11 11 13 13 11 5 13 4 13 14 9 14 12 2 11 6 14 14 5 10 9 11 5 1 4 4 13 "
        },
        {
            "input": "4 2\n3 2\n3 1\n2 4\n",
            "output": "Yes\n2 2 1 1 "
        },
        {
            "input": "7 4\n6 5\n6 3\n6 2\n1 7\n1 4\n2 4\n",
            "output": "Yes\n1 3 1 4 1 2 2 "
        },
        {
            "input": "64 45\n8 39\n8 42\n39 9\n8 37\n8 1\n42 12\n37 7\n7 5\n1 29\n9 40\n29 3\n1 50\n5 14\n14 6\n6 23\n23 25\n25 51\n25 34\n7 48\n1 35\n7 58\n58 57\n57 18\n40 54\n51 4\n5 53\n3 49\n29 33\n6 45\n26 24\n53 43\n43 62\n39 26\n8 52\n7 20\n25 27\n35 46\n18 13\n25 15\n53 56\n12 44\n8 38\n57 59\n5 32\n38 11\n46 47\n51 61\n56 63\n11 19\n56 10\n32 60\n19 22\n42 17\n42 2\n39 36\n11 30\n20 28\n14 31\n17 64\n54 16\n31 21\n2 41\n3 55\n",
            "output": "Yes\n11 12 13 1 7 5 8 10 12 4 12 12 12 6 2 15 12 11 13 9 4 14 4 13 3 12 2 10 12 13 5 6 13 2 12 12 9 11 11 13 13 11 5 13 4 13 14 9 14 12 2 11 6 14 14 5 10 9 11 5 1 4 4 13 "
        },
        {
            "input": "3 3\n2 1\n2 3\n",
            "output": "Yes\n3 2 1 "
        },
        {
            "input": "5 2\n1 5\n1 2\n3 4\n4 5\n",
            "output": "Yes\n2 1 1 2 1 "
        },
        {
            "input": "13 10\n1 5\n5 3\n5 10\n10 2\n4 12\n1 9\n10 4\n5 7\n12 11\n3 13\n10 8\n12 6\n",
            "output": "Yes\n6 5 6 3 5 1 6 5 7 4 1 2 7 "
        },
        {
            "input": "5 2\n3 2\n1 4\n4 2\n4 5\n",
            "output": "Yes\n2 2 1 1 2 "
        },
        {
            "input": "64 45\n8 39\n8 42\n39 9\n8 37\n8 1\n42 12\n37 7\n7 5\n1 29\n9 40\n29 3\n1 50\n5 14\n14 6\n6 23\n23 25\n25 51\n25 34\n7 48\n1 35\n7 58\n58 57\n57 18\n40 54\n51 4\n5 53\n3 49\n29 33\n6 45\n26 24\n53 43\n64 62\n39 26\n8 52\n7 20\n25 27\n35 46\n18 13\n25 15\n53 56\n12 44\n8 38\n57 59\n5 32\n38 11\n46 47\n51 61\n56 63\n11 19\n56 10\n32 60\n19 22\n42 17\n42 2\n33 36\n11 30\n20 28\n14 31\n17 64\n54 16\n31 21\n2 41\n3 55\n",
            "output": "Yes\n11 12 13 1 7 5 8 10 12 4 12 12 12 6 2 15 12 11 13 9 4 14 4 13 3 12 2 10 12 13 5 6 13 2 12 14 9 11 11 13 13 11 5 13 4 13 14 9 14 12 2 11 6 14 14 5 10 9 11 5 1 14 4 13 "
        },
        {
            "input": "4 1\n3 2\n3 1\n2 4\n",
            "output": "Yes\n1 1 1 1 "
        },
        {
            "input": "7 5\n6 5\n6 3\n6 2\n1 7\n1 4\n2 4\n",
            "output": "Yes\n5 3 1 4 1 2 1 "
        },
        {
            "input": "7 3\n1 3\n2 3\n3 4\n4 5\n5 6\n5 4\n",
            "output": "No\n"
        },
        {
            "input": "7 1\n1 3\n2 3\n3 4\n4 5\n5 6\n5 7\n",
            "output": "No\n"
        },
        {
            "input": "7 4\n2 3\n3 5\n3 7\n7 4\n2 1\n4 6\n",
            "output": "No\n"
        },
        {
            "input": "7 4\n6 5\n6 3\n6 1\n3 7\n1 4\n2 4\n",
            "output": "No\n"
        },
        {
            "input": "7 1\n1 3\n2 6\n3 4\n4 5\n5 6\n5 7\n",
            "output": "No\n"
        },
        {
            "input": "7 4\n6 5\n6 3\n6 1\n1 7\n1 4\n2 4\n",
            "output": "No\n"
        },
        {
            "input": "7 4\n2 3\n3 5\n3 13\n7 4\n2 1\n5 6\n",
            "output": "No\n"
        },
        {
            "input": "7 3\n6 5\n6 3\n6 1\n3 7\n1 2\n2 4\n",
            "output": "No\n"
        },
        {
            "input": "5 2\n3 1\n1 4\n4 2\n4 5\n",
            "output": "Yes\n1 1 2 2 1 "
        },
        {
            "input": "7 3\n7 1\n7 2\n7 1\n7 3\n7 6\n7 4\n",
            "output": "No\n"
        },
        {
            "input": "7 1\n1 2\n2 3\n3 4\n4 5\n5 6\n5 7\n",
            "output": "No\n"
        },
        {
            "input": "7 4\n6 5\n6 3\n6 1\n3 7\n1 8\n2 4\n",
            "output": "No\n"
        },
        {
            "input": "7 1\n1 3\n2 6\n3 4\n4 5\n5 6\n3 7\n",
            "output": "No\n"
        },
        {
            "input": "7 3\n11 1\n7 2\n7 1\n7 3\n7 6\n7 4\n",
            "output": "No\n"
        },
        {
            "input": "7 1\n1 2\n2 3\n3 4\n4 5\n5 6\n5 12\n",
            "output": "No\n"
        },
        {
            "input": "7 4\n6 4\n6 3\n6 1\n3 7\n1 8\n2 4\n",
            "output": "No\n"
        },
        {
            "input": "7 1\n1 3\n2 6\n3 6\n4 5\n5 6\n3 7\n",
            "output": "No\n"
        },
        {
            "input": "7 3\n11 1\n7 2\n7 1\n9 3\n7 6\n7 4\n",
            "output": "No\n"
        },
        {
            "input": "7 1\n6 4\n6 3\n6 1\n3 7\n1 8\n2 4\n",
            "output": "No\n"
        },
        {
            "input": "7 3\n11 1\n7 2\n7 1\n10 3\n7 6\n7 4\n",
            "output": "No\n"
        },
        {
            "input": "7 1\n6 4\n6 3\n6 1\n6 7\n1 8\n2 4\n",
            "output": "No\n"
        },
        {
            "input": "7 3\n7 3\n7 2\n7 1\n7 6\n7 6\n7 4\n",
            "output": "No\n"
        },
        {
            "input": "7 3\n2 5\n3 7\n7 3\n2 4\n4 1\n2 6\n",
            "output": "No\n"
        },
        {
            "input": "6 4\n6 4\n6 1\n4 2\n1 3\n6 5\n",
            "output": "No\n"
        },
        {
            "input": "7 4\n6 5\n2 3\n6 1\n3 7\n1 2\n2 4\n",
            "output": "No\n"
        },
        {
            "input": "7 3\n7 1\n7 2\n7 1\n7 6\n7 6\n7 4\n",
            "output": "No\n"
        },
        {
            "input": "7 3\n1 3\n2 3\n3 8\n4 5\n5 6\n5 4\n",
            "output": "No\n"
        },
        {
            "input": "7 1\n1 3\n2 3\n3 6\n4 5\n5 6\n5 7\n",
            "output": "No\n"
        },
        {
            "input": "7 1\n1 3\n2 6\n3 4\n3 5\n5 6\n5 7\n",
            "output": "No\n"
        },
        {
            "input": "7 1\n6 5\n6 3\n6 1\n1 7\n1 4\n2 4\n",
            "output": "No\n"
        },
        {
            "input": "7 1\n1 2\n2 3\n3 7\n4 5\n5 6\n5 7\n",
            "output": "No\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, root, d[200005], h[200005], res[200005];\nvector<int> a[200005];\nvoid dfs(int u, int p) {\n  int tmp = 0;\n  for (int i = 0; i < (int)a[u].size(); i++) {\n    int v = a[u][i];\n    if (v == p) continue;\n    d[v] = d[u] + 1;\n    dfs(v, u);\n    tmp = max(tmp, h[v]);\n  }\n  h[u] = max(d[u], tmp);\n}\nvoid color(int u, int p, int cur, int step, bool diameter = true) {\n  cur += step;\n  if (cur > k)\n    cur -= k;\n  else if (cur <= 0)\n    cur += k;\n  res[u] = cur;\n  int U = 0;\n  for (int i = 0; i < (int)a[u].size(); i++) {\n    int v = a[u][i];\n    if (v == p) continue;\n    if (diameter) {\n      if (U == 0 && h[v] == h[root]) {\n        U = v;\n        continue;\n      }\n      int len = h[v] - d[v] + 1;\n      if (k > 2 && len + d[u] >= k && len + h[root] - d[u] + 1 >= k) {\n        cout << \"No\";\n        exit(0);\n      } else if (len + d[u] >= k)\n        color(v, u, cur, step, false);\n      else\n        color(v, u, cur, -step, false);\n    } else\n      color(v, u, cur, step, false);\n  }\n  if (U) color(U, u, cur, step);\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    cin >> u >> v;\n    a[u].push_back(v);\n    a[v].push_back(u);\n  }\n  dfs(1, 0);\n  for (int i = 2; i <= n; i++)\n    if (d[i] == h[1]) root = i;\n  d[root] = 1;\n  dfs(root, 0);\n  color(root, 0, 0, 1);\n  cout << \"Yes\\n\";\n  for (int i = 1; i <= n; i++) cout << res[i] << \" \";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC_OPTIMIZE(\"ofast\")\nusing namespace std;\nconst long long MAXN = 1000000;\nvector<long long> g[MAXN];\nvector<long long> dp_up(MAXN);\nvector<pair<long long, long long>> dp_down1(MAXN);\nvector<pair<long long, long long>> dp_down2(MAXN);\nvector<pair<long long, long long>> dp_down3(MAXN);\nlong long n, k;\nvoid dfs_d(long long v, long long p = -1) {\n  long long v1 = 0;\n  long long i1 = -1;\n  long long v2 = -1;\n  long long i2 = -1;\n  long long v3 = -1;\n  long long i3 = -1;\n  for (auto u : g[v]) {\n    if (u != p) {\n      dfs_d(u, v);\n      if (v1 < dp_down1[u].first + 1) {\n        v3 = v2;\n        i3 = i2;\n        v2 = v1;\n        i2 = i1;\n        v1 = dp_down1[u].first + 1;\n        i1 = u;\n      } else {\n        if (v2 < dp_down1[u].first + 1) {\n          v3 = v2;\n          i3 = i2;\n          v2 = dp_down1[u].first + 1;\n          i2 = u;\n        } else {\n          if (v3 < dp_down1[u].first + 1) {\n            v3 = dp_down1[u].first + 1;\n            i3 = u;\n          }\n        }\n      }\n    }\n  }\n  dp_down1[v] = make_pair(v1, i1);\n  dp_down2[v] = make_pair(v2, i2);\n  dp_down3[v] = make_pair(v3, i3);\n}\nvoid dfs_u(long long v, long long p = -1) {\n  for (auto u : g[v]) {\n    if (p != u) {\n      dp_up[u] = dp_up[v] + 1;\n      if (u != dp_down1[v].second && dp_down1[v].second != -1) {\n        dp_up[u] = max(dp_up[u], 1 + dp_down1[v].first);\n      } else {\n        if (u != dp_down2[v].second && dp_down2[v].second != -1) {\n          dp_up[u] = max(dp_up[u], 1 + dp_down2[v].first);\n        }\n      }\n      dfs_u(u, v);\n    }\n  }\n}\nlong long ansd = -1;\nlong long ansi = -1;\nvoid dfs57(long long v, long long p = -1, long long dist = 0) {\n  if (dist > ansd) {\n    ansd = dist;\n    ansi = v;\n  }\n  for (auto u : g[v]) {\n    if (u != p) {\n      dfs57(u, v, dist + 1);\n    }\n  }\n}\nvector<long long> diam;\nvector<long long> now;\nlong long t1, t2;\nvoid dfs58(long long v, long long p = -1) {\n  now.push_back(v);\n  if (v == t2) {\n    diam = now;\n  }\n  for (auto u : g[v]) {\n    if (u != p) {\n      dfs58(u, v);\n    }\n  }\n  now.pop_back();\n}\nvector<bool> used_d(MAXN);\nvector<long long> ans(MAXN);\nvoid dfs59(long long v, long long p = -1) {\n  for (auto u : g[v]) {\n    if (u != p && !used_d[u]) {\n      ans[u] = (ans[v] + 1) % k;\n      dfs59(u, v);\n    }\n  }\n}\nvoid dfs60(long long v, long long p = -1) {\n  for (auto u : g[v]) {\n    if (u != p && !used_d[u]) {\n      ans[u] = (ans[v] - 1 + k) % k;\n      dfs60(u, v);\n    }\n  }\n}\nsigned main() {\n  cin >> n >> k;\n  for (long long i = 0; i < n - 1; i++) {\n    long long a, b;\n    cin >> a >> b;\n    a--;\n    b--;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  dp_up[0] = 0;\n  dfs_d(0);\n  dfs_u(0);\n  for (long long i = 0; i < n; i++) {\n  }\n  for (long long i = 0; i < n; i++) {\n  }\n  for (long long i = 0; i < n; i++) {\n    vector<long long> arr;\n    if (i != 0) {\n      arr.push_back(dp_up[i]);\n    }\n    if (dp_down1[i].second != -1) {\n      arr.push_back(dp_down1[i].first);\n    }\n    if (dp_down2[i].second != -1) {\n      arr.push_back(dp_down2[i].first);\n    }\n    if (dp_down3[i].second != -1) {\n      arr.push_back(dp_down3[i].first);\n    }\n    if (arr.size() > 2) {\n      sort(arr.rbegin(), arr.rend());\n      if (k != 2 && arr[1] + arr[2] >= k - 1 && arr[2] != 0) {\n        cout << \"No \\n\";\n        return 0;\n      }\n    }\n  }\n  dfs57(0);\n  t1 = ansi;\n  ansd = -1;\n  ansi = -1;\n  dfs57(t1);\n  t2 = ansi;\n  dfs58(t1);\n  for (long long i = 0; i < diam.size(); i++) {\n    used_d[diam[i]] = true;\n  }\n  long long now_ans = 0;\n  for (long long i = 0; i < diam.size(); i++) {\n    ans[diam[i]] = now_ans;\n    now_ans++;\n    if (now_ans == k) {\n      now_ans = 0;\n    }\n  }\n  for (long long i = 0; i < diam.size() / 2; i++) {\n    dfs60(diam[i]);\n  }\n  for (long long i = diam.size() / 2; i < diam.size(); i++) {\n    dfs59(diam[i]);\n  }\n  cout << \"Yes \\n\";\n  for (long long i = 0; i < n; i++) {\n    cout << ans[i] + 1 << \" \";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <typename T>\ninline void read(T &x) {\n  x = 0;\n  char c = getchar();\n  bool flag = false;\n  while (!isdigit(c)) {\n    if (c == '-') flag = true;\n    c = getchar();\n  }\n  while (isdigit(c)) x = x * 10 + (c ^ 48), c = getchar();\n  if (flag) x = -x;\n}\nusing namespace std;\nint n, K;\nstruct edge {\n  int nxt, to;\n  edge() {}\n  edge(int jzp, int zzz) { nxt = jzp, to = zzz; }\n} e[201000 << 1];\nint head[201000], ecnt = 1;\ninline void addedge(int from, int to) {\n  e[++ecnt] = edge(head[from], to);\n  head[from] = ecnt;\n}\nint que[201000], front, rear;\nint dep[201000], pre[201000];\ninline int BFS1(int s) {\n  memset(dep, 0x3f, sizeof(dep));\n  front = rear = 0;\n  que[++rear] = s;\n  dep[s] = 0;\n  while (front < rear) {\n    int cur = que[++front];\n    for (int i = head[cur]; i; i = e[i].nxt) {\n      int to = e[i].to;\n      if (dep[to] <= dep[cur] + 1) continue;\n      dep[to] = dep[cur] + 1;\n      que[++rear] = to;\n    }\n  }\n  int mx = 0, mxp = 0;\n  for (int i = 1; i <= n; ++i)\n    if (dep[i] > mx) mx = dep[i], mxp = i;\n  return mxp;\n}\nint h[201000], htot;\nbool inh[201000];\ninline void BFS2(int s) {\n  memset(dep, 0x3f, sizeof(dep));\n  front = rear = 0;\n  que[++rear] = s;\n  dep[s] = 0;\n  while (front < rear) {\n    int cur = que[++front];\n    for (int i = head[cur]; i; i = e[i].nxt) {\n      int to = e[i].to;\n      if (dep[to] <= dep[cur] + 1) continue;\n      dep[to] = dep[cur] + 1;\n      que[++rear] = to;\n      pre[to] = cur;\n    }\n  }\n  int mx = 0, mxp = 0;\n  for (int i = 1; i <= n; ++i)\n    if (dep[i] > mx) mx = dep[i], mxp = i;\n  int np = mxp;\n  while (np) {\n    h[++htot] = np;\n    inh[np] = true;\n    np = pre[np];\n  }\n}\nint dis[2][201000];\ninline void BFS3(int s, int t) {\n  memset(dis[t], 0x3f, sizeof(dis[t]));\n  front = rear = 0;\n  que[++rear] = s;\n  dis[t][s] = 0;\n  while (front < rear) {\n    int cur = que[++front];\n    for (int i = head[cur]; i; i = e[i].nxt) {\n      int to = e[i].to;\n      if (dis[t][to] < 201000) continue;\n      dis[t][to] = dis[t][cur] + 1;\n      que[++rear] = to;\n    }\n  }\n}\nint col[201000];\nint depcol[201000];\nvoid dfs_dep(int cur, int faa, int nwd) {\n  if (col[cur]) depcol[nwd] = col[cur];\n  for (int i = head[cur]; i; i = e[i].nxt) {\n    int to = e[i].to;\n    if (to == faa) continue;\n    dfs_dep(to, cur, nwd + 1);\n  }\n}\nvoid dfs_ans(int cur, int faa, int nwd) {\n  col[cur] = depcol[nwd];\n  for (int i = head[cur]; i; i = e[i].nxt) {\n    int to = e[i].to;\n    if (to == faa) continue;\n    dfs_ans(to, cur, nwd + 1);\n  }\n}\ninline void Failed() {\n  puts(\"No\");\n  exit(0);\n}\nint main() {\n  read(n), read(K);\n  for (int i = 1; i < n; ++i) {\n    int u, v;\n    read(u), read(v);\n    addedge(u, v), addedge(v, u);\n  }\n  int S = BFS1(1);\n  BFS2(S);\n  BFS3(h[1], 0);\n  BFS3(h[htot], 1);\n  if (K > 2) {\n    for (int i = 1; i <= n; ++i) {\n      if (!inh[i] && min(dis[0][i], dis[1][i]) >= K - 1) {\n        Failed();\n      }\n    }\n  }\n  for (int i = 1, c = 1; i <= htot; ++i) {\n    col[h[i]] = c;\n    if ((++c) > K) c = 1;\n  }\n  int midl = htot >> 1, midr = midl + 1;\n  dfs_dep(h[midl], h[midr], 0);\n  dfs_ans(h[midl], h[midr], 0);\n  memset(depcol, 0, sizeof(depcol));\n  dfs_dep(h[midr], h[midl], 0);\n  dfs_ans(h[midr], h[midl], 0);\n  puts(\"Yes\");\n  for (int i = 1; i <= n; ++i) printf(\"%d \", col[i]);\n  puts(\"\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2000000;\nint n, k, w;\nvector<int> g[N];\nint c[N], h[N], p[N];\nvector<int> v, nv;\nset<int> s;\nbool ok;\nvoid dfs_for_2(int v, int p) {\n  for (auto to : g[v]) {\n    if (to == p) continue;\n    c[to] = !c[v];\n    dfs_for_2(to, v);\n  }\n}\npair<int, int> dfs1(int v = 0, int p = -1, int h = 0) {\n  pair<int, int> tmp = {h, v};\n  for (auto to : g[v]) {\n    if (to == p) continue;\n    tmp = max(tmp, dfs1(to, v, h + 1));\n  }\n  return tmp;\n}\nvoid dfs2(int v, int pr = -1) {\n  p[v] = pr;\n  for (auto to : g[v]) {\n    if (to == pr) continue;\n    h[to] = h[v] + 1;\n    dfs2(to, v);\n  }\n}\npair<int, int> d1(int v, int col, int p = -1, int h = 0) {\n  c[v] = col;\n  int mx1 = 0, mx2 = 0;\n  for (auto to : g[v]) {\n    if (to == p || s.count(to) == 1) continue;\n    pair<int, int> q = d1(to, col - 1, v, h + 1);\n    q.first++;\n    q.second++;\n    if (q.first > mx1) {\n      mx2 = mx1;\n      mx1 = q.first;\n    }\n    if (q.second > mx2) {\n      mx2 = q.second;\n    }\n  }\n  return {mx1, mx2};\n}\npair<int, int> d2(int v, int col, int p = -1, int h = 0) {\n  c[v] = col;\n  int mx1 = 0, mx2 = 0;\n  for (auto to : g[v]) {\n    if (to == p || s.count(to) == 1) continue;\n    pair<int, int> q = d2(to, col + 1, v, h + 1);\n    q.first++;\n    q.second++;\n    if (q.first > mx1) {\n      mx2 = mx1;\n      mx1 = q.first;\n    }\n    if (q.second > mx2) {\n      mx2 = q.second;\n    }\n  }\n  return {mx1, mx2};\n}\nint main() {\n  cin >> n >> k;\n  w = 1;\n  for (int i = 1; i < n; i++) {\n    int x, y;\n    cin >> x >> y;\n    x--;\n    y--;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  if (k == 2) {\n    cout << \"Yes\\n\";\n    if (w) {\n      dfs_for_2(0, -1);\n      for (int i = 0; i < n; i++) {\n        cout << c[i] + 1 << ' ';\n      }\n    }\n    return 0;\n  }\n  dfs2(dfs1().second);\n  int mxn = 0;\n  for (int i = 0; i < n; i++) {\n    if (h[i] > h[mxn]) mxn = i;\n  }\n  while (mxn != -1) {\n    v.push_back(mxn);\n    s.insert(mxn);\n    mxn = p[mxn];\n  }\n  if (v.size() < k) {\n    cout << \"Yes\\n\";\n    if (w) {\n      for (int i = 0; i < n; i++) {\n        cout << 1 << ' ';\n      }\n    }\n    return 0;\n  }\n  nv.resize((int)v.size());\n  for (int i = 0; i < v.size(); i++) {\n    c[v[i]] = i;\n  }\n  int tmp = k - 2;\n  for (int i = 0; i < (int)v.size() / 2; i++) {\n    nv[i] = min(tmp, i);\n    if (tmp > 0) tmp--;\n    ok = 1;\n    pair<int, int> w = d1(v[i], c[v[i]]);\n    if (!ok || w.first > nv[i]) {\n      cout << \"No\";\n      return 0;\n    }\n  }\n  tmp = k - 2;\n  for (int i = (int)v.size() - 1; i >= (int)v.size() / 2; i--) {\n    nv[i] = min(tmp, (int)v.size() - i - 1);\n    if (tmp > 0) tmp--;\n    ok = 1;\n    pair<int, int> w = d2(v[i], c[v[i]]);\n    if (!ok || w.first > nv[i]) {\n      cout << \"No\";\n      return 0;\n    }\n  }\n  cout << \"Yes\\n\";\n  if (w) {\n    for (int i = 0; i < n; i++) {\n      if (c[i] < 0) return 228;\n      cout << c[i] % k + 1 << ' ';\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nvector<int> g[210000];\nint f[210000];\nint d[210000];\nint color[210000];\nint b;\nvoid ddfs(int v, int p) {\n  d[v] = (p == -1 ? 0 : d[p] + 1);\n  f[v] = p;\n  if (d[v] > d[b]) b = v;\n  for (int x : g[v])\n    if (x != p) ddfs(x, v);\n}\nint cdfs(int v, int p, int c, int d) {\n  c = (((c + d) % k) + k) % k;\n  color[v] = c;\n  int h = 1;\n  for (int x : g[v])\n    if (x != p) {\n      h = max(h, cdfs(x, v, c, d) + 1);\n    }\n  return h;\n}\nvoid solve() {\n  scanf(\"%d %d\", &n, &k);\n  for (int i = 0; i < (n - 1); ++i) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    a--;\n    b--;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  b = 0;\n  ddfs(0, -1);\n  ddfs(b, -1);\n  vector<int> path;\n  while (b != -1) {\n    path.push_back(b);\n    b = f[b];\n  }\n  for (int i = 0; i < path.size(); i++) {\n    color[path[i]] = i % k;\n    for (int x : g[path[i]]) {\n      if (i != 0 && path[i - 1] == x) continue;\n      if (i + 1 < path.size() && path[i + 1] == x) continue;\n      int left = i + 1;\n      int right = path.size() - i;\n      int delta = (right > left ? -1 : +1);\n      int h = cdfs(x, path[i], i % k, delta);\n      if (h + min(left, right) >= k && k > 2) {\n        printf(\"No\");\n        return;\n      }\n    }\n  }\n  printf(\"Yes\\n\");\n  for (int i = 0; i < (n); ++i) printf(\"%d \", color[i] + 1);\n}\nint main() { solve(); }\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline void cmin(T &a, T b) {\n  ((a > b) && (a = b));\n}\ntemplate <class T>\ninline void cmax(T &a, T b) {\n  ((a < b) && (a = b));\n}\nchar IO;\ntemplate <class T = int>\nT rd() {\n  T s = 0;\n  int f = 0;\n  while (!isdigit(IO = getchar())) f |= IO == '-';\n  do s = (s << 1) + (s << 3) + (IO ^ '0');\n  while (isdigit(IO = getchar()));\n  return f ? -s : s;\n}\nconst int N = 2e5 + 10, INF = 1e9 + 10;\nint n, k;\nvector<int> G[N];\nint col[N];\nint ma, id, fa[N];\nvoid dfs(int u, int f, int d) {\n  fa[u] = f;\n  if (d > ma) ma = d, id = u;\n  for (int v : G[u])\n    if (v != f) dfs(v, u, d + 1);\n}\nint A[N], C, vis[N], dp[N][2];\nvoid dfs2(int u, int c, int d, int delta) {\n  col[u] = c, vis[u] = 1;\n  for (int v : G[u])\n    if (!vis[v]) {\n      dfs2(v, (c + delta + k) % k, d + 1, delta);\n      int t = dp[v][0] + 1;\n      for (int j = 0, jend = 1; j <= jend; ++j)\n        if (t > dp[u][j]) swap(dp[u][j], t);\n    }\n  if (dp[u][1] > 0 && dp[u][0] + dp[u][1] >= k - 1) puts(\"No\"), exit(0);\n}\nnamespace pt1 {\nvoid dfs(int u, int f) {\n  for (int v : G[u])\n    if (v != f) col[v] = col[u] ^ 1, dfs(v, u);\n}\nvoid Solve() {\n  dfs(1, 0);\n  puts(\"Yes\");\n  for (int i = 1, iend = n; i <= iend; ++i) printf(\"%d \", col[i] + 1);\n}\n}  // namespace pt1\nint main() {\n  n = rd(), k = rd();\n  for (int i = 2, iend = n; i <= iend; ++i) {\n    int u = rd(), v = rd();\n    G[u].push_back(v), G[v].push_back(u);\n  }\n  if (k == 2) return pt1::Solve(), 0;\n  ma = -1, dfs(1, 0, 0), ma = -1, dfs(id, 0, 0);\n  for (int u = id; u; u = fa[u]) A[++C] = u, vis[u] = 1;\n  for (int i = 1, iend = C; i <= iend; ++i) {\n    dfs2(A[i], i % k, max(C - i, i - 1), C - i >= i - 1 ? -1 : 1);\n    if (dp[A[i]][0] > 0 && dp[A[i]][0] + min(i - 1, C - i) >= k - 1)\n      puts(\"No\"), exit(0);\n  }\n  puts(\"Yes\");\n  for (int i = 1, iend = n; i <= iend; ++i) printf(\"%d \", col[i] + 1);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 212345;\nint n, k, s, t, f[maxn], dep[maxn], deps[maxn], dept[maxn], col[maxn];\nbool in[maxn];\nvector<int> G[maxn];\nvoid dfs1(int u, int fa, int *mdep) {\n  mdep[u] = dep[u] = dep[fa] + 1;\n  f[u] = fa;\n  for (int i = 0; i < (int)G[u].size(); ++i) {\n    int v = G[u][i];\n    if (v == fa) continue;\n    dfs1(v, u, mdep);\n    mdep[u] = max(mdep[u], mdep[v]);\n  }\n}\nvoid dfs(int u, int fa, int c) {\n  if (in[u])\n    c = c % k + 1;\n  else {\n    int cnt = 0;\n    if (deps[u] >= k) ++cnt;\n    if (dept[u] >= k) ++cnt;\n    if (cnt == 2) {\n      puts(\"No\");\n      exit(0);\n    }\n    if (deps[u] >= k)\n      c = c % k + 1;\n    else\n      c = (c + k - 2) % k + 1;\n  }\n  col[u] = c;\n  for (int i = 0; i < (int)G[u].size(); ++i) {\n    int v = G[u][i];\n    if (v == fa) continue;\n    dfs(v, u, c);\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 0; i < n - 1; ++i) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  dfs1(1, 0, deps);\n  if (k == 2) {\n    puts(\"Yes\");\n    for (int i = 1; i <= n; ++i)\n      printf(\"%d%c\", dep[i] % 2 + 1, i == n ? '\\n' : ' ');\n    return 0;\n  }\n  for (int i = 1; i <= n; ++i)\n    if (dep[i] > dep[s]) s = i;\n  dfs1(s, 0, deps);\n  for (int i = 1; i <= n; ++i)\n    if (dep[i] > dep[t]) t = i;\n  int tt = t;\n  while (tt) {\n    in[tt] = true;\n    tt = f[tt];\n  }\n  dfs1(t, 0, dept);\n  dfs(s, 0, 0);\n  puts(\"Yes\");\n  for (int i = 1; i <= n; ++i) printf(\"%d%c\", col[i], i == n ? '\\n' : ' ');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename TH>\nvoid _dbg(const char* sdbg, TH h) {\n  cerr << sdbg << \"=\" << h << \"\\n\";\n}\ntemplate <typename TH, typename... TA>\nvoid _dbg(const char* sdbg, TH h, TA... t) {\n  while (*sdbg != ',') {\n    cerr << *sdbg++;\n  }\n  cerr << \"=\" << h << \",\";\n  _dbg(sdbg + 1, t...);\n}\ntemplate <class C>\nvoid mini(C& a4, C b4) {\n  a4 = min(a4, b4);\n}\ntemplate <class C>\nvoid maxi(C& a4, C b4) {\n  a4 = max(a4, b4);\n}\ntemplate <class T1, class T2>\nostream& operator<<(ostream& out, pair<T1, T2> pair) {\n  return out << \"(\" << pair.first << \", \" << pair.second << \")\";\n}\ntemplate <class A, class B, class C>\nstruct Triple {\n  A first;\n  B second;\n  C third;\n  bool operator<(const Triple& t) const {\n    if (first != t.first) return first < t.first;\n    if (second != t.second) return second < t.second;\n    return third < t.third;\n  }\n};\ntemplate <class T>\nvoid ResizeVec(T&, vector<long long>) {}\ntemplate <class T>\nvoid ResizeVec(vector<T>& vec, vector<long long> sz) {\n  vec.resize(sz[0]);\n  sz.erase(sz.begin());\n  if (sz.empty()) {\n    return;\n  }\n  for (T& v : vec) {\n    ResizeVec(v, sz);\n  }\n}\ntemplate <class A, class B, class C>\nostream& operator<<(ostream& out, Triple<A, B, C> t) {\n  return out << \"(\" << t.first << \", \" << t.second << \", \" << t.third << \")\";\n}\ntemplate <class T>\nostream& operator<<(ostream& out, vector<T> vec) {\n  out << \"(\";\n  for (auto& v : vec) out << v << \", \";\n  return out << \")\";\n}\ntemplate <class T>\nostream& operator<<(ostream& out, set<T> vec) {\n  out << \"(\";\n  for (auto& v : vec) out << v << \", \";\n  return out << \")\";\n}\ntemplate <class L, class R>\nostream& operator<<(ostream& out, map<L, R> vec) {\n  out << \"(\";\n  for (auto& v : vec) out << v << \", \";\n  return out << \")\";\n}\nstruct LCA {\n  LCA(const vector<vector<long long> >& their_slo, long long root = 1) {\n    M = 1;\n    while (M <= 2 * ((long long)(their_slo).size())) {\n      M *= 2;\n    }\n    my_slo.resize(M);\n    for (long long i = 0; i < (((long long)(their_slo).size())); ++i) {\n      for (auto nei : their_slo[i]) {\n        my_slo[i].push_back(nei);\n      }\n    }\n    drz.resize(2 * M + 5);\n    pre.resize(M);\n    inv.resize(M);\n    vis.resize(M);\n    ind.resize(M);\n    dep.resize(M);\n    d = 1;\n    akt = 1;\n    dfs(root);\n    for (long long i = M - 1; i >= 1; i--) {\n      drz[i] = min(drz[2 * i], drz[2 * i + 1]);\n    }\n  }\n  long long M;\n  vector<long long> drz;\n  vector<long long> pre;\n  vector<long long> inv;\n  vector<long long> vis;\n  vector<long long> ind;\n  vector<long long> dep;\n  vector<vector<long long> > my_slo;\n  long long d;\n  long long akt;\n  long long Lca(long long a, long long b) {\n    a = pre[a];\n    b = pre[b];\n    long long w;\n    w = czyt(min(ind[a], ind[b]), max(ind[a], ind[b]));\n    return inv[w];\n  }\n  long long Dis(long long a, long long b) {\n    return dep[a] + dep[b] - 2 * dep[Lca(a, b)];\n  }\n\n private:\n  long long czyt(long long a, long long b) {\n    a += M - 1;\n    b += M - 1;\n    long long mini = M;\n    mini = min(mini, drz[a]);\n    mini = min(mini, drz[b]);\n    while (a / 2 != b / 2) {\n      if (a % 2 == 0) {\n        mini = min(mini, drz[a + 1]);\n      }\n      if (b % 2 == 1) {\n        mini = min(mini, drz[b - 1]);\n      }\n      a /= 2;\n      b /= 2;\n    }\n    return mini;\n  }\n  void dfs(long long v) {\n    vis[v] = 1;\n    pre[v] = d;\n    inv[d] = v;\n    d++;\n    drz[akt + M - 1] = pre[v];\n    ind[pre[v]] = akt;\n    akt++;\n    for (long long nei : my_slo[v]) {\n      if (vis[nei]) {\n        continue;\n      }\n      dep[nei] = dep[v] + 1;\n      dfs(nei);\n      drz[akt + M - 1] = pre[v];\n      ind[pre[v]] = akt;\n      akt++;\n    }\n  }\n};\nconst long long N = 2e5 + 5;\nlong long dep[N];\nlong long hei[N];\nlong long par[N];\nlong long vis[N];\nvector<vector<long long> > slo;\nlong long furthest;\nlong long dis0[N], dis1[N], dis2[N];\nvoid Dfs(long long v) {\n  vis[v] = 1;\n  if (dis0[v] > dis0[furthest]) {\n    furthest = v;\n  }\n  hei[v] = 0;\n  for (auto nei : slo[v]) {\n    if (vis[nei]) {\n      continue;\n    }\n    dis0[nei] = dis0[v] + 1;\n    par[nei] = v;\n    Dfs(nei);\n    maxi(hei[v], hei[nei] + 1);\n  }\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  if (0) cout << fixed << setprecision(10);\n  cin.tie(0);\n  long long n, k;\n  cin >> n >> k;\n  slo.resize(n + 2);\n  for (long long i = (1); i <= (n - 1); ++i) {\n    long long a, b;\n    cin >> a >> b;\n    slo[a].push_back(b);\n    slo[b].push_back(a);\n  }\n  LCA lca(slo);\n  Dfs(1);\n  long long e1 = furthest;\n  for (long long i = (1); i <= (n); ++i) {\n    vis[i] = 0;\n    dis0[i] = 0;\n  }\n  Dfs(e1);\n  for (long long i = (1); i <= (n); ++i) {\n    vis[i] = 0;\n    dis1[i] = dis0[i];\n    dis0[i] = 0;\n  }\n  long long e2 = furthest;\n  Dfs(e2);\n  for (long long i = (1); i <= (n); ++i) {\n    dis2[i] = dis0[i];\n    vis[i] = 0;\n    dis0[i] = 0;\n  }\n  Dfs(e1);\n  long long diam = dis1[e2];\n  if (k == 2 || diam < k - 1) {\n    cout << \"Yes\\n\";\n    for (long long i = (1); i <= (n); ++i) {\n      cout << 1 + (dis1[i] % 2) << \" \";\n    }\n    cout << endl;\n    return 0;\n  }\n  vector<long long> res(n + 2);\n  for (long long i = (1); i <= (n); ++i) {\n    long long is_on_diam = ((dis1[i] + dis2[i]) == diam);\n    vector<long long> sons;\n    for (auto son : slo[i]) {\n      if (par[i] == son) {\n        continue;\n      }\n      sons.push_back(hei[son] + 1);\n    }\n    sort((sons).begin(), (sons).end(), greater<long long>());\n    long long third = 0;\n    if (((long long)(sons).size()) <= is_on_diam) {\n      third = 0;\n    } else {\n      third = sons[is_on_diam];\n    }\n    if (!is_on_diam && min(dis1[i], dis2[i]) + 1 >= k) {\n      cout << \"No\\n\";\n      return 0;\n    }\n    long long to_diam = (dis1[i] + dis2[i] - diam) / 2;\n    if (dis2[i] <= dis1[i]) {\n      res[i] = dis1[i] % k;\n    } else {\n      res[i] = (dis1[i] - 2 * to_diam) % k;\n    }\n  }\n  cout << \"Yes\\n\";\n  for (long long i = (1); i <= (n); ++i) {\n    cout << res[i] + 1 << \" \";\n  }\n  cout << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"fast-math\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,popcnt,abm,mmx,tune=native\")\nusing namespace std;\ntemplate <typename T>\nvoid uin(T &a, T b) {\n  if (b < a) {\n    a = b;\n  }\n}\ntemplate <typename T>\nvoid uax(T &a, T b) {\n  if (b > a) {\n    a = b;\n  }\n}\nconst long long N = 228228;\nconst long long INF = 1e9 + 228;\nlong long k, n;\nvector<long long> g[N];\nlong long dist[N];\nlong long far(long long a) {\n  for (long long i = 1; i <= n; ++i) {\n    dist[i] = INF;\n  }\n  dist[a] = 0;\n  vector<long long> q;\n  q.push_back(a);\n  for (long long i = 0; i < (long long)q.size(); ++i) {\n    long long v = q[i];\n    for (long long to : g[v]) {\n      if (dist[v] + 1 < dist[to]) {\n        dist[to] = dist[v] + 1;\n        q.push_back(to);\n      }\n    }\n  }\n  long long mx = 0;\n  for (long long i = 1; i <= n; ++i) {\n    if (dist[i] > dist[mx]) {\n      mx = i;\n    }\n  }\n  return mx;\n}\nvector<long long> diA;\nvector<long long> curv;\nvoid dfs(long long v, long long t, long long par = -1) {\n  curv.push_back(v);\n  if (v == t) {\n    diA = curv;\n  } else {\n    for (long long to : g[v]) {\n      if (to != par) {\n        dfs(to, t, v);\n      }\n    }\n  }\n  curv.pop_back();\n}\nvector<long long> find_diametr() {\n  diA.clear();\n  long long a = far(1);\n  long long b = far(a);\n  dfs(a, b);\n  return diA;\n}\nlong long nxt(long long a) {\n  ++a;\n  if (a > k) a = 1;\n  return a;\n}\nlong long pv(long long a) {\n  --a;\n  if (!a) a = k;\n  return a;\n}\nlong long color[N], deep[N];\nbool blocked[N];\nvoid jfs(long long v, long long c, long long delta, long long par = -1) {\n  color[v] = c;\n  for (long long to : g[v]) {\n    if (to == par) continue;\n    if (!blocked[to]) {\n      long long nc = c;\n      if (delta == 1)\n        nc = nxt(c);\n      else\n        nc = pv(c);\n      jfs(to, nc, delta, v);\n    }\n  }\n}\nmap<pair<long long, long long>, long long> value;\nvoid DFS(long long v, long long par = -1) {\n  long long sz = 0;\n  vector<long long> sons;\n  for (long long to : g[v]) {\n    if (to != par) {\n      DFS(to, v);\n      uax(deep[v], 1 + deep[to]);\n      ++sz;\n      sons.push_back(to);\n    }\n  }\n  vector<long long> pref(sz + 1), suff(sz + 2);\n  for (long long i = 1; i <= sz; ++i) {\n    pref[i] = max(pref[i - 1], deep[sons[i - 1]]);\n  }\n  for (long long i = sz; i; --i) {\n    suff[i] = max(suff[i + 1], deep[sons[i - 1]]);\n  }\n  for (long long i = 1; i <= sz; ++i) {\n    value[{v, sons[i - 1]}] = value[{sons[i - 1], v}] =\n        max(pref[i - 1], suff[i + 1]) + (sz > 1 ? 1 : 0);\n  }\n}\nlong long up[N];\nvoid JFS(long long v, long long par = -1) {\n  vector<long long> sons;\n  for (long long to : g[v]) {\n    if (to != par) {\n      sons.push_back(to);\n    }\n  }\n  sort(sons.begin(), sons.end(),\n       [&](long long i, long long j) { return deep[i] > deep[j]; });\n  if (par == -1) {\n    if (sons.size() > 2) {\n      long long a = deep[sons[0]], b = deep[sons[1]], c = deep[sons[2]];\n      if (a + b >= k - 1 && b + c >= k - 1 && a + c >= k - 1) {\n        cout << \"No\\n\";\n        exit(0);\n      }\n    }\n  } else {\n    reverse(sons.begin(), sons.end());\n    uax(up[v], up[par] + 1);\n    uax(up[v], 1 + value[{par, v}]);\n    vector<long long> kek;\n    long long it = 3;\n    while (!sons.empty() && it--) {\n      kek.push_back(deep[sons.back()] + 1);\n      sons.pop_back();\n    }\n    kek.push_back(up[v]);\n    sort(kek.rbegin(), kek.rend());\n    if (kek.size() > 2) {\n      long long a = kek[0], b = kek[1], c = kek[2];\n      if (a + b >= k - 1 && b + c >= k - 1 && a + c >= k - 1) {\n        cout << \"No\\n\";\n        exit(0);\n      }\n    }\n  }\n  for (long long to : g[v]) {\n    if (to != par) {\n      JFS(to, v);\n    }\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> k;\n  for (long long i = 0; i < n - 1; ++i) {\n    long long u, v;\n    cin >> u >> v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  if (k > 2) {\n    DFS(1);\n    JFS(1);\n  }\n  vector<long long> dia = find_diametr();\n  for (long long i = 0; i < (long long)dia.size(); ++i) {\n    color[dia[i]] = i % k + 1;\n    blocked[dia[i]] = 1;\n  }\n  for (long long i = 0; i < (long long)dia.size() / 2; ++i) {\n    for (long long to : g[dia[i]]) {\n      if (!blocked[to]) {\n        jfs(to, pv(color[dia[i]]), -1);\n      }\n    }\n  }\n  for (long long i = (long long)dia.size() / 2; i < (long long)dia.size();\n       ++i) {\n    for (long long to : g[dia[i]]) {\n      if (!blocked[to]) {\n        jfs(to, nxt(color[dia[i]]), 1);\n      }\n    }\n  }\n  cout << \"Yes\\n\";\n  for (long long i = 1; i <= n; ++i) {\n    cout << color[i] << ' ';\n  }\n  cout << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = (int)2e5 + 123, inf = 1e9, mod = 1e9 + 7;\nconst long long INF = 1e18;\nvector<int> g[N];\nint n, k, col[N], d1[N], d2[N];\nint dp[N], dp2[N];\nvoid DFS(int v, int pr) {\n  dp[v] = 1;\n  for (auto to : g[v]) {\n    if (to == pr) continue;\n    DFS(to, v);\n    dp[v] = max(dp[v], dp[to] + 1);\n  }\n}\nvoid DFS2(int v, int pr) {\n  vector<pair<int, int> > vv;\n  vv.push_back({0, 0});\n  for (auto to : g[v]) {\n    if (to == pr)\n      vv.push_back({dp2[v], v});\n    else\n      vv.push_back({dp[to], to});\n  }\n  sort(vv.begin(), vv.end());\n  reverse(vv.begin(), vv.end());\n  if (vv.size() >= 4 && vv[1].first + vv[2].first >= k - 1) {\n    printf(\"No\");\n    exit(0);\n  }\n  for (auto to : g[v]) {\n    if (to == pr) continue;\n    if (vv[0].second == to)\n      dp2[to] = vv[1].first + 1;\n    else\n      dp2[to] = vv[0].first + 1;\n    DFS2(to, v);\n  }\n}\nvoid f1(int v, int pr) {\n  d1[v] = d1[pr] + 1;\n  for (auto to : g[v])\n    if (to != pr) f1(to, v);\n}\nvoid f2(int v, int pr) {\n  d2[v] = d2[pr] + 1;\n  for (auto to : g[v])\n    if (to != pr) f2(to, v);\n}\nvoid ff(int v, int pr, int x, int y) {\n  x = (x + y + k) % k;\n  col[v] = x;\n  for (auto to : g[v])\n    if (to != pr) ff(to, v, x, y);\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i < n; i++) {\n    int v, u;\n    scanf(\"%d%d\", &v, &u);\n    g[v].push_back(u);\n    g[u].push_back(v);\n  }\n  if (k > 2) {\n    DFS(1, 1);\n    DFS2(1, 1);\n  }\n  f1(1, 1);\n  int A = 1;\n  for (int i = 1; i <= n; i++)\n    if (d1[i] > d1[A]) A = i;\n  f2(A, A);\n  int B = 1;\n  for (int i = 1; i <= n; i++)\n    if (d2[i] > d2[B]) B = i;\n  int v = B, last = -1;\n  while (true) {\n    col[v] = d2[v] % k;\n    for (auto to : g[v])\n      if (d2[to] > d2[v] && to != last) {\n        if (d2[v] * 2 > d2[B])\n          ff(to, v, col[v], 1);\n        else\n          ff(to, v, col[v], k - 1);\n      }\n    if (v == A) break;\n    for (auto to : g[v]) {\n      if (d2[to] < d2[v]) {\n        last = v;\n        v = to;\n        break;\n      }\n    }\n  }\n  printf(\"Yes\\n\");\n  for (int i = 1; i <= n; i++) printf(\"%d \", col[i] + 1);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target( \\\n    \"avx,avx2,fma,sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\nlong long MOD = 1e9 + 7;\nlong long INF = 1e18;\nconst int N = 210000;\nvector<long long> gr[N];\nlong long d[N];\nlong long pr[N];\nlong long go(long long v, long long pr_) {\n  d[v] = d[pr_] + 1;\n  pr[v] = pr_;\n  long long ans = v;\n  for (auto i : gr[v]) {\n    if (i != pr_) {\n      long long a = go(i, v);\n      if (d[ans] < d[a]) {\n        ans = a;\n      }\n    }\n  }\n  return ans;\n}\nlong long used[N];\nlong long ogr[N];\nlong long ogr1[N];\nlong long ogr2[N];\nlong long cl[N];\nlong long gl[N];\nlong long dfs(long long v, long long pr_) {\n  gl[v] = gl[pr_] + 1;\n  if (used[v]) {\n    gl[v]--;\n  }\n  long long sz = gl[v];\n  for (auto i : gr[v]) {\n    if (!used[i] && i != pr_) {\n      sz = max(dfs(i, v), sz);\n    }\n  }\n  return sz;\n}\nlong long k;\nvoid cl1(long long v, long long pr_, long long c) {\n  cl[v] = c;\n  for (auto i : gr[v]) {\n    if (!used[i] && i != pr_) {\n      cl1(i, v, (c + 1) % k);\n    }\n  }\n}\nvoid cl2(long long v, long long pr_, long long c) {\n  cl[v] = c;\n  for (auto i : gr[v]) {\n    if (!used[i] && i != pr_) {\n      cl2(i, v, (c - 1 + k) % k);\n    }\n  }\n}\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0),\n      cout << fixed << setprecision(20);\n  long long n;\n  cin >> n >> k;\n  for (int i = 0; i < n - 1; i++) {\n    long long u, v;\n    cin >> u >> v;\n    u--, v--;\n    gr[u].push_back(v);\n    gr[v].push_back(u);\n  }\n  long long vv = go(0, 0);\n  d[vv] = 0;\n  long long uu = go(vv, vv);\n  long long nw = uu;\n  used[uu] = 1;\n  vector<long long> pt;\n  pt.push_back(uu);\n  while (nw != vv) {\n    nw = pr[nw];\n    pt.push_back(nw);\n    used[nw] = 1;\n  }\n  for (int i = 0; i < k - 1; i++) {\n    ogr1[i] = ogr[i] = k - i - 2;\n  }\n  for (int i = 0; i < k - 1; i++) {\n    long long nww = (long long)pt.size() - i - 1;\n    if (nww < 0) break;\n    ogr2[nww] = k - i - 2;\n    ogr[nww] = max(k - i - 2, ogr[nww]);\n  }\n  long long nwc = 0;\n  for (int i = 0; i < pt.size(); i++) {\n    if (k != 2 && dfs(pt[i], pt[i]) > ogr[i]) {\n      cout << \"No\";\n      return 0;\n    }\n    if (i < pt.size() / 2) {\n      cl2(pt[i], pt[i], nwc);\n    } else {\n      cl1(pt[i], pt[i], nwc);\n    }\n    nwc = (nwc + 1) % k;\n  }\n  cout << \"Yes\"\n       << \"\\n\";\n  for (int i = 0; i < n; i++) {\n    cout << cl[i] + 1 << \" \";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint read() {\n  int x = 0, y = 1;\n  char ch = ' ';\n  for (; (ch != '-' && (ch > '9' || ch < '0')); ch = getchar())\n    ;\n  if (ch == '-') y = -1, ch = getchar();\n  for (; ch >= '0' && ch <= '9'; ch = getchar()) x = x * 10 + ch - 48;\n  return x * y;\n}\nconst int N = 2e5 + 10;\nstruct node {\n  int to, nex;\n} e[N << 1];\nint bgn[N], d[N], fr[N], b[N], c[N], p[N];\nint n, m, cnt, tot, flag;\nvoid add(int x, int y) {\n  e[++cnt] = (node){y, bgn[x]};\n  bgn[x] = cnt;\n}\nvoid dfs(int x) {\n  for (register int i = bgn[x]; i; i = e[i].nex) {\n    int y = e[i].to;\n    if (d[y]) continue;\n    fr[y] = x;\n    d[y] = d[x] + 1;\n    dfs(y);\n  }\n}\nvoid solve(int x, int d, int op, int lim, int j) {\n  if (flag) return;\n  if (d + lim >= m) {\n    flag = 1;\n    return;\n  }\n  c[x] = c[p[j + op * d]];\n  for (register int i = bgn[x]; i; i = e[i].nex) {\n    int y = e[i].to;\n    if (!c[y]) solve(y, d + 1, op, lim, j);\n  }\n}\nvoid paint(int x, int op) {\n  c[x] = op;\n  for (register int i = bgn[x]; i; i = e[i].nex) {\n    int y = e[i].to;\n    if (!c[y]) paint(y, 3 - op);\n  }\n}\nint main() {\n  int x, y, z, k;\n  n = read();\n  m = read();\n  for (register int i = 1; i < n; ++i) {\n    x = read();\n    y = read();\n    add(x, y);\n    add(y, x);\n  }\n  if (m == 2) {\n    paint(1, 1);\n    puts(\"Yes\");\n    for (register int i = 1; i <= n; ++i) printf(\"%d \", c[i]);\n    return 0;\n  }\n  d[1] = 1;\n  dfs(1);\n  int mx = 0;\n  k = 0;\n  for (register int i = 1; i <= n; ++i) {\n    if (d[i] > mx) {\n      mx = d[i];\n      k = i;\n    }\n    d[i] = 0;\n  }\n  fr[k] = 0;\n  d[k] = 1;\n  mx = 0;\n  dfs(k);\n  for (register int i = 1; i <= n; ++i) {\n    if (d[i] > mx) {\n      mx = d[i];\n      k = i;\n    }\n  }\n  x = k;\n  while (x) {\n    b[x] = 1;\n    c[x] = d[x] % m + 1;\n    p[++tot] = x;\n    x = fr[x];\n  }\n  x = k;\n  for (register int z = 1; z <= tot; ++z) {\n    x = p[z];\n    int op, lim;\n    if (mx - d[x] > d[x] - 1) {\n      op = 1;\n      lim = d[x];\n    } else {\n      op = -1;\n      lim = mx - d[x] + 1;\n    }\n    for (register int i = bgn[x]; i; i = e[i].nex) {\n      int y = e[i].to;\n      if (!b[y]) solve(y, 1, op, lim, z);\n      if (flag) {\n        puts(\"No\");\n        return 0;\n      }\n    }\n  }\n  puts(\"Yes\");\n  for (register int i = 1; i <= n; ++i) printf(\"%d \", c[i]);\n  puts(\"\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma warning(disable : 4996)\nusing namespace std;\nusing ld = long double;\ntemplate <class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\ntemplate <class S, class T>\nostream &operator<<(ostream &os, const pair<S, T> v) {\n  os << \"( \" << v.first << \", \" << v.second << \")\";\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  for (int i = 0; i < v.size(); i++) {\n    if (i > 0) {\n      os << \" \";\n    }\n    os << v[i];\n  }\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<vector<T>> &v) {\n  for (int i = 0; i < v.size(); i++) {\n    if (i > 0) {\n      os << endl;\n    }\n    os << v[i];\n  }\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<set<T>> &v) {\n  for (int i = 0; i < v.size(); i++) {\n    if (i > 0) {\n      os << endl;\n    }\n    os << v[i];\n  }\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const set<T> &v) {\n  int i = 0;\n  for (auto it : v) {\n    if (i > 0) {\n      os << ' ';\n    }\n    os << it;\n    i++;\n  }\n  return os;\n}\nusing ll = long long;\nvoid dfs(int now, int from, const vector<vector<int>> &graph,\n         vector<int> &dists, int d) {\n  dists[now] = d;\n  for (auto e : graph[now]) {\n    if (e != from) dfs(e, now, graph, dists, d + 1);\n  }\n}\nvector<int> get_diamater(const vector<vector<int>> &graph) {\n  vector<int> dists(graph.size());\n  dfs(0, -1, graph, dists, 0);\n  int k = max_element(dists.begin(), dists.end()) - dists.begin();\n  dfs(k, -1, graph, dists, 0);\n  int j = max_element(dists.begin(), dists.end()) - dists.begin();\n  vector<int> dias;\n  int now = j;\n  while (now != k) {\n    dias.push_back(now);\n    for (auto e : graph[now]) {\n      if (dists[e] == dists[now] - 1) {\n        now = e;\n        break;\n      }\n    }\n  }\n  dias.push_back(now);\n  return dias;\n}\nvector<int> answers;\nvector<int> depths;\nusing Graph = vector<vector<int>>;\nvoid dfs(int now, int from, const Graph &g) {\n  depths[now] = 1;\n  for (auto e : g[now]) {\n    if (e == from)\n      continue;\n    else {\n      dfs(e, now, g);\n      depths[now] = max(depths[now], depths[e] + 1);\n    }\n  }\n}\nint K;\nvoid dfs2(int tt, int now, int from, int c, bool flag, const Graph &g,\n          vector<int> &cs) {\n  vector<int> max_ds(3);\n  max_ds.push_back(tt);\n  int mtt = tt + 1;\n  for (auto e : g[now]) {\n    if (e == from)\n      continue;\n    else {\n      max_ds.push_back(depths[e]);\n      mtt = max(mtt, depths[e] + 1);\n    }\n  }\n  sort(max_ds.begin(), max_ds.end());\n  reverse(max_ds.begin(), max_ds.end());\n  if (K >= 3 && max_ds[2] && max_ds[1] + max_ds[2] + 1 >= K) {\n    return;\n  } else {\n    cs[now] = c;\n  }\n  if (flag)\n    c++;\n  else\n    c--;\n  if (c >= K) c -= K;\n  if (c < 0) c += K;\n  for (auto e : g[now]) {\n    if (e == from) continue;\n    dfs2(mtt, e, now, c, flag, g, cs);\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  int N;\n  cin >> N >> K;\n  answers.resize(N);\n  depths.resize(N);\n  vector<vector<int>> g(N);\n  for (int i = 0; i < N - 1; ++i) {\n    int u, v;\n    cin >> u >> v;\n    u--;\n    v--;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  vector<int> dias = get_diamater(g);\n  int l, r;\n  if (dias.size() % 2 == 0) {\n    l = dias[dias.size() / 2 - 1];\n    r = dias[dias.size() / 2];\n  } else {\n    l = dias[dias.size() / 2 - 1];\n    r = dias[dias.size() / 2];\n  }\n  dfs(l, r, g);\n  dfs(r, l, g);\n  vector<int> cs(N, -1);\n  dfs2(depths[r], l, r, 0, false, g, cs);\n  dfs2(depths[l], r, l, 1, true, g, cs);\n  if (find(cs.begin(), cs.end(), -1) == cs.end()) {\n    cout << \"Yes\" << endl;\n    for (auto c : cs) cout << c + 1 << ' ';\n    cout << endl;\n  } else {\n    cout << \"No\" << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> adj[200200];\nint mx[200200][3];\nint dep[200200];\nint fa[200200];\nint dis[2][200200];\nvoid dfs0(int u, int *dep, int f = 0) {\n  dep[u] = dep[f] + 1;\n  fa[u] = f;\n  for (int v : adj[u]) {\n    if (v == f) continue;\n    dfs0(v, dep, u);\n  }\n}\nvoid dfs(int u, int f = 0) {\n  dep[u] = dep[f] + 1;\n  for (int v : adj[u]) {\n    if (v == f) continue;\n    dfs(v, u);\n    mx[u][2] = max(mx[u][2], mx[v][0] + 1);\n    if (mx[u][1] < mx[u][2]) swap(mx[u][1], mx[u][2]);\n    if (mx[u][0] < mx[u][1]) swap(mx[u][0], mx[u][1]);\n  }\n}\nvoid redfs(int u, int f = 0, int pre = 0) {\n  mx[u][2] = max(mx[u][2], pre);\n  if (mx[u][1] < mx[u][2]) swap(mx[u][1], mx[u][2]);\n  if (mx[u][0] < mx[u][1]) swap(mx[u][0], mx[u][1]);\n  for (int v : adj[u]) {\n    if (v == f) continue;\n    if (mx[u][0] == mx[v][0] + 1)\n      redfs(v, u, mx[u][1] + 1);\n    else\n      redfs(v, u, mx[u][0] + 1);\n  }\n}\nint col[200200];\nint main() {\n  int n, k;\n  cin >> n >> k;\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  dfs(1);\n  if (k == 2) {\n    puts(\"Yes\");\n    for (int i = 1; i <= n; i++) printf(\"%d \", dep[i] % 2 + 1);\n    return 0;\n  }\n  int U = 0;\n  for (int i = 1; i <= n; i++)\n    if (dep[U] < dep[i]) U = i;\n  dfs0(U, dis[0]);\n  int V = 0;\n  for (int i = 1; i <= n; i++)\n    if (dis[0][V] < dis[0][i]) V = i;\n  dfs0(V, dis[1]);\n  memset(col, -1, sizeof(col));\n  int cur = 0;\n  for (int u = U; u != V; u = fa[u], cur++) col[u] = cur % k;\n  col[V] = cur % k;\n  for (int i = 1; i <= n; i++)\n    if (col[i] == -1) {\n      if (dis[0][i] >= k && dis[1][i] >= k) {\n        puts(\"No\");\n        return 0;\n      }\n      if (dis[0][i] > dis[1][i])\n        col[i] = (k + dis[0][i] - 1) % k;\n      else\n        col[i] = ((col[V] - dis[1][i] + 1) % k + k) % k;\n    }\n  puts(\"Yes\");\n  for (int i = 1; i <= n; i++) printf(\"%d \", col[i] + 1);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct zero {\n  int nxt, to;\n} edge[210000 << 1];\nint head[210000], tot = 0;\nint n, k, ans[210000];\nint plk, poi, f[210000], dep[210000], kl[210000];\nbool vis[210000];\nvoid add_edge(int a, int b) {\n  edge[++tot] = (zero){head[a], b};\n  head[a] = tot;\n}\nvoid dfspl(int x, int fa) {\n  for (int i = head[x]; i; i = edge[i].nxt) {\n    int to = edge[i].to;\n    if (to == fa) continue;\n    ans[to] = 3 - ans[x];\n    dfspl(to, x);\n  }\n}\nvoid aux(int x, int fa) {\n  if (dep[x] > dep[plk]) plk = x;\n  for (int i = head[x]; i; i = edge[i].nxt) {\n    int to = edge[i].to;\n    if (to == fa) continue;\n    dep[to] = dep[x] + 1;\n    aux(to, x);\n  }\n}\nvoid dfs1(int x, int fa) {\n  if (dep[x] > dep[poi]) poi = x;\n  kl[x] = dep[x];\n  for (int i = head[x]; i; i = edge[i].nxt) {\n    int to = edge[i].to;\n    if (to == fa) continue;\n    dep[to] = dep[x] + 1, f[to] = x;\n    dfs1(to, x);\n    kl[x] = max(kl[x], kl[to]);\n  }\n}\nvoid solve(int x, int now, int op) {\n  ans[x] = now;\n  for (int i = head[x]; i; i = edge[i].nxt) {\n    int to = edge[i].to;\n    if (vis[to] || to == f[x]) continue;\n    solve(to, (now + op - 1 + k) % k + 1, op);\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i < n; i++) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    add_edge(a, b), add_edge(b, a);\n  }\n  if (k == 2) {\n    ans[1] = 1;\n    dfspl(1, 0);\n    puts(\"Yes\");\n    for (int i = 1; i <= n; i++) printf(\"%d \", ans[i]);\n    return 0;\n  }\n  dep[1] = 1, plk = 1;\n  aux(1, 0);\n  dep[plk] = 1, poi = plk;\n  dfs1(plk, 0);\n  int poss = poi;\n  int cnt = 1;\n  while (poss) {\n    vis[poss] = true;\n    ans[poss] = cnt;\n    for (int i = head[poss]; i; i = edge[i].nxt) {\n      int to = edge[i].to;\n      if (to == f[poss] || vis[to]) continue;\n      if (kl[to] >= k && (kl[to] + dep[poi] - 2 * dep[poss] + 1 >= k))\n        return puts(\"NO\"), 0;\n      if (kl[to] >= k)\n        solve(to, (cnt + k - 2) % k + 1, -1);\n      else\n        solve(to, cnt % k + 1, 1);\n    }\n    cnt = cnt % k + 1;\n    poss = f[poss];\n  }\n  puts(\"Yes\");\n  for (int i = 1; i <= n; i++) printf(\"%d \", ans[i]);\n  puts(\"\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nstruct Edge {\n  int v, nxt;\n} e[400010];\nint tot;\nint first[200010];\nvoid build(int u, int v) {\n  e[++tot] = (Edge){v, first[u]};\n  first[u] = tot;\n  return;\n}\nint f[200010], g[200010], h[200010];\nvoid solve1(int u, int lst) {\n  f[u] = 0;\n  g[u] = -1e9;\n  for (int i = first[u]; i; i = e[i].nxt)\n    if (e[i].v != lst) {\n      solve1(e[i].v, u);\n      if (f[e[i].v] + 1 > f[u]) {\n        g[u] = f[u];\n        f[u] = f[e[i].v] + 1;\n      } else\n        g[u] = max(g[u], f[e[i].v] + 1);\n    }\n  return;\n}\nvoid solve2(int u, int lst) {\n  if (!lst)\n    h[u] = -1e9;\n  else {\n    int val = f[lst];\n    if (f[lst] == f[u] + 1) val = g[lst];\n    h[u] = max(val, h[lst]) + 1;\n  }\n  int mx = h[u], mmx = -1e9, mmmx = -1e9;\n  for (int i = first[u]; i; i = e[i].nxt) {\n    int v = e[i].v;\n    if (v == lst) continue;\n    solve2(v, u);\n    if (f[v] + 1 > mx) {\n      mmmx = mmx;\n      mmx = mx;\n      mx = f[v] + 1;\n    } else if (f[v] + 1 > mmx) {\n      mmmx = mmx;\n      mmx = f[v] + 1;\n    } else\n      mmmx = max(mmmx, f[v] + 1);\n  }\n  if (mmmx + mmx >= k - 1) {\n    printf(\"No\\n\");\n    exit(0);\n  }\n  return;\n}\nint dis[200010];\nint fa[200010];\nvoid dfs(int u, int lst, int& S) {\n  fa[u] = lst;\n  dis[u] = dis[lst] + 1;\n  if (dis[u] > dis[S]) S = u;\n  for (int i = first[u]; i; i = e[i].nxt)\n    if (e[i].v != lst) dfs(e[i].v, u, S);\n  return;\n}\nint col[200010];\nvoid dfs1(int u, int now) {\n  col[u] = now;\n  for (int i = first[u]; i; i = e[i].nxt)\n    if (!col[e[i].v]) {\n      int tnow = now - 1;\n      if (!tnow) tnow = k;\n      dfs1(e[i].v, tnow);\n    }\n  return;\n}\nvoid dfs2(int u, int now) {\n  col[u] = now;\n  for (int i = first[u]; i; i = e[i].nxt)\n    if (!col[e[i].v]) {\n      int tnow = now + 1;\n      if (tnow > k) tnow -= k;\n      dfs2(e[i].v, tnow);\n    }\n  return;\n}\nint p[200010];\nint main() {\n  scanf(\"%d %d\", &n, &k);\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    build(u, v);\n    build(v, u);\n  }\n  if (k > 2) {\n    solve1(1, 0);\n    solve2(1, 0);\n  }\n  int S = 0, T = 0;\n  dfs(1, 0, S);\n  dfs(S, 0, T);\n  int N = 0;\n  int u = T;\n  while (u != S) {\n    p[++N] = u;\n    u = fa[u];\n  }\n  p[++N] = S;\n  col[p[N / 2]] = 1;\n  col[p[N / 2 + 1]] = 2;\n  dfs1(p[N / 2], 1);\n  dfs2(p[N / 2 + 1], 2);\n  printf(\"Yes\\n\");\n  for (int i = 1; i <= n; i++) printf(\"%d \", col[i]);\n  printf(\"\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nstd::vector<std::vector<int>> ad;\nstd::vector<int> dt;\nstd::vector<int> parof;\nvoid fs(int node, int par) {\n  parof[node] = par;\n  for (int x : ad[node])\n    if (x != par) {\n      dt[x] = dt[node] + 1;\n      fs(x, node);\n    }\n}\nint main() {\n  std::ios::sync_with_stdio(0);\n  std::cin.tie(0);\n  int n, k;\n  std::cin >> n >> k;\n  ad.resize(n);\n  for (int z = n - 1; z--;) {\n    int u, v;\n    std::cin >> u >> v;\n    --u;\n    --v;\n    ad[u].push_back(v);\n    ad[v].push_back(u);\n  }\n  dt.resize(n);\n  dt[0] = 0;\n  parof.resize(n);\n  fs(0, -1);\n  if (k == 2) {\n    std::cout << \"Yes\\n\";\n    for (int d : dt) std::cout << (d % 2 ? '1' : '2') << ' ';\n    std::cout << '\\n';\n    return 0;\n  }\n  auto root = int(std::max_element(begin(dt), end(dt)) - begin(dt));\n  dt.resize(n);\n  dt[root] = 0;\n  parof.resize(n);\n  fs(root, -1);\n  auto leaf = int(std::max_element(begin(dt), end(dt)) - begin(dt));\n  int dia = 1 + dt[leaf];\n  if (dia < k) {\n    std::cout << \"Yes\\n\";\n    for (int i = 0; i < n; ++i) std::cout << \"1 \";\n    std::cout << '\\n';\n    return 0;\n  }\n  struct state {\n    int homei, dist, color;\n  };\n  std::vector<state> s(n, {-1, -1, -1});\n  std::queue<int> q;\n  for (int x = leaf, oldparx;; x = oldparx) {\n    q.push(x);\n    s[x] = {dt[x], 0, dt[x] % k};\n    oldparx = parof[x];\n    parof[x] = -1;\n    if (x == root) break;\n  }\n  while (!q.empty()) {\n    auto x = q.front();\n    q.pop();\n    for (int y : ad[x])\n      if (s[y].dist < 0) {\n        q.push(y);\n        s[y] = {s[x].homei, s[x].dist + 1, -1};\n        parof[y] = x;\n        int dy = s[y].dist;\n        int hy = s[y].homei;\n        int add1 = hy + 1;\n        int add2 = dia - hy;\n        if (dy + add1 >= k && dy + add2 >= k) {\n          std::cout << \"No\\n\";\n          return 0;\n        }\n        if (dy + add1 >= k) {\n          for (int z = y; s[z].color < 0;) {\n            s[z].color = (hy + s[z].dist) % k;\n            z = parof[z];\n          }\n        } else if (dy + add2 >= k) {\n          for (int z = y; s[z].color < 0;) {\n            s[z].color = ((hy - s[z].dist) % k + k) % k;\n            z = parof[z];\n          }\n        }\n      }\n  }\n  std::cout << \"Yes\\n\";\n  for (state& st : s) std::cout << std::max(st.color, 0) + 1 << ' ';\n  std::cout << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = (int)2e5 + 100;\nvector<int> g[N];\nint d[N];\nint par[N];\nint col[N];\nint maxd[N];\nvoid dfs(int v, int p, int dist) {\n  d[v] = dist;\n  maxd[v] = d[v];\n  par[v] = p;\n  for (int to : g[v]) {\n    if (to == p) continue;\n    dfs(to, v, dist + 1);\n    maxd[v] = max(maxd[v], maxd[to]);\n  }\n}\nvoid dfs2(int v, int x) {\n  col[v] = x;\n  for (int to : g[v])\n    if (col[to] == 0) dfs2(to, x ^ 3);\n}\nint n, k;\nvoid dfsX(int v, int p, int ccol, int delta) {\n  col[v] = ccol;\n  vector<pair<int, int>> ch;\n  for (auto to : g[v]) {\n    if (to == p) continue;\n    ch.emplace_back(maxd[to] - d[v], to);\n  }\n  sort(ch.begin(), ch.end());\n  reverse(ch.begin(), ch.end());\n  if (ch.size() >= 2 && ch[0].first + ch[1].first + 1 >= k) {\n    printf(\"No\\n\");\n    exit(0);\n  }\n  for (auto top : ch) dfsX(top.second, v, ccol + delta, delta);\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 0; i < n - 1; i++) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    a--;\n    b--;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  if (k == 2) {\n    printf(\"Yes\\n\");\n    dfs2(0, 1);\n    for (int i = 0; i < n; i++) printf(\"%d \", col[i]);\n    printf(\"\\n\");\n    return 0;\n  }\n  dfs(0, 0, 0);\n  int v1 = 0;\n  for (int i = 0; i < n; i++)\n    if (d[i] > d[v1]) v1 = i;\n  dfs(v1, v1, 0);\n  int v2 = 0;\n  for (int i = 0; i < n; i++)\n    if (d[i] > d[v2]) v2 = i;\n  int x = d[v2] / 2;\n  for (int i = 0; i < x; i++) v2 = par[v2];\n  dfs(v2, v2, 0);\n  ;\n  vector<pair<int, int>> ch;\n  for (int to : g[v2]) ch.emplace_back(maxd[to], to);\n  sort(ch.begin(), ch.end());\n  reverse(ch.begin(), ch.end());\n  if (ch.size() >= 3 && ch[2].first + ch[1].first + 1 >= k) {\n    printf(\"No\\n\");\n    return 0;\n  }\n  if (ch.size() == 1 || (ch.size() == 2 && ch[0].first + ch[1].first + 1 < k)) {\n    printf(\"Yes\\n\");\n    for (int i = 0; i < n; i++) printf(\"%d \", 1);\n    printf(\"\\n\");\n    return 0;\n  }\n  dfsX(ch[0].second, v2, -1, -1);\n  for (int i = 1; i < (int)ch.size(); i++) dfsX(ch[i].second, v2, 1, 1);\n  printf(\"Yes\\n\");\n  for (int i = 0; i < n; i++) printf(\"%d \", ((col[i] % k) + k) % k + 1);\n  printf(\"\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\ninline bool upmin(T &x, T y) {\n  return y < x ? x = y, 1 : 0;\n}\ntemplate <typename T>\ninline bool upmax(T &x, T y) {\n  return x < y ? x = y, 1 : 0;\n}\nconst long double eps = 1e-11;\nconst long double pi = acos(-1);\nconst int oo = 1 << 30;\nconst long long loo = 1ll << 62;\nconst int mods = 1e9 + 7;\nconst int MAXN = 600005;\nconst int INF = 0x3f3f3f3f;\ninline int read() {\n  int f = 1, x = 0;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    x = (x << 3) + (x << 1) + (c ^ 48);\n    c = getchar();\n  }\n  return x * f;\n}\nvector<int> e[MAXN];\nint dist[MAXN], distu[MAXN], distv[MAXN], vis[MAXN], dep[MAXN];\nvoid dfs(int x, int father) {\n  for (int i = 0; i < e[x].size(); i++)\n    if (e[x][i] != father) {\n      dist[e[x][i]] = dist[x] + 1;\n      dfs(e[x][i], x);\n    }\n}\nvoid add_edge(int u, int v) {\n  e[u].push_back(v);\n  e[v].push_back(u);\n}\nint main() {\n  int n = read(), k = read(), u = 0, v = 0;\n  for (int i = 1; i < n; i++) {\n    int u = read(), v = read();\n    add_edge(u, v);\n  }\n  dist[1] = 0;\n  dfs(1, 0);\n  for (int i = 1; i <= n; i++)\n    if (dist[i] > dist[u]) u = i;\n  dist[u] = 0;\n  dfs(u, 0);\n  for (int i = 1; i <= n; i++) {\n    distu[i] = dist[i];\n    if (dist[i] > dist[v]) v = i;\n  }\n  dist[v] = 0;\n  dfs(v, 0);\n  for (int i = 1; i <= n; i++) distv[i] = dist[i];\n  int len = distu[v];\n  for (int i = 1; i <= n; i++)\n    if (distu[i] + distv[i] == len) vis[i] = 1, dep[i] = distu[i];\n  if (k == 2) {\n    puts(\"Yes\");\n    for (int i = 1; i <= n; i++) printf(\"%d\\n\", dist[i] % 2 + 1);\n    return 0;\n  }\n  for (int i = 1; i <= n; i++) {\n    if (vis[i]) continue;\n    if (distu[i] >= k - 1 && distv[i] >= k - 1) {\n      puts(\"No\");\n      return 0;\n    } else if (distu[i] < k - 1 && distv[i] < k - 1) {\n      if (distu[i] == distv[i])\n        dep[i] = 0;\n      else if (distu[i] > distv[i])\n        dep[i] = distu[i];\n      else\n        dep[i] = len - distv[i];\n    } else if (distu[i] >= k - 1)\n      dep[i] = distu[i];\n    else\n      dep[i] = len - distv[i];\n  }\n  puts(\"Yes\");\n  for (int i = 1; i <= n; i++) printf(\"%d \", dep[i] % k + 1);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma 03\nusing namespace std;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nlong long max_down[200005], max_up[200005];\nlong long dist[200005][2];\nlong long color[200005];\nlong long par[200005];\nvector<long long> adj[200005];\nbool vis[200005];\nlong long n, k;\nvector<long long> diam;\nvoid dfs1(long long u, long long p) {\n  for (auto v : adj[u]) {\n    if (v == p) continue;\n    dfs1(v, u);\n    max_down[u] = max(max_down[u], max_down[v] + 1);\n  }\n}\nvoid dfs2(long long u, long long p) {\n  long long mx[3] = {-1, -1, -1};\n  for (auto v : adj[u]) {\n    if (v == p) {\n      for (long long i = 0; i < 3; i++) {\n        if (mx[i] < max_up[u]) {\n          for (long long j = 2; j > i; j--) mx[j] = mx[j - 1];\n          mx[i] = max_up[u];\n          break;\n        }\n      }\n    } else {\n      for (long long i = 0; i < 3; i++) {\n        if (mx[i] < max_down[v] + 1) {\n          for (long long j = 2; j > i; j--) mx[j] = mx[j - 1];\n          mx[i] = max_down[v] + 1;\n          break;\n        }\n      }\n    }\n  }\n  for (auto v : adj[u]) {\n    if (v == p) continue;\n    if (max_down[v] + 1 == mx[0])\n      max_up[v] = max(max_up[v], mx[1] + 1);\n    else\n      max_up[v] = max(max_up[v], mx[0] + 1);\n    dfs2(v, u);\n  }\n  if ((mx[1] + mx[2] >= k - 1) && (mx[1] >= 0) && (mx[2] >= 0)) {\n    cout << \"No\\n\";\n    exit(0);\n  }\n}\nvoid dfs3(long long u, long long p) {\n  for (auto v : adj[u]) {\n    if (v == p) continue;\n    dist[v][0] = dist[u][0] + 1;\n    dfs3(v, u);\n  }\n}\nvoid dfs4(long long u, long long p) {\n  par[u] = p;\n  for (auto v : adj[u]) {\n    if (v == p) continue;\n    dist[v][1] = dist[u][1] + 1;\n    dfs4(v, u);\n  }\n}\nvoid bfs1() {\n  queue<long long> q;\n  for (long long i = 0; i < (long long)diam.size() / 2; i++) {\n    color[diam[i]] = (i % k) + 1;\n    q.push(diam[i]);\n  }\n  while (!q.empty()) {\n    long long u = q.front();\n    q.pop();\n    for (auto v : adj[u]) {\n      if (vis[v]) continue;\n      vis[v] = 1;\n      color[v] = color[u] - 1;\n      if (color[v] == 0) color[v] = k;\n      q.push(v);\n    }\n  }\n}\nvoid bfs2() {\n  queue<long long> q;\n  for (long long i = (long long)diam.size() / 2; i < (long long)diam.size();\n       i++) {\n    color[diam[i]] = (i % k) + 1;\n    q.push(diam[i]);\n  }\n  while (!q.empty()) {\n    long long u = q.front();\n    q.pop();\n    for (auto v : adj[u]) {\n      if (vis[v]) continue;\n      vis[v] = 1;\n      color[v] = color[u] + 1;\n      if (color[v] == k + 1) color[v] = 1;\n      q.push(v);\n    }\n  }\n}\nvoid dfs_solve_2(long long u, long long p) {\n  for (auto v : adj[u]) {\n    if (v == p) continue;\n    color[v] = 3 - color[u];\n    dfs_solve_2(v, u);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  for (long long i = 1; i < n; i++) {\n    long long u, v;\n    cin >> u >> v;\n    adj[u].emplace_back(v);\n    adj[v].emplace_back(u);\n  }\n  if (k == 2) {\n    cout << \"Yes\\n\";\n    color[1] = 1;\n    dfs_solve_2(1, 0);\n    for (long long i = 1; i <= n; i++) cout << color[i] << \" \";\n    cout << \"\\n\";\n    return 0;\n  }\n  dfs1(1, 0);\n  dfs2(1, 0);\n  cout << \"Yes\\n\";\n  dfs3(1, 0);\n  long long mx = -1, mx_id = -1;\n  for (long long i = 1; i <= n; i++) {\n    if (mx < dist[i][0]) {\n      mx = dist[i][0];\n      mx_id = i;\n    }\n  }\n  dfs4(mx_id, 0);\n  mx = mx_id = -1;\n  for (long long i = 1; i <= n; i++) {\n    if (mx < dist[i][1]) {\n      mx = dist[i][1];\n      mx_id = i;\n    }\n  }\n  while (1) {\n    diam.emplace_back(mx_id);\n    mx_id = par[mx_id];\n    if (mx_id == 0) break;\n  }\n  for (auto u : diam) vis[u] = 1;\n  bfs1();\n  bfs2();\n  for (long long i = 1; i <= n; i++) cout << color[i] << \" \";\n  cout << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 200005;\nint n, k, cnt, last[N], fa[N][20], dep[N], dx, dy, dl, col[N];\nbool vis[N];\nstruct edge {\n  int to, next;\n} e[N * 2];\nvoid addedge(int u, int v) {\n  e[++cnt].to = v;\n  e[cnt].next = last[u];\n  last[u] = cnt;\n  e[++cnt].to = u;\n  e[cnt].next = last[v];\n  last[v] = cnt;\n}\nvoid dfs1(int x) {\n  dep[x] = dep[fa[x][0]] + 1;\n  for (int i = 1; i <= 18; i++) fa[x][i] = fa[fa[x][i - 1]][i - 1];\n  for (int i = last[x]; i; i = e[i].next) {\n    if (e[i].to == fa[x][0]) continue;\n    fa[e[i].to][0] = x;\n    dfs1(e[i].to);\n  }\n}\nint get_dis(int x, int y) {\n  int p = x, q = y;\n  if (dep[x] < dep[y]) std::swap(x, y);\n  for (int i = 18; i >= 0; i--)\n    if (dep[fa[x][i]] >= dep[y]) x = fa[x][i];\n  if (x == y) return dep[p] + dep[q] - dep[x] * 2;\n  for (int i = 18; i >= 0; i--)\n    if (fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i];\n  return dep[p] + dep[q] - dep[fa[x][0]] * 2;\n}\nvoid dfs2(int x, int d, int fa) {\n  if (d > dl) dl = d, dx = x;\n  for (int i = last[x]; i; i = e[i].next)\n    if (e[i].to != fa) dfs2(e[i].to, d + 1, x);\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  k--;\n  for (int i = 1; i < n; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    addedge(x, y);\n  }\n  dfs1(1);\n  if (k == 1) {\n    puts(\"Yes\");\n    for (int i = 1; i <= n; i++) printf(\"%d \", dep[i] % 2 + 1);\n    return 0;\n  }\n  dfs2(1, 0, 0);\n  dy = dx;\n  dl = dx = 0;\n  dfs2(dy, 0, 0);\n  for (int i = 1; i <= n; i++) {\n    int d1 = get_dis(i, dx), d2 = get_dis(i, dy);\n    if (d1 + d2 == dl) vis[i] = 1, col[i] = d1 % (k + 1);\n  }\n  for (int i = 1; i <= n; i++) {\n    if (vis[i]) continue;\n    int d1 = get_dis(i, dx), d2 = get_dis(i, dy);\n    if (d1 >= k && d2 >= k) {\n      puts(\"No\");\n      return 0;\n    } else if (d1 >= k)\n      col[i] = d1 % (k + 1);\n    else if (d2 >= k)\n      col[i] = (dl - d2) % (k + 1);\n    else if (d1 > d2)\n      col[i] = d1 % (k + 1);\n    else if (d1 < d2)\n      col[i] = (dl - d2) % (k + 1);\n    else\n      col[i] = 0;\n  }\n  puts(\"Yes\");\n  for (int i = 1; i <= n; i++) printf(\"%d \", col[i] + 1);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nvector<int> dia;\nvector<int> G[200009];\nbool bejar[200009];\nint szint[200009];\nint apa[200009];\nint szin[200009];\nint croot;\nbool dfs(int x, int cl, int df) {\n  bejar[x] = true;\n  szin[x] = cl;\n  if (x != dia[croot] && min(croot, (int)(dia.size()) - 1 - croot) + szint[x] -\n                                 szint[dia[croot]] >=\n                             k - 1)\n    return false;\n  for (int sz : G[x]) {\n    if (!bejar[sz]) {\n      int clnew = (cl + df + k) % k;\n      if (!dfs(sz, clnew, df)) return false;\n    }\n  }\n  return true;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> k;\n  for (int i = 1; i < n; i++) {\n    int aa, bb;\n    cin >> aa >> bb;\n    G[aa].push_back(bb);\n    G[bb].push_back(aa);\n  }\n  queue<int> q;\n  q.push(1);\n  szint[1] = 0;\n  bejar[1] = true;\n  while (!q.empty()) {\n    int akt = q.front();\n    q.pop();\n    for (int sz : G[akt]) {\n      if (!bejar[sz]) {\n        szint[sz] = szint[akt] + 1;\n        q.push(sz);\n        bejar[sz] = true;\n      }\n    }\n  }\n  if (k == 2) {\n    cout << \"Yes\" << endl;\n    for (int i = 1; i <= n; i++) {\n      cout << szint[i] % 2 + 1 << \" \";\n    }\n    cout << endl;\n    return 0;\n  }\n  int kezd = 1;\n  for (int i = 1; i <= n; i++) {\n    if (szint[i] > szint[kezd]) kezd = i;\n    bejar[i] = false;\n  }\n  q.push(kezd);\n  szint[kezd] = 0;\n  bejar[kezd] = true;\n  while (!q.empty()) {\n    int akt = q.front();\n    q.pop();\n    for (int sz : G[akt]) {\n      if (!bejar[sz]) {\n        szint[sz] = szint[akt] + 1;\n        q.push(sz);\n        bejar[sz] = true;\n        apa[sz] = akt;\n      }\n    }\n  }\n  int veg = 1;\n  for (int i = 1; i <= n; i++) {\n    if (szint[i] > szint[veg]) veg = i;\n    bejar[i] = false;\n  }\n  int akt = veg;\n  dia.push_back(akt);\n  bejar[akt] = true;\n  while (akt != kezd) {\n    akt = apa[akt];\n    dia.push_back(akt);\n    bejar[akt] = true;\n  }\n  reverse(dia.begin(), dia.end());\n  for (int idx = 0; idx < dia.size(); idx++) {\n    croot = idx;\n    if (2 * idx < dia.size()) {\n      if (!dfs(dia[idx], idx % k, -1)) {\n        cout << \"No\" << endl;\n        return 0;\n      }\n    } else {\n      if (!dfs(dia[idx], idx % k, 1)) {\n        cout << \"No\" << endl;\n        return 0;\n      }\n    }\n  }\n  cout << \"Yes\" << endl;\n  for (int i = 1; i <= n; i++) {\n    cout << szin[i] + 1 << \" \";\n  }\n  cout << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1e9 + 9;\nconst long long int MOD = 1e9 + 696969;\nmt19937_64 rng(time(0));\nint random(int l, int r) { return uniform_int_distribution<int>(l, r)(rng); }\nconst long long INF = 1e18;\nconst int maxn = 400100;\nint spo, n, k;\nvector<int> v[maxn];\nvector<bool> odw;\nvector<int> dist;\nvector<int> par;\nvector<bool> on_path;\nint f[maxn];\nvector<int> path;\nint dist_path[maxn];\nint PATHLEN;\nvoid initdfs(int x) {\n  odw[x] = 1;\n  for (auto u : v[x]) {\n    if (!odw[u]) {\n      par[u] = x;\n      dist[u] = dist[x] + 1;\n      initdfs(u);\n    }\n  }\n}\nvoid setup() {\n  odw.clear();\n  dist.clear();\n  par.clear();\n  odw.resize(n + 1, 0);\n  dist.resize(n + 1, 0);\n  par.resize(n + 1, 0);\n}\ninline int find(int x) {\n  if (f[x] == x) return x;\n  f[x] = find(f[x]);\n  return f[x];\n}\ninline void lacz(int x, int y) {\n  x = find(x);\n  y = find(y);\n  if (x == y) return;\n  --spo;\n  f[x] = y;\n}\nvector<int> stos;\nvoid dfs(int x, int pos_root) {\n  stos.push_back(x);\n  odw[x] = 1;\n  if (!on_path[x]) {\n    int i = stos.size() - 1;\n    if (i - k >= 0) {\n      lacz(stos[i], stos[i - k]);\n    } else {\n      int di = k;\n      di -= dist[x];\n      if (pos_root - di >= 0) {\n        lacz(stos[i], path[pos_root - di]);\n      }\n      if (pos_root + di < (int)path.size()) {\n        lacz(stos[i], path[pos_root + di]);\n      }\n      int d1 = dist[x] + pos_root;\n      int d2 = dist[x] + (int)(path).size() - pos_root - 1;\n      if (d1 >= d2) {\n        lacz(stos[i], path[pos_root + dist[x]]);\n      } else {\n        lacz(stos[i], path[pos_root - dist[x]]);\n      }\n    }\n  }\n  for (auto u : v[x]) {\n    if (!odw[u] && !on_path[u]) {\n      dist[u] = dist[x] + 1;\n      dfs(u, pos_root);\n    }\n  }\n  stos.pop_back();\n}\nint seen[maxn];\nint colors[maxn];\nint gold[maxn];\nint sz[maxn];\nint maxsub[maxn];\nvoid prep(int x, vector<int> &nodes) {\n  odw[x] = 1;\n  nodes.push_back(x);\n  sz[x] = 1;\n  for (auto u : v[x]) {\n    if (!gold[u] && !odw[u]) {\n      prep(u, nodes);\n      sz[x] += sz[u];\n      maxsub[x] = max(maxsub[x], sz[u]);\n    }\n  }\n}\nlong long int weight[maxn];\nlong long int SUM;\nlong long int hasz[maxn];\nint depth[maxn];\nbool ist[maxn];\nlong long int MAX[maxn];\nlong long int MIN[maxn];\nbool ansdfs(int x, vector<int> &vec) {\n  bool ans = true;\n  stos.push_back(x);\n  odw[x] = 1;\n  vec.push_back(x);\n  hasz[x] = hasz[par[x]] + weight[colors[x]];\n  depth[x] = 1 + depth[par[x]];\n  if (depth[x] >= k) {\n    long long int tmp = hasz[x] - hasz[stos[depth[x] - k]];\n    if (tmp != SUM) ans = false;\n  } else if (depth[x] == k - 1) {\n    if (hasz[x] != SUM) ans = false;\n  } else {\n    int search_for = k - depth[x] - 1;\n    if (ist[search_for]) {\n      if (MAX[search_for] + hasz[x] - hasz[stos[0]] != SUM) ans = false;\n      if (MIN[search_for] + hasz[x] - hasz[stos[0]] != SUM) ans = false;\n    }\n  }\n  for (auto u : v[x]) {\n    if (!gold[u] && !odw[u]) {\n      par[u] = x;\n      ans &= ansdfs(u, vec);\n    }\n  }\n  stos.pop_back();\n  return ans;\n}\nbool find_answers(int root) {\n  hasz[root] = weight[colors[root]];\n  depth[root] = 0;\n  bool all_ok = true;\n  stos.clear();\n  stos.push_back(root);\n  for (auto nei : v[root]) {\n    if (!gold[nei]) {\n      par[nei] = root;\n      vector<int> child;\n      all_ok &= ansdfs(nei, child);\n      for (auto &node : child) {\n        int dp = depth[node];\n        if (ist[dp]) {\n          MAX[dp] = max(MAX[dp], hasz[node]);\n          MIN[dp] = min(MIN[dp], hasz[node]);\n        } else {\n          ist[dp] = 1;\n          MAX[dp] = hasz[node];\n          MIN[dp] = hasz[node];\n        }\n      }\n    }\n  }\n  stos.clear();\n  return all_ok;\n}\nbool cd(int x) {\n  vector<int> component;\n  prep(x, component);\n  int N = (int)(component).size();\n  int cen = -1;\n  for (auto &node : component) {\n    maxsub[node] = max(maxsub[node], N - sz[node]);\n    if (maxsub[node] <= N / 2) cen = node;\n    odw[node] = 0;\n    sz[node] = 0;\n    maxsub[node] = 0;\n  }\n  assert(cen != -1);\n  gold[cen] = 1;\n  bool ans = find_answers(cen);\n  for (auto &node : component) {\n    odw[node] = 0;\n    sz[node] = 0;\n    maxsub[node] = 0;\n    ist[depth[node]] = 0;\n  }\n  for (auto u : v[cen]) {\n    if (!gold[u]) {\n      ans &= cd(u);\n    }\n  }\n  return ans;\n}\nlong long int WAGA = 1e12;\nbool check() {\n  setup();\n  for (int i = (1); i <= (k); ++i) {\n    weight[i] = ((long long int)rand() * rand() + WAGA) % WAGA;\n    SUM += weight[i];\n  }\n  return cd(1);\n}\nint A[maxn];\nvoid solve() {\n  cin >> n >> k;\n  spo = n + k;\n  for (int i = (1); i <= (n + k); ++i) f[i] = i;\n  for (int i = (2); i <= (n); ++i) {\n    int a, b;\n    cin >> a >> b;\n    A[i] = a;\n    v[a].push_back(b);\n    v[b].push_back(a);\n  }\n  on_path.resize(n + 1, 0);\n  setup();\n  initdfs(1);\n  int best = 1;\n  for (int i = (2); i <= (n); ++i)\n    if (dist[i] > dist[best]) best = i;\n  int x = best;\n  setup();\n  initdfs(best);\n  best = 1;\n  for (int i = (2); i <= (n); ++i)\n    if (dist[i] > dist[best]) best = i;\n  int y = best;\n  int gdzie = y;\n  on_path[gdzie] = 1;\n  path = {y};\n  dist_path[y] = dist[y];\n  while (gdzie != x) {\n    gdzie = par[gdzie];\n    dist_path[gdzie] = dist[gdzie];\n    on_path[gdzie] = 1;\n    path.push_back(gdzie);\n  }\n  reverse(begin(path), end(path));\n  0 && cerr;\n  setup();\n  for (int i = 0; i < (int)(path).size(); ++i) {\n    int jaki_kolor = i % k;\n    lacz(path[i], n + 1 + jaki_kolor);\n  }\n  for (int i = 0; i < (int)(path).size(); ++i) {\n    dfs(path[i], i);\n  }\n  if (spo < k) {\n    cout << \"No\";\n    exit(0);\n  };\n  int COL = 0;\n  for (int i = (1); i <= (n); ++i) {\n    int cc = find(i);\n    if (!seen[cc]) {\n      if (COL < k) ++COL;\n      seen[cc] = COL;\n    }\n    colors[i] = seen[cc];\n  }\n  if (check()) {\n    cout << \"Yes\\n\";\n    for (int i = (1); i <= (n); ++i) {\n      cout << colors[i] << ' ';\n    }\n    cout << endl;\n  } else {\n    cout << \"No\\n\";\n  }\n}\nint main() {\n  srand(2137);\n  {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n  };\n  int tests;\n  tests = 1;\n  while (tests--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 10;\nint read() {\n  int x = 0, f = 1;\n  char c = getchar();\n  while (!isdigit(c)) {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (isdigit(c)) {\n    x = (x << 3) + (x << 1) + c - 48;\n    c = getchar();\n  }\n  return x * f;\n}\nint to[maxn << 1], net[maxn << 1], h[maxn], e = 1;\nvoid add(int x, int y) {\n  to[++e] = y;\n  net[e] = h[x];\n  h[x] = e;\n}\nint k, m, n, len, id;\nint f[maxn], g[maxn], d[maxn], w[maxn], fa[maxn], dep[maxn];\nvoid dfs(int x) {\n  f[x] = g[x] = d[x] = 0;\n  dep[x] = dep[fa[x]] + 1;\n  for (int i = h[x]; i; i = net[i]) {\n    int y = to[i];\n    if (y == fa[x]) continue;\n    fa[y] = x;\n    dfs(y);\n    if (f[y] + 1 > f[x]) {\n      d[x] = g[x];\n      g[x] = f[x];\n      f[x] = f[y] + 1;\n    } else if (f[y] + 1 > g[x]) {\n      d[x] = g[x];\n      g[x] = f[y] + 1;\n    } else\n      d[x] = max(d[x], f[y] + 1);\n  }\n  f[x] = max(f[x], 1);\n  return;\n}\nvoid dfs2(int x) {\n  w[x] = w[fa[x]] + 1;\n  if (f[fa[x]] == f[x] + 1)\n    w[x] = max(w[x], g[fa[x]] + 1);\n  else\n    w[x] = max(w[x], f[fa[x]] + 1);\n  if (g[x] > 1 && d[x] > 1 && f[x] > 1 && g[x] + d[x] - 1 >= k) {\n    puts(\"No\");\n    exit(0);\n  }\n  if (w[x] > 1 && g[x] > 1 && f[x] > 1 && f[x] + g[x] - 1 >= k &&\n      w[x] + g[x] - 1 >= k) {\n    puts(\"No\");\n    exit(0);\n  }\n  for (int i = h[x]; i; i = net[i]) {\n    int y = to[i];\n    if (y == fa[x]) continue;\n    dfs2(y);\n  }\n}\nint ok[maxn];\nbool DFS(int x) {\n  if (dep[x] == len) return ok[x] = 1;\n  for (int i = h[x]; i; i = net[i]) {\n    int y = to[i];\n    if (y == fa[x]) continue;\n    if (DFS(y)) return ok[x] = 1;\n  }\n  return ok[x] = 0;\n}\nint color[maxn], son[maxn], depc[maxn];\nvoid DFS(int x, int fa) {\n  dep[x] = dep[fa] + 1;\n  if (ok[x])\n    depc[dep[x]] = color[x];\n  else\n    color[x] = depc[dep[x]];\n  int sonx = 0;\n  for (int i = h[x]; i; i = net[i]) {\n    int y = to[i];\n    if (y != fa && ok[y]) sonx = y;\n  }\n  if (sonx) DFS(sonx, x);\n  for (int i = h[x]; i; i = net[i]) {\n    int y = to[i];\n    if (y == fa || y == sonx) continue;\n    DFS(y, x);\n  }\n}\nint main() {\n  n = read();\n  k = read();\n  for (int i = 1; i < n; i++) {\n    int x = read(), y = read();\n    add(x, y);\n    add(y, x);\n  }\n  dfs(1);\n  if (k == 2) {\n    puts(\"Yes\");\n    for (int i = 1; i <= n; i++)\n      if (dep[i] % 2)\n        color[i] = 1;\n      else\n        color[i] = 2;\n    for (int i = 1; i <= n; i++) printf(\"%d \", color[i]);\n    puts(\"\");\n    return 0;\n  }\n  dfs2(1);\n  len = 0, id = 0;\n  for (int i = 1; i <= n; i++) {\n    fa[i] = 0;\n    if (dep[i] > len) {\n      len = dep[i];\n      id = i;\n    }\n  }\n  dfs(id);\n  for (int i = 1; i <= n; i++) {\n    if (dep[i] > len) len = dep[i];\n  }\n  DFS(id);\n  for (int i = 1; i <= n; i++) {\n    if (ok[i]) color[i] = dep[i] % k + 1;\n  }\n  int rt = 0;\n  for (int i = 1; i <= n; i++) {\n    if (ok[i] && dep[i] == (len + 1) / 2) rt = i;\n  }\n  for (int i = h[rt]; i; i = net[i]) {\n    int y = to[i];\n    if (ok[y] && dep[y] > dep[rt]) DFS(y, rt);\n  }\n  for (int i = h[rt]; i; i = net[i]) {\n    int y = to[i];\n    if (ok[y] && dep[y] < dep[rt]) DFS(y, rt);\n  }\n  for (int i = h[rt]; i; i = net[i]) {\n    int y = to[i];\n    if (!ok[y]) DFS(y, rt);\n  }\n  puts(\"Yes\");\n  for (int i = 1; i <= n; i++) printf(\"%d \", color[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing Graph = vector<vector<int>>;\nvoid Yes(vector<int> vs) {\n  cout << \"Yes\" << endl;\n  for (int i = 0; i < vs.size(); i++) cout << vs[i] + 1 << \" \";\n  cout << endl;\n  exit(0);\n}\nvoid No() {\n  cout << \"No\" << endl;\n  exit(0);\n}\nvoid dfsBC(int v, Graph& g, vector<int>& col) {\n  for (auto to : g[v]) {\n    if (col[to] == -1) {\n      col[to] = !col[v];\n      dfsBC(to, g, col);\n    }\n  }\n}\nvoid solve2(int n, Graph& g) {\n  vector<int> col(n, -1);\n  col[0] = 0;\n  dfsBC(0, g, col);\n  Yes(col);\n}\npair<int, int> dfs0(int v, int pre, Graph& g) {\n  pair<int, int> res = {0, v};\n  for (auto to : g[v]) {\n    if (to == pre) continue;\n    auto ret = dfs0(to, v, g);\n    ret.first++;\n    res = max(ret, res);\n  }\n  return res;\n}\nvoid dfs1(int v, int pre, int tar, Graph& g, vector<int>& vs) {\n  if (v == tar) {\n    vs.push_back(v);\n    return;\n  }\n  for (auto to : g[v]) {\n    if (to == pre) continue;\n    dfs1(to, v, tar, g, vs);\n    if (vs.size()) {\n      vs.push_back(v);\n      return;\n    }\n  }\n}\nvector<int> getDiameter(Graph& g) {\n  auto p = dfs0(0, -1, g);\n  int v = p.second;\n  p = dfs0(v, -1, g);\n  v = p.second;\n  p = dfs0(v, -1, g);\n  vector<int> vs;\n  dfs1(v, -1, p.second, g, vs);\n  return vs;\n}\nvoid dfsCOL(int v, int pre, int c, int diff, vector<int>& col, Graph& g) {\n  col[v] = c;\n  for (auto to : g[v]) {\n    if (to == pre) continue;\n    dfsCOL(to, v, c + diff, diff, col, g);\n  }\n}\nint setLen(int v, int pre, vector<int>& len, Graph& g, int k) {\n  pair<int, int> dblMax;\n  for (auto to : g[v]) {\n    if (to == pre) continue;\n    auto ret = setLen(to, v, len, g, k);\n    if (dblMax.second < ret) dblMax.second = ret;\n    if (dblMax.first < dblMax.second) swap(dblMax.first, dblMax.second);\n  }\n  if (dblMax.second && dblMax.first + dblMax.second >= k - 1) No();\n  return len[v] = dblMax.first + 1;\n}\nvoid solve(int n, int k, Graph& g) {\n  vector<int> vs = getDiameter(g);\n  if (vs.size() < k) {\n    vector<int> col(n, 0);\n    iota(col.begin(), col.begin() + k, 0);\n    Yes(col);\n  }\n  vs.resize(k);\n  vector<int> maxLen(k);\n  vector<int> lenL(k);\n  vector<int> lenR(k);\n  vector<int> len(n);\n  set<int> terminals(vs.begin(), vs.end());\n  for (int i = 0; i < k; i++) {\n    int v = vs[i];\n    for (auto to : g[v]) {\n      if (terminals.count(to)) continue;\n      setLen(to, v, len, g, k);\n      if (lenR[i] < len[to]) lenR[i] = len[to];\n      if (lenL[i] < lenR[i]) swap(lenL[i], lenR[i]);\n    }\n    if (lenR[i] && lenL[i] && lenR[i] + lenL[i] >= k - 1) No();\n    lenR[i] = lenL[i] = max(lenR[i], lenL[i]) + 1;\n    maxLen[i] = lenL[i] - 1;\n  }\n  for (int i = 0; i + 1 < k; i++) lenL[i + 1] = max(lenL[i + 1], lenL[i] + 1);\n  for (int i = k - 1; i > 0; i--) lenR[i - 1] = max(lenR[i - 1], lenR[i] + 1);\n  vector<int> flagL(k);\n  flagL[0] = false;\n  flagL[k - 1] = true;\n  for (int i = 1; i < k - 1; i++) {\n    bool bl = lenL[i - 1] + maxLen[i] >= k - 1;\n    bool br = lenR[i + 1] + maxLen[i] >= k - 1;\n    if (maxLen[i] && bl && br) No();\n    flagL[i] = bl;\n  }\n  vector<int> col(n);\n  for (int i = 0; i < k; i++) {\n    int v = vs[i];\n    col[v] = i;\n    int c, diff;\n    if (flagL[i]) {\n      c = i + 1;\n      diff = 1;\n    } else {\n      c = i - 1;\n      diff = -1;\n    }\n    for (auto to : g[v]) {\n      if (terminals.count(to)) continue;\n      dfsCOL(to, v, c, diff, col, g);\n    }\n  }\n  for (int i = 0; i < n; i++) col[i] = (col[i] % k + k) % k;\n  Yes(col);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  Graph g(n);\n  for (int i = 0; i + 1 < n; i++) {\n    int a, b;\n    cin >> a >> b;\n    a--, b--;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  if (k == 2) {\n    solve2(n, g);\n    return 0;\n  } else {\n    solve(n, k, g);\n    return 0;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing i64 = long long;\nint k, diameter;\nstd::vector<std::vector<int>> g;\nstd::vector<int> dist, color;\nstd::pair<int, int> dfs(int v, int p) {\n  auto ret = std::make_pair(0, v);\n  for (int to : g[v]) {\n    if (to == p) continue;\n    auto r = dfs(to, v);\n    r.first++;\n    if (r.first > ret.first) std::swap(r, ret);\n  }\n  dist[v] = ret.first;\n  return ret;\n}\nvoid dfs2(int v, int p, int c) {\n  color[v] = c;\n  for (int to : g[v])\n    if (to != p) dfs2(to, v, !c);\n}\nvoid dfsk(int v, int p, int c, bool rev = false) {\n  color[v] = (c % k + k) % k;\n  for (int to : g[v])\n    if (to != p) {\n      if (rev)\n        dfsk(to, v, c - 1, true);\n      else if (c >= diameter / 2)\n        dfsk(to, v, c + 1);\n      else if (dist[to] + c + 2 == diameter)\n        dfsk(to, v, c + 1);\n      else\n        dfsk(to, v, c - 1, true);\n    }\n}\nbool check(int v, int p, int o) {\n  int a[] = {o, -1, -1};\n  for (int to : g[v]) {\n    if (to == p) continue;\n    int d = dist[to] + 1;\n    if (d > a[0]) {\n      a[2] = a[1];\n      a[1] = a[0];\n      a[0] = d;\n    } else if (d > a[1]) {\n      a[2] = a[1];\n      a[1] = d;\n    } else if (d > a[2]) {\n      a[2] = d;\n    }\n  }\n  if (a[2] >= 0) {\n    if (a[1] + a[2] + 1 >= k) return false;\n  }\n  for (int to : g[v]) {\n    if (to == p) continue;\n    int l = dist[to] + 1 == a[0] ? a[1] + 1 : a[0] + 1;\n    if (!check(to, v, l)) return false;\n  }\n  return true;\n}\nint main() {\n  int n;\n  scanf(\"%d%d\", &n, &k);\n  g.resize(n);\n  dist.resize(n);\n  color.resize(n);\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    --u;\n    --v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  if (k == 2) {\n    printf(\"Yes\\n\");\n    dfs2(0, -1, 0);\n    for (auto c : color) printf(\"%d \", c + 1);\n    printf(\"\\n\");\n    return 0;\n  }\n  int root = dfs(0, -1).second;\n  diameter = dfs(root, -1).first + 1;\n  fprintf(stderr, \"root = %d, diameter = %d\\n\", root + 1, diameter);\n  if (!check(root, -1, 0)) {\n    printf(\"No\\n\");\n    return 0;\n  }\n  dfsk(root, -1, 0);\n  printf(\"Yes\\n\");\n  for (auto c : color) printf(\"%d \", c + 1);\n  printf(\"\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 200005;\nint to[N << 1], edge, Next[N << 1], last[N], f[N], dep[N], diss[N], dist[N];\nint dis[N], mx, tg, x, k, n, t, a[N], c[N], y, s, tag[N];\nvoid add(int x, int y) {\n  to[++edge] = y;\n  Next[edge] = last[x];\n  last[x] = edge;\n}\nvoid dfs(int x, int y, int d) {\n  dep[x] = d;\n  f[x] = y;\n  if (d >= mx) {\n    t = x;\n    mx = d;\n  }\n  for (int i = last[x]; i; i = Next[i]) {\n    int u = to[i];\n    if (u != y) dfs(u, x, d + 1);\n  }\n}\nvoid dfs2(int x, int y, int d, int *dis) {\n  dis[x] = d;\n  for (int i = last[x]; i; i = Next[i])\n    if (to[i] != y) dfs2(to[i], x, d + 1, dis);\n}\nvoid dfs3(int x, int y, int d) {\n  a[x] = c[d];\n  for (int i = last[x]; i; i = Next[i])\n    if (to[i] != y) dfs3(to[i], x, d + tg);\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i < n; i++) {\n    scanf(\"%d%d\", &x, &y);\n    add(x, y), add(y, x);\n  }\n  dfs(1, 0, 0);\n  s = t;\n  dfs(s, 0, 0);\n  if (k == 2) {\n    puts(\"Yes\");\n    for (int i = 1; i <= n; i++)\n      if (dep[i] & 1)\n        printf(\"%d \", 1);\n      else\n        printf(\"%d \", 2);\n    return 0;\n  }\n  dfs2(s, 0, 1, diss);\n  dfs2(t, 0, 1, dist);\n  for (int x = t, col = 0; x; x = f[x], col = (col + 1) % k)\n    a[x] = col, c[dep[x]] = col, tag[x] = 1;\n  for (int i = 1; i <= n; i++)\n    if (diss[i] >= k && dist[i] >= k && (!tag[i])) return puts(\"No\"), 0;\n  for (int x = t; x; x = f[x]) {\n    if (dep[x] <= mx / 2)\n      tg = -1;\n    else\n      tg = 1;\n    for (int i = last[x]; i; i = Next[i]) {\n      int u = to[i];\n      if (!tag[u]) dfs3(u, x, dep[x] + tg);\n    }\n  }\n  puts(\"Yes\");\n  for (int i = 1; i <= n; i++) printf(\"%d \", a[i] + 1);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma 03\nusing namespace std;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nlong long INF = 1e18;\nlong long max_down[200005], max_up[200005];\nlong long dist[200005][2];\nlong long color[200005];\nlong long par[200005];\nvector<long long> adj[200005];\nbool vis[200005];\nlong long n, k;\nvector<long long> diam;\nvoid dfs1(long long u, long long p) {\n  for (auto v : adj[u]) {\n    if (v == p) continue;\n    dfs1(v, u);\n    max_down[u] = max(max_down[u], max_down[v] + 1);\n  }\n}\nvoid dfs2(long long u, long long p) {\n  long long mx[3] = {-INF, -INF, -INF};\n  for (auto v : adj[u]) {\n    if (v == p) {\n      for (long long i = 0; i < 3; i++) {\n        if (mx[i] < max_up[u]) {\n          for (long long j = 2; j > i; j--) mx[j] = mx[j - 1];\n          mx[i] = max_up[u];\n          break;\n        }\n      }\n    } else {\n      for (long long i = 0; i < 3; i++) {\n        if (mx[i] < max_down[v] + 1) {\n          for (long long j = 2; j > i; j--) mx[j] = mx[j - 1];\n          mx[i] = max_down[v] + 1;\n          break;\n        }\n      }\n    }\n  }\n  for (auto v : adj[u]) {\n    if (v == p) continue;\n    if (max_down[v] + 1 == mx[0])\n      max_up[v] = max(max_up[v], mx[1] + 1);\n    else\n      max_up[v] = max(max_up[v], mx[0] + 1);\n    dfs2(v, u);\n  }\n  if (mx[1] + mx[2] >= k - 1) {\n    cout << \"No\\n\";\n    exit(0);\n  }\n}\nvoid dfs3(long long u, long long p) {\n  for (auto v : adj[u]) {\n    if (v == p) continue;\n    dist[v][0] = dist[u][0] + 1;\n    dfs3(v, u);\n  }\n}\nvoid dfs4(long long u, long long p) {\n  par[u] = p;\n  for (auto v : adj[u]) {\n    if (v == p) continue;\n    dist[v][1] = dist[u][1] + 1;\n    dfs4(v, u);\n  }\n}\nvoid bfs1() {\n  queue<long long> q;\n  for (long long i = 0; i < (long long)diam.size() / 2; i++) {\n    color[diam[i]] = (i % k) + 1;\n    q.push(diam[i]);\n  }\n  while (!q.empty()) {\n    long long u = q.front();\n    q.pop();\n    for (auto v : adj[u]) {\n      if (vis[v]) continue;\n      vis[v] = 1;\n      color[v] = color[u] - 1;\n      if (color[v] == 0) color[v] = k;\n      q.push(v);\n    }\n  }\n}\nvoid bfs2() {\n  queue<long long> q;\n  for (long long i = (long long)diam.size() / 2; i < (long long)diam.size();\n       i++) {\n    color[diam[i]] = (i % k) + 1;\n    q.push(diam[i]);\n  }\n  while (!q.empty()) {\n    long long u = q.front();\n    q.pop();\n    for (auto v : adj[u]) {\n      if (vis[v]) continue;\n      vis[v] = 1;\n      color[v] = color[u] + 1;\n      if (color[v] == k + 1) color[v] = 1;\n      q.push(v);\n    }\n  }\n}\nvoid dfs_solve_2(long long u, long long p) {\n  for (auto v : adj[u]) {\n    if (v == p) continue;\n    color[v] = 3 - color[u];\n    dfs_solve_2(v, u);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  for (long long i = 1; i < n; i++) {\n    long long u, v;\n    cin >> u >> v;\n    adj[u].emplace_back(v);\n    adj[v].emplace_back(u);\n  }\n  if (k == 2) {\n    cout << \"Yes\\n\";\n    color[1] = 1;\n    dfs_solve_2(1, 0);\n    for (long long i = 1; i <= n; i++) cout << color[i] << \" \";\n    cout << \"\\n\";\n    return 0;\n  }\n  dfs1(1, 0);\n  dfs2(1, 0);\n  cout << \"Yes\\n\";\n  dfs3(1, 0);\n  long long mx = -1, mx_id = -1;\n  for (long long i = 1; i <= n; i++) {\n    if (mx < dist[i][0]) {\n      mx = dist[i][0];\n      mx_id = i;\n    }\n  }\n  dfs4(mx_id, 0);\n  mx = mx_id = -1;\n  for (long long i = 1; i <= n; i++) {\n    if (mx < dist[i][1]) {\n      mx = dist[i][1];\n      mx_id = i;\n    }\n  }\n  while (1) {\n    diam.emplace_back(mx_id);\n    mx_id = par[mx_id];\n    if (mx_id == 0) break;\n  }\n  for (auto u : diam) vis[u] = 1;\n  bfs1();\n  bfs2();\n  for (long long i = 1; i <= n; i++) cout << color[i] << \" \";\n  cout << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200005;\nstruct edge {\n  int to, next;\n} e[N * 2];\nint head[N], tot;\nint n, k, vis[N], lvl[N];\nint dep[N], fa[N][20];\nvoid add(int x, int y) {\n  e[++tot] = (edge){y, head[x]};\n  head[x] = tot;\n}\nvoid dfs(int x) {\n  for (int i = head[x]; i; i = e[i].next)\n    if (e[i].to != fa[x][0]) {\n      fa[e[i].to][0] = x;\n      dep[e[i].to] = dep[x] + 1;\n      dfs(e[i].to);\n    }\n}\nint LCA(int x, int y) {\n  if (dep[x] < dep[y]) swap(x, y);\n  int tmp = dep[x] - dep[y];\n  for (int i = (int)(18); i >= (int)(0); i--)\n    if (tmp & (1 << i)) x = fa[x][i];\n  for (int i = (int)(18); i >= (int)(0); i--)\n    if (fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i];\n  return x == y ? x : fa[x][0];\n}\nint dis(int x, int y) { return dep[x] + dep[y] - 2 * dep[LCA(x, y)]; }\nint findmx(int x) {\n  int mxv = -1, mxid;\n  for (int i = (int)(1); i <= (int)(n); i++) {\n    int val = dis(x, i);\n    if (val > mxv) mxv = val, mxid = i;\n  }\n  return mxid;\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = (int)(1); i <= (int)(n - 1); i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    add(x, y);\n    add(y, x);\n  }\n  dfs(1);\n  if (k == 2) {\n    puts(\"Yes\");\n    for (int i = (int)(1); i <= (int)(n); i++) printf(\"%d \", dep[i] % 2 + 1);\n    return 0;\n  }\n  for (int i = (int)(1); i <= (int)(18); i++)\n    for (int j = (int)(1); j <= (int)(n); j++)\n      fa[j][i] = fa[fa[j][i - 1]][i - 1];\n  int S = findmx(1);\n  int T = findmx(S);\n  int dia = dis(S, T);\n  for (int i = (int)(1); i <= (int)(n); i++) {\n    int d1 = dis(S, i), d2 = dis(T, i);\n    if (d1 + d2 == dia) vis[i] = 1, lvl[i] = d1;\n  }\n  for (int i = (int)(1); i <= (int)(n); i++)\n    if (!vis[i]) {\n      int d1 = dis(S, i), d2 = dis(T, i);\n      if (d1 >= k - 1 && d2 >= k - 1) return puts(\"No\"), 0;\n      if (d1 >= d2)\n        lvl[i] = d1;\n      else\n        lvl[i] = dia - d2;\n    }\n  puts(\"Yes\");\n  for (int i = (int)(1); i <= (int)(n); i++) printf(\"%d \", lvl[i] % k + 1);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\nint n, k, k1, fa[N], c[N], mx[N], q[N], d[N];\nint mxx, rt1, rt2;\nbool in[N];\nvector<int> g[N];\nvoid fail() {\n  printf(\"No\\n\");\n  exit(0);\n}\nvoid dfs(int x, int d, int f = -1) {\n  if (d > mxx) mxx = d, rt2 = x;\n  for (int i = 0; i < g[x].size(); ++i)\n    if (g[x][i] != f) {\n      dfs(g[x][i], d + 1, x);\n    }\n}\nvoid dfs1(int x) {\n  for (int i = 0; i < g[x].size(); ++i)\n    if (g[x][i] != fa[x]) {\n      int y = g[x][i];\n      fa[y] = x;\n      d[y] = d[x] + 1;\n      dfs1(y);\n    }\n}\nvoid dfs2(int x) {\n  mx[x] = !in[x];\n  for (int i = 0; i < g[x].size(); ++i)\n    if (g[x][i] != fa[x]) {\n      int y = g[x][i];\n      dfs2(y);\n      mx[x] = max(mx[x], mx[y] + (!in[x]));\n    }\n}\nvoid dfs3(int x, int d) {\n  if (d == 1 || d == -1)\n    c[x] = (c[fa[x]] + d + k) % k;\n  else\n    c[x] = 0;\n  for (int i = 0; i < g[x].size(); ++i)\n    if (g[x][i] != fa[x] && !in[g[x][i]]) {\n      int y = g[x][i];\n      dfs3(y, d);\n    }\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1, x, y; i < n; ++i) {\n    scanf(\"%d%d\", &x, &y);\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  dfs(1, 0);\n  rt1 = rt2;\n  mxx = 0;\n  dfs(rt1, 0);\n  dfs1(rt1);\n  for (int x = rt2;; x = fa[x]) {\n    c[x] = k1++;\n    k1 %= k;\n    in[x] = 1;\n    q[++q[0]] = x;\n    if (x == rt1) break;\n  }\n  dfs2(rt1);\n  if (k == 1) {\n    printf(\"Yes\\n\");\n    for (int i = 1; i <= n; ++i) printf(\"%d \", 1);\n    return 0;\n  }\n  if (k == 2) {\n    printf(\"Yes\\n\");\n    for (int i = 1; i <= n; ++i) printf(\"%d \", (d[i] & 1) + 1);\n    return 0;\n  }\n  for (int t = 1; t <= q[0]; ++t) {\n    int x = q[t];\n    for (int i = 0; i < g[x].size(); ++i)\n      if (g[x][i] != fa[x] && !in[g[x][i]]) {\n        int y = g[x][i];\n        int a1 = mx[y] + t;\n        int a2 = mx[y] + q[0] - t + 1;\n        if (a1 >= k && a2 >= k)\n          fail();\n        else if (a1 < k && a2 < k && a1 == a2)\n          dfs(y, k - 1);\n        else\n          dfs3(y, (t <= (q[0] + 1) / 2) ? -1 : 1);\n      }\n  }\n  printf(\"Yes\\n\");\n  for (int i = 1; i <= n; ++i) printf(\"%d \", c[i] + 1);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200 * 1000 + 10, mod = 98765431;\nvector<int> adj[N];\nint dis[N];\nint par[N];\nint maxh[N];\nbool mark[N];\nint dfs_mx(int u, int p) {\n  par[u] = p;\n  int ans = u;\n  for (auto v : adj[u]) {\n    if (v == p) continue;\n    dis[v] = dis[u] + 1;\n    int mx = dfs_mx(v, u);\n    if (dis[mx] > dis[ans]) ans = mx;\n  }\n  maxh[u] = dis[ans];\n  return ans;\n}\nvoid gfs(int u, int p) {\n  for (auto v : adj[u]) {\n    if (mark[v] || v == p) continue;\n    dis[v] = dis[u] - 1;\n    gfs(v, u);\n  }\n}\nint32_t main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  for (int i = 1; i < n; i++) {\n    int x, y;\n    cin >> x >> y;\n    adj[x].push_back(y);\n    adj[y].push_back(x);\n  }\n  int sx = dfs_mx(1, 0);\n  dis[sx] = 0;\n  int sy = dfs_mx(sx, 0);\n  if (dis[sy] < k - 1 || k == 2) {\n    cout << \"Yes\\n\";\n    for (int i = 1; i <= n; i++) cout << dis[i] % k + 1 << \" \\n\"[i == n];\n    return 0;\n  }\n  vector<int> ham;\n  int tmp = sy;\n  while (tmp != sx) {\n    ham.push_back(tmp);\n    mark[tmp] = 1;\n    tmp = par[tmp];\n  }\n  ham.push_back(sx);\n  mark[sx] = 1;\n  int len = ham.size();\n  reverse(ham.begin(), ham.end());\n  for (int i = 0; i < len; i++) {\n    int v = ham[i];\n    int mx = -1;\n    for (auto u : adj[v]) {\n      if (mark[u]) continue;\n      mx = max(mx, maxh[u]);\n    }\n    if (mx == -1) continue;\n    int w = mx - dis[v];\n    if (w + i + 1 >= k && w + (len - i) >= k) return cout << \"No\" << endl, 0;\n    if (w + len - i >= k) {\n      gfs(v, -1);\n    }\n  }\n  cout << \"Yes\\n\";\n  for (int i = 1; i <= n; i++) cout << (dis[i] % k + 1) << \" \\n\"[i == n];\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nconst int MAXN = 200005;\nint n, k;\nvector<int> gph[MAXN];\nint par[MAXN], dep[MAXN], col[MAXN];\nnamespace Ontak {\nint a[200005], chk[200005];\nlint val[200005], mat;\nbool vis[200005];\nint aux[200005];\nvector<int> dfn;\nvoid dfs3(int x, int p) {\n  for (auto &i : gph[x]) {\n    if (i == p || vis[i]) continue;\n    dfs3(i, x);\n    if (aux[i]) aux[x] = 1;\n  }\n}\nvoid dfs2(int x, int p, lint h, vector<pair<int, int> > &v) {\n  h += val[a[x]];\n  v.push_back(pair<int, int>(h, x));\n  for (auto &i : gph[x]) {\n    if (i == p || vis[i]) continue;\n    dfs2(i, x, h, v);\n  }\n}\nvoid solve(int r) {\n  for (auto &i : dfn) aux[i] = 0;\n  set<lint> s;\n  s.insert(val[a[r]]);\n  for (auto &i : gph[r]) {\n    if (vis[i]) continue;\n    vector<pair<int, int> > sack;\n    dfs2(i, r, val[a[r]], sack);\n    for (auto &i : sack) {\n      if (s.find(mat - i.first + val[a[r]]) != s.end()) {\n        aux[i.second] = 1;\n      }\n    }\n    for (auto &i : sack) {\n      s.insert(i.first);\n    }\n  }\n  reverse(gph[r].begin(), gph[r].end());\n  s.clear();\n  s.insert(val[a[r]]);\n  for (auto &i : gph[r]) {\n    if (vis[i]) continue;\n    vector<pair<int, int> > sack;\n    dfs2(i, r, val[a[r]], sack);\n    for (auto &i : sack) {\n      if (s.find(mat - i.first + val[a[r]]) != s.end()) {\n        aux[i.second] = 1;\n      }\n    }\n    for (auto &i : sack) {\n      s.insert(i.first);\n    }\n  }\n  dfs3(r, -1);\n  for (auto &i : dfn)\n    if (aux[i]) chk[i] = 1;\n}\nint msz[200005], sz[200005];\nvoid dfs(int x, int p) {\n  dfn.push_back(x);\n  msz[x] = 0;\n  sz[x] = 1;\n  for (auto &i : gph[x]) {\n    if (i == p || vis[i]) continue;\n    dfs(i, x);\n    msz[x] = max(msz[x], sz[i]);\n    sz[x] += sz[i];\n  }\n}\nint get_center(int x) {\n  dfn.clear();\n  dfs(x, -1);\n  int cur = 1e9, pos = -1;\n  for (auto &i : dfn) {\n    int w = max((int)dfn.size() - sz[i], msz[i]);\n    if (w < cur) {\n      cur = w;\n      pos = i;\n    }\n  }\n  return pos;\n}\nbool solve() {\n  mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n  for (int i = 1; i <= n; i++) a[i] = col[i];\n  for (int i = 1; i <= k; i++) {\n    val[i] += uniform_int_distribution<long long>(0ll, 1ll << 32)(rng);\n    val[i] <<= 32;\n    val[i] += uniform_int_distribution<long long>(0ll, 1ll << 32)(rng);\n    mat += val[i];\n  }\n  queue<int> que;\n  que.push(1);\n  while (!que.empty()) {\n    int x = que.front();\n    que.pop();\n    x = get_center(x);\n    solve(x);\n    vis[x] = 1;\n    for (auto &i : gph[x]) {\n      if (!vis[i]) que.push(i);\n    }\n  }\n  for (int i = 1; i <= n; i++)\n    if (chk[i]) return 1;\n  return 0;\n}\n}  // namespace Ontak\npair<int, int> far(int x, int p) {\n  pair<int, int> ret(0, x);\n  for (auto &i : gph[x]) {\n    if (i != p && !col[i]) {\n      par[i] = x;\n      dep[i] = dep[x] + 1;\n      auto j = far(i, x);\n      j.first++;\n      ret = max(ret, j);\n    }\n  }\n  return ret;\n}\nvoid increasing(int x, int p) {\n  for (auto &i : gph[x]) {\n    if (i != p && !col[i]) {\n      col[i] = col[x] + 1;\n      if (col[i] > k) col[i] = 1;\n      increasing(i, x);\n    }\n  }\n}\nvoid decreasing(int x, int p) {\n  for (auto &i : gph[x]) {\n    if (i != p && !col[i]) {\n      col[i] = col[x] - 1;\n      if (col[i] <= 0) col[i] = k;\n      decreasing(i, x);\n    }\n  }\n}\nint main() {\n  scanf(\"%d %d\", &n, &k);\n  for (int i = 1; i < n; i++) {\n    int s, e;\n    scanf(\"%d %d\", &s, &e);\n    gph[s].push_back(e);\n    gph[e].push_back(s);\n  }\n  int s = far(1, 0).second;\n  int d, t;\n  tie(d, t) = far(s, 0);\n  if (d + 1 < k) {\n    puts(\"Yes\");\n    for (int i = 1; i <= n; i++) {\n      printf(\"%d \", (i - 1) % k + 1);\n    }\n    puts(\"\");\n    return 0;\n  }\n  if (k == 2) {\n    puts(\"Yes\");\n    for (int i = 1; i <= n; i++) {\n      printf(\"%d \", dep[i] % 2 + 1);\n    }\n    puts(\"\");\n    return 0;\n  }\n  vector<int> pth = {t};\n  for (int i = t; i != s; i = par[i]) {\n    pth.push_back(par[i]);\n  }\n  for (int i = 0; i < ((int)(pth).size()); i++) {\n    col[pth[i]] = i % k + 1;\n  }\n  for (int i = 0; i < ((int)(pth).size()); i++) {\n    auto tmp = far(pth[i], -1);\n    if (tmp.first == 0) continue;\n    if (tmp.first + min(((int)(pth).size()) - i, i + 1) >= k) {\n      puts(\"No\");\n      return 0;\n    }\n    if (((int)(pth).size()) - i >= i + 1) {\n      decreasing(pth[i], -1);\n    } else {\n      increasing(pth[i], -1);\n    }\n  }\n  if (!Ontak::solve()) {\n    puts(\"Yes\");\n    for (int i = 1; i <= n; i++) printf(\"%d \", col[i]);\n  } else\n    puts(\"No\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200005;\nint n, k;\nvector<int> a[N];\nint d[N];\nvoid dfs0(int x, int p) {\n  d[x] = 1;\n  for (int i = 0; i < a[x].size(); ++i) {\n    int h = a[x][i];\n    if (h == p) continue;\n    dfs0(h, x);\n    d[x] = max(d[x], d[h] + 1);\n  }\n}\nvoid dfs1(int x, int p, int dp) {\n  multiset<int> s;\n  if (dp) s.insert(dp);\n  for (int i = 0; i < a[x].size(); ++i) {\n    int h = a[x][i];\n    if (h == p) continue;\n    s.insert(d[h]);\n  }\n  if (k != 2 && s.size() >= 3 &&\n      *(--(--(--s.end()))) + *(--(--s.end())) + 1 >= k) {\n    printf(\"No\");\n    exit(0);\n  }\n  for (int i = 0; i < a[x].size(); ++i) {\n    int h = a[x][i];\n    if (h == p) continue;\n    s.erase(s.find(d[h]));\n    if (s.empty())\n      dfs1(h, x, 1);\n    else\n      dfs1(h, x, *(--s.end()) + 1);\n    s.insert(d[h]);\n  }\n}\nvector<int> v;\nint c[N];\nvoid dfs2(int x, int p, int u) {\n  c[x] = u;\n  for (int i = 0; i < a[x].size(); ++i) {\n    int h = a[x][i];\n    if (c[h]) continue;\n    dfs2(h, x, (u % k) + 1);\n  }\n}\nvoid dfs3(int x, int p, int u) {\n  c[x] = u;\n  for (int i = 0; i < a[x].size(); ++i) {\n    int h = a[x][i];\n    if (c[h]) continue;\n    dfs3(h, x, (u - 2 + k) % k + 1);\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 0; i < n - 1; ++i) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    a[x].push_back(y);\n    a[y].push_back(x);\n  }\n  dfs0(1, 1);\n  dfs1(1, 1, 0);\n  printf(\"Yes\\n\");\n  int x = 1;\n  dfs0(x, x);\n  while (1) {\n    int maxu = 0, maxx;\n    for (int i = 0; i < a[x].size(); ++i) {\n      int h = a[x][i];\n      if (d[h] > d[x]) continue;\n      if (d[h] > maxu) {\n        maxu = d[h];\n        maxx = h;\n      }\n    }\n    if (!maxu) break;\n    x = maxx;\n  }\n  dfs0(x, x);\n  while (1) {\n    v.push_back(x);\n    int maxu = 0, maxx;\n    for (int i = 0; i < a[x].size(); ++i) {\n      int h = a[x][i];\n      if (d[h] > d[x]) continue;\n      if (d[h] > maxu) {\n        maxu = d[h];\n        maxx = h;\n      }\n    }\n    if (!maxu) break;\n    x = maxx;\n  }\n  int u = 0;\n  for (int i = 0; i < v.size(); ++i) {\n    c[v[i]] = u + 1;\n    u = (u + 1) % k;\n  }\n  for (int i = 0; i < v.size(); ++i) {\n    if ((v.size() - i) < (i + 1)) {\n      dfs2(v[i], v[i], c[v[i]]);\n    } else {\n      dfs3(v[i], v[i], c[v[i]]);\n    }\n  }\n  for (int i = 1; i <= n; ++i) printf(\"%d \", c[i]);\n  printf(\"\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> E[201000];\nint n, K, Dis[201000], Dis2[201000];\nvoid DFS(int a, int pp, int d) {\n  Dis[a] = d;\n  for (auto &x : E[a]) {\n    if (x == pp) {\n      continue;\n    }\n    DFS(x, a, d + 1);\n  }\n}\nint D[201000], D2[201000], Deg[201000], R[201000];\nvoid Go(int a, int pp) {\n  int d = 0;\n  int d2 = 0;\n  for (auto &x : E[a]) {\n    if (x == pp) continue;\n    Go(x, a);\n    d2 = max(d2, d + D[x] + 1);\n    d = max(d, D[x] + 1);\n  }\n  D[a] = d, D2[a] = d2;\n}\nvoid Color(int a, int pp, int c, int d) {\n  while (c > K) c -= K;\n  R[a] = c;\n  for (auto &x : E[a]) {\n    if (x == pp) continue;\n    Color(x, a, c + d, d);\n  }\n}\nint main() {\n  int i, a, b, MD = 0;\n  scanf(\"%d%d\", &n, &K);\n  for (i = 1; i < n; i++) {\n    scanf(\"%d%d\", &a, &b);\n    E[a].push_back(b);\n    E[b].push_back(a);\n    Deg[a]++, Deg[b]++;\n    MD = max(MD, max(Deg[a], Deg[b]));\n  }\n  DFS(1, 0, 0);\n  if (K == 2) {\n    puts(\"Yes\");\n    for (i = 1; i <= n; i++) {\n      printf(\"%d \", Dis[i] % 2 + 1);\n    }\n    return 0;\n  }\n  int Mx = -1;\n  a = 0;\n  for (i = 1; i <= n; i++) {\n    if (Mx < Dis[i]) Mx = Dis[i], a = i;\n  }\n  DFS(a, 0, 0);\n  if (MD == 2) {\n    puts(\"Yes\");\n    for (i = 1; i <= n; i++) {\n      printf(\"%d \", Dis[i] % K + 1);\n    }\n    return 0;\n  }\n  Mx = -1;\n  for (i = 1; i <= n; i++) {\n    Dis2[i] = Dis[i];\n    if (Mx < Dis[i]) Mx = Dis[i], b = i;\n  }\n  if (Mx < K - 1) {\n    puts(\"Yes\");\n    for (i = 1; i <= n; i++) printf(\"%d \", i % K + 1);\n    return 0;\n  }\n  DFS(b, 0, 0);\n  int Mn = 1e9, mid1 = 0, mid2 = 0, Mn2 = 1e9;\n  for (i = 1; i <= n; i++) {\n    if (Dis[i] + Dis2[i] == Dis[a]) {\n      int t = max(Dis[i], Dis2[i]);\n      if (t < Mn) {\n        Mn2 = Mn, mid2 = mid1;\n        Mn = t, mid1 = i;\n      } else if (t < Mn2) {\n        Mn2 = t, mid2 = i;\n      }\n    }\n  }\n  for (auto &x : E[mid1]) {\n    if (Dis[x] + Dis2[x] == Dis[a]) {\n      Go(mid1, x);\n      Go(x, mid1);\n      for (i = 1; i <= n; i++) {\n        if (D2[i] >= K - 1 && Deg[i] >= 3) {\n          break;\n        }\n      }\n      if (i == n + 1) {\n        Color(mid1, x, 1, 1);\n        Color(x, mid1, K, K - 1);\n        puts(\"Yes\");\n        for (i = 1; i <= n; i++) printf(\"%d \", R[i]);\n        return 0;\n      }\n    }\n  }\n  puts(\"No\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mxn = 200000;\nint n, k;\nint a[mxn], d[mxn], p[mxn], first[mxn];\nvector<int> g[mxn];\nint dfs(int c, int v) {\n  int ret = c;\n  for (int i : g[c])\n    if (i != p[c]) {\n      p[i] = c, d[i] = d[c] + 1, a[i] = (a[c] + v) % k;\n      int x = dfs(i, v);\n      if (d[x] > d[ret]) ret = x;\n    }\n  return ret;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> k;\n  for (int i = 0; i < n - 1; i++) {\n    int x, y;\n    cin >> x >> y;\n    x--, y--;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  d[0] = 0, p[0] = -1;\n  int x = dfs(0, 1);\n  d[x] = 0, p[x] = -1;\n  x = dfs(x, 1);\n  first[x] = -1;\n  for (int i = x; ~i; i = p[i]) {\n    if (~p[i]) first[p[i]] = i;\n    for (int j : g[i])\n      if (j != first[i] && j != p[i]) {\n        int z = d[i] < d[x] - d[i] ? k - 1 : 1;\n        d[j] = 0, p[j] = i, a[j] = (a[i] + z) % k;\n        int y = dfs(j, z);\n        if (k > 2 && min(d[i], d[x] - d[i]) + d[y] + 1 >= k - 1) {\n          cout << \"No\" << '\\n';\n          return 0;\n        }\n      }\n  }\n  cout << \"Yes\" << '\\n';\n  cout << (a[0] + 1);\n  for (int i = 1; i < n; i++) cout << \" \" << (a[i] + 1);\n  cout << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nconst long long INF = 0x3f3f3f3f3f3f3f3f;\nconst long long llinf = (1LL << 62);\nconst int inf = (1 << 30);\nconst int nmax = 2e5 + 50;\nconst long long mod = 1e9 + 7;\nusing namespace std;\nint n, k, i, md, rs[nmax], mx, x, y, ap[nmax], viz[nmax], f, s, da[nmax],\n    db[nmax];\nvector<int> dm, vc, a[nmax];\nqueue<int> q;\nvoid cll(int x, int p) {\n  rs[x] = rs[p] ^ 1;\n  for (int i = 0; i < (int)a[x].size(); i++) {\n    int y = a[x][i];\n    if (y == p) continue;\n    cll(y, x);\n  }\n}\nvoid dfs1(int x, int p, int d, int &cr) {\n  if (d >= mx) {\n    mx = d;\n    cr = x;\n  }\n  for (int i = 0; i < (int)a[x].size(); i++) {\n    int y = a[x][i];\n    if (y == p) continue;\n    dfs1(y, x, d + 1, cr);\n  }\n}\nvoid dfs2(int x, int p) {\n  vc.push_back(x);\n  if (x == s) dm = vc;\n  for (int i = 0; i < (int)a[x].size(); i++) {\n    int y = a[x][i];\n    if (y == p) continue;\n    dfs2(y, x);\n  }\n  vc.pop_back();\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cerr.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  for (i = 1; i < n; i++) {\n    cin >> x >> y;\n    a[x].push_back(y);\n    a[y].push_back(x);\n  }\n  if (k == 2) {\n    cll(1, 1);\n    cout << \"Yes\" << endl;\n    for (i = 1; i <= n; i++) cout << rs[i] + 1 << \" \";\n    cout << endl;\n    return 0;\n  }\n  dfs1(1, 1, 1, f);\n  dfs1(f, f, 1, s);\n  if (mx < k) {\n    cout << \"Yes\" << endl;\n    for (i = 1; i <= n; i++) cout << 1 << \" \";\n    cout << endl;\n    return 0;\n  }\n  dfs2(f, f);\n  for (i = 0; i < mx; i++) ap[dm[i]] = 1;\n  for (i = 1; i <= n; i++) da[i] = inf;\n  da[dm[0]] = 1;\n  q.push(dm[0]);\n  while (!q.empty()) {\n    x = q.front();\n    q.pop();\n    for (i = 0; i < (int)a[x].size(); i++) {\n      y = a[x][i];\n      if (da[y] != inf) continue;\n      da[y] = da[x] + 1;\n      q.push(y);\n    }\n  }\n  for (i = 1; i <= n; i++) db[i] = inf;\n  db[dm.back()] = 1;\n  q.push(dm.back());\n  while (!q.empty()) {\n    x = q.front();\n    q.pop();\n    for (i = 0; i < (int)a[x].size(); i++) {\n      y = a[x][i];\n      if (db[y] != inf) continue;\n      db[y] = db[x] + 1;\n      q.push(y);\n    }\n  }\n  for (i = 1; i <= n; i++)\n    if (!ap[i] && da[i] >= k && db[i] >= k) return cout << \"No\" << endl, 0;\n  md = (mx - 1) / 2;\n  rs[dm[md]] = 1;\n  viz[dm[md]] = 1;\n  if (md) viz[dm[md - 1]] = 1;\n  q.push(dm[md]);\n  while (!q.empty()) {\n    x = q.front();\n    q.pop();\n    for (i = 0; i < (int)a[x].size(); i++) {\n      y = a[x][i];\n      if (viz[y]) continue;\n      rs[y] = rs[x] + 1;\n      if (rs[y] == k + 1) rs[y] = 1;\n      q.push(y);\n      viz[y] = 1;\n    }\n  }\n  for (i = 1; i <= n; i++) viz[i] = 0;\n  rs[dm[md]] = 1;\n  viz[dm[md]] = 1;\n  if (md < mx - 1) viz[dm[md + 1]] = 1;\n  q.push(dm[md]);\n  while (!q.empty()) {\n    x = q.front();\n    q.pop();\n    for (i = 0; i < (int)a[x].size(); i++) {\n      y = a[x][i];\n      if (viz[y]) continue;\n      rs[y] = rs[x] - 1;\n      if (rs[y] == 0) rs[y] = k;\n      q.push(y);\n      viz[y] = 1;\n    }\n  }\n  cout << \"Yes\" << endl;\n  for (i = 1; i <= n; i++) cout << rs[i] << \" \";\n  cout << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 2e5 + 5;\nvector<long long> adj[N];\nbool isDiam[N];\nlong long Dist[N], color[N];\nlong long n, k;\nlong long bfs(long long start) {\n  queue<pair<long long, long long>> q;\n  q.push({start, start});\n  Dist[start] = 0;\n  long long mxDist = -1;\n  long long mxNode = -1;\n  while (!q.empty()) {\n    long long node = q.front().first;\n    long long prev = q.front().second;\n    q.pop();\n    if (mxDist < Dist[node]) {\n      mxDist = Dist[node];\n      mxNode = node;\n    }\n    for (long long to : adj[node]) {\n      if (to == prev) continue;\n      q.push({to, node});\n      Dist[to] = 1 + Dist[node];\n    }\n  }\n  assert(mxNode != -1);\n  return mxNode;\n}\nvoid dfs(long long node, long long par, long long Depth, long long depthOfFail,\n         long long currColor, bool forward) {\n  if (Depth >= depthOfFail) {\n    cout << \"No\\n\";\n    exit(0);\n  }\n  long long nextColor = (currColor - 1 + k) % k;\n  if (forward) nextColor = (currColor + 1) % k;\n  color[node] = nextColor;\n  for (long long child : adj[node]) {\n    if (child == par) continue;\n    dfs(child, node, Depth + 1, depthOfFail, nextColor, forward);\n  }\n}\nvoid dfs2(long long node, long long par) {\n  for (long long child : adj[node]) {\n    if (child == par) continue;\n    color[child] = 1 + color[node];\n    dfs2(child, node);\n  }\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  for (long long i = 0; i < n - 1; ++i) {\n    long long u, v;\n    cin >> u >> v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  if (k == 2) {\n    dfs2(1, 1);\n    cout << \"Yes\\n\";\n    for (long long i = 1; i <= n; ++i) {\n      cout << (color[i] % 2) + 1 << ' ';\n    }\n    return 0;\n  }\n  long long end1 = bfs(1);\n  long long end2 = bfs(end1);\n  long long curr = end2;\n  vector<long long> diam;\n  while (curr != end1) {\n    diam.push_back(curr);\n    for (long long to : adj[curr]) {\n      if (Dist[to] == -1 + Dist[curr]) {\n        curr = to;\n        break;\n      }\n    }\n  }\n  diam.push_back(end1);\n  if ((long long)diam.size() < k) {\n    cout << \"Yes\\n\";\n    for (long long i = 0; i < n; ++i) {\n      cout << 1 << ' ';\n    }\n    return 0;\n  }\n  for (long long node : diam) isDiam[node] = true;\n  for (long long i = 0; i < (long long)diam.size(); ++i) {\n    color[diam[i]] = (i % k);\n    long long depthOfFail = k - (1 + min(i, (long long)diam.size() - i - 1));\n    for (long long to : adj[diam[i]]) {\n      if (isDiam[to]) continue;\n      assert(i != 0 && i + 1 != (long long)diam.size());\n      bool forward = (i > (long long)diam.size() - i - 1);\n      dfs(to, diam[i], 1, depthOfFail, color[diam[i]], forward);\n    }\n  }\n  cout << \"Yes\\n\";\n  for (long long i = 1; i <= n; ++i) {\n    cout << color[i] + 1 << ' ';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 200005;\nstruct Edge {\n  int to;\n  int nxt;\n} edge[MAXN << 1];\nint n, m, id;\nint first[MAXN];\nint f[MAXN];\nint g[MAXN];\nint ans[MAXN];\nvector<int> d;\nvoid addE(int u, int v) {\n  edge[++id] = (Edge){v, first[u]};\n  first[u] = id;\n}\nvoid dfs1(int u, int fa) {\n  for (int i = first[u]; i; i = edge[i].nxt)\n    if (edge[i].to != fa) {\n      dfs1(edge[i].to, u);\n      f[u] = max(f[u], f[edge[i].to]);\n    }\n  f[u]++;\n}\nvoid dfs2(int u, int fa) {\n  g[u]++;\n  int MAX = 0;\n  for (int i = first[u]; i; i = edge[i].nxt)\n    if (edge[i].to != fa && f[edge[i].to] > f[MAX]) MAX = edge[i].to;\n  int MX = g[u];\n  for (int i = first[u]; i; i = edge[i].nxt)\n    if (edge[i].to != fa && edge[i].to != MAX) {\n      g[edge[i].to] = max(g[u], f[MAX] + 1);\n      MX = max(MX, f[edge[i].to] + 1);\n    }\n  g[MAX] = MX;\n  for (int i = first[u]; i; i = edge[i].nxt)\n    if (edge[i].to != fa) dfs2(edge[i].to, u);\n}\npair<int, int> dfs(int u, int fa) {\n  pair<int, int> res = make_pair(0, u);\n  for (int i = first[u]; i; i = edge[i].nxt)\n    if (edge[i].to != fa) {\n      pair<int, int> ret = dfs(edge[i].to, u);\n      if (ret.first > res.first) res = ret;\n    }\n  res.first++;\n  return res;\n}\nbool get(int u, int T, int fa) {\n  if (u == T) {\n    d.push_back(u);\n    return 1;\n  }\n  for (int i = first[u]; i; i = edge[i].nxt)\n    if (edge[i].to != fa && get(edge[i].to, T, u)) {\n      d.push_back(u);\n      return 1;\n    }\n  return 0;\n}\nvoid fill(int u, int v, int dv) {\n  if (ans[u]) return;\n  if (!v) v = m;\n  if (v == m + 1) v = 1;\n  ans[u] = v;\n  for (int i = first[u]; i; i = edge[i].nxt) fill(edge[i].to, v + dv, dv);\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int u, v, i = 1; i < n; i++) {\n    scanf(\"%d%d\", &u, &v);\n    addE(u, v);\n    addE(v, u);\n  }\n  dfs1(1, 0);\n  dfs2(1, 0);\n  for (int i = 1; i <= n; i++) {\n    int MAX1 = 0, MAX2 = 0, MAX3 = 0;\n    for (int j = first[i]; j; j = edge[j].nxt) {\n      int dep = f[edge[j].to] > f[i] ? g[i] - 1 : f[edge[j].to];\n      if (dep >= MAX1) {\n        MAX3 = MAX2;\n        MAX2 = MAX1;\n        MAX1 = dep;\n      } else if (dep >= MAX2) {\n        MAX3 = MAX2;\n        MAX2 = dep;\n      } else if (dep > MAX3)\n        MAX3 = dep;\n    }\n    if (MAX3 && MAX2 + MAX3 + 1 >= m && m > 2) {\n      puts(\"No\");\n      return 0;\n    }\n  }\n  puts(\"Yes\");\n  int key = dfs(1, 0).second, nxt = dfs(key, 0).second;\n  get(key, nxt, 0);\n  int t = 0;\n  for (int i = 0; i < d.size(); i++) {\n    t = t % m + 1;\n    ans[d[i]] = t;\n  }\n  for (int i = 0; i < d.size(); i++)\n    for (int j = first[d[i]]; j; j = edge[j].nxt) {\n      if (i >= d.size() - i)\n        fill(edge[j].to, ans[d[i]] + 1, 1);\n      else\n        fill(edge[j].to, ans[d[i]] - 1, -1);\n    }\n  for (int i = 1; i <= n; i++) printf(\"%d \", ans[i]);\n  printf(\"\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> adj;\nvector<int> max_depth, depth, color;\nvoid dfs_depth(int current_v, int parent_v) {\n  if (current_v == parent_v) depth[current_v] = -1;\n  depth[current_v] = depth[parent_v] + 1;\n  max_depth[current_v] = depth[current_v];\n  for (auto child_v : adj[current_v]) {\n    if (child_v == parent_v) continue;\n    dfs_depth(child_v, current_v);\n    max_depth[current_v] = max(max_depth[current_v], max_depth[child_v]);\n  }\n}\nvector<int> get_diameter_path(int n) {\n  dfs_depth(1, 1);\n  int max_d = 0, leaf_of_interest = 0;\n  for (int i = 1; i <= n; ++i) {\n    if (depth[i] > max_d) {\n      max_d = depth[i];\n      leaf_of_interest = i;\n    }\n  }\n  dfs_depth(leaf_of_interest, leaf_of_interest);\n  int current_v = leaf_of_interest, parent_v = leaf_of_interest;\n  vector<int> diameter_path;\n  bool has_next_v = true;\n  while (has_next_v) {\n    diameter_path.push_back(current_v);\n    has_next_v = false;\n    int next_v = 0, max_d = 0;\n    for (auto child_v : adj[current_v]) {\n      if (child_v == parent_v) continue;\n      has_next_v = true;\n      if (max_depth[child_v] > max_d) {\n        next_v = child_v;\n        max_d = max_depth[child_v];\n      }\n    }\n    parent_v = current_v;\n    current_v = next_v;\n  }\n  return diameter_path;\n}\npair<int, int> get_max_2ndmax(int root_v, int n, bool unique = false) {\n  dfs_depth(root_v, root_v);\n  int max_d = 0, second_max_d = 0;\n  for (int i = 1; i <= n; ++i) {\n    if (max_depth[i] > max_d) {\n      second_max_d = max_d;\n      max_d = max_depth[i];\n    } else if (max_depth[i] == max_d) {\n      if (!unique) {\n        second_max_d = max_d;\n        max_d = max_depth[i];\n      }\n    } else if (max_depth[i] > second_max_d) {\n      second_max_d = max_depth[i];\n    }\n  }\n  return make_pair(max_d, second_max_d);\n}\nbool dfs2(int current_v, int parent_v, int max_d_up, int k) {\n  multiset<int> temp;\n  for (auto child_v : adj[current_v]) {\n    if (child_v == parent_v) continue;\n    temp.insert(max_depth[child_v] - depth[current_v]);\n  }\n  if (max_d_up) temp.insert(max_d_up);\n  if (temp.size() >= 3) {\n    auto it2 = temp.end();\n    auto it3 = it2;\n    --it2;\n    --it2;\n    --it3;\n    --it3;\n    --it3;\n    if (*it2 + *it3 >= k - 1) return false;\n  }\n  for (auto child_v : adj[current_v]) {\n    if (child_v == parent_v || temp.empty()) continue;\n    auto it = temp.find(max_depth[child_v] - depth[current_v]);\n    temp.erase(it);\n    int child_max_d_up = 0;\n    if (!temp.empty()) {\n      it = temp.end();\n      --it;\n      child_max_d_up = *it;\n    }\n    if (!dfs2(child_v, current_v, child_max_d_up + 1, k)) return false;\n    temp.insert(max_depth[child_v] - depth[current_v]);\n  }\n  return true;\n}\nbool possible(int n, int k) {\n  dfs_depth(1, 1);\n  return dfs2(1, 1, 0, k);\n}\nvoid dfs_color(int current_v, int parent_v, int change, int k) {\n  if (current_v != parent_v) {\n    color[current_v] = color[parent_v] + change;\n  }\n  if (color[current_v] > k) color[current_v] = 1;\n  if (!color[current_v]) color[current_v] = k;\n  for (auto child_v : adj[current_v]) {\n    if (!color[child_v]) dfs_color(child_v, current_v, change, k);\n  }\n}\nint main() {\n  int n, k;\n  scanf(\"%d %d\", &n, &k);\n  adj = vector<vector<int>>(n + 1, vector<int>());\n  max_depth = vector<int>(n + 1, 0);\n  depth = vector<int>(n + 1, 0);\n  color = vector<int>(n + 1, 0);\n  for (int i = 0; i < n - 1; ++i) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  if (k == 2) {\n    color[1] = 1;\n    dfs_color(1, 1, 1, k);\n    printf(\"Yes\\n\");\n    for (int i = 1; i <= n; ++i) printf(\"%d \", color[i]);\n    printf(\"\\n\");\n    return 0;\n  }\n  if (!possible(n, k)) {\n    printf(\"No\\n\");\n    return 0;\n  }\n  vector<int> diameter_path = get_diameter_path(n);\n  int diameter = diameter_path.size();\n  int central_v = diameter_path[diameter / 2];\n  pair<int, int> res = get_max_2ndmax(central_v, n);\n  int max_d = res.first, second_max_d = res.second;\n  vector<int> child_set1, child_set2;\n  for (auto child_v : adj[central_v]) {\n    if (max_depth[child_v] == max_d) {\n      child_set1.push_back(child_v);\n    } else if (max_depth[child_v] == second_max_d) {\n      child_set2.push_back(child_v);\n    }\n  }\n  if (max_d == second_max_d) {\n    child_set2.push_back(child_set1.back());\n    child_set1.pop_back();\n  }\n  color[central_v] = 1;\n  for (auto v : child_set1) {\n    dfs_color(v, central_v, 1, k);\n  }\n  for (auto v : child_set2) {\n    dfs_color(v, central_v, -1, k);\n  }\n  dfs_color(central_v, central_v, 1, k);\n  printf(\"Yes\\n\");\n  for (int i = 1; i <= n; ++i) printf(\"%d \", color[i]);\n  printf(\"\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 5;\nvector<int> E[MAXN];\nint clr[MAXN], dep[MAXN];\nint n, k, mxdep;\nbool tag[MAXN];\nint nxt(int x) { return (x == k) ? 1 : x + 1; }\nint lst(int x) { return (x == 1) ? k : x - 1; }\nvoid dfs1(int x, int f) {\n  dep[x] = dep[f] + 1;\n  for (auto v : E[x])\n    if (v != f) dfs1(v, x);\n}\nint getpos(int x) {\n  dfs1(x, 0);\n  int mx = x;\n  for (int i = 1; i <= n; i++)\n    if (dep[i] > dep[mx]) mx = i;\n  return mx;\n}\nvoid dfs2(int x, int f) {\n  for (auto v : E[x])\n    if (v != f) {\n      dfs2(v, x);\n      tag[x] |= tag[v];\n    }\n}\nint f[MAXN], g[MAXN];\nvoid dfs4(int x, int fa, int tp) {\n  if (tp)\n    clr[x] = nxt(clr[fa]);\n  else\n    clr[x] = lst(clr[fa]);\n  for (auto v : E[x])\n    if (v != fa) {\n      dfs4(v, x, tp);\n      if (f[v] + 1 > f[x])\n        g[x] = f[x], f[x] = f[v] + 1;\n      else if (f[v] + 1 > g[x])\n        g[x] = f[v] + 1;\n    }\n  if (f[x] && g[x] && f[x] + g[x] + 1 >= k) {\n    puts(\"No\");\n    exit(0);\n  }\n}\nvoid dfs3(int x, int fa) {\n  clr[x] = nxt(clr[fa]);\n  f[x] = g[x] = 0;\n  for (auto v : E[x])\n    if (v != fa) {\n      if (tag[v])\n        dfs3(v, x);\n      else {\n        if (dep[x] <= mxdep - dep[x] + 1)\n          dfs4(v, x, 0);\n        else\n          dfs4(v, x, 1);\n        if (f[v] + 1 > f[x])\n          g[x] = f[x], f[x] = f[v] + 1;\n        else if (f[v] + 1 > g[x])\n          g[x] = f[v] + 1;\n      }\n    }\n  if (f[x] && g[x] && f[x] + g[x] + 1 >= k) {\n    puts(\"No\");\n    exit(0);\n  }\n  if (f[x] && f[x] + dep[x] >= k && f[x] + mxdep - dep[x] + 1 >= k) {\n    puts(\"No\");\n    exit(0);\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    E[u].push_back(v);\n    E[v].push_back(u);\n  }\n  if (k == 2) {\n    puts(\"Yes\");\n    getpos(1);\n    for (int i = 1; i <= n; i++) printf(\"%d \", (dep[i] & 1) + 1);\n    puts(\"\");\n    return 0;\n  }\n  int p = getpos(1);\n  int q = getpos(p);\n  mxdep = dep[q];\n  tag[q] = true;\n  dfs2(p, 0);\n  clr[0] = k;\n  dfs3(p, 0);\n  puts(\"Yes\");\n  for (int i = 1; i <= n; i++) printf(\"%d \", clr[i]);\n  puts(\"\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nclass DFS {\n  int N_, R_;\n  vector<vector<int> > G_;\n  vector<int> par_, dep_, dep_sub_;\n  void DFS_internal(int v) {\n    dep_sub_[v] = 0;\n    for (auto u : G_[v])\n      if (par_[u] == -1) {\n        par_[u] = v;\n        dep_[u] = dep_[v] + 1;\n        DFS_internal(u);\n        dep_sub_[v] = max(dep_sub_[v], dep_sub_[u] + 1);\n      }\n  }\n\n public:\n  DFS(vector<vector<int> >& G, int R) : N_(G.size()), R_(R), G_(G) {\n    par_.resize(N_, -1);\n    dep_.resize(N_);\n    dep_sub_.resize(N_);\n    par_[R_] = R_;\n    dep_[R_] = 0;\n    DFS_internal(R_);\n  }\n  int max_dep_id() {\n    int ret = -1, max_dep = -1;\n    for (int i = 0; i < N_; i++)\n      if (max_dep < dep_[i]) {\n        max_dep = dep_[i];\n        ret = i;\n      }\n    return ret;\n  }\n  int dep(int v) { return dep_[v]; }\n  int par(int v) { return par_[v]; }\n  int dep_subtree(int v) { return dep_sub_[v]; }\n};\nint main() {\n  cin.sync_with_stdio(0);\n  cin.tie(0);\n  int N, K;\n  cin >> N >> K;\n  vector<vector<int> > G(N);\n  for (int i = 0; i < N - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n    G[--u].push_back(--v);\n    G[v].push_back(u);\n  }\n  DFS DFS0(G, 0);\n  int R1 = DFS0.max_dep_id();\n  DFS DFS1(G, R1);\n  int R2 = DFS1.max_dep_id();\n  DFS DFS2(G, R2);\n  int D = DFS1.dep(R2);\n  if (K == 2) {\n    cout << \"Yes\\n\";\n    for (int i = 0; i < N; i++)\n      cout << DFS1.dep(i) % 2 + 1 << ((i == N - 1) ? \"\\n\" : \" \");\n    return 0;\n  }\n  vector<int> ans(N);\n  for (int i = 0; i < N; i++) {\n    if (DFS1.dep(i) + DFS2.dep(i) - D == 0) {\n      ans[i] = DFS1.dep(i) % K + 1;\n      continue;\n    }\n    int d1 = DFS1.dep_subtree(i) + DFS1.dep(i);\n    int d2 = DFS1.dep_subtree(i) + DFS2.dep(i);\n    if (min(d1, d2) >= K - 1) {\n      cout << \"No\\n\";\n      return 0;\n    }\n    if (max(d1, d2) < K - 1) {\n      ans[i] = 1;\n      continue;\n    }\n    if (d1 > d2)\n      ans[i] = DFS1.dep(i) % K + 1;\n    else\n      ans[i] = (D + K - DFS2.dep(i) % K) % K + 1;\n  }\n  cout << \"Yes\\n\";\n  for (int i = 0; i < N; i++) cout << ans[i] << ((i == N - 1) ? \"\\n\" : \" \");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nusing namespace std;\nstringstream output;\ninline void eOP();\ninline void solve() {\n  int n, k;\n  cin >> n >> k;\n  vector<unordered_set<int>> edges(n + 1);\n  for (int _ = 0; _ < n - 1; ++_) {\n    int u, v;\n    cin >> u >> v;\n    edges[u].insert(v);\n    edges[v].insert(u);\n  }\n  vector<int> dist(n + 1);\n  list<int> q;\n  dist[1] = 1;\n  q.push_back(1);\n  int s;\n  while (!q.empty()) {\n    s = q.front();\n    q.pop_front();\n    for (int c : edges[s]) {\n      if (dist[c]) {\n        continue;\n      }\n      dist[c] = dist[s] + 1;\n      q.push_back(c);\n    }\n  }\n  if (k == 2) {\n    cout << \"Yes\\n\";\n    for (int i = 1; i <= n; ++i) {\n      cout << ((dist[i] & 1) + 1) << \" \";\n    }\n    return;\n  }\n  dist = vector<int>(n + 1);\n  dist[s] = 1;\n  q.push_back(s);\n  int f;\n  while (!q.empty()) {\n    f = q.front();\n    q.pop_front();\n    for (int c : edges[f]) {\n      if (dist[c]) {\n        continue;\n      }\n      dist[c] = dist[f] + 1;\n      q.push_back(c);\n    }\n  }\n  int len = dist[f];\n  vector<int> base(len + 1);\n  {\n    int i = f;\n    while (i != s) {\n      base[dist[i]] = i;\n      for (int j : edges[i]) {\n        if (dist[j] < dist[i]) {\n          i = j;\n          break;\n        }\n      }\n    }\n    base[1] = s;\n  }\n  for (int i = 1; i < len; ++i) {\n    edges[base[i]].erase(base[i + 1]);\n    edges[base[i + 1]].erase(base[i]);\n  }\n  vector<int> colours(n + 1);\n  for (int i = 1; i <= len; ++i) {\n    colours[base[i]] = i;\n    q.push_back(base[i]);\n    int l = base[i];\n    while (!q.empty()) {\n      l = q.front();\n      q.pop_front();\n      for (int c : edges[l]) {\n        if (colours[c]) {\n          continue;\n        }\n        colours[c] = colours[l] + (i << 1 > len ? 1 : -1);\n        q.push_back(c);\n      }\n    }\n    if (l == base[i]) {\n      continue;\n    }\n    if ((len - i) + abs(colours[l] - i) + 1 >= k &&\n        abs(colours[l] - i) + (i - 1) + 1 >= k) {\n      cout << \"No\";\n      return;\n    }\n  }\n  cout << \"Yes\\n\";\n  for (int i = 1; i <= n; ++i) {\n    cout << (colours[i] % k + 1) << \" \";\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  size_t t = 1;\n  for (int i = 0; i < t; ++i) {\n    solve();\n  }\n  eOP();\n}\ninline void eOP() {\n  cout << output.str();\n  output.str(string());\n  exit(0);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <class T>\nT Min(const T &a, const T &b) {\n  return a < b ? a : b;\n}\ntemplate <class T>\nT Max(const T &a, const T &b) {\n  return a > b ? a : b;\n}\ntemplate <class T>\nbool Chkmin(T &a, const T &b) {\n  return a > b ? a = b, 1 : 0;\n}\ntemplate <class T>\nbool Chkmax(T &a, const T &b) {\n  return a < b ? a = b, 1 : 0;\n}\nstruct fast_input {\n  static const int L = 1 << 15 | 1;\n  char buf[L], *l, *r;\n  fast_input() { l = r = buf; }\n  void Next(char &c) {\n    if (l == r) r = (l = buf) + fread(buf, 1, L, stdin);\n    c = l == r ? (char)EOF : *l++;\n  }\n  template <class T>\n  void operator()(T &x) {\n    char c, f = 0;\n    for (Next(c); !isdigit(c); Next(c))\n      if (c == '-') f = 1;\n    for (x = 0; isdigit(c); Next(c)) x = x * 10 + c - '0';\n    if (f) x = -x;\n  }\n} input;\nconst int N = 200000 + 47;\nconst int INF = 0x3f3f3f3f;\nint head[N], nxt[N << 1], to[N << 1], tot;\nint mc1[N], mc2[N], fc1[N], fc2[N], n, k, ans[N];\nvoid add(int x, int y) {\n  nxt[++tot] = head[x], head[x] = tot, to[tot] = y;\n  nxt[++tot] = head[y], head[y] = tot, to[tot] = x;\n}\nvoid solvek2(int x, int fa) {\n  for (int i = head[x]; i; i = nxt[i])\n    if (to[i] != fa) ans[to[i]] = ans[x] ^ 1, solvek2(to[i], x);\n}\nbool check1(int x, int fa) {\n  int mx1 = -INF, mx2 = -INF, fr1 = 0, fr2 = 0, s = 1;\n  for (int i = head[x]; i; i = nxt[i])\n    if (to[i] != fa) {\n      if (!check1(to[i], x)) return false;\n      s = mc1[to[i]] < 0 ? 1 : mc1[to[i]] + 1;\n      if (std::min(mx1 + mx2, std::min(mx1, mx2) + s) >= k - 1) return false;\n      if (s > mx1)\n        mx2 = mx1, fr2 = fr1, fr1 = to[i], mx1 = s;\n      else if (Chkmax(mx2, s))\n        fr2 = to[i];\n    }\n  mc1[x] = mx1, mc2[x] = mx2, fc1[x] = fr1, fc2[x] = fr2;\n  return true;\n}\nbool check2(int x, int fa) {\n  int t, ft, u;\n  for (int i = head[x]; i; i = nxt[i])\n    if ((u = to[i]) != fa) {\n      if (fc1[x] != to[i])\n        t = mc1[x] + 1, ft = x;\n      else\n        t = mc2[x] + 1, ft = x;\n      if (t < 0) t = 1, ft = x;\n      if (std::min(mc1[u] + mc2[u], std::min(mc1[u], mc2[u]) + t) >= k - 1)\n        return false;\n      if (t > mc1[u])\n        mc2[u] = mc1[u], fc2[u] = fc1[u], mc1[u] = t, fc1[u] = x;\n      else if (Chkmax(mc2[u], t))\n        fc2[u] = x;\n      if (!check2(to[i], x)) return false;\n    }\n  return true;\n}\nint goal, maxl;\nint getfp(int x, int fa, int d) {\n  if (Chkmax(maxl, d)) goal = x;\n  for (int i = head[x]; i; i = nxt[i])\n    if (to[i] != fa) getfp(to[i], x, d + 1);\n}\nint p1, p2, c1, c2;\nbool getc(int x, int fa, int d) {\n  if (x == p2) return true;\n  for (int i = head[x]; i; i = nxt[i])\n    if (to[i] != fa) {\n      if (getc(to[i], x, d + 1)) {\n        if (d == maxl / 2 + 1 && !c1) c1 = x;\n        if (to[i] == c1) c2 = x;\n        return true;\n      }\n    }\n  return false;\n}\nbool printd(int x, int fa) {\n  if (x == p2) {\n    ans[x] = 1;\n    return true;\n  }\n  for (int i = head[x]; i; i = nxt[i])\n    if (to[i] != fa && printd(to[i], x)) {\n      ans[x] = ans[to[i]] + 1;\n      if (ans[x] > k) ans[x] -= k;\n      return true;\n    }\n  return false;\n}\nvoid printo(int x, int fa, int t) {\n  for (int i = head[x]; i; i = nxt[i]) {\n    if (to[i] == fa) continue;\n    if (ans[to[i]])\n      printo(to[i], x, t);\n    else {\n      ans[to[i]] = ans[x] + t;\n      if (ans[to[i]] > k) ans[to[i]] -= k;\n      if (ans[to[i]] < 1) ans[to[i]] += k;\n      printo(to[i], x, t);\n    }\n  }\n}\nint main() {\n  int x, y, z;\n  input(n), input(k);\n  for (int i = 2; i <= n; ++i) input(x), input(y), add(x, y);\n  if (k == 2) {\n    ans[1] = 1, solvek2(1, -1);\n    for (int i = (1), i_end = (n); i <= i_end; ++i)\n      if (!ans[i]) ans[i] = 2;\n  } else {\n    if (!check1(1, -1)) {\n      puts(\"No\");\n      return 0;\n    }\n    if (!check2(1, -1)) {\n      puts(\"No\");\n      return 0;\n    }\n    maxl = -1, getfp(1, -1, 1), p1 = goal;\n    maxl = -1, getfp(goal, -1, 1), p2 = goal;\n    getc(p1, -1, 1);\n    printd(p1, -1);\n    printo(c1, c2, -1);\n    printo(c2, c1, 1);\n  }\n  puts(\"Yes\");\n  for (int i = 1; i <= n; ++i) printf(\"%d \", ans[i]);\n  putchar(10);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MN = 5e5 + 5;\nstruct Edge {\n  int to, nxt;\n} E[MN << 1];\nint N, K, r1, r2, d1, d2, tot;\nint head[MN], s1[MN], s2[MN];\ninline void AddEdge(int u, int v) {\n  E[++tot] = (Edge){v, head[u]};\n  head[u] = tot;\n}\ninline void dfs1(int x, int fa, int dep) {\n  if (dep > d1) r1 = x, d1 = dep;\n  for (int i = head[x]; i; i = E[i].nxt)\n    if (E[i].to != fa) dfs1(E[i].to, x, dep + 1);\n}\ninline void dfs2(int x) {\n  if (s1[x] > s1[r2]) r2 = x;\n  for (int i = head[x]; i; i = E[i].nxt)\n    if (!s1[E[i].to]) {\n      s1[E[i].to] = s1[x] + 1;\n      dfs2(E[i].to);\n    }\n}\ninline void dfs3(int x) {\n  for (int i = head[x]; i; i = E[i].nxt)\n    if (!s2[E[i].to]) {\n      s2[E[i].to] = s2[x] - 1;\n      dfs3(E[i].to);\n    }\n}\nint main() {\n  scanf(\"%d%d\", &N, &K);\n  for (int i = 1; i < N; ++i) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    AddEdge(u, v);\n    AddEdge(v, u);\n  }\n  dfs1(1, 0, 1);\n  s1[r1] = 1;\n  dfs2(r1);\n  s2[r2] = s1[r2];\n  dfs3(r2);\n  for (int i = 1; i <= N; ++i)\n    if (s1[i] >= K && s2[r2] - s2[i] + 1 >= K && s1[i] % K != s2[i] % K) {\n      puts(\"No\");\n      return 0;\n    }\n  puts(\"Yes\");\n  for (int i = 1; i <= N; ++i) {\n    if (s1[i] >= s2[r2] - s2[i] + 1)\n      printf(\"%d\", (s1[i] - 1) % K + 1);\n    else\n      printf(\"%d\", (s2[i] - 1) % K + 1);\n    putchar((i == N) ? '\\n' : ' ');\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\", \"unroll-loops\")\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\ndefault_random_engine generator;\nconst int MAXN = 200200;\nint n, k;\nvector<int> g[MAXN];\nint dist[2][MAXN];\npair<int, int> dfs(int v, int p = -1) {\n  pair<int, int> res = {-1, v};\n  for (int u : g[v]) {\n    if (u == p) {\n      continue;\n    }\n    res = max(res, dfs(u, v));\n  }\n  ++res.first;\n  return res;\n}\nvoid dfs1(int v, int k, int d, int p = -1) {\n  dist[k][v] = d;\n  for (int u : g[v]) {\n    if (u == p) {\n      continue;\n    }\n    dfs1(u, k, d + 1, v);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  for (int i = 0; i < n - 1; ++i) {\n    int u, v;\n    cin >> u >> v;\n    --u;\n    --v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  pair<int, int> p = dfs(0);\n  int u = p.second;\n  p = dfs(u);\n  int v = p.second;\n  int len = p.first;\n  dfs1(u, 0, 0);\n  dfs1(v, 1, 0);\n  vector<int> col(n);\n  for (int i = 0; i < n; ++i) {\n    int d = (dist[0][i] + dist[1][i] - len) / 2;\n    int a = dist[0][i] - d;\n    int b = dist[1][i] - d;\n    if (d == 0) {\n      col[i] = dist[0][i] % k;\n      continue;\n    }\n    if (a + d >= k - 1 && b + d >= k - 1 && d <= k - 2) {\n      cout << \"No\" << endl;\n      return 0;\n    }\n    if (a >= b) {\n      col[i] = (a - (k - d)) % k;\n      if (col[i] < 0) {\n        col[i] += k;\n      }\n    } else {\n      col[i] = (a + (k - d)) % k;\n      if (col[i] < 0) {\n        col[i] += k;\n      }\n    }\n  }\n  cout << \"Yes\" << endl;\n  for (int c : col) {\n    cout << c + 1 << \" \";\n  }\n  cout << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> node[200000];\nint furthest(int p, int depth = 0, int par = -1) {\n  static int ans, max_depth;\n  if (depth == 0 || depth > max_depth) {\n    max_depth = depth;\n    ans = p;\n  }\n  for (int i : node[p]) {\n    if (i == par) continue;\n    furthest(i, depth + 1, p);\n  }\n  return ans;\n}\nint col[200000];\nint n, k;\nint node_depth[200000], max_depth[200000], heavy[200000];\nvoid dfs1(int p, int depth = 0, int par = -1) {\n  node_depth[p] = depth;\n  max_depth[p] = 0;\n  for (int i : node[p]) {\n    if (i == par) continue;\n    dfs1(i, depth + 1, p);\n    if (max_depth[i] + 1 > max_depth[p]) {\n      heavy[p] = i;\n      max_depth[p] = max_depth[i] + 1;\n    }\n  }\n}\nvoid greedy(int p, int c, int dc, int par) {\n  c = (c + k + dc) % k;\n  col[p] = c;\n  for (int i : node[p]) {\n    if (i == par) continue;\n    greedy(i, c, dc, p);\n  }\n}\nvoid check(int a, int b, int c) {\n  if (k > 2 && a + b + 1 >= k && a + c + 1 >= k && b + c + 1 >= k) {\n    cout << \"No\" << endl;\n    exit(0);\n  }\n}\nvoid dfs2(int p, int depth = 0, int par = -1) {\n  col[p] = depth % k;\n  for (int i : node[p]) {\n    if (i == par) continue;\n    if (i == heavy[p]) {\n      dfs2(i, depth + 1, p);\n    } else {\n      check(max_depth[p], depth, max_depth[i] + 1);\n      greedy(i, depth % k, depth > max_depth[p] ? 1 : -1, p);\n    }\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> k;\n  for (int i = 1; i < n; i++) {\n    int a, b;\n    cin >> a >> b;\n    a--, b--;\n    node[a].push_back(b);\n    node[b].push_back(a);\n  }\n  int x = furthest(0);\n  int root = furthest(x);\n  dfs1(root);\n  dfs2(root);\n  cout << \"Yes\" << endl;\n  for (int i = 0; i < n; i++) cout << col[i] + 1 << ' ';\n  cout << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\nvector<int> e[N];\nint lo, md;\nvoid dfs1(int v, int p, int d) {\n  if (d > md) {\n    lo = v;\n    md = d;\n  }\n  for (int u : e[v])\n    if (u != p) dfs1(u, v, d + 1);\n}\nint k;\nint h[N], col[N];\nvoid up(int v, int p, int d) {\n  col[v] = (d % k + k) % k + 1;\n  for (int u : e[v])\n    if (u != p) up(u, v, d - 1);\n}\nvoid dfs2(int v, int p, int d) {\n  col[v] = d % k + 1;\n  h[v] = 1;\n  for (int u : e[v])\n    if (u != p) {\n      dfs2(u, v, d + 1);\n      h[v] = max(h[v], h[u] + 1);\n    }\n  int c = 0;\n  int th = min(h[v], d);\n  if (k > 2)\n    for (int u : e[v])\n      if (u != p) {\n        if (th + h[u] >= k) {\n          if (c++) {\n            cout << \"No\\n\";\n            exit(0);\n          }\n        } else if (h[v] + h[u] >= k)\n          up(u, v, d - 1);\n      }\n}\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  int n;\n  cin >> n >> k;\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    cin >> u >> v;\n    e[u].push_back(v);\n    e[v].push_back(u);\n  }\n  dfs1(1, 1, 0);\n  int root = lo;\n  dfs2(root, root, 1);\n  cout << \"Yes\\n\";\n  for (int i = 1; i <= n; i++) cout << col[i] << \" \\n\"[i == n];\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskH solver = new TaskH();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class TaskH {\n        boolean valid = true;\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int k = in.readInt();\n            Node[] nodes = new Node[n + 1];\n            for (int i = 1; i <= n; i++) {\n                nodes[i] = new Node();\n                nodes[i].id = i;\n            }\n            for (int i = 1; i < n; i++) {\n                Node a = nodes[in.readInt()];\n                Node b = nodes[in.readInt()];\n                a.next.add(b);\n                b.next.add(a);\n            }\n            findDiameter(nodes[1], null, 0);\n            List<Node> trace = new ArrayList<>(n);\n            dfsForTrace(nodes[1].a, null, 0, nodes[1].diameter, trace);\n\n            int half = trace.size() / 2;\n            Node a = trace.get(half - 1);\n            Node b = trace.get(half);\n            a.next.remove(b);\n            b.next.remove(a);\n            paint(a, b, 0, k, -1);\n            paint(b, a, 1, k, 1);\n            verify(a, b, 0, k);\n            verify(b, a, 0, k);\n            if (!valid) {\n                out.println(\"No\");\n                return;\n            }\n            out.println(\"Yes\");\n            for (int i = 1; i <= n; i++) {\n                out.append(nodes[i].color + 1).append(' ');\n            }\n        }\n\n        public void verify(Node root, Node p, int depth, int k) {\n            root.depth = depth;\n            root.depthest = root;\n            for (Node node : root.next) {\n                if (node == p) {\n                    continue;\n                }\n                verify(node, root, depth + 1, k);\n                if (root.depthest != root && node.depthest.depth + root.depthest.depth - depth * 2 + 1 >= k && k > 2) {\n                    valid = false;\n                }\n                if (node.depthest.depth > root.depthest.depth) {\n                    root.depthest = node.depthest;\n                }\n            }\n        }\n\n        public void paint(Node root, Node p, int color, int k, int step) {\n            root.color = DigitUtils.mod(color, k);\n            for (Node node : root.next) {\n                if (node == p) {\n                    continue;\n                }\n                paint(node, root, color + step, k, step);\n            }\n        }\n\n        public boolean dfsForTrace(Node root, Node p, int depth, int diameter, List<Node> trace) {\n            trace.add(root);\n            if (depth == diameter) {\n                return true;\n            }\n            for (Node node : root.next) {\n                if (node == p) {\n                    continue;\n                }\n                if (dfsForTrace(node, root, depth + 1, diameter, trace)) {\n                    return true;\n                }\n            }\n            trace.remove(trace.size() - 1);\n            return false;\n        }\n\n        public void findDiameter(Node root, Node p, int depth) {\n            root.depth = depth;\n            root.depthest = root;\n            for (Node node : root.next) {\n                if (node == p) {\n                    continue;\n                }\n                findDiameter(node, root, depth + 1);\n                if (root.diameter < node.diameter) {\n                    root.diameter = node.diameter;\n                    root.a = node.a;\n                }\n                if (root.depthest.depth + node.depthest.depth - root.depth * 2 > root.diameter) {\n                    root.diameter = root.depthest.depth + node.depthest.depth - 2 * root.depth;\n                    root.a = root.depthest;\n                }\n                if (root.depthest.depth < node.depthest.depth) {\n                    root.depthest = node.depthest;\n                }\n            }\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(String c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class Node {\n        List<Node> next = new ArrayList<>();\n        int color;\n        Node depthest;\n        int depth;\n        int diameter;\n        Node a;\n        int id;\n\n        public String toString() {\n            return \"\" + id;\n        }\n\n    }\n\n    static class DigitUtils {\n        private DigitUtils() {\n        }\n\n        public static int mod(int x, int mod) {\n            x %= mod;\n            if (x < 0) {\n                x += mod;\n            }\n            return x;\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\ninline int chkmin(T &x, const T &y) {\n  return x > y ? x = y, 1 : 0;\n}\ntemplate <typename T>\ninline int chkmax(T &x, const T &y) {\n  return x < y ? x = y, 1 : 0;\n}\ntemplate <typename T>\ninline T read(T &f) {\n  f = 0;\n  int x = 1;\n  char c = getchar();\n  while (!isdigit(c)) x = c == '-' ? -1 : 1, c = getchar();\n  while (isdigit(c)) (f *= 10) += c & 15, c = getchar();\n  return f *= x;\n}\nusing int64 = long long;\nusing uint64 = unsigned long long;\nconst int N = 200000 + 5;\nint n, k;\nstruct Edge {\n  int to;\n  Edge *next;\n} E[N << 1], *pre[N];\nint fa[N], dep[N];\nvoid addedge(int u, int v) {\n  static int cnt = 0;\n  E[++cnt] = {v, pre[u]}, pre[u] = &E[cnt];\n  E[++cnt] = {u, pre[v]}, pre[v] = &E[cnt];\n}\nvoid dfs(int u, int f) {\n  fa[u] = f, dep[u] = dep[f] + 1;\n  for (Edge *i = pre[u]; i; i = i->next) {\n    int v = i->to;\n    if (v == f) continue;\n    dfs(v, u);\n  }\n}\nint d, rt, dis[N], col[N];\nvoid draw(int u, int f, int dt) {\n  for (Edge *i = pre[u]; i; i = i->next) {\n    int v = i->to;\n    if (v == f) continue;\n    if (col[v]) continue;\n    col[v] = col[u] + dt;\n    if (col[v] < 0) col[v] += k;\n    if (col[v] > k) col[v] -= k;\n    draw(v, u, dt);\n  }\n}\nint ret = 0;\nvoid findpath(int u, int f) {\n  chkmax(ret, dis[u]);\n  for (Edge *i = pre[u]; i; i = i->next) {\n    int v = i->to;\n    if (v == f) continue;\n    if (col[v]) continue;\n    dis[v] = dis[u] + 1;\n    findpath(v, u);\n  }\n}\nint main() {\n  read(n), read(k);\n  for (int i = (1), ___ = (n - 1); i <= ___; ++i) {\n    static int u, v;\n    read(u), read(v);\n    addedge(u, v);\n  }\n  dfs(1, 0);\n  for (int i = (1), ___ = (n); i <= ___; ++i)\n    if (dep[i] > dep[rt]) rt = i;\n  dfs(rt, 0);\n  for (int i = (1), ___ = (n); i <= ___; ++i) chkmax(d, dep[i]);\n  if (k == 2) {\n    puts(\"Yes\");\n    for (int i = (1), ___ = (n); i <= ___; ++i)\n      printf(\"%d \", dep[i] & 1 ? 1 : 2);\n    return 0;\n  }\n  if (d < k) {\n    puts(\"Yes\");\n    for (int i = (1), ___ = (n); i <= ___; ++i) {\n      static int t = 0;\n      if (++t > k) t -= k;\n      printf(\"%d \", t);\n    }\n    return 0;\n  }\n  int v = 0;\n  for (int i = (1), ___ = (n); i <= ___; ++i)\n    if (dep[i] > dep[v]) v = i;\n  int t = 0, td = 0;\n  while (true) {\n    if (++td, ++t > k) t -= k;\n    col[v] = t, dis[v] = td;\n    if (v == rt) break;\n    v = fa[v];\n  };\n  for (int i = (1), ___ = (n); i <= ___; ++i)\n    if (dep[i] > dep[v]) v = i;\n  t = 0, td = 0;\n  do {\n    int dL = dis[v], dR = dis[rt] - dis[v] + 1;\n    dis[v] = ret = 0, findpath(v, 0);\n    if (ret == 0) {\n      v = fa[v];\n      continue;\n    }\n    dL += ret, dR += ret;\n    if (dL >= k && dR >= k) {\n      puts(\"No\");\n      return 0;\n    }\n    draw(v, 0, dL >= k ? 1 : -1);\n    v = fa[v];\n  } while (v != rt);\n  puts(\"Yes\");\n  for (int i = (1), ___ = (n); i <= ___; ++i) printf(\"%d \", col[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline bool chmax(T &a, T b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <class T>\ninline bool chmin(T &a, T b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\nint dist[3][205000];\nint n, k;\nvector<int> pathes[205000];\nint v[2];\nint color[205000];\nbool ondepth[205000];\nbool searched[2][205000];\nbool ng = false;\nvoid dfs(int now, int from, int index) {\n  for (int to : pathes[now]) {\n    if (to == from) continue;\n    dist[index][to] = dist[index][now] + 1;\n    dfs(to, now, index);\n  }\n}\nvoid search(int now, int from, int c) {\n  color[now] = c;\n  ondepth[now] = true;\n  for (int to : pathes[now]) {\n    if (to == from) continue;\n    if (dist[0][to] + dist[1][to] != dist[0][now] + dist[1][now]) continue;\n    search(to, now, (c % k) + 1);\n  }\n}\nvoid f(int now) {\n  int c = dist[0][now] % k + 1;\n  color[now] = c;\n  for (auto to : pathes[now]) {\n    if (searched[0][to]) continue;\n    if (ondepth[to]) continue;\n    if (dist[0][to] < dist[0][now]) f(to);\n  }\n}\nvoid g(int now) {\n  int c = color[v[1]];\n  c -= dist[1][now];\n  c %= k;\n  c += k;\n  c %= k;\n  if (c == 0) c += k;\n  if (color[now] != 0 && color[now] != c) ng = true;\n  color[now] = c;\n  for (auto to : pathes[now]) {\n    if (searched[1][to]) continue;\n    if (ondepth[to]) continue;\n    if (dist[1][to] < dist[1][now]) g(to);\n  }\n}\nvoid print() {\n  for (int i = 1; i <= n; i++) {\n    cout << color[i] << \" \";\n  }\n  cout << endl;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin >> n >> k;\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    cin >> u >> v;\n    pathes[u].push_back(v);\n    pathes[v].push_back(u);\n  }\n  dist[0][1] = 0;\n  dfs(1, -1, 0);\n  v[1] = 1;\n  for (int i = 2; i <= n; i++) {\n    if (dist[0][i] > dist[0][v[1]]) v[1] = i;\n  }\n  dist[1][v[1]] = 0;\n  dfs(v[1], -1, 1);\n  v[0] = 1;\n  for (int i = 2; i <= n; i++) {\n    if (dist[1][i] > dist[1][v[0]]) v[0] = i;\n  }\n  dist[0][v[0]] = 0;\n  dfs(v[0], -1, 0);\n  search(v[0], -1, 1);\n  for (int i = 1; i <= n; i++) {\n    if (dist[0][i] >= k - 1) {\n      if (!searched[0][i] && !ondepth[i]) f(i);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (dist[1][i] >= k - 1) {\n      if (!searched[1][i] && !ondepth[i]) g(i);\n    }\n  }\n  if (ng) {\n    cout << \"No\" << endl;\n    return 0;\n  }\n  cout << \"Yes\" << endl;\n  for (int i = 1; i <= n; i++) {\n    if (color[i] == 0) color[i] = 1;\n  }\n  print();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 5;\ninline int read() {\n  int x = 0;\n  bool f = 0;\n  char ch;\n  do {\n    ch = getchar();\n    f |= (ch == '-');\n  } while (!isdigit(ch));\n  do {\n    x = (x << 1) + (x << 3) + (ch ^ 48);\n    ch = getchar();\n  } while (isdigit(ch));\n  return f ? -x : x;\n}\ninline void write(int x) {\n  if (x < 0) x = -x, putchar('-');\n  if (x > 9) write(x / 10);\n  putchar(x % 10 + '0');\n}\ninline void writesp(int x) {\n  write(x);\n  putchar(' ');\n}\ninline void writeln(int x) {\n  write(x);\n  puts(\"\");\n}\nint head[maxn], to[maxn << 1], nxt[maxn << 1], tot = 0;\nvoid add(int u, int v) {\n  nxt[++tot] = head[u];\n  head[u] = tot;\n  to[tot] = v;\n}\nint dep[maxn];\nvoid dfs(int u, int fa) {\n  dep[u] = dep[fa] + 1;\n  for (register int i = head[u]; i; i = nxt[i]) {\n    int v = to[i];\n    if (v == fa) continue;\n    dfs(v, u);\n  }\n}\nbool tag[maxn];\nvoid diam(int u, int fa) {\n  for (register int i = head[u]; i; i = nxt[i]) {\n    int v = to[i];\n    if (v == fa) continue;\n    diam(v, u);\n    if (tag[v]) tag[u] = true;\n  }\n}\nint n, k;\nint len, f[maxn], g[maxn], col[maxn];\nvoid color2(int u, int fa, int op) {\n  if (op)\n    col[u] = col[fa] % k + 1;\n  else\n    col[u] = col[fa] - 1 + (col[fa] == 1) * k;\n  for (register int i = head[u]; i; i = nxt[i]) {\n    int v = to[i];\n    if (v == fa) continue;\n    color2(v, u, op);\n    if (f[v] >= f[u])\n      g[u] = f[u], f[u] = f[v] + 1;\n    else if (f[v] >= g[u])\n      g[u] = f[v] + 1;\n    if (g[v] >= g[u]) g[u] = g[v] + 1;\n  }\n  if (f[u] + g[u] + 1 >= k) {\n    puts(\"No\");\n    exit(0);\n  }\n}\nvoid color1(int u, int fa) {\n  col[u] = col[fa] % k + 1;\n  for (register int i = head[u]; i; i = nxt[i]) {\n    int v = to[i];\n    if (v == fa) continue;\n    if (tag[v]) {\n      color1(v, u);\n      continue;\n    }\n    if (dep[u] * 2 - 1 <= len)\n      color2(v, u, 0);\n    else\n      color2(v, u, 1);\n    if (f[v] >= f[u])\n      g[u] = f[u], f[u] = f[v] + 1;\n    else if (f[v] >= g[u])\n      g[u] = f[v] + 1;\n    if (g[v] >= g[u]) g[u] = g[v] + 1;\n  }\n  if (f[u] + g[u] + 1 >= k) {\n    puts(\"No\");\n    exit(0);\n  }\n  if (f[u] && f[u] + dep[u] >= k && f[u] + len - dep[u] + 1 >= k) {\n    puts(\"No\");\n    exit(0);\n  }\n}\nint main() {\n  n = read(), k = read();\n  for (register int i = 1; i <= n - 1; ++i) {\n    int u = read(), v = read();\n    add(u, v);\n    add(v, u);\n  }\n  dfs(1, 0);\n  if (k == 2) {\n    puts(\"Yes\");\n    for (register int i = 1; i <= n; ++i) {\n      writesp((dep[i] & 1) ? 1 : 2);\n    }\n    return 0;\n  }\n  int temp = 0;\n  for (register int i = 1; i <= n; ++i) {\n    if (dep[i] > dep[temp]) temp = i;\n  }\n  memset(dep, 0, sizeof dep);\n  dfs(temp, 0);\n  int s = 0;\n  for (register int i = 1; i <= n; ++i) {\n    if (dep[i] > dep[s]) s = i;\n  }\n  tag[s] = 1;\n  diam(temp, 0);\n  col[0] = k;\n  len = dep[s];\n  color1(temp, 0);\n  puts(\"Yes\");\n  for (register int i = 1; i <= n; ++i) writesp(col[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 5;\nconst int MAXM = 4e5 + 5;\nstruct Edge {\n  int to, nxt;\n  Edge() = default;\n  Edge(int a, int b) : to(a), nxt(b) {}\n} e[MAXM];\nint head[MAXN], edge_cnt = 1;\nint n, k, dis[MAXN], rt, s, t, st[MAXN], top, f[MAXN], col[MAXN], vis[MAXN];\ninline int read() {\n  int x = 0;\n  char ch = getchar();\n  while (!isdigit(ch)) ch = getchar();\n  while (isdigit(ch)) {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return x;\n}\ninline void Max(int &x, int y) {\n  if (x < y) x = y;\n}\ninline void Min(int &x, int y) {\n  if (x > y) x = y;\n}\ninline void add_edge(int x, int y) {\n  e[++edge_cnt] = Edge{y, head[x]};\n  head[x] = edge_cnt;\n}\ninline int add(int x, int y) {\n  int z = x + y;\n  z >= k && (z -= k);\n  z < 0 && (z += k);\n  return z;\n}\ninline void Fail() { puts(\"No\"), exit(0); }\nvoid dfs1(int x, int fa) {\n  dis[x] = dis[fa] + 1;\n  if (dis[x] > dis[s]) s = x;\n  for (int i = head[x]; i; i = e[i].nxt)\n    if (e[i].to != fa) dfs1(e[i].to, x);\n}\nvoid dfs2(int x, int fa) {\n  dis[x] = dis[fa] + 1;\n  if (dis[x] > dis[t]) t = x;\n  for (int i = head[x]; i; i = e[i].nxt)\n    if (e[i].to != fa) dfs2(e[i].to, x);\n}\nvoid dfs_rt(int x, int fa) {\n  st[++top] = x;\n  if (x == t) rt = st[(top + 1) >> 1];\n  if (x == t)\n    for (int i = 1; i <= top; i++) vis[st[i]] = 1;\n  for (int i = head[x]; i; i = e[i].nxt)\n    if (e[i].to != fa) dfs_rt(e[i].to, x);\n  top--;\n}\nvoid dfs_check(int x, int fa) {\n  for (int i = head[x]; i; i = e[i].nxt) {\n    int y = e[i].to;\n    if (y == fa || !vis[y]) continue;\n    dfs_check(y, x);\n    f[x] ? Min(f[x], f[y] + 1), 1 : f[x] = f[y] + 1;\n  }\n  Max(f[x], 1);\n  for (int i = head[x]; i; i = e[i].nxt) {\n    int y = e[i].to;\n    if (y == fa) continue;\n    if (vis[y]) continue;\n    dfs_check(y, x);\n    if (f[y] + f[x] >= k) return Fail();\n    Max(f[x], f[y] + 1);\n  }\n}\nvoid dfs_print(int x, int fa, int opt) {\n  col[x] = add(col[fa], opt);\n  for (int i = head[x]; i; i = e[i].nxt)\n    if (e[i].to != fa) dfs_print(e[i].to, x, opt);\n}\ninline void Success() {\n  puts(\"Yes\");\n  if (dis[t] & 1) {\n    int opt = 1;\n    for (int i = head[rt]; i; i = e[i].nxt)\n      dfs_print(e[i].to, rt, opt), vis[e[i].to] && (opt = -1);\n  } else {\n    for (int i = head[rt]; i; i = e[i].nxt)\n      if (f[e[i].to] < f[rt])\n        dfs_print(e[i].to, rt, 1);\n      else\n        dfs_print(e[i].to, rt, -1);\n  }\n  for (int i = 1; i <= n; i++) printf(\"%d%c\", col[i] + 1, \" \\n\"[i == n]);\n  exit(0);\n}\nint main() {\n  n = read(), k = read(), rt = 1;\n  for (int i = 2; i <= n; i++) {\n    int x = read(), y = read();\n    add_edge(x, y), add_edge(y, x);\n  }\n  if (k == 2) Success();\n  dfs1(1, 0), dfs2(s, 0);\n  dfs_rt(s, 0), dfs_check(rt, 0);\n  return Success(), 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int rd() {\n  int x = 0;\n  char c = getchar();\n  bool f = 0;\n  while (c < '0' && c != '-') c = getchar();\n  if (c == '-') f = 1, c = getchar();\n  while (c >= '0') x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();\n  return f ? -x : x;\n}\nconst int SIZE = 1e6 + 100;\nint n, K;\nint a[SIZE];\nint head[SIZE], ecnt;\nstruct Edge {\n  int v, nxt;\n} edge[SIZE << 1];\nvoid Add_Edge(int u, int v) {\n  edge[++ecnt] = (Edge){v, head[u]};\n  head[u] = ecnt;\n}\nint F[SIZE];\nint mx[SIZE][2], dep[SIZE];\nint len = -1, A, B;\nbool flag, mark[SIZE];\nvoid dfs(int u, int fa) {\n  F[u] = fa;\n  dep[u] = dep[fa] + 1;\n  mx[u][0] = mx[u][1] = u;\n  for (register int i = head[u]; i; i = edge[i].nxt) {\n    int v = edge[i].v;\n    if (v == fa) continue;\n    dfs(v, u);\n    if (dep[mx[v][0]] > dep[mx[u][0]])\n      mx[u][1] = mx[u][0], mx[u][0] = mx[v][0];\n    else if (dep[mx[v][0]] > dep[mx[u][1]])\n      mx[u][1] = mx[v][0];\n  }\n  if (len < dep[mx[u][0]] + dep[mx[u][1]] - 2 * dep[u]) {\n    len = dep[mx[u][0]] + dep[mx[u][1]] - 2 * dep[u];\n    A = mx[u][0], B = mx[u][1];\n  }\n}\nint L, R;\nint ans[SIZE], T;\nvoid DFS(int u, int fa) {\n  dep[u] = dep[fa] + 1;\n  if (!mark[u] && dep[u] + L >= K && dep[u] + R >= K) flag = 1;\n  for (register int i = head[u]; i; i = edge[i].nxt) {\n    int v = edge[i].v;\n    if (v == fa || mark[v]) continue;\n    ans[v] = (ans[u] + T) % K;\n    DFS(v, u);\n  }\n}\nvoid _main() {\n  n = rd(), K = rd();\n  for (register int i = 1, _n = n; i < _n; ++i) {\n    int u = rd(), v = rd();\n    Add_Edge(u, v);\n    Add_Edge(v, u);\n  }\n  dfs(1, 0);\n  L = 1, R = len + 1;\n  while (A != B) {\n    mark[A] = mark[B] = 1;\n    if (dep[A] > dep[B])\n      a[L++] = A, A = F[A];\n    else\n      a[R--] = B, B = F[B];\n  }\n  a[L] = A;\n  mark[A] = 1;\n  for (register int i = 1, _n = len + 1; i <= _n; ++i) {\n    L = i - 1, R = len + 1 - i;\n    if (i <= (len + 1) / 2)\n      T = K - 1;\n    else\n      T = 1;\n    ans[a[i]] = i % K;\n    DFS(a[i], 0);\n  }\n  if (flag && K != 2)\n    puts(\"No\");\n  else {\n    puts(\"Yes\");\n    for (register int i = 1, _n = n; i <= _n; ++i) printf(\"%d \", ans[i] + 1);\n  }\n}\nint main() {\n  _main();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nvector<vector<int>> g;\nvector<vector<pair<int, int>>> pr;\nvector<int> dis;\nvoid f(vector<pair<int, int>>& a, pair<int, int> e) {\n  a.push_back(e);\n  sort(a.rbegin(), a.rend());\n  a.erase(unique(a.begin(), a.end()), a.end());\n  if ((int)a.size() == 4) {\n    a.pop_back();\n  }\n}\nvector<int> pred;\nvoid dfs1(int v, int p) {\n  pred[v] = p;\n  dis[v] = 1;\n  for (int i = 0; i < (int)g[v].size(); ++i) {\n    auto e = g[v][i];\n    if (e != p) {\n      dfs1(e, v);\n      dis[v] = max(dis[e] + 1, dis[v]);\n      f(pr[v], make_pair((dis[e]), (i)));\n    }\n  }\n}\nvector<int> dd;\nvoid dfs2(int v, int p, int d) {\n  dd[v] = d;\n  for (int i = 0; i < (int)g[v].size(); ++i) {\n    auto e = g[v][i];\n    if (e != p) {\n      if (pr[v][0].second != i) {\n        dfs2(e, v, max(pr[v][0].first + 1, d + 1));\n      } else {\n        if ((int)pr[v].size() == 1) {\n          dfs2(e, v, d + 1);\n        } else {\n          dfs2(e, v, max(pr[v][1].first + 1, d + 1));\n        }\n      }\n    }\n  }\n}\nvector<int> ans;\nvoid dfs3(int v, int p, int cur, int sh) {\n  ans[v] = cur;\n  for (auto e : g[v]) {\n    if (e != p) {\n      dfs3(e, v, (cur + sh + k) % k, sh);\n    }\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cout.tie(0);\n  cin.tie(0);\n  cin >> n >> k;\n  g.resize(n);\n  for (int i = 0; i < n - 1; ++i) {\n    int v, u;\n    cin >> v >> u;\n    v--;\n    u--;\n    g[v].push_back(u);\n    g[u].push_back(v);\n  }\n  pr.resize(n);\n  dis.resize(n);\n  pred.resize(n);\n  dfs1(0, 0);\n  dd.resize(n, 0);\n  dfs2(0, 0, 0);\n  int mx = 0;\n  int mx_sm = -1;\n  int mx_rz = 1000 * 1000 * 1000;\n  for (int i = 0; i < n; ++i) {\n    int c1 = dd[i], c2 = 0, c3 = 0;\n    if ((int)pr[i].size() >= 3) {\n      if (c1 < pr[i][2].first) {\n        c1 = pr[i][2].first;\n        pred[i] = g[i][pr[i][2].second];\n      }\n    }\n    if ((int)pr[i].size() >= 1) {\n      c2 = pr[i][0].first;\n    }\n    if ((int)pr[i].size() >= 2) {\n      c3 = pr[i][1].first;\n    }\n    if ((k != 2) && (c1 > 0) && (c2 > 0) && (c3 > 0) && (c1 + c2 + 1 >= k) &&\n        (c1 + c3 + 1 >= k) && (c2 + c3 + 1 >= k)) {\n      cout << \"No\" << endl;\n      return 0;\n    }\n    if ((int)pr[i].size() >= 2) {\n      if (c1 < pr[i][1].first) {\n        c1 = pr[i][1].first;\n        pred[i] = g[i][pr[i][1].second];\n      }\n    }\n    if ((int)pr[i].size() >= 1) {\n      if (c1 < pr[i][0].first) {\n        pred[i] = g[i][pr[i][0].second];\n      }\n    }\n    if ((c1 + c2 + 1 > mx_sm) ||\n        ((c1 + c2 + 1 == mx_sm) && (abs(c1 - c2) < mx_rz))) {\n      mx = i;\n      mx_sm = c1 + c2 + 1;\n      mx_rz = abs(c1 - c2);\n    }\n  }\n  ans.resize(n);\n  for (auto e : g[mx]) {\n    if (e == pred[mx]) {\n      dfs3(e, mx, k - 1, -1);\n    } else {\n      dfs3(e, mx, 1, 1);\n    }\n  }\n  ans[mx] = 0;\n  cout << \"Yes\" << endl;\n  for (auto e : ans) {\n    cout << e + 1 << ' ';\n  }\n  cout << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long double EPS = (long double)1e-7;\nconst long double PI = acos(0) * 2;\nbool isZero(const long double& x) { return abs(x) <= EPS; }\nint sign(const long double& x) { return isZero(x) ? 0 : (0 < x ? 1 : -1); }\nlong long gcd(long long a, long long b) {\n  for (; b; a %= b, swap(a, b)) {\n  }\n  return abs(a);\n}\npair<long long, long long> operator+(const pair<long long, long long>& a,\n                                     const pair<long long, long long>& b) {\n  return pair<long long, long long>(a.first + b.first, a.second + b.second);\n}\npair<long long, long long> operator-(const pair<long long, long long>& a,\n                                     const pair<long long, long long>& b) {\n  return pair<long long, long long>(a.first - b.first, a.second - b.second);\n}\npair<long long, long long> operator*(const pair<long long, long long>& a,\n                                     const long long& b) {\n  return pair<long long, long long>(a.first * b, a.second * b);\n}\nlong long operator*(const pair<long long, long long>& a,\n                    const pair<long long, long long>& b) {\n  return a.first * b.second - b.first * a.second;\n}\nlong long ccw(const pair<long long, long long>& a,\n              const pair<long long, long long>& b,\n              const pair<long long, long long>& c) {\n  return a * b + b * c + c * a;\n}\nvoid fg(vector<int> G[], int a, int b) {\n  G[a].push_back(b);\n  G[b].push_back(a);\n}\nvoid fg(vector<pair<int, int> > G[], int a, int b, int c) {\n  G[a].push_back({b, c});\n  G[b].push_back({a, c});\n}\nconst int MAXN = 200055;\nvector<int> G[MAXN];\nint dep[MAXN], dh[MAXN], dl[MAXN];\nbitset<MAXN> chk;\nint Ans[MAXN];\nint N, K, Rt;\nvoid f(int i, int c, int dc) {\n  chk[i] = true;\n  Ans[i] = c;\n  c += dc;\n  if (c < 0) c += K;\n  if (K <= c) c -= K;\n  for (int v : G[i])\n    if (!chk[v]) f(v, c, dc);\n}\nvoid dfs(int i) {\n  chk[i] = true;\n  dh[i] = 1;\n  for (int v : G[i])\n    if (!chk[v]) {\n      dep[v] = dep[i] + 1;\n      dfs(v);\n      (dh[i]) = max((dh[i]), (dh[v] + 1));\n    }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> N >> K;\n  for (int i = 1, a, b; i < N; i++) {\n    cin >> a >> b;\n    fg(G, a, b);\n  }\n  dep[1] = 1;\n  dfs(1);\n  Rt = int(max_element(dep + 1, dep + N + 1) - dep);\n  chk.reset();\n  dep[Rt] = 1;\n  dfs(Rt);\n  int LI = int(max_element(dep + 1, dep + N + 1) - dep);\n  {\n    chk.reset();\n    vector<int> V;\n    V.emplace_back(LI);\n    for (int v; !V.empty();) {\n      v = V.back();\n      V.pop_back();\n      chk[v] = true;\n      for (int i : G[v])\n        if (!chk[i]) {\n          chk[i] = true;\n          dl[i] = dl[v] + 1;\n        }\n    }\n  }\n  if (K > 2) {\n    for (int i = 1; i <= N; i++) {\n      vector<int> V;\n      for (int v : G[i]) {\n        if (dep[v] < dep[i]) {\n          V.emplace_back(max(dep[i] - 1, dl[i]));\n          continue;\n        }\n        V.emplace_back(dh[v]);\n      }\n      sort(((V).begin()), ((V).end()));\n      reverse(((V).begin()), ((V).end()));\n      if (((int)(V).size()) < 3) continue;\n      if (min({V[0] + V[1], V[0] + V[2], V[1] + V[2]}) + 1 >= K) {\n        puts(\"No\");\n        exit(0);\n      }\n    }\n  }\n  vector<int> Path;\n  for (int i = LI;;) {\n    Path.emplace_back(i);\n    int nxt = -1;\n    for (int v : G[i])\n      if (dep[v] < dep[i]) nxt = v;\n    if (nxt < 0) break;\n    i = nxt;\n  }\n  chk.reset();\n  int CA = Path[((int)(Path).size()) / 2],\n      CB = Path[((int)(Path).size()) / 2 - 1];\n  G[CA].erase(find(((G[CA]).begin()), ((G[CA]).end()), CB));\n  G[CB].erase(find(((G[CB]).begin()), ((G[CB]).end()), CA));\n  f(CA, K - 1, -1);\n  f(CB, 0, 1);\n  puts(\"Yes\");\n  for (int i = 1; i <= N; i++) printf(\"%d \", Ans[i] + 1);\n  puts(\"\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e6 + 5;\nconst int inf = 0x3f3f3f3f;\nconst int iinf = 1 << 30;\nconst long long linf = 2e18;\nconst long long mod = 998244353;\nconst double eps = 1e-7;\ntemplate <class T>\nvoid read(T &a) {\n  int f = 1;\n  a = 0;\n  char ch = getchar();\n  while (!isdigit(ch)) {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (isdigit(ch)) {\n    a = (a << 3) + (a << 1) + ch - '0';\n    ch = getchar();\n  }\n  a *= f;\n}\nint n, k;\nint l, r, ml, mr;\nint col[maxn];\nint disl[maxn], disr[maxn];\nstruct node {\n  int nex, to;\n} edge[maxn];\nint head[maxn], tot;\nvoid add(int u, int v) {\n  edge[++tot].nex = head[u];\n  edge[tot].to = v;\n  head[u] = tot;\n}\nvoid dfs1(int now, int fa, int dep) {\n  if (dep > ml) ml = dep, l = now;\n  for (int i = head[now]; i; i = edge[i].nex) {\n    int to = edge[i].to;\n    if (to == fa) continue;\n    dfs1(to, now, dep + 1);\n  }\n  return;\n}\nvoid dfs2(int now, int fa, int dep) {\n  disl[now] = dep;\n  if (dep > mr) r = now, mr = dep;\n  for (int i = head[now]; i; i = edge[i].nex) {\n    int to = edge[i].to;\n    if (to == fa) continue;\n    dfs2(to, now, dep + 1);\n  }\n  return;\n}\nvoid dfs3(int now, int fa, int dep) {\n  disr[now] = dep;\n  for (int i = head[now]; i; i = edge[i].nex) {\n    int to = edge[i].to;\n    if (to == fa) continue;\n    dfs3(to, now, dep + 1);\n  }\n  return;\n}\nvoid sub1(int now, int fa, int c) {\n  col[now] = c + 1;\n  for (int i = head[now]; i; i = edge[i].nex) {\n    int to = edge[i].to;\n    if (to == fa) continue;\n    sub1(to, now, c ^ 1);\n  }\n}\nsigned main() {\n  scanf(\"%d %d\", &n, &k);\n  for (long long i = (1); i <= (n - 1); ++i) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    add(u, v), add(v, u);\n  }\n  if (k == 2) {\n    puts(\"Yes\");\n    sub1(1, 0, 1);\n    for (long long i = (1); i <= (n); ++i)\n      printf(\"%d%c\", col[i], \" \\n\"[i == n]);\n    return 0;\n  }\n  dfs1(1, 0, 0);\n  dfs2(l, 0, 0);\n  dfs3(r, 0, 0);\n  for (long long i = (1); i <= (n); ++i) {\n    if (disr[i] + disl[i] == mr) {\n      col[i] = (disl[i] + 1) % k + 1;\n      continue;\n    }\n    if (disl[i] >= k - 1 && disr[i] >= k - 1) return puts(\"No\"), 0;\n    if (disl[i] >= disr[i])\n      col[i] = (disl[i] + 1) % k + 1;\n    else\n      col[i] = (mr - disr[i] + 1) % k + 1;\n  }\n  puts(\"Yes\");\n  for (long long i = (1); i <= (n); ++i) printf(\"%d%c\", col[i], \" \\n\"[i == n]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint head[200010], to[200010 << 1], nxt[200010 << 1], idx, col[200010],\n    dis[200010], fa[200010], point[200010], n, k, en[2], mx[200010],\n    smx[200010];\nvoid add(int a, int b) { nxt[++idx] = head[a], to[idx] = b, head[a] = idx; }\nvoid dfs(int p, int from) {\n  fa[p] = from, dis[p] = dis[from] + 1;\n  for (int i = head[p]; i; i = nxt[i])\n    if (to[i] != from) dfs(to[i], p);\n}\nvoid init(int kind) {\n  for (int i = 1; i <= n; i++)\n    if (dis[i] > dis[en[kind]]) en[kind] = i;\n  for (int i = 1; i <= n; i++) dis[i] = 0;\n}\nvoid dfs2(int p, int from) {\n  dis[p] = dis[from] + 1, mx[p] = 1, smx[p] = 1;\n  for (int i = head[p]; i; i = nxt[i])\n    if (to[i] != from) {\n      dfs2(to[i], p), smx[p] = max(smx[p], mx[to[i]] + 1);\n      if (smx[p] > mx[p]) swap(smx[p], mx[p]);\n    }\n}\nvoid dfs3(int p, int from, int now) {\n  if (!col[p]) col[p] = now;\n  for (int i = head[p]; i; i = nxt[i])\n    if (to[i] != from) dfs3(to[i], p, (now - 1) ? now - 1 : k);\n}\nvoid dfs4(int p, int from, int now) {\n  if (!col[p]) col[p] = now;\n  for (int i = head[p]; i; i = nxt[i])\n    if (to[i] != from) dfs4(to[i], p, now % k + 1);\n}\nvoid colur() {\n  for (int i = en[1]; i; i = fa[i]) point[++point[0]] = i;\n  reverse(point + 1, point + point[0] + 1);\n  for (int i = 1; i <= point[0]; i++) col[point[i]] = (i - 1) % k + 1;\n  if (point[0] % 2)\n    dfs3(point[point[0] / 2 + 1], point[point[0] / 2 + 2],\n         col[point[point[0] / 2 + 1]]),\n        dfs4(point[point[0] / 2 + 1], point[point[0] / 2],\n             col[point[point[0] / 2 + 1]]);\n  else\n    dfs3(point[point[0] / 2], point[point[0] / 2 + 1],\n         col[point[point[0] / 2]]),\n        dfs4(point[point[0] / 2 + 1], point[point[0] / 2],\n             col[point[point[0] / 2 + 1]]);\n  for (int i = 1; i <= n; i++) printf(\"%d \", col[i]);\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1, x, y; i < n; i++) scanf(\"%d%d\", &x, &y), add(x, y), add(y, x);\n  dfs(1, 0), init(0), dfs(en[0], 0), init(1), dfs2(en[0], 0);\n  if (k == 2) printf(\"Yes\\n\"), colur(), exit(0);\n  for (int i = 1; i <= n; i++) {\n    int tmp = min(dis[i], mx[i]), tmp2 = smx[i];\n    if (tmp + tmp2 - 1 >= k && tmp2 > 1) printf(\"No\\n\"), exit(0);\n  }\n  printf(\"Yes\\n\"), colur();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, dep[200005], dist[200005], color[200005], pos[200005];\nvector<int> G[200005];\nint fa[200005], mx[200005];\nvoid dfs(int v, int p, int d) {\n  dep[v] = d;\n  fa[v] = p;\n  for (auto to : G[v]) {\n    if (to == p) continue;\n    dfs(to, v, d + 1);\n  }\n}\nvoid dfs2(int v, int p, int d) {\n  dist[v] = mx[v] = d;\n  for (auto to : G[v]) {\n    if (to == p) continue;\n    dfs2(to, v, d + 1);\n    mx[v] = max(mx[v], mx[to]);\n  }\n}\nvoid dfs3(int v, int p, int c, int dir) {\n  c += dir;\n  if (c < 0) c = k - 1;\n  if (c > k) c = 1;\n  color[v] = c;\n  for (auto to : G[v]) {\n    if (to == p) continue;\n    dfs3(to, v, c, dir);\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  memset(dist, 0, sizeof(dist));\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  dfs(1, 0, 0);\n  if (k == 2) {\n    puts(\"Yes\");\n    for (int i = 1; i <= n; i++)\n      printf(\"%d%c\", dep[i] & 1 ? 1 : 2, i == n ? '\\n' : ' ');\n    return 0;\n  }\n  int u = 1;\n  for (int i = 1; i <= n; i++)\n    if (dep[i] > dep[u]) u = i;\n  dfs(u, 0, 0);\n  int root = u, diam = 0;\n  for (int i = 1; i <= n; i++) {\n    if (dep[i] > dep[u]) u = i;\n  }\n  diam = dep[u];\n  if (diam < k - 1) {\n    puts(\"Yes\");\n    for (int i = 1; i <= n; i++) printf(\"%d%c\", 1, i == n ? '\\n' : ' ');\n    return 0;\n  }\n  int cur = 1, cnt = 1;\n  while (u) {\n    dist[u] = -1;\n    color[u] = cur;\n    pos[u] = cnt;\n    cur++;\n    cnt++;\n    if (cur > k) cur = 1;\n    u = fa[u];\n  };\n  bool f = true;\n  for (int i = 1; i <= n; i++) {\n    if (dist[i] == -1) {\n      int x = pos[i] - 1, y = diam - x;\n      for (auto to : G[i]) {\n        if (dist[to] == -1) continue;\n        dfs2(to, i, 1);\n        if (mx[to] + x >= k - 1 && mx[to] + y >= k - 1)\n          f = false;\n        else if (mx[to] + x >= k - 1)\n          dfs3(to, i, color[i], 1);\n        else\n          dfs3(to, i, color[i], -1);\n      }\n    }\n  }\n  if (!f) {\n    puts(\"No\");\n    return 0;\n  }\n  puts(\"Yes\");\n  for (int i = 1; i <= n; i++) printf(\"%d%c\", color[i], i == n ? '\\n' : ' ');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nusing namespace std;\nconst long long N = 2e5 + 100;\nlong long k;\nvector<long long> g[N];\nlong long c[N];\nvector<long long> d;\npair<long long, long long> farest(long long v, long long p1 = 0,\n                                  long long p2 = 0) {\n  pair<long long, long long> ans(0, v);\n  for (long long to : g[v])\n    if (to != p1 && to != p2) ans = max(ans, farest(to, v));\n  ans.first++;\n  return ans;\n}\nvoid col(long long v, long long add) {\n  long long cur = (c[v] + add + k - 1) % k + 1;\n  for (long long to : g[v])\n    if (!c[to]) c[to] = cur, col(to, add);\n}\nbool diam(long long v, long long p, long long dest) {\n  if (v == dest) return d.push_back(v), true;\n  for (long long to : g[v])\n    if (to != p && diam(to, v, dest)) return d.push_back(v), true;\n  return false;\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long n;\n  cin >> n >> k;\n  for (long long i = 1; i <= n - 1; i++) {\n    long long a, b;\n    cin >> a >> b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  if (k == 2) {\n    c[1] = 1;\n    col(1, +1);\n    cout << \"Yes\\n\";\n    for (long long i = 1; i <= n; i++) cout << c[i] << \" \";\n    exit(0);\n  }\n  long long v1 = farest(1).second;\n  long long v2 = farest(v1).second;\n  diam(v2, 0, v1);\n  long long len = d.size();\n  for (long long i = 0; i < len; i++) c[d[i]] = i % k + 1;\n  for (long long i = 0; i < len; i++) {\n    long long h =\n        farest(d[i], (i > 0 ? d[i - 1] : 0), (i < len - 1 ? d[i + 1] : 0))\n            .first;\n    if (h == 1) continue;\n    long long l = i + h;\n    long long r = len - i - 1 + h;\n    if (l >= k && r >= k) cout << \"No\", exit(0);\n    if (l < k)\n      col(d[i], -1);\n    else\n      col(d[i], +1);\n  }\n  cout << \"Yes\\n\";\n  for (long long i = 1; i <= n; i++) cout << c[i] << \" \";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid Main();\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  while (~cin.peek()) Main(), cin.get();\n  return 0;\n}\nvoid Main() {\n  int n, k;\n  cin >> n >> k;\n  vector<vector<int>> graph(n);\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    cin >> u >> v;\n    u--;\n    v--;\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n  function<void(pair<int, int> &, int, int, int)> dfs =\n      [&](pair<int, int> &ans, int rt, int fa, int k) {\n        ans = max(ans, make_pair(k, rt));\n        for (int &v : graph[rt]) {\n          if (v != fa) dfs(ans, v, rt, k + 1);\n        }\n      };\n  auto left = make_pair(0, 0);\n  dfs(left, 0, -1, 0);\n  auto merge = [&](vector<int> &a, vector<int> b) {\n    if (b[0] + 1 > a[0]) {\n      a[1] = a[0];\n      a[0] = b[0] + 1;\n    } else if (b[0] + 1 > a[1]) {\n      a[1] = b[0] + 1;\n    }\n  };\n  bool ok = 1;\n  vector<vector<int>> len_chain(n, vector<int>(2));\n  function<void(int, int, int)> dfs2 = [&](int rt, int fa, int d) {\n    for (int &v : graph[rt]) {\n      if (v != fa) {\n        dfs2(v, rt, d + 1);\n        merge(len_chain[rt], len_chain[v]);\n      }\n    }\n    if (d && len_chain[rt][1] && d + len_chain[rt][1] >= k - 1 &&\n        len_chain[rt][0] + len_chain[rt][1] >= k - 1)\n      ok = 0;\n  };\n  dfs2(left.second, -1, 0);\n  if (!ok && k > 2)\n    cout << \"No\" << endl;\n  else {\n    int total_count = len_chain[left.second][0] + 1;\n    int right_count = total_count / 2, left_count = total_count - right_count;\n    int left_center = -1, right_center = -1;\n    for (int i = 0; i < n; i++) {\n      if (len_chain[i][0] + 1 == right_count) right_center = i;\n      if (len_chain[i][0] + 1 == right_count + 1) left_center = i;\n    }\n    int left_mark = (left_count - 1) % k + 1, right_mark = left_mark % k + 1;\n    vector<int> ans(n);\n    function<void(int, int, int, int)> dfs = [&](int rt, int fa, int mark,\n                                                 int d_mark) {\n      ans[rt] = mark;\n      int new_mark = mark + d_mark;\n      if (new_mark == 0) new_mark = k;\n      if (new_mark == k + 1) new_mark = 1;\n      for (int &v : graph[rt]) {\n        if (v != fa) dfs(v, rt, new_mark, d_mark);\n      }\n    };\n    dfs(left_center, right_center, left_mark, -1);\n    dfs(right_center, left_center, right_mark, 1);\n    cout << \"Yes\" << endl;\n    for (int i = 0; i < n; i++) cout << ans[i] << \" \\n\"[i == n - 1];\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline long long read() {\n  long long x = 0, f = 1;\n  char c = getchar();\n  while ((c < '0' || c > '9') && (c != '-')) c = getchar();\n  if (c == '-') f = -1, c = getchar();\n  while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n  return x * f;\n}\nconst int N = 2e5 + 10;\nint n, m, col[N];\nvector<int> e[N];\nint dis[N], fa[N];\npair<int, int> Max;\nbool flag[N];\ninline void dfs(int u, int fa) {\n  dis[u] = dis[fa] + 1, ::fa[u] = fa;\n  for (auto v : e[u])\n    if (v != fa) dfs(v, u);\n  Max = max(Max, make_pair(dis[u], u));\n}\nint cnt, p[N];\ninline void Get() {\n  Max = make_pair(0, 0), dfs(1, 0);\n  int rt = Max.second;\n  Max = make_pair(0, 0), dfs(rt, 0);\n  for (int u = Max.second; u != rt; u = fa[u]) flag[p[++cnt] = u] = 1;\n  flag[p[++cnt] = rt] = 1;\n}\nint dep[N];\ninline void Dfs(int u, int fa) {\n  dep[u] = 1, ::fa[u] = fa;\n  for (auto v : e[u])\n    if (v != fa) Dfs(v, u), dep[u] = max(dep[u], dep[v] + 1);\n}\ninline void Dfs2(int u, int c, int k) {\n  col[u] = c;\n  for (auto v : e[u])\n    if (v != fa[u])\n      if (k == 1)\n        Dfs2(v, c == m ? 1 : c + 1, k);\n      else\n        Dfs2(v, c == 1 ? m : c - 1, k);\n}\nint main() {\n  n = read(), m = read();\n  for (register int i = (1); i <= (n - 1); i++) {\n    int x = read(), y = read();\n    e[x].push_back(y), e[y].push_back(x);\n  }\n  if (m == 2) {\n    dfs(1, 0);\n    puts(\"Yes\");\n    for (register int i = (1); i <= (n); i++) printf(\"%d \", (dis[i] & 1) + 1);\n    return 0;\n  }\n  Get();\n  if (cnt < m) {\n    puts(\"Yes\");\n    for (register int i = (1); i <= (n); i++) printf(\"%d \", 1);\n    return 0;\n  }\n  int c = 1;\n  for (register int i = (1); i <= (cnt); i++) {\n    col[p[i]] = c;\n    if (++c == m + 1) c = 1;\n  }\n  Dfs(p[1], 0);\n  for (register int i = (1); i <= (cnt); i++) {\n    c = col[p[i]];\n    for (auto v : e[p[i]]) {\n      if (flag[v]) continue;\n      if (dep[v] + i >= m && dep[v] + (cnt - i + 1) >= m) return puts(\"No\"), 0;\n      if (dep[v] + i >= m)\n        Dfs2(v, c == m ? 1 : c + 1, 1);\n      else\n        Dfs2(v, c == 1 ? m : c - 1, -1);\n    }\n  }\n  puts(\"Yes\");\n  for (register int i = (1); i <= (n); i++) printf(\"%d \", col[i]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int sz = 2e5 + 10;\nvector<int> sv[sz];\nint n, k, pr[sz], up[sz], an[sz];\npair<int, int> dow[sz];\nint dia = 0, rt, v1, v2;\nvoid dfs(int v) {\n  dow[v] = {0, v};\n  for (int a = 0; a < sv[v].size(); a++) {\n    int ne = sv[v][a];\n    if (ne != pr[v]) {\n      pr[ne] = v, an[ne] = an[v] ^ 1, dfs(ne);\n      if (dia < dow[v].first + dow[ne].first + 1) {\n        dia = dow[v].first + dow[ne].first + 1;\n        rt = v, v1 = dow[v].second, v2 = dow[ne].second;\n      }\n      dow[v] = max(dow[v], {dow[ne].first + 1, dow[ne].second});\n    }\n  }\n}\nvoid check(int v) {\n  multiset<int, greater<int> > se;\n  se.insert(up[v]);\n  vector<int> sp;\n  if (v) sp.push_back(up[v]);\n  for (int a = 0; a < sv[v].size(); a++) {\n    int ne = sv[v][a];\n    if (ne != pr[v]) {\n      se.insert(dow[ne].first + 1);\n      sp.push_back(dow[ne].first + 1);\n    }\n  }\n  for (int a = 0; a < sv[v].size(); a++) {\n    int ne = sv[v][a];\n    if (ne != pr[v]) {\n      se.erase(se.find(dow[ne].first + 1));\n      up[ne] = (*se.begin()) + 1, check(ne);\n      se.insert(dow[ne].first + 1);\n    }\n  }\n  if (sp.size() > 2) {\n    sort(sp.begin(), sp.end(), greater<int>());\n    if (sp[1] + sp[2] >= k - 1) {\n      cout << \"No\";\n      exit(0);\n    }\n  }\n}\nvoid dfs2(int v, int pr, int add) {\n  for (int a = 0; a < sv[v].size(); a++) {\n    int ne = sv[v][a];\n    if (ne != pr) {\n      an[ne] = an[v] + add;\n      if (an[ne] < 0) an[ne] += k;\n      if (an[ne] >= k) an[ne] -= k;\n      dfs2(ne, v, add);\n    }\n  }\n}\nint main() {\n  cin >> n >> k;\n  for (int a = 0; a < n - 1; a++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    u--, v--;\n    sv[u].push_back(v);\n    sv[v].push_back(u);\n  }\n  dfs(0);\n  if (k > 2) {\n    check(0);\n    vector<int> sp, sp2;\n    while (v1 != rt) sp.push_back(v1), v1 = pr[v1];\n    while (v2 != rt) sp2.push_back(v2), v2 = pr[v2];\n    sp.push_back(rt);\n    while (sp2.size()) sp.push_back(sp2.back()), sp2.pop_back();\n    for (int a = 0; a < sp.size(); a++) {\n      int v = sp[a], pr = (a) ? sp[a - 1] : -1,\n          ne = (a + 1 < sp.size()) ? sp[a + 1] : -1,\n          add = (a < sp.size() / 2) ? -1 : 1;\n      an[v] = a % k;\n      for (int b = 0; b < sv[v].size(); b++) {\n        int u = sv[v][b];\n        if (u != pr and u != ne) {\n          an[u] = an[v] + add;\n          if (an[u] < 0) an[u] += k;\n          if (an[u] >= k) an[u] -= k;\n          dfs2(u, v, add);\n        }\n      }\n    }\n  }\n  cout << \"Yes\\n\";\n  for (int a = 0; a < n; a++) printf(\"%d \", an[a] + 1);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC_OPTIMIZE(\"ofast\")\nusing namespace std;\nconst long long MAXN = 200000;\nvector<long long> g[MAXN];\nvector<long long> dp_up(MAXN);\nvector<pair<long long, long long>> dp_down1(MAXN);\nvector<pair<long long, long long>> dp_down2(MAXN);\nvector<pair<long long, long long>> dp_down3(MAXN);\nlong long n, k;\nvoid dfs_d(long long v, long long p = -1) {\n  long long v1 = 0;\n  long long i1 = -1;\n  long long v2 = -1;\n  long long i2 = -1;\n  long long v3 = -1;\n  long long i3 = -1;\n  for (auto u : g[v]) {\n    if (u != p) {\n      dfs_d(u, v);\n      if (v1 < dp_down1[u].first + 1) {\n        v3 = v2;\n        i3 = i2;\n        v2 = v1;\n        i2 = i1;\n        v1 = dp_down1[u].first + 1;\n        i1 = u;\n      } else {\n        if (v2 < dp_down1[u].first + 1) {\n          v3 = v2;\n          i3 = i2;\n          v2 = dp_down1[u].first + 1;\n          i2 = u;\n        } else {\n          if (v3 < dp_down1[u].first + 1) {\n            v3 = dp_down1[u].first + 1;\n            i3 = u;\n          }\n        }\n      }\n    }\n  }\n  dp_down1[v] = make_pair(v1, i1);\n  dp_down2[v] = make_pair(v2, i2);\n  dp_down3[v] = make_pair(v3, i3);\n}\nvoid dfs_u(long long v, long long p = -1) {\n  for (auto u : g[v]) {\n    if (p != u) {\n      dp_up[u] = dp_up[v] + 1;\n      if (u != dp_down1[v].second && dp_down1[v].second != -1) {\n        dp_up[u] = max(dp_up[u], 1 + dp_down1[v].first);\n      } else {\n        if (u != dp_down2[v].second && dp_down2[v].second != -1) {\n          dp_up[u] = max(dp_up[u], 1 + dp_down2[v].first);\n        }\n      }\n      dfs_u(u, v);\n    }\n  }\n}\nlong long ansd = -1;\nlong long ansi = -1;\nvoid dfs57(long long v, long long p = -1, long long dist = 0) {\n  if (dist > ansd) {\n    ansd = dist;\n    ansi = v;\n  }\n  for (auto u : g[v]) {\n    if (u != p) {\n      dfs57(u, v, dist + 1);\n    }\n  }\n}\nvector<long long> diam;\nvector<long long> now;\nlong long t1, t2;\nvoid dfs58(long long v, long long p = -1) {\n  now.push_back(v);\n  if (v == t2) {\n    diam = now;\n  }\n  for (auto u : g[v]) {\n    if (u != p) {\n      dfs58(u, v);\n    }\n  }\n  now.pop_back();\n}\nvector<bool> used_d(MAXN);\nvector<long long> ans(MAXN);\nvoid dfs59(long long v, long long p = -1) {\n  for (auto u : g[v]) {\n    if (u != p && !used_d[u]) {\n      ans[u] = (ans[v] + 1) % k;\n      dfs59(u, v);\n    }\n  }\n}\nvoid dfs60(long long v, long long p = -1) {\n  for (auto u : g[v]) {\n    if (u != p && !used_d[u]) {\n      ans[u] = (ans[v] - 1 + k) % k;\n      dfs60(u, v);\n    }\n  }\n}\nsigned main() {\n  cin >> n >> k;\n  for (long long i = 0; i < n - 1; i++) {\n    long long a, b;\n    cin >> a >> b;\n    a--;\n    b--;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  dp_up[0] = 0;\n  dfs_d(0);\n  dfs_u(0);\n  for (long long i = 0; i < n; i++) {\n    vector<long long> arr;\n    if (i != 0) {\n      arr.push_back(dp_up[i]);\n    }\n    if (dp_down1[i].second != -1) {\n      arr.push_back(dp_down1[i].first);\n    }\n    if (dp_down2[i].second != -1) {\n      arr.push_back(dp_down2[i].first);\n    }\n    if (dp_down3[i].second != -1) {\n      arr.push_back(dp_down3[i].first);\n    }\n    if (arr.size() > 2) {\n      sort(arr.rbegin(), arr.rend());\n      if (k != 2 && arr[1] + arr[2] >= k - 1 && arr[2] != 0) {\n        cout << \"No \\n\";\n        return 0;\n      }\n    }\n  }\n  dfs57(0);\n  t1 = ansi;\n  ansd = -1;\n  ansi = -1;\n  dfs57(t1);\n  t2 = ansi;\n  dfs58(t1);\n  for (long long i = 0; i < diam.size(); i++) {\n    used_d[diam[i]] = true;\n  }\n  long long now_ans = 0;\n  for (long long i = 0; i < diam.size(); i++) {\n    ans[diam[i]] = now_ans;\n    now_ans++;\n    if (now_ans == k) {\n      now_ans = 0;\n    }\n  }\n  for (long long i = 0; i < diam.size() / 2; i++) {\n    dfs60(diam[i]);\n  }\n  for (long long i = diam.size() / 2; i < diam.size(); i++) {\n    dfs59(diam[i]);\n  }\n  cout << \"Yes \\n\";\n  for (long long i = 0; i < n; i++) {\n    cout << ans[i] + 1 << \" \";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nvoid chkmax(T &a, T b) {\n  if (a < b) a = b;\n}\nconst int inf = 0x3f3f3f3f;\ninline char nc() {\n  static char buf[100000], *p1 = buf, *p2 = buf;\n  return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2)\n             ? EOF\n             : *p1++;\n}\nvoid read(int &x) {\n  char c = nc(), b = 1;\n  for (; !((c >= '0' && c <= '9') || c == EOF); c = nc())\n    if (c == '-') b = -b;\n  for (x = 0; c >= '0' && c <= '9'; x = x * 10 + c - '0', c = nc())\n    ;\n  x *= b;\n}\nvector<int> v[200005];\nint n;\nint mx[200005][4], id[200005][4];\nvoid refresh(int k) {\n  int t = 3;\n  while (t >= 1 && mx[k][t] > mx[k][t - 1]) {\n    swap(mx[k][t], mx[k][t - 1]);\n    swap(id[k][t], id[k][t - 1]);\n    t--;\n  }\n}\nvoid dfs(int k, int pa) {\n  int son = 0;\n  for (auto x : v[k]) {\n    if (x == pa) continue;\n    dfs(x, k);\n    son++;\n    mx[k][3] = mx[x][0] + 1, id[k][3] = x;\n    refresh(k);\n  }\n  if (!son) mx[k][0] = 1;\n  return;\n}\nvoid dfs_up(int k, int pa) {\n  if (pa) {\n    mx[k][3] = mx[pa][3] + 1;\n    if (k == id[pa][0])\n      chkmax(mx[k][3], 1 + mx[pa][1]);\n    else\n      chkmax(mx[k][3], 1 + mx[pa][0]);\n  } else\n    mx[k][3] = 1;\n  for (auto x : v[k]) {\n    if (x == pa) continue;\n    dfs_up(x, k);\n  }\n  return;\n}\nint c[200005];\nint d[200005], p[200005];\nint BFS(int rt, int n) {\n  static queue<int> Q;\n  while (!Q.empty()) Q.pop();\n  for (int i = 1; i <= n; i++) d[i] = inf;\n  d[rt] = p[rt] = 0;\n  Q.push(rt);\n  int res;\n  while (!Q.empty()) {\n    int x = Q.front();\n    Q.pop();\n    res = x;\n    for (int i = 0; i < v[x].size(); i++) {\n      int y = v[x][i];\n      if (d[y] < inf) continue;\n      d[y] = d[x] + 1;\n      p[y] = x;\n      Q.push(y);\n    }\n  }\n  return res;\n}\nint K;\nvoid dfs_col(int k, int p) {\n  for (auto x : v[k]) {\n    if (x == p) continue;\n    if (!c[x]) {\n      c[x] = 2 * c[k] - c[p];\n      if (c[x] > K) c[x] -= K;\n      if (c[x] <= 0) c[x] += K;\n    }\n    dfs_col(x, k);\n  }\n  return;\n}\nint main() {\n  read(n), read(K);\n  for (int i = 1; i < n; i++) {\n    int x, y;\n    read(x), read(y);\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  dfs(1, 0);\n  dfs_up(1, 0);\n  for (int i = 1; i <= n; i++) refresh(i);\n  bool flag = 0;\n  if (K > 2) {\n    for (int i = 1; i <= n; i++) {\n      if (mx[i][2] <= 1) continue;\n      if (mx[i][2] + mx[i][1] - 1 >= K) flag = 1;\n    }\n  }\n  if (flag) {\n    puts(\"No\");\n    return 0;\n  }\n  puts(\"Yes\");\n  int st = BFS(1, n);\n  int ed = BFS(st, n);\n  vector<int> P;\n  int cur = ed;\n  while (cur) {\n    P.push_back(cur);\n    cur = p[cur];\n  }\n  for (int i = 0; i < P.size(); i++) c[P[i]] = i % K + 1;\n  int sz = P.size() - 1;\n  if (n > 2) {\n    int k = sz >> 1;\n    dfs_col(P[k], P[k + 1]);\n    k = sz + 1 >> 1;\n    dfs_col(P[k], P[k - 1]);\n  }\n  for (int i = 1; i <= n; i++) {\n    c[i] = max(c[i], 1);\n    printf(\"%d \", c[i]);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Edge {\n  int t, next;\n  Edge() {}\n  Edge(int a, int b) : t(a), next(b) {}\n};\nEdge e[400005];\nint head[200005], ans[200005];\nbool vis[200005];\nint dep[200005], fa[200005];\nint dfs1(int x) {\n  int id = x;\n  for (int i = head[x]; i; i = e[i].next)\n    if (e[i].t != fa[x]) {\n      int u = e[i].t;\n      dep[u] = dep[x] + 1;\n      fa[u] = x;\n      int t = dfs1(u);\n      if (dep[t] > dep[id]) id = t;\n    }\n  return id;\n}\nint dfs2(int x, int v, int k) {\n  int s = dep[x];\n  for (int i = head[x]; i; i = e[i].next)\n    if (e[i].t != fa[x] && !vis[e[i].t]) {\n      int u = e[i].t;\n      dep[u] = dep[x] + 1;\n      fa[u] = x;\n      ans[u] = (ans[x] + v + k) % k;\n      s = max(s, dfs2(u, v, k));\n    }\n  return s;\n}\nint num[200005];\nint main() {\n  int n, k;\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i < n; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    e[2 * i - 1] = Edge(y, head[x]);\n    head[x] = 2 * i - 1;\n    e[2 * i] = Edge(x, head[y]);\n    head[y] = 2 * i;\n  }\n  dep[1] = fa[1] = 0;\n  int u = dfs1(1);\n  dep[u] = fa[u] = 0;\n  int v = dfs1(u), cnt = 0;\n  for (int i = v, last2 = 0; i; last2 = i, i = fa[i]) {\n    num[++cnt] = i;\n    vis[i] = 1;\n    ans[i] = (ans[last2] + 1) % k;\n  }\n  for (int i = 1; i <= cnt; i++) {\n    int x = num[i];\n    dep[x] = fa[x] = 0;\n    int t = dfs2(x, (i <= (cnt >> 1)) ? -1 : 1, k);\n    if (t && t + min(i, cnt - i + 1) >= k && k > 2) {\n      puts(\"No\");\n      return 0;\n    }\n  }\n  puts(\"Yes\");\n  for (int i = 1; i <= n; i++) printf(\"%d \", ans[i] + 1);\n  printf(\"\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 200010;\nstd::vector<int> e[N];\nint color[N], dep[N];\nbool vis[N];\nint n, k;\nint max = 0;\nvoid dfs(int u, int fa) {\n  max = std::max(max, dep[u]);\n  for (auto v : e[u]) {\n    if (vis[v] || v == fa) {\n      continue;\n    }\n    dep[v] = dep[u] + 1;\n    dfs(v, u);\n  }\n}\nstd::vector<int> stack;\nstd::vector<int> diameter;\nvoid find_diameter(int u, int fa, int t) {\n  stack.push_back(u);\n  if (u == t) {\n    diameter = stack;\n  }\n  for (auto v : e[u]) {\n    if (v == fa) {\n      continue;\n    }\n    find_diameter(v, u, t);\n  }\n  stack.pop_back();\n}\nvoid solve(int u, int fa, int add) {\n  for (auto v : e[u]) {\n    if (vis[v] || v == fa) {\n      continue;\n    }\n    color[v] = (color[u] + add + k) % k;\n    solve(v, u, add);\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 0, u, v; i < n - 1; ++i) {\n    scanf(\"%d%d\", &u, &v);\n    e[u].push_back(v);\n    e[v].push_back(u);\n  }\n  if (k == 2) {\n    solve(1, 0, 1);\n    puts(\"Yes\");\n    for (int i = 1; i <= n; ++i) {\n      printf(\"%d%c\", color[i] + 1, \" \\n\"[i == n]);\n    }\n    return 0;\n  }\n  dfs(1, 0);\n  int s = std::max_element(dep + 1, dep + n + 1) - dep;\n  dep[s] = 0;\n  dfs(s, 0);\n  int t = std::max_element(dep + 1, dep + n + 1) - dep;\n  find_diameter(s, 0, t);\n  int sz = diameter.size();\n  for (int i = 0; i < sz; ++i) {\n    color[diameter[i]] = i % k;\n    vis[diameter[i]] = true;\n  }\n  for (int i = 0; i < sz; ++i) {\n    dep[diameter[i]] = 0;\n    max = 0;\n    dfs(diameter[i], 0);\n    if (max == 0) {\n      continue;\n    }\n    if (max + i + 1 < k) {\n      solve(diameter[i], 0, -1);\n    } else if (max + sz - i < k) {\n      solve(diameter[i], 0, 1);\n    } else {\n      puts(\"No\");\n      return 0;\n    }\n  }\n  puts(\"Yes\");\n  for (int i = 1; i <= n; ++i) {\n    printf(\"%d%c\", color[i] + 1, \" \\n\"[i == n]);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 4e5 + 6;\nvector<int> h[maxn];\nbool vis[maxn];\nint dis[maxn], ans[maxn], n, k, pre[maxn], rt, st, mx, len;\nvoid dfs0(int u, int fa, int o) {\n  ans[u] = o;\n  for (auto v : h[u]) {\n    if (v == fa) continue;\n    dfs0(v, u, o ^ 1);\n  }\n}\nvoid dfs(int u, int fa) {\n  mx = max(mx, dis[u]);\n  for (auto v : h[u]) {\n    if (vis[v]) continue;\n    if (v == fa) continue;\n    dis[v] = dis[u] + 1;\n    pre[v] = u;\n    dfs(v, u);\n  }\n}\nvoid dfs2(int u, int fa) {\n  for (auto v : h[u]) {\n    if (vis[v]) continue;\n    if (v == fa) continue;\n    dis[v] = dis[u] - 1;\n    pre[v] = u;\n    dfs2(v, u);\n  }\n}\nvoid solve2() {\n  dfs0(1, 0, 0);\n  puts(\"Yes\");\n  for (int i = 1; i <= n; i++) printf(\"%d \", ans[i] + 1);\n  puts(\"\");\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    h[u].push_back(v);\n    h[v].push_back(u);\n  }\n  if (k == 2) {\n    solve2();\n    return 0;\n  }\n  dis[1] = 0;\n  dfs(1, 0);\n  rt = 1;\n  for (int i = 2; i <= n; i++)\n    if (dis[i] > dis[rt]) rt = i;\n  dis[rt] = 0;\n  dfs(rt, 0);\n  st = 1;\n  for (int i = 2; i <= n; i++)\n    if (dis[i] > dis[st]) st = i;\n  len = dis[st];\n  if (len < k - 1) {\n    puts(\"Yes\");\n    for (int i = 1; i <= n; i++) printf(\"%d \", i % k + 1);\n    puts(\"\");\n    return 0;\n  }\n  for (int i = st;; i = pre[i]) {\n    vis[i] = 1;\n    if (i == rt) break;\n  }\n  for (int i = st;; i = pre[i]) {\n    mx = 0;\n    dfs(i, 0);\n    mx -= dis[i];\n    bool fl, fr;\n    if (mx != 0) {\n      fl = (mx + dis[i] >= k - 1);\n      fr = (mx + len - dis[i] >= k - 1);\n      if (fl && fr) {\n        puts(\"No\");\n        return 0;\n      }\n      if (fl)\n        dfs(i, 0);\n      else\n        dfs2(i, 0);\n    }\n    if (i == rt) break;\n  }\n  puts(\"Yes\");\n  for (int i = 1; i <= n; i++) printf(\"%d \", dis[i] % k + 1);\n  puts(\"\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace io {\nconst int l = 1 << 20;\nchar buf[l], *s, *t;\ninline char gc() {\n  if (s == t) {\n    t = (s = buf) + fread(buf, 1, l, stdin);\n    return s == t ? EOF : *s++;\n  }\n  return *s++;\n}\nchar c;\ntemplate <class IT>\ninline void gi(IT &x) {\n  x = 0;\n  c = gc();\n  while (c < '0' || c > '9') c = gc();\n  while ('0' <= c && c <= '9') {\n    x = (x << 1) + (x << 3) + (c ^ 48);\n    c = gc();\n  }\n}\n};  // namespace io\nusing io::gi;\ntemplate <class IT>\ninline void cmin(IT &a, IT b = 0) {\n  if (a > b) a = b;\n}\ntemplate <class IT>\ninline void cmax(IT &a, IT b = 0) {\n  if (a < b) a = b;\n}\ntemplate <class IT>\ninline IT _min(IT a, IT b = 0) {\n  return a > b ? b : a;\n}\ntemplate <class IT>\ninline IT _max(IT a, IT b = 0) {\n  return a < b ? b : a;\n}\nconst long long p = 1000000007ll;\nconst int N = 200005;\nint dp[N][5];\nvector<int> e[N];\ninline void upd(int v, int w, int d) {\n  if (dp[v][0] <= w) {\n    dp[v][3] = d;\n    dp[v][2] = dp[v][1];\n    dp[v][1] = dp[v][0];\n    dp[v][0] = w;\n  } else if (dp[v][1] <= w) {\n    dp[v][2] = dp[v][1];\n    dp[v][1] = w;\n  } else\n    cmax(dp[v][2], w);\n}\nvoid dfs1(int v, int fa) {\n  int i = 0, s = e[v].size(), u;\n  for (; i < s; ++i)\n    if ((u = e[v][i]) != fa) {\n      dfs1(u, v);\n      upd(v, dp[u][0] + 1, u);\n    }\n}\nvoid dfs2(int v, int fa) {\n  upd(v, dp[v][4], 0);\n  int w = dp[v][3], w0 = dp[v][0] + 1, w1 = dp[v][1] + 1, i = 0,\n      s = e[v].size(), u;\n  for (; i < s; ++i)\n    if ((u = e[v][i]) != fa) {\n      if (u == w)\n        dp[u][4] = w1;\n      else\n        dp[u][4] = w0;\n      dfs2(u, v);\n    }\n}\nint f[N], d[N], mx, id;\nvoid dfs3(int v, int fa) {\n  f[v] = fa;\n  int p = d[v] + 1, i = 0, s = e[v].size(), u;\n  for (; i < s; ++i)\n    if ((u = e[v][i]) != fa) {\n      if ((d[u] = p) > mx) {\n        mx = p;\n        id = u;\n      }\n      dfs3(u, v);\n    }\n}\nint ans[N], k0;\nvoid dfsv(int v, int fa) {\n  int p = ans[v] + 1, i = 0, s = e[v].size(), u;\n  if (p > k0) p = 1;\n  for (; i < s; ++i)\n    if ((u = e[v][i]) != fa) {\n      ans[u] = p;\n      dfsv(u, v);\n    }\n}\nvoid dfsu(int v, int fa) {\n  int p = ans[v] - 1, i = 0, s = e[v].size(), u;\n  if (!p) p = k0;\n  for (; i < s; ++i)\n    if ((u = e[v][i]) != fa) {\n      ans[u] = p;\n      dfsu(u, v);\n    }\n}\nint main() {\n  int n, k, i = 1, v, u, w;\n  scanf(\"%d%d\", &n, &k);\n  k0 = k--;\n  for (; i < n; ++i) {\n    scanf(\"%d%d\", &v, &u);\n    e[v].push_back(u);\n    e[u].push_back(v);\n  }\n  dfs1(1, 0);\n  dfs2(1, 0);\n  if (k >= 2)\n    for (i = 1; i <= n; ++i)\n      if (dp[i][2] + dp[i][1] >= k && dp[i][2]) {\n        putchar('N');\n        putchar('o');\n        return 0;\n      }\n  v = u = 0;\n  for (i = 1; i <= n; ++i)\n    if (dp[i][0] > u) {\n      u = dp[i][0];\n      v = i;\n    }\n  dfs3(v, 0);\n  u = id;\n  w = mx >> 1;\n  while (w--) u = f[u];\n  v = f[u];\n  ans[v] = 1;\n  ans[u] = k0;\n  dfsv(v, u);\n  dfsu(u, v);\n  putchar('Y');\n  putchar('e');\n  putchar('s');\n  putchar('\\n');\n  for (i = 1; i <= n; ++i) printf(\"%d \", ans[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\ninline T read() {\n  T f = 0, x = 0;\n  char c = getchar();\n  while (!isdigit(c)) f = c == '-', c = getchar();\n  while (isdigit(c)) x = x * 10 + c - 48, c = getchar();\n  return f ? -x : x;\n}\nnamespace run {\nconst int N = 4e5 + 9;\nint n, K, head[N], nex[N], to[N], cnt;\ninline void add(int u, int v) {\n  nex[++cnt] = head[u];\n  head[u] = cnt, to[cnt] = v;\n}\nqueue<int> q;\nint dist[N], pre[N];\ninline int bfs(int S) {\n  while (!q.empty()) q.pop();\n  for (int i = 1; i <= n; i++) dist[i] = n + 1;\n  q.push(S), pre[S] = dist[S] = 0;\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n    for (int i = head[u]; i; i = nex[i])\n      if (dist[to[i]] == n + 1) {\n        dist[to[i]] = dist[u] + 1;\n        q.push(to[i]), pre[to[i]] = u;\n      }\n    if (q.empty()) return u;\n  }\n  assert(0);\n  return 0;\n}\nint dep[N], vis[N], mxdep;\ninline void dfs(int u, int _f) {\n  dep[u] = dep[_f] + 1;\n  for (int i = head[u]; i; i = nex[i])\n    if (to[i] ^ _f) dfs(to[i], u);\n}\nint st[N], top, col[N], rt;\ninline void chk(int u, int _f, int inv) {\n  dep[u] = dep[_f] + 1, mxdep = max(mxdep, dep[u]);\n  if (!vis[u]) {\n    if (inv)\n      col[u] = col[st[rt + dep[u] - 1]];\n    else\n      col[u] = col[st[rt - dep[u] + 1]];\n  }\n  for (int i = head[u]; i; i = nex[i])\n    if (!vis[to[i]] && to[i] ^ _f) chk(to[i], u, inv);\n}\nint main() {\n  n = read<int>(), K = read<int>();\n  for (int i = 1; i < n; i++) {\n    int u = read<int>(), v = read<int>();\n    add(u, v), add(v, u);\n  }\n  if (K == 2) {\n    puts(\"Yes\"), dfs(1, 0);\n    for (int i = 1; i <= n; i++) printf(\"%d \", (dep[i] & 1) + 1);\n    return 0;\n  }\n  int S = bfs(1), T = bfs(S);\n  while (T) st[++top] = T, T = pre[T];\n  for (int i = 1; i <= top; i++) col[st[i]] = i % K + 1, vis[st[i]] = 1;\n  if (top == n) {\n    puts(\"Yes\");\n    for (int i = 1; i <= n; i++) printf(\"%d \", col[i]);\n    puts(\"\");\n    return 0;\n  }\n  for (int i = 1; i <= top; i++) {\n    mxdep = 0, rt = i;\n    if (i <= top / 2)\n      chk(st[i], 0, 0);\n    else\n      chk(st[i], 0, 1);\n    if (mxdep + i - 1 >= K && top - i + mxdep >= K) puts(\"No\"), exit(0);\n  }\n  puts(\"Yes\");\n  for (int i = 1; i <= n; i++) printf(\"%d \", col[i]);\n  puts(\"\");\n  return 0;\n}\n}  // namespace run\nint main() { return run::main(); }\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nvector<int> g[200020];\nint mx[200020][3], h[200020], l[200020];\nvoid dfs(int u, int pa = 0) {\n  for (int v : g[u]) {\n    if (v == pa) continue;\n    dfs(v, u);\n    int tmp = mx[v][0] + 1;\n    if (mx[u][2] < tmp) swap(mx[u][2], tmp);\n    if (mx[u][1] < mx[u][2]) swap(mx[u][1], mx[u][2]);\n    if (mx[u][0] < mx[u][1]) swap(mx[u][0], mx[u][1]);\n  }\n}\nvoid up(int u, int pa = 0) {\n  if (pa) {\n    int now = h[pa];\n    if (mx[pa][0] == 1 + mx[u][0])\n      now = max(now, mx[pa][1]);\n    else\n      now = max(now, mx[pa][0]);\n    h[u] = now + 1;\n  }\n  for (int v : g[u]) {\n    if (v == pa) continue;\n    up(v, u);\n  }\n}\nint col[200020];\nvoid paint(int u, int cur, int pa = 0) {\n  col[u] = cur;\n  if (l[u] == h[u]) {\n    int nw = cur + 1;\n    if (pa && (col[u] - col[pa] + k) % k != 1) nw = cur - 1;\n    if (nw > k) nw -= k;\n    if (nw == 0) nw += k;\n    for (int v : g[u]) {\n      if (v == pa) continue;\n      paint(v, nw, u);\n    }\n  } else {\n    bool flag = 0;\n    int sg = 1;\n    if (pa && (col[u] - col[pa] + k) % k != 1) sg = -1;\n    for (int v : g[u]) {\n      if (v == pa) continue;\n      if (!flag && mx[v][0] + 1 == l[u]) {\n        int nw = cur + sg;\n        if (nw > k) nw -= k;\n        if (nw == 0) nw += k;\n        flag = 1;\n        paint(v, nw, u);\n      } else {\n        int nw = cur - sg;\n        if (nw > k) nw -= k;\n        if (nw == 0) nw = k;\n        paint(v, nw, u);\n      }\n    }\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1, u, v; i < n; i++) {\n    scanf(\"%d%d\", &u, &v);\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  int rt;\n  for (int i = 1; i <= n; i++)\n    if (g[i].size() == 1) {\n      rt = i;\n      break;\n    }\n  dfs(rt);\n  up(rt);\n  if (k >= 3) {\n    for (int i = 1; i <= n; i++) {\n      vector<int> cur = {h[i], mx[i][0], mx[i][1], mx[i][2]};\n      sort(cur.begin(), cur.end(), greater<int>());\n      l[i] = cur[0];\n      if (g[i].size() >= 3) {\n        if (cur[1] + cur[2] >= k - 1) {\n          puts(\"No\");\n          return 0;\n        }\n      }\n    }\n  }\n  paint(rt, 1);\n  puts(\"Yes\");\n  for (int i = 1; i <= n; i++) printf(\"%d \", col[i]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 300000 + 50;\nconst int maxm = 1300000 + 100;\nconst int maxt = 3000000 + 100;\nconst int maxk = 10 + 3;\nconst int M = 2010;\nconst long long unit = 1LL;\nconst int INF = 0x3f3f3f3f;\nconst long long Inf = 0x3f3f3f3f3f3f3f3fLL;\nconst double eps = 1e-8;\nconst double inf = 1e15;\nconst double pi = acos(-1.0);\nconst long long mod = 998244353LL, gg = 3LL, inv2 = 499122177LL;\ninline long long read() {\n  long long x = 0;\n  bool t = false;\n  char ch = getchar();\n  while ((ch < '0' || ch > '9') && ch != '-') ch = getchar();\n  if (ch == '-') t = true, ch = getchar();\n  while (ch <= '9' && ch >= '0') x = x * 10 + ch - 48, ch = getchar();\n  return t ? -x : x;\n}\nint n, k, tt;\nvector<int> G[maxn], tmp;\nint on[maxn], dep[maxn], pre[maxn], dia[maxn], ans[maxn];\nvoid dfs(int u, int fa) {\n  for (auto v : G[u]) {\n    if (v == fa) continue;\n    pre[v] = u;\n    dep[v] = dep[u] + 1;\n    dfs(v, u);\n  }\n}\nvoid dfs2(int u, int fa) {\n  for (auto v : G[u]) {\n    if (v == fa || on[v]) continue;\n    tmp.push_back(v);\n    dep[v] = dep[u] + 1;\n    dfs2(v, u);\n  }\n}\nint main() {\n  n = read(), k = read();\n  int u, v;\n  for (int i = 1; i < n; ++i) {\n    u = read(), v = read();\n    G[u].push_back(v), G[v].push_back(u);\n  }\n  dep[1] = 1;\n  dfs(1, 0);\n  if (k == 2) {\n    printf(\"Yes\\n\");\n    for (int i = 1; i <= n; ++i) printf(\"%d \", (dep[i] % 2) + 1);\n    return 0;\n  }\n  int p = max_element(dep + 1, dep + 1 + n) - dep;\n  memset(dep, 0, sizeof(dep));\n  memset(pre, 0, sizeof(pre));\n  pre[p] = 0, dep[p] = 1;\n  dfs(p, 0);\n  int q = max_element(dep + 1, dep + 1 + n) - dep;\n  while (q != p) {\n    on[q] = 1;\n    dia[++tt] = q;\n    q = pre[q];\n  }\n  dia[++tt] = p;\n  on[p] = 1;\n  int st = 0;\n  for (int i = 1; i <= tt; ++i) {\n    ans[dia[i]] = st;\n    ++st;\n    if (st >= k) st -= k;\n  }\n  memset(dep, 0, sizeof(dep));\n  bool ok = true;\n  for (int i = 1; i <= tt; ++i) {\n    tmp.clear();\n    dep[dia[i]] = 0;\n    dfs2(dia[i], 0);\n    if (tmp.empty()) continue;\n    int Max = 0;\n    for (auto x : tmp) Max = max(Max, dep[x]);\n    if ((i + Max >= k) && (tt - i + 1 + Max >= k)) {\n      ok = false;\n      break;\n    }\n    if (tt - i + 1 + Max >= k)\n      for (auto x : tmp) ans[x] = ans[dia[i - dep[x]]];\n    else\n      for (auto x : tmp) ans[x] = ans[dia[i + dep[x]]];\n  }\n  if (!ok)\n    printf(\"No\\n\");\n  else {\n    printf(\"Yes\\n\");\n    for (int i = 1; i <= n; ++i) printf(\"%d \", ans[i] + 1);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nusing namespace std;\nconst int maxN = 2 * (int)1e5 + 100;\nconst int LG = 20;\nint n, k;\nvector<int> g[maxN];\nstruct DistanceSolver {\n  int ti = 0;\n  vector<int> fi;\n  vector<int> lg;\n  vector<int> h;\n  vector<vector<int> > up;\n  void init() {\n    lg.resize(2 * n + 1);\n    fi.resize(n);\n    h.resize(n);\n    lg[1] = 0;\n    for (int i = 2; i <= 2 * n; i++) {\n      lg[i] = lg[i - 1];\n      if (!(i & (i - 1))) lg[i]++;\n    }\n    up.resize(LG);\n    dfs(0, -1);\n    for (int i = 1; i < LG; i++) {\n      up[i].resize(up[0].size());\n    }\n    for (int i = 0; i + 1 < LG; i++) {\n      for (int j = 0; j + (1 << (i + 1)) - 1 < up[0].size(); j++) {\n        up[i + 1][j] = min(up[i][j], up[i][j + (1 << i)]);\n      }\n    }\n  }\n  void dfs(int v, int p) {\n    fi[v] = ti;\n    up[0].push_back(h[v]);\n    ti++;\n    for (int to : g[v]) {\n      if (to == p) continue;\n      up[0].push_back(h[v]);\n      ti++;\n      h[to] = h[v] + 1;\n      dfs(to, v);\n    }\n  }\n  int getDist(int u, int v) {\n    if (u == v) return 0;\n    int l = fi[u];\n    int r = fi[v];\n    if (l > r) swap(l, r);\n    int k = lg[r - l + 1];\n    int h_lca = min(up[k][l], up[k][r - (1 << k) + 1]);\n    return h[u] + h[v] - 2 * h_lca;\n  }\n} DS;\nint ti = 0;\nint tin[maxN];\nint tout[maxN];\nvoid start_dfs(int v, int p) {\n  tin[v] = ti++;\n  for (int to : g[v]) {\n    if (to == p) continue;\n    start_dfs(to, v);\n  }\n  tout[v] = ti++;\n}\nvoid bad() {\n  cout << \"No\";\n  exit(0);\n}\nbool on_diam[maxN];\nint clr[maxN];\nint mx[maxN];\nvoid calc(int v, int p) {\n  mx[v] = 0;\n  for (int to : g[v]) {\n    if (to == p) continue;\n    calc(to, v);\n    mx[v] = max(mx[v], mx[to] + 1);\n  }\n}\nvoid process(int v, int p, int clr_now, int add) {\n  clr[v] = clr_now;\n  for (int to : g[v]) {\n    if (to == p) continue;\n    process(to, v, (clr_now + add) % k, add);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cin >> n >> k;\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    cin >> u >> v;\n    u--;\n    v--;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  DS.init();\n  if (k == 2) {\n    cout << \"Yes\" << '\\n';\n    for (int i = 0; i < n; i++) {\n      cout << DS.getDist(0, i) % 2 + 1 << \" \";\n    }\n    return 0;\n  }\n  pair<int, int> best = make_pair(-1, -1);\n  for (int i = 0; i < n; i++) {\n    best = max(best, make_pair(DS.getDist(0, i), i));\n  }\n  int A = best.second;\n  assert(A != -1);\n  best = make_pair(-1, -1);\n  for (int i = 0; i < n; i++) {\n    best = max(best, make_pair(DS.getDist(A, i), i));\n  }\n  int B = best.second;\n  assert(best.second != -1);\n  start_dfs(A, -1);\n  memset(clr, -1, sizeof clr);\n  for (int i = 0; i < n; i++) {\n    if (tin[i] <= tin[B] && tout[B] <= tout[i]) {\n      on_diam[i] = true;\n      clr[i] = DS.getDist(A, i) % k;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (on_diam[i]) {\n      for (int to : g[i]) {\n        if (!on_diam[to]) {\n          calc(to, i);\n          if (mx[to] + min(DS.getDist(A, to), DS.getDist(B, to)) + 1 >= k) {\n            bad();\n          }\n          if (mx[to] + max(DS.getDist(A, to), DS.getDist(B, to)) + 1 < k) {\n            continue;\n          }\n          if (mx[to] + DS.getDist(A, to) + 1 >= k) {\n            process(to, i, (clr[i] + 1) % k, 1);\n          } else {\n            process(to, i, (clr[i] + k - 1) % k, k - 1);\n          }\n        }\n      }\n    }\n  }\n  cout << \"Yes\" << '\\n';\n  for (int i = 0; i < n; i++) {\n    if (clr[i] == -1) clr[i] = 0;\n    cout << clr[i] + 1 << \" \";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\nint n, k;\nvector<int> a[200010];\npair<int, pair<int, int> > down[200010];\npair<int, pair<int, int> > downid[200010];\nint up[200010];\nbool vis[200010];\npair<int, pair<int, int> > dfs(int x) {\n  vis[x] = 1;\n  pair<int, pair<int, int> > ans = make_pair(0, make_pair(0, 0));\n  pair<int, pair<int, int> > id = make_pair(0, make_pair(0, 0));\n  vector<pair<int, int> > v;\n  for (int i = 0; i < a[x].size(); i++) {\n    if (!vis[a[x][i]]) v.push_back(make_pair(dfs(a[x][i]).first + 1, a[x][i]));\n  }\n  sort(v.begin(), v.end(), greater<pair<int, int> >());\n  if (v.size() >= 1) {\n    ans.first = v[0].first;\n    id.first = v[0].second;\n  }\n  if (v.size() >= 2) {\n    ans.second.first = v[1].first;\n    id.second.first = v[1].second;\n  }\n  if (v.size() >= 3) {\n    ans.second.second = v[2].first;\n    id.second.second = v[2].second;\n  }\n  down[x] = ans;\n  downid[x] = id;\n  return ans;\n}\nvoid dfs2(int x, int anc) {\n  vis[x] = 1;\n  int ans = 0;\n  if (anc) {\n    if (downid[anc].first != x) ans = max(ans, down[anc].first + 1);\n    if (downid[anc].second.first != x)\n      ans = max(ans, down[anc].second.first + 1);\n    if (downid[anc].second.second != x)\n      ans = max(ans, down[anc].second.second + 1);\n    ans = max(ans, up[anc] + 1);\n  }\n  up[x] = ans;\n  for (int i = 0; i < a[x].size(); i++)\n    if (!vis[a[x][i]]) dfs2(a[x][i], x);\n}\nbool pan(pair<int, pair<int, int> > x, int y) {\n  int a[4];\n  a[0] = x.first;\n  a[1] = x.second.first;\n  a[2] = x.second.second;\n  a[3] = y;\n  sort(a, a + 4);\n  int cnt = 0;\n  for (int i = 0; i < int(4); i++)\n    if (a[i] > 0) cnt++;\n  if (cnt >= 3 && a[1] + a[2] >= k - 1) return 0;\n  return 1;\n}\nint dep[200010];\nint nowdep;\nvoid dfs3(int x) {\n  vis[x] = 1;\n  dep[x] = nowdep;\n  for (int i = 0; i < int(a[x].size()); i++) {\n    if (!vis[a[x][i]]) {\n      nowdep++;\n      dfs3(a[x][i]);\n      nowdep--;\n    }\n  }\n}\npair<int, int> depanc[200010];\nvoid dfs4(int x, int anc) {\n  vis[x] = 1;\n  depanc[x] = make_pair(nowdep, anc);\n  for (int i = 0; i < int(a[x].size()); i++) {\n    if (!vis[a[x][i]]) {\n      nowdep++;\n      dfs4(a[x][i], x);\n      nowdep--;\n    }\n  }\n}\nint nxt(int x) {\n  if (x == k) return 1;\n  return x + 1;\n}\nint prev(int x) {\n  if (x == 1) return k;\n  return x - 1;\n}\nvector<int> dia;\nint op[200010];\nvoid dfsleft(int x, int col) {\n  vis[x] = 1;\n  op[x] = col;\n  for (int i = 0; i < int(a[x].size()); i++) {\n    if (!vis[a[x][i]]) {\n      dfsleft(a[x][i], prev(col));\n    }\n  }\n}\nvoid dfsright(int x, int col) {\n  vis[x] = 1;\n  op[x] = col;\n  for (int i = 0; i < int(a[x].size()); i++) {\n    if (!vis[a[x][i]]) {\n      dfsright(a[x][i], nxt(col));\n    }\n  }\n}\nint opfor2[200010];\nint nownum = 1;\nvoid dfsfor2(int x) {\n  vis[x] = 1;\n  opfor2[x] = nownum;\n  for (int i = 0; i < int(a[x].size()); i++) {\n    if (!vis[a[x][i]]) {\n      nownum = 3 - nownum;\n      dfsfor2(a[x][i]);\n      nownum = 3 - nownum;\n    }\n  }\n}\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cin >> n >> k;\n  for (int i = 0; i < int(n - 1); i++) {\n    int x, y;\n    cin >> x >> y;\n    a[x].push_back(y);\n    a[y].push_back(x);\n  }\n  if (k == 2) {\n    dfsfor2(1);\n    cout << \"YES\" << endl;\n    for (int i = 1; i <= int(n); i++) cout << opfor2[i] << \" \";\n    cout << endl;\n    return 0;\n  }\n  for (int i = 1; i <= int(n); i++) vis[i] = 0;\n  dfs(1);\n  for (int i = 1; i <= int(n); i++) vis[i] = 0;\n  dfs2(1, 0);\n  bool ok = 1;\n  for (int i = 1; i <= int(n); i++) {\n    if (!pan(down[i], up[i])) {\n      ok = 0;\n      break;\n    }\n  }\n  if (!ok) {\n    cout << \"NO\" << endl;\n    return 0;\n  }\n  cout << \"YES\" << endl;\n  for (int i = 1; i <= int(n); i++) vis[i] = 0;\n  dfs3(1);\n  int st = max_element(dep + 1, dep + 1 + n) - dep;\n  for (int i = 1; i <= int(n); i++) vis[i] = 0;\n  nowdep = 0;\n  dfs4(st, 0);\n  int en = max_element(depanc + 1, depanc + 1 + n) - depanc;\n  while (en) {\n    dia.push_back(en);\n    en = depanc[en].second;\n  }\n  for (int i = 1; i <= int(n); i++) vis[i] = 0;\n  int nowcol = 1;\n  for (int i = 0; i < int(dia.size()); i++) {\n    op[dia[i]] = nowcol;\n    nowcol = nxt(nowcol);\n    vis[dia[i]] = 1;\n  }\n  for (int i = 0; i < int(dia.size()); i++) {\n    if (i < dia.size() / 2)\n      dfsleft(dia[i], op[dia[i]]);\n    else\n      dfsright(dia[i], op[dia[i]]);\n  }\n  for (int i = 1; i <= int(n); i++) cout << op[i] << \" \";\n  cout << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nbasic_string<int> e[200005];\nint up[200005], dn[200005], p[200005];\nvoid dfs1(int x) {\n  for (int y : e[x]) {\n    if (y == p[x]) continue;\n    p[y] = x;\n    dfs1(y);\n    dn[x] = max(dn[x], dn[y] + 1);\n  }\n}\nvoid dfs2(int x) {\n  multiset<int> ms;\n  ms.insert(-1);\n  if (x != p[x]) ms.insert(up[x]);\n  for (int y : e[x]) {\n    if (y == p[x]) continue;\n    ms.insert(dn[y]);\n  }\n  for (int y : e[x]) {\n    if (y == p[x]) continue;\n    ms.erase(ms.find(dn[y]));\n    up[y] = *ms.rbegin() + 1;\n    ms.insert(dn[y]);\n    dfs2(y);\n  }\n}\nvoid dfs3(int x, vector<int>& c) {\n  c[x] = x == p[x] ? 1 : c[p[x]] ^ 3;\n  for (int y : e[x]) {\n    if (y == p[x]) continue;\n    dfs3(y, c);\n  }\n}\nvoid k2() {\n  vector<int> c(n + 1);\n  dfs3(1, c);\n  cout << \"Yes\\n\";\n  for (int i = 1; i <= n; i++) cout << c[i] << \" \\n\"[i == n];\n}\nvector<pair<int, int>> desc(int x) {\n  vector<pair<int, int>> r;\n  if (x == 1) {\n    for (int y : e[x]) {\n      r.emplace_back(dn[y] + 1, y);\n    }\n  } else {\n    for (int y : e[x]) {\n      if (y == p[x]) continue;\n      r.emplace_back(dn[y] + 1, y);\n    }\n    r.emplace_back(up[x] + 1, p[x]);\n  }\n  sort(r.begin(), r.end(), greater<pair<int, int>>());\n  return r;\n}\nvector<pair<int, int>> ad[200005];\nint ecc(int x) {\n  int z = 0;\n  for (auto [p, q] : ad[x]) z = max(z, p);\n  return z;\n}\nint sol[200005];\nvoid dfs4(int x, int p, int c, int d) {\n  sol[x] = c;\n  for (int y : e[x]) {\n    if (y == p) continue;\n    dfs4(y, x, (c + d + k + k - 1) % k + 1, d);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  cerr.tie(nullptr);\n  cin >> n >> k;\n  for (int i = 1; i < n; i++) {\n    int x, y;\n    cin >> x >> y;\n    e[x] += y;\n    e[y] += x;\n  }\n  p[1] = 1;\n  dfs1(1);\n  dfs2(1);\n  if (k == 2) {\n    k2();\n    return 0;\n  }\n  for (int i = 1; i <= n; i++) ad[i] = desc(i);\n  int c = 1, v = ecc(1);\n  for (int i = 2; i <= n; i++) {\n    int z = ecc(i);\n    if (z < v) {\n      v = z;\n      c = i;\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (ad[i].size() <= 2) continue;\n    if (ad[i][1].first + ad[i][2].first >= k - 1) {\n      cout << \"No\\n\";\n      return 0;\n    }\n  }\n  sol[c] = 1;\n  dfs4(ad[c][0].second, c, 2, 1);\n  for (int i = 1; i < (int)ad[c].size(); i++) {\n    dfs4(ad[c][i].second, c, k, -1);\n  }\n  cout << \"Yes\\n\";\n  for (int i = 1; i <= n; i++) cout << sol[i] << \" \\n\"[i == n];\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\npair<int, int> calLevel(vector<vector<int> >& memo, int index,\n                        vector<bool>& vis) {\n  pair<int, int> ans(0, index);\n  vis[index] = true;\n  for (int x : memo[index]) {\n    if (vis[x]) continue;\n    auto r = calLevel(memo, x, vis);\n    if (ans.first < r.first) ans = r;\n  }\n  ans.first++;\n  return ans;\n}\nint findMax(vector<vector<int> >& memo, int index, vector<bool>& vis) {\n  int ans = 0;\n  vis[index] = true;\n  for (int x : memo[index]) {\n    if (vis[x]) continue;\n    auto r = findMax(memo, x, vis);\n    ans = max(ans, r);\n  }\n  ans++;\n  return ans;\n}\nint fillMainLine(int index, int level, vector<vector<int> >& memo,\n                 vector<bool>& vis, vector<int>& ans, int k) {\n  level--;\n  vis[index] = true;\n  if (level == 0) {\n    ans[index] = level % k;\n    return 0;\n  }\n  for (int x : memo[index]) {\n    if (vis[x]) continue;\n    int r = fillMainLine(x, level, memo, vis, ans, k);\n    if (r == 0) {\n      ans[index] = level % k;\n      return 0;\n    }\n  }\n  return 1;\n}\nint fillColor(int index, int level, int cur, vector<vector<int> >& memo,\n              vector<bool>& vis, vector<int>& ans, int k, int next) {\n  vis[index] = true;\n  int m = 0;\n  if (next == 2) --level;\n  for (int x : memo[index]) {\n    if (vis[x]) continue;\n    if (ans[x] == -1) {\n      if (next == 2) next = level > cur ? 1 : -1;\n      int r = fillColor(x, level + next, cur, memo, vis, ans, k, next);\n      if (r + min(level, cur) + 1 >= k && k > 2) {\n        cout << \"No\";\n        exit(0);\n        return -1;\n      }\n      m = max(m, r);\n      ans[x] = (level + next + k) % k;\n    } else {\n      int r = fillColor(x, level, cur + 1, memo, vis, ans, k, 2);\n    }\n  }\n  return m + 1;\n}\nint main() {\n  int n, k;\n  cin >> n >> k;\n  vector<vector<int> > memo(n + 1);\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    cin >> u >> v;\n    memo[u].push_back(v);\n    memo[v].push_back(u);\n  }\n  if (k == 1) {\n    cout << \"Yes\" << endl;\n    for (int i = 1; i < n; i++)\n      cout << \"1\"\n           << \" \";\n    cout << \"1\" << endl;\n    return 0;\n  }\n  vector<bool> vis(n + 1);\n  vector<int> ans(n + 1, -1);\n  auto start = calLevel(memo, 1, vis);\n  fill(vis.begin(), vis.end(), false);\n  start.first = findMax(memo, start.second, vis);\n  fill(vis.begin(), vis.end(), false);\n  fillMainLine(start.second, start.first, memo, vis, ans, k);\n  fill(vis.begin(), vis.end(), false);\n  int x = fillColor(start.second, start.first, 0, memo, vis, ans, k, 2);\n  if (x == -1) {\n    cout << \"No\";\n    return 0;\n  }\n  cout << \"Yes\" << endl;\n  for (int i = 1; i < n; i++) cout << ans[i] + 1 << \" \";\n  cout << ans.back() + 1 << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long sqr(long long x) { return x * x; }\nint mysqrt(long long x) {\n  int l = 0, r = 1e9 + 1;\n  while (r - l > 1) {\n    int m = (l + r) / 2;\n    if (m * (long long)m <= x)\n      l = m;\n    else\n      r = m;\n  }\n  return l;\n}\nmt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\nmt19937_64 rndll(\n    chrono::high_resolution_clock::now().time_since_epoch().count());\nlong long AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MODR = 1e9 + 993;\nlong long myrand() {\n  long long ZR = (XR * AR + YR * BR + CR) % MODR;\n  XR = YR;\n  YR = ZR;\n  return ZR;\n}\nint gcd(int a, int b) { return a ? gcd(b % a, a) : b; }\nint gcdex(int a, int b, int &x, int &y) {\n  if (a == 0) {\n    x = 0;\n    y = 1;\n    return b;\n  }\n  int x1, y1;\n  int ret = gcdex(b % a, a, x1, y1);\n  x = y1 - (b / a) * x1;\n  y = x1;\n  return ret;\n}\nint Mod = 1e9 + 993;\nint Bpow(int x, long long y) {\n  int ret = 1;\n  int w = x;\n  while (y) {\n    if (y & 1) ret = (ret * (long long)w) % Mod;\n    w = (w * (long long)w) % Mod;\n    y >>= 1;\n  }\n  return ret;\n}\nint Bdiv(int x) {\n  int a, b;\n  gcdex(x, Mod, a, b);\n  if (a < 0) a += Mod;\n  return a;\n}\nint Bdiv(int x, int y) { return (x * (long long)Bpow(y, Mod - 2)) % Mod; }\ninline int ad(int x, int y) { return x + y >= Mod ? x + y - Mod : x + y; }\ninline int dif(int x, int y) { return x - y < 0 ? x - y + Mod : x - y; }\ninline int mul(int x, int y) { return (x * (long long)y) % Mod; }\nint inv(int a) {\n  int b = Mod, x = 0, y = 1;\n  while (a) {\n    int t = b / a;\n    b -= a * t;\n    x -= t * y;\n    swap(a, b);\n    swap(x, y);\n  }\n  if (x < 0) x += Mod;\n  return x;\n}\nvoid setmin(int &x, int y) { x = min(x, y); }\nvoid setmax(int &x, int y) { x = max(x, y); }\nvoid setmin(long long &x, long long y) { x = min(x, y); }\nvoid setmax(long long &x, long long y) { x = max(x, y); }\nconst long long llinf = 1e18 + 100;\nconst long double eps = 1e-9;\nconst int maxn = 2e5 + 100, maxw = 1e6 + 100, inf = 1e9 + 100, sq = 100, X = 43,\n          LG = 17;\nvector<int> e[maxn];\nint n, k;\nint col[maxn];\nvoid dfs_2(int v, int par) {\n  for (int i : e[v])\n    if (i != par) {\n      col[i] = col[v] ^ 1;\n      dfs_2(i, v);\n    }\n}\nint dst[maxn];\nvoid dfind(int v, int par) {\n  for (int i : e[v])\n    if (i != par) {\n      dst[i] = dst[v] + 1;\n      dfind(i, v);\n    }\n}\nvector<int> g;\nbool dget(int v, int par, int B) {\n  if (v == B) {\n    g.push_back(B);\n    return 1;\n  }\n  for (int i : e[v])\n    if (i != par) {\n      if (dget(i, v, B)) {\n        g.push_back(v);\n        return 1;\n      }\n    }\n  return 0;\n}\nbool vis[maxn];\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  for (int i = 1; i < n; i++) {\n    int v, u;\n    cin >> v >> u;\n    v--;\n    u--;\n    e[v].push_back(u);\n    e[u].push_back(v);\n  }\n  if (k == 2) {\n    cout << \"Yes\\n\";\n    dfs_2(0, -1);\n    for (int i = 0; i < n; i++) cout << col[i] + 1 << ' ';\n    cout << '\\n';\n    return 0;\n  }\n  dfind(0, -1);\n  int A = 0;\n  for (int i = 0; i < n; i++)\n    if (dst[i] > dst[A]) A = i;\n  memset(dst, 0, sizeof(dst));\n  dfind(A, -1);\n  int B = 0;\n  for (int i = 0; i < n; i++)\n    if (dst[i] > dst[B]) B = i;\n  dget(A, -1, B);\n  for (int i = 0; i < g.size(); i++) col[g[i]] = i % k, vis[g[i]] = 1;\n  for (int it = 0; it < g.size(); it++) {\n    bool lf = (it > g.size() - 1 - it);\n    int small;\n    if (lf)\n      small = g.size() - 1 - it;\n    else\n      small = it;\n    function<void(int, int, int)> dfs = [&](int v, int par, int len) {\n      if (small + len + 1 >= k) {\n        cout << \"No\\n\";\n        exit(0);\n      }\n      if (lf)\n        col[v] = col[g[it + len]];\n      else\n        col[v] = col[g[it - len]];\n      for (int i : e[v])\n        if (i != par) dfs(i, v, len + 1);\n    };\n    for (int i : e[g[it]])\n      if (!vis[i]) dfs(i, g[it], 1);\n  }\n  cout << \"Yes\\n\";\n  for (int i = 0; i < n; i++) cout << col[i] + 1 << ' ';\n  cout << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 50;\nint n, k;\nvector<int> g[N];\nint col[N];\nint in[N];\nint d1[N], d2[N];\nint x;\nint d;\nvector<int> v;\nint timer;\nint m1[N], m2[N], m3[N];\nint dub[N];\nint a, b;\nint id[N];\nint vidjen[N];\nint cc;\nint nadjidub(int u, int pret) {\n  int sum = 0;\n  for (int x : g[u]) {\n    if (x == pret) continue;\n    sum += nadjidub(x, u);\n  }\n  dub[u] = sum + 1;\n  return dub[u];\n}\nvoid vreme(int u, int pret) {\n  in[u] = ++timer;\n  for (int x : g[u]) {\n    if (x == pret) continue;\n    vreme(x, u);\n  }\n}\nvoid distanca(int u, int pret, int d, int dis[]) {\n  dis[u] = d;\n  for (int x : g[u]) {\n    if (x == pret) continue;\n    distanca(x, u, d + 1, dis);\n  }\n}\nvoid najdalji(int u, int pret, int dd) {\n  if (dd >= d) {\n    x = u;\n    d = dd;\n  }\n  for (int x : g[u]) {\n    if (x == pret) continue;\n    najdalji(x, u, dd + 1);\n  }\n}\nbool nadjiput(int u, int pret, int x) {\n  if (u == x) {\n    v.push_back(u);\n    return true;\n  }\n  for (int xx : g[u]) {\n    if (xx == pret) continue;\n    if (nadjiput(xx, u, x)) {\n      v.push_back(u);\n      return true;\n    }\n  }\n  return false;\n}\nint dfss(int u, int pret) {\n  int ma1 = 0;\n  int ma2 = 0;\n  int ma3 = 0;\n  int ind;\n  for (int x : g[u]) {\n    if (x == pret) continue;\n    int k = dfss(x, u);\n    if (k >= ma1) {\n      ind = x;\n      ma3 = ma2;\n      ma2 = ma1;\n      ma1 = k;\n      continue;\n    }\n    if (k >= ma2) {\n      ma3 = ma2;\n      ma2 = k;\n      continue;\n    } else if (k >= ma3) {\n      ma3 = k;\n    }\n  }\n  int w = 0;\n  if (in[a] < in[u] || in[a] >= in[u] + dub[u]) w = d1[u];\n  if (in[b] < in[u] || in[b] >= in[u] + dub[u]) w = max(d2[u], w);\n  m1[u] = w;\n  if (u == cc) m1[u] = ma3;\n  m2[u] = ma1;\n  m3[u] = ma2;\n  return ma1 + 1;\n}\nvoid resiza2(int u, int pret, int c) {\n  col[u] = c;\n  for (int x : g[u]) {\n    if (x == pret) continue;\n    int w = 1;\n    if (c == 1) w = 2;\n    resiza2(x, u, w);\n  }\n}\nvoid oboj(int x, int c, int smer) {\n  if (c == k + 1) c = 1;\n  if (c == 0) c = k;\n  col[x] = c;\n  for (int u : g[x]) {\n    if (col[u]) continue;\n    oboj(u, c + smer, smer);\n  }\n}\nint main() {\n  {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n    cerr.tie(NULL);\n  }\n  cin >> n >> k;\n  for (int i = 0; i < n - 1; i++) {\n    int a, b;\n    cin >> a >> b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  if (k == 2) {\n    resiza2(1, -1, 1);\n    cout << \"YES\"\n         << \"\\n\";\n    for (int i = 1; i <= n; i++) cout << col[i] << \" \";\n    return 0;\n  }\n  x = 1;\n  najdalji(1, -1, 0);\n  a = x;\n  d = 0;\n  x = b;\n  najdalji(a, -1, 0);\n  b = x;\n  distanca(a, -1, 0, d1);\n  distanca(b, -1, 0, d2);\n  nadjiput(a, -1, b);\n  cc = v[((int)v.size() - 1) / 2];\n  int ww = 1;\n  int sz = ((int)v.size() - 1) / 2;\n  int indd = 0;\n  for (int x : v) {\n    vidjen[x] = 1;\n    if (indd <= sz)\n      id[x] = 1;\n    else\n      id[x] = -1;\n    if (ww == k + 1) ww = 1;\n    col[x] = ww;\n    ww++;\n    indd++;\n  }\n  vreme(cc, -1);\n  nadjidub(cc, -1);\n  dfss(cc, -1);\n  for (int i = 1; i <= n; i++) {\n    if ((int)g[i].size() < 3) continue;\n    int cnt = 0;\n    if (m1[i] + m2[i] + 1 >= k) cnt++;\n    if (m1[i] + m3[i] + 1 >= k) cnt++;\n    if (m2[i] + m3[i] + 1 >= k) cnt++;\n    if (cnt == 3) {\n      cout << \"NO\";\n      return 0;\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (col[i] && vidjen[i]) {\n      for (int x : g[i]) {\n        if (!col[x]) {\n          int w = id[i];\n          if (w == 1)\n            oboj(x, col[i] - 1, -1);\n          else\n            oboj(x, col[i] + 1, 1);\n        }\n      }\n    }\n  }\n  cout << \"YES\"\n       << \"\\n\";\n  for (int i = 1; i <= n; i++) cout << col[i] << \" \";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int NN = 1000000 + 117;\nconst int MM = 100000 + 117;\nint read() {\n  int fl = 1, x;\n  char c;\n  for (c = getchar(); (c < '0' || c > '9') && c != '-'; c = getchar())\n    ;\n  if (c == '-') {\n    fl = -1;\n    c = getchar();\n  }\n  for (x = 0; c >= '0' && c <= '9'; c = getchar())\n    x = (x << 3) + (x << 1) + c - '0';\n  return x * fl;\n}\nvoid open() { freopen(\"f.in\", \"r\", stdin); }\nvoid close() {\n  fclose(stdin);\n  fclose(stdout);\n}\nint m, n, k;\nbool fl = 0;\nint fa[NN] = {};\nint dis[NN] = {};\nvector<int> p[NN] = {};\nint col[NN] = {};\nvoid getdis(int x, int f) {\n  fa[x] = f;\n  for (int i = 0; i < p[x].size(); ++i) {\n    int cur = p[x][i];\n    if (cur != fa[x]) {\n      dis[cur] = dis[x] + 1;\n      getdis(cur, x);\n    }\n  }\n}\nvoid paint(int x) {\n  while (x) {\n    col[x] = dis[x] % k;\n    x = fa[x];\n  }\n}\nint maxl;\nvoid ptdfs(int x, int c, int it) {\n  col[x] = c;\n  for (int i = 0; i < p[x].size(); ++i) {\n    int cur = p[x][i];\n    if (cur != fa[x]) {\n      ptdfs(cur, (c + k + it) % k, it);\n    }\n  }\n  maxl = max(maxl, dis[x]);\n}\nint main() {\n  n = read();\n  k = read();\n  memset(col, -1, sizeof(col));\n  for (int i = 1; i < n; ++i) {\n    int x = read(), y = read();\n    p[x].push_back(y);\n    p[y].push_back(x);\n  }\n  dis[1] = 0;\n  getdis(1, 0);\n  int X = 0;\n  for (int i = 1; i <= n; ++i) {\n    if (dis[X] < dis[i]) X = i;\n  }\n  dis[X] = 0;\n  getdis(X, 0);\n  int Y = 0;\n  for (int i = 1; i <= n; ++i) {\n    if (dis[Y] < dis[i]) Y = i;\n  }\n  paint(Y);\n  int l = dis[Y];\n  for (int i = 1; i <= n; ++i) {\n    maxl = 0;\n    if (col[i] == -1 && col[fa[i]] != -1) {\n      if (dis[fa[i]] <= l / 2) {\n        ptdfs(i, (col[fa[i]] + k - 1) % k, -1);\n      } else {\n        ptdfs(i, (col[fa[i]] + k + 1) % k, 1);\n      }\n      int b1 = l - dis[fa[i]];\n      int b2 = dis[fa[i]];\n      maxl -= dis[fa[i]];\n      if (maxl + b1 + 1 >= k && b1 + b2 + 1 >= k && b2 + maxl + 1 >= k) {\n        fl = 1;\n      }\n    }\n  }\n  if (fl && k > 2) {\n    printf(\"No\\n\");\n  } else {\n    printf(\"Yes\\n\");\n    for (int i = 1; i <= n; ++i) {\n      printf(\"%d \", col[i] + 1);\n    }\n    putchar('\\n');\n  }\n  close();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200001, M = 18;\nvector<int> g[N];\nint sm[N][M], dep[N], depa[N], depb[N], col[N], n, k;\nvoid build() {\n  for (int i = 1; i < M; i++)\n    for (int j = 1; j <= n; j++)\n      if (sm[j][i - 1]) sm[j][i] = sm[sm[j][i - 1]][i - 1];\n}\nvoid dfs(int u, int p) {\n  sm[u][0] = p, dep[u] = dep[p] + 1;\n  for (int v : g[u])\n    if (v != p) dfs(v, u);\n}\nvoid dfsa(int u, int p) {\n  depa[u] = depa[p] + 1, col[u] = depa[u] % k + 1;\n  for (int v : g[u])\n    if (v != p) dfsa(v, u);\n}\nvoid dfsb(int u, int p) {\n  depb[u] = depb[p] + 1, col[u] = k - depb[u] % k;\n  for (int v : g[u])\n    if (v != p) dfsb(v, u);\n}\nint lca(int u, int v) {\n  if (dep[u] > dep[v]) swap(u, v);\n  int d = dep[v] - dep[u];\n  for (int i = 0; i < M; i++)\n    if ((d >> i) & 1) v = sm[v][i];\n  if (u == v) return u;\n  for (int i = M - 1; i >= 0; i--)\n    if (sm[u][i] != sm[v][i]) u = sm[u][i], v = sm[v][i];\n  return sm[u][0];\n}\nint dist(int u, int v) { return dep[u] + dep[v] - dep[lca(u, v)] * 2; }\nint main() {\n  ios_base::sync_with_stdio(false), cin.tie(NULL);\n  cin >> n >> k;\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v, g[u].push_back(v), g[v].push_back(u);\n  }\n  dep[0] = -1, dfs(1, 0);\n  if (k == 2) {\n    cout << \"Yes\\n\";\n    for (int u = 1; u <= n; u++) cout << dep[u] % 2 + 1 << \" \";\n    cout << \"\\n\";\n    return 0;\n  }\n  int a = 1, b = 1;\n  for (int u = 1; u <= n; u++)\n    if (dep[u] > dep[a]) a = u;\n  dfs(a, 0), build();\n  for (int u = 1; u <= n; u++)\n    if (dep[u] > dep[b]) b = u;\n  for (int u = 1; u <= n; u++) {\n    int e = dist(u, b), d = (dep[u] + e + dep[b]) / 2;\n    int l[3]{d - dep[u], d - e, d - dep[b]};\n    sort(l, l + 3);\n    if (l[0] > 0 && l[0] + l[1] + 1 >= k) {\n      cout << \"No\\n\";\n      return 0;\n    }\n  }\n  int x = 1, y = 1;\n  for (int u = 1; u <= n; u++)\n    if (dep[u] == dep[b] / 2 && lca(u, b) == u) {\n      x = u;\n      break;\n    }\n  for (int u : g[x])\n    if (dep[u] == dep[x] + 1 && lca(u, b) == u) {\n      y = u;\n      break;\n    }\n  for (auto it = g[x].begin(); it != g[x].end(); it++)\n    if (*it == y) {\n      it = g[x].erase(it);\n      break;\n    }\n  for (auto it = g[y].begin(); it != g[y].end(); it++)\n    if (*it == x) {\n      it = g[y].erase(it);\n      break;\n    }\n  depa[0] = -1, depb[0] = -1, dfsa(x, 0), dfsb(y, 0);\n  cout << \"Yes\\n\";\n  for (int i = 1; i <= n; i++) cout << col[i] << \" \";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nT rd() {\n  T nmb = 0;\n  int sgn = 0;\n  char chr = getchar();\n  while (!isdigit(chr)) {\n    if (chr == '-') sgn = 1;\n    chr = getchar();\n  }\n  while (isdigit(chr)) {\n    nmb = (nmb << 3) + (nmb << 1) + chr - '0';\n    chr = getchar();\n  }\n  return sgn ? -nmb : nmb;\n}\ntemplate <typename T>\nvoid wt(T nmb) {\n  if (nmb > 9) wt(nmb / 10);\n  putchar(nmb % 10 + '0');\n}\ntemplate <typename T>\nvoid cmax(T &x, T y) {\n  x = x > y ? x : y;\n}\ntemplate <typename T>\nvoid cmin(T &x, T y) {\n  x = x < y ? x : y;\n}\nvoid proc_status() {\n  freopen(\"/proc/self/status\", \"r\", stdin);\n  string chr;\n  while (getline(cin, chr))\n    if (chr[2] == 'P') {\n      cerr << chr << endl;\n      break;\n    }\n}\nconst int N = 2e5 + 10;\nconst int inf = 2e9;\nint n, p;\nvector<int> g[N];\nint dep[N], fa[N], mx[N], sec[N], trd[N];\nvoid dfs1(int x, int f) {\n  dep[x] = dep[f] + 1;\n  fa[x] = f;\n  for (int i = g[x].size() - 1; ~i; --i) {\n    int k = g[x][i];\n    if (k == f) continue;\n    dfs1(k, x);\n    if (mx[x] <= mx[k] + 1)\n      trd[x] = sec[x], sec[x] = mx[x], mx[x] = mx[k] + 1;\n    else if (sec[x] <= mx[k] + 1)\n      trd[x] = sec[x], sec[x] = mx[k] + 1;\n    else if (trd[x] < mx[k] + 1)\n      trd[x] = mx[k] + 1;\n  }\n}\nvoid check(int a, int b, int c, int d) {\n  if (d >= a)\n    c = b, b = a, a = d;\n  else if (d >= b)\n    c = b, b = d;\n  else if (d > c)\n    c = d;\n  if (c && b + c + 1 >= p) puts(\"No\"), exit(0);\n}\nint st[N], pre[N], top;\nvoid dfs2(int x, int f) {\n  check(mx[x], sec[x], trd[x], pre[top] + dep[x]);\n  for (int i = g[x].size() - 1; ~i; --i) {\n    int k = g[x][i];\n    if (k == f) continue;\n    if (mx[k] + 1 == mx[x])\n      st[++top] = sec[x] - dep[x];\n    else\n      st[++top] = mx[x] - dep[x];\n    pre[top] = max(pre[top - 1], st[top]);\n    dfs2(k, x);\n    --top;\n  }\n}\nint clr[N];\nvoid clr1(int x, int c) {\n  clr[x] = c;\n  for (int i = g[x].size() - 1; ~i; --i) {\n    int k = g[x][i];\n    if (!clr[k]) clr1(k, c % p + 1);\n  }\n}\nvoid clr2(int x, int c) {\n  clr[x] = c;\n  for (int i = g[x].size() - 1; ~i; --i) {\n    int k = g[x][i];\n    if (!clr[k]) clr2(k, c == 1 ? p : c - 1);\n  }\n}\nvoid Init() {\n  n = rd<int>(), p = rd<int>();\n  for (int i = 1; i < n; ++i) {\n    int x = rd<int>(), y = rd<int>();\n    g[x].push_back(y), g[y].push_back(x);\n  }\n  if (p == 2) {\n    clr1(1, 1);\n    puts(\"Yes\");\n    for (int i = 1; i <= n; ++i) printf(\"%d \", clr[i]);\n    puts(\"\");\n    exit(0);\n  }\n  dfs1(1, 0);\n  st[0] = pre[0] = -inf, dfs2(1, 0);\n}\nint dfs(int x, int f, int len) {\n  if (!len) return x;\n  for (int i = g[x].size() - 1; ~i; --i) {\n    int k = g[x][i];\n    if (k == f || mx[k] + 1 != mx[x]) continue;\n    return dfs(k, x, len - 1);\n  }\n}\nvoid Solve() {\n  int Mx = 0, Pos = 0;\n  for (int i = 1; i <= n; ++i)\n    if (Mx < mx[i] + sec[i]) Mx = mx[i] + sec[i], Pos = i;\n  int x = dfs(Pos, 0, (mx[Pos] - sec[Pos]) >> 1);\n  int y;\n  for (int i = g[x].size() - 1; ~i; --i) {\n    int k = g[x][i];\n    if (k != fa[x] && mx[k] + 1 == mx[x]) {\n      y = k;\n      break;\n    }\n  }\n  clr[x] = 1, clr[y] = p;\n  clr1(x, 1), clr2(y, p);\n  puts(\"Yes\");\n  for (int i = 1; i <= n; ++i) printf(\"%d \", clr[i]);\n  puts(\"\");\n}\nint main() {\n  Init();\n  Solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstring to_string(string s) { return '\"' + s + '\"'; }\nstring to_string(bool x) { return (x ? \"T\" : \"F\"); }\nstring to_string(const char* s) { return to_string((string)s); }\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename V>\nstring to_string(V v) {\n  bool f = true;\n  string res = \"[\";\n  for (const auto& x : v) {\n    if (!f) res += \", \";\n    f = false;\n    res += to_string(x);\n  }\n  res += \"]\";\n  return res;\n}\nvoid debug() { cerr << endl; }\ntemplate <typename H, typename... T>\nvoid debug(H h, T... t) {\n  cerr << \" \" << to_string(h);\n  debug(t...);\n}\nvoid solve() {\n  int n, k;\n  cin >> n >> k;\n  vector<vector<int>> g(n);\n  for (int _ = 1; _ < n; _++) {\n    int x, y;\n    cin >> x >> y;\n    x--;\n    y--;\n    g[x].emplace_back(y);\n    g[y].emplace_back(x);\n  }\n  if (k == 2) {\n    cout << \"Yes\"\n         << \"\\n\";\n    vector<int> co(n);\n    function<void(int, int)> two = [&](int u, int p) {\n      for (int v : g[u])\n        if (v != p) {\n          co[v] = co[u] ^ 1;\n          two(v, u);\n        }\n    };\n    two(0, -1);\n    for (auto& x : co) {\n      cout << (x + 1) << ' ';\n    }\n    return;\n  }\n  vector<int> d(n);\n  vector<int> pa(n);\n  function<void(int, int)> dfs = [&](int u, int p) {\n    for (int v : g[u])\n      if (v != p) {\n        d[v] = 1 + d[u];\n        pa[v] = u;\n        dfs(v, u);\n      }\n  };\n  d[0] = 1;\n  pa[0] = -1;\n  dfs(0, -1);\n  int root = max_element(d.begin(), d.end()) - d.begin();\n  d[root] = 1;\n  pa[root] = -1;\n  dfs(root, -1);\n  int tail = max_element(d.begin(), d.end()) - d.begin();\n  if (d[tail] < k) {\n    cout << \"Yes\"\n         << \"\\n\";\n    for (int _ = 0; _ < n; _++) {\n      cout << \"1 \";\n    }\n    return;\n  }\n  vector<bool> trk(n, false);\n  vector<int> co(n);\n  vector<int> pth;\n  {\n    int cnt = 0;\n    int x = tail;\n    trk[x] = true;\n    pth.emplace_back(x);\n    co[x] = cnt;\n    (cnt += 1) %= k;\n    while (pa[x] != -1) {\n      x = pa[x];\n      trk[x] = true;\n      pth.emplace_back(x);\n      co[x] = cnt;\n      (cnt += 1) %= k;\n    }\n  }\n  function<int(int)> ck = [&](int u) {\n    int depth = 0;\n    for (int v : g[u])\n      if (!trk[v]) {\n        trk[v] = true;\n        depth = max(depth, 1 + ck(v));\n      }\n    return depth;\n  };\n  int D = d[tail];\n  int m = pth.size();\n  vector<int> dir(m);\n  for (int i = 0; i < m; i++) {\n    int x = i + 1, y = D - i, u = pth[i];\n    int depth = ck(u);\n    2019;\n    if (depth && depth + x >= k && depth + y >= k) {\n      cout << \"No\";\n      return;\n    }\n    if (depth + x < k) dir[i] = -1;\n    if (depth + y < k) dir[i] = +1;\n  }\n  function<void(int, int)> foot = [&](int u, int o) {\n    for (int v : g[u])\n      if (!trk[v]) {\n        trk[v] = true;\n        co[v] = (co[u] + o + k) % k;\n        foot(v, o);\n      }\n  };\n  fill(trk.begin(), trk.end(), false);\n  for (int u : pth) trk[u] = true;\n  for (int i = 0; i < m; i++) {\n    int u = pth[i], o = dir[i];\n    foot(u, o);\n  }\n  cout << \"Yes\"\n       << \"\\n\";\n  for (int i = 0; i < n; i++) {\n    cout << (co[i] + 1) << ' ';\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  solve();\n  cout << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MAXN = 200010;\nvoid bye() {\n  std::cout << \"No\\n\";\n  exit(0);\n}\nint head[MAXN], nxt[MAXN << 1], to[MAXN << 1], tot;\nvoid addedge(int b, int e) {\n  nxt[++tot] = head[b];\n  to[head[b] = tot] = e;\n  nxt[++tot] = head[e];\n  to[head[e] = tot] = b;\n}\nint ansl[MAXN];\nint n, K;\nvoid simpledfs(int u, int fa = 0, int col = 1) {\n  ansl[u] = col;\n  for (int i = head[u]; i; i = nxt[i])\n    if (to[i] != fa) simpledfs(to[i], u, col ^ 1);\n}\nint dis[MAXN];\nvoid dfsx(int u, int fa = 0) {\n  for (int i = head[u]; i; i = nxt[i])\n    if (to[i] != fa) {\n      dis[to[i]] = dis[u] + 1;\n      dfsx(to[i], u);\n    }\n}\nconst int INF = 0x3f3f3f3f;\nstruct data {\n  int a[3];\n  data() { a[0] = a[1] = a[2] = -INF; }\n  void insert(int x) {\n    if (x >= a[0])\n      a[2] = a[1], a[1] = a[0], a[0] = x;\n    else if (x >= a[1])\n      a[2] = a[1], a[1] = x;\n    else if (x >= a[2])\n      a[2] = x;\n  }\n  void shift() { ++a[0], ++a[1], ++a[2]; }\n} val[MAXN], vt[MAXN];\nvoid dfs1(int u, int fa = 0) {\n  for (int i = head[u]; i; i = nxt[i])\n    if (to[i] != fa) {\n      dfs1(to[i], u);\n      val[u].insert(std::max(val[to[i]].a[0], 0) + 1);\n    }\n}\nvoid dfs2(int u, int fa = 0, int upv = 0) {\n  for (int i = head[u]; i; i = nxt[i])\n    if (to[i] != fa) {\n      int tv = std::max(upv, val[u].a[val[to[i]].a[0] + 1 == val[u].a[0]]) + 1;\n      dfs2(to[i], u, tv);\n    }\n  vt[u] = val[u];\n  if (fa) vt[u].insert(upv);\n  if (vt[u].a[2] + vt[u].a[1] + 1 >= K) bye();\n}\nint li[MAXN], inc[MAXN];\nbool mark(int u, int dst, int fa = 0) {\n  if (u == dst) {\n    li[dis[u]] = u;\n    return true;\n  }\n  for (int i = head[u]; i; i = nxt[i])\n    if (to[i] != fa) {\n      if (mark(to[i], dst, u)) {\n        li[dis[u]] = u;\n        return true;\n      }\n    }\n  return false;\n}\nint R;\nvoid dfsmk(int u, int fa, int now, int delta) {\n  now = (now + delta) % K;\n  ansl[u] = now;\n  for (int i = head[u]; i; i = nxt[i])\n    if (to[i] != fa) dfsmk(to[i], u, now, delta);\n}\nint main() {\n  std::ios_base::sync_with_stdio(false), std::cin.tie(0);\n  std::cin >> n >> K;\n  for (int i = 1, t1, t2; i < n; ++i) {\n    std::cin >> t1 >> t2;\n    addedge(t1, t2);\n  }\n  if (K == 2)\n    simpledfs(1);\n  else {\n    dfs1(1);\n    dfs2(1);\n    dis[1] = 0;\n    dfsx(1);\n    int at = 1, rt;\n    for (int i = 2; i <= n; ++i)\n      if (dis[i] > dis[at]) at = i;\n    dis[at] = 0;\n    dfsx(rt = at);\n    at = 1;\n    for (int i = 2; i <= n; ++i)\n      if (dis[i] > dis[at]) at = i;\n    R = dis[at] + 1;\n    mark(rt, at);\n    for (int i = 0; i < R; ++i) inc[li[i]] = true;\n    for (int i = 0; i < R; ++i) {\n      ansl[li[i]] = i % K;\n      int dta = R - 1 - i > i ? K - 1 : 1;\n      for (int j = head[li[i]]; j; j = nxt[j])\n        if (!inc[to[j]]) dfsmk(to[j], li[i], i, dta);\n    }\n  }\n  std::cout << \"Yes\" << std::endl;\n  for (int i = 1; i <= n; ++i) std::cout << ansl[i] + 1 << ' ';\n  std::cout << std::endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int x = 0, f = 1;\n  char c = getchar();\n  for (; !isdigit(c); c = getchar())\n    if (c == '-') f = -1;\n  for (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n  return x * f;\n}\nconst int INF = 1000483600;\nconst int MAXN = 400010;\nint K, N;\nint Next[MAXN << 1], Node[MAXN << 1], Root[MAXN + 1], cnt;\nint col[MAXN + 1];\npair<int, int> f[MAXN + 1][2];\ninline void insert(int u, int v) {\n  Node[++cnt] = v;\n  Next[cnt] = Root[u];\n  Root[u] = cnt;\n  return;\n}\ninline void Add(int k, pair<int, int> a) {\n  if (a.first > f[k][0].first)\n    f[k][1] = f[k][0], f[k][0] = a;\n  else if (a.first > f[k][1].first)\n    f[k][1] = a;\n  return;\n}\nint ans = 0, to = 0;\nint fa[MAXN + 1];\ninline void dfs(int k, int Fa) {\n  fa[k] = Fa;\n  f[k][0].first = 1;\n  f[k][1].first = -INF;\n  f[k][0].second = f[k][1].second = k;\n  for (int x = Root[k]; x; x = Next[x]) {\n    int v = Node[x];\n    if (v == Fa) continue;\n    dfs(v, k);\n    f[v][0].first++;\n    f[v][1].first++;\n    Add(k, f[v][0]);\n  }\n  if (f[k][0].first + f[k][1].first - 1 >= ans)\n    ans = f[k][0].first + f[k][1].first - 1, to = k;\n  return;\n}\ninline void dfs1(int k, int Fa) {\n  f[k][0].first = 1;\n  f[k][1].first = -INF;\n  f[k][0].second = f[k][1].second = k;\n  for (int x = Root[k]; x; x = Next[x]) {\n    int v = Node[x];\n    if (v == Fa) continue;\n    dfs1(v, k);\n    f[v][0].first++;\n    f[v][1].first++;\n    Add(k, f[v][0]);\n  }\n  if (f[k][0].first + f[k][1].first - 1 >= K && K > 2) {\n    puts(\"No\");\n    exit(0);\n  }\n}\ninline void dfs2(int k, int Fa, int nwc, int d) {\n  nwc += d;\n  if (!nwc) nwc = K;\n  if (nwc > K) nwc = 1;\n  col[k] = nwc;\n  for (int x = Root[k]; x; x = Next[x]) {\n    int v = Node[x];\n    if (v == Fa) continue;\n    dfs2(v, k, nwc, d);\n  }\n}\nint head, tail;\nint sta[MAXN + 1], top;\nint vis[MAXN + 1];\nint cp[MAXN + 1];\nint sum1;\nbool flagt;\nint main() {\n  N = read(), K = read();\n  for (int i = 1; i < N; i++) {\n    int u = read(), v = read();\n    insert(u, v);\n    insert(v, u);\n  }\n  dfs(1, 0);\n  int t1 = f[to][0].second, t2 = f[to][1].second;\n  while (t1 != to) sta[++top] = t1, t1 = fa[t1];\n  sta[++top] = to;\n  int last = top, d = 0;\n  while (t2 != to) sta[++top] = t2, t2 = fa[t2];\n  if (last < top) reverse(sta + last + 1, sta + top + 1);\n  for (int i = 1; i <= top; i++)\n    vis[sta[i]] = ++d, col[sta[i]] = cp[i] = ((d - 1) % K) + 1;\n  cp[0] = K;\n  cp[top + 1] = (d % K) + 1;\n  for (int i = 1; i <= top; i++) {\n    int k = sta[i];\n    int s1 = -INF;\n    for (int x = Root[k]; x; x = Next[x]) {\n      int v = Node[x];\n      if (vis[v]) continue;\n      dfs1(v, k);\n      if (f[v][0].first + top - i + 1 >= K && f[v][0].first + i >= K &&\n          K != 2) {\n        puts(\"No\");\n        return 0;\n      }\n      if (i <= top - i + 1) {\n        if (f[v][0].first + top - i + 1 >= K) {\n          dfs2(v, k, cp[i], -1);\n        } else {\n          dfs2(v, k, cp[i], 1);\n        }\n      } else {\n        if (f[v][0].first + i >= K) {\n          dfs2(v, k, cp[i], 1);\n        } else {\n          dfs2(v, k, cp[i], -1);\n        }\n      }\n    }\n  }\n  puts(\"Yes\");\n  for (int i = 1; i <= N; i++) printf(\"%d \", col[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long> adj[200010], maxlen(200010), pathlen[200010], par(200010),\n    color(200010);\nlong long n, k, root, dist, mxdist, far, mnk;\nlong long dfs1(long long loc, long long par) {\n  pathlen[loc].push_back(0);\n  dist++;\n  for (auto &i : adj[loc]) {\n    if (i != par) {\n      if (mxdist < dist) {\n        root = i;\n        mxdist = dist;\n      }\n      pathlen[loc].push_back(dfs1(i, loc) + 1);\n    }\n  }\n  dist--;\n  sort(pathlen[loc].rbegin(), pathlen[loc].rend());\n  pathlen[loc].resize(3);\n  return maxlen[loc] = pathlen[loc][0];\n}\nvoid dfs2(long long loc, long long par, long long parlen = 0) {\n  vector<long long> lvals = pathlen[loc];\n  lvals.push_back(parlen);\n  sort(lvals.rbegin(), lvals.rend());\n  if (lvals[2]) mnk = max(mnk, lvals[1] + lvals[2] + 1);\n  for (auto &i : adj[loc]) {\n    if (i != par) {\n      long long parln = pathlen[loc][0] + 1;\n      if (maxlen[i] + 1 == pathlen[loc][0]) {\n        parln = pathlen[loc][1] + 1;\n      }\n      parln = max(parln, parlen + 1);\n      dfs2(i, loc, parln);\n    }\n  }\n}\nvoid dfs3(long long loc, long long par) {\n  dist++;\n  ::par[loc] = par;\n  for (auto &i : adj[loc]) {\n    if (i != par) {\n      if (mxdist < dist) {\n        far = i;\n        mxdist = dist;\n      }\n      dfs3(i, loc);\n    }\n  }\n  dist--;\n}\nvoid dfs4(long long loc, long long par, long long col, long long delta) {\n  col = ((col + delta + k - 1) % k) + 1;\n  color[loc] = col;\n  for (auto &i : adj[loc]) {\n    if (i != par) {\n      dfs4(i, loc, col, delta);\n    }\n  }\n}\nint32_t main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> k;\n  long long x, y;\n  for (long long i = 1; i < n; i++) {\n    cin >> x >> y;\n    adj[x].push_back(y);\n    adj[y].push_back(x);\n  }\n  dfs1(1, 1);\n  dfs2(1, 1);\n  bool poss = ((k > mnk) || k <= 2);\n  if (!poss) {\n    cout << \"No\";\n  } else {\n    mxdist = 0;\n    dfs3(root, root);\n    long long prev = far;\n    for (long long i = 0; i <= mxdist; i++) {\n      color[far] = (i % k) + 1;\n      for (auto &j : adj[far]) {\n        if (j != par[far] && j != prev) {\n          dfs4(j, far, color[far], 1 - 2 * (2 * i <= mxdist));\n        }\n      }\n      prev = far;\n      far = par[far];\n    }\n    cout << \"Yes\\n\";\n    for (long long i = 1; i <= n; i++) {\n      cout << color[i] << \" \";\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <typename T>\nconstexpr T my_abs(const T &x) {\n  return x < 0 ? -x : x;\n}\nusing ll = long long;\nconstexpr int MOD = 1e9 + 7;\ninline int quick_pow(int a, int n) {\n  int res = 1;\n  while (n) {\n    if (n & 1) res = (ll)res * a % MOD;\n    a = (ll)a * a % MOD;\n    n >>= 1;\n  }\n  return res;\n}\nint que[200005], dis[200005], pre[200005];\nint seq[200005], ans[200005], mxd[200005], n, k;\nbool chose[200005];\nstd::vector<int> adj[200005];\nint bfs(int st) {\n  memset(dis, 0x3f, sizeof(dis));\n  int he = 0, ta = 0;\n  que[ta++] = st;\n  dis[st] = 0;\n  while (he < ta) {\n    int u = que[he++];\n    for (int v : adj[u]) {\n      if (dis[v] > dis[u] + 1) {\n        dis[v] = dis[u] + 1;\n        pre[v] = u;\n        que[ta++] = v;\n      }\n    }\n  }\n  return std::max_element(dis, dis + n) - dis;\n}\nvoid dfs(int u, int fa = -1) {\n  mxd[u] = 0;\n  for (int v : adj[u]) {\n    if (v == fa || chose[v]) continue;\n    dfs(v, u);\n    mxd[u] = std::max(mxd[u], mxd[v] + 1);\n  }\n}\nvoid go(int u, int t, int fa = -1) {\n  for (int v : adj[u]) {\n    if (v == fa || chose[v]) continue;\n    ans[v] = (ans[u] + t + k) % k;\n    go(v, t, u);\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    adj[--u].push_back(--v);\n    adj[v].push_back(u);\n  }\n  int st = bfs(0), en = bfs(st), len = 0;\n  for (int i = en; i != st; i = pre[i]) seq[len++] = i;\n  seq[len++] = st;\n  if (k == 2) {\n    puts(\"Yes\");\n    for (int i = 0; i < n; i++)\n      printf(\"%d%c\", dis[i] % 2 + 1, \" \\n\"[i + 1 == n]);\n    return 0;\n  }\n  for (int i = 0; i < len; i++) chose[seq[i]] = true;\n  for (int i = 0; i < len; i++) {\n    int u = seq[i];\n    ans[u] = i % k;\n    dfs(u);\n    if (!mxd[u]) continue;\n    if (mxd[u] + i + 1 >= k && mxd[u] + len - i >= k) {\n      puts(\"No\");\n      return 0;\n    }\n    if (mxd[u] + len - i >= k)\n      go(u, -1);\n    else\n      go(u, 1);\n  }\n  puts(\"Yes\");\n  for (int i = 0; i < n; i++) printf(\"%d%c\", ans[i] + 1, \" \\n\"[i + 1 == n]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\nint n, k, k1, fa[N], c[N], mx[N], q[N], d[N];\nint mxx, rt1, rt2;\nbool in[N];\nvector<int> g[N];\nvoid fail() {\n  printf(\"No\\n\");\n  exit(0);\n}\nvoid dfs(int x, int d, int f = -1) {\n  if (d > mxx) mxx = d, rt2 = x;\n  for (int i = 0; i < g[x].size(); ++i)\n    if (g[x][i] != f) {\n      dfs(g[x][i], d + 1, x);\n    }\n}\nvoid dfs1(int x) {\n  for (int i = 0; i < g[x].size(); ++i)\n    if (g[x][i] != fa[x]) {\n      int y = g[x][i];\n      fa[y] = x;\n      d[y] = d[x] + 1;\n      dfs1(y);\n    }\n}\nvoid dfs2(int x) {\n  mx[x] = !in[x];\n  for (int i = 0; i < g[x].size(); ++i)\n    if (g[x][i] != fa[x]) {\n      int y = g[x][i];\n      dfs2(y);\n      mx[x] = max(mx[x], mx[y] + (!in[x]));\n    }\n}\nvoid dfs3(int x, int d) {\n  if (d == 1 || d == -1)\n    c[x] = (c[fa[x]] + d + k) % k;\n  else\n    c[x] = 0;\n  for (int i = 0; i < g[x].size(); ++i)\n    if (g[x][i] != fa[x] && !in[g[x][i]]) {\n      int y = g[x][i];\n      dfs3(y, d);\n    }\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1, x, y; i < n; ++i) {\n    scanf(\"%d%d\", &x, &y);\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  dfs(1, 0);\n  rt1 = rt2;\n  mxx = 0;\n  dfs(rt1, 0);\n  dfs1(rt1);\n  for (int x = rt2;; x = fa[x]) {\n    c[x] = k1++;\n    k1 %= k;\n    in[x] = 1;\n    q[++q[0]] = x;\n    if (x == rt1) break;\n  }\n  dfs2(rt1);\n  if (k == 1) {\n    printf(\"Yes\\n\");\n    for (int i = 1; i <= n; ++i) printf(\"%d \", 1);\n    return 0;\n  }\n  if (k == 2) {\n    printf(\"Yes\\n\");\n    for (int i = 1; i <= n; ++i) printf(\"%d \", (d[i] & 1) + 1);\n    return 0;\n  }\n  for (int t = 1; t <= q[0]; ++t) {\n    int x = q[t];\n    for (int i = 0; i < g[x].size(); ++i)\n      if (g[x][i] != fa[x] && !in[g[x][i]]) {\n        int y = g[x][i];\n        int a1 = mx[y] + t;\n        int a2 = mx[y] + q[0] - t + 1;\n        if (a1 >= k && a2 >= k)\n          fail();\n        else\n          dfs3(y, (t <= (q[0] + 1) / 2) ? -1 : 1);\n      }\n  }\n  printf(\"Yes\\n\");\n  for (int i = 1; i <= n; ++i) printf(\"%d \", c[i] + 1);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma warning(disable : 4996)\nint N, K, A[1 << 18], B[1 << 18];\nvector<pair<int, int>> X[1 << 18];\nint dist[1 << 18], dist1[1 << 18], dist2[1 << 18];\nbool diameter[1 << 18];\nvector<int> centroid;\nvoid getdist(int stt) {\n  for (int i = 1; i <= N; i++) dist[i] = (1 << 30);\n  queue<int> Q;\n  Q.push(stt);\n  dist[stt] = 0;\n  while (!Q.empty()) {\n    int pos = Q.front();\n    Q.pop();\n    for (pair<int, int> i : X[pos]) {\n      if (dist[i.first] > dist[pos] + 1) {\n        dist[i.first] = dist[pos] + 1;\n        Q.push(i.first);\n      }\n    }\n  }\n}\nvoid init() {\n  getdist(1);\n  pair<int, int> maxn = make_pair(-1, -1);\n  for (int i = 1; i <= N; i++) maxn = max(maxn, make_pair(dist[i], i));\n  getdist(maxn.second);\n  for (int i = 1; i <= N; i++) dist1[i] = dist[i];\n  pair<int, int> maxn2 = make_pair(-1, -1);\n  for (int i = 1; i <= N; i++) maxn2 = max(maxn2, make_pair(dist[i], i));\n  int cx = maxn2.second;\n  while (cx != maxn.second) {\n    for (pair<int, int> i : X[cx]) {\n      if (dist[i.first] < dist[cx]) {\n        cx = i.first;\n        diameter[i.second] = true;\n        break;\n      }\n    }\n  }\n  getdist(maxn2.second);\n  for (int i = 1; i <= N; i++) dist2[i] = dist[i];\n  int minx = (1 << 30);\n  for (int i = 1; i <= N; i++) {\n    if (minx > max(dist1[i], dist2[i])) {\n      minx = max(dist1[i], dist2[i]);\n      centroid.clear();\n    }\n    if (minx == max(dist1[i], dist2[i])) {\n      centroid.push_back(i);\n    }\n  }\n}\nint C[1 << 18];\nvector<int> Y[1 << 18];\nbool flag = false;\nint dfs2(int pos, int dep) {\n  C[pos] = dep;\n  vector<int> vecs;\n  for (int i = 0; i < Y[pos].size(); i++) {\n    if (C[Y[pos][i]] >= 1) continue;\n    int nex = dep - 1;\n    if (nex == 0) nex = K;\n    int r = dfs2(Y[pos][i], nex);\n    vecs.push_back(r + 1);\n  }\n  sort(vecs.begin(), vecs.end());\n  reverse(vecs.begin(), vecs.end());\n  if (vecs.size() == 0) return 0;\n  if (vecs.size() >= 2 && vecs[0] + vecs[1] + 1 >= K) flag = true;\n  return vecs[0];\n}\nint dfs3(int pos, int dep) {\n  C[pos] = dep;\n  vector<int> vecs;\n  for (int i = 0; i < Y[pos].size(); i++) {\n    if (C[Y[pos][i]] >= 1) continue;\n    int nex = dep + 1;\n    if (nex == K + 1) nex = 1;\n    int r = dfs3(Y[pos][i], nex);\n    vecs.push_back(r + 1);\n  }\n  sort(vecs.begin(), vecs.end());\n  reverse(vecs.begin(), vecs.end());\n  if (vecs.size() == 0) return 0;\n  if (vecs.size() >= 2 && vecs[0] + vecs[1] + 1 >= K) flag = true;\n  return vecs[0];\n}\nvoid solve_1(vector<int> vec) {\n  vector<int> V1, V2;\n  int root = vec[0];\n  int cnts = 0;\n  for (pair<int, int> i : X[root]) {\n    if (diameter[i.second] == true) {\n      if (cnts == 0)\n        V1.push_back(i.first);\n      else\n        V2.push_back(i.first);\n      cnts++;\n    } else {\n      V2.push_back(i.first);\n    }\n  }\n  for (int i = 1; i <= N; i++) {\n    if (A[i] == root || B[i] == root) continue;\n    Y[A[i]].push_back(B[i]);\n    Y[B[i]].push_back(A[i]);\n  }\n  C[root] = 1;\n  vector<int> vecs;\n  for (int i = 0; i < V1.size(); i++) {\n    int val = dfs2(V1[i], K);\n    vecs.push_back(val + 1);\n  }\n  for (int i = 0; i < V2.size(); i++) {\n    int val = dfs3(V2[i], 2);\n    vecs.push_back(val + 1);\n  }\n  sort(vecs.begin(), vecs.end());\n  reverse(vecs.begin(), vecs.end());\n  if (vecs.size() >= 3 && vecs[0] + vecs[2] + 1 >= K) flag = true;\n  if (flag == true) {\n    printf(\"No\\n\");\n  } else {\n    printf(\"Yes\\n\");\n    for (int i = 1; i <= N; i++) {\n      if (i >= 2) printf(\" \");\n      printf(\"%d\", C[i]);\n    }\n    printf(\"\\n\");\n  }\n}\nvoid solve_2(vector<int> vec) {\n  for (int i = 1; i <= N; i++) {\n    if (A[i] == vec[0] && B[i] == vec[1]) continue;\n    if (B[i] == vec[0] && A[i] == vec[1]) continue;\n    Y[A[i]].push_back(B[i]);\n    Y[B[i]].push_back(A[i]);\n  }\n  dfs2(vec[0], 1);\n  dfs3(vec[1], 2);\n  if (flag == true) {\n    printf(\"No\\n\");\n  } else {\n    printf(\"Yes\\n\");\n    for (int i = 1; i <= N; i++) {\n      if (i >= 2) printf(\" \");\n      printf(\"%d\", C[i]);\n    }\n    printf(\"\\n\");\n  }\n}\nvoid dfs4(int pos, int dep) {\n  C[pos] = dep;\n  for (int i = 0; i < X[pos].size(); i++) {\n    if (C[X[pos][i].first] >= 1) continue;\n    dfs4(X[pos][i].first, 3 - dep);\n  }\n}\nint main() {\n  scanf(\"%d%d\", &N, &K);\n  for (int i = 1; i <= N - 1; i++) {\n    scanf(\"%d%d\", &A[i], &B[i]);\n    X[A[i]].push_back(make_pair(B[i], i));\n    X[B[i]].push_back(make_pair(A[i], i));\n  }\n  if (K == 2) {\n    dfs4(1, 1);\n    printf(\"Yes\\n\");\n    for (int i = 1; i <= N; i++) {\n      if (i >= 2) printf(\" \");\n      printf(\"%d\", C[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n  }\n  init();\n  if (centroid.size() == 1) {\n    solve_1(centroid);\n  }\n  if (centroid.size() == 2) {\n    solve_2(centroid);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline void read(T &x) {\n  x = 0;\n  char c = getchar();\n  int f = 1;\n  while (!isdigit(c)) {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (isdigit(c)) {\n    x = x * 10 + c - '0';\n    c = getchar();\n  }\n  x *= f;\n}\ntemplate <class T>\ninline void umin(T &x, T y) {\n  x = x < y ? x : y;\n}\ntemplate <class T>\ninline void umax(T &x, T y) {\n  x = x > y ? x : y;\n}\ninline unsigned int R() {\n  static unsigned int seed = 416;\n  return seed ^= seed >> 5, seed ^= seed << 17, seed ^= seed >> 13;\n}\nconst int N = 466666, inf = 0x3f3f3f3f;\nint n, k, dis[N], pre[N], q[N];\nvector<int> e[N];\nint s[N], len, ans[N];\nbool gg[N];\nint bfs(int S) {\n  for (register int i = (0); i <= (n); i++) dis[i] = inf;\n  int f = 0, r = 1;\n  q[f] = S;\n  dis[S] = 0;\n  memset(pre, 0, sizeof(pre));\n  int res = S;\n  while (f != r) {\n    int u = q[f++];\n    if (dis[u] > dis[res]) res = u;\n    for (register int i = (0); i <= (((int)e[u].size()) - 1); i++)\n      if (dis[e[u][i]] > dis[u] + 1) {\n        dis[e[u][i]] = dis[u] + 1;\n        q[r++] = e[u][i];\n        pre[e[u][i]] = u;\n      }\n  }\n  return res;\n}\nvoid GG() {\n  puts(\"No\");\n  exit(0);\n}\nint CUR;\nvoid dfs(int u, int fa, int d) {\n  if (!gg[u] && d + CUR >= k && d + len - CUR + 1 >= k) GG();\n  if (CUR > len - CUR + 1) {\n    ans[u] = (CUR + d) % k;\n    if (!ans[u]) ans[u] = k;\n  } else {\n    ans[u] = ((CUR - d) % k + k) % k;\n    if (!ans[u]) ans[u] = k;\n  }\n  for (register int i = (0); i <= (((int)e[u].size()) - 1); i++)\n    if (e[u][i] != fa && !gg[e[u][i]]) dfs(e[u][i], u, d + 1);\n}\nvoid ini(int S, int T) {\n  for (int u = T;; u = pre[u]) {\n    s[++len] = u;\n    if (u == S) break;\n  }\n  for (register int i = (1); i <= (len); i++)\n    ans[s[i]] = i % k == 0 ? k : i % k, gg[s[i]] = 1;\n  for (CUR = 1; CUR <= len; CUR++) {\n    dfs(s[CUR], 0, 0);\n  }\n}\nvoid DFS(int u, int fa, int x) {\n  ans[u] = x;\n  for (register int i = (0); i <= (((int)e[u].size()) - 1); i++)\n    if (e[u][i] != fa) DFS(e[u][i], u, 3 - x);\n}\nint main() {\n  read(n);\n  read(k);\n  for (register int i = (1); i <= (n - 1); i++) {\n    int u, v;\n    read(u);\n    read(v);\n    e[u].push_back(v);\n    e[v].push_back(u);\n  }\n  if (k == 2) {\n    DFS(1, 0, 1);\n    puts(\"Yes\");\n    for (register int i = (1); i <= (n); i++) printf(\"%d \", ans[i]);\n    return 0;\n  }\n  int s = bfs(1), t = bfs(s);\n  if (dis[t] <= k - 2) {\n    puts(\"Yes\");\n    for (register int i = (1); i <= (n); i++) printf(\"1 \");\n    return 0;\n  }\n  ini(s, t);\n  puts(\"Yes\");\n  for (register int i = (1); i <= (n); i++) printf(\"%d \", ans[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 2e5 + 5;\nstd::vector<int> g[N];\nint n, k, down[N][3], up[N];\nvoid upd(int a[3], int b) {\n  for (int j = 0; j < 3; j++) {\n    if (a[j] < b) {\n      for (int k = 2; k > j; k--) a[k] = a[k - 1];\n      a[j] = b;\n      break;\n    }\n  }\n}\nvoid dfs1(int u, int fa, bool &ok) {\n  for (int v : g[u])\n    if (v != fa) {\n      dfs1(v, u, ok);\n      upd(down[u], down[v][0] + 1);\n    }\n  if (!down[u][0]) down[u][0] = 1;\n  if (down[u][1] > 1 && down[u][2] > 1 && down[u][1] + down[u][2] >= k + 1 &&\n      k > 2)\n    ok = false;\n}\nvoid dfs2(int u, int fa, bool &ok) {\n  for (int v : g[u])\n    if (v != fa) {\n      int d = down[v][0] + 1;\n      up[v] = std::max(up[u], (d == down[u][0] ? down[u][1] : down[u][0])) + 1;\n      dfs2(v, u, ok);\n    }\n  upd(down[u], up[u]);\n  if (down[u][1] > 1 && down[u][2] > 1 && down[u][1] + down[u][2] >= k + 1 &&\n      k > 2)\n    ok = false;\n}\nint ans[N], par[N], dis[N];\nbool vis[N];\nstd::vector<int> path;\nvoid dfs(int u, int fa, int d) {\n  dis[u] = d;\n  par[u] = fa;\n  for (int v : g[u])\n    if (v != fa) dfs(v, u, d + 1);\n}\nvoid color(int u, int fa, int c, int d) {\n  ans[u] = c;\n  for (int v : g[u])\n    if (v != fa && !vis[v]) {\n      color(v, u, (c + d + k) % k, d);\n    }\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int u, v, i = 1; i < n; i++) {\n    scanf(\"%d%d\", &u, &v);\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  bool ok = true;\n  dfs1(1, 0, ok);\n  up[1] = 1;\n  dfs2(1, 0, ok);\n  if (!ok) return !printf(\"No\");\n  printf(\"Yes\\n\");\n  dfs(1, 0, 0);\n  int L = 1, R;\n  for (int i = 2; i <= n; i++)\n    if (dis[i] > dis[L]) L = i;\n  R = 1;\n  dfs(L, 0, 0);\n  for (int i = 2; i <= n; i++)\n    if (dis[i] > dis[R]) R = i;\n  while (R) {\n    path.push_back(R);\n    vis[R] = true;\n    R = par[R];\n  }\n  int mid = path.size() / 2;\n  for (int i = 0; i < path.size(); i++) {\n    color(path[i], 0, i % k, i < mid ? -1 : 1);\n  }\n  for (int i = 1; i <= n; i++) printf(\"%d \", ans[i] + 1);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 7;\nint n, k;\nint ans[N];\nvector<int> G[N];\nint par[N];\nint dist[N];\nbool onPath[N];\nvector<int> path;\nvoid nie() {\n  puts(\"No\");\n  exit(0);\n}\nvoid write() {\n  puts(\"Yes\");\n  for (int i = 1; i <= n; ++i) printf(\"%d \", ans[i]);\n  puts(\"\");\n  exit(0);\n}\nvoid solveTwo(int u, int p) {\n  for (auto v : G[u])\n    if (v != p) {\n      ans[v] = ans[u] ^ 3;\n      solveTwo(v, u);\n    }\n}\nint maxDepth = 0;\nvoid solveSubtree(int u, int p, int dir, int d) {\n  ans[u] = (ans[p] - 1 + dir + k) % k + 1;\n  maxDepth = max(maxDepth, d);\n  for (auto v : G[u])\n    if (v != p) solveSubtree(v, u, dir, d + 1);\n}\nvoid dfs(int u, int p, int d) {\n  dist[u] = d;\n  par[u] = p;\n  for (auto v : G[u])\n    if (v != p) dfs(v, u, d + 1);\n}\nvoid getPath() {\n  dfs(1, 0, 0);\n  int best = 1;\n  for (int i = 1; i <= n; ++i)\n    if (dist[i] > dist[best]) best = i;\n  dfs(best, 0, 0);\n  best = 1;\n  for (int i = 1; i <= n; ++i)\n    if (dist[i] > dist[best]) best = i;\n  while (best != 0) {\n    onPath[best] = true;\n    path.push_back(best);\n    best = par[best];\n  }\n}\nint main() {\n  scanf(\"%d %d\", &n, &k);\n  for (int i = 1; i < n; ++i) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  if (k == 2) {\n    ans[1] = 1;\n    solveTwo(1, 0);\n    write();\n  }\n  getPath();\n  if (path.size() < k) {\n    for (int i = 1; i <= n; ++i) ans[i] = 1;\n    write();\n  }\n  for (int i = 0; i < (int)path.size(); ++i) ans[path[i]] = i % k + 1;\n  int Left = 0, Right = path.size();\n  for (auto u : path) {\n    ++Left;\n    for (auto v : G[u]) {\n      if (onPath[v]) continue;\n      maxDepth = 0;\n      if (Left < Right)\n        solveSubtree(v, u, -1, 1);\n      else\n        solveSubtree(v, u, 1, 1);\n      if (maxDepth + Left >= k && maxDepth + Right >= k) nie();\n    }\n    --Right;\n  }\n  write();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint const INF = (int)1e9 + 1e3;\nlong long const INFL = (long long)1e18 + 1e6;\nmt19937 tw(chrono::high_resolution_clock::now().time_since_epoch().count());\nuniform_int_distribution<long long> ll_distr;\nlong long rnd(long long a, long long b) {\n  return ll_distr(tw) % (b - a + 1) + a;\n}\nvoid solve() {\n  int n, k;\n  cin >> n >> k;\n  vector<vector<int>> graph(n);\n  for (int i = 0; i < n - 1; ++i) {\n    int a, b;\n    cin >> a >> b;\n    --a;\n    --b;\n    graph[a].push_back(b);\n    graph[b].push_back(a);\n  }\n  if (k == 2) {\n    cout << \"Yes\\n\";\n    vector<int> color(n);\n    function<void(int, int, int)> dfs = [&](int v, int p, int col) {\n      color[v] = col;\n      for (int to : graph[v]) {\n        if (to != p) {\n          dfs(to, v, 1 - col);\n        }\n      }\n    };\n    dfs(0, 0, 0);\n    for (int num : color) {\n      cout << num + 1 << \" \";\n    }\n    cout << \"\\n\";\n    return;\n  }\n  vector<int> ok(n);\n  vector<int> maxd(n);\n  function<void(int, int)> dfs = [&](int v, int p) {\n    ok[v] = true;\n    vector<int> tmp;\n    for (int to : graph[v]) {\n      if (to != p) {\n        dfs(to, v);\n        ok[v] &= ok[to];\n        tmp.push_back(maxd[to] + 1);\n      }\n    }\n    sort(tmp.begin(), tmp.end());\n    if (((int)tmp.size()) >= 2) {\n      ok[v] &= tmp[((int)tmp.size()) - 1] + tmp[((int)tmp.size()) - 2] < k - 1;\n    }\n    if (((int)tmp.size())) {\n      maxd[v] = tmp.back();\n    }\n  };\n  dfs(0, 0);\n  vector<int> ans(n);\n  function<void(int, int, int, int)> color = [&](int v, int p, int col,\n                                                 int shift) {\n    ans[v] = col;\n    for (int to : graph[v]) {\n      if (to != p) {\n        color(to, v, (col + shift) % k, shift);\n      }\n    }\n  };\n  function<void(int, int, int)> push_down = [&](int v, int p, int maxd_p) {\n    int cnt_not_ok = 0;\n    set<pair<int, int>> arr;\n    for (int to : graph[v]) {\n      if (to != p) {\n        cnt_not_ok += !ok[to];\n        arr.insert({maxd[to] + 1, to});\n      }\n    }\n    if (v) {\n      arr.insert({maxd_p + 1, p});\n    }\n    if (!cnt_not_ok) {\n      int tmp = (--arr.end())->first;\n      auto it = arr.lower_bound({k - 1 - tmp, -INF});\n      auto it2 = arr.end();\n      int sum = 0;\n      int cnt = 0;\n      for (int i = 0; i < 4; ++i) {\n        if (i >= 2) {\n          sum += it2->first;\n          ++cnt;\n        }\n        if (it2 == it) {\n          break;\n        }\n        if (it2 == arr.begin()) {\n          break;\n        }\n        --it2;\n      }\n      if (cnt < 2 || sum < k - 1) {\n        int to_tmp = (--arr.end())->second;\n        cerr << \"center \" << v + 1 << endl;\n        for (auto to : arr) {\n          if (to.first < k - 1 - tmp || to.second == to_tmp) {\n            cerr << to.second + 1 << \" \" << 1 << endl;\n            color(to.second, v, 1, 1);\n          } else {\n            cerr << to.second + 1 << \" \" << 2 << endl;\n            color(to.second, v, k - 1, k - 1);\n          }\n        }\n        cout << \"Yes\\n\";\n        for (int c : ans) {\n          cout << c + 1 << \" \";\n        }\n        cout << \"\\n\";\n        exit(0);\n      }\n    }\n    for (int to : graph[v]) {\n      if (to != p) {\n        arr.erase({maxd[to] + 1, to});\n        cnt_not_ok -= !ok[to];\n        if (!cnt_not_ok) {\n          auto it = arr.end();\n          int cnt = 0;\n          int sum = 0;\n          for (int i = 0; i < 2; ++i) {\n            if (it == arr.begin()) {\n              break;\n            }\n            --it;\n            sum += it->first;\n            ++cnt;\n          }\n          if (cnt < 2 || sum < k - 1) {\n            int maxd_ch = 0;\n            if (((int)arr.size())) {\n              maxd_ch = (--arr.end())->first;\n            }\n            push_down(to, v, maxd_ch);\n          }\n        }\n        cnt_not_ok += !ok[to];\n        arr.insert({maxd[to] + 1, to});\n      }\n    }\n  };\n  push_down(0, 0, -1);\n  cout << \"No\\n\";\n}\nint main() {\n  cout << setprecision(15) << fixed;\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int test_count = 1;\n  for (int test = 1; test <= test_count; ++test) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MAXN = 200000;\nstruct edge {\n  int to;\n  edge *nxt;\n} edges[2 * MAXN + 5], *adj[MAXN + 5], *ecnt = &edges[0];\nint clr[MAXN + 5], n, k;\nvoid addedge(int u, int v) {\n  edge *p = (++ecnt);\n  p->to = v, p->nxt = adj[u], adj[u] = p;\n  p = (++ecnt);\n  p->to = u, p->nxt = adj[v], adj[v] = p;\n}\nint dep[MAXN + 5];\nvoid dfs1(int x, int f) {\n  dep[x] = dep[f] + 1;\n  for (edge *p = adj[x]; p; p = p->nxt)\n    if (p->to != f) dfs1(p->to, x);\n}\nint get_pos(int x) {\n  dfs1(x, 0);\n  int mx = x;\n  for (int i = 1; i <= n; i++)\n    if (dep[i] > dep[mx]) mx = i;\n  return mx;\n}\nbool tag[MAXN + 5];\nvoid dfs2(int x, int f) {\n  for (edge *p = adj[x]; p; p = p->nxt)\n    if (p->to != f) {\n      dfs2(p->to, x);\n      tag[x] |= tag[p->to];\n    }\n}\nint f[MAXN + 5], g[MAXN + 5];\nint nxt(int x) { return (x == k) ? 1 : x + 1; }\nint lst(int x) { return (x == 1) ? k : x - 1; }\nvoid dfs4(int x, int fa, int type) {\n  if (type)\n    clr[x] = nxt(clr[fa]);\n  else\n    clr[x] = lst(clr[fa]);\n  for (edge *p = adj[x]; p; p = p->nxt)\n    if (p->to != fa) {\n      dfs4(p->to, x, type);\n      if (f[p->to] + 1 > f[x])\n        g[x] = f[x], f[x] = f[p->to] + 1;\n      else if (f[p->to] + 1 > g[x])\n        g[x] = f[p->to] + 1;\n    }\n  if (f[x] && g[x] && f[x] + g[x] + 1 >= k) {\n    puts(\"No\");\n    exit(0);\n  }\n}\nint mxdep;\nvoid dfs3(int x, int fa) {\n  clr[x] = nxt(clr[fa]);\n  f[x] = g[x] = 0;\n  for (edge *p = adj[x]; p; p = p->nxt)\n    if (p->to != fa) {\n      if (tag[p->to])\n        dfs3(p->to, x);\n      else {\n        if (dep[x] <= mxdep - dep[x] + 1)\n          dfs4(p->to, x, 0);\n        else\n          dfs4(p->to, x, 1);\n        if (f[p->to] + 1 > f[x])\n          g[x] = f[x], f[x] = f[p->to] + 1;\n        else if (f[p->to] + 1 > g[x])\n          g[x] = f[p->to] + 1;\n      }\n    }\n  if (f[x] && g[x] && f[x] + g[x] + 1 >= k) {\n    puts(\"No\");\n    exit(0);\n  }\n  if (f[x] && f[x] + dep[x] >= k && f[x] + mxdep - dep[x] + 1 >= k) {\n    puts(\"No\");\n    exit(0);\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    addedge(u, v);\n  }\n  if (k == 2) {\n    puts(\"Yes\"), get_pos(1);\n    for (int i = 1; i <= n; i++) printf(\"%d \", (dep[i] & 1) + 1);\n    return 0;\n  }\n  int p = get_pos(1), q = get_pos(p);\n  mxdep = dep[q];\n  tag[q] = true, dfs2(p, 0), clr[0] = k, dfs3(p, 0);\n  puts(\"Yes\");\n  for (int i = 1; i <= n; i++) printf(\"%d \", clr[i]);\n  puts(\"\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read();\nconst int maxn = 2e5 + 5;\nint n, k, c;\nint col[maxn], dn[maxn], id[maxn];\nint he[maxn], ne[maxn << 1], to[maxn << 1];\nstruct TRI {\n  int x, y, z;\n} mx[maxn];\nvoid Add_Edge(int x, int y) {\n  ne[++c] = he[x];\n  he[x] = c;\n  to[c] = y;\n  ne[++c] = he[y];\n  he[y] = c;\n  to[c] = x;\n}\nvoid Max(TRI& a, int k, int u, int v) {\n  if (a.x <= k)\n    a.z = a.y, a.y = a.x, a.x = k, id[u] = v;\n  else if (a.y <= k)\n    a.z = a.y, a.y = k;\n  else if (a.z <= k)\n    a.z = k;\n}\nvoid Dfs_Up(int p, int f) {\n  mx[p] = (TRI){0, 0, 0};\n  for (int i = he[p]; i; i = ne[i]) {\n    if (to[i] == f) continue;\n    Dfs_Up(to[i], p);\n    Max(mx[p], mx[to[i]].x + 1, p, to[i]);\n  }\n  if (!mx[p].x) mx[p].x = 1;\n}\nvoid Dfs_Down(int p, int f) {\n  for (int i = he[p]; i; i = ne[i]) {\n    if (to[i] == f) continue;\n    Max(mx[to[i]], id[p] == to[i] ? mx[p].y + 1 : mx[p].x + 1, to[i], p);\n    Dfs_Down(to[i], p);\n  }\n}\nint id2[maxn], len[maxn];\nvoid Dfs_Link(int p, int f) {\n  for (int i = he[p]; i; i = ne[i]) {\n    if (to[i] == f) continue;\n    Dfs_Link(to[i], p);\n    if (len[to[i]] > len[p]) len[p] = len[to[i]], id2[p] = to[i];\n  }\n  len[p]++;\n}\nint cnt, stk[maxn];\nbool Chk() {\n  Dfs_Up(1, 0);\n  int p = 1;\n  while (id[p]) p = id[p];\n  Dfs_Link(p, 0);\n  while (p) stk[++cnt] = p, p = id2[p];\n  Dfs_Down(1, 0);\n  for (int i = 1; i <= n; ++i)\n    if (mx[i].z && mx[i].z + mx[i].y - 1 >= k) return printf(\"No\\n\"), 0;\n  return 1;\n}\nvoid Color(int p, int f, int d) {\n  for (int i = he[p]; i; i = ne[i]) {\n    if (to[i] == f) continue;\n    col[to[i]] = (col[p] + d + k - 1) % k + 1;\n    Color(to[i], p, d);\n  }\n}\nvoid Work() {\n  n = read(), k = read();\n  for (int i = 1; i < n; ++i) Add_Edge(read(), read());\n  if (k == 2) {\n    col[1] = 1;\n    Color(1, 0, 1);\n    printf(\"Yes\\n\");\n    for (int i = 1; i <= n; ++i) printf(\"%d \", col[i]);\n    return;\n  }\n  if (Chk()) {\n    for (int i = 1; i <= cnt; ++i) col[stk[i]] = i % k + 1;\n    Color(stk[cnt / 2], stk[cnt / 2 + 1], -1);\n    Color(stk[cnt / 2 + 1], stk[cnt / 2], 1);\n    printf(\"Yes\\n\");\n    for (int i = 1; i <= n; ++i) printf(\"%d \", col[i]);\n  }\n}\nint main() {\n  Work();\n  return 0;\n}\ninline int read() {\n  char c;\n  bool type = 1;\n  while ((c = getchar()) < '0' || c > '9')\n    if (c == '-') type = 0;\n  int ans = c ^ 48;\n  while ((c = getchar()) >= '0' && c <= '9')\n    ans = (ans << 3) + (ans << 1) + (c ^ 48);\n  return type ? ans : -ans;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MX = 200005;\nvector<int> neigh[MX];\nint depth[MX];\nint par[MX];\nvoid dfs1(int v, int p, int d) {\n  par[v] = p;\n  depth[v] = d;\n  for (int u : neigh[v]) {\n    if (u == p) continue;\n    dfs1(u, v, d + 1);\n  }\n}\nvector<int> diag;\nbool is_diag[MX];\nint dfs2(int v, int p) {\n  int h = 0;\n  for (int u : neigh[v]) {\n    if (u == p) continue;\n    if (is_diag[u]) continue;\n    h = max(h, dfs2(u, v));\n  }\n  return h + 1;\n}\nint k;\nvoid dfs3(int v, int p, int x, int d) {\n  depth[v] = x;\n  x += d;\n  if (x < 0) x += k;\n  if (x >= k) x -= k;\n  for (int u : neigh[v]) {\n    if (u == p) continue;\n    if (is_diag[u]) continue;\n    dfs3(u, v, x, d);\n  }\n}\nint main() {\n  int n;\n  ignore = scanf(\"%d %d\", &n, &k);\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    ignore = scanf(\"%d %d\", &u, &v);\n    neigh[u].push_back(v);\n    neigh[v].push_back(u);\n  }\n  if (k == 2) {\n    dfs1(1, 0, 1);\n    printf(\"Yes\\n\");\n    for (int v = 1; v <= n; v++) {\n      printf(\"%d \", depth[v] % 2 + 1);\n    }\n    return 0;\n  }\n  {\n    dfs1(1, 0, 1);\n    int v = 1;\n    for (int i = 1; i <= n; i++) {\n      if (depth[i] > depth[v]) v = i;\n    }\n    dfs1(v, 0, 1);\n    v = 1;\n    for (int i = 1; i <= n; i++) {\n      if (depth[i] > depth[v]) v = i;\n    }\n    while (v) {\n      is_diag[v] = true;\n      diag.push_back(v);\n      v = par[v];\n    }\n  }\n  for (int i = 0; i < (int)diag.size(); i++) {\n    int v = diag[i];\n    int d = dfs2(v, 0);\n    if (d > 1 && d + i >= k && d + (int)diag.size() - i - 1 >= k) {\n      printf(\"No\\n\");\n      return 0;\n    }\n    if (d + i >= k) {\n      dfs3(v, 0, i % k, 1);\n    } else {\n      dfs3(v, 0, i % k, -1);\n    }\n  }\n  printf(\"Yes\\n\");\n  for (int i = 1; i <= n; i++) {\n    printf(\"%d \", depth[i] + 1);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1000000007;\nconst long long INF = mod * mod;\nconst long double eps = 1e-5;\nconst long double pi = acos(-1.0);\nint n, k;\nvector<int> G[1 << 18];\nvector<int> dist;\nint hantai(int s) {\n  dist.clear();\n  dist.resize(n, mod);\n  dist[s] = 0;\n  queue<int> q;\n  q.push(s);\n  int res;\n  while (!q.empty()) {\n    int id = q.front();\n    q.pop();\n    for (int j = 0; j < G[id].size(); j++) {\n      int to = G[id][j];\n      if (dist[id] + 1 < dist[to]) {\n        dist[to] = dist[id] + 1;\n        q.push(to);\n      }\n    }\n    res = id;\n  }\n  return res;\n}\nint depth(int id, int fr) {\n  int res = 0;\n  for (int j = 0; j < G[id].size(); j++) {\n    int to = G[id][j];\n    if (to == fr) continue;\n    res = max(res, depth(to, id));\n  }\n  return res + 1;\n}\nvector<int> ans(n);\nvoid tocol(int id, int fr, int col, bool inc) {\n  if (inc)\n    col++;\n  else\n    col--;\n  col = (col % k + k) % k;\n  ans[id] = col;\n  for (int j = 0; j < G[id].size(); j++) {\n    int to = G[id][j];\n    if (to == fr) continue;\n    tocol(to, id, col, inc);\n  }\n}\nvoid solve() {\n  cin >> n >> k;\n  ans.resize(n);\n  for (int i = 0; i < n - 1; i++) {\n    int a, b;\n    cin >> a >> b;\n    a--;\n    b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  if (k == 2) {\n    cout << \"Yes\" << endl;\n    queue<int> q;\n    q.push(0);\n    vector<bool> used(n, false);\n    used[0] = true;\n    while (!q.empty()) {\n      int id = q.front();\n      q.pop();\n      for (int j = 0; j < G[id].size(); j++) {\n        int to = G[id][j];\n        if (used[to]) continue;\n        ans[to] = ans[id] ^ 1;\n        used[to] = true;\n        q.push(to);\n      }\n    }\n    for (int i = 0; i < n; i++) {\n      if (i > 0) cout << \" \";\n      cout << ans[i] + 1;\n    }\n    cout << endl;\n    return;\n  }\n  int l = hantai(0);\n  int r = hantai(l);\n  int ma = dist[r];\n  vector<int> ldist = dist;\n  hantai(r);\n  vector<int> &rdist = dist;\n  int cur = l;\n  vector<int> pathes;\n  vector<bool> inpathes(n, false);\n  while (cur != r) {\n    inpathes[cur] = true;\n    pathes.push_back(cur);\n    for (int j = 0; j < G[cur].size(); j++) {\n      int to = G[cur][j];\n      if (inpathes[to]) continue;\n      if (ma == ldist[to] + rdist[to]) {\n        cur = to;\n        break;\n      }\n    }\n  }\n  inpathes[r] = true;\n  pathes.push_back(r);\n  if (pathes.size() < k) {\n    cout << \"Yes\" << endl;\n    for (int i = 0; i < n; i++) {\n      if (i > 0) cout << \" \";\n      cout << (i % k) + 1;\n    }\n    cout << endl;\n    return;\n  }\n  for (int i = 0; i < pathes.size(); i++) {\n    int col = i % k;\n    int id = pathes[i];\n    ans[id] = col;\n    int dl = ldist[id], dr = rdist[id];\n    int mal = 0;\n    vector<int> szs;\n    for (int j = 0; j < G[id].size(); j++) {\n      int to = G[id][j];\n      if (inpathes[to]) continue;\n      int sz = depth(to, id);\n      szs.push_back(sz);\n    }\n    sort(szs.begin(), szs.end(), greater<int>());\n    if (szs.size() >= 2) {\n      if (szs[0] + szs[1] + 1 >= k) {\n        cout << \"No\" << endl;\n        return;\n      }\n    }\n    for (int j = 0; j < G[id].size(); j++) {\n      int to = G[id][j];\n      if (inpathes[to]) continue;\n      int sz = depth(to, id);\n      if (sz + dl + 1 >= k && sz + dr + 1 >= k) {\n        cout << \"No\" << endl;\n        return;\n      }\n      if (sz + dl + 1 >= k) {\n        tocol(to, id, i % k, true);\n      } else {\n        tocol(to, id, i % k, false);\n      }\n    }\n  }\n  cout << \"Yes\" << endl;\n  for (int i = 0; i < n; i++) {\n    if (i > 0) cout << \" \";\n    cout << ans[i] + 1;\n  }\n  cout << endl;\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ninline int rand(int x, int y) {\n  ++y;\n  return (rng() % (y - x)) + x;\n}\nstring to_string(char c) {\n  string second(1, c);\n  return second;\n}\nstring to_string(bool b) { return (b ? \"true\" : \"false\"); }\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\nvoid degug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid degug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  degug_out(T...);\n}\ninline int gcd(int a, int b) {\n  if (a > b) swap(a, b);\n  if (a == 0) return b;\n  return gcd(b % a, a);\n}\nint n, k, ans[(200006)], up[(200006)];\npair<int, int> dp[(200006)][3];\nvector<int> v[(200006)];\nvoid put(pair<int, int> *A, pair<int, int> x) {\n  A[2] = max(A[2], x);\n  if (A[2] > A[1]) swap(A[1], A[2]);\n  if (A[1] > A[0]) swap(A[0], A[1]);\n}\nvoid dfs(int x, int p) {\n  for (auto i : v[x])\n    if (i ^ p) {\n      dfs(i, x);\n      put(dp[x], pair<int, int>(dp[i][0].first + 1, i));\n    }\n}\nbool bad(int a, int b, int c) {\n  if (a == 0 || b == 0 || c == 0) return 0;\n  return (a + b) >= k - 1 && (a + c) >= k - 1 && (b + c) >= k - 1;\n}\nbool bad(int a, int b, int c, int d) {\n  vector<int> v;\n  v.emplace_back(a), v.emplace_back(b), v.emplace_back(c), v.emplace_back(d);\n  sort((v).begin(), (v).end(), greater<int>());\n  return bad(v[0], v[1], v[2]);\n}\nvoid dfs2(int x, int p) {\n  if (bad(dp[x][0].first, dp[x][1].first, dp[x][2].first, up[x])) {\n    cout << \"No\\n\";\n    exit(0);\n  }\n  for (auto i : v[x])\n    if (i ^ p) {\n      int mx = dp[x][0].first;\n      if (dp[x][0].second == i) mx = dp[x][1].first;\n      up[i] = max(up[x] + 1, mx + 1);\n      dfs2(i, x);\n    }\n}\nstruct diam {\n  int dist[(200006)];\n  int p[(200006)];\n  stack<int> stk;\n  void solve(int x, int p) {\n    assert(stk.size());\n    ans[x] = stk.top();\n    stk.pop();\n    for (auto i : v[x])\n      if (i ^ p) {\n        solve(i, x);\n      }\n    stk.emplace(ans[x]);\n  }\n  void main() {\n    while (stk.size()) stk.pop();\n    dist[1] = 0;\n    dfs(1, 1);\n    pair<int, int> root = pair<int, int>(1, 1);\n    for (int i = (2); i <= (int)(n); ++i)\n      if (dist[i] > dist[root.first]) root.first = i;\n    dist[root.first] = 0;\n    dfs(root.first, root.first);\n    for (int i = (2); i <= (int)(n); ++i)\n      if (dist[i] > dist[root.second]) root.second = i;\n    assert(root.first ^ root.second);\n    int x = root.second;\n    vector<int> path;\n    while (x ^ root.first) {\n      path.emplace_back(x);\n      x = p[x];\n    }\n    path.emplace_back(root.first);\n    if (path.size() < k) case2();\n    reverse((path).begin(), (path).end());\n    int co = 0;\n    for (auto i : path) ans[i] = co % k, ++co;\n    stk.emplace(ans[path[0]]);\n    for (int i = (1); i <= (int)(((int)path.size()) / 2 - 1); ++i) {\n      for (auto j : v[path[i]])\n        if (j != path[i - 1] && j != path[i + 1]) solve(j, path[i]);\n      stk.emplace(ans[path[i]]);\n    }\n    while (stk.size()) stk.pop();\n    stk.emplace(ans[path.back()]);\n    for (int i = (((int)path.size()) - 2); i >= (int)(((int)path.size()) / 2);\n         --i) {\n      for (auto j : v[path[i]])\n        if (j != path[i - 1] && j != path[i + 1]) solve(j, path[i]);\n      stk.emplace(ans[path[i]]);\n    }\n  }\n  void dfs(int x, int par) {\n    p[x] = par;\n    for (auto i : v[x])\n      if (i ^ par) dist[i] = dist[x] + 1, dfs(i, x);\n  }\n  void case2() {\n    cout << \"YES\\n\";\n    for (int i = (1); i <= (int)(n); ++i) cout << 1 << ' ';\n    exit(0);\n  }\n} d;\nvoid dfsw(int x, int p) {\n  for (auto i : v[x])\n    if (i ^ p) {\n      ans[i] = !ans[x];\n      dfsw(i, x);\n    }\n}\nvoid weird() {\n  ans[1] = 0;\n  dfsw(1, 1);\n  cout << \"YES\\n\";\n  for (int i = (1); i <= (int)(n); ++i) cout << ans[i] + 1 << ' ';\n  exit(0);\n}\nint main() {\n  memset((ans), -1, sizeof((ans)));\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> k;\n  for (int i = (0); i <= (int)(n - 2); ++i) {\n    int a, b;\n    cin >> a >> b;\n    v[a].emplace_back(b), v[b].emplace_back(a);\n  }\n  if (k == 2) weird();\n  dfs(1, 1);\n  dfs2(1, 1);\n  d.main();\n  cout << \"YES\\n\";\n  for (int i = (1); i <= (int)(n); ++i)\n    assert(~ans[i]), cout << ans[i] + 1 << ' ';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T, typename U>\nstd::istream& operator>>(std::istream& i, pair<T, U>& p) {\n  i >> p.first >> p.second;\n  return i;\n}\ntemplate <typename T>\nstd::istream& operator>>(std::istream& i, vector<T>& t) {\n  for (auto& v : t) {\n    i >> v;\n  }\n  return i;\n}\ntemplate <typename T, typename U>\nstd::ostream& operator<<(std::ostream& o, const pair<T, U>& p) {\n  o << p.first << ' ' << p.second;\n  return o;\n}\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& o, const vector<T>& t) {\n  if (t.empty()) o << '\\n';\n  for (size_t i = 0; i < t.size(); ++i) {\n    o << t[i] << \" \\n\"[i == t.size() - 1];\n  }\n  return o;\n}\ntemplate <typename T>\nusing minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T>\nusing maxheap = priority_queue<T, vector<T>, less<T>>;\nunsigned int logceil(long long first) {\n  return first ? 8 * sizeof(long long) - __builtin_clzll(first) : 0;\n}\nnamespace std {\ntemplate <typename T, typename U>\nstruct hash<pair<T, U>> {\n  hash<T> t;\n  hash<U> u;\n  size_t operator()(const pair<T, U>& p) const {\n    return t(p.first) ^ (u(p.second) << 7);\n  }\n};\n}  // namespace std\ntemplate <typename T, typename F>\nT bsh(T l, T h, const F& f) {\n  T r = -1, m;\n  while (l <= h) {\n    m = (l + h) / 2;\n    if (f(m)) {\n      l = m + 1;\n      r = m;\n    } else {\n      h = m - 1;\n    }\n  }\n  return r;\n}\ntemplate <typename F>\ndouble bshd(double l, double h, const F& f, double p = 1e-9) {\n  unsigned int r = 3 + (unsigned int)log2((h - l) / p);\n  while (r--) {\n    double m = (l + h) / 2;\n    if (f(m)) {\n      l = m;\n    } else {\n      h = m;\n    }\n  }\n  return (l + h) / 2;\n}\ntemplate <typename T, typename F>\nT bsl(T l, T h, const F& f) {\n  T r = -1, m;\n  while (l <= h) {\n    m = (l + h) / 2;\n    if (f(m)) {\n      h = m - 1;\n      r = m;\n    } else {\n      l = m + 1;\n    }\n  }\n  return r;\n}\ntemplate <typename F>\ndouble bsld(double l, double h, const F& f, double p = 1e-9) {\n  unsigned int r = 3 + (unsigned int)log2((h - l) / p);\n  while (r--) {\n    double m = (l + h) / 2;\n    if (f(m)) {\n      h = m;\n    } else {\n      l = m;\n    }\n  }\n  return (l + h) / 2;\n}\ntemplate <typename T>\nT gcd(T a, T b) {\n  if (a < b) swap(a, b);\n  return b ? gcd(b, a % b) : a;\n}\ntemplate <typename T>\nclass vector2 : public vector<vector<T>> {\n public:\n  vector2() {}\n  vector2(size_t a, size_t b, T t = T())\n      : vector<vector<T>>(a, vector<T>(b, t)) {}\n};\ntemplate <typename T>\nclass vector3 : public vector<vector2<T>> {\n public:\n  vector3() {}\n  vector3(size_t a, size_t b, size_t c, T t = T())\n      : vector<vector2<T>>(a, vector2<T>(b, c, t)) {}\n};\ntemplate <typename T>\nclass vector4 : public vector<vector3<T>> {\n public:\n  vector4() {}\n  vector4(size_t a, size_t b, size_t c, size_t d, T t = T())\n      : vector<vector3<T>>(a, vector3<T>(b, c, d, t)) {}\n};\ntemplate <typename T>\nclass vector5 : public vector<vector4<T>> {\n public:\n  vector5() {}\n  vector5(size_t a, size_t b, size_t c, size_t d, size_t e, T t = T())\n      : vector<vector4<T>>(a, vector4<T>(b, c, d, e, t)) {}\n};\nclass HTilesPlacement {\n public:\n  void bip(int u, int p, int q, const vector<vector<int>>& E,\n           vector<int>& Ans) {\n    Ans[u] = q;\n    for (int v : E[u])\n      if (v != p) bip(v, u, 3 - q, E, Ans);\n  }\n  bool fail;\n  int N, K;\n  vector<vector<int>> E;\n  vector<int> D;\n  bool path(int u, int p, int t, vector<int>& P) {\n    if (u == t) {\n      P.push_back(u);\n      return true;\n    }\n    P.push_back(u);\n    for (int v : E[u])\n      if (v != p) {\n        if (path(v, u, t, P)) return true;\n      }\n    P.pop_back();\n    return false;\n  }\n  int depth(int u, int p) {\n    D[u] = 0;\n    for (int v : E[u])\n      if (v != p) D[u] = max(D[u], depth(v, u) + 1);\n    return D[u];\n  }\n  std::pair<int, int> dist(int u, int p) {\n    std::pair<int, int> ans = {0, u};\n    for (int v : E[u])\n      if (v != p) ans = max(ans, dist(v, u));\n    ans.first++;\n    return ans;\n  }\n  void fill(int u, int p, int d, int s, vector<int>& Ans) {\n    Ans[u] = d;\n    for (int v : E[u])\n      if (v != p) fill(v, u, (d + s + K) % K, s, Ans);\n  }\n  void dfs(int u, int p, int top) {\n    vector<int> A, V;\n    for (int v : E[u])\n      if (v != p) {\n        V.push_back(v);\n        A.push_back(D[v] + 1);\n      }\n    int M = A.size();\n    vector<int> S(M + 1, 0), P(M + 1, 0);\n    for (int i = 0; i < M; ++i) {\n      P[i + 1] = max(P[i], A[i]);\n      S[M - i - 1] = max(S[M - i], A[M - 1 - i]);\n    }\n    if (top != 0) A.push_back(top);\n    if (A.size() >= 3) {\n      sort(A.begin(), A.end());\n      reverse(A.begin(), A.end());\n      if (A[1] + A[2] + 1 >= K) fail = true;\n    }\n    for (int i = 0; i < M; ++i) {\n      dfs(V[i], u, 1 + max(top, max(P[i], S[i + 1])));\n    }\n  }\n  void solve(istream& cin, ostream& cout) {\n    cin >> N >> K;\n    E.resize(N);\n    D.resize(N);\n    for (int i = 0; i < N - 1; ++i) {\n      int u, v;\n      cin >> u >> v;\n      --u;\n      --v;\n      E[u].push_back(v);\n      E[v].push_back(u);\n    }\n    fail = false;\n    if (K == 2) {\n      vector<int> Ans(N, -1);\n      bip(0, -1, 1, E, Ans);\n      cout << \"Yes\\n\" << Ans;\n    } else {\n      depth(0, -1);\n      dfs(0, -1, 0);\n      if (fail) {\n        cout << \"No\\n\";\n        return;\n      }\n      std::pair<int, int> q = dist(0, -1);\n      std::pair<int, int> r = dist(q.second, -1);\n      vector<int> P;\n      path(q.second, -1, r.second, P);\n      vector<int> Ans(N, -1);\n      for (int i = 0; i < P.size(); ++i) {\n        Ans[P[i]] = i % K;\n      }\n      for (int i = 0; i < P.size(); ++i) {\n        int u = P[i];\n        for (int v : E[u])\n          if (Ans[v] == -1) {\n            int s = (2 * i < P.size()) ? -1 : 1;\n            fill(v, u, (Ans[u] + K + s) % K, s, Ans);\n          }\n      }\n      for (int& a : Ans) ++a;\n      cout << \"Yes\\n\" << Ans;\n    }\n  }\n};\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  HTilesPlacement solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int neg = 1, num = 0;\n  char c = getchar();\n  for (; !isdigit(c); c = getchar())\n    if (c == '-') neg = -1;\n  for (; isdigit(c); c = getchar()) num = (num << 1) + (num << 3) + c - '0';\n  return neg * num;\n}\nint n, k, rt, mx, F, S, ans[500010], f[500010][4], dep[500010];\nvector<int> g[500010];\ninline void update(int x, int w) {\n  if (w >= f[x][0])\n    f[x][2] = f[x][1], f[x][1] = f[x][0], f[x][0] = w;\n  else if (w < f[x][0] && w >= f[x][1])\n    f[x][2] = f[x][1], f[x][1] = w;\n  else if (w < f[x][1] && w >= f[x][2])\n    f[x][2] = w;\n}\ninline void dfs1(int u, int fa) {\n  for (auto v : g[u]) {\n    if (v == fa) continue;\n    dfs1(v, u);\n    update(u, f[v][0] + 1);\n  }\n}\ninline void dfs2(int u, int fa) {\n  if (u != 1) {\n    if (f[fa][0] == f[u][0] + 1)\n      f[u][3] = max(f[fa][3], f[fa][1]) + 1;\n    else\n      f[u][3] = max(f[fa][3], f[fa][0]) + 1;\n  }\n  for (auto v : g[u])\n    if (v != fa) dfs2(v, u);\n}\ninline void dfs3(int u, int fa) {\n  if (max(f[u][3], f[u][0]) < mx) {\n    mx = max(f[u][3], f[u][0]), rt = u;\n    if (rt != 1) {\n      for (auto v : g[u])\n        if (v != fa && f[v][0] + 1 == f[u][0]) S = v;\n      F = fa;\n      if (f[u][3] > f[u][0]) swap(S, F);\n    } else {\n      for (auto v : g[u]) {\n        if (v == fa) continue;\n        if (f[v][0] + 1 == f[u][0]) {\n          S = v;\n          continue;\n        }\n        if (f[v][1] + 1 == f[u][1]) {\n          F = v;\n          continue;\n        }\n      }\n    }\n  }\n  for (auto v : g[u])\n    if (v != fa) dfs3(v, u);\n}\ninline void dfs4(int u, int fa, int opt) {\n  ans[u] = ans[fa] + opt;\n  if (ans[u] == k + 1) ans[u] = 1;\n  if (ans[u] == 0) ans[u] = k;\n  for (auto v : g[u])\n    if (v != fa) dfs4(v, u, opt);\n}\ninline void dfs5(int u, int fa, int sum) {\n  mx = max(mx, sum);\n  for (auto v : g[u]) dfs5(v, u, sum + 1);\n}\nsigned main() {\n  n = mx = read();\n  k = read();\n  for (int i = 1; i <= n - 1; i++) {\n    int u = read(), v = read();\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  if (k == 2) {\n    cout << \"Yes\" << endl;\n    ans[1] = 1;\n    for (auto v : g[1]) dfs4(v, 1, 1);\n    for (int i = 1; i <= n; i++) cout << ans[i] << \" \";\n    return 0;\n  }\n  dfs1(1, 0);\n  dfs2(1, 0);\n  dfs3(1, 0);\n  for (int i = 1; i <= n; i++) {\n    sort(f[i], f[i] + 4);\n    if (f[i][1] + f[i][2] + 1 >= k && f[i][1] && f[i][2]) {\n      cout << \"No\" << endl;\n      exit(0);\n    }\n  }\n  cout << \"Yes\\n\";\n  ans[rt] = 1;\n  dfs4(S, rt, 1);\n  for (auto v : g[rt])\n    if (v != S) dfs4(v, rt, -1);\n  for (int i = 1; i <= n; i++) printf(\"%d \", ans[i] == 0 ? 1 : ans[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios {\n  fast_ios() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n  };\n} fast_ios_;\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &v) {\n  for (auto &x : v) is >> x;\n  return is;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, vector<T> &v) {\n  for (long long i = 0; i < v.size(); i++) {\n    cout << v[i];\n    if (i != v.size() - 1) cout << endl;\n  };\n  return os;\n}\ntemplate <typename T>\nvoid Out(T x) {\n  cout << x << endl;\n}\ntemplate <typename T1, typename T2>\nvoid Ans(bool first, T1 y, T2 n) {\n  if (first)\n    Out(y);\n  else\n    Out(n);\n}\nusing vec = vector<long long>;\nusing mat = vector<vec>;\nusing Pii = pair<long long, long long>;\nusing PiP = pair<long long, Pii>;\nusing PPi = pair<Pii, long long>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\nconst long long mod = 1000000007;\nstruct edge {\n  long long to, cost, id;\n};\nclass Graph {\n public:\n  long long N;\n  vector<vector<edge>> G;\n  vec ans;\n  Graph(long long N) : N(N) {\n    G = vector<vector<edge>>(N, vector<edge>(0));\n    ans = vec(N, -1);\n  }\n  void add_Directed_edge(long long from, long long to, long long cost = 1,\n                         long long id = 0) {\n    G[from].push_back(edge({to, cost, id}));\n  }\n  void add_Undirected_edge(long long v1, long long v2, long long cost = 1,\n                           long long id = 0) {\n    add_Directed_edge(v1, v2, cost, id);\n    add_Directed_edge(v2, v1, cost, id);\n  }\n  void dfs_for_calcdist(long long v, long long p, long long c, vec &dist) {\n    if (p != -1) dist[v] = dist[p] + c;\n    for (auto e : G[v])\n      if (e.to != p) dfs_for_calcdist(e.to, v, e.cost, dist);\n  }\n  long long diameter(long long &v1, long long &v2, long long second = 0) {\n    vec dist(N, 0);\n    dfs_for_calcdist(second, -1, -1, dist);\n    v1 = distance(dist.begin(), max_element(dist.begin(), dist.end()));\n    fill(dist.begin(), dist.end(), 0);\n    dfs_for_calcdist(v1, -1, -1, dist);\n    auto amax = max_element(dist.begin(), dist.end());\n    v2 = distance(dist.begin(), amax);\n    return *amax;\n  }\n  void dfs_for_k2(long long v, long long p = -1) {\n    if (p == -1)\n      ans[v] = 0;\n    else\n      ans[v] = 1 - ans[p];\n    for (auto e : G[v])\n      if (e.to != p) dfs_for_k2(e.to, v);\n  }\n  void showans() {\n    Out(\"Yes\");\n    for (long long i = (0); i < (N); i++) cout << ans[i] + 1 << ' ';\n    cout << endl;\n  }\n};\nsigned main() {\n  long long n, k;\n  cin >> n >> k;\n  Graph G(n);\n  for (long long i = (0); i < (n - 1); i++) {\n    long long a, b;\n    cin >> a >> b;\n    G.add_Undirected_edge(a - 1, b - 1, 1);\n  }\n  if (k == 2) {\n    G.dfs_for_k2(0);\n    G.showans();\n    return 0;\n  }\n  long long second, t;\n  long long R = G.diameter(second, t, 0);\n  if (R + 1 < k) {\n    Out(\"Yes\");\n    for (long long i = (0); i < (n); i++) cout << i % k + 1 << ' ';\n    cout << endl;\n    return 0;\n  }\n  vec dist_s(n, 0), dist_t(n, 0);\n  G.dfs_for_calcdist(second, -1, -1, dist_s);\n  G.dfs_for_calcdist(t, -1, -1, dist_t);\n  long long now = second;\n  long long c = 0;\n  while (true) {\n    G.ans[now] = c;\n    c = (c + 1) % k;\n    if (now == t) break;\n    for (auto e : G.G[now])\n      if (dist_t[e.to] == dist_t[now] - 1) {\n        now = e.to;\n        break;\n      }\n  }\n  for (long long i = (0); i < (n); i++)\n    if (G.ans[i] == -1) {\n      long long dt = dist_t[i], ds = dist_s[i];\n      if (dt >= k - 1 && ds >= k - 1) {\n        Out(\"No\");\n        return 0;\n      }\n      if (ds >= dt)\n        G.ans[i] = ds % k;\n      else\n        G.ans[i] = ((G.ans[t] - dt) % k + k) % k;\n    }\n  G.showans();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint n, k;\nstruct edge_t {\n  struct edge_t *next;\n  int v;\n};\nstruct edge_t *e[200005], ep[200005 * 2], *ep_top = ep;\nvoid add_edge(int u, int v) {\n  ep_top->v = v;\n  ep_top->next = e[u];\n  e[u] = ep_top++;\n  ep_top->v = u;\n  ep_top->next = e[v];\n  e[v] = ep_top++;\n}\nint color[200005];\nvoid dye_2(int u, int f) {\n  color[u] = !color[f];\n  for (struct edge_t *i = e[u]; i; i = i->next) {\n    int v = i->v;\n    if (v == f) continue;\n    dye_2(v, u);\n  }\n}\nstruct far_t {\n  int dis, id;\n};\nstruct far_t get_far(int u, int f) {\n  struct far_t res = {.dis = 0, .id = u};\n  for (struct edge_t *i = e[u]; i; i = i->next) {\n    const int v = i->v;\n    if (v == f) continue;\n    struct far_t v_far = get_far(v, u);\n    if (v_far.dis + 1 > res.dis) res = v_far, res.dis++;\n  }\n  return res;\n}\nint d_u, d_v, dlen;\nint dis_u[200005], dis_v[200005];\nbool on_chain[200005], bel_u[200005];\nvoid init_dis(int *dest, int u, int f, int cur_dis) {\n  dest[u] = cur_dis;\n  for (struct edge_t *i = e[u]; i; i = i->next) {\n    int v = i->v;\n    if (v == f) continue;\n    init_dis(dest, v, u, cur_dis + 1);\n  }\n}\nvoid dye_chain(int u, int f) {\n  color[u] = dis_u[u] % k;\n  for (struct edge_t *i = e[u]; i; i = i->next) {\n    int v = i->v;\n    if (!on_chain[v] || v == f) continue;\n    dye_chain(v, u);\n  }\n}\nvoid calc_bel(int u, int f) {\n  for (struct edge_t *i = e[u]; i; i = i->next) {\n    int v = i->v;\n    if (v == f) continue;\n    calc_bel(v, u);\n    bel_u[u] |= bel_u[v];\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i < n; ++i) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    add_edge(u, v);\n  }\n  if (k == 2) {\n    puts(\"Yes\");\n    dye_2(1, 0);\n    for (int i = 1; i <= n; ++i) printf(\"%d%c\", color[i] + 1, \" \\n\"[i == n]);\n    return 0;\n  }\n  d_u = get_far(1, 0).id;\n  d_v = get_far(d_u, 0).id;\n  init_dis(dis_u, d_u, 0, 0);\n  init_dis(dis_v, d_v, 0, 0);\n  dlen = dis_u[d_v];\n  for (int i = 1; i <= n; ++i) {\n    if (dis_u[i] + dis_v[i] == dlen)\n      on_chain[i] = true;\n    else if (dis_u[i] >= k - 1 && dis_v[i] >= k - 1) {\n      puts(\"No\");\n      return 0;\n    }\n    if (dis_u[i] >= k - 1) bel_u[i] = true;\n  }\n  dye_chain(d_u, 0);\n  calc_bel(d_u, 0);\n  for (int u = 1; u <= n; ++u)\n    if (!on_chain[u]) {\n      if (bel_u[u])\n        color[u] = dis_u[u] % k;\n      else\n        color[u] = ((color[d_v] - dis_v[u]) % k + k) % k;\n    }\n  puts(\"Yes\");\n  for (int i = 1; i <= n; ++i) printf(\"%d%c\", color[i] + 1, \" \\n\"[i == n]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 300005;\nint n, m, win, col[maxn];\nint pre[maxn], *dis, Dis[2][maxn];\nvector<int> g[maxn];\nvoid dfs(int x, int p, int d) {\n  pre[x] = p;\n  dis[x] = d;\n  for (int &y : g[x])\n    if (y != p) dfs(y, x, d + 1);\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  win = 1;\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  dis = Dis[0];\n  dfs(1, 0, 0);\n  if (m == 2) {\n    for (int i = 1; i <= n; i++) col[i] = dis[i] % 2 + 1;\n  } else {\n    int patA = 0, disA = -1;\n    for (int i = 1; i <= n; i++)\n      if (dis[i] > disA) disA = dis[i], patA = i;\n    dfs(patA, 0, 0);\n    int patB = 0, disB = -1;\n    for (int i = 1; i <= n; i++)\n      if (dis[i] > disB) disB = dis[i], patB = i;\n    dis = Dis[1];\n    dfs(patB, 0, 0);\n    for (int x = patA; x; x = pre[x]) col[x] = Dis[0][x] % m + 1;\n    for (int i = 1; win && i <= n; i++)\n      if (!col[i]) {\n        if (Dis[0][i] + 1 >= m && Dis[1][i] + 1 >= m)\n          win = 0;\n        else if (Dis[0][i] >= Dis[1][i])\n          col[i] = Dis[0][i] % m + 1;\n        else\n          col[i] = ((col[patB] - 1 - Dis[1][i]) % m + m) % m + 1;\n      }\n  }\n  if (win) {\n    puts(\"Yes\");\n    for (int i = 1; i <= n; i++) printf(\"%d \", col[i]);\n  } else\n    puts(\"No\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int mod = 998244353;\nconst long double error = 2e-6;\nconst long double PI = acosl(-1);\nmt19937 rng((unsigned)chrono::system_clock::now().time_since_epoch().count());\ninline long long int MOD(long long int x, long long int m = mod) {\n  long long int y = x % m;\n  return (y >= 0) ? y : y + m;\n}\nconst int inf = 1e9;\nconst long long int infl = 1061109567;\nconst int nmax = 2e5 + 10;\nvector<int> adj[nmax];\npair<int, int> best[nmax][4];\nint depth[nmax];\nvoid dfs1(int root, int par) {\n  depth[root] = (par == -1) ? 1 : depth[par] + 1;\n  best[root][1] = best[root][2] = best[root][3] = {0, root};\n  for (int u : adj[root]) {\n    if (u == par) continue;\n    dfs1(u, root);\n    best[root][0] = {best[u][3].first + 1, u};\n    sort(best[root], best[root] + 4);\n  }\n  return;\n}\nvoid dfs2(int root, int par) {\n  if (par != -1) {\n    if (best[par][3].second == root)\n      best[root][0] = {best[par][2].first + 1, par};\n    else\n      best[root][0] = {best[par][3].first + 1, par};\n    sort(best[root], best[root] + 4);\n  }\n  for (int u : adj[root]) {\n    if (u == par) continue;\n    dfs2(u, root);\n  }\n  return;\n}\nint ans[nmax];\nvoid dfs3(int root, int par, int del, int k) {\n  ans[root] = ans[par] + del;\n  if (ans[root] > k) ans[root] = 1;\n  if (ans[root] < 1) ans[root] = k;\n  for (int u : adj[root]) {\n    if (u == par) continue;\n    dfs3(u, root, del, k);\n  }\n  return;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ;\n  int n, k;\n  cin >> n >> k;\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    cin >> u >> v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  dfs1(1, -1);\n  if (k == 2) {\n    cout << \"YES\" << endl;\n    for (int i = 1; i <= n; i++) {\n      cout << depth[i] % 2 + 1 << \" \";\n    }\n    return 0;\n  }\n  dfs2(1, -1);\n  for (int i = 1; i <= n; i++) {\n    if (best[i][1].first == 0) continue;\n    if (best[i][1].first + best[i][2].first >= k - 1) {\n      cout << \"NO\" << endl;\n      return 0;\n    }\n  }\n  int diamend = 1;\n  for (int i = 1; i <= n; i++) {\n    if (best[i][3].first > best[diamend][3].first) diamend = i;\n  }\n  int cur = diamend, dlen = best[diamend][3].first + 1;\n  vector<int> diameter;\n  set<int> st;\n  while (true) {\n    ans[cur] = diameter.size() % k + 1;\n    st.insert(cur);\n    diameter.push_back(cur);\n    if (diameter.size() > 1 && diameter.end()[-2] == best[cur][3].second)\n      cur = best[cur][2].second;\n    else\n      cur = best[cur][3].second;\n    if (cur == diameter.back()) break;\n  }\n  assert(st.size() == dlen);\n  for (int i = 0; i < diameter.size(); i++) {\n    int u = diameter[i];\n    int del = 0;\n    if (i < diameter.size() / 2)\n      del = -1;\n    else\n      del = 1;\n    for (int v : adj[u]) {\n      if (ans[v]) continue;\n      dfs3(v, u, del, k);\n    }\n  }\n  cout << \"YES\" << endl;\n  for (int i = 1; i <= n; i++) {\n    cout << ans[i] << \" \";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 1;\nvector<int> adj[N];\nint height[N][3];\nint color[N];\nint dist[N];\nint par[N];\nint dep, k;\nvoid update(int u, int c) {\n  if (c == 0) return;\n  for (int i = 0; i < 3; ++i) {\n    if (height[c][0] + 1 > height[u][i]) {\n      for (int j = 2; j > i; --j) {\n        height[u][j] = height[u][j - 1];\n      }\n      height[u][i] = height[c][0] + 1;\n      return;\n    }\n  }\n}\nvoid dfs_pull(int u, int p) {\n  for (int c : adj[u]) {\n    if (c != p) {\n      dfs_pull(c, u);\n      update(u, c);\n    }\n  }\n}\nvoid dfs_push(int u, int p) {\n  update(u, p);\n  if (height[u][0] + height[u][1] >= k - 1 &&\n      height[u][1] + height[u][2] >= k - 1 && height[u][2] > 0) {\n    cout << \"No\\n\";\n    exit(0);\n  }\n  for (int c : adj[u]) {\n    if (c != p) {\n      int pre2 = height[u][0];\n      if (height[u][0] == height[c][0] + 1) {\n        height[u][0] = height[u][1];\n      }\n      dfs_push(c, u);\n      height[u][0] = pre2;\n    }\n  }\n}\npair<int, int> dfs_dep(int u, int dep) {\n  pair<int, int> far = {dep, u};\n  for (int c : adj[u]) {\n    if (c != par[u]) {\n      par[c] = u;\n      far = max(far, dfs_dep(c, dep + 1));\n    }\n  }\n  return far;\n}\nvoid dfs_color(int u, int p, int cur, int dir) {\n  cur = (cur + dir + k) % k;\n  color[u] = cur;\n  for (int c : adj[u]) {\n    if (c != p) {\n      dfs_color(c, u, cur, dir);\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n;\n  cin >> n >> k;\n  for (int i = 0; i < n - 1; ++i) {\n    int u, v;\n    cin >> u >> v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  if (k > 2) {\n    dfs_pull(1, 0);\n    dfs_push(1, 0);\n  }\n  int root = dfs_dep(1, 0).second;\n  par[root] = 0;\n  auto [diameter, u] = dfs_dep(root, 0);\n  int cur = 0;\n  int pre = 0;\n  while (u != root) {\n    color[u] = cur % k;\n    for (int c : adj[u]) {\n      if (c != par[u] && c != pre) {\n        dfs_color(c, u, cur, (2 * cur > diameter ? 1 : -1));\n      }\n    }\n    pre = u;\n    u = par[u];\n    ++cur;\n  }\n  color[root] = cur % k;\n  cout << \"Yes\\n\";\n  for (int i = 1; i <= n; ++i) {\n    cout << color[i] + 1 << \" \";\n  }\n  cout << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 212345;\nint n, k;\nvector<int> G[maxn];\nint f[maxn], g[maxn], h[maxn], ans[maxn];\nint dfs1(int u, int par) {\n  int ret = u;\n  for (auto v : G[u])\n    if (v != par) {\n      f[v] = f[u] + 1;\n      int now = dfs1(v, u);\n      if (f[ret] < f[now]) ret = now;\n    }\n  return ret;\n}\nint dfs2(int u, int par) {\n  int ret = u;\n  for (auto v : G[u])\n    if (v != par) {\n      g[v] = g[u] + 1;\n      int now = dfs2(v, u);\n      if (g[ret] < g[now]) ret = now;\n    }\n  return h[u] = ret;\n}\nbool dfs3(int u, int par, int st, int d, int en) {\n  if (++en >= k && k != 2) return false;\n  st += d;\n  ans[u] = st % k + 1;\n  for (auto v : G[u])\n    if (v != par && !dfs3(v, u, st, d, en)) return false;\n  return true;\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int(i) = (0); (i) <= ((n - 1) - 1); (i)++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    G[u].emplace_back(v);\n    G[v].emplace_back(u);\n  }\n  int u = dfs1(1, 0);\n  int v = dfs2(u, 0);\n  for (int(i) = (1); (i) <= (n); (i)++)\n    if (h[i] == v) {\n      ans[i] = g[i] % k + 1;\n      if (g[i] * 2 < g[v]) {\n        for (auto j : G[i])\n          if (h[j] != v) {\n            if (!dfs3(j, i, g[i], -1, g[i] + 1)) goto label;\n          }\n      } else {\n        for (auto j : G[i])\n          if (h[j] != v) {\n            if (!dfs3(j, i, g[i], 1, g[v] - g[i] + 1)) goto label;\n          }\n      }\n    }\n  puts(\"Yes\");\n  for (int(i) = (1); (i) <= (n); (i)++) printf(\"%d \", ans[i]);\n  return 0;\nlabel:\n  puts(\"No\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 5;\nvector<int> e[maxn];\nvector<int> chs[maxn];\nbool used[maxn];\nint ld[maxn], lu[maxn];\nint h[maxn];\nvoid dfs0(int v) {\n  used[v] = true;\n  ld[v] = 0;\n  for (int u : e[v]) {\n    if (!used[u]) {\n      h[u] = h[v] + 1;\n      dfs0(u);\n      ld[v] = max(ld[v], ld[u] + 1);\n      chs[v].push_back(u);\n    }\n  }\n}\nvoid dfs1(int v) {\n  int m1 = -5, m2 = -5;\n  for (int u : chs[v]) {\n    if (ld[u] + 1 >= m1) {\n      m2 = m1;\n      m1 = ld[u];\n    } else if (ld[u] + 1 >= m2) {\n      m2 = ld[u];\n    }\n  }\n  for (int u : chs[v]) {\n    if (m1 != ld[u])\n      lu[u] = max(lu[v] + 1, m1 + 2);\n    else\n      lu[u] = max(lu[v] + 1, m2 + 2);\n    dfs1(u);\n  }\n}\nvoid dfs2(int v) {\n  used[v] = true;\n  for (int u : e[v]) {\n    if (!used[u]) {\n      h[u] = h[v] + 1;\n      dfs2(u);\n      chs[v].push_back(u);\n    }\n  }\n}\nvector<int> tv;\nbool onto[maxn];\nvoid dfs3(int v) {\n  for (int u : chs[v]) {\n    dfs3(u);\n    onto[v] |= onto[u];\n  }\n}\nint gett(int v, int t) {\n  if (t == 0) return v;\n  for (int u : chs[v]) {\n    if (onto[u]) return gett(u, t - 1);\n  }\n}\nint res[maxn];\nvoid dfsst1(int v, int cur, int k) {\n  res[v] = cur;\n  cur = (cur + 1) % k;\n  used[v] = true;\n  for (int u : e[v]) {\n    if (!used[u]) {\n      dfsst1(u, cur, k);\n    }\n  }\n}\nvoid dfsst2(int v, int cur, int k) {\n  res[v] = cur;\n  cur = (cur - 1 + k) % k;\n  used[v] = true;\n  for (int u : e[v]) {\n    if (!used[u]) {\n      dfsst2(u, cur, k);\n    }\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, k;\n  cin >> n >> k;\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n    e[u].push_back(v);\n    e[v].push_back(u);\n  }\n  dfs0(1);\n  dfs1(1);\n  if (k == 2) {\n    fill(used, used + n + 1, false);\n    dfsst1(1, 0, 2);\n    cout << \"Yes\\n\";\n    for (int i = 1; i <= n; i++) {\n      cout << res[i] + 1 << \" \";\n    }\n    return 0;\n  }\n  for (int i = 1; i <= n; i++) {\n    tv.clear();\n    if (i != 1) tv.push_back(lu[i]);\n    for (int u : chs[i]) {\n      tv.push_back(ld[u] + 1);\n    }\n    sort(tv.begin(), tv.end(), greater<int>());\n    if (tv.size() >= 3 && tv[1] + tv[2] >= k - 1) {\n      cout << \"No\";\n      return 0;\n    }\n  }\n  cout << \"Yes\\n\";\n  int st = 1;\n  for (int i = 1; i <= n; i++) {\n    if (h[i] > h[st]) st = i;\n  }\n  fill(used, used + n + 1, false);\n  h[st] = 0;\n  for (int i = 1; i <= n; i++) {\n    chs[i].clear();\n  }\n  dfs2(st);\n  int fin = st;\n  for (int i = 1; i <= n; i++) {\n    if (h[i] > h[fin]) fin = i;\n  }\n  onto[fin] = true;\n  dfs3(st);\n  int x = gett(st, (h[fin] + 1) / 2 - 1);\n  int y = gett(st, (h[fin] + 1) / 2);\n  fill(used, used + n + 1, false);\n  used[y] = true;\n  dfsst1(x, 0, k);\n  fill(used, used + n + 1, false);\n  used[x] = true;\n  dfsst2(y, k - 1, k);\n  for (int i = 1; i <= n; i++) {\n    cout << res[i] + 1 << \" \";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200005;\ntemplate <class T>\nvoid read(T &x) {\n  int sgn = 1;\n  char ch;\n  x = 0;\n  for (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar())\n    ;\n  if (ch == '-') ch = getchar(), sgn = -1;\n  for (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n  x *= sgn;\n}\ntemplate <class T>\nvoid write(T x) {\n  if (x < 0)\n    putchar('-'), write(-x);\n  else if (x < 10)\n    putchar(x + '0');\n  else\n    write(x / 10), putchar(x % 10 + '0');\n}\nstruct edge {\n  int to, nxt;\n} tree[N << 1];\nint n, k, s = 1, t = 1, mid1, mid2, head[N], dep[N], dep2[N], par[N], col[N],\n          cnt = 0;\nvoid addedge(int u, int v) {\n  edge x = {v, head[u]};\n  tree[head[u] = cnt++] = x;\n}\nvoid dfs1(int u, int fa) {\n  if (fa) dep[u] = dep[fa] + 1;\n  for (int i = head[u]; ~i; i = tree[i].nxt) {\n    int v = tree[i].to;\n    if (v != fa) dfs1(v, u);\n  }\n}\nvoid dfs2(int u, int fa) {\n  if (fa) dep2[u] = dep2[fa] + 1, par[u] = fa;\n  for (int i = head[u]; ~i; i = tree[i].nxt) {\n    int v = tree[i].to;\n    if (v != fa) dfs2(v, u);\n  }\n}\nvoid dfs3(int u, int fa) {\n  col[u] = (col[fa] + 1) % k;\n  for (int i = head[u]; ~i; i = tree[i].nxt) {\n    int v = tree[i].to;\n    if (v != fa) dfs3(v, u);\n  }\n}\nvoid dfs4(int u, int fa) {\n  col[u] = (col[fa] + k - 1) % k;\n  for (int i = head[u]; ~i; i = tree[i].nxt) {\n    int v = tree[i].to;\n    if (v != fa) dfs4(v, u);\n  }\n}\nint main() {\n  read(n), read(k);\n  for (int i = 1; i <= n; i++) head[i] = -1;\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    read(u), read(v);\n    addedge(u, v), addedge(v, u);\n  }\n  if (k == 1) {\n    printf(\"Yes\\n\");\n    for (int i = 1; i <= n; i++) write(1), putchar(' ');\n    putchar('\\n');\n  } else {\n    dep[1] = 1, dfs1(1, 0);\n    if (k == 2) {\n      printf(\"Yes\\n\");\n      for (int i = 1; i <= n; i++) write(dep[i] & 1 ? 1 : 2), putchar(' ');\n      putchar('\\n');\n    } else {\n      for (int i = 2; i <= n; i++) {\n        if (dep[i] > dep[s]) s = i;\n      }\n      dep[s] = 1, dfs1(s, 0);\n      for (int i = 2; i <= n; i++) {\n        if (dep[i] > dep[t]) t = i;\n      }\n      dep2[t] = 1, dfs2(t, 0);\n      bool flag = true;\n      for (int i = 1; i <= n; i++) {\n        int d = (dep[i] + dep2[i] - dep[t]) / 2 + 1;\n        int d1 = dep[i] - d, d2 = dep2[i] - d;\n        if (d > 1 && d >= k - d1 && d >= k - d2) flag = false;\n      }\n      if (!flag)\n        printf(\"No\\n\");\n      else {\n        mid1 = s;\n        for (int i = 0; i < ((dep[t] - 1) >> 1); i++) mid1 = par[mid1];\n        mid2 = par[mid1];\n        col[mid1] = 1, col[mid2] = 0;\n        dfs3(mid1, mid2), dfs4(mid2, mid1);\n        printf(\"Yes\\n\");\n        for (int i = 1; i <= n; i++) write(col[i] + 1), putchar(' ');\n        putchar('\\n');\n      }\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 212345;\nint n, k, s, t, f[maxn], dep[maxn], deps[maxn], dept[maxn], col[maxn];\nbool in[maxn];\nvector<int> G[maxn];\nvoid dfs1(int u, int fa, int *mdep) {\n  mdep[u] = dep[u] = dep[fa] + 1;\n  f[u] = fa;\n  for (int i = 0; i < (int)G[u].size(); ++i) {\n    int v = G[u][i];\n    if (v == fa) continue;\n    dfs1(v, u, mdep);\n    mdep[u] = max(mdep[u], mdep[v]);\n  }\n}\nvoid dfs(int u, int fa, int c) {\n  if (in[u])\n    c = c % k + 1;\n  else {\n    int cnt = 0;\n    if (deps[u] >= k) ++cnt;\n    if (dept[u] >= k) ++cnt;\n    if (cnt == 2) {\n      puts(\"No\");\n      exit(0);\n    }\n    if (deps[u] >= k)\n      c = c % k + 1;\n    else if (dept[u] >= k)\n      c = (c + k - 2) % k + 1;\n  }\n  col[u] = c;\n  for (int i = 0; i < (int)G[u].size(); ++i) {\n    int v = G[u][i];\n    if (v == fa) continue;\n    dfs(v, u, c);\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 0; i < n - 1; ++i) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  dfs1(1, 0, deps);\n  if (k == 2) {\n    puts(\"Yes\");\n    for (int i = 1; i <= n; ++i)\n      printf(\"%d%c\", dep[i] % 2 + 1, i == n ? '\\n' : ' ');\n    return 0;\n  }\n  for (int i = 1; i <= n; ++i)\n    if (dep[i] > dep[s]) s = i;\n  dfs1(s, 0, deps);\n  for (int i = 1; i <= n; ++i)\n    if (dep[i] > dep[t]) t = i;\n  int tt = t;\n  while (tt) {\n    in[tt] = true;\n    tt = f[tt];\n  }\n  dfs1(t, 0, dept);\n  dfs(s, 0, 0);\n  puts(\"Yes\");\n  for (int i = 1; i <= n; ++i) printf(\"%d%c\", col[i], i == n ? '\\n' : ' ');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200005;\nconst int inf = 1000 * 1000 * 1000;\nconst int mod = 1000 * 1000 * 1000 + 7;\nint n, k;\nvector<int> g[N];\nint mx, gag;\nint answ[N];\nint parent[N];\nint dp[3][N];\nvoid color(int v, int p, int r) {\n  answ[v] = r + 1;\n  for (int i = 0; i < (int)g[v].size(); i++) {\n    int to = g[v][i];\n    if (to == p) continue;\n    color(to, v, r ^ 1);\n  }\n}\nvoid dfs(int v, int p, int r, int id) {\n  dp[id][v] = r;\n  if (r > mx) {\n    mx = r;\n    gag = v;\n  }\n  for (int i = 0; i < (int)g[v].size(); i++) {\n    int to = g[v][i];\n    if (to == p) continue;\n    parent[to] = v;\n    dfs(to, v, r + 1, id);\n  }\n}\nbool used[N];\nvoid color(int v, int p, int guyn, int delta) {\n  answ[v] = guyn;\n  for (int i = 0; i < (int)g[v].size(); i++) {\n    int to = g[v][i];\n    if (to == p || used[to]) continue;\n    int gg = guyn + delta;\n    if (gg > k) gg -= k;\n    if (gg < 1) gg += k;\n    color(to, v, gg, delta);\n  }\n}\nint main() {\n  mt19937 myrand(chrono::steady_clock::now().time_since_epoch().count());\n  cin >> n >> k;\n  for (int i = 1; i < n; i++) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  if (k == 2) {\n    color(1, -1, 0);\n    cout << \"Yes\" << endl;\n    for (int i = 1; i <= n; i++) {\n      printf(\"%d \", answ[i]);\n    }\n    cout << endl;\n    return 0;\n  }\n  dfs(1, -1, 0, 0);\n  int s = gag;\n  mx = -1;\n  dfs(gag, -1, 0, 0);\n  int e = gag;\n  int it = 1;\n  vector<int> path;\n  while (e != s) {\n    path.push_back(e);\n    used[e] = true;\n    answ[e] = it;\n    it++;\n    if (it > k) it -= k;\n    e = parent[e];\n  }\n  path.push_back(s);\n  used[s] = true;\n  answ[s] = it;\n  e = gag;\n  dfs(gag, -1, 0, 1);\n  for (int i = 1; i <= n; i++) {\n    if (used[i]) continue;\n    if (dp[0][i] >= k - 1 && dp[1][i] >= k - 1) {\n      cout << \"No\" << endl;\n      return 0;\n    }\n  }\n  cout << \"Yes\" << endl;\n  for (int i = 0; i < (int)path.size() / 2; i++) {\n    color(path[i], -1, answ[path[i]], -1);\n  }\n  for (int i = (int)path.size() / 2; i < (int)path.size(); i++) {\n    color(path[i], -1, answ[path[i]], 1);\n  }\n  for (int i = 1; i <= n; i++) {\n    printf(\"%d \", answ[i]);\n  }\n  cout << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nvector<vector<int> > edges;\nvector<int> par;\nvector<vector<int> > ch;\nvector<vector<int> > paths;\nvector<int> down;\nvector<int> down_where;\nvector<int> up;\nvector<int> vs;\nvoid dfs(int v, int p) {\n  par[v] = p;\n  if (p >= 0) ch[p].push_back(v);\n  for (int w : edges[v]) {\n    if (w == p) continue;\n    dfs(w, v);\n  }\n  vs.push_back(v);\n}\nvector<int> color;\nvoid dfs2(int v, int p, int col, int diff) {\n  col %= k;\n  if (col < 0) col += k;\n  color[v] = col;\n  for (int w : edges[v]) {\n    if (w == p) continue;\n    dfs2(w, v, col + diff, diff);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  cin >> n >> k;\n  edges.resize(n);\n  ch.resize(n);\n  par.resize(n);\n  paths.resize(n);\n  down.assign(n, 0);\n  down_where.assign(n, -1);\n  up.assign(n, 0);\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n    u--;\n    v--;\n    edges[u].push_back(v);\n    edges[v].push_back(u);\n  }\n  dfs(0, -1);\n  assert((int)vs.size() == n);\n  for (int v : vs) {\n    int p = par[v];\n    if (p == -1) continue;\n    paths[p].push_back(1 + down[v]);\n    if (1 + down[v] > down[p]) {\n      down[p] = 1 + down[v];\n      down_where[p] = v;\n    }\n  }\n  reverse(vs.begin(), vs.end());\n  up[0] = 0;\n  for (int v : vs) {\n    multiset<int> g;\n    for (int w : ch[v]) {\n      g.insert(down[w] + 1);\n    }\n    for (int w : ch[v]) {\n      up[w] = up[v] + 1;\n      g.erase(g.find(down[w] + 1));\n      if (!g.empty()) up[w] = max(up[w], *prev(g.end()) + 1);\n      g.insert(down[w] + 1);\n      paths[w].push_back(up[w]);\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (up[i] > down[i]) {\n      down[i] = up[i];\n      down_where[i] = par[i];\n    }\n  }\n  int r = -1;\n  for (int i = 0; i < n; i++) {\n    assert(down_where[i] >= 0);\n    if (down_where[down_where[i]] == i) {\n      r = i;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    sort(paths[i].begin(), paths[i].end());\n    reverse(paths[i].begin(), paths[i].end());\n    if (k >= 3 && (int)paths[i].size() >= 3 &&\n        paths[i][1] + paths[i][2] >= k - 1) {\n      cout << \"No\" << '\\n';\n      return 0;\n    }\n  }\n  color.assign(n, -1);\n  dfs2(r, down_where[r], 0, -1);\n  dfs2(down_where[r], r, 1, 1);\n  cout << \"Yes\" << '\\n';\n  for (int i = 0; i < n; i++) {\n    cout << color[i] + 1 << ' ';\n  }\n  cout << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = (int)2e5;\nvector<int> g[N];\nint h[N];\nmultiset<int, greater<int>> S[N];\nint get_max(multiset<int, greater<int>>& S) {\n  if (S.empty()) return 0;\n  return *S.begin();\n}\nint dfs_h(int v, int p) {\n  for (int u : g[v]) {\n    if (u == p) continue;\n    S[v].insert(dfs_h(u, v) + 1);\n  }\n  return h[v] = get_max(S[v]);\n}\nbool dfs_check(int v, int p, int k) {\n  if ((int)(S[v]).size() >= 3) {\n    int a[3];\n    int pos = 0;\n    for (auto it = S[v].begin(); pos < 3; ++it, ++pos) a[pos] = *it;\n    if (a[1] + a[2] >= k - 1) {\n      return false;\n    }\n  }\n  for (int u : g[v]) {\n    if (u == p) continue;\n    S[v].erase(S[v].find(h[u] + 1));\n    h[v] = get_max(S[v]);\n    S[u].insert(h[v] + 1);\n    h[u] = get_max(S[u]);\n    if (!dfs_check(u, v, k)) return false;\n    S[u].erase(S[u].find(h[v] + 1));\n    h[u] = get_max(S[u]);\n    S[v].insert(h[u] + 1);\n    h[v] = get_max(S[v]);\n  }\n  return true;\n}\nint find_far(int v, int n, vector<int>& path) {\n  vector<int> dist(n, 0), par(n, v);\n  function<void(int, int)> dfs_dist = [&](int v, int p) {\n    for (int u : g[v]) {\n      if (u != p) {\n        par[u] = v;\n        dist[u] = dist[v] + 1;\n        dfs_dist(u, v);\n      }\n    }\n  };\n  dfs_dist(v, -1);\n  int res = 0;\n  for (int v = 1; v < n; ++v)\n    if (dist[v] > dist[res]) res = v;\n  path.clear();\n  for (int u = res; u != v; u = par[u]) path.push_back(u);\n  path.push_back(v);\n  return res;\n}\nint find_diam(int n, vector<int>& diam) {\n  int x = find_far(0, n, diam);\n  int y = find_far(x, n, diam);\n  return (int)(diam).size();\n}\nint main() {\n  int n, k;\n  scanf(\"%d %d\", &n, &k);\n  for (int i = 1; i < n; ++i) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    --u;\n    --v;\n    g[v].push_back(u);\n    g[u].push_back(v);\n  }\n  vector<int> c(n, -1);\n  function<void(int, int, int)> dfs_color = [&](int v, int p, int step) {\n    for (int u : g[v]) {\n      if (u != p) {\n        c[u] = (c[v] + step + k) % k;\n        dfs_color(u, v, step);\n      }\n    }\n  };\n  if (k == 2) {\n    c[0] = 0;\n    dfs_color(0, -1, 1);\n    printf(\"Yes\\n\");\n    for (int i = 0; i < n; ++i) printf(\"%d \", c[i] + 1);\n    printf(\"\\n\");\n    return 0;\n  }\n  dfs_h(0, -1);\n  if (!dfs_check(0, -1, k)) {\n    printf(\"No\\n\");\n    return 0;\n  }\n  printf(\"Yes\\n\");\n  vector<int> diam;\n  int d = find_diam(n, diam);\n  int p = diam[d / 2 - 1], q = diam[d / 2];\n  c[p] = 0;\n  c[q] = 1;\n  dfs_color(p, q, -1);\n  dfs_color(q, p, 1);\n  for (int i = 0; i < n; ++i) printf(\"%d \", c[i] + 1);\n  printf(\"\\n\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\ninline void NO() {\n  cout << \"No\\n\";\n  exit(0);\n}\nconst int N = 2e5 + 10;\nint n, k;\nint col[N];\nvoid YES() {\n  cout << \"Yes\\n\";\n  for (int u = 0; u < n; u++) {\n    cout << (col[u] + 1) << ' ';\n  }\n  cout << '\\n';\n  exit(0);\n}\nvector<int> adj[N];\nint dep[N];\nvoid compute_dep(int u, int p = -1, int d = 0) {\n  dep[u] = d;\n  for (int v : adj[u]) {\n    if (v == p) continue;\n    compute_dep(v, u, d + 1);\n  }\n}\nint cdep[N], ht[N];\nvoid compute_cdep(int u, int p = -1) {\n  cdep[u] = dep[u];\n  ht[u] = 1;\n  for (int v : adj[u]) {\n    if (v == p) continue;\n    compute_cdep(v, u);\n    cdep[u] = max(cdep[u], cdep[v]);\n    ht[u] = max(ht[u], 1 + ht[v]);\n  }\n}\nvoid assign_col(int u, int p = -1, int c = -1) {\n  if (col[u] == -1) {\n    col[u] = c;\n  } else {\n    c = col[u];\n  }\n  for (int v : adj[u]) {\n    if (v == p) continue;\n    assign_col(v, u, (c - 1 + k) % k);\n  }\n}\nvoid check(int u, int p = -1) {\n  int inc[] = {0, 0}, dec[] = {0, 0};\n  for (int v : adj[u]) {\n    if (v == p) continue;\n    check(v, u);\n    if (col[v] == (col[u] + 1) % k) {\n      if (ht[v] > inc[1]) inc[1] = ht[v];\n      if (inc[1] > inc[0]) swap(inc[1], inc[0]);\n    }\n    if (col[u] == (col[v] + 1) % k) {\n      if (ht[v] > dec[1]) dec[1] = ht[v];\n      if (dec[1] > dec[0]) swap(dec[1], dec[0]);\n    }\n  }\n  if (inc[1] > 0 && inc[0] + inc[1] + 1 >= k) {\n    NO();\n  }\n  if (dec[1] > 0 && dec[0] + dec[1] + 1 >= k) {\n    NO();\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> k;\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n    adj[u - 1].push_back(v - 1);\n    adj[v - 1].push_back(u - 1);\n  }\n  int root = 0;\n  compute_dep(root);\n  for (int u = 0; u < n; u++) {\n    if (dep[u] > dep[root]) root = u;\n  }\n  compute_dep(root);\n  int maxd = 0;\n  for (int u = 0; u < n; u++) {\n    maxd = max(maxd, dep[u]);\n  }\n  if (maxd + 1 < k) YES();\n  compute_cdep(root);\n  memset(col, -1, sizeof col);\n  for (int u = 0; u < n; u++) {\n    if (cdep[u] >= k - 1) {\n      col[u] = dep[u] % k;\n    }\n  }\n  assign_col(root);\n  if (k == 2) YES();\n  check(root);\n  YES();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = (int)1.01e9;\nconst long long infll = (long long)1.01e18;\nconst long double eps = 1e-9;\nconst long double pi = acos((long double)-1);\nmt19937 mrand(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int x) { return mrand() % x; }\nvoid precalc() {}\nconst int maxn = (int)2e5 + 5;\nint n, k;\nvector<int> g[maxn];\nbool read() {\n  if (scanf(\"%d%d\", &n, &k) < 2) {\n    return false;\n  }\n  for (int i = 0; i < n; i++) {\n    g[i].clear();\n  }\n  for (int i = 0; i < n - 1; i++) {\n    int v, u;\n    scanf(\"%d%d\", &v, &u);\n    v--;\n    u--;\n    g[v].push_back(u);\n    g[u].push_back(v);\n  }\n  return true;\n}\nint d[maxn];\nint getFurthest(int v, int p) {\n  d[v] = (p == -1 ? 0 : d[p] + 1);\n  int res = v;\n  for (int i = 0; i < ((int)(g[v]).size()); i++) {\n    int u = g[v][i];\n    if (u == p) {\n      continue;\n    }\n    int cur = getFurthest(u, v);\n    if (d[cur] > d[res]) {\n      res = cur;\n    }\n  }\n  return res;\n}\nbool getPath(int v, int p, int t, vector<int> &path) {\n  path.push_back(v);\n  if (v == t) {\n    return true;\n  }\n  for (int i = 0; i < ((int)(g[v]).size()); i++) {\n    int u = g[v][i];\n    if (u == p) {\n      continue;\n    }\n    if (getPath(u, v, t, path)) {\n      return true;\n    }\n  }\n  path.pop_back();\n  return false;\n}\nint dep[maxn][3];\nvoid getDep(int v, int p) {\n  dep[v][0] = 0;\n  dep[v][1] = -1;\n  dep[v][2] = -1;\n  for (int i = 0; i < ((int)(g[v]).size()); i++) {\n    int u = g[v][i];\n    if (u == p) {\n      continue;\n    }\n    getDep(u, v);\n    if (dep[u][0] + 1 > dep[v][0]) {\n      dep[v][2] = dep[v][1];\n      dep[v][1] = dep[v][0];\n      dep[v][0] = dep[u][0] + 1;\n    } else if (dep[u][0] + 1 > dep[v][1]) {\n      dep[v][2] = dep[v][1];\n      dep[v][1] = dep[u][0] + 1;\n    } else if (dep[u][0] + 1 > dep[v][2]) {\n      dep[v][2] = dep[u][0] + 1;\n    }\n  }\n}\nint col[maxn];\nbool paint(int v, int p, int dc) {\n  if (dep[v][1] > 0 && dep[v][0] + dep[v][1] >= k - 1) {\n    return false;\n  }\n  for (int i = 0; i < ((int)(g[v]).size()); i++) {\n    int u = g[v][i];\n    if (u == p) {\n      continue;\n    }\n    col[u] = (col[v] + dc) % k;\n    if (!paint(u, v, dc)) {\n      return false;\n    }\n  }\n  return true;\n}\nvoid dfs2(int v, int p) {\n  for (int i = 0; i < ((int)(g[v]).size()); i++) {\n    int u = g[v][i];\n    if (u == p) {\n      continue;\n    }\n    col[u] = (col[v] ^ 1);\n    dfs2(u, v);\n  }\n}\nvoid printAns() {\n  printf(\"Yes\\n\");\n  for (int i = 0; i < n; i++) {\n    printf(\"%d \", col[i] + 1);\n  }\n  printf(\"\\n\");\n}\nvoid solve() {\n  if (k == 2) {\n    col[0] = 0;\n    dfs2(0, -1);\n    printAns();\n    return;\n  }\n  int v = 0;\n  int u = getFurthest(v, -1);\n  v = getFurthest(u, -1);\n  vector<int> path;\n  getPath(v, -1, u, path);\n  if (!(((int)(path).size()) & 1)) {\n    v = path[((int)(path).size()) / 2 - 1];\n    u = path[((int)(path).size()) / 2];\n    col[v] = 0;\n    getDep(v, u);\n    if (!paint(v, u, 1)) {\n      printf(\"No\\n\");\n      return;\n    }\n    col[u] = k - 1;\n    getDep(u, v);\n    if (!paint(u, v, k - 1)) {\n      printf(\"No\\n\");\n      return;\n    }\n    printAns();\n    return;\n  }\n  v = path[((int)(path).size()) / 2];\n  getDep(v, -1);\n  assert(dep[v][0] == dep[v][1]);\n  if (dep[v][2] > 0 && dep[v][2] + dep[v][1] >= k - 1) {\n    printf(\"No\\n\");\n    return;\n  }\n  int b = 0;\n  col[v] = 0;\n  for (int i = 0; i < ((int)(g[v]).size()); i++) {\n    int u = g[v][i];\n    int dc;\n    if (dep[u][0] + 1 == dep[v][0]) {\n      dc = (!b ? 1 : k - 1);\n      b++;\n    } else {\n      dc = 1;\n    }\n    col[u] = (col[v] + dc) % k;\n    if (!paint(u, v, dc)) {\n      printf(\"No\\n\");\n      return;\n    }\n  }\n  printAns();\n}\nint main() {\n  precalc();\n  while (read()) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int maxn = 200005, maxm = maxn << 1;\nint n, m, e, s1, s2, s, maxx, col, flg, mid;\nint start[maxn], to[maxm], then[maxm], dep[maxn], f[maxn], ans[maxn],\n    flen[maxn], slen[maxn];\ninline void add(int x, int y) { then[++e] = start[x], start[x] = e, to[e] = y; }\nvoid dfs(int x, int last) {\n  f[x] = last, dep[x] = dep[last] + 1;\n  flen[x] = slen[x] = 0;\n  if (dep[x] > maxx) maxx = dep[x], s = x;\n  for (int i = start[x]; i; i = then[i]) {\n    int y = to[i];\n    if (y == last) continue;\n    dfs(y, x);\n  }\n}\nvoid getlen(int x, int last) {\n  for (int i = start[x]; i; i = then[i]) {\n    int y = to[i];\n    if (y == last || ans[y]) continue;\n    getlen(y, x);\n    if (flen[y] + 1 > flen[x])\n      slen[x] = flen[x], flen[x] = flen[y] + 1;\n    else if (flen[y] + 1 > slen[x])\n      slen[x] = flen[y] + 1;\n    if (slen[y] + 1 > slen[x]) slen[x] = slen[y] + 1;\n  }\n}\nvoid solve(int x, int c, int d, int t) {\n  ans[x] = c;\n  c = (c + t + m - 1) % m + 1;\n  for (int i = start[x]; i; i = then[i]) {\n    int y = to[i];\n    if (ans[y] != 0) continue;\n    solve(y, c, d + 1, t);\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i < n; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    add(x, y), add(y, x);\n  }\n  maxx = -1000000000, dfs(1, 0), s1 = s;\n  maxx = -1000000000, dfs(s, 0), s2 = s;\n  if (m == 2) {\n    puts(\"Yes\");\n    for (int i = 1; i <= n; i++)\n      printf(\"%d%c\", dep[i] % 2 + 1, i == n ? '\\n' : ' ');\n    return 0;\n  }\n  for (int i = s2; i != 0; i = f[i]) {\n    col = col % m + 1;\n    if ((dep[s1] + dep[s2]) / 2 == dep[i]) mid = i;\n    ans[i] = col;\n  }\n  for (int i = s2; i != 0; i = f[i]) {\n    getlen(i, 0);\n    if (ans[i] && flen[i] && dep[i] + flen[i] >= m &&\n        (dep[s2] - dep[i] + 1) + flen[i] >= m) {\n      puts(\"No\");\n      return 0;\n    }\n  }\n  for (int i = 1; i <= n; i++)\n    if (flen[i] + slen[i] + 1 >= m) {\n      puts(\"No\");\n      return 0;\n    }\n  for (int i = s2; i != mid; i = f[i]) solve(i, ans[i], 1, -1);\n  for (int i = mid; i != 0; i = f[i]) solve(i, ans[i], 1, 1);\n  puts(\"Yes\");\n  for (int i = 1; i <= n; i++) printf(\"%d%c\", ans[i], i == n ? '\\n' : ' ');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxN = 2e5 + 10;\nvector<int> adj[maxN];\nint n, k, a[maxN], h[maxN], parent[maxN], dp_down[maxN], dp_up[maxN];\nbool vis[maxN];\nvector<int> vc;\nvoid last_dfs(int v, int par = -1) {\n  vc.push_back(v);\n  for (auto u : adj[v]) {\n    if (u == par) continue;\n    h[u] = h[v] + 1;\n    last_dfs(u, v);\n  }\n}\nvoid dfs_down(int v, int par = -1) {\n  for (auto u : adj[v]) {\n    if (u == par) continue;\n    dfs_down(u, v);\n    dp_down[v] = max(dp_down[v], dp_down[u] + 1);\n  }\n}\nvoid dfs_up(int v, int par = -1) {\n  int mx1 = 1 + dp_up[v], mx2 = 0;\n  for (auto u : adj[v]) {\n    if (u == par) continue;\n    if (dp_down[u] + 2 > mx1)\n      mx2 = mx1, mx1 = dp_down[u] + 2;\n    else if (dp_down[u] + 2 > mx2)\n      mx2 = dp_down[u] + 2;\n  }\n  for (auto u : adj[v]) {\n    if (u == par) continue;\n    if (2 + dp_down[u] == mx1)\n      dp_up[u] = mx2;\n    else\n      dp_up[u] = mx1;\n  }\n  for (auto u : adj[v]) {\n    if (u == par) continue;\n    dfs_up(u, v);\n  }\n  mx1 = dp_up[v], mx2 = -1e9;\n  int mx3 = -1e9;\n  for (auto u : adj[v]) {\n    if (u == par) continue;\n    if (dp_down[u] + 1 > mx1)\n      mx3 = mx2, mx2 = mx1, mx1 = dp_down[u] + 1;\n    else if (dp_down[u] + 1 > mx2)\n      mx3 = mx2, mx2 = dp_down[u] + 1;\n    else if (dp_down[u] + 1 > mx3)\n      mx3 = dp_down[u] + 1;\n  }\n  if (mx2 + mx3 >= k - 1) {\n    cout << \"No\\n\";\n    exit(0);\n  }\n}\nvoid DFS(int v, int par = -1) {\n  parent[v] = par;\n  for (auto u : adj[v]) {\n    if (u == par) continue;\n    h[u] = h[v] + 1;\n    DFS(u, v);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> k;\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n    u--;\n    v--;\n    adj[v].push_back(u);\n    adj[u].push_back(v);\n  }\n  memset(h, 0, sizeof h);\n  DFS(0);\n  if (k <= 2) {\n    cout << \"Yes\\n\";\n    for (int i = 0; i < n; i++) cout << (h[i] % 2) + 1 << ' ';\n    cout << '\\n';\n    return 0;\n  }\n  int v1 = 0;\n  for (int i = 0; i < n; i++)\n    if (h[i] > h[v1]) v1 = i;\n  memset(h, 0, sizeof h);\n  DFS(v1);\n  int v2 = 0;\n  for (int i = 0; i < n; i++)\n    if (h[i] > h[v2]) v2 = i;\n  if (h[v2] + 1 < k) {\n    cout << \"Yes\\n\";\n    for (int i = 0; i < n; i++) cout << 1 << ' ';\n    cout << '\\n';\n    return 0;\n  }\n  vector<int> path;\n  int curr = v2;\n  while (true) {\n    path.push_back(curr);\n    if (curr == v1) break;\n    curr = parent[curr];\n  }\n  memset(h, 0, sizeof h);\n  int t = 0, len = path.size() - 1, l_len = 0;\n  for (auto v : path) {\n    vis[v] = true;\n    a[v] = t % k;\n    t++;\n  }\n  for (auto v : path) {\n    for (auto u : adj[v]) {\n      if (vis[u]) continue;\n      vc.clear();\n      h[u] = 0;\n      last_dfs(u, v);\n      int p = u;\n      for (auto x : vc)\n        if (h[x] > h[p]) p = x;\n      int tool = h[p] + 1;\n      if (tool + l_len >= k - 1 && tool + len - l_len >= k - 1)\n        return cout << \"No\\n\", 0;\n      if (tool + l_len >= k - 1) {\n        for (auto x : vc) a[x] = (l_len + h[x] + 1) % k;\n      } else {\n        for (auto x : vc) a[x] = (l_len - h[x] % k - 1 + 2 * k) % k;\n      }\n    }\n    l_len++;\n  }\n  cout << \"Yes\\n\";\n  for (int i = 0; i < n; i++) cout << a[i] + 1 << ' ';\n  cout << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5;\nint n, k;\nvector<int> g[N];\nvoid scan() {\n  cin >> n >> k;\n  for (int i = 0; i < n - 1; ++i) {\n    int v, u;\n    cin >> v >> u;\n    --v, --u;\n    g[v].push_back(u);\n    g[u].push_back(v);\n  }\n}\nint d[N];\nvoid dfs1(int v, int last) {\n  for (int u : g[v]) {\n    if (u != last) {\n      d[u] = d[v] + 1;\n      dfs1(u, v);\n    }\n  }\n}\nint mxd = 0;\nint get_root() {\n  dfs1(0, 0);\n  int res = 0;\n  for (int v = 0; v < n; ++v) {\n    if (d[v] > d[res]) {\n      res = v;\n    }\n  }\n  mxd = d[res] + 1;\n  return res;\n}\nint c[N];\nbool ch[N];\nvoid dfs2(int v, int last, int depth) {\n  vector<int> arr;\n  if (v != last) {\n    ch[v] = true;\n  }\n  for (int u : g[v]) {\n    if (u != last) {\n      dfs2(u, v, depth + 1);\n      arr.push_back(d[u]);\n    }\n  }\n  sort(arr.begin(), arr.end(), greater<int>());\n  if (arr.size() >= 2 && arr[0] + arr[1] + 3 >= k &&\n      depth + 1 + arr[1] + 1 >= k && k > 2) {\n    cout << \"No\\n\";\n    exit(0);\n  } else if (!arr.empty()) {\n    d[v] = arr[0] + 1;\n  } else {\n    d[v] = 0;\n  }\n  if (d[v] + depth + 1 >= k) {\n    ch[v] = false;\n  }\n}\nvoid dfs3(int v, int last, int depth) {\n  if (ch[v]) {\n    c[v] = (c[last] - 1 + k) % k;\n  } else {\n    c[v] = depth % k;\n  }\n  for (int u : g[v]) {\n    if (u != last) {\n      dfs3(u, v, depth + 1);\n    }\n  }\n}\nvoid solve() {\n  int root = get_root();\n  dfs2(root, root, 0);\n  dfs3(root, root, 0);\n}\nvoid print_ans() {\n  cout << \"Yes\\n\";\n  for (int v = 0; v < n; ++v) {\n    cout << c[v] + 1 << ' ';\n  }\n  cout << '\\n';\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  scan();\n  solve();\n  print_ans();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct zero {\n  int nxt, to;\n} edge[210000 << 1];\nint head[210000], tot = 0;\nint n, k, ans[210000];\nint plk, poi, f[210000], dep[210000], kl[210000];\nbool vis[210000];\nvoid add_edge(int a, int b) {\n  edge[++tot] = (zero){head[a], b};\n  head[a] = tot;\n}\nvoid dfspl(int x, int fa) {\n  for (int i = head[x]; i; i = edge[i].nxt) {\n    int to = edge[i].to;\n    if (to == fa) continue;\n    ans[to] = 3 - ans[x];\n    dfspl(to, x);\n  }\n}\nvoid aux(int x, int fa) {\n  if (dep[x] > dep[plk]) plk = x;\n  for (int i = head[x]; i; i = edge[i].nxt) {\n    int to = edge[i].to;\n    if (to == fa) continue;\n    dep[to] = dep[x] + 1;\n    aux(to, x);\n  }\n}\nvoid dfs1(int x, int fa) {\n  if (dep[x] > dep[poi]) poi = x;\n  kl[x] = dep[x];\n  for (int i = head[x]; i; i = edge[i].nxt) {\n    int to = edge[i].to;\n    if (to == fa) continue;\n    dep[to] = dep[x] + 1, f[to] = x;\n    dfs1(to, x);\n    kl[x] = max(kl[x], kl[to]);\n  }\n}\nvoid solve(int x, int now, int op) {\n  ans[x] = now;\n  for (int i = head[x]; i; i = edge[i].nxt) {\n    int to = edge[i].to;\n    if (vis[to] || to == f[x]) continue;\n    solve(to, (now + op - 1 + k) % k + 1, op);\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i < n; i++) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    add_edge(a, b), add_edge(b, a);\n  }\n  if (k == 2) {\n    ans[1] = 1;\n    dfspl(1, 0);\n    puts(\"Yes\");\n    for (int i = 1; i <= n; i++) printf(\"%d \", ans[i]);\n    return 0;\n  }\n  dep[1] = 1, plk = 1;\n  aux(1, 0);\n  dep[plk] = 1, poi = plk;\n  dfs1(plk, 0);\n  int poss = poi;\n  int cnt = 1;\n  while (poss) {\n    vis[poss] = true;\n    ans[poss] = cnt;\n    for (int i = head[poss]; i; i = edge[i].nxt) {\n      int to = edge[i].to;\n      if (to == f[poss] || vis[to]) continue;\n      if (kl[to] >= k && (kl[to] + dep[poi] - 2 * dep[poss] + 1 >= k))\n        return puts(\"NO\"), 0;\n      if (kl[to] >= k)\n        solve(to, (cnt + k - 2) % k + 1, -1);\n      else\n        solve(to, cnt % k + 1, 1);\n    }\n    cnt = cnt % k + 1;\n    poss = f[poss];\n  }\n  puts(\"Yes\");\n  for (int i = 1; i <= n; i++) printf(\"%d \", ans[i]);\n  puts(\"\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nvector<int> adjList[200000];\nint parent[200000], dist[200000];\nint doDFS(int u, int p, int d) {\n  int i;\n  parent[u] = p, dist[u] = d;\n  for (i = 0; i < adjList[u].size(); i++) {\n    int v = adjList[u][i];\n    if (v != p) doDFS(v, u, d + 1);\n  }\n  return 0;\n}\nint ans[200000];\nvector<int> diam;\nint no[200000];\nint doDFS2(int u, int p, int x, int y) {\n  int i;\n  ans[u] = x;\n  for (i = 0; i < adjList[u].size(); i++) {\n    int v = adjList[u][i];\n    if (no[v]) continue;\n    if (v != p) doDFS2(v, u, (x + y + k) % k, y);\n  }\n  return 0;\n}\nint height[200000], height2[200000];\nint doDFS3(int u, int p) {\n  int i;\n  parent[u] = p, height[u] = 0;\n  for (i = 0; i < adjList[u].size(); i++) {\n    int v = adjList[u][i];\n    if (v != p) height[u] = max(height[u], doDFS3(v, u) + 1);\n  }\n  return height[u];\n}\nint doDFS4(int u, int p, int h) {\n  int i;\n  int m1 = 0, m2 = 0, mi = -1;\n  height2[u] = h;\n  for (i = 0; i < adjList[u].size(); i++) {\n    int v = adjList[u][i];\n    if (v != p) {\n      if (height[v] + 1 >= m1)\n        m2 = m1, m1 = height[v] + 1, mi = v;\n      else if (height[v] + 1 >= m2)\n        m2 = height[v] + 1;\n    }\n  }\n  for (i = 0; i < adjList[u].size(); i++) {\n    int v = adjList[u][i];\n    if (v != p) {\n      if (v == mi)\n        doDFS4(v, u, max(h + 1, m2 + 1));\n      else\n        doDFS4(v, u, max(h + 1, m1 + 1));\n    }\n  }\n  return 0;\n}\nint main() {\n  int i;\n  int u, v;\n  scanf(\"%d %d\", &n, &k);\n  for (i = 0; i < n - 1; i++) {\n    scanf(\"%d %d\", &u, &v);\n    u--, v--;\n    adjList[u].push_back(v);\n    adjList[v].push_back(u);\n  }\n  doDFS(0, -1, 0);\n  int mi = 0;\n  for (i = 0; i < n; i++) {\n    if (dist[i] > dist[mi]) mi = i;\n  }\n  int a = mi;\n  doDFS(a, -1, 0);\n  mi = 0;\n  for (i = 0; i < n; i++) {\n    if (dist[i] > dist[mi]) mi = i;\n  }\n  int b = mi;\n  u = b;\n  int j, c = 0;\n  fill(ans, ans + n, -1);\n  while (u != -1)\n    ans[u] = c, c = (c + 1) % k, diam.push_back(u), no[u] = 1, u = parent[u];\n  ;\n  for (i = 0; i < diam.size(); i++) {\n    if (i < diam.size() / 2)\n      doDFS2(diam[i], -1, ans[diam[i]], -1);\n    else\n      doDFS2(diam[i], -1, ans[diam[i]], 1);\n  }\n  int f = 0;\n  doDFS3(0, -1), doDFS4(0, -1, 0);\n  if (k > 2) {\n    for (i = 0; i < n; i++) {\n      int m1 = height2[i], m2 = 0, m3 = 0;\n      for (j = 0; j < adjList[i].size(); j++) {\n        int v = adjList[i][j];\n        if (v != parent[i]) {\n          int h = height[v] + 1;\n          if (h >= m1)\n            m3 = m2, m2 = m1, m1 = h;\n          else if (h >= m2)\n            m3 = m2, m2 = h;\n          else if (h >= m3)\n            m3 = h;\n        }\n      }\n      if (m1 == 0) m1 = -1e9;\n      if (m2 == 0) m2 = -1e9;\n      if (m3 == 0) m3 = -1e9;\n      if (m2 + m3 + 1 >= k) break;\n    }\n    if (i < n) f = 1;\n  }\n  if (f)\n    printf(\"No\\n\");\n  else {\n    printf(\"Yes\\n\");\n    for (i = 0; i < n; i++)\n      printf(\"%d%c\", ans[i] + 1, (i == n - 1) ? '\\n' : ' ');\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> adj[200005];\nint d[200005], mx[200005];\nint c1[200005], c2[200005];\nint dfs(int v, int p) {\n  d[v] = mx[v] = d[p] + 1;\n  int u = v;\n  for (int& x : adj[v]) {\n    if (x != p) {\n      int t = dfs(x, v);\n      mx[v] = max(mx[v], mx[x]);\n      if (d[t] > d[u]) u = t;\n    }\n  }\n  return u;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n  int n, k;\n  cin >> n >> k;\n  for (int i = 1; i < n; i++) {\n    int v, u;\n    cin >> v >> u;\n    adj[v].push_back(u);\n    adj[u].push_back(v);\n  }\n  int v = dfs(1, 0);\n  int u = dfs(v, 0);\n  int dia = d[u];\n  for (int i = 1; i <= n; i++) {\n    if (mx[i] >= k) c1[i] = (d[i] - 1) % k + 1;\n  }\n  dfs(u, 0);\n  for (int i = 1; i <= n; i++) {\n    if (mx[i] >= k) c2[i] = (dia - d[i]) % k + 1;\n  }\n  for (int i = 1; i <= n; i++) {\n    if (c1[i] && c2[i] && c1[i] != c2[i]) {\n      cout << \"No\";\n      return 0;\n    }\n  }\n  cout << \"Yes\\n\";\n  for (int i = 1; i <= n; i++) {\n    if (c1[i] + c2[i] == 0)\n      cout << rng() % k + 1 << ' ';\n    else\n      cout << max(c1[i], c2[i]) << ' ';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000007;\nconst int MOD = 1000000007;\nconst int nmax = 201234;\nint n, k, s2[nmax], root, res[nmax], len[nmax];\nvector<int> v2[nmax];\npair<int, int> init(int s, int f, int h) {\n  pair<int, int> ans = {h, s};\n  for (int i = 0; i < v2[s].size(); ++i) {\n    int pos = v2[s][i];\n    if (pos != f) {\n      pair<int, int> tmp = init(pos, s, h + 1);\n      if (tmp.first > ans.first) ans = tmp;\n    }\n  }\n  return ans;\n}\nint dfs(int s, int f, int h) {\n  int h2 = h;\n  for (int i = 0; i < v2[s].size(); ++i) {\n    int pos = v2[s][i];\n    if (pos != f) {\n      int tmp = dfs(pos, s, h + 1);\n      if (tmp > h2) {\n        h2 = tmp;\n        s2[s] = pos;\n      }\n    }\n  }\n  len[s] = h2 - h;\n  return h2;\n}\nbool check(int s, int f, int h) {\n  if (s2[s] == 0) return 1;\n  int tmp = max(h, len[s2[s]]) + 1;\n  for (int i = 0; i < v2[s].size(); ++i) {\n    int pos = v2[s][i];\n    if (pos != f && pos != s2[s] && tmp + len[pos] + 1 >= k) return 0;\n  }\n  if (!check(s2[s], s, h + 1)) return 0;\n  return 1;\n}\nvoid dfs3(int s, int f, int h, int v) {\n  res[s] = h % k;\n  for (int i = 0; i < v2[s].size(); ++i) {\n    int pos = v2[s][i];\n    if (pos != f) dfs3(pos, s, h + v, v);\n  }\n}\nbool dfs2(int s, int f, int h) {\n  res[s] = h % k;\n  if (s2[s] != 0)\n    if (!dfs2(s2[s], s, h + 1)) return 0;\n  for (int i = 0; i < v2[s].size(); ++i) {\n    int pos = v2[s][i];\n    if (pos != f && pos != s2[s]) {\n      if (len[pos] + 2 + h >= k && len[pos] + 2 + len[root] - h >= k)\n        return 0;\n      else if (!check(pos, s, 0))\n        return 0;\n      else if (len[pos] + 2 + h >= k)\n        dfs3(pos, s, h + 1, 1);\n      else if (len[pos] + 2 + len[root] - h >= k)\n        dfs3(pos, s, h - 1, -1);\n      else\n        dfs3(pos, s, 0, 0);\n    }\n  }\n  return 1;\n}\nvoid dfs4(int s, int f, int v) {\n  res[s] = v;\n  for (int i = 0; i < v2[s].size(); ++i) {\n    int pos = v2[s][i];\n    if (pos != f) dfs4(pos, s, 1 - v);\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int u, v, i = 1; i < n; ++i) {\n    scanf(\"%d%d\", &u, &v);\n    v2[u].push_back(v);\n    v2[v].push_back(u);\n  }\n  int flg = 1;\n  if (k == 2)\n    dfs4(1, 0, 0);\n  else {\n    root = init(1, 0, 0).second;\n    dfs(root, 0, 0);\n    flg = dfs2(root, 0, 0);\n  }\n  if (flg == 0)\n    puts(\"No\");\n  else {\n    puts(\"Yes\");\n    for (int i = 1; i <= n; ++i)\n      printf(\"%d%c\", res[i] + 1, i == n ? '\\n' : ' ');\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid Max(int &x, int y) { x = max(x, y); }\nvoid Min(int &x, int y) { x = min(x, y); }\nconst int N = 2e5 + 5;\ntemplate <class T1, class T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &a) {\n  return os << '(' << a.first << \", \" << a.second << ')';\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &a) {\n  os << '[';\n  for (unsigned int i = 0; i < a.size(); i++)\n    os << a[i] << (i < a.size() - 1 ? \", \" : \"\");\n  os << ']';\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const deque<T> &a) {\n  os << '[';\n  for (unsigned int i = 0; i < a.size(); i++)\n    os << a[i] << (i < a.size() - 1 ? \", \" : \"\");\n  os << ']';\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const set<T> &a) {\n  os << '{';\n  for (typename set<T>::iterator it = a.begin(); it != a.end(); it++) {\n    typename set<T>::iterator jt = it;\n    os << *it << (++jt != a.end() ? \", \" : \"\");\n  }\n  os << '}';\n  return os;\n}\ntemplate <class T1, class T2>\nostream &operator<<(ostream &os, map<T1, T2> &a) {\n  os << \"{\\n\";\n  for (typename map<T1, T2>::iterator it = a.begin(); it != a.end(); it++) {\n    typename map<T1, T2>::iterator jt = it;\n    os << \"  \" << it->first << \": \" << it->second\n       << (++jt != a.end() ? \",\\n\" : \"\\n\");\n  }\n  os << '}';\n  return os;\n}\nint n, length;\nvector<vector<int> > a(N);\nint par[N];\nint maxDepth[N];\nvoid dfs(int u, int p, int depth, pair<int, int> &farthest) {\n  par[u] = p;\n  farthest = max(farthest, make_pair(depth + 1, u));\n  for (auto v : a[u]) {\n    if (v == p) continue;\n    dfs(v, u, depth + 1, farthest);\n  }\n}\nvoid pdfs(int u, int p) {\n  maxDepth[u] = 1;\n  for (auto v : a[u]) {\n    if (v == p) continue;\n    pdfs(v, u);\n    maxDepth[u] = max(maxDepth[u], maxDepth[v] + 1);\n  }\n}\nvoid checkdfs(int u, int p, int depth) {\n  vector<pair<int, int> > ad;\n  for (auto v : a[u]) {\n    if (v == p) continue;\n    ad.push_back(make_pair(maxDepth[v], v));\n  }\n  sort(ad.begin(), ad.end(), greater<pair<int, int> >());\n  for (auto v : a[u]) {\n    if (v == p) continue;\n    if (v == ad.front().second) {\n      int other = 0;\n      if (ad.size() >= 2) other = ad[1].first;\n      checkdfs(v, u, max(depth, other) + 1);\n    } else {\n      checkdfs(v, u, max(depth, ad.front().first) + 1);\n    }\n  }\n  if (depth != 0) ad.push_back(make_pair(depth, 0));\n  sort(ad.begin(), ad.end(), greater<pair<int, int> >());\n  if (ad.size() >= 3) {\n    if (ad[1].first + ad[2].first + 1 >= length) {\n      cout << \"No\" << '\\n';\n      exit(0);\n    }\n  }\n}\nint color[N];\nset<int> unused;\ndeque<int> dq;\nvoid addFront(int u) {\n  unused.erase(color[u]);\n  dq.push_front(u);\n};\nvoid addBack(int u) {\n  unused.erase(color[u]);\n  dq.push_back(u);\n};\nvoid popFront() {\n  unused.insert(color[dq.front()]);\n  dq.pop_front();\n};\nint popBack() {\n  int ret = dq.back();\n  unused.insert(color[ret]);\n  dq.pop_back();\n  return ret;\n};\nvoid dfsColor(int u, int p) {\n  int whPopBack = -1;\n  assert(dq.size() <= length);\n  if (dq.size() == length) whPopBack = popBack();\n  color[u] = *unused.begin();\n  addFront(u);\n  for (auto v : a[u]) {\n    if (v != p) dfsColor(v, u);\n  }\n  popFront();\n  if (whPopBack != -1) addBack(whPopBack);\n}\nvoid solve(vector<int> arr) {\n  int d = arr.size();\n  memset(color, -1, sizeof(color));\n  int tick = 0;\n  for (auto &u : arr) {\n    color[u] = tick;\n    tick = (tick + 1) % length;\n  }\n  auto doColor = [&](int l, int r) {\n    unused.clear();\n    dq.clear();\n    for (signed i = (0); i <= (length - 1); i++) unused.insert(i);\n    int iter = min((int)arr.size() - 1, l + length - 1);\n    for (signed i = (l); i <= (iter); i++) addBack(arr[i]);\n    for (signed i = (l); i <= (r); i++) {\n      if (i != l) {\n        popFront();\n        if (iter + 1 < arr.size()) iter++, addBack(arr[iter]);\n      }\n      for (auto v : a[arr[i]])\n        if (color[v] == -1) dfsColor(v, arr[i]);\n    }\n  };\n  doColor(0, (d + 1) / 2 - 1);\n  reverse(arr.begin(), arr.end());\n  doColor(0, (d + 1) / 2 - 1);\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  memset(color, -1, sizeof(color));\n  cin >> n >> length;\n  for (signed i = (1); i <= (n - 1); i++) {\n    int u, v;\n    cin >> u >> v;\n    a[u].push_back(v);\n    a[v].push_back(u);\n  }\n  pdfs(1, 1);\n  if (length > 2) {\n    checkdfs(1, 1, 0);\n  }\n  pair<int, int> farthest = make_pair(0, 1);\n  dfs(1, 1, 0, farthest);\n  int piv = farthest.second;\n  farthest = make_pair(0, piv);\n  dfs(piv, piv, 0, farthest);\n  piv = farthest.second;\n  vector<int> b;\n  b.push_back(piv);\n  while (par[piv] != piv) {\n    piv = par[piv];\n    b.push_back(piv);\n  }\n  solve(b);\n  cout << \"Yes\" << '\\n';\n  for (signed i = (1); i <= (n); i++) {\n    assert(color[i] != -1);\n    cout << color[i] + 1 << ' ';\n  }\n  cout << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\nint n, k, k1, fa[N], c[N], mx[N], q[N], d[N];\nint mxx, rt1, rt2;\nbool in[N];\nvector<int> g[N];\nvoid fail() {\n  printf(\"No\\n\");\n  exit(0);\n}\nvoid dfs(int x, int d, int f = -1) {\n  if (d > mxx) mxx = d, rt2 = x;\n  for (int i = 0; i < g[x].size(); ++i)\n    if (g[x][i] != f) {\n      dfs(g[x][i], d + 1, x);\n    }\n}\nvoid dfs1(int x) {\n  for (int i = 0; i < g[x].size(); ++i)\n    if (g[x][i] != fa[x]) {\n      int y = g[x][i];\n      fa[y] = x;\n      d[y] = d[x] + 1;\n      dfs1(y);\n    }\n}\nvoid dfs2(int x) {\n  mx[x] = !in[x];\n  for (int i = 0; i < g[x].size(); ++i)\n    if (g[x][i] != fa[x]) {\n      int y = g[x][i];\n      dfs2(y);\n      mx[x] = max(mx[x], mx[y] + (!in[x]));\n    }\n}\nvoid dfs3(int x, int d) {\n  if (d == 1 || d == -1)\n    c[x] = (c[fa[x]] + d + k) % k;\n  else\n    c[x] = 0;\n  for (int i = 0; i < g[x].size(); ++i)\n    if (g[x][i] != fa[x] && !in[g[x][i]]) {\n      int y = g[x][i];\n      dfs3(y, d);\n    }\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1, x, y; i < n; ++i) {\n    scanf(\"%d%d\", &x, &y);\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  dfs(1, 0);\n  rt1 = rt2;\n  mxx = 0;\n  dfs(rt1, 0);\n  dfs1(rt1);\n  for (int x = rt2;; x = fa[x]) {\n    c[x] = k1++;\n    k1 %= k;\n    in[x] = 1;\n    q[++q[0]] = x;\n    if (x == rt1) break;\n  }\n  dfs2(rt1);\n  if (k == 1) {\n    printf(\"Yes\\n\");\n    for (int i = 1; i <= n; ++i) printf(\"%d \", 1);\n    return 0;\n  }\n  if (k == 2) {\n    printf(\"Yes\\n\");\n    for (int i = 1; i <= n; ++i) printf(\"%d \", (d[i] & 1) + 1);\n    return 0;\n  }\n  for (int t = 1; t <= q[0]; ++t) {\n    int x = q[t];\n    for (int i = 0; i < g[x].size(); ++i)\n      if (g[x][i] != fa[x] && !in[g[x][i]]) {\n        int y = g[x][i];\n        int a1 = mx[y] + t;\n        int a2 = mx[y] + q[0] - t + 1;\n        if (a1 >= k && a2 >= k)\n          fail();\n        else if (a1 == a2)\n          dfs(y, k - 1);\n        else\n          dfs3(y, (t <= (q[0] + 1) / 2) ? -1 : 1);\n      }\n  }\n  printf(\"Yes\\n\");\n  for (int i = 1; i <= n; ++i) printf(\"%d \", c[i] + 1);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid failure() {\n  cout << \"No\" << endl;\n  exit(0);\n}\nconst int MAX_N = 2e5 + 5;\nvector<int> adj[MAX_N];\nint longdown[MAX_N];\nvoid calc_longdown(int u, int p) {\n  for (int nxt : adj[u]) {\n    if (nxt != p) {\n      calc_longdown(nxt, u);\n      longdown[u] = max(longdown[u], 1 + longdown[nxt]);\n    }\n  }\n}\nint longup[MAX_N];\nvoid calc_longup(int u, int p) {\n  vector<pair<int, int>> diams;\n  diams.push_back(make_pair(1 + longup[u], -1));\n  for (int nxt : adj[u]) {\n    if (nxt != p) {\n      diams.push_back(make_pair(2 + longdown[nxt], nxt));\n    }\n  }\n  sort(diams.begin(), diams.end(), greater<pair<int, int>>());\n  for (int nxt : adj[u]) {\n    if (nxt != p) {\n      if (diams[0].second == nxt) {\n        longup[nxt] = diams[1].first;\n      } else {\n        longup[nxt] = diams[0].first;\n      }\n      calc_longup(nxt, u);\n    }\n  }\n}\nint K;\nvoid check(int u, int p) {\n  vector<pair<int, int>> paths;\n  if (p != 0) {\n    paths.push_back(make_pair(longup[u], p));\n  }\n  for (int nxt : adj[u]) {\n    if (nxt != p) {\n      paths.push_back(make_pair(1 + longdown[nxt], nxt));\n    }\n  }\n  if ((int)paths.size() >= 3) {\n    sort(paths.begin(), paths.end(), greater<pair<int, int>>());\n    if (paths[0].first + paths[1].first >= K - 1 &&\n        paths[0].first + paths[2].first >= K - 1 &&\n        paths[1].first + paths[2].first >= K - 1) {\n      failure();\n    }\n  }\n  for (int nxt : adj[u]) {\n    if (nxt != p) {\n      check(nxt, u);\n    }\n  }\n}\nint ans[MAX_N];\nvoid dfs2(int u, int p) {\n  ans[u] = !ans[p];\n  for (int nxt : adj[u]) {\n    if (nxt != p) {\n      dfs2(nxt, u);\n    }\n  }\n}\nvoid get_longds(int u, int p, vector<int> &longds) {\n  for (int nxt : adj[u]) {\n    if (nxt != p) {\n      get_longds(nxt, u, longds);\n      longds[u] = max(longds[u], 1 + longds[nxt]);\n    }\n  }\n}\npair<int, int> get_ans(int u, int p, int cur, int depth, int dir,\n                       const vector<int> &longds) {\n  ans[u] = cur;\n  auto maxd = make_pair(depth, u);\n  for (int nxt : adj[u]) {\n    if (nxt != p) {\n      if (depth + longds[nxt] + 1 >= K - 1) {\n        maxd = max(\n            maxd, get_ans(nxt, u, (cur + dir + K) % K, depth + 1, dir, longds));\n      }\n    }\n  }\n  return maxd;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  int n;\n  cin >> n >> K;\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  if (K == 2) {\n    dfs2(1, 0);\n    cout << \"Yes\" << endl;\n    for (int i = 1; i <= n; i++) {\n      cout << 1 + ans[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n  }\n  calc_longdown(1, 0);\n  calc_longup(1, 0);\n  check(1, 0);\n  pair<int, int> ra = make_pair(-1, 0);\n  for (int i = 1; i <= n; i++) {\n    ra = max(ra, make_pair(longup[i], i));\n  }\n  int root_a = ra.second;\n  vector<int> longds_a(n + 1, 0);\n  get_longds(root_a, 0, longds_a);\n  int root_b = get_ans(root_a, 0, 0, 0, 1, longds_a).second;\n  vector<int> longds_b(n + 1, 0);\n  get_longds(root_b, 0, longds_b);\n  get_ans(root_b, 0, ans[root_b], 0, -1, longds_b);\n  cout << \"Yes\" << endl;\n  for (int i = 1; i <= n; i++) {\n    cout << 1 + ans[i] << \" \";\n  }\n  cout << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5;\nint n, k;\nvector<int> gr[1 + N];\nint depth[2][1 + N];\nint nr;\nint maxleaf, mx;\nint ans[1 + N];\nvoid dfs(int node, int dad) {\n  for (auto son : gr[node]) {\n    if (son != dad) {\n      depth[nr][son] = depth[nr][node] + 1;\n      if (depth[nr][son] > mx) {\n        mx = depth[nr][son];\n        maxleaf = son;\n      }\n      dfs(son, node);\n    }\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  for (int i = 1; i < n; i++) {\n    int x, y;\n    cin >> x >> y;\n    gr[x].push_back(y);\n    gr[y].push_back(x);\n  }\n  maxleaf = mx = 0;\n  nr = 0;\n  dfs(1, -1);\n  memset(depth, 0, sizeof(depth));\n  int x = maxleaf;\n  nr = 0;\n  mx = 0;\n  dfs(x, -1);\n  int y = maxleaf;\n  mx = 1;\n  nr = 1;\n  dfs(y, -1);\n  for (int i = 1; i <= n; i++)\n    if (depth[0][i] + 1 >= k && depth[1][i] + 1 >= k && k > 2 &&\n        depth[0][i] + depth[1][i] != depth[0][y]) {\n      cout << \"No\\n\";\n      return 0;\n    }\n  for (int i = 1; i <= n; i++)\n    if (depth[0][i] > depth[1][i])\n      ans[i] = depth[0][i] % k + 1;\n    else\n      ans[i] = ((depth[0][y] - depth[1][i]) % k + k) % k + 1;\n  cout << \"Yes\\n\";\n  for (int i = 1; i <= n; i++) cout << ans[i] << \" \";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 200005;\nusing namespace std;\nint n, k, to[N << 1], hd[N << 1], lk[N], cnt, mx[N], dep[N], rt, bot, ans[N];\ninline void add(int u, int v) { to[++cnt] = v, hd[cnt] = lk[u], lk[u] = cnt; }\nint u, v;\nvoid dfs(int x, int y = 0) {\n  dep[x] = dep[y] + 1, mx[x] = x;\n  for (int s, i = lk[x]; i; i = hd[i])\n    if ((s = to[i]) ^ y) {\n      dfs(s, x);\n      if (dep[mx[s]] > dep[mx[x]]) mx[x] = mx[s];\n    }\n}\nvoid dfss(int x, int y = 0, int dis = 0) {\n  if (mx[x] != bot && mx[y] == bot) dis = dep[y];\n  if (mx[x] != bot && dis << 1 <= dep[bot])\n    (ans[x] = ans[y] - 1) ? 0 : ans[x] = k;\n  else\n    (ans[x] = ans[y] + 1) > k ? ans[x] = 1 : 0;\n  int fi = 0, se = 0;\n  for (int s, i = lk[x]; i; i = hd[i])\n    if ((s = to[i]) ^ y) {\n      dfss(s, x, dis);\n      if (dep[mx[s]] > fi)\n        se = fi, fi = dep[mx[s]];\n      else if (dep[mx[s]] > se)\n        se = dep[mx[s]];\n    }\n  if (fi && se && y && k > 2) {\n    if (mx[x] != bot && dis << 1 <= dep[bot])\n      dis = dep[x] + dep[bot] - 2 * dis;\n    else\n      dis = dep[x] - 1;\n    fi -= dep[x], se -= dep[x];\n    if (fi + dis >= k - 1 && se + dis >= k - 1 && fi + se >= k - 1)\n      puts(\"No\"), exit(0);\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i < n; i++) scanf(\"%d%d\", &u, &v), add(u, v), add(v, u);\n  dfs(1), dfs(rt = mx[1]);\n  bot = mx[rt], dfss(rt);\n  puts(\"Yes\");\n  for (int i = 1; i <= n; i++) printf(\"%d \", ans[i]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 100;\nint ans[N], n, k;\nvector<int> g[N];\nvector<int> *vs[N];\nint last[N], par[N];\npair<int, int> maxPath[N][2];\nvector<pair<int, int> > todo;\nint p(int v) { return par[v] == v ? v : par[v] = p(par[v]); }\nvoid merge(int v, int u) {\n  v = p(v);\n  u = p(u);\n  par[v] = u;\n}\nvoid dfsBin(int v, int pp) {\n  ans[v] = 1 - ans[pp];\n  for (int to : g[v]) {\n    if (to != pp) {\n      dfsBin(to, v);\n    }\n  }\n}\nvoid dfsMax(int v, int pp) {\n  maxPath[v][0] = maxPath[v][1] = make_pair(1, -1);\n  for (int to : g[v]) {\n    if (to != pp) {\n      dfsMax(to, v);\n      int len = maxPath[to][0].first + 1;\n      if (len > maxPath[v][0].first) {\n        maxPath[v][1] = maxPath[v][0];\n        maxPath[v][0] = make_pair(len, to);\n      } else if (len > maxPath[v][1].first) {\n        maxPath[v][1] = make_pair(len, to);\n      }\n    }\n  }\n}\nbool cmp(int a, int b) { return maxPath[a][0].first > maxPath[b][0].first; }\nvoid dfs(int v, int pp, int maxLenUp) {\n  vs[v] = new vector<int>(0);\n  vs[v]->push_back(v);\n  last[v]++;\n  sort((g[v]).begin(), (g[v]).end(), &cmp);\n  int added = 0;\n  for (int i = 0; (i) < ((int)((g[v]).size())); ++i) {\n    int to = g[v][i];\n    if (to == pp) continue;\n    int maxLen = 0;\n    if (maxPath[v][0].second == to)\n      maxLen = max(maxLenUp + 1, maxPath[v][1].first);\n    else\n      maxLen = max(maxLenUp + 1, maxPath[v][0].first);\n    dfs(to, v, maxLen);\n    if (!added) {\n      added = 1;\n      vs[v] = vs[to];\n      last[v] = last[to] + 1;\n      vs[v]->push_back(v);\n      if (last[v] > k) {\n        merge((*vs[v])[last[v] - k - 1], v);\n      }\n    } else {\n      maxLen = maxLenUp + 1;\n      if (i + 1 < (int)((g[v]).size())) {\n        maxLen = max(maxLen, maxPath[g[v][i + 1]][0].first + 1);\n      }\n      if (last[v] + last[to] >= k) {\n        if (last[to] + maxLen >= k && maxLen > 1) {\n          cout << \"No\\n\";\n          exit(0);\n        }\n        int cur = last[v] - k;\n        for (int j = 0; (j) < (min(k, last[to])); ++j) {\n          if (cur >= 0) merge((*vs[to])[last[to] - 1 - j], (*vs[v])[cur]);\n          cur++;\n        }\n        todo.push_back(make_pair(v, to));\n      } else {\n        int cur = last[v] - 2;\n        for (int j = 0; (j) < (min(k, last[to])); ++j) {\n          merge((*vs[to])[last[to] - 1 - j], (*vs[v])[cur]);\n          cur--;\n        }\n      }\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> k;\n  for (int i = 0; (i) < (n - 1); ++i) {\n    int v, u;\n    cin >> v >> u;\n    v--, u--;\n    g[v].push_back(u);\n    g[u].push_back(v);\n  }\n  if (k == 2) {\n    cout << \"Yes\\n\";\n    dfsBin(0, 0);\n    for (int i = 0; (i) < (n); ++i) cout << ans[i] + 1 << \" \";\n    cout << '\\n';\n    return 0;\n  }\n  int root = 0;\n  dfsMax(root, root);\n  for (int i = 0; (i) < (n); ++i) par[i] = i;\n  dfs(root, root, 0);\n  for (int i = 0; (i) < (min(k, last[root])); ++i) {\n    ans[p((*vs[root])[last[root] - 1 - i])] = i + 1;\n  }\n  reverse((todo).begin(), (todo).end());\n  for (pair<int, int> vto : todo) {\n    int v = vto.first;\n    int to = vto.second;\n    int initColor = (ans[p(v)] - 2 + k) % k;\n    for (int i = 0; (i) < (min(k, last[to])); ++i) {\n      ans[p((*vs[to])[last[to] - 1 - i])] = ((initColor - i + k) % k) + 1;\n    }\n  }\n  cout << \"Yes\\n\";\n  for (int i = 0; (i) < (n); ++i) {\n    int anss = ans[p(i)];\n    assert(ans);\n    cout << anss << \" \";\n  }\n  cout << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nint par[200005], up[200005], h[200005];\nint m[200005], m1[200005], m2[200005];\nint ans[200005], color[200005];\nvector<int> adj[200005];\nbool z = 1;\nint a, b;\nint diam = 0;\nint check_dfs(int i, int p, int d) {\n  par[i] = p;\n  h[i] = d;\n  m[i] = m1[i] = m2[i] = -1;\n  for (auto j : adj[i])\n    if (j != p) {\n      int x = 1 + check_dfs(j, i, d + 1);\n      if (x > m[i]) {\n        m2[i] = m1[i];\n        m1[i] = m[i];\n        m[i] = x;\n      } else if (x > m1[i]) {\n        m2[i] = m1[i];\n        m1[i] = x;\n      } else if (x > m2[i])\n        m2[i] = x;\n    }\n  return max(0, m[i]);\n}\nvoid check_dfs1(int i, int p, int v) {\n  if (i != 1) {\n    up[i] = up[p] + 1;\n    up[i] = max(up[i], v + 1);\n  }\n  if ((((m[i] > 0) + (m1[i] > 0) + (m2[i] > 0)) == 3 && m[i] + m1[i] >= k - 1 &&\n       m1[i] + m2[i] >= k - 1 && m2[i] + m[i] >= k - 1) ||\n      (((m[i] > 0) + (m1[i] > 0) + (up[i] > 0)) == 3 && m[i] + m1[i] >= k - 1 &&\n       m1[i] + up[i] >= k - 1 && up[i] + m[i] >= k - 1))\n    z = 0;\n  for (auto j : adj[i]) {\n    if (j == p) continue;\n    check_dfs1(j, i, ((m[j] + 1) == m[i] ? m1[i] : m[i]));\n  }\n}\npair<int, int> diam_dfs(int i, int p) {\n  pair<int, int> m = {0, i}, M = {0, i};\n  for (auto j : adj[i]) {\n    if (j == p) continue;\n    pair<int, int> d = diam_dfs(j, i);\n    d.first++;\n    if (d.first > M.first) {\n      m = M;\n      M = d;\n    } else if (d.first > m.first)\n      m = d;\n  }\n  if (diam < m.first + M.first) {\n    diam = m.first + M.first;\n    a = m.second;\n    b = M.second;\n  }\n  return M;\n}\nvector<int> work() {\n  vector<int> res, x;\n  if (h[a] > h[b]) swap(a, b);\n  while (h[b] > h[a]) {\n    res.push_back(b);\n    b = par[b];\n  }\n  while (a != b) {\n    res.push_back(b);\n    x.push_back(a);\n    b = par[b];\n    a = par[a];\n  }\n  res.push_back(a);\n  reverse(x.begin(), x.end());\n  res.insert(res.end(), x.begin(), x.end());\n  return res;\n}\nvoid dfs(int i, int p, int d) {\n  ans[i] = color[d];\n  for (auto j : adj[i])\n    if (j != p) dfs(j, i, d + 1);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  for (int i = 1; i < n; i++) {\n    int x, y;\n    cin >> x >> y;\n    adj[x].push_back(y);\n    adj[y].push_back(x);\n  }\n  check_dfs(1, 1, 1);\n  check_dfs1(1, 1, -1);\n  if (!z && k != 2) return cout << \"No\" << '\\n', 0;\n  diam_dfs(1, 1);\n  vector<int> diameter = work();\n  for (int i = 0; i < diameter.size(); i++) ans[diameter[i]] = (i % k);\n  for (int i = ((int)diameter.size() - 1) / 2; i >= 0; i--)\n    color[((int)diameter.size() - 1) / 2 - i] = ans[diameter[i]];\n  dfs(diameter[((int)diameter.size() - 1) / 2],\n      diameter[((int)diameter.size() - 1) / 2 + 1], 0);\n  for (int i = ((int)diameter.size() - 1) / 2 + 1; i < diameter.size(); i++)\n    color[i - 1 - ((int)diameter.size() - 1) / 2] = ans[diameter[i]];\n  dfs(diameter[((int)diameter.size() - 1) / 2 + 1],\n      diameter[((int)diameter.size() - 1) / 2], 0);\n  cout << \"Yes\" << '\\n';\n  for (int i = 1; i <= n; i++) cout << ans[i] + 1 << \" \";\n  cout << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\nint n, k, k1, fa[N], c[N], mx[N], q[N], d[N];\nint mxx, rt1, rt2;\nbool in[N];\nvector<int> g[N];\nvoid fail() {\n  printf(\"No\\n\");\n  exit(0);\n}\nvoid dfs(int x, int d, int f = -1) {\n  if (d > mxx) mxx = d, rt2 = x;\n  for (int i = 0; i < g[x].size(); ++i)\n    if (g[x][i] != f) {\n      dfs(g[x][i], d + 1, x);\n    }\n}\nvoid dfs1(int x) {\n  for (int i = 0; i < g[x].size(); ++i)\n    if (g[x][i] != fa[x]) {\n      int y = g[x][i];\n      fa[y] = x;\n      d[y] = d[x] + 1;\n      dfs1(y);\n    }\n}\nvoid dfs2(int x) {\n  mx[x] = !in[x];\n  for (int i = 0; i < g[x].size(); ++i)\n    if (g[x][i] != fa[x]) {\n      int y = g[x][i];\n      dfs2(y);\n      mx[x] = max(mx[x], mx[y] + (!in[x]));\n    }\n}\nvoid dfs3(int x, int d) {\n  for (int i = 0; i < g[x].size(); ++i)\n    if (g[x][i] != fa[x] && !in[g[x][i]]) {\n      int y = g[x][i];\n      c[y] = (c[x] + d + k) % k;\n      dfs3(y, d);\n    }\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1, x, y; i < n; ++i) {\n    scanf(\"%d%d\", &x, &y);\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  dfs(1, 0);\n  rt1 = rt2;\n  mxx = 0;\n  dfs(rt1, 0);\n  dfs1(rt1);\n  for (int x = rt2;; x = fa[x]) {\n    c[x] = k1++;\n    k1 %= k;\n    in[x] = 1;\n    q[++q[0]] = x;\n    if (x == rt1) break;\n  }\n  dfs2(rt1);\n  if (k == 1) {\n    printf(\"Yes\\n\");\n    for (int i = 1; i <= n; ++i) printf(\"%d \", 1);\n    return 0;\n  }\n  if (k == 2) {\n    printf(\"Yes\\n\");\n    for (int i = 1; i <= n; ++i) printf(\"%d \", (d[i] & 1) + 1);\n    return 0;\n  }\n  for (int t = 1; t <= q[0]; ++t) {\n    int x = q[t];\n    for (int i = 0; i < g[x].size(); ++i)\n      if (g[x][i] != fa[x] && !in[g[x][i]]) {\n        int y = g[x][i];\n        bool flag1 = (mx[y] + t) >= k;\n        bool flag2 = (mx[y] + q[0] - t + 1) >= k;\n        if (flag1 && flag2) fail();\n      }\n    dfs3(x, (t <= q[0] / 2) ? -1 : 1);\n  }\n  printf(\"Yes\\n\");\n  for (int i = 1; i <= n; ++i) printf(\"%d \", c[i] + 1);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool bo[200010];\nint n, x, y, hd[200010], k, q[200010], qn, l, r, cnt, la[200010], col[200010],\n    mxd[200010], dep[200010];\nstruct node {\n  int to, next;\n} e[400010];\nvoid addedge(int x, int y) {\n  e[++cnt] = (node){y, hd[x]}, hd[x] = cnt;\n  e[++cnt] = (node){x, hd[y]}, hd[y] = cnt;\n}\nvoid getcol2(int x, int fa) {\n  for (int i = hd[x]; i; i = e[i].next)\n    if (e[i].to != fa) col[e[i].to] = 3 - col[x], getcol2(e[i].to, x);\n}\nvoid dfs(int x, int fa) {\n  mxd[x] = dep[x] = dep[fa] + 1;\n  for (int i = hd[x]; i; i = e[i].next)\n    if (e[i].to != fa) dfs(e[i].to, x), mxd[x] = max(mxd[x], mxd[e[i].to]);\n}\nvoid dfs1(int x, int fa) {\n  col[x] = (col[fa] == k ? 1 : col[fa] + 1);\n  for (int i = hd[x]; i; i = e[i].next)\n    if (e[i].to != fa) dfs1(e[i].to, x);\n}\nvoid dfs2(int x, int fa) {\n  col[x] = (col[fa] == 1 ? k : col[fa] - 1);\n  for (int i = hd[x]; i; i = e[i].next)\n    if (e[i].to != fa) dfs2(e[i].to, x);\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i < n; i++) scanf(\"%d%d\", &x, &y), addedge(x, y);\n  if (k == 2) {\n    col[1] = 1, getcol2(1, 0);\n    puts(\"Yes\");\n    for (int i = 1; i <= n; i++) printf(\"%d \", col[i]);\n    puts(\"\");\n    return 0;\n  }\n  q[l = r = 1] = 1, memset(bo, 0, sizeof(bo)), bo[1] = 1;\n  while (l <= r) {\n    x = q[l++];\n    for (int i = hd[x]; i; i = e[i].next)\n      if (!bo[e[i].to]) q[++r] = e[i].to, bo[e[i].to] = 1;\n  }\n  q[1] = q[r], l = r = 1, memset(bo, 0, sizeof(bo)), bo[q[1]] = 1, la[q[1]] = 0;\n  while (l <= r) {\n    x = q[l++];\n    for (int i = hd[x]; i; i = e[i].next)\n      if (!bo[e[i].to]) q[++r] = e[i].to, bo[e[i].to] = 1, la[e[i].to] = x;\n  }\n  int nw = q[1];\n  q[qn = 1] = q[r];\n  while (la[q[qn]]) q[qn + 1] = la[q[qn]], qn++;\n  memset(bo, 0, sizeof(bo));\n  for (int i = 1; i <= qn; i++) bo[q[i]] = 1, col[q[i]] = i % k + 1;\n  for (int i = 1; i <= qn; i++) {\n    mxd[q[i]] = 0;\n    for (int j = hd[q[i]]; j; j = e[j].next)\n      if (!bo[e[j].to]) {\n        dfs(e[j].to, q[i]);\n        mxd[q[i]] = max(mxd[q[i]], mxd[e[j].to]);\n      }\n    if (mxd[q[i]] && mxd[q[i]] + i >= k && mxd[q[i]] + (qn - i + 1) >= k)\n      return puts(\"No\"), 0;\n    if (mxd[q[i]] + i >= k) {\n      for (int j = hd[q[i]]; j; j = e[j].next)\n        if (!bo[e[j].to]) dfs1(e[j].to, q[i]);\n    } else {\n      for (int j = hd[q[i]]; j; j = e[j].next)\n        if (!bo[e[j].to]) dfs2(e[j].to, q[i]);\n    }\n  }\n  puts(\"Yes\");\n  for (int i = 1; i <= n; i++) printf(\"%d \", col[i]);\n  puts(\"\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 200010;\nint n, m;\nvector<int> x[MAXN];\nint p[MAXN], d[MAXN];\nbool z[MAXN];\nint ans[MAXN];\nint dep[MAXN][3];\nint Bfs(int s) {\n  memset(z, 0, sizeof(z));\n  memset(p, 0, sizeof(p));\n  memset(d, 0, sizeof(d));\n  queue<int> Q;\n  Q.push(s);\n  z[s] = true;\n  while (!Q.empty()) {\n    s = Q.front();\n    Q.pop();\n    for (int t : x[s]) {\n      if (z[t]) continue;\n      z[t] = true;\n      p[t] = s;\n      d[t] = d[s] + 1;\n      Q.push(t);\n    }\n  }\n  return s;\n}\nvoid Dfs(int a, int fa, int c, bool order) {\n  ans[a] = c;\n  if (order) {\n    c = (c + 1) % m;\n  } else {\n    c = (c + m - 1) % m;\n  }\n  for (int b : x[a]) {\n    if (b == fa) continue;\n    Dfs(b, a, c, order);\n  }\n}\nvoid Update(int a, int dist) {\n  if (dist > dep[a][0]) {\n    dep[a][2] = dep[a][1];\n    dep[a][1] = dep[a][0];\n    dep[a][0] = dist;\n  } else if (dist + 1 > dep[a][1]) {\n    dep[a][2] = dep[a][1];\n    dep[a][1] = dist;\n  } else if (dist + 1 > dep[a][2]) {\n    dep[a][2] = dist;\n  }\n}\nvoid GetD(int a, int fa) {\n  for (int b : x[a]) {\n    if (b == fa) continue;\n    GetD(b, a);\n    Update(a, dep[b][0] + 1);\n  }\n  if (dep[a][0] == 0) dep[a][0] = 1;\n}\nbool Check(int a, int fa, int df) {\n  for (int b : x[a]) {\n    if (b == fa) continue;\n    int newdf = df + 1;\n    if (dep[a][0] == dep[b][0] + 1) {\n      newdf = max(newdf, dep[a][1] + 1);\n    } else {\n      newdf = max(newdf, dep[a][0] + 1);\n    }\n    if (!Check(b, a, newdf)) return false;\n  }\n  if (df != 1) Update(a, df);\n  return dep[a][2] == 0 || dep[a][1] + dep[a][2] - 1 < m;\n}\nbool Check() {\n  GetD(0, -1);\n  return Check(0, -1, 1);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> m;\n  for (int i = 1; i < n; ++i) {\n    int a, b;\n    cin >> a >> b;\n    --a;\n    --b;\n    x[a].push_back(b);\n    x[b].push_back(a);\n  }\n  if (m != 2 && !Check()) {\n    cout << \"No\" << endl;\n    return 0;\n  }\n  int s = Bfs(0);\n  int t = Bfs(s);\n  int md = t;\n  while (d[md] > (d[t] + 1) / 2) {\n    md = p[md];\n  }\n  Dfs(md, p[md], 0, true);\n  Dfs(p[md], md, m - 1, false);\n  cout << \"Yes\" << endl;\n  for (int i = 0; i < n; ++i) {\n    cout << ans[i] + 1 << \" \";\n  }\n  cout << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint head[200010], to[200010 << 1], nxt[200010 << 1], tot;\nchar *p1, *p2, buf[100000];\nint rd() {\n  int x = 0, f = 1;\n  char c =\n      (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2)\n           ? EOF\n           : *p1++);\n  while (c < 48) {\n    if (c == '-') f = -1;\n    c = (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2)\n             ? EOF\n             : *p1++);\n  }\n  while (c > 47) {\n    x = (((x << 2) + x) << 1) + (c ^ 48),\n    c = (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2)\n             ? EOF\n             : *p1++);\n  }\n  return x * f;\n}\ninline void add(int x, int y) {\n  to[++tot] = y;\n  nxt[tot] = head[x];\n  head[x] = tot;\n}\nint line1 = 1, line2 = 1, n, k;\nint dep[200010], line[200010], f[21][200010], dep_f[200010], tmp[200010],\n    ans[200010];\nbool L[200010];\nvoid dfs_init(int p, int fa) {\n  f[0][p] = fa;\n  dep_f[p] = dep_f[fa] + 1;\n  for (int i = 1; i <= 20; i++) {\n    f[i][p] = f[i - 1][f[i - 1][p]];\n  }\n  for (int i = head[p]; i; i = nxt[i]) {\n    if (to[i] != fa) {\n      dfs_init(to[i], p);\n    }\n  }\n}\nvoid dfs_find_line(int p, int fa) {\n  dep[p] = dep[fa] + 1;\n  for (int i = head[p]; i; i = nxt[i]) {\n    if (to[i] != fa) {\n      dfs_find_line(to[i], p);\n    }\n  }\n}\nint getlca(int x, int y) {\n  if (dep_f[x] < dep_f[y]) {\n    swap(x, y);\n  }\n  for (int i = 20; ~i; i--) {\n    if (dep_f[f[i][x]] >= dep_f[y]) {\n      x = f[i][x];\n    }\n  }\n  if (x == y) {\n    return x;\n  }\n  for (int i = 20; ~i; i--) {\n    if (f[i][x] != f[i][y]) {\n      x = f[i][x];\n      y = f[i][y];\n    }\n  }\n  return f[0][x];\n}\nvoid find_line() {\n  dfs_find_line(1, 0);\n  for (int i = 1; i <= n; i++) {\n    if (dep[line1] < dep[i]) {\n      line1 = i;\n    }\n  }\n  dfs_find_line(line1, 0);\n  for (int i = 1; i <= n; i++) {\n    if (dep[line2] < dep[i]) {\n      line2 = i;\n    }\n  }\n  int lca = getlca(line1, line2);\n  int now = line1;\n  while (now != lca) {\n    line[++line[0]] = now;\n    now = f[0][now];\n  }\n  line[++line[0]] = lca;\n  now = line2;\n  while (now != lca) {\n    tmp[++tmp[0]] = now;\n    now = f[0][now];\n  }\n  for (int i = tmp[0]; i; i--) {\n    line[++line[0]] = tmp[i];\n  }\n  for (int i = 1; i <= line[0]; i++) {\n    L[line[i]] = true;\n  }\n  for (int i = 1; i <= line[0]; i++) {\n    ans[line[i]] = i % k;\n  }\n}\nint dep_check[200010], mx_check[200010];\nvoid dfs_check(int p, int fa) {\n  dep_check[p] = dep_check[fa] + 1;\n  mx_check[p] = dep_check[p];\n  for (int i = head[p]; i; i = nxt[i]) {\n    if (to[i] != fa && !L[to[i]]) {\n      dfs_check(to[i], p);\n      mx_check[p] = max(mx_check[to[i]], mx_check[p]);\n    }\n  }\n}\nbool check() {\n  for (int i = 1; i <= line[0]; i++) {\n    dfs_check(line[i], line[i]);\n    if (min(i - 1, line[0] - i) + mx_check[line[i]] >= k &&\n        mx_check[line[i]] > 1) {\n      return false;\n    }\n  }\n  return true;\n}\nvoid dfs(int p, int fa, int opt) {\n  ans[p] = (ans[fa] + opt) % k;\n  ans[p] += k;\n  ans[p] %= k;\n  for (int i = head[p]; i; i = nxt[i]) {\n    if (to[i] != fa && !L[to[i]]) {\n      dfs(to[i], p, opt);\n    }\n  }\n}\nvoid work() {\n  for (int i = 1; i <= line[0]; i++) {\n    if (i - 1 <= line[0] - i) {\n      (ans[line[i]] += 1) %= k;\n      dfs(line[i], line[i], -1);\n    } else {\n      (ans[line[i]] += k - 1) %= k;\n      dfs(line[i], line[i], 1);\n    }\n  }\n}\nint dep2[200010];\nvoid dfs2(int p, int fa) {\n  dep2[p] = dep2[fa] + 1;\n  for (int i = head[p]; i; i = nxt[i]) {\n    if (to[i] != fa) {\n      dfs2(to[i], p);\n    }\n  }\n}\nint main() {\n  n = rd(), k = rd();\n  for (int i = 1; i < n; i++) {\n    int x = rd(), y = rd();\n    add(x, y);\n    add(y, x);\n  }\n  if (k == 2) {\n    puts(\"Yes\");\n    dfs2(1, 0);\n    for (int i = 1; i <= n; i++) {\n      if (dep2[i] & 1) {\n        printf(\"1 \");\n      } else {\n        printf(\"2 \");\n      }\n    }\n    puts(\"\");\n    return 0;\n  }\n  dfs_init(1, 0);\n  find_line();\n  if (!check()) {\n    puts(\"No\");\n    return 0;\n  }\n  work();\n  puts(\"Yes\");\n  for (int i = 1; i <= n; i++) {\n    printf(\"%d \", ans[i] + 1);\n  }\n  puts(\"\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, mx, ds, rt, ans[200001], mxd[200001], mxu[200001];\nvector<int> path, graph[200001];\nvoid dfs(int curr, int par, int tag) {\n  ans[curr] = tag;\n  for (auto i : graph[curr]) {\n    if (i == par) {\n      continue;\n    }\n    dfs(i, curr, 3 - tag);\n  }\n}\nvoid dfs2(int curr, int par, int dist) {\n  if (dist > ds) {\n    ds = dist, mx = curr;\n  }\n  for (auto i : graph[curr]) {\n    if (i == par) {\n      continue;\n    }\n    dfs2(i, curr, dist + 1);\n  }\n}\nbool dfs3(int curr, int par, int dist) {\n  path.push_back(curr);\n  if (curr == dist) {\n    return true;\n  }\n  for (auto i : graph[curr]) {\n    if (i == par) {\n      continue;\n    }\n    if (dfs3(i, curr, dist)) {\n      return true;\n    }\n  }\n  path.pop_back();\n  return false;\n}\nvoid dfs4(int curr, int par) {\n  mxd[curr] = 0;\n  for (auto i : graph[curr]) {\n    if (i == par) {\n      continue;\n    }\n    dfs4(i, curr);\n    mxd[curr] = max(mxd[curr], mxd[i] + 1);\n  }\n}\nvoid dfs5(int curr, int par) {\n  if (graph[curr].size() == 1 && curr != rt) {\n    return;\n  }\n  int pref[graph[curr].size() + 2], suf[graph[curr].size() + 2];\n  pref[0] = 0, suf[graph[curr].size() + (curr == rt ? 1 : 0)] = 0;\n  int tag = 1;\n  for (auto i : graph[curr]) {\n    if (i == par) {\n      continue;\n    }\n    pref[tag] = max(pref[tag - 1], mxd[i] + 2);\n    tag += 1;\n  }\n  tag = graph[curr].size() - 1 + (curr == rt ? 1 : 0);\n  for (auto j = (int)graph[curr].size() - 1; j >= 0; j -= 1) {\n    auto i = graph[curr][j];\n    if (i == par) {\n      continue;\n    }\n    suf[tag] = max(suf[tag + 1], mxd[i] + 2);\n    tag -= 1;\n  }\n  tag = 1;\n  for (auto i : graph[curr]) {\n    if (i == par) {\n      continue;\n    }\n    mxu[i] = max({mxu[curr] + 1, pref[tag - 1], suf[tag + 1]});\n    tag += 1;\n    dfs5(i, curr);\n  }\n}\nvoid dfs6(int curr, int par) {\n  int mx1 = -1, mx2 = -1, mx3 = -1;\n  if (mxu[curr]) {\n    mx3 = mxu[curr];\n  }\n  for (auto i : graph[curr]) {\n    if (i == par) {\n      continue;\n    }\n    if (mxd[i] + 1 >= mx3) {\n      mx1 = mx2, mx2 = mx3, mx3 = mxd[i] + 1;\n    } else if (mxd[i] + 1 >= mx2) {\n      mx1 = mx2, mx2 = mxd[i] + 1;\n    } else if (mxd[i] + 1 >= mx1) {\n      mx1 = mxd[i] + 1;\n    }\n    dfs6(i, curr);\n  }\n  if (mx1 > 0 && mx1 + mx2 + 1 >= k && mx2 + mx3 + 1 >= k &&\n      mx1 + mx3 + 1 >= k) {\n    cout << \"No\" << endl;\n    exit(0);\n  }\n}\nvoid dfs7(int curr, int par, int val) {\n  if (val == 0) {\n    val = k;\n  }\n  ans[curr] = val;\n  for (auto i : graph[curr]) {\n    if (!ans[i]) {\n      dfs7(i, curr, val - 1);\n    }\n  }\n}\nvoid dfs8(int curr, int par, int val) {\n  if (val == k + 1) {\n    val = 1;\n  }\n  ans[curr] = val;\n  for (auto i : graph[curr]) {\n    if (!ans[i]) {\n      dfs8(i, curr, val + 1);\n    }\n  }\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 0; i + 1 < n; i += 1) {\n    int a, b;\n    cin >> a >> b;\n    graph[a].push_back(b);\n    graph[b].push_back(a);\n  }\n  if (k == 2) {\n    dfs(1, 1, 1);\n    cout << \"Yes\" << endl;\n    for (int i = 1; i <= n; i += 1) {\n      cout << ans[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n  }\n  int curr = 1;\n  dfs2(curr, curr, 0);\n  curr = mx, ds = 0;\n  dfs2(curr, curr, 0);\n  dfs3(curr, curr, mx);\n  if (ds + 1 < k) {\n    dfs(1, 1, 1);\n    cout << \"Yes\" << endl;\n    for (int i = 1; i <= n; i += 1) {\n      cout << ans[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n  }\n  dfs4(curr, curr);\n  rt = curr;\n  dfs5(curr, curr);\n  dfs6(curr, curr);\n  for (int i = 0; i < path.size(); i += 1) {\n    ans[path[i]] = 1 + (i % k);\n  }\n  for (int i = 0; i < path.size() / 2; i += 1) {\n    dfs7(path[i], path[i + 1], ans[path[i]]);\n  }\n  for (int i = path.size() / 2; i < path.size(); i += 1) {\n    dfs8(path[i], path[i - 1], ans[path[i]]);\n  }\n  cout << \"Yes\" << endl;\n  for (int i = 1; i <= n; i += 1) {\n    cout << ans[i] << \" \";\n  }\n  cout << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = (int)1e9;\nconst long long INF = (long long)5e18;\nconst int MOD = 998244353;\nint _abs(int x) { return x < 0 ? -x : x; }\nint add(int x, int y) {\n  x += y;\n  return x >= MOD ? x - MOD : x;\n}\nint sub(int x, int y) {\n  x -= y;\n  return x < 0 ? x + MOD : x;\n}\nvoid Add(int &x, int y) {\n  x += y;\n  if (x >= MOD) x -= MOD;\n}\nvoid Sub(int &x, int y) {\n  x -= y;\n  if (x < 0) x += MOD;\n}\nvoid Mul(int &x, int y) { x = (long long)(x) * (y) % MOD; }\nint qpow(int x, int y) {\n  int ret = 1;\n  while (y) {\n    if (y & 1) ret = (long long)(ret) * (x) % MOD;\n    x = (long long)(x) * (x) % MOD;\n    y >>= 1;\n  }\n  return ret;\n}\nvoid checkmin(int &x, int y) {\n  if (x > y) x = y;\n}\nvoid checkmax(int &x, int y) {\n  if (x < y) x = y;\n}\nvoid checkmin(long long &x, long long y) {\n  if (x > y) x = y;\n}\nvoid checkmax(long long &x, long long y) {\n  if (x < y) x = y;\n}\ninline int read() {\n  int x = 0, f = 1;\n  char c = getchar();\n  while (c > '9' || c < '0') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9')\n    x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();\n  return x * f;\n}\nconst int N = 500005;\nint n, k;\nvector<int> v[N];\nint dis[N], dep[N];\nint mx = 0, rt, fa[N];\nvoid dfs(int u, int f) {\n  fa[u] = f;\n  if (mx < dep[u]) mx = dep[u], rt = u;\n  for (auto &to : v[u])\n    if (to != f) {\n      dep[to] = dep[u] + 1;\n      dfs(to, u);\n    }\n}\nint col[N], vis[N], mxdep;\nvector<int> seq;\nvoid dfs2(int u, int f, int flag, int now) {\n  col[u] = now;\n  checkmax(mxdep, dep[u]);\n  now += flag;\n  if (now <= 0) now += k;\n  if (now > k) now -= k;\n  for (auto &to : v[u])\n    if (to != f && !vis[to]) dep[to] = dep[u] + 1, dfs2(to, u, flag, now);\n}\nvoid GG() {\n  puts(\"No\");\n  exit(0);\n}\nint main() {\n  n = read();\n  k = read();\n  for (int i = 1; i < n; i++) {\n    int x = read(), y = read();\n    v[x].push_back(y), v[y].push_back(x);\n  }\n  dfs(1, 0);\n  mx = 0;\n  dep[rt] = 0;\n  int rt1 = rt;\n  dfs(rt, 0);\n  mx = 0;\n  dep[rt] = 0;\n  for (int i = 1; i <= n; i++) dis[i] = dep[i];\n  dfs(rt, 0);\n  int rt2 = rt;\n  int x = rt1;\n  while (x) seq.push_back(x), vis[x] = 1, x = fa[x];\n  x = 1;\n  for (auto &u : seq) {\n    col[u] = x++;\n    if (x > k) x -= k;\n  }\n  for (int i = 0; i < (int)(seq).size(); i++) {\n    int dis1 = i + 1, dis2 = (int)(seq).size() - i;\n    int u = seq[i];\n    dep[u] = 0;\n    mxdep = 0;\n    if (i < (int)(seq).size() / 2) {\n      dfs2(u, 0, -1, col[u]);\n      if (mxdep && mxdep + dis1 >= k && k != 2) GG();\n    } else {\n      dfs2(u, 0, 1, col[u]);\n      if (mxdep && mxdep + dis2 >= k && k != 2) GG();\n    }\n  }\n  puts(\"Yes\");\n  for (int i = 1; i <= n; i++) printf(\"%d \", col[i]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nvector<vector<int> > suka;\nvector<int> colour;\nvoid dfs(int vertex, int last, int c) {\n  colour[vertex] = c;\n  for (int i = 0; i < suka[vertex].size(); ++i) {\n    int to = suka[vertex][i];\n    if (to == last) continue;\n    dfs(to, vertex, 3 - c);\n  }\n}\nint mx = -1, W = -1;\nvoid dfs2(int vertex, int last, int d) {\n  if (d > mx) {\n    mx = d, W = vertex;\n  }\n  for (int i = 0; i < suka[vertex].size(); ++i) {\n    int to = suka[vertex][i];\n    if (to == last) continue;\n    dfs2(to, vertex, d + 1);\n  }\n}\nvector<int> path;\nvoid dfs3(int vertex, int target, int last, vector<int> &p) {\n  p.push_back(vertex);\n  if (target == vertex) path = p;\n  for (int i = 0; i < suka[vertex].size(); ++i) {\n    int to = suka[vertex][i];\n    if (to == last) continue;\n    dfs3(to, target, vertex, p);\n  }\n  p.pop_back();\n}\nvector<bool> in_path;\nvoid dfs4(int vertex, int last, int d) {\n  mx = max(mx, d);\n  for (int i = 0; i < suka[vertex].size(); ++i) {\n    int to = suka[vertex][i];\n    if (to == last) continue;\n    dfs4(to, vertex, d + 1);\n  }\n}\nvoid dfs5(int vertex, int last, int cur, int q) {\n  colour[vertex] = ((cur % k) + k) % k;\n  for (int i = 0; i < suka[vertex].size(); ++i) {\n    int to = suka[vertex][i];\n    if (to == last) continue;\n    dfs5(to, vertex, cur + q, q);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> k;\n  suka.assign(n, {});\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n    u--, v--;\n    suka[u].push_back(v);\n    suka[v].push_back(u);\n  }\n  colour.assign(n, -1);\n  if (k == 2) {\n    cout << \"Yes\\n\";\n    dfs(0, -1, 1);\n    for (int i = 0; i < n; i++) cout << colour[i] << \" \";\n    return 0;\n  }\n  dfs2(0, -1, 0);\n  int good = W;\n  W = -1, mx = -1;\n  dfs2(good, -1, 0);\n  vector<int> K;\n  dfs3(good, W, -1, K);\n  if (path.size() < k) {\n    cout << \"Yes\\n\";\n    for (int i = 0; i < n; i++) cout << 1 << \" \";\n    return 0;\n  }\n  in_path.assign(n, false);\n  for (int i = 0; i < path.size(); ++i) {\n    colour[path[i]] = i % k;\n    in_path[path[i]] = true;\n  }\n  for (int i = 0; i < path.size(); ++i) {\n    mx = -1e9;\n    int vertex = path[i];\n    for (int j = 0; j < suka[vertex].size(); ++j) {\n      int to = suka[vertex][j];\n      if (in_path[to]) continue;\n      dfs4(to, vertex, 1);\n    }\n    int A = i + 1, B = path.size() - i;\n    if (mx + A >= k && mx + B >= k) {\n      cout << \"No\";\n      return 0;\n    }\n  }\n  for (int i = 0; i < path.size(); ++i) {\n    int tut = i % k;\n    int vertex = path[i];\n    for (int j = 0; j < suka[vertex].size(); j++) {\n      int to = suka[vertex][j];\n      if (in_path[to]) continue;\n      if (i < path.size() / 2) {\n        dfs5(to, vertex, tut - 1, -1);\n      } else\n        dfs5(to, vertex, tut + 1, 1);\n    }\n  }\n  cout << \"Yes\\n\";\n  for (int i = 0; i < n; ++i) cout << colour[i] + 1 << \" \";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 212345;\nint n, k, s, t, f[maxn], dep[maxn], deps[maxn], dept[maxn], col[maxn];\nbool in[maxn];\nvector<int> G[maxn];\nvoid dfs1(int u, int fa, int *mdep) {\n  mdep[u] = dep[u] = dep[fa] + 1;\n  f[u] = fa;\n  for (int i = 0; i < (int)G[u].size(); ++i) {\n    int v = G[u][i];\n    if (v == fa) continue;\n    dfs1(v, u, mdep);\n    mdep[u] = max(mdep[u], mdep[v]);\n  }\n}\nvoid dfs(int u, int fa, int c) {\n  if (in[u])\n    c = c % k + 1;\n  else {\n    int cnt = 0;\n    if (deps[u] >= k) ++cnt;\n    if (dept[u] >= k) ++cnt;\n    if (cnt == 2) {\n      puts(\"No\");\n      exit(0);\n    }\n    if (deps[u] >= k)\n      c = c % k + 1;\n    else if (dept[u] >= k)\n      c = (c + k - 2) % k + 1;\n    else\n      c = 1;\n  }\n  col[u] = c;\n  for (int i = 0; i < (int)G[u].size(); ++i) {\n    int v = G[u][i];\n    if (v == fa) continue;\n    dfs(v, u, c);\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 0; i < n - 1; ++i) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  dfs1(1, 0, deps);\n  if (k == 2) {\n    puts(\"Yes\");\n    for (int i = 1; i <= n; ++i)\n      printf(\"%d%c\", dep[i] % 2 + 1, i == n ? '\\n' : ' ');\n    return 0;\n  }\n  for (int i = 1; i <= n; ++i)\n    if (dep[i] > dep[s]) s = i;\n  dfs1(s, 0, deps);\n  for (int i = 1; i <= n; ++i)\n    if (dep[i] > dep[t]) t = i;\n  int tt = t;\n  while (tt) {\n    in[tt] = true;\n    tt = f[tt];\n  }\n  dfs1(t, 0, dept);\n  dfs(s, 0, 0);\n  puts(\"Yes\");\n  for (int i = 1; i <= n; ++i) printf(\"%d%c\", col[i], i == n ? '\\n' : ' ');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 5;\nint col[MAXN], par[MAXN], deg[MAXN], in_diam[MAXN], dep[MAXN], del, n, k, cv,\n    cd;\nvector<int> adj[MAXN], diam;\nbool orz;\nvoid dfs_fill(int s, int c) {\n  col[s] = c;\n  for (auto v : adj[s]) {\n    if (col[v]) continue;\n    int nc = c + del;\n    if (nc == 0) nc = k;\n    if (nc == k + 1) nc = 1;\n    dfs_fill(v, nc);\n  }\n}\nvoid dfs_dis(int s, int p, int d) {\n  par[s] = p;\n  if (d > cd) {\n    cd = d;\n    cv = s;\n  }\n  for (auto v : adj[s]) {\n    if (v == p || in_diam[v]) continue;\n    dfs_dis(v, s, d + 1);\n  }\n}\nvoid get_diam() {\n  cd = 0;\n  dfs_dis(1, 0, 0);\n  int u = cv;\n  cd = 0;\n  dfs_dis(u, 0, 0);\n  int v = cv;\n  while (v != 0) {\n    diam.push_back(v);\n    in_diam[v] = 1;\n    v = par[v];\n  }\n}\nvoid get(int s) {\n  cd = 0;\n  dfs_dis(s, 0, 0);\n  cd = 0;\n  dfs_dis(cv, 0, 0);\n  if (cd > k) orz = false;\n}\nstruct node {\n  int l, r, mx, ad;\n  node *left, *right;\n  int get() { return mx + ad; }\n  void merge() { mx = max(left->get(), right->get()); }\n  void push() {\n    left->ad += ad;\n    right->ad += ad;\n    ad = 0;\n  }\n  node(int l, int r) : l(l), r(r), mx(0), ad(0) {\n    if (l < r) {\n      int m = (l + r) / 2;\n      left = new node(l, m);\n      right = new node(m + 1, r);\n    }\n  }\n  void upd(int rl, int rr, int v) {\n    if (r < rl || rr < l) return;\n    if (rl <= l && r <= rr) {\n      ad += v;\n      return;\n    }\n    push();\n    left->upd(rl, rr, v);\n    right->upd(rl, rr, v);\n    merge();\n  }\n  int qry(int rl, int rr) {\n    if (r < rl || rr < r || rl > rr) return -10000000;\n    if (rl <= l && r <= rr) return get();\n    push();\n    merge();\n    return max(left->qry(rl, rr), right->qry(rl, rr));\n  }\n};\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> k;\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n    deg[u]++;\n    deg[v]++;\n  }\n  del = 1;\n  if (k == 2) {\n    cout << \"Yes\\n\";\n    del = 1;\n    dfs_fill(1, 1);\n    for (int i = 1; i <= n; i++) cout << col[i] << \" \";\n    cout << '\\n';\n    return 0;\n  }\n  get_diam();\n  int d = diam.size();\n  for (int i = 0; i < d; i++) {\n    col[diam[i]] = (i % k) + 1;\n    if (i < d / 2)\n      del = -1;\n    else\n      del = 1;\n    int nc = col[diam[i]] + del;\n    if (nc == 0) nc = k;\n    if (nc == k + 1) nc = 1;\n    for (auto v : adj[diam[i]]) {\n      if (!in_diam[v]) dfs_fill(v, nc);\n    }\n  }\n  orz = true;\n  for (int i = 0; i < d; i++) {\n    int u = diam[i];\n    for (auto v : adj[u]) {\n      if (!in_diam[v]) {\n        get(v);\n        cd = 0;\n        dfs_dis(v, 0, 1);\n        dep[u] = max(dep[u], cd + 1);\n      }\n    }\n    if (dep[u] && dep[u] + min(i, d - 1 - i) >= k) orz = false;\n  }\n  int dd = d / 2 - 1;\n  node tree(0, dd);\n  for (int i = 0; i <= dd; i++) {\n    if (i > 0) tree.upd(0, i - 1, 1);\n    if (!dep[diam[i]]) {\n      tree.upd(i, i, -10000000);\n      continue;\n    }\n    int top = tree.qry(max(0, i - k + 3), i - 1);\n    if (top + dep[diam[i]] >= k) orz = false;\n    tree.upd(i, i, dep[diam[i]] - 1);\n  }\n  tree = node(dd + 1, d - 1);\n  for (int i = d - 1; i >= dd + 1; i--) {\n    if (i < d - 1) tree.upd(i + 1, d - 1, 1);\n    if (!dep[diam[i]]) {\n      tree.upd(i, i, -10000000);\n      continue;\n    }\n    int top = tree.qry(i + 1, min(d - 1, i + k - 3));\n    if (top + dep[diam[i]] >= k) orz = false;\n    tree.upd(i, i, dep[diam[i]] - 1);\n  }\n  if (!orz) {\n    cout << \"No\\n\";\n    return 0;\n  }\n  cout << \"Yes\\n\";\n  for (int i = 1; i <= n; i++) cout << col[i] << \" \";\n  cout << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\nint n, k, k1, fa[N], c[N], mx[N], q[N], d[N];\nint mxx, rt1, rt2;\nbool in[N];\nvector<int> g[N];\nvoid fail() {\n  printf(\"No\\n\");\n  exit(0);\n}\nvoid dfs(int x, int d, int f = -1) {\n  if (d > mxx) mxx = d, rt2 = x;\n  for (int i = 0; i < g[x].size(); ++i)\n    if (g[x][i] != f) {\n      dfs(g[x][i], d + 1, x);\n    }\n}\nvoid dfs1(int x) {\n  for (int i = 0; i < g[x].size(); ++i)\n    if (g[x][i] != fa[x]) {\n      int y = g[x][i];\n      fa[y] = x;\n      d[y] = d[x] + 1;\n      dfs1(y);\n    }\n}\nvoid dfs2(int x) {\n  mx[x] = !in[x];\n  for (int i = 0; i < g[x].size(); ++i)\n    if (g[x][i] != fa[x]) {\n      int y = g[x][i];\n      dfs2(y);\n      mx[x] = max(mx[x], mx[y] + (!in[x]));\n    }\n}\nvoid dfs3(int x, int d) {\n  if (d != 0)\n    c[x] = (c[fa[x]] + d + k) % k;\n  else\n    c[x] = 0;\n  for (int i = 0; i < g[x].size(); ++i)\n    if (g[x][i] != fa[x] && !in[g[x][i]]) {\n      int y = g[x][i];\n      dfs3(y, d);\n    }\n}\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1, x, y; i < n; ++i) {\n    scanf(\"%d%d\", &x, &y);\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  dfs(1, 0);\n  rt1 = rt2;\n  mxx = 0;\n  dfs(rt1, 0);\n  dfs1(rt1);\n  for (int x = rt2;; x = fa[x]) {\n    c[x] = k1++;\n    k1 %= k;\n    in[x] = 1;\n    q[++q[0]] = x;\n    if (x == rt1) break;\n  }\n  dfs2(rt1);\n  if (k == 1) {\n    printf(\"Yes\\n\");\n    for (int i = 1; i <= n; ++i) printf(\"%d \", 1);\n    return 0;\n  }\n  if (k == 2) {\n    printf(\"Yes\\n\");\n    for (int i = 1; i <= n; ++i) printf(\"%d \", (d[i] & 1) + 1);\n    return 0;\n  }\n  for (int t = 1; t <= q[0]; ++t) {\n    int x = q[t];\n    for (int i = 0; i < g[x].size(); ++i)\n      if (g[x][i] != fa[x] && !in[g[x][i]]) {\n        int y = g[x][i];\n        int a1 = mx[y] + t;\n        int a2 = mx[y] + q[0] - t + 1;\n        if (a1 >= k && a2 >= k)\n          fail();\n        else if (a1 < k && a2 < k && a1 == a2)\n          dfs(y, 0);\n        else\n          dfs3(y, (t <= (q[0] + 1) / 2) ? -1 : 1);\n      }\n  }\n  printf(\"Yes\\n\");\n  for (int i = 1; i <= n; ++i) printf(\"%d \", c[i] + 1);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 7;\nvector<int> g[N];\nint par[N];\nint h1[N], h2[N];\nint v1[N], v2[N];\nint ph[N];\nvoid dfs(int u, int p) {\n  h2[u] = -1e9;\n  par[u] = p;\n  for (auto v : g[u]) {\n    if (v != p) {\n      dfs(v, u);\n      if (h1[v] + 1 > h1[u]) {\n        h2[u] = h1[u];\n        h1[u] = h1[v] + 1;\n      } else {\n        h2[u] = max(h2[u], h1[v] + 1);\n      }\n    }\n  }\n}\nvoid jhfs(int u, int p) {\n  v1[u] = v2[u] = -1;\n  for (auto v : g[u]) {\n    if (v != p) {\n      ph[v] = max(ph[v], ph[u] + 1);\n      if (h1[u] == h1[v] + 1) {\n        ph[v] = max(ph[v], h2[u] + 1);\n      } else {\n        ph[v] = max(ph[v], h1[u] + 1);\n      }\n      if (h1[v] + 1 == h1[u]) {\n        v1[u] = v;\n      } else if (h1[v] + 1 == h2[u]) {\n        v2[u] = v;\n      }\n      jhfs(v, u);\n    }\n  }\n}\nint get(int u, int ban) {\n  int res = 0;\n  if (ban != par[u]) res = max(res, ph[u]);\n  if (v1[u] != ban) res = max(res, h1[u]);\n  if (v2[u] != ban) res = max(res, h2[u]);\n  return res;\n}\npair<int, int> best;\nvoid dfsD(int u, int d, int p) {\n  best = max(best, {d, u});\n  for (auto v : g[u]) {\n    if (v != p) {\n      dfsD(v, d + 1, u);\n    }\n  }\n}\nvector<int> curPath;\nvector<int> path;\nvoid dfsP(int u, int finish, int p) {\n  curPath.push_back(u);\n  if (u == finish) path = curPath;\n  for (auto v : g[u]) {\n    if (v != p) dfsP(v, finish, u);\n  }\n  curPath.pop_back();\n}\nvector<int> getPath(int u, int v) {\n  dfsP(u, v, -1);\n  return path;\n}\nvector<int> getDiam() {\n  best = {-1, 0};\n  dfsD(0, 0, -1);\n  int u = best.second;\n  best = {-1, 0};\n  dfsD(u, 0, -1);\n  int v = best.second;\n  return getPath(u, v);\n}\nint k;\nint color[N];\nvoid dfsC(int u, int p, int s) {\n  for (auto v : g[u]) {\n    if (v != p) {\n      if (color[v] == -1) {\n        color[v] = ((color[u] + s) % k + k) % k;\n      }\n      dfsC(v, u, s);\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.setf(ios::fixed);\n  cout.precision(20);\n  int n;\n  cin >> n >> k;\n  for (int i = 0; i + 1 < n; ++i) {\n    int u, v;\n    cin >> u >> v;\n    --u, --v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  dfs(0, -1);\n  jhfs(0, -1);\n  for (int i = 0; i < n; ++i) {\n    vector<int> hv;\n    for (int v : g[i]) {\n      hv.push_back(get(v, i));\n    }\n    sort(hv.rbegin(), hv.rend());\n    if (k != 2 && hv.size() >= 3 && hv[1] + hv[2] + 3 >= k) {\n      cout << \"No\\n\";\n      return 0;\n    }\n  }\n  cout << \"Yes\\n\";\n  vector<int> diam = getDiam();\n  for (int i = 0; i < n; ++i) color[i] = -1;\n  int c = 0;\n  for (int x : diam) {\n    color[x] = (c++) % k;\n  }\n  int f = diam[diam.size() / 2 - 1];\n  int s = diam[diam.size() / 2];\n  dfsC(f, s, -1);\n  dfsC(s, f, 1);\n  for (int i = 0; i < n; ++i) cout << color[i] + 1 << ' ';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nbool get_int(T &x) {\n  char t = getchar();\n  bool neg = false;\n  x = 0;\n  for (; (t > '9' || t < '0') && t != '-' && t != EOF; t = getchar())\n    ;\n  if (t == '-') neg = true, t = getchar();\n  if (t == EOF) return false;\n  for (; t <= '9' && t >= '0'; t = getchar()) x = x * 10 + t - '0';\n  if (neg) x = -x;\n  return true;\n}\ntemplate <typename T>\nvoid print_int(T x) {\n  if (x < 0) putchar('-'), x = -x;\n  short a[20] = {}, sz = 0;\n  while (x > 0) a[sz++] = x % 10, x /= 10;\n  if (sz == 0) putchar('0');\n  for (int i = sz - 1; i >= 0; i--) putchar('0' + a[i]);\n}\nconst int inf = 0x3f3f3f3f;\nconst long long Linf = 1ll << 61;\nconst double pi = acos(-1.0);\nconst int maxn = 200111;\nvector<int> g[maxn];\nint n, k, fa[20][maxn], dep[maxn];\nvoid dfs(int x, int f, int d) {\n  fa[0][x] = f;\n  for (int i = 1; i < 20; i++) fa[i][x] = fa[i - 1][fa[i - 1][x]];\n  dep[x] = d;\n  for (auto v : g[x])\n    if (v != f) dfs(v, x, d + 1);\n}\nint getlca(int u, int v) {\n  if (dep[u] < dep[v]) swap(u, v);\n  for (int i = 19; i >= 0; i--)\n    if (dep[u] - dep[v] >> i) u = fa[i][u];\n  if (u == v) return u;\n  for (int i = 19; i >= 0; i--)\n    if (fa[i][u] != fa[i][v]) u = fa[i][u], v = fa[i][v];\n  return fa[0][u];\n}\nint getdist(int u, int v) {\n  return dep[u] + dep[v] - dep[getlca(u, v)] * 2 + 1;\n}\nint getfar(int u) {\n  int ret = 0, d = 0;\n  for (int i = 1; i <= n; i++) {\n    int nd = getdist(u, i);\n    if (nd > d) {\n      d = nd;\n      ret = i;\n    }\n  }\n  return ret;\n}\nint ans[maxn];\nint main() {\n  (get_int(n) && get_int(k));\n  for (int i = 1, u, v; i < n; i++) {\n    (get_int(u) && get_int(v));\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  dfs(1, 0, 0);\n  if (k == 2) {\n    puts(\"Yes\");\n    for (int i = 1; i <= n; i++) printf(\"%d \", getdist(1, i) % 2 + 1);\n    return 0;\n  }\n  int u, v = 1, c, d;\n  u = getfar(v);\n  v = getfar(u);\n  d = getdist(u, v);\n  ans[u] = 1;\n  ans[v] = d % k;\n  for (int i = 1; i <= n; i++) {\n    int du = getdist(i, u), dv = getdist(i, v);\n    if (d == du + dv - 1)\n      ans[i] = du % k;\n    else if (du >= k && dv >= k) {\n      puts(\"No\");\n      return 0;\n    } else if (du >= dv)\n      ans[i] = du % k;\n    else\n      ans[i] = ((ans[v] - dv + 1) % k + k) % k;\n  }\n  puts(\"Yes\");\n  for (int i = 1; i <= n; i++) printf(\"%d \", ans[i] + 1);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint n, m;\nstd::vector<int> el[200100];\nint dist[200100];\nint chk[200100];\nint da[200100];\nvoid dfs(int x, int d) {\n  chk[x] = 1;\n  dist[x] = d;\n  for (int i = 0; i < el[x].size(); i++) {\n    int y = el[x][i];\n    if (chk[y] == 1) continue;\n    dfs(y, d + 1);\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n - 1; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    el[x].push_back(y);\n    el[y].push_back(x);\n  }\n  dfs(1, 0);\n  if (m == 2) {\n    printf(\"Yes\\n\");\n    for (int i = 1; i <= n; i++) {\n      printf(\"%d \", dist[i] % 2 + 1);\n    }\n    return 0;\n  }\n  int pa = 1;\n  for (int i = 1; i <= n; i++) {\n    if (dist[pa] < dist[i]) pa = i;\n    chk[i] = 0;\n  }\n  dfs(pa, 0);\n  int pb = 1;\n  for (int i = 1; i <= n; i++) {\n    if (dist[pb] < dist[i]) pb = i;\n    chk[i] = 0;\n    da[i] = dist[i];\n  }\n  dfs(pb, 0);\n  for (int i = 1; i <= n; i++) {\n    if (da[i] >= m - 1 && dist[i] >= m - 1 && da[i] + dist[i] != da[pb]) {\n      printf(\"No\\n\");\n      return 0;\n    } else if (da[i] >= dist[i]) {\n      dist[i] = da[pb] - da[i];\n    }\n  }\n  printf(\"Yes\\n\");\n  for (int i = 1; i <= n; i++) {\n    printf(\"%d \", dist[i] % m + 1);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class X, class Y>\nvoid amax(X &x, const Y &y) {\n  if (x < y) x = y;\n}\ntemplate <class X, class Y>\nvoid amin(X &x, const Y &y) {\n  if (x > y) x = y;\n}\nconst int INF = 1e9 + 10;\nconst long long INFL = (long long)1e18 + 10;\nconst int MAX = 2e5 + 10;\nint n, k;\nvector<int> da;\nvector<int> es[MAX];\nint p[MAX], cl[MAX], f[MAX];\npair<int, int> fr;\nvoid vhandle2(int u, int p) {\n  cl[u] = cl[p] ^ 1;\n  for (auto v : es[u])\n    if (v != p) vhandle2(v, u);\n}\nvoid handle2() {\n  vhandle2(1, 0);\n  for (int i = 1; i <= n; i++) cl[i]++;\n  cout << \"Yes\" << '\\n';\n  for (int i = 1; i <= n; i++) cout << cl[i] << \" \";\n  exit(0);\n}\nvoid no() {\n  cout << \"No\";\n  exit(0);\n}\nvoid vcheck(int u, int p) {\n  for (auto v : es[u])\n    if (v != p) {\n      vcheck(v, u);\n      amax(f[u], f[v]);\n    }\n  f[u]++;\n}\nvoid update(vector<int> &mx, int x) {\n  if (x >= mx[0]) {\n    mx[2] = mx[1];\n    mx[1] = mx[0];\n    mx[0] = x;\n  } else if (x >= mx[1]) {\n    mx[2] = mx[1];\n    mx[1] = x;\n  } else\n    amax(mx[2], x);\n}\nvoid v2check(int u, int p, int pf) {\n  vector<int> mx(3, 0);\n  update(mx, pf);\n  for (auto v : es[u])\n    if (v != p) update(mx, f[v]);\n  if (mx[2] > 0 && mx[1] + mx[2] + 1 >= k) no();\n  for (auto v : es[u])\n    if (v != p) {\n      if (f[v] == mx[0])\n        v2check(v, u, mx[1] + 1);\n      else\n        v2check(v, u, mx[0] + 1);\n    }\n}\nvoid check() {\n  vcheck(1, 0);\n  v2check(1, 0, 0);\n}\nvoid visit(int u, int d) {\n  auto t = make_pair(d, u);\n  if (t > fr) fr = t;\n  for (auto v : es[u])\n    if (v != p[u]) {\n      p[v] = u;\n      visit(v, d + 1);\n    }\n}\nvoid find_diameter() {\n  visit(1, 1);\n  int nn = fr.second;\n  p[nn] = 0;\n  fr = {0, 0};\n  visit(nn, 1);\n  int x = fr.second;\n  while (x != 0) {\n    da.push_back(x);\n    x = p[x];\n  }\n}\nint longest(int u, int p) {\n  int mx = 0;\n  for (auto v : es[u])\n    if (v != p) amax(mx, longest(v, u));\n  return mx + 1;\n}\nvoid paint(int u, int p, int c, int d) {\n  cl[u] = c;\n  for (auto v : es[u])\n    if (v != p) paint(v, u, c + d, d);\n}\nvoid process() {\n  cin >> n >> k;\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    cin >> u >> v;\n    es[u].push_back(v);\n    es[v].push_back(u);\n  }\n  if (k == 2) handle2();\n  check();\n  cout << \"Yes\" << '\\n';\n  find_diameter();\n  for (int i = 0; i < ((int)(da).size()); i++) {\n    cl[da[i]] = i;\n    int le = i == 0 ? -1 : da[i - 1];\n    int ri = i == ((int)(da).size()) - 1 ? -1 : da[i + 1];\n    int mx = 0;\n    for (auto v : es[da[i]])\n      if (v != le && v != ri) amax(mx, longest(v, da[i]));\n    if (mx + 1 + i >= k) {\n      for (auto v : es[da[i]])\n        if (v != le && v != ri) paint(v, da[i], i + 1, 1);\n    } else {\n      for (auto v : es[da[i]])\n        if (v != le && v != ri) paint(v, da[i], i - 1, -1);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    cl[i] %= k;\n    if (cl[i] < 0) cl[i] += k;\n    cl[i]++;\n  }\n  for (int i = 1; i <= n; i++) cout << cl[i] << \" \";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  process();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nvector<int> v[200007];\nint col[200007];\nint dep[200007];\nint mx[200007][3];\nint lst[200007];\nint diam_len;\nvoid dfs_col(int vertex, int prv, int aux) {\n  col[vertex] = aux;\n  for (auto x : v[vertex]) {\n    if (x == prv) {\n      continue;\n    }\n    dfs_col(x, vertex, 3 - aux);\n  }\n}\nvoid dfs_init(int vertex, int prv) {\n  for (auto x : v[vertex]) {\n    if (x == prv) {\n      continue;\n    }\n    dep[x] = dep[vertex] + 1;\n    dfs_init(x, vertex);\n  }\n}\nvoid dfs(int vertex, int prv) {\n  for (int i = 0; i < 3; ++i) {\n    mx[vertex][i] = -2 * 200007;\n  }\n  auto upd = [&](int x) {\n    if (mx[vertex][0] < x) {\n      mx[vertex][2] = mx[vertex][1];\n      mx[vertex][1] = mx[vertex][0];\n      mx[vertex][0] = x;\n    } else if (mx[vertex][1] < x) {\n      mx[vertex][2] = mx[vertex][1];\n      mx[vertex][1] = x;\n    } else if (mx[vertex][2] < x) {\n      mx[vertex][2] = x;\n    }\n  };\n  for (auto x : v[vertex]) {\n    if (x == prv) {\n      continue;\n    }\n    dep[x] = dep[vertex] + 1;\n    lst[x] = vertex;\n    dfs(x, vertex);\n    upd(mx[x][0] + 1);\n  }\n  if (mx[vertex][0] < 0) {\n    mx[vertex][0] = 0;\n  }\n}\nvoid rec_fill(int vertex, int prv, int dir) {\n  col[vertex] = col[prv] + dir;\n  if (col[vertex] > k) {\n    col[vertex] = 1;\n  }\n  if (col[vertex] <= 0) {\n    col[vertex] = k;\n  }\n  for (auto x : v[vertex]) {\n    if (x == prv) {\n      continue;\n    }\n    rec_fill(x, vertex, dir);\n  }\n}\nvoid mark_col(int vertex, int prv) {\n  for (auto x : v[vertex]) {\n    if (x == prv) {\n      continue;\n    }\n    if (col[x] == 0) {\n      if (dep[vertex] <= (diam_len / 2)) {\n        rec_fill(x, vertex, 1);\n      } else {\n        rec_fill(x, vertex, -1);\n      }\n    } else {\n      mark_col(x, vertex);\n    }\n  }\n}\nvoid input() {\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i < n; ++i) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n}\nvoid solve() {\n  if (k == 2) {\n    dfs_col(1, -1, 1);\n    printf(\"Yes\\n\");\n    for (int i = 1; i <= n; ++i) {\n      printf(\"%d \", col[i]);\n    }\n    printf(\"\\n\");\n    return;\n  }\n  dfs_init(1, -1);\n  int root = 1;\n  for (int i = 1; i <= n; ++i) {\n    if (dep[i] > dep[root]) {\n      root = i;\n    }\n  }\n  dep[root] = 0;\n  dfs(root, -1);\n  for (int i = 1; i <= n; ++i) {\n    if (mx[i][1] + mx[i][2] + 1 >= k) {\n      printf(\"No\\n\");\n      return;\n    }\n    if (mx[i][0] + mx[i][1] + 1 >= k && mx[i][1] + dep[i] + 1 >= k) {\n      printf(\"No\\n\");\n      return;\n    }\n  }\n  int target = 1;\n  for (int i = 1; i <= n; ++i) {\n    if (dep[i] > dep[target]) {\n      target = i;\n    }\n  }\n  diam_len = dep[target];\n  int dummy = target, tp = 1;\n  while (dummy != 0) {\n    col[dummy] = tp++;\n    if (tp > k) {\n      tp = 1;\n    }\n    dummy = lst[dummy];\n  }\n  mark_col(root, -1);\n  printf(\"Yes\\n\");\n  for (int i = 1; i <= n; ++i) {\n    printf(\"%d \", col[i]);\n  }\n  printf(\"\\n\");\n}\nint main() {\n  ios_base ::sync_with_stdio(false);\n  cin.tie(NULL);\n  int t;\n  t = 1;\n  while (t--) {\n    input();\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200005;\nvector<int> v[N];\nint n, kk;\nint dis[N], ans[N];\nvoid dfs1(int pos, int fa) {\n  for (auto &i : v[pos])\n    if (i != fa) dfs1(i, pos), dis[pos] = max(dis[pos], dis[i]);\n  ++dis[pos];\n}\nbool dfs2(int pos, int fa, const multiset<int, greater<int>> &mt) {\n  multiset<int, greater<int>> d;\n  int mx = 0;\n  for (auto &i : v[pos])\n    if (i != fa)\n      d.insert(dis[i]);\n    else\n      mx = 1;\n  bool fs = 1;\n  for (auto &i : mt) {\n    if (i == dis[pos] && fs) {\n      fs = 0;\n      continue;\n    }\n    mx = i + 1;\n    break;\n  }\n  if (mx) d.insert(mx);\n  while (d.size() > 3) d.erase(prev(d.end()));\n  if (d.size() > 2 && *next(d.begin()) + *next(next(d.begin())) >= kk - 1) {\n    cout << \"No\" << endl;\n    return 0;\n  }\n  for (auto &i : v[pos])\n    if (i != fa && !dfs2(i, pos, d)) return 0;\n  return 1;\n}\nint dep[N], f[N];\nvoid dfs(int pos, int fa) {\n  dep[pos] = dep[fa] + 1;\n  f[pos] = fa;\n  for (auto &i : v[pos])\n    if (i != fa) dfs(i, pos);\n}\nvoid dfs3(int pos, int fa, int cur, int dd) {\n  ans[pos] = cur;\n  for (auto &i : v[pos])\n    if (i != fa) dfs3(i, pos, (cur + dd + kk) % kk, dd);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> n >> kk;\n  int t1, t2;\n  for (int i = 1; i < n; i++) {\n    cin >> t1 >> t2;\n    v[t1].push_back(t2);\n    v[t2].push_back(t1);\n  }\n  dfs1(1, 0);\n  if (kk != 2 && !dfs2(1, 0, {})) return 0;\n  cout << \"Yes\" << endl;\n  if (kk == 2) {\n    dfs3(1, 0, 0, 1);\n    for (int i = 1; i <= n; i++) cout << ans[i] + 1 << ' ';\n    return 0;\n  }\n  dfs(1, 0);\n  t1 = max_element(dep + 1, dep + n + 1) - dep;\n  dfs(t1, 0);\n  t2 = max_element(dep + 1, dep + n + 1) - dep;\n  vector<int> d{t2};\n  while (f[t2]) d.push_back(t2 = f[t2]);\n  int mid = (d.size() + 1) / 2 - 1;\n  dfs3(d[mid], d[mid + 1], mid % kk, -1);\n  dfs3(d[mid + 1], d[mid], (mid + 1) % kk, 1);\n  for (int i = 1; i <= n; i++) cout << ans[i] + 1 << ' ';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint h[400010], d[400010], v[400010 * 2], nxt[400010 * 2], ec, n, m, od[400010];\nvoid add(int x, int y) {\n  v[++ec] = y;\n  nxt[ec] = h[x];\n  h[x] = ec;\n}\nvoid dfs(int x, int fa) {\n  d[x] = d[fa] + 1;\n  for (int i = h[x]; i; i = nxt[i])\n    if (v[i] != fa) dfs(v[i], x);\n}\nint main() {\n  cin >> n >> m;\n  for (int i = 1; i < n; i++) {\n    int x, y;\n    cin >> x >> y;\n    add(x, y);\n    add(y, x);\n  }\n  d[0] = -1;\n  dfs(1, 0);\n  if (m == 2) {\n    puts(\"Yes\");\n    for (int i = 1; i <= n; i++) printf(\"%d \", d[i] % 2 + 1);\n    return 0;\n  }\n  int p = 1, t = 1;\n  for (int i = 1; i <= n; i++)\n    if (d[p] < d[i]) p = i;\n  dfs(p, 0);\n  for (int i = 1; i <= n; i++) {\n    if (d[t] < d[i]) t = i;\n    od[i] = d[i];\n  }\n  dfs(t, 0);\n  for (int i = 1; i <= n; i++) {\n    if (od[i] > m - 2 && d[i] > m - 2 && d[i] + od[i] != od[t]) {\n      puts(\"No\");\n      return 0;\n    } else if (od[i] >= d[i])\n      d[i] = od[t] - od[i];\n  }\n  puts(\"Yes\");\n  for (int i = 1; i <= n; i++) printf(\"%d \", d[i] % m + 1);\n}\n"
        }
    ]
}