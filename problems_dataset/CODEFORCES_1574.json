{
    "name": "1574_F. Occurrences",
    "source": "CODEFORCES",
    "description": "A subarray of array a from index l to the index r is the array [a_l, a_{l+1}, ..., a_{r}]. The number of occurrences of the array b in the array a is the number of subarrays of a such that they are equal to b.\n\nYou are given n arrays A_1, A_2, ..., A_n; the elements of these arrays are integers from 1 to k. You have to build an array a consisting of m integers from 1 to k in such a way that, for every given subarray A_i, the number of occurrences of A_i in the array a is not less than the number of occurrences of each non-empty subarray of A_i in a. Note that if A_i doesn't occur in a, and no subarray of A_i occurs in a, this condition is still met for A_i.\n\nYour task is to calculate the number of different arrays a you can build, and print it modulo 998244353.\n\nInput\n\nThe first line contains three integers n, m and k (1 \u2264 n, m, k \u2264 3 \u22c5 10^5) \u2014 the number of the given arrays, the desired length of the array a, and the upper bound on the values in the arrays.\n\nThen n lines follow. The i-th line represents the array A_i. The first integer in the i-th line is c_i (1 \u2264 c_i \u2264 m) \u2014 the number of elements in A_i; then, c_i integers from 1 to k follow \u2014 the elements of the array A_i.\n\nAdditional constraint on the input: \u2211_{i=1}^n c_i \u2264 3 \u22c5 10^5; i. e., the number of elements in the given arrays in total does not exceed 3 \u22c5 10^5.\n\nOutput\n\nPrint one integer \u2014 the number of different arrays a you can build, taken modulo 998244353.\n\nExamples\n\nInput\n\n\n2 4 3\n2 1 2\n1 3\n\n\nOutput\n\n\n5\n\n\nInput\n\n\n2 4 3\n2 1 2\n3 3 2 1\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n1 42 1337\n2 13 31\n\n\nOutput\n\n\n721234447",
    "difficulty": "F",
    "tags": [
        "combinatorics",
        "dfs and similar",
        "dp",
        "dsu",
        "fft",
        "graphs"
    ],
    "rating": 2700,
    "public_test": [
        {
            "input": "2 4 3\n2 1 2\n3 3 2 1\n",
            "output": "0\n"
        },
        {
            "input": "2 4 3\n2 1 2\n1 3\n",
            "output": "5\n"
        },
        {
            "input": "1 42 1337\n2 13 31\n",
            "output": "721234447\n"
        }
    ],
    "generated_test": [
        {
            "input": "2 2 3\n2 1 2\n2 2 1\n",
            "output": "1\n"
        },
        {
            "input": "3 100 5\n2 2 5\n2 3 4\n2 1 3\n",
            "output": "156631805\n"
        },
        {
            "input": "2 7 5\n2 1 2\n3 5 1 5\n",
            "output": "128\n"
        },
        {
            "input": "58 3 60\n3 59 45 6\n3 30 4 1\n1 45\n1 50\n2 43 32\n2 13 20\n2 26 20\n2 29 41\n2 49 39\n2 19 47\n3 31 37 45\n3 13 14 31\n1 44\n1 21\n1 48\n3 5 53 7\n1 12\n3 35 2 1\n1 37\n2 46 38\n1 32\n2 22 60\n1 50\n3 37 20 17\n2 19 37\n3 58 31 42\n2 37 57\n2 9 24\n1 1\n1 22\n3 7 51 25\n3 37 38 30\n3 27 33 36\n3 41 47 57\n2 24 54\n2 5 35\n3 53 27 24\n2 4 25\n3 25 6 36\n3 30 58 44\n1 19\n1 26\n1 10\n1 33\n3 52 40 11\n1 19\n1 11\n1 60\n2 57 7\n2 21 28\n2 26 56\n2 47 53\n1 46\n3 11 11 45\n2 6 8\n2 49 40\n1 25\n2 17 35\n",
            "output": "1397\n"
        },
        {
            "input": "2 5 10\n2 9 8\n5 8 7 6 9 2\n",
            "output": "3125\n"
        },
        {
            "input": "2 114514 1919\n2 4 1\n2 3 1\n",
            "output": "394617181\n"
        },
        {
            "input": "9 8 2\n2 2 1\n1 1\n2 2 1\n2 2 1\n2 2 1\n2 2 2\n2 1 2\n2 1 2\n2 2 1\n",
            "output": "0\n"
        },
        {
            "input": "1 7 8\n4 1 4 8 3\n2 8 2\n",
            "output": "16640\n"
        },
        {
            "input": "2 3 5\n2 1 2\n2 1 3\n",
            "output": "8\n"
        },
        {
            "input": "26 5 88\n5 19 24 67 87 4\n3 78 28 76\n4 13 88 73 82\n5 35 75 62 54 4\n5 4 55 56 28 77\n3 19 48 81\n1 66\n4 28 40 83 59\n4 22 46 68 10\n5 52 67 53 62 53\n4 2 56 55 7\n3 87 11 75\n2 29 10\n5 79 51 17 82 2\n2 53 71\n2 74 50\n2 7 78\n1 60\n1 26\n5 30 81 28 37 79\n1 23\n1 35\n1 50\n4 17 12 76 75\n4 63 15 59 72\n1 85\n",
            "output": "130987710\n"
        },
        {
            "input": "6 10 94\n5 27 15 11 28 91\n2 27 79\n4 25 21 78 71\n4 19 83 4 23\n2 9 40\n7 43 83 40 18 16 86 92\n",
            "output": "653915924\n"
        },
        {
            "input": "1 300000 300000\n1 42654\n",
            "output": "607932985\n"
        },
        {
            "input": "1 41 1337\n2 13 31\n",
            "output": "120467814\n"
        },
        {
            "input": "58 3 60\n3 59 45 6\n3 30 4 1\n1 45\n1 50\n2 43 32\n2 13 20\n2 26 20\n2 57 41\n2 49 39\n2 19 47\n3 31 37 45\n3 13 14 31\n1 44\n1 21\n1 48\n3 5 53 7\n1 12\n3 35 2 1\n1 37\n2 46 38\n1 32\n2 22 60\n1 50\n3 37 20 17\n2 19 37\n3 58 31 42\n2 37 57\n2 9 24\n1 1\n1 22\n3 7 51 25\n3 37 38 30\n3 27 33 36\n3 41 47 57\n2 24 54\n2 5 35\n3 53 27 24\n2 4 25\n3 25 6 36\n3 30 58 44\n1 19\n1 26\n1 10\n1 33\n3 52 40 11\n1 19\n1 11\n1 60\n2 57 7\n2 21 28\n2 26 56\n2 47 53\n1 46\n3 11 11 45\n2 6 8\n2 49 40\n1 25\n2 17 35\n",
            "output": "1800\n"
        },
        {
            "input": "0 7 8\n4 1 4 8 3\n2 8 2\n",
            "output": "2097152\n"
        },
        {
            "input": "26 5 88\n5 19 24 67 87 4\n3 78 28 76\n4 13 88 73 82\n5 35 75 62 54 4\n5 4 55 56 28 77\n3 19 48 81\n1 66\n4 28 40 83 59\n4 22 46 68 10\n5 52 67 53 62 53\n4 2 56 55 7\n3 87 11 75\n2 29 7\n5 79 51 17 82 2\n2 53 71\n2 74 50\n2 7 78\n1 60\n1 26\n5 30 81 28 37 79\n1 23\n1 35\n1 50\n4 17 12 76 75\n4 63 15 59 72\n1 85\n",
            "output": "130987794\n"
        },
        {
            "input": "2 5 10\n2 9 4\n5 8 7 6 9 4\n",
            "output": "3126\n"
        },
        {
            "input": "2 5 4\n2 1 1\n2 1 3\n",
            "output": "32\n"
        },
        {
            "input": "0 114514 1919\n2 2 1\n2 3 1\n",
            "output": "81228828\n"
        },
        {
            "input": "11 3 52\n2 18 9\n3 36 12 35\n1 38\n1 43\n3 11 32 24\n3 21 7 37\n2 12 36\n1 50\n3 11 26 17\n3 29 11 29\n2 47 38\n",
            "output": "46801\n"
        },
        {
            "input": "48 3 63\n3 59 8 11\n1 62\n2 1 23\n1 55\n2 15 27\n1 14\n1 28\n1 19\n2 26 20\n1 9\n3 42 17 23\n1 49\n2 28 54\n1 26\n2 8 26\n3 38 15 35\n3 42 11 62\n1 37\n3 43 9 40\n3 5 46 27\n1 63\n2 15 48\n1 44\n3 35 2 26\n3 25 37 14\n3 7 62 17\n2 60 41\n2 11 21\n2 49 18\n3 31 42 46\n1 26\n1 11\n3 34 47 31\n2 9 9\n2 43 20\n3 49 19 47\n3 13 25 53\n1 43\n1 7\n1 49\n2 36 32\n3 61 26 10\n1 60\n2 22 29\n2 28 23\n2 48 55\n3 1 38 27\n1 60\n",
            "output": "5940\n"
        },
        {
            "input": "26 5 88\n5 19 24 67 87 4\n3 78 28 76\n4 13 88 73 82\n5 35 75 62 54 4\n5 4 55 56 28 77\n3 19 48 81\n1 66\n4 28 40 83 59\n4 22 46 68 10\n5 52 67 53 62 53\n4 4 56 55 7\n3 87 11 75\n2 29 10\n5 79 51 17 82 2\n2 53 71\n2 74 50\n2 7 78\n1 60\n1 26\n5 30 81 28 37 79\n1 23\n1 35\n1 50\n4 17 12 76 75\n4 63 15 59 87\n1 85\n",
            "output": "147326600\n"
        },
        {
            "input": "4 8 9\n3 5 8 1\n3 4 6 7\n2 9 5\n2 7 5\n",
            "output": "256\n"
        },
        {
            "input": "6 10 186\n5 27 15 11 28 91\n2 25 79\n4 25 21 78 71\n4 19 83 4 23\n2 9 40\n7 43 83 40 18 16 86 92\n",
            "output": "678188264\n"
        },
        {
            "input": "57 2 76\n2 28 15\n2 66 13\n1 26\n1 50\n1 35\n2 68 21\n1 71\n1 23\n2 40 7\n2 6 53\n2 57 25\n2 17 47\n2 44 13\n1 49\n2 47 15\n2 37 9\n2 48 1\n1 60\n1 49\n2 12 12\n1 40\n1 5\n1 14\n1 71\n2 15 72\n1 75\n2 62 12\n2 76 61\n2 8 9\n1 24\n1 31\n2 41 52\n2 53 20\n1 9\n2 67 22\n2 1 67\n2 72 4\n1 49\n1 32\n1 4\n1 12\n1 57\n1 51\n1 29\n2 29 20\n1 21\n2 1 30\n1 8\n1 11\n2 58 32\n2 61 68\n2 65 40\n2 8 12\n2 50 68\n2 24 56\n2 48 8\n1 40\n",
            "output": "1373\n"
        },
        {
            "input": "1 196598 300000\n1 55320\n",
            "output": "563450246\n"
        },
        {
            "input": "2 4 3\n2 1 3\n1 3\n",
            "output": "5\n"
        },
        {
            "input": "1 42 418\n2 13 31\n",
            "output": "856343832\n"
        },
        {
            "input": "2 7 10\n2 1 2\n3 5 1 5\n",
            "output": "823543\n"
        },
        {
            "input": "58 3 60\n3 59 45 6\n3 30 4 1\n1 45\n1 50\n2 43 32\n2 13 20\n2 26 20\n2 29 41\n2 49 39\n2 19 47\n3 31 37 45\n3 13 14 31\n1 44\n1 21\n1 48\n3 5 53 7\n1 12\n3 35 2 1\n1 37\n2 46 38\n1 32\n2 22 60\n1 50\n3 37 20 17\n2 19 37\n3 58 31 42\n2 37 57\n2 9 24\n1 1\n1 22\n3 7 51 25\n3 37 15 30\n3 27 33 36\n3 41 47 57\n2 24 54\n2 5 35\n3 53 27 24\n2 4 25\n3 25 6 36\n3 30 58 44\n1 19\n1 26\n1 10\n1 33\n3 52 40 11\n1 19\n1 11\n1 60\n2 57 7\n2 21 28\n2 26 56\n2 47 53\n1 46\n3 11 11 45\n2 6 8\n2 49 40\n1 25\n2 17 35\n",
            "output": "1080\n"
        },
        {
            "input": "2 114514 1919\n2 4 1\n2 3 2\n",
            "output": "931718856\n"
        },
        {
            "input": "2 3 5\n2 1 1\n2 1 3\n",
            "output": "27\n"
        },
        {
            "input": "3 100 5\n2 2 5\n3 3 4\n2 1 4\n",
            "output": "783005360\n"
        },
        {
            "input": "26 5 88\n5 19 24 67 87 4\n3 78 28 76\n4 13 88 73 82\n5 35 75 62 54 4\n5 4 55 56 28 77\n3 19 48 81\n1 66\n4 28 40 83 59\n4 22 46 68 10\n5 52 67 53 62 53\n4 2 56 55 7\n3 87 11 75\n2 29 7\n5 79 51 17 82 2\n2 53 71\n2 74 50\n2 1 78\n1 60\n1 26\n5 30 81 28 37 79\n1 23\n1 35\n1 50\n4 17 12 76 75\n4 63 15 59 72\n1 85\n",
            "output": "116132090\n"
        },
        {
            "input": "1 41 601\n2 16 31\n",
            "output": "545172274\n"
        },
        {
            "input": "2 5 10\n2 9 4\n5 8 7 6 2 4\n",
            "output": "1024\n"
        },
        {
            "input": "11 3 52\n2 18 9\n3 36 12 35\n1 38\n1 43\n3 11 32 24\n3 21 7 37\n2 12 36\n1 50\n3 11 26 17\n3 29 11 29\n1 47 38\n",
            "output": "54949\n"
        },
        {
            "input": "26 5 88\n5 19 24 67 87 4\n3 78 28 76\n4 13 88 73 82\n5 35 75 62 54 4\n5 4 55 56 28 77\n3 19 48 81\n1 66\n4 28 40 83 59\n4 22 46 68 10\n5 52 67 53 62 53\n4 4 56 55 7\n3 87 11 75\n2 29 10\n5 79 51 17 82 2\n2 53 71\n2 74 50\n2 7 78\n1 60\n1 26\n5 30 81 28 37 79\n1 23\n1 35\n1 50\n4 17 12 76 75\n4 63 13 59 87\n1 85\n",
            "output": "165257092\n"
        },
        {
            "input": "1 196598 224852\n1 55320\n",
            "output": "932426663\n"
        },
        {
            "input": "2 7 10\n1 1 2\n3 5 1 5\n",
            "output": "2298912\n"
        },
        {
            "input": "2 114514 1484\n2 4 1\n2 3 2\n",
            "output": "926826632\n"
        },
        {
            "input": "2 1 5\n2 1 1\n2 1 3\n",
            "output": "3\n"
        },
        {
            "input": "3 100 5\n2 2 2\n3 3 4\n2 1 4\n",
            "output": "882499718\n"
        },
        {
            "input": "58 3 60\n3 59 45 6\n3 30 4 1\n1 45\n1 50\n2 43 32\n2 13 20\n2 26 20\n2 57 41\n2 49 39\n2 19 47\n3 31 37 45\n3 13 14 31\n1 44\n1 21\n1 48\n3 5 53 7\n1 12\n3 35 2 1\n1 37\n2 46 38\n1 32\n2 22 60\n1 50\n3 37 20 17\n2 19 37\n3 58 31 42\n2 37 57\n2 9 24\n1 1\n1 22\n3 7 51 25\n3 37 38 30\n3 27 33 36\n3 41 47 57\n2 24 54\n2 5 35\n3 53 27 24\n2 4 25\n3 25 6 36\n3 30 58 44\n1 19\n1 26\n1 10\n1 33\n3 52 40 11\n1 19\n1 20\n1 60\n2 57 7\n2 38 28\n2 26 56\n2 47 53\n1 46\n3 11 11 45\n2 6 8\n2 49 40\n1 25\n2 17 35\n",
            "output": "2249\n"
        },
        {
            "input": "1 42 601\n2 16 31\n",
            "output": "981048532\n"
        },
        {
            "input": "0 5 8\n4 1 2 8 3\n2 8 2\n",
            "output": "32768\n"
        },
        {
            "input": "58 6 60\n3 59 45 6\n3 30 4 1\n1 45\n1 2\n2 43 32\n2 13 20\n2 26 20\n2 57 41\n2 49 39\n2 19 47\n3 31 37 45\n3 13 14 31\n1 44\n1 21\n1 48\n3 5 53 7\n1 12\n3 35 2 1\n1 37\n2 46 38\n1 32\n2 22 60\n1 50\n3 37 20 17\n2 19 37\n3 58 31 42\n2 37 57\n2 9 24\n1 1\n1 22\n3 7 51 25\n3 37 38 48\n3 27 33 36\n3 41 47 57\n2 24 54\n2 5 35\n3 53 27 24\n2 4 25\n3 25 6 36\n3 30 58 44\n1 19\n1 26\n1 10\n1 33\n3 52 40 11\n1 19\n1 11\n1 60\n2 57 7\n2 21 28\n2 26 56\n2 47 53\n1 46\n3 11 11 45\n2 6 8\n2 49 40\n1 38\n2 17 35\n",
            "output": "1997737\n"
        },
        {
            "input": "0 7 6\n4 1 1 8 2\n2 0 2\n",
            "output": "279936\n"
        },
        {
            "input": "0 114514 1268\n2 2 1\n2 0 1\n",
            "output": "927781931\n"
        },
        {
            "input": "11 3 52\n2 18 9\n3 36 12 7\n1 38\n1 43\n3 11 32 24\n3 21 7 37\n2 12 36\n1 50\n3 11 26 17\n3 29 11 29\n1 47 38\n",
            "output": "59397\n"
        },
        {
            "input": "48 3 63\n3 59 8 11\n1 62\n2 1 23\n1 55\n2 15 27\n1 14\n1 28\n1 19\n2 18 20\n1 9\n3 42 17 23\n1 49\n2 28 54\n1 26\n2 8 26\n3 38 15 35\n3 42 11 62\n1 37\n3 43 9 40\n3 5 46 27\n1 63\n2 15 48\n1 44\n3 35 2 26\n3 25 37 14\n3 7 62 17\n2 60 41\n2 11 21\n2 49 18\n3 31 42 46\n1 26\n1 11\n3 34 36 31\n2 9 9\n2 43 20\n3 49 19 47\n3 13 25 53\n1 43\n1 7\n1 49\n2 36 32\n3 61 26 10\n1 60\n2 22 29\n2 28 23\n2 48 55\n3 1 38 27\n1 60\n",
            "output": "5904\n"
        },
        {
            "input": "4 8 9\n3 4 8 1\n3 4 8 7\n2 9 5\n2 7 5\n",
            "output": "6561\n"
        },
        {
            "input": "1 2217 224852\n1 55320\n",
            "output": "612253731\n"
        },
        {
            "input": "2 7 10\n1 1 3\n3 5 1 5\n",
            "output": "835569\n"
        },
        {
            "input": "6 18 186\n5 27 15 11 28 91\n2 25 79\n4 25 21 78 71\n4 19 83 4 23\n2 9 40\n7 43 83 40 8 16 157 92\n",
            "output": "102522996\n"
        },
        {
            "input": "1 1427 224852\n1 55320\n",
            "output": "233475856\n"
        },
        {
            "input": "11 3 52\n2 18 9\n3 2 12 7\n1 38\n1 43\n3 11 32 24\n3 21 7 37\n2 21 36\n1 50\n3 11 26 17\n3 29 11 29\n1 47 38\n",
            "output": "54948\n"
        },
        {
            "input": "0 7 10\n1 1 3\n3 5 1 8\n",
            "output": "10000000\n"
        },
        {
            "input": "0 10 3\n3 2 3 1 2\n",
            "output": "59049\n"
        },
        {
            "input": "0 5 12\n7 1 1 10 3\n2 8 2\n",
            "output": "248832\n"
        },
        {
            "input": "0 3 6\n0 0 1 8 2\n1 0 2\n",
            "output": "216\n"
        },
        {
            "input": "0 1 11\n4 3 0 16 0\n1 -1 2\n",
            "output": "11\n"
        },
        {
            "input": "6 18 186\n5 27 15 5 28 91\n2 25 79\n4 25 21 5 71\n4 19 83 4 23\n2 9 40\n7 43 83 40 8 14 157 92\n",
            "output": "554639233\n"
        },
        {
            "input": "1 1427 270311\n1 3138\n",
            "output": "496034248\n"
        },
        {
            "input": "0 2 8\n4 1 3 0 2\n0 8 0\n",
            "output": "64\n"
        },
        {
            "input": "0 1 14\n4 3 0 16 0\n1 -1 2\n",
            "output": "14\n"
        },
        {
            "input": "0 114514 1155\n4 1 2\n3 0 1\n",
            "output": "947822446\n"
        },
        {
            "input": "0 11 10\n1 1 3\n3 7 1 13\n",
            "output": "175564700\n"
        },
        {
            "input": "0 1 16\n4 3 0 16 0\n1 -1 2\n",
            "output": "16\n"
        },
        {
            "input": "6 18 186\n5 27 15 7 28 91\n2 25 79\n4 25 26 5 71\n4 19 83 4 42\n2 9 63\n7 43 83 40 8 14 157 92\n",
            "output": "667821325\n"
        },
        {
            "input": "6 18 186\n5 27 15 7 28 91\n2 25 79\n4 25 26 5 71\n4 19 83 7 42\n2 9 63\n7 43 83 40 8 14 157 92\n",
            "output": "340253039\n"
        },
        {
            "input": "0 1 6\n2 2 1\n2 -1 2\n",
            "output": "6\n"
        },
        {
            "input": "0 6 10\n0 1 3\n3 8 1 13\n",
            "output": "1000000\n"
        },
        {
            "input": "1 1 6\n2 2 1\n2 -1 2\n",
            "output": "4\n"
        },
        {
            "input": "0 6 19\n0 1 3\n3 8 1 13\n",
            "output": "47045881\n"
        },
        {
            "input": "1 1 12\n2 2 1\n2 -1 2\n",
            "output": "10\n"
        },
        {
            "input": "0 3 8\n0 -1 -1 6 0\n0 0 1\n",
            "output": "512\n"
        },
        {
            "input": "0 4 10\n0 2 3\n3 8 0 11\n",
            "output": "10000\n"
        },
        {
            "input": "0 1 15\n0 0 0 6 -1\n0 0 1\n",
            "output": "15\n"
        },
        {
            "input": "0 4 3\n0 2 3\n1 38 0 11\n",
            "output": "81\n"
        },
        {
            "input": "15 10 2\n3 2 1\n1 2\n2 2 1\n2 2 1\n2 2 1\n2 1 2\n2 2 1\n1 2\n2 1 2\n2 2 1\n2 1 2\n1 1\n2 1 2\n1 2\n2 1 2\n",
            "output": "0\n"
        },
        {
            "input": "1 5 3\n4 2 2 1 2\n",
            "output": "1\n"
        },
        {
            "input": "19 7 2\n2 1 2\n1 1\n2 1 2\n2 2 1\n2 1 2\n1 1\n2 2 1\n1 2\n2 1 2\n1 2\n1 2\n2 1 2\n2 2 1\n2 2 1\n2 2 1\n2 1 2\n1 2\n2 1 2\n2 1 2\n",
            "output": "0\n"
        },
        {
            "input": "2 4 3\n2 1 2\n3 3 2 2\n",
            "output": "0\n"
        },
        {
            "input": "2 2 2\n2 1 2\n2 2 1\n",
            "output": "0\n"
        },
        {
            "input": "3 100 5\n2 2 5\n2 3 4\n2 1 4\n",
            "output": "1\n"
        },
        {
            "input": "9 8 2\n2 2 1\n1 1\n2 2 2\n2 2 1\n2 2 1\n2 2 2\n2 1 2\n2 1 2\n2 2 1\n",
            "output": "0\n"
        },
        {
            "input": "15 10 2\n3 2 1\n2 2\n2 2 1\n2 2 1\n2 2 1\n2 1 2\n2 2 1\n1 2\n2 1 2\n2 2 1\n2 1 2\n1 1\n2 1 2\n1 2\n2 1 2\n",
            "output": "0\n"
        },
        {
            "input": "19 7 2\n2 1 2\n1 1\n2 1 2\n2 2 1\n2 1 2\n1 1\n2 2 1\n1 2\n2 1 2\n1 2\n1 2\n2 1 1\n2 2 1\n2 2 1\n2 2 1\n2 1 2\n1 2\n2 1 2\n2 1 2\n",
            "output": "0\n"
        },
        {
            "input": "1 41 1337\n2 16 31\n",
            "output": "120467814\n"
        },
        {
            "input": "3 100 5\n2 1 5\n2 3 4\n2 1 4\n",
            "output": "1\n"
        },
        {
            "input": "58 3 60\n3 59 45 6\n3 30 4 1\n1 45\n1 50\n2 43 32\n2 13 20\n2 26 20\n2 57 41\n2 49 39\n2 19 47\n3 31 37 45\n3 13 14 31\n1 44\n1 21\n1 48\n3 5 53 7\n1 12\n3 35 2 1\n1 37\n2 46 38\n1 32\n2 22 60\n1 50\n3 37 20 17\n2 19 37\n3 58 31 42\n2 37 57\n2 9 24\n1 1\n1 22\n3 7 51 25\n3 37 38 30\n3 27 33 36\n3 41 47 57\n2 24 54\n2 5 35\n3 53 27 24\n2 4 25\n3 25 6 36\n3 30 58 44\n1 19\n1 26\n1 10\n1 33\n3 52 40 11\n1 19\n1 11\n1 60\n2 57 7\n2 21 28\n2 26 56\n2 47 53\n1 46\n3 11 11 45\n2 6 8\n2 49 40\n1 38\n2 17 35\n",
            "output": "1800\n"
        },
        {
            "input": "9 8 2\n2 2 1\n1 1\n2 2 2\n1 2 1\n2 2 1\n2 2 2\n2 1 2\n2 1 2\n2 2 1\n",
            "output": "0\n"
        },
        {
            "input": "0 7 8\n4 1 1 8 3\n2 8 2\n",
            "output": "2097152\n"
        },
        {
            "input": "15 10 2\n3 2 1\n2 2\n2 2 1\n2 2 1\n2 2 1\n2 1 2\n2 2 1\n1 2\n4 1 2\n2 2 1\n2 1 2\n1 1\n2 1 2\n1 2\n2 1 2\n",
            "output": "0\n"
        },
        {
            "input": "58 3 60\n3 59 45 6\n3 30 4 1\n1 45\n1 50\n2 43 32\n2 13 20\n2 26 20\n2 57 41\n2 49 39\n2 19 47\n3 31 37 45\n3 13 14 31\n1 44\n1 21\n1 48\n3 5 53 7\n1 12\n3 35 2 1\n1 37\n2 46 38\n1 32\n2 22 60\n1 50\n3 37 20 17\n2 19 37\n3 58 31 42\n2 37 57\n2 9 24\n1 1\n1 22\n3 7 51 25\n3 37 38 48\n3 27 33 36\n3 41 47 57\n2 24 54\n2 5 35\n3 53 27 24\n2 4 25\n3 25 6 36\n3 30 58 44\n1 19\n1 26\n1 10\n1 33\n3 52 40 11\n1 19\n1 11\n1 60\n2 57 7\n2 21 28\n2 26 56\n2 47 53\n1 46\n3 11 11 45\n2 6 8\n2 49 40\n1 38\n2 17 35\n",
            "output": "1397\n"
        },
        {
            "input": "9 8 2\n2 2 1\n1 1\n2 2 2\n1 2 1\n2 2 1\n2 2 2\n2 1 2\n2 1 2\n2 2 2\n",
            "output": "0\n"
        },
        {
            "input": "0 7 8\n4 1 1 8 3\n2 0 2\n",
            "output": "2097152\n"
        },
        {
            "input": "0 1 8\n4 1 1 8 3\n2 0 2\n",
            "output": "8\n"
        },
        {
            "input": "0 1 8\n4 2 1 8 3\n2 0 2\n",
            "output": "8\n"
        },
        {
            "input": "0 1 8\n4 2 1 8 3\n2 -1 2\n",
            "output": "8\n"
        },
        {
            "input": "3 5 3\n2 1 2\n2 2 3\n2 1 1\n",
            "output": "0\n"
        },
        {
            "input": "8 3 3\n1 2\n2 1 2\n1 3\n2 2 3\n1 1\n3 1 2 3\n2 3 1\n2 3 1\n",
            "output": "0\n"
        },
        {
            "input": "58 3 60\n3 59 45 6\n3 30 4 1\n1 45\n1 50\n2 43 32\n2 13 20\n2 26 20\n2 29 41\n2 49 39\n2 19 47\n3 31 37 45\n3 13 17 31\n1 44\n1 21\n1 48\n3 5 53 7\n1 12\n3 35 2 1\n1 37\n2 46 38\n1 32\n2 22 60\n1 50\n3 37 20 17\n2 19 37\n3 58 31 42\n2 37 57\n2 9 24\n1 1\n1 22\n3 7 51 25\n3 37 38 30\n3 27 33 36\n3 41 47 57\n2 24 54\n2 5 35\n3 53 27 24\n2 4 25\n3 25 6 36\n3 30 58 44\n1 19\n1 26\n1 10\n1 24\n3 52 40 11\n1 19\n1 11\n1 60\n2 57 7\n2 21 28\n2 26 56\n2 47 53\n1 46\n3 11 11 45\n2 6 8\n2 49 40\n1 25\n2 17 35\n",
            "output": "1800\n"
        },
        {
            "input": "9 8 2\n2 2 1\n1 1\n2 1 1\n2 2 1\n2 2 1\n2 1 2\n2 1 2\n2 1 2\n2 2 1\n",
            "output": "0\n"
        },
        {
            "input": "19 6 2\n2 1 2\n1 1\n2 1 2\n1 2 1\n2 1 2\n1 1\n2 2 1\n1 2\n2 1 2\n1 2\n1 2\n2 1 2\n2 2 1\n2 2 1\n2 2 1\n2 1 2\n1 2\n2 1 2\n2 1 2\n",
            "output": "0\n"
        },
        {
            "input": "2 1 3\n2 1 2\n2 2 1\n",
            "output": "1\n"
        },
        {
            "input": "15 10 2\n3 2 1\n1 2\n1 2 1\n2 2 1\n2 2 1\n2 1 2\n2 2 1\n1 2\n2 1 2\n2 2 1\n2 1 2\n1 1\n2 1 2\n1 2\n2 1 2\n",
            "output": "0\n"
        },
        {
            "input": "1 5 3\n4 2 3 1 2\n",
            "output": "0\n"
        },
        {
            "input": "26 5 88\n5 19 24 67 87 4\n3 78 28 76\n4 13 88 73 82\n5 35 75 62 54 4\n5 4 55 56 28 69\n3 19 48 81\n1 66\n4 28 40 83 59\n4 22 46 68 10\n5 52 67 53 62 53\n4 2 56 55 7\n3 87 11 75\n2 29 10\n5 79 51 17 82 2\n2 53 71\n2 74 50\n2 7 78\n1 60\n1 26\n5 30 81 28 37 79\n1 23\n1 35\n1 50\n4 17 12 76 75\n4 63 15 59 72\n1 85\n",
            "output": "130987710\n"
        },
        {
            "input": "58 3 60\n3 59 45 6\n3 30 4 1\n1 45\n1 50\n2 43 32\n2 13 20\n2 26 20\n2 57 41\n2 49 39\n2 19 47\n3 31 37 45\n3 13 14 31\n1 44\n1 21\n1 48\n3 5 53 7\n1 12\n3 35 2 1\n1 37\n2 46 38\n1 32\n2 22 60\n1 50\n3 37 20 17\n2 19 37\n3 58 31 42\n2 37 57\n2 9 24\n1 1\n1 22\n3 7 51 25\n3 37 38 30\n3 27 33 36\n3 41 47 57\n2 24 54\n2 5 35\n3 53 27 24\n2 4 25\n3 25 6 36\n3 30 58 44\n1 19\n1 26\n1 10\n1 33\n3 52 40 11\n1 19\n1 20\n1 60\n2 57 7\n2 21 28\n2 26 56\n2 47 53\n1 46\n3 11 11 45\n2 6 8\n2 49 40\n1 25\n2 17 35\n",
            "output": "1800\n"
        },
        {
            "input": "9 16 2\n2 2 1\n1 1\n2 2 2\n1 2 1\n2 2 1\n2 2 2\n2 1 2\n2 1 2\n2 2 1\n",
            "output": "0\n"
        },
        {
            "input": "0 7 8\n4 1 4 1 3\n2 8 2\n",
            "output": "2097152\n"
        },
        {
            "input": "19 7 2\n2 1 2\n1 1\n2 1 2\n2 2 2\n2 1 2\n1 1\n2 2 1\n1 2\n2 1 2\n1 2\n1 2\n2 1 1\n2 2 1\n2 2 1\n2 2 1\n2 1 2\n1 2\n2 1 2\n2 1 2\n",
            "output": "0\n"
        },
        {
            "input": "0 7 8\n4 1 2 8 3\n2 8 2\n",
            "output": "2097152\n"
        },
        {
            "input": "58 3 60\n3 59 45 6\n3 30 4 1\n1 45\n1 2\n2 43 32\n2 13 20\n2 26 20\n2 57 41\n2 49 39\n2 19 47\n3 31 37 45\n3 13 14 31\n1 44\n1 21\n1 48\n3 5 53 7\n1 12\n3 35 2 1\n1 37\n2 46 38\n1 32\n2 22 60\n1 50\n3 37 20 17\n2 19 37\n3 58 31 42\n2 37 57\n2 9 24\n1 1\n1 22\n3 7 51 25\n3 37 38 48\n3 27 33 36\n3 41 47 57\n2 24 54\n2 5 35\n3 53 27 24\n2 4 25\n3 25 6 36\n3 30 58 44\n1 19\n1 26\n1 10\n1 33\n3 52 40 11\n1 19\n1 11\n1 60\n2 57 7\n2 21 28\n2 26 56\n2 47 53\n1 46\n3 11 11 45\n2 6 8\n2 49 40\n1 38\n2 17 35\n",
            "output": "1397\n"
        },
        {
            "input": "0 7 8\n4 1 1 8 2\n2 0 2\n",
            "output": "2097152\n"
        },
        {
            "input": "0 1 8\n4 1 1 8 0\n2 0 2\n",
            "output": "8\n"
        },
        {
            "input": "0 1 8\n4 2 1 8 0\n2 -1 2\n",
            "output": "8\n"
        },
        {
            "input": "3 4 3\n2 1 2\n2 2 3\n2 1 1\n",
            "output": "0\n"
        },
        {
            "input": "8 3 3\n1 2\n2 1 2\n1 3\n2 2 3\n1 1\n3 2 2 3\n2 3 1\n2 3 1\n",
            "output": "0\n"
        },
        {
            "input": "58 3 60\n3 59 45 6\n3 30 4 1\n1 45\n1 50\n2 43 32\n2 13 20\n2 26 20\n2 29 41\n2 49 39\n2 19 47\n3 31 37 45\n3 13 17 31\n1 44\n1 21\n1 48\n3 5 53 7\n1 12\n3 35 2 1\n1 37\n2 46 38\n1 32\n2 22 60\n1 50\n3 37 20 17\n2 19 37\n3 58 31 42\n2 37 57\n2 9 24\n1 1\n1 22\n3 7 51 25\n3 37 38 30\n3 27 33 36\n3 41 47 57\n2 24 54\n2 5 35\n3 53 27 24\n2 4 25\n3 25 6 36\n3 30 58 44\n1 19\n1 26\n1 10\n1 37\n3 52 40 11\n1 19\n1 11\n1 60\n2 57 7\n2 21 28\n2 26 56\n2 47 53\n1 46\n3 11 11 45\n2 6 8\n2 49 40\n1 25\n2 17 35\n",
            "output": "1800\n"
        },
        {
            "input": "0 114514 1919\n2 2 1\n2 0 1\n",
            "output": "81228828\n"
        },
        {
            "input": "9 8 2\n2 2 1\n1 1\n2 1 1\n2 2 1\n2 2 1\n2 1 2\n2 2 2\n2 1 2\n2 2 1\n",
            "output": "0\n"
        },
        {
            "input": "48 3 63\n3 59 8 11\n1 62\n2 1 23\n1 55\n2 15 27\n1 14\n1 28\n1 19\n2 18 20\n1 9\n3 42 17 23\n1 49\n2 28 54\n1 26\n2 8 26\n3 38 15 35\n3 42 11 62\n1 37\n3 43 9 40\n3 5 46 27\n1 63\n2 15 48\n1 44\n3 35 2 26\n3 25 37 14\n3 7 62 17\n2 60 41\n2 11 21\n2 49 18\n3 31 42 46\n1 26\n1 11\n3 34 47 31\n2 9 9\n2 43 20\n3 49 19 47\n3 13 25 53\n1 43\n1 7\n1 49\n2 36 32\n3 61 26 10\n1 60\n2 22 29\n2 28 23\n2 48 55\n3 1 38 27\n1 60\n",
            "output": "5940\n"
        },
        {
            "input": "19 6 2\n2 1 2\n1 1\n2 1 2\n1 2 1\n2 1 2\n1 1\n1 2 1\n1 2\n2 1 2\n1 2\n1 2\n2 1 2\n2 2 1\n2 2 1\n2 2 1\n2 1 2\n1 2\n2 1 2\n2 1 2\n",
            "output": "0\n"
        },
        {
            "input": "4 8 9\n3 4 8 1\n3 4 6 7\n2 9 5\n2 7 5\n",
            "output": "256\n"
        },
        {
            "input": "6 10 186\n5 27 15 11 28 91\n2 25 79\n4 25 21 78 71\n4 19 83 4 23\n2 9 40\n7 43 83 40 18 16 157 92\n",
            "output": "678188264\n"
        },
        {
            "input": "1 42 418\n2 15 31\n",
            "output": "856343832\n"
        },
        {
            "input": "1 5 3\n4 1 3 1 2\n",
            "output": "0\n"
        },
        {
            "input": "9 16 2\n2 2 1\n2 1\n2 2 2\n1 2 1\n2 2 1\n2 2 2\n2 1 2\n2 1 2\n2 2 1\n",
            "output": "0\n"
        },
        {
            "input": "0 7 8\n4 1 4 1 3\n0 8 2\n",
            "output": "2097152\n"
        },
        {
            "input": "19 7 2\n2 1 2\n1 1\n2 1 2\n2 2 2\n2 1 2\n1 1\n2 2 1\n1 2\n2 1 2\n1 2\n1 2\n2 1 1\n1 2 1\n2 2 1\n2 2 1\n2 1 2\n1 2\n2 1 2\n2 1 2\n",
            "output": "0\n"
        },
        {
            "input": "0 1 8\n4 1 1 8 0\n2 0 0\n",
            "output": "8\n"
        },
        {
            "input": "0 1 8\n4 2 1 16 0\n2 -1 2\n",
            "output": "8\n"
        },
        {
            "input": "58 3 60\n3 59 45 6\n3 30 4 1\n1 45\n1 50\n2 43 32\n2 13 20\n2 26 20\n2 29 41\n2 49 39\n2 19 47\n3 31 37 45\n3 13 17 31\n1 44\n1 21\n1 48\n3 5 53 7\n1 12\n3 35 2 1\n1 37\n2 46 30\n1 32\n2 22 60\n1 50\n3 37 20 17\n2 19 37\n3 58 31 42\n2 37 57\n2 9 24\n1 1\n1 22\n3 7 51 25\n3 37 38 30\n3 27 33 36\n3 41 47 57\n2 24 54\n2 5 35\n3 53 27 24\n2 4 25\n3 25 6 36\n3 30 58 44\n1 19\n1 26\n1 10\n1 37\n3 52 40 11\n1 19\n1 11\n1 60\n2 57 7\n2 21 28\n2 26 56\n2 47 53\n1 46\n3 11 11 45\n2 6 8\n2 49 40\n1 25\n2 17 35\n",
            "output": "1800\n"
        },
        {
            "input": "26 5 88\n5 19 24 67 87 4\n3 78 28 76\n4 13 88 73 82\n5 35 75 62 54 4\n5 3 55 56 28 77\n3 19 48 81\n1 66\n4 28 40 83 59\n4 22 46 68 10\n5 52 67 53 62 53\n4 4 56 55 7\n3 87 11 75\n2 29 10\n5 79 51 17 82 2\n2 53 71\n2 74 50\n2 7 78\n1 60\n1 26\n5 30 81 28 37 79\n1 23\n1 35\n1 50\n4 17 12 76 75\n4 63 13 59 87\n1 85\n",
            "output": "147326600\n"
        },
        {
            "input": "6 10 186\n5 27 15 11 28 91\n2 25 79\n4 25 21 78 71\n4 19 83 4 23\n2 9 40\n7 43 83 40 8 16 157 92\n",
            "output": "678188264\n"
        },
        {
            "input": "1 10 3\n4 1 3 1 2\n",
            "output": "0\n"
        },
        {
            "input": "2 1 5\n2 1 1\n2 1 2\n",
            "output": "3\n"
        },
        {
            "input": "0 7 8\n4 1 4 1 2\n0 8 2\n",
            "output": "2097152\n"
        },
        {
            "input": "1 42 601\n2 16 35\n",
            "output": "981048532\n"
        },
        {
            "input": "0 5 8\n4 1 2 10 3\n2 8 2\n",
            "output": "32768\n"
        },
        {
            "input": "58 6 60\n3 59 45 6\n3 30 4 1\n1 45\n1 2\n2 43 32\n2 13 7\n2 26 20\n2 57 41\n2 49 39\n2 19 47\n3 31 37 45\n3 13 14 31\n1 44\n1 21\n1 48\n3 5 53 7\n1 12\n3 35 2 1\n1 37\n2 46 38\n1 32\n2 22 60\n1 50\n3 37 20 17\n2 19 37\n3 58 31 42\n2 37 57\n2 9 24\n1 1\n1 22\n3 7 51 25\n3 37 38 48\n3 27 33 36\n3 41 47 57\n2 24 54\n2 5 35\n3 53 27 24\n2 4 25\n3 25 6 36\n3 30 58 44\n1 19\n1 26\n1 10\n1 33\n3 52 40 11\n1 19\n1 11\n1 60\n2 57 7\n2 21 28\n2 26 56\n2 47 53\n1 46\n3 11 11 45\n2 6 8\n2 49 40\n1 38\n2 17 35\n",
            "output": "1997737\n"
        },
        {
            "input": "0 7 6\n4 1 1 8 2\n1 0 2\n",
            "output": "279936\n"
        },
        {
            "input": "0 1 8\n4 1 1 8 0\n1 0 0\n",
            "output": "8\n"
        },
        {
            "input": "0 1 8\n4 2 0 16 0\n2 -1 2\n",
            "output": "8\n"
        },
        {
            "input": "58 3 60\n3 59 45 6\n3 30 4 1\n1 45\n1 50\n2 43 32\n2 13 10\n2 26 20\n2 29 41\n2 49 39\n2 19 47\n3 31 37 45\n3 13 17 31\n1 44\n1 21\n1 48\n3 5 53 7\n1 12\n3 35 2 1\n1 37\n2 46 30\n1 32\n2 22 60\n1 50\n3 37 20 17\n2 19 37\n3 58 31 42\n2 37 57\n2 9 24\n1 1\n1 22\n3 7 51 25\n3 37 38 30\n3 27 33 36\n3 41 47 57\n2 24 54\n2 5 35\n3 53 27 24\n2 4 25\n3 25 6 36\n3 30 58 44\n1 19\n1 26\n1 10\n1 37\n3 52 40 11\n1 19\n1 11\n1 60\n2 57 7\n2 21 28\n2 26 56\n2 47 53\n1 46\n3 11 11 45\n2 6 8\n2 49 40\n1 25\n2 17 35\n",
            "output": "1397\n"
        },
        {
            "input": "0 114514 1268\n2 2 2\n2 0 1\n",
            "output": "927781931\n"
        },
        {
            "input": "11 3 52\n2 18 9\n3 36 12 7\n1 38\n1 43\n3 11 32 24\n3 21 7 37\n2 21 36\n1 50\n3 11 26 17\n3 29 11 29\n1 47 38\n",
            "output": "59397\n"
        },
        {
            "input": "48 3 63\n3 59 8 11\n1 62\n2 2 23\n1 55\n2 15 27\n1 14\n1 28\n1 19\n2 18 20\n1 9\n3 42 17 23\n1 49\n2 28 54\n1 26\n2 8 26\n3 38 15 35\n3 42 11 62\n1 37\n3 43 9 40\n3 5 46 27\n1 63\n2 15 48\n1 44\n3 35 2 26\n3 25 37 14\n3 7 62 17\n2 60 41\n2 11 21\n2 49 18\n3 31 42 46\n1 26\n1 11\n3 34 36 31\n2 9 9\n2 43 20\n3 49 19 47\n3 13 25 53\n1 43\n1 7\n1 49\n2 36 32\n3 61 26 10\n1 60\n2 22 29\n2 28 23\n2 48 55\n3 1 38 27\n1 60\n",
            "output": "5904\n"
        },
        {
            "input": "4 8 9\n3 4 8 1\n3 4 8 7\n2 9 5\n2 5 5\n",
            "output": "6561\n"
        },
        {
            "input": "2 7 10\n1 1 3\n3 5 1 8\n",
            "output": "835569\n"
        },
        {
            "input": "1 10 3\n3 1 3 1 2\n",
            "output": "1\n"
        },
        {
            "input": "2 1 5\n2 2 1\n2 1 2\n",
            "output": "3\n"
        },
        {
            "input": "0 7 8\n4 1 4 0 2\n0 8 2\n",
            "output": "2097152\n"
        },
        {
            "input": "1 42 601\n2 22 35\n",
            "output": "981048532\n"
        },
        {
            "input": "0 5 8\n4 1 1 10 3\n2 8 2\n",
            "output": "32768\n"
        },
        {
            "input": "0 7 6\n0 1 1 8 2\n1 0 2\n",
            "output": "279936\n"
        },
        {
            "input": "0 1 8\n4 1 1 8 1\n1 0 0\n",
            "output": "8\n"
        },
        {
            "input": "0 1 8\n4 3 0 16 0\n2 -1 2\n",
            "output": "8\n"
        },
        {
            "input": "0 114514 1268\n2 2 2\n3 0 1\n",
            "output": "927781931\n"
        },
        {
            "input": "48 3 63\n3 59 8 11\n1 62\n2 2 23\n1 55\n2 15 27\n1 14\n1 28\n1 19\n2 18 20\n1 9\n3 42 17 23\n1 49\n2 9 54\n1 26\n2 8 26\n3 38 15 35\n3 42 11 62\n1 37\n3 43 9 40\n3 5 46 27\n1 63\n2 15 48\n1 44\n3 35 2 26\n3 25 37 14\n3 7 62 17\n2 60 41\n2 11 21\n2 49 18\n3 31 42 46\n1 26\n1 11\n3 34 36 31\n2 9 9\n2 43 20\n3 49 19 47\n3 13 25 53\n1 43\n1 7\n1 49\n2 36 32\n3 61 26 10\n1 60\n2 22 29\n2 28 23\n2 48 55\n3 1 38 27\n1 60\n",
            "output": "5904\n"
        },
        {
            "input": "6 18 186\n5 27 15 11 28 91\n2 25 79\n4 25 21 78 71\n4 19 83 4 23\n2 9 40\n7 43 83 40 8 14 157 92\n",
            "output": "102522996\n"
        },
        {
            "input": "1 1427 224852\n1 7589\n",
            "output": "233475856\n"
        },
        {
            "input": "1 10 3\n3 2 3 1 2\n",
            "output": "0\n"
        },
        {
            "input": "2 1 5\n2 2 1\n1 1 2\n",
            "output": "3\n"
        },
        {
            "input": "0 7 8\n4 1 3 0 2\n0 8 2\n",
            "output": "2097152\n"
        },
        {
            "input": "0 5 8\n7 1 1 10 3\n2 8 2\n",
            "output": "32768\n"
        },
        {
            "input": "0 7 6\n0 0 1 8 2\n1 0 2\n",
            "output": "279936\n"
        },
        {
            "input": "0 1 8\n4 1 1 13 1\n1 0 0\n",
            "output": "8\n"
        },
        {
            "input": "0 1 8\n4 3 0 16 0\n1 -1 2\n",
            "output": "8\n"
        },
        {
            "input": "0 114514 1268\n4 2 2\n3 0 1\n",
            "output": "927781931\n"
        },
        {
            "input": "6 18 186\n5 27 15 5 28 91\n2 25 79\n4 25 21 78 71\n4 19 83 4 23\n2 9 40\n7 43 83 40 8 14 157 92\n",
            "output": "102522996\n"
        },
        {
            "input": "1 1427 224852\n1 3138\n",
            "output": "233475856\n"
        },
        {
            "input": "0 7 10\n1 1 3\n3 7 1 8\n",
            "output": "10000000\n"
        },
        {
            "input": "2 1 5\n1 2 1\n1 1 2\n",
            "output": "5\n"
        },
        {
            "input": "0 7 8\n4 1 3 0 2\n0 8 0\n",
            "output": "2097152\n"
        },
        {
            "input": "0 1 8\n4 0 1 13 1\n1 0 0\n",
            "output": "8\n"
        },
        {
            "input": "0 114514 1268\n4 1 2\n3 0 1\n",
            "output": "927781931\n"
        },
        {
            "input": "0 7 10\n1 1 3\n3 7 1 13\n",
            "output": "10000000\n"
        },
        {
            "input": "0 1 5\n1 2 1\n1 1 2\n",
            "output": "5\n"
        },
        {
            "input": "0 5 12\n7 1 1 10 3\n2 9 2\n",
            "output": "248832\n"
        },
        {
            "input": "0 3 6\n0 0 1 8 2\n1 0 0\n",
            "output": "216\n"
        },
        {
            "input": "6 18 186\n5 27 15 5 28 91\n2 25 79\n4 25 21 5 71\n4 19 83 4 42\n2 9 40\n7 43 83 40 8 14 157 92\n",
            "output": "554639233\n"
        },
        {
            "input": "0 1427 270311\n1 3138\n",
            "output": "496034248\n"
        },
        {
            "input": "0 1 5\n1 2 1\n2 1 2\n",
            "output": "5\n"
        },
        {
            "input": "0 2 8\n4 1 3 0 0\n0 8 0\n",
            "output": "64\n"
        },
        {
            "input": "0 5 12\n1 1 1 10 3\n2 9 2\n",
            "output": "248832\n"
        },
        {
            "input": "0 3 6\n0 0 1 8 1\n1 0 0\n",
            "output": "216\n"
        },
        {
            "input": "0 114514 1155\n6 1 2\n3 0 1\n",
            "output": "947822446\n"
        },
        {
            "input": "6 18 186\n5 27 15 5 28 91\n2 25 79\n4 25 26 5 71\n4 19 83 4 42\n2 9 40\n7 43 83 40 8 14 157 92\n",
            "output": "554639233\n"
        },
        {
            "input": "0 1427 270311\n1 980\n",
            "output": "496034248\n"
        },
        {
            "input": "0 11 10\n1 0 3\n3 7 1 13\n",
            "output": "175564700\n"
        },
        {
            "input": "0 1 5\n1 2 1\n2 0 2\n",
            "output": "5\n"
        },
        {
            "input": "0 5 12\n0 1 1 10 3\n2 9 2\n",
            "output": "248832\n"
        },
        {
            "input": "0 3 6\n0 0 1 3 1\n1 0 0\n",
            "output": "216\n"
        },
        {
            "input": "0 1 16\n4 3 0 11 0\n1 -1 2\n",
            "output": "16\n"
        },
        {
            "input": "0 114514 1155\n6 1 2\n1 0 1\n",
            "output": "947822446\n"
        },
        {
            "input": "6 18 186\n5 27 15 7 28 91\n2 25 79\n4 25 26 5 71\n4 19 83 4 42\n2 9 40\n7 43 83 40 8 14 157 92\n",
            "output": "102522996\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <long long mod>\nstruct modular {\n  long long value;\n  modular(long long x = 0) {\n    value = x % mod;\n    if (value < 0) value += mod;\n  }\n  modular& operator+=(const modular& other) {\n    if ((value += other.value) >= mod) value -= mod;\n    return *this;\n  }\n  modular& operator-=(const modular& other) {\n    if ((value -= other.value) < 0) value += mod;\n    return *this;\n  }\n  modular& operator*=(const modular& other) {\n    value = value * other.value % mod;\n    return *this;\n  }\n  modular& operator/=(const modular& other) {\n    long long a = 0, b = 1, c = other.value, m = mod;\n    while (c != 0) {\n      long long t = m / c;\n      m -= t * c;\n      swap(c, m);\n      a -= t * b;\n      swap(a, b);\n    }\n    a %= mod;\n    if (a < 0) a += mod;\n    value = value * a % mod;\n    return *this;\n  }\n  modular operator+(const modular& rhs) const { return modular(*this) += rhs; }\n  modular operator-(const modular& rhs) const { return modular(*this) -= rhs; }\n  modular operator*(const modular& rhs) const { return modular(*this) *= rhs; }\n  modular operator/(const modular& rhs) const { return modular(*this) /= rhs; }\n  modular& operator++() { return *this += 1; }\n  modular& operator--() { return *this -= 1; }\n  modular operator++(int) {\n    modular res(*this);\n    *this += 1;\n    return res;\n  }\n  modular operator--(int) {\n    modular res(*this);\n    *this -= 1;\n    return res;\n  }\n  modular operator-() const { return modular(-value); }\n  bool operator==(const modular& rhs) const { return value == rhs.value; }\n  bool operator!=(const modular& rhs) const { return value != rhs.value; }\n  bool operator<(const modular& rhs) const { return value < rhs.value; }\n};\ntemplate <long long mod>\nstring to_string(const modular<mod>& x) {\n  return to_string(x.value);\n}\ntemplate <long long mod>\nostream& operator<<(ostream& stream, const modular<mod>& x) {\n  return stream << x.value;\n}\ntemplate <long long mod>\nistream& operator>>(istream& stream, modular<mod>& x) {\n  stream >> x.value;\n  x.value %= mod;\n  if (x.value < 0) x.value += mod;\n  return stream;\n}\nconstexpr long long mod = 998244353;\nusing mint = modular<mod>;\nmint power(mint a, long long n) {\n  mint res = 1;\n  while (n > 0) {\n    if (n & 1) {\n      res *= a;\n    }\n    a *= a;\n    n >>= 1;\n  }\n  return res;\n}\nvector<mint> fact(1, 1);\nvector<mint> finv(1, 1);\nmint C(int n, int k) {\n  if (n < k || k < 0) {\n    return mint(0);\n  }\n  while ((int)fact.size() < n + 1) {\n    fact.emplace_back(fact.back() * (int)fact.size());\n    finv.emplace_back(mint(1) / fact.back());\n  }\n  return fact[n] * finv[k] * finv[n - k];\n}\nstruct dsu {\n  vector<int> p;\n  vector<int> sz;\n  int n;\n  dsu(int _n) : n(_n) {\n    p.resize(n);\n    iota(p.begin(), p.end(), 0);\n    sz.assign(n, 1);\n  }\n  inline int get(int x) {\n    if (p[x] == x) {\n      return x;\n    } else {\n      return p[x] = get(p[x]);\n    }\n  }\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x == y) {\n      return false;\n    }\n    if (sz[x] > sz[y]) {\n      swap(x, y);\n    }\n    p[x] = y;\n    sz[y] += sz[x];\n    return true;\n  }\n  inline bool same(int x, int y) { return (get(x) == get(y)); }\n};\nmint root;\nint base;\nint max_base;\nvector<mint> roots;\nvector<int> rev;\nvoid ensure_base(int nbase) {\n  if (roots.empty()) {\n    auto tmp = mod - 1;\n    max_base = 0;\n    while (tmp % 2 == 0) {\n      tmp /= 2;\n      max_base++;\n    }\n    root = 2;\n    while (power(root, (mod - 1) >> 1) == 1) {\n      root += 1;\n    }\n    root = power(root, (mod - 1) >> max_base);\n    base = 1;\n    rev = {0, 1};\n    roots = {0, 1};\n  }\n  if (nbase <= base) {\n    return;\n  }\n  rev.resize(1 << nbase);\n  for (int i = 0; i < (1 << nbase); i++) {\n    rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n  }\n  roots.resize(1 << nbase);\n  while (base < nbase) {\n    mint z = power(root, 1 << (max_base - 1 - base));\n    for (int i = 1 << (base - 1); i < (1 << base); i++) {\n      roots[i << 1] = roots[i];\n      roots[(i << 1) + 1] = roots[i] * z;\n    }\n    base++;\n  }\n}\nvoid ntt(vector<mint>& a) {\n  int n = (int)a.size();\n  int zeros = __builtin_ctz(n);\n  ensure_base(zeros);\n  int shift = base - zeros;\n  for (int i = 0; i < n; i++) {\n    if (i < (rev[i] >> shift)) {\n      swap(a[i], a[rev[i] >> shift]);\n    }\n  }\n  for (int k = 1; k < n; k <<= 1) {\n    for (int i = 0; i < n; i += 2 * k) {\n      for (int j = 0; j < k; j++) {\n        mint x = a[i + j];\n        mint y = a[i + j + k] * roots[j + k];\n        a[i + j] = x + y;\n        a[i + j + k] = x - y;\n      }\n    }\n  }\n}\nvector<mint> multiply(vector<mint> a, vector<mint> b) {\n  int need = (int)a.size() + (int)b.size() - 1;\n  int nbase = 0;\n  while ((1 << nbase) < need) {\n    nbase++;\n  }\n  ensure_base(nbase);\n  int sz = 1 << nbase;\n  a.resize(sz);\n  b.resize(sz);\n  ntt(a);\n  ntt(b);\n  mint inv = mint(1) / mint(sz);\n  for (int i = 0; i < sz; i++) {\n    a[i] *= b[i] * inv;\n  }\n  reverse(a.begin() + 1, a.end());\n  ntt(a);\n  a.resize(need);\n  return a;\n}\nvector<mint>& operator*=(vector<mint>& a, const vector<mint>& b) {\n  if (min(a.size(), b.size()) < 150) {\n    vector<mint> c = a;\n    a.assign(a.size() + b.size() - 1, 0);\n    for (int i = 0; i < (int)c.size(); i++) {\n      for (int j = 0; j < (int)b.size(); j++) {\n        a[i + j] += c[i] * b[j];\n      }\n    }\n  } else {\n    a = multiply(a, b);\n  }\n  return a;\n}\ntemplate <typename T>\nvector<T> operator*(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c *= b;\n}\ntemplate <typename T>\nvector<T> inverse(const vector<T>& a) {\n  vector<T> h(a);\n  int n = (int)h.size();\n  T invh0 = T(1) / h[0];\n  vector<T> u(1, invh0);\n  while ((int)u.size() < n) {\n    int t = (int)u.size();\n    vector<T> h0;\n    for (int i = 0; i < t; i++) {\n      h0.emplace_back(i < (int)h.size() ? h[i] : 0);\n    }\n    vector<T> c = h0 * u;\n    vector<T> h1;\n    for (int i = t; i < 2 * t; i++) {\n      h1.emplace_back(i < (int)h.size() ? h[i] : 0);\n    }\n    vector<T> aux = u * h1;\n    aux.resize(t);\n    for (int i = 0; i < t; i++) {\n      aux[i] += (i + t < (int)c.size() ? c[i + t] : 0);\n    }\n    vector<T> v = aux * u;\n    v.resize(t);\n    for (int i = 0; i < t; i++) {\n      u.emplace_back(-v[i]);\n    }\n  }\n  u.resize(n);\n  return u;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, k;\n  cin >> n >> m >> k;\n  vector<vector<int>> a;\n  for (int i = 0; i < n; i++) {\n    int c;\n    cin >> c;\n    vector<int> b(c);\n    for (int j = 0; j < c; j++) {\n      cin >> b[j];\n      b[j]--;\n    }\n    a.emplace_back(b);\n  }\n  sort(a.begin(), a.end());\n  a.resize(unique(a.begin(), a.end()) - a.begin());\n  n = (int)a.size();\n  vector<int> nxt(k, -1), pre(k, 0);\n  dsu uf(k + 1);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < (int)a[i].size() - 1; j++) {\n      uf.unite(a[i][j], a[i][j + 1]);\n      if (nxt[a[i][j]] != a[i][j + 1]) {\n        if (nxt[a[i][j]] == -1) {\n          nxt[a[i][j]] = a[i][j + 1];\n          pre[a[i][j + 1]]++;\n        } else {\n          uf.unite(a[i][j], k);\n        }\n      }\n    }\n  }\n  vector<mint> b(m + 1);\n  for (int i = 0; i < k; i++) {\n    if (uf.same(i, k) || pre[i]) {\n      continue;\n    }\n    vector<int> c;\n    c.emplace_back(i);\n    int now = i;\n    while (nxt[now] != -1) {\n      c.emplace_back(nxt[now]);\n      now = nxt[now];\n      if (pre[now] != 1) {\n        c.clear();\n        break;\n      }\n    }\n    if ((int)c.size() == uf.sz[uf.get(i)] && (int)c.size() <= m) {\n      b[c.size()]++;\n    } else {\n      uf.unite(i, k);\n    }\n  };\n  vector<mint> c(m + 1);\n  c[0] = 1;\n  for (int i = 1; i <= m; i++) {\n    c[i] = -b[i];\n  }\n  c = inverse(c);\n  b *= c;\n  cout << b[m] << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double PI = acos(-1);\nconst long long nax = 2e5 + 10, mod = 998244353, inf = 1e18;\nlong long mul(long long x, long long y) { return x * y % mod; }\nvoid solve() {\n  long long n, m, k;\n  cin >> n >> m >> k;\n  vector<vector<long long>> g(k), ad(k);\n  for (long long i = 0; i < n; i++) {\n    long long x;\n    cin >> x;\n    long long d;\n    cin >> d;\n    --d;\n    for (long long j = 1; j < x; j++) {\n      long long y;\n      cin >> y;\n      --y;\n      g[d].push_back(y);\n      ad[y].push_back(d);\n      d = y;\n    }\n  }\n  for (long long i = 0; i < k; i++) {\n    sort(g[i].begin(), g[i].end());\n    g[i].resize(unique(g[i].begin(), g[i].end()) - g[i].begin());\n    sort(ad[i].begin(), ad[i].end());\n    ad[i].resize(unique(ad[i].begin(), ad[i].end()) - ad[i].begin());\n  }\n  map<long long, long long> vis;\n  vector<bool> used(k, 0), mark(k, 0);\n  for (long long i = 0; i < k; i++) {\n    if (mark[i]) continue;\n    vector<long long> qq(1, i);\n    mark[i] = 1;\n    for (long long j = 0; j < qq.size(); j++) {\n      for (auto it : g[qq[j]])\n        if (!mark[it]) {\n          qq.push_back(it);\n          mark[it] = 1;\n        }\n      for (auto it : ad[qq[j]])\n        if (!mark[it]) {\n          qq.push_back(it);\n          mark[it] = 1;\n        }\n    }\n    long long val = 0;\n    for (auto xx : qq) val += g[xx].size();\n    if (val != qq.size() - 1) continue;\n    long long e = -1;\n    for (auto ii : qq)\n      if (ad[ii].empty()) {\n        e = ii;\n        break;\n      }\n    vector<long long> seq(1, e);\n    used[e] = 1;\n    while (1) {\n      long long nxt = -1;\n      for (auto ii : g[seq.back()])\n        if (!used[ii]) {\n          nxt = ii;\n          break;\n        }\n      if (nxt == -1) break;\n      seq.push_back(nxt);\n      used[nxt] = 1;\n    }\n    if (seq.size() == qq.size()) vis[seq.size()]++;\n  }\n  vector<pair<long long, long long>> et;\n  for (auto it : vis) et.push_back(it);\n  vector<long long> dp(m + 1);\n  dp[0] = 1;\n  for (long long i = 1; i < m + 1; i++) {\n    for (auto it : et)\n      if (i >= it.first) {\n        dp[i] += mul(dp[i - it.first], it.second);\n        dp[i] %= mod;\n      }\n  }\n  cout << dp[m] << endl;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  long long tt = 1;\n  for (long long i = 1; i <= tt; i++) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace mypoly {\nconst int MOD = 998244353;\nconst int g = 3;\nint qmul(int x, int y) { return 1ll * x * y - 1ll * x * y / MOD * MOD; }\nint qadd(int x, int y) { return x + y >= MOD ? x + y - MOD : x + y; }\nint G[21][(1 << 20) + 1], R[21][(1 << 20) + 1], inver[(1 << 20) + 1];\nint quick(int A, int B) {\n  int res = 1;\n  while (B) {\n    if (B & 1) res = qmul(res, A);\n    A = qmul(A, A);\n    B >>= 1;\n  }\n  return res;\n}\nint inv(int x) { return quick(x, MOD - 2); }\nstruct POLY {\n  int len;\n  int rev[1 << 20];\n  POLY() {\n    for (int i = 1; i <= (1 << 20); ++i) inver[i] = inv(i);\n    for (int i = 1; i <= 20; ++i) {\n      G[i][0] = 1;\n      R[i][0] = 1;\n      int tmp2 = inv(quick(g, (MOD - 1) >> i));\n      int tmp = quick(g, (MOD - 1) >> i);\n      for (int j = 1; j <= (1 << i); ++j) {\n        G[i][j] = qmul(G[i][j - 1], tmp);\n        R[i][j] = qmul(R[i][j - 1], tmp2);\n      }\n    }\n  }\n  void butterfly(vector<int>& v) {\n    for (int i = 0; i < len; ++i) {\n      rev[i] = rev[i >> 1] >> 1;\n      if (i & 1) rev[i] |= len >> 1;\n    }\n    for (int i = 0; i < len; ++i)\n      if (rev[i] > i) swap(v[i], v[rev[i]]);\n  }\n  vector<int> ntt(vector<int> v) {\n    butterfly(v);\n    vector<int> nex;\n    int lg = 1;\n    for (int l = 2; l <= len; l <<= 1, ++lg) {\n      nex.clear();\n      nex.resize(len);\n      for (int j = 0; j < len; j += l) {\n        for (int k = 0; k < l / 2; ++k) {\n          int A, B;\n          A = v[j + k];\n          B = v[j + l / 2 + k];\n          B = qmul(B, G[lg][k]);\n          nex[j + k] = qadd(A, B);\n          nex[j + k + l / 2] = qadd(A, MOD - B);\n        }\n      }\n      v = nex;\n    }\n    return v;\n  }\n  vector<int> intt(vector<int> v) {\n    butterfly(v);\n    vector<int> nex;\n    int lg = 1;\n    for (int l = 2; l <= len; l <<= 1, ++lg) {\n      nex.clear();\n      nex.resize(len);\n      for (int j = 0; j < len; j += l) {\n        for (int k = 0; k < l / 2; ++k) {\n          int A, B;\n          A = v[j + k];\n          B = v[j + l / 2 + k];\n          B = qmul(R[lg][k], B);\n          nex[j + k] = qadd(A, B);\n          nex[j + k + l / 2] = qadd(A, MOD - B);\n        }\n      }\n      v = nex;\n    }\n    return v;\n  }\n  void getlen(int x) {\n    len = 1;\n    while (len < x) {\n      len <<= 1;\n    }\n  }\n  vector<int> mul(vector<int> A, vector<int> B) {\n    if (A.size() + B.size() <= 25) {\n      vector<int> ret(A.size() + B.size() - 1);\n      for (int i = 0; i < A.size(); ++i)\n        for (int j = 0; j < B.size(); ++j)\n          ret[i + j] = qadd(ret[i + j], qmul(A[i], B[j]));\n      return ret;\n    }\n    getlen(A.size() + B.size());\n    A.resize(len);\n    B.resize(len);\n    A = ntt(A);\n    B = ntt(B);\n    for (int i = 0; i < len; ++i) A[i] = qmul(A[i], B[i]);\n    A = intt(A);\n    int iv = inver[len];\n    for (int i = 0; i < len; ++i) {\n      A[i] = qmul(A[i], iv);\n    }\n    while (!A.empty() && A.back() == 0) A.pop_back();\n    return A;\n  }\n  vector<int> inverse(vector<int> A, int n) {\n    vector<int> ret(n);\n    if (n == 1) {\n      ret[0] = quick(A[0], MOD - 2);\n    } else {\n      vector<int> oth = inverse(A, (n + 1) >> 1);\n      ret = oth;\n      ret.resize(n);\n      for (int i = 0; i < n; ++i) ret[i] = (ret[i] + ret[i]) % MOD;\n      getlen((oth.size() << 1) + A.size());\n      oth.resize(len);\n      A.resize(len);\n      oth = ntt(oth);\n      A = ntt(A);\n      for (int i = 0; i < len; ++i) oth[i] = qmul(qmul(oth[i], oth[i]), A[i]);\n      oth = intt(oth);\n      oth.resize(n);\n      int iv = inver[len];\n      for (int i = 0; i < n; ++i) {\n        oth[i] = qmul(oth[i], iv);\n      }\n      for (int i = 0; i < n; ++i) ret[i] = qadd(ret[i], MOD - oth[i]);\n    }\n    return ret;\n  }\n} poly;\nvector<int> operator*(vector<int> A, vector<int> B) { return poly.mul(A, B); }\nvector<int> operator+(vector<int> A, vector<int> B) {\n  int Sz = max(A.size(), B.size());\n  A.resize(Sz);\n  for (int i = 0; i < B.size(); ++i) A[i] = qadd(A[i], B[i]);\n  return A;\n}\nvector<int> operator-(vector<int> A, vector<int> B) {\n  int Sz = max(A.size(), B.size());\n  A.resize(Sz);\n  for (int i = 0; i < B.size(); ++i) A[i] = qadd(A[i], MOD - B[i]);\n  return A;\n}\nvector<int> operator/(vector<int> A, vector<int> B) {\n  return A * poly.inverse(B, A.size() - B.size() + 1);\n}\nvector<int> operator%(vector<int> A, vector<int> B) {\n  while (A.size() != 1 && A.back() == 0) A.pop_back();\n  while (B.size() != 1 && B.back() == 0) B.pop_back();\n  if (B.size() > A.size()) return A;\n  vector<int> rem, mod;\n  int n, m;\n  n = A.size() - 1;\n  m = B.size() - 1;\n  reverse(A.begin(), A.end());\n  reverse(B.begin(), B.end());\n  rem = A / B;\n  reverse(A.begin(), A.end());\n  reverse(B.begin(), B.end());\n  rem.resize(n - m + 1);\n  reverse(rem.begin(), rem.end());\n  mod = A - rem * B;\n  mod.resize(m);\n  return mod;\n}\nvector<int> der(vector<int> A) {\n  while (A.size() != 1 && A.back() == 0) A.pop_back();\n  vector<int> ret(A.size() - 1);\n  for (int i = 0; i < ret.size(); ++i) ret[i] = 1ll * (i + 1) * A[i + 1] % MOD;\n  if (ret.empty()) return vector<int>(1, 0);\n  return ret;\n}\n}  // namespace mypoly\nusing namespace mypoly;\nconst int INF = 0x3f3f3f3f;\nconst int MAXN = 6e5 + 1;\nint n, m, k;\nvector<int> A[MAXN];\nvector<int> Z[MAXN];\nint fa[MAXN];\nbool ba[MAXN];\nvector<int> belong[MAXN];\nint root(int x) { return fa[x] = (fa[x] == x ? x : root(fa[x])); }\nvoid merge(int u, int v) { fa[root(u)] = root(v); }\nvoid add(int& A, int B) {\n  A += B;\n  if (A >= MOD) A -= MOD;\n}\nint nex[MAXN];\nint main() {\n  for (int i = 0; i < MAXN; ++i) fa[i] = i, nex[i] = -1;\n  cin >> n >> m >> k;\n  for (int i = 1; i <= n; ++i) {\n    int ci;\n    scanf(\"%d\", &ci);\n    A[i].resize(ci);\n    for (int j = 0; j < ci; ++j) scanf(\"%d\", &A[i][j]);\n    map<int, int> app;\n    bool bad = 0;\n    for (auto it : A[i]) {\n      if (app.find(it) != app.end()) {\n        bad = 1;\n        break;\n      }\n      app[it] = 1;\n    }\n    if (bad) {\n      ba[i] = 1;\n    }\n    for (auto it : A[i]) Z[it].push_back(i);\n  }\n  for (int i = 1; i <= k; ++i) {\n    A[++n] = {i};\n    Z[i].push_back(n);\n  }\n  for (int i = 1; i <= k; ++i) {\n    if (Z[i].size() > 1) {\n      for (int j = 0; j < Z[i].size() - 1; ++j) {\n        merge(Z[i][j], Z[i][j + 1]);\n      }\n    }\n  }\n  for (int i = 1; i <= n; ++i) ba[root(i)] |= ba[i];\n  for (int i = 1; i <= n; ++i) ba[i] |= ba[root(i)];\n  for (int i = 1; i <= n; ++i) belong[root(i)].push_back(i);\n  vector<int> Tmp(m + 1, 0);\n  vector<int> orz;\n  for (int i = 1; i <= n; ++i)\n    if (root(i) == i && !ba[i]) {\n      vector<int>& now = belong[i];\n      map<int, int> app;\n      bool bad = 0;\n      for (auto it : now) {\n        for (auto itt : A[it]) {\n          app[itt] = 1;\n        }\n        if (A[it].size() > 1) {\n          for (int j = 0; j < A[it].size() - 1; ++j) {\n            if (nex[A[it][j]] != A[it][j + 1] && nex[A[it][j]] != -1) {\n              bad = 1;\n            }\n            nex[A[it][j]] = A[it][j + 1];\n          }\n        }\n      }\n      if (bad) continue;\n      map<int, int> app2 = app;\n      int sz = app2.size();\n      for (auto ite = app2.begin(); ite != app2.end(); ite++)\n        if (app.find(nex[ite->first]) != app.end()) app.erase(nex[ite->first]);\n      if (app.size() != 1) {\n        continue;\n      }\n      int fi = app.begin()->first;\n      app2.clear();\n      while (true) {\n        if (fi == -1) break;\n        if (app2.find(fi) != app2.end()) {\n          bad = 1;\n          break;\n        }\n        app2[fi] = 1;\n        fi = nex[fi];\n      }\n      if (!bad && sz <= m && app2.size() == sz) {\n        Tmp[sz]++;\n        orz.push_back(sz);\n      }\n    }\n  for (auto& it : Tmp) it = (MOD - it) % MOD;\n  Tmp[0] = 1;\n  Tmp = poly.inverse(Tmp, m + 1);\n  cout << Tmp[m] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 3e5 + 5;\nconst int MAXM = 3e5 + 5;\nconst int MAXD = 3e5 + 5;\nconst int mod = 998244353;\ninline void add_mod(int &a, int b) {\n  a += b;\n  if (a >= mod) a -= mod;\n}\nbool fob[MAXD];\nvector<int> lef[MAXD], rig[MAXD];\ninline void sort_unique(vector<int> &vec) {\n  sort(vec.begin(), vec.end());\n  vec.erase(unique(vec.begin(), vec.end()), vec.end());\n}\nvoid dfs_fob(int u) {\n  if (fob[u]) return;\n  fob[u] = 1;\n  for (int x : lef[u]) dfs_fob(x);\n  for (int x : rig[u]) dfs_fob(x);\n}\nint main(void) {\n  int n, m, d;\n  scanf(\"%d%d%d\", &n, &m, &d);\n  for (int i = 1; i <= n; ++i) {\n    int k;\n    scanf(\"%d\", &k);\n    vector<int> vec(k);\n    for (int &x : vec) scanf(\"%d\", &x);\n    for (int j = 1; j < k; ++j) {\n      lef[vec[j]].push_back(vec[j - 1]);\n      rig[vec[j - 1]].push_back(vec[j]);\n    }\n  }\n  for (int i = 1; i <= d; ++i) {\n    sort_unique(lef[i]);\n    sort_unique(rig[i]);\n    if (lef[i].size() > 1 || rig[i].size() > 1) dfs_fob(i);\n  }\n  static bool vis[MAXD];\n  map<int, int> tlens;\n  for (int i = 1; i <= d; ++i)\n    if (!vis[i] && !lef[i].size() && !fob[i]) {\n      int cur = 0, u = i;\n      while (1) {\n        if (vis[u]) {\n          dfs_fob(u);\n          break;\n        }\n        ++cur;\n        vis[u] = 1;\n        if (rig[u].size())\n          u = rig[u][0];\n        else\n          break;\n      }\n      if (!fob[i]) ++tlens[cur];\n    }\n  vector<pair<int, int> > lens(tlens.begin(), tlens.end());\n  static int f[MAXM];\n  f[0] = 1;\n  for (int i = 1; i <= m; ++i)\n    for (pair<int, int> &x : lens) {\n      if (x.first > i) break;\n      f[i] = (f[i] + (long long)f[i - x.first] * x.second) % mod;\n    }\n  printf(\"%d\", f[m]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nconst int N = 3e5 + 9, mod = 998244353;\nint n, m, k;\nset<int> nxt[N], prv[N];\nbool bad[N];\nvoid dfsbads(int node) {\n  if (bad[node]) return;\n  bad[node] = true;\n  for (auto i : nxt[node]) dfsbads(i);\n  for (auto i : prv[node]) dfsbads(i);\n}\nint dfsChain(int node) {\n  if (nxt[node].empty()) return 1;\n  assert(nxt[node].size() == 1);\n  return 1 + dfsChain(*nxt[node].begin());\n}\nint freq[N];\nint dp[N];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m >> k;\n  while (n--) {\n    int c, x;\n    cin >> c >> x;\n    for (int i = 1; i < c; i++) {\n      int y;\n      cin >> y;\n      nxt[x].insert(y);\n      prv[y].insert(x);\n      x = y;\n    }\n  }\n  for (int i = 1; i <= k; i++) {\n    if (nxt[i].size() > 1 || prv[i].size() > 1) dfsbads(i);\n  }\n  for (int i = 1; i <= k; i++) {\n    if (bad[i] || prv[i].size() > 0) continue;\n    freq[dfsChain(i)]++;\n  }\n  vector<pair<int, int> > v;\n  for (int i = 1; i <= m; i++) {\n    if (freq[i]) {\n      v.push_back({i, freq[i]});\n    }\n  }\n  dp[0] = 1;\n  for (int i = 1; i <= m; i++) {\n    for (auto j : v) {\n      if (j.first > i) break;\n      dp[i] = (dp[i] + 1LL * j.second * dp[i - j.first]) % mod;\n    }\n  }\n  cout << dp[m];\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid dbg_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n  cerr << ' ' << H;\n  dbg_out(T...);\n}\npair<int, int> operator*(const pair<int, int> &p, const pair<int, int> &x) {\n  pair<int, int> np = make_pair(p.first * x.first, p.second * x.second);\n  return np;\n}\npair<long long, long long> operator%(const pair<long long, long long> &p,\n                                     const pair<long long, long long> &x) {\n  pair<long long, long long> np =\n      make_pair(p.first % x.first, p.second % x.second);\n  return np;\n}\npair<long long, long long> operator*(const pair<long long, long long> &p,\n                                     const pair<int, int> &x) {\n  pair<long long, long long> np =\n      make_pair(p.first * x.first, p.second * x.second);\n  return np;\n}\npair<long long, long long> operator*(const pair<long long, long long> &p,\n                                     const pair<long long, long long> &x) {\n  pair<long long, long long> np =\n      make_pair(p.first * x.first, p.second * x.second);\n  return np;\n}\npair<long long, long long> operator+(const pair<long long, long long> &p,\n                                     const pair<long long, long long> &x) {\n  pair<long long, long long> np =\n      make_pair(p.first + x.first, p.second + x.second);\n  return np;\n}\npair<long long, long long> operator-(const pair<long long, long long> &p,\n                                     const pair<long long, long long> &x) {\n  pair<long long, long long> np =\n      make_pair(p.first - x.first, p.second - x.second);\n  return np;\n}\npair<int, int> operator+(const pair<int, int> &p, const pair<int, int> &x) {\n  pair<int, int> np = make_pair(p.first + x.first, p.second + x.second);\n  return np;\n}\npair<int, int> operator-(const pair<int, int> &p, const pair<int, int> &x) {\n  pair<int, int> np = make_pair(p.first - x.first, p.second - x.second);\n  return np;\n}\nvector<int> prime;\nbool sortinrev(const pair<int, int> &a, const pair<int, int> &b) {\n  return (a.first > b.first);\n}\nbool sortbysecdesc(const pair<int, int> &a, const pair<int, int> &b) {\n  if (a.second == b.second) return a.first > b.first;\n  return a.second > b.second;\n}\nbool sortbysec(const pair<int, int> &a, const pair<int, int> &b) {\n  if (a.second == b.second) return a.first > b.first;\n  return (a.second < b.second);\n}\nlong long powerm(long long a, long long k) {\n  if (!k) {\n    return 1;\n  }\n  long long b = powerm(a, k / 2);\n  b = b * b % 998244353;\n  if (k % 2) {\n    return a * b % 998244353;\n  } else {\n    return b;\n  }\n}\nlong long power(long long a, long long b) {\n  if (b == 1) return a;\n  if (b == 0) return 1;\n  long long m1 = power(a, b / 2);\n  if (b % 2) return m1 * m1 * a;\n  return m1 * m1;\n}\nvoid PFactor(int x) {\n  prime.clear();\n  for (int i = 2; i <= x / i; i++)\n    if (x % i == 0) {\n      while (x % i == 0) x /= i, prime.push_back(i);\n    }\n  if (x > 1) prime.push_back(x);\n}\nbool isprime(long long a) {\n  if (a <= 1) return false;\n  if (a == 2 || a == 3) return true;\n  if (a % 2 == 0 || a % 3 == 0) return false;\n  for (long long i = 5; i * i <= a; i = i + 6) {\n    if (a % i == 0 || a % (i + 2) == 0) return false;\n  }\n  return true;\n}\nlong long read() {\n  long long a = 0;\n  char b = 1, c;\n  do\n    if ((c = getchar()) == 45) b = -1;\n  while (c < 48 || c > 57);\n  do a = (a << 3) + (a << 1) + (c & 15);\n  while ((c = getchar()) > 47 && c < 58);\n  return a * b;\n}\nvoid write(long long x, char c) {\n  if (x < 0) putchar(45), x = -x;\n  char a[20], s = 0;\n  do a[++s] = x % 10 | 48;\n  while (x /= 10);\n  do putchar(a[s]);\n  while (--s);\n  putchar(c);\n}\nconst int LOGN = 20;\nconst int N = (1 << LOGN);\nset<long long> g[N];\nlong long n = 0, m = 0, k = 0;\nlong long a = 0, b = 0, c = 0;\nstring str;\nlong long d[N] = {0};\nbool ban[N];\nbool vis[N];\nmap<long long, long long> tim;\nlong long dp[N];\nlong long dfs(long long u, long long fa) {\n  if (vis[u]) return -1;\n  vis[u] = true;\n  if (fa != 0 && (long long)(g[u]).size() == 1) return 1;\n  if ((long long)(g[u]).size() == 2 || fa == 0) {\n    long long v = (*g[u].begin()) == (-fa) ? (*g[u].rbegin()) : (*g[u].begin());\n    long long ans = dfs(v, u);\n    if (ans == -1)\n      return -1;\n    else\n      return ans + 1;\n  }\n  return -1;\n}\nsigned main() {\n  dp[0] = 1;\n  cin >> n >> m >> k;\n  for (long long i = 1; i <= n; i++) {\n    cin >> a;\n    cin >> b;\n    for (long long i = 2; i <= a; i++) {\n      cin >> c;\n      g[b].insert(c);\n      g[c].insert(-b);\n      b = c;\n    }\n  }\n  for (long long i = 1; i <= k; i++) {\n    if ((long long)(g[i]).size() == 0) tim[1]++;\n    if ((long long)(g[i]).size() != 1 || vis[i]) continue;\n    if ((*g[i].begin()) < 0) continue;\n    long long ans = dfs(i, 0);\n    if (ans != -1) tim[ans]++;\n  }\n  for (long long i = 1; i <= m; i++) {\n    for (auto x : tim) {\n      if (i >= x.first) dp[i] += dp[i - x.first] * x.second;\n      dp[i] %= 998244353;\n    }\n  }\n  cout << dp[m];\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 998244353;\nint main() {\n  int n, m, k;\n  cin >> n >> m >> k;\n  vector<int> c(n);\n  vector<vector<int>> A(n);\n  for (int i = 0; i < n; i++) {\n    cin >> c[i];\n    A[i].resize(c[i]);\n    for (int j = 0; j < c[i]; j++) {\n      cin >> A[i][j];\n      A[i][j]--;\n    }\n  }\n  vector<vector<int>> E1(k), E2(k);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < c[i] - 1; j++) {\n      E1[A[i][j]].push_back(A[i][j + 1]);\n      E2[A[i][j + 1]].push_back(A[i][j]);\n    }\n  }\n  for (int i = 0; i < k; i++) {\n    sort(E1[i].begin(), E1[i].end());\n    E1[i].erase(unique(E1[i].begin(), E1[i].end()), E1[i].end());\n    sort(E2[i].begin(), E2[i].end());\n    E2[i].erase(unique(E2[i].begin(), E2[i].end()), E2[i].end());\n  }\n  vector<bool> used(k, false);\n  vector<int> S;\n  for (int i = 0; i < k; i++) {\n    if (!used[i] && E2[i].empty()) {\n      used[i] = true;\n      int v = i;\n      int cnt = 1;\n      bool ok = true;\n      while (true) {\n        if (E1[v].empty()) {\n          break;\n        }\n        if (E1[v].size() >= 2) {\n          ok = false;\n          break;\n        }\n        int w = E1[v][0];\n        if (E2[w].size() >= 2) {\n          ok = false;\n          break;\n        }\n        if (used[w]) {\n          ok = false;\n          break;\n        }\n        used[w] = true;\n        cnt++;\n        v = w;\n      }\n      if (ok) {\n        S.push_back(cnt);\n      }\n    }\n  }\n  int cnt = S.size();\n  map<int, int> mp;\n  for (int i = 0; i < cnt; i++) {\n    mp[S[i]]++;\n  }\n  int cnt2 = 0;\n  vector<int> a, b;\n  for (auto P : mp) {\n    a.push_back(P.first);\n    b.push_back(P.second);\n    cnt2++;\n  }\n  vector<long long> dp(m + 1, 0);\n  dp[0] = 1;\n  for (int i = 0; i < m; i++) {\n    for (int j = 0; j < cnt2; j++) {\n      if (i + a[j] <= m) {\n        dp[i + a[j]] += dp[i] * b[j];\n        dp[i + a[j]] %= MOD;\n      }\n    }\n  }\n  cout << dp[m] << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 300005;\nconst int MOD = 998244353;\nint read() {\n  int x = 0, f = 1;\n  char c;\n  while ((c = getchar()) < '0' || c > '9') {\n    if (c == '-') f = -1;\n  }\n  while (c >= '0' && c <= '9') {\n    x = (x << 3) + (x << 1) + (c ^ 48);\n    c = getchar();\n  }\n  return x * f;\n}\nint n, m, k, t, tot, f[M], a[M], in[M], out[M], cnt[M], dp[M];\nint pd, zxy, sz, vis[M];\nmap<pair<int, int>, int> mp;\nstruct edge {\n  int v, next;\n} e[2 * M];\nvoid add(int x, int y) {\n  if (mp[make_pair(x, y)]) return;\n  mp[make_pair(x, y)] = 1;\n  in[y]++;\n  out[x]++;\n  e[++tot] = edge{y, f[x]}, f[x] = tot;\n  e[++tot] = edge{x, f[y]}, f[y] = tot;\n}\nvoid dfs(int u) {\n  sz++;\n  vis[u] = 1;\n  if (!in[u]) zxy = 1;\n  if (in[u] >= 2 || out[u] >= 2) pd = 0;\n  for (int i = f[u]; i; i = e[i].next) {\n    int v = e[i].v;\n    if (!vis[v]) dfs(v);\n  }\n}\nsigned main() {\n  n = read();\n  m = read();\n  k = read();\n  for (int i = 1; i <= n; i++) {\n    int len = read();\n    for (int j = 1, ls; j <= len; j++) {\n      int x = read();\n      if (j > 1) add(ls, x);\n      ls = x;\n    }\n  }\n  for (int i = 1; i <= k; i++)\n    if (!vis[i]) {\n      pd = 1;\n      zxy = sz = 0;\n      dfs(i);\n      if (!pd || !zxy) continue;\n      a[++t] = sz;\n      cnt[sz]++;\n    }\n  sort(a + 1, a + 1 + t);\n  t = unique(a + 1, a + 1 + t) - a - 1;\n  dp[0] = 1;\n  for (int i = 1; i <= m; i++)\n    for (int j = 1; j <= t; j++)\n      if (a[j] <= i) dp[i] = (dp[i] + 1ll * cnt[a[j]] * dp[i - a[j]]) % MOD;\n  printf(\"%d\\n\", dp[m]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = double;\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<ld, ld>;\nusing cd = complex<ld>;\nusing vcd = vector<cd>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vd = vector<ld>;\nusing vs = vector<string>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>;\nusing vpd = vector<pd>;\ntemplate <class T>\nusing min_pq = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T>\ninline int ckmin(T& a, const T& val) {\n  return val < a ? a = val, 1 : 0;\n}\ntemplate <class T>\ninline int ckmax(T& a, const T& val) {\n  return a < val ? a = val, 1 : 0;\n}\ntemplate <class T>\nvoid remDup(vector<T>& v) {\n  sort(v.begin(), v.end());\n  v.erase(unique(v.begin(), v.end()), end(v));\n}\nconstexpr int pct(int x) { return __builtin_popcount(x); }\nconstexpr int bits(int x) { return x == 0 ? 0 : 31 - __builtin_clz(x); }\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\nll ceilDiv(ll a, ll b) { return a / b + ((a ^ b) > 0 && a % b); }\nll floorDiv(ll a, ll b) { return a / b - ((a ^ b) < 0 && a % b); }\nvoid setPrec(int x) { cout << fixed << setprecision(x); }\nstring to_string(char c) { return string(1, c); }\nstring to_string(const char* s) { return (string)s; }\nstring to_string(string s) { return s; }\nstring to_string(bool b) { return to_string((int)b); }\ntemplate <class T>\nstring to_string(complex<T> c) {\n  stringstream ss;\n  ss << c;\n  return ss.str();\n}\ntemplate <class T>\nusing V = vector<T>;\nstring to_string(V<bool> v) {\n  string res = \"{\";\n  for (int i = (0); i <= (int((v).size()) - 1); i++) res += char('0' + v[i]);\n  res += \"}\";\n  return res;\n}\ntemplate <size_t sz>\nstring to_string(bitset<sz> b) {\n  string res = \"\";\n  for (int i = (0); i <= (int((b).size()) - 1); i++) res += char('0' + b[i]);\n  return res;\n}\ntemplate <class T, class U>\nstring to_string(pair<T, U> p);\ntemplate <class T>\nstring to_string(T v) {\n  bool fst = 1;\n  string res = \"\";\n  for (const auto& x : v) {\n    if (!fst) res += \" \";\n    fst = 0;\n    res += to_string(x);\n  }\n  return res;\n}\ntemplate <class T, class U>\nstring to_string(pair<T, U> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <class T>\nvoid pr(T x) {\n  cout << to_string(x);\n}\ntemplate <class T, class... U>\nvoid pr(const T& t, const U&... u) {\n  pr(t);\n  pr(u...);\n}\nvoid ps() { pr(\"\\n\"); }\ntemplate <class T, class... U>\nvoid ps(const T& t, const U&... u) {\n  pr(t);\n  if (sizeof...(u)) pr(\" \");\n  ps(u...);\n}\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate <class T, class... U>\nvoid DBG(const T& t, const U&... u) {\n  cerr << to_string(t);\n  if (sizeof...(u)) cerr << \", \";\n  DBG(u...);\n}\nconst ld PI = acos(-1.0);\nconst int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\nconst ld EPS = 1e-9;\nconst ll MODBASE = 998244353;\nconst int INF = 0x3f3f3f3f;\nconst int MAXN = 300010;\nconst int MAXM = 1000;\nconst int MAXK = 16;\nconst int MAXQ = 200010;\ntemplate <int MOD>\nstruct mint {\n  static const int mod = MOD;\n  int v;\n  explicit operator int() const { return v; }\n  mint() { v = 0; }\n  mint(ll _v) {\n    v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);\n    if (v < 0) v += MOD;\n  }\n  friend bool operator==(const mint& a, const mint& b) { return a.v == b.v; }\n  friend bool operator!=(const mint& a, const mint& b) { return !(a == b); }\n  friend bool operator<(const mint& a, const mint& b) { return a.v < b.v; }\n  friend string to_string(mint a) { return to_string(a.v); }\n  mint& operator+=(const mint& m) {\n    if ((v += m.v) >= MOD) v -= MOD;\n    return *this;\n  }\n  mint& operator-=(const mint& m) {\n    if ((v -= m.v) < 0) v += MOD;\n    return *this;\n  }\n  mint& operator*=(const mint& m) {\n    v = int((ll)v * m.v % MOD);\n    return *this;\n  }\n  mint& operator/=(const mint& m) { return (*this) *= inv(m); }\n  friend mint pow(mint a, ll p) {\n    mint ans = 1;\n    assert(p >= 0);\n    for (; p; p /= 2, a *= a)\n      if (p & 1) ans *= a;\n    return ans;\n  }\n  friend mint inv(const mint& a) {\n    assert(a.v != 0);\n    return pow(a, MOD - 2);\n  }\n  mint operator-() const { return mint(-v); }\n  mint& operator++() { return *this += 1; }\n  mint& operator--() { return *this -= 1; }\n  friend mint operator+(mint a, const mint& b) { return a += b; }\n  friend mint operator-(mint a, const mint& b) { return a -= b; }\n  friend mint operator*(mint a, const mint& b) { return a *= b; }\n  friend mint operator/(mint a, const mint& b) { return a /= b; }\n};\nint n, m, k, cnt[MAXN];\nmint<MODBASE> dp[MAXN];\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(nullptr);\n  cin >> n >> m >> k;\n  vector<vi> A(n);\n  vi bad(k);\n  for (int i = (0); i <= (n - 1); i++) {\n    int c;\n    cin >> c;\n    A[i].resize(c);\n    for (int j = (0); j <= (c - 1); j++) {\n      cin >> A[i][j];\n      A[i][j]--;\n    }\n  }\n  for (int i = (0); i <= (n - 1); i++) {\n    if (set<int>(A[i].begin(), A[i].end()).size() != A[i].size()) {\n      for (auto& x : A[i]) {\n        bad[x] = 1;\n      }\n    }\n  }\n  vector<vi> nex(k), pre(k);\n  for (int i = (0); i <= (n - 1); i++) {\n    for (int j = (0); j <= (int((A[i]).size()) - 2); j++) {\n      nex[A[i][j]].push_back(A[i][j + 1]);\n      pre[A[i][j + 1]].push_back(A[i][j]);\n    }\n  }\n  for (int i = (0); i <= (k - 1); i++) {\n    remDup(nex[i]);\n    remDup(pre[i]);\n  }\n  vi used(k, 0);\n  for (int i = (0); i <= (k - 1); i++) {\n    if (used[i]) continue;\n    queue<int> q;\n    vi comp;\n    q.push(i);\n    used[i] = 1;\n    while (int((q).size())) {\n      int u = q.front();\n      q.pop();\n      comp.push_back(u);\n      for (auto& v : nex[u])\n        if (!used[v]) {\n          used[v] = 1;\n          q.push(v);\n        }\n      for (auto& v : pre[u])\n        if (!used[v]) {\n          used[v] = 1;\n          q.push(v);\n        }\n    }\n    bool isBad = false;\n    int cntBegin = 0;\n    for (auto& x : comp) {\n      if (int((pre[x]).size()) == 0) cntBegin++;\n      if (int((pre[x]).size()) > 1 || int((nex[x]).size()) > 1 || bad[x])\n        isBad = true;\n    }\n    isBad |= (cntBegin == 0);\n    if (isBad) continue;\n    cnt[int((comp).size())]++;\n  }\n  vi non0;\n  for (int i = (1); i <= (k); i++)\n    if (cnt[i]) non0.push_back(i);\n  dp[0] = 1;\n  for (int i = (1); i <= (m); i++) {\n    for (auto& x : non0) {\n      if (x <= i) dp[i] += dp[i - x] * cnt[x];\n    }\n  }\n  cout << int(dp[m]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\ntemplate <typename T1, typename T2>\ninline void remin(T1& a, T2 b) {\n  a = min(a, (T1)b);\n}\ntemplate <typename T1, typename T2>\ninline void remax(T1& a, T2 b) {\n  a = max(a, (T1)b);\n}\nconst int LOG = 19, maxN = 1 << LOG, mod = 998244353;\ntemplate <typename T1, typename T2>\ninline void addMod(T1& a, T2 b) {\n  a = (a + b) % mod;\n}\ntemplate <typename T1, typename T2>\ninline void multMod(T1& a, T2 b) {\n  a = a * b % mod;\n}\nint vis[maxN], nxt[maxN], prv[maxN], T[maxN];\nlong long dp[maxN];\nbool ban[maxN];\nvoid fail() {\n  printf(\"0\\n\");\n  exit(0);\n}\nmap<int, int> M;\nvector<pair<int, int> > kys;\nvoid solve() {\n  int n, m, k;\n  scanf(\"%d%d%d\", &n, &m, &k);\n  for (int v = (1); v < (n + 1); v++) {\n    int c;\n    scanf(\"%d\", &c);\n    bool dupl = false;\n    for (int i = (0); i < (c); i++) {\n      scanf(\"%d\", T + i);\n      if (vis[T[i]] == v) dupl = true;\n      vis[T[i]] = v;\n    }\n    if (dupl) {\n      for (int i = (0); i < (c); i++) ban[T[i]] = true;\n      continue;\n    }\n    for (int i = (0); i < (c - 1); i++) {\n      int x = T[i];\n      if (nxt[x] != 0 and nxt[x] != T[i + 1])\n        ban[x] = ban[nxt[x]] = true;\n      else\n        nxt[x] = T[i + 1];\n    }\n    for (int i = (1); i < (c); i++) {\n      int x = T[i];\n      if (prv[x] != 0 and prv[x] != T[i - 1])\n        ban[x] = ban[prv[x]] = true;\n      else\n        prv[x] = T[i - 1];\n    }\n  }\n  for (int v = (1); v < (k + 1); v++)\n    if (prv[v] == 0) {\n      int d = 0;\n      bool ok = true;\n      for (int x = v; x != 0; x = nxt[x]) {\n        d++;\n        if (ban[x] or (x == v and d != 1)) {\n          ok = false;\n          break;\n        }\n      }\n      if (ok) M[d]++;\n    }\n  for (auto it : M) kys.push_back(it);\n  dp[0] = 1;\n  for (int i = (1); i < (m + 1); i++) {\n    for (int j = (0); j < (((int)(kys).size())); j++) {\n      int ki, vl;\n      tie(ki, vl) = kys[j];\n      if (ki <= i) dp[i] += dp[i - ki] * vl;\n    }\n    dp[i] %= mod;\n  }\n  printf(\"%lld\\n\", dp[m]);\n}\nint main() {\n  int t = 1;\n  for (int tid = (1); tid < (t + 1); tid++) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long gcd(long long a, long long b) {\n  if (!a || !b) return a | b;\n  unsigned shift = __builtin_ctz(a | b);\n  a >>= __builtin_ctz(a);\n  do {\n    b >>= __builtin_ctz(b);\n    if (a > b) swap(a, b);\n    b -= a;\n  } while (b);\n  return a << shift;\n}\nlong long lcm(long long a, long long b) { return (long long)a * b / gcd(a, b); }\nconst int INF = 800000010;\nint lsb(int i) { return i & -i; }\nstruct SegTree {\n  int size;\n  vector<long long> arr;\n  void init(int sz) {\n    size = 1;\n    while (size < sz) size *= 2;\n    arr.resize(2 * size - 1);\n    for (int i = (0); (1) > 0 ? i < (size) : i > (size); i += (1)) {\n      arr[i] = 0;\n    }\n  }\n  void set(int i, long long val, int x, int lx, int rx) {\n    int mid = (lx + rx) / 2;\n    if (lx == rx) {\n      arr[x] += val;\n    } else {\n      if (i <= mid) {\n        set(i, val, 2 * x + 1, lx, mid);\n      } else {\n        set(i, val, 2 * x + 2, mid + 1, rx);\n      }\n      arr[x] = arr[2 * x + 1] + arr[2 * x + 2];\n    }\n  }\n  void set(int i, long long val) { set(i, val, 0, 0, size - 1); }\n  long long get(int x, int y) { return get(x, y, 0, 0, size - 1); }\n  long long get(int l, int r, int x, int lx, int rx) {\n    int mid = (lx + rx) / 2;\n    if (l == lx && r == rx) {\n      return arr[x];\n    } else if (l <= mid && r >= mid + 1) {\n      return get(l, mid, 2 * x + 1, lx, mid) +\n             get(mid + 1, r, 2 * x + 2, mid + 1, rx);\n    } else if (l <= mid) {\n      return get(l, r, 2 * x + 1, lx, mid);\n    } else {\n      return get(l, r, 2 * x + 2, mid + 1, rx);\n    }\n  }\n  int getval(int i) { return (arr[i]); }\n  int getsize() { return size; }\n};\ntemplate <class T>\nbool umin(T& a, const T& b) {\n  return b < a ? a = b, 1 : 0;\n}\ntemplate <class T>\nbool umax(T& a, const T& b) {\n  return a < b ? a = b, 1 : 0;\n}\nint binarySearch(vector<int> arr, int p, int r, int num) {\n  if (p <= r) {\n    int mid = (p + r) / 2;\n    if (arr[mid] == num) return mid;\n    if (arr[mid] > num) return binarySearch(arr, p, mid - 1, num);\n    if (arr[mid] > num) return binarySearch(arr, mid + 1, r, num);\n  }\n  return -1;\n}\nlong long FIRSTTRUE(function<bool(long long)> f, long long lb, long long rb) {\n  while (lb < rb) {\n    long long mb = (lb + rb) / 2;\n    f(mb) ? rb = mb : lb = mb + 1;\n  }\n  return lb;\n}\nlong long LASTTRUE(function<bool(long long)> f, long long lb, long long rb) {\n  while (lb < rb) {\n    long long mb = (lb + rb + 1) / 2;\n    f(mb) ? lb = mb : rb = mb - 1;\n  }\n  return lb;\n}\ntemplate <class A>\nvoid read(vector<A>& v);\ntemplate <class A, size_t S>\nvoid read(array<A, S>& a);\ntemplate <class T>\nvoid read(T& x) {\n  cin >> x;\n}\nvoid read(double& d) {\n  string t;\n  read(t);\n  d = stod(t);\n}\nvoid read(long double& d) {\n  string t;\n  read(t);\n  d = stold(t);\n}\ntemplate <class H, class... T>\nvoid read(H& h, T&... t) {\n  read(h);\n  read(t...);\n}\ntemplate <class A>\nvoid read(vector<A>& x) {\n  for (auto& a : x) read(a);\n}\ntemplate <class A, size_t S>\nvoid read(array<A, S>& x) {\n  for (auto& a : x) read(a);\n}\nstring to_string(char c) { return string(1, c); }\nstring to_string(bool b) { return b ? \"true\" : \"false\"; }\nstring to_string(const char* s) { return string(s); }\nstring to_string(string s) { return s; }\nstring to_string(vector<bool> v) {\n  string res;\n  for (int i = (0); (1) > 0 ? i < ((int)(v).size()) : i > ((int)(v).size());\n       i += (1))\n    res += char('0' + v[i]);\n  return res;\n}\ntemplate <size_t S>\nstring to_string(bitset<S> b) {\n  string res;\n  for (int i = (0); (1) > 0 ? i < (S) : i > (S); i += (1))\n    res += char('0' + b[i]);\n  return res;\n}\ntemplate <class T>\nstring to_string(T v) {\n  bool f = 1;\n  string res;\n  for (auto& x : v) {\n    if (!f) res += ' ';\n    f = 0;\n    res += to_string(x);\n  }\n  return res;\n}\ntemplate <class A>\nvoid write(A x) {\n  cout << to_string(x);\n}\ntemplate <class H, class... T>\nvoid write(const H& h, const T&... t) {\n  write(h);\n  write(t...);\n}\nvoid print() { write(\"\\n\"); }\ntemplate <class H, class... T>\nvoid print(const H& h, const T&... t) {\n  write(h);\n  if (sizeof...(t)) write(' ');\n  print(t...);\n}\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate <class H, class... T>\nvoid DBG(H h, T... t) {\n  cerr << to_string(h);\n  if (sizeof...(t)) cerr << \", \";\n  DBG(t...);\n}\ntemplate <class T>\nvoid offset(long long o, T& x) {\n  x += o;\n}\ntemplate <class T>\nvoid offset(long long o, vector<T>& x) {\n  for (auto& a : x) offset(o, a);\n}\ntemplate <class T, size_t S>\nvoid offset(long long o, array<T, S>& x) {\n  for (auto& a : x) offset(o, a);\n}\nmt19937 mt_rng(chrono::steady_clock::now().time_since_epoch().count());\nlong long randint(long long a, long long b) {\n  return uniform_int_distribution<long long>(a, b)(mt_rng);\n}\ntemplate <class T, class U>\nvoid vti(vector<T>& v, U x, size_t n) {\n  v = vector<T>(n, x);\n}\ntemplate <class T, class U>\nvoid vti(vector<T>& v, U x, size_t n, size_t m...) {\n  v = vector<T>(n);\n  for (auto& a : v) vti(a, x, m);\n}\nconst int d4i[4] = {-1, 0, 1, 0}, d4j[4] = {0, 1, 0, -1};\nconst int d8i[8] = {-1, -1, 0, 1, 1, 1, 0, -1},\n          d8j[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int mxN = 5e5 + 1, M = 1e9 + 7;\nint n, m, p[mxN];\nint find(int x) { return x ^ p[x] ? p[x] = find(p[x]) : x; }\nbool join(int x, int y) {\n  if ((x = find(x)) == (y = find(y))) return 0;\n  p[find(x)] = find(y);\n  return 1;\n}\nlong long pow(long long a, long long b, long long mod) {\n  if (b == 0) {\n    return 1;\n  }\n  long long sum = pow(a, b / 2, mod);\n  if (b % 2 == 1) {\n    return (((sum * sum) % mod) * a) % mod;\n  } else {\n    return (sum * sum) % mod;\n  }\n}\nset<int> adjlist[300005];\nset<int> ingree[300005];\nbool visited[300005];\nlong long dp[300005];\nmap<int, int> mp;\nint cur = 0;\nvoid dfs(int node) {\n  if (visited[node]) return;\n  visited[node] = true;\n  cur++;\n  if (adjlist[node].size() > 1 || ingree[node].size() > 1) return;\n  if (adjlist[node].empty()) {\n    if (mp.find(cur) == mp.end()) {\n      mp[cur] = 1;\n    } else {\n      mp[cur]++;\n    }\n    return;\n  }\n  for (auto& e : adjlist[node]) dfs(e);\n}\nvoid solve() {\n  int n, m, k;\n  cin >> n >> m >> k;\n  for (int i = (0); (1) > 0 ? i < (n) : i > (n); i += (1)) {\n    int c;\n    cin >> c;\n    int last;\n    for (int j = (0); (1) > 0 ? j < (c) : j > (c); j += (1)) {\n      if (j == 0) {\n        cin >> last;\n        last--;\n      } else {\n        int u;\n        cin >> u;\n        u--;\n        adjlist[last].insert(u);\n        ingree[u].insert(last);\n        last = u;\n      }\n    }\n  }\n  for (int i = (0); (1) > 0 ? i < (k) : i > (k); i += (1)) {\n    if (ingree[i].empty()) {\n      cur = 0;\n      dfs(i);\n    }\n  }\n  dp[0] = 1;\n  for (int i = 1; i <= m; i++) {\n    dp[i] = 0;\n    for (auto& e : mp) {\n      if (i >= e.first) {\n        dp[i] += (long long)e.second * dp[i - e.first];\n      }\n    }\n    dp[i] %= 998244353;\n  }\n  cout << dp[m] << '\\n';\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int tc = 1;\n  for (int i = (0); (1) > 0 ? i < (tc) : i > (tc); i += (1)) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint read() {\n  int x = 0, f = 0;\n  char ch = getchar();\n  while (!isdigit(ch)) f |= ch == '-', ch = getchar();\n  while (isdigit(ch)) x = 10 * x + ch - '0', ch = getchar();\n  return f ? -x : x;\n}\ntemplate <typename T>\nvoid print(T x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x >= 10) print(x / 10);\n  putchar(x % 10 + '0');\n}\ntemplate <typename T>\nvoid print(T x, char let) {\n  print(x), putchar(let);\n}\nconst int N = 3e5 + 5;\nconst int MOD = 998244353;\nint n, m, k, vis[N], in[N], out[N], d[N], a[N], cnt, vis1[N];\nint b[N], e[N], cnt2, vis2[N], dp[N];\nvector<int> G[N];\nbool dfs(int u, int idx) {\n  vis[u] = 1;\n  for (int i = 0; i < G[u].size(); i++) {\n    int v = G[u][i];\n    if (!vis[v] && in[v] == 1 && out[v] <= 1) {\n      bool b = dfs(v, idx);\n      if (b) d[u] = idx;\n      return b;\n    } else {\n      return false;\n    }\n  }\n  d[u] = idx;\n  return true;\n}\nint main() {\n  n = read();\n  m = read();\n  k = read();\n  int x, y;\n  for (int i = 1; i <= n; i++) {\n    x = read();\n    int l;\n    for (int j = 1; j <= x; j++) {\n      y = read();\n      if (j != 1) {\n        G[l].push_back(y);\n      }\n      l = y;\n    }\n  }\n  for (int i = 1; i <= k; i++) {\n    sort(G[i].begin(), G[i].end());\n    vector<int>::iterator x = unique(G[i].begin(), G[i].end());\n    G[i].erase(x, G[i].end());\n    for (int j = 0; j < G[i].size(); j++) {\n      int v = G[i][j];\n      in[v]++;\n      out[i]++;\n    }\n  }\n  int tot = 0;\n  for (int i = 1; i <= k; i++) {\n    if (!vis[i] && in[i] == 0 && out[i] == 1) {\n      dfs(i, ++tot);\n    }\n    if (in[i] == 0 && out[i] == 0) {\n      d[i] = ++tot;\n    }\n  }\n  for (int i = 1; i <= k; i++) {\n    if (d[i]) {\n      if (vis1[d[i]] == 0) {\n        ++cnt;\n        a[cnt] = 1;\n        vis1[d[i]] = cnt;\n      } else {\n        a[vis1[d[i]]]++;\n      }\n    }\n  }\n  for (int i = 1; i <= cnt; i++) {\n    if (vis2[a[i]] == 0) {\n      ++cnt2;\n      b[cnt2] = a[i];\n      e[cnt2] = 1;\n      vis2[a[i]] = cnt2;\n    } else {\n      e[vis2[a[i]]]++;\n    }\n  }\n  dp[0] = 1;\n  for (int i = 1; i <= m; i++) {\n    for (int j = 1; j <= cnt2; j++) {\n      if (i >= b[j]) {\n        dp[i] = (dp[i] + 1ll * dp[i - b[j]] * e[j] % MOD) % MOD;\n      }\n    }\n  }\n  cout << dp[m] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\nstruct DSU {\n  int n;\n  vector<int> link, sz;\n  DSU(int n) : n(n), link(n), sz(n) {\n    for (int i = 0; i < n; i++) {\n      link[i] = i;\n      sz[i] = 1;\n    }\n  }\n  int first(int x) { return (x == link[x] ? x : link[x] = first(link[x])); }\n  void unite(int x, int y) {\n    x = first(x), y = first(y);\n    if (x == y) {\n      return;\n    }\n    if (sz[x] < sz[y]) {\n      swap(x, y);\n    }\n    sz[x] += sz[y], link[y] = x;\n  }\n};\nint n, m, k, dp[300001], nxt[300000], prv[300000];\nvector<int> arr[300000], dsc[300000];\nvector<pair<int, int>> trns;\nmap<int, int> chns;\nbool bad[300000], appeared[300000];\nint mul(int x, int y) { return ((long long)x * y) % mod; }\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin >> n >> m >> k;\n  DSU grp(k);\n  for (int i = 0; i < k; i++) {\n    nxt[i] = prv[i] = -1;\n  }\n  for (int i = 0, sz; i < n; i++) {\n    cin >> sz;\n    arr[i].resize(sz);\n    for (int j = 0; j < sz; j++) {\n      cin >> arr[i][j];\n      appeared[arr[i][j] - 1] = true;\n    }\n    for (int j = 0; j < sz - 1; j++) {\n      grp.unite(arr[i][j] - 1, arr[i][j + 1] - 1);\n    }\n  }\n  for (int i = 0; i < k; i++) {\n    dsc[grp.first(i)].push_back(i);\n  }\n  for (int i = 0; i < n; i++) {\n    int sz = arr[i].size();\n    for (int j = 0; j < sz - 1; j++) {\n      if (prv[arr[i][j + 1] - 1] != -1 &&\n          prv[arr[i][j + 1] - 1] != arr[i][j] - 1) {\n        bad[grp.first(arr[i][j] - 1)] = true;\n      }\n      if (nxt[arr[i][j] - 1] != -1 && nxt[arr[i][j] - 1] != arr[i][j + 1] - 1) {\n        bad[grp.first(arr[i][j] - 1)] = true;\n      }\n      prv[arr[i][j + 1] - 1] = arr[i][j] - 1;\n      nxt[arr[i][j] - 1] = arr[i][j + 1] - 1;\n    }\n  }\n  for (int i = 0; i < k; i++) {\n    if (bad[i]) {\n      for (int j : dsc[i]) {\n        bad[j] = true;\n      }\n    }\n  }\n  for (int i = 0; i < k; i++) {\n    if (prv[i] == -1 && !bad[i]) {\n      int chn = 1, cur = i;\n      while (nxt[cur] != -1) {\n        cur = nxt[cur];\n        ++chn;\n      }\n      ++chns[chn];\n    }\n  }\n  for (auto it : chns) {\n    trns.push_back(it);\n  }\n  dp[0] = 1;\n  for (int i = 1; i <= m; i++) {\n    for (auto j : trns) {\n      if (i >= j.first) {\n        dp[i] = (dp[i] + mul(dp[i - j.first], j.second)) % mod;\n      }\n    }\n  }\n  cout << dp[m] << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\nstring to_string(const string& s) { return '\"' + s + '\"'; }\nstring to_string(const char* s) { return to_string((string)s); }\nstring to_string(bool b) { return (b ? \"true\" : \"false\"); }\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto& x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" +\n         to_string(get<2>(p)) + \")\";\n}\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" +\n         to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a;\n    swap(a, m);\n    u -= t * v;\n    swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod())\n      v = static_cast<Type>(x);\n    else\n      v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const {\n    return static_cast<U>(value);\n  }\n  constexpr static Type mod() { return T::value; }\n  Modular& operator+=(const Modular& other) {\n    if ((value += other.value) >= mod()) value -= mod();\n    return *this;\n  }\n  Modular& operator-=(const Modular& other) {\n    if ((value -= other.value) < 0) value += mod();\n    return *this;\n  }\n  template <typename U>\n  Modular& operator+=(const U& other) {\n    return *this += Modular(other);\n  }\n  template <typename U>\n  Modular& operator-=(const U& other) {\n    return *this -= Modular(other);\n  }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) {\n    Modular result(*this);\n    *this += 1;\n    return result;\n  }\n  Modular operator--(int) {\n    Modular result(*this);\n    *this -= 1;\n    return result;\n  }\n  Modular operator-() const { return Modular(-value); }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value,\n                     Modular>::type&\n  operator*=(const Modular& rhs) {\n    value = normalize(static_cast<int64_t>(value) *\n                      static_cast<int64_t>(rhs.value));\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value,\n                     Modular>::type&\n  operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) *\n                                         rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value,\n                     Modular>::type&\n  operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n  Modular& operator/=(const Modular& other) {\n    return *this *= Modular(inverse(other.value, mod()));\n  }\n  friend const Type& abs(const Modular& x) { return x.value; }\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\ntemplate <typename T>\nbool operator==(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return lhs.value == rhs.value;\n}\ntemplate <typename T, typename U>\nbool operator==(const Modular<T>& lhs, U rhs) {\n  return lhs == Modular<T>(rhs);\n}\ntemplate <typename T, typename U>\nbool operator==(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) == rhs;\n}\ntemplate <typename T>\nbool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T, typename U>\nbool operator!=(const Modular<T>& lhs, U rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T, typename U>\nbool operator!=(U lhs, const Modular<T>& rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T>\nbool operator<(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return lhs.value < rhs.value;\n}\ntemplate <typename T>\nModular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator+(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator+(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T>\nModular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator-(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator-(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T>\nModular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator*(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator*(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T>\nModular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator/(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator/(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, k;\n  cin >> n >> m >> k;\n  vector<vector<int>> g(k);\n  vector<vector<int>> gr(k);\n  for (int i = 0; i < n; i++) {\n    int len;\n    cin >> len;\n    int last;\n    cin >> last;\n    --last;\n    for (int j = 1; j < len; j++) {\n      int cur;\n      cin >> cur;\n      --cur;\n      g[last].push_back(cur);\n      gr[cur].push_back(last);\n      last = cur;\n    }\n  }\n  for (int i = 0; i < k; i++) {\n    sort(g[i].begin(), g[i].end());\n    g[i].resize(unique(g[i].begin(), g[i].end()) - g[i].begin());\n    sort(gr[i].begin(), gr[i].end());\n    gr[i].resize(unique(gr[i].begin(), gr[i].end()) - gr[i].begin());\n  }\n  map<int, int> mp;\n  vector<bool> was(k, false);\n  vector<bool> used(k, false);\n  for (int start = 0; start < k; start++) {\n    if (was[start]) {\n      continue;\n    }\n    vector<int> que(1, start);\n    was[start] = true;\n    for (int b = 0; b < (int)que.size(); b++) {\n      for (int j : g[que[b]]) {\n        if (!was[j]) {\n          que.push_back(j);\n          was[j] = true;\n        }\n      }\n      for (int j : gr[que[b]]) {\n        if (!was[j]) {\n          que.push_back(j);\n          was[j] = true;\n        }\n      }\n    }\n    int edges = 0;\n    for (int i : que) {\n      edges += (int)g[i].size();\n    }\n    if (edges != (int)que.size() - 1) {\n      continue;\n    }\n    int root = -1;\n    for (int i : que) {\n      if (gr[i].empty()) {\n        root = i;\n        break;\n      }\n    }\n    assert(root != -1);\n    vector<int> seq(1, root);\n    used[root] = true;\n    while (true) {\n      int nxt = -1;\n      for (int i : g[seq.back()]) {\n        if (!used[i]) {\n          nxt = i;\n          break;\n        }\n      }\n      if (nxt == -1) {\n        break;\n      }\n      seq.push_back(nxt);\n      used[nxt] = true;\n    }\n    if (seq.size() == que.size()) {\n      mp[(int)seq.size()] += 1;\n    }\n  }\n  vector<pair<int, int>> ps, sssss;\n  for (auto& p : mp) {\n    ps.push_back(p);\n  }\n  vector<Mint> dp(m + 1);\n  dp[0] = 1;\n  for (int i = 1; i <= m; i++) {\n    for (auto& p : ps) {\n      if (i >= p.first) {\n        dp[i] += dp[i - p.first] * p.second;\n      }\n    }\n  }\n  cout << dp[m] << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nnamespace {\ntemplate <typename T>\nstruct SparseTable {\n  std::vector<std::vector<T>> u;\n  std::vector<int> lg;\n  void build(const std::vector<T>& a) {\n    int n = a.size(), L = 1;\n    while ((1 << L) <= n) ++L;\n    std::vector<std::vector<T>>(n, std::vector<T>(L)).swap(u);\n    lg.resize(n + 1);\n    lg[0] = -1;\n    for (int i = 1; i < lg.size(); ++i) lg[i] = lg[i >> 1] + 1;\n    for (int i = 0; i < n; ++i) u[i][0] = a[i];\n    for (int j = 1; (1 << j) <= n; ++j) {\n      for (int i = 0; i + (1 << j) <= n; ++i) {\n        u[i][j] = std::min(u[i][j - 1], u[i + (1 << (j - 1))][j - 1]);\n      }\n    }\n  }\n  T ask(int a, int b) const {\n    if (a > b || a < 0 || b >= u.size()) throw;\n    int k = lg[b - a + 1];\n    return std::min(u[a][k], u[b - (1 << k) + 1][k]);\n  }\n};\nusing String = std::vector<int>;\nstruct SuffixArray {\n  int n;\n  String str;\n  std::vector<int> sa, rank;\n  std::vector<int> lcp;\n  SparseTable<int> st;\n  SuffixArray(const String& _s)\n      : n(_s.size()), str(_s), sa(n + 1), rank(n + 1) {\n    for (int i = 0; i <= n; ++i) {\n      sa[i] = i;\n      rank[i] = i < n ? str[i] : -1;\n    }\n    std::vector<int> tmp(n + 1);\n    for (int k = 1; k <= n; k <<= 1) {\n      auto compare_sa = [=](int i, int j) {\n        if (rank[i] != rank[j])\n          return rank[i] < rank[j];\n        else {\n          int ri = i + k <= n ? rank[i + k] : -1;\n          int rj = j + k <= n ? rank[j + k] : -1;\n          return ri < rj;\n        }\n      };\n      std::sort(sa.begin(), sa.end(), compare_sa);\n      tmp[sa[0]] = 0;\n      for (int i = 1; i <= n; i++) {\n        tmp[sa[i]] = tmp[sa[i - 1]] + (compare_sa(sa[i - 1], sa[i]) ? 1 : 0);\n      }\n      rank.swap(tmp);\n    }\n    for (int i = 0; i <= n; ++i) rank[sa[i]] = i;\n    lcp.resize(n + 1, 0);\n    int h = 0;\n    for (int i = 0; i < n; ++i) {\n      int j = sa[rank[i] - 1];\n      if (h > 0) --h;\n      for (; j + h < n && i + h < n; ++h) {\n        if (str[j + h] != str[i + h]) break;\n      }\n      lcp[rank[i] - 1] = h;\n    }\n  }\n  int compare(const String& lhs, int pos, int len, const String& rhs) const {\n    for (int i = pos; i < pos + len; ++i) {\n      if (i >= lhs.size()) {\n        return i - pos >= rhs.size() ? 0 : -1;\n      }\n      if (i - pos >= rhs.size()) {\n        return 1;\n      }\n      if (lhs[i] != rhs[i - pos]) {\n        return lhs[i] - rhs[i - pos];\n      }\n    }\n    return len < rhs.size() ? -1 : 0;\n  }\n  template <typename Compare>\n  int binary_search(const String& t) const {\n    int lb = -1, ub = n + 1;\n    while (ub - lb > 1) {\n      int mid = (ub + lb) / 2;\n      if (Compare()(compare(str, sa[mid], t.size(), t), 0))\n        lb = mid;\n      else\n        ub = mid;\n    }\n    return ub;\n  }\n  bool contains(const String& t) const {\n    int lb = 0, ub = n;\n    while (ub - lb > 1) {\n      int mid = (lb + ub) / 2;\n      if (compare(str, sa[mid], t.size(), t) < 0)\n        lb = mid;\n      else\n        ub = mid;\n    }\n    return compare(str, sa[ub], t.size(), t) == 0;\n  }\n  void prepare_lcp_rmq() { st.build(lcp); }\n  int get_lcp(int x, int y) const {\n    if (x == y) return n - x;\n    if (rank[x] > rank[y]) std::swap(x, y);\n    return st.ask(rank[x], rank[y] - 1);\n  }\n  int lower_bound(const String& t) const {\n    return binary_search<std::less<int>>(t);\n  }\n  int upper_bound(const String& t) const {\n    return binary_search<std::less_equal<int>>(t);\n  }\n};\nint example(const String& s) {\n  SuffixArray sa(s);\n  return s.size() - *std::max_element(sa.lcp.begin(), sa.lcp.end());\n}\ntemplate <int MOD>\nstruct Integral {\n  int v_ = 0;\n  template <typename T>\n  Integral(T v) : v_(norm(v)) {\n    static_assert(std::is_integral<T>::value, \"input should be an integral.\");\n  }\n  Integral() = default;\n  ~Integral() = default;\n  template <typename T>\n  T norm(T v) const {\n    if constexpr (std::is_same<long long, T>::value) {\n      v %= MOD;\n      if (v < 0) v += MOD;\n    } else {\n      if (v >= MOD) v -= MOD;\n      if (v < 0) v += MOD;\n      if (v >= MOD || v < 0) {\n        v %= MOD;\n        if (v < 0) v += MOD;\n      }\n    }\n    return v;\n  }\n  int val() const { return v_; }\n  Integral& operator+=(const Integral& rhs) {\n    v_ += rhs.val();\n    if (v_ >= MOD) v_ -= MOD;\n    return *this;\n  }\n  Integral& operator-=(const Integral& rhs) {\n    v_ += MOD - rhs.val();\n    if (v_ >= MOD) v_ -= MOD;\n    return *this;\n  }\n  Integral& operator*=(const Integral& rhs) {\n    v_ = v_ * 1LL * rhs.val() % MOD;\n    return *this;\n  }\n  Integral& operator/=(const Integral& rhs) {\n    v_ = v_ * 1LL * rhs.inv().val() % MOD;\n    return *this;\n  }\n  Integral operator+(const Integral& rhs) const {\n    Integral ret = *this;\n    return ret += rhs;\n  }\n  Integral operator-(const Integral& rhs) const {\n    Integral ret = *this;\n    return ret -= rhs;\n  }\n  Integral operator*(const Integral& rhs) const {\n    Integral ret = *this;\n    return ret *= rhs;\n  }\n  Integral operator/(const Integral& rhs) const {\n    Integral ret = *this;\n    return ret /= rhs;\n  }\n  bool operator==(const Integral& rhs) const { return val() == rhs.val(); }\n  bool operator!=(const Integral& rhs) const { return !(*this == rhs); }\n  const Integral operator-() const { return Integral(-val()); }\n  const Integral& operator++() {\n    v_ += 1;\n    if (v_ >= MOD) v_ -= MOD;\n    return *this;\n  }\n  const Integral operator++(int) {\n    Integral ret = *this;\n    ++(*this);\n    return ret;\n  }\n  const Integral& operator--() {\n    v_ += MOD - 1;\n    if (v_ >= MOD) v_ -= MOD;\n    return *this;\n  }\n  const Integral operator--(int) {\n    Integral ret = *this;\n    --(*this);\n    return ret;\n  }\n  Integral power(long long b) const {\n    long long ret = 1 % MOD, a = v_;\n    for (; b; b >>= 1, a = a * a % MOD)\n      if (b & 1) ret = ret * a % MOD;\n    return ret;\n  }\n  Integral inv() const { return power(MOD - 2); }\n};\ntemplate <int MOD>\nstd::string to_string(const Integral<MOD>& v) {\n  return std::string(\"{\") + std::to_string(v.val()) + \"}\";\n}\ntemplate <int MOD, bool kAllowBruteForce = false>\nstruct Binomial {\n  std::vector<Integral<MOD>> factor, inv_factor;\n  explicit Binomial(int n = 0) : factor(n + 1), inv_factor(n + 1) {\n    factor[0] = 1;\n    for (int i = 1; i <= n; ++i) factor[i] = factor[i - 1] * i;\n    inv_factor[n] = factor[n].inv();\n    for (int i = n; i >= 1; --i) inv_factor[i - 1] = inv_factor[i] * i;\n  }\n  ~Binomial() = default;\n  template <typename T>\n  Integral<MOD> operator()(T a, T b) const {\n    if (a < b || b < 0) return 0;\n    if (a < factor.size()) return factor[a] * inv_factor[b] * inv_factor[a - b];\n    if constexpr (!kAllowBruteForce) {\n      throw std::out_of_range(\"Binomial\");\n    } else {\n      b = std::min(b, a - b);\n      Integral<MOD> ret = 1;\n      for (T i = 1; i <= b; ++i) ret = ret * (a + 1 - i) / i;\n      return ret;\n    }\n  }\n};\ntemplate <int MOD>\nstruct PowerTable : public std::vector<Integral<MOD>> {\n  PowerTable(int n, const Integral<MOD>& g) {\n    static_assert(sizeof(PowerTable) == sizeof(std::vector<Integral<MOD>>), \"\");\n    this->resize(n + 1);\n    this->at(0) = 1;\n    this->at(1) = g;\n    for (int i = 2; i < this->size(); ++i)\n      this->at(i) = this->at(i - 1) * this->at(1);\n  }\n};\nconst int MOD = 998244353;\nusing Mint = Integral<MOD>;\nusing Binom = Binomial<MOD>;\nBinom binom(300000);\ntemplate <int MOD = 998244353, int kPrimRoot = 3>\nvoid ntt(Integral<MOD> A[], int n, int inv) {\n  Integral<MOD> w = 1, d = Integral<MOD>(kPrimRoot).power((MOD - 1) / n), t;\n  int i, j, c, s;\n  if (inv == -1) {\n    for (i = 1, j = n - 1; i < j; ++i, --j) std::swap(A[i], A[j]);\n    for (t = Integral<MOD>(n).inv(), i = 0; i < n; ++i) A[i] = A[i] * t;\n  }\n  for (s = n >> 1; s; s >>= 1, w = 1, d = d * d) {\n    for (c = 0; c < s; ++c, w = w * d) {\n      for (i = c; i < n; i += s << 1) {\n        A[i | s] = (A[i] - (t = A[i | s])) * w;\n        A[i] += t;\n      }\n    }\n  }\n  for (i = 1; i < n; ++i) {\n    for (j = 0, s = i, c = n >> 1; c; c >>= 1, s >>= 1) j = j << 1 | (s & 1);\n    if (i < j) std::swap(A[i], A[j]);\n  }\n}\ntemplate <typename T>\nusing Polynomial = std::vector<T>;\ntemplate <typename T>\nvoid ntt(Polynomial<T>& poly, int n, int inv) {\n  if (poly.size() < n) {\n    poly.resize(n, 0);\n  }\n  return ntt(&poly[0], n, inv);\n}\ntemplate <typename T>\nvoid norm(Polynomial<T>& p) {\n  while (p.size() > 1 && p.back() == T(0)) p.pop_back();\n}\ntemplate <typename T>\nPolynomial<T> operator+(const Polynomial<T>& lhs, const Polynomial<T>& rhs) {\n  Polynomial<T> ret = lhs;\n  ret.resize(std::max(lhs.size(), rhs.size()), T(0));\n  for (int i = 0; i < rhs.size(); ++i) ret[i] += rhs[i];\n  norm(ret);\n  return ret;\n}\ntemplate <typename T>\nPolynomial<T> operator-(const Polynomial<T>& lhs, const Polynomial<T>& rhs) {\n  Polynomial<T> ret = lhs;\n  ret.resize(std::max(lhs.size(), rhs.size()), T(0));\n  for (int i = 0; i < rhs.size(); ++i) ret[i] -= rhs[i];\n  norm(ret);\n  return ret;\n}\ntemplate <typename T>\nPolynomial<T> mod_len(Polynomial<T> poly, int len) {\n  if (poly.size() > len) {\n    poly.resize(len);\n  }\n  norm(poly);\n  return poly;\n}\ntemplate <typename T>\nPolynomial<T> enforce_len(Polynomial<T> poly, int len) {\n  poly.resize(len, 0);\n  return poly;\n}\nint binary_upper_bound(int w) {\n  if (w <= 0) return 1;\n  const int highbit = 31 - __builtin_clz(w);\n  return (1 << highbit) << ((1 << highbit) != w);\n}\ntemplate <typename T>\nint get_ntt_len(const Polynomial<T>& lhs, const Polynomial<T>& rhs) {\n  return binary_upper_bound((int)lhs.size() + (int)rhs.size() - 1);\n}\ntemplate <typename T>\nPolynomial<T> operator*(Polynomial<T> lhs, Polynomial<T> rhs) {\n  (lhs.size() + rhs.size() > 0);\n  const int L = get_ntt_len(lhs, rhs);\n  lhs.resize(L, 0);\n  rhs.resize(L, 0);\n  ntt(lhs, L, 1);\n  ntt(rhs, L, 1);\n  for (int i = 0; i < L; ++i) {\n    lhs[i] *= rhs[i];\n  }\n  ntt(lhs, L, -1);\n  norm(lhs);\n  return lhs;\n}\ntemplate <typename T>\nPolynomial<T> operator*(T a, Polynomial<T> p) {\n  for (int i = 0; i < p.size(); ++i) p[i] *= a;\n  norm(p);\n  return p;\n}\ntemplate <typename T>\nPolynomial<T> mod_inv(Polynomial<T> poly, int len = 0) {\n  (poly.size() >= 1 && poly[0] != 0);\n  if (len == 0) len = poly.size();\n  if (len > poly.size()) poly.resize(len);\n  const int L = binary_upper_bound(len);\n  poly.resize(L, 0);\n  Polynomial<T> w(L << 1), r(L << 1), saved(L << 1);\n  w[0] = poly[0].inv();\n  for (int len = 2; len <= L; len <<= 1) {\n    std::copy(w.begin(), w.begin() + (len >> 1), r.begin());\n    std::copy(poly.begin(), poly.begin() + len, saved.begin());\n    ntt(saved, len, 1);\n    ntt(r, len, 1);\n    for (int i = 0; i < len; ++i) r[i] *= saved[i];\n    ntt(r, len, -1);\n    for (int i = 0; i < (len >> 1); ++i) r[i] = 0;\n    std::copy(w.begin(), w.begin() + len, saved.begin());\n    ntt(saved, len, 1);\n    ntt(r, len, 1);\n    for (int i = 0; i < len; ++i) r[i] *= saved[i];\n    ntt(r, len, -1);\n    for (int i = (len >> 1); i < len; ++i) w[i] = w[i] + w[i] - r[i];\n  }\n  return mod_len(w, len);\n}\ntemplate <typename T>\nPolynomial<T> derivate(Polynomial<T> poly) {\n  if (poly.size() <= 1) {\n    return Polynomial<T>(1, 0);\n  }\n  for (int i = 1; i < poly.size(); ++i) {\n    poly[i - 1] = poly[i] * i;\n  }\n  poly.pop_back();\n  norm(poly);\n  return poly;\n}\ntemplate <typename T>\nPolynomial<T> integrate(Polynomial<T> poly) {\n  if (poly.size() == 0) {\n    return poly;\n  }\n  poly.emplace_back(0);\n  for (int i = (int)poly.size() - 1; i > 0; --i) {\n    poly[i] = poly[i - 1] / i;\n  }\n  poly[0] = 0;\n  norm(poly);\n  return poly;\n}\ntemplate <typename T>\nPolynomial<T> mod_sqrt(Polynomial<T> poly, int len = 0) {\n  (poly.size() >= 1 && poly[0] == 1);\n  if (len > poly.size()) poly.resize(len);\n  if (poly.size() == 1) {\n    return poly;\n  }\n  if (len == 0) len = poly.size();\n  const int L = binary_upper_bound(len);\n  poly.resize(L, 0);\n  Polynomial<T> buffer(1, 1), buffer1;\n  for (int len = 2; len <= L; len <<= 1) {\n    buffer1 = mod_inv(T(2) * buffer, len);\n    ntt(buffer, len, 1);\n    for (int i = 0; i < len; ++i) buffer[i] *= buffer[i];\n    ntt(buffer, len, -1);\n    for (int i = 0; i < len; ++i) buffer[i] += poly[i];\n    buffer = enforce_len(buffer * buffer1, len);\n  }\n  return mod_len(buffer, len);\n}\ntemplate <typename T>\nPolynomial<T> mod_ln(Polynomial<T> poly, int len = 0) {\n  if (len == 0) len = poly.size();\n  if (len > poly.size()) poly.resize(len);\n  return mod_len(integrate(derivate(poly) * mod_inv(poly, len)), len);\n}\ntemplate <typename T>\nPolynomial<T> mod_exp(Polynomial<T> poly, int len = 0) {\n  if (len == 0) len = poly.size();\n  if (len > poly.size()) poly.resize(len);\n  (poly.size() == 0 || poly[0] == 0);\n  const int L = binary_upper_bound(len);\n  poly.resize(L, 0);\n  Polynomial<T> p(1, 1);\n  for (int len = 2; len <= L; len <<= 1) {\n    Polynomial<T> q = p;\n    p = enforce_len(mod_ln(p, len), len);\n    for (int i = 0; i < len; ++i) p[i] = poly[i] - p[i];\n    ++p[0];\n    p = mod_len(p * q, len);\n  }\n  return mod_len(p, len);\n}\ntemplate <typename T>\nPolynomial<T> conditioned_mod_power(Polynomial<T> poly, T k, int len = 0) {\n  (poly.size() >= 1 && poly[0] != T(0));\n  if (len == 0) len = poly.size();\n  T constant = poly[0];\n  if (constant != T(1)) {\n    T inv_constant = T(1) / constant;\n    for (int i = 0; i < poly.size(); ++i) {\n      poly[i] *= inv_constant;\n    }\n  }\n  Polynomial<T> ret = mod_exp(k * mod_ln(poly, len), len);\n  if (constant != T(1)) {\n    constant = constant.power(k.val());\n    for (int i = 0; i < ret.size(); ++i) {\n      ret[i] *= constant;\n    }\n  }\n  return ret;\n}\ntemplate <typename T>\nT lagrange_inversion(Polynomial<T> poly, int n) {\n  if (poly.empty()) return T(0);\n  (poly[0] == T(0));\n  (poly.size() > 1);\n  (poly[1] != T(0));\n  (n > 0);\n  poly.erase(poly.begin());\n  return enforce_len(conditioned_mod_power(poly, n, n), n)[n - 1] / T(n);\n}\nusing Poly = Polynomial<Integral<MOD>>;\nstruct Solver {\n  int n, m, k;\n  std::vector<std::vector<int>> A;\n  Mint solve() {\n    using EdgeSet = std::set<int>;\n    std::vector<EdgeSet> prev(k), next(k);\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j + 1 < A[i].size(); ++j) {\n        int x = A[i][j];\n        int y = A[i][j + 1];\n        prev[y].emplace(x);\n        next[x].emplace(y);\n      }\n    }\n    std::vector<bool> bad(k);\n    std::queue<int> que;\n    for (int i = 0; i < k; ++i) {\n      if (prev[i].size() > 1 || next[i].size() > 1) {\n        bad[i] = true;\n        que.emplace(i);\n      }\n    }\n    while (!que.empty()) {\n      int u = que.front();\n      que.pop();\n      for (int v : prev[u]) {\n        if (!bad[v]) {\n          bad[v] = true;\n          que.emplace(v);\n        }\n      }\n      for (int v : next[u]) {\n        if (!bad[v]) {\n          bad[v] = true;\n          que.emplace(v);\n        }\n      }\n    }\n    Poly poly(m + 1);\n    for (int i = 0; i < k; ++i)\n      if (!bad[i] && prev[i].empty()) {\n        int len = 1;\n        for (int x = i; !next[x].empty(); x = *next[x].begin()) {\n          ++len;\n        }\n        poly[len]++;\n      }\n    return mod_inv(Poly(1, 1) - poly, m + 1)[m];\n  }\n  void solve(int ca, std::istream& reader) {\n    reader >> n >> m >> k;\n    A.resize(n);\n    for (int i = 0; i < n; ++i) {\n      int len;\n      reader >> len;\n      A[i].resize(len);\n      for (int j = 0; j < len; ++j) {\n        reader >> A[i][j];\n        --A[i][j];\n      }\n    }\n    printf(\"%d\\n\", solve().val());\n  }\n};\n}  // namespace\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  std::istream& reader = std::cin;\n  int cas = 1;\n  for (int ca = 1; ca <= cas; ++ca) {\n    Solver().solve(ca, reader);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nconst int N = 3e5 + 9, mod = 998244353;\nint n, m, k;\nset<int> nxt[N], prv[N];\nbool bad[N];\nvoid dfsbads(int node) {\n  if (bad[node]) return;\n  bad[node] = true;\n  for (auto i : nxt[node]) dfsbads(i);\n  for (auto i : prv[node]) dfsbads(i);\n}\nint dfsChain(int node) {\n  if (nxt[node].empty()) return 1;\n  assert(nxt[node].size() == 1);\n  return 1 + dfsChain(*nxt[node].begin());\n}\nint freq[N];\nint dp[N];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m >> k;\n  while (n--) {\n    int c, x;\n    cin >> c >> x;\n    for (int i = 1; i < c; i++) {\n      int y;\n      cin >> y;\n      nxt[x].insert(y);\n      prv[y].insert(x);\n      x = y;\n    }\n  }\n  for (int i = 1; i <= k; i++) {\n    if (nxt[i].size() > 1 || prv[i].size() > 1) dfsbads(i);\n  }\n  for (int i = 1; i <= k; i++) {\n    if (bad[i] || prv[i].size() > 0) continue;\n    freq[dfsChain(i)]++;\n  }\n  vector<pair<long long, long long> > v;\n  for (int i = 1; i <= m; i++) {\n    if (freq[i]) {\n      v.push_back({i, freq[i]});\n    }\n  }\n  dp[0] = 1;\n  for (int i = 1; i <= m; i++) {\n    for (auto j : v) {\n      if (j.first > i) break;\n      dp[i] = (dp[i] + 1LL * j.second * dp[i - j.first]) % mod;\n    }\n  }\n  cout << dp[m];\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 998244353;\nconst int maxi = 3e5 + 100;\nint n, m, k;\nset<int> alfabet;\nvector<vector<int> > a;\nvector<int> g[maxi];\nset<int> liter[maxi];\nset<int> zbior;\nint odw[maxi];\nset<int> zak;\nmap<int, int> dl;\nint odwslo[maxi];\nvector<pair<int, int> > eds;\nset<int> wych[maxi], wcho[maxi];\nmap<pair<int, int>, bool> odweds;\nvoid dfszakslow(int w);\nvoid dfszakliter(int w) {\n  if (zak.find(w) != zak.end()) {\n    return;\n  }\n  zak.insert(w);\n  for (auto xd : liter[w]) {\n    if (!odwslo[xd]) {\n      dfszakslow(xd);\n    }\n  }\n}\nvoid dfszakslow(int w) {\n  if (odwslo[w]) {\n    return;\n  }\n  odwslo[w] = 1;\n  for (auto xd : a[w]) {\n    dfszakliter(xd);\n  }\n}\nbool dfs(int w) {\n  zbior.insert(w);\n  odw[w] = 1;\n  bool ans = true;\n  if (zak.find(w) != zak.end()) {\n    ans = false;\n  }\n  for (auto xd : g[w]) {\n    if (odweds[eds[xd]]) {\n      continue;\n    }\n    odweds[eds[xd]] = true;\n    int x = eds[xd].first;\n    if (x == w) {\n      x = eds[xd].second;\n    }\n    if (odw[x]) {\n      ans = false;\n    }\n    bool dx = dfs(x);\n    ans &= dx;\n  }\n  return ans;\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &k);\n  vector<int> zleslowa;\n  for (int i = 0; i < n; ++i) {\n    int c;\n    scanf(\"%d\", &c);\n    vector<int> v;\n    set<int> sv;\n    multiset<int> mv;\n    for (int j = 0; j < c; ++j) {\n      int x;\n      scanf(\"%d\", &x);\n      alfabet.insert(x);\n      v.push_back(x);\n      liter[x].insert(i);\n      sv.insert(x);\n      mv.insert(x);\n    }\n    a.push_back(v);\n    bool flf = false;\n    for (int j = 1; j < c; ++j) {\n      eds.push_back({v[j - 1], v[j]});\n      g[v[j]].push_back(eds.size() - 1);\n      g[v[j - 1]].push_back(eds.size() - 1);\n      wcho[v[j]].insert(v[j - 1]);\n      wych[v[j - 1]].insert(v[j]);\n      if (wcho[v[j]].size() > 1 || wych[v[j - 1]].size() > 1) {\n        flf = true;\n      }\n    }\n    if (sv.size() != mv.size() || flf) {\n      zleslowa.push_back(i);\n    }\n  }\n  for (auto xd : zleslowa) {\n    dfszakslow(xd);\n  }\n  for (int i = 1; i <= k; ++i) {\n    if (odw[i]) {\n      continue;\n    }\n    zbior.clear();\n    bool fla = dfs(i);\n    if (fla) {\n      ++dl[zbior.size()];\n    }\n  }\n  vector<long long> dp(m + 1, 0);\n  dp[0] = 1;\n  for (int i = 1; i <= m; ++i) {\n    for (auto xd : dl) {\n      if (xd.first > i) {\n        break;\n      }\n      dp[i] += dp[i - xd.first] * xd.second;\n      dp[i] %= mod;\n    }\n  }\n  printf(\"%lld\\n\", dp[m]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<long long> a[300010];\nlong long pre[300010], nxt[300010];\nbool vis[300010];\nvector<long long> pack;\nconst long long mod = 998244353;\ninline long long fastpow(long long a, long long n) {\n  long long ans = 1;\n  while (n) {\n    if (n & 1) ans = ans * a % mod;\n    a = a * a % mod;\n    n >>= 1;\n  }\n  return ans;\n}\ninline long long inv(long long x) { return fastpow(x, mod - 2); }\nconst long long g = 3, ig = inv(g);\nlong long r[2000000];\ninline void getr(long long lim, long long n) {\n  for (long long i = 0; i < lim; i++)\n    r[i] = (r[i >> 1] >> 1) | ((i & 1) << (n - 1));\n}\ninline void NTT(long long *a, long long n, long long op) {\n  for (long long i = 0; i < n; i++)\n    if (i < r[i]) swap(a[i], a[r[i]]);\n  for (long long i = 1; i < n; i <<= 1) {\n    long long wn = fastpow(op == 1 ? g : ig, (mod - 1) / (i << 1));\n    for (long long j = 0; j < n; j += (i << 1)) {\n      long long w = 1;\n      for (long long k = 0; k < i; k++, w = w * wn % mod) {\n        long long x = a[j + k], y = w * a[j + k + i] % mod;\n        a[j + k] = (x + y) % mod;\n        a[j + k + i] = (x - y + mod) % mod;\n      }\n    }\n  }\n  if (op == -1) {\n    long long il = inv(n);\n    for (long long i = 0; i < n; i++) a[i] = a[i] * il % mod;\n  }\n}\nlong long A[2000000], B[2000000];\nvoid work(long long *a, long long *b, long long n, long long cnt) {\n  static long long tmp[2000000];\n  if (n == 1) {\n    b[0] = inv(a[0]);\n    return;\n  }\n  work(a, b, n >> 1, cnt - 1);\n  long long lim = n << 1;\n  for (long long i = 0; i < n; i++) tmp[i] = a[i];\n  for (long long i = n; i < lim; i++) tmp[i] = 0;\n  getr(lim, cnt + 1);\n  NTT(tmp, lim, 1);\n  NTT(b, lim, 1);\n  for (long long i = 0; i < lim; i++)\n    b[i] = b[i] * (2 - tmp[i] * b[i] % mod + mod) % mod;\n  NTT(b, lim, -1);\n  for (long long i = n; i < lim; i++) b[i] = 0;\n}\nsigned main() {\n  long long n, m, k;\n  scanf(\"%lld %lld %lld\", &n, &m, &k);\n  for (long long i = 1; i <= n; i++) {\n    long long t;\n    scanf(\"%lld\", &t);\n    while (t--) {\n      long long x;\n      scanf(\"%lld\", &x);\n      a[i].push_back(x);\n    }\n  }\n  for (long long i = 1; i <= n; i++) {\n    long long len = a[i].size();\n    for (long long j = 0; j < len; j++) {\n      if (j != 0) {\n        if (pre[a[i][j]] != 0 && pre[a[i][j]] != a[i][j - 1])\n          pre[a[i][j]] = -1;\n        else\n          pre[a[i][j]] = a[i][j - 1];\n      }\n      if (j != len - 1) {\n        if (nxt[a[i][j]] != 0 && nxt[a[i][j]] != a[i][j + 1])\n          nxt[a[i][j]] = -1;\n        else\n          nxt[a[i][j]] = a[i][j + 1];\n      }\n    }\n  }\n  for (long long i = 1; i <= k; i++)\n    if (!pre[i] && !vis[i]) {\n      long long tot = 0, u = i;\n      bool flag = true;\n      while (u) {\n        tot++;\n        if (vis[u] || pre[u] == -1 || nxt[u] == -1) {\n          flag = false;\n          break;\n        }\n        vis[u] = true;\n        u = nxt[u];\n      }\n      if (flag) pack.push_back(tot);\n    }\n  A[0] = mod - 1;\n  for (auto x : pack) A[x]++;\n  long long lim = 1, cnt = 0;\n  while (lim <= max(k, m)) lim <<= 1, cnt++;\n  work(A, B, lim, cnt);\n  printf(\"%lld\\n\", (mod - B[m]) % mod);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 3e5 + 10, MOD = 998244353;\nstruct Graph {\n  vector<pair<int, long long> > son[N];\n  int in[N];\n  void add(int x, int y, long long w) {\n    son[x].push_back(make_pair(y, w));\n    in[y]++;\n  }\n  void init(int MAXN) {\n    for (int i = 0; i <= MAXN; i++) son[i].clear(), in[i] = 0;\n  }\n} gr;\nint n, m, k;\nset<int> sson[N];\nvoid solve() {\n  cin >> n >> m >> k;\n  for (int i = 1; i <= n; i++) {\n    int c;\n    cin >> c;\n    int lst;\n    for (int j = 1; j <= c; j++) {\n      int x;\n      cin >> x;\n      if (j > 1 && !sson[lst].count(x)) {\n        gr.add(lst, x, 1);\n        sson[lst].insert(x);\n      }\n      lst = x;\n    }\n  }\n  vector<bool> vis(k + 1);\n  vector<int> cnt(k + 1);\n  function<void(int, int)> dfs = [&](int u, int dep) {\n    if (vis[u]) return;\n    vis[u] = 1;\n    if (gr.in[u] > 1) return;\n    if (gr.son[u].size() > 1) return;\n    if (gr.son[u].size() == 0) {\n      cnt[dep]++;\n      return;\n    }\n    dfs(gr.son[u][0].first, dep + 1);\n    return;\n  };\n  for (int i = 1; i <= k; i++) {\n    if (gr.in[i] == 0) dfs(i, 1);\n  }\n  vector<int> v;\n  for (int i = 1; i <= k; i++)\n    if (cnt[i]) {\n      v.push_back(i);\n    }\n  vector<long long> dp(m + 1);\n  dp[0] = 1;\n  for (int i = 1; i <= m; i++) {\n    for (auto j : v) {\n      if (i >= j) dp[i] = (dp[i] + dp[i - j] * cnt[j]) % MOD;\n    }\n  }\n  cout << dp[m];\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int ttt = 1;\n  for (int i = 1; i <= ttt; i++) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\nstring to_string(const string& s) { return '\"' + s + '\"'; }\nstring to_string(const char* s) { return to_string((string)s); }\nstring to_string(bool b) { return (b ? \"true\" : \"false\"); }\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto& x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" +\n         to_string(get<2>(p)) + \")\";\n}\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" +\n         to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a;\n    swap(a, m);\n    u -= t * v;\n    swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod())\n      v = static_cast<Type>(x);\n    else\n      v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const {\n    return static_cast<U>(value);\n  }\n  constexpr static Type mod() { return T::value; }\n  Modular& operator+=(const Modular& other) {\n    if ((value += other.value) >= mod()) value -= mod();\n    return *this;\n  }\n  Modular& operator-=(const Modular& other) {\n    if ((value -= other.value) < 0) value += mod();\n    return *this;\n  }\n  template <typename U>\n  Modular& operator+=(const U& other) {\n    return *this += Modular(other);\n  }\n  template <typename U>\n  Modular& operator-=(const U& other) {\n    return *this -= Modular(other);\n  }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) {\n    Modular result(*this);\n    *this += 1;\n    return result;\n  }\n  Modular operator--(int) {\n    Modular result(*this);\n    *this -= 1;\n    return result;\n  }\n  Modular operator-() const { return Modular(-value); }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value,\n                     Modular>::type&\n  operator*=(const Modular& rhs) {\n    value = normalize(static_cast<int64_t>(value) *\n                      static_cast<int64_t>(rhs.value));\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value,\n                     Modular>::type&\n  operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) *\n                                         rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value,\n                     Modular>::type&\n  operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n  Modular& operator/=(const Modular& other) {\n    return *this *= Modular(inverse(other.value, mod()));\n  }\n  friend const Type& abs(const Modular& x) { return x.value; }\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\ntemplate <typename T>\nbool operator==(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return lhs.value == rhs.value;\n}\ntemplate <typename T, typename U>\nbool operator==(const Modular<T>& lhs, U rhs) {\n  return lhs == Modular<T>(rhs);\n}\ntemplate <typename T, typename U>\nbool operator==(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) == rhs;\n}\ntemplate <typename T>\nbool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T, typename U>\nbool operator!=(const Modular<T>& lhs, U rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T, typename U>\nbool operator!=(U lhs, const Modular<T>& rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T>\nbool operator<(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return lhs.value < rhs.value;\n}\ntemplate <typename T>\nModular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator+(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator+(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T>\nModular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator-(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator-(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T>\nModular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator*(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator*(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T>\nModular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator/(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator/(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, k;\n  cin >> n >> m >> k;\n  vector<vector<int>> g(k);\n  vector<vector<int>> gr(k);\n  for (int i = 0; i < n; i++) {\n    int len;\n    cin >> len;\n    int last;\n    cin >> last;\n    --last;\n    for (int j = 1; j < len; j++) {\n      int cur;\n      cin >> cur;\n      --cur;\n      g[last].push_back(cur);\n      gr[cur].push_back(last);\n      last = cur;\n    }\n  }\n  for (int i = 0; i < k; i++) {\n    sort(g[i].begin(), g[i].end());\n    g[i].resize(unique(g[i].begin(), g[i].end()) - g[i].begin());\n    sort(gr[i].begin(), gr[i].end());\n    gr[i].resize(unique(gr[i].begin(), gr[i].end()) - gr[i].begin());\n  }\n  map<int, int> mp, testing;\n  vector<bool> was(k, false);\n  vector<bool> used(k, false);\n  for (int start = 0; start < k; start++) {\n    if (was[start]) {\n      continue;\n    }\n    vector<int> que(1, start);\n    was[start] = true;\n    for (int b = 0; b < (int)que.size(); b++) {\n      for (int j : g[que[b]]) {\n        if (!was[j]) {\n          que.push_back(j);\n          was[j] = true;\n        }\n      }\n      for (int j : gr[que[b]]) {\n        if (!was[j]) {\n          que.push_back(j);\n          was[j] = true;\n        }\n      }\n    }\n    int edges = 0;\n    for (int i : que) {\n      edges += (int)g[i].size();\n    }\n    if (edges != (int)que.size() - 1) {\n      continue;\n    }\n    int root = -1;\n    for (int i : que) {\n      if (gr[i].empty()) {\n        root = i;\n        break;\n      }\n    }\n    assert(root != -1);\n    vector<int> seq(1, root);\n    used[root] = true;\n    while (true) {\n      int nxt = -1;\n      for (int i : g[seq.back()]) {\n        if (!used[i]) {\n          nxt = i;\n          break;\n        }\n      }\n      if (nxt == -1) {\n        break;\n      }\n      seq.push_back(nxt);\n      used[nxt] = true;\n    }\n    if (seq.size() == que.size()) {\n      mp[(int)seq.size()] += 1;\n    }\n  }\n  vector<pair<int, int>> ps;\n  for (auto& p : mp) {\n    ps.push_back(p);\n  }\n  vector<Mint> dp(m + 1);\n  dp[0] = 1;\n  for (int i = 1; i <= m; i++) {\n    for (auto& p : ps) {\n      if (i >= p.first) {\n        dp[i] += dp[i - p.first] * p.second;\n      }\n    }\n  }\n  cout << dp[m] << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst long long mod = 998244353;\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cout.tie(0);\n  int n, m, k;\n  std::cin >> n >> m >> k;\n  std::vector<std::vector<int> > a(n, std::vector<int>(0));\n  std::set<int> ban;\n  std::vector<std::vector<int> > vec;\n  for (int i = 0; i < n; i++) {\n    int c, x;\n    std::cin >> c;\n    while (c--) {\n      std::cin >> x;\n      x--;\n      a[i].emplace_back(x);\n    }\n    std::map<int, int> mp;\n    for (auto x : a[i]) mp[x]++;\n    bool flag = true;\n    for (auto p : mp)\n      if (p.second >= 2) {\n        ban.insert(p.first);\n        flag = false;\n      }\n    if (not flag) {\n      for (auto x : a[i]) ban.insert(x);\n    }\n  }\n  std::vector<std::set<int> > g(k), rg(k);\n  for (auto v : a) {\n    for (int i = 0; i + 1 < v.size(); i++) {\n      g[v[i]].insert(v[i + 1]);\n      rg[v[i + 1]].insert(v[i]);\n    }\n  }\n  std::vector<int> in(k, 0), out(k, 0);\n  for (int i = 0; i < k; i++) {\n    out[i] = g[i].size();\n    in[i] = rg[i].size();\n  }\n  for (int i = 0; i < k; i++) {\n    if (in[i] >= 2 || out[i] >= 2) ban.insert(i);\n  }\n  std::function<int(int)> dfs = [&](int x) {\n    if (ban.count(x)) return -(int)1e9;\n    if (out[x] == 0) return 1;\n    if (out[x] == 1 && in[*g[x].begin()] == 1) {\n      return 1 + dfs(*g[x].begin());\n    }\n    return -(int)1e9;\n  };\n  std::vector<int> F(k + 1, 0);\n  for (int i = 0; i < k; i++)\n    if (!ban.count(i)) {\n      if (in[i] == 0) {\n        int len = dfs(i);\n        if (len > 0) F[len]++;\n      }\n    }\n  std::vector<std::pair<int, int> > key;\n  for (int i = 0; i <= k; i++)\n    if (F[i] > 0) {\n      key.emplace_back(i, F[i]);\n    }\n  std::vector<int> dp(m + 1, 0);\n  dp[0] = 1;\n  for (int i = 1; i <= m; i++) {\n    for (auto [len, w] : key) {\n      assert(len >= 1 && len <= k);\n      if (len <= i) {\n        dp[i] = (dp[i] + 1ll * w * dp[i - len] % mod) % mod;\n      }\n    }\n  }\n  std::cout << dp[m] << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\nstring to_string(const string& s) { return '\"' + s + '\"'; }\nstring to_string(const char& s) {\n  string res = \"'\";\n  res += s;\n  res += \"'\";\n  return res;\n}\nstring to_string(bool b) { return (b ? \"true\" : \"false\"); }\nstring to_string(vector<bool> v) {\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (i) res += \", \";\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto& x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" +\n         to_string(get<2>(p)) + \")\";\n}\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" +\n         to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\nconst long long mod = 998244353;\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long n, m, k;\n  cin >> n >> m >> k;\n  vector<vector<long long>> g(k);\n  vector<vector<long long>> a(n);\n  vector<vector<long long>> G(n);\n  for (long long i = 0; i < n; i++) {\n    long long m;\n    cin >> m;\n    for (long long j = 0; j < m; j++) {\n      long long x;\n      cin >> x;\n      x--;\n      a[i].push_back(x);\n      g[x].push_back(i);\n    }\n  }\n  long long usd = 0;\n  for (long long i = 0; i < k; i++) {\n    if ((long long)(g[i]).size() == 0)\n      usd++;\n    else {\n      for (auto x : g[i]) {\n        if (x != g[i][0]) {\n          G[x].push_back(g[i][0]);\n          G[g[i][0]].push_back(x);\n        }\n      }\n    }\n  }\n  vector<long long> p(n, -1), ts;\n  function<void(long long)> dfs = [&](long long v) {\n    ts.push_back(v);\n    for (auto x : G[v]) {\n      if (p[x] == -1) {\n        p[x] = v;\n        dfs(x);\n      }\n    }\n  };\n  map<long long, long long> AB;\n  vector<long long> pos(k, -1e18);\n  map<long long, long long> d;\n  for (long long i = 0; i < n; i++) {\n    if (p[i] != -1) continue;\n    AB.clear();\n    ts.clear();\n    p[i] = n;\n    dfs(i);\n    vector<long long> C;\n    for (auto v : ts) {\n      for (auto x : a[v]) C.push_back(x);\n    }\n    sort((C).begin(), (C).end());\n    C.resize(unique((C).begin(), (C).end()) - C.begin());\n    long long ok = 1;\n    for (auto v : ts) {\n      vector<long long> A = a[v];\n      sort((A).begin(), (A).end());\n      for (long long j = 0; j < (long long)(A).size() - 1; j++) {\n        if (A[j] == A[j + 1]) ok = 0;\n      }\n    }\n    if (!ok) continue;\n    for (auto x : a[ts[0]]) {\n      AB[(long long)(AB).size()] = x;\n      pos[x] = (long long)(AB).size() - 1;\n    }\n    for (auto v : ts) {\n      if (v == ts[0]) continue;\n      long long first = -1e18;\n      for (long long j = 0; j < (long long)(a[v]).size(); j++) {\n        if (pos[a[v][j]] != -1e18) {\n          first = pos[a[v][j]] - j;\n          break;\n        }\n      }\n      assert(first != -1e18);\n      for (long long j = 0; j < (long long)(a[v]).size(); j++) {\n        if (AB.find(first + j) == AB.end()) AB[first + j] = 0;\n        if (pos[AB[first + j]] == first + j) {\n          if (AB[first + j] != a[v][j]) ok = 0;\n        } else {\n          if (pos[a[v][j]] == (long long)-1e18) {\n            AB[first + j] = a[v][j];\n            pos[a[v][j]] = first + j;\n          } else {\n            ok = 0;\n          }\n        }\n      }\n      if (!ok) break;\n    }\n    if (!ok) {\n      for (auto x : C) pos[x] = -1e18;\n      continue;\n    }\n    long long mn = 1e18, mx = -1e18;\n    for (auto x : C) {\n      mn = min(mn, pos[x]);\n      mx = max(mx, pos[x]);\n    }\n    d[mx - mn + 1]++;\n    for (auto x : C) pos[x] = -1e18;\n  }\n  vector<long long> dp(m + 1);\n  dp[0] = 1;\n  for (long long i = 0; i < m; i++) {\n    dp[i + 1] = (dp[i] * usd) % mod;\n    for (auto [x, y] : d) {\n      if (x <= i + 1) {\n        dp[i + 1] = (dp[i + 1] + dp[i + 1 - x] * y) % mod;\n      }\n    }\n  }\n  cout << dp[m];\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 3e5 + 10;\nconst int LOG2 = 18;\nconst int MOD = 998244353;\nconst long long oo = 1e18;\nset<int> g[N];\nvector<int> g2[N];\nint in[N], seen[N], sz, bad[N], val[N];\nvoid mark_bad(int u) {\n  bad[u] = 1;\n  for (int v : g2[u])\n    if (!bad[v]) mark_bad(v);\n}\nint go(int u) {\n  int ok = 1;\n  sz++;\n  seen[u] = 1;\n  ok &= g[u].size() <= 1;\n  for (int v : g[u]) {\n    if (!seen[v])\n      ok &= go(v);\n    else\n      ok = 0;\n  }\n  return ok;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n, m, k;\n  cin >> n >> m >> k;\n  for (int it = 0; it < n; it++) {\n    int len;\n    cin >> len;\n    int last = -1;\n    while (len--) {\n      int x;\n      cin >> x;\n      if (last != -1) {\n        in[x]++;\n        g[last].insert(x);\n        g2[last].push_back(x);\n        g2[x].push_back(last);\n      }\n      last = x;\n    }\n  }\n  map<int, int> by_sz;\n  for (int i = 1; i <= k; i++) {\n    if (in[i] == 0 && !bad[i]) {\n      sz = 0;\n      if (!go(i)) mark_bad(i);\n      val[i] = sz;\n    }\n  }\n  for (int i = 1; i <= k; i++) {\n    if (!seen[i]) {\n      if (!go(i)) mark_bad(i);\n    }\n  }\n  for (int i = 1; i <= k; i++) {\n    if (in[i] == 0 && !bad[i]) {\n      by_sz[val[i]]++;\n    }\n  }\n  vector<int> dp(2 * N + 2);\n  dp[m] = 1;\n  for (int i = m - 1; i >= 0; i--) {\n    for (auto e : by_sz) {\n      dp[i] += 1ll * dp[i + e.first] * e.second % MOD;\n      if (dp[i] >= MOD) dp[i] -= MOD;\n    }\n  }\n  cout << dp[0] << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\ninline void read(T &f) {\n  f = 0;\n  T fu = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') fu = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    f = (f << 3) + (f << 1) + (c & 15);\n    c = getchar();\n  }\n  f *= fu;\n}\ntemplate <typename T>\nvoid print(T x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x < 10)\n    putchar(x + 48);\n  else\n    print(x / 10), putchar(x % 10 + 48);\n}\ntemplate <typename T>\nvoid print(T x, char t) {\n  print(x);\n  putchar(t);\n}\nconst int md = 998244353;\ninline int add(int x, int y) {\n  if (x + y >= md) return x + y - md;\n  return x + y;\n}\ninline void addx(int &x, int y) {\n  x += y;\n  if (x >= md) x -= md;\n}\ninline int sub(int x, int y) {\n  if (x < y) return x - y + md;\n  return x - y;\n}\ninline void subx(int &x, int y) {\n  x -= y;\n  if (x < 0) x += md;\n}\ninline int mul(int x, int y) { return 1ull * x * y % md; }\ninline int fpow(int x, int y) {\n  int ans = 1;\n  while (y) {\n    if (y & 1) ans = mul(ans, x);\n    y >>= 1;\n    x = mul(x, x);\n  }\n  return ans;\n}\nconst int N = 3e5 + 5;\npair<int, int> g[N];\nint nxt[N], pre[N], a[N], ban[N], vis[N], t[N], dp[N];\nint n, m, k, len, flag;\nvoid link(int u, int v) {\n  if (nxt[u] && nxt[u] != v) {\n    flag = 1;\n    return;\n  }\n  if (pre[v] && pre[v] != u) {\n    flag = 1;\n    return;\n  }\n  nxt[u] = v;\n  pre[v] = u;\n}\nint main() {\n  read(n);\n  read(m);\n  read(k);\n  for (int i = 1; i <= n; i++) {\n    int len;\n    read(len);\n    flag = 0;\n    for (int j = 1; j <= len; j++) {\n      read(a[j]);\n      if (j > 1) link(a[j - 1], a[j]);\n    }\n    if (flag) {\n      for (int j = 1; j <= len; j++) {\n        ban[a[j]] = 1;\n      }\n    }\n  }\n  for (int i = 1; i <= k; i++) {\n    if (ban[i]) continue;\n    if (!pre[i]) {\n      int tmp = i, cando = 1;\n      while (tmp) {\n        if (ban[tmp]) cando = 0;\n        tmp = nxt[tmp];\n      }\n      if (cando) {\n        int qwq = 0;\n        tmp = i;\n        while (tmp) {\n          ++qwq;\n          vis[tmp] = 1;\n          tmp = nxt[tmp];\n        }\n        ++t[qwq];\n      }\n    }\n  }\n  for (int i = 1; i <= k; i++) {\n    if (t[i]) g[++len] = make_pair(i, t[i]);\n  }\n  dp[0] = 1;\n  for (int i = 1; i <= m; i++) {\n    for (int j = 1; j <= len; j++) {\n      if (g[j].first > i) break;\n      dp[i] = add(dp[i], mul(dp[i - g[j].first], g[j].second));\n    }\n  }\n  print(dp[m], '\\n');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <class p, class q>\nvoid umin(p& a, const q& b) {\n  if (a > b) a = b;\n}\ntemplate <class p, class q>\nvoid umax(p& a, const q& b) {\n  if (a < b) a = b;\n}\nusing ll = long long;\nusing VI = std::vector<int>;\nusing namespace std;\nusing namespace std::chrono;\nint n, m, k;\nint const N = 3e5 + 3;\nll const P = 998244353;\nll const gen = 906409729;\nll const invgen = 483587622;\nll root[21];\nll invroot[21];\nll inv[3] = {0, 1, (P + 1) / 2};\nvoid calc() {\n  root[20] = gen;\n  invroot[20] = invgen;\n  for (int i = (19); i >= (0); i--) root[i] = (root[i + 1] * root[i + 1]) % P;\n  for (int i = (19); i >= (0); i--)\n    invroot[i] = (invroot[i + 1] * invroot[i + 1]) % P;\n}\nvoid fft(vector<ll>& b, bool invert) {\n  int m = b.size();\n  if (m == 1) return;\n  vector<ll> b0, b1;\n  for (int i = 0; 2 * i < m; i++) {\n    b0.push_back(b[2 * i]);\n    b1.push_back(b[2 * i + 1]);\n  }\n  fft(b0, invert);\n  fft(b1, invert);\n  ll w = 1;\n  ll wn = (invert) ? invroot[(int)(log2)(m)] : root[(int)(log2)(m)];\n  for (int i = 0; 2 * i < m; i++) {\n    b[i] = (b0[i] + w * b1[i]) % P;\n    b[i + m / 2] = ((b0[i] - w * b1[i]) % P + P) % P;\n    w = (w * wn) % P;\n    if (invert) {\n      b[i] = (b[i] * inv[2]) % P;\n      b[i + m / 2] = (b[i + m / 2] * inv[2]) % P;\n    }\n  }\n}\nvoid inverse(vector<ll>& ret, vector<ll> first, int r) {\n  assert(r > 0);\n  assert(first[0] == 1);\n  if (r == 1) {\n    ret = vector<ll>{1};\n  } else {\n    first.resize(r);\n    vector<ll> halfinverse;\n    inverse(halfinverse, first, r / 2);\n    int s = 2 * r;\n    first.resize(s);\n    halfinverse.resize(s);\n    fft(first, 0);\n    fft(halfinverse, 0);\n    ret = vector<ll>(s);\n    for (int i = (0); i <= (s - 1); i++)\n      ret[i] = (2 + P - (first[i] * halfinverse[i]) % P) % P;\n    for (int i = (0); i <= (s - 1); i++) ret[i] = (halfinverse[i] * ret[i]) % P;\n    fft(ret, 1);\n    ret.resize(r);\n  }\n}\nvector<VI> arrays;\nVI D[N];\nVI Din[N];\nvector<ll> W;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> m >> k;\n  arrays = vector<VI>(n);\n  for (int i = (1); i <= (n); i++) {\n    int t;\n    cin >> t;\n    for (int j = (1); j <= (t); j++) {\n      int s;\n      cin >> s;\n      arrays[i - 1].push_back(s);\n    }\n    for (int j = (0); j <= (t - 2); j++) {\n      D[arrays[i - 1][j]].push_back(arrays[i - 1][j + 1]);\n      Din[arrays[i - 1][j + 1]].push_back(arrays[i - 1][j]);\n    }\n  }\n  for (int i = (1); i <= (k); i++) {\n    sort(D[i].begin(), D[i].end());\n    sort(Din[i].begin(), Din[i].end());\n    D[i].erase(unique(D[i].begin(), D[i].end()), D[i].end());\n    Din[i].erase(unique(Din[i].begin(), Din[i].end()), Din[i].end());\n  }\n  W = vector<ll>(m + 1);\n  bool out = 1;\n  for (int i = (1); i <= (k); i++) {\n    if (Din[i].empty()) {\n      int ww = 1;\n      int ci = i;\n      while (1) {\n        if (((int)((D[ci]).size())) > 1 || ((int)((Din[ci]).size())) > 1)\n          break;\n        else if (((int)((D[ci]).size())) == 1) {\n          ww++;\n          ci = D[ci][0];\n        } else {\n          out = 0;\n          if (ww <= m) W[ww]--;\n          break;\n        }\n      }\n    }\n  }\n  if (out) {\n    cout << \"0\\n\";\n    return 0;\n  }\n  W[0] = 1;\n  calc();\n  vector<ll> ans;\n  int pot2 = 1;\n  while (pot2 <= m) pot2 *= 2;\n  inverse(ans, W, pot2);\n  if (((int)((ans).size())) > m)\n    cout << ans[m] << \"\\n\";\n  else\n    cout << \"0\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target( \\\n    \"fma,sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nconst double eps = 1e-6;\nstruct inout {\n  static const long long ibufl = 1 << 25;\n  char in_buf[ibufl + 5], out_buf[ibufl + 5], *inf, *ouf;\n  void init() {\n    fread(in_buf, 1, ibufl, stdin);\n    inf = in_buf;\n    ouf = out_buf;\n  }\n  inout& operator>>(long long& a) {\n    long long fh = 1;\n    while (!(isdigit(*inf) || *inf == '-')) ++inf;\n    if (*inf == '-') fh = -1, ++inf;\n    a = 0;\n    while (isdigit(*inf)) {\n      a = a * 10 + *inf - '0';\n      ++inf;\n    }\n    a *= fh;\n    return *this;\n  }\n  inout& operator>>(char& a) {\n    while (*inf == ' ' || *inf == '\\n') ++inf;\n    a = *inf;\n    ++inf;\n    return *this;\n  }\n  inout& operator>>(char* a) {\n    while (*inf == ' ' || *inf == '\\n') ++inf;\n    while (!(*inf == ' ' || *inf == '\\n')) {\n      *a = *inf;\n      ++inf;\n      ++a;\n    }\n    *a = '\\0';\n    return *this;\n  }\n  inout& operator>>(double& a) {\n    long long fh = 1;\n    double s;\n    while (!(isdigit(*inf) || *inf == '-')) ++inf;\n    if (*inf == '-') fh = -1, ++inf;\n    a = 0;\n    while (isdigit(*inf)) {\n      a = a * 10 + *inf - '0';\n      ++inf;\n    }\n    if (*inf == '.') {\n      s = 0.1;\n      ++inf;\n      while (isdigit(*inf)) {\n        a += s * (*inf - '0');\n        ++inf;\n        s *= 0.1;\n      }\n    }\n    a *= fh;\n    return *this;\n  }\n  void writeint(long long x) {\n    if (x / 10) writeint(x / 10);\n    *ouf = x % 10 + '0';\n    ++ouf;\n  }\n  inout& operator<<(long long a) {\n    if (a < 0) {\n      *ouf = '-';\n      ++ouf;\n      a = -a;\n    }\n    writeint(a);\n    return *this;\n  }\n  static const long long sz = 2;\n  inout& operator<<(char a) {\n    *ouf = a;\n    ++ouf;\n    return *this;\n  }\n  inout& operator<<(char* a) {\n    while (*a) {\n      *ouf = *a;\n      ++ouf;\n      ++a;\n    }\n    return *this;\n  }\n  inout& operator<<(double a) {\n    if (a < -eps) {\n      *ouf = '-';\n      ++ouf;\n      a = -a;\n    }\n    writeint((long long)a);\n    a -= (long long)a;\n    *ouf = '.';\n    ++ouf;\n    for (long long i = 1; i <= sz; i++) {\n      a = a * 10;\n      *ouf = (long long)a + '0';\n      ++ouf;\n      a -= (long long)a;\n    }\n    return *this;\n  }\n  void out() { fwrite(out_buf, 1, ouf - out_buf, stdout); }\n};\ninout io;\nlong long L[300005], R[300005];\nlong long cnt[300005], fa[300005], siz[300005];\nbool down[300005], vis[300005];\nlong long n, m, k;\nlong long dp[300005];\nlong long get(long long x) { return (fa[x] == x) ? x : (fa[x] = get(fa[x])); }\nbool merge(long long x, long long y) {\n  x = get(x);\n  y = get(y);\n  if (x == y) return 0;\n  fa[x] = y;\n  siz[y] += siz[x];\n  down[y] |= down[x];\n  return 1;\n}\nsigned main() {\n  io.init();\n  io >> n >> m >> k;\n  for (long long i = 1; i <= k; i++) fa[i] = i, siz[i] = 1;\n  for (long long i = 1; i <= n; i++) {\n    long long len, x;\n    io >> len >> x;\n    for (long long j = 1; j < len; j++) {\n      long long y;\n      io >> y;\n      if (!R[x]) {\n        if (!merge(x, y)) {\n          down[x] = down[y] = 1;\n        }\n      }\n      merge(x, y);\n      if (R[x] && R[x] != y) {\n        down[x] = 1;\n      }\n      if (L[y] && L[y] != x) {\n        down[y] = 1;\n      }\n      R[x] = y;\n      L[y] = x;\n      x = y;\n    }\n  }\n  for (long long i = 1; i <= k; i++) down[get(i)] |= down[i];\n  for (long long i = 1; i <= k; i++)\n    if (!vis[fa[i]] && !down[fa[i]]) {\n      cnt[siz[fa[i]]]++;\n      vis[fa[i]] = 1;\n    }\n  vector<long long> v;\n  for (long long i = 1; i <= m; i++)\n    if (cnt[i]) {\n      v.emplace_back(i);\n    }\n  dp[0] = 1;\n  long long mod = 998244353;\n  for (long long i = 1; i <= m; i++) {\n    for (auto u : v)\n      if (u <= i) {\n        dp[i] = (1ll * dp[i - u] * cnt[u] + dp[i]) % mod;\n      }\n  }\n  cout << dp[m];\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid rd(T& x) {\n  int f = 0, c;\n  while (!isdigit(c = getchar())) f ^= !(c ^ 45);\n  x = (c & 15);\n  while (isdigit(c = getchar())) x = x * 10 + (c & 15);\n  if (f) x = -x;\n}\ntemplate <typename T>\nvoid pt(T x, int c = -1) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x > 9) pt(x / 10);\n  putchar(x % 10 + 48);\n  if (c != -1) putchar(c);\n}\nconst int P = 998244353;\nint ad(int k1, int k2) { return k1 += k2 - P, k1 += k1 >> 31 & P; }\nint su(int k1, int k2) { return k1 -= k2, k1 += k1 >> 31 & P; }\nint mu(int k1, int k2) { return 1LL * k1 * k2 % P; }\nvoid uad(int& k1, int k2) { k1 += k2 - P, k1 += k1 >> 31 & P; }\nvoid usu(int& k1, int k2) { k1 -= k2, k1 += k1 >> 31 & P; }\ntemplate <typename... T>\nint ad(int k1, T... k2) {\n  return ad(k1, ad(k2...));\n}\ntemplate <typename... T>\nint su(int k1, T... k2) {\n  return su(k1, ad(k2...));\n}\ntemplate <typename... T>\nint mu(int k1, T... k2) {\n  return mu(k1, mu(k2...));\n}\ntemplate <typename... T>\nvoid uad(int& k1, T... k2) {\n  return uad(k1, ad(k2...));\n}\ntemplate <typename... T>\nvoid usu(int& k1, T... k2) {\n  return usu(k1, ad(k2...));\n}\nint po(int k1, int k2) {\n  int k3 = 1;\n  for (; k2; k2 >>= 1, k1 = mu(k1, k1))\n    if (k2 & 1) k3 = mu(k3, k1);\n  return k3;\n}\nvoid NTT(vector<int>& a, int g, int lim) {\n  a.resize(lim);\n  for (int i = 0, j = 0; i < lim; ++i) {\n    if (i < j) swap(a[i], a[j]);\n    for (int k = lim >> 1; (j ^= k) < k; k >>= 1)\n      ;\n  }\n  vector<int> w(lim >> 1);\n  w[0] = 1;\n  for (int i = 1; i < lim; i <<= 1) {\n    int wn = po(g, (P - 1) / (i << 1));\n    for (int j = (i >> 1) - 1; j > 0; --j) w[j << 1] = w[j];\n    for (int j = 1; j < i; j += 2) w[j] = mu(w[j - 1], wn);\n    for (int j = 0; j < lim; j += i << 1)\n      for (int k = 0; k < i; ++k) {\n        int x = a[j + k], y = mu(a[i + j + k], w[k]);\n        a[j + k] = ad(x, y), a[i + j + k] = su(x, y);\n      }\n  }\n  if (g == 332748118)\n    for (int i = 0, I = po(lim, P - 2); i < (int)a.size(); ++i)\n      a[i] = mu(a[i], I);\n}\nvector<int> operator*(vector<int> a, vector<int> b) {\n  if (((int)(a).size()) <= 50 && ((int)(b).size()) <= 50) {\n    vector<int> c(((int)(a).size()) + ((int)(b).size()) - 1);\n    for (int i = (0); i <= (((int)(a).size()) - 1); ++i)\n      for (int j = (0); j <= (((int)(b).size()) - 1); ++j)\n        uad(c[i + j], mu(a[i], b[j]));\n    return c;\n  }\n  int need = (int)a.size() + b.size() - 1, lim = 1;\n  while (lim <= need) lim <<= 1;\n  NTT(a, 3, lim), NTT(b, 3, lim);\n  for (int i = 0; i < lim; ++i) a[i] = mu(a[i], b[i]);\n  NTT(a, 332748118, lim);\n  return a.resize(need), a;\n}\nvector<int> operator+(vector<int> a, vector<int> b) {\n  if (a.size() < b.size()) {\n    for (int i = 0; i < (int)a.size(); ++i) (b[i] += a[i]) %= P;\n    return b;\n  } else {\n    for (int i = 0; i < (int)b.size(); ++i) (a[i] += b[i]) %= P;\n    return a;\n  }\n}\nvector<int> pinv(const vector<int>& a, int n = -1) {\n  if (n == -1) n = a.size();\n  if (n == 1) return vector<int>(1, po(a[0], P - 2));\n  vector<int> b = pinv(a, (n + 1) >> 1),\n              tmp = vector<int>(a.begin(), a.begin() + n);\n  int lim = 1;\n  while (lim <= n * 2 - 2) lim <<= 1;\n  NTT(b, 3, lim), NTT(tmp, 3, lim);\n  for (int i = 0; i < lim; ++i) b[i] = mu(su(2, mu(b[i], tmp[i])), b[i]);\n  NTT(b, 332748118, lim);\n  return b.resize(n), b;\n}\nvector<int> pdao(const vector<int>& a) {\n  vector<int> b((int)a.size() - 1);\n  for (int i = 1; i < (int)a.size(); ++i) b[i - 1] = mu(a[i], i);\n  return b;\n}\nvector<int> pji(const vector<int>& a) {\n  vector<int> b((int)a.size() + 1);\n  for (int i = 0; i < (int)a.size(); ++i) b[i + 1] = mu(a[i], po(i + 1, P - 2));\n  return b;\n}\nvector<int> pln(const vector<int>& a) {\n  vector<int> b(pdao(a) * pinv(a));\n  b.resize((int)a.size() - 1);\n  return pji(b);\n}\nvector<int> pexp(const vector<int>& a, int n = -1) {\n  if (n == -1) n = a.size();\n  if (n == 1) return vector<int>(1, 1);\n  vector<int> b = pexp(a, (n + 1) >> 1), c(b);\n  c.resize(n), c = pln(c), --c[0];\n  for (int i = 0; i < n; ++i) c[i] = su(a[i], c[i]);\n  vector<int> d(b * c);\n  return d.resize(n), d;\n}\nconst int N = 300005;\nint n, m, K, pre[N], nex[N], num[N], tot[N];\nstruct ufs {\n  int fa[N], bad[N];\n  ufs() {\n    for (int i = (1); i <= (N - 1); ++i) fa[i] = i, bad[i] = 0;\n  }\n  int fd(int k1) { return fa[k1] == k1 ? k1 : fa[k1] = fd(fa[k1]); }\n  void mer(int k1, int k2) {\n    k1 = fd(k1), k2 = fd(k2);\n    if (k1 == k2) return;\n    bad[k1] = bad[k1] | bad[k2];\n    fa[k2] = k1;\n  }\n} o;\nint main() {\n  rd(n), rd(m), rd(K);\n  for (int i = (1); i <= (n); ++i) {\n    int sz;\n    rd(sz);\n    for (int j = (1); j <= (sz); ++j) {\n      rd(num[j]);\n    }\n    for (int j = (1); j <= (sz - 1); ++j) {\n      if (nex[num[j]] != 0 && nex[num[j]] != num[j + 1]) {\n        o.bad[o.fd(num[j])] = 1;\n      }\n      nex[num[j]] = num[j + 1];\n      if (pre[num[j + 1]] != 0 && pre[num[j + 1]] != num[j]) {\n        o.bad[o.fd(num[j])] = 1;\n      }\n      pre[num[j + 1]] = num[j];\n      o.mer(num[j], num[j + 1]);\n    }\n  }\n  for (int i = (1); i <= (K); ++i) {\n    ++tot[o.fd(i)];\n  }\n  vector<int> v;\n  static int vis[N];\n  int tim = 0;\n  auto chk = [&](int k1) {\n    ++tim;\n    while (k1) {\n      if (vis[k1] == tim) return 0;\n      vis[k1] = tim;\n      k1 = nex[k1];\n    }\n    return 1;\n  };\n  for (int i = (1); i <= (K); ++i)\n    if (o.fd(i) == i) {\n      if (!o.bad[i] && chk(i)) {\n        v.push_back(tot[i]);\n      }\n    }\n  vector<int> res(m + 1);\n  uad(res[0], 1);\n  for (auto x : v) {\n    if (x <= m) usu(res[x], 1);\n  }\n  res = pinv(res);\n  printf(\"%d\\n\", res[m]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long get() {\n  long long x = 0, f = 1;\n  char c = getchar();\n  while (!isdigit(c)) {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (isdigit(c)) {\n    x = x * 10 + c - '0';\n    c = getchar();\n  }\n  return x * f;\n}\nconst long long N = 3e5 + 5, P = 998244353;\nlong long n, m, k, pre[N], suf[N], f[N], a[N], ban[N], cnt[N], w[N], v[N], tot;\nsigned main() {\n  n = get(), m = get(), k = get();\n  for (long long t = 1; t <= n; t++) {\n    long long len = get();\n    for (long long i = 1; i <= len; i++) a[i] = get();\n    long long flag = 1;\n    for (long long i = 2; i <= len; i++) {\n      if (pre[a[i]] && pre[a[i]] != a[i - 1]) {\n        flag = 0;\n        continue;\n      }\n      if (suf[a[i - 1]] && suf[a[i - 1]] != a[i]) {\n        flag = 0;\n        continue;\n      }\n      pre[a[i]] = a[i - 1], suf[a[i - 1]] = a[i];\n    }\n    if (!flag)\n      for (long long i = 1; i <= len; i++) ban[a[i]] = 1;\n  }\n  for (long long i = 1; i <= k; i++) {\n    if (pre[i]) continue;\n    long long flag = 0;\n    for (long long now = i; now; now = suf[now]) flag |= ban[now];\n    if (!flag) {\n      long long len = 0;\n      for (long long now = i; now; now = suf[now]) ++len;\n      cnt[len]++;\n    }\n  }\n  for (long long i = 1; i <= k; i++)\n    if (cnt[i]) ++tot, w[tot] = i, v[tot] = cnt[i];\n  f[0] = 1;\n  for (long long i = 0; i <= m; i++)\n    for (long long j = 1; j <= tot; j++)\n      if (w[j] <= i) f[i] = (f[i] + v[j] * f[i - w[j]] % P) % P;\n  printf(\"%lld\\n\", f[m]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long su(long long a, long long b) {\n  a += b;\n  return (a >= 998244353) ? a - 998244353 : a;\n}\nint i, j, k, n, m, t, a[300500], in[300500];\nlong long f[300500], num[300500];\nmap<pair<int, int>, int> mp;\nvector<int> v[300050], v1;\nvoid dfs(int x, int dep) {\n  if (v[x].size() > 1 || in[x] > 1) return;\n  if (!v[x].size()) {\n    if (!num[dep]) v1.push_back(dep);\n    num[dep]++;\n    return;\n  }\n  for (auto i : v[x]) dfs(i, dep + 1);\n}\nint main() {\n  f[0] = 1;\n  scanf(\"%d%d%d\", &t, &m, &k);\n  while (t--) {\n    scanf(\"%d\", &n);\n    for (i = 1; i <= n; i++) {\n      scanf(\"%d\", &a[i]);\n      if (i > 1) {\n        if (!mp[{a[i - 1], a[i]}]) {\n          v[a[i - 1]].push_back(a[i]), in[a[i]]++;\n          mp[{a[i - 1], a[i]}] = 1;\n        }\n      }\n    }\n  }\n  for (i = 1; i <= k; i++) {\n    if (!in[i]) dfs(i, 1);\n  }\n  for (i = 1; i <= m; i++) {\n    for (auto j : v1) {\n      if (j <= i) f[i] = su(f[i], f[i - j] * num[j] % 998244353);\n    }\n  }\n  printf(\"%lld\", f[m]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 998244353;\nconst int MAXN = 6E5;\nconst int BLOCK = 550;\nint par[MAXN];\nint sz[MAXN];\nvector<int> a[MAXN];\nvector<int> who_[MAXN];\nbool isBad[MAXN];\nvector<int> objects;\nint dp[MAXN + 1];\nint freq[BLOCK];\nvector<int> adjList[MAXN];\nint inDeg[MAXN];\nint outDeg[MAXN];\nint getRoot(int x) {\n  if (par[x] != x) par[x] = getRoot(par[x]);\n  return par[x];\n}\nbool mge(int x, int y) {\n  x = getRoot(x);\n  y = getRoot(y);\n  if (x == y) return false;\n  if (sz[x] < sz[y]) swap(x, y);\n  par[y] = x;\n  sz[x] += sz[y];\n  for (int z : who_[y]) who_[x].push_back(z);\n  return true;\n}\nvoid add(int &x, int y) {\n  x += y;\n  if (x >= MOD) x -= MOD;\n}\nint solve(int n) {\n  vector<int> big;\n  for (int num : objects) {\n    if (num >= BLOCK)\n      big.push_back(num);\n    else\n      freq[num]++;\n  }\n  dp[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    for (int b : big)\n      if (i - b >= 0) add(dp[i], dp[i - b]);\n    for (int j = 1; j < BLOCK; j++)\n      if (i - j >= 0) add(dp[i], (int)((long long)freq[j] * dp[i - j] % MOD));\n  }\n  return dp[n];\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  for (int i = 0; i < MAXN; i++) {\n    par[i] = i;\n    sz[i] = 1;\n  }\n  int n, m, k;\n  cin >> n >> m >> k;\n  for (int i = 0; i < n; i++) {\n    int c;\n    cin >> c;\n    a[i] = vector<int>(c);\n    set<int> seen;\n    for (int j = 0; j < c; j++) {\n      cin >> a[i][j];\n      a[i][j]--;\n      if (seen.count(a[i][j])) isBad[i] = true;\n      seen.insert(a[i][j]);\n      if (j) {\n        adjList[a[i][j - 1]].push_back(a[i][j]);\n        outDeg[a[i][j - 1]]++;\n        inDeg[a[i][j]]++;\n      }\n    }\n  }\n  for (int i = 0; i < k; i++) {\n    a[n + i] = {i};\n  }\n  n += k;\n  for (int i = 0; i < n; i++) {\n    int num = a[i][0];\n    who_[getRoot(num)].push_back(i);\n    for (int j : a[i]) {\n      mge(j, num);\n    }\n  }\n  for (int i = 0; i < k; i++) {\n    if (getRoot(i) != i) continue;\n    int r = getRoot(i);\n    bool valid = true;\n    set<int> nums;\n    for (int ind : who_[r]) {\n      if (isBad[ind]) valid = false;\n      for (int x : a[ind]) nums.insert(x);\n    }\n    if (!valid) continue;\n    int sources = 0;\n    int sinks = 0;\n    for (int x : nums) {\n      if (!inDeg[x]) sources++;\n      if (!outDeg[x]) sinks++;\n      if (outDeg[x]) {\n        for (int y : adjList[x])\n          if (y != adjList[x].back()) valid = false;\n      }\n    }\n    if (sources != 1 || sinks != 1) valid = false;\n    if (!valid) continue;\n    objects.push_back(sz[r]);\n  }\n  int ans = solve(m);\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <typename T>\nstruct range {\n  T b, e;\n  range(T _b, T _e) : b(_b), e(_e) {}\n  T begin() const { return b; }\n  T end() const { return e; }\n};\ntemplate <typename T>\nrange<T> make_range(T b, T e) {\n  return range<T>(b, e);\n}\ntemplate <typename T>\nstruct is_cont {\n  static constexpr const bool value = false;\n};\ntemplate <typename T>\nstruct is_cont<range<T>> {\n  static constexpr const bool value = true;\n};\ntemplate <typename... Ts>\nstruct is_cont<std::vector<Ts...>> {\n  static constexpr const bool value = true;\n};\ntemplate <typename... Ts>\nstruct is_cont<std::set<Ts...>> {\n  static constexpr const bool value = true;\n};\ntemplate <typename... Ts>\nstruct is_cont<std::map<Ts...>> {\n  static constexpr const bool value = true;\n};\ntemplate <typename T, typename U>\nstd::ostream& operator<<(std::ostream& os, const std::pair<T, U>& p) {\n  return os << '<' << p.first << ',' << p.second << '>';\n}\ntemplate <typename T>\ntypename std::enable_if<is_cont<T>::value, std::ostream>::type& operator<<(\n    std::ostream& os, const T& c) {\n  if (c.begin() == c.end()) return os << \"{}\";\n  auto it = c.begin();\n  for (os << '{' << *it; ++it != c.end(); os << ',' << *it)\n    ;\n  return os << '}';\n}\nvoid dbg() { std::cerr << std::endl; }\ntemplate <typename T, typename... Ts>\nvoid dbg(T arg, Ts... args) {\n  std::cerr << ' ' << arg;\n  dbg(args...);\n}\ntemplate <typename T>\nvoid Min(T& x, const T& y) {\n  if (x > y) x = y;\n}\ntemplate <typename T>\nvoid Max(T& x, const T& y) {\n  if (x < y) x = y;\n}\nconstexpr const unsigned int mod = 998244353u;\nunsigned int add(unsigned int x, unsigned int y) {\n  return x + y < mod ? x + y : x + y - mod;\n}\nunsigned int sub(unsigned int x, unsigned int y) {\n  return x < y ? mod + x - y : x - y;\n}\nunsigned int mul(unsigned int x, unsigned int y) {\n  return (unsigned long long)x * y % mod;\n}\nunsigned int fpow(unsigned int x, unsigned int y) {\n  unsigned int z = 1;\n  for (; y; y >>= 1) {\n    if (y & 1) z = mul(z, x);\n    x = mul(x, x);\n  }\n  return z;\n}\nconstexpr const unsigned int maxn = 300005u;\nunsigned int ban[maxn];\nstd::vector<unsigned int> le[maxn], ri[maxn];\nvoid dfs(unsigned int u) {\n  if (ban[u]) {\n    return;\n  }\n  ban[u] = 1;\n  for (const auto& v : le[u]) {\n    dfs(v);\n  }\n  for (const auto& v : ri[u]) {\n    dfs(v);\n  }\n}\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  unsigned int n, m, k;\n  std::cin >> n >> m >> k;\n  for (unsigned int i = 0; i != n; ++i) {\n    unsigned int l, x, y;\n    std::cin >> l >> x;\n    --x;\n    for (unsigned int j = 1; j != l; ++j) {\n      std::cin >> y;\n      --y;\n      ri[x].push_back(y);\n      le[y].push_back(x);\n      x = y;\n    }\n  }\n  for (unsigned int i = 0; i != k; ++i) {\n    std::sort(le[i].begin(), le[i].end());\n    le[i].resize(std::unique(le[i].begin(), le[i].end()) - le[i].begin());\n    std::sort(ri[i].begin(), ri[i].end());\n    ri[i].resize(std::unique(ri[i].begin(), ri[i].end()) - ri[i].begin());\n  }\n  for (unsigned int i = 0; i != k; ++i) {\n    if (le[i].size() >= 2u || ri[i].size() >= 2u) {\n      dfs(i);\n    }\n  }\n  std::map<unsigned int, unsigned int> mp;\n  for (unsigned int i = 0; i != k; ++i) {\n    if (le[i].empty() && !ban[i]) {\n      unsigned int s = 1;\n      for (unsigned int j = i; !ri[j].empty(); j = ri[j][0]) {\n        ++s;\n      }\n      ++mp[s];\n    }\n  }\n  std::vector<unsigned int> f(m + 1);\n  f[0] = 1;\n  for (unsigned int i = 1; i <= m; ++i) {\n    for (const auto& p : mp) {\n      if (p.first > i) {\n        break;\n      }\n      f[i] = add(f[i], mul(f[i - p.first], p.second));\n    }\n  }\n  std::cout << f[m] << std::endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 3 * 1e5 + 100;\nlong long n, m, k, in[N], out[N], w, vi[N], dp[N], t[N];\nvector<long long> e[N], p[N];\nvector<pair<long long, long long> > A;\nunordered_map<long long, long long> mp[N];\ninline void add(long long &a, long long b) {\n  a = ((a + b >= 998244353) ? a + b - 998244353 : a + b);\n}\ninline void del(long long &a, long long b) {\n  a = ((a - b < 0) ? a - b + 998244353 : a - b);\n}\ninline void mul(long long &a, long long b) { a = a * b % 998244353; }\ninline long long m_pow(long long a, long long b) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) mul(ans, a);\n    b >>= 1;\n    mul(a, a);\n  }\n  return ans;\n}\ninline long long read() {\n  long long f = 1, x = 0;\n  char s = getchar();\n  while (s < '0' || s > '9') {\n    if (s == '-') f = -1;\n    s = getchar();\n  }\n  while (s >= '0' && s <= '9') {\n    x = x * 10 + s - '0';\n    s = getchar();\n  }\n  return x * f;\n}\nvoid dfs(long long x) {\n  p[w].push_back(x);\n  vi[x] = 1;\n  for (long long u : e[x])\n    if (!vi[u]) dfs(u);\n}\nsigned main() {\n  n = read();\n  m = read();\n  k = read();\n  for (long long i = 1; i <= n; i++) {\n    long long c = read(), last = read();\n    for (long long i = 2; i <= c; i++) {\n      long long now = read();\n      if (!mp[now].count(last)) {\n        mp[now][last] = 1;\n        in[now]++;\n        out[last]++;\n      }\n      e[now].push_back(last);\n      e[last].push_back(now);\n      last = now;\n    }\n  }\n  for (long long i = 1; i <= k; i++)\n    if (!vi[i]) w++, dfs(i);\n  for (long long i = 1; i <= w; i++) {\n    if ((long long)p[i].size() == 1) {\n      if (in[p[i][0]] == 0 && out[p[i][0]] == 0) t[1]++;\n      continue;\n    }\n    long long cnt = 0;\n    for (long long x : p[i])\n      if (in[x] == 1 && out[x] == 1) cnt++;\n    if (cnt != (long long)p[i].size() - 2) continue;\n    long long a = 0, b = 0;\n    for (long long x : p[i])\n      a += (in[x] == 1 && out[x] == 0), b += (in[x] == 0 && out[x] == 1);\n    if (a != 1 || b != 1) continue;\n    t[(long long)p[i].size()]++;\n  }\n  for (long long i = 1; i <= m; i++)\n    if (t[i] > 0) A.push_back(make_pair(i, t[i]));\n  dp[0] = 1;\n  for (long long i = 1; i <= m; i++)\n    for (auto it : A)\n      if (i >= it.first) add(dp[i], it.second * dp[i - it.first] % 998244353);\n  printf(\"%lld\\n\", dp[m]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353, N = 3e5 + 5;\npair<int, int> g[N];\nint nxt[N], pre[N], a[N], ban[N], vis[N], t[N], dp[N];\nint n, m, k, len, flag;\nvoid link(int u, int v) {\n  if (nxt[u] && nxt[u] != v) {\n    flag = 1;\n    return;\n  }\n  if (pre[v] && pre[v] != u) {\n    flag = 1;\n    return;\n  }\n  nxt[u] = v;\n  pre[v] = u;\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &k);\n  for (int i = 1; i <= n; i++) {\n    int len;\n    scanf(\"%d\", &len);\n    flag = 0;\n    for (int j = 1; j <= len; j++) {\n      scanf(\"%d\", &a[j]);\n      if (j > 1) link(a[j - 1], a[j]);\n    }\n    if (flag)\n      for (int j = 1; j <= len; j++) ban[a[j]] = 1;\n  }\n  for (int i = 1; i <= k; i++) {\n    if (ban[i]) continue;\n    if (!pre[i]) {\n      int tmp = i, cando = 1;\n      while (tmp) {\n        if (ban[tmp]) cando = 0;\n        tmp = nxt[tmp];\n      }\n      if (cando) {\n        int qwq = 0;\n        tmp = i;\n        while (tmp) qwq++, vis[tmp] = 1, tmp = nxt[tmp];\n        t[qwq]++;\n      }\n    }\n  }\n  for (int i = 1; i <= k; i++)\n    if (t[i]) g[++len] = make_pair(i, t[i]);\n  dp[0] = 1;\n  for (int i = 1; i <= m; i++)\n    for (int j = 1; j <= len; j++) {\n      if (g[j].first > i) break;\n      dp[i] = (dp[i] + 1ll * dp[i - g[j].first] * g[j].second % mod) % mod;\n    }\n  printf(\"%d\\n\", dp[m]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 300010;\nconst int mod = 998244353;\nconst int inf = 2147483647;\nlong long read() {\n  long long x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') x = x * 10ll + ch - '0', ch = getchar();\n  return x * f;\n}\nvoid up(int& x, int y) {\n  x += y;\n  if (x >= mod) x -= mod;\n}\nint n, m, k, L[N], R[N], a[N], b[N], cnt[N], f[N];\nbool v[N], del[N];\nvector<pair<int, int> > h;\nint main() {\n  n = read(), m = read(), k = read();\n  for (int i = 1; i <= n; i++) {\n    int l = read();\n    for (int j = 1; j <= l; j++) a[j] = read(), cnt[a[j]]++;\n    bool flag = false;\n    for (int j = 1; j <= l; j++)\n      if (cnt[a[j]] > 1) {\n        flag = true;\n        break;\n      }\n    for (int j = 1; j <= l; j++) cnt[a[j]]--;\n    for (int j = 2; j <= l; j++) {\n      if (R[a[j - 1]] && R[a[j - 1]] != a[j]) flag = true;\n      R[a[j - 1]] = a[j];\n      v[a[j]] = true;\n    }\n    for (int j = 1; j < l; j++) {\n      if (L[a[j + 1]] && L[a[j + 1]] != a[j]) flag = true;\n      L[a[j + 1]] = a[j];\n    }\n    if (flag) {\n      for (int j = 1; j <= l; j++) del[a[j]] = true;\n    }\n  }\n  for (int i = 1; i <= k; i++)\n    if (!v[i]) {\n      int cnt = 0, t = i;\n      bool tmp = false;\n      while (t) {\n        tmp |= del[t];\n        if (tmp) break;\n        cnt++;\n        t = R[t];\n      }\n      if (!tmp) b[cnt]++;\n    }\n  for (int i = 1; i <= m; i++)\n    if (b[i]) h.push_back(make_pair(i, b[i]));\n  f[0] = 1;\n  for (int i = 1; i <= m; i++)\n    for (pair<int, int> j : h)\n      if (j.first <= i) up(f[i], (long long)f[i - j.first] * j.second % mod);\n  printf(\"%d\\n\", f[m]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 300005, mod = 998244353;\nint n, m, k, mx;\nint in[maxn], out[maxn], f[maxn], tot[maxn], q[maxn], tmp[maxn];\nvector<int> t, v[maxn], g[maxn];\nmap<int, int> mp[maxn];\nvoid dfs(int x, int d) {\n  if (in[x] > 1 || out[x] > 1) return;\n  if (out[x] == 0) tot[d]++, mx = max(mx, d);\n  for (int i = 0; i < g[x].size(); i++) dfs(g[x][i], d + 1);\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &k);\n  for (int i = 1, c; i <= n; i++) {\n    scanf(\"%d\", &c), v[i].resize(c);\n    for (int j = 0; j < c; j++) {\n      scanf(\"%d\", &v[i][j]);\n      if (j > 0 && mp[v[i][j - 1]][v[i][j]] == 0)\n        mp[v[i][j - 1]][v[i][j]] = 1, g[v[i][j - 1]].push_back(v[i][j]),\n                    out[v[i][j - 1]]++, in[v[i][j]]++;\n    }\n  }\n  for (int i = 1; i <= k; i++)\n    if (in[i] == 0) dfs(i, 1);\n  f[0] = 1;\n  for (int i = 1; i <= mx; i++)\n    if (tot[i]) t.push_back(i);\n  for (int i = 1; i <= m; i++)\n    for (int j = 0; j < t.size(); j++)\n      if (i >= t[j]) f[i] = (f[i] + 1ll * f[i - t[j]] * tot[t[j]]) % mod;\n  printf(\"%d\\n\", f[m]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\nstring to_string(const string& s) { return '\"' + s + '\"'; }\nstring to_string(const char& s) {\n  string res = \"'\";\n  res += s;\n  res += \"'\";\n  return res;\n}\nstring to_string(bool b) { return (b ? \"true\" : \"false\"); }\nstring to_string(vector<bool> v) {\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (i) res += \", \";\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto& x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" +\n         to_string(get<2>(p)) + \")\";\n}\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" +\n         to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\nconst long long mod = 998244353;\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long n, m, k;\n  cin >> n >> m >> k;\n  vector<vector<long long>> g(k);\n  vector<vector<long long>> a(n);\n  vector<vector<long long>> G(n);\n  for (long long i = 0; i < n; i++) {\n    long long m;\n    cin >> m;\n    for (long long j = 0; j < m; j++) {\n      long long x;\n      cin >> x;\n      x--;\n      a[i].push_back(x);\n      g[x].push_back(i);\n    }\n  }\n  long long usd = 0;\n  for (long long i = 0; i < k; i++) {\n    if ((long long)(g[i]).size() == 0)\n      usd++;\n    else {\n      for (auto x : g[i]) {\n        if (x != g[i][0]) {\n          G[x].push_back(g[i][0]);\n          G[g[i][0]].push_back(x);\n        }\n      }\n    }\n  }\n  vector<long long> p(n, -1), ts;\n  function<void(long long)> dfs = [&](long long v) {\n    ts.push_back(v);\n    for (auto x : G[v]) {\n      if (p[x] == -1) {\n        p[x] = v;\n        dfs(x);\n      }\n    }\n  };\n  vector<long long> AB(5 * k, 0), pos(k, -1);\n  map<long long, long long> d;\n  for (long long i = 0; i < n; i++) {\n    if (p[i] != -1) continue;\n    ts.clear();\n    p[i] = n;\n    dfs(i);\n    vector<long long> C;\n    for (auto v : ts) {\n      for (auto x : a[v]) C.push_back(x);\n    }\n    sort((C).begin(), (C).end());\n    C.resize(unique((C).begin(), (C).end()) - C.begin());\n    long long ok = 1;\n    for (auto v : ts) {\n      auto A = a[v];\n      sort((A).begin(), (A).end());\n      for (long long i = 0; i < (long long)(A).size() - 1; i++)\n        if (A[i] == A[i + 1]) ok = 0;\n    }\n    if (!ok) continue;\n    long long st = 2 * k;\n    for (auto x : a[ts[0]]) {\n      AB[st] = x;\n      pos[x] = st;\n      st++;\n    }\n    for (auto v : ts) {\n      if (v == ts[0]) continue;\n      long long first = 0;\n      for (long long j = 0; j < (long long)(a[v]).size(); j++) {\n        if (pos[a[v][j]] != -1) {\n          first = pos[a[v][j]] - j;\n          break;\n        }\n      }\n      for (long long j = 0; j < (long long)(a[v]).size(); j++) {\n        if (first + j < 0 || first + j >= (long long)(AB).size()) {\n          ok = 0;\n          break;\n        }\n        if (pos[AB[first + j]] == first + j) {\n          if (AB[first + j] != a[v][j]) ok = 0;\n        } else {\n          if (pos[a[v][j]] == -1) {\n            AB[first + j] = a[v][j];\n            pos[a[v][j]] = first + j;\n          } else {\n            ok = 0;\n          }\n        }\n      }\n      if (!ok) break;\n    }\n    if (!ok) {\n      for (auto x : C) pos[x] = -1;\n      continue;\n    }\n    long long mn = 1e18, mx = -1e18;\n    for (auto x : C) {\n      mn = min(mn, pos[x]);\n      mx = max(mx, pos[x]);\n    }\n    d[mx - mn + 1]++;\n    for (auto x : C) pos[x] = -1;\n  }\n  vector<long long> dp(m + 1);\n  dp[0] = 1;\n  for (long long i = 0; i < m; i++) {\n    dp[i + 1] = (dp[i] * usd) % mod;\n    for (auto [x, y] : d) {\n      if (x <= i + 1) {\n        dp[i + 1] = (dp[i + 1] + dp[i + 1 - x] * y) % mod;\n      }\n    }\n  }\n  cout << dp[m];\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\nstruct DSU {\n  int n;\n  vector<int> link, sz;\n  DSU(int n) : n(n), link(n), sz(n) {\n    for (int i = 0; i < n; i++) {\n      link[i] = i;\n      sz[i] = 1;\n    }\n  }\n  int first(int x) { return (x == link[x] ? x : link[x] = first(link[x])); }\n  void unite(int x, int y) {\n    x = first(x), y = first(y);\n    if (x == y) {\n      return;\n    }\n    if (sz[x] < sz[y]) {\n      swap(x, y);\n    }\n    sz[x] += sz[y], link[y] = x;\n  }\n};\nint n, m, k, dp[300001], nxt[300000], prv[300000];\nvector<int> arr[300000], dsc[300000];\nvector<pair<int, int>> trns;\nmap<int, int> chns;\nbool bad[300000], appeared[300000];\nint mul(int x, int y) { return ((long long)x * y) % mod; }\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin >> n >> m >> k;\n  DSU grp(k);\n  memset(nxt, -1, sizeof(nxt));\n  memset(prv, -1, sizeof(prv));\n  for (int i = 0, sz; i < n; i++) {\n    cin >> sz;\n    arr[i].resize(sz);\n    for (int j = 0; j < sz; j++) {\n      cin >> arr[i][j];\n      appeared[arr[i][j] - 1] = true;\n    }\n    for (int j = 0; j < sz - 1; j++) {\n      grp.unite(arr[i][j] - 1, arr[i][j + 1] - 1);\n    }\n  }\n  for (int i = 0; i < k; i++) {\n    dsc[grp.first(i)].push_back(i);\n  }\n  for (int i = 0; i < n; i++) {\n    int sz = arr[i].size();\n    for (int j = 0; j < sz - 1; j++) {\n      if (prv[arr[i][j + 1] - 1] != -1 &&\n          prv[arr[i][j + 1] - 1] != arr[i][j] - 1) {\n        bad[grp.first(arr[i][j] - 1)] = true;\n      }\n      if (nxt[arr[i][j] - 1] != -1 && nxt[arr[i][j] - 1] != arr[i][j + 1] - 1) {\n        bad[grp.first(arr[i][j] - 1)] = true;\n      }\n      prv[arr[i][j + 1] - 1] = arr[i][j] - 1;\n      nxt[arr[i][j] - 1] = arr[i][j + 1] - 1;\n    }\n  }\n  for (int i = 0; i < k; i++) {\n    if (bad[i]) {\n      for (int j : dsc[i]) {\n        bad[j] = true;\n      }\n    }\n  }\n  for (int i = 0; i < k; i++) {\n    if (prv[i] == -1 && !bad[i]) {\n      int chn = 1, cur = i;\n      while (nxt[cur] != -1) {\n        cur = nxt[cur];\n        ++chn;\n      }\n      ++chns[chn];\n    }\n  }\n  for (auto it : chns) {\n    trns.push_back(it);\n  }\n  dp[0] = 1;\n  for (int i = 1; i <= m; i++) {\n    for (auto j : trns) {\n      if (i >= j.first) {\n        dp[i] = (dp[i] + mul(dp[i - j.first], j.second)) % mod;\n      }\n    }\n  }\n  cout << dp[m] << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 10;\nconst long long mod = 998244353;\ninline long long gcd(long long a, long long b) {\n  return !b ? a : gcd(b, a % b);\n}\ninline long long q_pow(long long a, long long x = mod - 2) {\n  long long ans = 1, tmp = a;\n  while (x) {\n    if (x & 1) (ans *= tmp) %= mod;\n    (tmp *= tmp) %= mod;\n    x >>= 1;\n  }\n  return ans;\n}\ntemplate <typename T>\ninline void re(T &N) {\n  int f = 1;\n  char c;\n  while ((c = getchar()) < '0' || c > '9')\n    if (c == '-') f = -1;\n  N = c - '0';\n  while ((c = getchar()) >= '0' && c <= '9') N = N * 10 + c - '0';\n  N *= f;\n}\ntemplate <class T, class... T_>\ninline void re(T &x, T_ &...y) {\n  re(x), re(y...);\n}\nint m, n, k, t = 1, st, en;\nint vis[N];\nint cnt[N];\nlong long dp[N];\nvector<int> in[N], out[N];\ninline void add(int x, int y) {\n  in[y].push_back(x);\n  out[x].push_back(y);\n}\nint bad[N];\nvoid expand(int x) {\n  if (bad[x]) return;\n  bad[x] = 1;\n  for (int i : in[x]) expand(i);\n  for (int i : out[x]) expand(i);\n}\nvector<int> v[N];\nint main() {\n  re(n, m, k);\n  for (int i = 1; i <= n; i++) {\n    int len;\n    re(len);\n    v[i] = vector<int>(len);\n    for (int j = 0; j < len; j++) re(v[i][j]);\n    for (int j = 0; j + 1 < len; j++) add(v[i][j], v[i][j + 1]);\n  }\n  for (int i = 1; i <= n; i++) {\n    if (set<int>(v[i].begin(), v[i].end()).size() != v[i].size())\n      for (int j : v[i]) expand(j);\n  }\n  for (int i = 1; i <= k; i++) {\n    sort(in[i].begin(), in[i].end());\n    in[i].erase(unique(in[i].begin(), in[i].end()), in[i].end());\n    sort(out[i].begin(), out[i].end());\n    out[i].erase(unique(out[i].begin(), out[i].end()), out[i].end());\n  }\n  for (int i = 1; i <= k; i++) {\n    if (bad[i]) continue;\n    if (in[i].size() > 1 || out[i].size() > 1) {\n      expand(i);\n      continue;\n    }\n    if (vis[i]) continue;\n    queue<int> q;\n    q.push(i);\n    vis[i] = 1;\n    int ok = 1;\n    while (!q.empty()) {\n      int x = q.front();\n      q.pop();\n      for (int j : out[x]) {\n        if (vis[j]) {\n          ok = 0;\n          break;\n        }\n        vis[j] = 1;\n        q.push(j);\n      }\n      if (!ok) {\n        expand(x);\n        break;\n      }\n    }\n    if (ok) {\n      q.push(i);\n      while (!q.empty()) {\n        int x = q.front();\n        q.pop();\n        for (int j : in[x]) {\n          if (vis[j]) continue;\n          vis[j] = 1;\n          q.push(j);\n        }\n      }\n    }\n  }\n  fill(vis + 1, vis + k + 1, 0);\n  for (int i = 1; i <= k; i++)\n    if (!bad[i] && !vis[i]) {\n      int sum = 1;\n      queue<int> q;\n      q.push(i);\n      vis[i] = 1;\n      while (!q.empty()) {\n        int x = q.front();\n        q.pop();\n        for (int j : in[x]) {\n          if (vis[j]) continue;\n          sum++;\n          vis[j] = 1;\n          q.push(j);\n        }\n        for (int j : out[x]) {\n          if (vis[j]) continue;\n          sum++;\n          vis[j] = 1;\n          q.push(j);\n        }\n      }\n      cnt[sum]++;\n    }\n  vector<int> key;\n  for (int i = 1; i <= m; i++)\n    if (cnt[i]) key.push_back(i);\n  dp[0] = 1;\n  for (int i = 1; i <= m; i++)\n    for (int j : key)\n      if (i >= j) (dp[i] += dp[i - j] * cnt[j] % mod) %= mod;\n  printf(\"%lld\\n\", dp[m]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long get() {\n  long long x = 0, f = 1;\n  char c = getchar();\n  while (!isdigit(c)) {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (isdigit(c)) {\n    x = x * 10 + c - '0';\n    c = getchar();\n  }\n  return x * f;\n}\nconst long long N = 3e5 + 5, P = 998244353;\nlong long n, m, k, pre[N], suf[N], f[N], a[N], ban[N], cnt[N], w[N], v[N], tot;\nsigned main() {\n  n = get(), m = get(), k = get();\n  for (long long t = 1; t <= n; t++) {\n    long long len = get();\n    for (long long i = 1; i <= len; i++) a[i] = get();\n    long long flag = 1;\n    for (long long i = 2; i <= len; i++) {\n      if (pre[a[i]] && pre[a[i]] != a[i - 1]) {\n        flag = 0;\n        continue;\n      }\n      if (suf[a[i - 1]] && suf[a[i - 1]] != a[i]) {\n        flag = 0;\n        continue;\n      }\n      pre[a[i]] = a[i - 1], suf[a[i - 1]] = a[i];\n    }\n    if (!flag)\n      for (long long i = 1; i <= len; i++) ban[a[i]] = 1;\n  }\n  for (long long i = 1; i <= k; i++) {\n    if (pre[i]) continue;\n    long long flag = 0;\n    for (long long now = i; now; now = suf[now]) flag |= ban[now];\n    if (!flag) {\n      long long len = 0;\n      for (long long now = i; now; now = suf[now]) ++len;\n      cnt[len]++;\n    }\n  }\n  for (long long i = 1; i <= k; i++)\n    if (cnt[i]) ++tot, w[tot] = i, v[tot] = cnt[i];\n  f[0] = 1;\n  for (long long i = 0; i <= m; i++)\n    for (long long j = 1; j <= tot; j++)\n      if (w[j] <= i) f[i] = (f[i] + v[j] * f[i - w[j]] % P) % P;\n  printf(\"%lld\\n\", f[m]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\nstring to_string(const string& s) { return '\"' + s + '\"'; }\nstring to_string(const char* s) { return to_string((string)s); }\nstring to_string(bool b) { return (b ? \"true\" : \"false\"); }\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto& x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" +\n         to_string(get<2>(p)) + \")\";\n}\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" +\n         to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a;\n    swap(a, m);\n    u -= t * v;\n    swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod())\n      v = static_cast<Type>(x);\n    else\n      v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const {\n    return static_cast<U>(value);\n  }\n  constexpr static Type mod() { return T::value; }\n  Modular& operator+=(const Modular& other) {\n    if ((value += other.value) >= mod()) value -= mod();\n    return *this;\n  }\n  Modular& operator-=(const Modular& other) {\n    if ((value -= other.value) < 0) value += mod();\n    return *this;\n  }\n  template <typename U>\n  Modular& operator+=(const U& other) {\n    return *this += Modular(other);\n  }\n  template <typename U>\n  Modular& operator-=(const U& other) {\n    return *this -= Modular(other);\n  }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) {\n    Modular result(*this);\n    *this += 1;\n    return result;\n  }\n  Modular operator--(int) {\n    Modular result(*this);\n    *this -= 1;\n    return result;\n  }\n  Modular operator-() const { return Modular(-value); }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value,\n                     Modular>::type&\n  operator*=(const Modular& rhs) {\n    value = normalize(static_cast<int64_t>(value) *\n                      static_cast<int64_t>(rhs.value));\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value,\n                     Modular>::type&\n  operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) *\n                                         rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value,\n                     Modular>::type&\n  operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n  Modular& operator/=(const Modular& other) {\n    return *this *= Modular(inverse(other.value, mod()));\n  }\n  friend const Type& abs(const Modular& x) { return x.value; }\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\ntemplate <typename T>\nbool operator==(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return lhs.value == rhs.value;\n}\ntemplate <typename T, typename U>\nbool operator==(const Modular<T>& lhs, U rhs) {\n  return lhs == Modular<T>(rhs);\n}\ntemplate <typename T, typename U>\nbool operator==(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) == rhs;\n}\ntemplate <typename T>\nbool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T, typename U>\nbool operator!=(const Modular<T>& lhs, U rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T, typename U>\nbool operator!=(U lhs, const Modular<T>& rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T>\nbool operator<(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return lhs.value < rhs.value;\n}\ntemplate <typename T>\nModular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator+(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator+(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T>\nModular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator-(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator-(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T>\nModular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator*(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator*(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T>\nModular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator/(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator/(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, k;\n  cin >> n >> m >> k;\n  vector<vector<int>> g(k);\n  vector<vector<int>> gr(k);\n  for (int i = 0; i < n; i++) {\n    int len;\n    cin >> len;\n    int last;\n    cin >> last;\n    --last;\n    for (int j = 1; j < len; j++) {\n      int cur;\n      cin >> cur;\n      --cur;\n      g[last].push_back(cur);\n      gr[cur].push_back(last);\n      last = cur;\n    }\n  }\n  for (int i = 0; i < k; i++) {\n    sort(g[i].begin(), g[i].end());\n    g[i].resize(unique(g[i].begin(), g[i].end()) - g[i].begin());\n    sort(gr[i].begin(), gr[i].end());\n    gr[i].resize(unique(gr[i].begin(), gr[i].end()) - gr[i].begin());\n  }\n  map<int, int> mp;\n  vector<bool> was(k, false);\n  vector<bool> used(k, false);\n  for (int start = 0; start < k; start++) {\n    if (was[start]) {\n      continue;\n    }\n    vector<int> que(1, start);\n    was[start] = true;\n    for (int b = 0; b < (int)que.size(); b++) {\n      for (int j : g[que[b]]) {\n        if (!was[j]) {\n          que.push_back(j);\n          was[j] = true;\n        }\n      }\n      for (int j : gr[que[b]]) {\n        if (!was[j]) {\n          que.push_back(j);\n          was[j] = true;\n        }\n      }\n    }\n    int edges = 0;\n    for (int i : que) {\n      edges += (int)g[i].size();\n    }\n    if (edges != (int)que.size() - 1) {\n      continue;\n    }\n    int root = -1;\n    for (int i : que) {\n      if (gr[i].empty()) {\n        root = i;\n        break;\n      }\n    }\n    assert(root != -1);\n    vector<int> seq(1, root);\n    used[root] = true;\n    while (true) {\n      int nxt = -1;\n      for (int i : g[seq.back()]) {\n        if (!used[i]) {\n          nxt = i;\n          break;\n        }\n      }\n      if (nxt == -1) {\n        break;\n      }\n      seq.push_back(nxt);\n      used[nxt] = true;\n    }\n    if (seq.size() == que.size()) {\n      mp[(int)seq.size()] += 1;\n    }\n  }\n  vector<pair<int, int>> ps;\n  for (auto& p : mp) {\n    ps.push_back(p);\n  }\n  vector<Mint> dp(m + 1);\n  dp[0] = 1;\n  for (int i = 1; i <= m; i++) {\n    for (auto& p : ps) {\n      if (i >= p.first) {\n        dp[i] += dp[i - p.first] * p.second;\n      }\n    }\n  }\n  cout << dp[m] << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(3)\nusing namespace std;\nconst int N = 4000005, mod = 998244353;\nint n, m, k, l[N], r[N], a[N], vis[N], t, mx, b[N], fl;\nvector<int> s, p;\nint qp(int a, int b) {\n  int ans = 1;\n  while (b) {\n    if (b & 1) ans = 1ll * ans * a % mod;\n    a = 1ll * a * a % mod;\n    b >>= 1;\n  }\n  return ans;\n}\nint rv[N], w[N];\nvoid ntt(vector<int>& a, int f) {\n  int n = a.size();\n  for (int i = 0; i < n; i++) rv[i] = (rv[i >> 1] >> 1) | ((i & 1) * (n >> 1));\n  int wn = qp(f ? (mod + 1) / 3 : 3, (mod - 1) / n);\n  w[0] = 1;\n  for (int i = 1; i < n; i++) w[i] = 1ll * w[i - 1] * wn % mod;\n  for (int i = 0; i < n; i++)\n    if (i < rv[i]) swap(a[i], a[rv[i]]);\n  for (int mid = 1; mid < n; mid <<= 1) {\n    for (int i = 0; i < n; i += (mid << 1)) {\n      for (int j = 0; j < mid; j++) {\n        int x = a[i + j],\n            y = 1ll * a[i + j + mid] * w[n / (mid << 1) * j] % mod;\n        a[i + j] = (x + y >= mod ? x + y - mod : x + y);\n        a[i + j + mid] = (x - y < 0 ? x - y + mod : x - y);\n      }\n    }\n  }\n  if (f) {\n    int iv = qp(n, mod - 2);\n    for (int i = 0; i < n; i++) a[i] = 1ll * a[i] * iv % mod;\n  }\n}\nvector<int> mul(vector<int> a, vector<int> b) {\n  int n = 1, m = a.size() + b.size() - 1;\n  if (a.size() * b.size() <= 4096) {\n    vector<int> c(m, 0);\n    for (int i = 0; i < a.size(); i++)\n      for (int j = 0; j < b.size(); j++)\n        c[i + j] = (c[i + j] + 1ll * a[i] * b[j] % mod) % mod;\n    return c;\n  }\n  while (n < m) n <<= 1;\n  a.resize(n), b.resize(n);\n  ntt(a, 0), ntt(b, 0);\n  for (int i = 0; i < n; i++) a[i] = 1ll * a[i] * b[i] % mod;\n  ntt(a, 1);\n  a.resize(m);\n  return a;\n}\nvector<int> inv(vector<int> a) {\n  int n = a.size();\n  if (n == 1) {\n    a[0] = qp(a[0], mod - 2);\n    return a;\n  }\n  int m = 1;\n  while (m < (n << 1)) m <<= 1;\n  vector<int> a0 = a;\n  a0.resize((n + 1) / 2);\n  vector<int> b0 = inv(a0);\n  a.resize(m), b0.resize(m);\n  ntt(a, 0), ntt(b0, 0);\n  for (int i = 0; i < m; i++)\n    a[i] = 1ll * b0[i] * (2 - 1ll * a[i] * b0[i] % mod + mod) % mod;\n  ntt(a, 1);\n  a.resize(n);\n  return a;\n}\nvoid dfs(int u) {\n  vis[u] = 1;\n  t++;\n  if (!fl) return;\n  if (!r[u]) return;\n  if (b[u] || vis[r[u]]) b[u] = 1, fl = 0;\n  dfs(r[u]);\n  if (b[r[u]]) b[u] = 1, fl = 0;\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &k);\n  for (int i = 1; i <= n; i++) {\n    int c;\n    scanf(\"%d\", &c);\n    for (int j = 1; j <= c; j++) scanf(\"%d\", &a[j]);\n    for (int j = 2; j <= c; j++) {\n      if (l[a[j]] && l[a[j]] != a[j - 1]) b[a[j]] = 1;\n      l[a[j]] = a[j - 1];\n    }\n    for (int j = 1; j < c; j++) {\n      if (r[a[j]] && r[a[j]] != a[j + 1]) b[a[j]] = 1;\n      r[a[j]] = a[j + 1];\n    }\n  }\n  mx = m + 5;\n  s.resize(mx);\n  for (int i = 1; i <= k; i++) {\n    if (vis[i] || b[i]) continue;\n    if (!l[i] && !r[i]) {\n      s[1]++;\n      vis[i] = 1;\n      continue;\n    }\n    if (l[i] == i && r[i] == i) {\n      vis[i] = b[i] = 1;\n      continue;\n    }\n    if (!l[i] && r[i]) {\n      t = 0, fl = 1;\n      dfs(i);\n      if (fl && t <= m) s[t]++;\n    }\n  }\n  vector<int> f = vector<int>(mx, 0);\n  f[0] = (f[0] + mod - 1) % mod;\n  s[0] = (s[0] + mod - 1) % mod;\n  vector<int> iv = inv(s);\n  iv[0] = (iv[0] + mod - 1) % mod;\n  f = mul(f, iv);\n  printf(\"%d\\n\", f[m]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 300500;\nconst int L = 22;\nconst long long M = 998244353;\nint par[N];\nint up[N][L];\nint sz[N];\nvoid merge(int a, int b) {\n  if (sz[a] <= sz[b]) {\n    par[a] = b;\n    sz[b] += sz[a];\n  } else {\n    par[b] = a;\n    sz[a] += sz[b];\n  }\n}\nint parent(int a) {\n  if (a == par[a]) return a;\n  return par[a] = parent(par[a]);\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  for (int i = 0; i < N; i++) {\n    par[i] = i;\n    sz[i] = 1;\n  }\n  int n, m, k;\n  cin >> n >> m >> k;\n  vector<vector<int>> A;\n  for (int _ = 0; _ < n; _++) {\n    int l;\n    cin >> l;\n    vector<int> B(l);\n    for (int i = 0; i < l; i++) {\n      cin >> B[i];\n    }\n    A.push_back(B);\n  }\n  for (auto B : A) {\n    for (int i = 0; i < (int)B.size() - 1; i++) {\n      merge(parent(B[i]), parent(B[i + 1]));\n    }\n  }\n  vector<bool> ban(k + 1, false);\n  vector<int> next(k + 1, -1);\n  vector<int> prev(k + 1, -1);\n  for (auto B : A) {\n    for (int i = 0; i < (int)B.size() - 1; i++) {\n      if (next[B[i]] == -1) {\n        next[B[i]] = B[i + 1];\n      } else if (next[B[i]] != B[i + 1]) {\n        ban[parent(B[i])] = true;\n      }\n    }\n    for (int i = 0; i < (int)B.size() - 1; i++) {\n      if (prev[B[i + 1]] == -1) {\n        prev[B[i + 1]] = B[i];\n      } else if (prev[B[i + 1]] != B[i]) {\n        ban[parent(B[i + 1])] = true;\n      }\n    }\n    vector<int> B2 = B;\n    sort(B2.begin(), B2.end());\n    for (int i = 0; i < (int)B2.size() - 1; i++) {\n      if (B2[i] == B2[i + 1]) {\n        ban[parent(B2[i])] = true;\n      }\n    }\n  }\n  for (int i = 1; i <= k; i++) {\n    if (ban[parent(i)]) {\n      ban[i] = true;\n    }\n  }\n  for (int i = 1; i <= k; i++) {\n    if (!ban[i]) {\n      if (next[i] != -1) {\n        up[i][0] = next[i];\n      } else {\n        up[i][0] = i;\n      }\n    }\n  }\n  for (int l = 1; l < L; l++) {\n    for (int i = 1; i <= k; i++) {\n      if (!ban[i]) {\n        up[i][l] = up[up[i][l - 1]][l - 1];\n      }\n    }\n  }\n  for (int i = 1; i <= k; i++) {\n    if (!ban[i]) {\n      if (next[up[i][L - 1]] != -1) {\n        ban[i] = true;\n      }\n    }\n  }\n  vector<int> aboba;\n  for (int i = 1; i <= k; i++) {\n    if (!ban[i] && prev[i] == -1) {\n      int j = i;\n      int kek = 1;\n      for (int l = L - 1; l >= 0; l--) {\n        if (next[up[j][l]] != -1) {\n          j = up[j][l];\n          kek += (1 << l);\n        }\n      }\n      if (next[j] != -1) {\n        kek++;\n      }\n      aboba.push_back(kek);\n    }\n  }\n  vector<int> boba;\n  int s = (int)sqrt(n);\n  vector<long long> cnt(s + 1);\n  for (auto x : aboba) {\n    if (x <= s) {\n      cnt[x]++;\n    } else {\n      boba.push_back(x);\n    }\n  }\n  vector<long long> dp(m + 1);\n  dp[0] = 1;\n  for (int i = 1; i <= m; i++) {\n    for (int x = 1; x <= min(i, s); x++) {\n      dp[i] += (cnt[x] * dp[i - x]) % M;\n    }\n    for (auto x : boba) {\n      if (i >= x) {\n        dp[i] += dp[i - x];\n      }\n    }\n    dp[i] %= M;\n  }\n  cout << dp[m] << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 998244353;\nint main() {\n  int n, m, k;\n  cin >> n >> m >> k;\n  vector<int> c(n);\n  vector<vector<int>> A(n);\n  for (int i = 0; i < n; i++) {\n    cin >> c[i];\n    A[i].resize(c[i]);\n    for (int j = 0; j < c[i]; j++) {\n      cin >> A[i][j];\n      A[i][j]--;\n    }\n  }\n  vector<vector<int>> E1(k), E2(k);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < c[i] - 1; j++) {\n      E1[A[i][j]].push_back(A[i][j + 1]);\n      E2[A[i][j + 1]].push_back(A[i][j]);\n    }\n  }\n  for (int i = 0; i < k; i++) {\n    sort(E1[i].begin(), E1[i].end());\n    E1[i].erase(unique(E1[i].begin(), E1[i].end()), E1[i].end());\n    sort(E2[i].begin(), E2[i].end());\n    E2[i].erase(unique(E2[i].begin(), E2[i].end()), E2[i].end());\n  }\n  vector<bool> used(k, false);\n  vector<int> S;\n  for (int i = 0; i < k; i++) {\n    if (!used[i] && E2[i].empty()) {\n      used[i] = true;\n      int v = i;\n      int cnt = 1;\n      bool ok = true;\n      while (true) {\n        if (E1[v].empty()) {\n          break;\n        }\n        if (E1[v].size() >= 2) {\n          ok = false;\n          break;\n        }\n        int w = E1[v][0];\n        if (E2[w].size() >= 2) {\n          ok = false;\n          break;\n        }\n        if (used[w]) {\n          ok = false;\n          break;\n        }\n        used[w] = true;\n        cnt++;\n        v = w;\n      }\n      if (ok) {\n        S.push_back(cnt);\n      }\n    }\n  }\n  int cnt = S.size();\n  map<int, int> mp;\n  for (int i = 0; i < cnt; i++) {\n    mp[S[i]]++;\n  }\n  int cnt2 = 0;\n  vector<int> a, b;\n  for (auto P : mp) {\n    a.push_back(P.first);\n    b.push_back(P.second);\n    cnt2++;\n  }\n  vector<long long> dp(m + 1, 0);\n  dp[0] = 1;\n  for (int i = 0; i < m; i++) {\n    for (int j = 0; j < cnt2; j++) {\n      if (i + a[j] <= m) {\n        dp[i + a[j]] += dp[i] * b[j];\n        dp[i + a[j]] %= MOD;\n      }\n    }\n  }\n  cout << dp[m] << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353, G = 3;\nvoid ADD(int &x, int y) {\n  x += y;\n  if (x >= mod) x -= mod;\n}\nvoid SUB(int &x, int y) {\n  x -= y;\n  if (x < 0) x += mod;\n}\nlong long power(long long a, int b) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) ans = ans * a % mod;\n    a = a * a % mod, b >>= 1;\n  }\n  return ans;\n}\nnamespace PolyOp {\nint t1[1 << 20], t2[1 << 20], num[1 << 20];\nlong long W[1 << 20 | 10];\nint LSTN;\nlong long invn;\nvoid PreCalcNTT(int N) {\n  if (N == LSTN) return;\n  LSTN = N, invn = power(N, mod - 2);\n  for (int i = 0; i < N; i++) {\n    num[i] = num[i >> 1] >> 1 | (i & 1 ? N >> 1 : 0);\n  }\n  W[0] = 1, W[1] = power(G, (mod - 1) / N);\n  for (int i = 2; i <= N; i++) W[i] = W[i - 1] * W[1] % mod;\n}\nvoid NTT(int *f, int N, int flag) {\n  for (int i = 0; i < N; i++) {\n    if (i < num[i]) swap(f[i], f[num[i]]);\n  }\n  for (int len = 2; len <= N; len <<= 1) {\n    for (int i = 0; i < N; i += len) {\n      int *fl = f + i, *fr = fl + len / 2, step = flag ? -N / len : N / len;\n      long long *w = flag ? W + N : W;\n      for (int j = 0; j < len / 2; j++) {\n        int tmp = *fr * *w % mod;\n        SUB(*fr = *fl, tmp), ADD(*fl, tmp);\n        fl++, fr++, w += step;\n      }\n    }\n  }\n  if (flag) {\n    for (int i = 0; i < N; i++) {\n      f[i] = f[i] * invn % mod;\n    }\n  }\n}\nvoid polyinv(int *f, int n, int *g) {\n  if (n == 1) {\n    g[0] = power(f[0], mod - 2);\n    return;\n  }\n  int mid = n + 1 >> 1;\n  polyinv(f, mid, g);\n  int N = 1;\n  while (N < mid + mid + n - 2) N <<= 1;\n  PreCalcNTT(N);\n  for (int i = 0; i < N; i++) {\n    t1[i] = i < mid ? g[i] : 0, t2[i] = i < n ? f[i] : 0;\n  }\n  NTT(t1, N, 0), NTT(t2, N, 0);\n  for (int i = 0; i < N; i++) {\n    t1[i] = 1ll * t1[i] * t1[i] % mod * t2[i] % mod;\n  }\n  NTT(t1, N, 1);\n  for (int i = 0; i < n; i++) {\n    g[i] = (2ll * (i < mid ? g[i] : 0) - t1[i] + mod) % mod;\n  }\n}\n}  // namespace PolyOp\nint n, m, k;\nvector<vector<int> > a;\nint cnt[300010];\nint f[300010], g[300010];\nint suc[300010], pre[300010];\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &k);\n  for (int i = 0; i < n; i++) {\n    int k;\n    scanf(\"%d\", &k);\n    int lst = -1;\n    while (k--) {\n      int x;\n      scanf(\"%d\", &x);\n      if (lst != -1) {\n        if (suc[lst] == 0)\n          suc[lst] = x;\n        else if (suc[lst] != x)\n          suc[lst] = -1;\n        if (pre[x] == 0)\n          pre[x] = lst;\n        else if (pre[x] != lst)\n          pre[x] = -1;\n      }\n      lst = x;\n    }\n  }\n  f[0] = 1;\n  for (int i = 1; i <= k; i++) {\n    if (pre[i] == 0) {\n      int cur = i, cnt = 1;\n      while (1) {\n        if (suc[cur] == -1) goto BAD;\n        if (suc[cur] == 0) break;\n        cur = suc[cur], cnt++;\n        if (pre[cur] == -1) goto BAD;\n      }\n      f[cnt]--;\n    BAD:;\n    }\n  }\n  for (int i = 1; i <= m; i++) {\n    f[i] = (f[i] + mod) % mod;\n  }\n  PolyOp ::polyinv(f, m + 1, g);\n  printf(\"%d\\n\", g[m]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nconstexpr LL mod = 998244353;\nvoid no() {\n  cout << \"0\";\n  exit(0);\n}\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  int n, m, k;\n  cin >> n >> m >> k;\n  vector<set<int>> G(k + 1), H(k + 1);\n  for (int i = 0; i < n; i += 1) {\n    int c;\n    cin >> c;\n    vector<int> A(c);\n    for (int& x : A) cin >> x;\n    for (int j = 1; j < c; j += 1) {\n      G[A[j - 1]].insert(A[j]);\n      H[A[j]].insert(A[j - 1]);\n    }\n  }\n  map<int, int> mp;\n  for (int i = 1; i <= k; i += 1)\n    if (H[i].empty()) {\n      int x = 0;\n      for (int j = i; j;) {\n        x += 1;\n        if (H[j].size() > 1) {\n          x = -1;\n          break;\n        }\n        if (G[j].empty()) break;\n        if (G[j].size() > 1) {\n          x = -1;\n          break;\n        }\n        j = *G[j].begin();\n      }\n      if (x != -1) mp[x] += 1;\n    }\n  vector<LL> dp(m + 1);\n  dp[0] = 1;\n  for (int i = 1; i <= m; i += 1)\n    for (auto [x, y] : mp)\n      if (i >= x) dp[i] = (dp[i] + dp[i - x] * y) % mod;\n  cout << dp[m];\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int c = 300005;\nint n, m, k, db[c], el[c], kov[c], ki[c];\nvector<int> sz[c];\nbool rossz[c], v[c];\nvector<pair<int, long long> > lep;\nlong long dp[c], mod = 998244353;\nvoid dfs(int a) {\n  v[a] = true;\n  rossz[a] = 1;\n  for (auto x : sz[a]) {\n    if (!v[x]) {\n      dfs(x);\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin >> n >> m >> k;\n  for (int i = 1; i <= n; i++) {\n    int h, pr;\n    cin >> h;\n    cin >> pr;\n    ki[pr] = i;\n    for (int j = 1; j < h; j++) {\n      int x;\n      cin >> x;\n      sz[x].push_back(pr);\n      sz[pr].push_back(x);\n      if (ki[x] == i) {\n        rossz[x] = 1;\n      }\n      ki[x] = i;\n      if (kov[pr] && kov[pr] != x) {\n        rossz[pr] = 1;\n      }\n      if (el[x] && el[x] != pr) {\n        rossz[x] = 1;\n      }\n      kov[pr] = x;\n      el[x] = pr;\n      pr = x;\n    }\n  }\n  for (int i = 1; i <= k; i++) {\n    if (rossz[i] && !v[i]) {\n      dfs(i);\n    }\n  }\n  for (int i = 1; i <= k; i++) {\n    if (!rossz[i] && !el[i]) {\n      int len = 1, pos = i;\n      while (kov[pos]) {\n        pos = kov[pos];\n        len++;\n      }\n      db[len]++;\n    }\n  }\n  for (int i = 1; i <= k; i++) {\n    if (db[i]) {\n      lep.push_back({i, db[i]});\n    }\n  }\n  dp[0] = 1;\n  for (int i = 1; i <= m; i++) {\n    for (auto x : lep) {\n      if (i >= x.first) {\n        dp[i] += dp[i - x.first] * x.second;\n      }\n    }\n    dp[i] %= mod;\n  }\n  cout << dp[m] << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 3e5 + 5;\nconst int MOD = 998244353;\nvector<int> bio(MAX);\nvector<int> degree(MAX);\nvector<int> edges[MAX];\nint add(int x, int y) {\n  x += y;\n  while (x >= MOD) {\n    x -= MOD;\n  }\n  while (x < 0) {\n    x += MOD;\n  }\n  return x;\n}\nint mul(int x, int y) { return (x * 1ll * y) % MOD; }\nint dfs(int a) {\n  if (degree[a] > 1 || edges[a].size() > 1) return 0;\n  if (edges[a].size() == 0) return 1;\n  int z = dfs(edges[a][0]);\n  if (z == 0)\n    return 0;\n  else\n    return z + 1;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n, m, k;\n  cin >> n >> m >> k;\n  for (int i = 0; i < n; i++) {\n    int c, a, b;\n    cin >> c >> a;\n    c--;\n    while (c--) {\n      cin >> b;\n      if (edges[a].size() == 0 || edges[a][0] != b) {\n        edges[a].push_back(b);\n        degree[b]++;\n      }\n      a = b;\n    }\n  }\n  map<int, int> mp;\n  for (int i = 1; i <= k; i++) {\n    if (degree[i] == 0) {\n      int z = dfs(i);\n      if (z) mp[z]++;\n    }\n  }\n  vector<int> dp(m + 1);\n  dp[0] = 1;\n  for (int i = 1; i <= m; i++) {\n    for (auto e : mp) {\n      if (i < e.first) continue;\n      dp[i] = add(dp[i], mul(dp[i - e.first], e.second));\n    }\n  }\n  cout << dp[m] << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double EPS = 1e-12;\nconst int INF = 1e9 + 10;\ntemplate <typename T>\nusing MinPQ = priority_queue<T, vector<T>, greater<T>>;\nlong long GcdExt(long long a, long long b, long long& x, long long& y) {\n  if (b == 0) {\n    x = 1;\n    y = 0;\n    return a;\n  }\n  long long d = GcdExt(b, a % b, x, y);\n  long long tmp = y;\n  y = x - y * (a / b);\n  x = tmp;\n  return d;\n}\nstruct ModInt {\n  static constexpr int MOD = 998244353;\n  int v = 0;\n  ModInt() {}\n  ModInt(long long x) {\n    v = x % MOD;\n    if (v < 0) v += MOD;\n  }\n  friend inline bool operator==(const ModInt& l, const ModInt& r) {\n    return l.v == r.v;\n  }\n  friend inline bool operator!=(const ModInt& l, const ModInt& r) {\n    return !(l == r);\n  }\n  ModInt& operator+=(const ModInt& r) {\n    v += r.v;\n    if (v >= MOD) v -= MOD;\n    return *this;\n  }\n  ModInt& operator-=(const ModInt& r) {\n    v -= r.v;\n    if (v < 0) v += MOD;\n    return *this;\n  }\n  ModInt& operator*=(const ModInt& r) {\n    v = ((long long)v * r.v) % MOD;\n    return *this;\n  }\n  ModInt& operator/=(const ModInt& r) {\n    *this *= r.Inv();\n    return *this;\n  }\n  friend ModInt operator+(ModInt l, const ModInt& r) {\n    l += r;\n    return l;\n  }\n  friend ModInt operator-(ModInt l, const ModInt& r) {\n    l -= r;\n    return l;\n  }\n  friend ModInt operator*(ModInt l, const ModInt& r) {\n    l *= r;\n    return l;\n  }\n  friend ModInt operator/(ModInt l, const ModInt& r) {\n    l /= r;\n    return l;\n  }\n  ModInt Inv() const {\n    long long x, y;\n    assert(GcdExt(v, MOD, x, y) == 1);\n    return x;\n  }\n  ModInt Pow(long long n) {\n    if (!n) return 1;\n    ModInt r = Pow(n >> 1);\n    r *= r;\n    if (n & 1) r *= v;\n    return r;\n  }\n};\nstruct DisjointSet {\n  vector<int> f;\n  DisjointSet(int n = 0) { Reset(n); }\n  void Reset(int n) {\n    f.resize(n);\n    iota(f.begin(), f.end(), 0);\n  }\n  int Find(int u) {\n    if (f[u] == u) return u;\n    return f[u] = Find(f[u]);\n  }\n  bool Merge(int s, int t) {\n    s = Find(s);\n    t = Find(t);\n    if (s != t) {\n      f[s] = t;\n      return 1;\n    }\n    return 0;\n  }\n  void Add(int u) {\n    int nf = int((f).size());\n    if (u < nf) return;\n    f.resize(u + 1);\n    iota(f.begin() + nf, f.end(), nf);\n  }\n};\nstruct DirectedGraph {\n  int n;\n  vector<unordered_set<int>> adj;\n  DirectedGraph(int n = 0) { Reset(n); }\n  void Reset(int n) {\n    this->n = n;\n    adj.assign(n, {});\n  }\n  void AddEdge(int u, int v) { adj[u].insert(v); }\n  vector<int> TarjanScc(vector<int>& comp_id) {\n    comp_id.assign(n, -1);\n    vector<int> comp_size;\n    int dfsv = 0;\n    vector<int> dfs(n, -1);\n    vector<int> low(n);\n    vector<int> st;\n    vector<bool> in_st(n, 0);\n    const std::function<void(int)> Dfs = [&](int u) {\n      dfs[u] = dfsv++;\n      low[u] = dfs[u];\n      st.push_back(u);\n      in_st[u] = 1;\n      for (auto& v : (adj[u])) {\n        if (dfs[v] < 0) {\n          Dfs(v);\n          low[u] = min(low[u], low[v]);\n        } else if (in_st[v]) {\n          low[u] = min(low[u], dfs[v]);\n        }\n      }\n      if (low[u] == dfs[u]) {\n        int c = 0;\n        while (1) {\n          int v = st.back();\n          st.pop_back();\n          in_st[v] = 0;\n          comp_id[v] = int((comp_size).size());\n          ++c;\n          if (v == u) break;\n        }\n        comp_size.push_back(c);\n      }\n    };\n    for (int i = 0; i < n; i++)\n      if (dfs[i] < 0) {\n        Dfs(i);\n        assert(st.empty());\n      }\n    return comp_size;\n  }\n  vector<int> TopologicalSort() {\n    vector<char> vis(n, 0);\n    vector<int> ans;\n    ans.reserve(n);\n    const std::function<void(int)> Dfs = [&](int u) {\n      vis[u] = 1;\n      for (auto& v : (adj[u])) {\n        if (!vis[v]) Dfs(v);\n      }\n      ans.push_back(u);\n    };\n    for (int i = 0; i < n; ++i)\n      if (!vis[i]) Dfs(i);\n    reverse((ans).begin(), (ans).end());\n    return ans;\n  }\n};\nint n, m, k;\nvector<vector<int>> a;\nvector<int> all;\nvector<int> apos;\nvoid Solve() {\n  scanf(\"%d%d%d\", &n, &m, &k);\n  a.resize(n);\n  for (int i = 0; i < n; ++i) {\n    int c;\n    scanf(\"%d\", &c);\n    a[i].resize(c);\n    for (auto& x : (a[i])) scanf(\"%d\", &x);\n  }\n  DisjointSet ds(k + 1);\n  vector<char> good_ch(k + 1, 1);\n  {\n    for (int i = 0; i < n; ++i) {\n      for (auto& x : (a[i])) ds.Merge(a[i][0], x);\n    }\n    vector<int> cnt_ch(k + 1, 0);\n    for (int i = 0; i < n; ++i) {\n      for (auto& x : (a[i])) {\n        cnt_ch[x]++;\n      }\n      bool good = 1;\n      for (auto& x : (a[i])) {\n        if (cnt_ch[x] > 1) good = 0;\n        cnt_ch[x] = 0;\n      }\n      if (!good) good_ch[ds.Find(a[i][0])] = 0;\n    }\n  }\n  DirectedGraph g(k + 1), g_rev(k + 1);\n  for (int i = 0; i < n; ++i) {\n    if (!good_ch[ds.Find(a[i][0])]) continue;\n    for (int j = 1; j < int((a[i]).size()); ++j) {\n      ds.Merge(a[i][j - 1], a[i][j]);\n      g.AddEdge(a[i][j - 1], a[i][j]);\n      g_rev.AddEdge(a[i][j], a[i][j - 1]);\n    }\n  }\n  {\n    for (int i = 1; i <= k; ++i) {\n      if (int((g.adj[i]).size()) > 1 || int((g_rev.adj[i]).size()) > 1)\n        good_ch[ds.Find(i)] = 0;\n    }\n    vector<int> comp_id;\n    vector<int> comp_sizes = g.TarjanScc(comp_id);\n    for (int i = 1; i <= k; ++i)\n      if (comp_sizes[comp_id[i]] > 1) {\n        good_ch[ds.Find(i)] = 0;\n      }\n  }\n  vector<int> cnt_len(max(k, m) + 1, 0);\n  {\n    vector<int> top_order = g.TopologicalSort();\n    vector<char> vis(k + 1, 0);\n    vis[0] = 1;\n    for (auto& x : (top_order)) {\n      if (vis[x] || !good_ch[ds.Find(x)]) continue;\n      int u = x;\n      int len = 1;\n      vis[u] = 1;\n      while (!g.adj[u].empty()) {\n        int v = *g.adj[u].begin();\n        vis[v] = 1;\n        len++;\n        u = v;\n      }\n      42;\n      cnt_len[len]++;\n    }\n  }\n  vector<pair<int, int>> trans;\n  for (int i = 1; i <= m; ++i)\n    if (cnt_len[i] > 0) trans.emplace_back(i, cnt_len[i]);\n  vector<ModInt> f(m + 1);\n  f[0] = 1;\n  for (int i = 1; i <= m; ++i) {\n    f[i] = 0;\n    for (auto& p : (trans)) {\n      if (p.first > i) break;\n      f[i] += f[i - p.first] * p.second;\n    }\n  }\n  printf(\"%d\\n\", f[m].v);\n}\nint main() {\n  int t = 1;\n  for (int i = 1; i <= t; ++i) {\n    Solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 3e5 + 5, mod = 998244353;\nint t, vis[N], p[2 * N], n, m, K, cnt[N], dp[N], l, r, F, first[N], c[N];\nset<int> second[N];\nvector<int> a[N], V[N];\nvoid dfs(int u, int id) {\n  if (vis[u]) return;\n  vis[u] = 1;\n  while (second[u].size()) {\n    int x = *second[u].begin();\n    for (int i = 0; i < a[x].size(); i++) second[a[x][i]].erase(x);\n    int first = -1;\n    for (int j = 0; j < a[x].size(); j++) {\n      if (a[x][j] == u) first = j;\n    }\n    assert(first != -1);\n    for (int j = (int)a[x].size() - 1; j >= 0; j--) {\n      int d = a[x][j];\n      l = min(l, id + j - first);\n      r = max(r, id + j - first);\n      if (l <= 0) {\n        F = 1;\n      } else {\n        if (!p[id + j - first])\n          p[id + j - first] = d;\n        else if (p[id + j - first] != d) {\n          F = 1;\n        }\n      }\n      if (!vis[d]) {\n        dfs(d, id + j - first);\n      }\n    }\n  }\n}\nint main() {\n  cin >> n >> m >> K;\n  for (int i = 1; i <= n; i++) {\n    int c;\n    cin >> c;\n    while (c--) {\n      int x;\n      cin >> x;\n      a[i].push_back(x);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    int F = 0;\n    for (int j = 0; j < a[i].size(); j++) {\n      second[a[i][j]].insert(i);\n    }\n  }\n  for (int i = 1; i <= K; i++) {\n    if (!vis[i] && !first[i]) {\n      l = r = m + 1;\n      F = 0;\n      p[m + 1] = i;\n      dfs(i, m + 1);\n      for (int j = max(0, l); j <= r; j++) {\n        if (c[p[j]] && p[j]) F = 1;\n        c[p[j]]++;\n      }\n      for (int j = max(0, l); j <= r; j++) c[p[j]] = 0, p[j] = 0;\n      if (!(r - l + 1 > m || F)) cnt[r - l + 1]++;\n    }\n  }\n  dp[0] = 1;\n  vector<pair<int, int> > x;\n  for (int j = 1; j <= m; j++) {\n    if (cnt[j]) x.push_back({j, cnt[j]});\n  }\n  for (int i = 1; i <= m; i++) {\n    for (int j = 0; j < x.size(); j++)\n      if (i - x[j].first >= 0)\n        dp[i] =\n            (dp[i] + (long long)dp[i - x[j].first] * x[j].second % mod) % mod;\n  }\n  cout << endl;\n  cout << dp[m];\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 3e5 + 5;\nconst long long mod = 998244353;\nint n, m, k;\nint Pre[N], Suc[N];\nint cnt[N], nxt[N];\nbool CanId[N], CanVec[N], tVis[N];\nlong long dp[N << 1];\nvector<int> vec[N], Sons[N];\nint fa[N];\nint _Find(int u) { return u == fa[u] ? u : fa[u] = _Find(fa[u]); }\nvoid check(int Col) {\n  for (int now = Suc[Col]; now; now = Suc[now]) {\n    int fu = _Find(Pre[now]), fv = _Find(now);\n    if (fu == fv)\n      CanId[Pre[now]] = CanId[now] = 0;\n    else\n      fa[fu] = fv;\n  }\n}\nbool CheckCircle(int Col) {\n  if (tVis[Col]) return 1;\n  for (int now = Suc[Col]; now; now = Suc[now])\n    if (Col == now)\n      return 0;\n    else\n      tVis[now] = 1;\n  return 1;\n}\nbool CheckVec(int Id) {\n  bool ret = 1;\n  for (int i = 0; i < vec[Id].size(); i++)\n    if (tVis[vec[Id][i]]) {\n      ret = 0;\n      break;\n    } else\n      tVis[vec[Id][i]] = 1;\n  for (int i = 0; i < vec[Id].size(); i++) tVis[vec[Id][i]] = 0;\n  if (!ret) CanId[vec[Id][0]] = 0;\n  return ret;\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &k);\n  for (int i = 1; i <= k; i++) fa[i] = i, CanId[i] = CanVec[i] = 1;\n  for (int C, i = 1; i <= n; i++) {\n    scanf(\"%d\", &C);\n    for (int x; C--;) scanf(\"%d\", &x), vec[i].push_back(x);\n    CheckVec(i);\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j < vec[i].size(); j++) {\n      int Up = vec[i][j - 1], Down = vec[i][j];\n      if ((!Pre[Down] || Pre[Down] == Up) && (!Suc[Up] || Suc[Up] == Down)) {\n        Pre[Down] = Up;\n        Suc[Up] = Down;\n      } else\n        CanId[Up] = CanId[Down] = 0;\n    }\n  }\n  for (int i = 1; i <= k; i++)\n    if (!Pre[i]) check(i);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j < vec[i].size(); j++) {\n      int Up = vec[i][j - 1], Down = vec[i][j];\n      int fu = _Find(Up), fv = _Find(Down);\n      if (fu != fv) fa[fu] = fv;\n    }\n  for (int i = 1; i <= k; i++) _Find(i);\n  for (int i = 1; i <= k; i++) tVis[i] = 0;\n  for (int i = 1; i <= k; i++) Sons[fa[i]].push_back(i);\n  for (int i = 1; i <= k; i++)\n    if (!CheckCircle(i)) CanId[i] = 0;\n  for (int i = 1; i <= k; i++)\n    if (!CanId[i]) CanVec[fa[i]] = 0;\n  for (int i = 1; i <= k; i++)\n    if (CanVec[i] && Sons[i].size() > 0U) cnt[Sons[i].size()]++;\n  int tHead = 0;\n  for (int i = 1; i <= k; i++) {\n    if (cnt[i]) nxt[tHead] = i, tHead = i;\n  }\n  dp[0] = 1;\n  for (int i = 0; i <= m; i++) {\n    for (int j = nxt[0]; j; j = nxt[j]) {\n      (dp[i + j] += dp[i] * cnt[j]) %= mod;\n    }\n  }\n  printf(\"%lld\\n\", dp[m]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long dv = 998244353;\nlong long n, m, d, nn = 0, dsu[300069], cc[300069], ce[300069], dg[2][300069],\n                   cdg[2][300069], fq[300069], dp[300069], ex[300069];\nmap<long long, long long> ve[300069];\nlong long fd(long long x) {\n  if (dsu[x] != x) {\n    dsu[x] = fd(dsu[x]);\n  }\n  return dsu[x];\n}\nint main() {\n  long long i, j, ii, k, l, sz;\n  scanf(\"%lld%lld%lld\", &n, &m, &d);\n  for (i = 1; i <= d; i++) {\n    dsu[i] = i;\n    cc[i] = 1;\n  }\n  for (i = 0; i < n; i++) {\n    scanf(\"%lld\", &sz);\n    for (j = 0; j < sz; j++) {\n      scanf(\"%lld\", &k);\n      if (j && !ve[l][k]) {\n        ve[l][k] = 1;\n        if (fd(k) != fd(l)) {\n          cc[fd(l)] += cc[fd(k)];\n          ce[fd(l)] += ce[fd(k)];\n          for (ii = 0; ii < 2; ii++) {\n            cdg[ii][fd(l)] += cdg[ii][fd(k)];\n          }\n          dsu[fd(k)] = l;\n        }\n        ce[fd(k)]++;\n        for (ii = 0; ii < 2; ii++) {\n          cdg[ii][fd(k)] -= dg[ii][k] == 1;\n          dg[ii][k]++;\n          cdg[ii][fd(k)] += dg[ii][k] == 1;\n          swap(k, l);\n        }\n      }\n      l = k;\n    }\n  }\n  for (i = 1; i <= d; i++) {\n    if (fd(i) == i && ce[i] == cc[i] - 1 && cdg[0][i] == cc[i] - 1 &&\n        cdg[1][i] == cc[i] - 1) {\n      fq[cc[i]]++;\n    }\n  }\n  for (i = 1; i <= d; i++) {\n    if (fq[i]) {\n      nn++;\n      ex[nn] = i;\n    }\n  }\n  dp[0] = 1;\n  for (i = 1; i <= m; i++) {\n    for (j = 1; j <= nn; j++) {\n      if (i >= ex[j]) {\n        dp[i] = (dp[i] + dp[i - ex[j]] * fq[ex[j]]) % dv;\n      }\n    }\n  }\n  printf(\"%lld\\n\", dp[m]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 3e5 + 10, mod = 998244353;\nint n, m, k, a[N], fa[N], nxt[N], pre[N], tg[N], sz[N], ct[N], stk[N], f[N];\ninline int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\ninline void merge(int x, int y) {\n  x = find(x);\n  y = find(y);\n  if (x == y) {\n    tg[x] = 1;\n    return;\n  }\n  fa[x] = y;\n  sz[y] += sz[x];\n  tg[y] |= tg[x];\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &k);\n  for (int i = 1; i <= k; ++i) fa[i] = i, sz[i] = 1;\n  for (int i = 1, c; i <= n; ++i) {\n    scanf(\"%d\", &c);\n    for (int j = 1; j <= c; ++j) {\n      scanf(\"%d\", &a[j]);\n      if (j == 1) continue;\n      if (nxt[a[j - 1]] && nxt[a[j - 1]] != a[j])\n        tg[find(a[j - 1])] = tg[find(a[j])] = 1;\n      else if (pre[a[j]] && pre[a[j]] != a[j - 1])\n        tg[find(a[j - 1])] = tg[find(a[j])] = 1;\n      else if (!nxt[a[j - 1]])\n        nxt[a[j - 1]] = a[j], pre[a[j]] = a[j - 1], merge(a[j - 1], a[j]);\n    }\n  }\n  for (int i = 1; i <= k; ++i)\n    if (find(i) == i && !tg[i]) ct[sz[i]]++;\n  int top = 0;\n  for (int i = 1; i <= k; ++i)\n    if (ct[i]) stk[++top] = i;\n  f[0] = 1;\n  for (int i = 0; i <= m; ++i)\n    for (int j = 1; j <= top && i + stk[j] <= m; ++j)\n      f[i + stk[j]] = (f[i + stk[j]] + 1ll * f[i] * ct[stk[j]]) % mod;\n  printf(\"%d\\n\", f[m]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\nstring to_string(const string& s) { return '\"' + s + '\"'; }\nstring to_string(const char* s) { return to_string((string)s); }\nstring to_string(bool b) { return (b ? \"true\" : \"false\"); }\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto& x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" +\n         to_string(get<2>(p)) + \")\";\n}\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" +\n         to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a;\n    swap(a, m);\n    u -= t * v;\n    swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod())\n      v = static_cast<Type>(x);\n    else\n      v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const {\n    return static_cast<U>(value);\n  }\n  constexpr static Type mod() { return T::value; }\n  Modular& operator+=(const Modular& other) {\n    if ((value += other.value) >= mod()) value -= mod();\n    return *this;\n  }\n  Modular& operator-=(const Modular& other) {\n    if ((value -= other.value) < 0) value += mod();\n    return *this;\n  }\n  template <typename U>\n  Modular& operator+=(const U& other) {\n    return *this += Modular(other);\n  }\n  template <typename U>\n  Modular& operator-=(const U& other) {\n    return *this -= Modular(other);\n  }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) {\n    Modular result(*this);\n    *this += 1;\n    return result;\n  }\n  Modular operator--(int) {\n    Modular result(*this);\n    *this -= 1;\n    return result;\n  }\n  Modular operator-() const { return Modular(-value); }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value,\n                     Modular>::type&\n  operator*=(const Modular& rhs) {\n    value = normalize(static_cast<int64_t>(value) *\n                      static_cast<int64_t>(rhs.value));\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value,\n                     Modular>::type&\n  operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) *\n                                         rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value,\n                     Modular>::type&\n  operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n  Modular& operator/=(const Modular& other) {\n    return *this *= Modular(inverse(other.value, mod()));\n  }\n  friend const Type& abs(const Modular& x) { return x.value; }\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\ntemplate <typename T>\nbool operator==(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return lhs.value == rhs.value;\n}\ntemplate <typename T, typename U>\nbool operator==(const Modular<T>& lhs, U rhs) {\n  return lhs == Modular<T>(rhs);\n}\ntemplate <typename T, typename U>\nbool operator==(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) == rhs;\n}\ntemplate <typename T>\nbool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T, typename U>\nbool operator!=(const Modular<T>& lhs, U rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T, typename U>\nbool operator!=(U lhs, const Modular<T>& rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T>\nbool operator<(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return lhs.value < rhs.value;\n}\ntemplate <typename T>\nModular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator+(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator+(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T>\nModular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator-(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator-(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T>\nModular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator*(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator*(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T>\nModular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator/(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator/(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, k;\n  cin >> n >> m >> k;\n  vector<vector<int>> g(k);\n  vector<vector<int>> gr(k);\n  for (int i = 0; i < n; i++) {\n    int len;\n    cin >> len;\n    int last;\n    cin >> last;\n    --last;\n    for (int j = 1; j < len; j++) {\n      int cur;\n      cin >> cur;\n      --cur;\n      g[last].push_back(cur);\n      gr[cur].push_back(last);\n      last = cur;\n    }\n  }\n  for (int i = 0; i < k; i++) {\n    sort(g[i].begin(), g[i].end());\n    g[i].resize(unique(g[i].begin(), g[i].end()) - g[i].begin());\n    sort(gr[i].begin(), gr[i].end());\n    gr[i].resize(unique(gr[i].begin(), gr[i].end()) - gr[i].begin());\n  }\n  map<int, int> mp;\n  vector<bool> was(k, false);\n  vector<bool> used(k, false);\n  for (int start = 0; start < k; start++) {\n    if (was[start]) {\n      continue;\n    }\n    vector<int> que(1, start);\n    was[start] = true;\n    for (int b = 0; b < (int)que.size(); b++) {\n      for (int j : g[que[b]]) {\n        if (!was[j]) {\n          que.push_back(j);\n          was[j] = true;\n        }\n      }\n      for (int j : gr[que[b]]) {\n        if (!was[j]) {\n          que.push_back(j);\n          was[j] = true;\n        }\n      }\n    }\n    int edges = 0;\n    for (int i : que) {\n      edges += (int)g[i].size();\n    }\n    if (edges != (int)que.size() - 1) {\n      continue;\n    }\n    int root = -1;\n    for (int i : que) {\n      if (gr[i].empty()) {\n        root = i;\n        break;\n      }\n    }\n    assert(root != -1);\n    vector<int> seq(1, root);\n    used[root] = true;\n    while (true) {\n      int nxt = -1;\n      for (int i : g[seq.back()]) {\n        if (!used[i]) {\n          nxt = i;\n          break;\n        }\n      }\n      if (nxt == -1) {\n        break;\n      }\n      seq.push_back(nxt);\n      used[nxt] = true;\n    }\n    if (seq.size() == que.size()) {\n      mp[(int)seq.size()] += 1;\n    }\n  }\n  vector<pair<int, int>> ps;\n  for (auto& p : mp) {\n    ps.push_back(p);\n  }\n  vector<Mint> dp(m + 1);\n  dp[0] = 1;\n  for (int i = 1; i <= m; i++) {\n    for (auto& p : ps) {\n      if (i >= p.first) {\n        dp[i] += dp[i - p.first] * p.second;\n      }\n    }\n  }\n  cout << dp[m] << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 998244353;\nlong long n, m, t, nn = 0, vis[300010], cnt[300010], dp[300010], extr = 0;\nvector<long long> a[300010], g[300010], gg[300010], tmpa[300010], pth;\nvector<pair<long long, long long> > v;\nset<long long> st;\nbool bada[300010], badc[300010];\nmap<long long, long long> s;\nvoid dfs(long long pos, long long ty) {\n  if ((ty == 0 && bada[pos]) || (ty == 1 && badc[pos])) return;\n  if (ty == 0) {\n    bada[pos] = true;\n    for (int i = 0; i < a[pos].size(); ++i) dfs(a[pos][i], 1);\n  } else {\n    badc[pos] = true;\n    for (int i = 0; i < g[pos].size(); ++i) dfs(g[pos][i], 0);\n  }\n}\nbool dfs2(long long node, long long strPos, long long sPos) {\n  long long stPos = sPos - strPos;\n  if (bada[node]) return false;\n  if (vis[node] > -1e18) return vis[node] == stPos;\n  vis[node] = stPos;\n  pth.push_back(node);\n  vector<long long> trans;\n  trans.clear();\n  for (int i = 0; i < a[node].size(); ++i) {\n    if (s.find(stPos + i) != s.end()) {\n      if (s[stPos + i] != a[node][i]) return false;\n    } else {\n      trans.push_back(i);\n      s[stPos + i] = a[node][i];\n    }\n  }\n  for (int i = 0; i < trans.size(); ++i) {\n    long long val = a[node][trans[i]];\n    for (int j = 0; j < g[val].size(); ++j)\n      if (!dfs2(g[val][j], gg[val][j], stPos + trans[i])) return false;\n  }\n  return true;\n}\nint main() {\n  cin >> n >> m >> t;\n  long long x, y;\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%lld\", &x);\n    for (int j = 0; j < x; ++j) {\n      scanf(\"%lld\", &y);\n      a[i].push_back(y);\n      g[y].push_back(i);\n      st.insert(y);\n    }\n  }\n  for (int i = 1; i <= t; ++i)\n    if (st.find(i) == st.end()) ++extr;\n  for (int i = 0; i < n; ++i)\n    if (!bada[i]) {\n      st.clear();\n      for (int j = 0; j < a[i].size(); ++j) st.insert(a[i][j]);\n      if (st.size() < a[i].size())\n        for (auto it : st)\n          if (!badc[it]) dfs(it, 1);\n    }\n  for (int i = 0; i < n; ++i)\n    if (!bada[i]) tmpa[nn++] = a[i];\n  n = nn;\n  for (int i = 0; i < n; ++i) a[i] = tmpa[i];\n  for (int i = 0; i < t + 5; ++i) g[i].clear();\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < a[i].size(); ++j)\n      g[a[i][j]].push_back(i), gg[a[i][j]].push_back(j);\n  for (int i = 0; i < n + 5; ++i) vis[i] = -1e18, bada[i] = false;\n  for (int i = 0; i < n; ++i)\n    if (vis[i] == -1e18) {\n      s.clear();\n      pth.clear();\n      bool stat = dfs2(i, 0, 0);\n      if (!stat)\n        for (int j = 0; j < pth.size(); ++j) bada[pth[j]] = true;\n      else\n        ++cnt[(s.rbegin()->first) - (s.begin()->first) + 1];\n    }\n  for (int i = 1; i <= m; ++i)\n    if (cnt[i] > 0) v.push_back(make_pair(i, cnt[i]));\n  dp[0] = 1;\n  for (int i = 1; i <= m; ++i) {\n    (dp[i] += dp[i - 1] * extr) %= MOD;\n    for (int j = 0; j < v.size(); ++j)\n      if (i - v[j].first >= 0)\n        (dp[i] += dp[i - v[j].first] * v[j].second) %= MOD;\n      else\n        break;\n  }\n  cout << dp[m] << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 300005;\nconst int Mod = 998244353;\nvector<int> pre[MAXN], nxt[MAXN];\nbool vis[MAXN];\nvoid dfs(int u, int las, int& ok, int& siz) {\n  vis[u] = 1;\n  ++siz;\n  ok &= (pre[u].size() <= 1u);\n  ok &= (nxt[u].size() <= 1u);\n  for (auto& v : pre[u]) {\n    if (v == las) continue;\n    if (vis[v]) {\n      ok = 0;\n      continue;\n    }\n    dfs(v, u, ok, siz);\n  }\n  for (auto& v : nxt[u]) {\n    if (v == las) continue;\n    if (vis[v]) {\n      ok = 0;\n      continue;\n    }\n    dfs(v, u, ok, siz);\n  }\n}\nint main() {\n  int n, m, k;\n  scanf(\"%d%d%d\", &n, &m, &k);\n  for (int i = 0; i < n; i++) {\n    int c;\n    scanf(\"%d\", &c);\n    vector<int> a(c);\n    for (int j = 0; j < c; j++) scanf(\"%d\", &a[j]);\n    for (int j = 0; j + 1 < c; j++) {\n      nxt[a[j]].push_back(a[j + 1]);\n      pre[a[j + 1]].push_back(a[j]);\n    }\n  }\n  for (int i = 1; i <= k; i++) {\n    sort(nxt[i].begin(), nxt[i].end());\n    nxt[i].erase(unique(nxt[i].begin(), nxt[i].end()), nxt[i].end());\n    sort(pre[i].begin(), pre[i].end());\n    pre[i].erase(unique(pre[i].begin(), pre[i].end()), pre[i].end());\n  }\n  map<int, int> mp;\n  for (int i = 1; i <= k; i++) {\n    if (vis[i]) continue;\n    int ok = 1, siz = 0;\n    dfs(i, 0, ok, siz);\n    if (ok) mp[siz]++;\n  }\n  static int dp[MAXN];\n  for (int i = (dp[0] = 1); i <= m; i++)\n    for (auto& t : mp) {\n      int j = t.first, c = t.second;\n      if (j <= i) dp[i] = (dp[i] + 1LL * c * dp[i - j]) % Mod;\n    }\n  printf(\"%d\\n\", dp[m]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 300005, mod = 998244353;\nint n, m, k, mx;\nint in[maxn], out[maxn], f[maxn], tot[maxn], q[maxn], tmp[maxn];\nvector<int> t, v[maxn], g[maxn];\nmap<int, int> mp[maxn];\nvoid dfs(int x, int d) {\n  if (in[x] > 1 || out[x] > 1) return;\n  if (out[x] == 0) tot[d]++, mx = max(mx, d);\n  for (int i = 0; i < g[x].size(); i++) dfs(g[x][i], d + 1);\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &k);\n  for (int i = 1, c; i <= n; i++) {\n    scanf(\"%d\", &c), v[i].resize(c);\n    for (int j = 0; j < c; j++) {\n      scanf(\"%d\", &v[i][j]);\n      if (j > 0 && mp[v[i][j - 1]][v[i][j]] == 0)\n        mp[v[i][j - 1]][v[i][j]] = 1, g[v[i][j - 1]].push_back(v[i][j]),\n                    out[v[i][j - 1]]++, in[v[i][j]]++;\n    }\n  }\n  for (int i = 1; i <= k; i++)\n    if (in[i] == 0) dfs(i, 1);\n  f[0] = 1;\n  for (int i = 1; i <= mx; i++)\n    if (tot[i]) t.push_back(i);\n  for (int i = 1; i <= m; i++)\n    for (int j = 0; j < t.size(); j++)\n      if (i >= t[j]) f[i] = (f[i] + 1ll * f[i - t[j]] * tot[t[j]]) % mod;\n  printf(\"%d\\n\", f[m]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\nstring to_string(const string& s) { return '\"' + s + '\"'; }\nstring to_string(const char* s) { return to_string((string)s); }\nstring to_string(bool b) { return (b ? \"true\" : \"false\"); }\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto& x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" +\n         to_string(get<2>(p)) + \")\";\n}\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" +\n         to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a;\n    swap(a, m);\n    u -= t * v;\n    swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod())\n      v = static_cast<Type>(x);\n    else\n      v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const {\n    return static_cast<U>(value);\n  }\n  constexpr static Type mod() { return T::value; }\n  Modular& operator+=(const Modular& other) {\n    if ((value += other.value) >= mod()) value -= mod();\n    return *this;\n  }\n  Modular& operator-=(const Modular& other) {\n    if ((value -= other.value) < 0) value += mod();\n    return *this;\n  }\n  template <typename U>\n  Modular& operator+=(const U& other) {\n    return *this += Modular(other);\n  }\n  template <typename U>\n  Modular& operator-=(const U& other) {\n    return *this -= Modular(other);\n  }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) {\n    Modular result(*this);\n    *this += 1;\n    return result;\n  }\n  Modular operator--(int) {\n    Modular result(*this);\n    *this -= 1;\n    return result;\n  }\n  Modular operator-() const { return Modular(-value); }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value,\n                     Modular>::type&\n  operator*=(const Modular& rhs) {\n    value = normalize(static_cast<int64_t>(value) *\n                      static_cast<int64_t>(rhs.value));\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value,\n                     Modular>::type&\n  operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) *\n                                         rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value,\n                     Modular>::type&\n  operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n  Modular& operator/=(const Modular& other) {\n    return *this *= Modular(inverse(other.value, mod()));\n  }\n  friend const Type& abs(const Modular& x) { return x.value; }\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\ntemplate <typename T>\nbool operator==(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return lhs.value == rhs.value;\n}\ntemplate <typename T, typename U>\nbool operator==(const Modular<T>& lhs, U rhs) {\n  return lhs == Modular<T>(rhs);\n}\ntemplate <typename T, typename U>\nbool operator==(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) == rhs;\n}\ntemplate <typename T>\nbool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T, typename U>\nbool operator!=(const Modular<T>& lhs, U rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T, typename U>\nbool operator!=(U lhs, const Modular<T>& rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T>\nbool operator<(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return lhs.value < rhs.value;\n}\ntemplate <typename T>\nModular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator+(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator+(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T>\nModular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator-(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator-(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T>\nModular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator*(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator*(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T>\nModular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator/(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator/(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\nvoid hello() {}\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, k;\n  cin >> n >> m >> k;\n  vector<vector<int>> g(k);\n  vector<vector<int>> gr(k);\n  for (int i = 0; i < n; i++) {\n    int len;\n    cin >> len;\n    int last;\n    cin >> last;\n    --last;\n    for (int j = 1; j < len; j++) {\n      int cur;\n      cin >> cur;\n      --cur;\n      g[last].push_back(cur);\n      gr[cur].push_back(last);\n      last = cur;\n    }\n  }\n  for (int i = 0; i < k; i++) {\n    sort(g[i].begin(), g[i].end());\n    g[i].resize(unique(g[i].begin(), g[i].end()) - g[i].begin());\n    sort(gr[i].begin(), gr[i].end());\n    gr[i].resize(unique(gr[i].begin(), gr[i].end()) - gr[i].begin());\n  }\n  map<int, int> mp;\n  vector<bool> was(k, false);\n  vector<bool> used(k, false);\n  for (int start = 0; start < k; start++) {\n    if (was[start]) {\n      continue;\n    }\n    vector<int> que(1, start);\n    was[start] = true;\n    for (int b = 0; b < (int)que.size(); b++) {\n      for (int j : g[que[b]]) {\n        if (!was[j]) {\n          que.push_back(j);\n          was[j] = true;\n        }\n      }\n      for (int j : gr[que[b]]) {\n        if (!was[j]) {\n          que.push_back(j);\n          was[j] = true;\n        }\n      }\n    }\n    int edges = 0;\n    for (int i : que) {\n      edges += (int)g[i].size();\n    }\n    if (edges != (int)que.size() - 1) {\n      continue;\n    }\n    int root = -1;\n    for (int i : que) {\n      if (gr[i].empty()) {\n        root = i;\n        break;\n      }\n    }\n    assert(root != -1);\n    vector<int> seq(1, root);\n    used[root] = true;\n    while (true) {\n      int nxt = -1;\n      for (int i : g[seq.back()]) {\n        if (!used[i]) {\n          nxt = i;\n          break;\n        }\n      }\n      if (nxt == -1) {\n        break;\n      }\n      seq.push_back(nxt);\n      used[nxt] = true;\n    }\n    if (seq.size() == que.size()) {\n      mp[(int)seq.size()] += 1;\n    }\n  }\n  vector<pair<int, int>> ps;\n  for (auto& p : mp) {\n    ps.push_back(p);\n  }\n  vector<Mint> dp(m + 1);\n  dp[0] = 1;\n  for (int i = 1; i <= m; i++) {\n    for (auto& p : ps) {\n      if (i >= p.first) {\n        dp[i] += dp[i - p.first] * p.second;\n      }\n    }\n  }\n  cout << dp[m] << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937 ran(time(0));\nlong long mod = 998244353;\nlong long gcd(long long a, long long b) {\n  if (!b) return a;\n  return gcd(b, a % b);\n}\nlong long Bpow(long long a, long long b) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) {\n      ans *= a;\n      ans %= mod;\n    }\n    a = a * a % mod;\n    b >>= 1;\n  }\n  return ans;\n}\nbool F(vector<long long>& a, vector<long long>& b, long long c = 0) {\n  bool f = true;\n  for (long long i = 0; i < b.size() && c + i < a.size(); i++) {\n    f &= (a[c + i] == b[i]);\n  }\n  return f;\n}\nvector<long long> g(3e5 + 7, -1);\nvector<long long> w(3e5 + 7);\nvector<long long> len(3e5 + 7);\nvector<long long> z(3e5 + 7);\nvector<long long> b(3e5 + 7);\nvector<long long> c;\nvector<vector<long long>> a(3e5 + 7);\nvector<long long> mn(3e5 + 7);\nlong long dfs(long long v, long long now) {\n  if (z[v]) return -1;\n  if (g[v] == -1) return now;\n  return dfs(g[v], now + w[v]);\n}\nlong long pl(long long a, long long b) {\n  long long ans = a + b;\n  if (ans >= mod) ans -= mod;\n  return ans;\n}\nint32_t main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  long long n, m, k;\n  cin >> n >> m >> k;\n  vector<long long> h(k + 1);\n  vector<vector<long long>> fir(k + 1);\n  bool f = false;\n  set<long long> st;\n  vector<vector<pair<long long, long long>>> ow(k + 1);\n  for (long long i = 0; i < n; i++) {\n    long long c;\n    cin >> c;\n    a[i].resize(c);\n    for (long long j = 0; j < c; j++) {\n      cin >> a[i][j];\n      h[a[i][j]]++;\n      if (h[a[i][j]] > 1) {\n        z[i]++;\n      }\n      st.insert(a[i][j]);\n      ow[a[i][j]].push_back({i, j});\n    }\n    fir[a[i][0]].push_back(i);\n    for (long long j = 0; j < c; j++) {\n      h[a[i][j]]--;\n    }\n  }\n  long long kol = k - st.size();\n  for (long long i = 1; i < k + 1; i++) {\n    bool fs = true;\n    if (ow[i].empty()) {\n      continue;\n    }\n    set<long long> stl, str;\n    for (auto& u : ow[i]) {\n      if (u.second) stl.insert(a[u.first][u.second - 1]);\n      if (u.second + 1 < a[u.first].size())\n        str.insert(a[u.first][u.second + 1]);\n    }\n    if (stl.size() > 1 || str.size() > 1) {\n      for (auto& u : ow[i]) {\n        z[u.first]++;\n      }\n    }\n  }\n  vector<long long> fi(k + 1, -1);\n  for (long long i = 1; i < k + 1; i++) {\n    vector<long long> v;\n    long long ind;\n    for (long long j = 0; j < fir[i].size(); j++) {\n      if (v.size() < a[fir[i][j]].size()) {\n        v = a[fir[i][j]];\n        ind = fir[i][j];\n      }\n    }\n    for (long long j = 0; j < fir[i].size(); j++) {\n      if (!F(v, a[fir[i][j]])) {\n        z[ind]++;\n      }\n      if (fir[i][j] != ind) {\n        b[fir[i][j]]++;\n      }\n    }\n    if (v.empty()) continue;\n    fi[i] = ind;\n  }\n  for (long long i = 0; i < n; i++) {\n    if (z[i]) {\n      for (long long j = 1; j < a[i].size(); j++) {\n        if (fi[a[i][j]] != -1) {\n          b[fi[a[i][j]]]++;\n          z[fi[a[i][j]]]++;\n        }\n      }\n    }\n    for (long long j = 1; j < a[i].size(); j++) {\n      if (fi[a[i][j]] != -1) {\n        if (!F(a[i], a[fi[a[i][j]]], j)) {\n          z[i]++;\n        }\n        b[fi[a[i][j]]]++;\n        if (a[fi[a[i][j]]].size() > a[i].size() - j) {\n          g[i] = fi[a[i][j]];\n          w[i] = a[fi[a[i][j]]].size() - (a[i].size() - j);\n          break;\n        }\n        b[fi[a[i][j]]]++;\n      }\n    }\n  }\n  vector<long long> um(3e5 + 7);\n  vector<long long> v;\n  for (long long i = 0; i < n; i++) {\n    if (!b[i] && !z[i]) {\n      long long val = dfs(i, a[i].size());\n      c.clear();\n      if (val == -1) continue;\n      um[val]++;\n      if (um[val] == 1) {\n        v.push_back(val);\n      }\n    }\n  }\n  vector<long long> dp(m + 1);\n  dp[0] = 1;\n  for (long long i = 1; i < m + 1; i++) {\n    dp[i] = dp[i - 1] * kol % mod;\n    for (auto& u : v) {\n      if (i - u < 0) continue;\n      dp[i] = pl(dp[i], dp[i - u] * um[u] % mod);\n    }\n  }\n  cout << dp[m];\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 3 * 1e5 + 100;\nlong long n, m, k, vi[N], l[N], r[N], rev[N << 2], len;\nlong long dp[N], g[N], pr[N];\nlong long w, b[N], c[N], Inv[N];\npair<long long, long long> t[N];\nvector<long long> A[N], p[N], f[25];\ninline void add(long long &a, long long b) {\n  a = ((a + b >= 998244353) ? a + b - 998244353 : a + b);\n}\ninline void del(long long &a, long long b) {\n  a = ((a - b < 0) ? a - b + 998244353 : a - b);\n}\ninline void mul(long long &a, long long b) { a = a * b % 998244353; }\ninline long long m_pow(long long a, long long b) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) mul(ans, a);\n    b >>= 1;\n    mul(a, a);\n  }\n  return ans;\n}\ninline long long read() {\n  long long f = 1, x = 0;\n  char s = getchar();\n  while (s < '0' || s > '9') {\n    if (s == '-') f = -1;\n    s = getchar();\n  }\n  while (s >= '0' && s <= '9') {\n    x = x * 10 + s - '0';\n    s = getchar();\n  }\n  return x * f;\n}\nvoid prework() {\n  long long d = 20;\n  for (long long i = 1; i <= d; i++) {\n    f[i].resize(1 << i);\n    f[i][0] = 1;\n    f[i][1] = m_pow(3, (998244353 - 1) >> i);\n    for (long long j = 2; j < (1 << i); j++)\n      f[i][j] = f[i][j - 1] * f[i][1] % 998244353;\n  }\n}\ninline void change(long long len) {\n  for (long long i = 0; i < len; i++) {\n    rev[i] = rev[i >> 1] >> 1;\n    if (i & 1) rev[i] |= (len >> 1);\n  }\n}\ninline void DFT(vector<long long> &y, long long len, long long v) {\n  for (long long i = 0; i < len; i++)\n    if (i < rev[i]) swap(y[i], y[rev[i]]);\n  for (long long i = 1, d = 1; i < len; i <<= 1, d++) {\n    for (long long j = 0; j < len; j += (i << 1)) {\n      long long *W = &f[d][0], a, b;\n      for (long long k = j; k < j + i; k++) {\n        a = y[k], b = y[k + i] * (*W++) % 998244353;\n        y[k] = y[k + i] = a;\n        add(y[k], b);\n        del(y[k + i], b);\n      }\n    }\n  }\n  if (v == -1) {\n    reverse(y.begin() + 1, y.end());\n    long long invlen = m_pow(len, 998244353 - 2);\n    for (long long i = 0; i < len; i++) mul(y[i], invlen);\n  }\n}\nvector<long long> operator*(vector<long long> a, vector<long long> b) {\n  if (a.empty()) return b;\n  if (b.empty()) return a;\n  long long n = (long long)a.size(), m = (long long)b.size();\n  len = 1;\n  while (len < n + m) len <<= 1;\n  change(len);\n  a.resize(len);\n  b.resize(len);\n  DFT(a, len, 1);\n  DFT(b, len, 1);\n  for (long long i = 0; i < len; i++) mul(a[i], b[i]);\n  DFT(a, len, -1);\n  a.resize(n + m - 1);\n  return a;\n}\nvoid solve(long long l, long long r) {\n  if (l == r) {\n    if (l == 0) dp[l] = 1;\n    return;\n  }\n  long long mid = (l + r) >> 1;\n  solve(l, mid);\n  vector<long long> A;\n  A = vector<long long>(dp + l, dp + mid + 1) *\n      vector<long long>(g, g + r - l + 1);\n  for (long long i = mid + 1; i <= r; i++) add(dp[i], A[i - l]);\n  solve(mid + 1, r);\n}\nvoid del(long long id) {\n  vi[id] = 1;\n  for (long long i : A[id])\n    if (t[i].first != -1) {\n      vi[t[i].first] = 1;\n      t[i] = make_pair(-1, -1);\n    }\n}\nvoid check_twice(long long id) {\n  static long long cnt[N];\n  for (long long i : A[id]) cnt[i]++;\n  bool bl = 1;\n  for (long long i : A[id])\n    if (cnt[i] > 1) bl = 0;\n  if (!bl) del(id);\n  for (long long i : A[id]) cnt[i] = 0;\n}\nvoid upd(long long x) {\n  if (t[x].first <= 0) return;\n  if (vi[t[x].first]) t[x] = make_pair(-1, -1);\n}\nvoid merge(long long &x, long long &y) {\n  if ((long long)p[x].size() < (long long)p[y].size()) {\n    l[y] = l[y] - (long long)p[x].size();\n    for (long long i : p[x]) t[i] = make_pair(y, t[i].second - l[x] + l[y]);\n    p[y].insert(p[y].end(), p[x].begin(), p[x].end());\n    vi[x] = 1;\n    x = y;\n  } else {\n    r[x] = r[x] + (long long)p[y].size();\n    for (long long i : p[y]) t[i] = make_pair(x, r[x] - (r[y] - t[i].second));\n    p[x].insert(p[x].begin(), p[y].begin(), p[y].end());\n    vi[y] = 1;\n    y = x;\n  }\n}\nbool cmp(long long a, long long b) { return t[a].second < t[b].second; }\nbool cmp1(long long a, long long b) {\n  return (long long)A[a].size() > (long long)A[b].size();\n}\nsigned main() {\n  prework();\n  n = read();\n  m = read();\n  k = read();\n  for (long long i = 1; i <= n; i++) {\n    long long c = read();\n    A[i].resize(c);\n    for (long long &j : A[i]) j = read();\n    check_twice(i);\n  }\n  for (long long i = 1; i <= n; i++) pr[i] = i;\n  sort(pr + 1, pr + 1 + n, cmp1);\n  for (long long s = 1; s <= n; s++) {\n    long long i = pr[s];\n    if (vi[i]) continue;\n    bool bl = 1;\n    for (long long j : A[i]) {\n      upd(j);\n      if (t[j].first == -1) bl = 0;\n    }\n    if (!bl) {\n      del(i);\n      continue;\n    }\n    w = 0;\n    for (long long j = 0; j < (long long)A[i].size();) {\n      long long k = j;\n      while (k < (long long)A[i].size() && t[A[i][j]].first == t[A[i][k]].first)\n        k++;\n      b[++w] = k - j;\n      c[w] = t[A[i][j]].first;\n      j = k;\n    }\n    bl = 1;\n    for (long long j = 1, s = 0; j <= w; s += b[j++])\n      if (c[j] != 0) {\n        for (long long k = s; k < s + b[j] - 1; k++)\n          if (t[A[i][k]].second + 1 != t[A[i][k + 1]].second) bl = 0;\n        long long x = A[i][s], y = A[i][s + b[j] - 1];\n        if (t[x].second != l[c[j]] && t[y].second != r[c[j]] && w > 1) bl = 0;\n        if (t[x].second == l[c[j]] && j != w) bl = 0;\n        if (t[y].second == r[c[j]] && j != 1) bl = 0;\n      }\n    if (w > 3 || (w == 3 && c[2] != 0) || !bl) {\n      del(i);\n      continue;\n    }\n    for (long long j = 1, s = 0; j <= w; s += b[j++])\n      if (c[j] == 0) {\n        for (long long k = s; k < s + b[j]; k++)\n          t[A[i][k]] = make_pair(i, r[i]++), p[i].push_back(A[i][k]);\n        c[j] = i;\n      }\n    r[i]--;\n    for (long long i = 1; i < w; i++) merge(c[i], c[i + 1]);\n  }\n  for (long long i = 1; i <= n; i++)\n    if (!vi[i] && !p[i].empty()) {\n      g[(long long)p[i].size()]++;\n    }\n  long long ret = 0;\n  for (long long i = 1; i <= k; i++)\n    if (t[i].first == 0) ret++;\n  g[1] += ret;\n  solve(0, m);\n  printf(\"%lld\\n\", dp[m]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 3e5 + 10, mod = 998244353;\nint n, m, K, fa[N], sz[N], pre[N], nex[N], a[N], b[N], tot;\nint A[N], B[N], C[N], f[N];\nbool vis[N], tag[N];\nint find_(int x) { return fa[x] == x ? x : fa[x] = find_(fa[x]); }\nvoid merge_(int u, int v) {\n  u = find_(u), v = find_(v);\n  if (u == v) return;\n  if (sz[u] < sz[v]) swap(u, v);\n  fa[v] = u, sz[u] += sz[v];\n}\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &K);\n  for (int i = 1; i <= K; i++) fa[i] = i, sz[i] = 1;\n  for (int i = 1, c; i <= n; i++) {\n    scanf(\"%d\", &c);\n    for (int j = 1; j <= c; j++) {\n      scanf(\"%d\", &a[j]);\n      merge_(a[j], a[1]);\n      if (b[a[j]])\n        vis[a[j]] = 1;\n      else\n        b[a[j]] = 1;\n      if (j > 1) {\n        if (pre[a[j]] && pre[a[j]] != a[j - 1])\n          vis[a[j]] = 1;\n        else\n          pre[a[j]] = a[j - 1];\n        if (nex[a[j - 1]] && nex[a[j - 1]] != a[j])\n          vis[a[j - 1]] = 1;\n        else\n          nex[a[j - 1]] = a[j];\n      }\n    }\n    for (int j = 1; j <= c; j++) b[a[j]] = 0;\n  }\n  for (int i = 1; i <= K; i++)\n    vis[find_(i)] |= vis[i], tag[find_(i)] |= !nex[i];\n  for (int i = 1; i <= K; i++)\n    if (fa[i] == i && !vis[i] && tag[i]) {\n      if (!A[sz[i]]) A[sz[i]] = ++tot, B[tot] = sz[i];\n      C[A[sz[i]]]++;\n    }\n  f[0] = 1;\n  for (int i = 1; i <= m; i++)\n    for (int j = 1; j <= tot; j++)\n      if (B[j] <= i) f[i] = (f[i] + 1ll * f[i - B[j]] * C[j]) % mod;\n  printf(\"%d\\n\", (f[m] % mod + mod) % mod);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <class t>\ninline void read(t &s) {\n  s = 0;\n  register long long f = 1;\n  register char c = getchar();\n  while (!isdigit(c)) {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (isdigit(c)) s = (s << 3) + (s << 1) + (c ^ 48), c = getchar();\n  ;\n  s *= f;\n}\ntemplate <class t, class... A>\ninline void read(t &x, A &...a) {\n  read(x);\n  read(a...);\n}\ntemplate <class t>\ninline void write(t x) {\n  if (x < 0) putchar('-'), x = -x;\n  static long long buf[21], top = 0;\n  while (x) buf[++top] = x % 10, x /= 10;\n  if (!top) buf[++top] = 0;\n  while (top) putchar(buf[top--] ^ '0');\n}\ninline void setIn(std::string s) {\n  freopen(s.c_str(), \"r\", stdin);\n  return;\n}\ninline void setOut(std::string s) {\n  freopen(s.c_str(), \"w\", stdout);\n  return;\n}\ninline void setIO(std::string s = \"\") {\n  setIn(s + \".in\");\n  setOut(s + \".out\");\n  return;\n}\ntemplate <class t>\ninline bool ckmin(t &x, t y) {\n  if (x > y) {\n    x = y;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class t>\ninline bool ckmax(t &x, t y) {\n  if (x < y) {\n    x = y;\n    return 1;\n  }\n  return 0;\n}\ninline long long lowbit(long long x) { return x & (-x); }\nconst long long MaxN = 3e5 + 50;\nconst long long p = 998244353;\nstd::map<long long, long long> F[MaxN];\nlong long n, m, K;\nlong long f[MaxN], ideg[MaxN], odeg[MaxN];\nstd::vector<long long> nd[MaxN];\ninline long long getf(long long x) { return f[x] == x ? x : f[x] = getf(f[x]); }\ninline void merge(long long x, long long y) {\n  long long a = getf(x), b = getf(y);\n  if (a != b) f[b] = a;\n}\ninline void add(long long x, long long y) {\n  if (!F[x].count(y)) F[x][y], ++odeg[x], ++ideg[y], merge(x, y);\n}\nlong long g[MaxN];\nsigned main(void) {\n  read(n, m, K);\n  for (long long i = 1; i <= K; ++i) f[i] = i;\n  while (n--) {\n    long long x, y, lst = 0;\n    read(x);\n    while (x--) {\n      read(y);\n      if (lst) add(lst, y);\n      lst = y;\n    }\n  }\n  for (long long i = 1; i <= K; ++i) nd[getf(i)].push_back(i);\n  for (long long i = 1; i <= K; ++i)\n    if (getf(i) == i) {\n      long long c0 = 0, c2 = 0, C0 = 0, C2 = 0;\n      for (auto j : nd[i]) {\n        if (!ideg[j])\n          ++c0;\n        else if (ideg[j] >= 2)\n          ++c2;\n        if (!odeg[j])\n          ++C0;\n        else if (odeg[j] >= 2)\n          ++C2;\n      }\n      if (!c2 && c0 == 1 && !C2 && C0 == 1) ++g[(long long)nd[i].size()];\n    }\n  std::vector<std::pair<long long, long long> > G;\n  for (long long i = 1; i <= K; ++i)\n    if (g[i]) G.push_back(std::make_pair(i, g[i]));\n  std::memset(f, 0, sizeof f), f[0] = 1;\n  for (long long i = 0; i < m; ++i)\n    for (auto j : G)\n      if (i + j.first <= m) (f[i + j.first] += f[i] * j.second) %= p;\n  write(f[m]), putchar('\\n');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double PI = acos(-1);\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"O2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\nconst int MOD = 998244353;\nconst int MAXN = 3e5 + 100;\nconst int LOGN = 20;\nvoid clear() {}\nvoid precalc() {}\nvoid gen_tests() {}\nint sum(int a, int b) { return (a + b) % MOD; }\nint mult(int a, int b) { return ((long long)a * b) % MOD; }\nset<int> added_indexes[MAXN];\nstruct Number {\n  map<int, int> numbers;\n  map<int, int> back_numbers;\n  int delta = 0;\n  int index;\n  int Get(int ind) { return numbers[ind - delta]; }\n  void Set(int ind, int val) {\n    numbers[ind - delta] = val;\n    back_numbers[val] = ind - delta;\n  }\n  int Size() { return numbers.size(); }\n  int GetIndex(int value) { return back_numbers[value] + delta; }\n  bool TryMerge(Number &number) {\n    if (back_numbers.count(number.Get(0))) {\n      int s_index = GetIndex(number.Get(0));\n      int common_elements = 0;\n      for (int i = 0; i + s_index < Size() && i < number.Size(); i++) {\n        if (Get(i + s_index) != number.Get(i)) return false;\n        common_elements++;\n      }\n      for (int i = common_elements; i < number.Size(); i++) {\n        int val = number.Get(i);\n        added_indexes[val].insert(index);\n        Set(s_index + i, val);\n      }\n      return numbers.size() == back_numbers.size();\n    } else if (number.back_numbers.count(Get(0))) {\n      int s_index = number.GetIndex(Get(0));\n      for (int i = 0; i < Size() && i + s_index < number.Size(); i++) {\n        if (Get(i) != number.Get(i + s_index)) return false;\n      }\n      delta += s_index;\n      for (int i = 0; i < s_index; i++) {\n        int val = number.Get(i);\n        added_indexes[val].insert(index);\n        Set(i, val);\n      }\n      return numbers.size() == back_numbers.size();\n    }\n    return false;\n  }\n};\nNumber numbers[MAXN];\nbool is_free[MAXN];\nbool added[MAXN];\nvoid FullRemove(int index, bool add_more) {\n  queue<int> q;\n  q.push(index);\n  added[index] = false;\n  while (!q.empty()) {\n    auto top = q.front();\n    q.pop();\n    for (auto u : numbers[top].back_numbers) {\n      int val = u.first;\n      added_indexes[val].erase(top);\n      for (auto v : added_indexes[val]) {\n        if (added[v] && add_more) {\n          added[v] = false;\n          q.push(v);\n        }\n      }\n    }\n  }\n}\nint results[MAXN];\nvoid solve() {\n  int n, m, k;\n  cin >> n >> m >> k;\n  for (int i = 0; i < n; i++) {\n    numbers[i].index = i;\n    added[i] = 1;\n    int c;\n    cin >> c;\n    bool must_remove = false;\n    for (int j = 0; j < c; j++) {\n      int val;\n      cin >> val;\n      numbers[i].Set(j, val);\n      if (is_free[val] && added_indexes[val].size() == 0) must_remove = true;\n      added_indexes[val].insert(i);\n      is_free[val] = true;\n    }\n    must_remove |= numbers[i].back_numbers.size() != numbers[i].numbers.size();\n    if (must_remove) {\n      FullRemove(i, true);\n      continue;\n    }\n    int v = i;\n    set<int> merge_queue;\n    for (auto u : numbers[i].back_numbers) {\n      for (auto m : added_indexes[u.first]) {\n        if (m != i) merge_queue.insert(m);\n      }\n    }\n    for (int to : merge_queue) {\n      if (numbers[v].Size() < numbers[to].Size()) {\n        swap(v, to);\n      }\n      must_remove = !numbers[v].TryMerge(numbers[to]);\n      if (must_remove) break;\n      FullRemove(to, false);\n    }\n    if (must_remove) FullRemove(v, true);\n  }\n  map<int, int> shifts;\n  for (int i = 1; i <= k; i++) {\n    if (!is_free[i]) shifts[1]++;\n  }\n  for (int i = 0; i < n; i++) {\n    if (added[i]) {\n      shifts[numbers[i].Size()]++;\n    }\n  }\n  vector<pair<int, int> > moves;\n  for (auto u : shifts) {\n    moves.push_back({u.first, u.second});\n  }\n  results[0] = 1;\n  for (int i = 0; i < m; i++) {\n    for (auto u : moves) {\n      if (i + u.first > m) break;\n      results[i + u.first] =\n          sum(results[i + u.first], mult(u.second, results[i]));\n    }\n  }\n  cout << results[m];\n}\nvoid multisolve() {\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  precalc();\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1) {\n  std::cerr << name << \" : \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args) {\n  const char* comma = strchr(names + 1, ',');\n  std::cerr.write(names, comma - names) << \" : \" << arg1 << \" | \";\n  __f(comma + 1, args...);\n}\nconst long long N = 3e5 + 9, mod = 998244353;\nvector<long long> adj[N];\nvector<long long> act_adj[N];\nbool vis[N];\nlong long mark[N];\nlong long dfs(long long v) {\n  long long ans = 1;\n  vis[v] = 1;\n  long long flag = 0;\n  if (mark[v] == 2) {\n    flag = 1;\n  }\n  long long pika = 0;\n  for (long long x : adj[v]) {\n    if (vis[x]) {\n      continue;\n    }\n    pika = 1;\n    long long cnt = dfs(x);\n    if (cnt == 0) flag = 1;\n    ans += cnt;\n  }\n  if (pika == 0) {\n    if (adj[v].size() > 1) {\n      return 0;\n    }\n  }\n  if (flag)\n    return 0;\n  else\n    return ans;\n}\nvoid solve() {\n  long long n, m, k;\n  cin >> n >> m >> k;\n  long long rem[k];\n  memset(rem, -1, sizeof(rem));\n  vector<long long> v[n];\n  for (long long i = 0; i < n; i++) {\n    long long c;\n    cin >> c;\n    vector<long long> tmp;\n    for (long long j = 0; j < c; j++) {\n      long long x;\n      cin >> x;\n      tmp.push_back(x);\n      rem[x - 1] = 0;\n    }\n    v[i] = tmp;\n  }\n  for (long long i = 0; i < n; i++) {\n    for (long long j = 1; j < v[i].size(); j++) {\n      long long x = v[i][j - 1];\n      long long y = v[i][j];\n      if (y == v[i][0]) {\n        mark[y] = 2;\n      }\n      if (mark[y] == 1 && !(act_adj[x].size() == 1 && act_adj[x][0] == y)) {\n        mark[y] = 2;\n      }\n      if (x == y) {\n        mark[x] = 2;\n      }\n      if (act_adj[x].size() == 1) {\n        if (act_adj[x][0] != y) {\n          mark[x] = 2;\n        }\n      } else {\n        act_adj[x].push_back(y);\n      }\n      if ((x != y) &&\n          (mark[y] == 0 ||\n           !(mark[y] == 1 && (act_adj[x].size() == 1 && act_adj[x][0] == y)))) {\n        adj[x].push_back(y);\n        adj[y].push_back(x);\n      }\n      if (mark[y] == 0) mark[y] = 1;\n    }\n  }\n  vector<long long> p(m + 1, 0);\n  for (long long i = 0; i < n; i++) {\n    for (long long j = 0; j < v[i].size(); j++) {\n      if (!vis[v[i][j]]) {\n        long long cnt = dfs(v[i][j]);\n        if (cnt <= m) {\n          p[cnt]++;\n        }\n      }\n    }\n  }\n  p[0] = 0;\n  p[1] += (abs(accumulate(rem, rem + k, 0)));\n  long long idx = -1;\n  for (long long i = m; i >= 0; i--) {\n    if (p[i] >= 1) {\n      idx = i;\n      break;\n    }\n  }\n  if (idx == -1) {\n    cout << \"0\\n\";\n    return;\n  }\n  map<long long, long long> mp;\n  for (long long i = 1; i <= m; i++) {\n    if (p[i] > 0) mp[i] = p[i];\n  }\n  long long dp[m + 1];\n  memset(dp, 0, sizeof dp);\n  dp[0] = 1;\n  for (long long i = 1; i <= m; i++) {\n    for (auto x : mp) {\n      long long idx = x.first;\n      long long val = x.second;\n      if (idx > i) {\n        break;\n      }\n      dp[i] += val * dp[i - idx] % mod;\n      dp[i] %= mod;\n    }\n  }\n  cout << dp[m] % mod;\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  long long T = 1;\n  while (T--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nauto rng = bind(uniform_int_distribution<int>(1, 10000), mt19937(time(0)));\ntemplate <class T>\nbool umin(T &a, const T &b) {\n  return (a > b ? a = b, 1 : 0);\n}\ntemplate <class T>\nbool umax(T &a, const T &b) {\n  return (a < b ? a = b, 1 : 0);\n}\nconst int M = 998244353;\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= M)\n    a -= M;\n  else if (a < 0)\n    a += M;\n}\nint mult(int a, int b) { return 1ll * a * b % M; }\nint binpow(int a, int b) {\n  int ans = 1;\n  while (b) {\n    if (b & 1) ans = mult(ans, a);\n    b >>= 1;\n    a = mult(a, a);\n  }\n  return ans;\n}\nconst int N = 3e5 + 1;\nbool used[N];\nint lft[N], rgt[N];\nbool isr[N];\nvector<int> pos[N];\nbool bad[N];\nvector<int> lengs;\nint ways[N];\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  int n, m, k;\n  cin >> n >> m >> k;\n  vector<vector<int>> vc(n, vector<int>());\n  for (int i = 0; i < n; i++) {\n    int c;\n    cin >> c;\n    vector<int> a(c);\n    for (int j = 0; j < c; j++) {\n      cin >> a[j], used[a[j]] = 1;\n      if ((int)pos[a[j]].size() && pos[a[j]].back() == i) {\n        bad[a[j]] = 1;\n      }\n      pos[a[j]].push_back(i);\n    }\n    vc[i] = a;\n    for (int j = 0; j < c; j++) {\n      if (j > 0) {\n        if (!lft[a[j]] || lft[a[j]] == a[j - 1]) {\n          lft[a[j]] = a[j - 1];\n        } else\n          bad[a[j]] = 1;\n      }\n      if (j + 1 < c) {\n        if (!rgt[a[j]] || rgt[a[j]] == a[j + 1]) {\n          rgt[a[j]] = a[j + 1];\n          continue;\n        } else\n          bad[a[j]] = 1;\n      }\n    }\n  }\n  queue<int> q;\n  for (int i = 1; i <= k; i++) {\n    if (bad[i]) q.push(i);\n  }\n  while (!q.empty()) {\n    int x = q.front();\n    q.pop();\n    for (auto &j : pos[x]) {\n      if (isr[j]) continue;\n      isr[j] = 1;\n      for (auto &v : vc[j]) {\n        if (!bad[v]) {\n          bad[v] = 1;\n          q.push(v);\n        }\n      }\n    }\n  }\n  for (int i = 1; i <= k; i++) {\n    if (bad[i]) continue;\n    if (!lft[i]) {\n      int v = i;\n      int cnt = 0;\n      while (v) {\n        cnt++;\n        v = rgt[v];\n      }\n      lengs.push_back(cnt);\n      ways[cnt]++;\n    }\n  }\n  if (!(int)lengs.size()) {\n    cout << 0;\n    return 0;\n  }\n  vector<int> dp(m + 1, 0);\n  sort(lengs.begin(), lengs.end());\n  lengs.erase(unique(lengs.begin(), lengs.end()), lengs.end());\n  dp[0] = 1;\n  for (int i = 1; i <= m; i++) {\n    for (auto &j : lengs) {\n      if (i >= j) add(dp[i], mult(ways[j], dp[i - j]));\n    }\n  }\n  cout << dp[m];\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 3e5 + 10, mod = 1e9 + 7;\nint cnt = 0;\nint s[N], dp[N];\nchar g[N];\nstring str;\nvector<int> vec;\nlong long su(long long a, long long b) {\n  a += b;\n  return (a >= 998244353) ? a - 998244353 : a;\n}\nint i, j, k, n, m, t, a[300500], in[300500];\nlong long f[300500], num[300500];\nmap<pair<int, int>, int> mp;\nvector<int> v[300050], v1;\nvoid dfs(int first, int dep) {\n  if (v[first].size() > 1 || in[first] > 1) return;\n  if (!v[first].size()) {\n    if (!num[dep]) v1.push_back(dep);\n    num[dep]++;\n    return;\n  }\n  for (auto i : v[first]) dfs(i, dep + 1);\n}\nint main() {\n  f[0] = 1;\n  scanf(\"%d%d%d\", &t, &m, &k);\n  while (t--) {\n    scanf(\"%d\", &n);\n    for (i = 1; i <= n; i++) {\n      scanf(\"%d\", &a[i]);\n      if (i > 1) {\n        if (!mp[{a[i - 1], a[i]}]) {\n          v[a[i - 1]].push_back(a[i]), in[a[i]]++;\n          mp[{a[i - 1], a[i]}] = 1;\n        }\n      }\n    }\n  }\n  for (i = 1; i <= k; i++) {\n    if (!in[i]) dfs(i, 1);\n  }\n  for (i = 1; i <= m; i++) {\n    for (auto j : v1) {\n      if (j <= i) f[i] = su(f[i], f[i - j] * num[j] % 998244353);\n    }\n  }\n  printf(\"%lld\", f[m]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline long long read() {\n  long long x = 0, f = 1;\n  char c = getchar();\n  while ((c < '0' || c > '9') && (c != '-')) c = getchar();\n  if (c == '-') f = -1, c = getchar();\n  while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n  return x * f;\n}\nconst int N = 3e5 + 10, mod = 998244353;\nint n, m, k, f[N], g[N], cnt, pos[N], tot[N][3];\nvector<int> v[N];\nint fa[N], d[N], cnt0[N], cnt1[N];\nbool flag[N];\ninline int Find(int x) { return fa[x] == x ? x : fa[x] = Find(fa[x]); }\nmap<pair<int, int>, int> vis;\ninline void Merge(int x, int y) {\n  if (vis.count(make_pair(x, y))) return;\n  vis[make_pair(x, y)] = 1;\n  ++cnt0[x], ++cnt1[y], ++d[x], ++d[y];\n  if (Find(x) == Find(y)) return flag[Find(x)] = 1, void(0);\n  int rtx = Find(x), rty = Find(y);\n  fa[rtx] = rty, flag[rty] |= flag[rtx];\n  if (cnt0[x] >= 2 || cnt1[y] >= 2) flag[rty] = 1;\n}\nint main() {\n  n = read(), m = read(), k = read();\n  for (int i = (1); i <= (k); i++) fa[i] = i;\n  for (int i = (1); i <= (n); i++) {\n    int cnt = read();\n    v[i].resize(cnt);\n    for (int j = (0); j < (cnt); j++) v[i][j] = read();\n    for (int j = (1); j < (cnt); j++) Merge(v[i][j - 1], v[i][j]);\n  }\n  for (int i = (1); i <= (k); i++) {\n    if (d[i] > 2)\n      tot[Find(i)][1] += 3;\n    else\n      tot[Find(i)][d[i]]++;\n  }\n  for (int i = (1); i <= (k); i++)\n    if (Find(i) == i && !flag[i]) {\n      if (tot[i][0] == 1)\n        g[1]++;\n      else if (tot[i][1] == 2)\n        g[tot[i][1] + tot[i][2]]++;\n    }\n  for (int i = (1); i <= (m); i++)\n    if (g[i]) pos[++cnt] = i;\n  f[0] = 1;\n  for (int i = (1); i <= (m); i++)\n    for (int j = (1); j <= (cnt); j++) {\n      if (pos[j] > i) break;\n      f[i] = (f[i] + 1ll * f[i - pos[j]] * g[pos[j]]) % mod;\n    }\n  printf(\"%d\\n\", f[m]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst ll MOD = 998244353;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, k;\n  cin >> n >> m >> k;\n  vector<int> nxt(k, -1), pre(k, -1);\n  for (int i = 0; i < n; ++i) {\n    int c;\n    cin >> c;\n    int x;\n    cin >> x;\n    --x;\n    for (int j = 1; j < c; ++j) {\n      int y;\n      cin >> y;\n      --y;\n      if (nxt[x] != -1 && nxt[x] != y)\n        nxt[x] = -2;\n      else\n        nxt[x] = y;\n      if (pre[y] != -1 && pre[y] != x)\n        pre[y] = -2;\n      else\n        pre[y] = x;\n      x = y;\n    }\n  }\n  vector<bool> seen(k, 0);\n  vector<int> counts(k + 1, 0);\n  for (int i = 0; i < k; ++i) {\n    if (pre[i] == -1) {\n      int len = 0;\n      bool works = 1;\n      for (int x = i; x >= 0 && works; x = nxt[x], ++len) {\n        if (pre[x] == -2 || nxt[x] == -2 || seen[x]) works = 0;\n        seen[x] = 1;\n      }\n      if (works) ++counts[len];\n    }\n  }\n  vector<pair<int, int>> prs;\n  for (int i = 1; i <= k; ++i) {\n    if (counts[i] >= 1) prs.emplace_back(i, counts[i]);\n  }\n  vector<ll> dp(m + 1, 0);\n  dp[0] = 1;\n  for (int i = 1; i <= m; ++i) {\n    for (auto pr : prs) {\n      if (pr.first <= i) dp[i] = (dp[i] + dp[i - pr.first] * pr.second) % MOD;\n    }\n  }\n  cout << dp[m] << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid read(int& x) {\n  static char c;\n  int f = 0;\n  while (!isdigit(c = getchar()))\n    if (c == '-') f = 1;\n  x = c ^ 48;\n  while (isdigit(c = getchar())) x = (x * 10) + (c ^ 48);\n  if (f) x = -x;\n}\nvoid read(long long& x) {\n  static char c;\n  int f = 0;\n  while (!isdigit(c = getchar()))\n    if (c == '-') f = 1;\n  x = c ^ 48;\n  while (isdigit(c = getchar())) x = (x * 10) + (c ^ 48);\n  if (f) x = -x;\n}\nvoid read(unsigned int& x) {\n  static char c;\n  while (!isdigit(c = getchar()))\n    ;\n  x = c ^ 48;\n  while (isdigit(c = getchar())) x = (x * 10) + (c ^ 48);\n}\nvoid read(unsigned long long& x) {\n  static char c;\n  while (!isdigit(c = getchar()))\n    ;\n  x = c ^ 48;\n  while (isdigit(c = getchar())) x = (x * 10) + (c ^ 48);\n}\nvoid chkmax(int& x, int y) {\n  if (y > x) x = y;\n}\nvoid chkmin(int& x, int y) {\n  if (y < x) x = y;\n}\nvoid chkmax(long long& x, long long y) {\n  if (y > x) x = y;\n}\nvoid chkmin(long long& x, long long y) {\n  if (y < x) x = y;\n}\nvoid chkmax(unsigned int& x, unsigned int y) {\n  if (y > x) x = y;\n}\nvoid chkmin(unsigned int& x, unsigned int y) {\n  if (y < x) x = y;\n}\nvoid chkmax(unsigned long long& x, unsigned long long y) {\n  if (y > x) x = y;\n}\nvoid chkmin(unsigned long long& x, unsigned long long y) {\n  if (y < x) x = y;\n}\nconst int Mod = 998244353;\nvoid Add(int& x, int y) { (x += y) >= Mod ? x -= Mod : x; }\nvoid Del(int& x, int y) { (x -= y) < 0 ? x += Mod : x; }\nconst int N = 3e5 + 10;\nconst pair<int, int> I = make_pair(0, 0);\nint n, m, k;\nint in[N], out[N];\nset<pair<int, int> > S;\nint _len[N], B[N], F[N];\nvector<int> Trans;\nint fat[N], siz[N], vis[N];\nvoid Init() {\n  for (int i = 1; i <= k; ++i) fat[i] = i, siz[i] = 1;\n}\nint getf(int now) { return now == fat[now] ? now : fat[now] = getf(fat[now]); }\nvoid Merge(int u, int v) {\n  u = getf(u), v = getf(v);\n  if (u != v)\n    fat[u] = v, siz[v] += siz[u], vis[v] |= vis[u];\n  else\n    vis[u] = 1;\n}\nvoid Work() {\n  read(n), read(m), read(k), Init();\n  for (int i = 1; i <= n; ++i) {\n    int c, pre = 0, now;\n    read(c);\n    for (int p = 0; p < c; ++p) {\n      read(now);\n      if (p)\n        if (S.find(make_pair(pre, now)) == S.end())\n          Merge(pre, now), ++in[pre], ++out[now], S.insert(make_pair(pre, now));\n      pre = now;\n    }\n  }\n  for (int i = 1; i <= k; ++i)\n    if (in[i] > 1 || out[i] > 1) vis[getf(i)] = 1;\n  for (int i = 1; i <= k; ++i)\n    if (fat[i] == i && !vis[i]) ++B[siz[i]];\n  for (int i = 1; i <= m; ++i)\n    if (B[i]) Trans.push_back(i);\n  F[0] = 1;\n  for (int i = 1; i <= m; ++i)\n    for (int v : Trans)\n      if (v <= i) Add(F[i], 1ll * F[i - v] * B[v] % Mod);\n  printf(\"%d\\n\", F[m]);\n}\nint main() { Work(); }\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a;\n    swap(a, m);\n    u -= t * v;\n    swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U &x) {\n    value = normalize(x);\n  }\n  template <typename U>\n  static Type normalize(const U &x) {\n    Type v;\n    if (-mod() <= x && x < mod())\n      v = static_cast<Type>(x);\n    else\n      v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n  const Type &operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const {\n    return static_cast<U>(value);\n  }\n  constexpr static Type mod() { return T::value; }\n  Modular &operator+=(const Modular &other) {\n    if ((value += other.value) >= mod()) value -= mod();\n    return *this;\n  }\n  Modular &operator-=(const Modular &other) {\n    if ((value -= other.value) < 0) value += mod();\n    return *this;\n  }\n  template <typename U>\n  Modular &operator+=(const U &other) {\n    return *this += Modular(other);\n  }\n  template <typename U>\n  Modular &operator-=(const U &other) {\n    return *this -= Modular(other);\n  }\n  Modular &operator++() { return *this += 1; }\n  Modular &operator--() { return *this -= 1; }\n  Modular operator++(int) {\n    Modular result(*this);\n    *this += 1;\n    return result;\n  }\n  Modular operator--(int) {\n    Modular result(*this);\n    *this -= 1;\n    return result;\n  }\n  Modular operator-() const { return Modular(-value); }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value,\n                     Modular>::type &\n  operator*=(const Modular &rhs) {\n    value = normalize(static_cast<int64_t>(value) *\n                      static_cast<int64_t>(rhs.value));\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value,\n                     Modular>::type &\n  operator*=(const Modular &rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) *\n                                         rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value,\n                     Modular>::type &\n  operator*=(const Modular &rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n  Modular &operator/=(const Modular &other) {\n    return *this *= Modular(inverse(other.value, mod()));\n  }\n  friend const Type &abs(const Modular &x) { return x.value; }\n  template <typename U>\n  friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);\n  template <typename U>\n  friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);\n  template <typename V, typename U>\n  friend V &operator>>(V &stream, Modular<U> &number);\n\n private:\n  Type value;\n};\ntemplate <typename T>\nbool operator==(const Modular<T> &lhs, const Modular<T> &rhs) {\n  return lhs.value == rhs.value;\n}\ntemplate <typename T, typename U>\nbool operator==(const Modular<T> &lhs, U rhs) {\n  return lhs == Modular<T>(rhs);\n}\ntemplate <typename T, typename U>\nbool operator==(U lhs, const Modular<T> &rhs) {\n  return Modular<T>(lhs) == rhs;\n}\ntemplate <typename T>\nbool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T, typename U>\nbool operator!=(const Modular<T> &lhs, U rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T, typename U>\nbool operator!=(U lhs, const Modular<T> &rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T>\nbool operator<(const Modular<T> &lhs, const Modular<T> &rhs) {\n  return lhs.value < rhs.value;\n}\ntemplate <typename T>\nModular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator+(const Modular<T> &lhs, U rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator+(U lhs, const Modular<T> &rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T>\nModular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator-(const Modular<T> &lhs, U rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator-(U lhs, const Modular<T> &rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T>\nModular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator*(const Modular<T> &lhs, U rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator*(U lhs, const Modular<T> &rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T>\nModular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator/(const Modular<T> &lhs, U rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator/(U lhs, const Modular<T> &rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> power(const Modular<T> &a, const U &b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\ntemplate <typename T>\nbool IsZero(const Modular<T> &number) {\n  return number() == 0;\n}\ntemplate <typename T>\nstring to_string(const Modular<T> &number) {\n  return to_string(number());\n}\ntemplate <typename U, typename T>\nU &operator<<(U &stream, const Modular<T> &number) {\n  return stream << number();\n}\ntemplate <typename U, typename T>\nU &operator>>(U &stream, Modular<T> &number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\nconstexpr int md = (int)998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\nconst int N = 3e5 + 5;\nint An, L, alpha;\nset<int> e[N];\nint indegree[N];\nbool vis[N];\nbool flag;\nint visited;\nvoid dfs(int at) {\n  vis[at] = true;\n  visited++;\n  if (e[at].size() > 1) flag = false;\n  for (int to : e[at]) {\n    if (vis[to]) {\n      flag = false;\n      continue;\n    }\n    if (indegree[to] != 1) {\n      flag = false;\n    }\n    dfs(to);\n  }\n}\nint lengths[N];\nvector<pair<int, int>> recs;\nMint dp[N];\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> An >> L >> alpha;\n  for (int i = 1; i <= An; i++) {\n    int c;\n    cin >> c;\n    vector<int> A(c);\n    for (int &a : A) cin >> a;\n    for (int j = 0; j < c - 1; j++) {\n      int from = A[j];\n      int to = A[j + 1];\n      if (e[from].find(to) == e[from].end()) {\n        e[from].insert(to);\n        indegree[to]++;\n      }\n    }\n  }\n  for (int i = 1; i <= alpha; i++) {\n    if (indegree[i] == 0) {\n      assert(vis[i] == false);\n      flag = true;\n      visited = 0;\n      dfs(i);\n      if (flag) {\n        lengths[visited]++;\n      }\n    }\n  }\n  for (int len = 1; len <= alpha; len++) {\n    if (lengths[len]) {\n      recs.push_back({len, lengths[len]});\n    }\n  }\n  dp[0] = 1;\n  for (int i = 1; i <= L; i++) {\n    dp[i] = 0;\n    for (auto [back, times] : recs) {\n      if (i - back >= 0) {\n        dp[i] += dp[i - back] * times;\n      }\n    }\n  }\n  cout << dp[L] << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2000100;\nconst long long mod = 998244353;\nconst long long inf = 2000000000000000000;\nvector<int> a[N];\nbool ban[N];\nset<int> g[N];\nset<int> in[N];\nset<int> out[N];\nbool used[N];\nvector<int> order;\nvoid dfs(int v) {\n  order.push_back(v);\n  used[v] = true;\n  for (int to : g[v]) {\n    if (!used[to]) dfs(to);\n  }\n}\nlong long dp[N];\nvoid solve() {\n  int n, m, k;\n  cin >> n >> m >> k;\n  for (int i = 1; i <= n; i++) {\n    int len;\n    cin >> len;\n    a[i].resize(len, 0);\n    set<int> st;\n    for (int &j : a[i]) cin >> j, st.insert(j);\n    if (st.size() < len) {\n      for (int x : st) ban[x] = true;\n    } else {\n      for (int j = 1; j < a[i].size(); j++) {\n        g[a[i][j - 1]].insert(a[i][j]);\n        g[a[i][j]].insert(a[i][j - 1]);\n        out[a[i][j - 1]].insert(a[i][j]);\n        in[a[i][j]].insert(a[i][j - 1]);\n      }\n    }\n  }\n  map<int, int> block;\n  for (int i = 1; i <= k; i++) {\n    if (used[i]) continue;\n    dfs(i);\n    bool OK = true;\n    if (order.size() > 1) {\n      int s = 0, f = 0, mid = 0;\n      for (int j : order) {\n        if (ban[j]) OK = false;\n        if (in[j].size() == 1 && out[j].size() == 1)\n          mid++;\n        else if (in[j].size() == 1 && out[j].size() == 0)\n          f++;\n        else if (in[j].size() == 0 && out[j].size() == 1)\n          s++;\n      }\n      if (s != 1 || f != 1 || mid + 2 != order.size()) OK = false;\n    } else\n      OK = (!ban[i]);\n    if (OK) block[order.size()]++;\n    order.clear();\n  }\n  vector<pair<int, int> > v;\n  for (auto cur : block) v.push_back(cur);\n  dp[0] = 1ll;\n  for (int i = 1; i <= m; i++) {\n    dp[i] = 0ll;\n    for (auto cur : v) {\n      if (i >= cur.first) {\n        dp[i] += dp[i - cur.first] * cur.second;\n        dp[i] %= mod;\n      }\n    }\n  }\n  cout << dp[m] << '\\n';\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int tt = 1;\n  while (tt--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n, m, k;\n  cin >> n >> m >> k;\n  set<int> v[k + 1];\n  vector<int> in(k + 1, 0);\n  vector<int> out(k + 1, 0);\n  auto add_edge = [&](int a, int b) {\n    if (v[a].find(b) != v[a].end()) return;\n    v[a].insert(b);\n    in[b]++;\n    out[a]++;\n  };\n  for (int i = 1; i <= n; i++) {\n    int c;\n    cin >> c;\n    int s;\n    cin >> s;\n    for (int j = 2; j <= c; j++) {\n      int a;\n      cin >> a;\n      add_edge(s, a);\n      s = a;\n    }\n  }\n  vector<bool> vis(k + 1, 0);\n  vector<int> cnt(m + 1, 0);\n  for (int i = 1; i <= k; i++) {\n    if (vis[i] || in[i] >= 1 || out[i] > 1) continue;\n    bool ok = 1;\n    int a = i;\n    int len = 0;\n    while (1) {\n      ok &= (in[a] <= 1 && out[a] <= 1 && !vis[a]);\n      if (!ok) break;\n      vis[a] = 1;\n      len++;\n      if (out[a] == 0) break;\n      a = (*v[a].begin());\n    }\n    if (ok && len <= m) cnt[len]++;\n  }\n  vector<array<int, 2>> opt;\n  for (int i = 1; i <= m; i++)\n    if (cnt[i] > 0) opt.push_back({i, cnt[i]});\n  const long long mod = 998244353;\n  auto add = [&](long long a, long long b) -> long long {\n    return (a + b) % mod;\n  };\n  auto mul = [&](long long a, long long b) -> long long {\n    return (a * b) % mod;\n  };\n  vector<long long> dp(m + 1, 0);\n  dp[0] = 1;\n  for (int i = 0; i <= m; i++) {\n    for (auto [c, o] : opt)\n      if (i + c <= m) dp[i + c] = add(dp[i + c], mul(o, dp[i]));\n  }\n  cout << dp[m] << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\ntemplate <typename T>\nvoid _do(T x) {\n  cerr << x << \"\\n\";\n}\ntemplate <typename T, typename... U>\nvoid _do(T x, U... y) {\n  cerr << x << \", \";\n  _do(y...);\n}\nconst int MOD1 = 1e9 + 7;\nconst int MOD2 = 998244353;\nconst long long INF = 3e18;\nconst long double PI = 3.14159265358979323846;\nlong long gcd(long long a, long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nlong long fpow(long long a, long long b, long long m) {\n  if (!b) return 1;\n  long long ans = fpow(a * a % m, b / 2, m);\n  return (b % 2 ? ans * a % m : ans);\n}\nlong long inv(long long a, long long m) { return fpow(a, m - 2, m); }\nconst long long N = 3e5 + 5;\nlong long c[N], cnt[N], len[N], dp[N];\nvector<long long> a[N], ed[N], re[N];\nbool bad[N], vis[N];\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  long long n, m, k;\n  cin >> n >> m >> k;\n  for (long long i = 1; i <= n; i++) {\n    cin >> c[i];\n    bool x = 1;\n    for (long long j = 0; j < c[i]; j++) {\n      long long u;\n      cin >> u;\n      a[i].push_back(u);\n      cnt[u]++;\n      if (cnt[u] > 1 || bad[u]) x = 0;\n    }\n    for (long long j = 0; j < c[i]; j++) {\n      cnt[a[i][j]]--;\n      if (!x)\n        bad[a[i][j]] = 1;\n      else if (j > 0) {\n        ed[a[i][j - 1]].push_back(a[i][j]);\n        re[a[i][j]].push_back(a[i][j - 1]);\n      }\n    }\n  }\n  for (long long i = 1; i <= k; i++) {\n    sort(ed[i].begin(), ed[i].end()),\n        ed[i].resize(\n            distance(ed[i].begin(), unique(ed[i].begin(), ed[i].end())));\n    sort(re[i].begin(), re[i].end()),\n        re[i].resize(\n            distance(re[i].begin(), unique(re[i].begin(), re[i].end())));\n    if (ed[i].size() > 1 || re[i].size() > 1) bad[i] = 1;\n  }\n  for (long long i = 1; i <= k; i++) {\n    if (bad[i] || vis[i] || re[i].size() != 0) continue;\n    long long cur = i, tmp = 0;\n    bool x = 1;\n    while (1) {\n      vis[cur] = 1, tmp++;\n      if (bad[cur]) {\n        x = 0;\n        break;\n      }\n      if (ed[cur].size() == 0) break;\n      cur = ed[cur][0];\n    }\n    if (x) len[tmp]++;\n  }\n  vector<pair<long long, long long> > v;\n  for (long long i = 1; i <= k; i++)\n    if (len[i] > 0) v.push_back({i, len[i]});\n  dp[0] = 1;\n  for (long long i = 1; i <= m; i++) {\n    for (pair<long long, long long> p : v) {\n      if (i < p.first) break;\n      dp[i] = (dp[i] + dp[i - p.first] * p.second % MOD2) % MOD2;\n    }\n  }\n  cout << dp[m];\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353, G = 3;\nvoid ADD(int &x, int y) {\n  x += y;\n  if (x >= mod) x -= mod;\n}\nvoid SUB(int &x, int y) {\n  x -= y;\n  if (x < 0) x += mod;\n}\nlong long power(long long a, int b) {\n  long long ans = 1;\n  while (b) {\n    if (b & 1) ans = ans * a % mod;\n    a = a * a % mod, b >>= 1;\n  }\n  return ans;\n}\nnamespace PolyOp {\nint t1[1 << 20], t2[1 << 20], num[1 << 20];\nlong long W[1 << 20 | 10];\nint LSTN;\nlong long invn;\nvoid PreCalcNTT(int N) {\n  if (N == LSTN) return;\n  LSTN = N, invn = power(N, mod - 2);\n  for (int i = 0; i < N; i++) {\n    num[i] = num[i >> 1] >> 1 | (i & 1 ? N >> 1 : 0);\n  }\n  W[0] = 1, W[1] = power(G, (mod - 1) / N);\n  for (int i = 2; i <= N; i++) W[i] = W[i - 1] * W[1] % mod;\n}\nvoid NTT(int *f, int N, int flag) {\n  for (int i = 0; i < N; i++) {\n    if (i < num[i]) swap(f[i], f[num[i]]);\n  }\n  for (int len = 2; len <= N; len <<= 1) {\n    for (int i = 0; i < N; i += len) {\n      int *fl = f + i, *fr = fl + len / 2, step = flag ? -N / len : N / len;\n      long long *w = flag ? W + N : W;\n      for (int j = 0; j < len / 2; j++) {\n        int tmp = *fr * *w % mod;\n        SUB(*fr = *fl, tmp), ADD(*fl, tmp);\n        fl++, fr++, w += step;\n      }\n    }\n  }\n  if (flag) {\n    for (int i = 0; i < N; i++) {\n      f[i] = f[i] * invn % mod;\n    }\n  }\n}\nvoid polyinv(int *f, int n, int *g) {\n  if (n == 1) {\n    g[0] = power(f[0], mod - 2);\n    return;\n  }\n  int mid = n + 1 >> 1;\n  polyinv(f, mid, g);\n  int N = 1;\n  while (N < mid + mid + n - 2) N <<= 1;\n  PreCalcNTT(N);\n  for (int i = 0; i < N; i++) {\n    t1[i] = i < mid ? g[i] : 0, t2[i] = i < n ? f[i] : 0;\n  }\n  NTT(t1, N, 0), NTT(t2, N, 0);\n  for (int i = 0; i < N; i++) {\n    t1[i] = 1ll * t1[i] * t1[i] % mod * t2[i] % mod;\n  }\n  NTT(t1, N, 1);\n  for (int i = 0; i < n; i++) {\n    g[i] = (2ll * (i < mid ? g[i] : 0) - t1[i] + mod) % mod;\n  }\n}\n}  // namespace PolyOp\nint n, m, k;\nvector<vector<int> > a;\nint cnt[300010];\nint f[300010], g[300010];\nint suc[300010], pre[300010], vis[300010], VIS = 2333;\nint main() {\n  scanf(\"%d%d%d\", &n, &m, &k);\n  for (int i = 0; i < n; i++) {\n    int k;\n    scanf(\"%d\", &k);\n    int lst = -1;\n    while (k--) {\n      int x;\n      scanf(\"%d\", &x);\n      if (lst != -1) {\n        if (suc[lst] == 0)\n          suc[lst] = x;\n        else if (suc[lst] != x)\n          suc[lst] = -1;\n        if (pre[x] == 0)\n          pre[x] = lst;\n        else if (pre[x] != lst)\n          pre[x] = -1;\n      }\n      lst = x;\n    }\n  }\n  f[0] = 1;\n  for (int i = 1; i <= k; i++) {\n    if (pre[i] == 0) {\n      VIS++;\n      int cur = i, cnt = 1;\n      vis[cur] = VIS;\n      while (1) {\n        if (suc[cur] == -1) goto BAD;\n        if (suc[cur] == 0) break;\n        cur = suc[cur], cnt++;\n        if (vis[cur] == VIS) goto BAD;\n        if (pre[cur] == -1) goto BAD;\n        vis[cur] = VIS;\n      }\n      f[cnt]--;\n    BAD:;\n    }\n  }\n  for (int i = 1; i <= m; i++) {\n    f[i] = (f[i] + mod) % mod;\n  }\n  PolyOp ::polyinv(f, m + 1, g);\n  printf(\"%d\\n\", g[m]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid read(T &x) {\n  x = 0;\n  int op = 1;\n  char c = getchar();\n  while (!isdigit(c)) {\n    if (c == '-') op = -1;\n    c = getchar();\n  }\n  while (isdigit(c)) {\n    x = (x << 1) + (x << 3) + (c ^ 48);\n    c = getchar();\n  }\n  x *= op;\n}\ninline void swap(int &x, int &y) { x ^= y ^= x ^= y; }\ninline int min(int x, int y) { return x < y ? x : y; }\ninline int max(int x, int y) { return x > y ? x : y; }\nconst int Mod = 998244353;\nint Pls(int x, int y) {\n  x += y;\n  return x >= Mod ? x - Mod : x;\n}\nconst int MN = 300000 + 10;\nint N, M, K;\nvector<int> pre[MN], nxt[MN];\nbool fob[MN], vis[MN];\nint cnt[MN];\nvector<pair<int, int> > len;\nint dp[MN];\nvoid Adde(int x, int y) {\n  pre[y].push_back(x);\n  nxt[x].push_back(y);\n}\nvoid DFS(int x) {\n  if (fob[x]) return;\n  fob[x] = 1;\n  for (int y : pre[x]) DFS(y);\n  for (int y : nxt[x]) DFS(y);\n}\nint main() {\n  scanf(\"%d%d%d\", &N, &M, &K);\n  for (int i = 1; i <= N; ++i) {\n    int c;\n    scanf(\"%d\", &c);\n    vector<int> A(c);\n    for (int &x : A) scanf(\"%d\", &x);\n    for (int j = 1; j < c; ++j) Adde(A[j - 1], A[j]);\n  }\n  for (int i = 1; i <= K; ++i) {\n    sort((pre[i]).begin(), (pre[i]).end());\n    pre[i].erase(unique((pre[i]).begin(), (pre[i]).end()), pre[i].end());\n    sort((nxt[i]).begin(), (nxt[i]).end());\n    nxt[i].erase(unique((nxt[i]).begin(), (nxt[i]).end()), nxt[i].end());\n    if ((int)(pre[i]).size() > 1 || (int)(nxt[i]).size() > 1) DFS(i);\n  }\n  for (int i = 1; i <= K; ++i)\n    if (!fob[i] && !(int)(pre[i]).size()) {\n      int l = 0, x = i;\n      while (1) {\n        if (vis[x]) {\n          DFS(x);\n          break;\n        }\n        vis[x] = 1;\n        l++;\n        if ((int)(nxt[x]).size())\n          x = nxt[x][0];\n        else\n          break;\n      }\n      cnt[l]++;\n    }\n  for (int i = 1; i <= K; ++i)\n    if (cnt[i]) len.push_back(make_pair(i, cnt[i]));\n  dp[0] = 1;\n  for (int i = 1; i <= M; ++i)\n    for (pair<int, int> j : len)\n      if (j.first <= i)\n        dp[i] = Pls(dp[i], 1ll * dp[i - j.first] * j.second % Mod);\n  printf(\"%d\\n\", dp[M]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace IO {\nchar in[1 << 26];\nchar const *o;\nvoid init_in() {\n  o = in;\n  in[fread(in, 1, sizeof(in) - 4, stdin)] = 0;\n}\nint rd() {\n  unsigned u = 0, s = 0;\n  while (*o && *o <= 32) ++o;\n  if (*o == '-')\n    s = ~s, ++o;\n  else if (*o == '+')\n    ++o;\n  while (*o >= '0' && *o <= '9') u = (u << 3) + (u << 1) + (*o++ - '0');\n  return static_cast<int>((u ^ s) + !!s);\n}\nchar *rdstr(char *s) {\n  while (*o && *o <= 32) ++o;\n  while (*o > 32) *s++ = *o++;\n  *s = '\\0';\n  return s;\n}\n}  // namespace IO\ntemplate <typename T>\nvoid chkmax(T &a, const T &b) {\n  a = max(a, b);\n}\ntemplate <typename T>\nvoid chkmin(T &a, const T &b) {\n  a = min(a, b);\n}\npair<int, int> operator+(const pair<int, int> &a, const pair<int, int> &b) {\n  return make_pair(a.first + b.first, a.second + b.second);\n}\nusing IO::rd;\nconst int N = 300005;\nint vis[N], vvis[N], dfn[N], t[N], in[N], cnt[N], low, tot;\nvector<int> G[N];\nint n, m, k;\nbool dfs(int u) {\n  dfn[u] = ++tot;\n  if (G[u].empty() && in[u] < 2) return true;\n  int v = G[u][0];\n  if (dfn[v]) return false;\n  return dfs(v);\n}\nvoid solve() {\n  n = rd(), m = rd(), k = rd();\n  int sp = k;\n  for (int i = 0; i < n; ++i) {\n    int c = rd();\n    bool valid = 1;\n    for (int j = 0; j < c; ++j) {\n      t[j] = rd();\n      if (vis[t[j]] == i + 1) {\n        valid = 0;\n      }\n      vis[t[j]] = i + 1;\n    }\n    if (valid) {\n      for (int j = 0; j < c; ++j) {\n        if (!vvis[t[j]]) --sp;\n        vvis[t[j]] = 1;\n        if (j) {\n          G[t[j - 1]].push_back(t[j]);\n        }\n      }\n    } else {\n      for (int j = 0; j < c; ++j) dfn[t[j]] = 1;\n    }\n  }\n  for (int i = 1; i < k + 1; ++i) {\n    sort(begin(G[i]), end(G[i]));\n    G[i].erase(unique(G[i].begin(), G[i].end()), G[i].end());\n    for (auto v : G[i]) {\n      ++in[v];\n    }\n  }\n  for (int i = 1; i < k + 1; ++i)\n    if (G[i].size() > 1 || in[i] > 1) dfn[i] = 1;\n  tot = 1;\n  vector<int> con;\n  for (int i = 1; i < k + 1; ++i) {\n    if (!dfn[i] && in[i] == 0) {\n      low = tot;\n      if (dfs(i)) {\n        ++cnt[tot - low];\n        con.push_back(tot - low);\n      }\n    }\n  }\n  sort(begin(con), end(con));\n  con.erase(unique(con.begin(), con.end()), con.end());\n  static int dp[N];\n  const int mod = 998244353;\n  dp[0] = 1;\n  for (int i = 1; i < m + 1; ++i) {\n    for (auto l : con) {\n      if (l > i) break;\n      dp[i] = (dp[i] + 1ll * dp[i - l] * cnt[l]) % mod;\n    }\n  }\n  cout << dp[m] << '\\n';\n}\nint main() {\n  IO::init_in();\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nconst int MAX = 1e6 + 5;\nconst long long MOD = 998244353;\nconst long long MOD2 = 2010405347;\nconst long long INF = 2e18;\nconst int dr[] = {1, 0, -1, 0, 1, 1, -1, -1, 0};\nconst int dc[] = {0, 1, 0, -1, 1, -1, 1, -1, 0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 315;\ninline long long pw(long long x, long long y, long long md = MOD) {\n  long long ret = 1;\n  x %= md;\n  while (y) {\n    if (y & 1) ret = ret * x % md;\n    x = x * x % md, y >>= 1;\n  }\n  return ret;\n}\ninline void add(int &a, int b, int md = MOD) {\n  a = a + b >= md ? a + b - md : a + b;\n}\nint n, m, k, le[MAX], ri[MAX], x[MAX], c, cnt[MAX], nx[MAX], ls[MAX], hit, nw,\n    p[MAX], a, b;\nbool st[MAX], tmp;\nlong long ans, dp[MAX];\nvector<pair<int, int> > v;\nlong long f(int rem) {\n  if (!rem) return 1;\n  if (dp[rem] != -1) return dp[rem];\n  long long ret = 0;\n  for (pair<int, int> &i : v) {\n    if (i.first > rem) break;\n    ret += f(rem - i.first) * i.second;\n  }\n  return dp[rem] = ret % MOD;\n}\nint par(int z) {\n  if (p[z] == z) return z;\n  return p[z] = par(p[z]);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m >> c;\n  for (int i = (1); i <= (c); ++i) p[i] = i, st[i] = 1;\n  for (int i = (1); i <= (n); ++i) {\n    cin >> k;\n    for (int i = (1); i <= (k); ++i) cin >> x[i];\n    tmp = 1;\n    for (int i = (2); i <= (k); ++i) {\n      if ((nx[x[i - 1]] && nx[x[i - 1]] != x[i]) ||\n          (ls[x[i]] && ls[x[i]] != x[i - 1]) || x[i] == x[i - 1])\n        tmp = 0;\n      a = par(x[i - 1]), b = par(x[i]);\n      tmp &= st[a] && st[b];\n      p[b] = a;\n      st[a] = tmp;\n      if (!tmp) continue;\n      nx[x[i - 1]] = x[i];\n      ls[x[i]] = x[i - 1];\n    }\n  }\n  for (int i = (1); i <= (c); ++i)\n    if (!ls[i] && st[par(i)]) {\n      if (!nx[i])\n        ++cnt[1];\n      else {\n        nw = i, hit = 1;\n        while (nx[nw]) nw = nx[nw], ++hit;\n        ++cnt[hit];\n      }\n    }\n  for (int i = (1); i <= (m); ++i)\n    if (cnt[i]) v.push_back({i, cnt[i]});\n  memset(&dp, -1, sizeof dp);\n  cout << f(m) << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename A, typename B>\nstring to_string(const pair<A, B>& p);\ntemplate <typename A, typename B, typename C>\nstring to_string(const tuple<A, B, C>& t);\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(const tuple<A, B, C, D>& t);\nstring to_string(const string& s) { return '\"' + s + '\"'; }\nstring to_string(const char& c) { return string(\"'\") + c + \"'\"; }\nstring to_string(const char* c) { return to_string(string(c)); }\nstring to_string(const bool& b) { return (b ? \"true\" : \"false\"); }\nstring to_string(const vector<bool>& v) {\n  string res = \"{\";\n  for (int i = 0; i < (int)v.size(); ++i) {\n    if (i > 0) {\n      res += \", \";\n    }\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <size_t T>\nstring to_string(const bitset<T>& bs) {\n  return bs.to_string();\n}\ntemplate <typename T>\nstring to_string(queue<T> q) {\n  string res = \"{\";\n  size_t sz = q.size();\n  while (sz--) {\n    T cur = q.front();\n    q.pop();\n    if ((int)res.size() > 1) {\n      res += \", \";\n    }\n    res += to_string(cur);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <typename T, class C>\nstring to_string(priority_queue<T, vector<T>, C> pq) {\n  string res = \"{\";\n  while (!pq.empty()) {\n    T cur = pq.top();\n    pq.pop();\n    if ((int)res.size() > 1) {\n      res += \", \";\n    }\n    res += to_string(cur);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <typename T>\nstring to_string(const T& v) {\n  string res = \"{\";\n  for (auto& el : v) {\n    if ((int)res.size() > 1) {\n      res += \", \";\n    }\n    res += to_string(el);\n  }\n  res += \"}\";\n  return res;\n}\ntemplate <typename A, typename B>\nstring to_string(const pair<A, B>& p) {\n  return '(' + to_string(p.first) + \", \" + to_string(p.second) + ')';\n}\ntemplate <typename A, typename B, typename C>\nstring to_string(const tuple<A, B, C>& t) {\n  return '(' + to_string(get<0>(t)) + \", \" + to_string(get<1>(t)) + \", \" +\n         to_string(get<2>(t)) + ')';\n}\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(const tuple<A, B, C, D>& t) {\n  return '(' + to_string(get<0>(t)) + \", \" + to_string(get<1>(t)) + \", \" +\n         to_string(get<2>(t)) + \", \" + to_string(get<3>(t)) + ')';\n}\nvoid debug_out(int size, bool first, string name) {\n  vector<string> tmp = {name};\n  vector<int> tmp2 = {size, first};\n  cerr << endl;\n}\nconstexpr int buffer_size = 255;\ntemplate <typename Head, typename... Tail>\nvoid debug_out(int size, bool first, string name, Head H, Tail... T) {\n  string tmp;\n  int off = 0;\n  while ((!name.empty() && name[0] != ',') || off != 0) {\n    tmp += name[0];\n    name.erase(name.begin());\n    char c = tmp.back();\n    if (c == '{' || c == '(') {\n      ++off;\n    } else if (c == '}' || c == ')') {\n      --off;\n    }\n  }\n  if (!name.empty()) {\n    name.erase(name.begin());\n  }\n  if (tmp[0] == ' ') {\n    tmp.erase(tmp.begin());\n  }\n  string buff = to_string(H);\n  if ((int)buff.size() + size + (int)tmp.size() > buffer_size - 5 && !first) {\n    cerr << '\\n';\n    size = 0;\n  }\n  cerr << '[' << tmp << \": \" << buff << \"] \";\n  debug_out(((int)buff.size() + size + (int)tmp.size() + 5) % buffer_size,\n            false, name, T...);\n}\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a;\n    swap(a, m);\n    u -= t * v;\n    swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod())\n      v = static_cast<Type>(x);\n    else\n      v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const {\n    return static_cast<U>(value);\n  }\n  constexpr static Type mod() { return T::value; }\n  Modular& operator+=(const Modular& other) {\n    if ((value += other.value) >= mod()) value -= mod();\n    return *this;\n  }\n  Modular& operator-=(const Modular& other) {\n    if ((value -= other.value) < 0) value += mod();\n    return *this;\n  }\n  template <typename U>\n  Modular& operator+=(const U& other) {\n    return *this += Modular(other);\n  }\n  template <typename U>\n  Modular& operator-=(const U& other) {\n    return *this -= Modular(other);\n  }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) {\n    Modular result(*this);\n    *this += 1;\n    return result;\n  }\n  Modular operator--(int) {\n    Modular result(*this);\n    *this -= 1;\n    return result;\n  }\n  Modular operator-() const { return Modular(-value); }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value,\n                     Modular>::type&\n  operator*=(const Modular& rhs) {\n    value = normalize(static_cast<int64_t>(value) *\n                      static_cast<int64_t>(rhs.value));\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value,\n                     Modular>::type&\n  operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) *\n                                     rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value,\n                     Modular>::type&\n  operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n  Modular& operator/=(const Modular& other) {\n    return *this *= Modular(inverse(other.value, mod()));\n  }\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) {\n    return v;\n  }\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\ntemplate <typename T>\nbool operator==(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return lhs.value == rhs.value;\n}\ntemplate <typename T, typename U>\nbool operator==(const Modular<T>& lhs, U rhs) {\n  return lhs == Modular<T>(rhs);\n}\ntemplate <typename T, typename U>\nbool operator==(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) == rhs;\n}\ntemplate <typename T>\nbool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T, typename U>\nbool operator!=(const Modular<T>& lhs, U rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T, typename U>\nbool operator!=(U lhs, const Modular<T>& rhs) {\n  return !(lhs == rhs);\n}\ntemplate <typename T>\nbool operator<(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return lhs.value < rhs.value;\n}\ntemplate <typename T>\nModular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator+(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator+(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T>\nModular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator-(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator-(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T>\nModular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator*(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator*(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T>\nModular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator/(const Modular<T>& lhs, U rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator/(U lhs, const Modular<T>& rhs) {\n  return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\nstruct dsu {\n  vector<int> par, sz;\n  dsu(int n) {\n    par.resize(n);\n    sz.resize(n, 1);\n    iota(par.begin(), par.end(), 0);\n  }\n  inline int get(int v) { return par[v] = (v == par[v] ? v : get(par[v])); }\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x == y) return false;\n    sz[x] += sz[y];\n    par[y] = x;\n    return true;\n  }\n  int size(int v) { return sz[get(v)]; }\n  bool same(int x, int y) { return get(x) == get(y); }\n};\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, k;\n  cin >> n >> m >> k;\n  vector<vector<int>> g(k);\n  for (int i = 0; i < n; ++i) {\n    int s;\n    cin >> s;\n    vector<int> a(s);\n    for (int j = 0; j < s; ++j) {\n      cin >> a[j];\n      --a[j];\n    }\n    for (int j = 0; j < s - 1; ++j) {\n      g[a[j]].push_back(a[j + 1]);\n    }\n  }\n  dsu d(k);\n  vector<int> indeg(k);\n  vector<int> outdeg(k);\n  for (int i = 0; i < k; ++i) {\n    sort(g[i].begin(), g[i].end());\n    g[i].erase(unique(g[i].begin(), g[i].end()), g[i].end());\n    for (auto u : g[i]) {\n      ++indeg[u];\n      d.unite(i, u);\n    }\n    outdeg[i] = int(g[i].size());\n  }\n  vector<vector<int>> gs(k);\n  for (int i = 0; i < k; ++i) {\n    gs[d.get(i)].push_back(i);\n  }\n  vector<int> ct(k + 1);\n  for (int i = 0; i < k; ++i) {\n    array<int, 4> c = {};\n    for (auto v : gs[i]) {\n      if (indeg[v] > 1 || outdeg[v] > 1) {\n        continue;\n      }\n      ++c[indeg[v] + 2 * outdeg[v]];\n    }\n    int size = int(gs[i].size());\n    if ((c[1] == 1 && c[2] == 1 && c[3] == size - 2) || size == 1) {\n      ++ct[size];\n    }\n  }\n  vector<int> add;\n  for (int i = 0; i <= k; ++i) {\n    if (ct[i] > 0) {\n      add.push_back(i);\n    }\n  }\n  vector<Mint> dp(m + 1);\n  dp[0] = 1;\n  for (int i = 1; i <= m; ++i) {\n    for (auto j : add) {\n      dp[i] += (i >= j ? dp[i - j] * ct[j] : 0);\n    }\n  }\n  cout << dp[m] << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,abm,mmx,tune=native\")\nusing namespace std;\nlong long gcd(long long i, long long j) {\n  if (j == 0)\n    return i;\n  else\n    return gcd(j, i % j);\n}\ntemplate <typename T>\ninline T getint() {\n  T val = 0;\n  char c;\n  bool neg = false;\n  while ((c = getchar()) && !(c >= '0' && c <= '9')) {\n    neg |= c == '-';\n  }\n  do {\n    val = (val * 10) + c - '0';\n  } while ((c = getchar()) && (c >= '0' && c <= '9'));\n  return val * (neg ? -1 : 1);\n}\nconst long long INF = 3e18 + 100;\nconst int mod = 998244353;\nconst double eps = 1e-11, pi = acos(-1);\nconst long long maxN = 1 << 20, maxT = 600100, A = 179, K = 170;\nmt19937 mt_rand(time(0));\nlong long bp(long long et, long long b) {\n  b %= mod - 1;\n  et %= mod;\n  long long res = 1;\n  for (int i = 30; i >= 0; --i) {\n    res = (res * res) % mod;\n    if ((b & (1 << i)) != 0) res = (res * et) % mod;\n  }\n  return res;\n}\nvoid panic() {\n  cout << \"-1\\n\";\n  exit(0);\n}\nvector<vector<int>> g;\nvector<int> used;\nvector<set<int>> to(maxN);\nint dfs(int v) {\n  used[v] = 1;\n  sort(g[v].begin(), g[v].end());\n  g[v].resize(unique(g[v].begin(), g[v].end()) - g[v].begin());\n  if (g[v].size() > 1) return -1;\n  if (to[v].size() > 1) return -1;\n  int l = 1;\n  if (g[v].empty()) return l;\n  if (used[g[v][0]]) return -1;\n  int dd = dfs(g[v][0]);\n  if (dd == -1) return -1;\n  return l + dd;\n}\nvoid solve() {\n  int n, m, k;\n  cin >> n >> m >> k;\n  g.assign(k, vector<int>());\n  vector<int> d(k), bd(k);\n  vector<vector<int>> tmp(n);\n  for (int i = 0; i < n; ++i) {\n    int c;\n    cin >> c;\n    tmp[i].resize(c);\n    set<int> vert;\n    for (auto& x : tmp[i]) {\n      cin >> x;\n      ++d[--x];\n    }\n    for (int j = 0; j + 1 < tmp[i].size(); ++j) {\n      g[tmp[i][j]].push_back(tmp[i][j + 1]);\n      to[tmp[i][j + 1]].insert(tmp[i][j]);\n    }\n  }\n  used.assign(k, 0);\n  vector<int> lns(k + 1);\n  for (int i = 0; i < k; ++i) {\n    if (d[i] == 0) {\n      ++lns[1];\n      continue;\n    }\n    if (!to[i].empty() || used[i]) continue;\n    int tmp = dfs(i);\n    if (tmp == -1) continue;\n    ++lns[tmp];\n  }\n  vector<long long> dp(m + 1, 0);\n  dp[0] = 1;\n  set<int> s;\n  for (int i = 0; i <= k; ++i) {\n    if (lns[i] != 0) s.insert(i);\n  }\n  for (int i = 0; i < m; ++i) {\n    for (auto x : s) {\n      if (i + x > m) break;\n      dp[i + x] = (dp[i + x] + dp[i] * lns[x]) % mod;\n    }\n  }\n  cout << dp.back() << \"\\n\";\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cout.precision(20);\n  srand(time(0));\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nauto rng = bind(uniform_int_distribution<int>(1, 1000), mt19937(time(0)));\ntemplate <class T>\nbool umin(T &a, const T &b) {\n  return (a > b ? a = b, 1 : 0);\n}\ntemplate <class T>\nbool umax(T &a, const T &b) {\n  return (a < b ? a = b, 1 : 0);\n}\nconst int M = 998244353;\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= M)\n    a -= M;\n  else if (a < 0)\n    a += M;\n}\nint mult(int a, int b) { return 1ll * a * b % M; }\nint binpow(int a, int b) {\n  int ans = 1;\n  while (b) {\n    if (b & 1) ans = mult(ans, a);\n    b >>= 1;\n    a = mult(a, a);\n  }\n  return ans;\n}\nconst int N = 3e5 + 1;\nbool used[N];\nint lft[N], rgt[N];\nbool isr[N];\nvector<int> pos[N];\nbool bad[N];\nvector<int> lengs;\nint ways[N];\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  int n, m, k;\n  cin >> n >> m >> k;\n  vector<vector<int>> vc(n, vector<int>());\n  for (int i = 0; i < n; i++) {\n    int c;\n    cin >> c;\n    vector<int> a(c);\n    for (int j = 0; j < c; j++) {\n      cin >> a[j], used[a[j]] = 1;\n      if ((int)pos[a[j]].size() && pos[a[j]].back() == i) {\n        bad[a[j]] = 1;\n      }\n      pos[a[j]].push_back(i);\n    }\n    vc[i] = a;\n    for (int j = 0; j < c; j++) {\n      if (j > 0) {\n        if (!lft[a[j]] || lft[a[j]] == a[j - 1]) {\n          lft[a[j]] = a[j - 1];\n        } else\n          bad[a[j]] = 1;\n      }\n      if (j + 1 < c) {\n        if (!rgt[a[j]] || rgt[a[j]] == a[j + 1]) {\n          rgt[a[j]] = a[j + 1];\n          continue;\n        } else\n          bad[a[j]] = 1;\n      }\n    }\n  }\n  queue<int> q;\n  for (int i = 1; i <= k; i++) {\n    if (bad[i]) q.push(i);\n  }\n  while (!q.empty()) {\n    int x = q.front();\n    q.pop();\n    for (auto &j : pos[x]) {\n      if (isr[j]) continue;\n      isr[j] = 1;\n      for (auto &v : vc[j]) {\n        if (!bad[v]) {\n          bad[v] = 1;\n          q.push(v);\n        }\n      }\n    }\n  }\n  for (int i = 1; i <= k; i++) {\n    if (bad[i]) continue;\n    if (!lft[i]) {\n      int v = i;\n      int cnt = 0;\n      while (v) {\n        cnt++;\n        v = rgt[v];\n      }\n      lengs.push_back(cnt);\n      ways[cnt]++;\n    }\n  }\n  if (!(int)lengs.size()) {\n    cout << 0;\n    return 0;\n  }\n  vector<int> dp(m + 1, 0);\n  sort(lengs.begin(), lengs.end());\n  lengs.erase(unique(lengs.begin(), lengs.end()), lengs.end());\n  dp[0] = 1;\n  for (int i = 1; i <= m; i++) {\n    for (auto &j : lengs) {\n      if (i >= j) add(dp[i], mult(ways[j], dp[i - j]));\n    }\n  }\n  cout << dp[m];\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst long long mod = 998244353, gen = 3;\nconst long long inv2 = (mod + 1) / 2;\nconst int maxn = 6E+5 + 5;\nnamespace IObuf {\nconst int LEN = 1 << 20;\nchar ibuf[LEN + 5], *p1 = ibuf, *p2 = ibuf;\nchar obuf[LEN + 5], *p3 = obuf;\ninline char get() {\n  return p1 == p2 && (p2 = (p1 = ibuf) + fread(ibuf, 1, LEN, stdin), p1 == p2)\n             ? EOF\n             : *p1++;\n  return getchar();\n}\ninline long long getll(char c = get(), long long x = 0, long long op = 1) {\n  while (c < '0' || c > '9') c == '-' && (op = -op), c = get();\n  while (c >= '0' && c <= '9') x = x * 10 + c - 48, c = get();\n  return x * op;\n}\ninline char *flush() {\n  fwrite(obuf, 1, p3 - obuf, stdout);\n  return p3 = obuf;\n}\ninline void put(char c) {\n  p3 == obuf + LEN &&flush();\n  *p3++ = c;\n  return;\n  putchar(c);\n}\nchar s[20];\nint t = 0;\ninline void putll(long long x, char suf = ' ') {\n  if (!x)\n    put('0');\n  else {\n    while (x) s[++t] = x % 10 + 48, x /= 10;\n    while (t) put(s[t--]);\n  }\n  put(suf);\n}\n}  // namespace IObuf\nusing IObuf::getll;\nusing IObuf::putll;\ninline long long fsp(long long a, long long b, long long res = 1) {\n  for (a %= mod; b; a = a * a % mod, b >>= 1) b & 1 ? res = res * a % mod : 0;\n  return res;\n}\nnamespace Math {\nint L = -1;\nlong long _Fac[maxn << 2], _Inv[maxn << 2], _inv[maxn << 2];\ninline void pre(int l) {\n  if (L == -1) {\n    _Fac[0] = _Fac[1] = 1;\n    _Inv[0] = _Inv[1] = 1;\n    _inv[1] = 1, L = 1;\n    if (l <= L) return;\n  }\n  for (int i = L + 1; i <= l; ++i) {\n    _inv[i] = _inv[mod % i] * (mod - mod / i) % mod;\n    _Fac[i] = _Fac[i - 1] * i % mod;\n    _Inv[i] = _Inv[i - 1] * _inv[i] % mod;\n  }\n  L = l;\n}\ninline long long Fac(long long n) {\n  if (L < n) pre(n);\n  return _Fac[n];\n}\ninline long long Inv(long long n) {\n  if (L < n) pre(n);\n  return _Inv[n];\n}\ninline long long inv(long long n) {\n  if (L < n) pre(n);\n  return _inv[n];\n}\ninline long long binom(int n, int k) {\n  if (k < 0 || n < k) return 0;\n  return Fac(n) * Inv(k) % mod * Inv(n - k) % mod;\n}\n}  // namespace Math\nnamespace Cipolla {\nlong long imgn;\nstruct complex {\n  long long re, im;\n  inline complex(long long _r = 0, long long _i = 0) : re(_r), im(_i) {}\n  inline complex operator*(const complex &d) const {\n    return complex((re * d.re + im * d.im % mod * imgn) % mod,\n                   (re * d.im + im * d.re) % mod);\n  }\n};\ninline complex mod_fsp(complex a, long long b, complex res = 1) {\n  for (b %= mod - 1; b; a = a * a, b >>= 1)\n    if (b & 1) res = res * a;\n  return res;\n}\nstd::mt19937_64 rnd(time(0));\ninline long long solve(long long x) {\n  if (mod == 2 || !x) return x;\n  long long a = 0;\n  while (true) {\n    a = rnd() % mod;\n    if (fsp(mod + a * a - x, mod - 1 >> 1) == mod - 1) break;\n  }\n  imgn = (a * a - x + mod) % mod;\n  long long ans = mod_fsp(complex(a, 1), mod + 1 >> 1).re;\n  return std::min(ans, mod - ans);\n}\n}  // namespace Cipolla\nnamespace Poly {\nstruct poly {\n  std::vector<long long> f;\n  inline poly(long long v = 0) : f(1) { f[0] = v; }\n  inline poly(const std::vector<long long> &_f) : f(_f) {}\n  inline long long operator[](int p) const { return f[p]; }\n  inline long long &operator[](int p) { return f[p]; }\n  inline int deg() const { return f.size() - 1; }\n  inline void redeg(int d) { f.resize(d + 1); }\n  inline poly slice(int d) const {\n    if (d < f.size())\n      return std::vector<long long>(f.begin(), f.begin() + d + 1);\n    std::vector<long long> res(f);\n    return res.resize(d + 1), res;\n  }\n  inline void print(int d) const {\n    for (int i = 0; i <= d && i < f.size(); ++i) putll(f[i]);\n    for (int i = f.size(); i <= d; ++i) putll(0);\n    IObuf::put('\\n');\n  }\n  inline long long calc(long long x) const {\n    long long res = 0, tmp = 1;\n    for (int i = 0; i <= deg(); ++i) {\n      res = (res + f[i] * tmp) % mod;\n      tmp = tmp * x % mod;\n    }\n    return res;\n  }\n  inline poly operator+(const poly &P) const {\n    std::vector<long long> res(std::max(deg(), P.deg()) + 1);\n    for (int i = std::min(deg(), P.deg()); i >= 0; --i)\n      (res[i] = f[i] + P[i]) >= mod ? res[i] -= mod : 0;\n    for (int i = std::min(deg(), P.deg()) + 1; i < res.size(); ++i)\n      res[i] = i <= deg() ? f[i] : P[i];\n    return res;\n  }\n  inline poly operator-() const {\n    poly res(f);\n    for (int i = 0; i < f.size(); ++i) res[i] ? res[i] = mod - res[i] : 0;\n    return res;\n  }\n  inline poly operator-(const poly &P) const { return operator+(-P); }\n  inline poly operator<<(int d) const {\n    poly res;\n    res.redeg(d + deg());\n    for (int i = 0; i <= deg(); ++i) res[i + d] = f[i];\n    return res;\n  }\n  inline poly operator>>(int d) const {\n    if (d > deg()) return poly(0);\n    return std::vector<long long>(f.begin() + d, f.end());\n  }\n  inline poly operator*(const long long v) const {\n    poly res(f);\n    for (int i = 0; i <= deg(); ++i) res[i] = res[i] * v % mod;\n    return res;\n  }\n  inline poly operator*(const poly &P) const;\n  inline poly operator/(const poly &P) const;\n  inline poly operator%(const poly &P) const;\n  inline poly mul(const poly &P) const;\n  inline poly intg(long long C) const;\n  inline poly der() const;\n  inline poly inv() const;\n  inline poly quo(const poly &P) const;\n  inline void divln(poly &res, int bit, int l, int r) const;\n  inline poly ln() const;\n  inline void divexp(poly &res, int bit, int l, int r) const;\n  inline poly exp() const;\n  inline poly pow(long long k) const;\n  inline poly sqrt() const;\n};\nint Len = -1, rev[maxn * 4];\nunsigned long long rt[maxn * 4];\ninline void NTTpre(int bit) {\n  if (Len >= bit) return;\n  for (int i = Len + 1; i <= bit; ++i) {\n    long long stp = fsp(gen, mod - 1 >> i);\n    rt[1 << i] = 1;\n    for (int j = (1 << i) + 1; j < (1 << i + 1); ++j)\n      rt[j] = rt[j - 1] * stp % mod;\n  }\n  Len = bit;\n}\nunsigned long long tmp[maxn << 2];\ninline void NTT(poly &f, int bit, int op) {\n  NTTpre(bit);\n  int N = 1 << bit;\n  if (f.deg() < N - 1) f.redeg(N - 1);\n  for (int i = 0; i < N; ++i) {\n    rev[i] = (rev[i >> 1] >> 1 | (i & 1) << bit - 1);\n    tmp[i] = f[rev[i]] + (f[rev[i]] >> 31 & mod);\n  }\n  for (int len = 1; len < N; len <<= 1) {\n    for (int i = 0; i < N; i += len << 1) {\n      for (int k = i, x = len << 1; k < i + len; ++k, ++x) {\n        long long g = tmp[k], h = tmp[k + len] * rt[x] % mod;\n        tmp[k] = g + h, tmp[k + len] = mod + g - h;\n      }\n    }\n  }\n  for (int i = 0; i < N; ++i) f[i] = tmp[i] % mod;\n  if (op == -1) {\n    reverse(f.f.begin() + 1, f.f.begin() + N);\n    long long invN = fsp(N, mod - 2);\n    for (int i = 0; i < N; ++i) f[i] = f[i] * invN % mod;\n  }\n}\nbool __WayToDeg = 0;\ninline poly poly::operator*(const poly &P) const {\n  if (std::max(deg(), P.deg()) <= 128) {\n    poly res;\n    res.redeg(deg() + P.deg());\n    for (int i = 0; i <= deg(); ++i)\n      for (int j = 0; j <= P.deg(); ++j) (res[i + j] += f[i] * P[j]) %= mod;\n    if (!__WayToDeg) res.redeg(std::max(deg(), P.deg()));\n    return res;\n  }\n  poly F(f), G = P;\n  int bit = 0, N = 1;\n  while (N <= F.deg() + G.deg()) ++bit, N <<= 1;\n  NTT(F, bit, 1), NTT(G, bit, 1);\n  for (int i = 0; i < N; ++i) F[i] = F[i] * G[i] % mod;\n  NTT(F, bit, -1);\n  if (!__WayToDeg)\n    return F.slice(std::max(deg(), P.deg()));\n  else\n    return F.slice(deg() + P.deg());\n}\ninline poly poly::operator/(const poly &P) const {\n  if (deg() < P.deg()) return 0;\n  poly g = std::vector<long long>(f.rbegin(), f.rend()),\n       h = std::vector<long long>(P.f.rbegin(), P.f.rend());\n  poly res = g.slice(deg() - P.deg()).quo(h.slice(deg() - P.deg()));\n  res.redeg(deg() - P.deg()), reverse(res.f.begin(), res.f.end());\n  return res;\n}\ninline poly poly::operator%(const poly &P) const {\n  return operator-(operator/(P) * P).slice(P.deg() - 1);\n}\ninline poly poly::mul(const poly &P) const {\n  __WayToDeg = 1;\n  poly H = operator*(P);\n  return __WayToDeg = 0, H;\n}\ninline poly poly::inv() const {\n  poly g = fsp(f[0], mod - 2);\n  for (int stp = 1; (1 << stp - 1) <= deg(); ++stp) {\n    int N = 1 << stp;\n    poly h = slice(N - 1), g0 = g;\n    NTT(g, stp, 1), NTT(h, stp, 1);\n    for (int i = 0; i < N; ++i) h[i] = h[i] * g[i] % mod;\n    NTT(h, stp, -1);\n    for (int i = 0; i < (N >> 1); ++i) h[i] = 0;\n    NTT(h, stp, 1);\n    for (int i = 0; i < N; ++i) g[i] = g[i] * h[i] % mod;\n    NTT(g, stp, -1);\n    for (int i = 0; i < (N >> 1); ++i) g[i] = 0;\n    g = g0 - g;\n  }\n  return g.slice(deg());\n}\ninline poly poly::der() const {\n  poly res;\n  res.redeg(deg() - 1);\n  for (int i = 1; i <= deg(); ++i) res[i - 1] = f[i] * i % mod;\n  return res;\n}\ninline poly poly::intg(long long C = 0) const {\n  poly res = C;\n  res.redeg(deg() + 1);\n  for (int i = 0; i <= deg(); ++i) res[i + 1] = f[i] * Math::inv(i + 1) % mod;\n  return res;\n}\ninline poly poly::quo(const poly &P) const {\n  if (deg() == 0) return fsp(P[0], mod - 2, f[0]);\n  int bit = 0, N = 1;\n  while (N <= P.deg()) ++bit, N <<= 1;\n  poly g0 = P.slice((N >> 1) - 1).inv(), q0;\n  poly h0 = slice((N >> 1) - 1);\n  NTT(g0, bit, 1), NTT(h0, bit, 1), q0.redeg(N - 1);\n  for (int i = 0; i < N; ++i) q0[i] = g0[i] * h0[i] % mod;\n  NTT(q0, bit, -1), q0.redeg((N >> 1) - 1);\n  poly q = q0, f0 = P;\n  NTT(f0, bit, 1), NTT(q0, bit, 1);\n  for (int i = 0; i < N; ++i) f0[i] = f0[i] * q0[i] % mod;\n  NTT(f0, bit, -1), f0 = f0 - f;\n  for (int i = 0; i < (N >> 1); ++i) f0[i] = 0;\n  NTT(f0, bit, 1);\n  for (int i = 0; i < N; ++i) f0[i] = f0[i] * g0[i] % mod;\n  NTT(f0, bit, -1);\n  for (int i = 0; i < (N >> 1); ++i) f0[i] = 0;\n  return (q - f0).slice(deg());\n}\nconst int logB = 4, B = 1 << logB;\npoly __divln_G[20][B];\ninline void poly::divln(poly &res, int bit, int l, int r) const {\n  if (r - l <= 128) {\n    r = std::min(r, deg() + 1);\n    for (int i = l; i < r; ++i) {\n      if (i == 0)\n        res[i] = 0;\n      else\n        res[i] = (f[i] + mod - res[i] % mod * Math::inv(i) % mod) % mod;\n      for (int j = i + 1; j < r; ++j)\n        (res[j] += res[i] * f[j - i] % mod * i) %= mod;\n    }\n    return;\n  }\n  int dif = (r - l) / B, L = 0;\n  poly w[B];\n  while (L < B) {\n    if (l + L * dif > deg()) break;\n    w[L++].redeg(dif * 2 - 1);\n  }\n  for (int i = 0; i < L; ++i) {\n    if (i != 0) {\n      for (int j = 0; j < dif * 2; ++j) w[i][j] %= mod;\n      Poly::NTT(w[i], bit - logB + 1, -1);\n      for (int j = 0; j < dif; ++j) res[l + i * dif + j] += w[i][j + dif];\n    }\n    divln(res, bit - logB, l + i * dif, l + (i + 1) * dif);\n    if (i != L - 1) {\n      poly H;\n      H.redeg(dif * 2 - 1);\n      for (int j = 0; j < dif; ++j)\n        H[j] = res[j + l + i * dif] * (j + l + i * dif) % mod;\n      NTT(H, bit - logB + 1, 1);\n      for (int j = i + 1; j < L; ++j)\n        for (int k = 0; k < dif * 2; ++k)\n          w[j][k] += H[k] * __divln_G[bit][j - i - 1][k];\n    }\n  }\n}\ninline poly poly::ln() const {\n  poly res;\n  int bit = 0, N = 1;\n  while (N <= deg()) ++bit, N <<= 1;\n  res.redeg(N - 1), NTTpre(bit);\n  for (int b = bit; b >= logB; b -= logB) {\n    int dif = 1 << (b - logB);\n    for (int i = 0; i < B - 1; ++i) {\n      if (dif * i > deg()) break;\n      __divln_G[b][i].redeg(dif * 2 - 1);\n      for (int j = 0; j < dif * 2 && i * dif + j <= deg(); ++j)\n        __divln_G[b][i][j] = f[j + dif * i];\n      NTT(__divln_G[b][i], b - logB + 1, 1);\n    }\n  }\n  return divln(res, bit, 0, N), res;\n}\npoly __divexp_G[20][B];\ninline void poly::divexp(poly &res, int bit, int l, int r) const {\n  if (r - l <= 128) {\n    r = std::min(r, deg() + 1);\n    for (int i = l; i < r; ++i) {\n      if (i == 0)\n        res[i] = 1;\n      else\n        res[i] = res[i] % mod * Math::inv(i) % mod;\n      for (int j = i + 1; j < r; ++j)\n        (res[j] += res[i] * f[j - i] % mod * (j - i)) %= mod;\n    }\n    return;\n  }\n  int mid = l + r >> 1, dif = (r - l) / B;\n  int N = 1 << bit, L = 0;\n  poly w[B];\n  while (L < B) {\n    if (l + L * dif > deg()) break;\n    w[L++].redeg(dif * 2 - 1);\n  }\n  for (int i = 0; i < L; ++i) {\n    if (i != 0) {\n      for (int j = 0; j < dif * 2; ++j) w[i][j] %= mod;\n      Poly::NTT(w[i], bit - logB + 1, -1);\n      for (int j = 0; j < dif; ++j) res[l + i * dif + j] += w[i][j + dif];\n    }\n    divexp(res, bit - logB, l + i * dif, l + (i + 1) * dif);\n    if (i != L - 1) {\n      poly H;\n      H.redeg(dif * 2 - 1);\n      for (int j = 0; j < dif; ++j) H[j] = res[j + l + i * dif];\n      NTT(H, bit - logB + 1, 1);\n      for (int j = i + 1; j < L; ++j)\n        for (int k = 0; k < dif * 2; ++k)\n          w[j][k] += H[k] * __divexp_G[bit][j - i - 1][k];\n    }\n    if (L == i << 1)\n      for (int j = i + 1; j < L; ++j)\n        for (int k = 0; k < dif * 2; ++k) w[j].f[k] %= mod;\n  }\n}\ninline poly poly::exp() const {\n  poly res;\n  int bit = 0, N = 1;\n  while (N <= deg()) ++bit, N <<= 1;\n  res.redeg(N - 1), NTTpre(bit);\n  for (int b = bit; b >= logB; b -= logB) {\n    int dif = 1 << (b - logB);\n    for (int i = 0; i < B - 1; ++i) {\n      if (dif * i > deg()) break;\n      __divexp_G[b][i].redeg(dif * 2 - 1);\n      for (int j = 0; j < dif * 2 && i * dif + j <= deg(); ++j)\n        __divexp_G[b][i][j] = f[j + dif * i] * (j + dif * i) % mod;\n      NTT(__divexp_G[b][i], b - logB + 1, 1);\n    }\n  }\n  return divexp(res, bit, 0, N), res.slice(deg());\n}\ninline poly poly::pow(long long k) const { return (ln() * k).exp(); }\ninline poly poly::sqrt() const {\n  poly g = Cipolla::solve(operator[](0)), h0 = fsp(g[0], mod - 2);\n  for (int stp = 1; (1 << stp - 1) <= deg(); ++stp) {\n    int N = 1 << stp;\n    poly h = h0, g0 = g;\n    NTT(g, stp - 1, 1);\n    for (int i = 0; i < (N >> 1); ++i) g[i] = g[i] * g[i] % mod;\n    NTT(g, stp - 1, -1), g = g - slice(N - 1);\n    for (int i = 0; i < (N >> 1); ++i)\n      (g[i + (N >> 1)] += g[i]) %= mod, g[i] = 0;\n    g.redeg(N - 1), h.redeg(N - 1);\n    NTT(g, stp, 1), NTT(h, stp, 1);\n    for (int i = 0; i < N; ++i) g[i] = g[i] * h[i] % mod;\n    NTT(g, stp, -1);\n    for (int i = 0; i < (N >> 1); ++i) g[i] = 0;\n    g = g0 - g * ((mod + 1) / 2);\n    if ((1 << stp) <= deg()) {\n      h = h0;\n      poly f0 = slice(N - 1);\n      h.redeg((N << 1) - 1), f0.redeg((N << 1) - 1);\n      NTT(h, stp + 1, 1), NTT(f0, stp + 1, 1);\n      for (int i = 0; i < (N << 1); ++i)\n        h[i] = f0[i] * h[i] % mod * h[i] % mod * h[i] % mod;\n      NTT(h, stp + 1, -1);\n      h = (h - h0) * inv2;\n      for (int i = 0; i < (N >> 1); ++i) h[i] = 0;\n      h0 = h0 - h.slice(N - 1);\n    }\n  }\n  return g.slice(deg());\n}\n}  // namespace Poly\nusing Poly::poly;\nint n, m, k;\nstd::vector<std::pair<int, int>> to[maxn];\ninline void Add(int u, int v, int w) { to[u].emplace_back(v, w); }\ninline void Adde(int u, int v, int w) { Add(u, v, w), Add(v, u, -w); }\nbool vis[maxn], flag;\nint E, dep[maxn];\nstd::set<int> DEP;\ninline void DFS(int u, int d) {\n  vis[u] = 1, dep[u] = d;\n  if (u > n) {\n    ++E;\n    if (DEP.count(d)) flag = 0;\n    DEP.insert(d);\n  }\n  for (auto e : to[u]) {\n    if (!vis[e.first])\n      DFS(e.first, d + e.second);\n    else if (dep[e.first] != dep[u] + e.second)\n      flag = 0;\n  }\n}\nint main() {\n  n = getll(), m = getll(), k = getll();\n  for (int i = 1; i <= n; ++i) {\n    int c = getll();\n    for (int j = 1; j <= c; ++j) Adde(i, n + getll(), j);\n  }\n  std::vector<int> ele;\n  for (int i = 1; i <= k; ++i)\n    if (!vis[n + i]) {\n      DEP.clear(), E = 0, flag = 1, DFS(n + i, 0);\n      if (flag) ele.push_back(E);\n    }\n  poly F;\n  F.redeg(std::max(k, m));\n  for (int x : ele) ++F[x];\n  putll((poly(1) - F).inv()[m]), IObuf::flush();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 3e5 + 5, mod = 998244353;\nint t, vis[N], p[2 * N], n, m, K, cnt[N], dp[N], l, r, F, first[N], c[N];\nset<int> second[N];\nvector<int> a[N], V[N];\nvoid dfs(int u, int id) {\n  if (vis[u]) return;\n  vis[u] = 1;\n  while (second[u].size()) {\n    int x = *second[u].begin();\n    for (int i = 0; i < a[x].size(); i++) second[a[x][i]].erase(x);\n    int first = -1;\n    for (int j = 0; j < a[x].size(); j++) {\n      if (a[x][j] == u) first = j;\n    }\n    assert(first != -1);\n    for (int j = (int)a[x].size() - 1; j >= 0; j--) {\n      int d = a[x][j];\n      l = min(l, id + j - first);\n      r = max(r, id + j - first);\n      if (l <= 0) {\n        F = 1;\n      } else {\n        if (!p[id + j - first])\n          p[id + j - first] = d;\n        else if (p[id + j - first] != d) {\n          F = 1;\n        }\n      }\n      if (!vis[d]) {\n        dfs(d, id + j - first);\n      }\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n  cin >> n >> m >> K;\n  for (int i = 1; i <= n; i++) {\n    int c;\n    cin >> c;\n    while (c--) {\n      int x;\n      cin >> x;\n      a[i].push_back(x);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    int F = 0;\n    for (int j = 0; j < a[i].size(); j++) {\n      second[a[i][j]].insert(i);\n    }\n  }\n  for (int i = 1; i <= K; i++) {\n    if (!vis[i] && !first[i]) {\n      l = r = m + 1;\n      F = 0;\n      p[m + 1] = i;\n      dfs(i, m + 1);\n      for (int j = max(0, l); j <= r; j++) {\n        if (c[p[j]] && p[j]) F = 1;\n        c[p[j]]++;\n      }\n      for (int j = max(0, l); j <= r; j++) c[p[j]] = 0, p[j] = 0;\n      if (!(r - l + 1 > m || F)) cnt[r - l + 1]++;\n    }\n  }\n  dp[0] = 1;\n  vector<pair<int, int> > x;\n  for (int j = 1; j <= m; j++) {\n    if (cnt[j]) x.push_back({j, cnt[j]});\n  }\n  for (int i = 1; i <= m; i++) {\n    for (int j = 0; j < x.size(); j++)\n      if (i - x[j].first >= 0)\n        dp[i] =\n            (dp[i] + (long long)dp[i - x[j].first] * x[j].second % mod) % mod;\n  }\n  cout << dp[m];\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\nconst unsigned long long p = 19260817;\ninline int read(int x = 0, char c = getchar(), bool f = 0) {\n  while (c < '0' || c > '9') f = c == '-', c = getchar();\n  while (c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();\n  return f ? -x : x;\n}\nint n, m, k;\nint c[300050], dp[300050], al[300050];\nvector<int> v[300050];\nvector<unsigned long long> hs[300050];\nunsigned long long po[300050];\nbool cmp(const int &a, const int &b) { return c[a] < c[b]; }\nint pd[300050], pd2[300050];\nmap<int, int> mp[300050];\ninline unsigned long long geths(int id, int l, int r) {\n  --l;\n  --r;\n  if (!l) return hs[id][r];\n  return hs[id][r] - hs[id][l - 1] * po[r - l + 1];\n}\ninline void del1(int);\ninline void del2(int);\ninline void del1(int id) {\n  if (!pd[id]) return;\n  pd[id] = 0;\n  for (map<int, int>::iterator x = mp[id].begin(); x != mp[id].end(); ++x)\n    del2((*x).first);\n  mp[id].clear();\n}\ninline void del2(int id) {\n  if (!pd2[id]) return;\n  pd2[id] = 0;\n  for (int i = 0; i < v[id].size(); ++i) del1(v[id][i]);\n  v[id].clear();\n  return;\n}\ninline void work(int a, int pos, int b) {\n  int len = min(v[a].size() - pos + 1, v[b].size());\n  if (geths(a, pos, pos + len - 1) != geths(b, 1, len)) {\n    del2(a);\n    del2(b);\n  } else {\n    pd2[b] = 0;\n    int ok = 1;\n    for (int j = len, x; j < v[b].size(); ++j) {\n      x = v[b][j];\n      v[a].push_back(x);\n      hs[a].push_back(p * hs[a][hs[a].size() - 1] + x);\n      if (pd[x]) {\n        if (mp[x][a]) {\n          ok = 0;\n        } else\n          mp[x][a] = v[a].size();\n      } else\n        ok = 0;\n    }\n    if (!ok) del2(a);\n  }\n}\nint cnt[300050];\nint main() {\n  n = read();\n  m = read();\n  k = read();\n  po[0] = 1;\n  for (int i = 1; i <= 300000; ++i) po[i] = po[i - 1] * p;\n  for (int i = 1; i <= n; ++i) pd2[i] = 1;\n  for (int i = 1; i <= k; ++i) pd[i] = 1;\n  for (int i = 1, ok; i <= n; ++i) {\n    c[i] = read();\n    ok = 1;\n    for (int j = 1, x; j <= c[i]; ++j) {\n      x = read();\n      v[i].push_back(x);\n      if (j == 1)\n        hs[i].push_back(x);\n      else\n        hs[i].push_back(p * hs[i][hs[i].size() - 1] + x);\n      if (pd[x]) {\n        if (mp[x][i])\n          ok = 0;\n        else\n          mp[x][i] = j;\n      } else\n        ok = 0;\n    }\n    if (!ok) del2(i);\n  }\n  for (int i = 1, t; i <= n; ++i) {\n    if (!pd2[i]) continue;\n    t = v[i][0];\n    if (!pd[t] || mp[t].size() == 1) continue;\n    for (map<int, int>::iterator x = mp[t].begin(); x != mp[t].end(); ++x) {\n      if ((*x).first == i || !pd2[(*x).first]) continue;\n      work((*x).first, (*x).second, i);\n      break;\n    }\n    if (mp[t][i]) mp[t].erase(mp[t].find(i));\n  }\n  for (int i = 1, len; i <= k; ++i) {\n    if (!pd[i]) continue;\n    len = 0;\n    for (map<int, int>::iterator x = mp[i].begin(); x != mp[i].end(); ++x) {\n      if (!pd2[(*x).first]) continue;\n      if (len) {\n        del1(i);\n        break;\n      } else\n        len = 1;\n    }\n  }\n  for (int i = 1; i <= n; ++i)\n    if (pd2[i]) ++cnt[v[i].size()];\n  for (int i = 1; i <= k; ++i)\n    if (pd[i] && !mp[i].size()) ++cnt[1];\n  for (int i = 1; i <= k; ++i)\n    if (cnt[i]) al[++al[0]] = i;\n  dp[0] = 1;\n  for (int j = 0; j <= m; ++j)\n    for (int i = 1; i <= al[0]; ++i)\n      if (j + al[i] <= m)\n        dp[j + al[i]] = (1ll * cnt[al[i]] * dp[j] + dp[j + al[i]]) % mod;\n  cout << dp[m] << endl;\n  return 0;\n}\n"
        }
    ]
}