{
    "name": "1567_F. One-Four Overload",
    "source": "CODEFORCES",
    "description": "Alice has an empty grid with n rows and m columns. Some of the cells are marked, and no marked cells are adjacent to the edge of the grid. (Two squares are adjacent if they share a side.) \n\nAlice wants to fill each cell with a number such that the following statements are true: \n\n  * every unmarked cell contains either the number 1 or 4; \n  * every marked cell contains the sum of the numbers in all unmarked cells adjacent to it (if a marked cell is not adjacent to any unmarked cell, this sum is 0); \n  * every marked cell contains a multiple of 5. \n\nAlice couldn't figure it out, so she asks Bob to help her. Help Bob find any such grid, or state that no such grid exists.\n\nInput\n\nThe first line of input contains two integers n and m (1 \u2264 n, m \u2264 500) \u2014 the number of rows and the number of columns in the grid, respectively.\n\nThen n lines follow, each containing m characters. Each of these characters is either '.' or 'X' \u2014 an unmarked and a marked cell, respectively. No marked cells are adjacent to the edge of the grid.\n\nOutput\n\nOutput \"'NO\" if no suitable grid exists. Otherwise, output \"'YES\"'. Then output n lines of m space-separated integers \u2014 the integers in the grid.\n\nExamples\n\nInput\n\n\n5 5\n.....\n.XXX.\n.X.X.\n.XXX.\n.....\n\n\nOutput\n\n\nYES\n4 1 4 4 1\n4 5 5 5 1\n4 5 1 5 4\n1 5 5 5 4\n1 4 4 1 4\n\n\nInput\n\n\n5 5\n.....\n.XXX.\n.XXX.\n.XXX.\n.....\n\n\nOutput\n\n\nNO\n\n\nInput\n\n\n3 2\n..\n..\n..\n\n\nOutput\n\n\nYES\n4 1\n4 1\n1 4\n\n\nInput\n\n\n9 9\n.........\n.XXXXX.X.\n.X...X...\n.X.XXXXX.\n.X.X.X.X.\n.X.XXX.X.\n.X.....X.\n.XXXXXXX.\n.........\n\n\nOutput\n\n\nYES\n4 4 4 1 4 1 4 1 4\n1 5 5 5 5 5 4 10 1\n4 5 1 4 1 5 4 4 4\n4 5 1 5 5 0 5 5 1\n4 5 1 5 4 5 1 5 4\n4 5 1 5 5 5 4 5 1\n1 5 4 4 1 1 4 5 1\n4 5 5 5 5 5 5 5 4\n1 1 1 1 4 4 1 1 4\n\nNote\n\nIt can be shown that no such grid exists for the second test.",
    "difficulty": "F",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "dsu",
        "graphs",
        "implementation"
    ],
    "rating": 2700,
    "public_test": [
        {
            "input": "5 5\n.....\n.XXX.\n.X.X.\n.XXX.\n.....\n",
            "output": "YES\n1 1 1 1 1 \n4 5 5 5 4 \n1 5 4 5 1 \n1 5 5 5 1 \n1 4 1 4 1 \n"
        },
        {
            "input": "3 2\n..\n..\n..\n",
            "output": "YES\n1 1 \n1 1 \n1 1 \n"
        },
        {
            "input": "5 5\n.....\n.XXX.\n.XXX.\n.XXX.\n.....\n",
            "output": "NO\n"
        },
        {
            "input": "9 9\n.........\n.XXXXX.X.\n.X...X...\n.X.XXXXX.\n.X.X.X.X.\n.X.XXX.X.\n.X.....X.\n.XXXXXXX.\n.........\n",
            "output": "YES\n1 1 1 1 1 1 1 1 1 \n4 5 5 5 5 5 4 10 4 \n1 5 4 4 4 5 1 1 1 \n4 5 1 5 5 0 5 5 4 \n1 5 4 5 1 5 4 5 1 \n1 5 4 5 5 5 1 5 4 \n1 5 4 1 4 4 1 5 4 \n1 5 5 5 5 5 5 5 1 \n1 4 1 4 1 1 4 4 1 \n"
        }
    ],
    "generated_test": [
        {
            "input": "3 0\n..\n..\n..\n",
            "output": "YES\n\n\n\n"
        },
        {
            "input": "5 0\n..\n..\n..\n",
            "output": "YES\n\n\n\n\n\n"
        },
        {
            "input": "7 0\n./\n..\n./\n",
            "output": "YES\n\n\n\n\n\n\n\n"
        },
        {
            "input": "1 0\n-0\n..\n./\n",
            "output": "YES\n\n"
        },
        {
            "input": "9 9\n.........\n.XXXXX.X.\n.X...X...\n.XXXXX.X.\n.X.X.X.X.\n.X.XXX.X.\n.X.....X.\n.XXXXXXX.\n.........\n",
            "output": "NO\n"
        },
        {
            "input": "0 1\n.\n",
            "output": "YES\n"
        },
        {
            "input": "1 2\n..\n..\n..\n",
            "output": "YES\n1 1\n"
        },
        {
            "input": "1 5\n.....\n.XXX.\n.X.X.\n.XXX.\n.....\n",
            "output": "YES\n1 1 1 1 1\n"
        },
        {
            "input": "10 0\n..\n..\n..\n",
            "output": "YES\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "input": "8 0\n./\n..\n..\n",
            "output": "YES\n\n\n\n\n\n\n\n\n"
        },
        {
            "input": "2 0\n-0\n..\n/.\n",
            "output": "YES\n\n\n"
        },
        {
            "input": "4 0\n..\n-.\n..\n",
            "output": "YES\n\n\n\n\n"
        },
        {
            "input": "1 4\n.....\n.XXX.\n.X.X.\n.XX.X\n./...\n",
            "output": "YES\n1 1 1 1\n"
        },
        {
            "input": "20 0\n..\n..\n..\n",
            "output": "YES\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "input": "13 0\n-/\n..\n//\n",
            "output": "YES\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "input": "6 0\n0\n..\n/.\n",
            "output": "YES\n\n\n\n\n\n\n"
        },
        {
            "input": "1 3\n.....\n.XXX.\n.X.X.\n.XXX.\n./...\n",
            "output": "YES\n1 1 1\n"
        },
        {
            "input": "12 0\n/.\n..\n..\n",
            "output": "YES\n\n\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "input": "11 0\n-/\n..\n//\n",
            "output": "YES\n\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "input": "9 0\n./\n-.\n./\n",
            "output": "YES\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "input": "5 0\n./\n..\n..\n",
            "output": "YES\n\n\n\n\n\n"
        },
        {
            "input": "5 0\n./\n..\n./\n",
            "output": "YES\n\n\n\n\n\n"
        },
        {
            "input": "7 0\n-/\n..\n./\n",
            "output": "YES\n\n\n\n\n\n\n\n"
        },
        {
            "input": "7 0\n-0\n..\n./\n",
            "output": "YES\n\n\n\n\n\n\n\n"
        },
        {
            "input": "1 0\n-0\n..\n//\n",
            "output": "YES\n\n"
        },
        {
            "input": "1 0\n-0\n..\n/.\n",
            "output": "YES\n\n"
        },
        {
            "input": "5 5\n.....\n.XXX.\n.XXX.\nXX.X.\n.....\n",
            "output": "NO\n"
        },
        {
            "input": "9 9\n.........\n.XXXXX.X.\n...X...X.\n.X.XXXXX.\n.X.X.X.X.\n.X.XXX.X.\n.X.....X.\n.XXXXXXX.\n.........\n",
            "output": "NO\n"
        },
        {
            "input": "3 0\n..\n-.\n..\n",
            "output": "YES\n\n\n\n"
        },
        {
            "input": "5 0\n./\n-.\n./\n",
            "output": "YES\n\n\n\n\n\n"
        },
        {
            "input": "7 0\n./\n.-\n./\n",
            "output": "YES\n\n\n\n\n\n\n\n"
        },
        {
            "input": "7 0\n-/\n..\n//\n",
            "output": "YES\n\n\n\n\n\n\n\n"
        },
        {
            "input": "7 0\n0\n..\n./\n",
            "output": "YES\n\n\n\n\n\n\n\n"
        },
        {
            "input": "1 0\n1\n..\n/.\n",
            "output": "YES\n\n"
        },
        {
            "input": "9 9\n.........\n.X.XXXXX.\n.X...X...\n.XXXXX.X.\n.X.X.X.X.\n.X.XXX.X.\n.X.....X.\n.XXXXXXX.\n.........\n",
            "output": "NO\n"
        },
        {
            "input": "0 0\n.\n",
            "output": "YES\n"
        },
        {
            "input": "0 5\n.....\n.XXX.\n.X.X.\n.XXX.\n.....\n",
            "output": "YES\n"
        },
        {
            "input": "4 9\n.........\n.XXXXX.X.\n...X...X.\n.X.XXXXX.\n.X.X.X.X.\n.X.XXX.X.\n.X.....X.\n.XXXXXXX.\n.........\n",
            "output": "NO\n"
        },
        {
            "input": "10 0\n/.\n..\n..\n",
            "output": "YES\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "input": "8 0\n./\n-.\n..\n",
            "output": "YES\n\n\n\n\n\n\n\n\n"
        },
        {
            "input": "10 0\n./\n-.\n./\n",
            "output": "YES\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "input": "7 0\n./\n-.\n./\n",
            "output": "YES\n\n\n\n\n\n\n\n"
        },
        {
            "input": "7 0\n-/\n/.\n//\n",
            "output": "YES\n\n\n\n\n\n\n\n"
        },
        {
            "input": "7 0\n0\n..\n/.\n",
            "output": "YES\n\n\n\n\n\n\n\n"
        },
        {
            "input": "2 0\n0\n..\n/.\n",
            "output": "YES\n\n\n"
        },
        {
            "input": "0 0\n-\n",
            "output": "YES\n"
        },
        {
            "input": "0 3\n.....\n.XXX.\n.X.X.\n.XXX.\n.....\n",
            "output": "YES\n"
        },
        {
            "input": "4 9\n.........\n.XXXXX.X.\n...X...X.\n.Y.XXXXX.\n.X.X.X.X.\n.X.XXX.X.\n.X.....X.\n.XXXXXXX.\n.........\n",
            "output": "NO\n"
        },
        {
            "input": "10 0\n/.\n..\n-.\n",
            "output": "YES\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "input": "8 0\n./\n,.\n..\n",
            "output": "YES\n\n\n\n\n\n\n\n\n"
        },
        {
            "input": "7 0\n.0\n-.\n./\n",
            "output": "YES\n\n\n\n\n\n\n\n"
        },
        {
            "input": "0 0\n-/\n/.\n//\n",
            "output": "YES\n"
        },
        {
            "input": "7 0\n0\n..\n//\n",
            "output": "YES\n\n\n\n\n\n\n\n"
        },
        {
            "input": "0 0\n0\n..\n/.\n",
            "output": "YES\n"
        },
        {
            "input": "0 0\n,\n",
            "output": "YES\n"
        },
        {
            "input": "0 3\n.....\n.XXX.\n.X.X.\n.XXX.\n./...\n",
            "output": "YES\n"
        },
        {
            "input": "4 9\n.........\n.XXXXX.X.\n...X...X.\n.Y.XXXXX.\n.X.X.X.X.\n.X.XXX.X.\n.X..-..X.\n.XXXXXXX.\n.........\n",
            "output": "NO\n"
        },
        {
            "input": "10 0\n/.\n/.\n-.\n",
            "output": "YES\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "input": "3 0\n./\n,.\n..\n",
            "output": "YES\n\n\n\n"
        },
        {
            "input": "5 0\n.0\n-.\n./\n",
            "output": "YES\n\n\n\n\n\n"
        },
        {
            "input": "0 0\n-/\n0.\n//\n",
            "output": "YES\n"
        },
        {
            "input": "3 0\n0\n..\n//\n",
            "output": "YES\n\n\n\n"
        },
        {
            "input": "0 0\n-1\n..\n/.\n",
            "output": "YES\n"
        },
        {
            "input": "1 0\n,\n",
            "output": "YES\n\n"
        },
        {
            "input": "0 3\n.....\n.XXX.\n.X.X.\n.XX.X\n./...\n",
            "output": "YES\n"
        },
        {
            "input": "4 11\n.........\n.XXXXX.X.\n...X...X.\n.Y.XXXXX.\n.X.X.X.X.\n.X.XXX.X.\n.X..-..X.\n.XXXXXXX.\n.........\n",
            "output": "NO\n"
        },
        {
            "input": "10 0\n/.\n./\n-.\n",
            "output": "YES\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "input": "3 0\n/.\n,.\n..\n",
            "output": "YES\n\n\n\n"
        },
        {
            "input": "0 0\n-/\n0.6093613121462772\n//\n",
            "output": "YES\n"
        },
        {
            "input": "3 0\n0\n-.\n//\n",
            "output": "YES\n\n\n\n"
        },
        {
            "input": "0 0\n-1\n..\n./\n",
            "output": "YES\n"
        },
        {
            "input": "2 0\n,\n",
            "output": "YES\n\n\n"
        },
        {
            "input": "0 4\n.....\n.XXX.\n.X.X.\n.XX.X\n./...\n",
            "output": "YES\n"
        },
        {
            "input": "4 11\n.........\n.XXXXX.X.\n...X...X.\n.Y.XXXXX.\n.X.X.X.X.\n.X.XXX.X.\n.X/.-..X.\n.XXXXXXX.\n.........\n",
            "output": "NO\n"
        },
        {
            "input": "10 0\n/.\n./\n,.\n",
            "output": "YES\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "input": "3 0\n/.\n,.\n/.\n",
            "output": "YES\n\n\n\n"
        },
        {
            "input": "3 0\n1\n-.\n//\n",
            "output": "YES\n\n\n\n"
        },
        {
            "input": "0 1\n-1\n..\n./\n",
            "output": "YES\n"
        },
        {
            "input": "4 11\n.........\n.XXXXX.X.\n...X...X.\n.Y.XXXXX.\n.W.X.X.X.\n.X.XXX.X.\n.X/.-..X.\n.XXXXXXX.\n.........\n",
            "output": "NO\n"
        },
        {
            "input": "8 0\n/.\n./\n,.\n",
            "output": "YES\n\n\n\n\n\n\n\n\n"
        },
        {
            "input": "2 0\n/.\n,.\n/.\n",
            "output": "YES\n\n\n"
        },
        {
            "input": "3 0\n2\n-.\n//\n",
            "output": "YES\n\n\n\n"
        },
        {
            "input": "0 1\n-2\n..\n./\n",
            "output": "YES\n"
        },
        {
            "input": "4 11\n.........\n.XXXXX.X.\n...X...X.\n.Y.XXXXX.\n.W.X.X.X.\n.X.XXX.X.\n.X..-./X.\n.XXXXXXX.\n.........\n",
            "output": "NO\n"
        },
        {
            "input": "1 0\n/.\n./\n,.\n",
            "output": "YES\n\n"
        },
        {
            "input": "2 0\n/.\n,.\n//\n",
            "output": "YES\n\n\n"
        },
        {
            "input": "0 1\n-2\n..\n/.\n",
            "output": "YES\n"
        },
        {
            "input": "4 11\n.-.......\n.XXXXX.X.\n...X...X.\n.Y.XXXXX.\n.W.X.X.X.\n.X.XXX.X.\n.X..-./X.\n.XXXXXXX.\n.........\n",
            "output": "NO\n"
        },
        {
            "input": "1 0\n/.\n./\n,-\n",
            "output": "YES\n\n"
        },
        {
            "input": "2 0\n/.\n.,\n//\n",
            "output": "YES\n\n\n"
        },
        {
            "input": "0 1\n-2\n..\n..\n",
            "output": "YES\n"
        },
        {
            "input": "1 0\n/.\n./\n,,\n",
            "output": "YES\n\n"
        },
        {
            "input": "2 0\n/.\n.-\n//\n",
            "output": "YES\n\n\n"
        },
        {
            "input": "0 2\n-2\n..\n./\n",
            "output": "YES\n"
        },
        {
            "input": "2 0\n/.\n.+\n//\n",
            "output": "YES\n\n\n"
        },
        {
            "input": "0 2\n-2\n.-\n./\n",
            "output": "YES\n"
        },
        {
            "input": "4 0\n/.\n.+\n//\n",
            "output": "YES\n\n\n\n\n"
        },
        {
            "input": "0 2\n-2\n.-\n..\n",
            "output": "YES\n"
        },
        {
            "input": "0 4\n-2\n.-\n..\n",
            "output": "YES\n"
        },
        {
            "input": "0 4\n0\n.-\n..\n",
            "output": "YES\n"
        },
        {
            "input": "9 9\n.........\n.XXXXX.X.\n.X...X...\n.X.XXXXX.\n.X.X.X.X.\n.X.XXX.X.\n.X.....X.\n.X.XXXXXX\n.........\n",
            "output": "NO\n"
        },
        {
            "input": "3 0\n-.\n-.\n..\n",
            "output": "YES\n\n\n\n"
        },
        {
            "input": "0 0\n./\n..\n..\n",
            "output": "YES\n"
        },
        {
            "input": "5 0\n./\n/.\n./\n",
            "output": "YES\n\n\n\n\n\n"
        },
        {
            "input": "5 0\n/.\n..\n./\n",
            "output": "YES\n\n\n\n\n\n"
        },
        {
            "input": "7 0\n-/\n..\n/.\n",
            "output": "YES\n\n\n\n\n\n\n\n"
        },
        {
            "input": "0 0\n-0\n..\n./\n",
            "output": "YES\n"
        },
        {
            "input": "1 0\n-0\n..\n/0\n",
            "output": "YES\n\n"
        },
        {
            "input": "0 0\n-0\n..\n/.\n",
            "output": "YES\n"
        },
        {
            "input": "1 5\n.....\n.XXX.\n.X.X/\n.XXX.\n.....\n",
            "output": "YES\n1 1 1 1 1\n"
        },
        {
            "input": "2 0\n..\n-.\n..\n",
            "output": "YES\n\n\n"
        },
        {
            "input": "8 0\n/.\n..\n..\n",
            "output": "YES\n\n\n\n\n\n\n\n\n"
        },
        {
            "input": "5 0\n./\n--\n./\n",
            "output": "YES\n\n\n\n\n\n"
        },
        {
            "input": "7 0\n/.\n.-\n./\n",
            "output": "YES\n\n\n\n\n\n\n\n"
        },
        {
            "input": "1 0\n0\n..\n/.\n",
            "output": "YES\n\n"
        },
        {
            "input": "1 0\n.\n",
            "output": "YES\n\n"
        },
        {
            "input": "0 5\n.....\n.XXX.\n.X.X.\n.XXX/\n.....\n",
            "output": "YES\n"
        },
        {
            "input": "4 9\n.........\n.XXXXX.X.\n...X...X.\n.X.XXXXX.\n.X.X.X.X.\n.X.XXX.Y.\n.X.....X.\n.XXXXXXX.\n.........\n",
            "output": "NO\n"
        },
        {
            "input": "4 0\n..\n-.\n-.\n",
            "output": "YES\n\n\n\n\n"
        },
        {
            "input": "10 0\n//\n..\n..\n",
            "output": "YES\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "input": "8 0\n./\n-.\n.-\n",
            "output": "YES\n\n\n\n\n\n\n\n\n"
        },
        {
            "input": "10 0\n/.\n-.\n./\n",
            "output": "YES\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "input": "7 0\n/.\n-.\n./\n",
            "output": "YES\n\n\n\n\n\n\n\n"
        },
        {
            "input": "7 0\n-/\n./\n//\n",
            "output": "YES\n\n\n\n\n\n\n\n"
        },
        {
            "input": "7 0\n0\n..\n..\n",
            "output": "YES\n\n\n\n\n\n\n\n"
        },
        {
            "input": "2 0\n0\n..\n0.\n",
            "output": "YES\n\n\n"
        },
        {
            "input": "0 3\n....-\n.XXX.\n.X.X.\n.XXX.\n.....\n",
            "output": "YES\n"
        },
        {
            "input": "8 9\n.........\n.XXXXX.X.\n...X...X.\n.Y.XXXXX.\n.X.X.X.X.\n.X.XXX.X.\n.X.....X.\n.XXXXXXX.\n.........\n",
            "output": "NO\n"
        },
        {
            "input": "8 0\n./\n.-\n..\n",
            "output": "YES\n\n\n\n\n\n\n\n\n"
        },
        {
            "input": "1 0\n-/\n/.\n//\n",
            "output": "YES\n\n"
        },
        {
            "input": "0 0\n0\n..\n0.\n",
            "output": "YES\n"
        },
        {
            "input": "1 0\n-\n",
            "output": "YES\n\n"
        },
        {
            "input": "5 9\n.........\n.XXXXX.X.\n...X...X.\n.Y.XXXXX.\n.X.X.X.X.\n.X.XXX.X.\n.X..-..X.\n.XXXXXXX.\n.........\n",
            "output": "NO\n"
        },
        {
            "input": "10 0\n/.\n/.\n-/\n",
            "output": "YES\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "input": "3 0\n./\n-.\n..\n",
            "output": "YES\n\n\n\n"
        },
        {
            "input": "5 0\n0.4630921837904707\n-.\n./\n",
            "output": "YES\n\n\n\n\n\n"
        },
        {
            "input": "0 0\n-/\n0.2458250307115274\n//\n",
            "output": "YES\n"
        },
        {
            "input": "3 0\n1\n..\n//\n",
            "output": "YES\n\n\n\n"
        },
        {
            "input": "1 0\n-1\n..\n/.\n",
            "output": "YES\n\n"
        },
        {
            "input": "0 3\n.....\n.XXX.\n.X.X.\n.XX.X\n../..\n",
            "output": "YES\n"
        },
        {
            "input": "6 0\n/.\n./\n-.\n",
            "output": "YES\n\n\n\n\n\n\n"
        },
        {
            "input": "2 0\n/.\n,.\n..\n",
            "output": "YES\n\n\n"
        },
        {
            "input": "3 0\n0\n,.\n//\n",
            "output": "YES\n\n\n\n"
        },
        {
            "input": "0 4\n.....\n.XXX.\n.X.X.\n.WX.X\n./...\n",
            "output": "YES\n"
        },
        {
            "input": "4 11\n....../..\n.XXXXX.X.\n...X...X.\n.Y.XXXXX.\n.X.X.X.X.\n.X.XXX.X.\n.X/.-..X.\n.XXXXXXX.\n.........\n",
            "output": "NO\n"
        },
        {
            "input": "10 0\n0.\n./\n,.\n",
            "output": "YES\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "input": "2 0\n1\n-.\n//\n",
            "output": "YES\n\n\n"
        },
        {
            "input": "0 1\n-1\n-.\n./\n",
            "output": "YES\n"
        },
        {
            "input": "1 4\n.....\n.XXX.\n.X.X.\n.XX.W\n./...\n",
            "output": "YES\n1 1 1 1\n"
        },
        {
            "input": "4 11\n.........\n.XXXXX.X.\n...X...X.\n.Y.WXXXX.\n.W.X.X.X.\n.X.XXX.X.\n.X/.-..X.\n.XXXXXXX.\n.........\n",
            "output": "NO\n"
        },
        {
            "input": "8 0\n..\n./\n,.\n",
            "output": "YES\n\n\n\n\n\n\n\n\n"
        },
        {
            "input": "2 0\n/.\n.,\n/.\n",
            "output": "YES\n\n\n"
        },
        {
            "input": "1 0\n2\n-.\n//\n",
            "output": "YES\n\n"
        },
        {
            "input": "0 1\n-4\n..\n./\n",
            "output": "YES\n"
        },
        {
            "input": "4 11\n.........\n.XXXXX.X.\n.-.X...X.\n.Y.XXXXX.\n.W.X.X.X.\n.X.XXX.X.\n.X..-./X.\n.XXXXXXX.\n.........\n",
            "output": "NO\n"
        },
        {
            "input": "1 0\n./\n./\n,.\n",
            "output": "YES\n\n"
        },
        {
            "input": "2 0\n/.\n,/\n//\n",
            "output": "YES\n\n\n"
        },
        {
            "input": "0 1\n0\n..\n./\n",
            "output": "YES\n"
        },
        {
            "input": "4 11\n.-.......\n.XXXXX.X.\n...X...X.\n.Y.XXXXX.\n.X.X.X.W.\n.X.XXX.X.\n.X..-./X.\n.XXXXXXX.\n.........\n",
            "output": "NO\n"
        },
        {
            "input": "1 0\n/.\n./\n-,\n",
            "output": "YES\n\n"
        },
        {
            "input": "2 0\n/.\n-,\n//\n",
            "output": "YES\n\n\n"
        },
        {
            "input": "0 0\n-2\n..\n..\n",
            "output": "YES\n"
        },
        {
            "input": "1 0\n/.\n//\n,,\n",
            "output": "YES\n\n"
        },
        {
            "input": "2 0\n./\n.-\n//\n",
            "output": "YES\n\n\n"
        },
        {
            "input": "0 2\n-4\n..\n./\n",
            "output": "YES\n"
        },
        {
            "input": "2 0\n/.\n+.\n//\n",
            "output": "YES\n\n\n"
        },
        {
            "input": "0 2\n-2\n/-\n./\n",
            "output": "YES\n"
        },
        {
            "input": "6 0\n/.\n.+\n//\n",
            "output": "YES\n\n\n\n\n\n\n"
        },
        {
            "input": "0 2\n-2\n--\n./\n",
            "output": "YES\n"
        },
        {
            "input": "0 4\n-2\n--\n..\n",
            "output": "YES\n"
        },
        {
            "input": "0 4\n0\n--\n..\n",
            "output": "YES\n"
        },
        {
            "input": "2 0\n-.\n-.\n..\n",
            "output": "YES\n\n\n"
        },
        {
            "input": "0 0\n./\n..\n.-\n",
            "output": "YES\n"
        },
        {
            "input": "5 0\n/.\n/.\n./\n",
            "output": "YES\n\n\n\n\n\n"
        },
        {
            "input": "6 0\n/.\n..\n./\n",
            "output": "YES\n\n\n\n\n\n\n"
        },
        {
            "input": "2 0\n-/\n..\n/.\n",
            "output": "YES\n\n\n"
        },
        {
            "input": "0 1\n-0\n..\n./\n",
            "output": "YES\n"
        },
        {
            "input": "1 0\n0\n..\n/0\n",
            "output": "YES\n\n"
        },
        {
            "input": "1 5\n.....\n.XXX.\n/X.X.\n.XXX.\n.....\n",
            "output": "YES\n1 1 1 1 1\n"
        },
        {
            "input": "20 0\n..\n/.\n..\n",
            "output": "YES\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "input": "5 0\n./\n.-\n./\n",
            "output": "YES\n\n\n\n\n\n"
        },
        {
            "input": "7 0\n/.\n..\n./\n",
            "output": "YES\n\n\n\n\n\n\n\n"
        },
        {
            "input": "6 0\n1\n..\n/.\n",
            "output": "YES\n\n\n\n\n\n\n"
        },
        {
            "input": "1 0\n0\n..\n0.\n",
            "output": "YES\n\n"
        },
        {
            "input": "1 0\n/\n",
            "output": "YES\n\n"
        },
        {
            "input": "0 5\n.....\n.XXX.\n.W.X.\n.XXX/\n.....\n",
            "output": "YES\n"
        },
        {
            "input": "6 9\n.........\n.XXXXX.X.\n...X...X.\n.X.XXXXX.\n.X.X.X.X.\n.X.XXX.Y.\n.X.....X.\n.XXXXXXX.\n.........\n",
            "output": "NO\n"
        },
        {
            "input": "6 0\n..\n-.\n-.\n",
            "output": "YES\n\n\n\n\n\n\n"
        },
        {
            "input": "10 0\n//\n..\n/.\n",
            "output": "YES\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "input": "8 0\n/.\n-.\n.-\n",
            "output": "YES\n\n\n\n\n\n\n\n\n"
        },
        {
            "input": "7 0\n/.\n..\n.0\n",
            "output": "YES\n\n\n\n\n\n\n\n"
        },
        {
            "input": "7 0\n/-\n./\n//\n",
            "output": "YES\n\n\n\n\n\n\n\n"
        },
        {
            "input": "7 0\n0\n..\n-.\n",
            "output": "YES\n\n\n\n\n\n\n\n"
        },
        {
            "input": "2 0\n0\n.-\n0.\n",
            "output": "YES\n\n\n"
        },
        {
            "input": "0 0\n....-\n.XXX.\n.X.X.\n.XXX.\n.....\n",
            "output": "YES\n"
        },
        {
            "input": "8 9\n.........\n.XXXXX.X.\n...X...X.\n.Y.XXXXX.\n.X.X.X.X.\n.X.XXX.X.\n.XX......\n.XXXXXXX.\n.........\n",
            "output": "NO\n"
        },
        {
            "input": "12 0\n./\n.-\n..\n",
            "output": "YES\n\n\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "input": "1 0\n-/\n/.\n/0\n",
            "output": "YES\n\n"
        },
        {
            "input": "1 0\n0\n..\n0.3072543930661844\n",
            "output": "YES\n\n"
        },
        {
            "input": "1 3\n.....\n.XXX.\n.X.X.\n.XXX.\n./..-\n",
            "output": "YES\n1 1 1\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\nconst int N = 505;\nchar c[N][N];\nint comp[N][N];\nint countComp = 0;\nint color[N * N];\nint res[N][N];\nint n, m;\nvector<int> adj[N * N];\ninline bool inside(int u, int v) { return 0 < u && u <= n && 0 < v && v <= m; }\nvoid DFS(int u, int v) {\n  comp[u][v] = countComp;\n  for (int x = u - 1; x <= u + 1; ++x) {\n    for (int y = v - 1; y <= v + 1; ++y) {\n      if (!inside(x, y) || c[x][y] != '.' || comp[x][y] > 0) continue;\n      DFS(x, y);\n    }\n  }\n}\nvoid colorDFS(int u, int val) {\n  color[u] = val;\n  for (auto v : adj[u]) {\n    if (color[v] > 0) {\n      if (color[u] == color[v]) {\n        cout << \"NO\\n\";\n        exit(0);\n      }\n      continue;\n    }\n    colorDFS(v, val ^ 3);\n  }\n}\nint main() {\n  srand(time(NULL));\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= m; ++j) {\n      cin >> c[i][j];\n    }\n  }\n  countComp = 0;\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= m; ++j) {\n      if (c[i][j] == 'X' || comp[i][j] > 0) continue;\n      ++countComp;\n      DFS(i, j);\n    }\n  }\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= m; ++j) {\n      if (c[i][j] != 'X') continue;\n      int cnt = 0;\n      for (int k = 0; k < 4; ++k) {\n        cnt += (inside(i + dx[k], j + dy[k]) && c[i + dx[k]][j + dy[k]] == '.');\n      }\n      if (cnt & 1) {\n        cout << \"NO\\n\";\n        exit(0);\n      }\n      if (j > 0 && c[i][j - 1] == '.' && j < m && c[i][j + 1] == '.' &&\n          comp[i][j - 1] != comp[i][j + 1]) {\n        adj[comp[i][j - 1]].emplace_back(comp[i][j + 1]);\n        adj[comp[i][j + 1]].emplace_back(comp[i][j - 1]);\n      }\n      if (i > 0 && c[i - 1][j] == '.' && i < n && c[i + 1][j] == '.' &&\n          comp[i + 1][j] != comp[i - 1][j]) {\n        adj[comp[i + 1][j]].emplace_back(comp[i - 1][j]);\n        adj[comp[i - 1][j]].emplace_back(comp[i + 1][j]);\n      }\n    }\n  }\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= m; ++j) {\n      if (color[comp[i][j]] > 0) continue;\n      colorDFS(comp[i][j], 1);\n    }\n  }\n  for (int j = 1; j <= m; ++j) {\n    int val = ((j & 1) ? 1 : 4);\n    res[1][j] = val;\n    int pre = color[comp[1][j]];\n    for (int i = 2; i <= n; ++i) {\n      if (c[i][j] == 'X') continue;\n      if (pre != color[comp[i][j]]) {\n        val = (val == 1 ? 4 : 1);\n      }\n      res[i][j] = val;\n      pre = color[comp[i][j]];\n    }\n  }\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= m; ++j) {\n      if (c[i][j] != 'X') continue;\n      for (int k = 0; k < 4; ++k) {\n        int u = i + dx[k];\n        int v = j + dy[k];\n        if (!inside(u, v) || c[u][v] == 'X') continue;\n        res[i][j] += res[u][v];\n      }\n    }\n  }\n  cout << \"YES\\n\";\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= m; ++j) {\n      cout << res[i][j] << \" \\n\"[j == m];\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dir[4][2] = {-1, 0, 0, 1, 1, 0, 0, -1};\nchar s[505][505];\nint c[505][505];\nint r[505][505];\nvoid op(int x, int y, int k) {\n  r[x][y] = k;\n  for (auto i : dir) {\n    int xx = x + i[0], yy = y + i[1];\n    if (s[xx][yy] != 'X') continue;\n    if (c[xx][yy] == 2) {\n      for (auto j : dir) {\n        int xxx = xx + j[0], yyy = yy + j[1];\n        if (s[xxx][yyy] == '.' && !r[xxx][yyy]) op(xxx, yyy, k == 1 ? 4 : 1);\n      }\n    } else {\n      for (auto j : dir) {\n        int xxx = xx + j[0], yyy = yy + j[1];\n        if (r[xxx][yyy]) continue;\n        if (x + xxx == xx + xx && y + yyy == yy + yy)\n          op(xxx, yyy, k);\n        else\n          op(xxx, yyy, k == 1 ? 4 : 1);\n      }\n    }\n  }\n}\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%s\", s[i] + 1);\n  }\n  for (int i = 2; i <= n - 1; ++i) {\n    for (int j = 2; j <= m - 1; ++j) {\n      if (s[i][j] == 'X') {\n        for (auto k : dir) {\n          if (s[i + k[0]][j + k[1]] == '.') ++c[i][j];\n        }\n        if (c[i][j] & 1) {\n          printf(\"NO\\n\");\n          return 0;\n        }\n      }\n    }\n  }\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= m; ++j) {\n      if (s[i][j] == 'X')\n        r[i][j] = c[i][j] / 2 * 5;\n      else if (!r[i][j]) {\n        for (auto k : dir) {\n          if (c[i + k[0]][j + k[1]] == 2) op(i, j, 1);\n        }\n      }\n    }\n  }\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= m; ++j) {\n      if (!r[i][j] && s[i][j] == '.') {\n        op(i, j, 1);\n      }\n    }\n  }\n  printf(\"YES\\n\");\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= m; ++j) {\n      printf(\"%d \", r[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\nconst int N = 510;\nint n, m;\nchar a[N][N];\nint ans[N][N];\nvector<int> E[N * N];\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%s\", a[i] + 1);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      if (a[i][j] == 'X') {\n        vector<int> id;\n        for (int k = 0; k < 4; k++) {\n          int x = i + dx[k], y = j + dy[k];\n          int t = x * m + y - 1;\n          if (a[x][y] == '.') id.push_back(t);\n        }\n        if (id.size() & 1) {\n          puts(\"NO\");\n          return 0;\n        } else if (id.size() == 2) {\n          E[id[0]].push_back(id[1]);\n          E[id[1]].push_back(id[0]);\n        } else if (id.size() == 4) {\n          E[id[0]].push_back(id[1]);\n          E[id[1]].push_back(id[0]);\n          E[id[2]].push_back(id[3]);\n          E[id[3]].push_back(id[2]);\n        }\n      }\n  puts(\"YES\");\n  memset(ans, -1, sizeof ans);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      if (a[i][j] == '.') {\n        if (ans[i][j] != -1) continue;\n        ans[i][j] = 1;\n        queue<int> q;\n        q.push(i * m + j - 1);\n        while (q.size()) {\n          int t = q.front();\n          q.pop();\n          int xx = t / m, yy = t % m + 1;\n          for (int tt : E[t]) {\n            int x = tt / m, y = tt % m + 1;\n            if (ans[x][y] == -1) {\n              ans[x][y] = 5 - ans[xx][yy];\n              q.push(tt);\n            }\n          }\n        }\n      }\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      if (a[i][j] == 'X') {\n        ans[i][j] = 0;\n        for (int k = 0; k < 4; k++) {\n          int x = i + dx[k], y = j + dy[k];\n          if (a[x][y] == '.') ans[i][j] += ans[x][y];\n        }\n      }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) printf(\"%d \", ans[i][j]);\n    puts(\"\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e6 + 5;\nconst int N = 1e5 + 5;\nconst long long mod = 998244353;\nconst int inf = 0x3f3f3f3f;\nint dx[4] = {1, 0, 0, -1};\nint dy[4] = {0, 1, -1, 0};\nint ddx[4] = {1, 1, -1, -1};\nint ddy[4] = {1, -1, 1, -1};\nint n, m, k;\nchar s[505][505] = {0};\nint ans[505][505] = {0};\nint kind[505][505] = {0};\nint vis[505][505] = {0};\nvoid dfs(int x, int y, int t) {\n  vis[x][y] = 1;\n  kind[x][y] = t;\n  int p = t;\n  t ^= x & 1;\n  ans[x][y] = t * 3 + 1;\n  for (int i = 0; i < 4; i++) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if (nx >= 0 && nx < n && ny >= 0 && ny < m)\n      if (!vis[nx][ny] && s[nx][ny] == '.') dfs(nx, ny, p);\n    nx = x + ddx[i], ny = y + ddy[i];\n    if (nx >= 0 && nx < n && ny >= 0 && ny < m)\n      if (!vis[nx][ny] && s[nx][ny] == '.') dfs(nx, ny, p);\n  }\n}\nvoid solve() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; ++i) scanf(\"%s\", s[i]);\n  int cnt = 0;\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < m; j++)\n      if (!vis[i][j] && s[i][j] == '.') {\n        if (i && j) kind[i][j] = !kind[i - 2][j];\n        dfs(i, j, kind[i][j]);\n      }\n  int flag = 1;\n  for (int i = 1; i < n - 1; i++)\n    for (int j = 1; j < m - 1; j++)\n      if (s[i][j] == 'X') {\n        int cnt = 0;\n        for (int k = 0; k < 4; k++)\n          if (s[i + dx[k]][j + dy[k]] == '.') cnt += ans[i + dx[k]][j + dy[k]];\n        if (cnt % 5) flag = 0;\n        ans[i][j] = cnt;\n      }\n  if (!flag) {\n    puts(\"NO\");\n    return;\n  }\n  puts(\"YES\");\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < m; j++) printf(j < m - 1 ? \"%d \" : \"%d\\n\", ans[i][j]);\n}\nint main() {\n  int T = 1;\n  for (int i = 1; i <= T; i++) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nlong long dx[] = {0, 0, -1, 1};\nlong long dy[] = {1, -1, 0, 0};\nlong long grid[505][505];\nchar ogrid[505][505];\nlong long n, m;\nbool valid(long long x, long long y) {\n  return ((x > 0) && (x <= n) && (y > 0) && (y <= m));\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  for (long long i = 1; i <= n; i++) {\n    for (long long j = 1; j <= m; j++) cin >> ogrid[i][j];\n  }\n  for (long long i = 1; i <= n; i++) {\n    for (long long j = 1; j <= m; j++) {\n      if (ogrid[i][j] == 'X') {\n        long long unmarked = 0;\n        for (long long d = 0; d < 4; d++) {\n          long long ni = i + dx[d], nj = j + dy[d];\n          if (valid(ni, nj)) {\n            if (ogrid[ni][nj] == '.') unmarked++;\n          }\n        }\n        if (unmarked & 1) {\n          cout << \"NO\\n\";\n          return 0;\n        }\n      }\n    }\n  }\n  cout << \"YES\\n\";\n  long long cur = 0;\n  for (long long i = 1; i <= n; i++) {\n    for (long long j = 1; j <= m; j++) {\n      if (ogrid[i][j] == 'X') {\n        if (ogrid[i - 1][j] == 'X') cur ^= 1;\n        continue;\n      }\n      if ((i + cur) & 1)\n        grid[i][j] = 1;\n      else\n        grid[i][j] = 4;\n    }\n  }\n  for (long long i = 1; i <= n; i++) {\n    for (long long j = 1; j <= m; j++) {\n      if (ogrid[i][j] == 'X') {\n        for (long long d = 0; d < 4; d++) {\n          long long ni = i + dx[d], nj = j + dy[d];\n          if ((valid(ni, nj)) && (ogrid[ni][nj] == '.'))\n            grid[i][j] += grid[ni][nj];\n        }\n      }\n    }\n  }\n  for (long long i = 1; i <= n; i++) {\n    for (long long j = 1; j <= m; j++) cout << grid[i][j] << \" \";\n    cout << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long ch[4][2] = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\nconst long long N = 505;\nlong long n, m, cur;\nlong long a[N][N], res[N][N];\nvector<long long> edges[N * N];\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  long long n, m;\n  cin >> n >> m;\n  for (long long i = 0; i < n; i++) {\n    for (long long j = 0; j < m; j++) {\n      char c;\n      cin >> c;\n      if (c == 'X') a[i][j] = 1;\n      if (c == '.') a[i][j] = 0;\n    }\n  }\n  for (long long i = 0; i < n; i++) {\n    for (long long j = 0; j < m; j++) {\n      if (!a[i][j]) continue;\n      vector<long long> tt;\n      for (long long t = 0; t < 4; t++) {\n        long long x = i + ch[t][0], y = j + ch[t][1];\n        if (!a[x][y]) tt.push_back(x * m + y);\n      }\n      if ((long long)tt.size() & 1) {\n        cout << \"NO\\n\";\n        return 0;\n      }\n      for (long long i = 0; i < (long long)tt.size(); i += 2) {\n        edges[tt[i]].push_back(tt[i + 1]);\n        edges[tt[i + 1]].push_back(tt[i]);\n      }\n    }\n  }\n  for (long long i = 0; i < n; i++) {\n    for (long long j = 0; j < m; j++) {\n      if (a[i][j] || res[i][j]) continue;\n      queue<long long> qq;\n      res[i][j] = 1, qq.push(i * m + j);\n      while (!qq.empty()) {\n        long long u = qq.front();\n        qq.pop();\n        long long i = u / m, j = u % m;\n        for (auto t : edges[u]) {\n          long long x = t / m, y = t % m;\n          if (res[x][y]) continue;\n          res[x][y] = 5 - res[i][j];\n          qq.push(t);\n        }\n      }\n    }\n  }\n  cout << \"YES\\n\";\n  for (long long i = 0; i < n; i++) {\n    for (long long j = 0; j < m; j++) {\n      if (a[i][j]) {\n        for (long long t = 0; t < 4; t++) {\n          long long x = i + ch[t][0], y = j + ch[t][1];\n          if (!a[x][y]) res[i][j] += res[x][y];\n        }\n      }\n      cout << res[i][j] << \" \";\n    }\n    cout << \"\\n\";\n  }\n  cout << \"\\n\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\ndouble EPS = 1e-9;\nint INF = 1000000005;\nlong long INFF = 1000000000000000005ll;\ndouble PI = acos(-1);\nint dirx[8] = {-1, 0, 0, 1, -1, -1, 1, 1};\nint diry[8] = {0, 1, -1, 0, -1, 1, -1, 1};\nconst int MOD = 1000000007;\nconst int mxN = 500 + 7;\nchar grid[mxN][mxN] = {};\nbool vis[mxN][mxN] = {};\nint val[mxN][mxN] = {}, ans[mxN][mxN] = {}, color[mxN * mxN] = {};\nset<int> graph[mxN * mxN] = {};\nint idx = 0;\nvoid dfs(int x, int y) {\n  vis[x][y] = true;\n  vector<pair<int, int> > v;\n  for (int(i) = (-1); (i) <= (1); ++(i))\n    for (int(j) = (-1); (j) <= (1); ++(j)) v.emplace_back(x + i, y + j);\n  for (auto &(p) : (v)) {\n    if (!vis[p.first][p.second] && grid[p.first][p.second] == '.') {\n      val[p.first][p.second] = idx;\n      dfs(p.first, p.second);\n    }\n  }\n}\nint flip(int x) { return (x == 1 ? 4 : 1); }\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  for (int(i) = (0); (i) <= (n + 1); ++(i)) {\n    for (int(j) = (0); (j) <= (m + 1); ++(j)) {\n      if (i == 0 || j == 0 || i == n + 1 || j == m + 1) {\n        grid[i][j] = '!';\n      } else {\n        cin >> grid[i][j];\n      }\n    }\n  }\n  for (int(i) = (2); (i) <= (n - 1); ++(i)) {\n    for (int(j) = (2); (j) <= (m - 1); ++(j)) {\n      int cnt = (grid[i - 1][j] == '.') + (grid[i + 1][j] == '.') +\n                (grid[i][j - 1] == '.') + (grid[i][j + 1] == '.');\n      if (grid[i][j] == 'X' && cnt % 2 == 1) {\n        cout << \"NO\" << '\\n';\n        return;\n      }\n    }\n  }\n  for (int(i) = (1); (i) <= (n); ++(i)) {\n    for (int(j) = (1); (j) <= (m); ++(j)) {\n      if (grid[i][j] == '.' && !vis[i][j]) {\n        idx++;\n        val[i][j] = idx;\n        dfs(i, j);\n      }\n    }\n  }\n  for (int(i) = (1); (i) <= (n); ++(i)) {\n    for (int(j) = (1); (j) <= (m); ++(j)) {\n      if (grid[i][j] == 'X') {\n        bool horz = (grid[i][j - 1] == '.' && grid[i][j + 1] == '.');\n        bool vert = (grid[i - 1][j] == '.' && grid[i + 1][j] == '.');\n        if (horz && (val[i][j - 1] != val[i][j + 1])) {\n          graph[val[i][j - 1]].insert(val[i][j + 1]);\n          graph[val[i][j + 1]].insert(val[i][j - 1]);\n        }\n        if (vert && (val[i - 1][j] != val[i + 1][j])) {\n          graph[val[i - 1][j]].insert(val[i + 1][j]);\n          graph[val[i + 1][j]].insert(val[i - 1][j]);\n        }\n      }\n    }\n  }\n  queue<int> q;\n  for (int(i) = (1); (i) <= (idx); ++(i)) {\n    if (color[i] == 0) {\n      q.push(i);\n      color[i] = 1;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        for (int u : graph[v]) {\n          if (color[u] == 0) {\n            color[u] = (color[v] ^ 3);\n            q.push(u);\n          } else if (color[u] == color[v]) {\n            cout << \"NO\" << endl;\n            return;\n          }\n        }\n      }\n    }\n  }\n  for (int(j) = (1); (j) <= (m); ++(j)) {\n    int cur = (j % 2 ? 4 : 1);\n    ans[1][j] = cur;\n    int prev = color[val[1][j]];\n    for (int(i) = (2); (i) <= (n); ++(i)) {\n      if (grid[i][j] == '.') {\n        if (color[val[i][j]] != prev) {\n          cur = flip(cur);\n        }\n        ans[i][j] = cur;\n        prev = color[val[i][j]];\n      }\n    }\n  }\n  for (int(i) = (1); (i) <= (n); ++(i)) {\n    for (int(j) = (1); (j) <= (m); ++(j)) {\n      if (grid[i][j] == 'X') {\n        if (grid[i - 1][j] == '.') ans[i][j] += ans[i - 1][j];\n        if (grid[i + 1][j] == '.') ans[i][j] += ans[i + 1][j];\n        if (grid[i][j - 1] == '.') ans[i][j] += ans[i][j - 1];\n        if (grid[i][j + 1] == '.') ans[i][j] += ans[i][j + 1];\n      }\n    }\n  }\n  cout << \"YES\" << '\\n';\n  for (int(i) = (1); (i) <= (n); ++(i)) {\n    for (int(j) = (1); (j) <= (m); ++(j)) {\n      cout << ans[i][j] << \" \";\n    }\n    cout << \"\" << '\\n';\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int maxn = 505;\nint a[maxn][maxn], num[maxn][maxn], n, m;\nint ans[maxn][maxn], vis[maxn * maxn];\nconst int fx[] = {1, 0, 0, -1};\nconst int fy[] = {0, 1, -1, 0};\nusing std::make_pair;\nusing std::pair;\nusing std::vector;\npair<int, int> mun[maxn * maxn];\nvector<int> G[maxn * maxn];\nvoid dfs(int u, int col) {\n  int x = mun[u].first, y = mun[u].second;\n  ans[x][y] = col ? 4 : 1;\n  vis[u] = 1;\n  for (auto v : G[u])\n    if (!vis[v]) dfs(v, col ^ 1);\n  return;\n}\ninline void add(int u, int v) {\n  G[u].push_back(v), G[v].push_back(u);\n  return;\n}\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  int tot = 0;\n  for (int i = (1); i <= (n); ++i) {\n    char s[maxn];\n    scanf(\"%s\", s + 1);\n    for (int j = (1); j <= (m); ++j)\n      a[i][j] = (s[j] == 'X'), num[i][j] = ++tot, mun[tot] = make_pair(i, j);\n  }\n  for (int i = (1); i <= (n); ++i) {\n    for (int j = (1); j <= (m); ++j) {\n      if (!a[i][j]) continue;\n      int cnt = 0;\n      for (int k = (0); k <= (3); ++k) {\n        int tx = i + fx[k], ty = j + fy[k];\n        if (tx < 1 || tx > n || ty < 1 || ty > m) continue;\n        if (!a[tx][ty]) ++cnt;\n      }\n      if (cnt == 1 || cnt == 3)\n        return puts(\"NO\"), 0;\n      else if (cnt == 2) {\n        int u = 0, v = 0;\n        for (int k = (0); k <= (3); ++k) {\n          int tx = i + fx[k], ty = j + fy[k];\n          if (tx < 1 || tx > n || ty < 1 || ty > m) continue;\n          if (!a[tx][ty] && !u)\n            u = num[tx][ty];\n          else if (!a[tx][ty])\n            v = num[tx][ty];\n        }\n        add(u, v);\n      } else if (cnt == 4) {\n        add(num[i][j - 1], num[i + 1][j]);\n        add(num[i][j + 1], num[i + 1][j]);\n        add(num[i - 1][j], num[i][j + 1]);\n        add(num[i - 1][j], num[i][j - 1]);\n      }\n    }\n  }\n  for (int i = (1); i <= (n); ++i) {\n    for (int j = (1); j <= (m); ++j) {\n      if (a[i][j] || vis[num[i][j]]) continue;\n      dfs(num[i][j], 0);\n    }\n  }\n  puts(\"YES\");\n  for (int i = (1); i <= (n); ++i) {\n    for (int j = (1); j <= (m); ++j) {\n      if (a[i][j]) {\n        for (int k = (0); k <= (3); ++k) {\n          int tx = i + fx[k], ty = j + fy[k];\n          if (tx < 1 || tx > n || ty < 1 || ty > m) continue;\n          if (!a[tx][ty]) ans[i][j] += ans[tx][ty];\n        }\n      }\n      printf(\"%d \", ans[i][j]);\n    }\n    puts(\"\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid main0();\nint main() {\n  clock_t start, end;\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  main0();\n  return 0;\n}\nconst int dx[8] = {0, 1, -1, 0, 1, 1, -1, -1};\nconst int dy[8] = {1, 0, 0, -1, 1, -1, -1, 1};\nconst int N = 1e3 + 5;\nconst int M = 1e5;\nconst int INF = 0x3f3f3f3f;\nconst long long INFF = 0x3f3f3f3f3f3f3f3f;\nconst int mod = 998244353;\nconst double eps = 1e-6;\nconst double Pi = acos(-1.0);\nmt19937 rnd(\n    (unsigned int)chrono::steady_clock::now().time_since_epoch().count());\nlong long qpow(long long n, long long m) {\n  long long ret = 1;\n  while (m) {\n    if (m & 1) ret = ret * n % mod;\n    n = n * n % mod;\n    m >>= 1;\n  }\n  return ret;\n}\nlong long getinv(long long a) { return qpow(a, mod - 2); }\nint n, m;\nstring s[N];\nint ans[N][N];\nvoid main0() {\n  cin >> n >> m;\n  for (int i = 1; i <= n; ++i) {\n    cin >> s[i];\n    s[i] = \"$\" + s[i];\n    int cur = 1;\n    for (int j = 1; j <= m; ++j) {\n      cur ^= 5;\n      if (s[i][j] == '.') ans[i][j] = cur;\n      if ((s[i - 1][j] == 'X') && (s[i][j] == 'X')) cur ^= 5;\n    }\n  }\n  int succ = 1;\n  for (int i = 2; i <= n - 1; ++i) {\n    for (int j = 2; j <= m - 1; ++j)\n      if (s[i][j] == 'X') {\n        int cnt = 0;\n        for (int d = 0; d <= 3; ++d) {\n          int xt = i + dx[d];\n          int yt = j + dy[d];\n          cnt += (s[xt][yt] == '.');\n          ans[i][j] += (s[xt][yt] == '.') * ans[xt][yt];\n        }\n        if (cnt & 1) succ = 0;\n      }\n  }\n  if (succ) {\n    cout << \"YES\" << endl;\n    for (int i = 1; i <= n; ++i) {\n      for (int j = 1; j <= m; ++j) {\n        cout << ans[i][j] << ' ';\n      }\n      cout << endl;\n    }\n  } else {\n    cout << \"NO\" << endl;\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict\nimport sys\nm, n = [int(i) for i in input().split()]\nd = ['' for i in range(m)]\nfor i in range(m):\n    d[i] = input()\nop = defaultdict(list)\nr = [[-1] * n for i in range(m)]\nfor i in range(m):\n    for j in range(n):\n        if d[i][j] == 'X':\n            t = []\n            for a,b in [(i,j-1),(i-1,j),(i,j+1),(i+1,j)]:\n                if 0<=a<m and 0<=b<n and d[a][b] == '.':\n                    t.append((a,b))\n            if len(t) % 2:\n                print('NO')\n                sys.exit()\n            if len(t) == 0: r[i][j] = 0\n            if len(t) == 2:\n                op[t[0]].append(t[1])\n                op[t[1]].append(t[0])\n                r[i][j] = 5\n            if len(t) == 4:\n                op[t[0]].append(t[1])\n                op[t[1]].append(t[0])\n                op[t[2]].append(t[3])\n                op[t[3]].append(t[2])\n                r[i][j] = 10\n\nfor a in range(m):\n    for b in range(n):\n        if r[a][b] == -1:\n            r[a][b] = 1\n            st = [(a,b)]\n            while st:\n                i,j = st.pop()\n                for x,y in op[(i,j)]:\n                    if r[x][y] == -1:\n                        r[x][y] = 5 - r[i][j]\n                        st.append((x,y))\n                    else:\n                        if r[x][y] != 5 - r[i][j]:\n                            print('NO')\n                            sys.exit()\n\n\nprint('YES')\nfor i in range(m):\n    print (' '.join('1' if r[i][j] == -1 else str(r[i][j]) for j in range(n)))\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t = 1;\n  vector<vector<int>> neigh = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n  for (int i = 0; i < t; ++i) {\n    int m, n;\n    cin >> n >> m;\n    vector<string> v(n);\n    vector<vector<int>> ans(n, vector<int>(m, 0));\n    vector<vector<int>> g(n * m);\n    for (int j = 0; j < n; ++j) {\n      cin >> v[j];\n    }\n    for (int j = 1; j < n - 1; ++j) {\n      for (int k = 1; k < m - 1; ++k) {\n        if (v[j][k] == 'X') {\n          int c = 0;\n          vector<int> cell;\n          for (auto &d : neigh) {\n            int dx = d[0], dy = d[1];\n            if (v[j + dx][k + dy] == '.') {\n              ++c;\n              cell.push_back((j + dx) * m + k + dy);\n            }\n          }\n          if (c % 2 != 0) {\n            goto error;\n          } else if (c == 2) {\n            g[cell[0]].push_back(cell[1]);\n            g[cell[1]].push_back(cell[0]);\n          } else if (c == 4) {\n            g[cell[0]].push_back(cell[2]);\n            g[cell[2]].push_back(cell[0]);\n            g[cell[1]].push_back(cell[3]);\n            g[cell[3]].push_back(cell[1]);\n          }\n        }\n      }\n    }\n    for (int j = 0; j < n; ++j) {\n      for (int k = 0; k < m; ++k) {\n        int id = j * m + k;\n        if (v[j][k] == '.' && ans[j][k] == 0) {\n          list<int> q;\n          q.push_back(id);\n          ans[j][k] = 1;\n          while (!q.empty()) {\n            int p = q.front();\n            int x = p / m, y = p % m;\n            q.pop_front();\n            for (auto next : g[p]) {\n              int nx = next / m, ny = next % m;\n              if (ans[nx][ny] == 0) {\n                ans[nx][ny] = 5 - ans[x][y];\n                q.push_back(next);\n              }\n            }\n          }\n        }\n      }\n    }\n    printf(\"YES\\n\");\n    for (int j = 0; j < n; ++j) {\n      for (int k = 0; k < m; ++k) {\n        if (ans[j][k] == 0) {\n          for (auto &d : neigh) {\n            int dx = d[0], dy = d[1];\n            if (v[j + dx][k + dy] == '.') {\n              ans[j][k] += ans[j + dx][k + dy];\n            }\n          }\n        }\n        printf(\"%d \", ans[j][k]);\n      }\n      printf(\"\\n\");\n    }\n    continue;\n  error:\n    printf(\"NO\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing std::vector;\nconst int N = 505, M = N * N;\nint n, m;\nchar s[N][N];\nint a[N][N], f[M];\nvector<int> e[M];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ninline int gid(int x, int y) { return (x - 1) * m + y; }\ninline void add(int x, int y) {\n  e[x].push_back(y);\n  e[y].push_back(x);\n}\nvoid dfs(int u) {\n  for (int v : e[u])\n    if (!f[v]) {\n      f[v] = 5 - f[u];\n      dfs(v);\n    } else if (f[v] + f[u] != 5)\n      puts(\"NO\"), exit(0);\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) scanf(\"%s\", s[i] + 1);\n  for (int x = 1; x <= n; ++x)\n    for (int y = 1; y <= m; ++y)\n      if (s[x][y] == 'X') {\n        int t = 0;\n        for (int i = 0; i < 4; ++i) {\n          int x1 = x + dx[i], y1 = y + dy[i];\n          if (s[x1][y1] != '.') continue;\n          int u = gid(x1, y1);\n          if (t)\n            add(t, u), t = 0;\n          else\n            t = u;\n        }\n        if (t) return puts(\"NO\"), 0;\n      }\n  for (int x = 1; x <= n; ++x)\n    for (int y = 1; y <= m; ++y)\n      if (s[x][y] == '.' && !f[gid(x, y)]) f[gid(x, y)] = 1, dfs(gid(x, y));\n  for (int x = 1; x <= n; ++x)\n    for (int y = 1; y <= m; ++y) {\n      if (s[x][y] == '.')\n        a[x][y] = f[gid(x, y)];\n      else {\n        for (int i = 0; i < 4; ++i) {\n          int x1 = x + dx[i], y1 = y + dy[i];\n          if (s[x1][y1] != '.') continue;\n          a[x][y] += f[gid(x1, y1)];\n        }\n      }\n    }\n  puts(\"YES\");\n  for (int i = 1; i <= n; ++i, puts(\"\"))\n    for (int j = 1; j <= m; ++j) printf(\"%d \", a[i][j]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 0x7f7f7f7f;\nconst long long linf = 1e18;\nconst int maxn = 3e5 + 9;\nconst int maxm = 1e7 + 9;\nconst double PI = acos(-1);\nconst double eps = 1e-5;\nconst long long mod = 998244353;\nnamespace IO {\nlong long read() {\n  long long a = 1, b = 0;\n  char c = getchar();\n  while (c > '9' || c < '0') {\n    if (c == '-') a = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    b = (b << 3) + (b << 1) + c - '0';\n    c = getchar();\n  }\n  return a * b;\n}\nvoid print(long long x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x > 9) print(x / 10);\n  putchar(x % 10 + '0');\n}\n}  // namespace IO\nusing namespace IO;\nint n, m;\nchar s[600][600];\nint ans[600][600];\nvector<int> G[maxn];\nconst int mov[4][2] = {-1, 0, 1, 0, 0, -1, 0, 1};\nint col[maxn];\nint id(pair<int, int> x) { return (x.first - 1) * m + x.second; }\nvoid End() {\n  puts(\"NO\");\n  exit(0);\n}\nvoid dfs(int now) {\n  for (auto x : G[now]) {\n    if (!col[x]) col[x] = 5 - col[now], dfs(x);\n    if (col[x] != 5 - col[now]) End();\n  }\n}\nint main() {\n  n = read(), m = read();\n  for (int i = 1; i <= n; ++i) scanf(\"%s\", s[i] + 1);\n  vector<pair<int, int> > tmp;\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= m; ++j) {\n      if (s[i][j] == 'X') {\n        tmp.clear();\n        for (int k = 0; k <= 3; ++k) {\n          int nx = i + mov[k][0], ny = mov[k][1] + j;\n          if (s[nx][ny] == '.') tmp.push_back(pair<int, int>(nx, ny));\n        }\n        if (tmp.size() & 1) {\n          End();\n        }\n        if (tmp.size() == 2) {\n          G[id(tmp[0])].push_back(id(tmp[1]));\n          G[id(tmp[1])].push_back(id(tmp[0]));\n        } else if (tmp.size() == 4) {\n          G[id(tmp[0])].push_back(id(tmp[2]));\n          G[id(tmp[2])].push_back(id(tmp[0]));\n          G[id(tmp[3])].push_back(id(tmp[1]));\n          G[id(tmp[1])].push_back(id(tmp[3]));\n        }\n      }\n    }\n  }\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= m; ++j) {\n      if (s[i][j] == '.') {\n        if (!col[id(pair<int, int>(i, j))]) {\n          col[id(pair<int, int>(i, j))] = 1;\n          dfs(id(pair<int, int>(i, j)));\n        }\n      }\n    }\n  }\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= m; ++j) {\n      if (s[i][j] == '.') {\n        ans[i][j] = col[id(pair<int, int>(i, j))];\n      }\n    }\n  }\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= m; ++j) {\n      if (s[i][j] == 'X') {\n        int sum = 0;\n        for (int k = 0; k <= 3; ++k) {\n          int nx = i + mov[k][0], ny = j + mov[k][1];\n          if (s[nx][ny] == '.') sum += col[id(pair<int, int>(nx, ny))];\n        }\n        ans[i][j] = sum;\n      }\n    }\n  }\n  puts(\"YES\");\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= m; ++j) {\n      print(ans[i][j]);\n      putchar(' ');\n    }\n    putchar('\\n');\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nchar s[505][505];\nbool vis[505][505];\nbool vis2[250005];\nint val[250005];\nint ans[505][505];\nvector<int> g[250005];\nint idx[505][505], id = 1;\nvoid dfs(int x, int y) {\n  vis[x][y] = 1;\n  idx[x][y] = id;\n  for (int i = -1; i <= 1; i++) {\n    for (int j = -1; j <= 1; j++) {\n      if (1 <= x + i && x + i <= n && 1 <= y + j && y + j <= m &&\n          !vis[x + i][y + j] && s[x + i][y + j] == '.')\n        dfs(x + i, y + j);\n    }\n  }\n}\nvoid dfs2(int u, int c) {\n  val[u] = c;\n  vis2[u] = 1;\n  for (int i = 0; i < (int)(g[u]).size(); i++) {\n    int v = g[u][i];\n    if (vis2[v]) continue;\n    dfs2(v, c ^ 1);\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%s\", s[i] + 1);\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      if (s[i][j] == '.' && !vis[i][j]) {\n        dfs(i, j);\n        id++;\n      }\n    }\n  }\n  for (int j = 1; j <= m; j++) {\n    for (int i = 1; i <= n; i++) {\n      ans[i][j] = j % 2;\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      if (s[i][j] == 'X') {\n        int cnt = (s[i][j - 1] == '.') + (s[i][j + 1] == '.') +\n                  (s[i - 1][j] == '.') + (s[i + 1][j] == '.');\n        if (cnt % 2 == 1) {\n          printf(\"NO\\n\");\n          return 0;\n        }\n        if (cnt == 2 && s[i][j - 1] == '.' && s[i][j + 1] == '.' &&\n            idx[i][j - 1] != idx[i][j + 1]) {\n          g[idx[i][j - 1]].emplace_back(idx[i][j + 1]);\n          g[idx[i][j + 1]].emplace_back(idx[i][j - 1]);\n        }\n        if (cnt == 2 && s[i - 1][j] == '.' && s[i + 1][j] == '.' &&\n            idx[i - 1][j] != idx[i + 1][j]) {\n          g[idx[i - 1][j]].emplace_back(idx[i + 1][j]);\n          g[idx[i + 1][j]].emplace_back(idx[i - 1][j]);\n        }\n      }\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      if (vis2[idx[i][j]]) continue;\n      dfs2(idx[i][j], 0);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      if (s[i][j] == '.' && val[idx[i][j]] == 1) {\n        ans[i][j] ^= 1;\n      }\n      if (s[i][j] == '.') {\n        if (!ans[i][j]) ans[i][j] = 4;\n      }\n    }\n  }\n  printf(\"YES\\n\");\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      if (s[i][j] == 'X') {\n        ans[i][j] = 0;\n        if (s[i][j - 1] == '.') ans[i][j] += ans[i][j - 1];\n        if (s[i][j + 1] == '.') ans[i][j] += ans[i][j + 1];\n        if (s[i - 1][j] == '.') ans[i][j] += ans[i - 1][j];\n        if (s[i + 1][j] == '.') ans[i][j] += ans[i + 1][j];\n      }\n      printf(\"%d \", ans[i][j]);\n    }\n    printf(\"\\n\");\n  }\n}\n"
        },
        {
            "language": 3,
            "solution": "from collections import defaultdict\nm, n = [int(i) for i in input().split()];d = ['' for i in range(m)]\nfor i in range(m):d[i] = input()\nop = defaultdict(list);r = [[-1] * n for i in range(m)]\nfor i in range(m):\n    for j in range(n):\n        if d[i][j] == 'X':\n            t = []\n            for a,b in [(i,j-1),(i-1,j),(i,j+1),(i+1,j)]:\n                if 0<=a<m and 0<=b<n and d[a][b] == '.':\n                    t.append((a,b))\n            if len(t) % 2:\n                print('NO')\n                exit()\n            if len(t) == 0: r[i][j] = 0\n            if len(t) == 2:\n                op[t[0]].append(t[1])\n                op[t[1]].append(t[0])\n                r[i][j] = 5\n            if len(t) == 4:\n                op[t[0]].append(t[1])\n                op[t[1]].append(t[0])\n                op[t[2]].append(t[3])\n                op[t[3]].append(t[2])\n                r[i][j] = 10\n\nfor a in range(m):\n    for b in range(n):\n        if r[a][b] == -1:\n            r[a][b] = 1;st = [(a, b)]\n            while st:\n                i,j = st.pop()\n                for x,y in op[(i,j)]:\n                    if r[x][y] == -1:r[x][y] = 5 - r[i][j];st.append((x, y))\n                    else:\n                        if r[x][y] != 5 - r[i][j]:print('NO');exit()\nprint('YES')\nfor i in range(m):print (' '.join('1' if r[i][j] == -1 else str(r[i][j]) for j in range(n)))"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[4] = {1, -1, 0, 0}, dy[4] = {0, 0, 1, -1};\nint n, m, a[505][505];\nchar s[505][505];\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%s\", s[i] + 1);\n  for (int i = 1; i <= n; i++) {\n    int col = 0;\n    for (int j = 1; j <= m; j++) {\n      if (s[i][j] == '.') a[i][j] = ((i + col) & 1) ? 1 : 4;\n      if (s[i][j] == 'X') {\n        int cnt = 0;\n        for (int k = 0; k < 4; k++) cnt += s[i + dx[k]][j + dy[k]] == '.';\n        if (cnt & 1) {\n          puts(\"NO\");\n          return 0;\n        }\n        if (s[i - 1][j] == 'X') col ^= 1;\n      }\n    }\n  }\n  puts(\"YES\");\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++)\n      if (s[i][j] == 'X') {\n        int cnt = 0;\n        for (int k = 0; k < 4; k++) cnt += a[i + dx[k]][j + dy[k]];\n        printf(\"%d \", cnt);\n      } else\n        printf(\"%d \", a[i][j]);\n    puts(\"\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n, m;\n  cin >> n >> m;\n  vector<vector<int>> g(n, vector<int>(m));\n  for (int i = 0; i < n; ++i) {\n    string line;\n    cin >> line;\n    for (int j = 0; j < m; ++j) {\n      if (line[j] == 'X') {\n        g[i][j] = 1;\n      }\n    }\n  }\n  vector<vector<int>> gr(n * m);\n  const vector<int> di = {0, 1, 0, -1};\n  const vector<int> dj = {1, 0, -1, 0};\n  for (int i = 1; i < n - 1; ++i) {\n    for (int j = 1; j < m - 1; ++j) {\n      if (!g[i][j]) {\n        continue;\n      }\n      vector<int> nxt;\n      for (int d = 0; d < 4; ++d) {\n        int ni = i + di[d];\n        int nj = j + dj[d];\n        if (!g[ni][nj]) {\n          nxt.push_back(ni * m + nj);\n        }\n      }\n      int sz = (int)nxt.size();\n      if (sz & 1) {\n        cout << \"NO\" << '\\n';\n        return 0;\n      }\n      for (int k = 0; k < sz; ++k) {\n        auto ae = [&](int u, int v) {\n          gr[u].push_back(v);\n          gr[v].push_back(u);\n        };\n        ae(nxt[k], nxt[(k + 1) % sz]);\n      }\n    }\n  }\n  vector<int> c(n * m);\n  vector<bool> vis(n * m);\n  for (int i = 0; i < n * m; ++i) {\n    if (!vis[i]) {\n      function<void(int)> dfs = [&](int u) {\n        vis[u] = true;\n        for (int v : gr[u]) {\n          if (!vis[v]) {\n            c[v] = c[u] ^ 1;\n            dfs(v);\n          }\n        }\n      };\n      dfs(i);\n    }\n  }\n  cout << \"YES\" << '\\n';\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      int v = 0;\n      if (g[i][j]) {\n        for (int d = 0; d < 4; ++d) {\n          int ni = i + di[d];\n          int nj = j + dj[d];\n          if (!g[ni][nj]) {\n            v += c[ni * m + nj] * 3 + 1;\n          }\n        }\n      } else {\n        v = c[i * m + j] * 3 + 1;\n      }\n      cout << v << ' ';\n    }\n    cout << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1e9 + 7;\nvector<pair<int, int> > adj[502][502];\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\nint a[502][502];\nbitset<502> vis[502];\nvector<pair<int, int> > lol = {{0, 1}, {1, 2}, {0, 3}, {2, 3}};\nvoid dfs(int i, int j, bool f) {\n  vis[i][j] = 1;\n  if (f)\n    a[i][j] = 1;\n  else\n    a[i][j] = 4;\n  for (auto it : adj[i][j]) {\n    if (!vis[it.first][it.second]) dfs(it.first, it.second, !f);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  string s[n];\n  for (int i = 0; i < n; ++i) cin >> s[i];\n  for (int i = 1; i < n; ++i) {\n    for (int j = 1; j < m; ++j) {\n      if (s[i][j] == '.') continue;\n      vector<pair<int, int> > v;\n      for (int k = 0; k < 4; ++k) {\n        if (s[i + dx[k]][j + dy[k]] == '.')\n          v.emplace_back(i + dx[k], j + dy[k]);\n      }\n      if (v.size() & 1) {\n        cout << \"NO\\n\";\n        return 0;\n      }\n      a[i][j] = (v.size() / 2) * 5;\n      if (v.size() == 0) continue;\n      if (v.size() == 2) {\n        adj[v[0].first][v[0].second].emplace_back(v[1].first, v[1].second);\n        adj[v[1].first][v[1].second].emplace_back(v[0].first, v[0].second);\n        continue;\n      }\n      for (pair<int, int> it : lol) {\n        adj[v[it.first].first][v[it.first].second].emplace_back(\n            v[it.second].first, v[it.second].second);\n        adj[v[it.second].first][v[it.second].second].emplace_back(\n            v[it.first].first, v[it.first].second);\n      }\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      if (s[i][j] == 'X') continue;\n      if (!vis[i][j]) dfs(i, j, 0);\n    }\n  }\n  cout << \"YES\\n\";\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) cout << a[i][j] << \" \";\n    cout << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 510, M = 1000010;\nconst int dx[] = {0, 0, 0, 1, -1}, dy[] = {0, 1, -1, 0, 0};\nint n, m, tot, a[N][N], b[M], head[M], pos[3];\nbool flag;\nchar ch;\nstruct edge {\n  int next, to;\n} e[M];\nint ID(int x, int y) { return (x - 1) * m + y; }\nvoid add(int from, int to) {\n  e[++tot] = (edge){head[from], to};\n  head[from] = tot;\n  swap(from, to);\n  e[++tot] = (edge){head[from], to};\n  head[from] = tot;\n}\nvoid dfs(int x, int val) {\n  b[x] = val;\n  for (int i = head[x]; ~i; i = e[i].next) {\n    int v = e[i].to;\n    if (!b[v]) dfs(v, 5 - val);\n    if (b[x] == b[v]) flag = 1;\n    if (flag) return;\n  }\n}\nint main() {\n  memset(head, -1, sizeof(head));\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) {\n      while (ch = getchar())\n        if (ch == '.' || ch == 'X') break;\n      if (ch == 'X') a[i][j] = 1;\n    }\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      if (a[i][j]) {\n        int sum = 4;\n        for (int k = 1; k <= 4; k++) sum -= a[i + dx[k]][j + dy[k]];\n        if (sum & 1) return printf(\"NO\"), 0;\n        if (sum == 2) {\n          int tp = 0;\n          for (int k = 1; k <= 4; k++)\n            if (!a[i + dx[k]][j + dy[k]]) pos[++tp] = ID(i + dx[k], j + dy[k]);\n          add(pos[1], pos[2]);\n        }\n        if (sum == 4) {\n          add(ID(i - 1, j), ID(i, j - 1));\n          add(ID(i - 1, j), ID(i, j + 1));\n          add(ID(i + 1, j), ID(i, j - 1));\n          add(ID(i + 1, j), ID(i, j + 1));\n        }\n      }\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      if (!a[i][j] && !b[ID(i, j)]) dfs(ID(i, j), 1);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      if (a[i][j])\n        for (int k = 1; k <= 4; k++) {\n          int x = i + dx[k], y = j + dy[k];\n          if (!a[x][y]) b[ID(i, j)] += b[ID(x, y)];\n        }\n  cout << \"YES\\n\";\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) cout << b[ID(i, j)] << \" \";\n    cout << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing u32 = unsigned int;\nusing Graph = vector<vector<vector<pair<int, int>>>>;\nvoid solve(int test_number) {\n  test_number = test_number;\n  int n, m;\n  cin >> n >> m;\n  vector<string> grid(n);\n  for (int i = 0; i < n; ++i) cin >> grid[i];\n  Graph g(n, vector<vector<pair<int, int>>>(m));\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j) {\n      grid[i][j] = (grid[i][j] == 'X');\n      g[i][j] = vector<pair<int, int>>();\n    }\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j) {\n      if (!grid[i][j]) continue;\n      int count = grid[i + 1][j] + grid[i - 1][j];\n      count += grid[i][j + 1] + grid[i][j - 1];\n      if (count & 1) {\n        cout << \"NO\" << '\\n';\n        return;\n      }\n      for (int x = -1; x <= 1; x += 2)\n        for (int y = -1; y <= 1; y += 2) {\n          if (!grid[i + x][j] && !grid[i][j + y]) {\n            g[i + x][j].emplace_back(i, j + y);\n            g[i][j + y].emplace_back(i + x, j);\n          }\n        }\n      if (count > 0) {\n        if (!grid[i + 1][j] && !grid[i - 1][j]) {\n          g[i + 1][j].emplace_back(i - 1, j);\n          g[i - 1][j].emplace_back(i + 1, j);\n        }\n        if (!grid[i][j + 1] && !grid[i][j + 1]) {\n          g[i][j + 1].emplace_back(i, j - 1);\n          g[i][j - 1].emplace_back(i, j + 1);\n        }\n      }\n    }\n  vector<vector<int>> sol(n, vector<int>(m, -1));\n  function<void(int, int)> two_color_component = [&](int i, int j) {\n    for (auto [ui, uj] : g[i][j]) {\n      if (sol[ui][uj] == -1) {\n        sol[ui][uj] = (sol[i][j] == 1) ? 4 : 1;\n        two_color_component(ui, uj);\n      }\n    }\n  };\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j) {\n      if (grid[i][j]) continue;\n      if (sol[i][j] == -1) {\n        sol[i][j] = 4;\n        two_color_component(i, j);\n      }\n    }\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j) {\n      if (grid[i][j]) {\n        int count = grid[i + 1][j] + grid[i - 1][j];\n        count += grid[i][j + 1] + grid[i][j - 1];\n        sol[i][j] = 5 * (4 - count) / 2;\n      }\n    }\n  cout << \"YES\" << '\\n';\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      cout << sol[i][j] << \" \";\n    }\n    cout << '\\n';\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int T = 1;\n  for (int i = 1; i <= T; ++i) solve(i);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 510;\nint n, m;\nchar mp[N][N];\nint ans[N][N];\nint dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\nint main() {\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) cin >> mp[i][j];\n  int p;\n  for (int i = 1; i <= n; i++) {\n    p = 0;\n    for (int j = 1; j <= m; j++) {\n      if (mp[i][j] == 'X') {\n        p ^= (mp[i - 1][j] == 'X');\n        int cnt = 0;\n        for (int k = 0; k < 4; k++) {\n          if (mp[i + dx[k]][j + dy[k]] == '.') cnt++;\n        }\n        if (cnt & 1) {\n          cout << \"NO\" << endl;\n          return 0;\n        }\n      } else {\n        ans[i][j] = (j + p) % 2 ? 1 : 4;\n      }\n    }\n  }\n  cout << \"YES\" << endl;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      if (mp[i][j] == 'X') {\n        int s = 0;\n        for (int k = 0; k < 4; k++) {\n          if (mp[i + dx[k]][j + dy[k]] == '.') s += ans[i + dx[k]][j + dy[k]];\n        }\n        cout << s << ' ';\n      } else\n        cout << ans[i][j] << ' ';\n    }\n    cout << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<int, int> > e[505][505];\nchar c[505][505];\nint t[4][2] = {{0, -1}, {1, 0}, {0, 1}, {-1, 0}};\nint col[505][505];\nvoid dfs(int x, int y, int cl) {\n  col[x][y] = cl;\n  for (int i = 0; i < e[x][y].size(); i++) {\n    int xx = e[x][y][i].first, yy = e[x][y][i].second;\n    if (!col[xx][yy]) dfs(xx, yy, 5 - cl);\n  }\n}\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) cin >> c[i] + 1;\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      if (c[i][j] == 'X') {\n        vector<pair<int, int> > cur;\n        for (int k = 0; k <= 3; k++) {\n          if (c[i + t[k][0]][j + t[k][1]] == '.')\n            cur.push_back(make_pair(i + t[k][0], j + t[k][1]));\n        }\n        if (cur.size() & 1) {\n          puts(\"NO\");\n          return 0;\n        }\n        if (!cur.size()) continue;\n        cur.push_back(cur[0]);\n        for (int k = 1; k < cur.size(); k++) {\n          e[cur[k].first][cur[k].second].push_back(cur[k - 1]);\n          e[cur[k - 1].first][cur[k - 1].second].push_back(cur[k]);\n        }\n      }\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) {\n      if (c[i][j] == '.' && !col[i][j]) {\n        dfs(i, j, 1);\n      }\n    }\n  puts(\"YES\");\n  for (int i = 1; i <= n; i++, puts(\"\"))\n    for (int j = 1; j <= m; j++)\n      if (c[i][j] == 'X') {\n        for (int k = 0; k <= 3; k++) {\n          if (c[i + t[k][0]][j + t[k][1]] == '.')\n            col[i][j] += col[i + t[k][0]][j + t[k][1]];\n        }\n        printf(\"%d \", col[i][j]);\n      } else\n        printf(\"%d \", col[i][j]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T1, typename T2>\ninline ostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n  return os << \"(\" << p.first << \", \" << p.second << \")\";\n}\ntemplate <typename T, size_t N>\ninline ostream &operator<<(ostream &os, const array<T, N> &a) {\n  os << \"[\";\n  int cnt = 0;\n  for (auto &val : a) {\n    if (cnt++) os << \", \";\n    os << val;\n  }\n  os << \"]\";\n  return os;\n}\ntemplate <typename T>\ninline ostream &operator<<(ostream &os, const vector<T> &v) {\n  os << \"[\";\n  int cnt = 0;\n  for (auto &val : v) {\n    if (cnt++) os << \", \";\n    os << val;\n  }\n  return os << \"]\";\n}\ntemplate <typename T>\ninline ostream &operator<<(ostream &os, const set<T> &v) {\n  os << \"{\";\n  int cnt = 0;\n  for (auto &val : v) {\n    if (cnt++) os << \", \";\n    os << val;\n  }\n  return os << \"}\";\n}\ntemplate <typename T>\ninline ostream &operator<<(ostream &os, const unordered_set<T> &v) {\n  os << \"{\";\n  int cnt = 0;\n  for (auto &val : v) {\n    if (cnt++) os << \", \";\n    os << val;\n  }\n  return os << \"}\";\n}\ntemplate <typename T>\ninline ostream &operator<<(ostream &os, const multiset<T> &v) {\n  os << \"{\";\n  int cnt = 0;\n  for (auto &val : v) {\n    if (cnt++) os << \", \";\n    os << val;\n  }\n  return os << \"}\";\n}\ntemplate <typename T1, typename T2>\ninline ostream &operator<<(ostream &os, const map<T1, T2> &v) {\n  os << \"[\";\n  int cnt = 0;\n  for (auto &val : v) {\n    if (cnt++) os << \", \";\n    os << val;\n  }\n  return os << \"]\";\n}\ntemplate <typename Arg1>\nvoid __f(const char *name, Arg1 &&arg1) {\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char *names, Arg1 &&arg1, Args &&...args) {\n  const char *comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vll = vector<long long>;\nusing vvi = vector<vector<int>>;\nusing vs = vector<string>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vvb = vector<vector<bool>>;\nusing vvc = vector<vector<char>>;\nusing vc = vector<char>;\nusing si = set<int>;\nusing mpii = map<int, int>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nconst char nl = '\\n';\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ntemplate <class T>\ninline bool umin(T &a, const T b) {\n  return b < a ? a = b, 1 : 0;\n}\ntemplate <class T>\ninline bool umax(T &a, const T b) {\n  return a < b ? a = b, 1 : 0;\n}\nint n, m;\nvoid solve() {\n  vvc a(n, vc(m));\n  for (int i = 0; i < (n); i++)\n    for (int j = 0; j < (m); j++) cin >> a[i][j];\n  int nodes = n * m;\n  vvi g(nodes, vi());\n  for (int i = 1; i < n - 1; i++) {\n    for (int j = 1; j < m - 1; j++) {\n      if (a[i][j] == 'X') {\n        vi neis;\n        for (int k = 0; k < (4); k++) {\n          int x = i + dx[k];\n          int y = j + dy[k];\n          if (a[x][y] == '.') {\n            neis.emplace_back(x * m + y);\n          }\n        }\n        int cnt = ((int)(neis).size());\n        if (cnt & 1) {\n          cout << \"NO\" << nl;\n          return;\n        }\n        if (cnt == 2) {\n          g[neis[0]].emplace_back(neis[1]);\n          g[neis[1]].emplace_back(neis[0]);\n        } else if (cnt == 4) {\n          for (int k = 0; k < (cnt); k++) {\n            g[neis[k]].emplace_back(neis[(k + 1) % cnt]);\n            g[neis[(k + 1) % cnt]].emplace_back(neis[k]);\n          }\n        }\n      }\n    }\n  }\n  function<bool(int, int, char)> dfs = [&](int u, int fa, char c) -> bool {\n    a[u / m][u % m] = c;\n    char nc = (c == '1' ? '4' : '1');\n    for (int v : g[u]) {\n      if (v == fa) continue;\n      if (a[v / m][v % m] == c) return false;\n      if (a[v / m][v % m] == '.') {\n        if (!dfs(v, u, nc)) return false;\n      }\n    }\n    return true;\n  };\n  for (int i = 0; i < (n); i++)\n    for (int j = 0; j < (m); j++) {\n      if (a[i][j] == '.') {\n        if (!dfs(i * m + j, -1, '1')) {\n          cout << \"NO\" << nl;\n          return;\n        }\n      }\n    }\n  cout << \"YES\" << nl;\n  for (int i = 0; i < (n); i++)\n    for (int j = 0; j < (m); j++) {\n      if (a[i][j] == 'X') {\n        int cnt = 0;\n        for (int k = 0; k < (4); k++) {\n          int x = i + dx[k];\n          int y = j + dy[k];\n          if (a[x][y] != 'X') cnt++;\n        }\n        cout << 5 * cnt / 2;\n      } else {\n        cout << a[i][j];\n      }\n      cout << \" \\n\"[j == m - 1];\n    }\n}\nvoid solve(int _cas) { solve(); }\nint main() {\n  srand(time(NULL));\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL), cout.tie(NULL), cout.precision(12);\n  while (cin >> n >> m) solve(1);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nostream& operator<<(ostream& out, vector<T>& v) {\n  out << \"[\";\n  for (auto k : v) out << k << \",\";\n  out << \"]\"\n      << \"\\n\";\n  return out;\n}\ntemplate <class T>\nostream& operator<<(ostream& out, set<T> s) {\n  out << \"{\";\n  for (auto k : s) out << k << \",\";\n  out << \"}\"\n      << \"\\n\";\n  return out;\n}\ntemplate <class T, class U>\nostream& operator<<(ostream& out, pair<T, U> p) {\n  out << \"[ \" << p.first << \" , \" << p.second << \" ] \";\n  return out;\n}\ntemplate <class T, class U>\nistream& operator>>(istream& in, pair<T, U>& p) {\n  in >> p.first >> p.second;\n  return in;\n}\nint dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\nvoid DFS(int i, int j, int c, vector<string>& in,\n         vector<vector<vector<pair<int, int> > > >& adj,\n         vector<vector<int> >& res) {\n  if (res[i][j] != -1) return;\n  if (in[i][j] == 'X') return;\n  res[i][j] = c;\n  for (auto p : adj[i][j]) DFS(p.first, p.second, 5 - c, in, adj, res);\n}\nint main() {\n  cin.tie(0);\n  cin.sync_with_stdio(0);\n  int N, M;\n  cin >> N >> M;\n  vector<vector<int> > res(N, vector<int>(M, -1));\n  vector<string> in(N);\n  vector<vector<vector<pair<int, int> > > > adj(\n      N, vector<vector<pair<int, int> > >(M));\n  for (int i = 0; i < int(N); i++) {\n    cin >> in[i];\n  }\n  bool ok = true;\n  for (int i = 0; i < int(N); i++) {\n    for (int j = 0; j < int(M); j++) {\n      if (in[i][j] == 'X') {\n        int v = 0;\n        for (int k = 0; k < int(4); k++) {\n          int i2 = i + dy[k];\n          int j2 = j + dx[k];\n          if (((j2 >= 0) and (j2 < M) and (i2 >= 0) and (i2 < N)) and\n              in[i2][j2] == '.')\n            v++;\n        }\n        if (v % 2 == 1) ok = false;\n        bool dig = false;\n        for (int k = 0; k < int(4); k++) {\n          int i2 = i + dy[k], j2 = j + dx[k];\n          int i3 = i + dy[(k + 1) % 4], j3 = j + dx[(k + 1) % 4];\n          if (((j2 >= 0) and (j2 < M) and (i2 >= 0) and (i2 < N)) and\n              ((j3 >= 0) and (j3 < M) and (i3 >= 0) and (i3 < N)) and\n              in[i2][j2] == '.' and in[i3][j3] == '.') {\n            dig = true;\n            adj[i2][j2].push_back({i3, j3});\n            adj[i3][j3].push_back({i2, j2});\n          }\n        }\n        if (!dig) {\n          for (int k = 0; k < int(2); k++) {\n            int i2 = i + dy[k], j2 = j + dx[k];\n            int i3 = i + dy[(k + 2) % 4], j3 = j + dx[(k + 2) % 4];\n            if (((j2 >= 0) and (j2 < M) and (i2 >= 0) and (i2 < N)) and\n                ((j3 >= 0) and (j3 < M) and (i3 >= 0) and (i3 < N)) and\n                in[i2][j2] == '.' and in[i3][j3] == '.') {\n              adj[i2][j2].push_back({i3, j3});\n              adj[i3][j3].push_back({i2, j2});\n            }\n          }\n        }\n      }\n    }\n  }\n  if (!ok) {\n    cout << \"NO\\n\";\n    return 0;\n  }\n  for (int i = 0; i < int(N); i++)\n    for (int j = 0; j < int(M); j++) DFS(i, j, 1, in, adj, res);\n  for (int i = 0; i < int(N); i++)\n    for (int j = 0; j < int(M); j++)\n      if (in[i][j] == 'X') {\n        res[i][j] = 0;\n        for (int k = 0; k < int(4); k++) {\n          int i2 = i + dy[k], j2 = j + dx[k];\n          if (((j2 >= 0) and (j2 < M) and (i2 >= 0) and (i2 < N)) and\n              in[i2][j2] == '.')\n            res[i][j] += res[i2][j2];\n        }\n      }\n  cout << \"YES\" << '\\n';\n  for (int i = 0; i < int(N); i++) {\n    for (int j = 0; j < int(M); j++) cout << res[i][j] << \" \";\n    cout << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC target(\"avx2,fma\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nlong long IOS = []() {\n  ios::sync_with_stdio(0);\n  std::cin.tie(nullptr);\n  std::cout.tie(nullptr);\n  return 0;\n}();\ntemplate <class T>\nvoid _W(const T &x) {\n  cout << x;\n}\ntemplate <class T>\nvoid _W(T &x) {\n  cout << x;\n}\ntemplate <class T, class U>\nvoid _W(const pair<T, U> &x) {\n  _W(x.first);\n  putchar(' ');\n  _W(x.second);\n}\ntemplate <class T>\nvoid _W(const vector<T> &x) {\n  for (auto i = x.begin(); i != x.end(); _W(*i++)) cout << ' ';\n}\nvoid W() {}\ntemplate <class T, class... U>\nvoid W(const T &head, const U &...tail) {\n  _W(head);\n  cout << \", \";\n  W(tail...);\n}\ninline string cn(long long i) {\n  stringstream ss;\n  ss << i;\n  return ss.str();\n}\nconst long long N = 5e2 + 10;\nlong long tr[N];\nlong long n, m;\nchar mp[N][N];\nlong long t[N][N];\nlong long vis[N][N], ans[N][N];\nlong long dir[10] = {1, 0, -1, 0, 0, 1, 0, -1};\nvoid build(long long u, long long l, long long r) {\n  if (l == r) {\n    tr[u] = 0;\n    return;\n  }\n  long long mid = l + r >> 1;\n  build(u << 1, l, mid);\n  build(u << 1 | 1, mid + 1, r);\n}\nlong long judge(long long x, long long y) {\n  long long ans = 0;\n  for (long long i = 0; i < 4; i++) {\n    if (mp[x + dir[2 * i]][y + dir[2 * i + 1]] == '.') ans++;\n  }\n  return ans;\n}\nvoid dfs(long long x, long long y, long long k, long long d) {\n  vis[x][y] = 1;\n  if (k == 1) {\n    for (long long i = 0; i < 4; i++) {\n      if (mp[x + dir[2 * i]][y + dir[2 * i + 1]] == 'X' &&\n          vis[x + dir[2 * i]][y + dir[2 * i + 1]] == 0) {\n        dfs(x + dir[2 * i], y + dir[2 * i + 1], 0, d);\n      }\n    }\n  } else {\n    if (t[x][y] == 2) {\n      for (long long i = 0; i < 4; i++) {\n        if (mp[x + dir[2 * i]][y + dir[2 * i + 1]] == '.' &&\n            vis[x + dir[2 * i]][y + dir[2 * i + 1]] == 0) {\n          ans[x + dir[2 * i]][y + dir[2 * i + 1]] = 5 - d;\n          dfs(x + dir[2 * i], y + dir[2 * i + 1], 1, 5 - d);\n        }\n      }\n    } else {\n      if (vis[x - 1][y]) {\n        ans[x + 1][y] = ans[x - 1][y];\n        ans[x][y + 1] = ans[x][y - 1] = 5 - ans[x - 1][y];\n      } else if (vis[x + 1][y]) {\n        ans[x - 1][y] = ans[x + 1][y];\n        ans[x][y + 1] = ans[x][y - 1] = 5 - ans[x + 1][y];\n      } else if (vis[x][y + 1]) {\n        ans[x][y - 1] = ans[x][y + 1];\n        ans[x - 1][y] = ans[x + 1][y] = 5 - ans[x][y + 1];\n      } else {\n        ans[x][y + 1] = ans[x][y - 1];\n        ans[x - 1][y] = ans[x + 1][y] = 5 - ans[x][y - 1];\n      }\n      for (long long i = 0; i < 4; i++) {\n        vis[x + dir[2 * i]][y + dir[2 * i + 1]] = 1;\n      }\n      for (long long i = 0; i < 4; i++) {\n        long long xx = x + dir[2 * i], yy = y + dir[2 * i + 1];\n        dfs(xx, yy, 1, ans[x + dir[2 * i]][y + dir[2 * i + 1]]);\n      }\n    }\n  }\n}\nvoid solve() {\n  cin >> n >> m;\n  for (long long i = 1; i <= n; i++) {\n    for (long long j = 1; j <= m; j++) {\n      cin >> mp[i][j];\n    }\n  }\n  for (long long i = 1; i <= n; i++) {\n    for (long long j = 1; j <= m; j++) {\n      if (mp[i][j] == 'X') {\n        t[i][j] = judge(i, j);\n        if (t[i][j] & 1) {\n          cout << \"NO\" << '\\n';\n          return;\n        }\n        ans[i][j] = t[i][j] * 5 / 2;\n      }\n    }\n  }\n  for (long long i = 1; i <= n; i++) {\n    for (long long j = 1; j <= m; j++) {\n      if (mp[i][j] == '.') {\n        if (!vis[i][j]) {\n          ans[i][j] = 1;\n          dfs(i, j, 1, 1);\n        }\n      }\n    }\n  }\n  cout << \"YES\" << '\\n';\n  for (long long i = 1; i <= n; i++) {\n    for (long long j = 1; j <= m; j++) {\n      cout << ans[i][j] << \" \";\n    }\n    cout << '\\n';\n  }\n}\nsigned main() {\n  n = 10;\n  build(1, 1, n);\n  long long tt = 1;\n  while (tt--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid abc() { cout << endl; }\ntemplate <typename T, typename... U>\nvoid abc(T a, U... b) {\n  cout << a << ' ', abc(b...);\n}\ntemplate <typename T>\nvoid printv(T l, T r) {\n  while (l != r) cout << *l << \" \\n\"[++l == r];\n}\ntemplate <typename A, typename B>\nistream& operator>>(istream& o, pair<A, B>& a) {\n  return o >> a.first >> a.second;\n}\ntemplate <typename A, typename B>\nostream& operator<<(ostream& o, pair<A, B> a) {\n  return o << '(' << a.first << \", \" << a.second << ')';\n}\ntemplate <typename T>\nostream& operator<<(ostream& o, vector<T> a) {\n  bool is = false;\n  for (T i : a) {\n    o << (is ? ' ' : '{'), is = true, o << i;\n  }\n  return o << '}';\n}\ntemplate <typename T>\nstruct vv : vector<vector<T>> {\n  vv(int n, int m, T v) : vector<vector<T>>(n, vector<T>(m, v)) {}\n  vv() {}\n};\ntemplate <typename T>\nstruct vvv : vector<vv<T>> {\n  vvv(int n, int m, int k, T v) : vector<vv<T>>(n, vv<T>(m, k, v)) {}\n  vvv() {}\n};\nconst int mod = 998244353, N = 401, logN = 20, K = 80000;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<string> s(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> s[i];\n  }\n  vv<int> ans(n, m, -1);\n  vector<vector<int>> adj(n * m);\n  for (int i = 1; i + 1 < n; ++i)\n    for (int j = 1; j + 1 < m; ++j)\n      if (s[i][j] == 'X') {\n        vector<pair<int, int>> v;\n        if (s[i + 1][j] == '.') v.emplace_back(i + 1, j);\n        if (s[i - 1][j] == '.') v.emplace_back(i - 1, j);\n        if (s[i][j + 1] == '.') v.emplace_back(i, j + 1);\n        if (s[i][j - 1] == '.') v.emplace_back(i, j - 1);\n        if (int(v.size()) & 1) {\n          cout << \"NO\\n\";\n          return 0;\n        }\n        if (v.size() == 2) {\n          int x = v[0].first * m + v[0].second,\n              y = v[1].first * m + v[1].second;\n          adj[x].push_back(y), adj[y].push_back(x);\n          ans[i][j] = 5;\n        } else if (v.size() == 4) {\n          int x = v[0].first * m + v[0].second,\n              y = v[3].first * m + v[3].second;\n          adj[x].push_back(y), adj[y].push_back(x);\n          x = v[2].first * m + v[2].second, y = v[1].first * m + v[1].second;\n          adj[x].push_back(y), adj[y].push_back(x);\n          ans[i][j] = 10;\n        } else {\n          ans[i][j] = 0;\n        }\n      }\n  function<void(int)> dfs = [&](int v) {\n    for (int u : adj[v])\n      if (ans[u / m][u % m] == -1) {\n        ans[u / m][u % m] = 5 ^ ans[v / m][v % m];\n        dfs(u);\n      }\n  };\n  for (int i = 0; i < n * m; ++i)\n    if (!adj[i].empty() && ans[i / m][i % m] == -1) {\n      ans[i / m][i % m] = 1;\n      dfs(i);\n    }\n  cout << \"YES\\n\";\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j) {\n      if (ans[i][j] == -1)\n        cout << (i & 1 ? 1 : 4);\n      else\n        cout << ans[i][j];\n      cout << \" \\n\"[j == m - 1];\n    }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename A>\nostream &operator<<(ostream &cout, vector<A> const &v);\ntemplate <typename A, typename B>\nostream &operator<<(ostream &cout, pair<A, B> const &p) {\n  return cout << \"(\" << p.first << \", \" << p.second << \")\";\n}\ntemplate <typename A>\nostream &operator<<(ostream &cout, vector<A> const &v) {\n  cout << \"[\";\n  for (int i = 0; i < v.size(); i++) {\n    if (i) cout << \", \";\n    cout << v[i];\n  }\n  return cout << \"]\";\n}\ntemplate <typename A, typename B>\nistream &operator>>(istream &cin, pair<A, B> &p) {\n  cin >> p.first;\n  return cin >> p.second;\n}\nmt19937_64 rng(std::chrono::steady_clock::now().time_since_epoch().count());\nvoid usaco(string filename) {\n  freopen((filename + \".in\").c_str(), \"r\", stdin);\n  freopen((filename + \".out\").c_str(), \"w\", stdout);\n}\nconst long double pi = 3.14159265358979323846;\nconst long long mod = 1000000007;\nlong long n, m, q, k, l, r, x, y, z;\nconst long long template_array_size = 1e6 + 17598;\nlong long a[template_array_size];\nlong long b[template_array_size];\nlong long c[template_array_size];\nstring second, t;\nstring mat[505];\nlong long dr[4] = {0, 0, 1, -1};\nlong long dc[4] = {1, -1, 0, 0};\nlong long ret[505][505];\nbool vis[300005];\nlong long col[300005];\nvector<pair<long long, long long>> edges[300005];\nlong long id(long long r, long long c) { return r * m + c; }\nvoid edge(long long a, long long b, long long c) {\n  edges[a].push_back({b, c});\n  edges[b].push_back({a, c});\n}\nbool dfs(long long v, long long c) {\n  if (vis[v]) return 1;\n  vis[v] = 1;\n  col[v] = c;\n  for (pair<long long, long long> x : edges[v]) {\n    if (vis[x.first]) {\n      if ((col[v] ^ col[x.first]) != x.second) {\n        return 0;\n      }\n    } else {\n      dfs(x.first, col[v] ^ x.second);\n    }\n  }\n  return 1;\n}\nvoid solve(int tc = 0) {\n  cin >> n >> m;\n  for (long long i = 0; i < n; i++) cin >> mat[i];\n  bool pos = 1;\n  for (long long i = 0; i < n; i++) {\n    for (long long j = 0; j < m; j++) {\n      if (mat[i][j] == 'X') {\n        long long cnt = 0;\n        vector<long long> p;\n        for (long long d = 0; d < 4; d++) {\n          long long ni = i + dr[d], nj = j + dc[d];\n          if (mat[ni][nj] == '.') {\n            ++cnt;\n            p.push_back(d);\n          }\n        }\n        if (cnt % 2 == 1) {\n          pos = 0;\n          break;\n        } else if (cnt == 2) {\n          long long a = id(i + dr[p[0]], j + dc[p[0]]);\n          long long b = id(i + dr[p[1]], j + dc[p[1]]);\n          edge(a, b, 1);\n        } else if (cnt == 4) {\n          edge(id(i - 1, j), id(i + 1, j), 0);\n          edge(id(i, j - 1), id(i, j + 1), 0);\n          edge(id(i - 1, j), id(i, j - 1), 1);\n        }\n        ret[i][j] = 5 * (cnt / 2);\n      }\n    }\n  }\n  if (!pos) {\n    cout << \"NO\\n\";\n    return;\n  }\n  for (long long i = 0; i < n; i++) {\n    for (long long j = 0; j < m; j++) {\n      if (mat[i][j] != 'X') {\n        long long v = id(i, j);\n        if (!vis[v]) {\n          if (!dfs(v, 0)) {\n            cout << \"NO\\n\";\n            return;\n          }\n        }\n      }\n    }\n  }\n  for (long long i = 0; i < n; i++) {\n    for (long long j = 0; j < m; j++) {\n      if (mat[i][j] != 'X') {\n        long long v = id(i, j);\n        ret[i][j] = 1 + 3 * col[v];\n      }\n    }\n  }\n  cout << \"YES\\n\";\n  for (long long i = 0; i < n; i++) {\n    for (long long j = 0; j < m; j++) {\n      cout << ret[i][j] << \" \";\n    }\n    cout << '\\n';\n  }\n}\nint main() {\n  { ios_base::sync_with_stdio(false); }\n  { cin.tie(NULL); }\n  cout << setprecision(15) << fixed;\n  int tc = 1;\n  for (int t = 0; t < tc; t++) {\n    solve(t);\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "// Don't place your source in a package\n\n\nimport javax.swing.*;\nimport java.lang.reflect.Array;\nimport java.text.DecimalFormat;\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.*;\nimport java.util.stream.Stream;\n\n\n\n// Please name your class Main\npublic class Main {\n    static FastScanner fs=new FastScanner();\n    static class FastScanner {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(\"\");\n        public String next() {\n            while (!st.hasMoreElements())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n        int Int() {\n            return Integer.parseInt(next());\n        }\n\n        long Long() {\n            return Long.parseLong(next());\n        }\n\n        String Str(){\n            return next();\n        }\n    }\n\n\n    public static void main (String[] args) throws java.lang.Exception {\n        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        //reading /writing file\n        //Scanner sc=new Scanner(new File(\"src/text.txt\"));\n        //PrintWriter pr=new PrintWriter(\"output.txt\");\n        //File file = new File(\"src/text.txt\");\n\n\n\n        int T=1;\n        for(int t=0;t<T;t++){\n            int n=Int();int m=Int();\n            char A[][]=new char[n][m];\n            for(int i=0;i<A.length;i++){\n                String s=Str();\n                A[i]=s.toCharArray();\n            }\n\n            Solution sol1=new Solution(out);\n            sol1.solution(A);\n        }\n        out.close();\n\n    }\n\n\n    public static int[] Arr(int n){\n        int A[]=new int[n];\n        for(int i=0;i<n;i++)A[i]=Int();\n        return A;\n    }\n    public static int Int(){\n        return fs.Int();\n    }\n    public static long Long(){\n        return fs.Long();\n    }\n    public static String Str(){\n        return fs.Str();\n    }\n\n}\n\n\n\n\n\n\n\n\nclass Solution {\n    PrintWriter out;\n    int INF = Integer.MAX_VALUE;\n    int MOD = 1000000007;\n    long mod = 1000000007;\n\n    public Solution(PrintWriter out) {\n        this.out = out;\n    }\n\n\n    int dir[][]=new int[][]{{-1,0},{0,-1},{1,0},{0,1}};\n    boolean seen[][];\n    int res[][];\n    public void solution(char A[][]) {\n\n        int n = A.length,m=A[0].length;\n\n\n        seen=new boolean[n][m];\n        res=new int[n][m];\n\n        for(int i =0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(A[i][j]!='X')continue;\n                int cnt = 0;\n                for(int k=0;k<4;k++){\n                    int p[]=dir[k];\n                    int x = i+p[0];\n                    int y = j +p[1];\n                    if(x<0||y<0||x>=n||y>=m)continue;\n                    if(A[x][y]=='.'){\n                        cnt++;\n                    }\n                }\n\n                if(cnt%2==1){\n                    out.println(\"NO\");\n                    return;\n                }\n                dfs(A,i,j);\n            }\n        }\n\n\n        /*for(int p[]:res){\n            System.out.println(Arrays.toString(p));\n        }\n        System.out.println();*/\n\n\n\n        out.println(\"YES\");\n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(A[i][j]=='X'){\n                    int sum = 0;\n                    for(int p[]:dir){\n                        int x = i+p[0];\n                        int y = j +p[1];\n                        if(x<0||y<0||x>=n||y>=m||A[x][y]=='X')continue;\n                        sum+=res[x][y];\n                    }\n                    res[i][j]=sum;\n                }\n                if(A[i][j]=='.'&&res[i][j]==0){//assign random numberr\n                    res[i][j]=4;\n                }\n                out.print(res[i][j]+\" \");\n            }\n            out.println();\n        }\n    }\n\n    public void dfs(char A[][],int i,int j){\n        int n =A.length,m=A[0].length;\n        if(i<0||j<0||i>=n||j>=m)return;\n        if(A[i][j]=='.'||seen[i][j])return;\n        seen[i][j]=true;\n\n\n        List<int[]>list=new ArrayList<>();\n        for(int k=0;k<4;k++){\n            int p[]=dir[k];\n            int x = i+p[0];\n            int y = j +p[1];\n            if(x<0||y<0||x>=n||y>=m)continue;\n            if(A[x][y]=='.'){\n                list.add(new int[]{x,y});\n            }\n        }\n\n\n\n        if(list.size()!=2&&list.size()!=4){\n            return;\n        }\n\n        if(list.size()==2){\n            int p1[]=list.get(0);\n            int p2[]=list.get(1);\n            if(res[p1[0]][p1[1]]!=0&&res[p2[0]][p2[1]]!=0){\n\n            }\n            else if(res[p1[0]][p1[1]]==0&&res[p2[0]][p2[1]]==0){\n                res[p1[0]][p1[1]]=1;\n                res[p2[0]][p2[1]]=4;\n            }\n            else if(res[p1[0]][p1[1]]==0&&res[p2[0]][p2[1]]==1){\n                res[p1[0]][p1[1]]=4;\n            }\n            else if(res[p1[0]][p1[1]]==0&&res[p2[0]][p2[1]]==4){\n                res[p1[0]][p1[1]]=1;\n            }\n            else if(res[p1[0]][p1[1]]==1&&res[p2[0]][p2[1]]==0){\n                res[p2[0]][p2[1]]=4;\n            }\n            else if(res[p1[0]][p1[1]]==4&&res[p2[0]][p2[1]]==0){\n                res[p2[0]][p2[1]]=1;\n            }\n\n            for(int p[]:list){\n                int x=p[0],y=p[1];\n                for(int pp[]:dir){\n                    int xx=x+pp[0];\n                    int yy=y+pp[1];\n                    dfs(A,xx,yy);\n                }\n            }\n        }\n        else{\n            boolean flag = true;\n            boolean a = false;\n            for(int k=0;k<list.size();k++){\n                int p[]=list.get(k);\n                if(res[p[0]][p[1]]!=0){\n                    flag=false;\n                    //1 4 1 4 or 4 1 4 1\n                    if(k%2==0){\n                        if(res[p[0]][p[1]]==1)a=true;\n                    }\n                    else{\n                        if(res[p[0]][p[1]]==4)a=true;\n                    }\n                }\n                else{\n\n                }\n            }\n\n            if(flag){\n                for(int k=0;k<list.size();k++){\n                    int p[]=list.get(k);\n                    if(k%2==0){\n                        res[p[0]][p[1]]=1;\n                    }\n                    else{\n                        res[p[0]][p[1]]=4;\n                    }\n                }\n            }\n            else{\n\n                for(int k=0;k<list.size();k++){\n                    int p[]=list.get(k);\n                    if(k%2==0){\n                        if(a)res[p[0]][p[1]]=1;\n                        else res[p[0]][p[1]]=4;\n                    }\n                    else{\n                        if(a)res[p[0]][p[1]]=4;\n                        else res[p[0]][p[1]]=1;\n                    }\n                }\n            }\n\n            for(int p[]:list){\n                int x=p[0],y=p[1];\n                for(int pp[]:dir){\n                    int xx=x+pp[0];\n                    int yy=y+pp[1];\n                    dfs(A,xx,yy);\n                }\n            }\n        }\n\n\n    }\n\n}\n\n/*\n.......................\n...XXXXX.XXX..XXXXXXX..\n...X...X.X.X..X.....X..\n.XXXXX.X.XXX..X.XXX.X..\n.X.X.X.X......X.X.X.X..\n.X.XXXXX..XXXXXXXXX.X..\n.X...X....X...X.X...X..\n.X.XXXXX..X.XXXXXXXXX..\n.X.X.X.X..X.X.X.X......\n.XXXXX.X..X.XXX.X.XX...\n...X...X..X.....X.XXX..\n...XXXXX..XXXXXXX..XXX.\n........XX..........XX.\n........XX.............\n.X.X.X.X..XXXXX.XXXXX..\n..X.X.X...X...X.X...X..\n.X.X.X.X..X.XXXXXXX.X..\n..X.X.X...X.X.X.X.X.X..\n.X.X.X.X..XXXXX.XXXXX..\n............x.....x....\n* */\n\n/*\n.......X...X...........\n.XXXXX.X.X.X.X.X.X.X...\n.X...X.X...X..X...X.X..\n.X.X.X.XXXXX...X...X...\n.X...X......XX.........\n* */\n\n\n/*\n....................... 1\n...XXXXX.XXX..XXXXXXX.. 2\n...X...X.X.X..X.....X.. 3\n.XXXXX.X.XXX..X.XXX.X.. 4\n.X.X.X.X......X.X.X.X.. 5\n.X.XXXXX..XXXXXXXXX.X.. 6\n.X...X....X...X.X...X.. 7\n.X.XXXXX..X.XXXXXXXXX.. 8\n.X.X.X.X..X.X.X.X...... 9\n.XXXXX.X..X.XXX.X.XX... 10\n...X...X..X.....X.XXX.. 11\n...XXXXX..XXXXXXX..XXX. 12\n........XX..........XX. 13\n........XX............. 14\n.X.X.X.X..XXXXX.XXXXX.. 15\n..X.X.X...X...X.X...X.. 16\n.X.X.X.X..X.XXXXXXX.X.. 17\n..X.X.X...X.X.X.X.X.X.. 18\n.X.X.X.X..XXXXX.XXXXX.. 19\n..X.X.X.....X.....X.... 20\n.X.X.X.X.X..XXXXXXX.... 21\n..X.X.X.X.............. 22\n\n\n\n....................... 1\n...X...XXXXX.X.X.X.X... 2\n.......X...X..X.X.X.X.. 3\n.XXXXX.X.X.X.X.X.X.X... 4\n.X...X.X...X..X...X.X.. 5\n.X.X.X.XXXXX...X...X... 6\n.X...X......XX..X.X.... 7\n.XXXXX...X..XX...X..... 8\n....................... 9\n* */"
        },
        {
            "language": 4,
            "solution": "import java.util.*;\nimport java.io.*;\n\npublic class F {\n\n    static PrintWriter pw;\n\n    int[][] dir = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n\n    void solve(int n, int m, char[][] g) {\n        // tr(n, m, g);\n        // List[] adj = initializeGraph(n * m);\n        List<List<Integer>> adj = initializeGraph(n * m);\n        // tr(adj);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (g[i][j] == 'X') {\n                    List<Integer> q = new ArrayList<>();\n                    for (int[] e : dir) {\n                        int x = i + e[0];\n                        int y = j + e[1];\n                        if (x < 0 || x >= n || y < 0 || y >= m) continue;\n                        if (g[x][y] == '.') {\n                            q.add(x * m + y);\n                        }\n                    }\n                    // tr(q.size());\n                    if (q.size() % 2 == 1) {\n                        pr(\"NO\");\n                        return;\n                    }\n                    for (int k = 0; k < q.size(); k += 2) {\n                        int x = q.get(k), y = q.get(k + 1);\n                        // adj[x].add(y);\n                        // adj[y].add(x);\n                        adj.get(x).add(y);\n                        adj.get(y).add(x);\n                        // tr(adj);\n                    }\n                }\n            }\n        }\n        // tr(adj);\n        List<Integer> que = new ArrayList<>();\n        int[][] res = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (res[i][j] > 0 || g[i][j] == 'X') continue;\n                res[i][j] = 1;\n                que.add(i * m + j);\n                while (que.size() > 0) {\n                    int cur = que.get(0);\n                    que.remove(0);\n                    for (Object o : adj.get(cur)) {\n                        int v = (int) o;\n                        // tr(v);\n                        if (res[v / m][v % m] == 0) {\n                            res[v / m][v % m] = res[cur / m][cur % m] ^ 5;\n                            que.add(v);\n                        }\n                    }\n                }\n            }\n        }\n        pr(\"YES\");\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (g[i][j] == 'X') {\n                    for (int[] e : dir) {\n                        int x = i + e[0];\n                        int y = j + e[1];\n                        if (x < 0 || x >= n || y < 0 || y >= m) continue;\n                        if (g[x][y] == '.') {\n                            res[i][j] += res[x][y];\n                        }\n                    }\n                }\n                if (j == m - 1) {\n                    pr(res[i][j]);\n                } else {\n                    pw.print(res[i][j] + \" \");\n                }\n            }\n        }\n    }\n\n//    List[] initializeGraph(int n) {\n//        List[] g = new ArrayList[n];\n//        Arrays.fill(g, new ArrayList<Integer>());\n//        return g;\n//    }\n\n    List<List<Integer>> initializeGraph(int n) {\n        List<List<Integer>> g = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            g.add(new ArrayList<>());\n        }\n        return g;\n    }\n\n    private void run() {\n        // read_write_file(); // comment this before submission\n        FastScanner fs = new FastScanner();\n        int t = 1;\n        while (t-- > 0) {\n            int n = fs.nextInt();\n            int m = fs.nextInt();\n            char[][] g = new char[n][m];\n            for (int i = 0; i < n; i++) g[i] = fs.next().toCharArray();\n            solve(n, m, g);\n        }\n    }\n\n    private final String INPUT = \"input.txt\";\n    private final String OUTPUT = \"output.txt\";\n\n    void read_write_file() {\n        FileInputStream instream = null;\n        PrintStream outstream = null;\n        try {\n            instream = new FileInputStream(INPUT);\n            outstream = new PrintStream(new FileOutputStream(OUTPUT));\n            System.setIn(instream);\n            System.setOut(outstream);\n        } catch (Exception e) {\n        }\n    }\n\n    public static void main(String[] args) {\n        pw = new PrintWriter(System.out);\n        new F().run();\n        pw.close();\n    }\n\n    void pr(int num) {\n        pw.println(num);\n    }\n\n    void pr(long num) {\n        pw.println(num);\n    }\n\n    void pr(double num) {\n        pw.println(num);\n    }\n\n    void pr(String s) {\n        pw.println(s);\n    }\n\n    void pr(char c) {\n        pw.println(c);\n    }\n\n    class FastScanner {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] readArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        Integer[] readIntegerArray(int n) {\n            Integer[] a = new Integer[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    void tr(Object... o) {\n        pw.println(Arrays.deepToString(o));\n    }\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 505;\nint n, m;\nint a[maxn][maxn], dx[5] = {0, -1, 0, 0, 1}, dy[5] = {0, 0, 1, -1, 0};\nstring s[maxn];\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) cin >> s[i], s[i] = \" \" + s[i];\n  for (int i = 1; i <= n; i++)\n    for (int j = 1, k = 0; j <= m; j++) {\n      if (s[i][j] == '.') a[i][j] = ((i + k) & 1) ? 1 : 4;\n      if (s[i][j] == 'X') {\n        int tot = 0;\n        for (int k = 1; k <= 4; k++) tot += s[i + dx[k]][j + dy[k]] == '.';\n        if (tot & 1) {\n          puts(\"NO\");\n          return 0;\n        }\n        if (s[i - 1][j] == 'X') k ^= 1;\n      }\n    }\n  puts(\"Yes\");\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) {\n      if (s[i][j] == 'X') {\n        int res = 0;\n        for (int k = 1; k <= 4; k++) res += a[i + dx[k]][j + dy[k]];\n        printf(\"%d%c\", res, j == m ? '\\n' : ' ');\n      } else\n        printf(\"%d%c\", a[i][j], j == m ? '\\n' : ' ');\n    }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxN = 555, maxM = maxN * maxN * 2;\nint n, m, c[maxN][maxN];\nchar b[maxN][maxN];\nint f[maxM], vis[maxM];\nint dx[] = {1, -1, 0, 0}, dy[] = {0, 0, 1, -1};\nvector<int> p[maxM];\nint find(int x) {\n  if (f[x] == x)\n    return x;\n  else\n    return f[x] = find(f[x]);\n}\nvoid merge(int u, int v) {\n  u = find(u);\n  v = find(v);\n  f[find(u)] = find(v);\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%s\", b[i]);\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      f[(i * m + j) * 2] = (i * m + j) * 2;\n      f[(i * m + j) * 2 + 1] = (i * m + j) * 2 + 1;\n      vis[i * m + j] = (b[i][j] == '.');\n    }\n  }\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < m; j++)\n      if (b[i][j] == 'X') {\n        vector<int> d;\n        for (int k = 0; k < 4; k++) {\n          if (b[i + dx[k]][j + dy[k]] == '.') {\n            d.push_back((i + dx[k]) * m + (j + dy[k]));\n          }\n        }\n        if (d.size() % 2 != 0) {\n          printf(\"NO\");\n          return 0;\n        }\n        if (d.size() == 0) continue;\n        if (d.size() == 2) {\n          merge(d[0] * 2, d[1] * 2 + 1);\n          merge(d[0] * 2 + 1, d[1] * 2);\n        }\n      }\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < m; j++)\n      if (b[i][j] == 'X') {\n        vector<int> d;\n        for (int k = 0; k < 4; k++) {\n          if (b[i + dx[k]][j + dy[k]] == '.') {\n            d.push_back((i + dx[k]) * m + (j + dy[k]));\n          }\n        }\n        if (d.size() <= 2) continue;\n        merge(d[0] * 2, d[1] * 2);\n        merge(d[0] * 2 + 1, d[1] * 2 + 1);\n        merge(d[2] * 2, d[3] * 2);\n        merge(d[2] * 2 + 1, d[3] * 2 + 1);\n        merge(d[0] * 2, d[2] * 2 + 1);\n        merge(d[0] * 2 + 1, d[2] * 2);\n      }\n  for (int i = 0; i < n * m; i++) assert(find(2 * i) != find(2 * i + 1));\n  for (int i = 0; i < 2 * n * m; i++)\n    if (vis[i / 2]) p[find(i)].push_back(i);\n  for (int i = 0; i < 2 * n * m; i += 2) {\n    if (p[i].empty()) continue;\n    for (auto q : p[i]) {\n      if (q % 2 == 1) {\n        c[q / 2 / m][q / 2 % m] = 4;\n      } else {\n        c[q / 2 / m][q / 2 % m] = 1;\n      }\n    }\n  }\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < m; j++)\n      if (b[i][j] == 'X') {\n        for (int k = 0; k < 4; k++) {\n          if (b[i + dx[k]][j + dy[k]] == '.') {\n            c[i][j] += c[i + dx[k]][j + dy[k]];\n          }\n        }\n      }\n  puts(\"YES\");\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) printf(\"%d \", c[i][j]);\n    puts(\"\");\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst int N = 5e5 + 10;\nchar mp[510][510];\nint ans[510][510];\nvoid run() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%s\", mp[i] + 1);\n  }\n  int p = 0;\n  for (int i = 1; i <= n; i++) {\n    p = 0;\n    for (int j = 1; j <= m; j++) {\n      if (mp[i][j] == 'X') {\n        p ^= (mp[i - 1][j] == 'X');\n        int num = 0;\n        if (mp[i][j - 1] == '.') num++;\n        if (mp[i][j + 1] == '.') num++;\n        if (mp[i - 1][j] == '.') num++;\n        if (mp[i + 1][j] == '.') num++;\n        if (num & 1) {\n          printf(\"NO\\n\");\n          return;\n        }\n        if (num == 0) {\n          ans[i][j] = 0;\n        }\n        if (num == 2) {\n          ans[i][j] = 5;\n        }\n        if (num == 4) {\n          ans[i][j] = 10;\n        }\n      } else {\n        ans[i][j] = ((j + p) & 1) ? 1 : 4;\n      }\n    }\n  }\n  printf(\"YES\\n\");\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      printf(\"%d \", ans[i][j]);\n    }\n    puts(\"\");\n  }\n}\nint main() {\n  run();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 505;\nint n, m, id[N][N], tot, p[N], res[N * N];\nint head[N * N], ver[N * N * 10], nxt[N * N * 10];\npair<int, int> dir[4] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\nchar s[N][N];\nvoid add(int x, int y) {\n  ver[++tot] = y, nxt[tot] = head[x], head[x] = tot;\n  ver[++tot] = x, nxt[tot] = head[y], head[y] = tot;\n}\nvoid dfs(int x, int c) {\n  if (res[x]) return;\n  res[x] = c;\n  for (int i = head[x]; i; i = nxt[i]) {\n    int y = ver[i];\n    dfs(y, 5 - c);\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = int(1); i <= int(n); i++) scanf(\"%s\", s[i] + 1);\n  for (int i = int(1); i <= int(n); i++)\n    for (int j = int(1); j <= int(m); j++) id[i][j] = ++tot;\n  tot = 0;\n  for (int i = int(1); i <= int(n); i++)\n    for (int j = int(1); j <= int(m); j++) {\n      if (s[i][j] == 'X') {\n        int tt = 0;\n        for (auto t : dir) {\n          if (s[i + t.first][j + t.second] == '.')\n            p[++tt] = id[i + t.first][j + t.second];\n        }\n        if (tt & 1) {\n          puts(\"NO\");\n          return 0;\n        }\n        for (int k = int(1); k <= int(tt >> 1); k++) add(p[k], p[tt - k + 1]);\n      }\n    }\n  puts(\"YES\");\n  for (int i = int(1); i <= int(n); i++)\n    for (int j = int(1); j <= int(m); j++)\n      if (s[i][j] == '.') dfs(id[i][j], 1);\n  for (int i = int(1); i <= int(n); i++) {\n    for (int j = int(1); j <= int(m); j++) {\n      if (s[i][j] == 'X') {\n        for (auto t : dir) {\n          if (s[i + t.first][j + t.second] == '.')\n            res[id[i][j]] += res[id[i + t.first][j + t.second]];\n        }\n      }\n      printf(\"%d \", res[id[i][j]]);\n    }\n    puts(\"\");\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC target(\"avx2\")\n#pragma GCC optimization(\"O3\")\n#pragma GCC optimization(\"unroll-loops\")\nconst long long N = 505;\nlong long n, m;\nlong long a[N][N];\nlong long ans[N][N];\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  for (long long i = 0; i < n; ++i) {\n    for (long long j = 0; j < m; ++j) {\n      char c;\n      cin >> c;\n      if (c == '.')\n        a[i][j] = 0;\n      else\n        a[i][j] = 1;\n    }\n  }\n  for (long long i = 1; i < (n - 1); ++i) {\n    for (long long j = 1; j < (m - 1); ++j) {\n      if (a[i][j]) {\n        long long cnt = 0;\n        if (!a[i][j - 1]) ++cnt;\n        if (!a[i][j + 1]) ++cnt;\n        if (!a[i + 1][j]) ++cnt;\n        if (!a[i - 1][j]) ++cnt;\n        if (cnt & 1) {\n          cout << \"NO\";\n          return 0;\n        }\n        if (cnt == 2)\n          ans[i][j] = 5;\n        else if (cnt == 4)\n          ans[i][j] = 10;\n        else\n          ans[i][j] = 0;\n      }\n    }\n  }\n  for (long long i = 0; i < n; ++i) {\n    long long tmp = 1;\n    if (i % 2 == 1) tmp = 4;\n    for (long long j = 0; j < m; ++j) {\n      if (!a[i][j]) {\n        ans[i][j] = tmp;\n      } else {\n        if (i - 1 >= 0 && a[i - 1][j]) {\n          tmp = tmp ^ 5;\n        }\n      }\n    }\n  }\n  cout << \"YES\\n\";\n  for (long long i = 0; i < n; ++i) {\n    for (long long j = 0; j < m; ++j) {\n      cout << ans[i][j] << \" \";\n    }\n    cout << \"\\n\";\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ntemplate <class t>\ninline void read(t &s) {\n  s = 0;\n  register int f = 1;\n  register char c = getchar();\n  while (!isdigit(c)) {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (isdigit(c)) s = (s << 3) + (s << 1) + (c ^ 48), c = getchar();\n  ;\n  s *= f;\n}\ntemplate <class t, class... A>\ninline void read(t &x, A &...a) {\n  read(x);\n  read(a...);\n}\ntemplate <class t>\ninline void write(t x) {\n  if (x < 0) putchar('-'), x = -x;\n  static int buf[21], top = 0;\n  while (x) buf[++top] = x % 10, x /= 10;\n  if (!top) buf[++top] = 0;\n  while (top) putchar(buf[top--] ^ '0');\n}\ninline void setIn(std::string s) {\n  freopen(s.c_str(), \"r\", stdin);\n  return;\n}\ninline void setOut(std::string s) {\n  freopen(s.c_str(), \"w\", stdout);\n  return;\n}\ninline void setIO(std::string s = \"\") {\n  setIn(s + \".in\");\n  setOut(s + \".out\");\n  return;\n}\ntemplate <class t>\ninline bool ckmin(t &x, t y) {\n  if (x > y) {\n    x = y;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class t>\ninline bool ckmax(t &x, t y) {\n  if (x < y) {\n    x = y;\n    return 1;\n  }\n  return 0;\n}\ninline int lowbit(int x) { return x & (-x); }\nconst int MaxN = 505;\nconst int dir[4][2] = {1, 0, 0, 1, -1, 0, 0, -1};\nint n, m;\nchar s[MaxN][MaxN];\ninline int ok(int x, int y) { return 1 <= x && x <= n && 1 <= y && y <= m; }\nstd::vector<std::pair<int, int> > E[MaxN][MaxN];\ninline void adde(int u, int v, int x, int y) {\n  E[u][v].push_back(std::make_pair(x, y)),\n      E[x][y].push_back(std::make_pair(u, v));\n}\nint col[MaxN][MaxN], ans[MaxN][MaxN];\ninline void dfs(int x, int y) {\n  for (auto v : E[x][y]) {\n    if (~col[v.first][v.second]) continue;\n    col[v.first][v.second] = col[x][y] ^ 1;\n    dfs(v.first, v.second);\n  }\n}\nsigned main(void) {\n  std::memset(col, -1, sizeof col);\n  read(n, m);\n  for (int i = 1; i <= n; ++i) std::scanf(\"%s\", s[i] + 1);\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n      if (s[i][j] == 'X') {\n        std::vector<std::pair<int, int> > dr;\n        for (int k = 0; k < 4; ++k) {\n          register int nx = i + dir[k][0], ny = j + dir[k][1];\n          if (!ok(nx, ny)) continue;\n          if (s[nx][ny] == '.') dr.push_back(std::make_pair(nx, ny));\n        }\n        if (dr.size() & 1) return std::puts(\"NO\"), 0;\n        if (!dr.size()) continue;\n        if (dr.size() == 2u)\n          adde(dr[0].first, dr[0].second, dr[1].first, dr[1].second);\n        else\n          adde(i - 1, j, i, j - 1), adde(i + 1, j, i, j + 1);\n      }\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n      if (!~col[i][j] && s[i][j] == '.') col[i][j] = 0, dfs(i, j);\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n      if (s[i][j] == '.') ans[i][j] = (col[i][j] ? 1 : 4);\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n      if (s[i][j] == 'X')\n        for (int k = 0; k < 4; ++k) {\n          register int nx = i + dir[k][0], ny = j + dir[k][1];\n          if (!ok(nx, ny)) continue;\n          if (s[nx][ny] == '.') ans[i][j] += ans[nx][ny];\n        }\n  std::puts(\"YES\");\n  for (int i = 1; i <= n; ++i, putchar('\\n'))\n    for (int j = 1; j <= m; ++j, putchar(32)) write(ans[i][j]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 500 + 10;\nconst int M = N * 2;\nconst int MOD = 1e9 + 7;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-7;\nconst double PI = acos(-1);\nlong long qpow(long long a, long long b) {\n  long long res = 1;\n  while (b) {\n    if (b & 1) res = res * a % MOD;\n    a = a * a % MOD;\n    b >>= 1;\n  }\n  return res;\n}\nint n, m, k, T;\nint g[N][N];\nint dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1};\nchar str[N][N];\nsigned main() {\n  scanf(\"%d\", &n), scanf(\"%d\", &m);\n  for (int i = 1; i <= n; i++) scanf(\" %s\", str[i] + 1);\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1, t = 1; j <= m; j++) {\n      if (str[i][j] == '.') {\n        g[i][j] = ((i + t) & 1) ? 1 : 4;\n      } else {\n        int cnt = 0;\n        for (int k = 0; k < 4; k++)\n          cnt += (str[i + dir[k][0]][j + dir[k][1]] == '.');\n        if (cnt & 1) {\n          puts(\"NO\");\n          return 0;\n        }\n        if (str[i - 1][j] == 'X') t ^= 1;\n      }\n    }\n  }\n  puts(\"YES\");\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) {\n      if (str[i][j] == 'X') {\n        int ans = 0;\n        for (int k = 0; k < 4; k++) {\n          ans += g[i + dir[k][0]][j + dir[k][1]];\n        }\n        printf(\"%d%c\", ans, \" \\n\"[j == m]);\n      } else\n        printf(\"%d%c\", g[i][j], \" \\n\"[j == m]);\n    }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int M = 505;\nconst int N = M * M;\nint read() {\n  int x = 0, f = 1;\n  char c;\n  while ((c = getchar()) < '0' || c > '9') {\n    if (c == '-') f = -1;\n  }\n  while (c >= '0' && c <= '9') {\n    x = (x << 3) + (x << 1) + (c ^ 48);\n    c = getchar();\n  }\n  return x * f;\n}\nint n, m, ans[N];\nchar s[M][M];\nvector<int> g[N];\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\nint id(int x, int y) { return (x - 1) * m + y; }\nvoid add(int u, int v) {\n  g[u].push_back(v);\n  g[v].push_back(u);\n}\nvoid dfs(int u, int ls) {\n  ans[u] = ls;\n  for (auto v : g[u])\n    if (!ans[v]) dfs(v, 5 - ls);\n}\nint main() {\n  n = read();\n  m = read();\n  for (int i = 1; i <= n; i++) scanf(\"%s\", s[i] + 1);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      if (s[i][j] == 'X') {\n        int d = 0, a[4] = {};\n        for (int k = 0; k < 4; k++) {\n          int x = i + dx[k], y = j + dy[k];\n          if (x < 1 || y < 1 || x > n || y > m) continue;\n          if (s[x][y] == '.') a[d++] = id(x, y);\n        }\n        if (d & 1) {\n          puts(\"NO\");\n          return 0;\n        }\n        for (int i = 0; i < d; i++) add(a[i], a[(i + 1) % d]);\n      }\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      if (s[i][j] == '.' && !ans[id(i, j)]) dfs(id(i, j), 1);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      if (s[i][j] == 'X')\n        for (int k = 0; k < 4; k++) {\n          int x = i + dx[k], y = j + dy[k];\n          if (x < 1 || y < 1 || x > n || y > m) continue;\n          if (s[x][y] == '.') ans[id(i, j)] += ans[id(x, y)];\n        }\n  puts(\"YES\");\n  for (int i = 1; i <= n; i++, puts(\"\"))\n    for (int j = 1; j <= m; j++) printf(\"%d \", ans[id(i, j)]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 505;\nconst int Gx[8] = {0, 1, 0, -1, -1, -1, 1, 1};\nconst int Gy[8] = {1, 0, -1, 0, -1, 1, -1, 1};\nint n, m, cnt, a[N][N], visit[N][N], color[N * N];\nchar s[N][N];\nvector<int> S[N * N];\nvoid DFS(int i, int j) {\n  visit[i][j] = cnt;\n  for (int w = 0; w < 8; ++w) {\n    int x = i + Gx[w];\n    int y = j + Gy[w];\n    if (s[x][y] == '.' && !visit[x][y]) DFS(x, y);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  cin >> n >> m;\n  for (int i = 1; i <= n; ++i) cin >> s[i] + 1;\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n      if (s[i][j] == 'X') {\n        int dem = 0;\n        for (int w = 0; w < 4; ++w) {\n          int x = i + Gx[w];\n          int y = j + Gy[w];\n          if (s[x][y] == '.') ++dem;\n        }\n        if (dem & 1) return cout << \"NO\", 0;\n        a[i][j] = dem * 5 / 2;\n      }\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n      if (s[i][j] == '.' && !visit[i][j]) {\n        ++cnt;\n        DFS(i, j);\n      }\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j) {\n      if (visit[i][j - 1] && visit[i][j + 1] &&\n          visit[i][j - 1] != visit[i][j + 1]) {\n        S[visit[i][j - 1]].push_back(visit[i][j + 1]);\n        S[visit[i][j + 1]].push_back(visit[i][j - 1]);\n      }\n      if (visit[i - 1][j] && visit[i + 1][j] &&\n          visit[i - 1][j] != visit[i + 1][j]) {\n        S[visit[i - 1][j]].push_back(visit[i + 1][j]);\n        S[visit[i + 1][j]].push_back(visit[i - 1][j]);\n      }\n    }\n  queue<int> Q;\n  for (int i = 1; i <= cnt; ++i)\n    if (!color[i]) {\n      Q.push(i);\n      color[i] = 1;\n      while (!Q.empty()) {\n        int u = Q.front();\n        Q.pop();\n        for (int v : S[u]) {\n          if (!color[v]) color[v] = color[u] ^ 3, Q.push(v);\n          if (color[u] == color[v]) return cout << \"NO\", 0;\n        }\n      }\n    }\n  for (int i = 1; i <= n; ++i) {\n    int num = (i % 2 ? 1 : 4);\n    int col = color[visit[i][1]];\n    a[i][1] = num;\n    for (int j = 2; j <= m; ++j) {\n      if (s[i][j] == '.') {\n        if (col != color[visit[i][j]]) num ^= 5;\n        col = color[visit[i][j]];\n        a[i][j] = num;\n      }\n    }\n  }\n  cout << \"YES\\n\";\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j) cout << a[i][j] << \" \\n\"[j == m];\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename Ta, typename Tb>\nostream &operator<<(ostream &os, pair<Ta, Tb> x) {\n  return os << x.first << \" \" << x.second;\n}\nchar s[501][501];\nvector<int> c[512 * 512];\nbitset<512 * 512> odw, col;\nbool marked(int x, int y) {\n  if (x < 0 || y < 0) return 0;\n  return s[x][y] == 'X';\n}\nint marked_ct(int i, int j) {\n  return marked(i - 1, j) + marked(i + 1, j) + marked(i, j - 1) +\n         marked(i, j + 1);\n}\nvoid check_odd(int n, int m) {\n  for (int i = (int)0; i < (int)n; ++i)\n    for (int j = (int)0; j < (int)m; ++j)\n      if (marked(i, j)) {\n        int sum = marked_ct(i, j);\n        if (sum & 1) {\n          puts(\"NO\");\n          exit(0);\n        }\n      }\n}\nvoid check_for_add_edge(int x, int y, pair<int, int> &a, pair<int, int> &b) {\n  pair<int, int> base = make_pair(-1, -1);\n  if (!marked(x, y) && x >= 0 && y >= 0) {\n    if (a == base)\n      a = make_pair(x, y);\n    else\n      b = make_pair(x, y);\n  }\n}\nint vert(pair<int, int> x) { return (x.first << 9) + x.second; }\npair<int, int> wsp(int x) { return make_pair(x >> 9, x - (x >> 9)); }\nvoid add_edge(int x, int y, bool rev = 0) {\n  pair<int, int> a, b;\n  a = b = make_pair(-1, -1);\n  if (rev == 0) {\n    if (!marked(x - 1, y) && x >= 0) a = make_pair(x - 1, y);\n    check_for_add_edge(x, y + 1, a, b);\n    check_for_add_edge(x + 1, y, a, b);\n    check_for_add_edge(x, y - 1, a, b);\n    c[vert(a)].push_back(vert(b));\n    c[vert(b)].push_back(vert(a));\n  } else {\n    pair<int, int> d[4] = {{x - 1, y}, {x, y + 1}, {x + 1, y}, {x, y - 1}};\n    for (int i = (int)0; i < (int)4; ++i)\n      c[vert(d[i])].push_back(vert(d[(i + 1) % 4])),\n          c[vert(d[(i + 1) % 4])].push_back(vert(d[i]));\n  }\n}\nvoid build(int n, int m) {\n  for (int i = (int)0; i < (int)n; ++i)\n    for (int j = (int)0; j < (int)m; ++j) {\n      if (marked(i, j) && marked_ct(i, j) == 2) add_edge(i, j);\n      if (marked(i, j) && marked_ct(i, j) == 0)\n        add_edge(i, j), add_edge(i, j, 1);\n    }\n}\nvoid dfs(int x, bool color) {\n  odw[x] = 1;\n  col[x] = color;\n  for (auto ss : c[x])\n    if (!odw[ss]) dfs(ss, color ^ 1);\n}\nvoid solve(int n, int m) {\n  for (int i = (int)0; i < (int)n; ++i)\n    for (int j = (int)0; j < (int)m; ++j)\n      if (!odw[vert(make_pair(i, j))] && !marked(i, j))\n        dfs(vert(make_pair(i, j)), 1);\n}\nvoid print(int n, int m) {\n  puts(\"YES\");\n  for (int i = (int)0; i < (int)n; ++i) {\n    for (int j = (int)0; j < (int)m; ++j) {\n      if (!marked(i, j))\n        printf(\"%d \", col[vert(make_pair(i, j))] ? 4 : 1);\n      else\n        printf(\"%d \", (4 - marked_ct(i, j)) * 5 / 2);\n    }\n    puts(\"\");\n  }\n}\nvoid solve(void) {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = (int)0; i < (int)n; ++i) scanf(\"%s\", s[i]);\n  check_odd(n, m);\n  build(n, m);\n  solve(n, m);\n  print(n, m);\n}\nint32_t main(void) {\n  int t;\n  t = 1;\n  while (t--) solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1e9 + 7;\nconst long long MOD = 998244353;\nvector<vector<long long> > adj;\nlong long color[1000005];\nbool v[1000005] = {0};\nlong long block(long long x, long long y, long long m) { return m * x + y; }\nvoid dfs(long long idx, long long y) {\n  v[idx] = 1;\n  color[idx] = y;\n  for (auto x : adj[idx]) {\n    if (!v[x]) {\n      dfs(x, y ^ 1);\n    } else if (v[x]) {\n      assert(color[x] == (y ^ 1));\n    }\n  }\n}\nint main(void) {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  long long n, m;\n  cin >> n >> m;\n  char arr[n][m];\n  long long ans[n][m];\n  for (long long i = 0; i < n; i++) {\n    for (long long j = 0; j < m; j++) {\n      cin >> arr[i][j];\n    }\n  }\n  bool ok = 1;\n  long long ola = n * m + 10;\n  adj.assign(ola, vector<long long>());\n  long long dx[4] = {0, 0, 1, -1};\n  long long dy[4] = {1, -1, 0, 0};\n  for (long long i = 0; i < n; i++) {\n    for (long long j = 0; j < m; j++) {\n      if (arr[i][j] == 'X') {\n        long long posa = 0;\n        vector<long long> ex;\n        for (long long k = 0; k < 4; k++) {\n          long long x = i + dx[k], y = dy[k] + j;\n          if (arr[x][y] == '.') {\n            ex.push_back(block(x, y, m));\n            posa++;\n          }\n        }\n        if (posa == 2) {\n          for (long long i = 0; i < posa; i++) {\n            adj[ex[i]].push_back(ex[(i + 1) % posa]);\n            adj[ex[(i + 1) % posa]].push_back(ex[i]);\n          }\n        } else if (posa == 4) {\n          adj[ex[0]].push_back(ex[2]);\n          adj[ex[2]].push_back(ex[0]);\n          adj[ex[1]].push_back(ex[3]);\n          adj[ex[3]].push_back(ex[1]);\n        }\n        if (posa % 2) {\n          ok = 0;\n        }\n      }\n    }\n  }\n  if (!ok) {\n    cout << \"NO\";\n    return 0;\n  }\n  for (long long i = 0; i < n; i++) {\n    for (long long j = 0; j < m; j++) {\n      if (arr[i][j] == '.' && !v[block(i, j, m)]) {\n        dfs(block(i, j, m), 0);\n      }\n      if (arr[i][j] == '.') {\n        ans[i][j] = 1;\n        if (color[block(i, j, m)] == 1) {\n          ans[i][j] = 4;\n        }\n      }\n    }\n  }\n  cout << \"YES\\n\";\n  for (long long i = 0; i < n; i++) {\n    for (long long j = 0; j < m; j++) {\n      if (arr[i][j] == 'X') {\n        ans[i][j] = 0;\n        for (long long k = 0; k < 4; k++) {\n          long long x = i + dx[k], y = dy[k] + j;\n          if (arr[x][y] == '.') {\n            ans[i][j] += ans[x][y];\n          }\n        }\n      }\n      cout << ans[i][j] << \" \";\n    }\n    cout << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import javafx.util.Pair;\n\nimport java.util.*;\n\npublic class F {\n  private static final Scanner scanner = new Scanner(System.in);\n\n  public static void main(String[] args) {\n\n    int[] dx = new int[]{-1, 0, 1, 0};\n    int[] dy = new int[]{0, 1, 0, -1};\n    String[] nm = scanner.nextLine().split(\" \");\n    int n = Integer.parseInt(nm[0]);\n    int m = Integer.parseInt(nm[1]);\n\n    String[][] input = new String[n][m];\n\n    for (int i = 0; i < n; i++) {\n      String[] row = scanner.nextLine().split(\"\");\n      for (int j = 0; j < m; j++) {\n        input[i][j] = row[j];\n      }\n    }\n\n    ArrayList<ArrayList<Integer>> aroundXs = new ArrayList<>(n*m);\n\n    for (int i = 0; i < n * m; i++) {\n      aroundXs.add(new ArrayList<>());\n    }\n\n    for (int i = 1; i < n - 1; i++) {\n      for (int j = 1; j < m - 1; j++) {\n        if (input[i][j].equals(\"X\")) {\n          List<Integer> aroundX = new ArrayList<>();\n          for (int k = 0; k < 4; k++) {\n            int x = i + dx[k];\n            int y = j + dy[k];\n\n            if (input[x][y].equals(\".\")) {\n              aroundX.add(x*m + y);\n            }\n          }\n\n          if (aroundX.size() % 2 != 0) {\n            System.out.println(\"NO\");\n            return;\n          } else if (aroundX.size() == 2) {\n            aroundXs.get(aroundX.get(0)).add(aroundX.get(1));\n            aroundXs.get(aroundX.get(1)).add(aroundX.get(0));\n          } else if (aroundX.size() == 4) {\n            aroundXs.get(aroundX.get(0)).add(aroundX.get(1));\n            aroundXs.get(aroundX.get(1)).add(aroundX.get(0));\n            aroundXs.get(aroundX.get(2)).add(aroundX.get(3));\n            aroundXs.get(aroundX.get(3)).add(aroundX.get(2));\n          }\n        }\n      }\n    }\n\n    ArrayList<ArrayList<Integer>> finalVector = new ArrayList<>();\n\n    for (int i = 0; i < n; i++) {\n      ArrayList<Integer> temp = new ArrayList<>();\n      for (int j = 0; j < m; j++) {\n        temp.add(-1);\n      }\n      finalVector.add(temp);\n    }\n\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        if (finalVector.get(i).get(j) == -1 && input[i][j].equals(\".\")) {\n          finalVector.get(i).set(j, 1);\n\n          Queue<Pair<Integer, Integer>> queue = new ArrayDeque<>();\n          queue.add(new Pair<>(i, j));\n\n          while (!queue.isEmpty()) {\n            Pair<Integer, Integer> pair = queue.poll();\n            int x = pair.getKey();\n            int y = pair.getValue();\n\n            int v = x*m + y;\n\n            for (int w : aroundXs.get(v)) {\n              int x2 = w/m;\n              int y2 = w % m;\n\n              if (finalVector.get(x2).get(y2) == -1) {\n                finalVector.get(x2).set(y2, 5 - finalVector.get(x).get(y));\n                queue.add(new Pair<>(x2, y2));\n              }\n            }\n          }\n        }\n      }\n    }\n\n    for (int i = 1; i < n - 1; i++) {\n      for (int j = 1; j < m - 1; j++) {\n\n        if (input[i][j].equals(\"X\")) {\n          finalVector.get(i).set(j, 0);\n          for (int k = 0; k < 4; k++) {\n            int x = i + dx[k];\n            int y = j + dy[k];\n\n            if (input[x][y].equals(\".\")) {\n              int temp = finalVector.get(i).get(j) + finalVector.get(x).get(y);\n              finalVector.get(i).set(j, temp);\n            }\n          }\n        }\n      }\n    }\n\n    System.out.println(\"YES\");\n\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        System.out.print(finalVector.get(i).get(j));\n        if (j < m - 1) {\n          System.out.print(\" \");\n        }\n      }\n      System.out.print(\"\\n\");\n    }\n\n  }\n\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long maxn = 1e6 + 5;\nconst long long maxm = 1e3 + 5;\nnamespace IO {\nconst int SIZE = (1 << 20) + 1;\nchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = obuf + SIZE - 1;\nchar _st[55];\nint _qr = 0;\ninline char gc() {\n  return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin),\n          (iS == iT ? EOF : *iS++) : *iS++);\n}\ninline void qread() {}\ntemplate <class T1, class... T2>\ninline void qread(T1 &IEE, T2 &...ls) {\n  register T1 __ = 0, ___ = 1;\n  register char ch;\n  while (!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;\n  do {\n    __ = (__ << 1) + (__ << 3) + (ch ^ 48);\n  } while (isdigit(ch = gc()));\n  __ *= ___;\n  IEE = __;\n  qread(ls...);\n  return;\n}\ninline void flush() {\n  fwrite(obuf, 1, oS - obuf, stdout);\n  oS = obuf;\n  return;\n}\ninline void putc_(char _x) {\n  *oS++ = _x;\n  if (oS == oT) flush();\n}\ninline void qwrite() {}\ntemplate <class T1, class... T2>\ninline void qwrite(T1 IEE, T2... ls) {\n  if (!IEE) putc_('0');\n  if (IEE < 0) putc_('-'), IEE = -IEE;\n  while (IEE) _st[++_qr] = IEE % 10 + '0', IEE /= 10;\n  while (_qr) putc_(_st[_qr--]);\n  qwrite(ls...);\n  return;\n}\nstruct Flusher_ {\n  ~Flusher_() { flush(); }\n} io_flusher;\n}  // namespace IO\nusing namespace IO;\nlong long n, m;\nchar s[505][505];\nlong long head[maxn], nex[maxn << 1];\nlong long to[maxn << 1];\nlong long cur;\nvoid add(long long u, long long v) {\n  nex[++cur] = head[u];\n  to[cur] = v;\n  head[u] = cur;\n  return;\n}\nconst long long dar[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\nlong long f[505][505];\nlong long id(long long x, long long y) { return (x - 1) * m + y; }\nlong long col[maxn];\nqueue<long long> q;\nvoid bfs(long long now) {\n  q.push(now);\n  col[now] = 0;\n  while (!q.empty()) {\n    long long fr = q.front();\n    q.pop();\n    for (int i = head[fr]; i; i = nex[i]) {\n      long long t = to[i];\n      if (col[t] > -1 && col[t] != col[fr] ^ 1) {\n        cout << \"NO\\n\";\n        cout.flush();\n        exit(0);\n      }\n      if (col[t] > -1) continue;\n      col[t] = col[fr] ^ 1;\n      q.push(t);\n    }\n  }\n  return;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    cin >> (s[i] + 1);\n  }\n  for (int i = 2; i < n; i++) {\n    for (int j = 2; j < m; j++) {\n      if (s[i][j] == '.') continue;\n      long long cnt = 0;\n      for (int k = 0; k < 4; k++) {\n        long long tx = i + dar[k][0];\n        long long ty = j + dar[k][1];\n        if (s[tx][ty] == '.') cnt++;\n      }\n      if (cnt & 1) {\n        cout << \"NO\\n\";\n        cout.flush();\n        return 0;\n      }\n      if (cnt == 0) {\n        f[i][j] = 0;\n        continue;\n      } else if (cnt == 2) {\n        f[i][j] = 5;\n        for (int k = 0; k < 4; k++) {\n          long long nx = (k + 1) % 4;\n          long long tx = i + dar[k][0];\n          long long ty = j + dar[k][1];\n          if (s[tx][ty] == s[i + dar[nx][0]][j + dar[nx][1]] &&\n              s[tx][ty] == '.') {\n            add(id(tx, ty), id(i + dar[nx][0], j + dar[nx][1]));\n            add(id(i + dar[nx][0], j + dar[nx][1]), id(tx, ty));\n            break;\n          }\n        }\n        for (int k = 0; k < 4; k++) {\n          long long nx = (k + 2) % 4;\n          long long tx = i + dar[k][0];\n          long long ty = j + dar[k][1];\n          if (s[tx][ty] == s[i + dar[nx][0]][j + dar[nx][1]] &&\n              s[tx][ty] == '.') {\n            add(id(tx, ty), id(i + dar[nx][0], j + dar[nx][1]));\n            add(id(i + dar[nx][0], j + dar[nx][1]), id(tx, ty));\n            break;\n          }\n        }\n      } else if (cnt == 4) {\n        f[i][j] = 10;\n        add(id(i - 1, j), id(i, j - 1));\n        add(id(i, j - 1), id(i - 1, j));\n        add(id(i + 1, j), id(i, j + 1));\n        add(id(i, j + 1), id(i + 1, j));\n      }\n    }\n  }\n  memset(col, -1, sizeof(col));\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      if (s[i][j] == '.' && col[id(i, j)] == -1) {\n        bfs(id(i, j));\n      }\n      if (s[i][j] == '.') {\n        f[i][j] = col[id(i, j)] == 1 ? 1 : 4;\n      }\n    }\n  }\n  cout << \"YES\\n\";\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      cout << f[i][j] << \" \";\n    }\n    cout << \"\\n\";\n  }\n  cout.flush();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int t = 1;\n  vector<vector<int>> neigh = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n  for (int i = 0; i < t; ++i) {\n    int m, n;\n    cin >> n >> m;\n    vector<string> v(n);\n    vector<vector<int>> ans(n, vector<int>(m, 0));\n    vector<vector<int>> g(n * m);\n    for (int j = 0; j < n; ++j) {\n      cin >> v[j];\n    }\n    for (int j = 1; j < n - 1; ++j) {\n      for (int k = 1; k < m - 1; ++k) {\n        if (v[j][k] == 'X') {\n          int c = 0;\n          vector<int> cell;\n          for (auto &d : neigh) {\n            int dx = d[0], dy = d[1];\n            if (v[j + dx][k + dy] == '.') {\n              ++c;\n              cell.push_back((j + dx) * m + k + dy);\n            }\n          }\n          if (c % 2 != 0) {\n            goto error;\n          } else if (c == 2) {\n            g[cell[0]].push_back(cell[1]);\n            g[cell[1]].push_back(cell[0]);\n          } else if (c == 4) {\n            g[cell[0]].push_back(cell[3]);\n            g[cell[3]].push_back(cell[0]);\n            g[cell[1]].push_back(cell[2]);\n            g[cell[2]].push_back(cell[1]);\n          }\n        }\n      }\n    }\n    for (int j = 0; j < n; ++j) {\n      for (int k = 0; k < m; ++k) {\n        int id = j * m + k;\n        if (v[j][k] == '.' && ans[j][k] == 0) {\n          list<int> q;\n          q.push_back(id);\n          ans[j][k] = 1;\n          while (!q.empty()) {\n            int p = q.front();\n            int x = p / m, y = p % m;\n            q.pop_front();\n            for (auto next : g[p]) {\n              int nx = next / m, ny = next % m;\n              if (ans[nx][ny] == 0) {\n                ans[nx][ny] = 5 - ans[x][y];\n                q.push_back(next);\n              }\n            }\n          }\n        }\n      }\n    }\n    printf(\"YES\\n\");\n    for (int j = 0; j < n; ++j) {\n      for (int k = 0; k < m; ++k) {\n        if (ans[j][k] == 0) {\n          for (auto &d : neigh) {\n            int dx = d[0], dy = d[1];\n            if (v[j + dx][k + dy] == '.') {\n              ans[j][k] += ans[j + dx][k + dy];\n            }\n          }\n        }\n        printf(\"%d \", ans[j][k]);\n      }\n      printf(\"\\n\");\n    }\n    continue;\n  error:\n    printf(\"NO\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int f = 1, sum = 0;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') f = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    sum = sum * 10 + c - '0';\n    c = getchar();\n  }\n  return sum * f;\n}\ninline long long readLL() {\n  long long f = 1, sum = 0;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') f = -1LL;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    sum = sum * 10 + c - '0';\n    c = getchar();\n  }\n  return sum * f;\n}\nint n, m;\nchar s[505][505];\nint ans[505][505];\nint main() {\n  n = read();\n  m = read();\n  for (int i = 1; i <= n; i++) scanf(\"%s\", s[i] + 1);\n  for (int i = 1; i <= n; i++) {\n    int change = 0;\n    for (int j = 1; j <= m; j++) {\n      if (s[i][j] == 'X') {\n        change ^= (s[i - 1][j] == 'X');\n        int num = 0;\n        if (s[i - 1][j] == '.') num++;\n        if (s[i + 1][j] == '.') num++;\n        if (s[i][j - 1] == '.') num++;\n        if (s[i][j + 1] == '.') num++;\n        if (num & 1) {\n          puts(\"NO\");\n          return 0;\n        }\n      } else\n        ans[i][j] = ((j + change) & 1) ? 1 : 4;\n    }\n  }\n  puts(\"YES\");\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      if (s[i][j] == 'X') {\n        int num = 0;\n        if (s[i - 1][j] == '.') num += ans[i - 1][j];\n        if (s[i + 1][j] == '.') num += ans[i + 1][j];\n        if (s[i][j - 1] == '.') num += ans[i][j - 1];\n        if (s[i][j + 1] == '.') num += ans[i][j + 1];\n        printf(\"%d \", num);\n      } else\n        printf(\"%d \", ans[i][j]);\n    }\n    puts(\"\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC target(\"avx2,fma\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nlong long IOS = []() {\n  ios::sync_with_stdio(0);\n  std::cin.tie(nullptr);\n  std::cout.tie(nullptr);\n  return 0;\n}();\ntemplate <class T>\nvoid _W(const T &x) {\n  cout << x;\n}\ntemplate <class T>\nvoid _W(T &x) {\n  cout << x;\n}\ntemplate <class T, class U>\nvoid _W(const pair<T, U> &x) {\n  _W(x.first);\n  putchar(' ');\n  _W(x.second);\n}\ntemplate <class T>\nvoid _W(const vector<T> &x) {\n  for (auto i = x.begin(); i != x.end(); _W(*i++)) cout << ' ';\n}\nvoid W() {}\ntemplate <class T, class... U>\nvoid W(const T &head, const U &...tail) {\n  _W(head);\n  cout << \", \";\n  W(tail...);\n}\ninline string cn(long long i) {\n  stringstream ss;\n  ss << i;\n  return ss.str();\n}\nconst long long N = 5e2 + 10;\nlong long tr[N];\nlong long n, m;\nchar mp[N][N];\nlong long t[N][N];\nlong long vis[N][N], ans[N][N];\nlong long dir[10] = {1, 0, -1, 0, 0, 1, 0, -1};\nvoid build(long long u, long long l, long long r) {\n  if (l == r) {\n    tr[u] = 0;\n    return;\n  }\n  long long mid = l + r >> 1;\n  build(u << 1, l, mid);\n  build(u << 1 | 1, mid + 1, r);\n}\nlong long judge(long long x, long long y) {\n  long long ans = 0;\n  for (long long i = 0; i < 4; i++) {\n    if (mp[x + dir[2 * i]][y + dir[2 * i + 1]] == '.') ans++;\n  }\n  return ans;\n}\nvoid dfs(long long x, long long y, long long k, long long d) {\n  vis[x][y] = 1;\n  if (k == 1) {\n    for (long long i = 0; i < 4; i++) {\n      if (mp[x + dir[2 * i]][y + dir[2 * i + 1]] == 'X' &&\n          vis[x + dir[2 * i]][y + dir[2 * i + 1]] == 0) {\n        dfs(x + dir[2 * i], y + dir[2 * i + 1], 0, d);\n      }\n    }\n  } else {\n    if (t[x][y] == 2) {\n      for (long long i = 0; i < 4; i++) {\n        if (mp[x + dir[2 * i]][y + dir[2 * i + 1]] == '.' &&\n            vis[x + dir[2 * i]][y + dir[2 * i + 1]] == 0) {\n          ans[x + dir[2 * i]][y + dir[2 * i + 1]] = 5 - d;\n          dfs(x + dir[2 * i], y + dir[2 * i + 1], 1, 5 - d);\n        }\n      }\n    } else {\n      if (vis[x - 1][y]) {\n        ans[x + 1][y] = ans[x - 1][y];\n        ans[x][y + 1] = ans[x][y - 1] = 5 - ans[x - 1][y];\n      } else if (vis[x + 1][y]) {\n        ans[x - 1][y] = ans[x + 1][y];\n        ans[x][y + 1] = ans[x][y - 1] = 5 - ans[x + 1][y];\n      } else if (vis[x][y + 1]) {\n        ans[x][y - 1] = ans[x][y + 1];\n        ans[x - 1][y] = ans[x + 1][y] = 5 - ans[x][y + 1];\n      } else {\n        ans[x][y + 1] = ans[x][y - 1];\n        ans[x - 1][y] = ans[x + 1][y] = 5 - ans[x][y - 1];\n      }\n      for (long long i = 0; i < 4; i++) {\n        vis[x + dir[2 * i]][y + dir[2 * i + 1]] = 1;\n      }\n      for (long long i = 0; i < 4; i++) {\n        dfs(x + dir[2 * i], y + dir[2 * i + 1], 1,\n            ans[x + dir[2 * i]][y + dir[2 * i + 1]]);\n      }\n    }\n  }\n}\nvoid solve() {\n  cin >> n >> m;\n  for (long long i = 1; i <= n; i++) {\n    for (long long j = 1; j <= m; j++) {\n      cin >> mp[i][j];\n    }\n  }\n  for (long long i = 1; i <= n; i++) {\n    for (long long j = 1; j <= m; j++) {\n      if (mp[i][j] == 'X') {\n        t[i][j] = judge(i, j);\n        if (t[i][j] & 1) {\n          cout << \"NO\" << '\\n';\n          return;\n        }\n        ans[i][j] = t[i][j] * 5 / 2;\n      }\n    }\n  }\n  for (long long i = 1; i <= n; i++) {\n    for (long long j = 1; j <= m; j++) {\n      if (mp[i][j] == '.') {\n        if (!vis[i][j]) {\n          ans[i][j] = 1;\n          dfs(i, j, 1, 1);\n        }\n      }\n    }\n  }\n  cout << \"YES\" << '\\n';\n  for (long long i = 1; i <= n; i++) {\n    for (long long j = 1; j <= m; j++) {\n      cout << ans[i][j] << \" \";\n    }\n    cout << '\\n';\n  }\n}\nsigned main() {\n  n = 10;\n  build(1, 1, n);\n  long long tt = 1;\n  while (tt--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nT gcd(T a, T b) {\n  return (b == 0 ? a : gcd(b, a % b));\n}\nint gi() {\n  int a;\n  scanf(\"%d\", &a);\n  return a;\n}\nlong long gli() {\n  long long a;\n  scanf(\"%I64d\", &a);\n  return a;\n}\nint cases() {\n  static int t = gi();\n  return t--;\n}\nchar g[500][504];\nint r[500][500];\nint n, m;\nvoid st(int i, int j, int w) {\n  if (i < 0 || i >= n || j < 0 || j >= m || g[i][j] == 'X' || r[i][j]) return;\n  r[i][j] = w;\n  for (int ii = 0; ii < 3; ii++)\n    for (int jj = 0; jj < 3; jj++) st(i + ii - 1, j + jj - 1, w);\n  if (i - 2 >= 0 && g[i - 1][j] == 'X' && g[i - 1][j - 1] == 'X')\n    st(i - 2, j, 5 - w);\n  if (i + 2 < n && g[i + 1][j] == 'X' && g[i + 1][j + 1] == 'X')\n    st(i + 2, j, 5 - w);\n  if (j - 2 >= 0 && g[i][j - 1] == 'X' && g[i - 1][j - 1] == 'X')\n    st(i, j - 2, 5 - w);\n  if (j + 2 < m && g[i][j + 1] == 'X' && g[i + 1][j + 1] == 'X')\n    st(i, j + 2, 5 - w);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  n = gi();\n  m = gi();\n  for (int i = 0; i < n; i++) scanf(\"%s\", g[i]);\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < m; j++)\n      if (g[i][j] == 'X') {\n        int c = 0;\n        if (g[i - 1][j] == '.') c++;\n        if (g[i + 1][j] == '.') c++;\n        if (g[i][j - 1] == '.') c++;\n        if (g[i][j + 1] == '.') c++;\n        if (c % 2) {\n          printf(\"NO\\n\");\n          return 0;\n        }\n      }\n  st(0, 0, 1);\n  for (int i = 1; i < n; i += 2)\n    for (int j = 0; j < m; j++)\n      if (g[i][j] == '.') r[i][j] = 5 - r[i][j];\n  printf(\"YES\\n\");\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < m; j++)\n      printf(\"%d%c\",\n             r[i][j] ? r[i][j]\n                     : r[i - 1][j] + r[i + 1][j] + r[i][j - 1] + r[i][j + 1],\n             j == m - 1 ? '\\n' : ' ');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nint dx[]{0, -1, 0, 1};\nint dy[]{-1, 0, 1, 0};\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  int n, m;\n  cin >> n >> m;\n  vector<string> s(n);\n  for (int i = 0; i < n; i++) {\n    cin >> s[i];\n  }\n  vector<vector<int>> g(n * m);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      if (s[i][j] == 'X') {\n        vector<int> A;\n        for (int k = 0; k < 4; k++) {\n          int x = i + dx[k];\n          int y = j + dy[k];\n          if (x >= 0 && x < n && y >= 0 && y < m && s[x][y] == '.') {\n            A.push_back(x * m + y);\n          }\n        }\n        if (A.size() % 2 != 0) {\n          cout << \"NO\\n\";\n          return 0;\n        }\n        for (int k = 0; k < A.size(); k += 2) {\n          g[A[k]].push_back(A[k + 1]);\n          g[A[k + 1]].push_back(A[k]);\n        }\n      }\n    }\n  }\n  vector<vector<int>> e(n, vector<int>(m));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      if (s[i][j] == 'X' || e[i][j]) {\n        continue;\n      }\n      e[i][j] = 1;\n      queue<int> q;\n      q.push(i * m + j);\n      while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (auto v : g[u]) {\n          if (!e[v / m][v % m]) {\n            e[v / m][v % m] = e[u / m][u % m] ^ 5;\n            q.push(v);\n          }\n        }\n      }\n    }\n  }\n  cout << \"YES\\n\";\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      if (s[i][j] == 'X') {\n        for (int k = 0; k < 4; k++) {\n          int x = i + dx[k];\n          int y = j + dy[k];\n          if (x >= 0 && x < n && y >= 0 && y < m && s[x][y] == '.') {\n            e[i][j] += e[x][y];\n          }\n        }\n      }\n      cout << e[i][j] << \" \\n\"[j == m - 1];\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\ntemplate <typename T>\nvector<T>& operator--(vector<T>& v) {\n  for (auto& i : v) --i;\n  return v;\n}\ntemplate <typename T>\nvector<T>& operator++(vector<T>& v) {\n  for (auto& i : v) ++i;\n  return v;\n}\ntemplate <typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (auto& i : v) is >> i;\n  return is;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, vector<T> v) {\n  for (auto& i : v) os << i << ' ';\n  return os;\n}\ntemplate <typename T, typename U>\npair<T, U>& operator--(pair<T, U>& p) {\n  --p.first;\n  --p.second;\n  return p;\n}\ntemplate <typename T, typename U>\npair<T, U>& operator++(pair<T, U>& p) {\n  ++p.first;\n  ++p.second;\n  return p;\n}\ntemplate <typename T, typename U>\nistream& operator>>(istream& is, pair<T, U>& p) {\n  is >> p.first >> p.second;\n  return is;\n}\ntemplate <typename T, typename U>\nostream& operator<<(ostream& os, pair<T, U> p) {\n  os << p.first << ' ' << p.second;\n  return os;\n}\ntemplate <typename T, typename U>\npair<T, U> operator-(pair<T, U> a, pair<T, U> b) {\n  return make_pair(a.first - b.first, a.second - b.second);\n}\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> a, pair<T, U> b) {\n  return make_pair(a.first + b.first, a.second + b.second);\n}\ntemplate <typename T, typename U>\nvoid umin(T& a, U b) {\n  if (a > b) a = b;\n}\ntemplate <typename T, typename U>\nvoid umax(T& a, U b) {\n  if (a < b) a = b;\n}\nstruct DSU {\n  vector<int> rk;\n  vector<int> p;\n  vector<vector<int>> comp;\n  vector<int> col;\n  int n;\n  DSU(int n = 1) : n(n) { reset(n); }\n  void reset(int n) {\n    p.resize(n);\n    iota(p.begin(), p.end(), 0);\n    col.assign(n, 0);\n    comp.resize(n);\n    for (int i = 0; i < n; ++i) {\n      comp[i].push_back(i);\n    }\n    rk.assign(n, 1);\n  }\n  int par(int v) { return v == p[v] ? v : p[v] = par(p[v]); }\n  bool un(int u, int v) {\n    bool need_ch = (col[u] == col[v]);\n    u = par(u);\n    v = par(v);\n    if (u == v) return false;\n    if (rk[u] > rk[v]) swap(u, v);\n    p[u] = v;\n    rk[v] += rk[u];\n    for (int k : comp[u]) {\n      comp[v].push_back(k);\n      if (need_ch) col[k] ^= 1;\n    }\n    return true;\n  }\n  bool check(int u, int v) { return par(u) == par(v); }\n  bool is_same(int u, int v) { return check(u, v) && col[u] == col[v]; }\n  bool is_dif(int u, int v) { return check(u, v) && col[u] != col[v]; }\n};\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int n, m;\n  cin >> n >> m;\n  vector<string> v(n);\n  cin >> v;\n  vector<int> nei;\n  vector<int> nei2;\n  DSU d(n * m);\n  auto conn = [&](int u, int v) {\n    if (d.is_same(u, v)) {\n      cout << \"NO\\n\";\n      exit(0);\n    }\n    d.un(u, v);\n  };\n  queue<pair<int, int>> fours;\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      if (v[i][j] == 'X') {\n        nei.clear();\n        if (v[i - 1][j] != 'X') nei.push_back((i - 1) * m + j);\n        if (v[i + 1][j] != 'X') nei.push_back((i + 1) * m + j);\n        if (v[i][j - 1] != 'X') nei.push_back(i * m + j - 1);\n        if (v[i][j + 1] != 'X') nei.push_back(i * m + j + 1);\n        if (nei.size() % 2 != 0) {\n          cout << \"NO\\n\";\n          return 0;\n        }\n        if (nei.empty()) continue;\n        if (nei.size() == 2) {\n          conn(nei[0], nei[1]);\n        } else {\n          fours.emplace(i, j);\n        }\n      }\n    }\n  }\n  vector<vector<bool>> u(n, vector<bool>(m, false));\n  int unch = 0;\n  while (!fours.empty()) {\n    auto [i, j] = fours.front();\n    fours.pop();\n    nei.clear();\n    if (v[i - 1][j] != 'X') nei.push_back((i - 1) * m + j);\n    if (v[i + 1][j] != 'X') nei.push_back((i + 1) * m + j);\n    if (v[i][j - 1] != 'X') nei.push_back(i * m + j - 1);\n    if (v[i][j + 1] != 'X') nei.push_back(i * m + j + 1);\n    if (nei.size() != 4) continue;\n    bool found = false;\n    for (int i = 0; i < nei.size(); ++i) {\n      for (int j = 0; j < i; ++j) {\n        if (d.is_dif(nei[i], nei[j])) {\n          found = true;\n          nei2.clear();\n          for (int k = 0; k < nei.size(); ++k) {\n            if (k == i || k == j) continue;\n            nei2.push_back(nei[k]);\n          }\n          conn(nei2[0], nei2[1]);\n          break;\n        } else if (d.is_same(nei[i], nei[j])) {\n          found = true;\n          nei2.clear();\n          for (int k = 0; k < nei.size(); ++k) {\n            if (k == i || k == j) continue;\n            nei2.push_back(nei[k]);\n          }\n          conn(nei[i], nei2[0]);\n          conn(nei[i], nei2[1]);\n          conn(nei[j], nei2[0]);\n          conn(nei[j], nei2[1]);\n          break;\n        }\n      }\n      if (found) break;\n    }\n    if (found) {\n      unch = 0;\n      continue;\n    }\n    if (unch >= fours.size() || unch >= 505) {\n      conn(nei[0], nei[2]);\n      conn(nei[1], nei[3]);\n      unch = 0;\n    } else {\n      ++unch;\n      fours.emplace(i, j);\n    }\n  }\n  vector<vector<int>> ans(n, vector<int>(m));\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      if (v[i][j] == '.') ans[i][j] = (d.col[i * m + j] ? 1 : 4);\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      if (v[i][j] == 'X') {\n        nei.clear();\n        if (v[i - 1][j] != 'X') nei.push_back((i - 1) * m + j);\n        if (v[i + 1][j] != 'X') nei.push_back((i + 1) * m + j);\n        if (v[i][j - 1] != 'X') nei.push_back(i * m + j - 1);\n        if (v[i][j + 1] != 'X') nei.push_back(i * m + j + 1);\n        for (int k : nei) ans[i][j] += (d.col[k] ? 1 : 4);\n        if (ans[i][j] % 5 != 0) {\n          cout << \"NO\\n\";\n          return 0;\n        }\n      }\n    }\n  }\n  cout << \"YES\\n\";\n  for (auto& l : ans) cout << l << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int Rd() {\n  int s = 0;\n  char fl = 0, c = getchar();\n  while (c < '0' || c > '9') fl |= (c == '-'), c = getchar();\n  while (c >= '0' && c <= '9')\n    s = (s << 3) + (s << 1) + (c ^ 48), c = getchar();\n  return fl ? -s : s;\n}\nconst int N = 250005;\nint dx[4] = {0, 0, -1, 1}, dy[4] = {-1, 1, 0, 0};\nint n, m, a[505][505], ans[505][505];\nchar c[505];\nvector<int> vec[N];\ninline int Pos(int x, int y) { return (x - 1) * m + y; }\nint vit[N], deg[N], fl = 0;\nvoid DFS(int x) {\n  for (int i = 0, siz = vec[x].size(); i < siz; ++i) {\n    int y = vec[x][i];\n    if (!vit[y])\n      vit[y] = 5 - vit[x], DFS(y);\n    else if (vit[y] == vit[x])\n      return fl = 1, void();\n    if (fl) return;\n  }\n}\ninline void AddEdge(int x, int y) { vec[x].push_back(y), vec[y].push_back(x); }\ninline void Solve() {\n  memset(ans, 0, sizeof(ans));\n  n = Rd(), m = Rd();\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%s\", c + 1);\n    for (int j = 1; j <= m; ++j) a[i][j] = c[j] == '.';\n  }\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= m; ++j)\n      if (!a[i][j]) {\n        int num = 0, d[4];\n        for (int k = 0; k < 4; ++k) {\n          int px = i + dx[k], py = j + dy[k];\n          if (px < 1 || px > n || py < 1 || py > m) continue;\n          num += a[px][py];\n          if (a[px][py] == 1) d[num] = Pos(px, py);\n        }\n        if (num == 3 || num == 1) return puts(\"NO\"), void();\n        if (num == 4)\n          AddEdge(d[1], d[3]), AddEdge(d[3], d[2]), AddEdge(d[2], d[4]);\n        else if (num == 2)\n          AddEdge(d[1], d[2]);\n      }\n  }\n  for (int i = 1; i <= n * m; ++i) {\n    if (!vit[i]) {\n      vit[i] = 1, DFS(i);\n      if (fl) return puts(\"NO\"), void();\n    }\n  }\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j) {\n      if (!a[i][j]) {\n        for (int k = 0; k < 4; ++k) {\n          int px = i + dx[k], py = j + dy[k];\n          if (px < 1 || px > n || py < 1 || py > m) continue;\n          if (a[px][py] == 1) ans[i][j] += vit[Pos(px, py)];\n        }\n      } else\n        ans[i][j] = vit[Pos(i, j)];\n    }\n  puts(\"YES\");\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= m; ++j) printf(\"%d \", ans[i][j]);\n    puts(\"\");\n  }\n}\nint main() {\n  Solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 505 * 505 * 4;\nint n;\nusing vi = vector<int>;\nvi G[maxn];\nint dfn[maxn];\nint low[maxn];\nint scc[maxn];\nint scnt[maxn];\nint ntime;\nint scc_cnt;\nint sta[maxn];\nint sz;\nvoid tarjan(int u) {\n  dfn[u] = low[u] = ++ntime;\n  sta[sz++] = u;\n  for (int i = 0; i < G[u].size(); i++) {\n    int v = G[u][i];\n    if (!dfn[v]) {\n      tarjan(v);\n      low[u] = min(low[u], low[v]);\n    } else if (!scc[v]) {\n      low[u] = min(low[u], dfn[v]);\n    }\n  }\n  if (low[u] == dfn[u]) {\n    scc_cnt++;\n    int tmp;\n    do {\n      --sz;\n      tmp = sta[sz];\n      scc[tmp] = scc_cnt;\n      scnt[scc_cnt]++;\n    } while (tmp != u);\n  }\n}\nbool find_bcc() {\n  sz = 0;\n  memset(scc, 0, sizeof(scc));\n  memset(dfn, 0, sizeof(dfn));\n  memset(scnt, 0, sizeof(scnt));\n  ntime = scc_cnt = 0;\n  for (int i = 1; i <= n; ++i)\n    if (!dfn[i]) tarjan(i);\n  for (int i = 1; i <= n; i += 2) {\n    if (scc[i] == scc[i + 1]) return false;\n  }\n  return true;\n}\nchar s[505][505];\nint w, h;\nint id(int x, int y) { return (x - 1) * w + y; }\nint res[505][505];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint main() {\n  scanf(\"%d %d\", &h, &w);\n  n = 2 * h * w;\n  for (int i = 1; i <= h; i += 1) {\n    scanf(\"%s\", s[i] + 1);\n  }\n  for (int i = 1; i <= h; i += 1) {\n    for (int j = 1; j <= w; j += 1) {\n      if (s[i][j] == '.') continue;\n      int cnt = 0;\n      vector<int> lst;\n      for (int k = 0; k < 4; k += 1) {\n        int nx = i + dx[k];\n        int ny = j + dy[k];\n        if (s[nx][ny] == '.') {\n          cnt += 1;\n          lst.emplace_back(id(nx, ny));\n        }\n      }\n      if (cnt == 1 || cnt == 3) {\n        puts(\"NO\");\n        return 0;\n      }\n      if (!cnt) continue;\n      if (cnt == 2) {\n        G[lst[0] * 2 - 1].emplace_back(lst[1] * 2);\n        G[lst[1] * 2 - 1].emplace_back(lst[0] * 2);\n        G[lst[0] * 2].emplace_back(lst[1] * 2 - 1);\n        G[lst[1] * 2].emplace_back(lst[0] * 2 - 1);\n      }\n      if (cnt == 4) {\n        for (int i = 0; i < 2; i += 1) {\n          G[2 * lst[i]].emplace_back(2 * lst[i + 2]);\n          G[2 * lst[i] - 1].emplace_back(2 * lst[i + 2] - 1);\n          G[2 * lst[i + 2]].emplace_back(2 * lst[i]);\n          G[2 * lst[i + 2] - 1].emplace_back(2 * lst[i] - 1);\n        }\n        for (int i = 0; i < 4; i += 2) {\n          int nx = lst[(i + 1) % 4];\n          G[2 * lst[i] - 1].emplace_back(2 * nx);\n          G[2 * lst[i]].emplace_back(2 * nx - 1);\n          nx = lst[(i + 3) % 4];\n          G[2 * lst[i] - 1].emplace_back(2 * nx);\n          G[2 * lst[i]].emplace_back(2 * nx - 1);\n        }\n      }\n    }\n  }\n  if (!find_bcc())\n    puts(\"NO\");\n  else {\n    puts(\"YES\");\n    for (int i = 1; i <= h; i += 1) {\n      for (int j = 1; j <= w; j += 1) {\n        if (s[i][j] == 'X') continue;\n        int cur = id(i, j);\n        if (scc[2 * cur - 1] < scc[2 * cur])\n          res[i][j] = 1;\n        else\n          res[i][j] = 4;\n      }\n    }\n    for (int i = 1; i <= h; i += 1) {\n      for (int j = 1; j <= w; j += 1) {\n        if (s[i][j] == '.') continue;\n        for (int k = 0; k < 4; k += 1) {\n          int nx = i + dx[k];\n          int ny = j + dy[k];\n          if (s[nx][ny] == 'X') continue;\n          res[i][j] += res[nx][ny];\n        }\n      }\n    }\n    for (int i = 1; i <= h; i += 1) {\n      for (int j = 1; j <= w; j += 1) {\n        printf(\"%d%c\", res[i][j], \" \\n\"[j == w]);\n      }\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long int gcd(long long int a, long long int b) {\n  if (!b)\n    return a;\n  else\n    return gcd(b, a % b);\n}\nint dx[4] = {0, 0, 1, -1};\nint dy[4] = {1, -1, 0, 0};\nvector<vector<int>> adj(1000000);\nvector<int> color(1000000);\nvoid dfs(int v, int c) {\n  color[v] = c + 1;\n  for (int x : adj[v]) {\n    if (!color[x]) dfs(x, c ^ 1);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<string> s(n);\n  for (int i = 0; i < n; i++) cin >> s[i];\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      if (s[i][j] == '.') continue;\n      vector<int> c;\n      for (int k = 0; k < 4; k++) {\n        int x = dx[k] + i;\n        int y = dy[k] + j;\n        if (x >= 0 && y >= 0 && x < n && y < m && s[x][y] == '.')\n          c.push_back(x * m + y);\n      }\n      if ((int)(c.size()) % 2) {\n        cout << \"NO\";\n        return 0;\n      }\n      if ((int)(c.size()) == 2) {\n        adj[c[0]].push_back(c[1]);\n        adj[c[1]].push_back(c[0]);\n      } else if ((int)(c.size()) == 4) {\n        adj[c[0]].push_back(c[2]);\n        adj[c[2]].push_back(c[0]);\n        adj[c[1]].push_back(c[3]);\n        adj[c[3]].push_back(c[1]);\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      if (s[i][j] == '.' && !color[i * m + j]) dfs(i * m + j, 0);\n    }\n  }\n  vector<vector<int>> ans(n, vector<int>(m));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      ans[i][j] = 1;\n      if (color[i * m + j] == 2) ans[i][j] = 4;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      if (s[i][j] == '.') continue;\n      ans[i][j] = 0;\n      for (int k = 0; k < 4; k++) {\n        int x = dx[k] + i;\n        int y = dy[k] + j;\n        if (x >= 0 && y >= 0 && x < n && y < m && s[x][y] == '.')\n          ans[i][j] += ans[x][y];\n      }\n    }\n  }\n  cout << \"YES\" << '\\n';\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      cout << ans[i][j] << \" \";\n    }\n    cout << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 500 + 10;\nstruct node {\n  int x, y;\n};\nint n, m, deg[N][N], sum[N][N], val[N][N];\nint dis[N * N], fa[N * N];\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\nstring s[N];\nint in(int x, int y) { return 0 <= x && x < n && 0 <= y && y < m; }\nint find(int x) {\n  if (fa[x] == x) return x;\n  int anc = find(fa[x]);\n  dis[x] ^= dis[fa[x]];\n  return fa[x] = anc;\n}\nvoid con(int x, int y) {\n  sum[x][y] = 0;\n  for (int i = 0; i < 4; i++) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if (!in(nx, ny)) return;\n    sum[x][y] += val[nx][ny];\n  }\n  return;\n}\nint merge(int x, int y, int v) {\n  find(x), find(y);\n  v ^= dis[x] ^ dis[y];\n  x = find(x), y = find(y);\n  if (x == y) {\n    if (v == 0) return 1;\n    return 0;\n  }\n  dis[x] = v, fa[x] = y;\n  return 1;\n}\nint main() {\n  cin >> n >> m;\n  for (int i = 0; i < n * m; i++) fa[i] = i, dis[i] = 0;\n  for (int i = 0; i < n; i++) {\n    cin >> s[i];\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      for (int k = 0; k < 4; k++) {\n        int x = i + dx[k], y = j + dy[k];\n        if (!in(x, y)) continue;\n        if (s[i][j] != s[x][y]) {\n          deg[i][j]++;\n        }\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      if (s[i][j] == 'X' && deg[i][j] % 2 == 1) {\n        cout << \"NO\" << endl;\n        return 0;\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      if (s[i][j] != 'X' || deg[i][j] != 2) continue;\n      vector<int> x, y;\n      for (int k = 0; k < 4; k++) {\n        int nx = i + dx[k], ny = j + dy[k];\n        if (!in(nx, ny) || s[nx][ny] == 'X') continue;\n        x.push_back(nx), y.push_back(ny);\n      }\n      for (int k = 1; k < int((x).size()); k++) {\n        assert(merge(((x[k - 1]) * m + y[k - 1]), ((x[k]) * m + y[k]), 1));\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      if (s[i][j] != 'X' || deg[i][j] != 4) continue;\n      vector<int> x, y;\n      for (int k = 0; k < 4; k++) {\n        int nx = i + dx[k], ny = j + dy[k];\n        if (!in(nx, ny) || s[nx][ny] == 'X') continue;\n        x.push_back(nx), y.push_back(ny);\n      }\n      for (int k = 1; k < int((x).size()); k++) {\n        assert(merge(((x[k - 1]) * m + y[k - 1]), ((x[k]) * m + y[k]), 1));\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      if (s[i][j] == 'X') continue;\n      find(((i)*m + j));\n      sum[i][j] = val[i][j] = 1 + dis[((i)*m + j)] * 3;\n    }\n  }\n  cout << \"YES\" << endl;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      if (s[i][j] == 'X') con(i, j);\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      cout << sum[i][j] << \" \";\n    }\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\ninline char gc() {\n  static const int L = 233333;\n  static char sxd[L], *sss = sxd, *ttt = sxd;\n  if (sss == ttt) {\n    ttt = (sss = sxd) + fread(sxd, 1, L, stdin);\n    if (sss == ttt) {\n      return EOF;\n    }\n  }\n  return *sss++;\n}\ntemplate <class T>\ninline bool read(T& x) {\n  x = 0;\n  char c = gc();\n  bool flg = false;\n  for (; !isdigit(c); c = gc()) {\n    if (c == '-') {\n      flg = true;\n    } else if (c == EOF) {\n      return false;\n    }\n  }\n  for (; isdigit(c); c = gc()) {\n    x = (x * 10) + (c ^ 48);\n  }\n  if (flg) {\n    x = -x;\n  }\n  return true;\n}\ntemplate <class T>\ninline void write(T x) {\n  if (x < 0) {\n    x = -x;\n    putchar('-');\n  }\n  if (x > 9) {\n    write(x / 10);\n    x %= 10;\n  }\n  putchar(x | 48);\n}\ntemplate <class T>\ninline void writeln(T x) {\n  write(x);\n  puts(\"\");\n}\ntemplate <class T>\ninline void writesp(T x) {\n  write(x);\n  putchar(' ');\n}\nint dirx[] = {0, 0, 1, -1};\nint diry[] = {1, -1, 0, 0};\nint main() {\n  int n, m;\n  std::cin >> n >> m;\n  std::vector<std::string> mp(n);\n  std::vector<std::vector<int>> ans(n, std::vector<int>(m));\n  for (int i = 0; i < n; ++i) {\n    std::cin >> mp[i];\n  }\n  for (int i = 0; i < n; ++i) {\n    int noww = (i & 1) ? 1 : 4;\n    for (int j = 0; j < m; ++j) {\n      if (mp[i][j] == '.') {\n        ans[i][j] = noww;\n      } else if (mp[i - 1][j] == 'X') {\n        noww = 5 - noww;\n      }\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      if (mp[i][j] == 'X') {\n        for (int k = 0; k < 4; ++k) {\n          int xx = i + dirx[k];\n          int yy = j + diry[k];\n          if (mp[xx][yy] == '.') {\n            ans[i][j] += ans[xx][yy];\n          }\n        }\n        if (ans[i][j] % 5) {\n          puts(\"NO\");\n          return 0;\n        }\n      }\n    }\n  }\n  puts(\"YES\");\n  for (auto row : ans) {\n    for (auto x : row) {\n      writesp(x);\n    }\n    puts(\"\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid optIO() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n}\nstring s[520];\nint n, m;\nint dirx[] = {0, 0, -1, -1, -1, 1, 1, 1};\nint diry[] = {-1, 1, -1, 0, 1, -1, 0, 1};\nint id = 0;\nint vis[520][520], ans[520][520];\nvoid dfs(int x, int y) {\n  if (x < 0 || x >= n || y < 0 || y >= m) return;\n  if (s[x][y] == 'X') return;\n  if (vis[x][y]) return;\n  vis[x][y] = id;\n  for (int i = 0; i < 8; ++i) dfs(x + dirx[i], y + diry[i]);\n}\nbool used[250020];\nvoid solve() {\n  cin >> n >> m;\n  for (int i = 0; i < n; ++i) cin >> s[i];\n  bool ok = 1;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j) {\n      if (s[i][j] == 'X') {\n        int cnt = 0;\n        if (s[i][j + 1] == 'X') cnt++;\n        if (s[i][j - 1] == 'X') cnt++;\n        if (s[i + 1][j] == 'X') cnt++;\n        if (s[i - 1][j] == 'X') cnt++;\n        if (cnt % 2 != 0) ok = 0;\n        ans[i][j] = 5 * (2 - (cnt / 2));\n        continue;\n      }\n      if (vis[i][j]) continue;\n      id++;\n      dfs(i, j);\n    }\n  if (!ok) {\n    cout << \"No\\n\";\n    return;\n  }\n  cout << \"Yes\\n\";\n  map<int, int> mmap;\n  mmap[1] = 1;\n  for (int i = 0; i < n; ++i) {\n    int lid = vis[i][0];\n    mmap[lid] = 5 - mmap[lid];\n    int s = mmap[lid];\n    queue<int> q;\n    q.push(lid);\n    used[lid] = 1;\n    for (int j = 0; j < m; ++j) {\n      if (!vis[i][j]) continue;\n      if (lid != vis[i][j]) {\n        lid = vis[i][j];\n        s = 5 - s;\n        if (mmap.find(lid) == mmap.end()) {\n          mmap[lid] = s;\n          q.push(lid);\n        } else {\n          if (used[lid])\n            s = mmap[lid];\n          else {\n            mmap[lid] = 5 - mmap[lid];\n            s = mmap[lid];\n            q.push(lid);\n          }\n        }\n        used[lid] = 1;\n      }\n      ans[i][j] = s;\n    }\n    while (q.size()) {\n      used[q.front()] = 0;\n      q.pop();\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      cout << ans[i][j] << \" \";\n    }\n    cout << \"\\n\";\n  }\n}\nint main() {\n  optIO();\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 510;\nchar all[N][N];\nint res[N][N];\nint n, m;\nint dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nvoid f() {\n  for (int i = 1; i <= n; i++) {\n    int z = 1;\n    for (int j = 1; j <= m; j++) {\n      if (j % 2 == 0 && all[i][j] == '.')\n        res[i][j] = 1;\n      else if (j % 2 == 1 && all[i][j] == '.')\n        res[i][j] = 4;\n    }\n  }\n}\nint main() {\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      cin >> all[i][j];\n    }\n  }\n  int p = 0;\n  int ok = 1;\n  for (int i = 1; i <= n; i++) {\n    p = 0;\n    for (int j = 1; j <= m; j++) {\n      if (all[i][j] == 'X') {\n        p ^= (all[i - 1][j] == 'X');\n        int z = 0;\n        for (int k = 0; k < 4; k++) {\n          int a = i + dx[k], b = j + dy[k];\n          if (a < 1 || a > n || b < 1 || b > m) continue;\n          if (all[a][b] == 'X') continue;\n          z++;\n        }\n        if (z % 2 == 1) {\n          cout << \"NO\";\n          return 0;\n        }\n        if (z == 0)\n          res[i][j] = 0;\n        else if (z == 2)\n          res[i][j] = 5;\n        else if (z == 4)\n          res[i][j] = 10;\n      } else {\n        res[i][j] = ((j + p) & 1) ? 1 : 4;\n      }\n    }\n  }\n  cout << \"YES\" << endl;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      cout << res[i][j] << \" \";\n    }\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint n, m;\nchar s[1 << 10][1 << 10];\nint w[1 << 10][1 << 10];\nstruct pii {\n  int dx, dy;\n};\nstd::vector<pii> v[1 << 10][1 << 10];\nvoid link(int x, int y, int xx, int yy) {\n  v[x][y].push_back(pii{xx, yy});\n  v[xx][yy].push_back(pii{x, y});\n}\nvoid init(int x, int y) {\n  int cnt = (s[x - 1][y] == '.') + (s[x + 1][y] == '.') + (s[x][y - 1] == '.') +\n            (s[x][y + 1] == '.');\n  if (cnt & 1) {\n    puts(\"NO\");\n    exit(0);\n  }\n  if (cnt == 4)\n    w[x][y] = 10, link(x - 1, y, x, y - 1), link(x + 1, y, x, y + 1);\n  if (cnt == 2) {\n    w[x][y] = 5;\n    if (s[x - 1][y] == '.' && s[x + 1][y] == '.') link(x - 1, y, x + 1, y);\n    if (s[x - 1][y] == '.' && s[x][y + 1] == '.') link(x - 1, y, x, y + 1);\n    if (s[x][y - 1] == '.' && s[x + 1][y] == '.') link(x, y - 1, x + 1, y);\n    if (s[x][y - 1] == '.' && s[x][y + 1] == '.') link(x, y - 1, x, y + 1);\n    if (s[x + 1][y] == '.' && s[x][y + 1] == '.') link(x + 1, y, x, y + 1);\n    if (s[x - 1][y] == '.' && s[x][y - 1] == '.') link(x - 1, y, x, y - 1);\n  }\n}\nvoid dfs(int x, int y, int d = 1) {\n  w[x][y] = d;\n  for (pii z : v[x][y]) {\n    if (!w[z.dx][z.dy]) dfs(z.dx, z.dy, 5 - d);\n  }\n}\nint main() {\n  register int i, ii;\n  scanf(\"%d%d\", &n, &m);\n  for (i = 1; i <= n; i++) scanf(\"%s\", s[i] + 1);\n  for (i = 2; i < n; i++)\n    for (ii = 2; ii < m; ii++)\n      if (s[i][ii] == 'X') init(i, ii);\n  for (i = 1; i <= n; i++)\n    for (ii = 1; ii <= m; ii++)\n      if (s[i][ii] != 'X')\n        if (!w[i][ii]) {\n          dfs(i, ii);\n        }\n  puts(\"YES\");\n  for (i = 1; i <= n; i++, puts(\"\"))\n    for (ii = 1; ii <= m; ii++) printf(\"%d \", w[i][ii]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst long long maxn = 2e3 + 5, mod = 1e9 + 7, inf = 1e9;\nconst long double pi = 4 * atan(1.0), eps = 1e-9;\nvoid solve();\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ;\n  long long tc = 1;\n  for (long long test = (long long)(1); test <= (long long)(tc); ++test) {\n    solve();\n  }\n  return 0;\n}\nbool mark[maxn][maxn];\nlong long ans[maxn][maxn];\nlong long n, m;\nlong long c[1 << 20];\nvector<long long> g[1 << 20];\nvoid dfs(long long i) {\n  for (long long j : g[i]) {\n    if (c[j] == -1) {\n      c[j] = c[i] ^ 1;\n      dfs(j);\n    }\n  }\n}\nlong long conv(long long i, long long j) { return i * m + j; }\nvoid add(long long i, long long j) {\n  g[i].emplace_back(j);\n  g[j].emplace_back(i);\n}\nlong long dx[] = {-1, 0, 1, 0};\nlong long dy[] = {0, 1, 0, -1};\nvoid solve() {\n  cin >> n >> m;\n  fill(begin(c), end(c), -1);\n  for (long long i = (long long)(0); i <= (long long)(n - 1); ++i)\n    for (long long j = (long long)(0); j <= (long long)(m - 1); ++j) {\n      char c;\n      cin >> c;\n      if (c == 'X') mark[i][j] = 1;\n    }\n  for (long long i = (long long)(0); i <= (long long)(n - 1); ++i)\n    for (long long j = (long long)(0); j <= (long long)(m - 1); ++j) {\n      if (mark[i][j]) {\n        for (long long x = (long long)(i - 1); x <= (long long)(i + 1); ++x)\n          for (long long y = (long long)(j - 1); y <= (long long)(j + 1); ++y) {\n            vector<pair<long long, long long> > unmarked;\n            long long dir = 0;\n            for (long long d = (long long)(0); d <= (long long)(3); ++d) {\n              long long x = i + dx[d], y = j + dy[d];\n              if (!mark[x][y]) {\n                dir++;\n                unmarked.emplace_back(x, y);\n              }\n            }\n            if (dir & 1) {\n              cout << \"NO\";\n              return;\n            }\n            if (dir == 0)\n              continue;\n            else if (dir == 2) {\n              add(conv(unmarked[0].first, unmarked[0].second),\n                  conv(unmarked[1].first, unmarked[1].second));\n            } else {\n              add(conv(i - 1, j), conv(i, j - 1));\n              add(conv(i + 1, j), conv(i, j - 1));\n              add(conv(i + 1, j), conv(i, j + 1));\n            }\n          }\n      }\n    }\n  for (long long i = (long long)(0); i <= (long long)(n - 1); ++i) {\n    for (long long j = (long long)(0); j <= (long long)(m - 1); ++j) {\n      if (c[conv(i, j)] == -1 and !mark[i][j]) {\n        c[conv(i, j)] = 0;\n        dfs(conv(i, j));\n      }\n    }\n  }\n  for (long long i = (long long)(0); i <= (long long)(n - 1); ++i) {\n    for (long long j = (long long)(0); j <= (long long)(m - 1); ++j) {\n      if (c[conv(i, j)] >= 0) ans[i][j] = c[conv(i, j)] == 0 ? 1 : 4;\n    }\n  }\n  for (long long i = (long long)(0); i <= (long long)(n - 1); ++i) {\n    for (long long j = (long long)(0); j <= (long long)(m - 1); ++j) {\n      if (mark[i][j]) {\n        for (long long d = (long long)(0); d <= (long long)(3); ++d) {\n          long long x = i + dx[d], y = j + dy[d];\n          if (!mark[x][y]) ans[i][j] += ans[x][y];\n        }\n        assert(ans[i][j] % 5 == 0);\n      }\n    }\n  }\n  cout << \"YES\" << '\\n';\n  for (long long i = (long long)(0); i <= (long long)(n - 1); ++i) {\n    for (long long j = (long long)(0); j <= (long long)(m - 1); ++j)\n      cout << ans[i][j] << ' ';\n    cout << '\\n';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconstexpr int N = 505;\nint n, m;\nstd::string s;\nbool a[N][N];\nint ans[N][N];\nint f[N * N];\nstd::vector<int> v[N * N];\nint point(int x, int y) { return (x - 1) * m + y; }\nstd::pair<int, int> pos(int x) {\n  return std::make_pair((x - 1) / m + 1, (x - 1) % m + 1);\n}\nint find(int x) { return x == f[x] ? x : f[x] = find(f[x]); }\nvoid merge(int x, int y) {\n  x = find(x), y = find(y);\n  if (x == y) return;\n  f[x] = y;\n}\nint cnt(int x, int y) {\n  return !a[x - 1][y] + !a[x][y - 1] + !a[x + 1][y] + !a[x][y + 1];\n}\nvoid add(int x, int y) { v[x].push_back(y), v[y].push_back(x); }\nvoid dfs(int x, int y, int now) {\n  ans[x][y] = now ? 1 : 4;\n  for (int i : v[point(x, y)])\n    if (!ans[pos(i).first][pos(i).second])\n      dfs(pos(i).first, pos(i).second, now ^ 1);\n}\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(nullptr);\n  std::cin >> n >> m;\n  for (int i = 1; i <= n; ++i) {\n    std::cin >> s;\n    for (int j = 1; j <= m; ++j) a[i][j] = s[j - 1] == 'X';\n  }\n  std::iota(f + 1, f + n * m + 1, 1);\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n      if (a[i][j]) {\n        int x = cnt(i, j);\n        if (x & 1) return std::cout << \"NO\\n\", 0;\n        if (x == 4)\n          merge(point(i - 1, j), point(i + 1, j)),\n              merge(point(i, j - 1), point(i, j + 1));\n      }\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n      if (a[i][j]) {\n        int x = cnt(i, j);\n        if (x == 4)\n          add(find(point(i - 1, j)), find(point(i, j - 1)));\n        else if (x == 2) {\n          std::vector<int> v;\n          if (!a[i - 1][j]) v.push_back(point(i - 1, j));\n          if (!a[i + 1][j]) v.push_back(point(i + 1, j));\n          if (!a[i][j - 1]) v.push_back(point(i, j - 1));\n          if (!a[i][j + 1]) v.push_back(point(i, j + 1));\n          add(find(v.front()), find(v.back()));\n        }\n      }\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n      if (!a[i][j] && !ans[i][j] && find(point(i, j)) == point(i, j))\n        dfs(i, j, 0);\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n      if (!a[i][j]) {\n        int x = find(point(i, j));\n        ans[i][j] = ans[pos(x).first][pos(x).second];\n      }\n  std::cout << \"YES\\n\";\n  for (int i = 1; i <= n; ++i, std::cout << '\\n')\n    for (int j = 1; j <= m; ++j)\n      if (a[i][j])\n        std::cout << !a[i - 1][j] * ans[i - 1][j] +\n                         !a[i][j - 1] * ans[i][j - 1] +\n                         !a[i + 1][j] * ans[i + 1][j] +\n                         !a[i][j + 1] * ans[i][j + 1]\n                  << ' ';\n      else\n        std::cout << ans[i][j] << ' ';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nchar g[510][510];\nint s[510][510], col[250010];\nint dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};\nint h[250010], e[250010 * 10], ne[250010 * 10], idx;\nint tran(pair<int, int> p) { return (p.first - 1) * m + p.second; }\nvoid add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx++; }\nvoid dfs(int u, int c) {\n  col[u] = c;\n  for (int i = h[u]; ~i; i = ne[i]) {\n    int j = e[i];\n    if (!col[j]) dfs(j, 5 - c);\n  }\n}\nint main() {\n  memset(h, -1, sizeof h);\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%s\", g[i] + 1);\n  bool flag = true;\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      if (g[i][j] == 'X') {\n        int cnt = 0;\n        vector<pair<int, int> > v;\n        for (int d = 0; d < 4; d++)\n          if (i + dx[d] >= 1 && i + dx[d] <= n && j + dy[d] >= 1 &&\n              j + dy[d] <= m && g[i + dx[d]][j + dy[d]] == '.')\n            v.push_back(make_pair(i + dx[d], j + dy[d]));\n        if (v.size() == 2)\n          add(tran(v[0]), tran(v[1])), add(tran(v[1]), tran(v[0]));\n        else if (v.size() == 4)\n          for (int d = 0; d < 4; d++)\n            add(tran(v[d]), tran(v[(d + 1) % 4])),\n                add(tran(v[(d + 1) % 4]), tran(v[d]));\n        else if (v.size() > 0)\n          flag = false;\n      }\n  if (!flag)\n    return puts(\"NO\"), 0;\n  else {\n    puts(\"YES\");\n    for (int i = 1; i <= n * m; i++)\n      if (!col[i]) dfs(i, 1);\n    for (int i = 1; i <= n; i++)\n      for (int j = 1; j <= m; j++)\n        if (g[i][j] == '.') s[i][j] = col[tran(make_pair(i, j))];\n    for (int i = 1; i <= n; i++)\n      for (int j = 1; j <= m; j++)\n        if (g[i][j] == 'X')\n          for (int d = 0; d < 4; d++)\n            if (i + dx[d] >= 1 && i + dx[d] <= n && j + dy[d] >= 1 &&\n                j + dy[d] <= m && g[i + dx[d]][j + dy[d]] == '.')\n              s[i][j] += s[i + dx[d]][j + dy[d]];\n    for (int i = 1; i <= n; i++, puts(\"\"))\n      for (int j = 1; j <= m; j++) printf(\"%d \", s[i][j]);\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f, N = 550;\nconst int MOD = 1e9 + 7;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\ninline int lowbit(int x) { return x & (-x); }\nchar g[N][N];\nint ans[N][N];\nint n, m;\nvector<pair<int, int> > v[N][N];\nint dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\nvoid dfs(int x, int y, int k) {\n  ans[x][y] = k;\n  for (auto ite : v[x][y]) {\n    int nx = ite.first, ny = ite.second;\n    if (!ans[nx][ny]) dfs(nx, ny, 5 - k);\n  }\n}\ninline void solve() {\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) cin >> (g[i] + 1);\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      if (g[i][j] == '.') continue;\n      vector<pair<int, int> > tmp;\n      for (int k = 0; k < 4; k++) {\n        int x = i + dx[k], y = j + dy[k];\n        if (x < 1 || x > n || y < 1 || y > m || g[x][y] == 'X') continue;\n        tmp.emplace_back(x, y);\n      }\n      ans[i][j] = (int)tmp.size() / 2 * 5;\n      if (tmp.empty()) continue;\n      if (tmp.size() & 1) {\n        cout << \"NO\" << '\\n';\n        return;\n      }\n      if (tmp.size() == 2) {\n        int x1 = tmp[0].first, y1 = tmp[0].second;\n        int x2 = tmp[1].first, y2 = tmp[1].second;\n        v[x1][y1].emplace_back(x2, y2);\n        v[x2][y2].emplace_back(x1, y1);\n      } else {\n        sort(tmp.begin(), tmp.end());\n        int x[4], y[4];\n        for (int k = 0; k < 4; k++) x[k] = tmp[k].first, y[k] = tmp[k].second;\n        v[x[0]][y[0]].emplace_back(x[1], y[1]),\n            v[x[1]][y[1]].emplace_back(x[0], y[0]);\n        v[x[1]][y[1]].emplace_back(x[3], y[3]),\n            v[x[3]][y[3]].emplace_back(x[1], y[1]);\n        v[x[3]][y[3]].emplace_back(x[2], y[2]),\n            v[x[2]][y[2]].emplace_back(x[3], y[3]);\n        v[x[2]][y[2]].emplace_back(x[0], y[0]),\n            v[x[0]][y[0]].emplace_back(x[2], y[2]);\n      }\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      if (g[i][j] == 'X') continue;\n      if (!ans[i][j]) dfs(i, j, 1);\n    }\n  }\n  cout << \"YES\" << '\\n';\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) cout << ans[i][j] << ' ';\n    cout << '\\n';\n  }\n}\nint main() {\n  ios::sync_with_stdio(false), cin.tie(nullptr);\n  cout << fixed << setprecision(2);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 507;\nchar grid[MAX][MAX] = {};\nbool vis[MAX][MAX] = {};\nint val[MAX][MAX] = {}, res[MAX][MAX] = {}, color[MAX * MAX] = {};\nset<int> graph[MAX * MAX] = {};\nint ind = 0;\nvoid dfs(int x, int y) {\n  vis[x][y] = true;\n  vector<pair<int, int> > v;\n  for (int i = -1; i <= 1; i++) {\n    for (int j = -1; j <= 1; j++) {\n      v.emplace_back(x + i, y + j);\n    }\n  }\n  for (auto p : v) {\n    if (!vis[p.first][p.second] && grid[p.first][p.second] == '.') {\n      val[p.first][p.second] = ind;\n      dfs(p.first, p.second);\n    }\n  }\n}\nint flip(int x) { return (x == 1 ? 4 : 1); }\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i <= n + 1; i++) {\n    for (int j = 0; j <= m + 1; j++) {\n      if (i == 0 || j == 0 || i == n + 1 || j == m + 1) {\n        grid[i][j] = '!';\n      } else {\n        cin >> grid[i][j];\n      }\n    }\n  }\n  for (int i = 2; i <= n - 1; i++) {\n    for (int j = 2; j <= m - 1; j++) {\n      int cnt = (grid[i - 1][j] == '.') + (grid[i + 1][j] == '.') +\n                (grid[i][j - 1] == '.') + (grid[i][j + 1] == '.');\n      if (grid[i][j] == 'X' && cnt % 2 == 1) {\n        cout << \"NO\" << endl;\n        return;\n      }\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      if (grid[i][j] == '.' && !vis[i][j]) {\n        ind++;\n        val[i][j] = ind;\n        dfs(i, j);\n      }\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      if (grid[i][j] == 'X') {\n        bool horz = (grid[i][j - 1] == '.' && grid[i][j + 1] == '.');\n        bool vert = (grid[i - 1][j] == '.' && grid[i + 1][j] == '.');\n        if (horz && (val[i][j - 1] != val[i][j + 1])) {\n          graph[val[i][j - 1]].insert(val[i][j + 1]);\n          graph[val[i][j + 1]].insert(val[i][j - 1]);\n        }\n        if (vert && (val[i - 1][j] != val[i + 1][j])) {\n          graph[val[i - 1][j]].insert(val[i + 1][j]);\n          graph[val[i + 1][j]].insert(val[i - 1][j]);\n        }\n      }\n    }\n  }\n  queue<int> q;\n  for (int i = 1; i <= ind; i++) {\n    if (color[i] == 0) {\n      q.push(i);\n      color[i] = 1;\n      while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        for (int u : graph[v]) {\n          if (color[u] == 0) {\n            color[u] = (color[v] ^ 3);\n            q.push(u);\n          }\n        }\n      }\n    }\n  }\n  for (int j = 1; j <= m; j++) {\n    int curr = (j % 2 ? 4 : 1);\n    res[1][j] = curr;\n    int prev = color[val[1][j]];\n    for (int i = 2; i <= n; i++) {\n      if (grid[i][j] == '.') {\n        if (color[val[i][j]] != prev) {\n          curr = flip(curr);\n        }\n        res[i][j] = curr;\n        prev = color[val[i][j]];\n      }\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      if (grid[i][j] == 'X') {\n        if (grid[i - 1][j] == '.') {\n          res[i][j] += res[i - 1][j];\n        }\n        if (grid[i + 1][j] == '.') {\n          res[i][j] += res[i + 1][j];\n        }\n        if (grid[i][j - 1] == '.') {\n          res[i][j] += res[i][j - 1];\n        }\n        if (grid[i][j + 1] == '.') {\n          res[i][j] += res[i][j + 1];\n        }\n      }\n    }\n  }\n  cout << \"YES\" << endl;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      cout << res[i][j] << ' ';\n    }\n    cout << endl;\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  solve();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vvb = vector<vb>;\nusing vd = vector<double>;\nusing vs = vector<string>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing vpdd = vector<pdd>;\ntemplate <typename T>\nvoid ckmin(T &a, const T &b) {\n  a = min(a, b);\n}\ntemplate <typename T>\nvoid ckmax(T &a, const T &b) {\n  a = max(a, b);\n}\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nnamespace __input {\ntemplate <class T1, class T2>\nvoid re(pair<T1, T2> &p);\ntemplate <class T>\nvoid re(vector<T> &a);\ntemplate <class T, size_t SZ>\nvoid re(array<T, SZ> &a);\ntemplate <class T>\nvoid re(T &x) {\n  cin >> x;\n}\nvoid re(double &x) {\n  string t;\n  re(t);\n  x = stod(t);\n}\ntemplate <class Arg, class... Args>\nvoid re(Arg &first, Args &...rest) {\n  re(first);\n  re(rest...);\n}\ntemplate <class T1, class T2>\nvoid re(pair<T1, T2> &p) {\n  re(p.first, p.second);\n}\ntemplate <class T>\nvoid re(vector<T> &a) {\n  for (auto &x : a) re(x);\n}\ntemplate <class T, size_t SZ>\nvoid re(array<T, SZ> &a) {\n  for (auto &x : a) re(x);\n}\n}  // namespace __input\nusing namespace __input;\nnamespace __output {\ntemplate <typename T>\nstruct is_outputtable {\n  template <typename C>\n  static constexpr decltype(declval<ostream &>() << declval<const C &>(),\n                            bool())\n  test(int) {\n    return true;\n  }\n  template <typename C>\n  static constexpr bool test(...) {\n    return false;\n  }\n  static constexpr bool value = test<T>(int());\n};\ntemplate <\n    class T, typename V = decltype(declval<const T &>().begin()),\n    typename S = typename enable_if<!is_outputtable<T>::value, bool>::type>\nvoid pr(const T &x);\ntemplate <class T,\n          typename V = decltype(declval<ostream &>() << declval<const T &>())>\nvoid pr(const T &x) {\n  cout << x;\n}\ntemplate <class T1, class T2>\nvoid pr(const pair<T1, T2> &x);\ntemplate <class Arg, class... Args>\nvoid pr(const Arg &first, const Args &...rest) {\n  pr(first);\n  pr(rest...);\n}\ntemplate <class T, bool pretty = true>\nvoid prContain(const T &x) {\n  if (pretty) pr(\"{\");\n  bool fst = 1;\n  for (const auto &a : x) pr(!fst ? pretty ? \", \" : \" \" : \"\", a), fst = 0;\n  if (pretty) pr(\"}\");\n}\ntemplate <class T>\nvoid pc(const T &x) {\n  prContain<T, false>(x);\n  pr(\"\\n\");\n}\ntemplate <class T1, class T2>\nvoid pr(const pair<T1, T2> &x) {\n  pr(\"{\", x.first, \", \", x.second, \"}\");\n}\ntemplate <class T, typename V, typename S>\nvoid pr(const T &x) {\n  prContain(x);\n}\nvoid ps() { pr(\"\\n\"); }\ntemplate <class Arg>\nvoid ps(const Arg &first) {\n  pr(first);\n  ps();\n}\ntemplate <class Arg, class... Args>\nvoid ps(const Arg &first, const Args &...rest) {\n  pr(first, \" \");\n  ps(rest...);\n}\n}  // namespace __output\nusing namespace __output;\nnamespace __algorithm {\ntemplate <typename T>\nvoid dedup(vector<T> &v) {\n  sort((v).begin(), (v).end());\n  v.erase(unique((v).begin(), (v).end()), v.end());\n}\ntemplate <typename T>\ntypename vector<T>::const_iterator find(const vector<T> &v, const T &x) {\n  auto it = lower_bound((v).begin(), (v).end(), x);\n  return it != v.end() && *it == x ? it : v.end();\n}\ntemplate <typename T>\nsize_t index(const vector<T> &v, const T &x) {\n  auto it = find(v, x);\n  assert(it != v.end() && *it == x);\n  return it - v.begin();\n}\ntemplate <typename I>\nstruct _reversed_struct {\n  I &v_;\n  explicit _reversed_struct(I &v) : v_{v} {}\n  typename I::reverse_iterator begin() const { return v_.rbegin(); }\n  typename I::reverse_iterator end() const { return v_.rend(); }\n};\ntemplate <typename I>\n_reversed_struct<I> reversed(I &v) {\n  return _reversed_struct<I>(v);\n}\ntemplate <typename I>\nstruct _range_struct {\n  const I first_, last_;\n  explicit _range_struct(const I first, const I last)\n      : first_{first}, last_{last} {}\n  I begin() const { return first_; }\n  I end() const { return last_; }\n};\ntemplate <typename I>\n_range_struct<I> range(const I first, const I last) {\n  return _range_struct<I>(first, last);\n}\n}  // namespace __algorithm\nusing namespace __algorithm;\nnamespace __io {\nvoid setIO() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << setprecision(15);\n}\n}  // namespace __io\nusing namespace __io;\nstruct union_find_bipartite {\n  struct node {\n    int parent, rank, size, status;\n    bool parent_edge_parity;\n    bool is_bipartite;\n    int ct_nodes_on_root_side;\n    node() {}\n    node(int id)\n        : parent(id),\n          rank(0),\n          size(1),\n          status(-1),\n          parent_edge_parity(0),\n          is_bipartite(true),\n          ct_nodes_on_root_side(1) {}\n    int count_bipartitions() const {\n      return !is_bipartite ? 0 : status == -1 ? 2 : 1;\n    }\n    int min_nodes_on_side_1() const {\n      switch (status) {\n        case 1:\n          return ct_nodes_on_root_side;\n        case 0:\n          return size - ct_nodes_on_root_side;\n        case -1:\n          return std::min(ct_nodes_on_root_side, size - ct_nodes_on_root_side);\n        default:\n          assert(false);\n      }\n    }\n  };\n  int ct_components, ct_bipartite_components, degrees_of_freedom,\n      min_nodes_on_side_1;\n  mutable std::vector<node> data;\n  union_find_bipartite(int N = 0)\n      : ct_components(N),\n        ct_bipartite_components(N),\n        degrees_of_freedom(N),\n        min_nodes_on_side_1(0),\n        data(N) {\n    iota(data.begin(), data.end(), 0);\n  }\n\n private:\n  void subtract_component(int u) {\n    ct_components--;\n    if (data[u].is_bipartite) {\n      ct_bipartite_components--;\n      degrees_of_freedom -= data[u].status == -1;\n      min_nodes_on_side_1 -= data[u].min_nodes_on_side_1();\n    }\n  }\n  void add_component(int u) {\n    ct_components++;\n    if (data[u].is_bipartite) {\n      ct_bipartite_components++;\n      degrees_of_freedom += data[u].status == -1;\n      min_nodes_on_side_1 += data[u].min_nodes_on_side_1();\n    }\n  }\n\n public:\n  int find(int u) const {\n    if (u == data[u].parent) return u;\n    find(data[u].parent);\n    data[u].parent_edge_parity ^= data[data[u].parent].parent_edge_parity;\n    return data[u].parent = data[data[u].parent].parent;\n  }\n  bool can_constrain_node_to_side(int u, bool side) const {\n    find(u);\n    side ^= data[u].parent_edge_parity;\n    u = data[u].parent;\n    return data[u].is_bipartite &&\n           (data[u].status == -1 || data[u].status == side);\n  }\n  bool constrain_node_to_side(int u, bool side) {\n    find(u);\n    side ^= data[u].parent_edge_parity;\n    u = data[u].parent;\n    subtract_component(u);\n    if (data[u].status == -1) {\n      data[u].status = side;\n    } else {\n      data[u].is_bipartite &= data[u].status == side;\n    }\n    add_component(u);\n    return data[u].is_bipartite;\n  }\n  bool can_add_constraint_on_nodes(int u, int v, bool edge_parity) const {\n    find(u);\n    edge_parity ^= data[u].parent_edge_parity;\n    u = data[u].parent;\n    find(v);\n    edge_parity ^= data[v].parent_edge_parity;\n    v = data[v].parent;\n    return data[u].is_bipartite && data[v].is_bipartite &&\n           (data[u].status == -1 || data[v].status == -1 ||\n            (data[u].status ^ data[v].status) == edge_parity);\n  }\n  struct result {\n    bool added_connectivity;\n    bool component_is_bipartite;\n  };\n  result unite(int u, int v, bool edge_parity) {\n    find(u);\n    edge_parity ^= data[u].parent_edge_parity;\n    u = data[u].parent;\n    find(v);\n    edge_parity ^= data[v].parent_edge_parity;\n    v = data[v].parent;\n    if (u == v) {\n      subtract_component(u);\n      if (edge_parity) data[u].is_bipartite = false;\n      add_component(u);\n      return {false, data[u].is_bipartite};\n    }\n    if (data[u].rank < data[v].rank) std::swap(u, v);\n    subtract_component(u);\n    subtract_component(v);\n    data[v].parent = u;\n    data[v].parent_edge_parity = edge_parity;\n    if (data[u].rank == data[v].rank) data[u].rank++;\n    data[u].size += data[v].size;\n    data[u].is_bipartite &= data[v].is_bipartite;\n    if (edge_parity)\n      data[u].ct_nodes_on_root_side +=\n          data[v].size - data[v].ct_nodes_on_root_side;\n    else\n      data[u].ct_nodes_on_root_side += data[v].ct_nodes_on_root_side;\n    if (data[v].status != -1) {\n      bool implied_u_status = data[v].status ^ edge_parity;\n      if (data[u].status == -1)\n        data[u].status = implied_u_status;\n      else\n        data[u].is_bipartite &= data[u].status == implied_u_status;\n    }\n    add_component(u);\n    return {true, data[u].is_bipartite};\n  }\n  bool can_constrain_to_be_same(int u, int v) const {\n    return can_add_constraint_on_nodes(u, v, 0);\n  }\n  bool can_constrain_to_be_different(int u, int v) const {\n    return can_add_constraint_on_nodes(u, v, 1);\n  }\n  result constrain_to_be_same(int u, int v) { return unite(u, v, 0); }\n  result constrain_to_be_different(int u, int v) { return unite(u, v, 1); }\n};\nconst string NO = \"NO\", YES = \"YES\";\nint main() {\n  setIO();\n  int n, m;\n  re(n, m);\n  const int S = n * m;\n  auto ind = [&](int i, int j) { return i * m + j; };\n  auto row = [&](int i) { return i / m; };\n  auto col = [&](int i) { return i % m; };\n  vb marked(S);\n  for (int i = 0; i < n; i++) {\n    string line;\n    re(line);\n    for (int j = 0; j < m; j++) marked[ind(i, j)] = line[j] == 'X';\n  }\n  auto get_adj = [&](int i) {\n    vi res;\n    for (int j : {i + 1, i - 1, i + m, i - m}) {\n      if (marked[j]) continue;\n      res.push_back(j);\n    }\n    return res;\n  };\n  vi special;\n  union_find_bipartite uf(S);\n  for (int i = 0; i < S; i++) {\n    if (!marked[i]) continue;\n    auto adj = get_adj(i);\n    if (int((adj).size()) == 0) continue;\n    if (int((adj).size()) == 1 || int((adj).size()) == 3) {\n      ps(NO);\n      return 0;\n    }\n    if (int((adj).size()) == 4) {\n      for (int u : adj) {\n        for (int v : adj) {\n          if (u == v) continue;\n          uf.unite(u, v, !(row(u) == row(v) || col(u) == col(v)));\n        }\n      }\n      continue;\n    }\n    uf.unite(adj.front(), adj.back(), 1);\n  }\n  if (uf.ct_bipartite_components != uf.ct_components) {\n    ps(NO);\n    return 0;\n  }\n  ps(YES);\n  for (int i = 0; i < S; i++) {\n    if (marked[i]) continue;\n    if (uf.can_constrain_node_to_side(i, 0)) uf.constrain_node_to_side(i, 0);\n  }\n  vvi ans(n, vi(m));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      int u = ind(i, j);\n      if (marked[u]) continue;\n      ans[i][j] = uf.can_constrain_node_to_side(u, 0) ? 1 : 4;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      int u = ind(i, j);\n      if (!marked[u]) continue;\n      for (int v : get_adj(u)) ans[i][j] += ans[row(v)][col(v)];\n      assert(ans[i][j] % 5 == 0);\n    }\n  }\n  for (auto &i : ans) pc(i);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  char ch = getchar();\n  int nega = 1;\n  while (!isdigit(ch)) {\n    if (ch == '-') nega = -1;\n    ch = getchar();\n  }\n  int ans = 0;\n  while (isdigit(ch)) {\n    ans = ans * 10 + ch - 48;\n    ch = getchar();\n  }\n  if (nega == -1) return -ans;\n  return ans;\n}\nvoid print(vector<int> x) {\n  for (int i = 0; i < (int)x.size(); i++)\n    printf(\"%d%c\", x[i], \" \\n\"[i == (int)x.size() - 1]);\n}\nint fa[505 * 505 * 2], n, m;\nchar s[505][505];\nint find(int u) { return fa[u] == u ? u : fa[u] = find(fa[u]); }\nint getid(int x, int y) { return (x - 1) * m + y; }\nint dx[] = {-1, 1, 0, 0}, dy[] = {0, 0, 1, -1};\nint ans[505][505];\nsigned main() {\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) scanf(\"%s\", s[i] + 1);\n  for (int i = 2; i < n; i++)\n    for (int j = 2; j < m; j++) {\n      if (s[i][j] == '.') continue;\n      int cnt = 0;\n      for (int k = 0; k < 4; k++) {\n        int tx = i + dx[k], ty = j + dy[k];\n        if (s[tx][ty] == '.') cnt++;\n      }\n      if (cnt & 1) {\n        cout << \"NO\\n\";\n        return 0;\n      }\n    }\n  for (int i = 1; i <= 2 * n * m; i++) fa[i] = i;\n  cout << \"YES\\n\";\n  for (int i = 1; i < n; i++)\n    for (int j = 1; j < m; j++) {\n      if (s[i][j] == '.' && s[i + 1][j + 1] == '.') {\n        int u = getid(i, j), v = getid(i + 1, j + 1);\n        fa[find(u)] = find(v + n * m), fa[find(u + n * m)] = find(v);\n      }\n    }\n  for (int i = 1; i < n; i++)\n    for (int j = 2; j <= m; j++) {\n      if (s[i][j] == '.' && s[i + 1][j - 1] == '.') {\n        int u = getid(i, j), v = getid(i + 1, j - 1);\n        fa[find(u)] = find(v + n * m), fa[find(u + n * m)] = find(v);\n      }\n    }\n  for (int i = 2; i < n; i++)\n    for (int j = 2; j < m; j++) {\n      if (s[i][j] != 'X') continue;\n      if (s[i - 1][j] == '.' && s[i + 1][j] == '.' && s[i][j + 1] != '.') {\n        int u = getid(i - 1, j), v = getid(i + 1, j);\n        fa[find(u)] = find(v + n * m), fa[find(u + n * m)] = find(v);\n      }\n      if (s[i][j - 1] == '.' && s[i][j + 1] == '.' && s[i + 1][j] != '.') {\n        int u = getid(i, j - 1), v = getid(i, j + 1);\n        fa[find(u)] = find(v + n * m), fa[find(u + n * m)] = find(v);\n      }\n    }\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) {\n      int u = getid(i, j);\n      if (find(u) != find(1) && find(u + n * m) != find(1))\n        fa[find(u)] = find(1);\n    }\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) {\n      if (s[i][j] == '.') {\n        if (find(getid(i, j)) == find(1))\n          ans[i][j] = 1;\n        else\n          ans[i][j] = 4;\n      } else {\n        int cnt = 0;\n        for (int k = 0; k < 4; k++) {\n          int tx = i + dx[k], ty = j + dy[k];\n          if (s[tx][ty] == '.') cnt++;\n        }\n        ans[i][j] = cnt / 2 * 5;\n      }\n    }\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) printf(\"%d%c\", ans[i][j], \" \\n\"[j == m]);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1e9 + 7;\nconst long long MOD = 998244353;\nvector<vector<long long> > adj;\nlong long color[1000005];\nbool v[1000005] = {0};\nlong long block(long long x, long long y, long long m) { return m * x + y; }\nvoid dfs(long long idx, long long y) {\n  v[idx] = 1;\n  color[idx] = y;\n  for (auto x : adj[idx]) {\n    if (!v[x]) {\n      dfs(x, y ^ 1);\n    } else if (v[x]) {\n      assert(color[x] == (y ^ 1));\n    }\n  }\n}\nint main(void) {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  long long n, m;\n  cin >> n >> m;\n  char arr[n][m];\n  long long ans[n][m];\n  for (long long i = 0; i < n; i++) {\n    for (long long j = 0; j < m; j++) {\n      cin >> arr[i][j];\n    }\n  }\n  bool ok = 1;\n  long long ola = n * m + 10;\n  adj.assign(ola, vector<long long>());\n  long long dx[4] = {0, 0, 1, -1};\n  long long dy[4] = {1, -1, 0, 0};\n  for (long long i = 0; i < n; i++) {\n    for (long long j = 0; j < m; j++) {\n      if (arr[i][j] == 'X') {\n        long long posa = 0;\n        vector<long long> ex;\n        for (long long k = 0; k < 4; k++) {\n          long long x = i + dx[k], y = dy[k] + j;\n          if (arr[x][y] == '.') {\n            ex.push_back(block(x, y, m));\n            posa++;\n          }\n        }\n        if (posa == 2) {\n          for (long long i = 0; i < posa; i++) {\n            adj[ex[i]].push_back(ex[(i + 1) % posa]);\n            adj[ex[(i + 1) % posa]].push_back(ex[i]);\n          }\n        } else if (posa == 4) {\n          adj[ex[0]].push_back(ex[3]);\n          adj[ex[3]].push_back(ex[0]);\n          adj[ex[2]].push_back(ex[1]);\n          adj[ex[1]].push_back(ex[2]);\n        }\n        if (posa % 2) {\n          ok = 0;\n        }\n      }\n    }\n  }\n  if (!ok) {\n    cout << \"NO\";\n    return 0;\n  }\n  for (long long i = 0; i < n; i++) {\n    for (long long j = 0; j < m; j++) {\n      if (arr[i][j] == '.' && !v[block(i, j, m)]) {\n        dfs(block(i, j, m), 0);\n      }\n      if (arr[i][j] == '.') {\n        ans[i][j] = 1;\n        if (color[block(i, j, m)] == 1) {\n          ans[i][j] = 4;\n        }\n      }\n    }\n  }\n  cout << \"YES\\n\";\n  for (long long i = 0; i < n; i++) {\n    for (long long j = 0; j < m; j++) {\n      if (arr[i][j] == 'X') {\n        ans[i][j] = 0;\n        for (long long k = 0; k < 4; k++) {\n          long long x = i + dx[k], y = dy[k] + j;\n          if (arr[x][y] == '.') {\n            ans[i][j] += ans[x][y];\n          }\n        }\n      }\n      cout << ans[i][j] << \" \";\n    }\n    cout << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 500;\nchar a[N + 5][N + 5];\nint ans[N + 5][N + 5];\nint nx[4][2] = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%s\", a[i] + 1);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      if (a[i][j] == 'X') {\n        int tot = 0;\n        for (int k = 0; k <= 3; k++) {\n          int dx = i + nx[k][0];\n          int dy = j + nx[k][1];\n          if (dx <= 0 || dx > n || dy <= 0 || dy > m) continue;\n          if (a[dx][dy] == '.') tot++;\n        }\n        if (tot % 2) {\n          printf(\"NO\");\n          return 0;\n        }\n        ans[i][j] = tot / 2 * 5;\n      }\n  printf(\"YES\\n\");\n  int temp = 1;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      if (a[i][j] == '.')\n        ans[i][j] = temp;\n      else if (a[i - 1][j] == 'X')\n        temp ^= 5;\n    }\n    temp ^= 5;\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) printf(\"%d \", ans[i][j]);\n    printf(\"\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int MAX = 600;\nlong long int n, m;\nlong long int A[MAX + 1][MAX + 1] = {0};\nbool vis[MAX + 1][MAX + 1] = {0};\nlong long int out[MAX + 1][MAX + 1] = {0};\nlong long int cmp[MAX + 1][MAX + 1] = {0};\nlong long int c = 0;\nlong long int color[MAX * MAX + 1];\nlong long int dx[] = {-1, 1, 0, 0, 1, 1, -1, -1};\nlong long int dy[] = {0, 0, 1, -1, 1, -1, 1, -1};\nvector<long long int> adj[MAX * MAX + 1];\nbool in(long long int x, long long int y) {\n  return ((1 <= x) && (x <= n) && (1 <= y) && (y <= m));\n}\nbool is(long long int x, long long int y) {\n  return ((A[x][y] == 1) && (A[x + 1][y] == 1) && (A[x - 1][y] == 1) &&\n          (A[x][y - 1] == 0) && (A[x][y + 1] == 0));\n}\nvoid DFS(long long int i, long long int j) {\n  vis[i][j] = true;\n  cmp[i][j] = c;\n  for (long long int z = 0; z < 8; z++) {\n    if (in(i + dx[z], j + dy[z])) {\n      if (!vis[i + dx[z]][j + dy[z]]) {\n        if (A[i + dx[z]][j + dy[z]] == 0) DFS(i + dx[z], j + dy[z]);\n      }\n    }\n  }\n}\nvoid bipartite() {\n  vector<bool> vis(c + 1, false);\n  queue<long long int> q;\n  color[1] = 0;\n  q.push(1);\n  vis[1] = true;\n  while (!q.empty()) {\n    long long int v = q.front();\n    q.pop();\n    for (auto u : adj[v]) {\n      if (vis[u]) continue;\n      color[u] = 1 - color[v];\n      q.push(u);\n      vis[u] = true;\n    }\n  }\n}\nvoid solve() {\n  cin >> n >> m;\n  for (long long int j = 1; j <= n; j++) {\n    for (long long int i = 1; i <= m; i++) {\n      char ch;\n      cin >> ch;\n      if (ch == 'X') A[j][i] = 1;\n    }\n  }\n  for (long long int j = 1; j <= n; j++) {\n    for (long long int i = 1; i <= m; i++) {\n      if (vis[j][i]) continue;\n      c++;\n      DFS(j, i);\n    }\n  }\n  for (long long int j = 1; j <= n; j++) {\n    for (long long int i = 1; i <= m; i++) {\n      if (A[j][i]) {\n        long long int cnt = 0;\n        for (long long int z = 0; z < 4; z++)\n          cnt += (A[j + dx[z]][i + dy[z]] == 0);\n        if (cnt % 2) {\n          cout << \"NO\\n\";\n          return;\n        }\n      }\n    }\n  }\n  cout << \"YES\\n\";\n  for (long long int j = 1; j <= n; ++j) {\n    for (long long int i = 1; i <= m; i++) {\n      if (is(j, i)) {\n        adj[cmp[j][i - 1]].push_back(cmp[j][i + 1]);\n        adj[cmp[j][i + 1]].push_back(cmp[j][i - 1]);\n      }\n    }\n  }\n  bipartite();\n  for (long long int j = 1; j <= n; j++) {\n    for (long long int i = 1; i <= m; i++) {\n      if (A[j][i] == 0) {\n        if (color[cmp[j][i]] % 2 == i % 2) {\n          out[j][i] = 4;\n        } else\n          out[j][i] = 1;\n      }\n    }\n  }\n  for (long long int j = 1; j <= n; j++) {\n    for (long long int i = 1; i <= m; i++) {\n      if (A[j][i]) {\n        long long int c = 0;\n        c += out[j - 1][i] * (A[j - 1][i] == 0);\n        c += out[j + 1][i] * (A[j + 1][i] == 0);\n        c += out[j][i - 1] * (A[j][i - 1] == 0);\n        c += out[j][i + 1] * (A[j][i + 1] == 0);\n        out[j][i] = c;\n        assert(c % 5 == 0);\n      }\n    }\n  }\n  for (long long int j = 1; j <= n; j++) {\n    for (long long int i = 1; i <= m; i++) {\n      cout << out[j][i] << ' ';\n    }\n    cout << '\\n';\n  }\n  return;\n}\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  long long int t;\n  t = 1;\n  for (long long int j = 1; j <= MAX * MAX; j++) color[j] = -1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = long unsigned long;\nusing ld = double long;\nconst int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\nconst int dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\nint n, m;\nstring s[505];\nint dist[505][505], sol[505][505];\nint main() {\n  ios::sync_with_stdio(!cin.tie(0));\n  cin >> n >> m;\n  for (int i = 0; i < n; i++) cin >> s[i];\n  for (int i = 1; i < n - 1; i++) {\n    for (int j = 1; j < m - 1; j++) {\n      if (s[i][j] == 'X') {\n        int c = 0;\n        c += s[i - 1][j] == '.';\n        c += s[i + 1][j] == '.';\n        c += s[i][j - 1] == '.';\n        c += s[i][j + 1] == '.';\n        if (c % 2 == 1) {\n          cout << \"NO\\n\";\n          return 0;\n        }\n      }\n    }\n  }\n  memset(dist, 255, sizeof(dist));\n  deque<pair<int, int>> q;\n  dist[0][0] = 0;\n  q.push_back({0, 0});\n  while (q.size()) {\n    auto [x, y] = q.front();\n    q.pop_front();\n    for (int d = 0; d < 8; d++) {\n      int u = x + dx[d];\n      int v = y + dy[d];\n      if (u < 0 || v < 0 || u >= n || v >= m) continue;\n      if (abs(dx[d]) + abs(dy[d]) == 2 && (s[u][v] == 'X' || s[x][y] == 'X')) {\n        continue;\n      }\n      if (dist[u][v] == -1) {\n        if (s[u][v] == 'X') {\n          dist[u][v] = dist[x][y] + 1;\n          q.push_back({u, v});\n        } else {\n          dist[u][v] = dist[x][y];\n          q.push_front({u, v});\n        }\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      if (s[i][j] == '.') {\n        sol[i][j] = ((i + dist[i][j]) % 2) * 3 + 1;\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      if (s[i][j] == 'X') {\n        int c = 0;\n        c += sol[i - 1][j] * (s[i - 1][j] == '.');\n        c += sol[i + 1][j] * (s[i + 1][j] == '.');\n        c += sol[i][j - 1] * (s[i][j - 1] == '.');\n        c += sol[i][j + 1] * (s[i][j + 1] == '.');\n        sol[i][j] = c;\n      }\n    }\n  }\n  cout << \"YES\\n\";\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      cout << sol[i][j] << \" \\n\"[j == m - 1];\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"popcnt\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int maxn = 555;\nint n, m;\nint dx[] = {0, 0, -1, 1};\nint dy[] = {-1, 1, 0, 0};\nchar c[maxn][maxn];\nint res[maxn][maxn];\nbool valid(int x, int y) { return (x > 0 && y > 0 && x <= n && y <= m); }\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> m;\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j) cin >> c[i][j];\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n      if (c[i][j] == 'X') {\n        int cnt = 0;\n        for (int k = 0; k <= 3; ++k) {\n          int x = i + dx[k];\n          int y = j + dy[k];\n          if (!valid(x, y)) continue;\n          cnt += (c[x][y] == '.');\n        }\n        if (cnt % 2) return cout << \"NO\\n\", 0;\n        res[i][j] = cnt / 2 * 5;\n      }\n  int tmp = 1;\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= m; ++j) {\n      if (c[i][j] == '.')\n        res[i][j] = tmp;\n      else if (valid(i - 1, j) && c[i - 1][j] == 'X')\n        tmp = 5 - tmp;\n    }\n    tmp = 5 - tmp;\n  }\n  cout << \"YES\" << '\\n';\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j) cout << res[i][j] << \" \\n\"[j == m];\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse4\")\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing pii = pair<int, int>;\nusing vpi = vector<pii>;\nusing pll = pair<ll, ll>;\nusing vl = vector<ll>;\nusing vpl = vector<pll>;\nusing ld = long double;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\nconst int MOD = 1e9 + 7;\nconst ld PI = acos((ld)-1.0);\nconst int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ntemplate <typename T>\nusing pqg = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T>\nbool ckmin(T &a, const T &b) {\n  return b < a ? a = b, 1 : 0;\n}\ntemplate <typename T>\nbool ckmax(T &a, const T &b) {\n  return b > a ? a = b, 1 : 0;\n}\ntemplate <typename A, typename B>\nostream &operator<<(ostream &os, const pair<A, B> &p) {\n  return os << '(' << p.first << \", \" << p.second << ')';\n}\ntemplate <typename T_container, typename T = typename enable_if<\n                                    !is_same<T_container, string>::value,\n                                    typename T_container::value_type>::type>\nostream &operator<<(ostream &os, const T_container &v) {\n  os << '{';\n  string sep;\n  for (const T &x : v) os << sep << x, sep = \", \";\n  return os << '}';\n}\nvoid dbg_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n  cerr << ' ' << H;\n  dbg_out(T...);\n}\nstruct chash {\n  static uint64_t splitmix64(uint64_t x) {\n    x += 0x9e3779b97f4a7c15;\n    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n    return x ^ (x >> 31);\n  }\n  size_t operator()(uint64_t x) const {\n    static const uint64_t FIXED_RANDOM =\n        chrono::steady_clock::now().time_since_epoch().count();\n    return splitmix64(x + FIXED_RANDOM);\n  }\n  size_t operator()(pair<uint64_t, uint64_t> x) const {\n    static const uint64_t FIXED_RANDOM =\n        chrono::steady_clock::now().time_since_epoch().count();\n    return splitmix64(x.first + FIXED_RANDOM) ^\n           (splitmix64(x.second + FIXED_RANDOM) >> 1);\n  }\n};\nvoid setIO(string s) {\n  freopen((s + \".in\").c_str(), \"r\", stdin);\n  freopen((s + \".out\").c_str(), \"w\", stdout);\n}\nint grid[501][501];\nint ans[501][501];\nbool vis[501][501];\nint n, m;\nvi g[250000];\nvoid add(int x, int y) { g[x].push_back(y), g[y].push_back(x); }\nint conv(pii z) {\n  auto [x, y] = z;\n  return x * m + y;\n}\npii conv(int x) { return {x / m, x % m}; }\nbool good(int x, int y) { return x >= 0 && x < n && y >= 0 && y < m; }\nvoid solve() {\n  cin >> n >> m;\n  for (int i = (0); i < (n); ++i)\n    for (int j = (0); j < (m); ++j) {\n      char c;\n      cin >> c;\n      if (c == '.')\n        grid[i][j] = 0;\n      else\n        grid[i][j] = 1;\n    }\n  for (int i = (0); i < (n); ++i)\n    for (int j = (0); j < (m); ++j) {\n      if (!grid[i][j]) continue;\n      int cnt = 0;\n      vpi adj;\n      for (int k = (0); k < (4); ++k) {\n        int ni = i + dx[k], nj = j + dy[k];\n        if (good(ni, nj) && !grid[ni][nj]) adj.emplace_back(ni, nj), cnt++;\n      }\n      if (cnt & 1) {\n        cout << \"NO\\n\";\n        return;\n      } else\n        ans[i][j] = cnt * 5 / 2;\n      42;\n      for (int k = (0); k < ((int)(adj).size()); ++k) {\n        add(conv(adj[k]), conv(adj[(k + 1) % (int)(adj).size()]));\n      }\n    }\n  function<void(int, int, int)> dfs = [&](int x, int y, int z) {\n    vis[x][y] = 1;\n    ans[x][y] = (z ? 1 : 4);\n    42;\n    for (auto e : g[conv(make_pair(x, y))]) {\n      42;\n      auto [x1, y1] = conv(e);\n      if (!vis[x1][y1]) dfs(x1, y1, z ^ 1);\n    }\n  };\n  for (int i = (0); i < (n); ++i)\n    for (int j = (0); j < (m); ++j) {\n      if (!grid[i][j] && !vis[i][j]) {\n        dfs(i, j, 0);\n      }\n    }\n  cout << \"YES\"\n       << \"\\n\";\n  for (int i = (0); i < (n); ++i) {\n    for (int j = (0); j < (m); ++j) {\n      cout << ans[i][j] << \" \";\n    }\n    cout << \"\\n\";\n  }\n}\nint main() {\n  cin.tie(0)->sync_with_stdio(0);\n  cin.exceptions(cin.failbit);\n  int testcase = 1;\n  while (testcase--) {\n    solve();\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 517;\nint n, m, dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}, ans[N][N];\nchar mp[N][N];\nint fr[N * N], to[N * N * 8], nxt[N * N * 8], tails;\nvoid add(int ff, int tt) {\n  if (ff == 0 || tt == 0) return;\n  to[++tails] = tt;\n  nxt[tails] = fr[ff];\n  fr[ff] = tails;\n}\nint gp(int x, int y) { return x * m + y; }\nvoid dfs(int x, int y, int fill) {\n  for (int p = fr[gp(x, y)], v, xx, yy; p; p = nxt[p]) {\n    v = to[p];\n    xx = (v - 1) / m, yy = (v - 1) % m + 1;\n    if (ans[xx][yy]) continue;\n    ans[xx][yy] = fill ^ 1 ^ 4;\n    dfs(xx, yy, ans[xx][yy]);\n  }\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) scanf(\"%s\", mp[i] + 1);\n  for (int i = 2; i < n; ++i) {\n    for (int j = 2; j < m; ++j) {\n      if (mp[i][j] == '.') continue;\n      int cnt = (mp[i][j - 1] == '.') + (mp[i][j + 1] == '.') +\n                (mp[i - 1][j] == '.') + (mp[i + 1][j] == '.');\n      if (cnt & 1) {\n        printf(\"NO\");\n        return 0;\n      }\n      for (int dir = 0, last = 0; dir < 4; ++dir) {\n        if (mp[i + dx[dir]][j + dy[dir]] == '.') {\n          add(last, gp(i + dx[dir], j + dy[dir]));\n          add(gp(i + dx[dir], j + dy[dir]), last);\n          last = gp(i + dx[dir], j + dy[dir]);\n        }\n      }\n    }\n  }\n  for (int op = m + 1, x, y; op <= n * m + m; ++op) {\n    x = (op - 1) / m, y = (op - 1) % m + 1;\n    if (ans[x][y] || mp[x][y] == 'X') continue;\n    ans[x][y] = 1;\n    dfs(x, y, 1);\n  }\n  printf(\"YES\\n\");\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= m; ++j) {\n      if (ans[i][j])\n        printf(\"%d \", ans[i][j]);\n      else if (mp[i][j] == '.') {\n        ans[i][j] = 1;\n        printf(\"%d \", ans[i][j]);\n      } else {\n        for (int dir = 0; dir < 4; ++dir) {\n          if (mp[i + dx[dir]][j + dy[dir]] == '.')\n            ans[i][j] += ans[i + dx[dir]][j + dy[dir]];\n        }\n        printf(\"%d \", ans[i][j]);\n      }\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,abm,mmx,tune=native\")\nusing namespace std;\nlong long gcd(long long i, long long j) {\n  if (j == 0)\n    return i;\n  else\n    return gcd(j, i % j);\n}\ntemplate <typename T>\ninline T getint() {\n  T val = 0;\n  char c;\n  bool neg = false;\n  while ((c = getchar()) && !(c >= '0' && c <= '9')) {\n    neg |= c == '-';\n  }\n  do {\n    val = (val * 10) + c - '0';\n  } while ((c = getchar()) && (c >= '0' && c <= '9'));\n  return val * (neg ? -1 : 1);\n}\nconst long long INF = 1e18 + 100;\nconst int mod = 1000000007;\nconst double eps = 1e-11, pi = acos(-1);\nconst long long maxN = 500048, maxT = 600100, A = 179, K = 170;\nmt19937 mt_rand(time(0));\nlong long bp(long long et, long long b) {\n  b %= mod - 1;\n  et %= mod;\n  long long res = 1;\n  for (int i = 30; i >= 0; --i) {\n    res = (res * res) % mod;\n    if ((b & (1 << i)) != 0) res = (res * et) % mod;\n  }\n  return res;\n}\nvoid panic() {\n  cout << \"NO\\n\";\n  exit(0);\n}\nvector<vector<int>> g, g1;\nvector<int> used, ts;\nint cnt, n, m;\nint code(pair<int, int> p) { return m * p.first + p.second; }\nvector<set<int>> comp;\nvoid dfs1(int v) {\n  used[v] = 1;\n  if (comp.back().count(v - cnt) || comp.back().count(v + cnt)) panic();\n  comp.back().insert(v);\n  for (auto x : g1[v]) {\n    if (used[x]) continue;\n    dfs1(x);\n  }\n}\nvoid dfs(int v) {\n  used[v] = 1;\n  for (auto x : g[v]) {\n    if (used[x]) continue;\n    dfs(x);\n  }\n  ts.push_back(v);\n}\nvoid solve() {\n  cin >> n >> m;\n  vector<vector<int>> ans(n, vector<int>(m, 1));\n  vector<string> a(n);\n  for (auto& x : a) cin >> x;\n  cnt = n * m;\n  g.assign(2 * cnt, vector<int>());\n  g1.assign(2 * cnt, vector<int>());\n  const vector<pair<int, int>> go = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      if (a[i][j] == '.') continue;\n      vector<pair<int, int>> nb;\n      for (auto pi : go) {\n        int x, y;\n        tie(x, y) = pi;\n        x += i;\n        y += j;\n        if (a[x][y] == '.') nb.push_back({x, y});\n      }\n      if (nb.size() % 2) panic();\n      if (nb.size() == 0) {\n        ans[i][j] = 0;\n      } else {\n        if (nb.size() == 2) {\n          ans[i][j] = 5;\n          g[code(nb[0]) + cnt].push_back(code(nb[1]));\n          g[code(nb[1]) + cnt].push_back(code(nb[0]));\n          g[code(nb[0])].push_back(code(nb[1]) + cnt);\n          g[code(nb[1])].push_back(code(nb[0]) + cnt);\n        } else {\n          ans[i][j] = 10;\n          for (int i = 0; i < 4; ++i) {\n            g[code(nb[i]) + cnt].push_back(code(nb[(i + 1) % 4]));\n            g[code(nb[i])].push_back(code(nb[(i + 1) % 4]) + cnt);\n          }\n        }\n      }\n    }\n  }\n  used.assign(2 * cnt, 0);\n  for (int i = 0; i < 2 * cnt; ++i) {\n    if (used[i]) continue;\n    dfs(i);\n  }\n  for (int i = 0; i < 2 * cnt; ++i) {\n    for (auto x : g[i]) g1[x].push_back(i);\n  }\n  used.assign(2 * cnt, 0);\n  reverse(ts.begin(), ts.end());\n  for (auto i : ts) {\n    if (used[i]) continue;\n    comp.push_back(set<int>());\n    dfs1(i);\n  }\n  reverse(comp.begin(), comp.end());\n  used.assign(cnt, 0);\n  for (auto vec : comp) {\n    for (auto t : vec) {\n      int v = 1;\n      if (t >= cnt) {\n        t -= cnt;\n        v = 4;\n      }\n      int x = t / m, y = t % m;\n      if (a[x][y] == 'X') continue;\n      if (used[t]) continue;\n      used[t] = 1;\n      ans[x][y] = v;\n    }\n  }\n  cout << \"YES\\n\";\n  for (auto vec : ans) {\n    for (auto x : vec) {\n      cout << x << \" \";\n    }\n    cout << \"\\n\";\n  }\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cout.precision(20);\n  srand(time(0));\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int64_t>> g;\nvector<int64_t> vis;\nmap<pair<int64_t, int64_t>, int64_t> r;\nmap<int64_t, pair<int64_t, int64_t>> o;\nmap<int64_t, int64_t> mvp;\nvector<int64_t> path;\nvector<int64_t> dv;\nint64_t dfs(int v, int d) {\n  vis[v] = 1;\n  dv[v] = d;\n  path.push_back(v);\n  mvp[v] = path.size() - 1;\n  for (int i = 0; i < g[v].size(); ++i) {\n    if (!vis[g[v][i]]) {\n      if (dfs(g[v][i], 1 - d)) return 1;\n    } else {\n      if (abs(mvp[g[v][i]] - mvp[v]) % 2 == 0) {\n        return 1;\n      }\n    }\n  }\n  path.pop_back();\n  return 0;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  char a[n][m];\n  int64_t b[n][m];\n  int64_t num = 0;\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      cin >> a[i][j];\n      if (a[i][j] == '.') {\n        o[num] = {i, j};\n        r[{i, j}] = num++;\n      }\n    }\n  }\n  g.resize(num);\n  vis.resize(num);\n  dv.resize(num);\n  int64_t no = 0;\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      if (a[i][j] == 'X') {\n        vector<int64_t> so;\n        if (i != 0 && a[i - 1][j] == '.') so.push_back(r[{i - 1, j}]);\n        if (i != n - 1 && a[i + 1][j] == '.') so.push_back(r[{i + 1, j}]);\n        if (j != 0 && a[i][j - 1] == '.') so.push_back(r[{i, j - 1}]);\n        if (j != m - 1 && a[i][j + 1] == '.') so.push_back(r[{i, j + 1}]);\n        if (so.size() % 2 == 1) {\n          no = 1;\n        } else {\n          if (so.size() == 2) {\n            b[i][j] = 5;\n            g[so[0]].push_back(so[1]);\n            g[so[1]].push_back(so[0]);\n          } else if (so.size() == 4) {\n            g[so[0]].push_back(so[2]);\n            g[so[2]].push_back(so[0]);\n            g[so[1]].push_back(so[3]);\n            g[so[3]].push_back(so[1]);\n            b[i][j] = 10;\n          } else\n            b[i][j] = 0;\n        }\n      }\n    }\n  }\n  if (no) {\n    cout << \"NO\\n\";\n  } else {\n    int no2 = 0;\n    for (int i = 0; i < num; ++i) {\n      if (!vis[i]) {\n        if (dfs(i, 0)) no2 = 1;\n      }\n    }\n    if (no2) {\n      cout << \"NO\\n\";\n      return 0;\n    }\n    cout << \"YES\\n\";\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < m; ++j) {\n        if (a[i][j] == 'X')\n          cout << b[i][j] << ' ';\n        else\n          cout << ((dv[r[{i, j}]]) ? 4 : 1) << ' ';\n      }\n      cout << \"\\n\";\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst int N = 5e5 + 10;\nchar mp[510][510];\nint ans[510][510];\nvoid run() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%s\", mp[i] + 1);\n  }\n  int p = 0;\n  for (int i = 0; i <= n + 1; i++) {\n    mp[i][0] = 'X';\n    mp[i][m + 1] = 'X';\n  }\n  for (int i = 0; i <= m + 1; i++) {\n    mp[0][i] = 'X';\n    mp[n + 1][i] = 'X';\n  }\n  for (int i = 1; i <= n; i++) {\n    p = 0;\n    for (int j = 1; j <= m; j++) {\n      if (mp[i][j] == 'X') {\n        p ^= (mp[i - 1][j] == 'X');\n        int num = 0;\n        if (mp[i][j - 1] == '.') num++;\n        if (mp[i][j + 1] == '.') num++;\n        if (mp[i - 1][j] == '.') num++;\n        if (mp[i + 1][j] == '.') num++;\n        if (num & 1) {\n          printf(\"NO\\n\");\n          return;\n        }\n        if (num == 0) {\n          ans[i][j] = 0;\n        }\n        if (num == 2) {\n          ans[i][j] = 5;\n        }\n        if (num == 4) {\n          ans[i][j] = 10;\n        }\n      } else {\n        ans[i][j] = ((j + p) & 1) ? 1 : 4;\n      }\n    }\n  }\n  printf(\"YES\\n\");\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      printf(\"%d \", ans[i][j]);\n    }\n    puts(\"\");\n  }\n}\nint main() {\n  run();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[4] = {-1, 0, 0, 1}, dy[4] = {0, -1, 1, 0};\nint n, m, ans[505][505];\nbool a[505][505];\nchar s[505];\nvector<pair<int, int>> to[505][505];\nvoid dfs(int i, int j) {\n  for (auto [x, y] : to[i][j]) {\n    if (ans[x][y] == ans[i][j]) {\n      puts(\"NO\");\n      exit(0);\n    }\n    if (ans[x][y] != -1) continue;\n    ans[x][y] = 5 - ans[i][j], dfs(x, y);\n  }\n}\nint main() {\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%s\", s + 1);\n    for (int j = 1; j <= m; j++)\n      if (s[j] == 'X') a[i][j] = 1;\n  }\n  memset(ans, -1, sizeof ans);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      if (a[i][j]) {\n        vector<pair<int, int>> b;\n        for (int k = 0; k < 4; k++) {\n          int x = i + dx[k], y = j + dy[k];\n          if (!a[x][y]) b.push_back(make_pair(x, y));\n        }\n        if (b.size() & 1) {\n          puts(\"NO\");\n          return 0;\n        }\n        while (!b.empty()) {\n          auto [x, y] = b.back();\n          b.pop_back();\n          auto [z, w] = b.back();\n          b.pop_back();\n          to[x][y].push_back(make_pair(z, w));\n          to[z][w].push_back(make_pair(x, y));\n        }\n      }\n  memset(ans, -1, sizeof ans);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      if (ans[i][j] == -1 && !a[i][j]) ans[i][j] = 1, dfs(i, j);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      if (a[i][j]) {\n        ans[i][j] = 0;\n        for (int k = 0; k < 4; k++)\n          if (!a[i + dx[k]][j + dy[k]]) ans[i][j] += ans[i + dx[k]][j + dy[k]];\n      }\n  puts(\"YES\");\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) printf(\"%d%c\", ans[i][j], \" \\n\"[j == m]);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nvector<int> v[300050];\nint d[][2] = {1, 0, 0, 1, -1, 0, 0, -1};\nchar mp[505][505];\nint ans[300050] = {0};\nint id(int x, int y) { return (x - 1) * m + y; }\nint cnt(int x, int y) {\n  int res = 0;\n  for (int i = 0; i < 4; i++) {\n    int nx = x + d[i][0];\n    int ny = y + d[i][1];\n    if (mp[nx][ny] == '.') res++;\n  }\n  return res;\n}\nint f = 1;\nvoid dfs(int x, int w) {\n  ans[x] = w;\n  for (int i = 0; i < v[x].size(); i++) {\n    if (!ans[v[x][i]]) dfs(v[x][i], 5 - w);\n    if (ans[v[x][i]] == ans[x]) f = 0;\n  }\n}\nint main() {\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) cin >> mp[i] + 1;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      if (mp[i][j] == 'X') {\n        int res = cnt(i, j);\n        if (res == 2) {\n          ans[id(i, j)] = 5;\n          int now = -1;\n          for (int k = 0; k < 4; k++) {\n            int nx = i + d[k][0];\n            int ny = j + d[k][1];\n            if (mp[nx][ny] == '.') {\n              if (now == -1)\n                now = id(nx, ny);\n              else {\n                v[now].push_back(id(nx, ny));\n                v[id(nx, ny)].push_back(now);\n              }\n            }\n          }\n        } else if (res == 4) {\n          ans[id(i, j)] = 10;\n          v[id(i - 1, j)].push_back(id(i, j - 1));\n          v[id(i - 1, j)].push_back(id(i, j + 1));\n          v[id(i + 1, j)].push_back(id(i, j + 1));\n          v[id(i + 1, j)].push_back(id(i, j - 1));\n          v[id(i, j - 1)].push_back(id(i - 1, j));\n          v[id(i, j + 1)].push_back(id(i - 1, j));\n          v[id(i, j + 1)].push_back(id(i + 1, j));\n          v[id(i, j - 1)].push_back(id(i + 1, j));\n        } else if (res == 0) {\n          ans[id(i, j)] = 0;\n        } else if (res % 2 == 1) {\n          printf(\"NO\\n\");\n          return 0;\n        }\n      }\n    }\n  }\n  f = 1;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      if (mp[i][j] == '.' && !ans[id(i, j)]) dfs(id(i, j), 4);\n    }\n  }\n  if (!f)\n    cout << \"NO\" << endl;\n  else {\n    cout << \"YES\\n\" << endl;\n    for (int i = 1; i <= n; i++) {\n      for (int j = 1; j <= m; j++) cout << ans[id(i, j)] << \" \";\n      cout << endl;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-6;\nconst double PI = acos(-1.0);\ninline long long read() {\n  char ch;\n  long long x = 0;\n  bool f = true;\n  for (ch = getchar(); !isdigit(ch); ch = getchar())\n    if (ch == '-') f ^= f;\n  for (; isdigit(ch); ch = getchar()) x = (x << 3) + (x << 1) + ch - 48;\n  return f ? x : -x;\n}\nconst int N = 1010;\nchar ch[N][N];\nint h[N * N], e[2 * N * N], ne[2 * N * N], idx;\nint ans[N][N];\nvoid add(int a, int b) {\n  e[++idx] = b;\n  ne[idx] = h[a];\n  h[a] = idx;\n}\nvoid dfs(int u, int res) {\n  if (ans[u / N][u % N]) return;\n  int t = (res == 1 ? 4 : 1);\n  ans[u / N][u % N] = res;\n  for (int i = h[u]; i; i = ne[i]) {\n    int j = e[i];\n    dfs(j, t);\n  }\n}\nint z(int x, int y) { return x * N + y; }\nint dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};\nvoid solve() {\n  int n = read(), m = read();\n  for (int i = 1; i <= n; i++) cin >> (ch[i] + 1);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      if (ch[i][j] == 'X') {\n        vector<int> vs;\n        for (int k = 0; k < 4; k++) {\n          if (ch[i + dx[k]][j + dy[k]] != '.') continue;\n          vs.push_back(z(i + dx[k], j + dy[k]));\n        }\n        if (vs.size() % 2 == 1) return printf(\"NO\\n\"), void(0);\n        for (int k = 0; k < vs.size(); k += 2)\n          add(vs[k], vs[k + 1]), add(vs[k + 1], vs[k]);\n      }\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) {\n      if (ch[i][j] == 'X') continue;\n      if (ans[i][j]) continue;\n      dfs(z(i, j), 1);\n    }\n  cout << \"YES\\n\";\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      if (ch[i][j] == 'X')\n        for (int k = 0; k < 4; k++)\n          if (ch[i + dx[k]][j + dy[k]] == '.')\n            ans[i][j] += ans[i + dx[k]][j + dy[k]];\n      cout << ans[i][j] << \" \";\n    }\n    cout << \"\\n\";\n  }\n}\nint main() {\n  int T = 1;\n  while (T--) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvoid optIO() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n}\nstring s[520];\nint n, m;\nint dirx[] = {0, 0, -1, -1, -1, 1, 1, 1};\nint diry[] = {-1, 1, -1, 0, 1, -1, 0, 1};\nint id = 0;\nint vis[520][520], ans[520][520];\nvoid dfs(int x, int y) {\n  if (x < 0 || x >= n || y < 0 || y >= m) return;\n  if (s[x][y] == 'X') return;\n  if (vis[x][y]) return;\n  vis[x][y] = id;\n  for (int i = 0; i < 8; ++i) dfs(x + dirx[i], y + diry[i]);\n}\nbool used[250020];\nvoid solve() {\n  cin >> n >> m;\n  for (int i = 0; i < n; ++i) cin >> s[i];\n  bool ok = 1;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j) {\n      if (s[i][j] == 'X') {\n        int cnt = 0;\n        if (s[i][j + 1] == 'X') cnt++;\n        if (s[i][j - 1] == 'X') cnt++;\n        if (s[i + 1][j] == 'X') cnt++;\n        if (s[i - 1][j] == 'X') cnt++;\n        if (cnt % 2 != 0) ok = 0;\n        ans[i][j] = 5 * (2 - (cnt / 2));\n        continue;\n      }\n      if (vis[i][j]) continue;\n      id++;\n      dfs(i, j);\n    }\n  if (!ok) {\n    cout << \"No\\n\";\n    return;\n  }\n  cout << \"Yes\\n\";\n  map<int, int> mmap;\n  mmap[1] = 1;\n  for (int i = 0; i < n; ++i) {\n    int lid = vis[i][0];\n    mmap[lid] = 5 - mmap[lid];\n    int s = mmap[lid];\n    queue<int> q;\n    q.push(lid);\n    used[lid] = 1;\n    for (int j = 0; j < m; ++j) {\n      if (!vis[i][j]) continue;\n      if (lid != vis[i][j]) {\n        lid = vis[i][j];\n        s = 5 - s;\n        if (mmap.find(lid) == mmap.end())\n          mmap[lid] = s;\n        else if (used[lid])\n          s = mmap[lid];\n        else {\n          mmap[lid] = 5 - mmap[lid];\n          s = mmap[lid];\n        }\n        q.push(lid);\n        used[lid] = 1;\n      }\n      ans[i][j] = s;\n    }\n    while (q.size()) {\n      used[q.front()] = 0;\n      q.pop();\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) cout << ans[i][j] << \" \";\n    cout << \"\\n\";\n  }\n}\nint main() {\n  optIO();\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 505;\nlong long n, m;\nchar a[N][N];\nlong long ans[N][N];\nlong long dx[4] = {0, 0, -1, +1};\nlong long dy[4] = {+1, -1, 0, 0};\nlong long get(long long x, long long y) { return (x - 1) * m + y; }\nvector<long long> g[N * N];\nlong long col[N * N];\nbool vis[N * N];\nvoid dfs(long long u, long long c) {\n  if (vis[u]) {\n    if (col[u] != c) {\n      cout << \"NO\"\n           << \"\\n\";\n      exit(0);\n    }\n    return;\n  }\n  vis[u] = 1;\n  col[u] = c;\n  for (auto &it : g[u]) dfs(it, c ^ 1);\n}\nbool check() {\n  for (long long i = 1; i <= n; i++) {\n    for (long long j = 1; j <= m; j++) {\n      if (a[i][j] == 'X') {\n        long long ct = 0;\n        vector<pair<long long, long long> > v;\n        for (long long dir = 0; dir < 4; dir++) {\n          long long nx = i + dx[dir];\n          long long ny = j + dy[dir];\n          if (nx < 1 || nx > n || ny < 1 || ny > m) continue;\n          if (a[nx][ny] == 'X')\n            ct++;\n          else\n            v.push_back({nx, ny});\n        }\n        if (v.size() >= 2) {\n          long long idx = v.size() == 2 ? 1 : 2;\n          long long uu = get(v[0].first, v[0].second);\n          long long vv = get(v[idx].first, v[idx].second);\n          g[uu].push_back(vv);\n          g[vv].push_back(uu);\n        }\n        if (v.size() == 4) {\n          long long uu = get(v[1].first, v[1].second);\n          long long vv = get(v[3].first, v[3].second);\n          g[uu].push_back(vv);\n          g[vv].push_back(uu);\n        }\n        if (ct == 3 || ct == 1) {\n          cout << \"NO\"\n               << \"\\n\";\n          exit(0);\n        } else if (ct == 4)\n          ans[i][j] = 0;\n        else if (ct == 0)\n          ans[i][j] = 10;\n        else\n          ans[i][j] = 5;\n      }\n    }\n  }\n  for (long long i = 1; i <= n * m; i++) {\n    if (vis[i]) continue;\n    if (g[i].size()) dfs(i, 0);\n  }\n}\nvoid print() {\n  cout << \"YES\"\n       << \"\\n\";\n  for (long long i = 1; i <= n; i++) {\n    for (long long j = 1; j <= m; j++) {\n      if (!ans[i][j] && a[i][j] != 'X') ans[i][j] = 1;\n      cout << ans[i][j] << \" \";\n    }\n    cout << \"\\n\";\n  }\n}\nint32_t main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  ;\n  cin >> n >> m;\n  for (long long i = 1; i <= n; i++) {\n    for (long long j = 1; j <= m; j++) cin >> a[i][j];\n  }\n  check();\n  for (long long i = 1; i <= n; i++) {\n    for (long long j = 1; j <= m; j++) {\n      if (vis[get(i, j)]) {\n        ans[i][j] = col[get(i, j)] ? 4 : 1;\n      }\n    }\n  }\n  print();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"-Ofast\", \"-funroll-all-loops\")\n#pragma GCC optimize(2)\n#pragma GCC optimize(3, \"Ofast\", \"inline\")\nusing namespace std;\nint _;\nint n, m;\nchar s[510][510];\nint a[510][510];\nint ans[510][510];\nint xx[] = {1, 0, -1, 0};\nint yy[] = {0, 1, 0, -1};\nvector<pair<int, int> > adj[510][510];\nbool check(int x, int y) { return (x >= 1 && x <= n && y >= 1 && y <= m); }\nvoid dfs(int x, int y) {\n  for (auto P : adj[x][y]) {\n    int p = P.first, q = P.second;\n    if (ans[p][q] == 0) {\n      ans[p][q] = 5 - ans[x][y];\n      dfs(p, q);\n    }\n  }\n}\nvoid solve() {\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      cin >> s[i][j];\n      a[i][j] = (s[i][j] == 'X');\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      if (!a[i][j]) continue;\n      vector<pair<int, int> > vec;\n      vec.clear();\n      for (int d = 0; d < 4; d++) {\n        int xnow = i + xx[d];\n        int ynow = j + yy[d];\n        if (check(xnow, ynow) && a[xnow][ynow] == 0) {\n          vec.push_back({xnow, ynow});\n        }\n      }\n      if (vec.size() & 1) {\n        cout << \"NO\"\n             << \"\\n\";\n        return;\n      }\n      for (auto A : vec) {\n        int x = A.first, y = A.second;\n        for (auto B : vec) {\n          int p = B.first, q = B.second;\n          if (vec.size() == 4 && (x == p || y == q)) {\n            continue;\n          }\n          if (x != p || y != q) {\n            adj[x][y].push_back({p, q});\n          }\n        }\n      }\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      if (a[i][j]) {\n        continue;\n      }\n      if (ans[i][j] == 0) {\n        ans[i][j] = 1;\n        dfs(i, j);\n      }\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      if (!a[i][j]) continue;\n      for (int d = 0; d < 4; d++) {\n        int xnow = i + xx[d];\n        int ynow = j + yy[d];\n        if (check(xnow, ynow) && a[xnow][ynow] == 0) {\n          ans[i][j] += ans[xnow][ynow];\n        }\n      }\n    }\n  }\n  cout << \"YES\"\n       << \"\\n\";\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) {\n      cout << ans[i][j] << \" \";\n    }\n    cout << \"\\n\";\n  }\n  return;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 510;\nlong long n, m;\nchar mp[N][N];\nlong long ans[N][N];\nlong long dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\nsigned main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> m;\n  for (long long i = 1; i <= n; i++) {\n    for (long long j = 1; j <= m; j++) {\n      cin >> mp[i][j];\n    }\n  }\n  long long p = 0;\n  for (long long i = 1; i <= n; i++) {\n    p = 0;\n    for (long long j = 1; j <= m; j++) {\n      if (mp[i][j] == 'X') {\n        p ^= (mp[i - 1][j] == 'X');\n        long long cnt = 0;\n        for (long long k = 0; k < 4; k++) {\n          if (mp[i + dx[k]][j + dy[k]] == '.') cnt++;\n        }\n        if (cnt & 1) {\n          cout << \"NO\" << endl;\n          return 0;\n        }\n      } else {\n        ans[i][j] = ((j + p) & 1) ? 1 : 4;\n      }\n    }\n  }\n  cout << \"YES\" << endl;\n  for (long long i = 1; i <= n; i++) {\n    for (long long j = 1; j <= m; j++) {\n      if (mp[i][j] == 'X') {\n        long long s = 0;\n        for (long long k = 0; k < 4; k++) {\n          if (mp[i + dx[k]][j + dy[k]] == '.') s += ans[i + dx[k]][j + dy[k]];\n        }\n        cout << s << ' ';\n      } else\n        cout << ans[i][j] << ' ';\n    }\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint i, j, k, n, m, t, res[505][505], sb;\nvector<pair<int, int> > v = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\nchar s[505][505];\nint main() {\n  cin >> n >> m;\n  for (i = 1; i <= n; i++) {\n    cin >> s[i] + 1;\n  }\n  for (i = 1; i <= n; i++) {\n    for (j = 1; j <= m; j++) {\n      k = 0;\n      for (auto [x, y] : v) {\n        k += (s[x + i][y + j] == '.');\n      }\n      if (s[i][j] == 'X') {\n        sb ^= (s[i - 1][j] == 'X');\n        if (k & 1) {\n          cout << \"NO\";\n          return 0;\n        }\n      } else {\n        res[i][j] = ((j + sb) & 1) ? 1 : 4;\n      }\n    }\n  }\n  puts(\"YES\");\n  for (i = 1; i <= n; i++) {\n    for (j = 1; j <= m; j++) {\n      if (s[i][j] == 'X') {\n        for (auto [x, y] : v) {\n          if (s[x + i][y + j] == '.') {\n            res[i][j] += res[x + i][y + j];\n          }\n        }\n      }\n      printf(\"%d \", res[i][j]);\n    }\n    puts(\"\");\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MAXN = 1000005;\nconst long long SQRTN = 1003;\nconst long long LOGN = 22;\nconst double PI = acos(-1);\nconst long long INF = 1e16;\nconst long long MOD = 1000000007;\nconst long long FMOD = 998244353;\nconst double eps = 1e-9;\nmt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());\ntemplate <typename T>\nT gcd(T a, T b) {\n  return (b ? __gcd(a, b) : a);\n}\ntemplate <typename T>\nT lcm(T a, T b) {\n  return (a * (b / gcd(a, b)));\n}\nlong long add(long long a, long long b, long long c = MOD) {\n  long long res = a + b;\n  return (res >= c ? res - c : res);\n}\nlong long mod_neg(long long a, long long b, long long c = MOD) {\n  long long res;\n  if (abs(a - b) < c)\n    res = a - b;\n  else\n    res = (a - b) % c;\n  return (res < 0 ? res + c : res);\n}\nlong long mul(long long a, long long b, long long c = MOD) {\n  long long res = (long long)a * b;\n  return (res >= c ? res % c : res);\n}\nlong long muln(long long a, long long b, long long c = MOD) {\n  long long res = (long long)a * b;\n  return ((res % c) + c) % c;\n}\nlong long mulmod(long long a, long long b, long long m = MOD) {\n  long long q = (long long)(((long double)a * (long double)b) / (long double)m);\n  long long r = a * b - q * m;\n  if (r > m) r %= m;\n  if (r < 0) r += m;\n  return r;\n}\ntemplate <typename T>\nT expo(T e, T n) {\n  T x = 1, p = e;\n  while (n) {\n    if (n & 1) x = x * p;\n    p = p * p;\n    n >>= 1;\n  }\n  return x;\n}\ntemplate <typename T>\nT power(T e, T n, T m = MOD) {\n  T x = 1, p = e;\n  while (n) {\n    if (n & 1) x = mul(x, p, m);\n    p = mul(p, p, m);\n    n >>= 1;\n  }\n  return x;\n}\ntemplate <typename T>\nT extended_euclid(T a, T b, T& x, T& y) {\n  T xx = 0, yy = 1;\n  y = 0;\n  x = 1;\n  while (b) {\n    T q = a / b, t = b;\n    b = a % b;\n    a = t;\n    t = xx;\n    xx = x - q * xx;\n    x = t;\n    t = yy;\n    yy = y - q * yy;\n    y = t;\n  }\n  return a;\n}\ntemplate <typename T>\nT mod_inverse(T a, T n = MOD) {\n  T x, y, z = 0;\n  T d = extended_euclid(a, n, x, y);\n  return (d > 1 ? -1 : mod_neg(x, z, n));\n}\nconst long long FACSZ = 1;\nlong long fact[FACSZ], ifact[FACSZ];\nvoid precom(long long c = MOD) {\n  fact[0] = 1;\n  for (long long i = 1; i < FACSZ; i++) fact[i] = mul(fact[i - 1], i, c);\n  ifact[FACSZ - 1] = mod_inverse(fact[FACSZ - 1], c);\n  for (long long i = FACSZ - 1 - 1; i >= 0; i--) {\n    ifact[i] = mul(i + 1, ifact[i + 1], c);\n  }\n}\nlong long ncr(long long n, long long r, long long c = MOD) {\n  if (r > n) return 0;\n  return mul(mul(ifact[r], ifact[n - r], c), fact[n], c);\n}\nvoid solvethetestcase();\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  long long t = 1;\n  for (long long testcase = 1; testcase < t + 1; testcase++) {\n    solvethetestcase();\n  }\n}\nlong long n, m;\nlong long a[505][505], sm[505][505];\nvector<pair<long long, long long> > adj[505][505];\nbool check() {\n  for (long long i = 1; i < n + 1; i++) {\n    for (long long j = 1; j < m + 1; j++) {\n      if (!a[i][j]) {\n        long long cnt = 0;\n        if (sm[i - 1][j] % 5) cnt += sm[i - 1][j];\n        if (sm[i + 1][j] % 5) cnt += sm[i + 1][j];\n        if (sm[i][j - 1] % 5) cnt += sm[i][j - 1];\n        if (sm[i][j + 1] % 5) cnt += sm[i][j + 1];\n        if (sm[i][j] != cnt) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\nvoid dfs(long long i, long long j, long long c) {\n  sm[i][j] = c;\n  for (auto x : adj[i][j]) {\n    if (sm[x.first][x.second] == 0) {\n      dfs(x.first, x.second, 5 - c);\n    }\n  }\n}\nvoid solvethetestcase() {\n  cin >> n >> m;\n  for (long long i = 1; i < n + 1; i++) {\n    for (long long j = 1; j < m + 1; j++) {\n      char c;\n      cin >> c;\n      a[i][j] = (c == '.');\n    }\n  }\n  for (long long i = 1; i < n + 1; i++) {\n    for (long long j = 1; j < m + 1; j++) {\n      if (!a[i][j]) {\n        long long cnt = a[i - 1][j] + a[i + 1][j] + a[i][j - 1] + a[i][j + 1];\n        if (cnt % 2) {\n          cout << \"NO\\n\";\n          return;\n        }\n        if (cnt == 0) sm[i][j] = 0;\n        if (cnt == 2) {\n          sm[i][j] = 5;\n          if (a[i - 1][j] and a[i + 1][j]) {\n            adj[i - 1][j].push_back({i + 1, j});\n            adj[i + 1][j].push_back({i - 1, j});\n          }\n          if (a[i - 1][j] and a[i][j - 1]) {\n            adj[i - 1][j].push_back({i, j - 1});\n            adj[i][j - 1].push_back({i - 1, j});\n          }\n          if (a[i - 1][j] and a[i][j + 1]) {\n            adj[i - 1][j].push_back({i, j + 1});\n            adj[i][j + 1].push_back({i - 1, j});\n          }\n          if (a[i + 1][j] and a[i][j - 1]) {\n            adj[i + 1][j].push_back({i, j - 1});\n            adj[i][j - 1].push_back({i + 1, j});\n          }\n          if (a[i + 1][j] and a[i][j + 1]) {\n            adj[i + 1][j].push_back({i, j + 1});\n            adj[i][j + 1].push_back({i + 1, j});\n          }\n          if (a[i][j - 1] and a[i][j + 1]) {\n            adj[i][j - 1].push_back({i, j + 1});\n            adj[i][j + 1].push_back({i, j - 1});\n          }\n        }\n        if (cnt == 4) {\n          sm[i][j] = 10;\n          adj[i + 1][j].push_back({i, j + 1});\n          adj[i - 1][j].push_back({i, j - 1});\n          adj[i][j - 1].push_back({i - 1, j});\n          adj[i][j + 1].push_back({i + 1, j});\n        }\n      }\n    }\n  }\n  for (long long i = 1; i < n + 1; i++) {\n    for (long long j = 1; j < m + 1; j++) {\n      if (sm[i][j] == 0 and a[i][j]) {\n        dfs(i, j, 1);\n      }\n    }\n  }\n  if (check()) {\n    cout << \"YES\\n\";\n  } else {\n    cout << \"NO\\n\";\n    return;\n  }\n  for (long long i = 1; i < n + 1; i++) {\n    for (long long j = 1; j < m + 1; j++) {\n      cout << sm[i][j] << \" \";\n    }\n    cout << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vvb = vector<vb>;\nusing vd = vector<double>;\nusing vs = vector<string>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing vpdd = vector<pdd>;\ntemplate <typename T>\nvoid ckmin(T &a, const T &b) {\n  a = min(a, b);\n}\ntemplate <typename T>\nvoid ckmax(T &a, const T &b) {\n  a = max(a, b);\n}\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nnamespace __input {\ntemplate <class T1, class T2>\nvoid re(pair<T1, T2> &p);\ntemplate <class T>\nvoid re(vector<T> &a);\ntemplate <class T, size_t SZ>\nvoid re(array<T, SZ> &a);\ntemplate <class T>\nvoid re(T &x) {\n  cin >> x;\n}\nvoid re(double &x) {\n  string t;\n  re(t);\n  x = stod(t);\n}\ntemplate <class Arg, class... Args>\nvoid re(Arg &first, Args &...rest) {\n  re(first);\n  re(rest...);\n}\ntemplate <class T1, class T2>\nvoid re(pair<T1, T2> &p) {\n  re(p.first, p.second);\n}\ntemplate <class T>\nvoid re(vector<T> &a) {\n  for (auto &x : a) re(x);\n}\ntemplate <class T, size_t SZ>\nvoid re(array<T, SZ> &a) {\n  for (auto &x : a) re(x);\n}\n}  // namespace __input\nusing namespace __input;\nnamespace __output {\ntemplate <typename T>\nstruct is_outputtable {\n  template <typename C>\n  static constexpr decltype(declval<ostream &>() << declval<const C &>(),\n                            bool())\n  test(int) {\n    return true;\n  }\n  template <typename C>\n  static constexpr bool test(...) {\n    return false;\n  }\n  static constexpr bool value = test<T>(int());\n};\ntemplate <\n    class T, typename V = decltype(declval<const T &>().begin()),\n    typename S = typename enable_if<!is_outputtable<T>::value, bool>::type>\nvoid pr(const T &x);\ntemplate <class T,\n          typename V = decltype(declval<ostream &>() << declval<const T &>())>\nvoid pr(const T &x) {\n  cout << x;\n}\ntemplate <class T1, class T2>\nvoid pr(const pair<T1, T2> &x);\ntemplate <class Arg, class... Args>\nvoid pr(const Arg &first, const Args &...rest) {\n  pr(first);\n  pr(rest...);\n}\ntemplate <class T, bool pretty = true>\nvoid prContain(const T &x) {\n  if (pretty) pr(\"{\");\n  bool fst = 1;\n  for (const auto &a : x) pr(!fst ? pretty ? \", \" : \" \" : \"\", a), fst = 0;\n  if (pretty) pr(\"}\");\n}\ntemplate <class T>\nvoid pc(const T &x) {\n  prContain<T, false>(x);\n  pr(\"\\n\");\n}\ntemplate <class T1, class T2>\nvoid pr(const pair<T1, T2> &x) {\n  pr(\"{\", x.first, \", \", x.second, \"}\");\n}\ntemplate <class T, typename V, typename S>\nvoid pr(const T &x) {\n  prContain(x);\n}\nvoid ps() { pr(\"\\n\"); }\ntemplate <class Arg>\nvoid ps(const Arg &first) {\n  pr(first);\n  ps();\n}\ntemplate <class Arg, class... Args>\nvoid ps(const Arg &first, const Args &...rest) {\n  pr(first, \" \");\n  ps(rest...);\n}\n}  // namespace __output\nusing namespace __output;\nnamespace __algorithm {\ntemplate <typename T>\nvoid dedup(vector<T> &v) {\n  sort((v).begin(), (v).end());\n  v.erase(unique((v).begin(), (v).end()), v.end());\n}\ntemplate <typename T>\ntypename vector<T>::const_iterator find(const vector<T> &v, const T &x) {\n  auto it = lower_bound((v).begin(), (v).end(), x);\n  return it != v.end() && *it == x ? it : v.end();\n}\ntemplate <typename T>\nsize_t index(const vector<T> &v, const T &x) {\n  auto it = find(v, x);\n  assert(it != v.end() && *it == x);\n  return it - v.begin();\n}\ntemplate <typename I>\nstruct _reversed_struct {\n  I &v_;\n  explicit _reversed_struct(I &v) : v_{v} {}\n  typename I::reverse_iterator begin() const { return v_.rbegin(); }\n  typename I::reverse_iterator end() const { return v_.rend(); }\n};\ntemplate <typename I>\n_reversed_struct<I> reversed(I &v) {\n  return _reversed_struct<I>(v);\n}\ntemplate <typename I>\nstruct _range_struct {\n  const I first_, last_;\n  explicit _range_struct(const I first, const I last)\n      : first_{first}, last_{last} {}\n  I begin() const { return first_; }\n  I end() const { return last_; }\n};\ntemplate <typename I>\n_range_struct<I> range(const I first, const I last) {\n  return _range_struct<I>(first, last);\n}\n}  // namespace __algorithm\nusing namespace __algorithm;\nnamespace __io {\nvoid setIO() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << setprecision(15);\n}\n}  // namespace __io\nusing namespace __io;\nstruct union_find_bipartite {\n  struct node {\n    int parent, rank, size, status;\n    bool parent_edge_parity;\n    bool is_bipartite;\n    int ct_nodes_on_root_side;\n    node() {}\n    node(int id)\n        : parent(id),\n          rank(0),\n          size(1),\n          status(-1),\n          parent_edge_parity(0),\n          is_bipartite(true),\n          ct_nodes_on_root_side(1) {}\n    int count_bipartitions() const {\n      return !is_bipartite ? 0 : status == -1 ? 2 : 1;\n    }\n    int min_nodes_on_side_1() const {\n      switch (status) {\n        case 1:\n          return ct_nodes_on_root_side;\n        case 0:\n          return size - ct_nodes_on_root_side;\n        case -1:\n          return std::min(ct_nodes_on_root_side, size - ct_nodes_on_root_side);\n        default:\n          assert(false);\n      }\n    }\n  };\n  int ct_components, ct_bipartite_components, degrees_of_freedom,\n      min_nodes_on_side_1;\n  mutable std::vector<node> data;\n  union_find_bipartite(int N = 0)\n      : ct_components(N),\n        ct_bipartite_components(N),\n        degrees_of_freedom(N),\n        min_nodes_on_side_1(0),\n        data(N) {\n    iota(data.begin(), data.end(), 0);\n  }\n\n private:\n  void subtract_component(int u) {\n    ct_components--;\n    if (data[u].is_bipartite) {\n      ct_bipartite_components--;\n      degrees_of_freedom -= data[u].status == -1;\n      min_nodes_on_side_1 -= data[u].min_nodes_on_side_1();\n    }\n  }\n  void add_component(int u) {\n    ct_components++;\n    if (data[u].is_bipartite) {\n      ct_bipartite_components++;\n      degrees_of_freedom += data[u].status == -1;\n      min_nodes_on_side_1 += data[u].min_nodes_on_side_1();\n    }\n  }\n\n public:\n  int find(int u) const {\n    if (u == data[u].parent) return u;\n    find(data[u].parent);\n    data[u].parent_edge_parity ^= data[data[u].parent].parent_edge_parity;\n    return data[u].parent = data[data[u].parent].parent;\n  }\n  bool can_constrain_node_to_side(int u, bool side) const {\n    find(u);\n    side ^= data[u].parent_edge_parity;\n    u = data[u].parent;\n    return data[u].is_bipartite &&\n           (data[u].status == -1 || data[u].status == side);\n  }\n  bool constrain_node_to_side(int u, bool side) {\n    find(u);\n    side ^= data[u].parent_edge_parity;\n    u = data[u].parent;\n    subtract_component(u);\n    if (data[u].status == -1) {\n      data[u].status = side;\n    } else {\n      data[u].is_bipartite &= data[u].status == side;\n    }\n    add_component(u);\n    return data[u].is_bipartite;\n  }\n  bool can_add_constraint_on_nodes(int u, int v, bool edge_parity) const {\n    find(u);\n    edge_parity ^= data[u].parent_edge_parity;\n    u = data[u].parent;\n    find(v);\n    edge_parity ^= data[v].parent_edge_parity;\n    v = data[v].parent;\n    return data[u].is_bipartite && data[v].is_bipartite &&\n           (data[u].status == -1 || data[v].status == -1 ||\n            (data[u].status ^ data[v].status) == edge_parity);\n  }\n  struct result {\n    bool added_connectivity;\n    bool component_is_bipartite;\n  };\n  result unite(int u, int v, bool edge_parity) {\n    find(u);\n    edge_parity ^= data[u].parent_edge_parity;\n    u = data[u].parent;\n    find(v);\n    edge_parity ^= data[v].parent_edge_parity;\n    v = data[v].parent;\n    if (u == v) {\n      subtract_component(u);\n      if (edge_parity) data[u].is_bipartite = false;\n      add_component(u);\n      return {false, data[u].is_bipartite};\n    }\n    if (data[u].rank < data[v].rank) std::swap(u, v);\n    subtract_component(u);\n    subtract_component(v);\n    data[v].parent = u;\n    data[v].parent_edge_parity = edge_parity;\n    if (data[u].rank == data[v].rank) data[u].rank++;\n    data[u].size += data[v].size;\n    data[u].is_bipartite &= data[v].is_bipartite;\n    if (edge_parity)\n      data[u].ct_nodes_on_root_side +=\n          data[v].size - data[v].ct_nodes_on_root_side;\n    else\n      data[u].ct_nodes_on_root_side += data[v].ct_nodes_on_root_side;\n    if (data[v].status != -1) {\n      bool implied_u_status = data[v].status ^ edge_parity;\n      if (data[u].status == -1)\n        data[u].status = implied_u_status;\n      else\n        data[u].is_bipartite &= data[u].status == implied_u_status;\n    }\n    add_component(u);\n    return {true, data[u].is_bipartite};\n  }\n  bool can_constrain_to_be_same(int u, int v) const {\n    return can_add_constraint_on_nodes(u, v, 0);\n  }\n  bool can_constrain_to_be_different(int u, int v) const {\n    return can_add_constraint_on_nodes(u, v, 1);\n  }\n  result constrain_to_be_same(int u, int v) { return unite(u, v, 0); }\n  result constrain_to_be_different(int u, int v) { return unite(u, v, 1); }\n};\nconst string NO = \"NO\", YES = \"YES\";\nint main() {\n  setIO();\n  int n, m;\n  re(n, m);\n  const int S = n * m;\n  auto ind = [&](int i, int j) { return i * m + j; };\n  auto row = [&](int i) { return i / m; };\n  auto col = [&](int i) { return i % m; };\n  vb marked(S);\n  for (int i = 0; i < n; i++) {\n    string line;\n    re(line);\n    for (int j = 0; j < m; j++) marked[ind(i, j)] = line[j] == 'X';\n  }\n  auto get_adj = [&](int i) {\n    vi res;\n    for (int j : {i + 1, i - 1, i + m, i - m}) {\n      if (marked[j]) continue;\n      res.push_back(j);\n    }\n    return res;\n  };\n  vi special;\n  union_find_bipartite uf(S);\n  for (int i = 0; i < S; i++) {\n    if (!marked[i]) continue;\n    auto adj = get_adj(i);\n    if (int((adj).size()) == 0) continue;\n    if (int((adj).size()) == 1 || int((adj).size()) == 3) {\n      ps(NO);\n      return 0;\n    }\n    if (int((adj).size()) == 4) {\n      special.push_back(i);\n      continue;\n    }\n    uf.unite(adj.front(), adj.back(), 1);\n  }\n  if (uf.ct_bipartite_components != uf.ct_components) {\n    ps(NO);\n    return 0;\n  }\n  for (int cur : special) {\n    auto adj = get_adj(cur);\n    uf.constrain_to_be_same(adj[0], adj[1]);\n    uf.constrain_to_be_same(adj[2], adj[3]);\n    uf.constrain_to_be_different(adj[1], adj[2]);\n  }\n  if (uf.ct_bipartite_components != uf.ct_components) {\n    ps(NO);\n    return 0;\n  }\n  ps(YES);\n  for (int i = 0; i < S; i++) {\n    if (marked[i]) continue;\n    if (uf.can_constrain_node_to_side(i, 0)) uf.constrain_node_to_side(i, 0);\n  }\n  vvi ans(n, vi(m));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      int u = ind(i, j);\n      if (marked[u]) continue;\n      ans[i][j] = uf.can_constrain_node_to_side(u, 0) ? 1 : 4;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      int u = ind(i, j);\n      if (!marked[u]) continue;\n      for (int v : get_adj(u)) ans[i][j] += ans[row(v)][col(v)];\n      assert(ans[i][j] % 5 == 0);\n    }\n  }\n  for (auto &i : ans) pc(i);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nll const inf = 1e18;\nifstream fin(\"input.txt\");\nofstream fout(\"output.txt\");\nsigned main() {\n  int n, m;\n  cin >> n >> m;\n  vector<vector<int>> a(n, vector<int>(m, 3));\n  vector<vector<int>> b(n, vector<int>(m, 3));\n  vector<vector<int>> l(n, vector<int>(m, 0));\n  vector<vector<int>> r(n, vector<int>(m, 0));\n  bool may = true;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j) {\n      char c;\n      cin >> c;\n      if (c == '.') a[i][j] = 0;\n    }\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j) {\n      if (a[i][j] == 3) {\n        int x = a[i - 1][j] / 2 + a[i + 1][j] / 2 + a[i][j - 1] / 2 +\n                a[i][j + 1] / 2;\n        if (x % 2 == 1) may = false;\n      }\n    }\n  if (!may) {\n    cout << \"NO\\n\";\n    return 0;\n  }\n  cout << \"YES\\n\";\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j) {\n      if (i == 0 || j == 0 || j == m - 1) {\n        l[i][j] = 0;\n        r[i][j] = 0;\n        a[i][j] = 1;\n      } else {\n        l[i][j] = l[i - 1][j];\n        r[i][j] = r[i - 1][j];\n        if (a[i - 1][j] == 3) {\n          if (a[i - 1][j - 1] == 3) l[i][j]++;\n          if (a[i - 1][j + 1] == 3) r[i][j]++;\n        }\n        if (a[i][j] == 0) a[i][j] = min(l[i][j], r[i][j]) % 2 + 1;\n      }\n    }\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j) {\n      if (a[i][j] != 3)\n        if ((i + a[i][j]) % 2 == 0)\n          b[i][j] = 1;\n        else\n          b[i][j] = 4;\n    }\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j) {\n      if (a[i][j] == 3) {\n        b[i][j] = 0;\n        if (a[i - 1][j] != 3) b[i][j] += b[i - 1][j];\n        if (a[i + 1][j] != 3) b[i][j] += b[i + 1][j];\n        if (a[i][j - 1] != 3) b[i][j] += b[i][j - 1];\n        if (a[i][j + 1] != 3) b[i][j] += b[i][j + 1];\n      }\n    }\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      cout << b[i][j] << ' ';\n    }\n    cout << '\\n';\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class A>\nvoid rd(vector<A>& v);\ntemplate <class T>\nvoid rd(T& x) {\n  cin >> x;\n}\ntemplate <class H, class... T>\nvoid rd(H& h, T&... t) {\n  rd(h);\n  rd(t...);\n}\ntemplate <class A>\nvoid rd(vector<A>& x) {\n  for (auto& a : x) rd(a);\n}\ntemplate <class T>\nbool ckmin(T& a, const T b) {\n  return b < a ? a = b, 1 : 0;\n}\ntemplate <class T>\nbool ckmax(T& a, const T b) {\n  return a < b ? a = b, 1 : 0;\n}\ntemplate <typename T>\nvoid __p(T a) {\n  cout << a;\n}\ntemplate <typename T, typename F>\nvoid __p(pair<T, F> a) {\n  cout << \"{\";\n  __p(a.first);\n  cout << \",\";\n  __p(a.second);\n  cout << \"}\\n\";\n}\ntemplate <typename T>\nvoid __p(std::vector<T> a) {\n  cout << \"{\";\n  for (auto it = a.begin(); it < a.end(); it++)\n    __p(*it), cout << \",}\\n\"[it + 1 == a.end()];\n}\ntemplate <typename T, typename... Arg>\nvoid __p(T a1, Arg... a) {\n  __p(a1);\n  __p(a...);\n}\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1) {\n  cout << name << \" : \";\n  __p(arg1);\n  cout << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args) {\n  int64_t bracket = 0, i = 0;\n  for (;; i++)\n    if (names[i] == ',' && bracket == 0)\n      break;\n    else if (names[i] == '(')\n      bracket++;\n    else if (names[i] == ')')\n      bracket--;\n  const char* comma = names + i;\n  cout.write(names, comma - names) << \" : \";\n  __p(arg1);\n  cout << \" | \";\n  __f(comma + 1, args...);\n}\nvoid setIO(string s = \"\") {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin.exceptions(cin.failbit);\n  cout.precision(15);\n  cout << fixed;\n  if (((int64_t)(s).size())) {\n    freopen((s + \".in\").c_str(), \"r\", stdin);\n    freopen((s + \".out\").c_str(), \"w\", stdout);\n  }\n}\nconst int64_t dx[] = {1, -1, 0, 0};\nconst int64_t dy[] = {0, 0, 1, -1};\nconst int64_t N = 500;\nvector<int64_t> g[N * N], color(N*N, -1);\n;\nvector<bool> vis(N* N, false);\nvoid end() {\n  cout << \"NO\";\n  exit(0);\n}\nint64_t id(pair<int64_t, int64_t> p) { return N * p.first + p.second; };\nint64_t id(int64_t i, int64_t j) { return N * i + j; };\nsigned main() {\n  setIO();\n  int64_t n, m;\n  rd(n, m);\n  vector<string> a(n);\n  rd(a);\n  for (int64_t i = 0; i < n; ++i) {\n    for (int64_t j = 0; j < m; ++j) {\n      if (a[i][j] == 'X') {\n        vector<pair<int64_t, int64_t>> tmp;\n        for (int64_t k = 0; k < 4; ++k) {\n          int64_t ni = i + dx[k], nj = j + dy[k];\n          if (a[ni][nj] == '.') {\n            tmp.emplace_back(ni, nj);\n          }\n        }\n        if (((int64_t)(tmp).size()) & 1) end();\n        if (((int64_t)(tmp).size()) == 2) {\n          g[id(tmp[0])].push_back(id(tmp[1]));\n          g[id(tmp[1])].push_back(id(tmp[0]));\n        } else if (((int64_t)(tmp).size()) == 4) {\n          g[id(tmp[0])].push_back(id(tmp[2]));\n          g[id(tmp[0])].push_back(id(tmp[3]));\n          g[id(tmp[2])].push_back(id(tmp[0]));\n          g[id(tmp[3])].push_back(id(tmp[0]));\n          g[id(tmp[1])].push_back(id(tmp[2]));\n          g[id(tmp[1])].push_back(id(tmp[3]));\n          g[id(tmp[2])].push_back(id(tmp[1]));\n          g[id(tmp[3])].push_back(id(tmp[1]));\n        }\n      }\n    }\n  }\n  function<void(int64_t)> dfs = [&](int64_t i) -> void {\n    for (auto j : g[i]) {\n      if (!vis[j]) {\n        vis[j] = true;\n        color[j] = 1 ^ color[i];\n        dfs(j);\n      } else {\n        if (!(color[i] ^ color[j])) assert(false);\n      }\n    }\n  };\n  for (int64_t i = 0; i < n; ++i) {\n    for (int64_t j = 0; j < m; ++j) {\n      if (a[i][j] == '.' && !vis[id(i, j)]) {\n        color[id(i, j)] = 0;\n        vis[id(i, j)] = true;\n        dfs(id(i, j));\n      }\n    }\n  }\n  int64_t ans[n][m];\n  memset(ans, 0, sizeof(ans));\n  for (int64_t i = 0; i < n; ++i) {\n    for (int64_t j = 0; j < m; ++j) {\n      if (a[i][j] == '.') {\n        ans[i][j] = color[id(i, j)] ? 1 : 4;\n      }\n    }\n  }\n  cout << \"YES\"\n       << \"\\n\";\n  for (int64_t i = 0; i < n; ++i) {\n    for (int64_t j = 0; j < m; ++j) {\n      if (a[i][j] == 'X') {\n        for (int64_t k = 0; k < 4; ++k) {\n          int64_t ni = i + dx[k], nj = j + dy[k];\n          if (a[ni][nj] == '.') {\n            ans[i][j] += ans[ni][nj];\n          }\n        }\n      }\n      cout << ans[i][j] << \" \";\n    }\n    cout << \"\\n\";\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vvb = vector<vb>;\nusing vd = vector<double>;\nusing vs = vector<string>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing vpdd = vector<pdd>;\ntemplate <typename T>\nvoid ckmin(T &a, const T &b) {\n  a = min(a, b);\n}\ntemplate <typename T>\nvoid ckmax(T &a, const T &b) {\n  a = max(a, b);\n}\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nnamespace __input {\ntemplate <class T1, class T2>\nvoid re(pair<T1, T2> &p);\ntemplate <class T>\nvoid re(vector<T> &a);\ntemplate <class T, size_t SZ>\nvoid re(array<T, SZ> &a);\ntemplate <class T>\nvoid re(T &x) {\n  cin >> x;\n}\nvoid re(double &x) {\n  string t;\n  re(t);\n  x = stod(t);\n}\ntemplate <class Arg, class... Args>\nvoid re(Arg &first, Args &...rest) {\n  re(first);\n  re(rest...);\n}\ntemplate <class T1, class T2>\nvoid re(pair<T1, T2> &p) {\n  re(p.first, p.second);\n}\ntemplate <class T>\nvoid re(vector<T> &a) {\n  for (auto &x : a) re(x);\n}\ntemplate <class T, size_t SZ>\nvoid re(array<T, SZ> &a) {\n  for (auto &x : a) re(x);\n}\n}  // namespace __input\nusing namespace __input;\nnamespace __output {\ntemplate <typename T>\nstruct is_outputtable {\n  template <typename C>\n  static constexpr decltype(declval<ostream &>() << declval<const C &>(),\n                            bool())\n  test(int) {\n    return true;\n  }\n  template <typename C>\n  static constexpr bool test(...) {\n    return false;\n  }\n  static constexpr bool value = test<T>(int());\n};\ntemplate <\n    class T, typename V = decltype(declval<const T &>().begin()),\n    typename S = typename enable_if<!is_outputtable<T>::value, bool>::type>\nvoid pr(const T &x);\ntemplate <class T,\n          typename V = decltype(declval<ostream &>() << declval<const T &>())>\nvoid pr(const T &x) {\n  cout << x;\n}\ntemplate <class T1, class T2>\nvoid pr(const pair<T1, T2> &x);\ntemplate <class Arg, class... Args>\nvoid pr(const Arg &first, const Args &...rest) {\n  pr(first);\n  pr(rest...);\n}\ntemplate <class T, bool pretty = true>\nvoid prContain(const T &x) {\n  if (pretty) pr(\"{\");\n  bool fst = 1;\n  for (const auto &a : x) pr(!fst ? pretty ? \", \" : \" \" : \"\", a), fst = 0;\n  if (pretty) pr(\"}\");\n}\ntemplate <class T>\nvoid pc(const T &x) {\n  prContain<T, false>(x);\n  pr(\"\\n\");\n}\ntemplate <class T1, class T2>\nvoid pr(const pair<T1, T2> &x) {\n  pr(\"{\", x.first, \", \", x.second, \"}\");\n}\ntemplate <class T, typename V, typename S>\nvoid pr(const T &x) {\n  prContain(x);\n}\nvoid ps() { pr(\"\\n\"); }\ntemplate <class Arg>\nvoid ps(const Arg &first) {\n  pr(first);\n  ps();\n}\ntemplate <class Arg, class... Args>\nvoid ps(const Arg &first, const Args &...rest) {\n  pr(first, \" \");\n  ps(rest...);\n}\n}  // namespace __output\nusing namespace __output;\nnamespace __algorithm {\ntemplate <typename T>\nvoid dedup(vector<T> &v) {\n  sort((v).begin(), (v).end());\n  v.erase(unique((v).begin(), (v).end()), v.end());\n}\ntemplate <typename T>\ntypename vector<T>::const_iterator find(const vector<T> &v, const T &x) {\n  auto it = lower_bound((v).begin(), (v).end(), x);\n  return it != v.end() && *it == x ? it : v.end();\n}\ntemplate <typename T>\nsize_t index(const vector<T> &v, const T &x) {\n  auto it = find(v, x);\n  assert(it != v.end() && *it == x);\n  return it - v.begin();\n}\ntemplate <typename I>\nstruct _reversed_struct {\n  I &v_;\n  explicit _reversed_struct(I &v) : v_{v} {}\n  typename I::reverse_iterator begin() const { return v_.rbegin(); }\n  typename I::reverse_iterator end() const { return v_.rend(); }\n};\ntemplate <typename I>\n_reversed_struct<I> reversed(I &v) {\n  return _reversed_struct<I>(v);\n}\ntemplate <typename I>\nstruct _range_struct {\n  const I first_, last_;\n  explicit _range_struct(const I first, const I last)\n      : first_{first}, last_{last} {}\n  I begin() const { return first_; }\n  I end() const { return last_; }\n};\ntemplate <typename I>\n_range_struct<I> range(const I first, const I last) {\n  return _range_struct<I>(first, last);\n}\n}  // namespace __algorithm\nusing namespace __algorithm;\nnamespace __io {\nvoid setIO() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << setprecision(15);\n}\n}  // namespace __io\nusing namespace __io;\nstruct union_find_bipartite {\n  struct node {\n    int parent, rank, size, status;\n    bool parent_edge_parity;\n    bool is_bipartite;\n    int ct_nodes_on_root_side;\n    node() {}\n    node(int id)\n        : parent(id),\n          rank(0),\n          size(1),\n          status(-1),\n          parent_edge_parity(0),\n          is_bipartite(true),\n          ct_nodes_on_root_side(1) {}\n    int count_bipartitions() const {\n      return !is_bipartite ? 0 : status == -1 ? 2 : 1;\n    }\n    int min_nodes_on_side_1() const {\n      switch (status) {\n        case 1:\n          return ct_nodes_on_root_side;\n        case 0:\n          return size - ct_nodes_on_root_side;\n        case -1:\n          return std::min(ct_nodes_on_root_side, size - ct_nodes_on_root_side);\n        default:\n          assert(false);\n      }\n    }\n  };\n  int ct_components, ct_bipartite_components, degrees_of_freedom,\n      min_nodes_on_side_1;\n  mutable std::vector<node> data;\n  union_find_bipartite(int N = 0)\n      : ct_components(N),\n        ct_bipartite_components(N),\n        degrees_of_freedom(N),\n        min_nodes_on_side_1(0),\n        data(N) {\n    iota(data.begin(), data.end(), 0);\n  }\n\n private:\n  void subtract_component(int u) {\n    ct_components--;\n    if (data[u].is_bipartite) {\n      ct_bipartite_components--;\n      degrees_of_freedom -= data[u].status == -1;\n      min_nodes_on_side_1 -= data[u].min_nodes_on_side_1();\n    }\n  }\n  void add_component(int u) {\n    ct_components++;\n    if (data[u].is_bipartite) {\n      ct_bipartite_components++;\n      degrees_of_freedom += data[u].status == -1;\n      min_nodes_on_side_1 += data[u].min_nodes_on_side_1();\n    }\n  }\n\n public:\n  int find(int u) const {\n    if (u == data[u].parent) return u;\n    find(data[u].parent);\n    data[u].parent_edge_parity ^= data[data[u].parent].parent_edge_parity;\n    return data[u].parent = data[data[u].parent].parent;\n  }\n  bool can_constrain_node_to_side(int u, bool side) const {\n    find(u);\n    side ^= data[u].parent_edge_parity;\n    u = data[u].parent;\n    return data[u].is_bipartite &&\n           (data[u].status == -1 || data[u].status == side);\n  }\n  bool constrain_node_to_side(int u, bool side) {\n    find(u);\n    side ^= data[u].parent_edge_parity;\n    u = data[u].parent;\n    subtract_component(u);\n    if (data[u].status == -1) {\n      data[u].status = side;\n    } else {\n      data[u].is_bipartite &= data[u].status == side;\n    }\n    add_component(u);\n    return data[u].is_bipartite;\n  }\n  bool can_add_constraint_on_nodes(int u, int v, bool edge_parity) const {\n    find(u);\n    edge_parity ^= data[u].parent_edge_parity;\n    u = data[u].parent;\n    find(v);\n    edge_parity ^= data[v].parent_edge_parity;\n    v = data[v].parent;\n    return data[u].is_bipartite && data[v].is_bipartite &&\n           (data[u].status == -1 || data[v].status == -1 ||\n            (data[u].status ^ data[v].status) == edge_parity);\n  }\n  struct result {\n    bool added_connectivity;\n    bool component_is_bipartite;\n  };\n  result unite(int u, int v, bool edge_parity) {\n    find(u);\n    edge_parity ^= data[u].parent_edge_parity;\n    u = data[u].parent;\n    find(v);\n    edge_parity ^= data[v].parent_edge_parity;\n    v = data[v].parent;\n    if (u == v) {\n      subtract_component(u);\n      if (edge_parity) data[u].is_bipartite = false;\n      add_component(u);\n      return {false, data[u].is_bipartite};\n    }\n    if (data[u].rank < data[v].rank) std::swap(u, v);\n    subtract_component(u);\n    subtract_component(v);\n    data[v].parent = u;\n    data[v].parent_edge_parity = edge_parity;\n    if (data[u].rank == data[v].rank) data[u].rank++;\n    data[u].size += data[v].size;\n    data[u].is_bipartite &= data[v].is_bipartite;\n    if (edge_parity)\n      data[u].ct_nodes_on_root_side +=\n          data[v].size - data[v].ct_nodes_on_root_side;\n    else\n      data[u].ct_nodes_on_root_side += data[v].ct_nodes_on_root_side;\n    if (data[v].status != -1) {\n      bool implied_u_status = data[v].status ^ edge_parity;\n      if (data[u].status == -1)\n        data[u].status = implied_u_status;\n      else\n        data[u].is_bipartite &= data[u].status == implied_u_status;\n    }\n    add_component(u);\n    return {true, data[u].is_bipartite};\n  }\n  bool can_constrain_to_be_same(int u, int v) const {\n    return can_add_constraint_on_nodes(u, v, 0);\n  }\n  bool can_constrain_to_be_different(int u, int v) const {\n    return can_add_constraint_on_nodes(u, v, 1);\n  }\n  result constrain_to_be_same(int u, int v) { return unite(u, v, 0); }\n  result constrain_to_be_different(int u, int v) { return unite(u, v, 1); }\n};\nconst string NO = \"NO\", YES = \"YES\";\nint main() {\n  setIO();\n  int n, m;\n  re(n, m);\n  const int S = n * m;\n  auto ind = [&](int i, int j) { return i * m + j; };\n  auto row = [&](int i) { return i / m; };\n  auto col = [&](int i) { return i % m; };\n  vb marked(S);\n  for (int i = 0; i < n; i++) {\n    string line;\n    re(line);\n    for (int j = 0; j < m; j++) marked[ind(i, j)] = line[j] == 'X';\n  }\n  auto get_adj = [&](int i) {\n    vi res;\n    for (int j : {i + 1, i - 1, i + m, i - m}) {\n      if (marked[j]) continue;\n      res.push_back(j);\n    }\n    return res;\n  };\n  vi special;\n  union_find_bipartite uf(S);\n  for (int i = 0; i < S; i++) {\n    if (!marked[i]) continue;\n    auto adj = get_adj(i);\n    if (int((adj).size()) == 0) continue;\n    if (int((adj).size()) == 1 || int((adj).size()) == 3) {\n      ps(NO);\n      return 0;\n    }\n    if (int((adj).size()) == 4) {\n      special.push_back(i);\n      continue;\n    }\n    uf.unite(adj.front(), adj.back(), 1);\n  }\n  if (uf.ct_bipartite_components != uf.ct_components) {\n    ps(NO);\n    return 0;\n  }\n  for (int cur : special) {\n    auto adj = get_adj(cur);\n    for (int i = 0; i < 4; i++) {\n      for (int j = i + 1; j < 4; j++) {\n        int x;\n        for (int z = 0; z < 4; z++) {\n          if (z != i && z != j) {\n            x = z;\n            break;\n          }\n        }\n        int y = -1;\n        for (int z = 0; z < 4; z++) {\n          if (z != i && z != j && z != x) {\n            y = z;\n            break;\n          }\n        }\n        int u = adj[i], v = adj[j];\n        int a = adj[x], b = adj[y];\n        if (!uf.can_constrain_to_be_different(u, v) ||\n            !uf.can_constrain_to_be_different(a, b)) {\n          uf.constrain_to_be_same(u, v);\n          uf.constrain_to_be_same(a, b);\n          uf.constrain_to_be_different(u, a);\n          goto out;\n        }\n      }\n    }\n    uf.constrain_to_be_same(adj[0], adj[1]);\n    uf.constrain_to_be_same(adj[2], adj[3]);\n    uf.constrain_to_be_different(adj[1], adj[2]);\n  out:;\n  }\n  if (uf.ct_bipartite_components != uf.ct_components) {\n    ps(NO);\n    return 0;\n  }\n  ps(YES);\n  for (int i = 0; i < S; i++) {\n    if (marked[i]) continue;\n    if (uf.can_constrain_node_to_side(i, 0)) uf.constrain_node_to_side(i, 0);\n  }\n  vvi ans(n, vi(m));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      int u = ind(i, j);\n      if (marked[u]) continue;\n      ans[i][j] = uf.can_constrain_node_to_side(u, 0) ? 1 : 4;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      int u = ind(i, j);\n      if (!marked[u]) continue;\n      for (int v : get_adj(u)) ans[i][j] += ans[row(v)][col(v)];\n      assert(ans[i][j] % 5 == 0);\n    }\n  }\n  for (auto &i : ans) pc(i);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nstd::vector<int> a[500005];\nint n, m, col[500005], ans[505][505], f[505][505];\nint read() {\n  char ch = getchar();\n  if (ch == '.' || ch == 'X') return ch == 'X';\n  return read();\n}\nint t(int x, int y) { return (x - 1) * m + y; }\nstd::pair<int, int> it(int id) {\n  return std::make_pair((id - 1) / m + 1, (id - 1) % m + 1);\n}\nvoid add(int x, int y) {\n  a[x].push_back(y);\n  a[y].push_back(x);\n}\nvoid dfs(int v) {\n  for (int i = 0; i < (int)a[v].size(); i++) {\n    int u = a[v][i];\n    if (col[u] != -1) continue;\n    col[u] = 1 - col[v];\n    dfs(u);\n  }\n}\nint getans(int x, int y) {\n  int s = 0;\n  if (!f[x + 1][y]) s = s + ans[x + 1][y];\n  if (!f[x - 1][y]) s = s + ans[x - 1][y];\n  if (!f[x][y + 1]) s = s + ans[x][y + 1];\n  if (!f[x][y - 1]) s = s + ans[x][y - 1];\n  return s;\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) f[i][j] = read();\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) {\n      if (!f[i][j]) {\n        col[t(i, j)] = -1;\n        continue;\n      }\n      int cnt = 0;\n      if (!f[i + 1][j]) ++cnt;\n      if (!f[i - 1][j]) ++cnt;\n      if (!f[i][j + 1]) ++cnt;\n      if (!f[i][j - 1]) ++cnt;\n      if (cnt == 1 || cnt == 3) return puts(\"NO\"), 0;\n      if (!cnt) continue;\n      if (cnt == 2) {\n        int p1 = 0, p2 = 0;\n        if (!f[i + 1][j]) !p1 ? p1 = t(i + 1, j) : p2 = t(i + 1, j);\n        if (!f[i][j + 1]) !p1 ? p1 = t(i, j + 1) : p2 = t(i, j + 1);\n        if (!f[i - 1][j]) !p1 ? p1 = t(i - 1, j) : p2 = t(i - 1, j);\n        if (!f[i][j - 1]) !p1 ? p1 = t(i, j - 1) : p2 = t(i, j - 1);\n        add(p1, p2);\n      } else if (cnt == 4) {\n        add(t(i + 1, j), t(i, j + 1));\n        add(t(i + 1, j), t(i, j - 1));\n        add(t(i - 1, j), t(i, j + 1));\n        add(t(i - 1, j), t(i, j - 1));\n      }\n    }\n  for (int i = 1; i <= n * m; i++)\n    if (col[i] == -1) col[i] = 0, dfs(i);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      if (!f[i][j]) ans[i][j] = (col[t(i, j)] ? 1 : 4);\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      if (f[i][j]) ans[i][j] = getans(i, j);\n  puts(\"YES\");\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= m; j++) printf(\"%d \", ans[i][j]);\n    puts(\"\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\nlong long dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\nlong long n, m, ans[510][510];\nchar grid[510][510];\nvector<long long> vt[510 * 510];\nvoid dfs(long long x, long long v) {\n  ans[x / m][x % m] = v;\n  long long i;\n  for (i = 0; i < vt[x].size(); i++) {\n    if (ans[vt[x][i] / m][vt[x][i] % m] == -1) {\n      dfs(vt[x][i], 5 - v);\n    }\n  }\n  return;\n}\nint main() {\n  long long i, j, k, x, y;\n  scanf(\"%lld%lld\", &n, &m);\n  for (i = 0; i < n; i++) {\n    scanf(\"%s\", &grid[i]);\n  }\n  memset(ans, -1, sizeof(ans));\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < m; j++) {\n      if (grid[i][j] == '.') {\n        continue;\n      }\n      vector<long long> adj;\n      for (k = 0; k < 4; k++) {\n        x = i + dx[k];\n        y = j + dy[k];\n        if (grid[x][y] == '.') {\n          adj.push_back(x * m + y);\n        }\n      }\n      if (adj.size() == 0) {\n        ans[i][j] = 0;\n      } else if (adj.size() == 2) {\n        vt[adj[0]].push_back(adj[1]);\n        vt[adj[1]].push_back(adj[0]);\n      } else if (adj.size() == 4) {\n        vt[adj[0]].push_back(adj[1]);\n        vt[adj[1]].push_back(adj[0]);\n        vt[adj[2]].push_back(adj[3]);\n        vt[adj[3]].push_back(adj[2]);\n      } else {\n        puts(\"NO\");\n        return 0;\n      }\n    }\n  }\n  puts(\"YES\");\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < m; j++) {\n      if (ans[i][j] == -1 && grid[i][j] == '.') {\n        dfs(i * m + j, 1);\n      }\n    }\n  }\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < m; j++) {\n      if (ans[i][j] == -1) {\n        ans[i][j] = 0;\n      }\n    }\n  }\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < m; j++) {\n      if (grid[i][j] == 'X') {\n        for (k = 0; k < 4; k++) {\n          x = i + dx[k];\n          y = j + dy[k];\n          if (grid[x][y] == '.') {\n            ans[i][j] += ans[x][y];\n          }\n        }\n      }\n      printf(\"%lld \", ans[i][j]);\n    }\n    puts(\"\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nusing namespace std;\nstruct Comparator {\n  bool operator()(const pair<long long, long long>& lhs,\n                  const pair<long long, long long>& rhs) const {\n    if (lhs.first == rhs.first) return lhs.second < rhs.second;\n    return lhs.first < rhs.first;\n  }\n  bool operator()(long long a, long long b) const { return a > b; }\n};\nlong long n, m;\nchar grid[505][505];\nlong long val[505][505];\nvector<vector<long long> > graph(300005);\nvector<long long> colors(300005, -1);\nvoid init() {\n  long long counter = 0;\n  for (long long i = 0; i < n; i++) {\n    for (long long j = 0; j < m; j++) {\n      val[i][j] = counter++;\n    }\n  }\n}\nvoid input() {\n  cin >> n >> m;\n  for (long long i = 0; i < n; i++) {\n    for (long long j = 0; j < m; j++) {\n      cin >> grid[i][j];\n    }\n  }\n}\nbool checkOdd() {\n  for (long long i = 0; i < n; i++) {\n    for (long long j = 0; j < m; j++) {\n      if (grid[i][j] == 'X') {\n        long long count = (grid[i - 1][j] == '.') + (grid[i + 1][j] == '.') +\n                          (grid[i][j + 1] == '.') + (grid[i][j - 1] == '.');\n        if (count % 2) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\nvoid initGraph() {\n  for (long long i = 1; i < n - 1; i++) {\n    for (long long j = 1; j < m - 1; j++) {\n      if (grid[i][j] == 'X') {\n        vector<pair<long long, long long> > dots;\n        if (grid[i - 1][j] == '.') dots.push_back({i - 1, j});\n        if (grid[i + 1][j] == '.') dots.push_back({i + 1, j});\n        if (grid[i][j + 1] == '.') dots.push_back({i, j + 1});\n        if (grid[i][j - 1] == '.') dots.push_back({i, j - 1});\n        if (dots.size() == 2) {\n          long long first = val[dots[0].first][dots[0].second];\n          long long second = val[dots[1].first][dots[1].second];\n          graph[first].push_back(second);\n          graph[second].push_back(first);\n        }\n        if (dots.size() == 4) {\n          long long first = val[dots[0].first][dots[0].second];\n          long long second = val[dots[1].first][dots[1].second];\n          long long third = val[dots[2].first][dots[2].second];\n          long long fourth = val[dots[3].first][dots[3].second];\n          graph[first].push_back(third);\n          graph[first].push_back(fourth);\n          graph[second].push_back(third);\n          graph[second].push_back(fourth);\n          graph[third].push_back(first);\n          graph[third].push_back(second);\n          graph[fourth].push_back(first);\n          graph[fourth].push_back(second);\n        }\n      }\n    }\n  }\n}\nbool checkBipartite(long long vertex, long long color = 0) {\n  if (colors[vertex] == color) return true;\n  if (colors[vertex] == -1) colors[vertex] = color;\n  if (colors[vertex] != color) return false;\n  for (long long i = 0; i < graph[vertex].size(); i++) {\n    long long next = graph[vertex][i];\n    if (colors[next] == colors[vertex]) return false;\n    checkBipartite(next, 1 - color);\n  }\n  return true;\n}\nvoid solve() {\n  input();\n  init();\n  if (!checkOdd()) {\n    cout << \"NO\\n\";\n    return;\n  }\n  initGraph();\n  for (long long i = 0; i < n; i++) {\n    for (long long j = 0; j < m; j++) {\n      if (colors[val[i][j]] == -1) {\n        if (!checkBipartite(val[i][j])) {\n          cout << \"NO\\n\";\n          return;\n        }\n      }\n    }\n  }\n  long long answ[n + 1][m + 1];\n  for (long long i = 0; i < n; i++) {\n    for (long long j = 0; j < m; j++) {\n      if (grid[i][j] != 'X') {\n        answ[i][j] = colors[val[i][j]] * 3 + 1;\n      }\n    }\n  }\n  for (long long i = 0; i < n; i++) {\n    for (long long j = 0; j < m; j++) {\n      if (grid[i][j] == 'X') {\n        answ[i][j] = 0;\n        if (grid[i + 1][j] != 'X') answ[i][j] += answ[i + 1][j];\n        if (grid[i - 1][j] != 'X') answ[i][j] += answ[i - 1][j];\n        if (grid[i][j + 1] != 'X') answ[i][j] += answ[i][j + 1];\n        if (grid[i][j - 1] != 'X') answ[i][j] += answ[i][j - 1];\n      }\n    }\n  }\n  cout << \"YES\\n\";\n  for (long long i = 0; i < n; i++) {\n    for (long long j = 0; j < m; j++) {\n      cout << answ[i][j] << ' ';\n    }\n    cout << '\\n';\n  }\n}\nsigned main() {\n  cin.tie(0);\n  cout.tie(0);\n  ios_base::sync_with_stdio(0);\n  ;\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.StringTokenizer;\n\npublic class F {\n\n\tpublic static void main(String[] args) {\n\t\tFastScanner fs=new FastScanner();\n\t\tint h=fs.nextInt(), w=fs.nextInt();\n\t\tchar[][] grid=new char[w][h];\n\t\tfor (int y=0; y<h; y++) {\n\t\t\tchar[] line=fs.next().toCharArray();\n\t\t\tfor (int x=0; x<w; x++) {\n\t\t\t\tgrid[x][y]=line[x];\n\t\t\t}\n\t\t}\n\t\tint[][] dist=new int[w][h];\n\t\tArrayDeque<Integer> xs=new ArrayDeque<>(), ys=new ArrayDeque<>();\n\t\tint[] dx= {1, -1, 0, 0};\n\t\tint[] dy= {0, 0, 1, -1};\n\t\tint[] d2x= {1, -1, 0, 0, 1, 1, -1, -1};\n\t\tint[] d2y= {0, 0, 1, -1, 1, -1, 1, -1};\n\t\tfor (int x=0; x<w; x++) {\n\t\t\tfor (int y=0; y<h; y++) {\n\t\t\t\tint count=0;\n\t\t\t\tfor (int d=0; d<4; d++) {\n\t\t\t\t\tint nx=x+dx[d];\n\t\t\t\t\tint ny=y+dy[d];\n\t\t\t\t\tif (nx>=0 && ny>=0 && nx<w && ny<h && grid[nx][ny]=='.' && grid[x][y]=='X') count++;\n\t\t\t\t}\n\t\t\t\tif (count%2==1) {\n\t\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"YES\");\n\t\t\n\t\tfor (int x=0; x<w; x++) Arrays.fill(dist[x], -1);\n\t\txs.add(0);\n\t\tys.add(0);\n\t\tdist[0][0]=0;\n\t\twhile (!xs.isEmpty()) {\n\t\t\tint sx=xs.removeFirst();\n\t\t\tint sy=ys.removeFirst();\n\t\t\tint sd=dist[sx][sy];\n\t\t\tfor (int d=0; d<8; d++) {\n\t\t\t\tint nx=sx+d2x[d], ny=sy+d2y[d];\n\t\t\t\tif (nx<0||ny<0||nx>=w || ny>=h) continue;\n\t\t\t\tint nd=grid[nx][ny]=='.'?sd:sd+1;\n\t\t\t\tif (d>=4 && grid[nx][ny]!='.') continue;\n\t\t\t\tif (dist[nx][ny]==-1 || dist[nx][ny]>nd) {\n\t\t\t\t\t//then add this to the queue\n\t\t\t\t\tdist[nx][ny]=nd;\n\t\t\t\t\tif (sd==nd) {\n\t\t\t\t\t\txs.addFirst(nx);\n\t\t\t\t\t\tys.addFirst(ny);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\txs.addLast(nx);\n\t\t\t\t\t\tys.addLast(ny);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[][] ans=new int[w][h];\n\t\tfor (int x=0; x<w; x++) {\n\t\t\tfor (int y=0; y<h; y++) {\n\t\t\t\tif (grid[x][y]=='X') continue;\n\t\t\t\tint normal=(y)%2*3+1;\n\t\t\t\tif(dist[x][y]%2==0) {\n\t\t\t\t\tans[x][y]=normal;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans[x][y]=normal==4?1:4;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int x=0; x<w; x++) {\n\t\t\tfor (int y=0; y<h; y++) {\n\t\t\t\tif (grid[x][y]=='X') {\n\t\t\t\t\tfor (int d=0; d<4; d++) {\n\t\t\t\t\t\tint nx=x+dx[d], ny=y+dy[d];\n\t\t\t\t\t\tif (grid[nx][ny]=='.')\n\t\t\t\t\t\t\tans[x][y]+=ans[nx][ny];\n\t\t\t\t\t}\n\t\t\t\t\tif (ans[x][y]%5!=0) {\n\t\t\t\t\t\tSystem.out.println(x+\" \"+y+\" \"+ans[x][y]);\n//\t\t\t\t\t\tthrow null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int y=0; y<h; y++) {\n\t\t\tfor (int x=0; x<w; x++) {\n\t\t\t\tSystem.out.print(ans[x][y]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic void sort(int[] a) {\n\t\tArrayList<Integer> l=new ArrayList<>();\n\t\tfor (int i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n\t\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n\n\t\n}\n"
        }
    ]
}