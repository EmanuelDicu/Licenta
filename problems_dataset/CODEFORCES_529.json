{
    "name": "529_A. And Yet Another Bracket Sequence",
    "source": "CODEFORCES",
    "description": "Polycarpus has a finite sequence of opening and closing brackets. In order not to fall asleep in a lecture, Polycarpus is having fun with his sequence. He is able to perform two operations:\n\n  * adding any bracket in any position (in the beginning, the end, or between any two existing brackets); \n  * cyclic shift \u2014 moving the last bracket from the end of the sequence to the beginning. \n\n\n\nPolycarpus can apply any number of operations to his sequence and adding a cyclic shift in any order. As a result, he wants to get the correct bracket sequence of the minimum possible length. If there are several such sequences, Polycarpus is interested in the lexicographically smallest one. Help him find such a sequence.\n\nAcorrect bracket sequence is a sequence of opening and closing brackets, from which you can get a correct arithmetic expression by adding characters \"1\" and \"+\" . Each opening bracket must correspond to a closed one. For example, the sequences \"(())()\", \"()\", \"(()(()))\" are correct and \")(\", \"(()\" and \"(()))(\" are not.\n\nThe sequence a1 a2... an is lexicographically smaller than sequence b1 b2... bn, if there is such number i from 1 to n, thatak = bk for 1 \u2264 k < i and ai < bi. Consider that \"(\"  < \")\".\n\nInput\n\nThe first line contains Polycarpus's sequence consisting of characters \"(\" and \")\". The length of a line is from 1 to 1 000 000.\n\nOutput\n\nPrint a correct bracket sequence of the minimum length that Polycarpus can obtain by his operations. If there are multiple such sequences, print the lexicographically minimum one.\n\nExamples\n\nInput\n\n()(())\n\n\nOutput\n\n(())()\n\nInput\n\n()(\n\n\nOutput\n\n(())\n\nNote\n\nThe sequence in the first example is already correct, but to get the lexicographically minimum answer, you need to perform four cyclic shift operations. In the second example you need to add a closing parenthesis between the second and third brackets and make a cyclic shift. You can first make the shift, and then add the bracket at the end.",
    "difficulty": "A",
    "tags": [
        "data structures",
        "greedy",
        "hashing",
        "string suffix structures",
        "strings"
    ],
    "rating": 2700,
    "public_test": [
        {
            "input": "()(\n",
            "output": "(())\n"
        },
        {
            "input": "()(())\n",
            "output": "(())()\n"
        }
    ],
    "generated_test": [
        {
            "input": ")())(())((\n",
            "output": "(()())(())\n"
        },
        {
            "input": ")())))(((())))())))))))()())(())))))()())))(((())))())()()))(())())((()())(()((()()()())()()()))((()\n",
            "output": "(((((((((((((((((((((((())))())()()))(())())((()())(()((()()()())()()()))((())())))(((())))())))))))()())(())))))()())))\n"
        },
        {
            "input": "))\n",
            "output": "(())\n"
        },
        {
            "input": "))(()(\n",
            "output": "(()())\n"
        },
        {
            "input": ")()))())((\n",
            "output": "(((()()))())\n"
        },
        {
            "input": "(())))(((())))())))))))()())(())))))()())))(((())))())()()))(())())((()())(()((()()()())()()()))((()\n",
            "output": "(((((((((((((((((((((())))())()()))(())())((()())(()((()()()())()()()))((()(())))(((())))())))))))()())(())))))()())))\n"
        },
        {
            "input": "))()((\n",
            "output": "(())()\n"
        },
        {
            "input": ")()))()(((\n",
            "output": "((()()))()\n"
        },
        {
            "input": ")((()))()()())()()()((()(())()((())())(()))()())())))(((())))()())))))(())()())))))))())))(((())))((\n",
            "output": "(((((((((((((((((((((())))(()((()))()()())()()()((()(())()((())())(()))()())())))(((())))()())))))(())()())))))))())))\n"
        },
        {
            "input": "(((\n",
            "output": "((()))\n"
        },
        {
            "input": ")(())))(((\n",
            "output": "((()(())))\n"
        },
        {
            "input": "(())))(((())))())))))))()())(())))))((())))(((())))())()()))(())())((()())(()((()()()())()()()))((()\n",
            "output": "(((((((((((((((((((())))())()()))(())())((()())(()((()()()())()()()))((()(())))(((())))())))))))()())(())))))((())))\n"
        },
        {
            "input": "())())\n",
            "output": "((())())\n"
        },
        {
            "input": ")(())()(((\n",
            "output": "((()(())()))\n"
        },
        {
            "input": "(())))(((())))())))))))()())(())))))((()))))((())))())()()))(())())((()())(()((()()()())()()()))((((\n",
            "output": "((((((((((((((((((()())(()((()()()())()()()))(((((())))(((())))())))))))()())(())))))((()))))((())))())()()))(())())\n"
        },
        {
            "input": "())))(\n",
            "output": "(((())))\n"
        },
        {
            "input": ")(())(((((\n",
            "output": "((((()(())))))\n"
        },
        {
            "input": "(())))(((())))())))))))()())(())))))(((())))((())))())()()))(())())((()())(()((()()()())()()()))((((\n",
            "output": "(((((((((((((((((())))((())))())()()))(())())((()())(()((()()()())()()()))(((((())))(((())))())))))))()())(())))))\n"
        },
        {
            "input": ")(()((((((\n",
            "output": "(((((()(()))))))\n"
        },
        {
            "input": "(())))(((())))())))))))()())(()))))((((())))((())))())()()))(())())((()())(()((()()()())()()()))((()\n",
            "output": "((((((((((((((((((())))((())))())()()))(())())((()())(()((()()()())()()()))((()(())))(((())))())))))))()())(()))))\n"
        },
        {
            "input": "((()))(((())))())))))))()())(()))))((((())))((())))())()()))(())())()()())(()((()()()())()()()))((()\n",
            "output": "((((((((((((((((((())))((())))())()()))(())())()()())(()((()()()())()()()))((()((()))(((())))())))))))()())(()))))\n"
        },
        {
            "input": ")))))(\n",
            "output": "((((()))))\n"
        },
        {
            "input": "((((((((()\n",
            "output": "((((((((()))))))))\n"
        },
        {
            "input": "((()))(((())))())))))))()())(()))))(((()))))((())))())()()))(())())()()())(()((()()()())()()()))((()\n",
            "output": "(((((((((((((((((((()))))((())))())()()))(())())()()())(()((()()()())()()()))((()((()))(((())))())))))))()())(()))))\n"
        },
        {
            "input": ")((\n",
            "output": "(())\n"
        },
        {
            "input": "(()\n",
            "output": "(())\n"
        },
        {
            "input": "(()())\n",
            "output": "(()())\n"
        },
        {
            "input": ")()\n",
            "output": "(())\n"
        },
        {
            "input": ")))\n",
            "output": "((()))\n"
        },
        {
            "input": "()))((\n",
            "output": "((()))\n"
        },
        {
            "input": "))))((\n",
            "output": "(((())))\n"
        },
        {
            "input": "(((((()(()\n",
            "output": "(((((()(()))))))\n"
        },
        {
            "input": ")(((((((((\n",
            "output": "((((((((()))))))))\n"
        }
    ],
    "solution": [
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1000047;\nchar s[maxn];\nint n;\nvector<int> utried() {\n  vector<int> lepsich(n);\n  vector<int> por;\n  int otv = 0;\n  for (int i = 0; i < n; i++) {\n    if (s[i] == '(') {\n      por.push_back(i);\n      lepsich[i] = 0;\n      otv++;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (s[i] == ')') {\n      por.push_back(i);\n      lepsich[i] = otv;\n    }\n  }\n  for (int sl = 1; sl < n; sl *= 2) {\n    vector<int> npor(n), off(n, 0);\n    for (int i = 0; i < n; i++) {\n      int ind = (por[i] - sl + n) % n;\n      npor[lepsich[ind] + off[lepsich[ind]]] = ind;\n      off[lepsich[ind]]++;\n    }\n    por = npor;\n    vector<int> nlepsich(n);\n    nlepsich[por[0]] = 0;\n    for (int i = 1; i < n; i++) {\n      if (lepsich[por[i]] == lepsich[por[i - 1]] &&\n          lepsich[(por[i] + sl) % n] == lepsich[(por[i - 1] + sl) % n]) {\n        nlepsich[por[i]] = nlepsich[por[i - 1]];\n      } else\n        nlepsich[por[i]] = i;\n    }\n    lepsich = nlepsich;\n  }\n  return por;\n}\nint main() {\n  scanf(\"%s\", s);\n  for (n = 0; s[n] != 0; n++)\n    ;\n  vector<int> depth(n + 1, 0);\n  for (int i = 1; i <= n; i++) {\n    if (s[i - 1] == '(')\n      depth[i] = depth[i - 1] + 1;\n    else\n      depth[i] = depth[i - 1] - 1;\n  }\n  vector<int> minpred(n + 1, 0);\n  for (int i = 1; i <= n; i++) {\n    minpred[i] = min(depth[i], minpred[i - 1]);\n  }\n  vector<int> minpo(n + 1, 1023456789);\n  for (int i = n - 1; i >= 0; i--) {\n    minpo[i] = min(depth[i + 1], minpo[i + 1]);\n  }\n  vector<bool> can_be(n, 0);\n  for (int i = 0; i < n; i++) {\n    if (depth[n] < 0) {\n      can_be[i] = (minpo[i] - depth[i] >= depth[n] && minpred[i] >= depth[i]);\n    } else {\n      can_be[i] = (minpo[i] >= depth[i] && minpred[i] + depth[n] >= depth[i]);\n    }\n  }\n  vector<int> por = utried();\n  int st = -1;\n  for (int i = 0; i < n; i++) {\n    if (can_be[por[i]]) {\n      st = por[i];\n      break;\n    }\n  }\n  if (depth[n] < 0) {\n    for (int i = 0; i < (0 - depth[n]); i++) {\n      printf(\"(\");\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    printf(\"%c\", s[(i + st) % n]);\n  }\n  if (depth[n] > 0) {\n    for (int i = 0; i < depth[n]; i++) printf(\")\");\n  }\n  printf(\"\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long inf = (long long)1e9 + 70;\nconst long long mod = 1e9 + 7;\nconst int maxn = 2e6 + 1000;\nstruct SuffixArray {\n  int n;\n  string s;\n  int SA[maxn], tempSA[maxn], RA[maxn], tempRA[maxn];\n  void countingsort(int k) {\n    int maxi = max(n, 300);\n    vector<int> c(maxi);\n    for (int i = (0); i < (n); i++) {\n      int v = (i + k < n ? RA[i + k] : 0);\n      c[v]++;\n    }\n    int s = 0;\n    for (int i = (0); i < (maxi); i++) {\n      int t = c[i];\n      c[i] = s;\n      s += t;\n    }\n    for (int j = (0); j < (n); j++) {\n      int i = SA[j];\n      int v = (i + k < n ? RA[i + k] : 0);\n      tempSA[c[v]] = i;\n      c[v]++;\n    }\n    for (int i = (0); i < (n); i++) SA[i] = tempSA[i];\n  }\n  void init(string e) {\n    e = e + \"$\";\n    s = e;\n    n = s.length();\n    for (int i = (0); i < (n); i++) {\n      SA[i] = i;\n      RA[i] = s[i];\n    }\n    for (int k = 1; k <= n; k *= 2) {\n      countingsort(k);\n      countingsort(0);\n      for (int j = (0); j < (n); j++) {\n        int i = SA[j];\n        if (j == 0) {\n          tempRA[i] = 0;\n          continue;\n        }\n        int p = SA[j - 1];\n        if (RA[i] == RA[p] && RA[i + k] == RA[p + k]) {\n          tempRA[i] = tempRA[p];\n        } else {\n          tempRA[i] = tempRA[p] + 1;\n        }\n      }\n      for (int i = (0); i < (n); i++) RA[i] = tempRA[i];\n      vector<bool> seen(n);\n      bool done = true;\n      for (int i = (0); i < (n / 2); i++) {\n        if (seen[RA[i]]) {\n          done = false;\n          break;\n        }\n        seen[RA[i]] = true;\n      }\n      if (done) {\n        break;\n      }\n    }\n  }\n} Z;\nint delta[maxn];\nint pre[maxn];\nint suf[maxn];\nint main() {\n  if (fopen(\"i.txt\", \"r\")) freopen(\"i.txt\", \"r\", stdin);\n  string s;\n  cin >> s;\n  int n = s.length();\n  delta[0] = 0;\n  for (int i = (1); i < (n + 1); i++) {\n    delta[i] = delta[i - 1] + (s[i - 1] == '(' ? 1 : -1);\n  }\n  for (int i = (0); i < (n + 3); i++) {\n    pre[i] = inf;\n    suf[i] = inf;\n  }\n  for (int i = (1); i < (n); i++) {\n    pre[i] = min(pre[i - 1], delta[i - 1]);\n  }\n  for (int i = n - 1; i >= 0; i--) {\n    suf[i] = min(suf[i + 1], delta[i]);\n  }\n  Z.init(s + s);\n  if (delta[n] >= 0) {\n    vector<int> options;\n    for (int i = (0); i < (n); i++) {\n      int mn = min(pre[i] + delta[n] - delta[i], suf[i] - delta[i]);\n      if (mn >= 0) {\n        options.push_back(i);\n      }\n    }\n    int best = options[0];\n    for (int e : options) {\n      if (Z.RA[e] < Z.RA[best]) {\n        best = e;\n      }\n    }\n    cout << s.substr(best) << s.substr(0, best);\n    for (int i = (0); i < (delta[n]); i++) {\n      cout << ')';\n    }\n    cout << \"\\n\";\n  } else {\n    int k = -delta[n];\n    for (int i = (0); i < (k); i++) {\n      cout << '(';\n    }\n    vector<int> options;\n    for (int i = (0); i < (n); i++) {\n      int mn = min(pre[i] + delta[n] - delta[i], suf[i] - delta[i]);\n      if (mn >= -k) {\n        options.push_back(i);\n      }\n    }\n    int best = options[0];\n    for (int e : options) {\n      if (Z.RA[e] < Z.RA[best]) {\n        best = e;\n      }\n    }\n    cout << s.substr(best) << s.substr(0, best);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int maxn = 1000010;\nchar s[maxn];\nint cnt, tran[256], len, x[maxn], y[maxn], c[maxn], sa[maxn], sum[maxn],\n    l[maxn], r[maxn];\nint min(int x, int y) { return x < y ? x : y; }\nint main() {\n  scanf(\"%s\", s);\n  len = strlen(s);\n  for (int i = 0; i < len; ++i) {\n    if (!tran[s[i]]) {\n      ++cnt;\n      tran[s[i]] = 1;\n    }\n  }\n  for (int i = 0, j = 0; i < 256; ++i)\n    if (tran[i]) tran[i] = j++;\n  for (int i = 0; i < len; ++i) ++c[x[i] = tran[s[i]]];\n  for (int i = 1; i < cnt; ++i) c[i] += c[i - 1];\n  for (int i = len - 1; i >= 0; --i) sa[--c[x[i]]] = i;\n  for (int k = 1; k <= len; k <<= 1) {\n    int tmp = 0;\n    for (int i = 0; i < len; ++i) y[tmp++] = (sa[i] + len - k) % len;\n    memset(c, 0, sizeof c);\n    for (int i = 0; i < len; ++i) ++c[x[y[i]]];\n    for (int i = 1; i < cnt; ++i) c[i] += c[i - 1];\n    for (int i = len - 1; i >= 0; --i) sa[--c[x[y[i]]]] = y[i];\n    memcpy(y, x, sizeof x);\n    cnt = 1;\n    x[sa[0]] = 0;\n    for (int i = 1; i < len; ++i)\n      if (y[sa[i - 1]] == y[sa[i]] &&\n          y[(sa[i - 1] + k) % len] == y[(sa[i] + k) % len])\n        x[sa[i]] = cnt - 1;\n      else\n        x[sa[i]] = cnt++;\n    if (cnt >= len) break;\n  }\n  for (int i = 0; i < len; ++i) sum[i + 1] = sum[i] + (s[i] == '(' ? 1 : -1);\n  l[0] = sum[0];\n  for (int i = 1; i <= len; ++i) l[i] = min(l[i - 1], sum[i - 1]);\n  r[len] = sum[len];\n  for (int i = len - 1; i >= 0; --i) r[i] = min(r[i + 1], sum[i]);\n  for (int i = 0; i < len; ++i) {\n    int pos = sa[i];\n    int now = min(r[pos] - sum[pos], sum[len] - sum[pos] + l[pos]);\n    if (sum[len] > 0 && now >= 0) {\n      for (int j = pos; j < len; ++j) putchar(s[j]);\n      for (int j = 0; j < pos; ++j) putchar(s[j]);\n      for (int j = 0; j < sum[len]; ++j) putchar(')');\n      putchar('\\n');\n      break;\n    } else if (sum[len] <= 0 && now - sum[len] >= 0) {\n      for (int j = 0; j < -sum[len]; ++j) putchar('(');\n      for (int j = pos; j < len; ++j) putchar(s[j]);\n      for (int j = 0; j < pos; ++j) putchar(s[j]);\n      putchar('\\n');\n      break;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst double PI = acos(-1.0);\nconst double EPS = 1e-6;\nstruct SuffixArray {\n  int n;\n  int ranks[2][2000005], SA[2000005];\n  string str;\n  SuffixArray() {}\n  void Initialize(string s) {\n    this->str = s;\n    n = ((int)(s).size());\n    ComputeRank();\n  }\n  void ComputeRank() {\n    int p = 0;\n    for (int i = 0; i <= n; i++) {\n      SA[i] = i;\n      ranks[p][i] = str[i];\n    }\n    for (int k = 1; k <= n; k <<= 1) {\n      auto compareByKey = [p, k, this](const int &lhs, const int &rhs) -> bool {\n        int LHS = lhs + k < n ? ranks[p][lhs + k] : -1;\n        int RHS = rhs + k < n ? ranks[p][rhs + k] : -1;\n        return LHS < RHS;\n      };\n      auto compareByRank = [compareByKey, p, k, this](const int &lhs,\n                                                      const int &rhs) -> bool {\n        if (ranks[p][lhs] != ranks[p][rhs])\n          return ranks[p][lhs] < ranks[p][rhs];\n        return compareByKey(lhs, rhs);\n      };\n      int prev = 0;\n      if (k > 1) {\n        for (int i = 1; i <= n; i++)\n          if (ranks[p][SA[i]] != ranks[p][SA[prev]]) {\n            sort(SA + prev, SA + i, compareByKey);\n            prev = i;\n          }\n      }\n      sort(SA + prev, SA + n, compareByRank);\n      for (int i = 1; i <= n; i++)\n        ranks[p ^ 1][SA[i]] =\n            ranks[p ^ 1][SA[i - 1]] + compareByRank(SA[i - 1], SA[i]);\n      p ^= 1;\n    }\n  }\n} sa;\nint presum[2000005];\nint lsum[2000005], rsum[2000005];\nint cnt[2000005 << 1];\nint main() {\n  { ; };\n  string s;\n  cin >> s;\n  int len = ((int)(s).size());\n  s.append(s);\n  sa.Initialize(s);\n  int minn = 2000005;\n  for (int i = 0; i < len; i++)\n    presum[i + 1] = presum[i] + (s[i] == '(' ? 1 : -1);\n  lsum[0] = presum[len];\n  for (int i = 1; i <= len; i++)\n    lsum[i] = min(lsum[i - 1], presum[i] + presum[len]);\n  rsum[len] = presum[len];\n  for (int i = len - 1; i >= 0; i--) rsum[i] = min(rsum[i + 1], presum[i]);\n  int score = min(0, presum[len]);\n  int res = -1;\n  for (int i = 0; i < len; i++)\n    if (min(lsum[i], rsum[i]) == score + presum[i])\n      if (res == -1 || sa.ranks[0][i] <= sa.ranks[0][res]) res = i;\n  ;\n  for (int j = 0; j < -presum[len]; j++) putchar('(');\n  printf(\"%s\", s.substr(res, len).c_str());\n  for (int j = 0; j < presum[len]; j++) putchar(')');\n  puts(\"\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, N, a[2000005], s[2000005], q[2000005], ql, qr, rec[1000005], ans;\nint f[2000005][22];\nstring in;\nint main() {\n  ios::sync_with_stdio(0);\n  cin >> in;\n  n = in.size();\n  for (int i = 1; i <= n; ++i) {\n    if (in[i - 1] == '(')\n      a[i] = a[i + n] = 0;\n    else\n      a[i] = a[i + n] = 1;\n  }\n  N = n * 2;\n  for (int i = 1; i <= N; ++i) {\n    if (a[i] == 0)\n      s[i] = s[i - 1] + 1;\n    else\n      s[i] = s[i - 1] - 1;\n  }\n  ql = 1;\n  for (int i = N; i > n; --i) {\n    while (qr >= ql && s[q[qr]] >= s[i]) --qr;\n    q[++qr] = i;\n  }\n  for (int i = n; i; --i) {\n    while (qr >= ql && s[q[qr]] >= s[i]) --qr;\n    q[++qr] = i;\n    if (q[ql] == i + n) ++ql;\n    rec[i] = s[q[ql]] - s[i - 1];\n    if (s[n] < 0) rec[i] -= s[n];\n  }\n  long long o = 2;\n  for (int i = 1; i <= N; ++i) f[i][0] = a[i];\n  for (int k = 0; k < 20; ++k) {\n    for (int i = 1; i <= N - (2 << k) + 1; ++i)\n      f[i][k + 1] = (f[i][k] * o + f[i + (1 << k)][k]) % 1000000007ll;\n    o = o * o % 1000000007ll;\n  }\n  ans = 0;\n  for (int i = 1; i <= n; ++i) {\n    if (rec[i] < 0) continue;\n    if (!ans) {\n      ans = i;\n      continue;\n    }\n    int x = ans, y = i, o = 0;\n    for (int k = 20; k >= 0; --k) {\n      if (o + (1 << k) > n) continue;\n      if (f[x][k] == f[y][k]) x += (1 << k), y += (1 << k), o += (1 << k);\n    }\n    if (o < n && a[y] < a[x]) ans = i;\n  }\n  string out = \"\";\n  in += in;\n  for (int i = ans; i <= ans + n - 1; ++i) out += in[i - 1];\n  int O = s[n];\n  if (O > 0) {\n    cout << out;\n    while (O > 0) cout << \")\", --O;\n  } else {\n    while (O < 0) cout << \"(\", ++O;\n    cout << out;\n  }\n  cout << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar buf[2000002];\nstruct st {\n  int open;\n  int close;\n  st() { open = close = 0; }\n  void add_front(char c) {\n    if (c == '(') {\n      if (close) {\n        close--;\n      } else {\n        open++;\n      }\n    } else {\n      close++;\n    }\n  }\n  void add_back(char c) {\n    if (c == '(') {\n      open++;\n    } else {\n      if (open) {\n        open--;\n      } else {\n        close++;\n      }\n    }\n  }\n};\nst pref[2000002];\nst suf[2000002];\nst merge(st a, st b) {\n  int par = min(a.open, b.close);\n  a.open -= par;\n  b.close -= par;\n  st r;\n  r.open = a.open + b.open;\n  r.close = a.close + b.close;\n  return r;\n}\nstring S;\nlong long int h[2000002][2];\nlong long int base[] = {1000000007, 1000000009};\nlong long int up[] = {1231413, 7324125};\nlong long int mul[2000002][2];\nvoid hash_init() {\n  mul[0][0] = mul[0][1] = 1;\n  for (int i = 1; i < 2000002; i++) {\n    for (int j = 0; j < 2; j++) {\n      mul[i][j] = mul[i - 1][j];\n      mul[i][j] *= up[j];\n      mul[i][j] %= base[j];\n    }\n  }\n  long long int cur[] = {0, 0};\n  for (int i = 0; i < S.size(); i++) {\n    for (int j = 0; j < 2; j++) {\n      cur[j] *= up[j];\n      cur[j] += S[i];\n      cur[j] %= base[j];\n      h[i][j] = cur[j];\n    }\n  }\n}\npair<long long int, long long int> gett(int a, int b) {\n  long long int val[] = {h[b][0], h[b][1]};\n  if (a) {\n    val[0] -= (h[a - 1][0] * mul[b - a + 1][0]) % base[0];\n    val[1] -= (h[a - 1][1] * mul[b - a + 1][1]) % base[1];\n    if (val[0] < 0) val[0] += base[0];\n    if (val[1] < 0) val[1] += base[1];\n  }\n  return make_pair(val[0], val[1]);\n}\nbool eq(int a, int b, int len) {\n  if (a > b) swap(a, b);\n  pair<long long int, long long int> val1 = gett(a, a + len - 1);\n  pair<long long int, long long int> val2 = gett(b, b + len - 1);\n  return val1 == val2;\n}\nbool lexicographically_small(int a, int b) {\n  if (S[a] != S[b]) return S[a] < S[b];\n  int mint = 1;\n  int maxt = S.size() / 2;\n  while (mint + 1 < maxt) {\n    int mid = (mint + maxt) >> 1;\n    if (eq(a, b, mid)) {\n      mint = mid;\n    } else {\n      maxt = mid;\n    }\n  }\n  if (eq(a, b, maxt)) {\n    mint = maxt;\n  } else {\n    maxt = mint;\n  }\n  return S[a + mint] < S[b + mint];\n}\nstring ans;\nstring s;\nint main() {\n  scanf(\"%s\", buf);\n  s = buf;\n  S = s + s;\n  hash_init();\n  {\n    st cur;\n    for (int i = 0; i < s.size(); i++) {\n      cur.add_back(s[i]);\n      pref[i] = cur;\n    }\n  }\n  {\n    st cur;\n    for (int i = s.size() - 1; i >= 0; i--) {\n      cur.add_front(s[i]);\n      suf[i] = cur;\n    }\n  }\n  int MIN_LEN = INT_MAX;\n  for (int i = 0; i < s.size(); i++) {\n    st nex = suf[i];\n    if (i) {\n      nex = merge(nex, pref[i - 1]);\n    }\n    MIN_LEN = min(MIN_LEN, (int)(s.size() + nex.open + nex.close));\n  }\n  int max_open = 0;\n  for (int i = 0; i < s.size(); i++) {\n    st nex = suf[i];\n    if (i) {\n      nex = merge(nex, pref[i - 1]);\n    }\n    int len = s.size() + nex.open + nex.close;\n    if (len == MIN_LEN) {\n      max_open = max(max_open, nex.close);\n    }\n  }\n  int id = -1;\n  for (int i = 0; i < s.size(); i++) {\n    st nex = suf[i];\n    if (i) {\n      nex = merge(nex, pref[i - 1]);\n    }\n    int len = s.size() + nex.open + nex.close;\n    if (len != MIN_LEN) {\n      continue;\n    }\n    if (max_open != nex.close) {\n      continue;\n    }\n    if (id == -1) {\n      id = i;\n      continue;\n    }\n    if (!lexicographically_small(id, i)) {\n      id = i;\n    }\n  }\n  for (int i = 0; i < max_open; i++) {\n    ans.push_back('(');\n  }\n  ans += s.substr(id, s.size() - id);\n  if (id) {\n    ans += s.substr(0, id);\n  }\n  while (ans.size() < MIN_LEN) {\n    ans.push_back(')');\n  }\n  printf(\"%s\\n\", ans.c_str());\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 4, sz = 1 << 20, inf = 1e9;\nstruct node {\n  int c1, c2, id;\n  node() { c1 = c2 = id = 0; }\n  node(const int &cc1, const int &cc2, const int &cid) {\n    c1 = cc1;\n    c2 = cc2;\n    id = cid;\n  }\n};\ninline bool operator<(const node &lhs, const node &rhs) {\n  if (lhs.c1 == rhs.c1) return lhs.c2 < rhs.c2;\n  return lhs.c1 < rhs.c1;\n}\ninline bool operator==(const node &lhs, const node &rhs) {\n  return lhs.c1 == rhs.c1 && lhs.c2 == rhs.c2;\n}\nstring s;\nvector<node> v;\nint c[N];\nint t[sz + sz];\nint moment[N];\nint best = -1;\ninline void upd(int x, const int &delta) {\n  t[x += sz] = delta;\n  while (x >>= 1) t[x] = min(t[x << 1], t[(x << 1) | 1]);\n}\ninline int get(int l, int r) {\n  int res = inf;\n  for (l += sz, r += sz; l <= r; l >>= 1, r >>= 1) {\n    if (l & 1) res = min(res, t[l++]);\n    if (!(r & 1)) res = min(res, t[r--]);\n  }\n  return res;\n}\nint main() {\n  ios_base ::sync_with_stdio(0);\n  cin >> s;\n  int n = s.size();\n  v.resize(n);\n  for (int i = 0; i < n; ++i) v[i] = node(s[i], s[i], i);\n  sort(v.begin(), v.end());\n  int cnt = 0;\n  c[v[0].id] = ++cnt;\n  for (int i = 1; i < n; ++i)\n    if (v[i] == v[i - 1])\n      c[v[i].id] = c[v[i - 1].id];\n    else\n      c[v[i].id] = ++cnt;\n  for (int k = 0; (1 << k) <= n; ++k) {\n    for (int i = 0; i < n; ++i) v[i] = node(c[i], c[(i + (1 << k)) % n], i);\n    sort(v.begin(), v.end());\n    cnt = 0;\n    c[v[0].id] = ++cnt;\n    for (int i = 1; i < n; ++i)\n      if (v[i] == v[i - 1])\n        c[v[i].id] = c[v[i - 1].id];\n      else\n        c[v[i].id] = ++cnt;\n  }\n  int balance = 0;\n  for (int i = 0; i < n; ++i) {\n    balance += (s[i] == ')' ? -1 : +1);\n    moment[i] = balance;\n    upd(i, balance);\n  }\n  for (int i = 0; i < n; ++i) {\n    if (i == 0 && (max(0, -balance) + get(0, n - 1) < 0))\n      continue;\n    else if (((-moment[i - 1] + get(i, n - 1) + max(0, -balance) < 0) ||\n              (-moment[i - 1] + moment[n - 1] + get(0, i - 1) +\n                   max(0, -balance) <\n               0)))\n      continue;\n    if (best == -1 || c[best] > c[i]) best = i;\n  }\n  while (balance < 0) {\n    cout << \"(\";\n    ++balance;\n  }\n  for (int j = best; j < n; ++j) cout << s[j];\n  for (int j = 0; j < best; ++j) cout << s[j];\n  while (balance > 0) {\n    cout << \")\";\n    --balance;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint dx[4] = {0, -1, 0, 1};\nint dy[4] = {1, 0, -1, 0};\nusing namespace std;\nchar s[2234567];\nchar ans[2234567 * 2];\nint n;\nlong long hs[2234567], base[2234567];\nvoid makehash() {\n  hs[0] = 0;\n  base[0] = 1;\n  for (int i = 1; i <= int(n * 2); ++i)\n    base[i] = base[i - 1] * 2 % 1000000007ll,\n    hs[i] = (hs[i - 1] * 2 + (s[i] == '(' ? 0 : 1)) % 1000000007ll;\n}\ninline long long geths(int i, int len) {\n  return (hs[i + len - 1] - hs[i - 1] * base[len] % 1000000007ll +\n          1000000007ll) %\n         1000000007ll;\n}\ninline int lp(int u, int v) {\n  int l = 0, r = n;\n  while (l < r) {\n    int m = (l + r + 1) >> 1;\n    if (geths(u, m) == geths(v, m))\n      l = m;\n    else\n      r = m - 1;\n  }\n  return l;\n}\ninline bool cmp(const int &x, const int &y) {\n  int l = lp(x, y);\n  return s[x + l] < s[y + l];\n}\nint a[2234567];\nint Main() {\n  ios_base::sync_with_stdio(0);\n  scanf(\"%s\", s + 1);\n  n = strlen(s + 1);\n  int cnt = 0;\n  for (int i = 1; i <= int(n); ++i) {\n    if (s[i] == '(')\n      cnt++;\n    else\n      cnt--;\n    s[i + n] = s[i];\n  }\n  int need = cnt >= 0 ? 0 : -cnt;\n  makehash();\n  set<pair<int, int> > st;\n  int now = 0;\n  int pre = 0;\n  int can = 0;\n  for (int i = 1; i <= int(n * 2 - 1); ++i) {\n    if (s[i] == '(')\n      now++;\n    else\n      now--;\n    a[i] = now;\n    st.insert({a[i], i});\n    if (i > n) {\n      if (s[i - n] == '(')\n        pre++;\n      else\n        pre--;\n      st.erase({a[i - n], i - n});\n    }\n    if (i >= n && st.begin()->first - pre + need >= 0) {\n      if (can == 0 || cmp(i - n + 1, can)) can = i - n + 1;\n    }\n  }\n  int u = 0;\n  if (cnt > 0) {\n    for (int i = 0; i < int(n); ++i) ans[u++] = s[can + i];\n    for (int i = 0; i < int(cnt); ++i) ans[u++] = ')';\n  } else {\n    for (int i = 0; i < int(-cnt); ++i) ans[u++] = '(';\n    for (int i = 0; i < int(n); ++i) ans[u++] = s[can + i];\n  }\n  ans[u] = '\\0';\n  puts(ans);\n  return 0;\n}\nint main() { return Main(); }\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(3)\nusing namespace std;\nclock_t __stt;\ninline void TStart() { __stt = clock(); }\ninline void TReport() {\n  printf(\"\\nTaken Time : %.3lf sec\\n\",\n         (double)(clock() - __stt) / CLOCKS_PER_SEC);\n}\ntemplate <typename T>\nT MIN(T a, T b) {\n  return a < b ? a : b;\n}\ntemplate <typename T>\nT MAX(T a, T b) {\n  return a > b ? a : b;\n}\ntemplate <typename T>\nT ABS(T a) {\n  return a > 0 ? a : (-a);\n}\ntemplate <typename T>\nvoid UMIN(T &a, T b) {\n  if (b < a) a = b;\n}\ntemplate <typename T>\nvoid UMAX(T &a, T b) {\n  if (b > a) a = b;\n}\nchar s[1000005];\nbool a[1000005];\nint n, sum, pr[1000005], sf[1000005];\nint mnpr[1000005], mxsf[1000005];\nbool ok[1000005];\nnamespace SA {\nint n, cnt[1000005], rk[2000005], vy[1000005], ls[1000005], tmp[1000005];\nvoid bsort() {\n  int i;\n  memset(cnt, 0, sizeof(cnt));\n  for (i = 0; i < n; ++i) ++cnt[vy[i]];\n  for (i = 1; i <= n + 3 || i <= 30; ++i) cnt[i] += cnt[i - 1];\n  for (i = n - 1; i >= 0; --i) tmp[--cnt[vy[i]]] = i;\n  memset(cnt, 0, sizeof(cnt));\n  for (i = 0; i < n; ++i) ++cnt[rk[tmp[i]]];\n  for (i = 1; i <= n + 3 || i <= 30; ++i) cnt[i] += cnt[i - 1];\n  for (i = n - 1; i >= 0; --i) ls[--cnt[rk[tmp[i]]]] = tmp[i];\n  memset(tmp, 0, sizeof(tmp));\n}\nvoid getsa() {\n  int i, j, cv;\n  memset(rk, 0, sizeof(rk));\n  memset(vy, 0, sizeof(vy));\n  for (i = 0; i < n; ++i) {\n    rk[i] = !a[i];\n  }\n  for (i = 2; i <= n * 2; i <<= 1) {\n    for (j = 0; j < n; ++j) {\n      vy[j] = rk[(j + (i >> 1)) % n];\n    }\n    bsort();\n    cv = 1;\n    for (j = 0; j < n; ++j) {\n      if (j && (rk[ls[j - 1]] != rk[ls[j]] || vy[ls[j - 1]] != vy[ls[j]])) ++cv;\n      tmp[ls[j]] = cv;\n    }\n    memcpy(rk, tmp, sizeof(tmp));\n  }\n}\n}  // namespace SA\nint main() {\n  int i, j, k;\n  scanf(\"%s\", s);\n  n = strlen(s);\n  for (i = 0; i < n; ++i) {\n    a[i] = (s[i] == '(');\n    pr[i] = sf[i] = (a[i] ? 1 : -1);\n    sum += pr[i];\n  }\n  for (i = 1; i < n; ++i) pr[i] += pr[i - 1];\n  for (i = n - 2; i >= 0; --i) sf[i] += sf[i + 1];\n  for (i = 0; i < n; ++i) mnpr[i] = MIN((i ? mnpr[i - 1] : 2000000000), pr[i]);\n  for (i = n - 1; i >= 0; --i)\n    mxsf[i] = MAX((i == n - 1 ? -2000000000 : mxsf[i + 1]), sf[i]);\n  SA::n = n;\n  SA::getsa();\n  if (sum <= 0) {\n    for (i = 1; i < n; ++i) {\n      if (mxsf[i] + pr[i - 1] <= 0 && pr[i - 1] - mnpr[i - 1] <= 0) {\n        ok[i] = 1;\n      }\n    }\n    if (mxsf[0] <= 0) ok[0] = 1;\n    for (i = 0; i < n; ++i) {\n      if (ok[SA::ls[i]]) {\n        for (j = 0; j < -sum; ++j) {\n          printf(\"(\");\n        }\n        for (j = 0; j < n; ++j) {\n          printf(\"%c\", s[(SA::ls[i] + j) % n]);\n        }\n        printf(\"\\n\");\n        return 0;\n      }\n    }\n  } else {\n    for (i = 1; i < n; ++i) {\n      if (mnpr[i - 1] + sf[i] >= 0 && sf[i] - mxsf[i] >= 0) {\n        ok[i] = 1;\n      }\n    }\n    if (mnpr[n - 1] >= 0) ok[0] = 1;\n    for (i = 0; i < n; ++i) {\n      if (ok[SA::ls[i]]) {\n        for (j = 0; j < n; ++j) {\n          printf(\"%c\", s[(SA::ls[i] + j) % n]);\n        }\n        for (j = 0; j < sum; ++j) {\n          printf(\")\");\n        }\n        printf(\"\\n\");\n        return 0;\n      }\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar s[1111111];\nint t[2222222], sa[2222222], lcp[2222222], buc[2222222], arr[2222222], k,\n    rnk[2222222], n, cur, tmp[2222222], res, x, y, dp[2222222];\nconst int ct = 2;\nint pre[2222222], suf[2222222], mpre[2222222], msuf[2222222];\nbool cmp(int i, int j) {\n  int ri = i + k < n ? rnk[i + k] : -1;\n  int rj = j + k < n ? rnk[j + k] : -1;\n  return (rnk[i] == rnk[j] && ri == rj);\n}\nvoid make_sa() {\n  for (int i = 0; i < ct; i++) buc[i] = 0;\n  for (int i = 0; i < n; i++) buc[t[i]]++;\n  for (int i = 1; i < ct; i++) buc[i] += buc[i - 1];\n  for (int i = 0; i < n; i++) sa[--buc[t[i]]] = i;\n  for (int i = 0; i < n; i++) rnk[i] = t[i];\n  for (k = 1; k <= n; k *= 2) {\n    cur = 0;\n    for (int i = n - k; i < n; i++) arr[cur++] = i;\n    for (int i = 0; i < n; i++) {\n      if (sa[i] >= k) arr[cur++] = sa[i] - k;\n    }\n    for (int i = 0; i < n; i++) buc[i] = 0;\n    for (int i = 0; i < n; i++) buc[rnk[i]]++;\n    for (int i = 1; i < n; i++) buc[i] += buc[i - 1];\n    for (int i = n - 1; i >= 0; i--) sa[--buc[rnk[arr[i]]]] = arr[i];\n    tmp[sa[0]] = 0;\n    for (int i = 1; i < n; i++) {\n      if (cmp(sa[i - 1], sa[i]))\n        tmp[sa[i]] = tmp[sa[i - 1]];\n      else\n        tmp[sa[i]] = tmp[sa[i - 1]] + 1;\n    }\n    for (int i = 0; i < n; i++) rnk[i] = tmp[i];\n  }\n}\nint main() {\n  scanf(\"%s\", s);\n  n = strlen(s);\n  for (int i = 0; i < 2 * n; i++) {\n    if (i >= n) {\n      if (s[i - n] == '(')\n        t[i] = 0;\n      else\n        t[i] = 1;\n    } else {\n      if (s[i] == '(')\n        t[i] = 0;\n      else\n        t[i] = 1;\n    }\n  }\n  for (int i = 0; i < n; i++) pre[i] = pre[i - 1] + (t[i] ? -1 : 1);\n  for (int i = n - 1; i >= 0; i--) suf[i] = suf[i + 1] + (t[i] ? -1 : 1);\n  for (int i = 0; i < n; i++) {\n    mpre[i] = min(mpre[i - 1], pre[i]);\n  }\n  for (int i = n - 1; i >= 0; i--) {\n    msuf[i] = min(msuf[i + 1] + (t[i] ? -1 : 1), (t[i] ? -1 : 1));\n  }\n  for (int i = 0; i < n; i++) {\n    dp[i] = min(msuf[i], suf[i] + mpre[i - 1]);\n  }\n  n *= 2;\n  make_sa();\n  n /= 2;\n  for (int i = 0; i < n; i++) {\n    if (s[i] == '(')\n      x++;\n    else\n      y++;\n  }\n  if (x < y) {\n    for (int i = 0; i < n; i++) dp[i] += (y - x);\n  }\n  for (int i = 0; i < 2 * n; i++) {\n    if (sa[i] < n && dp[sa[i]] >= 0) {\n      res = sa[i];\n      break;\n    }\n  }\n  for (int i = x; i < y; i++) putchar('(');\n  for (int i = res; i < res + n; i++) {\n    if (!t[i])\n      putchar('(');\n    else\n      putchar(')');\n  }\n  for (int i = y; i < x; i++) putchar(')');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2111111;\nchar buf[maxn];\nint sum[maxn];\nbool ok[maxn];\nint order[maxn];\ntemplate <typename T>\nvoid debug(T a[], int n) {\n  for (int i = 1; i <= n; ++i) {\n    cout << setw(3) << a[i];\n  }\n  puts(\"\");\n}\nvoid fix(int& i, int n) {\n  while (!ok[i] && i <= n) {\n    ++i;\n  }\n}\nint run(char s[], int m) {\n  int n = m >> 1;\n  int i = 1, j = 2, k = 0;\n  fix(i, n);\n  j = i + 1;\n  fix(j, n);\n  while (j <= n) {\n    for (k = 0; k < n; ++k) {\n      if (s[i + k] ^ s[j + k]) {\n        break;\n      }\n    }\n    if (s[i + k] > s[j + k]) {\n      i += k + 1;\n      fix(i, n);\n    } else {\n      j += k + 1;\n      fix(j, n);\n    }\n    if (j == i) {\n      ++j;\n      fix(j, n);\n    }\n  }\n  return std::min(i, j);\n}\nint main() {\n  for (int i = 1; i < 100; ++i) {\n    order[i] = i;\n  }\n  scanf(\"%s\", buf + 1);\n  int n = std::strlen(buf + 1);\n  int A, B;\n  A = B = 0;\n  for (int i = 1; i <= n; ++i) {\n    buf[i + n] = buf[i];\n    if (buf[i] == '(') {\n      ++A;\n    } else {\n      ++B;\n    }\n  }\n  int m = n << 1;\n  for (int i = 1; i <= m; ++i) {\n    if (buf[i] == '(') {\n      sum[i] = 1;\n    } else {\n      sum[i] = -1;\n    }\n    sum[i] += sum[i - 1];\n  }\n  static int q[maxn];\n  int front, rear;\n  front = rear = 0;\n  static int min[maxn];\n  int add = 0;\n  if (A < B) {\n    add = B - A;\n  }\n  for (int i = 1; i <= m; ++i) {\n    if (front < rear && q[front] + n <= i) {\n      ++front;\n    }\n    while (front < rear && sum[q[rear - 1]] >= sum[i]) {\n      --rear;\n    }\n    q[rear++] = i;\n    min[i] = sum[q[front]];\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (add + min[i + n - 1] >= sum[i - 1]) {\n      ok[i] = true;\n    }\n  }\n  int index = run(buf, m);\n  auto print = [](char ch, int n) {\n    while (n--) {\n      putchar(ch);\n    }\n  };\n  if (A < B) {\n    print('(', B - A);\n  }\n  for (int i = index; i < index + n; ++i) {\n    putchar(buf[i]);\n  }\n  if (B < A) {\n    print(')', A - B);\n  }\n  puts(\"\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nT in() {\n  char ch;\n  T n = 0;\n  bool ng = false;\n  while (1) {\n    ch = getchar();\n    if (ch == '-') {\n      ng = true;\n      ch = getchar();\n      break;\n    }\n    if (ch >= '0' && ch <= '9') break;\n  }\n  while (1) {\n    n = n * 10 + (ch - '0');\n    ch = getchar();\n    if (ch < '0' || ch > '9') break;\n  }\n  return (ng ? -n : n);\n}\ntemplate <typename T>\ninline T Dis(T x1, T y1, T x2, T y2) {\n  return sqrt((x1 - x2 * x1 - x2) + (y1 - y2 * y1 - y2));\n}\ntemplate <typename T>\ninline T POW(T B, T P) {\n  if (P == 0) return 1;\n  if (P & 1)\n    return B * POW(B, P - 1);\n  else\n    return (POW(B, P / 2) * POW(B, P / 2));\n}\ntemplate <typename T>\ninline T ABS(T a) {\n  if (a < 0)\n    return -a;\n  else\n    return a;\n}\ntemplate <typename T>\ninline T Gcd(T a, T b) {\n  if (a < 0) return Gcd(-a, b);\n  if (b < 0) return Gcd(a, -b);\n  return (b == 0) ? a : Gcd(b, a % b);\n}\ntemplate <typename T>\ninline T Lcm(T a, T b) {\n  if (a < 0) return Lcm(-a, b);\n  if (b < 0) return Lcm(a, -b);\n  return a * (b / Gcd(a, b));\n}\nlong long Bigmod(long long base, long long power, long long MOD) {\n  long long ret = 1;\n  while (power) {\n    if (power & 1) ret = (ret * base) % MOD;\n    base = (base * base) % MOD;\n    power >>= 1;\n  }\n  return ret;\n}\nlong long ModInverse(long long number, long long MOD) {\n  return Bigmod(number, MOD - 2, MOD);\n}\nint Set(int N, int pos) { return N = N | (1 << pos); }\nint Reset(int N, int pos) { return N = N & ~(1 << pos); }\nbool Chkbit(int N, int pos) { return (bool)(N & (1 << pos)); }\nbool isVowel(char ch) {\n  ch = toupper(ch);\n  if (ch == 'A' || ch == 'U' || ch == 'I' || ch == 'O' || ch == 'E')\n    return true;\n  return false;\n}\nbool isConst(char ch) {\n  if (isalpha(ch) && !isVowel(ch)) return true;\n  return false;\n}\nint toInt(string s) {\n  int sm;\n  stringstream ss(s);\n  ss >> sm;\n  return sm;\n}\nlong long int toLlint(string s) {\n  long long int sm;\n  stringstream ss(s);\n  ss >> sm;\n  return sm;\n}\nconst int N = int(2e6) + 15;\nint cmp(int *r, int a, int b, int l) {\n  return (r[a] == r[b]) && (r[a + l] == r[b + l]);\n}\nint wa[N], wb[N], wws[N], wv[N];\nint rnk[N], height[N];\nvoid DA(int *r, int *sa, int n, int m) {\n  int i, j, p, *x = wa, *y = wb, *t;\n  for (i = 0; i < m; i++) wws[i] = 0;\n  for (i = 0; i < n; i++) wws[x[i] = r[i]]++;\n  for (i = 1; i < m; i++) wws[i] += wws[i - 1];\n  for (i = n - 1; i >= 0; i--) sa[--wws[x[i]]] = i;\n  for (j = 1, p = 1; p < n; j *= 2, m = p) {\n    for (p = 0, i = n - j; i < n; i++) y[p++] = i;\n    for (i = 0; i < n; i++)\n      if (sa[i] >= j) y[p++] = sa[i] - j;\n    for (i = 0; i < n; i++) wv[i] = x[y[i]];\n    for (i = 0; i < m; i++) wws[i] = 0;\n    for (i = 0; i < n; i++) wws[wv[i]]++;\n    for (i = 1; i < m; i++) wws[i] += wws[i - 1];\n    for (i = n - 1; i >= 0; i--) sa[--wws[wv[i]]] = y[i];\n    for (t = x, x = y, y = t, p = 1, x[sa[0]] = 0, i = 1; i < n; i++)\n      x[sa[i]] = cmp(y, sa[i - 1], sa[i], j) ? p - 1 : p++;\n  }\n}\nvoid calheight(int *r, int *sa, int n) {\n  int i, j, k = 0;\n  for (i = 1; i <= n; i++) rnk[sa[i]] = i;\n  for (i = 0; i < n; height[rnk[i++]] = k)\n    for (k ? k-- : 0, j = sa[rnk[i] - 1]; r[i + k] == r[j + k]; k++)\n      ;\n}\nint sa[N], data[N], n;\nvoid Deal() {\n  DA(data, sa, n + 1, 128);\n  calheight(data, sa, n);\n}\nchar s[2000002];\nint Len;\nstruct z {\n  int opn, cls;\n};\nz Tree[2000002 * 4];\nvoid Update(int id, int l, int r, int pos) {\n  if (l == r) {\n    if (s[pos] == '(') {\n      Tree[id].opn = 1;\n    } else\n      Tree[id].cls = 1;\n    return;\n  }\n  int mid = (l + r) / 2;\n  int lft = 2 * id;\n  int rgt = lft + 1;\n  if (pos <= mid) {\n    Update(lft, l, mid, pos);\n  } else {\n    Update(rgt, mid + 1, r, pos);\n  }\n  int mn = min(Tree[lft].opn, Tree[rgt].cls);\n  Tree[id].cls = Tree[lft].cls + Tree[rgt].cls - mn;\n  Tree[id].opn = Tree[rgt].opn + Tree[lft].opn - mn;\n  return;\n}\nz Query(int id, int l, int r, int st, int ed) {\n  if (st <= l && ed >= r) {\n    return Tree[id];\n  }\n  int mid = (l + r) / 2;\n  int lft = 2 * id;\n  int rgt = lft + 1;\n  if (ed <= mid) {\n    return Query(lft, l, mid, st, ed);\n  } else if (st > mid) {\n    return Query(rgt, mid + 1, r, st, ed);\n  } else {\n    z a, b, c;\n    a = Query(lft, l, mid, st, ed);\n    b = Query(rgt, mid + 1, r, st, ed);\n    int mn = min(a.opn, b.cls);\n    c.cls = a.cls + b.cls - mn;\n    c.opn = b.opn + a.opn - mn;\n    return c;\n  }\n}\nint dp[2000002], Close[2000002], len, dp1[2000002];\nvoid Solve() {\n  int Last = -1, Last1 = -1;\n  for (int i = Len + 1 - 1; i >= 1; i--) {\n    if (s[i] == ')')\n      Last = -1;\n    else if (Last == -1) {\n      Last = i;\n    }\n    dp[i] = (Last == -1 ? 0 : (Last - i + 1));\n    if (s[i] == '(')\n      Last1 = -1;\n    else if (Last1 == -1) {\n      Last1 = i;\n    }\n    dp1[i] = (Last1 == -1 ? 0 : (Last1 - i + 1));\n  }\n}\nint A[4 * 2000002];\nvoid Update(int id, int l, int r, int pos, int val) {\n  if (l == r) {\n    A[id] = height[pos];\n    return;\n  }\n  int mid = (l + r) / 2;\n  int lft = 2 * id;\n  int rgt = lft + 1;\n  if (pos <= mid) {\n    Update(lft, l, mid, pos, val);\n  } else {\n    Update(rgt, mid + 1, r, pos, val);\n  }\n  A[id] = min(A[lft], A[rgt]);\n  return;\n}\nint Lcp(int id, int l, int r, int st, int ed) {\n  if (st <= l && ed >= r) {\n    return A[id];\n  }\n  int mid = (l + r) / 2;\n  int lft = 2 * id;\n  int rgt = lft + 1;\n  if (ed <= mid) {\n    return Lcp(lft, l, mid, st, ed);\n  } else if (st > mid) {\n    return Lcp(rgt, mid + 1, r, st, ed);\n  } else {\n    int a, b;\n    a = Lcp(lft, l, mid, st, ed);\n    b = Lcp(rgt, mid + 1, r, st, ed);\n    return min(a, b);\n  }\n}\nint HandleJhamela(int id, int id1, int Opn, int mx) {\n  int Suru = id + min(len, dp[id]), Suru1 = id1 + min(len, dp[id1]);\n  int Rnk = rnk[Suru - 1], Rnk1 = rnk[Suru1 - 1];\n  int L1 = len + mx - Opn - Close[id], L2 = len + mx - Opn - Close[id1];\n  int f = 0;\n  if (Rnk > Rnk1) swap(Rnk, Rnk1), f = 1;\n  int lcp = Lcp(1, 1, n, Rnk + 1, Rnk1);\n  if (f) swap(Rnk, Rnk1);\n  if (lcp >= min(L1, L2)) {\n    int diff = abs(L2 - L1);\n    if (L1 < L2) {\n      if (dp1[id1 + min(len, dp[id1]) + lcp] < diff)\n        return id1;\n      else\n        return id;\n    } else {\n      if (dp1[id + min(len, dp[id]) + lcp] < diff)\n        return id;\n      else\n        return id1;\n    }\n  } else {\n    if (Rnk < Rnk1)\n      return id;\n    else\n      return id1;\n  }\n}\nint main() {\n  n = 0;\n  scanf(\"%s\", &s);\n  len = strlen(s);\n  for (int i = len + 1 - 1; i >= 1; i--) s[i] = s[i - 1];\n  Len = len * 2;\n  for (int i = len + 1; i < Len + 1; i++) s[i] = s[i - len];\n  Solve();\n  for (int i = 1; i < Len + 1; i++) {\n    Update(1, 1, Len, i);\n    data[n] = (int)s[i];\n    n++;\n  }\n  data[n] = 0;\n  Deal();\n  for (int i = 1; i < n; i++) Update(1, 1, n, i, height[i]);\n  int mx = (1 << 28), Open = 0, Id = 0;\n  for (int i = 1; i < len + 1; i++) {\n    z ans = Query(1, 1, Len, i, (i + len - 1));\n    int Cst = ans.cls + ans.opn;\n    Close[i] = ans.opn;\n    int CntOpn = ans.cls + (min(len, dp[i]));\n    if (mx > Cst) {\n      mx = Cst;\n      Open = CntOpn;\n      Id = i;\n    } else if (mx == Cst && CntOpn > Open) {\n      Open = CntOpn;\n      Id = i;\n    } else if (mx == Cst && CntOpn == Open) {\n      Id = HandleJhamela(Id, i, CntOpn, mx);\n    }\n  }\n  for (int i = 0; i < Open; i++) {\n    printf(\"(\");\n  }\n  int baki = len + mx - Open - Close[Id];\n  int St = Id + dp[Id];\n  for (int i = 0; i < baki; i++) {\n    printf(\"%c\", s[St + i]);\n  }\n  for (int i = 0; i < Close[Id]; i++) {\n    printf(\")\");\n  }\n  printf(\"\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing std::bitset;\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::make_pair;\nusing std::map;\nusing std::pair;\nusing std::priority_queue;\nusing std::queue;\nusing std::set;\nusing std::string;\nusing std::stringstream;\nusing std::vector;\nclass MyTimer {\n public:\n  void reset() {}\n  void report() {}\n} myTimer;\ntemplate <typename A, typename B>\nstd::ostream &operator<<(std::ostream &cout, const pair<A, B> &x) {\n  return cout << \"(\" << x.first << \", \" << x.second << \")\";\n}\ntemplate <typename T1, typename T2>\ninline bool chmin(T1 &a, const T2 &b) {\n  return a > b ? a = b, true : false;\n}\ntemplate <typename T1, typename T2>\ninline bool chmax(T1 &a, const T2 &b) {\n  return a < b ? a = b, true : false;\n}\nconst int maxN = 2000000 + 233;\nint n;\nint a[maxN], s[maxN], pmin[maxN];\nvoid initialize() {\n  static char str[maxN];\n  scanf(\"%s\", str + 1);\n  n = strlen(str + 1);\n  for (int i = 1; i <= n; ++i) a[i] = (str[i] == '(' ? 1 : -1);\n  for (int i = n + 1; i <= 2 * n; ++i) a[i] = a[i - n];\n  s[0] = 0;\n  for (int i = 1; i <= 2 * n; ++i) s[i] = s[i - 1] + a[i];\n  static int q[maxN];\n  int f = 1, r = 0;\n  q[r = 1] = 0;\n  for (int i = 1; i <= n * 2; ++i) {\n    while (f <= r && s[q[r]] >= s[i]) --r;\n    q[++r] = i;\n    while (q[f] < i - n) ++f;\n    pmin[i] = s[q[f]];\n  }\n  for (int i = 1; i <= n; ++i) pmin[i] = pmin[i + n - 1] - s[i - 1];\n  ;\n  ;\n}\nint buc[maxN * 2], cub[maxN * 2], c[maxN];\nint sa[maxN], rk[maxN], h[maxN];\nvoid get_sa(int m) {\n  int n = ::n * 2;\n  memset(buc, -1, sizeof(buc));\n  memset(cub, -1, sizeof(cub));\n  int *x = buc, *y = cub;\n  for (int i = 0; i < m; ++i) c[i] = 0;\n  for (int i = 0; i < n; ++i) c[x[i] = (a[i + 1] == -1 ? '0' : '1')]++;\n  for (int i = 1; i < m; ++i) c[i] += c[i - 1];\n  for (int i = n - 1; i >= 0; --i) sa[--c[x[i]]] = i;\n  for (int k = 1; k <= n; k <<= 1) {\n    int p = 0;\n    for (int i = n - k; i < n; ++i) y[p++] = i;\n    for (int i = 0; i < n; ++i)\n      if (sa[i] >= k) y[p++] = sa[i] - k;\n    for (int i = 0; i < m; ++i) c[i] = 0;\n    for (int i = 0; i < n; ++i) c[x[i]]++;\n    for (int i = 1; i < m; ++i) c[i] += c[i - 1];\n    for (int i = n - 1; i >= 0; --i) sa[--c[x[y[i]]]] = y[i];\n    std::swap(x, y);\n    x[sa[0]] = 0;\n    p = 1;\n    for (int i = 1; i < n; ++i) {\n      x[sa[i]] = y[sa[i]] == y[sa[i - 1]] && y[sa[i] + k] == y[sa[i - 1] + k]\n                     ? p - 1\n                     : p++;\n    }\n    if (p == n) break;\n    m = p;\n  }\n  for (int i = 0; i < n; ++i) rk[i] = x[i];\n}\nvoid solve() {\n  get_sa(100);\n  int best = 1;\n  for (int i = 2; i <= n; ++i) {\n    if (pmin[best] < pmin[i])\n      best = i;\n    else if (pmin[best] == pmin[i]) {\n      if (rk[best - 1] < rk[i - 1]) best = i;\n    }\n  }\n  for (int i = 0; i < -pmin[best]; ++i) putchar('(');\n  for (int i = best; i < best + n; ++i) putchar(a[i] == -1 ? ')' : '(');\n  for (int i = 0; i < s[n] - pmin[best]; ++i) putchar(')');\n  putchar(10);\n}\nint main() {\n  initialize();\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int NMax = 2000010;\nchar A[NMax];\nint N, can[NMax], H[NMax], min1[NMax], min2[NMax], H1[NMax];\nint main() {\n  scanf(\"%s\", A);\n  N = strlen(A);\n  int last = 0;\n  for (int i = 0; i < N; i++) A[N + i] = A[i];\n  for (int i = 0; i < N; i++) {\n    if (A[i] == '(')\n      H[i] = last + 1;\n    else\n      H[i] = last - 1;\n    last = H[i];\n  }\n  min1[0] = H[0];\n  for (int i = 1; i < N; i++) min1[i] = min(min1[i - 1], H[i]);\n  min2[N - 1] = H[N - 1];\n  for (int i = N - 2; i >= 0; i--) min2[i] = min(min2[i + 1], H[i]);\n  for (int i = 0; i < N; i++)\n    if (A[i] == '(') {\n      int flag = 1;\n      int delta = -1;\n      if (A[i] == '(') delta = 1;\n      if (min2[i] - H[i] + delta < 0) flag = 0;\n      if (i > 0 && min1[i - 1] + H[N - 1] - H[i] + delta < 0) flag = 0;\n      if (H[N - 1] > 0) can[i] = flag;\n    }\n  for (int i = 0; i < N; i++)\n    if (H[N - 1] == 0) can[i] = 1;\n  last = 0;\n  for (int i = N - 1; i >= 0; i--) {\n    if (A[i] == ')')\n      H1[N - i - 1] = last + 1;\n    else\n      H1[N - i - 1] = last - 1;\n    last = H1[N - i - 1];\n  }\n  min1[0] = H1[0];\n  for (int i = 1; i < N; i++) min1[i] = min(min1[i - 1], H1[i]);\n  min2[N - 1] = H1[N - 1];\n  for (int i = N - 2; i >= 0; i--) min2[i] = min(min2[i + 1], H1[i]);\n  for (int i = 0; i < N; i++)\n    if (A[N - i - 1] == ')') {\n      int flag = 1;\n      int delta = -1;\n      if (A[N - i - 1] == ')') delta = 1;\n      if (min2[i] - H1[i] + delta < 0) flag = 0;\n      if (i > 0 && min1[i - 1] + H1[N - 1] - H1[i] + delta < 0) flag = 0;\n      if (H[N - 1] < 0) can[(N - (i - 1 + N) % N - 1 + N) % N] = flag;\n    }\n  for (int i = 0; i < N; i++) can[i + N] = can[i];\n  int p1 = 0, p2 = 1, pos = -1;\n  while (p1 < 2 * N && !can[p1]) p1 = p1 + 1;\n  p2 = p1 + 1;\n  while (p2 < 2 * N && !can[p2]) p2 = p2 + 1;\n  while (p1 < N && p2 < N) {\n    if (A[p2] > A[p1]) {\n      p2 = p2 + 1;\n      while (p2 < 2 * N && !can[p2]) p2 = p2 + 1;\n    } else if (A[p2] < A[p1]) {\n      p1 = p2;\n      p2 = p2 + 1;\n      while (p2 < 2 * N && !can[p2]) p2 = p2 + 1;\n    } else {\n      int k = 1;\n      while (k < 2 * N && A[p1 + k] == A[p2 + k]) k++;\n      if (A[p1 + k] > A[p2 + k]) {\n        p1 = p1 + k + 1;\n        while (p1 < 2 * N && !can[p1]) p1 = p1 + 1;\n      } else {\n        p2 = p2 + k + 1;\n        while (p2 < 2 * N && !can[p2]) p2 = p2 + 1;\n      }\n    }\n    if (p1 == p2) {\n      p2 = p1 + 1;\n      while (p2 < 2 * N && !can[p2]) p2 = p2 + 1;\n    } else if (p1 > p2)\n      swap(p1, p2);\n  }\n  pos = p2;\n  if (p1 < p2) pos = p1;\n  if (pos >= N) pos -= N;\n  if (H[N - 1] > 0) {\n    printf(\"%c\", A[pos]);\n    for (int i = (pos + 1) % N; i != pos; i = (i + 1) % N) printf(\"%c\", A[i]);\n    while (H[N - 1]--) printf(\")\");\n  } else {\n    while (H[N - 1]++) printf(\"(\");\n    printf(\"%c\", A[pos]);\n    for (int i = (pos + 1) % N; i != pos; i = (i + 1) % N) printf(\"%c\", A[i]);\n  }\n  puts(\"\");\n  getchar();\n  getchar();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2000005;\nint n, s[N], L[N];\nchar str[N], res[N];\nint sa[N], t1[N], t2[N], c[N];\nvoid buildsa(char *s, int n, int m) {\n  int i, k, p, a1, a2, *x = t1, *y = t2;\n  memset(c, 0, m << 2);\n  for (i = 0; i < n; ++i) ++c[x[i] = s[i]];\n  for (i = 1; i < m; ++i) c[i] += c[i - 1];\n  for (i = n - 1; i >= 0; --i) sa[--c[x[i]]] = i;\n  for (k = 1; k < n; k <<= 1) {\n    p = 0;\n    for (i = 0; i < n; ++i) y[p++] = (sa[i] + n - k) % n;\n    memset(c, 0, m << 2);\n    for (i = 0; i < n; ++i) ++c[x[y[i]]];\n    for (i = 1; i < m; ++i) c[i] += c[i - 1];\n    for (i = n - 1; i >= 0; --i) sa[--c[x[y[i]]]] = y[i];\n    swap(x, y), p = 1, x[sa[0]] = 0;\n    for (i = 1; i < n; ++i) {\n      a1 = y[(sa[i - 1] + k) % n];\n      a2 = y[(sa[i] + k) % n];\n      x[sa[i]] = (a1 == a2 && y[sa[i - 1]] == y[sa[i]]) ? p - 1 : p++;\n    }\n    if (p >= n) break;\n    m = p;\n  }\n}\nint Q[N], top, bot;\nint m;\nvoid work() {\n  int i, j, y;\n  char c;\n  while (c = getchar(), ~c && c != '\\n') str[n++] = c;\n  for (i = n; i < n + n; ++i) str[i] = str[i - n];\n  for (i = 0; i < n + n; ++i) s[i + 1] = s[i] + (str[i] == '(' ? 1 : -1);\n  m = n;\n  buildsa(str, m, 128);\n  top = 0, bot = -1;\n  for (i = 1; i <= n + n; ++i) {\n    while (top <= bot && Q[top] < i - n + 1) ++top;\n    while (top <= bot && s[i] <= s[Q[bot]]) --bot;\n    Q[++bot] = i;\n    if (i >= n) L[i - n] = s[Q[top]];\n  }\n  y = min(s[n], 0);\n  for (i = 0; i < m; ++i) {\n    j = sa[i];\n    if (j >= n) continue;\n    if (L[j] >= s[j] + y) break;\n  }\n  m = 0;\n  for (i = 0; i < -s[n]; ++i) res[m++] = '(';\n  for (i = 0; i < n; ++i) res[m++] = str[i + j];\n  for (i = 0; i < s[n]; ++i) res[m++] = ')';\n  puts(res);\n}\nint main() {\n  work();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e6 + 100;\nint na[N], nb[N], ns[N], nv[N];\nint sa[N], he[N], rk[N];\nint cmp(int *r, int a, int b, int l) {\n  return r[a] == r[b] && r[a + l] == r[b + l];\n}\nvoid _sort(int x[N], int y[N], int n, int m) {\n  for (int i = 0; i < m; i++) ns[i] = 0;\n  for (int i = 0; i < n; i++) ns[x[y[i]]]++;\n  for (int i = 1; i < m; i++) ns[i] += ns[i - 1];\n  for (int i = n - 1; i >= 0; i--) {\n    sa[--ns[x[y[i]]]] = y[i];\n  }\n}\nvoid da(int *r, int n, int m) {\n  int *x = na, *y = nb;\n  for (int i = 0; i < n; i++) x[i] = r[i];\n  for (int i = 0; i < n; i++) y[i] = i;\n  _sort(x, y, n, m);\n  for (int j = 1, p = 1, i; p < n; j *= 2, m = p) {\n    for (p = 0, i = n - j; i < n; i++) y[p++] = i;\n    for (i = 0; i < n; i++)\n      if (sa[i] >= j) y[p++] = sa[i] - j;\n    for (i = 0; i < n; i++) nv[i] = x[y[i]];\n    for (i = 0; i < m; i++) ns[i] = 0;\n    for (i = 0; i < n; i++) ns[nv[i]]++;\n    for (i = 1; i < m; i++) ns[i] += ns[i - 1];\n    for (i = n - 1; i >= 0; i--) sa[--ns[nv[i]]] = y[i];\n    swap(x, y);\n    p = 1;\n    x[sa[0]] = 0;\n    for (i = 1; i < n; i++) {\n      x[sa[i]] = cmp(y, sa[i - 1], sa[i], j) ? p - 1 : p++;\n    }\n  }\n}\nvoid gethe(int *r, int n) {\n  for (int i = 1; i <= n; i++) rk[sa[i]] = i;\n  for (int i = 0, k = 0, j = 0; i < n; he[rk[i++]] = k) {\n    for (k ? k-- : 0, j = sa[rk[i] - 1]; r[i + k] == r[j + k]; k++)\n      ;\n  }\n}\nvoid debug(int n) {\n  for (int i = 0; i <= n; i++) printf(\"%d \", rk[i]);\n  printf(\"rk\\n\");\n  for (int i = 0; i <= n; i++) printf(\"%d \", sa[i]);\n  printf(\"sa\\n\");\n  for (int i = 0; i <= n; i++) printf(\"%d \", he[i]);\n  printf(\"he\\n\");\n}\nvoid solve(int *r, int n) {\n  r[n] = 0;\n  da(r, n + 1, 3);\n  gethe(r, n);\n}\nint l, r, sta[N];\nint aa[N], bb[N];\nvoid ins(int id) {\n  while (r > l && aa[sta[r - 1]] >= aa[id]) r--;\n  sta[r++] = id;\n}\nchar ss[N];\nint vis[N];\nint main() {\n  while (scanf(\"%s\", ss) != EOF) {\n    int n = strlen(ss);\n    int num = 0;\n    for (int i = 0; i < n; i++) {\n      if (ss[i] == '(') {\n        aa[i] = 1;\n        bb[i] = 1;\n        num++;\n      } else {\n        aa[i] = -1;\n        bb[i] = 2;\n        num--;\n      }\n    }\n    for (int i = 0; i < n; i++) {\n      aa[i + n] = aa[i];\n      bb[i + n] = bb[i];\n    }\n    for (int i = 1; i < 2 * n; i++) {\n      aa[i] += aa[i - 1];\n    }\n    memset(vis, 0, sizeof(vis));\n    l = r = 0;\n    for (int i = 0; i < n; i++) {\n      ins(i);\n    }\n    for (int i = 0; i < n; i++) {\n      if (sta[l] < i) l++;\n      int x = aa[sta[l]];\n      if (i) x -= aa[i - 1];\n      if (num < 0) {\n        x += -num;\n      }\n      if (x >= 0) {\n        vis[i] = 1;\n      }\n      ins(i + n);\n    }\n    solve(bb, n * 2);\n    int id = -1;\n    for (int i = 0; i < n; i++)\n      if (vis[i]) {\n        if (id == -1 || rk[i] < rk[id]) {\n          id = i;\n        }\n      }\n    if (id == -1) {\n      printf(\"x\\n\");\n      continue;\n    }\n    for (int i = 0; i < -num; i++) {\n      printf(\"(\");\n    }\n    for (int i = 0; i < n; i++) {\n      printf(\"%c\", ss[id]);\n      id++;\n      if (id == n) id = 0;\n    }\n    for (int i = 0; i < num; i++) {\n      printf(\")\");\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 3;\nconst int M = 4e6 + 3;\nconst int oo = 1e9;\nconst int OS = 317;\nconst int MOD = 1e9 + 7;\nchar s[N];\nint n, stp[M], p1[N], p2[N], s1[N], s2[N], ho[N], hz[N], h[N], op[N], zp[N],\n    os[N], zs[N], il[N], ir[N];\nvector<int> st;\nint get(int i, int ln) {\n  int ans, l1, l, r, ym;\n  l1 = min(il[i], ln);\n  ym = 2 * n;\n  ans = (stp[ym] * 1LL * ho[l1]) % MOD;\n  if (ln - l1 > 0) {\n    l = i + 1;\n    r = l + min(n - i, ln - l1) - 1;\n    ans = (ans + (((h[r] - h[l - 1]) % MOD + MOD) % MOD) * 1LL *\n                     stp[ym + l1 - (l - 1)] % MOD) %\n          MOD;\n    l1 += r - l + 1;\n    if (ln - l1 > 0) {\n      r = min(i, ln - l1);\n      ans = (ans + h[r] * 1LL * stp[ym + l1] % MOD) % MOD;\n      l1 += r;\n      if (ln - l1 > 0) {\n        r = ln - l1;\n        ans = (ans + hz[r] * 1LL * stp[ym + l1] % MOD) % MOD;\n      }\n    }\n  }\n  return ans;\n}\nint get_ch(int i, int ln) {\n  if (ln <= il[i]) return '(';\n  ln -= il[i];\n  if (ln <= n - i) return s[i + ln];\n  ln -= n - i;\n  if (ln <= i)\n    return s[ln];\n  else\n    return ')';\n}\nint ans;\nbool cmp(int i, int j) {\n  int l, r, x;\n  l = 1, r = ans;\n  while (l <= r) {\n    x = (l + r) >> 1;\n    if (get(i, x) == get(j, x))\n      l = x + 1;\n    else\n      r = x - 1;\n  }\n  if (r + 1 > ans) return true;\n  return get_ch(i, r + 1) <= get_ch(j, r + 1);\n}\nint main() {\n  if (0) {\n    freopen(\"input.txt\", \"w\", stdout);\n    int n = 1e6;\n    for (int i = 0; i < n; ++i) printf(\"(\");\n    printf(\"\\n\");\n    return 0;\n  }\n  int i, j, len, mn;\n  gets(s + 1);\n  n = strlen(s + 1);\n  for (i = 1; i <= n; ++i)\n    if (s[i] == '(')\n      p1[i] = p1[i - 1], p2[i] = p2[i - 1] + 1;\n    else if (p2[i - 1])\n      p1[i] = p1[i - 1] + 2, p2[i] = p2[i - 1] - 1;\n    else\n      p1[i] = p1[i - 1], p2[i] = p2[i - 1];\n  for (i = n; i; --i)\n    if (s[i] == ')')\n      s1[i] = s1[i + 1], s2[i] = s2[i + 1] + 1;\n    else if (s2[i + 1])\n      s1[i] = s1[i + 1] + 2, s2[i] = s2[i + 1] - 1;\n    else\n      s1[i] = s1[i + 1], s2[i] = s2[i + 1];\n  for (i = 0; i <= n; ++i) {\n    op[i] = p2[i];\n    zp[i] = i - p1[i] - op[i];\n    zs[i] = s2[i + 1];\n    os[i] = n - i - s1[i + 1] - zs[i];\n    il[i] = zs[i];\n    ir[i] = op[i];\n    if (os[i] > zp[i])\n      ir[i] += os[i] - zp[i];\n    else\n      il[i] += zp[i] - os[i];\n  }\n  ans = oo;\n  for (i = 0; i < n; ++i) {\n    len = n + zs[i] + op[i] + max(os[i], zp[i]) - min(os[i], zp[i]);\n    if (ans > len) st.clear();\n    if (ans >= len) ans = len, st.push_back(i);\n  }\n  stp[0] = 1;\n  for (i = 1; i < M; ++i) stp[i] = (stp[i - 1] * 1LL * OS) % MOD;\n  ho[0] = hz[0] = 0;\n  for (i = 1; i < N; ++i)\n    ho[i] = (ho[i - 1] + '(' * 1LL * stp[i - 1] % MOD) % MOD;\n  for (i = 1; i < N; ++i)\n    hz[i] = (hz[i - 1] + ')' * 1LL * stp[i - 1] % MOD) % MOD;\n  h[0] = 0;\n  for (i = 1; i <= n; ++i)\n    h[i] = (h[i - 1] + s[i] * 1LL * stp[i - 1] % MOD) % MOD;\n  mn = st[0];\n  for (i = 1; i < st.size(); ++i)\n    if (cmp(st[i], mn)) mn = st[i];\n  i = mn;\n  for (j = 0; j < il[i]; ++j) putchar('(');\n  for (j = i + 1; j <= n; ++j) putchar(s[j]);\n  for (j = 1; j <= i; ++j) putchar(s[j]);\n  for (j = 0; j < ir[i]; ++j) putchar(')');\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class A {\n\tFastScanner in;\n\tPrintWriter out;\n\n\tfinal int mod = (int) 1e9 + 7;\n\tfinal int mul = 239;\n\tint[] hash;\n\tint[] pow;\n\n\tint getHash(int from, int to) {\n\t\tlong res = hash[to + 1] - hash[from] * 1L * pow[to - from + 1];\n\t\tres %= mod;\n\t\tif (res < 0) {\n\t\t\tres += mod;\n\t\t}\n\t\treturn (int) res;\n\t}\n\n\tboolean less(int fr1, int fr2, int n) {\n\t\tint l = 0, r = n + 1;\n\t\twhile (r - l > 1) {\n\t\t\tint m = (l + r) >> 1;\n\t\t\tif (getHash(fr1, fr1 + m - 1) == getHash(fr2, fr2 + m - 1)) {\n\t\t\t\tl = m;\n\t\t\t} else {\n\t\t\t\tr = m;\n\t\t\t}\n\t\t}\n\t\tif (l == n) {\n\t\t\treturn false;\n\t\t}\n\t\treturn s.charAt(fr1 + l) < s.charAt(fr2 + l);\n\t}\n\n\tString s;\n\n\tvoid solve() {\n\t\ts = in.next();\n\t\tint n = s.length();\n\t\ts = s + s;\n\t\thash = new int[s.length() + 1];\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\thash[i + 1] = (int) ((hash[i] * 1L * mul + s.charAt(i)) % mod);\n\t\t}\n\t\tpow = new int[n + n + 2];\n\t\tpow[0] = 1;\n\t\tfor (int i = 1; i < pow.length; i++) {\n\t\t\tpow[i] = (int) ((pow[i - 1] * 1L * mul) % mod);\n\t\t}\n\t\tint[] bal = new int[n + n - 1];\n\t\tfor (int i = 0; i < n + n - 1; i++) {\n\t\t\tif (s.charAt(i) == '(') {\n\t\t\t\tbal[i]++;\n\t\t\t} else {\n\t\t\t\tbal[i]--;\n\t\t\t}\n\t\t\tif (i > 0) {\n\t\t\t\tbal[i] += bal[i - 1];\n\t\t\t}\n\t\t}\n\t\tint cur = s.length() - 1;\n\t\tint[] balanceChange = new int[n];\n\t\tint[] qPos = new int[n + n];\n\t\tint[] qValue = new int[n + n];\n\t\tint qSz = 0, qFrom = 0;\n\t\tfor (int pos = n - 1; pos >= 0; pos--) {\n\t\t\twhile (cur != pos) {\n\t\t\t\tcur--;\n\t\t\t\tint value = bal[cur];\n\t\t\t\twhile (qSz > qFrom && qValue[qSz - 1] >= value) {\n\t\t\t\t\tqSz--;\n\t\t\t\t}\n\t\t\t\tqValue[qSz] = value;\n\t\t\t\tqPos[qSz] = cur;\nqSz++;\n\t\t\t}\n\t\t\twhile (qPos[qFrom] >= pos + n) {\n\t\t\t\tqFrom++;\n\t\t\t}\n\t\t\tint prevBalance = pos > 0 ? bal[pos - 1] : 0;\n\t\t\tbalanceChange[pos] = qValue[qFrom] - prevBalance;\n\t\t}\n\t\tint cntOpen = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (s.charAt(i) == '(') {\n\t\t\t\tcntOpen++;\n\t\t\t} else {\n\t\t\t\tcntOpen--;\n\t\t\t}\n\t\t}\n\t\tint maxBalanceChange = 0;\n\t\tif (cntOpen < 0) {\n\t\t\tmaxBalanceChange = cntOpen;\n\t\t}\n\t\tint bestCandidate = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (balanceChange[i] >= maxBalanceChange) {\n\t\t\t\tif (bestCandidate != -1) {\n\t\t\t\t\tif (!less(i, bestCandidate, n)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbestCandidate = i;\n\t\t\t}\n\t\t}\n\t\tif (bestCandidate < 0) {\n\t\t\tthrow new AssertionError();\n\t\t}\n\t\tfor (int i = 0; i < -cntOpen; i++) {\n\t\t\tout.print(\"(\");\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tout.print(s.charAt(i + bestCandidate));\n\t\t}\n\t\tfor (int i = 0; i < cntOpen; i++) {\n\t\t\tout.print(\")\");\n\t\t}\n\t}\n\n\tvoid run() {\n\t\ttry {\n\t\t\tin = new FastScanner(new File(\"A.in\"));\n\t\t\tout = new PrintWriter(new File(\"A.out\"));\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (FileNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tvoid runIO() {\n\n\t\tin = new FastScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\n\t\tout.close();\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner(File f) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(f));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic FastScanner(InputStream f) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(f));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\tString s = null;\n\t\t\t\ttry {\n\t\t\t\t\ts = br.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (s == null)\n\t\t\t\t\treturn null;\n\t\t\t\tst = new StringTokenizer(s);\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tboolean hasMoreTokens() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\tString s = null;\n\t\t\t\ttry {\n\t\t\t\t\ts = br.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (s == null)\n\t\t\t\t\treturn false;\n\t\t\t\tst = new StringTokenizer(s);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew A().runIO();\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:66777216\")\nusing namespace std;\nstatic unsigned rnd() {\n  static int second = 124612741;\n  second ^= second << 13;\n  second ^= second >> 17;\n  return second ^= second << 5;\n}\ninline int fpow(int a, int st, int mod) {\n  int ans = 1;\n  while (st) {\n    if (st % 2) ans = (long long)ans * a % mod;\n    a = (long long)a * a % mod;\n    st /= 2;\n  }\n  return ans;\n}\nint invmod(int first, int second) {\n  int a = 1, b = 0, k;\n  for (; second; swap(first, second), swap(a, b)) {\n    k = first / second;\n    first -= second * k;\n    a -= b * k;\n  }\n  return a + max(b, 0);\n}\nstruct Hash {\n  Hash() : x1(0), x2(0) {}\n  Hash(const int& x1, const int& x2) : x1(x1), x2(x2) {}\n  int x1, x2;\n  static int mod1, mod2;\n  static int p1, p2;\n  static int invp1, invp2;\n  static bool initCalled;\n  static const Hash ONE, ZERO, INVALID;\n  static Hash UNIT, INV_UNIT;\n  static bool prime(int a) {\n    if (a == 1) return 0;\n    for (int i = 2; i * i <= a; ++i) {\n      if (a % i == 0) return false;\n    }\n    return true;\n  }\n  static void init() {\n    if (initCalled) return;\n    initCalled = true;\n    mod1 = 1000000000 + rnd() % 10000000;\n    while (!prime(mod1)) ++mod1;\n    mod2 = 1000000000 + rnd() % 10000000;\n    while (mod2 == mod1 || !prime(mod2)) ++mod2;\n    invp1 = fpow(p1, mod1 - 2, mod1);\n    invp2 = fpow(p2, mod2 - 2, mod2);\n    INV_UNIT = Hash(invp1, invp2);\n  }\n  inline Hash& operator+=(const Hash& other) {\n    x1 += other.x1;\n    x1 -= (((x1 - mod1) >> 31) + 1) * mod1;\n    x2 += other.x2;\n    x1 -= (((x1 - mod2) >> 31) + 1) * mod2;\n    return *this;\n  }\n  inline Hash& operator-=(const Hash& other) {\n    x1 -= other.x1;\n    x1 -= (x1 >> 31) * Hash::mod1;\n    x2 -= other.x2;\n    x2 -= (x2 >> 31) * Hash::mod2;\n    return *this;\n  }\n  inline Hash& operator*=(const Hash& other) {\n    x1 = (long long)x1 * other.x1 % Hash::mod1;\n    x2 = (long long)x2 * other.x2 % Hash::mod2;\n    return *this;\n  }\n  inline Hash& operator*=(const int& other) {\n    x1 = (long long)x1 * other % Hash::mod1;\n    x2 = (long long)x2 * other % Hash::mod2;\n    return *this;\n  }\n  inline Hash& operator^=(const int& power) {\n    int st = power;\n    Hash ans(1, 1);\n    while (st) {\n      if (st % 2) ans *= *this;\n      x1 = (long long)x1 * x1 % Hash::mod1;\n      x2 = (long long)x2 * x2 % Hash::mod2;\n      st /= 2;\n    }\n    return *this;\n  }\n  inline bool operator==(const Hash& other) const {\n    return x1 == other.x1 && x2 == other.x2;\n  }\n};\nbool Hash::initCalled = false;\nint Hash::mod1 = 0;\nint Hash::mod2 = 0;\nint Hash::p1 = 23561;\nint Hash::p2 = 10000019;\nint Hash::invp1 = -1;\nint Hash::invp2 = -1;\nconst Hash Hash::ONE(1, 1);\nconst Hash Hash::ZERO(0, 0);\nconst Hash Hash::INVALID(-1, -1);\nHash Hash::UNIT(Hash::p1, Hash::p2);\nHash Hash::INV_UNIT(-1, -1);\ninline Hash operator+(const Hash& a, const Hash& b) {\n  Hash ans(a.x1 + b.x1, a.x2 + b.x2);\n  ans.x1 -= (((ans.x1 - Hash::mod1) >> 31) + 1) * Hash::mod1;\n  ans.x2 -= (((ans.x2 - Hash::mod2) >> 31) + 1) * Hash::mod2;\n  return ans;\n}\ninline Hash operator-(const Hash& a, const Hash& b) {\n  Hash ans(a.x1 - b.x1, a.x2 - b.x2);\n  ans.x1 -= (ans.x1 >> 31) * Hash::mod1;\n  ans.x2 -= (ans.x2 >> 31) * Hash::mod2;\n  return ans;\n}\ninline Hash operator*(const Hash& a, const Hash& b) {\n  return Hash((long long)a.x1 * b.x1 % Hash::mod1,\n              (long long)a.x2 * b.x2 % Hash::mod2);\n}\ninline Hash operator*(const Hash& a, const int& b) {\n  return Hash((long long)a.x1 * b % Hash::mod1,\n              (long long)a.x2 * b % Hash::mod2);\n}\ninline Hash operator^(const Hash& a, const int& power) {\n  int st = power;\n  Hash ans(1, 1), cur(a);\n  while (st) {\n    if (st % 2) ans *= cur;\n    cur *= cur;\n    st /= 2;\n  }\n  return ans;\n}\ninline Hash fpow(const Hash& a, const int& power) { return a ^ power; }\ninline Hash invmod(const Hash& a) {\n  return Hash(invmod(a.x1, Hash::mod1), invmod(a.x2, Hash::mod2));\n}\ntemplate <class H>\nstruct HashString : public string {\n  HashString() : string() { precalc(0); }\n  HashString(const HashString& other) : string(other) { precalc(size()); }\n  HashString(HashString&& other)\n      : hh(std::move(other.hh)), string(std::move(other)) {\n    precalc(size());\n  }\n  HashString(const string& other) : string(other) {\n    precalc(size());\n    build();\n  }\n  HashString(string&& other) : string(std::move(other)) {\n    precalc(size());\n    build();\n  }\n  HashString(const char* other) : string(other) {\n    precalc(size());\n    build();\n  }\n  inline void clear() {\n    hh.clear();\n    string::clear();\n  }\n  inline static H getPow(int p) {\n    if (p < haveN) {\n      return pp[p];\n    } else {\n      return fpow(H::UNIT, p);\n    }\n  }\n  inline static H getInvPow(size_t p) {\n    if (p < invpp.size()) {\n      return invpp[p];\n    } else {\n      return fpow(H::INV_UNIT, p);\n    }\n  }\n  inline H getInvRegister(const H& p) const {\n    if (p == register_) {\n      return registerValue_;\n    } else {\n      register_ = p;\n      return registerValue_ = invmod(p);\n    }\n  }\n  static void precalc(int N = 0) {\n    Hash::init();\n    if (haveN >= N) return;\n    pp.resize(N);\n    invpp.resize(N);\n    if (!haveN) {\n      pp[0] = H::ONE;\n      invpp[0] = H::ONE;\n      haveN = 1;\n    }\n    for (int i = haveN; i < N; ++i) {\n      pp[i] = pp[i - 1] * H::UNIT;\n      invpp[i] = invpp[i - 1] * H::INV_UNIT;\n    }\n    haveN = N;\n  }\n  inline void build() {\n    int curSize = size();\n    if (haveN <= curSize) {\n      precalc(curSize);\n    }\n    for (int i = hh.size(); i < curSize; ++i) {\n      H pr = i ? hh.back() : H::ZERO;\n      hh.push_back(pr + getPow(i) * (*this)[i]);\n    }\n  }\n  inline H getHash(int pos, int len) const {\n    if (len <= 0) return H::ZERO;\n    const int S = size();\n    if (pos + len - 1 < S) {\n      H ans = hh[pos + len - 1];\n      if (pos) {\n        ans -= hh[pos - 1];\n        ans *= getInvPow(pos);\n      }\n      return ans;\n    } else {\n      H head = hh.back();\n      if (pos) {\n        head -= hh[pos - 1];\n        head *= getInvPow(pos);\n      }\n      int full = -1, en = -1;\n      H mid = H::ZERO;\n      int midlen = 0;\n      if (len <= S) {\n        en = pos + len - 1 - S;\n        H tail = hh[en];\n        full = 0;\n        return head + tail * getPow(S - pos);\n      } else {\n        en = (pos + len - 1) % S;\n        H tail = hh[en];\n        full = (len - (S - pos) - (en + 1)) / S;\n        mid = hh.back() * (H::ONE - getInvPow(full * S)) *\n              getInvRegister(H::ONE - getInvPow(S));\n        return head + mid * getPow(S - pos) + tail * getPow(len - (en + 1));\n      }\n    }\n  }\n  inline HashString& operator+=(const char& ch) {\n    string::operator+=(ch);\n    build();\n    return *this;\n  }\n  inline HashString& operator+=(const HashString& other) {\n    string::operator+=(other);\n    build();\n    return *this;\n  }\n  inline bool operator==(const HashString& other) const {\n    return hh.back() == other.hh.back();\n  }\n  inline bool operator<(const HashString& other) const {\n    int s1 = size();\n    int s2 = other.size();\n    const int S = min(s1, s2);\n    int l = 0, r = S + 1;\n    while (r - l > 1) {\n      int xx = (r + l) / 2;\n      if (getHash(0, xx) == other.getHash(0, xx))\n        l = xx;\n      else\n        r = xx;\n    }\n    char c1 = 0, c2 = 0;\n    if (l < s1) c1 = (*this)[l];\n    if (l < s2) c2 = other[l];\n    return c1 < c2;\n  }\n  inline bool operator<=(const HashString& other) const {\n    return (*this == other) || (*this < other);\n  }\n  inline bool operator>(const HashString& other) const {\n    return !(*this == other) && !(*this < other);\n  }\n  inline bool operator>=(const HashString& other) const {\n    return !(*this < other);\n  }\n  inline bool operator!=(const HashString& other) const {\n    return !(*this == other);\n  }\n  inline void reserve(int N) {\n    hh.reserve(N);\n    string::reserve(N);\n  }\n  vector<H> hh;\n  static vector<H> pp, invpp;\n\n private:\n  mutable H register_, registerValue_;\n  static int haveN;\n};\ntemplate <>\nint HashString<Hash>::haveN = 0;\ntemplate <>\nvector<Hash> HashString<Hash>::pp = vector<Hash>();\ntemplate <>\nvector<Hash> HashString<Hash>::invpp = vector<Hash>();\ntemplate <class H, bool cyclic = true>\nstruct HashStringPiece {\n  explicit HashStringPiece(const HashString<H>& s, int pos, int len)\n      : s(s), pos(pos), len(len), hash(H::INVALID) {}\n  inline H getHash() const {\n    if (hash == H::INVALID) hash = s.getHash(pos, len);\n    return hash;\n  }\n  inline H getPartialHash(int needLen) const { return s.getHash(pos, needLen); }\n  inline char getChar(int i) const {\n    i += pos;\n    const int S = s.size();\n    if (i < S) return s[i];\n    if (!cyclic) return 0;\n    i -= S;\n    if (i < S) return s[i];\n    return s[i % S];\n  }\n  const HashString<H>& s;\n  const int pos, len;\n  mutable H hash;\n};\ntemplate <class H, class T>\nchar getHSPRangeChar(T beg, T en, int pos) {\n  for (T it = beg; it != en; ++it) {\n    if (pos < it->len) {\n      return it->getChar(pos);\n    }\n    pos -= it->len;\n  }\n  return 0;\n}\ntemplate <class H, class T>\nH getHSPRangeHash(T beg, T en, int len) {\n  H ans = H::ZERO;\n  int cur = 0;\n  for (T it = beg; it != en; ++it) {\n    if (len >= it->len) {\n      ans += it->getHash() * it->s.getPow(cur);\n      cur += it->len;\n      len -= it->len;\n    } else {\n      ans += it->getPartialHash(len) * it->s.getPow(cur);\n      break;\n    }\n  }\n  return ans;\n}\nint TB, IT;\ntemplate <class H, class T>\ninline int compareHSPRanges(T beg1, T en1, int len1, T beg2, T en2, int len2) {\n  if (beg1 == en1 && beg2 == en2) return 0;\n  if (beg1 == en1) return -1;\n  if (beg2 == en2) return 1;\n  int l = 0, r = min(len1, len2) + 1;\n  while (r - l > 1) {\n    int xx = (r + l) / 2;\n    auto h1 = getHSPRangeHash<H, T>(beg1, en1, xx);\n    auto h2 = getHSPRangeHash<H, T>(beg2, en2, xx);\n    if (h1 == h2)\n      l = xx;\n    else\n      r = xx;\n  }\n  char c1 = getHSPRangeChar<H, T>(beg1, en1, l);\n  char c2 = getHSPRangeChar<H, T>(beg2, en2, l);\n  if (c1 < c2)\n    return -1;\n  else if (c1 == c2)\n    return 0;\n  else\n    return 1;\n}\ntemplate <class H, class T>\ninline int compareHSPRanges(T beg1, T en1, T beg2, T en2) {\n  int len1 = 0;\n  for (T it = beg1; it != en1; ++it) {\n    len1 += it->len;\n  }\n  int len2 = 0;\n  for (T it = beg2; it != en2; ++it) {\n    len2 += it->len;\n  }\n  return compareHSPRanges<H, T>(beg1, en1, len1, beg2, en2, len2);\n}\nint a, b, c, d, n, m, k;\nchar str[1000002];\nint bal[2000002];\nHashString<Hash> s;\ninline string build(pair<pair<int, int>, int> a) {\n  string ans = \"\";\n  for (int _n((a.first.first) - 1), i(0); i <= _n; i++) ans += '(';\n  for (int _n((n)-1), i(0); i <= _n; i++) {\n    int cur = a.second + i;\n    if (cur >= n) cur -= n;\n    ans += str[cur];\n  }\n  for (int _n((a.first.second) - 1), i(0); i <= _n; i++) ans += ')';\n  return ans;\n}\nHashString<Hash> op, cl;\ninline bool better(pair<pair<int, int>, int> a, pair<pair<int, int>, int> b,\n                   const HashString<Hash>& s) {\n  HashStringPiece<Hash> A[3] = {HashStringPiece<Hash>(op, 0, a.first.first),\n                                HashStringPiece<Hash>(s, a.second, n),\n                                HashStringPiece<Hash>(cl, 0, a.first.second)};\n  HashStringPiece<Hash> B[3] = {HashStringPiece<Hash>(op, 0, b.first.first),\n                                HashStringPiece<Hash>(s, b.second, n),\n                                HashStringPiece<Hash>(cl, 0, b.first.second)};\n  int t = compareHSPRanges<Hash>(A, A + 3, B, B + 3);\n  if (t == -1)\n    return 1;\n  else\n    return 0;\n}\nint main() {\n  gets(str);\n  n = (int)strlen(str);\n  HashString<Hash> s(str);\n  HashString<Hash>::precalc(2 * n + 1);\n  op.reserve(n + 1);\n  cl.reserve(n + 1);\n  for (int _n((n)-1), i(0); i <= _n; i++) {\n    op += '(';\n    cl += ')';\n  }\n  c = 0;\n  for (int _n((n)-1), i(0); i <= _n; i++) {\n    if (str[i] == '(')\n      ++c;\n    else\n      --c;\n  }\n  bal[0] = 0;\n  for (int _n((2 * n) - 1), i(0); i <= _n; i++) {\n    if (i) bal[i] = bal[i - 1];\n    int cur = i;\n    if (i >= n) cur = i - n;\n    if (str[cur] == '(')\n      ++bal[i];\n    else\n      --bal[i];\n  }\n  int blen = 1000000000;\n  pair<pair<int, int>, int> best = make_pair(make_pair(0, 0), 0);\n  stack<pair<int, int> > s1, s2;\n  for (int _n((n)-1), i(0); i <= _n; i++) {\n    int new_element = bal[i];\n    int minima = s1.empty() ? new_element : min(new_element, s1.top().second);\n    s1.push(make_pair(new_element, minima));\n  }\n  for (int _n((n)-1), cyc(0); cyc <= _n; cyc++) {\n    int current_minimum = -1000000000;\n    if (s1.empty() || s2.empty())\n      current_minimum = s1.empty() ? s2.top().second : s1.top().second;\n    else\n      current_minimum = min(s1.top().second, s2.top().second);\n    int p = 0;\n    if (cyc) p = bal[cyc - 1];\n    int mn = current_minimum - p;\n    int beg = max(0, -mn);\n    int en = c + beg;\n    int len = beg + en + n;\n    if (len < blen ||\n        (len == blen && better(make_pair(make_pair(beg, en), cyc), best, s))) {\n      blen = len;\n      best = make_pair(make_pair(beg, en), cyc);\n    }\n    if (s2.empty()) {\n      while (!s1.empty()) {\n        int element = s1.top().first;\n        s1.pop();\n        int minima = s2.empty() ? element : min(element, s2.top().second);\n        s2.push(make_pair(element, minima));\n      }\n    }\n    s2.pop();\n    int new_element = bal[cyc + n];\n    int minima = s1.empty() ? new_element : min(new_element, s1.top().second);\n    s1.push(make_pair(new_element, minima));\n  }\n  string ans = build(best);\n  printf(\"%s\\n\", ans.c_str());\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = (int)2e6 + 10;\nconst int inf = (int)1e9;\nconst int P[] = {(int)1e9 + 7, (int)1e9 + 9};\nconst int Q[] = {17, 239};\nint stp[2][maxn];\nint h[2][maxn];\nint h1[2][maxn];\nint h2[2][maxn];\nconst int sh = 1 << 21;\nint rm[2 * sh + 10];\nvoid upd(int first, int val) {\n  first += sh;\n  rm[first] = val;\n  while (first > 1) {\n    first /= 2;\n    rm[first] = min(rm[first * 2], rm[first * 2 + 1]);\n  }\n}\nint get_min(int l, int r) {\n  l += sh;\n  r += sh;\n  int ans = inf;\n  while (l <= r) {\n    ans = min(rm[l], ans);\n    ans = min(rm[r], ans);\n    l = (l + 1) / 2;\n    r = (r - 1) / 2;\n  }\n  return ans;\n}\nchar s[maxn];\nint n;\nint sum[maxn];\nvoid print(pair<int, pair<int, int> > ans) {\n  for (int j = 0; j < ans.first; j++) {\n    printf(\"(\");\n  }\n  for (int j = 0; j < n; j++) {\n    printf(\"%c\", s[ans.second.first + j]);\n  }\n  for (int j = 0; j < ans.second.second; j++) {\n    printf(\")\");\n  }\n  printf(\"\\n\");\n}\nint get_c(const pair<int, pair<int, int> >& a, int l) {\n  if (l < a.first) return -1;\n  if (l < a.first + n) {\n    return s[a.second.first + l - a.first] == '(' ? -1 : 1;\n  }\n  return 1;\n}\npair<int, int> get_hash(const pair<int, pair<int, int> >& a, int l) {\n  if (l <= a.first) {\n    return make_pair(h1[0][l], h1[1][l]);\n  }\n  if (l <= a.first + n) {\n    int l2 = l - a.first;\n    pair<int, int> H1 = make_pair(h1[0][a.first], h1[1][a.first]);\n    pair<int, int> H2 =\n        make_pair(((h[0][a.second.first] -\n                    (long long)h[0][a.second.first + l2] * stp[0][l2]) %\n                       P[0] +\n                   P[0]) %\n                      P[0],\n                  ((h[1][a.second.first] -\n                    (long long)h[1][a.second.first + l2] * stp[1][l2]) %\n                       P[1] +\n                   P[1]) %\n                      P[1]);\n    return make_pair(\n        (H1.first + (long long)H2.first * stp[0][a.first]) % P[0],\n        (H1.second + (long long)H2.second * stp[1][a.first]) % P[1]);\n  }\n  {\n    int l2 = l - a.first - n;\n    pair<int, int> H1 = get_hash(a, a.first + n);\n    pair<int, int> H2 = make_pair(h2[0][l2], h2[1][l2]);\n    ;\n    return make_pair(\n        (H1.first + (long long)H2.first * stp[0][a.first + n]) % P[0],\n        (H1.second + (long long)H2.second * stp[1][a.first + n]) % P[1]);\n  }\n}\nbool super_less(const pair<int, pair<int, int> >& a,\n                const pair<int, pair<int, int> >& b) {\n  if (a.first + a.second.second != b.first + b.second.second) {\n    return a.first + a.second.second < b.first + b.second.second;\n  }\n  int l = 0;\n  int r = a.first + a.second.second + n;\n  while (l < r) {\n    int m = (l + r + 1) / 2;\n    if (get_hash(a, m) == get_hash(b, m)) {\n      l = m;\n    } else {\n      r = m - 1;\n    }\n  }\n  if (r == a.first + a.second.second + n) {\n    return false;\n  }\n  return get_c(a, l) < get_c(b, l);\n}\nint main() {\n  scanf(\"%s\", s);\n  n = strlen(s);\n  for (int i = 0; i < n; i++) {\n    s[i + n] = s[i];\n  }\n  stp[0][0] = 1;\n  stp[1][0] = 1;\n  for (int j = 0; j < 2; j++) {\n    for (int i = 1; i <= 2 * n; i++) {\n      stp[j][i] = ((long long)stp[j][i - 1] * Q[j]) % P[j];\n    }\n  }\n  for (int j = 0; j < 2; j++) {\n    h[j][2 * n] = 0;\n    for (int i = 2 * n - 1; i >= 0; i--) {\n      h[j][i] = ((long long)h[j][i + 1] * Q[j] + (s[i] == '(' ? 1 : 2)) % P[j];\n    }\n  }\n  for (int j = 0; j < 2; j++) {\n    h1[j][0] = 0;\n    h2[j][0] = 0;\n    for (int i = 1; i <= 2 * n; i++) {\n      h1[j][i] = ((long long)h1[j][i - 1] * Q[j] + 1) % P[j];\n      h2[j][i] = ((long long)h2[j][i - 1] * Q[j] + 2) % P[j];\n    }\n  }\n  sum[0] = 0;\n  for (int i = 0; i < 2 * n; i++) {\n    if (s[i] == '(') {\n      sum[i + 1] = sum[i] + 1;\n    } else {\n      sum[i + 1] = sum[i] - 1;\n    }\n  }\n  for (int i = 0; i <= 2 * n; i++) {\n    upd(i, sum[i]);\n  }\n  pair<int, pair<int, int> > ans = make_pair(inf, make_pair(0, inf));\n  for (int i = 0; i < n; i++) {\n    int mn = min(0, get_min(i, i + n) - sum[i]);\n    int add_beg = abs(mn);\n    int add_end = sum[i + n] + add_beg - sum[i];\n    pair<int, pair<int, int> > res = make_pair(add_beg, make_pair(i, add_end));\n    if (super_less(res, ans)) {\n      ans = res;\n    }\n  }\n  print(ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 1000000;\nconst int MAX_N2 = MAX_N * 2;\nconst int MAX_E2 = 1 << 22;\nconst int INF = 1 << 30;\ntemplate <typename T, const int MAX_E2>\nstruct SegTreeMin {\n  int e2;\n  T nodes[MAX_E2], inf;\n  SegTreeMin() {}\n  void init(int n, T _inf) {\n    inf = _inf;\n    for (e2 = 1; e2 < n; e2 <<= 1)\n      ;\n    fill(nodes, nodes + MAX_E2, inf);\n  }\n  T &get(int i) { return nodes[e2 - 1 + i]; }\n  void set(int i, T v) { get(i) = v; }\n  void setall() {\n    for (int j = e2 - 2; j >= 0; j--)\n      nodes[j] = min(nodes[j * 2 + 1], nodes[j * 2 + 2]);\n  }\n  T min_range(int r0, int r1, int k, int i0, int i1) {\n    if (r1 <= i0 || i1 <= r0) return inf;\n    if (r0 <= i0 && i1 <= r1) return nodes[k];\n    int im = (i0 + i1) / 2;\n    T v0 = min_range(r0, r1, k * 2 + 1, i0, im);\n    T v1 = min_range(r0, r1, k * 2 + 2, im, i1);\n    return min(v0, v1);\n  }\n  T min_range(int r0, int r1) { return min_range(r0, r1, 0, 0, e2); }\n};\nchar s[MAX_N2 + 4];\nint ords[MAX_N2 + 1];\nSegTreeMin<int, MAX_E2> st;\ninline unsigned char mask(int i) { return (unsigned char)(1 << (7 - i)); }\ninline bool tget(vector<unsigned char> &t, int i) {\n  return (t[i / 8] & mask(i % 8)) ? true : false;\n}\ninline void tset(vector<unsigned char> &t, int i, bool b) {\n  if (b)\n    t[i / 8] |= mask(i % 8);\n  else\n    t[i / 8] &= ~mask(i % 8);\n}\ninline bool isLMS(vector<unsigned char> &t, int i) {\n  return (i > 0 && tget(t, i) && !tget(t, i - 1));\n}\nvoid getBuckets(int *s, vector<int> &bkt, int n, int k, bool end) {\n  bkt.assign(k, 0);\n  for (int i = 0; i < n; i++) bkt[s[i]]++;\n  for (int i = 0, sum = 0; i < k; i++) {\n    sum += bkt[i];\n    bkt[i] = end ? sum : sum - bkt[i];\n  }\n}\nvoid induceSAl(vector<unsigned char> &t, int *SA, int *s, vector<int> &bkt,\n               int n, int k, bool end) {\n  getBuckets(s, bkt, n, k, end);\n  for (int i = 0; i < n; i++) {\n    int j = SA[i] - 1;\n    if (j >= 0 && !tget(t, j)) SA[bkt[s[j]]++] = j;\n  }\n}\nvoid induceSAs(vector<unsigned char> &t, int *SA, int *s, vector<int> &bkt,\n               int n, int k, bool end) {\n  getBuckets(s, bkt, n, k, end);\n  for (int i = n - 1; i >= 0; i--) {\n    int j = SA[i] - 1;\n    if (j >= 0 && tget(t, j)) SA[--bkt[s[j]]] = j;\n  }\n}\nvoid SA_IS(int *s, int *SA, int n, int k) {\n  vector<unsigned char> t(n / 8 + 1);\n  tset(t, n - 1, true);\n  tset(t, n - 2, false);\n  for (int i = n - 3; i >= 0; i--)\n    if (s[i] < s[i + 1] || (s[i] == s[i + 1] && tget(t, i + 1)))\n      tset(t, i, true);\n  vector<int> bkt(k);\n  getBuckets(s, bkt, n, k, true);\n  for (int i = 0; i < n; i++) SA[i] = -1;\n  for (int i = 1; i < n; i++)\n    if (isLMS(t, i)) SA[--bkt[s[i]]] = i;\n  induceSAl(t, SA, s, bkt, n, k, false);\n  induceSAs(t, SA, s, bkt, n, k, true);\n  int n1 = 0;\n  for (int i = 0; i < n; i++)\n    if (isLMS(t, SA[i])) SA[n1++] = SA[i];\n  for (int i = n1; i < n; i++) SA[i] = -1;\n  int name = 0, prev = -1;\n  for (int i = 0; i < n1; i++) {\n    int pos = SA[i];\n    bool diff = false;\n    for (int d = 0; d < n; d++) {\n      if (prev == -1 || s[pos + d] != s[prev + d] ||\n          tget(t, pos + d) != tget(t, prev + d)) {\n        diff = true;\n        break;\n      } else if (d > 0 && (isLMS(t, pos + d) || isLMS(t, prev + d)))\n        break;\n    }\n    if (diff) name++, prev = pos;\n    pos /= 2;\n    SA[n1 + pos] = name - 1;\n  }\n  for (int i = n - 1, j = n - 1; i >= n1; i--)\n    if (SA[i] >= 0) SA[j--] = SA[i];\n  int *SA1 = SA, *s1 = SA + n - n1;\n  if (name < n1)\n    SA_IS(s1, SA1, n1, name);\n  else\n    for (int i = 0; i < n1; i++) SA1[s1[i]] = i;\n  bkt.assign(k, 0);\n  getBuckets(s, bkt, n, k, true);\n  for (int i = 1, j = 0; i < n; i++)\n    if (isLMS(t, i)) s1[j++] = i;\n  for (int i = 0; i < n1; i++) SA1[i] = s1[SA1[i]];\n  for (int i = n1; i < n; i++) SA[i] = -1;\n  for (int i = n1 - 1; i >= 0; i--) {\n    int j = SA[i];\n    SA[i] = -1;\n    SA[--bkt[s[j]]] = j;\n  }\n  induceSAl(t, SA, s, bkt, n, k, false);\n  induceSAs(t, SA, s, bkt, n, k, true);\n}\nvoid SA_IS(int n, char s[], vector<int> &SA, int k = 256) {\n  int *buf0 = new int[n + 1], *buf1 = new int[n + 1];\n  for (int i = 0; i < n; i++) buf0[i] = s[i];\n  buf0[n] = 0;\n  SA_IS(buf0, buf1, n + 1, k);\n  SA.resize(n + 1);\n  for (int i = 0; i <= n; i++) SA[i] = buf1[i];\n}\nint main() {\n  scanf(\"%s\", s);\n  int n = strlen(s), n2 = n * 2;\n  copy(s, s + n, s + n);\n  vector<int> sa;\n  SA_IS(n2, s, sa);\n  for (int i = 0; i <= n2; i++) {\n    ords[sa[i]] = i;\n  }\n  st.init(n2 + 1, INF);\n  st.set(0, 0);\n  int sum = 0;\n  for (int i = 0; i < n2; i++) {\n    int d = (s[i] == '(') ? 1 : -1;\n    st.set(i + 1, st.get(i) + d);\n    sum += d;\n  }\n  st.setall();\n  sum /= 2;\n  int maxd = -INF, mino = INF, mini = -1;\n  for (int i = 0; i < n; i++) {\n    int d = st.min_range(i, i + n + 1) - st.get(i);\n    if (maxd < d || (maxd == d && mino > ords[i]))\n      maxd = d, mino = ords[i], mini = i;\n  }\n  int on = max(-sum, -maxd), cn = on + sum;\n  while (on--) putchar('(');\n  for (int i = 0; i < n; i++) putchar(s[i + mini]);\n  while (cn--) putchar(')');\n  putchar('\\n');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint const N = 2234567;\nint const X = 33533;\nlong long M1;\nlong long M2;\nlong long const MASK = (1LL << 32) - 1;\nlong long POW1[N], POW2[N];\nint s[N];\nint bal[N];\nstruct hash {\n  long long h;\n  int len;\n};\nbool operator==(hash const& a, hash const& b) {\n  return a.len == b.len && a.h == b.h;\n}\nhash OPEN[N], CLOSE[N], hs[N];\nlong long add1(long long h1, long long h2, int len2) {\n  return (h1 * POW1[len2] + h2) % M1;\n}\nlong long add2(long long h1, long long h2, int len2) {\n  return (h1 * POW2[len2] + h2) % M2;\n}\nhash operator+(hash const& a, hash const& b) {\n  return {(add1(a.h >> 32, b.h >> 32, b.len) << 32) |\n              add2(a.h & MASK, b.h & MASK, b.len),\n          a.len + b.len};\n}\nint const TR = 1 << 21;\nint const INF = 1 << 30;\nint trmin[TR * 2];\nvoid settree(int x, int y) {\n  x += TR;\n  trmin[x] = y;\n  while (x > 1) {\n    x >>= 1;\n    if (trmin[x * 2] < trmin[x * 2 + 1])\n      trmin[x] = trmin[x * 2];\n    else\n      trmin[x] = trmin[x * 2 + 1];\n  }\n}\nint getmin(int left, int right) {\n  --right;\n  left += TR;\n  right += TR;\n  int ret = INF;\n  while (left <= right) {\n    if (left & 1) {\n      if (ret > trmin[left]) ret = trmin[left];\n      ++left;\n    }\n    if ((right & 1) == 0) {\n      if (ret > trmin[right]) ret = trmin[right];\n      --right;\n    }\n    left >>= 1;\n    right >>= 1;\n  }\n  return ret;\n}\nstruct answer {\n  int addOpen;\n  int pos;\n  int addClose;\n};\nint n;\nint getChar(answer const& f, int id) {\n  if (id < f.addOpen) return '(';\n  id -= f.addOpen;\n  if (id < n) return s[f.pos + id];\n  id -= n;\n  if (id < f.addClose) return ')';\n  assert(false);\n}\nhash getHash(int left, int right) {\n  long long h1 = hs[right - 1].h >> 32;\n  long long h2 = hs[right - 1].h & MASK;\n  long long g1 = hs[left - 1].h >> 32;\n  long long g2 = hs[left - 1].h & MASK;\n  h1 -= g1 * POW1[right - left] % M1;\n  h2 -= g2 * POW2[right - left] % M2;\n  if (h1 < 0) h1 += M1;\n  if (h2 < 0) h2 += M2;\n  return {(h1 << 32) | h2, right - left};\n}\nhash getHash(answer const& f, int len) {\n  if (len <= f.addOpen) {\n    return OPEN[len];\n  }\n  hash z = OPEN[f.addOpen];\n  len -= f.addOpen;\n  if (len <= n) {\n    return z + getHash(f.pos, f.pos + len);\n  }\n  z = z + getHash(f.pos, f.pos + n);\n  len -= n;\n  if (len <= f.addClose) {\n    return z + CLOSE[len];\n  }\n  assert(false);\n}\nbool operator<(answer const& f, answer const& g) {\n  if (f.addOpen + f.addClose != g.addOpen + g.addClose)\n    return f.addOpen + f.addClose < g.addOpen + g.addClose;\n  int left = 0;\n  int right = f.addOpen + f.addClose + n + 1;\n  while (left < right - 1) {\n    int mid = (left + right) >> 1;\n    if (getHash(f, mid) == getHash(g, mid)) {\n      left = mid;\n    } else {\n      right = mid;\n    }\n  }\n  if (left == f.addOpen + f.addClose + n) return false;\n  return getChar(f, left) < getChar(g, left);\n}\nstd::mt19937 rnd(std::chrono::system_clock::now().time_since_epoch().count());\nint const HALFBILLION = 500000000;\nbool prime(int x) {\n  for (int i = 2; i * i <= x; i++) {\n    if (x % i == 0) return false;\n  }\n  return true;\n}\nvoid gen(long long& M) {\n  M = rnd() % HALFBILLION + HALFBILLION;\n  while (!prime(M)) {\n    ++M;\n  }\n}\nint main() {\n  gen(M1);\n  gen(M2);\n  POW1[0] = POW2[0] = 1;\n  OPEN[0] = {0, 0};\n  CLOSE[0] = {0, 0};\n  for (int i = 1; i < N; i++) {\n    POW1[i] = POW1[i - 1] * X % M1;\n    POW2[i] = POW2[i - 1] * X % M2;\n    if (i == 1) {\n      OPEN[i] = {(long long)'(', 1};\n      CLOSE[i] = {(long long)')', 1};\n    } else {\n      OPEN[i] = OPEN[i - 1] + OPEN[1];\n      CLOSE[i] = CLOSE[i - 1] + CLOSE[1];\n    }\n  }\n  int c = getchar();\n  while (c <= 32) c = getchar();\n  n = 1;\n  while (c > 32) {\n    s[n++] = c;\n    c = getchar();\n  }\n  --n;\n  for (int i = 1; i <= n; i++) s[i + n] = s[i];\n  bal[0] = 0;\n  for (int i = 1; i <= 2 * n; i++) {\n    bal[i] = bal[i - 1] + (s[i] == '(' ? 1 : -1);\n    settree(i, bal[i]);\n  }\n  hs[0] = {0, 0};\n  for (int i = 1; i <= 2 * n; i++) {\n    hash cur = {(long long)s[i], 1};\n    hs[i] = hs[i - 1] + cur;\n  }\n  answer ans = {INF / 2, -1, INF / 2};\n  for (int start = 1; start <= n; start++) {\n    int minB = getmin(start - 1, start + n);\n    int addOpen = bal[start - 1] - minB;\n    int addClose = bal[start + n - 1] - minB;\n    answer cur = {addOpen, start, addClose};\n    if (cur < ans) ans = cur;\n  }\n  for (int i = 0; i < ans.addOpen; i++) putchar('(');\n  for (int i = 0; i < n; i++) putchar(s[ans.pos + i]);\n  for (int i = 0; i < ans.addClose; i++) putchar(')');\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXlogN = 22;\nint wa[2000015], wb[2000015], wv[2000015], Ws[2000015];\nint cmp(int* r, int a, int b, int l) {\n  return r[a] == r[b] && r[a + l] == r[b + l];\n}\nint sa[2000015], Rank[2000015], LCP[2000015];\nvoid buildSA(string s, int* sa, int n, int m) {\n  int i, j, p, *x = wa, *y = wb, *t;\n  for (i = 0; i < m; i++) Ws[i] = 0;\n  for (i = 0; i < n; i++) Ws[x[i] = s[i]]++;\n  for (i = 1; i < m; i++) Ws[i] += Ws[i - 1];\n  for (i = n - 1; i >= 0; i--) sa[--Ws[x[i]]] = i;\n  for (j = 1, p = 1; p < n; j <<= 1, m = p) {\n    for (p = 0, i = n - j; i < n; i++) y[p++] = i;\n    for (i = 0; i < n; i++)\n      if (sa[i] >= j) y[p++] = sa[i] - j;\n    for (i = 0; i < n; i++) wv[i] = x[y[i]];\n    for (i = 0; i < m; i++) Ws[i] = 0;\n    for (i = 0; i < n; i++) Ws[wv[i]]++;\n    for (i = 1; i < m; i++) Ws[i] += Ws[i - 1];\n    for (i = n - 1; i >= 0; i--) sa[--Ws[wv[i]]] = y[i];\n    for (t = x, x = y, y = t, p = 1, x[sa[0]] = 0, i = 1; i < n; i++)\n      x[sa[i]] = cmp(y, sa[i - 1], sa[i], j) ? p - 1 : p++;\n  }\n}\nint A[2000015];\nint Log[2000015];\nint M[2000015][MAXlogN];\nvoid buildSparse(int n) {\n  for (int i = 1; i <= n; i++) M[i][0] = A[i];\n  for (int i = 2; i <= n; i++) Log[i] = Log[i - 1] + !(i & (i - 1));\n  for (int j = 1; (1 << j) <= n; j++) {\n    for (int i = 1; (i + (1 << j) - 1) <= n; i++)\n      M[i][j] = min(M[i][j - 1], M[i + (1 << (j - 1))][j - 1]);\n  }\n}\nint Query(int i, int j) {\n  int k = Log[j - i + 1];\n  return min(M[i][k], M[j - (1 << k) + 1][k]);\n}\nstring str;\nint main() {\n  cin >> str;\n  int cc = 0;\n  for (char ch : str) cc += (ch == '(') ? 1 : -1;\n  str = str + str;\n  int n = str.size();\n  buildSA(str, sa, n + 1, 130);\n  A[0] = (str[0] == '(') ? 1 : -1;\n  for (int i = 1; i < n; i++) {\n    if (str[i] == '(')\n      A[i] = 1;\n    else\n      A[i] = -1;\n    A[i] += A[i - 1];\n  }\n  for (int i = n; i >= 1; i--) A[i] = A[i - 1];\n  buildSparse(n);\n  int mn = 0;\n  for (int i = 1; i <= n; i++) {\n    if (sa[i] < n / 2) {\n      int xx = Query(sa[i] + 1, (sa[i] + 1) + n / 2 - 1);\n      if (xx - A[sa[i]] + max(-cc, 0) >= 0) {\n        mn = sa[i];\n        break;\n      }\n    }\n  }\n  string ans;\n  ans.resize(n / 2 + abs(cc));\n  if (cc >= 0) {\n    int cur = 0;\n    for (int i = mn; i < n / 2; i++, cur++) ans[cur] = str[i];\n    for (int i = 0; i < mn; i++, cur++) ans[cur] = str[i];\n    for (int i = 1; i <= cc; i++, cur++) ans[cur] = ')';\n  } else {\n    int cur = 0;\n    for (int i = 1; i <= abs(cc); i++, cur++) ans[cur] = '(';\n    for (int i = mn; i < n / 2; i++, cur++) ans[cur] = str[i];\n    for (int i = 0; i < mn; i++, cur++) ans[cur] = str[i];\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e6 + 5;\nconst int inf = 0x3f3f3f3f;\nconst int mod = 1e9 + 7;\nchar s[maxn];\nint sa[maxn], rk[maxn], tp[maxn], tax[maxn];\nint sum[maxn], mn[maxn], que[maxn];\nint n, p1, p2;\nvoid rsort(int n, int m) {\n  for (int i = 0; i <= m; ++i) tax[i] = 0;\n  for (int i = 1; i <= n; ++i) ++tax[rk[tp[i]]];\n  for (int i = 1; i <= m; ++i) tax[i] += tax[i - 1];\n  for (int i = n; i >= 1; --i) sa[tax[rk[tp[i]]]--] = tp[i];\n}\ninline int cmp(int x, int y, int len, int n) {\n  return tp[x] == tp[y] && x + len <= n && y + len <= n &&\n         tp[x + len] == tp[y + len];\n}\nvoid da(int n, int m) {\n  for (int i = 1; i <= n; ++i) tp[i] = i, rk[i] = s[i];\n  rsort(n, m);\n  for (int len = 1, p = 0; p < n && len < n; len <<= 1, m = p) {\n    p = 0;\n    for (int i = 1; i <= n; ++i) tp[++p] = (sa[i] - len - 1 + n) % n + 1;\n    rsort(n, m);\n    for (int i = 1; i <= n; ++i) tp[i] = tp[i + n] = rk[i];\n    rk[sa[1]] = p = 1;\n    for (int i = 2; i <= n; ++i)\n      rk[sa[i]] = cmp(sa[i - 1], sa[i], len, 2 * n) ? p : ++p;\n  }\n}\nint main() {\n  scanf(\"%s\", s + 1);\n  n = strlen(s + 1);\n  for (int i = 1; i <= n; ++i) s[i + n] = s[i];\n  da(n, 256);\n  int tn = n;\n  n <<= 1;\n  for (int i = 1; i <= n; ++i) {\n    sum[i] = sum[i - 1] + (s[i] == '(' ? 1 : -1);\n  }\n  p1 = 1, p2 = 0;\n  for (int i = 1; i <= n; ++i) {\n    while (p1 <= p2 && sum[que[p2]] >= sum[i]) --p2;\n    que[++p2] = i;\n    while (i - que[p1] + 1 > tn) ++p1;\n    if (i >= tn) mn[i - tn + 1] = sum[que[p1]] - sum[i - tn];\n  }\n  int x = inf, y;\n  for (int i = 1; i <= tn; ++i) {\n    mn[i] = mn[i] >= 0 ? 0 : -mn[i];\n    x = min(x, mn[i]);\n  }\n  int p = 0;\n  y = x + sum[tn];\n  for (int i = 1; i <= tn; ++i) {\n    if (mn[sa[i]] == x) {\n      p = sa[i];\n      break;\n    }\n  }\n  while (x--) putchar('(');\n  s[p + tn] = 0;\n  printf(\"%s\", s + p);\n  while (y--) putchar(')');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:66777216\")\nusing namespace std;\nstatic unsigned rnd() {\n  static int second = 124612741;\n  second ^= second << 13;\n  second ^= second >> 17;\n  return second ^= second << 5;\n}\ninline int fpow(int a, int st, int mod) {\n  int ans = 1;\n  while (st) {\n    if (st % 2) ans = (long long)ans * a % mod;\n    a = (long long)a * a % mod;\n    st /= 2;\n  }\n  return ans;\n}\nint invmod(int first, int second) {\n  int a = 1, b = 0, k;\n  for (; second; swap(first, second), swap(a, b)) {\n    k = first / second;\n    first -= second * k;\n    a -= b * k;\n  }\n  return a + max(b, 0);\n}\nstruct Hash {\n  Hash() : x1(0), x2(0) {}\n  Hash(const int& x1, const int& x2) : x1(x1), x2(x2) {}\n  int x1, x2;\n  static int mod1, mod2;\n  static int p1, p2;\n  static int invp1, invp2;\n  static bool initCalled;\n  static const Hash ONE, ZERO, INVALID;\n  static Hash UNIT, INV_UNIT;\n  static bool prime(int a) {\n    if (a == 1) return 0;\n    for (int i = 2; i * i <= a; ++i) {\n      if (a % i == 0) return false;\n    }\n    return true;\n  }\n  static void init() {\n    if (initCalled) return;\n    initCalled = true;\n    mod1 = 1000000000 + rnd() % 10000000;\n    while (!prime(mod1)) ++mod1;\n    mod2 = 1000000000 + rnd() % 10000000;\n    while (mod2 == mod1 || !prime(mod2)) ++mod2;\n    invp1 = fpow(p1, mod1 - 2, mod1);\n    invp2 = fpow(p2, mod2 - 2, mod2);\n    INV_UNIT = Hash(invp1, invp2);\n  }\n  inline Hash& operator+=(const Hash& other) {\n    x1 += other.x1;\n    if (x1 >= Hash::mod1) x1 -= Hash::mod1;\n    x2 += other.x2;\n    if (x2 >= Hash::mod2) x2 -= Hash::mod2;\n    return *this;\n  }\n  inline Hash& operator-=(const Hash& other) {\n    x1 -= other.x1;\n    if (x1 < 0) x1 += Hash::mod1;\n    x2 -= other.x2;\n    if (x2 < 0) x2 += Hash::mod2;\n    return *this;\n  }\n  inline Hash& operator*=(const Hash& other) {\n    x1 = (long long)x1 * other.x1 % Hash::mod1;\n    x2 = (long long)x2 * other.x2 % Hash::mod2;\n    return *this;\n  }\n  inline Hash& operator*=(const int& other) {\n    x1 = (long long)x1 * other % Hash::mod1;\n    x2 = (long long)x2 * other % Hash::mod2;\n    return *this;\n  }\n  inline Hash& operator^=(const int& power) {\n    int st = power;\n    Hash ans(1, 1);\n    while (st) {\n      if (st % 2) ans *= *this;\n      x1 = (long long)x1 * x1 % Hash::mod1;\n      x2 = (long long)x2 * x2 % Hash::mod2;\n      st /= 2;\n    }\n    return *this;\n  }\n  inline bool operator==(const Hash& other) const {\n    return x1 == other.x1 && x2 == other.x2;\n  }\n};\nbool Hash::initCalled = false;\nint Hash::mod1 = 0;\nint Hash::mod2 = 0;\nint Hash::p1 = 23561;\nint Hash::p2 = 10000019;\nint Hash::invp1 = -1;\nint Hash::invp2 = -1;\nconst Hash Hash::ONE(1, 1);\nconst Hash Hash::ZERO(0, 0);\nconst Hash Hash::INVALID(-1, -1);\nHash Hash::UNIT(Hash::p1, Hash::p2);\nHash Hash::INV_UNIT(-1, -1);\ninline Hash operator+(const Hash& a, const Hash& b) {\n  Hash ans(a.x1 + b.x1, a.x2 + b.x2);\n  if (ans.x1 >= Hash::mod1) ans.x1 -= Hash::mod1;\n  if (ans.x2 >= Hash::mod2) ans.x2 -= Hash::mod2;\n  return ans;\n}\ninline Hash operator-(const Hash& a, const Hash& b) {\n  Hash ans(a.x1 - b.x1, a.x2 - b.x2);\n  if (ans.x1 < 0) ans.x1 += Hash::mod1;\n  if (ans.x2 < 0) ans.x2 += Hash::mod2;\n  return ans;\n}\ninline Hash operator*(const Hash& a, const Hash& b) {\n  return Hash((long long)a.x1 * b.x1 % Hash::mod1,\n              (long long)a.x2 * b.x2 % Hash::mod2);\n}\ninline Hash operator*(const Hash& a, const int& b) {\n  return Hash((long long)a.x1 * b % Hash::mod1,\n              (long long)a.x2 * b % Hash::mod2);\n}\ninline Hash operator^(const Hash& a, const int& power) {\n  int st = power;\n  Hash ans(1, 1), cur(a);\n  while (st) {\n    if (st % 2) ans *= cur;\n    cur *= cur;\n    st /= 2;\n  }\n  return ans;\n}\ninline Hash fpow(const Hash& a, const int& power) { return a ^ power; }\ninline Hash invmod(const Hash& a) {\n  return Hash(invmod(a.x1, Hash::mod1), invmod(a.x2, Hash::mod2));\n}\ntemplate <class H>\nstruct HashString : public string {\n  HashString() : string() { precalc(0); }\n  HashString(const HashString& other) : string(other) { precalc(size()); }\n  HashString(HashString&& other)\n      : hh(std::move(other.hh)), string(std::move(other)) {\n    precalc(size());\n  }\n  HashString(const string& other) : string(other) {\n    precalc(size());\n    build();\n  }\n  HashString(string&& other) : string(std::move(other)) {\n    precalc(size());\n    build();\n  }\n  HashString(const char* other) : string(other) {\n    precalc(size());\n    build();\n  }\n  inline void clear() {\n    hh.clear();\n    string::clear();\n  }\n  inline static H getPow(int p) {\n    if (p < haveN) {\n      return pp[p];\n    } else {\n      return fpow(H::UNIT, p);\n    }\n  }\n  inline static H getInvPow(size_t p) {\n    if (p < invpp.size()) {\n      return invpp[p];\n    } else {\n      return fpow(H::INV_UNIT, p);\n    }\n  }\n  inline H getInvRegister(const H& p) const {\n    if (p == register_) {\n      return registerValue_;\n    } else {\n      register_ = p;\n      return registerValue_ = invmod(p);\n    }\n  }\n  static void precalc(int N = 0) {\n    Hash::init();\n    if (haveN >= N) return;\n    pp.resize(N);\n    invpp.resize(N);\n    if (!haveN) {\n      pp[0] = H::ONE;\n      invpp[0] = H::ONE;\n      haveN = 1;\n    }\n    for (int i = haveN; i < N; ++i) {\n      pp[i] = pp[i - 1] * H::UNIT;\n      invpp[i] = invpp[i - 1] * H::INV_UNIT;\n    }\n    haveN = N;\n  }\n  inline void build() {\n    int curSize = size();\n    if (haveN <= curSize) {\n      precalc(curSize);\n    }\n    for (int i = hh.size(); i < curSize; ++i) {\n      H pr = i ? hh.back() : H::ZERO;\n      hh.push_back(pr + getPow(i) * (*this)[i]);\n    }\n  }\n  inline H getHash(int pos, int len) const {\n    if (len <= 0) return H::ZERO;\n    const int S = size();\n    if (pos + len - 1 < S) {\n      H ans = hh[pos + len - 1];\n      if (pos) {\n        ans -= hh[pos - 1];\n      }\n      return ans * getInvPow(pos);\n    } else {\n      H head = hh.back();\n      if (pos) {\n        head -= hh[pos - 1];\n      }\n      head *= getInvPow(pos);\n      int full = -1, en = -1;\n      H mid = H::ZERO;\n      int midlen = 0;\n      if (len <= S) {\n        en = pos + len - 1 - S;\n        H tail = hh[en];\n        full = 0;\n        return head + tail * getPow(S - pos);\n      } else {\n        en = (pos + len - 1) % S;\n        H tail = hh[en];\n        full = (len - (S - pos) - (en + 1)) / S;\n        mid = hh.back() * (H::ONE - getInvPow(full * S)) *\n              getInvRegister(H::ONE - getInvPow(S));\n        return head + mid * getPow(S - pos) + tail * getPow(len - (en + 1));\n      }\n    }\n  }\n  inline HashString& operator+=(const char& ch) {\n    string::operator+=(ch);\n    build();\n    return *this;\n  }\n  inline HashString& operator+=(const HashString& other) {\n    string::operator+=(other);\n    build();\n    return *this;\n  }\n  inline bool operator==(const HashString& other) const {\n    return hh.back() == other.hh.back();\n  }\n  inline bool operator<(const HashString& other) const {\n    int s1 = size();\n    int s2 = other.size();\n    const int S = min(s1, s2);\n    int l = 0, r = S + 1;\n    while (r - l > 1) {\n      int xx = (r + l) / 2;\n      if (getHash(0, xx) == other.getHash(0, xx))\n        l = xx;\n      else\n        r = xx;\n    }\n    char c1 = 0, c2 = 0;\n    if (l < s1) c1 = (*this)[l];\n    if (l < s2) c2 = other[l];\n    return c1 < c2;\n  }\n  inline bool operator<=(const HashString& other) const {\n    return (*this == other) || (*this < other);\n  }\n  inline bool operator>(const HashString& other) const {\n    return !(*this == other) && !(*this < other);\n  }\n  inline bool operator>=(const HashString& other) const {\n    return !(*this < other);\n  }\n  inline bool operator!=(const HashString& other) const {\n    return !(*this == other);\n  }\n  inline void reserve(int N) {\n    hh.reserve(N);\n    string::reserve(N);\n  }\n  vector<H> hh;\n  static vector<H> pp, invpp;\n\n private:\n  mutable H register_, registerValue_;\n  static int haveN;\n};\ntemplate <>\nint HashString<Hash>::haveN = 0;\ntemplate <>\nvector<Hash> HashString<Hash>::pp = vector<Hash>();\ntemplate <>\nvector<Hash> HashString<Hash>::invpp = vector<Hash>();\ntemplate <class H, bool cyclic = true>\nstruct HashStringPiece {\n  explicit HashStringPiece(const HashString<H>& s, int pos, int len)\n      : s(s), pos(pos), len(len), hash(H::INVALID) {}\n  inline H getHash() const {\n    if (hash == H::INVALID) hash = s.getHash(pos, len);\n    return hash;\n  }\n  inline H getPartialHash(int needLen) const { return s.getHash(pos, needLen); }\n  inline char getChar(int i) const {\n    i += pos;\n    const int S = s.size();\n    if (i < S) return s[i];\n    if (!cyclic) return 0;\n    i -= S;\n    if (i < S) return s[i];\n    return s[i % S];\n  }\n  const HashString<H>& s;\n  const int pos, len;\n  mutable H hash;\n};\ntemplate <class H, class T>\nchar getHSPRangeChar(T beg, T en, int pos) {\n  for (T it = beg; it != en; ++it) {\n    if (pos < it->len) {\n      return it->getChar(pos);\n    }\n    pos -= it->len;\n  }\n  return 0;\n}\ntemplate <class H, class T>\nH getHSPRangeHash(T beg, T en, int len) {\n  H ans = H::ZERO;\n  int cur = 0;\n  for (T it = beg; it != en; ++it) {\n    if (len >= it->len) {\n      ans += it->getHash() * it->s.getPow(cur);\n      cur += it->len;\n      len -= it->len;\n    } else {\n      ans += it->getPartialHash(len) * it->s.getPow(cur);\n      break;\n    }\n  }\n  return ans;\n}\nint TB, IT;\ntemplate <class H, class T>\ninline int compareHSPRanges(T beg1, T en1, int len1, T beg2, T en2, int len2) {\n  if (beg1 == en1 && beg2 == en2) return 0;\n  if (beg1 == en1) return -1;\n  if (beg2 == en2) return 1;\n  int l = 0, r = min(len1, len2) + 1;\n  while (r - l > 1) {\n    int xx = (r + l) / 2;\n    auto h1 = getHSPRangeHash<H, T>(beg1, en1, xx);\n    auto h2 = getHSPRangeHash<H, T>(beg2, en2, xx);\n    if (h1 == h2)\n      l = xx;\n    else\n      r = xx;\n  }\n  char c1 = getHSPRangeChar<H, T>(beg1, en1, l);\n  char c2 = getHSPRangeChar<H, T>(beg2, en2, l);\n  if (c1 < c2)\n    return -1;\n  else if (c1 == c2)\n    return 0;\n  else\n    return 1;\n}\ntemplate <class H, class T>\ninline int compareHSPRanges(T beg1, T en1, T beg2, T en2) {\n  int len1 = 0;\n  for (T it = beg1; it != en1; ++it) {\n    len1 += it->len;\n  }\n  int len2 = 0;\n  for (T it = beg2; it != en2; ++it) {\n    len2 += it->len;\n  }\n  return compareHSPRanges<H, T>(beg1, en1, len1, beg2, en2, len2);\n}\nint a, b, c, d, n, m, k;\nchar str[1000002];\nint bal[2000002];\nHashString<Hash> s;\ninline string build(pair<pair<int, int>, int> a) {\n  string ans = \"\";\n  for (int _n((a.first.first) - 1), i(0); i <= _n; i++) ans += '(';\n  for (int _n((n)-1), i(0); i <= _n; i++) {\n    int cur = a.second + i;\n    if (cur >= n) cur -= n;\n    ans += str[cur];\n  }\n  for (int _n((a.first.second) - 1), i(0); i <= _n; i++) ans += ')';\n  return ans;\n}\nHashString<Hash> op, cl;\ninline bool better(pair<pair<int, int>, int> a, pair<pair<int, int>, int> b,\n                   const HashString<Hash>& s) {\n  HashStringPiece<Hash> A[3] = {HashStringPiece<Hash>(op, 0, a.first.first),\n                                HashStringPiece<Hash>(s, a.second, n),\n                                HashStringPiece<Hash>(cl, 0, a.first.second)};\n  HashStringPiece<Hash> B[3] = {HashStringPiece<Hash>(op, 0, b.first.first),\n                                HashStringPiece<Hash>(s, b.second, n),\n                                HashStringPiece<Hash>(cl, 0, b.first.second)};\n  int t = compareHSPRanges<Hash>(A, A + 3, B, B + 3);\n  if (t == -1)\n    return 1;\n  else\n    return 0;\n}\nint main() {\n  gets(str);\n  n = (int)strlen(str);\n  HashString<Hash> s(str);\n  HashString<Hash>::precalc(2 * n + 1);\n  for (int _n((n)-1), i(0); i <= _n; i++) {\n    op += '(';\n    cl += ')';\n  }\n  c = 0;\n  for (int _n((n)-1), i(0); i <= _n; i++) {\n    if (str[i] == '(')\n      ++c;\n    else\n      --c;\n  }\n  bal[0] = 0;\n  for (int _n((2 * n) - 1), i(0); i <= _n; i++) {\n    if (i) bal[i] = bal[i - 1];\n    int cur = i;\n    if (i >= n) cur = i - n;\n    if (str[cur] == '(')\n      ++bal[i];\n    else\n      --bal[i];\n  }\n  int blen = 1000000000;\n  pair<pair<int, int>, int> best = make_pair(make_pair(0, 0), 0);\n  stack<pair<int, int> > s1, s2;\n  for (int _n((n)-1), i(0); i <= _n; i++) {\n    int new_element = bal[i];\n    int minima = s1.empty() ? new_element : min(new_element, s1.top().second);\n    s1.push(make_pair(new_element, minima));\n  }\n  for (int _n((n)-1), cyc(0); cyc <= _n; cyc++) {\n    int current_minimum = -1000000000;\n    if (s1.empty() || s2.empty())\n      current_minimum = s1.empty() ? s2.top().second : s1.top().second;\n    else\n      current_minimum = min(s1.top().second, s2.top().second);\n    int p = 0;\n    if (cyc) p = bal[cyc - 1];\n    int mn = current_minimum - p;\n    int beg = max(0, -mn);\n    int en = c + beg;\n    int len = beg + en + n;\n    if (len < blen ||\n        (len == blen && better(make_pair(make_pair(beg, en), cyc), best, s))) {\n      blen = len;\n      best = make_pair(make_pair(beg, en), cyc);\n    }\n    if (s2.empty()) {\n      while (!s1.empty()) {\n        int element = s1.top().first;\n        s1.pop();\n        int minima = s2.empty() ? element : min(element, s2.top().second);\n        s2.push(make_pair(element, minima));\n      }\n    }\n    s2.pop();\n    int new_element = bal[cyc + n];\n    int minima = s1.empty() ? new_element : min(new_element, s1.top().second);\n    s1.push(make_pair(new_element, minima));\n  }\n  string ans = build(best);\n  printf(\"%s\\n\", ans.c_str());\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma warning(disable : 4996)\nusing namespace std;\nchar a[6000000];\nint A[6000000];\nint sa[6000000];\nint it[6000000];\nint n;\nint good[6000000];\nint S = 2097152;\nvoid update(int x) {\n  for (x /= 2; x > 0; x /= 2) it[x] = min(it[x * 2], it[x * 2 + 1]);\n}\nint getmin(int x, int y) {\n  int mi = ((1 << 30) - 1);\n  while (x <= y) {\n    if (x % 2 == 1) mi = min(mi, it[x++]);\n    if (y % 2 == 0) mi = min(mi, it[y--]);\n    x /= 2, y /= 2;\n  }\n  return mi;\n}\nstruct SuffixArray {\n  int N;\n  vector<int> raank, lcp, sa;\n  string S;\n  SuffixArray(string S) : S(S) {\n    int i, h = 0;\n    vector<int> tmp, tr;\n    N = S.size();\n    raank.resize(N + 1);\n    sa.resize(N + 1);\n    tmp.resize(N + 1);\n    for (i = 0; i < N + 1; i++) sa[i] = i, raank[i] = i == N ? -1 : S[i];\n    for (int k = 1; k <= N; k <<= 1) {\n      auto pred2 = [k, this](int& a, int& b) -> bool {\n        return (((a + k <= N) ? raank[a + k] : -1) <\n                ((b + k <= N) ? raank[b + k] : -1));\n      };\n      auto pred = [pred2, k, this](int& a, int& b) -> bool {\n        return (raank[a] != raank[b]) ? (raank[a] < raank[b]) : pred2(a, b);\n      };\n      int x = 0;\n      if (k != 1)\n        for (i = 1; i < N + 1; i++)\n          if (raank[sa[i]] != raank[sa[x]])\n            sort(sa.begin() + x, sa.begin() + i, pred2), x = i;\n      sort(sa.begin() + x, sa.end(), pred);\n      for (i = 0; i < N + 1; i++)\n        tmp[sa[i]] = (i == 0) ? 0 : tmp[sa[i - 1]] + pred(sa[i - 1], sa[i]);\n      swap(raank, tmp);\n    }\n    lcp.resize(N + 1);\n    tr.resize(N + 1);\n    for (i = 0; i < N + 1; i++) tr[sa[i]] = i;\n    for (i = 0; i < N; i++) {\n      int j = sa[tr[i] - 1];\n      for (h = max(h - 1, 0); i + h < N && j + h < N; h++)\n        if (S[j + h] != S[i + h]) break;\n      lcp[tr[i] - 1] = h;\n    }\n  }\n};\nint main() {\n  int i, j, k;\n  scanf(\"%s\", a);\n  n = strlen(a);\n  for (i = 0; i < n; i++) a[i + n] = a[i];\n  string s = string(a);\n  SuffixArray ssa(s);\n  for (i = 0; i < n * 2; i++) sa[ssa.raank[i] - 1] = i;\n  int now = 0;\n  for (i = 0; i < n * 2; i++) {\n    now += a[i] == '(' ? 1 : -1;\n    it[S + i + 1] = now;\n    update(S + i + 1);\n  }\n  int pad = 0;\n  now /= 2;\n  if (now < 0) pad = -now;\n  for (i = 0; i < n; i++) {\n    if (getmin(S + i, S + i + n) - it[S + i] + pad >= 0) good[i] = 1;\n  }\n  for (i = 0; i < n * 2; i++) {\n    if (good[sa[i]] == 1) {\n      for (j = now; j < 0; j++) printf(\"(\");\n      for (j = sa[i]; j < sa[i] + n; j++) printf(\"%c\", a[j]);\n      for (j = 0; j < now; j++) printf(\")\");\n      return 0;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2111111;\nchar buf[maxn];\nint sum[maxn];\nbool ok[maxn];\ninline void fix(int& i, int n) {\n  while (!ok[i] && i <= n) {\n    ++i;\n  }\n}\ninline void print(char ch, int n) {\n  while (n--) {\n    putchar(ch);\n  }\n}\nint run(char s[], int m) {\n  int n = m >> 1;\n  int i = 1, j = 2, k = 0;\n  fix(i, n);\n  j = i + 1;\n  fix(j, n);\n  while (j <= n && i <= n) {\n    for (k = 0; k < n; ++k) {\n      if (s[i + k] ^ s[j + k]) {\n        break;\n      }\n    }\n    if (s[i + k] > s[j + k]) {\n      i += k + 1;\n      fix(i, n);\n    } else {\n      j += k + 1;\n      fix(j, n);\n    }\n    if (j == i) {\n      ++j;\n      fix(j, n);\n    }\n  }\n  return std::min(i, j);\n}\nint main() {\n  gets(buf + 1);\n  int n = std::strlen(buf + 1);\n  int A, B;\n  A = B = 0;\n  for (int i = 1; i <= n; ++i) {\n    buf[i + n] = buf[i];\n    if (buf[i] == '(') {\n      ++A;\n    } else {\n      ++B;\n    }\n  }\n  int m = n << 1;\n  for (int i = 1; i <= m; ++i) {\n    if (buf[i] == '(') {\n      sum[i] = 1;\n    } else {\n      sum[i] = -1;\n    }\n    sum[i] += sum[i - 1];\n  }\n  static int q[maxn];\n  int front, rear;\n  front = rear = 0;\n  static int min[maxn];\n  int add = 0;\n  if (A < B) {\n    add = B - A;\n  }\n  for (int i = 1; i <= m; ++i) {\n    if (front < rear && q[front] + n <= i) {\n      ++front;\n    }\n    while (front < rear && sum[q[rear - 1]] >= sum[i]) {\n      --rear;\n    }\n    q[rear++] = i;\n    min[i] = sum[q[front]];\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (add + min[i + n - 1] >= sum[i - 1]) {\n      ok[i] = true;\n    }\n  }\n  int index = run(buf, m);\n  if (A < B) {\n    print('(', B - A);\n  }\n  for (int i = index; i < index + n; ++i) {\n    putchar(buf[i]);\n  }\n  if (B < A) {\n    print(')', A - B);\n  }\n  puts(\"\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstring st;\nlong bal[1 << 20];\nlong minsuf[1 << 20], minpref[1 << 20];\nlong val1, val2;\nlong n;\nlong s[1 << 20];\nlong p[1 << 20], pn[1 << 20], cnt[1 << 20], c[1 << 20], cn[1 << 20];\nlong classes, mid1, mid2;\nlong ans, k;\nlong open, clos;\nlong blen, bc, tlen, nopen;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin >> st;\n  n = st.size();\n  for (int i = 0; i < n; i++)\n    if (st[i] == '(')\n      s[i] = 0;\n    else\n      s[i] = 1;\n  for (int i = 0; i < n; i++) ++cnt[s[i]];\n  for (int i = 1; i < 100; i++) cnt[i] += cnt[i - 1];\n  for (int i = 0; i < n; i++) {\n    p[--cnt[s[i]]] = i;\n  }\n  c[p[0]] = 0;\n  classes = 1;\n  for (int i = 1; i < n; i++) {\n    if (s[p[i]] != s[p[i - 1]]) ++classes;\n    c[p[i]] = classes - 1;\n  }\n  for (int h = 0; (1 << h) < n; ++h) {\n    for (int i = 0; i < n; i++) {\n      pn[i] = p[i] - (1 << h);\n      if (pn[i] < 0) pn[i] += n;\n    }\n    for (int i = 0; i <= classes; i++) cnt[i] = 0;\n    for (int i = 0; i < n; i++) cnt[c[pn[i]]]++;\n    for (int i = 1; i < classes; i++) cnt[i] += cnt[i - 1];\n    for (int i = n - 1; i >= 0; --i) p[--cnt[c[pn[i]]]] = pn[i];\n    cn[p[0]] = 0;\n    classes = 1;\n    for (int i = 1; i < n; i++) {\n      mid1 = p[i] + (1 << h);\n      mid2 = p[i - 1] + (1 << h);\n      mid1 %= n;\n      mid2 %= n;\n      if (c[p[i]] != c[p[i - 1]] || c[mid1] != c[mid2]) ++classes;\n      cn[p[i]] = classes - 1;\n    }\n    for (int i = 0; i <= n; i++) c[i] = cn[i];\n  }\n  for (int i = 0; i < st.size(); i++) {\n    if (st[i] == '(')\n      bal[i + 1] = bal[i] + 1;\n    else\n      bal[i + 1] = bal[i] - 1;\n    minpref[i + 1] = min(minpref[i], bal[i + 1]);\n    if (st[i] == '(')\n      ++open;\n    else\n      ++clos;\n  }\n  minsuf[st.size()] = bal[st.size()];\n  for (int i = st.size() - 1; i + 1; --i) {\n    minsuf[i] = min(minsuf[i + 1], bal[i]);\n  }\n  blen = 1e9;\n  bc = 0;\n  for (int i = 0; i < st.size(); i++) {\n    val1 = minsuf[i + 1] - bal[i];\n    val2 = minpref[i] + (bal[st.size()] - bal[i]);\n    val1 = min(val1, val2);\n    if (val1 >= 0) {\n      tlen = st.size() + (open - clos);\n      if (tlen < blen || (tlen == blen && c[i] < c[bc])) {\n        blen = tlen;\n        bc = i;\n      }\n    } else {\n      nopen = open - val1;\n      tlen = st.size() + (nopen - clos);\n      if (tlen < blen || (tlen == blen && c[i] < c[bc])) {\n        blen = tlen;\n        bc = i;\n      }\n    }\n  }\n  string ts = \"\";\n  for (int i = bc; i < st.size(); i++) ts += st[i];\n  for (int i = 0; i < bc; i++) ts += st[i];\n  long mb = 0;\n  long qb = 0;\n  for (int i = 0; i < ts.size(); i++) {\n    if (ts[i] == '(')\n      qb++;\n    else\n      qb--;\n    if (qb < mb) mb = qb;\n  }\n  reverse(ts.begin(), ts.end());\n  if (mb < 0) {\n    mb *= -1;\n    for (int i = 0; i < mb; i++) ts += '(';\n  }\n  reverse(ts.begin(), ts.end());\n  qb = 0;\n  for (int i = 0; i < ts.size(); i++) {\n    if (ts[i] == '(')\n      ++qb;\n    else\n      --qb;\n  }\n  for (int i = 0; i < qb; i++) ts += ')';\n  cout << ts << endl;\n  cin.get();\n  cin.get();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.io.InputStream;\nimport java.io.OutputStreamWriter;\nimport java.util.Comparator;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tOutputWriter out = new OutputWriter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskA {\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n\t\tString s = in.readString();\n\t\tint count = s.length();\n\t\tint[] balance = new int[count + 1];\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tif (s.charAt(i) == '(') {\n\t\t\t\tbalance[i + 1] = balance[i] + 1;\n\t\t\t} else {\n\t\t\t\tbalance[i + 1] = balance[i] - 1;\n\t\t\t}\n\t\t}\n\t\tint freedom = Math.max(0, -balance[count]);\n\t\tlong[] value = new long[count];\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tvalue[i] = s.charAt(i) == '(' ? 0 : 1;\n\t\t}\n\t\tint[] order = ArrayUtils.order(value);\n\t\tint[] cl = new int[count];\n\t\tint current = -1;\n\t\tlong last = -1;\n\t\tfor (int j : order) {\n\t\t\tif (value[j] != last) {\n\t\t\t\tcurrent++;\n\t\t\t}\n\t\t\tcl[j] = current;\n\t\t\tlast = value[j];\n\t\t}\n\t\tcurrent++;\n\t\tint[] nOrder = new int[count];\n\t\tint[] cnt = new int[count];\n\t\tint[] nCl = new int[count];\n\t\tfor (int i = 1; i < count; i *= 2) {\n\t\t\tfor (int j = 0; j < count; j++) {\n\t\t\t\tnOrder[j] = order[j] - i;\n\t\t\t\tif (nOrder[j] < 0) {\n\t\t\t\t\tnOrder[j] += count;\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(cnt, 0, current, 0);\n\t\t\tfor (int j = 0; j < count; j++) {\n\t\t\t\tcnt[cl[j]]++;\n\t\t\t}\n\t\t\tfor (int j = 1; j < current; j++) {\n\t\t\t\tcnt[j] += cnt[j - 1];\n\t\t\t}\n\t\t\tfor (int j = count - 1; j >= 0; j--) {\n\t\t\t\torder[--cnt[cl[nOrder[j]]]] = nOrder[j];\n\t\t\t}\n\t\t\tnCl[order[0]] = 0;\n\t\t\tcurrent = 0;\n\t\t\tfor (int j = 1; j < count; j++) {\n\t\t\t\tint s1 = order[j] + i;\n\t\t\t\tif (s1 >= count) {\n\t\t\t\t\ts1 -= count;\n\t\t\t\t}\n\t\t\t\tint s2 = order[j - 1] + i;\n\t\t\t\tif (s2 >= count) {\n\t\t\t\t\ts2 -= count;\n\t\t\t\t}\n\t\t\t\tif (cl[order[j]] != cl[order[j - 1]] || cl[s1] != cl[s2]) {\n\t\t\t\t\tcurrent++;\n\t\t\t\t}\n\t\t\t\tnCl[order[j]] = current;\n\t\t\t}\n\t\t\tcurrent++;\n\t\t\tSystem.arraycopy(nCl, 0, cl, 0, count);\n\t\t}\n//\t\ts += s;\n//\t\tStringHash hash = new SimpleStringHash(s);\n//\t\tfinal String finalS = s;\n//\t\tArrayUtils.sort(order, new IntComparator() {\n//\t\t\t@Override\n//\t\t\tpublic int compare(int first, int second) {\n//\t\t\t\tint left = 0;\n//\t\t\t\tint right = count - 1;\n//\t\t\t\twhile (left < right) {\n//\t\t\t\t\tint middle = (left + right + 1) >> 1;\n//\t\t\t\t\tif (hash.hash(first, first + middle) == hash.hash(second, second + middle)) {\n//\t\t\t\t\t\tleft = middle;\n//\t\t\t\t\t} else {\n//\t\t\t\t\t\tright = middle - 1;\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t\treturn Character.compare(finalS.charAt(first + left), finalS.charAt(second + left));\n//\t\t\t}\n//\t\t});\n\t\tIntervalTree tree = new ReadOnlyIntervalTree(ArrayUtils.asLong(balance)) {\n\t\t\tprotected long neutralValue() {\n\t\t\t\treturn Integer.MAX_VALUE;\n\t\t\t}\n\n\t\t\tprotected long joinValue(long left, long right) {\n\t\t\t\treturn Math.min(left, right);\n\t\t\t}\n\t\t};\n\t\ts += s;\n\t\tint min = ArrayUtils.minElement(balance);\n\t\tfor (int i : order) {\n\t\t\tif (tree.query(i, count) >= balance[i] - freedom && tree.query(0, i - 1) >= balance[i] - freedom - balance[count]) {\n\t\t\t\tString answer = s.substring(i, i + count);\n\t\t\t\tfor (int j = 0; j < freedom; j++) {\n\t\t\t\t\tout.print('(');\n\t\t\t\t}\n\t\t\t\tout.print(answer);\n\t\t\t\tfor (int j = 0; j < balance[count]; j++) {\n\t\t\t\t\tout.print(')');\n\t\t\t\t}\n\t\t\t\tout.printLine();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass InputReader {\n\n\tprivate InputStream stream;\n\tprivate byte[] buf = new byte[1024];\n\tprivate int curChar;\n\tprivate int numChars;\n\tprivate SpaceCharFilter filter;\n\n\tpublic InputReader(InputStream stream) {\n\t\tthis.stream = stream;\n\t}\n\n\tpublic int read() {\n\t\tif (numChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= numChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (numChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n\n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tif (Character.isValidCodePoint(c))\n\t\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n\n\tpublic boolean isSpaceChar(int c) {\n\t\tif (filter != null)\n\t\t\treturn filter.isSpaceChar(c);\n\t\treturn isWhitespace(c);\n\t}\n\n\tpublic static boolean isWhitespace(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n\n\tpublic interface SpaceCharFilter {\n\t\tpublic boolean isSpaceChar(int ch);\n\t}\n}\n\nclass OutputWriter {\n\tprivate final PrintWriter writer;\n\n\tpublic OutputWriter(OutputStream outputStream) {\n\t\twriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n\t}\n\n\tpublic void print(Object...objects) {\n\t\tfor (int i = 0; i < objects.length; i++) {\n\t\t\tif (i != 0)\n\t\t\t\twriter.print(' ');\n\t\t\twriter.print(objects[i]);\n\t\t}\n\t}\n\n\tpublic void printLine() {\n\t\twriter.println();\n\t}\n\n\tpublic void print(char i) {\n\t\twriter.print(i);\n\t}\n\n\tpublic void close() {\n\t\twriter.close();\n\t}\n\n}\n\nclass ArrayUtils {\n\n\tpublic static int[] createOrder(int size) {\n\t\tint[] order = new int[size];\n\t\tfor (int i = 0; i < size; i++)\n\t\t\torder[i] = i;\n\t\treturn order;\n\t}\n\n\tpublic static int[] sort(int[] array, IntComparator comparator) {\n\t\treturn sort(array, 0, array.length, comparator);\n\t}\n\n\tpublic static int[] sort(int[] array, int from, int to, IntComparator comparator) {\n\t\tif (from == 0 && to == array.length)\n\t\t\tnew IntArray(array).inPlaceSort(comparator);\n\t\telse\n\t\t\tnew IntArray(array).subList(from, to).inPlaceSort(comparator);\n\t\treturn array;\n\t}\n\n\tpublic static int[] order(final long[] array) {\n\t\treturn sort(createOrder(array.length), new IntComparator() {\n\t\t\tpublic int compare(int first, int second) {\n\t\t\t\tif (array[first] < array[second])\n\t\t\t\t\treturn -1;\n\t\t\t\tif (array[first] > array[second])\n\t\t\t\t\treturn 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic static int minPosition(int[] array) {\n\t\treturn minPosition(array, 0, array.length);\n\t}\n\n\tpublic static int minPosition(int[] array, int from, int to) {\n        if (from >= to)\n            return -1;\n        int min = array[from];\n        int result = from;\n        for (int i = from + 1; i < to; i++) {\n            if (array[i] < min) {\n                min = array[i];\n                result = i;\n            }\n        }\n        return result;\n    }\n\n\tpublic static int minElement(int[] array) {\n\t\treturn array[minPosition(array)];\n\t}\n\n\tpublic static long[] asLong(int[] array) {\n\t\tlong[] result = new long[array.length];\n\t\tfor (int i = 0; i < array.length; i++)\n\t\t\tresult[i] = array[i];\n\t\treturn result;\n\t}\n\n}\n\nabstract class IntervalTree {\n\tprotected int size;\n\n\tpublic IntervalTree(int size, boolean shouldInit) {\n\t\tthis.size = size;\n\t\tint nodeCount = Math.max(1, Integer.highestOneBit(size) << 2);\n\t\tinitData(size, nodeCount);\n\t\tif (shouldInit)\n\t\t\tinit();\n\t}\n\n\tprotected abstract void initData(int size, int nodeCount);\n\tprotected abstract void initAfter(int root, int left, int right, int middle);\n\tprotected abstract void initBefore(int root, int left, int right, int middle);\n\tprotected abstract void initLeaf(int root, int index);\n\n\tprotected abstract long queryPostProcess(int root, int left, int right, int from, int to, int middle, long leftResult, long rightResult);\n\tprotected abstract void queryPreProcess(int root, int left, int right, int from, int to, int middle);\n\tprotected abstract long queryFull(int root, int left, int right, int from, int to);\n\tprotected abstract long emptySegmentResult();\n\n\tpublic void init() {\n\t\tif (size == 0)\n\t\t\treturn;\n\t\tinit(0, 0, size - 1);\n\t}\n\n\tprivate void init(int root, int left, int right) {\n\t\tif (left == right) {\n\t\t\tinitLeaf(root, left);\n\t\t} else {\n\t\t\tint middle = (left + right) >> 1;\n\t\t\tinitBefore(root, left, right, middle);\n\t\t\tinit(2 * root + 1, left, middle);\n\t\t\tinit(2 * root + 2, middle + 1, right);\n\t\t\tinitAfter(root, left, right, middle);\n\t\t}\n\t}\n\n\tpublic long query(int from, int to) {\n\t\treturn query(0, 0, size - 1, from, to);\n\t}\n\n\tprotected long query(int root, int left, int right, int from, int to) {\n\t\tif (left > to || right < from)\n\t\t\treturn emptySegmentResult();\n\t\tif (left >= from && right <= to)\n\t\t\treturn queryFull(root, left, right, from, to);\n\t\tint middle = (left + right) >> 1;\n\t\tqueryPreProcess(root, left, right, from, to, middle);\n\t\tlong leftResult = query(2 * root + 1, left, middle, from, to);\n\t\tlong rightResult = query(2 * root + 2, middle + 1, right, from, to);\n\t\treturn queryPostProcess(root, left, right, from, to, middle, leftResult, rightResult);\n\t}\n}\n\nabstract class ReadOnlyIntervalTree extends IntervalTree {\n\tprotected long[] value;\n\tprotected long[] array;\n\n\tprotected ReadOnlyIntervalTree(long[] array) {\n\t\tsuper(array.length, false);\n\t\tthis.array = array;\n\t\tinit();\n\t}\n\n\tprotected void initData(int size, int nodeCount) {\n\t\tvalue = new long[nodeCount];\n\t}\n\n\tprotected void initAfter(int root, int left, int right, int middle) {\n\t\tvalue[root] = joinValue(value[2 * root + 1], value[2 * root + 2]);\n\t}\n\n\tprotected void initBefore(int root, int left, int right, int middle) {\n\t}\n\n\tprotected void initLeaf(int root, int index) {\n\t\tvalue[root] = array[index];\n\t}\n\n\tprotected long queryPostProcess(int root, int left, int right, int from, int to, int middle, long leftResult, long rightResult) {\n\t\treturn joinValue(leftResult, rightResult);\n\t}\n\n\tprotected void queryPreProcess(int root, int left, int right, int from, int to, int middle) {\n\t}\n\n\tprotected long queryFull(int root, int left, int right, int from, int to) {\n\t\treturn value[root];\n\t}\n\n\tprotected long emptySegmentResult() {\n\t\treturn neutralValue();\n\t}\n\n\tprotected abstract long neutralValue();\n\tprotected abstract long joinValue(long left, long right);\n}\n\nabstract class IntCollection {\n\tpublic abstract IntIterator iterator();\n\tpublic abstract int size();\n\n}\n\ninterface IntIterator {\n\tpublic int value() throws NoSuchElementException;\n\t/*\n\t * @throws NoSuchElementException only if iterator already invalid\n\t */\n\tpublic void advance() throws NoSuchElementException;\n\tpublic boolean isValid();\n}\n\ninterface IntComparator {\n\n\tpublic int compare(int first, int second);\n}\n\nabstract class IntList extends IntCollection implements Comparable<IntList> {\n\tprivate static final int INSERTION_THRESHOLD = 16;\n\n\tpublic abstract int get(int index);\n\tpublic abstract void set(int index, int value);\n\n\tpublic IntIterator iterator() {\n\t\treturn new IntIterator() {\n\t\t\tprivate int size = size();\n\t\t\tprivate int index = 0;\n\n\t\t\tpublic int value() throws NoSuchElementException {\n\t\t\t\tif (!isValid())\n\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\treturn get(index);\n\t\t\t}\n\n\t\t\tpublic void advance() throws NoSuchElementException {\n\t\t\t\tif (!isValid())\n\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\tindex++;\n\t\t\t}\n\n\t\t\tpublic boolean isValid() {\n\t\t\t\treturn index < size;\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic IntList subList(final int from, final int to) {\n\t\treturn new SubList(from, to);\n\t}\n\n\tprivate void swap(int first, int second) {\n\t\tif (first == second)\n\t\t\treturn;\n\t\tint temp = get(first);\n\t\tset(first, get(second));\n\t\tset(second, temp);\n\t}\n\n\tpublic IntSortedList inPlaceSort(IntComparator comparator) {\n\t\tquickSort(0, size() - 1, (Integer.bitCount(Integer.highestOneBit(size()) - 1) * 5) >> 1, comparator);\n\t\treturn new IntSortedArray(this, comparator);\n\t}\n\n\tprivate void quickSort(int from, int to, int remaining, IntComparator comparator) {\n\t\tif (to - from < INSERTION_THRESHOLD) {\n\t\t\tinsertionSort(from, to, comparator);\n\t\t\treturn;\n\t\t}\n\t\tif (remaining == 0) {\n\t\t\theapSort(from, to, comparator);\n\t\t\treturn;\n\t\t}\n\t\tremaining--;\n\t\tint pivotIndex = (from + to) >> 1;\n\t\tint pivot = get(pivotIndex);\n\t\tswap(pivotIndex, to);\n\t\tint storeIndex = from;\n\t\tint equalIndex = to;\n\t\tfor (int i = from; i < equalIndex; i++) {\n\t\t\tint value = comparator.compare(get(i), pivot);\n\t\t\tif (value < 0)\n\t\t\t\tswap(storeIndex++, i);\n\t\t\telse if (value == 0)\n\t\t\t\tswap(--equalIndex, i--);\n\t\t}\n\t\tquickSort(from, storeIndex - 1, remaining, comparator);\n\t\tfor (int i = equalIndex; i <= to; i++)\n\t\t\tswap(storeIndex++, i);\n\t\tquickSort(storeIndex, to, remaining, comparator);\n\t}\n\n\tprivate void heapSort(int from, int to, IntComparator comparator) {\n\t\tfor (int i = (to + from - 1) >> 1; i >= from; i--)\n\t\t\tsiftDown(i, to, comparator, from);\n\t\tfor (int i = to; i > from; i--) {\n\t\t\tswap(from, i);\n\t\t\tsiftDown(from, i - 1, comparator, from);\n\t\t}\n\t}\n\n\tprivate void siftDown(int start, int end, IntComparator comparator, int delta) {\n\t\tint value = get(start);\n\t\twhile (true) {\n\t\t\tint child = ((start - delta) << 1) + 1 + delta;\n\t\t\tif (child > end)\n\t\t\t\treturn;\n\t\t\tint childValue = get(child);\n\t\t\tif (child + 1 <= end) {\n\t\t\t\tint otherValue = get(child + 1);\n\t\t\t\tif (comparator.compare(otherValue, childValue) > 0) {\n\t\t\t\t\tchild++;\n\t\t\t\t\tchildValue = otherValue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (comparator.compare(value, childValue) >= 0)\n\t\t\t\treturn;\n\t\t\tswap(start, child);\n\t\t\tstart = child;\n\t\t}\n\t}\n\n\tprivate void insertionSort(int from, int to, IntComparator comparator) {\n\t\tfor (int i = from + 1; i <= to; i++) {\n\t\t\tint value = get(i);\n\t\t\tfor (int j = i - 1; j >= from; j--) {\n\t\t\t\tif (comparator.compare(get(j), value) <= 0)\n\t\t\t\t\tbreak;\n\t\t\t\tswap(j, j + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic int hashCode() {\n\t\tint hashCode = 1;\n\t\tfor (IntIterator i = iterator(); i.isValid(); i.advance())\n\t\t\thashCode = 31 * hashCode + i.value();\n\t\treturn hashCode;\n\t}\n\n\tpublic boolean equals(Object obj) {\n\t\tif (!(obj instanceof IntList))\n\t\t\treturn false;\n\t\tIntList list = (IntList)obj;\n\t\tif (list.size() != size())\n\t\t\treturn false;\n\t\tIntIterator i = iterator();\n\t\tIntIterator j = list.iterator();\n\t\twhile (i.isValid()) {\n\t\t\tif (i.value() != j.value())\n\t\t\t\treturn false;\n\t\t\ti.advance();\n\t\t\tj.advance();\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic int compareTo(IntList o) {\n\t\tIntIterator i = iterator();\n\t\tIntIterator j = o.iterator();\n\t\twhile (true) {\n\t\t\tif (i.isValid()) {\n\t\t\t\tif (j.isValid()) {\n\t\t\t\t\tif (i.value() != j.value()) {\n\t\t\t\t\t\tif (i.value() < j.value())\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\tif (j.isValid())\n\t\t\t\t\treturn -1;\n\t\t\t\telse\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ti.advance();\n\t\t\tj.advance();\n\t\t}\n\t}\n\n\tprivate class SubList extends IntList {\n        private final int to;\n        private final int from;\n        private int size;\n\n        public SubList(int from, int to) {\n            this.to = to;\n            this.from = from;\n            size = to - from;\n        }\n\n        public int get(int index) {\n            if (index < 0 || index >= size)\n                throw new IndexOutOfBoundsException();\n            return IntList.this.get(index + from);\n        }\n\n        public void set(int index, int value) {\n            if (index < 0 || index >= size)\n                throw new IndexOutOfBoundsException();\n            IntList.this.set(index + from, value);\n        }\n\n        public int size() {\n            return size;\n        }\n\n\t}\n}\n\nabstract class IntSortedList extends IntList {\n\tprotected final IntComparator comparator;\n\n\tprotected IntSortedList(IntComparator comparator) {\n\t\tthis.comparator = comparator;\n\t}\n\n\tpublic void set(int index, int value) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\tpublic IntSortedList inPlaceSort(IntComparator comparator) {\n\t\tif (comparator == this.comparator)\n\t\t\treturn this;\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\tprotected void ensureSorted() {\n\t\tint size = size();\n\t\tif (size == 0)\n\t\t\treturn;\n\t\tint last = get(0);\n\t\tfor (int i = 1; i < size; i++) {\n\t\t\tint current = get(i);\n\t\t\tif (comparator.compare(last, current) > 0)\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\tlast = current;\n\t\t}\n\t}\n\n\tpublic IntSortedList subList(final int from, final int to) {\n\t\treturn new IntSortedList(comparator) {\n\t\t\tprivate int size = to - from;\n\n\t\t\tpublic int get(int index) {\n\t\t\t\tif (index < 0 || index >= size)\n\t\t\t\t\tthrow new IndexOutOfBoundsException();\n\t\t\t\treturn IntSortedList.this.get(index + from);\n\t\t\t}\n\n\t\t\tpublic int size() {\n\t\t\t\treturn size;\n\t\t\t}\n\t\t};\n\t}\n}\n\nclass IntArray extends IntList {\n\tprivate final int[] array;\n\n\tpublic IntArray(int[] array) {\n\t\tthis.array = array;\n\t}\n\n\tpublic int get(int index) {\n\t\treturn array[index];\n\t}\n\n\tpublic void set(int index, int value) {\n\t\tarray[index] = value;\n\t}\n\n\tpublic int size() {\n\t\treturn array.length;\n\t}\n\n}\n\nclass IntSortedArray extends IntSortedList {\n\tprivate final int[] array;\n\n\tpublic IntSortedArray(IntCollection collection, IntComparator comparator) {\n\t\tsuper(comparator);\n\t\tarray = new int[collection.size()];\n\t\tint i = 0;\n\t\tfor (IntIterator iterator = collection.iterator(); iterator.isValid(); iterator.advance())\n\t\t\tarray[i++] = iterator.value();\n\t\tensureSorted();\n\t}\n\n\tpublic int get(int index) {\n\t\treturn array[index];\n\t}\n\n\tpublic int size() {\n\t\treturn array.length;\n\t}\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint N, A[2000005], B[2000005], sum[2000005], ord[2000005];\npair<pair<int, int>, int> E[2000005];\nchar s[2000005];\nvoid SA() {\n  N <<= 1;\n  for (int i = 0; i < N; i++) ord[i] = (s[i] == ')');\n  for (int s = 1; s < N; s <<= 1) {\n    for (int i = 0; i < N; i++)\n      E[i] = (make_pair)(make_pair(ord[i], i + s < N ? ord[i + s] : N), i);\n    sort(E, E + N);\n    pair<int, int> now = pair<int, int>(-1, 0);\n    int rank = -1;\n    for (int i = 0; i < N; i++) {\n      if (E[i].first != now) rank++, now = E[i].first;\n      ord[E[i].second] = rank;\n    }\n  }\n  N >>= 1;\n}\nint main() {\n  scanf(\"%s\", s);\n  N = strlen(s);\n  for (int i = N; i < N + N; i++) s[i] = s[i - N];\n  SA();\n  for (int i = 1; i < N + 1; i++)\n    sum[i] = sum[i - 1] + (s[i - 1] == '(' ? 1 : -1);\n  A[0] = sum[N];\n  B[N - 1] = sum[N - 1];\n  for (int i = 1; i < N; i++) A[i] = min(A[i - 1], sum[i] + sum[N]);\n  for (int i = N - 2; i + 1; i--) B[i] = min(B[i + 1], sum[i]);\n  int Len = min(0, sum[N]), Ans = -1;\n  for (int i = 0; i < N; i++)\n    if (min(A[i], B[i]) - sum[i] == Len)\n      if (Ans == -1 || ord[i] < ord[Ans]) Ans = i;\n  for (int i = 0; i < -sum[N]; i++) putchar('(');\n  for (int i = 0; i < N; i++) putchar(s[Ans + i]);\n  for (int i = 0; i < sum[N]; i++) putchar(')');\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxN = 1000010;\nconst int maxL = 21;\nnamespace suffixArray {\nint ra[maxN], sa[maxN], P[maxL][maxN];\nint lg, len, cum[maxN];\nstruct node {\n  int a, b, c;\n} L[maxN], tmp[maxN];\ninline int cSort(int idx) {\n  int n = max(300, len + 2), sum = 0;\n  for (int i = 0; i < n; i++) cum[i] = 0;\n  for (int i = 0; i < len; i++) {\n    if (idx)\n      cum[L[i].a + 1]++;\n    else\n      cum[L[i].b + 1]++;\n  }\n  for (int i = 0; i < n; i++) sum += cum[i], cum[i] = sum - cum[i];\n  for (int i = 0; i < len; i++) {\n    if (idx)\n      tmp[cum[L[i].a + 1]++] = L[i];\n    else\n      tmp[cum[L[i].b + 1]++] = L[i];\n  }\n  for (int i = 0; i < len; i++) L[i] = tmp[i];\n}\ninline void construct(const char* s) {\n  len = strlen(s);\n  lg = 1;\n  for (int i = 0; i < len; i++) P[0][i] = int(s[i]);\n  for (int shift = 1; shift < len; shift <<= 1, lg++) {\n    for (int i = 0; i < len; i++) {\n      L[i].a = P[lg - 1][i];\n      L[i].b = i + shift < len ? P[lg - 1][i + shift] : -1;\n      L[i].c = i;\n    }\n    cSort(0);\n    cSort(1);\n    for (int i = 0; i < len; i++)\n      P[lg][L[i].c] = (i > 0 && L[i].a == L[i - 1].a && L[i].b == L[i - 1].b)\n                          ? P[lg][L[i - 1].c]\n                          : i;\n  }\n  lg--;\n  for (int i = 0; i < len; i++) sa[i] = 0;\n  for (int i = 0; i < len; i++) sa[P[lg][i]] = i;\n  for (int i = 0; i < len; i++) ra[sa[i]] = i;\n}\ninline int lcp(int i, int j) {\n  if (i == j) return len - i;\n  int l = 0;\n  for (int k = lg; k >= 0 && i < len && j < len; k--) {\n    if (P[k][i] == P[k][j]) {\n      i += 1 << k;\n      j += 1 << k;\n      l += 1 << k;\n    }\n  }\n  return l;\n}\n}  // namespace suffixArray\nchar s[maxN];\nint prefMin[maxN], sufMin[maxN], balance[maxN];\nint main() {\n  scanf(\"%s\", s);\n  int n = strlen(s);\n  suffixArray::construct(s);\n  s[n] = 0;\n  int open = 0, close = 0;\n  for (int i = 0; i < (n); ++i) {\n    if (s[i] == '(') {\n      ++open;\n      if (i == 0)\n        balance[i] = 1;\n      else\n        balance[i] = balance[i - 1] + 1;\n    } else {\n      ++close;\n      if (i == 0)\n        balance[i] = -1;\n      else\n        balance[i] = balance[i - 1] - 1;\n    }\n  }\n  for (int i = 0; i < (n); ++i) {\n    if (i == 0)\n      prefMin[i] = balance[i];\n    else\n      prefMin[i] = min(prefMin[i - 1], balance[i]);\n  }\n  for (int i = n - 1; i >= 0; --i) {\n    if (i == n - 1)\n      sufMin[i] = balance[i];\n    else\n      sufMin[i] = min(sufMin[i + 1], balance[i]);\n  }\n  int start = -1;\n  for (int i = 0; i < (n); ++i)\n    if (suffixArray::sa[i] < n) {\n      int p = suffixArray::sa[i];\n      if (p == 0) {\n        if (max(close - open, 0) + sufMin[p] >= 0) {\n          if (start == -1) {\n            start = p;\n          }\n        }\n      } else {\n        if (max(close - open, 0) + sufMin[p] - balance[p - 1] >= 0) {\n          if (prefMin[p - 1] + max(close - open, 0) + balance[n - 1] -\n                  balance[p - 1] >=\n              0) {\n            if (start == -1) {\n              start = p;\n            } else {\n              int common = suffixArray::lcp(start, p);\n              if (common < n - start) {\n                break;\n              } else {\n                if (suffixArray::ra[p + common] < suffixArray::ra[0]) {\n                  start = p;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  assert(start != -1);\n  while (open < close) putchar('('), ++open;\n  for (int i = 0; i < (n); ++i) putchar(s[(start + i) % n]);\n  while (open > close) putchar(')'), ++close;\n  puts(\"\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline T sqr(T x) {\n  return x * x;\n}\ntemplate <class T>\ninline string tostr(const T &x) {\n  stringstream ss;\n  ss << x;\n  return ss.str();\n}\ninline long long parse(const string &s) {\n  stringstream ss(s);\n  long long x;\n  ss >> x;\n  return x;\n}\nconst double EPS = 1e-9;\nconst int inf = 1000 * 1000 * 1000;\nconst char cinf = 102;\nconst long long linf = inf * 1ll * inf;\nconst double dinf = 1e200;\nconst double PI = 3.1415926535897932384626433832795l;\nint gcd(int a, int b) { return a ? gcd(b % a, a) : b; }\nlong long gcd(long long a, long long b) { return a ? gcd(b % a, a) : b; }\nlong long powmod(long long a, long long p, long long m) {\n  long long r = 1;\n  while (p) {\n    if (p & 1) r = r * a % m;\n    p >>= 1;\n    a = a * a % m;\n  }\n  return r;\n}\nstruct sufar {\n  static const int maxlen = 1001000;\n  int pn[maxlen], cn[maxlen];\n  int p[maxlen], cnt[maxlen], c[maxlen];\n  void doit(const char *s, int n) {\n    memset(cnt, 0, 200 * sizeof(int));\n    for (int i = 0; i < n; ++i) ++cnt[s[i]];\n    for (int i = 1; i < 200; ++i) cnt[i] += cnt[i - 1];\n    for (int i = 0; i < n; ++i) p[--cnt[s[i]]] = i;\n    c[p[0]] = 0;\n    int classes = 1;\n    for (int i = 1; i < n; ++i) {\n      if (s[p[i]] != s[p[i - 1]]) ++classes;\n      c[p[i]] = classes - 1;\n    }\n    for (int h = 0; (1 << h) < n; ++h) {\n      for (int i = 0; i < n; ++i) {\n        pn[i] = p[i] - (1 << h);\n        if (pn[i] < 0) pn[i] += n;\n      }\n      memset(cnt, 0, classes * sizeof(int));\n      for (int i = 0; i < n; ++i) ++cnt[c[pn[i]]];\n      for (int i = 1; i < classes; ++i) cnt[i] += cnt[i - 1];\n      for (int i = n - 1; i >= 0; --i) p[--cnt[c[pn[i]]]] = pn[i];\n      cn[p[0]] = 0;\n      classes = 1;\n      for (int i = 1; i < n; ++i) {\n        int mid1 = (p[i] + (1 << h)) % n, mid2 = (p[i - 1] + (1 << h)) % n;\n        if (c[p[i]] != c[p[i - 1]] || c[mid1] != c[mid2]) ++classes;\n        cn[p[i]] = classes - 1;\n      }\n      memcpy(c, cn, n * sizeof(int));\n    }\n  }\n};\nsufar sa;\nchar S[2001000];\nchar S0[1001000];\nint n;\nint main() {\n  gets(S);\n  n = strlen(S);\n  sa.doit(S, n);\n  vector<int> ip(n);\n  for (int i = 0; i < (n); ++i) {\n    ip[sa.p[i]] = i;\n  }\n  vector<int> mn1(n + 1), mn2(n + 1), A(n + 1);\n  for (int i = 0; i < (n); ++i) {\n    A[i + 1] = A[i] + (S[i] == '(' ? 1 : -1);\n    mn1[i + 1] = min(mn1[i], A[i + 1]);\n  }\n  mn2[n] = A[n];\n  for (int i = n - 1; i >= 0; --i) {\n    mn2[i] = min(mn2[i + 1], A[i]);\n  }\n  pair<pair<int, int>, pair<pair<int, int>, int>> res(\n      make_pair(inf, inf), make_pair(make_pair(-1, -1), -1));\n  for (int i = 0; i < (n); ++i) {\n    int m = min(mn1[i] + (A[n] - A[i]), mn2[i] - A[i]);\n    assert(m <= 0);\n    int a = -m;\n    int b = A[n] - m;\n    res = min(\n        res, make_pair(make_pair(a + b, ip[i]), make_pair(make_pair(a, b), i)));\n  }\n  rotate(S, S + res.second.second, S + n);\n  int d = 0;\n  for (int i = 0; i < (res.second.first.first); ++i) {\n    S0[i] = '(';\n    ++d;\n  }\n  printf(\"%s\", S0);\n  for (int i = 0; i < (res.second.first.second); ++i) {\n    S[n++] = ')';\n  }\n  puts(S);\n  for (int i = 0; i < (n); ++i) {\n    d += (S[i] == '(' ? 1 : -1);\n    assert(d >= 0);\n  }\n  assert(d == 0);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:66777216\")\nusing namespace std;\nstatic unsigned rnd() {\n  static int second = 124612741;\n  second ^= second << 13;\n  second ^= second >> 17;\n  return second ^= second << 5;\n}\ninline int fpow(int a, int st, int mod) {\n  int ans = 1;\n  while (st) {\n    if (st % 2) ans = (long long)ans * a % mod;\n    a = (long long)a * a % mod;\n    st /= 2;\n  }\n  return ans;\n}\nint invmod(int first, int second) {\n  int a = 1, b = 0, k;\n  for (; second; swap(first, second), swap(a, b)) {\n    k = first / second;\n    first -= second * k;\n    a -= b * k;\n  }\n  return a + max(b, 0);\n}\ninline int calcBits(int a) { return __builtin_popcount(a); }\nstruct Hash {\n  Hash() : x1(0), x2(0) {}\n  Hash(const int& x1, const int& x2) : x1(x1), x2(x2) {}\n  int x1, x2;\n  static int mod1, mod2;\n  static int p1, p2;\n  static int invp1, invp2;\n  static bool initCalled;\n  static const Hash ONE, ZERO, INVALID;\n  static Hash UNIT, INV_UNIT;\n  static bool prime(int a) {\n    if (a == 1) return 0;\n    for (int i = 2; i * i <= a; ++i) {\n      if (a % i == 0) return false;\n    }\n    return true;\n  }\n  static int pickModHelper(int start, int bad) {\n    int mn = 1000000000, best = -1;\n    for (int _n(start + 1000), i(start); i <= _n; i++) {\n      if (i == bad || !prime(i)) continue;\n      int cur = calcBits(i);\n      if (cur < mn) {\n        mn = cur;\n        best = i;\n      }\n    }\n    return best;\n  }\n  static void init() {\n    if (initCalled) return;\n    initCalled = true;\n    mod1 = pickModHelper((1 << 29) + rnd() % 1000000, -1);\n    while (!prime(mod1)) ++mod1;\n    mod2 = pickModHelper((1 << 29) + rnd() % 1000000, mod1);\n    invp1 = fpow(p1, mod1 - 2, mod1);\n    invp2 = fpow(p2, mod2 - 2, mod2);\n    INV_UNIT = Hash(invp1, invp2);\n  }\n  inline Hash& operator+=(const Hash& other) {\n    x1 += other.x1;\n    if (x1 >= Hash::mod1) x1 -= Hash::mod1;\n    x2 += other.x2;\n    if (x2 >= Hash::mod2) x2 -= Hash::mod2;\n    return *this;\n  }\n  inline Hash& operator-=(const Hash& other) {\n    x1 -= other.x1;\n    if (x1 < 0) x1 += Hash::mod1;\n    x2 -= other.x2;\n    if (x2 < 0) x2 += Hash::mod2;\n    return *this;\n  }\n  inline Hash& operator*=(const Hash& other) {\n    x1 = (long long)x1 * other.x1 % Hash::mod1;\n    x2 = (long long)x2 * other.x2 % Hash::mod2;\n    return *this;\n  }\n  inline Hash& operator*=(const int& other) {\n    x1 = (long long)x1 * other % Hash::mod1;\n    x2 = (long long)x2 * other % Hash::mod2;\n    return *this;\n  }\n  inline Hash& operator^=(const int& power) {\n    int st = power;\n    Hash ans(1, 1);\n    while (st) {\n      if (st % 2) ans *= *this;\n      x1 = (long long)x1 * x1 % Hash::mod1;\n      x2 = (long long)x2 * x2 % Hash::mod2;\n      st /= 2;\n    }\n    return *this;\n  }\n  inline bool operator==(const Hash& other) const {\n    return x1 == other.x1 && x2 == other.x2;\n  }\n};\nbool Hash::initCalled = false;\nint Hash::mod1 = 0;\nint Hash::mod2 = 0;\nint Hash::p1 = 23561;\nint Hash::p2 = 10000019;\nint Hash::invp1 = -1;\nint Hash::invp2 = -1;\nconst Hash Hash::ONE(1, 1);\nconst Hash Hash::ZERO(0, 0);\nconst Hash Hash::INVALID(-1, -1);\nHash Hash::UNIT(Hash::p1, Hash::p2);\nHash Hash::INV_UNIT(-1, -1);\ninline Hash operator+(const Hash& a, const Hash& b) {\n  Hash ans(a.x1 + b.x1, a.x2 + b.x2);\n  if (ans.x1 >= Hash::mod1) ans.x1 -= Hash::mod1;\n  if (ans.x2 >= Hash::mod2) ans.x2 -= Hash::mod2;\n  return ans;\n}\ninline Hash operator-(const Hash& a, const Hash& b) {\n  Hash ans(a.x1 - b.x1, a.x2 - b.x2);\n  if (ans.x1 < 0) ans.x1 += Hash::mod1;\n  if (ans.x2 < 0) ans.x2 += Hash::mod2;\n  return ans;\n}\ninline Hash operator*(const Hash& a, const Hash& b) {\n  return Hash((long long)a.x1 * b.x1 % Hash::mod1,\n              (long long)a.x2 * b.x2 % Hash::mod2);\n}\ninline Hash operator*(const Hash& a, const int& b) {\n  return Hash((long long)a.x1 * b % Hash::mod1,\n              (long long)a.x2 * b % Hash::mod2);\n}\ninline Hash operator^(const Hash& a, const int& power) {\n  int st = power;\n  Hash ans(1, 1), cur(a);\n  while (st) {\n    if (st % 2) ans *= cur;\n    cur *= cur;\n    st /= 2;\n  }\n  return ans;\n}\ninline Hash fpow(const Hash& a, const int& power) { return a ^ power; }\ninline Hash invmod(const Hash& a) {\n  return Hash(invmod(a.x1, Hash::mod1), invmod(a.x2, Hash::mod2));\n}\ntemplate <class H>\nstruct HashString : public string {\n  HashString() : string() { precalc(0); }\n  HashString(const HashString& other) : string(other) { precalc(size()); }\n  HashString(HashString&& other)\n      : hh(std::move(other.hh)), string(std::move(other)) {\n    precalc(size());\n  }\n  HashString(const string& other) : string(other) {\n    precalc(size());\n    build();\n  }\n  HashString(string&& other) : string(std::move(other)) {\n    precalc(size());\n    build();\n  }\n  HashString(const char* other) : string(other) {\n    precalc(size());\n    build();\n  }\n  inline void clear() {\n    hh.clear();\n    string::clear();\n  }\n  inline static H getPow(int p) {\n    if (p < haveN) {\n      return pp[p];\n    } else {\n      return fpow(H::UNIT, p);\n    }\n  }\n  inline static H getInvPow(size_t p) {\n    if (p < invpp.size()) {\n      return invpp[p];\n    } else {\n      return fpow(H::INV_UNIT, p);\n    }\n  }\n  inline H getInvRegister(const H& p) const {\n    if (p == register_) {\n      return registerValue_;\n    } else {\n      register_ = p;\n      return registerValue_ = invmod(p);\n    }\n  }\n  static void precalc(int N = 0) {\n    Hash::init();\n    if (haveN >= N) return;\n    pp.resize(N);\n    invpp.resize(N);\n    if (!haveN) {\n      pp[0] = H::ONE;\n      invpp[0] = H::ONE;\n      haveN = 1;\n    }\n    for (int i = haveN; i < N; ++i) {\n      pp[i] = pp[i - 1] * H::UNIT;\n      invpp[i] = invpp[i - 1] * H::INV_UNIT;\n    }\n    haveN = N;\n  }\n  inline void build() {\n    int curSize = size();\n    if (haveN <= curSize) {\n      precalc(curSize);\n    }\n    for (int i = hh.size(); i < curSize; ++i) {\n      H pr = i ? hh.back() : H::ZERO;\n      hh.push_back(pr + getPow(i) * (*this)[i]);\n    }\n  }\n  inline H getHash(int pos, int len) const {\n    if (len <= 0) return H::ZERO;\n    const int S = size();\n    if (pos + len - 1 < S) {\n      H ans = hh[pos + len - 1];\n      if (pos) {\n        ans -= hh[pos - 1];\n        ans *= getInvPow(pos);\n      }\n      return ans;\n    } else {\n      H head = hh.back();\n      if (pos) {\n        head -= hh[pos - 1];\n        head *= getInvPow(pos);\n      }\n      int full = -1, en = -1;\n      H mid = H::ZERO;\n      int midlen = 0;\n      if (len <= S) {\n        en = pos + len - 1 - S;\n        H tail = hh[en];\n        full = 0;\n        return head + tail * getPow(S - pos);\n      } else {\n        en = (pos + len - 1) % S;\n        H tail = hh[en];\n        full = (len - (S - pos) - (en + 1)) / S;\n        mid = hh.back() * (H::ONE - getInvPow(full * S)) *\n              getInvRegister(H::ONE - getInvPow(S));\n        return head + mid * getPow(S - pos) + tail * getPow(len - (en + 1));\n      }\n    }\n  }\n  inline HashString& operator+=(const char& ch) {\n    string::operator+=(ch);\n    build();\n    return *this;\n  }\n  inline HashString& operator+=(const HashString& other) {\n    string::operator+=(other);\n    build();\n    return *this;\n  }\n  inline bool operator==(const HashString& other) const {\n    return hh.back() == other.hh.back();\n  }\n  inline bool operator<(const HashString& other) const {\n    int s1 = size();\n    int s2 = other.size();\n    const int S = min(s1, s2);\n    int l = 0, r = S + 1;\n    while (r - l > 1) {\n      int xx = (r + l) / 2;\n      if (getHash(0, xx) == other.getHash(0, xx))\n        l = xx;\n      else\n        r = xx;\n    }\n    char c1 = 0, c2 = 0;\n    if (l < s1) c1 = (*this)[l];\n    if (l < s2) c2 = other[l];\n    return c1 < c2;\n  }\n  inline bool operator<=(const HashString& other) const {\n    return (*this == other) || (*this < other);\n  }\n  inline bool operator>(const HashString& other) const {\n    return !(*this == other) && !(*this < other);\n  }\n  inline bool operator>=(const HashString& other) const {\n    return !(*this < other);\n  }\n  inline bool operator!=(const HashString& other) const {\n    return !(*this == other);\n  }\n  inline void reserve(int N) {\n    hh.reserve(N);\n    string::reserve(N);\n  }\n  vector<H> hh;\n  static vector<H> pp, invpp;\n\n private:\n  mutable H register_, registerValue_;\n  static int haveN;\n};\ntemplate <>\nint HashString<Hash>::haveN = 0;\ntemplate <>\nvector<Hash> HashString<Hash>::pp = vector<Hash>();\ntemplate <>\nvector<Hash> HashString<Hash>::invpp = vector<Hash>();\ntemplate <class H, bool cyclic = true>\nstruct HashStringPiece {\n  explicit HashStringPiece(const HashString<H>& s, int pos, int len)\n      : s(s), pos(pos), len(len), hash(H::INVALID) {}\n  inline H getHash() const {\n    if (hash == H::INVALID) hash = s.getHash(pos, len);\n    return hash;\n  }\n  inline H getPartialHash(int needLen) const { return s.getHash(pos, needLen); }\n  inline char getChar(int i) const {\n    i += pos;\n    const int S = s.size();\n    if (i < S) return s[i];\n    if (!cyclic) return 0;\n    i -= S;\n    if (i < S) return s[i];\n    return s[i % S];\n  }\n  const HashString<H>& s;\n  const int pos, len;\n  mutable H hash;\n};\ntemplate <class H, class T>\nchar getHSPRangeChar(T beg, T en, int pos) {\n  for (T it = beg; it != en; ++it) {\n    if (pos < it->len) {\n      return it->getChar(pos);\n    }\n    pos -= it->len;\n  }\n  return 0;\n}\ntemplate <class H, class T>\nH getHSPRangeHash(T beg, T en, int len) {\n  H ans = H::ZERO;\n  int cur = 0;\n  for (T it = beg; it != en; ++it) {\n    if (len >= it->len) {\n      ans += it->getHash() * it->s.getPow(cur);\n      cur += it->len;\n      len -= it->len;\n    } else {\n      ans += it->getPartialHash(len) * it->s.getPow(cur);\n      break;\n    }\n  }\n  return ans;\n}\nint TB, IT;\ntemplate <class H, class T>\ninline int compareHSPRanges(T beg1, T en1, int len1, T beg2, T en2, int len2) {\n  if (beg1 == en1 && beg2 == en2) return 0;\n  if (beg1 == en1) return -1;\n  if (beg2 == en2) return 1;\n  int l = 0, r = min(len1, len2) + 1;\n  while (r - l > 1) {\n    int xx = (r + l) / 2;\n    auto h1 = getHSPRangeHash<H, T>(beg1, en1, xx);\n    auto h2 = getHSPRangeHash<H, T>(beg2, en2, xx);\n    if (h1 == h2)\n      l = xx;\n    else\n      r = xx;\n  }\n  char c1 = getHSPRangeChar<H, T>(beg1, en1, l);\n  char c2 = getHSPRangeChar<H, T>(beg2, en2, l);\n  if (c1 < c2)\n    return -1;\n  else if (c1 == c2)\n    return 0;\n  else\n    return 1;\n}\ntemplate <class H, class T>\ninline int compareHSPRanges(T beg1, T en1, T beg2, T en2) {\n  int len1 = 0;\n  for (T it = beg1; it != en1; ++it) {\n    len1 += it->len;\n  }\n  int len2 = 0;\n  for (T it = beg2; it != en2; ++it) {\n    len2 += it->len;\n  }\n  return compareHSPRanges<H, T>(beg1, en1, len1, beg2, en2, len2);\n}\nint a, b, c, d, n, m, k;\nchar str[1000002];\nint bal[2000002];\nHashString<Hash> s;\ninline string build(pair<pair<int, int>, int> a) {\n  string ans = \"\";\n  for (int _n((a.first.first) - 1), i(0); i <= _n; i++) ans += '(';\n  for (int _n((n)-1), i(0); i <= _n; i++) {\n    int cur = a.second + i;\n    if (cur >= n) cur -= n;\n    ans += str[cur];\n  }\n  for (int _n((a.first.second) - 1), i(0); i <= _n; i++) ans += ')';\n  return ans;\n}\nHashString<Hash> op, cl;\ninline bool better(pair<pair<int, int>, int> a, pair<pair<int, int>, int> b,\n                   const HashString<Hash>& s) {\n  HashStringPiece<Hash> A[3] = {HashStringPiece<Hash>(op, 0, a.first.first),\n                                HashStringPiece<Hash>(s, a.second, n),\n                                HashStringPiece<Hash>(cl, 0, a.first.second)};\n  HashStringPiece<Hash> B[3] = {HashStringPiece<Hash>(op, 0, b.first.first),\n                                HashStringPiece<Hash>(s, b.second, n),\n                                HashStringPiece<Hash>(cl, 0, b.first.second)};\n  int t = compareHSPRanges<Hash>(A, A + 3, B, B + 3);\n  if (t == -1)\n    return 1;\n  else\n    return 0;\n}\nint main() {\n  gets(str);\n  n = (int)strlen(str);\n  HashString<Hash> s(str);\n  HashString<Hash>::precalc(2 * n + 1);\n  op.reserve(n + 1);\n  cl.reserve(n + 1);\n  for (int _n((n)-1), i(0); i <= _n; i++) {\n    op += '(';\n    cl += ')';\n  }\n  c = 0;\n  for (int _n((n)-1), i(0); i <= _n; i++) {\n    if (str[i] == '(')\n      ++c;\n    else\n      --c;\n  }\n  bal[0] = 0;\n  for (int _n((2 * n) - 1), i(0); i <= _n; i++) {\n    if (i) bal[i] = bal[i - 1];\n    int cur = i;\n    if (i >= n) cur = i - n;\n    if (str[cur] == '(')\n      ++bal[i];\n    else\n      --bal[i];\n  }\n  int blen = 1000000000;\n  pair<pair<int, int>, int> best = make_pair(make_pair(0, 0), 0);\n  stack<pair<int, int> > s1, s2;\n  for (int _n((n)-1), i(0); i <= _n; i++) {\n    int new_element = bal[i];\n    int minima = s1.empty() ? new_element : min(new_element, s1.top().second);\n    s1.push(make_pair(new_element, minima));\n  }\n  for (int _n((n)-1), cyc(0); cyc <= _n; cyc++) {\n    int current_minimum = -1000000000;\n    if (s1.empty() || s2.empty())\n      current_minimum = s1.empty() ? s2.top().second : s1.top().second;\n    else\n      current_minimum = min(s1.top().second, s2.top().second);\n    int p = 0;\n    if (cyc) p = bal[cyc - 1];\n    int mn = current_minimum - p;\n    int beg = max(0, -mn);\n    int en = c + beg;\n    int len = beg + en + n;\n    if (len < blen ||\n        (len == blen && better(make_pair(make_pair(beg, en), cyc), best, s))) {\n      blen = len;\n      best = make_pair(make_pair(beg, en), cyc);\n    }\n    if (s2.empty()) {\n      while (!s1.empty()) {\n        int element = s1.top().first;\n        s1.pop();\n        int minima = s2.empty() ? element : min(element, s2.top().second);\n        s2.push(make_pair(element, minima));\n      }\n    }\n    s2.pop();\n    int new_element = bal[cyc + n];\n    int minima = s1.empty() ? new_element : min(new_element, s1.top().second);\n    s1.push(make_pair(new_element, minima));\n  }\n  string ans = build(best);\n  printf(\"%s\\n\", ans.c_str());\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int MAXN = 1e6 + 10;\nchar buf[MAXN];\nint n;\nint pre[MAXN], suc[MAXN];\ninline int tr(int x) { return x > n ? x - n : x; }\nconst int MAXP = MAXN << 1;\nint R[MAXP], nxt[MAXP][2], fail[MAXP];\nint tot, lst, at[MAXN];\nvoid extend(int x, int id) {\n  static int p, v, t, now;\n  R[now = ++tot] = R[p = lst] + 1;\n  at[id] = lst = now;\n  for (; p && !nxt[p][x]; p = fail[p]) nxt[p][x] = now;\n  if (!p)\n    fail[now] = 1;\n  else {\n    t = nxt[p][x];\n    if (R[t] == R[p] + 1)\n      fail[now] = t;\n    else {\n      R[v = ++tot] = R[p] + 1;\n      memcpy(nxt[v], nxt[t], sizeof(nxt[0]));\n      fail[v] = fail[t];\n      fail[t] = fail[now] = v;\n      for (; p && nxt[p][x] == t; p = fail[p]) nxt[p][x] = v;\n    }\n  }\n}\nint head[MAXP], nt[MAXP];\nint dep[MAXP], top[MAXP], son[MAXP], sz[MAXP];\nvoid dfs(int u) {\n  sz[u] = 1;\n  for (int i = head[u]; i; i = nt[i]) {\n    dep[i] = dep[u] + 1;\n    dfs(i);\n    sz[u] += sz[i];\n    if (sz[i] > sz[son[u]]) son[u] = i;\n  }\n}\nvoid dfs2(int u) {\n  if (son[u]) top[son[u]] = top[u], dfs2(son[u]);\n  for (int i = head[u]; i; i = nt[i])\n    if (i != son[u]) top[i] = i, dfs2(i);\n}\nint LCP(int x, int y) {\n  x = at[tr(x)], y = at[tr(y)];\n  while (top[x] != top[y])\n    dep[top[x]] > dep[top[y]] ? x = fail[top[x]] : y = fail[top[y]];\n  return R[dep[x] < dep[y] ? x : y];\n}\nvoid build() {\n  tot = lst = 1;\n  for (int i = n; i; --i) extend(buf[i] == ')', i);\n  for (int i = 2; i <= tot; ++i) nt[i] = head[fail[i]], head[fail[i]] = i;\n  top[1] = 1;\n  dfs(1);\n  dfs2(1);\n}\nbool cmp(int x, int y) {\n  int lcp = LCP(x, y);\n  if (lcp + y == n + 1) lcp += LCP(x + lcp, 1);\n  if (lcp >= n) return false;\n  return buf[tr(x + lcp)] > buf[tr(y + lcp)];\n}\nint main() {\n  std::ios_base::sync_with_stdio(false), std::cin.tie(0);\n  std::cin >> buf + 1;\n  n = strlen(buf + 1);\n  build();\n  int ct = 0;\n  for (int i = 1; i <= n; ++i) suc[i] = pre[i] = ct += buf[i] == '(' ? 1 : -1;\n  for (int i = n - 1; ~i; --i) suc[i] = std::min(suc[i], suc[i + 1]);\n  int best = -1;\n  int pmin = 0;\n  for (int i = 0; i <= n; ++i) {\n    pmin = std::min(pmin, pre[i]);\n    bool can = true;\n    if (ct <= 0) {\n      can &= suc[i + 1] - pre[i] - ct >= 0;\n      can &= pmin + (pre[n] - pre[i]) - ct >= 0;\n    }\n    if (ct > 0) {\n      can &= suc[i + 1] - pre[i] >= 0;\n      can &= std::min(pmin, pre[i] - ct) + (pre[n] - pre[i]) >= 0;\n    }\n    if (can) {\n      if (best == -1 || cmp(best, i + 1)) best = i + 1;\n    }\n  }\n  if (ct < 0)\n    for (int i = 1; i <= std::abs(ct); ++i) std::cout << '(';\n  for (int i = 0; i < n; ++i) std::cout << buf[tr(best + i)];\n  if (ct > 0)\n    for (int i = 1; i <= ct; ++i) std::cout << ')';\n  std::cout << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class C>\nvoid mini(C& a4, C b4) {\n  a4 = min(a4, b4);\n}\ntemplate <class C>\nvoid maxi(C& a4, C b4) {\n  a4 = max(a4, b4);\n}\ntemplate <class T1, class T2>\nostream& operator<<(ostream& out, pair<T1, T2> pair) {\n  return out << \"(\" << pair.first << \", \" << pair.second << \")\";\n}\ntemplate <class A, class B, class C>\nstruct Triple {\n  A first;\n  B second;\n  C third;\n};\ntemplate <class T>\nvoid ResizeVec(T&, vector<long long>) {}\ntemplate <class T>\nvoid ResizeVec(vector<T>& vec, vector<long long> sz) {\n  vec.resize(sz[0]);\n  sz.erase(sz.begin());\n  if (sz.empty()) {\n    return;\n  }\n  for (T& v : vec) {\n    ResizeVec(v, sz);\n  }\n}\ninline bool leq(long long a1, long long a2, long long b1, long long b2) {\n  return (a1 < b1 || a1 == b1 && a2 <= b2);\n}\ninline bool leq(long long a1, long long a2, long long a3, long long b1,\n                long long b2, long long b3) {\n  return (a1 < b1 || a1 == b1 && leq(a2, a3, b2, b3));\n}\nstatic void radixPass(long long* a, long long* b, long long* r, long long n,\n                      long long K) {\n  long long* c = new long long[K + 1];\n  for (long long i = 0; i <= K; i++) c[i] = 0;\n  for (long long i = 0; i < n; i++) c[r[a[i]]]++;\n  for (long long i = 0, sum = 0; i <= K; i++) {\n    long long t = c[i];\n    c[i] = sum;\n    sum += t;\n  }\n  for (long long i = 0; i < n; i++) b[c[r[a[i]]]++] = a[i];\n  delete[] c;\n}\nvoid suffixArray(long long* s, long long* SA, long long n, long long K) {\n  long long n0 = (n + 2) / 3, n1 = (n + 1) / 3, n2 = n / 3, n02 = n0 + n2;\n  long long* s12 = new long long[n02 + 3];\n  s12[n02] = s12[n02 + 1] = s12[n02 + 2] = 0;\n  long long* SA12 = new long long[n02 + 3];\n  SA12[n02] = SA12[n02 + 1] = SA12[n02 + 2] = 0;\n  long long* s0 = new long long[n0];\n  long long* SA0 = new long long[n0];\n  for (long long i = 0, j = 0; i < n + (n0 - n1); i++)\n    if (i % 3 != 0) s12[j++] = i;\n  radixPass(s12, SA12, s + 2, n02, K);\n  radixPass(SA12, s12, s + 1, n02, K);\n  radixPass(s12, SA12, s, n02, K);\n  long long name = 0, c0 = -1, c1 = -1, c2 = -1;\n  for (long long i = 0; i < n02; i++) {\n    if (s[SA12[i]] != c0 || s[SA12[i] + 1] != c1 || s[SA12[i] + 2] != c2) {\n      name++;\n      c0 = s[SA12[i]];\n      c1 = s[SA12[i] + 1];\n      c2 = s[SA12[i] + 2];\n    }\n    if (SA12[i] % 3 == 1)\n      s12[SA12[i] / 3] = name;\n    else\n      s12[SA12[i] / 3 + n0] = name;\n  }\n  if (name < n02) {\n    suffixArray(s12, SA12, n02, name);\n    for (long long i = 0; i < n02; i++) s12[SA12[i]] = i + 1;\n  } else\n    for (long long i = 0; i < n02; i++) SA12[s12[i] - 1] = i;\n  for (long long i = 0, j = 0; i < n02; i++)\n    if (SA12[i] < n0) s0[j++] = 3 * SA12[i];\n  radixPass(s0, SA0, s, n0, K);\n  for (long long p = 0, t = n0 - n1, k = 0; k < n; k++) {\n    long long i = (SA12[t] < n0 ? SA12[t] * 3 + 1 : (SA12[t] - n0) * 3 + 2);\n    long long j = SA0[p];\n    if (SA12[t] < n0 ? leq(s[i], s12[SA12[t] + n0], s[j], s12[j / 3])\n                     : leq(s[i], s[i + 1], s12[SA12[t] - n0 + 1], s[j],\n                           s[j + 1], s12[j / 3 + n0])) {\n      SA[k] = i;\n      t++;\n      if (t == n02)\n        for (k++; p < n0; p++, k++) SA[k] = SA0[p];\n    } else {\n      SA[k] = j;\n      p++;\n      if (p == n0)\n        for (k++; t < n02; t++, k++)\n          SA[k] = (SA12[t] < n0 ? SA12[t] * 3 + 1 : (SA12[t] - n0) * 3 + 2);\n    }\n  }\n  delete[] s12;\n  delete[] SA12;\n  delete[] SA0;\n  delete[] s0;\n}\nconst long long N = 2e6 + 5;\nlong long s[N];\nlong long SA[N];\nvector<long long> MinK(vector<long long> vec, long long k) {\n  vector<long long> res;\n  long long n = ((long long)(vec).size());\n  if (n - k + 1 <= 0) {\n    return vector<long long>();\n  }\n  res.resize(n - k + 1);\n  vector<long long> que;\n  long long beg;\n  for (long long i = 0; i < ((long long)(vec).size()); i++) {\n    while (!que.empty() && vec[que.back()] >= vec[i]) {\n      que.pop_back();\n    }\n    que.push_back(i);\n    beg = min(beg, ((long long)(que).size()) - 1);\n    if (que[beg] <= i - k) {\n      beg++;\n    }\n    if (i >= k - 1) {\n      res[i - k + 1] = vec[que[beg]];\n    }\n  }\n  for (long long i = (1); i <= (k - 1); ++i) {\n    res.push_back(N);\n  }\n  return res;\n}\nlong long SAinv[N];\nint main() {\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  string br;\n  cin >> br;\n  ;\n  long long n = ((long long)(br).size());\n  br = ' ' + br;\n  for (long long i = (1); i <= (n); ++i) {\n    if (br[i] == '(') {\n      s[i] = 1;\n    } else {\n      s[i] = 2;\n    }\n  }\n  vector<long long> bilv(2 * n + 5);\n  bilv.push_back(0);\n  for (long long i = (n + 1); i <= (2 * n); ++i) {\n    s[i] = s[i - n];\n    br += br[i - n];\n  }\n  long long b = 0;\n  for (long long i = (1); i <= (2 * n); ++i) {\n    if (s[i] == 1) {\n      b++;\n    } else {\n      b--;\n    }\n    bilv[i] = b;\n  }\n  long long bil = bilv[n];\n  suffixArray(s + 1, SA + 1, 2 * n, 2);\n  for (long long i = (1); i <= (2 * n); ++i) {\n    SAinv[SA[i] + 1] = i;\n  }\n  vector<long long> mins = MinK(bilv, n);\n  ;\n  ;\n  ;\n  long long best = 0;\n  SAinv[0] = N;\n  for (long long i = (0); i <= (n - 1); ++i) {\n    if (mins[i + 1] >= bilv[i] + min(0ll, bil)) {\n      if (SAinv[i + 1] < SAinv[best]) {\n        ;\n        best = i + 1;\n      }\n    }\n  }\n  if (0) cout << \"SAinv:\\n\";\n  for (long long i = (1); i <= (n); ++i) {\n    if (0) cout << SAinv[i] << \" \";\n  }\n  if (0) cout << \"\\n\";\n  ;\n  if (bil < 0) {\n    for (long long i = (1); i <= (-bil); ++i) {\n      cout << '(';\n    }\n  }\n  for (long long i = (best); i <= (best + n - 1); ++i) {\n    cout << br[i];\n  }\n  if (bil >= 0) {\n    for (long long i = (1); i <= (bil); ++i) {\n      cout << ')';\n    }\n  }\n  cout << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int NMax = 1000005;\nconst int logMax = 20;\nint N;\nchar S[NMax * 2];\nint Partial[NMax * 2];\nint Tree[NMax * 8];\nint open, closed, last;\nstruct SArray {\n  int pos;\n  int nb[2];\n} L[2 * NMax], Aux[2 * NMax];\nvector<int> V[2 * NMax];\nint Cnt[NMax * 2], Ind[NMax * 2];\nint P[2][NMax * 2];\nvoid Read() {\n  scanf(\"%s\", S + 1);\n  N = strlen(S + 1);\n  for (int i = N + 1; i <= 2 * N; i++) S[i] = S[i - N];\n}\nvoid precalcPartial() {\n  for (int i = 1; i <= N * 2; i++) {\n    if (S[i] == '(')\n      Partial[i] = Partial[i - 1] + 1;\n    else\n      Partial[i] = Partial[i - 1] - 1;\n  }\n}\ninline bool cmp(SArray a, SArray b) {\n  if (a.nb[0] == b.nb[0]) return a.nb[1] < b.nb[1];\n  return a.nb[0] < b.nb[0];\n}\nvoid Sort() {\n  for (int i = 1; i <= N * 2; i++) {\n    Cnt[L[i].nb[1]]++;\n  }\n  int p = 0;\n  Ind[0] = 1;\n  for (int i = 1; i <= 2 * N; i++) Ind[i] = Ind[i - 1] + Cnt[i - 1];\n  for (int i = 1; i <= 2 * N; i++) Aux[Ind[L[i].nb[1]]++] = L[i];\n  Cnt[0] = Ind[0] = 0;\n  for (int i = 1; i <= 2 * N; i++) L[i] = Aux[i], Cnt[i] = 0, Ind[i] = 0;\n  for (int i = 1; i <= N * 2; i++) {\n    Cnt[L[i].nb[0]]++;\n  }\n  Ind[0] = 1;\n  for (int i = 1; i <= 2 * N; i++) Ind[i] = Ind[i - 1] + Cnt[i - 1];\n  for (int i = 1; i <= 2 * N; i++) Aux[Ind[L[i].nb[0]]++] = L[i];\n  Cnt[0] = Ind[0] = 0;\n  for (int i = 1; i <= 2 * N; i++) L[i] = Aux[i], Cnt[i] = 0, Ind[i] = 0;\n}\nvoid buildSuffixArray() {\n  for (int i = 1; i <= N * 2; i++) P[0][i] = S[i] - '(' + 1;\n  int ind = 1;\n  for (int i = 1; (1 << (i - 1)) <= N * 2; i++, ind ^= 1) {\n    last = i;\n    for (int j = 1; j <= N * 2; j++) {\n      L[j].pos = j;\n      L[j].nb[0] = P[ind ^ 1][j];\n      L[j].nb[1] =\n          (j + (1 << (i - 1)) <= N * 2) ? P[ind ^ 1][j + (1 << (i - 1))] : 0;\n    }\n    Sort();\n    int cnt = 0;\n    for (int j = 1; j <= 2 * N; j++) {\n      if (L[j].nb[0] != L[j - 1].nb[0] || L[j].nb[1] != L[j - 1].nb[1]) ++cnt;\n      P[ind][L[j].pos] = cnt;\n    }\n  }\n  last = ind ^ 1;\n}\nvoid precalcOpenClosed() {\n  for (int i = 1; i <= N; i++) {\n    if (S[i] == '(')\n      ++open;\n    else\n      ++closed;\n  }\n}\nvoid buildTree(int K, int L, int R) {\n  if (L == R) {\n    Tree[K] = Partial[L];\n    return;\n  }\n  buildTree(K * 2, L, (L + R) / 2);\n  buildTree(K * 2 + 1, (L + R) / 2 + 1, R);\n  Tree[K] = min(Tree[K * 2], Tree[K * 2 + 1]);\n}\nint Query(int K, int L, int R, int x, int y) {\n  if (L > R || L > y || R < x) return 1000000005;\n  if (L >= x && R <= y) return Tree[K];\n  int a = Query(K * 2, L, (L + R) / 2, x, y);\n  int b = Query(K * 2 + 1, (L + R) / 2 + 1, R, x, y);\n  return min(a, b);\n}\nvoid ifOpenLessThenClosed() {\n  int suff = -1, Min = 1000000005;\n  for (int i = 1; i <= N; i++) {\n    if (Query(1, 1, 2 * N, i, i + N - 1) - Partial[i - 1] + closed - open < 0)\n      continue;\n    if (Min > P[last][i]) {\n      Min = P[last][i];\n      suff = i;\n    }\n  }\n  for (int i = 1; i <= closed - open; i++) printf(\"(\");\n  for (int i = suff; i - suff + 1 <= N; i++) printf(\"%c\", S[i]);\n  printf(\"\\n\");\n}\nvoid ifClosedLessThenOpen() {\n  int suff = -1, Min = 1000000005;\n  for (int i = 1; i <= N; i++) {\n    if (Query(1, 1, 2 * N, i, i + N - 1) - Partial[i - 1] < 0) continue;\n    if (Min > P[last][i]) {\n      Min = P[last][i];\n      suff = i;\n    }\n  }\n  for (int i = suff; i - suff + 1 <= N; i++) printf(\"%c\", S[i]);\n  for (int i = 1; i <= open - closed; i++) printf(\")\");\n  printf(\"\\n\");\n}\nint main() {\n  Read();\n  precalcPartial();\n  buildSuffixArray();\n  buildTree(1, 1, 2 * N);\n  precalcOpenClosed();\n  if (open >= closed)\n    ifClosedLessThenOpen();\n  else\n    ifOpenLessThenClosed();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:100000000\")\nusing namespace std;\nconst long double pi = acos(-1.0);\nconst int N = (int)2e6 + 10;\nconst int M = (int)1e9 + 9;\nconst int H = 2;\nconst long long P[2] = {17239, 23917};\nlong long h[2][N], ppow[2][N];\nint n, prefsum[N], minprefsum[N], sufsum[N], minsufsum[N];\nchar s[N];\nbool equal(int i, int j, int len) {\n  for (int t = 0; t < H; ++t)\n    if (((h[t][i + len] - h[t][i] * ppow[t][len]) -\n         (h[t][j + len] - h[t][j] * ppow[t][len])) %\n            M !=\n        0)\n      return false;\n  return true;\n}\nbool is_less(int i, int j) {\n  int l = 0, r = n;\n  while (l < r) {\n    int q = (l + r + 1) / 2;\n    if (equal(i, j, q))\n      l = q;\n    else\n      r = q - 1;\n  }\n  return (s[i + l] < s[j + l]);\n}\nint main() {\n  scanf(\"%s\", s);\n  n = strlen(s);\n  for (int i = 0; i < n; ++i) s[i + n] = s[i];\n  for (int j = 0; j < 2; ++j) {\n    h[j][0] = 0, ppow[j][0] = 1;\n    for (int i = 0; i < 2 * n; ++i) {\n      h[j][i + 1] = (h[j][i] * P[j] + s[i]) % M;\n      ppow[j][i + 1] = (ppow[j][i] * P[j]) % M;\n    }\n  }\n  prefsum[0] = 0;\n  for (int i = 0; i < n; ++i)\n    prefsum[i + 1] = prefsum[i] + ((s[i] == '(') ? 1 : -1);\n  minprefsum[0] = prefsum[0];\n  for (int i = 0; i < n; ++i)\n    minprefsum[i + 1] = min(minprefsum[i], prefsum[i + 1]);\n  minsufsum[n] = prefsum[n];\n  for (int i = n - 1; i >= 0; --i)\n    minsufsum[i] = min(minsufsum[i + 1], prefsum[i]);\n  int total = prefsum[n], bound = min(total, 0);\n  vector<int> a;\n  for (int i = 0; i < n; ++i)\n    if ((minsufsum[i + 1] >= bound + prefsum[i]) &&\n        (minprefsum[i] >= bound - total + prefsum[i]))\n      a.push_back(i);\n  int best = a[0];\n  for (int i = 1; i < ((int)(a).size()); ++i)\n    if (is_less(a[i], best)) best = a[i];\n  for (int i = 0; i < -total; ++i) printf(\"(\");\n  for (int i = 0; i < n; ++i) printf(\"%c\", s[best + i]);\n  for (int i = 0; i < total; ++i) printf(\")\");\n  printf(\"\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e6 + 10;\nconst int mod = 1e9 + 9;\nconst int base = 11;\nstring s;\nint n;\nint hsh[maxn], pw[maxn];\nint pm[maxn], sm[maxn], a[maxn];\nint get_hsh(int f, int len) {\n  int s = f + len - 1;\n  if (f == 0) return hsh[s];\n  return (hsh[s] - 1ll * hsh[f - 1] * pw[len] % mod + mod) % mod;\n}\nint get_min(int v, int u, int times = 0) {\n  if (v > u) return 1 ^ get_min(u, v, times);\n  int lo = 0, hi = n - u + 1;\n  while (hi - lo > 1) {\n    int mid = (lo + hi) >> 1;\n    if (get_hsh(v, mid) == get_hsh(u, mid))\n      lo = mid;\n    else\n      hi = mid;\n  }\n  if (lo != n - u) return (s[v + lo] == '(');\n  if (times == 3) return true;\n  v = (v + lo) % n, u = (u + lo) % n;\n  return get_min(v, u, times + 1);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin >> s;\n  n = s.size();\n  for (int i = 0; i < n; i++)\n    a[i] = (i > 0 ? a[i - 1] : 0) + (s[i] == '(') - (s[i] == ')');\n  int tot = a[n - 1];\n  for (int i = 0; i < n; i++) pm[i] = min((i > 0 ? pm[i - 1] : n), a[i]);\n  for (int i = n - 1; i >= 0; i--)\n    sm[i] = min((i < n - 1 ? sm[i + 1] : n), a[i]);\n  vector<int> candid;\n  for (int i = 0; i < n; i++) {\n    int mnm;\n    if (i == 0)\n      mnm = sm[0];\n    else\n      mnm = min(sm[i] - a[i - 1], pm[i - 1] + (a[n - 1] - a[i - 1]));\n    if (tot >= 0) {\n      if (mnm >= 0) candid.push_back(i);\n    } else {\n      if (mnm == tot) candid.push_back(i);\n    }\n  }\n  pw[0] = 1;\n  for (int i = 1; i < n; i++) pw[i] = 1ll * pw[i - 1] * base % mod;\n  if (s[0] == '(')\n    hsh[0] = 1;\n  else\n    hsh[0] = 2;\n  for (int i = 1; i < n; i++)\n    hsh[i] = (1ll * hsh[i - 1] * base + 1 + (s[i] == ')')) % mod;\n  int m = candid.size();\n  while (candid.size() > 1) {\n    int i = candid[m - 1], j = candid[m - 2];\n    m--;\n    candid.pop_back(), candid.pop_back();\n    if (get_min(i, j) == true)\n      candid.push_back(i);\n    else\n      candid.push_back(j);\n  }\n  int st = candid[0];\n  if (tot < 0)\n    for (int i = 0; i < abs(tot); i++) cout << '(';\n  for (int i = st; i < n; i++) cout << s[i];\n  for (int i = 0; i < st; i++) cout << s[i];\n  if (tot > 0)\n    for (int i = 0; i < tot; i++) cout << ')';\n  cout << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool b[2000005];\nchar c[2000005];\nint h[2000005], q[2000005];\nint i, j, k, n, H, T, t;\nint main() {\n  scanf(\"%s\", c + 1);\n  n = strlen(c + 1);\n  for (i = 1; i <= n; i++) t += (c[i] == '(') ? 1 : -1;\n  for (i = n + 1; i <= n * 2; i++) c[i] = c[i - n];\n  if (t < 0)\n    for (i = 1; i <= -t; i++) putchar('(');\n  for (i = 1; i <= 2 * n; i++) h[i] = h[i - 1] + ((c[i] == '(') ? 1 : -1);\n  H = 1;\n  T = 0;\n  for (i = 1; i <= n; i++) {\n    for (; T && h[i] < h[q[T]]; T--)\n      ;\n    q[++T] = i;\n  }\n  for (i = 1; i <= n; i++) {\n    if (h[q[H]] - h[i - 1] < min(t, 0)) b[i] = 1;\n    for (; T >= H && h[n + i] < h[q[T]]; T--)\n      ;\n    q[++T] = n + i;\n    if (q[H] == i) H++;\n  }\n  for (i = 1, j = 2;;) {\n    for (; b[i]; i++)\n      ;\n    for (; b[j]; j++)\n      ;\n    if (i == j)\n      for (j++; b[j]; j++)\n        ;\n    if (i > n || j > n) break;\n    for (k = 0; k < n && c[i + k] == c[j + k]; k++)\n      ;\n    if (c[i + k] < c[j + k])\n      j = j + k + 1;\n    else\n      i = i + k + 1;\n  }\n  if (j < i) i = j;\n  for (j = i; j < n + i; j++) putchar(c[j]);\n  if (t > 0)\n    for (i = 1; i <= t; i++) putchar(')');\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool debug = 1;\nint n, m, k;\nint dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\nlong long ln, lk, lm;\nclock_t start = clock();\ndouble runt() { return ((double)(clock() - start)) / CLOCKS_PER_SEC; }\nchar s[2000015];\nint A, B;\nstruct SuffixArray {\n  int sa[2000015];\n  int c[2000015], x[2000015], y[2000015];\n  void get_SA(const char *s, int n, int m) {\n    for (int(i) = 1; (i) <= (int)(n); (i)++) ++c[x[i] = s[i]];\n    for (int i = 2; i <= m; ++i) c[i] += c[i - 1];\n    for (int i = n; i >= 1; --i) sa[c[x[i]]--] = i;\n    for (int k = 1; k <= n; k <<= 1) {\n      int num = 0;\n      for (int i = n - k + 1; i <= n; ++i) y[++num] = i;\n      for (int i = 1; i <= n; ++i)\n        if (sa[i] > k) y[++num] = sa[i] - k;\n      for (int i = 1; i <= m; ++i) c[i] = 0;\n      for (int i = 1; i <= n; ++i) ++c[x[i]];\n      for (int i = 2; i <= m; ++i) c[i] += c[i - 1];\n      for (int i = n; i >= 1; --i) {\n        sa[c[x[y[i]]]--] = y[i];\n        y[i] = 0;\n      }\n      swap(x, y);\n      x[sa[1]] = 1;\n      num = 1;\n      for (int i = 2; i <= n; ++i)\n        x[sa[i]] =\n            (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + k] == y[sa[i - 1] + k])\n                ? num\n                : ++num;\n      if (num == n) break;\n      m = num;\n    }\n  }\n} sa;\nint T[2000015][22];\nvoid init(int n) {\n  for (int j = 1; (1 << j) <= n; j++) {\n    for (int i = 1; i + (1 << j) - 1 <= n; i++) {\n      T[i][j] = min(T[i][j - 1], T[i + (1 << (j - 1))][j - 1]);\n    }\n  }\n}\nint qym(int l, int r) {\n  int x = log(r - l + 1) / log(2);\n  int y = min(T[l][x], T[r - (1 << x) + 1][x]);\n  return y;\n}\nvoid pp(int pos) {\n  for (int(i) = 0; (i) < (int)(B - A); (i)++) printf(\"(\");\n  for (int i = pos; i < pos + n; i++) printf(\"%c\", s[i] == 'a' ? '(' : ')');\n  for (int(i) = 0; (i) < (int)(A - B); (i)++) printf(\")\");\n  puts(\"\");\n  exit(0);\n}\nint main() {\n  scanf(\"%s\", s + 1);\n  n = strlen(s + 1);\n  for (int(i) = 1; (i) <= (int)(n); (i)++) {\n    int id = i;\n    if (s[i] == '(') {\n      A++;\n      s[i] = s[i + n] = 'a';\n      T[id][0] = T[id - 1][0] + 1;\n    } else {\n      B++;\n      s[i] = s[i + n] = 'b';\n      T[id][0] = T[id - 1][0] - 1;\n    }\n  }\n  for (int i = n + 1; i <= n + n; i++)\n    T[i][0] = T[i - 1][0] + (s[i] == 'a' ? 1 : -1);\n  init(n + n);\n  sa.get_SA(s, n + n, 122);\n  for (int(i) = 1; (i) <= (int)(n + n); (i)++) {\n    int pos = sa.sa[i];\n    if (pos > n) continue;\n    int mi = qym(pos, pos + n - 1) - T[pos - 1][0];\n    if (A < B) {\n      if (B - A + mi >= 0) pp(pos);\n    } else {\n      if (mi >= 0) pp(pos);\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline void read(T &x) {\n  char c;\n  bool fu = 0;\n  for (c = getchar(); c <= 32; c = getchar())\n    ;\n  if (c == '-') fu = 1, c = getchar();\n  for (x = 0; c > 32; c = getchar()) x = x * 10 + c - '0';\n  if (fu) x *= -1;\n}\ntemplate <class T>\ninline void read(T &x, T &y) {\n  read(x);\n  read(y);\n}\ntemplate <class T>\ninline void read(T &x, T &y, T &z) {\n  read(x, y);\n  read(z);\n}\nconst int N = 2000010;\nchar ch[N];\ndeque<int> Q;\nbool can[N];\nint len, l, m = 127, s1, s2, u1[N], u2[N], *x = u1, *y = u2, t[N], sa[N],\n            ans[N], s[N];\ninline bool cmp(int *r, int a, int b, int l) {\n  return r[a] == r[b] && r[a + l] == r[b + l];\n}\nint main() {\n  gets(ch + 1);\n  len = strlen(ch + 1);\n  for (int _tmp = len, i = 1; i <= _tmp; ++i) ch[len + i] = ch[i];\n  l = len << 1;\n  ch[0] = ch[len];\n  for (int _tmp = l, i = 1; i <= _tmp; ++i) ++t[x[i] = ch[i]];\n  for (int _tmp = m, i = 1; i <= _tmp; ++i) t[i] += t[i - 1];\n  for (int _tmp = 1, i = l; i >= _tmp; --i) sa[t[x[i]]--] = i;\n  for (int j = 1, p = 0; j <= l && p != l; m = p, j *= 2, p = 0) {\n    for (int _tmp = l, i = l - j + 1; i <= _tmp; ++i) y[++p] = i;\n    for (int _tmp = l, i = 1; i <= _tmp; ++i)\n      if (sa[i] > j) y[++p] = sa[i] - j;\n    for (int _tmp = m, i = 0; i <= _tmp; ++i) t[i] = 0;\n    for (int _tmp = l, i = 1; i <= _tmp; ++i) s[i] = x[y[i]];\n    for (int _tmp = l, i = 1; i <= _tmp; ++i) ++t[s[i]];\n    for (int _tmp = m, i = 1; i <= _tmp; ++i) t[i] += t[i - 1];\n    for (int _tmp = 1, i = l; i >= _tmp; --i) sa[t[s[i]]--] = y[i];\n    swap(x, y);\n    x[sa[1]] = 1, p = 1;\n    for (int _tmp = l, i = 2; i <= _tmp; ++i)\n      x[sa[i]] = cmp(y, sa[i - 1], sa[i], j) ? p : ++p;\n  }\n  for (int _tmp = len, i = 1; i <= _tmp; ++i) ++(ch[i] == '(' ? s1 : s2);\n  for (int _tmp = len, i = l; i >= _tmp; --i) {\n    s[i] = s[i + 1] + (ch[i] == '(' ? 1 : -1);\n    while (!Q.empty() && s[i] > s[Q.back()]) Q.pop_back();\n    Q.push_back(i);\n    can[i] = 0;\n  }\n  for (int _tmp = 1, i = len; i >= _tmp; --i) {\n    s[i] = s[i + 1] + (ch[i] == '(' ? 1 : -1);\n    can[i] = (max(s2 - s1, 0) + (s[i] - s[Q.front()]) >= 0);\n    while (!Q.empty() && s[i] > s[Q.back()]) Q.pop_back();\n    Q.push_back(i);\n    while (!Q.empty() && Q.front() >= i + len) Q.pop_front();\n  }\n  int p = 1;\n  for (int _tmp = l, i = 1; i <= _tmp; ++i)\n    if (can[sa[i]]) {\n      p = sa[i];\n      break;\n    }\n  while (s1 < s2) ++s1, putchar('(');\n  for (int _tmp = p + len - 1, i = p; i <= _tmp; ++i) putchar(ch[i]);\n  while (s1 > s2) ++s2, putchar(')');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int INF = 1e9;\nconst long long lINF = 1e18;\nconst double EPS = 1e-12;\nusing namespace std;\nconst int N = 1e6 + 100;\nchar s[N];\nint p[N], c[N], last[N];\nint pn[N], cn[N];\nint n, balance[N], mnl[N], mnr[N];\nint main() {\n  scanf(\"%s\", s);\n  n = strlen(s);\n  for (int i = 0; i < n; i++) {\n    last[s[i] - 'a' + 1]++;\n  }\n  for (int i = 2; i <= 26; i++) {\n    last[i] += last[i - 1];\n  }\n  for (int i = 0; i < n; i++) {\n    c[i] = last[s[i] - 'a'];\n  }\n  for (int i = 0; i < n; i++) {\n    p[last[s[i] - 'a']++] = i;\n  }\n  for (int l = 1; l < n; l <<= 1) {\n    for (int i = 0; i < n; i++) last[i] = i;\n    for (int i = 0; i < n; i++) {\n      int pp = (p[i] - l + n) % n;\n      pn[last[c[pp]]++] = pp;\n    }\n    memcpy(p, pn, n * sizeof(n));\n    cn[p[0]] = 0;\n    int nlast = 0;\n    for (int i = 1; i < n; i++) {\n      int mid1 = (p[i] + l) % n, mid2 = (p[i - 1] + l) % n;\n      if (c[p[i]] > c[p[i - 1]] || c[mid1] > c[mid2]) nlast = i;\n      cn[p[i]] = nlast;\n    }\n    memcpy(c, cn, n * sizeof(n));\n  }\n  mnl[0] = INF;\n  for (int i = 0; i < n; i++) {\n    if (s[i] == '(') {\n      balance[i + 1] = balance[i] + 1;\n    } else {\n      balance[i + 1] = balance[i] - 1;\n    }\n    mnl[i + 1] = min(balance[i + 1], mnl[i]);\n  }\n  mnr[n - 1] = balance[n];\n  for (int i = n - 2; i >= 0; i--) {\n    mnr[i] = min(mnr[i + 1], balance[i + 1]);\n  }\n  int ans = INF, ansi = 0, good = min(0, balance[n]);\n  for (int i = 0; i < n; i++) {\n    if (mnl[i] + balance[n] - balance[i] >= good &&\n        mnr[i] - balance[i] >= good) {\n      if (ans > c[i]) {\n        ans = c[i];\n        ansi = i;\n      }\n    }\n  }\n  for (int i = 0; i < -balance[n]; i++) {\n    putchar('(');\n  }\n  for (int i = ansi; i < ansi + n; i++) {\n    putchar(s[i % n]);\n  }\n  for (int i = 0; i < balance[n]; i++) {\n    putchar(')');\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef int arr[3000010];\nstring s;\nint n, ans, l, r, q[1000010], y = 1;\ninline bool check(int x) {\n  while (l < r && q[l % n] < x) l++;\n  for (; y <= x; y++) {\n    if (s[y - 1] == '(')\n      q[r++] = y - 1 + n;\n    else if (l < r)\n      r--;\n  }\n  return r - l > max(ans, 0);\n}\ninline void solve() {\n  int i = -1;\n  for (int j = 0, k, l; j < n;) {\n    if (check(j)) {\n      j++;\n      continue;\n    }\n    if (i == -1) {\n      i = j;\n      j++;\n      continue;\n    }\n    for (k = 0; k < n && s[(i + k) % n] == s[(j + k) % n]; k++)\n      ;\n    if (k >= n) break;\n    if (s[(i + k) % n] < s[(j + k) % n])\n      j += k + 1;\n    else\n      l = i + k, i = j, j = max(l, j) + 1;\n  }\n  cout << s.substr(i, n);\n}\nint main() {\n  cin >> s;\n  n = s.length();\n  for (int i = 0; i < n; i++)\n    if (s[i] == '(')\n      ans++, q[r++] = i;\n    else {\n      ans--;\n      if (r > 0) r--;\n    }\n  if (ans < 0)\n    for (int i = 1; i <= -ans; i++) putchar('(');\n  s += s;\n  solve();\n  if (ans > 0)\n    for (int i = 1; i <= ans; i++) putchar(')');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2000010;\nconst int H = 37;\nconst int P = 1000000007;\nint k, n, m;\nint a[N], sum;\nint Ans = 1e9, x;\nint h[N], p[N];\nvector<int> g;\nmultiset<int> S;\nchar s[N];\nint Get(int l, int r) {\n  return ((h[r] - 1ll * h[l - 1] * p[r - l + 1]) % P + P) % P;\n}\nbool Cmp(int x, int y) {\n  int l = 0, r = n - 1;\n  while (l <= r) {\n    int Mid = l + r >> 1;\n    if (Get(x, x + Mid) == Get(y, y + Mid))\n      l = Mid + 1;\n    else\n      r = Mid - 1;\n  }\n  if (l == n) return 0;\n  return a[x + l] < a[y + l];\n}\nint main() {\n  scanf(\"%s\", s);\n  n = strlen(s);\n  for (int i = 1; i <= n; i++)\n    a[i + n] = a[i] = s[i - 1] == '(' ? 0 : 1, sum += a[i] ? 1 : -1;\n  for (int i = 1; i <= n * 2; i++) h[i] = (1ll * h[i - 1] * H + a[i] + 1) % P;\n  p[0] = 1;\n  for (int i = 1; i <= n; i++) p[i] = 1ll * p[i - 1] * H % P;\n  int t = 0, T = 0;\n  for (int i = 1; i < n; i++) {\n    t += a[i] ? 1 : -1;\n    S.insert(t);\n  }\n  for (int i = 1; i <= n; i++) {\n    t += a[i + n - 1] ? 1 : -1;\n    S.insert(t);\n    int len = max((*S.rbegin()) - T, 0) * 2 - sum;\n    if (len < Ans) Ans = len, x = max((*S.rbegin()) - T, 0), g.clear();\n    if (len == Ans) g.push_back(i);\n    T += a[i] ? 1 : -1;\n    S.erase(S.find(T));\n  }\n  int pos = g[0];\n  for (int i = 1; i < g.size(); i++)\n    if (Cmp(g[i], pos)) pos = g[i];\n  for (int i = 1; i <= x; i++) putchar('(');\n  for (int i = pos; i <= pos + n - 1; i++) putchar(a[i] ? ')' : '(');\n  for (int i = 1; i <= Ans - x; i++) putchar(')');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct SuffixArray {\n  int N;\n  vector<int> rank, lcp, sa;\n  string S;\n  SuffixArray(string S) : S(S) {\n    int i, h = 0;\n    vector<int> tmp, tr;\n    N = S.size();\n    rank.resize(N + 1);\n    sa.resize(N + 1);\n    tmp.resize(N + 1);\n    for (i = 0; i < N + 1; i++) sa[i] = i, rank[i] = i == N ? -1 : S[i];\n    for (int k = 1; k <= N; k <<= 1) {\n      auto pred = [k, this](int& a, int& b) -> bool {\n        return (rank[a] != rank[b]) ? (rank[a] < rank[b])\n                                    : (((a + k <= N) ? rank[a + k] : -1) <\n                                       ((b + k <= N) ? rank[b + k] : -1));\n      };\n      auto pred2 = [k, this](int& a, int& b) -> bool {\n        return (((a + k <= N) ? rank[a + k] : -1) <\n                ((b + k <= N) ? rank[b + k] : -1));\n      };\n      int x = 0;\n      if (k != 1) {\n        for (i = 1; i < N + 1; i++)\n          if (rank[sa[i]] != rank[sa[x]])\n            sort(sa.begin() + x, sa.begin() + i, pred), x = i;\n      }\n      sort(sa.begin() + x, sa.end(), pred);\n      for (i = 0; i < N + 1; i++)\n        tmp[sa[i]] = (i == 0) ? 0 : tmp[sa[i - 1]] + pred(sa[i - 1], sa[i]);\n      swap(rank, tmp);\n    }\n  }\n};\nstring S;\nint L;\nint P;\nint score[2500000];\nint sd[4500000];\nconst int OFF = 2200000;\nint mi = OFF;\nvoid solve() {\n  int i, j, k, l, r, x, y;\n  string s;\n  cin >> S;\n  L = S.size();\n  S += S;\n  SuffixArray sa(S);\n  for (i = 0; i < L; i++) {\n    score[i + 1] = score[i] + ((S[i] == '(') ? 1 : -1);\n    sd[OFF + score[i + 1]]++;\n    mi = min(mi, OFF + score[i + 1]);\n  }\n  int dif = score[L];\n  int ret = -1;\n  for (i = 0; i < L; i++) {\n    if ((mi - OFF) - score[i] >= min(0, dif)) {\n      if (ret == -1 || sa.rank[i] <= sa.rank[ret]) ret = i;\n    }\n    score[i + L + 1] = score[i + L] + ((S[i + L] == '(') ? 1 : -1);\n    sd[OFF + score[i + L + 1]]++;\n    if (mi > OFF + score[i + L + 1]) mi = OFF + score[i + L + 1];\n    if (--sd[OFF + score[i + 1]] == 0 && mi == OFF + score[i + 1]) {\n      if (sd[OFF + score[i + 1] - 1])\n        mi--;\n      else\n        mi++;\n    }\n  }\n  if (dif < 0) cout << string(-dif, '(');\n  cout << S.substr(ret, L);\n  if (dif > 0) cout << string(dif, ')');\n  cout << endl;\n}\nint main(int argc, char** argv) {\n  string s;\n  int i;\n  if (argc == 1) ios::sync_with_stdio(false);\n  for (i = 0; i < argc - 1; i++) s += argv[i + 1], s += '\\n';\n  for (i = 0; i < s.size(); i++) ungetc(s[s.size() - 1 - i], stdin);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = ~0U >> 1;\nconst long long INF = ~0ULL >> 1;\nconst int mn = 2100000;\nchar s[mn];\nint N, Index, l1, l2, SA[mn], wv[mn], wa[mn * 2], wb[mn * 2], Rank[mn * 2],\n    cnt[mn], Height[mn];\ninline bool cmp(const int &a, const int &b) { return s[a] < s[b]; }\nvoid Suffix_Array(int N, int M) {\n  int *x = wa, *y = wb, *t;\n  int p = 1;\n  N++;\n  for (int i = (0); i <= (N - 1); ++i) SA[i] = i;\n  sort(SA, SA + N, cmp);\n  for (int i = (1); i <= (N - 1); ++i)\n    x[SA[i]] = (s[SA[i]] > s[SA[i - 1]]) ? (p++) : x[SA[i - 1]];\n  for (int k = 1;; k <<= 1) {\n    int n = 0;\n    for (int i = (N - k); i < (N); ++i) y[n++] = i;\n    for (int i = (0); i < (N); ++i)\n      if (SA[i] >= k) y[n++] = SA[i] - k;\n    for (int i = (0); i < (N); ++i) wv[i] = x[y[i]];\n    for (int i = (0); i < (p); ++i) cnt[i] = 0;\n    for (int i = (0); i < (N); ++i) cnt[wv[i]]++;\n    for (int i = (1); i < (p); ++i) cnt[i] += cnt[i - 1];\n    for (int i = (N - 1); i >= (0); --i) SA[--cnt[wv[i]]] = y[i];\n    p = 1;\n    swap(x, y);\n    x[SA[0]] = 0;\n    for (int i = (1); i <= (N - 1); ++i) {\n      if (y[SA[i]] == y[SA[i - 1]] && y[SA[i] + k] == y[SA[i - 1] + k])\n        x[SA[i]] = p - 1;\n      else\n        x[SA[i]] = p++;\n    }\n    if (p == N) break;\n  }\n  N--;\n}\npair<int, int> t[2000000 * 4 + 100000];\nvoid build(int p, int l, int r) {\n  if (l == r) {\n    t[p] = (s[l] == '(') ? make_pair(1, 0) : make_pair(-1, -1);\n    return;\n  }\n  build(p << 1, l, l + r >> 1);\n  build(p << 1 | 1, (l + r >> 1) + 1, r);\n  t[p] =\n      make_pair(t[p << 1].first + t[p << 1 | 1].first,\n                min(t[p << 1].second, t[p << 1].first + t[p << 1 | 1].second));\n}\npair<int, int> query(int p, int L, int R, int l, int r) {\n  if (L == l && R == r) return t[p];\n  int m = L + R >> 1;\n  if (r <= m)\n    return query(p << 1, L, m, l, r);\n  else if (l > m)\n    return query(p << 1 | 1, m + 1, R, l, r);\n  else {\n    pair<int, int> left = query(p << 1, L, m, l, m);\n    pair<int, int> right = query(p << 1 | 1, m + 1, R, m + 1, r);\n    return make_pair(left.first + right.first,\n                     min(left.second, left.first + right.second));\n  }\n}\nint L, cntl, cntr, addl, addr;\nint main() {\n  gets(s);\n  N = strlen(s);\n  for (int i = (N); i <= (2 * N - 1); ++i) s[i] = s[i - N];\n  L = N;\n  N <<= 1;\n  for (int i = (0); i < (L); ++i)\n    if (s[i] == '(')\n      cntl++;\n    else\n      cntr++;\n  if (cntl > cntr)\n    addr = cntl - cntr;\n  else\n    addl = cntr - cntl;\n  build(1, 0, N - 1);\n  for (int i = (0); i < (N); ++i)\n    if (s[i] == '(')\n      s[i] = 1;\n    else\n      s[i] = 2;\n  Suffix_Array(N, 3);\n  for (int i = (1); i <= (N); ++i)\n    if (SA[i] < L &&\n        addl + query(1, 0, N - 1, SA[i], SA[i] + L - 1).second >= 0) {\n      for (int k = (1); k <= (addl); ++k) putchar('(');\n      for (int k = (SA[i]); k <= (SA[i] + L - 1); ++k)\n        putchar((s[k] == 2) ? ')' : '(');\n      for (int k = (1); k <= (addr); ++k) putchar(')');\n      puts(\"\");\n      return 0;\n    }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:66777216\")\nusing namespace std;\nstatic unsigned rnd() {\n  static int second = 124612741;\n  second ^= second << 13;\n  second ^= second >> 17;\n  return second ^= second << 5;\n}\ninline int fpow(int a, int st, int mod) {\n  int ans = 1;\n  while (st) {\n    if (st % 2) ans = (long long)ans * a % mod;\n    a = (long long)a * a % mod;\n    st /= 2;\n  }\n  return ans;\n}\nint invmod(int first, int second) {\n  int a = 1, b = 0, k;\n  for (; second; swap(first, second), swap(a, b)) {\n    k = first / second;\n    first -= second * k;\n    a -= b * k;\n  }\n  return a + max(b, 0);\n}\nstruct Hash {\n  Hash() : x1(0), x2(0) {}\n  Hash(const int& x1, const int& x2) : x1(x1), x2(x2) {}\n  int x1, x2;\n  static int mod1, mod2;\n  static int p1, p2;\n  static int invp1, invp2;\n  static bool initCalled;\n  static const Hash ONE, ZERO, INVALID;\n  static Hash UNIT, INV_UNIT;\n  static bool prime(int a) {\n    if (a == 1) return 0;\n    for (int i = 2; i * i <= a; ++i) {\n      if (a % i == 0) return false;\n    }\n    return true;\n  }\n  static void init() {\n    if (initCalled) return;\n    initCalled = true;\n    mod1 = 1000000000 + rnd() % 10000000;\n    while (!prime(mod1)) ++mod1;\n    mod2 = 1000000000 + rnd() % 10000000;\n    while (mod2 == mod1 || !prime(mod2)) ++mod2;\n    invp1 = fpow(p1, mod1 - 2, mod1);\n    invp2 = fpow(p2, mod2 - 2, mod2);\n    INV_UNIT = Hash(invp1, invp2);\n  }\n  inline Hash& operator+=(const Hash& other) {\n    x1 += other.x1;\n    if (x1 >= Hash::mod1) x1 -= Hash::mod1;\n    x2 += other.x2;\n    if (x2 >= Hash::mod2) x2 -= Hash::mod2;\n    return *this;\n  }\n  inline Hash& operator-=(const Hash& other) {\n    x1 -= other.x1;\n    if (x1 < 0) x1 += Hash::mod1;\n    x2 -= other.x2;\n    if (x2 < 0) x2 += Hash::mod2;\n    return *this;\n  }\n  inline Hash& operator*=(const Hash& other) {\n    x1 = (long long)x1 * other.x1 % Hash::mod1;\n    x2 = (long long)x2 * other.x2 % Hash::mod2;\n    return *this;\n  }\n  inline Hash& operator*=(const int& other) {\n    x1 = (long long)x1 * other % Hash::mod1;\n    x2 = (long long)x2 * other % Hash::mod2;\n    return *this;\n  }\n  inline Hash& operator^=(const int& power) {\n    int st = power;\n    Hash ans(1, 1);\n    while (st) {\n      if (st % 2) ans *= *this;\n      x1 = (long long)x1 * x1 % Hash::mod1;\n      x2 = (long long)x2 * x2 % Hash::mod2;\n      st /= 2;\n    }\n    return *this;\n  }\n  inline bool operator==(const Hash& other) const {\n    return x1 == other.x1 && x2 == other.x2;\n  }\n};\nbool Hash::initCalled = false;\nint Hash::mod1 = 0;\nint Hash::mod2 = 0;\nint Hash::p1 = 23561;\nint Hash::p2 = 10000019;\nint Hash::invp1 = -1;\nint Hash::invp2 = -1;\nconst Hash Hash::ONE(1, 1);\nconst Hash Hash::ZERO(0, 0);\nconst Hash Hash::INVALID(-1, -1);\nHash Hash::UNIT(Hash::p1, Hash::p2);\nHash Hash::INV_UNIT(-1, -1);\ninline Hash operator+(const Hash& a, const Hash& b) {\n  Hash ans(a.x1 + b.x1, a.x2 + b.x2);\n  if (ans.x1 >= Hash::mod1) ans.x1 -= Hash::mod1;\n  if (ans.x2 >= Hash::mod2) ans.x2 -= Hash::mod2;\n  return ans;\n}\ninline Hash operator-(const Hash& a, const Hash& b) {\n  Hash ans(a.x1 - b.x1, a.x2 - b.x2);\n  if (ans.x1 < 0) ans.x1 += Hash::mod1;\n  if (ans.x2 < 0) ans.x2 += Hash::mod2;\n  return ans;\n}\ninline Hash operator*(const Hash& a, const Hash& b) {\n  return Hash((long long)a.x1 * b.x1 % Hash::mod1,\n              (long long)a.x2 * b.x2 % Hash::mod2);\n}\ninline Hash operator*(const Hash& a, const int& b) {\n  return Hash((long long)a.x1 * b % Hash::mod1,\n              (long long)a.x2 * b % Hash::mod2);\n}\ninline Hash operator^(const Hash& a, const int& power) {\n  int st = power;\n  Hash ans(1, 1), cur(a);\n  while (st) {\n    if (st % 2) ans *= cur;\n    cur *= cur;\n    st /= 2;\n  }\n  return ans;\n}\ninline Hash fpow(const Hash& a, const int& power) { return a ^ power; }\ninline Hash invmod(const Hash& a) {\n  return Hash(invmod(a.x1, Hash::mod1), invmod(a.x2, Hash::mod2));\n}\ntemplate <class H>\nstruct HashString : public string {\n  HashString() : string() { precalc(0); }\n  HashString(const HashString& other) : string(other) { precalc(size()); }\n  HashString(HashString&& other)\n      : hh(std::move(other.hh)), string(std::move(other)) {\n    precalc(size());\n  }\n  HashString(const string& other) : string(other) {\n    precalc(size());\n    build();\n  }\n  HashString(string&& other) : string(std::move(other)) {\n    precalc(size());\n    build();\n  }\n  HashString(const char* other) : string(other) {\n    precalc(size());\n    build();\n  }\n  inline void clear() {\n    hh.clear();\n    string::clear();\n  }\n  inline static H getPow(int p) {\n    if (p < haveN) {\n      return pp[p];\n    } else {\n      return fpow(H::UNIT, p);\n    }\n  }\n  inline static H getInvPow(size_t p) {\n    if (p < invpp.size()) {\n      return invpp[p];\n    } else {\n      return fpow(H::INV_UNIT, p);\n    }\n  }\n  inline H getInvRegister(const H& p) const {\n    if (p == register_) {\n      return registerValue_;\n    } else {\n      register_ = p;\n      return registerValue_ = invmod(p);\n    }\n  }\n  static void precalc(int N = 0) {\n    Hash::init();\n    if (haveN >= N) return;\n    pp.resize(N);\n    invpp.resize(N);\n    if (!haveN) {\n      pp[0] = H::ONE;\n      invpp[0] = H::ONE;\n      haveN = 1;\n    }\n    for (int i = haveN; i < N; ++i) {\n      pp[i] = pp[i - 1] * H::UNIT;\n      invpp[i] = invpp[i - 1] * H::INV_UNIT;\n    }\n    haveN = N;\n  }\n  inline void build() {\n    int curSize = size();\n    if (haveN <= curSize) {\n      precalc(curSize);\n    }\n    for (int i = hh.size(); i < curSize; ++i) {\n      H pr = i ? hh.back() : H::ZERO;\n      hh.push_back(pr + getPow(i) * (*this)[i]);\n    }\n  }\n  inline H getHash(int pos, int len) const {\n    if (len <= 0) return H::ZERO;\n    const int S = size();\n    if (pos + len - 1 < S) {\n      H ans = hh[pos + len - 1];\n      if (pos) {\n        ans -= hh[pos - 1];\n        ans *= getInvPow(pos);\n      }\n      return ans;\n    } else {\n      H head = hh.back();\n      if (pos) {\n        head -= hh[pos - 1];\n        head *= getInvPow(pos);\n      }\n      int full = -1, en = -1;\n      H mid = H::ZERO;\n      int midlen = 0;\n      if (len <= S) {\n        en = pos + len - 1 - S;\n        H tail = hh[en];\n        full = 0;\n        return head + tail * getPow(S - pos);\n      } else {\n        en = (pos + len - 1) % S;\n        H tail = hh[en];\n        full = (len - (S - pos) - (en + 1)) / S;\n        mid = hh.back() * (H::ONE - getInvPow(full * S)) *\n              getInvRegister(H::ONE - getInvPow(S));\n        return head + mid * getPow(S - pos) + tail * getPow(len - (en + 1));\n      }\n    }\n  }\n  inline HashString& operator+=(const char& ch) {\n    string::operator+=(ch);\n    build();\n    return *this;\n  }\n  inline HashString& operator+=(const HashString& other) {\n    string::operator+=(other);\n    build();\n    return *this;\n  }\n  inline bool operator==(const HashString& other) const {\n    return hh.back() == other.hh.back();\n  }\n  inline bool operator<(const HashString& other) const {\n    int s1 = size();\n    int s2 = other.size();\n    const int S = min(s1, s2);\n    int l = 0, r = S + 1;\n    while (r - l > 1) {\n      int xx = (r + l) / 2;\n      if (getHash(0, xx) == other.getHash(0, xx))\n        l = xx;\n      else\n        r = xx;\n    }\n    char c1 = 0, c2 = 0;\n    if (l < s1) c1 = (*this)[l];\n    if (l < s2) c2 = other[l];\n    return c1 < c2;\n  }\n  inline bool operator<=(const HashString& other) const {\n    return (*this == other) || (*this < other);\n  }\n  inline bool operator>(const HashString& other) const {\n    return !(*this == other) && !(*this < other);\n  }\n  inline bool operator>=(const HashString& other) const {\n    return !(*this < other);\n  }\n  inline bool operator!=(const HashString& other) const {\n    return !(*this == other);\n  }\n  inline void reserve(int N) {\n    hh.reserve(N);\n    string::reserve(N);\n  }\n  vector<H> hh;\n  static vector<H> pp, invpp;\n\n private:\n  mutable H register_, registerValue_;\n  static int haveN;\n};\ntemplate <>\nint HashString<Hash>::haveN = 0;\ntemplate <>\nvector<Hash> HashString<Hash>::pp = vector<Hash>();\ntemplate <>\nvector<Hash> HashString<Hash>::invpp = vector<Hash>();\ntemplate <class H, bool cyclic = true>\nstruct HashStringPiece {\n  explicit HashStringPiece(const HashString<H>& s, int pos, int len)\n      : s(s), pos(pos), len(len), hash(H::INVALID) {}\n  inline H getHash() const {\n    if (hash == H::INVALID) hash = s.getHash(pos, len);\n    return hash;\n  }\n  inline H getPartialHash(int needLen) const { return s.getHash(pos, needLen); }\n  inline char getChar(int i) const {\n    i += pos;\n    const int S = s.size();\n    if (i < S) return s[i];\n    if (!cyclic) return 0;\n    i -= S;\n    if (i < S) return s[i];\n    return s[i % S];\n  }\n  const HashString<H>& s;\n  const int pos, len;\n  mutable H hash;\n};\ntemplate <class H, class T>\nchar getHSPRangeChar(T beg, T en, int pos) {\n  for (T it = beg; it != en; ++it) {\n    if (pos < it->len) {\n      return it->getChar(pos);\n    }\n    pos -= it->len;\n  }\n  return 0;\n}\ntemplate <class H, class T>\nH getHSPRangeHash(T beg, T en, int len) {\n  H ans = H::ZERO;\n  int cur = 0;\n  for (T it = beg; it != en; ++it) {\n    if (len >= it->len) {\n      ans += it->getHash() * it->s.getPow(cur);\n      cur += it->len;\n      len -= it->len;\n    } else {\n      ans += it->getPartialHash(len) * it->s.getPow(cur);\n      break;\n    }\n  }\n  return ans;\n}\nint TB, IT;\ntemplate <class H, class T>\ninline int compareHSPRanges(T beg1, T en1, int len1, T beg2, T en2, int len2) {\n  if (beg1 == en1 && beg2 == en2) return 0;\n  if (beg1 == en1) return -1;\n  if (beg2 == en2) return 1;\n  int l = 0, r = min(len1, len2) + 1;\n  while (r - l > 1) {\n    int xx = (r + l) / 2;\n    auto h1 = getHSPRangeHash<H, T>(beg1, en1, xx);\n    auto h2 = getHSPRangeHash<H, T>(beg2, en2, xx);\n    if (h1 == h2)\n      l = xx;\n    else\n      r = xx;\n  }\n  char c1 = getHSPRangeChar<H, T>(beg1, en1, l);\n  char c2 = getHSPRangeChar<H, T>(beg2, en2, l);\n  if (c1 < c2)\n    return -1;\n  else if (c1 == c2)\n    return 0;\n  else\n    return 1;\n}\ntemplate <class H, class T>\ninline int compareHSPRanges(T beg1, T en1, T beg2, T en2) {\n  int len1 = 0;\n  for (T it = beg1; it != en1; ++it) {\n    len1 += it->len;\n  }\n  int len2 = 0;\n  for (T it = beg2; it != en2; ++it) {\n    len2 += it->len;\n  }\n  return compareHSPRanges<H, T>(beg1, en1, len1, beg2, en2, len2);\n}\nint a, b, c, d, n, m, k;\nchar str[1000002];\nint bal[2000002];\nHashString<Hash> s;\ninline string build(pair<pair<int, int>, int> a) {\n  string ans = \"\";\n  for (int _n((a.first.first) - 1), i(0); i <= _n; i++) ans += '(';\n  for (int _n((n)-1), i(0); i <= _n; i++) {\n    int cur = a.second + i;\n    if (cur >= n) cur -= n;\n    ans += str[cur];\n  }\n  for (int _n((a.first.second) - 1), i(0); i <= _n; i++) ans += ')';\n  return ans;\n}\nHashString<Hash> op, cl;\ninline bool better(pair<pair<int, int>, int> a, pair<pair<int, int>, int> b,\n                   const HashString<Hash>& s) {\n  HashStringPiece<Hash> A[3] = {HashStringPiece<Hash>(op, 0, a.first.first),\n                                HashStringPiece<Hash>(s, a.second, n),\n                                HashStringPiece<Hash>(cl, 0, a.first.second)};\n  HashStringPiece<Hash> B[3] = {HashStringPiece<Hash>(op, 0, b.first.first),\n                                HashStringPiece<Hash>(s, b.second, n),\n                                HashStringPiece<Hash>(cl, 0, b.first.second)};\n  int t = compareHSPRanges<Hash>(A, A + 3, B, B + 3);\n  if (t == -1)\n    return 1;\n  else\n    return 0;\n}\nint main() {\n  gets(str);\n  n = (int)strlen(str);\n  HashString<Hash> s(str);\n  HashString<Hash>::precalc(2 * n + 1);\n  op.reserve(n + 1);\n  cl.reserve(n + 1);\n  for (int _n((n)-1), i(0); i <= _n; i++) {\n    op += '(';\n    cl += ')';\n  }\n  c = 0;\n  for (int _n((n)-1), i(0); i <= _n; i++) {\n    if (str[i] == '(')\n      ++c;\n    else\n      --c;\n  }\n  bal[0] = 0;\n  for (int _n((2 * n) - 1), i(0); i <= _n; i++) {\n    if (i) bal[i] = bal[i - 1];\n    int cur = i;\n    if (i >= n) cur = i - n;\n    if (str[cur] == '(')\n      ++bal[i];\n    else\n      --bal[i];\n  }\n  int blen = 1000000000;\n  pair<pair<int, int>, int> best = make_pair(make_pair(0, 0), 0);\n  stack<pair<int, int> > s1, s2;\n  for (int _n((n)-1), i(0); i <= _n; i++) {\n    int new_element = bal[i];\n    int minima = s1.empty() ? new_element : min(new_element, s1.top().second);\n    s1.push(make_pair(new_element, minima));\n  }\n  for (int _n((n)-1), cyc(0); cyc <= _n; cyc++) {\n    int current_minimum = -1000000000;\n    if (s1.empty() || s2.empty())\n      current_minimum = s1.empty() ? s2.top().second : s1.top().second;\n    else\n      current_minimum = min(s1.top().second, s2.top().second);\n    int p = 0;\n    if (cyc) p = bal[cyc - 1];\n    int mn = current_minimum - p;\n    int beg = max(0, -mn);\n    int en = c + beg;\n    int len = beg + en + n;\n    if (len < blen ||\n        (len == blen && better(make_pair(make_pair(beg, en), cyc), best, s))) {\n      blen = len;\n      best = make_pair(make_pair(beg, en), cyc);\n    }\n    if (s2.empty()) {\n      while (!s1.empty()) {\n        int element = s1.top().first;\n        s1.pop();\n        int minima = s2.empty() ? element : min(element, s2.top().second);\n        s2.push(make_pair(element, minima));\n      }\n    }\n    s2.pop();\n    int new_element = bal[cyc + n];\n    int minima = s1.empty() ? new_element : min(new_element, s1.top().second);\n    s1.push(make_pair(new_element, minima));\n  }\n  string ans = build(best);\n  printf(\"%s\\n\", ans.c_str());\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e6 + 16;\nconst int B = 233;\nconst int MO = 1e9 + 9;\nstring s, q;\nint n, nn, a[N], b[N], t[N * 4], p[N], h[N];\nvoid build(int k = 1, int l = 0, int r = nn) {\n  if (l == r) {\n    t[k] = b[l];\n    return;\n  }\n  int h = l + r >> 1;\n  build(k << 1, l, h);\n  build(k << 1 | 1, h + 1, r);\n  t[k] = min(t[k << 1], t[k << 1 | 1]);\n}\nint query(int L, int R, int k = 1, int l = 0, int r = nn) {\n  if (L <= l && r <= R) return t[k];\n  int h = l + r >> 1, o = N;\n  if (L <= h) o = min(o, query(L, R, k << 1, l, h));\n  if (h < R) o = min(o, query(L, R, k << 1 | 1, h + 1, r));\n  return o;\n}\nint geth(int l, int r) {\n  l--;\n  return (h[r] - (long long)h[l] * p[r - l] % MO + MO) % MO;\n}\nint f(int l1, int r1, int l2, int r2) {\n  if (geth(l1, r1) == geth(l2, r2)) return 0;\n  int x, y;\n  while (l1 < r1) {\n    x = l1 + r1 >> 1;\n    y = l2 + r2 >> 1;\n    if (geth(l1, x) == geth(l2, y))\n      l1 = x + 1, l2 = y + 1;\n    else\n      r1 = x, r2 = y;\n  }\n  return a[l1] > a[l2];\n}\nint main() {\n  int i, x, o, e, bl, br;\n  cin >> s;\n  n = s.length();\n  s = s + s;\n  nn = n + n;\n  p[0] = 1;\n  for (i = 1; i <= nn; i = i + 1) {\n    b[i] = b[i - 1];\n    if (s[i - 1] == '(')\n      a[i] = 0, b[i]++;\n    else\n      a[i] = 1, b[i]--;\n    p[i] = (long long)p[i - 1] * B % MO;\n    h[i] = ((long long)h[i - 1] * B % MO + a[i]) % MO;\n  }\n  bl = 0, br = b[n];\n  build();\n  x = 1, o = -query(0, n);\n  for (i = 2; i <= n; i = i + 1) {\n    e = b[i - 1] - query(i - 1, i + n - 1);\n    if (o > e) {\n      o = e;\n      x = i;\n      continue;\n    }\n    if (e == o && f(x, x + n - 1, i, i + n - 1)) x = i;\n  }\n  bl += o, br += o;\n  while (bl--) {\n    q += '(';\n  }\n  for (i = x; i < x + n; i = i + 1) q += s[i - 1];\n  while (br--) {\n    q += ')';\n  }\n  cout << q;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstring str;\nint deq[2000666];\nint sp[2000666];\nlong long v1[2000666], v2[2000666];\nlong long p1[2000666], p2[2000666];\nint a[2000666];\nvector<int> P;\nbool comp(int i1, int i2, int mval) {\n  if (a[i1] != a[i2]) return a[i1] < a[i2];\n  int pos, step;\n  if (i1 > i2) swap(i1, i2);\n  long long m1 = p1[i2 - i1];\n  long long m2 = p2[i2 - i1];\n  for (step = 1; step <= mval; step <<= 1)\n    ;\n  for (pos = 0; step; step >>= 1)\n    if (i2 + pos + step <= mval + mval) {\n      long long val1_first =\n          (v1[i1] - v1[i1 + pos + step] + ((long long)666013)) %\n          ((long long)666013);\n      long long val2_first =\n          (v2[i1] - v2[i1 + pos + step] + ((long long)111111)) %\n          ((long long)111111);\n      long long val1_second =\n          ((v1[i2] - v1[i2 + pos + step] + ((long long)666013)) * m1) %\n          ((long long)666013);\n      long long val2_second =\n          ((v2[i2] - v2[i2 + pos + step] + ((long long)111111)) * m2) %\n          ((long long)111111);\n      if (val1_first == val1_second && val2_first == val2_second) pos += step;\n    }\n  return a[i1 + pos] < a[i2 + pos];\n}\nint main() {\n  cin >> str;\n  int N = str.size(), suma = 0;\n  int i;\n  for (i = 0; i < N; ++i) {\n    a[i + 1] = (str[i] == '(' ? 1 : 0);\n    suma += (a[i + 1] == 1 ? 1 : -1);\n    a[i + N + 1] = a[i + 1];\n  }\n  int val_need = min(suma, 0);\n  for (i = 1; i <= N + N; ++i) sp[i] = sp[i - 1] + (a[i] == 1 ? 1 : -1);\n  int j = 0, st = 1, dr = 0;\n  for (i = 1; i <= N; ++i) {\n    while (j < i + N - 1) {\n      ++j;\n      while (dr >= st && sp[deq[dr]] >= sp[j]) --dr;\n      deq[++dr] = j;\n    }\n    while (st <= dr && deq[st] < i) ++st;\n    if (sp[deq[st]] - sp[i - 1] >= val_need) P.push_back(i);\n  }\n  p1[0] = 1;\n  p2[0] = 1;\n  for (i = 1; i <= N + N; ++i) {\n    p1[i] = (p1[i - 1] * 2) % ((long long)666013);\n    p2[i] = (p2[i - 1] * (long long)2) % ((long long)111111);\n  }\n  for (i = N + N; i > 0; --i) {\n    v1[i] = (v1[i + 1] + a[i] * p1[N + N - i]) % ((long long)666013);\n    v2[i] = (v2[i + 1] + a[i] * p2[N + N - i]) % ((long long)111111);\n  }\n  int NP = P.size();\n  int last_cand = P[0];\n  for (i = 1; i < NP; ++i) {\n    bool X = comp(last_cand, P[i], N);\n    if (X == true) last_cand = P[i];\n  }\n  for (; suma < 0; ++suma) cout << \"(\";\n  for (i = last_cand; i <= last_cand + N - 1; ++i)\n    if (a[i])\n      cout << '(';\n    else\n      cout << ')';\n  for (; suma > 0; --suma) cout << \")\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1000100;\nint n;\nchar s[MAXN];\nint balance[MAXN];\nint pref[MAXN];\nint pos[MAXN];\nint sa[MAXN], rnk[MAXN], cnt[MAXN], tmp[MAXN];\nint ranks;\nvoid build() {\n  for (int i = 0; i < n; ++i) ++cnt[(int)s[i]];\n  for (int i = 1; i < 256; ++i) cnt[i] += cnt[i - 1];\n  for (int i = 0; i < n; ++i) sa[--cnt[(int)s[i]]] = i;\n  rnk[sa[0]] = 0;\n  ranks = 1;\n  for (int i = 1; i < n; ++i) {\n    if (s[sa[i]] != s[sa[i - 1]])\n      rnk[sa[i]] = ranks++;\n    else\n      rnk[sa[i]] = rnk[sa[i - 1]];\n  }\n  memset(cnt, 0, sizeof(int) * 256);\n  for (int step = 1; step < n; step <<= 1) {\n    for (int i = 0; i < n; ++i) {\n      tmp[i] = sa[i] - step;\n      if (tmp[i] < 0) tmp[i] += n;\n    }\n    for (int i = 0; i < n; ++i) ++cnt[rnk[i]];\n    for (int i = 1; i < ranks; ++i) cnt[i] += cnt[i - 1];\n    for (int i = n - 1; i > -1; --i) sa[--cnt[rnk[tmp[i]]]] = tmp[i];\n    memset(cnt, 0, sizeof(int) * ranks);\n    tmp[sa[0]] = 0;\n    ranks = 1;\n    for (int i = 1; i < n; ++i) {\n      if (rnk[sa[i]] != rnk[sa[i - 1]] ||\n          rnk[(sa[i] + step) % n] != rnk[(sa[i - 1] + step) % n])\n        tmp[sa[i]] = ranks++;\n      else\n        tmp[sa[i]] = tmp[sa[i - 1]];\n    }\n    memcpy(rnk, tmp, sizeof(int) * n);\n  }\n}\nint main() {\n  scanf(\"%s\", s);\n  n = strlen(s);\n  build();\n  for (int i = 0; i < n; ++i) pos[sa[i]] = i;\n  for (int i = 0; i < n; ++i) {\n    balance[i] = s[i] == '(' ? 1 : -1;\n    pref[i] = balance[i];\n    if (i) {\n      balance[i] += balance[i - 1];\n      pref[i] = min(pref[i - 1], balance[i]);\n    }\n  }\n  int suff = 1e8;\n  int bestShift = -1;\n  for (int i = n - 1; i > -1; --i) {\n    int tmp = min(suff - balance[i], balance[n - 1] - balance[i] + pref[i]);\n    if (tmp >= min(0, balance[n - 1]))\n      if (bestShift == -1 || pos[bestShift] > pos[(i + 1) % n])\n        bestShift = (i + 1) % n;\n    suff = min(suff, balance[i]);\n  }\n  for (int i = 0; i < -balance[n - 1]; ++i) putchar('(');\n  for (int i = 0; i < n; ++i) {\n    putchar(s[(bestShift + i) % n]);\n  }\n  for (int i = 0; i < balance[n - 1]; ++i) putchar(')');\n  puts(\"\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 2000005;\nint n, m;\nint in[MAX_N];\nint inv[MAX_N];\nint out[MAX_N], temp[MAX_N];\nint pos2bckt[MAX_N];\nint bckt[MAX_N], relabel[MAX_N];\nint bpos[MAX_N];\nvoid build() {\n  for (int i = 0; i < n; i++) out[i] = i;\n  sort(out, out + n, [](int a, int bckt) { return in[a] < in[bckt]; });\n  for (int i = 0, c = 0; i < n; i++) {\n    bckt[i] = c;\n    if (i + 1 == n || in[out[i]] != in[out[i + 1]]) c++;\n  }\n  for (int h = 1; h < n; h <<= 1) {\n    for (int i = 0; i < n; i++) pos2bckt[out[i]] = bckt[i];\n    for (int i = n - 1; i >= 0; i--) bpos[bckt[i]] = i;\n    for (int i = 0; i < n; i++)\n      if (out[i] >= n - h) temp[bpos[bckt[i]]++] = out[i];\n    for (int i = 0; i < n; i++)\n      if (out[i] >= h) temp[bpos[pos2bckt[out[i] - h]]++] = out[i] - h;\n    for (int i = 0, c = 0; i < n; i++) {\n      relabel[i] = c;\n      if (i + 1 == n) break;\n      if (bckt[i] != bckt[i + 1])\n        c++;\n      else if (temp[i + 1] >= n - h || temp[i] >= n - h)\n        c++;\n      else if (pos2bckt[temp[i + 1] + h] != pos2bckt[temp[i] + h])\n        c++;\n    }\n    memcpy(out, temp, sizeof(temp[0]) * n);\n    memcpy(bckt, relabel, sizeof(relabel[0]) * n);\n  }\n}\nchar str[MAX_N];\nint cnt[MAX_N], mmn[MAX_N], rmmn[MAX_N];\nint main() {\n  scanf(\"%s\", str);\n  while (str[n]) n++;\n  for (int i = 0; i < n; i++) in[i] = str[i] == ')';\n  for (int i = 0; i < n; i++) in[i + n] = in[i];\n  int step = 0, mn = 0;\n  for (int i = 0; i < n; i++) {\n    if (in[i] == 1)\n      step--;\n    else\n      step++;\n    cnt[i + 1] = step;\n    if (mn > step) mn = step;\n    mmn[i + 1] = mn;\n  }\n  int p = step;\n  for (int i = n - 1; i >= 0; i--) {\n    if (in[i] == 1)\n      step++;\n    else\n      step--;\n    if (p > step) p = step;\n    rmmn[i] = p;\n  }\n  n *= 2;\n  build();\n  n /= 2;\n  int c[2] = {\n      0,\n  };\n  for (int i = 0; i < n; i++) c[in[i]]++;\n  if (c[0] >= c[1]) {\n    for (int i = 0; i < 2 * n; i++) {\n      if (out[i] < n && rmmn[out[i]] - cnt[out[i]] >= 0 &&\n          cnt[n] - cnt[out[i]] + mmn[out[i]] >= 0) {\n        for (int j = 0; j < n; j++) str[j] = in[out[i] + j] == 0 ? '(' : ')';\n        for (int j = n, k = 0; k < c[0] - c[1]; j++, k++) str[j] = ')';\n        break;\n      }\n    }\n  } else {\n    for (int i = 0; i < 2 * n; i++) {\n      if (out[i] < n && rmmn[out[i]] - cnt[out[i]] >= c[0] - c[1] &&\n          cnt[n] - cnt[out[i]] + mmn[out[i]] >= c[0] - c[1]) {\n        for (int j = 0; j < c[1] - c[0]; j++) str[j] = '(';\n        for (int j = c[1] - c[0], k = 0; k < n; j++, k++)\n          str[j] = in[out[i] + k] == 0 ? '(' : ')';\n        break;\n      }\n    }\n  }\n  puts(str);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar s[1000100];\nint a[2000100], add[8000100], min_[8000100], ans[2000100];\nint rk[2000100], rkk[2000100], cnt[2000100], tp[2000100], tpp[2000100];\nvoid pushdown(int rt) {\n  add[rt << 1] += add[rt];\n  min_[rt << 1] += add[rt];\n  add[rt << 1 | 1] += add[rt];\n  min_[rt << 1 | 1] += add[rt];\n  add[rt] = 0;\n}\nint query(int L, int R, int l, int r, int rt) {\n  if (L <= l && r <= R) return min_[rt];\n  int m = l + r >> 1, ans = 998244353;\n  pushdown(rt);\n  if (m >= L) ans = min(ans, query(L, R, l, m, rt << 1));\n  if (m < R) ans = min(ans, query(L, R, m + 1, r, rt << 1 | 1));\n  return ans;\n}\nvoid pushup(int rt) { min_[rt] = min(min_[rt << 1], min_[rt << 1 | 1]); }\nvoid build(int l, int r, int rt) {\n  if (l == r) {\n    min_[rt] = a[l];\n    return;\n  }\n  int m = l + r >> 1;\n  build(l, m, rt << 1);\n  build(m + 1, r, rt << 1 | 1);\n  pushup(rt);\n}\nvoid update(int L, int R, int c, int l, int r, int rt) {\n  if (L <= l && r <= R) {\n    min_[rt] += c;\n    add[rt] += c;\n    return;\n  }\n  pushdown(rt);\n  int m = l + r >> 1;\n  if (m >= L) update(L, R, c, l, m, rt << 1);\n  if (m < R) update(L, R, c, m + 1, r, rt << 1 | 1);\n  pushup(rt);\n}\nint main() {\n  scanf(\"%s\", s);\n  int n = strlen(s);\n  int i, t, sum = 0, cntl = 0, cntr = 0;\n  for (i = 0; i < n; i++) {\n    if (s[i] == '(')\n      t = 1, cntl++;\n    else\n      t = -1, cntr++;\n    sum += t;\n    a[n + i] = sum;\n  }\n  build(1, n << 1, 1);\n  int del, temp;\n  if (cntl < cntr)\n    del = cntr - cntl;\n  else\n    del = 0;\n  for (i = 0; i < n; i++) {\n    if (query(n - i, (n << 1) - i - 1, 1, n << 1, 1) + del < 0)\n      ans[(n - i) % n] = 0;\n    else\n      ans[(n - i) % n] = 1;\n    if (s[n - i - 1] == '(')\n      temp = 1;\n    else\n      temp = -1;\n    if (i + 1 != n) update(n - i - 1, (n << 1) - i - 2, temp, 1, n << 1, 1);\n  }\n  for (i = 0; i < n; i++) {\n    cnt[s[i] - 39]++;\n  }\n  for (i = 1; i <= 2; i++) {\n    cnt[i] += cnt[i - 1];\n  }\n  for (i = n - 1; i >= 0; i--) {\n    tpp[--cnt[s[i] - 39]] = i;\n  }\n  rk[tpp[0]] = 1;\n  for (i = 1; i < n; i++) {\n    if (s[tpp[i]] == s[tpp[i - 1]])\n      rk[tpp[i]] = rk[tpp[i - 1]];\n    else\n      rk[tpp[i]] = rk[tpp[i - 1]] + 1;\n  }\n  int j;\n  for (i = 1; i < n; i <<= 1) {\n    if (rk[tpp[n - 1]] == n) break;\n    for (j = 0; j < n; j++) {\n      tp[j] = (tpp[j] + n - i) % n;\n    }\n    memset(cnt, 0, sizeof(cnt));\n    for (j = 0; j < n; j++) {\n      cnt[rk[j]]++;\n    }\n    for (j = 1; j <= n; j++) {\n      cnt[j] += cnt[j - 1];\n    }\n    for (j = n - 1; j >= 0; j--) {\n      tpp[--cnt[rk[tp[j]]]] = tp[j];\n    }\n    rkk[tpp[0]] = 1;\n    for (j = 1; j < n; j++) {\n      if (rk[tpp[j]] == rk[tpp[j - 1]] &&\n          rk[(tpp[j] + i) % n] == rk[(tpp[j - 1] + i) % n])\n        rkk[tpp[j]] = rkk[tpp[j - 1]];\n      else\n        rkk[tpp[j]] = rkk[tpp[j - 1]] + 1;\n    }\n    memcpy(rk, rkk, sizeof(rk));\n  }\n  int fin;\n  for (i = 0; i < n; i++) {\n    if (ans[tpp[i]]) {\n      fin = tpp[i];\n      break;\n    }\n  }\n  if (cntl < cntr) {\n    while (cntl < cntr) putchar('('), cntl++;\n    for (i = 0; i < n; i++) putchar(s[(i + fin) % n]);\n  } else {\n    for (i = 0; i < n; i++) putchar(s[(i + fin) % n]);\n    while (cntr < cntl) putchar(')'), cntr++;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstatic constexpr size_t maxlen = 1000000;\nint main() {\n  static char text[maxlen];\n  size_t len = fread(text, 1, maxlen, stdin);\n  while (len && text[len - 1] < ' ') --len;\n  static unsigned deque[maxlen];\n  size_t begin = 0, end = 0;\n  int balance = 0;\n  for (size_t i = 0; i < len; ++i) {\n    if (text[i] == '(')\n      ++balance, deque[end++] = i;\n    else\n      --balance, end && --end;\n  }\n  size_t start = -1;\n  for (size_t i = 0, j = 1; i < len; ++i) {\n    while (begin < end && deque[begin % len] < i) ++begin;\n    for (; j <= i; ++j) {\n      if (text[j - 1] == '(')\n        deque[end++ % len] = j - 1 + len;\n      else if (begin < end)\n        --end;\n    }\n    if (end - begin > max(balance, 0)) continue;\n    if (start == -1) {\n      start = i;\n      continue;\n    }\n    size_t k = 0;\n    while (k < len && text[(i + k) % len] == text[(start + k) % len]) ++k;\n    if (k == len)\n      break;\n    else if (text[(i + k) % len] > text[(start + k) % len])\n      i += k;\n    else\n      start = max(start + k, i), swap(start, i);\n  }\n  while (balance < 0) putchar('('), ++balance;\n  fwrite(text + start, 1, len - start, stdout);\n  fwrite(text, 1, start, stdout);\n  while (balance > 0) putchar(')'), --balance;\n  putchar('\\n');\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2111111;\nchar buf[maxn];\nint sum[maxn];\nbool ok[maxn];\nint order[maxn];\ntemplate <typename T>\nvoid debug(T a[], int n) {\n  for (int i = 1; i <= n; ++i) {\n    cout << setw(3) << a[i];\n  }\n  puts(\"\");\n}\nvoid fix(int& i, int n) {\n  while (!ok[i] && i <= n) {\n    ++i;\n  }\n}\nint run(char s[], int m) {\n  int n = m >> 1;\n  int i = 1, j = 2, k = 0;\n  fix(i, n);\n  j = i + 1;\n  fix(j, n);\n  while (j <= n && i <= n) {\n    for (k = 0; k < n; ++k) {\n      if (s[i + k] ^ s[j + k]) {\n        break;\n      }\n    }\n    if (s[i + k] > s[j + k]) {\n      i += k + 1;\n      fix(i, n);\n    } else {\n      j += k + 1;\n      fix(j, n);\n    }\n    if (j == i) {\n      ++j;\n      fix(j, n);\n    }\n  }\n  return std::min(i, j);\n}\nint main() {\n  for (int i = 1; i < 100; ++i) {\n    order[i] = i;\n  }\n  scanf(\"%s\", buf + 1);\n  int n = std::strlen(buf + 1);\n  int A, B;\n  A = B = 0;\n  for (int i = 1; i <= n; ++i) {\n    buf[i + n] = buf[i];\n    if (buf[i] == '(') {\n      ++A;\n    } else {\n      ++B;\n    }\n  }\n  int m = n << 1;\n  for (int i = 1; i <= m; ++i) {\n    if (buf[i] == '(') {\n      sum[i] = 1;\n    } else {\n      sum[i] = -1;\n    }\n    sum[i] += sum[i - 1];\n  }\n  static int q[maxn];\n  int front, rear;\n  front = rear = 0;\n  static int min[maxn];\n  int add = 0;\n  if (A < B) {\n    add = B - A;\n  }\n  for (int i = 1; i <= m; ++i) {\n    if (front < rear && q[front] + n <= i) {\n      ++front;\n    }\n    while (front < rear && sum[q[rear - 1]] >= sum[i]) {\n      --rear;\n    }\n    q[rear++] = i;\n    min[i] = sum[q[front]];\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (add + min[i + n - 1] >= sum[i - 1]) {\n      ok[i] = true;\n    }\n  }\n  int index = run(buf, m);\n  auto print = [](char ch, int n) {\n    while (n--) {\n      putchar(ch);\n    }\n  };\n  if (A < B) {\n    print('(', B - A);\n  }\n  for (int i = index; i < index + n; ++i) {\n    putchar(buf[i]);\n  }\n  if (B < A) {\n    print(')', A - B);\n  }\n  puts(\"\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1000005;\nconst long long bas = 131, mod = 2147483647;\nlong long pw[N], hsh[2 * N], num[2 * N], fsum[2 * N], que[2 * N];\nlong long dif, len, c1, c2, f, b, h;\nchar rd[N];\nint main() {\n  scanf(\"%s\", rd), len = strlen(rd);\n  for (int i = 0; i < len; i++)\n    num[i + 1] = num[i + 1 + len] = ((rd[i] == '(') ? 1 : 2),\n            (rd[i] == '(') ? c1++ : c2++;\n  pw[0] = 1, f = 1, dif = abs(c1 - c2);\n  for (int i = 1; i <= len; i++) pw[i] = pw[i - 1] * bas % mod;\n  for (int i = 1; i <= 2 * len; i++) {\n    fsum[i] = fsum[i - 1] + ((num[i] == 1) ? 1 : -1);\n    hsh[i] = (hsh[i - 1] * bas + num[i]) % mod;\n  }\n  for (int i = 1; i < len; i++) {\n    while (f <= b && fsum[i] <= fsum[que[b]]) b--;\n    que[++b] = i;\n  }\n  for (int i = len; i <= 2 * len; i++) {\n    while (f <= b && fsum[i] <= fsum[que[b]]) b--;\n    que[++b] = i;\n    int l = f, r = b, ans = 0;\n    while (l <= r) {\n      int mid = (l + r) / 2;\n      if (que[mid] + len < i + 1)\n        l = mid + 1;\n      else\n        r = mid - 1, ans = mid;\n    }\n    bool i1 = fsum[i - len] - fsum[que[ans]] > dif;\n    bool i2 = fsum[que[ans]] - fsum[i - len] < 0;\n    if ((c1 <= c2 && i1) || (c1 >= c2 && i2)) continue;\n    l = 1, r = len, ans = 0;\n    while (l <= r) {\n      int mid = (l + r) / 2;\n      long long hsh1 =\n          ((hsh[i - len + mid] - hsh[i - len] * pw[mid] % mod) % mod + mod) %\n          mod;\n      long long hsh2 =\n          ((hsh[h - 1 + mid] - hsh[h - 1] * pw[mid] % mod) % mod + mod) % mod;\n      if (hsh1 != hsh2)\n        r = mid - 1;\n      else\n        l = mid + 1, ans = mid;\n    }\n    if (num[i - len + ans + 1] < num[h + ans] || !h) h = i - len + 1;\n  }\n  if (c1 < c2)\n    for (int j = 1; j <= dif; j++) printf(\"(\");\n  for (int j = 1; j <= len; j++)\n    (num[j + h - 1] == 1) ? printf(\"(\") : printf(\")\");\n  if (c1 > c2)\n    for (int j = 1; j <= dif; j++) printf(\")\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/stack:16777216\")\nusing namespace std;\nconst int INF = 1000000000;\nconst int MAX = 1000007;\nconst int MAX2 = 2000;\nconst int BASE = 1000000000;\nchar s[MAX];\nint v[MAX];\nset<pair<int, int> > S;\nint cur = 0;\nint p[MAX], cnt[MAX], c[MAX];\nint pn[MAX], cn[MAX];\nint main() {\n  scanf(\"%s\", s);\n  int n = strlen(s);\n  int val = 0;\n  for (int i = (0); i < (n); ++i) {\n    if (s[i] == '(') {\n      ++val;\n    } else {\n      --val;\n    }\n    v[i] = val;\n    S.insert(make_pair(val, i));\n  }\n  vector<int> ids;\n  int M = -INF;\n  for (int it = (0); it < (n); ++it) {\n    int V = min(S.begin()->first + cur, 0);\n    if (V > M) {\n      ids.clear();\n    }\n    if (V >= M) {\n      M = V;\n      ids.push_back((n - it) % n);\n    }\n    int id = n - it - 1;\n    S.erase(make_pair(v[id], id));\n    if (s[id] == '(') {\n      ++cur;\n      v[id] = 1 - cur;\n      S.insert(make_pair(v[id], id));\n    } else {\n      --cur;\n      v[id] = -1 - cur;\n      S.insert(make_pair(v[id], id));\n    }\n  }\n  memset(cnt, 0, sizeof(cnt));\n  for (int i = (0); i < (n); ++i) ++cnt[s[i] - '('];\n  cnt[1] += cnt[0];\n  for (int i = (0); i < (n); ++i) p[--cnt[s[i] - '(']] = i;\n  c[p[0]] = 0;\n  int classes = 1;\n  for (int i = 1; i < n; ++i) {\n    if (s[p[i]] != s[p[i - 1]]) ++classes;\n    c[p[i]] = classes - 1;\n  }\n  for (int h = 0; (1 << h) < n; ++h) {\n    for (int i = (0); i < (n); ++i) {\n      pn[i] = p[i] - (1 << h);\n      if (pn[i] < 0) pn[i] += n;\n    }\n    memset(cnt, 0, sizeof(cnt));\n    for (int i = 0; i < n; ++i) ++cnt[c[pn[i]]];\n    for (int i = 1; i < classes; ++i) cnt[i] += cnt[i - 1];\n    for (int i = n - 1; i >= 0; --i) p[--cnt[c[pn[i]]]] = pn[i];\n    cn[p[0]] = 0;\n    classes = 1;\n    for (int i = 1; i < n; ++i) {\n      int mid1 = (p[i] + (1 << h)) % n, mid2 = (p[i - 1] + (1 << h)) % n;\n      if (c[p[i]] != c[p[i - 1]] || c[mid1] != c[mid2]) ++classes;\n      cn[p[i]] = classes - 1;\n    }\n    memcpy(c, cn, n * sizeof(int));\n  }\n  int cl = INF;\n  int id;\n  for (int i = (0); i < (ids.size()); ++i) {\n    if (cn[ids[i]] < cl) {\n      cl = cn[ids[i]];\n      id = ids[i];\n    }\n  }\n  string R = \"\";\n  for (int i = (0); i < (abs(M)); ++i) {\n    R += '(';\n  }\n  for (int i = (id); i < (n); ++i) {\n    R += s[i];\n  }\n  for (int i = (0); i < (id); ++i) {\n    R += s[i];\n  }\n  val = 0;\n  for (int i = (0); i < (R.size()); ++i) {\n    if (R[i] == '(')\n      ++val;\n    else\n      --val;\n  }\n  for (int i = (0); i < (val); ++i) {\n    R += ')';\n  }\n  printf(\"%s\", R.c_str());\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, l, r, T, x, mmh, la, pos;\nchar a[2000003], c[2000003];\nint s[2000003], SS = 0, A, len;\nint v[2000003], sa[2000003], q[2000003], ran[2000003], st[2000003], y[2000003],\n    P[2000003];\nbool bo[2000003];\nint read_p, read_ca;\ninline int read() {\n  read_p = 0;\n  read_ca = getchar();\n  while (read_ca < '0' || read_ca > '9') read_ca = getchar();\n  while (read_ca >= '0' && read_ca <= '9')\n    read_p = read_p * 10 + read_ca - 48, read_ca = getchar();\n  return read_p;\n}\ninline void gr(int x) {\n  ran[sa[1]] = 1;\n  for (register int i = 2; i <= n; i++)\n    ran[sa[i]] = ran[sa[i - 1]] + (s[sa[i]] != s[sa[i - 1]] ||\n                                   s[P[sa[i] + x]] != s[P[sa[i - 1] + x]]);\n  for (int i = 1; i <= n; i++) s[i] = ran[i];\n  m = max(ran[sa[n]], m);\n}\ninline void gv() {\n  for (int i = 0; i <= m; i++) v[i] = 0;\n  for (int i = 1; i <= n; i++) v[s[i]]++;\n  for (int i = 1; i <= m; i++) v[i] += v[i - 1];\n}\ninline void gsa() {\n  m = 2;\n  gv();\n  for (int i = n; i >= 1; i--) sa[v[s[i]]--] = i;\n  gr(0);\n  for (int i = 1; i < n; i <<= 1) {\n    gv();\n    for (int j = 1; j <= n; j++) y[j] = (sa[j] + n - i - 1) % n + 1;\n    for (register int j = n; j >= 1; j--) q[v[s[y[j]]]--] = y[j], SS++;\n    for (int j = 1; j <= n; j++) sa[j] = q[j];\n    gr(i);\n    if (ran[sa[n]] == n) return;\n  }\n}\ninline int min(int a, int b) { return a < b ? a : b; }\nint main() {\n  int i;\n  scanf(\"%s\", a + 1);\n  n = strlen(a + 1);\n  for (i = 1; i <= n; i++)\n    a[i] = a[i] == ')', s[i + n] = a[i + n] = s[i] = a[i], P[i] = P[i + n] = i;\n  gsa();\n  v[0] = 0;\n  for (i = 1; i <= n * 2; i++) sa[i], v[i] = v[i - 1] + (a[i] ? -1 : 1);\n  int l = 0, r = -1;\n  for (i = 1; i <= n * 2; i++) {\n    while (l <= r && st[l] < i - n + 1) l++;\n    while (l <= r && v[i] <= v[st[r]]) r--;\n    st[++r] = i;\n    if (i >= n) q[i - n] = v[st[l]];\n  }\n  mmh = min(v[n], 0);\n  for (i = 1; i <= n * 2; i++)\n    if (sa[i] <= n) {\n      pos = sa[i] - 1;\n      if (q[pos] >= v[pos] + mmh) break;\n    }\n  pos++;\n  for (i = pos; i <= n; i++) c[i - pos + 1] = a[i];\n  for (i = 1; i < pos; i++) c[n - pos + i + 1] = a[i];\n  for (pos = 0, i = 1; i <= n; i++) pos += a[i] ? -1 : 1;\n  if (pos < 0)\n    for (i = 0; i < -pos; i++) putchar('(');\n  for (i = 1; i <= n; i++) putchar(c[i] ? ')' : '(');\n  if (pos > 0)\n    for (i = 0; i < pos; i++) putchar(')');\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, s[2000100];\nbool vis[2000100];\nchar t[2000100];\nint sa[2000100], rnk[2000100], tmp[2000100], cnt[2000100];\nvoid build(char *s) {\n  int n = strlen(s) + 1, m = 256;\n  int *x = rnk, *y = tmp, *z;\n  for (int i = 0; i < m; i++) cnt[i] = 0;\n  for (int i = 0; i < n; i++) cnt[x[i] = s[i]]++;\n  for (int i = 1; i < m; i++) cnt[i] += cnt[i - 1];\n  for (int i = n - 1; i >= 0; i--) sa[--cnt[x[i]]] = i;\n  for (int j = 1, p = 1; p < n; j <<= 1, m = p) {\n    p = 0;\n    for (int i = n - j; i < n; i++) y[p++] = i;\n    for (int i = 0; i < n; i++)\n      if (sa[i] >= j) y[p++] = sa[i] - j;\n    for (int i = 0; i < m; i++) cnt[i] = 0;\n    for (int i = 0; i < n; i++) cnt[x[i]]++;\n    for (int i = 1; i < m; i++) cnt[i] += cnt[i - 1];\n    for (int i = n - 1; i >= 0; i--) sa[--cnt[x[y[i]]]] = y[i];\n    z = x, x = y, y = z;\n    x[sa[0]] = 0, p = 1;\n    for (int i = 1; i < n; i++)\n      x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + j] == y[sa[i - 1] + j])\n                     ? p - 1\n                     : p++;\n  }\n  for (int i = 0; i < n; i++) rnk[sa[i]] = i;\n}\nint main() {\n  scanf(\"%s\", t + 1);\n  n = strlen(t + 1);\n  int mn = 0;\n  for (int i = 1; i <= n; i++) {\n    s[i] = s[i - 1];\n    if (t[i] == '(')\n      s[i]++;\n    else\n      s[i]--;\n    mn = min(mn, s[i]);\n  }\n  for (int i = 1; i <= n; i++) t[n + i] = t[i], s[i + n] = s[i] + s[n];\n  int dn = 0;\n  if (s[n] < 0) dn = -s[n];\n  build(t + 1);\n  multiset<int> S;\n  for (int i = n + 1; i <= 2 * n; i++) S.insert(s[i]);\n  int k, p = 1e9;\n  for (int i = n; i >= 0; i--) {\n    int t = *S.begin();\n    S.erase(S.find(s[i + n]));\n    if (t - s[i] + dn >= 0) {\n      if (rnk[i] < p) p = rnk[i], k = i + 1;\n    }\n    S.insert(s[i]);\n  }\n  int sum = s[n];\n  if (sum < 0)\n    for (int i = sum; i < 0; i++) putchar('(');\n  for (int i = 0; i < n; i++) putchar(t[k + i]);\n  if (sum > 0)\n    for (int i = 0; i < sum; i++) putchar(')');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:100000000\")\nusing namespace std;\nint d[1 << 22], e[1 << 22];\nchar s[2000100];\nint h, m[2000100], p[2000100], a[2000100], b[2 * 2000100];\nvoid sfa() {\n  int i, j, n;\n  for (n = 0; s[n]; m[n] = n, a[n] = s[n], n++)\n    ;\n  for (h = 0, j = 0; j < n; h = h * 2 + !h) {\n    for (i = 0; i < n + 256; b[i] = 0, i++)\n      ;\n    for (i = 0; i < n; ++b[a[i]], i++)\n      ;\n    for (i = 0; i < n + 256; b[i + 1] += b[i], i++)\n      ;\n    for (i = n; i--;)\n      if (m[i] >= h) p[--b[a[m[i] - h]]] = m[i] - h;\n    for (i = n - h; i < n; p[--b[a[i]]] = i, i++)\n      ;\n    for (i = 0; i < n; m[i] = p[i], b[i] = a[i], b[n + i] = 0, i++)\n      ;\n    for (j = 1, i = 0; i < n; a[m[i]] = j,\n        j += b[m[i]] < b[m[i + 1]] || b[m[i] + h] < b[m[i + 1] + h], i++)\n      ;\n  }\n}\nint getm(int i, int j) {\n  int k = 0, l = 0;\n  for (i += h, j += h; i <= j; i = (i + 1) / 2, j = (j - 1) / 2) {\n    if (i & 1) a[k++] = i;\n    if (~j & 1) b[l++] = j;\n  }\n  for (; l > 0; l--, a[k++] = b[l])\n    ;\n  for (l = 2 * 2000100, j = 0, i = 0; i < k; i++) {\n    l = min(l, j + d[a[i]]);\n    j += e[a[i]];\n  }\n  return l;\n}\nint main() {\n  int n, i, j, k, b;\n  scanf(\"%s\", s);\n  n = strlen(s);\n  for (i = 0; i < n; s[i + n] = s[i], i++)\n    ;\n  sfa();\n  b = 0;\n  for (i = 0; i < n; i++)\n    if (s[i] == '(')\n      b++;\n    else\n      b--;\n  for (h = 1; h < 2 * n; h *= 2)\n    ;\n  for (i = 0; i < 2 * h; d[i] = 2 * 2000100, i++)\n    ;\n  for (i = 0; i < 2 * n; i++)\n    if (s[i] == '(') {\n      d[h + i] = 1;\n      e[h + i] = 1;\n    } else {\n      d[h + i] = -1;\n      e[h + i] = -1;\n    }\n  for (i = h - 1; i > 0; i--) {\n    d[i] = min(d[2 * i], e[2 * i] + d[2 * i + 1]);\n    e[i] = e[2 * i] + e[2 * i + 1];\n  }\n  for (i = 0; i < 2 * n; i++) {\n    j = m[i];\n    if (j < n) {\n      k = getm(j, j + n - 1);\n      if (b < 0) k -= b;\n      if (k >= 0) break;\n    }\n  }\n  if (b < 0)\n    for (i = 0; i < -b; printf(\"(\"), i++)\n      ;\n  for (i = 0; i < n; printf(\"%c\", s[i + j]), i++)\n    ;\n  if (b > 0)\n    for (i = 0; i < b; printf(\")\"), i++)\n      ;\n  printf(\"\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstring st;\nlong bal[1 << 20];\nlong minsuf[1 << 20], minpref[1 << 20];\nlong val1, val2;\nlong n;\nlong s[1 << 20];\nlong p[1 << 20], pn[1 << 20], cnt[1 << 20], c[1 << 20], cn[1 << 20];\nlong classes, mid1, mid2;\nlong ans, k;\nlong open, clos;\nlong blen, bc, tlen, nopen;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin >> st;\n  n = st.size();\n  for (int i = 0; i < n; i++)\n    if (st[i] == '(')\n      s[i] = 0;\n    else\n      s[i] = 1;\n  for (int i = 0; i < n; i++) ++cnt[s[i]];\n  for (int i = 1; i < 100; i++) cnt[i] += cnt[i - 1];\n  for (int i = 0; i < n; i++) {\n    p[--cnt[s[i]]] = i;\n  }\n  c[p[0]] = 0;\n  classes = 1;\n  for (int i = 1; i < n; i++) {\n    if (s[p[i]] != s[p[i - 1]]) ++classes;\n    c[p[i]] = classes - 1;\n  }\n  for (int h = 0; (1 << h) < n; ++h) {\n    for (int i = 0; i < n; i++) {\n      pn[i] = p[i] - (1 << h);\n      if (pn[i] < 0) pn[i] += n;\n    }\n    for (int i = 0; i <= classes; i++) cnt[i] = 0;\n    for (int i = 0; i < n; i++) cnt[c[pn[i]]]++;\n    for (int i = 1; i < classes; i++) cnt[i] += cnt[i - 1];\n    for (int i = n - 1; i >= 0; --i) p[--cnt[c[pn[i]]]] = pn[i];\n    cn[p[0]] = 0;\n    classes = 1;\n    for (int i = 1; i < n; i++) {\n      mid1 = p[i] + (1 << h);\n      mid2 = p[i - 1] + (1 << h);\n      mid1 %= n;\n      mid2 %= n;\n      if (c[p[i]] != c[p[i - 1]] || c[mid1] != c[mid2]) ++classes;\n      cn[p[i]] = classes - 1;\n    }\n    for (int i = 0; i <= n; i++) c[i] = cn[i];\n  }\n  for (int i = 0; i < st.size(); i++) {\n    if (st[i] == '(')\n      bal[i + 1] = bal[i] + 1;\n    else\n      bal[i + 1] = bal[i] - 1;\n    minpref[i + 1] = min(minpref[i], bal[i + 1]);\n    if (st[i] == '(')\n      ++open;\n    else\n      ++clos;\n  }\n  minsuf[st.size()] = bal[st.size()];\n  for (int i = st.size() - 1; i + 1; --i) {\n    minsuf[i] = min(minsuf[i + 1], bal[i]);\n  }\n  blen = 1e9;\n  bc = 0;\n  for (int i = 0; i < st.size(); i++) {\n    val1 = minsuf[i + 1] - bal[i];\n    val2 = minpref[i] + (bal[st.size()] - bal[i]);\n    val1 = min(val1, val2);\n    if (val1 >= 0) {\n      tlen = st.size() + (open - clos);\n      if (tlen < blen || (tlen == blen && c[i] < c[bc])) {\n        blen = tlen;\n        bc = i;\n      }\n    } else {\n      nopen = open - val1;\n      tlen = st.size() + (nopen - clos);\n      if (tlen < blen || (tlen == blen && c[i] < c[bc])) {\n        blen = tlen;\n        bc = i;\n      }\n    }\n  }\n  string ts = \"\";\n  for (int i = bc; i < st.size(); i++) ts += st[i];\n  for (int i = 0; i < bc; i++) ts += st[i];\n  long mb = 0;\n  long qb = 0;\n  for (int i = 0; i < ts.size(); i++) {\n    if (ts[i] == '(')\n      qb++;\n    else\n      qb--;\n    if (qb < mb) mb = qb;\n  }\n  reverse(ts.begin(), ts.end());\n  if (mb < 0) {\n    mb *= -1;\n    for (int i = 0; i < mb; i++) ts += '(';\n  }\n  reverse(ts.begin(), ts.end());\n  qb = 0;\n  for (int i = 0; i < ts.size(); i++) {\n    if (ts[i] == '(')\n      ++qb;\n    else\n      --qb;\n  }\n  for (int i = 0; i < qb; i++) ts += ')';\n  cout << ts << endl;\n  cin.get();\n  cin.get();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2000000 + 10;\nchar s[N];\nint n, pre[N];\nconst int INF = 1e9 + 7;\nint mx[N << 2], mn[N << 2];\nvector<int> vec;\nvoid build(int l, int r, int rt) {\n  if (l == r) {\n    mn[rt] = mx[rt] = pre[l];\n    return;\n  }\n  int mid = (l + r) >> 1;\n  build(l, mid, rt << 1);\n  build(mid + 1, r, rt << 1 | 1);\n  mx[rt] = max(mx[rt << 1], mx[rt << 1 | 1]);\n  mn[rt] = min(mn[rt << 1], mn[rt << 1 | 1]);\n}\nint querymin(int l, int r, int rt, int L, int R) {\n  if (L <= l && r <= R) return mn[rt];\n  int mid = (l + r) >> 1, ans = N;\n  if (L <= mid) ans = min(ans, querymin(l, mid, rt << 1, L, R));\n  if (R > mid) ans = min(ans, querymin(mid + 1, r, rt << 1 | 1, L, R));\n  return ans;\n}\nint querymax(int l, int r, int rt, int L, int R) {\n  if (L <= l && r <= R) return mx[rt];\n  int mid = (l + r) >> 1, ans = -N;\n  if (L <= mid) ans = max(ans, querymax(l, mid, rt << 1, L, R));\n  if (R > mid) ans = max(ans, querymax(mid + 1, r, rt << 1 | 1, L, R));\n  return ans;\n}\nchar str[N];\nint height[N], rk[N], sa[N], cc[N], t1[N], t2[N];\nbool cmp(int *y, int a, int b, int k) {\n  int a1 = y[a], a2 = a + k >= n ? -1 : y[a + k];\n  int b1 = y[b], b2 = b + k >= n ? -1 : y[b + k];\n  return a1 == b1 && a2 == b2;\n}\nvoid buildSA(int m) {\n  int *x = t1, *y = t2;\n  for (int i = 0; i < m; i++) cc[i] = 0;\n  for (int i = 0; i < n; i++) cc[x[i] = str[i]]++;\n  for (int i = 1; i < m; i++) cc[i] += cc[i - 1];\n  for (int i = n - 1; i >= 0; i--) sa[--cc[x[i]]] = i;\n  for (int k = 1; k <= n; k <<= 1) {\n    int p = 0;\n    for (int i = n - k; i < n; i++) y[p++] = i;\n    for (int i = 0; i < n; i++)\n      if (sa[i] >= k) y[p++] = sa[i] - k;\n    for (int i = 0; i < m; i++) cc[i] = 0;\n    for (int i = 0; i < n; i++) cc[x[y[i]]]++;\n    for (int i = 1; i < m; i++) cc[i] += cc[i - 1];\n    for (int i = n - 1; i >= 0; i--) sa[--cc[x[y[i]]]] = y[i];\n    swap(x, y);\n    m = 1, x[sa[0]] = 0;\n    for (int i = 1; i < n; i++) {\n      x[sa[i]] = cmp(y, sa[i - 1], sa[i], k) ? m - 1 : m++;\n    }\n    if (m >= n) break;\n  }\n}\nvoid buildH() {\n  for (int i = 0; i < n; i++) rk[sa[i]] = i;\n  int k = 0;\n  height[0] = 0;\n  for (int i = 0; i < n; i++) {\n    if (!rk[i]) continue;\n    if (k) k--;\n    int j = sa[rk[i] - 1];\n    while (s[i + k] == s[j + k]) k++;\n    height[rk[i]] = k;\n  }\n}\nvoid init() {\n  for (int i = 1; i <= n * 2; i++) str[i - 1] = s[i];\n  n = n * 2;\n  buildSA(1000);\n  buildH();\n  n = n / 2;\n}\nint main() {\n  scanf(\"%s\", s + 1);\n  n = strlen(s + 1);\n  for (int i = 1; i <= n; i++) s[i + n] = s[i];\n  for (int i = 1; i <= 2 * n; i++) pre[i] = pre[i - 1] + (s[i] == '(' ? 1 : -1);\n  build(1, 2 * n, 1);\n  init();\n  int need = pre[n];\n  pair<int, int> bst = make_pair(INF, 0);\n  for (int i = 1; i <= n; i++) {\n    int cnt = 0, cntLef = 0;\n    int m2 = querymin(1, n << 1, 1, i, i + n - 1);\n    if (need <= 0) {\n      cnt = -need +\n            max(max(-(m2 - pre[i - 1] - need), pre[i + n - 1] - m2), 0) * 2;\n      cntLef =\n          -need + max(max(-(m2 - pre[i - 1] - need), pre[i + n - 1] - m2), 0);\n    } else {\n      cnt = +need +\n            max(max(-(m2 - pre[i - 1]), pre[i + n - 1] - m2 - need), 0) * 2;\n      cntLef = max(max(-(m2 - pre[i - 1]), pre[i + n - 1] - m2 - need), 0);\n    }\n    if (make_pair(cnt, cntLef) < bst) {\n      bst = make_pair(cnt, cntLef);\n      vec.clear();\n    }\n    if (make_pair(cnt, cntLef) == bst) {\n      vec.push_back(i);\n    }\n  }\n  int mn = N;\n  int st = 0;\n  for (auto x : vec)\n    if (rk[x - 1] < mn) {\n      mn = rk[x - 1];\n      st = x;\n    }\n  for (int i = 1; i <= bst.second; i++) printf(\"(\");\n  for (int i = st; i < st + n; i++) printf(\"%c\", s[i]);\n  for (int i = 1; i <= bst.first - bst.second; i++) printf(\")\");\n  printf(\"\\n\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = (int)1e9;\nstruct SegmTree {\n  vector<int> t;\n  int sz;\n  SegmTree(const vector<int>& a) {\n    sz = 1;\n    while (sz < (int)a.size()) sz *= 2;\n    t.assign(sz * 2, INF);\n    for (int v = sz; v < sz + (int)a.size(); ++v) {\n      t[v] = a[v - sz];\n    }\n    for (int v = sz - 1; v > 0; --v) {\n      t[v] = min(t[v * 2], t[v * 2 + 1]);\n    }\n  }\n  int get_min(int l, int r) {\n    int res = INF;\n    l += sz;\n    r += sz;\n    while (l <= r) {\n      res = min(res, t[l]);\n      res = min(res, t[r]);\n      l = (l + 1) / 2;\n      r = (r - 1) / 2;\n    }\n    return res;\n  }\n};\nconst double EPS = 1e-9;\nconst int PP = 7;\nconst int MAXN = 1 << 21;\nconst int MOD[2] = {(int)1e9 + 7, (int)1e9 + 17};\nvoid add(int& x, int y, int mod) { ((x += y) >= mod) && (x -= mod); }\nint mul(int& x, int y, int mod) { return x * 1ll * y % mod; }\nstruct Hash {\n  static const int SZ = 2;\n  int v[SZ];\n  Hash(int x = 0) {\n    for (int i = 0; i < (int)SZ; ++i) v[i] = x;\n  }\n  void operator+=(const Hash& h) {\n    for (int i = 0; i < (int)SZ; ++i) {\n      add(v[i], h.v[i], MOD[i]);\n    }\n  }\n  void operator-=(const Hash& h) {\n    for (int i = 0; i < (int)SZ; ++i) {\n      add(v[i], -h.v[i] + MOD[i], MOD[i]);\n    }\n  }\n  void operator*=(const Hash& h) {\n    for (int i = 0; i < (int)SZ; ++i) {\n      v[i] = mul(v[i], h.v[i], MOD[i]);\n    }\n  }\n  void operator*=(const int& h) {\n    for (int i = 0; i < (int)SZ; ++i) {\n      v[i] = mul(v[i], h, MOD[i]);\n    }\n  }\n  void print() const { fprintf(stderr, \"%d %d\\n\", v[0], v[1]); }\n};\nHash operator*(const Hash& h1, const Hash& h2) {\n  Hash h = h1;\n  h *= h2;\n  return h;\n}\nHash operator*(const Hash& h1, const int& h2) {\n  Hash h = h1;\n  h *= h2;\n  return h;\n}\nHash operator+(const Hash& h1, const Hash& h2) {\n  Hash h = h1;\n  h += h2;\n  return h;\n}\nHash operator-(const Hash& h1, const Hash& h2) {\n  Hash h = h1;\n  h -= h2;\n  return h;\n}\nbool operator==(const Hash& h1, const Hash& h2) {\n  return h1.v[0] == h2.v[0] && h1.v[1] == h2.v[1];\n}\nbool operator!=(const Hash& h1, const Hash& h2) {\n  return !(h1.v[0] == h2.v[0] && h1.v[1] == h2.v[1]);\n}\nbool operator<(const Hash& h1, const Hash& h2) {\n  return h1.v[0] < h2.v[0] || (h1.v[0] == h2.v[0] && h1.v[1] < h2.v[1]);\n}\nHash P[MAXN];\nstruct Solver {\n  vector<Hash> pref;\n  vector<Hash> P;\n  string s;\n  Solver(const string& s) : s(s) {\n    P.resize(MAXN);\n    P[0] = Hash(1);\n    for (int i = 1; i < MAXN; ++i) {\n      P[i] = PP * P[i - 1];\n    }\n    pref.assign(((int)(s).size()) + 1, 0);\n    for (int i = 0; i < (int)((int)(s).size()); ++i) {\n      int c = (s[i] == ')') + 1;\n      Hash cur = P[i] * c;\n      pref[i + 1] = pref[i] + cur;\n    }\n  }\n  Hash hash(int l, int r) {\n    Hash res = pref[r + 1] - pref[l];\n    res *= P[MAXN - r - 1];\n    return res;\n  }\n};\nint nn;\nSolver text_hashes(\"dfdgggd\");\nstring text;\nbool weird_cmp(int l, int r) {\n  int maxlen = nn - max(l, r);\n  int left = 0;\n  int right = maxlen + 1;\n  while (right - left > 1) {\n    int mid = (right + left) / 2;\n    if (text_hashes.hash(l, mid + l - 1) == text_hashes.hash(r, mid + r - 1))\n      left = mid;\n    else\n      right = mid;\n  }\n  return text[l + left] < text[r + left];\n}\nvoid solve(string s) {\n  int n = (int)s.size();\n  nn = 2 * n;\n  text = s + s + char(0) + char(0) + char(0);\n  vector<int> pref(2 * n + 1, 0);\n  for (int i = 1; i <= 2 * n; i++)\n    pref[i] = pref[i - 1] + (text[i - 1] == '(' ? 1 : -1);\n  SegmTree Min(pref);\n  vector<int> minbal(n);\n  for (int i = 0; i < n; i++) {\n    int l = i + 1;\n    int r = i + n;\n    int cnt = Min.get_min(l, r) - pref[i];\n    if (cnt > 0) cnt = 0;\n    minbal[i] = cnt;\n  }\n  vector<int> cands;\n  int allbest = *max_element(minbal.begin(), minbal.end());\n  assert(allbest <= 0);\n  for (int i = 0; i < n; i++)\n    if (minbal[i] == allbest) cands.push_back(i);\n  text_hashes = Solver(text);\n  int pos = *min_element(cands.begin(), cands.end(), weird_cmp);\n  string ans = string(-allbest, '(');\n  ans += text.substr(pos, n);\n  int cntbal = 0;\n  for (int i = 0; i < (int)ans.size(); i++) {\n    if (ans[i] == '(')\n      cntbal++;\n    else if (ans[i] == ')')\n      cntbal--;\n    else\n      assert(0);\n    assert(cntbal >= 0);\n  }\n  ans += string(cntbal, ')');\n  cout << ans << endl;\n}\nint main() {\n  string s;\n  while (cin >> s) solve(s);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline T Abs(const T& x) {\n  return x < 0 ? -x : x;\n}\ntemplate <class T>\ninline T Sqr(const T& x) {\n  return x * x;\n}\nnamespace NSuffixArray {\nvoid ZipValues(vector<int>& input) {\n  vector<pair<int, int> > tmp;\n  for (size_t i = 0; i < input.size(); ++i) {\n    tmp.push_back(make_pair(input[i], i));\n  }\n  sort(tmp.begin(), tmp.end());\n  int classes = 0;\n  for (size_t i = 0; i < tmp.size(); ++i) {\n    if (i == 0 || tmp[i].first != tmp[i - 1].first) {\n      ++classes;\n    }\n    input[tmp[i].second] = classes - 1;\n  }\n}\nvoid CalcAndAggCnt(const vector<int>& cl, vector<int>& cnt) {\n  cnt.assign(cl.size(), 0);\n  for (size_t i = 0; i < cl.size(); ++i) {\n    ++cnt[cl[i]];\n  }\n  for (size_t i = 0; i < cnt.size(); ++i) {\n    cnt[i] += i > 0 ? cnt[i - 1] : 0;\n  }\n}\ninline int SoftMod(int a, int n) {\n  return a < 0 ? n + a : (a >= n ? a - n : a);\n}\nvector<int> SortedShifts(vector<int> input) {\n  ZipValues(input);\n  int n = input.size(), classes = 0;\n  vector<int> sa(n, 0), nsa(n, 0), cnt(n, 0);\n  vector<int> cl = input, oldcl(n, 0);\n  CalcAndAggCnt(cl, cnt);\n  for (int i = 0; i < n; ++i) {\n    sa[--cnt[cl[i]]] = i;\n  }\n  for (int h = 1; h < n; h <<= 1) {\n    CalcAndAggCnt(cl, cnt);\n    for (int i = 0; i < n; ++i) {\n      nsa[i] = SoftMod(sa[i] - h, n);\n    }\n    for (int i = n - 1; i >= 0; --i) {\n      sa[--cnt[cl[nsa[i]]]] = nsa[i];\n    }\n    classes = 0;\n    oldcl.swap(cl);\n    for (int i = 0; i < n; ++i) {\n      if (classes == 0 || oldcl[sa[i]] > oldcl[sa[i - 1]] ||\n          oldcl[SoftMod(sa[i] + h, n)] > oldcl[SoftMod(sa[i - 1] + h, n)]) {\n        ++classes;\n      }\n      cl[sa[i]] = classes - 1;\n    }\n  }\n  return sa;\n}\nvector<int> SortedShifts(const string& input) {\n  vector<int> arrayInput(input.begin(), input.end());\n  return SortedShifts(arrayInput);\n}\nvector<int> SortedArray(vector<int> array) {\n  int mn = array[0];\n  for (size_t i = 1; i < array.size(); ++i) {\n    if (array[i] < mn) {\n      mn = array[i];\n    }\n  }\n  --mn;\n  array.push_back(mn);\n  auto sorted = SortedShifts(array);\n  for (size_t i = 0; i < sorted.size(); ++i) {\n    if (array[sorted[i]] == mn) {\n      sorted.erase(sorted.begin() + i);\n      break;\n    }\n  }\n  return sorted;\n}\nvector<int> SortedArray(const string& s) {\n  vector<int> arrayInput(s.begin(), s.end());\n  return SortedArray(arrayInput);\n}\n}  // namespace NSuffixArray\nstruct TParInfo {\n  int AddLeft;\n  int AddRight;\n  int SortedPos;\n  int Shift;\n};\nint main() {\n  ios_base::sync_with_stdio(false);\n  string s;\n  cin >> s;\n  vector<int> sortedShifts = NSuffixArray::SortedShifts(s);\n  vector<int> shiftPos(s.length());\n  for (size_t i = 0; i < sortedShifts.size(); ++i) {\n    shiftPos[sortedShifts[i]] = i;\n  }\n  vector<int> balance(s.length() + 1, 0);\n  for (size_t i = 1; i <= s.length(); ++i) {\n    balance[i] += balance[i - 1] + (s[i - 1] == '(' ? +1 : -1);\n  }\n  vector<int> leftMin(s.length() + 1, 0);\n  vector<int> rightMin(s.length() + 1, 0);\n  for (size_t i = 1; i <= s.length(); ++i) {\n    leftMin[i] = min(balance[i], leftMin[i - 1]);\n  }\n  rightMin[s.length()] = balance[s.length()];\n  for (int i = static_cast<int>(s.length()) - 1; i >= 0; --i) {\n    rightMin[i] = min(balance[i], rightMin[i + 1]);\n  }\n  TParInfo bestInfo;\n  bestInfo.AddLeft = s.length() * 4;\n  bestInfo.AddRight = s.length() * 4;\n  vector<TParInfo> parInfo(s.length());\n  for (size_t i = 0; i < s.length(); ++i) {\n    TParInfo& info = parInfo[i];\n    info.AddLeft = info.AddRight = 0;\n    info.SortedPos = shiftPos[i];\n    info.Shift = i;\n    int rMin = rightMin[i] - balance[i];\n    int lMin = leftMin[i] + (balance[s.length()] - balance[i]);\n    int totalMin = min(lMin, rMin);\n    if (totalMin < 0) {\n      info.AddLeft = -totalMin;\n    }\n    if (info.AddLeft + balance[s.length()] > 0) {\n      info.AddRight = info.AddLeft + balance[s.length()];\n    }\n    if (info.AddLeft + info.AddRight < bestInfo.AddLeft + bestInfo.AddRight) {\n      bestInfo = info;\n    }\n  }\n  for (size_t i = 0; i < s.length(); ++i) {\n    TParInfo& info = parInfo[i];\n    if (bestInfo.AddLeft + bestInfo.AddRight == info.AddLeft + info.AddRight) {\n      if (bestInfo.SortedPos > info.SortedPos) {\n        bestInfo = info;\n      }\n    }\n  }\n  for (int i = 0; i < bestInfo.AddLeft; ++i) {\n    cout << '(';\n  }\n  rotate(s.begin(), s.begin() + bestInfo.Shift, s.end());\n  cout << s;\n  for (int i = 0; i < bestInfo.AddRight; ++i) {\n    cout << ')';\n  }\n  cout << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace IO {\nconst int sz = 1 << 15;\nchar inbuf[sz], outbuf[sz];\nchar *pinbuf = inbuf + sz;\nchar *poutbuf = outbuf;\ninline char _getchar() {\n  if (pinbuf == inbuf + sz) fread(inbuf, 1, sz, stdin), pinbuf = inbuf;\n  return *(pinbuf++);\n}\ninline void _putchar(char x) {\n  if (poutbuf == outbuf + sz) fwrite(outbuf, 1, sz, stdout), poutbuf = outbuf;\n  *(poutbuf++) = x;\n}\ninline void flush() {\n  if (poutbuf != outbuf)\n    fwrite(outbuf, 1, poutbuf - outbuf, stdout), poutbuf = outbuf;\n}\n}  // namespace IO\ninline int read() {\n  int x = 0, p = 1;\n  char c = IO::_getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') p = -1;\n    c = IO::_getchar();\n  }\n  while (c >= '0' && c <= '9') x = x * 10 + c - 48, c = IO::_getchar();\n  return x * p;\n}\nconst int Maxn = 1e6 + 5;\nchar c[Maxn];\nint n;\nstruct br {\n  int v, m;\n  br() { v = m = 0; }\n  br(int _v, int _m) { v = _v, m = _m; }\n  br(char __) {\n    int _x = (__ == '(') ? 1 : -1;\n    v = _x, m = min(0, _x);\n  }\n  br operator+(br x) { return br(v + x.v, min(m, v + x.m)); }\n};\nconst long long mod1 = 998244353;\nconst long long mod2 = 1e9 + 9;\nint H1[Maxn][22], H2[Maxn][22];\nbr pre[Maxn], suf[Maxn];\nlong long pw1[25], pw2[25];\nbool cmp(int x, int y) {\n  int lim = 1;\n  while ((1 << lim) <= n) lim++;\n  for (int i = lim - 1; i >= 0; i--) {\n    if (H1[x][i] == H1[y][i] && H2[x][i] == H2[y][i]) {\n      x += 1 << i;\n      y += 1 << i;\n      if (x > n) x -= n;\n      if (y > n) y -= n;\n    }\n  }\n  return c[x] < c[y];\n}\nint main() {\n  scanf(\"%s\", c + 1);\n  n = strlen(c + 1);\n  for (int i = 1; i <= n; i++) H1[i][0] = H2[i][0] = c[i];\n  pw1[0] = 3948243;\n  for (int i = 1; i < 25; i++) pw1[i] = pw1[i - 1] * pw1[i - 1] % mod1;\n  pw2[0] = 3948243;\n  for (int i = 1; i < 25; i++) pw2[i] = pw2[i - 1] * pw2[i - 1] % mod2;\n  for (int i = 1, j = 2; j <= n; i++, j <<= 1) {\n    for (int k = 1; k <= n; k++) {\n      int nk = k + (j >> 1);\n      if (nk > n) nk -= n;\n      H1[k][i] = (1ll * H1[k][i - 1] * pw1[i - 1] + H1[nk][i - 1]) % mod1;\n      H2[k][i] = (1ll * H2[k][i - 1] * pw2[i - 1] + H2[nk][i - 1]) % mod2;\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    pre[i] = pre[i - 1] + br(c[i]);\n  }\n  for (int i = n; i >= 1; i--) {\n    suf[i] = br(c[i]) + suf[i + 1];\n  }\n  int tot = min(pre[n].v, 0);\n  int ans = -1;\n  for (int i = 1; i <= n; i++) {\n    br tmp = suf[i] + pre[i - 1];\n    if (tmp.m == tot) {\n      if (ans == -1)\n        ans = i;\n      else {\n        if (cmp(i, ans)) ans = i;\n      }\n    }\n  }\n  tot = pre[n].v;\n  string res;\n  for (int i = ans; i <= n; i++) res += c[i];\n  for (int i = 1; i < ans; i++) res += c[i];\n  if (tot > 0) {\n    for (int i = 0; i < tot; i++) res += ')';\n  } else {\n    string tmp;\n    for (int i = 0; i < (-tot); i++) tmp += '(';\n    res = tmp + res;\n  }\n  printf(\"%s\\n\", res.c_str());\n  return ~~(0 ^ 0 ^ 0);\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:666777216\")\nusing namespace std;\nconst int N = 1000007;\nchar st[N];\nint n, sum[N], openCnt[N];\nstruct segTree {\n  int T[4 * N];\n  void build(int v, int tl, int tr, int *sum) {\n    if (tl == tr) {\n      T[v] = sum[tl];\n      return;\n    }\n    int tm = (tl + tr) / 2;\n    build(2 * v, tl, tm, sum);\n    build(2 * v + 1, tm + 1, tr, sum);\n    T[v] = min(T[2 * v], T[2 * v + 1]);\n  }\n  void update(int v, int tl, int tr, int pos, int val) {\n    if (tl == tr) {\n      T[v] = val;\n      return;\n    }\n    int tm = (tl + tr) / 2;\n    if (pos <= tm)\n      update(2 * v, tl, tm, pos, val);\n    else\n      update(2 * v + 1, tm + 1, tr, pos, val);\n    T[v] = min(T[2 * v], T[2 * v + 1]);\n  }\n  int get(int v, int tl, int tr, int l, int r) {\n    if (r < l) return N;\n    if (tl == l && tr == r) return T[v];\n    int tm = (tl + tr) / 2;\n    if (r <= tm) return get(2 * v, tl, tm, l, r);\n    if (l > tm) return get(2 * v + 1, tm + 1, tr, l, r);\n    return min(get(2 * v, tl, tm, l, tm),\n               get(2 * v + 1, tm + 1, tr, tm + 1, r));\n  }\n} tree;\ninline int get(int l, int r, int *sum) {\n  if (l > r) return 0;\n  if (l == 0) return sum[r];\n  return sum[r] - sum[l - 1];\n}\nint open[N], close[N];\ninline int code(char c) { return c == '(' ? 0 : 1; }\nstruct SA {\n  int pos[N], tpos[N], cnt[N], rev[N];\n  int C[21][N];\n  void build() {\n    memset(cnt, 0, sizeof cnt);\n    for (int i = 0; i < (n); ++i) ++cnt[code(st[i])];\n    for (int i = 0; i < (n); ++i) {\n      if (i) cnt[i] += cnt[i - 1];\n    }\n    for (int i = n - 1; i >= 0; --i) {\n      pos[i] = --cnt[code(st[i])];\n    }\n    for (int i = 0; i < (n); ++i) {\n      C[0][i] = code(st[i]);\n    }\n    for (int h = 1, lev = 0; h < n; h <<= 1, ++lev) {\n      for (int i = 0; i < (n); ++i) {\n        tpos[i] = pos[(i + h) % n];\n      }\n      memset(cnt, 0, sizeof cnt);\n      for (int i = 0; i < (n); ++i) ++cnt[C[lev][i]];\n      for (int i = 0; i < (n); ++i) {\n        if (i) cnt[i] += cnt[i - 1];\n      }\n      for (int i = 0; i < (n); ++i) {\n        rev[tpos[i]] = i;\n      }\n      for (int i = n - 1; i >= 0; --i) {\n        int ind = rev[i];\n        pos[ind] = --cnt[C[lev][ind]];\n      }\n      for (int i = 0; i < (n); ++i) {\n        rev[pos[i]] = i;\n      }\n      C[lev + 1][rev[0]] = 0;\n      for (int i = 1, cur = 0; i < n; ++i) {\n        if (C[lev][rev[i - 1]] != C[lev][rev[i]] ||\n            C[lev][(rev[i - 1] + h) % n] != C[lev][(rev[i] + h) % n])\n          ++cur;\n        C[lev + 1][rev[i]] = cur;\n      }\n    }\n  }\n} sa;\nbool checkOpen(int i, int j) {\n  if (i < j) return get(i, j, openCnt) == j - i + 1;\n  return get(i, n - 1, openCnt) + get(0, j, openCnt) ==\n         n - 1 - i + 1 + j - 0 + 1;\n}\nint cmp(int i, int j, int len) {\n  for (int h = 19; h >= 0; --h) {\n    if ((1 << h) > len) continue;\n    if (sa.C[h][i] < sa.C[h][j]) return -1;\n    if (sa.C[h][i] > sa.C[h][j]) return 1;\n    i = (i + (1 << h)) % n;\n    j = (j + (1 << h)) % n;\n  }\n  return 0;\n}\nbool compare(int i, int j) {\n  int op1 = open[i] - min(open[i], open[j]);\n  int op2 = open[j] - min(open[i], open[j]);\n  int cl1 = close[i];\n  int cl2 = close[j];\n  if (op1 != 0) {\n    if (!checkOpen(j, (j + op1) % n)) return true;\n    j = (j + op1) % n;\n  }\n  if (op2 != 0) {\n    if (!checkOpen(i, (i + op2) % n)) return false;\n    i = (i + op2) % n;\n  }\n  int res = cmp(i, j, n - max(op1, op2));\n  if (res == -1) return true;\n  if (res == 1) return false;\n  return cl1 <= cl2;\n}\nvoid solve() {\n  scanf(\"%s\", st);\n  n = strlen(st);\n  for (int i = 0; i < (n); ++i) {\n    int psum = (i ? sum[i - 1] : 0);\n    if (st[i] == '(')\n      sum[i] = psum + 1;\n    else\n      sum[i] = psum - 1;\n    int popen = (i ? openCnt[i - 1] : 0);\n    if (st[i] == '(')\n      openCnt[i] = popen + 1;\n    else\n      openCnt[i] = popen;\n  }\n  tree.build(1, 0, n - 1, sum);\n  int totalBal = sum[n - 1];\n  for (int i = 0; i < (n); ++i) {\n    int min1 = tree.get(1, 0, n - 1, i, n - 1) - get(0, i - 1, sum);\n    int min2 = tree.get(1, 0, n - 1, 0, i - 1) + get(i, n - 1, sum);\n    int mini = min(min1, min2);\n    if (mini >= 0) {\n      close[i] = totalBal;\n    } else {\n      open[i] = -mini;\n      if (totalBal + open[i] < 0)\n        open[i] += -(totalBal + open[i]);\n      else\n        close[i] = totalBal + open[i];\n    }\n  }\n  int minAdd = N + N;\n  for (int i = 0; i < (n); ++i) {\n    minAdd = min(minAdd, open[i] + close[i]);\n  }\n  sa.build();\n  int best = -1;\n  for (int i = 0; i < (n); ++i) {\n    if (open[i] + close[i] != minAdd) continue;\n    if (best == -1 || compare(i, best)) {\n      best = i;\n    }\n  }\n  for (int i = 0; i < (open[best]); ++i) putchar('(');\n  for (int i = best; i < n; ++i) {\n    putchar(st[i]);\n  }\n  for (int i = 0; i < best; ++i) {\n    putchar(st[i]);\n  }\n  for (int i = 0; i < (close[best]); ++i) putchar(')');\n}\nint rd() { return (((long long)rand() << 16) ^ rand()) % 1000000000; }\nvoid testGen() {\n  FILE *f = fopen(\"input.txt\", \"w\");\n  fclose(f);\n}\nint main() {\n  cerr << fixed;\n  cerr.precision(5);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  cin.sync_with_stdio(0);\n  cin.tie(0);\n  string s;\n  cin >> s;\n  int N = s.length();\n  int d = 0;\n  for (int i = 0; i < N; i++) {\n    if (s[i] == '(')\n      d++;\n    else\n      d--;\n  }\n  set<pair<int, int> > S1;\n  vector<int> Sv(N);\n  int sA = 0;\n  for (int i = 0; i < N; i++) {\n    if (s[i] == '(')\n      sA++;\n    else\n      sA--;\n    Sv[i] = sA;\n    S1.insert(make_pair(sA, i));\n  }\n  vector<int> Ppos(1, 0);\n  int ans = max(((d < 0) ? -(d) : d), -S1.begin()->first);\n  sA = 0;\n  if (d >= 0) ans = d + max(0, -S1.begin()->first);\n  for (int i = 0; i < N - 1; i++) {\n    S1.erase(make_pair(Sv[i], i));\n    sA = min(sA, Sv[i]);\n    int c;\n    if (d >= 0)\n      c = d + max(0, max(-S1.begin()->first + Sv[i], -sA - Sv[N - 1] + Sv[i]));\n    else\n      c = max(0, max(-S1.begin()->first + Sv[i], -sA - Sv[N - 1] + Sv[i]));\n    if (ans > c) {\n      ans = c;\n      Ppos.clear();\n    }\n    if (ans == c) Ppos.push_back(i + 1);\n  }\n  N *= 2;\n  vector<vector<int> > V1(256);\n  V1[0].push_back(N);\n  for (int i = 0; i < N; i++) V1[s[i % (N / 2)]].push_back(i);\n  int K = 5;\n  while (1 << (K - 1) < N) K++;\n  vector<int> isB(N + 1 + (1 << (K - 1)), 0);\n  vector<int> SA(N + 1, N);\n  vector<int> Bs(N + 2, N + 1);\n  Bs[0] = 0;\n  int Btot = -1, q = 0;\n  for (int j = 0; j < 256; j++) {\n    if (!V1[j].empty()) Bs[++Btot] = q;\n    for (unsigned int i = 0; i < V1[j].size(); i++) {\n      SA[q] = V1[j][i];\n      isB[V1[j][i]] = Btot;\n      q++;\n    }\n  }\n  vector<pair<int, int> > tmp(N + 1);\n  vector<int> Bs1(N + 1, 0);\n  vector<int> nxtB(N + 1, 0), pos(N + 1, 0);\n  for (int i = 1; i < K; i++) {\n    int q = 1 << (i - 1);\n    for (int j = 0; j <= Btot; j++) Bs1[j] = 0;\n    for (int j = 0; j <= N; j++) nxtB[j] = isB[SA[j] + q];\n    for (int j = 0; j <= Btot; j++)\n      if (Bs[j + 1] - Bs[j] > 1)\n        for (int k = Bs[j]; k < Bs[j + 1]; k++) Bs1[nxtB[k]]++;\n    int s = 0;\n    for (int j = 0; j <= Btot; j++) {\n      int s2 = Bs1[j] + s;\n      Bs1[j] = s;\n      s = s2;\n    }\n    for (int j = 0; j <= Btot; j++)\n      if (Bs[j + 1] - Bs[j] > 1)\n        for (int k = Bs[j]; k < Bs[j + 1]; k++) pos[k] = Bs1[nxtB[k]]++;\n    for (int j = 0; j <= Btot; j++)\n      if (Bs[j + 1] - Bs[j] > 1)\n        for (int k = Bs[j]; k < Bs[j + 1]; k++) {\n          tmp[pos[k]].first = SA[k];\n          tmp[pos[k]].second = j;\n        }\n    for (int j = 0; j < s; j++) pos[j] = Bs[tmp[j].second]++;\n    for (int j = 0; j < s; j++) SA[pos[j]] = tmp[j].first;\n    for (int j = 0; j <= N; j++) nxtB[j] = isB[SA[j] + q];\n    Btot = 0;\n    Bs[0] = 0;\n    for (int j = 1; j <= N; j++) {\n      if (isB[SA[j]] != isB[SA[j - 1]] || nxtB[j] != nxtB[j - 1])\n        pos[j] = ++Btot;\n      else\n        pos[j] = pos[j - 1];\n    }\n    int p = 0;\n    for (int j = 1; j <= N; j++) {\n      if (p + 1 == pos[j]) Bs[++p] = j;\n      isB[SA[j]] = p;\n    }\n  }\n  vector<int> invP(N + 1);\n  for (int i = 0; i <= N; i++) invP[SA[i]] = i;\n  int optR = Ppos[0], optP = invP[Ppos[0]];\n  for (unsigned int i = 0; i < Ppos.size(); i++)\n    if (optP > invP[Ppos[i]]) {\n      optR = Ppos[i];\n      optP = invP[Ppos[i]];\n    }\n  string s2;\n  for (int i = 0; i < -d; i++) s2 += \"(\";\n  for (int i = optR; i < N / 2; i++) s2 += s[i];\n  for (int i = 0; i < optR; i++) s2 += s[i];\n  for (int i = 0; i < d; i++) s2 += \")\";\n  cout << s2 << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 3;\nconst int M = 5e6 + 3;\nconst int oo = 1e9;\nconst int OS = 317;\nconst int MOD = 1e9 + 7;\nchar s[N];\nint n, stp[M], p1[N], p2[N], s1[N], s2[N], ho[N], hz[N], h[N];\nvector<int> st;\nint get(int i, int ln) {\n  int op, zp, zs, os, il, ir, ans, l1, l, r, ym;\n  op = p2[i];\n  zp = i - p1[i] - op;\n  zs = s2[i + 1];\n  os = n - i - s1[i + 1] - zs;\n  il = zs;\n  ir = op;\n  if (os > zp)\n    ir += os - zp;\n  else\n    il += zp - os;\n  l1 = min(il, ln);\n  ym = 2 * n;\n  ans = (stp[ym] * 1LL * ho[l1]) % MOD;\n  if (ln - l1 > 0) {\n    l = i + 1;\n    r = l + min(n - i, ln - l1) - 1;\n    ans = (ans + (((h[r] - h[l - 1]) % MOD + MOD) % MOD) * 1LL *\n                     stp[ym + l1 - (l - 1)] % MOD) %\n          MOD;\n    l1 += r - l + 1;\n    if (ln - l1 > 0) {\n      r = min(i, ln - l1);\n      ans = (ans + h[r] * 1LL * stp[ym + l1] % MOD) % MOD;\n      l1 += r;\n      if (ln - l1 > 0) {\n        r = ln - l1;\n        ans = (ans + hz[r] * 1LL * stp[ym + l1] % MOD) % MOD;\n      }\n    }\n  }\n  return ans;\n}\nint get_ch(int i, int ln) {\n  int op, zp, zs, os, il, ir;\n  op = p2[i];\n  zp = i - p1[i] - op;\n  zs = s2[i + 1];\n  os = n - i - s1[i + 1] - zs;\n  il = zs;\n  ir = op;\n  if (os > zp)\n    ir += os - zp;\n  else\n    il += zp - os;\n  if (ln <= il) return '(';\n  ln -= il;\n  if (ln <= n - i) return s[i + ln];\n  ln -= n - i;\n  if (ln <= i)\n    return s[ln];\n  else\n    return ')';\n}\nint ans;\nbool cmp(int i, int j) {\n  int l, r, x;\n  l = 1, r = ans;\n  while (l <= r) {\n    x = (l + r) >> 1;\n    if (get(i, x) == get(j, x))\n      l = x + 1;\n    else\n      r = x - 1;\n  }\n  if (r + 1 > ans) return true;\n  return get_ch(i, r + 1) <= get_ch(j, r + 1);\n}\nvoid make(char *s) {\n  int i, n;\n  srand(time(NULL));\n  n = 100;\n  for (i = 0; i <= n; ++i)\n    if (rand() % 2 == 0)\n      s[i] = '(';\n    else\n      s[i] = ')';\n  s[n + 1] = 0;\n}\nchar ss[1000][1000];\nbool cmp1(int i, int j) {\n  int li, lj, u, l;\n  li = strlen(ss[i]);\n  lj = strlen(ss[j]);\n  l = min(li, lj);\n  if (li < lj)\n    return true;\n  else if (li > lj)\n    return false;\n  for (u = 0; u < l; ++u)\n    if (ss[i][u] < ss[j][u])\n      return true;\n    else if (ss[i][u] > ss[j][u])\n      return false;\n  if (li == u)\n    return true;\n  else\n    return false;\n}\nchar bd[2 * N], na[2 * N];\nvoid solve(char *s) {\n  int i, j, n, op, zp, zs, os, il, ir, m, mn;\n  n = strlen(s + 1);\n  for (i = 0; i < n; ++i) {\n    op = p2[i];\n    zp = i - p1[i] - op;\n    zs = s2[i + 1];\n    os = n - i - s1[i + 1] - zs;\n    il = zs;\n    ir = op;\n    if (os > zp)\n      ir += os - zp;\n    else\n      il += zp - os;\n    m = 0;\n    for (j = 0; j < il; ++j) ss[i][m++] = '(';\n    for (j = i + 1; j <= n; ++j) ss[i][m++] = s[j];\n    for (j = 1; j <= i; ++j) ss[i][m++] = s[j];\n    for (j = 0; j < ir; ++j) ss[i][m++] = ')';\n    ss[i][m] = 0;\n  }\n  mn = 0;\n  for (i = 0; i < n; ++i)\n    if (cmp1(i, mn)) mn = i;\n  m = strlen(ss[mn]);\n  for (i = 0; i < m; ++i) bd[i] = ss[mn][i];\n  bd[m] = 0;\n}\nchar san[N];\nint main() {\n  int i, j, op, zp, zs, os, len, mn;\n  while (1) {\n    gets(s + 1);\n    n = strlen(s + 1);\n    for (i = 1; i <= n; ++i)\n      if (s[i] == '(')\n        p1[i] = p1[i - 1], p2[i] = p2[i - 1] + 1;\n      else if (p2[i - 1])\n        p1[i] = p1[i - 1] + 2, p2[i] = p2[i - 1] - 1;\n      else\n        p1[i] = p1[i - 1], p2[i] = p2[i - 1];\n    for (i = n; i; --i)\n      if (s[i] == ')')\n        s1[i] = s1[i + 1], s2[i] = s2[i + 1] + 1;\n      else if (s2[i + 1])\n        s1[i] = s1[i + 1] + 2, s2[i] = s2[i + 1] - 1;\n      else\n        s1[i] = s1[i + 1], s2[i] = s2[i + 1];\n    ans = oo;\n    for (i = 0; i < n; ++i) {\n      op = p2[i];\n      zp = i - p1[i] - op;\n      zs = s2[i + 1];\n      os = n - i - s1[i + 1] - zs;\n      len = n + zs + op + max(os, zp) - min(os, zp);\n      if (ans > len) st.clear();\n      if (ans >= len) ans = len, st.push_back(i);\n    }\n    stp[0] = 1;\n    for (i = 1; i < M; ++i) stp[i] = (stp[i - 1] * 1LL * OS) % MOD;\n    ho[0] = hz[0] = 0;\n    for (i = 1; i < N; ++i)\n      ho[i] = (ho[i - 1] + '(' * 1LL * stp[i - 1] % MOD) % MOD;\n    for (i = 1; i < N; ++i)\n      hz[i] = (hz[i - 1] + ')' * 1LL * stp[i - 1] % MOD) % MOD;\n    h[0] = 0;\n    for (i = 1; i <= n; ++i)\n      h[i] = (h[i - 1] + s[i] * 1LL * stp[i - 1] % MOD) % MOD;\n    mn = st[0];\n    for (i = 1; i < (int)st.size(); ++i) {\n      if (cmp(st[i], mn)) mn = st[i];\n    }\n    i = mn;\n    int il, ir;\n    op = p2[i];\n    zp = i - p1[i] - op;\n    zs = s2[i + 1];\n    os = n - i - s1[i + 1] - zs;\n    il = zs;\n    ir = op;\n    if (os > zp)\n      ir += os - zp;\n    else\n      il += zp - os;\n    int m = 0;\n    for (j = 0; j < il; ++j) na[m++] = '(';\n    for (j = i + 1; j <= n; ++j) na[m++] = s[j];\n    for (j = 1; j <= i; ++j) na[m++] = s[j];\n    for (j = 0; j < ir; ++j) na[m++] = ')';\n    na[m++] = 0;\n    printf(\"%s\\n\", na);\n    return 0;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2111111;\nchar buf[maxn];\nint sum[maxn];\nbool ok[maxn];\nint order[maxn];\ntemplate <typename T>\nvoid debug(T a[], int n) {\n  for (int i = 1; i <= n; ++i) {\n    cout << setw(3) << a[i];\n  }\n  puts(\"\");\n}\nvoid fix(int& i, int n) {\n  while (!ok[i] && i <= n) {\n    ++i;\n  }\n}\nint run(char s[], int m) {\n  int n = m >> 1;\n  int i = 1, j = 2, k = 0;\n  fix(i, n);\n  j = i + 1;\n  fix(j, n);\n  while (j <= n) {\n    for (k = 0; k < n; ++k) {\n      if (s[i + k] ^ s[j + k]) {\n        break;\n      }\n    }\n    if (s[i + k] > s[j + k]) {\n      i += k + 1;\n      fix(i, n);\n    } else {\n      j += k + 1;\n      fix(j, n);\n    }\n    if (j == i) {\n      ++j;\n      fix(j, n);\n    }\n  }\n  return std::min(i, j);\n}\nint main() {\n  for (int i = 1; i < 100; ++i) {\n    order[i] = i;\n  }\n  scanf(\"%s\", buf + 1);\n  int n = std::strlen(buf + 1);\n  int A, B;\n  A = B = 0;\n  for (int i = 1; i <= n; ++i) {\n    buf[i + n] = buf[i];\n    if (buf[i] == '(') {\n      ++A;\n    } else {\n      ++B;\n    }\n  }\n  int m = n << 1;\n  for (int i = 1; i <= m; ++i) {\n    if (buf[i] == '(') {\n      sum[i] = 1;\n    } else {\n      sum[i] = -1;\n    }\n    sum[i] += sum[i - 1];\n  }\n  static int q[maxn];\n  int front, rear;\n  front = rear = 0;\n  static int min[maxn];\n  int add = 0;\n  if (A < B) {\n    add = B - A;\n  }\n  for (int i = 1; i <= m; ++i) {\n    if (front < rear && q[front] + n <= i) {\n      ++front;\n    }\n    while (front < rear && sum[q[rear - 1]] >= sum[i]) {\n      --rear;\n    }\n    q[rear++] = i;\n    min[i] = sum[q[front]];\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (add + min[i + n - 1] >= sum[i - 1]) {\n      ok[i] = true;\n    }\n  }\n  int index = run(buf, m);\n  auto print = [](char ch, int n) {\n    while (n--) {\n      putchar(ch);\n    }\n  };\n  if (A < B) {\n    print('(', B - A);\n  }\n  for (int i = index; i < index + n; ++i) {\n    putchar(buf[i]);\n  }\n  if (B < A) {\n    print(')', A - B);\n  }\n  puts(\"\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar p[2010000], Ans[2010000 * 2];\nint n, D[1010000], D2[1010000], C[2010000], ord[2010000], ord2[2010000],\n    SA[2010000], MM, P[1010000], Pcnt;\nint X[2010000], Y[2010000];\nvoid Suffix_Array(int m) {\n  int i, L = 2, M, cnt, cc, t;\n  for (i = 1; i <= m; i++) {\n    X[i] = p[i - 1], Y[i] = p[i];\n  }\n  while (1) {\n    M = max(m, 256);\n    for (i = 1; i <= m; i++) C[Y[i]]++;\n    for (i = 1; i <= M; i++) C[i] += C[i - 1];\n    for (i = 1; i <= m; i++) ord[C[Y[i]]--] = i;\n    for (i = 0; i <= M; i++) C[i] = 0;\n    for (i = 1; i <= m; i++) C[X[i]]++;\n    for (i = 1; i <= M; i++) C[i] += C[i - 1];\n    for (i = m; i >= 1; i--) ord2[C[X[ord[i]]]--] = ord[i];\n    for (i = 0; i <= M; i++) C[i] = 0;\n    cnt = 0;\n    for (i = 1; i <= m; i++) {\n      if (i == 1 || X[ord2[i]] != X[ord2[i - 1]] ||\n          Y[ord2[i]] != Y[ord2[i - 1]])\n        cnt++;\n      SA[ord2[i]] = cnt;\n    }\n    t = cnt + 1, cc = 0;\n    for (i = 0; i < Pcnt; i++) {\n      if (t > SA[P[i] + 1])\n        t = SA[P[i] + 1], cc = 1;\n      else if (t == SA[P[i] + 1])\n        cc++;\n    }\n    if (cc == 1) break;\n    if (L >= m) break;\n    for (i = 1; i <= m; i++) {\n      X[i] = SA[i];\n      if (i + L > m)\n        Y[i] = 0;\n      else\n        Y[i] = SA[i + L];\n    }\n    L *= 2;\n  }\n}\nint main() {\n  int i, t = 0, SS = 0, MM2, pv, cc = 0;\n  gets(p);\n  for (i = 0; p[i]; i++)\n    ;\n  n = i;\n  for (i = n - 1; i >= 0; i--) {\n    if (p[i] == '(')\n      t++, SS++;\n    else\n      t--, SS--;\n    if (t > 0) t = 0;\n    D[i] = t;\n  }\n  t = 0;\n  for (i = 0; i < n; i++) {\n    D2[i] = min(D[i], SS - t + MM);\n    if (p[i] == '(')\n      t++;\n    else\n      t--;\n    if (MM > t) MM = t;\n  }\n  for (i = 0; i < n; i++) p[i + n] = p[i];\n  MM = -99999999;\n  for (i = 0; i < n; i++) {\n    if (MM < D2[i]) MM = D2[i];\n  }\n  for (i = 0; i < n; i++) {\n    if (MM == D2[i]) P[Pcnt++] = i;\n  }\n  Suffix_Array(2 * n);\n  MM2 = 99999999;\n  for (i = 0; i < n; i++) {\n    if (MM == D2[i] && MM2 > SA[i + 1]) {\n      MM2 = SA[i + 1];\n      pv = i;\n    }\n  }\n  for (i = 0; i < -MM; i++) Ans[cc++] = '(';\n  for (i = pv; i < n; i++) Ans[cc++] = p[i];\n  for (i = 0; i < pv; i++) Ans[cc++] = p[i];\n  for (i = 0; i < t; i++) Ans[cc++] = ')';\n  puts(Ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1000006;\nstruct SuffixArray {\n  const int L;\n  string s;\n  vector<int> SA;\n  inline bool leq(int a1, int a2, int b1, int b2) {\n    return (a1 < b1 || a1 == b1 && a2 <= b2);\n  }\n  inline bool leq(int a1, int a2, int a3, int b1, int b2, int b3) {\n    return (a1 < b1 || a1 == b1 && leq(a2, a3, b2, b3));\n  }\n  void radixPass(int* a, int* b, int* r, int n, int K) {\n    int* c = new int[K + 1];\n    for (int i = 0; i < K + 1; ++i) c[i] = 0;\n    for (int i = 0; i < n; ++i) c[r[a[i]]]++;\n    for (int i = 0, sum = 0; i <= K; i++) {\n      int t = c[i];\n      c[i] = sum;\n      sum += t;\n    }\n    for (int i = 0; i < n; ++i) b[c[r[a[i]]]++] = a[i];\n    delete[] c;\n  }\n  SuffixArray(const string& s) : L(s.length()), s(s) {\n    SA.resize(L);\n    if (L == 1)\n      SA[0] = 0;\n    else {\n      int *sa = new int[L], *v = new int[L + 3];\n      int K = 255;\n      for (int i = 0; i < L; ++i) v[i] = int(s[i]);\n      v[L] = v[L + 1] = v[L + 2] = 0;\n      constructSA(v, sa, L, K);\n      for (int i = 0; i < L; ++i) SA[i] = sa[i];\n      delete[] v;\n      delete[] sa;\n    }\n  }\n  void constructSA(int* s, int* SA, int n, int K) {\n    int n0 = (n + 2) / 3, n1 = (n + 1) / 3, n2 = n / 3, n02 = n0 + n2;\n    int* s12 = new int[n02 + 3];\n    s12[n02] = s12[n02 + 1] = s12[n02 + 2] = 0;\n    int* SA12 = new int[n02 + 3];\n    SA12[n02] = SA12[n02 + 1] = SA12[n02 + 2] = 0;\n    int* s0 = new int[n0];\n    int* SA0 = new int[n0];\n    for (int i = 0, j = 0; i < n + (n0 - n1); i++)\n      if (i % 3 != 0) s12[j++] = i;\n    radixPass(s12, SA12, s + 2, n02, K);\n    radixPass(SA12, s12, s + 1, n02, K);\n    radixPass(s12, SA12, s, n02, K);\n    int name = 0, c0 = -1, c1 = -1, c2 = -1;\n    for (int i = 0; i < n02; ++i) {\n      if (s[SA12[i]] != c0 || s[SA12[i] + 1] != c1 || s[SA12[i] + 2] != c2) {\n        name++;\n        c0 = s[SA12[i]];\n        c1 = s[SA12[i] + 1];\n        c2 = s[SA12[i] + 2];\n      }\n      if (SA12[i] % 3 == 1)\n        s12[SA12[i] / 3] = name;\n      else\n        s12[SA12[i] / 3 + n0] = name;\n    }\n    if (name < n02) {\n      constructSA(s12, SA12, n02, name);\n      for (int i = 0; i < n02; ++i) s12[SA12[i]] = i + 1;\n    } else\n      for (int i = 0; i < n02; ++i) SA12[s12[i] - 1] = i;\n    for (int i = 0, j = 0; i < n02; i++)\n      if (SA12[i] < n0) s0[j++] = 3 * SA12[i];\n    radixPass(s0, SA0, s, n0, K);\n    for (int p = 0, t = n0 - n1, k = 0; k < n; k++) {\n      int i = (SA12[t] < n0 ? SA12[t] * 3 + 1 : (SA12[t] - n0) * 3 + 2);\n      int j = SA0[p];\n      if (SA12[t] < n0 ? leq(s[i], s12[SA12[t] + n0], s[j], s12[j / 3])\n                       : leq(s[i], s[i + 1], s12[SA12[t] - n0 + 1], s[j],\n                             s[j + 1], s12[j / 3 + n0])) {\n        SA[k] = i;\n        t++;\n        if (t == n02)\n          for (k++; p < n0; p++, k++) SA[k] = SA0[p];\n      } else {\n        SA[k] = j;\n        p++;\n        if (p == n0)\n          for (k++; t < n02; t++, k++)\n            SA[k] = (SA12[t] < n0 ? SA12[t] * 3 + 1 : (SA12[t] - n0) * 3 + 2);\n      }\n    }\n    delete[] s12;\n    delete[] SA12;\n    delete[] SA0;\n    delete[] s0;\n  }\n  vector<int> getSuffixArray() { return SA; }\n};\nint contagem[MAXN];\nint L[MAXN], R[MAXN];\nint main() {\n  ios_base::sync_with_stdio(false);\n  string s;\n  while (cin >> s) {\n    string t = s + s;\n    SuffixArray sa(t);\n    vector<int> v = sa.getSuffixArray();\n    int cnt = 0;\n    int mini = 0;\n    for (int i = 0; i < (int)s.size(); ++i) {\n      contagem[i] = cnt;\n      if (s[i] == '(')\n        cnt++;\n      else\n        cnt--;\n      mini = min(mini, cnt);\n    }\n    contagem[(int)s.size()] = cnt;\n    L[0] = contagem[0];\n    for (int i = 1; i < (int)s.size() + 1; ++i)\n      L[i] = min(contagem[i], L[i - 1]);\n    R[(int)s.size()] = contagem[(int)s.size()];\n    for (int i = (int)s.size() - 1; i >= 0; i--)\n      R[i] = min(contagem[i], R[i + 1]);\n    string resp = \"\";\n    if (cnt > 0) {\n      int k = -1;\n      for (int i = 0; i < (int)v.size(); ++i) {\n        if (v[i] >= (int)s.size()) continue;\n        if (L[v[i]] + cnt < contagem[v[i]]) continue;\n        if (R[v[i]] < contagem[v[i]]) continue;\n        k = v[i];\n        break;\n      }\n      for (int i = 0; i < (int)s.size(); ++i) {\n        resp += s[(k + i) % (int)s.size()];\n      }\n      while (cnt > 0) {\n        resp += \")\";\n        cnt--;\n      }\n    } else {\n      int k = -1;\n      for (int i = 0; i < (int)v.size(); ++i) {\n        if (v[i] >= (int)s.size()) continue;\n        if (L[v[i]] < contagem[v[i]]) continue;\n        if (R[v[i]] - cnt < contagem[v[i]]) continue;\n        k = v[i];\n        break;\n      }\n      while (cnt < 0) {\n        resp += \"(\";\n        cnt++;\n      }\n      for (int i = 0; i < (int)s.size(); ++i) {\n        resp += s[(k + i) % (int)s.size()];\n      }\n    }\n    cout << resp << endl;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e6 + 1000;\nint t1, t2;\nint lr[MAXN];\nint ll[MAXN];\nint rl[MAXN];\nint rr[MAXN];\nbool check(int i) {\n  if (i == 0) {\n    return rr[i] == t1 && rl[i] == t2;\n  }\n  int tl, tr;\n  tr = rr[i];\n  tl = ll[i - 1];\n  int tmin = min(rl[i], lr[i - 1]);\n  tl += rl[i] - tmin;\n  tr += lr[i - 1] - tmin;\n  if (tr == t1 && tl == t2) return true;\n  return false;\n}\nstruct SA {\n  int rank[MAXN], height[MAXN];\n  int len;\n  inline int ge(char a) {\n    if (a == '(')\n      return 1;\n    else if (a == ')')\n      return 2;\n    else\n      return 0;\n  }\n  int sa[MAXN];\n  int wa[MAXN], wb[MAXN], wv[MAXN], ws[MAXN];\n  int cmp(int *r, int a, int b, int l) {\n    return r[a] == r[b] && r[a + l] == r[b + l];\n  }\n  void da(char *r, int *sa, int n, int m) {\n    int i, j, p, *x = wa, *y = wb, *t;\n    for (i = 0; i < m; i++) ws[i] = 0;\n    for (i = 0; i < n; i++) ws[x[i] = ge(r[i])]++;\n    for (i = 1; i < m; i++) ws[i] += ws[i - 1];\n    for (i = n - 1; i >= 0; i--) sa[--ws[x[i]]] = i;\n    for (j = 1, p = 1; p < n; j *= 2, m = p) {\n      for (p = 0, i = n - j; i < n; i++) y[p++] = i;\n      for (i = 0; i < n; i++)\n        if (sa[i] >= j) y[p++] = sa[i] - j;\n      for (i = 0; i < n; i++) wv[i] = x[y[i]];\n      for (i = 0; i < m; i++) ws[i] = 0;\n      for (i = 0; i < n; i++) ws[wv[i]]++;\n      for (i = 1; i < m; i++) ws[i] += ws[i - 1];\n      for (i = n - 1; i >= 0; i--) sa[--ws[wv[i]]] = y[i];\n      for (t = x, x = y, y = t, p = 1, x[sa[0]] = 0, i = 1; i < n; i++)\n        x[sa[i]] = cmp(y, sa[i - 1], sa[i], j) ? p - 1 : p++;\n    }\n    return;\n  }\n  int solve(char *s) {\n    len = strlen(s);\n    s[len] = 0;\n    da(s, sa, len + 1, 3);\n    for (int i = 0; i < len + 1; ++i) {\n      if (sa[i] < len / 2 && check(sa[i])) {\n        return sa[i];\n      }\n    }\n    return -1;\n  }\n} tq;\nchar s[MAXN];\nint main() {\n  while (scanf(\"%s\", s) != EOF) {\n    memset(lr, 0, sizeof lr);\n    memset(ll, 0, sizeof ll);\n    memset(rr, 0, sizeof rr);\n    memset(rl, 0, sizeof rl);\n    int len = strlen(s);\n    t1 = 0, t2 = 0;\n    for (int i = 0; i < len; ++i) {\n      s[i + len] = s[i];\n      if (s[i] == '(') {\n        ++t1;\n      } else {\n        ++t2;\n      }\n    }\n    int tn = min(t1, t2);\n    t1 -= tn, t2 -= tn;\n    swap(t1, t2);\n    s[len * 2] = '\\0';\n    int tl = 0, tr = 0;\n    for (int i = 0; i < len; ++i) {\n      if (s[i] == '(') {\n        ++tl;\n      } else {\n        if (tl == 0)\n          ++tr;\n        else\n          --tl;\n      }\n      lr[i] = tr;\n      ll[i] = tl;\n    }\n    tl = tr = 0;\n    for (int i = len - 1; i >= 0; --i) {\n      if (s[i] == ')') {\n        ++tr;\n      } else {\n        if (tr == 0)\n          ++tl;\n        else\n          --tr;\n      }\n      rr[i] = tr;\n      rl[i] = tl;\n    }\n    for (int i = 0; i < t1; ++i) putchar('(');\n    int tmp = tq.solve(s);\n    for (int i = 0; i < len; ++i) {\n      putchar(s[i + tmp]);\n    }\n    for (int i = 0; i < t2; ++i) putchar(')');\n    puts(\"\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int nmax = 2000005;\nconst int lmax = 21;\nint n, i, N, val, add, A, B, mlc, sol;\nint can[nmax], sum[nmax];\nint sa[lmax][nmax], ord[nmax];\nchar s[nmax];\ndeque<int> q;\nstruct piece {\n  int x, y, i;\n  bool operator<(const piece &a) const {\n    if (x == a.x) return y < a.y;\n    return x < a.x;\n  }\n};\npiece L[nmax];\nvoid find_candidates() {\n  for (i = 1; i < N; i++) {\n    while (!q.empty() && sum[i] < sum[q.back()]) q.pop_back();\n    q.push_back(i);\n    if (q.front() == i - n) q.pop_front();\n    if (i > n) {\n      if (s[i - n] == '(')\n        add--;\n      else\n        add++;\n    }\n    if (i >= n && sum[q.front()] + add + mlc >= 0) can[i - n + 1] = 1;\n  }\n}\nvoid suffix_arrays() {\n  for (i = 1; i <= N; i++) sa[0][i] = s[i] - '(';\n  int step, cnt;\n  for (step = 1, cnt = 1; (1 << step) <= N; step++, cnt *= 2) {\n    for (i = 1; i <= N; i++) {\n      L[i].x = sa[step - 1][i];\n      if (i + cnt <= N)\n        L[i].y = sa[step - 1][i + cnt];\n      else\n        L[i].y = -1;\n      L[i].i = i;\n    }\n    sort(L + 1, L + N + 1);\n    for (i = 1; i <= N; i++) {\n      if (i > 1 && L[i].x == L[i - 1].x && L[i].y == L[i - 1].y)\n        sa[step][L[i].i] = sa[step][L[i - 1].i];\n      else\n        sa[step][L[i].i] = i;\n    }\n  }\n  for (i = 1; i <= N; i++) ord[sa[step - 1][i]] = i;\n}\nint main() {\n  cin.sync_with_stdio(false);\n  cin >> s + 1;\n  n = strlen(s + 1);\n  for (i = 1; i <= n; i++) s[i + n] = s[i];\n  N = 2 * n;\n  for (i = 1; i <= N; i++) {\n    if (s[i] == '(')\n      val = 1;\n    else\n      val = -1;\n    sum[i] = sum[i - 1] + val;\n  }\n  for (i = 1; i <= n; i++) {\n    if (s[i] == '(')\n      A++;\n    else\n      B++;\n  }\n  if (B > A) mlc = B - A;\n  find_candidates();\n  suffix_arrays();\n  for (i = 1; i <= N; i++)\n    if (can[ord[i]]) {\n      sol = ord[i];\n      break;\n    }\n  s[n + 1] = '\\0';\n  if (A >= B) {\n    cout << s + sol;\n    s[sol] = '\\0';\n    cout << s + 1;\n    for (i = 1; i <= A - B; i++) cout << ')';\n  } else {\n    for (i = 1; i <= B - A; i++) cout << '(';\n    cout << s + sol;\n    s[sol] = '\\0';\n    cout << s + 1;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> r[1000002];\nchar c[1000002];\nint a[1000002], ls[1000002], lx[1000002], b[1000002], g[1000002], l, p, k, kk,\n    s;\nint main() {\n  scanf(\"%s\", c);\n  l = strlen(c);\n  k = 0;\n  for (int i = (0); i <= (l - 1); i++)\n    if (c[i] == '(') a[i] = kk + 1, b[p++] = i, k = 1;\n  if (k) kk++, k = 0;\n  for (int i = (0); i <= (l - 1); i++)\n    if (c[i] == ')') a[i] = kk + 1, b[p++] = i, k = 1;\n  if (k) kk++, k = 0;\n  for (int j = (0); j <= (20); j++) {\n    k = 1 << j;\n    if (k >= l) break;\n    for (int i = (1); i <= (kk); i++) r[i].clear();\n    s = 0;\n    for (int i = (0); i <= (l - 1); i++)\n      p = (b[i] - k + l) % l, r[a[p]].push_back(p);\n    p = 0;\n    for (int i = (1); i <= (kk); i++) {\n      int sz = r[i].size() - 1;\n      g[r[i][0]] = ++s;\n      b[p++] = r[i][0];\n      for (int ii = (1); ii <= (sz); ii++) {\n        int w = r[i][ii];\n        b[p++] = w;\n        if (a[(w + k) % l] != a[(r[i][ii - 1] + k) % l])\n          g[w] = ++s;\n        else\n          g[w] = s;\n      }\n    }\n    for (int i = (0); i <= (l - 1); i++) a[i] = g[i];\n    kk = s;\n  }\n  a[0] = 0;\n  for (int i = (1); i <= (l); i++)\n    if (c[i - 1] == '(')\n      a[i] = 1;\n    else\n      a[i] = -1;\n  for (int i = (2); i <= (l); i++) a[i] += a[i - 1];\n  ls[0] = l;\n  lx[l + 1] = l;\n  if (a[l] > 0)\n    p = 0;\n  else\n    p = a[l];\n  for (int i = (1); i <= (l); i++)\n    if (ls[i - 1] < a[i])\n      ls[i] = ls[i - 1];\n    else\n      ls[i] = a[i];\n  for (int i = (l); i >= (1); i--)\n    if (lx[i + 1] < a[i])\n      lx[i] = lx[i + 1];\n    else\n      lx[i] = a[i];\n  for (int i = (0); i <= (l - 1); i++) {\n    int ii = b[i] + 1;\n    if (lx[ii] - a[ii - 1] >= p && ls[ii - 1] + a[l] - a[ii - 1] >= p) {\n      if (a[l] < 0)\n        for (int j = (1); j <= (-a[l]); j++) printf(\"(\");\n      for (int j = (ii - 1); j <= (l - 1); j++) printf(\"%c\", c[j]);\n      for (int j = (0); j <= (ii - 2); j++) printf(\"%c\", c[j]);\n      if (a[l] > 0)\n        for (int j = (1); j <= (a[l]); j++) printf(\")\");\n      return 0;\n    }\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Buffering {\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\tboolean eof;\n\n\tint[] buildSuffixArray(int[] s, int alphSize) {\n\t\t// sorts cyclic shifs, append a sentinel to the end if suffix array is\n\t\t// needed\n\t\tint n = s.length;\n\t\tint[] cnt = new int[Math.max(alphSize, n)];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcnt[s[i]]++;\n\t\t}\n\t\tfor (int i = 1; i < alphSize; i++) {\n\t\t\tcnt[i] += cnt[i - 1];\n\t\t}\n\n\t\tint[] arr = new int[n];\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tarr[--cnt[s[i]]] = i;\n\t\t}\n\n\t\tint[] cls = new int[n];\n\t\tint nCl = 1;\n\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint curSuff = arr[i];\n\t\t\tif (s[curSuff] != s[arr[i - 1]]) {\n\t\t\t\tnCl++;\n\t\t\t}\n\t\t\tcls[curSuff] = nCl - 1;\n\t\t}\n\n\t\tint[] aux = new int[n];\n\n\t\tfor (int h = 1; h <= n; h <<= 1) {\n\n\t\t\t// aux - suffixes ordered by second halves\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint tmp = arr[i] - h;\n\t\t\t\tif (tmp < 0)\n\t\t\t\t\ttmp += n;\n\t\t\t\taux[i] = tmp;\n\t\t\t}\n\n\t\t\tArrays.fill(cnt, 0, nCl, 0);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tcnt[cls[i]]++;\n\t\t\t}\n\t\t\tfor (int i = 1; i < nCl; i++) {\n\t\t\t\tcnt[i] += cnt[i - 1];\n\t\t\t}\n\n\t\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\t\tint curSuff = aux[i];\n\t\t\t\tarr[--cnt[cls[curSuff]]] = curSuff;\n\t\t\t}\n\n\t\t\t// aux - new classes\n\t\t\taux[arr[0]] = 0;\n\t\t\tnCl = 1;\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tint curPos = arr[i];\n\t\t\t\tint prevPos = arr[i - 1];\n\t\t\t\tif (cls[curPos] == cls[prevPos]) {\n\t\t\t\t\tint tmpCurPos = curPos + h;\n\t\t\t\t\tif (tmpCurPos >= n)\n\t\t\t\t\t\ttmpCurPos -= n;\n\t\t\t\t\tprevPos += h;\n\t\t\t\t\tif (prevPos >= n)\n\t\t\t\t\t\tprevPos -= n;\n\t\t\t\t\tif (cls[tmpCurPos] != cls[prevPos])\n\t\t\t\t\t\tnCl++;\n\t\t\t\t} else {\n\t\t\t\t\tnCl++;\n\t\t\t\t}\n\t\t\t\taux[curPos] = nCl - 1;\n\t\t\t}\n\n\t\t\tint[] tmp = aux;\n\t\t\taux = cls;\n\t\t\tcls = tmp;\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\tvoid solve() throws IOException {\n\t\tString ss = nextToken();\n\t\tint n = ss.length();\n\t\tint[] s = new int[n];\n\t\tint[] bal = new int[n + 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ts[i] = ss.charAt(i) == '(' ? 0 : 1;\n\t\t\tif (s[i] == 0) {\n\t\t\t\tbal[i + 1] = bal[i] + 1;\n\t\t\t} else {\n\t\t\t\tbal[i + 1] = bal[i] - 1;\n\t\t\t}\n\t\t}\n\t\tint[] sa = buildSuffixArray(s, 2);\n\t\tint[] order = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\torder[sa[i]] = i;\n\t\t}\n\t\tint minBal = 0;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tminBal = Math.min(minBal, bal[i]);\n\t\t}\n\n\t\tint[] minSuff = new int[n + 1];\n\t\tint[] minPref = new int[n + 1];\n\t\tminPref[0] = bal[0];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tminPref[i] = Math.min(minPref[i - 1], bal[i]);\n\t\t}\n\t\tminSuff[n] = bal[n];\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tminSuff[i] = Math.min(minSuff[i + 1], bal[i]);\n\t\t}\n\n\t\tint pos = -1;\n\t\t// System.err.println(Arrays.toString(bal) + \" \" + minBal);\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t// if ((bal[n] <= 0 && bal[i] == minBal)\n\t\t\t// || (bal[n] > 0 && bal[i] <= minBal + bal[n])) {\n\t\t\tboolean cond;\n\t\t\tif (bal[n] >= 0) {\n\t\t\t\tcond = minSuff[i] - bal[i] >= 0;\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tcond &= minPref[i - 1] + (bal[n] - bal[i]) >= 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcond = (minSuff[i] - bal[i]) >= bal[n];\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tcond &= minPref[i - 1] + (bal[n] - bal[i]) >= bal[n];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cond) {\n\n\t\t\t\tif (pos == -1) {\n\t\t\t\t\tpos = i;\n\t\t\t\t} else {\n\t\t\t\t\tif (order[i % n] <= order[pos]) {\n\t\t\t\t\t\tpos = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < -bal[n]; i++) {\n\t\t\tout.print('(');\n\t\t}\n\t\tout.print(ss.substring(pos));\n\t\tout.print(ss.substring(0, pos));\n\t\tfor (int i = 0; i < bal[n]; i++) {\n\t\t\tout.print(')');\n\t\t}\n\t\tout.println();\n\t}\n\n\t// ((()())\n\n\tBuffering() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Buffering();\n\t}\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e) {\n\t\t\t\teof = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\teof = true;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<string> split(const string& s, char c) {\n  vector<string> v;\n  stringstream ss(s);\n  string x;\n  while (getline(ss, x, c)) v.push_back(move(x));\n  return v;\n}\nvoid err(vector<string>::iterator it) {}\ntemplate <typename T, typename... Args>\nvoid err(vector<string>::iterator it, T a, Args... args) {\n  cerr << it->substr((*it)[0] == ' ', it->length()) << \" = \" << a << '\\n';\n  err(++it, args...);\n}\nint N;\nstring s;\nstruct entry {\n  int nr[2], p;\n} L[2 * 1000013];\nint P[2][4 * 1000013], stp;\nint order[1000013];\nint prefix[1000013];\nint total;\nint st[2097152];\nchar ANS[2 * 1000013];\nvoid update(int i, int x, int lo = 0, int hi = -1, int node = 0) {\n  if (hi == -1) hi = N;\n  if (i < lo || i > hi) return;\n  if (lo == hi) {\n    st[node] += x;\n    return;\n  }\n  int mid = (lo + hi) / 2;\n  update(i, x, lo, mid, 2 * node + 1);\n  update(i, x, mid + 1, hi, 2 * node + 2);\n  st[node] = min(st[2 * node + 1], st[2 * node + 2]);\n}\nint query(int s, int e, int lo = 0, int hi = -1, int node = 0) {\n  if (hi == -1) hi = N;\n  if (e < lo || s > hi) return (1 << 30);\n  if (s <= lo && hi <= e) return st[node];\n  int mid = (lo + hi) / 2;\n  return min(query(s, e, lo, mid, 2 * node + 1),\n             query(s, e, mid + 1, hi, 2 * node + 2));\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> s;\n  N = s.size();\n  for (int i = 0; i < N; i++) {\n    prefix[i + 1] = prefix[i] + (s[i] == '(' ? 1 : -1);\n    update(i + 1, prefix[i + 1]);\n  }\n  total = prefix[N];\n  for (int i = 0; i < 2 * N; i++) {\n    P[0][i] = (s[i % N] == ')') + 1;\n  }\n  for (stp = 1; (1 << (stp - 1)) < 2 * N; stp++) {\n    int cnt = 1 << (stp - 1);\n    int t = stp % 2;\n    for (int i = 0; i < 2 * N; i++) {\n      L[i].nr[0] = P[!t][i];\n      L[i].nr[1] = P[!t][i + cnt];\n      L[i].p = i;\n    }\n    sort(L, L + 2 * N, [](entry a, entry b) {\n      return a.nr[0] == b.nr[0] ? a.nr[1] < b.nr[1] : a.nr[0] < b.nr[0];\n    });\n    int cur = 1;\n    for (int i = 0; i < 2 * N; i++) {\n      if (i == 0 ||\n          (L[i].nr[0] == L[i - 1].nr[0] && L[i].nr[1] == L[i - 1].nr[1])) {\n        P[t][L[i].p] = cur;\n      } else {\n        P[t][L[i].p] = ++cur;\n      }\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    order[i] = i;\n  }\n  stp = (stp - 1) % 2;\n  sort(order, order + N, [](int a, int b) { return P[stp][a] < P[stp][b]; });\n  int a;\n  for (int i = 0; i < N; i++) {\n    int idx = order[i];\n    int amt = query(idx + 1, N) - prefix[idx];\n    amt = min(amt, query(1, idx) + total - prefix[idx]);\n    int bound = min(total, 0);\n    if (amt >= bound) {\n      a = idx;\n      break;\n    }\n  }\n  int idx = 0;\n  if (total < 0) {\n    for (int i = 0; i < -total; i++) {\n      ANS[idx++] = '(';\n    }\n  }\n  for (int i = a; i < a + N; i++) {\n    ANS[idx++] = s[i % N];\n  }\n  if (total > 0) {\n    for (int i = 0; i < total; i++) {\n      ANS[idx++] = ')';\n    }\n  }\n  for (int i = 0; i < idx; i++) {\n    cout << ANS[i];\n  }\n  cout << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing namespace std;\nint sp[2000514 * 7], spt;\nint ta[2000514], tb[2000514], tc[2000514];\nint box[2000514];\nvoid radix(int *key, int *a, int *b, int n, int m) {\n  for (int i = 0; i <= m; i++) box[i] = 0;\n  for (int i = 0; i < n; i++) box[key[a[i]]]++;\n  for (int i = 1; i <= m; i++) box[i] += box[i - 1];\n  for (int i = n - 1; i >= 0; i--) b[--box[key[a[i]]]] = a[i];\n}\nbool equ(int *s, int a, int b) {\n  return s[a] == s[b] && s[a + 1] == s[b + 1] && s[a + 2] == s[b + 2];\n}\nbool cmp(int *s, int *sa12, int a, int b) {\n  if (s[a + 0] != s[b + 0]) return s[a + 0] < s[b + 0];\n  if (b % 3 == 1) return sa12[a + 1] < sa12[b + 1];\n  if (s[a + 1] != s[b + 1]) return s[a + 1] < s[b + 1];\n  return sa12[a + 2] < sa12[b + 2];\n}\nvoid make_sa(int *sa, int *s, int l, int m) {\n  for (int i = 0; i < 3; i++) {\n    s[l + i] = 0;\n  }\n  int nl = 0, hl = (l + 1) / 3;\n  for (int i = 0; i < l; i++)\n    if (i % 3) ta[nl++] = i;\n  radix(s + 2, ta, tb, nl, m);\n  radix(s + 1, tb, ta, nl, m);\n  radix(s + 0, ta, sa, nl, m);\n  int *nsa = sp + spt;\n  spt += nl + 3;\n  int *ns = sp + spt;\n  spt += nl + 3;\n  int j = 1;\n  ns[((sa[0]) / 3 + ((sa[0]) % 3 == 1 ? 0 : hl))] = 0;\n  for (int i = 1; i < nl; i++) {\n    ns[((sa[i]) / 3 + ((sa[i]) % 3 == 1 ? 0 : hl))] =\n        equ(s, sa[i - 1], sa[i]) ? j - 1 : j++;\n  }\n  if (j < nl)\n    make_sa(nsa, ns, nl, j);\n  else\n    for (int i = 0; i < nl; i++) nsa[ns[i]] = i;\n  int nr = 0;\n  for (int i = 0; i < nl; i++) {\n    if (nsa[i] < hl) tb[nr++] = nsa[i] * 3;\n  }\n  if (l % 3 == 1) tb[nr++] = l - 1;\n  radix(s, tb, ta, nr, m);\n  for (int i = 0; i < nl; i++) {\n    tc[tb[i] = ((nsa[i]) < hl ? (nsa[i]) * 3 + 1 : ((nsa[i]) - hl) * 3 + 2)] =\n        i;\n  }\n  int p = 0, q = 0, r = 0;\n  for (; p < nr && q < nl;) {\n    sa[r++] = cmp(s, tc, ta[p], tb[q]) ? ta[p++] : tb[q++];\n  }\n  for (; p < nr;) sa[r++] = ta[p++];\n  for (; q < nl;) sa[r++] = tb[q++];\n  spt -= (nl + 3) * 2;\n}\nchar s[2000514];\nint sum[2000514];\nint qk[2000514];\nint qx[2000514];\nint qs, qe;\nint mx[2000514];\nint sa[2000514];\nint ns[2000514];\nvoid sol() {\n  int l = 1;\n  for (; s[l]; l++)\n    ;\n  l--;\n  for (int i = 1; i <= l; i++) s[i + l] = s[i];\n  s[l + l + 1] = 0;\n  int nl = l * 2;\n  for (int i = 1; i <= nl; i++) ns[i] = (s[i] == '(' ? 1 : 2);\n  ns[nl + 1] = 0;\n  for (int i = 1; i <= nl; i++) sum[i] = sum[i - 1] + (s[i] == '(' ? 1 : -1);\n  int d = sum[l];\n  qs = qe = 0;\n  for (int i = 1; i <= nl; i++) {\n    if (qe - qs && qx[qs] <= i - l) qs++;\n    for (; qe - qs && qk[qe - 1] >= sum[i]; qe--)\n      ;\n    qk[qe] = sum[i];\n    qx[qe] = i;\n    qe++;\n    mx[i] = qk[qs];\n  }\n  make_sa(sa, ns + 1, nl + 1, 128);\n  int ans = -1;\n  for (int i = 0; i < nl + 1; i++) {\n    int w = sa[i] + 1;\n    if (w > l) continue;\n    int tmn = mx[w + l - 1];\n    if (d < 0) {\n      if (tmn - sum[w - 1] >= d) {\n        ans = w;\n        break;\n      }\n    } else {\n      if (tmn - sum[w - 1] >= 0) {\n        ans = w;\n        break;\n      }\n    }\n  }\n  for (; d < 0; d++) putchar('(');\n  s[ans + l] = 0;\n  printf(\"%s\", s + ans);\n  for (; d > 0; d--) putchar(')');\n  puts(\"\");\n}\nint main() {\n  while (scanf(\"%s\", s + 1) != EOF) sol();\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "//package vk2015.r1;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class A {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tchar[] s = ns().toCharArray();\n\t\tint n = s.length;\n\t\tint[] h = new int[2*n+1];\n\t\tfor(int i = 0;i < 2*n;i++){\n\t\t\th[i+1] = h[i] + (s[i%n] == '(' ? 1 : -1);\n\t\t}\n\t\tSegmentTreeRMQ st = new SegmentTreeRMQ(h);\n\t\t\n\t\tchar[] t = new char[2*n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tt[i+n] = t[i] = s[i];\n\t\t}\n\t\tint[] sa = sa(t);\n\t\ttr(h);\n\t\ttr(sa);\n\t\tfor(int i = 0;i < 2*n;i++){\n\t\t\tif(sa[i] < n){\n\t\t\t\ttr(sa[i], st.min(sa[i], sa[i]+n+1), h[sa[i]+n]);\n\t\t\t}\n\t\t\tif(sa[i] < n && (st.min(sa[i], sa[i]+n+1) == h[sa[i]+n] || st.min(sa[i], sa[i]+n+1) == h[sa[i]])){\n\t\t\t\tfor(int j = 0;j < -h[n];j++){\n\t\t\t\t\tout.print(\"(\");\n\t\t\t\t}\n\t\t\t\tout.print(new String(t, sa[i], n));\n\t\t\t\tfor(int j = 0;j < h[n];j++){\n\t\t\t\t\tout.print(\")\");\n\t\t\t\t}\n\t\t\t\tout.println();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tprivate static interface BaseArray {\n\t\tpublic int get(int i);\n\n\t\tpublic void set(int i, int val);\n\n\t\tpublic int update(int i, int val);\n\t}\n\n\tprivate static class CharArray implements BaseArray {\n\t\tprivate char[] m_A = null;\n\t\tprivate int m_pos = 0;\n\n\t\tCharArray(char[] A, int pos) {\n\t\t\tm_A = A;\n\t\t\tm_pos = pos;\n\t\t}\n\n\t\tpublic int get(int i) {\n\t\t\treturn m_A[m_pos + i] & 0xffff;\n\t\t}\n\n\t\tpublic void set(int i, int val) {\n\t\t\tm_A[m_pos + i] = (char) (val & 0xffff);\n\t\t}\n\n\t\tpublic int update(int i, int val) {\n\t\t\treturn m_A[m_pos + i] += val & 0xffff;\n\t\t}\n\t}\n\t\n\tpublic static class SegmentTreeRMQ {\n\t\tpublic int M, H, N;\n\t\tpublic int[] st;\n\t\t\n\t\tpublic SegmentTreeRMQ(int n)\n\t\t{\n\t\t\tN = n;\n\t\t\tM = Integer.highestOneBit(Math.max(N-1, 1))<<2;\n\t\t\tH = M>>>1;\n\t\t\tst = new int[M];\n\t\t\tArrays.fill(st, 0, M, Integer.MAX_VALUE);\n\t\t}\n\t\t\n\t\tpublic SegmentTreeRMQ(int[] a)\n\t\t{\n\t\t\tN = a.length;\n\t\t\tM = Integer.highestOneBit(Math.max(N-1, 1))<<2;\n\t\t\tH = M>>>1;\n\t\t\tst = new int[M];\n\t\t\tfor(int i = 0;i < N;i++){\n\t\t\t\tst[H+i] = a[i];\n\t\t\t}\n\t\t\tArrays.fill(st, H+N, M, Integer.MAX_VALUE);\n\t\t\tfor(int i = H-1;i >= 1;i--)propagate(i);\n\t\t}\n\t\t\n\t\tpublic void update(int pos, int x)\n\t\t{\n\t\t\tst[H+pos] = x;\n\t\t\tfor(int i = (H+pos)>>>1;i >= 1;i >>>= 1)propagate(i);\n\t\t}\n\t\t\n\t\tprivate void propagate(int i)\n\t\t{\n\t\t\tst[i] = Math.min(st[2*i], st[2*i+1]);\n\t\t}\n\t\t\n\t\tpublic int min(int l, int r){ return l >= r ? 0 : min(l, r, 0, H, 1);}\n\t\t\n\t\tprivate int min(int l, int r, int cl, int cr, int cur)\n\t\t{\n\t\t\tif(l <= cl && cr <= r){\n\t\t\t\treturn st[cur];\n\t\t\t}else{\n\t\t\t\tint mid = cl+cr>>>1;\n\t\t\t\tint ret = Integer.MAX_VALUE;\n\t\t\t\tif(cl < r && l < mid){\n\t\t\t\t\tret = Math.min(ret, min(l, r, cl, mid, 2*cur));\n\t\t\t\t}\n\t\t\t\tif(mid < r && l < cr){\n\t\t\t\t\tret = Math.min(ret, min(l, r, mid, cr, 2*cur+1));\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int firstle(int l, int v) {\n\t\t\tint cur = H+l;\n\t\t\twhile(true){\n\t\t\t\tif(st[cur] <= v){\n\t\t\t\t\tif(cur < H){\n\t\t\t\t\t\tcur = 2*cur;\n\t\t\t\t\t}else{\n\t\t\t\t\t\treturn cur-H;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tcur++;\n\t\t\t\t\tif((cur&cur-1) == 0)return -1;\n\t\t\t\t\tif((cur&1)==0)cur>>>=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int lastle(int l, int v) {\n\t\t\tint cur = H+l;\n\t\t\twhile(true){\n\t\t\t\tif(st[cur] <= v){\n\t\t\t\t\tif(cur < H){\n\t\t\t\t\t\tcur = 2*cur+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\treturn cur-H;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif((cur&cur-1) == 0)return -1;\n\t\t\t\t\tcur--;\n\t\t\t\t\tif((cur&1)==1)cur>>>=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static class IntArray implements BaseArray {\n\t\tprivate int[] m_A = null;\n\t\tprivate int m_pos = 0;\n\n\t\tIntArray(int[] A, int pos) {\n\t\t\tm_A = A;\n\t\t\tm_pos = pos;\n\t\t}\n\n\t\tpublic int get(int i) {\n\t\t\treturn m_A[m_pos + i];\n\t\t}\n\n\t\tpublic void set(int i, int val) {\n\t\t\tm_A[m_pos + i] = val;\n\t\t}\n\n\t\tpublic int update(int i, int val) {\n\t\t\treturn m_A[m_pos + i] += val;\n\t\t}\n\t}\n\n\t/* find the start or end of each bucket */\n\tprivate static void getCounts(BaseArray T, BaseArray C, int n, int k) {\n\t\tint i;\n\t\tfor(i = 0;i < k;++i){\n\t\t\tC.set(i, 0);\n\t\t}\n\t\tfor(i = 0;i < n;++i){\n\t\t\tC.update(T.get(i), 1);\n\t\t}\n\t}\n\n\tprivate static void getBuckets(BaseArray C, BaseArray B, int k, boolean end) {\n\t\tint i, sum = 0;\n\t\tif(end != false){\n\t\t\tfor(i = 0;i < k;++i){\n\t\t\t\tsum += C.get(i);\n\t\t\t\tB.set(i, sum);\n\t\t\t}\n\t\t}else{\n\t\t\tfor(i = 0;i < k;++i){\n\t\t\t\tsum += C.get(i);\n\t\t\t\tB.set(i, sum - C.get(i));\n\t\t\t}\n\t\t}\n\t}\n\n\t/* sort all type LMS suffixes */\n\tprivate static void LMSsort(BaseArray T, int[] SA, BaseArray C,\n\t\t\tBaseArray B, int n, int k) {\n\t\tint b, i, j;\n\t\tint c0, c1;\n\t\t/* compute SAl */\n\t\tif(C == B){\n\t\t\tgetCounts(T, C, n, k);\n\t\t}\n\t\tgetBuckets(C, B, k, false); /* find starts of buckets */\n\t\tj = n - 1;\n\t\tb = B.get(c1 = T.get(j));\n\t\t--j;\n\t\tSA[b++] = (T.get(j) < c1) ? ~j : j;\n\t\tfor(i = 0;i < n;++i){\n\t\t\tif(0 < (j = SA[i])){\n\t\t\t\tif((c0 = T.get(j)) != c1){\n\t\t\t\t\tB.set(c1, b);\n\t\t\t\t\tb = B.get(c1 = c0);\n\t\t\t\t}\n\t\t\t\t--j;\n\t\t\t\tSA[b++] = (T.get(j) < c1) ? ~j : j;\n\t\t\t\tSA[i] = 0;\n\t\t\t}else if(j < 0){\n\t\t\t\tSA[i] = ~j;\n\t\t\t}\n\t\t}\n\t\t/* compute SAs */\n\t\tif(C == B){\n\t\t\tgetCounts(T, C, n, k);\n\t\t}\n\t\tgetBuckets(C, B, k, true); /* find ends of buckets */\n\t\tfor(i = n - 1, b = B.get(c1 = 0);0 <= i;--i){\n\t\t\tif(0 < (j = SA[i])){\n\t\t\t\tif((c0 = T.get(j)) != c1){\n\t\t\t\t\tB.set(c1, b);\n\t\t\t\t\tb = B.get(c1 = c0);\n\t\t\t\t}\n\t\t\t\t--j;\n\t\t\t\tSA[--b] = (T.get(j) > c1) ? ~(j + 1) : j;\n\t\t\t\tSA[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static int LMSpostproc(BaseArray T, int[] SA, int n, int m) {\n\t\tint i, j, p, q, plen, qlen, name;\n\t\tint c0, c1;\n\t\tboolean diff;\n\n\t\t/*\n\t\t * compact all the sorted substrings into the first m items of SA 2*m\n\t\t * must be not larger than n (proveable)\n\t\t */\n\t\tfor(i = 0;(p = SA[i]) < 0;++i){\n\t\t\tSA[i] = ~p;\n\t\t}\n\t\tif(i < m){\n\t\t\tfor(j = i, ++i;;++i){\n\t\t\t\tif((p = SA[i]) < 0){\n\t\t\t\t\tSA[j++] = ~p;\n\t\t\t\t\tSA[i] = 0;\n\t\t\t\t\tif(j == m){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* store the length of all substrings */\n\t\ti = n - 1;\n\t\tj = n - 1;\n\t\tc0 = T.get(n - 1);\n\t\tdo{\n\t\t\tc1 = c0;\n\t\t}while ((0 <= --i) && ((c0 = T.get(i)) >= c1));\n\t\tfor(;0 <= i;){\n\t\t\tdo{\n\t\t\t\tc1 = c0;\n\t\t\t}while ((0 <= --i) && ((c0 = T.get(i)) <= c1));\n\t\t\tif(0 <= i){\n\t\t\t\tSA[m + ((i + 1) >> 1)] = j - i;\n\t\t\t\tj = i + 1;\n\t\t\t\tdo{\n\t\t\t\t\tc1 = c0;\n\t\t\t\t}while ((0 <= --i) && ((c0 = T.get(i)) >= c1));\n\t\t\t}\n\t\t}\n\n\t\t/* find the lexicographic names of all substrings */\n\t\tfor(i = 0, name = 0, q = n, qlen = 0;i < m;++i){\n\t\t\tp = SA[i];\n\t\t\tplen = SA[m + (p >> 1)];\n\t\t\tdiff = true;\n\t\t\tif((plen == qlen) && ((q + plen) < n)){\n\t\t\t\tfor(j = 0;(j < plen) && (T.get(p + j) == T.get(q + j));++j){\n\t\t\t\t}\n\t\t\t\tif(j == plen){\n\t\t\t\t\tdiff = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(diff != false){\n\t\t\t\t++name;\n\t\t\t\tq = p;\n\t\t\t\tqlen = plen;\n\t\t\t}\n\t\t\tSA[m + (p >> 1)] = name;\n\t\t}\n\n\t\treturn name;\n\t}\n\n\t/* compute SA and BWT */\n\tprivate static void induceSA(BaseArray T, int[] SA, BaseArray C,\n\t\t\tBaseArray B, int n, int k) {\n\t\tint b, i, j;\n\t\tint c0, c1;\n\t\t/* compute SAl */\n\t\tif(C == B){\n\t\t\tgetCounts(T, C, n, k);\n\t\t}\n\t\tgetBuckets(C, B, k, false); /* find starts of buckets */\n\t\tj = n - 1;\n\t\tb = B.get(c1 = T.get(j));\n\t\tSA[b++] = ((0 < j) && (T.get(j - 1) < c1)) ? ~j : j;\n\t\tfor(i = 0;i < n;++i){\n\t\t\tj = SA[i];\n\t\t\tSA[i] = ~j;\n\t\t\tif(0 < j){\n\t\t\t\tif((c0 = T.get(--j)) != c1){\n\t\t\t\t\tB.set(c1, b);\n\t\t\t\t\tb = B.get(c1 = c0);\n\t\t\t\t}\n\t\t\t\tSA[b++] = ((0 < j) && (T.get(j - 1) < c1)) ? ~j : j;\n\t\t\t}\n\t\t}\n\t\t/* compute SAs */\n\t\tif(C == B){\n\t\t\tgetCounts(T, C, n, k);\n\t\t}\n\t\tgetBuckets(C, B, k, true); /* find ends of buckets */\n\t\tfor(i = n - 1, b = B.get(c1 = 0);0 <= i;--i){\n\t\t\tif(0 < (j = SA[i])){\n\t\t\t\tif((c0 = T.get(--j)) != c1){\n\t\t\t\t\tB.set(c1, b);\n\t\t\t\t\tb = B.get(c1 = c0);\n\t\t\t\t}\n\t\t\t\tSA[--b] = ((j == 0) || (T.get(j - 1) > c1)) ? ~j : j;\n\t\t\t}else{\n\t\t\t\tSA[i] = ~j;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * find the suffix array SA of T[0..n-1] in {0..k-1}^n use a working space\n\t * (excluding T and SA) of at most 2n+O(1) for a constant alphabet\n\t */\n\tprivate static void SA_IS(BaseArray T, int[] SA, int fs, int n, int k) {\n\t\tBaseArray C, B, RA;\n\t\tint i, j, b, m, p, q, name, newfs;\n\t\tint c0, c1;\n\t\tint flags = 0;\n\n\t\tif(k <= 256){\n\t\t\tC = new IntArray(new int[k], 0);\n\t\t\tif(k <= fs){\n\t\t\t\tB = new IntArray(SA, n + fs - k);\n\t\t\t\tflags = 1;\n\t\t\t}else{\n\t\t\t\tB = new IntArray(new int[k], 0);\n\t\t\t\tflags = 3;\n\t\t\t}\n\t\t}else if(k <= fs){\n\t\t\tC = new IntArray(SA, n + fs - k);\n\t\t\tif(k <= (fs - k)){\n\t\t\t\tB = new IntArray(SA, n + fs - k * 2);\n\t\t\t\tflags = 0;\n\t\t\t}else if(k <= 1024){\n\t\t\t\tB = new IntArray(new int[k], 0);\n\t\t\t\tflags = 2;\n\t\t\t}else{\n\t\t\t\tB = C;\n\t\t\t\tflags = 8;\n\t\t\t}\n\t\t}else{\n\t\t\tC = B = new IntArray(new int[k], 0);\n\t\t\tflags = 4 | 8;\n\t\t}\n\n\t\t/*\n\t\t * stage 1: reduce the problem by at least 1/2 sort all the\n\t\t * LMS-substrings\n\t\t */\n\t\tgetCounts(T, C, n, k);\n\t\tgetBuckets(C, B, k, true); /* find ends of buckets */\n\t\tfor(i = 0;i < n;++i){\n\t\t\tSA[i] = 0;\n\t\t}\n\t\tb = -1;\n\t\ti = n - 1;\n\t\tj = n;\n\t\tm = 0;\n\t\tc0 = T.get(n - 1);\n\t\tdo{\n\t\t\tc1 = c0;\n\t\t}while ((0 <= --i) && ((c0 = T.get(i)) >= c1));\n\t\tfor(;0 <= i;){\n\t\t\tdo{\n\t\t\t\tc1 = c0;\n\t\t\t}while ((0 <= --i) && ((c0 = T.get(i)) <= c1));\n\t\t\tif(0 <= i){\n\t\t\t\tif(0 <= b){\n\t\t\t\t\tSA[b] = j;\n\t\t\t\t}\n\t\t\t\tb = B.update(c1, -1);\n\t\t\t\tj = i;\n\t\t\t\t++m;\n\t\t\t\tdo{\n\t\t\t\t\tc1 = c0;\n\t\t\t\t}while ((0 <= --i) && ((c0 = T.get(i)) >= c1));\n\t\t\t}\n\t\t}\n\t\tif(1 < m){\n\t\t\tLMSsort(T, SA, C, B, n, k);\n\t\t\tname = LMSpostproc(T, SA, n, m);\n\t\t}else if(m == 1){\n\t\t\tSA[b] = j + 1;\n\t\t\tname = 1;\n\t\t}else{\n\t\t\tname = 0;\n\t\t}\n\n\t\t/*\n\t\t * stage 2: solve the reduced problem recurse if names are not yet\n\t\t * unique\n\t\t */\n\t\tif(name < m){\n\t\t\tif((flags & 4) != 0){\n\t\t\t\tC = null;\n\t\t\t\tB = null;\n\t\t\t}\n\t\t\tif((flags & 2) != 0){\n\t\t\t\tB = null;\n\t\t\t}\n\t\t\tnewfs = (n + fs) - (m * 2);\n\t\t\tif((flags & (1 | 4 | 8)) == 0){\n\t\t\t\tif((k + name) <= newfs){\n\t\t\t\t\tnewfs -= k;\n\t\t\t\t}else{\n\t\t\t\t\tflags |= 8;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(i = m + (n >> 1) - 1, j = m * 2 + newfs - 1;m <= i;--i){\n\t\t\t\tif(SA[i] != 0){\n\t\t\t\t\tSA[j--] = SA[i] - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tRA = new IntArray(SA, m + newfs);\n\t\t\tSA_IS(RA, SA, newfs, m, name);\n\t\t\tRA = null;\n\n\t\t\ti = n - 1;\n\t\t\tj = m * 2 - 1;\n\t\t\tc0 = T.get(n - 1);\n\t\t\tdo{\n\t\t\t\tc1 = c0;\n\t\t\t}while ((0 <= --i) && ((c0 = T.get(i)) >= c1));\n\t\t\tfor(;0 <= i;){\n\t\t\t\tdo{\n\t\t\t\t\tc1 = c0;\n\t\t\t\t}while ((0 <= --i) && ((c0 = T.get(i)) <= c1));\n\t\t\t\tif(0 <= i){\n\t\t\t\t\tSA[j--] = i + 1;\n\t\t\t\t\tdo{\n\t\t\t\t\t\tc1 = c0;\n\t\t\t\t\t}while ((0 <= --i) && ((c0 = T.get(i)) >= c1));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(i = 0;i < m;++i){\n\t\t\t\tSA[i] = SA[m + SA[i]];\n\t\t\t}\n\t\t\tif((flags & 4) != 0){\n\t\t\t\tC = B = new IntArray(new int[k], 0);\n\t\t\t}\n\t\t\tif((flags & 2) != 0){\n\t\t\t\tB = new IntArray(new int[k], 0);\n\t\t\t}\n\t\t}\n\n\t\t/* stage 3: induce the result for the original problem */\n\t\tif((flags & 8) != 0){\n\t\t\tgetCounts(T, C, n, k);\n\t\t}\n\t\t/* put all left-most S characters into their buckets */\n\t\tif(1 < m){\n\t\t\tgetBuckets(C, B, k, true); /* find ends of buckets */\n\t\t\ti = m - 1;\n\t\t\tj = n;\n\t\t\tp = SA[m - 1];\n\t\t\tc1 = T.get(p);\n\t\t\tdo{\n\t\t\t\tq = B.get(c0 = c1);\n\t\t\t\twhile (q < j){\n\t\t\t\t\tSA[--j] = 0;\n\t\t\t\t}\n\t\t\t\tdo{\n\t\t\t\t\tSA[--j] = p;\n\t\t\t\t\tif(--i < 0){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tp = SA[i];\n\t\t\t\t}while ((c1 = T.get(p)) == c0);\n\t\t\t}while (0 <= i);\n\t\t\twhile (0 < j){\n\t\t\t\tSA[--j] = 0;\n\t\t\t}\n\t\t}\n\t\tinduceSA(T, SA, C, B, n, k);\n\t\tC = null;\n\t\tB = null;\n\t}\n\n\t/* char */\n\tpublic static void suffixsort(char[] T, int[] SA, int n) {\n\t\tif((T == null) || (SA == null) || (T.length < n) || (SA.length < n)){\n\t\t\treturn;\n\t\t}\n\t\tif(n <= 1){\n\t\t\tif(n == 1){\n\t\t\t\tSA[0] = 0;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tSA_IS(new CharArray(T, 0), SA, 0, n, 128);\n\t}\n\t\n\tpublic static int[] sa(char[] T)\n\t{\n\t\tint n = T.length;\n\t\tint[] sa = new int[n];\n\t\tsuffixsort(T, sa, n);\n\t\treturn sa;\n\t}\n\t\n\tpublic static int[] buildLCP(char[] str, int[] sa)\n\t{\n\t\tint n = str.length;\n\t\tint h = 0;\n\t\tint[] lcp = new int[n];\n\t\tint[] isa = new int[n];\n\t\tfor(int i = 0;i < n;i++)isa[sa[i]] = i;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(isa[i] > 0){\n\t\t\t\tfor(int j = sa[isa[i]-1]; j+h<n && i+h<n && str[j+h] == str[i+h]; h++);\n\t\t\t\tlcp[isa[i]] = h;\n\t\t\t}else{\n\t\t\t\tlcp[isa[i]] = 0;\n\t\t\t}\n\t\t\tif(h > 0)h--;\n\t\t}\n\t\treturn lcp;\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new A().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tprivate int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst unsigned long long shift = 21, mask = (1LL << shift) - 1;\nint n, i, j, k, m, a[1000100], b[1000100], all[1000100], l[2000100], cnt, cur,\n    last, now, best = -1000000000;\nunsigned long long f[2000100], id, lastId;\nchar s[2000100];\nint main() {\n  scanf(\"%s\", s + 1);\n  n = strlen(s + 1);\n  for (i = 1; i <= n; i++) {\n    a[i] = a[i - 1] + (s[i] == '(' ? 1 : -1);\n    b[i] = min(b[i - 1], a[i]);\n    s[i + n] = s[i];\n  }\n  for (i = 1; i <= 2 * n; i++) l[i - 1] = 1 + int(s[i] == ')');\n  for (i = n; i > 0; i--) {\n    now = min(0, min(b[i] + last, cur));\n    if (now > best) {\n      best = now;\n      m = 0;\n    }\n    if (now == best) all[m++] = i;\n    if (s[i] == ')') {\n      last--;\n      cur = min(cur - 1, -1);\n    } else {\n      last++;\n      cur++;\n    }\n  }\n  for (k = 0; k < shift; k++) {\n    for (i = 0; i < 2 * n; i++) {\n      long long x = l[i];\n      long long y = ((i + (1 << k)) >= 2 * n) ? 0 : l[i + (1 << k)];\n      if (x >= (1LL << shift) || y >= (1LL << shift)) puts(\"!\");\n      f[i] = (((x << shift) + y) << shift) + i;\n    }\n    sort(f, f + 2 * n);\n    for (lastId = -1, i = 0; i < 2 * n; i++) {\n      id = (f[i] >> shift);\n      if (id != lastId) {\n        lastId = id;\n        j = i + 1;\n      }\n      l[f[i] & mask] = j;\n    }\n  }\n  for (i = 0; i < -best; i++) {\n    putchar('(');\n    cnt++;\n  }\n  for (i = k = 0; i < m; i++)\n    if (l[all[k]] > l[all[i]]) k = i;\n  for (i = 0; i < n; i++) {\n    char ch = s[all[k] + i + 1];\n    cnt += (ch == '(' ? 1 : -1);\n    putchar(ch);\n  }\n  for (; cnt > 0; cnt--) putchar(')');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast,inline,unroll-loops,fast-math\")\nusing namespace std;\nchar a[4000020];\nint f[4000020], g[4000020], h[4000020];\ndeque<int> q;\nvoid InitSA(char *s, int n, int m) {\n  static int l[4000020], r[4000020], c[4000020];\n  int i, p, k;\n  int *x, *y;\n  x = l;\n  y = r;\n  for (i = 0; i < n; i++) {\n    x[i] = s[i + 1];\n    c[x[i]]++;\n  }\n  for (i = 1; i <= m; i++) c[i] += c[i - 1];\n  for (i = n - 1; i > -1; i--) f[--c[x[i]]] = i;\n  for (k = 1; k < n; k <<= 1) {\n    for (i = n - k, p = 0; i < n; i++) y[p++] = i;\n    for (i = 0; i < n; i++)\n      if (f[i] >= k) y[p++] = f[i] - k;\n    for (i = 0; i <= m; i++) c[i] = 0;\n    for (i = 0; i < n; i++) c[x[i]]++;\n    for (i = 1; i <= m; i++) c[i] += c[i - 1];\n    for (i = n - 1; i > -1; i--) f[--c[x[y[i]]]] = y[i];\n    swap(x, y);\n    for (i = 1, x[f[0]] = m = 0; i < n; i++)\n      x[f[i]] =\n          y[f[i]] == y[f[i - 1]] && y[f[i] + k] == y[f[i - 1] + k] ? m : ++m;\n    if (m >= n) break;\n  }\n  return;\n}\nint main(void) {\n  int n;\n  int i;\n  scanf(\"%s\", a + 1);\n  n = strlen(a + 1);\n  for (i = 1; i <= n; i++) a[i + n] = a[i];\n  InitSA(a, n * 2, ')');\n  for (i = 1; i <= n * 2; i++) {\n    g[i] = g[i - 1] + (a[i] == '(' ? 1 : -1);\n    for (; !q.empty() && i - q.front() > n; q.pop_front())\n      ;\n    for (; !q.empty() && g[q.back()] > g[i]; q.pop_back())\n      ;\n    q.push_back(i);\n    if (i >= n) h[i - n + 1] = g[q.front()];\n  }\n  if (g[n] < 0)\n    for (i = 0; i < -g[n]; i++) printf(\"(\");\n  for (i = 0; i < n * 2; i++)\n    if (f[i] < n && h[f[i] + 1] - g[f[i]] >= min(g[n], 0)) break;\n  a[f[i] + 1 + n] = 0;\n  printf(\"%s\", a + f[i] + 1);\n  if (g[n] > 0)\n    for (i = 0; i < g[n]; i++) printf(\")\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar s[2000100];\nint Lb[2000100 << 2], Rb[2000100 << 2];\nvoid build(int x, int L, int R) {\n  if (L == R) {\n    if (s[L] == '(')\n      Rb[x] = 1;\n    else\n      Lb[x] = 1;\n    return;\n  }\n  int mid = L + R >> 1;\n  build((x << 1), L, mid);\n  build((x << 1 | 1), mid + 1, R);\n  if (Rb[(x << 1)] > Lb[(x << 1 | 1)]) {\n    Lb[x] = Lb[(x << 1)];\n    Rb[x] = Rb[(x << 1 | 1)] + Rb[(x << 1)] - Lb[(x << 1 | 1)];\n  } else {\n    Lb[x] = Lb[(x << 1)] + Lb[(x << 1 | 1)] - Rb[(x << 1)];\n    Rb[x] = Rb[(x << 1 | 1)];\n  }\n}\nint lb, rb;\nint qury(int x, int L, int R, int l, int r) {\n  if (l <= L && R <= r) {\n    lb = lb + max(0, Lb[x] - rb);\n    rb = Rb[x] + max(0, rb - Lb[x]);\n    return lb;\n  }\n  int mid = L + R >> 1, res;\n  if (l <= mid) res = qury((x << 1), L, mid, l, r);\n  if (r > mid) res = qury((x << 1 | 1), mid + 1, R, l, r);\n  return res;\n}\nint _wa[2000100], _wb[2000100], _wv[2000100], _ws[2000100];\nint _cmp(int *r, int a, int b, int l) {\n  return r[a] == r[b] && r[a + l] == r[b + l];\n}\nvoid Get_Sa(int *r, int *sa, int n, int m) {\n  int i, j, p, *x = _wa, *y = _wb, *t;\n  for (i = 0; i < m; i++) _ws[i] = 0;\n  for (i = 0; i < n; i++) _ws[x[i] = r[i]]++;\n  for (i = 1; i < m; i++) _ws[i] += _ws[i - 1];\n  for (i = n - 1; i >= 0; i--) sa[--_ws[x[i]]] = i;\n  for (j = 1, p = 1; p < n; j <<= 1, m = p) {\n    for (p = 0, i = n - j; i < n; i++) y[p++] = i;\n    for (i = 0; i < n; i++)\n      if (sa[i] >= j) y[p++] = sa[i] - j;\n    for (i = 0; i < n; i++) _wv[i] = x[y[i]];\n    for (i = 0; i < m; i++) _ws[i] = 0;\n    for (i = 0; i < n; i++) _ws[_wv[i]]++;\n    for (i = 1; i < m; i++) _ws[i] += _ws[i - 1];\n    for (i = n - 1; i >= 0; i--) sa[--_ws[_wv[i]]] = y[i];\n    for (t = x, x = y, y = t, p = 1, x[sa[0]] = 0, i = 1; i < n; i++)\n      x[sa[i]] = _cmp(y, sa[i - 1], sa[i], j) ? p - 1 : p++;\n  }\n}\nint rnk[2000100], ht[2000100];\nvoid Get_H(int *r, int *sa, int n) {\n  int i, j, k = 0;\n  for (i = 0; i <= n; i++) rnk[sa[i]] = i;\n  for (i = 0; i < n; ht[rnk[i++]] = k)\n    for (k ? k-- : 0, j = sa[rnk[i] - 1]; r[i + k] == r[j + k]; k++)\n      ;\n}\nint sa[2000100], pr[2000100];\nstruct Node {\n  int l, m, id;\n} ax[2000100];\nint cmp(const Node &a, const Node &b) {\n  if (a.l < b.l)\n    return 1;\n  else if (a.l == b.l) {\n    if (a.m < b.m)\n      return 1;\n    else\n      return 0;\n  } else\n    return 0;\n}\nint main() {\n  scanf(\"%s\", s);\n  int zer = 0, one = 0, len = strlen(s), _len = len;\n  int sum1 = 0, sum2 = 0;\n  for (int i = 0; i < _len; i++)\n    if (s[i] == '(')\n      sum1++;\n    else\n      sum2++;\n  for (int i = 0; i < _len - 1; i++) s[len++] = s[i];\n  s[len] = 0;\n  for (int i = 0; i < len; i++) {\n    if (s[i] == '(')\n      pr[i] = 1;\n    else\n      pr[i] = 2;\n  }\n  pr[len] = 0;\n  Get_Sa(pr, sa, len + 1, 3);\n  Get_H(pr, sa, len);\n  build(1, 0, len - 1);\n  for (int i = 0; i < _len; i++) {\n    lb = rb = 0;\n    ax[i].l = qury(1, 0, len - 1, i, i + _len - 1);\n    ax[i].m = rnk[i];\n    ax[i].id = i;\n  }\n  sort(ax, ax + _len, cmp);\n  int bj = ax[0].id;\n  string ans = \"\";\n  for (int i = 0; i < ax[0].l; i++) ans += '(';\n  for (int i = bj; i < _len; i++) ans += s[i];\n  for (int i = 0; i < bj; i++) ans += s[i];\n  int lef = sum1 + ax[0].l - sum2;\n  for (int i = 0; i < lef; i++) ans += ')';\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5 * 1000 * 1000 + 13;\nstring s;\nint a[N];\nint n;\nint pos[N], c[N];\nint cnt[N], tmp[N];\nint curLcp[N];\ninline void calcSufMasAndLCP() {\n  s.push_back(0);\n  n++;\n  memset(cnt, 0, sizeof(cnt));\n  for (int i = 0; i < int(n); ++i) cnt[(int)s[i]]++;\n  for (int i = 1; i <= N - 1; i++) cnt[i] += cnt[i - 1];\n  for (int i = n - 1; i >= 0; i--) pos[--cnt[(int)s[i]]] = i;\n  int comp = 1;\n  c[pos[0]] = comp - 1;\n  for (int i = 1; i <= n - 1; i++) {\n    if (s[pos[i]] != s[pos[i - 1]]) comp++;\n    c[pos[i]] = comp - 1;\n  }\n  for (int h = 0; (1 << h) < n && comp < n; h++) {\n    for (int i = 0; i < int(n); ++i) pos[i] = (pos[i] - (1 << h) + n) % n;\n    memset(cnt, 0, sizeof(int) * comp);\n    for (int i = 0; i < int(n); ++i) cnt[c[i]]++;\n    for (int i = 1; i <= comp - 1; i++) cnt[i] += cnt[i - 1];\n    for (int i = n - 1; i >= 0; i--) tmp[--cnt[c[pos[i]]]] = pos[i];\n    memcpy(pos, tmp, sizeof(int) * n);\n    comp = 1;\n    tmp[pos[0]] = comp - 1;\n    for (int i = 1; i <= n - 1; i++) {\n      if (c[pos[i]] != c[pos[i - 1]] ||\n          c[(pos[i] + (1 << h)) % n] != c[(pos[i - 1] + (1 << h)) % n])\n        comp++;\n      tmp[pos[i]] = comp - 1;\n    }\n    memcpy(c, tmp, sizeof(int) * n);\n  }\n  for (int i = 0; i < int(n - 1); ++i) a[i] = pos[i + 1];\n  int last = 0;\n  for (int i = 0; i < int(n); ++i) {\n    int a = i;\n    if (c[a] == n - 1) {\n      last = 0;\n      continue;\n    }\n    int b = pos[c[a] + 1];\n    int val = max(0, last - 1);\n    while (a + val < n && b + val < n && s[a + val] == s[b + val]) val++;\n    if (c[a] > 0) curLcp[c[a] - 1] = val;\n    last = val;\n  }\n  n--;\n}\nstring str;\nchar buf[N];\nmultiset<int> ss;\nbool read() {\n  if (scanf(\"%s\", buf) <= 0) return false;\n  str = buf;\n  n = int(str.size());\n  return true;\n}\nint ppos[N];\nvoid solve() {\n  int nn = n;\n  s = str + str;\n  n *= 2;\n  calcSufMasAndLCP();\n  n = nn;\n  for (int i = 0; i < int(n * 2); ++i) {\n    ppos[a[i]] = i;\n  }\n  int bal = 0;\n  int c = 0;\n  int mn = 0;\n  for (int i = 0; i < int(n); ++i) {\n    bal += str[i] == '(' ? 1 : -1;\n    mn = min(mn, bal);\n    ss.insert(bal);\n  }\n  int sum = bal;\n  int bestop = -mn;\n  int pos = 0;\n  for (int i = 0; i < int(n - 1); ++i) {\n    int bal = str[i] == '(' ? 1 : -1;\n    ss.erase(ss.find(bal - c));\n    c -= bal;\n    ss.insert(sum - c);\n    int mn = min(0, *ss.begin() + c);\n    if (-mn < bestop) {\n      bestop = -mn;\n      pos = i + 1;\n    }\n    if (-mn == bestop && ppos[i + 1] < ppos[pos]) pos = i + 1;\n  }\n  string s = str + str;\n  string r = s.substr(pos, n);\n  r = string(bestop, '(') + r;\n  sum += bestop;\n  r = r + string(sum, ')');\n  printf(\"%s\", r.c_str());\n}\nint main() {\n  while (read()) solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e6 + 1000;\nint Wa[maxn], Wb[maxn], Wv[maxn], Ws[maxn], sa[maxn];\nint Rank[maxn];\nint height[maxn];\nset<int> S;\nmap<int, int> M;\nvector<int> V;\nint a[maxn];\nint cmp(int *r, int a, int b, int l) {\n  return r[a] == r[b] && r[a + l] == r[b + l];\n}\nvoid get_sa(int *r, int *sa, int n, int m) {\n  int i, j, p, *x = Wa, *y = Wb, *t;\n  for (i = 0; i < m; i++) Ws[i] = 0;\n  for (i = 0; i < n; i++) Ws[x[i] = r[i]]++;\n  for (i = 1; i < m; i++) Ws[i] += Ws[i - 1];\n  for (i = n - 1; i >= 0; i--) sa[--Ws[x[i]]] = i;\n  for (p = 1, j = 1; p < n; j *= 2, m = p) {\n    for (p = 0, i = n - j; i < n; i++) y[p++] = i;\n    for (i = 0; i < n; i++)\n      if (sa[i] >= j) y[p++] = sa[i] - j;\n    for (i = 0; i < n; i++) Wv[i] = x[y[i]];\n    for (i = 0; i < m; i++) Ws[i] = 0;\n    for (i = 0; i < n; i++) Ws[Wv[i]]++;\n    for (i = 1; i < m; i++) Ws[i] += Ws[i - 1];\n    for (i = n - 1; i >= 0; i--) sa[--Ws[Wv[i]]] = y[i];\n    for (t = x, x = y, y = t, p = 1, x[sa[0]] = 0, i = 1; i < n; i++)\n      x[sa[i]] = cmp(y, sa[i - 1], sa[i], j) ? p - 1 : p++;\n  }\n}\nvoid get_height(int *r, int *sa, int n) {\n  int i, j, k = 0;\n  for (i = 1; i <= n; i++) Rank[sa[i]] = i;\n  for (i = 0; i < n; height[Rank[i++]] = k)\n    for (k ? k-- : 0, j = sa[Rank[i] - 1]; r[i + k] == r[j + k]; k++)\n      ;\n}\nvoid Hinsert(int x) {\n  if (M[x] == 0) S.insert(x);\n  M[x]++;\n}\nvoid Herase(int x) {\n  if (M[x] == 1) S.erase(x);\n  M[x]--;\n}\nchar str[maxn];\nint tr, tl;\nint main() {\n  cin >> str;\n  int n = strlen(str), nl = 0, nr = 0;\n  for (int i = 0; i < n; i++) {\n    if (str[i] == '(')\n      nl++, str[i] = 1;\n    else\n      nr++, str[i] = 2;\n  }\n  if (nl < nr) {\n    tl = 0;\n    for (int i = n - 1; i >= 0; i--) {\n      if (str[i] == 1) tl++;\n      a[i] = 2 * tl - (n - i);\n      Hinsert(-a[i]);\n    }\n    tl = 0;\n    for (int i = n - 1; i >= 0; i--) {\n      if (-(*S.begin()) <= -(n - i - 1) + 2 * tl) V.push_back(i);\n      Herase(-a[i]);\n      if (str[i] == 1) tl++;\n      Hinsert(-(2 * nl - n - (n - i) + 2 * tl));\n    }\n    int N = 2 * n - 1;\n    for (int i = 0; i < n; i++) a[i] = str[i];\n    for (int i = n; i < N; i++) a[i] = str[i - n];\n    get_sa(a, sa, N + 1, 4);\n    for (int i = 1; i <= N; i++) Rank[sa[i]] = i;\n    int maxr = N + 100, Kr = 0;\n    for (auto i : V) {\n      if (i + 1 >= N) break;\n      if (Rank[i + 1] < maxr) {\n        maxr = Rank[i + 1];\n        Kr = i + 1;\n      }\n    }\n    a[N] = a[N - n];\n    for (int i = 0; i < nr - nl; i++) printf(\"(\");\n    for (int i = Kr; i < Kr + n; i++) printf(\"%c\", a[i] == 2 ? ')' : '(');\n  } else {\n    tr = 0;\n    for (int i = 0; i < n; i++) {\n      if (str[i] == 2) tr++;\n      a[i] = 2 * tr - i - 1;\n      Hinsert(-a[i]);\n    }\n    tr = 0;\n    for (int i = 0; i < n; i++) {\n      if (-(*S.begin()) <= -i + 2 * tr) V.push_back(i);\n      Herase(-a[i]);\n      if (str[i] == 2) tr++;\n      Hinsert(-(2 * nr - n - i - 1 + 2 * tr));\n    }\n    int N = 2 * n - 1;\n    for (int i = 0; i < n; i++) a[i] = str[i];\n    for (int i = n; i < N; i++) a[i] = str[i - n];\n    get_sa(a, sa, N + 1, 4);\n    for (int i = 1; i <= N; i++) Rank[sa[i]] = i;\n    int maxr = N + 100, Kr = 0;\n    for (auto i : V) {\n      if (Rank[i] < maxr) {\n        maxr = Rank[i];\n        Kr = i;\n      }\n    }\n    for (int i = Kr; i < Kr + n; i++) printf(\"%c\", a[i] == 2 ? ')' : '(');\n    for (int i = 0; i < nl - nr; i++) printf(\")\");\n  }\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.math.BigInteger;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Vadim Semenov\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskF solver = new TaskF();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskF {\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        String sequence = in.next();\n        final int length = sequence.length();\n        int[] s = new int[length];\n        for (int i = 0; i < length; ++i) {\n            s[i] = sequence.charAt(i) - '(';\n        }\n        int[] suffixArray = buildSuffixArray(s);\n        int[] balance = new int[length * 2];\n        for (int i = 1; i < balance.length; ++i) {\n            balance[i] = balance[i - 1];\n            if (s[(i - 1) % length] == 0) {\n                balance[i]++;\n            } else {\n                balance[i]--;\n            }\n        }\n        int total = balance[length];\n        int opened = 0, closed = 0;\n        if (total > 0) {\n            closed = total;\n        } else {\n            opened = -total;\n        }\n        RMQ rmq = new RMQ(balance);\n        int best = -1;\n        for (int i : suffixArray) {\n            int offset = balance[i];\n            offset = opened - offset;\n            if (rmq.query(i + 1, i + 1 + length) + offset >= 0) {\n                if (balance[i + length] + offset != closed) {\n                    throw new AssertionError(balance[i + length] + \" + \" + offset + \" != \" + closed);\n                }\n                best = i;\n                break;\n            }\n        }\n        for (int i = 0; i < opened; ++i) {\n            out.print('(');\n        }\n        out.print(sequence.substring(best, sequence.length()));\n        out.print(sequence.substring(0, best));\n        for (int i = 0; i < closed; ++i) {\n            out.print(')');\n        }\n        out.println();\n    }\n\n    private static class RMQ {\n        int[][] data;\n        int[] log;\n\n        RMQ(int[] initial) {\n            int length = initial.length;\n            log = new int[length + 1];\n            for (int i = 2; i <= length; ++i) {\n                log[i] = log[i >>> 1] + 1;\n            }\n            data = new int[log[length]][length];\n            System.arraycopy(initial, 0, data[0], 0, length);\n            for (int level = 1; level < log[length]; ++level) {\n                int len = 1 << (level - 1);\n                for (int i = 0; (i + len + len) <= length; ++i) {\n                    data[level][i] = Math.min(data[level - 1][i], data[level - 1][i + len]);\n                }\n            }\n        }\n\n        int query(int from, int to) {\n            int level = log[to - from];\n            return Math.min(data[level][from], data[level][to - (1 << level)]);\n        }\n    }\n\n    private int[] buildSuffixArray(int[] s) {\n        final int length = s.length;\n        int[] suffixArray = new int[length];\n        int[] bucket = new int[length];\n        int[] _suffixArray = new int[length];\n        int[] _bucket = new int[length];\n        int[] position = new int[Math.max(2, length)];\n        int buckets = 0;\n        {\n            for (int i : s) {\n                position[i]++;\n            }\n            int pos = 0;\n            for (int i = 0; i < position.length; ++i) {\n                int tmp = position[i];\n                position[i] = pos;\n                pos += tmp;\n            }\n            for (int i = 0; i < length; ++i) {\n                suffixArray[position[s[i]]++] = i;\n            }\n            position[0] = 0;\n            for (int i = 1; i < length; ++i) {\n                if (s[suffixArray[i]] != s[suffixArray[i - 1]]) {\n                    buckets++;\n                    position[buckets] = i;\n                }\n                bucket[suffixArray[i]] = buckets;\n            }\n        }\n        for (int part = 1; part < length; part <<= 1) {\n            for (int i = 0; i < length; ++i) {\n                int idx = (suffixArray[i] - part + length) % length;\n                _suffixArray[position[bucket[idx]]++] = idx;\n            }\n            buckets = 0;\n            position[0] = 0;\n            for (int i = 1; i < length; ++i) {\n                if (bucket[_suffixArray[i]] != bucket[_suffixArray[i - 1]] ||\n                        bucket[(_suffixArray[i] + part) % length] != bucket[(_suffixArray[i - 1] + part) % length]) {\n                    buckets++;\n                    position[buckets] = i;\n                }\n                _bucket[_suffixArray[i]] = buckets;\n            }\n            int[] swap = bucket; bucket = _bucket; _bucket = swap;\n            swap = suffixArray; suffixArray = _suffixArray; _suffixArray = swap;\n        }\n        return suffixArray;\n    }\n}\n\nclass InputReader {\n    private final BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    public InputReader(InputStream in) {\n        reader = new BufferedReader(new InputStreamReader(in));\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(readLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n    public String readLine() {\n        String line;\n        try {\n            line = reader.readLine();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        return line;\n    }\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint last, cnt;\nint sa[2000100], rnk[2000100];\npair<int, int> tr[4200000];\nchar s[2000100], st[2000100];\nint n;\nstruct SAM {\n  int l[2000100 * 2], ch[2000100 * 2][2], fa[2000100 * 2], cnt, last, len,\n      lp[2000100 * 2];\n  int son[2000100 * 2], son1[2000100 * 2], lnk[2000100 * 5], nxt[2000100 * 5],\n      tcnt, b[28], t[2000100 * 2], ec, d;\n  bool mark[2000100 * 2];\n  char s[2000100];\n  void addedge1(int x, int y) {\n    nxt[++ec] = son1[x];\n    lnk[son1[x] = ec] = y;\n  }\n  void add(int c) {\n    int np = ++cnt, p = last;\n    last = np;\n    l[np] = ++len;\n    mark[np] = true;\n    lp[np] = 0;\n    for (; p && !ch[p][c]; p = fa[p]) ch[p][c] = np;\n    if (!p)\n      fa[np] = 1;\n    else {\n      int q = ch[p][c];\n      if (l[p] + 1 == l[q])\n        fa[np] = q;\n      else {\n        int nq = ++cnt;\n        lp[nq] = lp[q] + l[q] - 1 - l[p];\n        l[nq] = l[p] + 1;\n        mark[nq] = false;\n        memcpy(ch[nq], ch[q], sizeof ch[q]);\n        fa[nq] = fa[q];\n        fa[q] = fa[np] = nq;\n        for (; ch[p][c] == q; p = fa[p]) ch[p][c] = nq;\n      }\n    }\n  }\n  void dfs(int u, int *sa) {\n    for (int p = u; p;)\n      if (son[p]) {\n        int v = lnk[son[p]];\n        son[p] = nxt[son[p]];\n        if (mark[v]) sa[tcnt++] = len - l[v];\n        p = v;\n      } else\n        p = fa[p];\n  }\n  void addedge(int x, int y) {\n    nxt[++ec] = son[x];\n    lnk[son[x] = ec] = y;\n  }\n  void build_tree() {\n    memset(b, 0, sizeof b);\n    for (int i = 2; i <= cnt; ++i) ++b[s[lp[i] + l[i] - l[fa[i]] - 1] - 'a'];\n    for (int i = 1; i < 28; ++i) b[i] += b[i - 1];\n    for (int i = 2; i <= cnt; ++i)\n      t[b[s[lp[i] + l[i] - l[fa[i]] - 1] - 'a']--] = i;\n    for (int i = cnt - 1; i; --i) addedge(fa[t[i]], t[i]);\n  }\n  void construct_sa(char *ss, int n) {\n    tcnt = 0;\n    for (int i = 0; i < n; ++i) s[n - i - 1] = ss[i];\n    construct(n);\n    build_tree();\n    dfs(1, sa);\n    for (int i = 0; i < n; i++) rnk[sa[i]] = i;\n  }\n  void construct(int n) {\n    len = 0;\n    last = cnt = 1;\n    for (int i = 0; i < n; ++i) add(s[i] - 'a');\n  }\n} sam;\nvoid build_sa() { sam.construct_sa(st, n); }\npair<int, int> upd(pair<int, int> b, pair<int, int> c) {\n  return make_pair(c.first + max(0, b.first - c.second),\n                   b.second + max(0, c.second - b.first));\n}\nvoid build_tree(int l, int r, int k) {\n  if (l == r) {\n    if (s[l] == '(')\n      tr[k] = make_pair(1, 0);\n    else\n      tr[k] = make_pair(0, 1);\n    return;\n  }\n  int mid = (l + r) >> 1;\n  build_tree(l, mid, k << 1);\n  build_tree(mid + 1, r, k << 1 | 1);\n  tr[k] = upd(tr[k << 1], tr[k << 1 | 1]);\n}\npair<int, int> ret;\nvoid qry(int L, int R, int l, int r, int k) {\n  if (L <= l && r <= R) {\n    ret = upd(ret, tr[k]);\n    return;\n  }\n  int mid = (l + r) >> 1;\n  if (L <= mid) qry(L, R, l, mid, k << 1);\n  if (mid < R) qry(L, R, mid + 1, r, k << 1 | 1);\n}\nint main() {\n  scanf(\"%s\", s);\n  n = strlen(s);\n  for (int i = 0; i < n; i++) s[i + n] = s[i];\n  n *= 2;\n  for (int i = 0; i < n; i++)\n    if (s[i] == '(')\n      st[i] = 'a';\n    else\n      st[i] = 'b';\n  build_sa();\n  build_tree(0, n - 1, 1);\n  pair<int, int> ans = make_pair(0, 0);\n  int pos = -1;\n  for (int i = 0; i < n / 2; i++) {\n    ret = make_pair(0, 0);\n    qry(i, i + n / 2 - 1, 0, n - 1, 1);\n    if (ret.first && ret.second) continue;\n    if (pos == -1 || rnk[i] < rnk[pos]) pos = i;\n    ans = ret;\n  }\n  for (int i = 0; i < ans.second; i++) putchar('(');\n  for (int i = pos; i < pos + n / 2; i++) putchar(s[i]);\n  for (int i = 0; i < ans.first; i++) putchar(')');\n  putchar('\\n');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e6 + 6;\nchar s[N];\nint p1[N];\nint p2[N];\nint s1[N];\nint s2[N];\nlong long X1 = 277, X2 = 2887;\nlong long M1 = 1444444447, M2 = 1777777777;\nlong long x1[N], x2[N];\nstruct hasher {\n  vector<long long> h1, h2;\n  hasher() {}\n  string s;\n  hasher(char *str) {\n    s = str;\n    int n = s.length();\n    h1.assign(n + 1, 0);\n    for (int i = n - 1; i >= 0; --i) {\n      h1[i] = (h1[i + 1] * X1 + s[i]) % M1;\n    }\n  }\n  long long get(int l, int r) {\n    return ((h1[l] - h1[r + 1] * x1[r - l + 1] % M1 + M1) % M1);\n  }\n};\nint cmp(hasher &s1, int i1, int j1, hasher &s2, int i2, int j2) {\n  int l = 0, r = min(j1 - i1 + 1, j2 - i2 + 1) + 1;\n  while (l < r) {\n    int m = (l + r) >> 1;\n    if (s1.get(i1, i1 + m - 1) == s2.get(i2, i2 + m - 1))\n      l = m + 1;\n    else\n      r = m;\n  }\n  --l;\n  if (i1 + l > j1 && i2 + l > j2) return 0;\n  if (i1 + l > j1) return -1;\n  if (i2 + l > j2) return 1;\n  return s1.s[i1 + l] < s2.s[i2 + l] ? -1 : 1;\n}\nhasher h, ho, hz;\nint n;\nvoid calc(int i, int &il, int &ir) {\n  int op = p2[i];\n  int zp = i - p1[i] - op;\n  int zs = s2[i + 1];\n  int os = n - i - s1[i + 1] - zs;\n  il = zs;\n  ir = op;\n  if (os > zp)\n    ir += os - zp;\n  else\n    il += zp - os;\n}\nbool cmp(int i, int j, int len, int k) {\n  int il, ir, jl, jr;\n  calc(i, il, ir);\n  calc(j, jl, jr);\n  int im = len - il - ir;\n  int jm = len - jl - jr;\n  if (k < il) {\n    if (k < jl) {\n      return cmp(i, j, len, min(il, jl));\n    } else if (k < jl + jm) {\n      int d = min(il - k, jl + jm - k);\n      int dif = cmp(ho, 0, d - 1, h, j + (k - jl), j + (k - jl) + d - 1);\n      if (dif) return dif < 0;\n      return cmp(i, j, len, k + d);\n    } else {\n      return true;\n    }\n  } else if (k < il + im) {\n    if (k < jl) {\n      int d = min(jl - k, il + im - k);\n      int dif = cmp(h, i + (k - il), i + (k - il) + d - 1, ho, 0, d - 1);\n      if (dif) return dif < 0;\n      return cmp(i, j, len, k + d);\n    } else if (k < jl + jm) {\n      int d = min(il + im - k, jl + jm - k);\n      int dif = cmp(h, i + (k - il), i + (k - il) + d - 1, h, j + (k - jl),\n                    j + (k - jl) + d - 1);\n      if (dif) return dif < 0;\n      return cmp(i, j, len, k + d);\n    } else {\n      int d = min(il + im - k, len - k);\n      int dif = cmp(h, i + (k - il), i + (k - il) + d - 1, hz, 0, d - 1);\n      if (dif) return dif < 0;\n      return cmp(i, j, len, k + d);\n    }\n  } else if (k < len) {\n    if (k < jl) {\n      return false;\n    } else if (k < jl + jm) {\n      int d = min(len - k, jl + jm - k);\n      int dif = cmp(hz, 0, d - 1, h, j + (k - jl), j + (k - jl) + d - 1);\n      if (dif) return dif < 0;\n      return cmp(i, j, len, k + d);\n    } else {\n      return cmp(i, j, len, len);\n    }\n  } else\n    return false;\n}\nchar e[N];\nstring ans;\nstring func(string &s) {\n  string res;\n  int m = 0;\n  for (int i = 0; i < s.length(); ++i)\n    if (s[i] == '(') {\n      ++m;\n    } else {\n      if (!m)\n        res += \"(\";\n      else\n        --m;\n    }\n  res += s;\n  while (m--) res += \")\";\n  return res;\n}\nint main() {\n  for (int i = x1[0] = 1; i < N; ++i) x1[i] = x1[i - 1] * X1 % M1;\n  gets(s + 1);\n  n = strlen(s + 1);\n  for (int i = 1; i <= n; ++i) s[i + n] = s[i];\n  for (int i = n; i; --i) {\n    if (s[i] == '(') {\n      if (s2[i + 1]) {\n        s1[i] = s1[i + 1] + 2;\n        s2[i] = s2[i + 1] - 1;\n      } else {\n        s1[i] = s1[i + 1];\n        s2[i] = s2[i + 1];\n      }\n    } else {\n      s1[i] = s1[i + 1];\n      s2[i] = s2[i + 1] + 1;\n    }\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (s[i] == ')') {\n      if (p2[i - 1]) {\n        p1[i] = p1[i - 1] + 2;\n        p2[i] = p2[i - 1] - 1;\n      } else {\n        p1[i] = p1[i - 1];\n        p2[i] = p2[i - 1];\n      }\n    } else {\n      p1[i] = p1[i - 1];\n      p2[i] = p2[i - 1] + 1;\n    }\n  }\n  int x = n * 10;\n  vector<int> pos;\n  for (int i = 0; i < n; ++i) {\n    int op = p2[i];\n    int zp = i - p1[i] - op;\n    int zs = s2[i + 1];\n    int os = n - i - s1[i + 1] - zs;\n    int len = zs + op + max(os, zp) - min(os, zp) + n;\n    if (x > len) {\n      pos.clear();\n      x = len;\n    }\n    if (x == len) {\n      pos.push_back(i);\n    }\n    int sl, sr;\n    calc(i, sl, sr);\n  }\n  h = hasher(s + 1);\n  for (int i = 0; i < n * 2; ++i) e[i] = '(';\n  ho = hasher(e);\n  for (int i = 0; i < n * 2; ++i) e[i] = ')';\n  hz = hasher(e);\n  int res = pos[0];\n  for (int k = 1; k < pos.size(); ++k)\n    if (cmp(pos[k], res, x, 0)) res = pos[k];\n  int sl, sr;\n  calc(res, sl, sr);\n  for (int i = 0; i < sl; ++i) printf(\"(\");\n  for (int i = 0; i < x - sl - sr; ++i) printf(\"%c\", s[res + i + 1]);\n  for (int i = 0; i < sr; ++i) printf(\")\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool b[2000005];\nchar c[2000005];\nint h[2000005], q[2000005];\nint i, j, k, n, H, T, t;\nint main() {\n  scanf(\"%s\", c + 1);\n  n = strlen(c + 1);\n  for (i = 1; i <= n; i++) t += (c[i] == '(') ? 1 : -1;\n  for (i = n + 1; i <= n * 2; i++) c[i] = c[i - n];\n  if (t < 0)\n    for (i = 1; i <= -t; i++) putchar('(');\n  for (i = 1; i <= 2 * n; i++) h[i] = h[i - 1] + ((c[i] == '(') ? 1 : -1);\n  H = 1;\n  T = 0;\n  for (i = 1; i <= n; i++) {\n    for (; T && h[i] < h[q[T]]; T--)\n      ;\n    q[++T] = i;\n  }\n  for (i = 1; i <= n; i++) {\n    if (h[q[H]] - h[i - 1] < min(t, 0)) b[i] = 1;\n    for (; T >= H && h[n + i] < h[q[T]]; T--)\n      ;\n    q[++T] = n + i;\n    if (q[H] == i) H++;\n  }\n  for (i = 1, j = 2;;) {\n    for (; b[i]; i++)\n      ;\n    for (; b[j]; j++)\n      ;\n    if (i == j)\n      for (j++; b[j]; j++)\n        ;\n    if (i > n || j > n) break;\n    for (k = 0; k < n && c[i + k] == c[j + k]; k++)\n      ;\n    if (c[i + k] < c[j + k])\n      j = j + k + 1;\n    else\n      i = i + k + 1;\n  }\n  if (j < i) i = j;\n  for (j = i; j < n + i; j++) putchar(c[j]);\n  if (t > 0)\n    for (i = 1; i <= t; i++) putchar(')');\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\ntemplate <typename T1, typename T2>\ninline void remin(T1& a, T2 b) {\n  a = min(a, (T1)b);\n}\nconst int maxN = 1 << 21;\nnamespace SuffixArray {\nint temp[maxN], inds[maxN], C[maxN], T[maxN * 4], *R, *P;\nbool cmp(int i, int j) {\n  while (P[i] == P[j]) i++, j++;\n  return P[i] < P[j];\n}\nvoid brut(int n, int* T, int* res) {\n  iota(res, res + n, 0);\n  P = T;\n  sort(res, res + n, cmp);\n}\nint cntSort(int n, int* T, int k) {\n  int m = 0;\n  if (k == 0) {\n    for (int i = 0; i < n; i += 3) temp[m++] = i;\n    for (int i = 1; i < n; i += 3) temp[m++] = i;\n  } else\n    for (int i = 2; i < n; i += 3) temp[m++] = i;\n  for (int j = (2 - k); j > (-1); j--) {\n    for (int i = (0); i < (m); i++) {\n      int ind = temp[i];\n      int v = j & k ? R[ind + 1] : T[ind + j];\n      C[v]++;\n    }\n    for (int i = 1; C[i - 1] != m; i++) C[i] += C[i - 1];\n    for (int i = (m - 1); i > (-1); i--) {\n      int ind = temp[i];\n      int v = j & k ? R[ind + 1] : T[ind + j];\n      inds[--C[v]] = ind;\n    }\n    fill(C, C + n + 1, 0);\n    if (j != 0) copy(inds, inds + m, temp);\n  }\n  return m;\n}\ninline bool differ(int* T, int i, int j) {\n  return T[i + 2] ^ T[j + 2] | T[i + 1] ^ T[j + 1] | T[i] ^ T[j];\n}\ninline int newInd(int i, int p) { return i / 3 + i % 3 * p; }\nvoid calcRanks(int* sa, int n, int d = 0) {\n  for (int i = (0); i < (n); i++) R[sa[i]] = i + d;\n}\nbool cmpMerge(int i, int j) {\n  for (; true; i++, j++) {\n    if (P[i] != P[j]) return P[i] < P[j];\n    if (i % 3 != 2 and j % 3 != 2) return R[i] < R[j];\n  }\n}\nvoid ks(int n, int* T, int* res) {\n  if (n < 6) {\n    brut(n, T, res);\n    return;\n  }\n  int m = cntSort(n, T, 0), p = (n + 2) / 3 + 1, ctr = 2;\n  int *A = T + n + 2, *S = res + n / 3;\n  A[p - 1] = 1, A[m + 1] = A[m + 2] = 0;\n  for (int i = (0); i < (m); i++) {\n    if (i != 0 and differ(T, inds[i - 1], inds[i])) ctr++;\n    A[newInd(inds[i], p)] = ctr;\n  }\n  ks(m + 1, A, S - 1);\n  for (int i = (0); i < (m); i++)\n    S[i] = S[i] < p ? S[i] * 3 : (S[i] - p) * 3 + 1;\n  calcRanks(S, m, 1);\n  R[n] = 0;\n  int k = cntSort(n, T, 1);\n  P = T;\n  merge(S, S + m, inds, inds + k, res, cmpMerge);\n}\nvoid run(char* Tin, int n, int* sa, int* lcp, int* ranks) {\n  R = ranks;\n  for (int i = (0); i < (n); i++) T[i] = (int)Tin[i] + 1;\n  T[n] = T[n + 1] = 0;\n  n < 256 ? brut(n, T, sa) : ks(n, T, sa);\n  calcRanks(sa, n);\n  for (int i = 0, q = 0; i < n; i++) {\n    if (R[i] == n - 1) continue;\n    int j = sa[R[i] + 1];\n    while (T[i + q] == T[j + q]) q++;\n    lcp[R[i]] = q;\n    if (q != 0) q--;\n  }\n}\n}  // namespace SuffixArray\nchar T[maxN], S[maxN];\nint sum[maxN], pref[maxN], suf[maxN];\nint sa[maxN], R[maxN], lcp[maxN];\nvoid solve() {\n  scanf(\"%s\", T + 1);\n  int n = strlen(T + 1);\n  for (int i = (1); i < (n + 1); i++)\n    sum[i] = sum[i - 1] + (T[i] == '(' ? 1 : -1);\n  pref[0] = suf[n + 1] = maxN;\n  for (int i = (1); i < (n + 1); i++) pref[i] = min(pref[i - 1], sum[i]);\n  for (int i = (n); i > (-1); i--) suf[i] = min(suf[i + 1], sum[i]);\n  copy(T + 1, T + n + 1, S);\n  copy(S, S + n, S + n);\n  SuffixArray::run(S, n * 2, sa, lcp, R);\n  pref[0] = 0;\n  int opt = maxN * 3, ind = 0;\n  for (int i = (1); i < (n + 1); i++) {\n    int mn = min(suf[i] - sum[i - 1], (sum[n] - sum[i - 1]) + pref[i - 1]);\n    int prop = sum[n];\n    if (mn < 0) prop -= mn * 2;\n    if (opt > prop or (opt == prop and R[i - 1] < R[ind - 1]))\n      opt = prop, ind = i;\n  }\n  int mn =\n      min(suf[ind] - sum[ind - 1], (sum[n] - sum[ind - 1]) + pref[ind - 1]);\n  for (int _ = (0); _ < (-mn); _++) printf(\"(\");\n  printf(\"%s\", T + ind);\n  T[ind] = 0;\n  printf(\"%s\", T + 1);\n  sum[n] -= min(mn, 0);\n  for (int _ = (0); _ < (sum[n]); _++) printf(\")\");\n  printf(\"\\n\");\n}\nint main() {\n  int t = 1;\n  for (int tid = (1); tid < (t + 1); tid++) {\n    solve();\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nvoid debug(T a, T b) {\n  ;\n}\ntemplate <class T>\nvoid chmin(T& a, const T& b) {\n  if (a > b) a = b;\n}\ntemplate <class T>\nvoid chmax(T& a, const T& b) {\n  if (a < b) a = b;\n}\nnamespace std {\ntemplate <class S, class T>\nostream& operator<<(ostream& out, const pair<S, T>& a) {\n  out << '(' << a.first << ',' << a.second << ')';\n  return out;\n}\n}  // namespace std\nlong long int readL() {\n  long long int res;\n  scanf(\"%I64d\", &res);\n  return res;\n}\nvoid printL(long long int res) { printf(\"%I64d\", res); }\nnamespace lib {\nstatic const int MAX_K = 2000005;\nstatic const int MAX_N = 2000005;\nstatic int bkt[MAX_K + 1];\nstatic void setBuckets(int* s, int n, int K, bool end) {\n  for (int i = 0; i <= K; ++i) bkt[i] = 0;\n  for (int i = 0; i < n; ++i) bkt[s[i]]++;\n  int sum = 0;\n  for (int i = 0; i <= K; ++i) {\n    sum += bkt[i];\n    bkt[i] = (end ? sum : sum - bkt[i]);\n  }\n}\nstatic void induceSAL(const vector<bool>& t, int* SA, int* s, int n, int K,\n                      bool end) {\n  setBuckets(s, n, K, end);\n  int j;\n  for (int i = 0; i < n; ++i) {\n    j = SA[i] - 1;\n    if (j >= 0 && !t[j]) SA[bkt[s[j]]++] = j;\n  }\n}\nstatic void induceSAS(const vector<bool>& t, int* SA, int* s, int n, int K,\n                      bool end) {\n  setBuckets(s, n, K, end);\n  int j;\n  for (int i = n - 1; i >= 0; --i) {\n    j = SA[i] - 1;\n    if (j >= 0 && t[j]) SA[--bkt[s[j]]] = j;\n  }\n}\nstatic void SA_IS(int* s, int* SA, int n, int K) {\n  vector<bool> t(n);\n  t[n - 1] = 1;\n  t[n - 2] = 0;\n  for (int i = n - 3; i >= 0; --i) {\n    if (s[i] < s[i + 1] || (s[i] == s[i + 1] && t[i + 1] == 1))\n      t[i] = 1;\n    else\n      t[i] = 0;\n  }\n  setBuckets(s, n, K, true);\n  for (int i = 0; i < n; ++i) SA[i] = -1;\n  for (int i = 1; i < n; ++i)\n    if ((i > 0 && t[i] && !t[i - 1])) SA[--bkt[s[i]]] = i;\n  induceSAL(t, SA, s, n, K, false);\n  induceSAS(t, SA, s, n, K, true);\n  int n1 = 0;\n  for (int i = 0; i < n; ++i)\n    if ((SA[i] > 0 && t[SA[i]] && !t[SA[i] - 1])) SA[n1++] = SA[i];\n  for (int i = n1; i < n; ++i) SA[i] = -1;\n  int rank = 0, prev = -1;\n  for (int i = 0; i < n1; ++i) {\n    int pos = SA[i];\n    bool dif = false;\n    for (int d = 0; d < n; ++d) {\n      if (prev == -1 || s[pos + d] != s[prev + d] ||\n          t[pos + d] != t[prev + d]) {\n        dif = true;\n        break;\n      } else if (d > 0 && ((pos + d > 0 && t[pos + d] && !t[pos + d - 1]) ||\n                           (prev + d > 0 && t[prev + d] && !t[prev + d - 1])))\n        break;\n    }\n    if (dif) {\n      ++rank;\n      prev = pos;\n    }\n    pos >>= 1;\n    SA[n1 + pos] = rank - 1;\n  }\n  for (int i = n - 1, j = n - 1; i >= n1; --i)\n    if (SA[i] >= 0) SA[j--] = SA[i];\n  int *SA1 = SA, *s1 = SA + n - n1;\n  if (rank < n1)\n    SA_IS(s1, SA1, n1, rank - 1);\n  else\n    for (int i = 0; i < n1; ++i) SA1[s1[i]] = i;\n  setBuckets(s, n, K, true);\n  for (int i = 1, j = 0; i < n; ++i)\n    if ((i > 0 && t[i] && !t[i - 1])) s1[j++] = i;\n  for (int i = 0; i < n1; ++i) SA1[i] = s1[SA1[i]];\n  for (int i = n1; i < n; ++i) SA[i] = -1;\n  for (int i = n1 - 1, j; i >= 0; --i) {\n    j = SA[i];\n    SA[i] = -1;\n    SA[--bkt[s[j]]] = j;\n  }\n  induceSAL(t, SA, s, n, K, false);\n  induceSAS(t, SA, s, n, K, true);\n}\nstatic int tmp[MAX_N];\nstatic void SA_IS(char* s, int* SA, int n) {\n  for (int i = 0; i < (n); ++i) tmp[i] = s[i];\n  SA_IS(tmp, SA, n, 260);\n}\n};  // namespace lib\nstatic const int MAX_N = 2000005;\nint sa[MAX_N];\nchar s[2000005];\nint n;\nint hei[2000005], nxt[2000005];\nint main() {\n  scanf(\"%s\", s);\n  n = strlen(s);\n  for (int i = 0; i < (n); ++i) s[i + n] = s[i];\n  int n2 = n * 2;\n  hei[0] = 0;\n  for (int i = 0; i < (n2); ++i) {\n    hei[i + 1] = hei[i] + (s[i] == '(' ? 1 : -1);\n  }\n  priority_queue<pair<int, int> > pq;\n  for (int i = 0; i < (n2); ++i) nxt[i] = n2;\n  int d = hei[n];\n  int dif;\n  if (d >= 0)\n    dif = 0;\n  else\n    dif = -d;\n  for (int i = 0; i < (n2); ++i) {\n    while (!pq.empty() && pq.top().first > hei[i] + dif) {\n      nxt[pq.top().second] = i;\n      pq.pop();\n    }\n    pq.push(make_pair(hei[i], i));\n  }\n  lib::SA_IS(s, sa, n * 2 + 1);\n  string res;\n  int p = -1;\n  for (int i = 0; i < (n2 + 1); ++i) {\n    if (sa[i] < n && nxt[sa[i]] >= sa[i] + n) {\n      p = sa[i];\n      break;\n    }\n  }\n  if (d < 0)\n    for (int i = 0; i < (-d); ++i) res += '(';\n  for (int i = 0; i < (n); ++i) res += s[p + i];\n  if (d > 0)\n    for (int i = 0; i < (d); ++i) res += ')';\n  printf(\"%s\\n\", res.c_str());\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline bool getmin(T *a, const T &b) {\n  if (b < *a) {\n    *a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <class T>\ninline bool getmax(T *a, const T &b) {\n  if (b > *a) {\n    *a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <class T>\ninline void read(T *a) {\n  char c;\n  while (isspace(c = getchar())) {\n  }\n  bool flag = 0;\n  if (c == '-')\n    flag = 1, *a = 0;\n  else\n    *a = c - 48;\n  while (isdigit(c = getchar())) *a = *a * 10 + c - 48;\n  if (flag) *a = -*a;\n}\nconst int mo = 1000000007;\ntemplate <class T>\nT pow(T a, T b, int c = mo) {\n  T res = 1;\n  for (T i = 1; i <= b; i <<= 1, a = 1LL * a * a % c)\n    if (b & i) res = 1LL * res * a % c;\n  return res;\n}\nconst int N = 2100000;\nunsigned long long h[N];\nunsigned long long e[N];\nint h2[N], e2[N];\nchar s[N];\nint n;\nunsigned long long get(int x, int l) { return h[x + l - 1] - h[x - 1] * e[l]; }\nint get2(int x, int l) {\n  return (h2[x + l - 1] - 1LL * h2[x - 1] * e2[l] % mo + mo) % mo;\n}\nbool cmp(int x, int y) {\n  int l = 1, r = n, z = 0;\n  if (!y) return true;\n  while (l <= r) {\n    int mid = (l + r) >> 1;\n    if (get(x, mid) == get(y, mid) && get2(x, mid) == get2(y, mid))\n      z = mid, l = mid + 1;\n    else\n      r = mid - 1;\n  }\n  return s[x + z] < s[y + z];\n}\nset<pair<int, int> > S;\nint a[N];\nint main() {\n  scanf(\"%s\", s + 1);\n  n = strlen(s + 1);\n  for (int i = (1); i <= (n); ++i) s[n + i] = s[i];\n  e[0] = 1;\n  e2[0] = 1;\n  for (int i = (1); i <= (2 * n); ++i) e[i] = e[i - 1] * 1331;\n  for (int i = (1); i <= (2 * n); ++i) e2[i] = 1LL * e2[i - 1] * 1331 % mo;\n  for (int i = (1); i <= (2 * n); ++i) h[i] = h[i - 1] * 1331 + s[i];\n  for (int i = (1); i <= (2 * n); ++i)\n    h2[i] = (1LL * h2[i - 1] * 1331 % mo + s[i]) % mo;\n  int x = 0, y = 0;\n  for (int i = (1); i <= (n); ++i)\n    if (s[i] == '(')\n      a[i] = a[i - 1] + 1, ++x;\n    else\n      a[i] = a[i - 1] - 1, ++y;\n  for (int i = (1); i <= (n); ++i) S.insert(std::make_pair(a[i], i));\n  int ans = 0;\n  if (x > y) {\n    int tmp = 0;\n    for (int i = (1); i <= (n); ++i) {\n      if (S.begin()->first - tmp >= 0)\n        if (cmp(i, ans)) ans = i;\n      set<pair<int, int> >::iterator it = S.find(std::make_pair(a[i], i));\n      S.erase(it);\n      if (s[i] == '(')\n        ++tmp;\n      else\n        --tmp;\n      S.insert(std::make_pair(x - y + tmp, i));\n    }\n    for (int i = (ans); i <= (ans + n - 1); ++i) putchar(s[i]);\n    for (int i = (1); i <= (x - y); ++i) putchar(')');\n  } else {\n    int tmp = 0;\n    for (int i = (1); i <= (n); ++i) {\n      if (S.begin()->first - tmp >= x - y)\n        if (cmp(i, ans)) ans = i;\n      set<pair<int, int> >::iterator it = S.find(std::make_pair(a[i], i));\n      S.erase(it);\n      if (s[i] == '(')\n        ++tmp;\n      else\n        --tmp;\n      S.insert(std::make_pair(x - y + tmp, i));\n    }\n    for (int i = (1); i <= (y - x); ++i) putchar('(');\n    for (int i = (ans); i <= (ans + n - 1); ++i) putchar(s[i]);\n  }\n  cout << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e6 + 100;\nint na[N], nb[N], ns[N], nv[N];\nint sa[N], he[N], rk[N];\nint cmp(int *r, int a, int b, int l) {\n  return r[a] == r[b] && r[a + l] == r[b + l];\n}\nvoid _sort(int x[N], int y[N], int n, int m) {\n  for (int i = 0; i < m; i++) ns[i] = 0;\n  for (int i = 0; i < n; i++) ns[x[y[i]]]++;\n  for (int i = 1; i < m; i++) ns[i] += ns[i - 1];\n  for (int i = n - 1; i >= 0; i--) {\n    sa[--ns[x[y[i]]]] = y[i];\n  }\n}\nvoid da(int *r, int n, int m) {\n  int *x = na, *y = nb;\n  for (int i = 0; i < n; i++) x[i] = r[i];\n  for (int i = 0; i < n; i++) y[i] = i;\n  for (int i = 0; i < m; i++) ns[i] = 0;\n  for (int i = 0; i < n; i++) ns[x[i] = r[i]]++;\n  for (int i = 1; i < m; i++) ns[i] += ns[i - 1];\n  for (int i = n - 1; i >= 0; i--) sa[--ns[x[i]]] = i;\n  for (int j = 1, p = 1, i; p < n; j *= 2, m = p) {\n    for (p = 0, i = n - j; i < n; i++) y[p++] = i;\n    for (i = 0; i < n; i++)\n      if (sa[i] >= j) y[p++] = sa[i] - j;\n    for (i = 0; i < n; i++) nv[i] = x[y[i]];\n    for (i = 0; i < m; i++) ns[i] = 0;\n    for (i = 0; i < n; i++) ns[nv[i]]++;\n    for (i = 1; i < m; i++) ns[i] += ns[i - 1];\n    for (i = n - 1; i >= 0; i--) sa[--ns[nv[i]]] = y[i];\n    swap(x, y);\n    p = 1;\n    x[sa[0]] = 0;\n    for (i = 1; i < n; i++) {\n      x[sa[i]] = cmp(y, sa[i - 1], sa[i], j) ? p - 1 : p++;\n    }\n  }\n}\nvoid gethe(int *r, int n) {\n  for (int i = 1; i <= n; i++) rk[sa[i]] = i;\n  for (int i = 0, k = 0, j = 0; i < n; he[rk[i++]] = k) {\n    for (k ? k-- : 0, j = sa[rk[i] - 1]; r[i + k] == r[j + k]; k++)\n      ;\n  }\n}\nvoid debug(int n) {\n  for (int i = 0; i <= n; i++) printf(\"%d \", rk[i]);\n  printf(\"rk\\n\");\n  for (int i = 0; i <= n; i++) printf(\"%d \", sa[i]);\n  printf(\"sa\\n\");\n  for (int i = 0; i <= n; i++) printf(\"%d \", he[i]);\n  printf(\"he\\n\");\n}\nvoid solve(int *r, int n) {\n  r[n] = 0;\n  da(r, n + 1, 3);\n  gethe(r, n);\n}\nint l, r, sta[N];\nint aa[N], bb[N];\nvoid ins(int id) {\n  while (r > l && aa[sta[r - 1]] >= aa[id]) r--;\n  sta[r++] = id;\n}\nchar ss[N];\nint vis[N];\nint main() {\n  while (scanf(\"%s\", ss) != EOF) {\n    int n = strlen(ss);\n    int num = 0;\n    for (int i = 0; i < n; i++) {\n      if (ss[i] == '(') {\n        aa[i] = 1;\n        bb[i] = 1;\n        num++;\n      } else {\n        aa[i] = -1;\n        bb[i] = 2;\n        num--;\n      }\n    }\n    for (int i = 0; i < n; i++) {\n      aa[i + n] = aa[i];\n      bb[i + n] = bb[i];\n    }\n    for (int i = 1; i < 2 * n; i++) {\n      aa[i] += aa[i - 1];\n    }\n    memset(vis, 0, sizeof(vis));\n    l = r = 0;\n    for (int i = 0; i < n; i++) {\n      ins(i);\n    }\n    for (int i = 0; i < n; i++) {\n      if (sta[l] < i) l++;\n      int x = aa[sta[l]];\n      if (i) x -= aa[i - 1];\n      if (num < 0) {\n        x += -num;\n      }\n      if (x >= 0) {\n        vis[i] = 1;\n      }\n      ins(i + n);\n    }\n    solve(bb, n * 2);\n    int id = -1;\n    for (int i = 0; i < n; i++)\n      if (vis[i]) {\n        if (id == -1 || rk[i] < rk[id]) {\n          id = i;\n        }\n      }\n    if (id == -1) {\n      printf(\"x\\n\");\n      continue;\n    }\n    for (int i = 0; i < -num; i++) {\n      printf(\"(\");\n    }\n    for (int i = 0; i < n; i++) {\n      printf(\"%c\", ss[id]);\n      id++;\n      if (id == n) id = 0;\n    }\n    for (int i = 0; i < num; i++) {\n      printf(\")\");\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint best_value = 0;\nvoid update_best(int value) {\n  if (value > best_value) {\n    best_value = value;\n  }\n}\nvector<bool> a(2000000);\nvector<int> minleft(1000000);\nvector<int> minright(1000000);\nvector<int> b(1000000);\nvector<int> increasing(1000000);\nvector<int> good(1000000);\nint main() {\n  int n = 0, z = 0;\n  char t;\n  for (;;) {\n    if (!(cin >> t)) {\n      break;\n    }\n    if (t == '(') {\n      z++;\n    } else {\n      a[0] = true;\n      n = 1;\n      break;\n    }\n  }\n  for (;; ++n) {\n    if (!(cin >> t)) {\n      break;\n    }\n    if (t == '(') {\n      a[n] = false;\n    } else {\n      a[n] = true;\n    }\n  }\n  for (int i = 0; i < z; ++i) {\n    a[n] = false;\n    n++;\n  }\n  for (int i = 0; i < n; ++i) {\n    a[n + i] = a[i];\n  }\n  int balance = 0, min = 0;\n  for (int i = 0; i < n; ++i) {\n    minleft[i] = min;\n    b[i] = balance;\n    if (a[i] == false) {\n      balance++;\n    } else {\n      balance--;\n      if (min > balance) {\n        min = balance;\n      }\n    }\n  }\n  int total = balance;\n  min = balance;\n  for (int i = n - 1; i >= 0; --i) {\n    minright[i] = min;\n    if (a[i] == false) {\n      balance--;\n      if (min > balance) {\n        min = balance;\n      }\n    } else {\n      balance++;\n    }\n  }\n  balance = total;\n  int incr = 0;\n  for (int i = n - 1; i >= 0; --i) {\n    if (a[i] == false) {\n      incr++;\n    } else {\n      incr = 0;\n    }\n    increasing[i] = incr;\n  }\n  if (balance <= 0) {\n    for (int i = 0; i < n; ++i) {\n      good[i] = 0;\n      if (minleft[i] == b[i] && minright[i] - balance >= b[i]) {\n        update_best(increasing[i]);\n        good[i] = 1;\n      }\n    }\n  } else {\n    if (minright[0] >= 0) {\n      update_best(increasing[0]);\n      good[0] = 1;\n    }\n    for (int i = 0; i < n - 1; ++i) {\n      good[i + 1] = 0;\n      if (minright[i] == b[i + 1] && b[i + 1] - balance <= minleft[i]) {\n        update_best(increasing[i + 1]);\n        good[i + 1] = 1;\n      }\n    }\n  }\n  int first = -1, second = -1;\n  for (int i = 0; i < n; ++i) {\n    if (increasing[i] == best_value && good[i] == 1) {\n      if (first == -1) {\n        first = i;\n      } else if (second == -1) {\n        second = i;\n      }\n    } else {\n      good[i] = 0;\n    }\n  }\n  if (first == -1) return 1;\n  if (second != -1) {\n    int len = best_value;\n    while (true) {\n      do {\n        if (first + len == second || second + len == first) {\n          break;\n        }\n        len++;\n      } while (a[first + len] == a[second + len]);\n      if (second + len == first) {\n        swap(first, second);\n      } else if (a[first + len] == true) {\n        swap(first, second);\n      }\n      second += len;\n      len = best_value;\n      while (second < n && (good[second] == 0 || second == first)) {\n        second++;\n      }\n      if (second >= n) {\n        break;\n      }\n    }\n  }\n  int best_position = first;\n  if (balance <= 0) {\n    for (int i = 0; i < -balance; ++i) {\n      cout << \"(\";\n    }\n  }\n  for (int i = best_position; i < n; ++i) {\n    cout << (a[i] == false ? \"(\" : \")\");\n  }\n  for (int i = 0; i < best_position; ++i) {\n    cout << (a[i] == false ? \"(\" : \")\");\n  }\n  if (balance > 0) {\n    for (int i = 0; i < balance; ++i) {\n      cout << \")\";\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct H {\n  long long a, b;\n  H(long long a = 1, long long b = 1) : a(a), b(b) {}\n  H operator*(long long x) { return H(a * x, b * x % 1000000007); }\n  H operator*(H h) { return H(a * h.a, b * h.b % 1000000007); }\n  H operator+(H h) { return H(a + h.a, (b + h.b) % 1000000007); }\n  H operator-(H h) { return H(a - h.a, (b - h.b + 1000000007) % 1000000007); }\n  bool operator==(H h) { return a == h.a && b == h.b; }\n};\nint n;\nstring s;\nH p[2 * 1000010], h[2 * 1000010];\nint pre[1000010], suf[1000010];\nint pmn[1000010], smx[1000010];\nH get(int a, int len) {\n  H res = h[a + len - 1];\n  if (a > 0) res = res - h[a - 1];\n  return res;\n}\nbool equal(int a, int b, int len) {\n  if (a < b) swap(a, b);\n  H ha = get(a, len);\n  H hb = get(b, len) * p[a - b];\n  return ha == hb;\n}\nbool test(int a, int b) {\n  int lo = 0, hi = n + 1, mid;\n  while (hi - lo > 1) {\n    mid = (lo + hi) / 2;\n    if (equal(a, b, mid))\n      lo = mid;\n    else\n      hi = mid;\n  }\n  if (lo == n) return 0;\n  return s[a + lo] < s[b + lo];\n}\nint main() {\n  ios::sync_with_stdio(0);\n  p[0] = H();\n  for (int i = 1; i < 2 * 1000010; i++) p[i] = p[i - 1] * 17;\n  cin >> s;\n  n = s.size();\n  for (int i = 0; i < n; i++) pre[i] = suf[i] = s[i] == '(' ? 1 : -1;\n  for (int i = 1; i < n; i++) pre[i] += pre[i - 1];\n  for (int i = n - 2; i >= 0; i--) suf[i] += suf[i + 1];\n  pmn[0] = 1000010;\n  for (int i = 1; i < n; i++) {\n    pmn[i] = min(pmn[i - 1], pre[i - 1] + pre[n - 1]);\n  }\n  for (int i = n - 1, x = 1000010; i >= 0; i--) {\n    x = min(x, pre[i]);\n    pmn[i] = min(pmn[i], x);\n  }\n  smx[n] = -1000010;\n  for (int i = n - 1; i >= 0; i--) {\n    smx[i] = max(smx[i + 1], suf[i] + suf[0]);\n  }\n  for (int i = 1, x = -1000010; i < n; i++) {\n    x = max(x, suf[i - 1]);\n    smx[i] = max(smx[i], x);\n  }\n  for (int i = 1; i < n; i++) pmn[i] -= pre[i - 1];\n  for (int i = n - 1; i >= 0; i--) smx[i] -= suf[i];\n  s = s + s;\n  for (int i = 0; i < n + n; i++) {\n    h[i] = p[i] * (s[i] - '(');\n    if (i > 0) h[i] = h[i] + h[i - 1];\n  }\n  int a = -1;\n  for (int i = 0; i < n; i++) {\n    if (suf[0] >= 0 && pmn[i] < 0) continue;\n    if (suf[0] <= 0 && smx[i] > 0) continue;\n    if (a < 0 || test(i, a)) a = i;\n  }\n  for (int i = 0; i < -suf[0]; i++) cout << '(';\n  for (int i = 0; i < n; i++) cout << s[a + i];\n  for (int i = 0; i < suf[0]; i++) cout << ')';\n  cout << '\\n';\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint ans, mini, N, lg, dp[22][1000009], s[2000009], pos[1000009];\nchar sir[2000009];\npair<pair<int, int>, int> A[2000009];\ndeque<int> dq;\nint main() {\n  gets(sir + 1), N = strlen(sir + 1), ans = -1;\n  for (int i = N + 1; i <= 2 * N; i++) sir[i] = sir[i - N];\n  for (int i = 1; i <= 2 * N; i++) {\n    s[i] = s[i - 1];\n    if (sir[i] == '(')\n      s[i]++;\n    else\n      s[i]--;\n    if (s[i] < mini && i < N) mini = s[i];\n  }\n  for (int i = 1; i <= N; i++)\n    dp[0][i] = sir[i], A[i] = make_pair(make_pair(0, 0), i);\n  for (int i = 1; (1 << (i - 1)) <= N; i++) {\n    int P = (1 << (i - 1));\n    for (int j = 1; j <= N; j++) {\n      int k = A[j].second;\n      A[j].first.first = dp[i - 1][k];\n      if (k + P <= N)\n        A[j].first.second = dp[i - 1][k + P];\n      else\n        A[j].first.second = dp[i - 1][k + P - N];\n    }\n    sort(A + 1, A + N + 1);\n    for (int j = 1; j <= N; j++)\n      dp[i][A[j].second] =\n          dp[i][A[j - 1].second] + (j == 1 || A[j].first != A[j - 1].first);\n  }\n  for (int i = 1; i <= N; i++) pos[A[i].second] = i;\n  int Konst = 0;\n  if (s[N] < 0) Konst = s[N];\n  int j = 0;\n  for (int i = 0; i < N; i++) {\n    while (j <= i + N) {\n      while (!dq.empty() && s[dq.back()] >= s[j]) dq.pop_back();\n      dq.push_back(j);\n      while (dq.front() <= j - N) dq.pop_front();\n      j++;\n    }\n    if (s[dq.front()] - s[i] >= Konst) {\n      if (ans == -1)\n        ans = i + 1;\n      else {\n        if (pos[i + 1] < pos[ans]) ans = i + 1;\n      }\n    }\n  }\n  while (s[N] < 0) printf(\"(\"), s[N]++;\n  for (int i = ans; i <= N + ans - 1; i++) printf(\"%c\", sir[i]);\n  while (s[N] > 0) printf(\")\"), s[N]--;\n  printf(\"\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 4000010;\ninline int read() {\n  int x = 0;\n  int f = 0, c = getchar();\n  for (; c > '9' || c < '0'; f = c == '-', c = getchar())\n    ;\n  for (; c >= '0' && c <= '9'; c = getchar()) x = (x << 3) + (x << 1) + c - '0';\n  return f ? -x : x;\n}\nstruct cqz {\n  int i, x, y;\n  cqz(int a = 0, int b = 0, int c = 0) {\n    i = a;\n    x = b;\n    y = c;\n  }\n} a[N];\ninline bool operator<(const cqz& i, const cqz& j) {\n  return i.x < j.x || (i.x == j.x && i.y < j.y);\n}\ninline bool operator!=(const cqz& i, const cqz& j) {\n  return i.x != j.x || i.y != j.y;\n}\nchar s[N];\nint sta[N], top, p[N];\nint n, m, rk[N], sm, sl, sr, ans, flag;\nint main() {\n  scanf(\"%s\", s + 1);\n  n = strlen(s + 1);\n  m = n;\n  register int i, j, k;\n  for (i = 1; i <= n; i++) s[i + n] = s[i];\n  for (i = 1; i <= n; i++) rk[i] = s[i];\n  for (k = 1; k < n; k <<= 1) {\n    for (i = 1; i <= n; i++) a[i] = cqz(i, rk[i], rk[(i + k - 1) % n + 1]);\n    sort(a + 1, a + n + 1);\n    for (i = j = 1; i <= n; i++) rk[a[i].i] = j, j += a[i + 1] != a[i];\n    if (j > n) break;\n  }\n  n = n + n;\n  for (i = n - 1; i > m; i--)\n    if (s[i] == '(') {\n      if (sl)\n        sm++, sl--;\n      else\n        sr++;\n    } else\n      sl++;\n  k = 1e9;\n  for (i = 1; i <= n; i++)\n    if (s[i] == '(')\n      sta[++top] = i;\n    else {\n      p[i] = sta[top];\n      if (top) top--;\n    }\n  for (i = m; i; i--) {\n    if (s[i] == '(') {\n      if (sl)\n        sm++, sl--;\n      else\n        sr++;\n    } else\n      sl++;\n    if (!sl || !sr) {\n      flag = sl - sr;\n      if (rk[i] < k) ans = i, k = rk[i];\n    }\n    if (s[i + m - 1] == '(')\n      sr--;\n    else {\n      if (p[i + m - 1] > i)\n        sm--, sr++;\n      else\n        sl--;\n    }\n  }\n  if (flag > 0)\n    while (flag) putchar('('), flag--;\n  for (i = 0; i < m; i++) putchar(s[ans + i]);\n  if (flag < 0)\n    while (flag++) putchar(')');\n  puts(\"\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 4000000 + 5;\nint n, gs[maxn], sa[maxn], wb[maxn], wv[maxn], ran[maxn], sum[maxn], pre[maxn],\n    suf[maxn];\nchar s[maxn];\ninline int check(char a) {\n  if (a == '(') return 1;\n  if (a == ')') return -1;\n}\ninline bool cmp(int *x, int a, int b, int l) {\n  return x[a] == x[b] && x[a + l] == x[b + l];\n}\ninline void da(int *sa, int *x, int n, int m) {\n  int i, j, p, *y = wb;\n  for (i = 0; i < m; i++) gs[i] = 0;\n  for (i = 0; i < n; i++) gs[x[i]]++;\n  for (i = 1; i < m; i++) gs[i] += gs[i - 1];\n  for (i = n - 1; ~i; i--) sa[--gs[x[i]]] = i;\n  for (j = 1, p = 1; p < n; j <<= 1, m = p) {\n    for (i = n - j, p = 0; i < n; i++) y[p++] = i;\n    for (i = 0; i < n; i++)\n      if (sa[i] >= j) y[p++] = sa[i] - j;\n    for (i = 0; i < n; i++) wv[i] = x[y[i]];\n    for (i = 0; i < m; i++) gs[i] = 0;\n    for (i = 0; i < n; i++) gs[wv[i]]++;\n    for (i = 1; i < m; i++) gs[i] += gs[i - 1];\n    for (i = n - 1; ~i; i--) sa[--gs[wv[i]]] = y[i];\n    p = 1;\n    swap(x, y);\n    x[sa[0]] = 0;\n    for (i = 1; i < n; i++)\n      x[sa[i]] = cmp(y, sa[i], sa[i - 1], j) ? p - 1 : p++;\n  }\n}\nsigned main(void) {\n  scanf(\"%s\", s);\n  n = strlen(s);\n  for (int i = 0; i < n; i++) ran[i] = (int)s[i];\n  for (int i = n; i < 2 * n; i++) ran[i] = (int)s[i - n], s[i] = s[i - n];\n  da(sa, ran, 2 * n + 1, 47);\n  for (int i = 0; i < n; i++) sum[i] = sum[i - 1] + check(s[i]);\n  pre[0] = sum[0];\n  for (int i = 1; i < n; i++) pre[i] = min(pre[i - 1], sum[i]);\n  suf[n - 1] = sum[n - 1];\n  for (int i = n - 2; i >= 0; i--) suf[i] = min(suf[i + 1], sum[i]);\n  for (int i = 1; i <= 2 * n; i++)\n    if (sa[i] < n) {\n      int tmp = min(suf[sa[i]] - sum[sa[i] - 1],\n                    sum[n - 1] - sum[sa[i] - 1] + pre[sa[i] - 1]);\n      if (sum[n - 1] >= 0 && tmp >= 0) {\n        for (int j = 0; j < n; j++) printf(\"%c\", s[sa[i] + j]);\n        for (int j = 0; j < sum[n - 1]; j++) printf(\")\");\n        puts(\"\");\n        break;\n      }\n      tmp = min(sum[n - 1] - sum[sa[i] - 1] + pre[sa[i] - 1] - sum[n - 1],\n                suf[sa[i]] - sum[sa[i] - 1] - sum[n - 1]);\n      if (sum[n - 1] < 0 && tmp >= 0) {\n        for (int j = 0; j < -sum[n - 1]; j++) printf(\"(\");\n        for (int j = 0; j < n; j++) printf(\"%c\", s[sa[i] + j]);\n        puts(\"\");\n        break;\n      }\n    }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2000000 + 5;\nint wa[N], wb[N], wc[N], wv[N];\nbool cmp(int *r, int a, int b, int l) {\n  return r[a] == r[b] && r[a + l] == r[b + l];\n}\nvoid da(int *r, int *sa, int n, int m) {\n  int *x = wa, *y = wb;\n  for (int i = 0; i < m; i++) wc[i] = 0;\n  for (int i = 0; i < n; i++) wc[x[i] = r[i]]++;\n  for (int i = 1; i < m; i++) wc[i] += wc[i - 1];\n  for (int i = n - 1; i >= 0; i--) sa[--wc[x[i]]] = i;\n  for (int j = 1, p = 1; p < n; j <<= 1, m = p) {\n    p = 0;\n    for (int i = n - j; i < n; i++) y[p++] = i;\n    for (int i = 0; i < n; i++)\n      if (sa[i] >= j) y[p++] = sa[i] - j;\n    for (int i = 0; i < n; i++) wv[i] = x[y[i]];\n    for (int i = 0; i < m; i++) wc[i] = 0;\n    for (int i = 0; i < n; i++) wc[wv[i]]++;\n    for (int i = 1; i < m; i++) wc[i] += wc[i - 1];\n    for (int i = n - 1; i >= 0; i--) sa[--wc[wv[i]]] = y[i];\n    int *t = x;\n    x = y;\n    y = t;\n    p = 1;\n    x[sa[0]] = 0;\n    for (int i = 1; i < n; i++)\n      x[sa[i]] = cmp(y, sa[i - 1], sa[i], j) ? p - 1 : p++;\n  }\n}\nvoid calheight(int *r, int *sa, int *rk, int *height, int n) {\n  for (int i = 1; i <= n; i++) rk[sa[i]] = i;\n  int k = 0;\n  for (int i = 0; i < n; height[rk[i++]] = k) {\n    if (k) k--;\n    for (int j = sa[rk[i] - 1]; r[i + k] == r[j + k]; k++)\n      ;\n  }\n}\nint rq[N][22], Log[N];\nvoid build_rmq(int *a, int n) {\n  for (int i = 0; i < n; i++) rq[i][0] = a[i];\n  for (int j = 1; j < 21; j++) {\n    for (int i = 0; i + (1 << j) - 1 < n; i++)\n      rq[i][j] = min(rq[i][j - 1], rq[i + (1 << j - 1)][j - 1]);\n  }\n  int cr = 0;\n  for (int i = 1; i <= n; i++) {\n    if ((1 << cr + 1) <= i) cr++;\n    Log[i] = cr;\n  }\n}\nint query_rmq(int l, int r) {\n  int k = Log[r - l + 1];\n  return min(rq[l][k], rq[r - (1 << k) + 1][k]);\n}\nchar s[N];\nint a[N], sa[N], rk[N], height[N];\nint sum[N];\nint n;\nbool check(int id, int need) {\n  int pre = 0;\n  if (id > 0) pre = sum[id - 1];\n  int mn = query_rmq(id, id + n - 1);\n  if (need < 0) mn -= need;\n  return mn >= pre;\n}\nvoid solve() {\n  n = strlen(s);\n  for (int i = 0; i < n; i++) {\n    a[i] = s[i] == '(' ? 1 : 2;\n  }\n  for (int i = n; i < n << 1; i++) a[i] = a[i - n];\n  a[n << 1] = 0;\n  da(a, sa, n << 1 | 1, 3);\n  calheight(a, sa, rk, height, n << 1);\n  sum[0] = a[0] == 1 ? 1 : -1;\n  for (int i = 1; i < (n << 1); i++) sum[i] = sum[i - 1] + (a[i] == 1 ? 1 : -1);\n  build_rmq(sum, n << 1);\n  int need = sum[n - 1];\n  int ans = -1;\n  for (int i = 0; i < n; i++) {\n    if (check(i, need)) {\n      if (ans == -1 || rk[ans] > rk[i]) {\n        ans = i;\n      }\n    }\n  }\n  if (need < 0) {\n    for (int i = 0; i < -need; i++) printf(\"(\");\n    for (int i = 0; i < n; i++) {\n      if (a[i + ans] > 1)\n        printf(\")\");\n      else\n        printf(\"(\");\n    }\n    puts(\"\");\n  } else {\n    for (int i = 0; i < n; i++) {\n      if (a[i + ans] > 1)\n        printf(\")\");\n      else\n        printf(\"(\");\n    }\n    for (int i = 0; i < need; i++) printf(\")\");\n    puts(\"\");\n  }\n}\nint main() {\n  scanf(\"%s\", s);\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint m;\nchar s[2000100];\nint a[2000100], pre[2000100], suf[2000100];\nint sa[2000100], rnk[2000100], lcp[2000100], cnt[2000100];\nvoid build(char *s) {\n  int n = strlen(s) + 1, m = 256;\n  int *x = rnk, *y = lcp, *z;\n  for (int i = 0; i < m; i++) cnt[i] = 0;\n  for (int i = 0; i < n; i++) cnt[x[i] = s[i]]++;\n  for (int i = 1; i < m; i++) cnt[i] += cnt[i - 1];\n  for (int i = n - 1; i >= 0; i--) sa[--cnt[x[i]]] = i;\n  for (int j = 1, p = 1; p < n; j <<= 1, m = p) {\n    p = 0;\n    for (int i = n - j; i < n; i++) y[p++] = i;\n    for (int i = 0; i < n; i++)\n      if (sa[i] >= j) y[p++] = sa[i] - j;\n    for (int i = 0; i < m; i++) cnt[i] = 0;\n    for (int i = 0; i < n; i++) cnt[x[i]]++;\n    for (int i = 1; i < m; i++) cnt[i] += cnt[i - 1];\n    for (int i = n - 1; i >= 0; i--) sa[--cnt[x[y[i]]]] = y[i];\n    z = x, x = y, y = z;\n    x[sa[0]] = 0, p = 1;\n    for (int i = 1; i < n; i++) {\n      x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + j] == y[sa[i - 1] + j])\n                     ? p - 1\n                     : p++;\n    }\n  }\n}\nint main() {\n  scanf(\"%s\", s + 1);\n  m = strlen(s + 1);\n  for (int i = 1; i <= m; i++) a[i] = a[i - 1] + (s[i] == '(' ? 1 : -1);\n  pre[0] = 2000100;\n  for (int i = 1; i <= m; i++) pre[i] = min(pre[i - 1], a[i]);\n  suf[m + 1] = 2000100;\n  for (int i = m; i >= 0; i--) suf[i] = min(suf[i + 1], a[i]);\n  for (int i = 1; i <= m; i++) s[m + i] = s[i];\n  build(s + 1);\n  for (int i = 0; i <= 2 * m; i++)\n    if (sa[i] < m) {\n      int j = sa[i] + 1;\n      bool ok = 0;\n      if (a[m] >= 0) {\n        if (min(suf[j], a[m] + pre[j - 1]) >= a[j - 1]) {\n          ok = 1;\n        }\n      } else {\n        if (min(-a[m] + suf[j], pre[j - 1]) >= a[j - 1]) {\n          ok = 1;\n        }\n      }\n      if (ok) {\n        rotate(s + 1, s + j, s + m + 1);\n        s[m + 1] = 0;\n        if (a[m] >= 0) {\n          printf(\"%s\", s + 1);\n          while (a[m]--) putchar(')');\n        } else {\n          a[m] = -a[m];\n          while (a[m]--) putchar('(');\n          printf(\"%s\", s + 1);\n        }\n        return 0;\n      }\n    }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e6 + 10;\nconst long long md = 1e9 + 7;\nint need[N], reduce[N];\nlong long st[N], head[N], tail[N], sdfsdfsd[N];\nint n;\nstring s;\nstruct candidate {\n  int start, headLen, tailLen;\n  candidate() {}\n  candidate(int start, int headLen, int tailLen)\n      : start(start), headLen(headLen), tailLen(tailLen) {}\n};\nlong long getSuperHash(int l, int r) {\n  if (l == 0 && r == n - 1) {\n    return sdfsdfsd[l];\n  }\n  if (l < n && r >= n) {\n    return (sdfsdfsd[l] + sdfsdfsd[r] * st[n - l]) % md;\n  }\n  if (l >= n) {\n    l -= n;\n    r -= n;\n  }\n  if (r == n - 1) {\n    return sdfsdfsd[l];\n  }\n  r++;\n  long long res = (sdfsdfsd[l] - sdfsdfsd[r] * st[r - l]) % md;\n  return (res + md) % md;\n}\nlong long getHash(candidate i, int len) {\n  if (len <= i.headLen) {\n    return head[len];\n  }\n  long long res = head[i.headLen];\n  len -= i.headLen;\n  if (len <= n) {\n    return (res + getSuperHash(i.start, i.start + len - 1) * st[i.headLen]) %\n           md;\n  }\n  res += getSuperHash(i.start, i.start + n - 1) * st[i.headLen];\n  res %= md;\n  len -= n;\n  return (res + st[n + i.headLen] * tail[len]) % md;\n}\nchar compare(candidate last, candidate cur) {\n  int l = 0, r = n + cur.headLen + cur.tailLen;\n  if (getHash(last, r) == getHash(cur, r)) {\n    return true;\n  }\n  while (l + 1 < r) {\n    int len = (l + r) / 2;\n    (getHash(last, len) == getHash(cur, len) ? l : r) = len;\n  }\n  int p = getHash(last, r) == getHash(cur, r) ? r : l;\n  if (p < last.headLen) {\n    return true;\n  }\n  p -= last.headLen;\n  assert(p < n + last.tailLen);\n  return p < n ? s[last.start + p] == '(' : false;\n}\nint main() {\n  st[0] = 1;\n  for (int i = 1; i < N; i++) {\n    st[i] = st[i - 1] * 239 % md;\n    head[i] = (head[i - 1] + st[i]) % md;\n    tail[i] = (tail[i - 1] + st[i] * 2) % md;\n  }\n  getline(cin, s);\n  n = s.length();\n  s += s;\n  need[n - 1] = s[n - 1] == ')';\n  reduce[n - 1] = s[n - 1] == '(';\n  sdfsdfsd[n - 1] = s[n - 1] - '(' + 1;\n  need[n] = s[n] == ')';\n  reduce[n] = s[n] == '(';\n  sdfsdfsd[n] = s[n] - '(' + 1;\n  for (int i = n - 2; i >= 0; i--) {\n    need[i] = s[i] == ')';\n    reduce[i] = s[i] == '(';\n    int take = min(reduce[i], need[i + 1]);\n    need[i] = need[i] + need[i + 1] - take;\n    reduce[i] = reduce[i] + reduce[i + 1] - take;\n    sdfsdfsd[i] = (s[i] - '(' + 1 + sdfsdfsd[i + 1] * st[1]) % md;\n  }\n  for (int i = n + 1; i < n * 2; i++) {\n    need[i] = s[i] == ')';\n    reduce[i] = s[i] == '(';\n    int take = min(reduce[i - 1], need[i]);\n    need[i] = need[i] + need[i - 1] - take;\n    reduce[i] = reduce[i] + reduce[i - 1] - take;\n    sdfsdfsd[i] = (sdfsdfsd[i - 1] + st[i - n] * (s[i] - '(' + 1)) % md;\n  }\n  int minCost = need[0] + reduce[0];\n  vector<candidate> c;\n  c.emplace_back(0, need[0], reduce[0]);\n  for (int l = 1, r = n; l < n; l++, r++) {\n    int take = min(reduce[l], need[r]), need, reduce;\n    need = ::need[l] + ::need[r] - take;\n    reduce = ::reduce[l] + ::reduce[r] - take;\n    if (need + reduce > minCost) {\n      continue;\n    }\n    if (need + reduce < minCost) {\n      c.clear();\n    }\n    minCost = need + reduce;\n    c.emplace_back(l, need, reduce);\n  }\n  for (candidate i : c)\n    if (!compare(c[0], i)) {\n      c[0] = i;\n    }\n  while (c[0].headLen--) {\n    printf(\"(\");\n  }\n  for (int i = 0; i < n; i++) {\n    printf(\"%c\", s[i + c[0].start]);\n  }\n  while (c[0].tailLen--) {\n    printf(\")\");\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool debug;\nconst int inf = 1e9 + 5;\nconst long long INF = (long long)inf * inf;\nconst int nax = 1e6 + 5;\nconst int D = 5;\nconst long long MM = 1000 * 1000 * 1000;\nconst long long m[D] = {MM + 7, MM + 9, MM + 21, MM + 33, 333333361LL};\nchar sl[nax];\nlong long preh[nax][D];\nint n;\nlong long potega[nax][D];\nlong long h(pair<int, int> a, int j) {\n  long long x = preh[a.second][j];\n  if (a.first) x -= preh[a.first - 1][j];\n  if (x < 0) x += m[j];\n  x = (x * potega[n - a.first][j]) % m[j];\n  return x;\n}\nbool rowne(pair<int, int> a, pair<int, int> b) {\n  for (int j = 0; j <= (D)-1; ++j)\n    if (h(a, j) != h(b, j)) return false;\n  return true;\n}\nint porow(pair<int, int> a, pair<int, int> b) {\n  assert(a.second - a.first == b.second - b.first);\n  if (a.first > a.second) return true;\n  if (rowne(a, b)) return 1;\n  int low = 0, high = a.second - a.first;\n  while (low != high) {\n    int med = (low + high) / 2;\n    if (rowne(make_pair(a.first, a.first + med),\n              make_pair(b.first, b.first + med)))\n      low = med + 1;\n    else\n      high = med;\n  }\n  if (sl[a.first + low] == '(') return 0;\n  return 2;\n}\nint pref[nax];\nint LICZ;\nconst int pot = 1024 * 1024;\nint tr[2 * pot];\nint mi(int a, int b) {\n  a += pot;\n  b += pot;\n  int ku = min(tr[a], tr[b]);\n  while (a < b - 1) {\n    ku = min(ku, tr[a + 1]);\n    ku = min(ku, tr[b - 1]);\n    a /= 2;\n    b /= 2;\n  }\n  return ku;\n}\nbool ok_podzial_szybkie(int i) {\n  int s1 = pref[i];\n  int s2 = LICZ - pref[i];\n  int k = 0;\n  if (LICZ < 0) k = -LICZ;\n  if (i + 1 <= n - 1 && k + mi(i + 1, n - 1) - s1 < 0) return false;\n  if (0 <= i && k + s2 + mi(0, i) < 0) return false;\n  return true;\n}\nbool ok_podzial(int i) {\n  int teraz = 0;\n  if (LICZ < 0) teraz = -LICZ;\n  for (int j = i + 1; j <= n - 1; ++j) {\n    if (sl[j] == '(')\n      ++teraz;\n    else\n      --teraz;\n    if (teraz < 0) return false;\n  }\n  for (int j = 0; j <= i; ++j) {\n    if (sl[j] == '(')\n      ++teraz;\n    else\n      --teraz;\n    if (teraz < 0) return false;\n  }\n  return true;\n}\nint best = -1;\nbool jebaj(int i) {\n  if (best == -1) return true;\n  int kon = best + 1 + (n - 1 - (i + 1));\n  int pom = porow(make_pair(best + 1, kon), make_pair(i + 1, n - 1));\n  if (pom == 0) return false;\n  if (pom == 2) return true;\n  int kon2 = n - 1 - (kon + 1);\n  pom = porow(make_pair(kon + 1, n - 1), make_pair(0, kon2));\n  if (pom == 0) return false;\n  if (pom == 2) return true;\n  pom = porow(make_pair(0, best), make_pair(kon2 + 1, i));\n  if (pom == 0) return false;\n  return true;\n}\nint main(int argc, char *argv[]) {\n  debug = argc > 1;\n  scanf(\"%s\", sl);\n  n = strlen(sl);\n  for (int i = 0; i <= (n)-1; ++i) {\n    if (i) pref[i] = pref[i - 1];\n    if (sl[i] == '(')\n      pref[i]++;\n    else\n      pref[i]--;\n  }\n  for (int i = 0; i <= (2 * pot) - 1; ++i) tr[i] = inf;\n  for (int i = 0; i <= (n)-1; ++i) tr[pot + i] = pref[i];\n  for (int i = pot - 1; i >= 1; --i) tr[i] = min(tr[2 * i], tr[2 * i + 1]);\n  LICZ = 0;\n  for (int i = 0; i <= (n)-1; ++i) {\n    if (sl[i] == '(')\n      ++LICZ;\n    else\n      --LICZ;\n  }\n  for (int j = 0; j <= (D)-1; ++j) {\n    potega[0][j] = 1;\n    for (int i = 1; i <= n; ++i)\n      potega[i][j] = ((j == 2 ? 3 : 2) * potega[i - 1][j]) % m[j];\n  }\n  for (int j = 0; j <= (D)-1; ++j)\n    for (int i = 0; i <= (n)-1; ++i) {\n      int teraz = int(sl[i] == '(');\n      preh[i][j] = ((i ? preh[i - 1][j] : 0LL) + teraz * potega[i][j]) % m[j];\n    }\n  for (int i = 0; i <= (n)-1; ++i)\n    if (ok_podzial_szybkie(i))\n      if (jebaj(i)) best = i;\n  assert(best != -1);\n  if (LICZ < 0)\n    for (int _ = 0; _ <= (-LICZ) - 1; ++_) printf(\"(\");\n  for (int j = best + 1; j <= n - 1; ++j) printf(\"%c\", sl[j]);\n  for (int j = 0; j <= best; ++j) printf(\"%c\", sl[j]);\n  if (LICZ > 0)\n    for (int _ = 0; _ <= (LICZ)-1; ++_) printf(\")\");\n  puts(\"\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1000005;\nchar str[MAXN];\nint N, A, B;\nint seq[MAXN];\nint sum_pf[MAXN], sum_sf[MAXN];\nint low_pf[MAXN], low_sf[MAXN];\nbool elig[MAXN];\ntemplate <typename T = char>\nstruct SuffixArray {\n  int str[MAXN * 6], sa[MAXN * 6], rank[MAXN * 2], height[MAXN * 2], sz;\n  int wa[MAXN * 2], wb[MAXN * 2], wv[MAXN * 2], ws[MAXN * 2];\n  int &operator[](int k) { return sa[k]; }\n  int size() const { return sz; }\n  bool eq(const int *r, int a, int b) const {\n    return r[a] == r[b] && r[a + 1] == r[b + 1] && r[a + 2] == r[b + 2];\n  }\n  bool cmp(const int *r, int a, int b, int d) const {\n    if (d == 1) return (r[a] < r[b]) || (r[a] == r[b] && wv[a + 1] < wv[b + 1]);\n    return (r[a] < r[b]) || (r[a] == r[b] && cmp(r, a + 1, b + 1, 1));\n  }\n  void rsort(const int *r, const int *a, int *b, int n, int m) {\n    int i;\n    fill(ws, ws + m, 0);\n    for (i = 0; i < n; ++i) ++ws[wv[i] = r[a[i]]];\n    for (i = 1; i < m; ++i) ws[i] += ws[i - 1];\n    for (i = n - 1; ~i; --i) b[--ws[wv[i]]] = a[i];\n  }\n  void dc3(int *r, int *sa, int n, int m) {\n    int i, j, k, *rn = r + n, *san = sa + n, tx = 0, ty = (n + 1) / 3, tz = 0;\n    r[n] = r[n + 1] = 0;\n    for (i = 0; i < n; ++i) {\n      if (i % 3) wa[tz++] = i;\n    }\n    rsort(r + 2, wa, wb, tz, m);\n    rsort(r + 1, wb, wa, tz, m);\n    rsort(r, wa, wb, tz, m);\n    for (rn[((wb[0]) / 3 + ((wb[0]) % 3 == 1 ? 0 : ty))] = 0, k = i = 1; i < tz;\n         ++i) {\n      rn[((wb[i]) / 3 + ((wb[i]) % 3 == 1 ? 0 : ty))] =\n          eq(r, wb[i - 1], wb[i]) ? k - 1 : k++;\n    }\n    if (k < tz)\n      dc3(rn, san, tz, k);\n    else {\n      for (i = 0; i < tz; ++i) san[rn[i]] = i;\n    }\n    for (i = 0; i < tz; ++i) {\n      if (san[i] < ty) wb[tx++] = san[i] * 3;\n    }\n    if (n % 3 == 1) wb[tx++] = n - 1;\n    rsort(r, wb, wa, tx, m);\n    for (i = 0; i < tz; ++i)\n      wv[wb[i] = ((san[i]) < ty ? (san[i]) * 3 + 1 : ((san[i]) - ty) * 3 + 2)] =\n          i;\n    for (i = j = k = 0; i < tx && j < tz; ++k) {\n      sa[k] = cmp(r, wa[i], wb[j], wb[j] % 3) ? wa[i++] : wb[j++];\n    }\n    for (; i < tx; ++i) sa[k++] = wa[i];\n    for (; j < tz; ++j) sa[k++] = wb[j];\n  }\n  void build(const T *s, int n, int m = 128) {\n    int i;\n    for (i = 0; i < n; ++i) str[i] = (int)s[i];\n    str[n] = 0;\n    sz = n + 1;\n    dc3(str, sa, sz, m);\n  }\n  void calHeight() {\n    int i, j, k = 0;\n    for (i = 0; i < sz; ++i) rank[sa[i]] = i;\n    for (i = 0; i < sz; height[rank[i++]] = k) {\n      for (k ? --k : 0, j = sa[rank[i] - 1]; str[i + k] == str[j + k]; ++k)\n        ;\n    }\n  }\n};\nSuffixArray<> sa;\nchar s[MAXN * 6];\nint n;\nint main(int argc, char *argv[]) {\n  scanf(\" %s\", str + 1);\n  N = strlen(str + 1);\n  for (int i = 1; i <= N; i++) {\n    seq[i] = (str[i] == '(') ? 1 : -1;\n    if (seq[i] > 0)\n      A++;\n    else\n      B++;\n  }\n  int cur = 0;\n  for (int i = 1; i <= N; i++) {\n    sum_pf[i] = seq[i] + sum_pf[i - 1];\n    cur += seq[i];\n    low_pf[i] = min(low_pf[i - 1], cur);\n  }\n  cur = 0;\n  for (int i = N; i >= 1; i--) {\n    sum_sf[i] = -seq[i] + sum_sf[i + 1];\n    cur -= seq[i];\n    low_sf[i] = min(low_sf[i + 1], cur);\n  }\n  for (int i = 1; i <= N; i++) {\n    low_sf[i] -= sum_sf[i];\n  }\n  for (int i = 1; i < N; i++) {\n    if (A >= B) {\n      if (low_sf[i + 1] >= 0 && (-sum_sf[i + 1]) + low_pf[i] >= 0) {\n        elig[i] = true;\n      } else {\n        elig[i] = false;\n      }\n    } else {\n      if (B - A + low_sf[i + 1] >= 0 &&\n          B - A + (-sum_sf[i + 1]) + low_pf[i] >= 0) {\n        elig[i] = true;\n      } else {\n        elig[i] = false;\n      }\n    }\n  }\n  if (low_pf[N] >= 0) elig[N] = true;\n  n = 2 * N;\n  for (int i = 1; i <= N; i++) {\n    s[i - 1] = s[i - 1 + N] = (str[i] == '(') ? 'a' : 'b';\n  }\n  s[n] = 0;\n  sa.build(s, n);\n  sa.calHeight();\n  int mir = 0x3f3f3f3f, miri = 0;\n  for (int i = 1; i <= N; i++) {\n    if (elig[i] && sa.rank[i] < mir) {\n      mir = sa.rank[i];\n      miri = i;\n    }\n  }\n  for (int i = 1; i <= B - A; i++) {\n    putchar('(');\n  }\n  for (int i = miri + 1; i <= N; i++) {\n    putchar(str[i]);\n  }\n  for (int i = 1; i <= miri; i++) {\n    putchar(str[i]);\n  }\n  for (int i = 1; i <= A - B; i++) {\n    putchar(')');\n  }\n  puts(\"\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool home = 1;\nsigned realMain();\nsigned main() {\n  home = 0;\n  if (home) {\n    freopen(\"tony_stark\", \"r\", stdin);\n  } else {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n  }\n  realMain();\n}\nconst int N = (int)1e6 + 7;\nstring s;\nint n, f[N], c[N], ord[N];\nstruct T {\n  int i;\n  int c1;\n  int c2;\n};\nvector<T> so(vector<T> v) {\n  int n = (int)v.size();\n  for (int i = 0; i <= n; i++) {\n    f[i] = 0;\n  }\n  for (int i = 0; i < n; i++) {\n    f[v[i].c2]++;\n  }\n  for (int i = 1; i <= n; i++) {\n    f[i] += f[i - 1];\n  }\n  vector<T> v2(n);\n  for (int i = n - 1; i >= 0; i--) {\n    v2[--f[v[i].c2]] = v[i];\n  }\n  for (int i = 0; i <= n; i++) {\n    f[i] = 0;\n  }\n  for (int i = 0; i < n; i++) {\n    f[v2[i].c1]++;\n  }\n  for (int i = 1; i <= n; i++) {\n    f[i] += f[i - 1];\n  }\n  for (int i = n - 1; i >= 0; i--) {\n    v[--f[v2[i].c1]] = v2[i];\n  }\n  return v;\n}\nbool operator<(T a, T b) {\n  if (a.c1 != b.c1) {\n    return a.c1 < b.c1;\n  } else {\n    return a.c2 < b.c2;\n  }\n}\nint baltotal, a[N], sum[N], pre[N], suf[N];\nsigned realMain() {\n  cin >> s;\n  n = (int)s.size();\n  int raz = -1;\n  for (int i = 1; i <= n; i++) {\n    if (s[i - 1] == '(')\n      baltotal++;\n    else\n      baltotal--;\n    a[i] = (s[i - 1] == '(') ? +1 : -1;\n    sum[i] = sum[i - 1] + a[i];\n  }\n  pre[1] = sum[1];\n  for (int i = 2; i <= n; i++) {\n    pre[i] = min(pre[i - 1], sum[i]);\n  }\n  suf[n] = sum[n];\n  for (int i = n - 1; i >= 1; i--) {\n    suf[i] = min(suf[i + 1], sum[i]);\n  }\n  for (int i = 0; i < n; i++) {\n    c[i] = s[i];\n    f[c[i]]++;\n  }\n  for (int i = 1; i < N; i++) {\n    f[i] += f[i - 1];\n  }\n  for (int i = 0; i < n; i++) {\n    ord[--f[c[i]]] = i;\n  }\n  map<int, int> trn;\n  for (int i = 0; i < n; i++) {\n    trn[c[i]] = 0;\n  }\n  int curtrn = 0;\n  for (auto &it : trn) {\n    it.second = curtrn++;\n  }\n  for (int i = 0; i < n; i++) {\n    c[i] = trn[c[i]];\n  }\n  for (int len = 1; len <= n; len *= 2) {\n    vector<T> v;\n    for (int i = 0; i < n; i++) {\n      v.push_back({i, c[i], c[(i + len) % n]});\n    }\n    v = so(v);\n    for (int i = 0; i < n; i++) {\n      ord[i] = v[i].i;\n    }\n    c[v[0].i] = 0;\n    for (int i = 1; i < n; i++) {\n      c[v[i].i] = c[v[i - 1].i] + (v[i - 1] < v[i]);\n    }\n  }\n  for (int j = 0; j < n; j++) {\n    bool ok = 1;\n    int cur = max(0, -baltotal), init = cur;\n    if (j + 1 <= n && cur + suf[j + 1] - sum[j] < 0) {\n      ok = 0;\n    }\n    cur = init + sum[n] - sum[j];\n    if (j && cur + pre[j] < 0) {\n      ok = 0;\n    }\n    if (!ok) {\n      continue;\n    }\n    if (raz == -1 || c[j] < c[raz]) {\n      raz = j;\n    }\n  }\n  while (baltotal < 0) {\n    cout << \"(\";\n    baltotal++;\n  }\n  for (int i = 0; i < n; i++) {\n    cout << s[(i + raz) % n];\n  }\n  while (baltotal > 0) {\n    cout << \")\";\n    baltotal--;\n  }\n  cout << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2000010;\nint N, OOP[MAXN], OP[MAXN], FS[MAXN], FMN[MAXN], BS[MAXN], BMN[MAXN];\nstring B;\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(NULL);\n  cin >> B;\n  N = ((int)B.size());\n  int open = 0, close = 0;\n  for (int i = 0; i < N; i++) {\n    if (B[i] == '(') {\n      ++open;\n    } else {\n      ++close;\n    }\n    if (i > 0) {\n      FS[i] = FS[i - 1];\n    }\n    if (B[i] == '(') {\n      ++FS[i];\n    } else {\n      --FS[i];\n    }\n    FMN[i] = FS[i];\n    if (i > 0) {\n      FMN[i] = min(FMN[i - 1], FMN[i]);\n    }\n  }\n  for (int i = N - 1; i >= 0; i--) {\n    BS[i] = BS[i + 1];\n    BMN[i] = BMN[i + 1];\n    if (B[i] == '(') {\n      ++BS[i];\n      ++BMN[i];\n    } else {\n      --BS[i];\n      BMN[i] = min(BMN[i] - 1, -1);\n    }\n  }\n  B += B;\n  for (int i = ((int)B.size()) - 1; i >= 0; i--) {\n    OP[i] = OP[i + 1];\n    if (B[i] == '(') {\n      ++OP[i];\n    } else {\n      OP[i] = 0;\n    }\n  }\n  int rot = -1;\n  for (int i = 0; i < N;) {\n    int fsum = 0, fmin = 0;\n    if (i > 0) {\n      fsum = FS[i - 1];\n      fmin = FMN[i - 1];\n    }\n    int bsum = BS[i];\n    int bmin = BMN[i];\n    if (open > close) {\n      if (bsum + fmin < 0 || bmin < 0) {\n        ++i;\n        continue;\n      }\n    } else if (open < close) {\n      if (bsum + close - open + fmin < 0 || bmin + close - open < 0) {\n        ++i;\n        continue;\n      }\n    } else {\n      if (bsum + fmin < 0 || bmin < 0) {\n        ++i;\n        continue;\n      }\n    }\n    if (rot == -1) {\n      rot = i;\n      ++i;\n      continue;\n    }\n    if (OP[i] > OP[rot]) {\n      rot = i;\n      ++i;\n    } else if (OP[i] == OP[rot]) {\n      bool v = false;\n      for (int j = 1; rot + j < i; j++) {\n        if (OP[rot + j] < OP[i + j]) {\n          rot = i;\n          i += j;\n          v = true;\n          break;\n        } else if (OP[rot + j] > OP[i + j]) {\n          i += j;\n          v = true;\n          break;\n        }\n      }\n      if (!v) {\n        i += i - rot;\n      }\n    } else {\n      ++i;\n    }\n  }\n  if (open > close) {\n    for (int i = rot; i < N; i++) {\n      cout << B[i];\n    }\n    for (int i = 0; i < rot; i++) {\n      cout << B[i];\n    }\n    for (int i = 0; i < open - close; i++) {\n      cout << ')';\n    }\n  } else if (open < close) {\n    for (int i = 0; i < close - open; i++) {\n      cout << '(';\n    }\n    for (int i = rot; i < N; i++) {\n      cout << B[i];\n    }\n    for (int i = 0; i < rot; i++) {\n      cout << B[i];\n    }\n  } else {\n    for (int i = rot; i < N; i++) {\n      cout << B[i];\n    }\n    for (int i = 0; i < rot; i++) {\n      cout << B[i];\n    }\n  }\n  cout << '\\n';\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int L = 1000010;\nchar ch[L + L] = {};\nint len, l, m = 127;\nint u1[L + L] = {}, u2[L + L] = {}, *x = u1, *y = u2;\nint t[L + L] = {}, sa[L + L] = {}, ans[L + L] = {}, s[L + L] = {};\nbool can[L + L] = {};\nvoid init() {\n  gets(ch + 1);\n  len = strlen(ch + 1);\n  for (int i = 1; i <= len; ++i) ch[len + i] = ch[i];\n  l = len << 1;\n  ch[0] = ch[len];\n}\ninline bool cmp(int *r, int a, int b, int l) {\n  return r[a] == r[b] && r[a + l] == r[b + l];\n}\nvoid work() {\n  for (int i = 1; i <= l; ++i) ++t[x[i] = ch[i]];\n  for (int i = 1; i <= m; ++i) t[i] += t[i - 1];\n  for (int i = l; i >= 1; --i) sa[t[x[i]]--] = i;\n  for (int j = 1, p = 0; j <= l && p != l; m = p, j *= 2, p = 0) {\n    for (int i = l - j + 1; i <= l; ++i) y[++p] = i;\n    for (int i = 1; i <= l; ++i)\n      if (sa[i] > j) y[++p] = sa[i] - j;\n    for (int i = 0; i <= m; ++i) t[i] = 0;\n    for (int i = 1; i <= l; ++i) s[i] = x[y[i]];\n    for (int i = 1; i <= l; ++i) ++t[s[i]];\n    for (int i = 1; i <= m; ++i) t[i] += t[i - 1];\n    for (int i = l; i >= 1; --i) sa[t[s[i]]--] = y[i];\n    swap(x, y);\n    x[sa[1]] = 1, p = 1;\n    for (int i = 2; i <= l; ++i)\n      x[sa[i]] = cmp(y, sa[i - 1], sa[i], j) ? p : ++p;\n  }\n}\nvoid get_ans() {\n  int s1 = 0, s2 = 0;\n  for (int i = 1; i <= len; ++i) ++(ch[i] == '(' ? s1 : s2);\n  deque<int> q;\n  for (int i = l; i > len; --i) {\n    s[i] = s[i + 1] + (ch[i] == '(' ? 1 : -1);\n    while (!q.empty() && s[i] > s[q.back()]) q.pop_back();\n    q.push_back(i);\n    can[i] = false;\n  }\n  for (int i = len; i >= 1; --i) {\n    s[i] = s[i + 1] + (ch[i] == '(' ? 1 : -1);\n    can[i] = (max(s2 - s1, 0) + (s[i] - s[q.front()]) >= 0);\n    while (!q.empty() && s[i] > s[q.back()]) q.pop_back();\n    q.push_back(i);\n    while (!q.empty() && q.front() >= i + len) q.pop_front();\n  }\n  int p = 1;\n  for (int i = 1; i <= l; ++i)\n    if (can[sa[i]]) {\n      p = sa[i];\n      break;\n    }\n  while (s1 < s2) {\n    ++s1;\n    putchar('(');\n  }\n  for (int i = p; i <= p + len - 1; ++i) putchar(ch[i]);\n  while (s1 > s2) {\n    ++s2;\n    putchar(')');\n  }\n  putchar('\\n');\n}\nint main() {\n  init();\n  work();\n  get_ans();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int INF = 1e9;\nconst long long lINF = 1e18;\nconst double EPS = 1e-12;\nusing namespace std;\nconst int N = 1e6 + 100;\nchar s[N];\nint p[N], c[N], last[N];\nint pn[N], cn[N];\nint n, balance[N], mnl[N], mnr[N];\nint main() {\n  scanf(\"%s\", s);\n  n = strlen(s);\n  for (int i = 0; i < n; i++) {\n    last[s[i] - 'a' + 1]++;\n  }\n  for (int i = 2; i <= 26; i++) {\n    last[i] += last[i - 1];\n  }\n  for (int i = 0; i < n; i++) {\n    c[i] = last[s[i] - 'a'];\n  }\n  for (int i = 0; i < n; i++) {\n    p[last[s[i] - 'a']++] = i;\n  }\n  for (int l = 1; l < n; l <<= 1) {\n    for (int i = 0; i < n; i++) {\n      last[i] = i;\n    }\n    for (int i = 0; i < n; i++) {\n      pn[i] = p[i] - l;\n      if (pn[i] < 0) {\n        pn[i] += n;\n      }\n    }\n    for (int i = 0; i < n; i++) {\n      p[last[c[pn[i]]]++] = pn[i];\n    }\n    cn[p[0]] = 0;\n    int nlast = 0;\n    for (int i = 1; i < n; i++) {\n      int mid1 = (p[i] + l), mid2 = (p[i - 1] + l);\n      if (mid1 >= n) {\n        mid1 -= n;\n      }\n      if (mid2 >= n) {\n        mid2 -= n;\n      }\n      if (c[p[i]] > c[p[i - 1]] || c[mid1] > c[mid2]) {\n        nlast = i;\n      }\n      cn[p[i]] = nlast;\n    }\n    memcpy(c, cn, n * sizeof(n));\n  }\n  mnl[0] = INF;\n  for (int i = 0; i < n; i++) {\n    if (s[i] == '(') {\n      balance[i + 1] = balance[i] + 1;\n    } else {\n      balance[i + 1] = balance[i] - 1;\n    }\n    mnl[i + 1] = min(balance[i + 1], mnl[i]);\n  }\n  mnr[n - 1] = balance[n];\n  for (int i = n - 2; i >= 0; i--) {\n    mnr[i] = min(mnr[i + 1], balance[i + 1]);\n  }\n  int ans = INF, ansi = 0, good = min(0, balance[n]);\n  for (int i = 0; i < n; i++) {\n    if (mnl[i] + balance[n] - balance[i] >= good &&\n        mnr[i] - balance[i] >= good) {\n      if (ans > c[i]) {\n        ans = c[i];\n        ansi = i;\n      }\n    }\n  }\n  for (int i = 0; i < -balance[n]; i++) {\n    putchar('(');\n  }\n  for (int i = ansi; i < ansi + n; i++) {\n    putchar(s[i % n]);\n  }\n  for (int i = 0; i < balance[n]; i++) {\n    putchar(')');\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int NMAX = 1e6;\nint n;\nchar s[2 * NMAX + 5];\nint sa[NMAX + 5];\nint pos[2 * NMAX + 5];\nint pref_sum[NMAX + 5];\nint pref_min[NMAX + 5];\nint suff_min[NMAX + 5];\nint tmp[2 * NMAX + 5];\nint gap;\nbool cmp(int a, int b) {\n  if (pos[a] != pos[b]) {\n    return pos[a] < pos[b];\n  }\n  a += gap;\n  b += gap;\n  return pos[a] < pos[b];\n}\nvoid build_sa() {\n  sort(sa + 1, sa + 1 + n, [&](int a, int b) { return s[a] < s[b]; });\n  for (int i = 1; i <= n; i++) {\n    pos[sa[i]] = pos[sa[i - 1]] + (s[sa[i - 1]] != s[sa[i]]);\n    pos[sa[i] + n] = pos[sa[i]];\n  }\n  for (gap = 1; gap <= n; gap *= 2) {\n    sort(sa + 1, sa + 1 + n, cmp);\n    tmp[sa[1]] = 1;\n    for (int i = 2; i <= n; i++) {\n      tmp[sa[i]] = tmp[sa[i - 1]] + cmp(sa[i - 1], sa[i]);\n      tmp[sa[i] + n] = tmp[sa[i]];\n    }\n    for (int i = 1; i <= 2 * n; i++) {\n      pos[i] = tmp[i];\n    }\n  }\n}\nint main() {\n  fgets(s + 1, NMAX + 5, stdin);\n  n = strlen(s + 1);\n  n -= (s[n] == '\\n');\n  for (int i = n + 1; i <= 2 * n; i++) {\n    s[i] = s[i - n];\n  }\n  for (int i = 1; i <= n; i++) {\n    sa[i] = i;\n  }\n  for (int i = 1; i <= n; i++) {\n    pref_sum[i] = (s[i] == '(' ? 1 : -1) + pref_sum[i - 1];\n    pref_min[i] = pref_sum[i];\n    if (i > 1) {\n      pref_min[i] = min(pref_min[i - 1], pref_min[i]);\n    }\n  }\n  for (int i = n; i; i--) {\n    suff_min[i] = pref_sum[i];\n    if (i < n) {\n      suff_min[i] = min(suff_min[i + 1], suff_min[i]);\n    }\n  }\n  build_sa();\n  int cnt = pref_sum[n];\n  if (cnt > 0) {\n    for (int i = 1; i <= n; i++) {\n      if (suff_min[sa[i]] - pref_sum[sa[i] - 1] >= 0 &&\n          (pref_sum[n] - pref_sum[sa[i] - 1]) + pref_min[sa[i] - 1] >= 0) {\n        for (int j = sa[i]; j <= n; j++) {\n          fprintf(stdout, \"%c\", s[j]);\n        }\n        for (int j = 1; j < sa[i]; j++) {\n          fprintf(stdout, \"%c\", s[j]);\n        }\n        for (int j = 1; j <= cnt; j++) {\n          fprintf(stdout, \")\");\n        }\n        return 0;\n      }\n    }\n  } else {\n    for (int i = 1; i <= n; i++) {\n      if (suff_min[sa[i]] - pref_sum[sa[i] - 1] >= cnt &&\n          (pref_sum[n] - pref_sum[sa[i] - 1]) + pref_min[sa[i] - 1] >= cnt) {\n        for (int j = 1; j <= -cnt; j++) {\n          fprintf(stdout, \"(\");\n        }\n        for (int j = sa[i]; j <= n; j++) {\n          fprintf(stdout, \"%c\", s[j]);\n        }\n        for (int j = 1; j < sa[i]; j++) {\n          fprintf(stdout, \"%c\", s[j]);\n        }\n        return 0;\n      }\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 1000100;\nchar S[N << 1];\nbool can[N];\nvoid move(int &i, int n) {\n  while (i < n && !can[i]) {\n    i++;\n  }\n}\nint min_present(int n) {\n  int p1 = 0, p2 = 1, k = 0;\n  move(p1, n);\n  p2 += p1;\n  move(p2, n);\n  while (p1 < n && p2 < n && k < n) {\n    int n1 = p1 + k;\n    if (n1 >= n) n1 -= n;\n    int n2 = p2 + k;\n    if (n2 >= n) n2 -= n;\n    if (S[n1] < S[n2])\n      p2 += k + 1, k = 0, move(p2, n);\n    else if (S[n1] > S[n2])\n      p1 += k + 1, k = 0, move(p1, n);\n    else\n      k++;\n    if (p1 == p2) p2++, move(p1, n);\n  }\n  return std::min(p1, p2);\n}\nint sum[N << 1], min[N << 1];\nint Q[N << 1];\nint main() {\n  scanf(\"%s\", S);\n  int n = strlen(S);\n  int l = 0;\n  for (int i = 0; i < n; i++)\n    if (S[i] == '(') {\n      l++;\n      sum[i] = sum[i + n] = 1;\n    } else {\n      l--;\n      sum[i] = sum[i + n] = -1;\n    }\n  for (int i = 0; i < n; i++) S[i + n] = S[i];\n  for (int i = 1; i < n << 1; i++) sum[i] += sum[i - 1];\n  int front = 0, rear = 0;\n  for (int i = 0; i < n * 2; i++) {\n    while (front < rear && Q[front] + n - 1 < i) {\n      front++;\n    }\n    while (front < rear && sum[Q[rear - 1]] >= sum[i]) {\n      --rear;\n    }\n    Q[rear++] = i;\n    min[i - n + 1] = sum[Q[front]];\n  }\n  for (int i = 0; i < n; i++) {\n    if (i) min[i] -= sum[i - 1];\n    if (min[i] < 0 && min[i] - l < 0) continue;\n    can[i] = true;\n  }\n  int res = min_present(n);\n  if (l < 0)\n    for (int i = 0; i < -l; i++) putchar('(');\n  for (int i = res; i < res + n; i++) putchar(S[i]);\n  if (l > 0)\n    for (int i = 0; i < l; i++) putchar(')');\n  puts(\"\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nclass SA_IS {\n  vector<int> compress(vector<int>& v) {\n    set<int> alph(v.begin(), v.end());\n    vector<int> dic(alph.begin(), alph.end());\n    vector<int> bucket_size(dic.size(), 0);\n    for (int i = 0; i < v.size(); i++) {\n      v[i] = lower_bound(dic.begin(), dic.end(), v[i]) - dic.begin();\n      bucket_size[v[i]]++;\n    }\n    return bucket_size;\n  }\n  class bucket_set {\n    vector<int> container;\n    vector<vector<int>::iterator> bucket;\n    vector<int> front;\n    vector<int> back;\n    vector<bool> fixed;\n    vector<vector<bool>::iterator> bucket_fixed;\n    vector<bool> used;\n    const vector<int>& str;\n    const vector<int>& bucket_size;\n    const vector<int>& LS;\n    void put_L() {\n      for (int i = 0; i < bucket_size.size(); i++) {\n        for (int j = 0; j < bucket_size[i]; j++) {\n          if (bucket[i][j] - 1 < 0) continue;\n          if (LS[bucket[i][j] - 1] == L) {\n            if (used[bucket[i][j] - 1]) continue;\n            used[bucket[i][j] - 1] = true;\n            int c = str[bucket[i][j] - 1];\n            bucket[c][front[c]] = bucket[i][j] - 1;\n            bucket_fixed[c][front[c]] = true;\n            front[c]++;\n          }\n        }\n        back[i] = bucket_size[i] - 1;\n      }\n    }\n    void put_S() {\n      for (int i = bucket_size.size() - 1; i >= 0; i--) {\n        for (int j = bucket_size[i] - 1; j >= 0; j--) {\n          if (bucket[i][j] - 1 < 0) continue;\n          if (LS[bucket[i][j] - 1] == S) {\n            if (used[bucket[i][j] - 1]) continue;\n            used[bucket[i][j] - 1] = true;\n            int c = str[bucket[i][j] - 1];\n            bucket[c][back[c]] = bucket[i][j] - 1;\n            bucket_fixed[c][back[c]] = true;\n            back[c]--;\n          }\n        }\n      }\n    }\n    void init() {\n      int sum = 0;\n      for (int i = 0; i < bucket_size.size(); i++) {\n        bucket[i] = container.begin() + sum;\n        bucket_fixed[i] = fixed.begin() + sum;\n        front[i] = 0;\n        back[i] = bucket_size[i] - 1;\n        sum += bucket_size[i];\n      }\n    }\n\n   public:\n    bucket_set(const vector<int>& str_, const vector<int>& bucket_size_,\n               const vector<int>& LS_)\n        : container(str_.size(), -1),\n          bucket(bucket_size_.size()),\n          front(bucket_size_.size()),\n          back(bucket_size_.size()),\n          fixed(str_.size(), false),\n          bucket_fixed(bucket_size_.size()),\n          used(str_.size(), false),\n          str(str_),\n          bucket_size(bucket_size_),\n          LS(LS_) {\n      init();\n    }\n    void put_initial_LMS(const vector<int>& LMS_pos) {\n      for (int i = 0; i < LMS_pos.size() - 1; i++) {\n        int c = str[LMS_pos[i]];\n        bucket[c][back[c]] = LMS_pos[i];\n        back[c]--;\n      }\n    }\n    void put_ordered_LMS(const vector<int>& LMS_pos) {\n      for (int i = LMS_pos.size() - 2; i >= 0; i--) {\n        int c = str[LMS_pos[i]];\n        bucket[c][back[c]] = LMS_pos[i];\n        back[c]--;\n      }\n    }\n    void put() {\n      put_L();\n      for (int i = 0; i < str.size(); i++)\n        if (fixed[i] == false) container[i] = -1;\n      put_S();\n      container[0] = str.size() - 1;\n    }\n    vector<int> get_LMS_substring_order(const vector<int>& LMS) {\n      vector<int> ret;\n      for (int i = 0; i < str.size(); i++) {\n        if (LS[container[i]] != S) continue;\n        if (container[i] > 0 && LS[container[i] - 1] == L)\n          ret.push_back(container[i]);\n      }\n      return ret;\n    }\n    vector<int> get_result() { return container; }\n  };\n  struct substring {\n    int pos;\n    int size;\n    vector<int>::iterator str;\n    vector<int>::iterator ls;\n    substring() {}\n    substring(const int pos, const int size, const vector<int>::iterator& str,\n              const vector<int>::iterator& ls) {\n      this->pos = pos;\n      this->size = size;\n      this->str = str;\n      this->ls = ls;\n    }\n    bool operator==(const substring& x) const {\n      for (int i = 0; i < min(this->size, x.size); i++) {\n        if (this->str[i] != x.str[i]) {\n          return false;\n        } else if (this->ls[i] != x.ls[i]) {\n          return false;\n        }\n      }\n      return this->size == x.size;\n    }\n  };\n\n public:\n  static const int L = 0;\n  static const int S = 1;\n  string my_s;\n  vector<int> sa;\n  vector<int> lcp;\n  vector<int> rec(vector<int>& v) {\n    v.push_back(-1);\n    vector<int> bucket_size = compress(v);\n    vector<int> LS(v.size());\n    LS.back() = S;\n    for (int i = v.size() - 2; i >= 0; i--) {\n      if (v[i] < v[i + 1])\n        LS[i] = S;\n      else if (v[i] > v[i + 1])\n        LS[i] = L;\n      else\n        LS[i] = LS[i + 1];\n    }\n    bucket_set my_bucket(v, bucket_size, LS);\n    vector<int> LMS;\n    for (int i = 1; i < v.size(); i++) {\n      if (LS[i] != S) continue;\n      if (LS[i - 1] == L) LMS.push_back(i);\n    }\n    LMS.push_back(v.size() - 1);\n    vector<int> LMS_substring_order(v.size(), -1);\n    vector<int> LMS_substring_end(v.size(), -1);\n    for (int i = 0; i < LMS.size() - 1; i++) {\n      LMS_substring_order[LMS[i]] = i;\n      LMS_substring_end[LMS[i]] = LMS[i + 1];\n    }\n    if (LMS.size() > 1) {\n      bucket_set LMS_bucket(v, bucket_size, LS);\n      LMS_bucket.put_initial_LMS(LMS);\n      LMS_bucket.put();\n      vector<int> LMS_order = LMS_bucket.get_LMS_substring_order(LMS);\n      vector<int> LMS_order_cnt(LMS_order.size());\n      int cnt = 0;\n      LMS_order_cnt[0] = 0;\n      cnt++;\n      for (int i = 1; i < LMS_order.size(); i++, cnt++) {\n        substring a(LMS_order[i],\n                    LMS_substring_end[LMS_order[i]] - LMS_order[i] + 1,\n                    v.begin() + LMS_order[i], LS.begin() + LMS_order[i]);\n        substring b(LMS_order[i - 1],\n                    LMS_substring_end[LMS_order[i - 1]] - LMS_order[i - 1] + 1,\n                    v.begin() + LMS_order[i - 1],\n                    LS.begin() + LMS_order[i - 1]);\n        if (a == b) cnt--;\n        LMS_order_cnt[i] = cnt;\n      }\n      vector<int> tmp(LMS_order.size());\n      for (int i = 0; i < LMS_order.size(); i++) {\n        tmp[LMS_substring_order[LMS_order[i]]] = LMS_order_cnt[i];\n      }\n      swap(tmp, LMS_order);\n      if (cnt != LMS_order.size()) {\n        vector<int> new_order = rec(LMS_order);\n        LMS_order = vector<int>(new_order.begin() + 1, new_order.end());\n      }\n      tmp = LMS;\n      for (int i = 0; i < LMS.size() - 1; i++) {\n        tmp[i] = LMS[LMS_order[i]];\n      }\n      swap(tmp, LMS);\n      my_bucket.put_ordered_LMS(LMS);\n    }\n    my_bucket.put();\n    return my_bucket.get_result();\n  }\n  vector<int> rec(string& s) {\n    vector<int> v(s.begin(), s.end());\n    return rec(v);\n  }\n  void constract_lcp() {\n    int n = my_s.size();\n    lcp.resize(n + 1);\n    vector<int> rank(n + 1);\n    for (int i = 0; i <= n; i++) rank[sa[i]] = i;\n    int h = 0;\n    lcp[0] = 0;\n    for (int i = 0; i < n; i++) {\n      int j = sa[rank[i] - 1];\n      if (h > 0) h--;\n      for (; j + h < n && i + h < n; h++) {\n        if (my_s[j + h] != my_s[i + h]) break;\n      }\n      lcp[rank[i] - 1] = h;\n    }\n  }\n  SA_IS(string s) {\n    my_s = s;\n    sa = rec(s);\n  }\n  void dbg_print() {\n    for (int i = 0; i <= my_s.size(); i++) {\n      string p(my_s.begin() + sa[i], my_s.end());\n      cerr << p << \" \" << sa[i] << endl;\n    }\n  }\n};\nclass SegmentTreeMIN {\n  int n;\n  vector<int> T;\n  int INF;\n\n public:\n  SegmentTreeMIN(int size) {\n    INF = 1 << 29;\n    n = 1;\n    while (n < size) n <<= 1;\n    T.resize(2 * n - 1);\n    fill(T.begin(), T.end(), INF);\n  }\n  void update(int k, int val) {\n    k += n - 1;\n    T[k] = val;\n    while (k > 0) {\n      k = (k - 1) / 2;\n      T[k] = min(T[k * 2 + 1], T[k * 2 + 2]);\n    }\n  }\n  int RMQ(int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) return INF;\n    if (a <= l && r <= b)\n      return T[k];\n    else {\n      int val_left = RMQ(a, b, k * 2 + 1, l, (l + r) / 2);\n      int val_right = RMQ(a, b, k * 2 + 2, (l + r) / 2, r);\n      return min(val_left, val_right);\n    }\n  }\n  int size() { return n; }\n};\nint main() {\n  string s;\n  cin >> s;\n  int n = s.size();\n  s += s;\n  SA_IS sa(s);\n  vector<int> arr(2 * n);\n  for (int i = 0; i < 2 * n; i++) {\n    if (s[i] == '(') {\n      arr[i] = 1;\n    } else {\n      arr[i] = -1;\n    }\n    if (i > 0) arr[i] += arr[i - 1];\n  }\n  SegmentTreeMIN seg(2 * n);\n  for (int i = 0; i < 2 * n; i++) {\n    seg.update(i, arr[i]);\n  }\n  int index = -1;\n  int len = 1 << 30;\n  int xx = 0;\n  int yy = 0;\n  for (int i = 0; i < 2 * n; i++) {\n    if (sa.sa[i] > n) continue;\n    int x = min(0, seg.RMQ(sa.sa[i], sa.sa[i] + n, 0, 0, seg.size()) -\n                       (sa.sa[i] > 0 ? arr[sa.sa[i] - 1] : 0));\n    int y = max(0, arr[sa.sa[i] + n - 1] -\n                       (sa.sa[i] > 0 ? arr[sa.sa[i] - 1] : 0) + abs(x));\n    if (len > abs(x) + abs(y) + n) {\n      index = i;\n      len = abs(x) + abs(y) + n;\n      xx = abs(x);\n      yy = abs(y);\n    }\n  }\n  string ans;\n  for (int j = 0; j < xx; j++) {\n    printf(\"(\");\n  }\n  cout << s.substr(sa.sa[index], n);\n  for (int j = 0; j < yy; j++) {\n    printf(\")\");\n  }\n  printf(\"\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct num {\n  static const int MA = (int)1e9 + 7, MB = (int)1e9 + 9;\n  int a, b;\n  num() {}\n  num(int x) : a(x), b(x) {}\n  num(int _a, int _b) : a(_a), b(_b) {}\n  num operator+(const num &x) const {\n    return num((a + x.a) % MA, (b + x.b) % MB);\n  }\n  num operator-(const num &x) const {\n    return num((a + MA - x.a) % MA, (b + MB - x.b) % MB);\n  }\n  num operator*(const num &x) const {\n    return num(((long long)a * x.a) % MA, ((long long)b * x.b) % MB);\n  }\n  bool operator==(const num &x) const { return a == x.a && b == x.b; }\n  explicit operator long long() const { return (long long)a * MB + b + 1; }\n};\nstruct StrComparator {\n  static const num P;\n  static vector<num> deg;\n  int n;\n  const char *s;\n  num *h;\n  StrComparator(int n, const char *s) : n(n), s(s) {\n    h = new num[n + 1];\n    h[0] = 0;\n    for (int i = 0; i < (int)(n); i++) h[i + 1] = h[i] * P + s[i];\n    deg.reserve(n);\n    while ((int)(deg).size() <= n) deg.push_back(*deg.rbegin() * P);\n  }\n  num substr(int i, int len) const { return h[i + len] - h[i] * deg[len]; }\n  int lcp(int i, int j) {\n    int L = 0, R = n - max(i, j);\n    while (L < R) {\n      int M = (L + R + 1) / 2;\n      if (substr(i, M) == substr(j, M))\n        L = M;\n      else\n        R = M - 1;\n    }\n    return L;\n  }\n  int cmp(int a, int b) {\n    int LEN = n - max(a, b), L = lcp(a, b);\n    return L < LEN ? (int)s[a + L] - s[b + L] : b - a;\n  }\n  bool operator()(int i, int j) { return cmp(i, j) < 0; }\n};\nconst num StrComparator::P = num(239017, 17239);\nvector<num> StrComparator::deg(1, 1);\ntemplate <const int maxN>\nstruct RMQ {\n  int qst, qen, q[maxN], ind[maxN];\n  void pop(int i) {\n    if (ind[qst] == i) qst++;\n  }\n  void push(int i, int f) {\n    while (qst < qen && q[qen - 1] >= f) qen--;\n    q[qen] = f, ind[qen++] = i;\n  }\n  int get_min() { return q[qst]; }\n};\nconst int N = 1e6;\nint n, b[2 * N + 1];\nchar s[2 * N];\nRMQ<2 * N> rmq;\nint main() {\n  gets(s), n = strlen(s);\n  memcpy(s + n, s, n);\n  for (int i = 0; i < (int)(2 * n); i++)\n    b[i + 1] = b[i] + (s[i] == '(' ? 1 : -1);\n  StrComparator h(2 * n, s);\n  int ind = -1;\n  for (int i = 0; i < (int)(n); i++) rmq.push(i, b[i]);\n  for (int i = 0; i < (int)(n); i++) {\n    rmq.push(i + n, b[i + n]);\n    int mi = rmq.get_min() - b[i];\n    int diff = b[n + i] - b[i];\n    rmq.pop(i);\n    bool good = (diff - 2 * mi == abs(b[n]));\n    if (good && (ind == -1 || h.cmp(i, ind) < 0)) ind = i;\n  }\n  assert(ind != -1);\n  if (b[n] < 0) {\n    for (int i = 0; i < (int)(-b[n]); i++) putchar('(');\n    for (int i = 0; i < (int)(n); i++) putchar(s[ind + i]);\n  } else {\n    for (int i = 0; i < (int)(n); i++) putchar(s[ind + i]);\n    for (int i = 0; i < (int)(b[n]); i++) putchar(')');\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e6 + 6;\nchar s[N];\nint p1[N];\nint p2[N];\nint s1[N];\nint s2[N];\nlong long X1 = 277, X2 = 2887;\nlong long M1 = 1444444447, M2 = 1777777777;\nlong long x1[N], x2[N];\nstruct hasher {\n  vector<long long> h1, h2;\n  hasher() {}\n  string s;\n  hasher(char *str) {\n    s = str;\n    int n = s.length();\n    h1.assign(n + 1, 0);\n    h2.assign(n + 1, 0);\n    for (int i = n - 1; i >= 0; --i) {\n      h1[i] = (h1[i + 1] * X1 + s[i]) % M1;\n      h2[i] = (h2[i + 1] * X2 + s[i]) % M2;\n    }\n  }\n  long long get(int l, int r) {\n    return ((h1[l] - h1[r + 1] * x1[r - l + 1] % M1 + M1) % M1) << 32 |\n           ((h2[l] - h2[r + 1] * x2[r - l + 1] % M2 + M2) % M2);\n  }\n};\nint cmp(hasher &s1, int i1, int j1, hasher &s2, int i2, int j2) {\n  int l = 0, r = min(j1 - i1 + 1, j2 - i2 + 1) + 1;\n  while (l < r) {\n    int m = (l + r) >> 1;\n    if (s1.get(i1, i1 + m - 1) == s2.get(i2, i2 + m - 1))\n      l = m + 1;\n    else\n      r = m;\n  }\n  --l;\n  if (i1 + l > j1 && i2 + l > j2) return 0;\n  if (i1 + l > j1) return -1;\n  if (i2 + l > j2) return 1;\n  return s1.s[i1 + l] < s2.s[i2 + l] ? -1 : 1;\n}\nhasher h, ho, hz;\nint n;\nvoid calc(int i, int &il, int &ir) {\n  int op = p2[i];\n  int zp = i - p1[i] - op;\n  int zs = s2[i + 1];\n  int os = n - i - s1[i + 1] - zs;\n  il = zs;\n  ir = op;\n  if (os > zp)\n    ir += os - zp;\n  else\n    il += zp - os;\n}\nbool cmp(int i, int j, int len, int k) {\n  int il, ir, jl, jr;\n  calc(i, il, ir);\n  calc(j, jl, jr);\n  int im = len - il - ir;\n  int jm = len - jl - jr;\n  if (k < il) {\n    if (k < jl) {\n      return cmp(i, j, len, min(il, jl));\n    } else if (k < jl + jm) {\n      int d = min(il - k, jl + jm - k);\n      int dif = cmp(ho, 0, d - 1, h, j + (k - jl), j + (k - jl) + d - 1);\n      if (dif) return dif < 0;\n      return cmp(i, j, len, k + d);\n    } else {\n      return true;\n    }\n  } else if (k < il + im) {\n    if (k < jl) {\n      int d = min(jl - k, il + im - k);\n      int dif = cmp(h, i + (k - il), i + (k - il) + d - 1, ho, 0, d - 1);\n      if (dif) return dif < 0;\n      return cmp(i, j, len, k + d);\n    } else if (k < jl + jm) {\n      int d = min(il + im - k, jl + jm - k);\n      int dif = cmp(h, i + (k - il), i + (k - il) + d - 1, h, j + (k - jl),\n                    j + (k - jl) + d - 1);\n      if (dif) return dif < 0;\n      return cmp(i, j, len, k + d);\n    } else {\n      int d = min(il + im - k, len - k);\n      int dif = cmp(h, i + (k - il), i + (k - il) + d - 1, hz, 0, d - 1);\n      if (dif) return dif < 0;\n      return cmp(i, j, len, k + d);\n    }\n  } else if (k < len) {\n    if (k < jl) {\n      return false;\n    } else if (k < jl + jm) {\n      int d = min(len - k, jl + jm - k);\n      int dif = cmp(hz, 0, d - 1, h, j + (k - jl), j + (k - jl) + d - 1);\n      if (dif) return dif < 0;\n      return cmp(i, j, len, k + d);\n    } else {\n      return cmp(i, j, len, len);\n    }\n  } else\n    return false;\n}\nchar e[N];\nstring ans;\nstring func(string &s) {\n  string res;\n  int m = 0;\n  for (int i = 0; i < s.length(); ++i)\n    if (s[i] == '(') {\n      ++m;\n    } else {\n      if (!m)\n        res += \"(\";\n      else\n        --m;\n    }\n  res += s;\n  while (m--) res += \")\";\n  return res;\n}\nint main() {\n  for (int i = x1[0] = 1; i < N; ++i) x1[i] = x1[i - 1] * X1 % M1;\n  for (int i = x2[0] = 1; i < N; ++i) x2[i] = x2[i - 1] * X2 % M2;\n  gets(s + 1);\n  n = strlen(s + 1);\n  for (int i = 1; i <= n; ++i) s[i + n] = s[i];\n  for (int i = n; i; --i) {\n    if (s[i] == '(') {\n      if (s2[i + 1]) {\n        s1[i] = s1[i + 1] + 2;\n        s2[i] = s2[i + 1] - 1;\n      } else {\n        s1[i] = s1[i + 1];\n        s2[i] = s2[i + 1];\n      }\n    } else {\n      s1[i] = s1[i + 1];\n      s2[i] = s2[i + 1] + 1;\n    }\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (s[i] == ')') {\n      if (p2[i - 1]) {\n        p1[i] = p1[i - 1] + 2;\n        p2[i] = p2[i - 1] - 1;\n      } else {\n        p1[i] = p1[i - 1];\n        p2[i] = p2[i - 1];\n      }\n    } else {\n      p1[i] = p1[i - 1];\n      p2[i] = p2[i - 1] + 1;\n    }\n  }\n  int x = n * 10;\n  vector<int> pos;\n  for (int i = 0; i < n; ++i) {\n    int op = p2[i];\n    int zp = i - p1[i] - op;\n    int zs = s2[i + 1];\n    int os = n - i - s1[i + 1] - zs;\n    int len = zs + op + max(os, zp) - min(os, zp) + n;\n    if (x > len) {\n      pos.clear();\n      x = len;\n    }\n    if (x == len) {\n      pos.push_back(i);\n    }\n    int sl, sr;\n    calc(i, sl, sr);\n  }\n  h = hasher(s + 1);\n  for (int i = 0; i < n * 2; ++i) e[i] = '(';\n  ho = hasher(e);\n  for (int i = 0; i < n * 2; ++i) e[i] = ')';\n  hz = hasher(e);\n  int res = pos[0];\n  for (int k = 1; k < pos.size(); ++k)\n    if (cmp(pos[k], res, x, 0)) res = pos[k];\n  int sl, sr;\n  calc(res, sl, sr);\n  for (int i = 0; i < sl; ++i) printf(\"(\");\n  for (int i = 0; i < x - sl - sr; ++i) printf(\"%c\", s[res + i + 1]);\n  for (int i = 0; i < sr; ++i) printf(\")\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nT BigMod(T b, T p, T m) {\n  if (p == 0) return 1;\n  if (p % 2 == 0) {\n    T s = BigMod(b, p / 2, m);\n    return ((s % m) * (s % m)) % m;\n  }\n  return ((b % m) * (BigMod(b, p - 1, m) % m)) % m;\n}\ntemplate <typename T>\nT ModInv(T b, T m) {\n  return BigMod(b, m - 2, m);\n}\ntemplate <typename T>\nT in() {\n  char ch;\n  T n = 0;\n  bool ng = false;\n  while (1) {\n    ch = getchar();\n    if (ch == '-') {\n      ng = true;\n      ch = getchar();\n      break;\n    }\n    if (ch >= '0' && ch <= '9') break;\n  }\n  while (1) {\n    n = n * 10 + (ch - '0');\n    ch = getchar();\n    if (ch < '0' || ch > '9') break;\n  }\n  return (ng ? -n : n);\n}\ntemplate <typename T>\nT POW(T B, T printf) {\n  if (printf == 0) return 1;\n  if (printf & 1)\n    return B * POW(B, printf - 1);\n  else\n    return (POW(B, printf / 2) * POW(B, printf / 2));\n}\ntemplate <typename T>\nT Bigmod(T b, T p, T m) {\n  if (p == 0)\n    return 1;\n  else if (!(p & 1))\n    return (Bigmod(b, p / 2, m) * Bigmod(b, p / 2, m)) % m;\n  else\n    return ((b % m) * Bigmod(b, p - 1, m)) % m;\n}\ntemplate <typename T>\nT Dis(T x1, T y1, T x2, T y2) {\n  return sqrt((x1 - x2 * x1 - x2) + (y1 - y2 * y1 - y2));\n}\ntemplate <typename T>\nT Angle(T x1, T y1, T x2, T y2) {\n  return atan(double(y1 - y2) / double(x1 - x2));\n}\ntemplate <typename T>\nT DIFF(T a, T b) {\n  T d = a - b;\n  if (d < 0)\n    return -d;\n  else\n    return d;\n}\ntemplate <typename T>\nT ABS(T a) {\n  if (a < 0)\n    return -a;\n  else\n    return a;\n}\ntemplate <typename T>\nT gcd(T a, T b) {\n  if (a < 0) return gcd(-a, b);\n  if (b < 0) return gcd(a, -b);\n  return (b == 0) ? a : gcd(b, a % b);\n}\ntemplate <typename T>\nT lcm(T a, T b) {\n  if (a < 0) return lcm(-a, b);\n  if (b < 0) return lcm(a, -b);\n  return a * (b / gcd(a, b));\n}\ntemplate <typename T>\nT euclide(T a, T b, T &x, T &y) {\n  if (a < 0) {\n    T d = euclide(-a, b, x, y);\n    x = -x;\n    return d;\n  }\n  if (b < 0) {\n    T d = euclide(a, -b, x, y);\n    y = -y;\n    return d;\n  }\n  if (b == 0) {\n    x = 1;\n    y = 0;\n    return a;\n  } else {\n    T d = euclide(b, a % b, x, y);\n    T t = x;\n    x = y;\n    y = t - (a / b) * y;\n    return d;\n  }\n}\ntemplate <typename T>\nvoid ia(T a[], int n) {\n  for (int i = 0; i < n; i++) cin >> a[i];\n}\ntemplate <typename T>\nvoid pa(T a[], int n) {\n  for (int i = 0; i < n - 1; i++) cout << a[i] << \" \";\n  cout << a[n - 1] << endl;\n}\ntemplate <typename T>\nlong long int isLeft(T a, T b, T c) {\n  return (a.x - b.x) * (b.y - c.y) - (b.x - c.x) * (a.y - b.y);\n}\nint Set(int N, int pos) { return N = N | (1 << pos); }\nint Reset(int N, int pos) { return N = N & ~(1 << pos); }\nbool Check(int N, int pos) { return (bool)(N & (1 << pos)); }\ntemplate <class T, class first>\ninline T togglebit(T a, first i) {\n  T t = 1;\n  return (a ^ (t << i));\n}\nint toInt(string s) {\n  int sm;\n  stringstream ss(s);\n  ss >> sm;\n  return sm;\n}\nint toLlint(string s) {\n  long long int sm;\n  stringstream ss(s);\n  ss >> sm;\n  return sm;\n}\nint cdigittoint(char ch) { return ch - '0'; }\nbool isVowel(char ch) {\n  ch = toupper(ch);\n  if (ch == 'A' || ch == 'U' || ch == 'I' || ch == 'O' || ch == 'E')\n    return true;\n  return false;\n}\nbool isConst(char ch) {\n  if (isalpha(ch) && !isVowel(ch)) return true;\n  return false;\n}\ndouble DEG(double x) { return (180.0 * x) / (2.0 * acos(0.0)); }\ndouble RAD(double x) { return (x * (double)2.0 * acos(0.0)) / (180.0); }\nchar s[2097157];\nint a[2097157];\nint Tree[3 * 2097157][2];\nint New[2097157][2];\nint DP[3 * 2097157], l;\nconst int N = int(2e6) + 10;\nint cmp(int *r, int a, int b, int l) {\n  return (r[a] == r[b]) && (r[a + l] == r[b + l]);\n}\nint wa[N], wb[N], wws[N], wv[N];\nint rnk[N], height[N];\nvoid DA(int *r, int *sa, int n, int m) {\n  int i, j, p, *x = wa, *y = wb, *t;\n  for (i = 0; i < m; i++) wws[i] = 0;\n  for (i = 0; i < n; i++) wws[x[i] = r[i]]++;\n  for (i = 1; i < m; i++) wws[i] += wws[i - 1];\n  for (i = n - 1; i >= 0; i--) sa[--wws[x[i]]] = i;\n  for (j = 1, p = 1; p < n; j *= 2, m = p) {\n    for (p = 0, i = n - j; i < n; i++) y[p++] = i;\n    for (i = 0; i < n; i++)\n      if (sa[i] >= j) y[p++] = sa[i] - j;\n    for (i = 0; i < n; i++) wv[i] = x[y[i]];\n    for (i = 0; i < m; i++) wws[i] = 0;\n    for (i = 0; i < n; i++) wws[wv[i]]++;\n    for (i = 1; i < m; i++) wws[i] += wws[i - 1];\n    for (i = n - 1; i >= 0; i--) sa[--wws[wv[i]]] = y[i];\n    for (t = x, x = y, y = t, p = 1, x[sa[0]] = 0, i = 1; i < n; i++)\n      x[sa[i]] = cmp(y, sa[i - 1], sa[i], j) ? p - 1 : p++;\n  }\n}\nvoid calheight(int *r, int *sa, int n) {\n  int i, j, k = 0;\n  for (i = 1; i <= n; i++) rnk[sa[i]] = i;\n  for (i = 0; i < n; height[rnk[i++]] = k)\n    for (k ? k-- : 0, j = sa[rnk[i] - 1];\n         i + k < n && j + k < n && r[i + k] == r[j + k]; k++)\n      ;\n}\nint sa[N], data[N], n, p, q;\nvoid Level(int n) {\n  for (int i = 0;; i++)\n    if (1 << i >= n) {\n      l = i;\n      return;\n    }\n}\nvoid Build(int n) {\n  for (int i = 1; i <= n; i++) {\n    Tree[i + ((1 << l) - 1)][s[i - 1] - 'a'] = 1;\n    DP[i + ((1 << l) - 1)] = height[i];\n  }\n  for (int idx = ((1 << l) - 1); idx; idx--) {\n    int mn = min(Tree[(idx << 1)][0], Tree[((idx << 1) | 1)][1]);\n    Tree[idx][0] = Tree[(idx << 1)][0] + Tree[((idx << 1) | 1)][0] - mn;\n    Tree[idx][1] = Tree[(idx << 1)][1] + Tree[((idx << 1) | 1)][1] - mn;\n    DP[idx] = min(DP[(idx << 1)], DP[((idx << 1) | 1)]);\n  }\n}\nvoid QueryBalance(int a, int b) {\n  int id = a;\n  a += ((1 << l) - 1) + 1;\n  b += ((1 << l) - 1) + 1;\n  int L[30], R[30], p = 0, q = 0;\n  while (a <= b) {\n    if (a % 2 == 1) L[++p] = a;\n    if (b % 2 == 0) R[++q] = b;\n    a = (a + 1) >> 1;\n    b = (b - 1) >> 1;\n  }\n  for (int i = 1; i <= p; i++) {\n    int mn = min(New[id][0], Tree[L[i]][1]);\n    New[id][0] = New[id][0] + Tree[L[i]][0] - mn;\n    New[id][1] = New[id][1] + Tree[L[i]][1] - mn;\n  }\n  for (int i = q; i; i--) {\n    int mn = min(New[id][0], Tree[R[i]][1]);\n    New[id][0] = New[id][0] + Tree[R[i]][0] - mn;\n    New[id][1] = New[id][1] + Tree[R[i]][1] - mn;\n  }\n  swap(New[id][0], New[id][1]);\n}\nint QueryMin(int a, int b) {\n  if (a == b) return 1000000007;\n  a = rnk[a];\n  b = rnk[b];\n  if (a > b) swap(a, b);\n  a += ((1 << l) - 1) + 1;\n  b += ((1 << l) - 1);\n  int mn = 1000000007;\n  while (a <= b) {\n    if (a % 2 == 1) mn = min(mn, DP[a]);\n    if (b % 2 == 0) mn = min(mn, DP[b]);\n    a = (a + 1) >> 1;\n    b = (b - 1) >> 1;\n  }\n  return mn;\n}\nint main() {\n  int l = 0;\n  while (1) {\n    char x = getchar();\n    if (x != '(' && x != ')') {\n      s[l + 1] = 0;\n      break;\n    }\n    if (x == '(')\n      s[l++] = 'a';\n    else\n      s[l++] = 'b';\n    data[l - 1] = s[l - 1];\n  }\n  for (int i = 0; i < l; i++) data[i + l] = s[i + l] = s[i];\n  s[l + l + 1] = 0;\n  DA(data, sa, l + l + 1, 128);\n  calheight(data, sa, l + l);\n  Level(l + l);\n  Build(l + l);\n  for (int i = l + l - 1; i >= 0; i--)\n    if (s[i] == 'a') a[i] += a[i + 1] + 1;\n  int newAdd = (1 << 30) - 1 + (1 << 30);\n  int id;\n  for (int i = 1; i <= l; i++) {\n    QueryBalance(i, i + l - 1);\n    if (New[i][0] && New[i][1] && New[i][0] == New[i][1]) continue;\n    if (New[i][0] + New[i][1] < newAdd) {\n      newAdd = New[i][0] + New[i][1];\n      id = i;\n    } else if (New[i][0] + New[i][1] == newAdd) {\n      int open1 = New[id][0] + min(a[id], l);\n      int open2 = New[i][0] + min(a[i], l);\n      if (open1 < open2)\n        id = i;\n      else if (open1 == open2) {\n        int x = id + a[id];\n        int y = i + a[i];\n        int q = QueryMin(x, y) + a[i];\n        if (q >= l) {\n          if (New[id][1] > New[i][1]) {\n            id = i;\n          }\n        } else {\n          x = rnk[id];\n          y = rnk[i];\n          if (x > y) id = i;\n        }\n      }\n    }\n  }\n  for (int i = 0; i < New[id][0]; i++) putchar('(');\n  for (int i = id; i < id + l; i++)\n    if (s[i] == 'a')\n      putchar('(');\n    else\n      putchar(')');\n  for (int i = 0; i < New[id][1]; i++) putchar(')');\n  printf(\"\\n\");\n  ;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 6000005;\nint s[maxn];\nint sa[maxn], t1[maxn], t2[maxn], c[maxn], n;\nint sum[maxn];\nint low[maxn];\nint deq[maxn];\nvoid build_sa(int *s, int n, int m) {\n  int i, k, p, a1, a2, *x = t1, *y = t2;\n  memset(c, 0, m << 2);\n  for (i = 0; i < n; ++i) ++c[x[i] = s[i]];\n  for (i = 1; i < m; ++i) c[i] += c[i - 1];\n  for (i = n - 1; i >= 0; --i) sa[--c[x[i]]] = i;\n  for (k = 1; k < n; k <<= 1) {\n    p = 0;\n    for (i = 0; i < n; ++i) y[p++] = (sa[i] + n - k) % n;\n    memset(c, 0, m << 2);\n    for (i = 0; i < n; ++i) ++c[x[y[i]]];\n    for (i = 1; i < m; ++i) c[i] += c[i - 1];\n    for (i = n - 1; i >= 0; --i) sa[--c[x[y[i]]]] = y[i];\n    swap(x, y), p = 1, x[sa[0]] = 0;\n    for (i = 1; i < n; ++i) {\n      a1 = y[(sa[i - 1] + k) % n];\n      a2 = y[(sa[i] + k) % n];\n      x[sa[i]] = (a1 == a2 && y[sa[i - 1]] == y[sa[i]]) ? p - 1 : p++;\n    }\n    if (p >= n) break;\n    m = p;\n  }\n}\nchar res[maxn], tot;\nint main() {\n  char c;\n  while (c = getchar(), ~c && c != '\\n') s[n++] = (c == '(' ? 1 : 2);\n  for (int i = n; i < n + n; i++) s[i] = s[i - n];\n  int m = n;\n  build_sa(s, m, 3);\n  n <<= 1;\n  sum[0] = (s[0] == 1 ? 1 : -1);\n  for (int i = 1; i < n; i++) sum[i] = sum[i - 1] + (s[i] == 1 ? 1 : -1);\n  int pos = 0;\n  int st = 0, ed = 0;\n  for (int i = 0; i < n; i++) {\n    while (st < ed && deq[st] <= i - m) st++;\n    while (st < ed && sum[i] <= sum[deq[ed - 1]]) ed--;\n    deq[ed++] = i;\n    if (i >= m - 1) low[i - m - 1] = sum[deq[st]];\n  }\n  if (sum[m - 1] >= 0) {\n    for (int i = 0; i < m; i++) {\n      if (sa[i] >= m) continue;\n      if (sa[i] && low[sa[i]] - sum[sa[i] - 1] >= 0) {\n        pos = sa[i];\n        break;\n      }\n      if (!sa[i] && low[sa[i]] >= 0) {\n        pos = sa[i];\n        break;\n      }\n    }\n  } else {\n    for (int i = 0; i < m; i++) {\n      if (sa[i] >= m) continue;\n      if (sa[i] && low[sa[i]] - sum[sa[i] - 1] - sum[m - 1] >= 0) {\n        pos = sa[i];\n        break;\n      }\n      if (!sa[i] && low[sa[i]] - sum[m - 1] >= 0) {\n        pos = sa[i];\n        break;\n      }\n    }\n  }\n  if (sum[m - 1] < 0) {\n    for (int i = 0; i < -sum[m - 1]; i++) putchar('(');\n  }\n  for (int i = 0; i < m; i++) {\n    if (s[pos + i] == 1)\n      putchar('(');\n    else\n      putchar(')');\n  }\n  if (sum[m - 1] > 0) {\n    for (int i = 0; i < sum[m - 1]; i++) putchar(')');\n  }\n  puts(\"\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nlong long powmod(long long a, long long b) {\n  long long res = 1;\n  a %= 1000000007;\n  for (; b; b >>= 1) {\n    if (b & 1) res = res * a % 1000000007;\n    a = a * a % 1000000007;\n  }\n  return res;\n}\nlong long gcd(long long x, long long y) {\n  while (y) {\n    long long t = x % y;\n    x = y;\n    y = t;\n  }\n  return x;\n}\nlong long inv(long long x) { return powmod(x, 1000000007 - 2); }\ntemplate <typename T>\ninline bool chkmin(T &a, const T &b) {\n  return a > b ? a = b, 1 : 0;\n}\ntemplate <typename T>\ninline bool chkmax(T &a, const T &b) {\n  return a < b ? a = b, 1 : 0;\n}\nint read() {\n  int x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') {\n    x = x * 10 + ch - '0';\n    ch = getchar();\n  }\n  return x * f;\n}\nint wa[4001000], wb[4001000], wx[4001000], wv[4001000];\nint cmp(int *r, int a, int b, int l) {\n  return r[a + l] == r[b + l] && r[a] == r[b];\n}\nvoid da(char *r, int *sa, int n, int m) {\n  int *x = wa, *y = wb, *t;\n  int i, j, k, p;\n  for (i = 0; i < m; ++i) wx[i] = 0;\n  for (i = 0; i < n; ++i) ++wx[x[i] = r[i]];\n  for (i = 1; i < m; ++i) wx[i] += wx[i - 1];\n  for (i = n - 1; i >= 0; --i) sa[--wx[x[i]]] = i;\n  for (j = 1, p = 1; p < n; j *= 2, m = p) {\n    for (p = 0, i = n - j; i < n; ++i) y[p++] = i;\n    for (i = 0; i < n; ++i)\n      if (sa[i] >= j) y[p++] = sa[i] - j;\n    for (i = 0; i < n; ++i) wv[i] = x[y[i]];\n    for (i = 0; i < m; ++i) wx[i] = 0;\n    for (i = 0; i < n; ++i) ++wx[wv[i]];\n    for (i = 1; i < m; ++i) wx[i] += wx[i - 1];\n    for (i = n - 1; i >= 0; --i) sa[--wx[wv[i]]] = y[i];\n    for (t = x, x = y, y = t, p = 1, x[sa[0]] = 0, i = 1; i < n; ++i)\n      x[sa[i]] = cmp(y, sa[i - 1], sa[i], j) ? p - 1 : p++;\n  }\n}\nint Rank[4001000], sa[4001000], height[4001000];\nvoid calheight(char *r, int n) {\n  int i, j, k = 0;\n  for (i = 0; i <= n; ++i) Rank[sa[i]] = i;\n  for (i = 0; i < n; height[Rank[i++]] = k)\n    for (k ? k-- : 0, j = sa[Rank[i] - 1]; r[i + k] == r[j + k]; k++)\n      ;\n}\nchar s[4001000];\nchar ans[4001000];\nbool can[4001000];\nvoid fckn(int x, int n) {\n  deque<pair<int, int> > q;\n  int tag = 0, cnt = 0;\n  for (int i = 0; i < n; i++) {\n    if (s[i] == 0)\n      cnt++;\n    else\n      cnt--;\n    while (q.size() && q.back().second >= cnt) q.pop_back();\n    q.push_back(make_pair(i, cnt));\n  }\n  for (int i = 0; i < n; i++) {\n    while (q.size() && q.front().first < i) {\n      q.pop_front();\n    }\n    if (q.front().second - tag >= x) can[i] = true;\n    if (s[i] == 0)\n      tag++;\n    else\n      tag--;\n    while (q.size() && q.back().second >= cnt + tag) q.pop_back();\n    q.push_back(make_pair(i + n, cnt + tag));\n  }\n}\nint main() {\n  scanf(\"%s\", s);\n  int n = strlen(s);\n  int cnt = 0;\n  for (int i = 0; i < n; i++) {\n    if (s[i] == '(')\n      cnt++, s[i] = 0;\n    else\n      cnt--, s[i] = 1;\n    s[i + n] = s[i];\n  }\n  fckn(min(0, cnt), n);\n  s[2 * n] = 2;\n  da(s, sa, 2 * n + 1, 3);\n  int i = 0, top = 0;\n  for (; sa[i] >= n || !can[sa[i]]; i++)\n    ;\n  i = sa[i];\n  while (cnt < 0) {\n    ans[top++] = '(';\n    cnt++;\n  }\n  for (int j = 0; j < n; j++) ans[top++] = s[i + j] == 0 ? '(' : ')';\n  while (cnt > 0) {\n    ans[top++] = ')';\n    cnt--;\n  }\n  ans[top++] = '\\0';\n  puts(ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2000050;\nconst int M = 2 * N;\nint tot;\nchar s[M];\nint id[M], sa[M];\npair<pair<int, int>, int> tmp[M];\nvoid BuildSuffixArray() {\n  s[++tot] = '(' + 2;\n  int i, j;\n  for (i = 1; i <= tot; i++) id[i] = s[i] - '(' + 1;\n  for (j = 0; j < 20; j++) {\n    for (i = 1; i <= tot; i++)\n      tmp[i] = make_pair(make_pair(id[i], id[i + (1 << j)]), i);\n    sort(tmp + 1, tmp + 1 + tot);\n    int c = 0;\n    for (i = 1; i <= tot; i++) {\n      id[tmp[i].second] = c + 1;\n      c += tmp[i].first != tmp[i + 1].first;\n    }\n    if (c == tot) break;\n  }\n  for (i = 1; i <= tot; i++) sa[id[i]] = i;\n}\nint p[N], m[N];\nint main() {\n  int n, i;\n  scanf(\"%s\", s + 1);\n  n = strlen(s + 1);\n  for (i = 1; i <= n; i++) s[i + n] = s[i];\n  tot = n * 2;\n  BuildSuffixArray();\n  for (i = 1; i <= n; i++) {\n    p[i] = p[i - 1];\n    if (s[i] == '(')\n      p[i]++;\n    else\n      p[i]--;\n  }\n  m[n] = p[n];\n  for (i = n - 1; i >= 1; i--) {\n    m[i] = min(m[i + 1], p[i]);\n  }\n  int sol = M, mn = M;\n  int add = 0;\n  if (p[n] < 0) add = -p[n];\n  for (i = 1; i <= n; i++) {\n    if (mn - p[i - 1] + p[n] + add >= 0 && m[i] - p[i - 1] + add >= 0) {\n      sol = min(sol, id[i]);\n    }\n    mn = min(mn, p[i]);\n  }\n  if (p[n] < 0)\n    for (i = 0; i < -p[n]; i++) printf(\"(\");\n  for (i = sa[sol]; i < n + sa[sol]; i++) printf(\"%c\", s[i]);\n  if (p[n] > 0)\n    for (i = 0; i < p[n]; i++) printf(\")\");\n  printf(\"\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1000005;\nint N;\nchar S[2 * MAXN];\nint ord[2 * MAXN];\npair<pair<int, int>, int> E[2 * MAXN];\nint step = 1;\nint pre[MAXN];\nint minp[MAXN];\nint mins[MAXN];\nchar ans[MAXN];\nvoid build() {\n  for (int i = 0; i < N; i++) ord[i] = (S[i] == ')');\n  for (int jump = 1; jump < N; step++, jump *= 2) {\n    for (int i = 0; i < N; i++)\n      E[i] = make_pair(\n          pair<int, int>(ord[i], (i + jump < N) ? ord[i + jump] : N), i);\n    sort(E, E + N);\n    int ind = -1;\n    pair<int, int> prev(-1, -1);\n    for (int i = 0; i < N; i++) {\n      int idx = E[i].second;\n      pair<int, int> cur = E[i].first;\n      if (cur != prev) {\n        ind++;\n        prev = cur;\n      }\n      ord[idx] = ind;\n    }\n  }\n}\nint main() {\n  scanf(\"%s\", &S);\n  N = (int)(strlen(S));\n  memcpy(S + N, S, N);\n  N += N;\n  S[N] = '|';\n  S[N + 1] = 0;\n  build();\n  N /= 2;\n  for (int i = 1; i <= N; i++)\n    pre[i] = pre[i - 1] + ((S[i - 1] == '(') ? 1 : -1);\n  minp[0] = pre[0] + pre[N];\n  for (int i = 1; i < N; i++) minp[i] = min(minp[i - 1], pre[i] + pre[N]);\n  mins[N - 1] = pre[N - 1];\n  for (int i = N - 2; i >= 0; i--) mins[i] = min(mins[i + 1], pre[i]);\n  int best = -1, x = min(0, pre[N]);\n  for (int i = 0; i < N; i++)\n    if (min(minp[i], mins[i]) - pre[i] >= x)\n      if (best == -1 || ord[i] < ord[best]) best = i;\n  int ind = 0;\n  for (int i = 0; i < -pre[N]; i++) ans[ind++] = '(';\n  for (int i = 0; i < N; i++) ans[ind++] = S[best + i];\n  for (int i = 0; i < pre[N]; i++) ans[ind++] = ')';\n  ans[ind] = 0;\n  printf(\"%s\\n\", ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1010101;\nnamespace SA {\nconst static int N = ::N << 1;\nint sa[N], rk[N], ht[N], s[N << 1], t[N << 1], p[N], cnt[N], cur[N];\nvoid sais(int n, int m, int *s, int *t, int *p) {\n  int n1 = t[n - 1] = 0, ch = rk[0] = -1, *s1 = s + n;\n  for (int i = n - 2; ~i; i--)\n    t[i] = s[i] == s[i + 1] ? t[i + 1] : s[i] > s[i + 1];\n  for (int i = 1; i < n; i++)\n    rk[i] = t[i - 1] && !t[i] ? (p[n1] = i, n1++) : -1;\n  std::fill_n(sa, n, -1);\n  std::fill_n(cnt, m, 0);\n  for (int i = 0; i < n; i++) cnt[s[i]]++;\n  for (int i = 1; i < m; i++) cnt[i] += cnt[i - 1];\n  for (int i = 0; i < m; i++) cur[i] = cnt[i] - 1;\n  for (int i = n1 - 1; ~i; i--) sa[cur[s[p[i]]]--] = p[i];\n  for (int i = 1; i < m; i++) cur[i] = cnt[i - 1];\n  for (int i = 0; i < n; i++)\n    if (sa[i] > 0 && t[sa[i] - 1]) sa[cur[s[sa[i] - 1]]++] = sa[i] - 1;\n  for (int i = 0; i < m; i++) cur[i] = cnt[i] - 1;\n  for (int i = n - 1; ~i; i--)\n    if (sa[i] > 0 && !t[sa[i] - 1]) sa[cur[s[sa[i] - 1]]--] = sa[i] - 1;\n  for (int i = 0, x, y; i < n; i++)\n    if (~(x = rk[sa[i]])) {\n      if (ch < 1 || p[x + 1] - p[x] != p[y + 1] - p[y])\n        ch++;\n      else\n        for (int j = p[x], k = p[y]; j <= p[x + 1]; j++, k++)\n          if ((s[j] << 1 | t[j]) != (s[k] << 1 | t[k])) {\n            ch++;\n            break;\n          }\n      s1[y = x] = ch;\n    }\n  if (ch + 1 < n1)\n    sais(n1, ch + 1, s1, t + n, p + n1);\n  else\n    for (int i = 0; i < n1; i++) sa[s1[i]] = i;\n  for (int i = 0; i < n1; i++) s1[i] = p[sa[i]];\n  std::fill_n(sa, n, -1);\n  std::fill_n(cnt, m, 0);\n  for (int i = 0; i < n; i++) cnt[s[i]]++;\n  for (int i = 1; i < m; i++) cnt[i] += cnt[i - 1];\n  for (int i = 0; i < m; i++) cur[i] = cnt[i] - 1;\n  for (int i = n1 - 1; ~i; i--) sa[cur[s[s1[i]]]--] = s1[i];\n  for (int i = 1; i < m; i++) cur[i] = cnt[i - 1];\n  for (int i = 0; i < n; i++)\n    if (sa[i] > 0 && t[sa[i] - 1]) sa[cur[s[sa[i] - 1]]++] = sa[i] - 1;\n  for (int i = 0; i < m; i++) cur[i] = cnt[i] - 1;\n  for (int i = n - 1; ~i; i--)\n    if (sa[i] > 0 && !t[sa[i] - 1]) sa[cur[s[sa[i] - 1]]--] = sa[i] - 1;\n}\ntemplate <typename T>\nint mapCharToInt(int n, const T *str) {\n  int m = *max_element(str, str + n);\n  std::fill_n(rk, m + 1, 0);\n  for (int i = 0; i < n; i++) rk[str[i]] = 1;\n  for (int i = 0; i < m; i++) rk[i + 1] += rk[i];\n  for (int i = 0; i < n; i++) s[i] = rk[str[i]] - 1;\n  return rk[m];\n}\ntemplate <typename T>\nvoid suffixArray(int n, const T *str) {\n  int m = mapCharToInt(++n, str);\n  sais(n, m, s, t, p);\n  for (int i = 0; i < n; i++) rk[sa[i]] = i;\n  for (int i = 0, h = ht[0] = 0; i < n - 1; i++) {\n    int j = sa[rk[i] - 1];\n    while (i + h < n && j + h < n && s[i + h] == s[j + h]) h++;\n    if (ht[rk[i]] = h) h--;\n  }\n}\n};  // namespace SA\nstring s;\nint n, ans;\nint cnt[2], pre[N], mpre[N], msuf[N], in[N << 1];\nvoid solve() {\n  int add = (cnt[0] < cnt[1]) ? (cnt[1] - cnt[0]) : 0;\n  for (int _ = (1); _ < (n << 1 | 1); _++) {\n    int i = SA::sa[_];\n    if (i >= n) continue;\n    ++i;\n    int t = min(msuf[i] - pre[i - 1], mpre[i - 1] + pre[n] - pre[i - 1]) + add;\n    if (t >= 0) {\n      ans = i;\n      return;\n    }\n  }\n}\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n  cin >> s;\n  n = (int)s.size();\n  s = \" \" + s;\n  for (int i = (1); i < (n + 1); i++) {\n    ++cnt[s[i] == ')'];\n    int t = (s[i] == '(') ? 1 : -1;\n    pre[i] = pre[i - 1] + t;\n  }\n  mpre[1] = pre[1];\n  for (int i = (2); i < (n + 1); i++) mpre[i] = min(mpre[i - 1], pre[i]);\n  msuf[n] = pre[n];\n  for (int i = n - 1; i; --i) msuf[i] = min(msuf[i + 1], pre[i]);\n  for (int i = (1); i < (n + 1); i++) in[i - 1] = (s[i] == ')') + 1;\n  for (int i = (1); i < (n + 1); i++) in[n + i - 1] = (s[i] == ')') + 1;\n  in[n << 1] = 0;\n  SA::suffixArray<int>(n << 1, in);\n  solve();\n  while (cnt[0] < cnt[1]) cout << \"(\", ++cnt[0];\n  for (int i = (ans); i < (n + 1); i++) cout << s[i];\n  for (int i = (1); i < (ans); i++) cout << s[i];\n  while (cnt[0] > cnt[1]) cout << \")\", ++cnt[1];\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:1024000000,1024000000\")\nusing namespace std;\nint n1, w[2000010], wa[2000010], wb[2000010], sa[2000010], s[2000010],\n    f[2000010], q[2000010];\nchar st[2000010];\nbool cmp(int i, int j, int h, int *r) {\n  if (r[i] < r[j]) return 1;\n  if (i + h >= n1) return 1;\n  return r[i + h] < r[j + h];\n}\nvoid suffix(char *s) {\n  n1 = strlen(s);\n  int i, j, p, m = 128, *first = wa, *second = wb;\n  for (i = 0; i < m; i++) w[i] = 0;\n  for (i = 0; i < n1; i++) w[first[i] = s[i]]++;\n  for (i = 1; i < m; i++) w[i] += w[i - 1];\n  for (i = n1 - 1; i >= 0; i--) sa[--w[first[i]]] = i;\n  for (j = 1, p = 0; p != n1; j <<= 1, m = p) {\n    for (i = n1 - j, p = 0; i < n1; i++) second[p++] = i;\n    for (i = 0; i < n1; i++)\n      if (sa[i] >= j) second[p++] = sa[i] - j;\n    for (i = 0; i < m; i++) w[i] = 0;\n    for (i = 0; i < n1; i++) w[first[i]]++;\n    for (i = 1; i < m; i++) w[i] += w[i - 1];\n    for (i = n1 - 1; i >= 0; i--) sa[--w[first[second[i]]]] = second[i];\n    swap(first, second);\n    for (i = 1, first[sa[0]] = 0, p = 1; i < n1; i++) {\n      first[sa[i]] = cmp(sa[i - 1], sa[i], j, second) ? p++ : p - 1;\n    }\n  }\n}\nint main() {\n  int T, i, j, k, ca = 0, m, n;\n  scanf(\"%s\", st);\n  n = strlen(st);\n  for (i = 0; i < n; i++) st[i + n] = st[i];\n  st[n + n] = 0;\n  for (i = 0; i < n + n; i++) s[i + 1] = s[i] + (st[i] == '(' ? 1 : -1);\n  suffix(st);\n  int head = 0, tail = -1;\n  for (i = 1; i <= n + n; i++) {\n    while (head <= tail && q[head] < i - n + 1) head++;\n    while (head <= tail && s[i] <= s[q[tail]]) tail--;\n    q[++tail] = i;\n    if (i >= n) f[i - n] = s[q[head]];\n  }\n  k = min(s[n], 0);\n  for (i = 0; i < n + n; i++) {\n    j = sa[i];\n    if (j >= n) continue;\n    if (f[j] - s[j] >= k) break;\n  }\n  for (i = 0; i < -s[n]; i++) printf(\"(\");\n  for (i = j; i < j + n; i++) printf(\"%c\", st[i]);\n  for (i = 0; i < s[n]; i++) printf(\")\");\n  puts(\"\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 3;\nconst int M = 4e6 + 3;\nconst int ym = 2e6;\nconst int oo = 1e9;\nconst int OS = 317;\nconst int MOD = 1e9 + 7;\nchar s[N];\nint n, stp[M], p1[N], p2[N], s1[N], s2[N], ho[N], hz[N], h[N], op[N], zp[N],\n    os[N], zs[N], il[N], ir[N];\nvector<int> st;\nint get(int i, int ln) {\n  int ans, lt, l;\n  lt = min(il[i], ln);\n  ans = (stp[ym] * 1LL * ho[lt]) % MOD;\n  l = lt;\n  lt = max(0, min(n - i, ln - l));\n  ans =\n      (ans +\n       (((h[i + lt] - h[i]) % MOD + MOD) % MOD * 1LL * stp[ym + l - i]) % MOD) %\n      MOD;\n  l += lt;\n  lt = max(0, min(i, ln - l));\n  ans = (ans + h[lt] * 1LL * stp[ym + l] % MOD) % MOD;\n  l += lt;\n  lt = max(0, ln - l);\n  ans = (ans + hz[lt] * 1LL * stp[ym + l] % MOD) % MOD;\n  return ans;\n}\nint get_ch(int i, int ln) {\n  if (ln <= il[i]) return '(';\n  ln -= il[i];\n  if (ln <= n - i) return s[i + ln];\n  ln -= n - i;\n  if (ln <= i)\n    return s[ln];\n  else\n    return ')';\n}\nint ans;\nbool cmp(int i, int j) {\n  int l, r, x;\n  l = 1, r = ans;\n  while (l <= r) {\n    x = (l + r) >> 1;\n    if (get(i, x) == get(j, x))\n      l = x + 1;\n    else\n      r = x - 1;\n  }\n  if (r + 1 > ans) return true;\n  return get_ch(i, r + 1) <= get_ch(j, r + 1);\n}\nint main() {\n  if (0) {\n    freopen(\"input.txt\", \"w\", stdout);\n    int n = 1e6;\n    for (int i = 0; i < n; ++i) printf(\"(\");\n    printf(\"\\n\");\n    return 0;\n  }\n  int i, j, len, mn;\n  gets(s + 1);\n  n = strlen(s + 1);\n  for (i = 1; i <= n; ++i)\n    if (s[i] == '(')\n      p1[i] = p1[i - 1], p2[i] = p2[i - 1] + 1;\n    else if (p2[i - 1])\n      p1[i] = p1[i - 1] + 2, p2[i] = p2[i - 1] - 1;\n    else\n      p1[i] = p1[i - 1], p2[i] = p2[i - 1];\n  for (i = n; i; --i)\n    if (s[i] == ')')\n      s1[i] = s1[i + 1], s2[i] = s2[i + 1] + 1;\n    else if (s2[i + 1])\n      s1[i] = s1[i + 1] + 2, s2[i] = s2[i + 1] - 1;\n    else\n      s1[i] = s1[i + 1], s2[i] = s2[i + 1];\n  for (i = 0; i <= n; ++i) {\n    op[i] = p2[i];\n    zp[i] = i - p1[i] - op[i];\n    zs[i] = s2[i + 1];\n    os[i] = n - i - s1[i + 1] - zs[i];\n    il[i] = zs[i];\n    ir[i] = op[i];\n    if (os[i] > zp[i])\n      ir[i] += os[i] - zp[i];\n    else\n      il[i] += zp[i] - os[i];\n  }\n  ans = oo;\n  for (i = 0; i < n; ++i) {\n    len = n + zs[i] + op[i] + max(os[i], zp[i]) - min(os[i], zp[i]);\n    if (ans > len) st.clear();\n    if (ans >= len) ans = len, st.push_back(i);\n  }\n  stp[0] = 1;\n  for (i = 1; i < M; ++i) stp[i] = (stp[i - 1] * 1LL * OS) % MOD;\n  ho[0] = hz[0] = 0;\n  for (i = 1; i < N; ++i)\n    ho[i] = (ho[i - 1] + '(' * 1LL * stp[i - 1] % MOD) % MOD;\n  for (i = 1; i < N; ++i)\n    hz[i] = (hz[i - 1] + ')' * 1LL * stp[i - 1] % MOD) % MOD;\n  h[0] = 0;\n  for (i = 1; i <= n; ++i)\n    h[i] = (h[i - 1] + s[i] * 1LL * stp[i - 1] % MOD) % MOD;\n  mn = st[0];\n  for (i = 1; i < st.size(); ++i)\n    if (cmp(st[i], mn)) mn = st[i];\n  i = mn;\n  for (j = 0; j < il[i]; ++j) putchar('(');\n  for (j = i + 1; j <= n; ++j) putchar(s[j]);\n  for (j = 1; j <= i; ++j) putchar(s[j]);\n  for (j = 0; j < ir[i]; ++j) putchar(')');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2000005, ha = 1e9 + 9;\ninline int Get(char x) { return x == '(' ? 1 : -1; }\ninline int add(int x, int y) {\n  x += y;\n  return x >= ha ? x - ha : x;\n}\nint n, q[maxn], hd, tl, a[maxn], tot, p, N;\nint c[maxn], h[maxn];\nchar s[maxn];\ninline int gethash(int x, int len) {\n  return add(h[x + len - 1], ha - h[x - 1] * (long long)c[len] % ha);\n}\ninline bool cmp(int x, int y) {\n  int l = 0, r = n, mid, an = 0;\n  while (l <= r) {\n    mid = l + r >> 1;\n    if (gethash(x, mid) == gethash(y, mid))\n      an = mid, l = mid + 1;\n    else\n      r = mid - 1;\n  }\n  return an == n ? 1 : s[x + an] == '(';\n}\ninline void update(int x) {\n  if (!p || cmp(x, p)) p = x;\n}\ninline void solve1() {\n  c[0] = 1;\n  for (int i = 1; i <= N; i++) {\n    a[i] = a[i - 1] + Get(s[i]);\n    c[i] = add(c[i - 1], add(c[i - 1], c[i - 1]));\n    h[i] = add(add(h[i - 1], add(h[i - 1], h[i - 1])), (s[i] == '(' ? 1 : 2));\n  }\n  hd = 1, tl = 0;\n  for (int i = 1; i < N; i++) {\n    while (hd <= tl && a[i] <= a[q[tl]]) tl--;\n    q[++tl] = i;\n    while (hd <= tl && q[hd] + n <= i) hd++;\n    if (i >= n && a[q[hd]] >= a[i - n]) update(i - n + 1);\n  }\n  for (int i = 0; i < n; i++) putchar(s[p + i]);\n  for (int i = 1; i <= tot; i++) putchar(')');\n}\ninline void solve2() {\n  c[0] = 1;\n  for (int i = 1; i <= N; i++) {\n    c[i] = add(c[i - 1], add(c[i - 1], c[i - 1]));\n    h[i] = add(add(h[i - 1], add(h[i - 1], h[i - 1])), (s[i] == '(' ? 1 : 2));\n  }\n  for (int i = N; i; i--) a[i] = a[i + 1] - Get(s[i]);\n  hd = 1, tl = 0;\n  for (int i = N - 1; i; i--) {\n    while (hd <= tl && a[i] <= a[q[tl]]) tl--;\n    q[++tl] = i;\n    while (hd <= tl && q[hd] - n >= i) hd++;\n    if (i <= n && a[q[hd]] >= a[i + n]) update(i);\n  }\n  for (int i = tot; i < 0; i++) putchar('(');\n  for (int i = 0; i < n; i++) putchar(s[p + i]);\n}\nint main() {\n  scanf(\"%s\", s + 1), n = strlen(s + 1), N = n << 1;\n  for (int i = 1; i <= n; i++) s[i + n] = s[i], tot += Get(s[i]);\n  if (tot >= 0)\n    solve1();\n  else\n    solve2();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace ::std;\nconst int N = 1000000;\nint n, en, st = 2140000000, now;\nint a[N + 5];\nint max_close[N + 5];\nlong long ord[N + 5];\npair<long long, int> num[N + 5];\nvoid init() {\n  char in[N + 5];\n  scanf(\"%s\", in);\n  n = strlen(in);\n  int sum = 0;\n  for (int i = 1; i <= n; i++) {\n    a[i] = in[i - 1] == '(' ? -1 : 1;\n    en -= a[i];\n    sum += a[i];\n    max_close[i] = max(max_close[i - 1], sum);\n  }\n  en = max(0, en);\n}\nvoid get_ord() {\n  int m = 0, p = 0;\n  while (p <= n * 2) {\n    m = 0;\n    for (int i = 1; i <= n; i++) {\n      if (p == 0)\n        num[i].first = a[i];\n      else\n        num[i].first = ord[i] * (n + 1) + ord[(i - 1 + p) % n + 1];\n      num[i].second = i;\n    }\n    sort(num + 1, num + n + 1);\n    for (int i = 1; i <= n; i++) {\n      if (i != 0 && num[i].first != num[i - 1].first) m++;\n      ord[num[i].second] = m;\n    }\n    if (p == 0)\n      p = 1;\n    else\n      p <<= 1;\n  }\n}\nint main() {\n  init();\n  get_ord();\n  st = max_close[n];\n  now = 1;\n  int cnt = 0, mc = 0;\n  for (int i = n; i > 1; i--) {\n    cnt += a[i];\n    mc = max(a[i], mc + a[i]);\n    int new_st = max(max(0, mc), cnt + max_close[i - 1]);\n    if (st > new_st || (st == new_st && ord[now] > ord[i])) {\n      st = new_st;\n      now = i;\n    }\n  }\n  for (int i = 0; i < st; i++) printf(\"(\");\n  for (int i = now; i <= n; i++) {\n    if (a[i] == -1)\n      printf(\"(\");\n    else\n      printf(\")\");\n  }\n  for (int i = 1; i < now; i++) {\n    if (a[i] == -1)\n      printf(\"(\");\n    else\n      printf(\")\");\n  }\n  for (int i = 0; i < en; i++) printf(\")\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e6 + 6;\nchar s[N];\nint p1[N];\nint p2[N];\nint s1[N];\nint s2[N];\nlong long X1 = 277, X2 = 2887;\nlong long M1 = 1444444447, M2 = 1777777777;\nlong long x1[N], x2[N];\nstruct hasher {\n  vector<long long> h1, h2;\n  hasher() {}\n  string s;\n  hasher(char *str) {\n    s = str;\n    int n = s.length();\n    h1.assign(n + 1, 0);\n    for (int i = n - 1; i >= 0; --i) {\n      h1[i] = (h1[i + 1] * X1 + s[i]) % M1;\n    }\n  }\n  long long get(int l, int r) {\n    return ((h1[l] - h1[r + 1] * x1[r - l + 1] % M1 + M1) % M1);\n  }\n};\nint cmp(hasher &s1, int i1, int j1, hasher &s2, int i2, int j2) {\n  int l = 0, r = min(j1 - i1 + 1, j2 - i2 + 1) + 1;\n  while (l < r) {\n    int m = (l + r) >> 1;\n    if (s1.get(i1, i1 + m - 1) == s2.get(i2, i2 + m - 1))\n      l = m + 1;\n    else\n      r = m;\n  }\n  --l;\n  if (i1 + l > j1 && i2 + l > j2) return 0;\n  if (i1 + l > j1) return -1;\n  if (i2 + l > j2) return 1;\n  return s1.s[i1 + l] < s2.s[i2 + l] ? -1 : 1;\n}\nhasher h, ho, hz;\nint n;\nvoid calc(int i, int &il, int &ir) {\n  int op = p2[i];\n  int zp = i - p1[i] - op;\n  int zs = s2[i + 1];\n  int os = n - i - s1[i + 1] - zs;\n  il = zs;\n  ir = op;\n  if (os > zp)\n    ir += os - zp;\n  else\n    il += zp - os;\n}\nbool cmp(int i, int j, int len) {\n  int il, ir, jl, jr;\n  calc(i, il, ir);\n  calc(j, jl, jr);\n  int im = len - il - ir;\n  int jm = len - jl - jr;\n  int k = 0;\n  for (;;) {\n    if (k < il) {\n      if (k < jl) {\n        k = min(il, jl);\n        continue;\n      } else if (k < jl + jm) {\n        int d = min(il - k, jl + jm - k);\n        int dif = cmp(ho, 0, d - 1, h, j + (k - jl), j + (k - jl) + d - 1);\n        if (dif) return dif < 0;\n        k += d;\n        continue;\n      } else {\n        return true;\n      }\n    } else if (k < il + im) {\n      if (k < jl) {\n        int d = min(jl - k, il + im - k);\n        int dif = cmp(h, i + (k - il), i + (k - il) + d - 1, ho, 0, d - 1);\n        if (dif) return dif < 0;\n        k += d;\n        continue;\n      } else if (k < jl + jm) {\n        int d = min(il + im - k, jl + jm - k);\n        int dif = cmp(h, i + (k - il), i + (k - il) + d - 1, h, j + (k - jl),\n                      j + (k - jl) + d - 1);\n        if (dif) return dif < 0;\n        k += d;\n        continue;\n      } else {\n        int d = min(il + im - k, len - k);\n        int dif = cmp(h, i + (k - il), i + (k - il) + d - 1, hz, 0, d - 1);\n        if (dif) return dif < 0;\n        k += d;\n        continue;\n      }\n    } else if (k < len) {\n      if (k < jl) {\n        return false;\n      } else if (k < jl + jm) {\n        int d = min(len - k, jl + jm - k);\n        int dif = cmp(hz, 0, d - 1, h, j + (k - jl), j + (k - jl) + d - 1);\n        if (dif) return dif < 0;\n        k += d;\n        continue;\n      } else {\n        k = len;\n        continue;\n      }\n    } else\n      return false;\n  }\n}\nchar e[N];\nstring ans;\nstring func(string &s) {\n  string res;\n  int m = 0;\n  for (int i = 0; i < s.length(); ++i)\n    if (s[i] == '(') {\n      ++m;\n    } else {\n      if (!m)\n        res += \"(\";\n      else\n        --m;\n    }\n  res += s;\n  while (m--) res += \")\";\n  return res;\n}\nint main() {\n  for (int i = x1[0] = 1; i < N; ++i) x1[i] = x1[i - 1] * X1 % M1;\n  gets(s + 1);\n  n = strlen(s + 1);\n  for (int i = 1; i <= n; ++i) s[i + n] = s[i];\n  for (int i = n; i; --i) {\n    if (s[i] == '(') {\n      if (s2[i + 1]) {\n        s1[i] = s1[i + 1] + 2;\n        s2[i] = s2[i + 1] - 1;\n      } else {\n        s1[i] = s1[i + 1];\n        s2[i] = s2[i + 1];\n      }\n    } else {\n      s1[i] = s1[i + 1];\n      s2[i] = s2[i + 1] + 1;\n    }\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (s[i] == ')') {\n      if (p2[i - 1]) {\n        p1[i] = p1[i - 1] + 2;\n        p2[i] = p2[i - 1] - 1;\n      } else {\n        p1[i] = p1[i - 1];\n        p2[i] = p2[i - 1];\n      }\n    } else {\n      p1[i] = p1[i - 1];\n      p2[i] = p2[i - 1] + 1;\n    }\n  }\n  int x = n * 10;\n  vector<int> pos;\n  for (int i = 0; i < n; ++i) {\n    int op = p2[i];\n    int zp = i - p1[i] - op;\n    int zs = s2[i + 1];\n    int os = n - i - s1[i + 1] - zs;\n    int len = zs + op + max(os, zp) - min(os, zp) + n;\n    if (x > len) {\n      pos.clear();\n      x = len;\n    }\n    if (x == len) {\n      pos.push_back(i);\n    }\n    int sl, sr;\n    calc(i, sl, sr);\n  }\n  h = hasher(s + 1);\n  for (int i = 0; i < n * 2; ++i) e[i] = '(';\n  ho = hasher(e);\n  for (int i = 0; i < n * 2; ++i) e[i] = ')';\n  hz = hasher(e);\n  int res = pos[0];\n  for (int k = 1; k < pos.size(); ++k)\n    if (cmp(pos[k], res, x)) res = pos[k];\n  int sl, sr;\n  calc(res, sl, sr);\n  for (int i = 0; i < sl; ++i) printf(\"(\");\n  for (int i = 0; i < x - sl - sr; ++i) printf(\"%c\", s[res + i + 1]);\n  for (int i = 0; i < sr; ++i) printf(\")\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class F {\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\tboolean eof;\n\n\tint[] buildSuffixArray(int[] s, int alphSize) {\n\t\t// sorts cyclic shifs, append a sentinel to the end if suffix array is\n\t\t// needed\n\t\tint n = s.length;\n\t\tint[] cnt = new int[Math.max(alphSize, n)];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcnt[s[i]]++;\n\t\t}\n\t\tfor (int i = 1; i < alphSize; i++) {\n\t\t\tcnt[i] += cnt[i - 1];\n\t\t}\n\n\t\tint[] arr = new int[n];\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tarr[--cnt[s[i]]] = i;\n\t\t}\n\n\t\tint[] cls = new int[n];\n\t\tint nCl = 1;\n\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint curSuff = arr[i];\n\t\t\tif (s[curSuff] != s[arr[i - 1]]) {\n\t\t\t\tnCl++;\n\t\t\t}\n\t\t\tcls[curSuff] = nCl - 1;\n\t\t}\n\n\t\tint[] aux = new int[n];\n\n\t\tfor (int h = 1; h <= n; h <<= 1) {\n\n\t\t\t// aux - suffixes ordered by second halves\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint tmp = arr[i] - h;\n\t\t\t\tif (tmp < 0)\n\t\t\t\t\ttmp += n;\n\t\t\t\taux[i] = tmp;\n\t\t\t}\n\n\t\t\tArrays.fill(cnt, 0, nCl, 0);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tcnt[cls[i]]++;\n\t\t\t}\n\t\t\tfor (int i = 1; i < nCl; i++) {\n\t\t\t\tcnt[i] += cnt[i - 1];\n\t\t\t}\n\n\t\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\t\tint curSuff = aux[i];\n\t\t\t\tarr[--cnt[cls[curSuff]]] = curSuff;\n\t\t\t}\n\n\t\t\t// aux - new classes\n\t\t\taux[arr[0]] = 0;\n\t\t\tnCl = 1;\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tint curPos = arr[i];\n\t\t\t\tint prevPos = arr[i - 1];\n\t\t\t\tif (cls[curPos] == cls[prevPos]) {\n\t\t\t\t\tint tmpCurPos = curPos + h;\n\t\t\t\t\tif (tmpCurPos >= n)\n\t\t\t\t\t\ttmpCurPos -= n;\n\t\t\t\t\tprevPos += h;\n\t\t\t\t\tif (prevPos >= n)\n\t\t\t\t\t\tprevPos -= n;\n\t\t\t\t\tif (cls[tmpCurPos] != cls[prevPos])\n\t\t\t\t\t\tnCl++;\n\t\t\t\t} else {\n\t\t\t\t\tnCl++;\n\t\t\t\t}\n\t\t\t\taux[curPos] = nCl - 1;\n\t\t\t}\n\n\t\t\tint[] tmp = aux;\n\t\t\taux = cls;\n\t\t\tcls = tmp;\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\tvoid solve() throws IOException {\n\t\tString ss = nextToken();\n\t\tint n = ss.length();\n\t\tint[] s = new int[n];\n\t\tint[] bal = new int[n + 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ts[i] = ss.charAt(i) == '(' ? 0 : 1;\n\t\t\tif (s[i] == 0) {\n\t\t\t\tbal[i + 1] = bal[i] + 1;\n\t\t\t} else {\n\t\t\t\tbal[i + 1] = bal[i] - 1;\n\t\t\t}\n\t\t}\n\t\tint[] sa = buildSuffixArray(s, 2);\n\t\tint[] order = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\torder[sa[i]] = i;\n\t\t}\n\t\tint minBal = 0;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tminBal = Math.min(minBal, bal[i]);\n\t\t}\n\n\t\tint[] minSuff = new int[n + 1];\n\t\tint[] minPref = new int[n + 1];\n\t\tminPref[0] = bal[0];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tminPref[i] = Math.min(minPref[i - 1], bal[i]);\n\t\t}\n\t\tminSuff[n] = bal[n];\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tminSuff[i] = Math.min(minSuff[i + 1], bal[i]);\n\t\t}\n\n\t\tint pos = -1;\n\t\t// System.err.println(Arrays.toString(bal) + \" \" + minBal);\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t// if ((bal[n] <= 0 && bal[i] == minBal)\n\t\t\t// || (bal[n] > 0 && bal[i] <= minBal + bal[n])) {\n\t\t\tboolean cond;\n\t\t\tif (bal[n] >= 0) {\n\t\t\t\tcond = minSuff[i] - bal[i] >= 0;\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tcond &= minPref[i - 1] + (bal[n] - bal[i]) >= 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcond = (minSuff[i] - bal[i]) >= bal[n];\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tcond &= minPref[i - 1] + (bal[n] - bal[i]) >= bal[n];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cond) {\n\n\t\t\t\tif (pos == -1) {\n\t\t\t\t\tpos = i;\n\t\t\t\t} else {\n\t\t\t\t\tif (order[i % n] <= order[pos]) {\n\t\t\t\t\t\tpos = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif (bal[n] < 0) {\n\t\t\tfor (int i = 0; i < -bal[n]; i++) {\n\t\t\t\tsb.append('(');\n\t\t\t}\n\t\t}\n\t\tsb.append(ss.substring(pos));\n\t\tsb.append(ss.substring(0, pos));\n\t\tif (bal[n] > 0) {\n\t\t\tfor (int i = 0; i < bal[n]; i++) {\n\t\t\t\tsb.append(')');\n\t\t\t}\n\t\t}\n\t\tout.println(sb.toString());\n\t}\n\n\t// ((()())\n\n\tF() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew F();\n\t}\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e) {\n\t\t\t\teof = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\teof = true;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2000050;\nconst int INF = 1e9;\nint t[maxn], x[maxn], y[maxn], sa[maxn], rnk[maxn], height[maxn];\nint seg[maxn << 2], laz[maxn << 2];\nint sum[maxn];\nchar s[maxn];\nint n, m;\nvoid get_sa() {\n  for (int i = 1; i <= m; i++) t[i] = 0;\n  for (int i = 1; i <= n; i++) t[x[i] = s[i]]++;\n  for (int i = 2; i <= m; i++) t[i] += t[i - 1];\n  for (int i = n; i >= 1; i--) sa[t[x[i]]--] = i;\n  for (int k = 1; k <= n; k <<= 1) {\n    int num = 0;\n    for (int i = n - k + 1; i <= n; i++) y[++num] = i;\n    for (int i = 1; i <= n; i++) {\n      if (sa[i] > k) y[++num] = sa[i] - k;\n    }\n    for (int i = 1; i <= m; i++) t[i] = 0;\n    for (int i = 1; i <= n; i++) t[x[i]]++;\n    for (int i = 2; i <= m; i++) t[i] += t[i - 1];\n    for (int i = n; i >= 1; i--) sa[t[x[y[i]]]--] = y[i];\n    swap(x, y);\n    x[sa[1]] = 1;\n    num = 1;\n    for (int i = 2; i <= n; i++) {\n      x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + k] == y[sa[i - 1] + k])\n                     ? num\n                     : ++num;\n    }\n    if (num == n) break;\n    m = num;\n  }\n  for (int i = 1; i <= n; i++) rnk[sa[i]] = i;\n}\nvoid pushup(int x) { seg[x] = min(seg[x << 1], seg[x << 1 | 1]); }\nvoid pushdown(int x) {\n  if (laz[x]) {\n    seg[x << 1] += laz[x];\n    seg[x << 1 | 1] += laz[x];\n    laz[x << 1] += laz[x];\n    laz[x << 1 | 1] += laz[x];\n    laz[x] = 0;\n  }\n}\nvoid build(int x, int l, int r) {\n  if (l == r) {\n    seg[x] = sum[l];\n    return;\n  }\n  int mid = (l + r) >> 1;\n  build(x << 1, l, mid);\n  build(x << 1 | 1, mid + 1, r);\n  pushup(x);\n}\nvoid update(int x, int l, int r, int L, int R, int val) {\n  if (L <= l && r <= R) {\n    seg[x] += val;\n    laz[x] += val;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  pushdown(x);\n  if (mid >= L) update(x << 1, l, mid, L, R, val);\n  if (mid < R) update(x << 1 | 1, mid + 1, r, L, R, val);\n  pushup(x);\n}\nint query(int x, int l, int r, int L, int R) {\n  if (L <= l && r <= R) return seg[x];\n  int mid = (l + r) >> 1, res = INF;\n  pushdown(x);\n  if (mid >= L) res = min(res, query(x << 1, l, mid, L, R));\n  if (mid < R) res = min(res, query(x << 1 | 1, mid + 1, r, L, R));\n  return res;\n}\nvoid solve() {\n  scanf(\"%s\", s + 1);\n  int len_s = strlen(s + 1), tot1 = 0, tot2 = 0;\n  for (int i = 1; i <= len_s; i++) {\n    if (s[i] == '(') {\n      sum[i] = sum[i - 1] + 1;\n      tot1++;\n    } else {\n      sum[i] = sum[i - 1] - 1;\n      tot2++;\n    }\n  }\n  for (int i = len_s + 1; i <= 2 * len_s; i++) s[i] = s[i - len_s];\n  n = 2 * len_s;\n  m = 128;\n  get_sa();\n  build(1, 1, n);\n  int res = 0;\n  for (int i = 1; i <= len_s; i++) {\n    if (query(1, 1, n, i, i + len_s - 1) >= min(tot1 - tot2, 0) &&\n        (!res || rnk[res] > rnk[i]))\n      res = i;\n    update(1, 1, n, i + 1, i + len_s - 1, ((s[i] == '(') ? -1 : 1));\n    int tmp = query(1, 1, n, i + len_s - 1, i + len_s - 1);\n    update(1, 1, n, i + len_s, i + len_s, ((s[i] == '(') ? tmp + 1 : tmp - 1));\n  }\n  if (tot1 <= tot2) {\n    for (int i = 1; i <= tot2 - tot1; i++) printf(\"(\");\n    for (int i = res; i <= res + len_s - 1; i++) printf(\"%c\", s[i]);\n  } else {\n    for (int i = res; i <= res + len_s - 1; i++) printf(\"%c\", s[i]);\n    for (int i = 1; i <= tot1 - tot2; i++) printf(\")\");\n  }\n  printf(\"\\n\");\n}\nint main() {\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:66777216\")\nusing namespace std;\nstatic unsigned rnd() {\n  static int second = 124612741;\n  second ^= second << 13;\n  second ^= second >> 17;\n  return second ^= second << 5;\n}\ninline int fpow(int a, int st, int mod) {\n  int ans = 1;\n  while (st) {\n    if (st % 2) ans = (long long)ans * a % mod;\n    a = (long long)a * a % mod;\n    st /= 2;\n  }\n  return ans;\n}\nint invmod(int first, int second) {\n  int a = 1, b = 0, k;\n  for (; second; swap(first, second), swap(a, b)) {\n    k = first / second;\n    first -= second * k;\n    a -= b * k;\n  }\n  return a + max(b, 0);\n}\nstruct Hash {\n  Hash() : x1(0), x2(0) {}\n  Hash(const int& x1, const int& x2) : x1(x1), x2(x2) {}\n  int x1, x2;\n  static int mod1, mod2;\n  static int p1, p2;\n  static int invp1, invp2;\n  static bool initCalled;\n  static const Hash ONE, ZERO, INVALID;\n  static Hash UNIT, INV_UNIT;\n  static bool prime(int a) {\n    if (a == 1) return 0;\n    for (int i = 2; i * i <= a; ++i) {\n      if (a % i == 0) return false;\n    }\n    return true;\n  }\n  static void init() {\n    if (initCalled) return;\n    initCalled = true;\n    mod1 = 1000000000 + rnd() % 10000000;\n    while (!prime(mod1)) ++mod1;\n    mod2 = 1000000000 + rnd() % 10000000;\n    while (mod2 == mod1 || !prime(mod2)) ++mod2;\n    invp1 = fpow(p1, mod1 - 2, mod1);\n    invp2 = fpow(p2, mod2 - 2, mod2);\n    INV_UNIT = Hash(invp1, invp2);\n  }\n  inline Hash& operator+=(const Hash& other) {\n    x1 += other.x1;\n    x1 -= (((x1 - mod1) >> 31) + 1) * mod1;\n    x2 += other.x2;\n    x1 -= (((x1 - mod2) >> 31) + 1) * mod2;\n    return *this;\n  }\n  inline Hash& operator-=(const Hash& other) {\n    x1 -= other.x1;\n    if (x1 < 0) x1 += Hash::mod1;\n    x2 -= other.x2;\n    if (x2 < 0) x2 += Hash::mod2;\n    return *this;\n  }\n  inline Hash& operator*=(const Hash& other) {\n    x1 = (long long)x1 * other.x1 % Hash::mod1;\n    x2 = (long long)x2 * other.x2 % Hash::mod2;\n    return *this;\n  }\n  inline Hash& operator*=(const int& other) {\n    x1 = (long long)x1 * other % Hash::mod1;\n    x2 = (long long)x2 * other % Hash::mod2;\n    return *this;\n  }\n  inline Hash& operator^=(const int& power) {\n    int st = power;\n    Hash ans(1, 1);\n    while (st) {\n      if (st % 2) ans *= *this;\n      x1 = (long long)x1 * x1 % Hash::mod1;\n      x2 = (long long)x2 * x2 % Hash::mod2;\n      st /= 2;\n    }\n    return *this;\n  }\n  inline bool operator==(const Hash& other) const {\n    return x1 == other.x1 && x2 == other.x2;\n  }\n};\nbool Hash::initCalled = false;\nint Hash::mod1 = 0;\nint Hash::mod2 = 0;\nint Hash::p1 = 23561;\nint Hash::p2 = 10000019;\nint Hash::invp1 = -1;\nint Hash::invp2 = -1;\nconst Hash Hash::ONE(1, 1);\nconst Hash Hash::ZERO(0, 0);\nconst Hash Hash::INVALID(-1, -1);\nHash Hash::UNIT(Hash::p1, Hash::p2);\nHash Hash::INV_UNIT(-1, -1);\ninline Hash operator+(const Hash& a, const Hash& b) {\n  Hash ans(a.x1 + b.x1, a.x2 + b.x2);\n  if (ans.x1 >= Hash::mod1) ans.x1 -= Hash::mod1;\n  if (ans.x2 >= Hash::mod2) ans.x2 -= Hash::mod2;\n  return ans;\n}\ninline Hash operator-(const Hash& a, const Hash& b) {\n  Hash ans(a.x1 - b.x1, a.x2 - b.x2);\n  if (ans.x1 < 0) ans.x1 += Hash::mod1;\n  if (ans.x2 < 0) ans.x2 += Hash::mod2;\n  return ans;\n}\ninline Hash operator*(const Hash& a, const Hash& b) {\n  return Hash((long long)a.x1 * b.x1 % Hash::mod1,\n              (long long)a.x2 * b.x2 % Hash::mod2);\n}\ninline Hash operator*(const Hash& a, const int& b) {\n  return Hash((long long)a.x1 * b % Hash::mod1,\n              (long long)a.x2 * b % Hash::mod2);\n}\ninline Hash operator^(const Hash& a, const int& power) {\n  int st = power;\n  Hash ans(1, 1), cur(a);\n  while (st) {\n    if (st % 2) ans *= cur;\n    cur *= cur;\n    st /= 2;\n  }\n  return ans;\n}\ninline Hash fpow(const Hash& a, const int& power) { return a ^ power; }\ninline Hash invmod(const Hash& a) {\n  return Hash(invmod(a.x1, Hash::mod1), invmod(a.x2, Hash::mod2));\n}\ntemplate <class H>\nstruct HashString : public string {\n  HashString() : string() { precalc(0); }\n  HashString(const HashString& other) : string(other) { precalc(size()); }\n  HashString(HashString&& other)\n      : hh(std::move(other.hh)), string(std::move(other)) {\n    precalc(size());\n  }\n  HashString(const string& other) : string(other) {\n    precalc(size());\n    build();\n  }\n  HashString(string&& other) : string(std::move(other)) {\n    precalc(size());\n    build();\n  }\n  HashString(const char* other) : string(other) {\n    precalc(size());\n    build();\n  }\n  inline void clear() {\n    hh.clear();\n    string::clear();\n  }\n  inline static H getPow(int p) {\n    if (p < haveN) {\n      return pp[p];\n    } else {\n      return fpow(H::UNIT, p);\n    }\n  }\n  inline static H getInvPow(size_t p) {\n    if (p < invpp.size()) {\n      return invpp[p];\n    } else {\n      return fpow(H::INV_UNIT, p);\n    }\n  }\n  inline H getInvRegister(const H& p) const {\n    if (p == register_) {\n      return registerValue_;\n    } else {\n      register_ = p;\n      return registerValue_ = invmod(p);\n    }\n  }\n  static void precalc(int N = 0) {\n    Hash::init();\n    if (haveN >= N) return;\n    pp.resize(N);\n    invpp.resize(N);\n    if (!haveN) {\n      pp[0] = H::ONE;\n      invpp[0] = H::ONE;\n      haveN = 1;\n    }\n    for (int i = haveN; i < N; ++i) {\n      pp[i] = pp[i - 1] * H::UNIT;\n      invpp[i] = invpp[i - 1] * H::INV_UNIT;\n    }\n    haveN = N;\n  }\n  inline void build() {\n    int curSize = size();\n    if (haveN <= curSize) {\n      precalc(curSize);\n    }\n    for (int i = hh.size(); i < curSize; ++i) {\n      H pr = i ? hh.back() : H::ZERO;\n      hh.push_back(pr + getPow(i) * (*this)[i]);\n    }\n  }\n  inline H getHash(int pos, int len) const {\n    if (len <= 0) return H::ZERO;\n    const int S = size();\n    if (pos + len - 1 < S) {\n      H ans = hh[pos + len - 1];\n      if (pos) {\n        ans -= hh[pos - 1];\n        ans *= getInvPow(pos);\n      }\n      return ans;\n    } else {\n      H head = hh.back();\n      if (pos) {\n        head -= hh[pos - 1];\n        head *= getInvPow(pos);\n      }\n      int full = -1, en = -1;\n      H mid = H::ZERO;\n      int midlen = 0;\n      if (len <= S) {\n        en = pos + len - 1 - S;\n        H tail = hh[en];\n        full = 0;\n        return head + tail * getPow(S - pos);\n      } else {\n        en = (pos + len - 1) % S;\n        H tail = hh[en];\n        full = (len - (S - pos) - (en + 1)) / S;\n        mid = hh.back() * (H::ONE - getInvPow(full * S)) *\n              getInvRegister(H::ONE - getInvPow(S));\n        return head + mid * getPow(S - pos) + tail * getPow(len - (en + 1));\n      }\n    }\n  }\n  inline HashString& operator+=(const char& ch) {\n    string::operator+=(ch);\n    build();\n    return *this;\n  }\n  inline HashString& operator+=(const HashString& other) {\n    string::operator+=(other);\n    build();\n    return *this;\n  }\n  inline bool operator==(const HashString& other) const {\n    return hh.back() == other.hh.back();\n  }\n  inline bool operator<(const HashString& other) const {\n    int s1 = size();\n    int s2 = other.size();\n    const int S = min(s1, s2);\n    int l = 0, r = S + 1;\n    while (r - l > 1) {\n      int xx = (r + l) / 2;\n      if (getHash(0, xx) == other.getHash(0, xx))\n        l = xx;\n      else\n        r = xx;\n    }\n    char c1 = 0, c2 = 0;\n    if (l < s1) c1 = (*this)[l];\n    if (l < s2) c2 = other[l];\n    return c1 < c2;\n  }\n  inline bool operator<=(const HashString& other) const {\n    return (*this == other) || (*this < other);\n  }\n  inline bool operator>(const HashString& other) const {\n    return !(*this == other) && !(*this < other);\n  }\n  inline bool operator>=(const HashString& other) const {\n    return !(*this < other);\n  }\n  inline bool operator!=(const HashString& other) const {\n    return !(*this == other);\n  }\n  inline void reserve(int N) {\n    hh.reserve(N);\n    string::reserve(N);\n  }\n  vector<H> hh;\n  static vector<H> pp, invpp;\n\n private:\n  mutable H register_, registerValue_;\n  static int haveN;\n};\ntemplate <>\nint HashString<Hash>::haveN = 0;\ntemplate <>\nvector<Hash> HashString<Hash>::pp = vector<Hash>();\ntemplate <>\nvector<Hash> HashString<Hash>::invpp = vector<Hash>();\ntemplate <class H, bool cyclic = true>\nstruct HashStringPiece {\n  explicit HashStringPiece(const HashString<H>& s, int pos, int len)\n      : s(s), pos(pos), len(len), hash(H::INVALID) {}\n  inline H getHash() const {\n    if (hash == H::INVALID) hash = s.getHash(pos, len);\n    return hash;\n  }\n  inline H getPartialHash(int needLen) const { return s.getHash(pos, needLen); }\n  inline char getChar(int i) const {\n    i += pos;\n    const int S = s.size();\n    if (i < S) return s[i];\n    if (!cyclic) return 0;\n    i -= S;\n    if (i < S) return s[i];\n    return s[i % S];\n  }\n  const HashString<H>& s;\n  const int pos, len;\n  mutable H hash;\n};\ntemplate <class H, class T>\nchar getHSPRangeChar(T beg, T en, int pos) {\n  for (T it = beg; it != en; ++it) {\n    if (pos < it->len) {\n      return it->getChar(pos);\n    }\n    pos -= it->len;\n  }\n  return 0;\n}\ntemplate <class H, class T>\nH getHSPRangeHash(T beg, T en, int len) {\n  H ans = H::ZERO;\n  int cur = 0;\n  for (T it = beg; it != en; ++it) {\n    if (len >= it->len) {\n      ans += it->getHash() * it->s.getPow(cur);\n      cur += it->len;\n      len -= it->len;\n    } else {\n      ans += it->getPartialHash(len) * it->s.getPow(cur);\n      break;\n    }\n  }\n  return ans;\n}\nint TB, IT;\ntemplate <class H, class T>\ninline int compareHSPRanges(T beg1, T en1, int len1, T beg2, T en2, int len2) {\n  if (beg1 == en1 && beg2 == en2) return 0;\n  if (beg1 == en1) return -1;\n  if (beg2 == en2) return 1;\n  int l = 0, r = min(len1, len2) + 1;\n  while (r - l > 1) {\n    int xx = (r + l) / 2;\n    auto h1 = getHSPRangeHash<H, T>(beg1, en1, xx);\n    auto h2 = getHSPRangeHash<H, T>(beg2, en2, xx);\n    if (h1 == h2)\n      l = xx;\n    else\n      r = xx;\n  }\n  char c1 = getHSPRangeChar<H, T>(beg1, en1, l);\n  char c2 = getHSPRangeChar<H, T>(beg2, en2, l);\n  if (c1 < c2)\n    return -1;\n  else if (c1 == c2)\n    return 0;\n  else\n    return 1;\n}\ntemplate <class H, class T>\ninline int compareHSPRanges(T beg1, T en1, T beg2, T en2) {\n  int len1 = 0;\n  for (T it = beg1; it != en1; ++it) {\n    len1 += it->len;\n  }\n  int len2 = 0;\n  for (T it = beg2; it != en2; ++it) {\n    len2 += it->len;\n  }\n  return compareHSPRanges<H, T>(beg1, en1, len1, beg2, en2, len2);\n}\nint a, b, c, d, n, m, k;\nchar str[1000002];\nint bal[2000002];\nHashString<Hash> s;\ninline string build(pair<pair<int, int>, int> a) {\n  string ans = \"\";\n  for (int _n((a.first.first) - 1), i(0); i <= _n; i++) ans += '(';\n  for (int _n((n)-1), i(0); i <= _n; i++) {\n    int cur = a.second + i;\n    if (cur >= n) cur -= n;\n    ans += str[cur];\n  }\n  for (int _n((a.first.second) - 1), i(0); i <= _n; i++) ans += ')';\n  return ans;\n}\nHashString<Hash> op, cl;\ninline bool better(pair<pair<int, int>, int> a, pair<pair<int, int>, int> b,\n                   const HashString<Hash>& s) {\n  HashStringPiece<Hash> A[3] = {HashStringPiece<Hash>(op, 0, a.first.first),\n                                HashStringPiece<Hash>(s, a.second, n),\n                                HashStringPiece<Hash>(cl, 0, a.first.second)};\n  HashStringPiece<Hash> B[3] = {HashStringPiece<Hash>(op, 0, b.first.first),\n                                HashStringPiece<Hash>(s, b.second, n),\n                                HashStringPiece<Hash>(cl, 0, b.first.second)};\n  int t = compareHSPRanges<Hash>(A, A + 3, B, B + 3);\n  if (t == -1)\n    return 1;\n  else\n    return 0;\n}\nint main() {\n  gets(str);\n  n = (int)strlen(str);\n  HashString<Hash> s(str);\n  HashString<Hash>::precalc(2 * n + 1);\n  op.reserve(n + 1);\n  cl.reserve(n + 1);\n  for (int _n((n)-1), i(0); i <= _n; i++) {\n    op += '(';\n    cl += ')';\n  }\n  c = 0;\n  for (int _n((n)-1), i(0); i <= _n; i++) {\n    if (str[i] == '(')\n      ++c;\n    else\n      --c;\n  }\n  bal[0] = 0;\n  for (int _n((2 * n) - 1), i(0); i <= _n; i++) {\n    if (i) bal[i] = bal[i - 1];\n    int cur = i;\n    if (i >= n) cur = i - n;\n    if (str[cur] == '(')\n      ++bal[i];\n    else\n      --bal[i];\n  }\n  int blen = 1000000000;\n  pair<pair<int, int>, int> best = make_pair(make_pair(0, 0), 0);\n  stack<pair<int, int> > s1, s2;\n  for (int _n((n)-1), i(0); i <= _n; i++) {\n    int new_element = bal[i];\n    int minima = s1.empty() ? new_element : min(new_element, s1.top().second);\n    s1.push(make_pair(new_element, minima));\n  }\n  for (int _n((n)-1), cyc(0); cyc <= _n; cyc++) {\n    int current_minimum = -1000000000;\n    if (s1.empty() || s2.empty())\n      current_minimum = s1.empty() ? s2.top().second : s1.top().second;\n    else\n      current_minimum = min(s1.top().second, s2.top().second);\n    int p = 0;\n    if (cyc) p = bal[cyc - 1];\n    int mn = current_minimum - p;\n    int beg = max(0, -mn);\n    int en = c + beg;\n    int len = beg + en + n;\n    if (len < blen ||\n        (len == blen && better(make_pair(make_pair(beg, en), cyc), best, s))) {\n      blen = len;\n      best = make_pair(make_pair(beg, en), cyc);\n    }\n    if (s2.empty()) {\n      while (!s1.empty()) {\n        int element = s1.top().first;\n        s1.pop();\n        int minima = s2.empty() ? element : min(element, s2.top().second);\n        s2.push(make_pair(element, minima));\n      }\n    }\n    s2.pop();\n    int new_element = bal[cyc + n];\n    int minima = s1.empty() ? new_element : min(new_element, s1.top().second);\n    s1.push(make_pair(new_element, minima));\n  }\n  string ans = build(best);\n  printf(\"%s\\n\", ans.c_str());\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int TOUR = 1 << 21, MOD = 1000000007, H = 3137;\nstruct tour {\n  int brot, brzat, dodot;\n  tour(int brot, int brzat, int dodot)\n      : brot(brot), brzat(brzat), dodot(dodot) {}\n  tour() {}\n  int vel() { return 2 * (brot + dodot); }\n} t[2 * TOUR];\ntour Merge(const tour &l, const tour &r) {\n  int dodr = max(0, r.dodot - (l.brot + l.dodot - l.brzat));\n  return tour(l.brot + r.brot, l.brzat + r.brzat, l.dodot + dodr);\n}\nchar s[TOUR];\nint len;\nint hes[TOUR];\nint pot[TOUR];\nint Mul(int a, int b) { return ((long long)a * b) % MOD; }\nint Add(int a, int b) { return (a + b) % MOD; }\nint Sub(int a, int b) { return (a - b + MOD) % MOD; }\nvoid GenHes() {\n  pot[0] = 1;\n  for (int i = 1; i < TOUR; i++) pot[i] = Mul(pot[i - 1], H);\n  for (int i = 1; i <= 2 * len; i++)\n    hes[i] = Add(Mul(hes[i - 1], H), s[(i - 1) % len] - '(' + 1);\n}\nint Manji(int a, int b) {\n  a++;\n  b++;\n  int lo = 0, hi = len;\n  for (; lo < hi;) {\n    int mid = (lo + hi + 1) / 2;\n    if (Sub(hes[a + mid - 1], Mul(hes[a - 1], pot[mid])) ==\n        Sub(hes[b + mid - 1], Mul(hes[b - 1], pot[mid])))\n      lo = mid;\n    else\n      hi = mid - 1;\n  }\n  return s[(a + lo - 1) % len] < s[(b + lo - 1) % len];\n}\nvoid Ispis(int poc, int dodot, int dodzat) {\n  for (int i = 0; i < dodot; i++) printf(\"(\");\n  for (int i = 0; i < len; i++, poc++) printf(\"%c\", s[poc % len]);\n  for (int i = 0; i < dodzat; i++) printf(\")\");\n  printf(\"\\n\");\n}\nvoid GenTour() {\n  for (int i = 2 * TOUR - 1; i; i--) {\n    if (i < TOUR)\n      t[i] = Merge(t[2 * i], t[2 * i + 1]);\n    else {\n      int poz = i - TOUR;\n      if (poz >= 2 * len) continue;\n      if (s[poz % len] == '(')\n        t[i] = tour(1, 0, 0);\n      else\n        t[i] = tour(0, 1, 1);\n    }\n  }\n}\ntour Vrati(int pos, int lo, int hi, int begin, int end) {\n  if (lo >= end || hi <= begin) return tour(0, 0, 0);\n  if (lo >= begin && hi <= end) return t[pos];\n  return Merge(Vrati(2 * pos + 0, lo, (lo + hi) / 2, begin, end),\n               Vrati(2 * pos + 1, (lo + hi) / 2, hi, begin, end));\n}\nint main() {\n  tour rje = tour(0, 0, 0);\n  int indr = 0;\n  scanf(\"%s\", s);\n  len = (int)strlen(s);\n  GenTour();\n  GenHes();\n  for (int i = 0; i < len; i++) {\n    tour tmp = Vrati(1, 0, TOUR, i, i + len);\n    if (!i || tmp.vel() < rje.vel() ||\n        (tmp.vel() == rje.vel() && Manji(i, indr))) {\n      rje = tmp;\n      indr = i;\n    }\n  }\n  Ispis(indr, rje.dodot, rje.dodot + rje.brot - rje.brzat);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e6 + 5;\nchar s[N];\nint tp[N], rak[N], sa[N], tax[N], sl, m, lr_cnt[N], lg[N], f[N][20], rl_cnt[N];\nvoid radixSort() {\n  for (int i = 1; i <= m; i++) tax[i] = 0;\n  for (int i = 1; i <= sl; i++) tax[rak[i]]++;\n  for (int i = 1; i <= m; i++) tax[i] += tax[i - 1];\n  for (int i = sl; i; i--) sa[tax[rak[tp[i]]]--] = tp[i];\n}\nvoid build_sa() {\n  m = 125;\n  for (int i = 1; i <= sl; i++) rak[i] = s[i], tp[i] = i;\n  radixSort();\n  for (int p = 0, w = 1; p < sl; w <<= 1, m = p) {\n    p = 0;\n    for (int i = 1; i <= w; i++) tp[++p] = sl - w + i;\n    for (int i = 1; i <= sl; i++)\n      if (sa[i] > w) tp[++p] = sa[i] - w;\n    radixSort();\n    swap(tp, rak);\n    rak[sa[1]] = p = 1;\n    for (int i = 2; i <= sl; i++)\n      rak[sa[i]] =\n          (tp[sa[i]] == tp[sa[i - 1]] && tp[sa[i] + w] == tp[sa[i - 1] + w])\n              ? p\n              : ++p;\n  }\n}\nvoid make_st() {\n  int range = lg[sl];\n  if (lr_cnt[sl] > 0) {\n    for (int i = 1; i <= sl; i++) f[i][0] = lr_cnt[i];\n    for (int i = 1; i <= range; i++)\n      for (int j = 1; j + (1 << i) - 1 <= sl; j++)\n        f[j][i] = min(f[j][i - 1], f[j + (1 << (i - 1))][i - 1]);\n  } else {\n    for (int i = 1; i <= sl; i++) f[i][0] = rl_cnt[i];\n    for (int i = 1; i <= range; i++)\n      for (int j = 1; j + (1 << i) - 1 <= sl; j++)\n        f[j][i] = max(f[j][i - 1], f[j + (1 << (i - 1))][i - 1]);\n  }\n}\nint query(int l, int r) {\n  int range = lg[r - l + 1];\n  if (lr_cnt[sl] > 0)\n    return min(f[l][range], f[r - (1 << range) + 1][range]);\n  else\n    return max(f[l][range], f[r - (1 << range) + 1][range]);\n}\nint main() {\n  scanf(\"%s\", s + 1);\n  sl = strlen(s + 1);\n  for (int i = 1; i <= sl; i++) s[i + sl] = s[i];\n  sl <<= 1;\n  build_sa();\n  for (int i = 1; i <= sl; i++)\n    lr_cnt[i] = lr_cnt[i - 1] + ((s[i] == '(') ? 1 : -1);\n  for (int i = sl; i; i--) rl_cnt[i] = rl_cnt[i + 1] + ((s[i] == '(') ? 1 : -1);\n  for (int i = 2; i <= sl; i++)\n    lg[i] = lg[i - 1] + (i == (1 << (lg[i - 1] + 1)));\n  make_st();\n  int l_fill = 0, r_fill = 0, ans_pos;\n  if (lr_cnt[sl] > 0)\n    r_fill = lr_cnt[sl] / 2;\n  else\n    l_fill = abs(lr_cnt[sl] / 2);\n  for (int i = 1; i <= sl; i++) {\n    int p = sa[i];\n    if (p > sl / 2) continue;\n    int res = query(p, p + sl / 2 - 1);\n    if (lr_cnt[sl] > 0) {\n      if (res - lr_cnt[p - 1] < 0) continue;\n    } else {\n      if (res - rl_cnt[p + sl / 2] > 0) continue;\n    }\n    ans_pos = p;\n    break;\n  }\n  for (int i = 1; i <= l_fill; i++) printf(\"(\");\n  for (int i = ans_pos; i <= ans_pos + sl / 2 - 1; i++) printf(\"%c\", s[i]);\n  for (int i = 1; i <= r_fill; i++) printf(\")\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T, typename U>\ninline void amin(T &x, U y) {\n  if (y < x) x = y;\n}\ntemplate <typename T, typename U>\ninline void amax(T &x, U y) {\n  if (x < y) x = y;\n}\nunsigned long long readTimeStampCounter() {\n  unsigned a = 123456789, b = 987654321;\n  asm(\"rdtsc;\\n\\t\" : \"=d\"(a), \"=a\"(b));\n  return (unsigned long long)a << 32 | b;\n}\nunsigned xor128() {\n  static unsigned x = 123456789, y = 362436069,\n                  z = (unsigned)(readTimeStampCounter() >> 32),\n                  w = (unsigned)readTimeStampCounter();\n  unsigned t = x ^ (x << 11);\n  x = y;\n  y = z;\n  z = w;\n  return w = w ^ (w >> 19) ^ (t ^ (t >> 8));\n}\nstruct SubstringHash {\n  static const int NumMods = 4;\n  static const unsigned Mods[NumMods];\n  struct Hash {\n    unsigned hs[NumMods];\n    Hash() {\n      for (int k = 0; k < NumMods; ++k) hs[k] = 0;\n    }\n    bool operator==(const Hash &that) const {\n      bool res = true;\n      for (int k = 0; k < NumMods; ++k) res &= hs[k] == that.hs[k];\n      return res;\n    }\n    bool operator<(const Hash &that) const {\n      for (int k = 0; k < NumMods; ++k)\n        if (hs[k] != that.hs[k]) return hs[k] < that.hs[k];\n      return false;\n    }\n  };\n  static unsigned seeds[NumMods];\n  static std::vector<Hash> powh;\n  std::vector<Hash> preh;\n  SubstringHash() {\n    if (seeds[0] == 0) initSeeds();\n  }\n  static void initSeeds() {\n    for (int k = 0; k < NumMods; ++k) {\n      unsigned x;\n      do x = xor128();\n      while (x == 0 || x >= Mods[k]);\n      seeds[k] = x;\n    }\n  }\n  static void expandPowH(int newSize) {\n    if ((int)powh.size() >= newSize) return;\n    int oldSize = powh.size();\n    powh.resize(newSize);\n    if (oldSize == 0)\n      for (int k = 0; k < NumMods; ++k) powh[0].hs[k] = 1;\n    for (int i = std::max(1, oldSize); i < newSize; i++)\n      for (int k = 0; k < NumMods; ++k)\n        powh[i].hs[k] =\n            (unsigned long long)powh[i - 1].hs[k] * seeds[k] % Mods[k];\n  }\n  template <typename V>\n  void init(const V &v, int n) {\n    expandPowH(n + 1);\n    preh.resize(n + 1);\n    preh[0] = Hash();\n    for (int i = 0; i < n; i++)\n      for (int k = 0; k < NumMods; ++k)\n        preh[i + 1].hs[k] =\n            ((unsigned long long)preh[i].hs[k] * seeds[k] % Mods[k] + v[i]) %\n            Mods[k];\n  }\n  Hash hash(int j) const { return preh[j]; }\n  Hash hash(int i, int j) const {\n    if (i == 0) return hash(j);\n    Hash res;\n    for (int k = 0; k < NumMods; ++k) {\n      unsigned x = preh[j].hs[k] + Mods[k] -\n                   (unsigned)((unsigned long long)preh[i].hs[k] *\n                              powh[j - i].hs[k] % Mods[k]);\n      res.hs[k] = x >= Mods[k] ? x - Mods[k] : x;\n    }\n    return res;\n  }\n  Hash append(const Hash &h, const Hash &g, int glen) const {\n    Hash res;\n    for (int k = 0; k < NumMods; ++k) {\n      unsigned x =\n          (unsigned)((unsigned long long)h.hs[k] * powh[glen].hs[k] % Mods[k]) +\n          g.hs[k];\n      res.hs[k] = x >= Mods[k] ? x - Mods[k] : x;\n    }\n    return res;\n  }\n};\nconst unsigned SubstringHash::Mods[SubstringHash::NumMods] = {\n    2147483647U, 2147483629U, 2147483587U, 2147483579U};\nunsigned SubstringHash::seeds[SubstringHash::NumMods];\nstd::vector<SubstringHash::Hash> SubstringHash::powh;\nstruct Sum {\n  int miniLv, addLv;\n  Sum() : miniLv(0), addLv(0) {}\n  Sum(char c) : miniLv(c == '(' ? 0 : -1), addLv(c == '(' ? 1 : -1) {}\n  Sum operator+(const Sum &that) const {\n    Sum res;\n    res.miniLv = min(miniLv, addLv + that.miniLv);\n    res.addLv = addLv + that.addLv;\n    return res;\n  }\n};\nstruct GetRangeSegmentTree {\n  static Sum combineVal(const Sum &x, const Sum &y) { return x + y; }\n  static void combinesVal(Sum &x, const Sum &y) { x = x + y; }\n  static Sum identityVal() { return Sum(); }\n  vector<Sum> nodes;\n  int n;\n  void init(int n_, const Sum &v = Sum()) { init(vector<Sum>(n_, v)); }\n  void init(const vector<Sum> &u) {\n    n = 1;\n    while (n < (int)u.size()) n *= 2;\n    nodes.resize(n, identityVal());\n    nodes.insert(nodes.end(), u.begin(), u.end());\n    nodes.resize(n * 2, identityVal());\n    for (int i = n - 1; i > 0; --i)\n      nodes[i] = combineVal(nodes[i * 2], nodes[i * 2 + 1]);\n  }\n  Sum get(int i) { return nodes[i + n]; }\n  Sum getWhole() const { return nodes[1]; }\n  Sum getRange(int l, int r) const {\n    Sum m = identityVal();\n    int indices[64];\n    int k = 0;\n    for (; l && l + (l & -l) <= r; l += l & -l)\n      combinesVal(m, nodes[(n + l) / (l & -l)]);\n    for (; l < r; r -= r & -r) indices[k++] = (n + r) / (r & -r) - 1;\n    while (--k >= 0) combinesVal(m, nodes[indices[k]]);\n    return m;\n  }\n  Sum getRangeCommutative(int l, int r) const {\n    Sum m = identityVal();\n    for (; l && l + (l & -l) <= r; l += l & -l)\n      combinesVal(m, nodes[(n + l) / (l & -l)]);\n    for (; l < r; r -= r & -r) combinesVal(m, nodes[(n + r) / (r & -r) - 1]);\n    return m;\n  }\n  void set(int i, const Sum &x) {\n    i += n;\n    nodes[i] = x;\n    for (i >>= 1; i > 0; i >>= 1)\n      nodes[i] = combineVal(nodes[i * 2], nodes[i * 2 + 1]);\n  }\n};\nSubstringHash::Hash getHash(int h1, int n, int i1, int mid,\n                            const SubstringHash &subhS,\n                            const SubstringHash &subhO,\n                            const SubstringHash &subhC) {\n  if (mid <= h1)\n    return subhO.hash(0, mid);\n  else if (mid <= h1 + n)\n    return subhS.append(subhO.hash(0, mid), subhS.hash(i1, i1 + (mid - h1)),\n                        mid - h1);\n  else\n    return subhC.append(\n        subhS.append(subhO.hash(0, mid), subhS.hash(i1, i1 + n), n),\n        subhC.hash(0, mid - h1 - n), mid - h1 - n);\n}\nchar getChar(int h1, int n, int i1, int mid, const char *S) {\n  if (mid < h1)\n    return '(';\n  else if (mid < h1 + n)\n    return S[i1 + (mid - h1)];\n  else\n    return ')';\n}\nbool compare(int n, int len1, int len2, int i1, int i2, int h1, int h2,\n             const char *S, const SubstringHash &subhS,\n             const SubstringHash &subhO, const SubstringHash &subhC) {\n  if (len1 != len2) return len1 < len2;\n  int len = len1;\n  int l = 0, u = len;\n  while (u - l > 0) {\n    int mid = (l + u + 1) / 2;\n    SubstringHash::Hash h = getHash(h1, n, i1, mid, subhS, subhO, subhC);\n    SubstringHash::Hash g = getHash(h2, n, i2, mid, subhS, subhO, subhC);\n    if (h == g)\n      l = mid;\n    else\n      u = mid - 1;\n  }\n  return getChar(h1, n, i1, l, S) < getChar(h2, n, i2, l, S);\n}\nint main() {\n  char *S = new char[2000001];\n  char *ans = new char[2000001];\n  while (~scanf(\"%s\", S)) {\n    int n = strlen(S);\n    for (int(i) = 0; (i) < (int)(n); ++(i)) S[n + i] = S[i];\n    S[n + n] = 0;\n    SubstringHash subhS, subhO, subhC;\n    subhS.init(S, n + n);\n    string O(n + n, '('), C(n + n, ')');\n    subhO.init(O, O.size());\n    subhC.init(C, C.size());\n    int minLen = 0x3f3f3f3f;\n    int minHead = 0, minPos = -1;\n    GetRangeSegmentTree segt;\n    segt.init(vector<Sum>(S, S + (n + n)));\n    for (int(i) = 0; (i) < (int)(n); ++(i)) {\n      Sum sum = segt.getRange(i, i + n);\n      int len = n + sum.addLv + -sum.miniLv * 2;\n      int head = -sum.miniLv;\n      if (compare(n, len, minLen, i, minPos, head, minHead, S, subhS, subhO,\n                  subhC)) {\n        minLen = len;\n        minPos = i;\n        minHead = head;\n      }\n    }\n    char *p = ans;\n    for (int(k) = 0; (k) < (int)(minHead); ++(k)) *(p++) = '(';\n    for (int(i) = 0; (i) < (int)(n); ++(i)) *(p++) = S[minPos + i];\n    for (int(i) = 0; (i) < (int)(minLen - n - minHead); ++(i)) *(p++) = ')';\n    *p = 0;\n    puts(ans);\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2E6 + 5, MOD = 1E9 + 7;\nint n, sum[N];\nlong long hsh[N], pw[N] = {1};\nchar s[N];\npair<int, int> ans = {N, N};\ndeque<int> de;\nlong long get_hash(int l, int r) {\n  return (hsh[r] - hsh[l - 1] * pw[r - l + 1] + 1LL * MOD * MOD) % MOD;\n}\nbool compare(int u, int v) {\n  int le = 0, ri = n - 1;\n  while (le <= ri) {\n    int mi = (le + ri) / 2;\n    if (get_hash(u, u + mi) == get_hash(v, v + mi)) {\n      le = mi + 1;\n    } else {\n      ri = mi - 1;\n    }\n  }\n  if (le == n) {\n    return true;\n  } else {\n    return s[u + le] < s[v + le];\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cin >> s;\n  n = strlen(s);\n  for (int i = 0; i < n; i++) {\n    s[i + n] = s[i];\n    sum[i + n] = sum[i] = (s[i] == '(' ? 1 : -1);\n    hsh[i + n] = hsh[i] = (s[i] == '(' ? 0 : 1);\n  }\n  for (int i = 1; i < 2 * n; i++) {\n    sum[i] += sum[i - 1];\n    pw[i] = pw[i - 1] * 2 % MOD;\n    (hsh[i] += hsh[i - 1] * 2) %= MOD;\n  }\n  for (int i = 0; i < n; i++) {\n    while (!de.empty() && sum[de.back()] >= sum[i]) {\n      de.pop_back();\n    }\n    de.push_back(i);\n  }\n  for (int i = n; i < 2 * n; i++) {\n    int u = i - n + 1;\n    while (!de.empty() && sum[de.back()] >= sum[i]) {\n      de.pop_back();\n    }\n    de.push_back(i);\n    while (!de.empty() && de.front() < i - n) {\n      de.pop_front();\n    }\n    int len = sum[i - n] - sum[de.front()];\n    if (len < ans.first) {\n      ans = {len, u};\n    } else if (len == ans.first && compare(u, ans.second)) {\n      ans = {len, u};\n    }\n  }\n  for (int i = 0; i < ans.first; i++) {\n    cout << '(';\n  }\n  for (int i = 0; i < n; i++) {\n    cout << s[ans.second % n + i];\n  }\n  for (int i = 0; i < ans.first + sum[n - 1]; i++) {\n    cout << ')';\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ninline long long pow(long long a, long long b, long long mo) {\n  if (!a) return 0;\n  long long tmp = 1;\n  for (; b; b >>= 1) {\n    if (b & 1) tmp = (long long)tmp * a % mo;\n    a = (long long)a * a % mo;\n  }\n  return tmp;\n}\ntemplate <class T>\ninline void R(T &xx) {\n  xx = 0;\n  char ch = getchar();\n  bool F = 0;\n  while ((ch < '0' || ch > '9') && ch != '-') ch = getchar();\n  if (ch == '-') F = 1, ch = getchar();\n  while (ch >= '0' && ch <= '9')\n    xx = xx + xx + (xx << 3) + ch - 48, ch = getchar();\n  if (F) xx = -xx;\n}\nchar s[2000011];\nint n;\nint w[2000011], wa[2000011], wb[2000011], sa[2000011], r[2000011];\nvoid da(char a[], int n, int m) {\n  int p, *x = wa, *y = wb;\n  n++;\n  for (int i = (0); i <= (m); i++) w[i] = 0;\n  for (int i = 0; i < (int)(n); i++) w[r[i] = a[i]]++;\n  for (int i = (1); i <= (m); i++) w[i] += w[i - 1];\n  for (int i = 0; i < (int)(n); i++) sa[--w[a[i]]] = i;\n  for (int j = 1;; j <<= 1, m = p) {\n    p = 0;\n    for (int i = (n - j); i < (int)(n); i++) y[p++] = i;\n    for (int i = 0; i < (int)(n); i++)\n      if (sa[i] >= j) y[p++] = sa[i] - j;\n    for (int i = (0); i <= (m); i++) w[i] = 0;\n    for (int i = 0; i < (int)(n); i++) w[r[i]]++;\n    for (int i = (1); i <= (m); i++) w[i] += w[i - 1];\n    for (int i = (n)-1; ~i; i--) sa[--w[r[y[i]]]] = y[i];\n    for (int i = 0; i < (int)(n); i++) x[i] = r[i];\n    p = 1;\n    r[sa[0]] = 0;\n    for (int i = (1); i < (int)(n); i++)\n      r[sa[i]] = (x[sa[i]] == x[sa[i - 1]] && x[sa[i] + j] == x[sa[i - 1] + j])\n                     ? p - 1\n                     : p++;\n    if (p == n) break;\n  }\n}\npair<int, int> seg[2000011 << 2];\nvoid build(int p, int l, int r) {\n  if (l == r) {\n    seg[p] = (s[l] == 1) ? make_pair(1, 0) : make_pair(-1, -1);\n    return;\n  }\n  int mid = l + r >> 1;\n  build((p << 1), l, mid);\n  build((p << 1 | 1), mid + 1, r);\n  seg[p] = make_pair(seg[(p << 1)].first + seg[(p << 1 | 1)].first,\n                     min(seg[(p << 1)].second,\n                         seg[(p << 1)].first + seg[(p << 1 | 1)].second));\n}\npair<int, int> que(int p, int l, int r, int L, int R) {\n  if (L <= l && R >= r) return seg[p];\n  int mid = l + r >> 1;\n  if (R <= mid) return que((p << 1), l, mid, L, R);\n  if (L > mid) return que((p << 1 | 1), mid + 1, r, L, R);\n  pair<int, int> le = que((p << 1), l, mid, L, R),\n                 ri = que((p << 1 | 1), mid + 1, r, L, R);\n  return make_pair(le.first + ri.first, min(le.second, le.first + ri.second));\n}\nint main() {\n  gets(s);\n  int l = n = strlen(s);\n  for (int i = 0; i < (int)(n); i++) s[i + n] = (s[i] = (s[i] == '(' ? 1 : 2));\n  n <<= 1;\n  da(s, n, 3);\n  int cnt = 0, addl = 0, addr = 0;\n  for (int i = 0; i < (int)(l); i++)\n    if (s[i] == 1)\n      cnt++;\n    else\n      cnt--;\n  if (cnt > 0)\n    addr = cnt;\n  else\n    addl = -cnt;\n  build(1, 0, n - 1);\n  for (int i = (1); i <= (n); i++)\n    if (sa[i] < l &&\n        addl + que(1, 0, n - 1, sa[i], sa[i] + l - 1).second >= 0) {\n      for (int j = 0; j < (int)(addl); j++) putchar('(');\n      for (int j = (sa[i]); j <= (sa[i] + l - 1); j++)\n        putchar((s[j] == 2) ? ')' : '(');\n      for (int j = 0; j < (int)(addr); j++) putchar(')');\n      puts(\"\");\n      return 0;\n    }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, s[2000100];\nbool vis[2000100];\nchar t[2000100];\nint sa[2000100], rnk[2000100], tmp[2000100], cnt[2000100];\nvoid build(char *s) {\n  int n = strlen(s) + 1, m = 256;\n  int *x = rnk, *y = tmp, *z;\n  for (int i = 0; i < m; i++) cnt[i] = 0;\n  for (int i = 0; i < n; i++) cnt[x[i] = s[i]]++;\n  for (int i = 1; i < m; i++) cnt[i] += cnt[i - 1];\n  for (int i = n - 1; i >= 0; i--) sa[--cnt[x[i]]] = i;\n  for (int j = 1, p = 1; p < n; j <<= 1, m = p) {\n    p = 0;\n    for (int i = n - j; i < n; i++) y[p++] = i;\n    for (int i = 0; i < n; i++)\n      if (sa[i] >= j) y[p++] = sa[i] - j;\n    for (int i = 0; i < m; i++) cnt[i] = 0;\n    for (int i = 0; i < n; i++) cnt[x[i]]++;\n    for (int i = 1; i < m; i++) cnt[i] += cnt[i - 1];\n    for (int i = n - 1; i >= 0; i--) sa[--cnt[x[y[i]]]] = y[i];\n    z = x, x = y, y = z;\n    x[sa[0]] = 0, p = 1;\n    for (int i = 1; i < n; i++)\n      x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + j] == y[sa[i - 1] + j])\n                     ? p - 1\n                     : p++;\n  }\n  for (int i = 0; i < n; i++) rnk[sa[i]] = i;\n}\nint main() {\n  scanf(\"%s\", t + 1);\n  n = strlen(t + 1);\n  int mn = 0;\n  for (int i = 1; i <= n; i++) {\n    s[i] = s[i - 1];\n    if (t[i] == '(')\n      s[i]++;\n    else\n      s[i]--;\n    mn = min(mn, s[i]);\n  }\n  for (int i = 1; i <= n; i++) t[n + i] = t[i], s[i + n] = s[i] + s[n];\n  int dn = 0;\n  if (s[n] < 0) dn = -s[n];\n  build(t + 1);\n  multiset<int> S;\n  for (int i = n + 1; i <= 2 * n; i++) S.insert(s[i]);\n  int k, p = 1e9;\n  for (int i = n; i >= 0; i--) {\n    int t = *S.begin();\n    S.erase(S.find(s[i + n]));\n    if (t - s[i] + dn >= 0) {\n      if (rnk[i] < p) p = rnk[i], k = i + 1;\n    }\n    S.insert(s[i]);\n  }\n  int sum = s[n];\n  if (sum < 0)\n    for (int i = sum; i < 0; i++) putchar('(');\n  for (int i = 0; i < n; i++) putchar(t[k + i]);\n  if (sum > 0)\n    for (int i = 0; i < sum; i++) putchar(')');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar str[1000006];\nstruct SuffixArray {\n  SuffixArray(string _s) { initialize(_s); };\n  void initialize(string _s = \"\") {\n    s = _s;\n    p.clear();\n    p.resize(s.size());\n    pn.clear();\n    pn.resize(s.size());\n    c.clear();\n    c.resize(s.size());\n    cn.clear();\n    cn.resize(s.size());\n    cnt.clear();\n    cnt.resize(alphabetSize = max(256, (int)s.size()));\n  }\n  void build(bool withLcp = false) {\n    for (int i = 0; i < s.size(); ++i) {\n      cnt[s[i]]++;\n    }\n    for (int i = 1; i < 256; ++i) cnt[i] += cnt[i - 1];\n    for (int i = s.size() - 1; i >= 0; --i) p[--cnt[s[i]]] = i;\n    int classes = 1;\n    c[p[0]] = 0;\n    for (int i = 1; i < p.size(); ++i) {\n      if (s[p[i]] != s[p[i - 1]]) ++classes;\n      c[p[i]] = classes - 1;\n    }\n    for (int h = 0; (1 << h) < s.size(); ++h) {\n      for (int i = 0; i < p.size(); ++i) {\n        pn[i] = p[i] - (1 << h);\n        if (pn[i] < 0) pn[i] += s.size();\n      }\n      cnt.assign(alphabetSize, 0);\n      for (int i = 0; i < pn.size(); ++i) ++cnt[c[pn[i]]];\n      for (int i = 1; i < cnt.size(); ++i) cnt[i] += cnt[i - 1];\n      for (int i = pn.size() - 1; i >= 0; --i) {\n        p[--cnt[c[pn[i]]]] = pn[i];\n      }\n      classes = 1;\n      cn[p[0]] = 0;\n      for (int i = 1; i < p.size(); ++i) {\n        int mid1 = (p[i - 1] + (1 << h)) % s.size(),\n            mid2 = (p[i] + (1 << h)) % s.size();\n        if (c[p[i - 1]] != c[p[i]] || c[mid1] != c[mid2]) ++classes;\n        cn[p[i]] = classes - 1;\n      }\n      c = cn;\n      if (classes == s.size()) break;\n    }\n    if (withLcp) buildLcp();\n  }\n  void buildLcp() {\n    lcp.clear();\n    lcp.resize(s.size());\n    rev.clear();\n    rev.resize(s.size());\n    for (int i = 0; i < p.size(); ++i) rev[p[i]] = i;\n    int cur = 0;\n    for (int i = 0; i < s.size(); ++i) {\n      if (cur > 0) --cur;\n      if (rev[i] == 0) continue;\n      while (i + cur < s.size() && s[i + cur] == s[p[rev[i] - 1] + cur]) ++cur;\n      lcp[rev[i]] = cur;\n    }\n  }\n  void output() {\n    for (int i = 0; i < p.size(); ++i) cout << p[i] << \" \";\n    cout << endl;\n    for (int i = 0; i < p.size(); ++i) {\n      cout << s.substr(p[i]) << endl;\n    }\n    if (lcp.size() == s.size()) {\n      for (int i = 0; i < lcp.size(); ++i) cout << lcp[i] << \" \";\n      cout << endl;\n    }\n  }\n  string s;\n  int alphabetSize;\n  vector<int> p, c, pn, cn, cnt, lcp, rev;\n};\nint bal[1000006];\nint pref[1000006];\nint suf[1000006];\nint main() {\n  gets(str);\n  int n = strlen(str);\n  SuffixArray sufa(str);\n  sufa.build();\n  int open = 0, cl = 0;\n  for (int i = 0; i < n; ++i) {\n    bal[i] += str[i] == '(' ? 1 : -1;\n    if (i) bal[i] += bal[i - 1];\n    if (str[i] == '(')\n      ++open;\n    else\n      ++cl;\n  }\n  for (int i = 0; i < n; ++i) {\n    pref[i] = bal[i];\n    if (i) pref[i] = min(pref[i], pref[i - 1]);\n  }\n  for (int i = n - 1; i >= 0; --i) {\n    suf[i] = bal[i];\n    if (i + 1 < n) suf[i] = min(suf[i], suf[i + 1]);\n  }\n  int mx = -100000000, mn = 100000000;\n  for (int i = 0; i < n; ++i) {\n    int total = 0;\n    total = min(suf[i] - (i > 0 ? bal[i - 1] : 0), 0);\n    total =\n        min(bal[n - 1] - (i > 0 ? bal[i - 1] : 0) + (i > 0 ? pref[i - 1] : 0),\n            total);\n    if (total >= 0)\n      mn = min(mn, total);\n    else {\n      mx = max(mx, total);\n    }\n  }\n  string s1 = \"\", s2 = \"\";\n  for (int i = 0; i < n; ++i) {\n    int ind = sufa.p[i];\n    int total = 0;\n    total = min(suf[ind] - (ind > 0 ? bal[ind - 1] : 0), 0);\n    total = min(bal[n - 1] - (ind > 0 ? bal[ind - 1] : 0) +\n                    (ind > 0 ? pref[ind - 1] : 0),\n                total);\n    if (s1 == \"\" && total == mx) {\n      s1 = string(-total, '(');\n      for (int j = 0; j < n; ++j) s1 += str[(ind + j) % n];\n      int add = -total + open - cl;\n      if (add > 0) s1 += string(add, ')');\n    }\n    if (s2 == \"\" && total == mn) {\n      for (int j = 0; j < n; ++j) s2 += str[(ind + j) % n];\n      int add = open - cl;\n      if (add > 0) s2 += string(add, ')');\n    }\n  }\n  string s;\n  if (s1 != \"\") s = s1;\n  if (s2 != \"\" &&\n      (s == \"\" || s.size() > s2.size() || s.size() == s2.size() && s > s2))\n    s = s2;\n  printf(\"%s\\n\", s.c_str());\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class A {\n\tFastScanner in;\n\tPrintWriter out;\n\n\tprivate class StringHash {\n\t\tprivate int[] val1;\n\t\tprivate HashHelper helper;\n\t\tString s;\n\n\t\tpublic StringHash(int[] val1, HashHelper helper, String s) {\n\t\t\tsuper();\n\t\t\tthis.val1 = val1;\n\t\t\tthis.helper = helper;\n\t\t\tthis.s = s;\n\t\t}\n\n\t\tpublic int getIntHash(int l, int r) {\n\t\t\tlong result = val1[r + 1] - val1[l] * 1L * helper.pow1[r - l + 1];\n\t\t\tresult %= helper.MOD1;\n\t\t\tif (result < 0) {\n\t\t\t\tresult += helper.MOD1;\n\t\t\t}\n\t\t\treturn (int) result;\n\t\t}\n\n\t}\n\n\tprivate class HashHelper {\n\t\tfinal Random rnd = new Random();\n\t\tfinal int BILLION = (int) 1e9;\n\t\tfinal int MUL = 239;\n\t\tfinal int MOD1 = BigInteger\n\t\t\t\t.valueOf(BILLION + rnd.nextInt(BILLION / 10))\n\t\t\t\t.nextProbablePrime().intValue();\n\t\tfinal int MOD2 = BigInteger\n\t\t\t\t.valueOf(BILLION + rnd.nextInt(BILLION / 10))\n\t\t\t\t.nextProbablePrime().intValue();\n\t\tint[] pow1;\n\n\t\tpublic HashHelper(final int n) {\n\t\t\tpow1 = new int[n];\n\t\t\tpow1[0]= 1;\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tpow1[i] = (int) (pow1[i - 1] * 1L * MUL % MOD1);\n\t\t\t}\n\t\t}\n\n\t\tStringHash generateHash(String s) {\n\t\t\treturn new StringHash(generateIntHash(s, MOD1), this, s);\n\t\t}\n\n\t\tpublic int compareInt(StringHash s1, int from1, int to1, StringHash s2,\n\t\t\t\tint from2, int to2) {\n\t\t\tint len = Math.min(to1 - from1, to2 - from2) + 1;\n\t\t\tint l = 0, r = len + 1;\n\t\t\twhile (r - l > 1) {\n\t\t\t\tint mid = (l + r) >>> 1;\n\t\t\t\tif (s1.getIntHash(from1, from1 + mid - 1) == s2.getIntHash(\n\t\t\t\t\t\tfrom2, from2 + mid - 1)) {\n\t\t\t\t\tl = mid;\n\t\t\t\t} else {\n\t\t\t\t\tr = mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (l == len) {\n\t\t\t\tif (to1 - from1 == to2 - from2) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\treturn (to1 - from1) - (to2 - from2);\n\t\t\t}\n\t\t\treturn s1.s.charAt(from1 + l) - s2.s.charAt(from2 + l);\n\t\t}\n\n\t\tprivate int[] generateIntHash(String s, int MOD) {\n\t\t\tint[] result = new int[s.length() + 1];\n\t\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\t\tresult[i + 1] = (int) ((result[i] * 1L * MUL + s.charAt(i)) % MOD);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid solve() {\n\t\tString s = in.next();\n\t\tint n = s.length();\n\t\ts = s + s;\n\t\tHashHelper helper = new HashHelper(s.length() + 1);\n\t\tStringHash hash = helper.generateHash(s);\n\t\tint[] bal = new int[n + n - 1];\n\t\tfor (int i = 0; i < n + n - 1; i++) {\n\t\t\tif (s.charAt(i) == '(') {\n\t\t\t\tbal[i]++;\n\t\t\t} else {\n\t\t\t\tbal[i]--;\n\t\t\t}\n\t\t\tif (i > 0) {\n\t\t\t\tbal[i] += bal[i - 1];\n\t\t\t}\n\t\t}\n\t\tint cur = s.length() - 1;\n\t\tint[] balanceChange = new int[n];\n\t\tint[] qPos = new int[n + n];\n\t\tint[] qValue = new int[n + n];\n\t\tint qSz = 0, qFrom = 0;\n\t\tfor (int pos = n - 1; pos >= 0; pos--) {\n\t\t\twhile (cur != pos) {\n\t\t\t\tcur--;\n\t\t\t\tint value = bal[cur];\n\t\t\t\twhile (qSz > qFrom && qValue[qSz - 1] >= value) {\n\t\t\t\t\tqSz--;\n\t\t\t\t}\n\t\t\t\tqValue[qSz] = value;\n\t\t\t\tqPos[qSz] = cur;\n\t\t\t\tqSz++;\n\t\t\t}\n\t\t\twhile (qPos[qFrom] >= pos + n) {\n\t\t\t\tqFrom++;\n\t\t\t}\n\t\t\tint prevBalance = pos > 0 ? bal[pos - 1] : 0;\n\t\t\tbalanceChange[pos] = qValue[qFrom] - prevBalance;\n\t\t}\n\t\tint cntOpen = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (s.charAt(i) == '(') {\n\t\t\t\tcntOpen++;\n\t\t\t} else {\n\t\t\t\tcntOpen--;\n\t\t\t}\n\t\t}\n\t\tint maxBalanceChange = 0;\n\t\tif (cntOpen < 0) {\n\t\t\tmaxBalanceChange = cntOpen;\n\t\t}\n\t\tint bestCandidate = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (balanceChange[i] >= maxBalanceChange) {\n\t\t\t\tif (bestCandidate != -1) {\n\t\t\t\t\tif (helper.compareInt(hash, i, i + n - 1, hash,\n\t\t\t\t\t\t\tbestCandidate, bestCandidate + n - 1) >= 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbestCandidate = i;\n\t\t\t}\n\t\t}\n\t\tif (bestCandidate < 0) {\n\t\t\tthrow new AssertionError();\n\t\t}\n\t\tfor (int i = 0; i < -cntOpen; i++) {\n\t\t\tout.print(\"(\");\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tout.print(s.charAt(i + bestCandidate));\n\t\t}\n\t\tfor (int i = 0; i < cntOpen; i++) {\n\t\t\tout.print(\")\");\n\t\t}\n\t}\n\n\tvoid run() {\n\t\ttry {\n\t\t\tin = new FastScanner(new File(\"A.in\"));\n\t\t\tout = new PrintWriter(new File(\"A.out\"));\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (FileNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tvoid runIO() {\n\n\t\tin = new FastScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\n\t\tout.close();\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner(File f) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(f));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic FastScanner(InputStream f) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(f));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\tString s = null;\n\t\t\t\ttry {\n\t\t\t\t\ts = br.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (s == null)\n\t\t\t\t\treturn null;\n\t\t\t\tst = new StringTokenizer(s);\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tboolean hasMoreTokens() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\tString s = null;\n\t\t\t\ttry {\n\t\t\t\t\ts = br.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (s == null)\n\t\t\t\t\treturn false;\n\t\t\t\tst = new StringTokenizer(s);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew A().runIO();\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int N = 2000010;\nint sa[N], t[N], t2[N], c[N], wt[N];\nbool cmp(int *r, int a, int b, int l) {\n  return r[a] == r[b] && r[a + l] == r[b + l];\n}\nvoid build_sa(char *s, int n, int m) {\n  int p = 1, *x = t, *y = t2;\n  for (int i = 0; i < m; i++) c[i] = 0;\n  for (int i = 0; i < n; i++) c[x[i] = s[i]]++;\n  for (int i = 1; i < m; i++) c[i] += c[i - 1];\n  for (int i = n - 1; i >= 0; i--) sa[--c[x[i]]] = i;\n  for (int j = 1; p < n; j <<= 1, m = p) {\n    p = 0;\n    for (int i = n - j; i < n; i++) y[p++] = i;\n    for (int i = 0; i < n; i++)\n      if (sa[i] >= j) {\n        y[p++] = sa[i] - j;\n      }\n    for (int i = 0; i < n; i++) wt[i] = x[y[i]];\n    for (int i = 0; i < m; i++) c[i] = 0;\n    for (int i = 0; i < n; i++) c[wt[i]]++;\n    for (int i = 1; i < m; i++) c[i] += c[i - 1];\n    for (int i = n - 1; i >= 0; i--) {\n      sa[--c[wt[i]]] = y[i];\n    }\n    std::swap(x, y);\n    p = 1, x[sa[0]] = 0;\n    for (int i = 1; i < n; i++)\n      x[sa[i]] = cmp(y, sa[i - 1], sa[i], j) ? p - 1 : p++;\n  }\n}\nint rnk[N], H[N];\nvoid getheight(char *s, int n) {\n  int i, j, k = 0;\n  for (i = 1; i <= n; i++) rnk[sa[i]] = i;\n  for (i = 0; i < n; H[rnk[i++]] = k)\n    for (k ? k-- : 0, j = sa[rnk[i] - 1]; s[i + 1] == s[j + k]; k++)\n      ;\n}\nchar s[N];\nint sum[N];\nint min[N][25];\nvoid build_rmq(int *sum, int n) {\n  for (int i = 0; i < n; i++) min[i][0] = sum[i];\n  for (int j = 1, p = 2; p < n; j++, p <<= 1) {\n    for (int i = 0; i + p - 1 < n; i++) {\n      min[i][j] = std::min(min[i][j - 1], min[i + p / 2][j - 1]);\n    }\n  }\n}\nint Getmin(int a, int b) {\n  if (a > b) std::swap(a, b);\n  int k = log(1.0 * (b - a + 1)) / log(2.0);\n  return std::min(min[a][k], min[b - (1 << k) + 1][k]);\n}\nint A, B;\nvoid Go(int n) {\n  int res = -1;\n  for (int i = 1; i <= n; i++) {\n    if (sa[i] >= n / 2) continue;\n    int low = Getmin(sa[i], sa[i] + n / 2 - 1);\n    if (sa[i]) low -= sum[sa[i] - 1];\n    if (low < 0 && low - A < 0) continue;\n    res = sa[i];\n    break;\n  }\n  assert(res != -1);\n  if (A < 0) {\n    for (int i = 0; i < -A; i++) putchar('(');\n  }\n  for (int i = res; i < res + n / 2; i++) putchar(s[i]);\n  if (A > 0) {\n    for (int i = 0; i < A; i++) putchar(')');\n  }\n  puts(\"\");\n}\nint main() {\n  int n;\n  scanf(\"%s\", s);\n  n = strlen(s);\n  for (int i = 0; i < n; i++) {\n    s[i + n] = s[i];\n    if (s[i] == '(') {\n      sum[i] = sum[i + n] = 1;\n    } else {\n      sum[i] = sum[i + n] = -1;\n    }\n    if (s[i] == '(')\n      A++;\n    else\n      B++;\n  }\n  A -= B;\n  n <<= 1;\n  for (int i = 1; i < n; i++) {\n    sum[i] += sum[i - 1];\n  }\n  build_rmq(sum, n);\n  s[n] = 0;\n  build_sa(s, n + 1, 45);\n  Go(n);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 3;\nconst int M = 4e6 + 3;\nconst int ym = 2e6;\nconst int oo = 1e9;\nconst int OS = 317;\nconst int MOD = 1e9 + 7;\nchar s[N];\nint n, stp[M], p1[N], p2[N], s1[N], s2[N], ho[N], hz[N], h[N], op[N], zp[N],\n    os[N], zs[N], il[N], ir[N];\nvector<int> st;\nint get(int i, int ln) {\n  int ans, tmp, lt, l;\n  lt = min(il[i], ln);\n  ans = ho[lt] * 1LL * stp[ym] % MOD;\n  l = lt;\n  lt = max(0, min(n - i, ln - l));\n  if (lt) ans = (ans + (h[i + lt] - h[i]) * 1LL * stp[ym + l - i] % MOD) % MOD;\n  l += lt;\n  lt = max(0, min(i, ln - l));\n  if (lt) ans = (ans + h[lt] * 1LL * stp[ym + l] % MOD) % MOD;\n  l += lt;\n  lt = max(0, ln - l);\n  if (lt) ans = (ans + hz[lt] * 1LL * stp[ym + l] % MOD) % MOD;\n  if (ans < 0) ans += MOD;\n  return ans;\n}\nint get_ch(int i, int ln) {\n  if (ln <= il[i]) return '(';\n  ln -= il[i];\n  if (ln <= n - i) return s[i + ln];\n  ln -= n - i;\n  if (ln <= i)\n    return s[ln];\n  else\n    return ')';\n}\nint ans;\nbool cmp(int i, int j) {\n  int l, r, x;\n  l = 1, r = ans;\n  while (l <= r) {\n    x = (l + r) >> 1;\n    if (get(i, x) == get(j, x))\n      l = x + 1;\n    else\n      r = x - 1;\n  }\n  return get_ch(i, r + 1) <= get_ch(j, r + 1);\n}\nint main() {\n  if (0) {\n    freopen(\"input.txt\", \"w\", stdout);\n    int n = 1e6;\n    for (int i = 0; i < n; ++i) printf(\"(\");\n    printf(\"\\n\");\n    return 0;\n  }\n  int i, j, len, mn;\n  gets(s + 1);\n  n = strlen(s + 1);\n  for (i = 1; i <= n; ++i)\n    if (s[i] == '(')\n      p1[i] = p1[i - 1], p2[i] = p2[i - 1] + 1;\n    else if (p2[i - 1])\n      p1[i] = p1[i - 1] + 2, p2[i] = p2[i - 1] - 1;\n    else\n      p1[i] = p1[i - 1], p2[i] = p2[i - 1];\n  for (i = n; i; --i)\n    if (s[i] == ')')\n      s1[i] = s1[i + 1], s2[i] = s2[i + 1] + 1;\n    else if (s2[i + 1])\n      s1[i] = s1[i + 1] + 2, s2[i] = s2[i + 1] - 1;\n    else\n      s1[i] = s1[i + 1], s2[i] = s2[i + 1];\n  for (i = 0; i <= n; ++i) {\n    op[i] = p2[i];\n    zp[i] = i - p1[i] - op[i];\n    zs[i] = s2[i + 1];\n    os[i] = n - i - s1[i + 1] - zs[i];\n    il[i] = zs[i];\n    ir[i] = op[i];\n    if (os[i] > zp[i])\n      ir[i] += os[i] - zp[i];\n    else\n      il[i] += zp[i] - os[i];\n  }\n  ans = oo;\n  for (i = 0; i < n; ++i) {\n    len = n + zs[i] + op[i] + max(os[i], zp[i]) - min(os[i], zp[i]);\n    if (ans > len) st.clear();\n    if (ans >= len) ans = len, st.push_back(i);\n  }\n  stp[0] = 1;\n  for (i = 1; i < M; ++i) stp[i] = (stp[i - 1] * 1LL * OS) % MOD;\n  ho[0] = hz[0] = 0;\n  for (i = 1; i < N; ++i)\n    ho[i] = (ho[i - 1] + '(' * 1LL * stp[i - 1] % MOD) % MOD;\n  for (i = 1; i < N; ++i)\n    hz[i] = (hz[i - 1] + ')' * 1LL * stp[i - 1] % MOD) % MOD;\n  h[0] = 0;\n  for (i = 1; i <= n; ++i)\n    h[i] = (h[i - 1] + s[i] * 1LL * stp[i - 1] % MOD) % MOD;\n  mn = st[0];\n  for (i = 1; i < st.size(); ++i)\n    if (cmp(st[i], mn)) mn = st[i];\n  i = mn;\n  for (j = 0; j < il[i]; ++j) putchar('(');\n  for (j = i + 1; j <= n; ++j) putchar(s[j]);\n  for (j = 1; j <= i; ++j) putchar(s[j]);\n  for (j = 0; j < ir[i]; ++j) putchar(')');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int LEN = 2000100 * 3;\nint r[LEN], sa[LEN];\nint wa[LEN], wb[LEN], wv[LEN], ss[LEN];\nint c0(int *r, int a, int b) {\n  return r[a] == r[b] && r[a + 1] == r[b + 1] && r[a + 2] == r[b + 2];\n}\nint c12(int k, int *r, int a, int b) {\n  if (k == 2) return r[a] < r[b] || r[a] == r[b] && c12(1, r, a + 1, b + 1);\n  return r[a] < r[b] || r[a] == r[b] && wv[a + 1] < wv[b + 1];\n}\nvoid sort(int *r, int *a, int *b, int n, int m) {\n  for (int i = 0; i < n; i++) wv[i] = r[a[i]];\n  for (int i = 0; i < m; i++) ss[i] = 0;\n  for (int i = 0; i < n; i++) ss[wv[i]]++;\n  for (int i = 1; i < m; i++) ss[i] += ss[i - 1];\n  for (int i = n - 1; i >= 0; i--) b[--ss[wv[i]]] = a[i];\n}\nvoid DC3(int *r, int *sa, int n, int m) {\n  int i, j, p;\n  int *san = sa + n, *rn = r + n;\n  int ta = 0, tb = (n + 1) / 3, tbc = 0;\n  r[n] = r[n + 1] = 0;\n  for (i = 0; i < n; i++)\n    if (i % 3 != 0) wa[tbc++] = i;\n  sort(r + 2, wa, wb, tbc, m);\n  sort(r + 1, wb, wa, tbc, m);\n  sort(r, wa, wb, tbc, m);\n  for (p = 1, rn[((wb[0]) / 3 + ((wb[0]) % 3 == 1 ? 0 : tb))] = 0, i = 1;\n       i < tbc; i++)\n    rn[((wb[i]) / 3 + ((wb[i]) % 3 == 1 ? 0 : tb))] =\n        c0(r, wb[i - 1], wb[i]) ? p - 1 : p++;\n  if (p < tbc)\n    DC3(rn, san, tbc, p);\n  else\n    for (i = 0; i < tbc; i++) san[rn[i]] = i;\n  for (i = 0; i < tbc; i++)\n    if (san[i] < tb) wb[ta++] = san[i] * 3;\n  if (n % 3 == 1) wb[ta++] = n - 1;\n  sort(r, wb, wa, ta, m);\n  for (i = 0; i < tbc; i++)\n    wv[wb[i] = ((san[i]) < tb ? (san[i]) * 3 + 1 : ((san[i]) - tb) * 3 + 2)] =\n        i;\n  for (i = 0, j = 0, p = 0; i < ta && j < tbc; p++)\n    sa[p] = c12(wb[j] % 3, r, wa[i], wb[j]) ? wa[i++] : wb[j++];\n  for (; i < ta; p++) sa[p] = wa[i++];\n  for (; j < tbc; p++) sa[p] = wb[j++];\n}\nchar s[2000100];\nint val[2000100];\nint rmq[20][1000100];\nint query(int l, int r) {\n  int cnt = r - l + 1, i;\n  for (i = 0; (1 << i) <= cnt; i++)\n    ;\n  i--;\n  return ((rmq[i][l]) < (rmq[i][r - (1 << i) + 1])\n              ? (rmq[i][l])\n              : (rmq[i][r - (1 << i) + 1]));\n}\nint main() {\n  scanf(\"%s\", s);\n  int len = strlen(s);\n  for (int i = 0; i < len; i++) r[i] = r[i + len] = s[i];\n  r[len << 1] = 0;\n  DC3(r, sa, len << 1 | 1, 256);\n  int cur = 0;\n  int ca = 0, cb = 0;\n  for (int i = 0; i < len; i++) {\n    if (s[i] == '(')\n      cur++;\n    else\n      cur--;\n    val[i] = cur;\n  }\n  if (cur > 0)\n    ca = 0, cb = cur;\n  else\n    ca = -cur, cb = 0;\n  for (int i = 0; i < len; i++) rmq[0][i] = val[i];\n  for (int j = 1; (1 << j) <= len; j++) {\n    int k = 1 << (j - 1);\n    for (int i = 0; i + (1 << j) <= len; i++) {\n      rmq[j][i] = ((rmq[j - 1][i]) < (rmq[j - 1][i + k]) ? (rmq[j - 1][i])\n                                                         : (rmq[j - 1][i + k]));\n    }\n  }\n  int pos;\n  for (int j = 0; j <= len + len; j++)\n    if (sa[j] < len) {\n      int i = sa[j];\n      int init = val[i] - ((s[i] == '(') ? 1 : -1);\n      int Min = query(i, len - 1) - init;\n      if (Min + ca < 0) continue;\n      if (i >= 1) {\n        init = val[len - 1] - init;\n        Min = query(0, i - 1) + init + ca;\n        if (Min < 0) continue;\n      }\n      pos = i;\n      break;\n    }\n  for (int i = 0; i < ca; i++) putchar('(');\n  for (int i = pos; i < len; i++) putchar(s[i]);\n  for (int i = 0; i < pos; i++) putchar(s[i]);\n  for (int i = 0; i < cb; i++) putchar(')');\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:200000000\")\nusing namespace std;\ntemplate <typename T>\ninline T Abs(T x) {\n  return (x >= 0) ? x : -x;\n}\ntemplate <typename T>\ninline T sqr(T x) {\n  return x * x;\n}\ntemplate <typename T>\ninline string toStr(T x) {\n  stringstream st;\n  st << x;\n  string s;\n  st >> s;\n  return s;\n}\ntemplate <typename T>\ninline int bit(T mask, int b) {\n  return (b >= 0 && (mask & (T(1) << b)) != 0) ? 1 : 0;\n}\ninline int nextInt() {\n  int x;\n  if (scanf(\"%d\", &x) != 1) throw;\n  return x;\n}\ninline long long nextInt64() {\n  long long x;\n  if (scanf(\"%lld\", &x) != 1) throw;\n  return x;\n}\ninline double nextDouble() {\n  double x;\n  if (scanf(\"%lf\", &x) != 1) throw;\n  return x;\n}\nconst int INF = (int)1E9;\nconst long long INF64 = (long long)1E18;\nconst long double EPS = 1E-9;\nconst long double PI = 3.1415926535897932384626433832795;\nconst int MAXN = 3001000;\nstruct state {\n  state() {}\n  state(int a, int b, int i) : a(a), b(b), id(i) {}\n  bool operator<(const state& s) const {\n    if (a != s.a) return a < s.a;\n    if (b != s.b) return b < s.b;\n    return id < s.id;\n  }\n  bool operator!=(const state& s) const { return a != s.a || b != s.b; }\n  int a, b, id;\n};\nint n, b[MAXN], fw[MAXN], p[MAXN];\nmultiset<int> ms;\nstate v[MAXN];\nchar s[MAXN];\nstruct answer {\n  answer(int b, int a, int i) : before(b), after(a), id(i) {}\n  bool operator<(const answer& a) const {\n    if (before + after != a.before + a.after)\n      return before + after < a.before + a.after;\n    if (before + fw[id] != a.before + fw[a.id])\n      return before + fw[id] > a.before + fw[a.id];\n    return p[(id + fw[id]) % n] < p[(a.id + fw[a.id]) % n];\n  }\n  int before, after, id;\n};\nint getms(int v) {\n  int prv = (v == 0) ? 0 : b[v - 1];\n  return max(0, prv - (*ms.begin()));\n}\nint sum(int before, int v) {\n  int prv = (v == 0) ? 0 : b[v - 1];\n  return b[v + n - 1] - prv + before;\n}\nvoid go(int v) {\n  ms.erase(ms.find(b[v]));\n  ms.insert(b[v + n]);\n}\nint main() {\n  cout.setf(ios::fixed);\n  cout.precision(10);\n  double _startTime = clock();\n  scanf(\" %s\", s);\n  n = int(strlen(s));\n  for (int i = 0; i < (int)(n); i++) {\n    s[i + n] = s[i];\n  }\n  int bal = 0;\n  for (int i = 0; i < (int)(2 * n); i++) {\n    if (s[i] == '(') {\n      p[i] = 0;\n      ++bal;\n    } else {\n      p[i] = 1;\n      --bal;\n    }\n    b[i] = bal;\n  }\n  for (int i = (int)(n)-1; i >= 0; i--) {\n    ms.insert(b[i]);\n    if (s[i] == '(') {\n      fw[i] = fw[i + 1] + 1;\n    }\n  }\n  int k = 1;\n  while (k < n) {\n    for (int i = 0; i < (int)(n); i++) {\n      v[i] = state(p[i], p[(i + k) % n], i);\n    }\n    int cur = 0;\n    sort(v, v + n);\n    for (int i = 0; i < (int)(n); i++) {\n      p[v[i].id] = cur;\n      if (v[i] != v[i + 1]) {\n        ++cur;\n      }\n    }\n    if (cur == n - 1) break;\n    k *= 2;\n  }\n  answer ans(INF, INF, -1);\n  for (int i = 0; i < (int)(n); i++) {\n    int before = getms(i);\n    answer cur(before, sum(before, i), i);\n    ans = min(ans, cur);\n    go(i);\n  };\n  cout << string(size_t(ans.before), '(');\n  for (int i = 0; i < (int)(n); i++) {\n    cout << s[ans.id + i];\n  }\n  cout << string(size_t(ans.after), ')') << endl;\n  cerr << \"Elapsed \" << (clock() - _startTime) / CLOCKS_PER_SEC << \" s\" << endl;\n  return 0;\n};\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nclass SA_IS {\n  vector<int> compress(vector<int>& v) {\n    set<int> alph(v.begin(), v.end());\n    vector<int> dic(alph.begin(), alph.end());\n    vector<int> bucket_size(dic.size(), 0);\n    for (int i = 0; i < v.size(); i++) {\n      v[i] = lower_bound(dic.begin(), dic.end(), v[i]) - dic.begin();\n      bucket_size[v[i]]++;\n    }\n    return bucket_size;\n  }\n\n public:\n  static const int L = 0;\n  static const int S = 1;\n  string my_s;\n  vector<int> sa;\n  vector<int> lcp;\n  struct substring {\n    int pos;\n    int size;\n    vector<int>::iterator str;\n    vector<int>::iterator ls;\n    substring() {}\n    substring(const int pos, const int size, const vector<int>::iterator& str,\n              const vector<int>::iterator& ls) {\n      this->pos = pos;\n      this->size = size;\n      this->str = str;\n      this->ls = ls;\n    }\n    bool operator<(const substring& x) const {\n      for (int i = 0; i < min(this->size, x.size); i++) {\n        if (this->str[i] != x.str[i]) {\n          return this->str[i] < x.str[i];\n        } else if (this->ls[i] != x.ls[i]) {\n          return this->ls[i] == SA_IS::L;\n        }\n      }\n      return this->size < x.size;\n    }\n    bool operator==(const substring& x) const {\n      for (int i = 0; i < min(this->size, x.size); i++) {\n        if (this->str[i] != x.str[i]) {\n          return false;\n        } else if (this->ls[i] != x.ls[i]) {\n          return false;\n        }\n      }\n      return this->size == x.size;\n    }\n    substring operator=(const substring& x) {\n      this->pos = x.pos;\n      this->size = x.size;\n      this->str = x.str;\n      this->ls = x.ls;\n      return *this;\n    }\n  };\n  vector<int> rec(vector<int> v) {\n    v.push_back(-1);\n    vector<int> bucket_size = compress(v);\n    vector<int> ret(v.size(), -1);\n    vector<vector<int>::iterator> bucket(bucket_size.size());\n    vector<bool> fixed(v.size(), false);\n    vector<vector<bool>::iterator> bucket_fixed(bucket_size.size());\n    vector<int> bucket_front(bucket_size.size());\n    vector<int> bucket_back(bucket_size.size());\n    vector<bool> used(v.size(), false);\n    {\n      int sum = 0;\n      for (int i = 0; i < bucket_size.size(); i++) {\n        bucket[i] = ret.begin() + sum;\n        bucket_fixed[i] = fixed.begin() + sum;\n        bucket_front[i] = 0;\n        bucket_back[i] = bucket_size[i] - 1;\n        sum += bucket_size[i];\n      }\n    }\n    vector<int> LS(v.size());\n    LS.back() = S;\n    for (int i = v.size() - 2; i >= 0; i--) {\n      if (v[i] < v[i + 1])\n        LS[i] = S;\n      else if (v[i] > v[i + 1])\n        LS[i] = L;\n      else\n        LS[i] = LS[i + 1];\n    }\n    vector<int> LMS;\n    for (int i = 1; i < v.size(); i++) {\n      if (LS[i] != S) continue;\n      if (LS[i - 1] == L) LMS.push_back(i);\n    }\n    LMS.push_back(v.size() - 1);\n    vector<pair<substring, int>> LMS_substring;\n    for (int i = 0; i < LMS.size() - 1; i++) {\n      substring sub(LMS[i], LMS[i + 1] - LMS[i] + 1, v.begin() + LMS[i],\n                    LS.begin() + LMS[i]);\n      LMS_substring.push_back({sub, LMS_substring.size()});\n    }\n    if (LMS_substring.size() > 0) {\n      vector<pair<substring, int>> LMS_substring_old = LMS_substring;\n      sort(LMS_substring.begin(), LMS_substring.end());\n      vector<int> LMS_order(LMS_substring.size());\n      int cnt = 0;\n      LMS_order[LMS_substring[0].second] = cnt;\n      cnt++;\n      for (int i = 1; i < LMS_substring.size(); i++) {\n        if (LMS_substring[i].first == LMS_substring[i - 1].first) {\n          LMS_order[LMS_substring[i].second] = cnt - 1;\n        } else {\n          LMS_order[LMS_substring[i].second] = cnt;\n          cnt++;\n        }\n      }\n      if (cnt != LMS_substring.size()) {\n        vector<int> new_order = rec(LMS_order);\n        LMS_order = vector<int>(new_order.begin() + 1, new_order.end());\n        for (int i = 0; i < LMS_substring.size(); i++) {\n          LMS_substring[i].first = LMS_substring_old[LMS_order[i]].first;\n        }\n      }\n      for (int i = LMS_substring.size() - 1; i >= 0; i--) {\n        int c = v[LMS_substring[i].first.pos];\n        bucket[c][bucket_back[c]] = LMS_substring[i].first.pos;\n        bucket_back[c]--;\n      }\n    }\n    for (int i = 0; i < bucket_size.size(); i++) {\n      for (int j = 0; j < bucket_size[i]; j++) {\n        if (bucket[i][j] - 1 < 0) continue;\n        if (LS[bucket[i][j] - 1] == L) {\n          if (used[bucket[i][j] - 1]) continue;\n          used[bucket[i][j] - 1] = true;\n          int c = v[bucket[i][j] - 1];\n          bucket[c][bucket_front[c]] = bucket[i][j] - 1;\n          bucket_fixed[c][bucket_front[c]] = true;\n          bucket_front[c]++;\n        }\n      }\n      bucket_back[i] = bucket_size[i] - 1;\n    }\n    for (int i = 0; i < v.size(); i++) {\n      if (fixed[i] == false) {\n        ret[i] = -1;\n      }\n    }\n    for (int i = bucket_size.size() - 1; i >= 0; i--) {\n      for (int j = bucket_size[i] - 1; j >= 0; j--) {\n        if (bucket[i][j] - 1 < 0) continue;\n        if (LS[bucket[i][j] - 1] == S) {\n          if (used[bucket[i][j] - 1]) continue;\n          used[bucket[i][j] - 1] = true;\n          int c = v[bucket[i][j] - 1];\n          bucket[c][bucket_back[c]] = bucket[i][j] - 1;\n          bucket_fixed[c][bucket_back[c]] = true;\n          bucket_back[c]--;\n        }\n      }\n    }\n    ret[0] = ret.size() - 1;\n    return ret;\n  }\n  vector<int> rec(string& s) {\n    vector<int> v(s.begin(), s.end());\n    return rec(v);\n  }\n  void constract_lcp() {\n    int n = my_s.size();\n    lcp.resize(n + 1);\n    vector<int> rank(n + 1);\n    for (int i = 0; i <= n; i++) rank[sa[i]] = i;\n    int h = 0;\n    lcp[0] = 0;\n    for (int i = 0; i < n; i++) {\n      int j = sa[rank[i] - 1];\n      if (h > 0) h--;\n      for (; j + h < n && i + h < n; h++) {\n        if (my_s[j + h] != my_s[i + h]) break;\n      }\n      lcp[rank[i] - 1] = h;\n    }\n  }\n  SA_IS(string s) {\n    my_s = s;\n    sa = rec(s);\n  }\n  void dbg_print() {\n    for (int i = 0; i <= my_s.size(); i++) {\n      string p(my_s.begin() + sa[i], my_s.end());\n      cerr << p << \" \" << sa[i] << endl;\n    }\n  }\n};\nclass SegmentTreeMIN {\n  int n;\n  vector<int> T;\n  int INF;\n\n public:\n  SegmentTreeMIN(int size) {\n    INF = 1 << 29;\n    n = 1;\n    while (n < size) n <<= 1;\n    T.resize(2 * n - 1);\n    fill(T.begin(), T.end(), INF);\n  }\n  void update(int k, int val) {\n    k += n - 1;\n    T[k] = val;\n    while (k > 0) {\n      k = (k - 1) / 2;\n      T[k] = min(T[k * 2 + 1], T[k * 2 + 2]);\n    }\n  }\n  int RMQ(int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) return INF;\n    if (a <= l && r <= b)\n      return T[k];\n    else {\n      int val_left = RMQ(a, b, k * 2 + 1, l, (l + r) / 2);\n      int val_right = RMQ(a, b, k * 2 + 2, (l + r) / 2, r);\n      return min(val_left, val_right);\n    }\n  }\n  int size() { return n; }\n};\nint main() {\n  string s;\n  cin >> s;\n  int n = s.size();\n  s += s;\n  SA_IS sa(s);\n  vector<int> arr(2 * n);\n  for (int i = 0; i < 2 * n; i++) {\n    if (s[i] == '(') {\n      arr[i] = 1;\n    } else {\n      arr[i] = -1;\n    }\n    if (i > 0) arr[i] += arr[i - 1];\n  }\n  SegmentTreeMIN seg(2 * n);\n  for (int i = 0; i < 2 * n; i++) {\n    seg.update(i, arr[i]);\n  }\n  int index = -1;\n  int len = 1 << 30;\n  int xx = 0;\n  int yy = 0;\n  for (int i = 0; i < 2 * n; i++) {\n    if (sa.sa[i] > n) continue;\n    int x = min(0, seg.RMQ(sa.sa[i], sa.sa[i] + n, 0, 0, seg.size()) -\n                       (sa.sa[i] > 0 ? arr[sa.sa[i] - 1] : 0));\n    int y = max(0, arr[sa.sa[i] + n - 1] -\n                       (sa.sa[i] > 0 ? arr[sa.sa[i] - 1] : 0) + abs(x));\n    if (len > abs(x) + abs(y) + n) {\n      index = i;\n      len = abs(x) + abs(y) + n;\n      xx = abs(x);\n      yy = abs(y);\n    }\n  }\n  string ans;\n  for (int j = 0; j < xx; j++) {\n    printf(\"(\");\n  }\n  cout << s.substr(sa.sa[index], n);\n  for (int j = 0; j < yy; j++) {\n    printf(\")\");\n  }\n  printf(\"\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e6 + 10, LG = 21;\nint sp[LG][maxn], arr[maxn];\nint mn[maxn];\nvector<int> vec;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie();\n  string s;\n  cin >> s;\n  int n = int((s).size()), SM = 0;\n  for (int i = 0; i < n; i++) {\n    SM += s[i] == '(' ? 1 : -1;\n  }\n  for (int i = 0; i < n; i++) {\n    sp[0][i] = s[i] == ')';\n    arr[i] = i;\n  }\n  int lg = 0;\n  for (int i = 1; (1 << i) <= n; i++) {\n    lg = i;\n    int pw = 1 << (i - 1);\n    auto f = [&](int a, int b) {\n      if (sp[i - 1][a] != sp[i - 1][b]) return sp[i - 1][a] < sp[i - 1][b];\n      a += pw, b += pw;\n      if (a >= n) a -= n;\n      if (b >= n) b -= n;\n      return sp[i - 1][a] < sp[i - 1][b];\n    };\n    sort(arr, arr + n, f);\n    for (int j = 1; j < n; j++) {\n      sp[i][arr[j]] =\n          sp[i][arr[j - 1]] + (f(arr[j - 1], arr[j]) || f(arr[j], arr[j - 1]));\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    mn[i] = (i == 0 ? 0 : mn[i - 1]) + (s[i] == '(' ? 1 : -1);\n  }\n  for (int i = 1; i < n; i++) {\n    mn[i] = min(mn[i - 1], mn[i]);\n  }\n  int sm = 0, mm = 0, pos = -1;\n  auto cmp = [&](int a, int b) {\n    int lc = 0;\n    for (int i = lg; i >= 0; i--) {\n      if (lc + (1 << i) <= n && sp[i][a] == sp[i][b])\n        a += (1 << i), b += (1 << i), lc += (1 << i), a %= n, b %= n;\n    }\n    return s[a] < s[b];\n  };\n  for (int i = n - 1; i >= 0; i--) {\n    int x = s[i] == '(' ? 1 : -1;\n    mm += x;\n    sm += x;\n    mm = min(mm, x);\n    int bf = (i == 0 ? 0 : mn[i - 1]);\n    if (min(mm, sm + bf) + max(-SM, 0) >= 0) {\n      if (pos == -1)\n        pos = i;\n      else if (cmp(i, pos))\n        pos = i;\n    }\n  }\n  string ans, ss;\n  for (int i = 0; i < n; i++) {\n    ans += s[(i + pos) % n];\n  }\n  if (SM < 0) {\n    while (SM < 0) ss += '(', SM++;\n    ans = ss + ans;\n  } else {\n    while (SM > 0) ss += ')', SM--;\n    ans = ans + ss;\n  }\n  return cout << ans << endl, 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast,inline,unroll-loops,fast-math\")\nusing namespace std;\nchar a[2000020];\nint f[2000020], g[2000020], h[2000020];\ndeque<int> q;\nvoid InitSA(char *s, int n, int m) {\n  static int l[2000020], r[2000020], c[2000020];\n  int i, p, k;\n  int *x, *y;\n  x = l;\n  y = r;\n  for (i = 0; i < n; i++) {\n    x[i] = s[i + 1];\n    c[x[i]]++;\n  }\n  for (i = 2; i <= m; i++) c[i] += c[i - 1];\n  for (i = n - 1; i > -1; i--) f[--c[x[i]]] = i;\n  for (k = 1; k <= n; k <<= 1) {\n    for (i = n - k, p = 0; i < n; i++) y[p++] = i;\n    for (i = 0; i < n; i++)\n      if (f[i] >= k) y[p++] = f[i] - k;\n    for (i = 1; i <= m; i++) c[i] = 0;\n    for (i = 0; i < n; i++) c[x[i]]++;\n    for (i = 2; i <= m; i++) c[i] += c[i - 1];\n    for (i = n - 1; i > -1; i--) f[--c[x[y[i]]]] = y[i];\n    swap(x, y);\n    for (i = x[f[0]] = m = 1; i < n; i++)\n      x[f[i]] =\n          y[f[i]] == y[f[i - 1]] && y[f[i] + k] == y[f[i - 1] + k] ? m : ++m;\n    if (m >= n) break;\n  }\n  return;\n}\nint main(void) {\n  int n;\n  int i;\n  scanf(\"%s\", a + 1);\n  n = strlen(a + 1);\n  for (i = 1; i <= n; i++) a[i + n] = a[i];\n  InitSA(a, n * 2, ')');\n  for (i = 1; i <= n * 2; i++) {\n    g[i] = g[i - 1] + (a[i] == '(' ? 1 : -1);\n    for (; !q.empty() && i - q.front() > n; q.pop_front())\n      ;\n    for (; !q.empty() && g[q.back()] > g[i]; q.pop_back())\n      ;\n    q.push_back(i);\n    if (i >= n) h[i - n + 1] = g[q.front()];\n  }\n  if (g[n] < 0)\n    for (i = 0; i < -g[n]; i++) printf(\"(\");\n  for (i = 0; i < n * 2; i++)\n    if (f[i] < n && h[f[i] + 1] - g[f[i]] >= min(g[n], 0)) break;\n  a[f[i] + 1 + n] = 0;\n  printf(\"%s\", a + f[i] + 1);\n  if (g[n] > 0)\n    for (i = 0; i < g[n]; i++) printf(\")\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2E6 + 10;\nconst int BASE = 7;\nconst int MOD = 1E9 + 7;\nchar S[MAXN];\nint N;\nint pref[MAXN];\nint mp[MAXN];\nlong long H[MAXN];\nlong long P[MAXN];\nlong long gethsh(int lft, int rgt) {\n  return (H[rgt] - H[lft] * P[rgt - lft] % MOD + MOD) % MOD;\n}\nbool equals(int a, int b, int len) {\n  return gethsh(a, a + len) == gethsh(b, b + len);\n}\nbool comp(int a, int b) {\n  int lo = 0, hi = N + 1;\n  while (hi - lo > 1) {\n    int mid = (lo + hi) / 2;\n    if (equals(a, b, mid)) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n  return S[a + lo] < S[b + lo];\n}\nvoid init_hsh() {\n  H[0] = 0;\n  for (int i = 0; i < N; ++i) {\n    H[i + 1] = (BASE * H[i] + S[i]) % MOD;\n  }\n  P[0] = 1;\n  for (int i = 0; i < MAXN - 1; ++i) {\n    P[i + 1] = BASE * P[i] % MOD;\n  }\n}\nvoid pop(deque<pair<int, int> >& dq, int idx) {\n  while (!dq.empty() && dq.front().first < idx) {\n    dq.pop_front();\n  }\n}\nvoid push(deque<pair<int, int> >& dq, pair<int, int> p) {\n  while (!dq.empty() && dq.back().second > p.second) {\n    dq.pop_back();\n  }\n  dq.push_back(p);\n}\nint main() {\n  if (fopen(\"input.txt\", \"r\")) {\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n  }\n  scanf(\"%s\", S);\n  N = (int)(strlen(S));\n  memcpy(S + N, S, N);\n  N += N;\n  init_hsh();\n  for (int i = 0; i < N; ++i) {\n    pref[i + 1] = pref[i] + (S[i] == '(' ? 1 : -1);\n  }\n  N /= 2;\n  deque<pair<int, int> > dq;\n  for (int i = 0; i < N * 2; ++i) {\n    pop(dq, i - N + 1);\n    push(dq, pair<int, int>(i, pref[i + 1]));\n    if (i >= N - 1) {\n      mp[i - N + 1] = dq.front().second - pref[i - N + 1];\n    }\n  }\n  int best = -1;\n  for (int i = 0; i < N; ++i) {\n    if (mp[i] >= min(pref[N], 0) && (best == -1 || comp(i, best))) {\n      best = i;\n    }\n  }\n  for (int i = 0; i < -pref[N]; ++i) {\n    printf(\"(\");\n  }\n  for (int i = 0; i < N; ++i) {\n    printf(\"%c\", S[best + i]);\n  }\n  for (int i = 0; i < pref[N]; ++i) {\n    printf(\")\");\n  }\n  puts(\"\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nconst int INF = 1e9;\nconst long long lINF = 1e18;\nconst double EPS = 1e-12;\nusing namespace std;\nconst int N = 1e6 + 100;\nchar s[N];\nint p[N], c[N], last[N];\nint pn[N], cn[N];\nint n, balance[N], mnl[N], mnr[N];\nint main() {\n  scanf(\"%s\", s);\n  n = strlen(s);\n  for (int i = 0; i < n; i++) {\n    last[s[i] - 'a' + 1]++;\n  }\n  for (int i = 2; i <= 26; i++) {\n    last[i] += last[i - 1];\n  }\n  for (int i = 0; i < n; i++) {\n    c[i] = last[s[i] - 'a'];\n  }\n  for (int i = 0; i < n; i++) {\n    p[last[s[i] - 'a']++] = i;\n  }\n  for (int l = 1; l < n; l <<= 1) {\n    for (int i = 0; i < n; i++) last[i] = i;\n    for (int i = 0; i < n; i++) pn[i] = (p[i] - l + n) % n;\n    for (int i = 0; i < n; i++) p[last[c[pn[i]]]++] = pn[i];\n    cn[p[0]] = 0;\n    int nlast = 0;\n    for (int i = 1; i < n; i++) {\n      int mid1 = (p[i] + l) % n, mid2 = (p[i - 1] + l) % n;\n      if (c[p[i]] > c[p[i - 1]] || c[mid1] > c[mid2]) nlast = i;\n      cn[p[i]] = nlast;\n    }\n    memcpy(c, cn, n * sizeof(n));\n  }\n  mnl[0] = INF;\n  for (int i = 0; i < n; i++) {\n    if (s[i] == '(') {\n      balance[i + 1] = balance[i] + 1;\n    } else {\n      balance[i + 1] = balance[i] - 1;\n    }\n    mnl[i + 1] = min(balance[i + 1], mnl[i]);\n  }\n  mnr[n - 1] = balance[n];\n  for (int i = n - 2; i >= 0; i--) {\n    mnr[i] = min(mnr[i + 1], balance[i + 1]);\n  }\n  int ans = INF, ansi = 0, good = min(0, balance[n]);\n  for (int i = 0; i < n; i++) {\n    if (mnl[i] + balance[n] - balance[i] >= good &&\n        mnr[i] - balance[i] >= good) {\n      if (ans > c[i]) {\n        ans = c[i];\n        ansi = i;\n      }\n    }\n  }\n  for (int i = 0; i < -balance[n]; i++) {\n    putchar('(');\n  }\n  for (int i = ansi; i < ansi + n; i++) {\n    putchar(s[i % n]);\n  }\n  for (int i = 0; i < balance[n]; i++) {\n    putchar(')');\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2111111;\nchar buf[maxn];\nint sum[maxn];\nbool ok[maxn];\nint order[maxn];\ntemplate <typename T>\nvoid debug(T a[], int n) {\n  for (int i = 1; i <= n; ++i) {\n    cout << setw(3) << a[i];\n  }\n  puts(\"\");\n}\nvoid fix(int& i, int n) {\n  while (!ok[i] && i <= n) {\n    ++i;\n  }\n}\nint run(char s[], int m) {\n  int n = m >> 1;\n  int i = 1, j = 2, k = 0;\n  fix(i, n);\n  j = i + 1;\n  fix(j, n);\n  while (j <= n && i <= n) {\n    for (k = 0; k < n; ++k) {\n      if (s[i + k] ^ s[j + k]) {\n        break;\n      }\n    }\n    if (s[i + k] > s[j + k]) {\n      i += k + 1;\n      fix(i, n);\n    } else {\n      j += k + 1;\n      fix(j, n);\n    }\n    if (j == i) {\n      ++j;\n      fix(j, n);\n    }\n  }\n  return std::min(i, j);\n}\nint main() {\n  for (int i = 1; i < 100; ++i) {\n    order[i] = i;\n  }\n  scanf(\"%s\", buf + 1);\n  int n = std::strlen(buf + 1);\n  int A, B;\n  A = B = 0;\n  for (int i = 1; i <= n; ++i) {\n    buf[i + n] = buf[i];\n    if (buf[i] == '(') {\n      ++A;\n    } else {\n      ++B;\n    }\n  }\n  int m = n << 1;\n  for (int i = 1; i <= m; ++i) {\n    if (buf[i] == '(') {\n      sum[i] = 1;\n    } else {\n      sum[i] = -1;\n    }\n    sum[i] += sum[i - 1];\n  }\n  static int q[maxn];\n  int front, rear;\n  front = rear = 0;\n  static int min[maxn];\n  int add = 0;\n  if (A < B) {\n    add = B - A;\n  }\n  for (int i = 1; i <= m; ++i) {\n    if (front < rear && q[front] + n <= i) {\n      ++front;\n    }\n    while (front < rear && sum[q[rear - 1]] >= sum[i]) {\n      --rear;\n    }\n    q[rear++] = i;\n    min[i] = sum[q[front]];\n  }\n  for (int i = 1; i <= n; ++i) {\n    if (add + min[i + n - 1] >= sum[i - 1]) {\n      ok[i] = true;\n    }\n  }\n  int index = run(buf, m);\n  auto print = [](char ch, int n) {\n    while (n--) {\n      putchar(ch);\n    }\n  };\n  if (A < B) {\n    print('(', B - A);\n  }\n  for (int i = index; i < index + n; ++i) {\n    putchar(buf[i]);\n  }\n  if (B < A) {\n    print(')', A - B);\n  }\n  puts(\"\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool debug;\nconst int inf = 1e9 + 5;\nconst long long INF = (long long)inf * inf;\nconst int nax = 1e6 + 5;\nconst int D = 2;\nconst long long MM = 1000 * 1000 * 1000;\nconst long long m[5] = {MM + 7, MM + 9, MM + 21, MM + 33, 333333361LL};\nchar sl[nax];\nlong long preh[nax][D];\nint n;\nlong long potega[nax][D];\nlong long h(pair<int, int> a, int j) {\n  long long x = preh[a.second][j];\n  if (a.first) x -= preh[a.first - 1][j];\n  if (x < 0) x += m[j];\n  x = (x * potega[n - a.first][j]) % m[j];\n  return x;\n}\nbool rowne(pair<int, int> a, pair<int, int> b) {\n  for (int j = 0; j <= (D)-1; ++j)\n    if (h(a, j) != h(b, j)) return false;\n  return true;\n}\nint porow(pair<int, int> a, pair<int, int> b) {\n  assert(a.second - a.first == b.second - b.first);\n  if (a.first > a.second) return true;\n  if (rowne(a, b)) return 1;\n  int low = 0, high = a.second - a.first;\n  while (low != high) {\n    int med = (low + high) / 2;\n    if (rowne(make_pair(a.first, a.first + med),\n              make_pair(b.first, b.first + med)))\n      low = med + 1;\n    else\n      high = med;\n  }\n  if (sl[a.first + low] == '(') return 0;\n  return 2;\n}\nint pref[nax];\nint LICZ;\nconst int pot = 1024 * 1024;\nint tr[2 * pot];\nint mi(int a, int b) {\n  a += pot;\n  b += pot;\n  int ku = min(tr[a], tr[b]);\n  while (a < b - 1) {\n    ku = min(ku, tr[a + 1]);\n    ku = min(ku, tr[b - 1]);\n    a /= 2;\n    b /= 2;\n  }\n  return ku;\n}\nbool ok_podzial_szybkie(int i) {\n  int s1 = pref[i];\n  int s2 = LICZ - pref[i];\n  int k = 0;\n  if (LICZ < 0) k = -LICZ;\n  if (i + 1 <= n - 1 && k + mi(i + 1, n - 1) - s1 < 0) return false;\n  if (0 <= i && k + s2 + mi(0, i) < 0) return false;\n  return true;\n}\nbool ok_podzial(int i) {\n  int teraz = 0;\n  if (LICZ < 0) teraz = -LICZ;\n  for (int j = i + 1; j <= n - 1; ++j) {\n    if (sl[j] == '(')\n      ++teraz;\n    else\n      --teraz;\n    if (teraz < 0) return false;\n  }\n  for (int j = 0; j <= i; ++j) {\n    if (sl[j] == '(')\n      ++teraz;\n    else\n      --teraz;\n    if (teraz < 0) return false;\n  }\n  return true;\n}\nint best = -1;\nbool jebaj(int i) {\n  if (best == -1) return true;\n  int kon = best + 1 + (n - 1 - (i + 1));\n  int pom = porow(make_pair(best + 1, kon), make_pair(i + 1, n - 1));\n  if (pom == 0) return false;\n  if (pom == 2) return true;\n  int kon2 = n - 1 - (kon + 1);\n  pom = porow(make_pair(kon + 1, n - 1), make_pair(0, kon2));\n  if (pom == 0) return false;\n  if (pom == 2) return true;\n  pom = porow(make_pair(0, best), make_pair(kon2 + 1, i));\n  if (pom == 0) return false;\n  return true;\n}\nint main(int argc, char *argv[]) {\n  debug = argc > 1;\n  scanf(\"%s\", sl);\n  n = strlen(sl);\n  for (int i = 0; i <= (n)-1; ++i) {\n    if (i) pref[i] = pref[i - 1];\n    if (sl[i] == '(')\n      pref[i]++;\n    else\n      pref[i]--;\n  }\n  for (int i = 0; i <= (2 * pot) - 1; ++i) tr[i] = inf;\n  for (int i = 0; i <= (n)-1; ++i) tr[pot + i] = pref[i];\n  for (int i = pot - 1; i >= 1; --i) tr[i] = min(tr[2 * i], tr[2 * i + 1]);\n  LICZ = 0;\n  for (int i = 0; i <= (n)-1; ++i) {\n    if (sl[i] == '(')\n      ++LICZ;\n    else\n      --LICZ;\n  }\n  for (int j = 0; j <= (D)-1; ++j) {\n    potega[0][j] = 1;\n    for (int i = 1; i <= n; ++i)\n      potega[i][j] = ((j == 2 ? 3 : 2) * potega[i - 1][j]) % m[j];\n  }\n  for (int j = 0; j <= (D)-1; ++j)\n    for (int i = 0; i <= (n)-1; ++i) {\n      int teraz = int(sl[i] == '(');\n      preh[i][j] = ((i ? preh[i - 1][j] : 0LL) + teraz * potega[i][j]) % m[j];\n    }\n  for (int i = 0; i <= (n)-1; ++i)\n    if (ok_podzial_szybkie(i))\n      if (jebaj(i)) best = i;\n  assert(best != -1);\n  if (LICZ < 0)\n    for (int _ = 0; _ <= (-LICZ) - 1; ++_) printf(\"(\");\n  for (int j = best + 1; j <= n - 1; ++j) printf(\"%c\", sl[j]);\n  for (int j = 0; j <= best; ++j) printf(\"%c\", sl[j]);\n  if (LICZ > 0)\n    for (int _ = 0; _ <= (LICZ)-1; ++_) printf(\")\");\n  puts(\"\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> scs(const string& s) {\n  int n = s.size();\n  vector<int> p(n), c(s.begin(), s.end());\n  vector<vector<int>> g(max(n, 256));\n  for (int i = 0; i < n; i++) g[c[i]].push_back(i);\n  int b = 0;\n  for (auto& gr : g) {\n    for (int x : gr) p[b++] = x;\n    gr.clear();\n  }\n  for (int h = 1; h < n; h <<= 1) {\n    vector<int> p2(n), c2(n);\n    for (int j : p) {\n      int jp = (j + n - h) % n;\n      g[c[jp]].push_back(jp);\n    }\n    b = 0;\n    for (auto& gr : g) {\n      for (int x : gr) p2[b++] = x;\n      gr.clear();\n    }\n    b = 0;\n    c2[p2[0]] = 0;\n    for (int i = 1; i < n; i++) {\n      int x = p2[i];\n      int y = p2[i - 1];\n      if (c[x] == c[y] && c[(x + h) % n] == c[(y + h) % n])\n        c2[x] = b;\n      else\n        c2[x] = ++b;\n    }\n    swap(c, c2);\n    swap(p, p2);\n  }\n  return p;\n}\nstruct stvar {\n  int a, b;\n  stvar(int x = 0) : a(x), b(min(0, x)) {}\n  stvar(int p, int q) : a(p), b(q) {}\n  stvar operator+(const stvar& o) const {\n    return stvar(a + o.a, min(b, a + o.b));\n  }\n};\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  cerr.tie(nullptr);\n  string s;\n  cin >> s;\n  int n = s.size();\n  vector<int> p = scs(s);\n  vector<stvar> pref(n + 1), suff(n + 1);\n  for (int i = 0; i < n; i++)\n    pref[i + 1] = pref[i] + stvar(s[i] == '(' ? 1 : -1);\n  for (int i = n - 1; i >= 0; i--)\n    suff[i] = stvar(s[i] == '(' ? 1 : -1) + suff[i + 1];\n  for (int j : p) {\n    auto t = suff[j] + pref[j];\n    if (t.a < 0) {\n      if (t.a == t.b) {\n        cout << string(-t.a, '(') << s.substr(j) << s.substr(0, j) << '\\n';\n        return 0;\n      }\n    } else {\n      if (t.b == 0) {\n        cout << s.substr(j) << s.substr(0, j) << string(t.a, ')') << '\\n';\n        return 0;\n      }\n    }\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2000005;\nconst int MOD = 100000009;\nconst int B = 31337;\nint n;\nint off = 1;\nint lo, hi;\nchar S[N];\npair<int, int> T[4 * N];\nlong long H[N];\nlong long PW[N];\nvoid load() {\n  scanf(\"%s\", S);\n  n = strlen(S);\n  while (off < 2 * n) off <<= 1;\n  for (int i = n; i < 2 * n; i++) S[i] = S[i - n];\n  H[0] = S[0];\n  for (int i = 1; i < 2 * n; i++) H[i] = H[i - 1] * B + S[i], H[i] %= MOD;\n  PW[0] = 1;\n  for (int i = 1; i < N; i++) PW[i] = PW[i - 1] * B, PW[i] %= MOD;\n}\nlong long get(int first, int second) {\n  if (!first) return H[second];\n  return (H[second] - (H[first - 1] * PW[second - first + 1] % MOD) + MOD) %\n         MOD;\n}\nint lcp(int first, int second) {\n  int low = 0, high = 2 * n - max(first, second) - 1, middle;\n  while (low <= high) {\n    middle = (low + high) / 2;\n    if (get(first, first + middle) != get(second, second + middle))\n      high = middle - 1;\n    else\n      low = middle + 1;\n  }\n  return S[first + low] < S[second + low];\n}\npair<int, int> merge(pair<int, int> A, pair<int, int> B) {\n  pair<int, int> C;\n  int brackets = min(A.first, B.second);\n  C.first = A.first + B.first - brackets;\n  C.second = A.second + B.second - brackets;\n  return C;\n}\npair<int, int> query(int a, int b, int node) {\n  if (a > hi || b < lo) return make_pair(0, 0);\n  if (a >= lo && b <= hi) return T[node];\n  return merge(query(a, (a + b) / 2, node * 2),\n               query((a + b) / 2 + 1, b, node * 2 + 1));\n}\nvoid solve() {\n  for (int i = 0; i < 2 * n; i++) {\n    if (S[i] == '(')\n      T[i + off].first++;\n    else\n      T[i + off].second++;\n  }\n  for (int i = off - 1; i >= 1; i--) {\n    T[i] = merge(T[i * 2], T[i * 2 + 1]);\n  }\n  int sol = (1 << 30);\n  int sol_left = 0;\n  int sol_right = 0;\n  int idx = 0;\n  for (int i = 0; i < n; i++) {\n    lo = i, hi = i + n - 1;\n    pair<int, int> AA = query(0, off - 1, 1);\n    int curr = AA.first + AA.second;\n    if (curr < sol) {\n      sol = curr;\n      sol_left = AA.first;\n      sol_right = AA.second;\n      idx = i;\n    } else if (curr == sol && lcp(i, idx)) {\n      sol_left = AA.first;\n      sol_right = AA.second;\n      idx = i;\n    }\n  }\n  for (int i = 0; i < sol_right; i++) printf(\"(\");\n  for (int i = idx; i < idx + n; i++) printf(\"%c\", S[i]);\n  for (int i = 0; i < sol_left; i++) printf(\")\");\n  printf(\"\\n\");\n}\nint main(void) {\n  load();\n  solve();\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nclass data {\n public:\n  int op, cl, x, y;\n} a[2000005];\nint n;\nchar s[4000005];\nint arr[4000005];\nint kd[8000000];\nint art[8000000];\nint update(int root, int bas, int son, int x, int y, int val) {\n  if (son < x or y < bas) return kd[root];\n  if (x <= bas and son <= y) {\n    art[root] += val;\n    return kd[root] += val;\n  }\n  return kd[root] =\n             min(update(root * 2, bas, (bas + son) / 2, x, y, val),\n                 update(root * 2 + 1, (bas + son) / 2 + 1, son, x, y, val)) +\n             art[root];\n}\nint query(int root, int bas, int son, int x, int y) {\n  if (son < x or y < bas) return 1000000007LL;\n  if (x <= bas and son <= y) return kd[root];\n  return min(query(root * 2, bas, (bas + son) / 2, x, y),\n             query(root * 2 + 1, (bas + son) / 2 + 1, son, x, y)) +\n         art[root];\n}\nlong long int h[4000005], pows[4000005] = {1}, OP[4000005], CL[4000005];\nlong long int f(int x, int y) {\n  return (h[y] - h[x - 1] * pows[y - x + 1] + 1000000007LL * 1000000007LL) %\n         1000000007LL;\n}\nlong long int giveHash(data A, int x) {\n  if (x <= A.op) return OP[x];\n  if (x <= A.op + n)\n    return (OP[A.op] * pows[x - A.op] + f(A.x, A.x + x - A.op - 1)) %\n           1000000007LL;\n  return (OP[A.op] * pows[x - A.op] + f(A.x, A.y) * pows[x - A.op - n] +\n          CL[x - A.op - n]) %\n         1000000007LL;\n}\nchar giveChar(data A, int x) {\n  if (x <= A.op) return '(';\n  if (x <= A.op + n) return s[A.x + x - A.op - 1];\n  return ')';\n}\nint lcp(data A, data B) {\n  int bas = 0, son = min(A.op + n + A.cl, B.op + n + B.cl), orta;\n  while (bas < son) {\n    orta = (bas + son) / 2 + 1;\n    if (giveHash(A, orta) == giveHash(B, orta))\n      bas = orta;\n    else\n      son = orta - 1;\n  }\n  return bas;\n}\nbool cmp(data A, data B) {\n  int u1, u2;\n  u1 = A.op + n + A.cl;\n  u2 = B.op + n + B.cl;\n  if (u1 != u2) return u1 < u2;\n  int l = lcp(A, B);\n  if (l == u1) return 1;\n  return giveChar(A, l + 1) == '(';\n}\nint main() {\n  scanf(\"%s\", s + 1);\n  n = strlen(s + 1);\n  int R = 0;\n  for (long long int i = 1; i <= n; i++) {\n    s[i + n] = s[i];\n    R += arr[i] = arr[i + n] = (s[i] == '(' ? 1 : -1);\n  }\n  for (long long int i = n + 1; i <= 2 * n; i++)\n    update(1, 1, 2 * n, i, 2 * n, arr[i]);\n  for (long long int i = n; i >= 1; i--) {\n    int mini = query(1, 1, 2 * n, i + 1, i + n);\n    a[i].op = max(0, -mini);\n    a[i].cl = R + a[i].op;\n    a[i].x = i + 1;\n    a[i].y = i + n;\n    update(1, 1, 2 * n, i, i + n - 1, arr[i]);\n  }\n  for (long long int i = 1; i <= 4000001; i++)\n    h[i] = (h[i - 1] * 9973 + s[i]) % 1000000007LL,\n    pows[i] = (pows[i - 1] * 9973) % 1000000007LL,\n    OP[i] = (OP[i - 1] * 9973 + '(') % 1000000007LL,\n    CL[i] = (CL[i - 1] * 9973 + ')') % 1000000007LL;\n  data res = a[1];\n  for (long long int i = 2; i <= n; i++)\n    if (cmp(a[i], res)) res = a[i];\n  string result;\n  for (long long int i = 1; i <= res.op; i++) result += '(';\n  for (long long int i = res.x; i <= res.y; i++) result += s[i];\n  for (long long int i = 1; i <= res.cl; i++) result += ')';\n  if (s[1] == '(' and s[4] == '(' and s[6] == '(' and s[2] == ')' and\n      s[3] == ')' and n >= 100000) {\n  }\n  printf(\"%s\\n\", result.c_str());\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool fast_greater(const string& s, const vector<long long>& h,\n                  const vector<long long>& p, int i1, int i2, int n) {\n  if (s[i1] != s[i2]) return s[i1] > s[i2];\n  int lo{0};\n  int up{n - 1};\n  while (up - lo > 1) {\n    int mid{(lo + up) / 2};\n    if ((h[i1 + mid] - h[i1] * p[mid] % 1234567890 + 1234567890) % 1234567890 ==\n        (h[i2 + mid] - h[i2] * p[mid] % 1234567890 + 1234567890) % 1234567890)\n      lo = mid;\n    else\n      up = mid;\n  }\n  if ((h[i1 + up] - h[i1] * p[up] % 1234567890 + 1234567890) % 1234567890 ==\n      (h[i2 + up] - h[i2] * p[up] % 1234567890 + 1234567890) % 1234567890)\n    return s[i1 + up + 1] > s[i2 + up + 1];\n  else\n    return s[i1 + lo + 1] > s[i2 + lo + 1];\n}\nint main() {\n  string s;\n  cin >> s;\n  int n = s.size();\n  vector<int> minPre(n), minSuf(n), bal(n);\n  transform((s).begin(), (s).end(), bal.begin(),\n            [](char ch) { return ch == '(' ? 1 : -1; });\n  partial_sum((bal).begin(), (bal).end(), bal.begin());\n  partial_sum((bal).begin(), (bal).end(), minPre.begin(),\n              [](int x, int y) { return x < y ? x : y; });\n  partial_sum((bal).rbegin(), (bal).rend(), minSuf.rbegin(),\n              [](int x, int y) { return x < y ? x : y; });\n  s += s;\n  vector<long long> h(2 * n);\n  vector<long long> p(2 * n);\n  h[0] = 0;\n  p[0] = 1;\n  for (int i = 1; i < 2 * n; ++i) {\n    h[i] = (h[i - 1] * 1000007 + s[i]) % 1234567890;\n    p[i] = p[i - 1] * 1000007 % 1234567890;\n  }\n  int I{-1};\n  int totBal{bal[n - 1]};\n  for (int i = 0; i < n; ++i) {\n    int minRot{i == 0 ? minSuf[0]\n                      : min(minSuf[i] - bal[i - 1],\n                            minPre[i - 1] + totBal - bal[i - 1])};\n    if (totBal >= 0 && minRot >= 0 || totBal < 0 && minRot - totBal >= 0)\n      if (I == -1 || fast_greater(s, h, p, I, i, n)) I = i;\n  }\n  string ans = (totBal < 0 ? string(-totBal, '(') : string()) +\n               string(s.begin() + I, s.begin() + I + n) +\n               (totBal > 0 ? string(totBal, ')') : string());\n  cout << ans << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nbool debug;\nconst int inf = 1e9 + 5;\nconst long long INF = (long long)inf * inf;\nconst int nax = 1e6 + 5;\nconst int D = 1;\nconst long long MM = 1000 * 1000 * 1000;\nconst long long m[5] = {MM + 7, MM + 9, MM + 21, MM + 33, 333333361LL};\nchar sl[nax];\nlong long preh[nax][D];\nint n;\nlong long potega[nax][D];\nlong long h(pair<int, int> a, int j) {\n  long long x = preh[a.second][j];\n  if (a.first) x -= preh[a.first - 1][j];\n  if (x < 0) x += m[j];\n  x = (x * potega[n - a.first][j]) % m[j];\n  return x;\n}\nbool rowne(pair<int, int> a, pair<int, int> b) {\n  for (int j = 0; j <= (D)-1; ++j)\n    if (h(a, j) != h(b, j)) return false;\n  return true;\n}\nint porow(pair<int, int> a, pair<int, int> b) {\n  assert(a.second - a.first == b.second - b.first);\n  if (a.first > a.second) return true;\n  if (rowne(a, b)) return 1;\n  int low = 0, high = a.second - a.first;\n  while (low != high) {\n    int med = (low + high) / 2;\n    if (rowne(make_pair(a.first, a.first + med),\n              make_pair(b.first, b.first + med)))\n      low = med + 1;\n    else\n      high = med;\n  }\n  if (sl[a.first + low] == '(') return 0;\n  return 2;\n}\nint pref[nax];\nint LICZ;\nconst int pot = 1024 * 1024;\nint tr[2 * pot];\nint mi(int a, int b) {\n  a += pot;\n  b += pot;\n  int ku = min(tr[a], tr[b]);\n  while (a < b - 1) {\n    ku = min(ku, tr[a + 1]);\n    ku = min(ku, tr[b - 1]);\n    a /= 2;\n    b /= 2;\n  }\n  return ku;\n}\nbool ok_podzial_szybkie(int i) {\n  int s1 = pref[i];\n  int s2 = LICZ - pref[i];\n  int k = 0;\n  if (LICZ < 0) k = -LICZ;\n  if (i + 1 <= n - 1 && k + mi(i + 1, n - 1) - s1 < 0) return false;\n  if (0 <= i && k + s2 + mi(0, i) < 0) return false;\n  return true;\n}\nbool ok_podzial(int i) {\n  int teraz = 0;\n  if (LICZ < 0) teraz = -LICZ;\n  for (int j = i + 1; j <= n - 1; ++j) {\n    if (sl[j] == '(')\n      ++teraz;\n    else\n      --teraz;\n    if (teraz < 0) return false;\n  }\n  for (int j = 0; j <= i; ++j) {\n    if (sl[j] == '(')\n      ++teraz;\n    else\n      --teraz;\n    if (teraz < 0) return false;\n  }\n  return true;\n}\nint best = -1;\nbool jebaj(int i) {\n  if (best == -1) return true;\n  int kon = best + 1 + (n - 1 - (i + 1));\n  int pom = porow(make_pair(best + 1, kon), make_pair(i + 1, n - 1));\n  if (pom == 0) return false;\n  if (pom == 2) return true;\n  int kon2 = n - 1 - (kon + 1);\n  pom = porow(make_pair(kon + 1, n - 1), make_pair(0, kon2));\n  if (pom == 0) return false;\n  if (pom == 2) return true;\n  pom = porow(make_pair(0, best), make_pair(kon2 + 1, i));\n  if (pom == 0) return false;\n  return true;\n}\nint main(int argc, char *argv[]) {\n  debug = argc > 1;\n  scanf(\"%s\", sl);\n  n = strlen(sl);\n  for (int i = 0; i <= (n)-1; ++i) {\n    if (i) pref[i] = pref[i - 1];\n    if (sl[i] == '(')\n      pref[i]++;\n    else\n      pref[i]--;\n  }\n  for (int i = 0; i <= (2 * pot) - 1; ++i) tr[i] = inf;\n  for (int i = 0; i <= (n)-1; ++i) tr[pot + i] = pref[i];\n  for (int i = pot - 1; i >= 1; --i) tr[i] = min(tr[2 * i], tr[2 * i + 1]);\n  LICZ = 0;\n  for (int i = 0; i <= (n)-1; ++i) {\n    if (sl[i] == '(')\n      ++LICZ;\n    else\n      --LICZ;\n  }\n  for (int j = 0; j <= (D)-1; ++j) {\n    potega[0][j] = 1;\n    for (int i = 1; i <= n; ++i)\n      potega[i][j] = ((j == 2 ? 3 : 2) * potega[i - 1][j]) % m[j];\n  }\n  for (int j = 0; j <= (D)-1; ++j)\n    for (int i = 0; i <= (n)-1; ++i) {\n      int teraz = int(sl[i] == '(');\n      preh[i][j] = ((i ? preh[i - 1][j] : 0LL) + teraz * potega[i][j]) % m[j];\n    }\n  for (int i = 0; i <= (n)-1; ++i)\n    if (ok_podzial_szybkie(i))\n      if (jebaj(i)) best = i;\n  assert(best != -1);\n  if (LICZ < 0)\n    for (int _ = 0; _ <= (-LICZ) - 1; ++_) printf(\"(\");\n  for (int j = best + 1; j <= n - 1; ++j) printf(\"%c\", sl[j]);\n  for (int j = 0; j <= best; ++j) printf(\"%c\", sl[j]);\n  if (LICZ > 0)\n    for (int _ = 0; _ <= (LICZ)-1; ++_) printf(\")\");\n  puts(\"\");\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.util.List;\nimport java.math.BigInteger;\nimport java.io.PrintStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Comparator;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author shu_mj @ http://shu-mj.com\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tScanner in = new Scanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskA {\n    Scanner in;\n    PrintWriter out;\n\n    public void solve(int testNumber, Scanner in, PrintWriter out) {\n        this.in = in;\n        this.out = out;\n        run();\n    }\n\n    void run() {\n        char[] cs = in.next().toCharArray();\n        int n = cs.length;\n        int n2 = n * 2;\n        cs = Algo.merge(cs, cs);\n//        SuffixArray sa = new SuffixArray(cs);\n//        int[] is = new int[n2];\n//        for (int i = 0; i < n2; i++) is[i] = cs[i];\n//        int[] sa = buildSuffixArray(is);\n        int[] sa = sa(cs);\n        Seg seg = new Seg(cs);\n        int[] lr = new int[2];\n        for (int i = 0; ; i++) {\n            int id = sa[i];\n            if (id < n) {\n                seg.query(id, id + n, lr);\n                if (lr[1] == 0) {\n                    for (int j = 0; j < lr[0]; j++) out.print('(');\n                    for (int j = 0; j < n; j++) out.print(cs[j + id]);\n                    out.println();\n                    return ;\n                } else if (lr[0] == 0) {\n                    for (int j = 0; j < n; j++) out.print(cs[j + id]);\n                    for (int j = 0; j < lr[1]; j++) out.print(')');\n                    out.println();\n                    return ;\n                }\n            }\n        }\n    }\n    private static interface BaseArray {\n        public int get(int i);\n\n        public void set(int i, int val);\n\n        public int update(int i, int val);\n    }\n\n    private static class CharArray implements BaseArray {\n        private char[] m_A = null;\n        private int m_pos = 0;\n\n        CharArray(char[] A, int pos) {\n            m_A = A;\n            m_pos = pos;\n        }\n\n        public int get(int i) {\n            return m_A[m_pos + i] & 0xffff;\n        }\n\n        public void set(int i, int val) {\n            m_A[m_pos + i] = (char) (val & 0xffff);\n        }\n\n        public int update(int i, int val) {\n            return m_A[m_pos + i] += val & 0xffff;\n        }\n    }\n    private static class IntArray implements BaseArray {\n        private int[] m_A = null;\n        private int m_pos = 0;\n\n        IntArray(int[] A, int pos) {\n            m_A = A;\n            m_pos = pos;\n        }\n\n        public int get(int i) {\n            return m_A[m_pos + i];\n        }\n\n        public void set(int i, int val) {\n            m_A[m_pos + i] = val;\n        }\n\n        public int update(int i, int val) {\n            return m_A[m_pos + i] += val;\n        }\n    }\n    /* find the start or end of each bucket */\n    private static void getCounts(BaseArray T, BaseArray C, int n, int k) {\n        int i;\n        for(i = 0;i < k;++i){\n            C.set(i, 0);\n        }\n        for(i = 0;i < n;++i){\n            C.update(T.get(i), 1);\n        }\n    }\n\n    private static void getBuckets(BaseArray C, BaseArray B, int k, boolean end) {\n        int i, sum = 0;\n        if(end != false){\n            for(i = 0;i < k;++i){\n                sum += C.get(i);\n                B.set(i, sum);\n            }\n        }else{\n            for(i = 0;i < k;++i){\n                sum += C.get(i);\n                B.set(i, sum - C.get(i));\n            }\n        }\n    }\n\n    /* sort all type LMS suffixes */\n    private static void LMSsort(BaseArray T, int[] SA, BaseArray C,\n                                BaseArray B, int n, int k) {\n        int b, i, j;\n        int c0, c1;\n\t\t/* compute SAl */\n        if(C == B){\n            getCounts(T, C, n, k);\n        }\n        getBuckets(C, B, k, false); /* find starts of buckets */\n        j = n - 1;\n        b = B.get(c1 = T.get(j));\n        --j;\n        SA[b++] = (T.get(j) < c1) ? ~j : j;\n        for(i = 0;i < n;++i){\n            if(0 < (j = SA[i])){\n                if((c0 = T.get(j)) != c1){\n                    B.set(c1, b);\n                    b = B.get(c1 = c0);\n                }\n                --j;\n                SA[b++] = (T.get(j) < c1) ? ~j : j;\n                SA[i] = 0;\n            }else if(j < 0){\n                SA[i] = ~j;\n            }\n        }\n\t\t/* compute SAs */\n        if(C == B){\n            getCounts(T, C, n, k);\n        }\n        getBuckets(C, B, k, true); /* find ends of buckets */\n        for(i = n - 1, b = B.get(c1 = 0);0 <= i;--i){\n            if(0 < (j = SA[i])){\n                if((c0 = T.get(j)) != c1){\n                    B.set(c1, b);\n                    b = B.get(c1 = c0);\n                }\n                --j;\n                SA[--b] = (T.get(j) > c1) ? ~(j + 1) : j;\n                SA[i] = 0;\n            }\n        }\n    }\n\n    private static int LMSpostproc(BaseArray T, int[] SA, int n, int m) {\n        int i, j, p, q, plen, qlen, name;\n        int c0, c1;\n        boolean diff;\n\n\t\t/*\n\t\t * compact all the sorted substrings into the first m items of SA 2*m\n\t\t * must be not larger than n (proveable)\n\t\t */\n        for(i = 0;(p = SA[i]) < 0;++i){\n            SA[i] = ~p;\n        }\n        if(i < m){\n            for(j = i, ++i;;++i){\n                if((p = SA[i]) < 0){\n                    SA[j++] = ~p;\n                    SA[i] = 0;\n                    if(j == m){\n                        break;\n                    }\n                }\n            }\n        }\n\n\t\t/* store the length of all substrings */\n        i = n - 1;\n        j = n - 1;\n        c0 = T.get(n - 1);\n        do{\n            c1 = c0;\n        }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));\n        for(;0 <= i;){\n            do{\n                c1 = c0;\n            }while ((0 <= --i) && ((c0 = T.get(i)) <= c1));\n            if(0 <= i){\n                SA[m + ((i + 1) >> 1)] = j - i;\n                j = i + 1;\n                do{\n                    c1 = c0;\n                }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));\n            }\n        }\n\n\t\t/* find the lexicographic names of all substrings */\n        for(i = 0, name = 0, q = n, qlen = 0;i < m;++i){\n            p = SA[i];\n            plen = SA[m + (p >> 1)];\n            diff = true;\n            if((plen == qlen) && ((q + plen) < n)){\n                for(j = 0;(j < plen) && (T.get(p + j) == T.get(q + j));++j){\n                }\n                if(j == plen){\n                    diff = false;\n                }\n            }\n            if(diff != false){\n                ++name;\n                q = p;\n                qlen = plen;\n            }\n            SA[m + (p >> 1)] = name;\n        }\n\n        return name;\n    }\n\n    /* compute SA and BWT */\n    private static void induceSA(BaseArray T, int[] SA, BaseArray C,\n                                 BaseArray B, int n, int k) {\n        int b, i, j;\n        int c0, c1;\n\t\t/* compute SAl */\n        if(C == B){\n            getCounts(T, C, n, k);\n        }\n        getBuckets(C, B, k, false); /* find starts of buckets */\n        j = n - 1;\n        b = B.get(c1 = T.get(j));\n        SA[b++] = ((0 < j) && (T.get(j - 1) < c1)) ? ~j : j;\n        for(i = 0;i < n;++i){\n            j = SA[i];\n            SA[i] = ~j;\n            if(0 < j){\n                if((c0 = T.get(--j)) != c1){\n                    B.set(c1, b);\n                    b = B.get(c1 = c0);\n                }\n                SA[b++] = ((0 < j) && (T.get(j - 1) < c1)) ? ~j : j;\n            }\n        }\n\t\t/* compute SAs */\n        if(C == B){\n            getCounts(T, C, n, k);\n        }\n        getBuckets(C, B, k, true); /* find ends of buckets */\n        for(i = n - 1, b = B.get(c1 = 0);0 <= i;--i){\n            if(0 < (j = SA[i])){\n                if((c0 = T.get(--j)) != c1){\n                    B.set(c1, b);\n                    b = B.get(c1 = c0);\n                }\n                SA[--b] = ((j == 0) || (T.get(j - 1) > c1)) ? ~j : j;\n            }else{\n                SA[i] = ~j;\n            }\n        }\n    }\n\n    /*\n     * find the suffix array SA of T[0..n-1] in {0..k-1}^n use a working space\n     * (excluding T and SA) of at most 2n+O(1) for a constant alphabet\n     */\n    private static void SA_IS(BaseArray T, int[] SA, int fs, int n, int k) {\n        BaseArray C, B, RA;\n        int i, j, b, m, p, q, name, newfs;\n        int c0, c1;\n        int flags = 0;\n\n        if(k <= 256){\n            C = new IntArray(new int[k], 0);\n            if(k <= fs){\n                B = new IntArray(SA, n + fs - k);\n                flags = 1;\n            }else{\n                B = new IntArray(new int[k], 0);\n                flags = 3;\n            }\n        }else if(k <= fs){\n            C = new IntArray(SA, n + fs - k);\n            if(k <= (fs - k)){\n                B = new IntArray(SA, n + fs - k * 2);\n                flags = 0;\n            }else if(k <= 1024){\n                B = new IntArray(new int[k], 0);\n                flags = 2;\n            }else{\n                B = C;\n                flags = 8;\n            }\n        }else{\n            C = B = new IntArray(new int[k], 0);\n            flags = 4 | 8;\n        }\n\n\t\t/*\n\t\t * stage 1: reduce the problem by at least 1/2 sort all the\n\t\t * LMS-substrings\n\t\t */\n        getCounts(T, C, n, k);\n        getBuckets(C, B, k, true); /* find ends of buckets */\n        for(i = 0;i < n;++i){\n            SA[i] = 0;\n        }\n        b = -1;\n        i = n - 1;\n        j = n;\n        m = 0;\n        c0 = T.get(n - 1);\n        do{\n            c1 = c0;\n        }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));\n        for(;0 <= i;){\n            do{\n                c1 = c0;\n            }while ((0 <= --i) && ((c0 = T.get(i)) <= c1));\n            if(0 <= i){\n                if(0 <= b){\n                    SA[b] = j;\n                }\n                b = B.update(c1, -1);\n                j = i;\n                ++m;\n                do{\n                    c1 = c0;\n                }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));\n            }\n        }\n        if(1 < m){\n            LMSsort(T, SA, C, B, n, k);\n            name = LMSpostproc(T, SA, n, m);\n        }else if(m == 1){\n            SA[b] = j + 1;\n            name = 1;\n        }else{\n            name = 0;\n        }\n\n\t\t/*\n\t\t * stage 2: solve the reduced problem recurse if names are not yet\n\t\t * unique\n\t\t */\n        if(name < m){\n            if((flags & 4) != 0){\n                C = null;\n                B = null;\n            }\n            if((flags & 2) != 0){\n                B = null;\n            }\n            newfs = (n + fs) - (m * 2);\n            if((flags & (1 | 4 | 8)) == 0){\n                if((k + name) <= newfs){\n                    newfs -= k;\n                }else{\n                    flags |= 8;\n                }\n            }\n            for(i = m + (n >> 1) - 1, j = m * 2 + newfs - 1;m <= i;--i){\n                if(SA[i] != 0){\n                    SA[j--] = SA[i] - 1;\n                }\n            }\n            RA = new IntArray(SA, m + newfs);\n            SA_IS(RA, SA, newfs, m, name);\n            RA = null;\n\n            i = n - 1;\n            j = m * 2 - 1;\n            c0 = T.get(n - 1);\n            do{\n                c1 = c0;\n            }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));\n            for(;0 <= i;){\n                do{\n                    c1 = c0;\n                }while ((0 <= --i) && ((c0 = T.get(i)) <= c1));\n                if(0 <= i){\n                    SA[j--] = i + 1;\n                    do{\n                        c1 = c0;\n                    }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));\n                }\n            }\n\n            for(i = 0;i < m;++i){\n                SA[i] = SA[m + SA[i]];\n            }\n            if((flags & 4) != 0){\n                C = B = new IntArray(new int[k], 0);\n            }\n            if((flags & 2) != 0){\n                B = new IntArray(new int[k], 0);\n            }\n        }\n\n\t\t/* stage 3: induce the result for the original problem */\n        if((flags & 8) != 0){\n            getCounts(T, C, n, k);\n        }\n\t\t/* put all left-most S characters into their buckets */\n        if(1 < m){\n            getBuckets(C, B, k, true); /* find ends of buckets */\n            i = m - 1;\n            j = n;\n            p = SA[m - 1];\n            c1 = T.get(p);\n            do{\n                q = B.get(c0 = c1);\n                while (q < j){\n                    SA[--j] = 0;\n                }\n                do{\n                    SA[--j] = p;\n                    if(--i < 0){\n                        break;\n                    }\n                    p = SA[i];\n                }while ((c1 = T.get(p)) == c0);\n            }while (0 <= i);\n            while (0 < j){\n                SA[--j] = 0;\n            }\n        }\n        induceSA(T, SA, C, B, n, k);\n        C = null;\n        B = null;\n    }\n\n    /* char */\n    public static void suffixsort(char[] T, int[] SA, int n) {\n        if((T == null) || (SA == null) || (T.length < n) || (SA.length < n)){\n            return;\n        }\n        if(n <= 1){\n            if(n == 1){\n                SA[0] = 0;\n            }\n            return;\n        }\n        SA_IS(new CharArray(T, 0), SA, 0, n, 128);\n    }\n\n    public static int[] sa(char[] T)\n    {\n        int n = T.length;\n        int[] sa = new int[n];\n        suffixsort(T, sa, n);\n        return sa;\n    }\n\n    class Seg {\n        int N;\n        int[] left, right;\n\n        Seg(char[] cs) {\n            int n = cs.length;\n            N = Integer.highestOneBit(n) << 1;\n            left = new int[N * 2];\n            right = new int[N * 2];\n            for (int i = 0; i < N; i++) {\n                if (i < n && cs[i] == '(') {\n                    left[i + N] = 0;\n                    right[i + N] = 1;\n                } else {\n                    left[i + N] = 1;\n                    right[i + N] = 0;\n                }\n            }\n            for (int i = N - 1; i > 0; i--) {\n                left[i] = left[i * 2] + Math.max(0, left[i * 2 + 1] - right[i * 2]);\n                right[i] = right[i * 2 + 1] + Math.max(0, right[i * 2] - left[i * 2 + 1]);\n            }\n        }\n        void query(int s, int t, int[] lr) {\n            int l = 0, r = 0;\n            while (0 < s && s + (s & -s) <= t) {\n                int i = (N + s) / (s & -s);\n                int nl = l + Math.max(0, left[i] - r);\n                int nr = right[i] + Math.max(0, r - left[i]);\n                l = nl; r = nr;\n                s += s & -s;\n            }\n            int l2 = 0, r2 = 0;\n            while (s < t) {\n                int i = (N + t) / (t & -t) - 1;\n                int nl = left[i] + Math.max(0, l2 - right[i]);\n                int nr = r2 + Math.max(0, right[i] - l2);\n                l2 = nl; r2 = nr;\n                t -= t & -t;\n            }\n            lr[0] = l + Math.max(0, l2 - r);\n            lr[1] = r2 + Math.max(0, r - l2);\n        }\n    }\n/*\n\n    void run2() {\n        char[] cs = in.next().toCharArray();\n        int n = cs.length;\n        if (cs[n - 1] == '(' && cs[0] == '(' && !Algo.allTheSame(cs)) {\n            int b = 0;\n            while (cs[b] == '(') b++;\n            cs = Algo.merge(Arrays.copyOfRange(cs, b, n), Arrays.copyOfRange(cs, 0, b));\n        }\n        if (cs[n - 1] == ')' && cs[0] == ')' && !Algo.allTheSame(cs)) {\n            int b = 0;\n            while (cs[b] == ')') b++;\n            cs = Algo.merge(Arrays.copyOfRange(cs, b, n), Arrays.copyOfRange(cs, 0, b));\n        }\n        int[] is = new int[n];\n        List<PII> ps = new ArrayList<PII>();\n        for (int i = 0; i < n; i++) {\n            if (cs[i] == '(') {\n                if (i == 0 || cs[i] != cs[i - 1]) {\n                    is[i] = -1;\n                } else {\n                    is[i] = is[i - 1] - 1;\n                }\n                if (i == n - 1 || cs[i] != cs[i + 1]) {\n                    ps.add(new PII(is[i], i));\n                }\n            } else {\n                if (i == 0 || cs[i] != cs[i - 1]) {\n                    is[i] = 1;\n                } else {\n                    is[i] = is[i - 1] + 1;\n                }\n                if (i == n - 1 || cs[i] != cs[i + 1]) {\n                    ps.add(new PII(is[i], i));\n                }\n            }\n        }\n//        Algo.debug(ps);\n        int m = ps.size();\n        int[] hs = new int[m];\n        for (int i = 0; i < m; i++) {\n            hs[i] = ps.get(i).x;\n        }\n        int[] ss = hs.clone();\n        Algo.sort(ss);\n        ss = Algo.unique(ss);\n        for (int i = 0; i < m; i++) {\n            hs[i] = Algo.lowerBound(ss, hs[i]) + 2;\n        }\n        hs = Algo.merge(hs, hs);\n        SuffixArray sa = new SuffixArray(hs, ss.length + 5);\n        int id = -1;\n        for (int i = 0; ; i++) {\n            if (sa.si[i] < hs.length / 2) {\n                id = sa.si[i];\n                break;\n            }\n        }\n        int mid = ps.get(id).y - Math.abs(ps.get(id).x) + 1;\n        int l = Algo.count(cs, '(');\n        int r = n - l;\n        if (l < r) {\n            for (int i = l; i < r; i++) {\n                out.print('(');\n            }\n            l = r;\n        }\n        for (int i = mid; i < n; i++) {\n            out.print(cs[i]);\n        }\n        for (int i = 0; i < mid; i++) {\n            out.print(cs[i]);\n        }\n        if (r < l) {\n            for (int i = r; i < l; i++) {\n                out.print(')');\n            }\n        }\n        out.println();\n    }\n    class SuffixArray {\n        public int n;\n        public int[] cs;\n        public int[] si, is;// si:= suffix array(si[0] = end); is[si[i]] = i;\n\n        public int[] indexSort(int[] is, int max) {\n            int[] c = new int[max + 1];\n            for (int i : is) c[i]++;\n            for (int i = 1; i < max; i++) c[i] += c[i - 1];\n            int n = is.length;\n            int[] si = new int[n];\n            for (int i = n - 1; i >= 0; i--) si[--c[is[i]]] = i;\n            return si;\n        }\n\n        public SuffixArray(int[] t, int max) {\n            n = t.length;\n            cs = new int[n + 1];\n            System.arraycopy(t, 0, cs, 0, n);\n            cs[n] = 0;// guard, minimum value and not allowed to use\n            is = new int[n + 1];\n            for (int i = 0; i <= n; i++) is[i] = cs[i];\n            si = indexSort(is, max);\n            int[] a = new int[n + 1], b = new int[n + 1];\n            for (int h = 0; ; ) {\n                for (int i = 0; i < n; i++) {\n                    int x = si[i + 1], y = si[i];\n                    b[i + 1] = b[i];\n                    if (is[x] > is[y] || is[x + h] > is[y + h]) b[i + 1]++;\n                }\n                for (int i = 0; i <= n; i++) is[si[i]] = b[i];\n                if (b[n] == n) break;\n                h = Math.max(1, h << 1);\n                for (int k = h; k >= 0; k -= h) {\n                    Arrays.fill(b, 0);\n                    b[0] = k;\n                    for (int i = k; i <= n; i++) b[is[i]]++;\n                    for (int i = 0; i < n; i++) b[i + 1] += b[i];\n                    for (int i = n; i >= 0; i--) {\n                        a[--b[si[i] + k > n ? 0 : is[si[i] + k]]] = si[i];\n                    }\n                    int[] tmp = si; si = a; a = tmp;\n                }\n            }\n        }\n\n        public int[] hs;// hs[i]:= suffix i & i+1 's LCP\n\n        public void buildHs() {\n            hs = new int[n + 1];\n            for (int i = 0, h = 0; i < n; i++) {\n                for (int j = si[is[i] - 1]; cs[i + h] == cs[j + h]; h++) ;\n                hs[is[i] - 1] = h;\n                if (h > 0) h--;\n            }\n        }\n\n        public RMQ rmq;\n\n        public void buildRMQ() {\n            rmq = new RMQ(hs);\n        }\n\n        // begin from pos i,j, LCP means that Longest Common Prefix\n        public int getLCP(int i, int j) {\n            if (i == j) return n - i;\n            return rmq.vs[rmq.query(Math.min(is[i], is[j]), Math.max(is[i], is[j]))];\n        }\n    }\n*/\n\n}\n\nclass Scanner {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public Scanner(InputStream in) {\n        br = new BufferedReader(new InputStreamReader(in));\n        eat(\"\");\n    }\n\n    private void eat(String s) {\n        st = new StringTokenizer(s);\n    }\n\n    public String nextLine() {\n        try {\n            return br.readLine();\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    public boolean hasNext() {\n        while (!st.hasMoreTokens()) {\n            String s = nextLine();\n            if (s == null)\n                return false;\n            eat(s);\n        }\n        return true;\n    }\n\n    public String next() {\n        hasNext();\n        return st.nextToken();\n    }\n\n}\n\nclass Algo {\n\n\n    public static char[] merge(char[] is, char[] js) {\n        int in = is.length;\n        int jn = js.length;\n        char[] rs = new char[in + jn];\n        System.arraycopy(is, 0, rs, 0, in);\n        System.arraycopy(js, 0, rs, in, jn);\n        return rs;\n    }\n\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#pragma GCC target( \\\n    \"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nstruct suff_arr {\n  vector<int> p, c, np, nc, h;\n  string s;\n  int n;\n  suff_arr(string &s) {\n    this->s = s;\n    this->n = s.size();\n    build();\n  }\n  int mode1(int a, int k) { return (a + (1 << (k - 1))) % n; }\n  int mode2(int a, int k) { return (a - (1 << (k - 1)) + n) % n; }\n  bool prov(int i, int j, int k) {\n    return c[i] != c[j] || c[mode1(i, k)] != c[mode1(j, k)];\n  }\n  void build() {\n    p.resize(n), c = nc = np = h = p;\n    vector<pair<char, int>> in;\n    for (int i = 0; i < s.size(); i++) in.push_back({s[i], i});\n    sort(in.begin(), in.end());\n    for (int i = 0; i < in.size(); i++) p[i] = in[i].second;\n    int g = h[0] = c[p[0]] = 0, k = 1;\n    for (int i = 1; i < n; i++) {\n      if (in[i].first != in[i - 1].first) g++, h[g] = i;\n      c[p[i]] = g;\n    }\n    while ((1 << (k - 1)) < n) {\n      for (int i = 0; i < n; i++) {\n        int v = mode2(p[i], k);\n        np[h[c[v]]++] = v;\n      }\n      g = h[0] = nc[np[0]] = 0;\n      for (int i = 1; i < n; i++) {\n        if (prov(np[i], np[i - 1], k)) g++, h[g] = i;\n        nc[np[i]] = g;\n      }\n      c = nc, p = np, k++;\n      if (g == n) break;\n    }\n  }\n};\nstruct que {\n  stack<pair<int, int>> s1, s2;\n  void add(int x) {\n    int ane = 1e9;\n    if (s1.size()) ane = min(ane, s1.top().second);\n    s1.push({x, min(ane, x)});\n  }\n  void res() {\n    while (s1.size()) {\n      int g = s1.top().first;\n      s1.pop();\n      int ane = 1e9;\n      if (s2.size()) ane = min(ane, s2.top().second);\n      s2.push({g, min(ane, g)});\n    }\n  }\n  int mi() {\n    int ane1 = 1e9, ane2 = 1e9;\n    if (s1.size()) ane1 = min(ane1, s1.top().second);\n    if (s2.size()) ane2 = min(ane2, s2.top().second);\n    return min(ane1, ane2);\n  }\n  int gy() {\n    if (!s2.size()) res();\n    int x = s2.top().first;\n    return x;\n  }\n  int del() {\n    if (!s2.size()) res();\n    int x = s2.top().first;\n    s2.pop();\n    return x;\n  }\n};\nconst int maxn = 1e6 + 113;\nbool used[maxn];\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.setf(ios::fixed);\n  cout.precision(0);\n  string s;\n  cin >> s;\n  int yt = s.size();\n  int b1 = 0, b2 = 0;\n  int de = 0, su = 0, lasty = 0;\n  que mu;\n  for (int i = 0; i < s.size(); i++) {\n    if (s[i] == '(') {\n      b1++;\n      su++;\n    } else {\n      b2++;\n      su--;\n    }\n    mu.add(su);\n    lasty = su;\n  }\n  int vs = max(b2 - b1, 0);\n  for (int i = 0; i < s.size(); i++) {\n    int u = mu.mi();\n    if (u + de >= -vs) used[i] = 1;\n    if (s[i] == '(')\n      de--;\n    else\n      de++;\n    mu.del();\n    mu.add(lasty - de);\n  }\n  suff_arr mg(s);\n  int pos;\n  for (int i = 0; i < s.size(); i++)\n    if (used[mg.p[i]]) {\n      pos = mg.p[i];\n      break;\n    }\n  string h;\n  for (int i = pos; i < s.size(); i++) h.push_back(s[i]);\n  for (int i = 0; i < pos; i++) h.push_back(s[i]);\n  while (b1 < b2) {\n    cout << \"(\";\n    b1++;\n  }\n  cout << h;\n  while (b1 > b2) {\n    cout << \")\";\n    b2++;\n  }\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1000000;\nchar a[2 * N + 1];\nint q[2 * N];\nint main() {\n  gets(a);\n  int n = strlen(a), ans = 0, l = 0, r = 0;\n  copy_n(a, n, a + n);\n  for (int i = (0); i < (n); i++)\n    if (a[i] == '(')\n      q[r++] = i, ans++;\n    else\n      r &&r--, ans--;\n  int i = -1;\n  for (int k, jj = 0, j = 0; j < n;) {\n    while (l < r && q[l] < j) l++;\n    for (; jj < j; jj++)\n      if (a[jj] == '(')\n        q[r++] = jj + n;\n      else if (l < r)\n        r--;\n    if (r - l > max(ans, 0)) {\n      j++;\n      continue;\n    }\n    if (i == -1) {\n      i = j++;\n      continue;\n    }\n    for (k = 0; k < n && a[i + k] == a[j + k]; k++)\n      ;\n    if (a[i + k] <= a[j + k])\n      j += k + 1;\n    else {\n      i += k + 1;\n      if (i < j)\n        i = j++;\n      else\n        j = i + 1;\n    }\n  }\n  for (int j = (0); j < (-ans); j++) putchar('(');\n  i %= n;\n  for (int j = (i); j < (n); j++) putchar(a[j]);\n  for (int j = (0); j < (i); j++) putchar(a[j]);\n  for (int j = (0); j < (ans); j++) putchar(')');\n  puts(\"\");\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class A {\n\tFastScanner in;\n\tPrintWriter out;\n\n\tprivate class StringHash {\n\t\tprivate int[] val1, val2;\n\t\tprivate HashHelper helper;\n\t\tString s;\n\n\t\tpublic StringHash(int[] val1, int[] val2, HashHelper helper, String s) {\n\t\t\tsuper();\n\t\t\tthis.val1 = val1;\n\t\t\tthis.val2 = val2;\n\t\t\tthis.helper = helper;\n\t\t\tthis.s = s;\n\t\t}\n\n\t\tpublic int getIntHash(int l, int r) {\n\t\t\tlong result = val1[r + 1] - val1[l] * 1L * helper.pow1[r - l + 1];\n\t\t\tresult %= helper.MOD1;\n\t\t\tif (result < 0) {\n\t\t\t\tresult += helper.MOD1;\n\t\t\t}\n\t\t\treturn (int) result;\n\t\t}\n\n\t\tpublic long getLongHash(int l, int r) {\n\t\t\tlong res;\n\t\t\t{\n\t\t\t\tlong result = val1[r + 1] - val1[l] * 1L\n\t\t\t\t\t\t* helper.pow1[r - l + 1];\n\t\t\t\tresult %= helper.MOD1;\n\t\t\t\tif (result < 0) {\n\t\t\t\t\tresult += helper.MOD1;\n\t\t\t\t}\n\t\t\t\tres = result;\n\t\t\t}\n\t\t\t{\n\t\t\t\tlong result = val2[r + 1] - val2[l] * 1L\n\t\t\t\t\t\t* helper.pow2[r - l + 1];\n\t\t\t\tresult %= helper.MOD2;\n\t\t\t\tif (result < 0) {\n\t\t\t\t\tresult += helper.MOD2;\n\t\t\t\t}\n\t\t\t\tres = (res << 32) ^ result;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tprivate class HashHelper {\n\t\tfinal Random rnd = new Random();\n\t\tfinal int BILLION = (int) 1e9;\n\t\tfinal int MUL = 239;\n\t\tfinal int MOD1 = BigInteger\n\t\t\t\t.valueOf(BILLION + rnd.nextInt(BILLION / 10))\n\t\t\t\t.nextProbablePrime().intValue();\n\t\tfinal int MOD2 = BigInteger\n\t\t\t\t.valueOf(BILLION + rnd.nextInt(BILLION / 10))\n\t\t\t\t.nextProbablePrime().intValue();\n\t\tint[] pow1, pow2;\n\n\t\tpublic HashHelper(final int n) {\n\t\t\tpow1 = new int[n];\n\t\t\tpow2 = new int[n];\n\t\t\tpow1[0] = pow2[0] = 1;\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tpow1[i] = (int) (pow1[i - 1] * 1L * MUL % MOD1);\n\t\t\t\tpow2[i] = (int) (pow2[i - 1] * 1L * MUL % MOD2);\n\t\t\t}\n\t\t}\n\n\t\tStringHash generateHash(String s) {\n\t\t\treturn new StringHash(generateIntHash(s, MOD1), generateIntHash(s,\n\t\t\t\t\tMOD2), this, s);\n\t\t}\n\n\t\tpublic int compareInt(StringHash s1, int from1, int to1, StringHash s2,\n\t\t\t\tint from2, int to2) {\n\t\t\tint len = Math.min(to1 - from1, to2 - from2) + 1;\n\t\t\tint l = 0, r = len + 1;\n\t\t\twhile (r - l > 1) {\n\t\t\t\tint mid = (l + r) >>> 1;\n\t\t\t\tif (s1.getIntHash(from1, from1 + mid - 1) == s2.getIntHash(\n\t\t\t\t\t\tfrom2, from2 + mid - 1)) {\n\t\t\t\t\tl = mid;\n\t\t\t\t} else {\n\t\t\t\t\tr = mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (l == len) {\n\t\t\t\tif (to1 - from1 == to2 - from2) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\treturn (to1 - from1) - (to2 - from2);\n\t\t\t}\n\t\t\treturn s1.s.charAt(from1 + l) - s2.s.charAt(from2 + l);\n\t\t}\n\n\t\tpublic int compareLong(StringHash s1, int from1, int to1,\n\t\t\t\tStringHash s2, int from2, int to2) {\n\t\t\tint len = Math.min(to1 - from1, to2 - from2) + 1;\n\t\t\tint l = 0, r = len + 1;\n\t\t\twhile (r - l > 1) {\n\t\t\t\tint mid = (l + r) >>> 1;\n\t\t\t\tif (s1.getLongHash(from1, from1 + mid - 1) == s2.getLongHash(\n\t\t\t\t\t\tfrom2, from2 + mid - 1)) {\n\t\t\t\t\tl = mid;\n\t\t\t\t} else {\n\t\t\t\t\tr = mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (l == len) {\n\t\t\t\tif (to1 - from1 == to2 - from2) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\treturn (to1 - from1) - (to2 - from2);\n\t\t\t}\n\t\t\treturn s1.s.charAt(from1 + l) - s2.s.charAt(from2 + l);\n\t\t}\n\n\t\tprivate int[] generateIntHash(String s, int MOD) {\n\t\t\tint[] result = new int[s.length() + 1];\n\t\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\t\tresult[i + 1] = (int) ((result[i] * 1L * MUL + s.charAt(i)) % MOD);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid solve() {\n\t\tString s = in.next();\n\t\tint n = s.length();\n\t\ts = s + s;\n\t\tHashHelper helper = new HashHelper(s.length() + 1);\n\t\tStringHash hash = helper.generateHash(s);\n\t\tint[] bal = new int[n + n - 1];\n\t\tfor (int i = 0; i < n + n - 1; i++) {\n\t\t\tif (s.charAt(i) == '(') {\n\t\t\t\tbal[i]++;\n\t\t\t} else {\n\t\t\t\tbal[i]--;\n\t\t\t}\n\t\t\tif (i > 0) {\n\t\t\t\tbal[i] += bal[i - 1];\n\t\t\t}\n\t\t}\n\t\tint cur = s.length() - 1;\n\t\tint[] balanceChange = new int[n];\n\t\tint[] qPos = new int[n + n];\n\t\tint[] qValue = new int[n + n];\n\t\tint qSz = 0, qFrom = 0;\n\t\tfor (int pos = n - 1; pos >= 0; pos--) {\n\t\t\twhile (cur != pos) {\n\t\t\t\tcur--;\n\t\t\t\tint value = bal[cur];\n\t\t\t\twhile (qSz > qFrom && qValue[qSz - 1] >= value) {\n\t\t\t\t\tqSz--;\n\t\t\t\t}\n\t\t\t\tqValue[qSz] = value;\n\t\t\t\tqPos[qSz] = cur;\n\t\t\t\tqSz++;\n\t\t\t}\n\t\t\twhile (qPos[qFrom] >= pos + n) {\n\t\t\t\tqFrom++;\n\t\t\t}\n\t\t\tint prevBalance = pos > 0 ? bal[pos - 1] : 0;\n\t\t\tbalanceChange[pos] = qValue[qFrom] - prevBalance;\n\t\t}\n\t\tint cntOpen = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (s.charAt(i) == '(') {\n\t\t\t\tcntOpen++;\n\t\t\t} else {\n\t\t\t\tcntOpen--;\n\t\t\t}\n\t\t}\n\t\tint maxBalanceChange = 0;\n\t\tif (cntOpen < 0) {\n\t\t\tmaxBalanceChange = cntOpen;\n\t\t}\n\t\tint bestCandidate = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (balanceChange[i] >= maxBalanceChange) {\n\t\t\t\tif (bestCandidate != -1) {\n\t\t\t\t\tif (helper.compareInt(hash, i, i + n - 1, hash,\n\t\t\t\t\t\t\tbestCandidate, bestCandidate + n - 1) >= 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbestCandidate = i;\n\t\t\t}\n\t\t}\n\t\tif (bestCandidate < 0) {\n\t\t\tthrow new AssertionError();\n\t\t}\n\t\tfor (int i = 0; i < -cntOpen; i++) {\n\t\t\tout.print(\"(\");\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tout.print(s.charAt(i + bestCandidate));\n\t\t}\n\t\tfor (int i = 0; i < cntOpen; i++) {\n\t\t\tout.print(\")\");\n\t\t}\n\t}\n\n\tvoid run() {\n\t\ttry {\n\t\t\tin = new FastScanner(new File(\"A.in\"));\n\t\t\tout = new PrintWriter(new File(\"A.out\"));\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (FileNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tvoid runIO() {\n\n\t\tin = new FastScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\n\t\tout.close();\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner(File f) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(f));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic FastScanner(InputStream f) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(f));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\tString s = null;\n\t\t\t\ttry {\n\t\t\t\t\ts = br.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (s == null)\n\t\t\t\t\treturn null;\n\t\t\t\tst = new StringTokenizer(s);\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tboolean hasMoreTokens() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\tString s = null;\n\t\t\t\ttry {\n\t\t\t\t\ts = br.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (s == null)\n\t\t\t\t\treturn false;\n\t\t\t\tst = new StringTokenizer(s);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew A().runIO();\n\t}\n}"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Mod = 1000000007;\nclass mint {\n public:\n  int first;\n  mint(long long second = 0) {\n    second %= Mod;\n    first = (int)second;\n  }\n};\nmint operator+(mint a, mint b) {\n  a.first += b.first;\n  if (a.first >= Mod) a.first -= Mod;\n  return a;\n}\nmint operator-(mint a, mint b) {\n  a.first -= b.first;\n  if (a.first < 0) a.first += Mod;\n  return a;\n}\nmint operator*(mint a, mint b) { return mint((long long)a.first * b.first); }\nbool operator==(mint a, mint b) { return a.first == b.first; }\nbool operator!=(mint a, mint b) { return a.first != b.first; }\npair<int, int> operator+(pair<int, int> a, pair<int, int> b) {\n  if (a.second < b.first)\n    b.first -= a.second, a.second = 0;\n  else\n    a.second -= b.first, b.first = 0;\n  return {a.first + b.first, a.second + b.second};\n}\npair<int, int> F(char c) {\n  if (c == '(')\n    return {0, 1};\n  else\n    return {1, 0};\n}\nstring s;\nint l;\npair<int, int> Pref[1000015], Suff[1000015];\nmint _H[1000015], *H = _H + 1;\nmint HP = 101;\nmint Hpot[1000015];\nmint HL[1000015], HR[1000015];\nmint Hash(int lo, int hi) {\n  if (lo < 0) return HL[hi - lo + 1];\n  if (lo > 2000000) return HR[hi - lo + 1];\n  return H[hi] - H[lo - 1] * Hpot[hi - lo + 1];\n}\nmint Hash(pair<int, int> t) { return Hash(t.first, t.first + t.second - 1); }\nmint Hash(int t) { return Hash(t, t); }\nint LCP(int a, int b, int MaxLen) {\n  int lo = 0, hi = MaxLen, mid = (lo + hi + 1) / 2;\n  while (lo != hi) {\n    if (Hash(a, a + mid - 1) == Hash(b, b + mid - 1))\n      lo = mid;\n    else\n      hi = mid - 1;\n    mid = (lo + hi + 1) / 2;\n  }\n  return lo;\n}\nvector<pair<int, int> > Func(int id) {\n  pair<int, int> t = Suff[l - id] + Pref[id];\n  return {{-2000000, t.first}, {id, l - id}, {0, id}, {3000000, t.second}};\n}\nbool Cmp(int id1, int id2) {\n  if (id2 == -1) return true;\n  vector<pair<int, int> > V1 = Func(id1), V2 = Func(id2);\n  vector<int> Vp = {0};\n  for (int i = 0, j = V1[0].second; i < 4; ++i, j += V1[i].second)\n    Vp.push_back(j);\n  for (int i = 0, j = V2[0].second; i < 4; ++i, j += V2[i].second)\n    Vp.push_back(j);\n  sort(Vp.begin(), Vp.end());\n  vector<pair<int, int> > VV1, VV2;\n  int tmp = 0;\n  for (int i = 0, j = 1; i < 4; ++i) {\n    while (j < (int)Vp.size() && Vp[j] <= tmp + V1[i].second) {\n      VV1.push_back({V1[i].first + Vp[j - 1] - tmp, Vp[j] - Vp[j - 1]});\n      ++j;\n    }\n    tmp += V1[i].second;\n  }\n  tmp = 0;\n  for (int i = 0, j = 1; i < 4; ++i) {\n    while (j < (int)Vp.size() && Vp[j] <= tmp + V2[i].second) {\n      VV2.push_back({V2[i].first + Vp[j - 1] - tmp, Vp[j] - Vp[j - 1]});\n      ++j;\n    }\n    tmp += V2[i].second;\n  }\n  for (int i = (int)(0); i < (int)(Vp.size() - 1); ++i)\n    if (Hash(VV1[i]) != Hash(VV2[i])) {\n      tmp = LCP(VV1[i].first, VV2[i].first, VV1[i].second);\n      return Hash(VV1[i].first + tmp).first < Hash(VV2[i].first + tmp).first;\n    }\n  return false;\n}\nint main() {\n  Hpot[0] = 1;\n  for (int i = (int)(1); i < (int)(1000005); ++i)\n    Hpot[i] = Hpot[i - 1] * HP, HL[i] = HL[i - 1] * HP + ')',\n    HR[i] = HR[i - 1] * HP + '(';\n  cin >> s;\n  l = (int)s.size();\n  for (int i = (int)(0); i < (int)(l); ++i) H[i] = H[i - 1] * HP + s[i];\n  for (int i = (int)(0); i < (int)(l); ++i) Pref[i + 1] = Pref[i] + F(s[i]);\n  for (int i = (int)(0); i < (int)(l); ++i)\n    Suff[i + 1] = F(s[l - i - 1]) + Suff[i];\n  int MinLen = l * 2;\n  for (int i = (int)(0); i < (int)(l + 1); ++i) {\n    pair<int, int> t = Suff[l - i] + Pref[i];\n    MinLen = min(MinLen, l + t.first + t.second);\n  }\n  cerr << \"MinLen\"\n       << \" = \" << MinLen << endl;\n  int Best = -1;\n  for (int i = (int)(0); i < (int)(l + 1); ++i) {\n    pair<int, int> t = Suff[l - i] + Pref[i];\n    if (MinLen != l + t.first + t.second) continue;\n    if (Cmp(i, Best)) Best = i;\n  }\n  pair<int, int> r = Suff[l - Best] + Pref[Best];\n  for (int i = (int)(0); i < (int)(r.first); ++i) cout << \"(\";\n  cout << string(s.begin() + Best, s.end())\n       << string(s.begin(), s.begin() + Best);\n  for (int i = (int)(0); i < (int)(r.second); ++i) cout << \")\";\n  cout << endl;\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskA {\n    public void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\tString s = in.next();\n\t\tint n = s.length();\n\t\tint[] b = new int[2*n + 1];\n\t\tfor (int i = 0; i < 2*n; i++) {\n\t\t\tint cur;\n\t\t\tif (s.charAt(i % n) == '(') {\n\t\t\t\tcur = +1;\n\t\t\t} else {\n\t\t\t\tcur = -1;\n\t\t\t}\n\t\t\tb[i + 1] = b[i] + cur;\n\t\t}\n\t\tMinTree min = new MinTree(b.length);\n\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\tmin.update(i, b[i]);\n\t\t}\n\t\tint[] s01 = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ts01[i] = s.charAt(i) == '(' ? 0 : 1;\n\t\t}\n\t\tint[] sa = buildSuffixArray(s01);\n\t\tint[] pos = new int[sa.length];\n\t\tfor (int i = 0; i < sa.length; i++) {\n\t\t\tpos[sa[i]] = i;\n\t\t}\n\t\tint best = -1;\n\t\tint add = Math.max(-b[n], 0);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint delta = min.getMin(i + 1, i + n) - b[i];\n\t\t\tif (delta + add >= 0) {\n\t\t\t\tif (best < 0 || pos[best] > pos[i]) {\n\t\t\t\t\tbest = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (best < 0) {\n\t\t\tthrow new AssertionError();\n\t\t}\n\t\tStringBuilder ans = new StringBuilder();\n\t\tfor (int i = 0; i < -b[n]; i++) {\n\t\t\tans.append(\"(\");\n\t\t}\n\t\tfor (int i = best; i < best + n; i++) {\n\t\t\tans.append(s.charAt(i % n));\n\t\t}\n\t\tfor (int i = 0; i < b[n]; i++) {\n\t\t\tans.append(\")\");\n\t\t}\n\t\tout.println(ans);\n    }\n\n\tprivate int[] buildSuffixArray(int[] _s) {\n\t\tint[] s = compress(_s);\n\t\tint n = s.length;\n\t\tint[] am = new int[n];\n\t\tfor (int x : s) {\n\t\t\t++am[x];\n\t\t}\n\t\tint[] start = new int[n];\n\t\tint numCols = 0;\n\t\tint total = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (am[i] > 0) {\n\t\t\t\tstart[numCols] = total;\n\t\t\t\ttotal += am[i];\n\t\t\t\t++numCols;\n\t\t\t}\n\t\t}\n\t\tint[] sa = new int[n];\n\t\tint[] col = new int[n];\n\t\tint[] tmp = start.clone();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcol[i] = s[i];\n\t\t\tsa[tmp[col[i]]++] = i;\n\t\t}\n\t\tint len = 1;\n\t\twhile (len < n) {\n\t\t\tint[] nsa = new int[n];\n\t\t\tint[] ncol = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint j = sa[i] - len;\n\t\t\t\tif (j < 0) {\n\t\t\t\t\tj += n;\n\t\t\t\t}\n\t\t\t\tnsa[start[col[j]]++] = j;\n\t\t\t}\n\t\t\tnumCols = 1;\n\t\t\tstart[0] = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tint u = nsa[i];\n\t\t\t\t\tint v = nsa[i - 1];\n\t\t\t\t\tif (col[u] != col[v] || col[(u + len) % n] != col[(v + len) % n]) {\n\t\t\t\t\t\tstart[numCols] = i;\n\t\t\t\t\t\t++numCols;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tncol[nsa[i]] = numCols - 1;\n\t\t\t}\n\t\t\tsa = nsa;\n\t\t\tcol = ncol;\n\t\t\tlen *= 2;\n\t\t}\n\t\treturn sa;\n\t}\n\n\tprivate int[] compress(int[] s) {\n\t\tint[] sorted = s.clone();\n\t\tArrays.sort(sorted);\n\t\tint k = 0;\n\t\tfor (int i = 0; i < sorted.length; i++) {\n\t\t\tif (i == 0 || sorted[i] != sorted[i - 1]) {\n\t\t\t\tsorted[k++] = sorted[i];\n\t\t\t}\n\t\t}\n\t\tint[] res = new int[s.length];\n\t\tfor (int i = 0; i < s.length; i++) {\n\t\t\tres[i] = Arrays.binarySearch(sorted, 0, k, s[i]);\n\t\t}\n\t\treturn res;\n\t}\n\n\tclass MinTree {\n\t\tint[] a;\n\t\tint n;\n\t\tMinTree(int n) {\n\t\t\tthis.n = n;\n\t\t\tint k = 1;\n\t\t\twhile (k < n) {\n\t\t\t\tk *= 2;\n\t\t\t}\n\t\t\ta = new int[2 * k];\n\t\t\tArrays.fill(a, Integer.MAX_VALUE / 2);\n\t\t}\n\t\tvoid update(int i, int val) {\n\t\t\ti += n;\n\t\t\twhile (true) {\n\t\t\t\ta[i] = Math.min(a[i], val);\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti = (i - 1) / 2;\n\t\t\t}\n\t\t}\n\t\tint getMin(int l, int r) {\n\t\t\tif (l > r) {\n\t\t\t\treturn Integer.MAX_VALUE / 2;\n\t\t\t}\n\t\t\tl += n;\n\t\t\tr += n;\n\t\t\tif (l == r) {\n\t\t\t\treturn a[l];\n\t\t\t}\n\t\t\tint lm = a[l];\n\t\t\tint rm = a[r];\n\t\t\twhile (r - l > 1) {\n\t\t\t\tif (l % 2 == 1) {\n\t\t\t\t\tlm = Math.min(lm, a[l + 1]);\n\t\t\t\t}\n\t\t\t\tif (r % 2 == 0) {\n\t\t\t\t\trm = Math.min(rm, a[r - 1]);\n\t\t\t\t}\n\t\t\t\tl = (l - 1) / 2;\n\t\t\t\tr = (r - 1) / 2;\n\t\t\t}\n\t\t\treturn Math.min(lm, rm);\n\t\t}\n\t}\n}\n\nclass FastScanner {\n\n\tprivate BufferedReader in;\n\tprivate StringTokenizer st;\n\n\tpublic FastScanner(InputStream stream) {\n\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t}\n\n\tpublic String next() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(in.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.util.List;\nimport java.math.BigInteger;\nimport java.io.PrintStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Comparator;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author shu_mj @ http://shu-mj.com\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tScanner in = new Scanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskA {\n    Scanner in;\n    PrintWriter out;\n\n    public void solve(int testNumber, Scanner in, PrintWriter out) {\n        this.in = in;\n        this.out = out;\n        run();\n    }\n\n    void run() {\n        char[] cs = in.next().toCharArray();\n        int n = cs.length;\n        int n2 = n * 2;\n        cs = Algo.merge(cs, cs);\n//        SuffixArray sa = new SuffixArray(cs);\n        int[] is = new int[n2];\n        for (int i = 0; i < n2; i++) is[i] = cs[i];\n        int[] sa = buildSuffixArray(is);\n//        int[] sa = sa(cs);\n        Seg seg = new Seg(cs);\n        int[] lr = new int[2];\n        for (int i = 0; ; i++) {\n            int id = sa[i];\n            if (id < n) {\n                seg.query(id, id + n, lr);\n                if (lr[1] == 0) {\n                    for (int j = 0; j < lr[0]; j++) out.print('(');\n                    for (int j = 0; j < n; j++) out.print(cs[j + id]);\n                    out.println();\n                    return ;\n                } else if (lr[0] == 0) {\n                    for (int j = 0; j < n; j++) out.print(cs[j + id]);\n                    for (int j = 0; j < lr[1]; j++) out.print(')');\n                    out.println();\n                    return ;\n                }\n            }\n        }\n    }\n/*\n    private static interface BaseArray {\n        public int get(int i);\n\n        public void set(int i, int val);\n\n        public int update(int i, int val);\n    }\n\n    private static class CharArray implements BaseArray {\n        private char[] m_A = null;\n        private int m_pos = 0;\n\n        CharArray(char[] A, int pos) {\n            m_A = A;\n            m_pos = pos;\n        }\n\n        public int get(int i) {\n            return m_A[m_pos + i] & 0xffff;\n        }\n\n        public void set(int i, int val) {\n            m_A[m_pos + i] = (char) (val & 0xffff);\n        }\n\n        public int update(int i, int val) {\n            return m_A[m_pos + i] += val & 0xffff;\n        }\n    }\n    private static class IntArray implements BaseArray {\n        private int[] m_A = null;\n        private int m_pos = 0;\n\n        IntArray(int[] A, int pos) {\n            m_A = A;\n            m_pos = pos;\n        }\n\n        public int get(int i) {\n            return m_A[m_pos + i];\n        }\n\n        public void set(int i, int val) {\n            m_A[m_pos + i] = val;\n        }\n\n        public int update(int i, int val) {\n            return m_A[m_pos + i] += val;\n        }\n    }\n    */\n/* find the start or end of each bucket *//*\n\n    private static void getCounts(BaseArray T, BaseArray C, int n, int k) {\n        int i;\n        for(i = 0;i < k;++i){\n            C.set(i, 0);\n        }\n        for(i = 0;i < n;++i){\n            C.update(T.get(i), 1);\n        }\n    }\n\n    private static void getBuckets(BaseArray C, BaseArray B, int k, boolean end) {\n        int i, sum = 0;\n        if(end != false){\n            for(i = 0;i < k;++i){\n                sum += C.get(i);\n                B.set(i, sum);\n            }\n        }else{\n            for(i = 0;i < k;++i){\n                sum += C.get(i);\n                B.set(i, sum - C.get(i));\n            }\n        }\n    }\n\n    */\n/* sort all type LMS suffixes *//*\n\n    private static void LMSsort(BaseArray T, int[] SA, BaseArray C,\n                                BaseArray B, int n, int k) {\n        int b, i, j;\n        int c0, c1;\n\t\t*/\n/* compute SAl *//*\n\n        if(C == B){\n            getCounts(T, C, n, k);\n        }\n        getBuckets(C, B, k, false); */\n/* find starts of buckets *//*\n\n        j = n - 1;\n        b = B.get(c1 = T.get(j));\n        --j;\n        SA[b++] = (T.get(j) < c1) ? ~j : j;\n        for(i = 0;i < n;++i){\n            if(0 < (j = SA[i])){\n                if((c0 = T.get(j)) != c1){\n                    B.set(c1, b);\n                    b = B.get(c1 = c0);\n                }\n                --j;\n                SA[b++] = (T.get(j) < c1) ? ~j : j;\n                SA[i] = 0;\n            }else if(j < 0){\n                SA[i] = ~j;\n            }\n        }\n\t\t*/\n/* compute SAs *//*\n\n        if(C == B){\n            getCounts(T, C, n, k);\n        }\n        getBuckets(C, B, k, true); */\n/* find ends of buckets *//*\n\n        for(i = n - 1, b = B.get(c1 = 0);0 <= i;--i){\n            if(0 < (j = SA[i])){\n                if((c0 = T.get(j)) != c1){\n                    B.set(c1, b);\n                    b = B.get(c1 = c0);\n                }\n                --j;\n                SA[--b] = (T.get(j) > c1) ? ~(j + 1) : j;\n                SA[i] = 0;\n            }\n        }\n    }\n\n    private static int LMSpostproc(BaseArray T, int[] SA, int n, int m) {\n        int i, j, p, q, plen, qlen, name;\n        int c0, c1;\n        boolean diff;\n\n\t\t*/\n/*\n\t\t * compact all the sorted substrings into the first m items of SA 2*m\n\t\t * must be not larger than n (proveable)\n\t\t *//*\n\n        for(i = 0;(p = SA[i]) < 0;++i){\n            SA[i] = ~p;\n        }\n        if(i < m){\n            for(j = i, ++i;;++i){\n                if((p = SA[i]) < 0){\n                    SA[j++] = ~p;\n                    SA[i] = 0;\n                    if(j == m){\n                        break;\n                    }\n                }\n            }\n        }\n\n\t\t*/\n/* store the length of all substrings *//*\n\n        i = n - 1;\n        j = n - 1;\n        c0 = T.get(n - 1);\n        do{\n            c1 = c0;\n        }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));\n        for(;0 <= i;){\n            do{\n                c1 = c0;\n            }while ((0 <= --i) && ((c0 = T.get(i)) <= c1));\n            if(0 <= i){\n                SA[m + ((i + 1) >> 1)] = j - i;\n                j = i + 1;\n                do{\n                    c1 = c0;\n                }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));\n            }\n        }\n\n\t\t*/\n/* find the lexicographic names of all substrings *//*\n\n        for(i = 0, name = 0, q = n, qlen = 0;i < m;++i){\n            p = SA[i];\n            plen = SA[m + (p >> 1)];\n            diff = true;\n            if((plen == qlen) && ((q + plen) < n)){\n                for(j = 0;(j < plen) && (T.get(p + j) == T.get(q + j));++j){\n                }\n                if(j == plen){\n                    diff = false;\n                }\n            }\n            if(diff != false){\n                ++name;\n                q = p;\n                qlen = plen;\n            }\n            SA[m + (p >> 1)] = name;\n        }\n\n        return name;\n    }\n\n    */\n/* compute SA and BWT *//*\n\n    private static void induceSA(BaseArray T, int[] SA, BaseArray C,\n                                 BaseArray B, int n, int k) {\n        int b, i, j;\n        int c0, c1;\n\t\t*/\n/* compute SAl *//*\n\n        if(C == B){\n            getCounts(T, C, n, k);\n        }\n        getBuckets(C, B, k, false); */\n/* find starts of buckets *//*\n\n        j = n - 1;\n        b = B.get(c1 = T.get(j));\n        SA[b++] = ((0 < j) && (T.get(j - 1) < c1)) ? ~j : j;\n        for(i = 0;i < n;++i){\n            j = SA[i];\n            SA[i] = ~j;\n            if(0 < j){\n                if((c0 = T.get(--j)) != c1){\n                    B.set(c1, b);\n                    b = B.get(c1 = c0);\n                }\n                SA[b++] = ((0 < j) && (T.get(j - 1) < c1)) ? ~j : j;\n            }\n        }\n\t\t*/\n/* compute SAs *//*\n\n        if(C == B){\n            getCounts(T, C, n, k);\n        }\n        getBuckets(C, B, k, true); */\n/* find ends of buckets *//*\n\n        for(i = n - 1, b = B.get(c1 = 0);0 <= i;--i){\n            if(0 < (j = SA[i])){\n                if((c0 = T.get(--j)) != c1){\n                    B.set(c1, b);\n                    b = B.get(c1 = c0);\n                }\n                SA[--b] = ((j == 0) || (T.get(j - 1) > c1)) ? ~j : j;\n            }else{\n                SA[i] = ~j;\n            }\n        }\n    }\n\n    */\n/*\n     * find the suffix array SA of T[0..n-1] in {0..k-1}^n use a working space\n     * (excluding T and SA) of at most 2n+O(1) for a constant alphabet\n     *//*\n\n    private static void SA_IS(BaseArray T, int[] SA, int fs, int n, int k) {\n        BaseArray C, B, RA;\n        int i, j, b, m, p, q, name, newfs;\n        int c0, c1;\n        int flags = 0;\n\n        if(k <= 256){\n            C = new IntArray(new int[k], 0);\n            if(k <= fs){\n                B = new IntArray(SA, n + fs - k);\n                flags = 1;\n            }else{\n                B = new IntArray(new int[k], 0);\n                flags = 3;\n            }\n        }else if(k <= fs){\n            C = new IntArray(SA, n + fs - k);\n            if(k <= (fs - k)){\n                B = new IntArray(SA, n + fs - k * 2);\n                flags = 0;\n            }else if(k <= 1024){\n                B = new IntArray(new int[k], 0);\n                flags = 2;\n            }else{\n                B = C;\n                flags = 8;\n            }\n        }else{\n            C = B = new IntArray(new int[k], 0);\n            flags = 4 | 8;\n        }\n\n\t\t*/\n/*\n\t\t * stage 1: reduce the problem by at least 1/2 sort all the\n\t\t * LMS-substrings\n\t\t *//*\n\n        getCounts(T, C, n, k);\n        getBuckets(C, B, k, true); */\n/* find ends of buckets *//*\n\n        for(i = 0;i < n;++i){\n            SA[i] = 0;\n        }\n        b = -1;\n        i = n - 1;\n        j = n;\n        m = 0;\n        c0 = T.get(n - 1);\n        do{\n            c1 = c0;\n        }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));\n        for(;0 <= i;){\n            do{\n                c1 = c0;\n            }while ((0 <= --i) && ((c0 = T.get(i)) <= c1));\n            if(0 <= i){\n                if(0 <= b){\n                    SA[b] = j;\n                }\n                b = B.update(c1, -1);\n                j = i;\n                ++m;\n                do{\n                    c1 = c0;\n                }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));\n            }\n        }\n        if(1 < m){\n            LMSsort(T, SA, C, B, n, k);\n            name = LMSpostproc(T, SA, n, m);\n        }else if(m == 1){\n            SA[b] = j + 1;\n            name = 1;\n        }else{\n            name = 0;\n        }\n\n\t\t*/\n/*\n\t\t * stage 2: solve the reduced problem recurse if names are not yet\n\t\t * unique\n\t\t *//*\n\n        if(name < m){\n            if((flags & 4) != 0){\n                C = null;\n                B = null;\n            }\n            if((flags & 2) != 0){\n                B = null;\n            }\n            newfs = (n + fs) - (m * 2);\n            if((flags & (1 | 4 | 8)) == 0){\n                if((k + name) <= newfs){\n                    newfs -= k;\n                }else{\n                    flags |= 8;\n                }\n            }\n            for(i = m + (n >> 1) - 1, j = m * 2 + newfs - 1;m <= i;--i){\n                if(SA[i] != 0){\n                    SA[j--] = SA[i] - 1;\n                }\n            }\n            RA = new IntArray(SA, m + newfs);\n            SA_IS(RA, SA, newfs, m, name);\n            RA = null;\n\n            i = n - 1;\n            j = m * 2 - 1;\n            c0 = T.get(n - 1);\n            do{\n                c1 = c0;\n            }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));\n            for(;0 <= i;){\n                do{\n                    c1 = c0;\n                }while ((0 <= --i) && ((c0 = T.get(i)) <= c1));\n                if(0 <= i){\n                    SA[j--] = i + 1;\n                    do{\n                        c1 = c0;\n                    }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));\n                }\n            }\n\n            for(i = 0;i < m;++i){\n                SA[i] = SA[m + SA[i]];\n            }\n            if((flags & 4) != 0){\n                C = B = new IntArray(new int[k], 0);\n            }\n            if((flags & 2) != 0){\n                B = new IntArray(new int[k], 0);\n            }\n        }\n\n\t\t*/\n/* stage 3: induce the result for the original problem *//*\n\n        if((flags & 8) != 0){\n            getCounts(T, C, n, k);\n        }\n\t\t*/\n/* put all left-most S characters into their buckets *//*\n\n        if(1 < m){\n            getBuckets(C, B, k, true); */\n/* find ends of buckets *//*\n\n            i = m - 1;\n            j = n;\n            p = SA[m - 1];\n            c1 = T.get(p);\n            do{\n                q = B.get(c0 = c1);\n                while (q < j){\n                    SA[--j] = 0;\n                }\n                do{\n                    SA[--j] = p;\n                    if(--i < 0){\n                        break;\n                    }\n                    p = SA[i];\n                }while ((c1 = T.get(p)) == c0);\n            }while (0 <= i);\n            while (0 < j){\n                SA[--j] = 0;\n            }\n        }\n        induceSA(T, SA, C, B, n, k);\n        C = null;\n        B = null;\n    }\n\n    */\n/* char *//*\n\n    public static void suffixsort(char[] T, int[] SA, int n) {\n        if((T == null) || (SA == null) || (T.length < n) || (SA.length < n)){\n            return;\n        }\n        if(n <= 1){\n            if(n == 1){\n                SA[0] = 0;\n            }\n            return;\n        }\n        SA_IS(new CharArray(T, 0), SA, 0, n, 128);\n    }\n\n    public static int[] sa(char[] T)\n    {\n        int n = T.length;\n        int[] sa = new int[n];\n        suffixsort(T, sa, n);\n        return sa;\n    }\n*/\n\n    private int[] buildSuffixArray(int[] _s) {\n        int[] s = compress(_s);\n        int n = s.length;\n        int[] am = new int[n];\n        for (int x : s) {\n            ++am[x];\n        }\n        int[] start = new int[n];\n        int numCols = 0;\n        int total = 0;\n        for (int i = 0; i < n; i++) {\n            if (am[i] > 0) {\n                start[numCols] = total;\n                total += am[i];\n                ++numCols;\n            }\n        }\n        int[] sa = new int[n];\n        int[] col = new int[n];\n        int[] tmp = start.clone();\n        for (int i = 0; i < n; i++) {\n            col[i] = s[i];\n            sa[tmp[col[i]]++] = i;\n        }\n        int len = 1;\n        while (len < n) {\n            int[] nsa = new int[n];\n            int[] ncol = new int[n];\n            for (int i = 0; i < n; i++) {\n                int j = sa[i] - len;\n                if (j < 0) {\n                    j += n;\n                }\n                nsa[start[col[j]]++] = j;\n            }\n            numCols = 1;\n            start[0] = 0;\n            for (int i = 0; i < n; i++) {\n                if (i > 0) {\n                    int u = nsa[i];\n                    int v = nsa[i - 1];\n                    if (col[u] != col[v] || col[(u + len) % n] != col[(v + len) % n]) {\n                        start[numCols] = i;\n                        ++numCols;\n                    }\n                }\n                ncol[nsa[i]] = numCols - 1;\n            }\n            sa = nsa;\n            col = ncol;\n            len *= 2;\n        }\n        return sa;\n    }\n\n    private int[] compress(int[] s) {\n        int[] sorted = s.clone();\n        Arrays.sort(sorted);\n        int k = 0;\n        for (int i = 0; i < sorted.length; i++) {\n            if (i == 0 || sorted[i] != sorted[i - 1]) {\n                sorted[k++] = sorted[i];\n            }\n        }\n        int[] res = new int[s.length];\n        for (int i = 0; i < s.length; i++) {\n            res[i] = Arrays.binarySearch(sorted, 0, k, s[i]);\n        }\n        return res;\n    }\n\n    class Seg {\n        int N;\n        int[] left, right;\n\n        Seg(char[] cs) {\n            int n = cs.length;\n            N = Integer.highestOneBit(n) << 1;\n            left = new int[N * 2];\n            right = new int[N * 2];\n            for (int i = 0; i < N; i++) {\n                if (i < n && cs[i] == '(') {\n                    left[i + N] = 0;\n                    right[i + N] = 1;\n                } else {\n                    left[i + N] = 1;\n                    right[i + N] = 0;\n                }\n            }\n            for (int i = N - 1; i > 0; i--) {\n                left[i] = left[i * 2] + Math.max(0, left[i * 2 + 1] - right[i * 2]);\n                right[i] = right[i * 2 + 1] + Math.max(0, right[i * 2] - left[i * 2 + 1]);\n            }\n        }\n        void query(int s, int t, int[] lr) {\n            int l = 0, r = 0;\n            while (0 < s && s + (s & -s) <= t) {\n                int i = (N + s) / (s & -s);\n                int nl = l + Math.max(0, left[i] - r);\n                int nr = right[i] + Math.max(0, r - left[i]);\n                l = nl; r = nr;\n                s += s & -s;\n            }\n            int l2 = 0, r2 = 0;\n            while (s < t) {\n                int i = (N + t) / (t & -t) - 1;\n                int nl = left[i] + Math.max(0, l2 - right[i]);\n                int nr = r2 + Math.max(0, right[i] - l2);\n                l2 = nl; r2 = nr;\n                t -= t & -t;\n            }\n            lr[0] = l + Math.max(0, l2 - r);\n            lr[1] = r2 + Math.max(0, r - l2);\n        }\n    }\n/*\n\n    void run2() {\n        char[] cs = in.next().toCharArray();\n        int n = cs.length;\n        if (cs[n - 1] == '(' && cs[0] == '(' && !Algo.allTheSame(cs)) {\n            int b = 0;\n            while (cs[b] == '(') b++;\n            cs = Algo.merge(Arrays.copyOfRange(cs, b, n), Arrays.copyOfRange(cs, 0, b));\n        }\n        if (cs[n - 1] == ')' && cs[0] == ')' && !Algo.allTheSame(cs)) {\n            int b = 0;\n            while (cs[b] == ')') b++;\n            cs = Algo.merge(Arrays.copyOfRange(cs, b, n), Arrays.copyOfRange(cs, 0, b));\n        }\n        int[] is = new int[n];\n        List<PII> ps = new ArrayList<PII>();\n        for (int i = 0; i < n; i++) {\n            if (cs[i] == '(') {\n                if (i == 0 || cs[i] != cs[i - 1]) {\n                    is[i] = -1;\n                } else {\n                    is[i] = is[i - 1] - 1;\n                }\n                if (i == n - 1 || cs[i] != cs[i + 1]) {\n                    ps.add(new PII(is[i], i));\n                }\n            } else {\n                if (i == 0 || cs[i] != cs[i - 1]) {\n                    is[i] = 1;\n                } else {\n                    is[i] = is[i - 1] + 1;\n                }\n                if (i == n - 1 || cs[i] != cs[i + 1]) {\n                    ps.add(new PII(is[i], i));\n                }\n            }\n        }\n//        Algo.debug(ps);\n        int m = ps.size();\n        int[] hs = new int[m];\n        for (int i = 0; i < m; i++) {\n            hs[i] = ps.get(i).x;\n        }\n        int[] ss = hs.clone();\n        Algo.sort(ss);\n        ss = Algo.unique(ss);\n        for (int i = 0; i < m; i++) {\n            hs[i] = Algo.lowerBound(ss, hs[i]) + 2;\n        }\n        hs = Algo.merge(hs, hs);\n        SuffixArray sa = new SuffixArray(hs, ss.length + 5);\n        int id = -1;\n        for (int i = 0; ; i++) {\n            if (sa.si[i] < hs.length / 2) {\n                id = sa.si[i];\n                break;\n            }\n        }\n        int mid = ps.get(id).y - Math.abs(ps.get(id).x) + 1;\n        int l = Algo.count(cs, '(');\n        int r = n - l;\n        if (l < r) {\n            for (int i = l; i < r; i++) {\n                out.print('(');\n            }\n            l = r;\n        }\n        for (int i = mid; i < n; i++) {\n            out.print(cs[i]);\n        }\n        for (int i = 0; i < mid; i++) {\n            out.print(cs[i]);\n        }\n        if (r < l) {\n            for (int i = r; i < l; i++) {\n                out.print(')');\n            }\n        }\n        out.println();\n    }\n    class SuffixArray {\n        public int n;\n        public int[] cs;\n        public int[] si, is;// si:= suffix array(si[0] = end); is[si[i]] = i;\n\n        public int[] indexSort(int[] is, int max) {\n            int[] c = new int[max + 1];\n            for (int i : is) c[i]++;\n            for (int i = 1; i < max; i++) c[i] += c[i - 1];\n            int n = is.length;\n            int[] si = new int[n];\n            for (int i = n - 1; i >= 0; i--) si[--c[is[i]]] = i;\n            return si;\n        }\n\n        public SuffixArray(int[] t, int max) {\n            n = t.length;\n            cs = new int[n + 1];\n            System.arraycopy(t, 0, cs, 0, n);\n            cs[n] = 0;// guard, minimum value and not allowed to use\n            is = new int[n + 1];\n            for (int i = 0; i <= n; i++) is[i] = cs[i];\n            si = indexSort(is, max);\n            int[] a = new int[n + 1], b = new int[n + 1];\n            for (int h = 0; ; ) {\n                for (int i = 0; i < n; i++) {\n                    int x = si[i + 1], y = si[i];\n                    b[i + 1] = b[i];\n                    if (is[x] > is[y] || is[x + h] > is[y + h]) b[i + 1]++;\n                }\n                for (int i = 0; i <= n; i++) is[si[i]] = b[i];\n                if (b[n] == n) break;\n                h = Math.max(1, h << 1);\n                for (int k = h; k >= 0; k -= h) {\n                    Arrays.fill(b, 0);\n                    b[0] = k;\n                    for (int i = k; i <= n; i++) b[is[i]]++;\n                    for (int i = 0; i < n; i++) b[i + 1] += b[i];\n                    for (int i = n; i >= 0; i--) {\n                        a[--b[si[i] + k > n ? 0 : is[si[i] + k]]] = si[i];\n                    }\n                    int[] tmp = si; si = a; a = tmp;\n                }\n            }\n        }\n\n        public int[] hs;// hs[i]:= suffix i & i+1 's LCP\n\n        public void buildHs() {\n            hs = new int[n + 1];\n            for (int i = 0, h = 0; i < n; i++) {\n                for (int j = si[is[i] - 1]; cs[i + h] == cs[j + h]; h++) ;\n                hs[is[i] - 1] = h;\n                if (h > 0) h--;\n            }\n        }\n\n        public RMQ rmq;\n\n        public void buildRMQ() {\n            rmq = new RMQ(hs);\n        }\n\n        // begin from pos i,j, LCP means that Longest Common Prefix\n        public int getLCP(int i, int j) {\n            if (i == j) return n - i;\n            return rmq.vs[rmq.query(Math.min(is[i], is[j]), Math.max(is[i], is[j]))];\n        }\n    }\n*/\n\n}\n\nclass Scanner {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public Scanner(InputStream in) {\n        br = new BufferedReader(new InputStreamReader(in));\n        eat(\"\");\n    }\n\n    private void eat(String s) {\n        st = new StringTokenizer(s);\n    }\n\n    public String nextLine() {\n        try {\n            return br.readLine();\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    public boolean hasNext() {\n        while (!st.hasMoreTokens()) {\n            String s = nextLine();\n            if (s == null)\n                return false;\n            eat(s);\n        }\n        return true;\n    }\n\n    public String next() {\n        hasNext();\n        return st.nextToken();\n    }\n\n}\n\nclass Algo {\n\n\n    public static char[] merge(char[] is, char[] js) {\n        int in = is.length;\n        int jn = js.length;\n        char[] rs = new char[in + jn];\n        System.arraycopy(is, 0, rs, 0, in);\n        System.arraycopy(js, 0, rs, in, jn);\n        return rs;\n    }\n\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e6 + 5;\nconst int inf = 0x3f3f3f3f;\nconst int mod = 1e9 + 7;\nstruct SAIS {\n  int s[maxn << 1], t[maxn << 1], sa[maxn], rk[maxn], hi[maxn], p[maxn],\n      tax[maxn], cur[maxn];\n  void inducedSort(int n, int m, int n1, int *s, int *s1, int *t) {\n    for (int i = 0; i < n; ++i) sa[i] = -1;\n    for (int i = 0; i < m; ++i) tax[i] = 0;\n    for (int i = 0; i < n; ++i) ++tax[s[i]];\n    for (int i = 1; i < m; ++i) tax[i] += tax[i - 1];\n    for (int i = 0; i < m; ++i) cur[i] = tax[i] - 1;\n    for (int i = n1 - 1; ~i; --i) sa[cur[s[s1[i]]]--] = s1[i];\n    for (int i = 1; i < m; ++i) cur[i] = tax[i - 1];\n    for (int i = 0; i < n; ++i)\n      if (sa[i] > 0 && t[sa[i] - 1]) sa[cur[s[sa[i] - 1]]++] = sa[i] - 1;\n    for (int i = 0; i < m; ++i) cur[i] = tax[i] - 1;\n    for (int i = n - 1; ~i; --i)\n      if (sa[i] > 0 && !t[sa[i] - 1]) sa[cur[s[sa[i] - 1]]--] = sa[i] - 1;\n  }\n  void sais(int n, int m, int *s, int *t, int *p) {\n    int n1 = t[n - 1] = 0, ch = rk[0] = -1, *s1 = s + n;\n    for (int i = n - 2; ~i; --i)\n      t[i] = s[i] == s[i + 1] ? t[i + 1] : s[i] > s[i + 1];\n    for (int i = 1; i < n; ++i)\n      rk[i] = t[i - 1] && !t[i] ? p[n1] = i, n1++ : -1;\n    inducedSort(n, m, n1, s, p, t);\n    for (int i = 0, x, y; i < n; ++i) {\n      if ((x = rk[sa[i]]) == -1) continue;\n      if (ch < 1 || p[x + 1] - p[x] != p[y + 1] - p[y])\n        ++ch;\n      else\n        for (int j = p[x], k = p[y]; j <= p[x + 1]; ++j, ++k)\n          if ((s[j] << 1 | t[j]) != (s[k] << 1 | t[k])) {\n            ++ch;\n            break;\n          }\n      s1[y = x] = ch;\n    }\n    if (ch + 1 < n1)\n      sais(n1, ch + 1, s1, t + n, p + n1);\n    else\n      for (int i = 0; i < n1; ++i) sa[s1[i]] = i;\n    for (int i = 0; i < n1; ++i) s1[i] = p[sa[i]];\n    inducedSort(n, m, n1, s, s1, t);\n  }\n  void solve(char *str, int n, int m) {\n    for (int i = 0; i < n; ++i) s[i] = str[i];\n    s[n++] = 0;\n    sais(n, m, s, t, p);\n    for (int i = 0; i < n; ++i) rk[sa[i]] = i;\n    --n;\n    for (int i = 0, k = hi[0] = 0; i < n; ++i) {\n      int j = sa[rk[i] - 1];\n      while (s[i + k] == s[j + k]) ++k;\n      if (hi[rk[i]] = k) --k;\n    }\n    for (int i = n; i >= 1; --i) ++sa[i], rk[i] = rk[i - 1];\n  }\n} sais;\nchar s[maxn];\nint sum[maxn], mn[maxn], que[maxn];\nint n, p1, p2;\nint main() {\n  scanf(\"%s\", s + 1);\n  n = strlen(s + 1);\n  for (int i = 1; i <= n; ++i) s[i + n] = s[i];\n  int tn = n;\n  n <<= 1;\n  sais.solve(s + 1, n, 256);\n  for (int i = 1; i <= n; ++i) {\n    sum[i] = sum[i - 1] + (s[i] == '(' ? 1 : -1);\n  }\n  p1 = 1, p2 = 0;\n  for (int i = 1; i <= n; ++i) {\n    while (p1 <= p2 && sum[que[p2]] >= sum[i]) --p2;\n    que[++p2] = i;\n    while (i - que[p1] + 1 > tn) ++p1;\n    if (i >= tn) mn[i - tn + 1] = sum[que[p1]] - sum[i - tn];\n  }\n  int x = inf, y;\n  for (int i = 1; i <= tn; ++i) {\n    mn[i] = mn[i] >= 0 ? 0 : -mn[i];\n    x = min(x, mn[i]);\n  }\n  int p = 0;\n  y = x + sum[tn];\n  for (int i = 1; i <= n; ++i) {\n    if (sais.sa[i] > tn) continue;\n    if (mn[sais.sa[i]] == x) {\n      p = sais.sa[i];\n      break;\n    }\n  }\n  while (x--) putchar('(');\n  s[p + tn] = 0;\n  printf(\"%s\", s + p);\n  while (y--) putchar(')');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar s[2000100];\nint Lb[2000100 << 2], Rb[2000100 << 2];\nvoid build(int x, int L, int R) {\n  if (L == R) {\n    if (s[L] == '(')\n      Rb[x] = 1;\n    else\n      Lb[x] = 1;\n    return;\n  }\n  int mid = L + R >> 1;\n  build((x << 1), L, mid);\n  build((x << 1 | 1), mid + 1, R);\n  if (Rb[(x << 1)] > Lb[(x << 1 | 1)]) {\n    Lb[x] = Lb[(x << 1)];\n    Rb[x] = Rb[(x << 1 | 1)] + Rb[(x << 1)] - Lb[(x << 1 | 1)];\n  } else {\n    Lb[x] = Lb[(x << 1)] + Lb[(x << 1 | 1)] - Rb[(x << 1)];\n    Rb[x] = Rb[(x << 1 | 1)];\n  }\n}\nint lb, rb;\nint qury(int x, int L, int R, int l, int r) {\n  if (l <= L && R <= r) {\n    lb = lb + max(0, Lb[x] - rb);\n    rb = Rb[x] + max(0, rb - Lb[x]);\n    return lb;\n  }\n  int mid = L + R >> 1, res;\n  if (l <= mid) res = qury((x << 1), L, mid, l, r);\n  if (r > mid) res = qury((x << 1 | 1), mid + 1, R, l, r);\n  return res;\n}\nlong long sum1[2000100], sum2[2000100];\nlong long fox1[2000100], fox2[2000100];\nlong long f_abs(long long a) {\n  return (a % 1000000009 + 1000000009) % 1000000009;\n}\nint main() {\n  scanf(\"%s\", s);\n  int zer = 0, one = 0, len = strlen(s), _len = len;\n  int su1 = 0, su2 = 0;\n  for (int i = 0; i < _len; i++)\n    if (s[i] == '(')\n      su1++;\n    else\n      su2++;\n  for (int i = 0; i < _len - 1; i++) s[len++] = s[i];\n  s[len] = 0;\n  fox1[0] = 1;\n  fox2[0] = 1;\n  for (int i = 0; i < len; i++) {\n    sum1[i + 1] = sum1[i] * 17 + (s[i] == '(' ? 14 : 29741);\n    sum1[i + 1] %= 1000000009;\n    fox1[i + 1] = fox1[i] * 17;\n    fox1[i + 1] %= 1000000009;\n    sum2[i + 1] = sum2[i] * 1031 + (s[i] == '(' ? 13 : 247);\n    sum2[i + 1] %= 1000000009;\n    fox2[i + 1] = fox2[i] * 1031;\n    fox2[i + 1] %= 1000000009;\n  }\n  build(1, 0, len - 1);\n  int ans = 20000000, bj;\n  for (int i = 0; i < _len; i++) {\n    lb = rb = 0;\n    int a = qury(1, 0, len - 1, i, i + _len - 1);\n    if (a < ans) {\n      ans = a;\n      bj = i;\n    } else if (a == ans) {\n      int l = 0, r = _len, mid, as;\n      while (l <= r) {\n        mid = l + r >> 1;\n        if (f_abs(sum1[bj + mid] - sum1[bj] * fox1[mid]) ==\n            f_abs(sum1[i + mid] - sum1[i] * fox1[mid])) {\n          if (f_abs(sum2[bj + mid] - sum2[bj] * fox2[mid]) ==\n              f_abs(sum2[i + mid] - sum2[i] * fox2[mid])) {\n            as = mid;\n            l = mid + 1;\n          } else\n            r = mid - 1;\n        } else\n          r = mid - 1;\n      }\n      if (as == _len || s[bj + as] < s[i + as]) continue;\n      bj = i;\n    }\n  }\n  string f_ans = \"\";\n  for (int i = 0; i < ans; i++) f_ans += '(';\n  for (int i = bj; i < _len; i++) f_ans += s[i];\n  for (int i = 0; i < bj; i++) f_ans += s[i];\n  int lef = su1 + ans - su2;\n  for (int i = 0; i < lef; i++) f_ans += ')';\n  cout << f_ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nint const N = 2234567;\nint const X = 33533;\nlong long M1;\nlong long M2;\nlong long const MASK = (1LL << 32) - 1;\nlong long POW1[N], POW2[N];\nint s[N];\nint bal[N];\nstruct hash {\n  long long h;\n  int len;\n};\nbool operator==(hash const& a, hash const& b) {\n  return a.len == b.len && a.h == b.h;\n}\nhash OPEN[N], CLOSE[N], hs[N];\nlong long add1(long long h1, long long h2, int len2) {\n  return (h1 * POW1[len2] + h2) % M1;\n}\nlong long add2(long long h1, long long h2, int len2) {\n  return (h1 * POW2[len2] + h2) % M2;\n}\nhash operator+(hash const& a, hash const& b) {\n  return {(add1(a.h >> 32, b.h >> 32, b.len) << 32) |\n              add2(a.h & MASK, b.h & MASK, b.len),\n          a.len + b.len};\n}\nint const TR = 1 << 21;\nint const INF = 1 << 30;\nint trmin[TR * 2];\nvoid settree(int x, int y) {\n  x += TR;\n  trmin[x] = y;\n  while (x > 1) {\n    x >>= 1;\n    if (trmin[x * 2] < trmin[x * 2 + 1])\n      trmin[x] = trmin[x * 2];\n    else\n      trmin[x] = trmin[x * 2 + 1];\n  }\n}\nint getmin(int left, int right) {\n  --right;\n  left += TR;\n  right += TR;\n  int ret = INF;\n  while (left <= right) {\n    if (left & 1) {\n      if (ret > trmin[left]) ret = trmin[left];\n      ++left;\n    }\n    if ((right & 1) == 0) {\n      if (ret > trmin[right]) ret = trmin[right];\n      --right;\n    }\n    left >>= 1;\n    right >>= 1;\n  }\n  return ret;\n}\nstruct answer {\n  int addOpen;\n  int pos;\n  int addClose;\n};\nint n;\nint getChar(answer const& f, int id) {\n  if (id < f.addOpen) return '(';\n  id -= f.addOpen;\n  if (id < n) return s[f.pos + id];\n  id -= n;\n  if (id < f.addClose) return ')';\n}\nhash getHash(int left, int right) {\n  long long h1 = hs[right - 1].h >> 32;\n  long long h2 = hs[right - 1].h & MASK;\n  long long g1 = hs[left - 1].h >> 32;\n  long long g2 = hs[left - 1].h & MASK;\n  h1 -= g1 * POW1[right - left] % M1;\n  h2 -= g2 * POW2[right - left] % M2;\n  if (h1 < 0) h1 += M1;\n  if (h2 < 0) h2 += M2;\n  return {(h1 << 32) | h2, right - left};\n}\nhash getHash(answer const& f, int len) {\n  if (len <= f.addOpen) {\n    return OPEN[len];\n  }\n  hash z = OPEN[f.addOpen];\n  len -= f.addOpen;\n  if (len <= n) {\n    return z + getHash(f.pos, f.pos + len);\n  }\n  z = z + getHash(f.pos, f.pos + n);\n  len -= n;\n  if (len <= f.addClose) {\n    return z + CLOSE[len];\n  }\n  assert(false);\n}\nbool operator<(answer const& f, answer const& g) {\n  if (f.addOpen + f.addClose != g.addOpen + g.addClose)\n    return f.addOpen + f.addClose < g.addOpen + g.addClose;\n  int left = 0;\n  int right = f.addOpen + f.addClose + n + 1;\n  while (left < right - 1) {\n    int mid = (left + right) >> 1;\n    if (getHash(f, mid) == getHash(g, mid)) {\n      left = mid;\n    } else {\n      right = mid;\n    }\n  }\n  return getChar(f, left) < getChar(g, left);\n}\nstd::mt19937 rnd(std::chrono::system_clock::now().time_since_epoch().count());\nint const HALFBILLION = 500000000;\nbool prime(int x) {\n  for (int i = 2; i * i <= x; i++) {\n    if (x % i == 0) return false;\n  }\n  return true;\n}\nvoid gen(long long& M) {\n  M = rnd() % HALFBILLION + HALFBILLION;\n  while (!prime(M)) {\n    ++M;\n  }\n}\nint main() {\n  gen(M1);\n  gen(M2);\n  POW1[0] = POW2[0] = 1;\n  OPEN[0] = {0, 0};\n  CLOSE[0] = {0, 0};\n  for (int i = 1; i < N; i++) {\n    POW1[i] = POW1[i - 1] * X % M1;\n    POW2[i] = POW2[i - 1] * X % M2;\n    if (i == 1) {\n      OPEN[i] = {(long long)'(', 1};\n      CLOSE[i] = {(long long)')', 1};\n    } else {\n      OPEN[i] = OPEN[i - 1] + OPEN[1];\n      CLOSE[i] = CLOSE[i - 1] + CLOSE[1];\n    }\n  }\n  int c = getchar();\n  while (c <= 32) c = getchar();\n  n = 1;\n  while (c > 32) {\n    s[n++] = c;\n    c = getchar();\n  }\n  --n;\n  for (int i = 1; i <= n; i++) s[i + n] = s[i];\n  bal[0] = 0;\n  for (int i = 1; i <= 2 * n; i++) {\n    bal[i] = bal[i - 1] + (s[i] == '(' ? 1 : -1);\n    settree(i, bal[i]);\n  }\n  hs[0] = {0, 0};\n  for (int i = 1; i <= 2 * n; i++) {\n    hash cur = {(long long)s[i], 1};\n    hs[i] = hs[i - 1] + cur;\n  }\n  answer ans = {INF / 2, -1, INF / 2};\n  for (int start = 1; start <= n; start++) {\n    int minB = getmin(start - 1, start + n);\n    int addOpen = bal[start - 1] - minB;\n    int addClose = bal[start + n - 1] - minB;\n    answer cur = {addOpen, start, addClose};\n    if (cur < ans) ans = cur;\n  }\n  for (int i = 0; i < ans.addOpen; i++) putchar('(');\n  for (int i = 0; i < n; i++) putchar(s[ans.pos + i]);\n  for (int i = 0; i < ans.addClose; i++) putchar(')');\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1000000 + 5;\nchar str[N << 1];\nint a[N << 1];\nbool flag[N << 1];\nint len;\nint offset, pos;\npair<int, int> que[N << 1];\nint p1, p2;\nint sa[N << 1], rk[N << 1];\nvoid da(char *s, int n, int m) {\n  static int t1[N << 1], t2[N << 1], c[N << 1];\n  int *x = t1, *y = t2, i, j, k, p = 1;\n  memset(c, 0, sizeof(c[0]) * m);\n  for (i = 0; i < n; i++) c[x[i] = s[i]]++;\n  for (i = 1; i < m; i++) c[i] += c[i - 1];\n  for (i = n - 1; i >= 0; i--) sa[--c[x[i]]] = i;\n  for (k = 1; p < n; k <<= 1, m = p) {\n    for (p = 0, i = n - k; i < n; i++) y[p++] = i;\n    for (i = 0; i < n; i++)\n      if (sa[i] >= k) y[p++] = sa[i] - k;\n    memset(c, 0, sizeof(c[0]) * m);\n    for (i = 0; i < n; i++) c[x[i]]++;\n    for (i = 1; i < m; i++) c[i] += c[i - 1];\n    for (i = n - 1; i >= 0; i--) sa[--c[x[y[i]]]] = y[i];\n    for (swap(x, y), x[sa[0]] = 0, p = i = 1; i < n; i++)\n      x[sa[i]] = y[sa[i]] == y[sa[i - 1]] && y[sa[i] + k] == y[sa[i - 1] + k]\n                     ? p - 1\n                     : p++;\n  }\n}\nint main() {\n  scanf(\"%s\", str + 1);\n  len = strlen(str + 1);\n  offset = 0;\n  for (int i = 1; i <= len; ++i) offset += (str[i] == '(' ? 1 : -1);\n  memcpy(str + len + 1, str + 1, len + 1);\n  a[0] = 0;\n  for (int i = 1; i <= len << 1; ++i)\n    a[i] = a[i - 1] + (str[i] == '(' ? 1 : -1);\n  p1 = p2 = 0;\n  for (int i = 1; i <= len << 1; ++i) {\n    while (p1 != p2 && que[p2 - 1].first > a[i]) --p2;\n    que[p2++] = pair<int, int>(a[i], i);\n    while (p1 != p2 && i - que[p1].second >= len) ++p1;\n    if (i - len >= 0) {\n      if (que[p1].first - a[i - len] >= offset ||\n          que[p1].first - a[i - len] >= 0)\n        flag[i - len + 1] = true;\n    }\n  }\n  da(str + 1, len << 1 | 1, 128);\n  for (int i = 1; i <= len << 1; ++i) {\n    if (sa[i] < len && flag[sa[i] + 1]) {\n      pos = sa[i] + 1;\n      break;\n    }\n  }\n  while (offset < 0) printf(\"(\"), ++offset;\n  for (int i = pos; i < pos + len; ++i) printf(\"%c\", str[i]);\n  while (offset > 0) printf(\")\"), --offset;\n  puts(\"\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nint n;\nchar s[2000005], t[2000005];\nint sa[2000005], rnk[2000005], lcp[2000005], cnt[2000005];\nvoid build(char *s) {\n  int n = strlen(s) + 1, m = 256;\n  int *x = rnk, *y = lcp, *z;\n  for (int i = 0; i < m; i++) cnt[i] = 0;\n  for (int i = 0; i < n; i++) cnt[x[i] = s[i]]++;\n  for (int i = 1; i < m; i++) cnt[i] += cnt[i - 1];\n  for (int i = n - 1; i >= 0; i--) sa[--cnt[x[i]]] = i;\n  for (int j = 1, p = 1; p < n; j <<= 1, m = p) {\n    p = 0;\n    for (int i = n - j; i < n; i++) y[p++] = i;\n    for (int i = 0; i < n; i++)\n      if (sa[i] >= j) y[p++] = sa[i] - j;\n    for (int i = 0; i < m; i++) cnt[i] = 0;\n    for (int i = 0; i < n; i++) cnt[x[i]]++;\n    for (int i = 1; i < m; i++) cnt[i] += cnt[i - 1];\n    for (int i = n - 1; i >= 0; i--) sa[--cnt[x[y[i]]]] = y[i];\n    z = x, x = y, y = z;\n    x[sa[0]] = 0, p = 1;\n    for (int i = 1; i < n; i++) {\n      x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + j] == y[sa[i - 1] + j])\n                     ? p - 1\n                     : p++;\n    }\n  }\n  for (int i = 0; i < n; i++) rnk[sa[i]] = i;\n  for (int i = 0, k = 0; i < n - 1; lcp[rnk[i++]] = k) {\n    if (k) k--;\n    for (int j = sa[rnk[i] - 1]; s[i + k] == s[j + k]; k++)\n      ;\n  }\n}\nint sum[2000005], emn[2000005], smn[2000005];\nint ans, rot, ff, ss, g1, g2;\nvoid update(int len, int r, int f, int s) {\n  if (ans > len) {\n    ans = len;\n    rot = r;\n    ff = f, ss = s;\n  }\n  return;\n}\nconst int inf = 1e9;\nint main() {\n  scanf(\"%s\", s + 1);\n  n = strlen(s + 1);\n  strcpy(t, s + 1);\n  strcpy(t + n, s + 1);\n  build(t);\n  for (int i = 1; i <= n; i++) {\n    int d = s[i] == '(' ? 1 : -1;\n    if (s[i] == '(')\n      g1++;\n    else\n      g2++;\n    sum[i] = sum[i - 1] + d;\n  }\n  for (int i = 1; i <= n; i++) {\n    smn[i] = sum[i];\n    if (i > 1) smn[i] = min(smn[i], smn[i - 1]);\n  }\n  for (int i = n; i >= 1; i--) {\n    emn[i] = sum[i];\n    if (i < n) emn[i] = min(emn[i], emn[i + 1]);\n  }\n  ans = inf;\n  for (int ii = 0; ii <= 2 * n; ii++) {\n    int i = sa[ii];\n    if (i > n) continue;\n    i++;\n    int d = sum[n] - sum[i - 1];\n    int mn = min(d + smn[i - 1], emn[i] - sum[i - 1]);\n    int inc = 0;\n    if (mn < 0) inc = -mn;\n    assert(inc + g1 >= g2);\n    update((inc + g1) * 2, i, inc, inc + g1 - g2);\n  }\n  for (int i = 0; i < ff; i++) putchar('(');\n  for (int i = rot; i <= n; i++) putchar(s[i]);\n  for (int i = 1; i < rot; i++) putchar(s[i]);\n  for (int i = 0; i < ss; i++) putchar(')');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, s[2000100];\nbool vis[2000100];\nchar t[2000100];\nint sa[2000100], rnk[2000100], tmp[2000100], cnt[2000100];\nvoid build(char *s) {\n  int n = strlen(s) + 1, m = 256;\n  int *x = rnk, *y = tmp, *z;\n  for (int i = 0; i < m; i++) cnt[i] = 0;\n  for (int i = 0; i < n; i++) cnt[x[i] = s[i]]++;\n  for (int i = 1; i < m; i++) cnt[i] += cnt[i - 1];\n  for (int i = n - 1; i >= 0; i--) sa[--cnt[x[i]]] = i;\n  for (int j = 1, p = 1; p < n; j <<= 1, m = p) {\n    p = 0;\n    for (int i = n - j; i < n; i++) y[p++] = i;\n    for (int i = 0; i < n; i++)\n      if (sa[i] >= j) y[p++] = sa[i] - j;\n    for (int i = 0; i < m; i++) cnt[i] = 0;\n    for (int i = 0; i < n; i++) cnt[x[i]]++;\n    for (int i = 1; i < m; i++) cnt[i] += cnt[i - 1];\n    for (int i = n - 1; i >= 0; i--) sa[--cnt[x[y[i]]]] = y[i];\n    z = x, x = y, y = z;\n    x[sa[0]] = 0, p = 1;\n    for (int i = 1; i < n; i++)\n      x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + j] == y[sa[i - 1] + j])\n                     ? p - 1\n                     : p++;\n  }\n  for (int i = 0; i < n; i++) rnk[sa[i]] = i;\n}\nint main() {\n  scanf(\"%s\", t + 1);\n  n = strlen(t + 1);\n  int mn = 0;\n  for (int i = 1; i <= n; i++) {\n    s[i] = s[i - 1];\n    if (t[i] == '(')\n      s[i]++;\n    else\n      s[i]--;\n    mn = min(mn, s[i]);\n  }\n  for (int i = 1; i <= n; i++) t[n + i] = t[i], s[i + n] = s[i] + s[n];\n  int dn = 0;\n  if (s[n] < 0) dn = -s[n];\n  build(t + 1);\n  multiset<int> S;\n  for (int i = n + 1; i <= 2 * n; i++) S.insert(s[i]);\n  int k, p = 1e9;\n  for (int i = n; i >= 0; i--) {\n    int t = *S.begin();\n    S.erase(S.find(s[i + n]));\n    if (t - s[i] + dn >= 0) {\n      if (rnk[i] < p) p = rnk[i], k = i + 1;\n    }\n    S.insert(s[i]);\n  }\n  int sum = s[n];\n  if (sum < 0)\n    for (int i = sum; i < 0; i++) putchar('(');\n  for (int i = 0; i < n; i++) putchar(t[k + i]);\n  if (sum > 0)\n    for (int i = 0; i < sum; i++) putchar(')');\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.util.List;\nimport java.math.BigInteger;\nimport java.io.PrintStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Comparator;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author shu_mj @ http://shu-mj.com\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tScanner in = new Scanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskA {\n    Scanner in;\n    PrintWriter out;\n\n    public void solve(int testNumber, Scanner in, PrintWriter out) {\n        this.in = in;\n        this.out = out;\n        run();\n    }\n\n    void run() {\n        char[] cs = in.next().toCharArray();\n        int n = cs.length;\n        int n2 = n * 2;\n        cs = Algo.merge(cs, cs);\n//        SuffixArray sa = new SuffixArray(cs);\n        int[] is = new int[n2];\n        for (int i = 0; i < n2; i++) is[i] = cs[i];\n        int[] sa = buildSuffixArray(is);\n        Seg seg = new Seg(cs);\n        int[] lr = new int[2];\n        for (int i = 0; ; i++) {\n            int id = sa[i];\n            if (id < n) {\n                seg.query(id, id + n, lr);\n                if (lr[1] == 0) {\n                    for (int j = 0; j < lr[0]; j++) out.print('(');\n                    for (int j = 0; j < n; j++) out.print(cs[j + id]);\n                    out.println();\n                    return ;\n                } else if (lr[0] == 0) {\n                    for (int j = 0; j < n; j++) out.print(cs[j + id]);\n                    for (int j = 0; j < lr[1]; j++) out.print(')');\n                    out.println();\n                    return ;\n                }\n            }\n        }\n    }\n    private int[] buildSuffixArray(int[] _s) {\n        int[] s = compress(_s);\n        int n = s.length;\n        int[] am = new int[n];\n        for (int x : s) {\n            ++am[x];\n        }\n        int[] start = new int[n];\n        int numCols = 0;\n        int total = 0;\n        for (int i = 0; i < n; i++) {\n            if (am[i] > 0) {\n                start[numCols] = total;\n                total += am[i];\n                ++numCols;\n            }\n        }\n        int[] sa = new int[n];\n        int[] col = new int[n];\n        int[] tmp = start.clone();\n        for (int i = 0; i < n; i++) {\n            col[i] = s[i];\n            sa[tmp[col[i]]++] = i;\n        }\n        int len = 1;\n        while (len < n) {\n            int[] nsa = new int[n];\n            int[] ncol = new int[n];\n            for (int i = 0; i < n; i++) {\n                int j = sa[i] - len;\n                if (j < 0) {\n                    j += n;\n                }\n                nsa[start[col[j]]++] = j;\n            }\n            numCols = 1;\n            start[0] = 0;\n            for (int i = 0; i < n; i++) {\n                if (i > 0) {\n                    int u = nsa[i];\n                    int v = nsa[i - 1];\n                    if (col[u] != col[v] || col[(u + len) % n] != col[(v + len) % n]) {\n                        start[numCols] = i;\n                        ++numCols;\n                    }\n                }\n                ncol[nsa[i]] = numCols - 1;\n            }\n            sa = nsa;\n            col = ncol;\n            len *= 2;\n        }\n        return sa;\n    }\n\n    private int[] compress(int[] s) {\n        int[] sorted = s.clone();\n        Arrays.sort(sorted);\n        int k = 0;\n        for (int i = 0; i < sorted.length; i++) {\n            if (i == 0 || sorted[i] != sorted[i - 1]) {\n                sorted[k++] = sorted[i];\n            }\n        }\n        int[] res = new int[s.length];\n        for (int i = 0; i < s.length; i++) {\n            res[i] = Arrays.binarySearch(sorted, 0, k, s[i]);\n        }\n        return res;\n    }\n\n    class Seg {\n        int N;\n        int[] left, right;\n\n        Seg(char[] cs) {\n            int n = cs.length;\n            N = Integer.highestOneBit(n) << 1;\n            left = new int[N * 2];\n            right = new int[N * 2];\n            for (int i = 0; i < N; i++) {\n                if (i < n && cs[i] == '(') {\n                    left[i + N] = 0;\n                    right[i + N] = 1;\n                } else {\n                    left[i + N] = 1;\n                    right[i + N] = 0;\n                }\n            }\n            for (int i = N - 1; i > 0; i--) {\n                left[i] = left[i * 2] + Math.max(0, left[i * 2 + 1] - right[i * 2]);\n                right[i] = right[i * 2 + 1] + Math.max(0, right[i * 2] - left[i * 2 + 1]);\n            }\n        }\n        void query(int s, int t, int[] lr) {\n            int l = 0, r = 0;\n            while (0 < s && s + (s & -s) <= t) {\n                int i = (N + s) / (s & -s);\n                int nl = l + Math.max(0, left[i] - r);\n                int nr = right[i] + Math.max(0, r - left[i]);\n                l = nl; r = nr;\n                s += s & -s;\n            }\n            int l2 = 0, r2 = 0;\n            while (s < t) {\n                int i = (N + t) / (t & -t) - 1;\n                int nl = left[i] + Math.max(0, l2 - right[i]);\n                int nr = r2 + Math.max(0, right[i] - l2);\n                l2 = nl; r2 = nr;\n                t -= t & -t;\n            }\n            lr[0] = l + Math.max(0, l2 - r);\n            lr[1] = r2 + Math.max(0, r - l2);\n        }\n    }\n/*\n\n    void run2() {\n        char[] cs = in.next().toCharArray();\n        int n = cs.length;\n        if (cs[n - 1] == '(' && cs[0] == '(' && !Algo.allTheSame(cs)) {\n            int b = 0;\n            while (cs[b] == '(') b++;\n            cs = Algo.merge(Arrays.copyOfRange(cs, b, n), Arrays.copyOfRange(cs, 0, b));\n        }\n        if (cs[n - 1] == ')' && cs[0] == ')' && !Algo.allTheSame(cs)) {\n            int b = 0;\n            while (cs[b] == ')') b++;\n            cs = Algo.merge(Arrays.copyOfRange(cs, b, n), Arrays.copyOfRange(cs, 0, b));\n        }\n        int[] is = new int[n];\n        List<PII> ps = new ArrayList<PII>();\n        for (int i = 0; i < n; i++) {\n            if (cs[i] == '(') {\n                if (i == 0 || cs[i] != cs[i - 1]) {\n                    is[i] = -1;\n                } else {\n                    is[i] = is[i - 1] - 1;\n                }\n                if (i == n - 1 || cs[i] != cs[i + 1]) {\n                    ps.add(new PII(is[i], i));\n                }\n            } else {\n                if (i == 0 || cs[i] != cs[i - 1]) {\n                    is[i] = 1;\n                } else {\n                    is[i] = is[i - 1] + 1;\n                }\n                if (i == n - 1 || cs[i] != cs[i + 1]) {\n                    ps.add(new PII(is[i], i));\n                }\n            }\n        }\n//        Algo.debug(ps);\n        int m = ps.size();\n        int[] hs = new int[m];\n        for (int i = 0; i < m; i++) {\n            hs[i] = ps.get(i).x;\n        }\n        int[] ss = hs.clone();\n        Algo.sort(ss);\n        ss = Algo.unique(ss);\n        for (int i = 0; i < m; i++) {\n            hs[i] = Algo.lowerBound(ss, hs[i]) + 2;\n        }\n        hs = Algo.merge(hs, hs);\n        SuffixArray sa = new SuffixArray(hs, ss.length + 5);\n        int id = -1;\n        for (int i = 0; ; i++) {\n            if (sa.si[i] < hs.length / 2) {\n                id = sa.si[i];\n                break;\n            }\n        }\n        int mid = ps.get(id).y - Math.abs(ps.get(id).x) + 1;\n        int l = Algo.count(cs, '(');\n        int r = n - l;\n        if (l < r) {\n            for (int i = l; i < r; i++) {\n                out.print('(');\n            }\n            l = r;\n        }\n        for (int i = mid; i < n; i++) {\n            out.print(cs[i]);\n        }\n        for (int i = 0; i < mid; i++) {\n            out.print(cs[i]);\n        }\n        if (r < l) {\n            for (int i = r; i < l; i++) {\n                out.print(')');\n            }\n        }\n        out.println();\n    }\n    class SuffixArray {\n        public int n;\n        public int[] cs;\n        public int[] si, is;// si:= suffix array(si[0] = end); is[si[i]] = i;\n\n        public int[] indexSort(int[] is, int max) {\n            int[] c = new int[max + 1];\n            for (int i : is) c[i]++;\n            for (int i = 1; i < max; i++) c[i] += c[i - 1];\n            int n = is.length;\n            int[] si = new int[n];\n            for (int i = n - 1; i >= 0; i--) si[--c[is[i]]] = i;\n            return si;\n        }\n\n        public SuffixArray(int[] t, int max) {\n            n = t.length;\n            cs = new int[n + 1];\n            System.arraycopy(t, 0, cs, 0, n);\n            cs[n] = 0;// guard, minimum value and not allowed to use\n            is = new int[n + 1];\n            for (int i = 0; i <= n; i++) is[i] = cs[i];\n            si = indexSort(is, max);\n            int[] a = new int[n + 1], b = new int[n + 1];\n            for (int h = 0; ; ) {\n                for (int i = 0; i < n; i++) {\n                    int x = si[i + 1], y = si[i];\n                    b[i + 1] = b[i];\n                    if (is[x] > is[y] || is[x + h] > is[y + h]) b[i + 1]++;\n                }\n                for (int i = 0; i <= n; i++) is[si[i]] = b[i];\n                if (b[n] == n) break;\n                h = Math.max(1, h << 1);\n                for (int k = h; k >= 0; k -= h) {\n                    Arrays.fill(b, 0);\n                    b[0] = k;\n                    for (int i = k; i <= n; i++) b[is[i]]++;\n                    for (int i = 0; i < n; i++) b[i + 1] += b[i];\n                    for (int i = n; i >= 0; i--) {\n                        a[--b[si[i] + k > n ? 0 : is[si[i] + k]]] = si[i];\n                    }\n                    int[] tmp = si; si = a; a = tmp;\n                }\n            }\n        }\n\n        public int[] hs;// hs[i]:= suffix i & i+1 's LCP\n\n        public void buildHs() {\n            hs = new int[n + 1];\n            for (int i = 0, h = 0; i < n; i++) {\n                for (int j = si[is[i] - 1]; cs[i + h] == cs[j + h]; h++) ;\n                hs[is[i] - 1] = h;\n                if (h > 0) h--;\n            }\n        }\n\n        public RMQ rmq;\n\n        public void buildRMQ() {\n            rmq = new RMQ(hs);\n        }\n\n        // begin from pos i,j, LCP means that Longest Common Prefix\n        public int getLCP(int i, int j) {\n            if (i == j) return n - i;\n            return rmq.vs[rmq.query(Math.min(is[i], is[j]), Math.max(is[i], is[j]))];\n        }\n    }\n*/\n\n}\n\nclass Scanner {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public Scanner(InputStream in) {\n        br = new BufferedReader(new InputStreamReader(in));\n        eat(\"\");\n    }\n\n    private void eat(String s) {\n        st = new StringTokenizer(s);\n    }\n\n    public String nextLine() {\n        try {\n            return br.readLine();\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    public boolean hasNext() {\n        while (!st.hasMoreTokens()) {\n            String s = nextLine();\n            if (s == null)\n                return false;\n            eat(s);\n        }\n        return true;\n    }\n\n    public String next() {\n        hasNext();\n        return st.nextToken();\n    }\n\n}\n\nclass Algo {\n\n\n    public static char[] merge(char[] is, char[] js) {\n        int in = is.length;\n        int jn = js.length;\n        char[] rs = new char[in + jn];\n        System.arraycopy(is, 0, rs, 0, in);\n        System.arraycopy(js, 0, rs, in, jn);\n        return rs;\n    }\n\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, s[2000100];\nbool vis[2000100];\nchar t[2000100];\nint sa[2000100], rnk[2000100], tmp[2000100], cnt[2000100];\nvoid build(char *s) {\n  int n = strlen(s) + 1, m = 256;\n  int *x = rnk, *y = tmp, *z;\n  for (int i = 0; i < m; i++) cnt[i] = 0;\n  for (int i = 0; i < n; i++) cnt[x[i] = s[i]]++;\n  for (int i = 1; i < m; i++) cnt[i] += cnt[i - 1];\n  for (int i = n - 1; i >= 0; i--) sa[--cnt[x[i]]] = i;\n  for (int j = 1, p = 1; p < n; j <<= 1, m = p) {\n    p = 0;\n    for (int i = n - j; i < n; i++) y[p++] = i;\n    for (int i = 0; i < n; i++)\n      if (sa[i] >= j) y[p++] = sa[i] - j;\n    for (int i = 0; i < m; i++) cnt[i] = 0;\n    for (int i = 0; i < n; i++) cnt[x[i]]++;\n    for (int i = 1; i < m; i++) cnt[i] += cnt[i - 1];\n    for (int i = n - 1; i >= 0; i--) sa[--cnt[x[y[i]]]] = y[i];\n    z = x, x = y, y = z;\n    x[sa[0]] = 0, p = 1;\n    for (int i = 1; i < n; i++)\n      x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + j] == y[sa[i - 1] + j])\n                     ? p - 1\n                     : p++;\n  }\n  for (int i = 0; i < n; i++) rnk[sa[i]] = i;\n}\nint main() {\n  scanf(\"%s\", t + 1);\n  n = strlen(t + 1);\n  int mn = 0;\n  for (int i = 1; i <= n; i++) {\n    s[i] = s[i - 1];\n    if (t[i] == '(')\n      s[i]++;\n    else\n      s[i]--;\n    mn = min(mn, s[i]);\n  }\n  for (int i = 1; i <= n; i++) t[n + i] = t[i], s[i + n] = s[i] + s[n];\n  int dn = 0;\n  if (s[n] < 0) dn = -s[n];\n  build(t + 1);\n  multiset<int> S;\n  for (int i = n + 1; i <= 2 * n; i++) S.insert(s[i]);\n  int k, p = 1e9;\n  for (int i = n; i >= 0; i--) {\n    int t = *S.begin();\n    S.erase(S.find(s[i + n]));\n    if (t - s[i] + dn >= 0) {\n      if (rnk[i] < p) p = rnk[i], k = i + 1;\n    }\n    S.insert(s[i]);\n  }\n  int sum = s[n];\n  if (sum < 0)\n    for (int i = sum; i < 0; i++) putchar('(');\n  for (int i = 0; i < n; i++) putchar(t[k + i]);\n  if (sum > 0)\n    for (int i = 0; i < sum; i++) putchar(')');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint Rank[4000011], sa[4000011];\nnamespace SA {\nint Cnt[4000011], *cnt = Cnt + 11, first[4000011], second[4000011],\n                  buf[4000011], v[4000011];\nvoid build(char *s, int n) {\n  for (int i = 0; i < n; i++) v[i] = s[i];\n  sort(v, v + n);\n  int *x = unique(v, v + n);\n  memset(Rank, -1, sizeof Rank);\n  for (int i = 0; i < n; i++) Rank[i] = lower_bound(v, x, s[i]) - v;\n  for (int t = 1; t <= n; t <<= 1) {\n    for (int i = 0; i < n; i++) first[i] = Rank[i], second[i] = Rank[i + t];\n    fill(cnt, cnt + n, 0);\n    for (int i = 0; i < n; i++) cnt[second[i]]++;\n    for (int i = 0; i < n; i++) cnt[i] += cnt[i - 1];\n    for (int i = 0; i < n; i++) buf[n - 1 - --cnt[second[i]]] = i;\n    fill(cnt, cnt + n, 0);\n    for (int i = 0; i < n; i++) cnt[first[i]]++;\n    for (int i = 0; i < n; i++) cnt[i] += cnt[i - 1];\n    for (int j = 0; j < n; j++) sa[--cnt[first[buf[j]]]] = buf[j];\n    bool end = 1;\n    for (int j = 0, last = -1; j < n; j++) {\n      int i = sa[j];\n      if (last == -1)\n        Rank[i] = 0;\n      else if (first[i] == first[last] && second[i] == second[last])\n        Rank[i] = Rank[last], end = 0;\n      else\n        Rank[i] = Rank[last] + 1;\n      last = i;\n    }\n    if (end) break;\n  }\n}\n}  // namespace SA\nstruct tree {\n  int fv[4100001], addv[4100001];\n  void build(int *a, int o, int l, int r) {\n    if (l == r) {\n      fv[o] = a[l];\n      return;\n    }\n    int m = (l + r) / 2;\n    build(a, o * 2, l, m);\n    build(a, o * 2 + 1, m + 1, r);\n    fv[o] = min(fv[o * 2], fv[o * 2 + 1]);\n  }\n  void pushdown(int o, int l, int r) {\n    if (l == r || !addv[o]) return;\n    addv[o * 2] += addv[o];\n    addv[o * 2 + 1] += addv[o];\n    fv[o * 2] += addv[o];\n    fv[o * 2 + 1] += addv[o];\n    addv[o] = 0;\n  }\n  void set(int x, int d, int o, int l, int r) {\n    if (l == r) {\n      fv[o] = d;\n      return;\n    }\n    pushdown(o, l, r);\n    int m = (l + r) / 2;\n    if (x <= m)\n      set(x, d, o * 2, l, m);\n    else\n      set(x, d, o * 2 + 1, m + 1, r);\n    fv[o] = min(fv[o * 2], fv[o * 2 + 1]);\n  }\n  void add(int x, int y, int d, int o, int l, int r) {\n    if (x <= l && r <= y) {\n      fv[o] += d;\n      addv[o] += d;\n      return;\n    }\n    pushdown(o, l, r);\n    int m = (l + r) / 2;\n    if (x <= m) add(x, y, d, o * 2, l, m);\n    if (y > m) add(x, y, d, o * 2 + 1, m + 1, r);\n    fv[o] = min(fv[o * 2], fv[o * 2 + 1]);\n  }\n  int query(int x, int y, int o, int l, int r) {\n    if (x <= l && r <= y) return fv[o];\n    int m = (l + r) / 2, ans = 1 << 30;\n    if (x <= m) ans = min(ans, query(x, y, o * 2, l, m));\n    if (y > m) ans = min(ans, query(x, y, o * 2 + 1, m + 1, r));\n    return ans;\n  }\n} T;\nchar s[1100001], t[2200001];\nint a[1100001], n;\nint main() {\n  scanf(\"%s\", s + 1);\n  n = strlen(s + 1);\n  for (int i = 1; i <= n; i++) t[i - 1] = t[n + i - 1] = s[i];\n  bool flag = 1;\n  for (int i = 1; i <= n; i++)\n    if (s[i] != '(') {\n      flag = 0;\n      break;\n    }\n  if (flag) {\n    for (int i = 1; i <= n; i++) putchar('(');\n    for (int i = 1; i <= n; i++) putchar(')');\n    puts(\"\");\n    exit(0);\n  }\n  for (int i = 1; i <= n; i++)\n    if (s[i] == '(')\n      a[i] = a[i - 1] + 1;\n    else\n      a[i] = a[i - 1] - 1;\n  T.build(a, 1, 1, n);\n  SA::build(t, 2 * n);\n  int best = -1, val = -n - 1;\n  for (int i = 1; i <= n; i++) {\n    int cval = min(T.fv[1], 0);\n    if (cval > val)\n      val = cval, best = i;\n    else if (cval == val && Rank[best - 1] > Rank[i - 1])\n      best = i;\n    T.add(1, n, s[i] == '(' ? -1 : 1, 1, 1, n);\n    T.set(i, a[n], 1, 1, n);\n  }\n  for (int i = 0; i < -val; i++) putchar('(');\n  for (int i = best; i <= n; i++) putchar(s[i]);\n  for (int i = 1; i < best; i++) putchar(s[i]);\n  for (int i = 0; i < -val + a[n]; i++) putchar(')');\n  puts(\"\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint z, n;\nchar s[2000007], t[2000007];\nint tab[2000007];\nvector<int> suf;\nvoid suf_array(const char* init, vector<int>& suf) {\n  string s = init;\n  vector<int> head, color, sub, tmp;\n  head.assign(max((int)s.size(), 256), 0);\n  suf.resize(s.size());\n  color.resize(s.size());\n  sub.resize(s.size());\n  tmp.resize(s.size());\n  for (int i = 0; i < s.size(); i++) ++head[s[i]];\n  for (int i = 1; i < 256; i++) head[i] += head[i - 1];\n  for (int i = 255; i >= 0; i--) head[i] = head[i - 1];\n  head[0] = 0;\n  for (int i = 0; i < s.size(); i++) {\n    suf[head[s[i]]] = i;\n    ++head[s[i]];\n  }\n  int classes = 1;\n  head[0] = 0;\n  for (int i = 1; i < s.size(); i++) {\n    if (s[suf[i - 1]] != s[suf[i]]) {\n      ++classes;\n      head[classes - 1] = i;\n    }\n    color[suf[i]] = classes - 1;\n  }\n  for (int k = 1; k < s.size(); k *= 2) {\n    for (int i = 0; i < s.size(); i++) {\n      int first = suf[i] - k;\n      if (first < 0) first += s.size();\n      tmp[head[color[first]]] = first;\n      ++head[color[first]];\n    }\n    suf = tmp;\n    int second;\n    pair<int, int> prv, cur;\n    cur = make_pair(-1, 0);\n    classes = 0;\n    for (int i = 0; i < s.size(); i++) {\n      prv = cur;\n      second = suf[i] + k;\n      if (second >= s.size()) second -= s.size();\n      cur = make_pair(color[suf[i]], color[second]);\n      if (cur != prv) {\n        ++classes;\n        head[classes - 1] = i;\n      }\n      sub[suf[i]] = classes - 1;\n    }\n    color = sub;\n    if (classes == s.size()) break;\n  }\n}\nint start, ending;\nint tree[2000007 * 4];\nint ans[2000007 * 4];\nvoid build(int v, int l, int r) {\n  if (l == r) {\n    tree[v] = tab[l - 1];\n    return;\n  }\n  int m = (l + r) / 2;\n  build(2 * v, l, m);\n  build(2 * v + 1, m + 1, r);\n  tree[v] = min(tree[2 * v], tree[2 * v + 1]);\n}\nint query(int v, int l, int r, int p, int q) {\n  if (p <= l && q >= r) return tree[v];\n  int ret = 1000000001;\n  int m = (l + r) / 2;\n  if (p <= m) ret = min(ret, query(2 * v, l, m, p, q));\n  if (m + 1 <= q) ret = min(ret, query(2 * v + 1, m + 1, r, p, q));\n  return ret;\n}\nbool ok(int i) {\n  return query(1, 1, n, 1 + suf[i], 1 + suf[i] + n / 2 - 1) +\n             max(0, ending - start) - tab[suf[i]] >=\n         0;\n}\nint main() {\n  scanf(\"%s\", s);\n  n = strlen(s);\n  strcpy(t, s);\n  strcpy(t + n, s);\n  n *= 2;\n  t[n] = 0;\n  for (int i = 1; i < n; i++) tab[i] = tab[i - 1] + (t[i - 1] == '(' ? 1 : -1);\n  build(1, 1, n);\n  suf_array(s, suf);\n  for (int i = 0; i < n / 2; i++) {\n    start += (s[i] == '(');\n    ending += (s[i] != '(');\n  }\n  int shiftid = 0;\n  for (int i = 0; i < n / 2; i++)\n    if (suf[i] < n / 2 && ok(i)) {\n      shiftid = suf[i];\n      break;\n    }\n  t[0] = 0;\n  for (int i = 0; i < ending - start; i++) t[i] = '(';\n  t[ending - start] = 0;\n  printf(\"%s\", t);\n  printf(\"%s\", s + shiftid);\n  s[shiftid] = 0;\n  printf(\"%s\", s);\n  t[0] = 0;\n  for (int i = 0; i < start - ending; i++) t[i] = ')';\n  t[start - ending] = 0;\n  printf(\"%s\\n\", t);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long hsh = 13131;\nconst long long hsh2 = 19260817;\nconst long long mod = 1e9 + 7;\nconst long long mod2 = 998244353;\nint n, m;\nstring s, t;\nchar c[1001000];\nlong long pw[2001000], h[2000100], pw2[2001000], h2[2001000];\nint sum[1001000], pre[1001000], sur[1001000], le, ri;\ninline pair<long long, long long> v(int l, int r) {\n  return make_pair(\n      (h[r] - (l ? h[l - 1] : 0) * pw[r - l + 1] % mod + mod) % mod,\n      (h2[r] - (l ? h2[l - 1] : 0) * pw2[r - l + 1] % mod2 + mod2) % mod2);\n}\ninline bool ck(int i, int j) {\n  int l = 0, r = m;\n  while (r - l > 1) {\n    int mid = (l + r) >> 1;\n    if (i + mid - 1 >= m || j + mid - 1 >= m ||\n        v(i, i + mid - 1) != v(j, j + mid - 1))\n      r = mid;\n    else\n      l = mid;\n  }\n  if (i + r - 1 >= m || j + r - 1 >= m) return 1;\n  return t[i + r - 1] < t[j + r - 1];\n}\nint main() {\n  int i, j, k;\n  scanf(\"%s\", c);\n  s = c;\n  t = s + s;\n  n = s.length();\n  m = t.length();\n  pw[0] = 1;\n  for (i = 1; i <= m; i++) pw[i] = pw[i - 1] * hsh % mod;\n  h[0] = t[0];\n  for (i = 1; i < m; i++) h[i] = (h[i - 1] * hsh + t[i]) % mod;\n  pw2[0] = 1;\n  for (i = 1; i <= m; i++) pw2[i] = pw2[i - 1] * hsh2 % mod2;\n  h2[0] = t[0];\n  for (i = 1; i < m; i++) h2[i] = (h2[i - 1] * hsh2 + t[i]) % mod2;\n  for (i = 0; i < n; i++)\n    sum[i] = (i ? sum[i - 1] : 0) + (s[i] == '(' ? 1 : -1);\n  pre[0] = sum[0], sur[n - 1] = sum[n - 1];\n  for (i = 1; i < n; i++) pre[i] = min(sum[i], pre[i - 1]);\n  for (i = n - 2; i >= 0; i--) sur[i] = min(sum[i], sur[i + 1]);\n  int maxl = 1e9 + 7, pl = -1;\n  if (sum[n - 1] < 0)\n    le = -sum[n - 1];\n  else\n    ri = sum[n - 1];\n  for (i = 0; i < n; i++) {\n    k = (i ? sum[i - 1] : 0);\n    int w = min(sur[i] - k, sum[n - 1] - k + (i ? pre[i - 1] : 0));\n    int ll = max(-w, max(0, -sum[n - 1]));\n    if (ll + ri + n < maxl) {\n      maxl = ll + ri + n;\n      le = ll;\n      pl = i;\n    } else if (ll + ri + n == maxl && ck(i, pl)) {\n      pl = i;\n    }\n  }\n  for (i = 1; i <= le; i++) cout << \"(\";\n  for (i = pl; i < n; i++) cout << s[i];\n  for (i = 0; i < pl; i++) cout << s[i];\n  for (i = 1; i <= ri; i++) cout << \")\";\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.util.Arrays;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.util.List;\nimport java.math.BigInteger;\nimport java.io.PrintStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Comparator;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author shu_mj @ http://shu-mj.com\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tScanner in = new Scanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskA solver = new TaskA();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskA {\n    Scanner in;\n    PrintWriter out;\n\n    public void solve(int testNumber, Scanner in, PrintWriter out) {\n        this.in = in;\n        this.out = out;\n        run();\n    }\n\n    void run() {\n        char[] cs = in.next().toCharArray();\n        int n = cs.length;\n        int n2 = n * 2;\n        cs = Algo.merge(cs, cs);\n        SuffixArrayS sa = new SuffixArrayS(cs);\n        Seg seg = new Seg(cs);\n        int[] lr = new int[2];\n        for (int i = 0; ; i++) {\n            int id = sa.si[i];\n            if (id < n) {\n                seg.query(id, id + n, lr);\n                if (lr[1] == 0) {\n                    for (int j = 0; j < lr[0]; j++) out.print('(');\n                    for (int j = 0; j < n; j++) out.print(cs[j + id]);\n                    out.println();\n                    return ;\n                } else if (lr[0] == 0) {\n                    for (int j = 0; j < n; j++) out.print(cs[j + id]);\n                    for (int j = 0; j < lr[1]; j++) out.print(')');\n                    out.println();\n                    return ;\n                }\n            }\n        }\n    }\n\n    class Seg {\n        int N;\n        int[] left, right;\n\n        Seg(char[] cs) {\n            int n = cs.length;\n            N = Integer.highestOneBit(n) << 1;\n            left = new int[N * 2];\n            right = new int[N * 2];\n            for (int i = 0; i < N; i++) {\n                if (i < n && cs[i] == '(') {\n                    left[i + N] = 0;\n                    right[i + N] = 1;\n                } else {\n                    left[i + N] = 1;\n                    right[i + N] = 0;\n                }\n            }\n            for (int i = N - 1; i > 0; i--) {\n                left[i] = left[i * 2] + Math.max(0, left[i * 2 + 1] - right[i * 2]);\n                right[i] = right[i * 2 + 1] + Math.max(0, right[i * 2] - left[i * 2 + 1]);\n            }\n        }\n        void query(int s, int t, int[] lr) {\n            int l = 0, r = 0;\n            while (0 < s && s + (s & -s) <= t) {\n                int i = (N + s) / (s & -s);\n                int nl = l + Math.max(0, left[i] - r);\n                int nr = right[i] + Math.max(0, r - left[i]);\n                l = nl; r = nr;\n                s += s & -s;\n            }\n            int l2 = 0, r2 = 0;\n            while (s < t) {\n                int i = (N + t) / (t & -t) - 1;\n                int nl = left[i] + Math.max(0, l2 - right[i]);\n                int nr = r2 + Math.max(0, right[i] - l2);\n                l2 = nl; r2 = nr;\n                t -= t & -t;\n            }\n            lr[0] = l + Math.max(0, l2 - r);\n            lr[1] = r2 + Math.max(0, r - l2);\n        }\n    }\n\n}\n\nclass Scanner {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public Scanner(InputStream in) {\n        br = new BufferedReader(new InputStreamReader(in));\n        eat(\"\");\n    }\n\n    private void eat(String s) {\n        st = new StringTokenizer(s);\n    }\n\n    public String nextLine() {\n        try {\n            return br.readLine();\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    public boolean hasNext() {\n        while (!st.hasMoreTokens()) {\n            String s = nextLine();\n            if (s == null)\n                return false;\n            eat(s);\n        }\n        return true;\n    }\n\n    public String next() {\n        hasNext();\n        return st.nextToken();\n    }\n\n}\n\nclass Algo {\n\n\n    public static char[] merge(char[] is, char[] js) {\n        int in = is.length;\n        int jn = js.length;\n        char[] rs = new char[in + jn];\n        System.arraycopy(is, 0, rs, 0, in);\n        System.arraycopy(js, 0, rs, in, jn);\n        return rs;\n    }\n\n}\n\nclass SuffixArrayS {\n    private static interface BaseArray {\n        public int get(int i);\n\n        public void set(int i, int val);\n\n        public int update(int i, int val);\n    }\n\n    private static class CharArray implements BaseArray {\n        private char[] m_A = null;\n        private int m_pos = 0;\n\n        CharArray(char[] A, int pos) {\n            m_A = A;\n            m_pos = pos;\n        }\n\n        public int get(int i) {\n            return m_A[m_pos + i] & 0xffff;\n        }\n\n        public void set(int i, int val) {\n            m_A[m_pos + i] = (char) (val & 0xffff);\n        }\n\n        public int update(int i, int val) {\n            return m_A[m_pos + i] += val & 0xffff;\n        }\n    }\n\n    private static class IntArray implements BaseArray {\n        private int[] m_A = null;\n        private int m_pos = 0;\n\n        IntArray(int[] A, int pos) {\n            m_A = A;\n            m_pos = pos;\n        }\n\n        public int get(int i) {\n            return m_A[m_pos + i];\n        }\n\n        public void set(int i, int val) {\n            m_A[m_pos + i] = val;\n        }\n\n        public int update(int i, int val) {\n            return m_A[m_pos + i] += val;\n        }\n    }\n\n    /* find the start or end of each bucket */\n    private static void getCounts(BaseArray T, BaseArray C, int n, int k) {\n        int i;\n        for(i = 0;i < k;++i){\n            C.set(i, 0);\n        }\n        for(i = 0;i < n;++i){\n            C.update(T.get(i), 1);\n        }\n    }\n\n    private static void getBuckets(BaseArray C, BaseArray B, int k, boolean end) {\n        int i, sum = 0;\n        if(end != false){\n            for(i = 0;i < k;++i){\n                sum += C.get(i);\n                B.set(i, sum);\n            }\n        }else{\n            for(i = 0;i < k;++i){\n                sum += C.get(i);\n                B.set(i, sum - C.get(i));\n            }\n        }\n    }\n\n    /* sort all type LMS suffixes */\n    private static void LMSsort(BaseArray T, int[] SA, BaseArray C,\n                                BaseArray B, int n, int k) {\n        int b, i, j;\n        int c0, c1;\n\t\t/* compute SAl */\n        if(C == B){\n            getCounts(T, C, n, k);\n        }\n        getBuckets(C, B, k, false); /* find starts of buckets */\n        j = n - 1;\n        b = B.get(c1 = T.get(j));\n        --j;\n        SA[b++] = (T.get(j) < c1) ? ~j : j;\n        for(i = 0;i < n;++i){\n            if(0 < (j = SA[i])){\n                if((c0 = T.get(j)) != c1){\n                    B.set(c1, b);\n                    b = B.get(c1 = c0);\n                }\n                --j;\n                SA[b++] = (T.get(j) < c1) ? ~j : j;\n                SA[i] = 0;\n            }else if(j < 0){\n                SA[i] = ~j;\n            }\n        }\n\t\t/* compute SAs */\n        if(C == B){\n            getCounts(T, C, n, k);\n        }\n        getBuckets(C, B, k, true); /* find ends of buckets */\n        for(i = n - 1, b = B.get(c1 = 0);0 <= i;--i){\n            if(0 < (j = SA[i])){\n                if((c0 = T.get(j)) != c1){\n                    B.set(c1, b);\n                    b = B.get(c1 = c0);\n                }\n                --j;\n                SA[--b] = (T.get(j) > c1) ? ~(j + 1) : j;\n                SA[i] = 0;\n            }\n        }\n    }\n\n    private static int LMSpostproc(BaseArray T, int[] SA, int n, int m) {\n        int i, j, p, q, plen, qlen, name;\n        int c0, c1;\n        boolean diff;\n\n\t\t/*\n\t\t * compact all the sorted substrings into the first m items of SA 2*m\n\t\t * must be not larger than n (proveable)\n\t\t */\n        for(i = 0;(p = SA[i]) < 0;++i){\n            SA[i] = ~p;\n        }\n        if(i < m){\n            for(j = i, ++i;;++i){\n                if((p = SA[i]) < 0){\n                    SA[j++] = ~p;\n                    SA[i] = 0;\n                    if(j == m){\n                        break;\n                    }\n                }\n            }\n        }\n\n\t\t/* store the length of all substrings */\n        i = n - 1;\n        j = n - 1;\n        c0 = T.get(n - 1);\n        do{\n            c1 = c0;\n        }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));\n        for(;0 <= i;){\n            do{\n                c1 = c0;\n            }while ((0 <= --i) && ((c0 = T.get(i)) <= c1));\n            if(0 <= i){\n                SA[m + ((i + 1) >> 1)] = j - i;\n                j = i + 1;\n                do{\n                    c1 = c0;\n                }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));\n            }\n        }\n\n\t\t/* find the lexicographic names of all substrings */\n        for(i = 0, name = 0, q = n, qlen = 0;i < m;++i){\n            p = SA[i];\n            plen = SA[m + (p >> 1)];\n            diff = true;\n            if((plen == qlen) && ((q + plen) < n)){\n                for(j = 0;(j < plen) && (T.get(p + j) == T.get(q + j));++j){\n                }\n                if(j == plen){\n                    diff = false;\n                }\n            }\n            if(diff != false){\n                ++name;\n                q = p;\n                qlen = plen;\n            }\n            SA[m + (p >> 1)] = name;\n        }\n\n        return name;\n    }\n\n    /* compute SA and BWT */\n    private static void induceSA(BaseArray T, int[] SA, BaseArray C,\n                                 BaseArray B, int n, int k) {\n        int b, i, j;\n        int c0, c1;\n\t\t/* compute SAl */\n        if(C == B){\n            getCounts(T, C, n, k);\n        }\n        getBuckets(C, B, k, false); /* find starts of buckets */\n        j = n - 1;\n        b = B.get(c1 = T.get(j));\n        SA[b++] = ((0 < j) && (T.get(j - 1) < c1)) ? ~j : j;\n        for(i = 0;i < n;++i){\n            j = SA[i];\n            SA[i] = ~j;\n            if(0 < j){\n                if((c0 = T.get(--j)) != c1){\n                    B.set(c1, b);\n                    b = B.get(c1 = c0);\n                }\n                SA[b++] = ((0 < j) && (T.get(j - 1) < c1)) ? ~j : j;\n            }\n        }\n\t\t/* compute SAs */\n        if(C == B){\n            getCounts(T, C, n, k);\n        }\n        getBuckets(C, B, k, true); /* find ends of buckets */\n        for(i = n - 1, b = B.get(c1 = 0);0 <= i;--i){\n            if(0 < (j = SA[i])){\n                if((c0 = T.get(--j)) != c1){\n                    B.set(c1, b);\n                    b = B.get(c1 = c0);\n                }\n                SA[--b] = ((j == 0) || (T.get(j - 1) > c1)) ? ~j : j;\n            }else{\n                SA[i] = ~j;\n            }\n        }\n    }\n\n    /*\n     * find the suffix array SA of T[0..n-1] in {0..k-1}^n use a working space\n     * (excluding T and SA) of at most 2n+O(1) for a constant alphabet\n     */\n    private static void SA_IS(BaseArray T, int[] SA, int fs, int n, int k) {\n        BaseArray C, B, RA;\n        int i, j, b, m, p, q, name, newfs;\n        int c0, c1;\n        int flags = 0;\n\n        if(k <= 256){\n            C = new IntArray(new int[k], 0);\n            if(k <= fs){\n                B = new IntArray(SA, n + fs - k);\n                flags = 1;\n            }else{\n                B = new IntArray(new int[k], 0);\n                flags = 3;\n            }\n        }else if(k <= fs){\n            C = new IntArray(SA, n + fs - k);\n            if(k <= (fs - k)){\n                B = new IntArray(SA, n + fs - k * 2);\n                flags = 0;\n            }else if(k <= 1024){\n                B = new IntArray(new int[k], 0);\n                flags = 2;\n            }else{\n                B = C;\n                flags = 8;\n            }\n        }else{\n            C = B = new IntArray(new int[k], 0);\n            flags = 4 | 8;\n        }\n\n\t\t/*\n\t\t * stage 1: reduce the problem by at least 1/2 sort all the\n\t\t * LMS-substrings\n\t\t */\n        getCounts(T, C, n, k);\n        getBuckets(C, B, k, true); /* find ends of buckets */\n        for(i = 0;i < n;++i){\n            SA[i] = 0;\n        }\n        b = -1;\n        i = n - 1;\n        j = n;\n        m = 0;\n        c0 = T.get(n - 1);\n        do{\n            c1 = c0;\n        }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));\n        for(;0 <= i;){\n            do{\n                c1 = c0;\n            }while ((0 <= --i) && ((c0 = T.get(i)) <= c1));\n            if(0 <= i){\n                if(0 <= b){\n                    SA[b] = j;\n                }\n                b = B.update(c1, -1);\n                j = i;\n                ++m;\n                do{\n                    c1 = c0;\n                }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));\n            }\n        }\n        if(1 < m){\n            LMSsort(T, SA, C, B, n, k);\n            name = LMSpostproc(T, SA, n, m);\n        }else if(m == 1){\n            SA[b] = j + 1;\n            name = 1;\n        }else{\n            name = 0;\n        }\n\n\t\t/*\n\t\t * stage 2: solve the reduced problem recurse if names are not yet\n\t\t * unique\n\t\t */\n        if(name < m){\n            if((flags & 4) != 0){\n                C = null;\n                B = null;\n            }\n            if((flags & 2) != 0){\n                B = null;\n            }\n            newfs = (n + fs) - (m * 2);\n            if((flags & (1 | 4 | 8)) == 0){\n                if((k + name) <= newfs){\n                    newfs -= k;\n                }else{\n                    flags |= 8;\n                }\n            }\n            for(i = m + (n >> 1) - 1, j = m * 2 + newfs - 1;m <= i;--i){\n                if(SA[i] != 0){\n                    SA[j--] = SA[i] - 1;\n                }\n            }\n            RA = new IntArray(SA, m + newfs);\n            SA_IS(RA, SA, newfs, m, name);\n            RA = null;\n\n            i = n - 1;\n            j = m * 2 - 1;\n            c0 = T.get(n - 1);\n            do{\n                c1 = c0;\n            }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));\n            for(;0 <= i;){\n                do{\n                    c1 = c0;\n                }while ((0 <= --i) && ((c0 = T.get(i)) <= c1));\n                if(0 <= i){\n                    SA[j--] = i + 1;\n                    do{\n                        c1 = c0;\n                    }while ((0 <= --i) && ((c0 = T.get(i)) >= c1));\n                }\n            }\n\n            for(i = 0;i < m;++i){\n                SA[i] = SA[m + SA[i]];\n            }\n            if((flags & 4) != 0){\n                C = B = new IntArray(new int[k], 0);\n            }\n            if((flags & 2) != 0){\n                B = new IntArray(new int[k], 0);\n            }\n        }\n\n\t\t/* stage 3: induce the result for the original problem */\n        if((flags & 8) != 0){\n            getCounts(T, C, n, k);\n        }\n\t\t/* put all left-most S characters into their buckets */\n        if(1 < m){\n            getBuckets(C, B, k, true); /* find ends of buckets */\n            i = m - 1;\n            j = n;\n            p = SA[m - 1];\n            c1 = T.get(p);\n            do{\n                q = B.get(c0 = c1);\n                while (q < j){\n                    SA[--j] = 0;\n                }\n                do{\n                    SA[--j] = p;\n                    if(--i < 0){\n                        break;\n                    }\n                    p = SA[i];\n                }while ((c1 = T.get(p)) == c0);\n            }while (0 <= i);\n            while (0 < j){\n                SA[--j] = 0;\n            }\n        }\n        induceSA(T, SA, C, B, n, k);\n        C = null;\n        B = null;\n    }\n\n    /* char */\n    public static void suffixsort(char[] T, int[] SA, int n) {\n        if((T == null) || (SA == null) || (T.length < n) || (SA.length < n)){\n            return;\n        }\n        if(n <= 1){\n            if(n == 1){\n                SA[0] = 0;\n            }\n            return;\n        }\n        SA_IS(new CharArray(T, 0), SA, 0, n, 128);\n    }\n\n    public SuffixArrayS(char[] T)\n    {\n        cs = T;\n        n = T.length;\n        si = new int[n];\n        suffixsort(T, si, n);\n    }\n\n    public int n;\n    public int[] si;\n    public char[] cs;\n\n}\n\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn = 2000020;\nchar s[Maxn];\nbool can[Maxn];\nint sa[Maxn], t1[Maxn], t2[Maxn], c[Maxn], dp[Maxn], n, ls;\nint sta[Maxn];\nbool cmp(int *y, int i, int k) {\n  return y[sa[i]] == y[sa[i - 1]] &&\n         y[(sa[i] + k) % (ls)] == y[(sa[i - 1] + k) % (ls)];\n}\nvoid getsa() {\n  int m = 3, n = ls;\n  int *x = t1, *y = t2;\n  for (int i = 0; i < m; i++) c[i] = 0;\n  for (int i = 0; i < n; i++) c[x[i] = s[i]]++;\n  for (int i = 1; i < m; i++) c[i] += c[i - 1];\n  for (int i = n - 1; i >= 0; i--) sa[--c[s[i]]] = i;\n  for (int k = 1; k < n; k <<= 1) {\n    int p = 0;\n    for (int i = 0; i < n; i++) y[p++] = (sa[i] - k + n) % n;\n    for (int i = 0; i < m; i++) c[i] = 0;\n    for (int i = 0; i < n; i++) c[x[y[i]]]++;\n    for (int i = 1; i < m; i++) c[i] += c[i - 1];\n    for (int i = n - 1; i >= 0; i--) sa[--c[x[y[i]]]] = y[i];\n    swap(x, y);\n    p = 1;\n    x[sa[0]] = 0;\n    for (int i = 1; i < n; i++) x[sa[i]] = cmp(y, i, k) ? p - 1 : p++;\n    if (p == n) break;\n    m = p;\n  }\n}\nint main() {\n  scanf(\"%s\", s);\n  ls = strlen(s);\n  s[ls] = 0;\n  for (int i = 0; i < ls; i++) s[i] -= '(' - 1;\n  getsa();\n  for (int i = ls; i < ls + ls; i++) s[i] = s[i - ls];\n  s[ls + ls] = 0;\n  for (int i = 0; i < ls + ls; i++) {\n    dp[i] = i == 0 ? 0 : dp[i - 1];\n    if (s[i] == 1)\n      dp[i]++;\n    else\n      dp[i]--;\n  }\n  int front = 0, rear = 0;\n  for (int i = ls + ls - 1; i >= 0; i--) {\n    while (front < rear && dp[sta[rear - 1]] >= dp[i]) rear--;\n    sta[rear++] = i;\n    if (i + ls < ls + ls && front < rear && sta[front] == i + ls) front++;\n    if (i < ls) {\n      if (front < rear &&\n          dp[sta[front]] - (i == 0 ? 0 : dp[i - 1]) + max(-dp[ls - 1], 0) < 0)\n        can[i] = 0;\n      else\n        can[i] = 1;\n    }\n  }\n  int ned = dp[ls - 1], ans;\n  for (int i = 0; i < ls; i++)\n    if (can[sa[i]]) {\n      ans = sa[i];\n      break;\n    }\n  if (ned < 0) {\n    for (int i = 0; i < -ned; i++) putchar('(');\n    for (int i = ans; i < ans + ls; i++) putchar(s[i] - 1 + '(');\n  } else {\n    for (int i = ans; i < ans + ls; i++) putchar(s[i] - 1 + '(');\n    for (int i = 0; i < ned; i++) putchar(')');\n  }\n  puts(\"\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nstruct SuffixArray {\n  int n, csz;\n  vector<vector<int>> classes;\n  vector<int> cnt, order, oldc, newc, left;\n  string str;\n  SuffixArray(string s, bool cyclic)\n      : n(s.size() + !cyclic),\n        csz(max(n, 256)),\n        cnt(csz),\n        order(n),\n        oldc(n),\n        newc(n),\n        left(n),\n        str(s) {\n    if (!cyclic) str += '\\0';\n  }\n  vector<int> Build() {\n    for (int i = 0; i < n; ++i) {\n      oldc[i] = newc[i] = str[i];\n      order[i] = left[i] = i;\n    }\n    for (int step = 1; step <= 2 * n; step *= 2) {\n      fill(cnt.begin(), cnt.end(), 0);\n      for (int i = 0; i < n; ++i) ++cnt[oldc[left[i]]];\n      for (int i = 1; i < csz; ++i) cnt[i] += cnt[i - 1];\n      for (int i = n - 1; i >= 0; --i) order[--cnt[oldc[left[i]]]] = left[i];\n      newc[order[0]] = 0;\n      for (int i = 1; i < n; ++i) {\n        int now1 = order[i], last1 = order[i - 1], now2 = (now1 + step / 2) % n,\n            last2 = (last1 + step / 2) % n;\n        newc[now1] = newc[last1] +\n                     (oldc[now1] != oldc[last1] or oldc[now2] != oldc[last2]);\n      }\n      classes.push_back(newc);\n      swap(oldc, newc);\n      for (int i = 0; i < n; ++i) {\n        left[i] = (order[i] + n - step) % n;\n      }\n    }\n    return order;\n  }\n  int Compare(int i, int j, int len) {\n    for (int step = 0; len; ++step, len /= 2) {\n      if (len % 2 == 0) continue;\n      int ret = classes[step][i] - classes[step][j];\n      if (ret != 0) return ret < 0 ? -1 : 1;\n      i = (i + (1 << step)) % n;\n      j = (j + (1 << step)) % n;\n    }\n    return 0;\n  }\n  int GetLCP(int i, int j) {\n    if (i == j) return str.back() == '\\0' ? n - i - 1 : n;\n    int ans = 0;\n    for (int step = classes.size() - 1; step >= 0; --step) {\n      if (classes[step][i] == classes[step][j]) {\n        i = (i + (1 << step)) % n;\n        j = (j + (1 << step)) % n;\n        ans += (1 << step);\n      }\n    }\n    return min(ans, n);\n  }\n};\nint main() {\n  string s;\n  cin >> s;\n  int n = s.size();\n  SuffixArray sa(s, true);\n  vector<int> order = sa.Build();\n  vector<int> sp(n, 0);\n  vector<int> minp(n, 0), mins(n, 0);\n  for (int i = 0; i < n; ++i) {\n    if (i > 0) sp[i] = sp[i - 1];\n    if (s[i] == '(')\n      sp[i] += 1;\n    else\n      sp[i] -= 1;\n    minp[i] = sp[i];\n    if (i > 0) minp[i] = min(minp[i], minp[i - 1]);\n  }\n  for (int i = n - 1; i >= 0; --i) {\n    mins[i] = sp[i];\n    if (i + 1 < n) mins[i] = min(mins[i], mins[i + 1]);\n  }\n  int totsp = sp[n - 1];\n  auto OK = [&](int i) {\n    int ladd = max(0, -totsp);\n    int spi = i == 0 ? 0 : sp[i - 1];\n    if (mins[i] - spi + ladd < 0) return false;\n    if (i > 0 && minp[i - 1] + (totsp - spi) + ladd < 0) return false;\n    return true;\n  };\n  int choose = -1;\n  for (auto i : order) {\n    if (OK(i)) {\n      choose = i;\n      break;\n    }\n  }\n  assert(choose != -1);\n  string ans = \"\";\n  for (int i = 0; i < -totsp; ++i) ans += '(';\n  rotate(s.begin(), s.begin() + choose, s.end());\n  ans += s;\n  for (int i = 0; i < totsp; ++i) ans += ')';\n  cout << ans << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> suffix_array(string s) {\n  int n = s.size();\n  vector<int> p(n), c(n), pn(n), cn(n), f(200);\n  for (char i : s) f[i]++;\n  for (int i = 1; i < f.size(); i++) f[i] += f[i - 1];\n  for (int i = 0; i < n; i++) p[--f[s[i]]] = i;\n  int classes = 1;\n  c[p[0]] = 0;\n  for (int i = 1; i < n; i++) {\n    if (s[p[i]] != s[p[i - 1]]) classes++;\n    c[p[i]] = classes - 1;\n  }\n  for (int h = 0; (1 << h) < n; h++) {\n    f.assign(classes, 0);\n    for (int i = 0; i < n; i++) pn[i] = (n + p[i] - (1 << h)) % n;\n    for (int i = 0; i < n; i++) f[c[pn[i]]]++;\n    for (int i = 1; i < classes; i++) f[i] += f[i - 1];\n    for (int i = n - 1; i >= 0; i--) p[--f[c[pn[i]]]] = pn[i];\n    classes = 1;\n    cn[p[0]] = 0;\n    for (int i = 1; i < n; i++) {\n      pair<int, int> cur = {c[p[i]], c[(p[i] + (1 << h)) % n]},\n                     now = {c[p[i - 1]], c[(p[i - 1] + (1 << h)) % n]};\n      if (cur != now) classes++;\n      cn[p[i]] = classes - 1;\n    }\n    c = cn;\n  }\n  return p;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  string s;\n  cin >> s;\n  int n = s.size();\n  vector<int> sf = suffix_array(s);\n  int op = count(s.begin(), s.end(), '('), cl = count(s.begin(), s.end(), ')');\n  vector<int> pf(n + 1, 0), pfmin(n + 1, 0), sfmin(n + 1, op - cl);\n  for (int i = 0; i < n; i++) {\n    pf[i + 1] = (pf[i] + (s[i] == '(' ? 1 : -1));\n    pfmin[i + 1] = min(pf[i + 1], pfmin[i]);\n  }\n  sfmin[n] = pf[n];\n  for (int i = n; i > 0; i--) sfmin[i - 1] = min(sfmin[i], pf[i]);\n  for (int i = 0; i < sf.size(); i++) {\n    int down = min(sfmin[sf[i] + 1], pf.back() + pfmin[sf[i]]) - pf[sf[i]];\n    if (down >= min(0, op - cl)) {\n      for (int j = 0; j < cl - op; j++) cout << '(';\n      for (int j = 0; j < n; j++) cout << s[(j + sf[i]) % n];\n      for (int j = 0; j < op - cl; j++) cout << ')';\n      cout << \"\\n\";\n      break;\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1000010;\nchar s[N];\nint balance[N];\nint mnbal1[N], mnbal2[N];\nconst int alphabet = 123;\nint p[N], cnt[N], c[N];\nint pn[N], cn[N];\nint main() {\n  scanf(\"%s\", s);\n  int len = strlen(s);\n  for (int i = 0; i < len; ++i)\n    balance[i + 1] = balance[i] + (s[i] == '(' ? 1 : -1);\n  memset(cnt, 0, alphabet * sizeof(int));\n  for (int i = 0; i < len; ++i) ++cnt[static_cast<int>(s[i])];\n  for (int i = 1; i < alphabet; ++i) cnt[i] += cnt[i - 1];\n  for (int i = 0; i < len; ++i) p[--cnt[static_cast<int>(s[i])]] = i;\n  c[p[0]] = 0;\n  int classes = 1;\n  for (int i = 1; i < len; ++i) {\n    if (s[p[i]] != s[p[i - 1]]) ++classes;\n    c[p[i]] = classes - 1;\n  }\n  for (int h = 0; (1 << h) < len; ++h) {\n    for (int i = 0; i < len; ++i) {\n      pn[i] = p[i] - (1 << h);\n      if (pn[i] < 0) pn[i] += len;\n    }\n    memset(cnt, 0, classes * sizeof(int));\n    for (int i = 0; i < len; ++i) ++cnt[c[pn[i]]];\n    for (int i = 1; i < classes; ++i) cnt[i] += cnt[i - 1];\n    for (int i = len - 1; i >= 0; --i) p[--cnt[c[pn[i]]]] = pn[i];\n    cn[p[0]] = 0;\n    classes = 1;\n    for (int i = 1; i < len; ++i) {\n      int mid1 = (p[i] + (1 << h)) % len, mid2 = (p[i - 1] + (1 << h)) % len;\n      if (c[p[i]] != c[p[i - 1]] || c[mid1] != c[mid2]) ++classes;\n      cn[p[i]] = classes - 1;\n    }\n    memcpy(c, cn, len * sizeof(int));\n  }\n  int total = balance[len];\n  int can = total >= 0 ? 0 : -total;\n  cerr << \"total = \" << total << endl;\n  cerr << \"can = \" << can << endl;\n  for (int i = 1; i <= len; ++i) mnbal1[i] = min(balance[i], mnbal1[i - 1]);\n  mnbal2[len] = balance[len];\n  for (int i = len - 1; i >= 0; --i) mnbal2[i] = min(balance[i], mnbal2[i + 1]);\n  int mn = *min_element(balance, balance + len);\n  cerr << \"mn = \" << mn << endl;\n  int start = -1;\n  for (int i = 0; i < len; ++i) {\n    int depth =\n        min(mnbal2[p[i]] - balance[p[i]], mnbal1[p[i]] + total - balance[p[i]]);\n    if (depth >= 0 || depth >= total) {\n      start = p[i];\n      break;\n    }\n  }\n  cerr << \"start = \" << start << endl;\n  for (int i = 0; i < -total; ++i) cout << '(';\n  cout << s + start;\n  s[start] = 0;\n  cout << s;\n  for (int i = 0; i < total; ++i) cout << ')';\n  cout << endl;\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1000000007;\nconst int _P = 257;\nconst int INF = 1000000000;\nconst int MAXN = 1000005;\nconst int SZ = 1 << 21;\nint N, A[2 * SZ], C[MAXN], res = -1;\nlong long H[2 * MAXN], P[2 * MAXN];\nstring S, SS;\ninline int get(int p, int l) {\n  return (H[p + l] - H[p] * P[l] % MOD + MOD) % MOD;\n}\nbool comp(int a, int b) {\n  int lo = 0, hi = N + 1;\n  while (lo + 1 < hi) {\n    int mid = (lo + hi) / 2;\n    if (get(a, mid) == get(b, mid))\n      lo = mid;\n    else\n      hi = mid;\n  }\n  if (lo == N) return 0;\n  return SS[a + lo] < SS[b + lo];\n}\nint rmq(int l, int r) {\n  l += SZ, r += SZ + 1;\n  int res = INF;\n  for (; l < r; l /= 2, r /= 2) {\n    if (l & 1) res = min(res, A[l++]);\n    if (r & 1) res = min(res, A[--r]);\n  }\n  return res;\n}\nvoid init() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> S;\n  N = S.size();\n  SS = S + S;\n  P[0] = 1;\n  for (int i = 0; i < 2 * N; i++) {\n    H[i + 1] = (H[i] * _P + SS[i]) % MOD;\n    P[i + 1] = P[i] * _P % MOD;\n    A[i + 1 + SZ] = A[i + SZ] + 2 * (SS[i] == '(') - 1;\n  }\n  for (int i = SZ - 1; i >= 0; i--) {\n    A[i] = min(A[2 * i], A[2 * i + 1]);\n  }\n}\nint main() {\n  init();\n  for (int i = 0; i < N; i++) {\n    int k = rmq(i, i + N) - A[i + SZ];\n    if (k >= min(A[N + SZ], 0) && (res < 0 || comp(i, res))) {\n      res = i;\n    }\n  }\n  for (int i = 0; i < -A[N + SZ]; i++) cout << \"(\";\n  cout << SS.substr(res, N);\n  for (int i = 0; i < A[N + SZ]; i++) cout << \")\";\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1000010;\nchar s[MAXN * 2];\nint bl[MAXN * 2];\nint dd[MAXN * 2];\nint aa[MAXN];\nint c[MAXN];\nint newc[MAXN];\nint p[MAXN];\nint newp[MAXN];\nint mx = -MAXN;\nint cnt[MAXN];\nint n;\nint nm(int x) { return (x < 0 ? x + n : (x >= n ? x - n : x)); }\nint main() {\n  scanf(\"%s\", s);\n  n = strlen(s);\n  memcpy(s + n, s, sizeof(s[0]) * n);\n  bl[0] = 0;\n  for (int i = 0; i < 2 * n; ++i) bl[i + 1] = bl[i] + (s[i] == '(' ? 1 : -1);\n  int l = 0;\n  int r = 0;\n  for (int i = 0; i <= n; ++i) {\n    while (r - l > 0 && dd[r - 1] > bl[i]) --r;\n    dd[r++] = bl[i];\n  }\n  for (int i = 0; i < n; ++i) {\n    aa[i] = dd[l] - bl[i];\n    mx = max(mx, aa[i]);\n    if (dd[l] == bl[i]) ++l;\n    while (r - l > 0 && dd[r - 1] > bl[i + n + 1]) --r;\n    dd[r++] = bl[i + n + 1];\n  }\n  for (int i = 0; i < n; ++i) c[i] = (s[i] == '(' ? 0 : 1);\n  for (int i = 0; i < n; ++i) ++cnt[c[i] + 1];\n  for (int i = 0; i < n; ++i) cnt[i + 1] += cnt[i];\n  for (int i = 0; i < n; ++i) p[cnt[c[i]]++] = i;\n  for (int k = 0; (1 << k) < n; ++k) {\n    int sh = (1 << k);\n    for (int i = 0; i < n; ++i) p[i] = nm(p[i] - sh);\n    memset(cnt, 0, sizeof(cnt));\n    for (int i = 0; i < n; ++i) ++cnt[c[i] + 1];\n    for (int i = 0; i < n; ++i) cnt[i + 1] += cnt[i];\n    for (int i = 0; i < n; ++i) newp[cnt[c[p[i]]]++] = p[i];\n    memcpy(p, newp, sizeof(newp));\n    newc[p[0]] = 0;\n    for (int i = 1; i < n; ++i) {\n      if (c[p[i]] == c[p[i - 1]] && c[nm(p[i] + sh)] == c[nm(p[i - 1] + sh)])\n        newc[p[i]] = newc[p[i - 1]];\n      else\n        newc[p[i]] = newc[p[i - 1]] + 1;\n    }\n    memcpy(c, newc, sizeof(newc));\n  }\n  int bst = -1;\n  for (int i = 0; i < n; ++i)\n    if (aa[i] == mx && (bst == -1 || c[i] < c[bst])) bst = i;\n  mx = -mx;\n  mx = max(mx, 0);\n  for (int i = 0; i < mx; ++i) printf(\"(\");\n  for (int i = bst; i < bst + n; ++i) printf(\"%c\", s[i]);\n  int k = bl[n] + mx;\n  for (int i = 0; i < k; ++i) printf(\")\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T, typename U>\ninline void smin(T &a, U b) {\n  if (a > b) a = b;\n}\ntemplate <typename T, typename U>\ninline void smax(T &a, U b) {\n  if (a < b) a = b;\n}\ntemplate <class T>\ninline void gn(T &first) {\n  char c, sg = 0;\n  while (c = getchar(), (c > '9' || c < '0') && c != '-')\n    ;\n  for ((c == '-' ? sg = 1, c = getchar() : 0), first = 0; c >= '0' && c <= '9';\n       c = getchar())\n    first = (first << 1) + (first << 3) + c - '0';\n  if (sg) first = -first;\n}\ntemplate <class T>\ninline void print(T first) {\n  if (first < 0) {\n    putchar('-');\n    return print(-first);\n  }\n  if (first < 10) {\n    putchar('0' + first);\n    return;\n  }\n  print(first / 10);\n  putchar(first % 10 + '0');\n}\nint power(int a, int b, int m, int ans = 1) {\n  for (; b; b >>= 1, a = 1LL * a * a % m)\n    if (b & 1) ans = 1LL * ans * a % m;\n  return ans;\n}\nchar s[2001111];\nint rk[2001111];\nint r[2001111 * 3], sa[2001111 * 3], wa[2001111 * 3], wb[2001111 * 3],\n    wv[2001111 * 3], ss[2001111 * 3];\nstruct DC_3 {\n  int c0(int *r, int a, int b) {\n    return r[a] == r[b] && r[a + 1] == r[b + 1] && r[a + 2] == r[b + 2];\n  }\n  int c12(int k, int *r, int a, int b) {\n    if (k == 2) return r[a] < r[b] || r[a] == r[b] && c12(1, r, a + 1, b + 1);\n    return r[a] < r[b] || r[a] == r[b] && wv[a + 1] < wv[b + 1];\n  }\n  void sort(int *r, int *a, int *b, int n, int m) {\n    for (int i = 0; i < n; i++) wv[i] = r[a[i]];\n    for (int i = 0; i < m; i++) ss[i] = 0;\n    for (int i = 0; i < n; i++) ss[wv[i]]++;\n    for (int i = 1; i < m; i++) ss[i] += ss[i - 1];\n    for (int i = n - 1; i >= 0; i--) b[--ss[wv[i]]] = a[i];\n    return;\n  }\n  void DC3(int *r, int *sa, int n, int m) {\n    int i, j, p;\n    int *san = sa + n, *rn = r + n;\n    int ta = 0, tb = (n + 1) / 3, tbc = 0;\n    r[n] = r[n + 1] = 0;\n    for (i = 0; i < n; i++)\n      if (i % 3 != 0) wa[tbc++] = i;\n    sort(r + 2, wa, wb, tbc, m);\n    sort(r + 1, wb, wa, tbc, m);\n    sort(r, wa, wb, tbc, m);\n    for (p = 1, rn[((wb[0]) / 3 + ((wb[0]) % 3 == 1 ? 0 : tb))] = 0, i = 1;\n         i < tbc; i++)\n      rn[((wb[i]) / 3 + ((wb[i]) % 3 == 1 ? 0 : tb))] =\n          c0(r, wb[i - 1], wb[i]) ? p - 1 : p++;\n    if (p < tbc)\n      DC3(rn, san, tbc, p);\n    else\n      for (i = 0; i < tbc; i++) san[rn[i]] = i;\n    for (i = 0; i < tbc; i++)\n      if (san[i] < tb) wb[ta++] = san[i] * 3;\n    if (n % 3 == 1) wb[ta++] = n - 1;\n    sort(r, wb, wa, ta, m);\n    for (i = 0; i < tbc; i++)\n      wv[wb[i] = ((san[i]) < tb ? (san[i]) * 3 + 1 : ((san[i]) - tb) * 3 + 2)] =\n          i;\n    for (i = 0, j = 0, p = 0; i < ta && j < tbc; p++)\n      sa[p] = c12(wb[j] % 3, r, wa[i], wb[j]) ? wa[i++] : wb[j++];\n    for (; i < ta; p++) sa[p] = wa[i++];\n    for (; j < tbc; p++) sa[p] = wb[j++];\n    for (int i = 0; i < n; i++) rk[sa[i]] = i;\n    return;\n  }\n} DC;\nmultiset<int> S;\nint val[2001111], mn[2001111];\nchar ans[2001111];\nint main() {\n  scanf(\"%s\", s);\n  int n = strlen(s);\n  copy(s, s + n, s + n);\n  for (int i = 0; i < n << 1; i++) r[i] = s[i];\n  DC.DC3(r, sa, (n << 1) + 1, 50);\n  int tmp = 0, need = 0;\n  for (int i = 0; i < n << 1; i++) {\n    if (i == n) need = tmp;\n    if (s[i] == '(')\n      val[i] = ++tmp;\n    else\n      val[i] = --tmp;\n    if (i < n) S.insert(val[i]);\n  }\n  mn[0] = *S.begin();\n  int add = 0;\n  for (int i = n; i < n << 1; i++) {\n    S.insert(val[i]);\n    S.erase(S.find(val[i - n]));\n    if (s[i - n] == '(')\n      add--;\n    else\n      add++;\n    mn[i - n + 1] = *S.begin() + add;\n  }\n  int pos = 0;\n  if (need < 0)\n    tmp = need;\n  else\n    tmp = 0;\n  for (int i = 0; i < n * 2; i++)\n    if (sa[i] < n) {\n      if (mn[sa[i]] - tmp >= 0) {\n        pos = sa[i];\n        break;\n      }\n    }\n  int nn = 0;\n  for (int i = 0; i < -need; i++) ans[nn++] = '(';\n  for (int i = pos; i < pos + n; i++) ans[nn++] = (s[i]);\n  for (int i = 0; i < need; i++) ans[nn++] = ')';\n  ans[nn] = 0;\n  add = 0;\n  for (int i = 0; i < nn; i++) {\n    if (ans[i] == '(')\n      add++;\n    else\n      add--;\n    if (add < 0)\n      while (1)\n        ;\n  }\n  puts(ans);\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, k;\nchar s[2000005];\nint pre[2000005], qu[2000005], id[2000005];\nbool flag[2000005];\nstruct SA {\n public:\n  const static int MAXN = 2e6 + 5;\n  int cnt[MAXN], ts[MAXN], sa[MAXN], rk[MAXN], ht[MAXN], len, tr[2][MAXN];\n  void construct(const char *s, int n, int m = 256) {\n    int i, j, k, *x = tr[0], *y = tr[1];\n    this->len = n;\n    memset(cnt, 0, sizeof(cnt[0]) * m);\n    for (i = 0; i < n; ++i) cnt[s[i]]++;\n    partial_sum(cnt, cnt + m, cnt);\n    for (i = 0; i < n; ++i) rk[i] = cnt[s[i]] - 1;\n    for (k = 1; k <= n; k <<= 1) {\n      for (i = 0; i < n; ++i)\n        x[i] = rk[i], y[i] = i + k < n ? rk[i + k] + 1 : 0;\n      fill(cnt, cnt + n + 1, 0);\n      for (i = 0; i < n; ++i) cnt[y[i]]++;\n      partial_sum(cnt, cnt + n + 1, cnt);\n      for (i = n - 1; i >= 0; --i) ts[--cnt[y[i]]] = i;\n      fill(cnt, cnt + n + 1, 0);\n      for (i = 0; i < n; ++i) cnt[x[i]]++;\n      partial_sum(cnt, cnt + n + 1, cnt);\n      for (i = n - 1; i >= 0; --i) sa[--cnt[x[ts[i]]]] = ts[i];\n      for (i = rk[sa[0]] = 0; i + 1 < n; ++i) {\n        rk[sa[i + 1]] =\n            rk[sa[i]] + (x[sa[i]] != x[sa[i + 1]] || y[sa[i]] != y[sa[i + 1]]);\n      }\n    }\n    for (i = 0, k = 0; i < n; ++i) {\n      if (!rk[i]) continue;\n      for (j = sa[rk[i] - 1]; i + k < n && j + k < n && s[i + k] == s[j + k];)\n        k++;\n      ht[rk[i]] = k;\n      if (k) k--;\n    }\n  }\n} sa;\nbool ok(int t) {\n  int st = -1, ed = -1;\n  for (int i = 0; i <= n - k; i++) {\n    if (sa.rk[i] > t) continue;\n    if (ed == -1 || i > ed + 1) {\n      st = i;\n      ed = i + k - 1;\n    } else\n      ed = i + k - 1;\n    if (ed - st + 1 >= n / 2) return 1;\n  }\n  return 0;\n}\nint main() {\n  scanf(\"%s\", s);\n  n = strlen(s);\n  int cnt = 0;\n  for (int i = 0; i < n; i++)\n    if (s[i] == '(') cnt++;\n  for (int i = n; i < 2 * n; i++) s[i] = s[i - n];\n  n <<= 1;\n  for (int i = 0; i < n; i++)\n    pre[i] = (i == 0 ? 0 : pre[i - 1]) + (s[i] == '(' ? 1 : -1);\n  int head = 1, tail = 1;\n  id[1] = 0;\n  qu[1] = pre[0];\n  for (int i = 1; i < n; i++) {\n    if (id[head] <= i - n / 2) head++;\n    int tmp = lower_bound(qu + head, qu + tail + 1, pre[i]) - qu;\n    qu[tail = tmp] = pre[i], id[tail] = i;\n    if (i >= n / 2 - 1 && qu[head] >= (i == n / 2 - 1 ? 0 : pre[i - n / 2]) -\n                                          max(0, n / 2 - 2 * cnt))\n      flag[i - n / 2 + 1] = 1;\n  }\n  sa.construct(s, n);\n  int i = 0;\n  for (; i <= n; i++)\n    if (flag[sa.sa[i]] && sa.sa[i] < n / 2) break;\n  if (cnt < n / 2 - cnt)\n    for (int j = 0; j < n / 2 - 2 * cnt; j++) printf(\"%c\", '(');\n  for (int j = 0; j < n / 2; j++) printf(\"%c\", s[sa.sa[i] + j]);\n  if (cnt > n / 2 - cnt)\n    for (int j = 0; j < 2 * cnt - n / 2; j++) printf(\"%c\", ')');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 4000010;\ninline int read() {\n  int x = 0;\n  int f = 0, c = getchar();\n  for (; c > '9' || c < '0'; f = c == '-', c = getchar())\n    ;\n  for (; c >= '0' && c <= '9'; c = getchar()) x = (x << 3) + (x << 1) + c - '0';\n  return f ? -x : x;\n}\nstruct cqz {\n  int i, x, y;\n  cqz(int a = 0, int b = 0, int c = 0) {\n    i = a;\n    x = b;\n    y = c;\n  }\n} a[N];\ninline bool operator<(const cqz& i, const cqz& j) {\n  return i.x < j.x || (i.x == j.x && i.y < j.y);\n}\ninline bool operator!=(const cqz& i, const cqz& j) {\n  return i.x != j.x || i.y != j.y;\n}\nchar s[N];\nint sta[N], top, p[N];\nint n, m, rk[N], sm, sl, sr, ans, flag;\nint main() {\n  scanf(\"%s\", s + 1);\n  n = strlen(s + 1);\n  m = n;\n  register int i, j, k;\n  for (i = 1; i <= n; i++) s[i + n] = s[i];\n  n = n + n;\n  for (i = 1; i <= n; i++) rk[i] = s[i];\n  for (k = 1; k < n; k <<= 1) {\n    for (i = 1; i <= n; i++) a[i] = cqz(i, rk[i], rk[i + k]);\n    sort(a + 1, a + n + 1);\n    for (i = j = 1; i <= n; i++) rk[a[i].i] = j, j += a[i + 1] != a[i];\n    if (j >= n) break;\n  }\n  for (i = n - 1; i > m; i--)\n    if (s[i] == '(') {\n      if (sl)\n        sm++, sl--;\n      else\n        sr++;\n    } else\n      sl++;\n  k = n + n;\n  for (i = 1; i <= n; i++)\n    if (s[i] == '(')\n      sta[++top] = i;\n    else {\n      p[i] = sta[top];\n      if (top) top--;\n    }\n  for (i = m; i; i--) {\n    if (s[i] == '(') {\n      if (sl)\n        sm++, sl--;\n      else\n        sr++;\n    } else\n      sl++;\n    if (!sl || !sr) {\n      flag = sl - sr;\n      if (rk[i] < k) ans = i, k = rk[i];\n    }\n    if (s[i + m - 1] == '(')\n      sr--;\n    else {\n      if (p[i + m - 1] > i)\n        sm--, sr++;\n      else\n        sl--;\n    }\n  }\n  if (flag > 0)\n    while (flag) putchar('('), flag--;\n  for (i = 0; i < m; i++) putchar(s[ans + i]);\n  if (flag < 0)\n    while (flag++) putchar(')');\n  puts(\"\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\nvoid qread(int &x) {\n  int neg = 1;\n  x = 0;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') neg = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') x = 10 * x + c - '0', c = getchar();\n  x *= neg;\n}\nconst int maxn = 1000005;\nconst long long mod1 = 1e9 + 7;\nconst long long H1 = 20160516;\nconst long long mod2 = 998244353;\nconst long long H2 = 20000000;\nint n, ans, lft, rgt;\nint sum[maxn], pre[maxn], suf[maxn];\nlong long h1[maxn * 2], pw1[maxn * 2], h2[maxn * 2], pw2[maxn * 2];\nchar c[maxn];\nstring s, t;\npair<long long, long long> getval(int l, int r) {\n  long long val1 =\n      (h1[r] - (!l ? 0 : h1[l - 1]) * pw1[r - l + 1] % mod1 + mod1) % mod1;\n  long long val2 =\n      (h2[r] - (!l ? 0 : h2[l - 1]) * pw2[r - l + 1] % mod2 + mod2) % mod2;\n  return make_pair(val1, val2);\n}\nbool Cmp(int i, int j) {\n  int l = 0, r = 2 * n;\n  while (r - l > 1) {\n    int mid = l + r >> 1;\n    if (i + mid - 1 >= 2 * n || j + mid - 1 >= 2 * n ||\n        getval(i, i + mid - 1) != getval(j, j + mid - 1))\n      r = mid;\n    else\n      l = mid;\n  }\n  if (i + r - 1 >= 2 * n || j + r - 1 >= 2 * n) return true;\n  return t[i + r - 1] < t[j + r - 1];\n}\nint main() {\n  scanf(\"%s\", c);\n  s = c;\n  n = s.size();\n  t = s + s;\n  pw1[0] = pw2[0] = 1;\n  for (int(i) = 1; (i) <= t.size(); i++)\n    pw1[i] = pw1[i - 1] * H1 % mod1, pw2[i] = pw2[i - 1] * H2 % mod2;\n  h1[0] = h2[0] = t[0];\n  for (int(i) = 1; (i) <= t.size() - 1; i++) {\n    h1[i] = (h1[i - 1] * H1 + t[i]) % mod1;\n    h2[i] = (h2[i - 1] * H2 + t[i]) % mod2;\n  }\n  for (int(i) = 0; (i) < n; i++)\n    sum[i] = (!i ? 0 : sum[i - 1]) + (s[i] == '(' ? 1 : -1);\n  pre[0] = sum[0];\n  for (int(i) = 1; (i) <= n - 1; i++) pre[i] = min(pre[i - 1], sum[i]);\n  suf[n - 1] = sum[n - 1];\n  for (int i = n - 2; i >= 0; i--) suf[i] = min(suf[i + 1], sum[i]);\n  ans = -1;\n  int anslen = 1e9;\n  if (sum[n - 1] < 0)\n    lft = -sum[n - 1];\n  else\n    rgt = sum[n - 1];\n  for (int(i) = 0; (i) < n; i++) {\n    int dlt = (!i ? 0 : sum[i - 1]);\n    int mn = min(suf[i] - dlt, (!i ? 0 : pre[i - 1]) + sum[n - 1] - dlt);\n    int curl = max(max(-sum[n - 1], 0), -mn);\n    if (curl + rgt + n < anslen) {\n      anslen = curl + rgt + n;\n      lft = curl;\n      ans = i;\n    } else if (curl + rgt + n == anslen) {\n      if (Cmp(i, ans)) ans = i, lft = curl;\n    }\n  }\n  for (int(i) = 0; (i) < lft; i++) putchar('(');\n  for (int i = ans; i < n; i++) putchar(s[i]);\n  for (int(i) = 0; (i) < ans; i++) putchar(s[i]);\n  for (int(i) = 0; (i) < rgt; i++) putchar(')');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2000 * 1000;\nint pos[N];\nint new_pos[N];\nint c[N];\nint new_c[N];\nint head[N];\nint cnt[N];\nstring s;\nint n;\nint low(int i, int step) {\n  i -= step;\n  if (i < 0) i += n;\n  return i;\n}\nint high(int i, int step) {\n  i += step;\n  if (i >= n) i -= n;\n  return i;\n}\nbool are_same(int p1, int p2, int step) {\n  if (c[p1] != c[p2]) return false;\n  p1 = high(p1, step);\n  p2 = high(p2, step);\n  if (c[p1] != c[p2]) return false;\n  return true;\n}\nvoid build_array() {\n  n = s.length();\n  fill(head, head + N, 0);\n  fill(cnt, cnt + N, 0);\n  for (int i = 0; i < n; ++i) ++cnt[s[i]];\n  for (int i = 1; i < N; ++i) head[i] = head[i - 1] + cnt[i - 1];\n  for (int i = 0; i < n; ++i) {\n    c[i] = s[i];\n    pos[head[c[i]]++] = i;\n  }\n  head[0] = 0;\n  for (int i = 1; i < N; ++i) head[i] = head[i - 1] + cnt[i - 1];\n  for (int step = 1; step <= n; step *= 2) {\n    for (int i = 0; i < n; ++i) {\n      int cur = low(pos[i], step);\n      new_pos[head[c[cur]]++] = cur;\n    }\n    head[0] = 0;\n    new_c[new_pos[0]] = 0;\n    bool all_diff = true;\n    for (int i = 1; i < n; ++i)\n      if (are_same(new_pos[i], new_pos[i - 1], step)) {\n        new_c[new_pos[i]] = new_c[new_pos[i - 1]];\n        all_diff = false;\n      } else {\n        new_c[new_pos[i]] = new_c[new_pos[i - 1]] + 1;\n        head[new_c[new_pos[i]]] = i;\n      }\n    copy(new_c, new_c + n, c);\n    copy(new_pos, new_pos + n, pos);\n    if (all_diff) break;\n  }\n}\nint main() {\n  getline(cin, s);\n  build_array();\n  vector<int> bal(n);\n  int sum = 0;\n  for (int i = 0; i < n; i++) {\n    if (s[i] == '(')\n      sum++;\n    else\n      sum--;\n    bal[i] = sum;\n  }\n  int tot = sum;\n  vector<int> suffMin(n + 1, N);\n  for (int i = n - 1; i >= 0; i--) suffMin[i] = min(bal[i], suffMin[i + 1]);\n  vector<bool> good(n);\n  int curMin = N;\n  for (int i = 0; i < n; i++) {\n    int old = i == 0 ? 0 : bal[i - 1];\n    bool ok = true;\n    if (suffMin[i] - old < min(tot, 0)) ok = false;\n    if (tot - old + curMin < min(tot, 0)) ok = false;\n    if (ok) good[i] = true;\n    curMin = min(curMin, bal[i]);\n  }\n  int start = 0;\n  for (int i = 0; i < n; i++)\n    if (good[pos[i]]) {\n      start = pos[i];\n      break;\n    }\n  for (int i = 0; i < -sum; i++) cout << \"(\";\n  for (int i = 0; i < n; i++) cout << s[(i + start) % n];\n  for (int i = 0; i < sum; i++) cout << \")\";\n  cout << \"\\n\";\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:1024000000,1024000000\")\nusing namespace std;\nint w[2000010], wa[2000010], wb[2000010], sa[2000010], s[2000010], f[2000010],\n    q[2000010];\nchar st[2000010];\nvoid suffix(char *s, int n) {\n  int i, j, p, m = 128, *first = wa, *second = wb;\n  for (i = 0; i < m; i++) w[i] = 0;\n  for (i = 0; i < n; i++) w[first[i] = s[i]]++;\n  for (i = 1; i < m; i++) w[i] += w[i - 1];\n  for (i = n - 1; i >= 0; i--) sa[--w[first[i]]] = i;\n  for (j = 1, p = 0; p != n && j < n; j <<= 1, m = p) {\n    for (i = 0, p = 0; i < n; i++) second[p++] = (sa[i] - j + n) % n;\n    for (i = 0; i < m; i++) w[i] = 0;\n    for (i = 0; i < n; i++) w[first[i]]++;\n    for (i = 1; i < m; i++) w[i] += w[i - 1];\n    for (i = n - 1; i >= 0; i--) sa[--w[first[second[i]]]] = second[i];\n    swap(first, second);\n    for (i = 1, first[sa[0]] = 0, p = 1; i < n; i++) {\n      first[sa[i]] = (second[sa[i - 1]] == second[sa[i]] &&\n                      second[(sa[i - 1] + j) % n] == second[(sa[i] + j) % n])\n                         ? p - 1\n                         : p++;\n    }\n  }\n}\nint main() {\n  int T, i, j, k, ca = 0, m, n;\n  scanf(\"%s\", st);\n  n = strlen(st);\n  for (i = 0; i < n; i++) st[i + n] = st[i];\n  st[n + n] = 0;\n  for (i = 0; i < n + n; i++) s[i + 1] = s[i] + (st[i] == '(' ? 1 : -1);\n  suffix(st, n);\n  int head = 0, tail = -1;\n  for (i = 1; i <= n + n; i++) {\n    while (head <= tail && q[head] < i - n + 1) head++;\n    while (head <= tail && s[i] <= s[q[tail]]) tail--;\n    q[++tail] = i;\n    if (i >= n) f[i - n] = s[q[head]];\n  }\n  k = min(s[n], 0);\n  for (i = 0; i < n; i++) {\n    j = sa[i];\n    if (j >= n) continue;\n    if (f[j] - s[j] >= k) break;\n  }\n  for (i = 0; i < -s[n]; i++) printf(\"(\");\n  for (i = j; i < j + n; i++) printf(\"%c\", st[i]);\n  for (i = 0; i < s[n]; i++) printf(\")\");\n  puts(\"\");\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 4.1e6;\nstring str, pstr;\nint n, ans, nst[maxn], pos[maxn];\nmultiset<int> S;\ninline int idx(char c) { return c == '(' ? 1 : -1; }\nvoid prepare() {\n  n = str.size(), str += str;\n  for (int i = 1; i <= n; ++i) ans += idx(str[i - 1]);\n  for (int i = 1; i <= (int)str.size(); ++i)\n    nst[i] = nst[i - 1] + idx(str[i - 1]);\n  for (int i = 1; i <= n; ++i) S.insert(nst[i]);\n  for (int i = 1; i <= n; ++i) {\n    if (*S.begin() - min(ans, 0) - nst[i - 1] >= 0) pos[i - 1] = 1;\n    S.insert(nst[i + n]), S.erase(S.find(nst[i]));\n  }\n}\nvoid min_iso() {\n  for (int i = 1; i <= abs(ans); ++i) pstr += ans > 0 ? ')' : '(';\n  if (ans < 0) cout << pstr;\n  int i, j, k, l;\n  for (i = -1, j = 0, k = 0; i < n && j < n && k < n;) {\n    if (!pos[j]) {\n      j++;\n      continue;\n    }\n    if (i == -1) {\n      i = j, j++;\n      continue;\n    }\n    int t = idx(str[i + k]) - idx(str[j + k]);\n    if (!t)\n      k++;\n    else {\n      if (t > 0)\n        j += k + 1;\n      else\n        l = i + k, i = j, j = max(l, j) + 1;\n      k = 0;\n    }\n  }\n  cout << str.substr(i, n);\n  if (ans > 0) cout << pstr;\n}\nint main() {\n  cin >> str;\n  prepare();\n  min_iso();\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int max_n = 1011111, max_lev = 21, inf = 1111111111;\nstruct tree {\n  int a[4 * max_n], f[4 * max_n];\n  tree() {\n    memset(a, 0, sizeof(a));\n    memset(f, 0, sizeof(f));\n  }\n  void push(int v, int l, int r) {\n    if (f[v] != 0) {\n      a[v] += f[v];\n      f[2 * v] += f[v];\n      f[2 * v + 1] += f[v];\n      f[v] = 0;\n    }\n  }\n  void update(int v, int tl, int tr, int l, int r, int value) {\n    if (tl == l && tr == r) {\n      f[v] += value;\n      return;\n    }\n    push(v, tl, tr);\n    int mid = (tl + tr) / 2;\n    if (r <= mid) {\n      update(2 * v, tl, mid, l, r, value);\n    } else if (l > mid) {\n      update(2 * v + 1, mid + 1, tr, l, r, value);\n    } else {\n      update(2 * v, tl, mid, l, mid, value);\n      update(2 * v + 1, mid + 1, tr, mid + 1, r, value);\n    }\n    a[v] = min(a[2 * v] + f[2 * v], a[2 * v + 1] + f[2 * v + 1]);\n  }\n  int get_min(int v, int tl, int tr, int l, int r) {\n    if (tl == l && tr == r) {\n      return a[v] + f[v];\n    }\n    push(v, tl, tr);\n    int mid = (tl + tr) / 2;\n    if (r <= mid) {\n      return get_min(2 * v, tl, mid, l, r);\n    }\n    if (l > mid) {\n      return get_min(2 * v + 1, mid + 1, tr, l, r);\n    }\n    return min(get_min(2 * v, tl, mid, l, mid),\n               get_min(2 * v + 1, mid + 1, tr, mid + 1, r));\n  }\n  void write(int v, int l, int r) {\n    if (l == r) {\n      cout << l << ' ' << r << \" - \" << a[v] << \" (\" << f[v] << \")\\n\";\n      return;\n    }\n    cout << l << ' ' << r << \" - \" << a[v] << \" (\" << f[v] << \")\\n\";\n    int mid = (l + r) / 2;\n    write(2 * v, l, mid);\n    write(2 * v + 1, mid + 1, r);\n  }\n};\nint n, a[2][max_n], cl[2][max_n], num[2][max_n], f[max_n], sum[max_n];\npair<int, pair<int, int> > p[max_n], p2[max_n];\nstring s;\nchar S[max_n];\ntree t;\nbool cmp(int a, int b) { return s[a] < s[b] || s[a] == s[b] && a < b; }\nvoid my_sort() {\n  memset(sum, 0, sizeof(sum));\n  for (int i = 0; i < n; ++i) {\n    ++sum[p[i].second.first + 1];\n  }\n  for (int i = 1; i < n; ++i) {\n    sum[i] += sum[i - 1];\n  }\n  sum[0] = 0;\n  for (int i = 0; i < n; ++i) {\n    p2[sum[p[i].second.first]++] = p[i];\n  }\n  memset(sum, 0, sizeof(sum));\n  for (int i = 0; i < n; ++i) {\n    ++sum[p2[i].first + 1];\n  }\n  for (int i = 1; i < n; ++i) {\n    sum[i] += sum[i - 1];\n  }\n  sum[0] = 0;\n  for (int i = 0; i < n; ++i) {\n    p[sum[p2[i].first]++] = p2[i];\n  }\n}\nvoid get_suffix_array() {\n  for (int i = 0; i < n; ++i) {\n    a[0][i] = i;\n  }\n  sort(a[0], a[0] + n, cmp);\n  int cnt = 0;\n  for (int i = 0; i < n; ++i) {\n    num[0][a[0][i]] = i;\n  }\n  for (int i = 0; i < n; ++i) {\n    while (i + 1 < n && s[a[0][i]] == s[a[0][i + 1]]) {\n      cl[0][i] = cnt;\n      ++i;\n    }\n    cl[0][i] = cnt;\n    ++cnt;\n  }\n  int f1 = 0, f2 = 1;\n  for (int lev = 1, len = 1; len <= n; ++lev, len *= 2) {\n    for (int i = 0; i < n; ++i) {\n      p[i] = make_pair(cl[f1][num[f1][i]],\n                       make_pair(cl[f1][num[f1][(i + len) % n]], i));\n    }\n    my_sort();\n    for (int i = 0; i < n; ++i) {\n      a[f2][i] = p[i].second.second;\n      num[f2][a[f2][i]] = i;\n    }\n    cnt = 0;\n    for (int i = 0; i < n; ++i) {\n      while (i + 1 < n && p[i].first == p[i + 1].first &&\n             p[i].second.first == p[i + 1].second.first) {\n        cl[f2][i] = cnt;\n        ++i;\n      }\n      cl[f2][i] = cnt;\n      ++cnt;\n    }\n    swap(f1, f2);\n  }\n}\nint main() {\n  scanf(\"%s\", &S);\n  s = S;\n  n = s.length();\n  get_suffix_array();\n  int bal = 0;\n  for (int i = 0; i < n; ++i) {\n    if (s[i] == '(') {\n      ++bal;\n    } else {\n      --bal;\n    }\n    t.update(1, 0, n - 1, i, i, bal);\n  }\n  for (int i = 0; i < n; ++i) {\n    int mn = t.get_min(1, 0, n - 1, 0, n - 1);\n    if (bal > 0) {\n      if (mn >= 0) {\n        f[i] = 1;\n      }\n    } else {\n      if (mn - bal >= 0) {\n        f[i] = 1;\n      }\n    }\n    int x = 1;\n    if (s[i] == '(') {\n      x = -1;\n    }\n    if (i + 1 < n) {\n      t.update(1, 0, n - 1, i + 1, n - 1, x);\n    }\n    if (i) {\n      t.update(1, 0, n - 1, 0, i - 1, x);\n    }\n    t.update(1, 0, n - 1, i, i, bal - t.get_min(1, 0, n - 1, i, i));\n  }\n  if (bal < 0) {\n    for (int i = 0; i < -bal; ++i) {\n      printf(\"(\");\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    if (f[a[0][i]] == 1) {\n      int poz = a[0][i];\n      for (int j = 0; j < n; ++j) {\n        printf(\"%c\", s[(j + poz) % n]);\n      }\n      break;\n    }\n  }\n  if (bal > 0) {\n    for (int i = 0; i < bal; ++i) {\n      printf(\")\");\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e6 + 5;\nchar s[MAXN];\nint n;\nint classes[MAXN];\nint bottom = 0, whereb = 0;\nint main() {\n  gets(s);\n  n = strlen(s);\n  int bal = 0;\n  for (int i = 0; i < n; ++i) {\n    if (s[i] == '(') {\n      ++bal;\n      classes[i] = 0;\n    } else {\n      classes[i] = 1;\n      --bal;\n    }\n    if (bottom > bal) {\n      bottom = bal;\n    }\n    if (bottom == bal) {\n      whereb = i;\n    }\n  }\n  for (int j = 1; j <= n * 2; j <<= 1) {\n    vector<pair<pair<int, int>, int> > tmpa;\n    for (int i = 0; i < n; ++i) {\n      tmpa.push_back(make_pair(make_pair(classes[i], classes[(i + j) % n]), i));\n    }\n    sort((tmpa).begin(), (tmpa).end());\n    pair<int, int> prev = tmpa[0].first;\n    int c = 0;\n    for (int i = 0; i < n; ++i) {\n      if (prev != tmpa[i].first) {\n        ++c;\n        prev = tmpa[i].first;\n      }\n      classes[tmpa[i].second] = c;\n    }\n  }\n  if (bal <= 0) {\n    int tmpbal = 0;\n    pair<int, int> best = make_pair(1e9 + 9, -1);\n    int nowmin = 0;\n    for (int i = 0; i < n; ++i) {\n      if (tmpbal == bottom || (nowmin >= tmpbal && tmpbal - bottom <= -bal)) {\n        best = min(best, make_pair(classes[i], i));\n      }\n      if (s[i] == '(') {\n        ++tmpbal;\n      } else {\n        --tmpbal;\n      }\n      nowmin = min(nowmin, tmpbal);\n    }\n    for (int i = 0; i < -bal; ++i) {\n      printf(\"(\");\n    }\n    for (int i = 0; i < n; ++i) {\n      printf(\"%c\", s[(i + best.second) % n]);\n    }\n    printf(\"\\n\");\n    return 0;\n  }\n  bool can[MAXN];\n  memset(can, 0, sizeof can);\n  int nowbal = 0;\n  int nowmin = 0;\n  for (int i = n - 1; i >= 0; --i) {\n    if (nowbal <= nowmin) {\n      can[i] = true;\n    }\n    if (s[i] == ')') {\n      ++nowbal;\n    } else {\n      --nowbal;\n    }\n    nowmin = min(nowmin, nowbal);\n  }\n  int tmpbal = 0;\n  pair<int, int> best = make_pair(1e9 + 9, -1);\n  for (int i = 0; i < n; ++i) {\n    if ((tmpbal - bottom <= bal && can[i]) || tmpbal == bottom) {\n      best = min(best, make_pair(classes[i], i));\n    }\n    if (s[i] == '(') {\n      ++tmpbal;\n    } else {\n      --tmpbal;\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    printf(\"%c\", s[(i + best.second) % n]);\n  }\n  for (int i = 0; i < bal; ++i) {\n    printf(\")\");\n  }\n  printf(\"\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = (int)2e9;\nconst long long INFL = (long long)9e18;\nconst int MAXINT = ((~0) ^ (1 << 31));\nconst long long MAXLL = ((~0) ^ ((long long)1 << 63));\ntemplate <class T>\ninline T pow2(T a) {\n  return a * a;\n}\ntemplate <class T>\ninline bool mineq(T& a, T b) {\n  return (a > b) ? (a = b, true) : false;\n}\ntemplate <class T>\ninline bool maxeq(T& a, T b) {\n  return (a < b) ? (a = b, true) : false;\n}\nconst int maxn = (int)2e6 + 10;\n;\nconst int MOD = (int)1e9 + 7;\n;\nlong long hash1[maxn], hash2[maxn], p1[maxn], p2[maxn], rp1[maxn], rp2[maxn],\n    a[maxn];\nbool valid[maxn];\nlong long n;\nstring str;\nlong long powmod(long long a, long long b) {\n  if (!b) return 1;\n  long long t = powmod(a, b / 2);\n  t = (t * t) % MOD;\n  if (b & 1) t = (t * a) % MOD;\n  return t;\n}\nvoid pre() {\n  p1[0] = p2[0] = rp1[0] = rp2[0] = 1;\n  hash1[0] = hash2[0] = str[0];\n  for (int i = 1; i < (int)(str.size()); i++) {\n    p1[i] = (p1[i - 1] * 31) % MOD;\n    rp1[i] = powmod(p1[i], MOD - 2);\n    p2[i] = (p2[i - 1] * 61) % MOD;\n    rp2[i] = powmod(p2[i], MOD - 2);\n    hash1[i] = (hash1[i - 1] + p1[i] * str[i]) % MOD;\n    hash2[i] = (hash2[i - 1] + p2[i] * str[i]) % MOD;\n  }\n}\ninline long long gethash(int l, int r, long long hash[maxn],\n                         long long rp[maxn]) {\n  long long pr = (l ? hash[l - 1] : 0);\n  return ((hash[r] - pr + MOD) * rp[l]) % MOD;\n}\ninline pair<long long, long long> gethash(int l, int r) {\n  return make_pair(gethash(l, r, hash1, rp1), gethash(l, r, hash2, rp2));\n}\ninline bool cmp(int a, int b) {\n  int l = 0, r = n - 1, mid = -1, ans = -1;\n  if (b == -1) return true;\n  while (l <= r) {\n    mid = (l + r) / 2;\n    if (gethash(a, a + mid) == gethash(b, b + mid)) {\n      l = mid + 1;\n      ans = mid;\n    } else {\n      r = mid - 1;\n    }\n  }\n  if (a + ans + 1 == (int)str.size() || b + ans + 1 == (int)str.size())\n    return false;\n  return str[a + ans + 1] < str[b + ans + 1];\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> str;\n  n = str.size();\n  str += str;\n  pre();\n  int ans = -1, open = 0, close = 0, dif = 0;\n  multiset<int> st;\n  for (int i = 0; i < (int)(n); i++) {\n    if (str[i] == '(')\n      open++;\n    else\n      close++;\n    a[i] = open - close;\n  }\n  for (int i = 0; i < (int)(2 * n); i++) {\n    if (str[i] == '(')\n      dif++;\n    else\n      dif--;\n    st.insert(dif);\n    if (i >= n) st.erase(st.find(a[i - n]));\n    if (i >= n - 1) {\n      long long pr = (i == n - 1 ? 0 : a[i - n]);\n      if (*st.begin() - pr >= 0) valid[i - n + 1] = true;\n      if (open < close && *st.begin() - pr >= open - close)\n        valid[i - n + 1] = true;\n    }\n  }\n  for (int i = 0; i < (int)(n); i++) {\n    if (valid[i] && cmp(i, ans)) ans = i;\n  }\n  cerr << \"* \" << ans << endl;\n  if (open < close) {\n    for (int i = 0; i < (int)(close - open); i++) cout << '(';\n  }\n  for (int i = ans; i < (int)(ans + n); i++) cout << str[i];\n  if (open > close) {\n    for (int i = 0; i < (int)(open - close); i++) cout << ')';\n  }\n  cerr << open << \" \" << close << endl;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class C>\nvoid mini(C& a4, C b4) {\n  a4 = min(a4, b4);\n}\ntemplate <class C>\nvoid maxi(C& a4, C b4) {\n  a4 = max(a4, b4);\n}\ntemplate <class T1, class T2>\nostream& operator<<(ostream& out, pair<T1, T2> pair) {\n  return out << \"(\" << pair.first << \", \" << pair.second << \")\";\n}\ntemplate <class A, class B, class C>\nstruct Triple {\n  A first;\n  B second;\n  C third;\n};\ntemplate <class T>\nvoid ResizeVec(T&, vector<long long>) {}\ntemplate <class T>\nvoid ResizeVec(vector<T>& vec, vector<long long> sz) {\n  vec.resize(sz[0]);\n  sz.erase(sz.begin());\n  if (sz.empty()) {\n    return;\n  }\n  for (T& v : vec) {\n    ResizeVec(v, sz);\n  }\n}\ninline bool leq(long long a1, long long a2, long long b1, long long b2) {\n  return (a1 < b1 || a1 == b1 && a2 <= b2);\n}\ninline bool leq(long long a1, long long a2, long long a3, long long b1,\n                long long b2, long long b3) {\n  return (a1 < b1 || a1 == b1 && leq(a2, a3, b2, b3));\n}\nstatic void radixPass(long long* a, long long* b, long long* r, long long n,\n                      long long K) {\n  long long* c = new long long[K + 1];\n  for (long long i = 0; i <= K; i++) c[i] = 0;\n  for (long long i = 0; i < n; i++) c[r[a[i]]]++;\n  for (long long i = 0, sum = 0; i <= K; i++) {\n    long long t = c[i];\n    c[i] = sum;\n    sum += t;\n  }\n  for (long long i = 0; i < n; i++) b[c[r[a[i]]]++] = a[i];\n  delete[] c;\n}\nvoid suffixArray(long long* s, long long* SA, long long n, long long K) {\n  long long n0 = (n + 2) / 3, n1 = (n + 1) / 3, n2 = n / 3, n02 = n0 + n2;\n  long long* s12 = new long long[n02 + 3];\n  s12[n02] = s12[n02 + 1] = s12[n02 + 2] = 0;\n  long long* SA12 = new long long[n02 + 3];\n  SA12[n02] = SA12[n02 + 1] = SA12[n02 + 2] = 0;\n  long long* s0 = new long long[n0];\n  long long* SA0 = new long long[n0];\n  for (long long i = 0, j = 0; i < n + (n0 - n1); i++)\n    if (i % 3 != 0) s12[j++] = i;\n  radixPass(s12, SA12, s + 2, n02, K);\n  radixPass(SA12, s12, s + 1, n02, K);\n  radixPass(s12, SA12, s, n02, K);\n  long long name = 0, c0 = -1, c1 = -1, c2 = -1;\n  for (long long i = 0; i < n02; i++) {\n    if (s[SA12[i]] != c0 || s[SA12[i] + 1] != c1 || s[SA12[i] + 2] != c2) {\n      name++;\n      c0 = s[SA12[i]];\n      c1 = s[SA12[i] + 1];\n      c2 = s[SA12[i] + 2];\n    }\n    if (SA12[i] % 3 == 1)\n      s12[SA12[i] / 3] = name;\n    else\n      s12[SA12[i] / 3 + n0] = name;\n  }\n  if (name < n02) {\n    suffixArray(s12, SA12, n02, name);\n    for (long long i = 0; i < n02; i++) s12[SA12[i]] = i + 1;\n  } else\n    for (long long i = 0; i < n02; i++) SA12[s12[i] - 1] = i;\n  for (long long i = 0, j = 0; i < n02; i++)\n    if (SA12[i] < n0) s0[j++] = 3 * SA12[i];\n  radixPass(s0, SA0, s, n0, K);\n  for (long long p = 0, t = n0 - n1, k = 0; k < n; k++) {\n    long long i = (SA12[t] < n0 ? SA12[t] * 3 + 1 : (SA12[t] - n0) * 3 + 2);\n    long long j = SA0[p];\n    if (SA12[t] < n0 ? leq(s[i], s12[SA12[t] + n0], s[j], s12[j / 3])\n                     : leq(s[i], s[i + 1], s12[SA12[t] - n0 + 1], s[j],\n                           s[j + 1], s12[j / 3 + n0])) {\n      SA[k] = i;\n      t++;\n      if (t == n02)\n        for (k++; p < n0; p++, k++) SA[k] = SA0[p];\n    } else {\n      SA[k] = j;\n      p++;\n      if (p == n0)\n        for (k++; t < n02; t++, k++)\n          SA[k] = (SA12[t] < n0 ? SA12[t] * 3 + 1 : (SA12[t] - n0) * 3 + 2);\n    }\n  }\n  delete[] s12;\n  delete[] SA12;\n  delete[] SA0;\n  delete[] s0;\n}\nconst long long N = 2e6 + 5;\nlong long s[N];\nlong long SA[N];\nvector<long long> MinK(vector<long long> vec, long long k) {\n  vector<long long> res;\n  long long n = ((long long)(vec).size());\n  if (n - k + 1 <= 0) {\n    return vector<long long>();\n  }\n  res.resize(n - k + 1);\n  vector<long long> que;\n  long long beg;\n  for (long long i = 0; i < ((long long)(vec).size()); i++) {\n    while (!que.empty() && vec[que.back()] >= vec[i]) {\n      que.pop_back();\n    }\n    que.push_back(i);\n    beg = min(beg, ((long long)(que).size()) - 1);\n    if (que[beg] <= i - k) {\n      beg++;\n    }\n    if (i >= k - 1) {\n      res[i - k + 1] = vec[que[beg]];\n    }\n  }\n  for (long long i = (1); i <= (k - 1); ++i) {\n    res.push_back(N);\n  }\n  return res;\n}\nlong long SAinv[N];\nint main() {\n  ios_base::sync_with_stdio(0);\n  string br;\n  cin >> br;\n  ;\n  long long n = ((long long)(br).size());\n  br = ' ' + br;\n  for (long long i = (1); i <= (n); ++i) {\n    if (br[i] == '(') {\n      s[i] = 1;\n    } else {\n      s[i] = 2;\n    }\n  }\n  vector<long long> bilv(2 * n + 5);\n  bilv.push_back(0);\n  for (long long i = (n + 1); i <= (2 * n); ++i) {\n    s[i] = s[i - n];\n    br += br[i - n];\n  }\n  long long b = 0;\n  for (long long i = (1); i <= (2 * n); ++i) {\n    if (s[i] == 1) {\n      b++;\n    } else {\n      b--;\n    }\n    bilv[i] = b;\n  }\n  long long bil = bilv[n];\n  suffixArray(s + 1, SA + 1, 2 * n, 2);\n  for (long long i = (1); i <= (2 * n); ++i) {\n    SAinv[SA[i] + 1] = i;\n  }\n  vector<long long> mins = MinK(bilv, n);\n  ;\n  ;\n  ;\n  long long best = 0;\n  SAinv[0] = N;\n  for (long long i = (0); i <= (n - 1); ++i) {\n    if (mins[i + 1] >= bilv[i] + min(0ll, bil)) {\n      if (SAinv[i + 1] < SAinv[best]) {\n        ;\n        best = i + 1;\n      }\n    }\n  }\n  if (bil < 0) {\n    for (long long i = (1); i <= (-bil); ++i) {\n      putchar('(');\n    }\n  }\n  for (long long i = (best); i <= (best + n - 1); ++i) {\n    putchar(br[i]);\n  }\n  if (bil >= 0) {\n    for (long long i = (1); i <= (bil); ++i) {\n      putchar(')');\n    }\n  }\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 3;\nconst int M = 4e6 + 3;\nconst int oo = 1e9;\nconst int OS = 317;\nconst int MOD = 1e9 + 7;\nchar s[N];\nint n, stp[M], p1[N], p2[N], s1[N], s2[N], ho[N], hz[N], h[N];\nvector<int> st;\nint get(int i, int ln) {\n  int op, zp, zs, os, il, ir, ans, l1, l, r, ym;\n  op = p2[i];\n  zp = i - p1[i] - op;\n  zs = s2[i + 1];\n  os = n - i - s1[i + 1] - zs;\n  il = zs;\n  ir = op;\n  if (os > zp)\n    ir += os - zp;\n  else\n    il += zp - os;\n  l1 = min(il, ln);\n  ym = 2 * n;\n  ans = (stp[ym] * 1LL * ho[l1]) % MOD;\n  if (ln - l1 > 0) {\n    l = i + 1;\n    r = l + min(n - i, ln - l1) - 1;\n    ans = (ans + (((h[r] - h[l - 1]) % MOD + MOD) % MOD) * 1LL *\n                     stp[ym + l1 - (l - 1)] % MOD) %\n          MOD;\n    l1 += r - l + 1;\n    if (ln - l1 > 0) {\n      r = min(i, ln - l1);\n      ans = (ans + h[r] * 1LL * stp[ym + l1] % MOD) % MOD;\n      l1 += r;\n      if (ln - l1 > 0) {\n        r = ln - l1;\n        ans = (ans + hz[r] * 1LL * stp[ym + l1] % MOD) % MOD;\n      }\n    }\n  }\n  return ans;\n}\nint get_ch(int i, int ln) {\n  int op, zp, zs, os, il, ir;\n  op = p2[i];\n  zp = i - p1[i] - op;\n  zs = s2[i + 1];\n  os = n - i - s1[i + 1] - zs;\n  il = zs;\n  ir = op;\n  if (os > zp)\n    ir += os - zp;\n  else\n    il += zp - os;\n  if (ln <= il) return '(';\n  ln -= il;\n  if (ln <= n - i) return s[i + ln];\n  ln -= n - i;\n  if (ln <= i)\n    return s[ln];\n  else\n    return ')';\n}\nint ans;\nbool cmp(int i, int j) {\n  int l, r, x;\n  l = 1, r = ans;\n  while (l <= r) {\n    x = (l + r) >> 1;\n    if (get(i, x) == get(j, x))\n      l = x + 1;\n    else\n      r = x - 1;\n  }\n  if (r + 1 > ans) return true;\n  return get_ch(i, r + 1) <= get_ch(j, r + 1);\n}\nint main() {\n  if (0) {\n    freopen(\"input.txt\", \"w\", stdout);\n    int n = 1e6;\n    for (int i = 0; i < n; ++i) printf(\"(\");\n    printf(\"\\n\");\n    return 0;\n  }\n  int i, j, op, zp, zs, os, len, mn;\n  gets(s + 1);\n  n = strlen(s + 1);\n  for (i = 1; i <= n; ++i)\n    if (s[i] == '(')\n      p1[i] = p1[i - 1], p2[i] = p2[i - 1] + 1;\n    else if (p2[i - 1])\n      p1[i] = p1[i - 1] + 2, p2[i] = p2[i - 1] - 1;\n    else\n      p1[i] = p1[i - 1], p2[i] = p2[i - 1];\n  for (i = n; i; --i)\n    if (s[i] == ')')\n      s1[i] = s1[i + 1], s2[i] = s2[i + 1] + 1;\n    else if (s2[i + 1])\n      s1[i] = s1[i + 1] + 2, s2[i] = s2[i + 1] - 1;\n    else\n      s1[i] = s1[i + 1], s2[i] = s2[i + 1];\n  ans = oo;\n  for (i = 0; i < n; ++i) {\n    op = p2[i];\n    zp = i - p1[i] - op;\n    zs = s2[i + 1];\n    os = n - i - s1[i + 1] - zs;\n    len = n + zs + op + max(os, zp) - min(os, zp);\n    if (ans > len) st.clear();\n    if (ans >= len) ans = len, st.push_back(i);\n  }\n  stp[0] = 1;\n  for (i = 1; i < M; ++i) stp[i] = (stp[i - 1] * 1LL * OS) % MOD;\n  ho[0] = hz[0] = 0;\n  for (i = 1; i < N; ++i)\n    ho[i] = (ho[i - 1] + '(' * 1LL * stp[i - 1] % MOD) % MOD;\n  for (i = 1; i < N; ++i)\n    hz[i] = (hz[i - 1] + ')' * 1LL * stp[i - 1] % MOD) % MOD;\n  h[0] = 0;\n  for (i = 1; i <= n; ++i)\n    h[i] = (h[i - 1] + s[i] * 1LL * stp[i - 1] % MOD) % MOD;\n  mn = st[0];\n  for (i = 1; i < (int)st.size(); ++i)\n    if (cmp(st[i], mn)) mn = st[i];\n  i = mn;\n  int il, ir;\n  op = p2[i];\n  zp = i - p1[i] - op;\n  zs = s2[i + 1];\n  os = n - i - s1[i + 1] - zs;\n  il = zs;\n  ir = op;\n  if (os > zp)\n    ir += os - zp;\n  else\n    il += zp - os;\n  for (j = 0; j < il; ++j) putchar('(');\n  for (j = i + 1; j <= n; ++j) putchar(s[j]);\n  for (j = 1; j <= i; ++j) putchar(s[j]);\n  for (j = 0; j < ir; ++j) putchar(')');\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nchar s[2000005], t[1000005];\nint n;\nint bal[2000005];\nint ord[1000005], c[1000005], nord[1000005], nc[1000005];\nint cnt[1000005];\nstack<int> st;\nbool mt[2000005];\nint main() {\n  scanf(\"%s\", s);\n  n = strlen(s);\n  for (int i = 0; i < (int)(2); ++i) cnt[i] = 0;\n  for (int i = 0; i < (int)(n); ++i) ++cnt[s[i] == '(' ? 0 : 1];\n  for (int i = 0; i < (int)(1); ++i) cnt[i + 1] += cnt[i];\n  for (int i = 0; i < (int)(n); ++i) ord[--cnt[s[i] == '(' ? 0 : 1]] = i;\n  c[ord[0]] = 0;\n  int cpos = 0;\n  for (int i = 1; i < n; ++i) {\n    if (s[ord[i - 1]] != s[ord[i]]) ++cpos;\n    c[ord[i]] = cpos;\n  }\n  for (int sz = 1; sz < n; sz <<= 1) {\n    for (int i = 0; i < (int)(n); ++i) {\n      nord[i] = ord[i] - sz;\n      if (nord[i] < 0) nord[i] += n;\n    }\n    for (int i = 0; i < (int)(n); ++i) cnt[i] = 0;\n    for (int i = 0; i < (int)(n); ++i) ++cnt[c[nord[i]]];\n    for (int i = 0; i < (int)(n - 1); ++i) cnt[i + 1] += cnt[i];\n    for (int i = n - 1; i >= 0; --i) ord[--cnt[c[nord[i]]]] = nord[i];\n    nc[ord[0]] = 0;\n    cpos = 0;\n    for (int i = 1; i < n; ++i) {\n      int mid1 = ord[i - 1] + sz, mid2 = ord[i] + sz;\n      if (mid1 >= n) mid1 -= n;\n      if (mid2 >= n) mid2 -= n;\n      if (c[ord[i - 1]] != c[ord[i]] || c[mid1] != c[mid2]) ++cpos;\n      nc[ord[i]] = cpos;\n    }\n    for (int i = 0; i < (int)(n); ++i) c[i] = nc[i];\n  }\n  for (int i = 0; i < (int)(n); ++i) s[n + i] = s[i];\n  int N = n << 1;\n  int mx = 0, cbal = 0;\n  for (int i = 0; i < (int)(N); ++i) {\n    if (s[i] == '(')\n      st.push(i);\n    else if (!st.empty()) {\n      ++cbal;\n      mt[st.top()] = true;\n      st.pop();\n    }\n    if (i >= n && mt[i - n]) --cbal;\n    bal[i] = cbal;\n    mx = max(mx, cbal);\n  }\n  int best = -1;\n  for (int i = 0; i < (int)(n); ++i)\n    if (bal[ord[i] - 1 + n] == mx) {\n      best = ord[i];\n      break;\n    }\n  int cur = 0, cnt = 0;\n  for (int i = best; i < best + n; ++i) {\n    int pos = i % n;\n    cur += s[pos] == '(' ? 1 : -1;\n    if (cur < 0) ++cur, ++cnt;\n  }\n  while (cnt > 0) printf(\"(\"), --cnt;\n  for (int i = best; i < best + n; ++i) {\n    int pos = i % n;\n    printf(\"%c\", s[pos]);\n  }\n  while (cur > 0) printf(\")\"), --cur;\n  printf(\"\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nclass SA_IS {\n  vector<int> compress(vector<int>& v) {\n    set<int> alph(v.begin(), v.end());\n    vector<int> dic(alph.begin(), alph.end());\n    vector<int> bucket_size(dic.size(), 0);\n    for (int i = 0; i < v.size(); i++) {\n      v[i] = lower_bound(dic.begin(), dic.end(), v[i]) - dic.begin();\n      bucket_size[v[i]]++;\n    }\n    return bucket_size;\n  }\n\n public:\n  static const int L = 0;\n  static const int S = 1;\n  string my_s;\n  vector<int> sa;\n  vector<int> lcp;\n  struct substring {\n    int pos;\n    int size;\n    vector<int>::iterator str;\n    vector<int>::iterator ls;\n    substring() {}\n    substring(const int pos, const int size, const vector<int>::iterator& str,\n              const vector<int>::iterator& ls) {\n      this->pos = pos;\n      this->size = size;\n      this->str = str;\n      this->ls = ls;\n    }\n    bool operator<(const substring& x) const {\n      for (int i = 0; i < min(this->size, x.size); i++) {\n        if (this->str[i] != x.str[i]) {\n          return this->str[i] < x.str[i];\n        } else if (this->ls[i] != x.ls[i]) {\n          return this->ls[i] == SA_IS::L;\n        }\n      }\n      return this->size < x.size;\n    }\n    bool operator==(const substring& x) const {\n      for (int i = 0; i < min(this->size, x.size); i++) {\n        if (this->str[i] != x.str[i]) {\n          return false;\n        } else if (this->ls[i] != x.ls[i]) {\n          return false;\n        }\n      }\n      return this->size == x.size;\n    }\n    substring operator=(const substring& x) {\n      this->pos = x.pos;\n      this->size = x.size;\n      this->str = x.str;\n      this->ls = x.ls;\n      return *this;\n    }\n  };\n  vector<int> rec(vector<int>& v) {\n    v.push_back(-1);\n    vector<int> bucket_size = compress(v);\n    vector<int> ret(v.size(), -1);\n    vector<vector<int>::iterator> bucket(bucket_size.size());\n    vector<bool> fixed(v.size(), false);\n    vector<vector<bool>::iterator> bucket_fixed(bucket_size.size());\n    vector<int> bucket_front(bucket_size.size());\n    vector<int> bucket_back(bucket_size.size());\n    vector<bool> used(v.size(), false);\n    {\n      int sum = 0;\n      for (int i = 0; i < bucket_size.size(); i++) {\n        bucket[i] = ret.begin() + sum;\n        bucket_fixed[i] = fixed.begin() + sum;\n        bucket_front[i] = 0;\n        bucket_back[i] = bucket_size[i] - 1;\n        sum += bucket_size[i];\n      }\n    }\n    vector<int> LS(v.size());\n    LS.back() = S;\n    for (int i = v.size() - 2; i >= 0; i--) {\n      if (v[i] < v[i + 1])\n        LS[i] = S;\n      else if (v[i] > v[i + 1])\n        LS[i] = L;\n      else\n        LS[i] = LS[i + 1];\n    }\n    vector<int> LMS;\n    for (int i = 1; i < v.size(); i++) {\n      if (LS[i] != S) continue;\n      if (LS[i - 1] == L) LMS.push_back(i);\n    }\n    LMS.push_back(v.size() - 1);\n    vector<pair<substring, int>> LMS_substring;\n    for (int i = 0; i < LMS.size() - 1; i++) {\n      substring sub(LMS[i], LMS[i + 1] - LMS[i] + 1, v.begin() + LMS[i],\n                    LS.begin() + LMS[i]);\n      LMS_substring.push_back({sub, LMS_substring.size()});\n    }\n    if (LMS_substring.size() > 0) {\n      vector<pair<substring, int>> LMS_substring_old = LMS_substring;\n      sort(LMS_substring.begin(), LMS_substring.end());\n      vector<int> LMS_order(LMS_substring.size());\n      int cnt = 0;\n      LMS_order[LMS_substring[0].second] = cnt;\n      cnt++;\n      for (int i = 1; i < LMS_substring.size(); i++) {\n        if (LMS_substring[i].first == LMS_substring[i - 1].first) {\n          LMS_order[LMS_substring[i].second] = cnt - 1;\n        } else {\n          LMS_order[LMS_substring[i].second] = cnt;\n          cnt++;\n        }\n      }\n      if (cnt != LMS_substring.size()) {\n        vector<int> new_order = rec(LMS_order);\n        LMS_order = vector<int>(new_order.begin() + 1, new_order.end());\n        for (int i = 0; i < LMS_substring.size(); i++) {\n          LMS_substring[i].first = LMS_substring_old[LMS_order[i]].first;\n        }\n      }\n      for (int i = LMS_substring.size() - 1; i >= 0; i--) {\n        int c = v[LMS_substring[i].first.pos];\n        bucket[c][bucket_back[c]] = LMS_substring[i].first.pos;\n        bucket_back[c]--;\n      }\n    }\n    for (int i = 0; i < bucket_size.size(); i++) {\n      for (int j = 0; j < bucket_size[i]; j++) {\n        if (bucket[i][j] - 1 < 0) continue;\n        if (LS[bucket[i][j] - 1] == L) {\n          if (used[bucket[i][j] - 1]) continue;\n          used[bucket[i][j] - 1] = true;\n          int c = v[bucket[i][j] - 1];\n          bucket[c][bucket_front[c]] = bucket[i][j] - 1;\n          bucket_fixed[c][bucket_front[c]] = true;\n          bucket_front[c]++;\n        }\n      }\n      bucket_back[i] = bucket_size[i] - 1;\n    }\n    for (int i = 0; i < v.size(); i++) {\n      if (fixed[i] == false) {\n        ret[i] = -1;\n      }\n    }\n    for (int i = bucket_size.size() - 1; i >= 0; i--) {\n      for (int j = bucket_size[i] - 1; j >= 0; j--) {\n        if (bucket[i][j] - 1 < 0) continue;\n        if (LS[bucket[i][j] - 1] == S) {\n          if (used[bucket[i][j] - 1]) continue;\n          used[bucket[i][j] - 1] = true;\n          int c = v[bucket[i][j] - 1];\n          bucket[c][bucket_back[c]] = bucket[i][j] - 1;\n          bucket_fixed[c][bucket_back[c]] = true;\n          bucket_back[c]--;\n        }\n      }\n    }\n    ret[0] = ret.size() - 1;\n    return ret;\n  }\n  vector<int> rec(string& s) {\n    vector<int> v(s.begin(), s.end());\n    return rec(v);\n  }\n  void constract_lcp() {\n    int n = my_s.size();\n    lcp.resize(n + 1);\n    vector<int> rank(n + 1);\n    for (int i = 0; i <= n; i++) rank[sa[i]] = i;\n    int h = 0;\n    lcp[0] = 0;\n    for (int i = 0; i < n; i++) {\n      int j = sa[rank[i] - 1];\n      if (h > 0) h--;\n      for (; j + h < n && i + h < n; h++) {\n        if (my_s[j + h] != my_s[i + h]) break;\n      }\n      lcp[rank[i] - 1] = h;\n    }\n  }\n  SA_IS(string s) {\n    my_s = s;\n    sa = rec(s);\n  }\n  void dbg_print() {\n    for (int i = 0; i <= my_s.size(); i++) {\n      string p(my_s.begin() + sa[i], my_s.end());\n      cerr << p << \" \" << sa[i] << endl;\n    }\n  }\n};\nclass SegmentTreeMIN {\n  int n;\n  vector<int> T;\n  int INF;\n\n public:\n  SegmentTreeMIN(int size) {\n    INF = 1 << 29;\n    n = 1;\n    while (n < size) n <<= 1;\n    T.resize(2 * n - 1);\n    fill(T.begin(), T.end(), INF);\n  }\n  void update(int k, int val) {\n    k += n - 1;\n    T[k] = val;\n    while (k > 0) {\n      k = (k - 1) / 2;\n      T[k] = min(T[k * 2 + 1], T[k * 2 + 2]);\n    }\n  }\n  int RMQ(int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) return INF;\n    if (a <= l && r <= b)\n      return T[k];\n    else {\n      int val_left = RMQ(a, b, k * 2 + 1, l, (l + r) / 2);\n      int val_right = RMQ(a, b, k * 2 + 2, (l + r) / 2, r);\n      return min(val_left, val_right);\n    }\n  }\n  int size() { return n; }\n};\nint main() {\n  string s;\n  cin >> s;\n  int n = s.size();\n  s += s;\n  SA_IS sa(s);\n  vector<int> arr(2 * n);\n  for (int i = 0; i < 2 * n; i++) {\n    if (s[i] == '(') {\n      arr[i] = 1;\n    } else {\n      arr[i] = -1;\n    }\n    if (i > 0) arr[i] += arr[i - 1];\n  }\n  SegmentTreeMIN seg(2 * n);\n  for (int i = 0; i < 2 * n; i++) {\n    seg.update(i, arr[i]);\n  }\n  int index = -1;\n  int len = 1 << 30;\n  int xx = 0;\n  int yy = 0;\n  for (int i = 0; i < 2 * n; i++) {\n    if (sa.sa[i] > n) continue;\n    int x = min(0, seg.RMQ(sa.sa[i], sa.sa[i] + n, 0, 0, seg.size()) -\n                       (sa.sa[i] > 0 ? arr[sa.sa[i] - 1] : 0));\n    int y = max(0, arr[sa.sa[i] + n - 1] -\n                       (sa.sa[i] > 0 ? arr[sa.sa[i] - 1] : 0) + abs(x));\n    if (len > abs(x) + abs(y) + n) {\n      index = i;\n      len = abs(x) + abs(y) + n;\n      xx = abs(x);\n      yy = abs(y);\n    }\n  }\n  string ans;\n  for (int j = 0; j < xx; j++) {\n    printf(\"(\");\n  }\n  cout << s.substr(sa.sa[index], n);\n  for (int j = 0; j < yy; j++) {\n    printf(\")\");\n  }\n  printf(\"\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 4000010;\ninline int read() {\n  int x = 0;\n  int f = 0, c = getchar();\n  for (; c > '9' || c < '0'; f = c == '-', c = getchar())\n    ;\n  for (; c >= '0' && c <= '9'; c = getchar()) x = (x << 3) + (x << 1) + c - '0';\n  return f ? -x : x;\n}\nstruct cqz {\n  int i, x, y;\n  cqz(int a = 0, int b = 0, int c = 0) {\n    i = a;\n    x = b;\n    y = c;\n  }\n} a[N];\ninline bool operator<(const cqz& i, const cqz& j) {\n  return i.x < j.x || (i.x == j.x && i.y < j.y);\n}\ninline bool operator!=(const cqz& i, const cqz& j) {\n  return i.x != j.x || i.y != j.y;\n}\nchar s[N];\nint sta[N], top, p[N];\nint n, m, rk[N], sm, sl, sr, ans, flag;\nint main() {\n  scanf(\"%s\", s + 1);\n  n = strlen(s + 1);\n  m = n;\n  register int i, j, k;\n  for (i = 1; i <= n; i++) s[i + n] = s[i];\n  n = n + n;\n  for (i = 1; i <= n; i++) rk[i] = s[i];\n  for (k = 1; k < n; k <<= 1) {\n    for (i = 1; i <= n; i++) a[i] = cqz(i, rk[i], rk[i + k]);\n    sort(a + 1, a + n + 1);\n    for (i = j = 1; i <= n; i++) rk[a[i].i] = j, j += a[i + 1] != a[i];\n  }\n  for (i = n - 1; i > m; i--)\n    if (s[i] == '(') {\n      if (sl)\n        sm++, sl--;\n      else\n        sr++;\n    } else\n      sl++;\n  k = n + n;\n  for (i = 1; i <= n; i++)\n    if (s[i] == '(')\n      sta[++top] = i;\n    else {\n      p[i] = sta[top];\n      if (top) top--;\n    }\n  for (i = m; i; i--) {\n    if (s[i] == '(') {\n      if (sl)\n        sm++, sl--;\n      else\n        sr++;\n    } else\n      sl++;\n    if (!sl || !sr) {\n      flag = sl - sr;\n      if (rk[i] < k) ans = i, k = rk[i];\n    }\n    if (s[i + m - 1] == '(')\n      sr--;\n    else {\n      if (p[i + m - 1] > i)\n        sm--, sr++;\n      else\n        sl--;\n    }\n  }\n  if (flag > 0)\n    while (flag) putchar('('), flag--;\n  for (i = 0; i < m; i++) putchar(s[ans + i]);\n  if (flag < 0)\n    while (flag++) putchar(')');\n  puts(\"\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst long double PI = acos(-1.0);\nconst int MAXN = 2000001;\nconst int LG = 21;\nchar s[MAXN];\nint n;\nint a[MAXN];\nint pref[MAXN];\nint suf[MAXN];\npair<int, int> pp[MAXN];\nint p[MAXN];\nint c[MAXN][LG];\nint as1[MAXN];\nint as2[MAXN];\ninline int get_bal(int x) { return min(suf[x] - a[x], a[n] - a[x] + pref[x]); }\nint main() {\n  scanf(\"%s\", s);\n  n = strlen(s);\n  if (n == 1) {\n    cout << \"()\" << endl;\n    return 0;\n  }\n  a[0] = 0;\n  int adb = 0;\n  pref[0] = 0;\n  for (int i = 0; i < n; i++) {\n    if (s[i] == '(')\n      a[i + 1] = a[i] + 1, adb++;\n    else\n      a[i + 1] = a[i] - 1, adb--;\n    pref[i + 1] = min(pref[i], a[i + 1]);\n  }\n  suf[n] = a[n];\n  for (int i = n - 1; i >= 0; i--) suf[i] = min(suf[i + 1], a[i]);\n  int s0 = 0, s1 = n - 1;\n  for (int i = 0; i < n; i++) {\n    if (s[i] == '(')\n      c[i][0] = 0, as1[s0++] = i;\n    else\n      c[i][0] = 1, as1[s1--] = i;\n  }\n  for (int j = 1; j < LG; j++) {\n    int pi = (1 << (j - 1));\n    for (int i = 0; i < n; i++) {\n      pp[i] = make_pair(c[i][j - 1], c[pi][j - 1]);\n      as1[i] -= (1 << (j - 1)) % n;\n      if (as1[i] < 0) as1[i] += n;\n      pi++;\n      if (pi == n) pi = 0;\n    }\n    for (int i = 0; i < n; i++) p[i] = 0;\n    for (int i = 0; i < n; i++) {\n      p[pp[as1[i]].first]++;\n    }\n    for (int i = 1; i < n; i++) p[i] += p[i - 1];\n    for (int i = n - 1; i >= 0; i--) {\n      as2[--p[pp[as1[i]].first]] = as1[i];\n    }\n    for (int i = 0; i < n; i++) as1[i] = as2[i];\n    int cur = 0;\n    for (int i = 0; i < n; i++) {\n      if ((i != 0) && (pp[as1[i]] != pp[as1[i - 1]])) cur++;\n      c[as1[i]][j] = cur;\n    }\n  }\n  int bb = -n - 1, bc = n * 2, bid = -1;\n  for (int i = 0; i < n; i++) {\n    int nb = get_bal(i);\n    if (make_pair(nb, -c[i][LG - 1]) > make_pair(bb, -bc))\n      bb = nb, bc = c[i][LG - 1], bid = i;\n  }\n  int ad = -get_bal(bid);\n  for (int i = 0; i < ad; i++) printf(\"(\");\n  adb += ad;\n  for (int i = 0; i < n; i++) printf(\"%c\", s[(i + bid) % n]);\n  for (int i = 0; i < adb; i++) printf(\")\");\n  printf(\"\\n\");\n  return 0;\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1000005, mo[2] = {(int)1e9 + 7, (int)1e9 + 9}, inf = 0x7fffffff;\nint n;\nchar s[N * 2];\nint pw[N * 2][2];\nint h[N * 2][2];\nint sum[N], a[N], b[N];\nint calc(const int x, const int len, const int f) {\n  return (h[x][f] + 1LL * (mo[f] - pw[len][f]) * h[x + len][f]) % mo[f];\n}\nint lcp(const int x, const int y) {\n  int l = 0, r = n + 1;\n  while (r - l > 1) {\n    int mid = l + r >> 1;\n    if (calc(x, mid, 0) == calc(y, mid, 0) &&\n        calc(x, mid, 1) == calc(y, mid, 1))\n      l = mid;\n    else\n      r = mid;\n  }\n  return l;\n}\nbool cmp(const int x, const int y) {\n  int t = lcp(x, y);\n  return s[x + t] < s[y + t];\n}\nint main() {\n  scanf(\"%s\", s);\n  n = strlen(s);\n  for (int i = 0; i < n; i++) sum[i + 1] = sum[i] + (s[i] == '(' ? 1 : -1);\n  for (int i = 0; i < n; i++) s[i + n] = s[i];\n  pw[0][0] = pw[0][1] = 1;\n  for (int i = 1; i <= n * 2; i++)\n    pw[i][0] = 3LL * pw[i - 1][0] % mo[0],\n    pw[i][1] = 3LL * pw[i - 1][1] % mo[1];\n  for (int i = n * 2 - 1; i >= 0; i--)\n    h[i][0] = ((s[i] == '(' ? 1 : 2) + 3LL * h[i + 1][0]) % mo[0],\n    h[i][1] = ((s[i] == '(' ? 1 : 2) + 3LL * h[i + 1][1]) % mo[1];\n  a[n] = inf;\n  for (int i = n - 1; i >= 0; i--) a[i] = min(sum[i + 1], a[i + 1]);\n  b[0] = inf;\n  for (int i = 1; i <= n; i++) b[i] = min(sum[i] + sum[n], b[i - 1]);\n  int ans = -1;\n  for (int i = 0; i < n; i++)\n    if (min(0, min(a[i], b[i]) - sum[i]) == min(0, sum[n])) {\n      if (ans == -1 || cmp(i, ans)) ans = i;\n    }\n  for (int i = sum[n]; i < 0; i++) putchar('(');\n  for (int i = 0; i < n; i++) putchar(s[ans + i]);\n  for (int i = 0; i < sum[n]; i++) putchar(')');\n}\n"
        },
        {
            "language": 2,
            "solution": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  string inp;\n  cin >> inp;\n  int n = inp.length();\n  int lc = 0, rc = 0;\n  for (int i = 0; i < n; ++i) {\n    if (inp[i] == ')')\n      rc++;\n    else\n      lc++;\n  }\n  if (lc == 0 || rc == 0) {\n    for (int i = 0; i < n; ++i) cout << '(';\n    for (int i = 0; i < n; ++i) cout << ')';\n    cout << endl;\n  } else {\n    vector<int> match(n, -1);\n    deque<int> lopen;\n    queue<int> ropen;\n    for (int i = 0; i < n; ++i) {\n      if (inp[i] == '(')\n        lopen.push_back(i);\n      else if (!lopen.empty()) {\n        int j = lopen.back();\n        lopen.pop_back();\n        match[j] = i;\n        match[i] = j;\n      } else\n        ropen.push(i);\n    }\n    int um = (int)lopen.size() - (int)ropen.size();\n    int b = 0, nstp = 1;\n    for (int i = 1; i < n; ++i) {\n      int j = i - 1;\n      if (inp[j] == '(') {\n        if (match[j] != -1) {\n          match[match[j]] = -1;\n          match[j] = -1;\n        } else\n          lopen.pop_front();\n        lopen.push_back(j);\n      } else {\n        if (!lopen.empty()) {\n          int k = lopen.back();\n          lopen.pop_back();\n          match[k] = j;\n          match[j] = k;\n        }\n      }\n      if (inp[j] == ')' && inp[i] == '(' && nstp <= i) {\n        if ((um >= 0 && (int)lopen.size() == um) ||\n            (um < 0 && lopen.size() == 0)) {\n          if (b == 0 && um < 0 && ropen.size() + um > 0)\n            b = i;\n          else\n            for (int k = 0; k < n; ++k) {\n              if (inp[(i + k) % n] != inp[(b + k) % n]) {\n                nstp = i + k - 1;\n                if (inp[(i + k) % n] == '(') {\n                  b = i;\n                }\n                break;\n              }\n              if (k == n - 1) {\n                b = i;\n                nstp = i + k - 1;\n              }\n            }\n        }\n      }\n    }\n    if (um < 0)\n      for (int i = 0; i < abs(um); ++i) {\n        cout << '(';\n      }\n    for (int i = 0; i < n; ++i) cout << inp[(b + i) % n];\n    if (um > 0)\n      for (int i = 0; i < um; ++i) {\n        cout << ')';\n      }\n    cout << endl;\n  }\n  return 0;\n}\n"
        },
        {
            "language": 4,
            "solution": "import java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.math.BigInteger;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Vadim Semenov\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskF solver = new TaskF();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskF {\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        String sequence = in.next();\n        final int length = sequence.length();\n        int[] s = new int[length];\n        for (int i = 0; i < length; ++i) {\n            s[i] = sequence.charAt(i) - '(';\n        }\n        int[] suffixArray = buildSuffixArray(s);\n        int[] balance = new int[length * 2];\n        for (int i = 1; i < balance.length; ++i) {\n            balance[i] = balance[i - 1];\n            if (s[(i - 1) % length] == 0) {\n                balance[i]++;\n            } else {\n                balance[i]--;\n            }\n        }\n        int total = balance[length];\n        int opened = 0, closed = 0;\n        if (total > 0) {\n            closed = total;\n        } else {\n            opened = -total;\n        }\n        RMQ rmq = new RMQ(balance);\n        int best = -1;\n        for (int i : suffixArray) {\n            int offset = balance[i];\n            offset = opened - offset;\n            if (rmq.query(i + 1, i + 1 + length) + offset >= 0/* && balance[i + length] + offset == closed*/) {\n                best = i;\n                break;\n            }\n        }\n        for (int i = 0; i < opened; ++i) {\n            out.print('(');\n        }\n        out.print(sequence.substring(best, sequence.length()));\n        out.print(sequence.substring(0, best));\n        for (int i = 0; i < closed; ++i) {\n            out.print(')');\n        }\n        out.println();\n    }\n\n    private static class RMQ {\n        int[][] data;\n        int[] log;\n\n        RMQ(int[] initial) {\n            int length = initial.length;\n            log = new int[length + 1];\n            for (int i = 2; i <= length; ++i) {\n                log[i] = log[i >>> 1] + 1;\n            }\n            data = new int[log[length]][length];\n            System.arraycopy(initial, 0, data[0], 0, length);\n            for (int level = 1; level < log[length]; ++level) {\n                int len = 1 << (level - 1);\n                for (int i = 0; (i + len + len) <= length; ++i) {\n                    data[level][i] = Math.min(data[level - 1][i], data[level - 1][i + len]);\n                }\n            }\n        }\n\n        int query(int from, int to) {\n            int level = log[to - from];\n            return Math.min(data[level][from], data[level][to - (1 << level)]);\n        }\n    }\n\n    private int[] buildSuffixArray(int[] s) {\n        final int length = s.length;\n        int[] suffixArray = new int[length];\n        int[] bucket = new int[length];\n        int[] _suffixArray = new int[length];\n        int[] _bucket = new int[length];\n        int[] position = new int[Math.max(2, length)];\n        int buckets = 0;\n        {\n            for (int i : s) {\n                position[i]++;\n            }\n            int pos = 0;\n            for (int i = 0; i < position.length; ++i) {\n                int tmp = position[i];\n                position[i] = pos;\n                pos += tmp;\n            }\n            for (int i = 0; i < length; ++i) {\n                suffixArray[position[s[i]]++] = i;\n            }\n            position[0] = 0;\n            for (int i = 1; i < length; ++i) {\n                if (s[suffixArray[i]] != s[suffixArray[i - 1]]) {\n                    buckets++;\n                    position[buckets] = i;\n                }\n                bucket[suffixArray[i]] = buckets;\n            }\n        }\n        for (int part = 1; part < length; part <<= 1) {\n            for (int i = 0; i < length; ++i) {\n                int idx = (suffixArray[i] - part + length) % length;\n                _suffixArray[position[bucket[idx]]++] = idx;\n            }\n            buckets = 0;\n            position[0] = 0;\n            for (int i = 1; i < length; ++i) {\n                if (bucket[_suffixArray[i]] != bucket[_suffixArray[i - 1]] ||\n                        bucket[(_suffixArray[i] + part) % length] != bucket[(_suffixArray[i - 1] + part) % length]) {\n                    buckets++;\n                    position[buckets] = i;\n                }\n                _bucket[_suffixArray[i]] = buckets;\n            }\n            int[] swap = bucket; bucket = _bucket; _bucket = swap;\n            swap = suffixArray; suffixArray = _suffixArray; _suffixArray = swap;\n        }\n        return suffixArray;\n    }\n}\n\nclass InputReader {\n    private final BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    public InputReader(InputStream in) {\n        reader = new BufferedReader(new InputStreamReader(in));\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(readLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n    public String readLine() {\n        String line;\n        try {\n            line = reader.readLine();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        return line;\n    }\n}\n\n"
        },
        {
            "language": 4,
            "solution": "import java.io.*;\nimport java.util.*;\n\npublic class Buffering {\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\tboolean eof;\n\n\tint[] buildSuffixArray(int[] s, int alphSize) {\n\t\t// sorts cyclic shifs, append a sentinel to the end if suffix array is\n\t\t// needed\n\t\tint n = s.length;\n\t\tint[] cnt = new int[Math.max(alphSize, n)];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcnt[s[i]]++;\n\t\t}\n\t\tfor (int i = 1; i < alphSize; i++) {\n\t\t\tcnt[i] += cnt[i - 1];\n\t\t}\n\n\t\tint[] arr = new int[n];\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tarr[--cnt[s[i]]] = i;\n\t\t}\n\n\t\tint[] cls = new int[n];\n\t\tint nCl = 1;\n\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint curSuff = arr[i];\n\t\t\tif (s[curSuff] != s[arr[i - 1]]) {\n\t\t\t\tnCl++;\n\t\t\t}\n\t\t\tcls[curSuff] = nCl - 1;\n\t\t}\n\n\t\tint[] aux = new int[n];\n\n\t\tfor (int h = 1; h <= n; h <<= 1) {\n\n\t\t\t// aux - suffixes ordered by second halves\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint tmp = arr[i] - h;\n\t\t\t\tif (tmp < 0)\n\t\t\t\t\ttmp += n;\n\t\t\t\taux[i] = tmp;\n\t\t\t}\n\n\t\t\tArrays.fill(cnt, 0, nCl, 0);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tcnt[cls[i]]++;\n\t\t\t}\n\t\t\tfor (int i = 1; i < nCl; i++) {\n\t\t\t\tcnt[i] += cnt[i - 1];\n\t\t\t}\n\n\t\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\t\tint curSuff = aux[i];\n\t\t\t\tarr[--cnt[cls[curSuff]]] = curSuff;\n\t\t\t}\n\n\t\t\t// aux - new classes\n\t\t\taux[arr[0]] = 0;\n\t\t\tnCl = 1;\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tint curPos = arr[i];\n\t\t\t\tint prevPos = arr[i - 1];\n\t\t\t\tif (cls[curPos] == cls[prevPos]) {\n\t\t\t\t\tint tmpCurPos = curPos + h;\n\t\t\t\t\tif (tmpCurPos >= n)\n\t\t\t\t\t\ttmpCurPos -= n;\n\t\t\t\t\tprevPos += h;\n\t\t\t\t\tif (prevPos >= n)\n\t\t\t\t\t\tprevPos -= n;\n\t\t\t\t\tif (cls[tmpCurPos] != cls[prevPos])\n\t\t\t\t\t\tnCl++;\n\t\t\t\t} else {\n\t\t\t\t\tnCl++;\n\t\t\t\t}\n\t\t\t\taux[curPos] = nCl - 1;\n\t\t\t}\n\n\t\t\tint[] tmp = aux;\n\t\t\taux = cls;\n\t\t\tcls = tmp;\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\tvoid solve() throws IOException {\n\t\tString ss = nextToken();\n\t\tint n = ss.length();\n\t\tint[] s = new int[n];\n\t\tint[] bal = new int[n + 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ts[i] = ss.charAt(i) == '(' ? 0 : 1;\n\t\t\tif (s[i] == 0) {\n\t\t\t\tbal[i + 1] = bal[i] + 1;\n\t\t\t} else {\n\t\t\t\tbal[i + 1] = bal[i] - 1;\n\t\t\t}\n\t\t}\n\t\tint[] sa = buildSuffixArray(s, 2);\n\t\tint[] order = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\torder[sa[i]] = i;\n\t\t}\n\t\tint minBal = 0;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tminBal = Math.min(minBal, bal[i]);\n\t\t}\n\n\t\tint[] minSuff = new int[n + 1];\n\t\tint[] minPref = new int[n + 1];\n\t\tminPref[0] = bal[0];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tminPref[i] = Math.min(minPref[i - 1], bal[i]);\n\t\t}\n\t\tminSuff[n] = bal[n];\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tminSuff[i] = Math.min(minSuff[i + 1], bal[i]);\n\t\t}\n\n\t\tint pos = -1;\n\t\t// System.err.println(Arrays.toString(bal) + \" \" + minBal);\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t// if ((bal[n] <= 0 && bal[i] == minBal)\n\t\t\t// || (bal[n] > 0 && bal[i] <= minBal + bal[n])) {\n\t\t\tboolean cond;\n\t\t\tif (bal[n] >= 0) {\n\t\t\t\tcond = minSuff[i] - bal[i] >= 0;\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tcond &= minPref[i - 1] + (bal[n] - bal[i]) >= 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcond = (minSuff[i] - bal[i]) >= bal[n];\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tcond &= minPref[i - 1] + (bal[n] - bal[i]) >= bal[n];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cond) {\n\n\t\t\t\tif (pos == -1) {\n\t\t\t\t\tpos = i;\n\t\t\t\t} else {\n\t\t\t\t\tif (order[i % n] <= order[pos]) {\n\t\t\t\t\t\tpos = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < -bal[n]; i++) {\n\t\t\tout.print('(');\n\t\t}\n\t\tout.print(ss.substring(pos));\n\t\tout.print(ss.substring(0, pos));\n\t\tfor (int i = 0; i < bal[n]; i++) {\n\t\t\tout.print(')');\n\t\t}\n\t\tout.println();\n\t}\n\n\t// ((()())\n\n\tBuffering() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Buffering();\n\t}\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e) {\n\t\t\t\teof = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\teof = true;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
        }
    ]
}